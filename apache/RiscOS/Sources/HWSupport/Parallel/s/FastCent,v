head	4.7;
access;
symbols
	Parallel-0_79:4.7
	Parallel-0_78:4.7
	Parallel-0_77:4.7
	Parallel-0_76:4.7
	Parallel-0_75:4.6
	Parallel-0_74:4.6
	Parallel-0_73:4.5
	Parallel-0_72:4.5
	Parallel-0_71:4.5
	Parallel-0_70:4.5
	Parallel-0_69:4.5
	Parallel-0_68:4.5
	Parallel-0_67:4.5
	Parallel-0_66:4.5
	Parallel-0_65:4.4
	kbracey_32bit_merge:4.2.2.3
	Parallel-0_64:4.4
	Parallel-0_60-4_13_2_5:4.2.2.3
	Parallel-0_60-4_13_2_4:4.2.2.2
	Parallel-0_60-4_13_2_3:4.2.2.1
	Parallel-0_63:4.3
	Parallel-0_60-4_13_2_2:4.2.2.1
	Alpnet_approved:4.2
	Parallel-0_62:4.2
	dellis_autobuild_BaseSW:4.2
	Parallel-0_61:4.2
	Parallel-0_60-4_13_2_1:4.2.2.1
	kbracey_32bit:4.2.0.2
	sbrodie_sedwards_16Mar2000:4.2
	Parallel-0_60:4.2
	Parallel-0_59:4.2
	dcotton_autobuild_BaseSW:4.5
	Parallel-0_58:4.2
	Parallel-0_57:4.2
	Parallel-0_56:4.2
	Parallel-0_55:4.2
	Parallel-0_54:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	Parallel-0_53:4.2
	Parallel-0_52:4.1
	Parallel-0_51:4.1
	FunaiNC2_Parallel-0_50:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	wturner_parallel-0_47:4.1.4.1
	wturner_parallel-0_46:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Ursula:4.1.0.4
	Spin_merge_16May97:4.1.7.1
	Daytona_bp:4.1
	Ursula_bp:4.1
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2012.06.23.16.24.15;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	NqgW20IuiIZMLQ9w;

4.6
date	2011.06.22.00.52.49;	author jlee;	state Exp;
branches;
next	4.5;
commitid	G7LnLvkSoQ9EpBov;

4.5
date	2001.03.16.15.59.13;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2001.01.09.14.10.03;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.11.01.13.59.40;	author arodger;	state Exp;
branches;
next	4.2;

4.2
date	98.10.29.10.52.31;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.36.26;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.07.23.20.43.04;	author sbrodie;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2000.11.29.12.41.40;	author sbrodie;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2001.01.09.11.39.29;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.36.26;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.30.22;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.08.18.15.12.02;	author wturner;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.54.51;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.49.33;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Fix stack imbalance in ioeb_busy and have a spring clean
Now uses OS_Memory throughout to determine controller addresses rather than calling the private HAL_ControllerAddress API.
Be devious in all the register pokes by making HardwareBase be roughly half way between the two sets of standard parallel registers and ECP mode ones, so they're always in range for an immediate offset of LDRB/STRB so the code doesn't thrash the literal pool so much.
Where possible, eliminate HAL conditional code by initialising HardwareBase in the non HAL case thus simplifying code paths a bit.
Be a bit less ugly in the 0.5us delays, since the combo chip is using Type B cycles a dummy read of a SuperIO chip will waste 0.5us rather than needing to back calculate the IOEB registers.
Expand tabs, use OSBytes header file.

Version 0.76. Tagged as 'Parallel-0_76'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > FastCent

; Driver for chips which support fast Centronics mode (eg. C&T 82C735 or
; SMC FDC37C665).  On output the chip will handshake for us using STROBE
; and BUSY and will normally use an on chip FIFO.

; Define default settings for control registers.

fast_ctrl_output        * pp_ctrl_slctin :OR: pp_ctrl_init
fast_ecr_output         * pp_ecr_flag_FIFO :OR: pp_ecr_errintdis

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: FastDevice
;
; in:   r0  = reason code
;       r8  = private word
;       wp -> workspace
;
; out:  V clear, registers setup correctly
;       V set, r0 -> error block
;
; This entry point is provided to allow the device to do what it needs to
; do, this is called by DeviceFS to pass events and control operations to the
; device driver.
;

FastDevice      ROUT

                Push    lr
                SavePSR lr
                BIC     lr, lr, #V_bit+ C_bit                   ; just ensure that all is OK
                Push    lr
                JumpAddress lr, fast_device_call_exit, forward

                CMP     r0, #(%10-%00)/4
                ADDCC   pc, pc, r0, LSL #2                      ; despatch the event
                B       %10                                     ; if not valid then give an error
00
                B       fast_open                               ; open a stream
                B       fast_close                              ; close the stream
                B       fast_wakeupTX                           ; wake up because someones transfering
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
                B       common_createTX                         ; create buffer for TX
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
                B       fast_created                            ; output or input stream created
                B       ioeb_monitorTX                          ; check sending is okay
                MOV     pc, lr                                  ; monitor rx
                MOV     pc, lr                                  ; ioctl
10
                ADRL    r0, ErrorBlock_Parallel_BadCall         ; if not within valid range
              [ international
                BL      MakeError
              |
                CMP     r0, #&80000000                          ; set V
                CMNVC   r0, #&80000000
              ]
fast_device_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,f
                Pull    pc

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: fast_open
;
; in:   r0  = reason code
;       r2  = external handle
;       r3  = flags
;       r6 -> special field block
;
; out:  r1  = internal handle
;
; This call attempts to open a stream onto the specified device.
;

fast_open       Entry   "r0,r1"
                Debug   open,"fast_open"
 [ StorkPower
                BL      SetPower_On             ;Should be powered down, so power up
 ]
                MOV     r0, #IOEB_PrinterIRQ_DevNo
                ADRL    r1, fast_irqwrite
                BL      common_open
 [ StorkPower
                BLVS    SetPower_Off            ;If openning failed, try powering down. If failure occurred
                                                ;because port was in use, the service call will be faulted
                                                ;and the port will remain powered (as it should be).
 ]
                EXIT



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: fast_close
;
; in:   r0  = reason code
;       r2  = internal handle
;
; out:  -
;
; This routine handles the closing of a stream.
;

fast_close      Entry   "r0-r2"
                Debug   close,"fast_close"
                MOV     r0, #IOEB_PrinterIRQ_DevNo
                ADRL    r1, fast_irqwrite
                MOV     r2, #0
                BL      common_close
                BL      IOEBreset
 [ StorkPower
                BL      SetPower_Off            ;Will be powered up, so power down
 ]
                EXIT



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: fast_created
;
; in:   r0 = reason code (11)
;       r2 = internal handle
;       r3 = buffer handle
;
; out:  -
;
; This routine is called when an input or output stream has been created.
;

fast_created    EntryS  "r0-r2"

                Debug   open,"fast_created, buffer handle =",r3

                STR     r3, BufferHandle        ; store buffer handle for read or write

 [ FastBufferMan
                MOV     r0, r3
                SWI     XBuffer_InternalInfo
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT    VS
                STR     r0, BufferId
                STR     r1, BuffManService
                STR     r2, BuffManWkSpace
 ]

                ClearPINTR r0,lr                ; clear pending interrupt

                LDR     r1, HardwareBase
                
                SETPSR  I_bit,lr                ; disable IRQs

                MOV     r0, #fast_ecr_output
                STRB    r0, [r1, #pp_ecr]

                MOV     r0, #fast_ctrl_output   ; set up for output
                STRB    r0, [r1, #pp_ctrl]

                EXITS   ,cf
g


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: fast_wakeupTX
;
; in:   r0  = reason code
;       r2  = internal handle
;
; out:  -
;
; Handle waking up the device, something has happened to it.
;

fast_wakeupTX   EntryS  "r0"

 [ HAL
                Push    "r1-r3,r9,r12"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                MOV     lr, pc
                LDR     pc, HAL_IRQEnable
                Pull    "r1-r3,r9,r12"
 |
                MOV     r0, #IOC                ; just enable device interrupts so we can fill FIFO

                SETPSR  I_bit+F_bit,lr          ; disable IRQs and FIQs round this bit

                LDRB    lr, [r0, #IOCIRQMSKA]
                ORR     lr, lr, #pbusy_bit
                STRB    lr, [r0, #IOCIRQMSKA]
  ]
                EXITS   ,cf



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This interrupt is generated when the parallel port FIFO contains a number of
; bytes less than or equal to the configured threshold (set up by the system
; kernel).  All we have to do is fill the FIFO and exit.  If we run out of
; bytes to send then we disable the interrupt and wait to be woken up by
; fast_wakeupTX.
;

fast_irqwrite   EntryS

                ClearPINTR r0,r1                                ; clear interrupt

                MOV     r0, #fast_ecr_output
                LDR     r1, HardwareBase
                STRB    r0, [r1, #pp_ecr]
10
 [ FastBufferMan
                MOV     r0, #BufferReason_RemoveByte
                LDR     r1, BufferId
                CallBuffMan
 |
                SavePSR r2
                BIC     r2, r2, #C_bit + V_bit                  ; clear C, V
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
                                                                ; we've already saved lr_svc, so we can junk it now)
                RestPSR lr                                      ; change to SVC mode with C and V clear
                LDR     r1, StreamHandle
                Push    "lr"                                    ; preserve SVC_LR
                SWI     XDeviceFS_TransmitCharacter             ; get character to send
                Pull    "lr"

                ORRCS   r2, r2, #C_bit                          ; ensure C flag reflected correctly
                RestPSR r2                                      ; back to original mode (IRQ or SVC)
 ]
                BCS     %FT20                                   ; if no byte to send then disable IRQ and wait for wakeupTX

                LDR     lr, HardwareBase
                STRB    byte, [lr, #pp_fifo]                    ; send byte (we know FIFO has space for at least 1 byte)

                LDRB    lr, [lr, #pp_ecr]
                TST     lr, #pp_ecr_full                        ; if FIFO is still not full then
                BEQ     %BT10                                   ; send another byte
                EXITS
20
 [ HAL
                Push    "r9,r12"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                MOV     lr, pc
                LDR     pc, HAL_IRQDisable
                Pull    "r9,r12"
 |
                MOV     r3, #IOC

                SETPSR  F_bit,lr                                ; Disable FIQs

                LDRB    lr, [r3, #IOCIRQMSKA]
                BIC     lr, lr, #pbusy_bit                      ; disable printer interrupts
                STRB    lr, [r3, #IOCIRQMSKA]
 ]
                EXITS   ,cf                                     ; no character so exit restoring FIQs

                END

@


4.6
log
@Add support for HAL builds
Detail:
  s/Parallel - Use HAL_ControllerAddress to get the address of the 82C710. IOMD IRQ numbers are assumed.
  s/Common - Use HAL_ControllerAddress to get the address of IOMD when measuring the CPU speed
  s/FastCent, s/IOEB - Use HardwareBase for hardware access and HAL calls for IRQ handling instead of fixed IOC/IOMD address & direct memory poking
  s/IOEB, s/Parallel - HAL version of UpdateIOEBCtrl gets copied into the module workspace to allow it to be used with the old calling standard (since we need to look up the C710 address)
  s/IOC - Add code that'll warn if this file gets built for a HAL target
Admin:
  Tested on RiscPC via IOMD ROM softload.
  Code is rather rough and could do with cleaning up in places (e.g. direct poking of timer registers in s/Common, and less-than-optimal register save/restore in ClearPINTR macro)


Version 0.74. Tagged as 'Parallel-0_74'
@
text
@d172 2
a175 6
                LDR     lr, =pp_ecr
 [ HAL
                ASSERT  pp_base = 0
                LDR     r1, HardwareBase
                ADD     lr, lr, r1
 ]
d177 1
a177 1
                STRB    r0, [lr]
a178 3
 [ :LNOT: HAL
                LDR     r1, =pp_base
 ]
d180 1
a180 1
                STRB    r0, [r1, #pp_ctrl-pp_base]
a199 2
                SETPSR  I_bit+F_bit,lr          ; disable IRQs and FIQs round this bit

d209 3
d233 1
a233 3
                LDR     r0, =pp_ecr                             ; reenable service interrupts in pp_ecr
 [ HAL
                ASSERT  pp_base = 0
d235 1
a235 4
                ADD     r0, r0, r1
 ]
                MOV     r1, #fast_ecr_output
                STRB    r1, [r0]
a257 3
                LDR     r3, =pp_fifo
 [ HAL
                ASSERT  pp_base = 0
d259 3
a261 4
                ADD     r3, r3, lr
 ]                
                STRB    byte, [r3]                              ; send byte (we know FIFO has space for at least 1 byte)
                LDRB    lr, [r3, #pp_ecr-pp_fifo]
a265 2
                SETPSR  F_bit,lr                                ; Disable FIQs

d275 3
a281 1
 
a283 1

@


4.5
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.66. Tagged as 'Parallel-0_66'
@
text
@d175 5
d183 3
a185 1
                LDR     lr, =pp_ctrl
d187 1
a187 1
                STRB    r0, [lr]
d209 8
d221 1
a221 1

d240 5
d270 5
d283 8
d295 2
a296 1

@


4.4
log
@  kbracey_32bit branch taken.
Detail:
  This is the result of the 32-bit branch merge.
Admin:
  This module has received modest testing.  It has not been exhaustively
    tested.  Projects taking this version should be careful with it as it
    may contain bugs.

Version 0.64. Tagged as 'Parallel-0_64'
@
text
@d98 1
a98 1
fast_open       ENTRY   "r0,r1"
d127 1
a127 1
fast_close      ENTRY   "r0-r2"
@


4.3
log
@  added device identification.
Detail:
  this allows the host to query the peripheral as to what it is.  As per
  IEEE1284-1994 spec.
Admin:
  This has not been excessivly tested as it does not interfere with the
  usual workings of the parallel port.  It has been tested with the
  lexmark Z12 and a HP 950

Version 0.63. Tagged as 'Parallel-0_63'
@
text
@d44 2
d47 3
d57 3
a59 3
                MOVS    pc, lr
                MOVS    pc, lr
                MOVS    pc, lr
d61 4
a64 4
                MOVS    pc, lr
                MOVS    pc, lr
                MOVS    pc, lr
                MOVS    pc, lr
d67 2
a68 2
                MOVS    pc, lr                                  ; monitor rx
                MOVS    pc, lr                                  ; ioctl
d71 12
a82 3
                DoError                                         ; then generate an error


d154 1
a154 1
fast_created    ENTRY   "r0-r2"
d163 1
a163 1
                STRVS   r0, [sp]
d172 1
a172 3
                MOV     lr, pc
                TST     lr, #I_bit              ; if IRQs enabled then
                TEQEQP  lr, #I_bit              ;   disable them
d182 2
a183 2
                EXITS

d198 1
a198 1
fast_wakeupTX   ENTRY   "r0"
d200 1
a200 2
                ORR     lr, lr, #I_bit + F_bit  ; disable IRQs and FIQs round this bit
                TEQP    lr, #0
d207 1
a207 1
                EXITS
d220 1
a220 1
fast_irqwrite   ENTRY
d233 4
a236 3
                MOV     r2, pc
                BIC     r2, r2, #C_bit + V_bit                  ; clear C&V for entering mode
                ORR     lr, r2, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
d238 1
a238 1
                TEQP    lr, #0                                  ; change to SVC mode with C and V clear
d245 1
a245 1
                TEQP    r2, #0                                  ; back to original mode (IRQ or SVC)
d256 1
a256 3
                MOV     lr, pc
                TST     lr, #F_bit                              ; FIQs currently enabled?
                TEQEQP  lr, #F_bit                              ; ensure that they are no longer
d263 1
a263 1
                EXITS                                           ; no character so exit restoring FIQs
@


4.2
log
@New Japanese messages.
FastParallel: device no longer faults monitor RX/TX calls.

Version 0.53. Tagged as 'Parallel-0_53'
@
text
@d24 1
a24 1
fast_ecr_output         * 2_010:SHL:5 :OR: pp_ecr_errintdis
@


4.2.2.1
log
@  First cut at 32-bit compatibility.
Detail:
  Lots of changes have been required in this module as it manipulates
    the PSR all over the place in various interesting ways.
Admin:
  Built, but not tested yet.

Version 0.60, 4.13.2.1. Tagged as 'Parallel-0_60-4_13_2_1'
@
text
@a43 2
                Push    lr
                SavePSR lr
a44 3
                Push    lr
                ADR     lr, fast_device_call_exit

d52 3
a54 3
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
d56 4
a59 4
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
d62 2
a63 2
                MOV     pc, lr                                  ; monitor rx
                MOV     pc, lr                                  ; ioctl
d68 1
a68 6
fast_device_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,f
                Pull    pc
d140 1
a140 1
fast_created    EntryS  "r0-r2"
d149 1
a149 1
                STRVS   r0, [sp, #Proc_RegOffset]
d158 3
a160 1
                SETPSR  I_bit,lr                ; disable IRQs
d186 1
a186 1
fast_wakeupTX   EntryS  "r0"
d188 2
a189 1
                SETPSR  I_bit+F_bit,lr          ; disable IRQs and FIQs round this bit
d209 1
a209 1
fast_irqwrite   EntryS
d222 3
a224 4
                SavePSR r2
                BIC     r2, r2, #C_bit + V_bit                  ; clear C, V
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
d226 1
a226 1
                RestPSR lr                                      ; change to SVC mode with C and V clear
d233 1
a233 1
                RestPSR r2                                      ; back to original mode (IRQ or SVC)
d244 3
a246 1
                SETPSR  F_bit,lr                                ; Disable FIQs
@


4.2.2.2
log
@  Major stack imbalance fixed.
  EXITS macros passed the fields parameter.
Detail:
  EXITS does NOT restore the c part of the CPSR only the flags.  Since
    this module was relying on EXITS to reset IRQ/FIQ/mode bits, this
    module wasn't going to work very well.
  The error generator on the DeviceFS entry point was severely broken in
    that it would remove 10 words from the stack that weren't actually
    there.
Admin:
  Built, but untested.


Version 0.60, 4.13.2.4. Tagged as 'Parallel-0_60-4_13_2_4'
@
text
@d48 1
a48 1
                JumpAddress lr, fast_device_call_exit, forward
d71 2
a72 6
              [ international
                BL      MakeError
              |
                CMP     r0, #&80000000                          ; set V
                CMNVC   r0, #&80000000
              ]
d178 2
a179 2
                EXITS   ,cf
g
d203 1
a203 1
                EXITS   ,cf
d259 1
a259 1
                EXITS   ,cf                                     ; no character so exit restoring FIQs
@


4.2.2.3
log
@  Merge of latest trunk version to the 32-bit branch.
Detail:
  Merged here for testing before committing this to the trunk
    as the master version.
Admin:
  Untested.

Version 0.60, 4.13.2.5. Tagged as 'Parallel-0_60-4_13_2_5'
@
text
@d24 1
a24 1
fast_ecr_output         * pp_ecr_flag_FIFO :OR: pp_ecr_errintdis
@


4.1
log
@Initial revision
@
text
@d61 3
@


4.1.4.1
log
@Parallel device driver modified for Phoebe hardware
NOT backwards compatible.
@
text
@a188 5
 [ IOMD2IRQs
 		LDR	lr, [r0, #IOMD2_INTENBL]
 		ORR	lr, lr, #iomd2_pbusy_bit
 		STR	lr, [r0, #IOMD2_INTENBL]
 |
d192 1
a192 1
 ]
a245 5
 [ IOMD2IRQs
 		LDR	lr, [r3, #IOMD2_INTENBL]
 		BIC	lr, lr, #iomd2_pbusy_bit
 		STR	lr, [r3, #IOMD2_INTENBL]
 |
a248 1
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.19;
access;
symbols
	Parallel-0_79:4.19
	Parallel-0_78:4.19
	Parallel-0_77:4.18
	Parallel-0_76:4.17
	Parallel-0_75:4.16
	Parallel-0_74:4.15
	Parallel-0_73:4.14
	Parallel-0_72:4.14
	Parallel-0_71:4.14
	Parallel-0_70:4.14
	Parallel-0_69:4.14
	Parallel-0_68:4.13
	Parallel-0_67:4.12
	Parallel-0_66:4.11
	Parallel-0_65:4.10
	kbracey_32bit_merge:4.7.2.4
	Parallel-0_64:4.9
	Parallel-0_60-4_13_2_5:4.7.2.4
	Parallel-0_60-4_13_2_4:4.7.2.3
	Parallel-0_60-4_13_2_3:4.7.2.2
	Parallel-0_63:4.8
	Parallel-0_60-4_13_2_2:4.7.2.1
	Alpnet_approved:4.7
	Parallel-0_62:4.7
	dellis_autobuild_BaseSW:4.7
	Parallel-0_61:4.7
	Parallel-0_60-4_13_2_1:4.7.2.1
	kbracey_32bit:4.7.0.2
	sbrodie_sedwards_16Mar2000:4.7
	Parallel-0_60:4.7
	Parallel-0_59:4.6
	dcotton_autobuild_BaseSW:4.14
	Parallel-0_58:4.5
	Parallel-0_57:4.5
	Parallel-0_56:4.5
	Parallel-0_55:4.5
	Parallel-0_54:4.5
	mstphens_UrsulaRiscPCBuild_20Nov98:4.4
	Ursula_RiscPC:4.4.0.6
	Parallel-0_53:4.5
	Parallel-0_52:4.5
	Parallel-0_51:4.5
	FunaiNC2_Parallel-0_50:4.1.7.8
	rthornb_UrsulaBuild-19Aug1998:4.4
	UrsulaBuild_FinalSoftload:4.4
	wturner_parallel-0_47:4.4.2.1
	wturner_parallel-0_46:4.4
	rthornb_UrsulaBuild-12Aug1998:4.4
	aglover_UrsulaBuild-05Aug1998:4.4
	rthornb_UrsulaBuild-29Jul1998:4.4
	rthornb_UrsulaBuild-22Jul1998:4.4
	rthornb_UrsulaBuild-15Jul1998:4.4
	rthornb_UrsulaBuild-07Jul1998:4.4
	rthornb_UrsulaBuild-17Jun1998:4.4
	rthornb_UrsulaBuild-03Jun1998:4.4
	rthornb_UrsulaBuild-27May1998:4.4
	rthornb_UrsulaBuild-21May1998:4.4
	rthornb_UrsulaBuild_01May1998:4.4
	afrost_NC2_Generic:4.1.7.8
	afrost_Funai01-33:4.1.7.8
	Spinner_RCA116:4.1.7.8
	Spinner_B20_2:4.1.7.5
	Spinner_19_3:4.1.7.5
	Spinner_B18:4.1.7.5
	Spinner_B17:4.1.7.5
	Spinner_B15:4.1.7.5
	Spinner_B14:4.1.7.4
	Spinner_B13:4.1.7.4
	Spinner_B12:4.1.7.4
	Spinner_B10:4.1.7.3
	Daytona:4.4.0.4
	Ursula:4.4.0.2
	Spin_merge_16May97:4.1.7.2
	Daytona_bp:4.4
	Ursula_bp:4.4
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.2
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.2.2.1
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.8
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.19
date	2012.12.21.13.13.05;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	6AX7FQ9jP8duT5xw;

4.18
date	2012.12.20.08.36.04;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	9ssBEbFq3jtroWww;

4.17
date	2012.06.23.16.24.15;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	NqgW20IuiIZMLQ9w;

4.16
date	2011.07.18.22.41.34;	author jlee;	state Exp;
branches;
next	4.15;
commitid	5mbikVDdCwgOO3sv;

4.15
date	2011.06.22.00.52.49;	author jlee;	state Exp;
branches;
next	4.14;
commitid	G7LnLvkSoQ9EpBov;

4.14
date	2001.08.29.13.40.27;	author mboura;	state Exp;
branches;
next	4.13;

4.13
date	2001.08.03.14.53.50;	author mboura;	state Exp;
branches;
next	4.12;

4.12
date	2001.04.12.16.17.32;	author arodger;	state Exp;
branches;
next	4.11;

4.11
date	2001.03.16.15.59.13;	author sbrodie;	state Exp;
branches;
next	4.10;

4.10
date	2001.01.10.15.35.57;	author arodger;	state Exp;
branches;
next	4.9;

4.9
date	2001.01.09.14.10.03;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	2000.11.01.13.59.40;	author arodger;	state Exp;
branches;
next	4.7;

4.7
date	99.10.26.08.34.12;	author kbracey;	state Exp;
branches
	4.7.2.1;
next	4.6;

4.6
date	99.10.25.17.28.02;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	98.10.19.16.10.29;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	97.05.16.11.14.57;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	97.05.07.12.02.43;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.02.11.10.29;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.36.27;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.7.2.1
date	2000.07.23.20.43.04;	author sbrodie;	state Exp;
branches;
next	4.7.2.2;

4.7.2.2
date	2000.11.22.11.58.32;	author sbrodie;	state Exp;
branches;
next	4.7.2.3;

4.7.2.3
date	2000.11.29.12.41.40;	author sbrodie;	state Exp;
branches;
next	4.7.2.4;

4.7.2.4
date	2001.01.09.11.39.29;	author sbrodie;	state Exp;
branches;
next	;

4.4.2.1
date	98.08.18.15.12.03;	author wturner;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.36.27;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.30.26;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.14.36.41;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.12.51.41;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.54.54;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.49.35;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.20.13.33.14;	author scormie;	state Exp;
branches
	4.1.7.2.2.1;
next	4.1.7.3;

4.1.7.3
date	97.04.30.18.19.00;	author scormie;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.05.27.12.46.50;	author jcoxhead;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.07.02.11.06.36;	author arodger;	state Exp;
branches;
next	4.1.7.6;

4.1.7.6
date	97.07.31.16.27.44;	author scormie;	state Exp;
branches;
next	4.1.7.7;

4.1.7.7
date	97.08.19.16.59.41;	author scormie;	state Exp;
branches;
next	4.1.7.8;

4.1.7.8
date	97.08.26.17.37.41;	author arodger;	state Exp;
branches;
next	;

4.1.7.2.2.1
date	97.04.23.12.32.30;	author blaughto;	state Exp;
branches;
next	;


desc
@@


4.19
log
@Fix printing in HAL case
ioeb_busy: saved a whole instruction in the NE case
ioeb_irqwrite: we are entered with R3=IO controller, which is not useful, so reload HardwareBase each time
ioeb_strobe: the call to the HAL corrupts the byte we're printing, so stack it either side of the call

Tested printing some geometrical shapes from a PrintOut file from Draw.
Used *COPY MyTest parallel: and
     *COPY MyTest fastparallel:
and also checked with !PICSuite that the Parallel_ SWIs allow low level access to the control register (used for bit bashing).

Version 0.78. Tagged as 'Parallel-0_78'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > IOEB

;time delay multipliers (times approx 0.5 us) for handshaking timeouts
;
TimeoutPACKhigh     *  40   ;40
TimeoutBusyAfterAck *  40   ;20

; Define information about the printer control port.

pp_imm            * &800                ; offset so index immediate is in +4k -4k range for all pp regs
pp_delay          * pp_stat             ; a register that is not read sensitive for tiny delays

pp_data           * 0  - pp_imm         ; data port in non-FIFO mode
pp_stat           * 4  - pp_imm         ; status register
pp_ctrl           * 8  - pp_imm         ; control register
;pp_EPP           * 12 - pp_imm         ; EPP mode not enabled
;pp_EPP_Data0     * 16 - pp_imm 
;pp_EPP_Data1     * 20 - pp_imm 
;pp_EPP_Data2     * 24 - pp_imm 
;pp_EPP_Data3     * 28 - pp_imm 
pp_fifo           * (&400 * 4) - pp_imm ; FIFO data port (may depend on the chip being used)
pp_ecr            * (&402 * 4) - pp_imm ; extended control register

pp_stat_notbusy         * 1:SHL:7       ; set => ready for data,                clear => busy
pp_stat_ack             * 1:SHL:6       ; goes low during acknowledge pulse
pp_stat_pe              * 1:SHL:5       ; set => no paper,                      clear => paper
pp_stat_slct            * 1:SHL:4       ; set => online,                        clear => off line
pp_stat_error           * 1:SHL:3       ; set => no error,                      clear => error
;pp_stat_2              * 1:SHL:2       ; hardwired low
;pp_stat_1              * 1:SHL:1       ; hardwired low
pp_EPP_timeout          * 1:SHL:0       ; set => >= 10 us timout occurred       clear => no timeout

;pp_ctrl_7              * 1:SHL:7       ; hardwired low
;pp_ctrl_6              * 1:SHL:6       ; hardwired low
pp_ctrl_dir             * 1:SHL:5       ; set => input, clear => output
pp_ctrl_irqen           * 1:SHL:4       ; set => irq gen when ACK low,          clear => irq disabled
pp_ctrl_slctin          * 1:SHL:3       ; set => select printer,                clear => off line
pp_ctrl_init            * 1:SHL:2       ; set => normal operation,              clear => reset printer (min 50µs)
pp_ctrl_autofd          * 1:SHL:1       ; set => generate auto feed,            clear => no autofeed
pp_ctrl_strobe          * 1:SHL:0       ; set => active low pulse,              clear => no strobe

; The following lines have opposite sense to the IEEE 1284 standard conventions:
; pp_stat_notbusy  <->  Busy
; pp_ctrl_slctin   <->  nSelectIn
; pp_ctrl_init     <->  nInit
; pp_ctrl_autofd   <->  nAutoFd
; pp_ctrl_strobe   <->  nStrobe


; IEEE 1284 extensibility request values
extensibility_request_revnibble * 0     ; request Reverse Nibble Mode
extensibility_request_device_id * 4     ; request Device ID using Reverse Nibble Mode
extensibility_acknowledge_mask  * pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error :OR: pp_stat_ack
extensibility_acknowledge_value * pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error

; these flags control the mode at which the parallel device should be driven, see the COMBO chip spec
; pg. 99 FDC37C669 specification.
pp_ecr_flag_FIFO        * 2_010:SHL:5   ; use FIFO mode
pp_ecr_flag_default     * 2_001:SHL:5   ; use default parallel mode

pp_ecr_mode             * 7:SHL:5       ; mask out mode bits
pp_ecr_errintdis        * 1:SHL:4       ; set => irq disabled,                  clear => irq gen on error
pp_ecr_dmaen            * 1:SHL:3       ; set => DMA enabled,                   clear => DMA disabled
pp_ecr_servintdis       * 1:SHL:2       ; set => irq disabled,                  clear => irq gen on service interrupt
pp_ecr_full             * 1:SHL:1       ; set => FIFO is full,                  clear => >=1 free byte in FIFO
pp_ecr_empty            * 1:SHL:0       ; set => FIFO is empty,                 clear => >=1 byte in FIFO

; Define default settings for control registers.

pp_ctrl_default         * pp_ctrl_init :OR: pp_ctrl_slctin :OR: pp_ctrl_autofd
pp_ecr_default          * pp_ecr_flag_default :OR: pp_ecr_errintdis

ioeb_ctrl_output        * pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
ioeb_ctrl_input         * pp_ctrl_dir :OR: pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init :OR: pp_ctrl_autofd

ioctl_reason_size       * 1
ioctl_reason_data       * 2
ioctl_reason_status     * 3
ioctl_reason_revnibble_size * 4
ioctl_reason_revnibble_data * 5

ioctl_reason_mask       * &FFFF
ioctl_group_parallel    * 1
ioctl_header_read       * 1:SHL:6
ioctl_header_write      * 1:SHL:7

        [ AdvancedErrorHandling
; values for UpCall_DeviceError

UpCall_DeviceError      * &10500
UpCallDeviceErrorFlag_FatalError    * 1:SHL:0
UpCallDeviceErrorFlag_UseErrorBlock * 1:SHL:1
        ]

; Clear printer interrupt depending on hardware type (IOMD has clear bit).
                MACRO
$label          ClearPINTR $v0,$v1
 [ HAL
$label
                MRS     $v0, CPSR ; Necessary?
                Push    "r0-r3,r9,r12,lr" ; This could be improved!
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                MOV     lr, pc
                LDR     pc, HAL_IRQClear
                Pull    "r0-r3,r9,r12,lr"
                MSR     CPSR_c, $v0
 |
$label          LDRB    $v0, InterruptBit
                LDR     $v1, InterruptClear
                STRB    $v0, [$v1]
 ]
                MEND

; this macro delays for 5us
                MACRO
$label          PulseDelay $v0

$label          ROUT
                LDR     $v0, LoopFactor         ; get the processor speed
                MOV     $v0, $v0, LSR #3
10
                SUBS    $v0, $v0, #1
                BGT     %BT10
                MEND


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEBdevice
;
; in:   r0  = reason code
;       r8  = private word
;       wp -> workspace
;
; out:  V clear, registers setup correctly
;       V set, r0 -> error block
;
; This entry point is provided to allow the IOEB device to do what it needs to
; do, this is called by DeviceFS to pass events and control operations to the
; device driver.
;

IOEBdevice      ROUT

                Push    lr
                SavePSR lr
                BIC     lr, lr, #V_bit+ C_bit                   ; just ensure that all is OK
                Push    lr
                JumpAddress lr, device_call_exit, forward       ; load return address
                CMP     r0, #(%10-%00)/4
                ADDCC   pc, pc, r0, LSL #2                      ; despatch the event
                B       %10                                     ; if not valid then give an error
00
                B       ioeb_open                               ; open a stream
                B       ioeb_close                              ; close the stream
                B       ioeb_wakeupTX                           ; wake up because someones transfering
                MOV     pc, lr                                  ; wakeup RX
                MOV     pc, lr                                  ; sleep RX
                MOV     pc, lr                                  ; enum dir
                B       common_createTX                         ; create buffer for TX
                B       common_createRX                         ; create buffer for RX
                MOV     pc, lr                                  ; halt
                B       ioeb_resume                             ; start sender sending again
                MOV     pc, lr                                  ; end of data
                B       ioeb_created                            ; output or input stream created
                B       ioeb_monitorTX                          ; check sending is okay
                MOV     pc, lr                                  ; monitor rx
                B       ioeb_ioctl                              ; ioctl
10
                ADRL    r0, ErrorBlock_Parallel_BadCall         ; if not within valid range
              [ international
                BL      MakeError
              |
                CMP     r0, #&80000000                          ; set V
                CMNVC   r0, #&80000000
              ]

device_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,f
                Pull    pc

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEBreset
;
; in:   -
;
; out:  -
;
; This routine allows the module to reset the hardware being controlled
; by the device to a nice set of defaults.
;

IOEBreset       EntryS   "r0-r2"

                ClearPINTR r0,r1                                ; attempt to clear any pending interrupts

                MOV     r0, #9
                MOV     r1, #34<<8                              ; SuperIO controller
                SWI     XOS_Memory
                LDR     r0, =(&278 * 4) + pp_imm                ; Offset to parallel port registers
                LDRVS   r1, =C710                               ; Address pre-HAL era
                ADD     r0, r1, r0
                STR     r0, HardwareBase                        ; setup the hardware base for device

        [ FastCentronics
                LDRB    r1, Flags
                TST     r1, #f_UseFIFO                          ; if FIFO hardware is there then
                MOVNE   r1, #pp_ecr_default                     ; program default value
                STRNEB  r1, [r0, #pp_ecr]
        ]

                MOV     r1, #pp_ctrl_default                    ; program default value into control register
                STRB    r1, [r0, #pp_ctrl]

                EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_open
;
; in:   r0  = reason code
;       r2  = external handle
;       r3  = flags
;       r6 -> special field block
;
; out:  r1  = internal handle
;
; This call attempts to open a stream onto the specified device.
;

ioeb_open       Entry   "r0,r1"
                Debug   open,"ioeb_open"
 [ StorkPower
                BL      SetPower_On             ;Should be powered down, so power up
 ]
                LDRB    r0, DeviceNo
                TST     r3, #&01
                ADREQL  r1, ioeb_irqread
                ADRNEL  r1, ioeb_irqwrite
                BL      common_open
 [ StorkPower
                BLVS    SetPower_Off            ;If openning failed, try powering down. If failure occurred
                                                ;because port was in use, the service call will be faulted
                                                ;and the port will remain powered (as it should be).
 ]
                EXIT



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_close
;
; in:   r0  = reason code
;       r2  = internal handle
;
; out:  -
;
; This routine handles the closing of a stream onto IOEB.
;

ioeb_close      Entry   "r0-r2"
                Debug   close,"ioeb_close"
                LDRB    r0, DeviceNo
                LDRB    r1, Flags
                TST     r1, #f_OpenForRead
                ADRNEL  r1, ioeb_irqread
                ADREQL  r1, ioeb_irqwrite
                ADRL    r2, ioeb_busy_check_callafter
                BL      common_close
                BL      IOEBreset
 [ StorkPower
                BL      SetPower_Off            ;Will be powered up, so power down
 ]
                EXIT



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_created
;
; in:   r0 = reason code (11)
;       r2 = internal handle
;       r3 = buffer handle
;
; out:  -
;
; This routine is called when an input or output stream has been created.
;

ioeb_created    EntryS  "r0-r2"

                Debug   open,"ioeb_created, buffer handle =",r3

                STR     r3, BufferHandle        ; store buffer handle for read or write

        [ FastBufferMan
                MOV     r0, r3
                SWI     XBuffer_InternalInfo
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT    VS
                STR     r0, BufferId
                STR     r1, BuffManService
                STR     r2, BuffManWkSpace
        ]

                ClearPINTR r0,lr                ; attempt to clear any pending interrupts

                SETPSR  I_bit,lr                ; Disable interrupts

                LDRB    r0, Flags
                TST     r0, #f_OpenForRead

                LDR     r0, HardwareBase
                MOVEQ   r1, #ioeb_ctrl_output   ; set up for output
                MOVNE   r1, #ioeb_ctrl_input    ; set up for input
                STRB    r1, [r0, #pp_ctrl]
                EXITS   EQ,cf                   ; do nothing else if open for output

        [ HAL
                Push    "r3,r9,r12"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                MOV     lr, pc
                LDR     pc, HAL_IRQEnable
                Pull    "r3,r9,r12"
        |
                MOV     r0, #IOC
                LDRB    r2, InterruptBit

                SETPSR  F_bit,lr                ; disable FIQs

                LDRB    r1, [r0, #IOCIRQMSKA]
                ORR     r1, r1, r2              ; enable device interrupts
                STRB    r1, [r0, #IOCIRQMSKA]
        ]
                EXITS   ,cf


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_monitorTX
;
; in:   r0  = reason code (12)
;       r2  = internal handle
;
; out:  VS if error, then R0 => error block
;       VC to continue, then R0 corrupted
;
; This routine is called by DeviceFS to check the device if the TX buffer is
; almost full. It can therefore be used to report printer error conditions

;Message tokens
paper           =               "Paper", 0
online          =               "OnLine", 0
printer         =               "Printer", 0
continue        =               "Continue",0
cancel          =               "Cancel",0
                ALIGN

; Now the real code: make an upcall on printer error, resuming if it's handled properly.

ioeb_monitorTX  ROUT

                Entry           "r1-r11"

        [ AdvancedErrorHandling
                ; first of all, check that we can use UpCall_DeviceError (only if we have been able
                ; to claim the UpCall vector, so we have got our own file handle to pass)
                Debug   adverr, "adverr"
                LDRB    r0, Flags
                TST     r0, #f_UpCallVectorClaimed
                BEQ     ioeb_error_fallback

                ; let us check for a stable error condition
                LDR     r3, HardwareBase
                LDR     r2, LoopFactor                          ; Get CPU speed rating
                MOV     r2, r2, LSR #2
20
                LDRB    r0, [r3, #pp_stat]                      ; read status register byte
                TST     R0, #pp_stat_slct                       ; off-line?
                TSTNE   r0, #pp_stat_error                      ; or a general error condition?
                BEQ     %FT25                                   ; we have got an error, so go to next iteration
                TST     r0, #pp_stat_pe
                BEQ     %FT40                                   ; no error, so return normally
25
                SUBS    r2, r2, #1
                BNE     %BT20

                ; OK, we have found a stable error condition, so use the advanced error handling protocol
                LDR     r0, =UpCall_DeviceError
                LDR     r1, FileSwitchHandle
                MOV     r2, #0

                Debug   adverr, "sending UpCall"
                SWI     XOS_UpCall
                BVS     ioeb_error_fallback                     ; UpCall could not be processed, so use old strategy
                TEQ     r0, #0
                BNE     ioeb_error_fallback                     ; UpCall not claimed, so use old strategy

                ; the UpCall has been claimed, so act on the error handling flags
                Debug   adverr, "UpCall claimed, flags = ", r1
                TST     r1, #UpCallDeviceErrorFlag_FatalError
                BEQ     %FT40                                   ; no error, so return normally!

                ; we have got an error, return a general error or a specific one
                TST     r1, #UpCallDeviceErrorFlag_UseErrorBlock
                MOVNE   r0, r2
                BNE     %FT30
                ADRL    r0, ErrorBlock_Parallel_Offline         ; use the standard "printer not ready" error
        [ international
                BL      MakeError
        ]
30
                ; OK, we want to abort printing, so we return to DeviceFS with VS. This will cause it
                ; to purge the buffer and fault any further access to the stream.
                Debug   adverr, "Return VS"
                SETV
                EXIT

ioeb_error_fallback
                ; fall back onto previous error handling strategy
                Debug   adverr, "error fallback, r0 = ", r0
        ]

                LDR     r0, HardwareBase
                LDRB    r0, [r0, #pp_stat]              ; read status register byte

        ; This tests for an error if it is detected looks at it for a test period to ensure it is stable

                TST             R0, #pp_stat_slct
                MOVEQ           r1, #pp_stat_slct       ; off-line?  set = online
                BLEQ            test_NSet_loop          ; if it is offline check that this is stable not noise
                BEQ             off_line

                TST             r0, #pp_stat_pe         ; out of paper? set = no paper
                MOVNE           r1, #pp_stat_pe
                BLNE            test_Set_loop           ; check that it stays set for 1 micro sec.
                BNE             paper_out

                TST             r0, #pp_stat_error      ; pp_stat_error clear for any other error
                MOVEQ           r1, #pp_stat_error      ; set = no error
                BLEQ            test_NSet_loop          ; if it is an error check that this is stable not noise
                BEQ             not_working
40
                Debug   adverr, "Return VC"
                CLRV
                EXIT

;+++++++++++++++++++++++++++++++++++++++++++++ test stable errors Start

        ; ADD a wait loop and check that the error is stable
        ; r0 ppstat, r1 is the error
        ; r3 is the address of the ppstat this needs to be read on each loop

test_Set_loop
                Push    "r2,r3,lr"

                LDR     r3, HardwareBase
                LDR     r2, LoopFactor                          ; Get CPU speed rating
                MOV     r2, r2, LSR #2
20
                LDRB    r0, [r3, #pp_stat]                      ; read status register byte
                TST     R0,R1
                BEQ     %FT25                                   ; see if the ppstat clears => EQ => not a stable error
                SUBS    r2, r2, #1
                BNE     %BT20                                   ; this leaves the loop on EQ
                MOVS    R1, R1                                  ; swap to NE condition => stable error
25
                Pull    "r2,r3,pc"

test_NSet_loop
                Push    "r2,r3,lr"

                LDR     r3, HardwareBase
                LDR     r2, LoopFactor                          ; Get CPU speed rating
                MOV     r2, r2, LSR #2
20
                LDRB    r0, [r3, #pp_stat]                      ; read status register byte
                TST     R0,R1
                BNE     %FT25                                   ; this sets the condition to NE
                SUBS    r2, r2, #1
                BNE     %BT20                                   ; this sets the returning condition to EQ
25                                                              ; this is the error condition
                Pull    "r2,r3,pc"

;+++++++++++++++++++++++++++++++++++++++++++++ test stable errors END
paper_out
                Debug           j, "paper out"
                MOV             r4, #0                  ;iteration count
                ADRL            r6, paper
                B               do_lookup_and_upcall

off_line
                Debug           j, "printer not connected"
                MOV             r4, #0                  ;iteration count
                ADRL            r6, online
                B               do_lookup_and_upcall

not_working
                Debug           j, "printer not working"
                MOV             r4, #0                  ;iteration count
                ADRL            r6, printer
                ;fall through

do_lookup_and_upcall
                ;Convert token in r6 to message in r6
                BL              OpenMessages
                ADDVS           r6, r0, #4
                BVS             do_upcall               ;if it went wrong, use the error as the message

                ADRL            r0, MessagesWorkspace
                MOV             r1, r6
                ADRL            r2, localerrorblock
                MOV             r3, #?localerrorblock
                SWI             XMessageTrans_Lookup
                MOVVC           r6, r2
                ADDVS           r6, r0, #4              ;if it went wrong, use the error as the message

do_upcall       ;Make the upcall

                MOV             r0, #UpCall_MediaNotPresent
                MOV             r1, #fsnumber_DeviceFS
                MOV             r2, #-1                 ;message in r6 (not media type)
                MOV             r3, #-1                 ;device number irrelevant
                ;r4 cleared first time, incremented subsequently
                MOV             r5, #&7FFFFFFF          ;timeout (very big)
                ;r6 set up depending on reason for upcall

                Debug           j, "OS_UpCall called", r0
                SWI             XOS_UpCall
                Debug           j, "OS_UpCall returned", r0
                EXIT            VS

                CMP             r0, #-1
                BNE             not_cancel      ;if this falls through it does not call exit with message

                Debug           j, "SHOULD EXIT WITH MESSAGE"
                ADRL            r6, cancel              ;move the specific error "cancel"
                BL              exit_with_message       ; send exit message then exit
                EXIT            VS

                ;Try to report the error state as it is now, but make sure that some error
                ;is reported even if all conditions have been (coincidentally) cleared.
set_errorblock
                LDR             r0, HardwareBase
                LDRB            r0, [r0, #pp_stat]      ; read status register byte

                ; now we've got an error, so what type is it?
                TST             r0, #pp_stat_pe         ; paper out?
                ADRNEL          r0, ErrorBlock_Parallel_PaperOut
                BNE             make_error

                TST             r0, #pp_stat_slct       ; off-line?
                ADREQL          r0, ErrorBlock_Parallel_Offline
                ADRNEL          r0, ErrorBlock_Parallel_OtherError
                ;fall through

make_error
                ;r0 -> error block
                PullEnv
                [               international
                B               MakeError
                |
                RETURNVS
                ]

not_cancel
                ; New strategy. Just exit with continuing message and let the higher levels
                ; raise the error again if necessary. This should be cleaner and provides
                ; more feedback to the user.

                ADRL            r6, continue            ;move the specific error "continue"
                BL              exit_with_message       ; All o k
                EXIT                                    ;This is the actual correct exit of this routine

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

exit_with_message

                Entry           "R1-R6"
                Debug           j, "exit with message"

                BL              OpenMessages
                ADDVS           r6, r0, #4
                BVS             send_exit               ;if it went wrong, use the error as the message

                ADRL            r0, MessagesWorkspace
                MOV             r1, r6
                ADRL            r2, localerrorblock
                MOV             r3, #?localerrorblock
                SWI             XMessageTrans_Lookup
                MOVVC           r6, r2
                ADDVS           r6, r0, #4

send_exit       ; call the end media search call

                MOV             R1, R6
                MOV             r0, #UpCall_MediaSearchEndMessage
                Debug           j, "OS_UpCall called", r0
                SWI             XOS_UpCall
                Debug           j, "OS_UpCall returned", r0
                EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_wakeupTX
;
; in:   r0  = reason code
;       r2  = internal handle
;
; out:  -
;
; Handle waking up the device, something has happened to it.
;

ioeb_wakeupTX   EntryS  "r0-r3"

                SETPSR  I_bit, lr               ; disable IRQs round this bit

                LDR     r3, HardwareBase
                BL      ioeb_busy               ; returns EQ if not busy
                BLEQ    ioeb_strobe
                EXITS   EQ,cf

                MOV     r0, #0                  ; indicate we wish to remain dormant
                STR     r0, [sp, #Proc_RegOffset]
                LDRB    r3, IRQFlags
                TST     r3, #if_PendingCallAfter ; if we've already asked for a callafter
                EXITS   NE,cf                   ; then exit

                LDR     r0, =BusyCheckInterval
                ADR     r1, ioeb_busy_check_callafter
                MOV     r2, wp
                SWI     XOS_CallAfter
                ORRVC   r3, r3, #if_PendingCallAfter
                STRVCB  r3, IRQFlags

                EXITS   ,cf

                ; CallAfter routine.  Entered in SVC mode with IRQs disabled.
                ; Must preserve all registers and exit with MOV pc, lr (PRM 1-429)
ioeb_busy_check_callafter EntryS "r0"
                LDRB    r0, IRQFlags
                BIC     r0, r0, #if_PendingCallAfter    ; indicate no pending callafter any more
                STRB    r0, IRQFlags
                BL      ioeb_wakeupTX                   ; and call wakeup routine
                EXITS                                   ; and exit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_busy
;
; in:
;       r3 -> HardwareBase
;       IRQs disabled
;
; out:  EQ if printer busy, else NE
;
; This routine will simply read the state of the busy pin from the 710.
;

ioeb_busy       Entry   "r0,r1"

                LDRB    lr, [r3, #pp_stat]                      ; lr  = status byte
                AND     r1, lr, #pp_stat_notbusy                ; is the port busy? =0 if so
                EORS    r1, r1, #pp_stat_notbusy                ; invert Z to be correct for any exit
                EXIT    EQ                                      ; return EQ, ie. port free

 [ HAL
                Push    "r2-r3,r9,r12"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                MOV     lr, pc
                LDR     pc, HAL_IRQEnable
                Pull    "r2-r3,r9,r12"
                MOVS    r0, #-1                                 ; ensure Z=0
 |
                LDRB    r1, InterruptBit
                MOV     r3, #IOC

                ; disable FIQs round updates to IOCIRQMSKA
                SETPSR  F_bit,r0,,lr                            ; old PSR into lr (note: Z clear in lr!)
                LDRB    r0, [r3, #IOCIRQMSKA]
                ORR     r0, r0, r1
                STRB    r0, [r3, #IOCIRQMSKA]
                RestPSR lr,,cf                                  ; restores PSR

                LDR     r3, HardwareBase                        ; Restore r3
 ]
                EXIT                                            ; Z=0, ie. printer is busy, NE

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Strobe characters to the printer port for the 82c710.  Routine can be
; called from anymode, assumes that BufferHandle contains the buffer
; to be examined and character to be strobed.
;
; Also assumes that the direction bit within pp_ctrl has been setup correctly
; so that the port is defined for output rather than input.

;Entry
;       IRQ mode, interrupts off
;       r3 -> IOC
;       r12 -> workspace
;       Not currently threaded (non-reentrant)
;Exit
;       Interrupt serviced
;       r0--r3, r12 corrupted
;Notes
;       Execution time <= 100µs
;       SWI's called by method on P R M p1-127 (X SWI's only)
;       Error stored---somewhere???
;       Calls re-entrant SWI's only

ioeb_irqwrite   ROUT

; The acknowledge interrupt is triggered on the falling (leading) edge of PACK, and some printers'
; manuals indicate that the printer is only ready when the pulse is completed (ie when PACK has gone high again).
; So now we should wait for PACK to go high, and then clear our interrupt

                LDR     r3, HardwareBase
                LDR     r2, LoopFactor                          ; Get CPU speed rating and loop until PACK is high
10
                LDRB    r0, [r3, #pp_stat]
                TST     r0, #pp_stat_ack
                BNE     %FT15
                SUBS    r2, r2, #1
                BNE     %BT10

                ClearPINTR r0,r1                                ; PACK not gone high (probably printer off)
                MOV     pc, lr                                  ; so clear interrupt and exit (printer on will start again)

15
        [ CheckBusyAfterAck
                LDR     r2, LoopFactor                          ; Get CPU speed rating
20
                LDRB    r0, [r3, #pp_stat]
                TST     r0, #pp_stat_notbusy                    ; 0 => busy
                BNE     ioeb_strobe                             ; not busy, so carry on
                SUBS    r2, r2, #1
                BNE     %BT20

                ClearPINTR r0,r1                                ; clear interrupt anyway

                LDRB    r2, IRQFlags
                TST     r2, #if_PendingCallAfter                ; if we already have a pending callafter
                MOVNE   pc, lr                                  ; then exit

                ASSERT  (IRQ_mode :EOR: SVC_mode) = (IRQ32_mode :EOR: SVC32_mode)
                TOGPSR  (IRQ_mode :EOR: SVC_mode),r0,,r3        ; move from IRQ into SVC mode.

                LDR     r0, =BusyCheckInterval                  ; takes place of NOP
                Push    "r2, lr"
                ADR     r1, ioeb_busy_check_callafter
                MOV     r2, wp
                SWI     XOS_CallAfter
                Pull    "r2, lr"
                ORRVC   r2, r2, #if_PendingCallAfter
                STRVCB  r2, IRQFlags

                RestPSR r3,,cf                                  ; restore IRQ mode
                NOP
                MOV     pc, lr                                  ; and exit

        ]

; in:
;     r3 -> HardwareBase
;     SVC_mode or IRQ_mode
;     IRQs disabled (this is needed (a) because may enable pack IRQ (b) mustn't have F=1 and I=0
;
; out: r0-r2 corrupted
;

ioeb_strobe     EntryS

                ClearPINTR r0,r1                                ; clear interrupt after PACK has gone high again
                                                                ; note this is done inside the strobe routine in order
                                                                ; to clear any fake acknowledges generated on printer
                                                                ; power-on

        [ FastBufferMan
                MOV     r0, #BufferReason_RemoveByte
                LDR     r1, BufferId
                CallBuffMan
        |
                SavePSR r2
                BIC     r2, r2, #C_bit + V_bit                  ; clear C&V for entering mode
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
                                                                ; we've already saved lr_svc, so we can junk it now)
                RestPSR lr                                      ; change to SVC mode with C and V clear
                LDR     r1, StreamHandle
                Push    "lr"                                    ; preserve SVC_LR
                SWI     XDeviceFS_TransmitCharacter             ; get character to send
                Pull    "lr"

                ORRCS   r2, r2, #C_bit                          ; ensure C flag reflected correctly
                RestPSR r2
                NOP                                             ; back to original mode (IRQ or SVC)
        ]
        [ HAL
                Push    "byte,r3,r9,r12"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                ADRCC   lr, %FT10
                LDRCC   pc, HAL_IRQEnable
                MOV     lr, pc
                LDR     pc, HAL_IRQDisable
                Pull    "byte,r3,r9,r12"
                EXITS   ,cf
10
                Pull    "byte,r3,r9,r12"
        |
                MOV     r3, #IOC
                LDRB    r1, InterruptBit

                SETPSR  F_bit,tmp,,lr                           ; set F bit, old PSR into lr

                LDRB    tmp, [r3, #IOCIRQMSKA]
                ORRCC   tmp, tmp, r1                            ; re-enable printer interrupts
                BICCS   tmp, tmp, r1
                STRB    tmp, [r3, #IOCIRQMSKA]

                EXITS   CS,cf                                   ; if no character then exit
                RestPSR lr,,c                                   ; restore FIQ status (IRQs still disabled)

                LDR     r3, HardwareBase                        ; Restore r3
        ]
                STRB    byte, [r3, #pp_data]

; The following assumes the SuperIO chip has IOTCR set for TypeB cycles (7 ticks of 16MHz IO clock => 437.5ns)
; hence a read of any non read sensitive register will waste 0.5us ish

; now do set up time of 0.5µs, so read dummy location

                LDRB    r0, [r3, #pp_delay]

                LDRB    r2, [r3, #pp_ctrl]
                ORR     r0, r2, #pp_ctrl_strobe                 ; enable strobing
                STRB    r0, [r3, #pp_ctrl]

; now leave strobe high for at least 1µs, so do two dummy reads

                LDRB    r0, [r3, #pp_delay]
                LDRB    r0, [r3, #pp_delay]

                STRB    r2, [r3, #pp_ctrl]                      ; disable strobing

; no need to explicitly wait for 1µs with data valid, there's no way we can send another character within 1µs
; since we have to call SWI XDeviceFS_TransmitChar to get each char.
                [       FastBufferMan                           ; but not if we're using FastBufferMan JRC 14-Apr-1997
                LDRB    r0, [r3, #pp_delay]
                LDRB    r0, [r3, #pp_delay]
                ]

; now cancel any pending callafter, since we've just transmitted a char

                LDRB    r0, IRQFlags
                TST     r0, #if_PendingCallAfter
                EXITS   EQ,cf

                SavePSR r2
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; force SVC mode
                RestPSR lr

                MOV     r1, wp
                Push    "r0,lr"
                ADR     r0, ioeb_busy_check_callafter
                SWI     XOS_RemoveTickerEvent
                Pull    "r0,lr"

                RestPSR r2                                      ; switch back

                BIC     r0, r0, #if_PendingCallAfter
                STRB    r0, IRQFlags

                EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: ioeb_irqread
;
;       Process incoming bytes.
;

ioeb_irqread    EntryS  "r0-r3"

                LDR     r1, HardwareBase
                LDRB    byte, [r1, #pp_data]            ; get input byte

                LDRB    tmp, [r1, #pp_ctrl]
                BIC     tmp, tmp, #pp_ctrl_slctin :OR: pp_ctrl_autofd
                STRB    tmp, [r1, #pp_ctrl]             ; signal busy using SLCTIN (+ AUTOFD for ECP cables)

                ClearPINTR r1,tmp                       ; clear interrupt

buffer_byte
        [ FastBufferMan
                MOV     r0, #BufferReason_InsertByte
                LDR     r1, BufferId
                CallBuffMan
        |
                SavePSR r3
                BIC     lr, r3, #2_01100 + C_bit + V_bit
                ORR     lr, lr, #SVC_mode
                RestPSR lr,,cf                          ; change to SVC mode (C & V clear)

                LDR     r1, BufferHandle
                Push    "r9,lr"
                MOV     r9, #INSV                       ; call vector directly for speed
                SWI     XOS_CallAVector                 ; buffer the byte
                Pull    "r9,lr"

                ORRCS   r3, r3, #C_bit                  ; reflect C flag in PSR
                RestPSR r3                              ; back to old mode
        ]

        [ HAL
                SavePSR lr
                Push    "byte,r9,r12,lr"
                LDRB    r0, DeviceNo
                LDR     r9, HAL_SB
                ADR     lr, %FT10
                LDRCC   pc, HAL_IRQEnable
                LDRCS   pc, HAL_IRQDisable
10
                Pull    "byte,r9,r12,lr"
                RestPSR lr,,f                           ; restore C bit conditionality
        |
                LDRB    r1, InterruptBit
                MOV     r3, #IOC

                SETPSR  F_bit,tmp,,lr                   ; disable FIQs

                LDR     tmp, [r3, #IOCIRQMSKA]
                BICCS   tmp, tmp, r1                    ; if buffer is full, disable device interrupts
                ORRCC   tmp, tmp, r1                    ; else ensure they are enabled
                STRB    tmp, [r3, #IOCIRQMSKA]

                BICCC   lr, lr, #C_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,c                           ; restore FIQs
        ]

                STRCS   byte, ByteBuffer                ; remember the byte that couldn't be buffered
                LDRCSB  r0, IRQFlags
                ORRCS   r0, r0, #if_ReadHalted          ; set halted flag
                STRCSB  r0, IRQFlags
                EXITS   CS

                LDR     r2, HardwareBase
                LDRB    r0, [r2, #pp_ctrl]
                ORR     r1, r0, #pp_ctrl_strobe
                STRB    r1, [r2, #pp_ctrl]              ; acknowledge using STROBE

                LDRB    r1, [r2, #pp_ctrl]
                LDRB    r1, [r2, #pp_ctrl]              ; leave for at least 1µs

                ORR     r0, r0, #pp_ctrl_slctin :OR: pp_ctrl_autofd
                STRB    r0, [r2, #pp_ctrl]              ; remove STROBE and busy (SLCTIN and AUTOFD)

                EXITS



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: ioeb_resume
;
; If DeviceFS has failed to buffer a byte and returned above with C set then
; this entry point will eventually be called when the buffer has enough space.
; In the mean time the writer has not been acknowledged and its BUSY line has
; been left high so that it cannot send.
;

ioeb_resume     ALTENTRY                        ; needs to push same stuff as ioeb_irqread

                SETPSR  I_bit,lr                ; disable IRQs

                LDRB    r0, IRQFlags
                TST     r0, #if_ReadHalted
                EXITS   EQ,cf

                Debug   in,"Resuming RX"

                BIC     r0, r0, #if_ReadHalted
                STRB    r0, IRQFlags

                LDR     byte, ByteBuffer        ; get the byte we couldn't buffer
                B       buffer_byte             ; try again

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_ioctl
;
; this implements the io control call as implemented in the serial device. At
; present this implements calls used to get the DEVICE ID, the current port
; status byte and the device status (read using reverse nibble transfer).
;
; entry. r3 => IOCtl block
; exit. registers preserved, IOCtl block updated (see below)
ioeb_ioctl
                ROUT
                Entry "r0, r4-r8"

                LDRB    r5, [r3, #2]                    ; get the group byte

                Debug   ioctl, "ioeb_ioctl, group = ", r5

                LDR     r6, =ioctl_group_parallel       ; make sure we are in the right group
                CMP     r6, r5
                BNE     ioctl_error

                LDRB    r5, [r3, #3]
                TST     r5, #ioctl_header_read           ; read flag must be set
                BEQ     ioctl_error

                LDR     r5, [r3]
                LDR     r0, =ioctl_reason_mask
                AND     r5, r5, r0                      ; the least significant half word is the reason

                Debug   ioctl, "           reason = ", r5

                SUBS    r5,r5,#1                        ; we do not have reason code 0, so return an error
                BMI     ioctl_error                     ; if this is what is wanted

                CMP     r5, #(%FT20-%FT10)/4
                ADDCC   pc, pc, r5, LSL #2              ; despatch the call
                B       ioctl_error

10
                B       ioctl_device_id_size
                B       ioctl_device_id_data
                B       ioctl_status
                B       ioctl_revnibble_size
                B       ioctl_revnibble_data
20

; returns the status byte in the data field of the IOCtl block
ioctl_status
                LDR     r6, HardwareBase
                LDRB    r7, [r6, #pp_stat]
                STR     r7, [r3, #4]
                B       ioctl_ret

; entry. -
; exit.  returns the size of the Device ID string in the data field of the IOCtl block
;        NB. this call only works if the printer allows us to abort reverse nibble transfer
;            mode after reading the size bytes. Canon printers do, the HP LJ5 printer, for
;            instance, does not. In practice, IOCTL_DEVICE_ID_DATA should be used instead
;            (with a generous buffer).
ioctl_device_id_size
                MOV     r8,#extensibility_request_device_id
                B       %FT30

; entry. -
; exit.  returns the size of the reverse nibble data in the data field of the IOCtl block
;        NB. This call only works if the printer passes the status data including two size bytes as
;            when reading the Device ID. Canon printers do this, but HP printers, for instance, do not!
;            This call was mainly added to provide a similar interface to reading the device ID. In
;            practice, it should not be used and IOCTL_REVNIBBLE_DATA should be used instead with a
;            generous buffer.
ioctl_revnibble_size
                MOV     r8,#extensibility_request_revnibble
30
                MOV     r7,#2                           ; to read the size read only two bytes
                ADD     r6, r3, #4                      ; r6 is the address of the data
                MOV     r4, #0                          ; set up the amount read
                STR     r4, [r3, #4]                    ; set the size to zero

                BL      IEEE1284_negotiate
                BVS     ioctl_error_xlate
                STR     r4, [r3, #4]                    ; store the size read in the IOCtl buffer
                B       ioctl_ret

; entry. the data field of the IOCtl block contains the size of the buffer starting from the beginning
;        of the data field
; exit.  returns the Device ID starting from the beginning of the data field (including the two size
;        bytes) - if the size passed in was too small, only that amount is read, no error is returned
;        in this case
ioctl_device_id_data
                MOV     r8,#extensibility_request_device_id
                LDR     r7, [r3, #4]                    ; load the beginning of the data (size)
                CMP     r7, #2
                BCC     ioctl_error                     ; make sure the size is at least the size field

                ; r7 = size to read
                ADD     r6, r3, #4                      ; r6 is the address of the data
                MOV     r4, #0                          ; set up the amount read
                STR     r4, [r3, #4]                    ; set the size to zero

                BL      IEEE1284_negotiate
                BVS     ioctl_error_xlate
                B       ioctl_ret

; entry. the data field of the IOCtl block contains the size of the buffer starting after the data field
;        (NB. this is different from ioctl_device_id_data)
; exit.  returns the reverse nibble transfer data starting after the end of the data field (including the
;        two size bytes) - if the size passed in was too small, only that amount is read and the size
;        field is updated to the actual size, no error is returned in this case
;        NB. This call only works if the printer passes the status data including two size bytes as for
;            the Device ID. Canon printers do this, but HP printers, for instance, do not!
ioctl_revnibble_data
                MOV     r8,#extensibility_request_revnibble
                LDR     r7, [r3, #4]                    ; load the beginning of the data (size)
                CMP     r7, #2
                BCC     ioctl_error                     ; make sure the size is at least the size field

                ; r7 = size to read
                ADD     r6, r3, #8                      ; r6 is the address of the data
                MOV     r4, #0                          ; set up the amount read
                STR     r4, [r3, #4]                    ; set the size to zero

                BL      IEEE1284_negotiate
                BVS     ioctl_error_xlate
                STR     r4, [r3, #4]                    ; store the size field in the IOCtl buffer
ioctl_ret
                EXIT
ioctl_error
                ADRL    r0, ErrorBlock_Parallel_BadParm ; this must be set
ioctl_error_xlate
                [ international
                BL      MakeError
                |
                SETV
                ]
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEB_ReadDataStatus
;
; in:   r0 = 0
;
; out:  r0 preserved
;       r1 = contents of data register
;       r2 = contents of status register
;
; This routine reads the contents of the data and status registers.
;

IOEB_ReadDataStatus
                EntryS

                LDR     r1, HardwareBase

                SETPSR  I_bit,r2                        ; disable IRQs

                LDRB    r2, [r1, #pp_stat]
                LDRB    r1, [r1, #pp_data]

                EXITS   ,cf

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEB_WriteData
;
; in:   r0 = 1
;       r1 = data to be written
;
; out:  r0 preserved
;       r1 preserved
;
; This routine writes the contents of the data register.
;

IOEB_WriteData
                Entry

                LDR     lr, HardwareBase        ; no need to disable IRQs
                STRB    r1, [lr, #pp_data]      ; it's atomic

                EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOEB_ReadWriteCtrl
;
; in:   r0 = 2
;       r1  = EOR mask
;       r2  = AND mask
;
; out:  r0 preserved
;       r1 = old state
;       r2 = new state
;
; This routine will read/write the control register based on the AND and EOR
; values specified.
;
; ctrl = (ctrl AND r2) EOR r1
;

IOEB_ReadWriteCtrl
                EntryS  "r0"

                LDR     r0, HardwareBase

                SETPSR  I_bit, lr                               ; disable IRQs

                LDRB    lr, [r0, #pp_ctrl]
                AND     r2, lr, r2
                EOR     r2, r2, r1                              ; r2 = new state of control reg
                STRB    r2, [r0, #pp_ctrl]                      ; update control register
                MOV     r1,lr

                EXITS   ,cf

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: UpdateIOEBCtrl
;
; in:   r0  = EOR mask
;       r1  = AND mask
;
; out:  -
;
; This routine will adjust the control register based on the AND and EOR
; values specified.
;
; control = (control AND r1) EOR r0
;

 [ HAL
; On HAL this routine gets copied into our workspace, to allow it to be called
; by user code without R12 being set up
UpdateIOEBCtrlProto
                EntryS  "r2"

                SETPSR  I_bit,r2                                ; disable IRQs

                LDR     r2, UpdateIOEBCtrlProto-(:INDEX:UpdateIOEBCtrl-:INDEX:HardwareBase)
 |
UpdateIOEBCtrl  EntryS  "r2"

                SETPSR  I_bit,r2                                ; disable IRQs

                LDR     r2, HardwareBase
 ]
                LDRB    lr, [r2, #pp_ctrl]
                AND     lr, lr, r1
                EOR     lr, lr, r0                              ; lr = new state of control reg
                STRB    lr, [r2, #pp_ctrl]                      ; update control register (hardware)

                EXITS   ,cf                                     ; exit, restoring original IRQ state
 [ HAL
UpdateIOEBCtrlProtoEnd
        ! 0, "UpdateIOEBCtrlProto is ":CC:(:STR:(UpdateIOEBCtrlProtoEnd-UpdateIOEBCtrlProto)):CC:" bytes"
        ASSERT UpdateIOEBCtrlProtoEnd-UpdateIOEBCtrlProto <= UpdateIOEBCtrlSize
 ]

; This method implements section 7.4 of the IEEE std 1284-1994 specification.
;
; entry. r6 => buffer to write to
;        r7 = size to read (including the two size bytes)
;        r8 = extensibility request value
; exit.  VS if error
;          r0 => error block (not translated)
;        VC if success
;          r4 = amount of data read
IEEE1284_negotiate
                ROUT
                Entry "r0-r3,r5,r9-r10"

                Debug   ioctl, "IEEE1284_negotiate = ", r7

; check if there is an OS_CallAfter pending. We don't want it trying to send data in the middle of reverse nibble!
                LDR     r0, IRQFlags
                TST     r0, #if_PendingCallAfter
                BEQ     %FT01
                ADRL    r0, ioeb_busy_check_callafter
                MOV     r1, wp
                SWI     XOS_RemoveTickerEvent
                EXIT    VS
                
01
                MOV     r9, r6                  ; keep initial buffer pointer
                LDR     lr, HardwareBase
                LDRB    r5, [lr, #pp_ecr]       ; make sure we are in compatability mode
                                                ; r5 must be preserved for negotiate_finalise below!

                [  FastCentronics               ; if we are in fast mode get out of it first
                TST     r5, #pp_ecr_flag_FIFO
                TSTNE   r5, #pp_ecr_empty
                BEQ     %FT05                   ; not in fast mode or FIFO empty, so we can go on
                Debug   ioctl_err, "FPar in use"
                ADRL    r0, ErrorBlock_Parallel_InUse
                STR     r0, [sp, #Proc_RegOffset]
                SETV
                EXIT
                ]

05
                MOV     r0, #pp_ecr_default     ; mode 001 as we may want to tri-state the data lines
                STRB    r0, [lr, #pp_ecr]       ; this sets the combo into compatability mode (turns FIFO off)

                Debug   ioctl, "init"

                LDR     r2, HardwareBase        ; r2 always contains the address of the hardware

                LDRB    r10, [r2, #pp_ctrl]     ; keep original ctrl byte value

; ensure interrupts are off and wait for everything to stabilise
                MOV     r0, r10
                BIC     r0, r0, #pp_ctrl_irqen
                STR     r0, [r2, #pp_ctrl]
; Failure rates per 10000 tries
; Delay     K80      930C
; 0            5     Freezes (power up needed)
; 5us         10     Freezes (escape worked. At write zeroes to printer)
; 10us        20
; 15us        10
; 1.3ms       22     As for 5us
                 LDR    r0, LoopFactor         ; 40us
                 MOV    r0, r0, LSL#5          ; 1.3ms
09               SUBS   r0, r0, #1
                 BNE    %B09
; things should now be stable so it should be safe to carry on

                LDRB    r0, [r2, #pp_data]
                ORR     r10, r10, r0, lsl#8     ; keep original data byte value

                MOV     r0, #pp_ctrl_default
                STRB    r0, [r2, #pp_ctrl]      ; pull the strobe line up
                STRB    r8, [r2, #pp_data]      ; set the data to Extensibility Request Value - event # 0

                PulseDelay lr                   ; make sure the data is stable before event # 1

                ORR     r0, r0, #pp_ctrl_autofd
                BIC     r0, r0, #pp_ctrl_slctin
                STRB    r0, [r2, #pp_ctrl]      ; set the stimulus event 1.

                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10         ; 40 us * &400 = ~40ms
10
                LDRB    r3, [r2, #pp_stat]      ; negotiation phase, load status
;                TST     r3, #pp_stat_error
;                TSTNE   r3, #pp_stat_pe
;                BNE     %FT20                   ; IEEE 1284 compatabiility
                AND     r3, r3, #extensibility_acknowledge_mask
                CMP     r3,     #extensibility_acknowledge_value 
                BEQ     %FT20
                SUBS    r0, r0, #1
                BGT     %BT10

                Debug   ioctl, "1284 failed, status = ", r3
                B       negotiate_error         ; device is not IEEE 1284 compatible
20
                Debug   ioctl, "1284 OK ", r3

                PulseDelay r0                   ; delay before strobing the data

                LDRB    r3, [r2, #pp_ctrl]      ; event 3 pull strobe down
                ORR     r3, r3, #pp_ctrl_strobe
                STRB    r3, [r2, #pp_ctrl]

                PulseDelay r0                   ; delay for 5 us to ensure the peripheral sees it.

                BIC     r3, r3, #pp_ctrl_autofd :OR: pp_ctrl_strobe
                STRB    r3, [r2, #pp_ctrl]      ; event 4 on map

; Events 5 and 6.
                LDR     r0, LoopFactor
                MOV     r0, r0, LSL #10          ; ~40ms. In practice a lot more as register r/w is slow.
22
                LDR     r3, [r2, #pp_stat]       ; Load status
                TST     r3, #pp_stat_ack         ; Step 6. Wait for nAck to go high. Step 5 values valid.
                BNE     %FT23
                SUBS    r0, r0, #1
                BGT     %BT22                    ; time out
                Debug   ioctl_err, "1284 t/o (step 6)"
                B       negotiate_error
23
                ; check that we have a positive responce. Required XFlag(slct) value depends on extensibility type.
                ; cf 1284-2000 table 4
                TEQ     r8, #extensibility_request_revnibble
                EOREQ   r3, r3, #pp_stat_slct   ; toggle SLCT bit if required
                TST     r3, #pp_stat_slct       ; if set then success
                BNE     %FT28
                
                Debug   ioctl_err, "1284 t/o (XFlag)"
                B       negotiate_error

28
                Debug   ioctl, "XFlag OK"

                ; Negotiate phase now successfully completed 
                ; OK, we have entered a valid state, so if anything goes wrong now, we have to
                ; use the full handshake termination protocol

                ; read data from peripheral, the data transfer phase
50
                Debug   ioctl_loop, "read loop, r4 = ", r4

                LDRB    r3, [r2, #pp_stat]      ; main read loop
                TST     r3, #pp_stat_error      ; determine if there is data to read
                BNE     negotiate_tidy          ; no data left

                BL      reverse_nibble_read     ; read the byte

                BVS     negotiate_error         ; if an error occurred while reading a nibble, this was not while
                                                ; being in a valid state, so we use the immediate abort strategy

                Debug   ioctl_loop, "nibble read = ", r0

                STRB    r0, [r6, r4]            ; this stores the data at the buffer including the first two bytes

                ADD     r4, r4, #1
                CMP     r4, r7
                BLT     %BT50

                ; The buffer is full
                Debug   ioctl, "Buffer full r8 = ", r8

                ; we return the size field in r4
                LDRB    r0, [r9]                ; read MSB of size
                LDRB    lr, [r9, #1]            ; read LSB of size
                ORR     r4, lr, r0, lsl#8       ; r4 = size
                Debug   ioctl, "New size field ", r4

negotiate_tidy
                ; the handshake termination sequence
                ; we should only end up here if the protocol is in a valid state (IEEE1284-2000, section 7.7)
                LDRB    r3, [r2, #pp_stat]      ; we have to take note of the current SLCT status
                AND     r14, r3, #pp_stat_slct

                LDRB    r3, [r2, #pp_ctrl]
                ORR     r3, r3, #pp_ctrl_slctin ; event 22
                BIC     r3, r3, #pp_ctrl_autofd ; this should be the case already, but just to be sure...
                STRB    r3, [r2, #pp_ctrl]

                ; we wait for the peripheral's response
                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10
60
                LDRB    r3, [r2, #pp_stat]
                EOR     r3, r3, #pp_stat_notbusy    ; change notbusy to BUSY
                TST     r3, #pp_stat_error      ; wait for ERROR to come up
                TSTNE   r3, #pp_stat_notbusy    ; and BUSY to come up, too
                BNE     %FT70
                SUBS    r0, r0, #1
                BGT     %BT60

                Debug   ioctl_err, "ERR BUSY t/o"
                B       negotiate_finalise      ; immediate abort
70
                ; OK, now we wait for event 24 (no stimulus inbetween)
                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10
80
                LDRB    r3, [r2, #pp_stat]
                EOR     r3, r3, #pp_stat_ack    ; invert nACK for NE test below
                EOR     r3, r3, r14             ; eor with initial SLCT status - if the bit is still the same as
                                                ; before, it is clear now, or set if it has been flipped
                TST     r3, #pp_stat_ack        ; wait for nACK to go low (i.e., inverted bit is set now)
                TSTNE   r3, #pp_stat_slct       ; and SLCT to be flipped
                BNE     %FT90
                SUBS    r0, r0, #1
                BGT     %BT80

                Debug   ioctl_err, "nACK low SLCT flip t/o"
                B       negotiate_finalise      ; immediate abort
90
                LDRB    r3, [r2, #pp_ctrl]
                ORR     r3, r3, #pp_ctrl_autofd ; event 25
                STRB    r3, [r2, #pp_ctrl]

                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10
100
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack        ; wait for nACK to go high (event 26)
                BNE     %FT110
                SUBS    r0, r0, #1
                BGT     %BT100

                Debug   ioctl_err, "nACK high t/o"

                ; this last check was only for the sake of completeness
                ; we are at the end of the protocol and will return to compatibility mode anyway
110
                ; OK, we did it! We are back in compatibility mode.
                ; All we have to do now is to clear pp_ctrl_autofd (set nAutoFd high, event 28),
                ; but this will be done using pp_ctrl_default below.
                Debug   ioctl, "Terminated OK"
                CLRV

negotiate_finalise
                ; V flag denotes error condition - must be preserved until EXIT
                STRB    r5, [r2, #pp_ecr]       ; tidyup restore the ecr state to what it was.

                ; if we have just gone through the full termination handshake, the following stimulus performs
                ; event 28 (nAutoFd high), else it indicates an immediate abort because it sets pp_ctrl_slctin
                ; (nSelectIn low)
                MOV     r5, #pp_ctrl_default
                STRB    r5, [r2, #pp_ctrl]

; The following assumes the SuperIO chip has IOTCR set for TypeB cycles (7 ticks of 16MHz IO clock => 437.5ns)
; hence a read of any non read sensitive register will waste 0.5us ish

                LDRB    lr, [r2, #pp_delay]     ; a slight delay

                MOV     r0, r10, lsr#8          ; get original data byte value back
                STRB    r0, [r3, #pp_data]      ; and restore it
                STRB    r10, [r2, #pp_ctrl]     ; restore the original ctrl byte

                LDR     r0, IRQFlags            ; check to see if we need to put back a CallAfter
                TST     r0, #if_PendingCallAfter
                BEQ     %FT120
                LDR     r0, =RevNibBusyCheckInterval    
                ADRL    r1, ioeb_busy_check_callafter
                MOV     r2, wp
                SWI     XOS_CallAfter
120

; but during output, a nAck may have been missed, in which case the stream will stall
; so check that there is an output stream, and if busy is clear, call ioeb_wakeupTX

                LDR    r0, Flags
                TST    r0, #f_OpenForWrite
                BLNE   ioeb_wakeupTX            ; there is an output stream
                Debug   ioctl, "negotiate_ret"

                EXIT

; wait for buffers to empty
;
; waits for both os and hardware buffers to empty
; times out if no characters fetched in 30s
; checks escape state and returns escape error if set
; entry. None.
; exit. VS if error
;         r0 => error block
;       VC if success
;         all registers preserved

; wait_for_buffers_to_empty
;                 ROUT
;                 Entry "r0-r9"
; 
; 10              SWI     XOS_ReadMonotonicTime
;                 ADD     r7, r0, #&BC0          ; ~30 seconds in cs  (30.08s)
;                 MOV     r8, #0                 ; used to store the number of characters in the buffer
;                 LDR     r9, =pp_stat           ; pointer to status register
; 20
;         ; is the printer error free?
;                 LDRB    r0, [r9]
;                 TST     r0, #pp_stat_error
;                 ADREQL  r0, ErrorBlock_Parallel_OtherError
;                 BEQ     %99
; 
;         ; user run out of patience? Check escape state
;                 SWI     XOS_ReadEscapeState
;                 ADRCSL  r0, ErrorBlock_Escape
;                 BCS     %98
; 
;         ; have we been here a stupidly long time?
;                 SWI     XOS_ReadMonotonicTime
;                 BVS     %99
;                 CMP     r7, r0
;                 ADRLTL  r0, ErrorBlock_Parallel_OtherError
;                 BLT     %98
; 
;         ; anything in the OS buffer PRM 4-97
;                 LDR     r0, BufferHandle
;                 SWI     XBuffer_GetInfo
;                 BVS     %99
;                 CMP     r6, #0
;                 BEQ     %30                         ; os buffer is empty
; 
;         ; are characters still departing?
;                 CMP     r6, r8                      ; always false first time round, but that doesn't matter
;                 MOV     r8, r6                      ; remember the number of characters in the buffer
;                 BNE     %10                         ; characters are going, so reset timeout
;                 B       %20                         ; no character gone, so don't reset the timeout
; 
; 30      ; is the hardware buffer in use, and if so, is it empty
;                 LDR     r5, =pp_ecr
;                 LDRB    r5, [r5]
;                 TST     r5, #pp_ecr_flag_FIFO       ; in fast mode?
;                 BEQ     %40                         ; it is not in use, so carry on
;                 TST     r5, #pp_ecr_empty           ; buffer empty?
;                 BEQ     %20                         ; not empty, so go round again
;                 
; 40      ; normal exit
;                 EXIT
; 
; 98      ; our error exit point
;                 SETV
; 99      ; external error exit point
;                 STR     r0, [sp, #Proc_RegOffset]
;                 EXIT


negotiate_error
                Debug   ioctl_err, "negotiate_error"
                ; NB. we return an untranslated error block, it will be translated by the caller
                ADRL    r0, ErrorBlock_Parallel_BadHardware     ; timeout
                SETV
                STR     r0, [sp, #Proc_RegOffset]
                B       negotiate_finalise

; entry.
;         r2 = HardwareBase, byte address
; exit. VS = error
;         r0 => error block (not translated)
;       VC = success
;         r0 = byte as read from peripheral

reverse_nibble_read
                ROUT
                Entry   "r3-r5"

                Debug   nibble, "Reverse nibble read"

                LDRB    r3, [r2, #pp_ctrl]
                ORR     r3, r3, #pp_ctrl_autofd                 ; pull the autofd line down
                STRB    r3, [r2, #pp_ctrl]

                LDR     r4, LoopFactor                          ; maximum of 35 milliseconds peripheral response
                MOV     r4, r4, LSL #10                         ; 40 us * 1000 ~=(&400)
50
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack                        ; wait for data, ack low
                BEQ     %FT55
                SUBS    r4, r4, #1
                BGT     %BT50

                Debug   nibble_err, "ACK low t/o ", r3
                B       nibble_error
55
                Debug   nibble, "ACK low, stat = ", r3
                LDRB    r4, [r2, #pp_stat]                      ; read the first nibble from the status byte
                AND     r0, r4, #pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error ; find bits 2, 1 and 0 resp. masked as 5, 4 & 3
                MOV     r0, r0, LSR #3
                TST     r4, #pp_stat_notbusy                    ; see if bit seven is set
                ORREQ   r0, r0, #&08                            ; make that bit 3

                LDRB    r3, [r2, #pp_ctrl]                      ; pull the autofd up again first nibble complete
                BIC     r3, r3, #pp_ctrl_autofd
                STRB    r3, [r2, #pp_ctrl]

                LDR     r4, LoopFactor                          ; wait for ack to come back up again
                MOV     r4, r4, LSL #10
65
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack                        ; wait for data
                BNE     %FT70
                SUBS    r4, r4, #1
                BGT     %BT65

                Debug   nibble_err, "ACK high t/o ", r3
                B       nibble_error
70
                Debug   nibble, "ACK high, stat = ", r3

                LDRB    r3, [r2, #pp_ctrl]                      ; ready to read the second nibble, similar cycle as above
                ORR     r3, r3, #pp_ctrl_autofd                 ; pull the autofd line down
                STRB    r3, [r2, #pp_ctrl]

                LDR     r4, LoopFactor
                MOV     r4, r4, LSL #10
75
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack                        ; wait for the lowering of the ack
                BEQ     %FT80
                SUBS    r4, r4, #1
                BGT     %BT75

                Debug   nibble_err, "ACK low2 t/o ", r3
                B       nibble_error
80
                Debug   nibble, "ACK low2, stat = ", r3
                LDRB    r4, [r2, #pp_stat]
                TST     r4, #pp_stat_notbusy                    ; see if bit seven is set
                ORREQ   r0, r0, #&80
                AND     r3, r4, #pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error ; find bits 2, 1 & 0, masked as 5 , 4 & 3
                ORR     r0, r0, r3, LSL #1                      ; set the top nibble

                LDRB    r3, [r2, #pp_ctrl]
                BIC     r3, r3, #pp_ctrl_autofd
                STRB    r3, [r2, #pp_ctrl]

                LDR     r4, LoopFactor
                MOV     r4, r4, LSL #10
85
                LDRB    r3, [r2, #pp_stat]
                TST     r3, #pp_stat_ack                        ; wait for the raising of the ack
                BNE     %FT90
                SUBS    r4, r4, #1
                BGT     %BT85

                Debug   nibble_err, "ACK high2 t/o ",r3
                B       nibble_error
90
                Debug   nibble, "ACK high2, stat = ",r3
                EXIT
nibble_error
                Debug   nibble_err, "nibble error"

                ; NB. we return an untranslated error block, it will be translated above
                ADRL    r0, ErrorBlock_Parallel_BadHardware     ; timeout
                SETV
                EXIT

                END
@


4.18
log
@Fix data abort when trying to print
Common.s: Misplaced comment moved
IOEB.s: Make sure pp_ctrl is relative to HardwareBase
        Preserve C bit over the HAL call
Parallel.s: Misplaced ASSERT moved
This module still stiffs when trying to print, but it at least doesn't data abort too!

Version 0.77. Tagged as 'Parallel-0_77'
@
text
@d704 1
a704 2
                SavePSR r1                                      ; note Z flag preservation
                Push    "r1-r3,r9,r12"
d709 2
a710 2
                Pull    "r1-r3,r9,r12"
                RestPSR r1,,cf                                  ; restores PSR
d743 1
a743 1
;       r3 -> HardwareBase
d761 1
d843 1
a843 1
                Push    "r3,r9,r12"
d850 1
a850 1
                Pull    "r3,r9,r12"
d853 1
a853 1
                Pull    "r3,r9,r12"
@


4.17
log
@Fix stack imbalance in ioeb_busy and have a spring clean
Now uses OS_Memory throughout to determine controller addresses rather than calling the private HAL_ControllerAddress API.
Be devious in all the register pokes by making HardwareBase be roughly half way between the two sets of standard parallel registers and ECP mode ones, so they're always in range for an immediate offset of LDRB/STRB so the code doesn't thrash the literal pool so much.
Where possible, eliminate HAL conditional code by initialising HardwareBase in the non HAL case thus simplifying code paths a bit.
Be a bit less ugly in the 0.5us delays, since the combo chip is using Type B cycles a dummy read of a SuperIO chip will waste 0.5us rather than needing to back calculate the IOEB registers.
Expand tabs, use OSBytes header file.

Version 0.76. Tagged as 'Parallel-0_76'
@
text
@a340 1
                LDR     r0, =pp_ctrl
d342 1
d344 2
a345 1
                STREQB  r1, [r0]
a347 3
                MOV     r1, #ioeb_ctrl_input
                STRB    r1, [r0]                ; set up for input

d714 1
d722 2
d960 1
d969 1
@


4.16
log
@Update to use OS_Memory 9 instead of HAL_ControllerAddress
Detail:
  s/IOEB - Now uses OS_Memory 9 to look for controller #34 instead of HAL_ControllerAddress to look for controller #6. Makes it a bit more portable/future-proof and fixes the HAL_ControllerAddress allocation clash.
Admin:
  Tested in ROM softload on RiscPC


Version 0.75. Tagged as 'Parallel-0_75'
@
text
@d24 2
a25 14
 [ HAL
pp_base                 * 0
 |
pp_base                 * C710 + (&278 * 4)
 ]

pp_data                 * pp_base +0                    ; data port in non-FIFO mode
pp_stat                 * pp_base +4                    ; status register
pp_ctrl                 * pp_base +8                    ; control register
;pp_EPP			* pp_base +12			; EPP mode available only
;pp_EPP_Data0		* pp_base +16
;pp_EPP_Data1		* pp_base +20
;pp_EPP_Data2		* pp_base +24
;pp_EPP_Data3		* pp_base +28
d27 10
a36 2
pp_fifo                 * pp_base + (&400 * 4)          ; FIFO data port (may depend on the chip being used)
pp_ecr                  * pp_base + (&402 * 4)          ; extended control register
d43 3
a45 3
;pp_stat_2		* 1:SHL:2	; hardwired low
;pp_stat_1		* 1:SHL:1	; hardwired low
pp_EPP_timeout		* 1:SHL:0	; set => >= 10 us timout occurred 	clear => no timeout
d47 2
a48 2
;pp_ctrl_7		* 1:SHL:7	; hardwired low
;pp_ctrl_6		* 1:SHL:6	; hardwired low
d72 2
a73 2
pp_ecr_flag_FIFO	* 2_010:SHL:5	; use FIFO mode
pp_ecr_flag_default	* 2_001:SHL:5	; use default parallel mode
d90 2
a91 2
ioctl_reason_size	* 1
ioctl_reason_data	* 2
d96 3
a98 3
ioctl_reason_mask	* &FFFF
ioctl_group_parallel	* 1
ioctl_header_read	* 1:SHL:6
d101 1
a101 1
	[ AdvancedErrorHandling
d107 1
a107 1
	]
d130 2
a131 2
		MACRO
$label		PulseDelay $v0
d133 3
a135 3
$label		ROUT
		LDR	$v0, LoopFactor		; get the processor speed
		MOV	$v0, $v0, LSR #3
d137 3
a139 3
		SUBS	$v0, $v0, #1
		BGT	%BT10
		MEND
a215 1
 [ HAL
d221 5
a225 4
                MOV     r1, #34<<8
                SWI     OS_Memory
                ASSERT  pp_base = 0
                ADD     r0, r1, #&278*4
d231 2
a232 3
                LDRNE   r2, =pp_ecr-pp_base
                MOVNE   r1, #pp_ecr_default                     ;   program default value
                STRNEB  r1, [r0, r2]
d236 1
a236 1
                STRB    r1, [r0, #pp_ctrl-pp_base]
a238 12
 |
IOEBreset       EntryS   "r0,r1"

                ClearPINTR r0,r1                                ; attempt to clear any pending interrupts

        [ FastCentronics
                LDRB    r0, Flags
                TST     r0, #f_UseFIFO                          ; if FIFO hardware is there then
                LDRNE   r0, =pp_ecr
                MOVNE   r1, #pp_ecr_default                     ;   program default value
                STRNEB  r1, [r0]
        ]
a239 8
                LDR     r0, =pp_base
                STR     r0, HardwareBase                        ; setup the hardware base for device

                MOV     r1, #pp_ctrl_default                    ; program default value into control register
                STRB    r1, [r0, #pp_ctrl-pp_base]

                EXITS
 ]
d349 1
d374 1
a374 1
; in:	r0  = reason code (12)
d384 6
a389 6
paper		=		"Paper", 0
online		=		"OnLine", 0
printer		=		"Printer", 0
continue	=		"Continue",0
cancel		=		"Cancel",0
		ALIGN
d393 1
a393 1
ioeb_monitorTX	ROUT
d395 1
a395 1
		Entry		"r1-r11"
d397 7
a403 7
	[ AdvancedErrorHandling
		; first of all, check that we can use UpCall_DeviceError (only if we have been able
		; to claim the UpCall vector, so we have got our own file handle to pass)
		Debug   adverr, "adverr"
		LDRB    r0, Flags
		TST	r0, #f_UpCallVectorClaimed
		BEQ	ioeb_error_fallback
d405 1
a405 2
		; let us check for a stable error condition
            [ HAL
d407 2
a408 5
            |
                LDR     r3, =pp_base
            ]
		LDR	r2, LoopFactor				; Get CPU speed rating
		MOV	r2, r2, LSR #2
d410 6
a415 6
		LDRB	r0, [r3, #pp_stat-pp_base]		; read status register byte
		TST	R0, #pp_stat_slct                       ; off-line?
		TSTNE	r0, #pp_stat_error			; or a general error condition?
		BEQ	%FT25                                   ; we have got an error, so go to next iteration
		TST	r0, #pp_stat_pe
		BEQ	%FT40                                   ; no error, so return normally
d420 24
a443 24
		; OK, we have found a stable error condition, so use the advanced error handling protocol
		LDR     r0, =UpCall_DeviceError
		LDR	r1, FileSwitchHandle
		MOV	r2, #0

		Debug   adverr, "sending UpCall"
		SWI	XOS_UpCall
		BVS	ioeb_error_fallback			; UpCall could not be processed, so use old strategy
		TEQ	r0, #0
		BNE	ioeb_error_fallback			; UpCall not claimed, so use old strategy

		; the UpCall has been claimed, so act on the error handling flags
		Debug   adverr, "UpCall claimed, flags = ", r1
		TST	r1, #UpCallDeviceErrorFlag_FatalError
		BEQ	%FT40					; no error, so return normally!

		; we have got an error, return a general error or a specific one
		TST	r1, #UpCallDeviceErrorFlag_UseErrorBlock
		MOVNE	r0, r2
		BNE	%FT30
		ADRL	r0, ErrorBlock_Parallel_Offline		; use the standard "printer not ready" error
	[ international
		BL	MakeError
	]
d445 5
a449 5
		; OK, we want to abort printing, so we return to DeviceFS with VS. This will cause it
		; to purge the buffer and fault any further access to the stream.
		Debug  	adverr, "Return VS"
		SETV
		EXIT
d452 3
a454 3
		; fall back onto previous error handling strategy
		Debug  	adverr, "error fallback, r0 = ", r0
	]
a455 1
        [ HAL
d457 1
a457 5
                LDRB    r0, [r0, #pp_stat-pp_base]
        |
		LDR 	r0, =pp_stat
		LDRB	r0, [r0]		; read status register byte
        ]
d459 1
a459 1
	; This tests for an error if it is detected looks at it for a test period to ensure it is stable
d461 14
a474 14
		TST		R0, #pp_stat_slct
		MOVEQ		r1, #pp_stat_slct	; off-line?  set = online
		BLEQ		test_NSet_loop		; if it is offline check that this is stable not noise
		BEQ		off_line

		TST		r0, #pp_stat_pe		; out of paper? set = no paper
		MOVNE		r1, #pp_stat_pe
		BLNE		test_Set_loop		; check that it stays set for 1 micro sec.
		BNE		paper_out

		TST		r0, #pp_stat_error	; pp_stat_error clear for any other error
		MOVEQ		r1, #pp_stat_error	; set = no error
		BLEQ		test_NSet_loop		; if it is an error check that this is stable not noise
		BEQ		not_working
d476 3
a478 3
		Debug	adverr, "Return VC"
		CLRV
		EXIT
d482 3
a484 3
	; ADD a wait loop and check that the error is stable
	; r0 ppstat, r1 is the error
	; r3 is the address of the ppstat this needs to be read on each loop
d487 1
a487 1
		Push 	"r2,r3,lr"
a488 1
            [ HAL
d490 2
a491 5
            |
                LDR     r3, =pp_base
            ]
		LDR	r2, LoopFactor				; Get CPU speed rating
		MOV	r2, r2, LSR #2
d493 3
a495 3
		LDRB	r0, [r3, #pp_stat-pp_base]		; read status register byte
		TST	R0,R1
		BEQ	%FT25					; test to see if the ppstat clears
d497 2
a498 3
                BNE     %BT20					; this leaves the loop on EQ
		MOVS	R1, R1		;Set the NE condition,		stable error
                Pull	"r2,r3 ,pc"
d500 1
a500 1
		Pull	"r2,r3 ,pc"	;EQ condition is set	Not a stable error
d503 1
a503 1
		Push 	"r2,r3,lr"
a504 1
            [ HAL
d506 2
a507 5
            |
                LDR     r3, =pp_base
            ]
		LDR	r2, LoopFactor				; Get CPU speed rating
		MOV	r2, r2, LSR #2
d509 3
a511 3
		LDRB	r0, [r3, #pp_stat-pp_base]		; read status register byte
		TST	R0,R1
		BNE	%FT25					; this sets the condition to NE
d513 3
a515 3
                BNE     %BT20					; this sets the returning condition to EQ
25								; this is the error condition
                Pull	"r2,r3,pc"
d519 4
a522 4
		Debug		j, "paper out"
		MOV		r4, #0			;iteration count
		ADRL		r6, paper
		B		do_lookup_and_upcall
d525 4
a528 4
		Debug		j, "printer not connected"
		MOV		r4, #0			;iteration count
		ADRL		r6, online
		B		do_lookup_and_upcall
d531 4
a534 4
		Debug		j, "printer not working"
		MOV		r4, #0			;iteration count
		ADRL		r6, printer
		;fall through
d537 35
a571 35
		;Convert token in r6 to message in r6
		BL		OpenMessages
		ADDVS		r6, r0, #4
		BVS		do_upcall		;if it went wrong, use the error as the message

		ADRL		r0, MessagesWorkspace
		MOV		r1, r6
		ADRL		r2, localerrorblock
		MOV		r3, #?localerrorblock
		SWI		XMessageTrans_Lookup
		MOVVC		r6, r2
		ADDVS		r6, r0, #4		;if it went wrong, use the error as the message

do_upcall	;Make the upcall

		MOV		r0, #UpCall_MediaNotPresent
		MOV		r1, #fsnumber_DeviceFS
		MOV		r2, #-1			;message in r6 (not media type)
		MOV		r3, #-1			;device number irrelevant
		;r4 cleared first time, incremented subsequently
		MOV		r5, #&7FFFFFFF		;timeout (very big)
		;r6 set up depending on reason for upcall

		Debug		j, "OS_UpCall called", r0
		SWI		XOS_UpCall
		Debug		j, "OS_UpCall returned", r0
		EXIT		VS

		CMP		r0, #-1
		BNE		not_cancel	;if this falls through it does not call exit with message

		Debug		j, "SHOULD EXIT WITH MESSAGE"
		ADRL		r6, cancel		;move the specific error "cancel"
		BL		exit_with_message	; send exit message then exit
		EXIT		VS
d573 2
a574 2
		;Try to report the error state as it is now, but make sure that some error
		;is reported even if all conditions have been (coincidentally) cleared.
a575 1
        [ HAL
d577 1
a577 5
                LDRB            r0, [r0, #pp_stat-pp_base]
        |
		LDR 		r0, =pp_stat
		LDRB		r0, [r0]		; read status register byte
        ]
d579 9
a587 9
		; now we've got an error, so what type is it?
		TST		r0, #pp_stat_pe		; paper out?
		ADRNEL		r0, ErrorBlock_Parallel_PaperOut
		BNE		make_error

		TST		r0, #pp_stat_slct	; off-line?
		ADREQL		r0, ErrorBlock_Parallel_Offline
		ADRNEL		r0, ErrorBlock_Parallel_OtherError
		;fall through
d590 7
a596 7
		;r0 -> error block
		PullEnv
		[		international
		B		MakeError
		|
		RETURNVS
		]
d611 2
a612 2
		Entry 		"R1-R6"
		Debug		j, "exit with message"
d614 20
a633 20
		BL		OpenMessages
		ADDVS		r6, r0, #4
		BVS		send_exit		;if it went wrong, use the error as the message

		ADRL		r0, MessagesWorkspace
		MOV		r1, r6
		ADRL		r2, localerrorblock
		MOV		r3, #?localerrorblock
		SWI		XMessageTrans_Lookup
		MOVVC		r6, r2
		ADDVS		r6, r0, #4

send_exit	; call the end media search call

		MOV		R1, R6
		MOV		r0, #UpCall_MediaSearchEndMessage
		Debug		j, "OS_UpCall called", r0
		SWI		XOS_UpCall
		Debug		j, "OS_UpCall returned", r0
		EXIT
a651 1
        [ HAL
a652 3
        |
                MOV     r3, #IOC
        ]
a689 1
 [ HAL
a690 3
 |
;       r3 -> IOC
 ]
d699 2
a700 6
 [ HAL
                ADD     lr, r3, #pp_stat-pp_base
 |
                LDR     lr, =pp_stat
 ]
                LDRB    lr, [lr]                                ; lr  = status byte
d706 1
a706 1
                MRS     r1, CPSR ; Preserve full PSR to be on the safe side
d712 2
d742 1
a742 2
;	IRQ mode, interrupts off
 [ HAL
d744 2
a745 5
 |
;	r3 -> base of IOC memory space
 ]
;	r12 -> workspace
;	Not currently threaded (non-reentrant)
d747 2
a748 2
;	Interrupt serviced
;	r0--r3, r12 corrupted
d750 4
a753 4
;	Execution time <= 100µs
;	SWI's called by method on P R M p1-127 (X SWI's only)
;	Error stored---somewhere???
;	Calls re-entrant SWI's only
d761 1
a761 6
 [ HAL
                ADD     r1, r3, #pp_stat-pp_base
 |
                LDR     r1, =pp_stat
 ]
		LDR	r2, LoopFactor				; Get CPU speed rating and loop until PACK is high
d763 1
a763 1
                LDRB    r0, [r1]
d774 1
a774 1
		LDR	r2, LoopFactor				; Get CPU speed rating
d776 1
a776 1
                LDRB    r0, [r1]
a806 1
 [ HAL
a807 3
 |
;     r3 -> IOC
 ]
a852 4
                LDR     lr, =IOEB_ASICPresent-(C710+(&278*4)+pp_base) ; Big hack!
                ADD     lr, lr, r3
                ADD     r1, r3, #pp_data-pp_base
                STRB    byte, [r1]
d854 1
d867 6
a872 2
                LDR     lr, =IOEB_ASICPresent                   ; a safe place to read in IOC controlled
                                                                ; space to give us at least 5 ticks delay
a873 3
                LDR     r1, =pp_data                            ; r1 -> port to write to
                STRB    byte, [r1]                              ; write character
        ]
d876 1
a876 1
                LDRB    r0, [lr]
d878 1
a878 1
                LDRB    r2, [r1, #pp_ctrl-pp_data]
d880 1
a880 1
                STRB    r0, [r1, #pp_ctrl-pp_data]
d884 2
a885 2
                LDRB    r0, [lr]
                LDRB    r0, [lr]
d887 1
a887 1
                STRB    r2, [r1, #pp_ctrl-pp_data]              ; disable strobing
d891 4
a894 4
		[	FastBufferMan				; but not if we're using FastBufferMan JRC 14-Apr-1997
                LDRB    r0, [lr]
                LDRB    r0, [lr]
		]
a927 1
        [ HAL
a928 3
        |
                LDR     r1, =pp_base
        ]
d931 1
a931 1
                LDRB    tmp, [r1, #pp_ctrl-pp_base]
d933 1
a933 1
                STRB    tmp, [r1, #pp_ctrl-pp_base]     ; signal busy using SLCTIN (+ AUTOFD for ECP cables)
a955 5
            [ HAL
                LDR     r3, HardwareBase
            |
                MOV     r3, #IOC                        ; restore r3
            ]
d959 1
a959 2
                MRS     tmp, CPSR
                Push    "r0,r2-r3,r9,r12"
d966 1
a966 2
                Pull    "r0,r2-r3,r9,r12"
                MSR     CPSR_cf,tmp
d969 1
d989 2
a990 6
        [ HAL
                ADD     r2, r3, #pp_ctrl-pp_base
        |
                LDR     r2, =pp_ctrl
        ]
                LDRB    r0, [r2]
d992 1
a992 1
                STRB    r1, [r2]                        ; acknowledge using STROBE
d994 2
a995 2
                LDRB    r1, [r2]
                LDRB    r1, [r2]                        ; leave for at least 1µs
d998 1
a998 1
                STRB    r0, [r2]                        ; remove STROBE and busy (SLCTIN and AUTOFD)
a1026 5
        [ HAL
                LDR     r3, HardwareBase
        |
                MOV     r3, #IOC
        ]
d1047 1
a1047 1
		Debug   ioctl, "ioeb_ioctl, group = ", r5
d1061 1
a1061 1
		Debug   ioctl, "           reason = ", r5
d1063 2
a1064 2
		SUBS	r5,r5,#1                        ; we do not have reason code 0, so return an error
		BMI	ioctl_error			; if this is what is wanted
d1071 5
a1075 5
		B	ioctl_device_id_size
		B	ioctl_device_id_data
		B	ioctl_status
		B	ioctl_revnibble_size
		B	ioctl_revnibble_data
a1079 1
        [ HAL
d1081 1
a1081 4
        |
                LDR     r6, =pp_base
        ]
                LDRB    r7, [r6, #pp_stat-pp_base]
d1083 1
a1083 1
                B	ioctl_ret
d1089 2
a1090 2
;	     instance, does not. In practice, IOCTL_DEVICE_ID_DATA should be used instead
;	     (with a generous buffer).
d1092 2
a1093 2
		MOV	r8,#extensibility_request_device_id
		B	%FT30
d1100 2
a1101 2
;	     practice, it should not be used and IOCTL_REVNIBBLE_DATA should be used instead with a
;	     generous buffer.
d1103 1
a1103 1
		MOV	r8,#extensibility_request_revnibble
d1107 2
a1108 2
                MOV	r4, #0				; set up the amount read
                STR     r4, [r3, #4]			; set the size to zero
d1113 1
a1113 1
		B	ioctl_ret
d1121 2
a1122 2
		MOV	r8,#extensibility_request_device_id
                LDR     r7, [r3, #4]			; load the beginning of the data (size)
d1126 1
a1126 1
		; r7 = size to read
d1128 2
a1129 2
                MOV	r4, #0				; set up the amount read
                STR     r4, [r3, #4]			; set the size to zero
d1133 1
a1133 1
		B	ioctl_ret
d1143 2
a1144 2
		MOV	r8,#extensibility_request_revnibble
                LDR     r7, [r3, #4]			; load the beginning of the data (size)
d1148 1
a1148 1
		; r7 = size to read
d1150 2
a1151 2
                MOV	r4, #0				; set up the amount read
                STR     r4, [r3, #4]			; set the size to zero
d1155 1
a1155 1
		STR     r4, [r3, #4]			; store the size field in the IOCtl buffer
d1185 3
d1190 2
a1191 8
        [ HAL
                ASSERT pp_data = pp_base
                LDR     r1, HardwareBase
        |
                LDR     r1, =pp_data
        ]
                LDRB    r2, [r1, #pp_stat-pp_data]
                LDRB    r1, [r1]
d1212 4
a1215 7
        [ HAL
                ASSERT pp_data = pp_base
                LDR     lr, HardwareBase
        |
                LDR     lr, =pp_data            ; no need to disable IRQs
        ]
                STRB    r1, [lr]                ; it's atomic
d1238 3
a1240 1
                EntryS   "r0"
d1242 1
a1242 1
                SETPSR  I_bit, r0                               ; disable IRQs
d1244 1
a1244 6
        [ HAL
                LDR     r0, HardwareBase
        |
                LDR     r0, =pp_base
        ]
                LDRB    lr, [r0, #pp_ctrl-pp_base]!
d1247 1
a1247 1
                STRB    r2, [r0]                                ; update control register
a1278 1
                LDRB    lr, [r2, #pp_ctrl-pp_base]!
d1284 1
a1284 2
                LDR     r2, =pp_ctrl
                LDRB    lr, [r2]
d1286 1
d1289 1
a1289 1
                STRB    lr, [r2]                                ; update control register (hardware)
d1311 1
a1311 1
		Debug   ioctl, "IEEE1284_negotiate = ", r7
d1323 4
a1326 7
		MOV     r9, r6                  ; keep initial buffer pointer
                LDR     lr, =pp_ecr             ; make sure we are in compatability mode
        [ HAL
                LDR     r5, HardwareBase
                ADD     lr, lr, r5
        ]
                LDRB    r5, [lr]                ; r5 must be preserved for negotiate_finalise below!
d1331 2
a1332 2
		BEQ	%FT05                   ; not in fast mode or FIFO empty, so we can go on
		Debug   ioctl_err, "FPar in use"
d1335 1
a1335 1
		SETV
d1341 3
a1343 1
                STRB    r0, [lr]                ; this sets the combo into compatability mode (turns FIFO off)
d1345 1
a1345 1
		Debug   ioctl, "init"
d1347 1
a1347 9
        [ HAL
                LDR     r10, HardwareBase
                ADD     r1, r10, #pp_stat-pp_base
                ADD     r2, r10, #pp_ctrl-pp_base
        |
                LDR     r1, =pp_stat            ; r1 always contains the address of the status byte
                LDR     r2, =pp_ctrl            ; r2 always contains the address of the control byte
        ]
		LDRB	r10, [r2]               ; keep original ctrl byte value
d1352 1
a1352 1
                STR     r0, [r2]
d1366 2
a1367 8
        [ HAL
                ASSERT pp_data = pp_base
                LDR     lr, HardwareBase
        |
                LDR     lr, =pp_data
        ]
		LDRB	r0, [lr]
		ORR	r10, r10, r0, lsl#8     ; keep original data byte value
d1370 2
a1371 2
                STRB    r0, [r2]                ; pull the strobe line up
                STRB    r8, [lr]                ; set the data to Extensibility Request Value - event # 0
d1373 1
a1373 1
		PulseDelay lr                   ; make sure the data is stable before event # 1
d1377 1
a1377 1
                STRB    r0, [r2]                ; set the stimulus event 1.
d1382 1
a1382 1
                LDRB    r3, [r1]                ; negotiation phase, load status
d1392 1
a1392 1
		Debug   ioctl, "1284 failed, status = ", r3
d1395 1
a1395 1
		Debug   ioctl, "1284 OK ", r3
d1397 1
a1397 1
		PulseDelay r0                   ; delay before strobing the data
d1399 1
a1399 1
                LDRB    r3, [r2]                ; event 3 pull strobe down
d1401 1
a1401 1
                STRB    r3, [r2]
d1406 1
a1406 1
                STRB    r3, [r2]                ; event 4 on map
d1412 1
a1412 1
                LDR     r3, [r1]                 ; Load status
d1417 1
a1417 1
		Debug   ioctl_err, "1284 t/o (step 6)"
d1422 3
a1424 3
		TEQ     r8, #extensibility_request_revnibble
		EOREQ	r3, r3, #pp_stat_slct   ; toggle SLCT bit if required
		TST	r3, #pp_stat_slct       ; if set then success
d1427 1
a1427 1
		Debug   ioctl_err, "1284 t/o (XFlag)"
d1431 1
a1431 1
		Debug   ioctl, "XFlag OK"
d1434 2
a1435 2
		; OK, we have entered a valid state, so if anything goes wrong now, we have to
		; use the full handshake termination protocol
d1439 1
a1439 1
		Debug   ioctl_loop, "read loop, r4 = ", r4
d1441 1
a1441 1
                LDRB    r3, [r1]                ; main read loop
d1448 1
a1448 1
						; being in a valid state, so we use the immediate abort strategy
d1450 1
a1450 1
		Debug   ioctl_loop, "nibble read = ", r0
d1458 2
a1459 2
		; The buffer is full
		Debug   ioctl, "Buffer full r8 = ", r8
d1461 5
a1465 5
		; we return the size field in r4
		LDRB    r0, [r9]                ; read MSB of size
		LDRB	lr, [r9, #1]		; read LSB of size
		ORR	r4, lr, r0, lsl#8	; r4 = size
		Debug   ioctl, "New size field ", r4
d1468 4
a1471 4
		; the handshake termination sequence
		; we should only end up here if the protocol is in a valid state (IEEE1284-2000, section 7.7)
                LDRB    r3, [r1]                ; we have to take note of the current SLCT status
		AND	r14, r3, #pp_stat_slct
d1473 1
a1473 1
                LDRB    r3, [r2]
d1475 2
a1476 2
		BIC	r3, r3, #pp_ctrl_autofd ; this should be the case already, but just to be sure...
                STRB    r3, [r2]
d1478 1
a1478 1
		; we wait for the peripheral's response
d1482 2
a1483 2
                LDRB    r3, [r1]
		EOR	r3, r3, #pp_stat_notbusy    ; change notbusy to BUSY
d1485 1
a1485 1
		TSTNE	r3, #pp_stat_notbusy	; and BUSY to come up, too
d1490 2
a1491 2
		Debug   ioctl_err, "ERR BUSY t/o"
		B       negotiate_finalise      ; immediate abort
d1493 1
a1493 1
		; OK, now we wait for event 24 (no stimulus inbetween)
d1497 4
a1500 4
                LDRB    r3, [r1]
		EOR	r3, r3, #pp_stat_ack    ; invert nACK for NE test below
		EOR	r3, r3, r14             ; eor with initial SLCT status - if the bit is still the same as
						; before, it is clear now, or set if it has been flipped
d1502 1
a1502 1
		TSTNE	r3, #pp_stat_slct	; and SLCT to be flipped
d1507 2
a1508 2
		Debug   ioctl_err, "nACK low SLCT flip t/o"
		B       negotiate_finalise      ; immediate abort
d1510 3
a1512 3
                LDRB    r3, [r2]
		ORR	r3, r3, #pp_ctrl_autofd ; event 25
                STRB    r3, [r2]
d1517 1
a1517 1
                LDRB    r3, [r1]
d1523 1
a1523 1
		Debug   ioctl_err, "nACK high t/o"
d1525 2
a1526 2
		; this last check was only for the sake of completeness
		; we are at the end of the protocol and will return to compatibility mode anyway
d1528 5
a1532 5
		; OK, we did it! We are back in compatibility mode.
		; All we have to do now is to clear pp_ctrl_autofd (set nAutoFd high, event 28),
		; but this will be done using pp_ctrl_default below.
		Debug   ioctl, "Terminated OK"
		CLRV
d1535 2
a1536 9
		; V flag denotes error condition - must be preserved until EXIT
                LDR     lr, =pp_ecr             ; tidyup restore the ecr state to what it was.
        [ HAL
                ASSERT  pp_base = 0
                LDR     r3, HardwareBase
                STRB    r5, [r3, lr]
        |
                STRB    r5, [lr]
        ]
d1538 3
a1540 3
		; if we have just gone through the full termination handshake, the following stimulus performs
		; event 28 (nAutoFd high), else it indicates an immediate abort because it sets pp_ctrl_slctin
		; (nSelectIn low)
d1542 4
a1545 1
                STRB    r5, [r2]
d1547 1
a1547 7
        [ HAL
                LDR     lr, =IOEB_ASICPresent-(C710+(&278*4)+pp_base) ; Big hack!
                LDR     lr, [lr, r3]
        |
                LDR     lr, =IOEB_ASICPresent
		LDR	lr, [lr]                ; a slight delay
        ]
d1549 3
a1551 9
		MOV	r0, r10, lsr#8          ; get original data byte value back
        [ HAL
                ASSERT  pp_data = pp_base
                STRB    r0, [r3]                ; and restore it
        |
		LDR	lr, =pp_data
		STRB	r0, [lr]                ; and restore it
        ]
		STRB    r10, [r2]               ; restore the original ctrl byte
d1553 1
a1553 1
                LDR     r0, IRQFlags             ; check to see if we need to put back a CallAfter
a1563 12
; Entry r3 -> base of IOC memory space, r12 -> workspace, anymode
; Exit, corrupts r0-r3, r12.        r0-r3, r5, r9-r10 stacked formerly.  wp is r12 so now stacking that as well.

                 LDR    r0, Flags
                 TST    r0, #f_OpenForWrite
                 BEQ    %FT130                 ; there is no output stream
        [ :LNOT: HAL ; HardwareBase already loaded for HAL
                 MOV    R3, #IOC               ; r3 base of IOC memory space
        ]
                 BL     ioeb_wakeupTX

130
d1565 4
a1568 1
		Debug   ioctl, "negotiate_ret"
d1642 2
a1643 2
		Debug   ioctl_err, "negotiate_error"
		; NB. we return an untranslated error block, it will be translated by the caller
d1647 1
a1647 1
		B	negotiate_finalise
d1649 2
a1650 2
; entry. r1 = status, byte address
;        r2 = control, byte address
d1660 1
a1660 1
		Debug   nibble, "Reverse nibble read"
d1662 1
a1662 1
                LDRB    r3, [r2]
d1664 1
a1664 1
                STRB    r3, [r2]
d1669 1
a1669 1
                LDRB    r3, [r1]
d1675 1
a1675 1
		Debug   nibble_err, "ACK low t/o ", r3
d1678 2
a1679 2
		Debug   nibble, "ACK low, stat = ", r3
                LDRB    r4, [r1]                                ; read the first nibble from the status byte
d1685 1
a1685 1
                LDRB    r3, [r2]                                ; pull the autofd up again first nibble complete
d1687 1
a1687 1
                STRB    r3, [r2]
d1692 1
a1692 1
                LDRB    r3, [r1]
d1698 1
a1698 1
		Debug   nibble_err, "ACK high t/o ", r3
d1701 1
a1701 1
		Debug   nibble, "ACK high, stat = ", r3
d1703 1
a1703 1
                LDRB    r3, [r2]                                ; ready to read the second nibble, similar cycle as above
d1705 1
a1705 1
                STRB    r3, [r2]
d1710 1
a1710 1
                LDRB    r3, [r1]
d1716 1
a1716 1
		Debug   nibble_err, "ACK low2 t/o ", r3
d1719 2
a1720 2
		Debug   nibble, "ACK low2, stat = ", r3
                LDRB    r4, [r1]
d1726 1
a1726 1
                LDRB    r3, [r2]
d1728 1
a1728 1
                STRB    r3, [r2]
d1733 1
a1733 1
                LDRB    r3, [r1]
d1739 1
a1739 1
		Debug   nibble_err, "ACK high2 t/o ",r3
d1742 1
a1742 1
		Debug   nibble, "ACK high2, stat = ",r3
d1745 1
a1745 1
		Debug   nibble_err, "nibble error"
d1747 1
a1747 1
		; NB. we return an untranslated error block, it will be translated above
@


4.15
log
@Add support for HAL builds
Detail:
  s/Parallel - Use HAL_ControllerAddress to get the address of the 82C710. IOMD IRQ numbers are assumed.
  s/Common - Use HAL_ControllerAddress to get the address of IOMD when measuring the CPU speed
  s/FastCent, s/IOEB - Use HardwareBase for hardware access and HAL calls for IRQ handling instead of fixed IOC/IOMD address & direct memory poking
  s/IOEB, s/Parallel - HAL version of UpdateIOEBCtrl gets copied into the module workspace to allow it to be used with the old calling standard (since we need to look up the C710 address)
  s/IOC - Add code that'll warn if this file gets built for a HAL target
Admin:
  Tested on RiscPC via IOMD ROM softload.
  Code is rather rough and could do with cleaning up in places (e.g. direct poking of timer registers in s/Common, and less-than-optimal register save/restore in ClearPINTR macro)


Version 0.74. Tagged as 'Parallel-0_74'
@
text
@d221 1
a221 1
IOEBreset       EntryS   "r0-r3,r8,r9"
d225 3
a227 4
                MOV     r1, #&600
                MOV     r8, #0
                MOV     r9, #EntryNo_HAL_ControllerAddress
                SWI     OS_Hardware
d229 1
a229 1
                ADD     r0, r0, #&278*4
@


4.14
log
@Summary
  Fixed a number of bugs in reverse nibble
Detail:
  A CallAfter was occasionally trying to write a byte whilst the reverse nibble transfer was in progress. Pending CallAfters are removed before the reverse nibble and reinstated afterwards.
  A number of errors in the reverse nibble negotiate have been fixed.
Admin:
  10000 trials of alternately reading device ID and sending 250 zero bytes gives no errors with HP930C and HP K80

Version 0.69. Tagged as 'Parallel-0_69'
@
text
@d24 3
d28 1
d116 11
a126 1

d130 1
d220 26
d265 1
a265 1

d375 8
a382 1

d391 1
a391 1

d431 5
a435 1
		LDR 	r3, =pp_stat
d439 1
a439 1
		LDRB	r0, [r3]				; read status register byte
d485 4
d491 1
d523 5
a527 1
		LDR 	r3, =pp_stat
d531 1
a531 1
		LDRB	r0, [r3]				; read status register byte
d544 5
a548 1
		LDR 	r3, =pp_stat
d552 1
a552 1
		LDRB	r0, [r3]				; read status register byte
d619 4
d625 1
d700 3
d704 1
d741 6
a746 1
; in:   r3 -> IOC
d755 3
d759 1
d765 8
d781 1
a781 1

d801 3
d805 1
d823 3
d827 1
d873 6
a878 1
; in: r3 -> IOC
d912 17
a928 1

d946 1
a946 1

d1001 6
a1006 2
                LDR     r1, =pp_data
                LDRB    byte, [r1]                      ; get input byte
d1008 1
a1008 1
                LDRB    tmp, [r1, #pp_ctrl-pp_data]
d1010 1
a1010 1
                STRB    tmp, [r1, #pp_ctrl-pp_data]     ; signal busy using SLCTIN (+ AUTOFD for ECP cables)
d1033 3
d1037 1
d1040 12
d1064 1
d1072 3
d1076 1
d1114 3
d1118 1
d1172 6
a1177 2
                LDR     r6, =pp_stat
                LDRB    r7, [r6]
d1283 4
d1288 1
d1311 4
d1316 1
d1344 6
a1349 2
                LDR     r0, =pp_ctrl                            ; -> control port
                LDRB    lr, [r0]
d1375 11
d1390 1
a1390 1
                LDR     r2, =pp_ctrl                            ; -> control port
d1392 1
d1398 5
d1431 4
d1454 5
d1460 2
a1461 1
08              LDR     r2, =pp_ctrl            ; r2 always contains the address of the control byte
d1481 4
d1486 1
d1658 5
d1664 1
d1672 4
d1678 1
d1681 4
d1687 1
d1707 1
d1709 1
@


4.13
log
@  Improved error handling and ioctl support/bug fixes
Detail:
  Explan have added error elucidation from a printer
  They have also fixed a number of bugs in ioctl read device id
  I have done an interim fix of another bug in the reverse nibble code
Admin:
  Tested on RPC. No errors in several thousand reads of device ID and no errors on several thousand reads of device ID interleaved with sending data

Version 0.68. Tagged as 'Parallel-0_68'
@
text
@d67 2
a68 1

a872 2


d972 1
d1136 1
a1228 1

d1235 10
d1249 10
a1258 14
                BL      wait_for_buffers_to_empty
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT    VS

;                [  FastCentronics               ; if we are in fast mode get out of it first
;                TST     r5, #pp_ecr_flag_FIFO
;                TSTNE   r5, #pp_ecr_empty
;		BEQ	%FT05                   ; not in fast mode or FIFO empty, so we can go on
;		Debug   ioctl_err, "FPar in use"
;                ADRL    r0, ErrorBlock_Parallel_InUse
;                STR     r0, [sp, #Proc_RegOffset]
;		SETV
;                EXIT
;                ]
d1267 2
d1270 16
a1285 21
               
                LDR     r2, LoopFactor          ; LoopFactor = loops for ~40us
                MOV     r2, r2, LSL#4           ; Loop for ~1ms
07              LDR     r0, [r1]                ; read the status
                TST     r0, #pp_stat_notbusy    ; set => ready for data
                BNE     %F08                    ; ready for data so continue
                SUBS    r2, r2, #1
                BNE     %B07                    ; not timed out

                ADRL    r0, ErrorBlock_Parallel_BadHardware
                STR     r0, [sp, #Proc_RegOffset]
                SETV
                EXIT

08
                LDR     r2, LoopFactor          ; LoopFactor = loops for ~40us
                MOV     r2, r2, LSL#4           ; ~1ms
09              SUBS    r2, r2, #1
                BNE     %B09
 
                LDR     r2, =pp_ctrl            ; r2 always contains the address of the control byte
a1286 1
		LDRB	r10, [r2]               ; keep original ctrl byte value
d1290 1
d1293 1
a1293 1
                STRB    r8, [lr]                ; set the data to Extensibility Request Value
d1295 1
a1295 1
		PulseDelay lr                   ; make sure the data is stable before event 1
d1302 1
a1302 1
                MOV     r0, r0, LSL #10         ; 40 us * &400
d1304 7
a1310 4
                LDRB    r3, [r1]                ; negotiation phase
                TST     r3, #pp_stat_error
                TSTNE   r3, #pp_stat_pe
                BNE     %FT20                   ; IEEE 1284 compatabiility
d1314 1
a1314 1
		Debug   ioctl, "1284 failed ", r3
d1330 1
a1330 3
		; wait 35ms to give the device time to respond
		; if we want the device ID, then the XFlag response is positive,
		; so we will not see a change in the line!
d1332 1
a1332 1
                MOV     r0, r0, LSL #10
d1334 10
a1343 6
		SUBS    r0, r0, #1
		BGT	%BT22

		; wait for peripheral response (event 5)
		; we need to see SLCT going low if this is nibble mode else we want SLCT to go
		; high (see table 4 in 1284-2000, column "XFlag affirmative response")
d1345 4
a1348 12
		MOVEQ	lr,#0                   ; we set up r14 to toggle the bit in modes other
		MOVNE	lr,#pp_stat_slct	; than reverse nibble mode
                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10
25
                LDRB    r3, [r1]
		EOR	r3, r3, lr              ; toggle SLCT bit if required
		TST	r3, #pp_stat_slct       ; wait for our adapted SLCT to clear
                BEQ     %FT28
                SUBS    r0, r0, #1
                BGT     %BT25

d1355 1
a1355 21
		; OK, so we have successfully entered the given mode
		; However, there may not be any data!
		TST     r3, #pp_stat_error      ; any data available?
		BNE	negotiate_tidy		; no, success

		Debug   ioctl, "data"
                PulseDelay r0                   ; give the periperal one pulse delay to set up ACK

                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10
30
                LDRB    r3, [r1]
                TST     r3, #pp_stat_ack        ; wait for the ACK to come up.
                BNE     %FT40
                SUBS    r0, r0, #1
                BGT     %BT30

		Debug   ioctl_err, "1284 t/o (ACK)"

                B       negotiate_error
40
d1359 1
a1359 1
                ; read data from peripheral
d1361 1
a1361 1
		Debug   ioctl, "read loop, r4 = ", r4
d1372 1
a1372 1
		Debug   ioctl, "nibble read = ", r0
d1378 1
a1378 1
                BLT     %BT40
d1453 1
a1453 1
		Debug   ioctl_err, "Terminated OK"
d1475 23
a1497 1
		Debug   ioctl_err, "negotiate_ret"
d1512 56
a1567 52
wait_for_buffers_to_empty
                ROUT
                Entry "r0-r9"

10              SWI     XOS_ReadMonotonicTime
                ADD     r7, r0, #&BC0          ; ~30 seconds in cs
                MOV     r8, #0                 ; used to store the number of characters in the buffer
                LDR     r9, =pp_stat           ; pointer to status register
20
        ; is the printer error free?
                LDR     r0, [r9]
                TST     r0, #pp_stat_error
                ADREQL  r0, ErrorBlock_Parallel_OtherError
                BEQ     %99

        ; user run out of patience? Check escape state
                SWI     XOS_ReadEscapeState
                ADRCSL  r0, ErrorBlock_Escape
                BCS     %98

        ; have we been here a stupidly long time?
                SWI     XOS_ReadMonotonicTime
                BVS     %99
                CMP     r7, r0
                ADRLTL  r0, ErrorBlock_Parallel_OtherError
                BLT     %98

        ; anything in the OS buffer PRM 4-97
                LDR     r0, BufferHandle
                SWI     XBuffer_GetInfo
                BVS     %99
                CMP     r6, #0
                BEQ     %30                         ; os buffer is empty

        ; are characters still departing?
                CMP     r6, r8                      ; always false first time round, but that doesn't matter
                MOV     r8, r6                      ; remember the number of characters in the buffer
                BNE     %10                         ; characters are going, so reset timeout
                B       %20                         ; no character gone, so don't reset the timeout

30      ; is the hardware buffer in use, and if so, is it empty
                TST     r5, #pp_ecr_flag_FIFO       ; in fast mode?
                BEQ     %40                         ; it is not in use, so carry on
                TST     r5, #pp_ecr_empty           ; buffer empty?
                BEQ     %20                         ; not empty, so go round again
                
40
                EXIT
98
                SETV
99              STR     r0, [sp, #Proc_RegOffset]
                EXIT
@


4.12
log
@  Integrated bug fixes made by RISC OS ltd.
Detail:
  these relate to reading the device id only.
  In ioctl terms;
  when reading size the data word is an integer word.
  when reading data the size is the first two nibbles as in the IEE1286 spec.
  This appears to only work when the file is open for writing only.  The
  reasons for this as yet uninvestigated.
Admin:
  This has been tested but not during a print job etc. only as a stand alone
  thing.

Version 0.67. Tagged as 'Parallel-0_67'
@
text
@d56 13
d92 3
a94 1
ioctl_reason_MAX	* 3
d97 10
a106 2
ioctl_header_read	* 1:SHL:7
ioctl_header_write      * 1:SHL:6
d129 1
a350 1
; 	r1  =
d353 2
a354 1
; out:  r0-r2 corrupted
a369 2
		LDR 		r0, =pp_stat
		LDRB		r0, [r0]		; read status register byte
d371 63
a433 1
		Entry		"r1-r9"			; OS_UpCall needs up to r6, but we can corrupt up to r2
d451 3
a453 1

d498 1
a498 1
		ADR		r6, paper
d979 2
a980 1
; present this only implements calls used to get the DEVICE ID.
d982 2
a983 1
; dumps the contents b0 least significant byte
d986 5
a990 1
                Entry "r0, r5-r7"
a991 1
                LDRB    r5, [r3, #2]
d997 1
a997 1
                CMP     r5, #ioctl_header_read           ; read flag must be set
d1002 21
a1022 5
                AND     r5, r5, r0                      ; the least significant word is the reason
                CMP     r5, #ioctl_reason_MAX		; is it within the range on understood reasons
                BHI     ioctl_error
                CMP	r5, #ioctl_reason_status	; are we after the status byte
                BNE	%FT5
d1026 39
a1064 5
                B	%FT20
5
                CMP     r5, #ioctl_reason_data		; determine if it is data or size we are after
                MOVLT   r7, #2                          ; to read the size read only two bytes
                BLT     %FT10
d1066 4
a1069 5
                LDRB    r5, [r3, #3]
                CMP     r5, #ioctl_header_write		; ensure the write bit is set
                CMPEQ   r7, #2
                BLE     ioctl_error                     ; make sure the size is at least the size field;
10
d1071 1
a1071 1
                MOV	R4, #0				; set up the amount read
d1076 14
d1091 9
a1099 8
                LDRB	r5, [r3]
                CMP	r5, #ioctl_reason_size
                BNE	%FT20
                LDRB    r5, [r3, #5]                    ; byte swap the size, zero the most significant two.
                LDRB    r4, [r3, #4]
                ORR     r5, r5, r4, LSL #8
                STR     r5, [r3, #4]
20
d1221 7
a1227 3
; reg usage;
; on entry r6 is the buffer to write to
; r7 is the size to read including the size.
d1231 1
a1231 1
                Entry "r0-r3,r5"
d1233 3
d1237 5
a1241 1
                LDRB    r5, [lr]
d1243 10
a1252 7
                [  FastCentronics               ; if we are in fast mode get out of it and store
                TST     r5, #pp_ecr_flag_FIFO
                TSTNE   r5, #pp_ecr_empty
                ADRNEL  r0, ErrorBlock_Parallel_InUse
                STRNE   r0, [sp, #Proc_RegOffset]
                EXIT    NE
                ]
d1254 1
d1258 30
a1287 1
                LDR     r2, =pp_ctrl            ; r2 now always contains the address of the control byte
d1290 4
a1293 3
                LDR     lr, =pp_data
                MOV     r3, #&04                ; request Device Id string using reverse nibble mode
                STRB    r3, [lr]                ; set the data to Extensibility Request Value
a1297 1
                LDR     r1, =pp_stat
d1307 3
a1309 2
                MOV     r0, #0                  ; data read is zero.
                B       negotiate_tidy          ; 1284 failed
d1311 4
d1324 39
d1371 4
a1374 1
                B       negotiate_tidy
d1376 3
d1381 2
d1389 4
a1392 1
                BVS     negotiate_tidy
d1397 12
a1408 2
                CMP     r7, r4
                BGT     %BT40
d1410 68
d1480 4
a1483 1
                LDR     r1, =pp_ctrl
d1485 4
a1488 1
                STRB    r5, [r1]
d1490 71
d1563 16
a1578 4
; register usage
; r0 returns byte or error on error
; r1 status, byte address
; r2 control, byte address
d1583 2
d1597 2
d1601 1
d1620 2
d1624 2
a1629 2
                LDRB    r3, [r2]

d1638 2
d1642 1
d1661 2
d1665 1
d1668 3
a1672 1
                STRVS   r0, [sp, #Proc_RegOffset]
@


4.11
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.66. Tagged as 'Parallel-0_66'
@
text
@d70 1
a70 1
pp_ctrl_default         * pp_ctrl_init :OR: pp_ctrl_slctin
d82 2
d906 1
a906 1
                CMP     r5, #1:SHL:7                    ; read flag must be set
d924 3
a926 3
                LDR     r7, [r3, #4]
                LDR     r5, [r3, #3]
                CMP     r5, #1:SHL:6;
d928 1
a928 1
                BLE     ioctl_error
d930 3
a932 1
                ADD     r6, r3, #6                      ; r6 is the address of the data
d937 5
a941 2
                LDRB    r5, [r3, #7]                    ; byte swap the size, zero the most significant two.
                LDRB    r4, [r3, #6]
d1072 1
a1072 1
                Entry "r0-r5"
a1130 1
                MOV     r4, #0                  ; set up the counts, avoiding the always blank first two bytes
d1144 1
a1144 1
                BGT     %BT50
@


4.10
log
@  Added IOCTL call to return the status byte.
Detail:
  This allows applications other than the parallel device driver to determine
  what the setting of output lines means.  The Parallel Device driver will
  still raise errors based on its idea of what is the cause of the printer error
  is perhaps this behavior can be configured.
Admin:
   This has been loosly tested and the code reviewed.  In essence it is a simple
   change.

Version 0.65. Tagged as 'Parallel-0_65'
@
text
@d216 1
a216 1
ioeb_open       ENTRY   "r0,r1"
d247 1
a247 1
ioeb_close      ENTRY   "r0-r2"
d347 1
a347 1
		ENTRY		"r1-r9"			; OS_UpCall needs up to r6, but we can corrupt up to r2
d500 1
a500 1
		ENTRY 		"R1-R6"
d586 1
a586 1
ioeb_busy       ENTRY   "r0,r1"
d896 1
a896 1
                ENTRY "r0, r5-r7"
d989 1
a989 1
                ENTRY
d1065 1
a1065 1
                ENTRY "r0-r5"
d1154 1
a1154 1
                ENTRY   "r3-r5"
@


4.9
log
@  kbracey_32bit branch taken.
Detail:
  This is the result of the 32-bit branch merge.
Admin:
  This module has received modest testing.  It has not been exhaustively
    tested.  Projects taking this version should be careful with it as it
    may contain bugs.

Version 0.64. Tagged as 'Parallel-0_64'
@
text
@d78 2
d910 10
a919 3
                CMP     r5, #ioctl_reason_data
                BGT     ioctl_error

d937 1
a937 1

@


4.8
log
@  added device identification.
Detail:
  this allows the host to query the peripheral as to what it is.  As per
  IEEE1284-1994 spec.
Admin:
  This has not been excessivly tested as it does not interfere with the
  usual workings of the parallel port.  It has been tested with the
  lexmark Z12 and a HP 950

Version 0.63. Tagged as 'Parallel-0_63'
@
text
@d120 2
d123 2
d132 3
a134 3
                MOVS    pc, lr					; wakeup RX
                MOVS    pc, lr					; sleep RX
                MOVS    pc, lr					; enum dir
d137 1
a137 1
                MOVS    pc, lr					; halt
d139 1
a139 1
                MOVS    pc, lr					; end of data
d141 3
a143 3
		B	ioeb_monitorTX				; check sending is okay
		MOVS	pc, lr					; monitor rx
		B	ioeb_ioctl				; ioctl
d146 13
a158 1
                DoError                                         ; then generate an error
d176 1
a176 1
IOEBreset       ENTRY   "r0,r1"
d275 1
a275 1
ioeb_created    ENTRY   "r0-r2"
d284 1
a284 1
                STRVS   r0, [sp]
d293 1
a293 3
                MOV     lr, pc
                TST     lr, #I_bit              ; if IRQs enabled then
                TEQEQP  lr, #I_bit              ; disable them
d301 1
a301 1
                EXITS   EQ                      ; do nothing else if open for output
d309 1
a309 2
                TST     lr, #F_bit              ; if FIQs enabled then
                TEQEQP  lr, #F_bit              ; disable them
d315 1
a315 1
                EXITS
a338 37
		[		false

; First, a version that just returns any printer error straight back to the caller (for testing).

ioeb_monitorTX	ROUT
		LDR 		r1, =pp_stat
		LDRB		r0, [r1]		; read status register byte

		TST		r0, #pp_stat_error	; pp_stat_error clear for any of pe, offline, other error
		MOVNES		pc, lr			; All o k

		;We've got an error, so what type is it?
		Debug		j, "some sort of error"
		TST		r0, #pp_stat_pe		; out of paper?
		BNE		paper_out

		TST		r0, #pp_stat_slct	; off-line?
		BEQ		off_line
		B		not_working

paper_out	ADRL		r0, ErrorBlock_Parallel_PaperOut
		B		make_error

off_line	ADRL		r0, ErrorBlock_Parallel_Offline
		B		make_error

not_working	ADRL		r0, ErrorBlock_Parallel_OtherError
		;fall through

make_error
		[		international
		B		MakeError
		|
		ORRS		pc, lr, #V_bit
		]
		|

a436 2
		BL		CloseMessages

d482 1
a482 1
		ORRS		pc, lr, #V_bit
d486 7
a492 47
		[ {TRUE}

		; New strategy. Just exit with continuing message and let the higher levels
		; raise the error again if necessary. This should be cleaner and provides
		; more feedback to the user.

		ADRL		r6, continue		;move the specific error "continue"
		BL		exit_with_message	; All o k
		EXIT		VS			;This is the actual correct exit of this routine
		EXITS

		|

		TEQ		r0, #0
		DebugIf		NE, j, "never happens (intercepted vector should always have r0 == 0 or -1)", r0
		EXITS		NE

confirm
		Debug		j, "user said it's ok now"
		;checking that there is really media there now
		LDR 		r0, =pp_stat
		LDRB		r0, [r0]		; read status register byte
		TST		r0, #pp_stat_error	; pp_stat_error clear for any of pe, offline, other error
		BEQ		stillerr
		ADRL		r6, continue		;move the specific error "continue"
		BL		exit_with_message	; All o k
		EXIT		VS			;This is the actual correct exit of this routine
		EXITS

		;Still got an error, so what type is it now?
stillerr	TST		r0, #pp_stat_pe
		ADRNEL		r6, paper		; paper out
		BNE		media_missing

		TST		r0, #pp_stat_slct
		ADREQL		r6, online		; off-line
		ADRNEL		r6, printer		; miscellaneous
		;fall through

media_missing
		Debug		j, "media still missing", r4
		ADD		r4, r4, #1		;increment iteration count
		B		do_lookup_and_upcall	;make upcall again
		EXIT		VS
		EXITS
		]
		]
a512 2
		BL		CloseMessages

d520 1
a520 2
		EXIT		VS
		EXITS
d535 1
a535 1
ioeb_wakeupTX   ENTRY   "r0-r3"
d537 1
a537 2
                ORR     lr, lr, #I_bit          ; disable IRQs round this bit
                TEQP    lr, #0
d542 1
a542 1
                EXITS   EQ
d545 1
a545 1
                STR     r0, [sp]
d548 1
a548 1
                EXITS   NE                      ; then exit
d557 1
a557 1
                EXITS
d559 3
a561 6
ioeb_busy_check_callafter ENTRY "r0"
                MOV     r0, pc
                ORR     lr, r0, #SVC_mode :OR: I_bit
                TEQP    lr, #0                          ; switch to SVC mode, IRQs off
                NOP
                Push    "r0, lr"                        ; save old flags, r14_svc
a565 3
                Pull    "r0, lr"
                TEQP    r0, #0                          ; restore old mode
                NOP
d587 3
a589 3
                TST     lr, #pp_stat_notbusy                    ; is the port busy? =0 if so
                PullEnv NE
                ORRNES  pc, lr, #Z_bit                          ; return EQ, ie. port free
d593 2
a594 4
                MOV     lr, #F_bit                              ; disable FIQs round updates
                TST     lr, pc                                  ; to IOCIRQMSKA
                TEQEQP  lr, pc

d598 1
d600 1
a600 4
                TEQEQP  lr, pc

                PullEnv
                BICS    pc, lr, #Z_bit                          ; Z=0, ie. printer is busy, NE
d647 1
a647 1
                MOVS    pc, lr                                  ; so clear interrupt and exit (printer on will start again)
d663 1
a663 1
                MOVNES  pc, lr                                  ; then exit
d665 2
a666 4
                MOV     r3, pc
                ORR     r0, r3, #SVC_mode                       ; go into SVC_mode to issue SWI call
                TEQP    r0, #0
                NOP
d668 1
a669 1
                LDR     r0, =BusyCheckInterval
d677 1
a677 1
                TEQP    r3, #0                                  ; restore IRQ mode
d679 1
a679 1
                MOVS    pc, lr                                  ; and exit
d690 1
a690 1
ioeb_strobe     ENTRY
d702 1
a702 1
                MOV     r2, pc
d704 2
a705 1
                ORR     lr, r2, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
d707 1
a707 1
                TEQP    lr, #0                                  ; change to SVC mode with C and V clear
d714 1
a714 1
                TEQP    r2, #0
d720 1
a720 3
                MOV     lr, #F_bit
                TST     lr, pc                                  ; FIQs currently enabled?
                TEQEQP  lr, pc                                  ; ensure that they are no longer
d727 2
a728 2
                TEQEQP  lr, pc                                  ; restore FIQ status (IRQs still disabled)
                EXITS   CS                                      ; if no character then exit
d762 1
a762 1
                EXITS   EQ
d764 4
a767 3
                MOV     r2, pc
                ORR     lr, r2, #SVC_mode                       ; force SVC mode
                TEQP    lr, #0
d775 1
a775 1
                TEQP    r2, #0                                  ; switch back
d790 1
a790 1
ioeb_irqread    ENTRY   "r0-r3"
d807 4
a810 4
                MOV     r3, pc
                BIC     r3, r3, #C_bit :OR: V_bit
                ORR     lr, r3, #SVC_mode
                TEQP    lr, #0                          ; change to SVC mode (C & V clear)
d819 1
a819 1
                TEQP    r3, #0                          ; back to old mode
d825 1
a825 3
                MOV     lr, pc
                TST     lr, #F_bit
                TEQEQP  lr, #F_bit                      ; disable FIQs
d832 3
a834 1
                TEQEQP  lr, #0                          ; restore FIQs
d868 1
a868 2
                ORR     lr, lr, #I_bit
                TEQP    lr, #0                  ; disable IRQs
d872 1
a872 1
                EXITS   EQ
d893 2
a894 2
		ROUT
		ENTRY "r0, r5-r7"
d896 22
a917 22
		LDRB	r5, [r3, #2]
		LDR	r6, =ioctl_group_parallel	; make sure we are in the right group
		CMP	r6, r5
		BNE	ioctl_error

		LDRB	r5, [r3, #3]
		CMP	r5, #1:SHL:7			; read flag must be set
		BEQ	ioctl_error

		LDR	r5, [r3]
		LDR	r0, =ioctl_reason_mask
		AND	r5, r5, r0			; the least significant word is the reason
		CMP	r5, #ioctl_reason_data
		BGT	ioctl_error

		MOVLT	r7, #2				; to read the size read only two bytes
		BLT	%FT10
		LDR	r7, [r3, #4]
		LDR	r5, [r3, #3]
		CMP	r5, #1:SHL:6;
		CMPEQ	r7, #2
		BLE	ioctl_error
d919 1
a919 1
		ADD	r6, r3, #6			; r6 is the address of the data
d921 2
a922 2
		BL	IEEE1284_negotiate
		EXIT    VS
d924 4
a927 4
		LDRB	r5, [r3, #7]			; byte swap the size, zero the most significant two.
		LDRB	r4, [r3, #6]
		ORR	r5, r5, r4, LSL #8
		STR	r5, [r3, #4]
d929 1
a929 1
		EXITS
d931 10
a940 3
		ADRL	r0, ErrorBlock_Parallel_BadParm	; this must be set
		PullEnv
		DoError
d956 2
a957 2
                ORR     r1, lr, #I_bit
                TEQP    r1, #0                                  ; disable IRQs
d963 1
a963 1
                MOVS    pc, lr
d983 1
a983 1
                EXITS
d1005 1
a1005 1
                ENTRY   "r0"
d1007 1
a1007 2
                ORR     lr, lr, #I_bit
                TEQP    lr, #0                                  ; disable IRQs
d1016 1
a1016 1
                EXITS
d1036 1
a1036 1
UpdateIOEBCtrl  ENTRY   "r2"
d1038 1
a1038 2
                ORR     lr, lr, #I_bit
                TEQP    lr, #0                                  ; disable IRQs
d1046 1
a1046 1
                EXITS                                           ; exit, restoring original IRQ state
d1055 2
a1056 2
		ROUT
		ENTRY "r0-r5"
d1058 2
a1059 2
                LDR     lr, =pp_ecr		; make sure we are in compatability mode
		LDRB	r5, [lr]
d1061 20
a1080 7
		[  FastCentronics		; if we are in fast mode get out of it and store
		TST	r5, #pp_ecr_flag_FIFO
		TSTNE	r5, #pp_ecr_empty
		ADRNEL  r0, ErrorBlock_Parallel_InUse
		PullEnv NE
		DoError NE			; exit FIFO in use
		]
d1082 3
a1084 16
		MOV	r0, #pp_ecr_default	; mode 001 as we may want to tri-state the data lines
		STRB	r0, [lr]		; this sets the combo into compatability mode (turns FIFO off)

                LDR     r2, =pp_ctrl		; r2 now always contains the address of the control byte
		MOV	r0, #pp_ctrl_default
		STRB	r0, [r2]		; pull the strobe line up
                LDR     lr, =pp_data
		MOV	r3, #&04		; request Device Id string using reverse nibble mode
		STRB	r3, [lr]		; set the data to Extensibility Request Value
		ORR	r0, r0, #pp_ctrl_autofd
		BIC	r0, r0, #pp_ctrl_slctin
		STRB	r0, [r2]		; set the stimulus event 1.

		LDR	r1, =pp_stat
		LDR	r0, LoopFactor		; wait for peripheral response
		MOV	r0, r0, LSL #10		; 40 us * &400
d1086 8
a1093 8
		LDRB	r3, [r1]		; negotiation phase
		TST	r3, #pp_stat_error
		TSTNE	r3, #pp_stat_pe
		BNE	%FT20			; IEEE 1284 compatabiility
		SUBS	r0, r0, #1
		BGT	%BT10
		MOV	r0, #0			; data read is zero.
		B	negotiate_tidy		; 1284 failed
d1095 3
a1097 3
		LDRB	r3, [r2]		; event 3 pull strobe down
		ORR	r3, r3, #pp_ctrl_strobe
		STRB	r3, [r2]
d1099 1
a1099 1
		PulseDelay r0			; delay for 5 us to ensure the peripheral sees it.
d1101 2
a1102 2
		BIC	r3, r3, #pp_ctrl_autofd :OR: pp_ctrl_strobe
		STRB	r3, [r2]		; event 4 on map
d1104 2
a1105 2
		LDR	r0, LoopFactor		; wait for peripheral response
		MOV	r0, r0, LSL #10
d1107 6
a1112 6
		LDRB	r3, [r1]
		TST	r3, #pp_stat_ack	; wait for the ACK to come up.
		BNE	%FT40
		SUBS	r0, r0, #1
		BGT	%BT30
		B	negotiate_tidy
d1114 2
a1115 2
		; read data from peripheral
		MOV	r4, #0			; set up the counts, avoiding the always blank first two bytes
d1117 3
a1119 3
		LDRB	r3, [r1]		; main read loop
                TST	r3, #pp_stat_error	; determine if there is data to read
	        BNE	negotiate_tidy		; no data left
d1121 1
a1121 1
		BL	reverse_nibble_read	; read the byte
d1123 1
a1123 1
		BVS	negotiate_tidy
d1125 1
a1125 1
		STRB	r0, [r6, r4]		; this stores the data at the buffer including the first two bytes
d1127 3
a1129 3
		ADD	r4, r4, #1
		CMP	r7, r4
		BGT	%BT50
d1131 5
a1135 6
		SWI	XOS_NewLine
		LDR	lr, =pp_ecr 		; tidyup restore the ecr state to what it was.
		STRB	r5, [lr]
		LDR	r1, =pp_ctrl
		MOV	r5, #pp_ctrl_default
		STRB	r5, [r1]
d1137 1
a1137 1
		EXIT
d1144 2
a1145 2
		ROUT
		ENTRY	"r3-r5"
d1147 3
a1149 3
		LDRB	r3, [r2]
		ORR	r3, r3, #pp_ctrl_autofd			; pull the autofd line down
		STRB	r3, [r2]
d1151 2
a1152 2
		LDR	r4, LoopFactor				; maximum of 35 milliseconds peripheral response
		MOV	r4, r4, LSL #10				; 40 us * 1000 ~=(&400)
d1154 6
a1159 6
		LDRB	r3, [r1]
		TST	r3, #pp_stat_ack			; wait for data, ack low
		BEQ	%FT55
		SUBS	r4, r4, #1
		BGT	%BT50
		B	nibble_error
d1161 9
a1169 9
		LDRB	r4, [r1]				; read the first nibble from the status byte
		AND	r0, r4, #pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error ; find bits 2, 1 and 0 resp. masked as 5, 4 & 3
		MOV	r0, r0, LSR #3
		TST	r4, #pp_stat_notbusy			; see if bit seven is set
		ORREQ	r0, r0, #&08				; make that bit 3

		LDRB	r3, [r2]				; pull the autofd up again first nibble complete
		BIC	r3, r3, #pp_ctrl_autofd
		STRB	r3, [r2]
d1171 2
a1172 2
		LDR	r4, LoopFactor				; wait for ack to come back up again
		MOV	r4, r4, LSL #10
d1174 6
a1179 6
		LDRB	r3, [r1]
		TST	r3, #pp_stat_ack			; wait for data
		BNE	%FT70
		SUBS	r4, r4, #1
		BGT	%BT65
		B	nibble_error
d1181 3
a1183 3
		LDRB	r3, [r2]				; ready to read the second nibble, similar cycle as above
		ORR	r3, r3, #pp_ctrl_autofd			; pull the autofd line down
		STRB	r3, [r2]
d1185 1
a1185 1
		LDRB	r3, [r2]
d1187 2
a1188 2
		LDR	r4, LoopFactor
		MOV	r4, r4, LSL #10
d1190 6
a1195 6
		LDRB	r3, [r1]
		TST	r3, #pp_stat_ack			; wait for the lowering of the ack
		BEQ	%FT80
		SUBS	r4, r4, #1
		BGT	%BT75
		B	nibble_error
d1197 9
a1205 9
		LDRB	r4, [r1]
		TST	r4, #pp_stat_notbusy			; see if bit seven is set
		ORREQ	r0, r0, #&80
		AND	r3, r4, #pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error ; find bits 2, 1 & 0, masked as 5 , 4 & 3
		ORR	r0, r0, r3, LSL #1			; set the top nibble

		LDRB	r3, [r2]
		BIC	r3, r3, #pp_ctrl_autofd
		STRB	r3, [r2]
d1207 2
a1208 2
		LDR	r4, LoopFactor
		MOV	r4, r4, LSL #10
d1210 6
a1215 6
		LDRB	r3, [r1]
		TST	r3, #pp_stat_ack			; wait for the raising of the ack
		BNE	%FT90
		SUBS	r4, r4, #1
		BGT	%BT85
		B	nibble_error
d1217 1
a1217 1
		EXIT
d1219 4
a1222 3
		ADRL    r0, ErrorBlock_Parallel_BadHardware 	; timeout
		PullEnv
		DoError
@


4.7
log
@Completed interrupt changes - may actually work now.

Version 0.60. Tagged as 'Parallel-0_60'
@
text
@d29 6
d43 3
d47 2
d56 5
d71 1
a71 1
pp_ecr_default          * 2_001:SHL:5 :OR: pp_ecr_errintdis
d76 4
d90 12
d139 1
a139 1
		MOVS	pc, lr					; ioctl
d967 50
d1125 176
@


4.7.2.1
log
@  First cut at 32-bit compatibility.
Detail:
  Lots of changes have been required in this module as it manipulates
    the PSR all over the place in various interesting ways.
Admin:
  Built, but not tested yet.

Version 0.60, 4.13.2.1. Tagged as 'Parallel-0_60-4_13_2_1'
@
text
@a87 2
                Push    lr
                SavePSR lr
a88 2
                Push    lr
                ADR     lr, device_call_exit
d96 3
a98 3
                MOV     pc, lr                                  ; wakeup RX
                MOV     pc, lr                                  ; sleep RX
                MOV     pc, lr                                  ; enum dir
d101 1
a101 1
                MOV     pc, lr                                  ; halt
d103 1
a103 1
                MOV     pc, lr                                  ; end of data
d105 3
a107 3
                B       ioeb_monitorTX                          ; check sending is okay
                MOV     pc, lr                                  ; monitor rx
                MOV     pc, lr                                  ; ioctl
a108 1
                Pull    lr
d110 1
a110 9
                Pull    lr
                B       make_error

device_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,f
                Pull    pc
d128 1
a128 1
IOEBreset       EntryS   "r0,r1"
d227 1
a227 1
ioeb_created    EntryS  "r0-r2"
d236 1
a236 1
                STRVS   r0, [sp, #Proc_RegOffset]
d245 3
a247 1
                SETPSR  I_bit,lr                ; Disable interrupts
d263 2
a264 1
                SETPSR  F_bit,lr                ; disable FIQs
d294 37
d429 2
d476 1
a476 1
		RETURNVS
d480 47
a526 7
                ; New strategy. Just exit with continuing message and let the higher levels
                ; raise the error again if necessary. This should be cleaner and provides
                ; more feedback to the user.

                ADRL            r6, continue            ;move the specific error "continue"
                BL              exit_with_message       ; All o k
                EXIT                                    ;This is the actual correct exit of this routine
d547 2
d556 2
a557 1
		EXIT
d572 1
a572 1
ioeb_wakeupTX   EntryS  "r0-r3"
d574 2
a575 1
                SETPSR  I_bit, lr               ; disable IRQs round this bit
d583 1
a583 1
                STR     r0, [sp, #Proc_RegOffset]
d597 6
a602 3
                ; CallAfter routine.  Entered in SVC mode with IRQs disabled.
                ; Must preserve all registers and exit with MOV pc, lr (PRM 1-429)
ioeb_busy_check_callafter EntryS "r0"
d607 3
d631 3
a633 3
                AND     r1, lr, #pp_stat_notbusy                ; is the port busy? =0 if so
                EORS    r1, r1, #pp_stat_notbusy                ; invert Z to be correct for any exit
                EXIT    EQ                                      ; return EQ, ie. port free
d637 4
a640 2
                ; disable FIQs round updates to IOCIRQMSKA
                SETPSR  F_bit,r0,,lr                            ; old PSR into lr (note: Z clear in lr!)
a643 1
                RestPSR lr,,cf                                  ; restores PSR
d645 4
a648 1
                EXIT                                            ; Z=0, ie. printer is busy, NE
d695 1
a695 1
                MOV     pc, lr                                  ; so clear interrupt and exit (printer on will start again)
d711 1
a711 1
                MOVNE   pc, lr                                  ; then exit
d713 4
a716 2
                ASSERT  (IRQ_mode :EOR: SVC_mode) = (IRQ32_mode :EOR: SVC32_mode)
                TOGPSR  (IRQ_mode :EOR: SVC_mode),r0,,r3        ; move from IRQ into SVC mode.
a717 1
                LDR     r0, =BusyCheckInterval                  ; takes place of NOP
d719 1
d727 1
a727 1
                RestPSR r3,,cf                                  ; restore IRQ mode
d729 1
a729 1
                MOV     pc, lr                                  ; and exit
d740 1
a740 1
ioeb_strobe     EntryS
d752 1
a752 1
                SavePSR r2
d754 1
a754 2
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
d756 1
a756 1
                RestPSR lr                                      ; change to SVC mode with C and V clear
d763 1
a763 1
                RestPSR r2
d769 3
a771 1
                SETPSR  F_bit,tmp,,lr                           ; set F bit, old PSR into lr
d778 1
a779 1
                RestPSR lr,,c                                   ; restore FIQ status (IRQs still disabled)
d815 3
a817 4
                SavePSR r2
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; force SVC mode
                RestPSR lr
d825 1
a825 1
                RestPSR r2                                      ; switch back
d840 1
a840 1
ioeb_irqread    EntryS  "r0-r3"
d857 4
a860 4
                SavePSR r3
                BIC     lr, r3, #2_01100 + C_bit + V_bit
                ORR     lr, lr, #SVC_mode
                RestPSR lr,,cf                          ; change to SVC mode (C & V clear)
d869 1
a869 1
                RestPSR r3                              ; back to old mode
d875 3
a877 1
                SETPSR  F_bit,tmp,,lr                   ; disable FIQs
d884 1
a884 3
                BICCC   lr, lr, #C_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,c                           ; restore FIQs
d918 2
a919 1
                SETPSR  I_bit,lr                ; disable IRQs
d950 2
a951 2
                EntryS
                SETPSR  I_bit,r2                        ; disable IRQs
d957 1
a957 1
                EXITS
d977 1
a977 1
                EXIT
d999 1
a999 1
                EntryS   "r0"
d1001 2
a1002 1
                SETPSR  I_bit, r0                               ; disable IRQs
d1031 1
a1031 1
UpdateIOEBCtrl  EntryS  "r2"
d1033 2
a1034 1
                SETPSR  I_bit,r2                                ; disable IRQs
@


4.7.2.2
log
@  JumpAddress macro used instead of simply ADR lr, device_call_exit
Detail:
  The former makes sure that the flags are in lr in 26-bit modes so that
    when the routine uses EntryS/EXITS you don't accidentally end up in
    USR mode.
Admin:
  Built.

Version 0.60, 4.13.2.3. Tagged as 'Parallel-0_60-4_13_2_3'
@
text
@d92 1
a92 1
                JumpAddress lr, device_call_exit, forward       ; load return address
@


4.7.2.3
log
@  Major stack imbalance fixed.
  EXITS macros passed the fields parameter.
Detail:
  EXITS does NOT restore the c part of the CPSR only the flags.  Since
    this module was relying on EXITS to reset IRQ/FIQ/mode bits, this
    module wasn't going to work very well.
  The error generator on the DeviceFS entry point was severely broken in
    that it would remove 10 words from the stack that weren't actually
    there.
Admin:
  Built, but untested.


Version 0.60, 4.13.2.4. Tagged as 'Parallel-0_60-4_13_2_4'
@
text
@d113 1
d115 2
a116 6
              [ international
                BL      MakeError
              |
                CMP     r0, #&80000000                          ; set V
                CMNVC   r0, #&80000000
              ]
d266 1
a266 1
                EXITS   EQ,cf                   ; do nothing else if open for output
d280 1
a280 1
                EXITS   ,cf
d507 1
a507 1
                EXITS   EQ,cf
d513 1
a513 1
                EXITS   NE,cf                   ; then exit
d522 1
a522 1
                EXITS   ,cf
d692 1
a692 1
                EXITS   CS,cf                                   ; if no character then exit
d727 1
a727 1
                EXITS   EQ,cf
d837 1
a837 1
                EXITS   EQ,cf
d871 1
a871 1
                EXITS   ,cf
d924 1
a924 1
                EXITS   ,cf
d954 1
a954 1
                EXITS   ,cf                                     ; exit, restoring original IRQ state
@


4.7.2.4
log
@  Merge of latest trunk version to the 32-bit branch.
Detail:
  Merged here for testing before committing this to the trunk
    as the master version.
Admin:
  Untested.

Version 0.60, 4.13.2.5. Tagged as 'Parallel-0_60-4_13_2_5'
@
text
@a28 6
;pp_EPP			* pp_base +12			; EPP mode available only
;pp_EPP_Data0		* pp_base +16
;pp_EPP_Data1		* pp_base +20
;pp_EPP_Data2		* pp_base +24
;pp_EPP_Data3		* pp_base +28

a36 3
;pp_stat_2		* 1:SHL:2	; hardwired low
;pp_stat_1		* 1:SHL:1	; hardwired low
pp_EPP_timeout		* 1:SHL:0	; set => >= 10 us timout occurred 	clear => no timeout
a37 2
;pp_ctrl_7		* 1:SHL:7	; hardwired low
;pp_ctrl_6		* 1:SHL:6	; hardwired low
a44 5
; these flags control the mode at which the parallel device should be driven, see the COMBO chip spec
; pg. 99 FDC37C669 specification.
pp_ecr_flag_FIFO	* 2_010:SHL:5	; use FIFO mode
pp_ecr_flag_default	* 2_001:SHL:5	; use default parallel mode

d55 1
a55 1
pp_ecr_default          * pp_ecr_flag_default :OR: pp_ecr_errintdis
a59 4
ioctl_reason_size	* 1
ioctl_reason_data	* 2
ioctl_reason_mask	* &FFFF
ioctl_group_parallel	* 1
a69 12
; this macro delays for 5us
		MACRO
$label		PulseDelay $v0

$label		ROUT
		LDR	$v0, LoopFactor		; get the processor speed
		MOV	$v0, $v0, LSR #3
10
		SUBS	$v0, $v0, #1
		BGT	%BT10
		MEND

d111 1
a111 1
                B       ioeb_ioctl                              ; ioctl
a851 57
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioeb_ioctl
;
; this implements the io control call as implemented in the serial device. At
; present this only implements calls used to get the DEVICE ID.
;
; dumps the contents b0 least significant byte
ioeb_ioctl
                ROUT
                ENTRY "r0, r5-r7"

                LDRB    r5, [r3, #2]
                LDR     r6, =ioctl_group_parallel       ; make sure we are in the right group
                CMP     r6, r5
                BNE     ioctl_error

                LDRB    r5, [r3, #3]
                CMP     r5, #1:SHL:7                    ; read flag must be set
                BEQ     ioctl_error

                LDR     r5, [r3]
                LDR     r0, =ioctl_reason_mask
                AND     r5, r5, r0                      ; the least significant word is the reason
                CMP     r5, #ioctl_reason_data
                BGT     ioctl_error

                MOVLT   r7, #2                          ; to read the size read only two bytes
                BLT     %FT10
                LDR     r7, [r3, #4]
                LDR     r5, [r3, #3]
                CMP     r5, #1:SHL:6;
                CMPEQ   r7, #2
                BLE     ioctl_error
10
                ADD     r6, r3, #6                      ; r6 is the address of the data

                BL      IEEE1284_negotiate
                BVS     ioctl_error_xlate

                LDRB    r5, [r3, #7]                    ; byte swap the size, zero the most significant two.
                LDRB    r4, [r3, #6]
                ORR     r5, r5, r4, LSL #8
                STR     r5, [r3, #4]

                EXIT
ioctl_error
                ADRL    r0, ErrorBlock_Parallel_BadParm ; this must be set
ioctl_error_xlate
                [ international
                BL      MakeError
                |
                SETV
                ]
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT

a957 176

; This method implements section 7.4 of the IEEE std 1284-1994 specification.
;
; reg usage;
; on entry r6 is the buffer to write to
; r7 is the size to read including the size.

IEEE1284_negotiate
                ROUT
                ENTRY "r0-r5"

                LDR     lr, =pp_ecr             ; make sure we are in compatability mode
                LDRB    r5, [lr]

                [  FastCentronics               ; if we are in fast mode get out of it and store
                TST     r5, #pp_ecr_flag_FIFO
                TSTNE   r5, #pp_ecr_empty
                ADRNEL  r0, ErrorBlock_Parallel_InUse
                STRNE   r0, [sp, #Proc_RegOffset]
                EXIT    NE
                ]

                MOV     r0, #pp_ecr_default     ; mode 001 as we may want to tri-state the data lines
                STRB    r0, [lr]                ; this sets the combo into compatability mode (turns FIFO off)

                LDR     r2, =pp_ctrl            ; r2 now always contains the address of the control byte
                MOV     r0, #pp_ctrl_default
                STRB    r0, [r2]                ; pull the strobe line up
                LDR     lr, =pp_data
                MOV     r3, #&04                ; request Device Id string using reverse nibble mode
                STRB    r3, [lr]                ; set the data to Extensibility Request Value
                ORR     r0, r0, #pp_ctrl_autofd
                BIC     r0, r0, #pp_ctrl_slctin
                STRB    r0, [r2]                ; set the stimulus event 1.

                LDR     r1, =pp_stat
                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10         ; 40 us * &400
10
                LDRB    r3, [r1]                ; negotiation phase
                TST     r3, #pp_stat_error
                TSTNE   r3, #pp_stat_pe
                BNE     %FT20                   ; IEEE 1284 compatabiility
                SUBS    r0, r0, #1
                BGT     %BT10
                MOV     r0, #0                  ; data read is zero.
                B       negotiate_tidy          ; 1284 failed
20
                LDRB    r3, [r2]                ; event 3 pull strobe down
                ORR     r3, r3, #pp_ctrl_strobe
                STRB    r3, [r2]

                PulseDelay r0                   ; delay for 5 us to ensure the peripheral sees it.

                BIC     r3, r3, #pp_ctrl_autofd :OR: pp_ctrl_strobe
                STRB    r3, [r2]                ; event 4 on map

                LDR     r0, LoopFactor          ; wait for peripheral response
                MOV     r0, r0, LSL #10
30
                LDRB    r3, [r1]
                TST     r3, #pp_stat_ack        ; wait for the ACK to come up.
                BNE     %FT40
                SUBS    r0, r0, #1
                BGT     %BT30
                B       negotiate_tidy
40
                ; read data from peripheral
                MOV     r4, #0                  ; set up the counts, avoiding the always blank first two bytes
50
                LDRB    r3, [r1]                ; main read loop
                TST     r3, #pp_stat_error      ; determine if there is data to read
                BNE     negotiate_tidy          ; no data left

                BL      reverse_nibble_read     ; read the byte

                BVS     negotiate_tidy

                STRB    r0, [r6, r4]            ; this stores the data at the buffer including the first two bytes

                ADD     r4, r4, #1
                CMP     r7, r4
                BGT     %BT50
negotiate_tidy
                LDR     lr, =pp_ecr             ; tidyup restore the ecr state to what it was.
                STRB    r5, [lr]
                LDR     r1, =pp_ctrl
                MOV     r5, #pp_ctrl_default
                STRB    r5, [r1]

                EXIT

; register usage
; r0 returns byte or error on error
; r1 status, byte address
; r2 control, byte address
reverse_nibble_read
                ROUT
                ENTRY   "r3-r5"

                LDRB    r3, [r2]
                ORR     r3, r3, #pp_ctrl_autofd                 ; pull the autofd line down
                STRB    r3, [r2]

                LDR     r4, LoopFactor                          ; maximum of 35 milliseconds peripheral response
                MOV     r4, r4, LSL #10                         ; 40 us * 1000 ~=(&400)
50
                LDRB    r3, [r1]
                TST     r3, #pp_stat_ack                        ; wait for data, ack low
                BEQ     %FT55
                SUBS    r4, r4, #1
                BGT     %BT50
                B       nibble_error
55
                LDRB    r4, [r1]                                ; read the first nibble from the status byte
                AND     r0, r4, #pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error ; find bits 2, 1 and 0 resp. masked as 5, 4 & 3
                MOV     r0, r0, LSR #3
                TST     r4, #pp_stat_notbusy                    ; see if bit seven is set
                ORREQ   r0, r0, #&08                            ; make that bit 3

                LDRB    r3, [r2]                                ; pull the autofd up again first nibble complete
                BIC     r3, r3, #pp_ctrl_autofd
                STRB    r3, [r2]

                LDR     r4, LoopFactor                          ; wait for ack to come back up again
                MOV     r4, r4, LSL #10
65
                LDRB    r3, [r1]
                TST     r3, #pp_stat_ack                        ; wait for data
                BNE     %FT70
                SUBS    r4, r4, #1
                BGT     %BT65
                B       nibble_error
70
                LDRB    r3, [r2]                                ; ready to read the second nibble, similar cycle as above
                ORR     r3, r3, #pp_ctrl_autofd                 ; pull the autofd line down
                STRB    r3, [r2]

                LDRB    r3, [r2]

                LDR     r4, LoopFactor
                MOV     r4, r4, LSL #10
75
                LDRB    r3, [r1]
                TST     r3, #pp_stat_ack                        ; wait for the lowering of the ack
                BEQ     %FT80
                SUBS    r4, r4, #1
                BGT     %BT75
                B       nibble_error
80
                LDRB    r4, [r1]
                TST     r4, #pp_stat_notbusy                    ; see if bit seven is set
                ORREQ   r0, r0, #&80
                AND     r3, r4, #pp_stat_pe :OR: pp_stat_slct :OR: pp_stat_error ; find bits 2, 1 & 0, masked as 5 , 4 & 3
                ORR     r0, r0, r3, LSL #1                      ; set the top nibble

                LDRB    r3, [r2]
                BIC     r3, r3, #pp_ctrl_autofd
                STRB    r3, [r2]

                LDR     r4, LoopFactor
                MOV     r4, r4, LSL #10
85
                LDRB    r3, [r1]
                TST     r3, #pp_stat_ack                        ; wait for the raising of the ack
                BNE     %FT90
                SUBS    r4, r4, #1
                BGT     %BT85
                B       nibble_error
90
                EXIT
nibble_error
                ADRL    r0, ErrorBlock_Parallel_BadHardware     ; timeout
                SETV
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT
@


4.6
log
@Added support for "version 2" parallel: if ReadSysInfo 3 says parallel type 2,
then it behaves as before, but claims device 2 rather than 0, as the
interface is on a different interrupt pin.

Version 0.59. Tagged as 'Parallel-0_59'
@
text
@d65 3
a67 7
$label          LDR     $v0, HardwareType
                TEQ     $v0, #hardware_IOMD
                LDRNE   $v0, =PINTR_Latch               ; Must be IOEB so use external latch.
                LDRNEB  $v0, [$v0]
                MOVEQ   $v0, #pbusy_bit                 ; IOMD so use clearing bit in IRQCLRA works.
                MOVEQ   $v1, #IOC
                STREQB  $v0, [$v1, #IOCIRQCLRA]
d171 1
a171 4
                LDRB    r0, Flags
                TST     r0, #f_DifferentDevice  ;Historical device, or the new "improved" one.
                MOVEQ   r0, #IOEB_PrinterIRQ_DevNo
                MOVNE   r0, #IOMDr_PrinterIRQ_DevNo
d199 1
a199 4
                LDRB    r0, Flags
                TST     r0, #f_DifferentDevice  ;Historical device, or the new "improved" one.
                MOVEQ   r0, #IOEB_PrinterIRQ_DevNo
                MOVNE   r0, #IOMDr_PrinterIRQ_DevNo
d260 3
a265 1
                MOV     r0, #IOC
d267 1
a267 1
                ORR     r1, r1, #pbusy_bit      ; enable device interrupts
d628 1
a628 1
ioeb_busy       ENTRY   "r0"
d635 2
d642 1
a642 1
                ORR     r0, r0, #pbusy_bit
d767 2
d774 2
a775 2
                ORRCC   tmp, tmp, #pbusy_bit                    ; re-enable printer interrupts
                BICCS   tmp, tmp, #pbusy_bit
d873 2
d880 2
a881 2
                BICCS   tmp, tmp, #pbusy_bit            ; if buffer is full, disable device interrupts
                ORRCC   tmp, tmp, #pbusy_bit            ; else ensure they are enabled
@


4.5
log
@Changed to use srccommit.
Spinner branch merged.
Inclusion of Hdr:CMOS removed.

Version 0.51. Tagged as 'Parallel-0_51'
@
text
@d175 4
a178 1
                MOV     r0, #IOEB_PrinterIRQ_DevNo
d206 4
a209 1
                MOV     r0, #IOEB_PrinterIRQ_DevNo
d348 1
a348 1
	
d355 1
a355 1
		MOVNE		r1, #pp_stat_pe	
d363 1
a363 1
		
d365 1
a365 1
		
d367 1
a367 1
		
d371 2
a372 2
	
test_Set_loop	
d379 1
a379 1
		LDRB	r0, [r3]				; read status register byte		
d385 1
a385 1
                Pull	"r2,r3 ,pc"	
d388 2
a389 2
	
test_NSet_loop	
d396 1
a396 1
		LDRB	r0, [r3]				; read status register byte		
d455 1
a455 1
		BNE		not_cancel	;if this falls through it does not call exit with message	 
d461 1
a461 1
		
d542 1
a542 1
		
d554 1
a554 1
				
d558 1
a558 1
		
d566 1
a566 1
		
@


4.4
log
@Spinner branch merged
@
text
@d292 2
d336 4
a339 2
		LDR 		r1, =pp_stat
		LDRB		r0, [r1]		; read status register byte
d341 6
a346 2
		TST		r0, #pp_stat_error	; pp_stat_error clear for any of pe, offline, other error
		MOVNES		pc, lr			; All o k
d348 3
a350 4
		;We've got an error, so what type is it?
		Debug		j, "some sort of error"
		ENTRY		"r1-r9"			; OS_UpCall needs up to r6, but we can corrupt up to r2
		TST		r0, #pp_stat_pe		; out of paper?
d353 44
a396 3
		TST		r0, #pp_stat_slct	; off-line?
		BEQ		off_line
		B		not_working
d398 1
d434 1
d449 1
a449 1
		BNE		not_cancel
d451 3
a453 6
cancel
		Debug		j, "user cancelled operation"
		MOV		r0, #UpCall_MediaSearchEnd
		Debug		j, "OS_UpCall called", r0
		SWI		XOS_UpCall
		Debug		j, "OS_UpCall returned", r0
d455 1
a455 1

d458 3
a460 6
		LDR 		r1, =pp_stat
		LDRB		r0, [r1]		; read status register byte

		TST		r0, #pp_stat_error	; pp_stat_error clear for any of pe, offline, other error
		ADRNEL		r0, ErrorBlock_Parallel_OtherError
		BNE		make_error		; doesn't seem to be an error any more!
d481 15
a495 1
not_cancel	TEQ		r0, #0
d502 2
a503 2
		LDR 		r1, =pp_stat
		LDRB		r0, [r1]		; read status register byte
d505 5
a509 1
		BNE		media_loaded		; All o k
d512 1
a512 1
		TST		r0, #pp_stat_pe
d525 4
d530 25
a554 3
media_loaded
		Debug		j, "media now present"
		MOV		r0, #UpCall_MediaSearchEnd
d560 1
a560 1
		]
d686 1
a686 3
		LDR	r0, LoopFactor				; Get CPU speed rating
                MOV     r2, r0, LSR #2                          ; loop until PACK is high
								; loop set from loop factor / 4
d699 1
a699 3
		LDR	r0, LoopFactor				; Get CPU speed rating
		MOV	r2, r0, LSR #2				; Scale rating to our needs

@


4.4.2.1
log
@Parallel device driver modified for Phoebe hardware
NOT backwards compatible.
@
text
@a20 1
LoopFactor_Value    *  40:SHL:2   ;This is the loopfactor used in the above cases on Phoebe.
a60 5
; Define IOMD2 specific addresses etc
iomd2_pbusy_bit		* 1:SHL:11
IOMD2_INTREQ		* &314
IOMD2_INTENBL		* &318

a61 9
 [ IOMD2IRQs
                MACRO
$label          ClearPINTR $v0,$v1

$label          MOV     $v0, #iomd2_pbusy_bit                 ; IOMD so use clearing bit in IRQCLRA works.
                MOV     $v1, #IOC
                STR     $v0, [$v1, #IOMD2_INTREQ]
                MEND
 |
a72 1
 ]
a266 6
 [ IOMD2IRQs
                MOV     r0, #IOC
                LDR     r1, [r0, #IOMD2_INTENBL]
                ORR     r1, r1, #iomd2_pbusy_bit      ; enable device interrupts
                STR     r1, [r0, #IOMD2_INTENBL]
 |
d271 1
a271 1
 ]
a552 6
 [ IOMD2IRQs
                LDR     r0, [r3, #IOMD2_INTENBL]
                ORR     r0, r0, #iomd2_pbusy_bit
                STR     r0, [r3, #IOMD2_INTENBL]
 		
 |
d556 1
a556 1
 ]
d686 1
a686 6
 [ IOMD2IRQs
                LDR     tmp, [r3, #IOMD2_INTENBL]
                ORRCC   tmp, tmp, #iomd2_pbusy_bit                    ; re-enable printer interrupts
                BICCS   tmp, tmp, #iomd2_pbusy_bit
                STR     tmp, [r3, #IOMD2_INTENBL]
 |
d691 1
a691 1
 ]
a790 6
 [ IOMD2IRQs
 		LDR	tmp, [r3, #IOMD2_INTENBL]
 		BICCS	tmp, tmp, #iomd2_pbusy_bit
 		ORRCC	tmp, tmp, #iomd2_pbusy_bit
 		STR	tmp, [r3, #IOMD2_INTENBL]
 |
d795 1
a795 1
 ]
@


4.3
log
@ARTtmp branch folded
@
text
@d100 3
a102 3
                MOVS    pc, lr
                MOVS    pc, lr
                MOVS    pc, lr
d105 1
a105 1
                MOVS    pc, lr
d107 1
a107 1
                MOVS    pc, lr
d109 3
d276 11
d288 185
a472 1

d576 14
a589 1
;
d598 1
a598 3
		Push	"lr"
		BL	common_get_loop_factor			; Get CPU speed rating
		Pull	"lr"
d613 2
a614 4
		Push	"lr"
		BL	common_get_loop_factor			; Get CPU speed rating
		Pull	"lr"
		MOV	R2, R0, LSR #2				; Scale rating to our needs
d718 4
a955 2
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

a956 1

@


4.2
log
@Version RO_3_71 merged
@
text
@d387 5
a391 1
                MOV     r2, #TimeoutPACKhigh                    ; loop until PACK is high (time out after >= n*0.5µs)
d404 5
a408 1
                MOV     r2, #TimeoutBusyAfterAck                ; loop 20 times (at least n*0.5µs)
d543 1
a543 1
ioeb_irqread    ENTRY   "r0-r2"
@


4.1
log
@Initial revision
@
text
@d17 5
d387 1
a387 1
                MOV     r2, #40                                 ; loop until PACK is high (time out after >=20µs)
d400 1
a400 1
                MOV     r2, #20                                 ; loop 20 times (at least 20*0.5µs)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Fix for busy after ack bug.
@
text
@d382 1
a382 5
		Push	"lr"
		BL	common_get_loop_factor			; Get CPU speed rating
		Pull	"lr"
                MOV     r2, r0, LSR #2                          ; loop until PACK is high
								; loop set from loop factor / 4
d395 1
a395 5
		Push	"lr"
		BL	common_get_loop_factor			; Get CPU speed rating
		Pull	"lr"
		MOV	R2, R0, LSR #2				; Scale rating to our needs

@


4.1.7.3
log
@   Calculate loop factor in init code; added Paper, OnLine, Printer message tokens;
make appropriate upcalls in ioeb_monitorTX when paper out etc; use
ParallelDeviceDriver$Path for resources; added 'j' debug flag.
@
text
@d95 3
a97 3
                MOVS    pc, lr					; wakeup RX
                MOVS    pc, lr					; sleep RX
                MOVS    pc, lr					; enum dir
d100 1
a100 1
                MOVS    pc, lr					; halt
d102 1
a102 1
                MOVS    pc, lr					; end of data
a103 3
		B	ioeb_monitorTX				; check sending is okay
		MOVS	pc, lr					; monitor rx
		MOVS	pc, lr					; ioctl
a267 11
;
; call: ioeb_monitorTX
;
; in:	r0  = reason code (12)
; 	r1  =
;       r2  = internal handle
;
; out:  r0-r2 corrupted
;
; This routine is called by DeviceFS to check the device if the TX buffer is
; almost full. It can therefore be used to report printer error conditions
d269 1
a269 185
;Message tokens
paper		=		"Paper", 0
online		=		"OnLine", 0
printer		=		"Printer", 0
		ALIGN

		[		false

; First, a version that just returns any printer error straight back to the caller (for testing).

ioeb_monitorTX	ROUT
		LDR 		r1, =pp_stat
		LDRB		r0, [r1]		; read status register byte

		TST		r0, #pp_stat_error	; pp_stat_error clear for any of pe, offline, other error
		MOVNES		pc, lr			; All o k

		;We've got an error, so what type is it?
		Debug		j, "some sort of error"
		TST		r0, #pp_stat_pe		; out of paper?
		BNE		paper_out

		TST		r0, #pp_stat_slct	; off-line?
		BEQ		off_line
		B		not_working

paper_out	ADRL		r0, ErrorBlock_Parallel_PaperOut
		B		make_error

off_line	ADRL		r0, ErrorBlock_Parallel_Offline
		B		make_error

not_working	ADRL		r0, ErrorBlock_Parallel_OtherError
		;fall through

make_error
		[		international
		B		MakeError
		|
		ORRS		pc, lr, #V_bit
		]
		|

; Now the real code: make an upcall on printer error, resuming if it's handled properly.

ioeb_monitorTX	ROUT
		LDR 		r1, =pp_stat
		LDRB		r0, [r1]		; read status register byte

		TST		r0, #pp_stat_error	; pp_stat_error clear for any of pe, offline, other error
		MOVNES		pc, lr			; All o k

		;We've got an error, so what type is it?
		Debug		j, "some sort of error"
		ENTRY		"r1-r9"			; OS_UpCall needs up to r6, but we can corrupt up to r2
		TST		r0, #pp_stat_pe		; out of paper?
		BNE		paper_out

		TST		r0, #pp_stat_slct	; off-line?
		BEQ		off_line
		B		not_working

paper_out
		Debug		j, "paper out"
		MOV		r4, #0			;iteration count
		ADR		r6, paper
		B		do_lookup_and_upcall

off_line
		Debug		j, "printer not connected"
		MOV		r4, #0			;iteration count
		ADRL		r6, online
		B		do_lookup_and_upcall

not_working
		Debug		j, "printer not working"
		MOV		r4, #0			;iteration count
		ADRL		r6, printer
		;fall through

do_lookup_and_upcall
		;Convert token in r6 to message in r6
		BL		OpenMessages
		ADDVS		r6, r0, #4
		BVS		do_upcall		;if it went wrong, use the error as the message

		ADRL		r0, MessagesWorkspace
		MOV		r1, r6
		ADRL		r2, localerrorblock
		MOV		r3, #?localerrorblock
		SWI		XMessageTrans_Lookup
		MOVVC		r6, r2
		ADDVS		r6, r0, #4		;if it went wrong, use the error as the message

		BL		CloseMessages

do_upcall	;Make the upcall
		MOV		r0, #UpCall_MediaNotPresent
		MOV		r1, #fsnumber_DeviceFS
		MOV		r2, #-1			;message in r6 (not media type)
		MOV		r3, #-1			;device number irrelevant
		;r4 cleared first time, incremented subsequently
		MOV		r5, #&7FFFFFFF		;timeout (very big)
		;r6 set up depending on reason for upcall

		Debug		j, "OS_UpCall called", r0
		SWI		XOS_UpCall
		Debug		j, "OS_UpCall returned", r0
		EXIT		VS

		CMP		r0, #-1
		BNE		not_cancel

cancel
		Debug		j, "user cancelled operation"
		MOV		r0, #UpCall_MediaSearchEnd
		Debug		j, "OS_UpCall called", r0
		SWI		XOS_UpCall
		Debug		j, "OS_UpCall returned", r0
		EXIT		VS

		;Try to report the error state as it is now, but make sure that some error
		;is reported even if all conditions have been (coincidentally) cleared.
		LDR 		r1, =pp_stat
		LDRB		r0, [r1]		; read status register byte

		TST		r0, #pp_stat_error	; pp_stat_error clear for any of pe, offline, other error
		ADRNEL		r0, ErrorBlock_Parallel_OtherError
		BNE		make_error		; doesn't seem to be an error any more!

		; now we've got an error, so what type is it?
		TST		r0, #pp_stat_pe		; paper out?
		ADRNEL		r0, ErrorBlock_Parallel_PaperOut
		BNE		make_error

		TST		r0, #pp_stat_slct	; off-line?
		ADREQL		r0, ErrorBlock_Parallel_Offline
		ADRNEL		r0, ErrorBlock_Parallel_OtherError
		;fall through

make_error
		;r0 -> error block
		PullEnv
		[		international
		B		MakeError
		|
		ORRS		pc, lr, #V_bit
		]

not_cancel	TEQ		r0, #0
		DebugIf		NE, j, "never happens (intercepted vector should always have r0 == 0 or -1)", r0
		EXITS		NE

confirm
		Debug		j, "user said it's ok now"
		;checking that there is really media there now
		LDR 		r1, =pp_stat
		LDRB		r0, [r1]		; read status register byte
		TST		r0, #pp_stat_error	; pp_stat_error clear for any of pe, offline, other error
		BNE		media_loaded		; All o k

		;Still got an error, so what type is it now?
		TST		r0, #pp_stat_pe
		ADRNEL		r6, paper		; paper out
		BNE		media_missing

		TST		r0, #pp_stat_slct
		ADREQL		r6, online		; off-line
		ADRNEL		r6, printer		; miscellaneous
		;fall through

media_missing
		Debug		j, "media still missing", r4
		ADD		r4, r4, #1		;increment iteration count
		B		do_lookup_and_upcall	;make upcall again

media_loaded
		Debug		j, "media now present"
		MOV		r0, #UpCall_MediaSearchEnd
		Debug		j, "OS_UpCall called", r0
		SWI		XOS_UpCall
		Debug		j, "OS_UpCall returned", r0
		EXIT		VS
		EXITS
		]
d373 1
a373 14

;Entry
;	IRQ mode, interrupts off
;	r3 -> base of IOC memory space
;	r12 -> workspace
;	Not currently threaded (non-reentrant)
;Exit
;	Interrupt serviced
;	r0--r3, r12 corrupted
;Notes
;	Execution time <= 100µs
;	SWI's called by method on P R M p1-127 (X SWI's only)
;	Error stored---somewhere???
;	Calls re-entrant SWI's only
d382 3
a384 1
		LDR	r0, LoopFactor				; Get CPU speed rating
d399 4
a402 2
		LDR	r0, LoopFactor				; Get CPU speed rating
		MOV	r2, r0, LSR #2				; Scale rating to our needs
a505 4
		[	FastBufferMan				; but not if we're using FastBufferMan JRC 14-Apr-1997
                LDRB    r0, [lr]
                LDRB    r0, [lr]
		]
d740 2
d743 1
@


4.1.7.4
log
@   Make timeout much bigger.
@
text
@d593 3
a595 1
		LDR	r2, LoopFactor				; Get CPU speed rating and loop until PACK is high
d608 3
a610 1
		LDR	r2, LoopFactor				; Get CPU speed rating
@


4.1.7.5
log
@added a call to upcall with message to overwrite dialogue boxes that wimp
redraw cannot cover as it is not polled while printing is carried out,
Alistair
@
text
@a286 2
continue	=		"Continue",0
cancel		=		"Cancel",0
a379 1

d394 1
a394 1
		BNE		not_cancel	;if this falls through it does not call exit with message	 
d396 6
a401 3
		Debug		j, "SHOULD EXIT WITH MESSAGE"
		ADRL		r6, cancel		;move the specific error "continue"
		BL		exit_with_message	; send exit message then exit
d403 1
a403 1
		
a405 1
set_errorblock
d442 1
a442 5
		BEQ		stillerr
		ADRL		r6, continue		;move the specific error "continue"
		BL		exit_with_message	; All o k
		EXIT		VS			;This is the actual correct exit of this routine
		EXITS
d445 1
a445 1
stillerr	TST		r0, #pp_stat_pe
a457 25
		EXIT		VS
		EXITS
		
		]

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

exit_with_message

		ENTRY 		"R1-R6"
		Debug		j, "exit with message"
		
		BL		OpenMessages
		ADDVS		r6, r0, #4
		BVS		send_exit		;if it went wrong, use the error as the message

		ADRL		r0, MessagesWorkspace
		MOV		r1, r6
		ADRL		r2, localerrorblock
		MOV		r3, #?localerrorblock
		SWI		XMessageTrans_Lookup
		MOVVC		r6, r2
		ADDVS		r6, r0, #4
				
		BL		CloseMessages
d459 3
a461 4
send_exit	; call the end media search call
		
		MOV		R1, R6
		MOV		r0, #UpCall_MediaSearchEndMessage
d467 1
a467 1
		
@


4.1.7.6
log
@Changed monitor TX so that it does not use pp_stat_error (nFault) as the
overriding indication of an error condition so that HP printers can report
out of paper errors. This is tempered by the condition that pp_stat_notbusy
must be clear (indicating busy).

Changed strategy for continue on errors such that the continuing to print
message is displayed and control is returned to the higher levels (rather
than rechecking the pp_stat bits). This should be cleaner and provides
better user feedback.
@
text
@d331 2
a332 2
		LDR 		r0, =pp_stat
		LDRB		r0, [r0]		; read status register byte
d334 2
a335 4
		TST		r0, #pp_stat_notbusy	; printer should be busy on error
		MOVNES		pc, lr

		ENTRY		"r1-r9"			; OS_UpCall needs up to r6, but we can corrupt up to r2
d339 1
a339 1

d345 1
a345 5

		TST		r0, #pp_stat_error	; pp_stat_error clear for any other error
		BEQ		not_working

		EXIT
d400 1
a400 1
		ADRL		r6, cancel		;move the specific error "cancel"
d407 6
a412 2
		LDR 		r0, =pp_stat
		LDRB		r0, [r0]		; read status register byte
d433 1
a433 15
not_cancel
		[ {TRUE}

		; New strategy. Just exit with continuing message and let the higher levels
		; raise the error again if necessary. This should be cleaner and provides
		; more feedback to the user.

		ADRL		r6, continue		;move the specific error "continue"
		BL		exit_with_message	; All o k
		EXIT		VS			;This is the actual correct exit of this routine
		EXITS

		|

		TEQ		r0, #0
d440 2
a441 2
		LDR 		r0, =pp_stat
		LDRB		r0, [r0]		; read status register byte
d465 1
a465 1
		]
@


4.1.7.7
log
@Reordered test for paper out and off-line so that the off-line error is
generated when there is no printer connected.
@
text
@d342 3
a346 3

		TST		r0, #pp_stat_pe		; out of paper?
		BNE		paper_out
@


4.1.7.8
log
@Changed the way it perceived errors to check for a consistant error.
@
text
@d334 3
d339 4
a342 5
	; This tests for an error if it is detected looks at it for a test period to ensure it is stable
	
		TST		R0, #pp_stat_slct
		MOVEQ		r1, #pp_stat_slct	; off-line?  set = online
		BLEQ		test_NSet_loop		; if it is offline check that this is stable not noise
d345 1
a345 3
		TST		r0, #pp_stat_pe		; out of paper? set = no paper
		MOVNE		r1, #pp_stat_pe	
		BLNE		test_Set_loop		; check that it stays set for 1 micro sec.
a348 2
		MOVEQ		r1, #pp_stat_error	; set = no error
		BLEQ		test_NSet_loop		; if it is an error check that this is stable not noise
d350 1
a350 1
		
a351 38
		
;+++++++++++++++++++++++++++++++++++++++++++++ test stable errors Start
		
	; ADD a wait loop and check that the error is stable
	; r0 ppstat, r1 is the error
	; r3 is the address of the ppstat this needs to be read on each loop
	
test_Set_loop	
		Push 	"r2,r3,lr"

		LDR 	r3, =pp_stat
		LDR	r2, LoopFactor				; Get CPU speed rating
		MOV	r2, r2, LSR #2
20
		LDRB	r0, [r3]				; read status register byte		
		TST	R0,R1
		BEQ	%FT25					; test to see if the ppstat clears
                SUBS    r2, r2, #1
                BNE     %BT20					; this leaves the loop on EQ
		MOVS	R1, R1		;Set the NE condition,		stable error
                Pull	"r2,r3 ,pc"	
25
		Pull	"r2,r3 ,pc"	;EQ condition is set	Not a stable error
	
test_NSet_loop	
		Push 	"r2,r3,lr"

		LDR 	r3, =pp_stat
		LDR	r2, LoopFactor				; Get CPU speed rating
		MOV	r2, r2, LSR #2
20
		LDRB	r0, [r3]				; read status register byte		
		TST	R0,R1
		BNE	%FT25					; this sets the condition to NE
                SUBS    r2, r2, #1
                BNE     %BT20					; this sets the returning condition to EQ
25								; this is the error condition
                Pull	"r2,r3,pc"
a352 1
;+++++++++++++++++++++++++++++++++++++++++++++ test stable errors END
@


4.1.7.2.2.1
log
@Fixed bug where device driver halt and resume routines were corrupting R3
@
text
@d538 1
a538 1
ioeb_irqread    ENTRY   "r0-r3"
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.3.2
log
@Version RO_3_71 taken
@
text
@a16 5
;time delay multipliers (times approx 0.5 us) for handshaking timeouts
;
TimeoutPACKhigh     *  40   ;40
TimeoutBusyAfterAck *  40   ;20

d382 1
a382 1
                MOV     r2, #TimeoutPACKhigh                    ; loop until PACK is high (time out after >= n*0.5µs)
d395 1
a395 1
                MOV     r2, #TimeoutBusyAfterAck                ; loop 20 times (at least n*0.5µs)
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@a16 5
;time delay multipliers (times approx 0.5 us) for handshaking timeouts
;
TimeoutPACKhigh     *  40   ;40
TimeoutBusyAfterAck *  40   ;20

d382 1
a382 1
                MOV     r2, #TimeoutPACKhigh                    ; loop until PACK is high (time out after >= n*0.5µs)
d395 1
a395 1
                MOV     r2, #TimeoutBusyAfterAck                ; loop 20 times (at least n*0.5µs)
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.12;
access;
symbols
	Parallel-0_79:4.12
	Parallel-0_78:4.11
	Parallel-0_77:4.11
	Parallel-0_76:4.10
	Parallel-0_75:4.9
	Parallel-0_74:4.9
	Parallel-0_73:4.8
	Parallel-0_72:4.8
	Parallel-0_71:4.8
	Parallel-0_70:4.8
	Parallel-0_69:4.8
	Parallel-0_68:4.8
	Parallel-0_67:4.7
	Parallel-0_66:4.7
	Parallel-0_65:4.6
	kbracey_32bit_merge:4.4.2.3
	Parallel-0_64:4.6
	Parallel-0_60-4_13_2_5:4.4.2.3
	Parallel-0_60-4_13_2_4:4.4.2.2
	Parallel-0_60-4_13_2_3:4.4.2.1
	Parallel-0_63:4.5
	Parallel-0_60-4_13_2_2:4.4.2.1
	Alpnet_approved:4.4
	Parallel-0_62:4.4
	dellis_autobuild_BaseSW:4.4
	Parallel-0_61:4.4
	Parallel-0_60-4_13_2_1:4.4.2.1
	kbracey_32bit:4.4.0.2
	sbrodie_sedwards_16Mar2000:4.4
	Parallel-0_60:4.4
	Parallel-0_59:4.4
	dcotton_autobuild_BaseSW:4.8
	Parallel-0_58:4.4
	Parallel-0_57:4.4
	Parallel-0_56:4.4
	Parallel-0_55:4.4
	Parallel-0_54:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.6
	Parallel-0_53:4.4
	Parallel-0_52:4.4
	Parallel-0_51:4.4
	FunaiNC2_Parallel-0_50:4.1.7.4
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	wturner_parallel-0_47:4.3.2.1
	wturner_parallel-0_46:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	rthornb_UrsulaBuild_01May1998:4.3
	afrost_NC2_Generic:4.1.7.4
	afrost_Funai01-33:4.1.7.4
	Spinner_RCA116:4.1.7.4
	Spinner_B20_2:4.1.7.4
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.4
	Spinner_B17:4.1.7.4
	Spinner_B15:4.1.7.4
	Spinner_B14:4.1.7.4
	Spinner_B13:4.1.7.4
	Spinner_B12:4.1.7.4
	Spinner_B10:4.1.7.3
	Daytona:4.3.0.4
	Ursula:4.3.0.2
	Spin_merge_16May97:4.1.7.2
	Daytona_bp:4.3
	Ursula_bp:4.3
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.2
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.4
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.12
date	2015.06.06.08.25.10;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	5y9PwYodGrF5tloy;

4.11
date	2012.12.20.08.36.04;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	9ssBEbFq3jtroWww;

4.10
date	2012.06.23.16.24.15;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	NqgW20IuiIZMLQ9w;

4.9
date	2011.06.22.00.52.49;	author jlee;	state Exp;
branches;
next	4.8;
commitid	G7LnLvkSoQ9EpBov;

4.8
date	2001.08.03.14.53.50;	author mboura;	state Exp;
branches;
next	4.7;

4.7
date	2001.03.16.15.59.13;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2001.01.09.14.10.03;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.11.01.13.59.40;	author arodger;	state Exp;
branches;
next	4.4;

4.4
date	98.10.19.16.10.28;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	97.05.16.11.14.50;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.05.07.12.02.41;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.36.26;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	2000.07.23.20.43.04;	author sbrodie;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2000.11.29.12.41.40;	author sbrodie;	state Exp;
branches;
next	4.4.2.3;

4.4.2.3
date	2001.01.09.11.39.29;	author sbrodie;	state Exp;
branches;
next	;

4.3.2.1
date	98.08.18.15.12.01;	author wturner;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.36.26;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.30.18;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.54.48;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.49.31;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.20.13.33.46;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.30.18.18.57;	author scormie;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.05.27.12.46.49;	author jcoxhead;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Remove workaround for DeviceFS bug
Fixed properly in DeviceFS-0_72.

Version 0.79. Tagged as 'Parallel-0_79'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Common

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: common_open
;
; in:   r0  = device interrupt number to claim
;       r1  = address of device interrupt handler
;       r2  = external handle (used for calling DeviceFS)
;       r3  = flags for opening the file
;       r6 -> special field that has been decoded
;
; out:  r1  = internal handle (used in communication from DeviceFS)
;
; This call is made to allow the parallel device driver to initialise itself, ie.
; claiming any vectors it may need.
;



common_open
                EntryS  "r2-r4"

                Debug   open,"common_open, DeviceFS handle = ",r2

                LDRB    r4, Flags
                TST     r4, #f_OpenForRead :OR: f_OpenForWrite
                ADRNEL   r0, ErrorBlock_Parallel_InUse
                PullEnv NE

              [ international
                BNE     MakeErrorWithDeviceName
              |
                RETURNVS NE
              ]

                STR     r2, StreamHandle                        ; stash the stream handle

                TST     r4, #f_VectorOwned                      ; do I own the vectors?
                BNE     %FT00

                MOV     r2, wp                                  ; -> code and workspace
                SWI     XOS_ClaimDeviceVector
                EXIT    VS                                      ; return any error from ClaimDeviceVector

                ORR     r4, r4, #f_VectorOwned
00
                TST     r3, #&01
                ORREQ   r4, r4, #f_OpenForRead
                ORRNE   r4, r4, #f_OpenForWrite
                STRB    r4, Flags                               ; update to indicate that the vectors are owned

                EXITS



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: common_close
;
; in:   r0  = device interrupt number to release
;       r1  = address of device interrupt handler
;       r2  = address of busy check callback handler (or 0)
;
; out:  -
;
; This call is made to allow the device to close down the routines associated
; with printing characters.
;

common_close
                EntryS  "r2,r3,r8"

                Debug   close,"common_close"

                SETPSR  I_bit,lr,,r8                            ; disable IRQs

                TEQ     r2, #0
                LDRNEB  r3, IRQFlags
                TSTNE   r3, #if_PendingCallAfter
                BEQ     %05

                Push    "r0, r1"
                MOV     r0, r2
                MOV     r1, wp
                SWI     XOS_RemoveTickerEvent
                Pull    "r0, r1"

                BIC     r3, r3, #if_PendingCallAfter
                STRB    r3, IRQFlags

05
                LDRB    r3, Flags
                TST     r3, #f_VectorOwned                      ; is the vector owned at the moment
                BEQ     %10

                Debug   close," removing IRQ routine..."

                MOV     r2, wp                                  ; -> routines
                SWI     XOS_ReleaseDeviceVector
                BVS     %FT15

                BIC     r3, r3, #f_VectorOwned                  ; mark as vector no longer owned

                Debug   close," removed"
10
                BIC     r3, r3, #f_OpenForRead :OR: f_OpenForWrite
                STRB    r3, Flags

                MOV     r3, #0
                STR     r3, StreamHandle                        ; clear the output handle
                STR     r3, BufferHandle                        ; and buffer handle

                Debug   close,"finished closing stream"

                EXITS   ,cf                                     ; exit restoring all flags (including I)

15
                ORR     r8, r8, #V_bit
                RestPSR r8,,cf                                  ; ensure I bit is restored and V is set
                EXIT                                            ; return any error from ReleaseDeviceVector


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: common_createTX
;
; in:   r0 = reason code (6)
;       r2 = internal stream handle
;       r3 = flags for buffer
;       r4 = size for buffer
;       r5 = buffer handle (usually -1)
;       r6 = threshold for buffer
;
; out:  above registers modified
;
; This routine is called just before the output stream is created.
;

common_createTX
                Debug   open,"common_createTX"

                CMP     r5, #-1
                MOVEQ   r5, #Buff_Print         ; set the buffer handle
                MOV     pc, lr



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: common_createRX
;
; in:   r0 = reason code (7)
;       r2 = internal stream handle
;       r3 = flags for buffer
;       r4 = size for buffer
;       r5 = buffer handle (usually -1)
;       r6 = threshold for buffer
;
; out:  above registers modified
;
; This entry point is called just before the input stream buffer is going to
; be created.  The flags are modified so that the Halt and Resume entry points
; are called and the threshold is set.
;

common_createRX EntryS  "r0-r2"

                Debug   open,"common_createRX"

                ORR     r3, r3, #BufferFlags_SendThresholdUpCalls ; change flags for parallel buffer

                CMP     r5, #-1
                MOVEQ   r5, #Buff_Print         ; use parallel buffer
                MOV     r6, #Parallel_Threshold

                EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: common_get_loop_factor
;
; in:   -
;
; out:  r0 = looping factor
;
; This call is made to find a looping factor. This is a measurement of how
; fast the processor is.

ncpuloops * 2048        ; loop this many times

common_get_loop_factor ROUT

                Entry   "r0-r3,r8"

                ; We load Timer0 with &7FFE, and set it going. Then we go into
                ; a tight loop for ncpuloops times. Then we reread the timer
                ; and see how much it has gone down
                ; We then return 16384 (&4000) divided by this number so that we
                ; return numbers which are higher when the processor is faster

                Debug   open,"common_get_loop_factor"

                ; This whole code sequence is naughty and should really use
                ; the HAL timer API. For now, just poke the timer directly.
                MOV     r0, #9
                MOV     r1, #4:SHL:8            ; Address of SSpace (IOMD)
                SWI     XOS_Memory
                MOVVS   r3, #IOC                ; Address of the IO controller pre-HAL era
                MOVVC   r3, r1

                LDR     R1, =&7FFE              ; 32K @@@@ 2MHz = ~16ms limit

                SETPSR  I_bit,lr,,r8            ; disable IRQs

                MOV     r0, r1, LSR #8
                STRB    r1, [r3, #Timer1LL]
                STRB    r0, [r3, #Timer1LH]
                LDR     r0, =ncpuloops
                STRB    r0, [r3, #Timer1GO]     ; start the timer NOW
                B       %FT25                   ; Looks superfluous, but is required
                                                ; to get ncpuloops pipeline breaks
25
                SUBS    r0, r0, #1              ; 1S
                BNE     %BT25                   ; 1N + 2S

                STRB    r0, [r3, #Timer1LR]     ; latch count NOW
                LDRB    r2, [r3, #Timer1CL]
                LDRB    r0, [r3, #Timer1CH]
                ADD     r2, r2, r0, LSL #8      ; count after looping is ...

                SUB     r2, r1, r2              ; decrements !, &7FFE - current time = time it takes to do loops

                MOV     R1, #10*&4000           ; Instead of dividing by 4 (done at site of use), multiply
                                                ; by 10 (here). The only requirement for this number is that
                                                ; it is big enough to avoid the callback code being called
                                                ; in normal use. JRC 27 May 1997
                DivRem  R0, R1, R2, R3          ; R0 := 16384 DIV R2 (R3 is temp)

                STR     r0, LoopFactor          ; save for next time

                RestPSR r8,,cf                  ; restore flags and reenable IRQ's
                NOP

                EXIT                            
        [ AdvancedErrorHandling

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: common_check_upcall
;
; in:   r0 = UpCall reason code
;            other registers depend on the reason code in r0
;       r12 = our workspace pointer
;
; out:  -
;
; This call checks whether the UpCall we just received is UpCall_StreamCreated,
; and if so, whether the DeviceFS handle corresponds to the one we are currently
; using. If so, we can obtain the FileSwitch handle for our stream!
;
common_check_upcall
                TEQ     r0, #UpCall_StreamCreated
                MOVNE   pc, lr

                ; UpCall_StreamCreated
                ; r0 = 10 (Stream created)
                ; r1 = device driver's handle
                ; r2 = 0 if created for reception (else created for transmission)
                ; r3 = file handle for stream
                ; r4 = DeviceFS stream handle as passed to us on initialisation

                Entry   "r0"

                Debug   adverr, "UpCall_StreamCreated, DeviceFS handle = ", r4

                LDR     r0, StreamHandle        ; the DeviceFS stream handle of our current stream (if any, else 0)
                TEQ     r0, r4                  ; is it the handle we just got?
                STREQ   r3, FileSwitchHandle    ; yes, so let us keep the FileSwitch handle!

              [ debug
                BNE     %FT00
                Debug   adverr, "Storing FileSwitch handle ", r3
00
              ]
                EXIT
        ]

                END
@


4.11
log
@Fix data abort when trying to print
Common.s: Misplaced comment moved
IOEB.s: Make sure pp_ctrl is relative to HardwareBase
        Preserve C bit over the HAL call
Parallel.s: Misplaced ASSERT moved
This module still stiffs when trying to print, but it at least doesn't data abort too!

Version 0.77. Tagged as 'Parallel-0_77'
@
text
@d158 1
a158 1
                MOVEQ   r5, #3          ; set the buffer handle
d184 1
a184 4
                MOV     r0, #3                  ; change flags for parallel buffer (DeviceFS won't do this)
                ORR     r1, r3, #BufferFlags_SendThresholdUpCalls
                MOV     r2, #0
                SWI     XBuffer_ModifyFlags
d187 1
a187 1
                MOVEQ   r5, #3                  ; use parallel buffer
@


4.10
log
@Fix stack imbalance in ioeb_busy and have a spring clean
Now uses OS_Memory throughout to determine controller addresses rather than calling the private HAL_ControllerAddress API.
Be devious in all the register pokes by making HardwareBase be roughly half way between the two sets of standard parallel registers and ECP mode ones, so they're always in range for an immediate offset of LDRB/STRB so the code doesn't thrash the literal pool so much.
Where possible, eliminate HAL conditional code by initialising HardwareBase in the non HAL case thus simplifying code paths a bit.
Be a bit less ugly in the 0.5us delays, since the combo chip is using Type B cycles a dummy read of a SuperIO chip will waste 0.5us rather than needing to back calculate the IOEB registers.
Expand tabs, use OSBytes header file.

Version 0.76. Tagged as 'Parallel-0_76'
@
text
@d257 1
a257 1
                RestPSR r8,,cf
d260 1
a260 2
                EXIT                            ; restore flags and reenable IRQ's

@


4.9
log
@Add support for HAL builds
Detail:
  s/Parallel - Use HAL_ControllerAddress to get the address of the 82C710. IOMD IRQ numbers are assumed.
  s/Common - Use HAL_ControllerAddress to get the address of IOMD when measuring the CPU speed
  s/FastCent, s/IOEB - Use HardwareBase for hardware access and HAL calls for IRQ handling instead of fixed IOC/IOMD address & direct memory poking
  s/IOEB, s/Parallel - HAL version of UpdateIOEBCtrl gets copied into the module workspace to allow it to be used with the old calling standard (since we need to look up the C710 address)
  s/IOC - Add code that'll warn if this file gets built for a HAL target
Admin:
  Tested on RiscPC via IOMD ROM softload.
  Code is rather rough and could do with cleaning up in places (e.g. direct poking of timer registers in s/Common, and less-than-optimal register save/restore in ClearPINTR macro)


Version 0.74. Tagged as 'Parallel-0_74'
@
text
@d205 1
a205 1
ncpuloops * 2048	; loop this many times
d211 6
d219 10
d231 7
a237 28
		; We load Timer0 with &7FFE, and set it going. Then we go into
		; a tight loop for ncpuloops times. Then we reread the timer
		; and see how much it has gone down
		; We then return 16384 (&4000) divided by this number so that we
		; return numbers which are higher when the processor is faster

		LDR	R1, =&7FFE		; 32K @@@@ 2MHz = ~16ms limit
 [ HAL
                ; This whole code sequence is naughty and should really use
                ; the HAL timer API. For now, just poke the timer directly.
                Push    "r1,r8,r9"
                MOV     r1, #&400
                MOV     r8, #0
                MOV     r9, #EntryNo_HAL_ControllerAddress
                SWI     OS_Hardware
                MOV     r3, r0
                Pull    "r1,r8,r9"
 |
		MOV	R3, #IOC		; Address of the IO controller
 ]

	        MOV     r0, r1, LSR #8
        	STRB    r1, [r3, #Timer1LL]
	        STRB    r0, [r3, #Timer1LH]
        	LDR     r0, =ncpuloops
	        STRB    r0, [r3, #Timer1GO]     ; start the timer NOW
	        B       %FT25                   ; Looks superfluous, but is required
        	                                ; to get ncpuloops pipeline breaks
d239 2
a240 2
	        SUBS    r0, r0, #1              ; 1S
        	BNE     %BT25                   ; 1N + 2S
d242 12
a253 12
	        STRB    r0, [r3, #Timer1LR]     ; latch count NOW
        	LDRB    r2, [r3, #Timer1CL]
	        LDRB    r0, [r3, #Timer1CH]
        	ADD     r2, r2, r0, LSL #8      ; count after looping is ...

	        SUB     r2, r1, r2              ; decrements !, &7FFE - current time = time it takes to do loops

		MOV	R1, #10*&4000		; Instead of dividing by 4 (done at site of use), multiply
						; by 10 (here). The only requirement for this number is that
						; it is big enough to avoid the callback code being called
						; in normal use. JRC 27 May 1997
		DivRem	R0, R1, R2, R3		; R0 := 16384 DIV R2 (R3 is temp)
d255 1
a255 1
		STR	r0, LoopFactor		; save for next time
d262 1
a262 1
	[ AdvancedErrorHandling
d278 2
a279 2
                TEQ	r0, #UpCall_StreamCreated
		MOVNE	pc, lr
d281 18
a298 18
		; UpCall_StreamCreated
		; r0 = 10 (Stream created)
		; r1 = device driver's handle
		; r2 = 0 if created for reception (else created for transmission)
		; r3 = file handle for stream
		; r4 = DeviceFS stream handle as passed to us on initialisation

		Entry	"r0"

		Debug	adverr, "UpCall_StreamCreated, DeviceFS handle = ", r4

		LDR	r0, StreamHandle        ; the DeviceFS stream handle of our current stream (if any, else 0)
		TEQ	r0, r4                  ; is it the handle we just got?
		STREQ	r3, FileSwitchHandle    ; yes, so let us keep the FileSwitch handle!

	      [ debug
		BNE	%FT00
		Debug	adverr, "Storing FileSwitch handle ", r3
d300 3
a302 3
	      ]
		EXIT
	]
d304 1
a304 1
		END
@


4.8
log
@  Improved error handling and ioctl support/bug fixes
Detail:
  Explan have added error elucidation from a printer
  They have also fixed a number of bugs in ioctl read device id
  I have done an interim fix of another bug in the reverse nibble code
Admin:
  Tested on RPC. No errors in several thousand reads of device ID and no errors on several thousand reads of device ID interleaved with sending data

Version 0.68. Tagged as 'Parallel-0_68'
@
text
@d222 11
d234 1
@


4.7
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.66. Tagged as 'Parallel-0_66'
@
text
@d38 1
a38 1
                Debug   open,"common_open",r2
d254 42
@


4.6
log
@  kbracey_32bit branch taken.
Detail:
  This is the result of the 32-bit branch merge.
Admin:
  This module has received modest testing.  It has not been exhaustively
    tested.  Projects taking this version should be careful with it as it
    may contain bugs.

Version 0.64. Tagged as 'Parallel-0_64'
@
text
@d209 1
a209 1
                ENTRY   "r0-r3,r8"
@


4.5
log
@  added device identification.
Detail:
  this allows the host to query the peripheral as to what it is.  As per
  IEEE1284-1994 spec.
Admin:
  This has not been excessivly tested as it does not interfere with the
  usual workings of the parallel port.  It has been tested with the
  lexmark Z12 and a HP 950

Version 0.63. Tagged as 'Parallel-0_63'
@
text
@d36 1
a36 1
                ENTRY   "r2-r4"
d48 1
a48 1
                ORRNES  pc, lr, #V_bit
d86 1
a86 1
                ENTRY   "r2,r3"
d90 1
a90 2
                ORR     lr, lr, #I_bit
                TEQP    lr, #0                                  ; disable IRQs
d115 1
a115 2
                PullEnv VS                                      ; return any error from ReleaseDeviceVector
                ORRVSS  pc, lr, #V_bit                          ; but ensure we set the I bit back
d130 1
a130 1
                EXITS                                           ; exit restoring all flags (including I)
d132 4
d180 1
a180 1
common_createRX ENTRY   "r0-r2"
d209 1
a209 1
		ENTRY	"r0-r3"
d213 1
a213 2
                ORR     lr, lr, #I_bit
                TEQP    lr, #0                  ; disable IRQs
d250 2
a251 1
                EXITS				; restore flags and reenable IRQ's
d253 1
@


4.4
log
@Changed to use srccommit.
Spinner branch merged.
Inclusion of Hdr:CMOS removed.

Version 0.51. Tagged as 'Parallel-0_51'
@
text
@d239 1
a239 1
	        SUB     r2, r1, r2              ; decrements !
d250 1
@


4.4.2.1
log
@  First cut at 32-bit compatibility.
Detail:
  Lots of changes have been required in this module as it manipulates
    the PSR all over the place in various interesting ways.
Admin:
  Built, but not tested yet.

Version 0.60, 4.13.2.1. Tagged as 'Parallel-0_60-4_13_2_1'
@
text
@d36 1
a36 1
                EntryS  "r2-r4"
d48 1
a48 1
                RETURNVS NE
d86 1
a86 1
                EntryS  "r2,r3,r8"
d90 2
a91 1
                SETPSR  I_bit,lr,,r8                            ; disable IRQs
d116 2
a117 1
                BVS     %FT15
a133 4
15
                ORR     r8, r8, #V_bit
                RestPSR r8,,cf                                  ; ensure I bit is restored and V is set
                EXIT                                            ; return any error from ReleaseDeviceVector
d178 1
a178 1
common_createRX EntryS  "r0-r2"
d207 1
a207 1
                ENTRY   "r0-r3,r8"
d211 2
a212 1
                SETPSR  I_bit,lr,,r8            ; disable IRQs
d249 1
a249 4
                RestPSR r8
                NOP

                EXIT                            ; restore flags and reenable IRQ's
@


4.4.2.2
log
@  Major stack imbalance fixed.
  EXITS macros passed the fields parameter.
Detail:
  EXITS does NOT restore the c part of the CPSR only the flags.  Since
    this module was relying on EXITS to reset IRQ/FIQ/mode bits, this
    module wasn't going to work very well.
  The error generator on the DeviceFS entry point was severely broken in
    that it would remove 10 words from the stack that weren't actually
    there.
Admin:
  Built, but untested.


Version 0.60, 4.13.2.4. Tagged as 'Parallel-0_60-4_13_2_4'
@
text
@d130 1
a130 1
                EXITS   ,cf                                     ; exit restoring all flags (including I)
d250 1
a250 1
                RestPSR r8,,cf
@


4.4.2.3
log
@  Merge of latest trunk version to the 32-bit branch.
Detail:
  Merged here for testing before committing this to the trunk
    as the master version.
Admin:
  Untested.

Version 0.60, 4.13.2.5. Tagged as 'Parallel-0_60-4_13_2_5'
@
text
@d240 1
a240 1
	        SUB     r2, r1, r2              ; decrements !, &7FFE - current time = time it takes to do loops
@


4.3
log
@Spinner branch merged
@
text
@d201 1
a201 1
; fast the processor is. e.g. a 200MHz StrongArm returns r0=#268
a216 1
		;
a229 1

d241 4
a244 1
		MOV	R1, #&4000		; = 16384
@


4.3.2.1
log
@Parallel device driver modified for Phoebe hardware
NOT backwards compatible.
@
text
@a208 1
 [ WhatAnAbortion
d245 1
a245 3
 |
 		MOV	r0, #LoopFactor_Value
 ]
@


4.2
log
@ARTtmp branch folded
@
text
@a201 3
;
; The first time it is called, calibration is performed for a while, which will
; mean that it will take longer that time. Thereafter it should be immediate.
d205 3
a207 1
common_get_loop_factor ENTRY
d211 2
a212 6
		LDR	r0, LoopFactor
		TEQ	r0, #0			; Delay factor calibrated yet?
		BEQ	%FT20                   ; if not, calibrate
		EXITS				; else return with value in r0
20
		Push	"R1-R3"			; Okay, calibrate
d248 1
a248 3
		Pull	"R1-R3"
                EXITS

a250 1

@


4.1
log
@Initial revision
@
text
@d33 2
d193 65
a258 1
                END
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Fix for busy after ack bug.
@
text
@a32 2


a190 65
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: common_get_loop_factor
;
; in:   -
;
; out:  r0 = looping factor
;
; This call is made to find a looping factor. This is a measurement of how
; fast the processor is. e.g. a 200MHz StrongArm returns r0=#268
;
; The first time it is called, calibration is performed for a while, which will
; mean that it will take longer that time. Thereafter it should be immediate.

ncpuloops * 2048	; loop this many times

common_get_loop_factor ENTRY

                Debug   open,"common_get_loop_factor"

		LDR	r0, LoopFactor
		TEQ	r0, #0			; Delay factor calibrated yet?
		BEQ	%FT20                   ; if not, calibrate
		EXITS				; else return with value in r0
20
		Push	"R1-R3"			; Okay, calibrate

		; We load Timer0 with &7FFE, and set it going. Then we go into
		; a tight loop for ncpuloops times. Then we reread the timer
		; and see how much it has gone down
		;
		; We then return 16384 (&4000) divided by this number so that we
		; return numbers which are higher when the processor is faster

		LDR	R1, =&7FFE		; 32K @@@@ 2MHz = ~16ms limit
		MOV	R3, #IOC		; Address of the IO controller

	        MOV     r0, r1, LSR #8
        	STRB    r1, [r3, #Timer1LL]
	        STRB    r0, [r3, #Timer1LH]
        	LDR     r0, =ncpuloops
	        STRB    r0, [r3, #Timer1GO]     ; start the timer NOW
	        B       %FT25                   ; Looks superfluous, but is required
        	                                ; to get ncpuloops pipeline breaks

25
	        SUBS    r0, r0, #1              ; 1S
        	BNE     %BT25                   ; 1N + 2S

	        STRB    r0, [r3, #Timer1LR]     ; latch count NOW
        	LDRB    r2, [r3, #Timer1CL]
	        LDRB    r0, [r3, #Timer1CH]
        	ADD     r2, r2, r0, LSL #8      ; count after looping is ...

	        SUB     r2, r1, r2              ; decrements !

		MOV	R1, #&4000		; = 16384
		DivRem	R0, R1, R2, R3		; R0 := 16384 DIV R2 (R3 is temp)

		STR	r0, LoopFactor		; save for next time

		Pull	"R1-R3"
                EXITS


		END
d192 1
@


4.1.7.3
log
@   Calculate loop factor in init code; added Paper, OnLine, Printer message tokens;
make appropriate upcalls in ioeb_monitorTX when paper out etc; use
ParallelDeviceDriver$Path for resources; added 'j' debug flag.
@
text
@d202 3
d208 1
a208 3
common_get_loop_factor ROUT

		ENTRY	"r0-r3"
d212 6
a217 2
                ORR     lr, lr, #I_bit
                TEQP    lr, #0                  ; disable IRQs
d253 3
a255 1
                EXITS				; restore flags and reenable IRQ's
d258 1
@


4.1.7.4
log
@   Make timeout much bigger.
@
text
@d201 1
a201 1
; fast the processor is.
d217 1
d231 1
d243 1
a243 4
		MOV	R1, #10*&4000		; Instead of dividing by 4 (done at site of use), multiply
						; by 10 (here). The only requirement for this number is that
						; it is big enough to avoid the callback code being called
						; in normal use. JRC 27 May 1997
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.18;
access;
symbols
	Parallel-0_79:4.18
	Parallel-0_78:4.18
	Parallel-0_77:4.18
	Parallel-0_76:4.17
	Parallel-0_75:4.16
	Parallel-0_74:4.16
	Parallel-0_73:4.14
	Parallel-0_72:4.14
	Parallel-0_71:4.14
	Parallel-0_70:4.14
	Parallel-0_69:4.14
	Parallel-0_68:4.13
	Parallel-0_67:4.12
	Parallel-0_66:4.12
	Parallel-0_65:4.11
	kbracey_32bit_merge:4.9.2.4
	Parallel-0_64:4.11
	Parallel-0_60-4_13_2_5:4.9.2.4
	Parallel-0_60-4_13_2_4:4.9.2.3
	Parallel-0_60-4_13_2_3:4.9.2.2
	Parallel-0_63:4.10
	Parallel-0_60-4_13_2_2:4.9.2.2
	Alpnet_approved:4.9
	Parallel-0_62:4.9
	dellis_autobuild_BaseSW:4.9
	Parallel-0_61:4.9
	Parallel-0_60-4_13_2_1:4.9.2.1
	kbracey_32bit:4.9.0.2
	sbrodie_sedwards_16Mar2000:4.9
	Parallel-0_60:4.9
	Parallel-0_59:4.8
	dcotton_autobuild_BaseSW:4.14
	Parallel-0_58:4.7
	Parallel-0_57:4.6
	Parallel-0_56:4.6
	Parallel-0_55:4.5
	Parallel-0_54:4.5
	mstphens_UrsulaRiscPCBuild_20Nov98:4.4
	Ursula_RiscPC:4.4.0.6
	Parallel-0_53:4.5
	Parallel-0_52:4.5
	Parallel-0_51:4.5
	FunaiNC2_Parallel-0_50:4.1.7.4
	rthornb_UrsulaBuild-19Aug1998:4.4
	UrsulaBuild_FinalSoftload:4.4
	wturner_parallel-0_47:4.4.2.1
	wturner_parallel-0_46:4.4
	rthornb_UrsulaBuild-12Aug1998:4.4
	aglover_UrsulaBuild-05Aug1998:4.4
	rthornb_UrsulaBuild-29Jul1998:4.4
	rthornb_UrsulaBuild-22Jul1998:4.4
	rthornb_UrsulaBuild-15Jul1998:4.4
	rthornb_UrsulaBuild-07Jul1998:4.4
	rthornb_UrsulaBuild-17Jun1998:4.4
	rthornb_UrsulaBuild-03Jun1998:4.4
	rthornb_UrsulaBuild-27May1998:4.4
	rthornb_UrsulaBuild-21May1998:4.4
	rthornb_UrsulaBuild_01May1998:4.4
	afrost_NC2_Generic:4.1.7.4
	afrost_Funai01-33:4.1.7.4
	Spinner_RCA116:4.1.7.4
	Spinner_B20_2:4.1.7.4
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.4
	Spinner_B17:4.1.7.4
	Spinner_B15:4.1.7.4
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Spinner_B12:4.1.7.3
	Spinner_B10:4.1.7.3
	Daytona:4.4.0.4
	Ursula:4.4.0.2
	Spin_merge_16May97:4.1.7.2
	Daytona_bp:4.4
	Ursula_bp:4.4
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.2
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2.2.1
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.4
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.18
date	2012.12.20.08.36.04;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	9ssBEbFq3jtroWww;

4.17
date	2012.06.23.16.24.15;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	NqgW20IuiIZMLQ9w;

4.16
date	2011.06.22.00.52.49;	author jlee;	state Exp;
branches;
next	4.15;
commitid	G7LnLvkSoQ9EpBov;

4.15
date	2009.06.11.21.18.21;	author bavison;	state Exp;
branches;
next	4.14;

4.14
date	2001.08.29.13.40.27;	author mboura;	state Exp;
branches;
next	4.13;

4.13
date	2001.08.03.14.53.50;	author mboura;	state Exp;
branches;
next	4.12;

4.12
date	2001.03.16.15.59.13;	author sbrodie;	state Exp;
branches;
next	4.11;

4.11
date	2001.01.09.14.10.03;	author sbrodie;	state Exp;
branches;
next	4.10;

4.10
date	2000.11.01.13.59.40;	author arodger;	state Exp;
branches;
next	4.9;

4.9
date	99.10.26.08.34.13;	author kbracey;	state Exp;
branches
	4.9.2.1;
next	4.8;

4.8
date	99.10.25.17.28.03;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.08.17.11.36.21;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.01.29.17.20.41;	author nturton;	state Exp;
branches;
next	4.5;

4.5
date	98.10.19.16.10.31;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	97.05.16.11.32.08;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	97.05.16.11.15.00;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.07.12.02.44;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.36.27;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.9.2.1
date	2000.07.23.20.43.04;	author sbrodie;	state Exp;
branches;
next	4.9.2.2;

4.9.2.2
date	2000.10.24.13.55.46;	author sbrodie;	state Exp;
branches;
next	4.9.2.3;

4.9.2.3
date	2000.11.29.12.41.40;	author sbrodie;	state Exp;
branches;
next	4.9.2.4;

4.9.2.4
date	2001.01.09.11.39.29;	author sbrodie;	state Exp;
branches;
next	;

4.4.2.1
date	98.08.18.15.12.04;	author wturner;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.36.27;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.30.28;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.54.56;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.49.36;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.20.13.32.56;	author scormie;	state Exp;
branches
	4.1.7.2.2.1;
next	4.1.7.3;

4.1.7.3
date	97.04.30.18.19.02;	author scormie;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.07.02.11.06.37;	author arodger;	state Exp;
branches;
next	;

4.1.7.2.2.1
date	97.04.23.13.07.16;	author blaughto;	state Exp;
branches;
next	;


desc
@@


4.18
log
@Fix data abort when trying to print
Common.s: Misplaced comment moved
IOEB.s: Make sure pp_ctrl is relative to HardwareBase
        Preserve C bit over the HAL call
Parallel.s: Misplaced ASSERT moved
This module still stiffs when trying to print, but it at least doesn't data abort too!

Version 0.77. Tagged as 'Parallel-0_77'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Parallel

; *******************
; *** Change List ***
; *******************

; 20-Jan-91 0.10 DDV Parallel device created, new style.
; 22-Jan-91      DDV Tidied the handling of finalise.
; 23-Jan-91      DDV Now traps Service_DeviceFSStarting/Dying.
; 23-Jan-91 0.11 DDV Calls to register to cope with new scheme.
; 25-Jan-91 0.12 DDV Fixed twee problem that stopped it printing.
; 29-Jan-91      DDV Setup so that validation strings generate an error.
; 15-Feb-91      DDV Checks made for hardware configuration.
; 17-Feb-91      DDV Device init functions added to allow devices to reset hardware.
; 17-Feb-91 0.13 DDV Semi-working 82C710 output routine added.
; 19-Feb-91      DDV IRQ routine for 82C710 improved.
; 20-Feb-91 0.14 DDV Finished changes to IRQ routine.
; 27-Feb-91      DDV Tweeked 827C10 interrupt routine changed, now uses Busy as IRQ source.
; 27-Feb-91      DDV Now sets up PrinterType$1 to use parallel:Output
; 27-Feb-91      DDV Added 'buffer,n' to validation string so kernel can specify which buffer to use.
; 27-Feb-91      DDV Removed IEOB input conditions.
; 28-Feb-91      DDV Validation string changed + default system var.
; 06-Mar-91      DDV Added configure/status command for buffer size.
; 06-Mar-91      DDV Reads CMOS bits for buffer size on module init.
; 06-Mar-91 0.15 DDV Handles value from special field correctly.
; 07-Mar-91      DDV Bug fix; CMOS read no longer corrupts all registers.
; 07-Mar-91      DDV Bug fix; DeviceFS table for IOEB now has miscop entry correctly placed.
; 07-Mar-91      DDV Contents of PrinterType$1 changed to include buffer handle.
; 07-Mar-91 0.16 DDV Bug fix; Decode of special field now gets buffer handle correctly.
; 07-Mar-91      DDV Bug fix; IOC IRQ busy routine checked the IRQ mask not IRQ status.
; 08-Mar-91      DDV Removed configure command for buffers.
; 11-Mar-91      DDV Added calls to Buffer_Unlink device to ensure buffer free'd.
; 11-Mar-91 0.17 DDV When DeviceFS starting service is recieved it will use SWIs, not call addresses.
; 12-Apr-91      DDV Internationalised.
; 12-Apr-91      DDV Added machine type checking.
; 12-Apr-91      DDV Added Parallel_HardwareAddress SWI.
; 12-Apr-91      DDV Clearing edge triggered interrupt on 710 added.
; 12-Apr-91      DDV Split again into some more useful files.
; 12-Apr-91      DDV Intergration with new DeviceFS
; 13-Apr-91 0.18 DDV Added new parameter to return IOEB update address.
; 17-Apr-91      DDV Tightened up coding for internationalisation.
; 18-Apr-91 0.19 DDV Bug fix; fixed stack inbalance.
; 21-Apr-91      DDV Changed to use IOEB binding for PINTR
; 21-Apr-91      DDV Now traps Service_DeviceDead.
; 21-Apr-91 0.20 DDV Changed system variable being used.
; 01-May-91 0.21 DDV Changed to cope with Jon's changes in special fields.
; 03-May-91 0.22 DDV Moved clear of the PINTR latch to end of IRQ routine.
; 16-Jul-91 0.23 TMD Made unknown SWI use global message.
;                    Recoded IRQ routines.
; 22-Jul-91 0.24 TMD Moved clearing of printer acknowledge to inside strobe
;                    routine (ie its now also called from dormant state).
;                    This is to clear any fake acknowledge signals caused by
;                    printer power-on.
; 30-Jul-91 0.25 TMD Put in CallAfters to poll busy when dormant.
;                    Improved strobe timing (doesn't use timers any more -
;                    they took too long)
; 31-Jul-91 0.26 TMD Changed device record to add reserved field
;                    Service_Reset code only executed on soft reset
; 08-Aug-91 0.27 TMD Fixed bug in SWI despatch
;                    Fixed bug in busy callafter code (was removing callafter without saving lr_svc)
; 22-Aug-91 0.28 TMD Base of errors changed
;                    Put in code that recognises 82C711
; 20-Nov-91 0.29 TMD Changed code that recognises 710/711 to check parallel sub-unit type
; 05-Dec-91 0.30 SMC Added parallel input stream
;                    Added SWI Parallel_Op
; 13-Dec-91 0.31 SMC Now only uses one local error message, the rest are global.
; 03-Feb-92 0.32 JSR Adjust service call entry for changed Service_MessageFileClosed.
; 02-Mar-92 0.33 TMD Added option to check busy after acknowledge pulse.
;                    Tidied up a few atomicity failures.
; 17-Mar-92 0.34 TMD Made it poll busy 20 times before rescheduling, for printers where
;                    busy always goes low after ack goes high.
; 21-Jun-93 0.35 SMC Now uses BufferManager service routines, not INSV/REMV.
;                    On read signal busy with nSlctIn and nAutoFd (for ECP cables).
;                    Created file Common to isolate files IOC, IOEB.
;                    Added file FastCent with driver for fastparallel: device (parallel FIFO).
; 29-Jun-93 0.36 SMC On IOMD based platforms clear PINTR in IRQCLRA, not using PINTR_Latch.
; 14-Jul-93 0.37 SMC OS_ReadSysInfo interface changed.
; 31-Aug-93 0.38 SMC Set ECR before CTRL as they are the same register in standard mode.
; 13-Dec-93 0.39 SMC Time out when waiting for PACK high after interrupt (prevent hang on printer off).
; 21-Jan-94 0.40 SMC Create for TX/RX should only have set the buffer id to 3 if it was -1.
; 20-Jul-94 0.41 RCM Added power saving code (active ONLY for portables) see StorkPower flag.
; 26-Jul-94 0.42 RCM Added conditional assembly flags OldHardware & NewHardware.
;                    Set OldHardware to false to save ROM space for RO Black.
; 13-Aug-94 0.43 ??? ??????????
; 18-Mar-97 0.44 JIFL Added timing loop function common_get_loop_factor to
;                     ensure processor speed independence
; 23-Apr-97 0.45 BAL Fixed bug where IOEB halt and resume routines were corrupting R3
;        (ARTtmp)
; 29 Apr 97 0.45 JRC Calculate loop factor in init code; added Paper, OnLine, Printer message tokens;
;        (Spinner)   make appropriate upcalls in ioeb_monitorTX when paper out etc; use
;                    ParallelDeviceDriver$Path for resources; added 'j' debug flag.
; 16 May 97 0.46 KJB Two version 0.45s merged.
; 17 Aug 99 0.58 KJB Service call table added.
; 25 Oct 99 0.59 KJB Added support for version 2 parallel (just a different IRQ line).
; 26 Oct 99 0.60 KJB Completed interrupt changes.
; 1  Nov 00 0.63 AR  added device discovery
; 20 Jul 01      MW  added advanced error handling support (UpCall_DeviceError)

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                GET     Hdr:ListOpts
                GET     Hdr:Macros
                GET     Hdr:System
                GET     Hdr:ModHand
                GET     Hdr:FSNumbers
                GET     Hdr:NewErrors
                GET     Hdr:Services
                GET     Hdr:Symbols
                GET     Hdr:NDRDebug
                GET     Hdr:HostFS
                GET     Hdr:Proc
                GET     Hdr:DevNos
                GET     Hdr:PublicWS
                GET     Hdr:DDVMacros
                GET     Hdr:Buffer
                GET     Hdr:DeviceFS
                GET     Hdr:Machine.<Machine>
                $GetIO
                GET     Hdr:IO.IOEB
                GET     Hdr:MsgTrans
                GET     Hdr:ResourceFS
                GET     Hdr:Portable
                GET     Hdr:UpCall
                GET     Hdr:OSBytes
        [ HAL
                GET     Hdr:HALEntries
        ]

                GBLL    debug
                GBLL    hostvdu
                GBLL    international
                GBLS    debug_file

                GBLL    CheckBusyAfterAck       ; whether to check busy after acknowledge pulse

CheckBusyAfterAck SETL  {TRUE}

                GBLL    FastBufferMan
FastBufferMan   SETL    {TRUE}

                GBLL    FastCentronics
FastCentronics  SETL    {TRUE}

                GBLL    StorkPower
StorkPower      SETL    {TRUE}                  ; try powering down the hardware when not in use

                GBLL    OldHardware             ; assemble code for old serial hardware?
OldHardware     SETL    {FALSE} ;{TRUE}         ; switched off to save space for RO Black

                GBLL    NewHardware             ; assemble code for new serial hardware (ie PC combo chips)
NewHardware     SETL    {TRUE}

                GBLL    AdvancedErrorHandling   ; use UpCall_DeviceError for error handling?
AdvancedErrorHandling   SETL {TRUE} :LAND: NewHardware ; advanced error handling only available with IOEB

; The following are defined because the new buffer manager interface uses r2 to
; insert and remove bytes whereas the old interface uses r0.
 [ FastBufferMan
tmp     RN      0
byte    RN      2
 |
byte    RN      0
tmp     RN      2
 ]

                GBLL    standalonemessages
 [ :DEF: standalone
standalonemessages SETL standalone
 |
standalonemessages SETL {FALSE}
 ]

debug           SETL    {FALSE}
hostvdu         SETL    {FALSE}
international   SETL    {TRUE}
debug_file      SETS    "Custom:Debug.parallel"

inter           SETD    {TRUE}
open            SETD    {TRUE}
close           SETD    {TRUE}
out             SETD    {TRUE}
in              SETD    {TRUE}
irq             SETD    {TRUE}
j               SETD    {TRUE}
ioctl           SETD    {FALSE}
nibble          SETD    {FALSE}
ioctl_err       SETD    {TRUE}
ioctl_loop      SETD    {FALSE}
nibble_err      SETD    {TRUE}
adverr          SETD    {FALSE}

                GET     VersionASM
                GET     Errors.s

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Macros
;

 [ FastBufferMan
; Calls buffer manager service routine (corrupts lr).
                MACRO
$label          CallBuffMan     $cc

$label          Push    "r12"                                   ; save our workspace ptr
                ADR$cc   r12, BuffManWkSpace                    ; place of buffman wkspace and entry
                MOV$cc   lr, pc                                 ; return address
                ASSERT  BuffManService = BuffManWkSpace+4
                LDM$cc.IA r12, {r12, pc}                        ; load buffman wkspace and entry
                Pull    "r12"                                   ; restore our workspace ptr

                MEND
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Device workspace.
;

                        ^ 0, wp
Flags                   # 1             ; global flags used by module, updated only in foreground
IRQFlags                # 1             ; flags updated from IRQs, or from foregd with IRQs off
DeviceNo                # 1             ; RISC OS device number
 [ :LNOT: HAL
InterruptBit            # 1             ; bit in InterruptClear and interrupt mask register
InterruptClear          # 4             ; address of interrupt clear register
 |
                        # 1             ; Padding
HAL_SB                  # 4             ; SB for HAL calls
HAL_IRQDisable          # 4             ; HAL_IRQDisable routine
HAL_IRQEnable           # 4             ; HAL_IRQEnable routine
HAL_IRQClear            # 4             ; HAL_IRQClear routine
 ]
BufferHandle            # 4             ; handle for read/write buffer
StreamHandle            # 4             ; handle for output data
DeviceHandle            # 4             ; handle for device (from DeviceFS)
HardwareType            # 4             ; hardware type
HardwareBase            # 4             ; hardware base address return by calls
ByteBuffer              # 4             ; place to hold byte which couldn't be buffered
 [ FastCentronics
FastHandle              # 4             ; handle for fast device
 ]
 [ FastBufferMan
BufferId                # 4             ; buffer managers iternal buffer id
BuffManWkSpace          # 4             ; buffer managers workspace pointer
BuffManService          # 4             ; address of buffer manager service routine
 ]
 [ StorkPower
portable_present        # 4             ;  = 0 if we don't think the Portable module is present
                                        ;  = 1 if we do
power_state             # 4             ;
 ]
                      [ international
MessagesWorkspace       # 16            ; block of workspace for opening message files
localerrorblock         # 256           ; do not use MessageTrans error block, as it gets trashed too easily
                      ]

LoopFactor              # 4             ; factor for tight loops giving a delay
                                        ; of 40 us

 [ AdvancedErrorHandling
FileSwitchHandle        # 4             ; file switch handle of current stream (undefined if no open stream)
 ]
 [ HAL
UpdateIOEBCtrlSize      * &38 ; Yuck
UpdateIOEBCtrl          # UpdateIOEBCtrlSize
 ]

wsrequired              * :INDEX: @@


; constants about workspace

; Bits in Flags

f_VectorOwned           * 1:SHL:0       ; bit 0 set => IRQ vector owned
f_WeHaveMessages        * 1:SHL:1       ; bit 1 set => messages file loaded
f_OpenForRead           * 1:SHL:2       ; bit 2 set => open for read
f_OpenForWrite          * 1:SHL:3       ; bit 3 set => open for write
 [ FastCentronics
f_UseFIFO               * 1:SHL:4       ; bit 4 set => register fastparallel: device
 ]
 [ AdvancedErrorHandling
f_UpCallVectorClaimed   * 1:SHL:5       ; bit 5 set => UpCall vector has been claimed
 ]

; Bits in IRQFlags

if_PendingCallAfter     * 1:SHL:0       ; bit 0 set => pending CallAfter exists
if_ReadHalted           * 1:SHL:1       ; bit 1 set => input stream halted

; default flags for DeviceFS_Register
 [ NewHardware
dfsr_flags              * ParentFlag_MonitorTransfers ; Monitor TX/RX functions available
 |
dfsr_flags              * 0
 ]

hardware_IOC            * 0             ; which hardware type being used
hardware_IOEB           * 1
hardware_IOMD           * 2             ; similar to IOEB but has Pintr clear, not external latch

BusyCheckInterval       * 1            ; time between busy checks (centiseconds)
RevNibBusyCheckInterval * 1            ; delay before check following reverse nibble

Parallel_Threshold      * 1016

ParallelPowerBits       * PortableControl_ParallelEnable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Now we have the module header, this defines all the entry points required
; for the module.
;

                AREA    |Parallel$$Code|, CODE, READONLY, PIC

Module_BaseAddr & 0
                & init -Module_BaseAddr                 ; init code
                & final -Module_BaseAddr                ; final code
                & service -Module_BaseAddr              ; service code

                & title -Module_BaseAddr                ; title string for module
                & help -Module_BaseAddr                 ; help string pointer
                & 0

                & ParallelSWI_Base
                & swicode -Module_BaseAddr
                & switable -Module_BaseAddr
                & 0

        [ :LNOT: No32bitCode
                & 0                                     ; international messages
                & moduleflags - Module_BaseAddr         ; flags
        ]

title           = "ParallelDeviceDriver",0
help            = "Parallel Device",9,"$Module_HelpVersion"
              [ debug
                = " Development version"
              ]
                = 0
                ALIGN

switable        = "Parallel", 0
                = "HardwareAddress", 0
                = "Op", 0
                = 0

                [       international
                !       0, "Internationalised version"
resource_file   =       "ParallelDeviceDriver:Messages", 0
                ]
                ALIGN

                MakeErrorBlock Parallel_BadCall
                MakeErrorBlock Parallel_BadHardware
                MakeErrorBlock Parallel_InUse
                MakeErrorBlock Parallel_PaperOut
                MakeErrorBlock Parallel_Offline
                MakeErrorBlock Parallel_OtherError

                MakeErrorBlock Escape
                
                ALIGN

        [ :LNOT: No32bitCode
moduleflags     DCD     ModuleFlag_32bit
        ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Now data passed to the device register call.
;

setsysvar       = "Set PrinterType$1 devices#buffer3:$."
devicename      = "Parallel", 0
 [ FastCentronics
fastname        = "FastParallel",0
 ]
                ALIGN

block
                & devicename -.         ; offset to device name
                & DeviceFlag_BufferedDevice+ DeviceFlag_DefinePathVariable ; flags
                & 0                     ; default RX buffer flags
                & 1024                  ; default RX buffer size
                & 0                     ; default TX buffer flags
                & 1024                  ; default TX buffer size
                & 0                     ; reserved field (must be zero)

                & 0                     ; end of list marker

 [ FastCentronics
fastblock
                & fastname -.           ; offset to device name
                & DeviceFlag_BufferedDevice+ DeviceFlag_DefinePathVariable ; flags
                & 0                     ; default RX buffer flags
                & 0                     ; default RX buffer size
                & 0                     ; default TX buffer flags
                & 1024                  ; default TX buffer size
                & 0                     ; reserved field (must be zero)

                & 0                     ; end of list marker
 ]

                ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setvar  =       "If ""<ParallelDeviceDriver$Path>"" = """" then "
        =       "Set ParallelDeviceDriver$Path Resources:$.Resources.Parallel."
        =       0 ;so lazy!

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Now we must handle the module init calls.
;

init            Entry   "r7"

                LDR     r2, [wp]
                TEQ     r2, #0                                  ; any workspace?
                BNE     %FT10                                   ; yes, so handle as warm start

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =wsrequired
                SWI     XOS_Module                              ; claim it
                EXIT    VS                                      ; return if it errored

                STR     r2, [wp]
10
                MOV     wp, r2                                  ; wp -> workspace

                [       debug
                Debug_Open debug_file
                ]

                Debug   j, "initialised"

        [ standalonemessages
                ADR     r0, resourcefsfiles
                SWI     XResourceFS_RegisterFiles   ; ignore errors (starts on Service_ResourceFSStarting)
        ]

                ADR     r0, setvar
                SWI     XOS_CLI
                EXIT    VS

                MOV     r0, #0                                  ; zap workspace
                STRB    r0, Flags
                STRB    r0, IRQFlags
                STR     r0, StreamHandle
                STR     r0, DeviceHandle
                STR     r0, BufferHandle
                STR     r0, HardwareBase
                BL      common_get_loop_factor
        [ FastCentronics
                STR     r0, FastHandle
        ]
        [ FastBufferMan
                STR     r0, BufferId
                STR     r0, BuffManService
                STR     r0, BuffManWkSpace
        ]

        [ HAL
                Push    "r8,r9"
                MOV     r8, #OSHW_LookupRoutine
                MOV     r9, #EntryNo_HAL_IRQDisable
                SWI     XOS_Hardware
                STR     r0, HAL_IRQDisable
                STR     r1, HAL_SB
                MOV     r9, #EntryNo_HAL_IRQEnable
                SWIVC   XOS_Hardware
                STR     r0, HAL_IRQEnable
                MOV     r9, #EntryNo_HAL_IRQClear
                SWIVC   XOS_Hardware
                STR     r0, HAL_IRQClear
                Pull    "r8,r9"
                EXIT    VS
        ]

                MOV     r0, #2                                  ; read machine information
                SWI     XOS_ReadSysInfo
                EXIT    VS                                      ; return any errors generated

                BIC     r0, r0, #&FF :SHL: 24                   ; not interested in video controller
                BIC     r0, r0, #&FF :SHL: 16                   ; or memory controller
                AND     r1, r1, #&FF                            ; only interested in I/O chip type

 [ OldHardware
                TEQ     r0, #&0000                              ; is it an A1 series machine?
                MOVEQ   r0, #hardware_IOC
                BEQ     %20
 ]
 [ NewHardware
                TEQ     r0, #&0001                              ; has it got IOEB
                TEQNE   r0, #&0100                              ; or IOMD
                TEQEQ   r1, #&01                                ; and an 82C710/711 (or similar)
                BNE     %15                                     ; no, so report error

                TEQ     r0, #&0001
                MOVEQ   r7, #hardware_IOEB
                MOVNE   r7, #hardware_IOMD
        [ :LNOT: HAL
                LDREQ   r0, =PINTR_Latch
                LDRNE   r0, =IOC+IOCIRQCLRA                     ; note address of IRQ clear register
                STR     r0, InterruptClear
        ]
   
                MOV     r0, #3                                  ; read version fields for each sub-unit
                SWI     XOS_ReadSysInfo
                EXIT    VS
                AND     r0, r0, #(15 :SHL: 8)                   ; extract parallel sub-unit version
                TEQ     r0, #(1 :SHL: 8)                        ; if not type 1
                TEQNE   r0, #(2 :SHL: 8)                        ; and not type 2 then
                BNE     %15                                     ;   report error
 
                TEQ     r0, #(1 :SHL: 8)
        [ :LNOT: HAL
                ASSERT  IOMD_PrinterIRQ_DevNo < 8               ; we assume the mask is in IOCIRQMSKA
                ASSERT  IOMDr_PrinterIRQ_DevNo < 8
                MOVEQ   r0,  #IOMD_printer_IRQ_bit              ; types 1 and 2 are the same, apart from
                MOVNE   r0,  #IOMDr_printer_IRQ_bit             ;   the interrupt used
                STRB    r0, InterruptBit
        ]
                MOVEQ   r14, #IOMD_PrinterIRQ_DevNo
                MOVNE   r14, #IOMDr_PrinterIRQ_DevNo
                STRB    r14, DeviceNo

        [ FastCentronics
                AND     r1, r1, #(15 :SHL: 8)                   ; extract extra features
                TEQ     r1, #(1 :SHL: 8)                        ; if we can use fast centronics then
                LDREQB  r0, Flags                               ;   set flag
                ORREQ   r0, r0, #f_UseFIFO
                STREQB  r0, Flags
        ]
                MOV     r0, r7                                  ; hardware OK
                B       %20
 ]
15
                ADRL    r0, ErrorBlock_Parallel_BadHardware
 [ international
                BL      MakeError
                BL      CloseMessages                           ; close messages if module init is failing
 ]
                SETV
                EXIT                                            ; generate error about invalid hardware platform
20
                STR     r0, HardwareType                        ; store in workspace
 [ HAL
                ; Set up UpdateIOEBCopy
                ADRL    r0, UpdateIOEBCtrlProto
                ADR     r1, UpdateIOEBCtrl
                MOV     r2, #UpdateIOEBCtrlSize
21
                SUBS    r2,r2,#4
                LDR     r3,[r0,r2]
                STR     r3,[r1,r2]
                BNE     %BT21
                MOV     r0,#1
                ADD     r2,r1,#UpdateIOEBCtrlSize
                SWI     XOS_SynchroniseCodeAreas                
 ]     

                BL      registerdevice                          ; register the device
                ADRVC   r0, setsysvar
                SWIVC   XOS_CLI                                 ; setup system variable
 [ StorkPower
                EXIT    VS                                      ; return any errors generated

                MOV     r0, #1                                  ; pretend portable module present
                STR     r0, portable_present                    ; at least until we know better
                LDR     r0, =ParallelPowerBits
                STR     r0, power_state                         ; show power_state as ON, to
                BL      SetPower_Off                            ; force SetPower_Off to call XPortable_Control
 ]

 [ AdvancedErrorHandling
                ; We want to use the UpCall_DeviceError mechanism for handling errors, so
                ; whenever there is a parallel stream open, we need its FileSwitch handle.
                ; We can get this by monitoring the UpCall vector and checking for
                ; UpCall_StreamCreated.
                MOV     r0, #UpCallV
                ADRL    r1, common_check_upcall
                MOV     r2, r12
                SWI     XOS_Claim

                ; if, for some reason, we are not able to claim the UpCall vector, we
                ; simply do not set the UpCallVectorClaimed flag, which means that we
                ; will fall back onto the previous error handling strategy in
                ; IOEB_monitorTX
                LDRVCB  r0, Flags
                ORRVC   r0, r0, #f_UpCallVectorClaimed
                STRVCB  r0, Flags
 ]

                CLRV
                EXIT

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle the module close down.
;

final           Entry

                LDR     wp, [wp]                                ; setup workspace pointer

                LDR     r0, StreamHandle
                TEQ     r0, #0                                  ; are any of the outputs being used
                PullEnv NE
                ADRNE   r0, ErrorBlock_Parallel_InUse

        [ international
                BNE     MakeErrorWithDeviceName
        |
                RETURNVS NE
        ]

        [ standalonemessages
                ADR     R0, resourcefsfiles
                SWI     XResourceFS_DeregisterFiles
        ]

                LDR     r0, DeviceHandle
                TEQ     r0, #0                                  ; is device registered?
                SWINE   XDeviceFS_Deregister                    ; remove device from being active

        [ FastCentronics
                LDR     r0, FastHandle
                TEQ     r0, #0
                SWINE   XDeviceFS_Deregister
        ]

                Debug   j, "terminated"

                [       debug
                Debug_Close
                ]

        [ international
                BL      CloseMessages                           ; we are definitely dying - close msgs
        ]

        [ AdvancedErrorHandling
                ; we may have claimed the UpCall vector, so release it if we have
                LDRB    r0, Flags
                TST     r0, #f_UpCallVectorClaimed
                MOVNE   r0, #UpCallV
                ADRNEL  r1, common_check_upcall
                MOVNE   r2, r12
                SWINE   XOS_Release

                ; we are definitely dying, so there is no point in resetting f_UpCallVectorClaimed
        ]
                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle service calls.
;
                ASSERT  Service_Reset < Service_ResourceFSStarting
                ASSERT  Service_ResourceFSStarting < Service_DeviceFSStarting
                ASSERT  Service_DeviceFSStarting < Service_DeviceFSDying
                ASSERT  Service_DeviceFSDying < Service_DeviceDead
                ASSERT  Service_DeviceDead < Service_Portable
servicetable    &       0
                &       serviceentry -Module_BaseAddr
                &       Service_Reset
 [ standalonemessages
                &       Service_ResourceFSStarting
 ]
                &       Service_DeviceFSStarting
                &       Service_DeviceFSDying
                &       Service_DeviceDead
 [ StorkPower
                &       Service_Portable
 ]
                &       0

                &       servicetable -Module_BaseAddr
service         ROUT
                MOV     r0, r0
                TEQ     r1, #Service_Reset
                TEQNE   r1, #Service_DeviceFSStarting
                TEQNE   r1, #Service_DeviceFSDying
                TEQNE   r1, #Service_DeviceDead
 [ StorkPower
                TEQNE   r1, #Service_Portable
 ]
 [ standalonemessages
                TEQNE   r1, #Service_ResourceFSStarting
 ]
                MOVNE   pc, lr

serviceentry    LDR     wp, [wp]                                ; wp -> workspace

                TEQ     r1, #Service_Reset
                BEQ     svc_reset                               ; machine reset pending

                TEQ     r1, #Service_DeviceFSStarting
                BEQ     svc_starting                            ; handle the fs starting again

                TEQ     r1, #Service_DeviceFSDying
                BEQ     svc_devfsdead                           ; DeviceFS reseting...

        [ standalonemessages
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT10
                Push    "r0-r3,lr"
                ADR     r0, resourcefsfiles
                MOV     lr, pc
                MOV     pc, r2
                Pull    "r0-r3,pc"
10
        ]

        [ StorkPower
                TEQ     r1, #Service_Portable
                BNE     %FT40
                TEQ     r2, #ServicePortable_PowerDown
                BNE     %FT35

                Push    "r0,r2,lr"
                MOV     lr, #1
                STR     lr, portable_present            ; indicate portable module present
                LDR     lr, =ParallelPowerBits
                TST     r3, lr                          ; are they trying to power down parallel port
                Pull    "r0,r2,pc",EQ                   ; no then just pass on the service

                LDRB    r0, Flags                       ; if open for reading or writing
                TST     r0, #f_OpenForRead :OR: f_OpenForWrite  ; then complain
                BEQ     %FT32                           ; [both closed, so OK]
                BICS    r3, r3, lr                      ; by clearing the parallel bits
                MOVEQ   r1, #0                          ; and if there are no more bits being turned off
                Pull    "r0,r2,pc"                      ; then claim service to save time
32
                LDR     r0, power_state                 ; update our record of which bits are on
                BIC     r0, r0, r3
                STR     r0, power_state
                Pull    "r0,r2,pc"

35
                TEQ     r2, #ServicePortable_PowerUp    ; bits being powered up
                MOVNE   pc, lr
                Push    "r0,r3,lr"
                MOV     lr, #1
                STR     lr, portable_present            ; indicate portable module present
                LDR     lr, =ParallelPowerBits
                AND     r3, r3, lr                      ; just get parallel bits which are being powered up
                LDR     r0, power_state
                ORR     r0, r0, r3                      ; and or them into our current state
                STR     r0, power_state
                Pull    "r0,r3,pc"

40
        ]

; must be device dead, we've checked for all the rest, so drop thru to ...

svc_devicedead
                Push    "lr"

                LDR     lr, DeviceHandle
                TEQ     lr, r2                                  ; is it my device being killed, don't bother checking r3.
                STREQ   r0, DeviceHandle                        ; yep, so write the value.

        [ FastCentronics
                LDR     lr, FastHandle
                TEQ     lr, r2
                STREQ   r0, FastHandle
        ]

                Pull    "pc"

svc_reset
                Push    "r0-r2, lr"

        [ AdvancedErrorHandling
                ; we need to claim the UpCall vector again after a reset
                MOV     r0, #UpCallV
                ADRL    r1, common_check_upcall
                MOV     r2, r12
                SWI     XOS_Claim
                LDRB    r0, Flags
                ORRVC   r0, r0, #f_UpCallVectorClaimed
                BICVS   r0, r0, #f_UpCallVectorClaimed
                STRB    r0, Flags
        ]

                MOV     r0, #OsByte_RW_LastResetType
                MOV     r1, #0
                MOV     r2, #&FF
                SWI     XOS_Byte
                TEQ     r1, #0

                Pull    "r0-r2, pc",NE                          ; if hard reset, do nothing

                BL      svc_devfsdead                           ; reset the variables etc...

                LDR     r0, HardwareType
                TEQ     r0, #hardware_IOC                       ; reset the relevant hardware
;                BLEQ    IOCreset                               ; (doesn't need to do anything on old hardware)
                BLNE    IOEBreset

                Pull    "r0-r2, pc"

svc_devfsdead
                Push    "lr"

                MOV     lr, #0                                  ; zap buffer handles
                STR     lr, DeviceHandle
                STR     lr, StreamHandle
                STR     lr, BufferHandle
        [ FastCentronics
                STR     lr, FastHandle
        ]
        [ FastBufferMan
                STR     lr, BufferId
                STR     lr, BuffManService
                STR     lr, BuffManWkSpace
        ]
                STRB    lr, IRQFlags

        [ FastCentronics
                LDRB    lr, Flags
                AND     lr, lr, #f_UseFIFO                      ; keep use FIFO bit
                STRB    lr, Flags
        |
                STRB    lr, Flags
        ]

                Pull    "pc"


svc_starting
                Push    "r0, lr"

                BL      registerdevice
                ADRVCL  r0, setsysvar
                SWIVC   XOS_CLI                                 ; setup system variable

                Pull    "r0, pc"

                LTORG

                GBLS    conditionalgetbodge
 [ standalonemessages
                GBLS    ApplicationName
ApplicationName SETS    "Parallel"
conditionalgetbodge SETS "GET s.ResFiles"
resourcefsfiles
 |
conditionalgetbodge SETS ""
 ]
                $conditionalgetbodge
 [ standalonemessages
                DCD     0
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; SWI despatching within the module.
;

swicode         ROUT

                LDR     wp, [wp]

                CMP     r11, #(%10-%00):SHR:2                   ; is the SWI within a valid range?
                ADDCC   pc, pc, r11, LSL #2
                B       %10
00
                B       HardwareAddr
                B       ParallelOp
10
                ADR     r0, ErrorBlock_Parallel_BadSWI
 [ international
                B       MakeErrorWithModuleName
 |
                RETURNVS
 ]

                MakeErrorBlock Parallel_BadSWI

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Parallel_HardwareAddress
;
; in:   -
;
; out:  r0 -> base address of 82C710 within IOEB / =0 on non-ioeb machines.
;               if r0 >0 then
;                       r1 -> routine to update IOEB ctrl register
;
; This call is provided to read the base address of the 82C710 parallel port
; within IOEB workspace.  The device can then be driven directly by applications,
; although this is not really advised.
;
; People wishing to do such a ghastly deed should first lock the device by
; opening a stream onto it.
;

HardwareAddr    LDR     r0, HardwareBase                        ; return base address
                TEQ     r0, #0
                SUBNE   r0, r0, #pp_imm                         ; deduct convenience offset
                ADRNEL  r1, UpdateIOEBCtrl                      ; if it is an IOEB then -> update ctrl function

                RETURNVC

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ParallelOp
;
; in:   r0 = reason code
;       other registers as determined by reason code
;
; out:  r0 preserved
;       other registers as determined by reason code
;
 [ StorkPower
; We don't call SetPower_On/Off around this call.
; The user is recommended (in the PRM 2-481) to claim exclusive use
; of the port by doing 'lock%=OPENOUT("parallel:")', this will ensure
; that the port is powered. The user should release the port by doing
; 'CLOSE#lock%', which will power it down.
 ]
;

ParallelOp      ROUT
                Push    "r3"
                LDR     r3, HardwareBase                        ; Make sure the correct hardware is there
                TEQ     r3, #0
                ADREQL  r0, ErrorBlock_Parallel_BadHardware
                Pull    "r3"
        [ international
                BEQ     MakeError
        |
                RETURNVS
        ]
                CMP     r0, #(%10-%00):SHR:2
                ADDCC   pc, pc, r0, LSL #2
                B       %10
00
                B       IOEB_ReadDataStatus
                B       IOEB_WriteData
                B       IOEB_ReadWriteCtrl
10
                ADR     r0, ErrorBlock_Parallel_BadParm
        [ international
                B       MakeError
        |
                RETURNVS
        ]

                MakeErrorBlock Parallel_BadParm

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: registerdevice
;
; in:   -
;
; out:  -
;
; This routine registers the specified device, the routine assumes that the
; hardware type has been obtained and then it will attempt to register a
; device within DeviceFS.
;

registerdevice  Entry   "r0-r7"

                LDR     r0, HardwareType
                TEQ     r0, #hardware_IOC                       ; which type of hardware?
;                BLEQ    IOCreset                               ; (doesn't do anything on IOC)
                BLNE    IOEBreset                               ; reset it...
 [ OldHardware
                ADREQL  r2, IOCdevice                           ; -> device routine
 ]
 [ NewHardware
                ADRNEL  r2, IOEBdevice
 ]
                MOV     r0, #dfsr_flags                         ; flags for registering device
                ADRL    r1, block                               ; device description block
                MOV     r3, #0
                MOV     r4, wp
                MOV     r5, #0                                  ; validation string with no decoding message
                MOVEQ   r6, #0                                  ; no receive buffer for IOC
                MOVNE   r6, #1                                  ; single receive buffer for IOEB
                MOV     r7, #1                                  ; single transmit buffer
                SWI     XDeviceFS_Register
                EXIT    VS

                STR     r0, DeviceHandle                        ; store device handle away
                Debug   open,"device handle =",r0

 [ FastCentronics
                LDRB    r0, Flags
                TST     r0, #f_UseFIFO
                EXIT    EQ

                MOV     r0, #dfsr_flags
                ADRL    r1, fastblock
                ADRL    r2, FastDevice
                MOV     r6, #0
                SWI     XDeviceFS_Register
                STRVC   r0, FastHandle
                Debug   open,"fast handle =",r0
 ]

                EXIT

 [ StorkPower
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Power management routines
;

SetPower_On     EntryS  "r0,r1"
                LDR     r0, =ParallelPowerBits
                B       SetPower                        ; turn on power


SetPower_Off    ALTENTRY
                MOV     r0, #0                          ; turn power off

; and drop thru to...

SetPower        ROUT
                LDR     lr, portable_present            ; if no portable module present
                TEQ     lr, #0
                EXITS   EQ                              ; then do nothing

                LDR     lr, power_state                 ; if current state = new state, do nothing
                TEQ     r0, lr
                EXITS   EQ

                LDR     r1, =:NOT: ParallelPowerBits
                SWI     XPortable_Control               ; new = (old AND r1) EOR r0
                STRVC   r1, power_state

                MOVVS   r0, #0                          ; if we got an error
                STRVS   r0, portable_present            ; then set portable_present = FALSE
                LDRVS   r0, =ParallelPowerBits
                STRVS   r0, power_state                 ; and set power_state = ON
                EXITS

                LTORG
 ]
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
              [ international

; Attempt to open the messages file.

OpenMessages    ROUT

                Entry   "r0-r3"

                SUBS    r2, r2, r2                              ; clears V, R2=0 (allocate RMA for messages)
                LDRB    r3, Flags
                TST     r3, #f_WeHaveMessages                   ; do we have an open messages block?
                EXIT    NE                                      ; yes, so don't bother again
                ORR     r3, r3, #f_WeHaveMessages

                ADR     r0, MessagesWorkspace
                ADRL    r1, resource_file                       ; -> path to be opened
                SWI     XMessageTrans_OpenFile
                STRVCB  r3, Flags                               ; assuming it worked mark as having messages

                EXIT                                            ; returning VC, VS from XSWI!


; Attempt to close the messages file.

CloseMessages   ROUT

                Entry   "r0"

                LDRB    r0, Flags
                TST     r0, #f_WeHaveMessages                   ; do we have any messages?
                BIC     r0, r0, #f_WeHaveMessages
                STRNEB  r0, Flags                               ; mark as we don't have them
                ADRNE   r0, MessagesWorkspace
                SWINE   XMessageTrans_CloseFile                 ; yes, so close the file

                EXIT


; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.

MakeErrorWithModuleName Entry "r1-r7"
                ADRL    r4, title
                B       MakeErrorEntry

MakeErrorWithDeviceName ALTENTRY
                ADRL    r4, devicename
                B       MakeErrorEntry

MakeError       ALTENTRY
                MOV     r4, #0
MakeErrorEntry
                BL      OpenMessages                            ; re-open messages if necessary
                EXIT    VS

                ADR     r1, MessagesWorkspace                   ; -> message control block
                ADR     r2, localerrorblock                     ; was 'MOV r2, #0', but for some reason
                                                                ; MsgTrans trashes the block. JRC 21-Apr-1997
                MOV     r3, #?localerrorblock
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0                                  ; no substitution + use internal buffers
                SWI     XMessageTrans_ErrorLookup

                EXIT                                            ; return, r0 -> block, V set
              ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ debug
                InsertNDRDebugRoutines
 ]

                GET     Common.s

                GBLS    getaroundaasm
 [ OldHardware
getaroundaasm   SETS    "GET s.IOC"
 |
getaroundaasm   SETS    ""
 ]
                $getaroundaasm

 [ NewHardware
getaroundaasm   SETS    "GET s.IOEB"
 |
getaroundaasm   SETS    ""
 ]
                $getaroundaasm

                GBLS    GETFastCent
 [ FastCentronics
GETFastCent     SETS    "GET s.FastCent"
 |
GETFastCent     SETS    ""
 ]
                $GETFastCent

                END
@


4.17
log
@Fix stack imbalance in ioeb_busy and have a spring clean
Now uses OS_Memory throughout to determine controller addresses rather than calling the private HAL_ControllerAddress API.
Be devious in all the register pokes by making HardwareBase be roughly half way between the two sets of standard parallel registers and ECP mode ones, so they're always in range for an immediate offset of LDRB/STRB so the code doesn't thrash the literal pool so much.
Where possible, eliminate HAL conditional code by initialising HardwareBase in the non HAL case thus simplifying code paths a bit.
Be a bit less ugly in the 0.5us delays, since the combo chip is using Type B cycles a dummy read of a SuperIO chip will waste 0.5us rather than needing to back calculate the IOEB registers.
Expand tabs, use OSBytes header file.

Version 0.76. Tagged as 'Parallel-0_76'
@
text
@d547 3
a549 1

a551 3

                TEQ     r0, #(1 :SHL: 8)
        [ :LNOT: HAL
@


4.16
log
@Add support for HAL builds
Detail:
  s/Parallel - Use HAL_ControllerAddress to get the address of the 82C710. IOMD IRQ numbers are assumed.
  s/Common - Use HAL_ControllerAddress to get the address of IOMD when measuring the CPU speed
  s/FastCent, s/IOEB - Use HardwareBase for hardware access and HAL calls for IRQ handling instead of fixed IOC/IOMD address & direct memory poking
  s/IOEB, s/Parallel - HAL version of UpdateIOEBCtrl gets copied into the module workspace to allow it to be used with the old calling standard (since we need to look up the C710 address)
  s/IOC - Add code that'll warn if this file gets built for a HAL target
Admin:
  Tested on RiscPC via IOMD ROM softload.
  Code is rather rough and could do with cleaning up in places (e.g. direct poking of timer registers in s/Common, and less-than-optimal register save/restore in ClearPINTR macro)


Version 0.74. Tagged as 'Parallel-0_74'
@
text
@d100 1
a100 1
;		      ensure processor speed independence
d124 1
a124 1
		GET	Hdr:HostFS
d131 1
a131 1
                GET	Hdr:Machine.<Machine>
d138 1
d167 2
a168 7
		GBLL	AdvancedErrorHandling   ; use UpCall_DeviceError for error handling?
AdvancedErrorHandling 	SETL	{TRUE}

 [ AdvancedErrorHandling
		; the advanced error handling mechanism is only available with IOEB
		ASSERT	NewHardware
 ]
d187 18
a204 18
debug           SETL    false
hostvdu         SETL    false
international   SETL    true
debug_file	SETS	"Custom:Debug.parallel"

inter           SETD    true
open            SETD    true
close           SETD    true
out             SETD    true
in              SETD    true
irq             SETD    true
j		SETD	true
ioctl           SETD    false
nibble		SETD	false
ioctl_err       SETD    true
ioctl_loop      SETD    false
nibble_err      SETD    true
adverr          SETD    false
d273 1
a273 1
localerrorblock		# 256		; do not use MessageTrans error block, as it gets trashed too easily
d276 2
a277 2
LoopFactor		# 4		; factor for tight loops giving a delay
					; of 40 us
d280 1
a280 1
FileSwitchHandle	# 4             ; file switch handle of current stream (undefined if no open stream)
d312 1
a312 1
dfsr_flags		* ParentFlag_MonitorTransfers ; Monitor TX/RX functions available
d314 1
a314 1
dfsr_flags		* 0
d373 4
a376 4
 		[	international
		!	0, "Internationalised version"
resource_file   =	"ParallelDeviceDriver:Messages", 0
		]
d382 3
a384 3
		MakeErrorBlock Parallel_PaperOut
		MakeErrorBlock Parallel_Offline
		MakeErrorBlock Parallel_OtherError
d439 3
a441 3
setvar	=	"If ""<ParallelDeviceDriver$Path>"" = """" then "
	=	"Set ParallelDeviceDriver$Path Resources:$.Resources.Parallel."
	=	0 ;so lazy!
d463 3
a465 3
		[	debug
		Debug_Open debug_file
		]
d467 1
a467 1
		Debug	j, "initialised"
d474 3
a476 3
		ADR	r0, setvar
		SWI	XOS_CLI
		EXIT	VS
d485 1
a485 1
		BL	common_get_loop_factor
d497 1
a497 1
                MOV     r8, #1
d610 16
a625 16
		; We want to use the UpCall_DeviceError mechanism for handling errors, so
		; whenever there is a parallel stream open, we need its FileSwitch handle.
		; We can get this by monitoring the UpCall vector and checking for
		; UpCall_StreamCreated.
		MOV	r0, #UpCallV
		ADRL	r1, common_check_upcall
		MOV	r2, r12
		SWI	XOS_Claim

		; if, for some reason, we are not able to claim the UpCall vector, we
		; simply do not set the UpCallVectorClaimed flag, which means that we
		; will fall back onto the previous error handling strategy in
		; IOEB_monitorTX
		LDRVCB	r0, Flags
		ORRVC	r0, r0, #f_UpCallVectorClaimed
		STRVCB	r0, Flags
d673 1
a673 1
		Debug	j, "terminated"
d675 3
a677 3
		[	debug
		Debug_Close
		]
d683 8
a690 8
	[ AdvancedErrorHandling
		; we may have claimed the UpCall vector, so release it if we have
		LDRB    r0, Flags
		TST	r0, #f_UpCallVectorClaimed
		MOVNE	r0, #UpCallV
		ADRNEL	r1, common_check_upcall
		MOVNE	r2, r12
		SWINE	XOS_Release
d692 2
a693 2
		; we are definitely dying, so there is no point in resetting f_UpCallVectorClaimed
	]
d823 11
a833 11
	[ AdvancedErrorHandling
		; we need to claim the UpCall vector again after a reset
		MOV	r0, #UpCallV
		ADRL	r1, common_check_upcall
		MOV	r2, r12
		SWI	XOS_Claim
		LDRB	r0, Flags
		ORRVC	r0, r0, #f_UpCallVectorClaimed
		BICVS	r0, r0, #f_UpCallVectorClaimed
		STRB	r0, Flags
	]
d835 1
a835 1
                MOV     r0, #&FD                                ; read last reset type
d884 1
a884 1
                ADRVCL	r0, setsysvar
d959 1
d1174 2
a1175 2
		ADR	r2, localerrorblock			; was 'MOV r2, #0', but for some reason
								; MsgTrans trashes the block. JRC 21-Apr-1997
@


4.15
log
@  GET file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both objasm and asasm.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 0.73. Not tagged
@
text
@d138 3
d246 1
d249 7
d286 4
d499 17
d536 3
a540 2
                MOVEQ   r7, #hardware_IOEB
                MOVNE   r7, #hardware_IOMD
d542 2
a543 1

d556 1
d558 4
a561 2
                MOVEQ   r14, #IOMD_PrinterIRQ_DevNo             ;   the interrupt used
                MOVNE   r0,  #IOMDr_printer_IRQ_bit
a562 1
                STRB    r0, InterruptBit
d585 14
@


4.14
log
@Summary
  Fixed a number of bugs in reverse nibble
Detail:
  A CallAfter was occasionally trying to write a byte whilst the reverse nibble transfer was in progress. Pending CallAfters are removed before the reverse nibble and reinstated afterwards.
  A number of errors in the reverse nibble negotiate have been fixed.
Admin:
  10000 trials of alternately reading device ID and sending 250 zero bytes gives no errors with HP930C and HP K80

Version 0.69. Tagged as 'Parallel-0_69'
@
text
@d208 1
a208 1
                GET     s.Errors
d1144 1
a1144 1
                GET     s.Common
@


4.13
log
@  Improved error handling and ioctl support/bug fixes
Detail:
  Explan have added error elucidation from a printer
  They have also fixed a number of bugs in ioctl read device id
  I have done an interim fix of another bug in the reverse nibble code
Admin:
  Tested on RPC. No errors in several thousand reads of device ID and no errors on several thousand reads of device ID interleaved with sending data

Version 0.68. Tagged as 'Parallel-0_68'
@
text
@d200 2
a201 2
ioctl           SETD    true
nibble		SETD	true
d203 1
d205 1
a205 1
adverr          SETD    true
d310 2
a311 1
BusyCheckInterval       * 50            ; time between busy checks (centiseconds)
@


4.12
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.66. Tagged as 'Parallel-0_66'
@
text
@d111 1
d163 8
d200 5
d271 4
d289 3
d373 2
d560 20
d634 12
d774 12
@


4.11
log
@  kbracey_32bit branch taken.
Detail:
  This is the result of the 32-bit branch merge.
Admin:
  This module has received modest testing.  It has not been exhaustively
    tested.  Projects taking this version should be careful with it as it
    may contain bugs.

Version 0.64. Tagged as 'Parallel-0_64'
@
text
@a171 1
		[	:LNOT: :DEF: standalonemessages
d173 3
d177 1
a177 1
		]
d305 1
a305 1
                LEADR   Module_LoadAddr
d412 1
a412 1
init            ENTRY   "r7"
d552 1
a552 1
final           ENTRY
d915 1
a915 1
registerdevice  ENTRY   "r0-r7"
d1043 1
a1043 1
MakeErrorWithModuleName ENTRY "r1-r7"
@


4.10
log
@  added device identification.
Detail:
  this allows the host to query the peripheral as to what it is.  As per
  IEEE1284-1994 spec.
Admin:
  This has not been excessivly tested as it does not interfere with the
  usual workings of the parallel port.  It has been tested with the
  lexmark Z12 and a HP 950

Version 0.63. Tagged as 'Parallel-0_63'
@
text
@d110 1
a110 1
; 1  Nov 00 0x63 AR  added device discovery
a132 1
;                GET     Hdr:CMOS
d319 5
d325 1
a325 4
help            = "Parallel Device",9,"$Module_MajorVersion ($Module_Date)"
              [ Module_MinorVersion <> ""
                = " $Module_MinorVersion"
              ]
d352 4
d514 6
a519 2
                PullEnv
                DoError                                         ; generate error about invalid hardware platform
d535 2
a536 1
                EXITS
a560 1
                BL      CloseMessages                           ; just incase, ok so I am paraniod
d562 1
a562 1
                ORRNES  pc, lr, #VFlag
d586 5
a590 1
                EXITS
d633 1
a633 1
                MOVNES  pc, lr
d653 1
a653 1
                Pull    "r0-r3,pc",,^
d668 1
a668 1
                Pull    "r0,r2,pc",EQ,^                 ; no then just pass on the service
d675 1
a675 1
                Pull    "r0,r2,pc",,^                   ; then claim service to save time
d680 1
a680 1
                Pull    "r0,r2,pc",,^
d684 1
a684 1
                MOVNES  pc, lr
d693 1
a693 1
                Pull    "r0,r3,pc",,^
d713 1
a713 1
                Pull    "pc",,^
d724 1
a724 1
                Pull    "r0-r2, pc",NE,^                        ; if hard reset, do nothing
d733 1
a733 1
                Pull    "r0-r2, pc",,^
d760 1
a760 1
                Pull    "pc",,^
d770 1
a770 1
                Pull    "r0, pc",,^
d813 1
a813 1
                ORRS    pc, lr, #V_bit
d844 1
a844 1
                MOVS    pc, lr
d878 1
a878 1
                ORRS    pc, lr, #V_bit
d892 1
a892 1
                ORRS    pc, lr, #V_bit
d961 1
a961 1
SetPower_On     ENTRY   "r0,r1"
a982 1
                EXITS   VC
d984 4
a987 4
                MOV     r0, #0                          ; if we got an error
                STR     r0, portable_present            ; then set portable_present = FALSE
                LDR     r0, =ParallelPowerBits
                STR     r0, power_state                 ; and set power_state = ON
a1001 1

d1006 1
a1006 1
                Push    "r0-r3, lr"
d1008 1
d1011 2
a1012 1
                Pull    "r0-r3, pc", NE, ^                      ; yes, so don't bother again
a1015 1
                MOV     r2, #0                                  ; allocate some wacky space in RMA
a1016 2
                LDRVCB  r3, Flags
                ORRVC   r3, r3, #f_WeHaveMessages
d1019 1
a1019 1
                Pull    "r0-r3, pc",,^                          ; returning VC, VS from XSWI!
d1026 1
a1026 1
                Push    "r0, lr"
d1030 4
a1033 1
                Pull    "r0, pc", EQ, ^                         ; and return if not!
d1035 1
a1035 7
                ADR     r0, MessagesWorkspace
                SWI     XMessageTrans_CloseFile                 ; yes, so close the file
                LDRVCB  r0, Flags
                BICVC   r0, r0, #f_WeHaveMessages
                STRVCB  r0, Flags                               ; mark as we don't have them

                Pull    "r0, pc",,^
a1049 5
		[	debug
		ADD	r0, r0, #4
		DebugS	j, "MakeError", r0, 252
		SUB	r0, r0, #4
		]
d1052 2
a1053 9
                LDRB    r1, Flags
                TST     r1, #f_WeHaveMessages                   ; has the messages file been closed?
		DebugIf	EQ, j, "opening messages file"
                BLEQ    OpenMessages

                LDRB    r1, Flags
                TST     r1, #f_WeHaveMessages
                PullEnv EQ
                ORREQS  pc, lr, #VFlag                          ; if still not open then return with V set
a1061 5
		[	debug
		ADD	r0, r0, #4
		DebugS	j, "looking up", r0, 252
		SUB	r0, r0, #4
		]
a1062 6
		[	debug
		ADD	r0, r0, #4
		DebugS	j, "answer was", r0, 252
		SUB	r0, r0, #4
		Debug	j, "buffer", r0
		]
a1063 13
		Debug	j, "closing messages file"
                BL      CloseMessages                           ; attempt to close the doofer

		[	debug
		PullEnv
		Push	r0
		MOV	r0, sp
		Debug	j, "exit sp", r0
		Debug	j, "exit flags", pc
		Pull	r0
		Debug	j, "returning to", lr
		MOV	pc, lr
		|
a1064 2
		]
		ALIGN
@


4.9
log
@Completed interrupt changes - may actually work now.

Version 0.60. Tagged as 'Parallel-0_60'
@
text
@d110 1
d254 1
a254 1
					; of 1us
@


4.9.2.1
log
@  First cut at 32-bit compatibility.
Detail:
  Lots of changes have been required in this module as it manipulates
    the PSR all over the place in various interesting ways.
Admin:
  Built, but not tested yet.

Version 0.60, 4.13.2.1. Tagged as 'Parallel-0_60-4_13_2_1'
@
text
@a318 5
        [ :LNOT: No32bitCode
                & 0                                     ; international messages
                & moduleflags - Module_BaseAddr         ; flags
        ]

a349 4
        [ :LNOT: No32bitCode
moduleflags     DCD     ModuleFlag_32bit
        ]

d508 2
a509 6
 [ international
                BL      MakeError
                BL      CloseMessages                           ; close messages if module init is failing
 ]
                SETV
                EXIT                                            ; generate error about invalid hardware platform
d525 1
a525 2
                CLRV
                EXIT
d550 1
d552 1
a552 1
                RETURNVS NE
d576 1
a576 5
        [ international
                BL      CloseMessages                           ; we are definitely dying - close msgs
        ]
                CLRV
                EXIT
d619 1
a619 1
                MOVNE   pc, lr
d639 1
a639 1
                Pull    "r0-r3,pc"
d654 1
a654 1
                Pull    "r0,r2,pc",EQ                   ; no then just pass on the service
d661 1
a661 1
                Pull    "r0,r2,pc"                      ; then claim service to save time
d666 1
a666 1
                Pull    "r0,r2,pc"
d670 1
a670 1
                MOVNE   pc, lr
d679 1
a679 1
                Pull    "r0,r3,pc"
d699 1
a699 1
                Pull    "pc"
d710 1
a710 1
                Pull    "r0-r2, pc",NE                          ; if hard reset, do nothing
d719 1
a719 1
                Pull    "r0-r2, pc"
d746 1
a746 1
                Pull    "pc"
d756 1
a756 1
                Pull    "r0, pc"
d799 1
a799 1
                RETURNVS
d830 1
a830 1
                RETURNVC
d864 1
a864 1
                RETURNVS
d878 1
a878 1
                RETURNVS
d947 1
a947 1
SetPower_On     EntryS  "r0,r1"
d989 1
d994 1
a994 1
                Entry   "r0-r3"
a995 1
                SUBS    r2, r2, r2                              ; clears V, R2=0 (allocate RMA for messages)
d998 1
a998 2
                EXIT    NE                                      ; yes, so don't bother again
                ORR     r3, r3, #f_WeHaveMessages
d1002 1
d1004 2
d1008 1
a1008 1
                EXIT                                            ; returning VC, VS from XSWI!
d1015 1
a1015 1
                Entry   "r0"
d1019 1
a1019 4
                BIC     r0, r0, #f_WeHaveMessages
                STRNEB  r0, Flags                               ; mark as we don't have them
                ADRNE   r0, MessagesWorkspace
                SWINE   XMessageTrans_CloseFile                 ; yes, so close the file
d1021 7
a1027 1
                EXIT
d1042 5
d1049 9
a1057 2
                BL      OpenMessages                            ; re-open messages if necessary
                EXIT    VS
d1066 5
d1072 6
d1079 13
d1093 2
@


4.9.2.2
log
@Detail:
  Fixed a stack imbalance.
Admin:
  Built.

Version 0.60, 4.13.2.2. Tagged as 'Parallel-0_60-4_13_2_2'
@
text
@d325 4
a328 1
help            = "Parallel Device",9,"$Module_HelpVersion"
@


4.9.2.3
log
@  Major stack imbalance fixed.
  EXITS macros passed the fields parameter.
Detail:
  EXITS does NOT restore the c part of the CPSR only the flags.  Since
    this module was relying on EXITS to reset IRQ/FIQ/mode bits, this
    module wasn't going to work very well.
  The error generator on the DeviceFS entry point was severely broken in
    that it would remove 10 words from the stack that weren't actually
    there.
Admin:
  Built, but untested.


Version 0.60, 4.13.2.4. Tagged as 'Parallel-0_60-4_13_2_4'
@
text
@d132 1
d983 1
d985 4
a988 4
                MOVVS   r0, #0                          ; if we got an error
                STRVS   r0, portable_present            ; then set portable_present = FALSE
                LDRVS   r0, =ParallelPowerBits
                STRVS   r0, power_state                 ; and set power_state = ON
@


4.9.2.4
log
@  Merge of latest trunk version to the 32-bit branch.
Detail:
  Merged here for testing before committing this to the trunk
    as the master version.
Admin:
  Untested.

Version 0.60, 4.13.2.5. Tagged as 'Parallel-0_60-4_13_2_5'
@
text
@a109 1
; 1  Nov 00 0.63 AR  added device discovery
d252 1
a252 1
					; of 40 us
@


4.8
log
@Added support for "version 2" parallel: if ReadSysInfo 3 says parallel type 2,
then it behaves as before, but claims device 2 rather than 0, as the
interface is on a different interrupt pin.

Version 0.59. Tagged as 'Parallel-0_59'
@
text
@d109 1
d225 3
a227 1
                        # 2             ; align
a268 1
f_DifferentDevice       * 1:SHL:5       ; bit 5 set => not the usual device number
d471 2
d475 1
d485 10
a494 4
                TEQ     r0, #(2 :SHL: 8)                        ; if type 2 then
                LDREQB  r0, Flags                               ;   set flag to note different device number
                ORREQ   r0, r0, #f_DifferentDevice
                STREQB  r0, Flags
@


4.7
log
@Service call table added.

Version 0.58. Tagged as 'Parallel-0_58'
@
text
@d108 1
d266 1
d476 2
a477 1
                TEQ     r0, #(1 :SHL: 8)                        ; if not type 1 then
d479 5
@


4.6
log
@Now GETS IO file dependant on the target machine.  Not always IO.IOC-A1.

Version 0.56. Tagged as 'Parallel-0_56'
@
text
@d107 1
d568 18
d587 1
d589 1
d602 1
a602 1
                LDR     wp, [wp]                                ; wp -> workspace
@


4.5
log
@Changed to use srccommit.
Spinner branch merged.
Inclusion of Hdr:CMOS removed.

Version 0.51. Tagged as 'Parallel-0_51'
@
text
@d126 2
a127 3
;                GET     Hdr:IOEB
;                GET     Hdr:IOMD
                GET     Hdr:IO.IOC-A1
@


4.4
log
@Added missing declaration of debug_file
@
text
@d130 1
a130 1
                GET     Hdr:CMOS
d178 1
a178 1
debug_file	SETS	"<PDDDebug>"
d180 6
a185 6
inter           SETD    false
open            SETD    false
close           SETD    false
out             SETD    false
in              SETD    false
irq             SETD    false
d188 1
a188 1
                GET     Version
d316 4
a319 1
help            = "Parallel Device",9,"$VString ($Date)"
d416 1
a416 1
		Debug_Open "<PDDDebug>"
@


4.4.2.1
log
@Parallel device driver modified for Phoebe hardware
NOT backwards compatible.
@
text
@a106 1
; 14 Aug 98 0.47 WT  Changed for IOMD2. Removed JIFLs _extremely_ broken timing loop. Timer1 SHOULD NOT be used.
a159 6
		GBLL	IOMD2IRQs
IOMD2IRQs	SETL	{TRUE}

		GBLL	WhatAnAbortion
WhatAnAbortion  SETL	{FALSE}

d1063 14
a1076 1
		GET	s.IOEB
@


4.3
log
@Spinner branch merged
@
text
@d139 1
@


4.2
log
@ARTtmp branch folded
@
text
@d102 5
a106 1
;
d118 1
a118 1
                GET     Hdr:NdrDebug
d134 1
d169 1
a169 1
 [ :LNOT: :DEF: standalonemessages
d172 1
a172 1
 ]
d175 1
a175 1
hostvdu         SETL    true
d177 1
d185 1
a189 1

d244 1
d248 1
a248 2
					; of 1us. Do not read directly - use
					; common_get_loop_factor
d270 7
d327 4
a330 4
              [ international
                ! 0, "Internationalised version"
resource_file   = "Resources:$.Resources.Parallel.Messages", 0
              ]
d336 3
d387 3
a389 2


d411 6
d422 4
d433 1
a433 1
		STR	r0, LoopFactor
d547 6
d710 1
a710 1
                ADRVC   r0, setsysvar
d816 1
a816 1
                ADREQ   r0, ErrorBlock_Parallel_BadHardware
d868 1
a868 1
                MOV     r0, #0                                  ; flags for registering device
d887 1
a887 1
                MOV     r0, #0
d999 5
d1008 1
d1017 3
a1019 2
                MOV     r2, #0
                MOV     r3, #0
d1023 5
d1029 6
d1036 1
d1039 10
d1050 2
a1051 1

@


4.1
log
@Initial revision
@
text
@d98 4
d115 1
d146 1
a146 1
StorkPower      SETL    {TRUE}                  ; try powering down the hardware when not in use 
d240 4
d406 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Fix for busy after ack bug.
@
text
@a97 3
; 13-Aug-94 0.43 ??? ??????????
; 18-Mar-97 0.44 JIFL Added timing loop function common_get_loop_factor to
;		      ensure processor speed independence
a110 1
		GET	Hdr:HostFS
d141 1
a141 1
StorkPower      SETL    {TRUE}                  ; try powering down the hardware when not in use
a234 4
LoopFactor		# 4		; factor for tight loops giving a delay
					; of 1us. Do not read directly - use
					; common_get_loop_factor

a396 1
		STR	r0, LoopFactor
@


4.1.7.3
log
@   Calculate loop factor in init code; added Paper, OnLine, Printer message tokens;
make appropriate upcalls in ioeb_monitorTX when paper out etc; use
ParallelDeviceDriver$Path for resources; added 'j' debug flag.
@
text
@d100 2
a101 4
;		     ensure processor speed independence
; 29 Apr 97 0.45 JRC Calculate loop factor in init code; added Paper, OnLine, Printer message tokens;
;                    make appropriate upcalls in ioeb_monitorTX when paper out etc; use
;                    ParallelDeviceDriver$Path for resources; added 'j' debug flag.
d113 1
a113 1
                GET     Hdr:NDRDebug
a128 1
                GET     Hdr:UpCall
d163 1
a163 1
		[	:LNOT: :DEF: standalonemessages
d166 1
a166 1
		]
d169 1
a169 1
hostvdu         SETL    false
a170 1
debug_file	SETS	"<PDDDebug>"
a177 1
j		SETD	true
d182 1
a236 1
localerrorblock		# 256		; do not use MessageTrans error block, as it gets trashed too easily
d240 2
a241 1
					; of 1us
a262 7
; default flags for DeviceFS_Register
 [ NewHardware
dfsr_flags		* ParentFlag_MonitorTransfers ; Monitor TX/RX functions available
 |
dfsr_flags		* 0
 ]

d313 4
a316 4
 		[	international
		!	0, "Internationalised version"
resource_file   =	"ParallelDeviceDriver:Messages", 0
		]
a321 3
		MakeErrorBlock Parallel_PaperOut
		MakeErrorBlock Parallel_Offline
		MakeErrorBlock Parallel_OtherError
d370 2
a371 3
setvar	=	"If ""<ParallelDeviceDriver$Path>"" = """" then "
	=	"Set ParallelDeviceDriver$Path Resources:$.Resources.Parallel."
	=	0 ;so lazy!
a392 6
		[	debug
		Debug_Open "<PDDDebug>"
		]

		Debug	j, "initialised"

a397 4
		ADR	r0, setvar
		SWI	XOS_CLI
		EXIT	VS

d405 1
a405 1
		BL	common_get_loop_factor
a518 6
		Debug	j, "terminated"

		[	debug
		Debug_Close
		]

d676 1
a676 1
                ADRVCL	r0, setsysvar
d782 1
a782 1
                ADREQL  r0, ErrorBlock_Parallel_BadHardware
d834 1
a834 1
                MOV     r0, #dfsr_flags                         ; flags for registering device
d853 1
a853 1
                MOV     r0, #dfsr_flags
a964 5
		[	debug
		ADD	r0, r0, #4
		DebugS	j, "MakeError", r0, 252
		SUB	r0, r0, #4
		]
a968 1
		DebugIf	EQ, j, "opening messages file"
d977 2
a978 3
		ADR	r2, localerrorblock			; was 'MOV r2, #0', but for some reason
								; MsgTrans trashes the block. JRC 21-Apr-1997
                MOV     r3, #?localerrorblock
a981 5
		[	debug
		ADD	r0, r0, #4
		DebugS	j, "looking up", r0, 252
		SUB	r0, r0, #4
		]
a982 6
		[	debug
		ADD	r0, r0, #4
		DebugS	j, "answer was", r0, 252
		SUB	r0, r0, #4
		Debug	j, "buffer", r0
		]
a983 1
		Debug	j, "closing messages file"
a985 10
		[	debug
		PullEnv
		Push	r0
		MOV	r0, sp
		Debug	j, "exit sp", r0
		Debug	j, "exit flags", pc
		Pull	r0
		Debug	j, "returning to", lr
		MOV	pc, lr
		|
d987 1
a987 2
		]
		ALIGN
@


4.1.7.4
log
@added a call to upcall with message to overwrite dialogue boxes that wimp
redraw cannot cover as it is not polled while printing is carried out,
Alistair
@
text
@d174 1
a174 1
debug_file	SETS	"Custom:Debug.parallel"
d176 6
a181 6
inter           SETD    true
open            SETD    true
close           SETD    true
out             SETD    true
in              SETD    true
irq             SETD    true
d409 1
a409 1
		Debug_Open debug_file
@


4.1.7.2.2.1
log
@Oops, forgot to update version number and history section
@
text
@a100 1
; 23-Apr-97 0.45 BAL Fixed bug where IOEB halt and resume routines were corrupting R3
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	1.8;
access;
symbols
	NVRAM-0_68:1.8
	NVRAM-0_67:1.8
	NVRAM-0_66:1.7
	RO_5_07:1.7
	NVRAM-0_65:1.7
	NVRAM-0_64:1.7
	NVRAM-0_63:1.6
	NVRAM-0_62:1.6
	NVRAM-0_61:1.6
	NVRAM-0_60:1.6
	NVRAM-0_59:1.6
	NVRAM-0_58:1.6
	NVRAM-0_57:1.6
	NVRAM-0_56:1.6
	NVRAM-0_55:1.6
	NVRAM-0_54:1.6
	NVRAM-0_53:1.6
	NVRAM-0_52:1.6
	NVRAM-0_51:1.6
	NVRAM-0_50:1.6
	dellis_autobuild_BaseSW:1.6
	NVRAM-0_49:1.6
	NVRAM-0_48:1.5
	NVRAM-0_47:1.4
	NVRAM-0_45:1.4
	NVRAM-0_44:1.3
	NVRAM-0_43:1.3
	NVRAM-0_42:1.3
	sbrodie_sedwards_16Mar2000:1.3
	NVRAM-0_41:1.3
	NVRAM-0_40:1.3
	NVRAM-0_39:1.3
	NVRAM-0_38:1.3
	NVRAM-0_37:1.3
	NVRAM-0_36:1.3
	NVRAM-0_35:1.3
	NVRAM-0_33:1.3
	NVRAM-0_31:1.3
	NVRAM-0_30:1.3
	NVRAM-0_29:1.3
	NVRAM-0_28:1.3
	NVRAM-0_27:1.3
	NVRAM-0_26:1.3
	NVRAM-0_25:1.3
	NVRAM-0_24:1.3
	NVRAM-0_23:1.3
	dcotton_autobuild_BaseSW:1.6
	nturton_NVRAM-0_21:1.3
	NVRAM-0_22:1.3
	dcotton_nvram-MPTInitialBuild:1.3
	NVRAM-0_21:1.3
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1
	Ursula_RiscPC:1.1.0.8
	NVRAM-0_20:1.3
	NVRAM-0_19:1.3
	NVRAM-0_18:1.3
	NVRAM-0_17:1.2
	NVRAM-0_16:1.2
	Spin_merge:1.1.1.7
	NVRAM-0_15:1.2
	NVRAM-2_02:1.2
	rthornb_UrsulaBuild-19Aug1998:1.1
	UrsulaBuild_FinalSoftload:1.1
	rthornb_UrsulaBuild-12Aug1998:1.1
	aglover_UrsulaBuild-05Aug1998:1.1
	rthornb_UrsulaBuild-29Jul1998:1.1
	jfarrell_NVRAM-0_13:1.1.1.6
	rthornb_UrsulaBuild-22Jul1998:1.1
	rthornb_UrsulaBuild-15Jul1998:1.1
	rthornb_UrsulaBuild-07Jul1998:1.1
	rthornb_UrsulaBuild-17Jun1998:1.1
	rthornb_UrsulaBuild-03Jun1998:1.1
	rthornb_UrsulaBuild-27May1998:1.1
	rthornb_UrsulaBuild-21May1998:1.1
	rthornb_UrsulaBuild_01May1998:1.1
	afrost_NC2_Generic:1.1.1.6
	Spinner_B20_2:1.1.1.6
	Spinner_19_3:1.1.1.6
	Spinner_B18:1.1.1.6
	Spinner_B17:1.1.1.6
	Spinner_B15:1.1.1.6
	Spinner_B14:1.1.1.4
	Spinner_B13:1.1.1.4
	Spinner_B12:1.1.1.4
	Spinner_B10:1.1.1.4
	Daytona:1.1.0.6
	Daytona_bp:1.1
	Ursula:1.1.0.4
	Ursula_bp:1.1
	Spinner_B7:1.1.1.3
	ARTtmp_merge:1.1.1.1
	Spin_3Apr97:1.1.1.2
	ARTtmp:1.1.1.1.0.2
	initial:1.1.1.1
	Spinner:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2012.01.01.09.19.08;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	oF6fBP1UW8OG0sNv;

1.7
date	2004.07.01.18.20.47;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.26.17.35.08;	author rcathera;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.08.17.32.11;	author rcathera;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.10.12.44.24;	author jfletche;	state Exp;
branches;
next	1.3;

1.3
date	98.09.24.12.01.42;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	98.09.08.16.21.23;	author srose;	state Exp;
branches;
next	1.1;

1.1
date	97.03.18.18.10.11;	author scormie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.18.18.10.11;	author scormie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.21.16.00.02;	author scormie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.01.11.35.10;	author scormie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.08.09.43.55;	author scormie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.06.25.11.11.08;	author scormie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.06.26.09.30.19;	author scormie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	98.09.07.10.02.34;	author srose;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Makefile rationalised a bit.
Error messages now not padded with one too many nulls.
Use CMHG's magic BAD_SWI return code rather than our own.
Compiles, but not tested.

Version 0.67. Tagged as 'NVRAM-0_67'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* > nvram.c */

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "nvram.h"
#include "msgfile.h"
#include "parse.h"
#include "error.h"

#include "trace.h"

/* Define this if you never want the module to write to the NVRAM. This
   might be useful for debugging, rather than overwriting the settings of
   the machine you are using. */
/* #define NO_WRITES */

/* Define this to ensure that every time the module starts up it applies
   the reset to the entries - this is purely a debug option and is unlikely
   to be useful on non=DEBUG builds; it'll also stop the machine from
   rebooting when it's done as this would be slightly annoying */
/* #define ALWAYS_FULL_RESET */

/* Define this to prevent resetting */
/* #define DONT_REBOOT */

/* rjc/RCathera (for indeed I have many names)
   The caching code in this module is completely redundant -
   all of the read and write routines re-read the NVRAM into the cache in case
   the NVRAM has been altered 'under our feet' (this could be improved with
   the write routine by only reading the first and last byte - needed for tags
   with non-byte aligned start or end).
   KBracey suggested moving the caching into the kernel */

ERROR_STRUCT( static, NOMEM, "NoMem" );
ERROR_STRUCT( static, NOTAG, "NoTag" );
ERROR_STRUCT( static, LOCKED, "Locked");
ERROR_STRUCT( static, READBUF, "ReadBuf");
ERROR_STRUCT( static, NEEDBUF, "NeedBuf");
ERROR_STRUCT( static, NOTBYTE, "NotByte");

static char *pCache = NULL;
static int nvram_size;
static int have_nvmemory_swi;

static void
RawRead( char *pbuf, int byte, int count )
{
        pbuf += byte;

        if (have_nvmemory_swi)
        {
                _swix( OS_NVMemory, _INR(0,3), NVMEMORY_READBLOCK, byte, pbuf, count);
        }
        else
        {
        	/* Read and buffer 'count' bytes from NV-RAM starting at location 'byte'. */
        	while ( count-- > 0 )
        	{
        		int value;

        		_swix( OS_Byte, _INR(0,1)|_OUT(2), OSBYTE_READCMOS, byte++, &value );
        		*pbuf++ = (char)value;
        	}
        }
}


static void
RawWrite( char *pbuf, int byte, int count )
{
#ifndef NO_WRITES
	/* Write 'count' bytes from buffer into NV-RAM starting at location 'byte'. */
	char *ptmp = pbuf + byte;

        if (have_nvmemory_swi)
        {
                _swix( OS_NVMemory, _INR(0,3), NVMEMORY_WRITEBLOCK, byte, ptmp, count);
        }
        else
        {
        	while ( count-- > 0 )
        		_swix( OS_Byte, _INR(0,2), OSBYTE_WRITECMOS, byte++, *ptmp++ );
        }

	/* Update checksum in 'pbuf' by reading back from Kernel. */
	RawRead( pbuf, NVRAM_CHECKSUM_BYTE, 1 );
#endif
}


static void
RawConsistent( char *pold, char *pnew, int byte, int count )
{
#ifndef NO_WRITES
	/* Current NV-RAM contents are in 'pold' buffer, new contents are in	*/
	/* 'pnew' buffer. Go through 'count' bytes starting at location 'byte'	*/
	/* and set any bytes from 'pnew' that are different from those in	*/
	/* 'pold' ie. bring NV-RAM up to date with as few writes as possible.	*/
	if (have_nvmemory_swi)
	{
                while (count > 0)
                {
                        int start = byte;
                        /* Find a run of different bytes */
                        while (count-- > 0 && byte != NVRAM_CHECKSUM_BYTE && pnew[byte] != pold[byte])
                        {
                                byte++;
                        }
                        /* Bytes [start..byte) need to be altered */
                        if (start != byte)
                        {
                                _swix(OS_NVMemory, _INR(0,3), NVMEMORY_WRITEBLOCK, start, pnew+start, byte-start);
                        }
                        /* Find a run of unaltered bytes */
                        while (count-- > 0 && (byte == NVRAM_CHECKSUM_BYTE || pnew[byte] == pold[byte]))
                        {
                                byte++;
                        }
                }
	}
	else
	{
        	while ( count-- > 0 )
        	{
        		/* Check for differences but don't update checksum byte!! */
        		if ( (byte != NVRAM_CHECKSUM_BYTE) && (pnew[byte] != pold[byte]) )
        			_swix( OS_Byte, _INR(0,2), OSBYTE_WRITECMOS, byte, pnew[byte] );
        		byte++;
        	}
        }

	/* Update checksum in 'pnew' by reading back from Kernel. */
	RawRead( pnew, NVRAM_CHECKSUM_BYTE, 1 );
#endif
}


static int
ReadValue( char *pbuf, unsigned int location, unsigned int start_bit, unsigned int length )
{
	/* Ensure that 'start_bit' and 'length' are reasonable values. */
	start_bit &= 7;
	if ( length > 32 ) length = 32;

	/* Check start and end bytes are in range. */
	if ( (location < nvram_size) && (location + (start_bit + length - 1) / 8 < nvram_size) )
	{
		int value, totlen;

		/* Read a 'length'-bit value from 'pbuf' starting at bit 'start_bit' of	*/
		/* byte 'location'.							*/
		pbuf += location;
		value = *pbuf >> start_bit;
		totlen = 8 - start_bit;
		while ( totlen < length )
		{
			value |= *++pbuf << totlen;
			totlen += 8;
		}
		return value & ((1 << length) - 1);
	}
	return 0;
}


static void
WriteValue( char *pbuf, unsigned int value, unsigned int location, unsigned int start_bit, unsigned int length, unsigned int flags )
{
	int byte_length;

	/* Ensure that 'start_bit' and 'length' are reasonable values. */
	start_bit &= 7;
	if ( length > 32 ) length = 32;
	byte_length = (start_bit + length + 7) / 8;

	/* Check start and end bytes are in range. */
	if ( (location < nvram_size) && (location + byte_length - 1 < nvram_size) )
	{
		unsigned int mask = (1 << length) - 1;
		char *ptmp = pbuf + location;

		/* Write a 'length'-bit value into 'pbuf' starting at bit 'start_bit'	*/
		/* of byte 'location'.							*/
		value &= mask;
		*ptmp = (*ptmp & ~(mask << start_bit)) | (value << start_bit);
		value >>= 8 - start_bit;
		mask >>= 8 - start_bit;
		while ( mask != 0 )
		{
			ptmp++;
			*ptmp = (*ptmp & ~mask) | value;
			value >>= 8;
			mask >>= 8;
		}

		/* If writing through to NV-RAM then do the raw write. */
		if ( flags & NVRAM_FLAGS_WRITETHROUGH )
			RawWrite( pbuf, location, byte_length );
	}
}


/* Note that contrary to other calls, length must be an int here. */
static void
CopyBuffer( char *psource, char *pdest, unsigned int location, unsigned int start_bit, int length, unsigned int flags )
{
	int byte_length;

	/* Ensure that 'start_bit' is a reasonable value. */
	/* rjc: byte_length is actually the number of bytes that the tag spans          */
	/* i.e a tag of length 15 bits thats starts at bit 4 will have byte_length = 3  */
	/* an not 2 as one might reasonably expect from the variable name               */
	start_bit &= 7;
	byte_length = (start_bit + length + 7) / 8;

	/* Check start and end bytes are in range. */
	if ( (location < nvram_size) && (location + byte_length <= nvram_size) )
	{
		unsigned int mask = (1 << length) - 1;	/* Will be -1 for length >= 32. */
		char *ptmp = pdest + location;
		if (length >= 32)
		{
		 /* Cannot rely on mask being set to -1 as commented above.  If the right operand  */
		 /* of a shift operator is negative or has a value that equals or exceeds the no.  */
		 /* of bits used to represent the left operand, then the behaviour is undefined,   */
		 /* (Kelley & Pohl, p. 250).  On the ARM, 'funny' values start appearing at length */
		 /* == 256.                                                                        */

		 /* XXX: the rest of the code ought to be checked for the same mistake.  Here is   */
		 /* the correction (tested and verified).                                          */

		    mask = ~0; /* FFFFFFFFu, i.e. -1 in unsigned int */
		}
		psource += location;
		*ptmp = (*ptmp & ~(mask << start_bit)) | (*psource & (mask << start_bit));
		length -= 8 - start_bit;
		while ( length > 7 )
		{
			*++ptmp = *++psource;
			length -= 8;
		}
		if ( length > 0 )
		{
			++ptmp;
			mask = (1 << length) - 1;
			*ptmp = (*ptmp & ~mask) | (*++psource & mask);
		}

		/* If writing through to NV-RAM then do the raw write. */
		if ( flags & NVRAM_FLAGS_WRITETHROUGH )
			RawWrite( pdest, location, byte_length );
	}
}


static void
FullReset( char *pold, char *pnew, location *ploc )
{
	/* Check for location being protected. */
	if ( ploc->flags & LOCATION_FLAGS_PROTECTED )
	{
		TRACE( "FullReset: copying old contents into cache for location &%03X\n" _ ploc->location );

		/* Protected so copy old contents into new contents. */
		CopyBuffer( pold, pnew, ploc->location, ploc->start_bit, ploc->length, NVRAM_FLAGS_WRITECACHE );
	} else {

                /* Otherwise set default value (only possible for locations with length <= 32), or strings */
                if ( ploc->flags & LOCATION_FLAGS_POINTER )
                {
                        TRACE( "FullReset: setting default string for location &%03X\n" _ ploc->location );
                        if ( (ploc->start_bit == 0) && (ploc->length % 8 == 0) )
                        {
                                int  copied  = 0;
                                char *source = defaultString;
                                char *dest   = pnew + ploc->location;
                                while( *source != '\0')
                                {
                                        /* this loop terminates before it copies the /0 byte    */
                                        *dest++ = *source++;
                                        copied++;
                                }

                                /* now zero the rest of the field */
                                memset( dest, 0, (ploc->length / 8) - copied );

                                /* finally free the memory we allocated earlier */
                                free( defaultString );
                                defaultString = NULL;
                        }
                        else
                                TRACE("FullReset: tried to give a non-byte aligned tag a string default\n");
                }
		else if ( ploc->length <= 32 )
		{
			TRACE( "FullReset: setting default value for location &%03X\n" _ ploc->location );

			WriteValue( pnew, ploc->value, ploc->location, ploc->start_bit, ploc->length, NVRAM_FLAGS_WRITECACHE );
		}
	}
}


static void
LockedReset( char *pold, char *pnew, location *ploc )
{
	if ( ploc->flags & LOCATION_FLAGS_LOCKED )
	{
                TRACE( "LockedReset: entered\n" );
                /* LockedReset resets everything that is locked and thus shouldn't be changed but doesn't alter */
                /* the settings that the user is allowed to change */
                /* Set default value (only possible for locations with length <= 32). or strings */
                if ( ploc->flags & LOCATION_FLAGS_POINTER )
                {
                        TRACE( "LockedReset: setting default string for location &%03X\n" _ ploc->location );
                        if ( (ploc->start_bit == 0) && (ploc->length % 8 == 0) )
                        {
                                int  copied  = 0;
                                char *source = defaultString;
                                char *dest   = pnew + ploc->location;
                                while( *source != '\0')
                                {
                                        /* this loop terminates before it copies the /0 byte    */
                                        *dest++ = *source++;
                                        copied++;
                                }

                                /* now zero the rest of the field */
                                memset( dest, 0, (ploc->length / 8) - copied );

                                /* finally free the memory we allocated earlier */
                                free( defaultString );
                                defaultString = NULL;
                        }
                        else
                                TRACE("LockedReset: tried to give a non-byte aligned tag a string default\n");
                }
                else if ( ploc->length <= 32 )
		{
			TRACE( "LockedReset: setting locked value for location &%03X\n" _ ploc->location );

			WriteValue( pnew, ploc->value, ploc->location, ploc->start_bit, ploc->length, NVRAM_FLAGS_WRITECACHE );
		}
	}

	NOT_USED( pold );
}




int
GetLocation( char *ptag, char *pdesc, location *ploc, int getDefault )
{
	TRACE( "GetLocation: looking up tag '%s'\n" _ ptag );

	/* Lookup tag and parse description into location 'ploc'. */
        return ( msgfile_lookup( &tags, ptag, pdesc, TMPBUF_SIZE, NULL) != NULL ) ? parse_description( pdesc, ploc, nvram_size, getDefault ) : 0;
}


static _kernel_oserror *
IterateTags( char *pold, char *pnew, void (*function)(char *, char *, location *) )
{
	_kernel_oserror *err;
	int index = 0;
	char *tagbuf = (char *)malloc( TMPBUF_SIZE*2 );

	if ( tagbuf != NULL )
	{
	  	char *descbuf = tagbuf + TMPBUF_SIZE;

		TRACE( "IterateTags: iterating through Tags file\n" );

		/* Iterate through Tags file and call 'function' for each tag. */
		while (1)
		{
			location loc;

                        err = msgfile_enumerate( &tags, "*", tagbuf, TMPBUF_SIZE, &index );
			if ( (err != NULL) || (index == 0) ) break;
			if ( GetLocation(tagbuf, descbuf, &loc, TRUE) )
				(*function)( pold, pnew, &loc );
		}
		free( tagbuf );
	}
	else err = ERROR( NOMEM );

	return err;
}


_kernel_oserror *
nvram_initialise( void )
{
	_kernel_oserror *err = NULL;

        /* Find out if we have a kernel with OS_NVMemory, and if so, how big is the NVRAM? */
        err = _swix(OS_NVMemory, _IN(0)|_OUT(1), NVMEMORY_SIZE, &nvram_size);
        if (err)
        {
            have_nvmemory_swi = 0;
            nvram_size = DEFAULT_NVRAM_SIZE;
        }
        else
            have_nvmemory_swi = 1;

	/* Allocate space for the cache + space for tag buffer + space for description buffer. */
	if ( (pCache = (char *)malloc(nvram_size)) != NULL )
	{
		/* Allocate space for temporary cache copy. */
		char *pbuf = (char *)malloc(nvram_size);

		TRACE( "nvram_initialise: allocated cache at &%08X\n" _ pCache );

		if ( pbuf != NULL )
		{
			int full_reset;

			/* Read and cache all NV-RAM contents in temporary buffer. */
			TRACE( "nvram_initialise: reading NV-RAM\n" );
			RawRead( pbuf, 0, nvram_size );

			/* Determine whether we need to do a full NVRAM reset. */
#ifdef ALWAYS_FULL_RESET
			full_reset = 1;
#else
			full_reset = ReadValue( pbuf, NVRAM_LASTRESET_BYTE, NVRAM_LASTRESET_BIT, 1 );
#endif

			if ( full_reset )
			{
				TRACE( "nvram_initialise: performing full NV-RAM reset\n" );

				/* Need to reset NV-RAM so start from all 0. */
				memset( pCache, 0, nvram_size );

				/* Iterate through tags and perform a full reset. */
				err = IterateTags( pbuf, pCache, FullReset );
			} else {
				TRACE( "nvram_initialise: performing reset of locked NV-RAM only\n" );

				/* Only ensuring locked locations so start from cache. */
				memcpy( pCache, pbuf, nvram_size );

				/* Iterate through tags and only reset locked values. */
				err = IterateTags( pbuf, pCache, LockedReset );
			}

			/* Compare buffer with cache and make NV-RAM consistent with cache. */
			if ( err == NULL )
			{
				TRACE( "nvram_initialise: making NV-RAM consistent with cache\n" );
				RawConsistent( pbuf, pCache, 0, nvram_size );

				/* If we've done a full reset then reboot the box so that it starts up in a consistent state. */
#if defined ALWAYS_FULL_RESET || defined DONT_REBOOT
				TRACE("I would have RESET!!!!!!\n");
#else
				if ( full_reset ) _swix( OS_Reset, 0 );
#endif
			}

			/* Free temporary cache copy. */
			free( pbuf );
		} else
			err = ERROR(NOMEM);
	} else
		err = ERROR(NOMEM);

	/* Note that if we return an error then nvram_finalise is called and pCache is freed. */
	return err;
}


void
nvram_finalise( void )
{
	/* Free the cache. */
	if ( pCache != NULL )
	{
		free( pCache );
		pCache = NULL;
	}
        msgfile_close( &tags );
        msgfile_close( &msgs );
}


_kernel_oserror *
nvram_get( char *tag, void *buffer, int bufferlen, int *size )
{
        _kernel_oserror *e = NULL;
	location loc;

	char *descbuf = (char *)malloc( TMPBUF_SIZE );
	if ( descbuf == NULL ) return ERROR( NOMEM );

	if ( GetLocation(tag, descbuf, &loc, FALSE) )
	{
		int req_bufsz = (loc.length + loc.start_bit + 7) / 8;

		if ( buffer == 0 )
		{
			/* Buffer pointer is 0 so just return required buffer size. */
                        *size = req_bufsz;
		}
		else
		{
			if ( bufferlen == 0 )
			{
				/* We have a buffer but want to read a value so check this location	*/
				/* fits in a word and assume buffer points to an int.			*/
				if ( loc.length <= 32 )
				{
					/* Read current NVRAM contents into cache in case it's changed	*/
					/* under our feet.						*/
					RawRead( pCache, loc.location, req_bufsz );

					*(int *)(buffer) = ReadValue( pCache, loc.location, loc.start_bit, loc.length );
                                        *size = 4;
				}
				else
                                {
                                        e = ERROR (NEEDBUF);
                                }
			}
			else
			{
				/* We have a buffer and want to read directly into it so check the	*/
				/* buffer size, zero the buffer and do the copy.			*/
				if ( bufferlen >= req_bufsz )
				{
					memset( buffer, 0, bufferlen );

					/* Read current NVRAM contents into cache in case it's changed	*/
					/* under our feet.						*/
					RawRead( pCache, loc.location, req_bufsz );

					/* Destination pointer gets loc.location added so subtract	*/
					/* before calling and we definitely don't want to update the	*/
					/* cache!							*/
					CopyBuffer( pCache, ((char *)buffer) - loc.location, loc.location, loc.start_bit, loc.length, NVRAM_FLAGS_WRITECACHE );
                                        *size = req_bufsz;
				}
				else
                                {
                                        e = ERROR (READBUF);
                                }
			}
		}
	}
	else
        {
                e = ERROR (NOTAG);
        }

	free( descbuf );

        return e;
}


_kernel_oserror *
nvram_set( char *tag, void *buffer, int bufferlen)
{
        _kernel_oserror *e = NULL;
	location loc;
	char *descbuf = (char *)malloc( TMPBUF_SIZE );

	if ( descbuf == NULL ) return ERROR( NOMEM );

	if ( GetLocation( tag, descbuf, &loc, FALSE) )
	{
		if ( loc.flags & LOCATION_FLAGS_LOCKED )
		{
			/* Location is locked so can't be updated. */
                        e = ERROR( LOCKED );
		}
		else
		{
			int req_bufsz = (loc.length + loc.start_bit + 7) / 8;

			if ( bufferlen == 0 )
			{
				/* Read current NVRAM contents into cache in case it's changed	*/
				/* under our feet.						*/
				RawRead( pCache, loc.location, req_bufsz );

				/* Want to write a value so assume data points to an int. */
				WriteValue( pCache, *(unsigned int *)(buffer), loc.location, loc.start_bit, loc.length, NVRAM_FLAGS_WRITETHROUGH );
			}
			else
			{
				/* Have a buffer so copy bits into cache and update NV-RAM but	*/
				/* make sure we don't go past the end of the caller's buffer.	*/
				int length = bufferlen * 8 - loc.start_bit;
				if ( length > loc.length ) length = loc.length;

				/* Read current NVRAM contents into cache in case it's changed	*/
				/* under our feet.						*/
				RawRead( pCache, loc.location, req_bufsz );

	                        CopyBuffer( ((char *)buffer) - loc.location, pCache, loc.location, loc.start_bit,
	                        		length, NVRAM_FLAGS_WRITETHROUGH );
	                }
                }
	}
        else
        {
                e = ERROR( NOTAG );
        }

	free( descbuf );

        return e;
}

_kernel_oserror *
nvram_lookup( char *ptag, unsigned int *startbyte, unsigned int *startbit, unsigned int *length, unsigned int *flagword )
{
        _kernel_oserror *e = NULL;
        location loc;

        char *descbuf = (char *)malloc( TMPBUF_SIZE );
        if ( descbuf == NULL ) return ERROR (NOMEM);

        if ( GetLocation( ptag, descbuf, &loc, TRUE) )
        {
                *startbyte = loc.location;
                *startbit  = loc.start_bit;
                *length    = loc.length;
                *flagword  = loc.flags;
        }
        else
        {
                e = ERROR (NOTAG);
        }

        free( descbuf );

        return e;
}

_kernel_oserror *
nvram_getbytes( char *tag, void *buffer, int bufferlen, int offset, int *size )
{
        /* bufferlen - bytes - how much data we want                            */
        /* offset    - bytes - where to start within tag (0 is the beginning)   */
        /* size      - bytes - return the length                                */

        /* if the tag specified is not byte aligned i.e loc.start_bit!=0 then   */
        /* we complain                                                          */

        _kernel_oserror *e = NULL;
        location loc;

        char *descbuf = (char *)malloc( TMPBUF_SIZE );
        if ( descbuf == NULL ) return ERROR( NOMEM );

        if ( GetLocation(tag, descbuf, &loc, FALSE) )
        {
                if (loc.start_bit == 0)
                {
                        /* make sure we don't run off the end of the tag        */
                        /* need value in bits for CopyBuffer                    */
                        int bit_length = loc.length - (offset * 8);
                        int byte_length;
                        bufferlen = (bufferlen * 8);
                        bit_length = (bufferlen > bit_length) ? bit_length : bufferlen;
                        /* the whole number of bytes needed to store 'bit_length' bits   */
                        byte_length = (bit_length + 7) / 8;

                        if (bit_length > 0)
                        {
                                int where = loc.location + offset;
                                /* Read current NVRAM contents into cache in case it's changed  */
                                /* under our feet.                                              */
                                /* RawRead(buffer, byte start value, byte length                */
                                RawRead( pCache, where, byte_length );

                                /* Destination pointer gets loc.location added so subtract      */
                                /* before calling and we definitely don't want to update the    */
                                /* cache!                                                       */
                                /* CopyBuffer(source buffer, dest buffer, byte start location, start bit, length in bits, flags) */
                                CopyBuffer( pCache, ((char *)buffer) - where, where, 0, bit_length, NVRAM_FLAGS_WRITECACHE );
                        }
                        *size = byte_length;
                }
                else
                {
                        e = ERROR (NOTBYTE);
                }
        }
        else
        {
                e = ERROR (NOTAG);
        }

        free( descbuf );

        return e;
}

_kernel_oserror *
nvram_setbytes( char *tag, void *buffer, int bufferlen, int offset )
{
        _kernel_oserror *e = NULL;
        location loc;
        char *descbuf = (char *)malloc( TMPBUF_SIZE );
        if ( descbuf == NULL ) return ERROR( NOMEM );

        if ( GetLocation( tag, descbuf, &loc, FALSE) )
        {
                if ( loc.flags & LOCATION_FLAGS_LOCKED )
                {
                        /* Location is locked so can't be updated. */
                        e = ERROR( LOCKED );
                }
                else if (loc.start_bit !=0 )
                {
                        /* not byte aligned */
                        e = ERROR( NOTBYTE );
                }
                else
                {
                        /* make sure we don't run off the end of the tag        */
                        /* need value in bits for CopyBuffer                    */
                        int bit_length = loc.length - (offset * 8);
                        int byte_length;
                        bufferlen = bufferlen * 8;
                        bit_length = (bufferlen > bit_length) ? bit_length : bufferlen;

                        /* the whole number of bytes needed to store 'bit_length' bits   */
                        byte_length = (bit_length + 7) / 8;
                        if (byte_length > 0)
                        {
                                int where = loc.location + offset;
                                /* Read current NVRAM contents into cache in case it's changed  */
                                /* under our feet.                                              */
                                /* rjc: this is not required - all we need to do is read first  */
                                /* and last byte (assuming start_bit != 0  also applies to Get  */
                                RawRead( pCache, where, byte_length);

                                CopyBuffer( ((char *)buffer) - where, pCache, where, 0, bit_length, NVRAM_FLAGS_WRITETHROUGH );
                        }
                }
        }
        else
        {
                e = ERROR( NOTAG );
        }

        free( descbuf );

        return e;
}

/* These three wrapper routines are exclusivly to support the very nasty NVRAM_Read and NVRAM_Write
   SWIs which do not return errors in a RISC OS compliant manner.
   They have been replaced by NVRAM_Get and NVRAM_Set respectivly. */

/* Convert an error from a _kernel_oserror to a -ve value in r0 */

static _kernel_oserror *
convert_error(_kernel_oserror *e, int *retvalue)
{
        int errnum = e->errnum &~ ERROR_LOOKUP_BIT;

        if (e && errnum >= ERROR_BASE && errnum <= ERROR_BASE + 0xFF)
        {
                *retvalue = -(errnum - ERROR_BASE);
                e = NULL;
        }

        return e;
}

/* Fake read and write using get and set, for backwards compatibility */

_kernel_oserror *
nvram_read( char *tag, void *buffer, int bufferlen, int *retvalue )
{
        return convert_error(nvram_get(tag, buffer, bufferlen, retvalue), retvalue);
}

_kernel_oserror *
nvram_write( char *tag, void *buffer, int bufferlen, int *retvalue )
{
        *retvalue = 0;
        return convert_error(nvram_set(tag, buffer, bufferlen), retvalue);
}
@


1.7
log
@Added STB5 tags.
Other minor build tweaks.

Version 0.64. Tagged as 'NVRAM-0_64'
@
text
@d53 6
a58 6
ERROR_STRUCT( NOMEM, "NoMem" );
ERROR_STRUCT( NOTAG, "NoTag" );
ERROR_STRUCT( LOCKED, "Locked");
ERROR_STRUCT( READBUF, "ReadBuf");
ERROR_STRUCT( NEEDBUF, "NeedBuf");
ERROR_STRUCT( NOTBYTE, "NotByte");
@


1.6
log
@  Added support for default strings and indirect tags pointing to strings.
  Tidied up indirect tags pointing to integer values.
Detail:
  If the default field is enclosed in quotes it is taken as being a string
   the escape character is currently a forward slash. Any character apart from
   '\0' may be used in the string so in theory any data type could be encoded
   provided it doesn't need a 0 byte anywhere in it. Infact this would be easy
   to fix - the removal of the escape characters could be done as the string
   is copied into the cache buffer so 0 bytes could be escaped.
  When a string is read and temporary buffer is allocated and it's address is
   returned in the value field. To indicate this a bit in the flag word is set
   LOCATION_FLAGS_POINTER - this bit is not useful outside the module but is
   returned by NVRAM_Lookup.

  c/nvram
   FullReset & LockedReset both modified to understand what to do if
 		LOCATION_FLAGS_POINTER is set
   GetLocation now takes an extra argument either TRUE or FALSE that
		is passed to parse_description. This is to signify whether
		or not the caller requires a default value to be looked up
		and returned. This should be FALSE (0) for all normal routines,
		and TRUE for routines involved in reset code.
  c/parse
   parse_description takes an extra argument as described above which is passed
		to GetDefaultValue.
   GetDefaultValue has been heavily modified to understand strings and the
		indirection code is different to cope with strings. It also
		takes a pointer to a flag word (see GetFlags below)
   GetFlags now takes a pointer to the flag word and modifies it so that
		GetDefaultValue can set the LOCATION_FLAGS_POINTER bit
Admin:
  A limited amount of testing has taken place but it needs testing in a real
   situation.
  It seems a bit messy in several places and consideration should be given to
   rewriting those functions which are relevant to reseting the NVRAM and the
   routines in c/parse. Separating these a bit would probably allow a tidier
   implementation of the new functionality in this version.

Version 0.49. Tagged as 'NVRAM-0_49'
@
text
@d42 3
d315 1
a315 1
			TRACE( "LockedReset: setting default value for location &%03X\n" _ ploc->location );
d476 1
a476 1
#ifdef ALWAYS_FULL_RESET
@


1.5
log
@  Added SWI NVRAM_Lookup which takes a pointer to a Tag in r0 on entry
  and returns startbyte within NVRAM (suitable for use with OS_NVMemory)
  in r0, startbit within byte in r1, length in r2 and flags in r3
  Added SWI NVRAM_Set and Get which take the same arguments as Read
  and Write but now return error pointers in r0 an error occurs
  instead of a -ve number.
  Added SWI NVRAM_SetBytes and GetBytes which work like Set/Get but also
  take an offset in r3 that is added to the address of the Tag to allow
  access to part of a Tag without needing to read or write the whole
  thing.

Detail:
  NVRAM_Read and Write used to pass on proper RISC OS errors if an external
  error was generated, but returned a -ve number in r0 if an internal error
  occured.
  NVRAM_Get and Set behave properly and use the error block 0x00819200
  this also means that Set preserves r0 (it used to return 0 for success)
  For compatibility Read and Write have not been removed but are deprecated,
  additionally the new error codes are the positive versions of the old
  error codes (hopefully this will ease converting code to use the new SWIs)
  The Messages file has been seperated from the Tags file and the module can
  return MsgTrans'ed error messages.

Admin:
  Tested all SWIs to a reasonable extent using a softloaded version.

Version 0.48. Tagged as 'NVRAM-0_48'
@
text
@d54 1
d283 28
a310 2
		/* Otherwise set default value (only possible for locations with length <= 32). */
		if ( ploc->length <= 32 )
d312 1
a312 1
			TRACE( "FullReset: setting default value for location &%03X\n" _ ploc->location );
d325 30
a354 2
		/* Set default value (only possible for locations with length <= 32). */
		if ( ploc->length <= 32 )
d368 2
a369 2
static int
GetLocation( char *ptag, char *pdesc, location *ploc )
d374 1
a374 1
        return ( msgfile_lookup( &tags, ptag, pdesc, TMPBUF_SIZE, NULL) != NULL ) ? parse_description( pdesc, ploc, nvram_size ) : 0;
d398 1
a398 1
			if ( GetLocation(tagbuf, descbuf, &loc) )
d515 1
a515 1
	if ( GetLocation(tag, descbuf, &loc) )
d541 1
a541 1
                                        e = ERROR (READBUF);
d589 1
a589 1
	if ( GetLocation( tag, descbuf, &loc) )
d644 1
a644 1
        if ( GetLocation( ptag, descbuf, &loc) )
d677 1
a677 1
        if ( GetLocation(tag, descbuf, &loc) )
d729 1
a729 1
        if ( GetLocation( tag, descbuf, &loc) )
@


1.4
log
@  Added support for default value indirected tags.
Detail:
  * Tags with a default value as a tagname in quotes will use the default
    value from that tag. This will allow certain tags to be programmed
    into the NVRAM at manufacture which are always restored, regardless of
    the configuration of the main tag. This is required
  * For reasons of ease, parts of the decoding process have been reworked;
    with the effect that pointers to register blocks aren't passed around
    now.
Admin:
  Tested locally; needs testing in a full build.
  This feature is needed for Bethany to support a default country, so that
  they will always start in a valid state.

Version 0.45. Tagged as 'NVRAM-0_45'
@
text
@d42 7
d51 4
d225 3
d311 2
d319 1
a319 1
	return ( msgfile_lookup(ptag, pdesc, TMPBUF_SIZE, NULL) != NULL ) ? parse_description( pdesc, ploc, nvram_size ) : 0;
d341 1
a341 1
			err = msgfile_enumerate( "*", tagbuf, TMPBUF_SIZE, &index );
d446 2
a447 1
	msgfile_close();
d452 1
a452 1
nvram_read( char *tag, void *buffer, int bufferlen, int *retvalue )
d454 1
d456 1
a457 1

d467 1
a467 1
			*retvalue = req_bufsz;
d482 1
a482 1
					*retvalue = 4;
d485 3
a487 1
					*retvalue = NVRAM_READ_BUFERR;
d505 1
a505 1
					*retvalue = req_bufsz;
d508 3
a510 1
					*retvalue = NVRAM_READ_BUFERR;
d515 3
a517 1
		*retvalue = NVRAM_READ_TAGERR;
d521 1
a521 1
	return NULL;
d526 1
a526 1
nvram_write( char *tag, void *buffer, int bufferlen, int *retvalue )
d528 1
d539 1
a539 1
			*retvalue = NVRAM_WRITE_LOCKERR;
a567 1
	                *retvalue = 0;	/* Return no error. */
d569 5
a573 2
	} else
		*retvalue = NVRAM_WRITE_TAGERR;
d577 176
a752 1
	return NULL;
@


1.3
log
@Changed to use OS_NVMemory SWIs if available. Crops fields in Tags file to
available NVRAM.
Makefile changed to use Link 5.08.
nvcheck modified to cope with up to 16K of NVRAM.

Version 0.18. Tagged as 'NVRAM-0_18'
@
text
@d31 11
d75 1
d91 1
d98 1
d138 1
d370 3
d374 1
d402 3
d406 1
a406 1
				//TRACE(" I would have RESET!!!!!!\n");
d435 1
a435 1
nvram_read( _kernel_swi_regs *r )
d442 1
a442 1
	if ( GetLocation((char *)r->r[0], descbuf, &loc) )
d446 1
a446 1
		if ( r->r[1] == 0 )
d449 1
a449 1
			r->r[0] = req_bufsz;
d453 1
a453 1
			if ( r->r[2] == 0 )
d456 1
a456 1
				/* fits in a word and assume r->r[1] points to an int.			*/
d463 2
a464 2
					*(int *)(r->r[1]) = ReadValue( pCache, loc.location, loc.start_bit, loc.length );
					r->r[0] = 4;
d467 1
a467 1
					r->r[0] = NVRAM_READ_BUFERR;
d473 1
a473 1
				if ( r->r[2] >= req_bufsz )
d475 1
a475 1
					memset( (char *)r->r[1], 0, r->r[2] );
d484 2
a485 2
					CopyBuffer( pCache, (char *)(r->r[1] - loc.location), loc.location, loc.start_bit, loc.length, NVRAM_FLAGS_WRITECACHE );
					r->r[0] = req_bufsz;
d488 1
a488 1
					r->r[0] = NVRAM_READ_BUFERR;
d493 1
a493 1
		r->r[0] = NVRAM_READ_TAGERR;
d502 1
a502 1
nvram_write( _kernel_swi_regs *r )
d509 1
a509 1
	if ( GetLocation((char *)r->r[0], descbuf, &loc) )
d514 1
a514 1
			r->r[0] = NVRAM_WRITE_LOCKERR;
d520 1
a520 1
			if ( r->r[2] == 0 )
d526 2
a527 2
				/* Want to write a value so assume r->r[1] points to an int. */
				WriteValue( pCache, *(unsigned int *)(r->r[1]), loc.location, loc.start_bit, loc.length, NVRAM_FLAGS_WRITETHROUGH );
d533 1
a533 1
				int length = r->r[2] * 8 - loc.start_bit;
d540 1
a540 1
	                        CopyBuffer( (char *)(r->r[1] - loc.location), pCache, loc.location, loc.start_bit,
d543 1
a543 1
	                r->r[0] = 0;	/* Return no error. */
d546 1
a546 1
		r->r[0] = NVRAM_WRITE_TAGERR;
@


1.2
log
@Bug fix in CopyBuffer().

Version 2.02. Tagged as 'NVRAM-2_02'
@
text
@d35 2
a36 1

d43 15
a57 8
	/* Read and buffer 'count' bytes from NV-RAM starting at location 'byte'. */
	while ( count-- > 0 )
	{
		int value;

		_swix( OS_Byte, _INR(0,1)|_OUT(2), OSBYTE_READCMOS, byte++, &value );
		*pbuf++ = (char)value;
	}
d67 9
a75 2
	while ( count-- > 0 )
		_swix( OS_Byte, _INR(0,2), OSBYTE_WRITECMOS, byte++, *ptmp++ );
d89 1
a89 1
	while ( count-- > 0 )
d91 19
a109 4
		/* Check for differences but don't update checksum byte!! */
		if ( (byte != NVRAM_CHECKSUM_BYTE) && (pnew[byte] != pold[byte]) )
			_swix( OS_Byte, _INR(0,2), OSBYTE_WRITECMOS, byte, pnew[byte] );
		byte++;
d111 10
d135 1
a135 1
	if ( (location < NVRAM_SIZE) && (location + (start_bit + length - 1) / 8 < NVRAM_SIZE) )
d166 1
a166 1
	if ( (location < NVRAM_SIZE) && (location + byte_length - 1 < NVRAM_SIZE) )
d203 1
a203 1
	if ( (location < NVRAM_SIZE) && (location + byte_length <= NVRAM_SIZE) )
d288 1
a288 1
	return ( msgfile_lookup(ptag, pdesc, TMPBUF_SIZE, NULL) != NULL ) ? parse_description( pdesc, ploc ) : 0;
d328 10
d339 1
a339 1
	if ( (pCache = (char *)malloc(NVRAM_SIZE)) != NULL )
d342 1
a342 1
		char *pbuf = (char *)malloc(NVRAM_SIZE);
d352 1
a352 1
			RawRead( pbuf, 0, NVRAM_SIZE );
d362 1
a362 1
				memset( pCache, 0, NVRAM_SIZE );
d370 1
a370 1
				memcpy( pCache, pbuf, NVRAM_SIZE );
d380 1
a380 1
				RawConsistent( pbuf, pCache, 0, NVRAM_SIZE );
d384 1
@


1.1
log
@Initial revision
@
text
@a34 1
static char *pTagBuf, *pDescBuf;
d40 2
d46 1
a46 1
		
d91 2
a92 1
	start_bit &= 7; length = ((length - 1) & 31) + 1;
d98 1
a98 1
	
d116 1
a116 1
WriteValue( char *pbuf, int value, unsigned int location, unsigned int start_bit, unsigned int length, unsigned int flags )
d119 1
a119 1
	
d121 2
a122 1
	start_bit &= 7; length = ((length - 1) & 31) + 1;
d124 1
a124 1
	
d130 1
a130 1
		
d157 3
a159 3
	
	/* Ensure that 'start_bit' and 'length' are reasonable values. */
	start_bit &= 7; length = ((length - 1) & 31) + 1;
d163 1
a163 1
	if ( (location < NVRAM_SIZE) && (location + byte_length - 1 < NVRAM_SIZE) )
d167 13
d208 1
a208 1
		TRACE( "Copying old contents into cache for location &%03X\n" _ ploc->location );
d216 1
a216 1
			TRACE( "Setting default value for location &%03X\n" _ ploc->location );
d232 1
a232 1
			TRACE( "Setting locked value for location &%03X\n" _ ploc->location );
d243 1
a243 1
GetLocation( char *ptag, location *ploc )
d245 1
a245 3
	char *pdesc;

	TRACE( "Looking up tag '%s'\n" _ ptag );
d248 1
a248 2
	pdesc = msgfile_lookup( ptag, pDescBuf, TMPBUF_SIZE, NULL );
	return ( pdesc != NULL ) ? parse_description( pdesc, ploc ) : 0;
d257 5
d263 1
a263 1
	TRACE( "Iterating through Tags file\n" );
d265 4
a268 4
	/* Iterate through Tags file and call 'function' for each tag. */
	while (1)
	{
		location loc;
d270 6
a275 4
		err = msgfile_enumerate( "*", pTagBuf, TMPBUF_SIZE, &index );
		if ( (err != NULL) || (index == 0) ) break;
		if ( GetLocation(pTagBuf, &loc) )
			(*function)( pold, pnew, &loc );
d277 2
d289 1
a289 1
	if ( (pCache = (char *)malloc(NVRAM_SIZE + TMPBUF_SIZE*2)) != NULL )
d294 1
a294 1
		TRACE( "Allocated cache at &%08X\n" _ pCache );
d298 1
a298 4
			/* Set up scratch buffers to avoid malloc/free every time we	*/
			/* look up a tag.						*/
			pTagBuf = pCache + NVRAM_SIZE;
			pDescBuf = pTagBuf + TMPBUF_SIZE;
d301 1
a301 1
			TRACE( "Reading NV-RAM\n" );
d303 5
a307 2
	
			if ( ReadValue(pbuf, NVRAM_LASTRESET_BYTE, NVRAM_LASTRESET_BIT, 1) != 0 )
d309 2
a310 2
				TRACE( "Performing full NV-RAM reset\n" );
	
d313 1
a313 1
	
d317 2
a318 2
				TRACE( "Performing reset of locked NV-RAM only\n" );
				
d321 1
a321 1
	
d325 1
a325 1
	
d329 1
a329 1
				TRACE( "Making NV-RAM consistent with cache\n" );
d331 3
d365 5
a369 2
	
	if ( GetLocation((char *)r->r[0], &loc) )
d386 4
d403 5
d421 3
a423 1
					
d432 5
a436 2
	
	if ( GetLocation((char *)r->r[0], &loc) )
d445 2
d449 4
d454 1
a454 1
				WriteValue( pCache, *(int *)(r->r[1]), loc.location, loc.start_bit, loc.length, NVRAM_FLAGS_WRITETHROUGH );
d460 7
a466 2
				int caller_length = r->r[2] * 8 - loc.start_bit;
				
d468 1
a468 1
	                        		(caller_length < loc.length) ? caller_length : loc.length, NVRAM_FLAGS_WRITETHROUGH );
d474 2
@


1.1.1.1
log
@Initial version.

@
text
@@


1.1.1.2
log
@Fixed bug in RawRead.
@
text
@a40 2
        pbuf += byte;
        
@


1.1.1.3
log
@Fixed silly bug in copying buffers which limited size to  4 bytes.
@
text
@d157 2
a158 2
	/* Ensure that 'start_bit' is a reasonable value. */
	start_bit &= 7;
@


1.1.1.4
log
@Fixed various bugs, including not using isspace when using TinyStubs as
the shared C library doesn't seem to initialise its copy of __ctype.
@
text
@d35 1
d162 1
a162 1
	if ( (location < NVRAM_SIZE) && (location + byte_length <= NVRAM_SIZE) )
d194 1
a194 1
		TRACE( "FullReset: copying old contents into cache for location &%03X\n" _ ploc->location );
d202 1
a202 1
			TRACE( "FullReset: setting default value for location &%03X\n" _ ploc->location );
d218 1
a218 1
			TRACE( "LockedReset: setting locked value for location &%03X\n" _ ploc->location );
d229 1
a229 1
GetLocation( char *ptag, char *pdesc, location *ploc )
d231 3
a233 1
	TRACE( "GetLocation: looking up tag '%s'\n" _ ptag );
d236 2
a237 1
	return ( msgfile_lookup(ptag, pdesc, TMPBUF_SIZE, NULL) != NULL ) ? parse_description( pdesc, ploc ) : 0;
a245 1
	char *tagbuf = (char *)malloc( TMPBUF_SIZE*2 );
d247 4
a250 1
	if ( tagbuf != NULL )
d252 1
a252 8
	  	char *descbuf = tagbuf + TMPBUF_SIZE;

		TRACE( "IterateTags: iterating through Tags file\n" );

		/* Iterate through Tags file and call 'function' for each tag. */
		while (1)
		{
			location loc;
d254 4
a257 6
			err = msgfile_enumerate( "*", tagbuf, TMPBUF_SIZE, &index );
			if ( (err != NULL) || (index == 0) ) break;
			if ( GetLocation(tagbuf, descbuf, &loc) )
				(*function)( pold, pnew, &loc );
		}
		free( tagbuf );
a258 2
	else err = ERROR( NOMEM );

d269 1
a269 1
	if ( (pCache = (char *)malloc(NVRAM_SIZE)) != NULL )
d274 1
a274 1
		TRACE( "nvram_initialise: allocated cache at &%08X\n" _ pCache );
d278 5
d284 1
a284 1
			TRACE( "nvram_initialise: reading NV-RAM\n" );
d289 1
a289 1
				TRACE( "nvram_initialise: performing full NV-RAM reset\n" );
d297 1
a297 1
				TRACE( "nvram_initialise: performing reset of locked NV-RAM only\n" );
d309 1
a309 1
				TRACE( "nvram_initialise: making NV-RAM consistent with cache\n" );
a341 1
	char *descbuf = (char *)malloc( TMPBUF_SIZE );
d343 1
a343 3
	if ( descbuf == NULL ) return ERROR( NOMEM );

	if ( GetLocation((char *)r->r[0], descbuf, &loc) )
a359 4
					/* Read current NVRAM contents into cache in case it's changed	*/
					/* under our feet.						*/
					RawRead( pCache, loc.location, req_bufsz );

a372 5

					/* Read current NVRAM contents into cache in case it's changed	*/
					/* under our feet.						*/
					RawRead( pCache, loc.location, req_bufsz );

d386 1
a386 3

	free( descbuf );
			
d395 2
a396 5
	char *descbuf = (char *)malloc( TMPBUF_SIZE );

	if ( descbuf == NULL ) return ERROR( NOMEM );

	if ( GetLocation((char *)r->r[0], descbuf, &loc) )
a404 2
			int req_bufsz = (loc.length + loc.start_bit + 7) / 8;

a406 4
				/* Read current NVRAM contents into cache in case it's changed	*/
				/* under our feet.						*/
				RawRead( pCache, loc.location, req_bufsz );

d414 2
a415 7
				int length = r->r[2] * 8 - loc.start_bit;
				if ( length > loc.length ) length = loc.length;

				/* Read current NVRAM contents into cache in case it's changed	*/
				/* under our feet.						*/
				RawRead( pCache, loc.location, req_bufsz );

d417 1
a417 1
	                        		length, NVRAM_FLAGS_WRITETHROUGH );
a422 2

	free( descbuf );
@


1.1.1.5
log
@Fixed bug thrown up by development tests.
@
text
@d91 1
a91 2
	start_bit &= 7;
	if ( length > 32 ) length = 32;
d115 1
a115 1
WriteValue( char *pbuf, unsigned int value, unsigned int location, unsigned int start_bit, unsigned int length, unsigned int flags )
d120 1
a120 2
	start_bit &= 7;
	if ( length > 32 ) length = 32;
d431 1
a431 1
				WriteValue( pCache, *(unsigned int *)(r->r[1]), loc.location, loc.start_bit, loc.length, NVRAM_FLAGS_WRITETHROUGH );
@


1.1.1.6
log
@Reboot the box if we do a full NVRAM reset so that it starts up in a
consistent state.
@
text
@a284 2
			int full_reset;

d288 2
a289 5

			/* Determine whether we need to do a full NVRAM reset. */
			full_reset = ReadValue( pbuf, NVRAM_LASTRESET_BYTE, NVRAM_LASTRESET_BIT, 1 );

			if ( full_reset )
a312 3

				/* If we've done a full reset then reboot the box so that it starts up in a consistent state. */
				if ( full_reset ) _swix( OS_Reset, 0 );
@


1.1.1.7
log
@Bug fix applied to function CopyBuffer().  The nature of the bug explains
why it may not have shown up previously.  The culprit was unsigned int
mask = (1 << length) - 1; with attached comment, will be -1 for length
>= 32.  This relies on undefined behaviour (Kelley & Pohl p. 250).  The
ARM produces values other than -1 at length 256 as shown by test code
below.
int i;
for (i = 0; i < 300; i++)
{
     printf("%d->%08x",i,(1<<i)-1);
}
XXX: remaining code ought to be checked for the same mistake.
@
text
@d41 1
a41 1

d46 1
a46 1

d98 1
a98 1

d119 1
a119 1

d124 1
a124 1

d130 1
a130 1

d157 1
a157 1

a166 13
		if (length >= 32)
		{
		 /* Cannot rely on mask being set to -1 as commented above.  If the right operand  */
		 /* of a shift operator is negative or has a value that equals or exceeds the no.  */
		 /* of bits used to represent the left operand, then the behaviour is undefined,   */
		 /* (Kelley & Pohl, p. 250).  On the ARM, 'funny' values start appearing at length */
		 /* == 256.                                                                        */

		 /* XXX: the rest of the code ought to be checked for the same mistake.  Here is   */
		 /* the correction (tested and verified).                                          */

		    mask = ~0; /* FFFFFFFFu, i.e. -1 in unsigned int */
		}
d297 1
a297 1

d300 1
a300 1

d305 1
a305 1

d308 1
a308 1

d312 1
a312 1

d353 1
a353 1

d410 1
a410 1

@

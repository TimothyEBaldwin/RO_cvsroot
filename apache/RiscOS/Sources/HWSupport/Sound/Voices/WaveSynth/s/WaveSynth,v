head	4.14;
access;
symbols
	WaveSynth-1_25:4.14
	WaveSynth-1_24:4.13
	WaveSynth-1_23:4.12
	WaveSynth-1_22:4.11
	WaveSynth-1_21:4.10
	WaveSynth-1_20:4.9
	RO_5_07:4.6
	WaveSynth-1_19:4.6
	WaveSynth-1_18:4.5
	WaveSynth-1_17:4.4
	WaveSynth-1_16:4.3
	WaveSynth-1_15:4.2
	Ursula_merge:4.1.4.1
	nturton_WaveSynth-1_13:4.1
	dcotton_wavesynth_MPTInitialBuild:4.1.7.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.14
date	2016.05.08.17.06.54;	author jlee;	state Exp;
branches;
next	4.13;
commitid	dx7F4YH2ZYCtwH5z;

4.13
date	2015.04.19.15.18.32;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	zMsp2UwaMJ9xidiy;

4.12
date	2014.06.29.10.46.29;	author jlee;	state Exp;
branches;
next	4.11;
commitid	t5k0ZTlsBd19fpGx;

4.11
date	2014.06.28.12.49.34;	author jlee;	state Exp;
branches;
next	4.10;
commitid	A54fGSV55YomXhGx;

4.10
date	2014.06.27.19.48.25;	author jlee;	state Exp;
branches;
next	4.9;
commitid	fkeMfBWnBmG2jcGx;

4.9
date	2014.01.19.14.55.17;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	4pP2yvTKHq8mNJlx;

4.8
date	2014.01.19.14.45.41;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	TxC3kZNfynNDJJlx;

4.7
date	2014.01.19.14.43.25;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	3aSn5oF4f869JJlx;

4.6
date	2004.06.21.12.40.21;	author mhobbs;	state Exp;
branches;
next	4.5;

4.5
date	2001.03.16.16.15.32;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	99.12.08.14.50.59;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.12.02.11.38.46;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.08.16.11.28.47;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.38.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.38.10;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.46.15;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.04.15.08.00.45;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.05.52;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.57.15;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Avoid unnecessary remainder calculations
Detail:
  s/WaveSynth - Avoid unnecessary remainder calculation in DivRem macro
Admin:
  Tested on Cortex-A15


Version 1.25. Tagged as 'WaveSynth-1_25'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     Sound System v3.0 -> <wini>arm.WaveSynth.WaveSynth

;*************************************************
;**                                             **
;**       ARTHUR Sound System Software          **
;**                                             **
;**    MODULE: Sound System WaveTable           **
;**            Library module                   **
;**                                             **
;**    AUTHORS: David Flynn                     **
;**             Tim Dobson                      **
;**                                             **
;**    DESCRIPTION: wavesynth kernels           **
;**                 as voice install library    **
;**                                             **
;**    ENTRIES: Sound System Level1 Voice Entry **
;**                                             **
;*************************************************
; 1.00 EPROM version
; 1.01 0 length duration fixes
; 1.02 stack corruption problem on initialisation
; 1.03 fix update aborts (when voice not currently active)
; 1.04 fix smooth updates
; 1.05 fix RMTIDY problems
; 1.06 fix note off duration
; ---- Released for Arthur 1.20 ----
; 1.06 Modified header GETs so they work again
; 1.07 OSS Internationalisation - also removed null service entry
; 1.08 OSS Carefully reworked to avoid the need for any message lookups.
;          Removed SWI WaveSynth_Load (did nothing) and the ability to
;          load a wavetable file on RMLOADing the module (unused and
;          undocumented).
; 1.09 OSS Put the RMLoad/RMReinit read of wavetable file back in due
;          to user demand - it's documented in Archive magazine vol. 1
;          issue 8, also there are the WaveSynth-Brass and WaveSynth-Organ
;          wavetables. This entailed putting message handling code back in.
; 1.10 SMC Removed comment from Messages file and shortened token.
; 1.11  28 Feb 92  OSS  Changed to register voices with local name.
; 1.12  16 Mar 92  OSS  Now updates local names when Messages RAM loaded.
; 1.13  18 Mar 92  OSS  Fixed "Token not found" error on loading a wavetable
;                       with no local name in initialisation parameters.


        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ModHand
        GET     Hdr:PublicWS
        GET     Hdr:Sound
        GET     Hdr:Proc
        GET     Hdr:MsgTrans
        GET     Hdr:Services
        GET     Hdr:HighFSI

        GET     VersionASM

; Now we can start the module

        AREA |WaveSynth$$Code|, CODE, READONLY, PIC

Module_Base                ; label for calculating offsets
        DCD     0                                       ; not application
        DCD     Initialise_Module  - Module_Base
        DCD     Finalise_Module    - Module_Base
        DCD     Intercept_Services - Module_Base
        DCD     Module_Name        - Module_Base
        DCD     Help_String        - Module_Base
        DCD     0                                       ; no Keywords
        DCD     0                                       ; No SWI chunk base
        DCD     0
        DCD     0
        DCD     0
        DCD     0                                       ; no international messages
      [ :LNOT: No32bitCode
        DCD     Module_Flags       - Module_Base
      ]

Module_Name DCB "WaveSynth", 0

Help_String
        DCB     "WaveSynth"
        DCB     9
        DCB     "$Module_HelpVersion"
        DCB     0
        ALIGN

LoadFailBlock
        DCB     "LoadErr",0                             ; Message token for string printed if file not found
        ALIGN

      [ :LNOT: No32bitCode
Module_Flags
        DCD     ModuleFlag_32bit                        ; 32-bit OK
      ]

; the initialisation :

Initialise_Module Entry "r9-r11", 16    ; MessageTrans file block on stack
        MOV     r11, sp                      ; held in r11
        
        LDR     R2, [R12]     ; check for reinitialisation
        TEQ     R2, #0
        MOVNE   R0, #ModHandReason_Free
        SWINE   XOS_Module   ; Free existing workspace (may need different size)
        EXIT    VS
        
        BL      open_message_file_r11
        ; OSS No error exit - r11 is 0 if open failed and the other message file
        ; functions cope with this.
        
        ; OSS From here on, don't just bomb out to quit - you need to close the
        ; Messages file.

        ; parse env string, discarding leading spaces
15      LDRB    R0,[R10]
        CMP     R0,#" "
        ADDEQ   R10,R10,#1
        BEQ     %BT15

        ; R10 now points to first non-space character in environment string.

        ; check for NULL name string
        LDRB    r0, [r10]
        CMP     r0, #" "
        BLO     %80          ; No file (first char is terminator)

        ; Scan to end of filename
        MOV     r9, r10
15      LDRB    R0,[R9]
        CMP     R0,#" "
        ADDHI   R9,R9,#1
        BHI     %BT15

        ; R9 now points at first char after filename. Check for a space
        LDRB    r0, [r9]
        CMP     r0, #" "
        MOVNE   r9, #0       ; No - there is no local name
        BNE     %FT20
        
        ; discard spaces to get to first char of local name
15      LDRB    R0,[R9]
        CMP     R0,#" "
        ADDEQ   R9,R9,#1
        BEQ     %BT15
        ; R9 now points at the first character of the local voice name. The entire
        ; of the rest of the command line is used - spaces do not terminate this.

20
        MOV     R1,R10               ; point R1 to string
        ; check file
        MOV     R0,#OSFile_ReadInfo
        MOV     R2,#0
        MOV     R3,#0
        SWI     XOS_File
        BVS     %70                  ; Bad file
        CMP     R0,#object_file      ; FILE FOUND?
        BNE     %70                  ; Bad file
        TST     R4,#&FF              ; check multiple of 256 bytes
        BNE     %70                  ; Bad file
        ; allocate according to length (returned in R4)
        LDR     R0,WaveBase
        ADD     R3,R4,R0             ; add on length of code
        MOV     R0, #ModHandReason_Claim
        SWI     XOS_Module
        BVS     wavesynth_init_fail
        
        STR     R2, [R12]
        MOV     R1,R10               ; restore file name
        LDR     R0,WaveBase
        MOV     R3,#0                ; use R2 as load address
        ADD     R2,R2,R0             ; R2 = load address
        ; load file
        MOV     R0,#OSFile_Load
        SWI     XOS_File
        BVS     %60                  ; Failed to load
        ; check header...
        LDR     R3,WaveBase
        LDR     R6,[R12]             ; workspace start to R6
        ADD     R6,R6,R3             ; workspace wavetable offset
        LDR     R0,[R6],#4           ; get wavetable magic word (and R6 to NAME)
        LDR     R1,WaveTable0        ; compare with ROM copy
        CMP     R0,R1                ; check the "!WT:" word
        ; if here and match then valid wavetable, R6 points to name string
        BEQ     CopyWorkSpace
        ; else release this space

60      LDR     R2,[R12]
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
        BVS     wavesynth_init_fail

        ; Come here if file given is no good. r10 -> filename.

70      ADR     r0, LoadFailBlock
        MOV     r1, r10
        BL      gs_lookup_print_string_one_file_r11
        BVS     wavesynth_init_fail

        ; Come here if zero length (ie. no) filename passed.

80      LDR     R3, BeepWorkSpaceSize
        MOV     R0, #ModHandReason_Claim
        SWI     XOS_Module
        BVS     wavesynth_init_fail
        
        STR     R2,[R12]
        MOV     r9, #1                       ; Local name flag to say the lookup
        MOV     R6,#0 ; NO NAME TO COPY        must succeed (we are Beep)
        LDR     R3, AmountToCopy
        ; copy code into our workspace.
        ; voice code MUST be in RAM for speed..
        ; all position independent.
        ; R3 is amount to copy...

CopyWorkSpace
        LDR     R12,[R12]                    ; R12 is the workspace pointer
        ADRL    R0, WorkSpaceImage           ; ROM copy base
CopyLoop
        SUBS    R3, R3, #4                   ; word copy
        LDRPL   R1, [R0, R3]
        STRPL   R1, [r12, R3]
        BPL     CopyLoop
        MOV     R0,#1
        MOV     R1,r12
        LDR     R2,AmountToCopy
        ADD     R2,r12,R2
        SUB     R2,R2,#4
        SWI     XOS_SynchroniseCodeAreas
        CMP     R6,#0
        BEQ     %90
        ADD     R1,r12,#Voice1Name
85      LDRB    R0,[R6],#1                   ; name pointer
        STRB    R0,[R1],#1
        CMP     R0,#0
        BNE     %85
90      ADD     R2,r12,#Voice1               ; WS IS LINK

        CMP     r9, #1                       ; Test if local name (and clear V)
        MOVHI   r0, r9                       ; Use local name.
        BHI     %FT93
        
        ADD     r0, r12, #Voice1Title        ; Lookup title in Messages file.
        BL      lookup_zero_file_r11
        BVC     %FT93                        ; Success!
        
        TEQ     r9, #1                       ; Check if we MUST have local name
        BEQ     wavesynth_init_fail          ; and generate an error if so.
        MOV     r0, #0                       ; No local voice name at all.
93
        MOV     r3, r0                       ; Move local name (0 if no file)
        MOV     R1,#0                        ; force load anywhere
        MOV     r0, #1                       ; install with local voice name
        SWI     XSound_InstallVoice
        BVS     wavesynth_init_fail
        ADD     R0,r12,#Voice1
        CMP     R1,#0                        ; fail?
        STRNE   R1,[R0,#SoundVoiceIndex]
        
        BL      close_message_file_r11
        EXIT

        ; OSS This code is only called when there has been an error - r0 points
        ; to the error block. Any extra errors on the close are ignored.
wavesynth_init_fail
        MOV     r1, r0                       ; Preserve current error
        BL      close_message_file_r11       ; Close the file
        MOV     r0, r1                       ; Get old error back
        SETV                                 ; flag an error
        EXIT


Finalise_Module ROUT
        Push    "lr"
        LDR     R2,[R12]        ; workspace
        ADD     R0,R2,#Voice1   ; WS IS LINK
        LDR     R1,[R0,#SoundVoiceIndex]
        SWI     XSound_RemoveVoice
10      Pull    "lr" ; return - the release is assumed to work correctly!
        ; Note that we can leave the workspace as it is : if this is a fatal entry,
        ; the workspace will be deleted, while for a non-fatal entry, the workspace
        ; will be moved and [R12] updated.
        RETURNVC

; Ursula format service table
UServTab
        DCD     0
        DCD     UService - Module_Base
        DCD     Service_ResourceFSStarted
        DCD     0
        DCD     UServTab - Module_Base
Intercept_Services
        MOV     r0, r0
        TEQ     r1, #Service_ResourceFSStarted
        MOVNE   pc, r14
UService
        ; OSS Update local voice name whenever new files are registered with
        ; ResourceFS.
change_names Entry "r0-r3, r11", 16     ; MessageTrans file block on
        MOV     r11, sp                 ; stack held in r11.
        BL      open_message_file_r11
        EXIT    VS                      ; Give up if no file.

        LDR     r12, [r12]              ; Workspace - points at voices.
        MOV     r2, #0                  ; Required.

        ADD     r0, r12, #Voice1Title   ; Lookup title in Messages file.
        BL      lookup_zero_file_r11
        BVS     %FT10                   ; Skip if no local name.
        ADD     r1, r12, #Voice1
        LDR     r1, [r1, #SoundVoiceIndex]
        MOV     r3, r0                  ; Local name in R3.
        MOV     r0, #3                  ; Change name please.
        TEQ     r1, #0
        SWINE   XSound_InstallVoice     ; Dont change if no voice.
10
        BL      close_message_file_r11  ; OSS Remember to close it!
        EXIT


; now the workspace image : it consists purely of the voice code
; and the reserved table and data segment spaces.

WorkSpaceImage

Start_Of_Code
;**************************************
;*   VOICE CO-ROUTINE CODE SEGMENT    *
;**************************************
; On installation, point Level1 code
; pointer to one of the following voice tables.
;
; ALL CALLS return using PC on top of stack
;
Voice1 * .-WorkSpaceImage
Voice1Base
        B       FillOne
        B       UpdateFillOne
        B       GateOnOne
        B       GateOffOne
        B       Instantiate
        B       Free
        LDMFD   R13!,{PC}       ; dummy entry per PRM 4-13
        DCD     Voice1TitleString - Voice1Base
        DCD     0               ; wavetable size variable
        DCD     0               ; data segmentSSCB index at load time..

Voice1TitleString
        DCB     "WaveSynth-"
Voice1Title * Voice1TitleString-WorkSpaceImage
Voice1NameString
        DCB     "Beep",0,0,0,0,0,0,0,0,0,0,0,0,0
Voice1Name * Voice1NameString-WorkSpaceImage
        ALIGN

;**************************************
;*  VOICE BUFFER FILLS                *
;**************************************
; Fill
; Update
; GateOn
; GateOff
; Entry:
;   R6 -ve if the channel config changed
;   R7 is channel number
;   R8 sample period (µs)
;   R9 is SoundChannelControlBlock
;   R10 DMA buffer limit (+1)
;   R11 DMA buffer interleave increment
;   R12 DMA buffer base pointer
;   R13 Sound System Stack with return address and flags
;       on top of stack
;   NO r14 - IRQs are enabled and r14 cannot be trusted
; Return:
;   R0 flags byte 
FillOne
        ADRL    R8,WaveTable0
        B       Fill
UpdateFillOne
        ADRL    R8,WaveTable0
        LDRB    R0,[R9,#SoundChannelFlagsB]
        LDMIB   R9,{R2-R4}      ; get pitch, timbre, fill counter
        TST     R0,#SoundChannelActive
        BNE     Fill
        B       GateOff
GateOnOne
        ; Calculate scale factor to convert segment durations from the reference
        ; value of 48us to the current sample period
        MOV     R0, #48<<16
        DivRem  R1,R0,R8,R2,norem
        ; Abuse the timbre accumulator to store the result
        STR     R1,[R9,#SoundChannelTimbre]
        ADRL    R8,WaveTable0
        B       GateOn
GateOffOne
        ADRL    R8,WaveTable0
        B       GateOff

        MACRO
        FixDuration
        ; Fix the segment duration value contained in R6, using the scale
        ; factor in R3. Corrupts R0.
        MOV     R0,R6,LSR #9
        MUL     R0,R3,R0
        MOV     R6,R6,LSL #32-9
        ORR     R6,R6,R0,LSR #16
        MOV     R6,R6,ROR #32-9
        MEND

;**************************************
;*  VOICE INSTANTIATE                 *
;**************************************
; Entry:
;   R0 is channel number to instantiate (0-7)
; Return:
;   R0 preserved if success, R0 changed if fail
Instantiate ROUT
        Pull    "pc"

;**************************************
;*  VOICE FREE                        *
;**************************************
; Entry:
;   R0 is channel number to de-instantiate! (0-7)
; Return:
;   R0 preserved ; always works!
Free ROUT
        Pull    "pc"

; table of pitch indexes into WaveStart table
PitchStartMap
        DCB     5
        DCB     5
        DCB     6,6
        DCB     7,7,7,7
        DCB     8,8,8,8,8,8,8,8
        DCB     9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9
        DCB     10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
        DCB     10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
        DCB     11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
        DCB     11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
        DCB     11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
        DCB     11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
        DCB     12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
        DCB     12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
        DCB     12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
        DCB     12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
        DCB     12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
        DCB     12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
        DCB     12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
        DCB     12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12

; hardwired address of the log table
LogAmpPtr
        DCD     SoundLevel1Base + SoundLevel1AmpTable

; fill routines
GateOn ROUT
        STMFD   R13!,{R8,R9}    ; preserve SCCB and the wavetable instance
        LDR     R8,LogAmpPtr    ; volume table
        LDR     R8,[R8]
        LDRB    R1,[R9,#SoundChannelAmpGateB]
        AND     R1,R1,#&7F      ; note amp
        LDRB    R1,[R8,R1,LSL #1] ; get volume scaled amp
        MOV     R1,R1,LSR #1    ; R1 is volume scaled amp (0-127)
        RSB     R1,R1,#127      ; => 0 is max, 127 is min
        LDMIB   R9,{R2-R4}      ; get pitch, timbre, fill counter
        ; determine pitch related start pointer
        MOVS    R0,R2,LSL #18   ; sample rate/4
        ORRCS   R0,R0,#&FF000000 ; if sample rate/2 then force to top
        ADR     R8,PitchStartMap
        LDRB    R0,[R8,R0,LSR #24] ; 8-bit pitch inc
        Pull    "R9"            ; get wavetable descriptor
        LDR     R8,[R9,R0,LSL #2] ; word index the ramp descriptor
        MOV     R8,R8,LSL #3    ; scale to multiple of 8 bytes
        ADD     R0,R9,R8        ; get start ramp
        LDMIA   R0,{R6,R7}
        ; if R7 is zero then exit!
        TEQ     R7,#0           ; should never have null start ramp!
        BEQ     Finished
        FixDuration
        MOV     R0,R7,LSL #16   ; 256-byte segment index
        ADD     R5,R9,R0,LSR #8 ; set wavetable base
        ; R0 is temp
        ; R1 is amp (0-127)
        ; R2 is pitch phase acc
        ;       b31     : unused
        ;       b24-30  : 7 bit magnitude
        ;       b16-23  : phase
        ;       b0-15   : inc for amp.
        ; R3 is segment duration scale factor
        ; R4 is duration
        ; R5 is wavetable base
        ; R6 is N steps
        ; R7 is ptr/segment
        ;       b16-31  : next segment number
        ;       b0-15   : seg wave ptr (DIV 256)
        ; R8 is LogAmpTab/Envelope structure ptr
        ; R9 is data structure base
        MOV     R7,#0
        AND     R0,R6,#&FF
        CMP     R0,#&FF
        ORREQ   R7,R7,#&7F      ; except if full on!
        CMP     R4,#0
        MOVLE   R7,#0
        BLE     GateOffRamp
        B       FillBuffer

GateOff ROUT
        STMFD   R13!,{R8,R9}    ; preserve SCCB and the wavetable instance
        LDR     R8,LogAmpPtr    ; volume table
        LDR     R8,[R8]
        LDRB    R1,[R9,#SoundChannelAmpGateB]
        LDRB    R0,[R9,#SoundChannelFlagsB]
        TST     R0,#SoundChannelActive
        MOVEQ   R1,#0
        AND     R1,R1,#&7F      ; note amp
        MOV     R0,#0
        STR     R0,[R9,#SoundChannelDuration]
        LDRB    R1,[R8,R1,LSL #1]    ; get volume scaled amp
        MOV     R1,R1,LSR #1    ; R1 is volume scaled amp (0-127)
        RSB     R1,R1,#127      ; => 0 is max, 127 is min
        LDMIB   R9,{R2-R7}      ; get regs (should be sensible as on)
        Pull    "R9"            ; get wavetable base
        CMP     R4,#0
        MOVLE   R7,#0

GateOffRamp
        LDR     R8,[R9,#WaveEnd]
        MOV     R8,R8,LSL #3    ; point to segment descriptor
        ;; 5-June-87
        ADD     R0,R9,R8        ; address it
        AND     R5,R7,#&7F      ; preserve amp
        ;; fix
        LDMIA   R0,{R6,R7}      ; get next env. segment
        ; if top and bottom of R7 are zero then exit!
        TEQ     R7,#0
        BEQ     Finished
        FixDuration
        MOV     R0,R7,LSL #16   ; 256-byte segment index
        MOV     R7,R5           ; current amp
        ADD     R5,R9,R0,LSR #8 ; set wavetable base
        B       FillBuffer

Fill ROUT ; taking account of current volume!
        STMFD   R13!,{R8,R9}    ; preserve SCCB and the wavetable instance
        LDR     R8,LogAmpPtr    ; volume table
        LDR     R8,[R8]
        LDRB    R1,[R9,#SoundChannelAmpGateB]
        
        AND     R1,R1,#&7F      ; note amp
        LDRB    R1,[R8,R1,LSL #1] ; get volume scaled amp
        MOV     R1,R1,LSR #1    ; R1 is volume scaled amp (0-127)
        RSB     R1,R1,#127      ; => 0 is max, 127 is min
        LDMIB   R9,{R2-R8}
        
        Pull    "R9"            ; get wavetable base
        CMP     R4,#0
        BEQ     GateOffRamp

FillBuffer
        AND     R0,R7,#&7F
        RSB     R0,R0,#127
        BIC     R1,R1,#&FF000000
        ORR     R1,R1,R1,LSL #24
        ADD     R1,R1,R0,LSL #24 ; low half is volume scaled note amp
FillLoop
Fill0
        TST     R6,#&00000100   ; check for sample(x4) count
        BNE     Fill0A
        SUBS    R6,R6,#&00000200
        BMI     FillTime0
Fill0A
        CMP     R12,R10         ; check for end of buffer
        BGE     FillDone
        ; now the four samples
        LDRB    R0,[R5,R2,LSR #24] ; amplitude modulate the next four samples
        SUBS    R0,R0,R1,LSR #23
        MOVMI   R0,#0
      [ VIDC_Type = "VIDC1"
        ORR     R0,R0,R0,LSL #8
        MOV     R0,R0,LSR #1
      ]
        STRB    R0,[R12],R11
        ADDS    R2,R2,R2,LSL #16
        BCS     Fix1
Fill1
        LDRB    R0,[R5,R2,LSR #24]
        SUBS    R0,R0,R1,LSR #23
        MOVMI   R0,#0
      [ VIDC_Type = "VIDC1"
        ORR     R0,R0,R0,LSL #8
        MOV     R0,R0,LSR #1
      ]
        STRB    R0,[R12],R11
        ADDS    R2,R2,R2,LSL #16
        BCS     Fix2
Fill2
        LDRB    R0,[R5,R2,LSR #24]
        SUBS    R0,R0,R1,LSR #23
        MOVMI   R0,#0
      [ VIDC_Type = "VIDC1"
        ORR     R0,R0,R0,LSL #8
        MOV     R0,R0,LSR #1
      ]
        STRB    R0,[R12],R11
        ADDS    R2,R2,R2,LSL #16
        BCS     Fix3
Fill3
        LDRB    R0,[R5,R2,LSR #24]
        SUBS    R0,R0,R1,LSR #23
        MOVMI   R0,#0
      [ VIDC_Type = "VIDC1"
        ORR     R0,R0,R0,LSL #8
        MOV     R0,R0,LSR #1
      ]
        STRB    R0,[R12],R11
        ADDS    R2,R2,R2,LSL #16
        BCC     FillLoop        ; else fall through..
        
        ; R6 is count
        ; R7 is ptr,segment
        ; R8 is current segment descriptor
        ; R9 is wavetable base pointer
Fix0
        TST     R6,#&00000100   ; check for wave cycle count
        SUBNE   R6,R6,#&00000200
        CMP     R6,#0           ; underflow on time or wavecycles?
        BPL     Fill0
        ADR     R0,Fill0
        B       Advance
Fix1
        TST     R6,#&00000100
        SUBNE   R6,R6,#&00000200
        CMP     R6,#0
        BPL     Fill1
        ADR     R0,Fill1
        B       Advance
Fix2
        TST     R6,#&00000100
        SUBNE   R6,R6,#&00000200
        CMP     R6,#0
        BPL     Fill2
        ADR     R0,Fill2
        B       Advance
Fix3
        TST     R6,#&00000100
        SUBNE   R6,R6,#&00000200
        CMP     R6,#0
        BPL     Fill3
        ADR     R0,Fill3
        B       Advance
FillTime0
        ANDS    R0,R6,#&FF
        BEQ     Fill0A          ; return and wait for wave crossing
        CMP     R0,#&FF
        BEQ     Fill0A          ; return and wait for wave crossing
        TST     R0,#&80
        AND     R0,R0,#&7F      ; mask out direction
        BEQ     FillTimeRampUp
        SUB     R7,R7,#1
        CMP     R7,R0
        MOVLT   R7,R0           ; fix underflow
        BLT     Fill0A          ; return and wait for wave crossing
        B       FillTimeRampAmp
FillTimeRampUp
        ADD     R7,R7,#1
        CMP     R7,R0
        MOVGT   R7,R0           ; return and wait for wave crossing
        BGT     Fill0A
FillTimeRampAmp
        LDR     R6,[R9,R8]      ; get copy of R6 again
        FixDuration
        AND     R0,R7,#&7F
        RSB     R0,R0,#127
        BIC     R1,R1,#&FF000000
        ORR     R1,R1,R1,LSL #24
        ADD     R1,R1,R0,LSL #24 ; low half is volume scaled note amp
        B       Fill0A          ; return

Advance
        Push    "R0"            ; function to call after advancing
        ; check for reason
        ANDS    R0,R6,#&FF
        BEQ     NextSeg
        CMP     R0,#&FF
        BEQ     NextSeg
        TST     R0,#&80
        AND     R0,R0,#&7F      ; mask out direction
        BEQ     RampUp
RampDown
        SUB     R7,R7,#1
        CMP     R7,R0
        BLT     NextSeg
        B       RampAmp
RampUp
        ADD     R7,R7,#1
        CMP     R7,R0
        BGT     NextSeg
RampAmp
        LDR     R6,[R9,R8]      ; get copy of R6 again
        FixDuration
AmpScale
        AND     R0,R7,#&7F
        RSB     R0,R0,#127
        BIC     R1,R1,#&FF000000
        ORR     R1,R1,R1,LSL #24
        ADD     R1,R1,R0,LSL #24 ; low half is volume scaled note amp
        Pull    "pc"
NextSeg
        AND     R5,R6,#&7F      ; save amp (GOAL)
        ADD     R0,R8,#4        ; get word + 4
        LDR     R0,[R9,R0]      ; get ptr/seg descriptor
        MOV     R0,R0,LSR #16   ; extract next descriptor
        MOV     R8,R0,LSL #3    ; make byte index
        ADD     R0,R9,R8        ; address it
        LDMIA   R0,{R6,R7}      ; get next env. segment
        ; if R7 is zero then exit!
        TEQ     R7,#0
        ADDEQ   R13,R13,#4      ; if end then scrap return
        BEQ     Finished
        FixDuration
        MOV     R0,R7,LSL #16   ; 256-byte segment index
        MOV     R7,R5           ; restore amp
        ADD     R5,R9,R0,LSR #8 ; make wavetable base
        AND     R0,R6,#&FF
        CMP     R0,#&FF
        ORREQ   R7,R7,#&7F      ; except if full on!
        B       AmpScale

FillDone
        SUBS    R4,R4,#1        ; dec. duration
        BEQ     GateOffRamp
        MOV     R0,#SoundChannelActive
        Pull    "R9"            ; get SCCB
        STMIB   R9,{R2-R8}      ; R0 is set up
        Pull    "pc"            ; return to level 1

Finished ROUT
        Pull    "R9"            ; get SCCB
        MOV     R2,#0           ; clear phase!
        STMIB   R9,{R2-R8}
        CMP     R12,R10
10      STRLTB  R2,[R12],R11    ; clear remainder of buffer
        CMPLT   R12,R10
        STRLTB  R2,[R12],R11
        CMPLT   R12,R10
        STRLTB  R2,[R12],R11
        CMPLT   R12,R10
        STRLTB  R2,[R12],R11
        CMPLT   R12,R10
        BLT     %10
        MOV     R0,#SoundChannelFlush2
        Pull    "pc"            ; return to level 1

End_Of_Code

WaveTable0
        ; start of header
        DCB     "!WT:"          ; magic id word
WaveNameStart
        DCB     "Beep"
        DCB     0,0,0,0
        DCB     0,0,0,0         ; room for MAX 11-char name + 0 terminator
WaveLen * . - WaveTable0
        DCD     End_Of_WaveTable-WaveTable0   ; total length
WaveStart * . - WaveTable0
        DCD     8,8,8,8,8,8,8,8 ; for 'Beep' all pitches start with descriptor 8
WaveEnd * . - WaveTable0
        DCD     11              ; release ramp ptr
        DCD     0,0             ; padding
        ; end of header
        ASSERT  (. - WaveTable0) = 16*4

; Descriptor format
; --------
; b0-6    : amplitude target for this segment } special value &FF means "fully on
; b7      : ramp direction (1=down)           } with a ramp of 0 gradient"
; b8      : set to count samples rather than completed waves
; b9-b31  : duration of this portion of the ADSR envelope
; --------
; b0-15   : offset from magic word to wave table to use (multiple of 256)
; b16-b31 : next descriptor number
; --------

        ; offset 64 (index 8)
        ; descriptor 8 (ATTACK)
        DCD     &0000007F + 1:SHL:9
        DCD     &00090001
        ; descriptor 9 (DECAY)
        DCD     &000000F0 + 31:SHL:9
        DCD     &000A0001
        ; descriptor 10 (SUSTAIN)
        DCD     &00000080 + 500:SHL:9
        DCD     &000C0001
        ; descriptor 11 (release)
        DCD     &00000080 + 1:SHL:9
        DCD     &000C0001
        ; descriptor 12 (Dead)
        DCD     0
        DCD     0

        % 256 - (. - WaveTable0)

        ; One WaveTable data segment (in VIDC sample format, so bit 0 = sign)
        DCB     &40,&68,&80,&8C,&9A,&A2,&A8,&AE,&B6,&BC,&C0,&C4,&C6,&CA,&CC,&D0
        DCB     &D2,&D4,&D8,&DA,&DE,&E0,&E0,&E2,&E4,&E4,&E6,&E8,&E8,&EA,&EA,&EC
        DCB     &EE,&EE,&F0,&F0,&F2,&F2,&F4,&F4,&F4,&F6,&F6,&F8,&F8,&F8,&FA,&FA
        DCB     &FA,&FC,&FC,&FC,&FC,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE
        DCB     &FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FC,&FC,&FC,&FC,&FA
        DCB     &FA,&FA,&F8,&F8,&F8,&F6,&F6,&F4,&F4,&F4,&F2,&F2,&F0,&F0,&EE,&EE
        DCB     &EC,&EA,&EA,&E8,&E8,&E6,&E4,&E4,&E2,&E0,&E0,&DE,&DA,&D8,&D4,&D2
        DCB     &D0,&CC,&CA,&C6,&C4,&C0,&BC,&B6,&AE,&A8,&A2,&9A,&8C,&80,&68,&40
        DCB     &41,&69,&81,&8D,&9B,&A3,&A9,&AF,&B7,&BD,&C1,&C5,&C7,&CB,&CD,&D1
        DCB     &D3,&D5,&D9,&DB,&DF,&E1,&E1,&E3,&E5,&E5,&E7,&E9,&E9,&EB,&EB,&ED
        DCB     &EF,&EF,&F1,&F1,&F3,&F3,&F5,&F5,&F5,&F7,&F7,&F9,&F9,&F9,&FB,&FB
        DCB     &FB,&FD,&FD,&FD,&FD,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF
        DCB     &FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FD,&FD,&FD,&FD,&FB
        DCB     &FB,&FB,&F9,&F9,&F9,&F7,&F7,&F5,&F5,&F5,&F3,&F3,&F1,&F1,&EF,&EF
        DCB     &ED,&EB,&EB,&E9,&E9,&E7,&E5,&E5,&E3,&E1,&E1,&DF,&DB,&D9,&D5,&D3
        DCB     &D1,&CD,&CB,&C7,&C5,&C1,&BD,&B7,&AF,&A9,&A3,&9B,&8D,&81,&69,&41
End_Of_WaveTable
CopyLimit
        ALIGN
AmountToCopy      DCD CopyLimit - WorkSpaceImage
BeepWorkSpaceSize DCD CopyLimit - WorkSpaceImage
WaveBase          DCD End_Of_Code - WorkSpaceImage

        GET     MsgCode.s

        END
@


4.13
log
@Adjust redundant voice entry
PRM 4-13 says it should be LDMFD, whereas the Pull macro will emit something different for 1 register. Lead by example and use an explicit LDMFD.
Not tested - this entry point hasn't been used for years.

Version 1.24. Tagged as 'WaveSynth-1_24'
@
text
@d404 1
a404 1
        DivRem  R1,R0,R8,R2
@


4.12
log
@More buffer overflow fixes
Detail:
  s/WaveSynth - Although WaveSynth normally outputs samples 4 at a time, the wave table segment can be advanced at any point. If it advances to a valid segment then everything is fine and it will correctly continue from where it left off within a 4-sample block. But if it reaches the end segment then it goes straight to the Finished routine, which assumes a multiple of 4 samples can be written. Fix this by making Finished check for the buffer end before each write.
Admin:
  Tested on BB-xM
  Should hopefully fix the overflow issues this time:
  https://www.riscosopen.org/forum/forums/4/topics/2673?page=1#posts-34085


Version 1.23. Tagged as 'WaveSynth-1_23'
@
text
@d357 1
a357 1
        Pull    "PC"            ; dummy entry per PRM 4-13
@


4.11
log
@Make wave table segment durations take into account current sound configuration
Detail:
  s/WaveSynth - Introduced a new FixDuration macro to adjust the wave table segment duration values to take into account the current sound sample period (stored values are relative to a 48us period). Swap single reg LDM/STM for Pull/Push macros to fix performance warnings from assembler.
Admin:
  Tested on BB-xM
  Beep now sounds correct at highest and lowest sample rates
  Part of the fix for ticket #347:
  https://www.riscosopen.org/tracker/tickets/347


Version 1.22. Tagged as 'WaveSynth-1_22'
@
text
@a756 6
        B       %FT90
10      STRB    R2,[R12],R11    ; clear remainder of buffer
        STRB    R2,[R12],R11
        STRB    R2,[R12],R11
        STRB    R2,[R12],R11
90
d758 8
@


4.10
log
@Fix buffer overflow in Finished code
Detail:
  s/WaveSynth - The main fill routine at Fill0A checks for the end of the buffer before writing any samples, while Finished used to check after writing samples. The wave table pointer is advanced after the samples are written but before Fill0A checks for the end of the buffer, so if the end of the wave table is reached just after the end of the buffer has been reached then the code will branch into Finished and attempt to write past the end of the sound buffer.
Admin:
  Tested on Iyonix
  Should fix issue reported on forums with WaveTable crashing in the Finished routine:
  https://www.riscosopen.org/forum/forums/4/topics/2673


Version 1.21. Tagged as 'WaveSynth-1_21'
@
text
@d357 1
a357 1
        LDMFD   R13!,{PC}       ; dummy entry per PRM 4-13
d401 6
d413 11
d487 1
a487 1
        LDMFD   R13!,{R9}       ; get wavetable descriptor
d495 1
d505 1
a505 1
        ; R3 is timbre phase acc [unused]
d538 1
a538 1
        LDMFD   R13!,{R9}       ; get wavetable base
d553 1
d571 1
a571 1
        LDMFD   R13!,{R9}       ; get wavetable base
d687 1
d716 1
d736 1
d749 1
a749 1
        LDMFD   R13!,{R9}       ; get SCCB
d754 1
a754 1
        LDMFD   R13!,{R9}       ; get SCCB
d757 6
a762 7
        CMP     R12,R10
        BGE     %FT99
        MOV     R0,#0           ; clear remainder of buffer
10      STRB    R0,[R12],R11
        STRB    R0,[R12],R11
        STRB    R0,[R12],R11
        STRB    R0,[R12],R11
a764 1
99
@


4.9
log
@Remove 2 dead wave descriptors
Tested on IOMD, still went beep after the change.

Version 1.20. Tagged as 'WaveSynth-1_20'
@
text
@d735 2
d744 1
@


4.8
log
@Line up to conventional columns, use names from headers, add documentation
Shock addition of some documentation on WaveSynth, thanks to Archive magazine for some of the background from 1988.
@
text
@d759 1
a759 1
        DCD     13              ; release ramp ptr
d782 1
a782 1
        ; descriptor 10 (SUS a)
d784 2
a785 8
        DCD     &000E0001
        ; descriptor 11 (SUS b)
        DCD     &000000DF + 25:SHL:9        ; <-- Not reached. None of the next markers
        DCD     &000A0001                   ; <-- point to 11
        ; descriptor 12 (SUSTAIN)
        DCD     &00000000 + &FFFFF:SHL:9    ; <-- Not reached. None of the next markers
        DCD     &000D0002                   ; <-- point to 12 (and the wave offset is &200!)
        ; descriptor 13 (release)
d787 2
a788 2
        DCD     &000E0001
        ; descriptor 14 (Dead)
@


4.7
log
@Push/pull macros used
@
text
@d58 11
a68 10
 GET Hdr:ListOpts
 GET Hdr:Macros
 GET Hdr:System
 GET Hdr:Machine.<Machine>
 GET Hdr:ModHand
 GET Hdr:PublicWS
 GET Hdr:Sound
 GET Hdr:Proc
 GET Hdr:MsgTrans
 GET Hdr:Services
d70 1
a70 1
 GET VersionASM
d74 1
a74 1
   AREA |WaveSynth$$Code|, CODE, READONLY, PIC
d77 15
a91 15
   &    0                                       ; not application
   &    Initialise_Module  - Module_Base
   &    Finalise_Module    - Module_Base
   &    Intercept_Services - Module_Base
   &    Module_Name        - Module_Base
   &    Help_String        - Module_Base
   &    0                                       ; no Keywords
   &    0                                       ; No SWI chunk base
   &    0
   &    0
   &    0
   &    0                                       ; no international messages
 [ :LNOT: No32bitCode
   &    Module_Flags       - Module_Base
 ]
d96 5
a100 6
   DCB     "WaveSynth"
   DCB     9
   DCB     "$Module_HelpVersion"
   DCB     0
   ALIGN

d103 2
a104 2
   =  "LoadErr",0      ; Message token for string printed if file not found
   ALIGN
d106 1
a106 1
 [ :LNOT: No32bitCode
d108 2
a109 2
   DCD    ModuleFlag_32bit           ; 32-bit OK
 ]
d114 48
a161 48
   MOV     r11, sp                      ; held in r11

   LDR     R2, [R12]     ; check for reinitialisation
   TEQ     R2, #0
   MOVNE   R0, #ModHandReason_Free
   SWINE   XOS_Module   ; Free existing workspace (may need different size)
   EXIT    VS

   BL      open_message_file_r11
; OSS No error exit - r11 is 0 if open failed and the other message file
; functions cope with this.

; OSS From here on, don't just bomb out to quit - you need to close the
; Messages file.

   ; parse env string, discarding leading spaces
15 LDRB    R0,[R10]
   CMP     R0,#" "
   ADDEQ   R10,R10,#1
   BEQ     %BT15

; R10 now points to first non-space character in environment string.

; check for NULL name string
   LDRB    r0, [r10]
   CMP     r0, #" "
   BLO     %80          ; No file (first char is terminator)

   ; Scan to end of filename
   MOV     r9, r10
15 LDRB    R0,[R9]
   CMP     R0,#" "
   ADDHI   R9,R9,#1
   BHI     %BT15

; R9 now points at first char after filename. Check for a space
   LDRB    r0, [r9]
   CMP     r0, #" "
   MOVNE   r9, #0       ; No - there is no local name
   BNE     %FT20

   ; discard spaces to get to first char of local name
15 LDRB    R0,[R9]
   CMP     R0,#" "
   ADDEQ   R9,R9,#1
   BEQ     %BT15
; R9 now points at the first character of the local voice name. The entire
; of the rest of the command line is used - spaces do not terminate this.
d164 65
a228 66
   MOV     R1,R10 ; point R1 to string
; check file
   MOV     R0,#5 ; read cat. info
   MOV     R2,#0
   MOV     R3,#0
   SWI     XOS_File
   BVS     %70                  ; Bad file
   CMP     R0,#1 ; FILE FOUND?
   BNE     %70                  ; Bad file
   TST     R4,#&FF ; check multiple of 256 bytes
   BNE     %70                  ; Bad file
; allocate according to length (returned in R4)
   LDR     R0,WaveBase
   ADD     R3,R4,R0 ; add on length of code
   MOV     R0, #ModHandReason_Claim
   SWI     XOS_Module
   BVS     wavesynth_init_fail

   STR     R2, [R12]
   MOV     R1,R10 ; restore file name
; R2 is load
   LDR     R0,WaveBase
   MOV     R3,#0                ; use R2 as load address
   ADD     R2,R2,R0             ; R2 = load address
; load file
   MOV     R0,#&FF ; load
   SWI     XOS_File
   BVS     %60                  ; Failed to load
; check header...
   LDR     R3,WaveBase
   LDR     R6,[R12]     ; workspace start to R6
   ADD     R6,R6,R3    ; workspace wavetable offset
   LDR     R0,[R6],#4   ; get wavetable magic word (and R6 to NAME)
   LDR     R1,WaveTable0 ; compare with ROM copy
   CMP     R0,R1 ; check the "!WV:" word
; if here and match then valid wavetable, R6 points to name string
   BEQ       CopyWorkSpace
; else release this space

60 LDR     R2,[R12]
   MOV     R0, #ModHandReason_Free
   SWI     XOS_Module
   BVS     wavesynth_init_fail

; Come here if file given is no good. r10 -> filename.

70 ADR     r0, LoadFailBlock
   MOV     r1, r10
   BL      gs_lookup_print_string_one_file_r11
   BVS     wavesynth_init_fail

; Come here if zero length (ie. no) filename passed.

80 LDR     R3, BeepWorkSpaceSize
   MOV     R0, #ModHandReason_Claim
   SWI     XOS_Module
   BVS     wavesynth_init_fail

   STR     R2,[R12]
   MOV     r9, #1                       ; Local name flag to say the lookup
   MOV     R6,#0 ; NO NAME TO COPY        must succeed (we are Beep)
   LDR     R3, AmountToCopy
; copy code into our workspace.
; voice code MUST be in RAM for speed..
; all position independent.
; R3 is amount to copy...
d231 2
a232 2
   LDR     R12,[R12] ; R12 is the workspace pointer
   ADRL    R0, WorkSpaceImage ; ROM copy base
d234 30
a263 30
   SUBS    R3, R3, #4         ; word copy
   LDRPL   R1, [R0, R3]
   STRPL   R1, [r12, R3]
   BPL     CopyLoop
   MOV     R0,#1
   MOV     R1,r12
   LDR     R2,AmountToCopy
   ADD     R2,r12,R2
   SUB     R2,R2,#4
   SWI     XOS_SynchroniseCodeAreas
   CMP     R6,#0
   BEQ     %90
   ADD     R1,r12,#WaveVoiceOffset
85 LDRB    R0,[R6],#1 ; name pointer
   STRB    R0,[R1],#1
   CMP     R0,#0
   BNE     %85
90 ADD     R2,r12,#Voice1 ; WS IS LINK

   CMP     r9, #1                       ; Test if local name (and clear V)
   MOVHI   r0, r9                       ; Use local name.
   BHI     %FT93

   ADD     r0, r12, #Voice1Title        ; Lookup title in Messages file.
   BL      lookup_zero_file_r11
   BVC     %FT93                        ; Success!

   TEQ     r9, #1                       ; Check if we MUST have local name
   BEQ     wavesynth_init_fail          ; and generate an error if so.
   MOV     r0, #0                       ; No local voice name at all.
d265 11
a275 14
   MOV     r3, r0                       ; Move local name (0 if no file)
   MOV     R1,#0 ; force load anywhere
   MOV     r0, #1 ; install with local voice name
   SWI     XSound_InstallVoice
   BVS     wavesynth_init_fail
   ADD     R0,r12,#Voice1
   CMP     R1,#0                                ; fail?
   STRNE   R1,[R0,#SoundVoiceIndex]

   BL      close_message_file_r11
   EXIT

; OSS This code is only called when there has been an error - r0 points
; to the error block. Any extra errors on the close are ignored.
d277 2
d280 5
a284 5
   MOV     r1, r0                       ; Preserve current error
   BL      close_message_file_r11       ; Close the file
   MOV     r0, r1                       ; Get old error back
   SETV                                 ; flag an error
   EXIT
d288 10
a297 13
   Push    "lr"
   LDR     R2,[R12] ; workspace
   ADD     R0,R2,#Voice1 ; WS IS LINK
   LDR     R1,[R0,#SoundVoiceIndex]
   SWI     XSound_RemoveVoice
10 Pull    "lr" ; return - the release is assumed to work correctly!
 ; Note that we can leave the workspace as it is : if this is a fatal entry,
 ; the workspace will be deleted, while for a non-fatal entry, the workspace
 ; will be moved and [R12] updated.
   RETURNVC

 ; end of finalisation code.

d299 1
a299 5
; OSS Update local voice name whenever new files are registered with
; ResourceFS.

;Ursula format
;
d311 2
d344 2
a345 2
; On installation, point Level1 voice
; pointers to these control blocks
a346 6

;**************************************
;*   VOICE CO-ROUTINE CODE SEGMENT    *
;**************************************
; On installation, point Level1 code
; pointer to one of the following voice tables
d351 13
a363 12
   B       FillOne
   B       UpdateFillOne
   B       GateOnOne
   B       GateOffOne
   B       Instantiate
   B       Free
   LDMFD   R13!,{PC}
   &       Voice1TitleString - Voice1Base
   &       0 ; wavetable size variable
   &       0 ; data segmentSSCB index at load time..
;
Voice1TitleString = "WaveSynth-"
d365 25
a389 3
Voice1Name        =  "Beep",0,0,0,0,0,0,0,0,0,0,0,0,0
WaveVoiceOffset * Voice1Name-WorkSpaceImage
  ALIGN
d391 2
a392 2
   ADRL    R8,WaveTable0
   B       Fill
d394 6
a399 6
   ADRL    R8,WaveTable0
   LDRB    R0,[R9,#SoundChannelFlagsB]
   LDMIB   R9,{R2-R4}    ; get pitch, duration, etc
   TST     R0,#SoundChannelActive
   BNE     Fill
   B       GateOff
d401 2
a402 2
   ADRL    R8,WaveTable0
   B       GateOn
d404 2
a405 27
   ADRL    R8,WaveTable0
   B       GateOff

LogAmpPtr & SoundLevel1Base + SoundLevel1AmpTable

; pitch to start segment pointer index!
PitchStartMap
   DCB 5
   DCB 5
   DCB 6,6
   DCB 7,7,7,7
   DCB 8,8,8,8,8,8,8,8
   DCB 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9
   DCB 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
   DCB 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
   DCB 11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
   DCB 11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
   DCB 11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
   DCB 11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
   DCB 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
   DCB 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
   DCB 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
   DCB 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
   DCB 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
   DCB 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
   DCB 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
   DCB 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
d415 1
a415 1
  Pull    "pc"
d425 1
a425 1
  Pull    "pc"
d427 77
d505 18
a522 67
;**************************************
;*
;*  Wavetable TRAVERSAL REGISTERS
;*
;*     16+16 bit phase+inc for amp.
;*       (top 7-bit magnitude)
;*     16+16 bit end + seg wave ptr
;*
; R0 is temp
; R1 is amp (0-127)
; R2 is pitch phase acc
; R3 is timbre phase acc
; R4 is duration
; R5 is wavetable base
; R6 is N steps
; R7 is ptr/segment
; R8 is LogAmpTab/Envelope structure ptr
; R9 is data structure base

;**************************************
;*  VOICE ENTRY CODE SEQUENCES        *
;**************************************
; Fill Entry -
;  The most used and hence reasonably tuned for efficiency
; R7 is channel number
;
; R9 is SoundChannelB base:
; r10 DMA buffer limit (+1)
; r11 DMA buffer interleave increment
; r12 DMA buffer base pointer
; R13 Sound System Stack with return address and flags
;     on top (must LDMFD R13!,{...,pc}
; NO r14 - IRQs are enabled and r14 cannot be trusted

GateOn
   STMFD   R13!,{R8,R9}  ; preserve SDCB and the wavetable instance
   LDR     R8,LogAmpPtr  ; volume table
   LDR     R8,[R8]
   LDRB    R1,[R9,#SoundChannelAmpGateB]
   AND     R1,R1,#&7F    ; note amp
   LDRB    R1,[R8,R1,LSL #1] ; get volume scaled amp
   MOV     R1,R1,LSR #1  ; R1 is volume scaled amp (0-127)
   RSB     R1,R1,#127    ; => 0 is max, 127 is min
   LDMIB   R9,{R2-R4}    ; get pitch, duration, etc
; determine pitch related start pointer
   MOVS    R0,R2,LSL #18    ; sample rate/4
   ORRCS   R0,R0,#&FF000000 ; if sample rate/2 then force to top
   ADR     R8,PitchStartMap
   LDRB    R0,[R8,R0,LSR #24] ; 8-bit pitch inc
   LDMFD   R13!,{R9}         ; get wavetable descriptor
   LDR     R8,[R9,R0,LSL #2] ; word index the ramp descriptor
   MOV     R8,R8,LSL #3      ; scale to multiple of 8 bytes
   ADD     R0,R9,R8          ; get start ramp
   LDMIA   R0,{R6,R7}
; if R7 is zero then exit!
   TEQ     R7,#0             ; should never have null start ramp!
   BEQ     Finished
   MOV     R0,R7,LSL #16     ; 256-byte segment index
   ADD     R5,R9,R0,LSR #8   ; set wavetable base
   MOV     R7,#0
   AND     R0,R6,#&FF
   CMP     R0,#&FF
   ORREQ   R7,R7,#&7F ; except if full on!
   CMP     R4,#0
   MOVLE   R7,#0
   BLE     GateOffRamp
   B       FillBuffer
a523 19
GateOff ROUT
   STMFD   R13!,{R8,R9}  ; preserve SDCB and the wavetable instance
   LDR     R8,LogAmpPtr  ; volume table
   LDR     R8,[R8]
   LDRB    R1,[R9,#SoundChannelAmpGateB]
   LDRB    R0,[R9,#SoundChannelFlagsB]
   TST     R0,#SoundChannelActive
   MOVEQ   R1,#0
   AND     R1,R1,#&7F    ; note amp
   MOV     R0,#0
   STR     R0,[R9,#SoundChannelDuration]
   LDRB    R1,[R8,R1,LSL #1]    ; get volume scaled amp
   MOV     R1,R1,LSR #1  ; R1 is volume scaled amp (0-127)
   RSB     R1,R1,#127    ; => 0 is max, 127 is min
   LDMIB   R9,{R2-R7}    ; get regs (should be sesnsible as on)
   LDMFD   R13!,{R9}     ; get wavetable base
   CMP     R4,#0
   MOVLE   R7,#0
;
d525 14
a538 14
   LDR     R8,[R9,#WaveEnd]
   MOV     R8,R8,LSL #3 ; point to segment descriptor
;; 5-June-87
   ADD     R0,R9,R8      ; address it
   AND     R5,R7,#&7F    ; preserve amp
;; fix
   LDMIA   R0,{R6,R7}    ; get next env. segment
; if top and bottom of R7 are zero then exit!
   TEQ     R7,#0
   BEQ     Finished
   MOV     R0,R7,LSL #16 ; 256-byte segment index
   MOV     R7,R5          ; current amp
   ADD     R5,R9,R0,LSR #8 ; set wavetable base
   B       FillBuffer
d541 15
a555 15
   STMFD   R13!,{R8,R9}  ; preserve SDCB and the wavetable instance
   LDR     R8,LogAmpPtr  ; volume table
   LDR     R8,[R8]
   LDRB    R1,[R9,#SoundChannelAmpGateB]

   AND     R1,R1,#&7F    ; note amp
   LDRB    R1,[R8,R1,LSL #1] ; get volume scaled amp
   MOV     R1,R1,LSR #1  ; R1 is volume scaled amp (0-127)
   RSB     R1,R1,#127    ; => 0 is max, 127 is min
   LDMIB   R9,{R2-R8}
;
   LDMFD   R13!,{R9}     ; get wavetable base
   CMP     R4,#0
   BEQ     GateOffRamp
;
d557 5
a561 5
   AND     R0,R7,#&7F
   RSB     R0,R0,#127
   BIC     R1,R1,#&FF000000
   ORR     R1,R1,R1,LSL #24
   ADD     R1,R1,R0,LSL #24 ; low half is volume scaled note amp
d564 4
a567 4
   TST     R6,#&00000100 ; check for sample(x4) count
   BNE     Fill0A
   SUBS    R6,R6,#&00000200
   BMI     FillTime0
d569 13
a581 13
   CMP     R12,R10       ; check for end of buffer
   BGE     FillDone
; now the four samples
   LDRB    R0,[R5,R2,LSR #24] ; amplitude modulate the next four samples
   SUBS    R0,R0,R1,LSR #23
   MOVMI   R0,#0
 [ VIDC_Type = "VIDC1"
   ORR     R0,R0,R0,LSL #8
   MOV     R0,R0,LSR #1
 ]
   STRB    R0,[R12],R11
   ADDS     R2,R2,R2,LSL #16
   BCS      Fix1
d583 10
a592 10
   LDRB    R0,[R5,R2,LSR #24]
   SUBS    R0,R0,R1,LSR #23
   MOVMI   R0,#0
 [ VIDC_Type = "VIDC1"
   ORR     R0,R0,R0,LSL #8
   MOV     R0,R0,LSR #1
 ]
   STRB    R0,[R12],R11
   ADDS     R2,R2,R2,LSL #16
   BCS      Fix2
d594 10
a603 10
   LDRB    R0,[R5,R2,LSR #24]
   SUBS    R0,R0,R1,LSR #23
   MOVMI   R0,#0
 [ VIDC_Type = "VIDC1"
   ORR     R0,R0,R0,LSL #8
   MOV     R0,R0,LSR #1
 ]
   STRB    R0,[R12],R11
   ADDS     R2,R2,R2,LSL #16
   BCS      Fix3
d605 15
a619 14
   LDRB    R0,[R5,R2,LSR #24]
   SUBS    R0,R0,R1,LSR #23
   MOVMI   R0,#0
 [ VIDC_Type = "VIDC1"
   ORR     R0,R0,R0,LSL #8
   MOV     R0,R0,LSR #1
 ]
   STRB    R0,[R12],R11
   ADDS     R2,R2,R2,LSL #16
   BCC      FillLoop ; else fall through..
; R6 is count
; R7 is ptr,segment
; R8 is current segment descriptor
; R9 is wavetable base pointer
d621 6
a626 6
   TST     R6,#&00000100 ; check for wave cycle count
   SUBNE   R6,R6,#&00000200
   CMP     R6,#0 ; underflow on time or wavecycles?
   BPL     Fill0
   ADR     R0,Fill0
   B       Advance
d628 6
a633 6
   TST     R6,#&00000100
   SUBNE   R6,R6,#&00000200
   CMP     R6,#0
   BPL     Fill1
   ADR     R0,Fill1
   B       Advance
d635 6
a640 6
   TST     R6,#&00000100
   SUBNE   R6,R6,#&00000200
   CMP     R6,#0
   BPL     Fill2
   ADR     R0,Fill2
   B       Advance
d642 6
a647 6
   TST     R6,#&00000100
   SUBNE   R6,R6,#&00000200
   CMP     R6,#0
   BPL     Fill3
   ADR     R0,Fill3
   B       Advance
d649 12
a660 12
   ANDS    R0,R6,#&FF
   BEQ     Fill0A ; return and wait for wave crossing
   CMP     R0,#&FF
   BEQ     Fill0A ; return and wait for wave crossing
   TST     R0,#&80
   AND     R0,R0,#&7F ; mask out direction
   BEQ     FillTimeRampUp
   SUB     R7,R7,#1
   CMP     R7,R0
   MOVLT   R7,R0 ; fix underflow
   BLT     Fill0A ; return and wait for wave crossing
   B       FillTimeRampAmp
d662 4
a665 4
   ADD     R7,R7,#1
   CMP     R7,R0
   MOVGT   R7,R0 ; return and wait for wave crossing
   BGT     Fill0A
d667 8
a674 8
   LDR     R6,[R9,R8]    ; get copy of R6 again
   AND     R0,R7,#&7F
   RSB     R0,R0,#127
   BIC     R1,R1,#&FF000000
   ORR     R1,R1,R1,LSL #24
   ADD     R1,R1,R0,LSL #24 ; low half is volume scaled note amp
   B       Fill0A ; return
;
d676 9
a684 9
   Push    "R0"            ; function to call after advancing
; check for reason
   ANDS    R0,R6,#&FF
   BEQ     NextSeg
   CMP     R0,#&FF
   BEQ     NextSeg
   TST     R0,#&80
   AND     R0,R0,#&7F ; mask out direction
   BEQ     RampUp
d686 4
a689 4
   SUB     R7,R7,#1
   CMP     R7,R0
   BLT     NextSeg
   B       RampAmp
d691 3
a693 3
   ADD     R7,R7,#1
   CMP     R7,R0
   BGT     NextSeg
d695 1
a695 1
   LDR     R6,[R9,R8]    ; get copy of R6 again
d697 6
a702 6
   AND     R0,R7,#&7F
   RSB     R0,R0,#127
   BIC     R1,R1,#&FF000000
   ORR     R1,R1,R1,LSL #24
   ADD     R1,R1,R0,LSL #24 ; low half is volume scaled note amp
   Pull    "pc"
d704 18
a721 18
   AND     R5,R6,#&7F    ; save amp (GOAL)
   ADD     R0,R8,#4      ; get word + 4
   LDR     R0,[R9,R0]    ; get ptr/seg descriptor
   MOV     R0,R0,LSR #16 ; extract next descriptor
   MOV     R8,R0,LSL #3  ; make byte index
   ADD     R0,R9,R8      ; address it
   LDMIA   R0,{R6,R7}    ; get next env. segment
; if R7 is zero then exit!
   TEQ     R7,#0
   ADDEQ   R13,R13,#4      ; if end then scrap return
   BEQ     Finished
   MOV     R0,R7,LSL #16 ; 256-byte segment index
   MOV     R7,R5         ; restore amp
   ADD     R5,R9,R0,LSR #8 ; make wavetable base
   AND     R0,R6,#&FF
   CMP     R0,#&FF
   ORREQ   R7,R7,#&7F ; except if full on!
   B       AmpScale
d724 6
a729 6
   SUBS    R4,R4,#1      ; dec. duration
   BEQ     GateOffRamp
   MOV     R0,#SoundChannelActive
   LDMFD   R13!,{R9}  ; get sccb
   STMIB   R9,{R2-R8}    ; R0 is set up
   Pull    "pc"            ; return to level 1
d732 13
a744 13
   LDMFD   R13!,{R9}
   MOV     R2,#0         ; clear phase!
   STMIB   R9,{R2-R8}
   MOV     R0,#0         ; clear remainder of buffer
10 STRB    R0,[R12],R11
   STRB    R0,[R12],R11
   STRB    R0,[R12],R11
   STRB    R0,[R12],R11
   CMP     R12,R10
   BLT     %10
   MOV     R0,#SoundChannelFlush2
   Pull    "pc"            ; return to level 1
;
d748 2
a749 2
; header
 = "!WT:" ; magic id word
d751 3
a753 3
 = "Beep"
 = 0,0,0,0
 = 0,0,0,0 ; room for MAX 11-char name + 0C terminator
d755 1
a755 1
   DCD   End_Of_WaveTable-WaveTable0   ; total length
d757 60
a816 50
   DCD   8,8,8,8,8,8,8,8 ; eight pitch related entries!
WaveEnd   * . - WaveTable0
   DCD   13  ; end ptr
   DCD 0,0
; end of 16 words header...

; offset 64 (index 8)
; descriptor 8 (ATTACK)
 DCD &0000007F + 1:SHL:9
 DCD &00090001
; descriptor 9 (DECAY)
 DCD &000000F0 + 31:SHL:9
 DCD &000A0001
; descriptor 10 (SUS a)
 DCD &00000080 + 500:SHL:9
 DCD &000E0001
; descriptor 11 (SUS b)
 DCD &000000DF + 25:SHL:9
 DCD &000A0001
; descriptor 12 (SUSTAIN)
 DCD &00000000 + &FFFFF:SHL:9
 DCD &000D0002
; descriptor 13 (release)
; descriptor 9 (DECAY)
 DCD &00000080 + 1:SHL:9
 DCD &000E0001
; descriptor 14 (Dead)
 DCD 0
 DCD 0

 % 256 - (. - WaveTable0)

;REM WaveGen output
; One WaveTable data segment
 DCB &40,&68,&80,&8C,&9A,&A2,&A8,&AE,&B6,&BC,&C0,&C4,&C6,&CA,&CC,&D0
 DCB &D2,&D4,&D8,&DA,&DE,&E0,&E0,&E2,&E4,&E4,&E6,&E8,&E8,&EA,&EA,&EC
 DCB &EE,&EE,&F0,&F0,&F2,&F2,&F4,&F4,&F4,&F6,&F6,&F8,&F8,&F8,&FA,&FA
 DCB &FA,&FC,&FC,&FC,&FC,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE
 DCB &FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FE,&FC,&FC,&FC,&FC,&FA
 DCB &FA,&FA,&F8,&F8,&F8,&F6,&F6,&F4,&F4,&F4,&F2,&F2,&F0,&F0,&EE,&EE
 DCB &EC,&EA,&EA,&E8,&E8,&E6,&E4,&E4,&E2,&E0,&E0,&DE,&DA,&D8,&D4,&D2
 DCB &D0,&CC,&CA,&C6,&C4,&C0,&BC,&B6,&AE,&A8,&A2,&9A,&8C,&80,&68,&40
 DCB &41,&69,&81,&8D,&9B,&A3,&A9,&AF,&B7,&BD,&C1,&C5,&C7,&CB,&CD,&D1
 DCB &D3,&D5,&D9,&DB,&DF,&E1,&E1,&E3,&E5,&E5,&E7,&E9,&E9,&EB,&EB,&ED
 DCB &EF,&EF,&F1,&F1,&F3,&F3,&F5,&F5,&F5,&F7,&F7,&F9,&F9,&F9,&FB,&FB
 DCB &FB,&FD,&FD,&FD,&FD,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF
 DCB &FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FF,&FD,&FD,&FD,&FD,&FB
 DCB &FB,&FB,&F9,&F9,&F9,&F7,&F7,&F5,&F5,&F5,&F3,&F3,&F1,&F1,&EF,&EF
 DCB &ED,&EB,&EB,&E9,&E9,&E7,&E5,&E5,&E3,&E1,&E1,&DF,&DB,&D9,&D5,&D3
 DCB &D1,&CD,&CB,&C7,&C5,&C1,&BD,&B7,&AF,&A9,&A3,&9B,&8D,&81,&69,&41
d819 4
a822 4
 ALIGN
AmountToCopy      & CopyLimit - WorkSpaceImage
BeepWorkSpaceSize & CopyLimit - WorkSpaceImage;
WaveBase          & End_Of_Code - WorkSpaceImage
d824 1
a824 1
 GET s.MsgCode
d826 1
a826 1
 END
@


4.6
log
@  Adapted for DB220.
Detail:
  Files modified: s.WaveSynth
Admin:
  Updated from Kev's machine.

Version 1.19. Tagged as 'WaveSynth-1_19'
@
text
@a58 1
 OPT OptNoList
a69 2
 OPT OptList
 OPT OptPage
a168 2
   MOV     R4,#0
   MOV     R5,#0
d186 2
a187 1
   ADD     R2,R2,R0
a189 3
   MOV     R3,#0
   MOV     R4,#0
   MOV     R5,#0
d290 1
a290 1
   STMFD   R13!,{R14}
d295 1
a295 3
10 LDMFD   R13!,{R14} ; return - the release is assumed to work correctly!
   RETURNVC

d299 1
d430 1
a430 1
   LDMFD R13!,{PC}
d440 1
a440 1
   LDMFD R13!,{PC}
a663 1
;;   BICLT   R6,R6,#&FF ; make don't change AMP
a669 1
;;   BICGT   R6,R6,#&FF ; make don't change AMP
d681 1
a682 1
   STMFD   R13!,{R0}
d707 1
a707 1
   LDMFD   R13!,{PC}
d718 1
a718 1
   LDMEQFD R13!,{R0}     ; if end then scrap return
d734 1
a734 1
   LDMFD   R13!,{PC}     ; return to level 1
d748 1
a748 1
   LDMFD   R13!,{PC} ; return to level 1
@


4.5
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 1.18. Tagged as 'WaveSynth-1_18'
@
text
@d246 6
@


4.4
log
@  32-bit compatibility improved to only declare itself as 32-bit if
    the build was 32-bit.
Detail:
  Code updated to use macros from HdrSrc for mode changing and IRQ
    state updates.
Admin:
  Tested 26-bit and 32-bit builds on Risc PC by pressing ^G to generate
    the system beep, Maestro to play several sounds concurrently, and
    Replay to play audio files.

Version 1.17. Tagged as 'WaveSynth-1_17'
@
text
@d76 1
a76 1
   LEADR Module_LoadAddr    ; give output the right addresses
d100 1
a100 4
   DCB     "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
   DCB     " $Module_MinorVersion"
 ]
d111 1
a111 1
   DCD     1           ; 32-bit OK
d116 1
a116 1
Initialise_Module ENTRY "r9-r11", 16    ; MessageTrans file block on stack
d322 1
a322 1
change_names ENTRY "r0-r3, r11", 16     ; MessageTrans file block on
@


4.3
log
@  32-bit compatible module.
Detail:
  Voice code was already OK, just module header tidying up.
Admin:
  Built.

Version 1.16. Tagged as 'WaveSynth-1_16'
@
text
@a62 1
 GET Hdr:APCS.<APCS>
d91 1
d93 1
d112 1
d115 1
@


4.2
log
@Spinner and Ursula branches merged.
Changed to use srccommit.

Version 1.15. Tagged as 'WaveSynth-1_15'
@
text
@d63 1
a65 1
; GET Hdr:File
d88 5
d111 2
d297 1
a297 1
   BICS    PC,R14,#V_bit
d320 1
a320 1
        MOVNES  pc, r14
d325 1
a325 1
        EXITS   VS                      ; Give up if no file.
d341 1
a341 1
        EXITS
@


4.1
log
@Initial revision
@
text
@d71 1
a71 1
 GET Version
d94 5
a98 1
   DCB     "$Version ($CurrentDate)", 0
d292 1
a292 1
 ; Note that we can leave the workspace as it is : if this is a fatal entry, 
d302 8
d311 1
d314 1
a314 1

d372 1
a372 1
Voice1Name        =  "Beep",0,0,0,0,0,0,0,0,0,0,0,0,0 
d463 1
a463 1
; 
d474 1
a474 1
   LDR     R8,LogAmpPtr  ; volume table 
d508 1
a508 1
   LDR     R8,LogAmpPtr  ; volume table 
d543 1
a543 1
   LDR     R8,LogAmpPtr  ; volume table 
d617 1
a617 1
; R7 is ptr,segment   
d631 1
a631 1
   BPL     Fill1     
d746 1
a746 1
; 
@


4.1.4.1
log
@update to Ursula service format
@
text
@a297 8
;Ursula format
;
UServTab
        DCD     0
        DCD     UService - Module_Base
        DCD     Service_ResourceFSStarted
        DCD     0
        DCD     UServTab - Module_Base
a298 1
        MOV     r0, r0
d301 1
a301 1
UService
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	1.24;
access;
symbols
	Sound0HAL-1_88:1.24
	Sound0HAL-1_87:1.23
	Sound0HAL-1_86:1.22
	Sound0HAL-1_85:1.21
	Sound0HAL-1_84:1.20
	Sound0HAL-1_83:1.19
	Sound0HAL-1_82:1.18
	Sound0HAL-1_81:1.17
	Sound0HAL-1_80:1.15
	Sound0HAL-1_79:1.13
	Sound0HAL-1_78:1.12
	Sound0HAL-1_77:1.11
	Sound0HAL-1_76:1.11
	Sound0HAL-1_75:1.11
	Sound0HAL-1_74:1.10
	Sound0HAL-1_73:1.9
	Sound0HAL-1_72:1.8
	Sound0HAL-1_71:1.7
	Sound0HAL-1_70:1.6
	Sound0HAL-1_69:1.5
	Sound0HAL-1_68:1.3
	Sound0HAL-1_67:1.3
	Sound0HAL-1_66:1.2
	Sound0HAL-1_65:1.1;
locks; strict;
comment	@# @;


1.24
date	2018.08.04.10.07.48;	author jlee;	state Exp;
branches;
next	1.23;
commitid	Z9HHvHtwQqhvUMMA;

1.23
date	2018.08.01.13.04.07;	author jballance;	state Exp;
branches;
next	1.22;
commitid	SUhFPynXLvHWYpMA;

1.22
date	2018.05.13.22.11.19;	author jballance;	state Exp;
branches;
next	1.21;
commitid	W85PFLqtRoB7AbCA;

1.21
date	2016.06.12.18.59.01;	author jlee;	state Exp;
branches;
next	1.20;
commitid	ydpFRyvqARbb1daz;

1.20
date	2016.06.08.21.32.27;	author jlee;	state Exp;
branches;
next	1.19;
commitid	l1TutttNkbdKZH9z;

1.19
date	2016.05.08.17.02.23;	author jlee;	state Exp;
branches;
next	1.18;
commitid	ZsfEiqtsy8cVuH5z;

1.18
date	2016.02.12.20.34.58;	author jlee;	state Exp;
branches;
next	1.17;
commitid	uo3b2HjkNE3drFUy;

1.17
date	2015.12.02.20.36.12;	author jlee;	state Exp;
branches;
next	1.16;
commitid	ZScC26sAEsbaLpLy;

1.16
date	2015.12.01.20.48.02;	author jlee;	state Exp;
branches;
next	1.15;
commitid	oU5pl7g7AqO7RhLy;

1.15
date	2015.04.06.09.02.18;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	tNSsBtgkILwoDvgy;

1.14
date	2015.04.06.09.00.37;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	PyFQBqFap0bpCvgy;

1.13
date	2015.03.28.20.41.21;	author jlee;	state Exp;
branches;
next	1.12;
commitid	hRgEm2L5aeF8Npfy;

1.12
date	2014.09.15.19.24.41;	author jlee;	state Exp;
branches;
next	1.11;
commitid	ryoQhqlvFaOsBtQx;

1.11
date	2012.11.09.20.37.18;	author jlee;	state Exp;
branches;
next	1.10;
commitid	I5DKP7b2lH7AHJrw;

1.10
date	2012.09.22.00.10.29;	author jlee;	state Exp;
branches;
next	1.9;
commitid	fVF7pm6B3dJnsslw;

1.9
date	2012.08.20.18.17.39;	author jlee;	state Exp;
branches;
next	1.8;
commitid	12G891KCllj5xjhw;

1.8
date	2012.08.19.15.35.17;	author jlee;	state Exp;
branches;
next	1.7;
commitid	SJvkSXa8ODNoFahw;

1.7
date	2012.08.14.23.38.12;	author jlee;	state Exp;
branches;
next	1.6;
commitid	XmeKVINrv8U0vzgw;

1.6
date	2012.04.05.22.23.30;	author jlee;	state Exp;
branches;
next	1.5;
commitid	0wqCmK2fpUktiJZv;

1.5
date	2012.04.01.13.39.34;	author jlee;	state Exp;
branches;
next	1.4;
commitid	C3ckiuHfS7XIwaZv;

1.4
date	2012.03.24.23.00.33;	author jlee;	state Exp;
branches;
next	1.3;
commitid	CADwVz3oWer3TbYv;

1.3
date	2010.02.28.16.02.19;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.16.19.57.20;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.16.03.53.51;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Allow module initialisation to succeed if there is no audio device present
Detail:
  Since we can cope with audio devices dynamically being added and removed once initialisation is complete, it seems sensible to also cope with the situation where no devices are available on startup.
  s/Sound0 - Rearrange Initialise_Module so that if no device is found on startup, the initial state of the module will be the same as if a device had been found but then went missing: configuration SWIs will continue to function, the next device to appear will automatically be selected as the active device (with sound automatically turning on), and manual Sound_Enable calls will produce an error saying no device is present. These changes should also allow the module to cope with situations where other support modules like DMAManager, RTSupport, or VFPSupport are (temporarily) unavailable on startup.
Admin:
  Tested on iMX6


Version 1.88. Tagged as 'Sound0HAL-1_88'
@
text
@; Copyright 2010 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     Sound System v3.0 -> <wini>arm.Sound0.Sound0

; *************************************************
; **                                             **
; **       ARTHUR Sound System Software          **
; **                                             **
; **    MODULE: SoundDMAHandler                  **
; **            Level0 Sound System Module       **
; **                                             **
; **    AUTHORS: David Flynn (alas, no more)     **
; **             Stuart Swales (ditto)           **
; **             Tim Dobson                      **
; **             Mark Taunton                    **
; **                                             **
; **    DESCRIPTION: all the privileged access   **
; **            to hardware/physical addresses   **
; **                                             **
; **    ENTRIES: IRQ  from Sound Buffer IRQ      **
; **             SWIs for system level interface **
; **             CLI  commands interface         **
; **                                             **
; *************************************************

; 1.05  EPROM release
; 1.06  Change help messages to add full stops
; 1.07  prevent ROM code linking to vector twice!
; 1.08  fix ROUT bug which corrupted Overrun fix
; 1.09  Service call reset IRQ problem...
; 1.10  Stereo help text fix
; 1.11  Tokenise help. SKS. Was looping freeing in death, not necessary
;       shorter exit sequences with {pc}^. Common error exits. Silly error
;       from irq claim failure. New irq scheme makes shorter + sexier
;       moved audio bug fix to proper place
;       Use spare registers in SWI handler
; 1.12  Fixed more places where IRQ could get in
; 1.13  Pass SoundLevel0Base around - a useful constant indeed!
;       Fixed RESET disabling sound problem. IRQ code neater, faster
; 1.14  Stereo can take optional '+' sign, does services
; 1.15  Had to take out overrun capability as it was much too dangerous
; ---- Released for Arthur 2.00 ----
; 1.16  Added code to cope with Fox VIDC clock speed adjustment
;       Modified header GETs so they work again
; 1.17  Internationalised
; 1.18  OSS  Added assemble time code for A500 which modifies the DMA
;            buffer for VIDC1 (rather than VIDC1a). Code courtesy of JRoach.
; 1.20  01 Mar 92  OSS  Changed to execute A500 buffer modify code in RAM to
;                       minimise the chance of overruns.
; 1.21  07-Aug-92  TMD  Re-added MEMC2 option
; 1.22  27-Aug-92  TMD  Put in VIDC20 option
; 1.23  16-Feb-93  TMD  Corrected for rotation of stereo image registers on VIDC20
; 1.24  25-May-93  MT   Added IOMD support; also conditionals (defined in xxHdr
;                       file) to handle loudspeaker on/off control (SpkControl)
;                       and sound clock frequency variation with video mode
;                       (VarSndClock). Older machines have both: Medusa has
;                       neither.
; 1.25  02-Jul-93  MT   Sound0Hack flag (defined in JordanHdr) now
;                       checked when assembling IOMD version, to avoid
;                       use of OS_Memory (not yet available), and
;                       OS_ClaimDeviceVector with IOMD DMA channels as
;                       devices (since that is also not yet ready).
;                       We use privileged knowledge about kernel's
;                       memory addressing variables to circumvent the
;                       first problem, and IrqV instead of the real
;                       IRQ vector, for the second.
; 1.26  09-Jul-93  TMD  Fix stack imbalance in unknown IRQ code.
; 1.27  15-Jul-93  JSR  Switch to new headers system.
; 1.28  06-Aug-93  MT   Fix bug in IOMD code where overrun (e.g. when
;                       interrupts were disabled for more than a
;                       buffer time) caused system lockup because of
;                       failure to program the correct buffer.
; 1.29  06-Aug-93  MT   No software change - merely getting version number
;                       right here.
; 1.30  11-Aug-93  MT   Fix handling of service call (bug MED-00362)
; 1.31  11-Aug-93  MT   Add the above line and this one, forgotten before (no
;                       code change).
; 1.32  26-Aug-93  OL   Libra mods: International_Help bit set for *audio,
;                       *speaker, *stereo. (These log lines added by MT.)
; 1.33  02-Sep-93  MT   Turned off Sound0Hack (no longer needed, but left in
;                       source for now); fixed stack imbalance bug in code for
;                       exit on XOS_Memory failure; added log entry for 1.32.
; 1.34  05-Oct-93  MT   Corrected flags to XOS_Memory, to fix bug MED-00621.
; 1.35  11-Nov-93  JSR  Fix MED-00820 - fix international help for *Stereo command.
;                       Install, but leave disabled, sound quenching code to quieten
;                       the quiet bits.
; 1.36  14-Feb-94  TMD  Fix MED-02859 - don't call InitResetCommon on Service_Reset
;                       unless it's a soft reset.
; 1.37  30-Jun-94  MT   Removed Sound0Hack, no longer needed, and JSR's sound quenching
;                       code - newer hardware fixes this `properly'.  Major surgery
;                       throughout, to support 16-bit output (set up by CMOS config).
; 1.38  12-Jul-94  MT   Fix problem with Sound_SampleRate setting new rate without VIDC
;                       programming offset of 2.  Also cure duff error on bad param.
; 1.40  18-Oct-94  RCM  Add power saving calls for Stork see 'StorkPower'.
; 1.41  21-Oct-94  SMC  Fixed bug in level0 fill where code could ask for more than would
;                       be played.
;                       Fixed MIN-00087 - Sound_Configure code allowed buffer size to be set
;                       too large for 16bit sound. Also WorkOutVIDCParams called process_oversample
;                       which used the OLD buffer size to determine whether to oversample rather than
;                       the new one given in the SWI call.
;                       Fixed MIN-00022 - Added *Configure SoundSystem for 8bit/16bit sound.
;
; ********************  See SrcFiler log file for changes since version 1.41.
;
; 1.53 14-Apr-97  MT    Merge in changes for StrongARM compatibility, mono output and
;                       oversampling performance improvement.  Change default sample rate
;                       to 22.05Khz, if hardware support is available for this (STB/NC).
; 1.54 22-Apr-97  MT    Fix to allow mono output to be controlled (Sound_Mode 3) - although
;                       the implementation was present, the code to recognise and act on
;                       the specific SWI function code had been omitted by accident in the
;                       code merge.
; 1.59 22-Feb-01  SBF   Obsolete STB flag removed; default frequency of 20.8333kHz used in all cases
;

              GBLL    StrongARM
StrongARM     SETL    {TRUE}

        GET     Hdr:ListOpts
        OPT     OptNoList
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        $GetVIDC
        $GetMEMM
        $GetIO
        GET     Hdr:CMOS
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:PublicWS
        GET     Hdr:Tokens
        GET     Hdr:DevNos
        GET     Hdr:Proc
        GET     Hdr:VduExt
        GET     Hdr:MsgTrans
        GET     Hdr:HostFS
        GET     Hdr:DDVMacros
        GET     Hdr:NDRDebug
        GET     Hdr:HALEntries
        GET     Hdr:DMA
        GET     Hdr:CPU.Arch
        GET     Hdr:RTSupport
        GET     Hdr:OsBytes

        OPT     OptList
        OPT     OptPage

        GET     Hdr:Sound
        GET     Hdr:Portable
        GET     Hdr:PCI

        GET     Version
        GET     VersionASM

        GET     Hdr:HALDevice
        GET     Hdr:AudioDevice
        GET     Hdr:MixerDevice
        GET     Hdr:SoundCtrl

; On IOMD-based systems, to support sound DMA "cheaply" in terms of
; software complexity, we must have physical sound buffers no bigger
; than the maximum DMA buffer IOMD supports (i.e. number of bytes
; transferred per DMA interrupt).  This is 4Kbytes: the size of a page
; on ARM{6,7}00 machines.  In addition, for each sound DMA buffer,
; either it must all lie within a single physical page, or else the
; pages which contain it must be physically contiguous.  We could
; survive any combination of values for SoundDMABufferSize and
; SoundDMABuffers which satisfied both these conditions. However it is
; simpler here (e.g. no need for physical contiguity check) just to
; use the tighter condition that the SoundDMABufferSize is *exactly*
; 4096 and that the base address of the sound buffers is on a 4096
; byte boundary. This was true for the original values as used on
; MEMC1 systems, and is unlikely to need to change. Therefore this
; tighter restriction is OK.

    [ SoundDMABufferSize /= 4096
        ! 1, "SoundDMABufferSize must be exactly 4096 for Sound0 on IOMD"
    ]
    [ SoundDMABuffers :MOD: 4096 /= 0
        ! 1, "SoundDMABuffers must be 4096-byte-aligned for Sound0 on IOMD"
    ]

; In addition, for yet more simplification, and minimum code change to
; support IOMD, we assume here that the two 4Kb sound buffer pages are
; physically contiguous (in the right order!), so that we can continue
; to use only one word [Level0Base,#Phys0] to hold the base address.
; This assumption cannot currently (21-May-93) be tested at assembly
; time.

        GBLL    debug
debug           SETL    {FALSE}

        GBLL    hostvdu
hostvdu         SETL    {TRUE}

swi     SETD    {FALSE}
devlist SETD    {FALSE}

; Timing code uses a HAL timer to measure time spent in various bits of buffer
; fill code. Use *SoundTiming to see the results (and to reset the counters)
        GBLL    TimingCode
TimingCode      SETL    {FALSE}

 [ TimingCode
TimingTimer     * 1 ; Which HAL timer to use
 ]   


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Level0 data structure

; Sound0Segment:  Sound DMA Control Block
;
; Total of 16 words available.  First 9 must NOT be reordered without also
; fixing static copy (ProtoS0S) and init code, since an LDM/STM pair is used
; with specific registers known to match particular fields
          ^ 0
Semaphore # 4   ; 0 = sound enabled, &80000000 = sound disabled
Phys1     # 4   ; physical address of buffer 1
Buff0     # 4   ; logical page addresses...
Buff1     # 4
Config    # 0
BuffLen   # 2   ; 16-bit Buffer Length (in samples)
Period    # 1   ; 8-bit SFG period
NChannels # 0   ; Log channels (3 bit) AND sundry flags
Flags     # 1   ; Name for flags byte
Level1Ptr # 4
Images    # 8   ; (8) byte image positions, full 8-bit resolution of user value (-127..127)
Level2Ptr # 4   ; scheduler

; End of order-critical section. From here on, items are initialised
; dynamically and one item at a time, hence order is not significant.

; Code to handle stereo 16-bit linear emulation of N-channel mu-law needs to
; keep track of how many channels are in use.
Log2nchan_C # 1 ; Log2(currently active channel count), as compiled into 16-bit conv code

Spare0    # 3

ImagesC_N # 4   ; compacted (new) version of Images, for prog'ing conv. routine
ImagesC_H # 4   ; value which IRQ code will load into conv. routine on next irq
ImagesC_C # 4   ; softcopy of value currently programmed into conv. routine
SoundRMA  # 4   ; pointer to remaining data/dynamic code items held in RMA
SoundGain # 1   ; value of additional gain (0..7) -> +0 .. 21dB in 3dB steps, for mu-law
SoundGain_C # 1 ; value of additional gain as currently compiled into conv code

; Currently 2 bytes free

        ASSERT  @@ <= SoundLevel0Reserved

; Constants
; SC prefix for SoundConstant
SCRate       * 22050                    ; default
SCPeriod     * 1000000/SCRate

SCBufferLen  * 224                      ; 224 bytes/channel (&E0: multiple of 16)
SCLogChannel * 0                        ; default log2nchan = 0 -> 1 channel
SCSoundGain  * 0                        ; default soundgain is 0

; Flags bits in NChannels/Flags byte: bottom 2 bits are log2nchan, top bit for
; handler call "Level0 updated" flag, remaining bits are free for general flags
 [ SupportSoftMix
DoSoftMix       *       &40             ; software mixer (volume control) flag
 ]
DoReverse       *       &20             ; stereo reverse bit
DoMono          *       &10             ; mono-isation control bit
DoOversample    *       &08             ; oversampling active bit
OversampleFlag  *       &04             ; AutoOversampling flag from CMOS

 [ SupportSoftMix
DoFlags         * DoMono+DoOversample+DoReverse+DoSoftMix
 |
DoFlags         * DoMono+DoOversample+DoReverse
 ]

; Definition of cut-off point for oversampling
MinOSPeriod     *       42              ; do not oversample if period < 42 (f > 24kHz)

; Level0 constants

; Physical address of sound DMA buffers is not fixed on HAL systems, but
; needs to be determined at initialisation time.


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Header
        OPT     OptPage

        AREA    |Sound0$$Code|, CODE, READONLY, PIC

Module_Base
        DCD     0                    ; NOT AN APPLICATION
        DCD     Initialise_Module    - Module_Base
        DCD     Finalise_Module      - Module_Base
        DCD     Intercept_Services   - Module_Base
        DCD     Module_Name          - Module_Base
        DCD     Help_String          - Module_Base
        DCD     Module_Keywords      - Module_Base
        DCD     Module_SWISystemBase + Sound0SWI * Module_SWIChunkSize
        DCD     Sound_SWI_Code       - Module_Base
        DCD     Module_SWIDecodeBase - Module_Base
        DCD     0                    ; No decoding code.
 [ International_Help <> 0
        DCD     message_filename     - Module_Base
 |
        DCD     0
 ]
 [ :LNOT: No32bitCode
        DCD     Module_Flags         - Module_Base
 ]

Module_Name
        DCB     "SoundDMA", 0

Help_String
        DCB     "SoundDMA"
        DCB     9
        DCB     "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        DCB     " $Module_MinorVersion"
 ]
        DCB     " HAL version"
        DCB     0

Module_SWIDecodeBase
        DCB     "Sound",0
        DCB     "Configure",0
        DCB     "Enable",0
        DCB     "Stereo",0
        DCB     "Speaker",0
        DCB     "Mode",0
        DCB     "LinearHandler",0
        DCB     "SampleRate",0
        DCB     "ReadSysInfo",0
        DCB     "SelectDefaultController",0
        DCB     "EnumerateControllers",0
        DCB     "ControllerInfo",0
        DCB     0

Module_Keywords

        DCB     "Audio", 0
        ALIGN
        DCD     Audio_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)   ; all flags clear, and one parameter ONLY
        DCD     Audio_Syntax - Module_Base
        DCD     Audio_Help   - Module_Base

        DCB     "Speaker", 0
        ALIGN
        DCD     Speaker_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)   ; all flags clear, and one parameter ONLY
        DCD     Speaker_Syntax - Module_Base
        DCD     Speaker_Help   - Module_Base

        DCB     "Stereo", 0
        ALIGN
        DCD     Stereo_Code   - Module_Base
        DCB     2, 0, 2, 0:OR:(International_Help:SHR:24)   ; all flags clear, two parameters ONLY
        DCD     Stereo_Syntax - Module_Base
        DCD     Stereo_Help   - Module_Base

        DCB     "SoundGain", 0
        ALIGN
        DCD     SoundGain_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)
        DCD     SoundGain_Syntax - Module_Base
        DCD     SoundGain_Help   - Module_Base

        DCB     "SoundSystem", 0
        ALIGN
        DCD     SoundSystem_Code   - Module_Base
        DCB     1, 0, 2, 0:OR:(International_Help:SHR:24):OR:(Status_Keyword_Flag:SHR:24)
        DCD     SoundSystem_Syntax - Module_Base
        DCD     SoundSystem_Help   - Module_Base

      [ TimingCode
        DCB     "SoundTiming", 0
        ALIGN
        DCD     SoundTiming_Code   - Module_Base
        DCB     0, 0, 0, 0
        DCD     0
        DCD     0
      ]

        DCB     0            ; no more entries.

        GET     TokHelpSrc.s

        ALIGN

 [ :LNOT: No32bitCode
Module_Flags
        DCD     ModuleFlag_32bit
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ UseNEON
        GET     Sound0NEON.s
 |
        GET     Sound0ARM.s
 ]

; Define RMA sound workspace now we know how big the A500 or mu-law-to-linear code is.

        ^       0

MessageFile_Block # 16
MessageFile_Open  #  4

; 16-bit linear support data
HALSRIndex        #  4                  ; Softcopy of sample rate index programmed in HAL device
HALBuffLen        #  2                  ; Softcopy of BuffLen programmed in HAL device, *2 if oversampling
UserOSFlag        #  1                  ; see UpdateHALParams 
ResetPending      #  1                  ; Flag for whether HAL-requested audio reset is pending
ReenableFlag      #  1                  ; Whether we're going to attempt to automatically reenable sound if a required service restarts
                  #  3
SavedSample       #  4                  ; Preserved stereo value from end of last buffer, for
                                        ; 2:1 linear interpolation (if configured).
Lin16GenR0        #  4                  ; Value to be passed in R0 to ...
Lin16Gen          #  4                  ; User-supplied 16-bit sound generator(/mixer) code
CurSRValue        #  4                  ; Current sample frequency in 1/1024 Hz units
CurSRIndex        #  4                  ; index into set of available frequencies
CurSRIndex_OS     #  4                  ; index after taking into account oversampling
 [ UseNEON
VFPSup_Context    #  4                  ; VFP context pointer
VFPSup_ChangeCtx  #  4                  ; VFPSupport context change function ptr
VFPSup_WS         #  4                  ; Context change function WS ptr
NEON_Q0_Q1        #  32                 ; R & L channel scale factors
 |
LinConvCode       #  MAXLinConvCodeSize ; Space for the dynamically-compiled mu-law to
                                        ; 16-bit-linear conversion code
 ]
 [ SupportSoftMix
SoftMixAmount     #  4                  ; Current software mix level (as volume multiplier for buffer fill code)
 ]
Sound_device      #  4                  ; IRQ number
HALDevice         #  4                  ; Pointer to current HAL audio controller device
DMAChannel        #  4                  ; DMA channel handle. 0 if device doesn't use DMAManager
DMATag            #  4                  ; DMA tag
DMARoutines       #  20                 ; Pointers to DMA routines
DMAScatter        #  16                 ; DMA scatter list

RTSup_Pollword    #  4                  ; RTSupport pollword
RTSup_Handle      #  4                  ; Our handle with RTSupport
DeviceList        #  4                  ; All detected (+ supported) HAL devices

 [ TimingCode
TimeGran          #  4                  ; Granularity, for display
TimeFunc          #  4                  ; HAL_Timer_ReadCountdown
TimeWS            #  4
TimeMaxPeriod     #  4                  ; Max period of timer
TimeTotal         #  4                  ; Total accumulated time
TimeLevel2        #  4                  ; Time spent in level 2 code
TimeNuke          #  4                  ; Time spent nuking old buffer
TimeLevel1        #  4                  ; Time spent in level 1 code
TimeMuLaw         #  4                  ; Time spent in mu-law to linear
TimeLinear        #  4                  ; Time spent in linear handler
TimeMonoOversample # 4                  ; Time spent in mono/oversample code
TimeTemp0         #  4
TimeTemp1         #  4
 ]

WorkSpaceSize     * @@

                         ^ 0
DeviceList_Next          # 4
DeviceList_AudioDevice   # 4
 [ SupportSoftMix
DeviceList_SoftMixDevice # 4
 ]
DeviceList_ID            # 0            ; ID string for device - is last member of struct

  [ TimingCode
        ; Get current time into r0
        ; SoundRMA in $ws
        ; Corrupts r0-r3,r9,r12,lr
        MACRO
        GetTime   $ws
        ASSERT    $ws <> 12
        ASSERT    $ws <> 0
        LDR       r9,[$ws,#TimeWS]
        MOV       r0,#TimingTimer
        MOV       lr,pc
        LDR       pc,[$ws,#TimeFunc]
        MEND
  ]

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Audio_Code Entry

        LDR     r12, [r12]
        BL      DeviceList_FindByID
        CMP     r3, #0
        BEQ     %FT10
        SWI     XSound_SelectDefaultController
        EXIT
10
        BL      DecodeOnOrOff
        SWI     XSound_Enable
        EXIT

; .............................................................................

Speaker_Code ALTENTRY

        LDR     r12, [r12]
        BL      DecodeOnOrOff
        SWI     XSound_Speaker
        EXIT

; .............................................................................
; Out   r0 = 1,2 (ON/OFF)
;       r12 = workspace pointer

DecodeOnOrOff ROUT

        LDRB    r1, [r0], #1            ; Spaces skipped already
        CMP     r1, #"O"
        CMPNE   r1, #"o"
        BNE     Bad_Parameter_Error
        LDRB    r1, [r0], #1
        CMP     r1, #"N"
        CMPNE   r1, #"n"
        BNE     %FT50
        LDRB    r1, [r0], #1            ; Ensure no trailing junk
        CMP     r1, #" "
        BHI     Bad_Parameter_Error
        MOV     r0, #2                  ;  2 -> ON
        MOV     pc, lr                  ; flags irrelevant on *-command exit

50      CMP     r1, #"F"
        CMPNE   r1, #"f"
        BNE     Bad_Parameter_Error
        LDRB    r1, [r0], #1
        CMP     r1, #"F"
        CMPNE   r1, #"f"
        CMPNE   r1, #"."
        BNE     Bad_Parameter_Error

        LDRB    r1, [r0], #1            ; Ensure no trailing junk
        CMP     r1, #" "
        BHI     Bad_Parameter_Error
        MOV     r0, #1                  ;  1 -> OFF
        MOV     pc, lr                  ; flags irrelevant on *-command exit

Bad_Parameter_Error
        ADR     r0, ErrorBlock_BadSoundParameter

ReturnError ; For star commands

        BL      CopyError
        PullEnv
        RETURNVS

        MakeInternatErrorBlock BadSoundParameter,,M00

; .............................................................................

Stereo_Code ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer
        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned
        BVS     Stereo_Channel_Error

        SUB     r14, r2, #1             ; Ensure in 1..SoundPhysChannels
        CMP     r14, #SoundPhysChannels
        BHS     Stereo_Channel_Error

        MOV     r4, r2                  ; preserve

10      LDRB    r3, [r1], #1            ; strip spaces
        CMP     r3, #" "
        BEQ     %BT10

        TEQ     r3, #"-"                ; signed?
        TEQNE   r3, #"+"
        SUBNE   r1, r1, #1              ; retrace our steps

        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned
        BVS     Stereo_Position_Error

        CMP     r2, #127
        BHI     Stereo_Position_Error

        TEQ     r3, #"-"                ; invert now if -ve
        RSBEQ   r2, r2, #0

        MOV     r0, r4                  ; channel no.
        MOV     r1, r2                  ; Position
        SWI     XSound_Stereo
        EXIT


Stereo_Channel_Error
        ADR     r0, ErrorBlock_BadSoundChannel
        B       ReturnError

        MakeInternatErrorBlock BadSoundChannel,,M01


Stereo_Position_Error
        ADR     r0, ErrorBlock_BadSoundStereo
        B       ReturnError

        MakeInternatErrorBlock BadSoundStereo,,M02

; .............................................................................

SoundSystem_Code
; In:   r0 = 0  => print syntax only
;       r0 = 1  => print current status
;       r0 > 1  => configure new value
;
        LDR     r12, [r12]

        Entry   "r1-r3"

        CMP     r0, #1
        BEQ     %FT10
        BCS     %FT20

        SWI     XOS_WriteS                      ; Print syntax only.
soundsystem_string
        DCB     "SoundSystem  ",0
        ALIGN
        SWI     XOS_WriteS
        DCB     "16bit [Oversampled] | <D>",0
        SWIVC   XOS_NewLine
        EXIT

10
        MOV     r0, #161                        ; Print status so read CMOS.
        MOV     r1, #PrintSoundCMOS
        SWI     XOS_Byte
        ADRVC   r0, soundsystem_string
        SWIVC   XOS_Write0
        EXIT    VS

        ADR     r0, parameter_16bit
        SWI     XOS_Write0
        EXIT    VS

        TST     r2, #&80
        BEQ     %FT15
        SWI     XOS_WriteI+" "
        ADRVC   r0, parameter_oversampled
        SWIVC   XOS_Write0
15
        SWIVC   XOS_NewLine
        EXIT

20
        MOV     r3, r0                          ; Save pointer to first parameter.

30
        MOV     r0, r3
        ADR     r1, parameter_16bit
        BL      strcmp_advance
        BNE     %FT40

        BL      skip_spaces                     ; "16bit" given so check for second parameter.
        MOVCC   r3, #1                          ; None, so no oversample.
        BCC     set_new_value

        ADR     r1, parameter_oversampled       ; Must be "oversampled".
        BL      strcmp_advance
        MOVEQ   r3, #5
        BEQ     set_new_value

        MOV     r0, #0                          ; Bad configure option.
exit_error
        SETV
        EXIT

40
        MOV     r0, #10:OR:(1:SHL:31):OR:(1:SHL:29)     ; Read unsigned, limit range, check terminator.
        MOV     r1, r3
        MOV     r2, #7
        SWI     XOS_ReadUnsigned
        EXIT    VS

        MOV     r0, r1                          ; Make sure number is not followed by another parameter.
        BL      skip_spaces
        MOVCS   r0, #3
        BCS     exit_error

        MOV     r3, r2
set_new_value
        MOV     r0, #161                        ; Read current value.
        MOV     r1, #PrintSoundCMOS
        SWI     XOS_Byte

        BICVC   r2, r2, #7:SHL:5                ; Set new value.
        ORRVC   r2, r2, r3, LSL #5
        MOVVC   r0, #162
        SWIVC   XOS_Byte
        EXIT


parameter_16bit
        DCB     "16bit",0
parameter_oversampled
        DCB     "Oversampled",0
        ALIGN

strcmp_advance
; In:   r0 -> string 1 (space or control char terminated)
;       r1 -> string 2 (space or control char terminated)
; Out:  EQ => strings match (no case)
;       r0 -> terminator of string 1
;       OR
;       NE => strings do not match
;
        Entry   "r2"
10
        LDRB    r2, [r0], #1
        LDRB    lr, [r1], #1
        CMP     r2, #" "                ; If found both terminators then strings are equal.
        CMPLE   lr, #" "
        BLE     %FT20

        BIC     r2, r2, #1:SHL:5
        BIC     lr, lr, #1:SHL:5
        TEQ     r2, lr
        BEQ     %BT10
        EXIT                            ; Not same so exit NE.
20
        SUB     r0, r0, #1              ; Point to terminator.
        CMP     r0, r0                  ; Same so exit EQ.
        EXIT

skip_spaces
; In:   r0 -> string
; Out:  r0 -> first non-space in string
;       CC => control char found
;       CS => printable char found
;
        Entry
10
        LDRB    lr, [r0], #1
        CMP     lr, #" "
        BEQ     %BT10
        SUB     r0, r0, #1
        EXIT


; .............................................................................

SoundGain_Code  ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer

        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned        ; complain if not a number or bad term
        BVS     Bad_Parameter_Error
        CMP     r2, #7                  ; if >7, complain about range
        BHI     SoundGain_Error
        LDR     r1, =SoundLevel0Base
        STRB    r2, [r1, #SoundGain]   ; else store out for compilation on next irq
        EXIT

SoundGain_Error
        ADR     r0, ErrorBlock_BadSoundGain
        B       ReturnError

        MakeInternatErrorBlock BadSoundGain,,M03

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Data Structure and Constants
        OPT     OptPage

; DMA physical address pointer

; Prototype of part of Sound0Segment from Buff 0 .. Scheduler

ProtoS0S
        DCD     SoundDMABuffers                         ; Buff 0
        DCD     SoundDMABuffers + SoundDMABufferSize    ; Buff 1
; Config word, comprised of buffer length (16 bits), period (8 bits),
; log2nchan (2 bits), misc config flags (5 bits)
; Last bit reserved for level1 config changed flag
        DCW     SCBufferLen
        DCB     SCPeriod
        DCB     SCLogChannel

        DCD     SoundSystemNIL                          ; channel handler
        DCB     &80, &80, &80, &80, &80, &80, &80, &80  ; Images (2 words worth)
        DCD     SoundSystemNIL                          ; scheduler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module SWI Interface
        OPT     OptPage

Sound_SWI_Code ROUT
        MRS     R10, CPSR
        Push    "R10,R14"
        SEI     SVC32_mode
        BL      Original_SWI_Code
        Pull    "R10,R14"
        MSR     CPSR_c, R10             ; restore interrupts
        MOV     PC,R14                  ; 32-bit exit: NZ corrupted, CV passed back

Original_SWI_Code
        LDR     r10, =SoundLevel0Base
        CMP     r11, #(EndOfJumpTable-JumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        MOV     pc, lr

JumpTable
        B       Sound0Config            ; configuration
        B       Sound0Enable            ; enable control
        B       Sound0Stereo            ; stereo positioning
        B       Sound0Speaker           ; loudspeaker control
        B       Sound0Mode              ; mode control/status (16-bit/mu-law etc)
        B       Sound0LinearHandler     ; 16-bit sound generator interface
        B       Sound0SampleRate        ; new sample rate control interface
        B       Sound0ReadSysInfo       ; Read info
        B       Sound0SelectDefaultController
        B       Sound0EnumerateControllers
        B       Sound0ControllerInfo
EndOfJumpTable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0  = no. of channels (rounded up to power of two)
;       r1  = samples per buffer
;       r2  = uS per sample
;       r3  = Level1 Handler   (normally 0!)
;       r4  = Level2 Scheduler (normally 0!)
;       r10 = SoundLevel0Base
;       0 -> don't change!
;       IRQs disabled
;
; Constraints:
;              1 <= r0             <= 8
;             16 <= r1 * NChannels <= SoundDMASize
;  3 * NChannels <= r2 * NChannels <= 255

; Out   Return old r0,r1,r2,r3,r4

Sound0Config Entry

        Debug   swi,"Sound0Config",r0,r1,r2,r3,r4

        CMP     r0, #0                  ; r0 processing
        LDREQB  r0, [r10, #NChannels]
        ANDEQ   r0, r0, #3
        BEQ     %FT10

        SUB     r0, r0, #1              ; 1=>0, 2=>1 FOR LOGS!
        CMP     r0, #3
        MOVEQ   r0, #2                  ; 2,3 => 2
        MOVGT   r0, #3                  ; 4,5,6,7 => 3

10 ; MUST UPDATE STEREO POSITIONS

        Push    "r0-r3"
        LDRB    r3, [r10, #NChannels]
        STRB    r0, [r10, #NChannels]
        MOV     r2, #1
        MOV     r2, r2, LSL r0          ; number of channels

; for r0 = 1 to NChannels
        MOV     r0, #1
15      MOV     r1, #-128               ; read stereo pos
        SWI     XSound_Stereo           ; get previous
        SWI     XSound_Stereo           ; force set to new channels
        ADD     r0, r0, #1
        CMP     r0, r2
        BLE     %BT15                   ; loop for N active channels

        STRB    r3, [r10, #NChannels]
        Pull    "r0-r3"

16
        CMP     r1, #0                  ; r1 processing
        LDREQ   r1, [r10, #Config]      ; bottom 16 bits
        BIC     r1, r1, #&FF000000
        BIC     r1, r1, #&00FF0000

        MOV     r1, r1, LSL r0          ; scale for NChannels of 8bit data
     [ UseNEON
        ADD     r1, r1, #15             ; Must be multiple of 16 for NEON code
        BIC     r1, r1, #15
     ]
        CMP     r1, #SoundDMABufferSize ; can't be > buffer size
        MOVGT   r1, #SoundDMABufferSize
        MOV     r1, r1, LSR r0          ; back to per channel

        ; Get minimum buffer size + granularity
        ; TODO - This could be improved for the case where oversampling is enabled. Unfortunately restructuring the code to allow oversampling to influence the buffer size could be a bit tricky.
        Push    "r2-r3"
        LDR     r2, [r10, #SoundRMA]
        LDR     r2, [r2, #HALDevice]
        CMP     r2, #1                  ; Use default limits if no device
        LDRHS   r3, [r2, #HALDevice_Version]
        CMPHS   r3, #2:SHL:16           ; Only available with API 2+
        LDRHS   r3, [r2, #HALDevice_AudioMinBuffSize]
        LDRHS   r2, [r2, #HALDevice_AudioBuffAlign]
        MOVLO   r3, #0
        MOVLO   r2, #0
        CMP     r3, #32                 ; ensure enough 8bit/16bit samples for >= 32bytes of data (sensible default minimum)
        MOVLO   r3, #32

        CMP     r1, r3, LSR #2          ; Apply min buffer size requirement
        MOVLT   r1, r3, LSR #2

        CMP     r2, #0                  ; Mono/oversample code processes 4 words of (non-oversampled) linear data at a time, so ensure granularity is a multiple of 16
        MOVEQ   r2, #16
20
        TST     r2, #&f
        MOVNE   r2, r2, LSL #1
        BNE     %BT20
        MOV     r2, r2, LSR #2          ; Get granularity in terms of stereo sample pairs

        DivRem  r3, r1, r2, lr
        CMP     r1, #0
        MOVNE   r1, r2                  ; Apply granularity requirement (round remainder up to granularity)
        MLA     r1, r2, r3, r1

        ; Check (non-oversampled) linear data doesn't overflow buffer
        ; Oversampled data is checked by process_oversample
        CMP     r1, #SoundDMABufferSize :SHR: 2
        BLE     %FT21
        MOV     r1, #SoundDMABufferSize :SHR: 2
        DivRem  r3, r1, r2, lr, norem   ; Work out how many multiples of granularity we can fit, and use that (assumed to be >= min buffer size)
        MUL     r1, r2, r3
21
        Pull    "r2-r3" 

        Debug   swi,"per channel bufsz =",r1

        CMP     r2, #0                  ; r2 processing
        LDREQB  r2, [r10, #Period]       ; if 0 then substitute current

        BL      WorkOutVIDCParams       ; but still go through update procedure

30      CMP     r3, #0                  ; r3 processing
        LDREQ   r3, [r10, #Level1Ptr]    ; old if 0

        CMP     r4, #0                  ; r4 processing
        LDREQ   r4, [r10, #Level2Ptr]    ; old if 0

40 ; merge into reg

        ORR     r11,  r1, r2, LSL #16
        ORR     r11, r11, r0, LSL #24

        LDR     r0, [r10, #Config]      ; Get return params
        AND     r1, r0, #&FC000000      ; extract current flags from nchan/flags byte
        ORR     r11, r11, r1            ; combine into new config value to store
        BIC     r1, r0, #&FF000000      ; mask out flags etc, leaving per-chan buflen
        BIC     r1, r1, #&00FF0000

        MOV     r2, r0, LSR #16
        AND     r2, r2, #&FF            ; current period value in r2

        ; produce channel count in r0, starting from config word in r0.
        MOV     r0, r0, LSR #24
        AND     r0, r0, #3
        ORR     r0, r0, #&01000000
        MOV     r0, r0, LSL r0          ; relies on LSL reg using only bits 7:0 of reg!
        MOV     r0, r0, LSR #24

        STR     r11, [r10, #Config]     ; store new buflen, period, log2nchan, flags

        LDR     r11, [r10, #Level1Ptr]  ; SSCB base
        STR     r3,  [r10, #Level1Ptr]  ; Install new Level1 handler
        MOV     r3,  r11                ; Return old

        LDR     r11, [r10, #Level2Ptr]  ; SSCB base
        STR     r4,  [r10, #Level2Ptr]  ; Install new Level2 handler
        MOV     r4,  r11                ; Return old

        PullEnv
        B       UpdateHALParams         ; Update HAL now that BuffLen is up to date

; Alternate entry point used during module initialisation
; This skips out the XSound_Stereo calls which would fail (and potentially loop forever) due to our SWIs not being hooked up yet
Sound0InitConfig ALTENTRY
        B       %BT16

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       WorkOutVIDCParams - Compute sample rate index from
;       present configuration: no. of channels, sample period.
;
; in:   r0 = log2(no of channels)
;       r1 = samples per buffer
;       r2 = desired sample period in microseconds, if < 256,
;       r10 = SoundLevel0Base
;
; out:  r2 = effective per-channel sample rate used (in microseconds)
;       CurSRIndex, CurSRValue updated
;

WorkOutVIDCParams ROUT
        Entry   "r0,r1,r3-r8"

        Debug   swi,"WorkOutVIDCParams",r0,r1,r2

20

; 16-bit output hardware in place: must use one of the subset of sample rates
; supported in this configuration. Scan the set of tabulated frequencies,
; looking for a suitable match.
; This could be reworked a bit for oversampling (i.e. look for r2/2 instead of
; making process_oversample look for closest_sample_rate*2)

        LDR     r5, [r10, #SoundRMA]
        LDR     r5, [r5, #HALDevice]
        CMP     r5, #0
        BEQ     %FT99
        LDR     r4, [r5, #HALDevice_AudioRateTable]
        LDR     r5, [r5, #HALDevice_AudioNumRates]
        SUB     r4, r4, #AudioRateTableSize ; address 0th entry of main freq info table
        MOV     lr, #1                  ; start with entry 1 in map
        ASSERT  AudioRateTableSize = 8
22      ADD     r1, r4, lr, LSL #3      ; address entry in table
        LDRB    r3, [r1, #AudioRateTable_Period] ; pick up nominal period

        SUBS    r7, r3, r2              ; place (entry - freq) in r7
        BEQ     %FT26                   ; if =, go do it
        BPL     %FT24                   ; else if freq > entry, then look at next entry

                                        ; here, freq < entry, so test for closest match ie

                                        ;      (last_entry > freq < this_entry)

        CMP     lr, #1                  ; accept if at start of table
        BEQ     %FT26
        SUB     lr, lr, #1              ; otherwise back up to previous entry
        ASSERT  AudioRateTableSize = 8
        ADD     r1, r4, lr, LSL #3      ; address entry in table
        LDRB    r3, [r1, #AudioRateTable_Period] ; pick up nominal period

        SUB     r8, r2, r3              ; place (freq - entry) in r8

        CMP     r7, r8                  ; if r7 < r8 (they're negative) then we have best
        BLT     %FT26                   ; match so accept the current entry

        ADD     lr, lr, #1              ; otherwise go back up to next entry
        ASSERT  AudioRateTableSize = 8
        ADD     r1, r4, lr, LSL #3      ; address entry in table
        LDRB    r3, [r1, #AudioRateTable_Period] ; pick up nominal period
        B       %FT26                   ; and accept it


24      CMP     lr, r5                  ; if at end of list, accept this one
        BEQ     %FT26
        ADD     lr, lr, #1
        B       %BT22

26      LDRB    r2, [r1, #AudioRateTable_Period] ; pick up period to report back to user
        LDR     r0, [r1, #AudioRateTable_Frequency] ; get frequency value
        ; and drop into final code

; Store computed values and exit:
; lr is sample rate index
; r2 is user-visible per-channel period,
; r0 is sample frequency in Hz/1024
98
        Debug   swi,"computed values are",lr,r2,r0

        LDR     r5, [r10, #SoundRMA]
        STR     r0, [r5, #CurSRValue]   ; update frequency
        STR     lr, [r5, #CurSRIndex]   ; and index of frequency
        MOV     r3, lr
        LDRB    r0, [r10, #Flags]
        LDR     r1, [sp, #4]            ; get back current/new samples per buffer
        BL      process_oversample      ; go set up to do oversampling iff we can
        STRB    r0, [r10, #Flags]       ; store back possibly updated flags
        STR     r3, [r5, #CurSRIndex_OS] ; store back oversampled freq index 
        EXIT                            ; return with updated period in R2

99
; No HAL device, so don't allow sample rate to be changed from previous value
        LDRB    r2, [r10, #Period]      ; Assuming Period hasn't been prematurely overwritten
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       UpdateHALParams - Reprograms the HAL device with the current sample rate
;       and DMA buffer size. Typically, this function must be called shortly
;       after calling WorkOutVIDCParams.
;
;       Currently, if sound is enabled we must disable it and then re-enable it.
;       This is because (unlike on IOMD) most modern machines don't allow the
;       sample rate to be changed on the fly. Devices are generally more
;       flexible when it comes to changing DMA buffer size, but DMAManager
;       doesn't provide the ability to update the parameters of a running
;       transfer (and neither to seamlessly chain two transfers together), so
;       for buffer size changes we have to stop and start playback also.
;
;       To avoid spurious updates (e.g. when Sound_Configure is called with all
;       0's) we first check a shadow copy of the HAL state.
;
;       in: r10 = SoundLevel0Base
;       out: All regs preserved
;
UpdateHALParams Entry "r0-r6,r12"
        LDR     r6, [r10, #SoundRMA]
        LDR     r0, [r6, #HALDevice]
        CMP     r0, #0
        EXIT    EQ ; No device active; ignore update
        LDRB    r4, [r10, #Flags]
        ANDS    r4, r4, #DoOversample
 [ UseLDRSH
        LDRH    r0, [r6, #HALBuffLen]
        LDRH    r3, [r10, #BuffLen]
        MOVNE   r3, r3, LSL #1 ; Double buffer length if oversampling
        CMP     r0, r3
        STRNEH  r3, [r6, #HALBuffLen]
 |
        LDR     r0, [r6, #HALBuffLen]
        LDR     r3, [r10, #BuffLen]
        MOVNE   r3, r3, LSL #17 ; Double buffer length if oversampling
        MOVEQ   r3, r3, LSL #16
        CMP     r3, r0, LSL #16
        ; Avoid overwriting UserOSFlag & ResetPending. Having those as 1 byte variables is probably more hassle than it's worth :(
        MOV     r3, r3, LSR #16
        STRNEB  r3, [r0, #HALBuffLen]
        MOVNE   r2, r3, LSR #8
        STRNEB  r2, [r0, #HALBuffLen+1]
 ]
        LDREQ   r0, [r6, #HALSRIndex]
        LDR     r5, [r6, #CurSRIndex_OS]
        CMPEQ   r0, r5
        BEQ     %FT10
        STR     r5, [r6, #HALSRIndex]
        STRB    r4, [r6, #UserOSFlag]

        TST     r4, #DoOversample
        MOVNE   r3, r3, LSR #1 ; Get non-oversampled buffer size back, ready for service call
        LDR     r4, [r10, #Semaphore]
        TST     r4, #&80000000
        MOVEQ   r0, #1
        SWIEQ   XSound_Enable ; Sound off

        ; Issue service call to let everyone know the parameters are changing
        MOV     r0, #Service_SoundConfigChanging
        MOV     r1, #Service_Sound
        LDR     r2, [r6, #CurSRValue]
        ; r3 already contains buffer size
        SWI     XOS_ServiceCall

        LDR     r0, [r6, #HALDevice]
        SUB     r1, r5, #1              ; 0-based index for HAL
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_AudioSetRate]
        TST     r4, #&80000000
        MOVEQ   r0, #2
        SWIEQ   XSound_Enable ; Sound back on again
        CLRV ; TODO - Error reporting
        EXIT

10
        ; No HAL update required, but if the user turned off oversampling at
        ; the same time as doubling the sample rate and buffer size then we'll
        ; have skipped out a required Service_SoundConfigChanging call
        ; So use UserOSFlag to track the previous oversampling state and
        ; trigger the service call if oversampling has been toggled
        LDRB    r0, [r6, #UserOSFlag]
        CMP     r0, r4
        EXIT    EQ
        STRB    r4, [r6, #UserOSFlag]
        ; Issue service call to let everyone know the parameters are changing
        MOV     r0, #Service_SoundConfigChanging
        MOV     r1, #Service_Sound
        LDR     r2, [r6, #CurSRValue]
        MOVLT   r3, r3, LSR #1 ; LT if oversampling currently on
        SWI     XOS_ServiceCall
        CLRV
        EXIT        

; process_oversample
; in:  r0 = flags value
;      r1 = samples per buffer
;      r2 = user-visible period
;      r3 = 1-based sample rate index
;      r10 = SoundLevel0Base
; out: r0 = new flags value reflecting oversampling state
;      r1 unchanged
;      r2 unchanged
;      r3 = updated sample rate index reflecting oversampling state
process_oversample Entry "r1,r2,r4,r5"
        Debug   swi,"process_oversample, default off"
        BIC     r0, r0, #DoOversample   ; clear out o/s active flag, assuming not possible
        TST     r0, #OversampleFlag     ;   && auto oversample flag is set)
        EXIT    EQ                      ; else return - can't oversample
        CMP     r2, #MinOSPeriod        ; check sample period value against oversample limit
        EXIT    LT                      ; if too small (f too high), can't oversample
        ; check buffer size: may be too big to handle double-length (4KB max)
        CMP     r1, #SoundDMABufferSize/8 ; check against size limit at Fs*2
        EXIT    HI                      ; don't oversample if gets too big
        ; Check if audio device can support Fs*2
        ; Do a simple linear search for now
        LDR     r1, [r10, #SoundRMA]
        LDR     r1, [r1, #HALDevice]
        CMP     r1, #0
        EXIT    EQ                      ; no device, so o/s flag is irrelevant
        LDR     r2, [r1, #HALDevice_AudioNumRates]
        LDR     r1, [r1, #HALDevice_AudioRateTable]
        ASSERT  AudioRateTableSize = 8
        SUB     r1, r1, #8-AudioRateTable_Frequency
        LDR     r4, [r1, r3, LSL #3]    ; Get current rate
        MOV     r5, r3
01
        ADD     r5, r5, #1
        CMP     r5, r2
        EXIT    HI
        LDR     lr, [r1, r5, LSL #3]
        CMP     r4, lr, LSR #1          ; Assume bottom bit of Fs*2 irrelevant (for inexact sample rates, e.g. 20.833kHz)
        BHI     %BT01
        EXIT    LO
        Debug   swi,"oversampling on"
        MOV     r3, r5                  ; Select new rate index
        ORR     r0, r0, #DoOversample   ; and inform IRQ level through flags
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = 0 -> leave (and return previous)
;            1 -> OFF
;          >=2 -> ON
;       r10 = SoundLevel0Base
;       SVC mode, IRQs disabled

; Out   r0 = previous enable state / error block
;       All other regs preserved
;       IRQs potentially enabled!

Sound0Enable Entry "r1,r4,r11,r12"

        LDR     r11, [r10, #Semaphore]
        TST     r11, #&80000000
        MOVEQ   r11, #2                 ; return ON
        MOVNE   r11, #1                 ; or OFF

        CMP     r0, #1
        BLT     %FT20                   ; [just return value]

; Any state change request causes us to clear ReenableFlag
        LDR     r4, [r10, #SoundRMA]
        MOV     lr, #0
        STRB    lr, [r4, #ReenableFlag]

        BGT     %FT10

; Turn OFF

        TEQ     r11, #1
        BEQ     %FT20

        MOV     r14, #&80000000         ; Set semaphore
        STR     r14, [r10, #Semaphore]
        
        ; Enable IRQs so we can call the potentially slow HAL device
        ; Thankfully the RISC OS 3 PRMs describe Sound_Enable as having undefined re-entrancy (and undefined IRQ status), so we don't have to worry about attempting to behave in a sane manner if we should get re-entered while the device does its stuff.
        CLI     SVC32_mode

        LDR     r4, [r10, #SoundRMA]

        LDR     r0, [r4, #HALDevice]
        Push    "r2-r3"
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_AudioPreDisable]

        MOV     r0, #0
        LDR     r1, [r4, #DMATag]
        CMP     r1, #0
        SWINE   XDMA_TerminateTransfer
        ; TODO - Handle error better - need to undo PreDisable somehow?
        STRVC   r0, [r4, #DMATag]
        Pull    "r2-r3",VS
        EXIT    VS

        LDR     r0, [r4, #HALDevice]
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_AudioPostDisable]
        Pull    "r2-r3"

        ; Get off RTSupport
        MOV     r12, r4
        BL      Finalise_RTSupport

        ; Indicate sound has stopped
        MOV     r1, #Service_Sound
        MOV     r0, #Service_SoundDisabled
        SWI     XOS_ServiceCall

        ; Disallow reset callbacks (not that we should receive any once sound is off)
        MOV     r0, #1
        STRB    r0, [r12, #ResetPending]
        ; Cancel any pending callbacks
        BL      RemoveCallbacks

        CLRV
        B       %FT20


10 ; Turn ON - turning on when already damages sample rate!

        CMP     r11, #2                 ; Exit if turning on when already on
        BEQ     %FT20                   ; This is the proper place to fix
                                        ; the bug, not at the *Audio level!

15
        MOV     r14, #0                 ; Clear semaphore. Common ep
        STR     r14, [r10, #Semaphore]
        
        ; Enable IRQs so we can call the potentially slow HAL device
        CLI     SVC32_mode

        LDR     r12, [r10, #SoundRMA]
        ; Make sure DMA & device are ready
        BL      Initialise_DMA
        ; Register with RTSupport
        BLVC    Initialise_RTSupport
      [ UseNEON
        ; ... and VFPSupport
        BLVC    Initialise_NEON
      ]
        BVS     %FT40

        ; Indicate sound is starting
        MOV     r1, #Service_Sound
        MOV     r0, #Service_SoundEnabled
        SWI     XOS_ServiceCall

        Push    "r2-r3,r5-r7"

        ; Build scatter list
        ADD     r5, r12, #DMAScatter+8
        LDR     r0, [r10, #Buff1]        
        LDR     r6, [r10, #Config]
        TST     r6, #DoOversample :SHL: 24 ; Check for oversampling
        MOV     r6, r6, LSL #16        ; 16-bit buffer length in r6
        MOVEQ   r6, r6, LSR #14        ; 4 bytes/sample if no o/s
        MOVNE   r6, r6, LSR #13        ; but 8 bytes/sample if o/s
        STMIA   r5, {r0,r6}
        LDR     r0, [r10, #Buff0]
        STMDB   r5!, {r0,r6} ; End with r5=scatter list start

        BL      RemoveCallbacks
        ; Allow reset attempts
        MOV     r0, #0
        STRB    r0, [r12, #ResetPending]

        ; Is DMAManager in use?
        MOV     r4, r12
        LDR     r0, [r4, #HALDevice]
        TEQ     r0, #0
        BEQ     %ft30                 ; no valid hal device
        LDR     r2, [r0, #HALDevice_Version]
        CMP     r2, #2:SHL:16 ; API 2+?
        LDRHS   r2, [r0, #HALDevice_AudioCustomDMAEnable]
        CMPHS   r2, #1 ; With AudioCustomDMAEnable?
        MOV     r1, r6
        BHS     %FT21

        ; DMAManager is in use, so call PreEnable
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_AudioPreEnable]
        MOV     r12, r4

        ; Start the DMA transfer
        MOV     r0, #7 ; write, circular, call DMASync
        LDR     r1, [r12, #DMAChannel]
        MOV     r3, r5
        MOV     r4, #0 ; infinite length
        MOV     r5, r6, LSL #1 ; Circular buffer references this much data
        SWI     XDMA_QueueTransfer
        Pull    "r2-r3,r5-r7", VS
        BVS     %FT30
        STR     r0, [r12, #DMATag]

        ; Call PostEnable
        LDR     r0, [r12, #HALDevice]
        MOV     r1, r6
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_AudioPostEnable]
        Pull    "r2-r3,r5-r7"
19
        CLRV

20      MOV     r0, r11                 ; Return previous enable state
        EXIT                            ; Restores ints to caller state, maybe
                                        ; get IRQ'ed here too.

21
        ; DMAManager isn't in use, so call CustomDMAEnable
        ; Already have R1 = buffer size, R0 = hal device, r4 = SoundRMA, r5 = scatter list, r10 = SoundLevel0Base
        LDR     r2, [r5]
        LDR     r3, [r5, #8]
        LDR     r11, [r0, #HALDevice_AudioFlags]
        TST     r11, #AudioFlag_Synchronous
        ADREQL  r11, CustomDMASync_Async
        ADRNEL  r11, CustomDMASync_Sync
        STMFD   r13!,{r4,r11}
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_AudioCustomDMAEnable]
        ADD     r13, r13, #8
        MOV     r12, r4
        Pull    "r2-r3,r5-r7"
        CMP     r0, #0
        BEQ     %BT19
        ; Fall through with R0 = error ptr

30
        ; Initialisation failed
        ; TODO - Decide on how to shutdown HAL device (AudioPostDisable?)
        MOV     r4, r0
        ; Broadcast that sound isn't starting after all
        MOV     r1, #Service_Sound
        MOV     r0, #Service_SoundDisabled
        SWI     XOS_ServiceCall
        ; Deregister with RTSupport
        BL      Finalise_RTSupport
        MOV     r0, r4
        SETV
40
        ; Set semaphore again
        MOV     r14, #&80000000
        STR     r14, [r10, #Semaphore]
        EXIT
        
        

; .............................................................................
; Called at RESET time
; in: r10 = SoundLevel0Base

Sound0Reenable ALTENTRY

        LDR     r11, [r10, #Semaphore]
        TST     r11, #&80000000
        EXIT    NE                      ; was OFF, stays OFF

        B       %BT15                   ; Turn it on again

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = 0 -> leave (and return previous)
;            1 -> OFF
;          >=2 -> ON
;       r10 = SoundLevel0Base
;       IRQs disabled

; Out   r0 = previous speaker state

Sound0Speaker ROUT
        Entry   "r0-r4"
        LDR     r12, [r10, #SoundRMA]
        LDR     r0, [r12, #HALDevice]
        TEQ     r0, #0
        LDRNE   r0, [r0, #HALDevice_AudioMixer]
        TEQNE   r0, #0
        MOVEQ   r0, #2
        BEQ     %FT90           ; if no mixer attached, cannot control speaker
                                ; else mixer attached to our controller will be number 0
        MOV     r0, #0
        MOV     r1, #MixerCategory_Speaker
        MOV     r2, #0
        SWI     XSoundCtrl_GetMix
        BVS     %FT80
        TST     r3, #1          ; already muted?
        MOVEQ   lr, #2
        MOVNE   lr, #1
        LDR     r3, [sp, #Proc_RegOffset] ; get new state
        STR     lr, [sp, #Proc_RegOffset] ; return old state in R0
        CMP     r3, #1
        EXIT    LO
        MOVEQ   r3, #1
        MOVHI   r3, #0
        SWI     XSoundCtrl_SetMix
        BVS     %FT90
        EXIT

80
        ; Sound mixer present, but no speaker channel (or some other error)
        ; Act as if mixer wasn't there and just report ON
        MOV     r0, #2
        CLRV

90      STR     r0, [sp, #Proc_RegOffset]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0  = channel number (1-8)
;       r1  = -127 for left, 0 centre, 127 right (-128 DON'T CHANGE)
;       r10 = SoundLevel0Base
;       IRQs disabled

; Attempts to be slightly clever...
; programs at interleave factor from r0 upwards...
; note pipeline delay on NChannels...!

; Out   r0 preserved
;       r1 is stereo position allocated (-128 for none/invalid)
;       -128 indicates invalid channel

Sound0Stereo Entry "r0, r2"

        SUB     r0, r0, #1              ; 1..8 -> 0..7
        CMP     r0, #SoundPhysChannels
        MOVHS   r1, #-128
        EXIT    HS

        ADD     r2, r1, #&80            ; add new offset
        LDRB    r14, [r10, #NChannels]
        AND     r14, r14, #3            ; get rid of extra flag bits
        MOV     r11, #1
        MOV     r14, r11, LSL r14       ; convert log

        ADD     r12, r10, #Images
        LDRB    r1, [r12, r0]           ; current pos
        SUB     r1, r1, #&80            ; map back to -127..+127

        CMP     r2, #0
        CMPNE   r2, #&100               ; force range
        EXIT    HS

        ADD     r11, r12, #8            ; end
        ADD     r12, r12, r0            ; base channel
05      STRB    r2, [r12], r14          ; store new pos
        CMP     r12, r11
        BLT     %BT05

        ADD     r0, r10, #Images        ; address full-size image set
        BL      ConvImages              ; produce compacted form...
        STR     r0, [r10, #ImagesC_N]   ; for programming on appropriate IRQ
        EXIT                            ; go back to caller


; Sound0Mode - implements Sound_Mode SWI
;
; In:
;
;   R0: function code
;     = 0: read current mode, returning information in r0/r1.  This code must
;          be used first, to determine the availability of other functions.
;     = 1: set/clear oversampling mode, returning previous state (0 or 1)
;          R1 = 0: disable linear 2x oversampling
;          R1 <> 0: enable linear 2x oversampling
;     = 2: (NOT YET IMPLEMENTED) set external sound clock handler
;          function (for format/status value 3)
;          R1 = external sound clock handler address, or 0 to cancel
;     = 3: set/clear mono flag, returning previous state (0 or 1)
;	   R1 = 0: stereo mode
;	   R1 <> 0: mono mode (convert stereo to mono for output)
;     other function code values not defined
;
;   R10 = SoundLevel0Base
;   IRQs disabled
;
; Out:
;  For function code 0:
;       R0      = 0: mu-law sound system only; SWIs Sound_LinearHandler and
;                    Sound_SampleRate, and all other functions of Sound_Mode, are
;                    not supported.  Contents of r1 are unchanged.
;       R0      = 1: 16-bit capable sound system: SWIs Sound_LinearHandler and
;                    Sound_SampleRate, and full Sound_Mode functionality are all
;                    available.
;
;       R1[3:0]: sound output format and clock control status (from CMOS RAM)
;               = 1: 16-bit linear output, 44k1, 22k05, 11k025 and selected original rates
;               = 2: 16-bit linear output, internal clock, selected original rates only
;               = 3: 16-bit linear output, external master clock source, custom rates only
;               = 4...15: reserved values
;       R1[4]: oversampling control
;               = 0: automatic linear 2x oversampling disabled
;               = 1: automatic linear 2x oversampling enabled
;       R1[5]   = 0: stereo output
;		= 1: mono conversion on output
;       R1[31:6]: reserved for expansion
;
; For all rates <= 25kHz, if auto-oversampling is on, the output data stream
; will be oversampled by 2x, by simple linear interpolation.
;
Sound0Mode      Entry   "r2"
        LDRB    r2, [r10, #Flags]

        CMP     r0, #0
        BNE     %FT10
; Function code 0: read mode information
        MOV     r0, #1                  ; new system, 16-bit
        MOV     r1, #1                  ; all sorts of clocks
        TST     r2, #OversampleFlag     ; check for oversampling
        ORRNE   r1, r1, #1 :SHL: 4      ; set flag if so
        TST	r2, #DoMono		; check for mono mode
        ORRNE	r1, r1, #1 :SHL: 5	; set flag if enabled
        EXIT

10      CMP     r0, #1
        BNE     %FT20
; Function code 1: enable/disable automatic oversampling (allows overriding CMOS value)
        LDR     r0, [r10, #Config]
        MOV     r2, r0, LSR #24
        MOV     lr, r2                  ; preserve original value
        BIC     r2, r2, #OversampleFlag ; clear o/s bit, but NOT DoOversample for now
        CMP     r1, #0                  ; check requested state
        ORRNE   r2, r2, #OversampleFlag ; set bit if required
        ANDS    r1, lr, #OversampleFlag ; get old state of flag into r1 (wrong bit pos)
        MOVNE   r1, #1                  ; if not zero, set 1, else 0 already there...
        ; Need to fix up for oversampling if now enabled.
        Push    "r1,r3,r4"
        MOV     r1, r0, LSL #16         ; r1 = samples per buffer
        MOV     r1, r1, LSR #16
        MOV     r0, r2                  ; r0 = new flags
        LDRB    r2, [r10, #Period]      ; and user-visible sample period into r2
        LDR     r4, [r10, #SoundRMA]
        LDR     r3, [r4, #CurSRIndex]   ; and user-visible SR index into r3
        BL      process_oversample      ; determine whether to use o/s
        STRB    r0, [r10, #Flags]       ; store final flags
        STR     r3, [r4, #CurSRIndex_OS] ; and required SR index
        Pull    "r1,r3,r4"
        MOV     r0, #1
        PullEnv
        B       UpdateHALParams         ; Update HAL on way out

20      CMP     r0, #2
        BNE     %FT30
; FUNCTION CODE 2: NOT YET IMPLEMENTED!
	B	%FT99
30	CMP	r0, #3
	BNE	%FT40
; Function code 3: enable/disable mono-isation (allows overriding CMOS value)
        LDRB    r2, [r10, #Flags]       ; get flags byte
        MOV     lr, r2                  ; preserve original value
        CMP     r1, #0                  ; check requested state
        ORRNE   r2, r2, #DoMono         ; set bit if enabling mono conversion
        BICEQ   r2, r2, #DoMono         ; or clear bit if disabling it
        ANDS    r1, lr, #DoMono         ; get old state of flag into r1 (wrong bit pos)
        MOVNE   r1, #1                  ; if not zero, set 1, else 0 already there...
        STRB    r2, [r10, #Flags]       ; store out new flag value
        EXIT
40
99
        EXIT


; Sound0LinearHandler: implements Sound_LinearHandler SWI.
;
; In: (r0-r2 from user SWI)
;  r0 is function code:
;    r0 = 0: return current handler as {routine, param} pair in r1, r2
;         no side effects, all regs except r1, r2 preserved
;         a null handler is recorded as a routine address of 0, param of -1
;    r0 = 1: install new handler
;         r1 =  0: set null handler (initial, default state), r2 is ignored
;         r1 != 0: set r1 as routine to call, r2 as parameter value to pass
;                  to it in r0, with following call rules:
;               r0 = value specified on installation of routine (r2 here)
;               r1 = base of word-aligned buffer, to fill with 16-bit stereo
;                    data, stored as pairs of signed (2's complement) 16-bit
;                    values; each word has bits 31:16 left channel data, bits
;                    15:0 right channel data.
;               r2 = end of buffer (address of first word beyond buffer)
;               r3 = flag for initial buffer contents:
;                    0 => data in buffer is invalid and MUST be overwritten
;                    1 => data has been converted from N-channel mu-law sound
;                         system and may be either overwritten or (preferably)
;                         mixed with new data produced by routine.
;                    2 => data in buffer is all 0: if routine would generate
;                         silent output, it may simply return.
;               r4 = sample frequency at which data will be played, in Hz/1024
;                    (e.g. for 20kHz, r4 would be 20000*1024 = 20480000).
;    else (r0 = any other value): ignored (do nothing, not even error...)
;
;  r1 = as determined by value in r0
;  r2 = as determined by value in r0
;
;  r10 = SoundLevel0Base (set up locally)
;
;  IRQs are disabled
;
; Out:
;  r0 preserved
;  r1 = previous/current routine address
;  r2 = previous/current value to pass to routine
;
Sound0LinearHandler Entry "r3,r4,r5"
        LDR     r3, [r10, #SoundRMA]
        LDR     r4, [r3, #Lin16Gen]
        LDR     r5, [r3, #Lin16GenR0]
        CMP     r0, #1
        BHI     %FT10
        STREQ   r1, [r3, #Lin16Gen]     ; if r0 = 1, store new value for routine
        STREQ   r2, [r3, #Lin16GenR0]   ;            and new value for r0 param to routine
        MOVS    r1, r4                  ; set previous routine address in r1
        MOVNE   r2, r5                  ; if not null, put param to pass into r2
        MVNEQ   r2, #0                  ; else set -1 into r2
10
        EXIT                            ; and go home


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sound0SampleRate: implements Sound_SampleRate SWI.  This SWI is only
; useable when SoundDevice is configured non-0, i.e. when there is 16-bit sound output
; hardware.  Otherwise it returns 0 in r1 and r2 for all calls.
;
; In: (r0,r1 from user SWI)
;   r0 is function code:
;      0: return in r1 the total number of available sample rates, NSR.
;         Available sample rates are indexed by numbers in the range 1..NSR,
;         and increase with increasing index number.  R2 is preserved.
;      1: return in r1 the index of the current sample rate, and in r2
;         the current sample rate, measured in units of 1/1024 Hz, e.g.
;         20kHz would be 20480000;
;      2: return in r2, as value measured in 1/1024ths of Hz, the sample
;         rate defined by index given in r1 (in range 1..NSR).
;      3: select new sample rate via index in r1, in range 1..NSR; return
;         index and value of previous rate in r1 and r2 respectively.
;
;   r1 = as determined by value in r0.
;   r2 = as determined by value in r0.
;
;  r10 = SoundLevel0Base (set up locally, not from SWI)
;
;  IRQs disabled
;
; Out:
;   r0 preserved
;   r1 = index of previous/current rate, or NSR;
;   r2 = previous/current/rate, measured in 1/1024ths of Hz, or preserved (r0 = 0)
;
Sound0SampleRate Entry "r3,r4"
        LDR     r3, [r10, #SoundRMA]
        CMP     r0, #0                  ; check function code
        LDR     r4, [r3, #HALDevice]
        BNE     %FT10

; Function code 0: read NSR (as configured at module init or via clock handler)
        TEQ     r4, #0
        LDRNE   r1, [r4, #HALDevice_AudioNumRates]
        MOVEQ   r1, #1                  ; only claim 1 rate if no device
        EXIT

10      CMP     r0, #1
        BNE     %FT20
; Function code 1: read current sample rate index and sample rate
15
        LDR     r2, [r3, #CurSRValue]
        LDR     r1, [r3, #CurSRIndex]
        EXIT

20      CMP     r0, #2
        BNE     %FT30
; Function code 2: return in r2 the sample rate for specified index in r1
        TEQ     r4, #0
        LDREQ   r2, [r3, #CurSRValue]
        EXIT    EQ                      ; just return last used if no device
        BL      SR_maptab               ; go get address of freq table entry
        CMP     r2, #0                  ; check for error
        BEQ     SR_badpar               ; handle error if any
        LDR     r2, [r2, #AudioRateTable_Frequency] ; pick up frequency
        EXIT                            ; all done!

30      CMP     r0, #3
        BNE     %FT40
; Function code 3: set sample rate as specified by index in r1
        TEQ     r4, #0
        BEQ     %BT15                   ; just return last used if no device
        BL      SR_maptab               ; get address of relevant main table entry
        MOVS    r4, r2                  ; move register, check for error (r2=0)
        BEQ     SR_badpar               ; handle error if any
        Push    "r1,r3"                 ; save new index
        LDRB    r2, [r4, #AudioRateTable_Period] ; get nominal period from table entry
        STRB    r2, [r10, #Period]      ; store away for Sound_Configure calls
        MOV     r3, r1                  ; r3 = new sample rate index
        LDR     r1, [r10, #Config]
        MOV     r0, r1, LSR #24         ; r0 = current flags
        MOV     r1, r1, LSL #16
        MOV     r1, r1, LSR #16         ; r1 = samples per buffer
        BL      process_oversample      ; work out whether o/s needed, fix SR index if so
        STRB    r0, [r10, #Flags]       ; and update flags
        ; Tell the HAL device about the new index
        Pull    "r0,lr"                 ; recover new index, SoundRMA
        STR     r3, [lr, #CurSRIndex_OS] ; save off oversampled index
        LDR     r1, [lr, #CurSRIndex]   ; get previous samplerate index for return to user
        STR     r0, [lr, #CurSRIndex]   ; save off new Sample Rate index
        LDR     r2, [lr, #CurSRValue]   ; get previous samplerate value for return to user
        LDR     r0, [r4, #AudioRateTable_Frequency] ; pick up frequency value from table entry
        STR     r0, [lr, #CurSRValue]   ; and save that too
        MOV     r0, #3
        PullEnv
        B       UpdateHALParams         ; update HAL on the way out
                                                

40                                      ; function code not 0..3: complain
SR_badpar
        ADR     r0, badparblock
        MOV     r1, #0
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        PullEnv
        MOV     pc, lr                  ; SWI will always set V

badparblock
        DCD     ErrorNumber_BadParameters
        DCB     "BadParm",0
        ALIGN

; SR_maptab: subroutine to convert r1 SR index to address of relevant
; entry in ftab, in r2.  Assumes r4 contains HAL device pointer.
; r2 is set to 0 on error. Doesn't alter any other registers.
SR_maptab
        LDR     r2, [r4, #HALDevice_AudioNumRates] ; get max
        SUB     r1, r1, #1              ; reduce index to 0-based range
        CMP     r1, r2                  ; check against limit (unsigned)
        MOVHS   r2, #0                  ; if out of range, mark error
        LDRLO   r2, [r4, #HALDevice_AudioRateTable] ; get table ptr
        ASSERT  AudioRateTableSize = 8
        ADDLO   r2, r2, r1, LSL #3      ; index into main table (8 bytes each)
        ADD     r1, r1, #1              ; put index back again always
        MOV     pc, lr                  ; return


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sound0ReadSysInfo: implements Sound_ReadSysInfo SWI.
;
; In:
;   r0 = reason code
;        1 -> return SoundDMA features
;        2 -> get current controller device name
; Other registers dependent on reason code
;
Sound0ReadSysInfo
        CMP     r0, #Sound_RSI_DefaultController
        LDR     r12, [r12]
        ADDLS   pc, pc, r0, LSL #2
        MOV     pc, lr
        MOV     pc, lr                              ; 0
        B       Sound0ReadSysInfo_Features          ; 1
        B       Sound0ReadSysInfo_DefaultController ; 2

; In:
;   r0 = 1 (reason code)
;
; Out:
;   r0 = 0
;   r1 = flags:
;        bit 0: Service_SoundRateChanging, Service_SoundEnabled, Service_SoundDisabled generated
;        bit 1: SelectDefaultController, EnumerateControllers, ControllerInfo SWIs supported
Sound0ReadSysInfo_Features
        MOV     r0, #0
        MOV     r1, #Sound_RSI_Feature_Service8910 :OR: Sound_RSI_Feature_ControllerSelection
        MOV     pc, lr

; In:
;   r0 = 2 (reason code)
;   r1 -> buffer
;   r2 = buffer length
;
; Out:
;   r0 = 0, or error (e.g. buffer overflow)
;   r2 updated with actual data length
;   buffer filled in with null-terminated controller device ID
Sound0ReadSysInfo_DefaultController ROUT
        Entry  "r2-r4"
        LDR     r2, [r12, #HALDevice]
        BL      DeviceList_FindByDevice
        CMP     r4, #0
        BEQ     SoundDevNotFoundErr
        ADD     r0, r4, #DeviceList_ID
        FRAMLDR r2
        BL      CopyStrToBuffer
        FRAMSTR r2
        MOVVC   r0, #0
        EXIT
SoundDevNotFoundErr
        PullEnv
        ADR     r0, ErrorBlock_SoundDevNotFound
        B       CopyError

        MakeInternatErrorBlock SoundDevNotFound,,M07


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sound0SelectDefaultController: implements Sound_SelectDefaultController SWI.
;
; In:
;   r0 -> space/control-terminated terminated controller device ID
;
; Out:
;   r0 = 0, or error
;
; Switches the current audio controller device
Sound0SelectDefaultController ROUT
        ALTENTRY
        LDR     r12, [r12]
        BL      DeviceList_FindByID
        CMP     r3, #0
        BEQ     SoundDevNotFoundErr
        ; Do nothing if this is already the active device
        LDR     r4, [r12, #HALDevice]
        LDR     r2, [r3, #DeviceList_AudioDevice]
        EORS    r0, r4, r2
        EXIT    EQ
        ; Stop current device - similar to Service_Hardware handling
        LDR     r10, =SoundLevel0Base
        CMP     r4, #0
        BEQ     %FT20
        Push    "r3"
        BL      PostFinal_DisableSound  ; (Corrupts r0,r2-r4)
        LDRB    r0, [r12, #ReenableFlag]
        BL      Finalise_Device
        STRB    r0, [r12, #ReenableFlag]
        Pull    "r3"
20
        ; Start new device
        MOV     r0, r3
        BL      TryInitialise_Device
        BLVC    Try_Reinit              ; (Corrupts R3)
        MOVVC   r0, #0
        ; Note - we don't fall back to the old device if this fails!
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sound0EnumerateControllers: implements Sound_EnumerateControllers SWI.
;
; In:
;   r0 = pointer to controller ID string to start from, or 0 or an empty string to start enumeration
;   r1 -> buffer for result (can be == r0)
;   r2 = length of buffer
;
; Out:
;   r0 = 0, buffer at r1 filled in with null-terminated ID of next controller. Buffer will be empty if end of list reached.
;   or r0 = error (e.g. buffer overflow)
;   r2 updated with actual data length
;
; Enumerates available controllers
Sound0EnumerateControllers ROUT
        ALTENTRY
        LDR     r12, [r12]
        CMP     r0, #0
        LDRNEB  r3, [r0]
        CMPNE   r3, #0
        ADDEQ   r3, r12, #DeviceList-DeviceList_Next
        BLNE    DeviceList_FindByID
        CMP     r3, #0
        LDRNE   r3, [r3, #DeviceList_Next]
        CMPNE   r3, #0
        ADREQ   r0, NullStr
        ADDNE   r0, r3, #DeviceList_ID
        BL      CopyStrToBuffer
        FRAMSTR r2
        MOVVC   r0, #0
        EXIT

NullStr
        DCB     0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sound0ControllerInfo: implements Sound_ControllerInfo SWI.
;
; In:
;   r0 -> space/control terminated controller device ID
;   r1 -> buffer for result
;   r2 = length of buffer
;   r3 = value to read:
;        0 -> read null terminated device name for display to user
;        1 -> read mixer device ptr
;        2 -> read supported sample rates (1 word per sample rate, Hz*1024)
;
; Out:
;   r0 = 0, buffer at r1 filled in with given value
;   or r0 = error (e.g. buffer overflow)
;   r2 updated with actual length of data
;
; Read info for a given controller device
Sound0ControllerInfo ROUT
        ALTENTRY
        LDR     r12, [r12]
        BL      DeviceList_FindByID
        CMP     r3, #0
        BEQ     SoundDevNotFoundErr
        FRAMLDR r4,,r3
        CMP     r4, #Sound_CtlrInfo_SampleRates
        ADDLS   pc, pc, r4, LSL #2
        B       %FT90
        B       Sound0ControllerInfo_DisplayName
        B       Sound0ControllerInfo_MixerDevice
        B       Sound0ControllerInfo_SampleRates

Sound0ControllerInfo_DisplayName
        LDR     r3, [r3, #DeviceList_AudioDevice]
        LDR     r0, [r3, #HALDevice_Description]
        ; See if we have a translation available for the device name
        BL      TranslateDeviceDescription
        BL      CopyStrToBuffer
        FRAMSTR r2
        MOVVC   r0, #0
        EXIT

Sound0ControllerInfo_MixerDevice
        LDR     r0, [r3, #DeviceList_AudioDevice]
        ADD     r0, r0, #HALDevice_AudioMixer
      [ SupportSoftMix
        LDR     lr, [r0]
        CMP     lr, #0
        ADDEQ   r0, r3, #DeviceList_SoftMixDevice
      ]
        MOV     r3, #4
        BL      CopyDataToBuffer
        FRAMSTR r2
        MOVVC   r0, #0
        EXIT

Sound0ControllerInfo_SampleRates
        LDR     r3, [r3, #DeviceList_AudioDevice]
        LDR     r0, [r3, #HALDevice_AudioRateTable]
        LDR     r3, [r3, #HALDevice_AudioNumRates]
        MOV     r3, r3, LSL #2
        BL      CopySampleRatesToBuffer
        FRAMSTR r2
        MOVVC   r0, #0
        EXIT      

90
        PullEnv
        ADR     r0, badparblock
        B       CopyError

TranslateDeviceDescription
        ; In: r0 = description
        ;     r3 = device
        ;     r12 = SoundRMA
        ; Out: r0 updated if possible
        Entry   "r0-r3", 32
        BL      open_messagefile
        ADRVC   r0, DisplayNameTok
        MOVVC   r1, sp
        MOVVC   r2, #Proc_LocalStack
        BLVC    CopyStrToBuffer
        SUBVC   r2, r2, #1
        ADDVC   r1, r1, r2
        RSBVC   r2, r2, #Proc_LocalStack
      [ UseLDRSH
        LDRVCH  r0, [r3, #HALDevice_ID]
      |
        LDRVCB  r0, [r3, #HALDevice_ID]
        LDRVCB  lr, [r3, #HALDevice_ID+1]
        ORRVC   r0, r0, lr, LSL #8
      ]
        SWIVC   XOS_ConvertHex4
        ADDVC   r0, r12, #MessageFile_Block
        MOVVC   r1, sp
        MOVVC   r2, #0
        SWIVC   XMessageTrans_Lookup
        FRAMSTR r2,VC,r0
        EXIT

DisplayNameTok
        DCB     "HAL_Name_", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In:
;   r0 -> control-terminated string
;   r1 -> destination buffer, or 0 just to check length
;   r2 = buffer length
;   r12 = SoundRMA
;
; Out:
;   Buffer updated (with null terminated string) if length sufficient
;   r2 = required length
;   r0 preserved or error (buffer overflow)
;
CopyStrToBuffer ROUT
        Entry   "r3"
        ; Calculate required length
        MOV     r3, #0
10
        LDRB    lr, [r0, r3]
        ADD     r3, r3, #1
        CMP     lr, #32
        BHS     %BT10
        ; Check
        CMP     r1, #&4000 ; Basic sanity test
        CMPHS   r2, r3
        MOV     r2, r3
        BLO     %FT90
        ; Copy
        SUBS    r3, r3, #1
        MOV     lr, #0 ; Null terminate
        STRB    lr, [r1, r3]
        EXIT    EQ
20
        SUBS    r3, r3, #1
        LDRB    lr, [r0, r3]
        STRB    lr, [r1, r3]
        BNE     %BT20
        EXIT
90
        PullEnv
        ADR     r0, ErrorBlock_BuffOverflow
        B       CopyError

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In:
;   r0 -> source value
;   r1 -> destination buffer, or 0 just to check length
;   r2 = buffer length
;   r3 = source length
;   r12 = SoundRMA
;
; Out:
;   Buffer updated if length sufficient
;   r2 = required length
;   r0 preserved or error (buffer overflow)
;
CopyDataToBuffer
        ALTENTRY
        ; Check
        CMP     r1, #&4000 ; Basic sanity test
        CMPHS   r2, r3
        MOV     r2, r3
        BLO     %BT90
        ; Copy
        B       %BT20

; Special-case CopyDataToBuffer for copying the sample rate list
CopySampleRatesToBuffer
        ALTENTRY
        ; Check
        CMP     r1, #&4000 ; Basic sanity test
        CMPHS   r2, r3
        MOV     r2, r3
        BLO     %BT90
        ; Copy
30
        SUBS    r3, r3, #4
        ASSERT  AudioRateTableSize = 8
        ASSERT  AudioRateTable_Frequency = 0
        LDR     lr, [r0, r3, LSL #1]
        STR     lr, [r1, r3]
        BNE     %BT30
        EXIT

        MakeInternatErrorBlock BuffOverflow,,BufOFlo

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Initialise_Module ROUT
        Entry   "r7, r8, r10, r11"

        LDR     r2, [r12]
        TEQ     r2, #0
        BNE     %FT00 ; (should probably make sure workspace is right size!)

        LDR     r3, =WorkSpaceSize
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS

        STR     r2, [r12]

00      LDR     r10, =SoundLevel0Base
        MOV     r12, r2
        STR     r2, [r10, #SoundRMA]    ; keep separate record of RMA area base
        MOV     r0, #0
05
        SUBS    r3, r3, #4
        STR     r0, [r2, r3] ; clear RMA workspace to 0
        BNE     %BT05
        MOV     r5, r2

  [ TimingCode
        Push    "r9"
        MOV     r0, #TimingTimer
        MOV     r8, #OSHW_CallHAL
        MOV     r9, #EntryNo_HAL_TimerMaxPeriod
        SWI     OS_Hardware
        STR     r0, [r5, #TimeMaxPeriod]
        MOV     r1, r0
        MOV     r0, #TimingTimer
        MOV     r9, #EntryNo_HAL_TimerSetPeriod
        SWI     OS_Hardware
        MOV     r0, #TimingTimer
        MOV     r9, #EntryNo_HAL_TimerGranularity
        SWI     OS_Hardware
        STR     r0, [r5, #TimeGran]
        MOV     r8, #OSHW_LookupRoutine
        MOV     r9, #EntryNo_HAL_TimerReadCountdown
        SWI     OS_Hardware
        STR     r0, [r5, #TimeFunc]
        STR     r1, [r5, #TimeWS]
        Pull    "r9"
  ]

; Zero DMA buffer
        LDR     r4, =SoundDMABuffers
        ADD     r14, r4, #SoundDMABufferSize * 2
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
10      STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        CMP     r4, r14
        BLT     %BT10

; Get physical address of sound buffer 0.  This is fixed at a single
; value on both MEMC1 and MEMC2 systems, but variable (obtained via new
; SWI) on IOMD systems.  The logical address is fixed (at &01F06000) on
; all systems.

        LDR     r2, =SoundDMABuffers    ; fixed logical address of 2 soundbuffers
        SUB     sp, sp, #12             ; get temp space for a single-entry Page Block
        STR     r2, [sp, #1*4]          ; write addr into l.a. slot of page block
        MOV     r1, sp                  ; point at Page Block as SWI arg
        MOV     r2, #1                  ; 1 entry to update
        MOV     r0, #&2200              ; convert log address to phys address
        SWI     XOS_Memory              ; go do the conversion
        LDR     r1, [sp, #2*4]          ; pick up physical address into R1
        ADD     sp, sp, #12             ; release temp space
        EXIT    VS                      ; ought never to fail!
        MOV     r0, #&80000000          ; Semaphore off until we've found a device
        ADD     r1, r1, #SoundDMABufferSize
        ADRL    r2, ProtoS0S            ; address sound0segment prototype
        LDMIA   r2, {r2,r3,r4,r5,r6,r7,r8}; load it up (from Buff0 onwards)
        STMIA   r10, {r0-r8}            ; Set up Sound0Segment, first 9 words

        ADD     r0, r10, #Images        ; address user-level image positions
        BL      ConvImages              ; convert to compact version for prog'ing
        STR     r0, [r10, #ImagesC_N]   ; compacted form, into top of pipeline
        STR     r0, [r10, #ImagesC_H]   ; and for next buffer

        ; go fetch 16-bit sound control info from CMOS
        MOV     r0, #OsByte_ReadCMOS
        MOV     r1, #PrintSoundCMOS     ; get extended (VIDC20) sound bits
        SWI     XOS_Byte                ; "won't" fail

; R2 is byte from CMOS
; bit 7 is quality bit (do interpolation to maximise quality)
; bit 6:5  form 16-bit sound control value (VIDC20 specific, irrelevant to us)
        TST     r2, #&80                ; Extract oversample setting
        ORRNE   r4, r4, #OversampleFlag :SHL: 24
        STR     r4, [r10, #Config]      ; store config, with correct flags in

        LDR     r0, =SCRate*1024
        STR     r0, [r12, #CurSRValue]  ; set sensible CurSRValue for if we find no device on startup

        ; Build device list (may fail, but error can be ignored)
        BL      Initialise_DeviceList

        ; Set up DMA (+ select default device)
        BL      Initialise_DMA
 [ UseNEON
        ; Get our VFPSupport context
        BLVC    Initialise_NEON
 ]
        ; If we failed to init, set the flag so that we'll try again later
        MOVVS   r0, #1
        STRVSB  r0, [r12, #ReenableFlag]
        MVNVS   r0, #0
        STRVS   r0, [r12, #HALSRIndex] ; and flag that we should reprogram the device upon initialisation
        ; ... else clear semaphore so that Sound0Reenable will actually turn sound on
        MOVVC   r0, #0
        STRVC   r0, [r10, #Semaphore]

        MOV     r0, r4, LSR #24         ; get log2nchan + flags byte
        AND     r0, r0, #3              ; get log2nchan alone into r0
        LDR     r1, [r10, #SoundRMA]
      [ :LNOT: UseNEON
        ADD     r1, r1, #LinConvCode    ; get address to put code
      ]
        MOV     r2, #SCSoundGain        ; set up default soundgain value
        STRB    r2, [r10, #SoundGain]
        STRB    r2, [r10, #SoundGain_C]
        LDR     r2, [r10, #ImagesC_H]   ; address stereo position set
        STR     r2, [r10, #ImagesC_C]   ; mark as current set
        STRB    r0, [r10, #Log2nchan_C] ; do same for log2nchan
        ORR     r2, r2, #SCSoundGain :SHL: 24 ; combine default soundgain into r2
        BL      compile                 ; go call compiler to set it all up

        MOV     r6, r4, LSL #16         ; build 16-bit Length (in sample times)
        MOV     r6, r6, LSR #16
        MOV     r7, r4, LSR #24         ; build LogChannel count in r7
        AND     r7, r7, #3
        MOV     r6, r6, LSL r7          ; build DAG End (i.e. length in bytes) in r6

        MOV     r0, r7                  ; r0:= log2(channels)
        MOV     r1, r4, LSL #16         ; r1 = samples per buffer
        MOV     r1, r1, LSR #16
        MOV     r2, r4, LSR #16         ; 8-bit period
        AND     r2, r2, #&FF
        MOV     r3, #0
        MOV     r4, #0
        SEI     SVC32_mode              ; IRQ off please
        BL      Sound0InitConfig        ; Configure initial sample rate & buffer size
        BL      Sound0Reenable          ; Turn on system
        CLI     SVC32_mode              ; Reenabled IRQs

        MOV     r0, #Service_SoundLevel0Alive
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall

        CLRV
        EXIT

90
        ; We can't initialise for some reason
        ; Shutdown everything and throw an error
        Push    "r0"
        BL      Finalise_Device ; Also shuts down DMA
      [ UseNEON
        BL      Finalise_NEON
      ]
        BL      close_messagefile
        Pull    "r0"
        SETV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module_RTSupport
        = "RTSupport", 0
Module_DMAManager
        = "DMAManager", 0
 [ UseNEON
Module_VFPSupport
        = "VFPSupport", 0
 ]
        ALIGN

;Ursula format
;
; We need to use service calls to watch out for the following events:
; * Init/finalisation of RTSupport
; * Init/finalisation of DMAManager (if required by HAL device)
; * Init/finalisation of HAL device
 [ UseNEON
; * Init/finalisation of VFPSupport
 ]
; If any of the above die, we release the relevant resources, and make sure
; sound is disabled. If the service then becomes available again, without any
; intermediate calls to Sound_Enable, we automatically re-enable sound output
; to ensure a simple *RMEnsure of an updated module doesn't result in sound
; being left off
       ASSERT   Service_Hardware < Service_ModulePostInit 
       ASSERT   Service_ModulePostInit < Service_ModulePostFinal
;
UServTab
        DCD     0
        DCD     UService - Module_Base
        DCD     Service_Hardware
        DCD     Service_ModulePostInit
        DCD     Service_ModulePostFinal
        DCD     0
        DCD     UServTab - Module_Base
Intercept_Services ROUT
        MOV     r0,r0
        TEQ     r1,#Service_Hardware
        TEQNE   r1,#Service_ModulePostInit
        TEQNE   r1,#Service_ModulePostFinal
        MOVNE   PC,LR
UService
        Entry   "r0,r2-r6,r10"
        LDR     r12, [r12]
        TEQ     r1,#Service_Hardware
        BEQ     UService_Hardware
        ; Which module is this?
        ADR     r0, Module_RTSupport
        ADR     r3, PostFinal_RTSupport
        BL      strcmp_branch
        ADR     r0, Module_DMAManager
        ADR     r3, PostFinal_DMAManager
        BL      strcmp_branch
      [ UseNEON
        ADR     r0, Module_VFPSupport
        ADR     r3, PostFinal_VFPSupport
        BL      strcmp_branch
      ]
UService_Exit
        CLRV
        EXIT

UService_Hardware ROUT
        CMP     r0, #1
        BHI     UService_Exit
        ; Only pay attention to audio controller devices
      [ UseLDRSH
        LDRH    r4, [r2, #HALDevice_Type]
      |
        LDR     r4, [r2, #HALDevice_Type]
        MOV     r4, r4, LSL #16
        MOV     r4, r4, LSR #16
      ]
        LDR     r3, =HALDeviceType_Audio :OR: HALDeviceAudio_AudC
        CMP     r4, r3
        BNE     UService_Exit
        ; Is the API version suitable?
        LDR     lr, [r2, #HALDevice_Version]
        CMP     lr, #(MaxDeviceVersion+1):SHL:16
        BHS     UService_Exit
        CMP     lr, #MinDeviceVersion:SHL:16
        BLO     UService_Exit
        ; Device has passed our initial sanity checks - process for addition/removal
        CMP     r0, #1        
        BLO     %FT50
        ; Device stopping. Is it our sound device?
        LDR     r0, [r12, #HALDevice]
        CMP     r0, r2
        BNE     %FT10
        LDR     r10, =SoundLevel0Base
        BL      PostFinal_DisableSound ; Disable sound, set reenable flag
        LDRB    r0, [r12, #ReenableFlag] ; Preserve flag (device release will indirectly clobber it via Sound0Enable)
        BL      Finalise_Device ; Release device
        STRB    r0, [r12, #ReenableFlag]
10
        ; Remove from device list if present there
        FRAMLDR r2 ; Corrupted by PostFinal_DisableSound above
        BL      DeviceList_Remove
        B       UService_Exit

50
        ; Device starting. Add to device list.
        BL      DeviceList_Add
        BVS     UService_Exit
        ; Are we looking for a sound device?
        LDR     r2, [r12, #HALDevice]
        CMP     r2, #0
        BNE     UService_Exit
        ; Does it work? (r0 = new device list entry)
        BL      TryInitialise_Device
        BVS     UService_Exit
        ; Yes; turn sound back on if necessary
        LDR     r10, =SoundLevel0Base
        ADR     lr, UService_Exit
        B       Try_Reinit
        

strcmp_branch   ROUT
        ; Case-sensitive comparison of r0 with r2
        ; Returns if strings differ
        ; Else branches to Try_Reinit if module is initialising, or r3 if module finalising
        ; r0,r4-r6 corruptible
        MOV     r4, r2
10
        LDRB    r5, [r4], #1
        LDRB    r6, [r0], #1
        CMP     r5, r6
        MOVNE   pc, lr
        CMP     r5, #0
        BNE     %BT10
        ADR     lr, UService_Exit ; Go straight to service exit on return
        LDR     r10, =SoundLevel0Base ; Set up for Sound0Enable calls (sigh)
        CMP     r1, #Service_ModulePostFinal
        BNE     Try_Reinit
        MOV     pc, r3

        ; r0, r2-r6 corruptible in following routines
        ; r10 = SoundLevel0Base
        ; r12 = SoundRMA

PostFinal_RTSupport ROUT
        ; Only need to disable if RTSupport is in use
        LDR     r0, [r12, #RTSup_Handle]
        CMP     r0, #0
        MOVEQ   pc, lr
PostFinal_DisableSound ; Corrupts r0,r2-r4
        ; Ensure sound off
        MOV     r3, lr
        MOV     r0, #1
        PHPSEI  r2
        LDRB    r4, [r12, #ReenableFlag] ; Get flag before we call Sound0Enable (as Sound0Enable will clear it)
        BL      Sound0Enable
        PLP     r2
        ORR     r4, r4, r0, LSR #1 ; Set flag if sound was on, preserve otherwise
        STRB    r4, [r12, #ReenableFlag]
        MOV     pc, r3

PostFinal_DMAManager ROUT
        ; Are we actually using DMAManager?
        LDR     r0, [r12, #DMAChannel]
        MOVEQ   pc, lr
        ; Ensure sound is off
        ; (We should have received a DMACompleted callback, which would have
        ; triggered a SoundDiedFunc OS callback, but if DMAManager is dying that
        ; callback won't have happened yet. Luckily we're in the foreground
        ; here, so we can cancel the callback and stop sound now.)
        MOV     r5, lr
        BL      PostFinal_DisableSound
        ; Forget our DMA channel handle
        MOV     r0, #0
        STR     r0, [r12, #DMAChannel]
        MOV     pc, r5

 [ UseNEON
PostFinal_VFPSupport ROUT
        ; VFPSupport issues Service_ModulePostFinal from within its finalisation code, allowing us to clean up properly
        ; Ensure sound is off
        MOV     r5, lr
        BL      PostFinal_DisableSound
        ; Release our VFPSupport context
        BL      Finalise_NEON
        ; Done!
        MOV     pc, r5
 ]        

Try_Reinit ROUT
        ; Try reinitialising sound if appropriate
        ; In: r10 = SoundLevel0Base, r12 = SoundRMA
        ; Out: r0 = error
        ;      Corrupts r3
        LDRB    r3, [r12, #ReenableFlag]
        Debug   swi,"Try_Reinit: flag=", r3
        CMP     r3, #0
        MOVEQ   pc, lr
        Entry   "r0,r5,r11"
        ; Initialise device
        BL      Initialise_Device
        FRAMSTR r0, VS
        EXIT    VS
        ; Re-enable sound
        MOV     r0, #2
        PHPSEI  r5
        BL      Sound0Enable
        PLP     r5
        MOVVC   r3, #0 ; Something else might still be dead; only clear flag on success
        Debug   swi,"Try_Reinit: new flag=", r3
        STRB    r3, [r12, #ReenableFlag]
        FRAMSTR r0, VS
        EXIT

RemoveCallbacks ROUT
        ; Remove any pending sound reset/died callbacks
        ; In: r12 = SoundRMA
        Entry   "r0,r1"
        ADRL    r0, SoundResetFunc
        MOV     r1, r12
        SWI     XOS_RemoveCallBack
        ADRL    r0, SoundDiedFunc
        SWI     XOS_RemoveCallBack
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable, r10 = fatality indication

Finalise_Module Entry "r10, r11"

        LDR     r12, [r12]

        LDR     r10, =SoundLevel0Base

        MOV     r0, #Service_SoundLevel0Dying
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall         ; Can't stop me!

; Shutdown the audio device (also stops sound, releases DMA)
        BL      Finalise_Device

; Free device list
        BL      Finalise_DeviceList

      [ UseNEON
; Release the VFP context
        BL      Finalise_NEON
      ]

        BL      close_messagefile

        CLRV
        EXIT                            ; Don't refuse to die


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


 [ UseNEON
Initialise_NEON ROUT
        ; Ensure we have a VFPSupport context and that NEON is available
        ; In: r12 = SoundRMA
        ; Out: Error on failure, else all regs preserved
        Entry   "r0-r4"
        LDR     r0, [r12, #VFPSup_Context]
        CMP     r0, #0
        EXIT    NE
        ; Check that VFPSupport + NEON is available
        MOV     r0, #VFPSupport_Features_SystemRegs
        SWI     XVFPSupport_Features
        BVS     %FT10
        ; Check FPSID for VFPv3+
        TST     r0, #&700000 ; These bits are set for non-ARM subarchitecture, or VFPv1
        BNE     %FT10
        TST     r0, #&0e0000 ; These bits are zero for VFPv1/v2
        ; Must be VFPv3+, with MVFR0/MVFR1 available. Check MVFR1 for NEON
        TSTNE   r2, #&f000
        BEQ     %FT10
        ; Get the FastAPI routines
        SWI     XVFPSupport_FastAPI
        STRVC   r0, [r12, #VFPSup_WS]
        STRVC   r4, [r12, #VFPSup_ChangeCtx]
        ; Create a context
        MOVVC   r0, #0
        MOVVC   r1, #32
        MOVVC   r2, #0
        MOVVC   r3, #0
        SWIVC   XVFPSupport_CreateContext
        STRVC   r0, [r12, #VFPSup_Context]
        STRVS   r0, [sp]
        EXIT
10
        ADR     r0, ErrorBlock_VFPSupport_NoHW2
        BL      CopyError
        STR     r0, [sp]
        SETV
        EXIT

        MakeInternatErrorBlock VFPSupport_NoHW2,,M05

Finalise_NEON ROUT
        ; Release our VFPSupport context
        ; In: r12 = SoundRMA
        ; Out: Error on failure, else all regs preserved
        ; Sound must be off!
        Entry   "r0-r1"
        LDR     r0, [r12, #VFPSup_Context]
        CMP     r0, #0
        EXIT    EQ
        MOV     r1, #0
        STR     r1, [r12, #VFPSup_Context] ; Even if we fail, we want to forget the old context
        SWI     XVFPSupport_DestroyContext
        STRVS   r0, [sp]
        EXIT
 ]

TryInitialise_Device ROUT
        ; Try initialising the given audio device
        ; In: r0 -> device list entry
        ;     r12 = SoundRMA
        ; Out: V clear -> OK
        ;      V set, R0 -> error
        Entry   "r0-r5,r8-r12"
        LDR     r4, [r0, #DeviceList_AudioDevice]
        Debug   swi,"TryInitialise_Device",r4
        ; Try to activate it
        MOV     r5, r12 ; r5 becomes SoundRMA
        MOV     r0, r4
        MOV     lr, pc
        LDR     pc, [r4, #HALDevice_Activate]
        CMP     r0, #0                  ; successful?
        BEQ     %FT90 ; Go back and look for another
        ; Else device is good, use it
        LDR     r0, [r4, #HALDevice_Device]
        STR     r4, [r5, #HALDevice]
        STR     r0, [r5, #Sound_device]
        ; Update our stereo reverse flag
        LDR     r8, =SoundLevel0Base
        LDRB    r9, [r8, #Flags]
        BIC     r9, r9, #DoReverse
        LDR     lr, [r4, #HALDevice_Version]
        CMP     lr, #2:SHL:16
        LDRGE   lr, [r4, #HALDevice_AudioFlags]
        ASSERT  AudioFlag_StereoReverse = 1
        ASSERT  DoReverse = &20
        ANDGE   lr, lr, #AudioFlag_StereoReverse
        ORRGE   r9, r9, lr, LSL #5
        STRB    r9, [r8, #Flags]
      [ SupportSoftMix
        ; Update software mix setting
        FRAMLDR lr,,r0 ; Can't FRAMLDR within the Push block
        Push    "r0-r3"
        LDR     r0, [lr, #DeviceList_SoftMixDevice]
        CMP     r0, #0
        LDRNE   r2, [r0, #SoftMixMute]
        LDRNE   r3, [r0, #SoftMixGain]
        MOVEQ   r2, #0 ; Set to 0 gain if software mix not required
        MOVEQ   r3, #0
        BL      SoftMixDev_Apply
        Pull    "r0-r3"
      ]
        ; Claim its vector and enable interrupts
        MOV     r8, #OSHW_CallHAL
        CMP     r0, #-1
        BEQ     %FT08
        ADR     r1, Module_VectorCode
        LDR     r2, =SoundLevel0Base
        SWI     XOS_ClaimDeviceVector
        BICVC   r0, r0, #1:SHL:31
        MOVVC   r9, #EntryNo_HAL_IRQEnable
        SWIVC   XOS_Hardware
        BVS     %FT80
08
        STRB    r8, [r5, #ResetPending] ; Allow reset callbacks to be registered

        ; If HALSRIndex is -1, it means we previously lost a device and this is the new device that's replacing it
        ; Checking HALSRIndex is important in order to avoid trying to reprogram the first device we find during module init (that happens later on during startup)
        LDR     r0, [r5, #HALSRIndex]
        CMP     r0, #-1
        BNE     %FT70
        ; We need to reset our buffer size & sample rate to work with this new device
        ; Scan sample rate table for closest match to previous rate
        LDR     r1, [r4, #HALDevice_AudioNumRates]
        LDR     r0, [r4, #HALDevice_AudioRateTable]
        ASSERT  AudioRateTableSize = 8
        ASSERT  AudioRateTable_Frequency = 0
        ADD     r0, r0, r1, LSL #3
        LDR     r2, [r5, #CurSRValue]
10
        LDR     r3, [r0, #-AudioRateTableSize]!
        CMP     r3, r2
        CMPHI   r1, #1
        SUBHI   r1, r1, #1
        BHI     %BT10
        ; Set rate
        ; Note - must be done via Sound0Config, as this will also cause buffer size to be verified against device limits
        LDRB    r2, [r0, #AudioRateTable_Period-AudioRateTable_Frequency]
        MOV     r0, #0
        MOV     r1, #0
        MOV     r3, #0
        MOV     r4, #0
        LDR     r10, =SoundLevel0Base
        PHPSEI  r5
        Debug   swi,"TryInitialise_Device switching to sample period ",r2
        LDR     r8, [r10, #Semaphore]
        MOV     r9, #&80000000
        STR     r9, [r10, #Semaphore] ; Ensure semaphore set to prevent Sound_Enable calls from within Sound_Config
        BL      Sound0Config
        STR     r8, [r10, #Semaphore]
        PLP     r5
70
        Debug   swi,"TryInitialise_Device OK"
        CLRV    ; Clobbers error from Sound0Config - is this wise?
        EXIT
80
        ; Something bad happened; release vector and shutdown device
        STR     r0, [sp]
        MOV     r12, r5 ; Restore WS ptr
        BL      Finalise_Device
        SETV
        EXIT

90
        PullEnv
        ADR     r0, ErrorBlock_BadSoundDevice
        SETV
        B       CopyError

Initialise_Device ROUT
        ; Search for and initialise a HAL audio device
        ; In: r12 = SoundRMA
        ; Out: Error on failure, else all regs preserved
        Entry   "r0-r2,r8"
        LDR     r0, [r12, #HALDevice]
        CMP     r0, #0
        EXIT    NE
        ; Look through our device list for a device which will initialise OK
        LDR     r1, [r12, #DeviceList]
10
        MOVS    r0, r1
        BNE     %FT20
        ADR     r0, ErrorBlock_NoSoundDevices
        BL      CopyError
        SETV
        B       %FT15
20
        BL      TryInitialise_Device
        EXIT    VC
        LDR     r1, [r1, #DeviceList_Next]
        TEQ     r1, #0
        BNE     %BT10 ; Try next device if there is one, else return this error        
15
        STR     r0, [sp]
        EXIT

        MakeInternatErrorBlock NoSoundDevices,,M04
        MakeInternatErrorBlock BadSoundDevice,,M06 ; TODO should be generic OS error?

Finalise_Device ROUT
        ; Disable sound and release the HAL device (+ DMA)
        ; In: r12 = SoundRMA
        ; Out: Error on failure, else all regs preserved
        Entry   "r0-r5,r12"
        LDR     r0, [r12, #HALDevice]
        CMP     r0, #0
        EXIT    EQ
        Debug   swi,"Finalise_Device",r0
        ; Check for any pending reset callbacks
        PHPSEI  r5, r0
        BL      RemoveCallbacks
        MOV     r0, #1
        STRB    r0, [r12, #ResetPending] ; Avoid any further callback registrations
        BL      Sound0Enable            ; Ensure sound off
        PLP     r5                      ; Reenable IRQs
        ; Release the IRQ handler
        ADR     r1, Module_VectorCode
        LDR     r2, =SoundLevel0Base
        LDR     r0, [r12, #Sound_device]
        CMP     r0, #-1
        SWINE   XOS_ReleaseDeviceVector ; release device vector
        ; Release the DMA channel
        BL      Finalise_DMA
        ; Deactivate the device
        LDR     r0, [r12, #HALDevice]
        MOV     r1, #0
        STR     r1, [r12, #HALDevice]
        MOV     r1, #1
        STR     r1, [r12, #CurSRIndex] ; claim we're using first SR index (while we have no device, we only report that we support one rate)
        MVN     r1, #0
        STR     r1, [r12, #HALSRIndex] ; and flag that we should reprogram the device upon re-registration
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_Deactivate] ; remember this corrupts r12
        CLRV
        EXIT                            ; Don't refuse to die        

Initialise_DMA ROUT
        ; Register with DMAManager (+ find/init HAL device)
        ; In: r12 = SoundRMA
        ; Out: Error on failure, else all regs preserved
        Entry   "r0-r7"
        LDR     r0, [r12, #DMAChannel]
        CMP     r0, #0
        EXIT    NE
        BL      Initialise_Device ; We need to know which channel to use
        BVS     %FT10
        ; Does this device need DMAManager?
        LDR     r7, [r12, #HALDevice]   
        LDR     r0, [r7, #HALDevice_Version]
        CMP     r0, #2:SHL:16 ; API 2+?
        LDRHS   r0, [r7, #HALDevice_AudioCustomDMAEnable]
        CMPHS   r0, #1 ; With AudioCustomDMAEnable?
        EXIT    HS
        ; Register with DMAManager
        LDR     r7, [r12, #HALDevice]   
        ADD     r7, r7, #HALDevice_AudioDMAParams
        ADD     r4, r12, #DMARoutines ; Use our DMA routines
        ADR     r0, DMAEnable
        ADR     r1, DMADisable
        ADR     r2, DMAStart
        ADR     r3, DMACompleted
        ADR     lr, DMASync
        STMIA   r4,{r0-r3,lr}
        LDMIA   r7, {r0,r1,r2,r3,r7} ; Get remaining DMA_RegisterChannel params
        MOV     r5, r12
        SWI     XDMA_RegisterChannel
        STRVC   r0, [r12, #DMAChannel]
        EXIT    VC
10
        STR     r0, [sp]
        EXIT        

Finalise_DMA
        ; Deregister with DMAManager
        ; In: r12 = SoundRMA
        ; Out: Error on failure, else all regs preserved
        ; Sound must be disabled!
        Entry   "r0"
        LDR     r0, [r12, #DMAChannel]
        CMP     r0, #0
        EXIT    EQ
        SWI     XDMA_DeregisterChannel
        STRVS   r0, [sp]
        MOV     r0, #0
        STR     r0, [r12, #DMAChannel] ; Forget handle even if we failed?
        EXIT

Initialise_RTSupport
        ; Register with RTSupport
        ; In: r12 = SoundRMA
        ; Out: Error on failure, else all regs preserved
        Entry   "r0-r7"
        LDR     r1, [r12, #HALDevice]
        LDR     r0, [r1, #HALDevice_Version]
        CMP     r0, #3:SHL:16 ; API 3+?
        MOVLO   r0, #0
        LDRHS   r0, [r1, #HALDevice_AudioFlags]
        TST     r0, #AudioFlag_Synchronous ; Don't need RTSupport if device is happy with synchronous processing
        LDREQ   r0, [r12, #RTSup_Handle]
        CMPEQ   r0, #0
        EXIT    NE
        MOV     r0, #0
        ADRL    r1, RTSup_Code
        MOV     r2, r12 ; R0 gets SoundRMA
        LDR     r3, =SoundLevel0Base ; R12 gets SoundLevel0Base
        MOV     r4, r12
        STR     r0, [r4, #RTSup_Pollword]!
        MOV     r5, #0 ; R10 is buffer index to fill
        MOV     r6, #0 ; No SYS stack needed
        ADR     r7, RTSup_Prio
        SWI     XRT_Register
        STRVC   r0, [r12, #RTSup_Handle]
        STRVS   r0, [sp]
        EXIT

Finalise_RTSupport
        ; Deregister with RTSupport
        ; In: r12 = SoundRMA
        ; Out: Error on failure, else all regs preserved
        Entry   "r0-r1"
        LDR     r1, [r12, #RTSup_Handle]
        CMP     r1, #0
        EXIT    EQ
        MOV     r0, #0
        STR     r0, [r12, #RTSup_Handle]
        SWI     XRT_Deregister
        STRVS   r0, [sp]
        EXIT

RTSup_Prio
        = "AudioFill:192",0
        ALIGN

        LTORG
        

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Interrupt Service Routine and DMA handlers
        OPT     OptPage

Module_VectorCode
        ; IRQ from audio controller. Find out what's up!
        ; r12 = SoundLevel0Base
        ; r0-r3, r12 trashable
        Entry   "r4,r8-r9"
        ; Drop into SVC mode so we can call SWIs
        SetMode SVC32_mode,,,I32_bit
        Push    "lr"
        LDR     r4, [r12, #SoundRMA]
        LDR     r0, [r4, #HALDevice]
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_AudioIRQHandle]
        CMP     r0, #1
        LDREQB  r1, [r4, #ResetPending]
        CMPEQ   r1, #0
        BNE     %FT10
        ADR     r0, SoundResetFunc
        MOV     r1, r4
        SWI     XOS_AddCallBack
        MOVVC   r0, #1
        STRVCB  r0, [r4, #ResetPending]
10
        LDR     r0, [r4, #Sound_device]
        MOV     r8, #OSHW_CallHAL
        MOV     r9, #EntryNo_HAL_IRQClear
        BIC     r0, r0, #1:SHL:31
        SWI     XOS_Hardware
        ; Back to IRQ
        Pull    "lr"
        SetMode IRQ32_mode,,,I32_bit
        EXIT

SoundResetFunc
        ; r12 = SoundRMA
        Entry   "r0-r1"
        MOV     r0, #1
        SWI     XSound_Enable
        ; Sound (should) be disabled now, so clear reset flag
        MOV     r1, #0
        STRB    r1, [r12, #ResetPending]
        EXIT    VS
        CMP     r0, #1 ; Only re-enable if we were enabled to start with
        MOVNE   r0, #2
        SWINE   XSound_Enable
        EXIT

SoundDiedFunc
        ; r12 = SoundRMA
        ; Disable sound and update the reenable flag
        Entry   "r0,r2-r4,r10"
        LDR     r10, =SoundLevel0Base
        BL      PostFinal_DisableSound
        EXIT
        

; DMAManager callbacks
; For each of these routines:
; r12 = SoundRMA

DMAStart
        CLRV
DMAEnable
DMADisable
        MOV     pc, lr

DMACompleted
        Entry   "r0-r1"
        ; Forget our DMA tag
        MOV     r1, #0
        STR     r1, [r12, #DMATag]
        EXIT    VC
        ; Something bad happened
        ; This is most likely DMAManager about to die on us
        ; We might not be able to stop sound output from here, so set a callback
        SetModeSEI SVC32_mode,,r2 ; Switch to SVC with IRQs off
        Push    "r2,lr"
        ; Prevent any new reset attempts
        MOV     r0, #1
        STRB    r0, [r12, #ResetPending]
        ; Cancel any existing callbacks
        BL      RemoveCallbacks
        ; Now register new callback
        ADR     r0, SoundDiedFunc
        MOV     r1, r12
        SWI     XOS_AddCallBack
        Pull    "r2,lr"
        MSR     CPSR_c, r2
        ; TODO - Make a note of the error so we can report it sometime later?
        EXIT

DMASync
        ; Wake up our RTSupport routine
        Entry
        ; Atomic increment of pollword
        PHPSEI  r0
        LDR     lr, [r12, #RTSup_Pollword]
        ADD     lr, lr, #1
        STR     lr, [r12, #RTSup_Pollword]
        PLP     r0
        MOV     r0, #0
        EXIT

; Custom DMA callback (asynchronous)
; On entry:
;  r0 = reason (reserved, should be 0)
;  r1 = SoundRMA
;  SWI-safe privileged mode, IRQ status undefined
; On exit:
;  r0-r3, r12 corrupted
CustomDMASync_Async
        ; Wake up our RTSupport routine
        Entry
        ; Atomic increment of pollword
        PHPSEI  r0
        LDR     r2, [r1, #RTSup_Pollword]
        ADD     r2, r2, #1
        STR     r2, [r1, #RTSup_Pollword]
        PLP     r0
        CMP     r2, #1 ; Just woken up?
        EXIT    NE
        ; Try yielding, we may have been called from foreground
        MOV     r1, pc ; Any non-zero pollword will do
        SWI     XRT_Yield
        EXIT        

; Custom DMA callback (synchronous)
; On entry:
;  r0 = bit 0: buffer index to fill
;       other bits: reserved (should be 0)
;  r1 = SoundRMA
;  SWI-safe privileged mode, IRQ status undefined
; On exit:
;  r0-r3, r12 corrupted
CustomDMASync_Sync
        Entry   "r4-r11"
        MOV     r11, r1
        MRS     r9, CPSR
        LDR     r12, =SoundLevel0Base
        MOV     r1, #1
        ADR     lr, %FT10 ; Return address needs to be specified for mode r9
        AND     r10, r0, #1
        SetModeSEI IRQ32_mode
        B       RTSup_Sync ; Exits with PSR = r9
10
        EXIT

RTSup_Code      ROUT
        ; Called with:
        ;  R0 = SoundRMA
        ;  R10 = Next buffer to fill
        ;  R12 = SoundLevel0Base
        ;  R13 = zero!
        ;  SYS mode, IRQs enabled
        ; Exit with:
        ;  R0 = flags (0)
        ;  R10 updated
        ;  SYS mode
        ;  R1-R9, R11, R12, R14_svc corrupt
        ; Guaranteed to not be re-entered 

        MOV    r11, r0
        MRS    r9, CPSR
        MOV    r0, #0
        ; Switch into IRQ mode with IRQs disabled
        SetModeSEI IRQ32_mode
        ; Check pollword to see how many buffers need filling
        LDR    r1, [r11, #RTSup_Pollword]
        CMP    r1, #8
        ANDHS  r1, r1, #1 ; Skip ahead if we get too far behind with DMA
        STR    r0, [r11, #RTSup_Pollword]
        ; Any work to do?
        CMP    r1, #0
        BEQ    RTSup_Exit
RTSup_Sync
        ; In:
        ; R1 = fill count
        ; R9 = return PSR
        ; R10 = Next buffer to fill
        ; R11 = SoundRMA
        ; R12 = SoundLevel0Base
        ; IRQ mode, IRQs disabled
        Push   "r9,r14"

 [ UseNEON
        ; Enable our VFP context
        Push    "r1,wp"
        LDR     r12,[r11,#VFPSup_WS]
        LDR     r0,[r11,#VFPSup_Context]
        MOV     r1,#0
        MOV     lr,pc
        LDR     pc,[r11,#VFPSup_ChangeCtx]
        ; Assume it succeeded!
        Pull    "r1,r14"
        Push    "r0" ; Remember old context
 |
        MOV    r14, wp
 ]

RTSup_Loop        
        ; Preserve crucial regs (fill count, next buffer)
        EOR    r12, r10, #1
        Push   "r1,r12"

; Level0Swap

; IRQ mode, IRQs disabled
; r0-r10  free
; r11     SoundRMA
; r12     Buffer flag
; r13     IRQ stack
; r14     SoundLevel0Base

; Level0 Go

 ASSERT Phys1     = 4  ; r5
 ASSERT Buff0     = 8  ; r6
 ASSERT Buff1     = 12 ; r7
 ASSERT Config    = 16 ; r8
 ASSERT Level1Ptr = 20 ; r9
 ASSERT Images    = 24 ; r10, r11 NB. Two words
        LDMIB   r14, {r5-r9}            ; Sound0Segment params, skip semaphore
        TST     r12, #1
        MOVNE   r12, r6                 ; we fill the opposite
        MOVEQ   r12, r7
        MOV     r6, r8                  ; get config (incl. flags) in r6
        MOV     r0, r6, LSR #24         ; get configured log2nchan & flags
        AND     r0, r0, #3              ; mask out just current req'd log2nchan
        LDRB    r1, [r14, #Log2nchan_C] ; pick up current value in use
        CMP     r0, r1                  ; if different, mark update for Level1
        ORRNE   r6, r6, #1 :SHL: 31     ; by setting sign bit in r6
        STRNEB  r0, [r14, #Log2nchan_C] ; and also update log2nchan

        LDRB    r1, [r14, #SoundGain_C] ; get current value of mu-law->linear conv gain
        LDRB    r2, [r14, #SoundGain]   ; get last-set value
        CMP     r2, r1                  ; check if different, and if so mark fact...
        ORRNE   r6, r6, #1 :SHL: 31     ; ..by setting sign bit in r6
        STRNEB  r2, [r14, #SoundGain_C] ; and also update recorded value

        ; Handle 16-bit mode conversion routine re-compile if needed.  NB we
        ; change the compiled code directly on THIS interrupt, rather than
        ; with a one-buffer delay as is applied when updating the hardware.
        ; This is because the stereo positioning is already dealt with in the
        ; data put into the buffer, rather than when the buffer is read out
        ; (after next interrupt) by the hardware.
        ; Get currently required log2nchan value + flags

        ; Check whether any stereo position value has changed.
        ; Shuffle ImagesC FIFO first, since there is no buffer delay for
        ; software stereo
        LDR     r2, [r14, #ImagesC_N]   ; get wanted value of ImagesC
        STR     r2, [r14, #ImagesC_H]   ; (force skipping of 1-buffer delay)
        LDR     r1, [r14, #ImagesC_C]   ; check current value of ImagesC
        CMP     r2, r1                  ; check for being the same
        BNE     %FT55                   ; go recompile if different

        ; No change in stereo, but check whether number of active channels has
        ; changed, => recompile needed.  This was tested above, and marked in bit
        ; 31 of r6, so it's easy to re-check.  This bit may alternatively/also
        ; indicate change of soundgain value, with same consequence.
        TST     r6, #1 :SHL: 31
        BEQ     %FT65                   ; no re-compilation needed if bit 31 clear

55      ; Compile for updated configuration/stereo position/soundgain value.
        STR     r2, [r14, #ImagesC_C]   ; record req'd ImagesC value as current
        LDRB    r1, [r14, #SoundGain_C] ; pick up newest soundgain value
        ORR     r2, r2, r1, LSL #24     ; and combine into r2
      [ :LNOT: UseNEON
        ADD     r1, r11, #LinConvCode   ; address code buffer in SoundRMA workspace
      |
        MOV     r1, r11
      ]
        MOV     r4, r14
        BL      compile                 ; go compile it (R0 = log2nchan)
        MOV     r14, r4                 ; (reset local vars pointer after BL)
65  ; Reprogram ASD, if required

        ! 0, "TODO - Reimplement sample rate pipelining (to cope with HW DMA double buffering etc.)"
        ; if delta values change, need to set bit 31 of r6?

; level0 MEMC update

70

80

; Level0Updated - any events to dispatch?
   [ TimingCode
        Push    "r0-r4,r9,r12,r14"
        LDR     r4,[r14,#SoundRMA]
        GetTime r4
        LDR     r1,[r4,#TimeTemp0]
        STR     r0,[r4,#TimeTemp0] ; Time at last total update
        STR     r0,[r4,#TimeTemp1] ; Time at level 2 update
        LDR     r2,[r4,#TimeTotal]
        SUBS    r0,r1,r0
        LDRLT   r1,[r4,#TimeMaxPeriod]
        ADDLT   r0,r0,r1
        ADD     r2,r2,r0
        STR     r2,[r4,#TimeTotal]
        Pull    "r0-r4,r9,r12,r14"
   ]

        Push    "r8-r12, r14"           ; r1-r7 preserved by scheduler
        LDR     r12, [r14, #Level2Ptr]
        TST     r12, #SoundSystemNIL    ; test for installed scheduler
        LDREQ   r0, [r12]
        TSTEQ   r0, #SoundSystemNIL     ; Valid Level2?
        MOVEQ   lr, pc
        MOVEQ   pc, r0                  ; Call Level2
        SEI     IRQ32_mode              ; Don't trust it to preserve IRQ state
        Pull    "r8-r12, r14"

   [ TimingCode
        Push    "r0-r4,r9,r12,r14"
        LDR     r4,[r14,#SoundRMA]
        GetTime r4
        LDR     r1,[r4,#TimeTemp1]
        LDR     r2,[r4,#TimeLevel2]
        SUBS    r0,r1,r0
        LDRLT   r1,[r4,#TimeMaxPeriod]
        ADDLT   r0,r0,r1
        ADD     r2,r2,r0
        STR     r2,[r4,#TimeLevel2]
        Pull    "r0-r4,r9,r12,r14"
   ]

; Level0 ready to fill

        MOV     r11, r6, LSR #24        ; get log2nchan + flags
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
81
        AND     r11, r11, #3            ; get just log2nchan
        MOV     r10, r6, LSL #16        ; get logical buffer length/channel
        MOV     r10, r10, LSR #16       ; (16 bits worth)
        MOV     r4, r10, LSL r11        ; work out physical length into r4
        BIC     r4, r4, #&F             ; must be a multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer len
        MOV     r4, r10, LSL #2         ; work out physical length into r4 (Fs*1, 16-bit stereo)
        MOV     r11, r6, LSR #24        ; get back real log2nchan (asking for 8bit data)
        AND     r11, r11, #3
        ADD     r10, r12, r10, LSL r11  ; r10 = logical buffer end
        MOV     r0, #1                  ; convert log to buffer inc
        MOV     r11, r0, LSL r11        ; r11 = N channels

82      ; Convert mu-law N-channel data in logical buffer to 16-bit stereo physical data

        TST     r9, #SoundSystemNIL     ; Valid Level1? Loaded only once, above
        MOVNE   r3, #0                  ; if not, mark no valid data in physical buffer
        BNE     %FT86                   ;         and go do 16-bit handling

        STMFD   sp!, {r4,r6,r10,r12,r14} ; save off physlen, config, logend, buffstart, ws

   [ TimingCode
        Push    "r9,r12"
        LDR     r4,[r14,#SoundRMA]
        GetTime r4
        STR     r0,[r4,#TimeTemp1]
        Pull    "r9,r12"
   ]

        CLI     IRQ32_mode              ; enable IRQs

        ; Zap the logical buffer to 0 before calling level 1 code to fill it.
        ; This is necessary for compatibility, since the standard channel
        ; handler assumes that any channel which is silent will have 0 data in
        ; its entries in the logical buffer.  But since we overwrite the
        ; logical data with 16-bit physical data after filling it, this will
        ; not hold in general.  So fill the logical buffer with all 0 now.
        ;
        ; KJB - surely better to have separate logical and physical buffers?
        ; maybe not - more cache thrashing?

    [ :LNOT: UseNEON
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        MOV     r8, r12

        ; Zero 4*8 words = 128 bytes each loop.  Slightly overrunning the
        ; logical buffer end is not a problem, and since the physical
        ; buffers are a multiple of 128 bytes in length, we won't overrun
        ; those either.

84      STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        CMP     r8, r10
        BLO     %BT84
    |
        ARM ; Avoid UAL syntax warnings
        VMOV.I32   Q0, #0
        VMOV.I32   Q1, #0
        VMOV.I32   Q2, #0
        VMOV.I32   Q3, #0
        MOV        r8, r12
84      VSTMIA     r8!, {Q0-Q3} ; 64 bytes at once
        VSTMIA     r8!, {Q0-Q3}
        CMP        r8, r10
        BLO        %BT84
        CODE32
    ]

        SEI     IRQ32_mode              ; IRQs off again

        ; Call Level1: don't change mode, flags

        LDR     r6, [sp, #4]            ; reload config value, including update flag r6:31
        MOV     r8, r6, LSR #16         ; get current per-channel period in r8,
        AND     r8, r8, #&FF            ; for Level1 fill code

   [ TimingCode
        LDR     r14,[sp,#16]
        Push    "r9,r12"
        LDR     r4,[r14,#SoundRMA]
        GetTime r4
        LDR     r1,[r4,#TimeTemp1]
        LDR     r2,[r4,#TimeNuke]
        STR     r0,[r4,#TimeTemp1]
        SUBS    r0,r1,r0
        LDRLT   r1,[r4,#TimeMaxPeriod]
        ADDLT   r0,r0,r1
        ADD     r2,r2,r0
        STR     r2,[r4,#TimeNuke]
        Pull    "r9,r12"
   ]

        MOV     lr, pc
        LDR     pc, [r9, #SoundLevel1FillPtr]
        SEI     IRQ32_mode              ; Don't trust it to preserve IRQ state

        LDMFD   sp, {r4,r6,r10,r12,r14} ; restore saved values. NB leave on stack: no `!'

   [ TimingCode
        Push    "r0-r4,r9,r12,r14"
        LDR     r4,[r14,#SoundRMA]
        GetTime r4
        LDR     r1,[r4,#TimeTemp1]
        LDR     r2,[r4,#TimeLevel1]
        STR     r0,[r4,#TimeTemp1]
        SUBS    r0,r1,r0
        LDRLT   r1,[r4,#TimeMaxPeriod]
        ADDLT   r0,r0,r1
        ADD     r2,r2,r0
        STR     r2,[r4,#TimeLevel1]
        Pull    "r0-r4,r9,r12,r14"
   ]

        ; Convert mu-law to 16-bit linear data.
        ; have: physical length in r4,
        ;       logical buffer end in r10
        ;       logical buffer start in r12
        ; want: r10 and r12 as they are,
        ;       r11 = physical buffer start or end, according to logical buffer size
 [ :LNOT: UseNEON
        ;       r9 = address of 256-entry mu-law to 16-bit conversion table
        ;       r8 = &FF for byte masking in conversion routine
        ;       r5 = &7FFF for overflow test
        TST     r6, #2 :SHL: 24         ; 4 or 8 channels in use?
        MOV     r8, #&FF                ; set up byte mask used in routine
        MOVNE   r11, r12                ; write 16-bit data forwards from start if so
        ADDEQ   r11, r12, r4            ; else write 16-bit data backwards from phys buff end
        ADRL    r9, convtable           ; address conversion table for routine to use
        ORR     r5, r8, #&7F00          ; and also mask for limit check
        LDR     r0, [r14, #SoundRMA]    ; go get RMA space address
        MOV     r7, #&70000003          ; put impossible 16-bit output value in r7
   [ UseLDRSH
        MOV     r8, r8, LSL #1          ; Must use mask of 0x1fe in r8
   ]
        CLI     IRQ32_mode              ; enable IRQs
        Push    pc                      ; set up return address
        ADD     pc, r0, #LinConvCode    ; call conversion code
        NOP

        SEI     IRQ32_mode              ; IRQs off again

        LDMFD   sp!, {r4,r6,r10,r12,r14}; again restore values, clearing stack this time

        CMP     r7, #&70000003          ; if impossible value still in r7, all data was 0
        MOVNE   r3, #1                  ; mark that there is valid (non-0) data in buffer
        MOVEQ   r3, #2                  ; else mark that 16-bit data in buffer is all 0
 |
        TST     r6, #2 :SHL: 24         ; 4 or 8 channels in use?
        LDR     r0, [r14, #SoundRMA]    ; go get RMA space address
        MOVNE   r11, r12                ; write 16-bit data forwards from start if so
        ADDEQ   r11, r12, r4            ; else write 16-bit data backwards from phys buff end
        BL      MuLawNEON_code
        LDMFD   sp!, {r4,r6,r10,r12,r14}; again restore values, clearing stack this time
 ]

   [ TimingCode
        Push    "r0-r4,r9,r12,r14"
        LDR     r4,[r14,#SoundRMA]
        GetTime r4
        LDR     r1,[r4,#TimeTemp1]
        LDR     r2,[r4,#TimeMuLaw]
        STR     r0,[r4,#TimeTemp1]
        SUBS    r0,r1,r0
        LDRLT   r1,[r4,#TimeMaxPeriod]
        ADDLT   r0,r0,r1
        ADD     r2,r2,r0
        STR     r2,[r4,#TimeMuLaw]
        Pull    "r0-r4,r9,r12,r14"
   ]

86      ; We're now dealing with a physical buffer containing 16-bit stereo
        ; data (it will still contain old data from last time, if no level 1
        ; handler is present).  Check whether there is a 16-bit sound
        ; generator/mixer, and if so, call it.  Note that r3 determines
        ; whether there is valid 16-bit data in the buffer already:
        ;
        ;     0 => old/invalid (*must* overwrite) - jumped here directly, no level 1 handler
        ;     1 => yes, valid, not all 0, but may overwrite to ignore
        ;     2 => yes, and known to be all 0, so can simply return if silent

        LDR     r5, [r14, #SoundRMA]    ; address RMA workspace
        LDR     r11, [r5, #Lin16Gen]    ; pick up code address
        LDR     r0, [r5, #Lin16GenR0]   ; pick up paramter to pass it in r0
        MOV     r1, r12                 ; pass base of buffer in r1
        ADD     r2, r12, r4             ; and end of buffer in r2
        CMP     r11, #0                 ; check for valid entry, if so.....
        STMFD   sp!, {r1,r2,r14}        ; save base/limit for oversampler below
        BEQ     %FT87
        LDR     r4, [r5, #CurSRValue]   ; load up current frequency value into r4

        MOV     lr, pc                  ; and go call
        MOV     pc, r11

   [ TimingCode
        LDR     r14,[sp,#8]
        Push    "r2-r4,r9,r12"
        LDR     r4,[r14,#SoundRMA]
        GetTime r4
        LDR     r1,[r4,#TimeTemp1]
        LDR     r2,[r4,#TimeLinear]
        STR     r0,[r4,#TimeTemp1]
        SUBS    r0,r1,r0
        LDRLT   r1,[r4,#TimeMaxPeriod]
        ADDLT   r0,r0,r1
        ADD     r2,r2,r0
        STR     r2,[r4,#TimeLinear]
        Pull    "r2-r4,r9,r12"
   ]

87
        LDMFD   sp, {r0,r1,r11}         ; reload (no pop) phys base & limit now

        CLI     IRQ32_mode              ; enable IRQs (watch out for r14)

        ; Finally, perform any post-processing required:
        ; * Mono mix-down
        ; * Oversampling
        ; * Stereo reversal
        ; * Software mixer (volume control)

        LDRB    r3, [r11, #Flags]
        ANDS    r3, r3, #DoFlags
        BEQ     BufferDone              ; nowt to do if all bits clear (r3 = 0)
        TEQ     r3, #DoReverse          ; just stereo reversal?
        BEQ     DoFunc_Reverse

        LDR     r7, [r11, #SoundRMA]

        ; OK, doing some sort of filtering operation.  Set up some constants
        ; used in all cases...
 [ :LNOT: UseNEON :LAND: NoARMv6
        ; Set up 0x80008000 in r12, to perform signed/unsigned swap overs
        MOV     r12, #1<<15
        ORR     r12, r12, #1<<31

        ; Create 0xFFFEFFFE in r11 for masking off LSBs, to isolate LH and RH
        ; parts during parallel additions.
        MVN     r11, r12, ROR #15       ; can derive from r12 in one go!
 ]
        TST     r3, #DoOversample
        BEQ     %FT88                   ; below only needed for oversampling
        SUB     r2, r1, r0              ; determine phys length of buffer at Fs*1
        ADD     r2, r0, r2, LSL #1      ; and compute end of buffer at Fs*2
        STR     r2, [sp, #4]            ; store out for later use also
                                        ; switch to appropriate oversampling code
        LDR     r6, [r7, #SavedSample]  ; get saved sample in R6

88
      [ SupportSoftMix
        ASSERT  DoSoftMix = &40
      ]        
        ASSERT  DoReverse = &20
        ASSERT  DoMono = &10
        ASSERT  DoOversample = &08        
        ADD     pc, pc, r3, LSR #1          ; branch to right code
        NOP
        B       BufferDone              ; flags=0 (shouldn't happen)
        ; Build the rest of the table using a loop
        GBLA    doflags
        GBLS    dofunc
doflags SETA    DoOversample
        WHILE   doflags <= DoFlags
dofunc  SETS    "DoFunc"
     [ SupportSoftMix
       [ (doflags :AND: DoSoftMix) <> 0
dofunc  SETS    "$dofunc" :CC: "_SoftMix"
       ]
     ]
       ; Reverse flag can be ignored if mono flag present
       [ (doflags :AND: DoMono) <> 0
dofunc  SETS    "$dofunc" :CC: "_Mono"
       ELIF (doflags :AND: DoReverse) <> 0
dofunc  SETS    "$dofunc" :CC: "_Reverse"
       ]
       [ (doflags :AND: DoOversample) <> 0
dofunc  SETS    "$dofunc" :CC: "_Oversample"
       ]
        B       $dofunc
doflags SETA    doflags + DoOversample
        WEND
        

BufferDone	; return here after any buffer processing
                ; NOTE: May be in IRQ or SVC!
        SetModeSEI IRQ32_mode           ; redisable IRQs
	Pull	"r3,r4,r14"             ; pop phys base+real limit (@@Fs*2 if oversampling)
	LDR	r6, [r4, #-4]		; pick up last sample pair from this buffer
	LDR	r11, [r14, #SoundRMA]	; address RMA area
	STR	r6, [r11, #SavedSample]	; save sample pair for possible oversampling next time

   [ TimingCode
        Push    "r12,r14"
        GetTime r10
        LDR     r1,[r11,#TimeTemp1]
        LDR     r2,[r11,#TimeMonoOversample]
        SUBS    r0,r1,r0
        LDRLT   r1,[r11,#TimeMaxPeriod]
        ADDLT   r0,r0,r1
        ADD     r2,r2,r0
        STR     r2,[r11,#TimeMonoOversample]
        Pull    "r12,r14"
   ]

        ; All done for this IRQ
        ; IRQ mode, IRQs disabled
        ; r11 = SoundRMA
        ; r14 = SoundLevel0Base
        Pull    "r1,r10" ; Recover fill count, next buffer
        SUBS    r1, r1, #1
        BNE     RTSup_Loop        

   [ UseNEON
        ; Restore previous VFP context
        Pull    "r0"
        MOV     r1, #0
        LDR     r12, [r11, #VFPSup_WS]
        MOV     lr, pc
        LDR     pc, [r11, #VFPSup_ChangeCtx]
   ]
        ; IRQ32 mode, IRQs disabled
        ; r10 = next buffer
        Pull    "r9,lr"
RTSup_Exit
        MSR     CPSR_c, r9 ; Restore correct CPU mode (SYS for RTSupport routine, or caller's mode for CustomDMASync_Sync)
        MOV     r0, #0
        MOV     pc, lr


;
; ConvImages
;
; Passed in a pointer in r0 to 8 bytes (Images), returns in r0 a word
; having bits 31:24 zero and with 24:0 being compacted image data for
; programming (8 x 3 bits, chan 0 in bits 2:0, 1 = MAX L, 7 =
; MAX R).  r1-r13 preserved.
ConvImages Entry r1
        ADD     r1, r0, #7              ; start with channel 7
        MOV     r0, #0                  ; initialise output in r0
10      LDRB    lr, [r1], #-1           ; get one byte
        CMP     lr, #&E0                ; convert from linear pos to SIR value
        ADDLT   lr, lr, #&10
        MOVS    lr, lr, LSR #5
        MOVEQ   lr, #1                  ; correct for min
        MOV     r0, r0, LSL #3          ; shift previous values left one channel pos
        ORR     r0, r0, lr              ; merge in this channel into bottom
        TST     r0, #7 :SHL: (7*3)      ; shifted channel 7 value into place yet?
                                        ; (all output values are 1..7, i.e. not 0)
        BEQ     %BT10                   ; go round again if not
        EXIT                            ; all done, go home

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CopyError Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        ADD     R1, R12, #MessageFile_Block
        MOV     R2, #0
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.SoundDMA.Messages", 0
        ALIGN

open_messagefile Entry r0-r2
        LDR     r0, [r12, #MessageFile_Open]
        CMP     r0, #0
        EXIT    NE
        ADD     R0, r12, #MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        EXIT    VS
        MOV     r0, #1
        STR     r0, [r12, #MessageFile_Open]
        EXIT

close_messagefile Entry "r0"
        LDR     r0, [r12, #MessageFile_Open]
        CMP     r0, #0
        ADDNE   r0, r12, #MessageFile_Block
        SWINE   XMessageTrans_CloseFile
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ TimingCode
        MACRO
        WriteVal $name,$val
        SWI     OS_WriteS
        DCB     "$name",0
        ALIGN
      [ "$val" <> "r0"
        MOV     r0, $val
      ]
        MOV     r1, sp
        MOV     r2, #12
        SWI     OS_ConvertCardinal4
        SWI     OS_Write0
        SWI     OS_NewLine
        MEND

SoundTiming_Code
        Entry   "r0-r10", 12
        LDR     r12, [r12]
        LDR     r0, [r12, #TimeGran]
        ADD     r3, r12, #TimeTotal
        LDMIA   r3, {r4-r10} ; Grab times in one go to avoid IRQs updating them
        ASSERT  TimeLevel2 = TimeTotal+4
        ASSERT  TimeNuke = TimeTotal+8
        ASSERT  TimeLevel1 = TimeTotal+12
        ASSERT  TimeMuLaw = TimeTotal+16
        ASSERT  TimeLinear = TimeTotal+20
        ASSERT  TimeMonoOversample = TimeTotal+24
        WriteVal "Granularity: ",r0
        WriteVal "Total time: ",r4
        WriteVal "Level2 time: ",r5
        WriteVal "Nuke time: ",r6
        WriteVal "Level1 time: ",r7
        WriteVal "MuLaw time: ",r8
        WriteVal "Linear time: ",r9
        WriteVal "MonoOversample time: ",r10
        ; Now nuke the existing times
        MOV     r4,#0
        MOV     r5,#0
        MOV     r6,#0
        MOV     r7,#0
        MOV     r8,#0
        MOV     r9,#0
        MOV     r10,#0
        STMIA   r3, {r4-r10}
        EXIT        
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ debug
        InsertNDRDebugRoutines
 ]

 [ SupportSoftMix
        GET     s.SoftMix
 ]
        GET     s.DeviceList

        END

@


1.23
log
@   Improved startup with transient HAL sound device
Detail:
   A previous mod provided a compile time switch to leave SoundDMA present
   even when there was no HAL audio device. This has proved unnecessary,
   so has been removed. Instead, once the HAL device has been made available
   one should rmreinit in order; SoundDMA, SoundChannels, SoundScheduler,
   and then WaveSynth, Percussion, and StringLib. This ensures that the module
   dependant interactions are reinitialised.
   Additionally there was a possibility that if no HAL audio devices were
   available at startup it was possible to get a null pointer error under
   some circumstances.
Admin:
   tested in iMx6 with other HAL audio devices both enabled and disabled

Version 1.87. Tagged as 'Sound0HAL-1_87'
@
text
@d156 1
d266 2
a267 1
SCPeriod     * 45                       ; default, i.e. 22050 Hz
d2174 2
a2175 1
Initialise_Module Entry "r7, r8, r10, r11"
d2250 1
a2250 1
        MOV     r0, #0                  ; Semaphore ON (so reenable wakens it)
a2260 11
        ; Build device list
        BL      Initialise_DeviceList

        ; Set up DMA (+ select default device)
        BLVC    Initialise_DMA
 [ UseNEON
        ; Get our VFPSupport context
        BLVC    Initialise_NEON
 ]
        BVS     %FT90

d2262 1
a2262 1
        MOV     r0, #161                ; CMOS read OSBYTE
d2271 1
d2273 5
a2277 9
; Get stereo reverse flag from HAL device
        LDR     r2, [r12, #HALDevice]
        LDR     lr, [r2, #HALDevice_Version]
        CMP     lr, #2:SHL:16
        LDRGE   lr, [r2, #HALDevice_AudioFlags]
        ASSERT  AudioFlag_StereoReverse = 1
        ASSERT  DoReverse = &20
        ANDGE   lr, lr, #AudioFlag_StereoReverse
        ORRGE   r4, r4, lr, LSL #5+24
d2279 14
a2292 1
        STR     r4, [r10, #Config]      ; store config, with correct flags in
d2294 1
a2294 1
20      MOV     r0, r4, LSR #24         ; get log2nchan + flags byte
d2308 1
a2308 1
30
d2323 1
a2323 1
        BL      Sound0InitConfig        ; Configure sample rate & buffer size, taking into account any constraints
a2325 1
        BVS     %FT90                   ; May fail, e.g. RTSupport unavailable
d2330 1
a2330 1
89
@


1.22
log
@  Made aware of another product that doesn't provide a sound driver till later.
  Module will not then die when initialised
Detail:
Admin:


Version 1.86. Tagged as 'Sound0HAL-1_86'
@
text
@a219 5
 [ :LNOT::DEF:CuBox
        GBLL    CuBox
CuBox   SETL    {FALSE}
 ]        
;
a1340 3
 [ CuBox
 B %ft40     ; hopefully keep module there..
 ]
d1376 2
a2259 3
 [ CuBox
        BVS     %ft89     ; hopefully keep module there..
 ]
d2262 1
a2262 1
        BL      Initialise_DMA
a2266 3
 [ CuBox
        BVS     %ft89     ; hopefully keep module there..
 |
d2268 1
a2268 1
 ]
@


1.21
log
@Use PSR manipulation macros. Add more ARMv6 optimisations to Sound0ARM.
Detail:
  s/Sound0 - Replace many manual MSR's with PSR manipulation macros, generally the new SEI/SetMode/etc. ones. Fix DMA completed callback restoring CPSR from wrong register.
  s/Sound0ARM - Replace manual MSR's with PSR manipulation macros. Optimise the buffer post-processing routines for ARMv6 by using SHADD16
Admin:
  Tested on Raspberry Pi


Version 1.85. Tagged as 'Sound0HAL-1_85'
@
text
@d220 4
d1346 3
d2266 3
d2276 3
d2280 1
a2280 1

d2341 1
@


1.20
log
@Rename new device selection/enumeration SWIs. Add a way to query the supported sample rates of an arbitrary device. Add user-friendly names for the current HAL-based devices. Protect against level1 & level2 sound handlers that fail to preserve IRQ state.
Detail:
  hdr/Sound, s/Sound0:
  - After some discussion it was decided that "Device" was a bit too generic for the device selection/enumeration SWIs (e.g. could be confusing when also referring to peripheral devices such as headphones or speakers), and so they've been renamed to use "Controller" instead.
  - Added a new reason code to Sound_ControllerInfo to read the supported sample rates for a controller, similar to Sound_SampleRate 0 & 2
  - Update IRQ handler to make sure IRQs are still off after calling level 1 (channel) & level 2 (scheduler) handlers - there's evidence that some third-party handlers fail to do this, which original IOMD versions of SoundDMA were tolerant of but newer versions were not.
  Resources/Germany/Messages, Resources/UK/Messages:
  - Added user-friendly, localisation-friendly names/descriptions for the current ROM-based devices which this module supports
Admin:
  Tested on Raspberry Pi
  German messages in need of translation.


Version 1.84. Tagged as 'Sound0HAL-1_84'
@
text
@d822 1
a822 1
        MSR     CPSR_c, #I32_bit :OR: SVC32_mode
d1284 1
a1284 1
        MSR     CPSR_c, #SVC32_mode
d1337 1
a1337 1
        MSR     CPSR_c, #SVC32_mode
d2319 1
a2319 1
        MSR     CPSR_c, #I32_bit+SVC32_mode ; IRQ off please
d2322 1
a2322 1
        MSR     CPSR_c, #SVC32_mode     ; Reenabled IRQs
d2495 1
a2495 2
        MRS     r2, CPSR
        MSR     CPSR_c, #SVC32_mode + I32_bit
d2498 1
a2498 1
        MSR     CPSR_c, r2
d2547 1
a2547 2
        MRS     r5, CPSR
        MSR     CPSR_c, #SVC32_mode + I32_bit
d2549 1
a2549 1
        MSR     CPSR_c, r5
d2744 1
a2744 2
        MRS     r5, CPSR
        MSR     CPSR_c, #SVC32_mode + I32_bit
d2751 1
a2751 1
        MSR     CPSR_c, r5
d2948 1
a2948 1
        MSR     CPSR_c, #I32_bit+SVC32_mode
d2971 1
a2971 1
        MSR     CPSR_c,#I32_bit+IRQ32_mode
d3016 1
a3016 3
        MRS     r2, CPSR
        ORR     r1, r2, #SVC32_mode+I32_bit ; Switch to SVC with IRQs off
        MSR     CPSR_c, r1
d3028 1
a3028 1
        MSR     CPSR_c, r1
d3036 1
a3036 3
        MRS     r0, CPSR
        ORR     lr, r0, #I32_bit
        MSR     CPSR_c, lr
d3040 1
a3040 1
        MSR     CPSR_c, r0
d3055 1
a3055 3
        MRS     r0, CPSR
        ORR     lr, r0, #I32_bit
        MSR     CPSR_c, lr
d3059 1
a3059 1
        MSR     CPSR_c, r0
d3083 1
a3083 1
        MSR     CPSR_c, #IRQ32_mode+I32_bit
d3106 1
a3106 1
        MSR    CPSR_c, #IRQ32_mode+I32_bit
d3251 1
a3251 1
        MSR     CPSR_c, #I32_bit+IRQ32_mode ; Don't trust it to preserve IRQ state
d3304 1
a3304 1
        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs
d3352 1
a3352 1
        MSR     CPSR_c, #I32_bit + IRQ32_mode ; IRQs off again
d3378 1
a3378 1
        MSR     CPSR_c, #I32_bit+IRQ32_mode ; Don't trust it to preserve IRQ state
d3418 1
a3418 1
        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs
d3423 1
a3423 1
        MSR     CPSR_c, #I32_bit+IRQ32_mode ; IRQs off again
d3496 1
a3496 1
        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs (watch out for r14)
d3514 1
a3514 1
 [ :LNOT: UseNEON
d3568 1
a3568 1
        MSR     CPSR_c, #I32_bit + IRQ32_mode ; redisable IRQs
@


1.19
log
@Avoid unnecessary remainder calculations
Detail:
  s/Sound0 - Avoid unnecessary remainder calculation in DivRem macro
Admin:
  Tested on Cortex-A15


Version 1.83. Tagged as 'Sound0HAL-1_83'
@
text
@d348 3
a350 3
        DCB     "SelectDefaultDevice",0
        DCB     "EnumerateDevices",0
        DCB     "DeviceInfo",0
d514 1
a514 1
        SWI     XSound_SelectDefaultDevice
d843 3
a845 3
        B       Sound0SelectDefaultDevice
        B       Sound0EnumerateDevices
        B       Sound0DeviceInfo
d1849 1
a1849 2
;        2 -> get current device name
;        3 -> get mixer HAL device for named audio device
d1853 1
a1853 1
        CMP     r0, #Sound_RSI_DefaultDevice
d1857 3
a1859 3
        MOV     pc, lr                           ; 0
        B       Sound0ReadSysInfo_Features       ; 1
        B       Sound0ReadSysInfo_DefaultDevice  ; 2
d1868 1
a1868 1
;        bit 1: SelectDefaultDevice, EnumerateDevices, DeviceInfo SWIs supported
d1871 1
a1871 1
        MOV     r1, #Sound_RSI_Feature_Service8910 :OR: Sound_RSI_Feature_DeviceSelection
d1882 2
a1883 2
;   buffer filled in with null-terminated device ID
Sound0ReadSysInfo_DefaultDevice ROUT
d1904 1
a1904 1
; Sound0SelectDefaultDevice: implements Sound_SelectDefaultDevice SWI.
d1907 1
a1907 1
;   r0 -> space/control-terminated terminated device ID
d1912 2
a1913 2
; Switches the current audio device
Sound0SelectDefaultDevice ROUT
d1944 1
a1944 1
; Sound0EnumerateDevices: implements Sound_EnumerateDevices SWI.
d1947 1
a1947 1
;   r0 = pointer to device ID string to start from, or 0 or an empty string to start enumeration
d1952 1
a1952 1
;   r0 = 0, buffer at r1 filled in with null-terminated ID of next device. Buffer will be empty if end of list reached.
d1956 2
a1957 2
; Enumerates available devices
Sound0EnumerateDevices ROUT
d1980 1
a1980 1
; Sound0DeviceInfo: implements Sound_DeviceInfo SWI.
d1983 1
a1983 1
;   r0 -> space/control terminated device ID
d1989 1
d1996 2
a1997 2
; Read info for a given device
Sound0DeviceInfo ROUT
d2004 1
a2004 1
        CMP     r4, #Sound_DevInfo_MixerDevice
d2007 3
a2009 2
        B       Sound0DeviceInfo_DisplayName
        B       Sound0DeviceInfo_MixerDevice
d2011 1
a2011 1
Sound0DeviceInfo_DisplayName
d2021 1
a2021 1
Sound0DeviceInfo_MixerDevice
d2035 10
d2148 19
a2166 1
        MakeInternatErrorBlock BuffOverflow
d3260 1
d3387 1
@


1.18
log
@Fix NEON detection
Detail:
  s/Sound0 - Add a missing condition code to the NEON detection code; FPSID bits must be set to indicate VFPv3+ (and MVFR0/1 availability) and MVFR1 bits must be set to indicate NEON availability
Admin:
  Tested on Pandaboard
  Issue spotted by Sprow; old code would have been fine on all current machines, but could have failed on a hypothetical VFPv1/v2 machine which had non-standard MVFR registers


Version 1.82. Tagged as 'Sound0HAL-1_82'
@
text
@d950 1
a950 1
        DivRem  r3, r1, r2, lr          ; Work out how many multiples of granularity we can fit, and use that (assumed to be >= min buffer size)
@


1.17
log
@Fix ARM version of module
Detail:
  s/Sound0 - Fix missing DoSoftMix symbol error when software mixer support is disabled
  s/Sound0ARM - Rename post-processing routines to match the names generated by the loop in Sound0
Admin:
  Tested on Raspberry Pi


Version 1.81. Retagged as 'Sound0HAL-1_81'
@
text
@d2591 1
a2591 1
        TST     r2, #&f000
@


1.16
log
@Add device enumeration and selection APIs. Make audio HAL device API more flexible. Add a generic software mixer implementation that can be used for devices where no hardware mixer is available.
Detail:
  Makefile - Include new source files. Export a C version of hdr/Sound.
  Resources/* - Add new error text to messages file and update command help text
  Version - Update MaxDeviceVersion. Add MinDeviceVersion definition to get rid of a magic constant from the code. Add new switch for whether software mixer support is enabled.
  hdr/AudioDevice - Extend with audio device API 3 features. Buffer size granularity can now be non-power of 2 values, and CustomDMA can be used in a synchronous manner instead of an asynchronous manner (asynchronous defers buffer filling to an RTSupport routine, synchronous performs it directly from within the callback from the device). Also correct a comment relating to AudioRateTable_Frequency.
  hdr/Sound - Add new SWIs and reason codes. Protect a portion of the header from being processed by Hdr2H (Hdr2H can't handle it)
  s/Sound0 - Change default sample rate & buffer size settings to 22050Hz (none of the hardware currently supported by this version of the module supports 20833Hz). Add implementations of the new SWIs and features. Tidy up a couple of other bits.
  s/Sound0NEON - Refactor post-processing code to add support for the software mixer - code is now generated by macros rather than copy & paste. Fix indentation of some other code sections.
  s/DeviceList - New file to contain code related to managing the list of audio devices that SoundDMA now keeps.
  s/SoftMix - New file containing the software mixer device implementation. Implements a single mixer channel to control the overall gain of the sound system. Mixing/volume scaling is performed by the buffer post-processing sequences in Sound0ARM/Sound0NEON, with the optimisation of skipping the processing for a gain of +0dB. Note however that Sound0ARM has yet to be updated and so software mixing is currently only available for the NEON version of the module.
Admin:
  Tested in iMX6 ROM
  German resources are in need of translation


Version 1.81. Tagged as 'Sound0HAL-1_81'
@
text
@d3525 1
d3529 1
@


1.15
log
@Fix for stack imbalance
If the RTSupport pollword says there's no work to do, SoundDMA would make a quick exit, but one instruction too early - trying to pop LR before it ever got pushed.

Version 1.80. Tagged as 'Sound0HAL-1_80'
@
text
@d203 1
a203 1
debug           SETL    False
d206 1
a206 1
hostvdu         SETL    True
d208 2
a209 1
swi     SETD    False
d266 1
a266 1
SCPeriod     * 48                       ; default, i.e. 20.833 kHz
d268 1
a268 1
SCBufferLen  * 208                      ; 208 bytes/channel (&D0: multiple of 16)
d274 3
d282 6
d293 1
a293 1
; Physical address of sound DMA buffers is not fixed on IOMD systems, but
d348 3
d448 3
d452 1
a452 1
HALDevice         #  4                  ; Pointer to HAL audio controller device
d460 1
d480 8
d510 7
d525 1
a535 1
        LDR     r12, [r12]              ; Get workspace pointer for caller
d843 3
d926 1
a926 1
        CMP     r3, #32                 ; ensure enough 8bit/16bit samples for >= 32bytes of data
a927 2
        CMP     r2, #16                 ; Mono/oversample code processes 4 words of (non-oversampled) linear data at a time
        MOVLO   r2, #16
d932 12
a943 4
        SUB     r2, r2, #1              ; Apply granularity requirement
        ADD     r1, r1, r2, LSR #2
        BIC     r1, r1, r2, LSR #2
        Pull    "r2-r3" 
d948 6
a953 1
        MOVGT   r1, #SoundDMABufferSize :SHR: 2
d1112 6
a1117 6
;       This is mainly due to limitations in the OMAP + TPS65950:
;       * Changes to sample rate can only be applied to the TPS if it's stopped
;       * The McBSP instance that transfers the data to the TPS needs to know
;         how much data is sent for each DMA transaction. Due to limitations in
;         the current DMAManager/HAL API, the size of each transaction is
;         identical to the size of the DMA buffer.
d1418 4
a1421 1
        ADRL    r11, CustomDMASync
d1849 15
d1869 267
a2135 5
Sound0ReadSysInfo
        CMP    r0, #Sound_RSI_Features
        MOVEQ  r0, #0
        MOVEQ  r1, #Sound_RSI_Feature_Service8910
        MOV    pc, lr
d2137 1
d2168 1
a2168 1
        MOV     r8, #0
d2180 1
a2180 1
        MOV     r8, #1
d2228 4
a2231 1
        ; Set up DMA (also looks for HAL device)
d2382 19
d2405 1
a2405 1
        BNE     UService_Exit
d2411 4
d2418 6
a2423 14
        ; Device starting. Are we looking for a sound device?
        LDR     r0, [r12, #HALDevice]
        CMP     r0, #0
        BNE     UService_Exit
        ; Is this an audio controller?
      [ UseLDRSH
        LDRH    r0, [r2, #HALDevice_Type]
      |
        LDR     r0, [r2, #HALDevice_Type]
        MOV     r0, r0, LSL #16
        MOV     r0, r0, LSR #16
      ]
        LDR     r3, =HALDeviceType_Audio :OR: HALDeviceAudio_AudC
        CMP     r0, r3
d2425 1
a2425 5
        ; Is the API version suitable?
        LDR     r0, [r2, #HALDevice_Version]
        CMP     r0, #(MaxDeviceVersion+1):SHL:16
        BHS     UService_Exit
        ; Does it work?
d2458 4
d2506 2
a2507 1
        ; Out: Corrupts r3
d2509 1
d2515 1
d2524 1
d2526 1
d2556 3
d2632 3
a2634 3
        ; Try initialising the sound device in r2
        ; Must already be validated for correct type & max API version
        ; In: r12 = SoundRMA
d2636 1
a2636 2
        ;      V set, R0=0 -> non-serious error (incompatible device)
        ;      V set, R0!=0 -> serious error
d2638 3
a2640 5
        ; We don't support devices with a major version of 0
        LDR     lr, [r2, #HALDevice_Version]
        CMP     lr, #1:SHL:16
        BLO     %FT90
        ; Device is valid, try to activate it
d2642 1
a2642 2
        MOV     r4, r2
        MOV     r0, r2
d2644 1
a2644 1
        LDR     pc, [r2, #HALDevice_Activate]
d2663 13
d2677 1
a2677 1
        MOV     r8, #0
d2719 4
d2724 1
d2727 1
d2740 1
a2740 1
        MOV     r0, #0
d2742 1
a2742 1
        MOV     pc, lr
d2752 10
a2761 11
        ; Hunt for a suitable HAL audio device  
        MOV     r1, #0
        MOV     r8, #4
10      LDR     r0, =MaxDeviceVersion:SHL:16 :OR: HALDeviceType_Audio :OR: HALDeviceAudio_AudC
        SWI     XOS_Hardware
        BVS     %FT15
        CMP     r1, #-1
        ADREQ   r0, ErrorBlock_NoSoundDevices
        SETV    EQ
        BLVS    CopyError
        BVS     %FT15
d2764 3
a2766 2
        TEQ     r0, #0 ; Serious error or non-serious error?
        BEQ     %BT10
d2772 1
d2782 1
d2867 8
a2874 2
        LDR     r0, [r12, #RTSup_Handle]
        CMP     r0, #0
d2907 2
d2939 1
a2939 1
        MOV     r8, #0
d3022 1
a3022 1
; Custom DMA callback
d3029 1
a3029 1
CustomDMASync
d3047 21
d3083 1
d3095 9
a3103 1
        Push   "r14"
d3476 5
a3480 1
        ; Finally, perform mono mix-down and/or oversampling, if required.
d3483 2
a3484 2
        ANDS    r3, r3, #DoReverse+DoMono+DoOversample
        BEQ     BufferDone              ; nowt to do if both bits clear (r3 = 0)
d3486 1
a3486 1
        BEQ     StereoOnly
d3501 2
a3502 3
        TST     r3, #DoOversample       ; check which proc we need to call
        BEQ     MonoOnly                ; if no o/s, do just mono conversion
                                        ; else doing oversampling...
d3508 5
a3512 7
        
                                        ; At this point, possibilities are:
                                        ; Reverse Mono Oversample
                                        ; 0       0    1
                                        ; 0       1    1
                                        ; 1       0    1
                                        ; 1       1    1 (same as 0 1 1)
d3515 26
a3540 4
        MOVS    r3, r3, LSL #27         ; Shift reverse bit into carry, mono into sign
        BMI     MonoOver                ; do mono + oversample (+ stereo)
        BCS     StereoOver
        B       OverOnly
d3581 1
a3581 1
        Pull    "lr"
d3583 1
a3583 1
        MSR     CPSR_c, #SYS32_mode
d3704 5
@


1.14
log
@Rename exported flags
Inspection of DMADevice/GPIODevice/RTCDevice suggests the equivalent of C structs become HALDeviceTHING and enums become THINGFlagName. Rename AudioDevice's flags ot match that pattern.
No code change, not tagged.
@
text
@a3147 1
RTSup_Exit
d3151 1
@


1.13
log
@Fix crash if HAL device fails to initialise
Detail:
  s/Sound0 - Fix TryInitialise_Device not setting R0 to zero on exit if the HAL device fails to initialise. Whatever (non-zero) value was already in R0 would then be interpreted as an error pointer, most likely leading to a crash.
Admin:
  Tested on Raspberry Pi


Version 1.79. Tagged as 'Sound0HAL-1_79'
@
text
@a128 2
              GBLL    ARM810support
ARM810support SETL    {FALSE}
d994 1
a994 1
        SUB     r4, r4, #HALDevice_AudioRateTableSize ; address 0th entry of main freq info table
d996 1
a996 1
        ASSERT  HALDevice_AudioRateTableSize = 8
d998 1
a998 1
        LDRB    r3, [r1, #HALDevice_AudioRateTable_Period] ; pick up nominal period
d1011 1
a1011 1
        ASSERT  HALDevice_AudioRateTableSize = 8
d1013 1
a1013 1
        LDRB    r3, [r1, #HALDevice_AudioRateTable_Period] ; pick up nominal period
d1021 1
a1021 1
        ASSERT  HALDevice_AudioRateTableSize = 8
d1023 1
a1023 1
        LDRB    r3, [r1, #HALDevice_AudioRateTable_Period] ; pick up nominal period
d1032 2
a1033 2
26      LDRB    r2, [r1, #HALDevice_AudioRateTable_Period] ; pick up period to report back to user
        LDR     r0, [r1, #HALDevice_AudioRateTable_Frequency] ; get frequency value
d1182 2
a1183 2
        ASSERT  HALDevice_AudioRateTableSize = 8
        SUB     r1, r1, #8-HALDevice_AudioRateTable_Frequency
d1731 1
a1731 1
        LDR     r2, [r2, #HALDevice_AudioRateTable_Frequency] ; pick up frequency
d1743 1
a1743 1
        LDRB    r2, [r4, #HALDevice_AudioRateTable_Period] ; get nominal period from table entry
d1758 1
a1758 1
        LDR     r0, [r4, #HALDevice_AudioRateTable_Frequency] ; pick up frequency value from table entry
d1788 1
a1788 1
        ASSERT  HALDevice_AudioRateTableSize = 8
d1925 1
a1925 1
        ASSERT  HALDevice_AudioFlag_StereoReverse = 1
d1927 1
a1927 1
        ANDGE   lr, lr, #HALDevice_AudioFlag_StereoReverse
d2309 1
a2309 1
        ASSERT  HALDevice_AudioFlag_StereoReverse = 1
d2311 1
a2311 1
        ANDGE   lr, lr, #HALDevice_AudioFlag_StereoReverse
d2337 2
a2338 2
        ASSERT  HALDevice_AudioRateTableSize = 8
        ASSERT  HALDevice_AudioRateTable_Frequency = 0
d2342 1
a2342 1
        LDR     r3, [r0, #-HALDevice_AudioRateTableSize]!
d2349 1
a2349 1
        LDRB    r2, [r0, #HALDevice_AudioRateTable_Period-HALDevice_AudioRateTable_Frequency]
@


1.12
log
@Fix DoReverse flag aliasing the Level1 updated flag
Detail:
  s/Sound0 - Get rid of the two VIDC20-era Lin16 flag bits and shuffle the other flags down so that the top bit of the flags remains clear. In the buffer fill code the top bit is used to detect when the log-to-lin code needs recompiling, plus it's passed on to the level 1 handler so that it can detect updates, so having the bit permanently set if stereo reverse is in use could cause numerous issues.
Admin:
  Tested on Raspberry Pi
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/4/topics/2814


Version 1.78. Tagged as 'Sound0HAL-1_78'
@
text
@d2373 1
d2376 1
a2376 1
        EXIT        
@


1.11
log
@Don't complain if sound mixer doesn't have a speaker channel
Detail:
  s/Sound0 - *Speaker / Sound_Speaker no longer complains if a mixer is present but there's no speaker channel, and instead reports that the speaker is on. This matches the behaviour for if the mixer isn't present, and the behaviour of previous versions of SoundDMA which lacked speaker control (e.g. IOMD)
Admin:
  Tested on Raspberry Pi
  Fixes "Mixer channel not found" error from Zool & Twin World (although Twin World still lacks audio)


Version 1.75. Tagged as 'Sound0HAL-1_75'
@
text
@d273 6
a278 10
; Flags bits in NChannels/Flags byte: bottom 2 bits are log2nchan, next 2 bits are
; Lin16 flags, 1 bit for auto-oversampling flag, 1 bit for "oversampling active" flag,
; 1 bit for mono-isation flag, top bit for stereo reversal
; handler call "Level0 updated" flag.
DoReverse       *       &80             ; stereo reverse bit
DoMono          *       &40             ; mono-isation control bit
DoOversample    *       &20             ; oversampling active bit
OversampleFlag  *       &10             ; AutoOversampling flag from CMOS
Lin16Bits       *       &0C             ; flags for 16-bit linear mode (VIDC20)
Lin16Shift      *       2
d774 2
a775 1
; log2nchan (3 bits), spare (1 bit), 16-bit flags (2 bits), spare (2 bits)
d778 1
a778 1
        DCB     SCLogChannel                            ; Note: 16-bit flags are 0
d1552 1
a1552 1
;       R1[31:5]: reserved for expansion
d1918 3
a1920 12
; bit 6:5  form 16-bit sound control value. From Hdr:CMOS --
;
; Bit  5,6 = 16-Bit sound control, on VIDC20 machines including Risc PC.
;              0: no 16-bit sound output, use standard mu-law (default)
;              1: DAC clock is slave: 11.2896MHz ext clock: standard VIDC20 rates or
;                  44.1 KHz * 4/(4..45) can be used (as on ESP sound card).
;              2: DAC clock is slave: no ext clock: standard VIDC20 rates only
;              3: DAC clock is master: ext clock must be used for 16-bit sound
;                 (suitable sound clock driver must be installed)
        MOV     r2, r2, LSR #5-Lin16Shift ; shift right to bit position in Flags byte
        AND     r2, r2, #Lin16Bits+OversampleFlag ; extract the three applicable bits
        ORR     r4, r4, r2, LSL #24     ; set new flag bits in place
d1928 3
a1930 2
        ASSERT  DoReverse = &80
        ORRGE   r4, r4, lr, LSL #31
d2312 3
a2314 2
        ASSERT  DoReverse = &80
        ORRGE   r9, r9, lr, LSL #7
d3105 3
a3107 3
        ASSERT  DoReverse = &80
        ASSERT  DoMono = &40
        MOVS    r3, r3, LSL #25         ; Shift reverse bit into carry, mono into sign
@


1.10
log
@Make sure initial buffer size doesn't violate any constraints
Detail:
  s/Sound0 - Rather than manually calling WorkOutVIDCParams & UpdateHALParams, module initialisation now branches into Sound0Config in order to make sure all buffer size/sample rate/channel count constraints are checked.
Admin:
  Tested on Raspberry Pi
  Sound will probably partially work with latest firmware, but still die on the next settings change.


Version 1.74. Tagged as 'Sound0HAL-1_74'
@
text
@d1445 1
a1445 1
        BVS     %FT90
d1459 6
@


1.9
log
@Fix building of NEON optimised version
Detail:
  s/Sound0 - Limited ADR range prevented NEON version from building
Admin:
  Tested on BB-xM with high processor vectors


Version 1.73. Tagged as 'Sound0HAL-1_73'
@
text
@d869 1
d961 5
d1965 2
a1966 3
        BL      WorkOutVIDCParams
        BL      UpdateHALParams

d1968 1
@


1.8
log
@Add support for sound devices disappearing & re-appearing post-initialisation
Detail:
  Version, s/Sound0 - Reworked code to allow the module to cope with sound devices vanishing and then re-appearing once the module has initialised.
  It's handled in the same way as the other dependencies; if the device vanishes while sound is active, SoundDMA will automatically re-enable sound once a replacement device is found.
  While there's no device available, Sound_SampleRate will claim that the system only supports one sample rate - the rate which was last in use. Other SWIs to set the sound system parameters (e.g. channel count, buffer size, stereo positions) will work as normal.
  Once a new device is activated SoundDMA will adjust its settings to make sure they match the capabilities of the new device.
  Currently the system assumes there's only one sound device available; if a device vanishes then SoundDMA won't check for any other devices which are already present. There's also still the requirement that a device must be present in order for the module to initialise.
  Also fixed CustomDMACallback to obey the spec on the wiki (SoundRMA ptr now taken in ATPCS-friendly r1 instead of r12)
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 1.72. Tagged as 'Sound0HAL-1_72'
@
text
@d2184 1
a2184 1
        ADR     r0, SoundResetFunc
d2187 1
a2187 1
        ADR     r0, SoundDiedFunc
@


1.7
log
@Update audio controller API to version 2
Detail:
  hdr/AudioDevice - extended audio device structure for API version 2. This adds support for controllers that don't use DMAManager, runtime selection of stereo reversal, and device-dictated buffer minimum size & granularity constraints
  Version, s/Sound0, s/Sound0ARM, s/Sound0NEON - Stripped out StereoReverse compile-time switch, adding support for runtime selection instead. Added support for other new features of device API version 2.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 1.71. Tagged as 'Sound0HAL-1_71'
@
text
@d443 1
a443 1
DMAChannel        #  4                  ; DMA channel handle
d888 3
a890 2
        LDR     r3, [r2, #HALDevice_Version]
        CMP     r3, #2:SHL:16           ; Only available with API 2+
d989 2
d1053 5
d1080 3
d1177 2
d1358 1
a1359 1
        Pull    "r2-r3,r5-r7"
d1377 1
d1385 1
a1385 1
        MOV     r2, r0
d1392 1
a1392 1
        MOV     r0, r2
a1428 1
        LDR     r0, [r0, #HALDevice_AudioMixer]
d1430 2
d1702 3
a1704 1
        LDR     r1, [r4, #HALDevice_AudioNumRates]
d1710 1
d1718 3
d1730 2
d1756 1
d1988 10
a2002 1
 [ {FALSE} ; Not implemented yet!
a2003 1
 ]
d2011 2
a2012 1
; being left off 
d2018 1
d2025 2
a2026 1
        TEQ     r1,#Service_ModulePostInit
d2032 2
d2050 43
a2092 9
Module_RTSupport
        = "RTSupport", 0
Module_DMAManager
        = "DMAManager", 0
 [ UseNEON
Module_VFPSupport
        = "VFPSupport", 0
 ]
        ALIGN
d2161 2
a2162 1
        ; Corrupts r0,r2-r4
d2166 5
d2172 1
a2172 2
        MRS     r2, CPSR
        MOV     r4, lr
d2175 2
a2176 2
        MSR     CPSR_c, r2
        MOVVC   r3, #0 ; Something else might still be dead
d2178 1
a2178 1
        MOV     pc, r4
d2279 3
a2281 2
Initialise_Device ROUT
        ; Search for and initialise a HAL audio device
d2283 4
a2286 18
        ; Out: Error on failure, else all regs preserved
        Entry   "r0-r5,r8-r9,r12"
        LDR     r0, [r12, #HALDevice]
        CMP     r0, #0
        EXIT    NE
        ; Hunt for a suitable HAL audio device
        MOV     r5, r12 ; r5 becomes SoundRMA
        LDR     r0, =2:SHL:16 :OR: HALDeviceType_Audio :OR: HALDeviceAudio_AudC
        MOV     r1, #0
        MOV     r4, #0
        MOV     r8, #4
10      SWI     XOS_Hardware
        BVS     %FT15
        CMP     r1, #-1
        ADREQ   r0, ErrorBlock_NoSoundDevices
        SETV    EQ
        BLVS    CopyError
        BVS     %FT15
d2290 1
a2290 1
        BLO     %BT10
d2292 1
d2298 1
a2298 1
        BEQ     %BT10 ; Go back and look for another
d2315 1
d2317 1
a2317 1
        EXIT    EQ
a2321 1
        MOVVC   r8, #0
d2324 39
a2362 2
        STRVCB  r8, [r5, #ResetPending] ; Allow reset callbacks to be registered
        EXIT    VC
d2369 29
d2431 4
d2646 1
a2646 1
;  r12 = SoundRMA
d2657 3
a2659 3
        LDR     r1, [r12, #RTSup_Pollword]
        ADD     r1, r1, #1
        STR     r1, [r12, #RTSup_Pollword]
d2661 1
a2661 1
        CMP     r1, #1 ; Just woken up?
@


1.6
log
@Fix oversampling buffer size checks
Detail:
  s/Sound0 - After oversampling each sample is 8 bytes, not 4
Admin:
  Tested in OMAP3 ROM
  Playing MP3 files through DigitalCD/AudioMPEG no longer crashes


Version 1.70. Tagged as 'Sound0HAL-1_70'
@
text
@d275 1
a275 1
; 1 bit for mono-isation flag, top bit reserved (probably unnecessarily) for Level1Fill
d277 1
a279 1
OverMonoShift   *       5               ; shift to get to OS/Mono as 2-bit field
d883 23
a905 2
        ADD     r1, r1, #3              ; Mono/oversample code processes 4 words of (non-oversampled) linear data at a time
        BIC     r1, r1, #3
a911 4
        MOV     lr, #32                 ; ensure enough 8bit/16bit samples for >= 32bytes of raw data
        CMP     r1, lr, LSR #2
        MOVLT   r1, lr, LSR #2

d1314 1
a1314 1
        ; Call PreEnable
d1317 4
d1322 3
d1345 1
d1353 15
d1897 11
a1907 1
        STR     r4, [r10, #Config]      ; and store config, with them in
d1968 1
a1968 1
; * Init/finalisation of DMAManager
d2061 3
d2213 1
a2213 1
        LDR     r0, =1:SHL:16 :OR: HALDeviceType_Audio :OR: HALDeviceAudio_AudC
d2228 1
a2228 1
        ; Device is valid, try to active it
d2239 11
d2316 7
d2458 1
d2497 1
a2497 1
        Push    "lr"
d2507 26
a2532 1
        Pull    "pc"
d2936 3
a2938 3
        MOV     r3, r3, LSR #OverMonoShift
        ANDS    r3, r3, #3              ; bit 0 -> oversamp. bit 1 -> mono
 [ StereoReverse
a2939 3
 |
        BEQ     BufferDone              ; nowt to do if both bits clear (r3 = 0)
 ]
d2943 2
a2944 2
	; OK, doing some sort of filtering operation.  Set up some constants
	; used in all cases...
d2954 2
a2955 2
        CMP     r3, #2                  ; check which proc we need to call (1,2,3)
        BEQ     MonoOnly                ; if r3 = 2, do just mono conversion
d2962 13
a2974 2
        BLT     OverOnly                ; if r3 < 2 (i.e. 1), only oversample
        B       MonoOver                ; if r3 > 2 (i.e. 3), do mono + oversample
@


1.5
log
@Fix building of non-NEON version
Detail:
  s/Sound0 - unguarded call to Finalise_NEON was causing an error if the NEON code was disabled
Admin:
  Non-NEON version builds properly again


Version 1.69. Retagged as 'Sound0HAL-1_69'
@
text
@d1143 1
a1143 1
        CMP     r1, #SoundDMABufferSize/4 ; check against size limit at Fs*2
@


1.4
log
@Major overhaul
Detail:
  s/Sound0ARM - Mulaw-to-linear and mono/oversampling code ripped out of s/Sound0 and moved to its own file. Minor optimisations for ARMv6+
  s/Sound0NEON - NEON-optimised Mulaw-to-linear and mono/oversampling code
  Version - Update UseLDRSH switch to depend on NoARMv4 arch flag. Add UseNEON switch.
  hdr/Sound - Added new sound start/stop/config changing service call & Sound_ReadSysInfo SWI definitions
  s/Sound0:
   - Added support for new service calls & Sound_ReadSysInfo SWI
   - Added support for oversampling
   - Fixed up stereo reversal to work if NoUnaligned is TRUE
   - Added support for using the new NEON-optimised buffer/manipulation fill routines. Currently whether to use NEON or not must be selected at compile time.
   - Added timing/profiling code, controlled via TimingCode switch. Uses a HAL timer to measure performance of various sections of the buffer fill/IRQ handling code
   - Updated buffer size constraints in Sound0Config to properly cope with oversampling and NEON code
   - Fixed Sound_SampleRate 3 corrupting the stored sound period value. This would cause Sound_Configure to switch to a different sample rate on next call (even if all 0 parameters were passed)
   - Fixed finalisation not releasing the DMA channel
   - Changed buffer fill code to run in an RTSupport routine instead of in the DMAManager DMASync callback (since we're not meant to be enabling IRQs from in there!). Old code resulted in buffer filling going out of sync with DMA if the IRQ timing was right.
   - Rewrote init/finalisation and sound enable/disable code so things don't fail horribly if one of the required modules (DMAManager, RTSupport, VFPSupport) dies.
   - Sound will be disabled if one of the required modules dies, but will automatically re-enable as the module(s) become available again.
  Resources/UK/Messages, Resources/Germany/Messages - New error messages
Admin:
  Tested in ROM softload on BB-xM, in both ARM and NEON versions
  German resources are in need of translation


Version 1.69. Tagged as 'Sound0HAL-1_69'
@
text
@d2078 1
d2081 1
@


1.3
log
@Fix the 'Module_VectorCode' IRQ handler to preserve R14_svc before calling any SWIs
Detail:
  s/Sound0 - Module_VectorCode, which is currently used to respond to FIFO underflows in the OMAP3 sound driver, wasn't saving R14_svc before calling a SWI from IRQ mode, potentially leading to malfunction if the CPU was in SVC mode at the time of the interrupt. This has been fixed.
Admin:
  Tested on rev C2 beagleboard


Version 1.67. Tagged as 'Sound0HAL-1_67'
@
text
@d156 2
d212 11
d232 1
a232 1
Semaphore # 4
d343 1
d383 9
d405 2
a406 180
;
; MT, May/June 1994.
;
; Code fragments used to convert from 1/2/4/8 channels of
; 8-bit mu-law sound in the "logical" buffer, to 2 channels of
; either 16-bit linear sound or 8-bit mu-law sound in the same
; buffer, now treated as a "physical" buffer to be output by DMA.
; Note the complexities caused because the logical buffer may
; be smaller than, the same size as, or bigger than the physical
; buffer, depending on the input and output sample-group sizes.
; There are always the same number of sample-groups in the physical
; buffer as in the logical buffer, and the sample rate is unaltered
; also.
;
; These fragments are compiled dynamically after any sound system
; reconfiguration or stereo position change, to cause the correct
; translation of data after the next sound DMA interrupt.  The compiled
; code lives in module workspace, whereas the conversion table stays
; here in module code space (though it might usefully be copied into
; RAM to maximise access speed if this code is running from ROM).
;
; On call to composite routine
;
;   r12 = start of logical/physical buffer
;   r11 = end of physical buffer (1,2 channels) or
;         start of physical buffer (4,8 channels)
;   r10 = end of logical buffer
;   r9  = base of 256-entry, 512-byte table converting mu-law bytes
;         (treated as 0..255, i.e. unsigned) to 16-bit signed
;         values in the range -3952..+3952.  See below
;         for more details on the format of entries.
;   r8  = 0xFF - mask for extraction of individual mu-law bytes
;   r5  = 0x7FFF - constant used for limit operation if soundgain > 0
;
; during call:
;   r7  = 32-bit accumulator for right channel linear data
;   r6  = 32-bit accumulator for left channel linear data
;   r0, r1, r3 - miscellaneous intermediate values
;   r2, r4, r5 - unused

; Conversion table (placed here to avoid addressing problems for the
; compiler).  Compute linear values from mu-law at assembly time.  For
; reference, the direct linear equivalents of mu-law values are:
;
; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
; 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46
; 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108
; 112 120 128 136 144 152 160 168 176 184 192 200 208 216 224 232
; 240 256 272 288 304 320 336 352 368 384 400 416 432 448 464 480
; 496 528 560 592 624 656 688 720 752 784 816 848 880 912 944 976
; 1008 1072 1136 1200 1264 1328 1392 1456 1520 1584 1648 1712 1776 1840 1904 1968
; 2032 2160 2288 2416 2544 2672 2800 2928 3056 3184 3312 3440 3568 3696 3824 3952
;

;
; JL, Jan 2010
;
; Now updated to allow use of LDRSH instead of unaligned LDR's. This required the following changes:
; * Swapping the two halfwords of each convtable entry (although I doubt many people would notice if the waveform was inverted!)
; * Using different shift offsets in stereo_code
;   - In some cases this also resulted in shorter instruction sequences
; * Using different shift offsets in byte_ext_TAB, due to LDRSH not supporting a shift of Rm
;   - r8 was also changed to 0x1fe
; * data_load_TAB was also tweaked to avoid an unaligned LDR for the 2-byte case
;

                  GBLA StereoShiftOffset
 [ UseLDRSH
StereoShiftOffset SETA 0
 |
StereoShiftOffset SETA 16
 ]


; Helper macros to perform MOV and ADD, shifted by the stereo shift offset
; Apart from helping to keep the code readable, they also avoid making objasm cry like a baby when told to ASR #0 :(
        MACRO
        MOVASR  $rd, $rm, $shift
 [ ("$shift" = "0") :LAND: UseLDRSH
        MOV  $rd, $rm
 |
        MOV  $rd, $rm, ASR #$shift+StereoShiftOffset
 ]
        MEND
        MACRO
        ADDASR  $rd, $rn, $rm, $shift
 [ ("$shift" = "0") :LAND: UseLDRSH
        ADD  $rd, $rn, $rm
 |
        ADD  $rd, $rn, $rm, ASR #$shift+StereoShiftOffset
 ]
        MEND

convtable
        GBLA    chord
        GBLA    point
        GBLA    step
        GBLA    value
value   SETA    0
chord   SETA    0
        WHILE   chord < 8
step      SETA  1 :SHL: chord
point     SETA  0
          WHILE point < 16
 [ UseLDRSH
            DCD         ((value :SHL: 2) :AND: &FFFF) :OR: (((-value) :SHL: 2) :SHL: 16)
 |
            DCD         (((-value) :SHL: 2) :AND: &FFFF) :OR: ((value :SHL: 2) :SHL: 16)
 ]
value       SETA        value + step
point       SETA        point + 1
          WEND
chord     SETA  chord + 1
        WEND

; When size (logical buffer) >= size (physical buffer) we must proceed
; forward, loading via r12 which is stepped forwards until it equals
; r10.  Note that in this case r11 starts off = r12.  When the size of
; the logical buffer < size of physical buffer, must move backwards -
; r11 is initialised to end of physical buffer; hence r10 moves
; backwards and r12 stays constant as end-stop for logical buffer.
; End-condition is still r10 = r12.

; Instruction sequence (1): loop begin (same for all configurations)
loop_head
        CMP     R10, R12                ; check for having finished
        Pull    PC, EQ                  ; return if so

; Instruction sequence (2): load up a sample-time's worth of data (1..8 bytes), and
; check whether it is all zero. One instruction for each part, two instructions
; per sequence.  Indexed by log2nchan.
data_load_TAB
        LDRB    r1, [r10, #-1]!         ; instruction for loading 1 byte (backwards)
        MOVS    r1, r1, LSL #24         ; get 1 byte in top byte of r1, zero in rest

 [ UseLDRSH
        LDRH    r1, [r10, #-2]!         ; instruction for loading 2 bytes (backwards)
 |
        LDR     r1, [r10, #-2]!         ; instruction for loading 2 bytes (backwards)
 ]
        MOVS    r1, r1, LSL #16         ; get 2 bytes in top half of r1, zero low bytes

        LDR     r1, [r12], #4           ; instruction for loading 4 bytes (forwards)
        MOVS    r1, r1                  ; check it for all 4 bytes being 0

        LDMIA   r12!, {r0,r1}           ; instruction for loading 8 bytes (forwards)
        ORRS    r3, r0, r1              ; result -> temp, to avoid corruption of r0/r1

; Instruction sequence (3): conditionally store a zero output value,
; for when input data is all 0.   Indexed by log2nchan>>1.
zero_store_TAB
; for log2nchan>>1 = 0 (i.e. 1, 2 channels)
        STREQ   r1, [r11, #-4]!         ; if 0, store out a zero and
; for log2nchan>>1 = 1 (i.e. 4, 8 channels)
        STREQ   r1, [r11], #4           ; if 0, store out a zero and

; Instruction sequence (4): conditionally branch back to
; start of loop if input data was all 0 for this sample.
zero_branch
        BEQ     .-(5*4)                 ; branch back to loop_head

; Instruction sequence (5): extract one byte out of 0 through 7 of the 1..8
; bytes picked up by instruction sequence (2), and put it into r3, testing
; for 0 as this is done.  One instruction word for each case.  Entries in
; this table are used starting from the (8-nchan)'th one, up to the required
; number of channels, hence the apparent oddity of the zero-data test
; instructions for 1,2 channels.  Note that the 1-channel case is slightly
; inefficient since we have already checked for all 1 byte being zero - if we
; hadn't done a LSL 24 in the process, we could dispense with this
; instruction, but that would be less regular so we just take the minor hit.
byte_ext_TAB
 [ UseLDRSH ; LDRSH lacks support for shifting Rm, so we must preshift here.
        ANDS    r3, r8, r0, LSL #1      ; byte 0
        ANDS    r3, r8, r0, LSR #7      ; byte 1
        ANDS    r3, r8, r0, LSR #15     ; byte 2
        ANDS    r3, r8, r0, LSR #23     ; byte 3
        ANDS    r3, r8, r1, LSL #1      ; byte 4
        ANDS    r3, r8, r1, LSR #7      ; byte 5
        ANDS    r3, r8, r1, LSR #15     ; byte 6
        ANDS    r3, r8, r1, LSR #23     ; byte 7
d408 1
a408 8
        ANDS    r3, r8, r0              ; byte 0
        ANDS    r3, r8, r0, LSR #8      ; byte 1
        ANDS    r3, r8, r0, LSR #16     ; byte 2
        ANDS    r3, r8, r0, LSR #24     ; byte 3 (could just be MOVS)
        ANDS    r3, r8, r1              ; byte 4
        ANDS    r3, r8, r1, LSR #8      ; byte 5
        ANDS    r3, r8, r1, LSR #16     ; byte 6
        ANDS    r3, r8, r1, LSR #24     ; byte 7 (could just be MOVS)
a410 367
; Instruction sequence (6): load up linear value for mu-law byte, from
; table.  This always follows the extraction instruction (above) and is
; conditionalised on Z flag from ANDS, to allow faster execution on zero
; byte value (i.e. no load is actually done and r3 stays 0).  N.B.  As
; should be apparent from its definition, The table holds 16-bit values,
; arranged as +ve/-ve pairs, in words.  The access is indexed with LSL #1
; (i.e. 2-byte entries) but is performed as an LDR, so we get both -ve and
; +ve values, with the required one in the top half of r3, because of ARM's
; data rotation on non-word aligned LDRs.  The subsequent stereo position
; code extracts this value using ASR #n where n varies according to the
; required multiplicative factor for the particular stereo position.
; Within the table entries, each value is the basic 12-bit linear value,
; shifted left by 2, and sign-extended to 16-bits.  This leaves the bottom
; two bits 0, so that ASR #18, 17 or 16 then produces the original value
; times 1, 2 or 4 (respectively), sign extended to 32 bits.

conv_byte
 [ UseLDRSH
        LDRNESH r3, [r9, r3]
 |
        LDRNE   r3, [r9, r3, LSL #1]
 ]

; Instruction sequence (7): set or add linear value just loaded, in the
; correct proportions according to stereo position for channel, into stereo
; accumulators.  Some sequences are two instructions, others 3, so we store
; them here as 3 words each (for indexing during compilation) with the 3rd
; one 0 if not required.  The sequences come in pairs, the first of each
; pair being for the first channel, when the accumulators are initialised,
; and the second for subsequent channels, when the accumulators are added
; to.  This saves at least one instruction in the generated code, over
; pre-initialising both accumulators to 0, and more often than not, 2.

stereo_code
; 100% left
; code for first channel: r6 = (r3 >> 18) * 6 = (r3 >> 17) + (r3 >> 16)
 [ UseLDRSH ; LDRSH version can save 1 instruction here
        ADD     r6, r3, r3, ASR #1
        MOV     r7, #0
        DCD     0
 |
        MOV     r6,     r3, ASR #17
        MOV     r7, #0                  ; init right acc to 0
        ADD     r6, r6, r3, ASR #16
 ]
; code for remaining channels
        ADDASR  r6, r6, r3, 1
        ADDASR  r6, r6, r3, 0
        DCD     0
; 83% left
; code for first channel: r6 = (r3 >> 18) * 5 = (r3 >> 16) + (r3 >> 18); r7 = r3 >> 18
 [ UseLDRSH ; LDRSH version can save 1 instruction here
        ADD     r6, r3, r3, ASR #2
        MOV     r7,     r3, ASR #2
        DCD     0
 |
        MOV     r6,     r3, ASR #16
        MOV     r7,     r3, ASR #18
        ADD     r6, r6, r3, ASR #18
 ]
; code for remaining channels
        ADDASR  r6, r6, r3, 0
        ADDASR  r7, r7, r3, 2
        ADDASR  r6, r6, r3, 2
; 67% left
; code for first channel: r6 = (r3 >> 18) * 4 = r3 >> 16; r7 = (r3 >> 18) * 2 = r3 >> 17
        MOVASR  r6,     r3, 0
        MOVASR  r7,     r3, 1
        DCD     0
; code for remaining channels
        ADDASR  r6, r6, r3, 0
        ADDASR  r7, r7, r3, 1
        DCD     0

; Centre position.  Note that to avoid overflow problems we compute
; r3*1.5, then add r3 ASR #17 (== >> 18 then *2) to each accumulator.
; The multiplication by 1.5 is exact because we have 2 spare 0 bits at
; the bottom of the value.  Overflow from the multiplication in the
; lower half (when that is -ve, i.e. when the required value is +ve)
; does not interfere, since it may reach bit 16, but that gets shifted
; out.

; Code for first channel
        ADD     r3, r3, r3, ASR #1      ; * 1.5
        MOVASR  r6,     r3, 1           ; == shifted right by 18, then * 2
        MOVASR  r7,     r3, 1
; Code for remaining channels
        ADD     r3, r3, r3, ASR #1
        ADDASR  r6, r6, r3, 1
        ADDASR  r7, r7, r3, 1

; 67% right: the mirror of 67% left
; code for first channel
        MOVASR  r7,     r3, 0
        MOVASR  r6,     r3, 1
        DCD     0
; code for remaining channels
        ADDASR  r7, r7, r3, 0
        ADDASR  r6, r6, r3, 1
        DCD     0

; 83% right: mirror of 83% left
; code for first channel
 [ UseLDRSH ; LDRSH version can save 1 instruction here
        ADD     r7, r3, r3, ASR #2
        MOV     r6,     r3, ASR #2
        DCD     0
 |
        MOV     r7,     r3, ASR #16
        MOV     r6,     r3, ASR #18
        ADD     r7, r7, r3, ASR #18
 ]
; code for remaining channels
        ADDASR  r7, r7, r3, 0
        ADDASR  r6, r6, r3, 2
        ADDASR  r7, r7, r3, 2

; 100% right: mirror of 100% left
; code for first channel
 [ UseLDRSH ; LDRSH version can save 1 instruction here
        ADD     r7, r3, r3, ASR #1
        MOV     r6, #0
        DCD     0
 |
        MOV     r7,     r3, ASR #17
        MOV     r6, #0                  ; initialise left acc to 0
        ADD     r7, r7, r3, ASR #16
 ]
; code for remaining channels
        ADDASR  r7, r7, r3, 1
        ADDASR  r7, r7, r3, 0
        DCD     0

; Instruction sequence (8): scaling code, to convert accumulated values
; (32-bit) back into signed 16-bit numbers.  For 8 channels, the maximum
; absolute value in either accumulator is 6*3952*8 = 189696.  To convert
; this into the range 0..32767 requires multiplying by 32767/189696 =
; .1727342...  We approximate this by multiplying by 11/64 = .171875,
; achieved using ADDs/shifts for the *11 and ASR #6 for the /64.  Exactness
; is unimportant, since all the slightly low value introduces is a small
; gain reduction.  For 1, 2 or 4 channels, the maximum value reduces in
; proportion to the number of channels, so the code is the same except for
; the N in ASR #N which is 3,4,5,6 for 1,2,4,8 channels.

; Version 1.52 onwards: supports *soundgain giving 0 to +21dB additional
; gain, with 3dB increments, in mu-law to linear conversion.  This is
; achieved by using a multiplier of *11 and a divisor of 64 (ASR #6) to give
; 0dB for the 8-channel case, with reducing right shifts as channel count
; decreases or gain is increased in 6dB steps.  For the +3dB steps, don't do
; the mul by 11, but divide by 4 (ASR #2) for 8-channel case, to give
; effectively a +3dB increment, and again reduce the right shift constant or
; go to a left shift for reducing channel count or each extra +6dB gain.
;

; (8a): First the *11 code, the same for all configurations: this is inserted
; only when soundgain is even (i.e. 0dB, 6dB, 12dB, 18dB)
scale_mul_even
        ADD     r0, r6, r6, LSL #1      ; r6 * 3
        ADD     r6, r0, r6, LSL #3      ; + r6 * 8 = r6 * 11
        ADD     r0, r7, r7, LSL #1      ; r7 * 3
        ADD     r7, r0, r7, LSL #3      ; + r7 * 8 = r7 * 11

; (8b): gain scaling code, 2 instructions; table indexed by
;       7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4).
scale_TAB                       ;       1ch     2ch     4ch     8ch
                                ;----------------------------------
        MOV     r6, r6, LSL #4  ;0      +21     -       -       -  GAIN (soundgain odd)
        MOV     r7, r7, LSL #4  ;       -       -       -       -  GAIN (soundgain even)

        MOV     r6, r6, LSL #3  ;1      +15     +21     -       -
        MOV     r7, r7, LSL #3  ;       -       -       -       -

        MOV     r6, r6, LSL #2  ;2      +9      +15     +21     -
        MOV     r7, r7, LSL #2  ;       -       -       -       -

        MOV     r6, r6, LSL #1  ;3      +3      +9      +15     +21
        MOV     r7, r7, LSL #1  ;       -       -       -       -

        DCD     0               ;4      -       +3      +9      +15
        DCD     0               ;       +18     -       -       -

        MOV     r6, r6, ASR #1  ;5      -       -       +3      +9
        MOV     r7, r7, ASR #1  ;       +12     +18     -       -

        MOV     r6, r6, ASR #2  ;6      -       -       -       +3
        MOV     r7, r7, ASR #2  ;       +6      +12     +18     -

        MOV     r6, r6, ASR #3  ;7      -       -       -       -
        MOV     r7, r7, ASR #3  ;       +0      +6      +12     +18

        MOV     r6, r6, ASR #4  ;8      -       -       -       -
        MOV     r7, r7, ASR #4  ;       -       +0      +6      +12

        MOV     r6, r6, ASR #5  ;9      -       -       -       -
        MOV     r7, r7, ASR #5  ;       -       -       +0      +6

        MOV     r6, r6, ASR #6  ;10      -       -       -       -
        MOV     r7, r7, ASR #6  ;       -       -       -       +0

; Instruction sequence (8c): do limiting (clipping) on output values:
; only used if soundgain > 0.
limit
        MOV     r0, r6, ASR #31         ; get r6 sign bit throughout r0
        CMP     r0, r6, ASR #15         ; check for overflow
        EORNE   r6, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r6
        MOV     r0, r7, ASR #31         ; get r7 sign bit throughout r0
        CMP     r0, r7, ASR #15         ; check for overflow
        EORNE   r7, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r7

; Instruction sequence (9): combine 2 x 16-bit values (sign-ext'd to
; 32-bits) from r6 and r7 into r6 ready for storing.  Same for all
; configurations.
combine
        MOV     r6, r6, LSL #16
        MOV     r7, r7, LSL #16
        ORR     r6, r6, r7, LSR #16

; Instruction sequence (10): store out the result: code for either
; direction (1 instruction each).  Index by log2nchan>>1.
store_sample
; for 1,2 channels
        STR     r6, [r11, #-4]!         ; backwards
; for 4,8 channels
        STR     r6, [r11], #4           ; forwards

; Instruction sequence (11): branch back to start of loop.  This
; instruction is adjusted in accordance with the total size of the loop
; code, which is dependent on both configuration (# channels) and also on
; individual stereo positions per channel.
loop_end
        B       .                       ; patched during compilation

; Defined maximum size of the conversion code.  This is:
;       size of sequence(1;2;3;4)         = 4 * (       (2 + 2 + 1 + 1)
; + 8 * size of sequence(5;6;7(max-size))        +  8 * (1 + 1 + 3)
; +     size of sequence(8a;8b;8c;9;10;11)       +      (4 + 2 + 6 + 3 + 1 + 1))

MAXLinConvCodeSize *  4 * ((2 + 2 + 1 + 1) + 8 * (1 + 1 + 3) + (4 + 2 + 6 + 3 + 1 + 1))


; Compile: generate a conversion routine appropriate to current configuration and
; stereo position settings.
; Entry conditions:
;   SVC or IRQ mode, IRQs disabled (essential for atomic rewrite of code!)
; Parameters:
;   r0 = log2nchan, i.e. 0 -> 1 channel, 1 -> 2 chans, 2 -> 4 chans, 3 -> 8 chans
;   r1 = pointer to space for compiled routine, in module workspace
;   r2 = compacted array of stereo position values, 8x3 bits each (1-based)
;        in bits 0..23, with soundgain (0..7) in top byte.

compile
        STMFD   sp!, {r1,r3-r9,lr}      ; save r3-r9,pc', and code start address (r1) for later

        ; (1): loop head code (fixed, 2 instructions)
        ADR     r3, loop_head
        LDMIA   r3,  {r4,r5}
        STMIA   r1!, {r4, r5}
        ; (2): data load and zero check: 2 instructions, indexed by log2nchan
        ADR     r3, data_load_TAB
        ADD     r3, r3, r0, LSL #3      ; 8 bytes each
        LDMIA   r3,  {r4, r5}           ; get 2 instructions
        STMIA   r1!, {r4, r5}           ; store them
        ; (3): conditional zero-store
        ADR     r3, zero_store_TAB
        MOV     r4, r0, LSR #1          ; index by log2nchan>>1
        LDR     r4, [r3, r4, LSL #2]    ; 4 bytes each, get 1 instr
        STMIA   r1!, {r4}               ; store it
        ; (4): conditional branch back
        LDR     r4, zero_branch         ; get the instruction
        STMIA   r1!, {r4}               ; store it out

        ; preserve soundgain value, for later (r2 gets shifted in next loop)
        MOV     r7, r2, LSR #24         ;

        ; Now the per-channel code.  Get r9 as nchans, and use r8
        ; as loop variable from 0 to nchans-1.
        MOV     r9, #1
        MOV     r9, r9, LSL r0          ; get nchans in r9
        MOV     r8, #0                  ; start at channel 0
10
        ; (5): byte-extraction code, per channel
        ADR     r3, byte_ext_TAB+8*4
        SUB     r3, r3, r9, LSL #2      ; start from (8-nchan)th entry
        LDR     r4, [r3, r8, LSL #2]    ; get the instruction for this channel
        STMIA   r1!, {r4}               ; store it out
        ; (6): byte-conversion (1 instruction, fixed)
        LDR     r4, conv_byte           ; get it
        STMIA   r1!, {r4}               ; store it
        ; (7): stereo positioning: index by channel position, and by
        ; whether this is the first channel (channel 0) or not.
        ADR     r3, stereo_code
        AND     r4, r2, #7              ; get this channel's value
        MOV     r2, r2, LSR #3          ; shift remaining channels down
        SUB     r4, r4, #1              ; convert to 0-based value
        ADD     r4, r4, r4, LSL #1      ; * 24 (3 w/seq * 2 seq/pos * 4b/w), first *3...
        ADD     r3, r3, r4, LSL #3      ; then *8, to index table of sequences
        CMP     r8, #0                  ; if not on channel 0...
        ADDNE   r3, r3, #3*4            ;  skip on to second 3-word seq of pair
        LDMIA   r3, {r4,r5,r6}          ; pick up three words
        CMP     r6, #0                  ; check for last being 0 (unused)
        STMEQIA r1!, {r4,r5}            ; if so, store out 2 only
        STMNEIA r1!, {r4,r5,r6}         ; else store out all 3

        ; OK, done one channel's code.  Step on.
        ADD     r8, r8, #1
        CMP     r8, r9
        BLT     %BT10                   ; branch back if more channels to do

        ; (8): scaling code, in three parts.
        ; (8a): if soundgain is even, multiply by 11 (same for all modes) - 4 insts
        ;       note: r7 holds soundgain value from above
        TST     r7, #1
        ADREQ   r2, scale_mul_even
        LDMEQIA r2!, {r3,r4,r5,r6}
        STMEQIA r1!, {r3,r4,r5,r6}

        ; (8b): next perform scaling (shifting) as required, using
        ;  scale_TAB[7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4)]

        ADR     r2, scale_TAB+7*2*4     ; address scale_TAB[7]
        SUB     r6, r0, r7, LSR #1      ; compute (log2nchan - soundgain DIV 2)
        SUBNE   r6, r6, #4              ; if soundgain odd, subtract 4 (c/c still valid)
        ADD     r2, r2, r6, LSL #3      ; then scale for 2 instructions/entry
        LDMIA   r2, {r4,r5}             ; get the 2 instructions
        CMP     r4, #0                  ; if first instr is not 0 (for NOP)...
        STMNEIA r1!, {r4,r5}            ; ...store them

        ; (8c) perform limiting on sample values if required (i.e. soundgain > 0)
        ADR     r2, limit
        CMP     r7, #0
        LDMNEIA r2,  {r3,r4,r5,r6,r7,r8}  ; 6 instructions (3/channel)
        STMNEIA r1!, {r3,r4,r5,r6,r7,r8}  ; store them

        ; (9): combining two samples into 1 word - 3 fixed instructions
        ADR     r3, combine
        LDMIA   r3, {r4,r5,r6}          ; get them
        STMIA   r1!, {r4,r5,r6}         ; store them

        ; (10): store out the sample, 1 instruction - 2 cases.
        ADR     r3, store_sample
        MOV     r4, r0, LSR #1          ; get log2nchan>>1
        LDR     r4, [r3, r4, LSL #2]    ; index table of single word instrs
        STMIA   r1!, {r4}               ; store it out

        ; (11): branch back to loop start code.  Need to compute offset here
        LDR     r4, loop_end            ; get the B . instruction (note: bits 23..3 are 1)
        LDMFD   sp!, {r0}               ; pop original code start (loop top)
        SUB     r3, r1, r0              ; work out offset from there to . now
        SUB     r4, r4, r3, LSR #2      ; subtract offset (in words) to get instr
        STMIA   r1!, {r4}               ; store it out and we're done!
        
    [ StrongARM
        MRS     r3, CPSR
        MSR     CPSR_c, #I32_bit+SVC32_mode
        MOV     r5, lr_svc
        SUB     r2, r1, #4
        MOV     r1, r0
        MOV     r0, #1
        SWI     XOS_SynchroniseCodeAreas
        MOV     lr_svc, r5
        MSR     CPSR_c, r3
    ]

        ; All done!
        LDMFD   sp!, {r3-r9,pc}         ; recover saved regs and go home


d420 2
a421 2
HALBuffLen        #  2                  ; Softcopy of BuffLen programmed in HAL device 
DMACurBuf         #  1                  ; Flag for which buffer should be filled next
d423 2
d431 7
d440 1
d447 20
a466 1
                  
d469 14
d815 1
a872 1
        BEQ     %FT20
d875 4
d883 7
a889 1
        LDRB    lr, [r10, #Flags]
a890 4
        MOV     lr, #SoundDMABufferSize ; limit no. samples to
        CMP     r1, lr, LSR #2          ; 4096/4=1024
        MOVGT   r1, lr, LSR #2          ; (largest form always 16bit stereo)
19
d897 1
a897 1
20      CMP     r2, #0                  ; r2 processing
d957 1
a957 1
        Push    "r0,r1,r3,lr"
d964 1
a964 4
; supported in this configuration.  This is effectively only rates which can
; be used in 4-channel mode, i.e. with period a multiple of 4usec, and in fact
; below 40usec (25kHz), just 8-channel-capable (N*8usec) rates, to allow for 2x
; oversampling.  Scan the appropriate subset of the tabulated frequencies,
d966 2
a968 3
        Debug   swi,"16bit output"

        Push    "r4,r5,r6,r7,r8"
a1012 1
        Pull    "r4,r5,r6,r7,r8"
d1022 4
a1025 3
        LDR     r1, [r10, #SoundRMA]
        STR     r0, [r1, #CurSRValue]   ; update frequency
        STR     lr, [r1, #CurSRIndex]   ; and index of frequency
d1030 2
a1031 1
        Pull    "r0,r1,r3,pc"           ; pop log2nchan, old r1, old r3, return PC
d1053 4
a1056 2
UpdateHALParams Entry "r0-r4,r12"
        LDR     r2, [r10, #SoundRMA]
d1058 1
a1058 1
        LDRH    r0, [r2, #HALBuffLen]
d1060 1
d1062 1
a1062 1
        STRNEH  r3, [r2, #HALBuffLen]
d1064 1
a1064 1
        LDR     r0, [r2, #HALBuffLen]
d1066 2
a1067 1
        MOV     r3, r3, LSL #16
d1069 2
a1070 2
        ; Avoid overwriting DMACurBuf & ResetPending. Having those as 1 byte variables is probably more hassle than it's worth :(
        MOVNE   r3, r3, LSR #16
d1072 2
a1073 2
        MOVNE   r3, r3, LSR #8
        STRNEB  r3, [r0, #HALBuffLen+1]
d1075 9
a1083 5
        LDREQ   r0, [r2, #HALSRIndex]
        LDR     r1, [r2, #CurSRIndex]
        CMPEQ   r0, r1
        STRNE   r1, [r2, #HALSRIndex]
        EXIT    EQ ; Exit if nothing to update in HAL
d1088 10
a1097 2
        LDR     r0, [r2, #HALDevice]
        SUB     r1, r1, #1              ; 0-based index for HAL
d1103 1
d1106 19
d1129 1
a1129 1
;      r3 = unadjusted DELTA value, for non-oversampling case
d1134 2
a1135 8
;      r3 = unadjusted DELTA for normal or oversampling as required
process_oversample Entry "r1,r2"
 [ {TRUE}
        ! 0, "TODO - fix oversampling for new HAL API"
        ; basically, we either need to scan the sample rate table to find a suitable entry, or we need an extra flag we can pass to SetRate to say whether we want oversampling or not (and the sample rate table updating to flag which entries are oversample-capable)
        ; also note that code which calls process_oversample currently isn't guaranteed to do anything except make sure R0 is the flags value
        BIC     r0, r0, #DoOversample
 |
d1145 18
a1162 1
        ; OK, set up for oversampling....
d1164 1
a1164 1
        MOV     r3, r3, LSL #1          ; multiply final frequency by 2 to generate Fs*2.
a1165 1
 ]
d1174 1
a1174 1
;       IRQs disabled
d1176 3
a1178 2
; Out   r0 = previous enable state
;       IRQs enabled!
d1180 1
a1180 1
Sound0Enable Entry "r1,r4"
d1189 6
d1207 1
a1207 3
        MRS     r4, CPSR
        BIC     r4, r4, #I32_bit
        MSR     CPSR_c, r4
d1212 1
a1212 1
        Push    "r2-r3,r12"
d1218 2
a1219 1
        SWI     XDMA_TerminateTransfer
d1222 1
a1222 1
        Pull    "r2-r3,r12",VS
d1228 17
a1244 1
        Pull    "r2-r3,r12"
d1255 2
a1256 1
15      MOV     r14, #0                 ; Clear semaphore. Common ep
d1260 1
a1260 3
        MRS     r4, CPSR
        BIC     r4, r4, #I32_bit
        MSR     CPSR_c, r4
d1262 15
a1276 1
        LDR     r4, [r10, #SoundRMA]
d1278 1
a1278 3
        ; Reset DMACurBuf to make sure buffer fill stays in sync with DMA
        MOV     r0, #0
        STRB    r0, [r4, #DMACurBuf]
a1279 1
        Push    "r2-r3,r5-r6"
d1281 1
a1281 1
        ADD     r5, r4, #DMAScatter+8
d1285 1
a1285 1
        MOV     r6, r6, LSL #16        ; 16-bit buffer length in r5
d1292 5
d1298 1
d1303 1
d1307 1
a1307 1
        LDR     r1, [r4, #DMAChannel]
d1312 3
a1314 4
        Pull    "r2-r3,r5-r6", VS
        EXIT    VS
        LDR     r4, [r10, #SoundRMA]
        STR     r0, [r4, #DMATag]
d1317 1
a1317 1
        LDR     r0, [r4, #HALDevice]
d1321 1
a1321 1
        Pull    "r2-r3,r5-r6"
d1328 20
d1519 1
a1519 1
        Push    "r1,r3"
d1524 2
d1528 2
a1529 1
        Pull    "r1,r3"
d1531 2
a1532 1
        EXIT
d1640 1
a1640 1
Sound0SampleRate Entry "r3,r4,r5"
d1670 1
a1670 1
        MOVS    r5, r2                  ; move register, check for error (r2=0)
d1672 1
a1672 1
        Push    "r1"                    ; save new index
d1675 1
d1680 1
a1680 2
        BL      process_oversample      ; work out whether o/s needed, fix DELTA if so
        ; Note: Following assumes r3 hasn't been changed by process_oversample
d1683 7
a1689 6
        Pull    "lr"                    ; recover new index
        LDR     r1, [r3, #CurSRIndex]   ; get previous samplerate index for return to user
        STR     lr, [r3, #CurSRIndex]   ; save off new Sample Rate index
        LDR     r2, [r3, #CurSRValue]   ; get previous samplerate value for return to user
        LDR     lr, [r5, #HALDevice_AudioRateTable_Frequency] ; pick up frequency value from table entry
        STR     lr, [r3, #CurSRValue]   ; and save that too
d1704 1
a1704 1
        DCD     &1F1                    ; ???
d1723 17
d1748 1
a1748 1
        BNE     %FT00
d1750 1
a1750 1
        MOV     r3, #WorkSpaceSize
d1758 1
d1767 36
a1802 53
        ; Hunt for a suitable HAL audio device
        LDRVC   r0, =1:SHL:16 :OR: HALDeviceType_Audio :OR: HALDeviceAudio_AudC
        MOVVC   r1, #0
        MOVVC   r4, #0
        MOVVC   r8, #4
10      SWIVC   XOS_Hardware
        BVS     %FT15
        CMP     r1, #-1
        ADREQ   r0, ErrorBlock_NoSoundDevices
        SETV    EQ
        BVS     %FT15
        ; We don't support devices with a major version of 0
        LDR     lr, [r2, #HALDevice_Version]
        CMP     lr, #1:SHL:16
        BLO     %BT10
        ; Device is valid, try to active it
        MOV     r4, r2
        MOV     r0, r2
        MOV     lr, pc
        LDR     pc, [r2, #HALDevice_Activate]
        CMP     r0, #0                  ; successful?
        BEQ     %BT10 ; Go back and look for another
        ; Else device is good, use it
        LDR     lr, [r4, #HALDevice_Device]
        STR     r4, [r5, #HALDevice]
        STR     lr, [r5, #Sound_device]
        ; Register with DMAManager
        MOV     r11, r4
        ADD     r7, r4, #HALDevice_AudioDMAParams
        ADD     r4, r5, #DMARoutines ; Use our DMA routines
        ADR     r0, DMAEnable
        ADR     r1, DMADisable
        ADR     r2, DMAStart
        ADR     r3, DMACompleted
        ADR     lr, DMASync
        STMIA   r4,{r0-r3,lr}
        MOV     r5, r10 ; Pass SoundLevel0Base to DMA handlers
        LDMIA   r7, {r0,r1,r2,r3,r7} ; Get remaining DMA_RegisterChannel params
        SWI     XDMA_RegisterChannel
        LDR     r5, [r10, #SoundRMA]
        STRVC   r0, [r5, #DMAChannel]
        BVC     %FT15
        ; Couldn't get DMA channel, so abort
        MOV     r4, r0 ; preserve error ptr
        LDR     r0, [r5, #HALDevice]
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_Deactivate]
        ; Now return error
        MOV     r0, r4
        SETV
15
        BLVC    InitResetCommon
        EXIT    VS                      ; [going nowhere if this fails]
d1830 8
d1862 1
d1864 1
d1891 1
d1896 1
d1899 12
a1910 1
        MakeInternatErrorBlock NoSoundDevices,,M04
d1916 15
a1930 2
       ASSERT   Service_Reset      < Service_ModeChange
       ASSERT   Service_ModeChange < Service_Portable
d1935 2
a1936 1
        DCD     Service_Reset
d1941 2
a1942 1
        TEQ     r1,#Service_Reset
d1945 38
a1982 1
        CMP     r1, #Service_Reset
d1984 38
d2023 38
a2060 1
        Entry   "r0-r4, r10, r11"
d2062 2
a2063 4
; Fix MED-02859 - only call InitResetCommon if it's a soft reset.
; Otherwise we'll try to put ourselves on twice, and there's a window
; during which Sound DMA is enabled and the kernel has temporarily removed
; all device handlers.
d2065 1
a2065 6
        MOV     r0, #&FD
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #0
        EXIT    NE
d2068 1
a2069 2
        BL      InitResetCommon
        EXIT    VS                      ; Can't raise error from service
d2071 6
a2076 5
        MRS     r1, CPSR
        MSR     CPSR_c, #I32_bit :OR: SVC32_mode ; IRQ off please
        BL      Sound0Reenable          ; Turn on system/keep it off
        MSR     CPSR_c, r1              ; Restore caller's IRQ state
        EXIT
d2078 2
a2079 3
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r4 trashable <---- NB.
;       r10 = SoundLevel0Base
d2081 1
a2081 2
; Out   VC: ok
;       VS: r0 -> error block
d2083 2
a2084 1
InitResetCommon Entry "r8,r9"
a2085 12
        LDR     r4, =SoundDMABuffers    ; Clear out entire DMA buffers
        ADD     r14, r4, #SoundDMABufferSize * 2
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
50      STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        CMP     r4, r14
        BLT     %BT50
d2087 1
a2087 4
; Claim vector to field the interrupts on
        LDR     r3, [r10, #SoundRMA]
        ADR     r1, Module_VectorCode
        MOV     r2, r10                 ; R12 value to be passed in
a2088 4
        LDR     r0, [r3, #Sound_device]
        CMP     r0, #-1
        EXIT    EQ
        SWI     XOS_ClaimDeviceVector
d2090 38
a2127 6
        ; Make sure interrupt is enabled
        BIC     r0, r0, #1:SHL:31
        MOV     r8, #0
        MOV     r9, #EntryNo_HAL_IRQEnable
        SWI     XOS_Hardware
        
d2130 1
a2130 2
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable, r10 = fatality indication
d2132 15
a2146 1
Finalise_Module Entry "r10, r11"
d2148 6
a2153 2
        LDR     r12, [r12]              ; Get wp for messagefile info
        LDR     r0, [r12, #MessageFile_Open]
d2155 50
a2204 2
        ADDNE   r0, r12, #MessageFile_Block
        SWINE   XMessageTrans_CloseFile
d2206 1
a2206 1
        LDR     r10, =SoundLevel0Base
d2208 6
a2213 7
        MOV     r0, #Service_SoundLevel0Dying
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall         ; Can't stop me!

        PHPSEI  r14, r0
        Push    "r14"
        LDRB    r3, [r12, #ResetPending] ; Check if a reset callback is pending
d2215 4
a2218 3
        ADRNE   r0, SoundResetFunc
        MOVNE   r1, r12
        SWINE   XOS_RemoveCallBack
d2220 4
a2223 6
        STRB    r3, [r12, #ResetPending] ; Avoid any further callback registrations
        BL      Sound0Enable            ; Turn off system - can't SWI anymore
        Pull    "r14"
        PLP     r14                     ; Reenable IRQs

; release the irq handler
d2225 1
a2225 2
        MOV     r2, r10

d2229 3
a2231 4

        MOV     r0, #0
        STRB    r0, [r12, #ResetPending] ; it's safe to clear this flag now that the device vector has been released

d2233 2
d2238 30
a2267 1
        EXIT                            ; Don't refuse to die
d2269 14
d2284 35
d2320 4
a2323 7
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Divide - r2 := r0 DIV r1  -
;
; This is needed when base sound clock rate varies (with video clock), and
; when computing period from frequency or vice versa.
;
a2324 3
Divide  Entry
        DivRem  r2, r0, r1, r14
        EXIT
d2332 1
d2334 1
a2334 1
        Entry  "r4,r8-r9"
d2336 15
a2350 15
        MSR    CPSR_c, #I32_bit+SVC32_mode
        Push   "lr"
        LDR    r4, [r12, #SoundRMA]
        LDR    r0, [r4, #HALDevice]
        MOV    lr, pc
        LDR    pc, [r0, #HALDevice_AudioIRQHandle]
        CMP    r0, #1
        LDREQB r1, [r4, #ResetPending]
        CMPEQ  r1, #0
        BNE    %FT10
        ADR    r0, SoundResetFunc
        MOV    r1, r4
        SWI    XOS_AddCallBack
        MOVVC  r0, #1
        STRVCB r0, [r4, #ResetPending]
d2352 5
a2356 5
        LDR    r0, [r4, #Sound_device]
        MOV    r8, #0
        MOV    r9, #EntryNo_HAL_IRQClear
        BIC    r0, r0, #1:SHL:31
        SWI    XOS_Hardware
d2358 2
a2359 2
        Pull   "lr"
        MSR    CPSR_c,#I32_bit+IRQ32_mode
d2363 4
a2366 3
        Entry  "r0-r1"
        MOV    r0, #1
        SWI    XSound_Enable
d2368 6
a2373 6
        MOV    r1, #0
        STRB   r1, [r12, #ResetPending]
        EXIT   VS
        CMP    r0, #1 ; Only re-enable if we were enabled to start with
        MOVNE  r0, #2
        SWINE  XSound_Enable
d2376 9
d2386 1
a2386 1
; r12 = SoundLevel0Base
d2392 2
d2395 25
a2419 1
        MOV     pc, lr
d2422 10
a2431 1
        ; This is the one we're really interested in!
d2433 49
a2481 29
        Push    "r11,r12, lr"
        ; Mung ourselves into IRQ mode with interrupts off
        ! 0, "TODO - Check if updating this to run in SVC is sensible"
        MRS     r11, CPSR
        MSR     CPSR_c,#IRQ32_mode+I32_bit
        Push    "r11"

; IFF semaphore is zero then r13 = system IRQ stack pointer
; ELSE re-entrant SIRQ indicating buffer filling STILL IN PROGRESS!
; r12     SoundLevel0Base
; r13     IRQ stack (must be FD)
; r14     work register

        MOV     r14, wp                 ; =SoundLevel0Base
        LDR     r12, [r14, #Semaphore]  ; semaphore
        LDR     r11, [r14, #SoundRMA]
        CMP     r12, #0
        LDREQB  r12, [r11, #DMACurBuf] ; TODO - Investigate this - logic dictates we should pay attention to buffer changes during recursive IRQs. But that doesn't seem to be the case with DMAManager!
        EOREQ   r12, r12, #1
        STREQB  r12, [r11, #DMACurBuf]
        BEQ     %FT40                   ; do Level0Swap

; Level0Overrun - can't break general IRQ thread; other handlers reenable IRQ.

; What can we do? Push the CSO back to the start of the "other" buffer?

        Pull    "r11"
        MSR     CPSR_c, r11
        Pull    "r11,r12, pc"
d2485 6
a2490 6
40      STR     sp_irq, [r14, #Semaphore] ; save IRQ stack^ in semaphore
        Push    "r0-r10"

; r11   SoundRMA
; r12   Buffer flag
; r14   SoundLevel0Base
d2546 5
a2550 2
        LDR     r1, [r14, #SoundRMA]    ; address code buffer in SoundRMA workspace
        ADD     r1, r1, #LinConvCode    ; ...
a2553 1

d2566 15
d2591 14
d2633 8
d2653 1
d2675 13
d2697 16
d2718 15
d2739 1
a2742 1

d2751 1
a2751 1
 [ UseLDRSH
d2753 1
a2753 1
 ]
d2766 23
d2813 16
d2845 2
d2849 1
a2849 1

a2853 2
        LDR     r7, [r11, #SoundRMA]

d2857 1
a2857 1

d2870 1
d2872 1
a2872 1
	Pull	"r3,r4,r11"             ; pop phys base+real limit (@@Fs*2 if oversampling)
d2874 15
a2888 2
	LDR	r7, [r11, #SoundRMA]	; address RMA area
	STR	r6, [r7, #SavedSample]	; save sample pair for possible oversampling next time
d2891 22
a2913 213
        Pull    "r0-r10"
        MOV     wp, r11
        MOV     r11, #0
        STR     r11, [wp, #Semaphore]   ; clear semaphore
        Pull    "r11"
        MSR     CPSR_c, r11
        Pull    "r11,r12, pc"               ; Return from DMA callback


; Buffer processing routines - 3 off, done as out-of-line code sequences which
; all return to "BufferDone" above....

; MonoOnly
;
;     Convert stereo into mono (in same buffer space)
;
;   r0 = base address of current buffer
;   r1 = limit address (last+1) of source (Fs*1)
;   r2-r9 free for general use (r6 = saved sample (oversampling only))
;   r10 = &FFFF0000
;   r11 = &FFFEFFFE
;   r12 = &80008000
;   r14 = unavailable (IRQs enabled)
; On exit:
;   r0-r12,r14 corrupted

MonoOnly        ROUT
        TST     r0, #&1000              ; eurgh
        ADDEQ   r7, r0, #SoundDMABufferSize
        MOVNE   r7, r1
01      LDMDB   r1!, {r2,r3,r4,r5}
        ; convert from signed to unsigned format
        EOR     r2, r2, r12
        EOR     r3, r3, r12
        EOR     r4, r4, r12
        EOR     r5, r5, r12
        ; clear off LSB from each value (two in each reg)
        AND     r2, r2, r11
        AND     r3, r3, r11
        AND     r4, r4, r11
        AND     r5, r5, r11
        ; Add the left and right samples together, simultaneously in both upper and
        ; halves of each stereo pair. There will be no
        ; interference between carry out from the RHS MSB into bit 16 (LSB of
        ; LHS sample), and no carry from bit 16 into bit 17, since we cleared
        ; bit 16 in both sources (i.e. bit 16 and bit 0 of pre-rotated single source!)
        ; beforehand; therefore the subsequent right shift will correctly put the
        ; average of the two channel samples back into bits 15..0 (and also into
        ; bits 31..16, using RRX to recover carry out from bit 31).
        ; Get back to signed 16 bit result for each channel afterwards by EOR'ing
        ; with 0x80008000.
        ADDS    r2, r2, r2, ROR #16
        EOR     r2, r12, r2, RRX
        ADDS    r3, r3, r3, ROR #16
        EOR     r3, r12, r3, RRX
        ADDS    r4, r4, r4, ROR #16
        EOR     r4, r12, r4, RRX
        ADDS    r5, r5, r5, ROR #16
        EOR     r5, r12, r5, RRX
        STMDB   r7!, {r2,r3,r4,r5}      ; store them all out
        CMP     r1, r0                  ; have we just done last loop?
        BNE     %B01                    ; round again if not
        B       BufferDone              ; we're all done


; OverOnly:
;     Oversample, expanding buffer by factor of 2 by performing linear interpolation
;     between each pair of samples.  For the very first case, this uses a saved copy
;     of the last stereo sample pair word (2x16-bit) from the end of the previous
;     buffer, to interpolate against.  Note that this process is done in reverse
;     order (working from end of buffer back to start) to avoid overwriting the
;     initial data as would happen if we went forwards..
OverOnly        ROUT
        MSR     CPSR_c, #SVC32_mode     ; want to use R14...
        Push    "r6,r14"
        LDR     r14, [r1, #-4]!         ; get last sample in source buffer now
 [ StereoReverse
        EOR     r14, r12, r14, ROR #16  ; convert signed to unsigned and stereo reverse
 |
        EOR     r14, r14, r12           ; convert signed to unsigned
 ]
        AND     r14, r14, r11           ; mask LSB bits from this sample-pair
        ADD     r0, r0, #8*4            ; need to do last group separately, so move base

01      LDMDB   r1!, {r3,r5,r7,r9}      ; load 4 new samples

02      ; convert from signed to unsigned format (into separate regs apart from r3)
 [ StereoReverse
        EOR     r3, r12, r3, ROR #16
        MOV     r5, r5, ROR #16
        EOR     r6, r12, r5
        MOV     r7, r7, ROR #16
        EOR     r8, r12, r7
        MOV     r9, r9, ROR #16
        EOR     r10, r12, r9
 |
        EOR     r3, r3, r12
        EOR     r6, r5, r12
        EOR     r8, r7, r12
        EOR     r10, r9, r12
 ]
        ; clear off LSB from each value (two in each reg)
        AND     r3, r3, r11
        AND     r6, r6, r11
        AND     r8, r8, r11
        AND     r10, r10, r11
        ; oversampling: average pairs and turn back to signed format
        ADDS    r4, r3, r6
        EOR     r4, r12, r4, RRX
        ADDS    r6, r6, r8
        EOR     r6, r12, r6, RRX
        ADDS    r8, r8, r10
        EOR     r8, r12, r8, RRX
        ADDS    r10, r10, r14
        EOR     r10, r12, r10, RRX
        EOR     r14, r12, r14                   ; put r14 back to signed format also
        STMDB   r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results interleaved with originals
        MOV     r14, r3                 ; set lowest sample for end of next group
        CMP     r2, r0                  ; have we just done last normal loop?
        BHI     %B01                    ; round again if not
        Pull    r14, LO
        BLO     BufferDone              ; all done if done extra, special loop

        ; get last sample from previous buffer, to interpolate for first new sample of this
        Pull    r3
        ; (r2==r0) for last special loop, pick up very first 3 samples from this buffer
        LDMDB   r1!, {r5,r7,r9}
 [ StereoReverse
        MOV     r3, r3, ROR #16
 ]
        B       %B02                    ; use main loop code to do it

 [ StereoReverse
StereoOnly      ROUT
; Reverse stereo only
        TST     r0, #&1000              ; eurgh
        ADDEQ   r7, r0, #SoundDMABufferSize
        MOVNE   r7, r1
        ASSERT  0 ; TODO - Make ARMv6/v7-safe
        ADD     r0, r0, #2
        ADD     r1, r1, #2              ; misalign pointer for rotation
01      LDR     r2, [r1, #-16]!         ; get four new samples, reversing
        LDR     r3, [r1, #4]            ; left-right stereo pairs
        LDR     r4, [r1, #8]
        LDR     r5, [r1, #12]
        STMDB   r7!, {r2,r3,r4,r5}      ; write back the four samples
        CMP     r1, r0                  ; have we finished?
        BNE     %B01
        SUB     r0, r0, #2
        B       BufferDone
 ]

; Convert to mono and oversample also
MonoOver        ROUT
        MSR     CPSR_c, #SVC32_mode     ; want to use R14...
        Push    "r6,r14"
        ADD     r0, r0, #8*4            ; need to do last group separately, so move base

        LDR     r14, [r1, #-4]!         ; get last sample in source buffer now
        EOR     r14, r14, r12           ; convert signed to unsigned
        AND     r14, r14, r11           ; mask LSB bits from this sample-pair
        ADDS    r14, r14, r14, ROR #16  ; convert to mono
        AND     r14, r11, r14, RRX

01      LDMDB   r1!, {r3,r5,r7,r9}      ; get four new samples: signed, full 16-bit, stereo

02      ; convert from signed to unsigned format
        EOR     r3, r3, r12
        EOR     r5, r5, r12
        EOR     r7, r7, r12
        EOR     r9, r9, r12
        ; clear off LSB from each value (two in each reg)
        AND     r3, r3, r11
        AND     r5, r5, r11
        AND     r7, r7, r11
        AND     r9, r9, r11
        ; Monoise unsigned masked versions of input data; since we're also oversampling,
        ; leave in unsigned form and mask off LSBs again
        ADDS    r3, r3, r3, ROR #16
        AND     r3, r11, r3, RRX
        ADDS    r5, r5, r5, ROR #16
        AND     r5, r11, r5, RRX
        ADDS    r7, r7, r7, ROR #16
        AND     r7, r11, r7, RRX
        ADDS    r9, r9, r9, ROR #16
        AND     r9, r11, r9, RRX
        ; then oversample, generating new intermediate values in r4,r6,r8,r10, in signed format
        ADDS    r4, r3, r5
        EOR     r4, r12, r4, RRX
        ADDS    r6, r5, r7
        EOR     r6, r12, r6, RRX
        ADDS    r8, r7, r9
        EOR     r8, r12, r8, RRX
        ADDS    r10, r9, r14
        EOR     r10, r12, r10, RRX
        ; must convert monoised unsigned masked originals back to signed format also
        EOR     r5, r12, r5
        EOR     r7, r7, r12
        EOR     r9, r9, r12
        EOR     r14, r12, r14           ; put r14 back to signed format also for store-out
        STMDB   r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results, interleaved with originals
        MOV     r14, r3                 ; copy lo sample (mono,still unsigned & masked) for next group
        CMP     r2, r0                  ; have we just done last normalloop?
        BHI     %B01                    ; round again if not
        Pull    r14, LO
        BLO     BufferDone              ; return if just done extra, special loop

        ; r2==r0: finally, pick up very first 3 samples from this buffer
        LDMDB   r1!, {r5,r7,r9}
        ; and last sample from previous buffer, to interpolate for first new sample of this
        Pull    r3
        ; use main loop code to do final (earliest) 8 samples of output
        B       %B02
d2968 56
@


1.2
log
@Minor sSound0HAL update to ensure correct behaviour of devif device does not provide an IRQ

Version 1.66. Tagged as 'Sound0HAL-1_66'
@
text
@d2417 3
d2439 3
@


1.1
log
@Add initial version of new SoundDMA module, 'Sound0HAL'
Detail:
  Based on the Sound0Trid source code, this version of SoundDMA makes use of a new version of the audio controller HAL device API. Briefly:
  * DMA is handled by the HALified DMAManager
  * The DMASync callback is used to trigger audio buffer filling
  * The set of available sample rates is dictated by the audio controller device
  * Basic support for resetting the audio when an error occurs (e.g. FIFO under/overflow causing stereo channels to be swapped)
  * Module is now ARMv6/7-safe, due to use of LDR(S)H instead of unaligned loads. This comes at the cost of losing RiscPC compatability. Can be disabled if needed via setting UseLDRSH to false.
  * To keep the code simple, it only accepts devices which use the new API version.
  * Sound0Enable now enables IRQs for most of its execution, to allow for supporting slow devices (e.g. IIC communications with the TPS65950). The PRMs describe Sound_Enable as having undefined reentrancy & IRQ state, so this should be OK with regards to code compatability.
  * The stereo reverse code still needs to be made ARMv6/v7-safe, as well as (preferably) being something that can be selectively enabled at runtime, depending on the audio controller in use
  * The oversampling code is disabled, much as it was in Sound0Trid.
  * The pipelining of sample rate changes that Sound0Trid performed is gone - partly to keep the code simple, and partly because it wouldn't work too well with the TPS65950 (due to the intermediate FIFO that the samples pass through, and the fact that the TPS audio codec must be turned off to change the sample rate)
Admin:
  Tested on rev C2 beagleboard.


Version 1.65. Tagged as 'Sound0HAL-1_65'
@
text
@d2336 2
d2383 2
a2384 1
        SWI     XOS_ReleaseDeviceVector                 ; release device vector
@


head	4.13;
access;
symbols
	Sound2-1_33:4.13
	Sound2-1_32:4.12
	Sound2-1_31:4.11
	Sound2-1_30:4.9
	Sound2-1_29:4.8
	Sound2-1_28:4.7
	RO_5_07:4.6
	Sound2-1_27:4.6
	Sound2-1_26:4.5
	dellis_autobuild_BaseSW:4.4
	sbrodie_sedwards_16Mar2000:4.4
	SoundScheduler-1_25:4.4
	Sound2-1_25:4.4
	dcotton_autobuild_BaseSW:4.6
	Sound2-1_24:4.3
	Ursula_merge:4.2.2.1
	nturton_Sound2-1_22:4.2
	dcotton_sound2_MPTInitialBuild:4.1.7.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2018.08.04.10.20.28;	author jlee;	state Exp;
branches;
next	4.12;
commitid	tjPPVbXVv2LQYMMA;

4.12
date	2014.06.28.12.42.29;	author jlee;	state Exp;
branches;
next	4.11;
commitid	F9b8U5EtcgwVUhGx;

4.11
date	2014.06.23.18.28.10;	author jlee;	state Exp;
branches;
next	4.10;
commitid	noZYmWOdWBEuZFFx;

4.10
date	2014.06.22.18.54.46;	author jlee;	state Exp;
branches;
next	4.9;
commitid	RwUs97XIctSBayFx;

4.9
date	2012.02.16.22.49.52;	author jlee;	state Exp;
branches;
next	4.8;
commitid	s3548lDK8pab1rTv;

4.8
date	2011.03.14.23.38.47;	author srevill;	state Exp;
branches;
next	4.7;
commitid	vFoPaD9K31QxbSbv;

4.7
date	2009.06.11.21.22.49;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2001.03.19.09.39.18;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2001.03.16.16.15.13;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	99.12.08.14.49.05;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.08.16.11.13.29;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.09.59.33;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.37.49;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	98.04.15.07.58.25;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.37.49;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.44.56;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.04.51;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.56.39;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Cope with SoundDMA being reinitialised
Detail:
  s/Sound2 - Adapt service call handler so that on Service_SoundLevel0Alive we reregister ourselves as the sound channel handler
Admin:
  Tested on iMX6
  This means that (combined with Sound1-1_42) *RMReinit of SoundDMA while Maestro is playing music will not halt playback (However, Maestro won't spot that playback has been switched from 8 channels back to the default of 1 channel)


Version 1.33. Tagged as 'Sound2-1_33'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     Sound System v3.0 -> <wini>arm.Sound2.Sound2

; *************************************************
; **                                             **
; **       ARTHUR Sound System Software          **
; **                                             **
; **    MODULE: SoundEventScheduler              **
; **            Level2 Sound System Module       **
; **                                             **
; **    AUTHOR: David Flynn (alas, no more)      **
; **            Stuart Swales (likewise)         **
; **            Tim Dobson                       **
; **                                             **
; **    DESCRIPTION: schedule and dispatch       **
; **                 sound event handler         **
; **                                             **
; **    ENTRIES: SWIs for system level interface **
; **             CLI  commands interface         **
; **                                             **
; *************************************************

; 1.05  EPROM version
; 1.06  fix full stops on syntax messages
; 1.07  fix textual SOUND SWI names to match documents
; 1.08  Tokenise help. Bug in finalise wrt. errors on dying. Don't flag no
;       room separately. Acres of superfluous code that was never referenced!
; 1.09  Disable IRQ to see if it makes life better
; 1.10  Fix QDispatch, QRemove SWIs. Make more use of r10,r11 in SWI code
; 1.11  Provisional new BL-type interface to prevent SWIs from IRQs
;       also does services
; 1.12  Fixed QDispatch to allow SWIs that reenable IRQ
; ---- Released for Arthur 2.00 ----
; 1.13  Changed Sound_QInit to restore caller's IRQ state during big workspace
;       initialisation - sets TimeSlot to be -1 while this is being done -
;       other SWIs check this to prevent background mishaps.
;       Changed header GETs to make it work again
; 1.14  Internationalised
; 1.15  23-Mar-92 JSR  Halve scheduler event list from 8K to 4K.
; 1.16  22-Apr-92 TMD  Remove wildcards from message filename (fixes RP-2371).
;


        GET     Hdr:ListOpts
        OPT     OptNoList
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:PublicWS
        GET     Hdr:Proc
        GET     Hdr:Tokens
        GET     Hdr:MsgTrans
        GET     Hdr:CPU.Arch

        OPT     OptList
        OPT     OptPage

        GET     Hdr:Sound
        GET     VersionASM

        GBLL    bltype
bltype  SETL    True

        GBLL    debug
debug   SETL    False

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound Event Scheduler/Dispatcher
        OPT     OptPage

        ^       0, wp
 [ {FALSE}
QDataSize       * 4096
 |
QDataSize       * 8192                  ; 8k for now, dynamic from CLI later?
 ]
QData           # QDataSize

MessageFile_Block # 16
MessageFile_Open  # 4

WorkSpaceSize   * :INDEX: @@

DefaultTempo    * &1000

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        AREA    |Sound2$$Code|, CODE, READONLY, PIC

Module_Base
        &       0 ; NOT AN APPLICATION
        &       Initialise_Module    - Module_Base
        &       Finalise_Module      - Module_Base
        &       Intercept_Services   - Module_Base
        &       Module_Name          - Module_Base
        &       Help_String          - Module_Base
        &       Module_Keywords      - Module_Base
        &       Module_SWISystemBase + Sound2SWI * Module_SWIChunkSize
        &       SoundQ_SWI_Code      - Module_Base
        &       Module_SWIDecodeBase - Module_Base
        &       0
 [ International_Help <> 0
        &       message_filename     - Module_Base
 |
        &       0
 ]
 [ :LNOT: No32bitCode
        &       ModuleFlags          - Module_Base
 ]

Module_Name
        =       "SoundScheduler", 0

Help_String
        DCB     "SoundScheduler"
        DCB     9
        DCB     "$Module_HelpVersion"
        DCB     0

Module_SWIDecodeBase
        =       "Sound",0
        =       "QInit",0
        =       "QSchedule",0
        =       "QRemove",0
        =       "QFree",0
        =       "QSDispatch",0
        =       "QTempo",0
        =       "QBeat",0
 [ bltype
        =       "QInterface",0
 ]
        =       0

Module_Keywords
        =       "Tempo",0
        ALIGN
        &       Tempo_Code   - Module_Base
        =       1,0,1,0:OR:(International_Help:SHR:24)                 ; 1 parameter
        &       Tempo_Syntax - Module_Base
        &       Tempo_Help   - Module_Base

        =       "QSound", 0
        ALIGN
        &       QSound_Code   - Module_Base
        =       5,0,5,0:OR:(International_Help:SHR:24)                 ; 5 parameters
        &       QSound_Syntax - Module_Base
        &       QSound_Help   - Module_Base

        =       0                       ; No more entries

        GET     TokHelpSrc.s

        ALIGN

 [ :LNOT: No32bitCode
ModuleFlags
        DCD     1       ; 32-bit compatible
 ]
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Tempo_Code Entry
        LDR     wp, [r12]

        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; No bad terminators please
        SWI     XOS_ReadUnsigned
        BVS     Parse_Error
        MOVS    r0, r2, LSR #16
        MOVEQ   r0, r2
        SWIEQ   XSound_QTempo
        CLRV
        EXIT


Parse_Error
        ADR     r0, ErrorBlock_BadSoundParameter

ReturnError ; For star command entries

        BL      CopyError       ; sets V
        PullEnv
        MOV     pc, lr

        MakeInternatErrorBlock BadSoundParameter,,M00

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

QSound_Code ALTENTRY
        LDR     wp, [r12]

        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; No bad terminators please
        SWI     XOS_ReadUnsigned        ; read channel
        BVS     Parse_Error

        SUB     r14, r2, #1             ; Ensure in 1..SoundPhysChannels
        CMP     r14, #SoundPhysChannels
        BHS     %FT90

        MOV     r4, r2                  ; preserve

        SWI     XOS_ReadUnsigned        ; read amplitude
        MOVVC   r5, r2

        SWIVC   XOS_ReadUnsigned        ; read pitch
        MOVVC   r3, r2

        SWIVC   XOS_ReadUnsigned        ; read duration
        MOVVC   r6, r2

        SWIVC   XOS_ReadUnsigned        ; read time
        BVS     Parse_Error

        MOV     r0, r2                  ; sort out regs: time
        MOV     r1, #0
        MOV     r4, r4, LSL #16
        MOV     r4, r4, LSR #16
        ORR     r2, r4, r5, LSL #16
        MOV     r3, r3, LSL #16
        MOV     r3, r3, LSR #16
        ORR     r3, r3, r6, LSL #16
        SWI     XSound_QSchedule
        CLRV
        EXIT


90      ADR     r0, ErrorBlock_BadSoundChannel
        B       ReturnError

        MakeInternatErrorBlock BadSoundChannel,,M01

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

NBuckets        * 256                   ; for normal no. of micro-beats per bar

; Q dynamic structures - ALL 4 WORDS EXACTLY!

; link ALWAYS at offset 0

; bucket
            ^ 0
BucketLink  # 4
BucketTime  # 4
BucketHead  # 4
BucketTail  # 4
BucketSize  # 0

; event
            ^ 0
EventLink   # 4
EventSched  # 4
EventData0  # 4
EventData1  # 4
EventSize   # 0

; free list (stack)
            ^ 0
FreeLink    # 4
FreeUnused  # 12
FreeSize    # 0

; wheel of time (chained bucket sequences)
            ^ 0
QCodePtr    # 4
QSize       # 4
            # 4 ; Spare padding
QTempoInCS  # 4 ; public tempo value, measured in beats/centisecond
QTempo      # 4 ; internal tempo value in low 16 bits, phase in high
QLast       # 4 ; remember last incremental time...
QBeatCount  # 4 ; (0 for beat counter off)
QBeat       # 4

QDepth      # 4

TimeSlot    # 4 ; -ve => in the middle of a QInit
FreeStack   # 4
QSPARE      # 16 - ((NBuckets*4 + 12):MOD:16)
; FORCE timebuckets to end on 16 byte boundary!
TimeBucket  # NBuckets * 4 ; just links
TimeBucketEnd # 0 ; base of buckets and events..


QFullError * -1                         ; -ve error return codes

QWrap   *       NBuckets

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r10, r11 trashable, r12 is QWorkSpace^

SoundQ_SWI_Code ROUT
        LDR     wp, [r12]
        Push    "R0,R14"
      [ NoARMv3
        MOV     R10, R14, LSR #IF32_26Shift     ; caller I_bit in I32_bit position
      ]
      [ SupportARMv3
        MRS     R10, CPSR               ; Get real PSR if we can
      ]
        AND     R10, R10, #I32_bit      ; R10 now non-zero if interrupts were off
        PHPSEI  R14, R0
        Pull    R0
        BL      Original_SWI_Code
    [ No32bitCode
        ; 26bit OS
        Pull    R14
        MOVVCS  PC,R14                  ; 26-bit exit: NZC preserved, V clear
        ORRVSS  PC,R14,#V_bit           ; 26-bit exit: NZC preserved, V set
    |
     [ No26bitCode
        ; 32bit OS
        Pull    "pc"
     |
        ; 26bit or 32bit OS
        Pull    R14
      [ NoARMv3
        ; ... with ARMv2 support
        MOV     R10,#0
      ]
        MRS     R10,CPSR                ; NOP on pre-ARM6
        TST     R10,#2_11100            ; EQ if in 26-bit mode - C,V unaltered
        MOVNE   PC,R14                  ; 32-bit exit: NZ corrupted, CV passed back
        MOVVCS  PC,R14                  ; 26-bit exit: NZC preserved, V clear
        ORRVSS  PC,R14,#V_bit           ; 26-bit exit: NZC preserved, V set
     ]
    ]

Original_SWI_Code
        CMP     r11, #(EndOfJumpTable-JumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        MOV     pc, lr

JumpTable
        B       SoundQInit
        B       SoundQSchedule_SWI
        B       SoundQRemove_SWI
        B       SoundQFree              ; (* no of GUARANTEED slots left *)
        B       SoundQDispatch_SWI
        B       SoundQTempo
        B       SoundQBeat_SWI
 [ bltype
        B       SoundQInterface
 ]
EndOfJumpTable

 [ bltype
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SoundQInterface - read how to call me

; In    r12 is QWorkSpace

; Out   r0 = ws^ to call me with
;       r1 = @@SoundQSchedule_External
;       r2 = @@SoundQBeat_External

SoundQInterface ROUT

        ADDS    r0, wp, #0      ; clears V
        ADR     r1, SoundQSchedule_External
        ADR     r2, SoundQBeat_External
        MOV     pc, lr
 ]

; *****************************************************************************
;
;       SoundQFullInit - Initialise queue, ignoring whether we're already
;                        inside a QInit (called on module init, die, reset)

SoundQFullInit Entry "r2,r10"
        PHPSEI  r2, r14
        MOV     r0, #0
        STR     r0, [wp, #TimeSlot]     ; indicate not already in QInit
        MOV     r10, #I32_bit           ; indicate don't want IRQs enabled
        BL      SoundQInit
        PLP     r2                      ; restore I_bit
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SoundQInit - Initialise Q data structures

; In    r10, r11 trashable
;       r12 is QWorkSpace
;       IRQs off

; Out   r0 = 0 => successful operation (never fails)

SoundQInit Entry
        LDR     r0, [wp, #TimeSlot]     ; save so we can spot reentrant QInits
        MOV     r11, #-1
        STR     r11, [wp, #TimeSlot]    ; Clear slot

        TST     r10, #I32_bit           ; If caller had IRQs on
        WritePSRc SVC_mode, r10, EQ

        ADD     r11, wp, #TimeBucket
        LDR     r14, =QWrap
        ADD     r14, r11, r14, LSL #2   ; Pointer space for wheel

        MOV     r10, #SoundSystemNIL
10      STR     r10, [r11], #4
        CMP     r11, r14
        BLT     %BT10

        LDR     r14, [wp, #QSize]
        ADD     r14, wp, r14            ; End of Q space
        SUB     r14, r14, #EventSize    ; Watch end!
        STR     r14, [wp, #FreeStack]
        STR     r10, [r11]              ; Free list NIL

20      STR     r11, [r11, #EventSize]
        ADD     r11, r11, #EventSize
        CMP     r11, r14
        BLT     %BT20

        WritePSRc I_bit :OR: SVC_mode, r10 ; turn IRQs off again
        MOV     r10, #DefaultTempo
        STR     r10, [wp, #QTempo]      ; Wipe phase value
        STR     r10, [wp, #QTempoInCS]
        BL      RecalcTempo
        CMP     r0, #0                  ; if not in the middle of a QInit ...
        MOV     r0, #0
        STRPL   r0, [wp, #TimeSlot]     ; ... then reset TimeSlot to normal
        STR     r0, [wp, #QLast]
        STR     r0, [wp, #QBeatCount]   ; Disable beat counter
        STR     r0, [wp, #QBeat]        ; And clear beats
        STR     r0, [wp, #QDepth]
        EXIT                            ; r0=0 to indicate success

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SoundQTempo - Set/Get Sound Q Tempo

; In    r0 = update value (16-bit)
;            0 FOR DON'T CHANGE
;       r10, r11 trashable
;       r12 is QWorkSpace

; Out   r0 = previous tempo value

; This routine can be work OK even if we're in the middle of a QInit

SoundQTempo ROUT
        LDR     r11, [wp, #QTempoInCS]
        CMP     r0, #0
        BEQ     %FT20

        CMP     r0, #&00010000
        BGE     %FT20
        STR     r0, [wp, #QTempoInCS]
        MOV     r10, lr
        BL      RecalcTempo
        MOV     lr, r10

20      MOV     r0, r11, LSL #16        ; return previous value
        MOV     r0, r0, LSR #16
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 [ bltype
; In    r0  = parm
;       r10, r11 trashable
;       r12 = QWorkspace
;       r14 = return address, with bits

SoundQBeat_External
        PHPSEI  r10, r11
        Push    "r10,lr"
        BL      SoundQBeat_SWI
        Pull    "r10,lr"
        PLP     r10
        MOV     pc, lr

; ..............................................................................
 ]
; SoundQBeat - Set/Get Sound Q Tempo Beat count

; In    r0 = update value (16-bit)
;            0 for read current beat
;            +ve for set beat count limit
;            -1  for read current beat count limit
;            -ve otherwise for disable
;       r10, r11 trashable
;       r12 = QWorkSpace

; Out   r0 = previous tempo beat or last beat count value

; This routine can be work OK even if we're in the middle of a QInit

SoundQBeat_SWI ROUT

        CMP     r0, #0
        LDREQ   r0, [wp, #QBeat]
        BEQ     %FT90                   ; [read current beat]

        CMN     r0, #1                  ; check for -1 (CMN is like ADDS)
        LDREQ   r0, [wp, #QBeatCount]
        BEQ     %FT90                   ; [read current beat limit]

; still MI if negative

        MOVPL   r11, r0, LSL #16        ; 16 bits to top
        MOVPL   r11, r11, LSR #16       ; and back
        MOVMI   r11, #0
        LDR     r0,  [wp, #QBeatCount]  ; return previous beat count
        STR     r11, [wp, #QBeatCount]
        STRMI   r11, [wp, #QBeat]
90      ADDS    r0, r0, #0              ; clear V
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SoundQFree - Check no. of Guaranteed slots!
;      (very pessimistic, to include worst case bucket/event chains)

; In    r12 is QWorkSpace

; Out   r0 = slots

; This routine can be work OK even if we're in the middle of a QInit

SoundQFree ROUT

        LDR     r0, [wp, #QSize]
        SUB     r0, r0, #TimeBucketEnd
        MOV     r0, r0, LSR #6          ; 64 bytes each worst!
                                        ; worst case is size/3*16
        LDR     r11, [wp, #QDepth]
        SUB     r0, r0, r11             ; may be negative!
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 [ bltype
; In    r0..r3 parms
;       r10, r11 trashable
;       r12 = QWorkspace
;       r14 = return address, with bits

SoundQSchedule_External ROUT

        PHPSEI  r10, r11
        Push    "r10,lr"
        BL      SoundQSchedule_SWI
        Pull    "r10,lr"
        PLP     r10
        MOV     pc, lr

; ..............................................................................
 ]
; SoundQSchedule - Insert event in Queue

; In    r0  = Time (incremental from BEAT=0!.IF -ve then synchron'd with last)
;       r1  = control
;       r2  = data0
;       r3  = data1
;       r10, r11 trashable
;       r12 = QWorkSpace

; Out   r0 = 0 for Success, -ve for Error

; This routine returns a queue full error if in the middle of a QInit

SoundQSchedule_SWI Entry "r4-r8"
        LDR     r4, [wp, #TimeSlot]     ; get slot pointer
        CMP     r4, #0                  ; if -ve then the foreground is doing
        BMI     %FT99                   ; a QInit, so exit with queuefull error

        CMP     r0, #0
        LDRMI   r0, [wp, #QLast]
        STRPL   r0, [wp, #QLast]

; now fix the synchronisation to BEAT=0!

        LDR     r5, [wp, #QBeat]
        SUBS    r0, r0, r5
        MOVMI   r0, #0

        MOV     r6, r0                  ; relative offset
        LDR     r5, =QWrap              ; wrap index
        MOV     r0, #0

10      CMP     r6, r5
        SUBGE   r6, r6, r5              ; wrap bucket index
        ADDGE   r0, r0, #1              ; inc bucket number
        BGE     %BT10

        ADD     r4, r4, r6
        CMP     r4, r5
        SUBGE   r4, r4, r5

; r0 is no of wheel cycles in future, r4 is slot index

        ADD     r5, wp, r4, LSL #2      ; bucket header
        ADD     r5, r5, #TimeBucket

; use R4 to check time...

30      LDR     r6, [r5, #BucketLink]
        TST     r6, #SoundSystemNIL
        BNE     %FT60                   ; MakeBucket between r5, r6=NIL

        LDR     r4, [r6, #BucketTime]
        CMP     r0, r4                  ; test bucket time
        BGT     %FT50                   ; try next Bucket

; LT: then must split inc time, else EQ: insert into R6^

        SUBLT   r4, r4, r0
        BLLT    Get3Elements            ; May fail with QFull
        STRLT   r4, [r6, #BucketTime]   ; now safe to change..
        BLT     %FT70                   ; insert r7^ between r5^, r6^


; InsertEvent - r6^ is the bucket to insert into

        LDR     r8, [wp, #FreeStack]
        LDR     r7, [r8, #FreeLink]     ; Get 1 element. Note registers!
        TST     r7, #SoundSystemNIL
        BNE     %FT99                   ; QFull
        STR     r7, [wp, #FreeStack]
        B       %FT80                   ; Initialise Event


50 ; carry on searching..

        SUBGT   r0, r0, r4              ; incremental insert time
        MOV     r5, r6                  ; advance
        B       %BT30


; MakeBucket - r0 IS INCREMENTAL TIME, r5 is previous bucket pointer
;              r6 is next buffer pointer (or NIL)

60      BL      Get3Elements            ; May fail with QFull


; InitBucket - r7 points to list of three elements

70      LDR     r8, [r7, #FreeLink]     ; init second as null element

        STR     r8, [r7, #BucketHead]   ; init first as bucket
        STR     r8, [r7, #BucketTail]
        STR     r0, [r7, #BucketTime]

        STR     r6, [r7, #BucketLink]   ; chain in to bucket list
        STR     r7, [r5, #BucketLink]

; init the event element

        LDR     r8, [r8, #FreeLink]     ; third element
        MOV     r6, r7                  ; r6 to share code...


; InitEvent - r8 is uninitialised event

80      MOV     r0, #SoundSystemNIL
        STMIA   r8, {r0, r1, r2, r3}    ; set data fields

; insert at end of bucket list!

        LDR     r7, [r6, #BucketTail]
        STR     r8, [r6, #BucketTail]
        STR     r8, [r7, #EventLink]    ; and chain event
        LDR     r0, [wp, #QDepth]
        ADD     r0, r0, #1
        STR     r0, [wp, #QDepth]

        SUBS    r0, r0, r0              ; success (R0=0, V clear)
        EXIT


; Out    r7 -> head of list of 3 elements. Flags must be preserved unless fail
;        Well, N and V (necessary for LT condition tests)
;        If condition LT eixsts at start, must exist at end
;        NOTE:  If TST sets Z, it must clear N, hence we simply need to set V.
Get3Elements ; NOROUT
        SETV
        LDR     r7, [wp, #FreeStack]    ; Get 3 elements

        LDR     r8, [r7, #FreeLink]
        TST     r8, #SoundSystemNIL     ; if Z set, N clear - we rely on this!
        LDREQ   r8, [r8, #FreeLink]
        TSTEQ   r8, #SoundSystemNIL
        LDREQ   r8, [r8, #FreeLink]
        TSTEQ   r8, #SoundSystemNIL
        STREQ   r8, [wp, #FreeStack]
        MOVEQ   pc, lr                  ; [ok, else drop into ...]

; QFull

99      MOV     r0, #QFullError         ; failure
        CLRV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SoundQRemove_SWI Entry "r7"

        WritePSRc I_bit :OR: IRQ_mode, r7
      [ NoARMa ; Protect against ARM2 "banked register access after mode change" bug
        NOP
      ]
        BL      SoundQRemove            ; MUST be called in IRQ mode

        WritePSRc I_bit :OR: SVC_mode, r7
        ADDVSS  r0, r0, #0              ; clear V
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SoundQRemove - remove event from Q if within the next R0 ticks

; In    r0 is incremental advance period
;       IRQ mode, IRQs disabled

; Out   r0 >= 0, and R1, R2, R3 if valid event found
;       r0 < 0                  if no more events left AND TimeSlot ADVANCED!

; (basically call until r0 goes negative!)

; This call returns with r0=-1 if we are in the middle of a QInit

SoundQRemove Entry "r4-r8"

        LDR     r4, [wp, #TimeSlot]     ; get slot pointer
        CMP     r4, #0                  ; if -ve then in middle of QInit
        MOVMI   r0, #-1                 ; so say no more events
        EXIT    MI

; SlotProcess

10      ADD     r5, wp, r4, LSL #2      ; bucket header
        ADD     r5, r5, #TimeBucket

; BucketProcess

20      LDR     r6, [r5, #BucketLink]
        TST     r6, #SoundSystemNIL
        BNE     %FT60                   ; AdvanceSlot

        LDR     r7, [r6, #BucketTime]
        CMP     r7, #0
        BEQ     %FT40                   ; RemoveEvent from bucket R6^

; DecrementBuckets - ONLY IF R0 NOT 0

30      CMP     r0, #0
        SUBNE   r7, r7, #1
        STRNE   r7, [r6, #BucketTime]
        B       %FT60                   ; AdvanceSlot


; RemoveEvent - r6 is bucket pointer, r5 is previous bucket pointer

40      LDR     r7, [r6, #BucketHead]   ; inspect list
        LDR     r8, [r7, #EventLink]    ; skip dummy
        TST     r8, #SoundSystemNIL     ; empty?
        BNE     %FT50                   ; scrap bucket if so

; event found ok...

        LDR     r1, [r6, #BucketTail]   ; head = tail?
        CMP     r1, r8                  ; then only 1
        STREQ   r7, [r6, #BucketTail]   ; so fix tail
        LDR     r1, [r8, #EventLink]    ; de-chain
        STR     r1, [r7, #EventLink]    ; back to dummy
        LDR     r1, [wp, #QDepth]
        SUB     r1, r1, #1
        STR     r1, [wp, #QDepth]
        LDMIB   r8, {r1, r2, r3}        ; get contents
        LDR     r7, [wp, #FreeStack]    ; return storage
        STR     r7, [r8, #FreeLink]     ; to stack
        STR     r8, [wp, #FreeStack]
        EXIT


; RemoveBucket - r5 is previous bucket pointer, r6 is EMPTY bucket to discard

50      LDR     r7, [r6, #BucketHead]   ; discard dummy event
        LDR     r1, [r6, #BucketLink]   ; next or NIL
        LDR     r8, [wp, #FreeStack]    ; return storage
        STR     r8, [r7, #FreeLink]     ; and bucket next
        STR     r7, [r6, #FreeLink]
        STR     r6, [wp, #FreeStack]
        STR     r1, [r5, #BucketLink]   ; de-chain bucket
        B       %BT20                   ; now go back and decrement chain....


; AdvanceSlot - FOR ALL BUT R0=0!

60      SUBS    r0, r0, #1 ; decrement count
        EXIT    MI                      ; Return as r0 was 0

; R0 was > 0 -  real advance...

        LDR     R5, [wp, #QLast]        ; adjust QLast time
        SUBS    R5, R5, #1
        STRPL   R5, [wp, #QLast]        ; but ensure NEVER negative

        LDR     r6, [wp, #QBeatCount]
        CMP     r6, #0                  ; ignore if off (0)
        BEQ     %FT70

        LDR     r5, [wp, #QBeat]        ; advance beat count
        ADD     r5, R5, #1
        CMP     r5, R6
        MOVGE   r5, #0
        STR     r5, [wp, #QBeat]        ; update

; Cause Sound Tempo Event if EQ condition

        Push    "r0-r2"
        MOVEQ   r0, #Event_Sound
        MOVEQ   r1, #2                  ; Level2 event
        MOVEQ   r2, #0
        SWIEQ   XOS_GenerateEvent       ; svc_lr was saved ages ago
        Pull    "r0-r2"

70      ADD     r4, r4, #1
        LDR     r5, =QWrap
        CMP     r4, r5
        SUBGE   r4, r4, r5
        STR     r4, [wp, #TimeSlot]     ; update TimeSlot
        B       %BT10                   ; SlotProcess

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Two ways into the same lump of code. SKS

SoundQDispatch_SWI Entry "r4"

        WritePSRc I_bit :OR: IRQ_mode, r4
      [ NoARMa
        NOP
      ]

        BL      SoundQDispatch_Body      ; MUST be called in IRQ mode

        WritePSRc I_bit :OR: SVC_mode, r4
        ADDVSS  r0, r0, #0              ; clear V
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Must preserve SVC r14 as we will call SWIs (or our clients could)

SoundQDispatch_IRQ
        Push    "r3,r4,lr"

     [ :LNOT: No32bitCode
      [ NoARMv3
        MOV     r4, #0
      ]
        MRS     r4, CPSR
     ]

        WritePSRc I_bit :OR: SVC_mode, r3
      [ NoARMa
        NOP
      ]
        Push    lr_svc

        WritePSRc I_bit :OR: IRQ_mode, r3
      [ NoARMa
        NOP
      ]

        BL      SoundQDispatch_Body

        WritePSRc I_bit :OR: SVC_mode, r3
      [ NoARMa
        NOP
      ]
        Pull    lr_svc

        WritePSRc I_bit :OR: IRQ_mode, r3
      [ NoARMa
        NOP
      ]
     [ No32bitCode
        ; 26bit OS
        LDMFD   sp!, {r3,r4,pc}^
     |
      [ :LNOT: No26bitCode
        ; 26bit or 32bit CPU/OS
        TST     r4, #2_11100
        LDMEQFD sp!, {r3,r4,pc}^ ; 26-bit mode - flag restoration OK!
      ]
        ; 32bit OS
        MSR     CPSR_f, r4
        LDMFD   sp!, {r3,r4,pc}
     ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SoundQDispatch

; ***** IRQ mode, IRQ disabled - our clients expect it, code relies on it *****

; ***** Presumably we could only go IRQ when calling CODE ??? ******

; In    r0 is tempo dispatch period
;       r12 is QWorkSpace

SoundQDispatch_Body Entry "r0-r4"

        LDR     r0, [wp, #QTempo]
        BIC     r0, r0, #&F0000000
        ADD     r0, r0, r0, LSL #16
        STR     r0, [wp, #QTempo]
        MOV     r0, r0, LSR #28

SoundDispatchLoop

        BL      SoundQRemove            ; r0 is updated each call

        CMP     r0, #0
        EXIT    MI                      ; [finished. tempo advanced]

        MOV     r4, r0                  ; preserve r0
        Push    "r4-r12"

        CMP     r1, #0                  ; 0 for SOUND fg control
        BEQ     SoundControlDispatch

        AND     r0, r1, #&0F000000      ; SWI opcode?
        CMP     r0, #&0F000000
        BEQ     SoundDispatchSWI        ; [yes]

        TST     r1, #SoundSystemNIL     ; call code pointed to by R1 ?
        MOVEQ   lr, pc                  ; Return with MOVS pc, lr
        MOVEQ   pc, r1                  ; R14 is return

SoundDispatchNext
        Pull    "r4-r12"
        MOV     r0, r4                  ; restore R0
        B       SoundDispatchLoop


SoundControlDispatch ; r2, r3 are packed as per osword

        MOV     r1, r2, ASR #16 ; sign extend bytes 2, 3 to R1
        MOV     r0, r2, LSL #16 ; bytes 0, 1 in R0
        MOV     r0, r0, LSR #16
        MOV     r2, r3, LSL #16 ; bytes 4, 5 to low R2
        MOV     r2, r2, LSR #16
        MOV     r3, r3, LSR #16 ; bytes 6, 7 to low R3
        SWI     XSound_Control
        B       SoundDispatchNext


SoundDispatchSWI ; r1 is SWI number to execute, with parms r2, r3 (->SWI r0,r1)
        Push    "r2-r7,r10"
        BIC     r10, r1, #&FF000000     ; SWI code
        MOV     r0, r2                  ; Get r0,r1 params
        MOV     r1, r3
        MOV     r2, #0                  ; zero all other params
        MOV     r3, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XOS_CallASWI
        Pull    "r2-r7,r10"
        B       SoundDispatchNext

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Calculate the correct QTempo value for the current sound system configuration
RecalcTempo     ROUT
        Entry   "r0-r6"
        ; IRQs off - ensures QTempo value stays in sync with QTempoInCS (e.g.
        ; if we get a tempo change from a scheduled call), and avoids bad
        ; Sound_Tuning values being temporarily visible to outside code if
        ; automatic tuning isn't supported
        PHPSEI  r6, lr
        ; Check if automatic tuning is enabled. If not, fall back to old behaviour.
        LDR     r0, =&4f545541
        MOV     r1, #0
        SWI     XSound_Tuning
        BVS     %FT90
        ; If automatic tuning isn't supported, R1 will have been left unaltered
        TEQ     r1, #0
        BEQ     %FT80
01
        TEQ     r0, #2
        BNE     %FT90
        ; Fetch the sample rate
        MOV     r0, #0
        SWI     XSound_Mode             ; Check Sound_SampleRate supported
        TEQ     r0, #1
        MOVNE   r2, #0
        SWIEQ   XSound_SampleRate       ; r0=1 to get current rate
        MOV     r5, r2                  ; r5 = sample rate in 1/1024 Hz
        ; Fetch buffer size (+ sample period)
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #0
        SWI     XSound_Configure ; R1 = buffer size, R2 = sample period
        BVS     %FT90
        ORRS    r0, r1, r2
        BEQ     %FT90
        ; Calculate real QTempo value
        ; If we have Sound_SampleRate:
        ;   QTempo = QTempoInCS*bufsize*1024*100/samplerate
        ; Otherwise:
        ;   QTempo = QTempoInCS*bufsize*period/10000
        TEQ     r5, #0
        MOVNE   r2, #1024*100
        LDREQ   r5, =10000
05
        LDR     r0, [wp, #QTempoInCS]
        ; Now calculate QTempoInCS*bufsize*r2/r5
        ; Product will most likely be a 64 bit value
        MUL     r3, r1, r0 ; QTempoInCS*bufsize
      [ NoARMM
        MOV     r4, r2, LSR #16
        MOV     lr, r3, LSR #16
        BIC     r2, r2, r4, LSL #16
        BIC     r3, r3, lr, LSL #16
        MUL     r1, r4, lr ; r2hi*r3hi
        MUL     r0, r2, r3 ; r2lo*r3lo
        MUL     r4, r3, r4 ; r2hi*r3lo
        MUL     lr, r2, lr ; r2lo*r3hi
        ADDS    r4, r4, lr
        ADDCS   r1, r1, #1<<16
        ADDS    r0, r0, r4, LSL #16
        ADC     r1, r1, r4, LSR #16
      |
        UMULL   r0, r1, r2, r3
      ]
        ; Now divide r0, r1 by r5
        MOV     r2, #64
        MOV     r3, #0
        ADDS    r0, r0, r0
10
        ADCS    r1, r1, r1
        ADC     r3, r3, r3
        SUBS    r2, r2, #1
        BLT     %FT20
        CMP     r3, r5
        SUBCS   r3, r3, r5
        ADCS    r0, r0, r0
        B       %BT10
20
        ; r0, r1 = result
        ; Clamp to 16 bit value
        CMP     r1, #1
        CMPLO   r0, #&f000
        MOVHS   r0, #&f000
30
        ; Replace current QTempo, preserving phase value
        LDR     r1, [wp, #QTempo]
        MOV     r1, r1, LSR #16
        ORR     r1, r1, r0, LSL #16
        MOV     r1, r1, ROR #16
        STR     r1, [wp, #QTempo]
        PLP     r6
        EXIT

80
        ; Arrive here if we attempted to query the automatic tuning state for a
        ; version of SoundChannels which doesn't understand the call. In this
        ; case it will have erroneously set the tuning value to &5541. Restore
        ; the previous value by calling Sound_Tuning again.
        SWI     XSound_Tuning
90
        ; Unable to perform automatic tempo calculation.
        ; Just fall back to the assumption that 1 buffer = 1 cs
        LDR     r0, [wp, #QTempoInCS]
        B       %BT30

RecalcTempoService ALTENTRY
        PHPSEI  r6, lr
        ; From Service_SoundConfigChanging
        ; r2 = sample rate
        ; r3 = buffer size
        MOV     r5, r2
        ; Check that automatic tuning is enabled
        LDR     r0, =&4f545541
        MOV     r1, #0
        SWI     XSound_Tuning
        BVS     %BT90
        TEQ     r1, #0
        BEQ     %BT80
        TEQ     r0, #2
        BNE     %BT90
        ; It's enabled, call back into the calculation code
        MOV     r1, r3
        MOV     r2, #1024*100
        B       %BT05

RecalcTempoService2 ALTENTRY
        PHPSEI  r6, lr
        ; From Service_SoundAutoTune
        ; r2 = auto tuning state (1=off, 2=on)
        ; For this entry point we skip the Sound_Tuning call, which has the
        ; benefit of allowing us to detect the auto tuning state for the case
        ; where SoundChannels makes this service call during its initialisation
        MOV     r0, r2
        B       %BT01

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Initialise_Module Entry "r10, r11"      ; Calls internal routine

        LDR     r2, [r12]               ; check for reinitialisation
        CMP     r2, #0
        BNE     %FT10

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =WorkSpaceSize
        SWI     XOS_Module
        EXIT    VS
        STR     r2, [r12]

; Set up private workspace

10      MOV     wp, r2                  ; Get ws^

        MOV     r0, #0
        ADRL    r1, MessageFile_Open
        STR     r0, [r1]

        ADR     r0, SoundQDispatch_IRQ
        STR     r0, [wp, #QCodePtr]
        MOV     r0, #QDataSize
        STR     r0, [wp, #QSize]

        BL      SoundQFullInit          ; Can't call Level2 SWI yet

        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        ADD     r4, wp, #QCodePtr       ; Install Level2 handler (in ws)
        SWI     XSound_Configure        ; Level0 SWI, won't give error

        MOV     r0, #Service_SoundLevel2Alive
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable, r10 = fatality indicator

; if this is a fatal entry, then there is no hope
; if NON fatal, still must kill queue before move
; (workspace full of valuable pointers which won't relocate)

Finalise_Module Entry "r10, r11"        ; Calls internal routine

        LDR     wp, [r12]

        ADRL    r1, MessageFile_Open
        LDR     r0, [r1]
        CMP     r0, #0
        ADRNE   r0, MessageFile_Block
        SWINE   XMessageTrans_CloseFile

        MOV     r0, #Service_SoundLevel2Dying
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall         ; Can't stop me!

        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #SoundSystemNIL     ; Remove Level2 handler
        SWI     XSound_Configure        ; Level0 SWI, won't give error

        BL      SoundQFullInit          ; Clear down everything
                                        ; Can't call Level2 SWI anymore
        ADR     r0, Reregister
        MOV     r1, wp
        SWI     XOS_RemoveCallBack      ; Cancel any re-register callback

        CLRV
        EXIT                            ; Mustn't refuse to die

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;Ursula format
;
        ASSERT  Service_Reset < Service_Sound
UServTab
        DCD     0
        DCD     UService - Module_Base
        DCD     Service_Reset
        DCD     Service_Sound
        DCD     0
        DCD     UServTab - Module_Base
Intercept_Services ROUT
        MOV     r0, r0
        CMP     r1, #Service_Reset
        CMPNE   r1, #Service_Sound
        MOVNE   pc, lr
UService
        LDR     wp, [R12]

        Entry   "r0,r10,r11"
        TEQ     r1, #Service_Sound
        BNE     %FT80
        ; Deal with sound configuration changes
        TEQ     r0, #Service_SoundConfigChanging
        BLEQ    RecalcTempoService
        ; Make automatic tempo enable/disable state match automatic tuning enable/disable state
        TEQ     r0, #Service_SoundAutoTune
        BLEQ    RecalcTempoService2
        ; Disable automatic tempo if SoundChannels is dying (rather academic, sound system won't be much use in that state anyway?)
        TEQ     r0, #Service_SoundLevel1Dying
        BLEQ    RecalcTempo
        TEQ     r0, #Service_SoundLevel0Alive
        BLEQ    Level0Alive
        EXIT
80
        BL      SoundQFullInit          ; Reinitialise the queue on reset
        EXIT                            ; Can't raise error from service

Level0Alive
        Entry   "r0-r1"
        ; Defer processing to callback so that level0 SWIs will work
        ADR     r0, Reregister
        MOV     r1, wp
        SWI     XOS_AddCallBack
        CLRV
        EXIT

Reregister
        Entry   "r0-r4"
        ; Assume that we're the only level 2 handler in the system and just
        ; clobber whatever other handler may be present (cf. Initialise &
        ; Finalise)
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        ADD     r4, wp, #QCodePtr
        SWI     XSound_Configure
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CopyError Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        ADR     R1, MessageFile_Block
        MOV     R2, #0
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.SoundSched.Messages", 0
        ALIGN

open_messagefile Entry r0-r3
        ADRL    r3, MessageFile_Open
        LDR     r0, [r3]
        CMP     r0, #0
        EXIT    NE
        ADR     R0, MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, [r3]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        END

@


4.12
log
@Cleanup pass
Detail:
  s/Sound2 - Follow the PRM's instructions and issue Sound_Mode before Sound_SampleRate, instead of assuming Sound_SampleRate 1 would be safe on systems without 16 bit sound.
Admin:
  Tested on BB-xM


Version 1.32. Tagged as 'Sound2-1_32'
@
text
@d1189 4
d1228 2
d1235 22
@


4.11
log
@Fix non-ARMv7 builds
Detail:
  s/Sound2 - Swap MOV # of a large constant with LDR =. When building for ARMv7 the MOV was being silently swapped for MOVW, but for older architectures it was generating an error.
Admin:
  IOMD, Tungsten, BCM2835 variants of module now build


Version 1.31. Retagged as 'Sound2-1_31'
@
text
@d1001 6
a1006 5
        MOV     r0, #1
        MOV     r2, #0
        SWI     XSound_SampleRate
        MOVVS   r2, #0
        MOV     r5, r2 ; r5 = sample rate in 1/1024 Hz
@


4.10
log
@Automatically adjust tempo for current sample rate + DMA buffer size
Detail:
  The Sound_QTempo SWI has always been defined as accepting a tempo value that's relative to the number of beats per centisecond.
  However the implementation has never attempted to adjust the value to match the current sound system settings; it's always worked under the assumption that one buffer = one centisecond.
  For default sound settings on an Archimedes this would have been almost correct, but for modern machines with different sample rates or buffer sizes it's generally wrong.
  This change rectifies that, by taking whatever tempo value was supplied to the SWI and adjusting it behind the scenes so that the core scheduling code uses the correct beat increment.
  For compatibility with existing software which may be relying on the fact that tempo was never dealt with correctly, this new behaviour can be disabled and the old behaviour used instead simply by disabling automatic tuning via Sound_Tuning.
  s/Sound2 - As above. Added RecalcTempo routine which is responsible for relculating the internal tempo value whenever the external value changes or the sound system configuration changes. This is called from SoundQTempo whenever the user-facing tempo value changes, and from the service call handler whenever the sound system configuration changes or when automatic tuning is turned on or off.
Admin:
  Tested on BB-xM
  !Maestro now plays music at the correct speed when switching the sound system through different sample rates
  This goes part way towards fixing issue #347; fixes for the voice generators are still required:
  https://www.riscosopen.org/tracker/tickets/347


Version 1.31. Tagged as 'Sound2-1_31'
@
text
@d1023 1
a1023 1
        MOVEQ   r5, #10000
@


4.9
log
@Tidy up PSR manipulation to only do the necessary amount of work for the target architectures
Detail:
  s/Sound2 - Instead of assembling to a 26/32bit neutral module, 26bit or 32bit code sequences will now be stripped out where possible, reaping almost insignificant rewards in terms of ROM space and performance.
Admin:
  Tested in IOMD ROM softload


Version 1.30. Tagged as 'Sound2-1_30'
@
text
@d285 3
a287 6
  [ {FALSE}   ;StrongARM - not needed with CallASWI strategy
QSWICode    # 8 ; SWI and return...
  |
Qpadding    # 8 ; so we don't change size
  ]
QTempo      # 4
d435 3
a437 1
        STR     r10, [wp, #QTempo]
d460 1
a460 1
        LDR     r11, [wp, #QTempo]
d465 5
a469 4
        MOVLT   r0, r0, LSL #16         ; 16 bits to top
        ORRLT   r0, r0, r11, LSR #16    ; phase to bottom 16
        MOVLT   r0, r0, ROR #16         ; swap halves
        STR     r0, [wp, #QTempo]
d981 136
d1195 1
d1200 1
d1206 1
d1211 15
a1225 2
        Entry   "r0,r10,r11"            ; Reinitialise the queue on reset
        BL      SoundQFullInit
@


4.8
log
@Fixed very suspect code which would have unpredictable behaviour on most ARMs.

Version 1.29. Tagged as 'Sound2-1_29'
@
text
@d69 1
d315 1
d317 2
d320 1
d325 2
d328 11
d340 1
d346 2
d715 1
d717 1
a717 1

d848 1
d850 1
d864 2
d867 1
d869 1
d872 1
d874 1
d878 1
d880 1
d885 1
d887 1
d891 1
d893 7
d902 2
d906 1
@


4.7
log
@  GET file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both objasm and asasm.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 1.27. Not tagged
@
text
@d410 2
a411 1
20      STR     r11, [r11, #EventSize]!
@


4.6
log
@  Fixed msr and mrs usage to be proper objasm-style MRS and MSR.
Admin:
  Built.

Version 1.27. Tagged as 'Sound2-1_27'
@
text
@d167 1
a167 1
        GET     s.TokHelpSrc
@


4.5
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 1.26. Tagged as 'Sound2-1_26'
@
text
@d315 1
a315 1
        mrs    ,R10, CPSR               ; Get real PSR if we can
d322 1
a322 1
        mrs  AL,R10,CPSR                ; NOP on pre-ARM6
d840 1
a840 1
        mrs    ,r4, CPSR
d859 1
a859 1
        msr    ,CPSR_f, r4
@


4.4
log
@  32-bit compatibility.
Detail:
  Code updated to use macros from HdrSrc for mode changing and IRQ
    state updates.
Admin:
  Tested 26-bit and 32-bit builds on Risc PC by pressing ^G to generate
    the system beep, Maestro to play several sounds concurrently, and
    Replay to play audio files.

Version 1.25. Tagged as 'Sound2-1_25'
@
text
@d104 1
a104 1
        LEADR   Module_LoadAddr
d133 1
a133 4
        DCB     "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        DCB     " $Module_MinorVersion"
 ]
d178 1
a178 1
Tempo_Code ENTRY
d369 1
a369 1
SoundQFullInit ENTRY "r2,r10"
d387 1
a387 1
SoundQInit ENTRY
d556 1
a556 1
SoundQSchedule_SWI ENTRY "r4-r8"
d690 1
a690 1
SoundQRemove_SWI ENTRY "r7"
d714 1
a714 1
SoundQRemove ENTRY "r4-r8"
d822 1
a822 1
SoundQDispatch_SWI ENTRY "r4"
d872 1
a872 1
SoundQDispatch_Body ENTRY "r0-r4"
d937 1
a937 1
Initialise_Module ENTRY "r10, r11"      ; Calls internal routine
d983 1
a983 1
Finalise_Module ENTRY "r10, r11"        ; Calls internal routine
d1026 1
a1026 1
        ENTRY   "r0,r10,r11"            ; Reinitialise the queue on reset
d1032 1
a1032 1
CopyError ENTRY r1-r7
d1048 1
a1048 1
open_messagefile ENTRY r0-r3
@


4.3
log
@Spinner and Ursula branches merged.
Changed to use srccommit.

Version 1.24. Tagged as 'Sound2-1_24'
@
text
@d123 3
d174 4
d189 4
a192 4
        BNE     Parse_Error
        MOV     r0, r2
        SWI     XSound_QTempo
        EXITS
d200 1
a200 1
        BL      CopyError
d202 1
a202 1
        ORRS    pc, lr, #V_bit
d244 2
a245 1
        EXITS
d315 15
d331 1
a331 2
        LDR     wp, [r12]
        TEQP    pc, #I_bit + SVC_mode   ; Disable IRQ, I think we expect it
d334 1
a334 1
        MOVS    pc, lr                  ; Reenable caller's IRQ state
d361 1
a361 1
        MOV     r0, wp
d364 1
a364 1
        MOVS    pc, lr
d372 2
a373 2
SoundQFullInit ENTRY
        TEQP    PC, #SVC_mode + I_bit
d376 1
d378 2
a379 1
        EXITS                           ; exit restoring I_bit
d392 2
a393 2
        MOV     r10, #-1
        STR     r10, [wp, #TimeSlot]    ; Clear slot
d395 2
a396 2
        TST     r14, #I_bit             ; If caller had IRQs on
        TEQEQP  PC, #SVC_mode
d417 1
a417 1
        TEQP    PC, #SVC_mode+I_bit     ; turn IRQs off again
d427 1
a427 1
        EXITS                           ; r0=0 to indicate success
d454 1
a454 1
        MOVS    pc, lr
d463 7
a469 5
SoundQBeat_External ROUT

        MOV     r10, pc                 ; Ensure IRQ disabled
        ORR     r10, r10, #I_bit
        TEQP    r10, #0
d471 1
a471 1
; .............................................................................
d491 1
a491 1
        MOVEQS  pc, lr                  ; [read current beat]
d495 1
a495 1
        MOVEQS  pc, lr                  ; [read current beat limit]
d505 2
a506 1
        MOVS    pc, lr
d526 1
a526 1
        MOVS    pc, lr
d537 6
a542 4
        MOV     r10, pc                 ; Ensure IRQ disabled
        ORR     r10, r10, #I_bit
        TEQP    r10, #0
        B       SoundQSchedule_SWI
d544 1
a544 1
; .............................................................................
d664 2
a665 2
        MOV     r0, #0                  ; success
        EXITS
d669 3
a671 1

d673 1
a673 1

d677 1
a677 1
        TST     r8, #SoundSystemNIL
d683 1
a683 1
        MOVEQS  pc, lr                  ; [ok, else drop into ...]
d688 2
a689 1
        EXITS
d693 1
a693 1
SoundQRemove_SWI ENTRY
d695 1
a695 1
        TEQP    pc, #I_bit + IRQ_mode
d700 3
a702 3
        TEQP    pc, #I_bit + SVC_mode
        NOP
        EXITS
d722 1
a722 1
        EXITS   MI
d768 1
a768 1
        EXITS
d780 1
a780 1
        B       %BT20                   ; now go back and decrement chain...
d786 1
a786 1
        EXITS   MI                      ; Return as r0 was 0
d825 1
a825 1
SoundQDispatch_SWI ENTRY
d827 1
a827 1
        TEQP    pc, #I_bit + IRQ_mode
d830 1
a830 1
        BL      SoundQDispatch_Body     ; MUST be called in IRQ mode
d832 3
a834 3
        TEQP    pc, #I_bit + SVC_mode
        NOP
        EXITS
d839 5
a843 1
SoundQDispatch_IRQ ENTRY
d845 1
a845 1
        TEQP    pc, #I_bit + SVC_mode
d849 1
a849 1
        TEQP    pc, #I_bit + IRQ_mode
d854 1
a854 1
        TEQP    pc, #I_bit + SVC_mode
d858 1
a858 1
        TEQP    pc, #I_bit + IRQ_mode
d860 4
a863 1
        EXITS
d888 1
a888 1
        EXITS   MI                      ; [finished. tempo advanced]
a922 2

  [ {TRUE}   ;StrongARM - avoid dynamic code
a935 29
  |
        Push    "r2-r7"

        ORR     r4, r1, #&EF000000      ; Build an X-form SWI
        ORR     r4, r4, #&00020000
        STR     r4, [wp, #QSWICode+0]
        LDR     r4, SoundSWIReturn      ; LDMFD sp!, {regs, pc}^
        STR     r4, [wp, #QSWICode+4]

        MOV     r0, r2                  ; Get r0,r1 params
        MOV     r1, r3

        MOV     r2, #0                  ; zero all other params
        MOV     r3, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        Push    pc                      ; Push return address = .+12 -> Pull
                                        ; Note, for ARM800/StrongARM + , it is .+8
        ADD     pc, wp, #QSWICode

        NOP                             ;To cope with both +8 and +12
        Pull    "r2-r7"
        B       SoundDispatchNext

SoundSWIReturn                          ; Can't trust lr_irq as he may do
        LDMFD   sp!, {pc}^              ; a SWI that reenables IRQs
  ]
d977 1
a977 1
        EXITS
d1009 2
a1010 1
        EXITS                           ; Mustn't refuse to die
d1031 1
a1031 1
        EXITS                           ; Can't raise error from service
d1069 1
@


4.2
log
@Module merged
@
text
@d74 1
a74 1
        GET     Version
d130 5
a134 1
        DCB     "$Version ($CurrentDate)", 0
d1005 8
d1014 1
a1014 1

d1017 1
a1017 1

@


4.2.2.1
log
@update to Ursula service format
@
text
@a1000 8
;Ursula format
;
UServTab
        DCD     0
        DCD     UService - Module_Base
        DCD     Service_Reset
        DCD     0
        DCD     UServTab - Module_Base
d1002 1
a1002 1
        MOV     r0, r0
d1005 1
a1005 1
UService
@


4.1
log
@Initial revision
@
text
@d275 1
d277 3
a279 1

d881 15
d912 1
d914 1
a914 1
        MOV     r7, #0
d917 1
a920 1

d923 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d894 1
a895 2
        Push    pc                      ; Push return address = .+12 -> Pull
					; Note, for ARM800/StrongARM + , it is .+8
a897 1
	NOP				;To cope with both +8 and +12
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d894 1
a895 2
        Push    pc                      ; Push return address = .+12 -> Pull
					; Note, for ARM800/StrongARM + , it is .+8
a897 1
	NOP				;To cope with both +8 and +12
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a274 1
  [ {FALSE}   ;StrongARM - not needed with CallASWI strategy
d276 1
a276 3
  |
Qpadding    # 8 ; so we don't change size
  ]
a877 15
  [ {TRUE}   ;StrongARM - avoid dynamic code
        Push    "r2-r7,r10"
        BIC     r10, r1, #&FF000000     ; SWI code
        MOV     r0, r2                  ; Get r0,r1 params
        MOV     r1, r3
        MOV     r2, #0                  ; zero all other params
        MOV     r3, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XOS_CallASWI
        Pull    "r2-r7,r10"
        B       SoundDispatchNext
  |
d894 1
a895 2
        Push    pc                      ; Push return address = .+12 -> Pull
                                        ; Note, for ARM800/StrongARM + , it is .+8
a897 1
        NOP                             ;To cope with both +8 and +12
d901 1
a903 1
  ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

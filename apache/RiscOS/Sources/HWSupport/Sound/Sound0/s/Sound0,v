head	4.18;
access;
symbols
	Sound0-1_72:4.18
	Sound0-1_71:4.18
	Sound0-1_70:4.18
	Sound0-1_69:4.17
	Sound0-1_68:4.16
	Sound0-1_67:4.14
	Sound0-1_66:4.14
	Sound0-1_65:4.13
	Sound0-1_64:4.13
	Sound0-1_63:4.11
	Sound0-1_62-4_8_4_4:4.10.4.3
	Sound0-1_62-4_8_4_3:4.10.4.3
	Sound0-1_62-4_8_4_2:4.10.4.2
	Sound0-1_62-4_8_4_1:4.10.4.1
	L72xx_AC97:4.10.0.4
	Sound0-1_62-4_8_2_1:4.10.2.1
	CL92xx:4.10.0.2
	Sound0-1_62:4.10
	Sound0-1_61:4.9
	Sound0-1_60:4.9
	Sound0-1_59:4.8
	dellis_autobuild_BaseSW:4.7
	Sound0-1_58:4.7
	sbrodie_sedwards_16Mar2000:4.6
	SoundDMA-1_57:4.6
	Sound0-1_57:4.6
	dcotton_autobuild_BaseSW:4.11
	Sound0-1_56:4.5
	Ursula_merge:4.4.2.1
	nturton_Sound0-1_54:4.4
	dcotton_sound0_MPTInitialBuild:4.1.7.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.4.2.1
	Ursula_RiscPC:4.4.2.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.4.2.1
	UrsulaBuild_FinalSoftload:4.4.2.1
	rthornb_UrsulaBuild-12Aug1998:4.4.2.1
	aglover_UrsulaBuild-05Aug1998:4.4.2.1
	rthornb_UrsulaBuild-29Jul1998:4.4.2.1
	rthornb_UrsulaBuild-22Jul1998:4.4.2.1
	rthornb_UrsulaBuild-15Jul1998:4.4.2.1
	rthornb_UrsulaBuild-07Jul1998:4.4.2.1
	rthornb_UrsulaBuild-17Jun1998:4.4.2.1
	rthornb_UrsulaBuild-03Jun1998:4.4.2.1
	rthornb_UrsulaBuild-27May1998:4.4.2.1
	rthornb_UrsulaBuild-21May1998:4.4.2.1
	rthornb_UrsulaBuild_01May1998:4.4.2.1
	afrost_NC2_Generic:4.1.7.3
	afrost_Funai01-33:4.1.7.3
	Spinner_RCA116:4.1.7.3
	Spinner_B20_2:4.1.7.3
	Spinner_19_3:4.1.7.3
	Spinner_B18:4.1.7.3
	Spinner_B17:4.1.7.3
	Spinner_B15:4.1.7.3
	Ursula:4.4.0.2
	Spin_merge_3Jul97:4.1.7.1
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Spinner_B12:4.1.7.3
	Spinner_B10:4.1.7.3
	Daytona:4.1.3.2.0.4
	Daytona_bp:4.1.3.2
	Ursula_bp:4.4
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.3
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.18
date	2013.04.14.16.55.11;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	13M3o3zWyeEusLLw;

4.17
date	2012.06.30.10.31.52;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	GsTU43S6rE6UAIaw;

4.16
date	2012.03.24.23.02.07;	author jlee;	state Exp;
branches;
next	4.15;
commitid	Ekb10FqxtrzETbYv;

4.15
date	2012.03.24.22.22.20;	author jlee;	state Exp;
branches;
next	4.14;
commitid	YvoPKrBfhdHYFbYv;

4.14
date	2012.02.16.22.55.09;	author jlee;	state Exp;
branches;
next	4.13;
commitid	Zk08zduMt5xZ2rTv;

4.13
date	2010.12.02.20.41.22;	author bavison;	state Exp;
branches;
next	4.12;

4.12
date	2009.06.11.21.21.16;	author bavison;	state Exp;
branches;
next	4.11;

4.11
date	2001.07.11.11.10.05;	author sbrodie;	state Exp;
branches;
next	4.10;

4.10
date	2001.03.16.16.14.36;	author sbrodie;	state Exp;
branches
	4.10.2.1
	4.10.4.1;
next	4.9;

4.9
date	2001.03.01.14.32.03;	author sforrest;	state Exp;
branches;
next	4.8;

4.8
date	2000.11.16.12.01.37;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2000.04.28.12.49.38;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.12.08.14.47.12;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	99.08.16.11.02.39;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	97.07.03.11.02.06;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	97.05.02.12.49.59;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.20.13.52.14;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.37.42;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.10.2.1
date	2001.06.13.10.34.44;	author kbracey;	state Exp;
branches;
next	;

4.10.4.1
date	2001.06.19.13.11.38;	author kbracey;	state Exp;
branches;
next	4.10.4.2;

4.10.4.2
date	2001.06.20.16.16.26;	author kbracey;	state Exp;
branches;
next	4.10.4.3;

4.10.4.3
date	2001.06.21.12.15.09;	author kbracey;	state Exp;
branches;
next	;

4.4.2.1
date	98.04.15.07.57.11;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.37.42;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.43.52;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.14.40.04;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.14.08.21;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.04.05;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.56.13;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.04.15.16.29.28;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.22.12.47.20;	author mark;	state Exp;
branches;
next	;


desc
@@


4.18
log
@Fixes for 8 bit sound output on MkI Risc PCs
A handful of problems conspired to make this not work
* Line 3237 (and 3225 for pre-VIDC20), bits 16-23 of the buffer logical address were erroneously being used as the sample rate passed to Level1, which in a 32 bit world is 0xFAFF4000 => 255us, now uses the correct register
* Line 3681 et al, a register fumble meant the stereo position registers were being programmed with junk in the mu-law case leading to an annoying high pitched squeal
* Line 2925, reinstate the DMA channel setup in the overrun case
* Line 1465, the parameters to Divide were reversed so the rate always came out at 0Hz (this value doesn't actually appear to be used in the mu-law case, but might as well get it right)
Unrelated
* Added 'Debug' entries to each of the SWIs
* Substituted some OSHW_CallHAL's missed in earlier clear up
* Deleted non functional/obsolete 'AdvancedPower' switch from Stork laptop
* Refactored single use of OverMonoShift to just compare the shifted constants and skip the shift
* Removed redundant 'Version' header

Tested in IOMD ROM on 0197,000 motherboard

Version 1.70. Tagged as 'Sound0-1_70'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     Sound System v3.0 -> <wini>arm.Sound0.Sound0

; *************************************************
; **                                             **
; **       ARTHUR Sound System Software          **
; **                                             **
; **    MODULE: SoundDMAHandler                  **
; **            Level0 Sound System Module       **
; **                                             **
; **    AUTHORS: David Flynn (alas, no more)     **
; **             Stuart Swales (ditto)           **
; **             Tim Dobson                      **
; **             Mark Taunton                    **
; **                                             **
; **    DESCRIPTION: all the privileged access   **
; **            to hardware/physical addresses   **
; **                                             **
; **    ENTRIES: IRQ  from Sound Buffer IRQ      **
; **             SWIs for system level interface **
; **             CLI  commands interface         **
; **                                             **
; *************************************************

; 1.05  EPROM release
; 1.06  Change help messages to add full stops
; 1.07  prevent ROM code linking to vector twice!
; 1.08  fix ROUT bug which corrupted Overrun fix
; 1.09  Service call reset IRQ problem...
; 1.10  Stereo help text fix
; 1.11  Tokenise help. SKS. Was looping freeing in death, not necessary
;       shorter exit sequences with {pc}^. Common error exits. Silly error
;       from irq claim failure. New irq scheme makes shorter + sexier
;       moved audio bug fix to proper place
;       Use spare registers in SWI handler
; 1.12  Fixed more places where IRQ could get in
; 1.13  Pass SoundLevel0Base around - a useful constant indeed!
;       Fixed RESET disabling sound problem. IRQ code neater, faster
; 1.14  Stereo can take optional '+' sign, does services
; 1.15  Had to take out overrun capability as it was much too dangerous
; ---- Released for Arthur 2.00 ----
; 1.16  Added code to cope with Fox VIDC clock speed adjustment
;       Modified header GETs so they work again
; 1.17  Internationalised
; 1.18  OSS  Added assemble time code for A500 which modifies the DMA
;            buffer for VIDC1 (rather than VIDC1a). Code courtesy of JRoach.
; 1.20  01 Mar 92  OSS  Changed to execute A500 buffer modify code in RAM to
;                       minimise the chance of overruns.
; 1.21  07-Aug-92  TMD  Re-added MEMC2 option
; 1.22  27-Aug-92  TMD  Put in VIDC20 option
; 1.23  16-Feb-93  TMD  Corrected for rotation of stereo image registers on VIDC20
; 1.24  25-May-93  MT   Added IOMD support; also conditionals (defined in xxHdr
;                       file) to handle loudspeaker on/off control (SpkControl)
;                       and sound clock frequency variation with video mode
;                       (VarSndClock). Older machines have both: Medusa has
;                       neither.
; 1.25  02-Jul-93  MT   Sound0Hack flag (defined in JordanHdr) now
;                       checked when assembling IOMD version, to avoid
;                       use of OS_Memory (not yet available), and
;                       OS_ClaimDeviceVector with IOMD DMA channels as
;                       devices (since that is also not yet ready).
;                       We use privileged knowledge about kernel's
;                       memory addressing variables to circumvent the
;                       first problem, and IrqV instead of the real
;                       IRQ vector, for the second.
; 1.26  09-Jul-93  TMD  Fix stack imbalance in unknown IRQ code.
; 1.27  15-Jul-93  JSR  Switch to new headers system.
; 1.28  06-Aug-93  MT   Fix bug in IOMD code where overrun (e.g. when
;                       interrupts were disabled for more than a
;                       buffer time) caused system lockup because of
;                       failure to program the correct buffer.
; 1.29  06-Aug-93  MT   No software change - merely getting version number
;                       right here.
; 1.30  11-Aug-93  MT   Fix handling of service call (bug MED-00362)
; 1.31  11-Aug-93  MT   Add the above line and this one, forgotten before (no
;                       code change).
; 1.32  26-Aug-93  OL   Libra mods: International_Help bit set for *audio,
;                       *speaker, *stereo. (These log lines added by MT.)
; 1.33  02-Sep-93  MT   Turned off Sound0Hack (no longer needed, but left in
;                       source for now); fixed stack imbalance bug in code for
;                       exit on XOS_Memory failure; added log entry for 1.32.
; 1.34  05-Oct-93  MT   Corrected flags to XOS_Memory, to fix bug MED-00621.
; 1.35  11-Nov-93  JSR  Fix MED-00820 - fix international help for *Stereo command.
;                       Install, but leave disabled, sound quenching code to quieten
;                       the quiet bits.
; 1.36  14-Feb-94  TMD  Fix MED-02859 - don't call InitResetCommon on Service_Reset
;                       unless it's a soft reset.
; 1.37  30-Jun-94  MT   Removed Sound0Hack, no longer needed, and JSR's sound quenching
;                       code - newer hardware fixes this `properly'.  Major surgery
;                       throughout, to support 16-bit output (set up by CMOS config).
; 1.38  12-Jul-94  MT   Fix problem with Sound_SampleRate setting new rate without VIDC
;                       programming offset of 2.  Also cure duff error on bad param.
; 1.40  18-Oct-94  RCM  Add power saving calls for Stork see 'StorkPower'.
; 1.41  21-Oct-94  SMC  Fixed bug in level0 fill where code could ask for more than would
;                       be played.
;                       Fixed MIN-00087 - Sound_Configure code allowed buffer size to be set
;                       too large for 16bit sound. Also WorkOutVIDCParams called process_oversample
;                       which used the OLD buffer size to determine whether to oversample rather than
;                       the new one given in the SWI call.
;                       Fixed MIN-00022 - Added *Configure SoundSystem for 8bit/16bit sound.
;
; ********************  See SrcFiler log file for changes since version 1.41.
;
; 1.53 14-Apr-97  MT    Merge in changes for StrongARM compatibility, mono output and
;                       oversampling performance improvement.  Change default sample rate
;                       to 22.05Khz, if hardware support is available for this (STB/NC).
; 1.54 22-Apr-97  MT    Fix to allow mono output to be controlled (Sound_Mode 3) - although
;                       the implementation was present, the code to recognise and act on
;                       the specific SWI function code had been omitted by accident in the
;                       code merge.
; 1.59 22-Feb-01  SBF   Obsolete STB flag removed; default frequency of 20.8333kHz used in all cases
;

              GBLL    StrongARM
StrongARM     SETL    {TRUE}

        GET     Hdr:ListOpts
        OPT     OptNoList
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        $GetVIDC
        $GetMEMM
        $GetIO
        GET     Hdr:CMOS
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:PublicWS
        GET     Hdr:Tokens
        GET     Hdr:DevNos
        GET     Hdr:Proc
        GET     Hdr:VduExt
        GET     Hdr:OSBytes
        GET     Hdr:MsgTrans
        GET     Hdr:HostFS
        GET     Hdr:DDVMacros
        GET     Hdr:NDRDebug
        GET     Hdr:Sound
        GET     Hdr:Portable
        GET     Hdr:HALEntries

        OPT     OptList
        OPT     OptPage

        GET     VersionASM



;
; Define the VIDC specific things
;
; Note that we only handle VIDC1, VIDC1a and VIDC20
;
        GBLL    VarSndClock
 [ VIDC_Type = "VIDC1a"
VarSndClock     SETL    {TRUE}
 ]
 [ VIDC_Type = "VIDC20"
VarSndClock     SETL    {FALSE}
 ]

;
; Define IO specific things
;
        GBLL    SpkrControl
SpkrControl     SETL    IO_Type = "IOC-A1" :LOR: IO_Type = "IOC-A500" :LOR: IO_Type = "IOEB"

 [ MEMC_Type = "IOMD"

; On IOMD-based systems, to support sound DMA "cheaply" in terms of
; software complexity, we must have physical sound buffers no bigger
; than the maximum DMA buffer IOMD supports (i.e. number of bytes
; transferred per DMA interrupt).  This is 4Kbytes: the size of a page
; on ARM{6,7}00 machines.  In addition, for each sound DMA buffer,
; either it must all lie within a single physical page, or else the
; pages which contain it must be physically contiguous.  We could
; survive any combination of values for SoundDMABufferSize and
; SoundDMABuffers which satisfied both these conditions. However it is
; simpler here (e.g. no need for physical contiguity check) just to
; use the tighter condition that the SoundDMABufferSize is *exactly*
; 4096 and that the base address of the sound buffers is on a 4096
; byte boundary. This was true for the original values as used on
; MEMC1 systems, and is unlikely to need to change. Therefore this
; tighter restriction is OK.

    [ SoundDMABufferSize /= 4096
        ! 1, "SoundDMABufferSize must be exactly 4096 for Sound0 on IOMD"
    ]
    [ SoundDMABuffers :MOD: 4096 /= 0
        ! 1, "SoundDMABuffers must be 4096-byte-aligned for Sound0 on IOMD"
    ]

; In addition, for yet more simplification, and minimum code change to
; support IOMD, we assume here that the two 4Kb sound buffer pages are
; physically contiguous (in the right order!), so that we can continue
; to use only one word [rLevel0Base,#Phys0] to hold the base address.
; This assumption cannot currently (21-May-93) be tested at assembly
; time.

 ]

        GBLL    StorkPower
StorkPower      SETL    {TRUE}

        GBLL    EnableIRQsIn16bit
EnableIRQsIn16bit       SETL    {FALSE}

 [ EnableIRQsIn16bit
        GBLL    DisableFlybackIRQ
DisableFlybackIRQ       SETL    {TRUE}

        GBLL    DisableHardDiscIRQ
DisableHardDiscIRQ      SETL    {TRUE}
 ]

        GBLL    debug
        GBLL    hostvdu
        GBLL    debugsw
debug           SETL    {FALSE}
hostvdu         SETL    {TRUE}
debugsw         SETL    debug :LAND: {FALSE}

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Level0 data structure

; Sound0Segment:  Sound DMA Control Block
;
; Total of 16 words available.  First 9 must NOT be reordered without also
; fixing static copy (ProtoS0S) and init code, since an LDM/STM pair is used
; with specific registers known to match particular fields
          ^ 0
Semaphore # 4
Phys0     # 4   ; physical address of buffer 0
Buff0     # 4   ; logical page addresses...
Buff1     # 4
Config    # 0
BuffLenLo # 1   ; 16-bit Buffer Length
BuffLenHi # 1
Period    # 1   ; 8-bit SFG period
NChannels # 0   ; Log channels (3 bit) AND sundry flags
Flags     # 1   ; Name for flags byte
Level1Ptr # 4
Images    # 8   ; (8) byte image positions, full 8-bit resolution of user value (-127..127)
Level2Ptr # 4   ; scheduler

; End of order-critical section. From here on, items are initialised
; dynamically and one item at a time, hence order is not significant.

; To cope with hardware DMA buffer pipeline, need to keep parallel pipelines
; for VIDCSFR and VIDCSCR values; also VIDC SIR values (if not in 16-bit mode
; when stereo is handled in software).
VIDCSFR_N # 1   ; (new) value to stick into VIDC to program sound frequency register
VIDCSFR_H # 1   ; value which IRQ code should ensure is in SFR on next irq
VIDCSFR_C # 1   ; softcopy of value currently set in VIDC
; same for VIDCSCR
VIDCSCR_N # 1   ; (new) value to program into VIDC20's Sound Control Register
VIDCSCR_H # 1   ; value which IRQ code should ensure is in SCR on next irq
VIDCSCR_C # 1   ; softcopy of value currently set in VIDC

; Code to handle stereo 16-bit linear emulation of N-channel mu-law needs to
; keep track of how many channels are in use.
Log2nchan_C # 1 ; Log2(currently active channel count), as compiled into 16-bit conv code

 [ VarSndClock
VIDCMultiplier # 1 ; VIDC clock speed in units of 4MHz
 |
Spare0    # 1
 ]

ImagesC_N # 4   ; compacted (new) version of Images, for prog'ing SIR or conv. routine
ImagesC_H # 4   ; value which IRQ code will load into VIDC SIRs on next irq
ImagesC_C # 4   ; softcopy of value currently programmed into VIDC
SoundRMA  # 4   ; pointer to remaining data/dynamic code items held in RMA
SoundGain # 1   ; value of additional gain (0..7) -> +0 .. 21dB in 3dB steps, for mu-law
SoundGain_C # 1 ; value of additional gain as currently compiled into conv code

; CURRENTLY 3(2?) BYTES SPARE (FOR VIDC20).

        ASSERT  @@ <= SoundLevel0Reserved

; Constants
; SC prefix for SoundConstant
SCPeriod     * 48                       ; default, i.e. 20.8333 kHz (48us)

SCBufferLen  * 208                      ; 208 bytes/channel (&D0: multiple of 16)
SCLogChannel * 0                        ; default log2nchan = 0 -> 1 channel
SCSoundGain  * 0                        ; default soundgain is 0

; Flags bits in NChannels/Flags byte: bottom 2 bits are log2nchan, next 2 bits are
; Lin16 flags, 1 bit for auto-oversampling flag, 1 bit for "oversampling active" flag,
; 1 bit for mono-isation flag, top bit reserved (probably unnecessarily) for Level1Fill
; handler call "Level0 updated" flag.
DoMono          *       &40             ; mono-isation control bit
DoOversample    *       &20             ; oversampling active bit
OversampleFlag  *       &10             ; AutoOversampling flag from CMOS
Lin16Bits       *       &0C             ; flags for 16-bit linear mode (VIDC20)
Lin16Shift      *       2               ; low bit of field is bit 2
L16_mulaw       *       &00             ; no, normal mu-law output
L16_slave44k    *       &04             ; DAC slave with 44k1*256 ext sound clock
L16_slaveInt    *       &08             ; DAC slave, no ext sound clock, internal only
L16_master      *       &0C             ; DAC clock is master (MUST use ext sound clock)

; Definition of cut-off point for oversampling
MinOSPeriod     *       40              ; do not oversample if period < 40 (f > 25kHz)

; Level0 constants

 [ MEMC_Type = "IOMD"
; Physical address of sound DMA buffers is not fixed on IOMD systems, but
; needs to be determined at initialisation time.
 |
SoundPhysBuffers * TopOfDMAPhysRAM - (TopOfDMAWorkSpace-SoundDMABuffers)
 ]

 [ VIDC_Type = "VIDC20"
SIR0    *       &A1000000               ; Stereo Image Register addr for chan 0
SIR1    *       &A2000000               ; etc...
SIR2    *       &A3000000
SIR3    *       &A4000000
SIR4    *       &A5000000
SIR5    *       &A6000000
SIR6    *       &A7000000
SIR7    *       &A0000000               ; NB chan 7 address is out of order
SIRSTEP *       &01000000               ; offset from one SIR to next
SFR     *       &B0000000               ; Sound Frequency Register
SCR     *       &B1000000               ; VIDC20 also has Sound Control Reg
 |
SIR0    *       &64000000
SIR1    *       &68000000
SIR2    *       &6C000000
SIR3    *       &70000000
SIR4    *       &74000000
SIR5    *       &78000000
SIR6    *       &7C000000
SIR7    *       &60000000               ; chan out of order
SIRSTEP *       &04000000               ; offset from one SIR to next
SFR     *       &C0000000
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Header
        OPT     OptPage

        AREA    |Sound0$$Code|, CODE, READONLY, PIC

Module_BaseAddr
        DCD     0                    ; NOT AN APPLICATION
        DCD     Initialise_Module    - Module_BaseAddr
        DCD     Finalise_Module      - Module_BaseAddr
        DCD     Intercept_Services   - Module_BaseAddr
        DCD     Module_Name          - Module_BaseAddr
        DCD     Help_String          - Module_BaseAddr
        DCD     Module_Keywords      - Module_BaseAddr
        DCD     Module_SWISystemBase + Sound0SWI * Module_SWIChunkSize
        DCD     Sound_SWI_Code       - Module_BaseAddr
        DCD     Module_SWIDecodeBase - Module_BaseAddr
        DCD     0                    ; No decoding code.
 [ International_Help <> 0
        DCD     message_filename     - Module_BaseAddr
 |
        DCD     0
 ]
 [ :LNOT: No32bitCode
        DCD     Module_Flags         - Module_BaseAddr
 ]

Module_Name
        DCB     "SoundDMA", 0

Help_String
        DCB     "SoundDMA"
        DCB     9
        DCB     "$Module_HelpVersion"
 [ debug
        DCB     " Development"
  [ EnableIRQsIn16bit
        DCB     " IRQs enabled"
  |
        DCB     " IRQs disabled"
  ]
 ]
 [ VIDC_Type = "VIDC20"
  [ MEMC_Type = "IOMD"
        DCB     " Generic"
  |
        DCB     " VIDC20/MEMC1 version"
  ]
 ]
 [ MEMC_Type = "MEMC2" ; assume => VIDC10
        DCB     " MEMC2 version"
 ]
        DCB     0

Module_SWIDecodeBase
        DCB     "Sound",0
        DCB     "Configure",0
        DCB     "Enable",0
        DCB     "Stereo",0
        DCB     "Speaker",0
        DCB     "Mode",0
        DCB     "LinearHandler",0
        DCB     "SampleRate",0
        DCB     "ReadSysInfo",0
        DCB     0

Module_Keywords

        Command "Audio",       1, 1, International_Help ; one parameter ONLY
        Command "Speaker",     1, 1, International_Help ; one parameter ONLY
        Command "Stereo",      2, 2, International_Help ; two parameters ONLY
        Command "SoundGain",   1, 1, International_Help ; one parameter ONLY
        Command "SoundSystem", 2, 1, International_Help :OR: Status_Keyword_Flag  
        DCB     0                                       ; no more entries.

        GET     TokHelpSrc.s

        ALIGN

 [ :LNOT: No32bitCode
Module_Flags
        DCD     ModuleFlag_32bit
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ VIDC_Type = "VIDC20"                 ; only on VIDC20 machines for now
;
; MT, May/June 1994.
;
; Code fragments used to convert from 1/2/4/8 channels of
; 8-bit mu-law sound in the "logical" buffer, to 2 channels of
; either 16-bit linear sound or 8-bit mu-law sound in the same
; buffer, now treated as a "physical" buffer to be output by DMA.
; Note the complexities caused because the logical buffer may
; be smaller than, the same size as, or bigger than the physical
; buffer, depending on the input and output sample-group sizes.
; There are always the same number of sample-groups in the physical
; buffer as in the logical buffer, and the sample rate is unaltered
; also.
;
; These fragments are compiled dynamically after any sound system
; reconfiguration or stereo position change, to cause the correct
; translation of data after the next sound DMA interrupt.  The compiled
; code lives in module workspace, whereas the conversion table stays
; here in module code space (though it might usefully be copied into
; RAM to maximise access speed if this code is running from ROM).
;
; On call to composite routine
;
;   r12 = start of logical/physical buffer
;   r11 = end of physical buffer (1,2 channels) or
;         start of physical buffer (4,8 channels)
;   r10 = end of logical buffer
;   r9  = base of 256-entry, 512-byte table converting mu-law bytes
;         (treated as 0..255, i.e. unsigned) to 16-bit signed
;         values in the range -3952..+3952.  See below
;         for more details on the format of entries.
;   r8  = 0xFF - mask for extraction of individual mu-law bytes
;   r5  = 0x7FFF - constant used for limit operation if soundgain > 0
;
; during call:
;   r7  = 32-bit accumulator for right channel linear data
;   r6  = 32-bit accumulator for left channel linear data
;   r0, r1, r3 - miscellaneous intermediate values
;   r2, r4, r5 - unused

; Conversion table (placed here to avoid addressing problems for the
; compiler).  Compute linear values from mu-law at assembly time.  For
; reference, the direct linear equivalents of mu-law values are:
;
; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
; 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46
; 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108
; 112 120 128 136 144 152 160 168 176 184 192 200 208 216 224 232
; 240 256 272 288 304 320 336 352 368 384 400 416 432 448 464 480
; 496 528 560 592 624 656 688 720 752 784 816 848 880 912 944 976
; 1008 1072 1136 1200 1264 1328 1392 1456 1520 1584 1648 1712 1776 1840 1904 1968
; 2032 2160 2288 2416 2544 2672 2800 2928 3056 3184 3312 3440 3568 3696 3824 3952
;

convtable
        GBLA    chord
        GBLA    point
        GBLA    step
        GBLA    value
value   SETA    0
chord   SETA    0
        WHILE   chord < 8
step      SETA  1 :SHL: chord
point     SETA  0
          WHILE point < 16
            DCD         (((-value) :SHL: 2) :AND: &FFFF) :OR: ((value :SHL: 2) :SHL: 16)
value       SETA        value + step
point       SETA        point + 1
          WEND
chord     SETA  chord + 1
        WEND

; When size (logical buffer) >= size (physical buffer) we must proceed
; forward, loading via r12 which is stepped forwards until it equals
; r10.  Note that in this case r11 starts off = r12.  When the size of
; the logical buffer < size of physical buffer, must move backwards -
; r11 is initialised to end of physical buffer; hence r10 moves
; backwards and r12 stays constant as end-stop for logical buffer.
; End-condition is still r10 = r12.

; Instruction sequence (1): loop begin (same for all configurations)
loop_head
        CMP     R10, R12                ; check for having finished
        MOVEQ   PC, R14                 ; return if so

; Instruction sequence (2): load up a sample-time's worth of data (1..8 bytes), and
; check whether it is all zero. One instruction for each part, two instructions
; per sequence.  Indexed by log2nchan.
data_load_TAB
        LDRB    r1, [r10, #-1]!         ; instruction for loading 1 byte (backwards)
        MOVS    r1, r1, LSL #24         ; get 1 byte in top byte of r1, zero in rest

        LDR     r1, [r10, #-2]!         ; instruction for loading 2 bytes (backwards)
        MOVS    r1, r1, LSL #16         ; get 2 bytes in top half of r1, zero low bytes

        LDR     r1, [r12], #4           ; instruction for loading 4 bytes (forwards)
        MOVS    r1, r1                  ; check it for all 4 bytes being 0

        LDMIA   r12!, {r0,r1}           ; instruction for loading 8 bytes (forwards)
        ORRS    r3, r0, r1              ; result -> temp, to avoid corruption of r0/r1

; Instruction sequence (3): conditionally store a zero output value,
; for when input data is all 0.   Indexed by log2nchan>>1.
zero_store_TAB
; for log2nchan>>1 = 0 (i.e. 1, 2 channels)
        STREQ   r1, [r11, #-4]!         ; if 0, store out a zero and
; for log2nchan>>1 = 1 (i.e. 4, 8 channels)
        STREQ   r1, [r11], #4           ; if 0, store out a zero and

; Instruction sequence (4): conditionally branch back to
; start of loop if input data was all 0 for this sample.
zero_branch
        BEQ     .-(5*4)                 ; branch back to loop_head

; Instruction sequence (5): extract one byte out of 0 through 7 of the 1..8
; bytes picked up by instruction sequence (2), and put it into r3, testing
; for 0 as this is done.  One instruction word for each case.  Entries in
; this table are used starting from the (8-nchan)'th one, up to the required
; number of channels, hence the apparent oddity of the zero-data test
; instructions for 1,2 channels.  Note that the 1-channel case is slightly
; inefficient since we have already checked for all 1 byte being zero - if we
; hadn't done a LSL 24 in the process, we could dispense with this
; instruction, but that would be less regular so we just take the minor hit.
byte_ext_TAB
        ANDS    r3, r8, r0              ; byte 0
        ANDS    r3, r8, r0, LSR #8      ; byte 1
        ANDS    r3, r8, r0, LSR #16     ; byte 2
        ANDS    r3, r8, r0, LSR #24     ; byte 3 (could just be MOVS)
        ANDS    r3, r8, r1              ; byte 4
        ANDS    r3, r8, r1, LSR #8      ; byte 5
        ANDS    r3, r8, r1, LSR #16     ; byte 6
        ANDS    r3, r8, r1, LSR #24     ; byte 7 (could just be MOVS)

; Instruction sequence (6): load up linear value for mu-law byte, from
; table.  This always follows the extraction instruction (above) and is
; conditionalised on Z flag from ANDS, to allow faster execution on zero
; byte value (i.e. no load is actually done and r3 stays 0).  N.B.  As
; should be apparent from its definition, The table holds 16-bit values,
; arranged as +ve/-ve pairs, in words.  The access is indexed with LSL #1
; (i.e. 2-byte entries) but is performed as an LDR, so we get both -ve and
; +ve values, with the required one in the top half of r3, because of ARM's
; data rotation on non-word aligned LDRs.  The subsequent stereo position
; code extracts this value using ASR #n where n varies according to the
; required multiplicative factor for the particular stereo position.
; Within the table entries, each value is the basic 12-bit linear value,
; shifted left by 2, and sign-extended to 16-bits.  This leaves the bottom
; two bits 0, so that ASR #18, 17 or 16 then produces the original value
; times 1, 2 or 4 (respectively), sign extended to 32 bits.

conv_byte
        LDRNE   r3, [r9, r3, LSL #1]

; Instruction sequence (7): set or add linear value just loaded, in the
; correct proportions according to stereo position for channel, into stereo
; accumulators.  Some sequences are two instructions, others 3, so we store
; them here as 3 words each (for indexing during compilation) with the 3rd
; one 0 if not required.  The sequences come in pairs, the first of each
; pair being for the first channel, when the accumulators are initialised,
; and the second for subsequent channels, when the accumulators are added
; to.  This saves at least one instruction in the generated code, over
; pre-initialising both accumulators to 0, and more often than not, 2.

stereo_code
; 100% left
; code for first channel: r6 = (r3 >> 18) * 6 = (r3 >> 17) + (r3 >> 16)
        MOV     r6,     r3, ASR #17
        ADD     r6, r6, r3, ASR #16
        MOV     r7, #0                  ; init right acc to 0
; code for remaining channels
        ADD     r6, r6, r3, ASR #17
        ADD     r6, r6, r3, ASR #16
        DCD     0
; 83% left
; code for first channel: r6 = (r3 >> 18) * 5 = (r3 >> 16) + (r3 >> 18); r7 = r3 >> 18
        MOV     r6,     r3, ASR #16
        ADD     r6, r6, r3, ASR #18
        MOV     r7,     r3, ASR #18
; code for remaining channels
        ADD     r6, r6, r3, ASR #16
        ADD     r6, r6, r3, ASR #18
        ADD     r7, r7, r3, ASR #18
; 67% left
; code for first channel: r6 = (r3 >> 18) * 4 = r3 >> 16; r7 = (r3 >> 18) * 2 = r3 >> 17
        MOV     r6,     r3, ASR #16
        MOV     r7,     r3, ASR #17
        DCD     0
; code for remaining channels
        ADD     r6, r6, r3, ASR #16
        ADD     r7, r7, r3, ASR #17
        DCD     0

; Centre position.  Note that to avoid overflow problems we compute
; r3*1.5, then add r3 ASR #17 (== >> 18 then *2) to each accumulator.
; The multiplication by 1.5 is exact because we have 2 spare 0 bits at
; the bottom of the value.  Overflow from the multiplication in the
; lower half (when that is -ve, i.e. when the required value is +ve)
; does not interfere, since it may reach bit 16, but that gets shifted
; out.

; Code for first channel
        ADD     r3, r3, r3, ASR #1      ; * 1.5
        MOV     r6,     r3, ASR #17     ; == shifted right by 18, then * 2
        MOV     r7,     r3, ASR #17
; Code for remaining channels
        ADD     r3, r3, r3, ASR #1
        ADD     r6, r6, r3, ASR #17
        ADD     r7, r7, r3, ASR #17

; 67% right: the mirror of 67% left
; code for first channel
        MOV     r7,     r3, ASR #16
        MOV     r6,     r3, ASR #17
        DCD     0
; code for remaining channels
        ADD     r7, r7, r3, ASR #16
        ADD     r6, r6, r3, ASR #17
        DCD     0

; 83% right: mirror of 83% left
; code for first channel
        MOV     r7,     r3, ASR #16
        ADD     r7, r7, r3, ASR #18
        MOV     r6,     r3, ASR #18
; code for remaining channels
        ADD     r7, r7, r3, ASR #16
        ADD     r7, r7, r3, ASR #18
        ADD     r6, r6, r3, ASR #18

; 100% right: mirror of 100% left
; code for first channel
        MOV     r7,     r3, ASR #17
        ADD     r7, r7, r3, ASR #16
        MOV     r6, #0                  ; initialise left acc to 0
; code for remaining channels
        ADD     r7, r7, r3, ASR #17
        ADD     r7, r7, r3, ASR #16
        DCD     0

; Instruction sequence (8): scaling code, to convert accumulated values
; (32-bit) back into signed 16-bit numbers.  For 8 channels, the maximum
; absolute value in either accumulator is 6*3952*8 = 189696.  To convert
; this into the range 0..32767 requires multiplying by 32767/189696 =
; .1727342...  We approximate this by multiplying by 11/64 = .171875,
; achieved using ADDs/shifts for the *11 and ASR #6 for the /64.  Exactness
; is unimportant, since all the slightly low value introduces is a small
; gain reduction.  For 1, 2 or 4 channels, the maximum value reduces in
; proportion to the number of channels, so the code is the same except for
; the N in ASR #N which is 3,4,5,6 for 1,2,4,8 channels.

; Version 1.52 onwards: supports *soundgain giving 0 to +21dB additional
; gain, with 3dB increments, in mu-law to linear conversion.  This is
; achieved by using a multiplier of *11 and a divisor of 64 (ASR #6) to give
; 0dB for the 8-channel case, with reducing right shifts as channel count
; decreases or gain is increased in 6dB steps.  For the +3dB steps, don't do
; the mul by 11, but divide by 4 (ASR #2) for 8-channel case, to give
; effectively a +3dB increment, and again reduce the right shift constant or
; go to a left shift for reducing channel count or each extra +6dB gain.
;

; (8a): First the *11 code, the same for all configurations: this is inserted
; only when soundgain is even (i.e. 0dB, 6dB, 12dB, 18dB)
scale_mul_even
        ADD     r0, r6, r6, LSL #1      ; r6 * 3
        ADD     r6, r0, r6, LSL #3      ; + r6 * 8 = r6 * 11
        ADD     r0, r7, r7, LSL #1      ; r7 * 3
        ADD     r7, r0, r7, LSL #3      ; + r7 * 8 = r7 * 11

; (8b): gain scaling code, 2 instructions; table indexed by
;       7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4).
scale_TAB                       ;       1ch     2ch     4ch     8ch
                                ;----------------------------------
        MOV     r6, r6, LSL #4  ;0      +21     -       -       -  GAIN (soundgain odd)
        MOV     r7, r7, LSL #4  ;       -       -       -       -  GAIN (soundgain even)

        MOV     r6, r6, LSL #3  ;1      +15     +21     -       -
        MOV     r7, r7, LSL #3  ;       -       -       -       -

        MOV     r6, r6, LSL #2  ;2      +9      +15     +21     -
        MOV     r7, r7, LSL #2  ;       -       -       -       -

        MOV     r6, r6, LSL #1  ;3      +3      +9      +15     +21
        MOV     r7, r7, LSL #1  ;       -       -       -       -

        DCD     0               ;4      -       +3      +9      +15
        DCD     0               ;       +18     -       -       -

        MOV     r6, r6, ASR #1  ;5      -       -       +3      +9
        MOV     r7, r7, ASR #1  ;       +12     +18     -       -

        MOV     r6, r6, ASR #2  ;6      -       -       -       +3
        MOV     r7, r7, ASR #2  ;       +6      +12     +18     -

        MOV     r6, r6, ASR #3  ;7      -       -       -       -
        MOV     r7, r7, ASR #3  ;       +0      +6      +12     +18

        MOV     r6, r6, ASR #4  ;8      -       -       -       -
        MOV     r7, r7, ASR #4  ;       -       +0      +6      +12

        MOV     r6, r6, ASR #5  ;9      -       -       -       -
        MOV     r7, r7, ASR #5  ;       -       -       +0      +6

        MOV     r6, r6, ASR #6  ;10      -       -       -       -
        MOV     r7, r7, ASR #6  ;       -       -       -       +0

; Instruction sequence (8c): do limiting (clipping) on output values:
; only used if soundgain > 0.
limit
        MOV     r0, r6, ASR #31         ; get r6 sign bit throughout r0
        CMP     r0, r6, ASR #15         ; check for overflow
        EORNE   r6, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r6
        MOV     r0, r7, ASR #31         ; get r7 sign bit throughout r0
        CMP     r0, r7, ASR #15         ; check for overflow
        EORNE   r7, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r7

; Instruction sequence (9): combine 2 x 16-bit values (sign-ext'd to
; 32-bits) from r6 and r7 into r6 ready for storing.  Same for all
; configurations.
combine
        MOV     r6, r6, LSL #16
        MOV     r7, r7, LSL #16
        ORR     r6, r6, r7, LSR #16

; Instruction sequence (10): store out the result: code for either
; direction (1 instruction each).  Index by log2nchan>>1.
store_sample
; for 1,2 channels
        STR     r6, [r11, #-4]!         ; backwards
; for 4,8 channels
        STR     r6, [r11], #4           ; forwards

; Instruction sequence (11): branch back to start of loop.  This
; instruction is adjusted in accordance with the total size of the loop
; code, which is dependent on both configuration (# channels) and also on
; individual stereo positions per channel.
loop_end
        B       .                       ; patched during compilation

; Defined maximum size of the conversion code.  This is:
;       size of sequence(1;2;3;4)         = 4 * (       (2 + 2 + 1 + 1)
; + 8 * size of sequence(5;6;7(max-size))        +  8 * (1 + 1 + 3)
; +     size of sequence(8a;8b;8c;9;10;11)       +      (4 + 2 + 6 + 3 + 1 + 1))

MAXLinConvCodeSize *  4 * ((2 + 2 + 1 + 1) + 8 * (1 + 1 + 3) + (4 + 2 + 6 + 3 + 1 + 1))


; Compile: generate a conversion routine appropriate to current configuration and
; stereo position settings.
; Entry conditions:
;   SVC mode, IRQs disabled (essential for atomic rewrite of code!)
; Parameters:
;   r0 = log2nchan, i.e. 0 -> 1 channel, 1 -> 2 chans, 2 -> 4 chans, 3 -> 8 chans
;   r1 = pointer to space for compiled routine, in module workspace
;   r2 = compacted array of stereo position values, 8x3 bits each (1-based)
;        in bits 0..23, with soundgain (0..7) in top byte.

compile
        Push    "r1,r3-r9,lr"           ; save r3-r9,pc', and code start address (r1) for later

        ; (1): loop head code (fixed, 2 instructions)
        ADR     r3, loop_head
        LDMIA   r3,  {r4,r5}
        STMIA   r1!, {r4, r5}
        ; (2): data load and zero check: 2 instructions, indexed by log2nchan
        ADR     r3, data_load_TAB
        ADD     r3, r3, r0, LSL #3      ; 8 bytes each
        LDMIA   r3,  {r4, r5}           ; get 2 instructions
        STMIA   r1!, {r4, r5}           ; store them
        ; (3): conditional zero-store
        ADR     r3, zero_store_TAB
        MOV     r4, r0, LSR #1          ; index by log2nchan>>1
        LDR     r4, [r3, r4, LSL #2]    ; 4 bytes each, get 1 instr
        STMIA   r1!, {r4}               ; store it
        ; (4): conditional branch back
        LDR     r4, zero_branch         ; get the instruction
        STMIA   r1!, {r4}               ; store it out

        ; preserve soundgain value, for later (r2 gets shifted in next loop)
        MOV     r7, r2, LSR #24         ;

        ; Now the per-channel code.  Get r9 as nchans, and use r8
        ; as loop variable from 0 to nchans-1.
        MOV     r9, #1
        MOV     r9, r9, LSL r0          ; get nchans in r9
        MOV     r8, #0                  ; start at channel 0
10
        ; (5): byte-extraction code, per channel
        ADR     r3, byte_ext_TAB+8*4
        SUB     r3, r3, r9, LSL #2      ; start from (8-nchan)th entry
        LDR     r4, [r3, r8, LSL #2]    ; get the instruction for this channel
        STMIA   r1!, {r4}               ; store it out
        ; (6): byte-conversion (1 instruction, fixed)
        LDR     r4, conv_byte           ; get it
        STMIA   r1!, {r4}               ; store it
        ; (7): stereo positioning: index by channel position, and by
        ; whether this is the first channel (channel 0) or not.
        ADR     r3, stereo_code
        AND     r4, r2, #7              ; get this channel's value
        MOV     r2, r2, LSR #3          ; shift remaining channels down
        SUB     r4, r4, #1              ; convert to 0-based value
        ADD     r4, r4, r4, LSL #1      ; * 24 (3 w/seq * 2 seq/pos * 4b/w), first *3...
        ADD     r3, r3, r4, LSL #3      ; then *8, to index table of sequences
        CMP     r8, #0                  ; if not on channel 0...
        ADDNE   r3, r3, #3*4            ;  skip on to second 3-word seq of pair
        LDMIA   r3, {r4,r5,r6}          ; pick up three words
        CMP     r6, #0                  ; check for last being 0 (unused)
        STMEQIA r1!, {r4,r5}            ; if so, store out 2 only
        STMNEIA r1!, {r4,r5,r6}         ; else store out all 3

        ; OK, done one channel's code.  Step on.
        ADD     r8, r8, #1
        CMP     r8, r9
        BLT     %BT10                   ; branch back if more channels to do

        ; (8): scaling code, in three parts.
        ; (8a): if soundgain is even, multiply by 11 (same for all modes) - 4 insts
        ;       note: r7 holds soundgain value from above
        TST     r7, #1
        ADREQ   r2, scale_mul_even
        LDMEQIA r2!, {r3,r4,r5,r6}
        STMEQIA r1!, {r3,r4,r5,r6}

        ; (8b): next perform scaling (shifting) as required, using
        ;  scale_TAB[7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4)]

        ADR     r2, scale_TAB+7*2*4     ; address scale_TAB[7]
        SUB     r6, r0, r7, LSR #1      ; compute (log2nchan - soundgain DIV 2)
        SUBNE   r6, r6, #4              ; if soundgain odd, subtract 4 (c/c still valid)
        ADD     r2, r2, r6, LSL #3      ; then scale for 2 instructions/entry
        LDMIA   r2, {r4,r5}             ; get the 2 instructions
        CMP     r4, #0                  ; if first instr is not 0 (for NOP)...
        STMNEIA r1!, {r4,r5}            ; ...store them

        ; (8c) perform limiting on sample values if required (i.e. soundgain > 0)
        ADR     r2, limit
        CMP     r7, #0
        LDMNEIA r2,  {r3,r4,r5,r6,r7,r8}  ; 6 instructions (3/channel)
        STMNEIA r1!, {r3,r4,r5,r6,r7,r8}  ; store them

        ; (9): combining two samples into 1 word - 3 fixed instructions
        ADR     r3, combine
        LDMIA   r3, {r4,r5,r6}          ; get them
        STMIA   r1!, {r4,r5,r6}         ; store them

        ; (10): store out the sample, 1 instruction - 2 cases.
        ADR     r3, store_sample
        MOV     r4, r0, LSR #1          ; get log2nchan>>1
        LDR     r4, [r3, r4, LSL #2]    ; index table of single word instrs
        STMIA   r1!, {r4}               ; store it out

        ; (11): branch back to loop start code.  Need to compute offset here
        LDR     r4, loop_end            ; get the B . instruction (note: bits 23..3 are 1)
        Pull    "r0"                    ; pop original code start (loop top)
        SUB     r3, r1, r0              ; work out offset from there to . now
        SUB     r4, r4, r3, LSR #2      ; subtract offset (in words) to get instr
        STMIA   r1!, {r4}               ; store it out and we're done!
      [ StrongARM
        Push    "r0-r2"
        BL      Sound0synccode          ; SynchroniseCodeAreas, r0 = start addr, r1 = end addr (inclusive)
        Pull    "r0-r2"
      ]
        ; All done!
        Pull    "r3-r9,pc"              ; recover saved regs and go home
 ]


; Define RMA sound workspace now we know how big the A500 or mu-law-to-linear code is.

        ^       0

MessageFile_Block # 16
MessageFile_Open  #  4

BaseOfIOMD        #  4                  ; Logical addresses
BaseOfVIDC        #  4                  ; Logical addresses

 [ VIDC_Type = "VIDC20"
; 16-bit linear support data
SavedSample       #  4                  ; Preserved stereo value from end of last buffer, for
                                        ; 2:1 linear interpolation (if configured).
Lin16GenR0        #  4                  ; Value to be passed in R0 to ...
Lin16Gen          #  4                  ; User-supplied 16-bit sound generator(/mixer) code
NSR               #  4                  ; Total number of available sample frequencies
CurSRValue        #  4                  ; Current sample frequency in 1/1024 Hz units
CurSRIndex        #  4                  ; index into set of available frequencies
LinConvCode       #  MAXLinConvCodeSize ; Space for the dynamically-compiled mu-law to
                                        ; 16-bit-linear conversion code
 ]

 [ StorkPower
portable_present  # 4                   ;  = 0 if we don't think the Portable module is present
                                        ;  = 1 if we do
power_state       # 4                   ;

SoundPowerBits  * PortableControl_SoundEnable
 ]

WorkSpaceSize     * @@

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Audio_Code Entry

        BL      DecodeOnOrOff
        SWI     XSound_Enable
        EXIT

; .............................................................................

Speaker_Code ALTENTRY

        BL      DecodeOnOrOff
        SWI     XSound_Speaker
        EXIT

; .............................................................................
; Out   r0 = 1,2 (ON/OFF)
;       r12 = workspace pointer

DecodeOnOrOff ROUT

        LDR     r12, [r12]              ; Get workspace pointer for caller
        LDRB    r1, [r0], #1            ; Spaces skipped already
        CMP     r1, #"O"
        CMPNE   r1, #"o"
        BNE     Bad_Parameter_Error
        LDRB    r1, [r0], #1
        CMP     r1, #"N"
        CMPNE   r1, #"n"
        BNE     %FT50
        LDRB    r1, [r0], #1            ; Ensure no trailing junk
        CMP     r1, #" "
        BHI     Bad_Parameter_Error
        MOV     r0, #2                  ;  2 -> ON
        MOV     pc, lr                  ; flags irrelevant on *-command exit

50      CMP     r1, #"F"
        CMPNE   r1, #"f"
        BNE     Bad_Parameter_Error
        LDRB    r1, [r0], #1
        CMP     r1, #"F"
        CMPNE   r1, #"f"
        CMPNE   r1, #"."
        BNE     Bad_Parameter_Error

        LDRB    r1, [r0], #1            ; Ensure no trailing junk
        CMP     r1, #" "
        BHI     Bad_Parameter_Error
        MOV     r0, #1                  ;  1 -> OFF
        MOV     pc, lr                  ; flags irrelevant on *-command exit

Bad_Parameter_Error
        ADR     r0, ErrorBlock_BadSoundParameter

ReturnError ; For star commands

        BL      CopyError
        PullEnv
        RETURNVS

        MakeInternatErrorBlock BadSoundParameter,,M00

; .............................................................................

Stereo_Code ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer
        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned
        BVS     Stereo_Channel_Error

        SUB     r14, r2, #1             ; Ensure in 1..SoundPhysChannels
        CMP     r14, #SoundPhysChannels
        BHS     Stereo_Channel_Error

        MOV     r4, r2                  ; preserve

10      LDRB    r3, [r1], #1            ; strip spaces
        CMP     r3, #" "
        BEQ     %BT10

        TEQ     r3, #"-"                ; signed?
        TEQNE   r3, #"+"
        SUBNE   r1, r1, #1              ; retrace our steps

        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned
        BVS     Stereo_Position_Error

        CMP     r2, #127
        BHI     Stereo_Position_Error

        TEQ     r3, #"-"                ; invert now if -ve
        RSBEQ   r2, r2, #0

        MOV     r0, r4                  ; channel no.
        MOV     r1, r2                  ; Position
        SWI     XSound_Stereo
        EXIT


Stereo_Channel_Error
        ADR     r0, ErrorBlock_BadSoundChannel
        B       ReturnError

        MakeInternatErrorBlock BadSoundChannel,,M01


Stereo_Position_Error
        ADR     r0, ErrorBlock_BadSoundStereo
        B       ReturnError

        MakeInternatErrorBlock BadSoundStereo,,M02

; .............................................................................

SoundSystem_Code
; In:   r0 = 0  => print syntax only
;       r0 = 1  => print current status
;       r0 > 1  => configure new value
;
        LDR     r12, [r12]

        Entry   "r1-r3"

        CMP     r0, #1
        BEQ     %FT10
        BCS     %FT20

        SWI     XOS_WriteS                      ; Print syntax only.
soundsystem_string
        DCB     "SoundSystem  ",0
        ALIGN
        SWI     XOS_WriteS
        DCB     "8bit | 16bit [Oversampled] | <D>",0
        SWIVC   XOS_NewLine
        EXIT

10
        MOV     r0, #OsByte_ReadCMOS
        MOV     r1, #PrintSoundCMOS
        SWI     XOS_Byte
        ADRVC   r0, soundsystem_string
        SWIVC   XOS_Write0
        EXIT    VS

        TST     r2, #&60
        ADREQ   r0, parameter_8bit
        ADRNE   r0, parameter_16bit
        SWI     XOS_Write0
        EXIT    VS

        TST     r2, #&80
        BEQ     %FT15
        SWI     XOS_WriteI+" "
        ADRVC   r0, parameter_oversampled
        SWIVC   XOS_Write0
15
        SWIVC   XOS_NewLine
        EXIT

20
        MOV     r3, r0                          ; Save pointer to first parameter.

        ADR     r1, parameter_8bit
        BL      strcmp_advance
        BNE     %FT30

        BL      skip_spaces                     ; "8bit" given so can be no more parameters.
        MOVCC   r3, #0
        BCC     set_new_value

        MOV     r0, #3                          ; Too many parameters
        B       exit_error

30
        MOV     r0, r3
        ADR     r1, parameter_16bit
        BL      strcmp_advance
        BNE     %FT40

        BL      skip_spaces                     ; "16bit" given so check for second parameter.
        MOVCC   r3, #1                          ; None, so no oversample.
        BCC     set_new_value

        ADR     r1, parameter_oversampled       ; Must be "oversampled".
        BL      strcmp_advance
        MOVEQ   r3, #5
        BEQ     set_new_value

        MOV     r0, #0                          ; Bad configure option.
exit_error
        SETV
        EXIT

40
        MOV     r0, #10:OR:(1:SHL:31):OR:(1:SHL:29)     ; Read unsigned, limit range, check terminator.
        MOV     r1, r3
        MOV     r2, #7
        SWI     XOS_ReadUnsigned
        EXIT    VS

        MOV     r0, r1                          ; Make sure number is not followed by another parameter.
        BL      skip_spaces
        MOVCS   r0, #3
        BCS     exit_error

        MOV     r3, r2
set_new_value
        MOV     r0, #OsByte_ReadCMOS            ; Read current value.
        MOV     r1, #PrintSoundCMOS
        SWI     XOS_Byte

        BICVC   r2, r2, #7:SHL:5                ; Set new value.
        ORRVC   r2, r2, r3, LSL #5
        MOVVC   r0, #OsByte_WriteCMOS
        SWIVC   XOS_Byte
        EXIT


parameter_8bit
        DCB     "8bit",0
parameter_16bit
        DCB     "16bit",0
parameter_oversampled
        DCB     "Oversampled",0
        ALIGN

strcmp_advance
; In:   r0 -> string 1 (space or control char terminated)
;       r1 -> string 2 (space or control char terminated)
; Out:  EQ => strings match (no case)
;       r0 -> terminator of string 1
;       OR
;       NE => strings do not match
;
        Entry   "r2"
10
        LDRB    r2, [r0], #1
        LDRB    lr, [r1], #1
        CMP     r2, #" "                ; If found both terminators then strings are equal.
        CMPLE   lr, #" "
        BLE     %FT20

        BIC     r2, r2, #1:SHL:5
        BIC     lr, lr, #1:SHL:5
        TEQ     r2, lr
        BEQ     %BT10
        EXIT                            ; Not same so exit NE.
20
        SUB     r0, r0, #1              ; Point to terminator.
        CMP     r0, r0                  ; Same so exit EQ.
        EXIT

skip_spaces
; In:   r0 -> string
; Out:  r0 -> first non-space in string
;       CC => control char found
;       CS => printable char found
;
        Entry
10
        LDRB    lr, [r0], #1
        CMP     lr, #" "
        BEQ     %BT10
        SUB     r0, r0, #1
        EXIT


; .............................................................................

SoundGain_Code  ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer

        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned        ; complain if not a number or bad term
        BVS     Bad_Parameter_Error
        CMP     r2, #7                  ; if >7, complain about range
        BHI     SoundGain_Error
        LDR     r1, =SoundLevel0Base
        STRB    r2, [r1, #SoundGain]   ; else store out for compilation on next irq
        EXIT

SoundGain_Error
        ADR     r0, ErrorBlock_BadSoundGain
        B       ReturnError

        MakeInternatErrorBlock BadSoundGain,,M03

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Data Structure and Constants
        OPT     OptPage

; DMA physical address pointer

; Prototype of part of Sound0Segment from Buff 0 .. Scheduler

ProtoS0S
        DCD     SoundDMABuffers                         ; Buff 0
        DCD     SoundDMABuffers + SoundDMABufferSize    ; Buff 1
; Config word, comprised of buffer length (16 bits), period (8 bits),
; log2nchan (3 bits), spare (1 bit), 16-bit flags (2 bits), spare (2 bits)
        DCW     SCBufferLen
        DCB     SCPeriod
        DCB     SCLogChannel                            ; Note: 16-bit flags are 0

        DCD     SoundSystemNIL                          ; channel handler
        DCB     &80, &80, &80, &80, &80, &80, &80, &80  ; Images (2 words worth)
        DCD     SoundSystemNIL                          ; scheduler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module SWI Interface
        OPT     OptPage

Sound_SWI_Code ROUT
        Push    R14
        WritePSRc I_bit :OR: SVC_mode, r14
        BL      Original_SWI_Code
        Pull    R14
        MOV     R10,#0
        MRS     R10,CPSR                ; NOP on pre-ARM6
        TST     R10,#2_11100            ; EQ if in 26-bit mode - C,V unaltered
        MOVNE   PC,R14                  ; 32-bit exit: NZ corrupted, CV passed back
        MOVVCS  PC,R14                  ; 26-bit exit: NZC preserved, V clear
        ORRVSS  PC,R14,#V_bit           ; 26-bit exit: NZC preserved, V set

Original_SWI_Code
        LDR     r10, =SoundLevel0Base
        CMP     r11, #(EndOfJumpTable-JumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        MOV     pc, lr

JumpTable
        B       Sound0Config            ; configuration
        B       Sound0Enable            ; enable control
        B       Sound0Stereo            ; stereo positioning
        B       Sound0Speaker           ; loudspeaker control
        B       Sound0Mode              ; mode control/status (16-bit/mu-law etc)
        B       Sound0LinearHandler     ; 16-bit sound generator interface
        B       Sound0SampleRate        ; new sample rate control interface
        B       Sound0ReadSysInfo       ; Read info
EndOfJumpTable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0  = no. of channels (rounded up to power of two)
;       r1  = samples per buffer
;       r2  = uS per sample
;       r3  = Level1 Handler   (normally 0!)
;       r4  = Level2 Scheduler (normally 0!)
;       r10 = SoundLevel0Base
;       0 -> don't change!
;       IRQs disabled
;
; Constraints:
;              1 <= r0             <= 8
;             16 <= r1 * NChannels <= SoundDMASize
;  3 * NChannels <= r2 * NChannels <= 255

; Out   Return old r0,r1,r2,r3,r4

Sound0Config Entry

        Debug   sw,"Sound0Config",r0,r1,r2,r3,r4

        CMP     r0, #0                  ; r0 processing
        LDREQB  r0, [r10, #NChannels]
        ANDEQ   r0, r0, #3
        BEQ     %FT10

        SUB     r0, r0, #1              ; 1=>0, 2=>1 FOR LOGS!
        CMP     r0, #3
        MOVEQ   r0, #2                  ; 2,3 => 2
        MOVGT   r0, #3                  ; 4,5,6,7 => 3

10 ; MUST UPDATE STEREO POSITIONS

        Push    "r0-r3"
        LDRB    r3, [r10, #NChannels]
        STRB    r0, [r10, #NChannels]
        MOV     r2, #1
        MOV     r2, r2, LSL r0          ; number of channels

; for r0 = 1 to NChannels
        MOV     r0, #1
15      MOV     r1, #-128               ; read stereo pos
        SWI     XSound_Stereo           ; get previous
        SWI     XSound_Stereo           ; force set to new channels
        ADD     r0, r0, #1
        CMP     r0, r2
        BLE     %BT15                   ; loop for N active channels

        STRB    r3, [r10, #NChannels]
        Pull    "r0-r3"

        CMP     r1, #0                  ; r1 processing
        LDREQ   r1, [r10, #Config]      ; bottom 16 bits
        BIC     r1, r1, #&FF000000
        BIC     r1, r1, #&00FF0000
        BEQ     %FT20

        MOV     r1, r1, LSL r0          ; scale for NChannels of 8bit data
        CMP     r1, #SoundDMABufferSize ; can't be > buffer size
        MOVGT   r1, #SoundDMABufferSize
        MOV     r1, r1, LSR r0          ; back to per channel

 [ VIDC_Type = "VIDC20"
        LDRB    lr, [r10, #Flags]
        TST     lr, #Lin16Bits          ; doing 16bit sound?
        MOVEQ   r11, r0                 ; no, so check enough for 16bits of raw 8bit data
        BEQ     %FT19

        ADD     r1, r1, #3              ; Mono/oversample code processes 4 words of (non-oversampled) linear data at a time
        BIC     r1, r1, #3

        ; Check (non-oversampled) linear data doesn't overflow buffer
        ; Oversampled data is checked by process_oversample
        CMP     r1, #SoundDMABufferSize :SHR: 2
        MOVGT   r1, #SoundDMABufferSize :SHR: 2
19
        MOV     lr, #32                 ; ensure enough 8bit/16bit samples for >= 32bytes of raw data
        CMP     r1, lr, LSR r11
        MOVLT   r1, lr, LSR r11
 ]
        Debug   sw,"per channel bufsz =",r1

20      CMP     r2, #0                  ; r2 processing
        LDREQB  r2, [r10, #Period]       ; if 0 then substitute current

        BL      WorkOutVIDCParams       ; but still go through update procedure

30      CMP     r3, #0                  ; r3 processing
        LDREQ   r3, [r10, #Level1Ptr]    ; old if 0

        CMP     r4, #0                  ; r4 processing
        LDREQ   r4, [r10, #Level2Ptr]    ; old if 0

40 ; merge into reg

        ORR     r11,  r1, r2, LSL #16
        ORR     r11, r11, r0, LSL #24

        LDR     r0, [r10, #Config]      ; Get return params
        AND     r1, r0, #&FC000000      ; extract current flags from nchan/flags byte
        ORR     r11, r11, r1            ; combine into new config value to store
        BIC     r1, r0, #&FF000000      ; mask out flags etc, leaving per-chan buflen
        BIC     r1, r1, #&00FF0000

        MOV     r2, r0, LSR #16
        AND     r2, r2, #&FF            ; current period value in r2

        ; produce channel count in r0, starting from config word in r0.
        MOV     r0, r0, LSR #24
        AND     r0, r0, #3
        ORR     r0, r0, #&01000000
        MOV     r0, r0, LSL r0          ; relies on LSL reg using only bits 7:0 of reg!
        MOV     r0, r0, LSR #24

        STR     r11, [r10, #Config]     ; store new buflen, period, log2nchan, flags

        LDR     r11, [r10, #Level1Ptr]  ; SSCB base
        STR     r3,  [r10, #Level1Ptr]  ; Install new Level1 handler
        MOV     r3,  r11                ; Return old

        LDR     r11, [r10, #Level2Ptr]  ; SSCB base
        STR     r4,  [r10, #Level2Ptr]  ; Install new Level2 handler
        MOV     r4,  r11                ; Return old

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       WorkOutVIDCParams - Compute VIDC SFR (and for VIDC20, SCR) value from
;       present configuration: no. of channels, sample period [and, with variable
;       sound clock, VIDCMultiplier].
;
; in:   r0 = log2(no of channels)
;       r1 = samples per buffer
;       r2 = desired sample period in microseconds, if < 256,
;  [    VIDCMultiplier holds VIDC clock rate DIV 4MHz ]
;       r10 = SoundLevel0Base
;
; out:  r2 = effective per-channel sample rate used (in microseconds)
;       VIDCSFR_N holds SFR value to program into VIDC
;       [ VIDCSCR_N holds value to program into VIDC20 SCR ]
;

WorkOutVIDCParams ROUT
 [ VIDC_Type = "VIDC20"                 ; new code for Risc PC etc
        Entry   "r0,r1,r3-r8"

        Debug   sw,"WorkOutVIDCParams",r0,r1,r2

        LDRB    r0, [r10, #Flags]       ; check for what rates we can handle
        AND     r0, r0, #Lin16Bits      ; by reference to new CMOS sound bits, read on init
        CMP     r0, #L16_mulaw  ; check for old sound system
        BNE     %FT20

; L16_mulaw: no special sound clock support, and mu-law sound only: can only
; handle standard VIDC rates; work out VIDC programming parameters, taking
; number of channels into account.

        Debug   sw,"L16_mulaw"

        BICS    r0, r2, #&FF            ; see if number out of range 0..255
        MOVNE   r2, #&FF                ; if >=255 (or -ve) then use 255
        MOVMI   r2, #&03                ; if -ve then use 3
        LDR     r0, [sp, #0*4]          ; get log2(NChannels) back
        MOV     r3, r2, LSR r0          ; scale for NChannels
        CMP     r3, #&03                ; if < 3
        MOVLO   r3, #&03                ; then use 3
        MOV     r2, r3, LSL r0          ; compute inter-sample period for one channel
        MOV     r1, #&05                ; program SCR for internal clock, mu-law DAC sound
        ; work out sample frequency from per-channel usec period in r2
        Push    "r1-r2"                 ; save regs corrupted by Divide
        LDR     r0, =1024*1000*1000     ; calculate 1,024,000,000/usec
        MOV     r1, r2                  ; to get Hz/1024
        BL      Divide
        MOV     r0, r2                  ; put result into r0
        Pull    "r1-r2"                 ; recover other values
        MOV     lr, #0                  ; non-sensible SampleRate index (irrelevant anyway!)
        B       %FT98                   ; go set up

20

; 16-bit output hardware in place: must use one of the subset of sample rates
; supported in this configuration.  This is effectively only rates which can
; be used in 4-channel mode, i.e. with period a multiple of 4usec, and in fact
; below 40usec (25kHz), just 8-channel-capable (N*8usec) rates, to allow for 2x
; oversampling.  Scan the appropriate subset of the tabulated frequencies,
; looking for a suitable match.

        Debug   sw,"16bit output"

        MOV     r0, r0, LSR #Lin16Shift ; reduce mode to 1..3 range (0 accounted for above)
        ADRL    r1, mtab-1              ; address map table (0th entry)
        LDRB    r0, [r1, r0]            ; pick up map offset for mode
        ADD     r0, r1, r0              ; convert to address of relevant map, -1
        LDRB    r5, [r0, #1]!           ; get index range (entry 0 in map)
        ADR     r4, ftab-8              ; address 0th entry of main freq info table
        MOV     lr, #1                  ; start with entry 1 in map
22      LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period

        SUBS    r7, r3, r2              ; place (entry - freq) in r7
        BEQ     %FT26                   ; if =, go do it
        BPL     %FT24                   ; else if freq > entry, then look at next entry

                                        ; here, freq < entry, so test for closest match ie

                                        ;      (last_entry > freq < this_entry)

        CMP     lr, #1                  ; accept if at start of table
        BEQ     %FT26
        SUB     lr, lr, #1              ; otherwise back up to previous entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period

        SUB     r8, r2, r3              ; place (freq - entry) in r8

        CMP     r7, r8                  ; if r7 < r8 (they're negative) then we have best
        BLT     %FT26                   ; match so accept the current entry

        ADD     lr, lr, #1              ; otherwise go back up to next entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period
        B       %FT26                   ; and accept it


24      CMP     lr, r5                  ; if at end of list, accept this one
        BEQ     %FT26
        ADD     lr, lr, #1
        B       %BT22

26      LDRB    r2, [r1, #4]            ; pick up period to report back to user
        LDRB    r3, [r1, #5]            ; pick up unadjusted SFR value
        LDR     r0, [r1, #0]            ; get frequency value
        LDRB    r1, [r1, #6]            ; and SCR value
        ; and drop into final code

; Store computed values and exit:
; lr is sample rate index
; r3 is VIDC SFR to program, unadjusted, assuming no oversampling
; r2 is user-visible per-channel period,
; r1 is value for scr
; r0 is sample frequency in Hz/1024
98
        Debug   sw,"computed values are",r0,r1,r2,r3

        STRB    r1, [r10, #VIDCSCR_N]   ; store new SCR value
        LDR     r1, [r10, #SoundRMA]
        LDR     r4, [r1, #CurSRValue]
        STR     r0, [r1, #CurSRValue]   ; and frequency
        STR     lr, [r1, #CurSRIndex]   ; and index of frequency
        MOV     r6, r0                  ; remember for later
        LDRB    r0, [r10, #Flags]
        LDR     r1, [sp, #4]            ; get back current/new samples per buffer
        BL      process_oversample      ; go set up to do oversampling iff we can
        STRB    r0, [r10, #Flags]       ; store back possibly updated flags
        STRB    r3, [r10, #VIDCSFR_N]   ; store for prog'ing under IRQ

        ; Trigger any SoundConfigChanging service call
        ; This relies on Sound0Config updating BuffLen after WorkOutVIDCParams
        LDR     r5, [r10, #Config]
        MOV     r5, r5, LSL #16
        CMP     r4, r6
        CMPEQ   r1, r5, LSR #16
        EXIT    EQ
        MOV     r4, r2                  ; Preserve R2 over call
        MOV     r0, #Service_SoundConfigChanging
        MOV     r2, r6 ; New sample rate
        MOV     r3, r1 ; New buffer size
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall
        MOV     r2, r4
        CLRV
        EXIT

; process_oversample
; in:  r0 = flags value
;      r1 = samples per buffer
;      r2 = user-visible period
;      r3 = unadjusted SFR value, for non-oversampling case
;      r10 = SoundLevel0Base
; out: r0 = new flags value reflecting oversampling state
;      r1 unchanged
;      r2 unchanged
;      r3 = unadjusted SFR for normal or oversampling as required
process_oversample Entry "r1,r2"
        Debug   sw,"process_oversample, default off"
        BIC     r0, r0, #DoOversample   ; clear out o/s active flag, assuming not possible
        AND     lr, r0, #Lin16Bits      ; check that...
        CMP     lr, #L16_mulaw          ;  (not in mu-law mode
        CMPNE   lr, #L16_master         ;   && not in master mode
        TSTNE   r0, #OversampleFlag     ;   && auto oversample flag is set)
        EXIT    EQ                      ; else return - can't oversample
        CMP     r2, #MinOSPeriod        ; check sample period value against oversample limit
        EXIT    LT                      ; if too small (f too high), can't oversample
        TST     r3, #1                  ; is final period odd?
        EXIT    NE                      ; can't oversample if so
        ; check buffer size: may be too big to handle double-length (4KB max)
        CMP     r1, #SoundDMABufferSize/8 ; check against size limit at Fs*2
        EXIT    HI                      ; don't oversample if gets too big
        ; OK, set up for oversampling....
        Debug   sw,"oversampling on"
        MOV     r3, r3, LSR #1          ; divide final period by 2 to generate Fs*2.
        ORR     r0, r0, #DoOversample   ; and inform IRQ level through flags
        EXIT

 | ; Non-VIDC20 machine

        Push    "r0-r1,lr"

        BICS    r0, r2, #&FF            ; see if number out of range 0..255
        MOVNE   r2, #&FF                ; if >=255 (or -ve) then use 255
        MOVMI   r2, #&03                ; if -ve then use 3

 [ VarSndClock
        LDRB    r0, [r10, #VIDCMultiplier]
        MUL     r0, r2, r0              ; scale for VIDC clock rate
        MOV     r1, #6                  ; divide by nominal value (24MHz)
        BL      Divide
 ]
        LDR     r0, [sp, #0*4]          ; get log2(NChannels) back
        MOV     r2, r2, LSR r0          ; scale for NChannels
        CMP     r2, #&FF                ; if > 255
        MOVHI   r2, #&FF                ; then use 255
        CMP     r2, #&03                ; if < 3
        MOVLO   r2, #&03                ; then use 3

; now update the required VIDCSFR to be this value

        STRB    r1, [r10, #VIDCSFR_N]   ; record the value for prog'ing
        MOV     r2, r2, LSL r0          ; compute inter-sample period for one channel

 [ VarSndClock
; now need to reverse engineer the real period, depending on sound clock
        MOV     r0, #6                  ; work out (n*6)/vm
        MUL     r0, r2, r0
        LDRB    r1, [r10, #VIDCMultiplier]
        TEQ     r1, #0                  ; watch out for divide by zero
        MOVEQ   r1, #6
        BL      Divide
 ]

        Pull    "r0-r1,pc"
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = 0 -> leave (and return previous)
;            1 -> OFF
;          >=2 -> ON
;       r10 = SoundLevel0Base
;       IRQs disabled

; Out   r0 = previous enable state

Sound0Enable Entry "r1"

        Debug   sw,"Sound0Enable",r0

        LDR     r11, [r10, #Semaphore]
        TST     r11, #&80000000
        MOVEQ   r11, #2                 ; return ON
        MOVNE   r11, #1                 ; or OFF

        CMP     r0, #1
        BLT     %FT20                   ; [just return value]
        BGT     %FT10

; Turn OFF

 [ MEMC_Type = "IOMD"
        LDR     r0, [r10, #SoundRMA]
        LDR     r0, [r0, #BaseOfIOMD]
        LDRB    r1, [r0, #IOMD_SD0CR]   ; Get Sound 0 Control reg
        BIC     r1, r1, #IOMD_DMA_E_Bit ; Clear the Enable bit (i.e. disable it)
        STRB    r1, [r0, #IOMD_SD0CR]

        Push    "r2-r3,r8,r9"
        MOV     r9, #EntryNo_HAL_IRQDisable
        MOV     r8, #OSHW_CallHAL
        MOV     r0, #IOMD_DMASound0_DevNo
        SWI     XOS_Hardware
        Pull    "r2-r3,r8,r9"

        ; Indicate sound has stopped
        MOV     r1, #Service_Sound
        MOV     r0, #Service_SoundDisabled
        SWI     XOS_ServiceCall
05
 |
  [ MEMC_Type = "MEMC2"
        LDR     r0, =MEMC2Address+MEMC2_SATT
        MOV     r1, #(0*SATT_sdis + 0*SATT_senb + 1*SATT_srnw + 1*SATT_smsks + 0*SATT_smskf)
        STR     r1, [r0]                ; Disable Sound DMA
  |
    ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        MOV     r0, #&00000000          ; Disable Sound DMA
        MOV     r1, #&00000800
        SWI     XOS_UpdateMEMC
  ]
  ; IOC assumed if MEMC_Type != "IOMD"
        MOV     r12, #IOC
        LDRB    r14, [r12, #IOCIRQMSKB] ; Disable Sound IRQ
  [ IO_Type = "IOEB"
        BIC     r14, r14, #IOEB_sound_IRQ_bit
  |
        BIC     r14, r14, #sound_IRQ_bit
  ]
        STRB    r14, [r12, #IOCIRQMSKB]
 ]

        MOV     r14, #&80000000         ; Set semaphore
        STR     r14, [r10, #Semaphore]
 [ StorkPower
        BL      SetPower_Off            ; save power, ensure amplifiers are off (corrupts R0)
 ]
        B       %FT20


10 ; Turn ON - turning on when already damages sample rate!

        CMP     r11, #2                 ; Exit if turning on when already on
        BEQ     %FT20                   ; This is the proper place to fix
                                        ; the bug, not at the *Audio level!

15      MOV     r14, #0                 ; Clear semaphore. Common ep
        STR     r14, [r10, #Semaphore]

 [ StorkPower
        BL      SetPower_On             ; Power up now (corrupts R0)
 ]

 [ MEMC_Type = "IOMD"
        ; Indicate sound is starting
        MOV     r1, #Service_Sound
        MOV     r0, #Service_SoundEnabled
        SWI     XOS_ServiceCall

        LDR     r0, [r10, #SoundRMA]
        LDR     r12, [r0, #BaseOfIOMD]

        ; reset the channel and enable it (starts DMA on buffer A once prog'ed)
        MOV     r0, #1*IOMD_DMA_E_Bit :OR: 1*IOMD_DMA_C_Bit :OR: 0*IOMD_DMA_D_Bit :OR: 16
        STR     r0, [r12, #IOMD_SD0CR]
        LDR     r0, [r10, #Phys0]       ; set current pointer = buffer base
        STR     r0, [r12, #IOMD_SD0CURA]
        LDR     r0, [r12, #IOMD_SD0ENDA] ; pick up previous end mask value (already programmed)
        STR     r0, [r12, #IOMD_SD0ENDA] ; re-write, to start DMA
 |
  [ MEMC_Type = "MEMC2"
        LDR     r0, [r10, #Phys0]
        MOV     r1, r0, LSR #16         ; get lo 16 bits
        EOR     r0, r0, r1, LSL #16     ; get hi 16 bits

        LDR     lr, =MEMC2Address+MEMC2_SSTRT
        STMIA   lr, {r0, r1}           ; write SSTRT
        ADD     lr, lr, #MEMC2_SCUR-MEMC2_SSTRT
        STMIA   lr, {r0, r1}           ; write SCUR

        MOV     r0, #(0*SATT_sdis + 1*SATT_senb + 1*SATT_srnw + 1*SATT_smsks + 0*SATT_smskf)
        STR     r0, [lr, #MEMC2_SATT-MEMC2_SCUR]  ; Enable Sound DMA
  |
    ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        LDR     r0, [r10, #Phys0]
        MOV     r0, r0, LSR #2
        ORR     r0, r0, #&03680000
        ORR     r1, r0, #&000C0000
        STR     r0, [r0]                ; Write DAG start
        STR     r1, [r1]                ; Write DAG ptr

        MOV     r0, #&00000800          ; Enable Sound DMA
        MOV     r1, #&00000800
        SWI     XOS_UpdateMEMC
  ]
 ]

 [ MEMC_Type = "IOMD"
        Push    "r2-r3,r8-r9"
        MOV     r9, #EntryNo_HAL_IRQEnable
        MOV     r0, #IOMD_DMASound0_DevNo
        MOV     r8, #OSHW_CallHAL
        SWI     XOS_Hardware
        Pull    "r2-r3,r8-r9"
 |
        MOV     r12, #IOC
        LDRB    r14, [r12, #IOCIRQMSKB] ; Enable Sound IRQ
  [ IO_Type="IOEB"
        ORR     r14, r14, #IOEB_sound_IRQ_bit
  |
        ORR     r14, r14, #sound_IRQ_bit
  ]
        STRB    r14, [r12, #IOCIRQMSKB]
 ]

20      MOV     r0, r11                 ; Return previous enable state
        EXIT                            ; Restores ints to caller state, maybe
                                        ; get IRQ'ed here too.

; .............................................................................
; Called at RESET time
; in: r10 = SoundLevel0Base

Sound0Reenable ALTENTRY

        LDR     r11, [r10, #Semaphore]
        TST     r11, #&80000000
        EXIT    NE                      ; was OFF, stays OFF

        B       %BT15                   ; Turn it on again

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = 0 -> leave (and return previous)
;            1 -> OFF
;          >=2 -> ON
;       r10 = SoundLevel0Base
;       IRQs disabled

; Out   r0 = previous speaker state

Sound0Speaker ROUT

 [ SpkrControl
        MOV     r12, #0
        LDRB    r10, [r12, #IOCControlSoftCopy]
        TST     r10, #2_00100000        ; check output bit
        MOVEQ   r11, #2                 ; return ON
        MOVNE   r11, #1                 ;     or OFF
        BIC     r10, r10, #2_00100000
        CMP     r0, #1
        ORREQ   r10, r10, #2_00100000
        STRHSB  r10, [r12, #IOCControlSoftCopy]
        MOVHS   r12, #IOC
        STRHSB  r10, [r12, #IOCControl]

        MOV     r0, r11                 ; Return previous speaker state
 |
        MOV     r0, #2                  ; if no speaker control hardware, report ON
 ]
        MOV     pc, lr                  ; no need to preserve flags (we have a wrapper)

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0  = channel number (1-8)
;       r1  = -127 for left, 0 centre, 127 right (-128 DON'T CHANGE)
;       r10 = SoundLevel0Base
;       IRQs disabled

; Attempts to be slightly clever...
; programs at interleave factor from r0 upwards...
; note pipeline delay on NChannels...!

; Out   r0 preserved
;       r1 is stereo position allocated (-128 for none/invalid)
;       -128 indicates invalid channel

Sound0Stereo Entry "r0, r2"

        Debug   sw,"Sound0Stereo",r0,r1

        SUB     r0, r0, #1              ; 1..8 -> 0..7
        CMP     r0, #SoundPhysChannels
        MOVHS   r1, #-128
        EXIT    HS

        ADD     r2, r1, #&80            ; add new offset
        LDRB    r14, [r10, #NChannels]
        AND     r14, r14, #3            ; get rid of extra flag bits
        MOV     r11, #1
        MOV     r14, r11, LSL r14       ; convert log

        ADD     r12, r10, #Images
        LDRB    r1, [r12, r0]           ; current pos
        SUB     r1, r1, #&80            ; map back to -127..+127

        CMP     r2, #0
        CMPNE   r2, #&100               ; force range
        EXIT    HS

        ADD     r11, r12, #8            ; end
        ADD     r12, r12, r0            ; base channel
05      STRB    r2, [r12], r14          ; store new pos
        CMP     r12, r11
        BLT     %BT05

        ADD     r0, r10, #Images        ; address full-size image set
        BL      ConvImages              ; produce compacted form...
        STR     r0, [r10, #ImagesC_N]   ; for programming on appropriate IRQ
        EXIT                            ; go back to caller

 [ VIDC_Type = "VIDC20"

; Sound0Mode - implements Sound_Mode SWI
;
; In:
;
;   R0: function code
;     = 0: read current mode, returning information in r0/r1.  This code must
;          be used first, to determine the availability of other functions.
;     = 1: set/clear oversampling mode, returning previous state (0 or 1)
;          R1 = 0: disable linear 2x oversampling
;          R1 <> 0: enable linear 2x oversampling
;     = 2: (NOT YET IMPLEMENTED) set external sound clock handler
;          function (for format/status value 3)
;          R1 = external sound clock handler address, or 0 to cancel
;     = 3: set/clear mono flag, returning previous state (0 or 1)
;          R1 = 0: stereo mode
;          R1 <> 0: mono mode (convert stereo to mono for output)
;     other function code values not defined
;
;   R10 = SoundLevel0Base
;   IRQs disabled
;
; Out:
;  For function code 0:
;       R0      = 0: mu-law sound system only; SWIs Sound_LinearHandler and
;                    Sound_SampleRate, and all other functions of Sound_Mode, are
;                    not supported.  Contents of r1 are unchanged.
;       R0      = 1: 16-bit capable sound system: SWIs Sound_LinearHandler and
;                    Sound_SampleRate, and full Sound_Mode functionality are all
;                    available.
;
;       R1[3:0]: sound output format and clock control status (from CMOS RAM)
;               = 1: 16-bit linear output, 44k1, 22k05, 11k025 and selected original rates
;               = 2: 16-bit linear output, internal clock, selected original rates only
;               = 3: 16-bit linear output, external master clock source, custom rates only
;               = 4...15: reserved values
;       R1[4]: oversampling control
;               = 0: automatic linear 2x oversampling disabled
;               = 1: automatic linear 2x oversampling enabled
;       R1[5]   = 0: stereo output
;               = 1: mono conversion on output
;       R1[31:5]: reserved for expansion
;
; For all rates <= 25kHz, if auto-oversampling is on, the output data stream
; will be oversampled by 2x, by simple linear interpolation.
;
Sound0Mode      Entry   "r2"

        Debug   sw,"Sound0Mode",r0

        LDRB    r2, [r10, #Flags]
        AND     lr, r2, #Lin16Bits      ; if configured for mu-law, return 0 in r0 and r1
        CMP     lr, #L16_mulaw
        MOVEQ   r0, #0
        MOVEQ   r1, #0
        EXIT    EQ

        CMP     r0, #0
        BNE     %FT10
; Function code 0: read mode information
        MOV     r0, #1                  ; new system, 16-bit
        MOV     r1, lr, LSR #Lin16Shift ; get mode (1..3) in right place
        TST     r2, #OversampleFlag     ; check for oversampling
        ORRNE   r1, r1, #1 :SHL: 4      ; set flag if so
        TST     r2, #DoMono             ; check for mono mode
        ORRNE   r1, r1, #1 :SHL: 5      ; set flag if enabled
        EXIT

10      CMP     r0, #1
        BNE     %FT20
; Function code 1: enable/disable automatic oversampling (allows overriding CMOS value)
        LDR     r0, [r10, #Config]
        MOV     r2, r0, LSR #24
        MOV     lr, r2                  ; preserve original value
        BIC     r2, r2, #OversampleFlag ; clear o/s bit, but NOT DoOversample for now
        CMP     r1, #0                  ; check requested state
        ORRNE   r2, r2, #OversampleFlag ; set bit if required
        ANDS    r1, lr, #OversampleFlag ; get old state of flag into r1 (wrong bit pos)
        MOVNE   r1, #1                  ; if not zero, set 1, else 0 already there...
        ; Need to fix up for oversampling if now enabled.
        Push    "r1,r3"
        MOV     r1, r0, LSL #16         ; r1 = samples per buffer
        MOV     r1, r1, LSR #16
        MOV     r0, r2                  ; r0 = new flags
        LDRB    r2, [r10, #Period]      ; and user-visible sample period into r2
        LDRB    r3, [r10, #VIDCSFR_N]   ; pick up current SFR into r3
        TST     lr, #DoOversample       ; check whether O/S was in use before
        MOVNE   r3, r3, LSL #1          ; double the period if so, to give non-O/S period
        BL      process_oversample      ; determine whether to use o/s
        STRB    r0, [r10, #Flags]       ; store final flags
        STRB    r3, [r10, #VIDCSFR_N]   ; and store SFR
        Pull    "r1,r3"
        MOV     r0, #1
        EXIT

20      CMP     r0, #2
        BNE     %FT30
; FUNCTION CODE 2: NOT YET IMPLEMENTED!
        B       %FT99
30      CMP     r0, #3
        BNE     %FT40
; Function code 3: enable/disable mono-isation (allows overriding CMOS value)
        LDRB    r2, [r10, #Flags]       ; get flags byte
        MOV     lr, r2                  ; preserve original value
        CMP     r1, #0                  ; check requested state
        ORRNE   r2, r2, #DoMono         ; set bit if enabling mono conversion
        BICEQ   r2, r2, #DoMono         ; or clear bit if disabling it
        ANDS    r1, lr, #DoMono         ; get old state of flag into r1 (wrong bit pos)
        MOVNE   r1, #1                  ; if not zero, set 1, else 0 already there...
        STRB    r2, [r10, #Flags]       ; store out new flag value
        EXIT
40
99
        EXIT


; Sound0LinearHandler: implements Sound_LinearHandler SWI.
;
; In: (r0-r2 from user SWI)
;  r0 is function code:
;    r0 = 0: return current handler as {routine, param} pair in r1, r2
;         no side effects, all regs except r1, r2 preserved
;         a null handler is recorded as a routine address of 0, param of -1
;    r0 = 1: install new handler
;         r1 =  0: set null handler (initial, default state), r2 is ignored
;         r1 != 0: set r1 as routine to call, r2 as parameter value to pass
;                  to it in r0, with following call rules:
;               r0 = value specified on installation of routine (r2 here)
;               r1 = base of word-aligned buffer, to fill with 16-bit stereo
;                    data, stored as pairs of signed (2's complement) 16-bit
;                    values; each word has bits 31:16 left channel data, bits
;                    15:0 right channel data.
;               r2 = end of buffer (address of first word beyond buffer)
;               r3 = flag for initial buffer contents:
;                    0 => data in buffer is invalid and MUST be overwritten
;                    1 => data has been converted from N-channel mu-law sound
;                         system and may be either overwritten or (preferably)
;                         mixed with new data produced by routine.
;                    2 => data in buffer is all 0: if routine would generate
;                         silent output, it may simply return.
;               r4 = sample frequency at which data will be played, in Hz/1024
;                    (e.g. for 20kHz, r4 would be 20000*1024 = 20480000).
;    else (r0 = any other value): ignored (do nothing, not even error...)
;
;  r1 = as determined by value in r0
;  r2 = as determined by value in r0
;
;  r10 = SoundLevel0Base (set up locally)
;
;  IRQs are disabled
;
; Out:
;  r0 preserved
;  r1 = previous/current routine address
;  r2 = previous/current value to pass to routine
;
Sound0LinearHandler Entry "r3,r4,r5"

        Debug   sw,"Sound0LinearHandler",r0,r1,r2,r3,r4

        LDRB    r3, [r10, #Flags]
        TST     r3, #Lin16Bits
        MOVEQ   r1, #0
        MOVEQ   r2, #0
        EXIT    EQ

        LDR     r3, [r10, #SoundRMA]
        LDR     r4, [r3, #Lin16Gen]
        LDR     r5, [r3, #Lin16GenR0]
        CMP     r0, #1
        BHI     %FT10
        STREQ   r1, [r3, #Lin16Gen]     ; if r0 = 1, store new value for routine
        STREQ   r2, [r3, #Lin16GenR0]   ;            and new value for r0 param to routine
        MOVS    r1, r4                  ; set previous routine address in r1
        MOVNE   r2, r5                  ; if not null, put param to pass into r2
        MVNEQ   r2, #0                  ; else set -1 into r2
10
        EXIT                            ; and go home


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sound0SampleRate: implements Sound_SampleRate SWI.  This SWI is only
; useable when SoundDevice is configured non-0, i.e. when there is 16-bit sound output
; hardware.  Otherwise it returns 0 in r1 and r2 for all calls.
;
; In: (r0,r1 from user SWI)
;   r0 is function code:
;      0: return in r1 the total number of available sample rates, NSR.
;         Available sample rates are indexed by numbers in the range 1..NSR,
;         and increase with increasing index number.  R2 is preserved.
;      1: return in r1 the index of the current sample rate, and in r2
;         the current sample rate, measured in units of 1/1024 Hz, e.g.
;         20kHz would be 20480000;
;      2: return in r2, as value measured in 1/1024ths of Hz, the sample
;         rate defined by index given in r1 (in range 1..NSR).
;      3: select new sample rate via index in r1, in range 1..NSR; return
;         index and value of previous rate in r1 and r2 respectively.
;
;   r1 = as determined by value in r0.
;   r2 = as determined by value in r0.
;
;  r10 = SoundLevel0Base (set up locally, not from SWI)
;
;  IRQs disabled
;
; Out:
;   r0 preserved
;   r1 = index of previous/current rate, or NSR;
;   r2 = previous/current/rate, measured in 1/1024ths of Hz, or preserved (r0 = 0)
;
;
; Combined set of "selected original rates" and CD-derived rates is:
;
;  1  1   5kHz     (200usec)
;  2  2   6.25kHz  (160usec)
;  3  3   6.944kHz (144usec)
;  4  4   7.812kHz (128usec)
;  5  5   8.928kHz (112usec)
;  6  6  10.417kHz (96usec)
;     7  11.025kHz (~91 usec)  CD/4
;  7  8  11.364kHz (88usec)
;  8  9  12.5kHz   (80usec)
;  9 10  13.889kHz (72usec)
; 10 11  15.625kHz (64usec)
; 11 12  17.857kHz (56usec)
; 12 13  20.833kHz (48usec)
;    14  22.05kHz  (~45 usec)  CD/2
; 13 15  25kHz     (40usec)
; 14 16  27.778kHz (36usec)
; 15 17  31.25kHz  (32usec)
; 16 18  35.714kHz (28usec)
; 17 19  41.667kHz (24usec)
;    20  44.1kHz   (~23 usec)  CD/1
; 18 21  50kHz     (20usec)

        MACRO
$lab    vidcf   $per                    ; Original VIDC sample rate, defined by usec period
$lab    DCD     1000000*1024/$per       ; frequency derived from period
        DCB     $per                    ; period for use in Sound_Configure
        DCB     $per/4                  ; unadjusted value for SFR (no oversampling)
        DCB     3                       ; value for SCR: serial sound, int clk
        DCB     0                       ; padding so total is 8 bytes
        MEND

        MACRO
$lab    cdf     $freq, $per             ; CD-derived rate ($freq in Hz, since all integral)
$lab    DCD     $freq*1024              ; frequency value as reported by Sound_SampleRate
        DCB     $per                    ; period as reported via Sound_Configure
        DCB     4*44100/$freq           ; unadjusted value for SFR (no oversampling)
        DCB     2                       ; value for VIDC20 SCR: serial sound, ext sclk
        DCB     0                       ; padding so total is 8 bytes
        MEND

ftab    vidcf   200                     ; 1   5kHz     (200 usec)
        vidcf   160                     ; 2   6.25kHz  (160usec)
        vidcf   144                     ; 3   6.944kHz (144usec)
        vidcf   128                     ; 4   7.812kHz (128usec)
        vidcf   112                     ; 5   8.928kHz (112usec)
        vidcf   96                      ; 6  10.417kHz (96usec)
        cdf     11025, 91               ; 7  11.025kHz (~91 usec) CD/4
        vidcf   88                      ; 8  11.364kHz (88usec)
        vidcf   80                      ; 9  12.5kHz   (80usec)
        vidcf   72                      ;10  13.889kHz (72usec)
        vidcf   64                      ;11  15.625kHz (64usec)
        vidcf   56                      ;12  17.857kHz (56usec)
        vidcf   48                      ;13  20.833kHz (48usec)
        cdf     22050, 45               ;14  22.05kHz  (~45 usec) CD/2
        vidcf   40                      ;15  25kHz     (40usec)
        vidcf   36                      ;16  27.778kHz (36usec)
        vidcf   32                      ;17  31.25kHz  (32usec)
        vidcf   28                      ;18  35.714kHz (28usec)
        vidcf   24                      ;19  41.667kHz (24usec)
        cdf     44100, 23               ;20  44.1kHz   (~23 usec) CD/1
        vidcf   20                      ;21  50kHz     (20usec)

; NSR values for different sound modes.
nnsr    DCB     21, 18, 1

; map sound mode numbers onto tables of valid frequencies out of full ftab set
; mtab must be close to, but at a lower address than, the maps...
mtab    DCB     mapboth-mtab            ; L16_slave44k
        DCB     mapvidc-mtab            ; L16_slaveInt
        DCB     mapcd  -mtab            ; L16_master

mapboth DCB     21
        DCB     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21
mapvidc DCB     18
        DCB     1, 2, 3, 4, 5, 6,    8, 9, 10, 11, 12, 13,     15, 16, 17, 18, 19,     21
mapcd   DCB     1
        DCB                                                                        20

        ALIGN

Sound0SampleRate Entry "r3,r4"

        Debug   sw,"Sound0SampleRate",r0,r1,r2

        LDRB    r3, [r10, #Flags]
        AND     r3, r3, #Lin16Bits
        CMP     r3, #L16_mulaw          ; if in old sound world (not 16-bit), return 0s always
        MOVEQ   r1, #0
        MOVEQ   r2, #0
        EXIT    EQ

        MOV     r3, r3, LSR #Lin16Shift ; get sound mode bits at bottom of r3, so 1..3
        CMP     r0, #0                  ; check function code
        BNE     %FT10

; Function code 0: read NSR (as configured at module init or via clock handler)
        LDR     r1, [r10, #SoundRMA]
        LDR     r1, [r1, #NSR]
        EXIT

10      CMP     r0, #1
        BNE     %FT20
; Function code 1: read current sample rate index and sample rate
        LDR     r1, [r10, #SoundRMA]
        LDR     r2, [r1, #CurSRValue]
        LDR     r1, [r1, #CurSRIndex]
        EXIT

20      CMP     r0, #2
        BNE     %FT30
; Function code 2: return in r2 the sample rate for specified index in r1
        BL      SR_maptab               ; go get address of freq table entry
        CMP     r2, #0                  ; check for error
        BEQ     SR_badpar               ; handle error if any
        LDR     r2, [r2, #0]            ; pick up frequency (1st word in entry)
        EXIT                           ; all done!

30      CMP     r0, #3
        BNE     %FT40
; Function code 3: set sample rate as specified by index in r1
        BL      SR_maptab               ; get address of relevant main table entry
        MOVS    r4, r2                  ; move pointer, check for error (=0)
        BEQ     SR_badpar               ; handle error if any
        Push    "r1"                    ; save new index
        LDRB    r2, [r4, #4]            ; get nominal period from table entry
        STRB    r2, [r10, #Period]      ; store away for Sound_Configure calls
        LDRB    r3, [r4, #5]            ; get SFR w/o oversampling
        LDR     r1, [r10, #Config]
        MOV     r0, r1, LSR #24         ; r0 = current flags
        MOV     r1, r1, LSL #16
        MOV     r1, r1, LSR #16         ; r1 = samples per buffer
        BL      process_oversample      ; work out whether o/s needed, fix SFR if so
        STRB    r3, [r10, #VIDCSFR_N]   ; store SFR for later programming
        STRB    r0, [r10, #Flags]       ; and update flags
        LDRB    r3, [r4, #6]            ; get SCR value from table entry
        STRB    r3, [r10, #VIDCSCR_N]   ; store for prog'ing under IRQ
        Pull    "lr"                    ; recover new index, into lr this time
        LDR     r3, [r10, #SoundRMA]    ; address 16-bit system variables
        LDR     r1, [r3, #CurSRIndex]   ; get previous samplerate index for return to user
        LDR     r2, [r3, #CurSRValue]   ; get previous samplerate value for return to user
        STR     lr, [r3, #CurSRIndex]   ; save off new Sample Rate index
        LDR     lr, [r4, #0]            ; pick up frequency value from table entry
        STR     lr, [r3, #CurSRValue]   ; and save that too
        ; Trigger Service_SoundConfigChanging if necessary
        MOV     r0, #3
        CMP     r2, lr
        EXIT    EQ
        Push    "r0-r2"
        MOV     r0, #Service_SoundConfigChanging
        LDR     r3, [r10, #Config]
        MOV     r1, #Service_Sound
        MOV     r3, r3, LSL #16
        MOV     r2, lr
        MOV     r3, r3, LSR #16
        SWI     XOS_ServiceCall
        CLRV     
        Pull    "r0-r2,$Proc_RegList,pc" ; all done

40                                      ; function code not 0..3: complain
SR_badpar
        ADR     r0, badparblock
        MOV     r1, #0
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        PullEnv
        MOV     pc, lr                  ; SWI will always set V

badparblock
        DCD     ErrorNumber_BadParameters
        DCB     "BadParm",0
        ALIGN

; SR_maptab: subroutine to convert r1 SR index to address of relevant
; entry in ftab, in r2.  Assumes r3 contains configured sound mode (1..3).
; Corrupts r3 and r4; r1 is always preserved; r2 is set to 0 on error.
SR_maptab
        ADRL    r4, mtab-1              ; address map table (0-equiv entry)
        LDRB    r3, [r4, r3]            ; pick up table offset
        ADD     r3, r4, r3              ; convert to address of relevant map, -1
        LDRB    r4, [r3, #1]!           ; get index range (entry 0 in map)
        SUB     r1, r1, #1              ; reduce index to 0-based range
        CMP     r1, r4                  ; check against limit (unsigned)
        ADD     r1, r1, #1              ; put index back again always
        MOVHS   r2, #0                  ; if out of range, mark error
        MOVHS   pc, lr                  ; and return
        LDRB    r2, [r3, r1]            ; get index into main freq table
        ADR     r3, ftab-8              ; address main table 0th entry
        ADD     r2, r3, r2, LSL #3      ; index into main table (8 bytes each)
        MOV     pc, lr                  ; return


  ]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sound0ReadSysInfo: implements Sound_ReadSysInfo SWI.
;
; In:
;   r0 = reason code
;        1 -> return SoundDMA features
;
; Out:
;   r0 = 0
;   r1 = flags:
;        bit 0: Service_SoundRateChanging, Service_SoundEnabled, Service_SoundDisabled generated
Sound0ReadSysInfo

        Debug   sw,"Sound0ReadSysInfo",r0

        CMP     r0, #Sound_RSI_Features
        MOVEQ   r0, #0
      [ (MEMC_Type = "IOMD") :LAND: (VIDC_Type = "VIDC20")
        MOVEQ   r1, #Sound_RSI_Feature_Service8910
      |
        MOVEQ   r1, #0 ; New services not (yet) implemented for old machines
      ]
        MOV     pc, lr


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Initialise_Module Entry "r7, r8, r10, r11"

        LDR     r2, [r12]
        TEQ     r2, #0
        BNE     %FT00

        MOV     r3, #WorkSpaceSize
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS

        STR     r2, [r12]
00
        LDR     r10, =SoundLevel0Base
        STR     r2, [r10, #SoundRMA]    ; keep separate record of RMA area base
        MOV     r0, #0
        STR     r0, [r2, #MessageFile_Open]
 [ VIDC_Type = "VIDC20"
        STR     r0, [r2, #Lin16Gen]     ; No 16-bit handler
        STR     r0, [r2, #Lin16GenR0]
        STR     r0, [r2, #SavedSample]  ; 0 previous value for interpolation
        STR     r0, [r2, #CurSRIndex]   ;
        STR     r0, [r2, #CurSRValue]   ;
 ]
        MOV     r0, #9

        MOV     r1, #3:SHL:8            ; VIDC20 controller address
        SWI     XOS_Memory
        MOVVS   r4, #0
        MOVVC   r4, r1

        MOV     r1, #4:SHL:8            ; IOMD (SSpace) controller address
        SWI     XOS_Memory
        MOVVS   r5, #0
        MOVVC   r5, r1

        CMP     r4, #0
        CMPNE   r5, #0
        BNE     %FT10                   ; Got both chips
        ADR     r0, ErrorBlock_NoSoundDevices
        BL      CopyError
        EXIT    VS

        MakeInternatErrorBlock NoSoundDevices,,M04
10
        STR     r4, [r2, #BaseOfVIDC]
        STR     r5, [r2, #BaseOfIOMD]

 [ StorkPower
        BL      GetPower                        ;
        BL      SetPower_On                     ; SetPower_On to call XPortable_Control (corrupts R0)
 ]
        BL      InitResetCommon
        EXIT    VS                      ; [going nowhere if this fails]

; Get physical address of sound buffer 0.  This is fixed at a single
; value on both MEMC1 and MEMC2 systems, but variable (obtained via new
; SWI) on IOMD systems.  The logical address is fixed (at &01F06000) on
; all systems.

 [ MEMC_Type = "IOMD"
        LDR     r2, =SoundDMABuffers    ; fixed logical address of 2 soundbuffers
        SUB     sp, sp, #12             ; get temp space for a single-entry Page Block
        STR     r2, [sp, #1*4]          ; write addr into l.a. slot of page block
        MOV     r1, sp                  ; point at Page Block as SWI arg
        MOV     r2, #1                  ; 1 entry to update
        MOV     r0, #&2200              ; convert log address to phys address
        SWI     XOS_Memory              ; go do the conversion
        LDR     r1, [sp, #2*4]          ; pick up physical address into R1
        ADD     sp, sp, #12             ; release temp space
        EXIT    VS                      ; ought never to fail!
 |
        LDR     r1, =SoundPhysBuffers   ; get fixed physical address in R1
 ]
        MOV     r0, #0                  ; Semaphore ON (so reenable wakens it)
        ADRL    r2, ProtoS0S            ; address sound0segment prototype
        LDMIA   r2, {r2,r3,r4,r5,r6,r7,r8} ; load it up (from Buff0 onwards)
        STMIA   r10, {r0-r8}            ; Set up Sound0Segment, first 9 words

        ADD     r0, r10, #Images        ; address user-level image positions
        BL      ConvImages              ; convert to compact version for prog'ing
        STR     r0, [r10, #ImagesC_N]   ; compacted form, into top of pipeline
        STR     r0, [r10, #ImagesC_H]   ; and for next buffer

 [ VIDC_Type <> "VIDC20"
        LDR     r0, [r10, #ImagesC_H]   ; program default SIR setting into hardware
        STR     r0, [r10, #ImagesC_C]   ; mark as current set
        BL      ProgramImages           ; program them now not later
 |
        ; go fetch 16-bit sound control info from CMOS
        MOV     r0, #OsByte_ReadCMOS
        MOV     r1, #PrintSoundCMOS     ; get extended (VIDC20) sound bits
        SWI     XOS_Byte                ; "won't" fail

; R2 is byte from CMOS
; bit 7 is quality bit (do interpolation to maximise quality)
; bit 6:5  form 16-bit sound control value. From Hdr:CMOS --
;
; Bit  5,6 = 16-Bit sound control, on VIDC20 machines including Risc PC.
;              0: no 16-bit sound output, use standard mu-law (default)
;              1: DAC clock is slave: 11.2896MHz ext clock: standard VIDC20 rates or
;                  44.1 KHz * 4/(4..45) can be used (as on ESP sound card).
;              2: DAC clock is slave: no ext clock: standard VIDC20 rates only
;              3: DAC clock is master: ext clock must be used for 16-bit sound
;                 (suitable sound clock driver must be installed)
        MOV     r2, r2, LSR #5-Lin16Shift ; shift right to bit position in Flags byte
        AND     r2, r2, #Lin16Bits+OversampleFlag ; extract the three applicable bits
        ORR     r4, r4, r2, LSL #24     ; set new flag bits in place
        STR     r4, [r10, #Config]      ; and store config, with them in
        TST     r2, #Lin16Bits          ; check for 16-bit mode bits being 0
        BNE     %FT20                   ; if not, go handle software conv code compilation
                                        ; else nowt special to do except...
        LDR     r0, [r10, #ImagesC_H]   ; program default SIR setting into hardware
        STR     r0, [r10, #ImagesC_C]   ; mark as current set
        BL      ProgramImages           ; program them now not later

        B       %FT30

20      MOV     r0, r4, LSR #24         ; get log2nchan + flags byte
        AND     r0, r0, #3              ; get log2nchan alone into r0
        LDR     r1, [r10, #SoundRMA]
        ADD     r1, r1, #LinConvCode    ; get address to put code
        MOV     r2, #SCSoundGain        ; set up default soundgain value
        STRB    r2, [r10, #SoundGain]
        STRB    r2, [r10, #SoundGain_C]
        LDR     r2, [r10, #ImagesC_H]   ; address stereo position set
        STR     r2, [r10, #ImagesC_C]   ; mark as current set
        STRB    r0, [r10, #Log2nchan_C] ; do same for log2nchan
        ORR     r2, r2, #SCSoundGain :SHL: 24 ; combine default soundgain into r2
        BL      compile                 ; go call compiler to set it all up
        LDR     r1, [r10, #Phys0]       ; reload physical buffer address to r1
        ; set up NSR
        LDR     r7, [r10, #SoundRMA]
        MOV     r0, r4, LSR #24 + Lin16Shift
        AND     r0, r0, #Lin16Bits :SHR: Lin16Shift
        ADRL    r6, nnsr-1
        LDRB    r6, [r6, r0]
        STR     r6, [r7, #NSR]
30
 ]
        MOV     r6, r4, LSL #16         ; build 16-bit Length (in sample times)
        MOV     r6, r6, LSR #16
        MOV     r7, r4, LSR #24         ; build LogChannel count in r7
        AND     r7, r7, #3
        MOV     r6, r6, LSL r7          ; build DAG End (i.e. length in bytes) in r6
        SUB     r6, r6, #16             ; adjust for DMA end check (hardware)

 [ MEMC_Type = "IOMD"
        ; Initialise DMA pointers
        LDR     r0, [r10, #SoundRMA]
        LDR     r0, [r0, #BaseOfIOMD]
        STR     r1, [r0, #IOMD_SD0CURA]
        STR     r6, [r0, #IOMD_SD0ENDA] ; initialise buffer A
        STR     r1, [r0, #IOMD_SD0CURB]
        STR     r6, [r0, #IOMD_SD0ENDB] ; and buffer B, to same range!
 |
  [ MEMC_Type = "MEMC2"
        ADD     r0, r1, r6              ; r1 = start, r0 = end
        MOV     r3, r1, LSR #16         ; r3 = start hi
        EOR     r1, r1, r3, LSL #16     ; r1 = start lo
        MOV     r2, r0, LSR #16         ; r2 = end hi
        EOR     r0, r0, r2, LSL #16     ; r0 = end lo

        LDR     r5, =MEMC2Address+MEMC2_SSTRT
        ADD     r6, r5, #MEMC2_SENDN-MEMC2_SSTRT
        ADD     r14, r5, #MEMC2_SCUR-MEMC2_SSTRT

        STMIA   r6, {r0, r2}            ; write SENDN
        STMIA   r5, {r1, r3}            ; write SSTRT
        STMIA   r14, {r1, r3}           ; write SCUR
        STMIA   r6, {r0, r2}            ; write SENDN
        STMIA   r5, {r1, r3}            ; write SSTRT
  |
    ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        LDR     r2, =SoundPhysBuffers :SHR: 2 ; Set DMA constants
        ORR     r2, r2, #&03680000      ; r2 will be DAG start
        ORR     r1, r2, #&00020000      ; r1 will be DAG end
        ORR     r0, r2, #&00040000      ; r0 will be DAG ptr

        ADD     r1, r1, r6, LSR #2

        STR     r1, [r1]                ; write DAG end
        STR     r2, [r2]                ; write DAG start
        STR     r0, [r0]                ; and DAG ptr -> SWAP: now ...
        STR     r1, [r1]                ; write DAG end
        STR     r2, [r2]                ; write DAG start
        STR     r0, [r0]                ; and DAG ptr
  ]
 ]

        MOV     r0, r7                  ; r0:= log2(channels)
        MOV     r1, r4, LSL #16         ; r1 = samples per buffer
        MOV     r1, r1, LSR #16
        MOV     r2, r4, LSR #16         ; 8-bit period
        AND     r2, r2, #&FF
        BL      WorkOutVIDCParams

        ; Set VIDC sample rate now, not later
        LDRB    r0, [r10, #VIDCSFR_N]   ; pick up computed value
        STRB    r0, [r10, #VIDCSFR_H]   ; store in next pipeline slot also
        SUB     r2, r0, #2              ; adjust for programming (want N, write N-2)
        ORR     r2, r2, #SFR            ; merge in register address
 [ VIDC_Type <> "VIDC20"
        ORR     r2, r2, #&100           ; ensure NTest bit set -> not Test
 ]
        LDR     r1, [r10, #SoundRMA]
        LDR     r1, [r1, #BaseOfVIDC]
        STR     r2, [r1]                ; and program into VIDC
        STRB    r0, [r10, #VIDCSFR_C]   ; store as current hardware value

 [ VIDC_Type = "VIDC20"
        ; Set up VIDC20's Sound Control Register in the same way
        LDRB    r0, [r10, #VIDCSCR_N]
        STRB    r0, [r10, #VIDCSCR_H]   ; copy into pipeline now
        ORR     r2, r0, #SCR            ; construct reg + value combination
        STR     r2, [r1]                ; and program it
        STRB    r0, [r10, #VIDCSCR_C]   ; and record as current value
 ]

        WritePSRc I_bit :OR: SVC_mode,lr; IRQ off please
        BL      Sound0Reenable          ; Turn on system
        WritePSRc SVC_mode, lr          ; Reenabled IRQs

        MOV     r0, #Service_SoundLevel0Alive
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;Ursula format
;
       ASSERT   Service_Reset      < Service_ModeChange
       ASSERT   Service_ModeChange < Service_Portable
;
UServTab
        DCD     0
        DCD     UService - Module_BaseAddr
        DCD     Service_Reset
  [ VarSndClock
        DCD     Service_ModeChange
  ]
  [ StorkPower
        DCD     Service_Portable
  ]
        DCD     0
        DCD     UServTab - Module_BaseAddr
Intercept_Services ROUT
        MOV     r0,r0
        TEQ     r1,#Service_Reset
  [ StorkPower
        TEQNE   r1,#Service_Portable
  ]
  [ VarSndClock
        TEQNE   r1,#Service_ModeChange
  ]
        MOVNE   PC,LR
UService
 [ StorkPower
        CMP     r1, #Service_Portable
        BEQ     %FT30
 ]
 [ VarSndClock
        CMP     r1, #Service_ModeChange         ; EQ, CS if this
        TEQNE   r1, #(Service_Reset :SHL: 2), 2 ; EQ, CC if that
        MOVNE   pc, lr
        BCS     ModeChangeCode
 |
        CMP     r1, #Service_Reset
        MOVNE   pc, lr
 ]

        Entry   "r0-r4, r10, r11"

; Fix MED-02859 - only call InitResetCommon if it's a soft reset.
; Otherwise we'll try to put ourselves on twice, and there's a window
; during which Sound DMA is enabled and the kernel has temporarily removed
; all device handlers.

        MOV     r0, #OsByte_RW_LastResetType
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #0
        EXIT    NE

        LDR     r10, =SoundLevel0Base
        BL      InitResetCommon
        EXIT    VS                      ; Can't raise error from service

        SavePSR r14
        Push    r14
        WritePSRc I_bit :OR: SVC_mode, r11 ; IRQ off please
        BL      Sound0Reenable          ; Turn on system/keep it off
 [ VarSndClock
        BL      ModeChangeCode          ; recache VIDCMultiplier + VIDCSFR
 ]
        WritePSRc I_bit :OR: SVC_mode, r11 ; restore SVC mode/IRQ off in case
        Pull    r14
        RestPSR r14
        EXIT                            ; Restore caller's IRQ state

 [ VarSndClock
ModeChangeCode
        Entry   "r0-r4, r10"
        LDR     r10, =SoundLevel0Base
        BL      SetupVIDCMultiplier
        MOV     r0, #0                  ; issue a Sound_Configure SWI
        MOV     r1, #0                  ; without altering any parameters
        MOV     r2, #0                  ; this will cause VIDCSFR to be
        MOV     r3, #0                  ; recalculated, and an update requested
        MOV     r4, #0                  ; from the low level code
        SWI     XSound_Configure
        CLRV
        EXIT
 ]

 [ StorkPower
30
        TEQ     r2, #ServicePortable_PowerDown
        BNE     %FT35

        Push    "r0,r10,r11,lr"
        LDR     r10, =SoundLevel0Base
        LDR     r11, [r10, #SoundRMA]

        MOV     lr, #1
        STR     lr, [r11, #portable_present]    ; indicate portable module present
        TST     r3, #SoundPowerBits             ; are they trying to power down the sound system
        Pull    "r0,r10,r11,pc",EQ              ; no then just pass on the service

        LDR     r0, [r10, #Semaphore]           ;Its OK to power down if sound IRQ's are off or
        TST     r0, #&80000000                  ; sound is quiet
        BNE     %FT32                           ;NE, sound system off
;
; Sound system on, so prevent powerdown
;
        BICS    r3, r3, #SoundPowerBits         ; by clearing the sound bits
        MOVEQ   r1, #0                          ; and if there are no more bits being turned off
        Pull    "r0,r10,r11,pc"                 ; then claim service to save time
32
        LDR     r0, [r11, #power_state]         ; update our record of which bits are on
        BIC     r0, r0, r3
        STR     r0, [r11, #power_state]
        Pull    "r0,r10,r11,pc"

35
        TEQ     r2, #ServicePortable_PowerUp    ; bits being powered up
        MOVNE   pc, lr

        Push    "r0,r10,r11,lr"
        LDR     r10, =SoundLevel0Base
        LDR     r11, [r10, #SoundRMA]
        MOV     lr, #1
        STR     lr, [r11, #portable_present]    ; indicate portable module present
        AND     lr, r3, #SoundPowerBits         ; just get sound bits which are being powered up
        LDR     r0, [r11, #power_state]
        ORR     r0, r0, lr                      ; and or them into our current state
        STR     r0, [r11, #power_state]
        Pull    "r0,r10,r11,pc"
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r4 trashable <---- NB.
;       r10 = SoundLevel0Base

; Out   VC: ok
;       VS: r0 -> error block

InitResetCommon Entry

        LDR     r4, =SoundDMABuffers    ; Clear out entire DMA buffers
        ADD     r14, r4, #SoundDMABufferSize * 2
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
50      STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        CMP     r4, r14
        BLT     %BT50

 [ VarSndClock
        BL      SetupVIDCMultiplier
 ]

; Claim vector to field the interrupts on

        ADR     r1, Module_VectorCode
        MOV     r2, r10                 ; R12 value to be passed in

 [ MEMC_Type = "IOMD"
        MOV     r0, #IOMD_DMASound0_DevNo
        SWI     XOS_ClaimDeviceVector
 |
        MOV     r0, #Sound_DevNo
        SWI     XOS_ClaimDeviceVector
 ]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable, r10 = fatality indication

Finalise_Module Entry "r10, r11"

        LDR     r12, [r12]              ; Get wp for messagefile info
        LDR     r0, [r12, #MessageFile_Open]
        CMP     r0, #0
        ADDNE   r0, r12, #MessageFile_Block
        SWINE   XMessageTrans_CloseFile

        LDR     r10, =SoundLevel0Base

        MOV     r0, #Service_SoundLevel0Dying
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall         ; Can't stop me!

        PHPSEI  r14, r0
        Push    "r14"
        MOV     r0, #1                  ; Turn off system - can't SWI anymore
        BL      Sound0Enable
        Pull    "r14"
        PLP     r14                     ; Reenable IRQs

; release the irq handler

        ADR     r1, Module_VectorCode
        MOV     r2, r10

 [ MEMC_Type = "IOMD"
        MOV     r0, #IOMD_DMASound0_DevNo
        SWI     XOS_ReleaseDeviceVector                 ; release device vector
 |
        MOV     r0, #Sound_DevNo
        SWI     XOS_ReleaseDeviceVector                 ; release device vector
 ]
        CLRV
        EXIT                            ; Don't refuse to die


 [ VarSndClock
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       SetupVIDCMultiplier - Set up VIDC multiplier - for use
;       on systems where sound clock frequency is affected by
;       changes in video clock frequency (incl. any with VIDC1/1a).
;
; in:   wp -> Sound0 workspace
;       r10 = SoundLevel0Base
; out:  r0-r2 corrupted
;

SetupVIDCMultiplier Entry
        ADR     r0, RVVTab              ; point at table
        LDR     r2, =24000              ; default rate
        Push    r2                      ; push on stack
        MOV     r1, r13                 ; r1 -> object block
        SWI     XOS_ReadVduVariables    ; if SWI not known, will leave default
        Pull    r0
        TEQ     r0, #0                  ; 0 => variable not known
        MOVEQ   r0, r2                  ; so use default

        LDR     r1, =4000               ; now divide by 4000 to get VIDC clock
        BL      Divide                  ; in units of 4MHz
        STRB    r2, [r10, #VIDCMultiplier] ; and save it away
        EXIT

RVVTab
        &       VduExt_VIDCClockSpeed
        &       -1

 ]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Divide - r2 := r0 DIV r1  -
;
; This is needed when base sound clock rate varies (with video clock), and
; when computing period from frequency or vice versa.
;

Divide  Entry
        DivRem  r2, r0, r1, r14
        EXIT
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Interrupt Service Routine
        OPT     OptPage

Module_VectorCode ROUT

        Push    "r11, lr"               ; Never entered except when SIRQ
                                        ; Below code expects stacked return pc
        MSR     CPSR_c, #I32_bit+SVC32_mode
        Push    "lr"
        MSR     CPSR_c, #I32_bit+IRQ32_mode
; IFF semaphore is zero then r13 = system IRQ stack pointer
; ELSE re-entrant SIRQ indicating buffer filling STILL IN PROGRESS!
; r11     work register
; r12     SoundLevel0Base
; r13     IRQ stack (must be FD)
; r14     work register

        MOV     r14, wp                 ; =SoundLevel0Base
        LDR     r12, [r14, #Semaphore]  ; semaphore
        CMP     r12, #0
        BEQ     %FT40                   ; do Level0Swap

; Level0Overrun - can't break general IRQ thread; other handlers reenable IRQ.

        Push    "r0-r10"

; Program MEMC such that next buffer = this buffer

        LDMIB   r14, {r5-r11}           ; Sound0Segment params, skip semaphore
;;;        STR     r6, [r14, #Buff1]       ; DON'T Swap for next time
;;;        STR     r7, [r14, #Buff0]
        MOV     r12, r7                 ; r7 = old start
                                        ; r6 = new start
        SUBS    r0, r7, r6              ; buffer offset
        ADDPL   r5, r5, r0              ; if r7 > r6, then r5 += diff!
        MOV     r6, r8                  ; set r6 -ve for any updates

        MOV     r10, r6, LSL #16        ; 16-bit buffer length in r10
        MOV     r10, r10, LSR #16
        MOV     r11, r6, LSR #24        ; 3-bit log channel count in r11
 [ VIDC_Type = "VIDC20"
        TST     r11, #Lin16Bits         ; in 16-bit mode?
        BEQ     %FT01                   ; just use masked value if not
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
01
 ]
        AND     r11, r11, #3
        MOV     r4, r10, LSL r11        ; compute physical buffer length in r4
        BIC     r4, r4, #&F             ; must be multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer length
        SUB     r0, r4, #16             ; compute DMA end

 [ MEMC_Type = "IOMD"

        ; Can set end field to (length of buffer - 16), already
        ; computed in r0, since we know - or at least, we assume! -
        ; that buffers always start on a page boundary, and hence the
        ; end has the same page-relative alignment as the length.
        ; Note: we never need to set the S bit, since we assume
        ; continuous operation and never pre-program sound DMA to stop
        ; at some future point; if we are told to stop we do so
        ; immediately by clearing the enable bit.  Nor do we ever set
        ; the L bit, since we assume sane buffer lengths, i.e. much
        ; more than 16 bytes/buffer.

        ; Now work out which buffer set to program, by checking status
        ; of DMA channel hardware.  If hardware status shows A, update
        ; B and vice versa, unless overrun has occured in which case
        ; we update the same one hardware is now on (since it has now
        ; stopped on that buffer waiting to know what to do, and must
        ; have that same buffer programmed next).  When the A/B bit is
        ; zero, the hardware is on A, when one it is on B.

        LDR     r2, [r14, #SoundRMA]
        LDR     r2, [r2, #BaseOfIOMD]
        LDRB    r1, [r2, #IOMD_SD0ST]   ; get status of channel

        TST     r1, #IOMD_DMA_O_Bit     ; invert sense of A/B bit if O bit is set
        EORNE   r1, r1, #IOMD_DMA_B_Bit ; ....

        TST     r1, #IOMD_DMA_B_Bit     ; work out whether to write to A or B

        STRNE   r5, [r2, #IOMD_SD0CURA] ; if Z clear, update CURA reg
        STRNE   r0, [r2, #IOMD_SD0ENDA] ;   and also end reg, to make it valid
        STREQ   r5, [r2, #IOMD_SD0CURB] ; else update CURB reg
        STREQ   r0, [r2, #IOMD_SD0ENDB] ;   and also end reg, to make it valid

        ; Now check that it worked - if overrun happens between
        ; reading the status and writing the end register, the
        ; interrupt will still be there and O will be set, and we need
        ; to re-write the other register pair with the *same* values
        ; (cannot allow to just exit from interrupt service and catch
        ; on next IRQ since wrong buffers would then be used,
        ; resulting in an audible glitch if sound were playing at the
        ; time).

        ; BIG ASSUMPTION (but a very reasonable one): only a small
        ; amount of real time - certainly less than a buffer period -
        ; can have passed between the STR to the relevant end register
        ; above, and re-loading the status register now.  Since only
        ; FIQs can have got in (IRQs are disabled), we expect that
        ; this requirement will hold.  The only problem would be if
        ; FIQs started occuring after the STR and continued without
        ; pause for a whole buffer time: that seems highly unlikely.

        LDRB    r3, [r2, #IOMD_SD0ST]
        TST     r3, #IOMD_DMA_O_Bit     ; now in overrun?
        BEQ     %FT10                   ; branch if OK

        ; Here, use other buffer in channel, so if we programmed A
        ; above do B now, and vice versa
        TST     r1, #IOMD_DMA_B_Bit     ; same test as above, but
                                        ; reverse execution conditions below
        STREQ   r5, [r2, #IOMD_SD0CURA] ; if Z set, update CURA reg
        STREQ   r0, [r2, #IOMD_SD0ENDA] ;   and also end reg, to make it valid
        STRNE   r5, [r2, #IOMD_SD0CURB] ; else update CURB reg
        STRNE   r0, [r2, #IOMD_SD0ENDB] ;   and also end reg, to make it valid
        ; OK, should be all clear now...
10
 |
        ; Both MEMC1 and MEMC2 need actual end (last used) address rather
        ; than just end offset value as in IOMD: compute it now
        ADD     r0, r0, r5              ; OLD END! r12
  [ MEMC_Type = "MEMC2"
        MOV     r1, r0, LSR #16         ; r1 = end hi
        EOR     r0, r0, r1, LSL #16     ; r0 = end lo
        LDR     r2, =MEMC2Address+MEMC2_SENDN
        STMIA   r2, {r0, r1}            ; write DAG end

        MOV     r1, r5, LSR #16         ; r1 = start hi
        EOR     r0, r5, r1, LSL #16     ; r0 = start lo
        ADD     r2, r2, #MEMC2_SSTRT-MEMC2_SENDN
        STMIA   r2, {r0, r1}            ; write DAG start. Clears current SIRQ
  |
    ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        MOV     r0, r0, LSR #2
        ORR     r0, r0, #&03600000
        ORR     r0, r0, #&000A0000
        STR     r0, [r0]                ; write DAG end

        MOV     r0, r5, LSR #2          ; OLD compute NEW start
        ORR     r0, r0, #&03680000
        STR     r0, [r0]                ; write DAG start. Clears current SIRQ
  ]
 ]
        MSR     CPSR_c,#I32_bit+SVC32_mode
        Pull    "lr"
        MSR     CPSR_c,#I32_bit+IRQ32_mode
        Pull    "r0-r10, r11, pc"


; Level0Swap

40      STR     sp_irq, [r14, #Semaphore] ; save IRQ stack^ in semaphore
        Push    "r0-r10"


; Level0 Go

 ASSERT Phys0     = 4  ; r5
 ASSERT Buff0     = 8  ; r6
 ASSERT Buff1     = 12 ; r7
 ASSERT Config    = 16 ; r8
 ASSERT Level1Ptr = 20 ; r9
 ASSERT Images    = 24 ; r10, r11 NB. Two words
50      LDMIB   r14, {r5-r9}            ; Sound0Segment params, skip semaphore
        STR     r6, [r14, #Buff1]       ; Swap for next time
        STR     r7, [r14, #Buff0]
        MOV     r12, r7                 ; r7 = old start
                                        ; r6 = new start
        SUBS    r0, r7, r6              ; buffer offset
        ADDPL   r5, r5, r0              ; if r7 > r6, then r5 += diff!
        MOV     r6, r8                  ; get config (incl. flags) in r6
        MOV     r0, r6, LSR #24         ; get configured log2nchan & flags
        AND     r0, r0, #3              ; mask out just current req'd log2nchan
        LDRB    r1, [r14, #Log2nchan_C] ; pick up current value in use
        CMP     r0, r1                  ; if different, mark update for Level1
        ORRNE   r6, r6, #1 :SHL: 31     ; by setting sign bit in r6
        STRNEB  r0, [r14, #Log2nchan_C] ; and also update log2nchan

 [ VIDC_Type = "VIDC20"
        LDRB    r1, [r14, #SoundGain_C] ; get current value of mu-law->linear conv gain
        LDRB    r2, [r14, #SoundGain]   ; get last-set value
        CMP     r2, r1                  ; check if different, and if so mark fact...
        ORRNE   r6, r6, #1 :SHL: 31     ; ..by setting sign bit in r6
        STRNEB  r2, [r14, #SoundGain_C] ; and also update recorded value

        ; Handle 16-bit mode conversion routine re-compile if needed.  NB we
        ; change the compiled code directly on THIS interrupt, rather than
        ; with a one-buffer delay as is applied when updating the hardware.
        ; This is because the stereo positioning is already dealt with in the
        ; data put into the buffer, rather than when the buffer is read out
        ; (after next interrupt) by the hardware.
        ; Get currently required log2nchan value + flags
        TST     r6, #Lin16Bits :SHL: 24 ; check whether in 16-bit mode
        BEQ     %FT60                   ; go do h/ware SIR update if not

        ; Check whether any stereo position value has changed.
        ; Shuffle ImagesC FIFO first, since there is no buffer delay for
        ; software stereo
        LDR     r2, [r14, #ImagesC_N]   ; get wanted value of ImagesC
        STR     r2, [r14, #ImagesC_H]   ; (force skipping of 1-buffer delay)
        LDR     r1, [r14, #ImagesC_C]   ; check current value of ImagesC
        CMP     r2, r1                  ; check for being the same
        BNE     %FT55                   ; go recompile if different

        ; No change in stereo, but check whether number of active channels has
        ; changed, => recompile needed.  This was tested above, and marked in bit
        ; 31 of r6, so it's easy to re-check.  This bit may alternatively/also
        ; indicate change of soundgain value, with same consequence.
        TST     r6, #1 :SHL: 31
        BEQ     %FT65                   ; no re-compilation needed if bit 31 clear

55      ; Compile for updated configuration/stereo position/soundgain value.
        STR     r2, [r14, #ImagesC_C]   ; record req'd ImagesC value as current
        LDRB    r1, [r14, #SoundGain_C] ; pick up newest soundgain value
        ORR     r2, r2, r1, LSL #24     ; and combine into r2
        LDR     r1, [r14, #SoundRMA]    ; address code buffer in SoundRMA workspace
        ADD     r1, r1, #LinConvCode    ; ...
        BL      compile                 ; go compile it (R0 = log2nchan)
        LDR     r14, =SoundLevel0Base   ; (reset local vars pointer after BL)
        B       %FT65                   ; skip hardware SIR programming
 ]

60 ; mu-law output. Level0 VIDC SIR reprogram if required

        LDR     r1, [r14, #ImagesC_C]   ; get currently loaded SIR set
        LDR     r0, [r14, #ImagesC_H]   ; get SIR set for this buffer-time
        CMP     r0, r1                  ; are they the same?
        BLNE    ProgramImages           ; if not, program new set
        LDR     r14, =SoundLevel0Base   ; (reset local vars pointer after possible BL)
        STR     r0, [r14, #ImagesC_C]   ; in any case, step FIFO on (r0 preserved)
        LDR     r0, [r14, #ImagesC_N]   ; ...
        STR     r0, [r14, #ImagesC_H]   ; by one, to keep everything in step

65  ; Reprogram SFR (and on VIDC20, SCR), if required

        LDRB    r1, [r14, #VIDCSFR_C]   ; get currently active SFR value
        LDRB    r0, [r14, #VIDCSFR_H]   ; compare against value to apply from now on
        CMP     r0, r1                  ; are they the same?
        SUBNE   r1, r0, #2              ; if not: adjust,
        ORRNE   r1, r1, #SFR            ;        set up with reg addr
 [ VIDC_Type <> "VIDC20"
        ORRNE   r1, r1, #&100           ;        ensure NTest bit set -> not Test
 ]
        LDR     r2, [r14, #SoundRMA]
        LDR     r2, [r2, #BaseOfVIDC]
        STRNE   r1, [r2]                ;        program new value

        STRNEB  r0, [r14, #VIDCSFR_C]   ;        and mark as current
        LDRB    r1, [r14, #VIDCSFR_N]   ; in any case, step FIFO...
        STRB    r1, [r14, #VIDCSFR_H]   ; to keep everything in sync.
        CMP     r0, r1                  ; if new value on NEXT irq, mark update for Level1 now
        ORRNE   r6, r6, #1 :SHL: 31

 [ VIDC_Type = "VIDC20"
        ; on VIDC20, do the same for the SCR
        LDRB    r1, [r14, #VIDCSCR_C]   ; get currently active SCR value
        LDRB    r0, [r14, #VIDCSCR_H]   ; compare against value to apply from now on
        CMP     r0, r1                  ; are they the same?
        ORRNE   r1, r0, #SCR            ; if not, set up and
        STRNE   r1, [r2]                ; program new value
        STRNEB  r0, [r14, #VIDCSCR_C]   ; and mark as current
        LDRB    r0, [r14, #VIDCSCR_N]   ; in any case, step FIFO...
        STRB    r0, [r14, #VIDCSCR_H]   ; to keep everything in sync.
 ]

; level0 MEMC update

70      MOV     r10, r6, LSL #16        ; 16-bit buffer length in r10
        MOV     r10, r10, LSR #16
        MOV     r11, r6, LSR #24        ; 3-bit log channel count, + flags, in r11
 [ VIDC_Type = "VIDC20"
        TST     r11, #Lin16Bits         ; in 16-bit mode?
        BEQ     %FT71                   ; just use masked value if not
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
71
 ]
        AND     r11, r11, #3
        MOV     r4, r10, LSL r11        ; compute physical buffer length in r4
        BIC     r4, r4, #&F             ; must be a multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer len
        SUB     r0, r4, #16             ; compute DMA end

 [ MEMC_Type = "IOMD"
        Push    "r1,r2,r3"

        ; Now work out which buffer set to program, by checking status
        ; of DMA channel hardware.  If hardware status shows A, update
        ; B and vice versa, unless overrun has occured in which case
        ; we update the same one hardware is now on (since it has now
        ; stopped on that buffer waiting to know what to do, and must
        ; have that same buffer programmed next).  When the A/B bit is
        ; zero, the hardware is on A, when one it is on B.

        LDR     r2, [r14, #SoundRMA]
        LDR     r2, [r2, #BaseOfIOMD]
        LDRB    r1, [r2, #IOMD_SD0ST]   ; get status of channel

        TST     r1, #IOMD_DMA_O_Bit     ; invert sense of A/B bit if O bit is set
        EORNE   r1, r1, #IOMD_DMA_B_Bit ; ....

        TST     r1, #IOMD_DMA_B_Bit     ; work out whether to write to A or B

        STRNE   r5, [r2, #IOMD_SD0CURA] ; if Z clear, update CURA
        STRNE   r0, [r2, #IOMD_SD0ENDA] ;   and ENDA: clears IRQ, lets DMA go on to A next
        STREQ   r5, [r2, #IOMD_SD0CURB] ; else update CURB
        STREQ   r0, [r2, #IOMD_SD0ENDB] ;   and ENDB: clears IRQ, lets DMA go on to B next

        ; Now check that it worked - if overrun happens between
        ; reading the status and writing the end register, the
        ; interrupt will still be there and O will be set, and we need
        ; to re-write the other register pair with the *same* values
        ; (cannot allow to just exit from interrupt service and catch
        ; on next IRQ since wrong buffers would then be used,
        ; resulting in an audible glitch if sound were playing at the
        ; time).

        ; BIG ASSUMPTION (but a very reasonable one): only a small
        ; amount of real time - certainly less than a buffer period -
        ; can have passed between the STR to the relevant end register
        ; above, and re-loading the status register now.  Since only
        ; FIQs can have got in (IRQs are disabled), we expect that
        ; this requirement will hold.  The only problem would be if
        ; FIQs started occuring after the STR and continued without
        ; pause for a whole buffer time: that seems highly unlikely.

        LDRB    r3, [r2, #IOMD_SD0ST]
        TST     r3, #IOMD_DMA_O_Bit     ; now in overrun?
        BEQ     %FT80                   ; branch if OK

        ; Here, use other buffer in channel, so if we programmed A
        ; above do B now, and vice versa
        TST     r1, #IOMD_DMA_B_Bit     ; same test as above, but
                                        ; reverse execution conditions below
        STREQ   r5, [r2, #IOMD_SD0CURA] ; if Z set, update CURA reg
        STREQ   r0, [r2, #IOMD_SD0ENDA] ;   and also end reg, to make it valid
        STRNE   r5, [r2, #IOMD_SD0CURB] ; else update CURB reg
        STRNE   r0, [r2, #IOMD_SD0ENDB] ;   and also end reg, to make it valid
        ; OK, should be all clear now...
80
        Pull    "r1,r2,r3"
 |
        ADD     r0, r0, r5              ; OLD END! r12
  [ MEMC_Type = "MEMC2"
        Push    "r1,r2"
        MOV     r1, r0, LSR #16         ; r1 = end hi
        EOR     r0, r0, r1, LSL #16     ; r0 = end lo
        LDR     r2, =MEMC2Address+MEMC2_SENDN
        STMIA   r2, {r0, r1}            ; write DAG end

        MOV     r1, r5, LSR #16         ; r1 = start hi
        EOR     r0, r5, r1, LSL #16     ; r0 = start lo
        ADD     r2, r2, #MEMC2_SSTRT-MEMC2_SENDN
        STMIA   r2, {r0, r1}            ; write DAG start. Clears current SIRQ
        Pull    "r1,r2"
  |
   ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        MOV     r0, r0, LSR #2
        ORR     r0, r0, #&03600000
        ORR     r0, r0, #&000A0000
        STR     r0, [r0]                ; write DAG end

; program START, hence enable reentrant SIRQs! (not here, but up in Level1 etc)

        MOV     r0, r5, LSR #2          ; OLD compute NEW start
        ORR     r0, r0, #&03680000
        STR     r0, [r0]                ; write DAG start. Clears current SIRQ
  ]
 ]

; Level0Updated - any events to dispatch?

        Push    "r8-r12, r14"           ; r1-r7 preserved by scheduler
        LDR     r12, =SoundLevel0Base
        LDR     r12, [r12, #Level2Ptr]
        TST     r12, #SoundSystemNIL    ; test for installed scheduler
        LDREQ   r0, [r12]
        TSTEQ   r0, #SoundSystemNIL     ; Valid Level2?
        MOVEQ   lr, pc
        MOVEQ   pc, r0                  ; Call Level2
        Pull    "r8-r12, r14"

; Level0 ready to fill

        MOV     r11, r6, LSR #24        ; get log2nchan + flags
  [ VIDC_Type = "VIDC20"
        TST     r11, #Lin16Bits         ; in 16-bit mode?
        BEQ     %FT81                   ; just use masked value if not
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
81
  ]
        AND     r11, r11, #3            ; get just log2nchan
        MOV     r10, r6, LSL #16        ; get logical buffer length/channel
        MOV     r10, r10, LSR #16       ; (16 bits worth)
        MOV     r4, r10, LSL r11        ; work out physical length into r4
        BIC     r4, r4, #&F             ; must be a multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer len
  [ VIDC_Type = "VIDC20"
        MOV     r4, r10, LSL #2         ; work out physical length into r4 (Fs*1, 16-bit)
        MOV     r11, r6, LSR #24        ; get back real log2nchan (asking for 8bit data)
        AND     r11, r11, #3
  ]
        ADD     r10, r12, r10, LSL r11  ; r10 = logical buffer end
        MOV     r0, #1                  ; convert log to buffer inc
        MOV     r11, r0, LSL r11        ; r11 = N channels

 [ VIDC_Type <> "VIDC20"

        MOV     r8, r6, LSR #16         ; get current per-channel period in r8
        AND     r8, r8, #&FF            ; for Level1 fill code
        TST     r9, #SoundSystemNIL     ; Valid Level1? Loaded only once ^^^
        MOVEQ   lr, pc                  ; Call Level1: don't change mode, flags
        LDREQ   pc, [r9, #SoundLevel1FillPtr] ; but only call if valid

 |
        ; Check whether running in 16-bit mode
        TST     r6, #Lin16Bits :SHL: 24
        BNE     %FT82                   ; branch to handle if so

        ; Old mu-law mode: call Level1 (if valid) and be done.
        MOV     r8, r6, LSR #16         ; get current per-channel period in r8
        AND     r8, r8, #&FF            ; for Level1 fill code
        TST     r9, #SoundSystemNIL     ; Valid Level1? Loaded only once ^^^
        MOVEQ   lr, pc                  ; Call Level1: don't change mode, flags
        LDREQ   pc, [r9, #SoundLevel1FillPtr]
        B       %FT99                   ; all finished with this buffer

82      ; Convert mu-law N-channel data in logical buffer to 16-bit stereo physical data

 [ EnableIRQsIn16bit
        ; SMC: Try enabling IRQs during conversion to reduce latency (must disable
        ;      sound IRQ first).
        Push    "r1-r3,r8-r9"
        MOV     r9, #EntryNo_HAL_IRQDisable
        MOV     r0, #IOMD_DMASound0_DevNo
        MOV     r8, #OSHW_CallHAL
        SWI     XOS_Hardware

  [ DisableFlybackIRQ
        ; Hack to disable flyback IRQ so that Replay still works. Timer0 is also disabled
        ; because the Hourglass module waits for a VSync from a handler sitting on TickerV
        ; (== stiff machine if Timer0 IRQ goes off while VSync IRQ is disabled).
        ;
        MOV     r9, #EntryNo_HAL_IRQDisable
        MOV     r0, #IOMD_VSync_DevNo
        MOV     r8, #OSHW_CallHAL
        SWI     XOS_Hardware
        MOV     r9, #EntryNo_HAL_IRQDisable
        MOV     r0, #IOMD_Timer0_DevNo
        MOV     r8, #OSHW_CallHAL
        SWI     XOS_Hardware
  ]

  [ DisableHardDiscIRQ
        ; Disable IDE interrupt too. Replay doesn't like this being enabled either.
        ;
        MOV     r9, #EntryNo_HAL_IRQDisable
        MOV     r0, #IOMD_IDE_DevNo
        MOV     r8, #OSHW_CallHAL
        SWI     XOS_Hardware
  ]
        Pull    "r1-r3,r8-r9"

        WritePSRc SVC_mode, r0          ; R0 corruptable.  Into SVC mode, enable IRQs
        NOP
        Push    lr                      ; Save SVC_lr.
 ]

        TST     r9, #SoundSystemNIL     ; Valid Level1? Loaded only once, above
        MOVNE   r3, #0                  ; if not, mark no valid data in physical buffer
        BNE     %FT86                   ;         and go do 16-bit handling

        Push    "r4,r6,r10,r12"         ; save off physlen, config, logend, buffstart

        WritePSRc IRQ_mode, r0          ; enable IRQs

        ; Zap the logical buffer to 0 before calling level 1 code to fill it.
        ; This is necessary for compatibility, since the standard channel
        ; handler assumes that any channel which is silent will have 0 data in
        ; its entries in the logical buffer.  But since we overwrite the
        ; logical data with 16-bit physical data after filling it, this will
        ; not hold in general.  So fill the logical buffer with all 0 now.

        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        MOV     r8, r12

        ; Zero 4*8 words = 128 bytes each loop.  Slightly overrunning the
        ; logical buffer end is not a problem, and since the physical
        ; buffers are a multiple of 128 bytes in length, we won't overrun
        ; those either.

84      STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        CMP     r8, r10
        BLO     %BT84

        WritePSRc I_bit + IRQ_mode, r0  ; IRQs off again

        ; Call Level1: don't change mode, flags

        LDR     r6, [sp, #4]            ; reload config value, including update flag r6:31
        MOV     r8, r6, LSR #16         ; get current per-channel period in r8,
        AND     r8, r8, #&FF            ; for Level1 fill code

 [ EnableIRQsIn16bit
        ; SMC: Back to IRQ mode with IRQs disabled for Level 1 fill.
        WritePSRc I_bit :OR: IRQ_mode, lr
        NOP
 ]
        MOV     lr, pc
        LDR     pc, [r9, #SoundLevel1FillPtr]

 [ EnableIRQsIn16bit
        ; SMC: Then back to SVC mode with IRQs enabled.
        WritePSRc SVC_mode, lr
        NOP
 ]

        LDMFD   sp, {r4,r6,r10,r12}    ; restore saved values. NB leave on stack: no `!'

        ; Convert mu-law to 16-bit linear data.
        ; have: physical length in r4,
        ;       logical buffer end in r10
        ;       logical buffer start in r12
        ; want: r10 and r12 as they are,
        ;       r11 = physical buffer start or end, according to logical buffer size
        ;       r9 = address of 256-entry mu-law to 16-bit conversion table
        ;       r8 = &FF for byte masking in conversion routine
        ;       r5 = &7FFF for overflow test

        TST     r6, #2 :SHL: 24         ; 4 or 8 channels in use?
        MOVNE   r11, r12                ; write 16-bit data forwards from start if so
        ADDEQ   r11, r12, r4            ; else write 16-bit data backwards from phys buff end
        ADRL    r9, convtable           ; address conversion table for routine to use
        MOV     r8, #&FF                ; set up byte mask used in routine
        ORR     r5, r8, #&7F00          ; and also mask for limit check
        LDR     r0, =SoundLevel0Base    ; address our local data
        LDR     r0, [r0, #SoundRMA]     ; go get RMA space address
        MOV     r7, #&70000003          ; put impossible 16-bit output value in r7
        MOV     lr, pc                  ; set up return address
        ADD     pc, r0, #LinConvCode    ; call conversion code

        Pull    "r4,r6,r10,r12"         ; again restore values, clearing stack this time

        CMP     r7, #&70000003          ; if impossible value still in r7, all data was 0
        MOVNE   r3, #1                  ; mark that there is valid (non-0) data in buffer
        MOVEQ   r3, #2                  ; else mark that 16-bit data in buffer is all 0

86      ; We're now dealing with a physical buffer containing 16-bit stereo
        ; data (it will still contain old data from last time, if no level 1
        ; handler is present).  Check whether there is a 16-bit sound
        ; generator/mixer, and if so, call it.  Note that r3 determines
        ; whether there is valid 16-bit data in the buffer already:
        ;
        ;     0 => old/invalid (*must* overwrite) - jumped here directly, no level 1 handler
        ;     1 => yes, valid, not all 0, but may overwrite to ignore
        ;     2 => yes, and known to be all 0, so can simply return if silent

        LDR     r0, =SoundLevel0Base
        LDR     r5, [r0, #SoundRMA]     ; address RMA workspace
        LDR     r11, [r5, #Lin16Gen]    ; pick up code address
        LDR     r0, [r5, #Lin16GenR0]   ; pick up paramter to pass it in r0
        MOV     r1, r12                 ; pass base of buffer in r1
        ADD     r2, r12, r4             ; and end of buffer in r2
        CMP     r11, #0                 ; check for valid entry, if so.....
        Push    "r1-r2"                 ; save base/limit for oversampler below
        BEQ     %FT87
        LDR     r4, [r5, #CurSRValue]   ; load up current frequency value into r4

 [ EnableIRQsIn16bit
        ; SMC: Back to IRQ mode with IRQs disabled.
        WritePSRc I_bit :OR: IRQ_mode, lr
        NOP
 ]
        MOV     lr, pc                  ; and go call
        MOV     pc, r11

 [ EnableIRQsIn16bit
        ; SMC: Then back to SVC mode with IRQs enabled.
        WritePSRc SVC_mode, lr
        NOP
 ]

87
        LDMFD   sp, {r0,r1}            ; reload (no pop) phys base & limit now

        ; Finally, perform mono mix-down and/or oversampling, if required.

        LDR     r11, =SoundLevel0Base
        LDRB    r3, [r11, #Flags]       ; now check for oversamping/mono
        ANDS    r3, r3, #DoOversample :OR: DoMono  ; isolate flags
        BEQ     BufferDone              ; nowt to do if both bits clear (r3 = 0)

        ; OK, doing some sort of filtering operation.  Set up some constants
        ; used in all cases...

        ; Set up 0x80008000 in r12, to perform signed/unsigned swap overs
        MOV     r12, #1<<15
        ORR     r12, r12, #1<<31

        ; Create 0xFFFEFFFE in r11 for masking off LSBs, to isolate LH and RH
        ; parts during parallel additions.
        MVN     r11, r12, ROR #15       ; can derive from r12 in one go!

        CMP     r3, #DoMono             ; check which proc we need to call
        BEQ     MonoOnly                ; do just mono conversion
                                        ; else doing oversampling...
        SUB     r2, r1, r0              ; determine phys length of buffer at Fs*1
        ADD     r2, r0, r2, LSL #1      ; and compute end of buffer at Fs*2
        STR     r2, [sp, #4]            ; store out for later use also
                                        ; switch to appropriate oversampling code
        ASSERT  DoMono > DoOversample
        BLT     OverOnly                ; if r3 < DoMono, only oversample
        B       MonoOver                ; if r3 > DoMono, do mono + oversample

BufferDone      ; return here after any buffer processing
        Pull    "r3,r4"                 ; pop phys base+real limit (@@Fs*2 if oversampling)
        LDR     r6, [r4, #-4]           ; pick up last sample pair from this buffer
        LDR     r11, =SoundLevel0Base   ; address sound work area
        LDR     r7, [r11, #SoundRMA]    ; address RMA area
        STR     r6, [r7, #SavedSample]  ; save sample pair for possible oversampling next time


  [ EnableIRQsIn16bit
        Pull    lr                      ; Restore SVC_lr.
        WritePSRc I_bit :OR: IRQ_mode, r0

        Push    "r1-r3,r8-r9"
        MOV     r9, #EntryNo_HAL_IRQEnable
        MOV     r8, #OSHW_CallHAL
        MOV     r0, #IOMD_DMASound0_DevNo
        SWI     XOS_Hardware            ; r8 & r9 preserved
   [ DisableHardDiscIRQ
        MOV     r0, #IOMD_IDE_DevNo
        SWI     XOS_Hardware
   ]
   [ DisableFlybackIRQ
        MOV     r0, #IOMD_VSync_DevNo
        SWI     XOS_Hardware

        MOV     r0, #IOMD_Timer0_DevNo
        SWI     XOS_Hardware
   ]
        Pull    "r1-r3,r8-r9"
  ]
 ]

99      ; All done for this IRQ

        Pull    "r0-r10"
        LDR     wp, =SoundLevel0Base
        MOV     r11, #0
        STR     r11, [wp, #Semaphore]   ; clear semaphore
        MSR     CPSR_c,#I32_bit+SVC32_mode
        Pull    "lr"
        MSR     CPSR_c,#I32_bit+IRQ32_mode
        Pull    "r11, pc"               ; Return from interrupt


; Buffer processing routines - 3 off, done as out-of-line code sequences which
; all return to "BufferDone" above....

; MonoOnly
;
;     Convert stereo into mono (in same buffer space) for use with mono sound devices
;     (e.g. TV with only mono sound input, attached to NC).
;     NB: output data is still 2x16bit/sample.
;
;   r0 = base address of current buffer
;   r1 = limit address (last+1) of source (Fs*1)
;   r2-r10 free for general use
;   r11 = 0xFFFEFFFE
;   r12 = 0x80008000
;   r14 = free for use
; On exit:
;   r0-r10,r14 corrupted

MonoOnly        ROUT
01      LDMDB   r1!, {r2,r3,r4,r5}
        ; convert from signed to unsigned format
        EOR     r2, r2, r12
        EOR     r3, r3, r12
        EOR     r4, r4, r12
        EOR     r5, r5, r12
        ; clear off LSB from each value (two in each reg)
        AND     r2, r2, r11
        AND     r3, r3, r11
        AND     r4, r4, r11
        AND     r5, r5, r11
        ; Add the left and right samples together, simultaneously in both upper and
        ; halves of each stereo pair. There will be no
        ; interference between carry out from the RHS MSB into bit 16 (LSB of
        ; LHS sample), and no carry from bit 16 into bit 17, since we cleared
        ; bit 16 in both sources (i.e. bit 16 and bit 0 of pre-rotated single source!)
        ; beforehand; therefore the subsequent right shift will correctly put the
        ; average of the two channel samples back into bits 15..0 (and also into
        ; bits 31..16, using RRX to recover carry out from bit 31).
        ; Get back to signed 16 bit result for each channel afterwards by EOR'ing
        ; with 0x80008000.
        ADDS    r2, r2, r2, ROR #16
        EOR     r2, r12, r2, RRX
        ADDS    r3, r3, r3, ROR #16
        EOR     r3, r12, r3, RRX
        ADDS    r4, r4, r4, ROR #16
        EOR     r4, r12, r4, RRX
        ADDS    r5, r5, r5, ROR #16
        EOR     r5, r12, r5, RRX
        STMIA   r1, {r2,r3,r4,r5}       ; store them all out
        CMP     r1, r0                  ; have we just done last loop?
        BNE     %B01                    ; round again if not
        B       BufferDone              ; we're all done



; OverOnly:
;     Oversample, expanding buffer by factor of 2 by performing linear interpolation
;     between each pair of samples.  For the very first case, this uses a saved copy
;     of the last stereo sample pair word (2x16-bit) from the end of the previous
;     buffer, to interpolate against.  Note that this process is done in reverse
;     order (working from end of buffer back to start) to avoid overwriting the
;     initial data as would happen if we went forwards..
OverOnly        ROUT
        LDR     r14, [r1, #-4]!         ; get last sample in source buffer now
        EOR     r14, r14, r12           ; convert signed to unsigned
        AND     r14, r14, r11           ; mask LSB bits from this sample-pair
        ADD     r0, r0, #8*4            ; need to do last group separately, so move base

01      LDMDB   r1!, {r3,r5,r7,r9}      ; load 4 new samples

02      ; convert from signed to unsigned format (into separate regs apart from r3)
        EOR     r3, r3, r12
        EOR     r6, r5, r12
        EOR     r8, r7, r12
        EOR     r10, r9, r12
        ; clear off LSB from each value (two in each reg)
        AND     r3, r3, r11
        AND     r6, r6, r11
        AND     r8, r8, r11
        AND     r10, r10, r11
        ; oversampling: average pairs and turn back to signed format
        ADDS    r4, r3, r6
        EOR     r4, r12, r4, RRX
        ADDS    r6, r6, r8
        EOR     r6, r12, r6, RRX
        ADDS    r8, r8, r10
        EOR     r8, r12, r8, RRX
        ADDS    r10, r10, r14
        EOR     r10, r12, r10, RRX
        EOR     r14, r12, r14                   ; put r14 back to signed format also
        STMDB   r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results interleaved with originals
        MOV     r14, r3                 ; set lowest sample for end of next group
        CMP     r2, r0                  ; have we just done last normal loop?
        BHI     %B01                    ; round again if not
        BLO     BufferDone              ; all done if done extra, special loop

        ; (r2==r0) for last special loop, pick up very first 3 samples from this buffer
        LDMDB   r1!, {r5,r7,r9}
        ; get last sample from previous buffer, to interpolate for first new sample of this
        LDR     r3, =SoundLevel0Base
        LDR     r3, [r3, #SoundRMA]
        LDR     r3, [r3, #SavedSample]
        B       %B02                    ; use main loop code to do it


; Convert to mono and oversample also
MonoOver        ROUT
        ADD     r0, r0, #8*4            ; need to do last group separately, so move base

        LDR     r14, [r1, #-4]!         ; get last sample in source buffer now
        EOR     r14, r14, r12           ; convert signed to unsigned
        AND     r14, r14, r11           ; mask LSB bits from this sample-pair
        ADDS    r14, r14, r14, ROR #16  ; convert to mono
        AND     r14, r11, r14, RRX

01      LDMDB   r1!, {r3,r5,r7,r9}      ; get four new samples: signed, full 16-bit, stereo

02      ; convert from signed to unsigned format
        EOR     r3, r3, r12
        EOR     r5, r5, r12
        EOR     r7, r7, r12
        EOR     r9, r9, r12
        ; clear off LSB from each value (two in each reg)
        AND     r3, r3, r11
        AND     r5, r5, r11
        AND     r7, r7, r11
        AND     r9, r9, r11
        ; Monoise unsigned masked versions of input data; since we're also oversampling,
        ; leave in unsigned form and mask off LSBs again
        ADDS    r3, r3, r3, ROR #16
        AND     r3, r11, r3, RRX
        ADDS    r5, r5, r5, ROR #16
        AND     r5, r11, r5, RRX
        ADDS    r7, r7, r7, ROR #16
        AND     r7, r11, r7, RRX
        ADDS    r9, r9, r9, ROR #16
        AND     r9, r11, r9, RRX
        ; then oversample, generating new intermediate values in r4,r6,r8,r10, in signed format
        ADDS    r4, r3, r5
        EOR     r4, r12, r4, RRX
        ADDS    r6, r5, r7
        EOR     r6, r12, r6, RRX
        ADDS    r8, r7, r9
        EOR     r8, r12, r8, RRX
        ADDS    r10, r9, r14
        EOR     r10, r12, r10, RRX
        ; must convert monoised unsigned masked originals back to signed format also
        EOR     r5, r12, r5
        EOR     r7, r7, r12
        EOR     r9, r9, r12
        EOR     r14, r12, r14           ; put r14 back to signed format also for store-out
        STMDB   r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results, interleaved with originals
        MOV     r14, r3                 ; copy lo sample (mono,still unsigned & masked) for next group
        CMP     r2, r0                  ; have we just done last normalloop?
        BHI     %B01                    ; round again if not
        BLO     BufferDone              ; return if just done extra, special loop

        ; r2==r0: finally, pick up very first 3 samples from this buffer
        LDMDB   r1!, {r5,r7,r9}
        ; and last sample from previous buffer, to interpolate for first new sample of this
        LDR     r3, =SoundLevel0Base
        LDR     r3, [r3, #SoundRMA]
        LDR     r3, [r3, #SavedSample]
        ; use main loop code to do final (earliest) 8 samples of output
        B       %B02


;
; ConvImages
;
; Passed in a pointer in r0 to 8 bytes (Images), returns in r0 a word
; having bits 31:24 zero and with 24:0 being compacted image data for
; programming (8 x 3 bits, chan 0 in bits 2:0, 1 = MAX L, 7 =
; MAX R).  r1-r13 preserved.
ConvImages Entry r1
        ADD     r1, r0, #7              ; start with channel 7
        MOV     r0, #0                  ; initialise output in r0
10      LDRB    lr, [r1], #-1           ; get one byte
        CMP     lr, #&E0                ; convert from linear pos to SIR value
        ADDLT   lr, lr, #&10
        MOVS    lr, lr, LSR #5
        MOVEQ   lr, #1                  ; correct for min
        MOV     r0, r0, LSL #3          ; shift previous values left one channel pos
        ORR     r0, r0, lr              ; merge in this channel into bottom
        TST     r0, #7 :SHL: (7*3)      ; shifted channel 7 value into place yet?
                                        ; (all output values are 1..7, i.e. not 0)
        BEQ     %BT10                   ; go round again if not
        EXIT                            ; all done, go home

;
; ProgramImages
;
; Given a compact stereo image position set in r0, program VIDC
; with the values.  r0-r13 preserved.

ProgramImages Entry "r0-r3"
        LDR     r1, =SoundLevel0Base
        LDR     r1, [r1, #SoundRMA]
        LDR     r1, [r1, #BaseOfVIDC]

        MOV     r2, #SIR0               ; address channel 0 register
10      AND     r3, r0, #&7             ; get this channel
        CMP     r2, #SIR6+SIRSTEP       ; are we on channel 7? then fix regaddr
        MOVEQ   r2, #SIR7               ; to cope with out-of-order prog'ing
        ORR     r3, r3, r2              ; combine value and vidc reg addr
        STR     r3, [r1]                ; and program it
        ADD     r2, r2, #SIRSTEP        ; step on to next channel SIR address
        MOV     r0, r0, LSR #3          ; and shift down to next channel pos
        BNE     %BT10                   ; drop out if channel 7 done

        EXIT                            ; and go home

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CopyError Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        ADD     R1, R12, #MessageFile_Block
        MOV     R2, #0
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.SoundDMA.Messages", 0
        ALIGN

open_messagefile Entry r0-r2
        LDR     r0, [r12, #MessageFile_Open]
        CMP     r0, #0
        EXIT    NE
        ADD     R0, r12, #MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        EXIT    VS
        MOV     r0, #1
        STR     r0, [r12, #MessageFile_Open]
        EXIT

 [ StorkPower
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Power management routines
;

GetPower Entry "r1,r10,r11"
        LDR     r10, =SoundLevel0Base
        LDR     r11, [r10, #SoundRMA]

        MOV     R0, #0                          ; set masks for read
        MOV     R1, #&FFFFFFFF
        SWI     XPortable_Control               ; new = (old AND r1) EOR r0
        ANDVC   r1, r1, #SoundPowerBits         ; call ok, so extract sound bits
        MOVVS   r1, #SoundPowerBits             ; error, assume power is on
        STR     r1, [r11, #power_state]
        MOVVC   r1, #1                          ; call ok, mark module present
        MOVVS   r1, #0                          ; error
        STR     r1, [r11, #portable_present]
        EXIT

SetPower_On
        MOV     r0, #SoundPowerBits
        B       SetPower                        ; turn on power

SetPower_Off
        MOV     r0, #0                          ; turn power off

; and drop thru to...

SetPower Entry "r1,r10,r11"
        LDR     r10, =SoundLevel0Base
        LDR     r11, [r10, #SoundRMA]

        LDR     lr, [r11, #portable_present]    ; if no portable module present
        TEQ     lr, #0
        EXIT    EQ                              ; then do nothing

        LDR     lr, [r11, #power_state]         ; if current state = new state, do nothing
        TEQ     r0, lr
        EXIT    EQ

        MOV     r1, #:NOT:SoundPowerBits
        SWI     XPortable_Control               ; new = (old AND r1) EOR r0
        ANDVC   r1, r1, #SoundPowerBits
        STRVC   r1, [r11, #power_state]
        EXIT    VC

        MOV     r0, #0                          ; if we got an error
        STR     r0, [r11, #portable_present]    ; then set portable_present = FALSE
        MOV     r0, #SoundPowerBits
        STR     r0, [r11, #power_state]         ; and set power_state = ON
        EXIT

        LTORG
 ]

        GET Sound0_SA.s

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ debug
        InsertNDRDebugRoutines
 ]

        END

@


4.17
log
@Code sync fix, less shouty help, cached controller addresses
* ON/OFF->On/Off in the syntax and help.
* The call to Sound0synccode was a bit premature as there was a branch instruction emitted after it.
* Cache the logical addresses of IOMD/VIDC to avoid having to keep looking them up with SWIs.
* Substitute magic numbers for header definitions.
* Build command table with 'Command' macro.
* STM/LDM from SP changed to Push/Pull.
* Trimmed out ARM810 support. No such chip.

Version 1.69. Tagged as 'Sound0-1_69'
@
text
@a159 1
        GET     Version
a219 5
 [ StorkPower
        GBLL    AdvancedPower   ;True - power on only whilst buffers hold 'non-quiet' data
AdvancedPower   SETL    {FALSE} ;Switched off cos amps have nasty switch-on click
 ]

a309 1
OverMonoShift   *       5               ; shift to get to OS/Mono as 2-bit field
d390 1
a390 1
 [ Development
d935 1
a935 8
  [ AdvancedPower
PowerControl      # 4                   ;0..PowerContThres2 number of consecutive quiet buffers
PowerContThres1   * 2                   ;When PowerControl is >=2, both current & next buffers
                                        ; are quiet so allow amplifier to be powered down
                                        ; ie don't reject ServicePortable_PowerDown.
PowerContThres2   * 100                 ;Threshold at which the interrupt routine powers down
                                        ; the amplifier
  ]
d1462 2
a1463 2
        LDR     r1, =1024*1000*1000     ; calculate 1,024,000,000/usec
        MOV     r0, r2                  ; to get Hz/1024
d1649 2
a1720 6
  [ AdvancedPower
        LDR     r0, [r10, #SoundRMA]
        LDR     r0, [r0, #PowerControl]
        CMP     r0, #PowerContThres1    ; if both buffers are silent, no need to power up the amplifiers
        BLLT    SetPower_On             ; but if not... power up now (corrupts R0)
  |
a1721 1
  ]
d1772 1
a1772 1
        MOV     r8, #0
d1850 2
d1930 3
d2040 3
d2177 3
d2302 5
a2306 2
        CMP    r0, #Sound_RSI_Features
        MOVEQ  r0, #0
d2308 1
a2308 1
        MOVEQ  r1, #Sound_RSI_Feature_Service8910
d2310 1
a2310 1
        MOVEQ  r1, #0 ; New services not (yet) implemented for old machines
d2312 1
a2312 1
        MOV    pc, lr
a2366 5
  [ AdvancedPower
        MOV     r0, #0                          ; indicate amplifier power should be on
        STR     r0, [r2, #PowerControl]
        BL      GetPower                        ;
  |
a2368 1
  ]
a2651 8
  [ AdvancedPower
        LDR     r0, [r11, #PowerControl]
        CMP     r0, #PowerContThres1
        BGE     %FT32                           ;GE, playing, but quietly
;
; Sound system on AND making a noise, so prevent powerdown
;
  |
a2654 1
  ]
d2922 4
a2925 4
;        STREQ   r5, [r2, #IOMD_SD0CURA] ; if Z set, update CURA reg
;        STREQ   r0, [r2, #IOMD_SD0ENDA] ;   and also end reg, to make it valid
;        STRNE   r5, [r2, #IOMD_SD0CURB] ; else update CURB reg
;        STRNE   r0, [r2, #IOMD_SD0ENDB] ;   and also end reg, to make it valid
a3184 1
        ;MSR    CPSR_c, #I32_bit+IRQ32_mode
a3191 1
        ;MSR    CPSR_c, #I32_bit+SVC32_mode
d3222 1
a3222 1
        MOV     r8, r7, LSR #16         ; get current per-channel period in r8
d3234 1
a3234 2
        ;MSR    CPSR_c, #I32_bit+IRQ32_mode
        MOV     r8, r7, LSR #16         ; get current per-channel period in r8
a3238 10
        ;MSR    CPSR_c, #I32_bit+SVC32_mode
 [ StorkPower
  [ AdvancedPower
        LDR     r9, =SoundLevel0Base    ; Workspace pointer
        LDR     r9, [r9, #SoundRMA]     ; Address fixup code via RMA pointer
        LDR     r0, [r9, #portable_present]
        CMP     r0, #0
        BLNE    StorkCode
  ]
 ]
d3249 1
a3249 1
        MOV     r8, #0
d3259 1
a3259 1
        MOV     r8, #0
d3263 1
a3263 1
        MOV     r8, #0
d3272 1
a3272 1
        MOV     r8, #0
a3331 1
        ;MSR    CPSR_c, #I32_bit+IRQ32_mode
d3334 1
a3334 1
        ;MSR    CPSR_c, #I32_bit+SVC32_mode
a3340 9
 [ StorkPower
  [ AdvancedPower
        LDR     r9, =SoundLevel0Base    ; Workspace pointer
        LDR     r9, [r9, #SoundRMA]     ; Address fixup code via RMA pointer
        LDR     r0, [r9, #portable_present]
        CMP     r0, #0
        BLNE    StorkCode
  ]
 ]
a3396 2

        ;MSR    CPSR_c, #I32_bit+IRQ32_mode
d3399 1
a3399 1
        ;MSR    CPSR_c, #I32_bit+SVC32_mode
d3413 1
a3413 3
        MOV     r3, r3, LSR #OverMonoShift
        ANDS    r3, r3, #3              ; bit 0 -> oversamp. bit 1 -> mono
;       B       BufferDone
d3427 2
a3428 2
        CMP     r3, #2                  ; check which proc we need to call (1,2,3)
        BEQ     MonoOnly                ; if r3 = 2, do just mono conversion
d3434 3
a3436 2
        BLT     OverOnly                ; if r3 < 2 (i.e. 1), only oversample
        B       MonoOver                ; if r3 > 2 (i.e. 3), do mono + oversample
d3678 3
a3680 3
        LDR     r0, =SoundLevel0Base
        LDR     r0, [r0, #SoundRMA]
        LDR     r0, [r0, #BaseOfVIDC]
d3683 1
a3683 1
10      AND     r3, r1, #&7             ; get this channel
d3687 1
a3687 1
        STR     r3, [r0]                ; and program it
d3689 1
a3689 1
        MOV     r1, r1, LSR #3          ; and shift down to next channel pos
d3782 1
a3782 65
 [ StorkPower
  [ AdvancedPower
        ; Check the buffer for being all 0.
;
; Scan the buffer just filled, to see if it is silent (all zeroes) or noisy (non-zero).
; If the buffer is noisy, we must ensure that the sound hardware (filters & amplifier etc)
; is switched on. If the buffer is quiet, we increment PowerControl and compare it against
; a threshold (PowerContThres2). If the threshold is reached, we switch the sound hardware
; off. The threshold value is of course a compromise; a short value to minimise power
; consumption verses a long one to minimise annoying clicks from the speaker.
;
StorkCode
StorkCodeStart ROUT
        MOV     r0, #0
StorkCodeLoop1
        LDMIA   r12!, {r1-r4}
        ORR     r0, r0, r1
        ORR     r0, r0, r2
        ORR     r0, r0, r3
        ORR     r0, r0, r4
        CMP     r12, r10
        BLO     StorkCodeLoop1
        TEQ     r0, #0                          ;if r0 is 0, the sound system is quiet

        MOVNE   r0, #0                          ;NE, making a noise, so
        STRNE   r0, [r9, #PowerControl]         ;NE, zero counter
        MOVNE   r0, #SoundPowerBits             ;NE, and ensure sound system is powered up
        BNE     SetPower_

        LDR     r0, [r9, #PowerControl]         ;'next' buffer is quiet, so inc counter
        ADD     r0, r0, #1                      ;
        CMP     r0, #PowerContThres2            ; (limit count at threshold)
        MOVGE   r0, #PowerContThres2            ;
        STR     r0, [r9, #PowerControl]         ;

        MOVLT   pc, lr                          ;LT, not hit threshold, so leave power 'as-is'

        MOVGE   r0, #0                          ;hit switch off threshold, so power down

SetPower_
        Push    "LR"                            ;IRQ_LR

        LDR     lr, [r9, #power_state]
        TEQ     r0, r9
        Pull    "PC",EQ

       ;SVCMode r3
        SavePSR r3
        WritePSRc I_bit :OR: SVC_mode, r4
        NOP

        Push    "LR"                            ;save SVC_LR
        BL      SetPower
        Pull    "LR"                            ;restore SVC_LR

        RestPSR r3
        NOP

        Pull    "PC"
StorkCodeEnd
StorkCodeSize * StorkCodeEnd - StorkCodeStart
  ]
 ]

    GET Sound0_SA.s
@


4.16
log
@Add missing SWI name
Detail:
  s/Sound0 - Add ReadSysInfo to SWI decoding table
Admin:
  Name missed out from previous commit


Version 1.68. Retagged as 'Sound0-1_68'
@
text
@a128 2
              GBLL    ARM810support
ARM810support SETL    {FALSE}
d148 1
d153 3
a159 3
        GET     Hdr:Sound
        GET     Hdr:Portable

a162 1
        GET     Hdr:HALEntries
d219 1
a219 1
StorkPower      SETL    True
d223 1
a223 1
AdvancedPower   SETL    False   ;Switched off cos amps have nasty switch-on click
d227 1
a227 1
EnableIRQsIn16bit       SETL    False
d231 1
a231 1
DisableFlybackIRQ       SETL    True
d234 1
a234 1
DisableHardDiscIRQ      SETL    True
a237 2
debug           SETL    False

d239 4
a242 3
hostvdu         SETL    True

swi     SETD    False
d369 1
a369 1
Module_Base
d371 6
a376 6
        DCD     Initialise_Module    - Module_Base
        DCD     Finalise_Module      - Module_Base
        DCD     Intercept_Services   - Module_Base
        DCD     Module_Name          - Module_Base
        DCD     Help_String          - Module_Base
        DCD     Module_Keywords      - Module_Base
d378 2
a379 2
        DCD     Sound_SWI_Code       - Module_Base
        DCD     Module_SWIDecodeBase - Module_Base
d382 1
a382 1
        DCD     message_filename     - Module_Base
d387 1
a387 1
        DCD     Module_Flags         - Module_Base
d431 6
a436 36
        DCB     "Audio", 0
        ALIGN
        DCD     Audio_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)   ; all flags clear, and one parameter ONLY
        DCD     Audio_Syntax - Module_Base
        DCD     Audio_Help   - Module_Base

        DCB     "Speaker", 0
        ALIGN
        DCD     Speaker_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)   ; all flags clear, and one parameter ONLY
        DCD     Speaker_Syntax - Module_Base
        DCD     Speaker_Help   - Module_Base

        DCB     "Stereo", 0
        ALIGN
        DCD     Stereo_Code   - Module_Base
        DCB     2, 0, 2, 0:OR:(International_Help:SHR:24)   ; all flags clear, two parameters ONLY
        DCD     Stereo_Syntax - Module_Base
        DCD     Stereo_Help   - Module_Base

        DCB     "SoundGain", 0
        ALIGN
        DCD     SoundGain_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)
        DCD     SoundGain_Syntax - Module_Base
        DCD     SoundGain_Help   - Module_Base

        DCB     "SoundSystem", 0
        ALIGN
        DCD     SoundSystem_Code   - Module_Base
        DCB     1, 0, 2, 0:OR:(International_Help:SHR:24):OR:(Status_Keyword_Flag:SHR:24)
        DCD     SoundSystem_Syntax - Module_Base
        DCD     SoundSystem_Help   - Module_Base

        DCB     0            ; no more entries.
d806 1
a806 1
        STMFD   sp!, {r1,r3-r9,lr}      ; save r3-r9,pc', and code start address (r1) for later
d901 3
a903 8
        LDMFD   sp!, {r0}               ; pop original code start (loop top)
  [ StrongARM
        STMFD   sp!,{r0-r2,lr}
        BL      Sound0synccode          ;SynchroniseCodeAreas, r0=start addr, r1 = end addr (inclusive)
        LDMFD   sp!,{r0-r2,lr}
  ]
        SUB     r0, r1, r0              ; work out offset from there to . now
        SUB     r4, r4, r0, LSR #2      ; subtract offset (in words) to get instr
d905 5
a909 1

d911 1
a911 1
        LDMFD   sp!, {r3-r9,pc}         ; recover saved regs and go home
d922 3
d1097 1
a1097 1
        MOV     r0, #161                        ; Print status so read CMOS.
d1167 1
a1167 1
        MOV     r0, #161                        ; Read current value.
d1173 1
a1173 1
        MOVVC   r0, #162
d1324 1
a1324 1
        Debug   swi,"Sound0Config",r0,r1,r2,r3,r4
d1385 1
a1385 1
        Debug   swi,"per channel bufsz =",r1
d1452 1
a1452 1
        Debug   swi,"WorkOutVIDCParams",r0,r1,r2
d1463 1
a1463 1
        Debug   swi,"L16_mulaw"
d1475 1
a1475 1
        STMFD   sp!, {r1,r2}            ; save regs corrupted by Divide
d1480 1
a1480 1
        LDMFD   sp!, {r1,r2}            ; recover other values
d1493 1
a1493 1
        Debug   swi,"16bit output"
d1551 1
a1551 1
        Debug   swi,"computed values are",r0,r1,r2,r3
d1593 1
a1593 1
        Debug   swi,"process_oversample, default off"
d1608 1
a1608 1
        Debug   swi,"oversampling on"
d1675 2
a1676 6
        STMDB   sp!,{r2-r3,r8-r9}
        MOV     r9, #EntryNo_HAL_ControllerAddress
        MOV     r1, #0x400
        MOV     r8, #0
        SWI     XOS_Hardware

d1681 1
d1683 2
a1684 1
        MOV     r0, #0x14
d1686 1
a1686 1
        LDMIA   sp!,{r2-r3,r8-r9}
d1749 2
a1750 7
        STMDB   sp!,{r2-r3,r8-r9}
        MOV     r9, #EntryNo_HAL_ControllerAddress
        MOV     r1, #0x400
        MOV     r8, #0
        SWI     XOS_Hardware
        MOV     r12, r0
        LDMIA   sp!,{r2-r3,r8-r9}
d1788 1
a1788 1
        STMDB   sp!,{r2-r3,r8-r9}
d1790 1
a1790 1
        MOV     r0, #0x14
d1793 1
a1793 1
        LDMIA   sp!,{r2-r3,r8-r9}
d2335 2
a2336 2

00      LDR     r10, =SoundLevel0Base
d2347 24
d2419 1
a2419 1
        MOV     r0, #161                ; CMOS read OSBYTE
d2478 2
a2479 7
        STMDB   sp!,{r1-r3,r8-r9}
        MOV     r9, #EntryNo_HAL_ControllerAddress
        MOV     r1, #0x400
        MOV     r8, #0
        SWI     XOS_Hardware
        LDMIA   sp!,{r1-r3,r8-r9}

d2534 2
a2535 8
        STMDB   sp!,{r0,r2-r3,r8-r9}
        MOV     r9, #EntryNo_HAL_ControllerAddress
        MOV     r1, #0x300
        MOV     r8, #0
        SWI     XOS_Hardware
        MOV     r1,r0
        LDMIA   sp!,{r0,r2-r3,r8-r9}

d2566 1
a2566 1
        DCD     UService - Module_Base
d2575 1
a2575 1
        DCD     UServTab - Module_Base
d2608 1
a2608 1
        MOV     r0, #&FD
d2902 2
a2903 8
        STMDB   sp!,{r0-r1,r3,r8-r9}
        MOV     r9, #EntryNo_HAL_ControllerAddress
        MOV     r1, #0x400
        MOV     r8, #0
        SWI     XOS_Hardware
        MOV     r2, r0
        LDMIA   sp!,{r0-r1,r3,r8-r9}

a3065 8
        STMDB   sp!,{r3,r8-r9}
        MOV     r9, #EntryNo_HAL_ControllerAddress
        MOV     r1, #0x300
        MOV     r8, #0
        SWI     XOS_Hardware
        MOV     r2,r0
        LDMIA   sp!,{r3,r8-r9}

d3074 2
d3077 1
d3126 2
a3127 8
        STMDB   sp!,{r0,r8-r9}
        MOV     r9, #EntryNo_HAL_ControllerAddress
        MOV     r1, #0x400
        MOV     r8, #0
        SWI     XOS_Hardware
        MOV     r2, r0
        LDMIA   sp!,{r0,r8-r9}

d3279 1
a3279 1
        STMDB   sp!,{r1-r3,r8-r9}
d3281 1
a3281 1
        MOV     r0, #0x14
d3291 1
a3291 1
        MOV     r0, #3
d3295 1
a3295 1
        MOV     r0, #5
d3304 1
a3304 1
        MOV     r0, #9
d3308 1
a3308 1
        LDMIA   sp!,{r1-r3,r8-r9}
d3319 1
a3319 1
        STMFD   sp!, {r4,r6,r10,r12} ; save off physlen, config, logend, buffstart
d3408 1
a3408 1
        LDMFD   sp!, {r4,r6,r10,r12}    ; again restore values, clearing stack this time
d3431 1
a3431 1
        STMFD   sp!, {r1,r2}            ; save base/limit for oversampler below
d3495 2
a3496 1
        STMDB   sp!,{r1-r3,r8-r9}
d3498 3
a3500 7
        MOV     r0, #0x14
        MOV     r8, 0
        SWI     XOS_Hardware

        MOV     r9, #EntryNo_HAL_ControllerAddress
        MOV     r1, #0x400
        MOV     r8, #0
d3502 1
a3502 3
        MOV     r9, #EntryNo_HAL_IRQEnable
        MOV     r0, #9
        MOV     r8, #0
d3506 1
a3506 3
        MOV     r9, #EntryNo_HAL_IRQEnable
        MOV     r0, #3
        MOV     r8, #0
d3508 2
a3509 3
        MOV     r9, #EntryNo_HAL_IRQEnable
        MOV     r0, #5
        MOV     r8, #0
d3512 1
a3512 1
        LDMIA   sp!,{r1-r3,r8-r9}
d3723 5
a3727 6
ProgramImages Entry "r0-r3,r8-r9"
        MOV     r9, #EntryNo_HAL_ControllerAddress
        MOV     r1, #0x300
        MOV     r8, #0
        SWI     XOS_Hardware
        LDR     r1, [sp]
@


4.15
log
@Add support for sound starting/stopping/config changing service calls, and new Sound_ReadSysInfo SWI
Detail:
  hdr/Sound - Added definitions for new service calls and Sound_ReadSysInfo SWI
  s/Sound0 - Add support for new SWI/service calls. Adjust buffer size constraints in Sound0Enable.
Admin:
  Tested in IOMD ROM softload on RiscPC


Version 1.68. Tagged as 'Sound0-1_68'
@
text
@d429 1
@


4.14
log
@Fix register corruption in Sound_Enable. Only preserve bare minimum registers around OS_Hardware calls. Convert tabs to spaces for consistency
Detail:
  s/Sound0 - Fixed register corruption in Sound_Enable when disabling sound.
  Tweaked numerous OS_Hardware calls to only preserve the bare minimum registers, and to avoid lots of popping/pushing when calling multiple times.
  Converted tabs to spaces for consistency, and stripped code that was made commented out when HAL support was introduced.
Admin:
  Tested in IOMD ROM softload


Version 1.66. Tagged as 'Sound0-1_66'
@
text
@d1332 1
d1403 7
a1409 6
        TST     lr, #OversampleFlag     ; yes, so limit no. samples to
        MOVEQ   r11, #2                 ; 4096/4=1024 if no o/s
        MOVNE   r11, #3                 ; 4096/8=512 if o/s
        MOV     lr, #SoundDMABufferSize
        CMP     r1, lr, LSR r11
        MOVGT   r1, lr, LSR r11
d1480 1
a1480 1
        Push    "r0,r1,r3,lr"
a1524 1
        Push    "r4,r5,r6,r7,r8"
a1571 1
        Pull    "r4,r5,r6,r7,r8"
d1585 1
d1588 1
d1594 17
a1610 1
        Pull    "r0,r1,r3,pc"           ; pop log2nchan, old r1, old r3, return PC
d1719 5
d1776 5
d2284 1
d2286 12
a2297 1
        EXIT                            ; all done
d2309 1
a2309 1
        DCD     &1F1                    ; ???
d2336 22
@


4.13
log
@  Support for HAL-ised IOMD builds
Detail:
  Not supplied, but looks like it's primarily support for IOMD's address being
  determined by querying the HAL, and use of the HAL interrupt API. Note that
  the code has no fallbacks for non-HAL OSes and there's no build switch to
  build a non-HAL variant, so use version 1.63 for non-HAL OSes.
Admin:
  Changes by Tom Walker

Version 1.64. Tagged as 'Sound0-1_64'
@
text
@d164 1
a164 1
	GET	Hdr:HALEntries
d1687 5
a1691 8
	STMDB	sp!,{r8-r9}
	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x400
	MOV	r8, #0
	SWI	XOS_Hardware

	;ADD	r0, r0, #0x200000
        ;MOV     r0, #IOMD_Base          ; Address IOMD
d1697 4
a1700 8
	MOV	r9, #EntryNo_HAL_IRQDisable
	MOV	r0, #0x14
	MOV 	r8, #0
	SWI	XOS_Hardware
	LDMIA 	sp!,{r8-r9}
        ;LDRB    r1, [r0, #IOMD_DMAMSK]  ; Also disable IRQ from sound0 DMA channel
        ;BIC     r1, r1, #IOMD_DMA_SD0
        ;STRB    r1, [r0, #IOMD_DMAMSK]
d1753 7
a1759 8
	STMDB 	sp!,{r0-r3,r8-r9}
 	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x400
	MOV	r8, #0
	SWI	XOS_Hardware
	MOV	r12, r0
	;ADD	r12, r0, #0x200000
	LDMIA	sp!,{r0-r3,r8-r9}
a1760 1
       ;MOV     r12, #IOMD_Base
d1797 6
a1802 12
        ; r12 already contains IOMD_Base
	STMDB 	sp!,{r0-r3,r8-r9}
 	MOV	r9, #EntryNo_HAL_IRQEnable
	MOV	r0, #0x14
	MOV	r8, #0
	SWI	XOS_Hardware
	MOV	r12, r0
	;ADD	r12, r0, #0x200000
	LDMIA	sp!,{r0-r3,r8-r9}
;        LDRB    r1, [r12, #IOMD_DMAMSK] ; Enable IRQ from sound0 DMA channel
;        ORR     r1, r1, #IOMD_DMA_SD0
;        STRB    r1, [r12, #IOMD_DMAMSK]
d1924 2
a1925 2
;	   R1 = 0: stereo mode
;	   R1 <> 0: mono mode (convert stereo to mono for output)
d1949 1
a1949 1
;		= 1: mono conversion on output
d1970 2
a1971 2
        TST	r2, #DoMono		; check for mono mode
        ORRNE	r1, r1, #1 :SHL: 5	; set flag if enabled
d2004 3
a2006 3
	B	%FT99
30	CMP	r0, #3
	BNE	%FT40
d2008 1
a2008 1
        LDRB    r2, [r10, #Flags]	; get flags byte
d2429 6
a2434 7
	STMDB 	sp!,{r1-r3,r8-r9}
 	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x400
	MOV	r8, #0
	SWI	XOS_Hardware
	;ADD	r0, r0, #0x200000
	LDMIA	sp!,{r1-r3,r8-r9}
a2435 1
;       MOV     r0, #IOMD_Base
d2490 7
a2496 7
	STMDB 	sp!,{r0,r2-r3,r8-r9}
 	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x300
	MOV	r8, #0
	SWI	XOS_Hardware
	MOV	r1,r0
	LDMIA	sp!,{r0,r2-r3,r8-r9}
a2497 1
;        MOV     r1, #VIDC
d2796 3
a2798 3
        MSR	CPSR_c,	#I32_bit+SVC32_mode
        Push 	"lr"
	MSR	CPSR_c, #I32_bit+IRQ32_mode
d2864 7
a2870 8
	STMDB	sp!,{r0-r1,r3,r8-r9}
	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x400
	MOV	r8, #0
	SWI	XOS_Hardware
	MOV	r2, r0
	;ADD	r2, r0, #0x200000
	LDMIA	sp!,{r0-r1,r3,r8-r9}
a2871 2
;        	MOV     r2, #0xF9000000
;		ORR	r2, r2, #0xA00000
d2942 3
a2944 3
	MSR	CPSR_c,#I32_bit+SVC32_mode
	Pull	"lr"
	MSR	CPSR_c,#I32_bit+IRQ32_mode
d3034 7
a3040 7
	STMDB 	sp!,{r0-r1,r3,r8-r9}
 	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x300
	MOV	r8, #0
	SWI	XOS_Hardware
	MOV	r2,r0
	LDMIA	sp!,{r0-r1,r3,r8-r9}
a3041 2
        ;MOV     r2, #0xF9000000
	;ORR	r2, r2, #0xC00000
d3099 7
a3105 8
	STMDB	sp!,{r0-r1,r3,r5-r9}
	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x400
	MOV	r8, #0
	SWI	XOS_Hardware
	MOV	r2, r0
	;ADD	r2, r0, #0x200000
	LDMIA	sp!,{r0-r1,r3,r5-r9}
a3106 2
        ;MOV     r2, #0xF9000000
	;ORR	r2, r2, #0xA00000
d3184 1
a3184 1
        ;MSR	CPSR_c,	#I32_bit+IRQ32_mode
d3192 1
a3192 1
        ;MSR	CPSR_c,	#I32_bit+SVC32_mode
d3235 1
a3235 1
        ;MSR	CPSR_c,	#I32_bit+IRQ32_mode
d3241 1
a3241 1
        ;MSR	CPSR_c,	#I32_bit+SVC32_mode
d3258 5
a3262 17
	STMDB	sp!,{r1-r3,r8-r9}
	MOV	r9, #EntryNo_HAL_IRQDisable
	MOV 	r0, #0x14
	MOV 	r8, #0
	SWI 	XOS_Hardware

	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x400
	MOV 	r8, #0
	;SWI	XOS_Hardware
	;ADD	r0, r0, #0x200000
	LDMIA	sp!,{r1-r3,r8-r9}

        ;MOV     r0, #IOMD_Base
        ;LDRB    lr, [r0, #IOMD_DMAMSK]
        ;BIC     lr, lr, #IOMD_DMA_SD0
        ;STRB    lr, [r0, #IOMD_DMAMSK]
d3269 8
a3276 11
	MOV	r9, #EntryNo_HAL_IRQDisable
	MOV 	r0, #3
	MOV 	r8, #0
	SWI 	XOS_Hardware
	MOV	r9, #EntryNo_HAL_IRQDisable
	MOV 	r0, #5
	MOV 	r8, #0
	SWI 	XOS_Hardware        ;LDRB    lr, [r0, #IOCIRQMSKA]           ; Assume IOC base = IOMD base.
        ;Push    lr
        ;BIC     lr, lr, #vsync_bit + timer0_bit
        ;STRB    lr, [r0, #IOCIRQMSKA]
d3282 4
a3285 7
	MOV	r9, #EntryNo_HAL_IRQDisable
	MOV 	r0, #9
	MOV 	r8, #0
	SWI 	XOS_Hardware        ;LDRB    lr, [r0, #IOCIRQMSKB]
       ; Push    lr
       ; BIC     lr, lr, #IOMD_HardDisc_IRQ_bit
        ;STRB    lr, [r0, #IOCIRQMSKB]
d3287 1
d3344 1
a3344 1
        ;MSR	CPSR_c,	#I32_bit+IRQ32_mode
d3347 1
a3347 1
        ;MSR	CPSR_c,	#I32_bit+SVC32_mode
d3420 1
a3420 1
        ;MSR	CPSR_c,	#I32_bit+IRQ32_mode
d3423 1
a3423 1
        ;MSR	CPSR_c,	#I32_bit+SVC32_mode
d3437 19
a3455 19
	MOV	r3, r3, LSR #OverMonoShift
	ANDS	r3, r3, #3		; bit 0 -> oversamp. bit 1 -> mono
;	B	BufferDone
	BEQ	BufferDone		; nowt to do if both bits clear (r3 = 0)

	; OK, doing some sort of filtering operation.  Set up some constants
	; used in all cases...

	; Set up 0x80008000 in r12, to perform signed/unsigned swap overs
 	MOV	r12, #1<<15
 	ORR	r12, r12, #1<<31

	; Create 0xFFFEFFFE in r11 for masking off LSBs, to isolate LH and RH
	; parts during parallel additions.
 	MVN	r11, r12, ROR #15	; can derive from r12 in one go!

	CMP	r3, #2			; check which proc we need to call (1,2,3)
	BEQ	MonoOnly		; if r3 = 2, do just mono conversion
					; else doing oversampling...
d3458 11
a3468 11
	STR	r2, [sp, #4]		; store out for later use also
					; switch to appropriate oversampling code
	BLT	OverOnly		; if r3 < 2 (i.e. 1), only oversample
	B	MonoOver		; if r3 > 2 (i.e. 3), do mono + oversample

BufferDone	; return here after any buffer processing
	Pull	"r3,r4" 		; pop phys base+real limit (@@Fs*2 if oversampling)
	LDR	r6, [r4, #-4]		; pick up last sample pair from this buffer
	LDR	r11, =SoundLevel0Base 	; address sound work area
	LDR	r7, [r11, #SoundRMA]	; address RMA area
	STR	r6, [r7, #SavedSample]	; save sample pair for possible oversampling next time
d3474 9
a3482 16
	STMDB	sp!,{r1-r3,r8-r9}
	MOV	r9, #EntryNo_HAL_IRQEnable
	MOV	r0, #0x14
	MOV	r8, 0
	SWI 	XOS_Hardware

	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x400
	MOV	r8, #0
	;SWI	XOS_Hardware
	;ADD	r0, r0, #0x200000
	LDMIA	sp!,{r1-r3,r8-r9}
;        MOV     r0, #IOMD_Base
        ;LDRB    lr, [r0, #IOMD_DMAMSK]
        ;ORR     lr, lr, #IOMD_DMA_SD0
        ;STRB    lr, [r0, #IOMD_DMAMSK]
d3484 4
a3487 9
	MOV	r9, #EntryNo_HAL_IRQEnable
	MOV 	r0, #9
	MOV 	r8, #0
	SWI 	XOS_Hardware
        ;;Pull    lr
        ;TST     lr, #IOMD_HardDisc_IRQ_bit
        ;LDRNEB  lr, [r0, #IOCIRQMSKB]
        ;ORRNE   lr, lr, #IOMD_HardDisc_IRQ_bit
        ;STRNEB  lr, [r0, #IOCIRQMSKB]
d3490 8
a3497 14
	MOV	r9, #EntryNo_HAL_IRQEnable
	MOV 	r0, #3
	MOV 	r8, #0
	SWI 	XOS_Hardware
	MOV	r9, #EntryNo_HAL_IRQEnable
	MOV 	r0, #5
	MOV 	r8, #0
	SWI 	XOS_Hardware
        ;Pull    lr
        ;ANDS    lr, lr, #vsync_bit + timer0_bit
        ;LDRNEB  r1, [r0, #IOCIRQMSKA]
        ;BICNE   r1, r1, #vsync_bit + timer0_bit
        ;ORRNE   r1, r1, lr
        ;STRNEB  r1, [r0, #IOCIRQMSKA]
d3499 1
d3509 3
a3511 3
	MSR	CPSR_c,#I32_bit+SVC32_mode
	Pull	"lr"
	MSR	CPSR_c,#I32_bit+IRQ32_mode
d3533 32
a3564 32
MonoOnly	ROUT
01	LDMDB	r1!, {r2,r3,r4,r5}
	; convert from signed to unsigned format
	EOR	r2, r2, r12
	EOR	r3, r3, r12
	EOR	r4, r4, r12
	EOR	r5, r5, r12
	; clear off LSB from each value (two in each reg)
	AND	r2, r2, r11
	AND	r3, r3, r11
	AND	r4, r4, r11
	AND	r5, r5, r11
	; Add the left and right samples together, simultaneously in both upper and
	; halves of each stereo pair. There will be no
	; interference between carry out from the RHS MSB into bit 16 (LSB of
	; LHS sample), and no carry from bit 16 into bit 17, since we cleared
	; bit 16 in both sources (i.e. bit 16 and bit 0 of pre-rotated single source!)
	; beforehand; therefore the subsequent right shift will correctly put the
	; average of the two channel samples back into bits 15..0 (and also into
	; bits 31..16, using RRX to recover carry out from bit 31).
	; Get back to signed 16 bit result for each channel afterwards by EOR'ing
	; with 0x80008000.
	ADDS	r2, r2, r2, ROR #16
	EOR	r2, r12, r2, RRX
	ADDS	r3, r3, r3, ROR #16
	EOR	r3, r12, r3, RRX
	ADDS	r4, r4, r4, ROR #16
	EOR	r4, r12, r4, RRX
	ADDS	r5, r5, r5, ROR #16
	EOR	r5, r12, r5, RRX
	STMIA	r1, {r2,r3,r4,r5}	; store them all out
	CMP	r1, r0                  ; have we just done last loop?
d3566 1
a3566 1
	B	BufferDone		; we're all done
d3577 31
a3607 31
OverOnly 	ROUT
	LDR	r14, [r1, #-4]!		; get last sample in source buffer now
	EOR	r14, r14, r12		; convert signed to unsigned
	AND	r14, r14, r11		; mask LSB bits from this sample-pair
	ADD	r0, r0, #8*4		; need to do last group separately, so move base

01	LDMDB	r1!, {r3,r5,r7,r9}	; load 4 new samples

02	; convert from signed to unsigned format (into separate regs apart from r3)
	EOR	r3, r3, r12
	EOR	r6, r5, r12
	EOR	r8, r7, r12
	EOR	r10, r9, r12
	; clear off LSB from each value (two in each reg)
	AND	r3, r3, r11
	AND	r6, r6, r11
	AND	r8, r8, r11
	AND	r10, r10, r11
	; oversampling: average pairs and turn back to signed format
	ADDS	r4, r3, r6
	EOR     r4, r12, r4, RRX
	ADDS	r6, r6, r8
	EOR	r6, r12, r6, RRX
	ADDS	r8, r8, r10
	EOR	r8, r12, r8, RRX
  	ADDS	r10, r10, r14
	EOR     r10, r12, r10, RRX
	EOR	r14, r12, r14			; put r14 back to signed format also
	STMDB	r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results interleaved with originals
	MOV	r14, r3			; set lowest sample for end of next group
	CMP	r2, r0                  ; have we just done last normal loop?
d3609 1
a3609 1
	BLO	BufferDone		; all done if done extra, special loop
d3611 7
a3617 7
 	; (r2==r0) for last special loop, pick up very first 3 samples from this buffer
 	LDMDB	r1!, {r5,r7,r9}
 	; get last sample from previous buffer, to interpolate for first new sample of this
 	LDR	r3, =SoundLevel0Base
 	LDR	r3, [r3, #SoundRMA]
 	LDR	r3, [r3, #SavedSample]
	B	%B02			; use main loop code to do it
d3621 2
a3622 2
MonoOver	ROUT
	ADD	r0, r0, #8*4		; need to do last group separately, so move base
d3624 45
a3668 45
	LDR	r14, [r1, #-4]!		; get last sample in source buffer now
	EOR	r14, r14, r12		; convert signed to unsigned
	AND	r14, r14, r11		; mask LSB bits from this sample-pair
    	ADDS	r14, r14, r14, ROR #16	; convert to mono
    	AND	r14, r11, r14, RRX

01	LDMDB	r1!, {r3,r5,r7,r9}	; get four new samples: signed, full 16-bit, stereo

02	; convert from signed to unsigned format
	EOR	r3, r3, r12
	EOR	r5, r5, r12
	EOR	r7, r7, r12
	EOR	r9, r9, r12
	; clear off LSB from each value (two in each reg)
	AND	r3, r3, r11
	AND	r5, r5, r11
	AND	r7, r7, r11
	AND	r9, r9, r11
	; Monoise unsigned masked versions of input data; since we're also oversampling,
	; leave in unsigned form and mask off LSBs again
	ADDS	r3, r3, r3, ROR #16
	AND	r3, r11, r3, RRX
	ADDS	r5, r5, r5, ROR #16
	AND	r5, r11, r5, RRX
	ADDS	r7, r7, r7, ROR #16
	AND	r7, r11, r7, RRX
	ADDS	r9, r9, r9, ROR #16
	AND	r9, r11, r9, RRX
	; then oversample, generating new intermediate values in r4,r6,r8,r10, in signed format
	ADDS	r4, r3, r5
	EOR     r4, r12, r4, RRX
	ADDS	r6, r5, r7
	EOR	r6, r12, r6, RRX
	ADDS	r8, r7, r9
	EOR	r8, r12, r8, RRX
  	ADDS	r10, r9, r14
	EOR     r10, r12, r10, RRX
	; must convert monoised unsigned masked originals back to signed format also
	EOR	r5, r12, r5
	EOR	r7, r7, r12
	EOR	r9, r9, r12
	EOR	r14, r12, r14		; put r14 back to signed format also for store-out
	STMDB	r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results, interleaved with originals
	MOV	r14, r3			; copy lo sample (mono,still unsigned & masked) for next group
	CMP	r2, r0                  ; have we just done last normalloop?
d3670 1
a3670 1
	BLO	BufferDone		; return if just done extra, special loop
d3672 8
a3679 8
 	; r2==r0: finally, pick up very first 3 samples from this buffer
 	LDMDB	r1!, {r5,r7,r9}
 	; and last sample from previous buffer, to interpolate for first new sample of this
 	LDR	r3, =SoundLevel0Base
 	LDR	r3, [r3, #SoundRMA]
 	LDR	r3, [r3, #SavedSample]
 	; use main loop code to do final (earliest) 8 samples of output
 	B	%B02
d3710 6
a3715 1
ProgramImages Entry "r0-r3"
d3717 1
a3717 9
	STMDB 	sp!,{r0,r2-r3,r8-r9}
 	MOV	r9, #EntryNo_HAL_ControllerAddress
	MOV	r1, #0x300
	MOV	r8, #0
	SWI	XOS_Hardware
	MOV	r1,r0
	LDMIA	sp!,{r0,r2-r3,r8-r9}
;        MOV     r1, #VIDC
10      AND     r3, r0, #&7             ; get this channel
d3721 1
a3721 1
        STR     r3, [r1]                ; and program it
d3723 1
a3723 1
        MOV     r0, r0, LSR #3          ; and shift down to next channel pos
@


4.12
log
@  GET file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both objasm and asasm.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 1.63. Not tagged
@
text
@d164 2
d1687 8
a1694 1
        MOV     r0, #IOMD_Base          ; Address IOMD
d1699 9
a1707 3
        LDRB    r1, [r0, #IOMD_DMAMSK]  ; Also disable IRQ from sound0 DMA channel
        BIC     r1, r1, #IOMD_DMA_SD0
        STRB    r1, [r0, #IOMD_DMAMSK]
d1760 10
a1769 1
        MOV     r12, #IOMD_Base
d1807 11
a1817 3
        LDRB    r1, [r12, #IOMD_DMAMSK] ; Enable IRQ from sound0 DMA channel
        ORR     r1, r1, #IOMD_DMA_SD0
        STRB    r1, [r12, #IOMD_DMAMSK]
d2444 9
a2452 1
        MOV     r0, #IOMD_Base
d2507 9
a2515 1
        MOV     r1, #VIDC
d2814 3
a2816 2


d2882 11
a2892 1
        MOV     r2, #IOMD_Base
d2931 4
a2934 4
        STREQ   r5, [r2, #IOMD_SD0CURA] ; if Z set, update CURA reg
        STREQ   r0, [r2, #IOMD_SD0ENDA] ;   and also end reg, to make it valid
        STRNE   r5, [r2, #IOMD_SD0CURB] ; else update CURB reg
        STRNE   r0, [r2, #IOMD_SD0ENDB] ;   and also end reg, to make it valid
d2963 3
d3055 10
a3064 1
        MOV     r2, #VIDC
d3122 11
a3132 1
        MOV     r2, #IOMD_Base
d3210 1
d3218 1
d3261 1
d3267 1
d3284 17
a3300 4
        MOV     r0, #IOMD_Base
        LDRB    lr, [r0, #IOMD_DMAMSK]
        BIC     lr, lr, #IOMD_DMA_SD0
        STRB    lr, [r0, #IOMD_DMAMSK]
d3307 11
a3317 4
        LDRB    lr, [r0, #IOCIRQMSKA]           ; Assume IOC base = IOMD base.
        Push    lr
        BIC     lr, lr, #vsync_bit + timer0_bit
        STRB    lr, [r0, #IOCIRQMSKA]
d3323 7
a3329 4
        LDRB    lr, [r0, #IOCIRQMSKB]
        Push    lr
        BIC     lr, lr, #IOMD_HardDisc_IRQ_bit
        STRB    lr, [r0, #IOCIRQMSKB]
d3387 1
a3387 1

d3390 1
a3390 1

d3463 1
d3466 1
a3466 1

d3482 1
d3517 16
a3532 4
        MOV     r0, #IOMD_Base
        LDRB    lr, [r0, #IOMD_DMAMSK]
        ORR     lr, lr, #IOMD_DMA_SD0
        STRB    lr, [r0, #IOMD_DMAMSK]
d3534 9
a3542 5
        Pull    lr
        TST     lr, #IOMD_HardDisc_IRQ_bit
        LDRNEB  lr, [r0, #IOCIRQMSKB]
        ORRNE   lr, lr, #IOMD_HardDisc_IRQ_bit
        STRNEB  lr, [r0, #IOCIRQMSKB]
d3545 14
a3558 6
        Pull    lr
        ANDS    lr, lr, #vsync_bit + timer0_bit
        LDRNEB  r1, [r0, #IOCIRQMSKA]
        BICNE   r1, r1, #vsync_bit + timer0_bit
        ORRNE   r1, r1, lr
        STRNEB  r1, [r0, #IOCIRQMSKA]
d3569 3
d3772 8
a3779 1
        MOV     r1, #VIDC
@


4.11
log
@  Help string no longer has the date in it twice.
Admin:
  Will build.


Version 1.63. Tagged as 'Sound0-1_63'
@
text
@d468 1
a468 1
        GET     s.TokHelpSrc
@


4.10
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 1.62. Tagged as 'Sound0-1_62'
@
text
@d397 1
a397 1
        DCB     "$Module_HelpVersion ($Module_Date)"
@


4.10.4.1
log
@Yet another version of SoundDMA. This one's for the LinkUp L7205 or similar,
attached to an AC '97 codec that supports Variable Rate PCM Audio.

Tested on the SDB board, with a CS4299 codec. With a bit of luck, should work
on any of the myriad other L7205 systems, as long as the codec reset line is
still on GPIO line PD[0].

With a bit more work, this would form the basis of a generic AC '97 SoundDMA
module. The only nasty wrinkle of the L7205 is that the sound data needs
left-right swapping before playback. Bah.

Version 1.62, 4.8.4.1. Tagged as 'Sound0-1_62-4_8_4_1'
@
text
@a163 1
        GET     hdr.L7200
d165 20
d216 21
d272 9
a280 4
; for SIB_ASD.
SRC_N     # 2   ; (new) value to stick into SRC to program audio sample rate divisor
SRC_H     # 2   ; value which IRQ code should ensure is in SRC on next irq
SRC_C     # 2   ; softcopy of value currently set in SRC
d286 3
d290 1
d292 3
a294 3
ImagesC_N # 4   ; compacted (new) version of Images, for prog'ing conv. routine
ImagesC_H # 4   ; value which IRQ code will load into conv. routine on next irq
ImagesC_C # 4   ; softcopy of value currently programmed into conv. routine
d299 1
a299 1
; Currently 2 bytes free
d305 1
a305 1
SCPeriod     * 45                       ; default, i.e. 22.05 kHz
d320 5
a324 1
Lin16Shift      *       2
d327 1
a327 1
MinOSPeriod     *       42              ; do not oversample if period < 42 (f > 24kHz)
d331 1
d334 3
d338 24
d397 1
a397 4
        DCB     "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        DCB     " $Module_MinorVersion"
 ]
d400 3
d404 11
a415 1
        DCB     " AC97 version"
d479 1
d563 1
a563 1
        Pull    PC, EQ                  ; return if so
d828 1
a828 1
;   SVC or IRQ mode, IRQs disabled (essential for atomic rewrite of code!)
d932 5
a936 13
    [ StrongARM
        STMFD   sp!,{r0-r2}
        MRS     r3, CPSR
        MSR     CPSR_c, #I32_bit+SVC32_mode
        MOV     r5, lr_svc
        SUB     r2, r1, #4
        MOV     r1, r0
        MOV     r0, #1
        SWI     XOS_SynchroniseCodeAreas
        MOV     lr_svc, r5
        MSR     CPSR_c, r3
        LDMFD   sp!,{r0-r2}
    ]
d943 1
d953 1
d959 1
d964 16
a979 4
DMACTRL_base      #  4
SIC_base          #  4
GPIO_base         #  4
INT_base          #  4
a982 23
        GBLA    nsr
nsr     SETA    0

        MACRO
        ACRate  $freq
        DCD     $freq*1024
        DCB     (1000000+($freq/2)) / $freq
        DCB     0,0,0
nsr     SETA    nsr+1
        MEND

ftab
        ACRate   8000
        ACRate  11025
        ACRate  16000
        ACRate  22050
        ACRate  32000
        ACRate  44100
        ACRate  48000


        ALIGN

d1120 1
a1120 1
        DCB     "16bit [Oversampled] | <D>",0
d1132 3
a1134 1
        ADR     r0, parameter_16bit
d1150 11
d1206 2
d1305 2
a1306 3
        MRS     R10, CPSR
        Push    "R10,R14"
        MSR     CPSR_c, #I32_bit :OR: SVC32_mode
d1308 7
a1314 3
        Pull    "R10,R14"
        MSR     CPSR_c, R10             ; restore interrupts
        MOV     PC,R14                  ; 32-bit exit: NZ corrupted, CV passed back
d1394 1
d1396 10
a1405 4

        MOV     lr, #SoundDMABufferSize ; limit no. samples to
        CMP     r1, lr, LSR #2          ; 4096/4=1024
        MOVGT   r1, lr, LSR #2          ; (largest form always 16bit stereo)
d1408 3
a1410 3
        CMP     r1, lr, LSR #2
        MOVLT   r1, lr, LSR #2

d1459 3
a1461 2
;       WorkOutVIDCParams - Compute SIB ASD value from
;       present configuration: no. of channels, sample period.
d1466 1
d1470 2
a1471 1
;       SIB_ASD_N holds ASD value to program into SIB
d1475 1
d1480 30
d1522 5
a1526 1
        MOV     r5, #nsr
d1529 2
a1530 1
22      ADD     r1, r4, lr, LSL #3      ; address entry in table
d1544 2
a1545 1
        ADD     r1, r4, lr, LSL #3      ; address entry in table
d1554 2
a1555 1
        ADD     r1, r4, lr, LSL #3      ; address entry in table
d1566 1
d1568 1
a1568 1
        MOV     r3, r0, LSR #10         ; value for SRC register
d1574 1
a1574 1
; r3 is SIB ASD to program, unadjusted, assuming no oversampling
d1576 1
d1581 1
d1589 1
a1589 1
        STRH    r3, [r10, #SRC_N]       ; store for prog'ing under IRQ
d1596 1
a1596 1
;      r3 = unadjusted SRC value, for non-oversampling case
d1601 1
a1601 1
;      r3 = unadjusted SRC for normal or oversampling as required
d1605 4
a1608 1
        TST     r0, #OversampleFlag     ;   && auto oversample flag is set)
d1612 2
d1615 1
a1615 1
        CMP     r1, #SoundDMABufferSize/4 ; check against size limit at Fs*2
d1619 1
a1619 1
        MOV     r3, r3, LSL #1          ; multiply final frequency by 2 to generate Fs*2.
d1623 38
d1684 2
a1685 4
        LDR     r14, [r10, #SoundRMA]
        LDR     r0, [r14, #SIC_base]    ; Address SIC controller
        MOV     r1, #0
        STR     r1, [r0, #SICR2]        ; stop replay
d1687 6
a1692 35
        TEQ     r11, #1
        BEQ     %FT04

; if on, power it down gradually
        MOV     r1, #&26
        MOV     r0, #&0100
        BL      WriteAC97
        MOV     r1, #&26
        MOV     r0, #&0300
        BL      WriteAC97
        MOV     r1, #&26
        MOV     r0, #&0700
        BL      WriteAC97
        MOV     r1, #&26
        ORR     r1, r1, #1:SHL:20
        MOV     r0, #&1700
        BL      WriteAC97

04      LDR     r14, [r10, #SoundRMA]

        LDR     r0, [r14, #SIC_base]    ; Address SIC controller
        MOV     r1, #2_0110000
        STR     r1, [r0, #SICR0]        ; disable SIC

        LDR     r0, [r14, #GPIO_base]   ; Address GPIO controller
        LDR     r1, [r0, #PDDR]
        BIC     r1, r1, #1              ; pull reset low
        STR     r1, [r0, #PDDR]

        LDR     r0, [r14, #DMACTRL_base]; Address DMA controller
        MOV     r1, #&80
        STR     r1, [r0, #DMA_TERM]     ; Terminate DMA
        LDR     r1, [r0, #DMA_IER]      ; Also disable IRQ from sound0 DMA channel
        BIC     r1, r1, #&80
        STR     r1, [r0, #DMA_IER]
d1694 21
d1718 3
d1733 10
a1742 65
        LDR     r14, [r10, #SoundRMA]
        LDR     r12, [r14, #INT_base]
        MOV     r1, #IRQ_DMA
        STR     r1, [r12, #IRQLEnableClear] ; Disable IRQ from DMA controller

        ; *** THIS MAY TAKE A LONG TIME - TOO LONG FOR IRQs DISABLED.
        MSR     CPSR_c, #SVC32_mode
        LDR     r12, [r14, #SIC_base]
        LDR     r1, [r14, #GPIO_base]
;        MOV     r0, #2_0110000          ; Use SPI pins, reset
;        STR     r0, [r12, #SICR0]
        MOV     r0, #2_0100000          ; clear reset
        STR     r0, [r12, #SICR0]
        LDR     r0, [r1, #PDDDR]        ; bring AC97 codec out of reset
        ORR     r0, r0, #1              ; using GPIO lines
        STR     r0, [r1, #PDDDR]
        LDR     r0, [r1, #PDDR]
        ORR     r0, r0, #1
        STR     r0, [r1, #PDDR]
        MOV     r0, #2_0100001          ; enable interface
        STR     r0, [r12, #SICR0]
        MOV     r0, #1:SHL:8
        STR     r0, [r12, #SICR2]       ; warm reset
        ; HACK - software timing loop
        MOV     r0, #50
18      SUBS    r0, r0, #1              ; 50 x 4 cycles = 2.6us - plenty of room for a while
        BNE     %B18
        STR     r0, [r12, #SICR2]       ; end warm reset
19      LDR     r0, [r12, #SICR2]
        TST     r0, #1:SHL:8
        BNE     %B19
        MOV     r0, #2_00010            ; enable replay (rev AA workaround)
        STR     r0, [r12, #SICR2]
16      LDR     r0, [r12, #SIRSR]
        TST     r0, #1:SHL:20           ; wait for codec ready
        BEQ     %B16
;        MOV     r0, #2_00000            ; disable replay (rev AA workaround)
;        STR     r0, [r12, #SICR2]
17      MOV     r1, #&26
        BL      ReadAC97
        AND     r0, r0, #2_1111         ; wait for four green lights
        TEQ     r0, #2_1111             ; (just like Concorde, innit?)
        BNE     %B17
;        MOV     r1, #&00
;        MOV     r0, #0
;        BL      WriteAC97               ; reset registers
        MOV     r1, #&2A
        MOV     r0, #&0001
        BL      WriteAC97               ; enable variable rate
        ; Set SIB sample rate now, not later
        LDRH    r0, [r10, #SRC_N]       ; pick up computed value
        STRH    r0, [r10, #SRC_H]       ; store in next pipeline slot also
        STRH    r0, [r10, #SRC_C]       ; and record as current value
        MOV     r1, #&2C
        BL      WriteAC97               ; sample rate programmed
        MOV     r1, #&02
        MOV     r0, #&0000
        BL      WriteAC97               ; master volume = 0dB
        MOV     r1, #&04
        MOV     r0, #&0000
        BL      WriteAC97               ; headphone volume = 0dB
        MOV     r1, #&18
        MOV     r0, #&0800
        ORR     r0, r0, #&0008
        BL      WriteAC97               ; PCM out volume = 0dB
d1744 36
a1779 1
        MSR     CPSR_c, #I32_bit + SVC32_mode
d1781 15
a1795 33
        MOV     r0, #2_00010            ; enable replay
        STR     r0, [r12, #SICR2]

        LDR     r14, [r10, #SoundRMA]
        LDR     r12, [r14, #DMACTRL_base]
        LDR     r0, [r10, #Phys0]       ; set current pointer = buffer base
        STR     r0, [r12, #DMA_C7NBA]
        LDR     r0, [r12, #DMA_C7NTC]   ; pick up previous end mask value (already programmed)
        STR     r0, [r12, #DMA_C7NTC]   ; re-write, to start DMA

        LDR     r0, =SIC_BASE_PHYS + SIADR
        STR     r0, [r12, #DMA_C7PA]    ; set peripheral address

        LDR     r0, =2_011011           ; 32-bit from RAM, burst, auto-reload, don't stop
        ORR     r0, r0, #&300           ; 3 cycle idle gap
        STR     r0, [r12, #DMA_C7CTL]

        LDR     r0, [r12, #DMA_RCM2]
        BIC     r0, r0, #&FF000000
        ORR     r0, r0, #&18000000      ; map channel 7 to SIC audio transmit
        STR     r0, [r12, #DMA_RCM2]

        MOV     r0, #&80
        STR     r0, [r12, #DMA_UR]      ; clear underrun flag
        STR     r0, [r12, #DMA_ICR]     ; clear interrupts
        STR     r0, [r12, #DMA_EN]      ; enable channel 7
        LDR     r0, [r12, #DMA_IER]     ; enable interrupts from channel 7
        ORR     r0, r0, #&80
        STR     r0, [r12, #DMA_IER]

        LDR     r12, [r14, #INT_base]
        MOV     r1, #IRQ_DMA
        STR     r1, [r12, #IRQLEnableSet] ; Enable IRQ from DMA controller
d1826 15
d1842 1
d1891 1
d1940 5
d1950 1
a1950 1
        MOV     r1, #2                  ; internal clock only
d1974 1
a1974 1
        LDRB    r3, [r10, #SRC_N]       ; pick up current SRC into r3
d1976 1
a1976 1
        MOVNE   r3, r3, LSR #1          ; halve the frequency if so, to give non-O/S period
d1979 1
a1979 1
        STRH    r3, [r10, #SRC_N]       ; and store SRC
d1991 1
a1991 1
        LDRB    r2, [r10, #Flags]       ; get flags byte
d2046 6
d2096 83
d2180 8
d2192 2
a2193 1
        MOV     r1, #nsr
d2211 1
a2211 1
        EXIT                            ; all done!
d2222 1
a2222 1
        LDRB    r3, [r4, #5]            ; get ASD w/o oversampling
d2227 2
a2228 2
        BL      process_oversample      ; work out whether o/s needed, fix ASD if so
        STRB    r3, [r10, #SRC_N]       ; store SRC for later programming
d2230 2
d2260 4
d2265 1
a2265 1
        CMP     r1, #nsr                ; check against limit (unsigned)
d2269 3
a2271 2
        ADRL    r3, ftab-8              ; address main table 0th entry
        ADD     r2, r3, r1, LSL #3      ; index into main table (8 bytes each)
d2275 2
d2298 1
d2304 11
a2314 25
        MOV     r4, r2
        MOV     r0, #13
        LDR     r1, =DMACTRL_BASE_PHYS
        MOV     r2, #&1000
        SWI     XOS_Memory
        LDRVS   r3, =DMACTRL_BASE
        STR     r3, [r4, #DMACTRL_base]
        MOV     r0, #13
        LDR     r1, =SIC_BASE_PHYS
        MOV     r2, #&1000
        SWI     XOS_Memory
        LDRVS   r3, =SIC_BASE
        STR     r3, [r4, #SIC_base]
        MOV     r0, #13
        LDR     r1, =GPIO_BASE_PHYS
        MOV     r2, #&1000
        SWI     XOS_Memory
        LDRVS   r3, =GPIO_BASE
        STR     r3, [r4, #GPIO_base]
        MOV     r0, #13
        LDR     r1, =INT_BASE_PHYS
        MOV     r2, #&1000
        SWI     XOS_Memory
        LDRVS   r3, =INT_BASE
        STR     r3, [r4, #INT_base]
d2323 1
d2334 3
d2347 5
d2372 8
d2394 7
d2402 1
d2408 1
d2410 1
d2412 39
a2450 5

        LDR     r0, [r10, #SoundRMA]
        LDR     r0, [r0, #DMACTRL_base]
        STR     r1, [r0, #DMA_C7NBA]
        STR     r6, [r0, #DMA_C7NTC]
d2459 19
a2477 11
 [ {TRUE}
 |
        ; Set SIB sample rate now, not later
        LDRH    r4, [r10, #SRC_N]       ; pick up computed value
        STRH    r4, [r10, #SRC_H]       ; store in next pipeline slot also

        MOV     r1, #&2C
        MOV     r0, r4
        BL      WriteAC97               ; set rate in the codec

        STRH    r4, [r10, #SRC_C]       ; and record as current value
d2480 1
a2480 1
        MSR     CPSR_c, #I32_bit+SVC32_mode ; IRQ off please
d2482 1
a2482 1
        MSR     CPSR_c, #SVC32_mode     ; Reenabled IRQs
d2500 6
d2511 6
d2519 10
d2531 1
d2551 3
a2553 2
        MRS     r1, CPSR
        MSR     CPSR_c, #I32_bit :OR: SVC32_mode ; IRQ off please
d2555 20
a2574 1
        MSR     CPSR_c, r1              ; Restore caller's IRQ state
d2576 55
d2654 4
d2663 5
a2667 1
        MOV     r0, #L7200_DMA_DevNo
d2669 1
d2701 5
a2705 1
        MOV     r0, #L7200_DMA_DevNo
d2707 1
d2712 33
a2766 2
        MOV     r0, #&80
        STR     r0, [r2, #DMA_ICR]      ; clear the interrupt
d2798 3
d2805 1
d2810 1
a2810 4
        MOV     r0, r4                  ; compute DMA end

        LDR     r2, [r10, #SoundRMA]
        LDR     r2, [r2, #DMACTRL_base]
d2812 1
a2812 7
        STR     r5, [r2, #DMA_C7NBA]
        STR     r0, [r2, #DMA_C7NTC]

        LDR     r4, [r2, #DMA_UR]       ; check for still underrun
        TST     r4, #&80
        STRNE   r5, [r2, #DMA_C7NBA]
        STRNE   r0, [r2, #DMA_C7NTC]
d2814 63
d2878 26
d2936 1
d2950 2
d2977 2
d2980 1
a2980 1
65  ; Reprogram ASD, if required
d2982 25
a3006 16
        LDRH    r1, [r14, #SRC_C]       ; get currently active SRC value
        LDRH    r4, [r14, #SRC_H]       ; compare against value to apply from now on
        CMP     r4, r1                  ; are they the same?
        BEQ     %FT67

        MOV     r10, r14                ; remember r14
        MOV     r1, #&2C
        MOV     r0, r4
        BL      WriteAC97               ; set rate in the codec

        STRH    r4, [r10, #SRC_C]       ; and record as current value
        MOV     r14, r10                ; (reset local vars pointer after BL)

67      LDRH    r1, [r14, #SRC_N]       ; in any case, step FIFO...
        STRH    r1, [r14, #SRC_H]       ; to keep everything in sync.
        CMP     r4, r1                  ; if new value on NEXT irq, mark update for Level1 now
d3009 12
d3026 3
d3033 1
d3038 1
a3038 1
        MOV     r0, r4                  ; compute DMA end
d3040 2
a3041 10
        LDR     r2, [r14, #SoundRMA]
        LDR     r2, [r2, #DMACTRL_base]
        STR     r5, [r2, #DMA_C7NBA]
        STR     r0, [r2, #DMA_C7NTC]
        MOV     r4, #&80
        STR     r4, [r2, #DMA_ICR]      ; clear the interrupt
        LDR     r4, [r2, #DMA_UR]       ; check for still underrun
        TST     r4, #&80
        STRNE   r5, [r2, #DMA_C7NBA]
        STRNE   r0, [r2, #DMA_C7NTC]
d3043 52
d3096 29
d3141 3
d3148 1
d3155 2
a3156 1
        MOV     r4, r10, LSL #2         ; work out physical length into r4 (Fs*1, 16-bit stereo)
d3159 1
d3164 30
d3196 33
d3235 1
a3235 1
        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs
a3242 3
        ;
        ; KJB - surely better to have separate logical and physical buffers?
        ; maybe not - more cache thrashing?
d3266 1
a3266 1
        MSR     CPSR_c, #I32_bit + IRQ32_mode ; IRQs off again
d3274 6
d3283 15
d3319 1
a3319 2
        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs
        Push    pc                      ; set up return address
a3320 3
        NOP

        MSR     CPSR_c, #I32_bit+IRQ32_mode ; IRQs off again
d3349 6
d3358 6
d3365 1
a3365 3
        LDMFD   sp, {r0,r1}             ; reload (no pop) phys base & limit now

        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs (watch out for r14)
d3370 4
a3373 8
        LDRB    r3, [r11, #Flags]
        MOV     r3, r3, LSR #OverMonoShift
        ANDS    r3, r3, #3              ; bit 0 -> oversamp. bit 1 -> mono
 [ StereoReverse
        BEQ     StereoOnly
 |
        BEQ     BufferDone              ; nowt to do if both bits clear (r3 = 0)
 ]
d3378 11
a3388 11
        ; Set up 0x80008000 in r12, to perform signed/unsigned swap overs
        MOV     r12, #1<<15
        ORR     r12, r12, #1<<31

        ; Create 0xFFFEFFFE in r11 for masking off LSBs, to isolate LH and RH
        ; parts during parallel additions.
        MVN     r11, r12, ROR #15       ; can derive from r12 in one go!

        CMP     r3, #2                  ; check which proc we need to call (1,2,3)
        BEQ     MonoOnly                ; if r3 = 2, do just mono conversion
                                        ; else doing oversampling...
d3391 4
a3394 4
        STR     r2, [sp, #4]            ; store out for later use also
                                        ; switch to appropriate oversampling code
        BLT     OverOnly                ; if r3 < 2 (i.e. 1), only oversample
        B       MonoOver                ; if r3 > 2 (i.e. 3), do mono + oversample
a3396 1
        MSR     CPSR_c, #I32_bit + IRQ32_mode ; redisable IRQs
d3403 26
d3443 3
a3445 1
;     Convert stereo into mono (in same buffer space)
d3449 4
a3452 5
;   r2-r9 free for general use
;   r10 = &FFFF0000
;   r11 = SoundLevel0Base
;   r12 free for general use
;   r14 = unavailable (IRQs enabled)
d3454 1
a3454 1
;   r0-r12,r14 corrupted
d3456 32
a3487 32
MonoOnly        ROUT
01      LDMDB   r1!, {r2,r3,r4,r5}
        ; convert from signed to unsigned format
        EOR     r2, r2, r12
        EOR     r3, r3, r12
        EOR     r4, r4, r12
        EOR     r5, r5, r12
        ; clear off LSB from each value (two in each reg)
        AND     r2, r2, r11
        AND     r3, r3, r11
        AND     r4, r4, r11
        AND     r5, r5, r11
        ; Add the left and right samples together, simultaneously in both upper and
        ; halves of each stereo pair. There will be no
        ; interference between carry out from the RHS MSB into bit 16 (LSB of
        ; LHS sample), and no carry from bit 16 into bit 17, since we cleared
        ; bit 16 in both sources (i.e. bit 16 and bit 0 of pre-rotated single source!)
        ; beforehand; therefore the subsequent right shift will correctly put the
        ; average of the two channel samples back into bits 15..0 (and also into
        ; bits 31..16, using RRX to recover carry out from bit 31).
        ; Get back to signed 16 bit result for each channel afterwards by EOR'ing
        ; with 0x80008000.
        ADDS    r2, r2, r2, ROR #16
        EOR     r2, r12, r2, RRX
        ADDS    r3, r3, r3, ROR #16
        EOR     r3, r12, r3, RRX
        ADDS    r4, r4, r4, ROR #16
        EOR     r4, r12, r4, RRX
        ADDS    r5, r5, r5, ROR #16
        EOR     r5, r12, r5, RRX
        STMIA   r1, {r2,r3,r4,r5}       ; store them all out
        CMP     r1, r0                  ; have we just done last loop?
d3489 2
a3490 1
        B       BufferDone              ; we're all done
d3500 31
a3530 47
OverOnly        ROUT
        MSR     CPSR_c, #SVC32_mode     ; want to use R14...
        Push    r14
        LDR     r14, [r1, #-4]!         ; get last sample in source buffer now
 [ StereoReverse
        EOR     r14, r12, r14, ROR #16  ; convert signed to unsigned and stereo reverse
 |
        EOR     r14, r14, r12           ; convert signed to unsigned
 ]
        AND     r14, r14, r11           ; mask LSB bits from this sample-pair
        ADD     r0, r0, #8*4            ; need to do last group separately, so move base

01      LDMDB   r1!, {r3,r5,r7,r9}      ; load 4 new samples

02      ; convert from signed to unsigned format (into separate regs apart from r3)
 [ StereoReverse
        EOR     r3, r12, r3, ROR #16
        MOV     r5, r5, ROR #16
        EOR     r6, r12, r5
        MOV     r7, r7, ROR #16
        EOR     r8, r12, r7
        MOV     r9, r9, ROR #16
        EOR     r10, r12, r9
 |
        EOR     r3, r3, r12
        EOR     r6, r5, r12
        EOR     r8, r7, r12
        EOR     r10, r9, r12
 ]
        ; clear off LSB from each value (two in each reg)
        AND     r3, r3, r11
        AND     r6, r6, r11
        AND     r8, r8, r11
        AND     r10, r10, r11
        ; oversampling: average pairs and turn back to signed format
        ADDS    r4, r3, r6
        EOR     r4, r12, r4, RRX
        ADDS    r6, r6, r8
        EOR     r6, r12, r6, RRX
        ADDS    r8, r8, r10
        EOR     r8, r12, r8, RRX
        ADDS    r10, r10, r14
        EOR     r10, r12, r10, RRX
        EOR     r14, r12, r14                   ; put r14 back to signed format also
        STMDB   r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results interleaved with originals
        MOV     r14, r3                 ; set lowest sample for end of next group
        CMP     r2, r0                  ; have we just done last normal loop?
d3532 1
a3532 2
        Pull    r14, LO
        BLO     BufferDone              ; all done if done extra, special loop
d3534 7
a3540 11
        ; (r2==r0) for last special loop, pick up very first 3 samples from this buffer
        LDMDB   r1!, {r5,r7,r9}
        ; get last sample from previous buffer, to interpolate for first new sample of this
        LDR     r3, =SoundLevel0Base
        LDR     r3, [r3, #SoundRMA]
 [ StereoReverse
        LDR     r3, [r3, #SavedSample+2]
 |
        LDR     r3, [r3, #SavedSample]
 ]
        B       %B02                    ; use main loop code to do it
a3541 13
 [ StereoReverse
StereoOnly      ROUT
; Reverse stereo only
01      LDMDB   r1!, {r2,r3,r4,r5}      ; get four new samples
        MOV     r2, r2, ROR #16         ; reverse left-right stereo pairs
        MOV     r3, r3, ROR #16
        MOV     r4, r4, ROR #16
        MOV     r5, r5, ROR #16
        STMIA   r1, {r2,r3,r4,r5}       ; write back the four samples
        CMP     r1, r0                  ; have we finished?
        BNE     %B01
        B       BufferDone
 ]
d3544 2
a3545 4
MonoOver        ROUT
        MSR     CPSR_c, #SVC32_mode     ; want to use R14...
        Push    r14
        ADD     r0, r0, #8*4            ; need to do last group separately, so move base
d3547 45
a3591 45
        LDR     r14, [r1, #-4]!         ; get last sample in source buffer now
        EOR     r14, r14, r12           ; convert signed to unsigned
        AND     r14, r14, r11           ; mask LSB bits from this sample-pair
        ADDS    r14, r14, r14, ROR #16  ; convert to mono
        AND     r14, r11, r14, RRX

01      LDMDB   r1!, {r3,r5,r7,r9}      ; get four new samples: signed, full 16-bit, stereo

02      ; convert from signed to unsigned format
        EOR     r3, r3, r12
        EOR     r5, r5, r12
        EOR     r7, r7, r12
        EOR     r9, r9, r12
        ; clear off LSB from each value (two in each reg)
        AND     r3, r3, r11
        AND     r5, r5, r11
        AND     r7, r7, r11
        AND     r9, r9, r11
        ; Monoise unsigned masked versions of input data; since we're also oversampling,
        ; leave in unsigned form and mask off LSBs again
        ADDS    r3, r3, r3, ROR #16
        AND     r3, r11, r3, RRX
        ADDS    r5, r5, r5, ROR #16
        AND     r5, r11, r5, RRX
        ADDS    r7, r7, r7, ROR #16
        AND     r7, r11, r7, RRX
        ADDS    r9, r9, r9, ROR #16
        AND     r9, r11, r9, RRX
        ; then oversample, generating new intermediate values in r4,r6,r8,r10, in signed format
        ADDS    r4, r3, r5
        EOR     r4, r12, r4, RRX
        ADDS    r6, r5, r7
        EOR     r6, r12, r6, RRX
        ADDS    r8, r7, r9
        EOR     r8, r12, r8, RRX
        ADDS    r10, r9, r14
        EOR     r10, r12, r10, RRX
        ; must convert monoised unsigned masked originals back to signed format also
        EOR     r5, r12, r5
        EOR     r7, r7, r12
        EOR     r9, r9, r12
        EOR     r14, r12, r14           ; put r14 back to signed format also for store-out
        STMDB   r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results, interleaved with originals
        MOV     r14, r3                 ; copy lo sample (mono,still unsigned & masked) for next group
        CMP     r2, r0                  ; have we just done last normalloop?
d3593 10
a3602 2
        Pull    r14, LO
        BLO     BufferDone              ; return if just done extra, special loop
a3603 8
        ; r2==r0: finally, pick up very first 3 samples from this buffer
        LDMDB   r1!, {r5,r7,r9}
        ; and last sample from previous buffer, to interpolate for first new sample of this
        LDR     r3, =SoundLevel0Base
        LDR     r3, [r3, #SoundRMA]
        LDR     r3, [r3, #SavedSample]
        ; use main loop code to do final (earliest) 8 samples of output
        B       %B02
d3627 17
a3643 48
; In: R0 = data
;     R1 = register number (bit 20 set => don't wait for response)
; Out: R0, R1 corrupted
WriteAC97    ROUT
        Push    "r2,r3,lr"
        LDR     r14, [r10, #SoundRMA]
        LDR     r3, [r14, #SIC_base]
        MRS     lr, CPSR
        MOV     r0, r0, LSL #4          ; Data
        MOVS    r1, r1, LSL #12         ; Register number  (C set => no wait)
        ORR     r2, lr, #I32_bit
        MSR     CPSR_c, r2
        STR     r1, [r3, #ACCAR]
        STR     r0, [r3, #ACCDR]
        BCS     %FT15
10      LDR     r1, [r3, #SIRSR]                ; Why poll for the result when we don't
        TST     r1, #1                          ; need it? Better would be to set a flag
        BEQ     %BT10                           ; and poll at the next access attempt.
15      MSR     CPSR_c, lr
        Pull    "r2,r3,pc"

; In: R1 = register number
; Out: R0 = data, R1 corrupted
ReadAC97    ROUT
        Push    "r3,lr"
        LDR     r14, [r10, #SoundRMA]
        LDR     r3, [r14, #SIC_base]
        MRS     lr, CPSR
        MOV     r1, r1, LSL #12         ; Register number
        ORR     r1, r1, #1:SHL:19
08      ORR     r0, lr, #I32_bit
        MSR     CPSR_c, r0
        STR     r1, [r3, #ACCAR]
10      LDR     r0, [r3, #SIRSR]
        TST     r0, #1:SHL:18
        BNE     ReadAC97_timeout
        TST     r0, #2
        BEQ     %BT10
        LDR     r0, [r3, #ACSDR]
        MOV     r0, r0, LSR #4
        MSR     CPSR_c, lr
        Pull    "r3,pc"

ReadAC97_timeout
        MOV     r0, #1:SHL:18
        STR     r0, [r3, #SIICR]
        MSR     CPSR_c, lr              ; re-enable IRQs (briefly)
        B       %BT08
d3645 1
d3678 122
@


4.10.4.2
log
@Minor tweak - disables ADCs in codec to save a bit of power.

Version 1.62, 4.8.4.2. Tagged as 'Sound0-1_62-4_8_4_2'
@
text
@a1589 3
        MOV     r0, #1:SHL:8
        MOV     r1, #&26
        BL      WriteAC97               ; disable the ADCs (no sound input required)
d1592 2
a1593 2
        AND     r0, r0, #2_1110         ; wait for green lights from the DACs, mixer
        TEQ     r0, #2_1110             ; and Vref
d1595 3
@


4.10.4.3
log
@Should now work on the pointlessly different MSI and TViLink boards. Maybe.
Set BOARD to the appropriate value, as in the HAL.

Version 1.62, 4.8.4.3. Tagged as 'Sound0-1_62-4_8_4_3'
@
text
@a878 3
 [ KBCOLReset
KEYBOARD_base     #  4
 |
a879 1
 ]
a1524 6
 [ KBCOLReset
        LDR     r0, [r14, #KEYBOARD_base]
        LDR     r1, [r0, #KBDR]
        BIC     r1, r1, #1              ; pull reset low
        STR     r1, [r0, #KBDR]
 |
a1528 1
 ]
a1559 3
 [ KBCOLReset
        LDR     r1, [r14, #KEYBOARD_base]
 |
a1560 1
 ]
a1564 8
 [ KBCOLReset
        LDR     r0, [r1, #KBDR]
        ORR     r0, r0, #1:SHL:5
        STR     r0, [r1, #KBDR]
        LDR     r0, [r1, #KBDMR]        ; bring AC97 codec out of reset
        BIC     r0, r0, #1:SHL:5        ; using GPIO lines
        STR     r0, [r1, #KBDMR]
 |
a1570 1
 ]
a2043 8
 [ KBCOLReset
        MOV     r0, #13
        LDR     r1, =KEYBOARD_BASE_PHYS
        MOV     r2, #&1000
        SWI     XOS_Memory
        LDRVS   r3, =KEYBOARD_BASE
        STR     r3, [r4, #KEYBOARD_base]
 |
a2049 1
 ]
@


4.10.2.1
log
@A version of SoundDMA that will work on the Alba 2 board, using FIQs for
buffer handover so it works on revision B parts.
No attempt at any sort of HAL interface, or use of the DMA manager, but it's
good enough for Alba 2.
Except if anyone ones to try anything like software IR reception, they'll
have to figure out how to integrate this FIQ handler into theirs.

Version 1.62, 4.8.2.1. Tagged as 'Sound0-1_62-4_8_2_1'
@
text
@d165 20
d216 21
d272 9
a280 6
; for SIB_ASD.
SIB_ASD_N # 1   ; (new) value to stick into SIB to program audio sample rate divisor
SIB_ASD_H # 1   ; value which IRQ code should ensure is in ASD on next irq
SIB_ASD_C # 1   ; softcopy of value currently set in SIB

Spare2    # 3
d286 3
d290 1
d292 3
a294 3
ImagesC_N # 4   ; compacted (new) version of Images, for prog'ing conv. routine
ImagesC_H # 4   ; value which IRQ code will load into conv. routine on next irq
ImagesC_C # 4   ; softcopy of value currently programmed into conv. routine
d299 1
a299 1
; CURRENTLY 6 BYTES SPARE.
d305 1
a305 1
SCPeriod     * 48                       ; default, i.e. 20.8333 kHz
d320 5
a324 1
Lin16Shift      *       2
d327 1
a327 1
MinOSPeriod     *       42              ; do not oversample if period < 42 (f > 24kHz)
d331 1
d334 3
d338 24
a361 1
        GET     hdr.CL9200
d400 3
d404 11
a415 1
        DCB     " CL92xx I2S version"
d479 1
d563 1
a563 1
        Pull    PC, EQ                  ; return if so
d828 1
a828 1
;   SVC or IRQ mode, IRQs disabled (essential for atomic rewrite of code!)
d933 3
a935 11
        STMFD   sp!,{r0-r2}
        MRS     r3, CPSR
        MSR     CPSR_c, #I32_bit+SVC32_mode
        MOV     r5, lr_svc
        SUB     r2, r1, #4
        MOV     r1, r0
        MOV     r0, #1
        SWI     XOS_SynchroniseCodeAreas
        MOV     lr_svc, r5
        MSR     CPSR_c, r3
        LDMFD   sp!,{r0-r2}
d943 1
d953 1
d959 1
a961 3
 [ RevB
WantFIQ           #  4
 ]
d964 1
d966 13
a978 25
WorkSpaceSize     * @@

; Our base clock frequency is 1440kHz - available rates are 1440kHz/div,
; where div ranges from 30 to 127. Below 24kHz we may oversample, so need to
; be able to double the frequency. Hence, only even divisors above 60 are reported.


ftab
        GBLA    asd_div
        GBLA    freq
        GBLA    nsr
nsr     SETA    0
asd_div SETA    126
        WHILE   asd_div >= 30
freq    SETA    (1440000*1024+(asd_div/2))/asd_div

        DCD     freq                                    ; frequency (to closest 1/1024Hz)
        DCB     (1024*1000000 + (freq/2)) / freq        ; rate (to closest us)
        DCB     asd_div                                 ; divisor value
        DCB     0                                       ; padding
        DCB     0
 [ asd_div > 60
asd_div SETA    asd_div - 2
 |
asd_div SETA    asd_div - 1
a979 2
nsr     SETA    nsr + 1
        WEND
d981 1
a981 1
        ALIGN
d1120 1
a1120 1
        DCB     "16bit [Oversampled] | <D>",0
d1132 3
a1134 1
        ADR     r0, parameter_16bit
d1150 11
d1206 2
d1305 2
a1306 3
        MRS     R10, CPSR
        Push    "R10,R14"
        MSR     CPSR_c, #I32_bit :OR: SVC32_mode
d1308 7
a1314 3
        Pull    "R10,R14"
        MSR     CPSR_c, R10             ; restore interrupts
        MOV     PC,R14                  ; 32-bit exit: NZ corrupted, CV passed back
d1394 1
d1396 10
a1405 4

        MOV     lr, #SoundDMABufferSize ; limit no. samples to
        CMP     r1, lr, LSR #2          ; 4096/4=1024
        MOVGT   r1, lr, LSR #2          ; (largest form always 16bit stereo)
d1408 3
a1410 3
        CMP     r1, lr, LSR #2
        MOVLT   r1, lr, LSR #2

d1459 3
a1461 2
;       WorkOutVIDCParams - Compute SIB ASD value from
;       present configuration: no. of channels, sample period.
d1466 1
d1470 2
a1471 1
;       SIB_ASD_N holds ASD value to program into SIB
d1475 1
d1480 30
d1522 6
a1527 2
        MOV     r5, #nsr
        ADRL    r4, ftab-8              ; address 0th entry of main freq info table
d1529 2
a1530 1
22      ADD     r1, r4, lr, LSL #3      ; address entry in table
d1544 2
a1545 1
        ADD     r1, r4, lr, LSL #3      ; address entry in table
d1554 2
a1555 1
        ADD     r1, r4, lr, LSL #3      ; address entry in table
d1566 1
a1566 1
        LDRB    r3, [r1, #5]            ; pick up unadjusted ASD value
d1568 1
d1574 1
a1574 1
; r3 is SIB ASD to program, unadjusted, assuming no oversampling
d1576 1
d1581 1
d1589 1
a1589 1
        STRB    r3, [r10, #SIB_ASD_N]   ; store for prog'ing under IRQ
d1596 1
a1596 1
;      r3 = unadjusted ASD value, for non-oversampling case
d1601 1
a1601 1
;      r3 = unadjusted ASD for normal or oversampling as required
d1605 4
a1608 1
        TST     r0, #OversampleFlag     ;   && auto oversample flag is set)
d1615 1
a1615 1
        CMP     r1, #SoundDMABufferSize/4 ; check against size limit at Fs*2
d1623 38
d1684 2
a1685 1
        LDR     r12, =DMA_BASE       ; Address DMA controller
d1687 28
a1714 2
        MOV     r1, #0
        STR     r1, [r12, #DMACONT0]     ; Disable DMA
d1718 3
d1733 10
a1742 9
        Push    "r2"
        MOV     r2, r10
        MRS     r0, CPSR
        BIC     r1, r0, #M32_bits
        ORR     r1, r1, #F32_bit + I32_bit + FIQ32_mode
        MSR     CPSR_c, r1
        LDR     r9_fiq, [r2, #Phys0]        ; set current pointer = buffer base
        MSR     CPSR_c, r0
        Pull    "r2"
d1744 36
a1779 1
        LDR     r12, =DMA_BASE       ; Address DMA controller
d1781 15
a1795 5
        LDR     r0, =AC97_BASE_PHYS + TXBUF
        STR     r0, [r12, #DMADEST0]    ; set peripheral address

        LDR     r0, =2_1111000001000010  ; ask for interrupt generation
        STR     r0, [r12, #DMACONT0]
d1826 15
d1842 1
d1891 1
d1940 5
d1950 1
a1950 1
        MOV     r1, #2                  ; internal clock only
d1974 1
a1974 1
        LDRB    r3, [r10, #SIB_ASD_N]   ; pick up current ASD into r3
d1979 1
a1979 1
        STRB    r3, [r10, #SIB_ASD_N]   ; and store ASD
d2046 6
d2096 83
d2180 8
d2192 2
a2193 1
        MOV     r1, #nsr
d2211 1
a2211 1
        EXIT                            ; all done!
d2222 1
a2222 1
        LDRB    r3, [r4, #5]            ; get ASD w/o oversampling
d2227 2
a2228 2
        BL      process_oversample      ; work out whether o/s needed, fix ASD if so
        STRB    r3, [r10, #SIB_ASD_N]   ; store ASD for later programming
d2230 2
d2260 4
d2265 1
a2265 1
        CMP     r1, #nsr                ; check against limit (unsigned)
d2269 3
a2271 2
        ADRL    r3, ftab-8              ; address main table 0th entry
        ADD     r2, r3, r1, LSL #3      ; index into main table (8 bytes each)
d2275 2
a2293 6
        [ RevB
        MOV     r1, #Service_ClaimFIQ
        SWI     XOS_ServiceCall
        BL      InstallFIQHandler
        ]

d2298 1
d2304 10
a2313 2
 [ RevB
        STR     r0, [r2, #WantFIQ]
d2323 1
d2334 3
d2347 5
d2372 8
d2396 5
d2402 1
d2408 1
d2410 1
d2412 5
a2416 11
 [ RevB
        MRS     r2, CPSR
        BIC     lr, r2, #M32_bits
        ORR     lr, lr, #F32_bit+I32_bit+FIQ32_mode
        MSR     CPSR_c, lr
        MOV     r9_fiq, r1
        MOV     r8_fiq, r6, LSR #2
        SUB     r8_fiq, r8_fiq, #1
        LDR     r10_fiq, =2_0111000001000011
        MSR     CPSR_c, r2
        BL      InstallFIQHandler
d2418 32
a2449 3
        LDR     r0, =DMACTRL_BASE
        STR     r1, [r0, #DMA_C7NBA]
        STR     r6, [r0, #DMA_C7NTC]
d2459 20
a2478 20
        ; Set SIB sample rate now, not later
        LDRB    r4, [r10, #SIB_ASD_N]   ; pick up computed value
        STRB    r4, [r10, #SIB_ASD_H]   ; store in next pipeline slot also

        MSR     CPSR_c, #I32_bit+SVC32_mode ; IRQ off please
        STRB    r4, [r10, #SIB_ASD_C]   ; and record as current value
        LDR     r1, =SYSCON_BASE
        LDR     r2, [r1, #I2SDIV]
        BIC     r2, r2, #&000000FF
        BIC     r2, r2, #&003F4000
        BIC     r2, r2, #&40000000
        ORR     r2, r2, #&80000000
        ORR     r2, r2, #&00008000
        ORR     r2, r2, r4, LSL #1
        MOVS    r4, r4, LSR #1
        ORR     r2, r2, r4, LSL #16
        ORRCS   r2, r2, #&40000000
        MOV     r0, #&AA
        STR     r0, [r1, #SYSLOCK]
        STR     r2, [r1, #I2SDIV]
d2480 1
d2482 1
a2482 1
        MSR     CPSR_c, #SVC32_mode     ; Reenabled IRQs
d2493 2
a2494 3
       ASSERT   Service_ReleaseFIQ < Service_ClaimFIQ
       ASSERT   Service_ClaimFIQ   < Service_Reset
       ASSERT   Service_Reset      < Service_ClaimFIQinBackground
a2498 4
 [ RevB
        DCD     Service_ReleaseFIQ
        DCD     Service_ClaimFIQ
 ]
d2500 6
a2505 3
 [ RevB
        DCD     Service_ClaimFIQinBackground
 ]
d2511 6
a2516 5
 [ RevB
        TEQNE   r1,#Service_ClaimFIQ
        TEQNE   r1,#Service_ClaimFIQinBackground
        TEQNE   r1,#Service_ReleaseFIQ
 ]
d2519 3
a2521 6
 [ RevB
        TEQ     r1, #Service_ClaimFIQ
        TEQNE   r1, #Service_ClaimFIQinBackground
        BEQ     Serv_ClaimFIQ
        TEQ     r1, #Service_ReleaseFIQ
        BEQ     Serv_ReleaseFIQ
d2523 6
d2531 1
d2551 3
a2553 2
        MRS     r1, CPSR
        MSR     CPSR_c, #I32_bit :OR: SVC32_mode ; IRQ off please
d2555 20
a2574 1
        MSR     CPSR_c, r1              ; Restore caller's IRQ state
d2576 55
d2654 3
a2656 5
        LDR     r2, =AC97_BASE
        LDR     r0, =&00040002
        STR     r0, [r2, #SERMC]
        LDR     r0, =&40000001
        STR     r0, [r2, #TSLTMP+0]
d2663 5
a2667 1
        MOV     r0, #CL9200_DMA_DevNo
d2669 1
a2697 11
 [ RevB
        MOV     r0, #0
        STR     r0, [r12, #WantFIQ]
        MOV     r1, #Service_ReleaseFIQ
        SWI     XOS_ServiceCall
 ]

        MOV     r0, #0
        LDR     r2, =AC97_BASE
        STR     r0, [r2, #SERMC]

d2701 5
a2705 1
        MOV     r0, #CL9200_DMA_DevNo
d2707 1
d2712 33
a2766 3
        MOV     r0, #FIQdowngrade_bit
        LDR     r2, =INT_BASE
        STR     r0, [r2, #CLRIRQMSKA]
d2798 3
d2805 1
d2810 3
a2812 1
        MOV     r0, r4                  ; compute DMA end
d2814 63
a2876 8
        MRS     r2, CPSR
        BIC     lr, r2, #M32_bits
        ORR     lr, lr, #F32_bit + I32_bit + FIQ32_mode
        MSR     CPSR_c, lr
        MOV     r8_fiq, r0, LSR #2
        SUB     r8_fiq, r8_fiq, #1
        MOV     r9_fiq, r5
        MSR     CPSR_c, r2
d2878 26
d2936 1
d2950 2
d2977 2
d2980 1
a2980 1
65  ; Reprogram ASD, if required
d2982 25
a3006 25
        LDRB    r1, [r14, #SIB_ASD_C]   ; get currently active ASD value
        LDRB    r4, [r14, #SIB_ASD_H]   ; compare against value to apply from now on
        CMP     r4, r1                  ; are they the same?
        BEQ     %FT67

        STRB    r4, [r14, #SIB_ASD_C]   ; and record as current value

        LDR     r1, =SYSCON_BASE
        LDR     r2, [r1, #I2SDIV]
        BIC     r2, r2, #&000000FF
        BIC     r2, r2, #&003F4000
        BIC     r2, r2, #&40000000
        ORR     r2, r2, #&80000000
        ORR     r2, r2, #&00008000
        ORR     r2, r2, r4, LSL #1
        MOVS    r4, r4, LSR #1
        ORR     r2, r2, r4, LSL #16
        ORRCS   r2, r2, #&40000000
        MOV     r0, #&AA
        STR     r0, [r1, #SYSLOCK]
        STR     r2, [r1, #I2SDIV]

67      LDRB    r1, [r14, #SIB_ASD_N]   ; in any case, step FIFO...
        STRB    r1, [r14, #SIB_ASD_H]   ; to keep everything in sync.
        CMP     r4, r1                  ; if new value on NEXT irq, mark update for Level1 now
d3009 12
d3026 3
d3033 1
d3038 1
a3038 1
        MOV     r0, r4                  ; compute DMA end
d3040 2
a3041 8
        MRS     r2, CPSR
        BIC     r4, r2, #M32_bits
        ORR     r4, r4, #F32_bit + I32_bit + FIQ32_mode
        MSR     CPSR_c, r4
        MOV     r8_fiq, r0, LSR #2
        SUB     r8_fiq, r8_fiq, #1
        MOV     r9_fiq, r5
        MSR     CPSR_c, r2
d3043 52
d3096 29
d3141 3
d3148 1
d3155 2
a3156 1
        MOV     r4, r10, LSL #2         ; work out physical length into r4 (Fs*1, 16-bit stereo)
d3159 1
d3164 30
d3196 33
d3235 1
a3235 1
        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs
a3242 3
        ;
        ; KJB - surely better to have separate logical and physical buffers?
        ; maybe not - more cache thrashing?
d3266 1
a3266 1
        MSR     CPSR_c, #I32_bit + IRQ32_mode ; IRQs off again
d3274 6
d3283 15
d3319 1
a3319 2
        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs
        Push    pc                      ; set up return address
a3320 3
        NOP

        MSR     CPSR_c, #I32_bit+IRQ32_mode ; IRQs off again
d3349 6
d3358 6
d3365 1
a3365 3
        LDMFD   sp!, {r0,r1}            ; reload phys base & limit now

        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs (watch out for r14)
d3370 3
a3372 3
        LDRB    r3, [r11, #Flags]
        MOV     r3, r3, LSR #OverMonoShift
        ANDS    r3, r3, #3              ; bit 0 -> oversamp. bit 1 -> mono
d3397 31
a3427 1
        MSR     CPSR_c, #I32_bit + IRQ32_mode ; redisable IRQs
d3443 3
a3445 1
;     Convert stereo into mono (in same buffer space)
d3449 4
a3452 5
;   r2-r9 free for general use
;   r10 = &FFFF0000
;   r11 = SoundLevel0Base
;   r12 free for general use
;   r14 = unavailable (IRQs enabled)
d3454 1
a3454 1
;   r0-r12,r14 corrupted
d3492 1
a3500 2
        MSR     CPSR_c, #SVC32_mode     ; want to use R14...
        Push    r14
a3531 1
        Pull    r14, LO
a3544 2
        MSR     CPSR_c, #SVC32_mode     ; want to use R14...
        Push    r14
a3592 1
        Pull    r14, LO
a3604 1

d3627 19
d3678 114
a3791 6
 [ RevB
Serv_ReleaseFIQ
        LDR     r1, [r12, #WantFIQ]
        TEQ     r1, #0
        MOVEQ   r1, #Service_ReleaseFIQ
        MOVEQ   pc, lr
d3793 4
a3796 52
        MOV     r1, #Service_Serviced
InstallFIQHandler
        Entry   "r0-r6"
        ADR     r1, FIQHandler
        LDMIA   r1, {r2-r6}
        MOV     r1, #&1C
        STMIA   r1, {r2-r6}
        MOV     r0, #1
        ADD     r2, r1, #20-4
        SWI     XOS_SynchroniseCodeAreas
        MRS     r0, CPSR
        BIC     r1, r0, #M32_bits
        ORR     r1, r1, #F32_bit + I32_bit + FIQ32_mode
        LDR     r2, =SoundLevel0Base
        LDR     r4, [r2, #Config]
        LDR     r3, [r2, #Phys0]
        MOV     r6, r4, LSL #16
        MOV     r6, r6, LSR #16
        MOV     r5, r4, LSR #24
        TST     r5, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r5, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r5, #3                 ; but 8 bytes/sample if o/s
        MOV     r6, r6, LSL r5
        MSR     CPSR_c, r1
        MOV     r8_fiq, r6, LSR #2
        SUB     r8_fiq, r8_fiq, #1
        MOV     r9_fiq, r3
        LDR     r10_fiq, =2_0111000001000011
        MOV     r11_fiq, #FIQdowngrade_bit
        LDR     r12_fiq, =INT_BASE
        LDR     r13_fiq, =DMA_BASE
        MSR     CPSR_c, r0
        MOV     r0, #DMA0_bit
        LDR     r1, =INT_BASE
        STR     r0, [r1, #FIQMASKA]
        EXIT

Serv_ClaimFIQ
        MOV     r1, #Service_Serviced
RemoveFIQHandler
        Entry   r0
        LDR     r0, =INT_BASE
        MOV     lr, #DMA0_bit
        STR     lr, [r0, #CLRFIQMSKA]
        EXIT

FIQHandler
        STR     r8_fiq, [r13_fiq, #DMATC0]
        STR     r9_fiq, [r13_fiq, #DMASRC0]
        STR     r10_fiq, [r13_fiq, #DMACONT0]
        STR     r11_fiq, [r12_fiq, #IRQMASKA]
        SUBS    pc, lr, #4
d3798 2
@


4.9
log
@
  * Removed dependency on obsolete STB flag.

Detail:

  * Default sample frequency os 20.8333kHz restored, which is what most
    software relies upon to do its calculations when playing sound samples.
    (There was probably a time when the clock frequencies weren't available
    on STB/NC hardware and therefore 22.05KHz was used instead.)

    The result is that both Desktop and Embedded variants are identical.

Admin:

  * Built and tested on Lazarus 32-bit build.

  * Removed build-specific directories in "rm", sinc these are created
    during assembly.

Version 1.60. Tagged as 'Sound0-1_60'
@
text
@d368 1
a368 1
        LEADR   Module_LoadAddr
d397 1
a397 4
        DCB     "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        DCB     " $Module_MinorVersion"
 ]
d986 1
a986 1
Audio_Code ENTRY
d1109 1
a1109 1
        ENTRY   "r1-r3"
d1222 1
a1222 1
        ENTRY   "r2"
d1246 1
a1246 1
        ENTRY
d1310 1
a1310 1
        mrs  AL,R10,CPSR                ; NOP on pre-ARM6
d1349 1
a1349 1
Sound0Config ENTRY
d1602 1
a1602 1
process_oversample ENTRY "r1,r2"
d1671 1
a1671 1
Sound0Enable ENTRY "r1"
d1859 1
a1859 1
Sound0Stereo ENTRY "r0, r2"
d1938 1
a1938 1
Sound0Mode      ENTRY   "r2"
d2045 1
a2045 1
Sound0LinearHandler ENTRY "r3,r4,r5"
d2179 1
a2179 1
Sound0SampleRate ENTRY "r3,r4"
d2281 1
a2281 1
Initialise_Module ENTRY "r7, r8, r10, r11"
d2533 1
a2533 1
        ENTRY   "r0-r4, r10, r11"
d2565 1
a2565 1
        ENTRY   "r0-r4, r10"
d2639 1
a2639 1
InitResetCommon ENTRY
d2675 1
a2675 1
Finalise_Module ENTRY "r10, r11"
d2724 1
a2724 1
SetupVIDCMultiplier ENTRY
d2754 1
a2754 1
Divide  ENTRY
d3612 1
a3612 1
ConvImages ENTRY r1
d3633 1
a3633 1
ProgramImages ENTRY "r0-r3"
d3649 1
a3649 1
CopyError ENTRY r1-r7
d3665 1
a3665 1
open_messagefile ENTRY r0-r2
d3684 1
a3684 1
GetPower ENTRY "r1,r10,r11"
d3708 1
a3708 1
SetPower ENTRY "r1,r10,r11"
d3799 1
a3799 1
    GET s.Sound0_SA
@


4.8
log
@* Fixed error in sample rate selection: would choose 2nd closest match
  instead of closest match if the exact sample period requested by
  Sound_Configure was unavailable.
* Obsolete VIDC1 code removed (that's VIDC1 as in the A500 as opposed to
  the VIDC1a used in all production Archimedes).
* Interrupts enabled during 16-bit buffer zeroing, as a simple way to
  begin to reduce the interrupt latency.

Version 1.59. Tagged as 'Sound0-1_59'
@
text
@d124 1
d305 1
a305 5
 [ STB
SCPeriod     * 45                       ; use 45us (22.05kHz) for STBs & NCs
 |
SCPeriod     * 48                       ; default, i.e. 20.8333 kHz
 ]
a410 3
   [ STB
        DCB     " STB/NC version"
   |
a411 1
   ]
@


4.7
log
@Minor tweak to module header to use new constant and ensure correct layout.

Version 1.58. Tagged as 'Sound0-1_58'
@
text
@a169 3
 [ VIDC_Type = "VIDC1"
VarSndClock     SETL    {TRUE}
 ]
a411 3
 [ VIDC_Type = "VIDC1"
        DCB     " A500 version"
 ]
a488 34
; OSS Code to modify the DMA buffer so the contents are right for the VIDC1
; in an A500 (the sign bit is at the other end of each byte).  The code is
; copied into the RMA and excuted from there (via SoundRMA point in the
; SoundLevel0 workspace). This is to lessen the chances of getting over-runs
; on 8MHz ARM2 A500s with SoundDMA in ROM.

 [ VIDC_Type = "VIDC1"
        ; constant &80808080 in R0
        ; buffer end in r10
        ; buffer start in r12

        MACRO
        Convert4Bytes $reg
        AND     r5, r0, $reg, LSL #7
        BIC     $reg, $reg, r0, LSR #7
        ORR     $reg, r5, $reg, LSR #1
        MEND

A500CodeStart ROUT
        LDMIA   r12, {r1-r4}

        Convert4Bytes r1
        Convert4Bytes r2
        Convert4Bytes r3
        Convert4Bytes r4

        STMIA   r12!, {r1-r4}
        CMP     r12, r10
        BLO     A500CodeStart
        MOV     pc, lr                          ; OSS Don't use MOVS here
A500CodeEnd
A500CodeSize    * A500CodeEnd - A500CodeStart
 ]

a975 4
 [ VIDC_Type = "VIDC1"
A500Code          #  A500CodeSize       ; Code goes here in RMA
 ]

d1560 2
a1561 2
        CMP     r7, r8                  ; if r7 > r8 then we have best match
        BGT     %FT26                   ; so accept the current entry
a2324 10
 [ VIDC_Type = "VIDC1"
        ADD     r3, r2, #A500Code       ; Code in RMA workspace
        ADRL    r1, A500CodeStart       ; Code in module
        ADRL    r2, A500CodeEnd         ; End of code in module

01      LDR     r0, [r1], #4
        STR     r0, [r3], #4
        CMP     r1, r2
        BLO     %BT01
 ]
a3181 18
  [ VIDC_Type = "VIDC1"
; OSS Call code to modify the DMA buffer so the contents are right for the
; VIDC1 in an A500 (the sign bit is at the other end of each byte).

        ; Constant &80808080 in R0
        ; buffer end in r10
        ; buffer start in r12

        MOV     r0, #&80
        ORR     r0, r0, r0, ASL #8
        ORR     r0, r0, r0, ASL #16     ; Set constant up

        LDR     r1, =SoundLevel0Base    ; Workspace pointer
        LDR     r1, [r1, #SoundRMA]     ; Address fixup code via RMA pointer
        MOV     lr, pc                  ; set return address and
        ADD     pc, r1, #A500Code       ; jump to fixup code
  ]

d3245 2
d3275 2
@


4.6
log
@  32-bit compatibility.
Detail:
  Code updated to use macros from HdrSrc for mode changing and IRQ
    state updates.
Admin:
  Tested 26-bit and 32-bit builds on Risc PC by pressing ^G to generate
    the system beep, Maestro to play several sounds concurrently, and
    Replay to play audio files.

Tagged as SoundDMA-1_57

Version 1.57. Tagged as 'Sound0-1_57'
@
text
@d390 2
d490 1
a490 1
        DCD     1       ; 32-bit compatible
@


4.5
log
@Spinner and Ursula branches merged.
Changed to use srccommit.

Version 1.56. Tagged as 'Sound0-1_56'
@
text
@a152 2
;        GET     Hdr:IO.IOMD
;        GET     Hdr:MEMC.MEMC2
d391 3
d486 5
d1071 1
a1071 1
        ORRS    pc, lr, #Z_bit          ; EQ -> ON
d1086 1
a1086 1
        BICS    pc, lr, #Z_bit          ; NE -> OFF
d1095 1
a1095 1
        ORRS    pc, lr, #V_bit
d1357 10
d1368 1
a1369 1
        TEQP    pc, #I_bit+SVC_mode     ; Disable IRQs, I think we expect this
d1372 1
a1372 1
        BICS    pc, lr, #V_bit          ; Reenable caller's IRQ state
d1507 1
a1507 1
        EXITS
d1642 1
a1642 2
        Pull    "r0,r1,r3,lr"           ; pop log2nchan, old r1, old r3, return PC
        MOVS    pc, lr                  ; and go home
d1850 1
a1850 1
        EXITS                           ; Restores ints to caller state, maybe
d1895 1
a1895 1
        MOVS    pc, lr
d1916 1
a1916 1
        EXITS   HS
d1930 1
a1930 1
        EXITS   HS
d1941 1
a1941 1
        EXITS                           ; go back to caller
d2007 1
a2007 1
        EXITS
d2034 1
a2034 1
        EXITS
d2051 1
a2051 1
        EXITS
d2054 1
a2054 1
        EXITS
d2102 1
a2102 1
        EXITS   EQ
d2115 1
a2115 1
        EXITS                           ; and go home
d2237 1
a2237 1
        EXITS   EQ
d2246 1
a2246 1
        EXITS
d2254 1
a2254 1
        EXITS
d2263 1
a2263 1
        EXITS                           ; all done!
d2292 1
a2292 1
        EXITS                           ; all done
d2301 1
a2301 1
        ORRS    pc, lr, #V_bit
d2541 2
a2542 1
        TEQP    pc, #I_bit + SVC_mode   ; IRQ off please
d2544 1
a2544 1
        TEQP    pc, #SVC_mode           ; Reenable IRQs
d2607 1
a2607 1
        EXITS   NE
d2611 1
a2611 1
        EXITS   VS                      ; Can't raise error from service
d2613 3
a2615 1
        TEQP    pc, #I_bit + SVC_mode   ; IRQ off please
d2620 4
a2623 1
        EXITS                           ; Restore caller's IRQ state
d2652 1
a2652 1
        Pull    "r0,r10,r11,pc",EQ,^            ; no then just pass on the service
d2671 1
a2671 1
        Pull    "r0,r10,r11,pc",,^              ; then claim service to save time
d2676 1
a2676 1
        Pull    "r0,r10,r11,pc",,^
d2680 1
a2680 1
        MOVNES  pc, lr
d2691 1
a2691 1
        Pull    "r0,r10,r11,pc",,^
d2751 2
a2752 1
        TEQP    pc, #I_bit + SVC_mode   ; IRQ off please
d2755 2
a2756 1
        TEQP    pc, #SVC_mode           ; Reenable IRQs
d2770 2
a2771 1
        EXITS                           ; Don't refuse to die
d3304 1
a3304 1
        TEQP    pc, #SVC_mode           ; Into SVC mode, enable IRQs.
d3352 1
a3352 1
        TEQP    pc, #IRQ_mode+I_bit
d3361 1
a3361 1
        TEQP    pc, #SVC_mode
d3427 1
a3427 1
        TEQP    pc, #IRQ_mode+I_bit
d3436 1
a3436 1
        TEQP    pc, #SVC_mode
d3482 1
a3482 1
        TEQP    pc, #IRQ_mode+I_bit     ; Back to IRQ mode, IRQs disabled.
d3773 1
a3773 1
        EXITS
d3790 1
a3790 1
        EXITS   EQ                              ; then do nothing
d3794 1
a3794 1
        EXITS   EQ
d3800 1
a3800 1
        EXITS   VC
d3806 1
a3806 1
        EXITS
d3855 1
a3855 1
        Pull    "PC",EQ,^
d3858 2
a3859 2
        MOV     r3, pc
        TEQP    pc, #SVC_mode + I_bit
d3866 1
a3866 2
       ;SetPSR  r3
        TEQP    r3, #0
d3869 1
a3869 1
        Pull    "PC",,^
d3884 1
@


4.4
log
@Spinner branch merged
@
text
@d163 1
d400 4
a403 1
        DCB     "$Version ($CurrentDate)"
d2537 17
d2555 10
@


4.4.2.1
log
@update to Ursula service format
@
text
@a2532 17
;Ursula format
;
       ASSERT   Service_Reset      < Service_ModeChange
       ASSERT   Service_ModeChange < Service_Portable
;
UServTab
        DCD     0
        DCD     UService - Module_Base
        DCD     Service_Reset
  [ VarSndClock
        DCD     Service_ModeChange
  ]
  [ StorkPower
        DCD     Service_Portable
  ]
        DCD     0
        DCD     UServTab - Module_Base
a2533 10
        MOV     r0,r0
        TEQ     r1,#Service_Reset
  [ StorkPower
        TEQNE   r1,#Service_Portable
  ]
  [ VarSndClock
        TEQNE   r1,#Service_ModeChange
  ]
        MOVNE   PC,LR
UService
@


4.3
log
@Version RO_3_71 merged
@
text
@d117 8
d126 2
a127 2
          GBLL    StrongARM
StrongARM SETL    {TRUE}
d164 1
d308 3
d312 2
d320 3
a322 2
; 1 bit spare, with top bit reserved (probably unnecessarily) for Level1Fill handler
; call "Level0 updated" flag.
d324 1
d413 5
a417 1
        DCB     " VIDC20/IOMD version"
d1939 3
d1948 1
d1964 2
d1986 2
d2018 1
a2018 1
        BNE     %FT99
d2020 14
d3386 3
a3388 4
        LDMFD   sp!, {r0,r1}            ; reload up phys base & limit now
        ; Finally, perform oversampling if required.  Ideally, the mu-law-to-
        ; linear code would do this itself, but it would get messy if 16-bit
        ; output is also being generated (which sample rate to use for 16-bit?)
d3391 19
a3409 7
        LDR     r9, [r11, #SoundRMA]
        LDR     r10, [r9, #SavedSample] ; pick up saved sample from prev buffer, for use below
        LDR     r6, [r1, #-4]!          ; get last pair of samples in this buffer
        STR     r6, [r9, #SavedSample]  ; save off for next time round, anyway
        LDRB    r2, [r11, #Flags]       ; now check for oversamping
        TST     r2, #DoOversample       ; oversampling in effect?
        BEQ     %98                     ; nowt more to do if not
a3410 1
        ADD     r2, r2, #4              ; correct for decr of r1 above
d3412 12
a3424 25
        MOV     r4, r6, ASR #16         ; split last sample of this buffer into L and R
        MOV     r5, r6, LSL #16
        MOV     r5, r5, ASR #16

88      CMP     r1, r0                  ; on last sample?  (SETS CC FOR TEST AT END)
        LDRNE   r3, [r1, #-4]!          ; if not, get next pair from this buffer (backwards)
        MOVEQ   r3, r10                 ; else use saved pair from end of prev buffer
        MOV     r7, r3, ASR #16         ; and split up
        MOV     r8, r3, LSL #16
        MOV     r8, r8, ASR #16

        ADD     r4, r4, r7              ; add left values
        ADD     r5, r5, r8              ; and right values
        MOV     r4, r4, ASR #1          ; divide by 2 (left)
        MOV     r5, r5, ASR #1          ; divide by 2 (right)
        MOV     r4, r4, LSL #16         ; recombine
        MOV     r5, r5, LSL #16
        ORR     r4, r4, r5, LSR #16
        STMDB   r2!, {r4, r6}           ; save out previous pair and intermediate pair
        MOV     r6, r3                  ; cycle values for next set
        MOV     r4, r7
        MOV     r5, r8
        CMP     r2, r0                  ; have we just written last sample?
        BNE     %B88                    ; round again if not
98
d3457 167
@


4.2
log
@Module merged
@
text
@d120 2
d1545 1
a1545 1
        SUBS    r7, r3, r2              ; place (entry - freq) in r7 
d1547 1
a1547 1
        BPL     %FT24                   ; else if freq > entry, then look at next entry 
d1554 1
a1554 1
        BEQ     %FT26     
@


4.1
log
@Initial revision
@
text
@d118 3
d213 5
d219 1
a219 1
EnableIRQsIn16bit       SETL    True
d221 1
d225 4
d288 2
d291 1
a291 1
; CURRENTLY ONE WORD SPARE (FOR VIDC20).
d300 1
d382 8
d439 7
d528 1
d726 1
a726 1
        MOV     r7, r3, ASR #17
d745 13
a757 2
; (8a): First the *11 code, the same for all configurations
scale_mul
d763 46
a808 14
; (8b): Then the /N code (N=8,16,32,64) which is 2 instructions; table indexed
; by log2nchan.
scale_div_TAB
        MOV     r6, r6, ASR #3          ; 1 channel
        MOV     r7, r7, ASR #3

        MOV     r6, r6, ASR #4          ; 2 channels
        MOV     r7, r7, ASR #4

        MOV     r6, r6, ASR #5          ; 4 channels
        MOV     r7, r7, ASR #5

        MOV     r6, r6, ASR #6          ; 8 channels
        MOV     r7, r7, ASR #6
d836 1
a836 1
; +     size of sequence(8a;8b;9;10;11)          +      (4 + 2 + 3 + 1 + 1))
d838 1
a838 1
MAXLinConvCodeSize *  4 * ((2 + 2 + 1 + 1) + 8 * (1 + 1 + 3) + (4 + 2 + 3 + 1 + 1))
d848 2
a849 1
;   r2 = compacted array of stereo position values, 3 bits each, 1-based.
d872 3
d909 24
a932 9
        ; (8): scaling code, in two parts.
        ; (8a): multiply by 11 (same for all) - 4 instructions
        ADR     r3, scale_mul
        LDMIA   r3!, {r4,r5,r6,r7}      ; NB. leaves r3 pointing at scale_div_TAB
        STMIA   r1!, {r4,r5,r6,r7}
        ; (8b): divide by 8/16/32/64, determined by log2nchan
        ADD     r3, r3, r0, LSL #3      ; 8 bytes each
        LDMIA   r3, {r4,r5}             ; get the 2 instructions
        STMIA   r1!, {r4,r5}            ; store them
d948 5
d983 1
a983 1
A500Code          #  A500CodeSize              ; Code goes here in RMA
d990 3
a992 3

PowerControl    #    4                  ;0..PowerContThres2 number of consecutive quiet buffers
PowerContThres1 *    2                  ;When PowerControl is >=2, both current & next buffers
d995 1
a995 1
PowerContThres2 *    100                ;Threshold at which the interrupt routine powers down
d997 1
a997 1

d1274 23
d1531 1
a1531 1
        Push    "r4,r5,r6"
d1542 2
a1543 1
        CMP     r3, r2                  ; check against required period
d1545 25
a1569 7
        BGT     %FT24                   ; if period too large (f too low), try next one.
                                        ; period lower than req (f higher): use lower one
        CMP     lr, #1                  ; but if on first, we're stuck with it
        SUBGT   lr, lr, #1              ; address previous entry if needed
        LDRGTB  r6, [r0, lr]
        ADDGT   r1, r4, r6, LSL #3
        B       %FT26                   ; go accept it (we must)
d1579 1
a1579 1
        Pull    "r4,r5,r6"
d1745 1
d1750 3
d2295 1
a2297 1
  [ 1 = 1
d2300 1
a2300 4
        MOV     r0, #1                          ; pretend portable module present
        STR     r0, [r2, #portable_present]     ; at least until we know better
        MOV     r0, #0
        STR     r0, [r2, #power_state]          ; show power_state as OFF, to force
d2384 3
d2390 2
a2391 1
        BL      compile                 ; go call compiler to set it up
d2559 1
a2559 1
        TST     r0, #&80000000                  ;  sound is quiet
d2561 1
d2568 5
d2900 6
d2927 2
a2928 1
        ; 31 of r6, so it's easy to re-check.
d2930 1
a2930 1
        BEQ     %FT65                   ; no re-compilation needed if bit 13 clear
d2932 1
a2932 1
55      ; Compile for updated configuration/stereo position.
d2934 2
d2938 1
a2938 1
        BL      compile                 ; go compile it
d3165 1
d3171 1
d3191 1
d3196 9
d3267 1
d3273 1
a3274 1

d3283 1
d3285 1
a3285 1
        ;       r9 = address of 256-entry mu-law to 16-bit conversion table
d3292 1
d3391 7
d3399 6
a3404 3
        LDRB    lr, [r0, #IOCIRQMSKA]
        ORR     lr, lr, #vsync_bit + timer0_bit
        STRB    lr, [r0, #IOCIRQMSKA]
d3549 1
a3593 1

a3599 2
;;;        MOV     r1, #:NOT:SoundPowerBits
;;;        SWI     XPortable_Control
a3600 1

d3610 1
d3612 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a209 5
 [ StorkPower
        GBLL    AdvancedPower   ;True - power on only whilst buffers hold 'non-quiet' data
AdvancedPower   SETL    False   ;Switched off cos amps have nasty switch-on click
 ]

d211 1
a211 1
EnableIRQsIn16bit       SETL    False
a212 1
 [ EnableIRQsIn16bit
a215 4
        GBLL    DisableHardDiscIRQ
DisableHardDiscIRQ      SETL    True
 ]

a274 2
SoundGain # 1   ; value of additional gain (0..7) -> +0 .. 21dB in 3dB steps, for mu-law
SoundGain_C # 1 ; value of additional gain as currently compiled into conv code
d276 1
a276 1
; CURRENTLY 3 BYTES SPARE (FOR VIDC20).
a284 1
SCSoundGain  * 0                        ; default soundgain is 0
a365 8
 [ Development
        DCB     " Development"
  [ EnableIRQsIn16bit
        DCB     " IRQs enabled"
  |
        DCB     " IRQs disabled"
  ]
 ]
a414 7
        DCB     "SoundGain", 0
        ALIGN
        DCD     SoundGain_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)
        DCD     SoundGain_Syntax - Module_Base
        DCD     SoundGain_Help   - Module_Base

a496 1
;   r5  = 0x7FFF - constant used for limit operation if soundgain > 0
d694 1
a694 1
        MOV     r7,     r3, ASR #17
d713 2
a714 13
; Version 1.52 onwards: supports *soundgain giving 0 to +21dB additional
; gain, with 3dB increments, in mu-law to linear conversion.  This is
; achieved by using a multiplier of *11 and a divisor of 64 (ASR #6) to give
; 0dB for the 8-channel case, with reducing right shifts as channel count
; decreases or gain is increased in 6dB steps.  For the +3dB steps, don't do
; the mul by 11, but divide by 4 (ASR #2) for 8-channel case, to give
; effectively a +3dB increment, and again reduce the right shift constant or
; go to a left shift for reducing channel count or each extra +6dB gain.
;

; (8a): First the *11 code, the same for all configurations: this is inserted
; only when soundgain is even (i.e. 0dB, 6dB, 12dB, 18dB)
scale_mul_even
d720 14
a733 46
; (8b): gain scaling code, 2 instructions; table indexed by
;       7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4).
scale_TAB                       ;       1ch     2ch     4ch     8ch
                                ;----------------------------------
        MOV     r6, r6, LSL #4  ;0      +21     -       -       -  GAIN (soundgain odd)
        MOV     r7, r7, LSL #4  ;       -       -       -       -  GAIN (soundgain even)

        MOV     r6, r6, LSL #3  ;1      +15     +21     -       -
        MOV     r7, r7, LSL #3  ;       -       -       -       -

        MOV     r6, r6, LSL #2  ;2      +9      +15     +21     -
        MOV     r7, r7, LSL #2  ;       -       -       -       -

        MOV     r6, r6, LSL #1  ;3      +3      +9      +15     +21
        MOV     r7, r7, LSL #1  ;       -       -       -       -

        DCD     0               ;4      -       +3      +9      +15
        DCD     0               ;       +18     -       -       -

        MOV     r6, r6, ASR #1  ;5      -       -       +3      +9
        MOV     r7, r7, ASR #1  ;       +12     +18     -       -

        MOV     r6, r6, ASR #2  ;6      -       -       -       +3
        MOV     r7, r7, ASR #2  ;       +6      +12     +18     -

        MOV     r6, r6, ASR #3  ;7      -       -       -       -
        MOV     r7, r7, ASR #3  ;       +0      +6      +12     +18

        MOV     r6, r6, ASR #4  ;8      -       -       -       -
        MOV     r7, r7, ASR #4  ;       -       +0      +6      +12

        MOV     r6, r6, ASR #5  ;9      -       -       -       -
        MOV     r7, r7, ASR #5  ;       -       -       +0      +6

        MOV     r6, r6, ASR #6  ;10      -       -       -       -
        MOV     r7, r7, ASR #6  ;       -       -       -       +0

; Instruction sequence (8c): do limiting (clipping) on output values:
; only used if soundgain > 0.
limit
        MOV     r0, r6, ASR #31         ; get r6 sign bit throughout r0
        CMP     r0, r6, ASR #15         ; check for overflow
        EORNE   r6, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r6
        MOV     r0, r7, ASR #31         ; get r7 sign bit throughout r0
        CMP     r0, r7, ASR #15         ; check for overflow
        EORNE   r7, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r7
d761 1
a761 1
; +     size of sequence(8a;8b;8c;9;10;11)       +      (4 + 2 + 6 + 3 + 1 + 1))
d763 1
a763 1
MAXLinConvCodeSize *  4 * ((2 + 2 + 1 + 1) + 8 * (1 + 1 + 3) + (4 + 2 + 6 + 3 + 1 + 1))
d773 1
a773 2
;   r2 = compacted array of stereo position values, 8x3 bits each (1-based)
;        in bits 0..23, with soundgain (0..7) in top byte.
a795 3
        ; preserve soundgain value, for later (r2 gets shifted in next loop)
        MOV     r7, r2, LSR #24         ;

d830 9
a838 24
        ; (8): scaling code, in three parts.
        ; (8a): if soundgain is even, multiply by 11 (same for all modes) - 4 insts
        ;       note: r7 holds soundgain value from above
        TST     r7, #1
        ADREQ   r2, scale_mul_even
        LDMEQIA r2!, {r3,r4,r5,r6}
        STMEQIA r1!, {r3,r4,r5,r6}

        ; (8b): next perform scaling (shifting) as required, using
        ;  scale_TAB[7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4)]

        ADR     r2, scale_TAB+7*2*4     ; address scale_TAB[7]
        SUB     r6, r0, r7, LSR #1      ; compute (log2nchan - soundgain DIV 2)
        SUBNE   r6, r6, #4              ; if soundgain odd, subtract 4 (c/c still valid)
        ADD     r2, r2, r6, LSL #3      ; then scale for 2 instructions/entry
        LDMIA   r2, {r4,r5}             ; get the 2 instructions
        CMP     r4, #0                  ; if first instr is not 0 (for NOP)...
        STMNEIA r1!, {r4,r5}            ; ...store them

        ; (8c) perform limiting on sample values if required (i.e. soundgain > 0)
        ADR     r2, limit
        CMP     r7, #0
        LDMNEIA r2,  {r3,r4,r5,r6,r7,r8}  ; 6 instructions (3/channel)
        STMNEIA r1!, {r3,r4,r5,r6,r7,r8}  ; store them
d884 1
a884 1
A500Code          #  A500CodeSize       ; Code goes here in RMA
d891 3
a893 3
  [ AdvancedPower
PowerControl      # 4                   ;0..PowerContThres2 number of consecutive quiet buffers
PowerContThres1   * 2                   ;When PowerControl is >=2, both current & next buffers
d896 1
a896 1
PowerContThres2   * 100                 ;Threshold at which the interrupt routine powers down
d898 1
a898 1
  ]
a1174 23

; .............................................................................

SoundGain_Code  ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer

        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned        ; complain if not a number or bad term
        BVS     Bad_Parameter_Error
        CMP     r2, #7                  ; if >7, complain about range
        BHI     SoundGain_Error
        LDR     r1, =SoundLevel0Base
        STRB    r2, [r1, #SoundGain]   ; else store out for compilation on next irq
        EXIT

SoundGain_Error
        ADR     r0, ErrorBlock_BadSoundGain
        B       ReturnError

        MakeInternatErrorBlock BadSoundGain,,M03

d1409 1
a1409 1
        Push    "r4,r5,r6,r7,r8"
d1420 1
a1420 2

        SUBS    r7, r3, r2              ; place (entry - freq) in r7
d1422 7
a1428 25
        BPL     %FT24                   ; else if freq > entry, then look at next entry

                                        ; here, freq < entry, so test for closest match ie

                                        ;      (last_entry > freq < this_entry)

        CMP     lr, #1                  ; accept if at start of table
        BEQ     %FT26
        SUB     lr, lr, #1              ; otherwise back up to previous entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period

        SUB     r8, r2, r3              ; place (freq - entry) in r8

        CMP     r7, r8                  ; if r7 > r8 then we have best match
        BGT     %FT26                   ; so accept the current entry

        ADD     lr, lr, #1              ; otherwise go back up to next entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period
        B       %FT26                   ; and accept it


d1438 1
a1438 1
        Pull    "r4,r5,r6,r7,r8"
a1603 1
  [ AdvancedPower
a1607 3
  |
        BL      SetPower_On             ; Power up now (corrupts R0)
  ]
a2149 1
  [ AdvancedPower
d2152 1
d2155 4
a2158 1
        BL      GetPower                        ;
a2241 3
        MOV     r2, #SCSoundGain        ; set up default soundgain value
        STRB    r2, [r10, #SoundGain]
        STRB    r2, [r10, #SoundGain_C]
d2245 1
a2245 2
        ORR     r2, r2, #SCSoundGain :SHL: 24 ; combine default soundgain into r2
        BL      compile                 ; go call compiler to set it all up
d2413 1
a2413 1
        TST     r0, #&80000000                  ; sound is quiet
a2414 1
  [ AdvancedPower
a2420 5
  |
;
; Sound system on, so prevent powerdown
;
  ]
a2747 6
        LDRB    r1, [r14, #SoundGain_C] ; get current value of mu-law->linear conv gain
        LDRB    r2, [r14, #SoundGain]   ; get last-set value
        CMP     r2, r1                  ; check if different, and if so mark fact...
        ORRNE   r6, r6, #1 :SHL: 31     ; ..by setting sign bit in r6
        STRNEB  r2, [r14, #SoundGain_C] ; and also update recorded value

d2769 1
a2769 2
        ; 31 of r6, so it's easy to re-check.  This bit may alternatively/also
        ; indicate change of soundgain value, with same consequence.
d2771 1
a2771 1
        BEQ     %FT65                   ; no re-compilation needed if bit 31 clear
d2773 1
a2773 1
55      ; Compile for updated configuration/stereo position/soundgain value.
a2774 2
        LDRB    r1, [r14, #SoundGain_C] ; pick up newest soundgain value
        ORR     r2, r2, r1, LSL #24     ; and combine into r2
d2777 1
a2777 1
        BL      compile                 ; go compile it (R0 = log2nchan)
a3003 1
  [ AdvancedPower
a3008 1
  ]
a3027 1
        Push    lr
a3031 9
  [ DisableHardDiscIRQ
        ; Disable IDE interrupt too. Replay doesn't like this being enabled either.
        ;
        LDRB    lr, [r0, #IOCIRQMSKB]
        Push    lr
        BIC     lr, lr, #IOMD_HardDisc_IRQ_bit
        STRB    lr, [r0, #IOCIRQMSKB]
  ]

a3093 1
  [ AdvancedPower
a3098 1
  ]
d3100 1
d3109 1
a3110 2
        ;       r8 = &FF for byte masking in conversion routine
        ;       r5 = &7FFF for overflow test
a3116 1
        ORR     r5, r8, #&7F00          ; and also mask for limit check
a3214 7
   [ DisableHardDiscIRQ
        Pull    lr
        TST     lr, #IOMD_HardDisc_IRQ_bit
        LDRNEB  lr, [r0, #IOCIRQMSKB]
        ORRNE   lr, lr, #IOMD_HardDisc_IRQ_bit
        STRNEB  lr, [r0, #IOCIRQMSKB]
   ]
d3216 3
a3218 6
        Pull    lr
        ANDS    lr, lr, #vsync_bit + timer0_bit
        LDRNEB  r1, [r0, #IOCIRQMSKA]
        BICNE   r1, r1, #vsync_bit + timer0_bit
        ORRNE   r1, r1, lr
        STRNEB  r1, [r0, #IOCIRQMSKA]
a3362 1
  [ AdvancedPower
d3407 1
d3414 2
d3417 1
a3426 1
  ]
@


4.1.7.2
log
@StrongARM capable, mono sound capable, different sample rate on STBs/NCs.
@
text
@a116 7
; 1.53 14-Apr-97  MT    Merge in changes for StrongARM compatibility, mono output and
;                       oversampling performance improvement.  Change default sample rate
;                       to 22.05Khz, if hardware support is available for this (STB/NC).
;

        GBLL    StrongARM
StrongARM SETL    {TRUE}
a150 1

a293 3
 [ STB
SCPeriod     * 45                       ; use 45us (22.05kHz) for STBs & NCs
 |
a294 2
 ]
 
d301 2
a302 3
; 1 bit for mono-isation flag, top bit reserved (probably unnecessarily) for Level1Fill
; handler call "Level0 updated" flag.
DoMono          *       &40             ; mono-isation control bit
a303 1
OverMonoShift   *       5               ; shift to get to OS/Mono as 2-bit field
d392 1
a392 5
   [ STB
        DCB     " STB/NC version"
   |
        DCB     " Generic"
   ]
a944 5
  [ StrongARM
        STMFD   sp!,{r0-r2,lr}
        BL      Sound0synccode          ;SynchroniseCodeAreas, r0=start addr, r1 = end addr (inclusive)
        LDMFD   sp!,{r0-r2,lr}
  ]
d2476 1
d3334 4
a3337 3
        LDMFD   sp, {r0,r1}            ; reload (no pop) phys base & limit now

        ; Finally, perform mono mix-down and/or oversampling, if required.
d3340 7
a3346 19
        LDRB    r3, [r11, #Flags]       ; now check for oversamping/mono
	MOV	r3, r3, LSR #OverMonoShift
	ANDS	r3, r3, #3		; bit 0 -> oversamp. bit 1 -> mono
	BEQ	BufferDone		; nowt to do if both bits clear (r3 = 0)

	; OK, doing some sort of filtering operation.  Set up some constants
	; used in all cases...

	; Set up 0x80008000 in r12, to perform signed/unsigned swap overs
 	MOV	r12, #1<<15
 	ORR	r12, r12, #1<<31
 	
	; Create 0xFFFEFFFE in r11 for masking off LSBs, to isolate LH and RH
	; parts during parallel additions.	
 	MVN	r11, r12, ROR #15	; can derive from r12 in one go!

	CMP	r3, #2			; check which proc we need to call (1,2,3)
	BEQ	MonoOnly		; if r3 = 2, do just mono conversion
					; else doing oversampling...
d3348 1
a3349 12
	STR	r2, [sp, #4]		; store out for later use also
					; switch to appropriate oversampling code
	BLT	OverOnly		; if r3 < 2 (i.e. 1), only oversample
	B	MonoOver		; if r3 > 2 (i.e. 3), do mono + oversample
	
BufferDone	; return here after any buffer processing
	Pull	"r3,r4" 		; pop phys base+real limit (@@Fs*2 if oversampling)
	LDR	r6, [r4, #-4]		; pick up last sample pair from this buffer
	LDR	r11, =SoundLevel0Base 	; address sound work area
	LDR	r7, [r11, #SoundRMA]	; address RMA area
	STR	r6, [r7, #SavedSample]	; save sample pair for possible oversampling next time

d3351 25
a3407 167
        
        
; Buffer processing routines - 3 off, done as out-of-line code sequences which
; all return to "BufferDone" above....

; MonoOnly
;
;     Convert stereo into mono (in same buffer space) for use with mono sound devices
;     (e.g. TV with only mono sound input, attached to NC).
;     NB: output data is still 2x16bit/sample.
;
;   r0 = base address of current buffer
;   r1 = limit address (last+1) of source (Fs*1)
;   r2-r10 free for general use
;   r11 = 0xFFFEFFFE
;   r12 = 0x80008000
;   r14 = free for use
; On exit:
;   r0-r10,r14 corrupted

MonoOnly	ROUT
01	LDMDB	r1!, {r2,r3,r4,r5}
	; convert from signed to unsigned format
	EOR	r2, r2, r12
	EOR	r3, r3, r12
	EOR	r4, r4, r12
	EOR	r5, r5, r12
	; clear off LSB from each value (two in each reg)
	AND	r2, r2, r11
	AND	r3, r3, r11
	AND	r4, r4, r11
	AND	r5, r5, r11
	; Add the left and right samples together, simultaneously in both upper and
	; halves of each stereo pair. There will be no
	; interference between carry out from the RHS MSB into bit 16 (LSB of
	; LHS sample), and no carry from bit 16 into bit 17, since we cleared
	; bit 16 in both sources (i.e. bit 16 and bit 0 of pre-rotated single source!)
	; beforehand; therefore the subsequent right shift will correctly put the
	; average of the two channel samples back into bits 15..0 (and also into
	; bits 31..16, using RRX to recover carry out from bit 31).
	; Get back to signed 16 bit result for each channel afterwards by EOR'ing
	; with 0x80008000.
	ADDS	r2, r2, r2, ROR #16
	EOR	r2, r12, r2, RRX 
	ADDS	r3, r3, r3, ROR #16
	EOR	r3, r12, r3, RRX 
	ADDS	r4, r4, r4, ROR #16
	EOR	r4, r12, r4, RRX 
	ADDS	r5, r5, r5, ROR #16
	EOR	r5, r12, r5, RRX 
	STMIA	r1, {r2,r3,r4,r5}	; store them all out
	CMP	r1, r0                  ; have we just done last loop?
        BNE     %B01                    ; round again if not
	B	BufferDone		; we're all done



; OverOnly:
;     Oversample, expanding buffer by factor of 2 by performing linear interpolation
;     between each pair of samples.  For the very first case, this uses a saved copy
;     of the last stereo sample pair word (2x16-bit) from the end of the previous
;     buffer, to interpolate against.  Note that this process is done in reverse
;     order (working from end of buffer back to start) to avoid overwriting the
;     initial data as would happen if we went forwards..
OverOnly 	ROUT
	LDR	r14, [r1, #-4]!		; get last sample in source buffer now
	EOR	r14, r14, r12		; convert signed to unsigned
	AND	r14, r14, r11		; mask LSB bits from this sample-pair
	ADD	r0, r0, #8*4		; need to do last group separately, so move base

01	LDMDB	r1!, {r3,r5,r7,r9}	; load 4 new samples

02	; convert from signed to unsigned format (into separate regs apart from r3)
	EOR	r3, r3, r12
	EOR	r6, r5, r12
	EOR	r8, r7, r12
	EOR	r10, r9, r12
	; clear off LSB from each value (two in each reg)
	AND	r3, r3, r11
	AND	r6, r6, r11
	AND	r8, r8, r11
	AND	r10, r10, r11
	; oversampling: average pairs and turn back to signed format
	ADDS	r4, r3, r6
	EOR     r4, r12, r4, RRX 
	ADDS	r6, r6, r8
	EOR	r6, r12, r6, RRX 
	ADDS	r8, r8, r10
	EOR	r8, r12, r8, RRX 
  	ADDS	r10, r10, r14
	EOR     r10, r12, r10, RRX 
	EOR	r14, r12, r14			; put r14 back to signed format also
	STMDB	r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results interleaved with originals
	MOV	r14, r3			; set lowest sample for end of next group
	CMP	r2, r0                  ; have we just done last normal loop?
        BHI     %B01                    ; round again if not
	BLO	BufferDone		; all done if done extra, special loop

 	; (r2==r0) for last special loop, pick up very first 3 samples from this buffer
 	LDMDB	r1!, {r5,r7,r9}
 	; get last sample from previous buffer, to interpolate for first new sample of this
 	LDR	r3, =SoundLevel0Base
 	LDR	r3, [r3, #SoundRMA]
 	LDR	r3, [r3, #SavedSample]
	B	%B02			; use main loop code to do it


; Convert to mono and oversample also
MonoOver	ROUT
	ADD	r0, r0, #8*4		; need to do last group separately, so move base
	
	LDR	r14, [r1, #-4]!		; get last sample in source buffer now
	EOR	r14, r14, r12		; convert signed to unsigned
	AND	r14, r14, r11		; mask LSB bits from this sample-pair
    	ADDS	r14, r14, r14, ROR #16	; convert to mono
    	AND	r14, r11, r14, RRX 

01	LDMDB	r1!, {r3,r5,r7,r9}	; get four new samples: signed, full 16-bit, stereo

02	; convert from signed to unsigned format
	EOR	r3, r3, r12
	EOR	r5, r5, r12
	EOR	r7, r7, r12
	EOR	r9, r9, r12
	; clear off LSB from each value (two in each reg)
	AND	r3, r3, r11
	AND	r5, r5, r11
	AND	r7, r7, r11
	AND	r9, r9, r11
	; Monoise unsigned masked versions of input data; since we're also oversampling,
	; leave in unsigned form and mask off LSBs again
	ADDS	r3, r3, r3, ROR #16
	AND	r3, r11, r3, RRX 
	ADDS	r5, r5, r5, ROR #16
	AND	r5, r11, r5, RRX 
	ADDS	r7, r7, r7, ROR #16
	AND	r7, r11, r7, RRX 
	ADDS	r9, r9, r9, ROR #16
	AND	r9, r11, r9, RRX 
	; then oversample, generating new intermediate values in r4,r6,r8,r10, in signed format
	ADDS	r4, r3, r5
	EOR     r4, r12, r4, RRX 
	ADDS	r6, r5, r7
	EOR	r6, r12, r6, RRX 
	ADDS	r8, r7, r9
	EOR	r8, r12, r8, RRX 
  	ADDS	r10, r9, r14
	EOR     r10, r12, r10, RRX 
	; must convert monoised unsigned masked originals back to signed format also
	EOR	r5, r12, r5
	EOR	r7, r7, r12
	EOR	r9, r9, r12
	EOR	r14, r12, r14		; put r14 back to signed format also for store-out
	STMDB	r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results, interleaved with originals
	MOV	r14, r3			; copy lo sample (mono,still unsigned & masked) for next group
	CMP	r2, r0                  ; have we just done last normalloop?
        BHI     %B01                    ; round again if not
	BLO	BufferDone		; return if just done extra, special loop

 	; r2==r0: finally, pick up very first 3 samples from this buffer
 	LDMDB	r1!, {r5,r7,r9}
 	; and last sample from previous buffer, to interpolate for first new sample of this
 	LDR	r3, =SoundLevel0Base
 	LDR	r3, [r3, #SoundRMA]
 	LDR	r3, [r3, #SavedSample]
 	; use main loop code to do final (earliest) 8 samples of output
 	B	%B02
a3481 60

 [ StrongARM
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; StrongARM cache management support code
;

ARM_config_cp        CP 15  ;coprocessor number for configuration control
ARM_ID_reg           CN  0  ;processor ID
ARM8A_cache_reg      CN  7  ;cache operations, ARMs 8 or StrongARM

C0  CN  0
C1  CN  1
C2  CN  2
C3  CN  3
C4  CN  4
C5  CN  5
C6  CN  6
C7  CN  7
C8  CN  8
C9  CN  9
C10 CN 10
C11 CN 11
C12 CN 12
C13 CN 13
C14 CN 14
C15 CN 15

; local version of SynchroniseCodeAreas (avoids calling a SWI,
; which seems to bust things - interrupts,re-entrancy probs?)
;
; entry: r0 = low addr
;        r1 = high addr (inclusive)
;
; exit:  corrupts r0,r1,r2
;
Sound0synccode ROUT
        MRC     ARM_config_cp,0,r2,ARM_ID_reg,C0,0 
        AND     r2,r2,#&F000
        CMP     r2,#&A000
        BNE     %FT02        ;not SA

        BIC     r0,r0,#31    ;align down to 8-word (1 cache line) boundary
        ADD     r1,r1,#31
        BIC     r1,r1,#31    ;align up to 8-word boundary
01
        MCR     ARM_config_cp,0,r0,ARM8A_cache_reg,C10,1   ;clean DC entry
        ADD     r0,r0,#32    ;next line
        CMP     r0,r1
        BLO     %BT01
        MCR ARM_config_cp,0,R0,ARM8A_cache_reg,C10,4         ;drain WB
        MCR ARM_config_cp,0,R0,ARM8A_cache_reg,C5,0          ;flush IC
        MOV     r0,r0
        MOV     r0,r0
        MOV     r0,r0
02
        MOVS    pc,lr

 ] ;StrongARM

@


4.1.7.3
log
@1.54  Fix to allow mono output to be controlled (Sound_Mode 3) - although the
      implementation was present (and has previously been tested), the code to
      recognise and act on Sound_Mode function code 3 had been omitted by
      accident in the source merge which produced 1.53.
1.54  Fix to allow mono output to be controlled (Sound_Mode 3) - although the
      implementation was present (and has previously been tested), the code to
      recognise and act on Sound_Mode function code 3 had been omitted by
      accident in the source merge which produced 1.53.
@
text
@a119 4
; 1.54 22-Apr-97  MT    Fix to allow mono output to be controlled (Sound_Mode 3) - although
;                       the implementation was present, the code to recognise and act on
;                       the specific SWI function code had been omitted by accident in the
;                       code merge.
a1932 3
;     = 3: set/clear mono flag, returning previous state (0 or 1)
;	   R1 = 0: stereo mode
;	   R1 <> 0: mono mode (convert stereo to mono for output)
a1938 1
;  For function code 0:
a1953 2
;       R1[5]   = 0: stereo output
;		= 1: mono conversion on output
a1973 2
        TST	r2, #DoMono		; check for mono mode
        ORRNE	r1, r1, #1 :SHL: 5	; set flag if enabled
d2004 1
a2004 1
        BNE     %FT30
a2005 14
	B	%FT99
30	CMP	r0, #3
	BNE	%FT40
; Function code 3: enable/disable mono-isation (allows overriding CMOS value)
        LDRB    r2, [r10, #Flags]	; get flags byte
        MOV     lr, r2                  ; preserve original value
        CMP     r1, #0                  ; check requested state
        ORRNE   r2, r2, #DoMono         ; set bit if enabling mono conversion
        BICEQ   r2, r2, #DoMono         ; or clear bit if disabling it
        ANDS    r1, lr, #DoMono         ; get old state of flag into r1 (wrong bit pos)
        MOVNE   r1, #1                  ; if not zero, set 1, else 0 already there...
        STRB    r2, [r10, #Flags]       ; store out new flag value
        EXITS
40
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a209 5
 [ StorkPower
        GBLL    AdvancedPower   ;True - power on only whilst buffers hold 'non-quiet' data
AdvancedPower   SETL    False   ;Switched off cos amps have nasty switch-on click
 ]

d211 1
a211 1
EnableIRQsIn16bit       SETL    False
a212 1
 [ EnableIRQsIn16bit
a215 4
        GBLL    DisableHardDiscIRQ
DisableHardDiscIRQ      SETL    True
 ]

a274 2
SoundGain # 1   ; value of additional gain (0..7) -> +0 .. 21dB in 3dB steps, for mu-law
SoundGain_C # 1 ; value of additional gain as currently compiled into conv code
d276 1
a276 1
; CURRENTLY 3 BYTES SPARE (FOR VIDC20).
a284 1
SCSoundGain  * 0                        ; default soundgain is 0
a365 8
 [ Development
        DCB     " Development"
  [ EnableIRQsIn16bit
        DCB     " IRQs enabled"
  |
        DCB     " IRQs disabled"
  ]
 ]
a414 7
        DCB     "SoundGain", 0
        ALIGN
        DCD     SoundGain_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)
        DCD     SoundGain_Syntax - Module_Base
        DCD     SoundGain_Help   - Module_Base

a496 1
;   r5  = 0x7FFF - constant used for limit operation if soundgain > 0
d694 1
a694 1
        MOV     r7,     r3, ASR #17
d713 2
a714 13
; Version 1.52 onwards: supports *soundgain giving 0 to +21dB additional
; gain, with 3dB increments, in mu-law to linear conversion.  This is
; achieved by using a multiplier of *11 and a divisor of 64 (ASR #6) to give
; 0dB for the 8-channel case, with reducing right shifts as channel count
; decreases or gain is increased in 6dB steps.  For the +3dB steps, don't do
; the mul by 11, but divide by 4 (ASR #2) for 8-channel case, to give
; effectively a +3dB increment, and again reduce the right shift constant or
; go to a left shift for reducing channel count or each extra +6dB gain.
;

; (8a): First the *11 code, the same for all configurations: this is inserted
; only when soundgain is even (i.e. 0dB, 6dB, 12dB, 18dB)
scale_mul_even
d720 14
a733 46
; (8b): gain scaling code, 2 instructions; table indexed by
;       7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4).
scale_TAB                       ;       1ch     2ch     4ch     8ch
                                ;----------------------------------
        MOV     r6, r6, LSL #4  ;0      +21     -       -       -  GAIN (soundgain odd)
        MOV     r7, r7, LSL #4  ;       -       -       -       -  GAIN (soundgain even)

        MOV     r6, r6, LSL #3  ;1      +15     +21     -       -
        MOV     r7, r7, LSL #3  ;       -       -       -       -

        MOV     r6, r6, LSL #2  ;2      +9      +15     +21     -
        MOV     r7, r7, LSL #2  ;       -       -       -       -

        MOV     r6, r6, LSL #1  ;3      +3      +9      +15     +21
        MOV     r7, r7, LSL #1  ;       -       -       -       -

        DCD     0               ;4      -       +3      +9      +15
        DCD     0               ;       +18     -       -       -

        MOV     r6, r6, ASR #1  ;5      -       -       +3      +9
        MOV     r7, r7, ASR #1  ;       +12     +18     -       -

        MOV     r6, r6, ASR #2  ;6      -       -       -       +3
        MOV     r7, r7, ASR #2  ;       +6      +12     +18     -

        MOV     r6, r6, ASR #3  ;7      -       -       -       -
        MOV     r7, r7, ASR #3  ;       +0      +6      +12     +18

        MOV     r6, r6, ASR #4  ;8      -       -       -       -
        MOV     r7, r7, ASR #4  ;       -       +0      +6      +12

        MOV     r6, r6, ASR #5  ;9      -       -       -       -
        MOV     r7, r7, ASR #5  ;       -       -       +0      +6

        MOV     r6, r6, ASR #6  ;10      -       -       -       -
        MOV     r7, r7, ASR #6  ;       -       -       -       +0

; Instruction sequence (8c): do limiting (clipping) on output values:
; only used if soundgain > 0.
limit
        MOV     r0, r6, ASR #31         ; get r6 sign bit throughout r0
        CMP     r0, r6, ASR #15         ; check for overflow
        EORNE   r6, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r6
        MOV     r0, r7, ASR #31         ; get r7 sign bit throughout r0
        CMP     r0, r7, ASR #15         ; check for overflow
        EORNE   r7, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r7
d761 1
a761 1
; +     size of sequence(8a;8b;8c;9;10;11)       +      (4 + 2 + 6 + 3 + 1 + 1))
d763 1
a763 1
MAXLinConvCodeSize *  4 * ((2 + 2 + 1 + 1) + 8 * (1 + 1 + 3) + (4 + 2 + 6 + 3 + 1 + 1))
d773 1
a773 2
;   r2 = compacted array of stereo position values, 8x3 bits each (1-based)
;        in bits 0..23, with soundgain (0..7) in top byte.
a795 3
        ; preserve soundgain value, for later (r2 gets shifted in next loop)
        MOV     r7, r2, LSR #24         ;

d830 9
a838 24
        ; (8): scaling code, in three parts.
        ; (8a): if soundgain is even, multiply by 11 (same for all modes) - 4 insts
        ;       note: r7 holds soundgain value from above
        TST     r7, #1
        ADREQ   r2, scale_mul_even
        LDMEQIA r2!, {r3,r4,r5,r6}
        STMEQIA r1!, {r3,r4,r5,r6}

        ; (8b): next perform scaling (shifting) as required, using
        ;  scale_TAB[7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4)]

        ADR     r2, scale_TAB+7*2*4     ; address scale_TAB[7]
        SUB     r6, r0, r7, LSR #1      ; compute (log2nchan - soundgain DIV 2)
        SUBNE   r6, r6, #4              ; if soundgain odd, subtract 4 (c/c still valid)
        ADD     r2, r2, r6, LSL #3      ; then scale for 2 instructions/entry
        LDMIA   r2, {r4,r5}             ; get the 2 instructions
        CMP     r4, #0                  ; if first instr is not 0 (for NOP)...
        STMNEIA r1!, {r4,r5}            ; ...store them

        ; (8c) perform limiting on sample values if required (i.e. soundgain > 0)
        ADR     r2, limit
        CMP     r7, #0
        LDMNEIA r2,  {r3,r4,r5,r6,r7,r8}  ; 6 instructions (3/channel)
        STMNEIA r1!, {r3,r4,r5,r6,r7,r8}  ; store them
d884 1
a884 1
A500Code          #  A500CodeSize       ; Code goes here in RMA
d891 3
a893 3
  [ AdvancedPower
PowerControl      # 4                   ;0..PowerContThres2 number of consecutive quiet buffers
PowerContThres1   * 2                   ;When PowerControl is >=2, both current & next buffers
d896 1
a896 1
PowerContThres2   * 100                 ;Threshold at which the interrupt routine powers down
d898 1
a898 1
  ]
a1174 23

; .............................................................................

SoundGain_Code  ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer

        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned        ; complain if not a number or bad term
        BVS     Bad_Parameter_Error
        CMP     r2, #7                  ; if >7, complain about range
        BHI     SoundGain_Error
        LDR     r1, =SoundLevel0Base
        STRB    r2, [r1, #SoundGain]   ; else store out for compilation on next irq
        EXIT

SoundGain_Error
        ADR     r0, ErrorBlock_BadSoundGain
        B       ReturnError

        MakeInternatErrorBlock BadSoundGain,,M03

d1409 1
a1409 1
        Push    "r4,r5,r6,r7,r8"
d1420 1
a1420 2

        SUBS    r7, r3, r2              ; place (entry - freq) in r7
d1422 7
a1428 25
        BPL     %FT24                   ; else if freq > entry, then look at next entry

                                        ; here, freq < entry, so test for closest match ie

                                        ;      (last_entry > freq < this_entry)

        CMP     lr, #1                  ; accept if at start of table
        BEQ     %FT26
        SUB     lr, lr, #1              ; otherwise back up to previous entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period

        SUB     r8, r2, r3              ; place (freq - entry) in r8

        CMP     r7, r8                  ; if r7 > r8 then we have best match
        BGT     %FT26                   ; so accept the current entry

        ADD     lr, lr, #1              ; otherwise go back up to next entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period
        B       %FT26                   ; and accept it


d1438 1
a1438 1
        Pull    "r4,r5,r6,r7,r8"
a1603 1
  [ AdvancedPower
a1607 3
  |
        BL      SetPower_On             ; Power up now (corrupts R0)
  ]
a2149 1
  [ AdvancedPower
d2152 1
d2155 4
a2158 1
        BL      GetPower                        ;
a2241 3
        MOV     r2, #SCSoundGain        ; set up default soundgain value
        STRB    r2, [r10, #SoundGain]
        STRB    r2, [r10, #SoundGain_C]
d2245 1
a2245 2
        ORR     r2, r2, #SCSoundGain :SHL: 24 ; combine default soundgain into r2
        BL      compile                 ; go call compiler to set it all up
d2413 1
a2413 1
        TST     r0, #&80000000                  ; sound is quiet
a2414 1
  [ AdvancedPower
a2420 5
  |
;
; Sound system on, so prevent powerdown
;
  ]
a2747 6
        LDRB    r1, [r14, #SoundGain_C] ; get current value of mu-law->linear conv gain
        LDRB    r2, [r14, #SoundGain]   ; get last-set value
        CMP     r2, r1                  ; check if different, and if so mark fact...
        ORRNE   r6, r6, #1 :SHL: 31     ; ..by setting sign bit in r6
        STRNEB  r2, [r14, #SoundGain_C] ; and also update recorded value

d2769 1
a2769 2
        ; 31 of r6, so it's easy to re-check.  This bit may alternatively/also
        ; indicate change of soundgain value, with same consequence.
d2771 1
a2771 1
        BEQ     %FT65                   ; no re-compilation needed if bit 31 clear
d2773 1
a2773 1
55      ; Compile for updated configuration/stereo position/soundgain value.
a2774 2
        LDRB    r1, [r14, #SoundGain_C] ; pick up newest soundgain value
        ORR     r2, r2, r1, LSL #24     ; and combine into r2
d2777 1
a2777 1
        BL      compile                 ; go compile it (R0 = log2nchan)
a3003 1
  [ AdvancedPower
a3008 1
  ]
a3027 1
        Push    lr
a3031 9
  [ DisableHardDiscIRQ
        ; Disable IDE interrupt too. Replay doesn't like this being enabled either.
        ;
        LDRB    lr, [r0, #IOCIRQMSKB]
        Push    lr
        BIC     lr, lr, #IOMD_HardDisc_IRQ_bit
        STRB    lr, [r0, #IOCIRQMSKB]
  ]

a3093 1
  [ AdvancedPower
a3098 1
  ]
d3100 1
d3109 1
a3110 2
        ;       r8 = &FF for byte masking in conversion routine
        ;       r5 = &7FFF for overflow test
a3116 1
        ORR     r5, r8, #&7F00          ; and also mask for limit check
a3214 7
   [ DisableHardDiscIRQ
        Pull    lr
        TST     lr, #IOMD_HardDisc_IRQ_bit
        LDRNEB  lr, [r0, #IOCIRQMSKB]
        ORRNE   lr, lr, #IOMD_HardDisc_IRQ_bit
        STRNEB  lr, [r0, #IOCIRQMSKB]
   ]
d3216 3
a3218 6
        Pull    lr
        ANDS    lr, lr, #vsync_bit + timer0_bit
        LDRNEB  r1, [r0, #IOCIRQMSKA]
        BICNE   r1, r1, #vsync_bit + timer0_bit
        ORRNE   r1, r1, lr
        STRNEB  r1, [r0, #IOCIRQMSKA]
a3362 1
  [ AdvancedPower
d3407 1
d3414 2
d3417 1
a3426 1
  ]
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a117 3
          GBLL    StrongARM
StrongARM SETL    {TRUE}

a209 5
 [ StorkPower
        GBLL    AdvancedPower   ;True - power on only whilst buffers hold 'non-quiet' data
AdvancedPower   SETL    False   ;Switched off cos amps have nasty switch-on click
 ]

d211 1
a211 1
EnableIRQsIn16bit       SETL    False
a212 1
 [ EnableIRQsIn16bit
a215 4
        GBLL    DisableHardDiscIRQ
DisableHardDiscIRQ      SETL    True
 ]

a365 8
 [ Development
        DCB     " Development"
  [ EnableIRQsIn16bit
        DCB     " IRQs enabled"
  |
        DCB     " IRQs disabled"
  ]
 ]
a853 5
  [ StrongARM
        STMFD   sp!,{r0-r2,lr}
        BL      Sound0synccode          ;SynchroniseCodeAreas, r0=start addr, r1 = end addr (inclusive)
        LDMFD   sp!,{r0-r2,lr}
  ]
d884 1
a884 1
A500Code          #  A500CodeSize       ; Code goes here in RMA
d891 3
a893 3
  [ AdvancedPower
PowerControl      # 4                   ;0..PowerContThres2 number of consecutive quiet buffers
PowerContThres1   * 2                   ;When PowerControl is >=2, both current & next buffers
d896 1
a896 1
PowerContThres2   * 100                 ;Threshold at which the interrupt routine powers down
d898 1
a898 1
  ]
d1409 1
a1409 1
        Push    "r4,r5,r6,r7,r8"
d1420 1
a1420 2

        SUBS    r7, r3, r2              ; place (entry - freq) in r7 
d1422 7
a1428 25
        BPL     %FT24                   ; else if freq > entry, then look at next entry 

                                        ; here, freq < entry, so test for closest match ie

                                        ;      (last_entry > freq < this_entry)

        CMP     lr, #1                  ; accept if at start of table
        BEQ     %FT26     
        SUB     lr, lr, #1              ; otherwise back up to previous entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period

        SUB     r8, r2, r3              ; place (freq - entry) in r8

        CMP     r7, r8                  ; if r7 > r8 then we have best match
        BGT     %FT26                   ; so accept the current entry

        ADD     lr, lr, #1              ; otherwise go back up to next entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period
        B       %FT26                   ; and accept it


d1438 1
a1438 1
        Pull    "r4,r5,r6,r7,r8"
a1603 1
  [ AdvancedPower
a1607 3
  |
        BL      SetPower_On             ; Power up now (corrupts R0)
  ]
a2149 1
  [ AdvancedPower
d2152 1
d2155 4
a2158 1
        BL      GetPower                        ;
d2413 1
a2413 1
        TST     r0, #&80000000                  ; sound is quiet
a2414 1
  [ AdvancedPower
a2420 5
  |
;
; Sound system on, so prevent powerdown
;
  ]
a3003 1
  [ AdvancedPower
a3008 1
  ]
a3027 1
        Push    lr
a3031 9
  [ DisableHardDiscIRQ
        ; Disable IDE interrupt too. Replay doesn't like this being enabled either.
        ;
        LDRB    lr, [r0, #IOCIRQMSKB]
        Push    lr
        BIC     lr, lr, #IOMD_HardDisc_IRQ_bit
        STRB    lr, [r0, #IOCIRQMSKB]
  ]

a3093 1
  [ AdvancedPower
a3098 1
  ]
d3100 1
a3214 7
   [ DisableHardDiscIRQ
        Pull    lr
        TST     lr, #IOMD_HardDisc_IRQ_bit
        LDRNEB  lr, [r0, #IOCIRQMSKB]
        ORRNE   lr, lr, #IOMD_HardDisc_IRQ_bit
        STRNEB  lr, [r0, #IOCIRQMSKB]
   ]
d3216 3
a3218 6
        Pull    lr
        ANDS    lr, lr, #vsync_bit + timer0_bit
        LDRNEB  r1, [r0, #IOCIRQMSKA]
        BICNE   r1, r1, #vsync_bit + timer0_bit
        ORRNE   r1, r1, lr
        STRNEB  r1, [r0, #IOCIRQMSKA]
a3362 1
  [ AdvancedPower
d3407 1
d3414 2
d3417 1
a3426 1
  ]
a3427 2

    GET s.Sound0_SA
@


4.1.3.2
log
@Version RO_3_71 taken
@
text
@a119 2
              GBLL    ARM810support
ARM810support SETL    {FALSE}
d1447 1
a1447 1
        SUBS    r7, r3, r2              ; place (entry - freq) in r7
d1449 1
a1449 1
        BPL     %FT24                   ; else if freq > entry, then look at next entry
d1456 1
a1456 1
        BEQ     %FT26
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@a119 2
              GBLL    ARM810support
ARM810support SETL    {FALSE}
d1447 1
a1447 1
        SUBS    r7, r3, r2              ; place (entry - freq) in r7
d1449 1
a1449 1
        BPL     %FT24                   ; else if freq > entry, then look at next entry
d1456 1
a1456 1
        BEQ     %FT26
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

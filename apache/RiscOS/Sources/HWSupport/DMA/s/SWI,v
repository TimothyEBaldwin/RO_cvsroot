head	4.9;
access;
symbols
	DMA-0_23:4.9
	DMA-0_22:4.9
	DMA-0_21:4.9
	DMA-0_20:4.8
	DMA-0_19:4.7
	DMA-0_18:4.7
	RO_5_07:4.6
	DMA-0_17:4.6
	DMA-0_16:4.4
	HAL_merge:4.3.2.4
	DMA-0_15-4_4_2_6:4.3.2.4
	DMA-0_15-4_4_2_5:4.3.2.3
	DMA-0_15-4_4_2_4:4.3.2.3
	DMA-0_15-4_4_2_3:4.3.2.3
	DMA-0_15-4_4_2_2:4.3.2.2
	DMA-0_15-4_4_2_1:4.3.2.1
	HAL_bp:4.3
	HAL:4.3.0.2
	DMA-0_15:4.3
	DMA-0_14:4.2
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	DMA-0_13:4.1
	dcotton_autobuild_BaseSW:4.3
	nturton_DMA-0_12:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	troddis_DMA-0_13:4.1.4.1
	nicke_DMA_0_11:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2014.10.18.19.18.07;	author jlee;	state Exp;
branches;
next	4.8;
commitid	ZCUMqbwOugLqvIUx;

4.8
date	2013.01.20.12.18.34;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	THRcEfGlI1hZCWAw;

4.7
date	2009.11.28.22.19.36;	author jlee;	state Exp;
branches;
next	4.6;

4.6
date	2003.02.07.20.09.52;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2003.01.30.16.10.49;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.12.13.18.48.12;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2001.04.11.18.49.22;	author bavison;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	2001.03.16.15.54.35;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.35.44;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2001.11.27.14.57.57;	author bavison;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2002.10.03.17.35.13;	author bavison;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	2002.10.15.19.15.35;	author bavison;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	2002.12.13.17.25.01;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.35.44;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.22.47;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.09.18.12.16.55;	author troddis;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.50.33;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.45.20;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Fix sync callbacks for list-type DMA channels. Improve handling of Service_PreReset.
Detail:
  s/DMA - Fixed sync callback logic of list-type channels to match that used by buffer-type channels. Old logic would result in too many sync callbacks being made at the start of a transfer, followed by dmar_Gap becoming negative and (potentially) no sync callbacks being made for the remainder of the transfer.
  s/Front, s/ModHead, s/SWI - Make SWI handler refuse to service any SWI following Service_PreReset. This helps avoid bad things happening should a client try to access DMA channels/transfers after we've reset everything during PreReset (although really it's our own fault for not telling the clients about the controller reset)
  Resources/UK/Messages, s/Errors - Define the error that we return when called following Service_PreReset.
Admin:
  Tested on Raspberry Pi


Version 0.21. Tagged as 'DMA-0_21'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.SWI

SWInames
        DCB     "DMA",0
        DCB     "RegisterChannel",0
        DCB     "DeregisterChannel",0
        DCB     "QueueTransfer",0
        DCB     "TerminateTransfer",0
        DCB     "SuspendTransfer",0
        DCB     "ResumeTransfer",0
        DCB     "ExamineTransfer",0
      [ HAL
        DCB     "AllocateLogicalChannels",0
      ]
        DCB     0
                ALIGN

 [ :LNOT: HAL

; These are the tables for IOMD1.

;-----------------------------------------------------------------------------
; LogicalChannel table.
;
LogicalChannel
        DCD     &000    ; Podule 0, DMA line 0, channel 2
;       DCD     &001    ; Podule 0, DMA line 1, not supported
        DCD     &010    ; Podule 1, DMA line 0, channel 3
;       DCD     &011    ; Podule 1, DMA line 1, not supported
;       DCD     &020    ; Podule 2, DMA line 0, not supported
;       DCD     &021    ; Podule 2, DMA line 1, not supported
;       DCD     &030    ; Podule 3, DMA line 0, not supported
;       DCD     &031    ; Podule 3, DMA line 1, not supported
;       DCD     &040    ; Podule 4, DMA line 0, not supported
;       DCD     &041    ; Podule 4, DMA line 1, not supported
;       DCD     &050    ; Podule 5, DMA line 0, not supported
;       DCD     &051    ; Podule 5, DMA line 1, not supported
;       DCD     &060    ; Podule 6, DMA line 0, not supported
;       DCD     &061    ; Podule 6, DMA line 1, not supported
;       DCD     &070    ; Podule 7, DMA line 0, not supported
;       DCD     &071    ; Podule 7, DMA line 1, not supported
;       DCD     &100    ; On-board SCSI, not supported
        DCD     &101    ; On-board Floppy, channel 1
        DCD     &102    ; Parallel, channel 1
        DCD     &103    ; Sound out, channel 4
        DCD     &104    ; Sound in, channel 5
        DCD     &105    ; Network Card, channel 0

        ASSERT .-LogicalChannel = NoLogicalChannels :SHL: 2

;-----------------------------------------------------------------------------
; PhysicalChannel table.
;       Maps logical channel to physical channel.
;
PhysicalChannel
        DCB     2
        DCB     3
        DCB     1
        DCB     1
        DCB     4
        DCB     5
        ASSERT .-PhysicalChannel = NoPhysicalChannels
        DCB     0
        ALIGN

 ]

;---------------------------------------------------------------------------
;       Handle SWI calls to our module.
;
SWIhandler
        LDR     r12, [r12]
      [ HAL
        LDRB    r10, PreReset
        TEQ     r10, #0
        BNE     SWIPreResetError
      ]
        CMP     r11, #(SWItabend-SWItabstart):SHR:2
        ADDCC   pc, pc, r11, LSL #2
        B       SWIerror

SWItabstart
        B       SWIRegisterChannel
        B       SWIDeregisterChannel
        B       SWIQueueTransfer
        B       SWITerminateTransfer
        B       SWISuspendTransfer
        B       SWIResumeTransfer
        B       SWIExamineTransfer
      [ HAL
        B       SWIAllocateLogicalChannels
      ]
SWItabend

SWIerror
        ADR     r0, ErrorBlock_DMA_BadSWI
 [ international
        ADRL    r4, Title
 ]
        DoError

 [ HAL
SWIPreResetError
        ADR     r0, ErrorBlock_DMA_PreReset
        DoError
        MakeErrorBlock  DMA_PreReset
 ]

        MakeErrorBlock  DMA_BadSWI

;---------------------------------------------------------------------------
; SWIRegisterChannel
;       In:     r0  = flags
;                       bit     meaning
;             [ HAL
;                       0-3     post-transfer channel delay
;                       4       disable burst transfers
;                       5       disable DRQ synchronisation to clock
;                       6-31    reserved (set to 0)
;             |
;                       0-31    reserved (set to 0)
;             ]
;               r1  = logical channel
;               r2  = DMA cycle speed (0-3)
;               r3  = transfer unit size (1,2,4 or 16)
;               r4  ->vector routine
;               r5  = value to pass to vector routine in r12
;             [ HAL
;               r6  = peripheral read/receive physical address, or -1 to disallow reads
;               r7  = peripheral write/transmit physical address, or -1 to disallow writes
;             ]
;
;       Out:    r0  = channel handle
;               all other registers preserved
;
;       Register a channel handling vector with the DMA manager.
;
SWIRegisterChannel      ROUT
      [ HAL
        Entry   "r1-r4,r8-r9"

        Debug   swi,"SWIRegisterChannel",r1

        ; For now assume that we must fault re-registration of the same channel.
        ; (This will need to change when we support memory-to-memory DMA.)
        ADR     r9, ChannelList - lcb_Next
10      LDR     r8, [r9, #lcb_Next]
        TEQ     r8, #0
        BEQ     %FT15
        LDR     lr, [r8, #lcb_ChannelNo]
        TEQ     lr, r1
        MOVNE   r9, r8
        BNE     %BT10
        PullEnv
        ADR     r0, ErrorBlock_DMA_AlreadyClaimed
        DoError

15      ; We can safely register this channel.
        Push    "r0,r2-r3"
        MOV     r0, #ModHandReason_Claim
        MOV     r3, #LCBSize
        SWI     XOS_Module
        ADDVS   sp, sp, #3*4
        EXIT    VS
        MOV     r0, #0
        ASSERT  lcb_Next = 0
        ASSERT  lcb_ChannelNo = lcb_Next + 4
        STMIA   r2, {r0,r1}
        MOV     lr, r2
        ADD     r8, r2, #lcb_Flags
        Pull    "r0,r2-r3"

        CMP     r2, #4                          ; Validate cycle speed.
        PullEnv CS
        ADRCS   r0, ErrorBlock_DMA_BadCycleSpeed
        DoError CS

        CMP     r3, #32                         ; Validate transfer unit size.
        PullEnv CS
        ADRCS   r0, ErrorBlock_DMA_BadTransferUnit
        DoError CS

        TST     r4, #3                          ; Ensure vector table is word aligned.
        PullEnv NE
        ADRNE   r0, ErrorBlock_DMA_BadAddress
        DoError NE

        ORR     r0, r3, r0, LSL #8              ; Build flags in r0.
        ORR     r0, r0, r2, LSL #5

        ASSERT  lcb_Vector = lcb_Flags + 4
        ASSERT  lcb_R12 = lcb_Vector + 4

        STMIA   r8!, {r0,r4-r5}

        MOV     r5, r1                          ; r5 = logical channel number
        LDR     r4, CtrlrList
30      TEQ     r4, #0
        ADREQ   r0, ErrorBlock_DMA_BadChannel   ; Not found so return error.
        BEQ     %FT99
        LDR     r0, [r4, #ctrlr_Device]
        MOV     r1, r5
        CallHAL DMACAllocate, lr
        TEQ     r0, #0
        LDREQ   r4, [r4, #ctrlr_Next]
        BEQ     %BT30                           ; Not supported by this controller so try next one.

        ; Search for the DMA queue for this physical channel (there must be one)
        ADD     r3, r4, #ctrlr_DMAQueues
        LDR     r1, [r4, #ctrlr_PhysicalChannels]
80      LDR     r4, [r3, #dmaq_DMADevice]
        TEQ     r0, r4
        SUBNES  r1, r1, #1
        ADDNE   r3, r3, #DMAQSize
        BNE     %BT80                           ; Terminate loop anyway in case of broken HAL code.

        ASSERT  lcb_Queue = lcb_R12 + 4
        ASSERT  lcb_PeripheralRead = lcb_Queue + 4
        ASSERT  lcb_PeripheralWrite = lcb_PeripheralRead + 4

        STMIA   r8, {r3,r6-r7}

        LDR     r8, [r3, #dmaq_Usage]
        CMP     r8, #0                          ; Is this the first time we've used this physical channel?
        ADD     r8, r8, #1
        BNE     %FT85                           ; If not, no more physical memory is needed.
        LDRB    r0, [r4, #HALDevice_Type + 0]
        CMP     r0, #HALDeviceSysPeri_DMAL      ; List devices always need memory.
        LDRNE   r1, [r4, #HALDevice_Device]
        CMPNE   r1, #-1                         ; Buffer devices need a bounce buffer iff they have no interrupt.
        BNE     %FT85

        CMP     r0, #HALDeviceSysPeri_DMAL
        LDREQ   r2, [r3, #dmaq_DeviceFeatures]
        MOVNE   r0, #BOUNCEBUFFSIZE
        LDREQ   r0, [r2, #DMAFeaturesBlock_BlockSize]
        MOVNE   r1, #BOUNCEBUFFSIZE
        LDREQ   r1, [r2, #DMAFeaturesBlock_BlockAlign]
        MOVNE   r2, #BOUNCEBUFFSIZE
        LDREQ   r2, [r2, #DMAFeaturesBlock_BlockBound]
        Push    "lr"
        SWI     XPCI_RAMAlloc
        Pull    "lr"
        BVS     %FT90
        LDRB    r2, [r4, #HALDevice_Type + 0]
        CMP     r2, #HALDeviceSysPeri_DMAL
        STRNE   r0, [r3, #dmaq_BounceBuff + ptab_Logical]
        STREQ   r0, [r3, #dmaq_DescBlockLogical]
        STRNE   r1, [r3, #dmaq_BounceBuff + ptab_Physical]
        STREQ   r1, [r3, #dmaq_DescBlockPhysical]
85      STR     r8, [r3, #dmaq_Usage]

        ; Link this block on the end of the list, so system channels get found as quickly as possible.
        STR     lr, [r9, #lcb_Next]

        ; Return channel handle in r0.
        MOV     r0, lr

        Debug   swi," channel handle =",r0

        EXIT

90
        Push    "r0"
        MOV     r0, #ModHandReason_Free
        MOV     r2, r8
        SWI     XOS_Module
        Pull    "r0"
        SETV
        EXIT
99
        Push    "r0"
        MOV     r0, #ModHandReason_Free
        MOV     r2, r8
        SWI     XOS_Module
        Pull    "r0"
        PullEnv
        DoError

      |

        Entry   "r6-r8"

        Debug   swi,"SWIRegisterChannel",r1

        ADR     r6, LogicalChannel              ; Find the logical channel number.
        MOV     lr, #NoLogicalChannels * 4
10
        SUBS    lr, lr, #4                      ; Work back from end of table.
        PullEnv CC                              ; Not found so return error.
        ADRCC   r0, ErrorBlock_DMA_BadChannel
        DoError CC
        LDR     r7, [r6, lr]
        TEQ     r1, r7
        BNE     %BT10

        ASSERT  LCBSize = 20
        ADR     r8, ChannelBlock
        ADD     r8, r8, lr, LSL #2
        ADD     r8, r8, lr                      ; r8->logical channel block

        LDR     r6, [r8, #lcb_Flags]
        TST     r6, #lcbf_Registered
        PullEnv NE                              ; Return error if already claimed.
        ADRNE   r0, ErrorBlock_DMA_AlreadyClaimed
        DoError NE

        CMP     r2, #4                          ; Validate cycle speed.
        PullEnv CS
        ADRCS   r0, ErrorBlock_DMA_BadCycleSpeed
        DoError CS

        TEQ     r3, #1                          ; Validate transfer unit size.
        TEQNE   r3, #2
        TEQNE   r3, #4
        TEQNE   r3, #16
        PullEnv NE
        ADRNE   r0, ErrorBlock_DMA_BadTransferUnit
        DoError NE

        TST     r4, #3                          ; Ensure vector table is word aligned.
        PullEnv NE
        ADRNE   r0, ErrorBlock_DMA_BadAddress
        DoError NE

        ORR     r0, r3, r2, LSL #5              ; Build flags in r0.
        ORR     r0, r0, #lcbf_Registered

        ADR     r6, PhysicalChannel
        LDRB    r7, [r6, lr, LSR #2]            ; r7 = physical channel number
        PhysToDMAQ r6, r7                       ; r6->DMA queue

        ASSERT  lcb_Flags = 0
        ASSERT  lcb_Vector = lcb_Flags + 4
        ASSERT  lcb_R12 = lcb_Vector + 4
        ASSERT  lcb_Queue = lcb_R12 + 4
        ASSERT  lcb_Physical = lcb_Queue + 4

        STMIA   r8, {r0,r4-r7}                  ; Store flags, vector, r12 value, queue and physical channel.

        MOV     r0, lr, LSR #2                  ; Return channel handle in r0.

        Debug   swi," channel handle =",r0

        TEQ     r7, #4                          ; If not registering a sound channel then
        TEQNE   r7, #5
        EXIT    NE                              ;   exit.

        Push    "r0-r2"

        IOMDBase r8
        IRQOff  r6, lr

        LDRB    r6, [r8, #IOMD_IOTCR]           ; Otherwise set up transfer size/speed in IOTCR.
        AND     r6, r6, #&0F
        ORR     r6, r6, r3, LSL #6
        ORR     r6, r6, r2, LSL #4
        STRB    r6, [r8, #IOMD_IOTCR]

        LDRB    r6, [r8, #IOMD_DMAMSK]          ; Disable sound channel and set up to claim device.
        TEQ     r7, #4
        MOVEQ   r0, #IOMD_DMASound0_DevNo
        ADREQL  r1, DMAInterruptSound0
        BICEQ   r6, r6, #IOMD_DMA_SD0
        MOVNE   r0, #IOMD_DMASound1_DevNo
        ADRNEL  r1, DMAInterruptSound1
        BICNE   r6, r6, #IOMD_DMA_SD1
        STRB    r6, [r8, #IOMD_DMAMSK]

        SetPSR  lr

        Debug   swi," claiming device vector",r0

        MOV     r2, r12
        SWI     XOS_ClaimDeviceVector           ; Claim appropriate sound device vector.

        Pull    "r0-r2"
        EXIT
      ]

        MakeErrorBlock  DMA_BadChannel
        MakeErrorBlock  DMA_AlreadyClaimed
        MakeErrorBlock  DMA_BadCycleSpeed
        MakeErrorBlock  DMA_BadTransferUnit
        MakeErrorBlock  DMA_BadAddress

;---------------------------------------------------------------------------
; SWIDeregisterChannel
;       In:     r0  = channel handle
;
;       Out:    all registers preserved
;
;       Deregister a previously registered channel handling vector.
;
SWIDeregisterChannel
      [ HAL
        Entry   "r0-r3,r7-r9"
      |
        Entry   "r1,r7,r8"
      ]

        Debug   swi,"SWIDeregisterChannel",r0

      [ HAL
        ADR     r9, ChannelList - lcb_Next
01      LDR     lr, [r9, #lcb_Next]
        TEQ     lr, #0
        TEQNE   lr, r0
        MOVNE   r9, lr
        BNE     %BT01
        TEQ     lr, #0                          ; Was handle in list?
        PullEnv EQ
        ADREQ   r0, ErrorBlock_DMA_BadHandle    ; No, so generate error.
        DoError EQ
        LDR     lr, [lr, #lcb_Next]             ; Delink.
        STR     lr, [r9, #lcb_Next]
      |
        CMP     r0, #NoLogicalChannels          ; Ensure handle in range.
        PullEnv CS
        ADRCS   r0, ErrorBlock_DMA_BadHandle
        DoError CS
      ]

        LCBlock r8, r0
      [ :LNOT: HAL
        LDR     r7, [r8, #lcb_Flags]            ; Ensure it's been claimed.
        TST     r7, #lcbf_Registered
        PullEnv EQ
        ADREQ   r0, ErrorBlock_DMA_BadHandle
        DoError EQ
      ]

        MOV     r7, #0                          ; Mark logical channel as not claimed.
      [ :LNOT: HAL
        STR     r7, [r8, #lcb_Flags]
      ]
        BL      DMAPurge                        ; r7=0 so new transfers can start.

      [ HAL
        LDR     r9, [r8, #lcb_Queue]
        LDR     r2, [r9, #dmaq_DMADevice] ; API 1.x requires r2 to be channel device ptr
        LDR     r0, [r2, #HALDevice_DMAController]
        LDR     r1, [r8, #lcb_ChannelNo]
        CallHAL DMACDeallocate

        LDR     r1, [r9, #dmaq_Usage]           ; Free the bounce buffer if necessary.
        SUBS    r1, r1, #1
        STR     r1, [r9, #dmaq_Usage]
        BNE     %FT80
        LDR     r0, [r9, #dmaq_BounceBuff + ptab_Logical]
        TEQ     r0, #0
        STRNE   r1, [r9, #dmaq_BounceBuff + ptab_Logical]
        STRNE   r1, [r9, #dmaq_BounceBuff + ptab_Physical]
        SWINE   XPCI_RAMFree
        LDR     r0, [r9, #dmaq_DescBlockLogical]
        TEQ     r0, #0
        STRNE   r1, [r9, #dmaq_DescBlockLogical]
        STRNE   r1, [r9, #dmaq_DescBlockPhysical]
        SWINE   PCI_RAMFree
80
        MOV     r0, #ModHandReason_Free
        MOV     r2, r8
        SWI     XOS_Module
        CLRV
      |
        TEQ     r0, #4
        TEQNE   r0, #5
        EXIT    NE                              ; If not a sound channel then exit.

        TEQ     r0, #4                          ; Release appropriate sound device vector.
        MOVEQ   r0, #IOMD_DMASound0_DevNo
        ADREQL  r1, DMAInterruptSound0
        MOVNE   r0, #IOMD_DMASound1_DevNo
        ADRNEL  r1, DMAInterruptSound1
        MOV     r2, r12
        SWI     XOS_ReleaseDeviceVector
      ]
        EXIT

        MakeErrorBlock  DMA_BadHandle

;---------------------------------------------------------------------------
; SWIQueueTransfer
;       In:     r0  = flags
;                       bit     meaning
;                       0       transfer direction:
;                               0 = from device to memory (read)
;                               1 = from memory to device (write)
;                       1       1 = scatter list is circular buffer
;                       2       1 = call DMASync callback
;                       3-31    reserved (set to 0)
;               r1  = channel handle
;               r2  = value to pass to vector routine in r11
;               r3  ->word aligned scatter list
;               r4  = length of transfer (in bytes)
;               r5  = size of circular buffer (if used)
;               r6  = number of bytes between DMASync callbacks (if used)
;
;       Out:    r0  = DMA tag
;               all other registers preserved
;
;       Queues a DMA request for the specified channel.
;
SWIQueueTransfer
        Entry   "r5-r11"

        Debug   swi,"SWIQueueTransfer, channel handle =",r1

      [ HAL
        LDR     lr, ChannelList
01      TEQ     lr, #0
        TEQNE   lr, r1
        LDRNE   lr, [lr, #lcb_Next]
        BNE     %BT01
        TEQ     lr, #0                          ; Was handle in list?
        PullEnv EQ
        ADREQ   r0, ErrorBlock_DMA_BadHandle    ; No, so generate error.
        DoError EQ
      |
        CMP     r1, #NoLogicalChannels          ; Ensure handle in range.
        PullEnv CS
        ADRCS   r0, ErrorBlock_DMA_BadHandle
        DoError CS
      ]

        LCBlock r8, r1
        LDR     lr, [r8, #lcb_Flags]            ; Ensure it's been claimed.
      [ :LNOT: HAL
        TST     lr, #lcbf_Registered
        PullEnv EQ
        ADREQ   r0, ErrorBlock_DMA_BadHandle
        DoError EQ
      ]

        TST     r3, #3                          ; Ensure scatter list is word aligned.
        PullEnv NE
        ADRNE   r0, ErrorBlock_DMA_BadAddress
        DoError NE

        TST     r0, #dmarf_Circular             ; If not circular then
        MOVEQ   r5, #0                          ;   buff size = 0
        MOVEQ   r7, r4                          ;   test for zero length below
        MOVNE   r7, r5                          ; else test for zero buffer size below
        ORRNE   r0, r0, #dmarf_Infinite         ;   assume infinite
        TEQNE   r4, #0                          ;   but if length<>0 then
        BICNE   r0, r0, #dmarf_Infinite         ;     not infinite.

        TEQ     r7, #0
        PullEnv EQ
        ADREQ   r0, ErrorBlock_DMA_ZeroLength
        DoError EQ

      [ HAL
        LDR     r7, [r8, #lcb_Queue]
        LDR     r7, [r7, #dmaq_DescBlockLogical]
        TEQ     r7, #0
        BEQ     %FT05
        LDR     r7, [r8, #lcb_Queue]            ; If it's a list device,
        LDR     r7, [r7, #dmaq_DeviceFeatures]
        LDR     r7, [r7, #DMAFeaturesBlock_Flags]
        TST     r0, #dmarf_Circular             ;   ensure it can do circular transfers if appropriate,
        TSTNE   r7, #DMAFeaturesFlag_NotCircular
        PullEnv NE
        ADRNE   r0, ErrorBlock_DMA_NotCircular
        DoError NE
        TST     r0, #dmarf_Infinite             ;   and check infinite transfers likewise.
        TSTNE   r7, #DMAFeaturesFlag_NotInfinite
        PullEnv NE
        ADRNE   r0, ErrorBlock_DMA_NotInfinite
        DoError NE
        B       %FT06                           ; We know we're not using a bounce buffer, so skip next test.
05
        CMP     r4, #BOUNCEBUFFSIZE             ; If longer than bounce buffer length
        ANDLS   r7, r0, #dmarf_Infinite
        CMPLS   r7, #0                          ;   or infinite transfer
        LDRHI   r7, [r8, #lcb_Queue]
        LDRHI   r7, [r7, #dmaq_BounceBuff + ptab_Logical]
        CMPHI   r7, #0                          ;   and we're using a bounce buffer
        PullEnv HI
        ADRHI   r0, ErrorBlock_DMA_TransferTooLong
        DoError HI                              ;   then do error.
06
      ]

        TST     r0, #dmarf_Sync                 ; If not calling DMASync then
        MOVEQ   r6, #0                          ;   sync gap = 0
        BEQ     %FT10
        TEQ     r6, #0
        PullEnv EQ
        ADREQ   r0, ErrorBlock_DMA_ZeroLength
        DoError EQ
10
        AND     lr, lr, #lcbf_TransferSize      ; lr=flags from above
        SUB     lr, lr, #1
        TST     lr, r4                          ; Ensure length is multiple of transfer unit size.
        TSTEQ   lr, r5                          ; Ensure buff size is multiple of t.u.s.
        TSTEQ   lr, r6                          ; Ensure sync gap is multiple of t.u.s.
        PullEnv NE
        ADRNE   r0, ErrorBlock_DMA_BadSize
        DoError NE

        ASSERT  dmar_R11 = dmar_Flags + 4
        ASSERT  dmar_ScatterList = dmar_R11 + 4
        ASSERT  dmar_Length = dmar_ScatterList + 4
        ASSERT  dmar_BuffSize = dmar_Length + 4
        ASSERT  dmar_SyncGap = dmar_BuffSize + 4
        ASSERT  dmar_Done = dmar_SyncGap + 4
        ASSERT  dmar_LCB = dmar_Done + 4
        ASSERT  dmar_PageTable = dmar_LCB + 4

        BL      DMAGetRequestBlock              ; Set up request block (r10=pointer).
        EXIT    VS

        ADD     lr, r10, #dmar_Flags
        MOV     r7, #0                          ; Set amount done to 0.
        MOV     r9, #0                          ; Set no page table
        Debug   swi," flags,r11,scat,len,buffsz,gap,LCB =",r0,r2,r3,r4,r5,r6,r8
        STMIA   lr, {r0,r2-r9}                  ; Store flags, r11, scat list, length, buff size, gap, done, LCB, page table.
      [ HAL
        STR     r7, [lr, #dmar_DoneAtStart - dmar_Flags]
      ]

        LDR     r5, TagIndex                    ; Build DMA request tag in r0.
        ADD     r5, r5, #1
      [ HAL
        STR     r5, [r10, #dmar_TagBits01]
        AND     r0, r5, #3
        ORR     r0, r0, r10
      |
        LDR     lr, [r8, #lcb_Physical]
        ORR     r0, lr, r5, LSL #3
        STR     r0, [r10, #dmar_Tag]
      ]

        Debug   swi," DMA tag = ",r0

        LDR     r9, [r8, #lcb_Queue]            ; r9->DMA queue
      [ HAL
        STR     r9, [r10, #dmar_Queue]
      ]
        BL      DMALinkRequest                  ; Stick it on the queue.
      [ :LNOT: HAL
        IOMDBase r11
      ]
        BL      DMAActivate                     ; Try to activate it.
        STRVC   r5, TagIndex
        STRVS   r7, [r9, #dmaq_Active]          ; If activate returned error then unblock channel
        BLVS    DMAUnlinkRequest                ;   and delete request.
        BLVS    DMAFreeRequestBlock
        EXIT

        MakeErrorBlock  DMA_ZeroLength
      [ HAL
        MakeErrorBlock  DMA_NotCircular
        MakeErrorBlock  DMA_NotInfinite
        MakeErrorBlock  DMA_TransferTooLong
      ]
        MakeErrorBlock  DMA_BadSize

;---------------------------------------------------------------------------
; SWITerminateTransfer
;       In:     r0  ->error block
;               r1  = DMA tag
;
;       Out:    all registers preserved
;
;       Terminate a DMA transfer if it is active or just remove from the queue.
;
SWITerminateTransfer
        Entry   "r0,r8-r11"

        Debug   swi,"SWITerminateTransfer",r1

        BL      DMAFindTag
        STRVS   r0, [sp]
        EXIT    VS

        TEQ     r0, #0                          ; If caller provides no error then
        ADREQ   r0, ErrorBlock_DMA_Terminated   ;   use our own (or DMATerminate will think we're suspending).
        BLEQ    MsgTrans_ErrorLookup

        LDR     r8, [r10, #dmar_LCB]            ; r8->logical channel block
      [ :LNOT: HAL
        IOMDBase r11
      ]
        CLRV
        BL      DMATerminate                    ; Terminate (if active, physical channel remains blocked).
        STRVS   r0, [sp]
        EXIT    VS

        BL      DMAUnlinkRequest
        LDR     lr, [r10, #dmar_Flags]
        TST     lr, #dmarf_Blocking :OR: dmarf_Halted ; If it was blocking logical channel then
        LDRNE   lr, [r8, #lcb_Flags]            ;   unblock it.
        BICNE   lr, lr, #lcbf_Blocked
        STRNE   lr, [r8, #lcb_Flags]
        LDR     lr, [r9, #dmaq_Active]
        TEQ     lr, r10                         ; If it was active then
        BLEQ    DMASearchQueue                  ;   try to start something else (unblock physical channel).
        BL      DMAFreeRequestBlock

        EXIT

        MakeErrorBlock  DMA_Terminated

;---------------------------------------------------------------------------
; SWISuspendTransfer
;       In:     r0  = flags
;                       bit     meaning
;                       0       0 = don't start queued transfers
;                               1 = start next queued transfer
;                       1-31    reserved (set to 0)
;               r1  = DMA tag
;
;       Out:    all registers preserved
;
;       Suspend a DMA transfer.
;
SWISuspendTransfer
        Entry   "r0,r8-r11"

        Debug   swi,"SWISuspendTransfer",r1

        BL      DMAFindTag
        STRVS   r0, [sp]
        EXIT    VS

        LDR     r8, [r10, #dmar_LCB]            ; r8->logical channel block
      [ :LNOT: HAL
        IOMDBase r11
      ]
        MOV     r0, #0                          ; Suspend not terminate.
        BL      DMATerminate                    ; Terminate (physical channel should remain blocked).
        STRVS   r0, [sp]
        EXIT    VS

        LDR     lr, [r10, #dmar_Flags]
        TST     lr, #dmarf_Completed            ; If completed anyway then
        BLNE    DMAUnlinkRequest                ;   free block,
        BLNE    DMAFreeRequestBlock
        BNE     %FT10                           ;   and unblock physical channel.

      [ HAL
        ORR     lr, lr, #dmarf_Suspended        ; Mark as suspended.
      |
        ORR     lr, lr, #dmarf_Suspended :OR: dmarf_BeenActive  ; Mark as suspended and been active.
      ]
        LDR     r0, [sp]
        TST     r0, #&00000001                  ; If don't want queued transfers to start
        LDREQ   r0, [r8, #lcb_Flags]
        TSTEQ   r0, #lcbf_Blocked               ;     and the channel is not blocked already then
        ORREQ   r0, r0, #lcbf_Blocked           ;   block logical channel
        STREQ   r0, [r8, #lcb_Flags]
        ORREQ   lr, lr, #dmarf_Blocking         ;   and mark as blocking.
        STR     lr, [r10, #dmar_Flags]
10
        BL      DMASearchQueue                  ; Try to start another request (unblock physical channel).
        EXIT

;---------------------------------------------------------------------------
; SWIResumeTransfer
;       In:     r0  = flags
;                       bit     meaning
;                       0       1 = move to head of queue
;                       1-31    reserved (set to 0)
;               r1  = DMA tag
;
;       Out:    all registers preserved
;
;       Resume a previously suspended DMA transfer.
;
SWIResumeTransfer
        Entry   "r8-r11"

        Debug   swi,"SWIResumeTransfer",r1

        BL      DMAFindTag
        EXIT    VS

        LDR     lr, [r10, #dmar_Flags]          ; Make sure it's suspended.
        TST     lr, #dmarf_Suspended
        PullEnv EQ
        ADREQ   r0, ErrorBlock_DMA_NotSuspended
        DoError EQ

        LDR     r8, [r10, #dmar_LCB]            ; r8->logical channel block
        BIC     lr, lr, #dmarf_Suspended        ; Mark as not suspended.
        TST     lr, #dmarf_Blocking             ; If blocking then
        BICNE   lr, lr, #dmarf_Blocking         ;   clear blocking bit.
        STR     lr, [r10, #dmar_Flags]
        BEQ     %FT10
        TST     lr, #dmarf_Halted               ; If not now halted either then
        LDREQ   lr, [r8, #lcb_Flags]            ;   unblock logical channel.
        BICEQ   lr, lr, #lcbf_Blocked
        STREQ   lr, [r8, #lcb_Flags]
10
      [ :LNOT: HAL
        IOMDBase r11
      ]
        BL      DMAActivate
        MOVVS   lr, #0                          ; If Start callback returned error then
        STRVS   lr, [r9, #dmaq_Active]          ;   unblock channel
        BLVS    DMAUnlinkRequest                ;   and delete request.
        BLVS    DMAFreeRequestBlock
        EXIT

        MakeErrorBlock  DMA_NotSuspended

;---------------------------------------------------------------------------
; SWIExamineTransfer
;
;       In:     r0  = flags
;                       bit     meaning
;                       0-31    reserved (set to 0)
;               r1  = DMA tag
;
;       Out:    r0  = number of bytes transferred so far, or error pointer (eg "Bus error")
;               All other registers preserved
;
;       Examine the progress of an active DMA transfer.
;
SWIExamineTransfer
      [ HAL
        Entry   "r1,r6-r10"
      |
        Entry   "r1,r7-r10"
      ]

        Debug   swi,"SWIExamineTransfer",r1

        BL      DMAFindTag
        EXIT    VS

        IRQOff  lr, r7                          ; Stop interrupt routine finishing transfer.

      [ :LNOT: HAL
        LDR     lr, [r10, #dmar_Tag]            ; Make sure it's still there.
        TEQ     lr, r1
        ADRNE   r0, ErrorBlock_DMA_BadTag
        BNE     %FT10
      ]

        LDR     r1, [r10, #dmar_Done]           ; Get amount of transfer done.
        LDR     r8, [r10, #dmar_LCB]            ; r8->logical channel block
        LDR     lr, [r10, #dmar_Flags]
        TST     lr, #dmarf_Completed + dmarf_Suspended
        MOVNE   r0, #0                          ; If completed or suspended then just return dmar_Done.
        BNE     %FT05

        LDR     r0, [r9, #dmaq_Active]
        CMP     r0, r10
        MOVNE   r0, #0                          ; If not yet started then then just return dmar_Done (which will be 0).
      [ HAL
        BNE     %FT05
        LDR     r6, [r10, #dmar_Length]         ; Remember the amount that was to be done (DMAActiveDone may change this).
        TST     lr, #dmarf_Infinite
        MOVNE   r6, #-1                         ; If infinite, pretend an unlikely amount still to do.
        BL      DMAActiveDone                   ; If transfer is active then get amount of active buffer done.
        LDR     lr, [r9, #dmaq_DMADevice]
        LDR     lr, [lr, #HALDevice_Device]
        TestMinusOne lr
        BNE     %FT05                           ; If device has its own interrupt, then let it handle completion or errors.
        TEQVC   r0, r6
        BNE     %FT05                           ; If no error and stuff still to do, take no action.
        Push    "r0"
        MOVVC   r0, #0
        Push    "r0"
        BL      DMACompleted
        BL      DMAUnlinkRequest
        BL      DMAFreeRequestBlock
        BL      DMASearchQueue
        Pull    "r0"
        TEQ     r0, #0
        SETV    NE
        Pull    "r0"
      |
        BLEQ    DMAActiveDone                   ; If transfer is active then get amount of active buffer done.
      ]
05
        SetPSR  r7,, c
        ADDVC   r0, r0, r1                      ; Return total (if not error).
        EXIT

      [ :LNOT: HAL
10
        SetPSR  r7
        PullEnv
        DoError
      ]


 [ HAL
;---------------------------------------------------------------------------
; SWIAllocateLogicalChannels
;
;       In:     r0  = number of channels to allocate
;
;       Out:    r0  = number of first channel
;               All other registers preserved
;
;       Allocate one or more logical channels.
;
SWIAllocateLogicalChannels
        LDR     r10, NextLogicalChannel
        ADD     r11, r10, r0
        STR     r11, NextLogicalChannel
        MOV     r0, r10
        MOV     pc, lr
 ]


        END
@


4.8
log
@API enhancements and fixes
ModHead.s: Allow list type channels to specify NoInitIRQ. Respect the flag when deciding whether or not to unmask the IRQ at the HAL level
DMA.s: Use the cached device flags rather than incurring a function call, refactor the call to DMASetListTransfer to use the CallHAL macro
SWI.s: The transfer unit size check was against the wrong register
hdr/DMADevice: Comment updated to reflect wider flag use

Tested with IOMD HAL, no longer aborts on module init because the channel interrupt fires before any lists have been prepared (it does have an initial IRQ), with various transfer sizes.

Version 0.20. Tagged as 'DMA-0_20'
@
text
@d87 5
d116 7
@


4.7
log
@DMAManager fixes & improvements
Detail:
  DMA.s, in DMAForceActivate: Support for the NoInitIRQ flag for interrupt-driven buffer-type channels (API 1+)
  DMA.s, 'testloop': Fix handling of interrupt-driven buffer-type channels so DMAManager doesn't immediately crash or malfunction
  DMA.s, 'overrun', 'earlyoverrun', 'nooverrun': Fix handling of interrupt-driven buffer-type channels so IRQ state is cleared before the next stage of the transfer is programmed (to avoid missing IRQs)
  DMA.s, 'finished': Fix handling of interrupt-driven buffer-type channels so R8 is loaded with the logical channel block ptr, as expected by subsequent function calls.
  Front.s: Make dmaq_Trampoline larger to allow it to contain the HAL device ptr
  GetAll.s: Add Hdr:HALEntries to GET list, as required by 'ClaimVectors' fix in ModHead.s
  ModHead.s: Update controller handling code to cope with API versions 0.1 (TestIRQ2) & 1 ('Deallocate' passed channel device ptr)
  ModHead.s: Fix 'ClaimVectors' to call HAL_IRQEnable to enable IRQs for the detected channels/controllers.
  ModHead.s: Fix IRQ handler trampolines so that they call HALDevice_TestIRQ on the channel instead of branching to a random address in memory
  SWI.s: Support for controller API 1 (pass channel device ptr to 'Deallocate' in R2)
  hdr/DMADevice: Extra flags & entries for new DMA controller & buffer API versions
Admin:
  Tested on rev C2 beagleboard with the incoming HAL DMA driver. API revisions are documented in more detail on the ROOL wiki.


Version 0.18. Tagged as 'DMA-0_18'
@
text
@d180 1
a180 1
        CMP     r2, #32                         ; Validate transfer unit size.
@


4.6
log
@  Three bugfixes (as it happens, all were introduced with the support for
  multiple DMA controllers).
Detail:
  * Service_PagesSafe handler would abort if the restarting transfer had
    more than one entry in its scatter list
  * Logical channels remained linked into the chain during mass
    deregistration in module finalisation, allowing new transfers to be
    queued
  * Logical channel (RMA) block wasn't freed in DMA_DeregisterChannel
Admin:
  Tested on Tungsten with UDMA ADFS, pscramble and the Task Manager.

Version 0.17. Not tagged
@
text
@d443 2
a444 2
        LDR     r0, [r9, #dmaq_DMADevice]
        LDR     r0, [r0, #HALDevice_DMAController]
@


4.5
log
@  A few weeks' dedicated work, mainly to support UDMA hard discs.
Detail:
  Features:
  * Supports physical channels using a new type of HAL device (&303) where
    the hardware takes a pointer to a scatter list up front to effect the
    entire transfer, and which may report hardware errors at any time.
    For full details, see Doc.HAL_DMAAPI.
  * Page tables are no longer generated when using a bounce-buffer, since
    they aren't actually any use except in determining if unsafe pages
    intersect with the transfer. Instead, bounce-buffer transfers are halted
    whenever any page becomes unsafe, and no new bounce-buffer transfers can
    be started while any pages are unsafe.
  * For both bounce-buffer and list-type devices, the Activate entry is
    now called after the transfer is programmed (with SetCurrentTransfer
    or SetListTransfer), since this is likely to be more useful for these
    types of devices. Note that for interrupt-driven buffer devices, it
    is still assumed that the default state of the device is to be in an
    underrun interrupt state, so the transfer is not programmed until the
    first time the interrupt routine is entered.
  * Now ensures that scatter list start addresses and lengths are all
    multiples of the transfer unit size (this check is done during page
    table construction, so will be returned via the Completed callback,
    rather than directly from DMA_QueueTransfer like the total length check).
  * When there is no interrupt associated with a physical channel (both for
    buffer- or list-type devices), if the polling of the hardware within SWI
    DMA_ExamineTransfer detects that the transfer has completed, then
    the transfer is shut down in the same was as though an interrupt had
    happened (ie the Completed callback is called without an error).
  * Added SWI DMA_AllocateLogicalChannels to act as a centralised allocator
    for session-unique logical DMA channels. Primarily a service to
    third-party authors of "HAL" devices.
  Bugfixes:
  * Now handles Service_MessageFileClosed to allow safe MessageTrans lookups
    in the background.
  * If a controller device was removed before its constituent channel
    devices, removing the channel device would abort.
  * Interrupt trampoline construction was wrong, the address of the
    interrupt handler code wasn't relocated. Also, non-vectored interrupts
    weren't correctly handled.
  * Transfers suspended by Service_PagesUnsafe weren't blocking the logical
    channel, so you could queue another transfer on the same channel and it
    would start immediately (although transfers already queued before the
    service call wouldn't have been started).
  * Transfers which had completed within Service_PagesUnsafe handler weren't
    being delinked from the queue.
  * Service_PagesSafe wasn't handled properly, meaning that none of the
    transfers that were halted by Service_PagesUnsafe were restarted! This
    was due to the use of routines in common with DMA_SuspendTransfer and
    DMA_ResumeTransfer which started with the first HALised version - these
    suspend a logical channel, unlike the original IOMD code which
    effectively suspends a physical channel. Thus the code to search for
    transfers to restart needs to be quite different, since the physical
    channel may be idle, or occupied with another logical channel, and
    each physical channel may have multiple associated logical channels
    that were on unsafe transfers!
  * When you deregistered a logical channel (including during module death)
    the Completed callback was called for all queued transfers, incorrectly
    including those that had not yet had the matching Start callback called.
  * There was a stack imbalance in the buffer device interrupt handler
    because the retained part of the old code assumed Hdr:Proc stack
    management, which the new code doesn't use (it's entered with the return
    address on the stack).
Admin:
  Tested with UDMA test harnesses on Tungsten (ADFS not yet complete).

Version 0.17. Tagged as 'DMA-0_17'
@
text
@d463 3
@


4.4
log
@Folded in HAL branch.

Version 0.16. Tagged as 'DMA-0_16'
@
text
@d26 3
d34 2
d99 3
d146 2
a147 2
        ; For now assume that we must fault re-registration of the same channel
        ; (this will need to change when we support memory-to-memory DMA).
d228 15
a242 7
        LDREQ   r1, [r4, #HALDevice_Device]
        CMPEQ   r1, #-1                         ; Does the device have an interrupt?
        BNE     %FT85                           ; If not, no bounce buffer is needed.

        MOV     r0, #BOUNCEBUFFSIZE
        MOV     r1, #BOUNCEBUFFSIZE
        MOV     r2, #BOUNCEBUFFSIZE
d244 1
a244 1
        SWI     XPCI_RAMAlloc                   ; Claim bounce buffer for this physical channel.
d247 6
a252 2
        STR     r0, [r3, #dmaq_BounceBuff + ptab_Logical]
        STR     r1, [r3, #dmaq_BounceBuff + ptab_Physical]
d457 5
d553 19
d580 2
a581 1
        DoError HI
d618 3
d653 2
d692 1
a692 1
        TST     lr, #dmarf_Blocking             ; If it was blocking logical channel then
d742 3
d746 1
d788 1
a788 1
        BICNE   lr, lr, #dmarf_Blocking         ;   clear blocking bit
d790 6
a795 4
        LDRNE   lr, [r8, #lcb_Flags]            ;   and unblock logical channel.
        BICNE   lr, lr, #lcbf_Blocked
        STRNE   lr, [r8, #lcb_Flags]

d816 1
a816 1
;       Out:    r0  = number of bytes transferred so far
d822 3
d826 1
d852 24
d877 1
d879 2
a880 2
        SetPSR  r7
        ADD     r0, r0, r1                      ; Return total.
d889 20
@


4.3
log
@  Main change is 32-bit compatibility.
Detail:
  Also
  * added Ursula service call table (not even the Phoebe version had one!)
  * fixed a bug: the Service_PagesUnsafe handler was returning with IRQs
    still disabled
Admin:
  Not tested.

Version 0.15. Tagged as 'DMA-0_15'
@
text
@d29 2
d75 2
d109 6
d116 1
d122 4
d133 131
d334 1
a334 1
        IRQOff  lr, r6
d361 1
d378 3
d382 1
d386 14
d404 1
d407 1
d413 1
d416 1
d418 1
d421 19
d451 1
d483 11
d498 1
d502 1
d507 1
d527 12
d576 5
d584 1
d589 3
d593 1
d595 1
d604 3
d632 1
d634 1
d678 1
d680 1
d740 1
d742 1
d773 1
a773 1
        IRQOff  r7, lr                          ; Stop interrupt routine finishing transfer.
d775 1
d780 1
d790 3
a792 2
        CMP     r0, r10                         ; If transfer is active then
        BLEQ    DMAActiveDone                   ;   get amount of active buffer done.
d797 2
d803 1
@


4.3.2.1
log
@  Commit of the HALised DMA Manager code, as it was when the IA division
  was closed.
Detail:
  This didn't get far beyond the design stage, but what there is is best kept
  safe in CVS in case it gets accidentally deleted again...
Admin:
  Don't even think about trying to build this version.

Version 0.15, 4.4.2.1. Tagged as 'DMA-0_15-4_4_2_1'
@
text
@d188 1
a188 1
        IRQOff  r6, lr
d537 1
a537 1
        IRQOff  lr, r7                          ; Stop interrupt routine finishing transfer.
@


4.3.2.2
log
@  An intermediate version.
Detail:
  Finally, all IOMD dependencies have been expunged, and the module will
  build again. Any specific support for new features of other DMA controllers
  has yet to be added, though. New exported header added, for use by DMA
  device code.
Admin:
  Untested. However, should theoretically work if someone were to write the
  appropriate routines for the IOMD HAL.

Version 0.15, 4.4.2.2. Tagged as 'DMA-0_15-4_4_2_2'
@
text
@a28 2
 [ :LNOT: HAL

a72 2
 ]

a104 6
;             [ HAL
;                       0-3     post-transfer channel delay
;                       4       disable burst transfers
;                       5       disable DRQ synchronisation to clock
;                       6-31    reserved (set to 0)
;             |
a105 1
;             ]
a110 4
;             [ HAL
;               r6  = peripheral read/receive physical address, or -1 to disallow reads
;               r7  = peripheral write/transmit physical address, or -1 to disallow writes
;             ]
a117 82
      [ HAL
        Entry   "r1-r3,r8-r9"

        Debug   swi,"SWIRegisterChannel",r1

        LDR     r8, LogicalList
        LDR     lr, LogicalChannels
        MOV     lr, lr, LSL #2
10
        SUBS    lr, lr, #4                      ; Work back from end of table.
        PullEnv CC                              ; Not found so return error.
        ADRCC   r0, ErrorBlock_DMA_BadChannel
        DoError CC
        LDR     r9, [r8, lr]
        TEQ     r1, r9
        BNE     %BT10

        ASSERT  LCBSize = 28
        LDR     r8, ChannelBlock
        ADD     r8, r8, lr, LSL #3
        SUB     r8, r8, lr                      ; r8->logical channel block

        LDR     r9, [r8, #lcb_Flags]
        TST     r9, #lcbf_Registered
        PullEnv NE                              ; Return error if already claimed.
        ADRNE   r0, ErrorBlock_DMA_AlreadyClaimed
        DoError NE

        CMP     r2, #4                          ; Validate cycle speed.
        PullEnv CS
        ADRCS   r0, ErrorBlock_DMA_BadCycleSpeed
        DoError CS

        CMP     r2, #32                         ; Validate transfer unit size.
        PullEnv CS
        ADRCS   r0, ErrorBlock_DMA_BadTransferUnit
        DoError CS

        TST     r4, #3                          ; Ensure vector table is word aligned.
        PullEnv NE
        ADRNE   r0, ErrorBlock_DMA_BadAddress
        DoError NE

        ORR     r0, r3, r0, LSL #8              ; Build flags in r0.
        ORR     r0, r0, r2, LSL #5
        ORR     r0, r0, #lcbf_Registered

        ASSERT  lcb_Flags = 0
        ASSERT  lcb_Vector = lcb_Flags + 4
        ASSERT  lcb_R12 = lcb_Vector + 4

        STMIA   r8!, {r0,r4-r5}

        ; r1 still contains logical channel number
        CallHAL DMA_Allocate, lr
        MOVS    r3, r0
        PullEnv EQ                              ; Not found so return error.
        ADREQ   r0, ErrorBlock_DMA_BadChannel
        DoError EQ

        ; Search for the DMA queue for this physical channel (there must be one)
        LDR     r2, DMAQueues
        LDR     r1, PhysicalChannels
80      LDR     r0, [r2, #dmaq_DMADevice]
        TEQ     r0, r3
        SUBNES  r1, r1, #1
        ADDNE   r2, r2, #DMAQSize
        BNE     %BT80

        ASSERT  lcb_Queue = lcb_R12 + 4
        ASSERT  lcb_DMADevice = lcb_Queue + 4
        ASSERT  lcb_PeripheralRead = lcb_DMADevice + 4
        ASSERT  lcb_PeripheralWrite = lcb_PeripheralRead + 4

        STMIA   r8, {r2-r3,r6-r7}

        MOV     r0, lr, LSR #2                  ; Return channel handle in r0.

        Debug   swi," channel handle =",r0

        EXIT
      |
a214 1
      ]
a230 3
      [ HAL
        Entry   "r0-r3,r7,r8"
      |
a231 1
      ]
a234 4
      [ HAL
        LDR     lr, LogicalChannels
        CMP     r0, lr                          ; Ensure handle in range.
      |
a235 1
      ]
a250 5
      [ HAL
        LDR     r1, LogicalList
        LDR     r1, [r1, r0, LSL #2]
        CallHAL DMA_Deallocate
      |
a261 1
      ]
a292 4
      [ HAL
        LDR     lr, LogicalChannels
        CMP     r1, lr                          ; Ensure handle in range.
      |
a293 1
      ]
a359 5
      [ HAL
        STR     r5, [r10, #dmar_TagBits01]
        AND     r0, r5, #3
        ORR     r0, r0, r10
      |
a362 1
      ]
a366 3
      [ HAL
        STR     r9, [r10, #dmar_Queue]
      ]
a367 1
      [ :LNOT: HAL
a368 1
      ]
a401 1
      [ :LNOT: HAL
a402 1
      ]
a445 1
      [ :LNOT: HAL
a446 1
      ]
a505 1
      [ :LNOT: HAL
a506 1
      ]
a538 1
      [ :LNOT: HAL
a542 1
      ]
a557 2

      [ :LNOT: HAL
a561 1
      ]
@


4.3.2.3
log
@  Just enough support for floppy DMA transfer to work on Tungsten.
Detail:
  * Supports DMA controllers with no interrupts (ie those that need a bounce
    buffer).
  * Restructured interface to HAL to separate the concepts of a DMA controller
    device and a DMA channel device.
  * Bugfixes to handling of single-buffered channels.
  * Updated Doc.HAL_DMAAPI.
Admin:
  Tested with Kevin's ADFS.

Version 0.15, 4.4.2.3. Tagged as 'DMA-0_15-4_4_2_3'
@
text
@d134 1
a134 1
        Entry   "r1-r4,r8-r9"
d188 1
a188 1
        MOVS    r4, r0
d194 1
a194 1
        LDR     r3, DMAQueues
d196 2
a197 2
80      LDR     r0, [r3, #dmaq_DMADevice]
        TEQ     r0, r4
d199 1
a199 1
        ADDNE   r3, r3, #DMAQSize
d207 1
a207 1
        STMIA   r8, {r3-r4,r6-r7}
d209 1
a209 20
        MOV     r9, lr
        LDR     r8, [r3, #dmaq_Usage]
        CMP     r8, #0                          ; Is this the first time we've used this physical channel?
        ADD     r8, r8, #1
        LDREQ   lr, [r4, #HALDevice_Device]
        CMPEQ   lr, #-1                         ; Does the device have an interrupt?
        BNE     %FT85                           ; If not, no bounce buffer is needed.

        MOV     r0, #BOUNCEBUFFSIZE
        MOV     r1, #BOUNCEBUFFSIZE
        MOV     r2, #BOUNCEBUFFSIZE
        SWI     XPCI_RAMAlloc                   ; Claim bounce buffer for this physical channel.
        EXIT    VS
        STR     r0, [r3, #dmaq_BounceBuff + ptab_Logical]
        STR     r1, [r3, #dmaq_BounceBuff + ptab_Physical]
; DREG r0, "Bounce buffer logical address = "
; DREG r1, "Bounce buffer physical address = "
85      STR     r8, [r3, #dmaq_Usage]

        MOV     r0, r9, LSR #2                  ; Return channel handle in r0.
a361 12

        LDR     lr, [r8, #lcb_Queue]            ; Free the bounce buffer if necessary.
        LDR     r1, [lr, #dmaq_Usage]
        SUBS    r1, r1, #1
        STR     r1, [lr, #dmaq_Usage]
        BNE     %FT80
        LDR     r0, [lr, #dmaq_BounceBuff + ptab_Logical]
        TEQ     r0, #0
        STRNE   r1, [lr, #dmaq_BounceBuff + ptab_Logical]
        STRNE   r1, [lr, #dmaq_BounceBuff + ptab_Physical]
        SWINE   XPCI_RAMFree
80
a440 12
      [ HAL
        CMP     r4, #BOUNCEBUFFSIZE             ; If longer than bounce buffer length
        ANDLS   r7, r0, #dmarf_Infinite
        CMPLS   r7, #0                          ;   or infinite transfer
        LDRHI   r7, [r8, #lcb_Queue]
        LDRHI   r7, [r7, #dmaq_BounceBuff + ptab_Logical]
        CMPHI   r7, #0                          ;   and we're using a bounce buffer
        PullEnv HI
        ADRHI   r0, ErrorBlock_DMA_TransferTooLong
        DoError HI
      ]

a505 3
      [ HAL
        MakeErrorBlock  DMA_TransferTooLong
      ]
d689 2
a690 3
        CMP     r0, r10
        MOVNE   r0, #0                          ; If not yet started then then just return dmar_Done (which will be 0).
        BLEQ    DMAActiveDone                   ; If transfer is active then get amount of active buffer done.
@


4.3.2.4
log
@  Lots of improvements, working towards support for UDMA etc.
Detail:
  * No longer uses temporay HAL DMA entry points, all hardware access is
    accomplished using device entry points.
  * Supports multiple DMA controllers, including dynamic addition and
    removal of controllers (using OS_Hardware 4 and Service_Hardware).
  * Added *DMAChannels, which enumerates the currently registered DMA
    channels, listed according to physical location.
  * Logical channel blocks are dynamically allocated (as a requirement of
    the above changes) so logical channel handles are now pointers, no
    longer an array index. Just so you know.
  * Removed now-obsolete EnumerateLogical entry from controller device API.
  * Added pointer-to-controller-device item in publically visible part of
    channel device structure.
  * Moved memory-to-memory channel device entries to end of channel device
    structure (I'm considering removing them).
  * Added support for GPA debugging listing (requires BuildSys 3.86).
Admin:
  Tested on Tungsten (ie floppies still work).

Version 0.15, 4.4.2.6. Tagged as 'DMA-0_15-4_4_2_6'
@
text
@d138 10
a147 9
        ; For now assume that we must fault re-registration of the same channel
        ; (this will need to change when we support memory-to-memory DMA).
        ADR     r9, ChannelList - lcb_Next
10      LDR     r8, [r9, #lcb_Next]
        TEQ     r8, #0
        BEQ     %FT15
        LDR     lr, [r8, #lcb_ChannelNo]
        TEQ     lr, r1
        MOVNE   r9, r8
d149 11
a159 18
        PullEnv
        ADR     r0, ErrorBlock_DMA_AlreadyClaimed
        DoError

15      ; We can safely register this channel.
        Push    "r0,r2-r3"
        MOV     r0, #ModHandReason_Claim
        MOV     r3, #LCBSize
        SWI     XOS_Module
        ADDVS   sp, sp, #3*4
        EXIT    VS
        MOV     r0, #0
        ASSERT  lcb_Next = 0
        ASSERT  lcb_ChannelNo = lcb_Next + 4
        STMIA   r2, {r0,r1}
        MOV     lr, r2
        ADD     r8, r2, #lcb_Flags
        Pull    "r0,r2-r3"
d178 1
d180 1
d186 6
a191 11
        MOV     r5, r1                          ; r5 = logical channel number
        LDR     r4, CtrlrList
30      TEQ     r4, #0
        ADREQ   r0, ErrorBlock_DMA_BadChannel   ; Not found so return error.
        BEQ     %FT99
        LDR     r0, [r4, #ctrlr_Device]
        MOV     r1, r5
        CallHAL DMACAllocate, lr
        TEQ     r0, #0
        LDREQ   r4, [r4, #ctrlr_Next]
        BEQ     %BT30                           ; Not supported by this controller so try next one.
d194 3
a196 3
        ADD     r3, r4, #ctrlr_DMAQueues
        LDR     r1, [r4, #ctrlr_PhysicalChannels]
80      LDR     r4, [r3, #dmaq_DMADevice]
d200 1
a200 1
        BNE     %BT80                           ; Terminate loop anyway in case of broken HAL code.
d203 2
a204 1
        ASSERT  lcb_PeripheralRead = lcb_Queue + 4
d207 1
a207 1
        STMIA   r8, {r3,r6-r7}
d209 1
d213 2
a214 2
        LDREQ   r1, [r4, #HALDevice_Device]
        CMPEQ   r1, #-1                         ; Does the device have an interrupt?
a219 1
        Push    "lr"
d221 1
a221 2
        Pull    "lr"
        BVS     %FT90
d224 2
d228 1
a228 5
        ; Link this block on the end of the list, so system channels get found as quickly as possible.
        STR     lr, [r9, #lcb_Next]

        ; Return channel handle in r0.
        MOV     r0, lr
a232 18

90
        Push    "r0"
        MOV     r0, #ModHandReason_Free
        MOV     r2, r8
        SWI     XOS_Module
        Pull    "r0"
        SETV
        EXIT
99
        Push    "r0"
        MOV     r0, #ModHandReason_Free
        MOV     r2, r8
        SWI     XOS_Module
        Pull    "r0"
        PullEnv
        DoError

a233 1

d349 1
a349 1
        Entry   "r0-r3,r7-r9"
d357 2
a358 12
        ADR     r9, ChannelList - lcb_Next
01      LDR     lr, [r9, #lcb_Next]
        TEQ     lr, #0
        TEQNE   lr, r0
        MOVNE   r9, lr
        BNE     %BT01
        TEQ     lr, #0                          ; Was handle in list?
        PullEnv EQ
        ADREQ   r0, ErrorBlock_DMA_BadHandle    ; No, so generate error.
        DoError EQ
        LDR     lr, [lr, #lcb_Next]             ; Delink.
        STR     lr, [r9, #lcb_Next]
d361 1
a364 1
      ]
a366 1
      [ :LNOT: HAL
a371 1
      ]
a373 1
      [ :LNOT: HAL
a374 1
      ]
d378 3
a380 5
        LDR     r9, [r8, #lcb_Queue]
        LDR     r0, [r9, #dmaq_DMADevice]
        LDR     r0, [r0, #HALDevice_DMAController]
        LDR     r1, [r8, #lcb_ChannelNo]
        CallHAL DMACDeallocate
d382 2
a383 1
        LDR     r1, [r9, #dmaq_Usage]           ; Free the bounce buffer if necessary.
d385 1
a385 1
        STR     r1, [r9, #dmaq_Usage]
d387 1
a387 1
        LDR     r0, [r9, #dmaq_BounceBuff + ptab_Logical]
d389 2
a390 2
        STRNE   r1, [r9, #dmaq_BounceBuff + ptab_Logical]
        STRNE   r1, [r9, #dmaq_BounceBuff + ptab_Physical]
a392 1
        CLRV
d438 2
a439 9
        LDR     lr, ChannelList
01      TEQ     lr, #0
        TEQNE   lr, r1
        LDRNE   lr, [lr, #lcb_Next]
        BNE     %BT01
        TEQ     lr, #0                          ; Was handle in list?
        PullEnv EQ
        ADREQ   r0, ErrorBlock_DMA_BadHandle    ; No, so generate error.
        DoError EQ
d442 1
a445 1
      ]
a448 1
      [ :LNOT: HAL
a452 1
      ]
@


4.2
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.14. Tagged as 'DMA-0_14'
@
text
@d188 1
a188 1
        IRQOff  lr
d537 1
a537 1
        IRQOff  r7                              ; Stop interrupt routine finishing transfer.
@


4.1
log
@Initial revision
@
text
@d118 1
a118 1
        ENTRY   "r6-r8"
d231 1
a231 1
        ENTRY   "r1,r7,r8"
d289 1
a289 1
        ENTRY   "r5-r11"
d389 1
a389 1
        ENTRY   "r0,r8-r11"
d437 1
a437 1
        ENTRY   "r0,r8-r11"
d484 1
a484 1
        ENTRY   "r8-r11"
d530 1
a530 1
        ENTRY   "r1,r7-r10"
@


4.1.4.1
log
@DMA changes for Phoebe (mostly remapping of channels).
@
text
@d50 5
a54 12
        DCD     &101    ; On-board Floppy, channel 0
        DCD     &102    ; Parallel, channel 5
        DCD     &103    ; Sound out, channel 8
;        DCD     &104    ; Sound in, not supported
;        DCD     &105    ; Network Card, not supported
        DCD     &106    ; IDE channel A, channel 7
        DCD     &107    ; IDE channel B, channel 6
        DCD     &108    ; Audio codec line 0, channel 1
        DCD     &109    ; Audio codec line 1, channel 4
        DCD     &10a    ; PCI 
        DCD     &10b    ;     channels
; put PCI stuff in here and give it dummy physical channels below 9, 10 etc.
a61 3
        GBLL PhoebeProto
PhoebeProto SETL {FALSE}

a62 1
 [ :LNOT: PhoebeProto
a64 2
 |
        DCB     2
a65 7
 ]     
        DCB     0
        DCB     5
        DCB     8 ; fictional
        DCB     7
        DCB     6
 [ :LNOT: PhoebeProto
d68 1
a68 6
 |
        DCB     3
        DCB     4
 ]     
        DCB     9
        DCB     10
d70 1
d181 2
a182 4


        TEQ     r7, #VIDC_Sound_DMA_In          ; If not registering a sound channel then
;       TEQNE   r7, #5
d197 1
a197 1
        TEQ     r7, #VIDC_Sound_DMA_In
d239 1
a239 1
 
d251 2
a252 2
        TEQ     r0, #VIDC_Sound_DMA_In
;        TEQNE   r0, #5
d255 1
a255 1
        TEQ     r0, #VIDC_Sound_DMA_In          ; Release appropriate sound device vector.
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

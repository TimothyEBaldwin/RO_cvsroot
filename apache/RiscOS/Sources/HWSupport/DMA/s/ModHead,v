head	4.11;
access;
symbols
	DMA-0_23:4.11
	DMA-0_22:4.11
	DMA-0_21:4.11
	DMA-0_20:4.9
	DMA-0_19:4.8
	DMA-0_18:4.8
	RO_5_07:4.7
	DMA-0_17:4.7
	DMA-0_16:4.5
	HAL_merge:4.4.2.4
	DMA-0_15-4_4_2_6:4.4.2.4
	DMA-0_15-4_4_2_5:4.4.2.3
	DMA-0_15-4_4_2_4:4.4.2.3
	DMA-0_15-4_4_2_3:4.4.2.3
	DMA-0_15-4_4_2_2:4.4.2.2
	DMA-0_15-4_4_2_1:4.4.2.1
	HAL_bp:4.4
	HAL:4.4.0.2
	DMA-0_15:4.4
	DMA-0_14:4.3
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	DMA-0_13:4.2
	dcotton_autobuild_BaseSW:4.4
	nturton_DMA-0_12:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	troddis_DMA-0_13:4.1
	nicke_DMA_0_11:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	2015.01.16.00.36.30;	author jlee;	state Exp;
branches;
next	4.10;
commitid	PvGZtgsXnFxkpb6y;

4.10
date	2014.10.18.19.18.07;	author jlee;	state Exp;
branches;
next	4.9;
commitid	ZCUMqbwOugLqvIUx;

4.9
date	2013.01.20.12.18.34;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	THRcEfGlI1hZCWAw;

4.8
date	2009.11.28.22.19.36;	author jlee;	state Exp;
branches;
next	4.7;

4.7
date	2003.02.07.20.09.52;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2003.01.30.16.10.49;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.12.13.18.48.12;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2001.04.11.18.49.22;	author bavison;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	2001.03.16.15.54.35;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.11.12.12.36.56;	author dcotton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.35.44;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	2001.11.27.14.57.57;	author bavison;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2002.10.03.17.35.13;	author bavison;	state Exp;
branches;
next	4.4.2.3;

4.4.2.3
date	2002.10.15.19.15.35;	author bavison;	state Exp;
branches;
next	4.4.2.4;

4.4.2.4
date	2002.12.13.17.25.01;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.35.44;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.22.42;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.50.30;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.45.17;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Escape some dollars
Detail:
  s/ModHead - Escape some dollars contained in strings to avoid warnings from objasm
Admin:
  Resulting binary unchanged


Version 0.21. Retagged as 'DMA-0_21'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.ModHead

        ENTRY

        ASSERT  (.=Module_BaseAddr)

        DCD     0                               ; Start
        DCD     Init           - Module_BaseAddr
        DCD     Die            - Module_BaseAddr
        DCD     Service        - Module_BaseAddr
        DCD     Title          - Module_BaseAddr
        DCD     Helpstr        - Module_BaseAddr
      [ HAL
        DCD     Command        - Module_BaseAddr
      |
        DCD     0                               ; Helptable
      ]
        DCD     Module_SWISystemBase + DMAManagerSWI * Module_SWIChunkSize
        DCD     SWIhandler     - Module_BaseAddr
        DCD     SWInames       - Module_BaseAddr
        DCD     0                               ; SWIdecode
        ASSERT  international
        DCD     message_filename - Module_BaseAddr
        DCD     ModFlags       - Module_BaseAddr

;---------------------------------------------------------------------------
Title   DCB     "DMAManager",0
Helpstr DCB     "DMAManager",9,"$Module_HelpVersion",0
                ALIGN

; GET Hdr:Debug
; InsertDebugRoutines

ModFlags
      [ No32bitCode
        DCD     0
      |
        DCD     ModuleFlag_32bit
      ]

      [ HAL
Command
        Command DMAChannels, 0, 0, International_Help
        &       0

        ASSERT  International_Help<>0

DMAChannels_Help   = "HDMADCH", 0
DMAChannels_Syntax = "SDMADCH", 0

        ALIGN
      ]

;---------------------------------------------------------------------------
;       Module initialisation point.
;
Init
        Entry

        Debug   mod,"Init"

 [ debug
        Debug_Open
 ]

        LDR     r2, [r12]                       ; Have we already got a workspace ?
        TEQ     r2, #0
        BNE     %FT01

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =max_running_work
        SWI     XOS_Module                      ; Claim workspace.
        EXIT    VS

        STR     r2, [r12]                       ; Store workspace pointer.
01
        MOV     r12, r2

      [ HAL
        MOV     r0, #0
        STR     r0, NextLogicalChannel          ; Ensure uninitialised.
      ]
 [ standalone
        ADRL    r0, resourcefsfiles
        SWI     XResourceFS_RegisterFiles
 ]
        BLVC    InitWS
        BLVC    InitHardware

        BLVS    ShutDown
        EXIT

;---------------------------------------------------------------------------
; InitWS
;
;       Out:    r0 corrupted
;
;       Initialise our workspace.
;
InitWS
      [ HAL
        Entry   "r0-r4,r8"
      |
        Entry   "r1,r2"
      ]

        Debug   mod,"InitWS"

        MOV     r0, #0                          ; Initialise workspace.
 [ international
        STR     r0, message_file_open
 ]
        STR     r0, DMABlockHead
        STR     r0, FreeBlock
        STR     r0, TagIndex
        STR     r0, UnsafePageTable
        STR     r0, UnsafePageCount

      [ HAL

        STR     r0, ChannelList                 ; Don't free anything silly in error cases.
        STR     r0, CtrlrList
        STRB    r0, PreReset

        SUB     sp, sp, #4
        ADR     r0, NextLogicalChannelSysVar
        MOV     r1, sp
        MOV     r2, #4
        MOV     r4, #0
        SWI     XOS_ReadVarVal                  ; Try to read last unassigned logical channel
        Pull    "r1"                            ;   from a previous life.
        TEQ     r4, #VarType_Number
        SETV    NE
        MOVVS   r1, #&1000                      ; Default, assume this is the first time.
        STR     r1, NextLogicalChannel
        ADR     r0, NextLogicalChannelSysVar
        MOV     r2, #-1
        MOV     r4, #VarType_Number
        SWI     XOS_SetVarVal                   ; Delete the variable, we no longer need it.

        ADR     r3, CtrlrList - ctrlr_Next
        LDR     r0, =(1:SHL:16) + HALDeviceType_SysPeri + HALDeviceSysPeri_DMAC
        MOV     r1, #0
        MOV     r8, #OSHW_DeviceEnumerate
05      SWI     XOS_Hardware
        ADRVS   r0, ErrorBlock_DMA_BadHard
        PullEnv VS
        DoError VS
        CMP     r1, #-1
        BLNE    AddController
        CMP     r1, #-1
        STRNE   r2, [r3, #ctrlr_Next]           ; Append new controller to end of list
        MOVNE   r3, r2                          ; (maintains order returned by search).
        BNE     %BT05
        ; V will be clear

      |

        ADR     r1, ChannelBlock + lcb_Flags    ; Initialise logical channel table.
        MOV     r2, #NoLogicalChannels
10
        SUBS    r2, r2, #1
        STRCS   r0, [r1], #LCBSize              ; Initialise all lcb_Flags to 0.
        BCS     %BT10

        ADR     r1, DMAQueues                   ; Initialise DMA queues.
        MOV     r2, #NoPhysicalChannels * DMAQSize / 4
20
        SUBS    r2, r2, #1
        STRCS   r0, [r1], #4                    ; Zero all pointers.
        BCS     %BT20

      ]

 [ debugtab
        MOV     r0, #0
        DebugTabInit r0,r1,lr
        Debug   tab,"Debug table at",r1
 ]

        EXIT

 [ HAL
NextLogicalChannelSysVar
        =       "DMAManager$$NextLogicalChannel", 0
        ALIGN
 ]

;---------------------------------------------------------------------------
; InitHardware
;
;       Out:    r0 corrupted
;     [ HAL
;               r1-r6 corrupted
;     ]
;
;       Initialise DMA hardware.
;
InitHardware
      [ HAL
        Entry
        ; Check for bad hardware now done in InitWS
        LDR     r4, CtrlrList
        TEQ     r4, #0
        EXIT    EQ                              ; Don't error here -
                                                ; controller(s) may now be declared later!
01      BL      InitController
        LDR     r4, [r4]
        TEQ     r4, #0
        BNE     %BT01
      |
        Entry   "r1,r2"

        MOV     r0, #2                          ; Read system information.
        SWI     XOS_ReadSysInfo
        EXIT    VS
        AND     r0, r0, #&0000FF00
        TEQ     r0, #&00000100                  ; If no IOMD
        ANDEQS  r2, r2, #&0000FF00              ;   or IOMD variant does not support DMA
        ADRNE   r0, ErrorBlock_DMA_BadHard      ; then return error.
        PullEnv NE
        DoError NE

        IOMDBase r1

        IRQOff  r2, lr
        LDRB    r0, [r1, #IOMD_DMAMSK]          ; Disable all but sound channels.
        BIC     r0, r0, #IOMD_DMA_IO0 :OR: IOMD_DMA_IO1 :OR: IOMD_DMA_IO2 :OR: IOMD_DMA_IO3
        STRB    r0, [r1, #IOMD_DMAMSK]
        SetPSR  lr

        MOV     r0, #&0C                        ; Channels 2 and 3 are external peripherals.
        STRB    r0, [r1, #IOMD_DMAEXT]

        BL      ClaimVectors
      ]

        EXIT

        MakeErrorBlock  DMA_BadHard

 [ HAL
;---------------------------------------------------------------------------
; ServiceDevice
;
;       In:     r0 bits 0-7 = 0 => device added
;                           = 1 => device about to be removed
;               r2 -> device
;       Out:    r1 = 0 and r0 -> error if we object to removal, else all registers preserved
;
ServiceDevice
        TST     r0, #&FF
        BEQ     DeviceAdded
        TST     r0, #&FE
        MOVNE   pc, r14

DeviceRemove
        Push    "r14"
        LDR     r14, [r2, #HALDevice_Version]
        TST     r14, #&FF:SHL:24
        TSTEQ   r14, #&FE:SHL:16
        Pull    "pc", NE        ; We only understand major versions 0 & 1 of any device type
        Push    "r3-r6"
        LDR     r14, [r2, #HALDevice_Type]
        LDR     r4, =(HALDeviceType_SysPeri + HALDeviceSysPeri_DMAC) :SHL: 16
        LDR     r5, =(HALDeviceType_SysPeri + HALDeviceSysPeri_DMAB) :SHL: 16
        LDR     r6, =(HALDeviceType_SysPeri + HALDeviceSysPeri_DMAL) :SHL: 16
        CMP     r4, r14, LSL #16
        CMPNE   r5, r14, LSL #16
        CMPNE   r6, r14, LSL #16
        Pull    "r3-r6,pc", NE
        CMP     r4, r14, LSL #16
        BNE     %FT50

        ; r2 -> DMA controller device being removed - are any of its channels in use?
        ADR     r6, CtrlrList - ctrlr_Next
10      LDR     r4, [r6, #ctrlr_Next]
        LDR     r5, [r4, #ctrlr_Device]
        TEQ     r5, r2
        MOVNE   r6, r4
        BNE     %BT10

        LDR     r5, [r4, #ctrlr_PhysicalChannels]
        ADD     r3, r4, #ctrlr_DMAQueues + dmaq_Usage
20      LDR     r14, [r3], #DMAQSize
        TEQ     r14, #0
        BNE     %FT30
        SUBS    r5, r5, #1
        BNE     %BT20

        ; No channels in use, remove controller
        Push    "r0-r2"
        LDR     r14, [r4, #ctrlr_Next]
        STR     r14, [r6, #ctrlr_Next]
        BL      ForgetController
        MOV     r0, #ModHandReason_Free
        MOV     r2, r4
        SWI     XOS_Module
        Pull    "r0-r6,pc"

30      ; Channel(s) in use
        Pull    "r3-r6,r14"
        ADR     r0, ErrorBlock_DMA_CtrlrInUse
        MOV     r1, #0
        DoError

50      ; r2 -> DMA channel being removed - is it in use?
        LDR     r6, [r2, #HALDevice_DMAController]
        LDR     r4, CtrlrList
60      TEQ     r4, #0
        BEQ     %FT78
        LDR     r5, [r4, #ctrlr_Device]
        TEQ     r5, r6
        LDRNE   r4, [r4, #ctrlr_Next]
        BNE     %BT60

        ADD     r3, r4, #ctrlr_DMAQueues + dmaq_DMADevice
70      LDR     r5, [r3], #DMAQSize
        TEQ     r5, r2
        BNE     %BT70

        LDR     r14, [r3, #-(DMAQSize + dmaq_DMADevice) + dmaq_Usage]
        TEQ     r14, #0
        BNE     %FT80

78      ; Channel not in use
        Pull    "r3-r6,pc"

80      ; Channel in use
        Pull    "r3-r6,r14"
        ADR     r0, ErrorBlock_DMA_ChanInUse
        MOV     r1, #0
        DoError

DeviceAdded
        Push    "r14"
        LDR     r14, [r2, #HALDevice_Version]
        TST     r14, #&FF:SHL:24
        TSTEQ   r14, #&FE:SHL:16
        Pull    "pc", NE        ; We understand major versions 0 & 1
        Push    "r6"
        LDR     r14, [r2, #HALDevice_Type]
        LDR     r6, =(HALDeviceType_SysPeri + HALDeviceSysPeri_DMAC) :SHL: 16
        CMP     r6, r14, LSL #16
        Pull    "r6,pc", NE
        Push    "r0-r5"
        BL      AddController
        BVS     %FT90
        MOV     r4, r2
        BL      InitController
        LDRVC   r0, CtrlrList
        STRVC   r0, [r4, #ctrlr_Next]
        STRVC   r4, CtrlrList   ; Add to start of list (that's where it would be enumerated)
        MOVVS   r0, #ModHandReason_Free
        MOVVS   r2, r4
        SWIVS   XOS_Module
90
        Pull    "r0-r6,pc"

        MakeErrorBlock DMA_CtrlrInUse
        MakeErrorBlock DMA_ChanInUse

;---------------------------------------------------------------------------
; AddController
;
;       In:     r2 -> HAL device for new controller
;       Out:    r2 -> controller block
;               controller not linked into list (we don't whether to add at start or end)
;
AddController
        Entry   "r0-r1,r3-r5"
        MOV     r4, r2
        MOV     r0, r4
        CallHAL DMACEnumerate
        ADD     r5, r0, r1, LSL #2

        ASSERT  DMAQSize=112
        MOV     r0, #ModHandReason_Claim   ; Create and initialise controller block.
        MOV     r3, r1, LSL #7
        SUB     r3, r3, r1, LSL #4
        ADD     r3, r3, #CtrlrSize
        SWI     XOS_Module
        STRVS   r0, [sp]
        EXIT    VS

        MOV     r0, r4
        ASSERT  ctrlr_Device = 4
        ASSERT  ctrlr_PhysicalChannels = 8
        STMIB   r2, {r0,r1}
        MOV     r4, #0
        STR     r4, [r2], #ctrlr_DMAQueues
        SUB     r3, r3, #CtrlrSize

10      SUBS    r3, r3, #4
        STRCS   r4, [r2, r3]
        BCS     %BT10

        ASSERT  DMAQSize=112
        MOV     r3, r1, LSL #7
        SUB     r3, r3, r1, LSL #4
        SUB     r3, r3, #DMAQSize - dmaq_DMADevice
15      LDR     lr, [r5, #-4]! ; Make sure that channel 0 is at the start of the block, for the TestIRQ2-based trampolines to work cleanly 
        STR     lr, [r2, r3]
        SUBS    r3, r3, #DMAQSize
        BPL     %BT15

        SUB     r2, r2, #ctrlr_DMAQueues
        EXIT

;---------------------------------------------------------------------------
; InitController
;
;       In:     r4 -> controller block
;       Out:    r0-r3,r5-r6 corrupted
;
InitController
        Entry   "r4"

01      LDR     r5, [r4, #ctrlr_PhysicalChannels]
        ADD     r6, r4, #ctrlr_DMAQueues

        LDR     r0, [r4, #ctrlr_Device]
        CallHAL Activate                        ; Activate controller.

02      LDR     r0, [r6, #dmaq_DMADevice]
        CallHAL DMAFeatures
        STR     r0, [r6, #dmaq_DeviceFeatures]  ; Cache channel features.
        ADD     r6, r6, #DMAQSize
        SUBS    r5, r5, #1
        BNE     %BT02

        BL      ClaimVectors

        EXIT
 ]

;---------------------------------------------------------------------------
; ClaimVectors
;
;     [ HAL
;       In:     r4 -> controller block
;     ]
;       Out:    r0 corrupted
;     [ HAL
;               r1-r6 corrupted
;     ]
;
;       Claim device vectors for DMA interrupts.
;
ClaimVectors
      [ HAL
        Entry   ; r0-r6 trashable
        ; For controller API version 0.0, only the channels can be used to detect the source of an IRQ.
        ; However for API version 0.1+, a new entry point was added to allow the controller
        ; to detect the IRQ source.
        LDR     r6, [r4, #ctrlr_Device]
        LDR     r1, [r6, #HALDevice_Version]
        CMP     r1, #0
        LDRNE   r1, [r6, #HALDevice_DMACTestIRQ2]
        CMPNE   r1, #0
        BNE     %FT10           ; Controller TestIRQ2 supported
        
        ADD     r1, r4, #ctrlr_DMAQueues + dmaq_Trampoline
        LDR     r4, [r4, #ctrlr_PhysicalChannels]

01      ; For each channel on this controller...
        LDR     r6, [r1, #-dmaq_Trampoline + dmaq_DMADevice]
        LDR     r5, [r6, #HALDevice_Device]
        CMP     r5, #-1         ; no interrupt for this channel?
        BEQ     %FT08

        ; Create trampoline
        TST     r5, #1:SHL:31   ; Shared vector?
        ADREQ   lr, TrampolineTemplate
        ADRNE   lr, TrampolineTemplate_Vectored
        LDRB    r0, [r6, #HALDevice_Type + 0]
        STR     r6, [r1, #12*4] ; Store channel device ptr
        TEQ     r0, #HALDeviceSysPeri_DMAL
        ; Copy 12 words of code for the trampoline
        LDMIA   lr!, {r0,r2,r3,r6}
        STMIA   r1!, {r0,r2,r3,r6}
        LDMIA   lr!, {r0,r2,r3,r6}
        STMIA   r1!, {r0,r2,r3,r6}
        LDMIA   lr!, {r0,r2,r3,r6}
        STMIA   r1!, {r0,r2,r3,r6}
        SUB     r1, r1, #12*4
        ADRNEL  lr, DMAInterruptCommon
        ADREQL  lr, DMAInterruptList
        STR     lr, [r1, #11*4] ; Store handler ptr
        SUB     r6, r1, #dmaq_Trampoline
        STR     r6, [r1, #10*4] ; Store DMA queue ptr
        LDR     r6, [r6, #dmaq_DeviceFeatures]
        LDREQ   r6, [r6, #DMAFeaturesBlock_Flags]

        MOV     r0, #1
        ADD     r2, r1, #12*4-4
        SWI     XOS_SynchroniseCodeAreas

        MOV     r0, r5
        MOV     r2, r12
        SWI     XOS_ClaimDeviceVector
        BVS     %FT09

        TST     r6, #DMAFeaturesFlag_NoInitIRQ
        BEQ     %FT08

        ; There's no initial IRQ pending when Activate is called
        ; so enable the IRQ all the time for this channel
        Push    "r1,r8,r9"
        BIC     r0, r5, #1:SHL:31
        MOV     r8, #OSHW_CallHAL
        MOV     r9, #EntryNo_HAL_IRQEnable
        SWI     XOS_Hardware
        Pull    "r1,r8,r9"
        BVS     %FT09

08      ADD     r1, r1, #DMAQSize
        SUBS    r4, r4, #1
        BNE     %BT01           ; ...next channel
        ; V will be clear
09
        EXIT
                

TrampolineTemplate
        STMDB   sp!, {r12, lr}
        LDR     a1, TChan
        MOV     lr, pc
        LDR     pc, [a1, #HALDevice_TestIRQ]
        LDR     r12, [sp], #4   ; retrieve module wsptr for the likely case that IRQ is genuine
        TEQ     a1, #0
        ADRNE   a1, TArgs       ; no flags if we're ever run in 26-bit mode
        LDMNEIA a1, {a1, pc}    ; interrupt handler now entered with return address on stack
        LDR     pc, [r13], #4   ; else return if bogus IRQ (can't pass on)
        NOP                     ; so next three words are at same position as in vectored case
TArgs   DCD     0               ; needs patching with address of DMA queue
        DCD     0               ; needs patching with DMAInterruptCommon or DMAInterruptList
TChan   DCD     0               ; needs patching with address of DMA channel HAL device

TrampolineTemplate_Vectored
        STMDB   sp!, {r12, lr}
        LDR     a1, TVChan
        MOV     lr, pc
        LDR     pc, [a1, #HALDevice_TestIRQ]
        TEQ     a1, #0
        ADDEQ   sp, sp, #4      ; junk module wsptr and
        LDREQ   pc, [sp], #4    ; pass on if not claimed
        LDR     r12, [sp], #8   ; else retrieve module wsptr and junk pass-on address
        ADR     a1, TVArgs      ; no flags if we're ever run in 26-bit mode
        LDMIA   a1, {a1, pc}    ; interrupt handler now entered with return address on stack
TVArgs  DCD     0               ; needs patching with address of DMA queue
        DCD     0               ; needs patching with DMAInterruptCommon or DMAInterruptList
TVChan  DCD     0               ; needs patching with address of DMA channel HAL device


10
        ; Create one single trampoline to service all the channels for this controller
        ; The trampoline will be stored in the trampoline slot for the first channel
        ; On entry (via ClaimVectors):
        ; r4 = controller block
        ; r6 = controller device
        ; Return address on stack
        ; On exit:
        ; r0-r6 trashed
        ADD     r1, r4, #ctrlr_DMAQueues + dmaq_Trampoline
        LDR     r5, [r6, #HALDevice_Device]
        TST     r5, #1:SHL:31   ; Shared vector?
        ADREQ   lr, TrampolineTemplate_Controller
        ADRNE   lr, TrampolineTemplate_Controller_Vectored
        ; The type of the first channel is the type of all the channels
        LDR     r0, [r1, #-dmaq_Trampoline + dmaq_DMADevice]
        LDRB    r0, [r0, #HALDevice_Type + 0]
        STR     r6, [r1, #12*4] ; Store controller device ptr
        TEQ     r0, #HALDeviceSysPeri_DMAL
        ; Copy 11 words of code for the trampoline
        LDMIA   lr!, {r0,r2,r3,r6}
        STMIA   r1!, {r0,r2,r3,r6}
        LDMIA   lr!, {r0,r2,r3,r6}
        STMIA   r1!, {r0,r2,r3,r6}
        LDMIA   lr!, {r0,r2,r3}
        STMIA   r1!, {r0,r2,r3}
        SUB     r1, r1, #11*4
        ADRNEL  lr, DMAInterruptCommon
        ADREQL  lr, DMAInterruptList
        STR     lr, [r1, #11*4] ; Store handler ptr

        MOV     r0, #1
        ADD     r2, r1, #11*4-4
        SWI     XOS_SynchroniseCodeAreas

        MOV     r0, r5
        MOV     r2, r12
        SWI     XOS_ClaimDeviceVector
        BVS     %FT19

        ; We know TestIRQ2 is supported, so this controller can't have initially
        ; set IRQs otherwise all the channels would interrupt and swamp DMAManager.
        ; So, enable the IRQ that corresponds to this controller.
        Push    "r8,r9"
        BIC     r0, r5, #1:SHL:31
        MOV     r8, #OSHW_CallHAL
        MOV     r9, #EntryNo_HAL_IRQEnable
        SWI     XOS_Hardware
        Pull    "r8,r9"
19
        EXIT

TrampolineTemplate_Controller
        STMDB   sp!, {r12, lr}
        LDR     a1, TCCont
        MOV     lr, pc
        LDR     pc, [a1, #HALDevice_DMACTestIRQ2]
        LDR     r12, [sp], #4   ; retrieve module wsptr for the likely case that IRQ is genuine
        ASSERT  DMAQSize=112
        RSBS    a1, a1, a1, LSL #3 ; a1=a1*7, so still negative if a1=-1
        SUBPL   a2, pc, #8*4+(:INDEX:dmaq_Trampoline) ; Get ptr to DMA queue 0. This relies on the trampolines being stored as part of the queue list!
        ADDPL   a1, a2, a1, LSL #4
        LDRPL   pc, TCHand      ; interrupt handler now entered with return address on stack
        LDR     pc, [r13], #4   ; else return if bogus IRQ (can't pass on)
        NOP                     ; so next two words words are at same position as in vectored case
TCHand  DCD     0               ; needs patching with DMAInterruptCommon or DMAInterruptList
TCCont  DCD     0               ; needs patching with address of DMA controller HAL device

TrampolineTemplate_Controller_Vectored
        STMDB   sp!, {r12, lr}
        LDR     a1, TCVCont
        MOV     lr, pc
        LDR     pc, [a1, #HALDevice_DMACTestIRQ2]
        ASSERT  DMAQSize=112
        RSBS    a1, a1, a1, LSL #3
        ADDMI   sp, sp, #4      ; junk module wsptr and
        LDRMI   pc, [sp], #4    ; pass on if not claimed
        LDR     r12, [sp], #8   ; else retrieve module wsptr and junk pass-on address
        SUB     a2, pc, #10*4+(:INDEX:dmaq_Trampoline) ; Get ptr to DMA queue 0. This relies on the trampolines being stored as part of the queue list!
        ADD     a1, a2, a1, LSL #4
        LDR     pc, TCVHand     ; interrupt handler now entered with return
TCVHand DCD     0               ; needs patching with DMAInterruptCommon or DMAInterruptList
TCVCont DCD     0               ; needs patching with address of DMA controller HAL device
      |
        Entry   "r1,r2"

        MOV     r0, #IOMD_DMAChannel0_DevNo
        ADRL    r1, DMAInterruptChannel0
        MOV     r2, r12
        SWI     XOS_ClaimDeviceVector

        MOVVC   r0, #IOMD_DMAChannel1_DevNo
        ADRVCL  r1, DMAInterruptChannel1
        SWIVC   XOS_ClaimDeviceVector

        MOVVC   r0, #IOMD_DMAChannel2_DevNo
        ADRVCL  r1, DMAInterruptChannel2
        SWIVC   XOS_ClaimDeviceVector

        MOVVC   r0, #IOMD_DMAChannel3_DevNo
        ADRVCL  r1, DMAInterruptChannel3
        SWIVC   XOS_ClaimDeviceVector

        EXIT
      ]

 [ HAL
;---------------------------------------------------------------------------
; ForgetController
;
;       In:     r4 -> controller block
;       Out:    r0-r3,r5-r6 corrupted
;
ForgetController
        Entry

01      LDR     r5, [r4, #ctrlr_PhysicalChannels]
        ADD     r6, r4, #ctrlr_DMAQueues

        LDR     r0, [r4, #ctrlr_Device]
        CallHAL Deactivate                      ; Deactivate controller.

02      LDR     r0, [r6, #dmaq_BounceBuff + ptab_Logical]
        TEQ     r0, #0
        SWINE   PCI_RAMFree
        LDR     r0, [r6, #dmaq_DescBlockLogical]
        TEQ     r0, #0
        SWINE   PCI_RAMFree

        ADD     r6, r6, #DMAQSize
        SUBS    r5, r5, #1
        BNE     %BT02

        BL      ReleaseVectors

        EXIT
 ]

;---------------------------------------------------------------------------
; ReleaseVectors
;
;     [ HAL
;       In:     r4 -> controller block
;     ]
;       Out:    all registers preserved
;     [ HAL
;               r0-r3 corrupted
;     ]
;
;       Release device vectors for DMA interrupts.
;
ReleaseVectors
      [ HAL
        Entry   ; r0-r6 trashable
        ADD     r1, r4, #ctrlr_DMAQueues + dmaq_Trampoline
        LDR     r0, [r4, #ctrlr_Device]
        LDR     r3, [r0, #HALDevice_Version]
        CMP     r3, #0
        LDRNE   r3, [r6, #HALDevice_DMACTestIRQ2]
        CMPNE   r3, #0
        LDREQ   r3, [r4, #ctrlr_PhysicalChannels] ; Controller doesn't support TestIRQ2, so has full compliment of trampolines
        MOVNE   r3, #1 ; Controller does support TestIRQ2, so only has 1 trampoline
        MOV     r2, r12
        BNE     %FT02 ; Skip device lookup, we want to deregister the nonshared controller IRQ, not the shared channel IRQ (which devices retain for backwards compatability)

01      LDR     r0, [r1, #-dmaq_Trampoline + dmaq_DMADevice]
02      LDR     r0, [r0, #HALDevice_Device]
        CMP     r0, #-1         ; no interrupt for this channel?
        SWINE   XOS_ReleaseDeviceVector

        ADD     r1, r1, #DMAQSize
        SUBS    r3, r3, #1
        BNE     %BT01
        EXIT
      |
        Entry   "r0-r2"

        MOV     r0, #IOMD_DMAChannel0_DevNo
        ADRL    r1, DMAInterruptChannel0
        MOV     r2, r12
        SWI     XOS_ReleaseDeviceVector

        MOV     r0, #IOMD_DMAChannel1_DevNo
        ADRL    r1, DMAInterruptChannel1
        SWI     XOS_ReleaseDeviceVector

        MOV     r0, #IOMD_DMAChannel2_DevNo
        ADRL    r1, DMAInterruptChannel2
        SWI     XOS_ReleaseDeviceVector

        MOV     r0, #IOMD_DMAChannel3_DevNo
        ADRL    r1, DMAInterruptChannel3
        SWI     XOS_ReleaseDeviceVector

        EXIT
      ]

;---------------------------------------------------------------------------
;       Service handler.
;
ServiceTable
        DCD     0                          ; flags
        DCD     Service2 - Module_BaseAddr
        DCD     Service_Reset              ; &27
      [ HAL
        DCD     Service_PreReset           ; &45
      [ international
        DCD     Service_MessageFileClosed  ; &5E
      ]
      ]
 [ standalone
        DCD     Service_ResourceFSStarting ; &60
 ]
        DCD     Service_PagesUnsafe        ; &8E
        DCD     Service_PagesSafe          ; &8F
      [ HAL
        DCD     Service_Hardware           ; &D9
      ]
        DCD     0                          ; terminator

        DCD     ServiceTable - Module_BaseAddr
Service
        MOV     r0, r0
        TEQ     r1, #Service_Reset
      [ HAL
        TEQNE   r1, #Service_PreReset
      [ international
        TEQNE   r1, #Service_MessageFileClosed
      ]
      ]
 [ standalone
        TEQNE   r1, #Service_ResourceFSStarting
 ]
        TEQNE   r1, #Service_PagesUnsafe
        TEQNE   r1, #Service_PagesSafe
      [ HAL
        TEQNE   r1, #Service_Hardware
      ]
        MOVNE   pc, lr

Service2
        LDR     r12, [r12]

        TEQ     r1, #Service_PagesUnsafe
        BEQ     DMAPagesUnsafe
        TEQ     r1, #Service_PagesSafe
        BEQ     DMAPagesSafe
      [ HAL
        TEQ     r1, #Service_Hardware
        BEQ     ServiceDevice
      [ international
        TEQ     r1, #Service_MessageFileClosed
        BEQ     ServiceMessageFileClosed
      ]
      ]
 [ standalone
        TEQ     r1, #Service_ResourceFSStarting
        BNE     %FT10
        Entry   "r0-r3"
        ADR     r0, resourcefsfiles
        MOV     lr, pc
        MOV     pc, r2
        EXIT
10
 ]
      [ HAL
        TEQ     r1, #Service_PreReset
        BNE     %FT10
        ASSERT  (Service_PreReset :AND: 255) != 0
        STRB    r1, PreReset

        Entry   "r0-r4"
        LDR     r4, CtrlrList
        TEQ     r4, #0
        EXIT    EQ
01      LDR     r0, [r4, #ctrlr_Device]
        CallHAL Reset
        LDR     r4, [r4, #ctrlr_Next]
        TEQ     r4, #0
        BNE     %BT01
        EXIT
10
      ]

        Debug   mod,"Service_Reset"

        Entry   "r0-r2"
        MOV     r0, #&FD                        ; Read last reset type.
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #0
        EXIT    NE                              ; Do nothing if hard reset.

        Debug   mod," soft"

      [ HAL
        BL      ShutDown
      |
        BL      FreePageTables
        BL      FreeBuffers
      ]
        BL      InitWS
      [ HAL
        BL      InitHardware
      ]
        EXIT

;---------------------------------------------------------------------------
;       Killing the module.
;
Die
        Entry

        Debug   mod,"Die"

        LDR     r12, [r12]
        CMP     r12, #0
        EXIT    EQ

        BL      ShutDown

        CLRV
        EXIT

;---------------------------------------------------------------------------
; ShutDown
;
;       Out:    preserves all registers and flags
;
;       Tidy up before dying.
;
ShutDown
        Entry   "r0"

        Debug   mod,"Shutdown"

        BL      DeregisterChannels
        BL      FreeBuffers

      [ HAL
        LDR     r4, CtrlrList
        TEQ     r4, #0
        BEQ     %FT10
01      BL      ForgetController
        MOV     r0, #ModHandReason_Free
        MOV     r2, r4
        LDR     r4, [r4, #ctrlr_Next]
        SWI     XOS_Module
        TEQ     r4, #0
        BNE     %BT01
10
        LDR     lr, NextLogicalChannel
        Push    "lr"
        ADRL    r0, NextLogicalChannelSysVar
        MOV     r1, sp
        MOV     r2, #4
        MOV     r4, #VarType_Number
        SWI     XOS_SetVarVal                   ; Save the channel number seed for later use.
        ADD     sp, sp, #4
      |
        BL      ReleaseVectors
      ]

 [ international
        LDR     r0, message_file_open           ; Close the message file if it's open.
        TEQ     r0, #0
        ADRNE   r0, message_file_block
        SWINE   XMessageTrans_CloseFile
 ]

 [ standalone
        ADR     r0, resourcefsfiles
        SWI     XResourceFS_DeregisterFiles
 ]

        SETV
        EXIT                                    ; Flags ignored by Die, V must be set for Init

;---------------------------------------------------------------------------
;       Deregister all registered logical DMA channels, purge their queues
;       and free any page tables.
;
DeregisterChannels
        Entry   "r6-r8"

        MOV     r7, #-1                         ; On DMAPurge calls do not start new transfers.
      [ HAL
        LDR     r8, ChannelList
        MOV     lr, #0
        STR     lr, ChannelList                 ; Don't allow any new transfers to be queued.
10      TEQ     r8, #0
        EXIT    EQ

        BL      DMAPurge                        ; Purge the queue of requests for this channel.

        MOV     r0, #ModHandReason_Free
        MOV     r2, r8
        LDR     r8, [r8, #lcb_Next]
        SWI     XOS_Module
        B       %BT10
      |
        MOV     r6, #NoLogicalChannels
        ADR     r8, ChannelBlock-LCBSize
10
        SUBS    r6, r6, #1                      ; If no more channels to do then
        EXIT    CC                              ;   exit.

        ADD     r8, r8, #LCBSize
        LDR     lr, [r8, #lcb_Flags]
        TST     lr, #lcbf_Registered            ; If this channel has not been registered then
        BEQ     %BT10                           ;   try next.
        MOV     lr, #0                          ; Mark channel as no longer registered.
        STR     lr, [r8, #lcb_Flags]
        BL      DMAPurge                        ; Purge the queue of requests for this channel.
        B       %BT10
      ]

;---------------------------------------------------------------------------
;       Free any page tables attached to DMA requests.
;
FreePageTables
      [ HAL
        Entry   "r0-r2,r9-r11"

        LDR     r11, CtrlrList
01
        TEQ     r11, #0
        EXIT    EQ
        LDR     r1, [r11, #ctrlr_PhysicalChannels]
        ADD     r9, r11, #ctrlr_DMAQueues - DMAQSize
10
        SUBS    r1, r1, #1
        LDRCC   r11, [r11, #ctrlr_Next]
        BCC     %BT01
      |
        Entry   "r0-r2,r9,r10"

        MOV     r1, #NoPhysicalChannels
        ADR     r9, DMAQueues-DMAQSize
10
        SUBS    r1, r1, #1
        EXIT    CC
      ]

        ADD     r9, r9, #DMAQSize
        LDR     r10, [r9, #dmaq_Head]
        TEQ     r10, #0
        BEQ     %BT10
20
        LDR     r2, [r10, #dmar_PageTable]
        TEQ     r2, #0
        MOVNE   r0, #ModHandReason_Free
        SWINE   XOS_Module
        LDR     r10, [r10, #dmar_Next]
        TEQ     r10, #0
        BNE     %BT20
        B       %BT10

;---------------------------------------------------------------------------
;       Free DMA request block buffers.
;
FreeBuffers
        Entry   "r0-r2"
        LDR     r2, DMABlockHead                ; Free all DMA request block buffers.
10
        TEQ     r2, #0
        EXIT    EQ
        LDR     r1, [r2, #block_Next]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        MOV     r2, r1
        B       %BT10
        EXIT

        LTORG

        END
@


4.10
log
@Fix sync callbacks for list-type DMA channels. Improve handling of Service_PreReset.
Detail:
  s/DMA - Fixed sync callback logic of list-type channels to match that used by buffer-type channels. Old logic would result in too many sync callbacks being made at the start of a transfer, followed by dmar_Gap becoming negative and (potentially) no sync callbacks being made for the remainder of the transfer.
  s/Front, s/ModHead, s/SWI - Make SWI handler refuse to service any SWI following Service_PreReset. This helps avoid bad things happening should a client try to access DMA channels/transfers after we've reset everything during PreReset (although really it's our own fault for not telling the clients about the controller reset)
  Resources/UK/Messages, s/Errors - Define the error that we return when called following Service_PreReset.
Admin:
  Tested on Raspberry Pi


Version 0.21. Tagged as 'DMA-0_21'
@
text
@d199 1
a199 1
        =       "DMAManager$NextLogicalChannel", 0
@


4.9
log
@API enhancements and fixes
ModHead.s: Allow list type channels to specify NoInitIRQ. Respect the flag when deciding whether or not to unmask the IRQ at the HAL level
DMA.s: Use the cached device flags rather than incurring a function call, refactor the call to DMASetListTransfer to use the CallHAL macro
SWI.s: The transfer unit size check was against the wrong register
hdr/DMADevice: Comment updated to reflect wider flag use

Tested with IOMD HAL, no longer aborts on module init because the channel interrupt fires before any lists have been prepared (it does have an initial IRQ), with various transfer sizes.

Version 0.20. Tagged as 'DMA-0_20'
@
text
@d137 1
d838 2
@


4.8
log
@DMAManager fixes & improvements
Detail:
  DMA.s, in DMAForceActivate: Support for the NoInitIRQ flag for interrupt-driven buffer-type channels (API 1+)
  DMA.s, 'testloop': Fix handling of interrupt-driven buffer-type channels so DMAManager doesn't immediately crash or malfunction
  DMA.s, 'overrun', 'earlyoverrun', 'nooverrun': Fix handling of interrupt-driven buffer-type channels so IRQ state is cleared before the next stage of the transfer is programmed (to avoid missing IRQs)
  DMA.s, 'finished': Fix handling of interrupt-driven buffer-type channels so R8 is loaded with the logical channel block ptr, as expected by subsequent function calls.
  Front.s: Make dmaq_Trampoline larger to allow it to contain the HAL device ptr
  GetAll.s: Add Hdr:HALEntries to GET list, as required by 'ClaimVectors' fix in ModHead.s
  ModHead.s: Update controller handling code to cope with API versions 0.1 (TestIRQ2) & 1 ('Deallocate' passed channel device ptr)
  ModHead.s: Fix 'ClaimVectors' to call HAL_IRQEnable to enable IRQs for the detected channels/controllers.
  ModHead.s: Fix IRQ handler trampolines so that they call HALDevice_TestIRQ on the channel instead of branching to a random address in memory
  SWI.s: Support for controller API 1 (pass channel device ptr to 'Deallocate' in R2)
  hdr/DMADevice: Extra flags & entries for new DMA controller & buffer API versions
Admin:
  Tested on rev C2 beagleboard with the incoming HAL DMA driver. API revisions are documented in more detail on the ROOL wiki.


Version 0.18. Tagged as 'DMA-0_18'
@
text
@d157 1
a157 1
        MOV     r8, #4
d466 3
a468 1
        ; For API version 0.0, only the channels can be used to detect the source of an IRQ. However for API version 0.1+, a new entry point was added to allow the controller to detect the IRQ source.
d474 1
a474 1
        BNE     %FT10 ; Controller TestIRQ2 supported
d479 2
a480 1
01      LDR     r6, [r1, #-dmaq_Trampoline + dmaq_DMADevice]
d486 1
a486 1
        TST     r5, #1:SHL:31
d490 1
a490 1
        STR     r6, [r1, #12*4] ; Note: This is just outside the block we copy below
d492 1
a499 2
        SUB     lr, r1, #dmaq_Trampoline
        STR     lr, [r1, #10*4]
d502 5
a506 1
        STR     lr, [r1, #11*4]
d517 6
a522 2
        ; Enabling the IRQ is generally a good thing!
        Push    "r1-r3,r8,r9"
d524 1
a524 1
        MOV     r8, #0
d527 1
a527 1
        Pull    "r1-r3,r8,r9"
d532 1
a532 1
        BNE     %BT01
d540 1
a540 1
        LDR     a1, [pc, #36]
d545 1
a545 1
        ADDNE   a1, pc, #8      ; no flags if we're ever run in 26-bit mode
d548 2
a549 2
        DCD     0               ; so next three words are at same position as in vectored case
        DCD     0               ; needs patching with address of DMA queue
d551 1
a551 1
        DCD     0               ; needs patching with address of DMA channel HAL device
d555 1
a555 1
        LDR     a1, [pc, #36]
d562 1
a562 1
        ADD     a1, pc, #0      ; no flags if we're ever run in 26-bit mode
d564 1
a564 1
        DCD     0               ; needs patching with address of DMA queue
d566 1
a566 1
        DCD     0               ; needs patching with address of DMA channel HAL device
d580 1
a580 1
        TST     r5, #1:SHL:31
d588 1
a588 1
        ; Copy 11 words of code for vectored case
d598 1
a598 1
        STR     lr, [r1, #11*4]
d601 1
a601 1
        ADD     r2, r1, #12*4-4
d609 3
a611 1
        ; Enabling the IRQ is generally a good thing!
d614 1
a614 1
        MOV     r8, #0
d623 1
a623 1
        LDR     a1, [pc, #36]
d631 1
a631 1
        LDRPL   pc, [pc, #4]    ; interrupt handler now entered with return address on stack
d633 3
a635 3
        DCD     0               ; Empty, so next two words words are at same position as in vectored case
        DCD     0               ; needs patching with DMAInterruptCommon or DMAInterruptList
        DCD     0               ; needs patching with address of DMA controller HAL device
d639 1
a639 1
        LDR     a1, [pc, #36]
d649 3
a651 3
        LDR     pc, [pc, #-4]   ; interrupt handler now entered with return
        DCD     0               ; needs patching with DMAInterruptCommon or DMAInterruptList
        DCD     0               ; needs patching with address of DMA controller HAL device
@


4.7
log
@  Three bugfixes (as it happens, all were introduced with the support for
  multiple DMA controllers).
Detail:
  * Service_PagesSafe handler would abort if the restarting transfer had
    more than one entry in its scatter list
  * Logical channels remained linked into the chain during mass
    deregistration in module finalisation, allowing new transfers to be
    queued
  * Logical channel (RMA) block wasn't freed in DMA_DeregisterChannel
Admin:
  Tested on Tungsten with UDMA ADFS, pscramble and the Task Manager.

Version 0.17. Not tagged
@
text
@d155 1
a155 1
        LDR     r0, =(0:SHL:16) + HALDeviceType_SysPeri + HALDeviceSysPeri_DMAC
d274 2
a275 2
        TSTEQ   r14, #&FF:SHL:16
        Pull    "pc", NE        ; We only understand major version 0 of any device type
d352 2
a353 2
        TSTEQ   r14, #&FF:SHL:16
        Pull    "pc", NE        ; We only understand major version 0
d388 1
a388 1
        MOV     r5, r0
d415 1
a415 1
15      LDR     lr, [r5], #4
d466 8
d487 1
d511 9
d526 1
d530 1
a530 1
        LDR     a1, [pc, #28]
d538 1
a538 1
        DCD     0               ; so next two words are at same position as in vectored case
d541 1
d545 1
a545 1
        LDR     a1, [pc, #28]
d556 84
d712 7
a718 1
        LDR     r3, [r4, #ctrlr_PhysicalChannels]
d720 1
d723 1
a723 1
        LDR     r0, [r0, #HALDevice_Device]
@


4.6
log
@  A few weeks' dedicated work, mainly to support UDMA hard discs.
Detail:
  Features:
  * Supports physical channels using a new type of HAL device (&303) where
    the hardware takes a pointer to a scatter list up front to effect the
    entire transfer, and which may report hardware errors at any time.
    For full details, see Doc.HAL_DMAAPI.
  * Page tables are no longer generated when using a bounce-buffer, since
    they aren't actually any use except in determining if unsafe pages
    intersect with the transfer. Instead, bounce-buffer transfers are halted
    whenever any page becomes unsafe, and no new bounce-buffer transfers can
    be started while any pages are unsafe.
  * For both bounce-buffer and list-type devices, the Activate entry is
    now called after the transfer is programmed (with SetCurrentTransfer
    or SetListTransfer), since this is likely to be more useful for these
    types of devices. Note that for interrupt-driven buffer devices, it
    is still assumed that the default state of the device is to be in an
    underrun interrupt state, so the transfer is not programmed until the
    first time the interrupt routine is entered.
  * Now ensures that scatter list start addresses and lengths are all
    multiples of the transfer unit size (this check is done during page
    table construction, so will be returned via the Completed callback,
    rather than directly from DMA_QueueTransfer like the total length check).
  * When there is no interrupt associated with a physical channel (both for
    buffer- or list-type devices), if the polling of the hardware within SWI
    DMA_ExamineTransfer detects that the transfer has completed, then
    the transfer is shut down in the same was as though an interrupt had
    happened (ie the Completed callback is called without an error).
  * Added SWI DMA_AllocateLogicalChannels to act as a centralised allocator
    for session-unique logical DMA channels. Primarily a service to
    third-party authors of "HAL" devices.
  Bugfixes:
  * Now handles Service_MessageFileClosed to allow safe MessageTrans lookups
    in the background.
  * If a controller device was removed before its constituent channel
    devices, removing the channel device would abort.
  * Interrupt trampoline construction was wrong, the address of the
    interrupt handler code wasn't relocated. Also, non-vectored interrupts
    weren't correctly handled.
  * Transfers suspended by Service_PagesUnsafe weren't blocking the logical
    channel, so you could queue another transfer on the same channel and it
    would start immediately (although transfers already queued before the
    service call wouldn't have been started).
  * Transfers which had completed within Service_PagesUnsafe handler weren't
    being delinked from the queue.
  * Service_PagesSafe wasn't handled properly, meaning that none of the
    transfers that were halted by Service_PagesUnsafe were restarted! This
    was due to the use of routines in common with DMA_SuspendTransfer and
    DMA_ResumeTransfer which started with the first HALised version - these
    suspend a logical channel, unlike the original IOMD code which
    effectively suspends a physical channel. Thus the code to search for
    transfers to restart needs to be quite different, since the physical
    channel may be idle, or occupied with another logical channel, and
    each physical channel may have multiple associated logical channels
    that were on unsafe transfers!
  * When you deregistered a logical channel (including during module death)
    the Completed callback was called for all queued transfers, incorrectly
    including those that had not yet had the matching Start callback called.
  * There was a stack imbalance in the buffer device interrupt handler
    because the retained part of the old code assumed Hdr:Proc stack
    management, which the new code doesn't use (it's entered with the return
    address on the stack).
Admin:
  Tested with UDMA test harnesses on Tungsten (ADFS not yet complete).

Version 0.17. Tagged as 'DMA-0_17'
@
text
@d833 2
a835 1
        STREQ   r8, ChannelList
@


4.5
log
@Folded in HAL branch.

Version 0.16. Tagged as 'DMA-0_16'
@
text
@d55 1
d66 1
d76 4
d93 4
d116 1
a116 1
        Entry   "r0-r3,r8"
d138 16
d196 6
d323 3
a325 1
60      LDR     r5, [r4, #ctrlr_Device]
d339 1
a339 1
        ; Channel not in use
d390 1
a390 1
        ASSERT  DMAQSize=96
d392 2
a393 2
        MOV     r3, r1, LSL #6
        ADD     r3, r3, r1, LSL #5
d411 3
a413 3
        ASSERT  DMAQSize=96
        MOV     r3, r1, LSL #6
        ADD     r3, r3, r1, LSL #5
d469 2
a470 2
01      LDR     r5, [r1, #-dmaq_Trampoline + dmaq_DMADevice]
        LDR     r5, [r5, #HALDevice_Device]
d475 5
a479 1
        ADR     lr, TrampolineTemplate
d489 3
d514 14
d533 1
a533 1
        LDMIA   a1, {a1, pc}    ; DMAInterruptCommon now entered with return address on stack
d535 1
a535 1
        DCD     DMAInterruptCommon
d578 3
d652 3
d672 3
d696 4
d796 8
@


4.4
log
@  Main change is 32-bit compatibility.
Detail:
  Also
  * added Ursula service call table (not even the Phoebe version had one!)
  * fixed a bug: the Service_PagesUnsafe handler was returning with IRQs
    still disabled
Admin:
  Not tested.

Version 0.15. Tagged as 'DMA-0_15'
@
text
@d17 2
d27 3
d31 1
d36 2
a37 1
        DCD     0
d45 3
d55 11
d78 1
a78 1
        MOV     r0, #6
d88 1
a88 1
        ADR     r0, resourcefsfiles
d105 3
d109 1
d123 23
d160 2
d174 3
d181 12
d207 1
a207 1
        IRQOff  lr, r2
a212 5
 [ :LNOT: IOMD
        STRB    r0, [r1, #IOMD_DMASTA]
        STRB    r0, [r1, #IOMD_DMAREQ]
 ]

a215 1
 [ IOMD
d217 1
a217 1
 ]
d223 58
d282 133
a414 1
 [ IOMD
d419 3
d423 3
d430 52
d502 30
d536 3
d540 3
d547 16
d583 1
a583 2

 ]
d592 3
a597 1
 [ MemManager
d600 3
a602 1
 ]
d609 3
a614 1
 [ MemManager
d617 3
a619 1
 ]
d625 8
d643 16
a658 6
 [ MemManager
        TEQ     r1, #Service_PagesUnsafe
        BEQ     DMAPagesUnsafe
        TEQ     r1, #Service_PagesSafe
        BEQ     DMAPagesSafe
 ]
d672 3
d677 1
d679 3
d709 1
a709 1
        Entry   "r0,r2"
a712 1
 [ DeregisterOnFinalise
a713 3
 |
        BL      FreePageTables
 ]
d716 13
a728 1
 [ IOMD
d730 1
a730 1
 ]
a746 2
 [ DeregisterOnFinalise

d754 15
a769 1
        MOV     r7, #-1                         ; On DMAPurge calls do not start new transfers.
d783 1
a783 2

 ]
d789 14
d810 1
d841 2
@


4.4.2.1
log
@  Commit of the HALised DMA Manager code, as it was when the IA division
  was closed.
Detail:
  This didn't get far beyond the design stage, but what there is is best kept
  safe in CVS in case it gets accidentally deleted again...
Admin:
  Don't even think about trying to build this version.

Version 0.15, 4.4.2.1. Tagged as 'DMA-0_15-4_4_2_1'
@
text
@d57 1
a57 1
        MOV     r0, #ModHandReason_Claim
a97 40
      [ HAL

        STR     r0, DMAQueues
        STR     r0, ChannelBlock                ; Don't free anything silly in error cases.
        STR     r0, VectorTramps

        CallHAL DMAEnumeratePhysical
        TEQ     r0, #0
        ADREQ   r0, ErrorBlock_DMA_BadHard
        PullEnv EQ
        DoError EQ                              ; Error if hardware doesn't do DMA.
        STR     r0, DMADevices
        STR     r1, PhysicalChannels
        ASSERT  DMAQSize=16
        MOV     r0, #ModHandReason_Claim        ; Create and initialise DMA queues.
        MOV     r3, r1, LSL #4
        SWI     XOS_Module
        EXIT    VS
        STR     r2, DMAQueues
        MOV     r4, #0
10      SUBS    r3, r3, #4
        STRCS   r4, [r2, r3]
        BCS     %BT10

        CallHAL DMAEnumerateLogical
        STR     r0, LogicalList
        STR     r1, LogicalChannels
        ASSERT  LCBSize=32
        MOV     r0, #ModHandReason_Claim        ; Create and initialise logical channel table.
        MOV     r3, r1, LSL #5
        SWI     XOS_Module
        EXIT    VS
        STR     r2, ChannelBlock
20      SUBS    r1, r1, #1
        STRCS   r4, [r2], #LCBSize
        BCS     %BT20
        ; V will be clear

      |

a111 2
      ]

a123 3
;     [ HAL
;               r1-r6 corrupted
;     ]
a127 10
      [ HAL
        Entry
        ; Check for bad hardware now done in InitWS
        LDR     r4, DMADevices
        LDR     r5, PhysicalChannels
01      LDR     r0, [r4], #4
        CallHAL DMAActivate
        SUBS    r5, r5, #1
        BGT     %BT01
      |
d142 1
a142 1
        IRQOff  r2, lr
d148 5
a154 1
      ]
d156 1
d158 1
d164 3
a170 3
;     [ HAL
;               r1-r6 corrupted
;     ]
a174 43
      [ HAL
        Entry
        ; Create an array of trampolines
        LDR     r4, DMADevices
        LDR     r5, PhysicalChannels
        MOV     r0, #ModHandReason_Claim
        MOV     r3, r5, LSL #3
        ADD     r3, r3, #4                      ; size of block is 2*PhysicalChannels+1 words
        SWI     XOS_Module
        EXIT    VS
        STR     r2, VectorTramps

        ADR     lr, DMAInterruptCommon          ; first word is address of common IRQ handler
        STR     lr, [r2], #4
        MOV     r6, r2                          ; r6 = base address for IRQ handlers
        MOV     r3, r5
        LDR     r0, =&E3A02000                  ; MOV R2, #0
        LDR     r1, =&E51FF010                  ; LDR PC, [PC, #-16]
01      STMIA   r2!, {r0,r1}
        ADD     r0, r0, #1                      ; increment constant to assign to R2
        ADD     r1, r1, #8                      ; PC-relative address is 8 bytes more distant
        SUBS    r3, r3, #1
        BGT     %BT01

        ; Synchronise code areas for trampolines
        MOV     r0, #1
        MOV     r1, r6
        SUB     r2, r2, #4
        SWI     XOS_SynchroniseCodeAreas

        ; Claim device vectors
01      LDR     r0, [r4], #4                    ; r0 -> HAL device
        MOV     r1, #0                          ; r1 = interrupt number (always 0)
        MOV     r2, r6                          ; r2 -> trampoline
        MOV     r3, r12                         ; r3 = module ws ptr
        CallHAL DMAClaim
        ADD     r6, r6, #2*4                    ; point at next trampoline
        SUBS    r5, r5, #1
        BGT     %BT01
        ; V will be clear

        EXIT
      |
a194 1
      ]
d225 2
a233 3
      [ HAL
        DCD     Service_PreReset           ; &45
      ]
d237 1
d240 1
a246 3
      [ HAL
        TEQNE   r1, #Service_PreReset
      ]
d250 1
d253 1
a258 4
        TEQ     r1, #Service_PagesUnsafe
        BEQ     DMAPagesUnsafe
        TEQ     r1, #Service_PagesSafe
        BEQ     DMAPagesSafe
d269 6
a274 14
      [ HAL
        TEQ     r1, #Service_PreReset
        BNE     %FT10

        Entry   "r0-r5"
        LDR     r4, DMADevices
        LDR     r5, PhysicalChannels
01      LDR     r0, [r4], #4
        CallHAL DMAReset
        SUBS    r5, r5, #1
        BGT     %BT01
        EXIT
10
      ]
d322 1
d324 3
d329 1
d331 1
a331 12

      [ HAL
        LDR     r2, ChannelBlock
        TEQ     r2, #0
        MOVNE   r0, #ModHandReason_Free
        SWINE   XOS_Module

        LDR     r2, DMAQueues
        TEQ     r2, #0
        MOVNE   r0, #ModHandReason_Free
        SWINE   XOS_Module
      ]
d348 2
d372 2
@


4.4.2.2
log
@  An intermediate version.
Detail:
  Finally, all IOMD dependencies have been expunged, and the module will
  build again. Any specific support for new features of other DMA controllers
  has yet to be added, though. New exported header added, for use by DMA
  device code.
Admin:
  Untested. However, should theoretically work if someone were to write the
  appropriate routines for the IOMD HAL.

Version 0.15, 4.4.2.2. Tagged as 'DMA-0_15-4_4_2_2'
@
text
@d67 1
a67 1
        ADRL    r0, resourcefsfiles
d102 1
d104 1
a104 1
        CallHAL DMA_EnumeratePhysical
d111 1
a111 1
        ASSERT  DMAQSize=80
d113 1
a113 2
        MOV     r3, r1, LSL #6
        ADD     r3, r3, r1, LSL #4
a120 9
        LDR     r0, DMADevices
        ASSERT  DMAQSize=80
        MOV     r3, r1, LSL #6
        ADD     r3, r3, r1, LSL #4
        SUB     r3, r3, #DMAQSize - dmaq_DMADevice
15      LDR     lr, [r0], #4
        STR     lr, [r2, r3]
        SUBS    r3, r3, #DMAQSize
        BPL     %BT15
d122 1
a122 1
        CallHAL DMA_EnumerateLogical
d125 1
a125 1
        ASSERT  LCBSize=28
a127 1
        SUB     r3, r3, r3, LSL #2
d179 1
a179 1
        CallHAL Activate
d225 22
a246 22
        Entry   "r7" ; r0-r6 trashable
        LDR     r1, DMAQueues
        ADD     r1, r1, #dmaq_Trampoline
        LDR     r3, DMADevices
        LDR     r4, PhysicalChannels

01      LDR     r5, [r3], #4
        LDR     r5, [r5, #HALDevice_Device]
        CMP     r5, #-1         ; no interrupt for this channel?
        BEQ     %FT08

        ; Create trampoline
        ADR     lr, TrampolineTemplate
        LDMIA   lr!, {r0,r2,r6,r7}
        STMIA   r1!, {r0,r2,r6,r7}
        LDMIA   lr!, {r0,r2,r6,r7}
        STMIA   r1!, {r0,r2,r6,r7}
        LDMIA   lr!, {r0,r2,r6,r7}
        STMIA   r1!, {r0,r2,r6,r7}
        SUB     r1, r1, #12*4
        SUB     lr, r1, #dmaq_Trampoline
        STR     lr, [r1, #10*4]
d248 1
d250 2
a251 1
        ADD     r2, r1, #12*4-4
d254 10
a263 4
        ORR     r0, r5, #1:SHL:31
        MOV     r2, r12
        SWI     XOS_ClaimDeviceVector
        BVS     %FT09
a264 5
08      ADD     r1, r1, #DMAQSize
        SUBS    r4, r4, #1
        BNE     %BT01
        ; V will be clear
09
a265 14

TrampolineTemplate
        STMDB   sp!, {r12, lr}
        LDR     a1, [pc, #28]
        MOV     lr, pc
        LDR     pc, [a1, #HALDevice_TestIRQ]
        TEQ     a1, #0
        ADDEQ   sp, sp, #4      ; junk module wsptr and
        LDREQ   pc, [sp], #4    ; pass on if not claimed
        LDR     r12, [sp], #8   ; else retrieve module wsptr and junk pass-on address
        MOV     a1, pc
        LDMIA   a1, {a1, pc}    ; DMAInterruptCommon now entered with return address on stack
        DCD     0               ; needs patching with address of DMA queue
        DCD     DMAInterruptCommon
a292 3
;     [ HAL
;               r0-r6 corrupted
;     ]
a296 20
      [ HAL
        Entry    ; r0-r6 trashable
        LDR      r1, DMAQueues
        ADD      r1, r1, #dmaq_Trampoline
        LDR      r3, DMADevices
        LDR      r4, PhysicalChannels
        MOV      r2, r12

01      LDR      r5, [r3], #4
        LDR      r0, [r5, #HALDevice_Device]
        CMP      r0, #-1        ; no interrupt for this channel?

        ORRNE    r0, r0, #1:SHL:31
        SWINE    XOS_ReleaseDeviceVector

        ADD      r1, r1, #DMAQSize
        SUBS     r4, r4, #1
        BNE      %BT01
        EXIT
      |
a316 1
      ]
d374 1
a374 1
        CallHAL Reset
d423 1
a423 1
        Entry   "r0"
a432 7
        LDR     r4, DMADevices
        LDR     r5, PhysicalChannels
01      LDR     r0, [r4], #4
        CallHAL Deactivate
        SUBS    r5, r5, #1
        BGT     %BT01

d466 1
a467 6
      [ HAL
        LDR     r6, LogicalChannels
        LDR     r8, ChannelBlock
        SUB     r8, r8, #LCBSize
      |
        MOV     r6, #NoLogicalChannels
a468 1
      ]
a487 5
      [ HAL
        LDR     r1, PhysicalChannels
        LDR     r9, DMAQueues
        SUB     r9, r9, #DMAQSize
      |
a489 1
      ]
@


4.4.2.3
log
@  Just enough support for floppy DMA transfer to work on Tungsten.
Detail:
  * Supports DMA controllers with no interrupts (ie those that need a bounce
    buffer).
  * Restructured interface to HAL to separate the concepts of a DMA controller
    device and a DMA channel device.
  * Bugfixes to handling of single-buffered channels.
  * Updated Doc.HAL_DMAAPI.
Admin:
  Tested with Kevin's ADFS.

Version 0.15, 4.4.2.3. Tagged as 'DMA-0_15-4_4_2_3'
@
text
@a37 3
; GET Hdr:Debug
; InsertDebugRoutines

d104 1
a104 2
        MOVVS   r1, #0
        TEQ     r1, #0
d110 1
a110 1
        ASSERT  DMAQSize=96
d113 1
a113 1
        ADD     r3, r3, r1, LSL #5
d122 1
a122 1
        ASSERT  DMAQSize=96
d124 1
a124 1
        ADD     r3, r3, r1, LSL #5
d137 1
a137 1
        SUB     r3, r3, r1, LSL #2
a187 8
        LDR     r6, DMAQueues

        Push    "r12"
        LDR     r0, [r4]
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_Activate]  ; activate controller (bodge)
        Pull    "r12"

d189 1
a189 12
        CallHAL DMA_Features
        STR     r0, [r6, #dmaq_DeviceFeatures]

; SWI XOS_WriteS
; = "Found ", 0
; ALIGN
; LDR r0, [r4, #-4]
; LDR r0, [r0, #HALDevice_Description]
; SWI XOS_Write0
; SWI XOS_NewLine

        ADD     r6, r6, #DMAQSize
a323 2
        TEQ      r1, #0
        EXIT     EQ
d415 7
a421 5
        Entry   "r0-r3"
        LDR     r0, DMADevices
        LDR     r0, [r0]   ; reset controller (bodge)
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_Reset]
d480 2
a481 15
        LDR     r6, DMAQueues
        TEQ     r6, #0
        BEQ     %FT02

        Push    "r12"
        LDR     r0, [r4]
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_Deactivate] ; deactivate controller (bodge)
        Pull    "r12"

01      LDR     r0, [r6, #dmaq_BounceBuff + ptab_Logical]
        TEQ     r0, #0
        SWINE   XPCI_RAMFree

        ADD     r6, r6, #DMAQSize
d484 1
a484 1
02
a521 2
        TEQ     r8, #0
        EXIT    EQ
@


4.4.2.4
log
@  Lots of improvements, working towards support for UDMA etc.
Detail:
  * No longer uses temporay HAL DMA entry points, all hardware access is
    accomplished using device entry points.
  * Supports multiple DMA controllers, including dynamic addition and
    removal of controllers (using OS_Hardware 4 and Service_Hardware).
  * Added *DMAChannels, which enumerates the currently registered DMA
    channels, listed according to physical location.
  * Logical channel blocks are dynamically allocated (as a requirement of
    the above changes) so logical channel handles are now pointers, no
    longer an array index. Just so you know.
  * Removed now-obsolete EnumerateLogical entry from controller device API.
  * Added pointer-to-controller-device item in publically visible part of
    channel device structure.
  * Moved memory-to-memory channel device entries to end of channel device
    structure (I'm considering removing them).
  * Added support for GPA debugging listing (requires BuildSys 3.86).
Admin:
  Tested on Tungsten (ie floppies still work).

Version 0.15, 4.4.2.6. Tagged as 'DMA-0_15-4_4_2_6'
@
text
@a16 2
        ENTRY

a24 3
      [ HAL
        DCD     Command        - Module_BaseAddr
      |
a25 1
      ]
d30 1
a30 2
        ASSERT  international
        DCD     message_filename - Module_BaseAddr
a47 11
Command
        Command DMAChannels, 0, 0, International_Help
        &       0

        ASSERT  International_Help<>0

DMAChannels_Help   = "HDMADCH", 0
DMAChannels_Syntax = "SDMADCH", 0

        ALIGN

a86 3
      [ HAL
        Entry   "r0-r3,r8"
      |
a87 1
      ]
d103 31
a133 2
        STR     r0, ChannelList                 ; Don't free anything silly in error cases.
        STR     r0, CtrlrList
d135 13
a147 14
        ADR     r3, CtrlrList - ctrlr_Next
        LDR     r0, =(0:SHL:16) + HALDeviceType_SysPeri + HALDeviceSysPeri_DMAC
        MOV     r1, #0
        MOV     r8, #4
05      SWI     XOS_Hardware
        ADRVS   r0, ErrorBlock_DMA_BadHard
        PullEnv VS
        DoError VS
        CMP     r1, #-1
        BLNE    AddController
        CMP     r1, #-1
        STRNE   r2, [r3, #ctrlr_Next]           ; Append new controller to end of list
        MOVNE   r3, r2                          ; (maintains order returned by search).
        BNE     %BT05
d190 25
a214 8
        LDR     r4, CtrlrList
        TEQ     r4, #0
        EXIT    EQ                              ; Don't error here -
                                                ; controller(s) may now be declared later!
01      BL      InitController
        LDR     r4, [r4]
        TEQ     r4, #0
        BNE     %BT01
d238 1
a240 1
      ]
a245 193
 [ HAL
;---------------------------------------------------------------------------
; ServiceDevice
;
;       In:     r0 bits 0-7 = 0 => device added
;                           = 1 => device about to be removed
;               r2 -> device
;       Out:    r1 = 0 and r0 -> error if we object to removal, else all registers preserved
;
ServiceDevice
        TST     r0, #&FF
        BEQ     DeviceAdded
        TST     r0, #&FE
        MOVNE   pc, r14

DeviceRemove
        Push    "r14"
        LDR     r14, [r2, #HALDevice_Version]
        TST     r14, #&FF:SHL:24
        TSTEQ   r14, #&FF:SHL:16
        Pull    "pc", NE        ; We only understand major version 0 of any device type
        Push    "r3-r6"
        LDR     r14, [r2, #HALDevice_Type]
        LDR     r4, =(HALDeviceType_SysPeri + HALDeviceSysPeri_DMAC) :SHL: 16
        LDR     r5, =(HALDeviceType_SysPeri + HALDeviceSysPeri_DMAB) :SHL: 16
        LDR     r6, =(HALDeviceType_SysPeri + HALDeviceSysPeri_DMAL) :SHL: 16
        CMP     r4, r14, LSL #16
        CMPNE   r5, r14, LSL #16
        CMPNE   r6, r14, LSL #16
        Pull    "r3-r6,pc", NE
        CMP     r4, r14, LSL #16
        BNE     %FT50

        ; r2 -> DMA controller device being removed - are any of its channels in use?
        ADR     r6, CtrlrList - ctrlr_Next
10      LDR     r4, [r6, #ctrlr_Next]
        LDR     r5, [r4, #ctrlr_Device]
        TEQ     r5, r2
        MOVNE   r6, r4
        BNE     %BT10

        LDR     r5, [r4, #ctrlr_PhysicalChannels]
        ADD     r3, r4, #ctrlr_DMAQueues + dmaq_Usage
20      LDR     r14, [r3], #DMAQSize
        TEQ     r14, #0
        BNE     %FT30
        SUBS    r5, r5, #1
        BNE     %BT20

        ; No channels in use, remove controller
        Push    "r0-r2"
        LDR     r14, [r4, #ctrlr_Next]
        STR     r14, [r6, #ctrlr_Next]
        BL      ForgetController
        MOV     r0, #ModHandReason_Free
        MOV     r2, r4
        SWI     XOS_Module
        Pull    "r0-r6,pc"

30      ; Channel(s) in use
        Pull    "r3-r6,r14"
        ADR     r0, ErrorBlock_DMA_CtrlrInUse
        MOV     r1, #0
        DoError

50      ; r2 -> DMA channel being removed - is it in use?
        LDR     r6, [r2, #HALDevice_DMAController]
        LDR     r4, CtrlrList
60      LDR     r5, [r4, #ctrlr_Device]
        TEQ     r5, r6
        LDRNE   r4, [r4, #ctrlr_Next]
        BNE     %BT60

        ADD     r3, r4, #ctrlr_DMAQueues + dmaq_DMADevice
70      LDR     r5, [r3], #DMAQSize
        TEQ     r5, r2
        BNE     %BT70

        LDR     r14, [r3, #-(DMAQSize + dmaq_DMADevice) + dmaq_Usage]
        TEQ     r14, #0
        BNE     %FT80

        ; Channel not in use
        Pull    "r3-r6,pc"

80      ; Channel in use
        Pull    "r3-r6,r14"
        ADR     r0, ErrorBlock_DMA_ChanInUse
        MOV     r1, #0
        DoError

DeviceAdded
        Push    "r14"
        LDR     r14, [r2, #HALDevice_Version]
        TST     r14, #&FF:SHL:24
        TSTEQ   r14, #&FF:SHL:16
        Pull    "pc", NE        ; We only understand major version 0
        Push    "r6"
        LDR     r14, [r2, #HALDevice_Type]
        LDR     r6, =(HALDeviceType_SysPeri + HALDeviceSysPeri_DMAC) :SHL: 16
        CMP     r6, r14, LSL #16
        Pull    "r6,pc", NE
        Push    "r0-r5"
        BL      AddController
        BVS     %FT90
        MOV     r4, r2
        BL      InitController
        LDRVC   r0, CtrlrList
        STRVC   r0, [r4, #ctrlr_Next]
        STRVC   r4, CtrlrList   ; Add to start of list (that's where it would be enumerated)
        MOVVS   r0, #ModHandReason_Free
        MOVVS   r2, r4
        SWIVS   XOS_Module
90
        Pull    "r0-r6,pc"

        MakeErrorBlock DMA_CtrlrInUse
        MakeErrorBlock DMA_ChanInUse

;---------------------------------------------------------------------------
; AddController
;
;       In:     r2 -> HAL device for new controller
;       Out:    r2 -> controller block
;               controller not linked into list (we don't whether to add at start or end)
;
AddController
        Entry   "r0-r1,r3-r5"
        MOV     r4, r2
        MOV     r0, r4
        CallHAL DMACEnumerate
        MOV     r5, r0

        ASSERT  DMAQSize=96
        MOV     r0, #ModHandReason_Claim   ; Create and initialise controller block.
        MOV     r3, r1, LSL #6
        ADD     r3, r3, r1, LSL #5
        ADD     r3, r3, #CtrlrSize
        SWI     XOS_Module
        STRVS   r0, [sp]
        EXIT    VS

        MOV     r0, r4
        ASSERT  ctrlr_Device = 4
        ASSERT  ctrlr_PhysicalChannels = 8
        STMIB   r2, {r0,r1}
        MOV     r4, #0
        STR     r4, [r2], #ctrlr_DMAQueues
        SUB     r3, r3, #CtrlrSize

10      SUBS    r3, r3, #4
        STRCS   r4, [r2, r3]
        BCS     %BT10

        ASSERT  DMAQSize=96
        MOV     r3, r1, LSL #6
        ADD     r3, r3, r1, LSL #5
        SUB     r3, r3, #DMAQSize - dmaq_DMADevice
15      LDR     lr, [r5], #4
        STR     lr, [r2, r3]
        SUBS    r3, r3, #DMAQSize
        BPL     %BT15

        SUB     r2, r2, #ctrlr_DMAQueues
        EXIT

;---------------------------------------------------------------------------
; InitController
;
;       In:     r4 -> controller block
;       Out:    r0-r3,r5-r6 corrupted
;
InitController
        Entry   "r4"

01      LDR     r5, [r4, #ctrlr_PhysicalChannels]
        ADD     r6, r4, #ctrlr_DMAQueues

        LDR     r0, [r4, #ctrlr_Device]
        CallHAL Activate                        ; Activate controller.

02      LDR     r0, [r6, #dmaq_DMADevice]
        CallHAL DMAFeatures
        STR     r0, [r6, #dmaq_DeviceFeatures]  ; Cache channel features.
        ADD     r6, r6, #DMAQSize
        SUBS    r5, r5, #1
        BNE     %BT02

        BL      ClaimVectors

        EXIT
 ]

a248 3
;     [ HAL
;       In:     r4 -> controller block
;     ]
d258 5
a262 3
        Entry   ; r0-r6 trashable
        ADD     r1, r4, #ctrlr_DMAQueues + dmaq_Trampoline
        LDR     r4, [r4, #ctrlr_PhysicalChannels]
d264 1
a264 1
01      LDR     r5, [r1, #-dmaq_Trampoline + dmaq_DMADevice]
d271 6
a276 6
        LDMIA   lr!, {r0,r2,r3,r6}
        STMIA   r1!, {r0,r2,r3,r6}
        LDMIA   lr!, {r0,r2,r3,r6}
        STMIA   r1!, {r0,r2,r3,r6}
        LDMIA   lr!, {r0,r2,r3,r6}
        STMIA   r1!, {r0,r2,r3,r6}
d285 1
a285 1
        MOV     r0, r5
d306 1
a306 1
        ADD     a1, pc, #0      ; no flags if we're ever run in 26-bit mode
a332 29
 [ HAL
;---------------------------------------------------------------------------
; ForgetController
;
;       In:     r4 -> controller block
;       Out:    r0-r3,r5-r6 corrupted
;
ForgetController
        Entry

01      LDR     r5, [r4, #ctrlr_PhysicalChannels]
        ADD     r6, r4, #ctrlr_DMAQueues

        LDR     r0, [r4, #ctrlr_Device]
        CallHAL Deactivate                      ; Deactivate controller.

02      LDR     r0, [r6, #dmaq_BounceBuff + ptab_Logical]
        TEQ     r0, #0
        SWINE   PCI_RAMFree

        ADD     r6, r6, #DMAQSize
        SUBS    r5, r5, #1
        BNE     %BT02

        BL      ReleaseVectors

        EXIT
 ]

a335 3
;     [ HAL
;       In:     r4 -> controller block
;     ]
d338 1
a338 1
;               r0-r3 corrupted
d345 19
a363 13
        Entry   ; r0-r6 trashable
        ADD     r1, r4, #ctrlr_DMAQueues + dmaq_Trampoline
        LDR     r3, [r4, #ctrlr_PhysicalChannels]
        MOV     r2, r12

01      LDR     r0, [r1, #-dmaq_Trampoline + dmaq_DMADevice]
        LDR     r0, [r0, #HALDevice_Device]
        CMP     r0, #-1         ; no interrupt for this channel?
        SWINE   XOS_ReleaseDeviceVector

        ADD     r1, r1, #DMAQSize
        SUBS    r3, r3, #1
        BNE     %BT01
a402 3
      [ HAL
        DCD     Service_Hardware           ; &D9
      ]
a416 3
      [ HAL
        TEQNE   r1, #Service_Hardware
      ]
a425 4
      [ HAL
        TEQ     r1, #Service_Hardware
        BEQ     ServiceDevice
      ]
d440 5
a444 9
        Entry   "r0-r4"
        LDR     r4, CtrlrList
        TEQ     r4, #0
        EXIT    EQ
01      LDR     r0, [r4, #ctrlr_Device]
        CallHAL Reset
        LDR     r4, [r4, #ctrlr_Next]
        TEQ     r4, #0
        BNE     %BT01
a460 3
      [ HAL
        BL      ShutDown
      |
a462 1
      ]
a463 3
      [ HAL
        BL      InitHardware
      ]
d498 2
d501 29
a529 13
        LDR     r4, CtrlrList
        TEQ     r4, #0
        BEQ     %FT10
01      BL      ForgetController
        MOV     r0, #ModHandReason_Free
        MOV     r2, r4
        LDR     r4, [r4, #ctrlr_Next]
        SWI     XOS_Module
        TEQ     r4, #0
        BNE     %BT01
10
      |
        BL      ReleaseVectors
d556 3
a558 3
        LDR     r8, ChannelList
10      TEQ     r8, #0
        STREQ   r8, ChannelList
d560 1
a560 8

        BL      DMAPurge                        ; Purge the queue of requests for this channel.

        MOV     r0, #ModHandReason_Free
        MOV     r2, r8
        LDR     r8, [r8, #lcb_Next]
        SWI     XOS_Module
        B       %BT10
d564 1
a576 1
      ]
d582 2
d585 3
a587 12
        Entry   "r0-r2,r9-r11"

        LDR     r11, CtrlrList
01
        TEQ     r11, #0
        EXIT    EQ
        LDR     r1, [r11, #ctrlr_PhysicalChannels]
        ADD     r9, r11, #ctrlr_DMAQueues - DMAQSize
10
        SUBS    r1, r1, #1
        LDRCC   r11, [r11, #ctrlr_Next]
        BCC     %BT01
a588 2
        Entry   "r0-r2,r9,r10"

d591 1
a594 1
      ]
a624 2

        LTORG
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.14. Tagged as 'DMA-0_14'
@
text
@d31 1
a31 1
        DCD     0
d38 7
d142 1
a142 1
        IRQOff  lr
d199 1
a199 1
;       Out:    all registers and flags preserved
d223 1
a223 1
        EXITS
d230 14
d245 1
d254 1
a254 1
        MOVNES  pc, lr
d256 1
d266 1
a266 1
        EXITS
d284 1
a284 1
        EXITS   NE                              ; Do nothing if hard reset.
d291 1
a291 1
        EXITS
d302 2
a303 2
        TEQ     r12, #0
        EXITS   EQ
d307 2
a308 1
        EXITS
d345 2
a346 1
        EXITS                                   ; Ignore errors, preserve flags.
d362 1
a362 1
        EXITS   CC                              ;   exit.
d385 1
a385 1
        EXITS   CC
d409 1
a409 1
        EXITS   EQ
d415 1
a415 1
        EXITS
@


4.2
log
@	Now builds with HdrSrc-0_52 or later, and placed under srccommit
control.

Detail:
	A change in Version 0.52 of HdrSrc meant that this component would
not build. This has now been fixed.
	Makefile now uses strdepend in the clean phase to remove all the
dynamic dependencies.
	Placed under srccommit control.

Admin:
	Built.

Version 0.13. Tagged as 'DMA-0_13'
@
text
@a15 1
        LEADR   Module_LoadAddr
d35 1
a35 1
Helpstr DCB     "DMAManager",9,"$Module_FullVersion ($Module_Date)",0
d42 1
a42 1
        ENTRY
d77 1
a77 1
        ENTRY   "r1,r2"
d121 1
a121 1
        ENTRY   "r1,r2"
d168 1
a168 1
        ENTRY   "r1,r2"
d197 1
a197 1
        ENTRY   "r0-r2"
d239 1
a239 1
        ENTRY   "r0-r3"
d255 1
a255 1
        ENTRY   "r0-r2"
d274 1
a274 1
        ENTRY
d294 1
a294 1
        ENTRY   "r0,r2"
d330 1
a330 1
        ENTRY   "r6-r8"
d354 1
a354 1
        ENTRY   "r0-r2,r9,r10"
d380 1
a380 1
        ENTRY   "r0-r2"
@


4.1
log
@Initial revision
@
text
@d36 1
a36 1
Helpstr DCB     "DMAManager",9,"$VString ($Date)",0
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

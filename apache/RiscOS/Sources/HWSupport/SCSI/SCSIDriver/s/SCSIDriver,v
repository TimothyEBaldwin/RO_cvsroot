head	4.9;
access;
symbols
	SCSIDriver-1_19:4.9
	SCSIDriver-1_18:4.8
	SCSIDriver-1_17:4.7
	SCSIDriver-1_16:4.7
	SCSIDriver-1_15:4.6
	RO_5_07:4.5
	SCSIDriver-1_14:4.5
	SCSIDriver-1_13:4.4
	SCSIDriver-1_12:4.3
	SCSIDriver-1_11:4.2
	dellis_autobuild_BaseSW:4.1
	SCSIDriver-1_10:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	nturton_SCSIDriver-1_10:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SCSIDriver_1_10:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA:4.1.0.2
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2018.01.11.20.55.05;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	J4IY4It17pv45vmA;

4.8
date	2013.08.24.20.24.32;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	TKmQHiMVsx7enK2x;

4.7
date	2013.01.13.10.10.12;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	RqDXIERutm0V82Aw;

4.6
date	2011.08.04.21.46.31;	author jlee;	state Exp;
branches;
next	4.5;
commitid	9P9MKCyfkyo1Yeuv;

4.5
date	2003.06.16.17.00.16;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2003.06.12.17.42.52;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2003.06.12.14.41.11;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2003.05.23.13.23.17;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.37.22;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.37.22;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.40.27;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.01.35;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.53.49;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Free up some command namespace
Change command to *ScsiDevices to match the other similar ones (IIC, SDIO, GPIO, SPI, SATA etc) with the intention that *Devices can in future be repurposed to list all subsets.
For now, alias one to the other during the transition.

Version 1.19. Tagged as 'SCSIDriver-1_19'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;------------------------------------------------------------------------------
;
; RISC OS SCSI device driver for Acorn SCSI podule P/N 0173,010
;
;------------------------------------------------------------------------------


;************************************************
;       Switches governing assembly
;************************************************

        GBLS    DString
        GBLL    debug
        GBLL    trace
        GBLL    counts

debug           SETL {FALSE}

      [ debug
DString         SETS " - Debugging version"
counts          SETL {FALSE}
trace           SETL {TRUE}
      |
DString         SETS ""
counts          SETL {FALSE}
trace           SETL {FALSE}            ; Must be false for release
      ]

                GBLL disconnect         ; When true, driver defaults to allowing
disconnect      SETL {FALSE}            ; disconnection/reselection

                GBLL SQ555kludge
SQ555kludge     SETL {FALSE}
    [ SQ555kludge
disconnect      SETL {FALSE}
      [ debug
DString         SETS " - SQ555 debugging version"
      |
DString         SETS " - SQ555 version"
      ]
    ]

                GBLL HAL                ; When true, try OS_Hardware instead of poking IOC
HAL             SETL {TRUE}

      [ :LNOT::DEF:soft
                GBLL soft               ; When true, be a driver module for SCSISwitch
soft            SETL {FALSE}
      ]
                GBLL testMEMC           ; When true, test for MEMC1a
testMEMC        SETL :LNOT:HAL

                GBLL doAssertATN
doAssertATN     SETL {TRUE}

                GBLL useTickerV
                GBLL doEscapeCheck
      [ doAssertATN:LAND::LNOT:soft
useTickerV      SETL {TRUE}             ;true or false
doEscapeCheck   SETL {FALSE}
      |
useTickerV      SETL {FALSE}            ;MUST be false
doEscapeCheck   SETL {FALSE}            ;MUST be false
      ]

                GBLL IRQswhenreading
                GBLL IRQswhenwriting
                GBLL rejectnaffmessages
IRQswhenreading SETL {TRUE}
IRQswhenwriting SETL {TRUE}
rejectnaffmessages  SETL {TRUE}

                GBLL BigCapacity        ; Assume capacities > 4G are possible
BigCapacity     SETL {TRUE}

                GBLL readback           ; Read back from podule to flush writes
readback        SETL {TRUE}

                GBLL bugfix1            ; Escape whilst reading
bugfix1         SETL {TRUE}

                GBLL bugfix2            ; Suppress escape & timeout if command
bugfix2         SETL {TRUE}             ; completes before noticing ATN is hi.

                GBLL bugfix3            ; Small xfers after a re-select failing
bugfix3         SETL {TRUE}             ; to copy SRAM data to main ram

                GBLL bugfix4            ; Restore DPD bit in SR_DestID when
bugfix4         SETL {TRUE}             ; reselected by a target

                GBLL bugfix5            ; Set ER bit in SR_SourceID when a
bugfix5         SETL {TRUE}             ; disconnection occurs

                GBLL bugfix6            ; LCI bit doesn't always work when
bugfix6         SETL {TRUE}             ; another target reselects SBIC

                GBLL bugfix7a           ; Indicate NO data transfered, if any
bugfix7a        SETL {FALSE}            ; error occurs

                GBLL bugfix7b           ; Indicate NO data transfered, if an
bugfix7b        SETL {TRUE}             ; unexpected disconnection occurs

                GBLL bugfix8            ; Determine device gives -1,-1 for block
bugfix8         SETL {TRUE}             ;  count/size if readcapacity fails

                GBLL bugfix9            ; Target disconnects during last
bugfix9         SETL {TRUE}             ; 12 bytes of data out phase

                GBLL bugfix10           ; Tell SBIC the CDB size incase its
bugfix10        SETL {TRUE}             ; not a group 0,1 or 5 command.

                GBLL efficient
efficient       SETL {TRUE}

                GBLL bugfix11           ; Check CDB size
bugfix11        SETL {TRUE}

                GBLL bugfix12           ; Get LUN's to work
bugfix12        SETL {TRUE}

                GBLL bugfix13           ; Prevent call of UnQueueSlot from
bugfix13        SETL {TRUE}             ; Restart_DMAC_Writing when queue
                                        ; is empty.

;************************************************
;       Header files required
;************************************************

        AREA    |!!!Module|,CODE,READONLY

Module_BaseAddr

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:FSNumbers
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:Proc
        GET     Hdr:DevNos
        GET     Hdr:Podule
        GET     Hdr:NewErrors
        GET     Hdr:HALEntries
        GET     Hdr:SCSI
        GET     Hdr:SCSIErr
        GET     Hdr:Variables
        GET     hdr.SCSIMacros
        GET     VersionASM
        GET     hdr.SCSIEquates
        
;************************************************
;       Module start
;************************************************

        ASSERT  (.=Module_BaseAddr)     ; Winge if we've generated code

SCSI_SWIbase * Module_SWISystemBase + (SCSIDriverSWI * Module_SWIChunkSize)

        DCD     0                               ; 0  Start - Not an application
        DCD     ModInit-Module_BaseAddr         ; 4  Initialisation
        DCD     ModDie-Module_BaseAddr          ; 8  Die (aka Finalisation)
        DCD     ModService-Module_BaseAddr      ; C  Service
        DCD     ModTitleStr-Module_BaseAddr     ; 10 Title
        DCD     ModHelpStr-Module_BaseAddr      ; 14 Help string
      [ soft
        DCD     0                               ; 18 Combined Help/* command table
        DCD     0                               ; 1C Chunk number of SWIs intercepted
        DCD     0                               ; 20 Offset of code to handle SWIs
        DCD     0                               ; 24 SWI Decoding table
      |
        DCD     HC_Table-Module_BaseAddr        ; 18 Combined Help/* command table
        DCD     SCSI_SWIbase                    ; 1C Chunk number of SWIs intercepted (MySWIBase)
        DCD     SCSI_SWIdecode-Module_BaseAddr  ; 20 Offset of code to handle SWIs (MySWIDecode)
        DCD     SCSI_SWInames-Module_BaseAddr   ; 24 SWI Decoding table (MySWINames)
      ]
        DCD     0                               ; 28 SWI Decoding code
        DCD     0                               ; 32 Messages filename
        DCD     ModFlags-Module_BaseAddr        ; 36 Flags

      [ soft
ModTitleStr
        DCB     "SCSISoftWD33C93",0
        ALIGN

ModHelpStr
        DCB     "SCSISoftWD33C93",&09,"$Module_MajorVersion ($Module_Date)$DString",0
        ALIGN
      |
ModTitleStr
        DCB     "SCSIDriver",0
        ALIGN

ModHelpStr
        DCB     "SCSIDriver",&09,"$Module_MajorVersion ($Module_Date)$DString",0
        ALIGN
      ]

ModFlags
      [ No32bitCode
        DCD     0
      |
        DCD     ModuleFlag_32bit
      ]

    [ :LNOT:soft
HC_Table
        Command SCSIDevices, 0,0
        DCD     0


; ------------------------------------------------------------
; GET TokHelpSrc. For now, have inline non tokenised help text

SCSIDevices_Help
        DCB     "*SCSIDevices lists type, capacity and vendor details of "
        DCB     "attached SCSI devices"
        DCB     13
SCSIDevices_Syntax
        DCB     "Syntax: *SCSIDevices"
        DCB     0
        ALIGN

SCSIDevices_Code
        Entry

        LDR     WsPtr,[R12]
        CMP     WsPtr,#0
        BEQ     Devices_Co_40           ; Wot! no workspace

        SUB     StkPtr,StkPtr,#256

        MOV     R1,StkPtr
        MOV     R2,#255

        ADR     R3,HeadingDevice
        MOV     R4,#255

        MOV     R5,#HeadingDevLen
        ADD     R6,R1,#FormDeviceDst
        BL      CopyField
        BL      PadField

        MOV     R5,#HeadingTypLen
        ADD     R6,R6,#FormTypeDst
        BL      CopyField
        BL      PadField

        MOV     R5,#HeadingCapLen
        ADD     R6,R6,#FormCapacityDst
        BL      CopyField
        BL      PadField

        MOV     R5,#HeadingVenLen
        ADD     R6,R6,#FormVendorDst
        BL      CopyField
        BL      PadField

        MOV     R5,#HeadingProLen
        ADD     R6,R6,#FormProductDst
        BL      CopyField
        BL      PadField

        MOV     R5,#HeadingRevLen
        BL      CopyField

        MOV     R0,StkPtr
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        BVS     Devices_Co_30
      [ {FALSE}
        SWI     XOS_WriteS
        DCB     "ddd    ttttttttttttttttt cccc Mbytes vvvvvvvv pppppppppppppppp rrrr"
        DCB     0
        ALIGN
        SWI     XOS_NewLine
      ]
        MOV     R1,#0
        LDR     R4,maxCardID            ; 0/1/2/3 for 1/2/3/4 cards
Devices_Co_10
        MOV     R0,#3                   ; Enumerate
        MOV     R2,StkPtr
        MOV     R3,#255
        SWI     XSCSI_Initialise

        MOV     R0,StkPtr
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        BVS     Devices_Co_30

        ADD     R1,R1,#1                ; 
        TST     R1,#maxDeviceID         ; Loop until last device on this card
        BNE     Devices_Co_10           ;  has been accessed

        SUBS    R4,R4,#1                ; Quit if no more cards
        BLT     Devices_Co_30
        SWI     XOS_NewLine             ; 
        BVC     Devices_Co_10           ; Else print blank line and loop for next card

Devices_Co_30
        ADD     StkPtr,StkPtr,#256
Devices_Co_40

        EXIT

;
; Format of display by *SCSIDevices
;           1         2         3         4         5         6         7
; 01234567890123456789012345678901234567890123456789012345678901234567890
;
;                                        1      1   2         3  3
;                                      89012345 6789012345678901 2345
; Device Type              Capacity    Vendor   Product          Revision
; ddd    ttttttttttttttttt cccc Mbytes vvvvvvvv pppppppppppppppp rrrr
;
;


;
; Field headings - used by *devices
;

HeadingDevice   DCB "Device"
HeadingDevLen   EQU (.-HeadingDevice)
HeadingType     DCB "Type"
HeadingTypLen   EQU (.-HeadingType)
HeadingCapacity DCB "Capacity"
HeadingCapLen   EQU (.-HeadingCapacity)
HeadingVendor   DCB "Vendor"
HeadingVenLen   EQU (.-HeadingVendor)
HeadingProduct  DCB "Product"
HeadingProLen   EQU (.-HeadingProduct)
HeadingRevision DCB "Revision"
HeadingRevLen   EQU (.-HeadingRevision)

    ] ; :LNOT:soft

HostVendor      DCB "ACORN   "
FormVendorSrc   EQU (.-HostVendor)
HostProduct     DCB "SCSI expansion  "
FormProductSrc  EQU (.-HostProduct)
HostRevision    DCB Module_MajorVersion
FormRevisionSrc EQU (.-HostRevision)
HostEnd

        ALIGN

      [ :LNOT:soft

        ASSERT  FormVendorSrc   = 8     ; These are the widths of the
        ASSERT  FormProductSrc  = 16    ; fields in the returned
        ASSERT  FormRevisionSrc = 4     ; Inquiry data


dev_heading
        DCB     CR,LF,"SCSI Devices:",CR,LF,SPACE,0
dev_host
        DCB     "Host",0

dev_notpresent
        DCB     "LUN not present  "

FormDeviceDst   EQU 7
FormTypeDst     EQU 18
FormCapacityDst EQU 12
FormVendorDst   EQU 9
FormProductDst  EQU 17

        ALIGN

;
; Textual forms of Peripheral-Device-Types
;
DeviceTypeDecodeTab
        DCD     TextDirect       - DeviceTypeDecodeTab      ; &00
        DCD     TextSequential   - DeviceTypeDecodeTab      ; &01
        DCD     TextPrinter      - DeviceTypeDecodeTab      ; &02
        DCD     TextProcessor    - DeviceTypeDecodeTab      ; &03
        DCD     TextWORM         - DeviceTypeDecodeTab      ; &04
        DCD     TextRODirect     - DeviceTypeDecodeTab      ; &05
        DCD     TextScanner      - DeviceTypeDecodeTab      ; &06
        DCD     TextOptical      - DeviceTypeDecodeTab      ; &07
        DCD     TextChanger      - DeviceTypeDecodeTab      ; &08
        DCD     TextComms        - DeviceTypeDecodeTab      ; &09

maxPERIPHERALDEVICETYPE EQU (.-DeviceTypeDecodeTab):SHR:2
        DCD     TextUnknown      - DeviceTypeDecodeTab      ; &0A..&7F


TextDirect      DCB "Direct-access    "                 ;&00
TextSequential  DCB "Sequential-access"                 ;&01
TextPrinter     DCB "Printer          "                 ;&02
TextProcessor   DCB "Processor        "                 ;&03
TextWORM        DCB "WORM             "                 ;&04
TextRODirect    DCB "Read-only        "                 ;&05
TextScanner     DCB "Scanner          "                 ;&06
TextOptical     DCB "Optical memory   "                 ;&07
TextChanger     DCB "Changer          "                 ;&08
TextComms       DCB "Communications   "                 ;&09
TextUnknown     DCB "Unknown          "
TextHost        DCB "Host             "
FormTypeSrc     EQU (.-TextHost)

        ALIGN

TextCapacityUnknown     DCB "Unknown"
LenTextCapacityUnknown  EQU (.-TextCapacityUnknown)

        ALIGN

AliasFrom       DCB "Alias$Devices", 0
AliasTo         DCB "%SCSIDevices"

        ALIGN

      ] ; :LNOT:soft


;************************************************
;       Initialisation entry
;************************************************

; On entry (in supervisor mode)
;   R10 -> environment string
;   R11  = 0            if loaded from filing system
;        > &03000000    if loaded from a podule and is the base of the podule
;        = 1..&02FFFFFF if being reincarnated and is the number of other
;                       incarnations
;   R12 -> private word (private word <> 0 implies reinitialisation)
;   R13  = supervisor stack pointer (FD stack)
;
; Must preserve processor mode, interrupt state, R7..R11,R13
; Can corrupt R0..R6,R12,R14 and flags
;
; Return by MOV PC,R14 with VC or VS & R0->error
;
ModInit
        mess    ,"ModInit",NL
        Push    "R7-R11,Link"

      [ testMEMC
        MOV     R0,#0                   ; Our copier only works with MEMC1a as
        LDRB    R0,[R0,#MemorySpeed+2]  ; it uses LDM/STM to podule area.
        TST     R0,#1                   ; Assumes future MEMCs/OSs set this properly.
        BEQ     err_WrongMEMC
      ]
        LDR     R2,[R12]                ; Load private word
        TEQ     R2,#0
        MOVNE   WsPtr,R2                ; Already got our workspace (ie this is a
        BNE     GotWorkSpace            ; reinitialise entry)

      [ :LNOT:soft
        ADR     R0,AliasFrom
        ADR     R1,AliasTo              ; Transitionary
        MOV     R2,#?AliasTo
        MOV     R3,#0
        MOV     R4,#VarType_LiteralString
        SWI     XOS_SetVarVal
      ]
        CMP     R11,#&03000000          ; Loaded from a podule,
        BHS     ModIn_20                ; R11 is podule base address
        CMP     R11,#0
        BNE     exitModInit             ; If <>0, new incarnation, do nothing
;
; R11=0, means loaded from filing system, so look for a single digit podule
; number in the environment string (R10 points after the module name).
;
ModIn_10
        LDRB    R0,[R10],#1             ; Skip leading spaces
        CMP     R0,#" "                 ; 
        BEQ     ModIn_10                ; 

        SUBS    R3,R0,#"0"              ; Accept "0"..."7",
        MOVLT   R3,#0                   ; assume anything else (non-digit
        CMP     R3,#7                   ; or unspecified is podule zero).
        MOVHI   R3,#0                   ;
        SWI     XPodule_HardwareAddress
        LDRVC   R14,=Podule_BaseAddressBICMask
        BICVC   R11,R3,R14              ; Zap the CMOS RAM base
        MOVVS   R11,#0                  ; R11 now holds the podule base address (for sync access)
ModIn_20
        BIC     R11,R11,#PoduleSpeedMask  ; Reduce to slow access address from sync.

        SWI     XSCSI_LogList           ; Ask ScsiLog for a list of Podule base
        MOVVS   R0,#0                   ; addresses
        MOV     R3,#0

        Push    R0
        BVS     ModIn_40                ; ScsiLog not installed (or knows nothing???)
ModIn_30
        LDR     R1,[R0],#4              ; Count number of podule addresses in list
        TEQ     R1,R11                  ;  (If R11 is a duplicate of one of the list
        MOVEQ   R11,#0                  ;   values, kill it).
        TEQ     R1,#0                   ; Don't count if null terminator
        ADDNE   R3,R3,#1
        BNE     ModIn_30
ModIn_40
        Pull    "R1"
        CMP     R11,#0                  ; Include latest entry?
        ADDNE   R3,R3,#1
;
; R3 now holds count of scsi cards
;
        CMP     R3,#4                   ; Restrict to 4 cards maximum because there can't
        MOVGT   R3,#4                   ; be more than 4 buses at a time

        MOV     R0,#:INDEX: SCSIstubsize
        LDR     R2,=(:INDEX: Cardworkspacesize)
        MLA     R3, R2,R3,R0

        MOV     R0,#ModHandReason_Claim
        SWI     XOS_Module
        BVS     err_NoRoom_forworkspace

        STR     R2,[R12]                ; Store ->WorkSpace in private word
        MOV     WsPtr,R2                ; WsPtr is R12

        MOV     R2,#(:INDEX:ListEntry0)
        TEQ     R1,#0                   ; If no list obtained from ScsiLog
        BEQ     ModIn_60                ; then skip
ModIn_50
        CMP     R2,#(:INDEX: ListHighestTerm)
        BGE     ModIn_70                ; (must terminate now!!!)

        LDR     R0,[R1],#4              ; else Copy null terminated list obtained from
        TEQ     R0,#0                   ; ScsiLog (ignoring entries that clash
        STRNE   R0,[WsPtr,R2]           ; with our (R11) address).
        ADDNE   R2,R2,#4
        BNE     ModIn_50

ModIn_60
        CMP     R11,#0
        STRNE   R11,[WsPtr,R2]          ; Add our podule address to end of list
        ADDNE   R2,R2,#4
ModIn_70
        MOV     R11,#0
        STR     R11,[WsPtr,R2]          ; Terminate the list
;
; R2 = 4 * number of ScsiCards (max of 4 cards)
;
        SUB     R2,R2,#(:INDEX:ListEntry1)
        MOV     R2,R2,ASR #2
        STR     R2,maxCardID

GotWorkSpace
        ForEachCard HardResetCard       ; Do the deed to reset the hardware
      [ soft
        ForEachCard RegisterCard        ; and register the podule with the SCSI switcher
      ]

exitModInit
        Pull    "R7-R11,PC"

err_NoRoom_forworkspace
        XSCSIError SCSI_NoRoom
        B       exitModInit

        MakeSCSIErrorBlock SCSI_NoRoom

      [ testMEMC
err_WrongMEMC
        XSCSIError SCSI_WrongMEMC       ; then return VS & R0->error
        B       exitModInit             ; in usual fashion

        MakeErrorBlock SCSI_WrongMEMC   ; "SCSI requires MEMC1a - see your dealer"
      ]


;************************************************
;       Finalisation entry
;************************************************

; On entry
;   R10  = fatality indication (0/1 for non-fatal/fatal)
;   R12 -> private word
;   R13  = supervisor stack pointer
;
; On exit (VC or VS & R0->error)
;   May corrupt R0-R6,R12,R14
;   Must preserve R7-R11,R13
;
ModDie
        mess    ,"ModDie",NL
        Push    "R7-R11,Link"
        LDR     WsPtr,[R12]             ; Get workspace ptr
        CMP     WsPtr,#0
        BEQ     ModDi_10                ; Wot! no workspace

      [ soft
        ForEachCard DeregisterCard      ; Degister all our cards with the SCSI switcher
      ]
        ForEachCard FreezeAndRelease    ; and shut down the hardware
ModDi_10
        CLRV
        Pull    "R7-R11,PC",AL

      [ soft
RegisterCard
        Push    "LR"
        MOV     R0, #1                  ; bus
        ORR     R0, R0, #7:SHL:8        ; highest device = 7
        ORR     R0, R0, #7:SHL:16       ; default host ID = 7
        ADR     R1, SoftHandler
        MOV     R2, WsPtr
        MOV     R3, R5
        SWI     XSCSI_Register
        MOVVS   R0,#-1                  ; Failed to register (maybe too many other people have)
        STR     R0, HostID              ;  mark card appropriately
        Pull    "PC"

DeregisterCard
        LDR     R0, HostID
        CMP     R0, #-1
        MOVEQ   PC, LR
        Push    "LR"
        ADR     R1, SoftHandler
        MOV     R2, WsPtr
        MOV     R3, R5
        SWI     XSCSI_Deregister        ; Deregister with the same parameters we registered with
        Pull    "PC"
      ]


;************************************************
;       Service call handler
;************************************************
;
; On entry (in supervisor or interrupt mode depending on the service)
;   R1   = service number
;   R12 -> private word
;   R13  = stack pointer
;
; On exit
;   R1   = preserved or zero if claiming service
;   R2   = preserved or returns a result
;
; May corrupt R12
;
; Return with MOV PC,R14
;
; N.B. The normal VS & R0->error convention cannot be used
;
        ASSERT  Service_Reset < Service_PreReset
ModServiceTable
        DCD     0
        DCD     ModServiceEntry-Module_BaseAddr
        DCD     Service_Reset
        DCD     Service_PreReset
        DCD     0

        DCD     ModServiceTable-Module_BaseAddr
ModService
        MOV     R0, R0                  ; magic instruction signifying fast service table presence
        CMP     R1,#Service_PreReset
        CMPNE   R1,#Service_Reset
        MOVNE   PC,Link

ModServiceEntry
        Push    Link
        LDR     WsPtr,[R12]

        CMP     R1,#Service_Reset
        BEQ     ModServ_30


;************************************************
;       Service Pre_Reset
;************************************************

; The user has pressed the BREAK key, rather than the RESET button, so
; force a podule reset
;
;>>>Is it safe to leave reset asserted until Service_Reset comes around
;>>> or should we delay 25us then release it. The worry is that a control-BREAK
;>>> might kick the module out, leaving the SCSI_RESET line asserted.
;
ModServ_20
        mess    ,"ModService, Service_PreReset",NL
        Push    "R0-R11"                ; Link already pushed

        ForEachCard FreezeHardware

        Pull    "R0-R11,PC",AL



;************************************************
;       Service_Reset
;************************************************

ModServ_30
        mess    ,"ModService, Service_Reset",NL
        Push    "R0-R11"                ; Link already pushed

      [ soft
        ; You only get Service_Reset when in ROM, and after the point of registering with
        ; the SCSI switcher. Clearing the queue while it's in use is bad.
      |
        ForEachCard SoftResetCard
      ]
        Pull    "R0-R11,PC",AL

        LTORG                           ; Dump them Literals




    [ soft
;************************************************
;       SCSI switcher entry point dispatch
;************************************************

; On entry
;   R0..R7 as appropriate
;   R8   = hardware pointer for card
;   R11  = driver reason code
;   R12 -> workspace for card
;   R13  = Stack pointer
;
; On exit
;   R0..R7 return results, or are preserved
;
; Entered in SVC_mode with callers interrupt state

SoftHandler
        mess    ,"SCSI_Entry - Entry", NL
        Push    "R0-R9,Link"

        CMP     R11,#maxEntry
        ASSERT  (SCSI_Entrytable-. =8)  ; Table must follow code
        ADDCC   PC,PC,R11,ASL #2
        B       err_Entryunkn

SCSI_Entrytable
        B       FeaturesEntry           ; List features
        B       ResetBusEntry           ; Reset bus (the podule does do buses)
        B       err_Entryunkn           ; Reserved
        B       err_Entryunkn           ; Reserved
        B       err_Entryunkn           ; Don't do foreground transfers, the SCSI switcher will do these
        B       OpEntry                 ; using the background entry point instead
        B       AbortOpEntry            ; For cancelling a pending background operation
        B       HostDescEntry           ; Return host description (only used if buses are supported, as here)
maxEntry * (.-SCSI_Entrytable):SHR:2

err_Entryunkn
        XSCSIError SCSI_SWIunkn

exitSWIdecode
exitEntrydecode
        STRVS   R0,StackedR0            ; Overwrite stacked R0 with ->error
        mess    ,"SCSI_Entry - Exit", NL
        Pull    "R0-R9,PC"

    | ; soft

;************************************************
;       SWI name table
;************************************************

;
; SWInames table
;
SCSI_SWInames
        DCB     "SCSI",0                ; SWI group prefix
        DCB     "Version",0             ; +0
        DCB     "Initialise",0          ; +1
        DCB     "Control",0             ; +2
        DCB     "Op",0                  ; +3
        DCB     "Status",0              ; +4
        DCB     "5",0                   ; +5
        DCB     "6",0                   ; +6
        DCB     "Reserve",0             ; +7
        DCB     "List",0                ; +8
        DCB     0
        ALIGN


;************************************************
;       SWI dispatch
;************************************************

; On entry
;   R11  = SWI number within SCSI_SWI block
;   R12 -> private word
;   R13  = Stack pointer
;
; On exit
;   R0..R7 return results, or are preserved
;
; Entered in SVC_mode with callers interrupt state
;
; May corrupt R10..R12, return with MOVS PC,R14
;
SCSI_SWIdecode
        mess    ,"SCSI_SWIdecode - Entry", NL
        Push    "R0-R9,Link"

        LDR     WsPtr,[R12]             ; Get workspace ptr

        CMP     R11,#maxSWI
        ASSERT  (SCSI_SWItable-. =8)    ; Table must follow code
        ADDCC   PC,PC,R11,ASL #2
        B       err_SWIunkn

SCSI_SWItable
        MySWI   SCSI_Version
        MySWI   SCSI_Initialise
        MySWI   SCSI_Control
        MySWI   SCSI_Op
        MySWI   SCSI_Status
        MySWI   SCSI_ReadControlLines   ; } Not supported by Acorn SCSIdriver
        MySWI   SCSI_EEProm             ; }
        MySWI   SCSI_Reserve
        MySWI   SCSI_List

maxSWI  * (.-SCSI_SWItable):SHR:2

err_SWIunkn
        XSCSIError SCSI_SWIunkn
        B       exitSWIdecode

        MakeSCSIErrorBlock SCSI_SWIunkn

exitSWIdecode

      [ counts
        Push    "R0-R4"
        SavePSR R4
        ADRL    R3, MyInfoSpace1
        LDR     R0, [R3, #0]
        BEQ     NotOpSWI
        SWI     OS_WriteS
        =       "StartCommand : "
        LDR     R0, [R3, #8]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_NewLine
        SWI     OS_WriteS
        =       "int_ser_65+  : "
        LDR     R0, [R3, #4]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_NewLine
        SWI     OS_WriteS
        =       "int_ser_202  : "
        LDR     R0, [R3, #12]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_NewLine

        SWI     OS_WriteS
        =       "IDLE:"
        LDR     R0, [R3, #16]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  RUNNING:"
        LDR     R0, [R3, #20]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  STALLED:"
        LDR     R0, [R3, #24]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  WAITING:"
        LDR     R0, [R3, #28]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_NewLine

        SWI     OS_WriteS
        =       "INITIALISING:"
        LDR     R0, [R3, #32]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  INITIALISED:"
        LDR     R0, [R3, #36]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_NewLine

        SWI     OS_WriteS
        =       "TtlCnt: "
        LDR     R0, [R3, #52]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  ScatPtr: "
        LDR     R0, [R3, #56]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  EntCnt: "
        LDR     R0, [R3, #60]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  EntAdr: "
        LDR     R0, [R3, #64]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_NewLine

NotOpSWI
        MOV     R0, #1
        STR     R0, [R3, #0]
        RestPSR R4,,f
        Pull    "R0-R4"
      ]

        STRVS   R0,StackedR0            ; Overwrite stacked R0 with ->error
        Pull    "R0-R9,Link"
        mess    ,"SCSI_SWIdecode - Exit", NL
      [ :LNOT:No32bitCode
        TEQ     PC,PC
        MOVEQ   PC,Link
      ]
        ORRVS   Link,Link,#V_bit        ; Stacked Link had VClear, so set if error
        MOVS    PC,Link


;************************************************
;       SCSI_Version
;************************************************

; On exit
;   R0 bits 0..7  software minor version number
;      bits 8..31 software major version number (100 for 1.00)
;   R1 bitset of  software features
;   R2 bits 0..7  hardware minor version number
;      bits 8..31 hardware major version number (100 for 1.00)
;   R3 bitset of  hardware features
;
SWI_SCSI_Version
        traceswi "Version"
        ADR     R0,VersionBlk
        LDMIA   R0,{R0,R1,R2,R3}        ; Pickup return values
        STMIA   StkPtr,{R0,R1,R2,R3}    ; Write to StackedR0..StackedR3
        B       exitSWIdecode           ; will be popped on return

VersionBlk
        DCD     SoftwareVersionNumber
        DCD     SoftwareExtensions
        DCD     HardwareVersionNumber
        DCD     HardwareExtensions


;************************************************
;       SCSI_Initialise
;************************************************

; Various initialisations determined by a reason code in R0
;
; On entry
;   R0 = 0 - reset bus
;        1 - reset device
;        2 - determine device
;        3 - enumerate device
;   R1 = hostID/deviceID
;
SWI_SCSI_Initialise
        traceswi "Initialise"
        AddressCard
        BVS     exitSWIdecode
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}

        ASSERT  (:INDEX:PODULEptr)=4
        ASSERT  (:INDEX:DMACptr)=8

        CMP     R0,#maxSCSI_InitRC
        ASSERT  (SCSI_InitRCtable-. =8) ; Table must follow code
        ADDCC   PC,PC,R0,ASL #2
        B       err_RCunkn

SCSI_InitRCtable
        B       ResetBus
        B       ResetDevice
        B       DetermineDevice
        B       EnumerateDevice
      [ debug
        B       ExamineDeviceWS
      ]

maxSCSI_InitRC * (.-SCSI_InitRCtable):SHR:2

err_RCunkn
        XSCSIError SCSI_RCunkn
        B       exitSWIdecode

        MakeSCSIErrorBlock SCSI_RCunkn
    ] ; :LNOT:soft


;************************************************
;       Reset bus (SWI SCSI_Initialise, RC=0)
;************************************************

; Reset the SCSIbus, the SBIC and the DMAC by pulsing the podule reset bit.
; Then initialise the SBIC and DMAC.
;
; Reset duration. The DMAC needs 250nS, the SBIC 1uS and the SCSI bus 25uS,
; so aim for >25uS
;
; On entry
;   R0   = 0
;   R1   = HostID (0..7, usually 7), LUN field must be 0
;
; Exit by B(VS) exitSWIdecode
;
; LUN<>0 reported as "Invalid host ID"
;
      [ soft
ResetBusEntry
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}
      ]
ResetBus
        tracerc "ResetBus"
        CMP     R1,#maxDeviceID         ; Only ID's 0..7 are valid
        BHI     err_BadHostID

        BL      UserResetCard

        B       exitSWIdecode

err_BadHostID
        XSCSIError SCSI_BadHostID
        B       exitSWIdecode

        MakeSCSIErrorBlock SCSI_BadHostID


;************************************************
;       Reset device (SWI SCSI_Initialise, RC=1)
;************************************************

; Reset the device by sending MESSAGE_BUSDEVICERESET
;
; On entry
;   R0 = 1
;   R1 = DeviceID (DevID, LUN)
;
;   R8 = AccessKey
;
; LUN number 0 passed to SCSImessage_internal
;
ResetDevice
        tracerc "ResetDevice"
        BL      ValidateID              ; In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
        ;       R0->"Device ID invalid"
        BLVC    AddressDevice           ; In: R1=DeviceID
        ;Out:R1=DeviceID,R9->deviceblk
      [ :LNOT:soft
        BLVC    CheckAccess             ; In: R8=AccessKey, R9->deviceblk, Out:VC or
        ;       VS & R0->"SCSI driver reservation error"
      ]
        BVS     exitSWIdecode

        MOV     R0,#CTL_DOINGRESET      ; Try to send MESSAGE_BUSDEVICERESET
        BL      SCSImessage_internal    ; to device (LUN=0)
;
; This should generate an &8E interrupt which allows the message to be sent,
; followed by an &85 interrupt.
;
; N.B. &8E is service required - REQ asserted following connection,
;          MessageOut phase requested),
;      &85 is service required - Disconnection has occured.
;
        B       exitSWIdecode

err_NoDevice
        XSCSIError SCSI_NoDevice
        B       exitSWIdecode

        MakeSCSIErrorBlock SCSI_NoDevice


;************************************************
;       DetermineDevice (SWI SCSI_Initialise, RC=2)
;************************************************

; Return device type (tape,winnie,WORM etc) and Capacity
;
; This is a 'safe' operation, AccessKey not checked
;
; On entry
;   R0  = 2
;   R1  = DeviceID (DevID, LUN)
;   R2 -> buffer for description (16 bytes, word aligned)
;
; On exit (VC)
;   R0..R2 preserved
;
; On exit (VS)
;   R0 -> "Device ID invalid"
;
; Passes DevID and LUN to SCSIop_internal
;
DetermineDevice
        tracerc "DetermineDevice"
        BL      ValidateID              ; In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
        ;       R0->"Device ID invalid"
        BLVC    AddressDevice           ; In: R1=DeviceID
        ;Out:R1=DeviceID,R9->deviceblk
        BVS     exitSWIdecode

      [ bugfix12
        LDR     R1,StackedR1            ; Recover DeviceID
        ;BIC    R1,R1,#CardIDMask       ; but kill the CardID bits ;>>>Is this needed???
      ]
        SUB     StkPtr,StkPtr,#((Determine_BLK_SIZE + 3) :AND: &FFFFFFFC)
        MOV     R3,StkPtr

        ORR     R0,R1,#CTL_DumbDeviceTXREAD ; Assume target is dumb
        ADR     R2,cdb_inquiry_withread
        LDR     R1,[R2],#4              ; CDB length, R2 now->CDB
        MOV     R4,#INQUIRY_BLK_SIZE

        Push    R0                      ; Wanted later on
        MOV     R5,#0                   ; Default timeout
        BL      SCSIop_internal         ; Out: R0-R2 corrupt,R3->Last byte received+1,
        ;       R4=amount untransfered
        ADDVS   StkPtr,StkPtr,#4+((Determine_BLK_SIZE + 3) :AND: &FFFFFFFC)
        BVS     det_dev_10
        Pull    R0
;>>>should we set the address here???
        ADD     R3,R3,#3                ; Align to next word boundary
        BIC     R3,R3,#3

        ADR     R2,cdb_readcapacity
        LDR     R1,[R2],#4              ; CDB length, R2 now->CDB
        MOV     R4,#READCAPACITY_BLK_SIZE

        MOV     R5,#0                   ; Default timeout
        BL      SCSIop_internal         ; Out: R0-R2 corrupt,R3->Last byte received+1,
        ;       R4=amount untransfered
      [ bugfix8
        TEQ     R4,#0                   ;     R4=amount untransfered
      ]
        LDMIA   StkPtr,{R3,R4,R5,R6}
        ADD     StkPtr,StkPtr,#((Determine_BLK_SIZE + 3) :AND: &FFFFFFFC)

        AND     R4,R4,#&FF              ; Bytes 5..7 returned as zero
      [ bugfix8
        MOVNE   R5,#&FFFFFFFF           ; If 'read-capacity' failed or didn't return
        MOVNE   R6,#&FFFFFFFF           ; enough data, return -1,-1.
      ]
        RevBytes R5, R7,R8              ; Convert highest logical block number
        RevBytes R6, R7,R8, s           ; and block length to normal ARM byte sex

        LDR     R2,StackedR2            ; Recover users buffer address
        STMIA   R2 !,{R3,R4,R5,R6}
det_dev_10
        B       exitSWIdecode

; cdb_inquiry_notransfer - Control word & CDB for an inquiry command
; ======================
;
; Transfer direction bits and allocation length byte set for NO data
; Used to determine if a device is present
;
cdb_inquiry_notransfer
        DCD     cdb_inquiry_notx_end-cdb_inquiry_notx_start
cdb_inquiry_notx_start
        DCB     C_INQUIRY               ; INQUIRY command
        DCB     0                       ; LUN=0 (b7..b5), reserved=0 (b4..b0)
        DCB     0                       ; reserved
        DCB     0                       ; reserved
        DCB     0                       ; Allocation length=0
        DCB     0                       ; Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
        ;       Flag=0 (b1),Link=0 (b0)
cdb_inquiry_notx_end
        ALIGN


; cdb_inquiry_withread - Control word & CDB for an inquiry command
; ====================
;
cdb_inquiry_withread
        DCD     cdb_inquiry_withread_end-cdb_inquiry_withread_start
cdb_inquiry_withread_start
        DCB     C_INQUIRY               ; INQUIRY command
        DCB     0                       ; LUN=0 (b7..b5), reserved=0 (b4..b0)
        DCB     0                       ; reserved
        DCB     0                       ; reserved
        DCB     INQUIRY_BLK_SIZE        ; Allocation length
        DCB     0                       ; Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
        ;       Flag=0 (b1),Link=0 (b0)
cdb_inquiry_withread_end
        ALIGN


; cdb_inquiry_withreadL - Control word & CDB for an inquiry command
; =====================
;
cdb_inquiry_withreadL
        DCD     cdb_inquiry_withread_endL-cdb_inquiry_withread_startL
cdb_inquiry_withread_startL
        DCB     C_INQUIRY               ; INQUIRY command
        DCB     0                       ; LUN=0 (b7..b5), reserved=0 (b4..b0)
        DCB     0                       ; reserved
        DCB     0                       ; reserved
        DCB     INQUIRY_BLK_SIZEL       ; Allocation length
        DCB     0                       ; Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
        ;       Flag=0 (b1),Link=0 (b0)
cdb_inquiry_withread_endL
        ALIGN


; cdb_readcapacity - Control word & CDB for a read capacity command
; ================
;
; Partial Medium Indicator (PMI) & Logical Block Address are zero, to mean
; return logical block address & block length (in bytes) of the last logical
; block of the drive.
;
cdb_readcapacity
        DCD     cdb_readcapacity_end-cdb_readcapacity_start
cdb_readcapacity_start
        DCB     C_READCAPACITY          ; READCAPACITY command
        DCB     0                       ; LUN=0 (b7..b5), reserved=0 (b4..b1),
        ;       RelAdr=0 (b0)
        DCB     0                       ; Logical block address (MSB)
        DCB     0
        DCB     0
        DCB     0                       ; Logical block address (LSB)
        DCB     0                       ; reserved
        DCB     0                       ; reserved
        DCB     0                       ; VU=0 (b7..b6), Reserved=0 (b5..b1), PMI=0 (b0)
        DCB     0                       ; VU=0 (b7..b6), Reserved=0 (b5..b2),
        ;       Flag=0 (b1),Link=0 (b0)
cdb_readcapacity_end
        ALIGN


; cdb_requestsense - Control word & CDB for a request sense command
; ================
; Allocation length is 8 to mean return 8 bytes of extended sense data
;
cdb_requestsense
        DCD     cdb_requestsense_end-cdb_requestsense_start
cdb_requestsense_start
        DCB     C_REQUESTSENSE          ; REQUESTSENSE command
        DCB     0                       ; LUN=0 (b7..b5), reserved=0 (b4..b0)
        DCB     0                       ; reserved
        DCB     0                       ; reserved
        DCB     REQUESTSENSE_BLK_SIZE       ; Allocation length=0
        DCB     0                       ; VU=0 (b7..b6), Reserved=0 (b5..b2),
        ;       Flag=0 (b1),Link=0 (b0)
cdb_requestsense_end
        ALIGN

    [ :LNOT:soft

;************************************************
;       EnumerateDevice (SWI SCSI_Initialise, RC=3)
;************************************************

; This is a safe operation, AccessKey not checked
;
; On entry
;   R0  = 3
;   R1  = DeviceID (DevID, LUN)
;   R2 -> buffer to fill
;   R3  = buffer size
;
; On exit (VC)
;   R0    preserved
;   R1    preserved
;   R2    preserved
;   R3 -> terminating 0
;
;
; On exit (VS)
;   R0 -> error
;   R1    preserved
;   R2    preserved
;   R3
;
; Passes DevID and LUN to determinedevice_internal
;
EnumerateDevice
        tracerc "EnumerateDevice"
        STR     R2,StackedR3            ; So failure of XOS_ConvertCardinal1 gives ->""

        LDR     R0,StackedR1            ; Use stacked DeviceID, which includes CardID and LUN

        MOV     R1,R2                   ; Position in buffer to place DeviceID
        MOV     R2,R3                   ; Buffer size
        ADD     R6,R1,#FormDeviceDst    ; Next field is device type

        SWI     XOS_ConvertCardinal1    ; In R0=cardinal,R1->Buffer,R2=BuffSz
        BVS     enu_dev_30              ; Out R0->Buffer,R1->terminator,R2=bytes left

        BL      PadField                ; In R1=current position,R2=BuffSz,R6->nextfield
        ;Out    R1=R6=terminator,R2=bytes left

        STR     R1,StackedR3            ; Advance stacked endpointer

        MOV     R6,R1                   ; ->next field in buffer
        MOV     R7,R2                   ; Bytes left in buffer

        LDR     R0,StackedR1            ; Recover DeviceID
        BIC     R0,R0,#CardIDMask       ; but kill the CardID bits
        LDR     R1,HostID

;
; Lower the stack and perform a 'determine device'.
; Format of returned data (we return it on the stack):
;
;   bytes 0..3    Highest Logical block address } (ARM byte sex)
;         4..7    Block length                  }
;   byte  8       Peripheral device type
;         9       RMB & Device-type qualifier
;         10      ISO/ECMA/ANSI version
;         11      Reserved
;         12      Additional length
;         13..15
;         16..23  Vendor identification (ASCII)
;         24..39  Product identification (ASCII)
;         40..43  Revision level (ASCII)
;
        SUB     StkPtr,StkPtr,#((Describe_BLK_SIZE + 3) :AND: &FFFFFFFC)

        CMP     R0,R1
        BEQ     enu_dev_50

        MOV     R1,StkPtr
        MOV     R2,#Describe_BLK_SIZE
        BL      determinedevice_internal     ; In R0=DeviceID,R1->buffer,R2=bufferlen
        BVS     enu_dev_20              ; Out R0->buffer,R1->last byte+1,R2=

        MOV     R3,StkPtr               ; ->recovered data
        SUB     R4,R1,StkPtr            ; Size of recovered data
        Push    "R3,R4"                 ; Preserve for later

;
; R6 -> next field in buffer
; R7  = bytes left in buffer
;


;
; Interpret the Peripheral-Device-Type field
;
        LDRB    R0,[R3,#8]

        CMP     R0,#maxPERIPHERALDEVICETYPE
        MOVHI   R0,#maxPERIPHERALDEVICETYPE

        ADRL    R3,DeviceTypeDecodeTab
        LDR     R0,[R3,R0,LSL #2]
        ADD     R3,R0,R3

        MOV     R1,R6                   ; ->buffer
        MOV     R2,R7                   ; =buffersize

        MOV     R4,#255
        MOV     R5,#FormTypeSrc
        ADD     R6,R6,#FormTypeDst
        ;In:    R1->dest buf,R2=dest size,R3->src buf
        BL      CopyField               ;     R4=src buf size,R5=src field size
        BL      PadField                ; In R1=current position,R2=BuffSz,R6->nextfield
        ;Out    R1=R6=terminator,R2=bytes left


        Pull    "R3,R4"
;
;R1->dest buffer, R2=dest size, R3->ReadCapacity/Inquire data, R4 size of
;R6->next dest field
;
        Push    "R3,R4"
        LDMIA   R3,{R3,R4}              ; Highest sector address, sector size

        CMP     R3,#-1                  ; Sector address & size of
        CMPEQ   R4,#-1                  ; -1,-1 indicates device doesnt
        ADREQL  R3,TextCapacityUnknown  ; support 'read-capacity' cmd
        MOVEQ   R4,#LenTextCapacityUnknown        ; or returned unsufficent data
        MOVEQ   R5,#LenTextCapacityUnknown        ; 
        BLEQ    CopyField                         ; so print 'Unknown'
        BEQ     enu_dev_02                        ;
        ;Else   print valid capacity
        ADD     R3,R3,#1                ; Total sector count
      [ BigCapacity
        ;       UMULL R0,R3,R4,R3
        Split16 R8,R9,R4                ; R8:=R4.h, R9:=R4.l
        Mul64   R3,R0,R8,R9,R3,,,R10,R5,LR ; (R3,R0)=(R8,R9)*R3, using R3,R5,LR as work regs
        BL      ConvertFixedFileSize64  ; In R0=Capacity(L),R1->Buffer,R2=BuffSz,R3=Capacity(H)
      |
        MUL     R0,R3,R4                ; Device capacity (bytes)

        ;ADD    R6,R6,#FormCapacityDst
        SWI     XOS_ConvertFixedFileSize    ; In R0=Capacity,R1->Buffer,R2=BuffSz
      ]
        BVS     enu_dev_30              ; Out R0->Buffer,R1->terminator,R2=bytes left

enu_dev_02
        ADD     R6,R6,#FormCapacityDst
        BL      PadField                ; In R1=current position,R2=BuffSz,R6->nextfield
        ;Out    R1=R6=terminator,R2=bytes left
        Pull    "R3,R4"
        ADD     R3,R3,#(8+8)            ; -> Vendor-Identification field
        SUB     R4,R4,#(8+8)
;
;R1->dest buffer, R2=dest size, R3->Vendor Identification data, R4 size of
;R6->next dest field
;
enu_dev_05
        MOV     R5,#FormVendorSrc       ; sizeof(Vendor-Identification field)
        ADD     R6,R6,#FormVendorDst
        ;In:    R1->dest buf,R2=dest size,R3->src buf
        BL      CopyField               ;     R4=src buf size,R5=src field size
        ;Out:   R0->dest, R2..R5 updated
        BL      PadField                ; In R1=current position,R5->next field
        ;Out    R1=R5= ->next field

        MOV     R5,#FormProductSrc      ; sizeof(Product-Identification field)
        ADD     R6,R6,#FormProductDst
        BL      CopyField
        BL      PadField

        MOV     R5,#FormRevisionSrc     ; sizeof(Revision-Level field)
        BL      CopyField

        ADD     StkPtr,StkPtr,#((Describe_BLK_SIZE + 3) :AND: &FFFFFFFC)

        STR     R1,StackedR3            ; Pass back offset to terminating zero

        LDR     R3,StackedR3
        MOV     R0,#0
        STRB    R0,[R3]                 ; Terminate string

        B       exitSWIdecode


enu_dev_20
        ADD     StkPtr,StkPtr,#((Describe_BLK_SIZE + 3) :AND: &FFFFFFFC)
enu_dev_30
        STR     R0,StackedR0
        LDR     R3,StackedR3
        MOV     R0,#0
        STRB    R0,[R3]                 ; Terminate string

        B       exitSWIdecode
;
; R6 -> dest buffer, R7 = bytes left in dest buffer
;

enu_dev_50
        MOV     R1,R6                   ; ->buffer
        MOV     R2,R7                   ; =buffersize
        ADRL    R3,TextHost
        MOV     R4,#255
        MOV     R5,#FormTypeSrc
        ADD     R6,R6,#FormTypeDst+FormCapacityDst
        ;In:    R1->dest buf,R2=dest size,R3->src buf
        BL      CopyField               ;     R4=src buf size,R5=src field size
        BL      PadField                ; In R1=current position,R2=BuffSz,R6->nextfield
        ADRL    R3,HostVendor
        MOV     R4,#(HostEnd-HostVendor)
        B       enu_dev_05

      [ BigCapacity
;Adapted from the Kernel's OS_ConvertFixedFileSize code

;In R0=Capacity(L),R1->Buffer,R2=BuffSz,R3=Capacity(H)
;Out R0->Buffer,R1->terminator,R2=bytes left,R3=0, R10+R12 corrupted
ConvertFixedFileSize64 ROUT
        MOV     r12, #0
        Push    "r1, lr"

        Push    "r4-r7"
        SUB     sp, sp, #16             ; May need temp frame

        MOV     r4, #0                  ; No char by default
05      CMP     r3, #0                  ; Go up to next format if >= 4096
        CMPEQ   r0, #4096
        BCC     %FT10
        ADD     r4, r4, #1
        MOVS    r0, r0, LSR #10         ; /1024
        ORR     r0, r0, r3, LSL #(32-10)
        MOV     r3, r3, LSR #10
        ADCS    r0, r0, #0              ; Round up iff bit fell out
        ADC     r3, r3, #0
        B       %BT05
10
        ADR     lr, PrefixTable
        LDRB    r4, [lr, r4]            ; Load the appropriate prefix

        MOV     r5, r0                  ; Remember for prettiness

        Push    "r1, r2"                ; Remembering state
        ADD     r1, sp, #4*2            ; Point to our temp buffer
        MOV     r2, #16
        SWI     XOS_BinaryToDecimal     ; This will not give error
        MOV     r7, r2                  ; Number of chars to do
        RSBS    r6, r2, #4              ; Number of spaces needed
        Pull    "r1, r2"
        BLE     %FT39

30      MOV     r10, #" "
        BL      addconvchar
        BVS     %FA95
        SUBS    r6, r6, #1
        BNE     %BT30

39      MOV     r6, sp                  ; Stick string in punter's buffer
40      LDRB    r10, [r6], #1
        BL      addconvchar
        BVS     %FA95
        SUBS    r7, r7, #1
        BNE     %BT40

        B       %FT60


60      MOVVC   r10, #" "
        BLVC    addconvchar
        MOVVC   r10, r4                 ; Char to print
        BLVC    addconvchar
        MOVVC   r10, #"b"               ; 'byte'
        BLVC    addconvchar
        MOVVC   r10, #"y"
        BLVC    addconvchar
        MOVVC   r10, #"t"
        BLVC    addconvchar
        MOVVC   r10, #"e"
        BLVC    addconvchar
        BVS     %FA95

        CMP     r5, #1                  ; Prettify (unpluralisationism). VClear
        MOVNE   r10, #"s"
        MOVEQ   r10, #" "               ; Need to pad to right
        BL      addconvchar

95      ADD     sp, sp, #16
        Pull    "r4-r7"
        MOVVC   R10, #0
        BLVC    addconvchar
        BVS     naffconversion

        Pull    "r0 ,lr"
        SUB     R2, R2, R12
        ADD     R2, R2, #1              ; null not really a char.
        SUB     R1, R1, #1
        MOV     pc, lr


naffconversion
        ADR     r0, ErrorBlock_BuffOverflow
        SETV
        Pull    "r1, pc"

; R1 current buffer pos
; R12 character count, R2 character limit
; R10 character

addconvchar ROUT

        CMP     R2, R12
        BLE     addconvcharoverflow

        ADD     R12, R12, #1
        STRB    R10, [R1], #1
        RETURNVC

addconvcharoverflow
        RETURNVS

PrefixTable
        DCB     " KMGTPE"
        ALIGN

ErrorBlock_BuffOverflow
        DCD     ErrorNumber_BuffOverflow
        DCB     "Buffer overflow",0
        ALIGN

      ]

;************************************************
;       ExamineDeviceWS (SWI SCSI_Initialise, RC=4)
;************************************************

; On entry
;   R0  = 4
;   R1  = DeviceID, LUN field is "don't care"
;
; On exit (VC)
;   R0 -> WorkSpace
;   R1 -> deviceBlk
;
; On exit (VS)
;   R0 -> "Device ID invalid"
;
      [ debug
ExamineDeviceWS
        tracerc "ExamineDeviceWS"
        BL      ValidateID              ; In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
        ;       R0->"Device ID invalid"
        BLVC    AddressDevice           ; In: R1=DeviceID
        ;Out:R1=DeviceID,R9->deviceblk
        BVS     exitSWIdecode

        STR     WsPtr,StackedR0
        STR     rDEVICEptr,StackedR1

        B       exitSWIdecode
      ]

;************************************************
;       Misc. routines
;************************************************

; determinedevice_internal
; ========================
;
; On entry
;   R0  = DeviceID (cardID=?, DevID, LUN)
;   R1 -> buffer
;   R2  = buffer length (assumed >= 12)
;
; On exit
;   R0 -> buffer (R1 entry value)
;   R1 -> buffer (last byte transfered+1)
;   R2  = amount untransfered
;
determinedevice_internal

        ORR     R0,R0,#CTL_DumbDeviceTXREAD ; Combine TargetID with control bits
        Push    "R0-R7,Link"

        MOV     R3,R1                       ; TxAdr
        MOV     R4,#READCAPACITY_BLK_SIZE   ; TxSize

        ADR     R2,cdb_readcapacity
        LDR     R1,[R2],#4              ; CDB length, R2 now->CDB
        MOV     R5,#0                   ; Default timeout
        BL      SCSIop_internal         ; Out: R0-R2 corrupt,R3->Last byte received+1,
        ;Ignore errors, capacity gets reported as -1,-1

        TEQ     R4,#0                   ;     R4=amount untransfered
        LDR     R0,StackedR1            ; Convert highest logical block number
        LDMEQIA R0,{R1,R2}              ; and block length to normal ARM byte sex
        MOVNE   R1,#&FFFFFFFF           ; 
        MOVNE   R2,#&FFFFFFFF           ; N.B. If 'read-capacity' failed or didn't
        RevBytes R1, R3,R4              ;     transfer enough data, return -1,-1.
        RevBytes R2, R3,R4, s           ;     If inquiry is successful, this can be
        STMIA   R0,{R1,R2}              ;     interpreted as 'device-present-but-naff'
        ;       or 'present-but-size-has-no-meaning'.
        Pull    "R0,R1,R4"
        ADD     R3,R1,#READCAPACITY_BLK_SIZE        ; Adjust ->block and block size
        SUB     R4,R4,#READCAPACITY_BLK_SIZE        ; for data already received.
        Push    "R1,R3,R4"
        ;Then   do inquiry command
        ADR     R2,cdb_inquiry_withreadL
        LDR     R1,[R2],#4              ; CDB length, R2 now->CDB
        MOV     R4,#INQUIRY_BLK_SIZEL
        MOV     R5,#0                   ; Default timeout
        BL      SCSIop_internal         ; Out: R0-R2 corrupt,R3->Last byte received+1,
        ;       R4=amount untransfered
        STR     R3,StackedR1
        STR     R4,StackedR2
det_dev_int_10
        STRVS   R0,StackedR0
        Pull    "R0-R7,PC"

;
; CopyField - Copy R5 characters from the source string to the destination
; =========
;
; On entry
;   R1 -> destination buffer
;   R2    size of destination buffer
;   R3 -> source string
;   R4    size of source string
;   R5    size of source field
;
; On exit
;   R0 -> destination buffer (->start)
;   R1 -> destination buffer (->terminating 0)
;   R2  = bytes free in buffer
;   R3 -> first uncopied source byte
;   R4  = bytes remaining in source string
;   R5  = uncopied source field bytes
;
CopyField
      [ No32bitCode
        Push    R1
      |
        Push    "R1,R6"
        SavePSR R6
      ]

        CMP     R2,#0                   ; If destination string full,
        BLE     cpy_fie_30              ; give up now (DON'T touch the string)

        CMP     R4,#0                   ; If source string empty
        CMPGT   R5,#0                   ; or source field empty
        BLE     cpy_fie_20              ; give up now (terminate destination string)

cpy_fie_10
        LDRB    R0,[R3],#1              ; Get bytes from source string,
        CMP     R0,#" "                 ; 'sanitise then' (replace 0..31,127 with " ")
        MOVLT   R0,#" "
        CMP     R0,#127
        MOVEQ   R0,#" "
        STRB    R0,[R1],#1              ; and write to destination string

        SUB     R4,R4,#1
        SUBS    R5,R5,#1
        CMPGT   R4,#0                   ; Loop until source field or source string
        BGT     cpy_fie_10              ; are exhausted

cpy_fie_20
        MOV     R0,#0
        STRB    R0,[R1]                 ; Terminate the destination string
cpy_fie_30
      [ No32bitCode
        Pull    R0
        MOVS    PC,Link
      |
        RestPSR R6,,f
        Pull    "R0,R6"
        MOV     PC,Link
      ]

;
; PadField
; ========
;
; On entry
;   R1 -> destination buffer
;   R2    size of destination buffer
;   R6 -> address to pad to
;
; On exit
;   R1 -> destination buffer (->terminating 0)
;   R2  = bytes free in buffer
;   R6 -> destination buffer (->terminating 0)
;
PadField
      [ :LNOT:No32bitCode
        Push    R3
        SavePSR R3
      ]
        MOV     R0,#" "
pad_fie_10
        SUBS    R2,R2,#1
        STRB    R0,[R1],#1
        CMP     R6,R1
        BHI     pad_fie_10

        MOV     R0,#0
        STRB    R0,[R1]                 ; Terminate the destination string
      [ No32bitCode
        MOVS    PC,Link
      |
        RestPSR R3,,f
        Pull    R3
        MOV     PC,Link
      ]

;************************************************
;       SCSI_Control
;************************************************

; Various control commands determined by a reason code in R0
;
; On entry
;   R0 = 0 - abort device
;        1 - abort op
;        2 - reserved
;        3 - set timeout
;        4 - control error response
;        5 - control queue behaviour
;        6 - control disconnect/reselects
;   R1 = DeviceID, LUN is "don't care"
;
;   R8 = AccessKey
;
; N.B. AccessKey checking is applied to all reason codes
;
SWI_SCSI_Control
        traceswi "Control"
        AddressCard
        BVS     exitSWIdecode
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}

        BL      ValidateID              ; In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
        ;       R0->"Device ID invalid"
        BLVC    AddressDevice           ; In: R1=DeviceID
        ;Out:   R1=DeviceID, R9->deviceblk
        BVS     exitSWIdecode

        CMP     R0,#maxSCSI_ContRC
        ASSERT  (SCSI_ContRCtable-. =8)  ; Table must follow code
        ADDCC   PC,PC,R0,ASL #2
        B       err_RCunkn

SCSI_ContRCtable
        B       AbortDevice
        B       AbortOp
        B       SetSenseMode
        B       SetTimeOut
        B       ControlErrors
        B       ControlQueue
        B       ControlDisconnects
maxSCSI_ContRC * (.-SCSI_ContRCtable):SHR:2

maxSCSI_Cont_RespRC     EQU 2   ;Highest R2 value for ControlErrors
maxSCSI_Cont_QueuRC     EQU 3   ;Highest R2 value for ControlQueue
maxSCSI_Cont_DiscRC     EQU 2   ;Highest R2 value for ControlDisconnects

;************************************************
;       AbortDevice (SWI SCSI_Control, RC=0)
;************************************************

; Abort the device by sending MESSAGE_ABORT
;
; On entry
;   R0  = 0
;   R1  = DeviceID (DevID, LUN=0)
;
;   R8  = AccessKey
;   R9 -> deviceblk
;
AbortDevice
        tracerc "AbortDevice"
        BL      CheckAccess             ; In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS     exitSWIdecode           ;    VS & R0->"SCSI driver reservation error"

        MOV     R0,#CTL_DOINGABORTDEVICE    ; Try to send MESSAGE_ABORT
        BL      SCSImessage_internal    ; to device (LUN=0)
;
; This should generate an &8E interrupt which allows the message to be sent,
; followed by an &85 interrupt.
;
; N.B. &8E is service required - REQ asserted following connection,
;          MessageOut phase requested),
;      &85 is service required - Disconnection has occured.
;
        B       exitSWIdecode

;************************************************
;       AbortOp (SWI SCSI_Control, RC=1)
;************************************************

; Cancel the specified operation
;
; On entry
;   R0  = 1
;   R1  = DeviceID (DevID, LUN=0)
;   R2  = OperationID as returned by SWI SCSI_Op
;
;   R8  = AccessKey
;   R9 -> deviceblk
;
AbortOp
        tracerc "AbortOp"
        BL      CheckAccess             ; In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS     exitSWIdecode           ;    VS & R0->"SCSI driver reservation error"

        LDR     rCMDptr,CMDptr          ; >>>>is this needed???

        MOV     R1,#CTL_DOINGABORTOP    ; Try to abort,
        BL      RaiseATN                ; if it works, report operation aborted

        B       exitSWIdecode

SetSenseMode ;No longer defined, this RC is reserved
        B       exitSWIdecode

;************************************************
;       SetTimeOut (SWI SCSI_Control, RC=3)
;************************************************

; Set the default timeout for the device
;
; On entry
;   R0  = 3;
;   R1  = DeviceID (DevID, LUN=0)
;   R2  = timeout value in centi-seconds
;
;   R8  = AccessKey
;   R9 -> deviceblk
;
; On exit (VC)
;   StackedR2 = previous setting
;
SetTimeOut
        tracerc "SetTimeOut"
        BL      CheckAccess             ; In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS     exitSWIdecode           ;    VS & R0->"SCSI driver reservation error"

        LDR     R5,ControlTimeout
        STR     R2,ControlTimeout
        STR     R5,StackedR2

        B       exitSWIdecode

;************************************************
;       ControlErrors (SWI SCSI_Control, RC=4)
;************************************************

; Control behaviour on receiving CHECK CONDITION status
;
; On entry
;   R0  = 4;
;   R1  = DeviceID (DevID, LUN=0)
;   R2  = 0  If device returns CHECK CONDITION, return it as an error.
;            This is for badly behaved devices with non-standard request sense
;            return blocks.
;         1  If the device returns CHECK CONDITION do a request sense.
;            Decode and report the error (doesn't hide 'unit attention').
;         2  If the device returns CHECK CONDITION, do a request sense.
;            If the sense data indicates 'unit attention', ignore it and
;            re-issue the command else decode and report the error.
;         -1 No action, return previous setting.
;
;   R8  = AccessKey
;   R9 -> deviceblk
;
; On exit (VC)
;   StackedR2 = previous setting
;
ControlErrors
        tracerc "ControlErrors"
        LDR     R5,ControlBits          ; Ready to be returned as previous value
        CMP     R2,#-1
        BEQ     Cont_Err_10

        BL      CheckAccess             ; In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS     exitSWIdecode           ;    VS & R0->"SCSI driver reservation error"

        CMP     R2,#maxSCSI_Cont_RespRC
        BHI     err_RCunkn

        ASSERT  (maxSCSI_Cont_RespRC = 2)

        CMP     R2,#1
        BIC     R3,R5,#(CTL_INHIBITREQUESTSENSE :OR: CTL_REPORTUNITATTENTION)
        ORRLT   R3,R3,#(CTL_REPORTUNITATTENTION :OR: CTL_INHIBITREQUESTSENSE)
        ORREQ   R3,R3,#(CTL_REPORTUNITATTENTION)
        STR     R3,ControlBits

Cont_Err_10
        MOV     R2,#2
        TST     R5,#CTL_REPORTUNITATTENTION
        MOVNE   R2,#1
        TST     R5,#CTL_INHIBITREQUESTSENSE
        MOVNE   R2,#0
        STR     R2,StackedR2

        B       exitSWIdecode

;************************************************
;       ControlQueue (SWI SCSI_Control, RC=5)
;************************************************

; Control behaviour of the command queue
;
; On entry
;   R0  = 5;
;   R1  = DeviceID (DevID, LUN=0)
;   R2  = 0                        ie If the queue is full, loop in the
;                                     foreground until a slot becomes free.
;         1  Reject if queue full  ie Command accepted only if it can be
;                                     queued/run without waiting.
;         2  Reject if device busy ie Command accepted only if there are no
;            (or queue full)          others queued/running for this device.
;         3  Reject if podule busy ie Accept command only if it will run
;                                    immediatly.
;        -1 No action, return previous setting.
;
;   R8  = AccessKey
;   R9 -> deviceblk
;
ControlQueue
        tracerc "ControlQueue"
        LDR     R5,ControlBits          ; Ready to be returned as previous value
        CMP     R2,#-1
        BEQ     Cont_Que_10

        BL      CheckAccess             ; In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS     exitSWIdecode           ;    VS & R0->"SCSI driver reservation error"

        CMP     R2,#maxSCSI_Cont_QueuRC
        BHI     err_RCunkn

        ASSERT  (maxSCSI_Cont_QueuRC = 3)

        BIC     R3,R5,#(CTL_REJECTQUEUEFULL :OR: CTL_REJECTDEVICEBUSY)
        BIC     R3,R3,#(CTL_REJECTPODULEBUSY)
        CMP     R2,#1
        ORRGE   R3,R3,#CTL_REJECTQUEUEFULL        ; R2 is 1/2/3
        ORRGT   R3,R3,#CTL_REJECTDEVICEBUSY       ; R2 is   2/3
        CMP     R2,#3
        ORRGE   R3,R3,#CTL_REJECTPODULEBUSY       ; R2 is     3
        STR     R3,ControlBits

Cont_Que_10
        MOV     R2,#0
        TST     R5,#CTL_REJECTQUEUEFULL
        MOVNE   R2,#1
        TST     R5,#CTL_REJECTDEVICEBUSY
        MOVNE   R2,#2
        TST     R5,#CTL_REJECTPODULEBUSY
        MOVNE   R2,#3
        STR     R2,StackedR2

        B       exitSWIdecode

;************************************************
;       ControlDisconnects (SWI SCSI_Control, RC=6)
;************************************************

; Allow or inhibit target disconnection/reselection
;
; On entry
;   R0  = 6;
;   R1  = DeviceID (DevID, LUN=0)
;   R2  = 0  Allow the target to disconnect/reconnect if it wants to.
;         1  Inhibit target disconnection/reselection
;         2  Inhibit identify message
;            (for devices like the Hitachi CD-ROM drive that reject it!)
;         -1 No action, return previous setting.
;
;   R8  = AccessKey (already checked)
;   R9 -> deviceblk
;
ControlDisconnects
        tracerc "ControlDisconnects"
        LDR     R5,ControlBits
        CMP     R2,#-1
        BEQ     Cont_Dis_10

        BL      CheckAccess             ; In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS     exitSWIdecode           ;    VS & R0->"SCSI driver reservation error"

        CMP     R2,#maxSCSI_Cont_DiscRC
        BHI     err_RCunkn

        ASSERT  (maxSCSI_Cont_DiscRC = 2)

        LDR     R3,ControlBits
        BIC     R3,R3,#(CTL_INHIBITDISCONNECTION :OR: CTL_INHIBITIDENTIFY)
        CMP     R2,#1
        ORREQ   R3,R3,#CTL_INHIBITDISCONNECTION
        ORRGT   R3,R3,#(CTL_INHIBITDISCONNECTION :OR: CTL_INHIBITIDENTIFY)
        STR     R3,ControlBits

Cont_Dis_10
        MOV     R2,#0
        TST     R5,#CTL_INHIBITDISCONNECTION
        MOVNE   R2,#1
        TST     R5,#CTL_INHIBITIDENTIFY
        MOVNE   R2,#2
        STR     R2,StackedR2

        B       exitSWIdecode


;************************************************
;       SCSI_Status
;************************************************

;
; Returns various status indicators determined by a reason code in R0
;
; On entry
;   R0 = 0 - check device status
;        1 - return last error
;
SWI_SCSI_Status
        traceswi "Status"
        AddressCard
        BVS     exitSWIdecode
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}

        CMP     R0,#maxSCSI_StatRC
        ASSERT  (SCSI_StatRCtable-. =8)  ; Table must follow code
        ADDCC   PC,PC,R0,ASL #2
        B       err_RCunkn

SCSI_StatRCtable
        B       CheckDevice
        B       ReturnLastError

maxSCSI_StatRC * (.-SCSI_StatRCtable):SHR:2

;************************************************
;       CheckDevice (SWI SCSI_Status, RC=0)
;************************************************

; On entry
;   R0 = 0
;   R1 = DeviceID, LUN field is "don't care"
;
; On exit
;   R0 = 1  Idle (No operation in progress, or in queue)
;      = 2  Busy
;
CheckDevice
        tracerc "CheckDevice"
        BL      ValidateID              ; In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
        ;       R0->"Device ID invalid"
        BLVC    AddressDevice           ; In: R1=DeviceID
        ;Out:R1=DeviceID,R9->deviceblk
        BVS     exitSWIdecode

        LDR     R0,PendingCnt
        TEQ     R0,#0
        MOVEQ   R0,#1
        MOVNE   R0,#2
        STR     R0,StackedR0

        B       exitSWIdecode

ReturnLastError
        B       exitSWIdecode

;************************************************
;       SCSI_ReadControlLines
;************************************************

SWI_SCSI_ReadControlLines
        traceswi "ReadControlLines (not supported)"
        B       err_SWIunkn

;************************************************
;       SCSI_EEProm
;************************************************

SWI_SCSI_EEProm
        traceswi "EEProm (not supported)"
        B       err_SWIunkn

;************************************************
;       SCSI_Reserve
;************************************************

; Various device reservation commands determined by a reason code in R0
;
; On entry
;   R0 = 0 - Claim device
;        1 - Forceably claim device
;        2 - Release device
;   R1 = DeviceID, LUN field is "don't care"
;
;   R8 = AccessKey (either key to use after successful claim or
;         key to device being released)
;
SWI_SCSI_Reserve
        traceswi "Reserve"
        AddressCard
        BVS     exitSWIdecode
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}

        BL      ValidateID              ; In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
        ;       R0->"Device ID invalid"
        BLVC    AddressDevice           ; In: R1=DeviceID
        ;Out:R1=DeviceID,R9->deviceblk
        BVS     exitSWIdecode

        CMP     R0,#maxSCSI_ReseRC
        ASSERT  (SCSI_ReseRCtable-. =8)  ; Table must follow code
        ADDCC   PC,PC,R0,ASL #2
        B       err_RCunkn

SCSI_ReseRCtable
        B       ClaimDevice
        B       ForceClaimDevice
        B       FreeDevice
maxSCSI_ReseRC * (.-SCSI_ReseRCtable):SHR:2

;************************************************
;       ClaimDevice (SWI SCSI_Reserve, RC=0)
;************************************************

; Claim exclusive use of device
;
; On entry
;   R0  = 0
;   R1  = DeviceID (DevID, LUN=0)
;   R2  = release address } to be called by ScsiDriver to request claimant to
;   R3  = release R12     } free device, or to warn of reset
;
;   R8  = AccessKey (to be used if claim succeeds)
;   R9 -> deviceblk
;
;
ClaimDevice
        tracerc "ClaimDevice"
        BL      CheckAccess             ; In: R8=AccessKey, R9->deviceblk
        ;Out:VC or
        ;       VS & R0->"SCSI driver reservation error"
        ASSERT  (ReleaseCallAdr+4) = ReleaseCallR12
        ASSERT  (ReleaseCallR12+4) = AccessKey

        ADRVC   R0,ReleaseCallAdr       ; Assign release Adr & R12 and AccessKey if not
        STMVCIA R0,{R2-R3,R8}           ; reserved (or we reserved it already under the
        B       exitSWIdecode           ; same key)

;************************************************
;       ForceClaimDevice (SWI SCSI_Reserve, RC=1)
;************************************************

; On entry
;   R0  = 1
;   R1  = DeviceID (DevID, LUN=0)
;   R2  = release address } to be called by ScsiDriver to request claimant to
;   R3  = release R12     } free device, or to warn of reset
;
;   R8  = AccessKey (to be used if claim succeeds)
;   R9 -> deviceblk
;
ForceClaimDevice
        tracerc "ForceClaimDevice"
        ASSERT  (ReleaseCallAdr+4) = ReleaseCallR12
        ASSERT  (ReleaseCallR12+4) = AccessKey
        ADR     R4,ReleaseCallAdr
        LDMIA   R4,{R4,R5,R6}           ; Current claimants Release Adr & R12 and key
        CMP     R6,#0                   ; If not claimed
        CMPNE   R4,#0                   ; or claiment has no release address,
        BEQ     ClaimDevice             ; let ClaimDevice do the work

;
; R0 ..R9  already pushed,
; R10..R11 don't care
; R12      preserve (to be on the safe side)
; R14      don't care
;
;Ask current claimant to let go
;
        Push    "R1-R3,R8-R9,R12"
        MOV     R0,#1
        MOV     R12,R5
        MOV     Link,PC
        MOV     PC,R4
        Pull    "R1-R3,R8-R9,R12"

        BVC     ClaimDevice             ; VC, so should be free, so ClaimDevice
        B       exitSWIdecode           ; VS, so refused

;************************************************
;       FreeDevice (SWI SCSI_Reserve, RC=2)
;************************************************

; On entry
;   R0  = 2
;   R1  = DeviceID (DevID, LUN=0)
;   R8  = AccessKey (proof that we claimed the device)
;   R9 -> deviceblk
;
FreeDevice
        tracerc "FreeDevice"
        BL      CheckAccess
        MOVVC   R8,#0                   ; If we reserved the device
        STRVC   R8,ReleaseCallAdr       ; (or device not reserved)
        STRVC   R8,ReleaseCallR12       ; 
        STRVC   R8,AccessKey            ; free it.
        B       exitSWIdecode

;************************************************
;       SCSI_List
;************************************************

; On exit
;   R0 -> Null terminated list of podule addresses
;
SWI_SCSI_List
        traceswi "List"
        ADR     R0,ListEntry0
        STR     R0,StackedR0

        B       exitSWIdecode

;************************************************
;       SCSI_Op
;************************************************

; May be called in the background
;
; R0 (ctl)         = b2..b0    device (0..6, 7 is host) }
;                    b4..b3    card                     } targetID
;                    b7..b5    LUN                      }
;                    b25..b24  xfer dirn (00 => no transfer, 01 => read,
;                                         10 => write, 11 => reserved)
;                    b26       scatter (0 => R3->data, 1 => R3->scatter list)
;                    b27       escape (0 => poll for escape during xfer,
;                                      1 => don't poll for escape)
;                    b28       retry (1 => retry on timeout)
;                    b29       background (1 => background part of the xfer)
; R1 (cbd_size)    = length of SCSI CDB (usually 6,10,12 bytes)
; R2 (cdb_ptr)    -> control block
; R3 (xfer_ptr)   -> data         (if R0.b26=0)
;                 -> scatter list (if R0.b26=1)
; R4 (xfer_size)   = length of xfer in bytes
; R5 (timeout)     = timeout in centi-seconds or 0 for default
; R6 (callbackadr) = address to call back when xfer is complete (if R0.b8=1)
; R7 (callbackws)  = workspace pointer to return in R12 for callback
; R8               = AccessKey
;

      [ counts                  ; 0 : 0=> In SCSI_Op Otherwise dont count
MyInfoSpace1   % 72             ; 4 : Count of times entering int_service_01
MyStringSpace1 % 100            ; 8 : Count of times entered StartCommand
      ]                         ; 12: Count of times entered int_ser_202
        ;       16-46 Used for State counts
        ;       52-68 Fillslot variables


SWI_SCSI_Op
        traceswi "Op"

      [ counts                          ; Initialise MyInfoSpace
        Push    "R0-R1"
        ADR     R0, MyInfoSpace1
        MOV     R1, #0
        STR     R1, [R0, #0]
        STR     R1, [R0, #4]
        STR     R1, [R0, #8]
        STR     R1, [R0, #12]
        STR     R1, [R0, #16]
        STR     R1, [R0, #20]
        STR     R1, [R0, #24]
        STR     R1, [R0, #28]
        STR     R1, [R0, #32]
        STR     R1, [R0, #36]
        STR     R1, [R0, #40]
        STR     R1, [R0, #52]
        STR     R1, [R0, #56]
        STR     R1, [R0, #60]
        STR     R1, [R0, #64]
        Pull    "R0-R1"
      ]

        LDR     R1,=&FFFF
        AND     R1,R0,R1

        AddressCard
        BVS     exitSWIdecode
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}

        BL      ValidateID              ; In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
        ;       R0->"Device ID invalid"
        BLVC    AddressDevice           ; In: R1=DeviceID
        ;Out:   R1=DeviceID, R9->deviceblk

      [ counts
        Push    "R0-R2"
        SWI     OS_WriteS
        =       "deviceblk: "
        MOV     R0, R9
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  [0:3]: "
        LDR     R0, [R9, #0]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  [4:7]: "
        LDR     R0, [R9, #4]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  [8:11]: "
        LDR     R0, [R9, #8]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_WriteS
        =       "  [12:15]: "
        LDR     R0, [R9, #12]
        ADRL    R1, MyStringSpace1
        MOV     R2, #100
        SWI     OS_ConvertHex8
        SWI     OS_Write0

        SWI     OS_NewLine
        Pull    "R0-R2"
      ]

        TEQ     R8,#UnixAccessKey       ; Allow UNIX to side step AccessKey checks
        BEQ     KludgeForUnix           ; N.B. V_bit unaltered by TEQ
        BLVC    CheckAccess             ; In: R8=AccessKey, R9->deviceblk
KludgeForUnix                           ;Out:VC or
        ;       VS & R0->"SCSI driver reservation error"
        BVS     exitSWIdecode

        LDR     R0,StackedR0            ; Recover corrupted registers from
        LDR     R1,ControlBits          ; StackedR0..StackedR1, and add stored control
        ORR     R0,R0,R1                ; bits to those already in R0
        LDR     R1,StackedR1
      [ {FALSE}
        TST     R0,#CTL_TXREAD
        ORRNE   R0,R0,#CTL_INHIBITDISCONNECTION :OR: CTL_INHIBITIDENTIFY
      ]
      [ bugfix11
        CMP     R1,#minCDBLen
        BLT     err_ParmError
        CMP     R1,#maxCDBLen
        BGT     err_ParmError
      ]
        ;R5     (timeout) supplied by user
        BL      SCSIop_internal         ; Out: R0-R2 corrupt,R3->Last byte received+1,
        ;       R4=amount untransfered
;
; R0 is preserved if foreground transfer and VC
; R0 is OperationID if background transfer and VC
; R0 is -> if VS
;
        STR     R0,StackedR0
        STRVS   R1,StackedR1            ; } Returned only on error
        STRVS   R2,StackedR2            ; }
        STR     R3,StackedR3
        STR     R4,StackedR4
        ;If     SCSIop_internal returned VS, exitSWIdecode
        B       exitSWIdecode           ; stores R0 to StackedR0, this doesn't matter
;
      [ bugfix11
err_ParmError
        XSCSIError SCSI_ParmError
        B       exitSWIdecode

        MakeSCSIErrorBlock SCSI_ParmError
      ]
;
;
;==============================================================================


    ] ; :LNOT:soft



;
; Initialise the DMAC
;
ResetDMAC
        MOV     R0,#dmac_bits           ; Reset to 8bit mode
        wrDMAC  R0,DR_Initialise
;
        MOV     R0,#ctrl1               ; &60 active low DRQ/DACK, extended write
        wrDMAC  R0,DR_DevCon1
        MOV     R0,#ctrl2               ; &01 bus hold between cycles
        wrDMAC  R0,DR_DevCon2
;
        MOV     R0,#0                   ; Select channel 0 for programming, current
        wrDMAC  R0,DR_Channel           ; registers may be read, current and base
        ;       registers written to simultaneously

        STRB    R0,PR_ClrInt            ; Clear the DMAC Terminal count interrupt
      [ readback
        LDRB    R0,PR_IntStat
      ]

        MOV     PC,Link                 ; Flags preserved across call





INT_wait
        Push    R0
INT_wai_10
        LDRB    R0,SBICauxstat
        TST     R0,#INT
        BEQ     INT_wai_10
INT_wai_20
        Pull    R0
        MOV     PC,Link


DBR_wait
        Push    R0
DBR_wai_10
        LDRB    R0,SBICauxstat
        TST     R0,#DBR
        BEQ     DBR_wai_10
        Pull    R0
        MOV     PC,Link


nCIP_wait
        Push    R0
nCIP_wai_10
        LDRB    R0,SBICauxstat
        TST     R0,#CIP
        BNE     nCIP_wai_10
        Pull    R0
        MOV     PC,Link



; Wait25uSec
; ==========
;
; DoMicroDelay
; ============
;
; On entry
;   R0 = time delay in 1/2 microsecond units
;
; On exit
;   R0 corrupted
;
Wait25uSec
        MOV     R0,#25*2                ; Delay in 1/2 microsecond units
DoMicroDelay
      [ HAL
        Push    "R0-R3,R8,R9,R14"
        MOV     R0,R0,LSR #1
        MOV     R8,#OSHW_CallHAL
        MOV     R9,#EntryNo_HAL_CounterDelay
        SWI     XOS_Hardware
        Pull    "R0-R3,R8,R9,PC",VC
        Pull    "R0-R3,R8,R9,R14"
      ]
        Push    "R1,R2,R14"
        MOV     R2,#IOC
        STRB    R0,[R2, #Timer0LR]      ; Copy counter into output latch
        LDRB    R1,[R2, #Timer0CL]      ; R1 := low output latch
Micro_10
        STRB    R0,[R2, #Timer0LR]      ; Copy counter into output latch
        LDRB    R14,[R2, #Timer0CL]     ; R14 := low output latch
        TEQ     R14,R1                  ; unchanged ?
        MOVNE   R1,R14                  ; copy anyway
        BEQ     Micro_10                ; then loop
        SUBS    R0,R0,#1                ; decrement count
        BNE     Micro_10                ; loop if not finished
        Pull    "R1,R2,PC",AL


;
; ResetCard
;
;
HardResetCard
        LDR     rPODULEptr,=PODULEptrRel     ; except for pointers to hardware
        ADD     rPODULEptr,rPODULEptr,R5
        STR     rPODULEptr,PODULEptr

        LDR     rDMACptr,=DMACptrRel
        ADD     rDMACptr,rDMACptr,R5
        STR     rDMACptr,DMACptr

        LDR     R0,=SRAMptrRel
        ADD     R0,R0,R5
        STR     R0,SRAMptr

      [ soft
        MOV     R1,#-1                  ; Destroy the host id
      |
        MOV     R1,#defaultHostID
      ]
        STR     R1,HostID

SoftResetCard
        Push    Link

        MOV     R0,#RCsoftcopyadr
        MOV     R1,#Pod_EnableInts

      [ No32bitCode
        MOV     R3,R5,LSR #14
        AND     R3,R3,#3                ; Deduce podule number
      |
        ADD     R3,R5,#PoduleSpeedMask  ; Bug in Iyonix - only Sync base accepted
      ]
        SWI     XPodule_CallLoader

        Pull    Link
        LDR     R1,HostID
UserResetCard
        Push    Link

        MOV     R0,#Pod_ForceReset      ; Page 0,interrupts disabled,reset asserted
        wrPageReg R0                    ; ie reset SCSIbus,SBIC & DMAC, hold for >25uS

        BL      ResetWorkSpace          ; Trash any active commands,

        BL      ResetHardware           ; In: R1=HostID
        Pull    "PC"

        LTORG


;
; On entry
;   R0                = 0/1 for partial/full initialisation
;
ResetWorkSpace
        mess    ," - ResetWorkSpace",NL
        Push    "R0,R1,R14"
        MOV     R0,#0
        STR     R0,DEVICEptr            ; Cos MyTickerV looks at it

        LDR     R1,=(:INDEX:ClearWSEnd-4)
RstWoSp_10
        STR     R0,[WsPtr,R1]           ; Zero all our workspace
        SUBS    R1,R1,#4
        CMP     R1,#(:INDEX:ClearWSStart)
        BGE     RstWoSp_10

        LDR     R0,=&0052434D           ; Initialise operationID counter
        STR     R0,OperationID
        LDR     R0,=PAGEBITS            ; SRAM has pages 0..15, mark as unallocated
        STR     R0,RamMap               ; pages 16..31 don't exist, mark as allocated
        LDR     R0,=CMDBITS
        STR     R0,CmdMap
        MOV     R0,#0
        STR     R0,FirstCmd             ; Queue initially empty

        Pull    "R0,R1"
        Push    "R0,R1,rDEVICEptr"

        ASSERT  ((DevCB1-DevCB0) = :INDEX: deviceRecSize)

        MOV     R1,#maxDeviceID
        ADRL    rDEVICEptr,DevCB0
RstWoSp_20
        BL      ClearDevCB

        ASSERT  ((DevCB1-DevCB0) = :INDEX: deviceRecSize)

        ADD     rDEVICEptr,rDEVICEptr,#:INDEX: deviceRecSize
        SUBS    R1,R1,#1
        BGE     RstWoSp_20

        Pull    "R0,R1,rDEVICEptr,PC",AL

        LTORG


;
; On entry
;   R0               = 0/1 for partial/full initialisation
;   R9 (rDEVICEptr) -> deviceCB
;
ClearDevCB
        MOV     R0,#1                   ; >>>Force hard reset for now

        Push    "R1-R3"

        MOV     R1,#0
        MOV     R2,R9                   ; Low (inclusive) limit
        CMP     R0,#0
        ADREQ   R3,SoftClearDevCBEnd    ; Upper (exclusive) limit
        ADRNE   R3,HardClearDevCBEnd
Clr_Dev_10
        STR     R1,[R2],#4
        CMP     R3,R2
        BHI     Clr_Dev_10

        CMP     R0,#0
        BEQ     Clr_Dev_20

    [ :LNOT:soft
      [ disconnect
        ;Zeroed workspace implies allow disconnection
      |
        MOV     R1,#CTL_INHIBITDISCONNECTION
        STR     R1,ControlBits
      ]
    ]
Clr_Dev_20
        Pull    "R1-R3"
        MOV     PC,Link


;
; On entry
;   R1 = HostID
;
ResetHardware
        mess    ," - ResetHardware",NL
        Push    "R0,R1,Link"
        MOV     R0,#Pod_ForceReset      ; Page 0,interrupts disabled,reset asserted
        wrPageReg R0                    ; ie reset SCSIbus,SBIC & DMAC, hold for >25uS


;>>>wait 25uS, by looking at system timer
        BL      Wait25uSec
      [ {TRUE}
        BL      Wait25uSec
      ]

        MOV     R0,#&0                  ; Page 0,interrupts disabled,reset negated
        wrPageReg R0
        STRB    R0,PR_ClrInt            ; Clear the DMAC Terminal count interrupt
      [ readback
        LDRB    R0,PR_IntStat
      ]

        BL      ResetDMAC

      [ {TRUE}
        BL      Wait25uSec
        BL      Wait25uSec
        BL      Wait25uSec
      ]

;
; Set SBIC HostID (requires a soft reset command to be activated)
;
; R1 = HostID
        ORR     R0,R1,#EAF              ; Enable advanced features
        wrSBIC  R0,SR_OwnID             ; Set SBIC HostID (requires a soft reset command
        ;
        MOV     R0,#SC_Reset            ; to be activated)
        wrSBIC  R0,SR_Command

      [ {TRUE}
RstBus05
        LDRB    R0,SBICauxstat
        CMP     R0,#INT
        BNE     RstBus05
      |
        BL      INT_wait                ; Wait until interrupt bit is set in auxiliary
        ;       status register.
        ;       In: R1 is DeviceID,
        BVS     err_BadReset            ; Out: VC or VS and R0->'timeout error'
      ]

        rdSBIC  R0,SR_SCSIstat
        CMP     R0,#HOST_RESET          ; &01 (advanced)

        BNE     err_BadReset            ;         reset cockup
;
        MOV     R0,#(DMAmode :OR: IDI)  ; &24 use SBIC burst DMA mode
        wrSBIC  R0,SR_Control
;
        MOV     R0,#SyncMode            ; &20 REQ/ACK pulse width of 1 cycle
        wrSBIC  R0,SR_SyncXfer
;
        MOV     R0,#SelectTimeout       ; Timeout for Select phase
        wrSBIC  R0,SR_Timeout
;
        MOV     R0,#00
        wrSBIC  R0,SR_TargetLUN
;
; ResetBus command completed successfully
;
      [ soft
        LDR     R0,HostID
        BIC     R0,R0,#DeviceIDMask
        ORR     R1,R0,R1
      ]
        STR     R1,HostID               ; Keep HostID for checking purposes

        MOV     R0,#0
        STRB    R0,PR_ClrInt            ; Clear the DMAC Terminal count interrupt
      [ readback
        LDRB    R0,PR_IntStat
      ]

        BL      ClaimIRQs
      [ useTickerV
        BL      ClaimTickerV
      ]
        MOV     R0,#Pod_EnableInts      ; Interrupts enabled,reset negated,page 0
        wrPageReg R0
      [ readback
        LDRB    R0,PR_IntStat
      ]

        CLRV
        Pull    "R0,R1,PC"

err_BadReset
        Pull    "R0,R1,Link"
        XSCSIError SCSI_BadReset
        MOV     PC,Link

        MakeSCSIErrorBlock SCSI_BadReset



ClaimIRQs
        mess    ," - ClaimIRQs",NL
        Push    "R0-R4,Link"

        MOV     R0,#Podule_DevNo        ; Claim podule IRQ's
        ADRL    R1,int_service
        MOV     R2,WsPtr
        ADR     R3,PR_IntStat
        MOV     R4,#Pod_IRQ
        SWI     XOS_ClaimDeviceVector

      [ HAL
        Push    "R8,R9"
        MOV     R0,#Podule_DevNo
        MOV     R8,#OSHW_CallHAL
        MOV     R9,#EntryNo_HAL_IRQEnable
        SWI     XOS_Hardware
        Pull    "R8,R9"
        BVC     %FT10
      ]
        SETPSR  I_bit+F_bit,R1,,R14        ; Disable IRQs & FIQs
        MOV     R0,#IOC                    ; whilst enabling Podule IRQs
        LDRB    R1,[R0,#IOCIRQMSKB]        ; in IOC
        ORR     R1,R1,#podule_IRQ_bit
        STRB    R1,[R0,#IOCIRQMSKB]
        RestPSR R14,,cf                    ; Restore original state
10
        Pull    "R0-R4,PC",AL


ReleaseIRQs
        mess    ," - ReleaseIRQs",NL
        Push    "R0-R4,Link"

        MOV     R0,#Podule_DevNo        ; Claim podule IRQ's
        ADRL    R1,int_service
        MOV     R2,WsPtr
        ADR     R3,PR_IntStat
        MOV     R4,#Pod_IRQ
        SWI     XOS_ReleaseDeviceVector

        CLRV
        Pull    "R0-R4,PC",AL


      [ useTickerV
ClaimTickerV
        mess    ," - ClaimTickerV",NL
        Push    "R0-R2,Link"
        MOV     R0,#TickerV             ; claim 100Hz Vector
        ADDR    R1,MyTickerV
        MOV     R2,WsPtr
        SWI     XOS_Claim
        Pull    "R0-R2,PC",AL


ReleaseTickerV
        mess    ," - ReleaseTickerV",NL
        Push    "R0-R2,Link"
        MOV     R0,#TickerV
        ADDR    R1,MyTickerV
        MOV     R2,WsPtr
        SWI     XOS_Release
        Pull    "R0-R2,PC",AL
      ]

FreezeHardware
        mess    ," - FreezeHardware",NL
        Push    "R0-R4,Link"
        MOV     R1,#Pod_ForceReset      ; Page 0,interrupts disabled,reset asserted
        wrPageReg R1                    ; ie reset SCSIbus,SBIC & DMAC, hold for >25uS

        MOV     R0,#RCsoftcopyadr
      [ No32bitCode
        MOV     R3,R5,LSR #14           ;
        AND     R3,R3,#3                ; Podule number
      |
        ADD     R3,R5,#PoduleSpeedMask  ; Bug in Iyonix - only Sync base accepted
      ]
        SWI     XPodule_CallLoader

        Pull    "R0-R4,PC",AL


FreezeAndRelease
        Push    R14
        BL      FreezeHardware
      [ useTickerV
        BL      ReleaseTickerV
      ]
        BL      ReleaseIRQs
        Pull    PC



;
; ValidateID
; ==========
;
; Check a DeviceID is 0..7 and <> HostID
;
; On entry
;   R1 = DeviceID
;
; On exit (VC)
;   R1    preserved
;
; On exit (VS)
;   R0 -> "Invalid device ID"
;   R1    preserved
;
ValidateID
      [ bugfix12
        BIC     R1,R1,#LUNIDMask
      ]
        CMP     R1,#maxDeviceID
        BHI     err_BadDevID
        Push    R0
        LDR     R0,HostID
        CMP     R0,R1
        Pull    R0
        RETURNVC NE
err_BadDevID
        XSCSIError SCSI_BadDevID
        MOV     PC,Link

        MakeSCSIErrorBlock SCSI_BadDevID


;
; AddressDevice
; =============
;
; On entry
;   R1 = DeviceID (0..7, <> HostID)
;
; On exit
;   R9 (rDEVICEptr) -> deviceCB
;
AddressDevice
        MOV     R9,#:INDEX:deviceRecSize
        MLA     R9,R1,R9,WsPtr
        ADD     R9,R9,#((:INDEX:DevCB0) :AND: &000000FF)
        ADD     R9,R9,#((:INDEX:DevCB0) :AND: &FFFFFF00)
        MOV     PC,Link


      [ :LNOT:soft
;
; CheckAccess
; ===========
;
; On entry
;   R8 = AccessKey
;   R9 (rDEVICEptr) -> deviceCB
;
; On exit (VC)
;   R8   preserved
;
; On exit (VS)
;   R0 -> "SCSI driver reservation error"
;
CheckAccess
        Push    R0
        LDR     R0,AccessKey
        CMP     R0,#0
        CMPNE   R0,R8
        Pull    R0
        MOVEQ   PC,Link                 ; Not reserved, or reserved and key fits

        XSCSIError SCSI_DevReserved
        MOV     PC,Link

        MakeSCSIErrorBlock SCSI_DevReserved
      ]

      [ soft
FeaturesEntry
        MOV     R1,#2_100010            ; Features mask supported by this driver (see documentation)
        STR     R1,StackedR1
        B       exitEntrydecode

OpEntry
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}
        BL      SCSIop_internal         ; Process the background operation
        trstr   "OpEntry out"
        STRVC   R0,StackedR1
        MOVVC   R0,#-1
        STRVC   R0,StackedR0
        B       exitEntrydecode

; In: R0 = flags
;     R1 = device id
;     R2 = operation handle
AbortOpEntry
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}
        MOV     R1,R0
        BL      RaiseATN
        B       exitEntrydecode

HostDescEntry
        ADRL    R2,HostVendor
        ADD     R3,R2,#HostEnd-HostVendor
10      LDR     R4,[R2],#4
        STR     R4,[R0],#4
        CMP     R2,R3
        BLO     %BT10
        B       exitEntrydecode
      ]

;************************************************
;       SCSIOp_Internal - issue SCSI command
;************************************************

; On entry
;   R0  = b2..b0     device (0..6, 7 is usually host)   }
;         b4..b3     card (AddressCard already called)  } targetID
;         b7..b6     LUN                                }
;         b25..b24   00=no transfer, 01=read, 10=write, 11=reserved
;         b26        scatter bit, if set, R3 is scatter list, not RAM start
;         b27        inhibit escape, if set, don't poll escape during transfer
;         b28        retry bit, if set, repeatedly retry on timeout
;         b29        background bit, set if background part to the transfer
;   R1  = cdb size
;   R2 -> cdb        typically 6,10,12 bytes
;   R3 -> block
;   R4  = block size
;   R5  = T.B.A.
;   R6  = T.B.A.
;   R7  = T.B.A.
;
; On exit
;   R0..R2 preserved
;   R3 -> end of block+1 (based on actual number of bytes transfered)
;   R4  = Number of bytes NOT transfered
;
; Entered in SVC_mode, enables interrupts.
;
      [ trace
MyStringBuff2 % 16
      ]

SCSIop_internal

      [ {FALSE}
        TST     R0,#CTL_TXWRITE
        ORRNE   R0,R0,#CTL_INHIBITDISCONNECTION
      ]
        mess    ,"SCSIop_internal",NL

        SUB     StkPtr,StkPtr,#4
        Push    "R0-R2,Link"

        CLRPSR  I_bit,Link,,R1          ; To give queued commands a chance to run
        STR     R1,[StkPtr,#16]

      [ trace
        Push    "R0-R2"
        SWI     OS_WriteS
        =       "R0="
        ADR     R1, MyStringBuff2
        MOV     R2, #16
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_WriteS
        =       ", R3="
        ADR     R1, MyStringBuff2
        MOV     R2, #16
        MOV     R0, R3
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_WriteS
        =       ", R4="
        ADR     R1, MyStringBuff2
        MOV     R2, #16
        MOV     R0, R4
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_NewLine
        Pull    "R0-R2"
      ]

        AND     R1,R0,#maxDeviceID
        BL      AddressDevice           ; In: R1=DeviceID
      [ :LNOT:soft
        TST     R0,#CTL_REJECTPODULEBUSY
        BLNE    TestPoduleBusy

        TST     R0,#CTL_REJECTDEVICEBUSY
        BLNE    TestDeviceBusy

        TST     R0,#CTL_REJECTQUEUEFULL
        BLNE    TestQueueFull
      ]
;  Push "R0-R7,R9-R11"
op_intl_01
        BL      AllocateCMDslot         ; Out: rCMDptr-> block or rCMDptr=0
        TEQ     rCMDptr,#0
      [ soft
        SCSIError SCSI_QueueFull,EQ
        BEQ     op_intl_104             ; Return immediately if busy (the SCSI switcher will queue this for us)
      |
        BEQ     op_intl_01              ; Loop until a command slot can be claimed
      ]
;  Pull "R0-R7,R9-R11"

        ASSERT  (CmdXferPtr + 4 = CmdXferLen)
      [ soft
        ASSERT  (CmdXferLen + 4 = CmdCallbackR5)
        ASSERT  (CmdCallbackR5 + 4 = CmdCallbackAdr)
      |
        ASSERT  (CmdXferLen + 4 = CmdTimeout)
        ASSERT  (CmdTimeout + 4 = CmdCallbackAdr)
      ]
        ASSERT  (CmdCallbackAdr + 4 = CmdCallbackR12)
        ASSERT  (R8 = rCMDptr )

        LDR     R0,StackedR0
        TST     R0,#(CTL_TXREAD :OR: CTL_TXWRITE)
        MOVEQ   R4,#0                   ; Zero CmdXferLen if no data xfer

        TEQ     R4,#0                   ; Kill read/write bits if CmdXferLen=0
        BICEQ   R0,R0,#(CTL_TXREAD :OR: CTL_TXWRITE)

        ADR     R1,CmdCallbackR12

      [ :LNOT:soft
        TEQ     R5,#0                   ; If user requested default timeout
        LDREQ   R5,ControlTimeout       ; load it
      ]

        STMDA   R1,{R3,R4,R5,R6,R7}     ; CmdXferPtr,CmdXferLen,CmdTimeout,CmdCallbackAdr,CmdCallbackR12
        LDR     R1,StackedR1            ; CDBLen
        LDR     R2,StackedR2            ; ->CDB
        ADR     R3,CmdCDB
        STMDB   R3,{R0,R1}              ; CmdDevID,CmdCDBLen

op_intl_03
        LDRB    R4,[R2],#1              ; Copy CDB to CmdCDB
        STRB    R4,[R3],#1
        SUBS    R1,R1,#1
        BGT     op_intl_03

        MOV     R1,#WAITING
        STR     R1,CmdStat              ; Cmd waiting to start execution

        LDR     R2,CmdOpID              ; CmdOpID, needed so escape can abort us

      [ soft
        STR     R2,StackedR0            ; return CmdOpID to user, incase he needs it
      |
        TST     R0,#CTL_BACKGROUND      ; If command will run in the background,
        STRNE   R2,StackedR0            ; return CmdOpID to user, incase he needs it
        BNE     op_intl_105             ; to call AbortOp, then Skip ...

; If the command 'runs-in-the-foreground', set up a CallBackHandler that
; indicates command completion by filling in a block on the stack, we
; poll this block in the foreground, waiting for the command to complete.

        ADR     R1,CallBackHandler
        STR     R1,CmdCallbackAdr
        SUB     StkPtr,StkPtr,#CallBkRecSize
        STR     StkPtr,CmdCallbackR12

        MOV     R1,#RUNNING
        STR     R1,[StkPtr,#CallBkStat]
      ]

op_intl_105
        BL      QueueCMDslot            ; Queue it
        BL      StartCommand            ; Try to start it
;
;Assume R0 intact, don't load from stack, cos we may have pushed a CallBk block
;
    [ :LNOT:soft ; operations will always be background in the soft case
        TST     R0,#CTL_BACKGROUND
        BNE     op_intl_102
;
; If our command is the first one in the queue, it should have been started.
; If not the first in the queue, it may have started, if all earlier commands
; are running but are in a disconnected state.
; If not, it will start under interrupt, when all the commands infront of it
; complete or disconnect.
;
        ;LDR    R0,CmdDevID
        ;LDR    R2,CmdOpID              ; Our OpID, needed so escape can abort us

op_intl_04
      [ doEscapeCheck
;
; R0 holds CmdDevID, if this indicates escape checks are enabled AND not
; already doing abort-due-to-escape, call TestEscapeStatus.
; If escape is clear, this returns quickly (registers preserved)
; If escape is set, this ATTEMPTS to raise ATN to abort the command, it
; returns with all registers preserved, except R0 which has
; CTL_DOINGESCAPEDEVICE set.
; R2 holds CmdOpID, needed to abort the command.
;
; Sometime later, the device MIGHT respond to our ATN and MIGHT stop
;
        TST     R0,#CTL_NOESCAPE
        TSTEQ   R0,#CTL_DOINGESCAPEDEVICE
        BLEQ    TestEscapeStatus        ; R0=CmdDevID,R2=CmdOpID
        ;May    set CTL_DOINGESCAPEDEVICE in R0
      ]
        LDR     R1,[StkPtr,#CallBkStat]
        CMP     R1,#RUNNING             ; So loop until our command completes
        BEQ     op_intl_04

        CMP     R1,#ERROR

        ASSERT  (CallBkR0 = 0)
        ASSERT  (CallBkR1 = CallBkR0 + 4)
        ASSERT  (CallBkR2 = CallBkR1 + 4)
        ASSERT  (CallRtR3 = CallBkR2 + 4)
        ASSERT  (CallRtR4 = CallRtR3 + 4)

        LDMIA   StkPtr,{R0,R1,R2,R3,R4}   ; CallBkR0..R2, CallRtR3..R4

        ADD     StkPtr,StkPtr,#CallBkRecSize        ; Remove block from stack

        STREQ   R0,StackedR0            ; If error occured, pass back ->error
        STREQ   R1,StackedR1            ; its cause
        STREQ   R2,StackedR2            ; and logical block address

        BEQ     op_intl_106
    ] ; :LNOT:soft

op_intl_102
        LDR     R0,[StkPtr,#16]
        BIC     R0,R0,#V_bit
        RestPSR R0,,cf
        Pull    "R0-R2,Link",AL
        ADD     StkPtr,StkPtr,#4
        MOV     PC,Link


op_intl_104
        STR     R0,StackedR0
op_intl_106
        LDR     R0,[StkPtr,#16]
        ORR     R0,R0,#V_bit
        RestPSR R0,,cf
        Pull    "R0-R2,Link",AL
        ADD     StkPtr,StkPtr,#4
        MOV     PC,Link

      [ :LNOT:soft
TestPoduleBusy
        Push    "R2,R3"
        LDR     R2,CmdMap
        LDR     R3,= CMDBITS
        CMP     R2,R3
        Pull    "R2,R3"
        MOVEQ   PC,Link
        XSCSIError SCSI_QueueNotEmpty
        B       op_intl_104

TestDeviceBusy
        Push    R2
        LDR     R2,PendingCnt
        TEQ     R2,#0
        Pull    R2
        MOVEQ   PC,Link
        XSCSIError SCSI_NotIdle
        B       op_intl_104

TestQueueFull
        Push    R2
        LDR     R2,CmdMap
        TEQ     R2,#0
        Pull    R2
        MOVNE   PC,Link
        XSCSIError SCSI_QueueFull
        B       op_intl_104


        MakeSCSIErrorBlock SCSI_QueueNotEmpty
        MakeSCSIErrorBlock SCSI_QueueFull

err_NotIdle
        XSCSIError SCSI_NotIdle
        B       exitSWIdecode

        MakeSCSIErrorBlock SCSI_NotIdle
      ] ; LNOT:soft

;************************************************
;       SCSImessage_internal - issue SCSI message
;************************************************

; On entry
;   R0  = Reason for message CTL_DOINGRESET       (send MESSAGE_BUSDEVICERESET)
;                            CTL_DOINGABORTDEVICE (send MESSAGE_ABORT)
;   R1  = DeviceID (DevID, LUN)
;
;   R8  = AccessKey
;
SCSImessage_internal
        Push    "R0,Link"

        ORR     R0,R0,R1
        ORR     R0,R0,#CTL_MessageOnly
        ADRL    R2,cdb_inquiry_notransfer
        LDR     R1,[R2],#4              ; CDB length, R2 now->CDB
        MOV     R4,#0                   ; Xfer count=0
        MOV     R5,#0                   ; Default timeout
        MOV     R6,#0                   ; CallbackAdr } ie don't call us
        MOV     R7,#0                   ; CallbackR12 }
        BL      SCSIop_internal

        CLRV
        Pull    "R0,PC",AL

;************************************************
;       Callback handler
;************************************************

; On entry (VC)
;   R3  -> end of block+1 (based on actual number of bytes transfered)
;   R4   = Number of bytes NOT transfered
;   R12 -> Callbackworkspace
;
; On entry (VS)
;   R0  -> Static error message
;   R1   = Error number
;   R2   = Logical device address where error occured
;   R3  -> end of block+1 (based on actual number of bytes transfered)
;   R4   = Number of bytes NOT transfered
;   R12 -> Callbackworkspace
;
; On exit
;   R5 corrupt
;
CallBackHandler
        ASSERT  (CallBkR1 = CallBkR0 + 4)
        ASSERT  (CallBkR2 = CallBkR1 + 4)
        ASSERT  (CallRtR3 = CallBkR2 + 4)
        ASSERT  (CallRtR4 = CallRtR3 + 4)
        ASSERT  (CallBkStat = CallRtR4 + 4)

        MOVVC   R5,#IDLE
        MOVVS   R5,#ERROR
        STMIA   R12,{R0,R1,R2,R3,R4,R5}
        MOV     PC,Link

;************************************************
;       StartCommand - Try sending the next queued SCSI command to the Target
;************************************************

; May be called in:
;   IRQ_mode - on completion/disconnection of the current command to start
;              another running.
;   SVC_mode - to try and start the recently queued command.
;
; On entry IRQs are disabled. Care must be taken with R14 as enabling IRQs
; whilst in IRQ_mode will corrupt it.
;
;>>>Must mark the command as INITIALISING, incase a target reconnects whilst
;>>> we are copying (CTL_TXWRITE set), initialising DMAC or SBIC. This prevents
;>>> the disconnection/completion of that target from trying to start
;>>> us again (or starting someone after us in the chain).
;
StartCommand

      [ counts
        Push    "R0-R1"
        ADRL    R0, MyInfoSpace1
        LDR     R1, [R0, #8]
        ADD     R1, R1, #1
        STR     R1, [R0, #8]

        LDR     R1, SBICStat
        ADD     R0, R0, #40             ; Error count !!
        CMP     R1, #IDLE
        SUBEQ   R0, R0, #24
        CMP     R1, #RUNNING
        SUBEQ   R0, R0, #20
        CMP     R1, #STALLED
        SUBEQ   R0, R0, #16
        CMP     R1, #WAITING
        SUBEQ   R0, R0, #12
        CMP     R1, #INITIALISING
        SUBEQ   R0, R0, #8
        CMP     R1, #INITIALISED
        SUBEQ   R0, R0, #4
        LDR     R1, [R0, #0]
        ADD     R1, R1, #1
        STR     R1, [R0, #0]
        Pull    "R0-R1"
      ]

        Push    "R0-R11,Link"           ; >>>Overkill
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}  ; R10,R11

        trstr   "StartCommand POD="
        trhex   rPODULEptr
        trstr   " DMAC="
        trhex   rDMACptr
        trstr   "  "

        SETPSR  I_bit,R0,,Link
        Push    Link

        LDR     R0,Lockout
        TEQ     R0,#0
        BNE     St_Cmd_40

        LDRB    R0,SBICauxstat
        TST     R0,#INT
        BNE     St_Cmd_40

        MOV     R0,#Pod_EnableInts      ; Incase some ASS-HOLE has poked our page
        wrPageReg R0                    ; register and left our ints disabled

        BL      NextCommand
        TEQ     rCMDptr,#0
        BEQ     St_Cmd_40               ; None, so return

        LDR     R0,CmdDevID             ; Composite of DeviceID & Rd/Wr/Bk bits
        AND     R1,R0,#maxDeviceID
        BL      AddressDevice           ; In: R1=DeviceID
        ;Out:   R1=DeviceID, R9->deviceblk
      [ bugfix6
      |
        STR     R9,DEVICEptr            ; Register device with interrupt handler
      ]
        STR     rCMDptr,CMDptr          ; Register the command with this device

        trstr   "Starting "

        LDR     R2,CmdStat
        CMP     R2,#INITIALISED
        BEQ     St_Cmd_10


;
; Mark the command block as INITIALISING, this is incase we are interrupted
; later on (usually whilst writing data to SRAM) by a target reconnecting.
; When this target disconnects again, causing a call to StartCommand this
; will cause a return to allow our INITIALISING command to continue, rather
; than attempting to start it again.
;
        MOV     R2,#INITIALISING
        STR     R2,CmdStat

        ASSERT  ((CmdXferPtr + 4) = CmdXferLen)
      [ soft
        ADR     R2,CmdXferPtr
        LDMIA   R2,{R3,R4}              ; CmdXferPtr,CmdXferLen
      |
; Examine CTL_DOINGREQUESTSENSE bit,
;  if clear, we are issueing the CDB held in CmdCDB,
;  if set, the SCSI command gave CHECK CONDITION and we are
;          doing a REQUEST SENSE to find out why.

        TST     R0,#CTL_DOINGREQUESTSENSE

        ASSERT  ((CmdXferPtr + 4) = CmdXferLen)
        ADREQ   R2,CmdXferPtr
        LDMEQIA R2,{R3,R4}              ; CmdXferPtr,CmdXferLen

        ADRNE   R3,SenseBlk
        MOVNE   R4,#REQUESTSENSE_BLK_SIZE
        BICNE   R0,R0,#(CTL_TXWRITE :OR: CTL_SCATTER)
        ORRNE   R0,R0,#CTL_TXREAD
      ]

        STR     R0,CpyCtl
        STR     R3,CpyAdr
        STR     R4,CpyCnt               ; Trying to Xfer R4 bytes
        STR     R4,CurrTtlCnt           ; 

      [ soft
        STR     R3,CurrScatPtr
      |
        TST     R0,#CTL_SCATTER         ; If scatter list supplied,
        STRNE   R3,CurrScatPtr          ; save pointer to it
        ADREQ   R5,FakeScatterAdr       ; else
        STMEQIA R5,{R3,R4}              ; fake one using supplied addr & len
        STREQ   R5,CurrScatPtr          ; 
      ]

        MOV     R4,#0                   ; Zero CurrEntCnt to force FillSlot to get
        STR     R4,CurrEntCnt           ; first (may be Fake) scatter list entry

      [ :LNOT:soft
        LDR     R4,CmdTimeout           ; Prepare the timeout counter
        STR     R4,Timeout              ; (runs only if select phase succeds)
      ]

        MOV     R5,R0                   ; Leave CpyCtl in R5

      [ {TRUE}
;>>>
;>>>Might be better to initialise the Saved pointers
;>>>and start the dmac running by calling RestoreCurrentPointers
;>>>but this will do for now

        Push    "R1-R4"
        LDR     R1,CurrScatPtr
        LDR     R2,CurrEntAdr
        LDR     R3,CurrEntCnt
        LDR     R4,CurrTtlCnt

        STR     R1,SavdScatPtr
        STR     R2,SavdEntAdr
        STR     R3,SavdEntCnt
        STR     R4,SavdTtlCnt
        Pull    "R1-R4"
      ]
      [ debug
        MOV     R3,#-1
        STR     R3,TargStat
        STR     R3,HostStat
        STR     R3,HostStat1
        STR     R3,HostStat2
        STR     R3,HostStat3
        STR     R3,HostStat4
        STR     R3,HostStat5
        STR     R3,HostStat6
        STR     R3,HostStat7
      |
        MOV     R3,#-1
        STR     R3,TargStat
        STR     R3,HostStat
        STR     R3,HostStat1
      ]

      [ bugfix2
        MOV     R3,#0                   ; For now, all messages (out) are allowed
        STR     R3,Suppress             ; 
      ]
        MOV     R3,#MESSAGE_NOOPERATION
        STR     R3,MessageIn            ; Safe values
        STR     R3,MessageOut           ;

        MOV     R3,#:INDEX:Queue0       ; Queue empty
        STR     R3,QStart
        STR     R3,QEnd



; Initial states
;           NoXfer,  Read,    Write
; DeviStat  RUNNING  RUNNING  RUNNING
; SBICStat  RUNNING  RUNNING  RUNNING
; DMACStat  IDLE     RUNNING  STALLED
; CopyStat  IDLE     STALLED  RUNNING

        MOV     R3,#RUNNING
        STR     R3,DeviStat
        STR     R3,SBICStat

        MOV     R3,#IDLE
        STR     R3,DMACStat
        STR     R3,CopyStat

        TST     R5,#(CTL_TXREAD :OR: CTL_TXWRITE)
        BEQ     St_Cmd_10

;
; If reading or writing, claim a pageslot and initialise it
;
        MOV     R3,#STALLED
        STR     R3,CopyStat
        STR     R3,DMACStat

;
; R1  = DeviceID (TargetID)
; R9 -> DeviceBlk
;
; R3,R4 temp


        TST     R5,#CTL_TXWRITE
        BNE     St_Cmd_05
;
; Reading - claim a page of SRAM for the DMAC to fill
;
        BL      AllocateRAM             ; Out CC & R7 (rPAGESLOTptr) ->RamRec
        ;BCS    help                    ;    CS for failed
        trstr   "Allocated "

        STR     R7,DMACram              ; DMAC will queue this when its full
        BL      FillSlot                ; In/Out: R7->RamRec
        B       St_Cmd_10

;
; Writing - claim a page and fill it
;
St_Cmd_05
    [ {TRUE}
      [ {TRUE}
        Push    "R1-R4"
        LDR     R1,CurrScatPtr
        LDR     R2,CurrEntAdr
        LDR     R3,CurrEntCnt
        LDR     R4,CurrTtlCnt
        STR     R1,FutrScatPtr
        STR     R2,FutrEntAdr
        STR     R3,FutrEntCnt
        STR     R4,FutrTtlCnt
        Pull    "R1-R4"
        ADR     R7,DemandSlot
        BL      FillSlot
      ]

        MOV     R0,#STALLED             ; STALL copier so that PreWriteBlk
        STR     R0,CopyStat             ; will work

        BL      PreWriteBlk
        ;BCS    help                    ;    CS for failed
        BL      UnQueueSlot
        STR     R7,DMACram              ; First block given to DMAC
    |
        BL      AllocateRAM             ; Out CC & R7 (rPAGESLOTptr) ->RamRec
        ;BCS    help                    ;    CS for failed

        STR     R7,DMACram              ; First block given to DMAC
        BL      FillSlot                ; In/Out: R7->RamRec
;
; Writing, copy the first block to SRAM
;
        MOV     R0,#RUNNING
        STR     R0,CopyStat
        BL      WriteBlkToSRAM          ; Write block to SRAM. In R8->Slot
        ;       IRQs enabled whilst copying

        LDR     R0,CurrTtlCnt           ; If no more data to copy,
        TEQ     R0,#0
        MOVEQ   R0,#IDLE                ; IDLE the copier
        MOVNE   R0,#STALLED             ; else STALL it
        STR     R0,CopyStat
        ;>>>    BL QueueSlot            ; In: R7=SlotNum(0..15)
    ]

;
; Command fully initialised, ie RAM pages claimed & copied etc. so mark command
; block as INITIALISED. Try to Load the command into the SBIC & perform a
; Select_And_Tranfer. This may fail, due to reselection of the SBIC by
; target. If it does, give up, leaving the command marked as initialised, so
; that a future call to StartCommand will pick up from this point.
;

St_Cmd_10
        trstr   "Initialised "
        LDR     R5,CpyCtl
        LDR     R7,DMACram

        LDR     rCMDptr,CMDptr
        MOV     R0,#INITIALISED
        STR     R0,CmdStat

        LDRB    R0,SBICauxstat
        TST     R0,#INT
        BNE     St_Cmd_40
;
; SBIC seems to be free, so, ArmDMAC (if data in/out phase required),
; load the SBIC registers and issue a Select-And-Transfer command.
;
; Since IRQs are disabled, if a target re-connection occurs, the SBIC LCI
; (last command ignored) bit will be set and can be tested for, rather than
; allowing an interrupt when the SBIC registers are partially loaded.
;

        AND     R0,R5,#(CTL_TXREAD :OR: CTL_TXWRITE)
        CMP     R0,#CTL_TXREAD

        MOVEQ   R0,#dma_rd_mode         ; &04 demand mode,read
        ORREQ   R1,R1,#DPD              ; &40 Data Phase Direction is read
        MOVGT   R0,#dma_wr_mode         ; &08 demand mode,write

        BLGE    ArmDMAC                 ; In/Out: R7->RamRec

      [ bugfix12
        LDR     R0,CmdDevID
        AND     R0,R0,#LUNIDMask
        MOV     R0,R0,LSR #LUNIDShft
      |
        MOV     R0,#0
      ]
        wrSBIC  R0,SR_TargetLUN

        TST     R5,#CTL_INHIBITDISCONNECTION
        MOVNE   R0,#0
        MOVEQ   R0,#ER                  ; &80
        wrSBIC  R0,SR_SourceID
        wrSBIC  R1,SR_DestID            ; Setup TargetID and DPD

        LDR     rCMDptr,CMDptr
        BL      LoadCDBregisters        ; In R5=CpyCtl, corrupts R0,R2,R3

        LDR     R4,CpyCnt
        wrSBIC24 R4,SR_Count            ; Write Total Transfer count to SBIC

        MOV     R0,#0                   ; Ensure any SAT command starts from the
        wrSBIC  R0,SR_Phase             ; beginning (cos <>0 implies Resume-SAT)

        TST     R5,#CTL_INHIBITIDENTIFY
        MOVNE   R0,#SC_Sel_Tx_woATN
        MOVEQ   R0,#SC_Sel_Tx_withATN

        TST     R5,#(CTL_DOINGRESET :OR: CTL_DOINGABORTDEVICE)
        MOVNE   R0,#SC_Sel_withATN
        wrSBIC  R0,SR_Command

;
; If the Select-And-Transfer command was issued prior to or concurrent with
; a pending interrupt, the command is ignored, and the LCI bit set.
; In this case, leave the command block marked as INITIALISED and exit,
; as soon as interrupts are re-enabled, the SBIC interrupt will occur and be
; processed. A later call to StartCommand will allow this command to resume.
;
; NOTE there is a SBIC bug, sometimes the LCI bit is not set even though
;      the command is ignored. See comments in interrupt (&81) handler.
;
        LDRB    R0,SBICauxstat          ; 
        TST     R0,#LCI
        BNE     St_Cmd_40


        MOV     R0,#1                   ; Any non-zero value
        STR     R0,Connected            ; We are now (probably) connected to Target
        STR     R0,Lockout

        MOV     R0,#RUNNING
        STR     R0,CmdStat


      [ bugfix6
        STR     R9,DEVICEptr            ; Register device with interrupt handler
      ]

      [ {FALSE}
        TST     R5,#CTL_TXWRITE         ; Try copying & queueing the next block
        BLNE    PreWriteBlk             ; before the DMAC demands it
      ]
St_Cmd_40
        trstr   "StartCommand out "
        Pull    Link
        RestPSR Link,,cf
        Pull    "R0-R11,PC",AL

;************************************************
;       Interrupt service routine
;************************************************

; Interrupt sources are:
;   DMAC terminal count
;   SBIC interrupt
;
; On entry - in IRQ_mode with IRQs disabled.
;   R3  -> IOC
;   R12 -> WorkSpace
;
; May corrupt R0..R3,R12
;
; May reenable IRQs whilst copying to/from SRAM.
;
int_service
        Push    "R0-R11,Link"
        LDMIA   WsPtr,{rDEVICEptr, rPODULEptr,rDMACptr}  ; R9,R10,R11
        LDRB    R0,PR_IntStat
        TST     R0,#SB_IRQ
        BNE     int_service_SBIC        ; Interrupt from SBIC

        TST     R0,#TC_IRQ
        BEQ     int_ser_200             ; Not interrupting
;
; Terminal count interrupt from DMAC
;
        LDR     rCMDptr,CMDptr

        MOV     R0,#0
        STRB    R0,PR_ClrInt            ; Clear the DMAC Terminal count interrupt
        MOV     R0,#set_mask
        wrDMAC  R0,DR_Mask
      [ readback
        LDRB    R0,PR_IntStat
      ]

        LDR     R0,CpyCtl
        TST     R0,#CTL_TXWRITE
        BNE     int_DMAC_TC_Writing
        TST     R0,#CTL_TXREAD
        BEQ     int_ser_100

;************************************************
;       Terminal Count interrupt from DMAC (Reading)
;************************************************

int_DMAC_TC_Reading
        LDR     R7,DMACram              ; Advance current pointers by amount
        BL      AdvanceCurrentPointers  ; just transfered.       In R7->RamRec
        BL      QueueSlot               ; Queue block for copier  In R7->RamRec
      [ efficient
      |
        MOV     R7,#-1
        STR     R7,DMACram
      ]
        MOV     R0,#STALLED             ; DMAC completed a page, stall for now, maybe
        STR     R0,DMACStat             ; able to restart it

int_TC_rd_10
        ;Either stalled by above, or under interrupt
        ;       whilst in copier, below

        LDR     R0,SBICStat             ; If SBIC has stopped
        CMP     R0,#IDLE                ; (if not, & CurrTtlCnt=0, leave stalled
        ;       incase of data overrun)
        MOVEQ   R0,#IDLE
        STREQ   R0,DMACStat             ; stop the DMAC, the data in SRAM needs
        BEQ     int_TC_rd_20            ; to be copied to MainRAM

; Allocate another SRAM page
;   If MainRam to SRAM copier is faster than SCSI via DMAC copying then
;     there should be a free page
;   else
;     there may not be a free page, so freeze the DMAC until the copier
;     frees one
;
        BL      AllocateRAM             ; Out CC & R7 (rPAGESLOTptr) ->RamRec
        BCS     int_TC_rd_20            ;    CS for failed

        STR     R7,DMACram              ; DMAC will queue this when its full

        BL      FillSlot                ; In/Out: R7->RamRec

        MOV     R0,#dma_rd_mode
        BL      ArmDMAC                 ; In/Out: R7->RamRec

int_TC_rd_20
        LDR     R0,CopyStat             ; If already running, return to it
        CMP     R0,#RUNNING             ; else copy next queued block
        BEQ     int_TC_rd_40            ; 

int_TC_rd_30
        BL      ReadBlkFromSRAM         ; IRQs enabled whilst copying, disabled on exit

        LDR     R0,DMACStat             ; If DMAC interrupted whilst in ReadBlkFromSRAM
        CMP     R0,#STALLED             ; it may have been stalled, if so loop back
        BEQ     int_TC_rd_10            ; to try to restart it

        LDR     R0,QStart
        LDR     R1,QEnd
        CMP     R0,R1                   ; If queue not empty, loop back to copy another
        BNE     int_TC_rd_30            ; page

        LDR     R0,DMACStat             ; Queue empty & DMAC finished means no more data
        CMP     R0,#IDLE
        STREQ   R0,CopyStat             ; so stop copier

int_TC_rd_40
        B       int_ser_100


;************************************************
;       DMAC terminal count whilst writing data to SBIC
;************************************************

int_DMAC_TC_Writing
        Push    "R0-R11,Link"           ; >>>Overkill

        MOV     R0,#STALLED             ; Stall DMAC, may be able to restart it if
        STR     R0,DMACStat             ; enough slots in queue

        LDR     R7,DMACram              ; Advance current pointers by amount
        BL      AdvanceCurrentPointers  ; just transfered. In R7->RamRec
        BL      DeAllocateRAM           ; and dispose of the completed block
      [ efficient
      |
        MOV     R7,#-1
        STR     R7,DMACram
      ]
        BL      Restart_DMAC_Writing
        Pull    "R0-R11,Link"           ; >>>Overkill
        B       int_ser_100


      [ bugfix13
;
; Called from int_DMAC_TC_Writing with:
;  DMACStat = STALLED
;
;
; Called from RestoreCurrentPointers with:
;  DMACStat = STALLED
;  CopyStat = RUNNING or STALLED
;
Restart_DMAC_Writing
        Push    "R0-R11,Link"           ; >>>Overkill    ;>>>>> DMACStat WILL BE STALLED
;        LDR R0,DMACStat                         ;>>>>>
;        CMP R0,#STALLED                         ;>>>>>
;        BNE int_TC_wr_25                        ;>>>>> so branch never executes - should be BNE int_TC_wr_30???

int_TC_wr_10
        LDR     R0,QStart               ; If data has been queued (ie already
        LDR     R1,QEnd                 ; copied to SRAM)
        CMP     R0,R1                   ;
        BNE     int_TC_wr_20            ; try giving it to the DMAC

;
; Queue empty
;
        LDR     R0,CopyStat             ; If CopyStat=IDLE Stop the DMAC
        CMP     R0,#IDLE
        STREQ   R0,DMACStat

        ;LDR    R0,CopyStat
        CMP     R0,#STALLED             ; Interrupted the copier, so return, when copier
        BNE     int_TC_wr_30            ; finishs, it will see the stalled DMAC and
        ;       restart it. >>>>combine with above 3 lines


; Queue empty, copier stalled.
; Copy CurrentPointers into FuturePointers to ensure PreWriteBlk
; gives us the required data.
;
        ASSERT  PtrRecSize=16

        ADR     R0,CurrentPointers
        LDMIA   R0,{R1,R2,R3,R4}
        ADR     R0,FuturePointers
        STMIA   R0,{R1,R2,R3,R4}

        BL      PreWriteBlk

        LDR     R0,DMACStat
        CMP     R0,#STALLED
        BEQ     int_TC_wr_10            ; Loop back to check if PreWriteBlk queued anything
        BNE     int_TC_wr_30            ; Give up and go home

;
; Queue not empty - Restart DMAC
;
int_TC_wr_20
        ADR     R7,DemandSlot           ; RamTxAdr & RamBlkSz that the DMAC wants
        BL      FillSlot                ; so lets see what's been copied to SRAM

        BL      UnQueueSlot             ; Out: R7->RamRec
        STR     R7,DMACram              ; DMAC will DeAllocate this when its empty

; If unqueued data is from wrong address, deallocate the block and loop back
;  to call PreWriteBlk or UnQueue until something suitable arrives.
;
; The normal cause of a mismatch between data wanted and data available is the
; receipt of a MESSAGE_RESTOREDATAPOINTER or the implied restore-data-pointers
; that occurs upon target re-selection.
;
;>>>Current acceptance test is harsh ie
;>>> fail := (RamTxAdr<>CurrEntAdr) OR (RamBlkSz>CurrEntCnt)
;>>>
;>>> we could adjust RamTxAdr & RamBlkSz if CurrEntAdr falls between
;>>> RamTxAdr..(RamTxAdr+RamBlkSz)
;>>>
        LDMIA   rPAGESLOTptr,{R0,R1}      ; RamTxAdr,RamBlkSz

        LDR     R4,DemandSlot+:INDEX:RamTxAdr
        LDR     R5,DemandSlot+:INDEX:RamBlkSz

        CMP     R0,R4                   ; If RamTxAdr<>CurrEntAdr
        BLNE    DeAllocateRAM           ; 
        BNE     int_TC_wr_10            ; 
        CMP     R1,R5                   ; or RamBlkSz>CurrEntCnt
        BLGT    DeAllocateRAM           ; ditch the block
        BGT     int_TC_wr_10            ; loop back to look for a better one

;
; UnQueued block OK, so Restart the DMAC
;
        MOV     R0,#dma_wr_mode         ; Restart the DMAC in write mode
        BL      ArmDMAC                 ; In/Out: R7->RamRec

int_TC_wr_25
        BL      PreWriteBlk

        LDR     R0,DMACStat             ; If DMAC stalled whilst copying the above block
        CMP     R0,#STALLED
        BEQ     int_TC_wr_10            ; restart it, (with above block)

int_TC_wr_30
        LDR     R0,SBICStat
        CMP     R0,#IDLE
        BLEQ    FlushQueue              ; >>>should this be elsewhere????

        Pull    "R0-R11,PC"             ; >>>Overkill
;

      |

;
Restart_DMAC_Writing
        Push    "R0-R11,Link"           ; >>>Overkill
        LDR     R0,DMACStat
        CMP     R0,#STALLED
        BNE     int_TC_wr_25

int_TC_wr_10
        LDR     R0,QStart
        LDR     R1,QEnd
        CMP     R0,R1
        BNE     int_TC_wr_20


;
; Queue empty
;
        LDR     R0,CopyStat             ; If CopyStat=IDLE Stop the DMAC
        CMP     R0,#IDLE
        STREQ   R0,DMACStat

        LDR     R0,CopyStat
        CMP     R0,#STALLED             ; Interrupted the copier, so return, when copier
        BNE     int_TC_wr_30            ; finishs, it will see the stalled DMAC and
        ;       restart it. >>>>combine with above 3 lines


; Queue empty, copier stalled.
; Copy CurrentPointers into FuturePointers to ensure PreWriteBlk
; gives us the required data.
;
        ASSERT  PtrRecSize=16

        ADR     R0,CurrentPointers
        LDMIA   R0,{R1,R2,R3,R4}
        ADR     R0,FuturePointers
        STMIA   R0,{R1,R2,R3,R4}

        BL      PreWriteBlk

        LDR     R0,DMACStat
        CMP     R0,#STALLED
        BNE     int_TC_wr_30
;
; Queue not empty - Restart DMAC
;
int_TC_wr_20
        ADR     R7,DemandSlot           ; RamTxAdr & RamBlkSz that the DMAC wants
        BL      FillSlot                ; so lets see what's been copied to SRAM

        BL      UnQueueSlot             ; Out: R7->RamRec
        STR     R7,DMACram              ; DMAC will DeAllocate this when its empty

; If unqueued data is from wrong address, deallocate the block and loop back
;  to call PreWriteBlk or UnQueue until something suitable arrives.
;
; The normal cause of a mismatch between data wanted and data avaiable is the
; receipt of a MESSAGE_RESTOREDATAPOINTER or the implied restore-data-pointers
; that occurs upon target re-selection.
;
;>>>Current acceptance test is harsh ie
;>>> fail := (RamTxAdr<>CurrEntAdr) OR (RamBlkSz>CurrEntCnt)
;>>>
;>>> we could adjust RamTxAdr & RamBlkSz if CurrEntAdr falls between
;>>> RamTxAdr..(RamTxAdr+RamBlkSz)
;>>>
        LDMIA   rPAGESLOTptr,{R0,R1}      ; RamTxAdr,RamBlkSz

        LDR     R4,DemandSlot+:INDEX:RamTxAdr
        LDR     R5,DemandSlot+:INDEX:RamBlkSz

        CMP     R0,R4                   ; If RamTxAdr<>CurrEntAdr
        BLNE    DeAllocateRAM           ; 
        BNE     int_TC_wr_10            ; 
        CMP     R1,R5                   ; or RamBlkSz>CurrEntCnt
        BLGT    DeAllocateRAM           ; ditch the block
        BGT     int_TC_wr_10            ; loop back to look for a better one

;
; UnQueued block OK, so Restart the DMAC
;
        MOV     R0,#dma_wr_mode         ; Restart the DMAC in write mode
        BL      ArmDMAC                 ; In/Out: R7->RamRec

int_TC_wr_25
        BL      PreWriteBlk
        BCS     int_TC_wr_30

        LDR     R0,DMACStat             ; If DMAC stalled whilst copying the above block
        CMP     R0,#STALLED
        BEQ     int_TC_wr_20            ; restart it, (with above block)

int_TC_wr_30
        LDR     R0,SBICStat
        CMP     R0,#IDLE
        BLEQ    FlushQueue              ; >>>should this be elsewhere????

        Pull    "R0-R11,Link"           ; >>>Overkill
        MOV     PC,Link
      ]

;************************************************
;       Interrupt from SBIC
;************************************************

int_service_SBIC
        LDR     rCMDptr,CMDptr

        LDRB    R1,SBICauxstat
        TST     R1,#INT
        BEQ     int_ser_99              ; Not interrupting, so return
        rdSBIC  R0,SR_SCSIstat


int_service_01
        CMP     R0,#&81                 ; Reselected (advanced mode)
        BEQ     int_ser_73



      [ debug
        STR     R1,HostAuxStat
        Push    "R1-R8"
        ADRL    R8,HostStat
        LDMIA   R8,{R1-R7}
        STMIA   R8,{R0-R7}
        Pull    "R1-R8"
      |
        LDR     R2,HostStat
        STR     R2,HostStat1
        STR     R0,HostStat             ; Everything else is useful
      ]

        CMP     R0,#&11
        BEQ     int_ser_code_11         ; Select command completed OK

        CMP     R0,#&16
        BEQ     int_ser_10              ; Select-And-Transfer completed OK

        CMP     R0,#&20
        BEQ     int_ser_40              ; MessageIn paused

        CMP     R0,#&21                 ; Paused after receipt of a 'save data pointers'
        BEQ     int_ser_code_21         ; message

        CMP     R0,#&85                 ; Disconnect has occured
        BEQ     int_ser_50

        CMP     R0,#&41                 ; Unexpected disconnection
      [ SQ555kludge
        BEQ     int_ser_SQ555
      |
        BEQ     int_ser_49              ; do unexpected disconnection code
      ]
;
;
; MCI=2_000 - DataOut phase requested
;
        CMP     R0,#&48                 ; Unexpected DataOut
        BEQ     int_ser_13
        CMP     R0,#&18
        BEQ     int_ser_14
        CMP     R0,#&88
        BEQ     int_ser_65
;
;
; MCI=2_001 - DataIn phase requested
;
        CMP     R0,#&49                 ; Unexpected DataIn phase
        BEQ     int_ser_15
        CMP     R0,#&19
        BEQ     int_ser_16
        CMP     R0,#&89
        BEQ     int_ser_66
;
;
; MCI=2_010 - Command phase
;
        CMP     R0,#&4A
        BEQ     int_ser_code_4A
        CMP     R0,#&1A
        BEQ     int_ser_code_1A
        CMP     R0,#&8A
        BEQ     int_ser_code_8A
;
;
; MCI=2_011 - Status phase requested
;
        CMP     R0,#&1B
        BEQ     int_ser_27
        CMP     R0,#&4B
        BEQ     int_ser_20              ; Unexpected Status phase
        CMP     R0,#&8B
        BEQ     int_ser_22              ; REQ signal asserted, Status phase requested
;
;
; MCI=2_110 - MessageOut phase requested
;
        CMP     R0,#&4E
        BEQ     int_ser_59
        CMP     R0,#&8E
        BEQ     int_ser_60
        CMP     R0,#&1E
        BEQ     int_ser_61
;
;
; MCI=2_111 - MessageIn phase requested
;
        CMP     R0,#&1F
        BEQ     int_ser_30              ; A transfer command completed, MessageIn phase
        CMP     R0,#&4F
        BEQ     int_ser_24              ; Unexpected MessageIn phase
        CMP     R0,#&8F
        BEQ     int_ser_23              ; REQ signal asserted, MessageIn phase requested





        CMP     R0,#HOST_TIMEOUT
        BEQ     int_ser_70

        B       int_ser_99


;
; &11 - Select command completed OK
;
;       ie we did SC_Sel_withATN to allow a message to be sent
;          we hope to receive an &8E to allow the message to be sent
;       Set up sensible values in HoldCmd,HoldPhase,HoldCount, so that if
;       the target demands a command instead or fails to stop for some other
;       reason, we can do a resume-SAT
;
int_ser_code_11
        ASSERT  (HoldPhase = HoldCmd + 4)
        ASSERT  (HoldCount = HoldPhase + 4)

        MOV     R0,#SC_Sel_Tx_woATN     ; 
        MOV     R1,#&20                 ; 
        MOV     R2,#0                   ; 
        ADR     R3,HoldCmd
        STMIA   R3,{R0,R1,R2}           ; HoldCmd,HoldPhase,HoldCount

        B       int_ser_99


;
; &16 - Select-And-Transfer completed OK
;       ie Target received/sent expected number of data bytes,
;          then sent a status byte, then a MESSAGE_COMMANDCOMPLETE
;
; Read the Target Status byte, update DeviStat/CopyStat/DMACStat/SBICStat
;
; Successful completion, so DMAC should have IDLEd, Copier should be
;  IDLE (Host->Target) or running (Target->Host)
;
int_ser_10
        rdSBIC  R0,SR_TargetLUN          ; Get returned Target Status byte
        STR     R0,TargStat

        MOV     R0,#MESSAGE_COMMANDCOMPLETE ; Target sent this, but the SBIC didn't
        STR     R0,MessageIn                ; pass it on, so pretend it did
      [ bugfix2
;
; Since command has completed, theres no point allowing
; 'Escape','AbortOp' or 'Timeout2' to send an abort message
;
        MOV     R0,#CTL_Suppress
        STR     R0,Suppress
      ]
        BL      StopDataTX              ; SBIC transfer count register WILL BE 0

        MOV     R0,#IDLE                ; SBIC now completed
        STR     R0,SBICStat
        B       int_ser_99


;
; &18 - A Transfer (non-MessageIn phase) command completed successfully.
;
; &48 - Unexpected information phase requested
;       (eg the target is demanding more data than we've got)
;
; &88 - The REQ signal has been asserted following connection
;       or when the SBIC is in the initiator state and no command is executing.
;
; DataOut phase requested
;
int_ser_13                              ;&48
        BL      StopDataTX              ; Marks state as cannot do ResumeSAT
int_ser_14                              ;&18
int_ser_65                              ;&88
;
; May need to nudge phase to &41, because if the target sent a SAVEDATAPOINTER
; message immediatly after the command phase we get a &4F interrupt (not &21)
; and have to process it by steam, this leaves the phase set to &3x.
;
        BL      NudgePhase_41           ; If phase<41, set to 41
        BL      TryResumeSAT            ; Returns only if impossible

      [ bugfix9
        MOV     R0,#0
        wrSBIC24 R0,SR_Count
      ]

      [ counts
        Push    "R0-R1"
        ADRL    R0, MyInfoSpace1
        LDR     R1, [R0, #4]
        ADD     R1, R1, #1
        STR     R1, [R0, #4]
        Pull    "R0-R1"
      ]

        MOV     R0,#SC_Transfer_Info_SBT    ; Single byte transfer over SCSI bus
        wrSBIC  R0,SR_Command
        BL      DBR_wait                ; Wait for data buffer empty
        MOV     R0,#&42
        wrSBIC  R0,SR_Data              ; Write data byte to SBIC

        B       int_ser_99


;
; &19 - A Transfer (non-MessageIn phase) command completed successfully.
;
; &49 - Unexpected information phase requested
;       (eg the target is sending more data than we asked for)
;
; &89 - The REQ signal has been asserted following connection
;       or when the SBIC is in the initiator state and no command is executing.
;
; DataIn phase requested
;
int_ser_15                              ;&49
        BL      StopDataTX              ; Marks state as cannot do ResumeSAT
int_ser_16                              ;&19
int_ser_66                              ;&89
;
; May need to nudge phase to &41, because if the target sent a SAVEDATAPOINTER
; message immediatly after the command phase we get a &4F interrupt (not &21)
; and have to process it by steam, this leaves the phase set to &3x.
;
        BL      NudgePhase_41           ; If phase<41, set to 41
        BL      TryResumeSAT            ; Returns only if impossible

        BL      FillJunkSlot
        STR     R7,DMACram

        MOV     R0,#dma_rd_mode
        BL      ArmDMAC                 ; In/Out: R7->RamRec

        LDR     rCMDptr,CMDptr          ; cos register shared with rPAGESLOTptr

        MOV     R0,#PAGESIZE
        wrSBIC24 R0,SR_Count
        MOV     R0,#SC_Transfer_Info
        wrSBIC  R0,SR_Command

        B       int_ser_99


;
; &1A - A Transfer (non-MessageIn phase) command completed successfully.
;       (eg we sent a MESSAGE_REJECT in response to a MessageIn phase
;        requesting a synchronous data transfer).
;
; &4A - Unexpected information phase requested
;       (eg we did a SATwithATN and the target does not support messages)
;
; &8A - The REQ signal has been asserted following connection
;       or when the SBIC is in the initiator state and no command is executing.
;       (eg the target just sent MESSAGE_REJECT in response to our IDENTIFY
;        message, we now wish to continue the SATwithATN)
;
;
;
; Command phase requested
;
int_ser_code_4A                         ;&4A
;>>>this means the target CANNOT accept messages, we could set a control bit
;>>>to prevent our trying to, or we could alter the control disconnection
;>>>setting to 2.
        BL      HoldSBICstate
        MOV     R1,#&20
        STR     R1,HoldPhase
int_ser_code_1A                         ;&1A
int_ser_code_8A                         ;&8A
        MOV     R0,#SC_Sel_Tx_withATN   ; Resume SATwithATN
        MOV     R1,#&20                 ; &30              ; after the identify MessageOut
        ADR     R3,HoldCmd              ; phase
        STMIA   R3,{R0,R1}              ; HoldCmd,HoldPhase
        BL      TryResumeSAT            ; Won't return

        B       int_ser_99


;
; &1B - A Transfer (non-MessageIn phase) command completed successfully.
;
; &4B - Unexpected information phase requested
;       (eg the target has sent less data than we asked for)
;
; &8B - The REQ signal has been asserted following connection
;       or when the SBIC is in the initiator state and no command is executing.
;
; Status phase requested
;
int_ser_20                              ;&4B - Unexpected status phase, so halt
        BL      StopDataTX              ; Marks state as cannot do ResumeSAT
int_ser_22                              ;&8B
int_ser_27                              ;&1B
        BL      TryResumeSAT            ; Returns only if impossible

        MOV     R0,#SC_Transfer_Info_SBT    ; Single byte transfer
        wrSBIC  R0,SR_Command
        BL      DBR_wait                ; Wait for data ready
        rdSBIC  R0,SR_Data              ; Fetch the status byte
        STR     R0,TargStat

        B       int_ser_99


;
; &1E - A Transfer (non-MessageIn phase) command completed successfully.
;       (eg following the status phase in int_ser_20)
;
; &4E - Unexpected information phase requested
;
; &8E - The REQ signal has been asserted following connection
;       or when the SBIC is in the initiator state and no command is executing.
;
; MessageOut phase requested
;
int_ser_59                              ;&4E
        BL      HoldSBICstate
int_ser_60                              ;&8E
int_ser_61                              ;&1E
        LDR     rCMDptr,CMDptr

        MOV     R0,#SC_Transfer_Info_SBT    ; Single byte transfer over SCSI bus
        wrSBIC  R0,SR_Command

        BL      DBR_wait                ; Wait for data buffer empty

        LDR     R1,CmdDevID             ; Test CmdDevID for reasons
      [ bugfix2
        LDR     R0,Suppress             ; Some reasons maybe suppressed, after
        BIC     R1,R1,R0                ; MESSAGE_COMMANDCOMPLETE received
      ]
      [ rejectnaffmessages
        MOV     R0,#MESSAGE_REJECT      ; that require a 'Reject'

        MOV     R2,#CTL_DOINGMESSAGEREJECT
        TST     R1,R2
        BNE     message_go
      ]
        MOV     R0,#MESSAGE_BUSDEVICERESET  ; or 'BusDeviceReset'

        MOV     R2,#CTL_DOINGRESET
        TST     R1,R2
        BNE     message_go

        MOV     R0,#MESSAGE_ABORT       ; or 'DeviceAbort'

        MOV     R2,#CTL_DOINGABORTDEVICE
        TST     R1,R2
        BNE     message_go

        MOV     R2,#CTL_DOINGABORTOP
        TST     R1,R2
        BNE     message_go

        MOV     R2,#CTL_DOINGESCAPEDEVICE
        TST     R1,R2
        BNE     message_go

        MOV     R2,#CTL_DOINGTIMEOUT2
        TST     R1,R2
        BNE     message_go

        MOV     R0,#MESSAGE_NOOPERATION ; Un-solicited MessageOut, send NOP
        MOV     R2,#0
message_go
        ORR     R0,R0,R2                ; Mark the message with the reason for sending
        BIC     R1,R1,R2                ; Clear reason from CmdDevID
        STR     R1,CmdDevID

        STR     R0,MessageOut
        wrSBIC  R0,SR_Data              ; Write message byte to SBIC
        B       int_ser_200

;
; &1F - A Transfer (non-MessageIn phase) command completed successfully.
;       (eg following the status phase in int_ser_20)
;
; &4F - Unexpected information phase requested
;       (eg the target is trying to send a restore data pointers message)
;
; &8F - The REQ signal has been asserted following connection
;       or when the SBIC is in the initiator state and no command is executing.
;
; MessageIn phase requested
;
int_ser_24                              ;&4F
        BL      HoldSBICstate
int_ser_30                              ;&1F
int_ser_23                              ;&8F
        MOV     R0,#SC_Transfer_Info_SBT    ; Use single byte transfer mode
        wrSBIC  R0,SR_Command               ;
        BL      DBR_wait                    ; (wait for data ready)
        rdSBIC  R0,SR_Data                  ; to fetch the message byte
        STR     R0,MessageIn

        B       int_ser_99


;
; &20 - A Transfer Info (MessageIn phase) command has paused with ACK
;       asserted.
;
; This allows the host to examine the message before accepting it.
;
int_ser_40           ;&20
        LDR     R0,MessageIn

        CMP     R0,#MESSAGE_SAVEDATAPOINTER         ; Carefull, as we've read bytes
        ADREQ   Link,int_ser_43                   ; to get the message, SR_Count
        BEQ     SaveCurrentPointers_UseHold         ; is invalid

        CMP     R0,#MESSAGE_RESTOREDATAPOINTER
        BNE     int_ser_41

        BL      RestoreCurrentPointers

        MOV     R0,#&45                 ; 'Resume Select-And-Transfer' ready
        wrSBIC  R0,SR_Phase             ; for data transfer phase. May get

        MOV     R0,#SC_Sel_Tx_withATN   ; Status or MessageIn. An implied
        wrSBIC  R0,SR_Command           ; Negate ACK occurs
        B       int_ser_99

int_ser_41
        CMP     R0,#MESSAGE_COMMANDCOMPLETE ; If MessageIn is command complete
        MOVEQ   R0,#IDLE
        STREQ   R0,SBICStat             ; SBIC now completed
      [ bugfix2
;
; Since command has completed, theres no point allowing
; 'Escape','AbortOp' or 'Timeout2' to send an abort message
;
        MOVEQ   R0,#CTL_Suppress
        STREQ   R0,Suppress
      ]
        BEQ     int_ser_43

        CMP     R0,#MESSAGE_REJECT      ; Target rejected our message so pretend
        MOVEQ   R1,#MESSAGE_NOOPERATION ; we never sent it (prevents the next
        STREQ   R1,MessageOut           ; disconnection being mis-interpreted
        BEQ     int_ser_43              ; as a successful abort/reset).

        CMP     R0,#MESSAGE_DISCONNECT  ; Controller normally hides this, but
        BEQ     int_ser_43              ; may appear outside a SAT command


      [ rejectnaffmessages
        CMP     R0,#MESSAGE_EXTENDEDMESSAGE
        BNE     RejectIt
;
; Extended message processing
;
        MOV     R0,#SC_NegateACK        ; Negate ACK (on the MESSAGE_EXTENDEDMESSAGE)
        wrSBIC  R0,SR_Command
        ;Now    wait for the Extended message length byte
        BL      INT_wait
        rdSBIC  R0,SR_SCSIstat
        CMP     R0,#&8F
        BNE     int_service_01

        MOV     R0,#SC_Transfer_Info_SBT; Use single byte transfer mode
        wrSBIC  R0,SR_Command           ;
        BL      DBR_wait                ; (wait for data ready)
        rdSBIC  R1,SR_Data              ; to fetch the message length byte

        BL      INT_wait
        rdSBIC  R0,SR_SCSIstat
        CMP     R0,#&20
        BNE     int_service_01

        CMP     R1,#0                   ; Zero means 256 bytes follow
        MOVEQ   R1,#256                 ; 
int_ser_42
        MOV     R0,#SC_NegateACK        ; Negate ACK (length/code/argument byte)
        wrSBIC  R0,SR_Command
        ;Now    wait for the message code/argument bytes
        BL      INT_wait
        rdSBIC  R0,SR_SCSIstat
        CMP     R0,#&8F
        BNE     int_service_01

        MOV     R0,#SC_Transfer_Info_SBT; Use single byte transfer mode
        wrSBIC  R0,SR_Command           ;
        BL      DBR_wait                ; (wait for data ready)
        rdSBIC  R0,SR_Data              ; to fetch the code/argument byte

        BL      INT_wait
        rdSBIC  R0,SR_SCSIstat
        CMP     R0,#&20
        BNE     int_service_01

        SUBS    R1,R1,#1                ; If more bytes to come, loop back to Negate ACK
        BNE     int_ser_42              ; for this one, then expect another byte
        ;Else   since we support NONE of the extended
        ;       messages, drop into...
;
; Reject an unwanted (not supported) message by asserting ATN.
; This will cause us to send a MESSAGE_REJECT later on.
;
RejectIt
        LDR     R0,CmdDevID
        ORR     R0,R0,#CTL_DOINGMESSAGEREJECT
        STR     R0,CmdDevID

        BL      nCIP_wait
        MOV     R0,#SC_AssertATN
        wrSBIC  R0,SR_Command
      ]

int_ser_43
        BL      nCIP_wait
        MOV     R0,#SC_NegateACK        ; Negate ACK
        wrSBIC  R0,SR_Command
        B       int_ser_99


;
; &21 - A Save Data Pointers message has been received whilst executing
;       a Select-And-Transfer command.
;
; N.B. MUST have been SATwithATN, as that is the only way to send an identity
;      message telling the target we support messages.
;
int_ser_code_21
        BL      SaveCurrentPointers
        MOV     R0,#&41                 ; >>>Do we need this, command phase register
        wrSBIC  R0,SR_Phase             ; >>> should be &41 already

        MOV     R0,#SC_Sel_Tx_withATN   ; 'Resume Select-And-Transfer' after
        wrSBIC  R0,SR_Command           ; receipt of 'Save data pointers'
        B       int_ser_99


;
; &41 - Unexpected disconnection
;
int_ser_49                              ;&41
    [ debug
      [ {FALSE}
        rdSBIC  R0,SR_Command
        rdSBIC  R1,SR_Phase
        MOV     R14,#-1
        LDR     R14,[R14]
      ]
    ]
        MOV     R0,#TARGET_UNEXPECTEDDISCONNECT
common_disconnect
        STR     R0,TargStat             ; Pseudo status
      [ {FALSE}
        BL      ResetDMAC               ; Stop DMAC

        LDR     R0,DMACStat
        CMP     R0,#RUNNING
        LDREQ   R7,DMACram
        BLEQ    DeAllocateRAM

        MOV     R0,#IDLE                ; SBIC now IDLE
        STR     R0,SBICStat
        STR     R0,DMACStat             ; as is the DMAC

        MOV     R0,#0
        STR     R0,Connected            ; and no longer connected
        STR     R0,Lockout
      |
        BL      StopDataTX

        MOV     R0,#IDLE                ; SBIC IDLEd
        STR     R0,SBICStat

        MOV     R0,#0
        STR     R0,Connected            ; and no longer connected
        STR     R0,Lockout
      ]
      [ bugfix5
        MOV     R0,#ER                  ; &80 allow other targets to reselect
        wrSBIC  R0,SR_SourceID
      ]
        B       int_ser_99

;
; &85 - Expected disconnection occured
;       ie Target sent MESSAGE_DISCONNECT then disconnected OR
;          Target sent MESSAGE_COMMANDCOMPLETE
;
int_ser_50                              ;&85
;
; Violate the SCSI spec...
;
; Some SCSI devices may disconnect after transfering all the data, but before
; sending status & command complete messages. They ought to send a SAVE DATA
; POINTER message before disconnection but some don't. On reconnection the
; current pointers are restored from the saved pointer values. A NAFF target
; expects the pointers to point to the end of the data whereas they will in
; fact pointer earlier in the transfer. Chaos then strikes.
;
; So, to fix these devices, check the transfer count register, if zero
; fake a SAVE DATA POINTER operation.
;
; Of course, if we find a device that doesn't break the spec. and expects
; the saved pointers not to have been written to, we're f***ed!!.
;
        rdSBIC24 R0,SR_Count            ; Violates the SCSI spec,
        CMP     R0,#0                   ; but see if it fixes the Connor
        BLEQ    SaveCurrentPointers     ;

        BL      StopDataTX              ; >>>non-optimal. OK for read case
        ;>>>but flushs copied data when writing.
        MOV     R0,#0
        STR     R0,Connected            ; and no longer connected
        STR     R0,Lockout
      [ bugfix5
        MOV     R0,#ER                  ; &80 allow other targets to reselect
        wrSBIC  R0,SR_SourceID
      ]

;If the disconnection occured as the result of a message_out, that we
; sent, to abort or reset the target, load up a pseudo target status
; and ASSUME the target has aborted this command
;
;Uses code common to unexpected disconnection

        LDR     R0,HostStat1
        AND     R0,R0,#&0F
        CMP     R0,#&0E
        BNE     int_ser_99

        LDR     R0,MessageOut

        TST     R0,#CTL_DOINGRESET
        MOVNE   R0,#TARGET_RESET
        BNE     common_disconnect

        TST     R0,#CTL_DOINGABORTDEVICE
        MOVNE   R0,#TARGET_ABORTDEVICE
        BNE     common_disconnect

        TST     R0,#CTL_DOINGABORTOP
        MOVNE   R0,#TARGET_ABORTOP
        BNE     common_disconnect

        TST     R0,#CTL_DOINGESCAPEDEVICE
        MOVNE   R0,#TARGET_ESCAPED
        BNE     common_disconnect

        TST     R0,#CTL_DOINGTIMEOUT2
        MOVNE   R0,#TARGET_TIMEOUT2
        BNE     common_disconnect

        B       int_ser_99              ; >>>Else assume it was harmless????


;
; &42 - Timeout occured whilst trying to select the target
;
int_ser_70                              ;&42
        BL      StopDataTX              ; IDLEs the DMAC, tells the copier to IDLE ASAP

        MOV     R0,#TARGET_TIMEOUT      ; Easier to pretend its a target status problem
        STR     R0,TargStat

        MOV     R0,#IDLE                ; SBIC IDLEd
        STR     R0,SBICStat

        MOV     R0,#0
        STR     R0,Connected            ; and no longer connected
        STR     R0,Lockout
      [ bugfix5
        MOV     R0,#ER                  ; &80 allow other targets to reselect
        wrSBIC  R0,SR_SourceID
      ]
        B       int_ser_99

;
; &81 - SBIC reselected (whilst in advanced mode)
;
; The ID of the reselecting target is in the SR_SourceID register
; The identify message from the target (indicating the reconnecting LUN)
; is in the SR_Data register.
;
; ACK is still asserted, so the identify message may be rejected.
;
int_ser_73
        rdSBIC  R1,SR_SourceID          ; Reselecting TargetID (known iff SIV set)
        rdSBIC  R2,SR_Data              ; its LUN
        ;>>>do  we need to wait for DBR???

    [ bugfix6
;
; If we try to select another device at about the same time as this one
; reselects, the select (and transfer) command is ignored. The SBIC is
; supposed to indicate this by setting the LCI bit in SBICauxstat, this
; bit is checked in StartCommand. However due to a SBIC bug, this doesn't
; always get set, so the device, (registered with DEVICEptr) thinks it is
; connected to its target and is running.
;
; So, if DEVICEptr points to a device with its connected bit set put it
; back to not connected and mark the command as INITIALISED.
; This is the state StartCommand would have left it in if the LCI bit
; had worked.
;
        LDR     R9,DEVICEptr
        TEQ     R9,#0
        LDRNE   R3,Connected            ; >>>>The proper code could go above the two
        TEQNE   R3,#0                   ;    rdSBIC commands
      [ {TRUE}
        ;MOVNE  R3,#IDLE                ; Put device back to IDLE & NOT connected
        ;STRNE  R3,DeviStat             ; 
        MOVNE   R3,#0                   ; 
        STRNE   R3,Connected            ; 

        LDRNE   rCMDptr,CMDptr
        MOVNE   R3,#INITIALISED         ; Command is already initialised.
        STRNE   R3,CmdStat              ; 
      |
        BNE     gobang                  ; LCI bit failed
      ]
    ]
        AND     R1,R1,#maxDeviceID
        BL      AddressDevice           ; In: R1=DeviceID; Out: R1=DeviceID,
        ;       R9->deviceblk

        STR     R9,DEVICEptr            ; Register reselecting target with interrupt
        ;       handler
      [ debug
        Push    "R1-R8"
        ADRL    R8,HostStat
        LDMIA   R8,{R1-R7}
        STMIA   R8,{R0-R7}
        Pull    "R1-R8"
      |
        LDR     R3,HostStat
        STR     R3,HostStat1
        STR     R0,HostStat
      ]

        LDR     rCMDptr,CMDptr
        LDR     R5,CpyCtl
;>>>Must also restore data direction info (do in RestoreCurrentPointers??)
;>>>and CDB[0..11]
;>>>
      [ bugfix4
;
; Restore data direction info, held in SR_DestID
;
        TST     R5,#CTL_TXREAD
        ORRNE   R1,R1,#DPD
        wrSBIC  R1,SR_DestID            ; Set DPD, with kosha TargetID
      ]
      [ {TRUE}
        AND     R2,R2,#7
        wrSBIC  R2,SR_TargetLUN         ; Probably not needed, but doesn't hurt

        BL      LoadCDBregisters        ; In R5=CpyCtl, corrupts R0,R2,R3
      ]


        BL      RestoreCurrentPointers
        MOV     R0,#&45                 ; 'Resume Select-And-Transfer' ready for
        wrSBIC  R0,SR_Phase             ; for data transfer phase. May get

        MOV     R0,#SC_Sel_Tx_withATN   ; Status or MessageIn. An implied
        wrSBIC  R0,SR_Command           ; Negate ACK occurs

        MOV     R0,#1
        STR     R0,Connected
        STR     R0,Lockout
        B       int_ser_99


int_ser_99
;>>> if command complete/aborted return quietly (background bit clear)
;>>> or do callback (background bit set)
;>>> else return

        LDR     R0,CpyCtl
        TST     R0,#CTL_TXREAD
        BEQ     int_ser_100
        ;In     READ mode,
        LDR     R1,CopyStat
        CMP     R1,#STALLED
        BNE     int_ser_100
        ;       with Copier STALLED
        LDR     R0,QStart
        LDR     R1,QEnd
        CMP     R0,R1
        BNE     int_TC_rd_30            ; and slots in the queue, so start copier

;************************************************
;       Interrupt processed - Check command completion state
;************************************************

int_ser_100
        LDR     R0,CopyStat             ; If copier not running
        CMP     R0,#RUNNING
        BEQ     int_ser_200

        LDR     R0,SBICStat             ; and SBIC & DMAC are IDLE
        CMP     R0,#IDLE
        LDREQ   R0,DMACStat
        CMPEQ   R0,#IDLE

        STREQ   R0,DeviStat             ; mark whole operation as complete

int_ser_200
        LDR     R0,DeviStat
        CMP     R0,#IDLE
        LDREQ   R0,Connected
        CMPEQ   R0,#0
        BNE     int_ser_202

        LDR     rCMDptr,CMDptr          ; cos register shared with rPAGESLOTptr
        MOV     R5,#IDLE
        STR     R5,CmdStat

        LDR     R0,CmdDevID
      [ :LNOT:soft
        TST     R0,#CTL_DOINGREQUESTSENSE
        BNE     int_ser_300
      ]

;
; Completed execution of the users CDB
;

; LDR R3,CpyAdr
; LDR R4,CmdXferPtr
; CMP R3,R4
; MOVNE PC,#0

; LDR R3,CpyCnt
; LDR R4,CmdXferLen
; CMP R3,R4
; MOVNE PC,#0

        LDR     R4,CpyFail              ; Count of bytes NOT transfered
        STR     R4,CmdRtR4              ; (will change if we re-issue command)

;
; Check for our pseudo status values first (eg timeout), then
; mask out the vendor unique bits and look for GOOD/CHECK CONDITION/BUSY

        LDR     R1,TargStat
        CMP     R1,#TARGET_TIMEOUT
        BNE     %FT10
      [ :LNOT:soft
        BL      CheckForRetry           ; Returns if CTL_RETRYONTIMEOUT is clear
      ]
        SCSIError SCSI_Timeout
        B       do_callback_clrR1R2     ; so report error
10
        CMP     R1,#TARGET_TIMEOUT2
        BNE     %FT10
      [ :LNOT:soft
        BL      CheckForRetry           ; Returns if CTL_RETRYONTIMEOUT is clear
      ]
        SCSIError SCSI_Timeout2
        B       do_callback_clrR1R2     ; Report error

10      CMP     R1,#TARGET_ESCAPED
        ADREQ   R0,ErrorBlock_Escape
        BEQ     do_callback_clrR1R2

        CMP     R1,#TARGET_ABORTOP
        SCSIError SCSI_AbortOp
        BEQ     do_callback_clrR1R2

        CMP     R1,#TARGET_ABORTDEVICE
        CMPNE   R1,#TARGET_RESET
        BEQ     completed_nocallback

        CMP     R1,#TARGET_UNEXPECTEDDISCONNECT
        SCSIError SCSI_Died
      [ bugfix7b
        BEQ     do_callback_NoTx_clrR1R2
      |
        BEQ     do_callback_clrR1R2
      ]
    [ soft
        AND     R0,R1,#TARGET_Mask      ; Ignore vendor unique bits
        B       do_callback
    |
        AND     R0,R1,#TARGET_Mask      ; Ignore vendor unique bits
        CMP     R0,#TARGET_GOOD
        MOVEQ   R0,#0                   ; Indicate no error
        BEQ     do_callback             ; Command complete, status GOOD

        CMP     R0,#TARGET_CHECK_CONDITION
        BNE     %FT10
        BL      CheckAutoRequest        ; Returns if CTL_INHIBITREQUESTSENSE is set
        ;       doesn't if clear (issues REQUEST SENSE)
        SCSIError SCSI_CheckCondition
        B       do_callback             ; Report error

10      CMP     R0,#TARGET_BUSY
        SCSIError SCSI_Busy,EQ
        SCSIError SCSI_StatusUnkn,NE
        B       do_callback             ; Report error
    ]


    [ :LNOT:soft
;
; Completed an automatic request sense command
;
; IF TargStat=GOOD THEN
;   IF 8 bytes of extended sense recovered THEN
;     IF sensekey=unit attention AND hideunitattention THEN
;       reissue original command
;     ELSE
;       error(message[sensekey]) etc
;     ENDIF
;
;   else error("error (vendor unique)")
; else error("error (unable to determine cause)")
;
;
int_ser_300
        LDR     R1,SenseBlk             ; Bytes 0..3 of sense data
        LDR     R2,SenseBlk+4           ; Bytes 4..7 of sense data
        AND     R0,R1,#&7F              ; Extract error class & error code bits

        MOV     R2,R2,LSL #8            ; Assume extended sense, put information bytes
        ORR     R2,R2,R1,LSR #24        ; (bytes 3..6) in R2.
        ;       N.B. wrong byte sex!!
        RevBytes R1, R3,R4
        RevBytes R2, R3,R4, s           ; Deal with R2's sexual hangups
;
; RevBytes R1 leaves us with valid,class & code in b31,b30..b28,b27..b24
;   if non-extended sense, b23..b21 are vendor unique,
;                          b20..b0  are logical block address (now correct
;                                   byte sex)
;   if extended sense, b23..b16 are segment number
;                      b15      filemark bit
;                      b14      EOM
;                      b13      ILI
;                      b12      reserved
;                      b11..b8  Sense key
;                      b7..b0   information byte (MSB)
;
;   if non-extended sense, we separate the block address & error bits into
;                          R2 & R1
;   if extended sense, we mask out the information byte in R1 and load
;                      bytes 3..6 into R2 (byte sex reversed to suit ARM)

        CMP     R0,#&70                 ; 00..60 are non-extended (by defn. vendor unique)
        ;70     is extended sense (look at sense key)
        ;71..7E are extended sense - vendor unique
        ;7F     extended sense reserved


        BLO     nonextendedvendorunique
        BHI     extendedvendorunique


        MOV     R1,R1,LSR #8
        AND     R0,R1,#&0F              ; Extract the Sense Key
        CMP     R0,#&06
        BLEQ    CheckReportUnitAttention   ; Returns if CTL_REPORTUNITATTENTION set
        ;       doesn't if clear (reissues command)
;>>>interpret sensekey
        ADR     R3,SenseKeyDecodeTab
        LDR     R0,[R3,R0,LSL #2]
        ADD     R0,R0,R3



        B       do_callback



extendedvendorunique
        MOV     R1,R1,LSR #8
      [ debug ; debug makes this out of range
        SCSIError SCSI_CC_UnKn,,L
      |
        SCSIError SCSI_CC_UnKn
      ]
        B       do_callback

nonextendedvendorunique
        LDR     R0,=&001FFFFF
        AND     R2,R1,R0                ; R1 = Logical address (corrected byte sex)
        BIC     R1,R1,R0
        MOV     R1,R1,LSR #8
      [ debug                           ; debug makes this out of range
        SCSIError SCSI_CC_UnKn,,L
      |
        SCSIError SCSI_CC_UnKn
      ]
        B       do_callback
    ] ; :LNOT:soft

        LTORG                           ; Assemblers constants may go here

;
      [ soft
; R0 = status (VC)
;      error number or -> error block (VS)
      |
; R0  = 0
;    -> error block
      ]
; R1  = error number qualifier
; R2  = logical block address
;

      [ bugfix7b
;
; Indicate that none of the data was transfered,
; eg because of an unexpected disconnection.
;
do_callback_NoTx_clrR1R2
        LDR     R4,CmdXferLen           ; Save Expected size of transfer
        STR     R4,CmdRtR4              ; as Number of bytes NOT transfered
      ]
do_callback_clrR1R2
      [ soft
        SETV
      ]
        MOV     R1,#0
        MOV     R2,#0
do_callback

        LDR     rCMDptr,CMDptr          ; cos register shared with rPAGESLOTptr

        LDR     R5,CmdCallbackAdr
        TEQ     R5,#0                   ; callback NULL
        BEQ     completed_nocallback

      [ :LNOT:soft
        TEQ     R0,#0
        LDRNEB  R3,[R0]                 ; If error, LSB of error number, returned as
        ORRNE   R1,R1,R3,LSL #24        ; MSB of R1
      ]

        Push    "R0,R1,R2, R5, rCMDptr,rDEVICEptr,R12"

        LDR     R3,CmdXferPtr           ; Start of transfer
        LDR     R4,CmdRtR4              ; Number of bytes NOT transfered
        LDR     R5,CmdXferLen           ; Expected size of transfer
      [ bugfix7a
        MOVNE   R4,R5                   ; If error, pretend NO data was transfered
      ]
      [ :LNOT:soft
        SUB     R5,R5,R4                ; Number of bytes actually transfered

        LDR     R0,CmdDevID

        TST     R0,#CTL_SCATTER

        ADDEQ   R3,R3,R5                ; Last byte transfered +1
        STREQ   R3,CmdRtR3
        BEQ     do_callbk_20
do_callbk_10
        LDMIA   R3,{R0,R1}              ; Address,length entry
        CMP     R5,R1
        MOVGE   R2,R1
        MOVLT   R2,R5                   ; R2=min(bytes transfered,bytes this entry)

        ADD     R0,R0,R2                ; Inc Entry address  } by amount from this entry
        SUB     R5,R5,R2                ; Dec Entry length   } ie min(bytes transferedt,
        SUB     R1,R1,R2                ; Dec Transfer count }        bytes this entry)

        STMGEIA R3 !,{R0,R1}
        BGT     do_callbk_10            ; More entries to update
        STMLTIA R3,{R0,R1}
      ]
do_callbk_20
        Pull    "R0,R1,R2, R6"
      [ soft
        LDR     R5,CmdCallbackR5
      ]
        LDR     R12,CmdCallbackR12
      [ soft
        ;       V flag is preserved from entry to do_callback
      |
        CMP     R0,#0
        SETV    NE
      ]
        MOV     Link,PC
        MOV     PC,R6
        Pull    "rCMDptr,rDEVICEptr,R12"

completed_nocallback
        BL      UnQueueCMDslot          ; Remove from queue (may not be first item)
        BL      DeAllocateCMDslot       ; 
int_ser_202

        MOV     R0,#Pod_EnableInts      ; Reselect Page0 to keep bootrom peekers happy
        wrPageReg R0

        Pull    "R0-R11,Link"

      [ counts
        Push    "R0-R1"
        ADRL    R0, MyInfoSpace1
        LDR     R1, [R0, #12]
        ADD     R1, R1, #1
        STR     R1, [R0, #12]
        Pull    "R0-R1"
      ]

        ;>>>MOVS PC,Link
        B       StartCommand


      [ :LNOT:soft
SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_NoSense        - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_RecoveredError    - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_NotReady       - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_MediumError    - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_HardwareError  - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_IllegalRequest - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_UnitAttention  - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_DataProtect    - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_BlankCheck     - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_VendorUnique   - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_CopyAborted    - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_AbortedCommand - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_Equal          - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_VolumeOverflow - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_Miscompare     - SenseKeyDecodeTab
        DCD     ErrorBlock_SCSI_CC_Reserved       - SenseKeyDecodeTab
      ]




        MakeSCSIErrorBlock SCSI_Timeout
        MakeSCSIErrorBlock SCSI_Timeout2
      [ {FALSE}
        MakeErrorBlock Escape           ; Declared in &.Hdr.newErrors
      |
ErrorBlock_Escape
        DCD     ErrorNumber_Escape
        DCB     "Escape", 0
        ALIGN
      ]
        MakeSCSIErrorBlock SCSI_AbortOp
        MakeSCSIErrorBlock SCSI_Died

        MakeSCSIErrorBlock SCSI_CheckCondition
        MakeSCSIErrorBlock SCSI_Busy
        MakeSCSIErrorBlock SCSI_StatusUnkn

        MakeSCSIErrorBlock SCSI_CC_NoSense
        MakeSCSIErrorBlock SCSI_RecoveredError
        MakeSCSIErrorBlock SCSI_CC_NotReady
        MakeSCSIErrorBlock SCSI_CC_MediumError
        MakeSCSIErrorBlock SCSI_CC_HardwareError
        MakeSCSIErrorBlock SCSI_CC_IllegalRequest
        MakeSCSIErrorBlock SCSI_CC_UnitAttention
        MakeSCSIErrorBlock SCSI_CC_DataProtect
        MakeSCSIErrorBlock SCSI_CC_BlankCheck
        MakeSCSIErrorBlock SCSI_CC_VendorUnique
        MakeSCSIErrorBlock SCSI_CC_CopyAborted
        MakeSCSIErrorBlock SCSI_CC_AbortedCommand
        MakeSCSIErrorBlock SCSI_CC_Equal
        MakeSCSIErrorBlock SCSI_CC_VolumeOverflow
        MakeSCSIErrorBlock SCSI_CC_Miscompare
        MakeSCSIErrorBlock SCSI_CC_Reserved

        MakeSCSIErrorBlock SCSI_CC_UnKn





CheckForRetry
        Push    "R0,Link"
        LDR     R0,CmdDevID
        TST     R0,#CTL_RETRYONTIMEOUT
        Pull    "R0,PC",EQ

        MOV     R0,#WAITING
        STR     R0,CmdStat

        Pull    "R0,Link"
      [ {FALSE}
        mess    ,"re-try command on Timeout",NL
      ]
        B       int_ser_202

    [ :LNOT:soft
CheckAutoRequest
        Push    "R0,Link"
        LDR     R0,CmdDevID
        TST     R0,#CTL_INHIBITREQUESTSENSE
        Pull    "R0,PC",NE
        ORR     R0,R0,#CTL_DOINGREQUESTSENSE
        STR     R0,CmdDevID

        MOV     R0,#WAITING
        STR     R0,CmdStat

        Pull    "R0,Link"
      [ {FALSE}
        mess    ,"doing Automatic-Request-Sense",NL
      ]
        B       int_ser_202

;************************************************
;       CheckReportUnitAttention
;************************************************

; Called when an auto request sense detects unit attention.
; If CTL_REPORTUNITATTENTION is set, return to the caller which will cause
; 'Unit attention' to be reported as an error.
; If CTL_REPORTUNITATTENTION is clear, the original user command is re-issued
; but with CTL_REPORTUNITATTENTION set, this is to ensure that if the re-issued
; command produces  check-condition/unit attention, this is reported rather
; than looping.
;
CheckReportUnitAttention
        Push    "R0,Link"
        LDR     R0,CmdDevID
        TST     R0,#CTL_REPORTUNITATTENTION
        Pull    "R0,PC",NE

        BIC     R0,R0,#CTL_DOINGREQUESTSENSE        ; Re_issue user command
        ORR     R0,R0,#CTL_REPORTUNITATTENTION      ; 
        STR     R0,CmdDevID

        MOV     R0,#WAITING
        STR     R0,CmdStat

        Pull    "R0,Link"
      [ {FALSE}
        mess    ,"re-issue command cos of Unit-Attention",NL
      ]
        B       int_ser_202
    ]

;************************************************
;       LoadCDBregisters
;************************************************

; Examine CTL_DOINGREQUESTSENSE bit in CpyCtl,
;  if clear, issue the CDB held in CmdCDB,
;  if set,   the SCSI command gave CHECK CONDITION and we are doing a
;            REQUEST SENSE to find out why.
;
; On entry
;   R5            = CpyCtl
;   R8 (rCMDptr) -> CmdRec
; Corrupts R0,R2,R3
;
      [ bugfix12
; The LUN given in CmdDevID (the DeviceID) replaces the LUN field
; in byte 1 of the CDB.
      ]
;
LoadCDBregisters
      [ soft
        ADR     R2,CmdCDB               ; ->CDB
        LDR     R3,CmdCDBLen            ; CDB size
      |
        TST     R5,#CTL_DOINGREQUESTSENSE
        ADREQ   R2,CmdCDB               ; ->CDB
        LDREQ   R3,CmdCDBLen            ; CDB size

        ADRNEL  R2,cdb_requestsense
        LDRNE   R3,[R2],#4
      ]

      [ bugfix10
        Push    Link
        wrSBIC  R3,SR_OwnID             ; Write CDB size to OwnID/CDBsize register,
        Pull    Link                    ; incase command is not group 0,1 or 5
      ]
        MOV     R0,#SR_CDB
        STRB    R0,SBICaddress          ; Select CDB register 1
      [ bugfix12
        LDRB    R0,[R2],#1              ; CDB byte 0
        STRB    R0,SBICindirect         ; 

        ASSERT  (LUNIDMask=&E0)
        LDRB    R0,[R2],#1              ; Replace LUN field in CDB byte 1
        BIC     R0,R0,#&E0              ; 
        LDR     R1,CmdDevID             ; 
        AND     R1,R1,#LUNIDMask        ; with LUN from DeviceID
        ORR     R0,R0,R1                ; 
        STRB    R0,SBICindirect         ; 

        SUBS    R3,R3,#2
        ;Now    do bytes 3 onwards
      ]
LdCDBreg_10
        LDRB    R0,[R2],#1              ; Copy 6,10,12 bytes of CDB into
        STRB    R0,SBICindirect         ; SBIC CDB registers
        SUBS    R3,R3,#1
        BGT     LdCDBreg_10

        MOV     PC,Link



PreWriteBlk
        Push    "R0,R1,Link"
        LDR     R0,CopyStat

        CMP     R0,#RUNNING
        BEQ     PreWrBlk_10

        LDR     R0,QStart
        LDR     R1,QEnd
        CMP     R0,R1
        BNE     PreWrBlk_10

        LDR     R0,FutrTtlCnt           ; If no data to copy
        CMP     R0,#0
        MOVEQ   R0,#IDLE                ; IDLE the copier
        STREQ   R0,CopyStat
        BEQ     PreWrBlk_10

        BL      AllocateRAM             ; Out CC & R7 (rPAGESLOTptr) ->RamRec
        BCS     PreWrBlk_10             ;    CS for failed

        BL      FillFutureSlot          ; In/Out: R7->RamRec
        MOV     R0,#RUNNING
        STR     R0,CopyStat
        BL      WriteBlkToSRAM          ; Write block to SRAM. In R8->Slot
        ;       IRQs enabled whilst copying
        BL      AdvanceFuturePointers
        LDR     R0,FutrTtlCnt           ; If no more data to copy,
        CMP     R0,#0
        MOVEQ   R0,#IDLE                ; IDLE the copier
        MOVNE   R0,#STALLED             ; else STALL it
        STR     R0,CopyStat
        BL      QueueSlot               ; In: R7 ->RamRec

PreWrBlk_10
        CLC
        Pull    "R0,R1,PC"


;************************************************
;       HoldSBICstate
;************************************************

; On exit
;   All registers preserved
;   Current SBIC state written into HoldCmd,HoldPhase,HoldCount
;
HoldSBICstate
        Push    "R0,R1,R2,R3,Link"
        rdSBIC24 R2,SR_Count
        rdSBIC  R1,SR_Phase
        rdSBIC  R0,SR_Command
        CMP     R0,#SC_AssertATN        ; Only ever raised whilst doing
        MOVEQ   R0,#SC_Sel_Tx_withATN   ; SC_Sel_Tx_withATN or SC_Sel_Tx_woATN
        CMP     R0,#SC_Sel_Tx_withATN
        CMPNE   R0,#SC_Sel_Tx_woATN
        MOVNE   R1,#0
        MOVNE   R2,#0
      [ bugfix1
        STREQ   R2,CpyFail              ; If HoldSBICstate called due to unexpected
        ;       message out and we send an abort message
        ;       CpyFail must be set here because StopDataTX
        ;       won't (it will find SR_Command set to
        ;       SC_Transfer_Info_SBT.
      ]
        ADR     R3,HoldCmd
        STMIA   R3,{R0,R1,R2}
        Pull    "R0,R1,R2,R3,PC"


        ASSERT  (HoldCmd   +4) = HoldPhase
        ASSERT  (HoldPhase +4) = HoldCount



;
; NudgePhase_30
; NudgePhase_41
; NudgePhase
;
; If HoldPhase <> 0 then
;   HoldPhase := max(HoldPhase,Supplied value)
;
;
NudgePhase_30
        Push    "R0,R1,Link"
        MOV     R0,#&30
        BL      NudgePhase
        Pull    "R0,R1,PC"


NudgePhase_41
        Push    "R0,R1,Link"
        MOV     R0,#&41
        BL      NudgePhase
        Pull    "R0,R1,PC"


NudgePhase
        LDR     R1,HoldPhase
        CMP     R1,#0
        MOVEQ   PC,Link

        CMP     R1,R0
        STRLT   R0,HoldPhase
        MOV     PC,Link


TryResumeSAT
        Push    "R0,R1,R2,R3, Link"
        ADR     R3,HoldCmd
        LDMIA   R3,{R0,R1,R2}           ; HoldCmd,HoldPhase,HoldCount
        TEQ     R1,#0
        Pull    "R0,R1,R2,R3, PC",EQ    ; Command Phase non-zero,
        wrSBIC24 R2,SR_Count            ; so reload SBIC
        wrSBIC  R1,SR_Phase             ; 
        wrSBIC  R0,SR_Command           ; and resume the command
        Pull    "R0,R1,R2,R3, Link"
        B       int_ser_99


;************************************************
;       StopDataTX
;************************************************

; Stop data transfer (ie copier & DMAC) as soon as possible
;
; If DMACStat=RUNNING & CpyCtl=READ
;   adjust DMACram->RamBlkSz; QueueSlot(DMACram); DMACStat=IDLE
;
StopDataTX
        Push    "R0,R1,R7,Link"
;
; If SR_Command (SBIC command register) is SC_Sel_Tx_withATN or SC_Sel_Tx_woATN
; or SC_AssertATN we are executing a Select-And-Transfer command. SR_Count
; indicates the number of bytes that have not been transfered (will be written
; to Cpy_Fail).
;
; If SR_Command holds any other value, the SBIC is executing part of the
; 'recover from terminated SAT command' sequence. SR_Count is discarded
; (if it holds anything it will be the sink/source junk count for transfer
; command to deal with an unexpected DataIn/DataOut phase).
;


        rdSBIC  R0,SR_Command
        CMP     R0,#SC_AssertATN        ; Only ever raised whilst doing
        ;MOVEQ  R0,#SC_Sel_Tx_withATN   ; SC_Sel_Tx_withATN or SC_Sel_Tx_woATN
        CMPNE   R0,#SC_Sel_Tx_withATN
        CMPNE   R0,#SC_Sel_Tx_woATN
        BNE     StpDat_10               ; skip the reading of SR_Count

;>>>
;>>> Look at SBIC transfer count and indicate amount successfully transfered
;>>> stop copier (Host->Target) or allow it to finish with adjusted limits
;>>> (Target->Host)
;>>>
        MOV     R0,#0                   ; Indicate that we cannot do a
        STR     R0,HoldCmd              ; Resume-Select-And-Transfer
        STR     R0,HoldPhase            ; in reponse to subsequent interrupts
        STR     R0,HoldCount

        rdSBIC24 R0,SR_Count
        STR     R0,CpyFail              ; 24bit count of bytes NOT transfered
StpDat_10
        LDR     R0,DMACStat
        CMP     R0,#RUNNING
        BNE     StpDat_20

;
;DMAC is running, ie filling a slot,
;  if writing, stop DMAC and dispose of partially emptied slot
;              the copier has to be allowed to complete its block and
;              dispose of it on seeing the DMAC IDLEd.
;
;  if reading, stop DMAC and add the partially filled slot to queue
;
        LDR     R7,DMACram
        LDR     R1,CpyCtl

        TST     R1,#CTL_TXWRITE         ; If writing,
        BEQ     %FT10
        BL      AdjustSlot              ; In/Out R7->RamRec
        BL      AdvanceCurrentPointers  ; In/Out R7->RamRec
        BL      DeAllocateRAM           ; In     R7->RamRec
        BL      FlushQueue
10
        TST     R1,#CTL_TXREAD          ; If reading,
        BEQ     %FT10
        BL      AdjustSlot              ; In/Out R7->RamRec
        BL      AdvanceCurrentPointers  ; In/Out R7->RamRec
        BL      QueueSlot               ; In     R7->RamRec
10
      [ {TRUE}
        MOV     R7,#-1
        STR     R7,DMACram
      ]
        MOV     R1,#0
        STR     R1,CurrTtlCnt

StpDat_20
        LDR     R0,DMACStat
        CMP     R0,#IDLE                ; If DMACStat=RUNNING or STALLED kill it
        BLNE    ResetDMAC               ; (sets DMACStat=IDLE)

        MOV     R0,#IDLE
        STR     R0,DMACStat             ; >>>>>Should be done by ResetDMAC???

; CASE CpyCtl OF
;   WHEN write : CASE CopyStat OF
;                  WHEN RUNNING: { Interupted whilst in copier. Do nothing, }
;                                {  when block completes, copier will idle  }
;                  WHEN STALLED: { Mark as IDLE                             }
;                  WHEN IDLE     { Mark as IDLE                             }
;                ENDCASE
;   WHEN read   :
;   WHEN no xfer:


        LDR     R1,CpyCtl
        TST     R1,#CTL_TXWRITE
        LDRNE   R1,CopyStat
        CMPNE   R1,#RUNNING             ; Copier STALLED (or IDLE) whilst in write mode
        STRNE   R0,CopyStat             ; force to IDLE state.

        Pull    "R0,R1,R7,PC"


;************************************************
;       ReadBlkFromSRAM
;************************************************

; UnQueue a RamRec (queue known to be non-empty), and copy the indicated data
; from SRAM into main memory.
;
; Entered with interrupts off, set CopyStat to running, initialise copier,
; enable interrupts and copy current block.
;
; We may be interrupted by the SBIC, or by DMAC terminal counts which
; give us extra pages to deal with.
;
        ASSERT  ( RamTxAdr  < RamBlkSz )
        ASSERT  ( RamBlkSz  < RamOffset)
        ASSERT  ( RamOffset < RamPage  )
;
ReadBlkFromSRAM
        Push    "R0,Link"
        Push    "R1-R11"

        MOV     R0,#RUNNING
        STR     R0,CopyStat

        BL      UnQueueSlot             ; Out: R7->RamRec
        Push    "R7,R12"                ; Preserve for later DeAllocate call

        LDMIA   rPAGESLOTptr,{R0,R1,R3,R4}  ; RamTxAdr,RamBlkSz,RamOffset,RamPage
        TEQ     R1,#0
        BEQ     RdBlkSRAM_80            ; No data in block, so finish
      [ debug
        CMP     R1,#4096
        MOVHI   PC,#0
      ]
;
; R0=RamTxAdr, R1=RamBlkSz, R2=???, R3=RamOffset, R4=RamPage
;
    [ IRQswhenreading
        ;BIC    R4,R4,#Pod_EnableInts
        wrPageReg R4                    ; Page the SRAM
      [ readback
        LDRB    R5,PR_IntStat
      ]

        EnableIRQs2 R5
    |
        ORR     R4,R4,#Pod_EnableInts
        wrPageReg R4                    ; Page the SRAM
    ]
        LDR     R2,SRAMptr              ; Base address of SRAM

        TEQ     R3,#0
        BEQ     RdBlkSRAM_20            ; Destination already QuadWord aligned

;
; Destination not QuadWord aligned, so read 8 halfwords from SRAM, compress
; them into 4 words that are written into QuadDump, copy bytes from the
; appropriate position in QuadDump to the destination until either the counter
; zeros (1..15 bytes xfered) or the destination becomes QuadWord aligned.
;
        LDMIA   R2!,{R4,R5,R6,R7,R8,R9,R10,R11}
        JoinHWords R4,R4,R5             ; R4:=(R4 AND &FFFF) OR (R5<<16)
        JoinHWords R6,R6,R7
        JoinHWords R8,R8,R9
        JoinHWords R10,R10,R11
        ADR     R5,QuadDump             ; Dump four words into QuadDump
        STMIA   R5,{R4,R6,R8,R10}
        ADD     R5,R5,R3                ; Adjust start address to suit dest alignment
RdBlkSRAM_10
        LDRB    R4,[R5],#1              ; Copy bytes from QuadDump to main RAM
        STRB    R4,[R0],#1              ; 
        SUBS    R1,R1,#1                ; 
        BLE     RdBlkSRAM_80            ; until count hits zero (finished)
        TST     R0,#&0F                 ; 
        BNE     RdBlkSRAM_10            ; or destination becomes quad word aligned

;
; Destination is (now) quad word aligned, so read 8 halfwords at a time from
; SRAM, compress into words and write 4 words at a time into mainRAM
;
RdBlkSRAM_20
        InitJoinMask R12
        SUBS    R1,R1,#16
        BLT     RdBlkSRAM_40
RdBlkSRAM_30
        LDMIA   R2!,{R4,R5,R6,R7,R8,R9,R10,R11}
        JoinHWords R4,R4,R5,R12         ; R4:=(R4 AND &FFFF) OR (R5<<16)
        JoinHWords R6,R6,R7,R12
        JoinHWords R8,R8,R9,R12
        JoinHWords R10,R10,R11,R12
        STMIA   R0!,{R4,R6,R8,R10}
        SUBS    R1,R1,#16
        BGE     RdBlkSRAM_30
RdBlkSRAM_40
        ADDS    R1,R1,#12
        BLT     RdBlkSRAM_60
RdBlkSRAM_50
        LDMIA   R2!,{R4,R5}
        JoinHWords R4,R4,R5,R12
        STR     R4,[R0],#4
        SUBS    R1,R1,#4
        BGE     RdBlkSRAM_50
RdBlkSRAM_60
        ADDS    R1,R1,#3
        BLT     RdBlkSRAM_80
        LDMIA   R2!,{R4,R5}
        JoinHWords R4,R4,R5,R12
RdBlkSRAM_70
        STRB    R4,[R0],#1
        MOV     R4,R4,LSR #8
        SUBS    R1,R1,#1
        BGE     RdBlkSRAM_70

RdBlkSRAM_80
      [ IRQswhenreading
        DisableIRQs2 R0                 ; Disable ARM IRQs
      ]
        Pull    "R7,R12"                ; Recover ->RamRec, WsPtr
        BL      DeAllocateRAM           ; In: R7 ->RamRec

        Pull    "R1-R11"                ; MUST DO THIS HERE, to recover rDEVICEptr

        MOV     R0,#STALLED             ; so that copier may be stalled
        STR     R0,CopyStat             ; 
      [ IRQswhenreading
        MOV     R0,#Pod_EnableInts
        wrPageReg R0                    ; Allow Podule IRQs
      ]
        Pull    "R0,PC"

;************************************************
;       WriteBlkToSRAM
;************************************************

; Transfers from MainRAM to SRAM are done in quad word (8 half word) chunks
; from quad word aligned addresses using LDM/STM.
; Since the block start address and block size may not be quad word aligned,
; the source start & source limits used by the copier are widened to quad word
; boundaries and the address and count values written to the DMAC adjusted to
; ensure only the required data are DMAed to the SBIC.
;
; Called by:
;   SCSIop_internal     - in SVC_mode, (IRQs off??)
;   int_DMAC_TC_Writing - in IRQ_mode, IRQs disabled
; Whilst copying, IRQs are enabled to allow furthur DMAC/SBIC interrupts
;
; On entry
;   R7 (rPAGESLOTptr) -> RamTxAdr
;                        RamBlkSz
;                        RamOffset
;                        RamPage
;
; On exit
;   All registers preserved
;
        ASSERT  ( RamTxAdr  < RamBlkSz )
        ASSERT  ( RamBlkSz  < RamOffset)
        ASSERT  ( RamOffset < RamPage  )
;
WriteBlkToSRAM
        Push    "R0,Link"
        Push    "R1-R10"

        LDMIA   rPAGESLOTptr,{R0-R3}    ; RamTxAdr,RamBlkSz,RamOffset,RamPage
        TEQ     R1,#0
        BEQ     WrBlkSRAM_20            ; No data in block, so finish

        LDR     R2,SRAMptr              ; Base address of SRAM

    [ IRQswhenwriting
;
; IRQs are enabled whilst copying, Podule Ints are disabled
;
        ;BIC    R3,R3,#Pod_EnableInts
        wrPageReg R3                    ; Select destination page
      [ readback
        LDRB    R4,PR_IntStat
      ]

        EnableIRQs2 R4
    |
        ORR     R3,R3,#Pod_EnableInts
        wrPageReg R3                    ; Select destination page
    ]
        ADD     R1,R1,R0                ; End address+1
        BIC     R0,R0,#&0F              ; Truncate to quad word boundary
WrBlkSRAM_10
        LDMIA   R0!,{R4,R6,R8,R10}      ; Four words of source data
        SplitWord R3,R4                 ; split and written as half words
        SplitWord R5,R6
        SplitWord R7,R8
        SplitWord R9,R10
        STMIA   R2!,{R3,R4, R5,R6, R7,R8, R9,R10}
        CMP     R1,R0
        BHI     WrBlkSRAM_10

WrBlkSRAM_20
        Pull    "R1-R10"

      [ IRQswhenwriting
        DisableIRQs2 R0                 ; Disable ARM IRQs

        MOV     R0,#Pod_EnableInts
        wrPageReg R0                    ; Allow Podule IRQs
      ]
        Pull    "R0,PC"


;************************************************
;       AllocateCMDslot - Allocate a command slot
;************************************************

; On exit (CC)
;   rCMDptr (R8) -> command slot
;   rCMDptr (R8)  = 0            (unable to claim slot)
;
; N.B. Should be called in SVC_mode, with interrupts enabled on entry.
;      Interrupts are disabled whilst adjusting CmdMap but restored on exit.
;
AllocateCMDslot

        LDR     rCMDptr,CmdMap
        TEQ     rCMDptr,#0
        MOVEQ   PC,Link                 ; No free slots, return 0
;
; There seems to be at least one slot free, so disable interrupts whilst
; trying to claim it.
;
        Push    "Link"

        PHPSEI  ,rCMDptr

        LDR     rCMDptr,CmdMap          ; Reload incase its changed under interrupt
        TEQ     rCMDptr,#0
        BNE     %FT10
        PLP
        Pull    "PC"                    ; No free slots, return 0, restore IRQ state
10

;Scan CmdMap for first slot (first bit set), claim it, find the slot address

        Push    "R5,R6"

        MOV     R6,rCMDptr              ; LDR R6,CmdMap
        MOV     R5,#1
        ADR     rCMDptr,Cmd0

Allo_Cmd_10
        TST     R6,R5
        BNE     Allo_Cmd_20
        ADD     rCMDptr,rCMDptr,#:INDEX:CmdRecSize
        MOV     R5,R5,LSL #1
        B       Allo_Cmd_10             ; CmdMap<>0, so does terminate

Allo_Cmd_20
        BIC     R6,R6,R5
        STR     R6,CmdMap               ; Claim page

        MOV     R5,#0
        STR     R5,CmdNxt               ; Play safe, zero the link now!

        LDR     R5,PendingCnt
        ADD     R5,R5,#1                ; One more command for this device
        STR     R5,PendingCnt

        LDR     R5,OperationID          ; 
        STR     R5,CmdOpID              ; Unique identification
        ADD     R5,R5,#1                ; 
        STR     R5,OperationID          ; 

        PLP
        Pull    "R5,R6,PC"              ; Slot address in rCMDptr, restore IRQ state

;************************************************
;       DeAllocateCMDSlot
;************************************************

; On entry
;   rCMDptr (R8) -> command slot
;
; On exit
;   rCMDptr (R8) corrupt
;
; N.B. Called in IRQ_mode with IRQs disabled or SVC_mode where IRQs may be
;      enabled. Routine disables interrupts whilst adjusting CmdMap, but
;      restores interrupt state on exit.
;
DeAllocateCMDslot
        Push    "R0,Link"

        ADR     R0,Cmd0
        SUB     R0,rCMDptr,R0               ; gives slot number*CmdRecSize
        MOV     R0,R0,LSR #Log2CMDRECSIZE   ; gives slot number (ie bit position)
        MOV     rCMDptr,#1
        MOV     rCMDptr,rCMDptr, LSL R0     ; bit mask for CmdMap

; Disable IRQs.
; If in IRQ_mode, IRQs are already disabled, so use of Link is safe.
        PHPSEI  ,R0

        LDR     R0,CmdMap
        ORR     R0,R0,rCMDptr           ; Free the slot
        STR     R0,CmdMap

        LDR     R0,PendingCnt
        SUB     R0,R0,#1                ; One less command for this device
        STR     R0,PendingCnt

        PLP
        Pull    "R0,PC"                 ; Return, restoring int state


;************************************************
;       QueueCMDslot - Add a command to the end of the command queue
;************************************************

; On entry
;   rCMDptr (R8) -> command slot
;
; N.B. Routine disables interrupts whilst adding to command chain,
;      but restores interrupt state on exit.
;
;      The CmdNxt field is assumed to be zero and IS NOT zeroed by this routine
;      This is to allow a chain of commands to be added, (not used currently,
;      might be usefull later).
;
QueueCMDslot
        Push    "R0,R1,R14"

        PHPSEI  ,R0                     ; Stores old state in r14, corrupts R0

        ADR     R0,FirstCmd             ; Pretend FirstCmd is a CmdNxt field
        SUB     R0,R0,#:INDEX: CmdNxt   ; then chain along list looking for
Que_C_10
        LDR     R1,[R0,#:INDEX: CmdNxt] ; the last record (CmdNxt field = 0)
        TEQ     R1,#0
        MOVNE   R0,R1
        BNE     Que_C_10
        ;R0     -> last CmdRec (or FirstCmd-CmdNxt)
        STR     rCMDptr,[R0,#:INDEX: CmdNxt]        ; Add entry to end of list

        PLP                             ; Restore int state
        Pull    "R0,R1,PC"              ; Return


;************************************************
;       UnQueueCMDslot - Remove a command from the command queue
;************************************************

; On entry
;   rCMDptr (R8) -> command slot
;
; N.B. Since commands may complete (or be aborted) in any order, this routine
;      will remove a command from anywhere in the chain, altering preceding
;      links as needed.
;
;      Routine disables interrupts whilst altering the command chain,
;      but restores interrupt state on exit.
;
UnQueueCMDslot
        Push    "R0,R1,Link"

        PHPSEI  ,R0                     ; Stores old state in r14, corrupts R0
        ADR     R0,FirstCmd             ; Pretend FirstCmd is a CmdNxt field
        SUB     R0,R0,#:INDEX: CmdNxt   ; then chain along list looking for
UQue_C_10
        LDR     R1,[R0,#:INDEX: CmdNxt] ; the record whose CmdNxt field points
      [ debug
        CMP     R1,#0                   ; Error, reached end of queue without finding
        SWIEQ   &17                     ; required cmd slot.
      ]
        CMP     R1,rCMDptr              ; at the record to be removed.
        MOVNE   R0,R1
        BNE     UQue_C_10

        LDR     R1,CmdNxt               ; Replace the link to us with our
        STR     R1,[R0,#:INDEX: CmdNxt] ; CmdNxt link.

        PLP                             ; Restore int state
        Pull    "R0,R1,PC"              ; Return


;************************************************
;       NextCommand - Find the first/next executable queued command
;************************************************

; Commands are linked in chronological order, scan the command queue for the
; earliest non-executing command (ie WAITING,INITIALISING,READY), if the
; CmdStat is :-
;
;   WAITING      - The command may be started. As long no other command is
;                  active on its target. Return a pointer to it.
;   INITIALISING - The Command was interrupted whilst being started (usually
;                  when writing data to the SRAM), by a target reselecting.
;                  The target had completed its command and went IDLE.
;                  Returning a nil pointer, will cause a return to the copier
;                  and allow the command to start normally.
;   INITIALISED  - The Command has done all its initialisation, but found the
;                  SBIC to be busy when it tried to select the target.
;                  Return a pointer to this command, it can be started by
;                  selecting the target.
;
; On exit
;   rCMDptr  = 0 (no suitable command found)
;   rCMDptr -> command block
;
; N.B. Assumes IRQs disabled on entry.
;
NextCommand
        Push    "R0,R1,R14"
        LDR     rCMDptr,FirstCmd

        CMP     rCMDptr,#0
        BEQ     Nxt_Cmd_30              ; No commands/end of list found
Nxt_Cmd_10
        LDR     R0,CmdStat
        CMP     R0,#INITIALISING        ; We interrupted this command whilst it was
        BEQ     Nxt_Cmd_30              ; initialising, so indicate 'non found'
        ;       so it is returned to and allowed to start.
        CMP     R0,#INITIALISED
        BEQ     Nxt_Cmd_40              ; Try another select-and-transfer

        CMP     R0,#WAITING
        BNE     Nxt_Cmd_20              ; Not WAITING, so try next command block

        LDR     R1,CmdDevID
        AND     R1,R1,#maxDeviceID
        BL      AddressDevice           ; In: R1=DeviceID
        ;Out:   R1=DeviceID, R9->deviceblk
        LDR     R0,DeviStat
        CMP     R0,#IDLE                ; Found a command for a device that is IDLE,
        LDREQ   R0,Connected            ; and disconnected
        CMPEQ   R0,#0
        BEQ     Nxt_Cmd_40              ; so return it

Nxt_Cmd_20
        LDR     rCMDptr,CmdNxt          ; Examine next command block
        CMP     rCMDptr,#0
        BNE     Nxt_Cmd_10

Nxt_Cmd_30
        MOV     rCMDptr,#0
Nxt_Cmd_40
        Pull    "R0,R1,PC"


;************************************************
;       FindCommand - find the command that matches a given OpID
;************************************************

; On entry
;   R2  = OperationID
;
; On exit
;   rCMDptr (R8)  = 0 (command not found)
;   rCMDptr (R8) -> command block
;
; N.B. Assumes IRQs disabled on entry.
;
FindCommand
        Push    "R0,Link"
        LDR     rCMDptr,FirstCmd
        CMP     rCMDptr,#0
        BEQ     Fnd_Cmd_20              ; No commands/end of list found
Fnd_Cmd_10
        LDR     R0,CmdOpID
        CMP     R0,R2
        BEQ     Fnd_Cmd_20              ; CmdOpID matches

        LDR     rCMDptr,CmdNxt          ; Examine next command block
        CMP     rCMDptr,#0
        BNE     Fnd_Cmd_10              ; Loop checking CmdOpIDs until
        ;       end of list found
Fnd_Cmd_20
        Pull    "R0,PC"


;************************************************
;       AllocateRAM - Allocate another SRAM page & associated RamRec
;************************************************

; Returns CC if successfull, CS for fail
;
; On exit (CC)
;   R7 (rPAGESLOTptr) -> RamRec
;
;   RamRec.RamPage     = slotnumber (0..15)
;
; On exit (CS)
;   R7 corrupt
;
; N.B. Interrupts MUST BE disabled whilst adjusting RamMap
;
        ASSERT  ((:INDEX:RamRecSize) = 16)
        ASSERT  (R7 = rPAGESLOTptr)
;
AllocateRAM
        Push    "R6,R8"
        LDR     R6,RamMap
      [ efficient
        MOV     R7,#PAGECOUNT-1         ; Not a bug, just more efficient
      |
        MOV     R7,#PAGECOUNT           ;
      ]
        MOV     R8,#1
Alloc_10
        TST     R6,R8,LSL R7
        BNE     Alloc_20                ; Slot R7 is free
        SUBS    R7,R7,#1
        BGE     Alloc_10

        Pull    "R6,R8"
        SEC
        MOV     PC,Link

Alloc_20
        BIC     R6,R6,R8,LSL R7
        STR     R6,RamMap               ; Claim slot

        MOV     R8,R7                   ; Slotnumber
        ADR     R7,Ram0
        ASSERT  (:INDEX: RamRecSize = 16)
        ADD     R7,R7,R8,LSL #4         ; R7:=Adr(Ram0)+SlotNumber*RamRecSize
        STR     R8,RamPage

        Pull    "R6,R8"
        CLC
        MOV     PC,Link


;************************************************
;       DeAllocateRAM
;************************************************

; On entry
;   R7 (rPAGESLOTptr) -> RamRec
;
;   RamRec.RamPage     = Slot number (0..15)
;
; N.B. Interrupts MUST BE disabled whilst adjusting RamMap
;
DeAllocateRAM
        Push    "R0-R2,Link"
        SavePSR Link
        LDR     R0,RamMap
        LDR     R2,RamPage
        CMP     R2,#PANICPAGE           ; Don't deallocate the sink/source junk page
        BEQ     DeAll_10

        MOV     R1,#1
        ORR     R0,R0,R1,LSL R2
        STR     R0,RamMap
DeAll_10
        RestPSR Link,,f
        Pull    "R0-R2,PC"


FillJunkSlot
        Push    "R0-R3"
        ADR     R7,(Ram0+(PANICPAGE * :INDEX: RamRecSize))
        MOV     R0,#&80000000           ; Give Naff address and
        MOV     R1,#0                   ; zero BlkSz to indicate sink/source
        MOV     R2,#0                   ; junk (for overrun)
        MOV     R3,#PANICPAGE
        STMIA   rPAGESLOTptr,{R0-R3}    ; Adr,BlkSz,Offset,Page
        Pull    "R0-R3"
        MOV     PC,Link



;
; Calculate transfer block size, which is MIN(PAGESIZE,transfer size), if the
; transfer address isn't on a QuadWord boundary, reduce the block size and
; offset the DMAC address to allow QuadWord aligned LDM/STM copies between
; main RAM & SRAM.
;
; On entry
;   R7 (rPAGESLOTptr) -> RamRec
;
;   RamRec.RamPage     = Slot number (0..15)
;
; On exit
;   All registers preserved
;
;   RamRec.RamTxAdr    }
;   RamRec.RamBlkSz    } Filled in
;   RamRec.RamOffset   }
;
;
FillSlot
        Push    "R0,R2,R3,R4,R5,R6"
        ADR     R0,CurrentPointers
FilSlt_01
        LDR     R2,[R0,#TtlCnt]
        LDR     R3,[R0,#EntAdr]
        LDR     R4,[R0,#EntCnt]

        TEQ     R4,#0
        BNE     FilSlt_10
FilSlt_05
        LDR     R5,[R0,#ScatPtr]        ; Scatter list entry exhausted,
        LDMIA   R5 !,{R3,R4}            ; so use next one
        STR     R5,[R0,#ScatPtr]
        STR     R3,[R0,#EntAdr]
        STR     R4,[R0,#EntCnt]

FilSlt_10

      [ counts
        Push    "R0"
        ADRL    R0, MyInfoSpace1
        STR     R2, [R0, #52]           ; TtlCnt
        STR     R5, [R0, #56]           ; ScatPtr
        STR     R4, [R0, #60]           ; EntCnt
        STR     R3, [R0, #64]           ; EntAdr
        Pull    "R0"
      ]

        MOV     R5,#PAGESIZE
        AND     R6,R3,#&0F              ; DMAC address offset (0..15)
        SUB     R5,R5,R6                ; Block size is PAGESIZE-(0..15)
        CMP     R5,R4
        MOVGT   R5,R4                   ; BlockSize:=MIN(PAGESIZE,EntCnt)
        CMP     R5,R2
        MOVGT   R5,R2                   ; BlockSize:=MIN(BlockSize,TtlCnt)

        ASSERT  ( RamTxAdr  < RamBlkSz )
        ASSERT  ( RamBlkSz  < RamOffset)
        ASSERT  ( RamOffset < RamPage  )
        STMIA   rPAGESLOTptr,{R3,R5,R6} ; Adr,BlkSz,Offset,Page

FilSlt_20
        Pull    "R0,R2,R3,R4,R5,R6"
        MOV     PC,Link

FillFutureSlot
        Push    "R0,R2,R3,R4,R5,R6"
        ADR     R0,FuturePointers
        B       FilSlt_01


AdvanceCurrentPointers
        Push    "R0,R2,R3,R4,R5,R6,R7"
        ADR     R0,CurrentPointers

AdvCurPtr_05
        LDMIA   rPAGESLOTptr,{R3,R5,R6} ; Adr,BlkSz,Offset
        LDR     R2,RamPage
        CMP     R2,#PANICPAGE
        BEQ     AdvCurPtr_10

        LDR     R2,[R0,#TtlCnt]
        LDR     R3,[R0,#EntAdr]
        LDR     R4,[R0,#EntCnt]
      [ debug
        CMP     R2,#0
        LDRLT   R14,[R2]
      ]
        SUB     R2,R2,R5                ; Size of rest of transfer
        ADD     R3,R3,R5                ; Address of rest of transfer
        SUB     R4,R4,R5                ; Size of rest of transfer (this scatter entry)
      [ debug
        CMP     R2,#0
        LDRLT   R14,[R2]
      ]
        STR     R2,[R0,#TtlCnt]
        STR     R3,[R0,#EntAdr]
        STR     R4,[R0,#EntCnt]
AdvCurPtr_10
        Pull    "R0,R2,R3,R4,R5,R6,R7"
        MOV     PC,Link


AdvanceFuturePointers
        Push    "R0,R2,R3,R4,R5,R6,R7"
        ADR     R0,FuturePointers
        B       AdvCurPtr_05


AdvanceSavedPointers
        Push    "R0,R2,R3,R4,R5,R6,R7"
        ADR     R0,SavedPointers
        B       AdvCurPtr_05


SaveCurrentPointers_UseHold
        Push    "R0,Link"
        LDR     R0,HoldCount
        wrSBIC24 R0,SR_Count
        Pull    "R0,Link"
SaveCurrentPointers

        Push    "R0-R4,R7,Link"

        ADR     R0,CurrentPointers      ; Assign CurrentPointers to SavedPointers
        LDMIA   R0,{R1,R2,R3,R4}        ; 
        ADR     R0,SavedPointers        ; 
        STMIA   R0,{R1,R2,R3,R4}        ; 

      [ bugfix9
        LDR     R0,CpyCtl
        TST     R0,#CTL_TXWRITE
        BNE     SavCurPtr_50
      ]

SavCurPtr_10
        LDR     R0,DMACStat
        CMP     R0,#RUNNING
        BNE     SavCurPtr_20

        LDR     R4,CurrTtlCnt
        TEQ     R4,#0
        BEQ     SavCurPtr_20

        rdSBIC24 R0,SR_Count            ; Number of bytes not transfered
        SUBS    R4,R4,R0                ; Number of bytes transfered in this block

        LDR     R7,DMACram
        LDMIA   R7,{R0,R1,R2,R3}        ; RamTxAdr,RamBlkSz,RamOffset,RamPage

        Push    "R0-R3"

        ADD     R0,R0,R4                ; Advance RamTxAdr
        SUB     R1,R1,R4                ; Reduce RamBlkSz
        ADD     R2,R2,R4                ; Advance RamOffset
        Push    "R0-R3"                 ; Push for later use

        STR     R4,RamBlkSz             ; Patch record to indicate amount
        BL      AdvanceSavedPointers    ; actually transfered, advance pointers
        Pull    "R0-R3"

        STMIA   R7,{R0,R1,R2,R3}        ; Put back the adjusted record

        LDR     R0,CpyCtl
        TST     R0,#CTL_TXWRITE
        BLNE    ResetDMAC
        MOVNE   R0,#dma_wr_mode
        BLNE    ArmDMAC

        Pull    "R0-R3"

        STMIA   R7,{R0,R1,R2,R3}        ; Put back the original record
SavCurPtr_20

        Pull    "R0-R4,R7,PC"

      [ bugfix9

SavCurPtr_50

        LDR     R4,CurrTtlCnt
        rdSBIC24 R0,SR_Count            ; Number of bytes not transfered
        SUBS    R4,R4,R0                ; Number of bytes transfered in this block
        BGE     SavCurPtr_10

;
; R4 is negative, -R4 is the number of bytes from the end of the previous
; lump that have been thrown away by the SBIC flushing its FIFO
;

        ADR     R0,SavdEntAdr
        LDMIA   R0,{R1,R2,R3}           ; EntAdr,EntCnt,TtlCnt

        ADD     R1,R1,R4                ; SavdEntAdr += R4
        SUB     R2,R2,R4                ; SavdEntCnt -= R4
        SUB     R3,R3,R4                ; SavdTtlCnt -= R4

        STMIA   R0,{R1,R2,R3}           ; EntAdr,EntCnt,TtlCnt

        Pull    "R0-R4,R7,Link",AL      ; Pull back the saved registers and
        ;       drop into...
      ]

RestoreCurrentPointers
        Push    "R0-R4,Link"

        BL      StopDataTX

        LDR     R1,SavdScatPtr
        LDR     R2,SavdEntAdr
        LDR     R3,SavdEntCnt
        LDR     R4,SavdTtlCnt

        STR     R1,CurrScatPtr
        STR     R2,CurrEntAdr
        STR     R3,CurrEntCnt
        STR     R4,CurrTtlCnt

        wrSBIC24 R4,SR_Count            ; Number of bytes left to transfer

        LDR     R0,CpyCtl
        TST     R0,#(CTL_TXREAD :OR: CTL_TXWRITE)
        BEQ     ResCurPtr_20
        TST     R0,#CTL_TXREAD
        BEQ     ResCurPtr_10


;
; Reading - claim a page of SRAM for the DMAC to fill
;
        MOV     R3,#STALLED
        STR     R3,DMACStat
      [ bugfix3
        LDR     R0,CopyStat             ; If Copier is RUNNING, don't disturb it,
        CMP     R0,#RUNNING             ; if not, mark it as STALLED, ready to
        STRNE   R3,CopyStat             ; try a restart
      ]
        BL      AllocateRAM             ; Out CC & R7 (rPAGESLOTptr) ->RamRec
        BCS     ResCurPtr_20            ;    CS for failed

        STR     R7,DMACram              ; DMAC will queue this when its full
        BL      FillSlot                ; In/Out: R7->RamRec
        MOV     R0,#dma_rd_mode         ; &04 demand mode,read
        BL      ArmDMAC                 ; In/Out: R7->RamRec
        B       ResCurPtr_20

;
; Writing
;
ResCurPtr_10
        MOV     R3,#STALLED             ; Put DMAC into stalled state (had been IDLEd by
        STR     R3,DMACStat             ; StopDataTx)
        LDR     R0,CopyStat             ; If Copier is RUNNING, don't disturb it,
        CMP     R0,#RUNNING             ; if not, mark it as STALLED, ready to
        STRNE   R3,CopyStat             ; try a restart
        BL      Restart_DMAC_Writing
ResCurPtr_20
        Pull    "R0-R4,PC"



;
; If a SBIC phase change occurs whilst the DMAC is running are left with a
; slot (DMACram) partialy filled with useful data.
; The missing data is CpyFail-CurrTtlCnt (the untransfered byte count read
; from the SBIC - the total size of slots yet to be transfered).
; The RamBlkSz needs adjusting to show the actual number of bytes in it
; prior to adding it to the queue.
;
; If RamBlkSz is zero, we are sinking/sourcing unwanted data,
;  so DO NOTHING to the block.
; A genuine block should have RamBlkSz non-zero, but the above won't cause
; a problem
;
; On entry
;   R7 (rPAGESLOTptr) -> RamRec
;   RamRec.RamBlkSz = Number of bytes we tried
;
; On exit
;   RamRec.RamBlkSz = Number of bytes actually transfered
;
AdjustSlot
        Push    "R0,R1"

        LDR     R0,CurrTtlCnt
        LDR     R1,CpyFail
        SUB     R1,R0,R1                ; Number of bytes actually transfered
        LDR     R0,RamBlkSz
        TEQ     R0,#0                   ; If not sinking/sourcing junk,
        STRNE   R1,RamBlkSz
        Pull    "R0,R1"
        MOV     PC,Link

;************************************************
;       QueueSlot
;************************************************

; Add ->RamRec to QEnd then advance QEnd.
;
; N.B. The maximum number of queue entries is PAGECOUNT (16), since the
;      queue is PAGECOUNT+4 positions in length, it can NEVER overflow.
;
; On entry
;   R7 (rPAGESLOTptr) -> RamRec
;
QueueSlot
        Push    "R0"
        LDR     R0,QEnd
        STR     R7,[rDEVICEptr,R0]      ; Write ->RamRec at QEnd
        ADD     R0,R0,#4                ; Advance QEnd
        CMP     R0,#:INDEX:QueuePastIt
        MOVHS   R0,#:INDEX:Queue0       ; It's a wrap
        STR     R0,QEnd
        Pull    "R0"
        MOV     PC,Link

;************************************************
;       UnQueueSlot
;************************************************

; Read ->RamRec from QStart then advance QStart.
;
; On exit
;   R7 (rPAGESLOTptr) -> RamRec
;
        ASSERT  ((:INDEX:RamRecSize) = 16)
        ASSERT  (R7 = rPAGESLOTptr)
;
UnQueueSlot
        Push    R8
        LDR     R8, QStart
        LDR     R7, [rDEVICEptr,R8]     ; Read ->RamRec from QStart
        ADD     R8, R8, #4              ; Advance QStart
        CMP     R8, #:INDEX:QueuePastIt
        MOVHS   R8, #:INDEX:Queue0      ; Wrap round
        STR     R8, QStart
        Pull    R8
        MOV     PC, Link

;************************************************
;       FlushQueue
;************************************************

; DeAllocate each slot in the Queue
;
FlushQueue
        Push    "R0,R1,Link"
Flu_Qu_10
        LDR     R0, QStart
        LDR     R1, QEnd
        CMP     R0, R1
        BLNE    UnQueueSlot             ; Out R8->RamRec
        BLNE    DeAllocateRAM
        BNE     Flu_Qu_10
        Pull    "R0,R1,PC"


;************************************************
;       ArmDMAC
;************************************************

; On entry
;   R0                 = dma_rd_mode or dma_wr_mode
;   R7 (rPAGESLOTptr) -> RamRec
;
ArmDMAC
        Push    "R0,R3,R5,R6,R7"

        LDMIA   rPAGESLOTptr, {R3,R5,R6,R7}     ; TxAdr,BlkSz,Offset,Page
        wrDMAC  R0, DR_ModeCon

        CMP     R7,#PANICPAGE
        MOVEQ   R6, #0
        MOVEQ   R5, #PAGESIZE

      [ {FALSE}
        CMP     R0, #dma_wr_mode        ; If we are writing to the target
        BNE     ArmDMAC_01

ArmDMAC_01
      ]

;>>>                            ;Crude count & address initialisation
        SUB     R5, R5, #1              ; DMAC wants BlkSize-1 !!
        wrDMAC  R5, DR_TxCntLo
        MOV     R5, R5, LSR #8
        wrDMAC  R5, DR_TxCntHi

        ADD     R0, R6, R7, LSL #Log2PAGESIZE
        wrDMAC  R0, DR_TxAdrLo          ; DMAC address is Slot*PAGESIZE+Offset
        MOV     R0, R0, LSR #8
        wrDMAC  R0, DR_TxAdrMd
        MOV     R0, R0, LSR #8
        wrDMAC  R0, DR_TxAdrHi

        MOV     R0, #clr_mask           ; &0E
        wrDMAC  R0, DR_Mask

        MOV     R0, #RUNNING            ; Restart the DMAC
        STR     R0, DMACStat

        Pull    "R0,R3,R5,R6,R7"
        MOV     PC, Link



;
; On entry
;   R1 = deviceID
;
DoAddressCard
        AND     R10,R1,#CardIDMask
        MOV     R10,R10,LSR #CardIDShft
        LDR     R11,maxCardID           ; >>>Note gives "Invalid device ID"
        CMP     R10,R11                 ; >>>Not really worth a different
        BHI     err_BadDevID            ; >>>message

        MOV     R11,#((:INDEX: Cardworkspacesize)     :AND: &000000FF)
        ORR     R11,R11,#((:INDEX: Cardworkspacesize) :AND: &FFFFFF00)
        MUL     R10,R11,R10
        ADR     WsPtr,LogicalCard0
        ADD     WsPtr,WsPtr,R10

        BIC     R1,R1,#CardIDMask
        MOV     PC,Link


;
; DoForEachCard
;
; On entry
;   R6 = Address of routine to execute
;
DoForEachCard
        Push    "R4-R6,WsPtr,Link"

        ASSERT  (:INDEX:PODULEptr)=4
        ASSERT  (:INDEX:DMACptr)=8

        LDR     R4,maxCardID
        ADR     R5,ListEntry0           ; ->PoduleBase address
        ADR     WsPtr,LogicalCard0      ; ->CardWs
        CMP     R4,#0
        BMI     DoForEac_20
DoForEac_10
        Push    "R4-R6,WsPtr"

        LDR     R5,[R5]                           ; Podule base address
        LDMIB   WsPtr,{rPODULEptr,rDMACptr}       ; Card hardware addresses
        MOV     Link,PC
        MOV     PC,R6

        Pull    "R4-R6,WsPtr"
        ADD     WsPtr,WsPtr,#((:INDEX: Cardworkspacesize) :AND: &000000FF)
        ADD     WsPtr,WsPtr,#((:INDEX: Cardworkspacesize) :AND: &FFFFFF00)
        ADD     R5,R5,#4
        SUBS    R4,R4,#1
        BGE     DoForEac_10
DoForEac_20
        Pull    "R4-R6,WsPtr,PC"


      [ doEscapeCheck
;
; TestEscapeStatus
;
; On entry
;   R0 = CmdDevID of foreground command
;   R2 = CmdOpID of foreground command (used to abort it)
;
; On exit (escape clear)
;   All registers preserved
;
; On exit (escape set)
;   R0 = R0 ORed with CTL_DOINGESCAPEDEVICE
;
TestEscapeStatus
        Push    LR
        SWI     XOS_ReadEscapeState
        Pull    PC,CC                   ; Escape not pressed, so return

        ORR     R0,R0,#CTL_DOINGESCAPEDEVICE
        Push    "R0,R1,R2"
        MOV     R1,#CTL_DOINGESCAPEDEVICE    ; Try to abort,
        BL      RaiseATN                     ; if it works, report esacpe
        Pull    "R0,R1,R2,PC"
      ]

;
; RaiseATN - Try to send the target a message
;
; On entry
;   R1 = Reason for raising ATN
;   R2 = OperationID
RaiseATN
        mess    ,"RaiseATN",NL
        Push    "R0-R3,rCMDptr,rDEVICEptr,Link"

        PHPSEI  R3,R0

        BL      FindCommand
        CMP     rCMDptr,#0
        BEQ     Rai_ATN_10              ; Quit if command not found

        LDR     R2,CmdDevID
        TST     R2,R1
        BNE     Rai_ATN_10              ; Quit if ATN already raised for this reason

        ORR     R2,R2,R1
        STR     R2,CmdDevID             ; Mark Cmd to prevent furthur tries

        LDR     R0,CmdStat
        CMP     R0,#RUNNING
        BNE     Rai_ATN_10              ; Can't raise ATN on a non-running command

        ;LDR    R2,CmdDevID
        AND     R1,R2,#maxDeviceID
        BL      AddressDevice           ; In: R1=DeviceID
        ;Out:   R1=DeviceID, R9->deviceblk
        LDR     R0,DeviStat
        CMP     R0,#RUNNING
        BNE     Rai_ATN_10              ; Quit if device not running
        LDR     R0,Connected
        CMP     R0,#0                   ; or if disconnected
        BEQ     Rai_ATN_10              ; 

        rdSBIC  R0,SR_Command           ; Safer not to disturb SBIC
        CMP     R0,#SC_Sel_Tx_withATN   ; if in overrunning
        CMPNE   R0,#SC_Sel_Tx_woATN     ; or doing closing status/message
        BNE     Rai_ATN_10              ; transfers

;
; SBIC seems to be connected to the required Target
;
    [ doAssertATN
      [ {TRUE}
        rdSBIC  R2,SR_Phase
        BL      nCIP_wait               ; <<<<
      ]
        MOV     R1,#SC_AssertATN        ; So, TRY to attract its attention
        wrSBIC  R1,SR_Command

      [ {TRUE}
        BL      nCIP_wait               ; <<<<
        wrSBIC  R2,SR_Phase
      ]
        wrSBIC  R0,SR_Command           ; Put the previous command back >>>>doesn't work

    ]
Rai_ATN_10
        PLP     R3
        Pull    "R0-R3,rCMDptr,rDEVICEptr,PC"



      [ useTickerV
;
; Entered in IRQ mode, all registers must be preserved
;
MyTickerV
        Push    "R0-R2,R8-R11,Link"

        LDMIA   WsPtr,{rDEVICEptr, rPODULEptr,rDMACptr}  ; R9,R10,R11

        TEQ     rDEVICEptr,#0           ; Quit if no device registered
        BEQ     MyTick_10               ; 

        LDR     R0,DeviStat             ; Quit if not yet, or just finished
        CMP     R0,#RUNNING             ; running
        BNE     MyTick_10               ; 
;
; Timeout > 0 timer running, times out on 1->0
;         = 0 timer not running or timed out on last tick
;         < 0 timer not running
;
        LDR     R0,Timeout              ; Quit if not running, or already timed out
        CMP     R0,#0                   ; 
        BLE     MyTick_10               ; 

        SUBS    R0,R0,#1
        STR     R0,Timeout
;
; Timer went 1->0 so try to abort the command
;
        LDREQ   rCMDptr,CMDptr          ; (R8)Pointer to command >>>kosha???
        MOVEQ   R1,#CTL_DOINGTIMEOUT2   ; Try to abort,
        LDREQ   R2,CmdOpID              ;
        BLEQ    RaiseATN                ; if it works, report device timeout
MyTick_10
        Pull    "R0-R2,R8-R11,PC"
      ]


    [ bugfix6
      [ {TRUE}
      |
gobang
        SWI     OS_WriteS
        =       "LCI bit failed"
        =       CR,LF
        =       0
        ALIGN
        MOV     R14,#-1
        LDR     R14,[R14]
      ]
    ]

    [ SQ555kludge
        LTORG
int_ser_SQ555
        LDR     R0,HostStat1
        AND     R0,R0,#&0F
        CMP     R0,#&0F
        LDREQ   R0,MessageIn
        CMPEQ   R0,#MESSAGE_COMMANDCOMPLETE
        BNE     int_ser_49
;
; pretend the MessageIn paused happened
;
        MOV     R0,#IDLE
        STR     R0,SBICStat             ; SBIC now completed
      [ bugfix2
;
; Since command has completed, theres no point allowing
; 'Escape','AbortOp' or 'Timeout2' to send an abort message
;
        MOV     R0,#CTL_Suppress
        STR     R0,Suppress
      ]
        B       int_ser_50              ; Then treat like an expected disconnection

    ]

        END
@


4.8
log
@Update SCSI podule driver for more recent SCSI switchers
The SCSISoftWD33C93 driver was used as a test bed for the SCSI switcher, but a typo in the supported features mask meant that it didn't work any longer after SCSI switch 2.01 (version 2.00 didn't check the features mask, hence it worked).
Makefile
* Can now produce either SCSILog or standalone SCSIDriver or SCSISoft module, based on the TARGET and/or COMPONENT
SCSIEquates
* Shuffle some common equates around so the same header can be used with SCSILog and SCSIDriver
SCSIMacros
* A cut and paste fumble meant the DisableIRQs macro actually left them enabled
* Lined up
SCSIDriver
* Changed to accept podule numbers 0-7 for Risc PC (was 0-3)
* Get the base address from Podule manager rather than IOC era logical addresses
* Chopped out some long redundant switches
* Use PSR manipulation macros to allow 26 or 26/32 or 32 bit compatible variants
* Fix typo in features mask to &22 (was &21)
* Use PLP after PHPSEI rather than RestPSR, the preserve value from PHPSEI is not guaranteed RestPSR compatible
* Don't re-register a second time on Service_Reset, this is not needed in the loaded-from-ROM; loaded-from-disc; or reinit cases (since the module initialisation already registers), and don't wipe the workspace when a client to SCSI switcher (it get's very confused as transactions are in play)
SCSILog
* Delete defines now taken from SCSIEquates
* Get the base address from Podule manager rather than IOC era logical addresses
* Changed to accept podule numbers 0-7 for Risc PC (was 0-3)

Requires HdrSrc-2_32
Tested on AKA31 podule, on a StrongARM RISC OS 3.70, and a StrongARM RISC OS 5.20, in both SCSISoftWD33C93 and SCSIDriver configurations connected to a CD-ROM drive and harddisc, copying the contents of a random CD onto the harddisc.

Version 1.18. Tagged as 'SCSIDriver-1_18'
@
text
@d160 1
d221 1
a221 1
        Command Devices, 0,0
d228 2
a229 2
Devices_Help
        DCB     "*Devices lists type, capacity and vendor details of "
d232 2
a233 2
Devices_Syntax
        DCB     "Syntax: *Devices"
d237 1
a237 1
Devices_Code
d320 1
a320 1
; Format of display by *Devices
d424 5
d465 8
@


4.7
log
@Knocked columns into line
SCSIDriver: conventional columns used via automated tidier, assembles to same binary (not tested)
SCSILoader: made 32 bit compatible, no longer peeks IRQsema, tested briefly in a podule
SCSILog: conventional columns used via automated tider, assembles to same binary (not tested)

Version 1.16. Tagged as 'SCSIDriver-1_16'
@
text
@a29 2
        GBLL    preserveWSoverreset
        GBLL    SQ555kludge
d34 7
a40 9
DString             SETS " - Debugging version"
counts              SETL {FALSE}
trace               SETL {TRUE}
preserveWSoverreset SETL {FALSE}
      |
DString             SETS ""
counts              SETL {FALSE}
trace               SETL {FALSE}        ; Must be false for release
preserveWSoverreset SETL {FALSE}        ; Must be false for release
a42 1

d46 1
a46 1

d57 1
a57 1
                GBLL HAL
d60 1
d62 2
a63 2
soft            SETL {TRUE}

d87 1
a87 1
                GBLL BigCapacity
a122 7
                GET Version

;
; Driver AMRed as V 1.01 (26 Oct 89), the following bugs have been
; found and fixed since then.
;

d124 1
a124 1
bugfix10        SETL Version >= 102     ; not a group 0,1 or 5 command.
d127 1
a127 1
efficient       SETL Version >= 104
d130 1
a130 1
bugfix11        SETL Version >= 104
d133 1
a133 1
bugfix12        SETL Version >= 104
d136 1
a136 1
bugfix13        SETL Version >= 104     ; Restart_DMAC_Writing when queue
d161 1
d163 1
a163 1

d199 1
a199 1
        DCB     "SCSISoftWD33C93",&09,"$VString ($Date)$DString",0
d207 1
a207 1
        DCB     "SCSIDriver",&09,"$VString ($Date)$DString",0
d218 1
a218 1
    [ :LNOT: soft
d229 1
a229 1
        DCB     "attatched SCSI devices"
d293 1
a293 1
        MOV     R0,#3
d354 1
a354 1
HostRevision    DCB VString
d472 1
a472 1
        SUBS    R3,R0,#"0"              ; Accept "0"..."9",
d474 2
a475 2
        CMP     R3,#9                   ; or unspecified is podule zero).
        MOVGT   R3,#0                   ; 
d477 2
a478 2
        BICVC   R11,R3,#&FF
        BICVC   R11,R11,#&300           ; Zap the CMOS RAM base
d481 1
a481 2
        TEQ     R11,#0
        SUBNE   R11,R11,#PoduleSpeedMask  ; Reduce to slow access address from sync.
a560 4
        ADR     R0,ErrorBlock_SCSI_WrongMEMC +4     ; Print the error to ensure
        SWI     XOS_Write0                          ; it is'nt hidden from user
        SWI     XOS_NewLine                         ; 

d694 3
a696 1
      [ preserveWSoverreset
a699 3
      [ soft
        ForEachCard RegisterCard
      ]
d741 1
a741 1
        B       HostDescEntry           ; Return host description (only used is buses are supported, as here)
d2561 1
a2561 1
        MOV     R8,#0
d2841 1
a2841 1
        MOV     R8,#0
d2847 1
a2847 8
      [ No32bitCode
        MOV     R14,PC                     ; Hold current I_bit & F_bit
        TEQP    PC,#I_bit+F_bit+SVC_mode   ; Disable IRQs & FIRQs
      |
        MRS     R14,CPSR                   ; Hold current I_bit & F_bit
        ORR     R1,R14,#I32_bit+F32_bit
        MSR     CPSR_c,R1                  ; Disable IRQs & FIRQs
      ]
d2852 1
a2852 7
      [ No32bitCode
        TEQP    PC,R14                     ; Restore original I_bit & F_bit
        NOP
        NOP
      |
        MSR     CPSR_c,R14                 ; Restore original I_bit & F_bit
      ]
a2853 1

d2904 1
a2904 1
        ADD     R3,R5,#PoduleSpeedMask  ; Sync base (for Iyonix)
d3005 1
a3005 1
        MOV     R1,#&21                 ; Features mask supported by this driver (see documentation)
d3030 1
a3030 1
10      LDR R4,[R2],#4
d3158 1
a3158 2
        STMDA   R1,{R3,R4,R5,R6,R7}     ; CmdXferPtr,CmdXferLen,CmdTimeout,
        ;       CmdCallbackAdr,CmdCallbackR12
d4996 1
a4996 1
10      CMP R1,#TARGET_ESCAPED
d5031 1
a5031 1
10      CMP R0,#TARGET_BUSY
d5128 1
a5128 1
    ] ; :LNOT: soft
a5157 1
do_callback_clrR2
d5164 1
a5164 1
        TEQ     R5,#0                   ; 
d5212 1
a5212 1
        ;       V flag is preserved from entry to no_callback
d5763 1
a5763 1
        STMIA   R0!,{R4}
d6030 1
a6030 1
        LDR     R1,[R0,#:INDEX: CmdNxt] ; the record whoes CmdNxt field points
d6784 1
a6784 1
        RestPSR R3,,cf
@


4.6
log
@Update to work with zero page relocation
Detail:
  s/SCSIDriver - Use OS_ReadEscapeState instead of checking ESC_Status manually
  hdr/SCSIEquates - Get rid of obsolete EscapeBit definition
Admin:
  Tested on rev A2 BB-xM


Version 1.15. Tagged as 'SCSIDriver-1_15'
@
text
@d26 6
a31 6
                GBLS DString
                GBLL debug
                GBLL trace
                GBLL counts
                GBLL preserveWSoverreset
                GBLL SQ555kludge
d35 1
a35 1
 [ debug
d40 1
a40 1
 |
d43 3
a45 3
trace               SETL {FALSE}        ;Must be false for release
preserveWSoverreset SETL {FALSE}        ;Must be false for release
 ]
d48 1
a48 1
                GBLL disconnect         ;When true, driver defaults to allowing
d53 1
a53 1
 [ SQ555kludge
d55 1
a55 1
 [ debug
d57 1
a57 1
 |
d59 2
a60 2
 ]
 ]
d65 1
a65 1
                GBLL soft               ;When true, be a driver module for SCSISwitch
d68 1
a68 1
                GBLL testMEMC           ;When true, test for MEMC1a
d76 1
a76 1
 [ doAssertATN:LAND::LNOT:soft
d79 1
a79 1
 |
d82 1
a82 1
 ]
d94 1
a94 2

                GBLL readback           ;Read back from podule to flush writes
d97 1
a97 1
                GBLL bugfix1            ;Escape whilst reading
d100 1
a100 1
                GBLL bugfix2            ;Suppress escape & timeout if command
d103 1
a103 1
                GBLL bugfix3            ;Small xfers after a re-select failing
d106 1
a106 1
                GBLL bugfix4            ;Restore DPD bit in SR_DestID when
d109 1
a109 1
                GBLL bugfix5            ;Set ER bit in SR_SourceID when a
d112 1
a112 1
                GBLL bugfix6            ;LCI bit doesn't always work when
d115 1
a115 1
                GBLL bugfix7a           ;Indicate NO data transfered, if any
d118 1
a118 1
                GBLL bugfix7b           ;Indicate NO data transfered, if an
d121 1
a121 1
                GBLL bugfix8            ;Determine device gives -1,-1 for block
d124 1
a124 1
                GBLL bugfix9            ;Target disconnects during last
d134 1
a134 1
                GBLL bugfix10           ;Tell SBIC the CDB size incase its
d140 1
a140 1
                GBLL bugfix11           ;Check CDB size
d143 1
a143 1
                GBLL bugfix12           ;Get LUN's to work
d146 1
a146 1
                GBLL bugfix13           ;Prevent call of UnQueueSlot from
a149 4
                GBLL bugfix14           ;Show correct host revision number
bugfix14        SETL Version >= 105     ; for *Devices


d154 1
a154 1
        AREA |!!!Module|,CODE,READONLY
d158 15
a172 20
        ; Core headers
        GET Hdr:ListOpts
        GET Hdr:Macros
        GET Hdr:System

        ; Filing system related headers
        GET Hdr:FSNumbers
        GET Hdr:ModHand
        GET Hdr:Services
        GET Hdr:Proc
        GET Hdr:DevNos
        GET Hdr:Podule
        GET Hdr:NewErrors
        GET Hdr:HALEntries

        ; SCSI specific local headers
        GET Hdr:SCSI
        GET Hdr:SCSIErr
        GET Hdr:SCSIMacros  ;The macros we use
        GET Hdr:SCSIEquates ;Magic constants
d178 1
a178 1
        ASSERT (.=Module_BaseAddr)            ;Winge if we've generated code
d182 20
a201 20
        DCD 0                                 ; 0  Start - Not an application
        DCD ModInit-Module_BaseAddr           ; 4  Initialisation
        DCD ModDie-Module_BaseAddr            ; 8  Die (aka Finalisation)
        DCD ModService-Module_BaseAddr        ; C  Service
        DCD ModTitleStr-Module_BaseAddr       ; 10 Title
        DCD ModHelpStr-Module_BaseAddr        ; 14 Help string
 [ soft
        DCD 0                                 ; 18 Combined Help/* command table
        DCD 0                                 ; 1C Chunk number of SWIs intercepted
        DCD 0                                 ; 20 Offset of code to handle SWIs
        DCD 0                                 ; 24 SWI Decoding table
 |
        DCD HC_Table-Module_BaseAddr          ; 18 Combined Help/* command table
        DCD SCSI_SWIbase                      ; 1C Chunk number of SWIs intercepted (MySWIBase)
        DCD SCSI_SWIdecode-Module_BaseAddr    ; 20 Offset of code to handle SWIs (MySWIDecode)
        DCD SCSI_SWInames-Module_BaseAddr     ; 24 SWI Decoding table (MySWINames)
 ]
        DCD 0                                 ; 28 SWI Decoding code
        DCD 0                                 ; 32 Messages filename
        DCD ModFlags-Module_BaseAddr          ; 36 Flags
d203 1
a203 2
 [ {TRUE}
 [ soft
d211 1
a211 1
 |
d213 1
a213 1
        DCB     "SCSIdriver",0
d217 1
a217 1
        DCB     "SCSIdriver",&09,"$VString ($Date)$DString",0
d219 1
a219 10
 ]
 |
ModTitleStr
        DCB     "UNIXboot",0
        ALIGN

ModHelpStr
        DCB     "UNIXboot",&09,"$VString ($Date)",0
        ALIGN
 ]
d222 5
a226 5
 [ No32bitCode
        DCD 0
 |
        DCD ModuleFlag_32bit
 ]
d228 1
a228 1
 [ :LNOT: soft
d249 53
a301 53
        LDR WsPtr,[R12]
        CMP WsPtr,#0
        BEQ Devices_Co_40       ;Wot! no workspace

        SUB StkPtr,StkPtr,#256

        MOV R1,StkPtr
        MOV R2,#255

        ADR R3,HeadingDevice
        MOV R4,#255

        MOV R5,#HeadingDevLen
        ADD R6,R1,#FormDeviceDst
        BL CopyField
        BL PadField

        MOV R5,#HeadingTypLen
        ADD R6,R6,#FormTypeDst
        BL CopyField
        BL PadField

        MOV R5,#HeadingCapLen
        ADD R6,R6,#FormCapacityDst
        BL CopyField
        BL PadField

        MOV R5,#HeadingVenLen
        ADD R6,R6,#FormVendorDst
        BL CopyField
        BL PadField

        MOV R5,#HeadingProLen
        ADD R6,R6,#FormProductDst
        BL CopyField
        BL PadField

        MOV R5,#HeadingRevLen
        BL CopyField

        MOV R0,StkPtr
        SWI XOS_Write0
        SWIVC XOS_NewLine
        BVS Devices_Co_30
 [ {FALSE}
 SWI XOS_WriteS
 DCB "ddd    ttttttttttttttttt cccc Mbytes vvvvvvvv pppppppppppppppp rrrr"
 DCB 0
 ALIGN
 SWI XOS_NewLine
 ]
        MOV R1,#0
        LDR R4,maxCardID        ;0/1/2/3 for 1/2/3/4 cards
d303 18
a320 18
        MOV R0,#3
        MOV R2,StkPtr
        MOV R3,#255
        SWI XSCSI_Initialise

        MOV R0,StkPtr
        SWI XOS_Write0
        SWIVC XOS_NewLine
        BVS Devices_Co_30

        ADD R1,R1,#1            ;
        TST R1,#maxDeviceID     ;Loop until last device on this card
        BNE Devices_Co_10       ; has been accessed

        SUBS R4,R4,#1           ;Quit if no more cards
        BLT Devices_Co_30
        SWI XOS_NewLine         ;
        BVC Devices_Co_10       ;Else print blank line and loop for next card
d323 1
a323 1
        ADD StkPtr,StkPtr,#256
a340 2


d345 21
a365 27
HeadingDevice           DCB "Device"
HeadingDevLen                                   EQU (.-HeadingDevice)
HeadingType             DCB "Type"
HeadingTypLen                                   EQU (.-HeadingType)
HeadingCapacity         DCB "Capacity"
HeadingCapLen                                   EQU (.-HeadingCapacity)
HeadingVendor           DCB "Vendor"
HeadingVenLen                                   EQU (.-HeadingVendor)
HeadingProduct          DCB "Product"
HeadingProLen                                   EQU (.-HeadingProduct)
HeadingRevision         DCB "Revision"
HeadingRevLen                                   EQU (.-HeadingRevision)



 ] ; :LNOT:soft

HostVendor              DCB "ACORN   "
FormVendorSrc                                   EQU (.-HostVendor)
HostProduct             DCB "SCSI expansion  "
FormProductSrc                                  EQU (.-HostProduct)
 [ bugfix14
HostRevision            DCB VString
 |
HostRevision            DCB "1.00"
 ]
FormRevisionSrc                                 EQU (.-HostRevision)
d370 1
a370 1
 [ :LNOT:soft
d372 3
a374 3
        ASSERT FormVendorSrc   = 8      ;These are the widths of the
        ASSERT FormProductSrc  = 16     ; fields in the returned
        ASSERT FormRevisionSrc = 4      ; Inquiry data
d378 1
a378 1
        DCB CR,LF,"SCSI Devices:",CR,LF,SPACE,0
d380 1
a380 1
        DCB "Host",0
d383 1
a383 4
        DCB "LUN not present  "



a390 1

d397 10
a406 10
        DCD TextDirect       - DeviceTypeDecodeTab      ;&00
        DCD TextSequential   - DeviceTypeDecodeTab      ;&01
        DCD TextPrinter      - DeviceTypeDecodeTab      ;&02
        DCD TextProcessor    - DeviceTypeDecodeTab      ;&03
        DCD TextWORM         - DeviceTypeDecodeTab      ;&04
        DCD TextRODirect     - DeviceTypeDecodeTab      ;&05
        DCD TextScanner      - DeviceTypeDecodeTab      ;&06
        DCD TextOptical      - DeviceTypeDecodeTab      ;&07
        DCD TextChanger      - DeviceTypeDecodeTab      ;&08
        DCD TextComms        - DeviceTypeDecodeTab      ;&09
d409 1
a409 1
        DCD TextUnknown      - DeviceTypeDecodeTab      ;&0A..&7F
d412 13
a424 13
TextDirect              DCB "Direct-access    "         ;&00
TextSequential          DCB "Sequential-access"         ;&01
TextPrinter             DCB "Printer          "         ;&02
TextProcessor           DCB "Processor        "         ;&03
TextWORM                DCB "WORM             "         ;&04
TextRODirect            DCB "Read-only        "         ;&05
TextScanner             DCB "Scanner          "         ;&06
TextOptical             DCB "Optical memory   "         ;&07
TextChanger             DCB "Changer          "         ;&08
TextComms               DCB "Communications   "         ;&09
TextUnknown             DCB "Unknown          "
TextHost                DCB "Host             "
FormTypeSrc             EQU (.-TextHost)
a427 1

d432 2
a433 1
 ] ; :LNOT:soft
d455 2
a456 2
        mess ,"ModInit",NL
        Push "R7-R11,Link"
d458 15
a472 15
 [ testMEMC
        MOV R0,#0                       ;Our copier only works with MEMC1a as
        LDRB R0,[R0,#MemorySpeed+2]     ; it uses LDM/STM to podule area.
        TST R0,#1               ;Assumes future MEMCs/OSs set this properly.
        BEQ err_WrongMEMC
 ]
        LDR R2,[R12]            ;Load private word
        TEQ R2,#0
        MOVNE WsPtr,R2          ;Already got our workspace (ie this is a
        BNE GotWorkSpace        ; reinitialise entry)

        CMP R11,#&03000000      ; Loaded from a podule,
        BHS ModIn_20            ; R11 is podule base address
        CMP R11,#0
        BNE exitModInit         ;If <>0, new incarnation, do nothing
d478 12
a489 12
        LDRB R0,[R10],#1        ;Skip leading spaces
        CMP R0,#" "             ;
        BEQ ModIn_10            ;

        SUBS R3,R0,#"0"         ;Accept "0"..."9",
        MOVLT R3,#0             ; assume anything else (non-digit
        CMP R3,#9               ; or unspecified is podule zero).
        MOVGT R3,#0             ;
        SWI XPodule_HardwareAddress
        BICVC R11,R3,#&FF
        BICVC R11,R11,#&300     ;Zap the CMOS RAM base
        MOVVS R11,#0            ; R11 now holds the podule base address (for sync access)
d491 2
a492 2
        TEQ R11,#0
        SUBNE R11,R11,#PoduleSpeedMask  ;Reduce to slow access address from sync.
d494 3
a496 3
        SWI XSCSI_LogList       ;Ask ScsiLog for a list of Podule base
        MOVVS R0,#0             ; addresses
        MOV R3,#0
d498 2
a499 2
        Push R0
        BVS ModIn_40            ;ScsiLog not installed (or knows nothing???)
d501 6
a506 6
        LDR R1,[R0],#4          ;Count number of podule addresses in list
        TEQ R1,R11              ; (If R11 is a duplicate of one of the list
        MOVEQ R11,#0            ;   values, kill it).
        TEQ R1,#0               ;Don't count if null terminator
        ADDNE R3,R3,#1
        BNE ModIn_30
d508 3
a510 3
        Pull "R1"
        CMP R11,#0              ;Include latest entry?
        ADDNE R3,R3,#1
d514 2
a515 2
        CMP R3,#4               ;Restrict to 4 cards maximum because there can't
        MOVGT R3,#4             ; be more than 4 buses at a time
d517 14
a530 14
        MOV R0,#:INDEX: SCSIstubsize
        LDR R2,=(:INDEX: Cardworkspacesize)
        MLA R3, R2,R3,R0

        MOV R0,#ModHandReason_Claim
        SWI XOS_Module
        BVS err_NoRoom_forworkspace

        STR R2,[R12]            ;Store ->WorkSpace in private word
        MOV WsPtr,R2            ; WsPtr is R12

        MOV R2,#(:INDEX:ListEntry0)
        TEQ R1,#0               ;If no list obtained from ScsiLog
        BEQ ModIn_60            ; then skip
d532 2
a533 2
        CMP R2,#(:INDEX: ListHighestTerm)
        BGE ModIn_70            ; (must terminate now!!!)
d535 5
a539 5
        LDR R0,[R1],#4          ;else Copy null terminated list obtained from
        TEQ R0,#0               ; ScsiLog (ignoring entries that clash
        STRNE R0,[WsPtr,R2]     ; with our (R11) address).
        ADDNE R2,R2,#4
        BNE ModIn_50
d542 3
a544 3
        CMP R11,#0
        STRNE R11,[WsPtr,R2]    ;Add our podule address to end of list
        ADDNE R2,R2,#4
d546 2
a547 2
        MOV R11,#0
        STR R11,[WsPtr,R2]      ;Terminate the list
d551 3
a553 3
        SUB R2,R2,#(:INDEX:ListEntry1)
        MOV R2,R2,ASR #2
        STR R2,maxCardID
d556 4
a559 4
        ForEachCard HardResetCard               ;Do the deed to reset the hardware
 [ soft
        ForEachCard RegisterCard                ; and register the podule with the SCSI switcher
 ]
d562 1
a562 1
        Pull "R7-R11,PC"
d566 1
a566 1
        B exitModInit
d568 1
a568 1
        MakeSCSIErrorBlock SCSI_NoRoom          ;"No room for SCSI driver workspace"
d570 1
a570 1
 [ testMEMC
d572 3
a574 3
        ADR R0,ErrorBlock_SCSI_WrongMEMC +4     ;Print the error to ensure
        SWI XOS_Write0                          ; it is'nt hidden from user
        SWI XOS_NewLine                         ;
d576 2
a577 2
        XSCSIError SCSI_WrongMEMC               ; then return VS & R0->error
        B exitModInit                           ; in usual fashion
d579 2
a580 2
        MakeErrorBlock SCSI_WrongMEMC           ;"SCSI requires MEMC1a - see your dealer"
 ]
d597 9
a605 9
        mess ,"ModDie",NL
        Push "R7-R11,Link"
        LDR WsPtr,[R12]        ;Get workspace ptr
        CMP WsPtr,#0
        BEQ ModDi_10           ;Wot! no workspace

 [ soft
        ForEachCard DeregisterCard      ;Degister all our cards with the SCSI switcher
 ]
d609 1
a609 1
        Pull "R7-R11,PC",AL
d611 1
a611 1
 [ soft
d635 1
a635 1
 ]
d657 1
a657 1
        ASSERT Service_Reset < Service_PreReset
d659 5
a663 5
        DCD 0
        DCD ModServiceEntry-Module_BaseAddr
        DCD Service_Reset
        DCD Service_PreReset
        DCD 0
d665 1
a665 1
        DCD ModServiceTable-Module_BaseAddr
d667 4
a670 4
        MOV R0, R0              ; magic instruction signifying fast service table presence
        CMP R1,#Service_PreReset
        CMPNE R1,#Service_Reset
        MOVNE PC,Link
d673 2
a674 2
        Push Link
        LDR WsPtr,[R12]
d676 2
a677 2
        CMP R1,#Service_Reset
        BEQ ModServ_30
d692 2
a693 2
        mess ,"ModService, Service_PreReset",NL
        Push "R0-R11"           ;Link already pushed
d697 1
a697 1
        Pull "R0-R11,PC",AL
d706 2
a707 2
        mess ,"ModService, Service_Reset",NL
        Push "R0-R11"           ;Link already pushed
d709 2
a710 2
 [ preserveWSoverreset
 |
d712 2
a713 2
 ]
 [ soft
d715 2
a716 2
 ]
        Pull "R0-R11,PC",AL
d718 1
a718 1
        LTORG                   ;Dump them Literals
d723 1
a723 1
 [ soft
d741 2
a742 2
        mess ,"SCSI_Entry - Entry", NL
        Push "R0-R9,Link"
d744 4
a747 4
        CMP R11,#maxEntry
        ASSERT (SCSI_Entrytable-. =8)     ;Table must follow code
        ADDCC PC,PC,R11,ASL #2
        B err_Entryunkn
d750 8
a757 8
        B FeaturesEntry                   ;List features
        B ResetBusEntry                   ;Reset bus (the podule does do buses)
        B err_Entryunkn                   ;Reserved
        B err_Entryunkn                   ;Reserved
        B err_Entryunkn                   ;Don't do foreground transfers, the SCSI switcher will do these
        B OpEntry                         ; using the background entry point instead
        B AbortOpEntry                    ;For cancelling a pending background operation
        B HostDescEntry                   ;Return host description (only used is buses are supported, as here)
d765 3
a767 3
        STRVS R0,StackedR0      ;Overwrite stacked R0 with ->error
        mess ,"SCSI_Entry - Exit", NL
        Pull "R0-R9,PC"
d769 1
a769 1
 | ; soft
d779 11
a789 11
        DCB "SCSI",0         ;SWI group prefix
        DCB "Version",0      ; +0
        DCB "Initialise",0   ; +1
        DCB "Control",0      ; +2
        DCB "Op",0           ; +3
        DCB "Status",0       ; +4
        DCB "5",0            ; +5
        DCB "6",0            ; +6
        DCB "Reserve",0      ; +7
        DCB "List",0         ; +8
        DCB 0
d810 2
a811 2
        mess ,"SCSI_SWIdecode - Entry", NL
        Push "R0-R9,Link"
d813 1
a813 1
        LDR WsPtr,[R12]                 ;Get workspace ptr
d815 4
a818 4
        CMP R11,#maxSWI
        ASSERT (SCSI_SWItable-. =8)     ;Table must follow code
        ADDCC PC,PC,R11,ASL #2
        B err_SWIunkn
d821 9
a829 9
        MySWI SCSI_Version
        MySWI SCSI_Initialise
        MySWI SCSI_Control
        MySWI SCSI_Op
        MySWI SCSI_Status
        MySWI SCSI_ReadControlLines     ; } Not supported by Acorn SCSIdriver
        MySWI SCSI_EEProm               ; }
        MySWI SCSI_Reserve
        MySWI SCSI_List
d835 1
a835 1
        B exitSWIdecode
d837 1
a837 1
        MakeSCSIErrorBlock SCSI_SWIunkn     ;"Unknown SCSI SWI number"
d841 2
a842 2
 [ counts
        Push "R0-R4"
d844 110
a953 110
        ADRL R3, MyInfoSpace1
        LDR R0, [R3, #0]
        BEQ NotOpSWI
        SWI OS_WriteS
        = "StartCommand : "
        LDR R0, [R3, #8]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0
        SWI OS_NewLine
        SWI OS_WriteS
        = "int_ser_65+  : "
        LDR R0, [R3, #4]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0
        SWI OS_NewLine
        SWI OS_WriteS
        = "int_ser_202  : "
        LDR R0, [R3, #12]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0
        SWI OS_NewLine

        SWI OS_WriteS
        = "IDLE:"
        LDR R0, [R3, #16]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  RUNNING:"
        LDR R0, [R3, #20]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  STALLED:"
        LDR R0, [R3, #24]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  WAITING:"
        LDR R0, [R3, #28]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0
        SWI OS_NewLine

        SWI OS_WriteS
        = "INITIALISING:"
        LDR R0, [R3, #32]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  INITIALISED:"
        LDR R0, [R3, #36]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0
        SWI OS_NewLine

        SWI OS_WriteS
        = "TtlCnt: "
        LDR R0, [R3, #52]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  ScatPtr: "
        LDR R0, [R3, #56]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  EntCnt: "
        LDR R0, [R3, #60]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  EntAdr: "
        LDR R0, [R3, #64]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0
        SWI OS_NewLine
d956 2
a957 2
        MOV R0, #1
        STR R0, [R3, #0]
d959 2
a960 2
        Pull "R0-R4"
 ]
d962 9
a970 9
        STRVS R0,StackedR0      ;Overwrite stacked R0 with ->error
        Pull "R0-R9,Link"
        mess ,"SCSI_SWIdecode - Exit", NL
 [ :LNOT:No32bitCode
        TEQ PC,PC
        MOVEQ PC,Link
 ]
        ORRVS Link,Link,#V_bit  ;Stacked Link had VClear, so set if error
        MOVS PC,Link
d987 4
a990 4
        ADR R0,VersionBlk
        LDMIA R0,{R0,R1,R2,R3}          ;Pickup return values
        STMIA StkPtr,{R0,R1,R2,R3}      ;Write to StackedR0..StackedR3
        B exitSWIdecode                 ; will be popped on return
d993 4
a996 4
        DCD SoftwareVersionNumber
        DCD SoftwareExtensions
        DCD HardwareVersionNumber
        DCD HardwareExtensions
d1015 2
a1016 2
        BVS exitSWIdecode
        LDMIB WsPtr,{rPODULEptr,rDMACptr}
d1018 2
a1019 2
        ASSERT (:INDEX:PODULEptr)=4
        ASSERT (:INDEX:DMACptr)=8
d1021 4
a1024 4
        CMP R0,#maxSCSI_InitRC
        ASSERT (SCSI_InitRCtable-. =8)  ;Table must follow code
        ADDCC PC,PC,R0,ASL #2
        B err_RCunkn
d1027 7
a1033 7
        B ResetBus
        B ResetDevice
        B DetermineDevice
        B EnumerateDevice
 [ debug
        B ExamineDeviceWS
 ]
d1039 1
a1039 1
        B exitSWIdecode
d1041 2
a1042 2
        MakeSCSIErrorBlock SCSI_RCunkn      ;"Unknown reason code for SCSI SWI"
 ] ; :LNOT:soft
d1063 1
a1063 1
 [ soft
d1065 2
a1066 2
        LDMIB WsPtr,{rPODULEptr,rDMACptr}
 ]
d1069 2
a1070 2
        CMP R1,#maxDeviceID                 ;Only ID's 0..7 are valid
        BHI err_BadHostID
d1072 1
a1072 1
        BL UserResetCard
d1074 1
a1074 1
        B exitSWIdecode
d1078 1
a1078 1
        B exitSWIdecode
d1080 1
a1080 1
        MakeSCSIErrorBlock SCSI_BadHostID   ;"Invalid host ID"
d1099 9
a1107 9
        BL ValidateID           ;In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
                                ;    R0->"Device ID invalid"
        BLVC AddressDevice      ;In: R1=DeviceID
                                ;Out:R1=DeviceID,R9->deviceblk
 [ :LNOT:soft
        BLVC CheckAccess        ;In: R8=AccessKey, R9->deviceblk, Out:VC or
                                ;    VS & R0->"SCSI driver reservation error"
 ]
        BVS exitSWIdecode
d1109 2
a1110 2
        MOV R0,#CTL_DOINGRESET  ;Try to send MESSAGE_BUSDEVICERESET
        BL SCSImessage_internal ; to device (LUN=0)
d1119 1
a1119 1
        B exitSWIdecode
d1123 1
a1123 1
        B exitSWIdecode
d1125 1
a1125 1
        MakeSCSIErrorBlock SCSI_NoDevice    ;"No hardware at this ID"
d1151 25
a1175 25
        BL ValidateID           ;In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
                                ;    R0->"Device ID invalid"
        BLVC AddressDevice      ;In: R1=DeviceID
                                ;Out:R1=DeviceID,R9->deviceblk
        BVS exitSWIdecode

 [ bugfix12
        LDR R1,StackedR1        ;Recover DeviceID
       ;BIC R1,R1,#CardIDMask   ; but kill the CardID bits ;>>>Is this needed???
 ]
        SUB StkPtr,StkPtr,#((Determine_BLK_SIZE + 3) :AND: &FFFFFFFC)
        MOV R3,StkPtr

        ORR R0,R1,#CTL_DumbDeviceTXREAD ;Assume target is dumb
        ADR R2,cdb_inquiry_withread
        LDR R1,[R2],#4                  ;CDB length, R2 now->CDB
        MOV R4,#INQUIRY_BLK_SIZE

        Push R0                         ;Wanted later on
        MOV R5,#0               ;Default timeout
        BL SCSIop_internal      ;Out: R0-R2 corrupt,R3->Last byte received+1,
                                ;     R4=amount untransfered
        ADDVS StkPtr,StkPtr,#4+((Determine_BLK_SIZE + 3) :AND: &FFFFFFFC)
        BVS det_dev_10
        Pull R0
d1177 2
a1178 2
        ADD R3,R3,#3            ;Align to next word boundary
        BIC R3,R3,#3
d1180 12
a1191 20
        ADR R2,cdb_readcapacity
        LDR R1,[R2],#4          ;CDB length, R2 now->CDB
        MOV R4,#READCAPACITY_BLK_SIZE

        MOV R5,#0               ;Default timeout
        BL SCSIop_internal      ;Out: R0-R2 corrupt,R3->Last byte received+1,
                                ;     R4=amount untransfered
 [ bugfix8
        TEQ R4,#0               ;     R4=amount untransfered
 ]
        LDMIA StkPtr,{R3,R4,R5,R6}
        ADD StkPtr,StkPtr,#((Determine_BLK_SIZE + 3) :AND: &FFFFFFFC)

        AND R4,R4,#&FF          ;Bytes 5..7 returned as zero
 [ bugfix8
        MOVNE R5,#&FFFFFFFF     ;If 'read-capacity' failed or didn't return
        MOVNE R6,#&FFFFFFFF     ; enough data, return -1,-1.
 ]
        RevBytes R5, R7,R8      ;Convert highest logical block number
        RevBytes R6, R7,R8, s   ; and block length to normal ARM byte sex
d1193 10
a1202 2
        LDR R2,StackedR2        ;Recover users buffer address
        STMIA R2 !,{R3,R4,R5,R6}
d1204 1
a1204 1
        B exitSWIdecode
d1213 1
a1213 1
        DCD cdb_inquiry_notx_end-cdb_inquiry_notx_start
d1215 7
a1221 7
        DCB C_INQUIRY           ;INQUIRY command
        DCB 0                   ;LUN=0 (b7..b5), reserved=0 (b4..b0)
        DCB 0                   ;reserved
        DCB 0                   ;reserved
        DCB 0                   ;Allocation length=0
        DCB 0                   ;Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
                                ; Flag=0 (b1),Link=0 (b0)
d1230 1
a1230 1
        DCD cdb_inquiry_withread_end-cdb_inquiry_withread_start
d1232 7
a1238 7
        DCB C_INQUIRY           ;INQUIRY command
        DCB 0                   ;LUN=0 (b7..b5), reserved=0 (b4..b0)
        DCB 0                   ;reserved
        DCB 0                   ;reserved
        DCB INQUIRY_BLK_SIZE    ;Allocation length
        DCB 0                   ;Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
                                ; Flag=0 (b1),Link=0 (b0)
d1247 1
a1247 1
        DCD cdb_inquiry_withread_endL-cdb_inquiry_withread_startL
d1249 7
a1255 7
        DCB C_INQUIRY           ;INQUIRY command
        DCB 0                   ;LUN=0 (b7..b5), reserved=0 (b4..b0)
        DCB 0                   ;reserved
        DCB 0                   ;reserved
        DCB INQUIRY_BLK_SIZEL   ;Allocation length
        DCB 0                   ;Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
                                ; Flag=0 (b1),Link=0 (b0)
d1268 1
a1268 1
        DCD cdb_readcapacity_end-cdb_readcapacity_start
d1270 12
a1281 12
        DCB C_READCAPACITY      ;READCAPACITY command
        DCB 0                   ;LUN=0 (b7..b5), reserved=0 (b4..b1),
                                ; RelAdr=0 (b0)
        DCB 0                   ;Logical block address (MSB)
        DCB 0
        DCB 0
        DCB 0                   ;Logical block address (LSB)
        DCB 0                   ;reserved
        DCB 0                   ;reserved
        DCB 0                   ;VU=0 (b7..b6), Reserved=0 (b5..b1), PMI=0 (b0)
        DCB 0                   ;VU=0 (b7..b6), Reserved=0 (b5..b2),
                                ; Flag=0 (b1),Link=0 (b0)
d1291 1
a1291 1
        DCD cdb_requestsense_end-cdb_requestsense_start
d1293 7
a1299 7
        DCB C_REQUESTSENSE      ;REQUESTSENSE command
        DCB 0                   ;LUN=0 (b7..b5), reserved=0 (b4..b0)
        DCB 0                   ;reserved
        DCB 0                   ;reserved
        DCB REQUESTSENSE_BLK_SIZE       ;Allocation length=0
        DCB 0                   ;VU=0 (b7..b6), Reserved=0 (b5..b2),
                                ; Flag=0 (b1),Link=0 (b0)
d1303 1
a1303 1
 [ :LNOT:soft
d1334 1
a1334 1
        STR R2,StackedR3        ;So failure of XOS_ConvertCardinal1 gives ->""
d1336 1
a1336 1
        LDR R0,StackedR1        ;Use stacked DeviceID, which includes CardID and LUN
d1338 3
a1340 3
        MOV R1,R2               ;Position in buffer to place DeviceID
        MOV R2,R3               ;Buffer size
        ADD R6,R1,#FormDeviceDst        ;Next field is device type
d1342 2
a1343 2
        SWI XOS_ConvertCardinal1        ;In R0=cardinal,R1->Buffer,R2=BuffSz
        BVS enu_dev_30          ;Out R0->Buffer,R1->terminator,R2=bytes left
d1345 2
a1346 2
        BL PadField             ;In R1=current position,R2=BuffSz,R6->nextfield
                                ;Out R1=R6=terminator,R2=bytes left
d1348 1
a1348 1
        STR R1,StackedR3        ;Advance stacked endpointer
d1350 2
a1351 2
        MOV R6,R1               ;->next field in buffer
        MOV R7,R2               ;Bytes left in buffer
d1353 3
a1355 3
        LDR R0,StackedR1        ;Recover DeviceID
        BIC R0,R0,#CardIDMask   ; but kill the CardID bits
        LDR R1,HostID
d1373 1
a1373 1
        SUB StkPtr,StkPtr,#((Describe_BLK_SIZE + 3) :AND: &FFFFFFFC)
d1375 2
a1376 2
        CMP R0,R1
        BEQ enu_dev_50
d1378 8
a1385 8
        MOV R1,StkPtr
        MOV R2,#Describe_BLK_SIZE
        BL determinedevice_internal     ;In R0=DeviceID,R1->buffer,R2=bufferlen
        BVS enu_dev_20                  ;Out R0->buffer,R1->last byte+1,R2=

        MOV R3,StkPtr           ;->recovered data
        SUB R4,R1,StkPtr        ;Size of recovered data
        Push "R3,R4"            ;Preserve for later
d1396 1
a1396 1
        LDRB R0,[R3,#8]
d1398 2
a1399 2
        CMP R0,#maxPERIPHERALDEVICETYPE
        MOVHI R0,#maxPERIPHERALDEVICETYPE
d1401 3
a1403 3
        ADRL R3,DeviceTypeDecodeTab
        LDR R0,[R3,R0,LSL #2]
        ADD R3,R0,R3
d1405 2
a1406 2
        MOV R1,R6               ;->buffer
        MOV R2,R7               ;=buffersize
d1408 7
a1414 7
        MOV R4,#255
        MOV R5,#FormTypeSrc
        ADD R6,R6,#FormTypeDst
                                ;In:  R1->dest buf,R2=dest size,R3->src buf
        BL CopyField            ;     R4=src buf size,R5=src field size
        BL PadField             ;In R1=current position,R2=BuffSz,R6->nextfield
                                ;Out R1=R6=terminator,R2=bytes left
d1417 1
a1417 1
        Pull "R3,R4"
d1422 2
a1423 2
        Push "R3,R4"
        LDMIA R3,{R3,R4}        ;Highest sector address, sector size
d1425 9
a1433 9
        CMP R3,#-1                              ;Sector address & size of
        CMPEQ R4,#-1                            ; -1,-1 indicates device doesnt
        ADREQL R3,TextCapacityUnknown           ; support 'read-capacity' cmd
        MOVEQ R4,#LenTextCapacityUnknown        ; or returned unsufficent data
        MOVEQ R5,#LenTextCapacityUnknown        ;
        BLEQ CopyField                          ; so print 'Unknown'
        BEQ enu_dev_02                          ;
                                                ;Else print valid capacity
        ADD R3,R3,#1            ;Total sector count
d1435 1
a1435 1
        ; UMULL R0,R3,R4,R3
d1437 2
a1438 2
        Mul64 R3,R0,R8,R9,R3,,,R10,R5,LR ; (R3,R0)=(R8,R9)*R3, using R3,R5,LR as work regs
        BL ConvertFixedFileSize64       ;In R0=Capacity(L),R1->Buffer,R2=BuffSz,R3=Capacity(H)
d1440 1
a1440 1
        MUL R0,R3,R4            ;Device capacity (bytes)
d1442 2
a1443 2
       ;ADD R6,R6,#FormCapacityDst
        SWI XOS_ConvertFixedFileSize    ;In R0=Capacity,R1->Buffer,R2=BuffSz
d1445 1
a1445 1
        BVS enu_dev_30          ;Out R0->Buffer,R1->terminator,R2=bytes left
d1448 6
a1453 6
        ADD R6,R6,#FormCapacityDst
        BL PadField             ;In R1=current position,R2=BuffSz,R6->nextfield
                                ;Out R1=R6=terminator,R2=bytes left
        Pull "R3,R4"
        ADD R3,R3,#(8+8)        ;-> Vendor-Identification field
        SUB R4,R4,#(8+8)
d1459 23
a1481 23
        MOV R5,#FormVendorSrc   ;sizeof(Vendor-Identification field)
        ADD R6,R6,#FormVendorDst
                                ;In:  R1->dest buf,R2=dest size,R3->src buf
        BL CopyField            ;     R4=src buf size,R5=src field size
                                ;Out: R0->dest, R2..R5 updated
        BL PadField             ;In R1=current position,R5->next field
                                ;Out R1=R5= ->next field

        MOV R5,#FormProductSrc  ;sizeof(Product-Identification field)
        ADD R6,R6,#FormProductDst
        BL CopyField
        BL PadField

        MOV R5,#FormRevisionSrc ;sizeof(Revision-Level field)
        BL CopyField

        ADD StkPtr,StkPtr,#((Describe_BLK_SIZE + 3) :AND: &FFFFFFFC)

        STR R1,StackedR3        ;Pass back offset to terminating zero

        LDR R3,StackedR3
        MOV R0,#0
        STRB R0,[R3]            ;Terminate string
d1483 1
a1483 1
        B exitSWIdecode
d1487 1
a1487 1
        ADD StkPtr,StkPtr,#((Describe_BLK_SIZE + 3) :AND: &FFFFFFFC)
d1489 4
a1492 4
        STR R0,StackedR0
        LDR R3,StackedR3
        MOV R0,#0
        STRB R0,[R3]            ;Terminate string
d1494 1
a1494 1
        B exitSWIdecode
d1500 12
a1511 12
        MOV R1,R6               ;->buffer
        MOV R2,R7               ;=buffersize
        ADRL R3,TextHost
        MOV R4,#255
        MOV R5,#FormTypeSrc
        ADD R6,R6,#FormTypeDst+FormCapacityDst
                                ;In:  R1->dest buf,R2=dest size,R3->src buf
        BL CopyField            ;     R4=src buf size,R5=src field size
        BL PadField             ;In R1=current position,R2=BuffSz,R6->nextfield
        ADRL R3,HostVendor
        MOV R4,#(HostEnd-HostVendor)
        B enu_dev_05
d1513 1
a1513 1
 [ BigCapacity
d1629 1
a1629 1
 ]
d1646 1
a1646 1
 [ debug
d1649 5
a1653 5
        BL ValidateID           ;In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
                                ;    R0->"Device ID invalid"
        BLVC AddressDevice      ;In: R1=DeviceID
                                ;Out:R1=DeviceID,R9->deviceblk
        BVS exitSWIdecode
d1655 2
a1656 2
        STR WsPtr,StackedR0
        STR rDEVICEptr,StackedR1
d1658 2
a1659 2
        B exitSWIdecode
 ]
d1680 2
a1681 2
        ORR R0,R0,#CTL_DumbDeviceTXREAD ;Combine TargetID with control bits
        Push "R0-R7,Link"
d1683 2
a1684 2
        MOV R3,R1                       ;TxAdr
        MOV R4,#READCAPACITY_BLK_SIZE   ;TxSize
d1686 28
a1713 28
        ADR R2,cdb_readcapacity
        LDR R1,[R2],#4          ;CDB length, R2 now->CDB
        MOV R5,#0               ;Default timeout
        BL SCSIop_internal      ;Out: R0-R2 corrupt,R3->Last byte received+1,
                                ;Ignore errors, capacity gets reported as -1,-1

        TEQ R4,#0               ;     R4=amount untransfered
        LDR R0,StackedR1        ;Convert highest logical block number
        LDMEQIA R0,{R1,R2}      ; and block length to normal ARM byte sex
        MOVNE R1,#&FFFFFFFF     ;
        MOVNE R2,#&FFFFFFFF     ;N.B. If 'read-capacity' failed or didn't
        RevBytes R1, R3,R4      ;     transfer enough data, return -1,-1.
        RevBytes R2, R3,R4, s   ;     If inquiry is successful, this can be
        STMIA R0,{R1,R2}        ;     interpreted as 'device-present-but-naff'
                                ;     or 'present-but-size-has-no-meaning'.
        Pull "R0,R1,R4"
        ADD R3,R1,#READCAPACITY_BLK_SIZE        ;Adjust ->block and block size
        SUB R4,R4,#READCAPACITY_BLK_SIZE        ; for data already received.
        Push "R1,R3,R4"
                                                ;Then do inquiry command
        ADR R2,cdb_inquiry_withreadL
        LDR R1,[R2],#4          ;CDB length, R2 now->CDB
        MOV R4,#INQUIRY_BLK_SIZEL
        MOV R5,#0               ;Default timeout
        BL SCSIop_internal      ;Out: R0-R2 corrupt,R3->Last byte received+1,
                                ;     R4=amount untransfered
        STR R3,StackedR1
        STR R4,StackedR2
d1715 2
a1716 2
        STRVS R0,StackedR0
        Pull "R0-R7,PC"
d1738 13
a1750 13
 [ No32bitCode
    Push R1
 |
    Push "R1,R6"
    SavePSR R6
 ]

    CMP R2,#0                   ;If destination string full,
    BLE cpy_fie_30              ; give up now (DON'T touch the string)

    CMP R4,#0                   ;If source string empty
    CMPGT R5,#0                 ; or source field empty
    BLE cpy_fie_20              ; give up now (terminate destination string)
d1753 11
a1763 11
    LDRB R0,[R3],#1             ;Get bytes from source string,
    CMP R0,#" "                 ; 'sanitise then' (replace 0..31,127 with " ")
    MOVLT R0,#" "
    CMP R0,#127
    MOVEQ R0,#" "
    STRB R0,[R1],#1             ; and write to destination string

    SUB R4,R4,#1
    SUBS R5,R5,#1
    CMPGT R4,#0                 ;Loop until source field or source string
    BGT cpy_fie_10              ; are exhausted
d1766 2
a1767 2
    MOV R0,#0
    STRB R0,[R1]                ;Terminate the destination string
d1769 8
a1776 8
 [ No32bitCode
    Pull R0
    MOVS PC,Link
 |
    RestPSR R6,,f
    Pull "R0,R6"
    MOV PC,Link
 ]
d1793 5
a1797 5
 [ :LNOT:No32bitCode
    Push R3
    SavePSR R3
 ]
    MOV R0,#" "
d1799 14
a1812 14
    SUBS R2,R2,#1
    STRB R0,[R1],#1
    CMP R6,R1
    BHI pad_fie_10

    MOV R0,#0
    STRB R0,[R1]                ;Terminate the destination string
 [ No32bitCode
    MOVS PC,Link
 |
    RestPSR R3,,f
    Pull R3
    MOV PC,Link
 ]
d1837 2
a1838 2
        BVS exitSWIdecode
        LDMIB WsPtr,{rPODULEptr,rDMACptr}
d1840 10
a1849 10
        BL ValidateID           ;In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
                                ;    R0->"Device ID invalid"
        BLVC AddressDevice      ;In: R1=DeviceID
                                ;Out: R1=DeviceID, R9->deviceblk
        BVS exitSWIdecode

        CMP R0,#maxSCSI_ContRC
        ASSERT (SCSI_ContRCtable-. =8)  ;Table must follow code
        ADDCC PC,PC,R0,ASL #2
        B err_RCunkn
d1852 7
a1858 7
        B AbortDevice
        B AbortOp
        B SetSenseMode
        B SetTimeOut
        B ControlErrors
        B ControlQueue
        B ControlDisconnects
d1880 2
a1881 2
        BL CheckAccess          ;In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS exitSWIdecode       ;    VS & R0->"SCSI driver reservation error"
d1883 2
a1884 2
        MOV R0,#CTL_DOINGABORTDEVICE    ;Try to send MESSAGE_ABORT
        BL SCSImessage_internal         ; to device (LUN=0)
d1893 1
a1893 1
        B exitSWIdecode
d1911 2
a1912 2
        BL CheckAccess          ;In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS exitSWIdecode       ;    VS & R0->"SCSI driver reservation error"
d1914 1
a1914 1
        LDR rCMDptr,CMDptr      ;>>>>is this needed???
d1916 2
a1917 2
        MOV R1,#CTL_DOINGABORTOP        ;Try to abort,
        BL RaiseATN                     ; if it works, report operation aborted
d1919 1
a1919 1
        B exitSWIdecode
d1922 1
a1922 1
        B exitSWIdecode
d1943 2
a1944 2
        BL CheckAccess          ;In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS exitSWIdecode       ;    VS & R0->"SCSI driver reservation error"
d1946 3
a1948 3
        LDR R5,ControlTimeout
        STR R2,ControlTimeout
        STR R5,StackedR2
d1950 1
a1950 1
        B exitSWIdecode
d1979 17
a1995 17
        LDR R5,ControlBits      ;Ready to be returned as previous value
        CMP R2,#-1
        BEQ Cont_Err_10

        BL CheckAccess          ;In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS exitSWIdecode       ;    VS & R0->"SCSI driver reservation error"

        CMP R2,#maxSCSI_Cont_RespRC
        BHI err_RCunkn

        ASSERT (maxSCSI_Cont_RespRC = 2)

        CMP R2,#1
        BIC R3,R5,#(CTL_INHIBITREQUESTSENSE :OR: CTL_REPORTUNITATTENTION)
        ORRLT R3,R3,#(CTL_REPORTUNITATTENTION :OR: CTL_INHIBITREQUESTSENSE)
        ORREQ R3,R3,#(CTL_REPORTUNITATTENTION)
        STR R3,ControlBits
d1998 6
a2003 6
        MOV R2,#2
        TST R5,#CTL_REPORTUNITATTENTION
        MOVNE R2,#1
        TST R5,#CTL_INHIBITREQUESTSENSE
        MOVNE R2,#0
        STR R2,StackedR2
d2005 1
a2005 1
        B exitSWIdecode
d2031 20
a2050 20
        LDR R5,ControlBits      ;Ready to be returned as previous value
        CMP R2,#-1
        BEQ Cont_Que_10

        BL CheckAccess          ;In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS exitSWIdecode       ;    VS & R0->"SCSI driver reservation error"

        CMP R2,#maxSCSI_Cont_QueuRC
        BHI err_RCunkn

        ASSERT (maxSCSI_Cont_QueuRC = 3)

        BIC R3,R5,#(CTL_REJECTQUEUEFULL :OR: CTL_REJECTDEVICEBUSY)
        BIC R3,R3,#(CTL_REJECTPODULEBUSY)
        CMP R2,#1
        ORRGE R3,R3,#CTL_REJECTQUEUEFULL        ;R2 is 1/2/3
        ORRGT R3,R3,#CTL_REJECTDEVICEBUSY       ;R2 is   2/3
        CMP R2,#3
        ORRGE R3,R3,#CTL_REJECTPODULEBUSY       ;R2 is     3
        STR R3,ControlBits
d2053 8
a2060 8
        MOV R2,#0
        TST R5,#CTL_REJECTQUEUEFULL
        MOVNE R2,#1
        TST R5,#CTL_REJECTDEVICEBUSY
        MOVNE R2,#2
        TST R5,#CTL_REJECTPODULEBUSY
        MOVNE R2,#3
        STR R2,StackedR2
d2062 1
a2062 1
        B exitSWIdecode
d2084 18
a2101 18
        LDR R5,ControlBits
        CMP R2,#-1
        BEQ Cont_Dis_10

        BL CheckAccess          ;In: R8=AccessKey, R9->deviceblk, Out:VC or
        BVS exitSWIdecode       ;    VS & R0->"SCSI driver reservation error"

        CMP R2,#maxSCSI_Cont_DiscRC
        BHI err_RCunkn

        ASSERT (maxSCSI_Cont_DiscRC = 2)

        LDR R3,ControlBits
        BIC R3,R3,#(CTL_INHIBITDISCONNECTION :OR: CTL_INHIBITIDENTIFY)
        CMP R2,#1
        ORREQ R3,R3,#CTL_INHIBITDISCONNECTION
        ORRGT R3,R3,#(CTL_INHIBITDISCONNECTION :OR: CTL_INHIBITIDENTIFY)
        STR R3,ControlBits
d2104 6
a2109 6
        MOV R2,#0
        TST R5,#CTL_INHIBITDISCONNECTION
        MOVNE R2,#1
        TST R5,#CTL_INHIBITIDENTIFY
        MOVNE R2,#2
        STR R2,StackedR2
d2111 1
a2111 1
        B exitSWIdecode
d2128 2
a2129 2
        BVS exitSWIdecode
        LDMIB WsPtr,{rPODULEptr,rDMACptr}
d2131 4
a2134 4
        CMP R0,#maxSCSI_StatRC
        ASSERT (SCSI_StatRCtable-. =8)  ;Table must follow code
        ADDCC PC,PC,R0,ASL #2
        B err_RCunkn
d2137 2
a2138 2
        B CheckDevice
        B ReturnLastError
d2156 11
a2166 11
        BL ValidateID           ;In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
                                ;    R0->"Device ID invalid"
        BLVC AddressDevice      ;In: R1=DeviceID
                                ;Out:R1=DeviceID,R9->deviceblk
        BVS exitSWIdecode

        LDR R0,PendingCnt
        TEQ R0,#0
        MOVEQ R0,#1
        MOVNE R0,#2
        STR R0,StackedR0
d2168 1
a2168 1
        B exitSWIdecode
d2171 1
a2171 1
        B exitSWIdecode
d2179 1
a2179 1
        B err_SWIunkn
d2187 1
a2187 1
        B err_SWIunkn
d2207 2
a2208 2
        BVS exitSWIdecode
        LDMIB WsPtr,{rPODULEptr,rDMACptr}
d2210 10
a2219 10
        BL ValidateID           ;In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
                                ;    R0->"Device ID invalid"
        BLVC AddressDevice      ;In: R1=DeviceID
                                ;Out:R1=DeviceID,R9->deviceblk
        BVS exitSWIdecode

        CMP R0,#maxSCSI_ReseRC
        ASSERT (SCSI_ReseRCtable-. =8)  ;Table must follow code
        ADDCC PC,PC,R0,ASL #2
        B err_RCunkn
d2222 3
a2224 3
        B ClaimDevice
        B ForceClaimDevice
        B FreeDevice
d2245 9
a2253 9
        BL CheckAccess          ;In: R8=AccessKey, R9->deviceblk
                                ;Out:VC or
                                ;    VS & R0->"SCSI driver reservation error"
        ASSERT (ReleaseCallAdr+4) = ReleaseCallR12
        ASSERT (ReleaseCallR12+4) = AccessKey

        ADRVC R0,ReleaseCallAdr ;Assign release Adr & R12 and AccessKey if not
        STMVCIA R0,{R2-R3,R8}   ; reserved (or we reserved it already under the
        B exitSWIdecode         ; same key)
d2270 7
a2276 7
        ASSERT (ReleaseCallAdr+4) = ReleaseCallR12
        ASSERT (ReleaseCallR12+4) = AccessKey
        ADR R4,ReleaseCallAdr
        LDMIA R4,{R4,R5,R6}     ;Current claimants Release Adr & R12 and key
        CMP R6,#0               ;If not claimed
        CMPNE R4,#0             ; or claiment has no release address,
        BEQ ClaimDevice         ; let ClaimDevice do the work
d2286 6
a2291 6
        Push "R1-R3,R8-R9,R12"
        MOV R0,#1
        MOV R12,R5
        MOV Link,PC
        MOV PC,R4
        Pull "R1-R3,R8-R9,R12"
d2293 2
a2294 2
        BVC ClaimDevice         ;VC, so should be free, so ClaimDevice
        B exitSWIdecode         ;VS, so refused
d2308 6
a2313 6
        BL CheckAccess
        MOVVC R8,#0             ;If we reserved the device
        STRVC R8,ReleaseCallAdr ; (or device not reserved)
        STRVC R8,ReleaseCallR12 ;
        STRVC R8,AccessKey      ; free it.
        B exitSWIdecode
d2324 2
a2325 2
        ADR R0,ListEntry0
        STR R0,StackedR0
d2327 1
a2327 1
        B exitSWIdecode
d2356 1
a2356 1
 [ counts                       ; 0 : 0=> In SCSI_Op Otherwise dont count
d2359 3
a2361 3
 ]                              ; 12: Count of times entered int_ser_202
                                ; 16-46 Used for State counts
                                ; 52-68 Fillslot variables
d2367 21
a2387 21
 [ counts                       ; Initialise MyInfoSpace
        Push "R0-R1"
        ADR R0, MyInfoSpace1
        MOV R1, #0
        STR R1, [R0, #0]
        STR R1, [R0, #4]
        STR R1, [R0, #8]
        STR R1, [R0, #12]
        STR R1, [R0, #16]
        STR R1, [R0, #20]
        STR R1, [R0, #24]
        STR R1, [R0, #28]
        STR R1, [R0, #32]
        STR R1, [R0, #36]
        STR R1, [R0, #40]
        STR R1, [R0, #52]
        STR R1, [R0, #56]
        STR R1, [R0, #60]
        STR R1, [R0, #64]
        Pull "R0-R1"
 ]
d2389 2
a2390 2
        LDR R1,=&FFFF
        AND R1,R0,R1
d2393 49
a2441 2
        BVS exitSWIdecode
        LDMIB WsPtr,{rPODULEptr,rDMACptr}
d2443 28
a2470 75
        BL ValidateID           ;In: R1=DeviceID, Out: R1=DeviceID, VC or VS &
                                ;    R0->"Device ID invalid"
        BLVC AddressDevice      ;In: R1=DeviceID
                                ;Out: R1=DeviceID, R9->deviceblk

 [ counts
        Push "R0-R2"
        SWI OS_WriteS
        = "deviceblk: "
        MOV  R0, R9
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  [0:3]: "
        LDR  R0, [R9, #0]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  [4:7]: "
        LDR  R0, [R9, #4]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  [8:11]: "
        LDR  R0, [R9, #8]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_WriteS
        = "  [12:15]: "
        LDR  R0, [R9, #12]
        ADRL R1, MyStringSpace1
        MOV R2, #100
        SWI OS_ConvertHex8
        SWI OS_Write0

        SWI OS_NewLine
        Pull "R0-R2"
 ]

        TEQ R8,#UnixAccessKey   ;Allow UNIX to side step AccessKey checks
        BEQ KludgeForUnix       ; N.B. V_bit unaltered by TEQ
        BLVC CheckAccess        ;In: R8=AccessKey, R9->deviceblk
KludgeForUnix                   ;Out:VC or
                                ;    VS & R0->"SCSI driver reservation error"
        BVS exitSWIdecode

        LDR R0,StackedR0        ;Recover corrupted registers from
        LDR R1,ControlBits      ; StackedR0..StackedR1, and add stored control
        ORR R0,R0,R1            ; bits to those already in R0
        LDR R1,StackedR1
 [ {FALSE}
        TST R0,#CTL_TXREAD
        ORRNE R0,R0,#CTL_INHIBITDISCONNECTION :OR: CTL_INHIBITIDENTIFY
 ]
 [ bugfix11
        CMP R1,#minCDBLen
        BLT err_ParmError
        CMP R1,#maxCDBLen
        BGT err_ParmError
 ]
                                ;R5 (timeout) supplied by user
        BL SCSIop_internal      ;Out: R0-R2 corrupt,R3->Last byte received+1,
                                ;     R4=amount untransfered
d2476 7
a2482 7
        STR R0,StackedR0
        STRVS R1,StackedR1      ; } Returned only on error
        STRVS R2,StackedR2      ; }
        STR R3,StackedR3
        STR R4,StackedR4
                                ;If SCSIop_internal returned VS, exitSWIdecode
        B exitSWIdecode         ; stores R0 to StackedR0, this doesn't matter
d2484 1
a2484 1
 [ bugfix11
d2487 1
a2487 1
        B exitSWIdecode
d2489 2
a2490 2
        MakeSCSIErrorBlock SCSI_ParmError   ;"Parameter error"
 ]
d2496 1
a2496 1
 ] ; :LNOT:soft
d2504 2
a2505 2
        MOV R0,#dmac_bits       ;Reset to 8bit mode
        wrDMAC R0,DR_Initialise
d2507 8
a2514 13
        MOV R0,#ctrl1           ;&60 active low DRQ/DACK, extended write
        wrDMAC R0,DR_DevCon1
        MOV R0,#ctrl2           ;&01 bus hold between cycles
        wrDMAC R0,DR_DevCon2
;
        MOV R0,#0               ;Select channel 0 for programming, current
        wrDMAC R0,DR_Channel    ; registers may be read, current and base
                                ; registers written to simultaneously

        STRB R0,PR_ClrInt       ;Clear the DMAC Terminal count interrupt
 [ readback
        LDRB R0,PR_IntStat
 ]
d2516 6
a2521 1
        MOV PC,Link             ;Flags preserved across call
d2528 1
a2528 1
        Push R0
d2530 3
a2532 3
        LDRB R0,SBICauxstat
        TST R0,#INT
        BEQ INT_wai_10
d2534 2
a2535 2
        Pull R0
        MOV PC,Link
d2539 1
a2539 1
        Push R0
d2541 5
a2545 5
        LDRB R0,SBICauxstat
        TST R0,#DBR
        BEQ DBR_wai_10
        Pull R0
        MOV PC,Link
d2549 1
a2549 1
        Push R0
d2551 5
a2555 5
        LDRB R0,SBICauxstat
        TST R0,#CIP
        BNE nCIP_wai_10
        Pull R0
        MOV PC,Link
d2572 1
a2572 1
        MOV R0,#25*2            ;Delay in 1/2 microsecond units
d2574 13
a2586 13
 [ HAL
        Push "R0-R3,R8,R9,R14"
        MOV R0,R0,LSR #1
        MOV R8,#0
        MOV R9,#EntryNo_HAL_CounterDelay
        SWI XOS_Hardware
        Pull "R0-R3,R8,R9,PC",VC
        Pull "R0-R3,R8,R9,R14"
 ]
        Push "R1,R2,R14"
        MOV R2,#IOC
        STRB R0,[R2, #Timer0LR]         ;Copy counter into output latch
        LDRB R1,[R2, #Timer0CL]         ;R1 := low output latch
d2588 8
a2595 8
        STRB R0,[R2, #Timer0LR]         ;Copy counter into output latch
        LDRB R14,[R2, #Timer0CL]        ;R14 := low output latch
        TEQ  R14,R1                     ;unchanged ?
        MOVNE R1,R14                    ;copy anyway
        BEQ Micro_10                    ;then loop
        SUBS R0,R0,#1                   ;decrement count
        BNE Micro_10                    ;loop if not finished
        Pull "R1,R2,PC",AL
d2603 18
a2620 18
        LDR rPODULEptr,=PODULEptrRel     ; except for pointers to hardware
        ADD rPODULEptr,rPODULEptr,R5
        STR rPODULEptr,PODULEptr

        LDR rDMACptr,=DMACptrRel
        ADD rDMACptr,rDMACptr,R5
        STR rDMACptr,DMACptr

        LDR R0,=SRAMptrRel
        ADD R0,R0,R5
        STR R0,SRAMptr

 [ soft
        MOV R1,#-1                       ;Destroy the host id
 |
        MOV R1,#defaultHostID
 ]
        STR R1,HostID
d2623 1
a2623 1
        Push Link
d2625 2
a2626 2
        MOV R0,#RCsoftcopyadr
        MOV R1,#Pod_EnableInts
d2628 7
a2634 7
 [ No32bitCode
        MOV R3,R5,LSR #14
        AND R3,R3,#3                    ;Deduce podule number
 |
        ADD R3,R5,#PoduleSpeedMask      ;Bug in Iyonix - only Sync base accepted
 ]
        SWI XPodule_CallLoader
d2636 2
a2637 2
        Pull Link
        LDR R1,HostID
d2639 1
a2639 1
        Push Link
d2641 2
a2642 2
        MOV R0,#Pod_ForceReset  ;Page 0,interrupts disabled,reset asserted
        wrPageReg R0            ; ie reset SCSIbus,SBIC & DMAC, hold for >25uS
d2644 1
a2644 1
        BL ResetWorkSpace       ;Trash any active commands,
d2646 2
a2647 2
        BL ResetHardware        ;In: R1=HostID
        Pull "PC"
d2657 4
a2660 4
        mess ," - ResetWorkSpace",NL
        Push "R0,R1,R14"
        MOV R0,#0
        STR R0,DEVICEptr        ;Cos MyTickerV looks at it
d2662 1
a2662 1
        LDR R1,=(:INDEX:ClearWSEnd-4)
d2664 13
a2676 13
        STR R0,[WsPtr,R1]       ;Zero all our workspace
        SUBS R1,R1,#4
        CMP R1,#(:INDEX:ClearWSStart)
        BGE RstWoSp_10

        LDR R0,=&0052434D       ;Initialise operationID counter
        STR R0,OperationID
        LDR R0,=PAGEBITS        ;SRAM has pages 0..15, mark as unallocated
        STR R0,RamMap           ; pages 16..31 don't exist, mark as allocated
        LDR R0,=CMDBITS
        STR R0,CmdMap
        MOV R0,#0
        STR R0,FirstCmd         ;Queue initially empty
d2678 2
a2679 2
        Pull "R0,R1"
        Push "R0,R1,rDEVICEptr"
d2681 1
a2681 1
        ASSERT ((DevCB1-DevCB0) = :INDEX: deviceRecSize)
d2683 2
a2684 2
        MOV R1,#maxDeviceID
        ADRL rDEVICEptr,DevCB0
d2686 1
a2686 1
        BL ClearDevCB
d2688 1
a2688 1
        ASSERT ((DevCB1-DevCB0) = :INDEX: deviceRecSize)
d2690 3
a2692 3
        ADD rDEVICEptr,rDEVICEptr,#:INDEX: deviceRecSize
        SUBS R1,R1,#1
        BGE RstWoSp_20
d2694 1
a2694 1
        Pull "R0,R1,rDEVICEptr,PC",AL
d2705 1
a2705 1
        MOV R0,#1       ;>>>Force hard reset for now
d2707 1
a2707 1
        Push "R1-R3"
d2709 5
a2713 5
        MOV R1,#0
        MOV R2,R9                       ;Low (inclusive) limit
        CMP R0,#0
        ADREQ R3,SoftClearDevCBEnd      ;Upper (exclusive) limit
        ADRNE R3,HardClearDevCBEnd
d2715 15
a2729 15
        STR R1,[R2],#4
        CMP R3,R2
        BHI Clr_Dev_10

        CMP R0,#0
        BEQ Clr_Dev_20

 [ :LNOT:soft
 [ disconnect
                                ;Zeroed workspace implies allow disconnection
 |
        MOV R1,#CTL_INHIBITDISCONNECTION
        STR R1,ControlBits
 ]
 ]
d2731 2
a2732 2
        Pull "R1-R3"
        MOV PC,Link
d2740 4
a2743 4
        mess ," - ResetHardware",NL
        Push "R0,R1,Link"
        MOV R0,#Pod_ForceReset  ;Page 0,interrupts disabled,reset asserted
        wrPageReg R0            ; ie reset SCSIbus,SBIC & DMAC, hold for >25uS
d2747 4
a2750 4
        BL Wait25uSec
 [ {TRUE}
   BL Wait25uSec
 ]
d2752 1
a2752 1
        MOV R0,#&0              ;Page 0,interrupts disabled,reset negated
d2754 12
a2765 12
        STRB R0,PR_ClrInt       ;Clear the DMAC Terminal count interrupt
 [ readback
        LDRB R0,PR_IntStat
 ]

        BL ResetDMAC

 [ {TRUE}
   BL Wait25uSec
   BL Wait25uSec
   BL Wait25uSec
 ]
d2771 5
a2775 5
        ORR R0,R1,#EAF          ;Enable advanced features
        wrSBIC R0,SR_OwnID      ;Set SBIC HostID (requires a soft reset command
                                ;
        MOV R0,#SC_Reset        ; to be activated)
        wrSBIC R0,SR_Command
d2777 1
a2777 1
 [ {TRUE}
d2779 17
a2795 17
        LDRB R0,SBICauxstat
        CMP R0,#INT
        BNE RstBus05
 |
        BL INT_wait             ;Wait until interrupt bit is set in auxiliary
                                ; status register.
                                ; In: R1 is DeviceID,
        BVS err_BadReset        ; Out: VC or VS and R0->'timeout error'
 ]

        rdSBIC R0,SR_SCSIstat
        CMP R0,#HOST_RESET      ;&01 (advanced)

        BNE err_BadReset        ;         reset cockup
;
        MOV R0,#(DMAmode :OR: IDI)      ;&24 use SBIC burst DMA mode
        wrSBIC R0,SR_Control
d2797 2
a2798 2
        MOV R0,#SyncMode        ;&20 REQ/ACK pulse width of 1 cycle
        wrSBIC R0,SR_SyncXfer
d2800 2
a2801 2
        MOV R0,#SelectTimeout   ;Timeout for Select phase
        wrSBIC R0,SR_Timeout
d2803 2
a2804 2
        MOV R0,#00
        wrSBIC R0,SR_TargetLUN
d2808 18
a2825 18
 [ soft
        LDR R0,HostID
        BIC R0,R0,#DeviceIDMask
        ORR R1,R0,R1
 ]
        STR R1,HostID           ;Keep HostID for checking purposes

        MOV R0,#0
        STRB R0,PR_ClrInt       ;Clear the DMAC Terminal count interrupt
 [ readback
        LDRB R0,PR_IntStat
 ]

        BL ClaimIRQs
 [ useTickerV
        BL ClaimTickerV
 ]
        MOV R0,#Pod_EnableInts  ;Interrupts enabled,reset negated,page 0
d2827 3
a2829 3
 [ readback
        LDRB R0,PR_IntStat
 ]
d2832 1
a2832 1
        Pull "R0,R1,PC"
d2835 1
a2835 1
        Pull "R0,R1,Link"
d2837 1
a2837 1
        MOV PC,Link
d2839 1
a2839 1
        MakeSCSIErrorBlock SCSI_BadReset    ;"SCSI bus failed to reset"
d2844 2
a2845 2
        mess ," - ClaimIRQs",NL
        Push "R0-R4,Link"
d2847 30
a2876 30
        MOV R0,#Podule_DevNo            ;Claim podule IRQ's
        ADRL R1,int_service
        MOV R2,WsPtr
        ADR R3,PR_IntStat
        MOV R4,#Pod_IRQ
        SWI XOS_ClaimDeviceVector

 [ HAL
        Push "R8,R9"
        MOV R0,#Podule_DevNo
        MOV R8,#0
        MOV R9,#EntryNo_HAL_IRQEnable
        SWI XOS_Hardware
        Pull "R8,R9"
        BVC %FT10
 ]
 [ No32bitCode
        MOV R14,PC                      ;Hold current I_bit & F_bit
        TEQP PC,#I_bit+F_bit+SVC_mode   ;Disable IRQs & FIRQs
 |
        MRS R14,CPSR                    ;Hold current I_bit & F_bit
        ORR R1,R14,#I32_bit+F32_bit
        MSR CPSR_c,R1                   ;Disable IRQs & FIRQs
 ]
        MOV R0,#IOC                     ; whilst enabling Podule IRQs
        LDRB R1,[R0,#IOCIRQMSKB]        ; in IOC
        ORR R1,R1,#podule_IRQ_bit
        STRB R1,[R0,#IOCIRQMSKB]
 [ No32bitCode
        TEQP PC,R14                     ;Restore original I_bit & F_bit
d2879 3
a2881 3
 |
        MSR CPSR_c,R14                  ;Restore original I_bit & F_bit
 ]
d2884 1
a2884 1
        Pull "R0-R4,PC",AL
d2888 2
a2889 2
        mess ," - ReleaseIRQs",NL
        Push "R0-R4,Link"
d2891 6
a2896 6
        MOV R0,#Podule_DevNo            ;Claim podule IRQ's
        ADRL R1,int_service
        MOV R2,WsPtr
        ADR R3,PR_IntStat
        MOV R4,#Pod_IRQ
        SWI XOS_ReleaseDeviceVector
d2899 1
a2899 1
        Pull "R0-R4,PC",AL
d2902 1
a2902 1
 [ useTickerV
d2904 7
a2910 7
        mess ," - ClaimTickerV",NL
        Push "R0-R2,Link"
        MOV R0,#TickerV         ;claim 100Hz Vector
        ADDR R1,MyTickerV
        MOV R2,WsPtr
        SWI XOS_Claim
        Pull "R0-R2,PC",AL
d2914 8
a2921 8
        mess ," - ReleaseTickerV",NL
        Push "R0-R2,Link"
        MOV R0,#TickerV
        ADDR R1,MyTickerV
        MOV R2,WsPtr
        SWI XOS_Release
        Pull "R0-R2,PC",AL
 ]
d2924 13
a2936 13
        mess ," - FreezeHardware",NL
        Push "R0-R4,Link"
        MOV R1,#Pod_ForceReset  ;Page 0,interrupts disabled,reset asserted
        wrPageReg R1            ; ie reset SCSIbus,SBIC & DMAC, hold for >25uS

        MOV R0,#RCsoftcopyadr
 [ No32bitCode
        MOV R3,R5,LSR #14               ;
        AND R3,R3,#3                    ;Podule number
 |
        ADD R3,R5,#PoduleSpeedMask      ;Sync base (for Iyonix)
 ]
        SWI XPodule_CallLoader
d2938 1
a2938 1
        Pull "R0-R4,PC",AL
d2942 7
a2948 7
        Push R14
        BL FreezeHardware
 [ useTickerV
        BL ReleaseTickerV
 ]
        BL ReleaseIRQs
        Pull PC
d2969 9
a2977 9
 [ bugfix12
        BIC R1,R1,#LUNIDMask
 ]
        CMP R1,#maxDeviceID
        BHI err_BadDevID
        Push R0
        LDR R0,HostID
        CMP R0,R1
        Pull R0
d2981 1
a2981 1
        MOV PC,Link
d2983 1
a2983 1
        MakeSCSIErrorBlock SCSI_BadDevID    ;"Invalid device ID"
d2997 5
a3001 5
        MOV R9,#:INDEX:deviceRecSize
        MLA R9,R1,R9,WsPtr
        ADD R9,R9,#((:INDEX:DevCB0) :AND: &000000FF)
        ADD R9,R9,#((:INDEX:DevCB0) :AND: &FFFFFF00)
        MOV PC,Link
d3004 1
a3004 1
 [ :LNOT:soft
d3020 6
a3025 6
        Push R0
        LDR R0,AccessKey
        CMP R0,#0
        CMPNE R0,R8
        Pull R0
        MOVEQ PC,Link           ;Not reserved, or reserved and key fits
d3028 1
a3028 1
        MOV PC,Link
d3030 2
a3031 2
        MakeSCSIErrorBlock SCSI_DevReserved ;"SCSI driver reservation error"
 ]
d3033 1
a3033 1
 [ soft
d3035 3
a3037 3
        MOV R1,#&21             ;Features mask supported by this driver (see documentation)
        STR R1,StackedR1
        B exitEntrydecode
d3040 7
a3046 7
        LDMIB WsPtr,{rPODULEptr,rDMACptr}
        BL SCSIop_internal      ;Process the background operation
        trstr "OpEntry out"
        STRVC R0,StackedR1
        MOVVC R0,#-1
        STRVC R0,StackedR0
        B exitEntrydecode
d3052 4
a3055 4
        LDMIB WsPtr,{rPODULEptr,rDMACptr}
        MOV R1,R0
        BL  RaiseATN
        B exitEntrydecode
d3058 2
a3059 2
        ADRL R2,HostVendor
        ADD R3,R2,#HostEnd-HostVendor
d3061 5
a3065 5
        STR R4,[R0],#4
        CMP R2,R3
        BLO %BT10
        B exitEntrydecode
 ]
d3095 1
a3095 1
 [ trace
d3097 1
a3097 1
 ]
d3101 50
a3150 50
 [ {FALSE}
  TST R0,#CTL_TXWRITE
  ORRNE R0,R0,#CTL_INHIBITDISCONNECTION
 ]
        mess ,"SCSIop_internal",NL

        SUB StkPtr,StkPtr,#4
        Push "R0-R2,Link"

        CLRPSR I_bit,Link,,R1   ;To give queued commands a chance to run
        STR R1,[StkPtr,#16]

 [ trace
        Push "R0-R2"
        SWI OS_WriteS
        = "R0="
        ADR R1, MyStringBuff2
        MOV R2, #16
        SWI OS_ConvertHex8
        SWI OS_Write0
        SWI OS_WriteS
        = ", R3="
        ADR R1, MyStringBuff2
        MOV R2, #16
        MOV R0, R3
        SWI OS_ConvertHex8
        SWI OS_Write0
        SWI OS_WriteS
        = ", R4="
        ADR R1, MyStringBuff2
        MOV R2, #16
        MOV R0, R4
        SWI OS_ConvertHex8
        SWI OS_Write0
        SWI OS_NewLine
        Pull "R0-R2"
 ]

        AND R1,R0,#maxDeviceID
        BL AddressDevice        ;In: R1=DeviceID
 [ :LNOT:soft
        TST R0,#CTL_REJECTPODULEBUSY
        BLNE TestPoduleBusy

        TST R0,#CTL_REJECTDEVICEBUSY
        BLNE TestDeviceBusy

        TST R0,#CTL_REJECTQUEUEFULL
        BLNE TestQueueFull
 ]
d3153 3
a3155 3
        BL AllocateCMDslot      ;Out: rCMDptr-> block or rCMDptr=0
        TEQ rCMDptr,#0
 [ soft
d3157 4
a3160 4
        BEQ op_intl_104         ;Return immediately if busy (the SCSI switcher will queue this for us)
 |
        BEQ op_intl_01          ;Loop until a command slot can be claimed
 ]
d3163 31
a3193 31
  ASSERT (CmdXferPtr + 4 = CmdXferLen)
 [ soft
  ASSERT (CmdXferLen + 4 = CmdCallbackR5)
  ASSERT (CmdCallbackR5 + 4 = CmdCallbackAdr)
 |
  ASSERT (CmdXferLen + 4 = CmdTimeout)
  ASSERT (CmdTimeout + 4 = CmdCallbackAdr)
 ]
  ASSERT (CmdCallbackAdr + 4 = CmdCallbackR12)
  ASSERT (R8 = rCMDptr )

        LDR R0,StackedR0
        TST R0,#(CTL_TXREAD :OR: CTL_TXWRITE)
        MOVEQ R4,#0                     ;Zero CmdXferLen if no data xfer

        TEQ R4,#0                       ;Kill read/write bits if CmdXferLen=0
        BICEQ R0,R0,#(CTL_TXREAD :OR: CTL_TXWRITE)

        ADR R1,CmdCallbackR12

 [ :LNOT:soft
        TEQ R5,#0                       ;If user requested default timeout
        LDREQ R5,ControlTimeout         ; load it
 ]

        STMDA R1,{R3,R4,R5,R6,R7}       ;CmdXferPtr,CmdXferLen,CmdTimeout,
                                        ; CmdCallbackAdr,CmdCallbackR12
        LDR R1,StackedR1                ;CDBLen
        LDR R2,StackedR2                ;->CDB
        ADR R3,CmdCDB
        STMDB R3,{R0,R1}                ;CmdDevID,CmdCDBLen
d3196 16
a3211 16
        LDRB R4,[R2],#1                 ;Copy CDB to CmdCDB
        STRB R4,[R3],#1
        SUBS R1,R1,#1
        BGT op_intl_03

        MOV R1,#WAITING
        STR R1,CmdStat          ;Cmd waiting to start execution

        LDR R2,CmdOpID          ;CmdOpID, needed so escape can abort us

 [ soft
        STR R2,StackedR0        ; return CmdOpID to user, incase he needs it
 |
        TST R0,#CTL_BACKGROUND  ;If command will run in the background,
        STRNE R2,StackedR0      ; return CmdOpID to user, incase he needs it
        BNE op_intl_105         ; to call AbortOp, then Skip ...
d3217 8
a3224 8
        ADR R1,CallBackHandler
        STR R1,CmdCallbackAdr
        SUB StkPtr,StkPtr,#CallBkRecSize
        STR StkPtr,CmdCallbackR12

        MOV R1,#RUNNING
        STR R1,[StkPtr,#CallBkStat]
 ]
d3227 2
a3228 2
        BL QueueCMDslot         ;Queue it
        BL StartCommand         ;Try to start it
d3232 3
a3234 3
 [ :LNOT:soft ; operations will always be background in the soft case
        TST R0,#CTL_BACKGROUND
        BNE op_intl_102
d3242 2
a3243 2
       ;LDR R0,CmdDevID
       ;LDR R2,CmdOpID          ;Our OpID, needed so escape can abort us
d3246 1
a3246 1
 [ doEscapeCheck
d3258 20
a3277 24
        TST R0,#CTL_NOESCAPE
        TSTEQ R0,#CTL_DOINGESCAPEDEVICE
        BLEQ TestEscapeStatus   ;R0=CmdDevID,R2=CmdOpID
                                ;May set CTL_DOINGESCAPEDEVICE in R0
 ]
        LDR R1,[StkPtr,#CallBkStat]
        CMP R1,#RUNNING           ;So loop until our command completes
        BEQ op_intl_04

        CMP R1,#ERROR

        ASSERT (CallBkR0 = 0)
        ASSERT (CallBkR1 = CallBkR0 + 4)
        ASSERT (CallBkR2 = CallBkR1 + 4)
        ASSERT (CallRtR3 = CallBkR2 + 4)
        ASSERT (CallRtR4 = CallRtR3 + 4)

        LDMIA StkPtr,{R0,R1,R2,R3,R4}   ; CallBkR0..R2, CallRtR3..R4

        ADD StkPtr,StkPtr,#CallBkRecSize        ;Remove block from stack

        STREQ R0,StackedR0      ;If error occured, pass back ->error
        STREQ R1,StackedR1      ; its cause
        STREQ R2,StackedR2      ; and logical block address
d3279 6
a3284 2
        BEQ op_intl_106
 ] ; :LNOT:soft
d3287 2
a3288 2
        LDR R0,[StkPtr,#16]
        BIC R0,R0,#V_bit
d3290 3
a3292 3
        Pull "R0-R2,Link",AL
        ADD StkPtr,StkPtr,#4
        MOV PC,Link
d3296 1
a3296 1
        STR R0,StackedR0
d3298 2
a3299 2
        LDR R0,[StkPtr,#16]
        ORR R0,R0,#V_bit
d3301 3
a3303 3
        Pull "R0-R2,Link",AL
        ADD StkPtr,StkPtr,#4
        MOV PC,Link
d3305 1
a3305 1
 [ :LNOT:soft
d3307 6
a3312 6
        Push "R2,R3"
        LDR R2,CmdMap
        LDR R3,= CMDBITS
        CMP R2,R3
        Pull "R2,R3"
        MOVEQ PC,Link
d3314 1
a3314 1
        B op_intl_104
d3317 5
a3321 5
        Push R2
        LDR R2,PendingCnt
        TEQ R2,#0
        Pull R2
        MOVEQ PC,Link
d3323 1
a3323 1
        B op_intl_104
d3326 5
a3330 5
        Push R2
        LDR R2,CmdMap
        TEQ R2,#0
        Pull R2
        MOVNE PC,Link
d3332 1
a3332 1
        B op_intl_104
d3340 1
a3340 1
        B exitSWIdecode
d3342 2
a3343 2
        MakeSCSIErrorBlock SCSI_NotIdle     ;"Device not idle"
 ] ;LNOT:soft
d3357 1
a3357 1
        Push "R0,Link"
d3359 9
a3367 9
        ORR R0,R0,R1
        ORR R0,R0,#CTL_MessageOnly
        ADRL R2,cdb_inquiry_notransfer
        LDR R1,[R2],#4          ;CDB length, R2 now->CDB
        MOV R4,#0               ;Xfer count=0
        MOV R5,#0               ;Default timeout
        MOV R6,#0               ;CallbackAdr } ie don't call us
        MOV R7,#0               ;CallbackR12 }
        BL SCSIop_internal
d3370 1
a3370 1
        Pull "R0,PC",AL
d3393 10
a3402 10
        ASSERT (CallBkR1 = CallBkR0 + 4)
        ASSERT (CallBkR2 = CallBkR1 + 4)
        ASSERT (CallRtR3 = CallBkR2 + 4)
        ASSERT (CallRtR4 = CallRtR3 + 4)
        ASSERT (CallBkStat = CallRtR4 + 4)

        MOVVC R5,#IDLE
        MOVVS R5,#ERROR
        STMIA R12,{R0,R1,R2,R3,R4,R5}
        MOV PC,Link
d3423 69
a3491 69
 [ counts
        Push "R0-R1"
        ADRL R0, MyInfoSpace1
        LDR R1, [R0, #8]
        ADD R1, R1, #1
        STR R1, [R0, #8]

        LDR R1, SBICStat
        ADD R0, R0, #40                 ; Error count !!
        CMP R1, #IDLE
        SUBEQ R0, R0, #24
        CMP R1, #RUNNING
        SUBEQ R0, R0, #20
        CMP R1, #STALLED
        SUBEQ R0, R0, #16
        CMP R1, #WAITING
        SUBEQ R0, R0, #12
        CMP R1, #INITIALISING
        SUBEQ R0, R0, #8
        CMP R1, #INITIALISED
        SUBEQ R0, R0, #4
        LDR R1, [R0, #0]
        ADD R1, R1, #1
        STR R1, [R0, #0]
        Pull "R0-R1"
 ]

        Push "R0-R11,Link"      ;>>>Overkill
        LDMIB WsPtr,{rPODULEptr,rDMACptr}  ;R10,R11

 trstr "StartCommand POD="
 trhex rPODULEptr
 trstr " DMAC="
 trhex rDMACptr
 trstr "  "

        SETPSR I_bit,R0,,Link
        Push Link

        LDR R0,Lockout
        TEQ R0,#0
        BNE St_Cmd_40

        LDRB R0,SBICauxstat
        TST R0,#INT
        BNE St_Cmd_40

        MOV R0,#Pod_EnableInts  ;Incase some ASS-HOLE has poked our page
        wrPageReg R0            ; register and left our ints disabled

        BL NextCommand
        TEQ rCMDptr,#0
        BEQ St_Cmd_40           ;None, so return

        LDR R0,CmdDevID         ;Composite of DeviceID & Rd/Wr/Bk bits
        AND R1,R0,#maxDeviceID
        BL AddressDevice        ;In: R1=DeviceID
                                ;Out: R1=DeviceID, R9->deviceblk
 [ bugfix6
 |
        STR R9,DEVICEptr        ;Register device with interrupt handler
 ]
        STR rCMDptr,CMDptr      ;Register the command with this device

      trstr "Starting "

        LDR R2,CmdStat
        CMP R2,#INITIALISED
        BEQ St_Cmd_10
d3501 2
a3502 2
        MOV R2,#INITIALISING
        STR R2,CmdStat
d3504 5
a3508 5
        ASSERT ((CmdXferPtr + 4) = CmdXferLen)
 [ soft
        ADR R2,CmdXferPtr
        LDMIA R2,{R3,R4}        ;CmdXferPtr,CmdXferLen
 |
d3514 11
a3524 1
        TST R0,#CTL_DOINGREQUESTSENSE
d3526 4
a3529 32
        ASSERT ((CmdXferPtr + 4) = CmdXferLen)
        ADREQ R2,CmdXferPtr
        LDMEQIA R2,{R3,R4}      ;CmdXferPtr,CmdXferLen

        ADRNE R3,SenseBlk
        MOVNE R4,#REQUESTSENSE_BLK_SIZE
        BICNE R0,R0,#(CTL_TXWRITE :OR: CTL_SCATTER)
        ORRNE R0,R0,#CTL_TXREAD
 ]

        STR R0,CpyCtl
        STR R3,CpyAdr
        STR R4,CpyCnt           ;Trying to Xfer R4 bytes
        STR R4,CurrTtlCnt           ;

 [ soft
        STR R3,CurrScatPtr
 |
        TST R0,#CTL_SCATTER     ;If scatter list supplied,
        STRNE R3,CurrScatPtr    ; save pointer to it
        ADREQ R5,FakeScatterAdr ;else
        STMEQIA R5,{R3,R4}      ; fake one using supplied addr & len
        STREQ R5,CurrScatPtr    ;
 ]

        MOV R4,#0               ;Zero CurrEntCnt to force FillSlot to get
        STR R4,CurrEntCnt       ; first (may be Fake) scatter list entry

 [ :LNOT:soft
        LDR R4,CmdTimeout       ;Prepare the timeout counter
        STR R4,Timeout          ; (runs only if select phase succeds)
 ]
d3531 17
a3547 1
        MOV R5,R0               ;Leave CpyCtl in R5
d3549 3
a3551 1
 [ {TRUE}
d3557 41
a3597 41
        Push "R1-R4"
        LDR R1,CurrScatPtr
        LDR R2,CurrEntAdr
        LDR R3,CurrEntCnt
        LDR R4,CurrTtlCnt

        STR R1,SavdScatPtr
        STR R2,SavdEntAdr
        STR R3,SavdEntCnt
        STR R4,SavdTtlCnt
        Pull "R1-R4"
 ]
 [ debug
        MOV R3,#-1
        STR R3,TargStat
        STR R3,HostStat
        STR R3,HostStat1
        STR R3,HostStat2
        STR R3,HostStat3
        STR R3,HostStat4
        STR R3,HostStat5
        STR R3,HostStat6
        STR R3,HostStat7
 |
        MOV R3,#-1
        STR R3,TargStat
        STR R3,HostStat
        STR R3,HostStat1
 ]

 [ bugfix2
        MOV R3,#0               ;For now, all messages (out) are allowed
        STR R3,Suppress         ;
 ]
        MOV R3,#MESSAGE_NOOPERATION
        STR R3,MessageIn                ;Safe values
        STR R3,MessageOut               ;

        MOV R3,#:INDEX:Queue0   ;Queue empty
        STR R3,QStart
        STR R3,QEnd
d3608 7
a3614 7
        MOV R3,#RUNNING
        STR R3,DeviStat
        STR R3,SBICStat

        MOV R3,#IDLE
        STR R3,DMACStat
        STR R3,CopyStat
d3616 2
a3617 2
        TST R5,#(CTL_TXREAD :OR: CTL_TXWRITE)
        BEQ St_Cmd_10
d3622 3
a3624 3
        MOV R3,#STALLED
        STR R3,CopyStat
        STR R3,DMACStat
d3633 2
a3634 2
        TST R5,#CTL_TXWRITE
        BNE St_Cmd_05
d3638 7
a3644 7
        BL AllocateRAM          ;Out CC & R7 (rPAGESLOTptr) ->RamRec
       ;BCS help                ;    CS for failed
        trstr "Allocated "

        STR R7,DMACram          ;DMAC will queue this when its full
        BL FillSlot         ;In/Out: R7->RamRec
        B St_Cmd_10
d3650 18
a3667 26
 [ {TRUE}
 [ {TRUE}
        Push "R1-R4"
        LDR R1,CurrScatPtr
        LDR R2,CurrEntAdr
        LDR R3,CurrEntCnt
        LDR R4,CurrTtlCnt
        STR R1,FutrScatPtr
        STR R2,FutrEntAdr
        STR R3,FutrEntCnt
        STR R4,FutrTtlCnt
        Pull "R1-R4"
        ADR R7,DemandSlot
        BL FillSlot
 ]

        MOV R0,#STALLED         ;STALL copier so that PreWriteBlk
        STR R0,CopyStat         ; will work

        BL PreWriteBlk
       ;BCS help                ;    CS for failed
        BL UnQueueSlot
        STR R7,DMACram          ;First block given to DMAC
 |
        BL AllocateRAM          ;Out CC & R7 (rPAGESLOTptr) ->RamRec
       ;BCS help                ;    CS for failed
d3669 10
a3678 2
        STR R7,DMACram          ;First block given to DMAC
        BL FillSlot         ;In/Out: R7->RamRec
d3682 12
a3693 12
        MOV R0,#RUNNING
        STR R0,CopyStat
        BL WriteBlkToSRAM       ;Write block to SRAM. In R8->Slot
                                ; IRQs enabled whilst copying

        LDR R0,CurrTtlCnt           ;If no more data to copy,
        TEQ R0,#0
        MOVEQ R0,#IDLE      ; IDLE the copier
        MOVNE R0,#STALLED       ; else STALL it
        STR R0,CopyStat
     ;>>>   BL QueueSlot            ;In: R7=SlotNum(0..15)
 ]
d3704 11
a3714 11
        trstr "Initialised "
        LDR R5,CpyCtl
        LDR R7,DMACram

        LDR rCMDptr,CMDptr
        MOV R0,#INITIALISED
        STR R0,CmdStat

        LDRB R0,SBICauxstat
        TST R0,#INT
        BNE St_Cmd_40
d3724 2
a3725 2
        AND R0,R5,#(CTL_TXREAD :OR: CTL_TXWRITE)
        CMP R0,#CTL_TXREAD
d3727 37
a3763 37
        MOVEQ R0,#dma_rd_mode   ;&04 demand mode,read
        ORREQ R1,R1,#DPD        ;&40 Data Phase Direction is read
        MOVGT R0,#dma_wr_mode   ;&08 demand mode,write

        BLGE ArmDMAC            ;In/Out: R7->RamRec

 [ bugfix12
        LDR R0,CmdDevID
        AND R0,R0,#LUNIDMask
        MOV R0,R0,LSR #LUNIDShft
 |
        MOV R0,#0
 ]
        wrSBIC R0,SR_TargetLUN

        TST R5,#CTL_INHIBITDISCONNECTION
        MOVNE R0,#0
        MOVEQ R0,#ER            ;&80
        wrSBIC R0,SR_SourceID
        wrSBIC R1,SR_DestID     ;Setup TargetID and DPD

        LDR rCMDptr,CMDptr
        BL LoadCDBregisters     ;In R5=CpyCtl, corrupts R0,R2,R3

        LDR R4,CpyCnt
        wrSBIC24 R4,SR_Count    ;Write Total Transfer count to SBIC

        MOV R0,#0               ;Ensure any SAT command starts from the
        wrSBIC R0,SR_Phase      ; beginning (cos <>0 implies Resume-SAT)

        TST R5,#CTL_INHIBITIDENTIFY
        MOVNE R0,#SC_Sel_Tx_woATN
        MOVEQ R0,#SC_Sel_Tx_withATN

        TST R5,#(CTL_DOINGRESET :OR: CTL_DOINGABORTDEVICE)
        MOVNE R0,#SC_Sel_withATN
        wrSBIC R0,SR_Command
d3775 3
a3777 3
        LDRB R0,SBICauxstat     ;
        TST R0,#LCI
        BNE St_Cmd_40
d3780 3
a3782 3
        MOV R0,#1               ;Any non-zero value
        STR R0,Connected        ;We are now (probably) connected to Target
        STR R0,Lockout
d3784 2
a3785 2
        MOV R0,#RUNNING
        STR R0,CmdStat
d3788 3
a3790 3
 [ bugfix6
        STR R9,DEVICEptr        ;Register device with interrupt handler
 ]
d3792 4
a3795 4
 [ {FALSE}
        TST R5,#CTL_TXWRITE     ;Try copying & queueing the next block
        BLNE PreWriteBlk        ; before the DMAC demands it
 ]
d3797 2
a3798 2
        trstr "StartCommand out "
        Pull Link
d3800 1
a3800 1
        Pull "R0-R11,PC",AL
d3819 5
a3823 5
        Push "R0-R11,Link"
        LDMIA WsPtr,{rDEVICEptr, rPODULEptr,rDMACptr}  ;R9,R10,R11
        LDRB R0,PR_IntStat
        TST R0,#SB_IRQ
        BNE int_service_SBIC    ;Interrupt from SBIC
d3825 2
a3826 2
        TST R0,#TC_IRQ
        BEQ int_ser_200         ;Not interrupting
d3830 9
a3838 1
        LDR rCMDptr,CMDptr
d3840 5
a3844 13
        MOV R0,#0
        STRB R0,PR_ClrInt       ;Clear the DMAC Terminal count interrupt
        MOV R0,#set_mask
        wrDMAC R0,DR_Mask
 [ readback
        LDRB R0,PR_IntStat
 ]

        LDR R0,CpyCtl
        TST R0,#CTL_TXWRITE
        BNE int_DMAC_TC_Writing
        TST R0,#CTL_TXREAD
        BEQ int_ser_100
d3851 10
a3860 10
        LDR R7,DMACram                  ;Advance current pointers by amount
        BL AdvanceCurrentPointers       ; just transfered.       In R7->RamRec
        BL QueueSlot                    ;Queue block for copier  In R7->RamRec
 [ efficient
 |
   MOV R7,#-1
   STR R7,DMACram
 ]
        MOV R0,#STALLED         ;DMAC completed a page, stall for now, maybe
        STR R0,DMACStat         ; able to restart it
d3863 2
a3864 2
                                ;Either stalled by above, or under interrupt
                                ; whilst in copier, below
d3866 6
a3871 6
        LDR R0,SBICStat         ;If SBIC has stopped
        CMP R0,#IDLE            ; (if not, & CurrTtlCnt=0, leave stalled
                                ;  incase of data overrun)
        MOVEQ R0,#IDLE
        STREQ R0,DMACStat       ; stop the DMAC, the data in SRAM needs
        BEQ int_TC_rd_20        ; to be copied to MainRAM
d3880 2
a3881 2
        BL AllocateRAM          ;Out CC & R7 (rPAGESLOTptr) ->RamRec
        BCS int_TC_rd_20        ;    CS for failed
d3883 1
a3883 1
        STR R7,DMACram          ;DMAC will queue this when its full
d3885 1
a3885 1
        BL FillSlot         ;In/Out: R7->RamRec
d3887 2
a3888 2
        MOV R0,#dma_rd_mode
        BL ArmDMAC     ;In/Out: R7->RamRec
d3891 3
a3893 3
        LDR R0,CopyStat         ;If already running, return to it
        CMP R0,#RUNNING         ; else copy next queued block
        BEQ int_TC_rd_40        ;
d3896 1
a3896 1
        BL ReadBlkFromSRAM      ;IRQs enabled whilst copying, disabled on exit
d3898 12
a3909 12
        LDR R0,DMACStat         ;If DMAC interrupted whilst in ReadBlkFromSRAM
        CMP R0,#STALLED         ; it may have been stalled, if so loop back
        BEQ int_TC_rd_10        ; to try to restart it

        LDR R0,QStart
        LDR R1,QEnd
        CMP R0,R1               ;If queue not empty, loop back to copy another
        BNE int_TC_rd_30        ; page

        LDR R0,DMACStat         ;Queue empty & DMAC finished means no more data
        CMP R0,#IDLE
        STREQ R0,CopyStat       ; so stop copier
d3912 1
a3912 1
        B int_ser_100
d3920 1
a3920 1
        Push "R0-R11,Link"      ;>>>Overkill
d3922 2
a3923 2
        MOV R0,#STALLED         ;Stall DMAC, may be able to restart it if
        STR R0,DMACStat         ; enough slots in queue
d3925 11
a3935 11
        LDR R7,DMACram                  ;Advance current pointers by amount
        BL AdvanceCurrentPointers       ; just transfered. In R7->RamRec
        BL DeAllocateRAM                ; and dispose of the completed block
 [ efficient
 |
   MOV R7,#-1
   STR R7,DMACram
 ]
        BL Restart_DMAC_Writing
        Pull "R0-R11,Link"      ;>>>Overkill
        B int_ser_100
d3938 1
a3938 1
 [ bugfix13
d3949 1
a3949 1
        Push "R0-R11,Link"      ;>>>Overkill    ;>>>>> DMACStat WILL BE STALLED
d3955 4
a3958 4
        LDR R0,QStart                           ;If data has been queued (ie already
        LDR R1,QEnd                             ; copied to SRAM)
        CMP R0,R1                               ;
        BNE int_TC_wr_20                        ; try giving it to the DMAC
d3963 8
a3970 8
        LDR R0,CopyStat         ;If CopyStat=IDLE Stop the DMAC
        CMP R0,#IDLE
        STREQ R0,DMACStat

       ;LDR R0,CopyStat
        CMP R0,#STALLED         ;Interrupted the copier, so return, when copier
        BNE int_TC_wr_30        ; finishs, it will see the stalled DMAC and
                                ; restart it. >>>>combine with above 3 lines
d3977 1
a3977 1
        ASSERT PtrRecSize=16
d3979 11
a3989 11
        ADR R0,CurrentPointers
        LDMIA R0,{R1,R2,R3,R4}
        ADR R0,FuturePointers
        STMIA R0,{R1,R2,R3,R4}

        BL PreWriteBlk

        LDR R0,DMACStat
        CMP R0,#STALLED
        BEQ int_TC_wr_10        ;Loop back to check if PreWriteBlk queued anything
        BNE int_TC_wr_30        ;Give up and go home
d3995 2
a3996 2
        ADR R7,DemandSlot       ;RamTxAdr & RamBlkSz that the DMAC wants
        BL FillSlot             ; so lets see what's been copied to SRAM
d3998 2
a3999 2
        BL UnQueueSlot          ;Out: R7->RamRec
        STR R7,DMACram          ;DMAC will DeAllocate this when its empty
d4014 1
a4014 1
        LDMIA rPAGESLOTptr,{R0,R1}      ;RamTxAdr,RamBlkSz
d4016 2
a4017 2
        LDR R4,DemandSlot+:INDEX:RamTxAdr
        LDR R5,DemandSlot+:INDEX:RamBlkSz
d4019 6
a4024 6
        CMP R0,R4               ;If RamTxAdr<>CurrEntAdr
        BLNE DeAllocateRAM      ;
        BNE int_TC_wr_10        ;
        CMP R1,R5               ; or RamBlkSz>CurrEntCnt
        BLGT DeAllocateRAM      ; ditch the block
        BGT int_TC_wr_10        ; loop back to look for a better one
d4029 2
a4030 2
        MOV R0,#dma_wr_mode     ;Restart the DMAC in write mode
        BL ArmDMAC              ;In/Out: R7->RamRec
d4033 1
a4033 1
        BL PreWriteBlk
d4035 3
a4037 3
        LDR R0,DMACStat         ;If DMAC stalled whilst copying the above block
        CMP R0,#STALLED
        BEQ int_TC_wr_10        ; restart it, (with above block)
d4040 3
a4042 3
        LDR R0,SBICStat
        CMP R0,#IDLE
        BLEQ FlushQueue    ;>>>should this be elsewhere????
d4044 1
a4044 1
        Pull "R0-R11,PC"       ;>>>Overkill
d4047 1
a4047 1
 |
d4051 4
a4054 4
        Push "R0-R11,Link"      ;>>>Overkill
        LDR R0,DMACStat
        CMP R0,#STALLED
        BNE int_TC_wr_25
d4057 4
a4060 4
        LDR R0,QStart
        LDR R1,QEnd
        CMP R0,R1
        BNE int_TC_wr_20
d4066 8
a4073 8
        LDR R0,CopyStat         ;If CopyStat=IDLE Stop the DMAC
        CMP R0,#IDLE
        STREQ R0,DMACStat

        LDR R0,CopyStat
        CMP R0,#STALLED         ;Interrupted the copier, so return, when copier
        BNE int_TC_wr_30        ; finishs, it will see the stalled DMAC and
                                ; restart it. >>>>combine with above 3 lines
d4080 1
a4080 1
        ASSERT PtrRecSize=16
d4082 10
a4091 10
        ADR R0,CurrentPointers
        LDMIA R0,{R1,R2,R3,R4}
        ADR R0,FuturePointers
        STMIA R0,{R1,R2,R3,R4}

        BL PreWriteBlk

        LDR R0,DMACStat
        CMP R0,#STALLED
        BNE int_TC_wr_30
d4096 2
a4097 2
        ADR R7,DemandSlot       ;RamTxAdr & RamBlkSz that the DMAC wants
        BL FillSlot             ; so lets see what's been copied to SRAM
d4099 2
a4100 2
        BL UnQueueSlot          ;Out: R7->RamRec
        STR R7,DMACram          ;DMAC will DeAllocate this when its empty
d4115 1
a4115 1
        LDMIA rPAGESLOTptr,{R0,R1}      ;RamTxAdr,RamBlkSz
d4117 2
a4118 2
        LDR R4,DemandSlot+:INDEX:RamTxAdr
        LDR R5,DemandSlot+:INDEX:RamBlkSz
d4120 6
a4125 6
        CMP R0,R4               ;If RamTxAdr<>CurrEntAdr
        BLNE DeAllocateRAM      ;
        BNE int_TC_wr_10        ;
        CMP R1,R5               ; or RamBlkSz>CurrEntCnt
        BLGT DeAllocateRAM      ; ditch the block
        BGT int_TC_wr_10        ; loop back to look for a better one
d4130 2
a4131 2
        MOV R0,#dma_wr_mode     ;Restart the DMAC in write mode
        BL ArmDMAC              ;In/Out: R7->RamRec
d4134 2
a4135 2
        BL PreWriteBlk
        BCS int_TC_wr_30
d4137 3
a4139 3
        LDR R0,DMACStat         ;If DMAC stalled whilst copying the above block
        CMP R0,#STALLED
        BEQ int_TC_wr_20        ; restart it, (with above block)
d4142 7
a4148 7
        LDR R0,SBICStat
        CMP R0,#IDLE
        BLEQ FlushQueue    ;>>>should this be elsewhere????

        Pull "R0-R11,Link"      ;>>>Overkill
        MOV PC,Link
 ]
d4155 1
a4155 1
        LDR rCMDptr,CMDptr
d4157 4
a4160 4
        LDRB R1,SBICauxstat
        TST R1,#INT
        BEQ int_ser_99          ;Not interrupting, so return
        rdSBIC R0,SR_SCSIstat
d4164 20
a4183 2
        CMP R0,#&81             ;Reselected (advanced mode)
        BEQ int_ser_73
d4185 2
d4188 2
d4191 12
a4202 34
 [ debug
        STR R1,HostAuxStat
        Push "R1-R8"
        ADRL R8,HostStat
        LDMIA R8,{R1-R7}
        STMIA R8,{R0-R7}
        Pull "R1-R8"
 |
        LDR R2,HostStat
        STR R2,HostStat1
        STR R0,HostStat         ;Everything else is useful
 ]

        CMP R0,#&11
        BEQ int_ser_code_11     ;Select command completed OK

        CMP R0,#&16
        BEQ int_ser_10          ;Select-And-Transfer completed OK

        CMP R0,#&20
        BEQ int_ser_40          ;MessageIn paused

        CMP R0,#&21             ;Paused after receipt of a 'save data pointers'
        BEQ int_ser_code_21     ; message

        CMP R0,#&85             ;Disconnect has occured
        BEQ int_ser_50

        CMP R0,#&41             ;Unexpected disconnection
 [ SQ555kludge
        BEQ int_ser_SQ555
 |
        BEQ int_ser_49          ; do unexpected disconnection code
 ]
d4207 6
a4212 6
        CMP R0,#&48             ;Unexpected DataOut
        BEQ int_ser_13
        CMP R0,#&18
        BEQ int_ser_14
        CMP R0,#&88
        BEQ int_ser_65
d4217 6
a4222 6
        CMP R0,#&49             ;Unexpected DataIn phase
        BEQ int_ser_15
        CMP R0,#&19
        BEQ int_ser_16
        CMP R0,#&89
        BEQ int_ser_66
d4227 6
a4232 6
        CMP R0,#&4A
        BEQ int_ser_code_4A
        CMP R0,#&1A
        BEQ int_ser_code_1A
        CMP R0,#&8A
        BEQ int_ser_code_8A
d4237 6
a4242 6
        CMP R0,#&1B
        BEQ int_ser_27
        CMP R0,#&4B
        BEQ int_ser_20          ;Unexpected Status phase
        CMP R0,#&8B
        BEQ int_ser_22          ;REQ signal asserted, Status phase requested
d4247 6
a4252 6
        CMP R0,#&4E
        BEQ int_ser_59
        CMP R0,#&8E
        BEQ int_ser_60
        CMP R0,#&1E
        BEQ int_ser_61
d4257 6
a4262 6
        CMP R0,#&1F
        BEQ int_ser_30          ;A transfer command completed, MessageIn phase
        CMP R0,#&4F
        BEQ int_ser_24          ;Unexpected MessageIn phase
        CMP R0,#&8F
        BEQ int_ser_23          ;REQ signal asserted, MessageIn phase requested
d4268 2
a4269 2
        CMP R0,#HOST_TIMEOUT
        BEQ int_ser_70
d4271 1
a4271 1
        B int_ser_99
d4284 2
a4285 2
        ASSERT (HoldPhase = HoldCmd + 4)
        ASSERT (HoldCount = HoldPhase + 4)
d4287 5
a4291 5
        MOV R0,#SC_Sel_Tx_woATN ;
        MOV R1,#&20             ;
        MOV R2,#0               ;
        ADR R3,HoldCmd
        STMIA R3,{R0,R1,R2}     ;HoldCmd,HoldPhase,HoldCount
d4293 1
a4293 1
        B int_ser_99
d4307 2
a4308 2
        rdSBIC R0,SR_TargetLUN          ;Get returned Target Status byte
        STR R0,TargStat
d4310 3
a4312 3
        MOV R0,#MESSAGE_COMMANDCOMPLETE ;Target sent this, but the SBIC didn't
        STR R0,MessageIn                ; pass it on, so pretend it did
 [ bugfix2
d4317 8
a4324 8
        MOV R0,#CTL_Suppress
        STR R0,Suppress
 ]
        BL StopDataTX           ;SBIC transfer count register WILL BE 0

        MOV R0,#IDLE            ;SBIC now completed
        STR R0,SBICStat
        B int_ser_99
d4339 1
a4339 1
        BL StopDataTX           ;Marks state as cannot do ResumeSAT
d4347 2
a4348 2
        BL NudgePhase_41        ;If phase<41, set to 41
        BL TryResumeSAT         ;Returns only if impossible
d4350 2
a4351 2
 [ bugfix9
        MOV R0,#0
d4353 1
a4353 1
 ]
d4355 8
a4362 14
 [ counts
        Push "R0-R1"
        ADRL R0, MyInfoSpace1
        LDR R1, [R0, #4]
        ADD R1, R1, #1
        STR R1, [R0, #4]
        Pull "R0-R1"
 ]

        MOV R0,#SC_Transfer_Info_SBT    ;Single byte transfer over SCSI bus
        wrSBIC R0,SR_Command
        BL DBR_wait                     ;Wait for data buffer empty
        MOV R0,#&42
        wrSBIC R0,SR_Data               ;Write data byte to SBIC
d4364 7
a4370 1
        B int_ser_99
d4385 1
a4385 1
        BL StopDataTX           ;Marks state as cannot do ResumeSAT
d4393 2
a4394 2
        BL NudgePhase_41        ;If phase<41, set to 41
        BL TryResumeSAT         ;Returns only if impossible
d4396 2
a4397 2
        BL FillJunkSlot
        STR R7,DMACram
d4399 2
a4400 2
        MOV R0,#dma_rd_mode
        BL ArmDMAC              ;In/Out: R7->RamRec
d4402 1
a4402 1
        LDR rCMDptr,CMDptr      ;cos register shared with rPAGESLOTptr
d4404 1
a4404 1
        MOV R0,#PAGESIZE
d4406 2
a4407 2
        MOV R0,#SC_Transfer_Info
        wrSBIC R0,SR_Command
d4409 1
a4409 1
        B int_ser_99
d4433 3
a4435 3
        BL HoldSBICstate
        MOV R1,#&20
        STR R1,HoldPhase
d4438 5
a4442 5
        MOV R0,#SC_Sel_Tx_withATN       ;Resume SATwithATN
        MOV R1,#&20   ;&30              ; after the identify MessageOut
        ADR R3,HoldCmd                  ; phase
        STMIA R3,{R0,R1}                ;HoldCmd,HoldPhase
        BL TryResumeSAT                 ;Won't return
d4444 1
a4444 1
        B int_ser_99
d4459 1
a4459 1
        BL StopDataTX           ;Marks state as cannot do ResumeSAT
d4462 1
a4462 1
        BL TryResumeSAT         ;Returns only if impossible
d4464 5
a4468 5
        MOV R0,#SC_Transfer_Info_SBT    ;Single byte transfer
        wrSBIC R0,SR_Command
        BL DBR_wait                     ;Wait for data ready
        rdSBIC R0,SR_Data               ;Fetch the status byte
        STR R0,TargStat
d4470 1
a4470 1
        B int_ser_99
d4485 1
a4485 1
        BL HoldSBICstate
d4488 4
a4491 1
        LDR rCMDptr,CMDptr
d4493 1
a4493 2
        MOV R0,#SC_Transfer_Info_SBT    ;Single byte transfer over SCSI bus
        wrSBIC R0,SR_Command
d4495 19
a4513 1
        BL DBR_wait             ;Wait for data buffer empty
d4515 3
a4517 35
        LDR R1,CmdDevID                 ;Test CmdDevID for reasons
 [ bugfix2
        LDR R0,Suppress         ;Some reasons maybe suppressed, after
        BIC R1,R1,R0            ; MESSAGE_COMMANDCOMPLETE received
 ]
 [ rejectnaffmessages
        MOV R0,#MESSAGE_REJECT          ; that require a 'Reject'

        MOV R2,#CTL_DOINGMESSAGEREJECT
        TST R1,R2
        BNE message_go
 ]
        MOV R0,#MESSAGE_BUSDEVICERESET  ; or 'BusDeviceReset'

        MOV R2,#CTL_DOINGRESET
        TST R1,R2
        BNE message_go

        MOV R0,#MESSAGE_ABORT           ; or 'DeviceAbort'

        MOV R2,#CTL_DOINGABORTDEVICE
        TST R1,R2
        BNE message_go

        MOV R2,#CTL_DOINGABORTOP
        TST R1,R2
        BNE message_go

        MOV R2,#CTL_DOINGESCAPEDEVICE
        TST R1,R2
        BNE message_go

        MOV R2,#CTL_DOINGTIMEOUT2
        TST R1,R2
        BNE message_go
d4519 14
a4532 2
        MOV R0,#MESSAGE_NOOPERATION     ;Un-solicited MessageOut, send NOP
        MOV R2,#0
d4534 7
a4540 7
        ORR R0,R0,R2            ;Mark the message with the reason for sending
        BIC R1,R1,R2            ;Clear reason from CmdDevID
        STR R1,CmdDevID

        STR R0,MessageOut
        wrSBIC R0,SR_Data       ;Write message byte to SBIC
        B int_ser_200
d4555 1
a4555 1
        BL HoldSBICstate
d4558 5
a4562 5
        MOV R0,#SC_Transfer_Info_SBT    ;Use single byte transfer mode
        wrSBIC R0,SR_Command            ;
        BL DBR_wait                     ; (wait for data ready)
        rdSBIC R0,SR_Data               ; to fetch the message byte
        STR R0,MessageIn
d4564 1
a4564 1
        B int_ser_99
d4574 1
a4574 1
        LDR R0,MessageIn
d4576 3
a4578 3
        CMP R0,#MESSAGE_SAVEDATAPOINTER         ;Carefull, as we've read bytes
        ADREQ Link,int_ser_43                   ; to get the message, SR_Count
        BEQ SaveCurrentPointers_UseHold         ; is invalid
d4580 2
a4581 2
        CMP R0,#MESSAGE_RESTOREDATAPOINTER
        BNE int_ser_41
d4583 1
a4583 1
        BL RestoreCurrentPointers
d4585 2
a4586 2
        MOV R0,#&45                     ;'Resume Select-And-Transfer' ready
        wrSBIC R0,SR_Phase              ; for data transfer phase. May get
d4588 3
a4590 3
        MOV R0,#SC_Sel_Tx_withATN       ; Status or MessageIn. An implied
        wrSBIC R0,SR_Command            ; Negate ACK occurs
        B int_ser_99
d4593 4
a4596 4
        CMP R0,#MESSAGE_COMMANDCOMPLETE ;If MessageIn is command complete
        MOVEQ R0,#IDLE
        STREQ R0,SBICStat               ; SBIC now completed
 [ bugfix2
d4601 17
a4617 17
        MOVEQ R0,#CTL_Suppress
        STREQ R0,Suppress
 ]
        BEQ int_ser_43

        CMP R0,#MESSAGE_REJECT          ;Target rejected our message so pretend
        MOVEQ R1,#MESSAGE_NOOPERATION   ; we never sent it (prevents the next
        STREQ R1,MessageOut             ; disconnection being mis-interpreted
        BEQ int_ser_43                  ; as a successful abort/reset).

        CMP R0,#MESSAGE_DISCONNECT      ;Controller normally hides this, but
        BEQ int_ser_43                  ; may appear outside a SAT command


 [ rejectnaffmessages
        CMP R0,#MESSAGE_EXTENDEDMESSAGE
        BNE RejectIt
d4621 17
a4637 17
        MOV R0,#SC_NegateACK    ;Negate ACK (on the MESSAGE_EXTENDEDMESSAGE)
        wrSBIC R0,SR_Command
                                ;Now wait for the Extended message length byte
        BL INT_wait
        rdSBIC R0,SR_SCSIstat
        CMP R0,#&8F
        BNE int_service_01

        MOV R0,#SC_Transfer_Info_SBT    ;Use single byte transfer mode
        wrSBIC R0,SR_Command            ;
        BL DBR_wait                     ; (wait for data ready)
        rdSBIC R1,SR_Data               ; to fetch the message length byte

        BL INT_wait
        rdSBIC R0,SR_SCSIstat
        CMP R0,#&20
        BNE int_service_01
d4639 2
a4640 2
        CMP R1,#0               ;Zero means 256 bytes follow
        MOVEQ R1,#256           ;
d4642 22
a4663 22
        MOV R0,#SC_NegateACK    ;Negate ACK (length/code/argument byte)
        wrSBIC R0,SR_Command
                                ;Now wait for the message code/argument bytes
        BL INT_wait
        rdSBIC R0,SR_SCSIstat
        CMP R0,#&8F
        BNE int_service_01

        MOV R0,#SC_Transfer_Info_SBT    ;Use single byte transfer mode
        wrSBIC R0,SR_Command            ;
        BL DBR_wait                     ; (wait for data ready)
        rdSBIC R0,SR_Data               ; to fetch the code/argument byte

        BL INT_wait
        rdSBIC R0,SR_SCSIstat
        CMP R0,#&20
        BNE int_service_01

        SUBS R1,R1,#1           ;If more bytes to come, loop back to Negate ACK
        BNE int_ser_42          ; for this one, then expect another byte
                                ;Else since we support NONE of the extended
                                ; messages, drop into...
d4669 8
a4676 8
        LDR R0,CmdDevID
        ORR R0,R0,#CTL_DOINGMESSAGEREJECT
        STR R0,CmdDevID

        BL nCIP_wait
        MOV R0,#SC_AssertATN
        wrSBIC R0,SR_Command
 ]
d4679 4
a4682 4
        BL nCIP_wait
        MOV R0,#SC_NegateACK    ;Negate ACK
        wrSBIC R0,SR_Command
        B int_ser_99
d4693 7
a4699 7
        BL SaveCurrentPointers
        MOV R0,#&41             ;>>>Do we need this, command phase register
        wrSBIC R0,SR_Phase      ;>>> should be &41 already

        MOV R0,#SC_Sel_Tx_withATN       ;'Resume Select-And-Transfer' after
        wrSBIC R0,SR_Command            ; receipt of 'Save data pointers'
        B int_ser_99
d4706 9
a4714 9
 [ debug
 [ {FALSE}
   rdSBIC R0,SR_Command
   rdSBIC R1,SR_Phase
   MOV R14,#-1
   LDR R14,[R14]
 ]
 ]
        MOV R0,#TARGET_UNEXPECTEDDISCONNECT
d4716 31
a4746 31
        STR R0,TargStat         ;Pseudo status
 [ {FALSE}
        BL ResetDMAC            ;Stop DMAC

        LDR R0,DMACStat
        CMP R0,#RUNNING
        LDREQ R7,DMACram
        BLEQ DeAllocateRAM

        MOV R0,#IDLE            ;SBIC now IDLE
        STR R0,SBICStat
        STR R0,DMACStat         ; as is the DMAC

        MOV R0,#0
        STR R0,Connected        ; and no longer connected
        STR R0,Lockout
 |
        BL StopDataTX

        MOV R0,#IDLE            ;SBIC IDLEd
        STR R0,SBICStat

        MOV R0,#0
        STR R0,Connected        ; and no longer connected
        STR R0,Lockout
 ]
 [ bugfix5
        MOV R0,#ER              ;&80 allow other targets to reselect
        wrSBIC R0,SR_SourceID
 ]
        B int_ser_99
d4770 13
a4782 13
        rdSBIC24 R0,SR_Count            ;Violates the SCSI spec,
        CMP R0,#0                       ; but see if it fixes the Connor
        BLEQ SaveCurrentPointers        ;

        BL StopDataTX           ;>>>non-optimal. OK for read case
                                ;>>>but flushs copied data when writing.
        MOV R0,#0
        STR R0,Connected        ; and no longer connected
        STR R0,Lockout
 [ bugfix5
        MOV R0,#ER              ;&80 allow other targets to reselect
        wrSBIC R0,SR_SourceID
 ]
d4790 26
a4815 26
        LDR R0,HostStat1
        AND R0,R0,#&0F
        CMP R0,#&0E
        BNE int_ser_99

        LDR R0,MessageOut

        TST R0,#CTL_DOINGRESET
        MOVNE R0,#TARGET_RESET
        BNE common_disconnect

        TST R0,#CTL_DOINGABORTDEVICE
        MOVNE R0,#TARGET_ABORTDEVICE
        BNE common_disconnect

        TST R0,#CTL_DOINGABORTOP
        MOVNE R0,#TARGET_ABORTOP
        BNE common_disconnect

        TST R0,#CTL_DOINGESCAPEDEVICE
        MOVNE R0,#TARGET_ESCAPED
        BNE common_disconnect

        TST R0,#CTL_DOINGTIMEOUT2
        MOVNE R0,#TARGET_TIMEOUT2
        BNE common_disconnect
d4817 1
a4817 1
        B int_ser_99                    ;>>>Else assume it was harmless????
d4824 1
a4824 1
        BL StopDataTX           ;IDLEs the DMAC, tells the copier to IDLE ASAP
d4826 2
a4827 2
        MOV R0,#TARGET_TIMEOUT  ;Easier to pretend its a target status problem
        STR R0,TargStat
d4829 2
a4830 2
        MOV R0,#IDLE            ;SBIC IDLEd
        STR R0,SBICStat
d4832 8
a4839 8
        MOV R0,#0
        STR R0,Connected        ; and no longer connected
        STR R0,Lockout
 [ bugfix5
        MOV R0,#ER              ;&80 allow other targets to reselect
        wrSBIC R0,SR_SourceID
 ]
        B int_ser_99
d4851 3
a4853 3
        rdSBIC R1,SR_SourceID   ;Reselecting TargetID (known iff SIV set)
        rdSBIC R2,SR_Data       ; its LUN
                                ;>>>do we need to wait for DBR???
d4855 1
a4855 1
 [ bugfix6
d4869 34
a4902 34
        LDR R9,DEVICEptr
        TEQ R9,#0
        LDRNE R3,Connected      ;>>>>The proper code could go above the two
        TEQNE R3,#0             ;    rdSBIC commands
 [ {TRUE}
       ;MOVNE R3,#IDLE          ;Put device back to IDLE & NOT connected
       ;STRNE R3,DeviStat       ;
        MOVNE R3,#0             ;
        STRNE R3,Connected      ;

        LDRNE rCMDptr,CMDptr
        MOVNE R3,#INITIALISED   ;Command is already initialised.
        STRNE R3,CmdStat        ;
 |
        BNE gobang            ;LCI bit failed
 ]
 ]
        AND R1,R1,#maxDeviceID
        BL AddressDevice        ;In: R1=DeviceID; Out: R1=DeviceID,
                                ;    R9->deviceblk

        STR R9,DEVICEptr        ;Register reselecting target with interrupt
                                ; handler
 [ debug
        Push "R1-R8"
        ADRL R8,HostStat
        LDMIA R8,{R1-R7}
        STMIA R8,{R0-R7}
        Pull "R1-R8"
 |
        LDR R3,HostStat
        STR R3,HostStat1
        STR R0,HostStat
 ]
d4904 2
a4905 2
        LDR rCMDptr,CMDptr
        LDR R5,CpyCtl
d4909 1
a4909 1
 [ bugfix4
d4913 23
a4935 23
        TST R5,#CTL_TXREAD
        ORRNE R1,R1,#DPD
        wrSBIC R1,SR_DestID     ;Set DPD, with kosha TargetID
 ]
 [ {TRUE}
        AND R2,R2,#7
        wrSBIC R2,SR_TargetLUN  ;Probably not needed, but doesn't hurt

        BL LoadCDBregisters     ;In R5=CpyCtl, corrupts R0,R2,R3
 ]


        BL RestoreCurrentPointers
        MOV R0,#&45                     ;'Resume Select-And-Transfer' ready for
        wrSBIC R0,SR_Phase              ; for data transfer phase. May get

        MOV R0,#SC_Sel_Tx_withATN       ; Status or MessageIn. An implied
        wrSBIC R0,SR_Command            ; Negate ACK occurs

        MOV R0,#1
        STR R0,Connected
        STR R0,Lockout
        B int_ser_99
d4943 12
a4954 12
        LDR R0,CpyCtl
        TST R0,#CTL_TXREAD
        BEQ int_ser_100
                                ;In READ mode,
        LDR R1,CopyStat
        CMP R1,#STALLED
        BNE int_ser_100
                                ; with Copier STALLED
        LDR R0,QStart
        LDR R1,QEnd
        CMP R0,R1
        BNE int_TC_rd_30        ; and slots in the queue, so start copier
d4961 8
a4968 8
        LDR R0,CopyStat         ;If copier not running
        CMP R0,#RUNNING
        BEQ int_ser_200

        LDR R0,SBICStat         ; and SBIC & DMAC are IDLE
        CMP R0,#IDLE
        LDREQ R0,DMACStat
        CMPEQ R0,#IDLE
d4970 1
a4970 1
        STREQ R0,DeviStat       ; mark whole operation as complete
d4973 15
a4987 15
        LDR R0,DeviStat
        CMP R0,#IDLE
        LDREQ R0,Connected
        CMPEQ R0,#0
        BNE int_ser_202

        LDR rCMDptr,CMDptr      ;cos register shared with rPAGESLOTptr
        MOV R5,#IDLE
        STR R5,CmdStat

        LDR R0,CmdDevID
 [ :LNOT:soft
        TST R0,#CTL_DOINGREQUESTSENSE
        BNE int_ser_300
 ]
d5003 2
a5004 2
        LDR R4,CpyFail          ;Count of bytes NOT transfered
        STR R4,CmdRtR4          ; (will change if we re-issue command)
d5010 6
a5015 6
        LDR R1,TargStat
        CMP R1,#TARGET_TIMEOUT
        BNE %FT10
 [ :LNOT:soft
        BL CheckForRetry                ;Returns if CTL_RETRYONTIMEOUT is clear
 ]
d5017 1
a5017 1
        B do_callback_clrR1R2          ; so report error
d5019 5
a5023 5
        CMP R1,#TARGET_TIMEOUT2
        BNE %FT10
 [ :LNOT:soft
        BL CheckForRetry                ;Returns if CTL_RETRYONTIMEOUT is clear
 ]
d5025 1
a5025 1
        B do_callback_clrR1R2           ;Report error
d5028 2
a5029 2
        ADREQ R0,ErrorBlock_Escape
        BEQ do_callback_clrR1R2
d5031 1
a5031 1
        CMP R1,#TARGET_ABORTOP
d5033 1
a5033 1
        BEQ do_callback_clrR1R2
d5035 3
a5037 3
        CMP R1,#TARGET_ABORTDEVICE
        CMPNE R1,#TARGET_RESET
        BEQ completed_nocallback
d5039 1
a5039 1
        CMP R1,#TARGET_UNEXPECTEDDISCONNECT
d5041 18
a5058 18
 [ bugfix7b
        BEQ do_callback_NoTx_clrR1R2
 |
        BEQ do_callback_clrR1R2
 ]
 [ soft
        AND R0,R1,#TARGET_Mask  ;Ignore vendor unique bits
        B do_callback
 |
        AND R0,R1,#TARGET_Mask  ;Ignore vendor unique bits
        CMP R0,#TARGET_GOOD
        MOVEQ R0,#0             ;Indicate no error
        BEQ do_callback         ;Command complete, status GOOD

        CMP R0,#TARGET_CHECK_CONDITION
        BNE %FT10
        BL CheckAutoRequest     ;Returns if CTL_INHIBITREQUESTSENSE is set
                                ; doesn't if clear (issues REQUEST SENSE)
d5060 1
a5060 1
        B do_callback           ;Report error
d5065 2
a5066 2
        B do_callback           ;Report error
 ]
d5069 1
a5069 1
 [ :LNOT:soft
d5086 7
a5092 7
        LDR R1,SenseBlk         ;Bytes 0..3 of sense data
        LDR R2,SenseBlk+4       ;Bytes 4..7 of sense data
        AND R0,R1,#&7F          ;Extract error class & error code bits

        MOV R2,R2,LSL #8        ;Assume extended sense, put information bytes
        ORR R2,R2,R1,LSR #24    ; (bytes 3..6) in R2.
                                ; N.B. wrong byte sex!!
d5094 1
a5094 1
        RevBytes R2, R3,R4, s   ;Deal with R2's sexual hangups
d5113 4
a5116 4
        CMP R0,#&70     ;00..60 are non-extended (by defn. vendor unique)
                        ;70     is extended sense (look at sense key)
                        ;71..7E are extended sense - vendor unique
                        ;7F     extended sense reserved
d5119 2
a5120 2
        BLO nonextendedvendorunique
        BHI extendedvendorunique
d5123 5
a5127 5
        MOV R1,R1,LSR #8
        AND R0,R1,#&0F          ;Extract the Sense Key
        CMP R0,#&06
        BLEQ CheckReportUnitAttention   ;Returns if CTL_REPORTUNITATTENTION set
                                        ; doesn't if clear (reissues command)
d5129 3
a5131 3
        ADR R3,SenseKeyDecodeTab
        LDR R0,[R3,R0,LSL #2]
        ADD R0,R0,R3
d5135 1
a5135 1
        B do_callback
d5140 2
a5141 2
        MOV R1,R1,LSR #8
 [ debug                        ; debug makes this out of range
d5143 1
a5143 1
 |
d5145 2
a5146 2
 ]
        B do_callback
d5149 5
a5153 5
        LDR R0,=&001FFFFF
        AND R2,R1,R0            ;R1 = Logical address (corrected byte sex)
        BIC R1,R1,R0
        MOV R1,R1,LSR #8
 [ debug                        ; debug makes this out of range
d5155 1
a5155 1
 |
d5157 3
a5159 3
 ]
        B do_callback
 ] ; :LNOT: soft
d5161 1
a5161 1
        LTORG                   ;Assemblers constants may go here
d5164 1
a5164 1
 [ soft
d5167 1
a5167 1
 |
d5170 1
a5170 1
 ]
d5175 1
a5175 1
 [ bugfix7b
d5181 3
a5183 3
        LDR R4,CmdXferLen       ;Save Expected size of transfer
        STR R4,CmdRtR4          ; as Number of bytes NOT transfered
 ]
d5185 1
a5185 1
 [ soft
d5187 2
a5188 2
 ]
        MOV R1,#0
d5190 1
a5190 1
        MOV R2,#0
d5193 24
a5216 1
        LDR rCMDptr,CMDptr      ;cos register shared with rPAGESLOTptr
d5218 5
a5222 28
        LDR R5,CmdCallbackAdr
        TEQ R5,#0               ;
        BEQ completed_nocallback

 [ :LNOT:soft
        TEQ R0,#0
        LDRNEB R3,[R0]          ;If error, LSB of error number, returned as
        ORRNE R1,R1,R3,LSL #24  ; MSB of R1
 ]

        Push "R0,R1,R2, R5, rCMDptr,rDEVICEptr,R12"

        LDR R3,CmdXferPtr       ;Start of transfer
        LDR R4,CmdRtR4          ;Number of bytes NOT transfered
        LDR R5,CmdXferLen       ;Expected size of transfer
 [ bugfix7a
        MOVNE R4,R5             ;If error, pretend NO data was transfered
 ]
 [ :LNOT:soft
        SUB R5,R5,R4            ;Number of bytes actually transfered

        LDR R0,CmdDevID

        TST R0,#CTL_SCATTER

        ADDEQ R3,R3,R5            ;Last byte transfered +1
        STREQ R3,CmdRtR3
        BEQ do_callbk_20
d5224 8
a5231 8
        LDMIA R3,{R0,R1}        ;Address,length entry
        CMP R5,R1
        MOVGE R2,R1
        MOVLT R2,R5             ;R2=min(bytes transfered,bytes this entry)

        ADD R0,R0,R2            ;Inc Entry address  } by amount from this entry
        SUB R5,R5,R2            ;Dec Entry length   } ie min(bytes transferedt,
        SUB R1,R1,R2            ;Dec Transfer count }        bytes this entry)
d5234 1
a5234 1
        BGT do_callbk_10        ;More entries to update
d5236 1
a5236 1
 ]
d5238 14
a5251 14
        Pull "R0,R1,R2, R6"
 [ soft
        LDR R5,CmdCallbackR5
 ]
        LDR R12,CmdCallbackR12
 [ soft
        ; V flag is preserved from entry to no_callback
 |
        CMP R0,#0
        SETV NE
 ]
        MOV Link,PC
        MOV PC,R6
        Pull "rCMDptr,rDEVICEptr,R12"
d5254 2
a5255 2
        BL UnQueueCMDslot       ;Remove from queue (may not be first item)
        BL DeAllocateCMDslot    ;
d5258 1
a5258 1
        MOV R0,#Pod_EnableInts  ;Reselect Page0 to keep bootrom peekers happy
d5261 1
a5261 1
        Pull "R0-R11,Link"
d5263 8
a5270 8
 [ counts
        Push "R0-R1"
        ADRL R0, MyInfoSpace1
        LDR R1, [R0, #12]
        ADD R1, R1, #1
        STR R1, [R0, #12]
        Pull "R0-R1"
 ]
d5272 2
a5273 2
    ;>>>MOVS PC,Link
        B StartCommand
d5276 1
a5276 1
 [ :LNOT:soft
d5278 17
a5294 17
        DCD ErrorBlock_SCSI_CC_NoSense        - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_RecoveredError    - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_NotReady       - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_MediumError    - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_HardwareError  - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_IllegalRequest - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_UnitAttention  - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_DataProtect    - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_BlankCheck     - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_VendorUnique   - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_CopyAborted    - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_AbortedCommand - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_Equal          - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_VolumeOverflow - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_Miscompare     - SenseKeyDecodeTab
        DCD ErrorBlock_SCSI_CC_Reserved       - SenseKeyDecodeTab
 ]
d5301 3
a5303 3
 [ {FALSE}
        MakeErrorBlock Escape           ;Declared in &.Hdr.newErrors
 |
d5308 1
a5308 1
 ]
d5340 13
a5352 13
        Push "R0,Link"
        LDR R0,CmdDevID
        TST R0,#CTL_RETRYONTIMEOUT
        Pull "R0,PC",EQ

        MOV R0,#WAITING
        STR R0,CmdStat

        Pull "R0,Link"
 [ {FALSE}
        mess ,"re-try command on Timeout",NL
 ]
        B int_ser_202
d5354 1
a5354 1
 [ :LNOT:soft
d5356 15
a5370 15
        Push "R0,Link"
        LDR R0,CmdDevID
        TST R0,#CTL_INHIBITREQUESTSENSE
        Pull "R0,PC",NE
        ORR R0,R0,#CTL_DOINGREQUESTSENSE
        STR R0,CmdDevID

        MOV R0,#WAITING
        STR R0,CmdStat

        Pull "R0,Link"
 [ {FALSE}
        mess ,"doing Automatic-Request-Sense",NL
 ]
        B int_ser_202
d5385 18
a5402 18
        Push "R0,Link"
        LDR R0,CmdDevID
        TST R0,#CTL_REPORTUNITATTENTION
        Pull "R0,PC",NE

        BIC R0,R0,#CTL_DOINGREQUESTSENSE        ;Re_issue user command
        ORR R0,R0,#CTL_REPORTUNITATTENTION      ;
        STR R0,CmdDevID

        MOV R0,#WAITING
        STR R0,CmdStat

        Pull "R0,Link"
 [ {FALSE}
        mess ,"re-issue command cos of Unit-Attention",NL
 ]
        B int_ser_202
 ]
d5418 1
a5418 1
 [ bugfix12
d5421 1
a5421 1
 ]
d5424 34
a5457 34
 [ soft
        ADR R2,CmdCDB           ;->CDB
        LDR R3,CmdCDBLen        ;CDB size
 |
        TST R5,#CTL_DOINGREQUESTSENSE
        ADREQ R2,CmdCDB         ;->CDB
        LDREQ R3,CmdCDBLen      ;CDB size

        ADRNEL R2,cdb_requestsense
        LDRNE R3,[R2],#4
 ]

 [ bugfix10
        Push Link
        wrSBIC R3,SR_OwnID      ;Write CDB size to OwnID/CDBsize register,
        Pull Link               ; incase command is not group 0,1 or 5
 ]
        MOV R0,#SR_CDB
        STRB R0,SBICaddress     ;Select CDB register 1
 [ bugfix12
        LDRB R0,[R2],#1         ;CDB byte 0
        STRB R0,SBICindirect    ;

        ASSERT (LUNIDMask=&E0)
        LDRB R0,[R2],#1         ;Replace LUN field in CDB byte 1
        BIC R0,R0,#&E0          ;
        LDR R1,CmdDevID         ;
        AND R1,R1,#LUNIDMask    ; with LUN from DeviceID
        ORR R0,R0,R1            ;
        STRB R0,SBICindirect    ;

        SUBS R3,R3,#2
                                ;Now do bytes 3 onwards
 ]
d5459 4
a5462 4
        LDRB R0,[R2],#1         ;Copy 6,10,12 bytes of CDB into
        STRB R0,SBICindirect    ; SBIC CDB registers
        SUBS R3,R3,#1
        BGT LdCDBreg_10
d5464 1
a5464 1
        MOV PC,Link
d5469 2
a5470 2
        Push "R0,R1,Link"
        LDR R0,CopyStat
d5472 2
a5473 2
        CMP R0,#RUNNING
        BEQ PreWrBlk_10
d5475 26
a5500 26
        LDR R0,QStart
        LDR R1,QEnd
        CMP R0,R1
        BNE PreWrBlk_10

        LDR R0,FutrTtlCnt       ;If no data to copy
        CMP R0,#0
        MOVEQ R0,#IDLE          ; IDLE the copier
        STREQ R0,CopyStat
        BEQ PreWrBlk_10

        BL AllocateRAM          ;Out CC & R7 (rPAGESLOTptr) ->RamRec
        BCS PreWrBlk_10         ;    CS for failed

        BL FillFutureSlot       ;In/Out: R7->RamRec
        MOV R0,#RUNNING
        STR R0,CopyStat
        BL WriteBlkToSRAM       ;Write block to SRAM. In R8->Slot
                                ; IRQs enabled whilst copying
        BL AdvanceFuturePointers
        LDR R0,FutrTtlCnt       ;If no more data to copy,
        CMP R0,#0
        MOVEQ R0,#IDLE          ; IDLE the copier
        MOVNE R0,#STALLED       ; else STALL it
        STR R0,CopyStat
        BL QueueSlot            ;In: R7 ->RamRec
d5504 1
a5504 1
        Pull "R0,R1,PC"
d5518 17
a5534 17
        rdSBIC   R1,SR_Phase
        rdSBIC   R0,SR_Command
        CMP      R0,#SC_AssertATN       ;Only ever raised whilst doing
        MOVEQ    R0,#SC_Sel_Tx_withATN  ; SC_Sel_Tx_withATN or SC_Sel_Tx_woATN
        CMP      R0,#SC_Sel_Tx_withATN
        CMPNE    R0,#SC_Sel_Tx_woATN
        MOVNE    R1,#0
        MOVNE    R2,#0
 [ bugfix1
        STREQ    R2,CpyFail     ;If HoldSBICstate called due to unexpected
                                ; message out and we send an abort message
                                ; CpyFail must be set here because StopDataTX
                                ; won't (it will find SR_Command set to
                                ; SC_Transfer_Info_SBT.
 ]
        ADR      R3,HoldCmd
        STMIA    R3,{R0,R1,R2}
d5538 2
a5539 2
        ASSERT (HoldCmd   +4) = HoldPhase
        ASSERT (HoldPhase +4) = HoldCount
d5553 4
a5556 4
        Push "R0,R1,Link"
        MOV R0,#&30
        BL NudgePhase
        Pull "R0,R1,PC"
d5560 4
a5563 4
        Push "R0,R1,Link"
        MOV R0,#&41
        BL NudgePhase
        Pull "R0,R1,PC"
d5567 7
a5573 7
        LDR R1,HoldPhase
        CMP R1,#0
        MOVEQ PC,Link

        CMP R1,R0
        STRLT R0,HoldPhase
        MOV PC,Link
d5577 5
a5581 5
        Push "R0,R1,R2,R3, Link"
        ADR      R3,HoldCmd
        LDMIA    R3,{R0,R1,R2}  ;HoldCmd,HoldPhase,HoldCount
        TEQ R1,#0
        Pull "R0,R1,R2,R3, PC",EQ       ;Command Phase non-zero,
d5583 4
a5586 4
        wrSBIC   R1,SR_Phase            ;
        wrSBIC   R0,SR_Command          ; and resume the command
        Pull "R0,R1,R2,R3, Link"
        B int_ser_99
d5599 1
a5599 1
        Push "R0,R1,R7,Link"
d5613 6
a5618 6
        rdSBIC R0,SR_Command
        CMP R0,#SC_AssertATN            ;Only ever raised whilst doing
       ;MOVEQ R0,#SC_Sel_Tx_withATN     ; SC_Sel_Tx_withATN or SC_Sel_Tx_woATN
        CMPNE R0,#SC_Sel_Tx_withATN
        CMPNE R0,#SC_Sel_Tx_woATN
        BNE StpDat_10           ; skip the reading of SR_Count
d5625 4
a5628 4
        MOV R0,#0               ;Indicate that we cannot do a
        STR R0,HoldCmd          ; Resume-Select-And-Transfer
        STR R0,HoldPhase        ; in reponse to subsequent interrupts
        STR R0,HoldCount
d5631 1
a5631 1
        STR R0,CpyFail          ;24bit count of bytes NOT transfered
d5633 3
a5635 3
        LDR R0,DMACStat
        CMP R0,#RUNNING
        BNE StpDat_20
d5645 2
a5646 2
        LDR R7,DMACram
        LDR R1,CpyCtl
d5648 6
a5653 6
        TST R1,#CTL_TXWRITE     ;If writing,
        BEQ %FT10
        BL AdjustSlot                   ;In/Out R7->RamRec
        BL AdvanceCurrentPointers       ;In/Out R7->RamRec
        BL DeAllocateRAM                ;In     R7->RamRec
        BL FlushQueue
d5655 5
a5659 5
        TST R1,#CTL_TXREAD      ;If reading,
        BEQ %FT10
        BL AdjustSlot                   ;In/Out R7->RamRec
        BL AdvanceCurrentPointers       ;In/Out R7->RamRec
        BL QueueSlot                    ;In     R7->RamRec
d5661 6
a5666 6
 [ {TRUE}
   MOV R7,#-1
   STR R7,DMACram
 ]
        MOV R1,#0
        STR R1,CurrTtlCnt
d5669 3
a5671 3
        LDR R0,DMACStat
        CMP R0,#IDLE        ;If DMACStat=RUNNING or STALLED kill it
        BLNE ResetDMAC           ; (sets DMACStat=IDLE)
d5673 2
a5674 2
        MOV R0,#IDLE
        STR R0,DMACStat    ;>>>>>Should be done by ResetDMAC???
d5687 5
a5691 5
        LDR R1,CpyCtl
        TST R1,#CTL_TXWRITE
        LDRNE R1,CopyStat
        CMPNE R1,#RUNNING       ;Copier STALLED (or IDLE) whilst in write mode
        STRNE R0,CopyStat       ; force to IDLE state.
d5693 1
a5693 1
        Pull "R0,R1,R7,PC"
d5709 3
a5711 3
 ASSERT ( RamTxAdr  < RamBlkSz )
 ASSERT ( RamBlkSz  < RamOffset)
 ASSERT ( RamOffset < RamPage  )
d5714 2
a5715 2
        Push "R0,Link"
        Push "R1-R11"
d5717 2
a5718 2
        MOV R0,#RUNNING
        STR R0,CopyStat
d5720 2
a5721 2
        BL UnQueueSlot          ;Out: R7->RamRec
        Push "R7,R12"           ;Preserve for later DeAllocate call
d5723 7
a5729 7
        LDMIA rPAGESLOTptr,{R0,R1,R3,R4}  ;RamTxAdr,RamBlkSz,RamOffset,RamPage
        TEQ R1,#0
        BEQ RdBlkSRAM_80        ;No data in block, so finish
 [ debug
        CMP R1,#4096
        MOVHI PC,#0
 ]
d5733 3
a5735 3
 [ IRQswhenreading
       ;BIC R4,R4,#Pod_EnableInts
        wrPageReg R4            ;Page the SRAM
d5737 1
a5737 1
        LDRB R5,PR_IntStat
d5741 5
a5745 5
 |
        ORR R4,R4,#Pod_EnableInts
        wrPageReg R4            ;Page the SRAM
 ]
        LDR R2,SRAMptr          ;Base address of SRAM
d5747 2
a5748 2
        TEQ R3,#0
        BEQ RdBlkSRAM_20        ;Destination already QuadWord aligned
d5756 2
a5757 2
        LDMIA R2!,{R4,R5,R6,R7,R8,R9,R10,R11}
        JoinHWords R4,R4,R5     ;R4:=(R4 AND &FFFF) OR (R5<<16)
d5761 3
a5763 3
        ADR R5,QuadDump         ;Dump four words into QuadDump
        STMIA R5,{R4,R6,R8,R10}
        ADD R5,R5,R3            ;Adjust start address to suit dest alignment
d5765 6
a5770 6
        LDRB R4,[R5],#1         ;Copy bytes from QuadDump to main RAM
        STRB R4,[R0],#1         ;
        SUBS R1,R1,#1           ;
        BLE RdBlkSRAM_80        ; until count hits zero (finished)
        TST R0,#&0F             ;
        BNE RdBlkSRAM_10        ; or destination becomes quad word aligned
d5778 2
a5779 2
        SUBS R1,R1,#16
        BLT RdBlkSRAM_40
d5781 2
a5782 2
        LDMIA R2!,{R4,R5,R6,R7,R8,R9,R10,R11}
        JoinHWords R4,R4,R5,R12 ;R4:=(R4 AND &FFFF) OR (R5<<16)
d5786 3
a5788 3
        STMIA R0!,{R4,R6,R8,R10}
        SUBS R1,R1,#16
        BGE RdBlkSRAM_30
d5790 2
a5791 2
        ADDS R1,R1,#12
        BLT RdBlkSRAM_60
d5793 1
a5793 1
        LDMIA R2!,{R4,R5}
d5795 3
a5797 3
        STMIA R0!,{R4}
        SUBS R1,R1,#4
        BGE RdBlkSRAM_50
d5799 3
a5801 3
        ADDS R1,R1,#3
        BLT RdBlkSRAM_80
        LDMIA R2!,{R4,R5}
d5804 4
a5807 4
        STRB R4,[R0],#1
        MOV R4,R4,LSR #8
        SUBS R1,R1,#1
        BGE RdBlkSRAM_70
d5810 15
a5824 15
 [ IRQswhenreading
        DisableIRQs2 R0         ;Disable ARM IRQs
 ]
        Pull "R7,R12"           ;Recover ->RamRec, WsPtr
        BL DeAllocateRAM        ;In: R7 ->RamRec

        Pull "R1-R11"           ;MUST DO THIS HERE, to recover rDEVICEptr

        MOV R0,#STALLED         ; so that copier may be stalled
        STR R0,CopyStat         ;
 [ IRQswhenreading
        MOV R0,#Pod_EnableInts
        wrPageReg R0            ;Allow Podule IRQs
 ]
        Pull "R0,PC"
d5851 3
a5853 3
 ASSERT ( RamTxAdr  < RamBlkSz )
 ASSERT ( RamBlkSz  < RamOffset)
 ASSERT ( RamOffset < RamPage  )
d5856 2
a5857 2
        Push "R0,Link"
        Push "R1-R10"
d5859 3
a5861 3
        LDMIA rPAGESLOTptr,{R0-R3}      ;RamTxAdr,RamBlkSz,RamOffset,RamPage
        TEQ R1,#0
        BEQ WrBlkSRAM_20        ;No data in block, so finish
d5863 1
a5863 1
        LDR R2,SRAMptr          ;Base address of SRAM
d5865 1
a5865 1
 [ IRQswhenwriting
d5869 2
a5870 2
       ;BIC R3,R3,#Pod_EnableInts
        wrPageReg R3            ;Select destination page
d5872 1
a5872 1
        LDRB R4,PR_IntStat
d5876 6
a5881 6
 |
        ORR R3,R3,#Pod_EnableInts
        wrPageReg R3            ;Select destination page
 ]
        ADD R1,R1,R0            ;End address+1
        BIC R0,R0,#&0F          ;Truncate to quad word boundary
d5883 2
a5884 2
        LDMIA R0!,{R4,R6,R8,R10};Four words of source data
        SplitWord R3,R4         ; split and written as half words
d5888 3
a5890 3
        STMIA R2!,{R3,R4, R5,R6, R7,R8, R9,R10}
        CMP R1,R0
        BHI WrBlkSRAM_10
d5893 1
a5893 1
        Pull "R1-R10"
d5895 7
a5901 2
 [ IRQswhenwriting
        DisableIRQs2 R0         ;Disable ARM IRQs
a5902 4
        MOV R0,#Pod_EnableInts
        wrPageReg R0            ;Allow Podule IRQs
 ]
        Pull "R0,PC"
a5903 1
  
d5917 3
a5919 3
        LDR rCMDptr,CmdMap
        TEQ rCMDptr,#0
        MOVEQ  PC,Link          ;No free slots, return 0
d5924 1
a5924 1
        Push "Link"
d5926 1
a5926 1
        PHPSEI ,rCMDptr
d5928 3
a5930 3
        LDR rCMDptr,CmdMap      ;Reload incase its changed under interrupt
        TEQ rCMDptr,#0
        BNE %FT10
d5932 1
a5932 1
        Pull "PC"               ;No free slots, return 0, restore IRQ state
d5937 1
a5937 1
        Push "R5,R6"
d5939 3
a5941 3
        MOV R6,rCMDptr          ;LDR R6,CmdMap
        MOV R5,#1
        ADR rCMDptr,Cmd0
d5944 5
a5948 5
        TST R6,R5
        BNE Allo_Cmd_20
        ADD rCMDptr,rCMDptr,#:INDEX:CmdRecSize
        MOV R5,R5,LSL #1
        B Allo_Cmd_10           ;CmdMap<>0, so does terminate
d5951 2
a5952 2
        BIC R6,R6,R5
        STR R6,CmdMap           ;Claim page
d5954 2
a5955 2
        MOV R5,#0
        STR R5,CmdNxt           ;Play safe, zero the link now!
d5957 8
a5964 8
        LDR R5,PendingCnt
        ADD R5,R5,#1            ;One more command for this device
        STR R5,PendingCnt

        LDR R5,OperationID      ;
        STR R5,CmdOpID          ;Unique identification
        ADD R5,R5,#1            ;
        STR R5,OperationID      ;
d5967 1
a5967 1
        Pull "R5,R6,PC"         ;Slot address in rCMDptr, restore IRQ state
d5984 1
a5984 1
        Push "R0,Link"
d5986 5
a5990 5
        ADR R0,Cmd0
        SUB R0,rCMDptr,R0               ; gives slot number*CmdRecSize
        MOV R0,R0,LSR #Log2CMDRECSIZE   ; gives slot number (ie bit position)
        MOV rCMDptr,#1
        MOV rCMDptr,rCMDptr, LSL R0     ; bit mask for CmdMap
d5994 1
a5994 1
        PHPSEI ,R0
d5996 7
a6002 7
        LDR R0,CmdMap
        ORR R0,R0,rCMDptr       ;Free the slot
        STR R0,CmdMap

        LDR R0,PendingCnt
        SUB R0,R0,#1            ;One less command for this device
        STR R0,PendingCnt
d6005 1
a6005 1
        Pull "R0,PC"            ;Return, restoring int state
d6023 1
a6023 1
        Push "R0,R1,R14"
d6025 1
a6025 1
        PHPSEI ,R0                      ;Stores old state in r14, corrupts R0
d6027 2
a6028 2
        ADR R0,FirstCmd                 ;Pretend FirstCmd is a CmdNxt field
        SUB R0,R0,#:INDEX: CmdNxt       ; then chain along list looking for
d6030 6
a6035 6
        LDR R1,[R0,#:INDEX: CmdNxt]     ; the last record (CmdNxt field = 0)
        TEQ R1,#0
        MOVNE R0,R1
        BNE Que_C_10
                                        ;R0 -> last CmdRec (or FirstCmd-CmdNxt)
        STR rCMDptr,[R0,#:INDEX: CmdNxt]        ;Add entry to end of list
d6037 2
a6038 2
        PLP                             ;Restore int state
        Pull "R0,R1,PC"                 ;Return
d6056 1
a6056 1
        Push "R0,R1,Link"
d6058 3
a6060 3
        PHPSEI ,R0                      ;Stores old state in r14, corrupts R0
        ADR R0,FirstCmd                 ;Pretend FirstCmd is a CmdNxt field
        SUB R0,R0,#:INDEX: CmdNxt       ; then chain along list looking for
d6062 8
a6069 8
        LDR R1,[R0,#:INDEX: CmdNxt]     ; the record whoes CmdNxt field points
 [ debug
        CMP R1,#0        ;Error, reached end of queue without finding
        SWIEQ &17        ; required cmd slot.
 ]
        CMP R1,rCMDptr                  ; at the record to be removed.
        MOVNE R0,R1
        BNE UQue_C_10
d6071 2
a6072 2
        LDR R1,CmdNxt                   ;Replace the link to us with our
        STR R1,[R0,#:INDEX: CmdNxt]     ; CmdNxt link.
d6074 2
a6075 2
        PLP                             ;Restore int state
        Pull "R0,R1,PC"                 ;Return
d6105 2
a6106 2
        Push "R0,R1,R14"
        LDR rCMDptr,FirstCmd
d6108 2
a6109 2
        CMP rCMDptr,#0
        BEQ Nxt_Cmd_30          ;No commands/end of list found
d6111 19
a6129 19
        LDR R0,CmdStat
        CMP R0,#INITIALISING    ;We interrupted this command whilst it was
        BEQ Nxt_Cmd_30          ; initialising, so indicate 'non found'
                                ; so it is returned to and allowed to start.
        CMP R0,#INITIALISED
        BEQ Nxt_Cmd_40          ;Try another select-and-transfer

        CMP R0,#WAITING
        BNE Nxt_Cmd_20          ;Not WAITING, so try next command block

        LDR R1,CmdDevID
        AND R1,R1,#maxDeviceID
        BL AddressDevice        ;In: R1=DeviceID
                                ;Out: R1=DeviceID, R9->deviceblk
        LDR R0,DeviStat
        CMP R0,#IDLE            ;Found a command for a device that is IDLE,
        LDREQ R0,Connected      ; and disconnected
        CMPEQ R0,#0
        BEQ Nxt_Cmd_40          ; so return it
d6132 3
a6134 3
        LDR rCMDptr,CmdNxt      ;Examine next command block
        CMP rCMDptr,#0
        BNE Nxt_Cmd_10
d6137 1
a6137 1
        MOV rCMDptr,#0
d6139 1
a6139 1
        Pull "R0,R1,PC"
d6156 4
a6159 4
        Push "R0,Link"
        LDR rCMDptr,FirstCmd
        CMP rCMDptr,#0
        BEQ Fnd_Cmd_20          ;No commands/end of list found
d6161 8
a6168 8
        LDR R0,CmdOpID
        CMP R0,R2
        BEQ Fnd_Cmd_20          ;CmdOpID matches

        LDR rCMDptr,CmdNxt      ;Examine next command block
        CMP rCMDptr,#0
        BNE Fnd_Cmd_10          ;Loop checking CmdOpIDs until
                                ; end of list found
d6170 1
a6170 1
        Pull "R0,PC"
d6189 2
a6190 2
        ASSERT ((:INDEX:RamRecSize) = 16)
        ASSERT (R7 = rPAGESLOTptr)
d6193 8
a6200 8
        Push "R6,R8"
        LDR R6,RamMap
 [ efficient
        MOV R7,#PAGECOUNT-1             ;Not a bug, just more efficient
 |
        MOV R7,#PAGECOUNT               ;
 ]
        MOV R8,#1
d6202 4
a6205 4
        TST R6,R8,LSL R7
        BNE Alloc_20                    ;Slot R7 is free
        SUBS R7,R7,#1
        BGE Alloc_10
d6207 1
a6207 1
        Pull "R6,R8"
d6209 1
a6209 1
        MOV PC,Link
d6212 2
a6213 2
        BIC R6,R6,R8,LSL R7
        STR R6,RamMap          ;Claim slot
d6215 5
a6219 5
        MOV R8,R7               ;Slotnumber
        ADR R7,Ram0
        ASSERT (:INDEX: RamRecSize = 16)
        ADD R7,R7,R8,LSL #4     ;R7:=Adr(Ram0)+SlotNumber*RamRecSize
        STR R8,RamPage
d6221 1
a6221 1
        Pull "R6,R8"
d6223 1
a6223 1
        MOV PC,Link
d6238 1
a6238 1
        Push "R0-R2,Link"
d6240 8
a6247 8
        LDR R0,RamMap
        LDR R2,RamPage
        CMP R2,#PANICPAGE       ;Don't deallocate the sink/source junk page
        BEQ DeAll_10

        MOV R1,#1
        ORR R0,R0,R1,LSL R2
        STR R0,RamMap
d6250 1
a6250 1
        Pull "R0-R2,PC"
d6254 9
a6262 9
        Push "R0-R3"
        ADR R7,(Ram0+(PANICPAGE * :INDEX: RamRecSize))
        MOV R0,#&80000000               ;Give Naff address and
        MOV R1,#0                       ; zero BlkSz to indicate sink/source
        MOV R2,#0                       ; junk (for overrun)
        MOV R3,#PANICPAGE
        STMIA rPAGESLOTptr,{R0-R3}      ;Adr,BlkSz,Offset,Page
        Pull "R0-R3"
        MOV PC,Link
d6286 2
a6287 2
        Push "R0,R2,R3,R4,R5,R6"
        ADR R0,CurrentPointers
d6289 3
a6291 3
        LDR R2,[R0,#TtlCnt]
        LDR R3,[R0,#EntAdr]
        LDR R4,[R0,#EntCnt]
d6293 2
a6294 2
        TEQ R4,#0
        BNE FilSlt_10
d6296 5
a6300 5
        LDR R5,[R0,#ScatPtr]    ;Scatter list entry exhausted,
        LDMIA R5 !,{R3,R4}      ; so use next one
        STR R5,[R0,#ScatPtr]
        STR R3,[R0,#EntAdr]
        STR R4,[R0,#EntCnt]
d6304 22
a6325 22
 [ counts
        Push "R0"
        ADRL R0, MyInfoSpace1
        STR R2, [R0, #52]        ;TtlCnt
        STR R5, [R0, #56]        ;ScatPtr
        STR R4, [R0, #60]        ;EntCnt
        STR R3, [R0, #64]        ;EntAdr
        Pull "R0"
 ]

        MOV R5,#PAGESIZE
        AND R6,R3,#&0F          ;DMAC address offset (0..15)
        SUB R5,R5,R6            ;Block size is PAGESIZE-(0..15)
        CMP R5,R4
        MOVGT R5,R4             ;BlockSize:=MIN(PAGESIZE,EntCnt)
        CMP R5,R2
        MOVGT R5,R2             ;BlockSize:=MIN(BlockSize,TtlCnt)

  ASSERT ( RamTxAdr  < RamBlkSz )
  ASSERT ( RamBlkSz  < RamOffset)
  ASSERT ( RamOffset < RamPage  )
        STMIA rPAGESLOTptr,{R3,R5,R6}      ;Adr,BlkSz,Offset,Page
d6328 2
a6329 2
        Pull "R0,R2,R3,R4,R5,R6"
        MOV PC,Link
d6332 3
a6334 3
        Push "R0,R2,R3,R4,R5,R6"
        ADR R0,FuturePointers
        B FilSlt_01
d6338 2
a6339 2
        Push "R0,R2,R3,R4,R5,R6,R7"
        ADR R0,CurrentPointers
d6342 22
a6363 22
        LDMIA rPAGESLOTptr,{R3,R5,R6}   ;Adr,BlkSz,Offset
        LDR R2,RamPage
        CMP R2,#PANICPAGE
        BEQ AdvCurPtr_10

        LDR R2,[R0,#TtlCnt]
        LDR R3,[R0,#EntAdr]
        LDR R4,[R0,#EntCnt]
 [ debug
 CMP R2,#0
 LDRLT R14,[R2]
 ]
        SUB R2,R2,R5            ;Size of rest of transfer
        ADD R3,R3,R5            ;Address of rest of transfer
        SUB R4,R4,R5            ;Size of rest of transfer (this scatter entry)
 [ debug
 CMP R2,#0
 LDRLT R14,[R2]
 ]
        STR R2,[R0,#TtlCnt]
        STR R3,[R0,#EntAdr]
        STR R4,[R0,#EntCnt]
d6365 2
a6366 2
        Pull "R0,R2,R3,R4,R5,R6,R7"
        MOV PC,Link
d6370 3
a6372 3
        Push "R0,R2,R3,R4,R5,R6,R7"
        ADR R0,FuturePointers
        B AdvCurPtr_05
d6376 3
a6378 3
        Push "R0,R2,R3,R4,R5,R6,R7"
        ADR R0,SavedPointers
        B AdvCurPtr_05
d6382 2
a6383 2
        Push "R0,Link"
        LDR R0,HoldCount
d6385 1
a6385 1
        Pull "R0,Link"
d6388 1
a6388 1
        Push "R0-R4,R7,Link"
d6390 10
a6399 10
        ADR R0,CurrentPointers  ;Assign CurrentPointers to SavedPointers
        LDMIA R0,{R1,R2,R3,R4}  ;
        ADR R0,SavedPointers    ;
        STMIA R0,{R1,R2,R3,R4}  ;

 [ bugfix9
        LDR R0,CpyCtl
        TST R0,#CTL_TXWRITE
        BNE SavCurPtr_50
 ]
d6402 3
a6404 3
        LDR R0,DMACStat
        CMP R0,#RUNNING
        BNE SavCurPtr_20
d6406 3
a6408 3
        LDR R4,CurrTtlCnt
        TEQ R4,#0
        BEQ SavCurPtr_20
d6410 2
a6411 2
        rdSBIC24 R0,SR_Count    ;Number of bytes not transfered
        SUBS R4,R4,R0           ;Number of bytes transfered in this block
d6413 2
a6414 2
        LDR R7,DMACram
        LDMIA R7,{R0,R1,R2,R3}  ;RamTxAdr,RamBlkSz,RamOffset,RamPage
d6416 1
a6416 1
        Push "R0-R3"
d6418 4
a6421 4
        ADD R0,R0,R4            ;Advance RamTxAdr
        SUB R1,R1,R4            ;Reduce RamBlkSz
        ADD R2,R2,R4            ;Advance RamOffset
        Push "R0-R3"            ;Push for later use
d6423 3
a6425 3
        STR R4,RamBlkSz                 ;Patch record to indicate amount
        BL AdvanceSavedPointers       ; actually transfered, advance pointers
        Pull "R0-R3"
d6427 1
a6427 1
        STMIA R7,{R0,R1,R2,R3}  ;Put back the adjusted record
d6429 5
a6433 5
        LDR R0,CpyCtl
        TST R0,#CTL_TXWRITE
        BLNE ResetDMAC
        MOVNE R0,#dma_wr_mode
        BLNE ArmDMAC
d6435 1
a6435 1
        Pull "R0-R3"
d6437 1
a6437 1
        STMIA R7,{R0,R1,R2,R3}  ;Put back the original record
d6440 1
a6440 1
        Pull "R0-R4,R7,PC"
d6442 1
a6442 1
 [ bugfix9
d6446 4
a6449 4
        LDR R4,CurrTtlCnt
        rdSBIC24 R0,SR_Count    ;Number of bytes not transfered
        SUBS R4,R4,R0           ;Number of bytes transfered in this block
        BGE SavCurPtr_10
d6456 2
a6457 2
        ADR R0,SavdEntAdr
        LDMIA R0,{R1,R2,R3}     ;EntAdr,EntCnt,TtlCnt
d6459 9
a6467 9
        ADD R1,R1,R4            ;SavdEntAdr += R4
        SUB R2,R2,R4            ;SavdEntCnt -= R4
        SUB R3,R3,R4            ;SavdTtlCnt -= R4

        STMIA R0,{R1,R2,R3}     ;EntAdr,EntCnt,TtlCnt

        Pull "R0-R4,R7,Link",AL ;Pull back the saved registers and
                                ; drop into...
 ]
d6470 1
a6470 1
        Push "R0-R4,Link"
d6472 1
a6472 1
        BL StopDataTX
d6474 17
a6490 17
        LDR R1,SavdScatPtr
        LDR R2,SavdEntAdr
        LDR R3,SavdEntCnt
        LDR R4,SavdTtlCnt

        STR R1,CurrScatPtr
        STR R2,CurrEntAdr
        STR R3,CurrEntCnt
        STR R4,CurrTtlCnt

        wrSBIC24 R4,SR_Count    ;Number of bytes left to transfer

        LDR R0,CpyCtl
        TST R0,#(CTL_TXREAD :OR: CTL_TXWRITE)
        BEQ ResCurPtr_20
        TST R0,#CTL_TXREAD
        BEQ ResCurPtr_10
d6496 15
a6510 15
        MOV R3,#STALLED
        STR R3,DMACStat
 [ bugfix3
        LDR R0,CopyStat         ;If Copier is RUNNING, don't disturb it,
        CMP R0,#RUNNING         ; if not, mark it as STALLED, ready to
        STRNE R3,CopyStat       ; try a restart
 ]
        BL AllocateRAM          ;Out CC & R7 (rPAGESLOTptr) ->RamRec
        BCS ResCurPtr_20        ;    CS for failed

        STR R7,DMACram          ;DMAC will queue this when its full
        BL FillSlot             ;In/Out: R7->RamRec
        MOV R0,#dma_rd_mode     ;&04 demand mode,read
        BL ArmDMAC              ;In/Out: R7->RamRec
        B ResCurPtr_20
d6516 6
a6521 6
        MOV R3,#STALLED         ;Put DMAC into stalled state (had been IDLEd by
        STR R3,DMACStat         ; StopDataTx)
        LDR R0,CopyStat         ;If Copier is RUNNING, don't disturb it,
        CMP R0,#RUNNING         ; if not, mark it as STALLED, ready to
        STRNE R3,CopyStat       ; try a restart
        BL Restart_DMAC_Writing
d6523 1
a6523 1
        Pull "R0-R4,PC"
d6548 1
a6548 1
        Push "R0,R1"
d6550 8
a6557 8
        LDR R0,CurrTtlCnt
        LDR R1,CpyFail
        SUB R1,R0,R1            ;Number of bytes actually transfered
        LDR R0,RamBlkSz
        TEQ R0,#0               ;If not sinking/sourcing junk,
        STRNE R1,RamBlkSz
        Pull "R0,R1"
        MOV PC,Link
d6572 9
a6580 9
        Push "R0"
        LDR R0,QEnd
        STR R7,[rDEVICEptr,R0]          ;Write ->RamRec at QEnd
        ADD R0,R0,#4                    ;Advance QEnd
        CMP R0,#:INDEX:QueuePastIt
        MOVHS R0,#:INDEX:Queue0         ;It's a wrap
        STR R0,QEnd
        Pull "R0"
        MOV PC,Link
d6591 2
a6592 2
        ASSERT ((:INDEX:RamRecSize) = 16)
        ASSERT (R7 = rPAGESLOTptr)
d6597 2
a6598 2
        LDR     R7, [rDEVICEptr,R8]     ;Read ->RamRec from QStart
        ADD     R8, R8, #4              ;Advance QStart
d6600 1
a6600 1
        MOVHS   R8, #:INDEX:Queue0      ;Wrap round
d6617 1
a6617 1
        BLNE    UnQueueSlot             ;Out R8->RamRec
d6634 1
a6634 1
        LDMIA   rPAGESLOTptr, {R3,R5,R6,R7}     ;TxAdr,BlkSz,Offset,Page
d6637 1
a6637 1
        CMP R7,#PANICPAGE
d6641 1
a6641 1
 [ {FALSE}
d6646 1
a6646 1
 ]
d6649 1
a6649 1
        SUB     R5, R5, #1              ;DMAC wants BlkSize-1 !!
d6655 1
a6655 1
        wrDMAC  R0, DR_TxAdrLo          ;DMAC address is Slot*PAGESIZE+Offset
d6661 1
a6661 1
        MOV     R0, #clr_mask        ;&0E
d6664 1
a6664 1
        MOV     R0, #RUNNING         ;Restart the DMAC
d6677 11
a6687 11
        AND R10,R1,#CardIDMask
        MOV R10,R10,LSR #CardIDShft
        LDR R11,maxCardID       ;>>>Note gives "Invalid device ID"
        CMP R10,R11             ;>>>Not really worth a different
        BHI err_BadDevID        ;>>>message

        MOV R11,#((:INDEX: Cardworkspacesize)     :AND: &000000FF)
        ORR R11,R11,#((:INDEX: Cardworkspacesize) :AND: &FFFFFF00)
        MUL R10,R11,R10
        ADR WsPtr,LogicalCard0
        ADD WsPtr,WsPtr,R10
d6689 2
a6690 2
        BIC R1,R1,#CardIDMask
        MOV PC,Link
d6700 1
a6700 1
        Push "R4-R6,WsPtr,Link"
d6702 2
a6703 2
        ASSERT (:INDEX:PODULEptr)=4
        ASSERT (:INDEX:DMACptr)=8
d6705 5
a6709 5
        LDR R4,maxCardID
        ADR R5,ListEntry0                       ;->PoduleBase address
        ADR WsPtr,LogicalCard0                  ;->CardWs
        CMP R4,#0
        BMI DoForEac_20
d6711 1
a6711 1
        Push "R4-R6,WsPtr"
d6713 11
a6723 11
        LDR R5,[R5]                             ;Podule base address
        LDMIB WsPtr,{rPODULEptr,rDMACptr}       ;Card hardware addresses
        MOV Link,PC
        MOV PC,R6

        Pull "R4-R6,WsPtr"
        ADD WsPtr,WsPtr,#((:INDEX: Cardworkspacesize) :AND: &000000FF)
        ADD WsPtr,WsPtr,#((:INDEX: Cardworkspacesize) :AND: &FFFFFF00)
        ADD R5,R5,#4
        SUBS R4,R4,#1
        BGE DoForEac_10
d6725 1
a6725 1
        Pull "R4-R6,WsPtr,PC"
d6728 1
a6728 1
 [ doEscapeCheck
d6743 10
a6752 10
        Push LR
        SWI XOS_ReadEscapeState
        Pull PC,CC                      ;Escape not pressed, so return

        ORR R0,R0,#CTL_DOINGESCAPEDEVICE
        Push "R0,R1,R2"
        MOV R1,#CTL_DOINGESCAPEDEVICE   ;Try to abort,
        BL RaiseATN                     ; if it works, report esacpe
        Pull "R0,R1,R2,PC"
 ]
d6761 2
a6762 2
        mess ,"RaiseATN",NL
        Push "R0-R3,rCMDptr,rDEVICEptr,Link"
d6764 1
a6764 1
        PHPSEI R3,R0
d6766 30
a6795 30
        BL FindCommand
        CMP rCMDptr,#0
        BEQ Rai_ATN_10          ;Quit if command not found

        LDR R2,CmdDevID
        TST R2,R1
        BNE Rai_ATN_10          ;Quit if ATN already raised for this reason

        ORR R2,R2,R1
        STR R2,CmdDevID         ;Mark Cmd to prevent furthur tries

        LDR R0,CmdStat
        CMP R0,#RUNNING
        BNE Rai_ATN_10          ;Can't raise ATN on a non-running command

       ;LDR R2,CmdDevID
        AND R1,R2,#maxDeviceID
        BL AddressDevice        ;In: R1=DeviceID
                                ;Out: R1=DeviceID, R9->deviceblk
        LDR R0,DeviStat
        CMP R0,#RUNNING
        BNE Rai_ATN_10          ;Quit if device not running
        LDR R0,Connected
        CMP R0,#0               ; or if disconnected
        BEQ Rai_ATN_10          ;

        rdSBIC R0,SR_Command            ;Safer not to disturb SBIC
        CMP R0,#SC_Sel_Tx_withATN       ; if in overrunning
        CMPNE R0,#SC_Sel_Tx_woATN       ; or doing closing status/message
        BNE Rai_ATN_10                  ; transfers
d6800 15
a6814 15
 [ doAssertATN
 [ {TRUE}
        rdSBIC R2,SR_Phase
        BL nCIP_wait     ;<<<<
 ]
        MOV R1,#SC_AssertATN    ;So, TRY to attract its attention
        wrSBIC R1,SR_Command
 [ {TRUE}
 [ {TRUE}
        BL nCIP_wait     ;<<<<
        wrSBIC R2,SR_Phase
 ]
        wrSBIC R0,SR_Command    ;Put the previous command back >>>>doesn't work
 ]
 ]
d6817 1
a6817 1
        Pull "R0-R3,rCMDptr,rDEVICEptr,PC"
d6821 1
a6821 1
 [ useTickerV
d6826 1
a6826 1
        Push "R0-R2,R8-R11,Link"
d6828 1
a6828 1
        LDMIA WsPtr,{rDEVICEptr, rPODULEptr,rDMACptr}  ;R9,R10,R11
d6830 2
a6831 2
        TEQ rDEVICEptr,#0       ;Quit if no device registered
        BEQ MyTick_10           ;
d6833 3
a6835 3
        LDR R0,DeviStat         ;Quit if not yet, or just finished
        CMP R0,#RUNNING         ; running
        BNE MyTick_10           ;
d6841 3
a6843 3
        LDR R0,Timeout          ;Quit if not running, or already timed out
        CMP R0,#0               ;
        BLE MyTick_10           ;
d6845 2
a6846 2
        SUBS R0,R0,#1
        STR R0,Timeout
d6850 4
a6853 4
        LDREQ rCMDptr,CMDptr            ;(R8)Pointer to command >>>kosha???
        MOVEQ R1,#CTL_DOINGTIMEOUT2     ;Try to abort,
        LDREQ R2,CmdOpID                ;
        BLEQ RaiseATN                   ; if it works, report device timeout
d6855 2
a6856 2
        Pull "R0-R2,R8-R11,PC"
 ]
d6859 3
a6861 3
 [ bugfix6
 [ {TRUE}
 |
d6863 4
a6866 4
        SWI OS_WriteS
        = "LCI bit failed"
        = CR,LF
        = 0
d6868 4
a6871 4
        MOV R14,#-1
        LDR R14,[R14]
 ]
 ]
d6873 1
a6873 1
 [ SQ555kludge
d6876 6
a6881 6
        LDR R0,HostStat1
        AND R0,R0,#&0F
        CMP R0,#&0F
        LDREQ R0,MessageIn
        CMPEQ R0,#MESSAGE_COMMANDCOMPLETE
        BNE int_ser_49
d6885 3
a6887 3
        MOV R0,#IDLE
        STR R0,SBICStat               ; SBIC now completed
 [ bugfix2
d6892 4
a6895 4
        MOV R0,#CTL_Suppress
        STR R0,Suppress
 ]
        B int_ser_50                  ;Then treat like an expected disconnection
d6897 1
a6897 1
 ]
@


4.5
log
@Was going mad.Should only have been clearing bits 0-9 of the CMOS
address.

Version 1.14. Tagged as 'SCSIDriver-1_14'
@
text
@d6775 3
a6777 6
        Push R1
        MOV R1,#0
        LDRB R1,[R1,#ESC_Status]
        TSTS R1,#EscapeBit
        Pull R1
        MOVEQ PC,Link                   ;Escape not pressed, so return
d6780 1
a6780 1
        Push "R0,R1,R2,Link"
@


4.4
log
@Loads of cleanups and tidying ready for public source release.
Moved macros and equates into seperate header files.
!MkClean now strips dependencies.
Single code change (cf.1.12) is to BIC out the bottom 11 bits of the
podule hardware address to get the sync base.
Sorry,no,bottom 12 bits.

Version 1.13. Tagged as 'SCSIDriver-1_13'
@
text
@d520 1
a520 1
        BICVC R11,R11,#&F00     ;Zap the CMOS RAM base
@


4.3
log
@Added the features entry point.

Version 1.12. Tagged as 'SCSIDriver-1_12'
@
text
@d17 1
a17 8
; RISC OS SCSI device driver
;
; Author : R.C.Manby
; Copyright Acorn Computers Ltd
;
; History
;   23-Jan-89: RCM: Started
;   26-Oct-89: RCM: Version 1.01 released (part of 0273,210-02)
d22 3
a24 5
                GBLL true
                GBLL false
true            SETL 1=1
false           SETL 1=0

d33 1
a33 1
debug           SETL false
d36 9
a44 9
DString         SETS " - Debugging version"
counts          SETL false
trace           SETL true
preserveWSoverreset SETL false
 |
DString         SETS ""
counts          SETL false
trace           SETL false              ;Must be false for release
preserveWSoverreset SETL false          ;Must be false for release
d49 1
a49 1061
disconnect      SETL false               ; disconnection/reselection


SQ555kludge     SETL false
 [ SQ555kludge
disconnect      SETL false
 [ debug
DString         SETS " - SQ555 debugging version"
 |
DString         SETS " - SQ555 version"
 ]
 ]

                GBLL HAL
HAL             SETL true

                GBLL soft               ;When true, be a driver module for SCSISwitch
soft            SETL true

                GBLL testMEMC           ;When true, test for MEMC1a
testMEMC        SETL :LNOT:HAL


                GBLL doAssertATN
doAssertATN     SETL true

                GBLL useTickerV
                GBLL doEscapeCheck
 [ doAssertATN:LAND::LNOT:soft
useTickerV      SETL true               ;true or false
doEscapeCheck   SETL false
 |
useTickerV      SETL false              ;MUST be false
doEscapeCheck   SETL false              ;MUST be false
 ]

                GBLL IRQswhenreading
                GBLL IRQswhenwriting
                GBLL rejectnaffmessages
IRQswhenreading SETL true
IRQswhenwriting SETL true
rejectnaffmessages  SETL true

                GBLL BigCapacity
BigCapacity     SETL true


                GBLL readback           ;Read back from podule to flush writes
readback        SETL true

                GBLL bugfix1            ;Escape whilst reading
bugfix1         SETL true

                GBLL bugfix2            ;Suppress escape & timeout if command
bugfix2         SETL true               ; completes before noticing ATN is hi.

                GBLL bugfix3            ;Small xfers after a re-select failing
bugfix3         SETL true               ; to copy SRAM data to main ram

                GBLL bugfix4            ;Restore DPD bit in SR_DestID when
bugfix4         SETL true               ; reselected by a target

                GBLL bugfix5            ;Set ER bit in SR_SourceID when a
bugfix5         SETL true               ; disconnection occurs

                GBLL bugfix6            ;LCI bit doesn't always work when
bugfix6         SETL true               ; another target reselects SBIC

                GBLL bugfix7a           ;Indicate NO data transfered, if any
bugfix7a        SETL false              ; error occurs

                GBLL bugfix7b           ;Indicate NO data transfered, if an
bugfix7b        SETL true               ; unexpected disconnection occurs

                GBLL bugfix8            ;Determine device gives -1,-1 for block
bugfix8         SETL true               ;  count/size if readcapacity fails

                GBLL bugfix9            ;Target disconnects during last
bugfix9         SETL true               ; 12 bytes of data out phase

        GET Version

;
; Driver AMRed as V 1.01 (26 Oct 89), the following bugs have been
; found and fixed since then.
;

                GBLL bugfix10           ;Tell SBIC the CDB size incase its
bugfix10        SETL Version >= 102     ; not a group 0,1 or 5 command.

                GBLL efficient
efficient       SETL Version >= 104

                GBLL bugfix11           ;Check CDB size
bugfix11        SETL Version >= 104

                GBLL bugfix12           ;Get LUN's to work
bugfix12        SETL Version >= 104

                GBLL bugfix13           ;Prevent call of UnQueueSlot from
bugfix13        SETL Version >= 104     ; Restart_DMAC_Writing when queue
                                        ; is empty.

                GBLL bugfix14           ;Show correct host revision number
bugfix14        SETL Version >= 105     ; for *Devices


        AREA |!!!Module|,CODE,READONLY

Module_BaseAddr

        GET Hdr:ListOpts  ; These first three must be in this order
        GET Hdr:Macros
        GET Hdr:System

;        GET Hdr:File ; dar 24/10/91 - needed for newerrors
        GET Hdr:FSNumbers
        GET Hdr:ModHand
        GET Hdr:Services
;        GET Hdr:NewSpace
        GET Hdr:Proc
;        GET Hdr:Tokens
        GET Hdr:DevNos
        GET Hdr:Podule
        GET Hdr:NewErrors
        GET Hdr:HALEntries


        GET Hdr:SCSI
        GET Hdr:SCSIErr    ;Insert me in Hdr.NewErrors?


;------------------------------------------------------------------------------
;
;
defaultHostID   EQU 7
maxDeviceID     EQU 7           ;Host/Target DeviceID's are 0..7

minCDBLen       EQU 3           ;Imposed by LoadCDBregisters
maxCDBLen       EQU 12          ;SBIC has 12 CDB registers

DeviceIDMask    EQU 7
DeviceIDShft    EQU 0
CardIDMask      EQU &18
CardIDShft      EQU 3
LUNIDMask       EQU &E0
LUNIDShft       EQU 5

Log2PAGESIZE    EQU 12
PAGESIZE        EQU 4096        ;SRAM is 64K in 16 x 4K pages
PAGECOUNT       EQU 16
PANICPAGE       EQU 0           ;Page  0      used to sink/source unwanted data
PAGEBITS        EQU &0000FFFE   ;Pages 1..15, initially marked as unallocated
                                ;Pages 16..31 don't exist, marked as allocated

                ASSERT (PAGESIZE = (1 :SHL: Log2PAGESIZE))

CMDCOUNT        EQU 16          ;Number of queued commands
CMDBITS         EQU &0000FFFF   ;

                ASSERT (CMDBITS = (1 :SHL: CMDCOUNT)-1)

UnixAccessKey   EQU &FC000003   ;Magic value that allows UNIX to break the
                                ; AccessKey system. ONLY allowed on SWI SCSI_Op
                                ; If the user of this key corrupts your DISC
                                ; DON'T COME CRYING TO ME.
RCsoftcopyadr * &9A


LF      *   10
CR      *   13
SPACE   *   32


;ESC_Status     EQU &104        ;Declared in hdr.NewSpace
EscapeBit       EQU &40         ;This bit indicates escape pressed


IDLE            EQU &00000000
RUNNING         EQU &00000004
STALLED         EQU &00000008
WAITING         EQU &00000010
INITIALISING    EQU &00000020
INITIALISED     EQU &00000040
ERROR           EQU &00000080



;------------------------------------------------------------------------------
;
; Register names
; ==============
;
rPAGESLOTptr    RN 7
rCMDptr         RN 8
rDEVICEptr      RN 9
rPODULEptr      RN 10
rDMACptr        RN 11
;WsPtr          RN 12
StkPtr          RN 13
Link            RN 14
;PC             RN 15


;------------------------------------------------------------------------------
;
; Access to stacked registers - TO BE USED WITH CAUTION!
; ===========================

 ^ 0,StkPtr
StackedR0   # 4
StackedR1   # 4
StackedR2   # 4
StackedR3   # 4
StackedR4   # 4
StackedR5   # 4
StackedR6   # 4
StackedR7   # 4




;==============================================================================
;
;
;
; Podule             SRAMptr    DMACptr        PODULEptr
;  0      03240000   03000000   03003000       03343000
;  1      03244000
;  2      03248000
;  3      0324C000
;
Podule0SlowAccess       EQU &03240000
PoduleSpeedMask         EQU &00180000

SRAMptrRel   EQU &03000000 - Podule0SlowAccess
DMACptrRel   EQU &03003000 - Podule0SlowAccess
PODULEptrRel EQU &03343000 - Podule0SlowAccess




;==============================================================================
;
; Podule registers
;
;------------------------------------------------------------------------------
;
; Both memory mapped, accessed by +ve/-ve offsets off rPODULEptr (R10)
;
 ^ -4,rPODULEptr

PR_IntStat # 0                  ;Read : Interrupt status
PR_ClrInt  # 4                  ;Write: Clear DMAC interrupt
PR_PageReg # 0                  ;Write: PageRegister/IntEnable/UserReset

Pod_IRQ                 EQU &01 ;Podule IRQ (Set if TC_IRQ or SB_IRQ)
TC_IRQ                  EQU &02 ; DMAC terminal count
SB_IRQ                  EQU &08 ; SBIC interrupting

Pod_EnableInts          EQU &40
Pod_ForceReset          EQU &80
;
;
;==============================================================================


;==============================================================================
;
; SBIC registers, commands and status bits
;
;----------------------------------------------------------------------------
;
; SBIC registers
;
 ^ -8,rDMACptr
                                ;    bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0
SBICauxstat     # 0             ; RO  INT  LCI  BSY  CIP    0    0   PE  DBR
SBICaddress     # 4             ; WO  Register selection address
SBICindirect    # 4             ; Read/write register given by address register
;
; Register indicators, must be written to SBIC address register (see wrSBIC
;  & rdSBIC macros)
;                               ;    bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0
SR_OwnID                EQU &00 ; RW  FS1  FS0    0  EHP  EAF  ID2  ID1  ID0
SR_Control              EQU &01 ; RW  DM2  DM1  DM0  HHP  EDI  IDI   HA  HSP
SR_Timeout              EQU &02 ; RW  timeout period value = Tper*Ficlk/80d
SR_CDB                  EQU &03
SR_TargetLUN            EQU &0F ; RW  TLV  DOK    0    0    0  TL2  TL1  TL0
SR_Phase                EQU &10
SR_SyncXfer             EQU &11
SR_CountHi              EQU &12 ; RW  Transfer count MSB
SR_CountMd              EQU &13
SR_CountLo              EQU &14 ; RW  Transfer count LSB
SR_DestID               EQU &15 ;     SCC  DPD    0    0    0  DI2  DI1  DI0
SR_SourceID             EQU &16 ; RW   ER   ES  DSP    0  SIV  SI2  SI1  SI0
SR_SCSIstat             EQU &17
SR_Command              EQU &18
SR_Data                 EQU &19
;
;
;------------------------------------------------------------------------------
;
; SBIC commands - Actioned by writing to SBIC command register (SR_Command)
;
SC_Reset                EQU &00 ; Level 1
SC_Abort                EQU &01 ;       1
SC_AssertATN            EQU &02 ;       1
SC_NegateACK            EQU &03 ;       1
SC_Disconnect           EQU &04 ;       1
SC_Sel_withATN          EQU &06 ; Level 2
SC_Sel_Tx_withATN       EQU &08 ;       2
SC_Sel_Tx_woATN         EQU &09 ;       2
SC_SetIDI               EQU &0F ;       2
SC_Transfer_Info        EQU &20 ;       2
SC_Transfer_Info_SBT    EQU &A0 ;       2
;
;
;------------------------------------------------------------------------------
;
; Host status - Indicates cause of most recent SBIC interrupt, read from SCSI
;               status register (SR_SCSIstat)
;
; Format: 1 byte: iiiiqqqq (1=interrupt type bits, q=qualifier bits)
;
HOST_Type_Mask          EQU 2_11110000  ;Mask to extract interrupt type
;
HOST_RESET              EQU 2_00000001  ;Reset - advanced features enabled
HOST_COMPLETE           EQU 2_00010000
HOST_PAUSED             EQU 2_00100000
HOST_TERMINATED         EQU 2_01000000
HOST_SERVICE            EQU 2_10000000
;
HOST_Qualifier_Mask     EQU 2_00001111  ;Mask to extract qualifier
;
HOST_TIMEOUT            EQU 2_01000010
;
;
;------------------------------------------------------------------------------
;
; SBIC general status bits - Read from SBIC auxiliary status register
;                            (SBIXauxstat)
;
DBR                     EQU &01 ;Data Buffer Ready
PE                      EQU &02 ;Parity Error
CIP                     EQU &10 ;Command In Progress
BSY                     EQU &20 ;BuSY - Level II command executing
LCI                     EQU &40 ;Last Command Ignored
INT                     EQU &80 ;INTerrupt pending
;
;
;------------------------------------------------------------------------------
; Bits in SR_OwnID
EAF             EQU &08         ;Enable Advanced Features
;EHP            EQU &10         ;Enable Host Parity
;----------------------
; Bits in SR_Control
IDI             EQU &04         ;Intermediate Disconnect Interrupt
;EDI            EQU &08         ;Ending Disconnect Interrupt
DMAmode         EQU &20         ;SBIC burst DMA mode
;-----------------
; Bits in SR_DestID
DPD             EQU &40         ;Data Phase Direction, set for DataIn expected
;----------------
; Bits in SR_SourceID
ER              EQU &80         ;Enable reselection
SIV             EQU &08         ;Source ID valid
;
;----------------
;
SyncMode        EQU &20         ;REQ/ACK pulse width of 1 cycle
SelectTimeout   EQU 10          ;SBIC 100mS timeout on select phase
;
;
;==============================================================================


;==============================================================================
;
; DMAC registers and control bits
;
;------------------------------------------------------------------------------
;
; DMAC registers - memory mapped, accessed by +ve offsets off rDMACptr (R11)
;
 ^ 0,rDMACptr
                      ;Offset
DR_Initialise #  &200 ; 000
DR_Channel    # -&1FC ; 200
DR_TxCntLo    #  &200 ; 004
DR_TxCntHi    # -&1FC ; 204
DR_TxAdrLo    #  &200 ; 008
DR_TxAdrMd    # -&1FC ; 208
DR_TxAdrHi    #  &200 ; 00C
DR_Unused     # -&1FC ; 20C
DR_DevCon1    #  &200 ; 010
DR_DevCon2    # -&1FC ; 210
DR_ModeCon    #  &200 ; 014
DR_Status     # -&1FC ; 214
DR_TempLo     #  &200 ; 018
DR_TempHi     # -&1FC ; 218
DR_Request    #  &200 ; 01C
DR_Mask       # -&1FC ; 21C
;
;
;------------------------------------------------------------------------------
;
dmac_bits       EQU &01         ;Active, 8bit mode
ctrl1           EQU &60         ;Active low DRQ/DACK, extended write
ctrl2           EQU &01         ;Bus hold between cycles

clr_mask        EQU &0E         ;Channel 0 may interrupt
set_mask        EQU &0F         ;Set all DRQ masks
dma_rd_mode     EQU &04         ;Demand mode, read
dma_wr_mode     EQU &08         ;Demand mode, write
;
;
;==============================================================================


;==============================================================================
;
; SCSI command, message and status bytes
;
;------------------------------------------------------------------------------
;
; SCSI commands - Operation codes held in the 1st byte of a CDB (command
;                 descriptor block).
;
C_INQUIRY               EQU &12
INQUIRY_BLK_SIZE        EQU 5           ;Used by 'Determine Device'
INQUIRY_BLK_SIZEL       EQU 36
Describe_BLK_SIZE       EQU (INQUIRY_BLK_SIZEL + READCAPACITY_BLK_SIZE)

C_READCAPACITY          EQU &25
READCAPACITY_BLK_SIZE   EQU 8           ;Used by 'Determine Device'
Determine_BLK_SIZE      EQU (INQUIRY_BLK_SIZE + READCAPACITY_BLK_SIZE)

C_REQUESTSENSE          EQU &03
REQUESTSENSE_BLK_SIZE   EQU &08         ;Space for 8 bytes of extended sense
;
;
;------------------------------------------------------------------------------
;
; SCSI Message codes - In = Target to initiator, Out = Initiator to Target
;
MESSAGE_COMMANDCOMPLETE         EQU &00 ; In
MESSAGE_EXTENDEDMESSAGE         EQU &01 ; In Out
MESSAGE_SAVEDATAPOINTER         EQU &02 ; In
MESSAGE_RESTOREDATAPOINTER      EQU &03 ; In
MESSAGE_DISCONNECT              EQU &04 ; In
MESSAGE_ABORT                   EQU &06 ;    Out
MESSAGE_REJECT                  EQU &07 ; In Out
MESSAGE_NOOPERATION             EQU &08 ;    Out
MESSAGE_BUSDEVICERESET          EQU &0C ;    Out
;
;
;------------------------------------------------------------------------------
;
; Target status - Returned by the Target during the status phase of command
;
; Format: 1 byte: rvvSSSSv (r=reserved, v=vendor unique, S=status bit)
;
TARGET_Mask                     EQU 2_10011110  ;Mask to extract status bits
;
TARGET_GOOD                     EQU 2_00000000
TARGET_CHECK_CONDITION          EQU 2_00000010
TARGET_BUSY                     EQU 2_00001000
;
; Pseudo target status values
;
TARGET_TIMEOUT                  EQU &0100       ;Timeout during selection
                                                ;We sent MESSAGE_ABORT
TARGET_TIMEOUT2                 EQU &0200       ; cos operation took too long
TARGET_ESCAPED                  EQU &0300       ; cos user pressed escape
TARGET_ABORTOP                  EQU &0400       ; cos user did AbortOp
TARGET_ABORTDEVICE              EQU &0500       ; cos user did AbortDevice
                                                ;We sent MESSAGE_BUSDEVICERESET
TARGET_RESET                    EQU &0600       ; cos user did ResetDevice
TARGET_UNEXPECTEDDISCONNECT     EQU &0700       ;Target dropped dead!!!
;
;
;==============================================================================


;==============================================================================
;
; Misc records - RamRec, PtrRec and CmdRec
;
;------------------------------------------------------------------------------
;
; The SRAM is visible as 16 x 4K pages (PAGECOUNT x PAGELEN),
; Data transfer between MainRam & SRAM is by a fast data copier using LDM/STM
; in chunks of PAGELEN bytes or less.
; Data transfer between SRAM & SBIC uses the DMAC controler and is in chunks
; of PAGELEN bytes or less.
;
; For each slot, we maintain a record of the MainRam address,SRAMpage,
; SRAMoffset and Block size of a chunk.
;
; For each device, we maintain a circular queue indicating slots allocated to
; that device.
;
; Consider the READ case (Target->Host)
;   The DMAC, if running, fills the slot whose number is held in DMACram.
;   On completion of that chunk (terminal count interrupt), DMACram is
;   queued. If there is further data to transfer and a page can be claimed
;   to DMA it into, that page number is written into DMACram and the DMAC
;   restarted, if not the DMAC status is set to IDLE or STALLED as appropriate.
;
;   The copier will run for as long as QStart<>QEnd and will copy the page
;   whose slot number appears at QStart. On completion of that page, QStart is
;   advanced. When QStart=QEnd, the copier status is set to IDLE or STALLED
;   as appropriate.
;
;   The slots freed by the copier will allow a stalled DMAC to be restarted and
;   slots filled by the DMAC may allow a stalled Copier to be restarted.
;


    ^ 0,rPAGESLOTptr
RamTxAdr        # 4             ;Main memory Src/Dst address
RamBlkSz        # 4             ;BlockSize
RamOffset       # 4             ;SRAM offset (0/1/2/3)
RamPage         # 4             ;SRAM page
;
RamRecSize      # 0
;
;
;------------------------------------------------------------------------------
;
; A SCSI pointer record, used by SavedPointers,CurrentPointers & FuturePointers
;
    ^ 0
ScatPtr         # 4
EntAdr          # 4
EntCnt          # 4
TtlCnt          # 4
;
PtrRecSize      # 0
;
;
;------------------------------------------------------------------------------
;
; Commands are queued, and start executing in chronological order,
; if a device allows disconnection, it may disconnect, allowing a
; later command (for a different device) to be started.
; Although commands are started in order, they may complete and hence be
; removed from the queue in any order.
;
    ^ 0,rCMDptr
CmdDevID        # 4             ;                 } Copy of SCSIop
CmdCDBLen       # 4             ;                 }
CmdCDB          # 12            ;N.B. Copy of CDB }
CmdXferPtr      # 4             ;                 }
CmdXferLen      # 4             ;                 }  parameters
 [ soft
CmdCallbackR5   # 4             ;                 }
 |
CmdTimeout      # 4             ;                 }
 ]
CmdCallbackAdr  # 4             ;                 }
CmdCallbackR12  # 4             ;                 }

CmdRtR3         # 4             ; }
CmdRtR4         # 4             ; }

CmdStat         # 4             ;Waiting/Initialising/Initialised/Running/Idle
;CmdCtl          # 4             ;Send message/Execute CDB/Request sense
CmdOpID         # 4             ;Command ID returned to user
CmdNxt          # 4             ;Link to next command (chronological order)

spare0          # 4

CmdRecSize      # 0
Log2CMDRECSIZE  EQU 6
                ASSERT ((:INDEX: CmdRecSize) = (1 :SHL: Log2CMDRECSIZE))
;
;
;==============================================================================


;==============================================================================
;
; Workspace for SCSI device
;
    ^ 0,rDEVICEptr
DeviStat        # 4             ;absent/idle/running
CopyStat        # 4             ;       idle/running/stalled
DMACStat        # 4             ;       idle/running/stalled
SBICStat        # 4             ;       idle/running
Connected       # 4             ;0/~0 for disconnected/connected

MessageIn       # 4             ;Last message we received
MessageOut      # 4             ;Last message we managed to send
TargStat        # 4             ;Copied from SBIC TargetLUN register on
                                ; completion of 'Select-And-Transfer'
HostStat        # 4             ;Copied from SBIC SCSI status register
HostStat1       # 4             ;Previous value
 [ debug
HostStat2       # 4
HostStat3       # 4
HostStat4       # 4
HostStat5       # 4
HostStat6       # 4
HostStat7       # 4
 ]
 [ debug
;IntStat         # 4
HostAuxStat     # 4             ;
;HostPhase       # 4
 ]

CpyCtl          # 4
CpyAdr          # 4  ;>>>not needed??? ;Main memory address to copy to/from
CpyCnt          # 4             ;Transfer size loaded into SBIC
CpyFail         # 4             ;Amount NOT transfered

SavedPointers   # 0     ;SavedPointers
SavdScatPtr     # 4     ;
SavdEntAdr      # 4     ;
SavdEntCnt      # 4     ;
SavdTtlCnt      # 4     ; see PtrRecSize

CurrentPointers # 0     ;CurrentPointers
CurrScatPtr     # 4     ;        ;Pointer to next Address/Length pair to use
CurrEntAdr      # 4     ;
CurrEntCnt      # 4     ;
CurrTtlCnt      # 4     ; see PtrRecSize

FuturePointers  # 0     ;FuturePointers
FutrScatPtr     # 4     ;Used only when writing,
FutrEntAdr      # 4     ; to allow data to be copied to SRAM
FutrEntCnt      # 4     ; before the DMAC needs it.
FutrTtlCnt      # 4     ; see PtrRecSize

DemandSlot      # :INDEX: RamRecSize

Timeout         # 4
QStart          # 4             ; } Offsets to Queue0..Queue19
QEnd            # 4             ; } Queue bigger than number of pages to
Queue0          # (PAGECOUNT+4)*4 ; } prevent full/empty ambiguity
QueuePastIt     # 0
;
DMACram         # 4             ;If reading, this is the RAM page (0..15), that
                                ;            the DMAC is filling.
                                ;If writing, this is the RAM page the DMAC is
                                ;            emptying.
CMDptr          # 4             ;Pointer to current CmdRec

FakeScatterAdr  # 4             ;If user didn't supply a scatter list, dump
FakeScatterLen  # 4             ; address & len here and use this

SenseBlk        # REQUESTSENSE_BLK_SIZE ;Good place to put Sense Data if doing
                                ; automatic Request sense on check condition

PendingCnt      # 4             ;Number of commands queued for this device
SoftClearDevCBEnd # 0   ;Extent of clearing/initialise for 'soft' initialise

 [ :LNOT:soft
ReleaseCallAdr  # 4
ReleaseCallR12  # 4
AccessKey       # 4

ControlTimeout  # 4
ControlBits     # 4
 ]

HoldCmd         # 4             ;Used to hold SBIC state around MessageIN
HoldPhase       # 4             ; MessageOut phases
HoldCount       # 4
 [ bugfix2
Suppress        # 4             ;Bit mask of messages (out) to be suppressed
                                ; normally zero, holds CTL_Suppress after
                                ; MESSAGE_COMMANDCOMPLETE received
 ]
HardClearDevCBEnd # 0   ;Extent of clearing/initialise for 'hard' initialise
deviceRecSize   # 0
;
;
;==============================================================================


;==============================================================================
;
; Workspace for ONE SCSI card
;
    ^ 0,WsPtr
DEVICEptr       # 4             ;0 or ->DevCB(0..7)
PODULEptr       # 4             ;Typicaly &03343000 (for slot 0)
DMACptr         # 4             ;Typicaly &03003000 (for slot 0)
SRAMptr         # 4             ;Typicaly &03000000 (for slot 0)
HostID          # 4             ;0..7, typicaly 7

ClearWSStart    # 0

OperationID     # 4             ;Next operation ID to be issued
Lockout         # 4
QuadDump        # 16

RamMap          # 4             ;Bit vector of RAM pages in use
Ram0            # (PAGECOUNT * :INDEX: RamRecSize)
                                ;16 slots, one slot per page of SRAM
FirstCmd        # 4
CmdMap          # 4
Cmd0            # (CMDCOUNT * :INDEX: CmdRecSize)

ClearWSEnd      # 0

DevCB0          # :INDEX: deviceRecSize
DevCB1          # :INDEX: deviceRecSize
DevCB2          # :INDEX: deviceRecSize
DevCB3          # :INDEX: deviceRecSize
DevCB4          # :INDEX: deviceRecSize
DevCB5          # :INDEX: deviceRecSize
DevCB6          # :INDEX: deviceRecSize
DevCB7          # :INDEX: deviceRecSize

Cardworkspacesize # 0
;
;
;==============================================================================


;==============================================================================
;
; Workspace for upto 4 SCSI cards
;
    ^ 0,WsPtr
ListEntry0      # 4
ListEntry1      # 4
ListEntry2      # 4
ListEntry3      # 4
ListHighestTerm # 4

maxCardID       # 4             ;0/1/2/3 for 1/2/3/4 SCSI cards

SCSIstubsize    # 0

LogicalCard0    # :INDEX: Cardworkspacesize
LogicalCard1    # :INDEX: Cardworkspacesize
LogicalCard2    # :INDEX: Cardworkspacesize
LogicalCard3    # :INDEX: Cardworkspacesize

SCSIworkspacesize # 0
;
;
;==============================================================================


;==============================================================================
;
; Control bits in R0 for SWI SCSI_Op
;
CTL_TXNONE                      EQU &00 :SHL: 24
CTL_TXREAD                      EQU &01 :SHL: 24
CTL_TXWRITE                     EQU &02 :SHL: 24
CTL_TXRESERVED                  EQU &03 :SHL: 24
CTL_SCATTER                     EQU &01 :SHL: 26
CTL_NOESCAPE                    EQU &01 :SHL: 27
CTL_RETRYONTIMEOUT              EQU &01 :SHL: 28
CTL_BACKGROUND                  EQU &01 :SHL: 29
;
;>>>Would extra bits for inhibit disconnect and 'this is a message' be useful
;>>>(possibly for internal use only)?
;
CTL_INHIBITREQUESTSENSE         EQU &01 :SHL: 23
CTL_REPORTUNITATTENTION         EQU &01 :SHL: 22
CTL_INHIBITDISCONNECTION        EQU &01 :SHL: 21
CTL_INHIBITIDENTIFY             EQU &01 :SHL: 20
;
CTL_DOINGREQUESTSENSE           EQU &01 :SHL: 19
;
CTL_REJECTQUEUEFULL             EQU &01 :SHL: 18
CTL_REJECTDEVICEBUSY            EQU &01 :SHL: 17
CTL_REJECTPODULEBUSY            EQU &01 :SHL: 16
;
CTL_DOINGRESET                  EQU &01 :SHL: 15
CTL_DOINGABORTDEVICE            EQU &01 :SHL: 14
CTL_DOINGABORTOP                EQU &01 :SHL: 13
CTL_DOINGESCAPEDEVICE           EQU &01 :SHL: 12
CTL_DOINGTIMEOUT2               EQU &01 :SHL: 11
CTL_DOINGMESSAGEREJECT          EQU &01 :SHL: 10
;
;
; Composite flags for communication at the simplest level,
;   ie no disconnection or identify message.
;
CTL_DumbDeviceTXNONE    EQU CTL_INHIBITDISCONNECTION :OR: CTL_INHIBITIDENTIFY
CTL_DumbDeviceTXREAD    EQU CTL_DumbDeviceTXNONE     :OR: CTL_TXREAD
CTL_DumbDeviceTXWRITE   EQU CTL_DumbDeviceTXNONE     :OR: CTL_TXWRITE
;
; Composite flags for sending messages
;
CTL_MessageOnly                 EQU CTL_INHIBITREQUESTSENSE :OR: CTL_BACKGROUND
;
;
; Actions to be suppressed once MESSAGE_COMMANDCOMPLETE is received
;
CTL_Suppress            EQU CTL_DOINGABORTOP :OR: CTL_DOINGESCAPEDEVICE :OR: CTL_DOINGTIMEOUT2
;
;
;==============================================================================


;==============================================================================
;
; Internally the device driver always runs SCSI transfers as background tasks
; that perform a callback on completion/error. The 'foreground' transfers are
; acheived by setting up an internal background handler and looping in the
; foreground until the callback handler indicates completion by writing to
; a block allocated on the stack. The format of this block is:-
;
    ^ 0
CallBkR0        # 4     ;0 or ->error block
CallBkR1        # 4     ;0 or error number
CallBkR2        # 4     ;     logical address on device where error occured

CallRtR3        # 4     ;
CallRtR4        # 4     ;

CallBkStat      # 4     ;RUNNING/IDLE/ERROR

CallBkRecSize   # 0
;
;
;==============================================================================


;==============================================================================
;
; Macro definitions
; =================
;
;------------------------------------------------------------------------------
;
        MACRO
        MySWI   $swiname
        ASSERT  SCSI_SWIbase+(.-SCSI_SWItable)/4 = $swiname
        B       SWI_$swiname
        MEND
;
;
;------------------------------------------------------------------------------
;
        MACRO
        MyEntry $entryname
;        ASSERT  SCSI_SWIbase+(.-SCSI_SWItable)/4 = $swiname
        B       Entry_$swiname
        MEND
;
;
;------------------------------------------------------------------------------
;
        MACRO
        AddressCard
        ASSERT (:INDEX:PODULEptr)=4
        ASSERT (:INDEX:DMACptr)=8

        BL DoAddressCard
       ;LDMIB WsPtr,{rPODULEptr,rDMACptr}       ;>>>do this here???
        MEND
;
;
;------------------------------------------------------------------------------
;
        MACRO
        ForEachCard $routinename
        mess ,"ForEachCard - Entry", NL
        ADRL R6,$routinename
        BL DoForEachCard
        mess ,"ForEachCard - Exit", NL
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro rdSBIC - read contents of a SBIC register
; eg rdSBIC R0,SR_Control
;
        MACRO
$label  rdSBIC   $arm, $sbic, $cc
$label  MOV$cc   $arm, #$sbic
        STR$cc.B $arm, SBICaddress
        LDR$cc.B $arm, SBICindirect
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro wrSBIC - write to SBIC register
; eg wrSBIC R0,SR_OwnID
;
; N.B. corrupts R14 (Link)
;
        MACRO
$label  wrSBIC   $arm, $sbic, $cc
$label  MOV$cc   R14,  #$sbic
        STR$cc.B R14,  SBICaddress
        STR$cc.B $arm, SBICindirect
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro rdSBIC24 - read 24bits from SBIC
; eg rdSBIC24 R0,SR_Count
;
; N.B. corrupts R14 (Link)
;
        MACRO
$label  rdSBIC24 $arm, $sbic, $cc
$label  MOV$cc   R14, #$sbic.Hi
        STR$cc.B R14, SBICaddress
        LDR$cc.B $arm, SBICindirect
        LDR$cc.B R14, SBICindirect
        ORR$cc $arm,R14,$arm,LSL #8     ;0000HHMM
        LDR$cc.B R14, SBICindirect
        ORR$cc $arm,R14,$arm,LSL #8     ;00HHMMLL
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro wrSBIC24 - write 24bits to SBIC
; eg wrSBIC24 R0,SR_Count       ;Write to SR_CountHi,SR_CountMd,SR_CountLo
;
; N.B. corrupts R14 (Link)
;
        MACRO
$label  wrSBIC24   $arm, $sbic, $cc
$label  MOV$cc   R14,  #$sbic.Hi
        STR$cc.B R14,  SBICaddress
        MOV$cc $arm,$arm,ROR #16        ;xxHHmmll->mmllxxHH
        STR$cc.B $arm, SBICindirect
        MOV$cc $arm,$arm,ROR #24        ;MMllxxhh->llxxhhMM
        STR$cc.B $arm, SBICindirect
        MOV$cc $arm,$arm,ROR #24        ;LLxxhhmm->xxhhmmLL
        STR$cc.B $arm, SBICindirect
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro wrDMAC - write to DMAC register
; eg wrDMAC R0,DR_Channel, VC
;
        MACRO
$label  wrDMAC $arm, $dmac, $cc
$label  STR$cc.B $arm, $dmac
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro rdDMAC - read contents of a DMAC register
; eg rdDMAC R0,DR_Channel, VC
;
        MACRO
$label  rdDMAC $arm, $dmac, $cc
$label  LDR$cc.B $arm, $dmac
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro wrPageReg - write to page register (& soft copy)
;
        MACRO
$label  wrPageReg $arm, $cc
$label  STR$cc.B $arm,PR_PageReg
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro JoinHWords
;
        MACRO
$label  InitJoinMask $mask
$label  MOV $mask,      #&00FF0000
        ORR $mask,$mask,#&FF000000
        MEND

        MACRO
$label  JoinHWords $dst,$lo,$hi,$mask
 [ "$mask"=""
$label  BIC $lo,$lo,#&00FF0000
        BIC $lo,$lo,#&FF000000
 |
$label  BIC $lo,$lo,$mask
 ]
        ORR $dst,$lo,$hi,LSL #16
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro SplitWord
;
        MACRO
$label  SplitWord $lo,$hi
$label  MOV $lo,$hi,LSL #16
        MOV $hi,$hi,LSR #16
        ORR $lo,$lo,$lo,ROR #16
        ORR $hi,$hi,$hi,ROR #16
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro RevBytes - reverse the bytes in a register
;
        MACRO
$label  RevBytes $arm, $t1,$t2, $succ
 [ "$label" <> "" :LOR: "$succ" = ""
$label  MVN $t1,#&FF00          ;a3=&FFFF00FF
 ]
        EOR $t2,$arm,$arm,ROR #16
        AND $t2,$t1,$t2,LSR #8
        EOR $arm,$t2,$arm,ROR #8
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro EnableIRQs - enable IRQ's
;
; User is in SVC_mode with IRQs (en/dis)abled or in IRQ_mode with IRQs disabled
;
        MACRO
$label  EnableIRQs
 [ No32bitCode
$label  BIC Link,Link,#I_bit
        TEQP PC,Link            ;Preserve SVC_mode/IRQ_mode, enable IRQs
        NOP
 |
$label  EnableIRQs2 Link
 ]
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro DisableIRQs - disable IRQ's
;
; User is in SVC_mode with IRQs (en/dis)abled or in IRQ_mode with IRQs disabled
;
        MACRO
$label  DisableIRQs
 [ No32bitCode
$label  ORR Link,Link,#I_bit
        TEQP PC,Link            ;Preserve SVC_mode/IRQ_mode, disable IRQs
        NOP
 |
$label  EnableIRQs2 Link
 ]
        MEND
;
;
;------------------------------------------------------------------------------
d52 5
a56 13
;------------------------------------------------------------------------------
;
; Macro EnableIRQs2 - enable IRQs
;
; User is in SVC_mode or IRQ_mode
;
        MACRO
$label  EnableIRQs2 $t1
 [ No32bitCode
$label  MOV $t1,PC
        BIC $t1,$t1,#I_bit
        TEQP PC,$t1             ;Preserve SVC_mode/IRQ_mode, enable IRQs
        NOP
d58 1
a58 3
$label  MRS $t1,CPSR
        BIC $t1,$t1,#I32_bit
        MSR CPSR_c,$t1
a59 20
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macro DisableIRQs2 - disable IRQs
;
; User is in SVC_mode or IRQ_mode
;
        MACRO
$label  DisableIRQs2 $t1
 [ No32bitCode
$label  MOV $t1,PC
        ORR $t1,$t1,#I_bit
        TEQP PC,$t1             ;Preserve SVC_mode/IRQ_mode, disable IRQs
        NOP
 |
$label  MRS $t1,CPSR
        ORR $t1,$t1,#I32_bit
        MSR CPSR_c,$t1
a60 6
        MEND
;
;
;------------------------------------------------------------------------------
;
; Macros to handle either returning error pointers or error numbers
d62 17
a78 5
        MACRO
        XSCSIError $err
 [ soft
        MOV     R0, #ErrorNumber_$err-SCSI_ErrorBase
        SETV
d80 2
a81 1
        XError  $err
a82 1
        MEND
d84 28
a111 6
        MACRO
        MakeSCSIErrorBlock $err
 [ :LNOT:soft
        MakeErrorBlock $err
 ]
        MEND
d113 2
a114 8
        MACRO
        SCSIError $err, $cond, $l
 [ soft
        MOV$cond R0, #ErrorNumber_$err-SCSI_ErrorBase
 |
        ADR$cond.$l R0, ErrorBlock_$err
 ]
        MEND
d116 2
a117 1
;------------------------------------------------------------------------------
d119 2
d122 2
a123 1
;===========================================================================
d125 2
a126 1
; Macro to separate a 32-bit value in a register into its two 16-bit halves.
d128 1
a128 70
        MACRO
$label  Split16 $resh,$resl,$src
        ASSERT  $resh <> $src
$label  MOV     $resh,$src,LSR #16
        BIC     $resl,$src,$resh,LSL #16
        MEND

;===========================================================================

; Macro to do a (16,16)x32 -> 64 multiplication. Done by breaking it up into
; four 16x16 multiplications and recombining the pieces. (N.B. The trick
; described in Knuth section 4.3.3 for reducing the four multiplications to
; three plus some additions and sign manipulations is not profitable at this
; size: it only becomes profitable when trying to synthesise a 64x64
; multiplication out of 32x32 multiplications.)
;   Also allows the flags to be set on the high word of the result and an
; optional addend to be added into the high word of the result: however,
; combining these does *not* result in the C flag being set correctly for
; the carry-out from the notional addition of the addend and the high word.
; Only the Z and N flags have meaningful values.
;   The operands are:
; $resh,$resl: Registers that will receive the 64-bit product;
; $op1h,$op1l: Registers containing the high and low 16 bits of the first
;              32-bit operand;
; $op2:        Register containing the second 32-bit operand;
; $add:        If present, register containing the addend;
; $s:          "S" to set the condition codes;
; $t1,$t2,$t3: Three temporary registers required during the calculation.
; The restrictions on which registers may be the same are complicated and
; are detailed in the ASSERT statements below.

        MACRO
$label  Mul64   $resh,$resl,$op1h,$op1l,$op2,$add,$s,$t1,$t2,$t3
        ASSERT  $resh <> $resl
        ASSERT  $resl <> $op1h
        ASSERT  $resl <> $t1
        ASSERT  $resl <> $t2
        ASSERT  $resl <> $t3
        ASSERT  $op1h <> $op1l
        ASSERT  $op1h <> $op2
        ASSERT  $op1h <> $t1
        ASSERT  $op1h <> $t2
        ASSERT  $op1h <> $t3
        ASSERT  $op1l <> $op2
        ASSERT  $op1l <> $t1
        ASSERT  $op1l <> $t2
        ASSERT  $op1l <> $t3
        ASSERT  $op2  <> $t1
        ASSERT  $t1   <> $t2
        ASSERT  $t1   <> $t3
        ASSERT  $t2   <> $t3
$label  Split16 $t1,$t2,$op2            ;t1 := op2h, t2 := op2l
        [ "$add" <> ""
          ASSERT  $add <> $op1h
          ASSERT  $add <> $op1l
          ASSERT  $add <> $op2
          ASSERT  $add <> $t1
          ASSERT  $add <> $t2
          MLA     $t3,$op1h,$t1,$add      ;t3 := op1h * op2h + add
        |
          MUL     $t3,$op1h,$t1           ;t3 := op1h * op2h
        ]
        MUL     $t1,$op1l,$t1           ;t1 := op1l * op2h
        MUL     $resl,$t2,$op1l         ;resl := op1l * op2l
        ADDS    $resl,$resl,$t1,LSL #16 ;Add op1l * op2h into (t3,resl)
        ADC     $t3,$t3,$t1,LSR #16
        MUL     $t2,$op1h,$t2           ;t2 := op1h * op2l
        ADDS    $resl,$resl,$t2,LSL #16 ;Add op1h * op2l into (t3,resl)
        ADC$s   $resh,$t3,$t2,LSR #16   ; to produce (resh,resl)
        MEND
a129 1
;------------------------------------------------------------------------------
d131 2
a132 1
; Macro mess - print a debugging message
a133 51
        MACRO
        mess    $cond,$s1,$s2,$s3,$s4,$s5
 [ trace
        B$cond  %F11
        BAL     %F21
11
        Push    "LR"
        SWI     OS_WriteS
 [ "$s1"="NL"
 = CR,LF
 |
 = "ScsiDriver: $s1"
 ]
 [ "$s2"=""
 |
  [ "$s2"="NL"
  = CR,LF
  |
  = "$s2"
  ]
  [ "$s3"=""
  |
   [ "$s3"="NL"
   = CR,LF
   |
   = "$s3"
   ]
   [ "$s4"=""
   |
    [ "$s4"="NL"
    = CR,LF
    |
    = "$s4"
    ]
    [ "$s5"=""
    |
     [ "$s5"="NL"
     = CR,LF
     |
     = "$s5"
     ]
    ]
   ]
  ]
 ]
        =       0
        ALIGN
        Pull    "LR"
21
 ]
        MEND
d135 15
d151 2
a152 4
        MACRO
        traceswi $s1
        mess , "SWI_SCSI_$s1", NL
        MEND
d155 3
a157 4
        MACRO
        tracerc $s1
        mess , "   $s1", NL
        MEND
d159 1
a159 12
        MACRO
        trhex $reg
 [ trace
        Push    "R0-R2"
        MOV     R0, $reg
        ADR     R1, MyStringBuff2
        MOV     R2, #16
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        Pull    "R0-R2"
 ]
        MEND
d161 1
a161 11
        MACRO
        trstr $str, $nl
 [ trace
        SWI     OS_WriteS
        = "$str", 0
        ALIGN
  [ "$nl" <> ""
        trnl
  ]
 ]
        MEND
d163 4
a166 6
        MACRO
        trnl
 [ trace
        SWI     OS_NewLine
 ]
        MEND
d168 9
a176 3
;
;
;==============================================================================
d178 9
d188 1
a188 5
;==============================================================================
;
; Module start
;
        ASSERT (.=Module_BaseAddr)      ;Winge if we've generated code
a191 2
;alan glover 24/10/91 added '-Module_BaseAddr' to satisfy newer versions of AASM

d213 1
a213 1
 [ true
d254 2
a255 2
;>>>------------------------------------------------------------
;>>>GET TokHelpSrc. For now, have inline non tokenised help text
d313 1
a313 1
 [ false
d467 5
a471 5
;------------------------------------------------------------------------------
;
; ModInit - Module Initialisation entry
; =======
;
d501 2
a502 2
        CMP R11,#&03000000              ;Loaded from a podule,
        BHS ModIn_20                    ; R11 is podule base address
d514 1
a514 1
        SUBS R3,R0,#"0"         ;Accept "0".."9",
d520 2
a521 9
        BICVC R11,R11,#&300
        MOVVS R11,#0
;
; R11 holds the podule base address (sync access)
; (&03240000, &03244000, &03248000 or &0324C000) (slow access)
; (&032C0000, &032C4000, &032C8000 or &032CC000) (medium access)
; (&03340000, &03344000, &03348000 or &0334C000) (fast access)
; (&033C0000, &033C4000, &033C8000 or &033CC000) (sync. access)
;
d546 2
a547 2
        CMP R3,#4               ;Restrict to 4 cards maximum
        MOVGT R3,#4             ;
d588 1
a588 1
        ForEachCard HardResetCard
d590 1
a590 1
        ForEachCard RegisterCard
d600 1
a600 1
        MakeSCSIErrorBlock SCSI_NoRoom      ;"No room for SCSI driver workspace"
d611 1
a611 1
        MakeErrorBlock SCSI_WrongMEMC     ;"SCSI requires MEMC1a - see your dealer"
d613 6
a618 7
;
;
;------------------------------------------------------------------------------
;
; ModDie - Module Finalisation entry
; ======
;
d636 1
a636 1
        ForEachCard DeregisterCard
d638 1
a638 1
        ForEachCard FreezeAndRelease
a643 3
XSCSI_Register          * &603FF
XSCSI_Deregister        * &603FE

d653 2
a654 2
        MOVVS   R0,#-1
        STR     R0, HostID
d665 1
a665 1
        SWI     XSCSI_Deregister
d669 4
a672 6
;
;
;------------------------------------------------------------------------------
;
; ModService - Module Service entry
; ==========
d699 1
a699 1
        MOV R0, R0
d711 5
a715 3
;
; Module service - Service_PreReset
;
d732 5
a736 3
;
; Module service - Service_Reset
;
a749 1

d756 3
a758 5
;==============================================================================
;
; Driver dispatch
;
;------------------------------------------------------------------------------
d782 8
a789 8
        B FeaturesEntry
        B ResetBusEntry
        B err_Entryunkn
        B err_Entryunkn
        B err_Entryunkn
        B OpEntry
        B AbortOpEntry
        B HostDescEntry
d803 4
a806 5
;==============================================================================
;
; SCSI SWI names and SWI dispatch
;
;------------------------------------------------------------------------------
d823 6
a828 7
;
;
;------------------------------------------------------------------------------
;
; SWI decoding
; ============
;
d845 1
a845 1
        LDR WsPtr,[R12]         ;Get workspace ptr
a1002 3
;
;
;==============================================================================
d1005 4
a1008 5
;==============================================================================
;
; SWI_SCSI_Version
; ================
;
a1028 3
;
;
;==============================================================================
d1031 4
a1034 5
;==============================================================================
;
; SWI SCSI_Initialise
; ===================
;
d1076 5
a1080 7
;
;
;------------------------------------------------------------------------------
;
; ResetBus (SWI SCSI_Initialise, RC=0)
; ========
;
d1101 1
a1101 1
        CMP R1,#maxDeviceID     ;Only ID's 0..7 are valid
d1113 6
a1118 7
;
;
;------------------------------------------------------------------------------
;
; ResetDevice (SWI SCSI_Initialise, RC=1)
; ===========
;
d1152 1
a1152 4
;
;
;------------------------------------------------------------------------------
;
d1158 6
a1163 7
;
;
;------------------------------------------------------------------------------
;
; DetermineDevice (SWI SCSI_Initialise, RC=2)
; ===============
;
a1236 4
;
;
;------------------------------------------------------------------------------
;
d1336 5
a1340 7
;
;
;------------------------------------------------------------------------------
;
; EnumerateDevice (SWI SCSI_Initialise, RC=3)
; ===============
;
d1663 4
a1666 7
;
;
;------------------------------------------------------------------------------
;
; ExamineDeviceWS (SWI SCSI_Initialise, RC=4)
; ===============
;
a1691 3
;
;
;==============================================================================
d1693 3
a1696 6
;==============================================================================
;
; Misc. routines
;
;------------------------------------------------------------------------------
;
d1749 1
a1749 3
;
;
;------------------------------------------------------------------------------
a1810 3
;
;------------------------------------------------------------------------------
;
a1844 3
;
;
;==============================================================================
d1846 3
a1849 5
;==============================================================================
;
; SWI SCSI_Control
; ================
;
d1896 5
a1900 7
;
;
;------------------------------------------------------------------------------
;
; AbortDevice (SWI SCSI_Control, RC=0)
; ===========
;
d1926 5
a1930 7
;
;
;------------------------------------------------------------------------------
;
; AbortOp (SWI SCSI_Control, RC=1)
; =======
;
d1952 1
a1952 4
;
;
;------------------------------------------------------------------------------
;
d1956 4
a1959 7
;
;
;------------------------------------------------------------------------------
;
; SetTimeOut (SWI SCSI_Control, RC=3)
; ==========
;
d1983 5
a1987 7
;
;
;------------------------------------------------------------------------------
;
; ControlErrors (SWI SCSI_Control, RC=4)
; =============
;
d2038 5
a2042 7
;
;
;------------------------------------------------------------------------------
;
; ControlQueue (SWI SCSI_Control, RC=5)
; ============
;
d2095 5
a2099 7
;
;
;------------------------------------------------------------------------------
;
; ControlDisconnects (SWI SCSI_Control, RC=6)
; ==================
;
a2143 3
;
;
;==============================================================================
d2146 4
a2149 4
;==============================================================================
;
; SWI SCSI_Status
; ===============
d2173 5
a2177 7
;
;
;------------------------------------------------------------------------------
;
; CheckDevice (SWI SCSI_Status, RC=0)
; ===========
;
d2201 1
a2201 4
;
;
;------------------------------------------------------------------------------
;
a2203 3
;
;
;==============================================================================
d2205 3
a2208 5
;==============================================================================
;
; SWI SCSI_ReadControlLines
; =========================
;
a2211 3
;
;
;==============================================================================
d2213 3
a2216 5
;==============================================================================
;
; SWI SCSI_EEProm
; ===============
;
a2219 3
;
;
;==============================================================================
d2221 3
a2224 5
;==============================================================================
;
; SWI SCSI_Reserve
; ================
;
d2258 5
a2262 7
;
;
;------------------------------------------------------------------------------
;
; ClaimDevice (SWI SCSI_Reserve, RC=0)
; ===========
;
d2286 5
a2290 7
;
;
;------------------------------------------------------------------------------
;
; ForceClaimDevice (SWI SCSI_Reserve, RC=1)
; ================
;
d2327 5
a2331 7
;
;
;------------------------------------------------------------------------------
;
; FreeDevice (SWI SCSI_Reserve, RC=2)
; ==========
;
a2345 3
;
;
;==============================================================================
d2347 3
a2350 6

;==============================================================================
;
; SWI_SCSI_List
; =============
;
a2359 3
;
;
;==============================================================================
d2361 3
a2364 5
;==============================================================================
;
; SWI_SCSI_Op - Issues a SCSI command to a device.
; ===========
;
d2490 1
a2490 1
 [ false
a2590 1
;
d2648 1
a2648 1
        MOV R1,#-1
d2661 2
a2662 2
        MOV R3,R5,LSR #14               ;
        AND R3,R3,#3                    ;Podule number
d2664 1
a2664 1
        ADD R3,R5,#PoduleSpeedMask      ; bug in Iyonix - only Sync base accepted
d2780 1
a2780 1
 [ true
d2793 1
a2793 1
 [ true
d2809 1
a2809 1
 [ true
d3067 1
a3067 1
        MOV R1,#&21
d3073 1
a3073 1
        BL SCSIop_internal
d3099 4
a3102 5
;==============================================================================
;
; SCSIop_internal - issue SCSI command.
; ===============
;
d3133 1
a3133 1
 [ false
d3189 1
a3189 1
        BEQ op_intl_104
d3377 4
a3380 7
;
;
;------------------------------------------------------------------------------
;
; SCSImessage_internal - issue SCSI message.
; ====================
;
d3404 4
a3407 7
;
;
;------------------------------------------------------------------------------
;
; CallBackHandler
; ===============
;
a3434 3
;
;
;==============================================================================
d3436 3
a3439 5
;==============================================================================
;
; StartCommand - Try sending the next queued SCSI command to the Target
; ============
;
d3583 1
a3583 1
 [ true
d3682 2
a3683 2
 [ true
 [ true
d3824 1
a3824 1
 [ false
a3832 3
;
;
;------------------------------------------------------------------------------
d3834 3
a3837 5
;==============================================================================
;
; Interrupt service routine
; =========================
;
d3877 5
a3881 6
;
;
;------------------------------------------------------------------------------
;
; Terminal Count interrupt from DMAC (Reading)
;
d3945 6
a3950 6
;
;
;------------------------------------------------------------------------------
;
; DMAC terminal count whilst writing data to SBIC
;
d4181 5
a4185 6
;
;
;------------------------------------------------------------------------------
;
; Interrupt from SBIC
;
d4739 1
a4739 1
 [ false
d4749 1
a4749 1
 [ false
d4905 1
a4905 1
 [ true
d4949 1
a4949 1
 [ true
d4987 5
a4991 5
;
;------------------------------------------------------------------------------
;
; Interrupt processed - Check command completion state
;
d5381 1
a5381 1
 [ false
d5399 1
a5399 1
 [ false
d5404 3
a5407 4
;
; CheckReportUnitAttention
; ========================
;
d5430 1
a5430 1
 [ false
d5436 3
a5439 4
;
; LoadCDBregisters
; ================
;
a5513 1
 ;LDRLT R14,[R0]
d5539 4
a5542 4
;
; HoldSBICstate
; =============
;
d5621 3
a5624 4
;
; StopDataTX
; ==========
;
d5693 1
a5693 1
 [ true
d5728 4
a5731 3
;
; ReadBlkFromSRAM
;
d5858 3
a5861 4
;
; WriteBlkToSRAM
; ==============
;
d5935 4
a5939 4
;
; AllocateCMDslot - Allocate a command slot
; ===============
;
d6001 3
a6004 4
;
; DeAllocateCMDSlot
; =================
;
d6040 4
a6043 4
;
; QueueCMDslot - Add a command to the end of the command queue
; ============
;
d6073 4
a6076 4
;
; UnQueueCMDslot - Remove a command from the command queue
; ==============
;
d6110 4
a6113 4
;
; NextCommand - Find the first/next executable queued command.
; ===========
;
d6174 4
a6177 4
;
; FindCommand - find the command that matches a given OpID
; ===========
;
d6205 4
a6208 4
;
; AllocateRAM - Allocate another SRAM page & associated RamRec
; ============
;
d6258 4
a6261 4
;
; DeAllocateRAM
; ==============
;
d6591 4
a6594 4
;
; QueueSlot
; =========
;
d6614 3
a6617 4
;
; UnQueueSlot
; ===========
;
d6637 3
a6640 4
;
; FlushQueue
; ==========
;
d6655 4
a6658 4
;
; ArmDMAC
; =======
;
d6673 1
a6673 1
 [ false
d6836 1
a6836 1
 [ true
d6842 2
a6843 2
 [ true
 [ true
d6895 1
a6895 1
 [ true
@


4.2
log
@* 32-bit compatible.
* Hard-coded podule addresses removed (for Iyonix compatibility).
* Now builds as a driver module (SCSISoftWD33C93) for the new central
  SCSIdriver despatch system. Can revert to building a standalone driver
  by changing the "soft" switch in the sources.

Version 1.11. Tagged as 'SCSIDriver-1_11'
@
text
@d1988 1
a1988 1
        B err_Entryunkn
d4371 5
@


4.1
log
@Initial revision
@
text
@d46 1
a46 1
counts          SETL true
d50 1
a50 1
DString         SETS ""  
d71 6
d78 1
a78 1
testMEMC        SETL true
d86 1
a86 1
 [ doAssertATN
d101 6
d165 2
d173 2
a174 1
        GET Hdr:File ; dar 24/10/91 - needed for newerrors
d177 1
a177 1
        GET Hdr:NewSpace
d183 1
d199 1
a199 1
DeviceIDMask    EQU 3
d384 1
a384 1
; 
d402 1
a402 1
PE                      EQU &02 ;Parity Error 
d412 1
a412 1
;EHP            EQU &10         ;Enable Host Parity  
d420 1
a420 1
DPD             EQU &40         ;Data Phase Direction, set for DataIn expected 
d564 1
a564 1
;   queued. If there is furthur data to transfer and a page can be claimed
d614 3
d618 1
d717 1
d724 1
d865 1
a865 1
; Internally the device driver always runs SCSI transfers as background tasks 
d904 9
d1037 8
a1044 1
$label  JoinHWords $dst,$lo,$hi
d1047 3
d1061 3
d1072 2
a1073 1
$label  RevBytes $arm, $t1,$t2
d1075 1
d1090 1
d1094 3
d1108 1
d1112 3
d1129 1
d1134 5
d1150 1
d1155 5
d1164 33
d1198 72
d1338 33
a1379 2
        LEADR Module_LoadAddr

d1383 1
a1383 1
                                           
d1392 6
d1402 4
a1405 3
        DCD 0                 ; 28 SWI Decoding code
        DCD 0
        DCD 0
d1408 9
d1424 1
d1435 8
d1461 1
a1461 1
        ENTRY
d1532 1
a1532 1
        BLT Devices_Co_30       
d1542 1
a1542 1
; 
d1546 1
a1546 1
; 
d1549 1
a1549 1
; Device Type              Capacity    Vendor   Product          Revision   
d1551 2
a1552 2
; 
; 
d1576 1
d1592 2
d1629 2
a1630 2
        DCD TextScanner      - DeviceTypeDecodeTab      ;&06       
        DCD TextOptical      - DeviceTypeDecodeTab      ;&07       
d1659 1
d1695 1
a1695 1
        CMP R11,#Podule0SlowAccess      ;Loaded from a podule,
d1708 8
a1715 6
        SUBS R0,R0,#"0"         ;Accept "0".."3",
        MOVLT R0,#0             ; assume anything else ("4".."9",non-digit
        CMP R0,#3               ; or unspecified is podule zero).
        MOVGT R0,#0             ;
        MOV R11,#Podule0SlowAccess
        ADD R11,R11,R0,LSL #14
d1717 1
a1717 1
; R11 holds the podule base address
d1724 2
a1725 1
        BIC R11,R11,#PoduleSpeedMask    ;Reduce to slow access address
d1790 3
d1798 1
a1798 1
        XError SCSI_NoRoom
d1801 1
a1801 1
        MakeErrorBlock SCSI_NoRoom      ;"No room for SCSI driver workspace"
d1809 1
a1809 1
        XError SCSI_WrongMEMC                   ; then return VS & R0->error
d1812 1
a1812 1
        MakeErrorBlock SCSI_WrongMEMC ;"SCSI requires MEMC1a - see your dealer"
d1836 4
a1839 1
 
d1842 32
a1873 1
        Pull "R7-R11,PC",AL,^
d1883 1
a1883 1
;   R12 -> private word 
d1896 9
d1906 1
d1909 1
a1909 1
        MOVNES PC,Link
d1911 1
d1934 1
a1934 1
        Pull "R0-R11,PC",AL,^
d1948 4
a1951 1
        Pull "R0-R11,PC",AL,^
d1959 49
d2074 1
a2074 1
        XError SCSI_SWIunkn
d2077 1
a2077 1
        MakeErrorBlock SCSI_SWIunkn     ;"Unknown SCSI SWI number"
d2082 2
a2083 1
        Push "R0-R3"
d2197 3
a2199 2
        STR R0, [R3, #0]         
        Pull "R0-R3"
d2204 5
a2209 1
        mess ,"SCSI_SWIdecode - Exit", NL
d2286 1
a2286 1
        XError SCSI_RCunkn
d2289 3
a2291 1
        MakeErrorBlock SCSI_RCunkn      ;"Unknown reason code for SCSI SWI"
d2313 4
d2327 1
a2327 1
        XError SCSI_BadHostID
d2330 1
a2330 1
        MakeErrorBlock SCSI_BadHostID   ;"Invalid host ID"
d2354 1
d2357 1
d2376 1
a2376 1
        XError SCSI_NoDevice
d2379 1
a2379 1
        MakeErrorBlock SCSI_NoDevice    ;"No hardware at this ID"
d2454 1
a2454 1
        RevBytes R6, R7,R8      ; and block length to normal ARM byte sex
d2561 2
d2625 1
a2625 1
;         9       RMB & Device-type qualifier     
d2629 1
a2629 1
;         13..15 
d2695 6
d2705 1
d2773 119
d2968 1
a2968 1
        RevBytes R2, R3,R4      ;     If inquiry is successful, this can be
d2992 1
a2992 1
; =========            
d3010 1
d3012 4
d3041 1
d3044 6
d3055 1
a3055 1
; ========            
d3061 1
a3061 1
;   
d3068 4
d3081 1
d3083 5
d3210 1
d3305 1
a3305 1
; Control behaviour of the command queue 
d3317 1
a3317 1
;                                    immediatly. 
d3598 1
a3598 1
        CMPEQ R4,#0             ; or claiment has no release address,
d3606 1
a3606 1
;        
d3616 1
a3616 1
        BVC ClaimDevice         ;VC, so should be free, so ClaimDevice 
d3644 1
d3673 1
a3673 1
;                    b7..b6    LUN                      }
d3724 1
a3724 1
        
d3737 1
a3737 1
 [ counts       
d3754 1
a3754 1
 
d3822 1
a3822 1
        XError SCSI_ParmError
d3825 1
a3825 1
        MakeErrorBlock SCSI_ParmError   ;"Parameter error"
d3832 1
d3853 3
d3857 1
a3857 1
        MOVS PC,Link
d3871 1
a3871 1
        MOVS PC,Link
d3881 1
a3881 1
        MOVS PC,Link
d3891 1
a3891 1
        MOVS PC,Link
d3911 9
d3932 1
a3932 2
        Pull "R1,R2,PC",AL,^

d3952 3
d3956 1
d3965 1
d3968 3
d4031 1
a4031 1
        Pull "R0,R1,rDEVICEptr,PC",AL,^
d4059 1
d4066 1
d4069 1
a4069 1
        MOVS PC,Link
d4074 1
a4074 1
;   R1 = HostID 
d4092 3
d4145 5
d4154 3
d4164 3
d4168 2
a4169 2
        Pull "R0,R1,Link"
        BICS PC,Link,#V_bit
d4173 2
a4174 2
        XError SCSI_BadReset
        ORRS PC,Link,#V_bit
d4176 1
a4176 1
        MakeErrorBlock SCSI_BadReset    ;"SCSI bus failed to reset"
d4189 1
a4189 1
        SWI OS_ClaimDeviceVector 
d4191 10
d4203 5
d4212 1
d4216 4
d4221 1
a4221 1
        Pull "R0-R4,PC",AL,^
d4233 1
a4233 1
        SWI XOS_ReleaseDeviceVector 
d4235 2
a4236 1
        Pull "R0-R4,PC",AL,^
d4247 1
a4247 1
        Pull "R0-R2,PC",AL,^
d4257 1
a4257 1
        Pull "R0-R2,PC",AL,^
d4267 1
d4270 3
d4275 1
a4275 1
        Pull "R0-R4,PC",AL,^
d4315 1
a4315 1
        BICNES PC,Link,#V_bit
d4317 2
a4318 2
        XError SCSI_BadDevID
        ORR PC,Link,#V_bit
d4320 1
a4320 1
        MakeErrorBlock SCSI_BadDevID    ;"Invalid device ID"
d4335 1
a4335 1
        MUL R9,R1,R9
d4338 1
a4338 2
        ADD R9,R9,WsPtr                 ;Absolute address of Control block
        MOVS PC,Link
d4341 1
d4362 1
a4362 6
        BICEQS PC,Link,#V_bit   ;Not reserved, or reserved and key fits

        XError SCSI_DevReserved
        ORR PC,Link,#V_bit

        MakeErrorBlock SCSI_DevReserved ;"SCSI driver reservation error"
d4364 2
d4367 2
d4370 28
d4428 1
a4428 1
 [ trace                    
a4438 1
        BIC Link,Link,#V_bit
d4440 1
d4443 2
a4444 1
        EnableIRQs              ;To give queued commands a chance to run
d4474 1
d4483 1
d4488 4
d4493 1
d4497 4
d4503 1
d4516 1
d4519 1
d4539 3
d4557 1
d4565 1
d4592 1
a4592 1
        TSTEQ R0,#CTL_DOINGESCAPEDEVICE 
a4607 1
        ADR R0,CallBkR0
d4616 2
a4617 2
        Pull "R0-R2,Link",EQ
        ORREQS PC,Link,#V_bit
d4620 6
a4625 1
        Pull "R0-R2,PC",AL,^
d4630 7
a4636 2
        Pull "R0-R2,Link"
        ORRS PC,Link,#V_bit
d4638 1
d4646 1
a4646 1
        XError SCSI_QueueNotEmpty
d4655 1
a4655 1
        XError SCSI_NotIdle
d4664 1
a4664 1
        XError SCSI_QueueFull
d4668 2
a4669 2
        MakeErrorBlock SCSI_QueueNotEmpty
        MakeErrorBlock SCSI_QueueFull
d4672 1
a4672 1
        XError SCSI_NotIdle
d4675 3
a4677 1
        MakeErrorBlock SCSI_NotIdle     ;"Device not idle"
d4705 3
a4707 1
        Pull "R0,PC",AL,^
d4741 1
a4741 1
        MOVS PC,Link
d4797 9
a4805 2
        DisableIRQs
 
d4831 2
d4848 5
a4852 1

a4860 1
        ASSERT ((CmdXferLen + 4) = CmdTimeout)
d4868 1
a4868 1

d4875 3
a4877 1

d4883 1
d4888 1
d4891 1
d4934 1
a4934 1
 ] 
d4984 1
d5028 1
a5028 1
        BL WriteBlkToSRAM       ;Write block to SRAM. In R8->Slot 
d5031 1
a5031 1
        LDR R0,CurrTtlCnt           ;If no more data to copy, 
d5041 1
a5041 1
; block as INITIALISED. Try to Load the command into the SBIC & perform a 
d5048 1
d5093 1
a5093 1
        BL LoadCDBregisters     ;In R5=CpyCtl, corrupts R0,R2,R3 
d5141 4
a5144 1
        Pull "R0-R11,PC",AL,^
d5185 3
d5292 1
a5292 1
; 
d5300 3
a5302 3
        LDR R0,DMACStat                         ;>>>>>
        CMP R0,#STALLED                         ;>>>>>
        BNE int_TC_wr_25                        ;>>>>> so branch never executes - should be BNE int_TC_wr_30???
d5319 1
a5319 1
        BNE int_TC_wr_30        ; finishs, it will see the stalled DMAC and 
d5352 1
a5352 1
;  to call PreWriteBlk or UnQueue until something suitable arrives. 
d5354 1
a5354 1
; The normal cause of a mismatch between data wanted and data avaiable is the
d5360 1
a5360 1
;>>> 
d5362 1
a5362 1
;>>> RamTxAdr..(RamTxAdr+RamBlkSz) 
d5394 1
a5394 2
        Pull "R0-R11,Link"      ;>>>Overkill
        MOVS PC,Link
d5422 1
a5422 1
        BNE int_TC_wr_30        ; finishs, it will see the stalled DMAC and 
d5453 1
a5453 1
;  to call PreWriteBlk or UnQueue until something suitable arrives. 
d5461 1
a5461 1
;>>> 
d5463 1
a5463 1
;>>> RamTxAdr..(RamTxAdr+RamBlkSz) 
d5497 1
a5497 1
        MOVS PC,Link
d5827 1
a5827 1
; 
d5843 1
a5843 1
 
d5928 2
a5929 2
        BLEQ SaveCurrentPointers_UseHold        ; to get the message, SR_Count
        BEQ int_ser_43                          ; is invalid
d5966 1
a5966 1
 [ rejectnaffmessages 
d6017 1
a6017 1
; This will cause us to send a MESSAGE_REJECT later on. 
d6037 1
a6037 1
; &21 - A Save Data Pointers message has been received whilst executing 
d6055 1
a6055 1
; 
d6093 1
a6093 1
 [ bugfix5 
d6118 1
a6118 1
; Of course, if we find a device that doesn't break the spec. and expects  
d6130 1
a6130 1
 [ bugfix5 
d6186 1
a6186 1
 [ bugfix5 
d6200 1
a6200 1
; 
d6203 1
a6203 1
        rdSBIC R2,SR_Data       ; its LUN 
d6272 1
a6272 1
        BL LoadCDBregisters     ;In R5=CpyCtl, corrupts R0,R2,R3 
d6310 1
a6310 1
; 
d6335 1
d6338 1
d6344 3
a6346 3
 LDR R3,CpyAdr
 LDR R4,CmdXferPtr
 CMP R3,R4
d6349 3
a6351 3
 LDR R3,CpyCnt
 LDR R4,CmdXferLen
 CMP R3,R4
d6363 7
a6369 4
        BLEQ CheckForRetry              ;Returns if CTL_RETRYONTIMEOUT is clear
        ADREQ R0,ErrorBlock_SCSI_Timeout
        BEQ do_callback_clrR1R2        ; so report error

d6371 6
a6376 3
        BLEQ CheckForRetry              ;Returns if CTL_RETRYONTIMEOUT is clear
        ADREQ R0,ErrorBlock_SCSI_Timeout2
        BEQ do_callback_clrR1R2         ;Report error
d6378 1
a6378 1
        CMP R1,#TARGET_ESCAPED
d6383 1
a6383 1
        ADREQ R0,ErrorBlock_SCSI_AbortOp
d6391 1
a6391 1
        ADREQ R0,ErrorBlock_SCSI_Died
d6397 4
d6404 1
a6404 1
        BEQ do_callback         ;Command complete, status GOOD  
d6407 2
a6408 1
        BLEQ CheckAutoRequest   ;Returns if CTL_INHIBITREQUESTSENSE is set
d6410 2
a6411 2
        ADREQ R0,ErrorBlock_SCSI_CheckCondition
        BEQ do_callback         ;Report error
d6413 3
a6415 3
        CMP R0,#TARGET_BUSY
        ADREQ R0,ErrorBlock_SCSI_Busy
        ADRNE R0,ErrorBlock_SCSI_StatusUnkn
d6417 1
d6420 1
a6420 1

d6431 1
a6431 1
;        
d6445 1
a6445 1
        RevBytes R2, R3,R4      ;Deal with R2's sexual hangups 
d6462 1
a6462 1
;                      bytes 3..6 into R2 (byte sex reversed to suit ARM) 
d6493 1
a6493 1
        ADRL R0,ErrorBlock_SCSI_CC_UnKn
d6495 1
a6495 1
        ADR R0,ErrorBlock_SCSI_CC_UnKn
d6497 1
a6497 1
        B do_callback    
d6505 1
a6505 1
        ADRL R0,ErrorBlock_SCSI_CC_UnKn
d6507 1
a6507 1
        ADR R0,ErrorBlock_SCSI_CC_UnKn
d6510 1
d6515 4
d6521 1
d6536 3
d6550 1
a6550 3
; The CallbackAdr is masked to remove any psr bits (they should have been clear
; anyway) 
;
a6551 4
        BIC R5,R5,#ARM_CC_Mask
        ORR R5,R5,#(IRQ_mode :OR: I_bit)
        ORRNE R5,R5,#V_bit

d6554 1
d6564 1
d6587 1
d6589 4
a6592 1
        Pull "R0,R1,R2, R5"
d6594 6
d6601 1
a6601 1
        MOVS PC,R5
d6627 1
d6645 1
d6650 3
a6652 3

        MakeErrorBlock SCSI_Timeout
        MakeErrorBlock SCSI_Timeout2
d6654 8
a6661 2
        MakeErrorBlock SCSI_AbortOp
        MakeErrorBlock SCSI_Died
d6663 20
a6682 20
        MakeErrorBlock SCSI_CheckCondition
        MakeErrorBlock SCSI_Busy
        MakeErrorBlock SCSI_StatusUnkn

        MakeErrorBlock SCSI_CC_NoSense
        MakeErrorBlock SCSI_RecoveredError
        MakeErrorBlock SCSI_CC_NotReady
        MakeErrorBlock SCSI_CC_MediumError
        MakeErrorBlock SCSI_CC_HardwareError
        MakeErrorBlock SCSI_CC_IllegalRequest
        MakeErrorBlock SCSI_CC_UnitAttention
        MakeErrorBlock SCSI_CC_DataProtect
        MakeErrorBlock SCSI_CC_BlankCheck
        MakeErrorBlock SCSI_CC_VendorUnique
        MakeErrorBlock SCSI_CC_CopyAborted
        MakeErrorBlock SCSI_CC_AbortedCommand
        MakeErrorBlock SCSI_CC_Equal
        MakeErrorBlock SCSI_CC_VolumeOverflow
        MakeErrorBlock SCSI_CC_Miscompare
        MakeErrorBlock SCSI_CC_Reserved
d6684 1
a6684 1
        MakeErrorBlock SCSI_CC_UnKn
d6694 1
a6694 1
        Pull "R0,PC",EQ,^
d6705 1
d6710 1
a6710 1
        Pull "R0,PC",NE,^
d6740 1
a6740 1
        Pull "R0,PC",NE,^
d6754 1
d6777 4
d6787 1
d6817 1
a6817 1
        MOVS PC,Link
d6846 1
a6846 1
        BL WriteBlkToSRAM       ;Write block to SRAM. In R8->Slot 
d6849 1
a6849 1
        LDR R0,FutrTtlCnt       ;If no more data to copy, 
d6857 2
a6858 2
        Pull "R0,R1,Link"
        BICS PC,Link,#C_bit
d6876 1
a6876 1
        CMP      R0,#SC_Sel_Tx_withATN      
d6889 1
a6889 1
        Pull    "R0,R1,R2,R3,PC",AL,^
d6910 1
a6910 1
        Pull "R0,R1,PC",AL,^
d6917 1
a6917 1
        Pull "R0,R1,PC",AL,^
d6923 1
a6923 1
        MOVEQS PC,Link
d6927 1
a6927 1
        MOVS PC,Link
d6935 1
a6935 1
        Pull "R0,R1,R2,R3, PC",EQ,^     ;Command Phase non-zero,
d6971 1
a6971 1
        CMPNE R0,#SC_Sel_Tx_withATN      
d6981 1
a6981 1
        STR R0,HoldCmd          ; Resume-Select-And-Transfer 
d6994 1
a6994 1
;  if writing, stop DMAC and dispose of partially emptied slot 
d7004 6
a7009 5
        BLNE AdjustSlot                 ;In/Out R7->RamRec
        BLNE AdvanceCurrentPointers     ;In/Out R7->RamRec
        BLNE DeAllocateRAM              ;In     R7->RamRec
        BLNE FlushQueue

d7011 5
a7015 3
        BLNE AdjustSlot                 ;In/Out R7->RamRec
        BLNE AdvanceCurrentPointers     ;In/Out R7->RamRec
        BLNE QueueSlot                  ;In     R7->RamRec
d7038 1
a7038 1
;   WHEN read   : 
d7075 1
a7075 1
        Push "R7"               ;Preserve for later DeAllocate call
d7090 3
d7131 1
d7136 4
a7139 4
        JoinHWords R4,R4,R5     ;R4:=(R4 AND &FFFF) OR (R5<<16)
        JoinHWords R6,R6,R7
        JoinHWords R8,R8,R9
        JoinHWords R10,R10,R11
d7148 1
a7148 1
        JoinHWords R4,R4,R5
d7156 1
a7156 1
        JoinHWords R4,R4,R5
d7167 1
a7167 1
        Pull "R7"               ;Recover ->RamRec
d7178 1
a7178 1
        Pull "R0,PC",AL,^
d7205 1
a7205 1
; 
d7226 3
d7256 1
a7256 1
        Pull "R0,PC",AL,^
d7274 1
a7274 1
        MOVEQS PC,Link          ;No free slots, return 0
d7281 1
a7281 1
        DisableIRQs
d7285 4
a7288 1
        Pull "PC",EQ,^          ;No free slots, return 0, restore IRQ state
d7321 2
a7322 1
        Pull "R5,R6,PC",AL,^    ;Slot address in rCMDptr, restore IRQ state
d7346 1
a7346 1
        MOV rCMDptr,rCMDptr, LSL R0     ; bit mask for CmdMap 
d7350 1
a7350 1
        DisableIRQs
d7360 2
a7361 1
        Pull "R0,PC",AL,^       ;Return, restoring int state
d7381 1
a7381 1
        DisableIRQs                     ;Corrupts Link
d7383 1
a7383 1
        ADR R0,FirstCmd                 ;Pretend FirstCmd is a CmdNxt field 
d7393 2
a7394 1
        Pull "R0,R1,PC",AL,^            ;Return, restoring int state
d7412 1
a7412 1
        Push "R0,R1,R14"
d7414 2
a7415 2
        DisableIRQs                     ;Corrupts Link
        ADR R0,FirstCmd                 ;Pretend FirstCmd is a CmdNxt field 
d7430 2
a7431 1
        Pull "R0,R1,PC",AL,^            ;Return, restoring int state
d7453 1
a7453 1
;                  
d7495 1
a7495 1
        Pull "R0,R1,PC",AL,^
d7526 1
a7526 1
        Pull "R0,PC",AL,^
d7564 2
a7565 1
        ORRS PC,Link,#C_bit
d7578 2
a7579 1
        BICS PC,Link,#C_bit
d7594 2
a7595 1
        Push "R0,R1,R2"
d7600 1
a7600 1
 
d7605 2
a7606 2
        Pull "R0,R1,R2"
        MOVS PC,Link
d7618 1
a7618 1
        MOVS PC,Link
d7685 2
a7686 2
        MOVS PC,Link
           
d7722 1
a7722 1
        MOVS PC,Link
d7781 1
a7781 1
        Pull "R0-R3"            
d7791 1
a7791 1
        Pull "R0-R3"            
d7795 2
a7796 2
 
        Pull "R0-R4,R7,PC",AL,^
d7879 1
a7879 1
        Pull "R0-R4,PC",AL,^
d7913 1
a7913 1
        MOVS PC,Link
d7936 1
a7936 1
        MOVS PC,Link
d7960 1
a7960 1
        MOVS    PC, Link
d7978 1
a7978 2
        Pull    "R0,R1,Link"
        MOVS    PC,Link
d8002 1
a8002 1
       
d8004 1
a8004 1
 ] 
d8048 1
a8048 1
        MOVS PC,Link
d8066 2
d8082 1
a8082 1

d8106 1
a8106 1
        MOVEQS PC,Link                  ;Escape not pressed, so return
d8112 1
a8112 1
        Pull "R0,R1,R2,PC",AL,^
d8123 1
a8123 1
        Push "R0-R2,rCMDptr,rDEVICEptr,Link"
d8125 1
a8125 1
        DisableIRQs2 R0
d8149 1
a8149 1
        LDR R0,Connected     
d8177 2
a8178 1
        Pull "R0-R2,rCMDptr,rDEVICEptr,PC",AL,^ ;Restores IRQ state
a8188 3
        TEQP PC,#I_bit+IRQ_mode ;Disable IRQs
        NOP

d8194 1
a8194 1
        LDR R0,DeviStat         ;Quit if not yet, or just finished 
d8216 1
a8216 1
        Pull "R0-R2,R8-R11,PC",AL,^
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

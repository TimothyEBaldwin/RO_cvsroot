head	4.6;
access;
symbols
	IIC-0_18-4_5_2_13:4.4.2.11
	IIC-0_18-4_5_2_12:4.4.2.10
	IIC-0_18-4_5_2_11:4.4.2.9
	IIC-0_18-4_5_2_10:4.4.2.8
	IIC-0_18-4_5_2_9:4.4.2.7
	IIC-0_18-4_5_2_8:4.4.2.6
	IIC-0_18-4_5_2_7:4.4.2.5
	IIC-0_18-4_5_2_6:4.4.2.4
	IIC-0_21:4.6
	RO_5_07:4.4.2.3
	IIC-0_20:4.5
	IIC-0_18-4_5_2_5:4.4.2.3
	IIC-0_18-4_5_2_4:4.4.2.3
	IIC-0_19:4.4
	IIC-0_18-4_5_2_3:4.4.2.2
	IIC-0_18-4_5_2_2:4.4.2.2
	IIC-0_18-4_5_2_1:4.4.2.1
	HAL:4.4.0.2
	dellis_autobuild_BaseSW:4.4
	IIC-0_18:4.4
	IIC-0_17:4.4
	sbrodie_sedwards_16Mar2000:4.3
	IIC-0_16:4.3
	dcotton_Ursula_merge:4.1
	IIC-0_15:4.2
	dcotton_autobuild_BaseSW:4.4
	nturton_IIC-0_14:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_IIC_0_14:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2011.03.14.23.37.40;	author srevill;	state Exp;
branches;
next	4.5;
commitid	ZeEryf65mFaabSbv;

4.5
date	2004.07.31.19.47.19;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2000.08.01.14.25.31;	author bavison;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	2000.02.04.16.30.04;	author dcotton;	state Exp;
branches;
next	4.2;

4.2
date	99.11.12.10.18.35;	author dcotton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.35.58;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	2001.03.07.16.08.45;	author kbracey;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2001.05.10.17.11.16;	author kbracey;	state Exp;
branches;
next	4.4.2.3;

4.4.2.3
date	2003.11.13.18.41.01;	author bavison;	state Exp;
branches;
next	4.4.2.4;

4.4.2.4
date	2011.08.04.21.41.00;	author jlee;	state Exp;
branches;
next	4.4.2.5;
commitid	cl7UCasB3Vq9Weuv;

4.4.2.5
date	2012.01.01.10.11.47;	author rsprowson;	state Exp;
branches;
next	4.4.2.6;
commitid	o9VplwBOZXnMisNv;

4.4.2.6
date	2012.11.27.23.07.00;	author jlee;	state Exp;
branches;
next	4.4.2.7;
commitid	I3dcrxhqydz4X3uw;

4.4.2.7
date	2016.10.19.07.39.17;	author rsprowson;	state Exp;
branches;
next	4.4.2.8;
commitid	EOqnaVL5mNeU6Jqz;

4.4.2.8
date	2016.10.19.07.42.25;	author rsprowson;	state Exp;
branches;
next	4.4.2.9;
commitid	XN457QNs7eDZ7Jqz;

4.4.2.9
date	2016.10.19.07.44.38;	author rsprowson;	state Exp;
branches;
next	4.4.2.10;
commitid	8RK0vyHtcGnK8Jqz;

4.4.2.10
date	2017.02.02.20.58.50;	author rsprowson;	state Exp;
branches;
next	4.4.2.11;
commitid	ZhO9h92GaH7W7qEz;

4.4.2.11
date	2017.02.02.21.01.52;	author rsprowson;	state Exp;
branches;
next	;
commitid	qKj8ctRomno09qEz;

4.1.1.1
date	96.11.05.09.35.58;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.25.39;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.52.20;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.46.58;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Fixed some code which could have unpredictable behaviour on 26 bit ARMs.

Version 0.21. Tagged as 'IIC-0_21'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > adfs::TimSource.!IIC.IICMod

; *********************************
; ***    C h a n g e   L i s t  ***
; *********************************

; Date          Description
; ----          -----------
; 11-Mar-88     Started
; 15-Mar-88     Disable IRQs around SetC1C0 (uses IOCControlSoftCopy)
; 15-Mar-88     Added code to check for clock syncronisation
; 23-Nov-89     Added 'GET <Hdr>.File' so it assembles again
;               - no change to object
; 08-Jul-91     Look up messages in messages file
; 23-Apr-92 0.11 LRust,SWI errors no longer corrupt R1
;                 * Fixes to IIC transations for BMU
; 28-Apr-92 0.12 LRust, RxByte disables interupts for BMU
; 18-May-92 0.13 TMD - put bodges in for BMU, so interrupt latency isn't awful

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:Proc
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:MsgTrans
        GET     Hdr:IIC
	GET	VersionASM

                GBLL    ReentrancyCheck
ReentrancyCheck SETL    {TRUE}                          ; Harmless if you don't need it

                GBLL    KernelDoesIIC
KernelDoesIIC   SETL    {TRUE} :LAND: ReentrancyCheck   ; Until the kernel's IIC support is farmed out

 ^ ErrorNumber_IIC_NoAcknowledge      ; The nearest thing we have to a defined error base
 # 1  ; AddError2 IIC_NoAcknowledge,    "No acknowledge from IIC device"
        AddError2 IIC_InUse,            "IIC operation in progress"

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

IOCControlSoftCopy * &106       ; Address of soft copy of IOC control register
 [ KernelDoesIIC
IRQsema                         * &108  ; Address of IRQ semaphore
KernelVersion_STB22             * &45200
KernelVersion_STB3              * &47100
KernelVersion_STB400            * &53000
KernelVersion_32bitIRQStack     * &48100 ; trunk versions: beware desktop OS builders!
 ]

; Module workspace allocation

        ^ 0, R12

MessageFile_Block # 16
MessageFile_Open  # 4
IRQDisableFlag  # 4             ; 0 if we're talking to Alex, otherwise I_bit
 [ ReentrancyCheck
IICSWIThreaded  # 4
   [ KernelDoesIIC
KernelIICStart  # 4
KernelIICEnd    # 4
KernelIRQStackFlag # 4          ; negative if ARM2/3 style IRQ stack
   ]
 ]

IIC_WorkspaceSize * :INDEX: @@

; **************** Module code starts here **********************

        AREA    |IIC$Code|, CODE, READONLY, PIC

Module_BaseAddr

        DCD     0
        DCD     IIC_Init    -Module_BaseAddr
        DCD     IIC_Die     -Module_BaseAddr
        DCD     IIC_Service -Module_BaseAddr
        DCD     IIC_Title   -Module_BaseAddr
        DCD     IIC_HelpStr -Module_BaseAddr
        DCD     IIC_HC_Table-Module_BaseAddr
        DCD     IICSWI * Module_SWIChunkSize
        DCD     IIC_SWIHandler-Module_BaseAddr
        DCD     IIC_SWINameTable-Module_BaseAddr
        DCD     0 ; Code to manually decode swi name (not needed)
        DCD     0 ; No messages file
        DCD     IIC_ModFlags-Module_BaseAddr

IIC_SWINameTable
IIC_Title
        =       "IIC", 0
        =       "Control", 0
        =       0

IIC_HelpStr =       "IIC",TAB, TAB,"$Module_MajorVersion ($Module_Date)", 0
        ALIGN

IIC_ModFlags
      [ No26bitCode
        &       ModuleFlag_32bit
      |
        &       0
      ]

; *****************************************************************************

IIC_HC_Table * Module_BaseAddr

IIC_Service * Module_BaseAddr

IIC_Init
        STMDB   sp!, {lr}

        LDR     r2, [r12]               ; Hard or soft init ?
        TEQ     r2, #0
        BNE     %FT00

; Hard init

        LDR     r3, =IIC_WorkspaceSize
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        LDMVSIA sp!, {pc}

        STR     r2, [r12]

00      MOV     r12, r2

        MOV     r14, #0
        STR     r14, MessageFile_Open

    [ ReentrancyCheck
        STR     r14, IICSWIThreaded
      [ KernelDoesIIC
        MOV     r0, #ModHandReason_LookupName
        ADR     r1, UtilityModuleString
        SWI     XOS_Module
        LDR     r0, [r3, #Module_HelpStr]
        ADD     r0, r0, r3
        BL      GetVerNoFromHelpString
        MOV     r2, #0          ; emergency defaults
        MOV     r3, #0          ; (lr=0 shouldn't appear on the IRQ stack)
        LDR     r0, =KernelVersion_STB22
        TEQ     r1, r0
        ADREQ   lr, KernelAddresses_STB22
        LDMEQIA lr, {r2, r3}
        LDR     r0, =KernelVersion_STB3
        TEQ     r1, r0
        ADREQ   lr, KernelAddresses_STB3
        LDMEQIA lr, {r2, r3}
        LDR     r0, =KernelVersion_STB400
        TEQ     r1, r0
        ADREQ   lr, KernelAddresses_STB400
        LDMEQIA lr, {r2, r3}
        ADR     lr, KernelIICStart
        ASSERT  :INDEX: KernelIICEnd = :INDEX: KernelIICStart + 4
        STMIA   lr, {r2, r3}
        LDR     r0, =KernelVersion_32bitIRQStack
        SUB     r0, r1, r0
        STR     r0, KernelIRQStackFlag
        CLRV
      ]
    ]
        LDMIA   sp!, {pc}

IIC_Die STMDB   sp!, {lr}
        LDR     r12, [r12]
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        ADRNE   r0, MessageFile_Block
        SWINE   XMessageTrans_CloseFile
        CLRV
        LDMIA   sp!, {pc}

 [ KernelDoesIIC

UtilityModuleString
        =       "UtilityModule", 0
        ALIGN

KernelAddresses_STB22
        &       &03828A4C, &0382900C ; first (incl) and last (excl) addresses to trap
KernelAddresses_STB3
        &       &0382A808, &0382B334 ; first (incl) and last (excl) addresses to trap
KernelAddresses_STB400
        &       &0382C2FC, &0382CE68 ; first (incl) and last (excl) addresses to trap

        LTORG

; *************************************************************************
;
;       RMEGetVerNo - Read version number from a string
;
; in:   R0 -> string
;
; out:  R0, R4, R5, R12 corrupted
;       R1 = version number in BCD with the decimal point between bits 15 and 16
;            eg "2.34" => &00023400, "5.6789" => &00056789, "17" => &00170000
;            only the last 4 digits of the integer part, and the first 4 decimal places are stored
;

RMEGetVerNo Entry
        MOV     r1, #0
10
        LDRB    r12, [r0], #1
        CMP     r12, #" "
        BEQ     %BT10
11
        SUB     r12, r12, #"0"
        CMP     r12, #9
        ORRLS   r1, r12, r1, LSL #4             ; just keep nibbles - we only need the
        LDRLSB  r12, [r0], #1                   ; result to be ordered, not continous
        BLS     %BT11
        MOV     r5, #0
        CMP     r12, #"."-"0"
        BNE     %FT13
        MOV     r4, #16
12
        SUBS    r4, r4, #4
        BMI     %FT13
        LDRB    r12, [r0], #1
        SUB     r12, r12, #"0"
        CMP     r12, #9
        ORRLS   r5, r5, r12, LSL r4
        BLS     %BT12
13
        ORR     r1, r5, r1, LSL #16
        EXIT

; *************************************************************************
;
;       GetVerNoFromHelpString - Read version number from a module help string
;
; in:   R0 -> module help string
;
; out:  R1 = version number in BCD with the decimal point between bits 15 and 16
;            eg "2.34" => &00023400, "5.6789" => &00056789, "17" => &00170000
;            only the last 4 digits of the integer part, and the first 4 decimal places are stored
;       All other registers preserved
;

GetVerNoFromHelpString Entry "r0, r4, r5, r12"
        MOV     r5, #0                          ; char count
10
        LDRB    r1, [r0], #1
        CMP     r1, #0                          ; check character
        EXIT    EQ                              ; if end of string then no version number so return zero
        ADD     r5, r5, #1
        CMP     r1, #TAB
        ADDEQ   r5, r5, #7
        BICEQ   r5, r5, #7
        CMP     r5, #16                         ; hit verno col yet?
        BLT     %BT10
20
        LDRB    r1, [r0], #1
        CMP     r1, #TAB
        CMPNE   r1, #31                         ; if a control character (except TAB)
        MOVLT   r1, #0                          ; then no version number so return zero
        EXIT    LT
        SUB     r1, r1, #"0"
        CMP     r1, #9                          ; if not a digit
        BHI     %BT20                           ; then try next character
        SUB     r0, r0, #1                      ; was a digit so go back to it
        BL      RMEGetVerNo                     ; read version number from here
        EXIT

 ]

; *****************************************************************************
;
;       IIC_SWIHandler - Handler for my SWIs
;
; in:   R11 = SWINumber MOD 64 (only 0 is recognised)
;       R0 = device address (bit 0 set => read, clear => write)
;       R1 -> data block
;       R2 = length of data block
;
; out:  R10-R12 may be corrupted

IIC_SWIHandler ROUT
        LDR     r12, [r12]
        MOV     R10, LR
        TEQ     R11, #0                 ; we only have one SWI
        BNE     ReturnNoSuchSWIError

    [ ReentrancyCheck
      [ KernelDoesIIC
        Push    "R0-R2,R14"
        ADR     R14, KernelIICStart
        ASSERT  :INDEX: KernelIICEnd = :INDEX: KernelIICStart + 4
        LDMIA   R14, {R0, R1}
        SCPSR   I_bit, 0, R14,, R2      ; disable IRQs while we navigate the IRQ stack
        MOV     R11, #IRQsema
inspect_IRQ_stack
        LDR     R11, [R11]
        CMP     R11, #0
        BEQ     iis_end
        LDR     R14, KernelIRQStackFlag
        TEQ     R14, #0
        LDRMI   R14, [R11, #4*7]        ; get return lr from stack (pushed on ARM2/3, else 26-bit PSR
        BICMI   R14, R14, #ARM_CC_Mask  ; is mangled in by the kernel, and which we have to strip away)
        LDRPL   R14, [R11, #4*8]        ; get pushed lr from stack (no flag bits to worry about)
        CMP     R14, R0
        CMPGE   R1, R14
        BLT     inspect_IRQ_stack       ; try the next IRQ out, in case of IRQ re-entrancy

        ; Kernel IIC code is threaded!
        ; Can't easily do a OS_Heap type trick, so just report an error instead
        RestPSR R2,, cf
        Pull    "R0-R2,R14"
        B       ReturnIICInUseError

iis_end
        RestPSR R2,, cf
        Pull    "R0-R2,R14"
      ]
        LDR     R11, IICSWIThreaded
        TEQ     R11, #0
        BNE     ReturnIICInUseError
        MOV     R11, #1
        STR     R11, IICSWIThreaded
    ]

        Push    R14
        LDR     lr, IRQDisableFlag      ; save IRQ disable flag around operations
        Push    "lr"

        BIC     r11, r0, #1             ; r11 = address without R/W bit
        EORS    lr, r11, #IICAddress_AcornBMUMicrocontroller    ; lr = 0 if we're talking to the BMU
        EORNES  lr, r11, #IICAddress_AcornBMUMicrocontroller2
 [ No26bitCode
        MOVNE   lr, #I32_bit
 |
        MOVNE   lr, #I_bit
 ]
        STR     lr, IRQDisableFlag      ; 0 if talking to BMU, else I_bit

        BL      Start
        BL      TXCheckAck              ; transmit device address

        MOV     R11, R1
        MOVS    R10, R2
        BEQ     %FT30

        TST     R0, #1                  ; Z => write, NZ => read
        BNE     %FT20
10
        LDRB    R0, [R11], #1           ; read byte from data block
        BL      TXCheckAck              ; transmit, checking for ack
        SUBS    R10, R10, #1            ; decrement byte count
        BNE     %BT10                   ; loop until finished
        BEQ     %FT30                   ; then stop

20
        BL      RXByte                  ; read byte from bus
        STRB    R0, [R11], #1           ; store in data block
        SUBS    R10, R10, #1            ; is it last byte ?
        MOVNE   R0, #0                  ; no, then acknowledge with 0 bit
        MOVEQ   R0, #1                  ; yes, then don't acknowledge
        BL      ClockData               ; but always send ack clock pulse
        BNE     %BT20
30
        BL      Stop
        Pull    "lr"
        STR     lr, IRQDisableFlag      ; restore IRQ disable flag
      [ ReentrancyCheck
        MOV     R11, #0
        STR     R11, IICSWIThreaded
      ]
        Pull    R14
        CMP     PC, PC                  ; also clears V in 32-bit modes
        MOVEQ   PC, R14                 ; 32-bit exit: NZC corrupted
        BICS    PC, R14, #V_bit         ; 26-bit exit: NZC preserved

TXCheckAck ROUT
        Push    R14
        BL      TXByte
        BL      Acknowledge
        Pull    R14
        MOVVC   PC, R14                 ; acknowledged ok, so return

        BL      Stop                    ; error, so tidy up
        ADR     R0, ErrorBlock_IIC_NoAcknowledge
        MOV     R11, #0
        BL      CopyError               ; sets V
        Pull    "lr"
        STR     lr, IRQDisableFlag      ; restore IRQ disable flag
      [ ReentrancyCheck
;       MOV     R11, #0
        STR     R11, IICSWIThreaded
      ]
        Pull    R14                     ; pull real return address
        TEQ     PC, PC
        MOVEQ   PC, R14                 ; 32-bit exit: NZC corrupted
        ORRS    PC, R14, #V_bit         ; 26-bit exit: NZC preserved

ReturnNoSuchSWIError
        ADR     R0, ErrorBlock_NoSuchSWI
        ADR     R11, IIC_Title
        BL      CopyError               ; sets V
        TEQ     PC, PC
        MOVEQ   PC, R10                 ; 32-bit exit: NZC corrupted
        ORRS    PC, R10, #V_bit         ; 26-bit exit: NZC preserved

      [ ReentrancyCheck
ReturnIICInUseError
        ADR     R0, ErrorBlock_IIC_InUse
        MOV     R11, #0
        BL      CopyError               ; sets V
        TEQ     PC, PC
        MOVEQ   PC, R10                 ; 32-bit exit: NZC corrupted
        ORRS    PC, R10, #V_bit         ; 26-bit exit: NZC preserved
      ]

        MakeInternatErrorBlock NoSuchSWI,,BadSWI
        MakeInternatErrorBlock IIC_NoAcknowledge,,NoAck
      [ ReentrancyCheck
        MakeInternatErrorBlock IIC_InUse,,InUse
      ]

; *****************************************************************************
;
;       SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
;
; out:  All registers preserved, including PSR
;

SetC1C0 ROUT
 [ No26bitCode
        Push    "R0-R3,R14"
        MRS     R3, CPSR
        TEQ     PC, #0                          ; set NE
 |
        Push    "R0-R2,R14"
        BIC     R14, R14, #Z_bit                ; indicate not checking clock
 ]
SetOrCheck
 [ No26bitCode
        ORR     R14, R3, #I32_bit               ; disable interrupts round access to IOCControlSoftCopy
        MSR     CPSR_c, R14                     ; preserves Z flag
 |
        ORR     R14, R14, #I_bit                ; disable interrupts round access to IOCControlSoftCopy
        TEQP    R14, #0
 ]

        ADD     R0, R0, R1, LSL #1              ; R0 := C0 + C1*2

        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy
        BIC     R1, R1, #&03                    ; clear clock and data
        ORR     R1, R1, R0                      ; put in new clock and data
        ORR     R1, R1, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R1, [R2, #IOCControlSoftCopy]   ; store back to soft copy

        MOV     R2, #IOC
        STRB    R1, [R2, #IOCControl]
10
        LDREQB  R1, [R2, #IOCControl]           ; if EQ, then wait for clock
        TSTEQ   R1, #i2c_clock_bit              ; to read high
        BNE     %FT30                           ; if not checking, or it went high straight away, skip

 [ No26bitCode
        MOV     lr, R3                          ; lr = original CPSR
 |
        LDR     lr, [sp, #3*4]                  ; reload original lr
 ]
        LDR     r1, IRQDisableFlag
        ORR     lr, lr, r1
 [ No26bitCode
        MSR     CPSR_c, lr                      ; restore IRQs if we're talking to BMU
 |
        TEQP    lr, #0                          ; restore IRQs if we're talking to BMU
 ]

20
        LDRB    R1, [R2, #IOCControl]           ; now wait for clock to go high
        TST     R1, #i2c_clock_bit
        BEQ     %BT20

30
        MOV     R0, #10                         ; delay for >= 10/2 microsecs
        BL      DoMicroDelay

 [ No26bitCode
        MSR     CPSR_cf, R3
        Pull    "R0-R3,PC"
 |
        Pull    "R0-R2,PC",,^
 ]

; Set clock and data lines to R1 and R0 and then wait for clock to be high

SetC1C0CheckClock ROUT
 [ No26bitCode
        Push    "R0-R3,R14"
        MRS     R3, CPSR
        TEQ     R0, R0                          ; set EQ
 |
        Push    "R0-R2,R14"
        ORR     R14, R14, #Z_bit                ; indicate checking clock
 ]
        B       SetOrCheck


; *****************************************************************************
;
;       DoMicroDelay - Delay for >= R0/2 microseconds
;
; in:   R0 = time delay in 1/2 microsecond units
;       R2 -> IOC
;
; out:  R0,R1 corrupted
;

DoMicroDelay ROUT
        Push    R14
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R14, [R2, #Timer0CL]    ; R14 := low output latch
        TEQ     R14, R1                 ; unchanged ?
        MOVNE   R1, R14                 ; copy anyway
        BEQ     %BT10                   ; then loop
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished
        Pull    PC

; *****************************************************************************
;
;       ClockData - Clock a bit of data down the IIC bus
;
; in:   R0 = data bit
;
; out:  All registers preserved, including PSR
;

ClockData ROUT
 [ No26bitCode
        Push    "R1,R2,R14"
        MRS     R2,CPSR
 |
        Push    "R1, R14"
 ]

        MOV     R1, #0                  ; clock LO
        BL      SetC1C0

; Disable interrupts if not talking to BMU to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        LDR     r1, IRQDisableFlag
 [ No26bitCode
        ORR     r1, r1, r2
        MSR     CPSR_c,r1
 |
        ORR     r1, r1, pc
        TEQP    r1, #0
 ]

        MOV     R1, #1                  ; clock HI
        BL      SetC1C0CheckClock

; Delay here must be >= 4.0 microsecs

        MOV     R1, #0                  ; clock LO
        BL      SetC1C0

 [ No26bitCode
        MSR     CPSR_cf,R2
        Pull    "R1,R2,PC"
 |
        Pull    "R1, PC",,^
 ]

; *****************************************************************************
;
;       Start - Send the Start signal
;
; out:  All registers preserved, including PSR
;

Start   ROUT
 [ No26bitCode
        Push    "R0-R3,R14"
        MRS     R3, CPSR
 |
        Push    "R0-R2,R14"
 ]

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SetC1C0

; Hold start condition for BMU

        MOV     R2, #IOC
        MOV     R0,#10
        BL      DoMicroDelay

; Delay here must be >= 4.7 microsecs

        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
        BL      SetC1C0

 [ No26bitCode
        MSR     CPSR_f, R3
        Pull    "R0-R3,PC"
 |
        Pull    "R0-R2,PC",,^
 ]

; *****************************************************************************
;
;       Acknowledge - Check acknowledge after transmitting a byte
;
; out:  All registers preserved
;       V=0 => acknowledge received
;       V=1 => no acknowledge received
;

Acknowledge ROUT
        Push    "R0-R2,R14"

        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        BL      SetC1C0

; Disable interrupts if not talking to BMU to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

 [ No26bitCode
        MRS     R1,CPSR
        Push    "R1"
        LDR     r0, IRQDisableFlag
        ORR     r1, r1, r0
        MSR     CPSR_c,r1
 |
        MOV     R1,PC
        Push    "R1"
        LDR     r0, IRQDisableFlag
        ORR     r1, r1, r0
        TEQP    r1, #0
 ]

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SetC1C0CheckClock

; Delay here must be >= 4.0 microsecs

        MOV     R2, #IOC
        LDRB    R2, [R2, #IOCControl]   ; get the data from IOC

        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
        BL      SetC1C0

        Pull    "R1"
 [ No26bitCode
        MSR     CPSR_c,R1
 |
        TEQP    PC,R1
 ]

        TST     R2, #1                  ; should be LO for correct acknowledge
        MOV     R2, PC
        BICEQ   R2, R2, #V_bit          ; clear V if correct acknowledge
        ORRNE   R2, R2, #V_bit          ; set V if no acknowledge
        TEQP    R2, #0

        Pull    "R0-R2,PC"

; *****************************************************************************
;
;       Stop - Send the Stop signal
;
; out:  All registers preserved, including PSR
;

Stop    ROUT
 [ No26bitCode
        Push    "R0-R2,R14"
        MRS     R2, CPSR
 |
        Push    "R0,R1,R14"
 ]

        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SetC1C0

 [ No26bitCode
        MSR     CPSR_f, R2
        Pull    "R0-R2,PC"
 |
        Pull    "R0,R1,PC",,^
 ]

; *****************************************************************************
;
;       TXByte - Transmit a byte
;
; in:   R0 = byte to be transmitted
;
; out:  All registers preserved, including PSR
;

TXByte  ROUT
 [ No26bitCode
        Push    "R0-R3,R14"
        MRS     R3, CPSR
 |
        Push    "R0-R2,R14"
 ]
        MOV     R2, R0                  ; byte goes into R2
        MOV     R1, #&80                ; 2^7   the bit mask
10
        ANDS    R0, R2, R1              ; zero if bit is zero
        MOVNE   R0, #1
        BL      ClockData               ; send the bit
        MOVS    R1, R1, LSR #1
        BNE     %BT10
 [ No26bitCode
        MSR     CPSR_f, R3
        Pull    "R0-R3,PC"
 |
        Pull    "R0-R2,PC",,^
 ]

; *****************************************************************************
;
;       RXByte - Receive a byte
;
; out:  R0 = byte received
;       All other registers preserved, including PSR
;

RXByte  ROUT
 [ No26bitCode
        Push    "R1-R5, R14"
        MRS     R5, CPSR
 |
        Push    "R1-R4, R14"
 ]
        MOV     R3, #0                  ; byte:=0
        MOV     R2, #IOC
        MOV     R4, #7

        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        BL      SetC1C0
10
 [ No26bitCode
        MRS     R1,CPSR
        Push    "R1"
        LDR     r0,IRQDisableFlag
        ORR     R1,R1,r0
        MSR     CPSR_c,R1               ; Disable ints if not talking to BMU
 |
        MOV     LR, PC
        Push    "LR"
        LDR     r0, IRQDisableFlag
        ORR     LR, LR, r0
        TEQP    LR, #0                  ; Disable ints if not talking to BMU
 ]

        MOV     R0, #1                  ; pulse clock HI
        MOV     R1, #1
        BL      SetC1C0CheckClock

        LDRB    R1, [R2, #IOCControl]   ; get the data from IOC
        AND     R1, R1, #1
        ADD     R3, R1, R3, LSL #1      ; byte:=byte*2+(IOC?0)AND1

        MOV     R0, #1                  ; return clock LO
        MOV     R1, #0
        BL      SetC1C0

 [ No26bitCode
        Pull    "R1"
        MSR     CPSR_c,R1               ; restore interrupt state
 |
        Pull    "LR"
        TEQP    PC, LR                  ; restore interrupt state
 ]

        SUBS    R4, R4, #1
        BCS     %BT10

        MOV     R0, R3                  ; return the result in R0
 [ No26bitCode
        MSR     CPSR_f, R5
        Pull    "R1-R5, PC"
 |
        Pull    "R1-R4, PC",,^
 ]

CopyError Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        MOV     R4,R11                  ; (parameter) -> R4
CopyError0
        ADR     R1, MessageFile_Block
        MOV     R2, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.IIC.Messages", 0

        ALIGN

open_messagefile Entry r0-r2
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     R0, MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

        END
@


4.5
log
@  Moved to use shared makefiles and objasm
Admin:
  Tested in STB Baseline build.

Version 0.20. Tagged as 'IIC-0_20'
@
text
@d328 1
a328 1
        RestPSR R2,, c
d333 1
a333 1
        RestPSR R2,, c
@


4.4
log
@  Made interrupt safe, at least on STBs. Also 32-bit compatible, FWIW.

Detail:
  A new error, "IIC operation in progress", error number &20301 will be
  returned from SWI IIC_Control under the following circumstances:

  1) if the previous call to IIC_Control has not yet completed; or
  2) if an examination of the interrupt stack indicates that the kernel's
     IIC code is currently threaded. This aspect of operation requires
     detailed knowledge of the kernel; currently the following kernels are
     supported:
       4.52 (featured in STB-22)
       4.71 (featured in STB-3)
       5.31 (featured in STB-400)
     The knowledge required is the range of addresses covering the routines
     HexToBCD to ReadTime from Kernel.s.PMF.i2cutils. It is also assumed
     that kernels from 4.81 onwards feature an Ursula-style 32-bit
     compatible IRQ stack, rather than an ARM2/3 compatible stack with a
     combined return PC/PSR on the stack.

  32-bit compatibility makes heavy use of the No26bitCode switch, largely
  for consistency with the equivalent code in the kernel, with which it
  obviously shares a common heritage.

Admin:
  Currently tested only on an STB-22. Required for closed captioning support
  on all STBs.

  It is currently planned that future versions of RISC OS will farm out IIC
  operations to the HAL, so at that point the distinction between the two
  sets of IIC code will be removed. Ideally, the new IIC code would be
  fully re-entrant (ie would complete any foreground IIC operation, then
  do the background operation and then return to the background process).
  We can just about do without that functionality at present.

Version 0.17. Tagged as 'IIC-0_17'
@
text
@a55 2
        LEADR   Module_LoadAddr

d90 2
d450 1
a450 1
        mrs    ,R3, CPSR
d459 1
a459 1
        msr    ,CPSR_c, R14                     ; preserves Z flag
d490 1
a490 1
        msr    ,CPSR_c, lr                      ; restore IRQs if we're talking to BMU
d505 1
a505 1
        msr    ,CPSR_cf, R3
d516 1
a516 1
        mrs    ,R3, CPSR
d561 1
a561 1
        mrs    ,R2,CPSR
d575 1
a575 1
        msr    ,CPSR_c,r1
d590 1
a590 1
        msr    ,CPSR_cf,R2
d606 1
a606 1
        mrs    ,R3, CPSR
d634 1
a634 1
        msr    ,CPSR_f, R3
d660 1
a660 1
        mrs    ,R1,CPSR
d664 1
a664 1
        msr    ,CPSR_c,r1
d688 1
a688 1
        msr    ,CPSR_c,R1
d711 1
a711 1
        mrs    ,R2, CPSR
d727 1
a727 1
        msr    ,CPSR_f, R2
d745 1
a745 1
        mrs    ,R3, CPSR
d758 1
a758 1
        msr    ,CPSR_f, R3
d775 1
a775 1
        mrs    ,R5, CPSR
d788 1
a788 1
        mrs    ,R1,CPSR
d792 1
a792 1
        msr    ,CPSR_c,R1               ; Disable ints if not talking to BMU
d815 1
a815 1
        msr    ,CPSR_c,R1               ; restore interrupt state
d826 1
a826 1
        msr    ,CPSR_f, R5
d832 1
a832 1
CopyError ENTRY r1-r7
d850 1
a850 1
open_messagefile ENTRY r0-r2
@


4.4.2.1
log
@* Attempts to use Kernel IIC code if possible.
* Reentrancy checks removed - ultimately this should be in the Kernel.

Version 0.18, 4.5.2.1. Tagged as 'IIC-0_18-4_5_2_1'
@
text
@d78 1
a304 25
        Push    "R0-R1"
        Push    "R0-R2"                 ; parameters for OS_IICControl
        MOV     R0, R13
        MOV     R1, #1
        SWI     XOS_IICOp
        ADD     R13, R13, #12           ; balance stack
        BVS     %FT10
        Pull    "R0-R1"
        TEQ     PC, PC
        MOVNE   PC, R10                 ; 32-bit exit: NZC corrupted
        MOVEQS  PC, R10                 ; 26-bit exit: NZC preserved
10
        LDR     R14, [R0]
        SUB     R14, R14, #ErrorNumber_NoSuchSWI :AND: &FF00
        TEQ     R14, #ErrorNumber_NoSuchSWI :AND: &FF
        Pull    "R0-R1",EQ
        BEQ     %FT20

        ADD     R13, R13, #4
        Pull    "R1"
        TEQ     PC, PC
        MOVNE   PC, R10                 ; 32-bit exit: NZC corrupted
        MOVEQS  PC, R10                 ; 26-bit exit: NZC preserved

20
d344 12
d383 2
d405 2
d482 13
d572 1
d574 1
a574 1
        ORR     r1, r2, #I32_bit
d577 1
a577 1
        ORR     r1, pc, #I_bit
d662 2
a663 1
        ORR     r1, r1, #I32_bit
d668 2
a669 1
        ORR     r1, r1, #I_bit
d790 2
a791 1
        ORR     R1,R1,#I32_bit
d796 2
a797 1
        ORR     LR, LR, #I_bit
@


4.4.2.2
log
@Changed to use ObjAsm and centralised Makefiles. Some 32-bit fixes.

Version 0.18, 4.5.2.2. Tagged as 'IIC-0_18-4_5_2_2'
@
text
@d56 2
a90 2
        AREA    |IIC$Code|, CODE, READONLY, PIC

d458 1
a458 1
        MRS     R3, CPSR
d467 1
a467 1
        MSR     CPSR_c, R14                     ; preserves Z flag
d500 1
a500 1
        MSR     CPSR_cf, R3
d511 1
a511 1
        MRS     R3, CPSR
d556 1
a556 1
        MRS     R2,CPSR
d569 1
a569 1
        MSR     CPSR_c,r1
d584 1
a584 1
        MSR     CPSR_cf,R2
d600 1
a600 1
        MRS     R3, CPSR
d628 1
a628 1
        MSR     CPSR_f, R3
d654 1
a654 1
        MRS     R1,CPSR
d657 1
a657 1
        MSR     CPSR_c,r1
d680 1
a680 1
        MSR     CPSR_c,R1
a685 3
 [ No26bitCode
        MRS     R2, CPSR
 |
a686 1
 ]
a688 3
 [ No26bitCode
        MSR     CPSR_f, R2
 |
a689 1
 ]
d703 1
a703 1
        MRS     R2, CPSR
d719 1
a719 1
        MSR     CPSR_f, R2
d737 1
a737 1
        MRS     R3, CPSR
d750 1
a750 1
        MSR     CPSR_f, R3
d767 1
a767 1
        MRS     R5, CPSR
d780 1
a780 1
        MRS     R1,CPSR
d783 1
a783 1
        MSR     CPSR_c,R1               ; Disable ints if not talking to BMU
d805 1
a805 1
        MSR     CPSR_c,R1               ; restore interrupt state
d816 1
a816 1
        MSR     CPSR_f, R5
d822 1
a822 1
CopyError Entry r1-r7
d840 1
a840 1
open_messagefile Entry r0-r2
@


4.4.2.3
log
@Inserts minor version number into module help string.

Version 0.18, 4.5.2.4. Tagged as 'IIC-0_18-4_5_2_4'
@
text
@d113 1
a113 5
IIC_HelpStr =       "IIC",TAB, TAB,"$Module_MajorVersion ($Module_Date)"
      [ "$Module_MinorVersion" <> ""
        = " $Module_MinorVersion"
      ]
        = 0
@


4.4.2.4
log
@Update to work with zero page relocation
Detail:
  s/IICMod - Try getting IRQsema pointer from OS_ReadSysInfo before falling back on legacy address. Store pointer in workspace for speedy access.
Admin:
  Tested on rev A2 BB-xM


Version 0.18, 4.5.2.6. Tagged as 'IIC-0_18-4_5_2_6'
@
text
@a43 2
        GET     Hdr:PublicWS
        GET     Hdr:OSRSI6
d63 1
a78 1
ptr_IRQsema     # 4   
a156 8
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_IRQsema
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        MOVEQ   r2, #Legacy_IRQsema
        STR     r2, ptr_IRQsema
d340 1
a340 1
        LDR     R11, ptr_IRQsema
@


4.4.2.5
log
@Apply change from IIC-0_21 to HAL branch.

Version 0.18, 4.5.2.7. Tagged as 'IIC-0_18-4_5_2_7'
@
text
@d366 1
a366 1
        RestPSR R2,, cf
d371 1
a371 1
        RestPSR R2,, cf
@


4.4.2.6
log
@Fix incorrect 26bit/32bit SWI exit logic after calling OS_IICOp
Detail:
  s/IICMod - The OS_IICOp wrapper code had the 26bit vs. 32bit conditions the wrong way round, leading to the 26bit exit code path being used on 32bit machines and vice-versa.
Admin:
  Builds but untested
  Should fix issue reported on forums with IIC_Control being unstable on the Pi when compared to OS_IICOp:
  http://www.riscosopen.org/forum/forums/4/topics/1437#posts-18194


Version 0.18, 4.5.2.8. Tagged as 'IIC-0_18-4_5_2_8'
@
text
@d327 2
a328 2
        MOVEQ   PC, R10                 ; 32-bit exit: NZC corrupted
        MOVNES  PC, R10                 ; 26-bit exit: NZC preserved
d339 2
a340 2
        MOVEQ   PC, R10                 ; 32-bit exit: NZC corrupted
        MOVNES  PC, R10                 ; 26-bit exit: NZC preserved
@


4.4.2.7
log
@Error number alignment & minor tidying
The trunk version of IIC uses &20301 as "IIC in use" by defining it locally at the top of the source, whereas the RISC OS 5 kernel (using the HAL branch of IIC) uses &20302. Since the trunk version with reentrancy checking was only ever shipped in STBs, take the allocation in Hdr:NewErrors as gospel and swap to using that.
Other minor tidying:
* Use Push/Pull instead of STM/LDM
* Beef up some comments
* Use Unix style filenames in the Makefile
Built, but not tested.

Version 0.18, 4.5.2.9. Tagged as 'IIC-0_18-4_5_2_9'
@
text
@d46 1
a46 1
        GET     VersionASM
d54 4
d136 1
a136 1
        Push    "lr"
d147 1
a147 1
        Pull    "pc", VS
d196 1
a196 1
        Pull    "pc"
d198 1
a198 2
IIC_Die
        Push    "lr"
d205 1
a205 1
        Pull    "pc"
d319 1
a319 1
        Push    "R0-R2"                 ; parameters for OS_IICOp
d334 1
a334 1
        BEQ     %FT20                   ; OS_IICOp not known, bitbash IOC ourselves
d448 1
a448 1
        ADR     R0, ErrorBlock_IIC_Busy
d459 1
a459 1
        MakeInternatErrorBlock IIC_Busy,,InUse
a843 4
; *****************************************************************************
;
;       Internationalisation
;
@


4.4.2.8
log
@Simplify 32 bitting
None of the internal functions of IIC require flags preservation, so don't bother preserving them.
Use PSR manipulation macros where possible instead of longhand.

Version 0.18, 4.5.2.10. Tagged as 'IIC-0_18-4_5_2_10'
@
text
@d346 1
a346 1
        PHPSEI  R2, R14                 ; disable IRQs while we navigate the IRQ stack
d363 1
a363 1
        PLP     R2
d368 1
a368 1
        PLP     R2
a461 1
;                 optionally waiting for clock to be high
d463 1
a463 1
; out:  All registers preserved
d467 1
d469 14
a482 3
        PHPSEI  R3, R14                         ; disable interrupts round access to IOCControlSoftCopy
        TEQ     PC, #0                          ; set NE to indicate not checking clock
        B       SetOrCheck
a483 6
SetC1C0CheckClock
        Push    "R0-R3,R14"
        PHPSEI  R3, R14                         ; disable interrupts round access to IOCControlSoftCopy
        TEQ     R0, R0                          ; set EQ to indicate checking clock

SetOrCheck
d510 2
a511 1
        PLP     R3
d513 17
d565 1
d567 4
d578 7
a584 1
        PHPSEI  R2, R14
d594 6
a599 3
        PLP     R2
        
        Pull    "R1-R2, PC"
d605 1
a605 1
; out:  All registers preserved
d609 4
d614 1
d638 6
a643 1
        Pull    "R0-R2,PC"
d664 7
a670 1
        PHPSEI  R1, R14
d672 3
d690 5
a694 1
        PLP     R1
a695 1
        CLRV
d697 12
a708 1
        SETV    NE                      ; set V if no acknowledge
d716 1
a716 1
; out:  All registers preserved
d720 4
d725 1
d737 6
a742 1
        Pull    "R0,R1,PC"
d750 1
a750 1
; out:  All registers preserved
d754 4
d759 1
a759 1

d768 6
a773 2

        Pull    "R0-R2,PC"
d784 4
d789 1
a789 1

d798 11
a808 2
        PHPSEI  R1, LR
        Push    "R1"                    ; Disable ints if not talking to BMU
d822 1
d824 5
a828 1
        PLP     R1                      ; restore interrupt state
d834 6
a839 2

        Pull    "R1-R4, PC"
@


4.4.2.9
log
@Fix to work on pre-HAL machines
The attempt to call OS_IICOp first corrupts r14, which is carefully stacked only to cause a prefetch abort on return. Stack r10 instead.
Tested on RISC OS 4.02.

Version 0.18, 4.5.2.11. Tagged as 'IIC-0_18-4_5_2_11'
@
text
@d378 1
a378 1
        Push    R10
d410 1
a410 1
        Pull    R10
d412 2
a413 2
        MOVEQ   PC, R10                 ; 32-bit exit: NZC corrupted
        BICS    PC, R10, #V_bit         ; 26-bit exit: NZC preserved
@


4.4.2.10
log
@Add command to list the IIC devices
New command *IICDevices probes each bus and reports what it finds.
When an ACK to an address read is received Service_IIC is set round to see if any resident device drivers have definitive knowledge about what's at the address (cf. Service_PCI), otherwise a guess will be made based on a small lookup table in the Messages.
hdr/IIC: Subreason for name lookup
IICMod.s: Loop over the buses, report what's there.
CmdHelp/Messages: New syntax, error messages, and table of IIC devices

Tested on IOMD, Titanium, and a Raspberry Pi 2.

Version 0.18, 4.5.2.12. Tagged as 'IIC-0_18-4_5_2_12'
@
text
@d92 6
a97 6
        DCD     IIC_Init         - Module_BaseAddr
        DCD     IIC_Die          - Module_BaseAddr
        DCD     IIC_Service      - Module_BaseAddr
        DCD     IIC_Title        - Module_BaseAddr
        DCD     IIC_HelpStr      - Module_BaseAddr
        DCD     IIC_HC_Table     - Module_BaseAddr
d99 2
a100 2
        DCD     IIC_SWIHandler   - Module_BaseAddr
        DCD     IIC_SWINameTable - Module_BaseAddr
d102 1
a102 1
        DCD     message_filename - Module_BaseAddr
d127 1
a127 3
IIC_HC_Table
        Command IICDevices, 1, 0, International_Help 
        &       0
a299 160
;       IICDevices command handler
;
; in:   R0 = command tail
;       R1 = number of parameters
;       R12 -> private word
;
; out:  R0-R6, R12 may be corrupted
IICDevices_Help   = "HIICD", 0
IICDevices_Syntax = "SIICD", 0
HeadrTok          = "Headr", 0
        ALIGN
IICDevices_Code
        Entry   "r7", 4
        LDR     r12, [r12]
        MOV     r7, #1                  ; no header line yet

        TEQ     r1, #0
        MOVEQ   r5, #0                  ; start at the bottom...
        MOVEQ   r2, #256                ; ...do all buses
        BEQ     %FT05

        MOV     r1, r0
        MOV     r0, #10 :OR: (1:SHL:30)
        SWI     XOS_ReadUnsigned
        MOVVC   r5, r2                  ; start at this bus...
        ADDVC   r2, r5, #1              ; ...and only do that one
        BVS     %FT95
05
        ; Range check bus
        MOV     r0, #14                 
        SWI     XOS_ReadSysInfo         ; read bus count
        MOVVS   r0, #1                  ; at least 1 then

        CMP     r5, r0
        BCS     %FT95                   ; started too high

        CMP     r2, r0
        MOVCS   r4, r0
        MOVCC   r4, r2                  ; MIN(buses, request)
10
        MOV     r6, #0                  ; address
20
        ; Try addressing each device on each bus
        MOVS    r0, r6, LSR #3
        TEQNE   r0, #2_1111
        BEQ     %FT50                   ; skip reserved 2_1111xxx and 2_0000xxx

        MOV     r0, #1
        ORR     r0, r0, r6, LSL #1
        MOV     r1, sp
        MOV     r2, #1                  ; 1 byte read transfer

        TEQ     r5, #0
        BNE     %FT30                   ; Use IIC_Control for pre 5.00 compatibility

        SWI     XIIC_Control
        B       %FT40
30
        Push    "r0-r2"                 ; descriptor
        MOV     r0, sp
        MOV     r1, #1              
        ORR     r1, r1, r5, LSL #24     ; 1 transfer on that bus
        SWI     XOS_IICOp
        ADD     sp, sp, #3*4
40
        BVC     %FT60                   ; no error => good

        LDR     r1, =ErrorNumber_IIC_NoAcknowledge
        LDR     r2, [r0]
        TEQ     r2, r1
        BEQ     %FT50                   ; no ack => goto next

        EXIT    VS                      ; some other error => bad
50
        ADD     r6, r6, #1
        TEQ     r6, #128
        BNE     %BT20                   ; next address

        ADD     r5, r5, #1
        TEQ     r5, r4
        BNE     %BT10                   ; next bus

        CLRV
        EXIT
60
        ; Print heading line out
        SUBS    r7, r7, #1
        SUB     sp, sp, #64             ; space for lookups
        BNE     %FT70

        ADR     r1, HeadrTok
        MOV     r2, sp
        MOV     r3, #64
        BL      CopyMessage

        MOVVC   r0, sp
        SWIVC   XOS_Write0
        SWIVC   XOS_NewLine
        BVS     %FT90
70
        ; Print device detail out
        MOV     r0, r5
        BL      PrintF_3iSpc
        MOVVC   r0, r6, LSL #1
        BLVC    PrintF_3iSpc
        BVS     %FT90

        ; Ask around if any drivers have a definitive result
        LDR     r1, =IICService
        MOV     r2, #Service_IIC_LookupDescription
        MOV     r3, r5, LSL #24
        ORR     r3, r3, r6, LSL #1
        SWI     XOS_ServiceCall
        TEQ     r1, #Service_Serviced
        BEQ     %FT80

        ; Try our device table then
        MOV     r0, r6, LSL #1
        MOV     r2, #'D'
        MOV     r1, sp
        STRB    r2, [r1], #1
        MOV     r2, #3
        SWI     XOS_ConvertHex2

        MOVVC   r1, sp                  ; token 'Dxx'
        ADDVC   r2, sp, #4              ; buffer
        MOVVC   r3, #64 - 4
        BLVC    CopyMessage
        BVS     %FT90
80
        MOV     r0, r2
        SWI     XOS_Write0
        TEQ     r1, #Service_Serviced
        SWINE   XOS_WriteI+'?'          ; guessed by me
        SWIVC   XOS_NewLine
90
        ADD     sp, sp, #64             ; junk space from lookup
        BVC     %BT50
        EXIT    VS
95
        ADR     R0, ErrorBlock_IIC_BadBus
        MOV     R11, #0
        BL      CopyError               ; sets V
        EXIT    VS

PrintF_3iSpc ROUT
        LDR     r1, =&20202020
        Push    "r1-r2, lr"
        ADD     r1, sp, #2              ; might need 2 leading spaces
        MOV     r2, #6
        SWI     XOS_ConvertCardinal1
        RSBVC   r2, r2, #5              ; 5/4/3 -> 0/1/2
        ADDVC   r0, sp, r2
        SWIVC   XOS_Write0
        SWIVC   XOS_WriteI+' '
        ADD     sp, sp, #8
        Pull    "pc"

; *****************************************************************************
;
d437 1
a437 1
        ADRL    R11, IIC_Title
a457 1
        MakeInternatErrorBlock IIC_BadBus,,BdBus
a747 12
CopyMessage Entry "r1,r3-r7"
        BL      open_messagefile
        EXIT    VS
CopyMessage0
        ADR     R0, MessageFile_Block   ; R1 -> token, R2 -> buffer, R3 = buffer size
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_Lookup
        EXIT

@


4.4.2.11
log
@Switch out pre-HAL code
This is the HAL branch of the module, so there's no need to carry round all the IOC poking code which never gets called.

Version 0.18, 4.5.2.13. Tagged as 'IIC-0_18-4_5_2_13'
@
text
@d49 1
a49 1
ReentrancyCheck SETL    {TRUE} :LAND: :LNOT:HAL         ; Harmless if you don't need it
a488 1
    [ :LNOT:HAL
d494 1
a494 1
    ]
a500 1
  [ :LNOT:HAL
d539 1
a595 1
  ] ; :LNOT:HAL
a621 1
  [ :LNOT:HAL
a892 1
  ] ; :LNOT:HAL
@


4.3
log
@	Dozy Dave can't merge branches properly ;-)
Detail:
	When merging the Spinner branch of this module, I changed two TAB
characters in the help string to spaces. This threw out the formatting of the
rommodules listing. Fixed by changing back to two TAB's as was present before
the last change.
Admin:
	Tested.

Version 0.16. Tagged as 'IIC-0_16'
@
text
@d46 10
d64 7
d79 8
d105 2
d114 1
a114 1
IIC_HelpStr =       "IIC",TAB, TAB,"$Module_MajorVersion ($Module_Date)"
d117 7
d151 33
a183 1
        LDMIA   sp!, {pc}^
d191 96
a286 1
        LDMIA   sp!, {pc}^
d303 39
a341 4
        ADRNE   R0, ErrorBlock_NoSuchSWI
        ADRNE   R11, IIC_Title
        BLNE    CopyError
        ORRVSS  PC, R10, #V_bit
d350 3
d354 1
d385 4
d390 3
a392 1
        BICS    PC, R14, #V_bit
d404 1
a404 1
        BL      CopyError
d407 4
d412 21
a432 1
        ORRS    PC, R14, #V_bit
d436 3
d448 5
d455 1
d457 4
d463 1
d482 3
d486 1
d489 3
d493 1
d504 4
d509 1
d514 5
d521 1
d559 1
d561 4
d573 4
d579 1
d589 6
a594 1
        Pull    "R1,R2,PC",,^
d604 4
d609 1
d633 4
d638 1
d659 7
d671 1
d687 3
d691 1
d709 4
d714 1
d726 4
d731 1
d743 4
d748 1
d757 4
d762 1
d773 4
d778 1
d787 7
d799 1
d813 4
d819 1
d825 4
d830 1
@


4.2
log
@	Updated this component onto the trunk.

Detail:
	Merged Ursula branch.
	Placed component under srccommit control.
	Strdepend now used in clean target.

 Admin:
 	Built.

Version 0.15. Tagged as 'IIC-0_15'
@
text
@d87 1
a87 1
IIC_HelpStr =       "IIC",9,"$Module_MajorVersion ($Module_Date)"
@


4.1
log
@Initial revision
@
text
@d44 1
d87 1
a87 4
IIC_HelpStr
        =       "IIC"
        =       TAB, TAB
        =       "0.14 (26 Sep 1994)", 0
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

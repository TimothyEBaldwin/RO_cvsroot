head	4.10;
access;
symbols
	Serial-0_47:4.10
	Serial-0_46:4.9
	Serial-0_45:4.8
	Serial-0_44:4.7
	Serial-0_43:4.6
	Serial-0_42:4.6
	Serial-0_41:4.5
	RO_5_07:4.5
	Serial-0_40:4.5
	Serial-0_39:4.4
	dellis_autobuild_BaseSW:4.3
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.4
	Serial-0_38:4.3
	Ursula_merge:4.2.2.1
	Serial-0_37:4.3
	nturton_Serial-0_35:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.6
	nicke_Serial_0_34:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2013.01.14.09.20.56;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	r811zrT2fNc1Q9Aw;

4.9
date	2013.01.05.21.37.47;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	jwUKqlU2NAFJc4zw;

4.8
date	2012.06.04.22.50.53;	author jlee;	state Exp;
branches;
next	4.7;
commitid	QhkTVtPXpHwgwr7w;

4.7
date	2011.11.26.23.17.27;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	VIfzlTfHNQj3OTIv;

4.6
date	2011.06.22.00.39.29;	author jlee;	state Exp;
branches;
next	4.5;
commitid	7AENLsN77du4lBov;

4.5
date	2003.11.13.17.02.57;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2001.03.16.16.02.39;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.08.16.12.57.23;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.02.12.43.20;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.37.27;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	98.09.07.13.50.56;	author wturner;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.37.27;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.41.29;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.14.38.53;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.14.01.58;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.02.17;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.54.12;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Get PCIHardware option from the components file
No longer switches on M_Tungsten.

Version 0.47. Tagged as 'Serial-0_47'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Serial710

; This file contains the driver for the C&T 82C710/711 parts but will also
; work with register compatible devices.  The code has been extended to deal
; with parts such as the SMC FDC37C665 or C&T 82C735 which have RX and TX FIFOs.

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ PCIHardware
RegSpacing              * 1
HWDeviceNo              * PCI_DeviceNo
        ! 0, "Using PCI attached serial controller"
 |
RegSpacing              * 4
HWDeviceNo              * Serial_DevNo
        ! 0, "Using IO mapped serial controller"
 ]

                        ^ 0, r11
C710_DataWord           # RegSpacing    ; byte wide data port
C710_InterruptEnable    # RegSpacing    ; interrupt enable bits
FIFO_Control            # 0             ; FIFO control register in same position as interrupt flags
C710_InterruptFlags     # RegSpacing    ; flags to indicate what sort of interrupt
C710_FormatWord         # RegSpacing    ; format word
C710_ModemControl       # RegSpacing    ; control register
C710_LineStatus         # RegSpacing    ; current line status
C710_ModemStatus        # RegSpacing    ; modem status

                        ^ 0, r11
C710_BaudDivisorLSB     # RegSpacing    ; bottom 8 bits of baud divisor (only accessable when DRAB =1)
C710_BaudDivisorMSB     # RegSpacing    ; top 8 bits of baud divisor (only accessed when DRAB =1)

; Bits in InterruptEnable

IE_Receive  *   1 :SHL: 0               ; set bit to enable receive interrupts
IE_Transmit *   1 :SHL: 1               ; set bit to enable transmit interrupts
IE_Error    *   1 :SHL: 2               ; set bit to enable error interrupts (Overrun, Parity, Framing, Break)
IE_Modem    *   1 :SHL: 3               ; set bit to enable modem line change interrupts

; Bits in FIFO_Control

FC_Enable       *       1:SHL:0         ; enable TX and RX FIFOs
FC_RXClear      *       1:SHL:1         ; clear RX FIFO
FC_TXClear      *       1:SHL:2         ; clear TX FIFO
FC_RXTrigger1   *       2_00:SHL:6      ; RX interrupt trigger level (given our IRQ latency problems use 1 byte trigger)
FC_RXTrigger4   *       2_01:SHL:6
FC_RXTrigger8   *       2_10:SHL:6
FC_RXTrigger14  *       2_11:SHL:6

FIFO_Trigger    *       FC_RXTrigger1
FIFO_Size       *       16

; Values in InterruptFlags

IF_NoInterrupt  *       1
IF_LineStatus   *       6
IF_RXFull       *       4
IF_RXTimeout    *       12
IF_TXEmpty      *       2
IF_Modem        *       0
IF_IRQBits      *       15

; Bits in ModemControl

MC_DTROn        *       1 :SHL: 0       ; set bit to turn DTR on
MC_RTSOff       *       1 :SHL: 1       ; control RTS line
MC_OUT1         *       1 :SHL: 2       ; control OUT1 line
MC_OUT2         *       1 :SHL: 3       ; set bit to enable serial interrupts to get to the rest of the chip
MC_LoopBack     *       1 :SHL: 4       ; turn on loopback

; Bits in LineStatus

LS_RXFull       *       1 :SHL: 0       ; 1 => character is in receive buffer
LS_Overrun      *       1 :SHL: 1       ; 1 => overrun error
LS_Parity       *       1 :SHL: 2       ; 1 => parity error
LS_Framing      *       1 :SHL: 3       ; 1 => framing error
LS_Break        *       1 :SHL: 4       ; 1 => break error
LS_TXEmpty      *       1 :SHL: 5       ; 1 => transmit buffer empty
LS_TXShiftEmpty *       1 :SHL: 6       ; 1 => both Transmit buffer and shift register
                                        ; are empty

; Bits in ModemStatus

MS_CTSChanged   *       1 :SHL: 0       ; 1 => CTS has changed state
MS_DSRChanged   *       1 :SHL: 1       ; 1 => DSR has changed state
MS_RIRisen      *       1 :SHL: 2       ; 1 => RI has gone from 0 to 1
MS_DCDChanged   *       1 :SHL: 3       ; 1 => DCD has changed state
MS_CTSLow       *       1 :SHL: 4       ; CTS state
MS_DSRLow       *       1 :SHL: 5       ; DSR state
MS_RIHigh       *       1 :SHL: 6       ; RI state
MS_DCDLow       *       1 :SHL: 7       ; DCD state

; Bits in FormatWord

FW_BreakEnable    *     1 :SHL: 6       ; set to enable break signal
FW_AddressDivisor *     1 :SHL: 7       ; set to access baud rate divisors

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 [ :LNOT: HAL
Combo                   * &03010000
 ]
SMIindex                * &3A8
SMIaccess               * &3AC
SMIENBL1                * &0C
serial1_bit             * 8


        MACRO
        Palette $colour, $reg1, $reg2
 [ {TRUE}
        MOV     $reg1, #&03400000
        LDR     $reg2, =$colour
        STR     $reg2, [$reg1]
 ]
        MEND

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: Serial710
;
; in:   r0  = reason code
;               if bit 31 set then
;                       r2 -> return frame containing r1-r7 for call
;               if bit 31 clear then normal call from DeviceFS
;
; out:  -
;
; This call handles the calls received from DeviceFS, the interface is slightly
; involved.  If the reason code has bit 31 clear then it is a normal DeviceFS
; call with r1..r7 containing parameters.
;
; With bit 31 set then r2 is a pointer to a command block containing the
; relevant parameters.  This is mainly to save lots of faffing around in
; the support module and moving registers about.
;

Serial710       ROUT

                Debug   interface, "serial710, reason =", r0

                TST     r0, #DeviceCall_ExternalBase
                BNE     %20                             ; is it a call from the support module?

                Debug   interface, "is an internal call from DeviceFS", r0

                CMP     r0, #(%20-%00)/4
                ADDCC   pc, pc, r0, LSL #2              ; despatch as required
                MOV     pc, lr
00
                B       open710                         ; initialise
                B       close710                        ; finalise
                B       wakeupTX710                     ; wake up for TX
                MOV     pc, lr                          ; wake up for RX
                MOV     pc, lr                          ; sleep rx
                MOV     pc, lr                          ; enum dir
                B       CreateForTX                     ; create buffer for TX
                B       CreateForRX                     ; create buffer for RX
                B       thresholdhalt710
                B       thresholdresume710
                MOV     pc, lr                          ; eod
                B       newstream710
20
                SUB     r0, r0, #DeviceCall_ExternalBase
                CMP     r0, #(%40-%30)/4
                ADRCSL  r0, ErrorBlock_Serial_BadControlOp
                DoError CS                              ; return error if invalid

                Push    "r11, lr"

                Debug   interface, "call from support module", r0
                Debug   interface, "frame at", r2
                DebugFrame interface, r2, 24

                MOV     r11, r2                         ; -> return frame
                LDMIA   r11, {r1-r7}

                MOV     lr, pc                          ; -> return address
                ADD     pc, pc, r0, LSL #2              ;    despatch as required
                B       %40
30
                B       reset710
                B       remove710
                B       setbaud710
                B       change710flags
                B       change710format
                B       break710
                B       nobreak710
                B       SetExtent                       ; common
                B       getchar                         ; common
                B       putchar                         ; common
                B       enumerate710
                B       GetDeviceName                   ; common
40
                STMIA   r11, {r1-r7}
                Pull    "r11, pc"                       ; and balance the stack

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: open710
;
; in:   r0  = reason codes
;       r1  = device handle
;       r2  = external stream handle
;       r3  = flags to indicate if for input or output
;
; out:  r2  = internal stream handle
;
; This routine is used to open a stream onto the device it must store the
; relevant handles and setup the device.
;

open710         Entry   "r0"

                Debug   open, "handle", r2
                Debug   open, "flags", r3

                BL      SetPower_On

                TST     r3, #2_1                        ; is it a RX or TX stream?
                STREQ   r2, InputHandle
                BEQ     %FT90
 [ KickSerialTX
                BL      SetTXKick                       ; if TX then set up call every to kick serial
 ]
 [ NewSplitScheme
                EXIT

                LDRB    r0, SerialRXBaud                ; check if RX baud = TX baud
                LDRB    lr, SerialTXBaud
                CMP     r0, lr
                STREQ   r2, OutputHandle                ; if equal then OK
                EXIT    EQ

                PullEnv
                ADR     r0, ErrorBlock_Serial_NoSplitBaudRates
                DoError

                MakeErrorBlock Serial_NoSplitBaudRates
 |
                STR     r2, OutputHandle
                EXIT
 ]
90
                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: close710
;
; in:   r0  = reason code
;       r2  = internal handle
;       SVC mode
;
; out:  -
;
; This code handles the closing of the file.  When received then we should halt
; the relevant transmission type until the stream is re-opened.
;

close710        Entry   "r0-r2"

                Debug   close, "Close handle", r2

                MOV     lr, #-1
                MOV     r1, #0

                LDR     r0, InputHandle
                TEQ     r0, r2                          ; Input stream being closed?
                TEQNE   r2, #0                          ; Or all streams?
                STREQ   lr, InputBufferHandle           ; Yes, invalidate input buffer handle
                STREQ   r1, InputHandle                 ;  and input handle
                BLEQ    UpdateRTSForegd                 ;  and update RTS

                MOV     lr, #-1
                LDR     r0, OutputHandle
                TEQ     r0, r2                          ; Output stream being closed?
                TEQNE   r2, #0                          ; Or all streams?
                STREQ   lr, OutputBufferHandle          ; Yes, invalidate output buffer handle
                STREQ   r1, OutputHandle                ;  and output handle
 [ KickSerialTX
                BLEQ    RemoveTXKick                    ; If output/all then remove call every set up in open710
 ]
 [ FixPowerSave
                BL      SetPower_Off                    ; Attempt to power down, service call faulted if other channel open
 ]
                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: newstream710
;
; in:   r0  = reason code
;       r2  = internal handle
;       r3  = buffer handle
;       SVC mode
;
; out:  -
;
; This call is issued after the stream has been created, it gives me a chance
; to setup the device correctly and start transmission etc, etc...
;

newstream710    Entry   "r0-r2"
                LDR     r0, InputHandle                         ; is it the input stream?
                TEQ     r0, r2
                STREQ   r3, InputBufferHandle                   ; save buffer handle
                STRNE   r3, OutputBufferHandle
                BLEQ    UpdateRTSForegd                         ; if opening input stream update RTS
                CLRV
                EXIT

UpdateRTSForegd EntryS  "r2, r11"
                WritePSRc SVC_mode + I_bit,lr                   ; update RTS call require IRQs off
                LDR     r2, SerialDeviceFlags                   ; and r2 = SerialDeviceFlags
                LDR     r11, HWAddress                          ; and r11 -> UART
                BL      UpdateDTRRTSTXI710
                EXITS   ,cf

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: reset710
;
; in:   r0  = reason code.
;       SVC mode
;
; out:  -
;
; This code is called to reset the CHIPS 710 controller, it will reset the modem control
; registers, enable the relevant interrupts and setup the IRQ handler for RISC OS.
;
; This routine may be called at other times than reset, if the power to the serial bits
; has been switched off and then reapplied.
;

reset710        Entry   "r0-r3, r11"
                LDR     r11, HWAddress                                  ; -> UART

                LDR     r2, SerialDeviceFlags
                ORR     r2, r2, #(1:SHL:SF_TXDormant):OR:(1:SHL:SF_NoSplitBaudRates)
                STR     r2, SerialDeviceFlags

                MVN     r1, r2                                          ; enable/disable serial FIFO depending on serial flags
                BL      SetFIFO

 [ Fix710TXEnable
                MOV     r0, #IE_Receive :OR: IE_Error :OR: IE_Modem
                STRB    r0, C710_InterruptEnable
 ]
                MOV     r0, #IE_Receive :OR: IE_Transmit :OR: IE_Error :OR: IE_Modem ; enable all interrupts
                STRB    r0, C710_InterruptEnable

                MOV     r0, #MC_DTROn :OR: MC_OUT2                      ; turn on DTR,RTS and enable serial IRQ
                STRB    r0, C710_ModemControl

                MOV     r1, #0                                          ; ensure CTS and DSR are updated in SerialFlags
                MOV     r2, #-1
                BL      change710flags

                LDR     r3, Flags                                       ; do we already own the IRQ vector?
                TST     r3, #f_SerialIRQ
                BNE     %FT10                                           ; yes, then skip

                MOV     r0, #HWDeviceNo
                ADDR    r1, irq710                                      ; -> irq routine
                MOV     r2, wp
                SWI     XOS_ClaimDeviceVector                           ; and claim the irq routine
                STRVS   r0, [sp]
                PullEnv VS
                DoError VS                                              ; return error (V set, r0 -> block)

                ORR     r3, r3, #f_SerialIRQ                            ; and we now have the IRQ vector
                STR     r3, Flags
10
 [ HAL
                Push    "r8,r9"
                MOV     r0, #HWDeviceNo
                MOV     r8, #0
                MOV     r9, #EntryNo_HAL_IRQEnable
                SWI     XOS_Hardware
                Pull    "r8,r9"
 |
 [ PhoebeHardware
                LDR     r1, =Combo
 |
                LDR     r1, =IOC
 ]
                SETPSR  I_bit, lr,,r3                                   ; disable IRQs while IOCIRQMSKB updated
 [ PhoebeHardware
                MOV     r0, #SMIENBL1
                STR     r0, [r1, #SMIindex]
                LDR     r0, [r1, #SMIaccess]
                ORR     r0, r0, #serial1_bit
                STR     r0, [r1, #SMIaccess]
 |
                LDRB    r0, [r1, #IOCIRQMSKB]
                ORR     r0, r0, #serial_bit
                STRB    r0, [r1, #IOCIRQMSKB]                           ; enable serial IRQs from 710
 ]
                RestPSR r3                                              ; restore interrupt state
 ]
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: remove710
;
; in:   SVC mode
;
; out:  -
;
; This code is called when the device should detach itself from the various
; vectors that mean that it has a grasp on IRQ chains.
;

remove710       Entry   "r0-r3"
                LDR     r3, Flags
                TST     r3, #f_SerialIRQ                ; serial IRQ handler still setup?
                EXIT    EQ

                MOV     r0, #HWDeviceNo
                ADDR    r1, irq710                      ; r1 -> code for handling serial device
                MOV     r2, wp                          ; r2 -> workspace for device IRQ
                SWI     XOS_ReleaseDeviceVector
                STRVS   r0, [sp]
                PullEnv VS
                DoError VS                              ; return error (r0 -> block)

                BIC     r3, r3, #f_SerialIRQ
                STR     r3, Flags                       ; mark as not owning the IRQ vectors
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: setbaud710
;
; in:   r0  = reason code
;       r1  = RX baud rate / -1 to read
;       r2  = TX baud rate / -1 to read
;       SVC mode
;
; out:  r1  = new RX baud (not necessarily what you asked for)
;       r2  = new TX baud (-------------""-------------------)
;       r3  = old RX baud
;       r4  = old TX baud
;
; This call is used to set the RX/TX baud rates, it should be noted that the 710
; controller does not support split baud rates and we must decide on which one
; to use.
;
; If both are specified as -1, ie. read then we simply setup the registers and
; return.
;
; In the old split scheme, if either r1 or r2 is -1 then the baud was changed to the value specified in the
; non -ve register.  If both were setup then we used r1 (RX). We return with both r1 and r2 set to the new value.
;
; In the new split scheme, we remember both RX and TX rates separately, but store the RX rate into the hardware.
; If an output stream is opened when split baud rates are set, an error is returned
;

setbaud710      Entry   "r0, r5, r11"

                LDRB    r3, SerialRXBaud
                LDRB    r4, SerialTXBaud                                ; read existing baud rates

                Debug   baud710, "baud710: rx, tx original baud rates", r3, r4

                MOV     r5, #-1

                CMP     r2, #0                                          ; if setting TX to zero
                MOVEQ   r2, #7                                          ; then use 7 (9600)
                CMP     r2, #-1                                         ; if reading TX
                MOVEQ   r2, r4                                          ; then use old value
 [ :LNOT: NewSplitScheme
                MOVNE   r5, r2                                          ; if setting TX then use this as baud
 ]

                CMP     r1, #0                                          ; if setting RX to zero
                MOVEQ   r1, #7                                          ; then use 7 (9600)
                CMP     r1, #-1                                         ; if reading RX
                MOVEQ   r1, r3                                          ; then use old value
                MOVNE   r5, r1                                          ; if setting RX then use this as baud
                                                                        ; (overrides TX if setting both)

                Debug   baud710, "baud710: actual values being set", r1, r2

                CMP     r1, r3                                          ; will the call invoke any change?
                CMPEQ   r2, r4
                EXIT    EQ                                              ; no, so don't bother return now!

                Debug   baud710, "baud710: rx, tx baud rates:", r1, r2
 [ NewBaudRates
                CMP     r1, #serialbaud_NewMAX                          ; if either baud rate is invalid
                CMPCC   r2, #serialbaud_NewMAX                          ; then complain
 |
                CMP     r1, #serialbaud_OldMAX                          ; if either baud rate is invalid
                CMPCC   r2, #serialbaud_OldMAX                          ; then complain
 ]
                PullEnv CS
                ADRCSL  r0, ErrorBlock_Serial_BadBaud                   ; r0 -> error block
                DoError CS                                              ; return error

                Debug   baud710, "baud710: specified baud:", r5

                PHPSEI

 [ NewSplitScheme
                STRB    r1, SerialRXBaud                                ; store both rates separately
                STRB    r2, SerialTXBaud
                CMP     r5, #-1                                         ; if not setting RX
                BEQ     %FT10                                           ; then skip hardware programming
 |
                STRB    r5, SerialRXBaud                                ; mark them both the same
                STRB    r5, SerialTXBaud                                ; (because they will be)
                MOV     r1, r5                                          ; return new rates as both the same
                MOV     r2, r5
 ]

                LDR     r11, HWAddress                                  ; r11 -> uart base

                ADR     r0, bauddivisors
                LDR     r5, [r0, r5, LSL #2]                            ; get baud rate crystal divisor

 [ NewTXStrategy
                CMP     r5, #6
                LDR     r0, SerialDeviceFlags
                ORRCC   r0, r0, #1:SHL:SF_FillTXFIFO
                BICCS   r0, r0, #1:SHL:SF_FillTXFIFO
                STR     r0, SerialDeviceFlags
 |
                STR     r5, SerialBaudDivisor
 ]

                LDRB    r0, C710_FormatWord
                ORR     r0, r0, #FW_AddressDivisor                      ; set DRAB to allow reprogram of baud generators
                STRB    r0, C710_FormatWord

                STRB    r5, C710_BaudDivisorLSB
                MOV     r5, r5, LSR #8
                STRB    r5, C710_BaudDivisorMSB                         ; write the baud value as 16b across two 8b registers
                BIC     r0, r0, #FW_AddressDivisor
                STRB    r0, C710_FormatWord                             ; and then restore the DRAB bit to original state

 [ :LNOT: NewTXStrategy
                Push    "r1,r2,lr"
                LDR     r2, SerialDeviceFlags
                TST     r2, #1:SHL:SF_UseFIFOs
                MVNNE   r1, r2
                BLNE    SetFIFO
                Pull    "r1,r2,lr"
 ]

10
                PLP
                CLRV
                EXIT

                ; table used to convert the specified baud value into a clock divisor
                ; as used by the 710 UART.

bauddivisors
                & 12    ; 9600
                & 1536  ; 75
                & 768   ; 150
                & 384   ; 300
                & 96    ; 1200
                & 48    ; 2400
                & 24    ; 4800
                & 12    ; 9600
                & 6     ; 19200
                & 2304  ; 50
                & 1047  ; 110
                & 857   ; 134.5
                & 192   ; 600
                & 64    ; 1800
                & 32    ; 3600
                & 16    ; 7200
 [ NewBaudRates
                & 3     ; 38400
                & 2     ; 57600
                & 1     ; 115200
  [ PCIHardware
                & 32770 ; 230400
  ]
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: change710flags
;
; in:   r0  = reason code
;       r1  = EOR mask
;       r2  = AND mask
;       SVC mode
;
; out:  r1  = OLD flags
;       r2  = NEW flags
;
; This code will modify the flags within the 710 controller, it is also used
; to return the state in the top 16 bits.  When called the routine will
; attempt to reprogram the values as required, it also compiles the
; status bits.
;
; This call is used to read/write the serial status.
;
;       bit     rw / ro         value   meaning
;
;       0       r/w             0       No software control. Use RTS handshaking if bit 5 clear.
;
;                               1       Use XON/XOFF protocol. Bit 5 ignored.
;
;       1       r/w             0       Use ~DCD bit.  If ~DCD bit in the status
;                                       register goes high, then cause a serial
;                                       event.  Also, if a character is received when
;                                       ~DCD is high then cause a serial event, and do not enter the
;                                       character into the buffer.
;
;                               1       Ignore the ~DCD bit.  Note that some serial chips (GTE and CMD)
;                                       have reception and transmission problems if this bit is high.
;
;       2       r/w             0       Use the ~DSR bit.  If the ~DSR bit in the status
;                                       register is high, then do not transmit characters.
;
;                               1       Ignore ~DSR bit.
;
;       3       r/w             0       DTR on (normal operation).
;                               1       DTR off (on 6551 cannot use serial in this state).
;
;       4       r/w             0       Use the ~CTS bit. If the ~CTS bit in the status
;                                       register is high, then do not transmit characters.
;
;                               1       Ignore ~CTS bit (not supported on 6551 hardware).
;
;       5       r/w             0       Use RTS handshaking if bit 0 is clear.
;                               1       Do not use RTS handshaking.
;                                       This bit is ignored if bit 0 is set.
;
;       6       r/w             0       Input not suppressed.
;                               1       Input is suppressed.
;
;       7       r/w             0       RTS controlled by handshaking system (low if no RTS handshaking)
;                               1       RTS high.
;                                       Users should only modify this bit if RTS handshaking is NOT in use.
;
;       8       r/w             0       Do not use FIFOs (if present)
;                               1       Use FIFOs (if present)
;
;       9..15   ro              0       Reserved for future expansion.
;
;       16      ro              0       XOFF not received
;                               1       XOFF has been received.  Transmission is stopped by this occurence.
;
;       17      ro              0       The other end is intended to be in XON state.
;                               1       The other state is intended to be in XOFF state.  When this
;                                       bit is set, then it means that an XOFF has been sent and it will be cleared
;                                       when an XON is sent by the buffering software.  Note that the fact that this
;                                       bit is set does not imply that the other end has received
;                                       an XOFF yet.
;
;       18      ro              0       The ~DCD bit is low, ie. carrier present.
;                               1       The ~DCD bit is high, ie. no carrier.
;                                       This bit is stored in the variable and updated on modem status interrupts
;
;       19      ro              0       The ~DSR bit is low, ie. 'ready' state.
;                               1       The ~DSR bit is high, ie. 'not-ready' state.
;                                       This bit is stored in the variable and updated on modem status interrupts
;
;       20      ro              0       The ring indicator bit is low.
;                               1       The ring indicator bit is high.
;                                       This bit is not stored in the variable but is read directly from the hardware.
;
;       21      ro              0       CTS low -> clear to send
;                               1       CTS high -> not clear to send
;                                       This bit is stored in the variable and updated on modem status interrupts.
;
;       22      ro              0       User has not manually sent an XOFF
;                               1       User has manually sent an XOFF
;
;       23      ro              0       Space in receive buffer above threshold
;                               1       Space in receive buffer below threshold
;
;       24..27  ro              0       Reserved for future expansion.
;
;       28      ro              0       Not using serial FIFOs
;                               1       Using serial FIFOs
;
;       29      ro              0       We have normal characters to transmit
;                               1       No normal characters to transmit (excluding breaks, XON/XOFFs)
;
;       30      ro              0       Not sending a break signal
;                               1       Currently sending a break signal
;
;       31      ro              0       Not trying to stop a break
;                               1       Trying to stop sending a break
;


change710flags  Entry   "r7-r11"

                BL      SetPower_On

                LDR     r11, HWAddress                                  ; r11 -> UART base

                LDR     r10, = :NOT: SF_ModifyBits
                BIC     r1, r1, r10                                     ; EOR mask cannot modify these bits
                ORR     r2, r2, r10                                     ; AND mask must preserve these bits

; disable IRQs round this bit because
; a) we are updating SerialDeviceFlags, which gets modified under IRQ
; b) if ModemStatus changes (and generates an IRQ) after we read it but
;    before we update SerialDeviceFlags, we'd be writing an old state into
;    the flags

                SETPSR  I_bit, lr,,r7                                   ; disable IRQs
                LDRB    r8, C710_ModemStatus

                Debug   flags710, "flags710: 710 modem status", r8

                LDR     r10, SerialDeviceFlags                          ; get global serial state flags

                Debug   flags710, "flags710: serial device flags", r10
                Debug   flags710, "flags710: uart base", r11

                BIC     r10, r10, #(1:SHL:SF_DCDHigh):OR:(1:SHL:SF_DSRHigh):OR:(1:SHL:SF_Ringing):OR:(1:SHL:SF_CTSHigh)

                TST     r8, #MS_CTSLow                                  ; OR in state of CTS
                ORREQ   r10, r10, #1:SHL:SF_CTSHigh

                TST     r8, #MS_DSRLow                                  ; OR in state of DSR
                ORREQ   r10, r10, #1:SHL:SF_DSRHigh

                TST     r8, #MS_RIHigh                                  ; OR in state of RI
                ORRNE   r10, r10, #1:SHL:SF_Ringing

                TST     r8, #MS_DCDLow
                ORREQ   r10, r10, #1:SHL:SF_DCDHigh

                AND     r9, r10, r2
                EOR     r2, r9, r1
                MOV     r1, r10                                         ; well munge them together and what ya got...
                STR     r2, SerialDeviceFlags                           ; store serial device flags (new!)

                Debug   flags710, "flags710: old, new:", r1, r2

                TEQ     r1, r2                                          ; any change ?
                BEQ     %FT10
                BL      SetFIFO                                         ; if so, then update FIFO
                BL      UpdateDTRRTSTXI710                              ; if so, then update DTR, RTS and TXI
10
                RestPSR r7
                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       SetFIFO
;
; Update state of FIFO
;
; in:   r1 = old flags
;       r2 = new flags
;       r11 -> C710_UART
;
; out:  r2 possibly updated
;       All other regs preserved
;

SetFIFO         Entry   "r1"

                EOR     lr, r1, r2                                      ; if bit not changed then
                TST     lr, #1:SHL:SF_UseFIFOs
                EXIT    EQ                                              ;   nothing to do

                LDR     lr, Flags
                TST     lr, #f_UseFIFOs                                 ; if we have no FIFOs then
                BICEQ   r2, r2, #1:SHL:SF_UseFIFOs                      ;   make sure bit is clear
                BEQ     %FT40                                           ;   and exit

                MOV     r1, #FIFO_Size                                  ; We're enabling/disabling FIFOs so clear RX data first
10
                LDRB    lr, C710_DataWord
                SUBS    r1, r1, #1
                BNE     %BT10

                TST     r2, #1:SHL:SF_UseFIFOs                          ; Enable/disable FIFOs based on flags passed in
 [ NewTXStrategy
                MOVEQ   lr, #0
                MOVNE   lr, #FC_Enable :OR: FC_RXClear :OR: FC_TXClear :OR: FIFO_Trigger
 |
                BEQ     %FT20

                LDR     lr, SerialBaudDivisor
                CMP     lr, #12                                                                 ; If current baud rate <= 9600 then
                BCS     %FT20                                                                   ;   disable FIFOs
                MOV     lr, #FC_Enable :OR: FC_RXClear :OR: FC_TXClear :OR: FIFO_Trigger        ; else enable FIFOs
                ORR     r2, r2, #1:SHL:SF_FIFOsEnabled
                B       %FT30
20
                MOV     lr, #0                                          ; Disable FIFOs
                BIC     r2, r2, #1:SHL:SF_FIFOsEnabled
30
 ]
                STRB    lr, FIFO_Control
40
                STR     r2, SerialDeviceFlags
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       UpdateDTRRTSTXI710
;
; Update DTR, RTS and TXI from SerialDeviceFlags and other state
;
; in:   r2 = SerialDeviceFlags
;       r11 -> C710_UART
;       Works in IRQ or SVC mode
;       IRQs disabled
;
; out:  All preserved
;

UpdateDTRRTSTXI710 Entry   "r0"
                LDRB    r0, C710_ModemControl                           ; get the status and control registers
                Debug   flags710, "flags710: old control register:", r0

; first work out DTR state

                TST     r2, #1:SHL:SF_DTROff                            ; change DTR?
                BICNE   r0, r0, #MC_DTROn
                ORREQ   r0, r0, #MC_DTROn

; now work out RTS state

                TST     r2, #1:SHL:SF_UserRTSHigh                       ; if user forcing RTS high
                BNE     setrtshigh710                                   ; then set high
                TST     r2, #(1:SHL:SF_XONXOFFOn):OR:(1:SHL:SF_NoRTSHandshake) ; if not using RTS handshaking
                BNE     setrtslow710                                    ; then set low
                TST     r2, #1:SHL:SF_Thresholded                       ; if not enough space in RX buffer
                BNE     setrtshigh710                                   ; then set high
                LDR     lr, InputBufferHandle
                CMP     lr, #-1
                BEQ     setrtshigh710
setrtslow710
                ORR     r0, r0, #MC_RTSOff
                B       %FT10

setrtshigh710
                BIC     r0, r0, #MC_RTSOff
10
                STRB    r0, C710_ModemControl

                Debug   flags710, "flags710: new control register:", r0

; now update TXI state

                TST     r2, #1:SHL:SF_StoppingBreak                     ; if stopping break
                BNE     disableTXI710                                   ; then don't transmit anything
                TST     r2, #1:SHL:SF_BreakOn                           ; if transmitting break
                BNE     enableTXI710                                    ; then always enable it (to transmit nulls)

                TST     r2, #1:SHL:SF_CTSHigh                           ; if CTS low, then skip
                BEQ     %FT20
                TST     r2, #1:SHL:SF_CTSIgnore                         ; else if CTS high and not ignoring CTS
                BEQ     disableTXI710                                   ; disable TXI
20
                TST     r2, #1:SHL:SF_DSRHigh                           ; if DSR low, then skip
                BEQ     %FT30
                TST     r2, #1:SHL:SF_DSRIgnore                         ; else if DSR high and not ignoring DSR
                BEQ     disableTXI710                                   ; disable TXI
30
                LDRB    lr, SerialXONXOFFChar                           ; if we have an XON or XOFF to send
                TEQ     lr, #0
                BNE     enableTXI710                                    ; then enableTXI

                TST     r2, #1:SHL:SF_HeXOFFedMe                        ; if he XOFFed me
                TSTEQ   r2, #1:SHL:SF_TXDormant                         ; or if no chars to send
                BNE     disableTXI710                                   ; then disableTXI
enableTXI710
                LDRB    lr, C710_InterruptEnable
 [ Fix710TXEnable
                BIC     lr, lr, #IE_Transmit
                STRB    lr, C710_InterruptEnable
 ]
                ORR     lr, lr, #IE_Transmit
                STRB    lr, C710_InterruptEnable
                EXIT

disableTXI710
                LDRB    lr, C710_InterruptEnable
                BIC     lr, lr, #IE_Transmit
                STRB    lr, C710_InterruptEnable

                MOV     lr, #0                                          ; make sure we put no more in FIFO (if we have one)
                STRB    lr, SerialTxByteCount

                EXIT

                ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: change710format
;
; in:   r0  = reason code
;       r1  = new format / -1 to read
;       SVC mode
;
; out:  r1  = old format
;
; This call modifies the format register for the 710 controller, it will
; setup the stop bits, word length and parity checking bits.
;
; The soft copy, SerialDataFormat, is only maintained so we can restore the correct data format
; if the power is switched off since we last set it.
;

; in format register                                    in r1
; ------------------                                    -----
;
; b0, b1        => word length                          b0, b1          => word length
;
; 0   0         => 5 bits                               0   0           => 8 bit word
; 0   1         => 6 bits                               0   1           => 7 bit word
; 1   0         => 7 bits                               1   0           => 6 bit word
; 1   1         => 8 bits                               1   1           => 5 bit word
;
;
; b2            => stop bits                            b2              => stop bits
;
; 0             => 1                                    0               => 1
; 1             => 1.5 (5 bit word)                     1               => 1.5 (5 bit word)
; 1             => 2 (6 bit word)                       1               => 2 (6 bit word)
; 1             => 2 (7 bit word)                       1               => 2 (7 bit word)
; 1             => 2 (8 bit word)                       1               => 2 (8 bit word no parity)
;                                                       1               => 1 (8 bit word with parity)
;                                                       (we assume no-one will use this option)
;
;
; b3            => parity enable                        b3              => parity enable
;
; 0             => disabled (no parity)                 0               => disabled (no parity)
; 1             => enabled (lots of parity)             1               => enabled (lots of parity)
;
;
; b4, b5        => parity type (if b3 =1)               b4, r5          => parity type (if b3 =1)
;
; 0   0         => odd parity                           0   0           => odd parity
; 1   0         => even parity                          1   0           => even parity
; 0   1         => 1                                    0   1           => 1
; 1   1         => 0                                    1   1           => 0

change710format Entry   "r9-r11"

                LDR     r11, HWAddress                                  ; -> 710 uart

                PHPSEI  ,r9                                             ; disable IRQs round updates to FormatWord

                LDRB    r10, C710_FormatWord                            ;  = 710 format register

; now mangle bits 0,1 to convert to old format:

; 00 -> 11
; 01 -> 10
; 10 -> 01
; 11 -> 00

; this is just an EOR with 3, unlike what the original 82C710 spec said

                AND     r9, r10, #2_00111111
                EOR     r9, r9, #3                      ; mangle chip's bits into user format
                CMP     r1, #-1                         ; if writing then
                ANDNE   r1, r1, #2_00111111             ; mask out strange bits
                CMPNE   r1, r9                          ; if reading or if writing the same state
                BEQ     %FT10                           ; then don't update

                EOR     r1, r1, #3                      ; mangle user bits into chip's format
                BIC     r10, r10, #2_00111111
                ORR     r10, r10, r1
                STRB    r10, C710_FormatWord
10
                PLP
                MOV     r1, r9
                EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: break710
;
; in:   r0  = reason code
;       SVC mode
;
; out:  -
;
; This code sets the 710 sending a break.
;
; Load a NULL character to transmit register now.
; Set bit 6 of FormatWord after the next transmit buffer empty occurs.
;

break710        EntryS  "r0, r11"

                BL      SetPower_On

                WritePSRc SVC_mode + I_bit, lr                  ; disable IRQs round this bit

                LDR     r11, HWAddress
                MOV     r0, #0                                  ; stick a null in the transmit data register now
                STRB    r0, C710_DataWord

                LDRB    r0, C710_InterruptEnable                ; enable transmit interrupts
 [ Fix710TXEnable
                BIC     r0, r0, #IE_Transmit
                STRB    r0, C710_InterruptEnable
 ]
                ORR     r0, r0, #IE_Transmit
                STRB    r0, C710_InterruptEnable

                LDR     lr, SerialDeviceFlags                   ; and set the bit in SerialDeviceFlags
                ORR     lr, lr, #1:SHL:SF_BreakOn
                STR     lr, SerialDeviceFlags
                EXITS   ,cf

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: nobreak710
;
; in:   r0  = reason code
;       SVC_mode
;
; out:  -
;
; This code stops sending the break for the 710.
;
;

nobreak710      Entry   "r0,r6-r7,r11"

                BL      SetPower_On

 [ No32bitCode
                MOV     lr, pc
                AND     lr, lr, #I_bit
                EOR     lr, lr, #I_bit                  ; value to EOR with PC to toggle between IRQs off
                                                        ; and entry state

                TEQP    lr, pc                          ; disable IRQs first
 |
                MRS     r7, CPSR
                ORR     lr, r7, #I32_bit
                MSR     CPSR_c, lr                      ; disable IRQs first
 ]

                LDR     r11, HWAddress
                LDR     r6, WaitForIRQsToFire

                LDR     r0, SerialDeviceFlags
                ORR     r0, r0, #1:SHL:SF_StoppingBreak ; indicate that we wish to stop break
                STR     r0, SerialDeviceFlags

                LDRB    r0, C710_InterruptEnable
                BIC     r0, r0, #IE_Transmit            ; disable transmit interrupts
                STRB    r0, C710_InterruptEnable

; now go into a loop, polling the transmitter empty bit, but processing any line status errors we get
; (since reading line status clears these!)

10
                LDRB    r0, C710_LineStatus
                TST     r0, #LS_Overrun :OR: LS_Parity :OR: LS_Framing :OR: LS_Break
                BNE     %FT50                           ; if a line status error, then process it
15
                TST     r0, #LS_TXShiftEmpty
                BNE     %FT20                           ; transmitter has finished shifting, so can clear break bit

 [ No32bitCode
                TEQP    lr, pc                          ; restore IRQ state for a bit
 |
                MSR     CPSR_c, r7                      ; restore IRQ state for a bit
 ]
                TEQ     r6, #0
                MOVNE   lr, pc
                MOVNE   pc, r6                          ; if needed do enough of a delay interrupts to occur
 [ No32bitCode
                TEQP    lr, pc                          ; then disable them again
 |
                ORR     lr, r7, #I32_bit                ; then disable them again
                MSR     CPSR_c, lr
 ]
                B       %BT10

20
                LDRB    r0, C710_FormatWord
                BIC     r0, r0, #FW_BreakEnable         ; disable break signal
                STRB    r0, C710_FormatWord

                LDR     r0, SerialDeviceFlags
                BIC     r0, r0, #(1:SHL:SF_BreakOn):OR:(1:SHL:SF_StoppingBreak) ; finished the break completely
                STR     r0, SerialDeviceFlags

                LDRB    lr, C710_InterruptEnable
 [ Fix710TXEnable
                BIC     lr, lr, #IE_Transmit
                STRB    lr, C710_InterruptEnable
 ]
                ORR     lr, lr, #IE_Transmit            ; enable transmit interrupts again
                STRB    lr, C710_InterruptEnable

 [ No32bitCode
                EXITS
 |
                MSR     CPSR_c, r7
                EXIT
 ]

50
                Push    "lr"
                BL      ProcessLineStatusError710
                Pull    "lr"
                B       %BT15

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: enumerate710
;
; in:   r0 = reason code
;
; out:  r1 -> table of supported serial speeds (in 0.5 bit/sec)
;       r2 = number of entries in table
;
; Return a pointer to a table of supported serial speeds.
;

enumerate710
                ADRL    r1, BaudRates
                MOV     r2, #(EndNewRates - BaudRates) :SHR: 2
                MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ProcessLineStatusError710 - Generate serial error event from line status
;
; in:   r0 = line status register
;       r11 -> C710_UART
;       IRQ or SVC mode
;

ProcessLineStatusError710 Entry "r1, r2"
        TST     r0, #LS_RXFull          ; if there's a character
        LDRNEB  r2, C710_DataWord       ; then read it and pass to event

; now translate error bits

        ANDS    r1, r0, #LS_Overrun
        MOVNE   r1, #SerialError_Overrun
        TST     r0, #LS_Parity
        ORRNE   r1, r1, #SerialError_Parity
        TST     r0, #LS_Framing :OR: LS_Break   ; map framing or break errors onto framing
        ORRNE   r1, r1, #SerialError_Framing
        BL      giveerror710
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: irq710
;
; in:   r3 -> IOC
;       IRQ mode
;
; out:  -
;
; This code handles the serial interrupts from the 710 controller, this
; routine basically handles all the communication with this chip, RX and
; TX of characters.
;

irq710          Entry   "r11"

                LDR     r11, HWAddress
irq710pollloop
                LDRB    r1, C710_InterruptFlags
                AND     r1, r1, #IF_IRQBits
                TST     r1, #IF_NoInterrupt                     ; if no more interrupt causes
                BNE     irq710exit
                TEQ     r1, #IF_LineStatus
                BEQ     handle_linestatus
                TEQ     r1, #IF_RXFull
                TEQNE   r1, #IF_RXTimeout                       ; byte in RX FIFO longer than 4 character times
                BEQ     handle_rxfull
                TEQ     r1, #IF_TXEmpty
                BEQ     handle_txempty

; if none of the above, it must be...

handle_modemstatus
                LDRB    r1, C710_ModemStatus
                LDR     lr, SerialDeviceFlags
                BIC     r2, lr, #(1:SHL:SF_DCDHigh):OR:(1:SHL:SF_DSRHigh):OR:(1:SHL:SF_Ringing):OR:(1:SHL:SF_CTSHigh)

                TST     r1, #MS_CTSLow                          ; OR in state of CTS
                ORREQ   r2, r2, #1:SHL:SF_CTSHigh

                TST     r1, #MS_DSRLow                          ; OR in state of DSR
                ORREQ   r2, r2, #1:SHL:SF_DSRHigh

                TST     r1, #MS_RIHigh                          ; OR in state of RI
                ORRNE   r2, r2, #1:SHL:SF_Ringing

                TST     r1, #MS_DCDLow
                ORREQ   r2, r2, #1:SHL:SF_DCDHigh

                STR     r2, SerialDeviceFlags

; if DCD just went high and we're not ignoring it, then generate a serial error event

                TST     r2, #1:SHL:SF_DCDHigh                   ; if DCD not high now
                BEQ     DCDOK                                   ; then skip
                TST     lr, #1:SHL:SF_DCDHigh                   ; else if DCD was high already
                TSTEQ   lr, #1:SHL:SF_DCDIgnore                 ; or we're ignoring DCD
                BNE     DCDOK                                   ; then skip

                MOV     r1, #0                                  ; indicate none of PE,OV or FE
                BL      giveerror710
DCDOK

; now update TXI etc since CTS or DSR may have gone low

                BL      UpdateDTRRTSTXI710
                B       irq710pollloop                          ; go back to test other interrupts

; handle line status interrupt

handle_linestatus
                LDRB    r0, C710_LineStatus
                BL      ProcessLineStatusError710
                B       irq710pollloop                          ; go back to test other interrupts

; handle receive interrupt (even in FIFO mode we must go round poll loop for each char in case of errors)

handle_rxfull
                LDRB    r2, C710_DataWord                       ; get byte received
                LDR     r0, SerialDeviceFlags
                TST     r0, #1:SHL:SF_DCDIgnore                 ; if not ignoring DCD
                ORREQ   lr, r0, #1:SHL:SF_DCDHigh               ;     and DCD is high then
                TEQEQ   lr, r0
                BEQ     %FT20                                   ;   deal with error

                TST     r0, #1:SHL:SF_XONXOFFOn                 ; if not doing xon/xoff
                BEQ     %FT10                                   ; then skip

                TEQ     r2, #XOFFChar                           ; if it's the XOFF character
                ORREQ   r0, r0, #(1:SHL:SF_HeXOFFedMe)          ; then set bit
                STREQ   r0, SerialDeviceFlags
                BEQ     irq710pollloop                          ; and go back

                TEQ     r2, #XONChar                            ; if it's the XON character then
                BEQ     %FT30                                   ;   deal with it
10
                TST     r0, #(1:SHL:SF_RXIgnore)                ; is input supressed currently?
                BNE     irq710pollloop                          ; if so, then throw character away

                LDR     r1, InputBufferHandle                   ; get buffer handle to insert into
                CMP     r1, #-1                                 ; if there is a buffer (handle <> -1)
                BEQ     irq710pollloop

                WritePSRc SVC_mode + I_bit,r0                   ; switch to SVC mode so we can save lr_svc
                MOV     r0, #OsByte_InsertBufferCharWithEsc     ; then insert character, checking for Escape if appropriate
                Push    "lr"
                SWI     XOS_Byte                                ; NB this may cause thresholdhalt710 to be called
                Pull    "lr"
                WritePSRc IRQ_mode + I_bit,r0                   ; switch back
                B       irq710pollloop

20
                MOV     r1, #0                                  ; indicate no other errors besides DCD
                BL      giveerror710
                B       irq710pollloop

30
                BIC     r0, r0, #(1:SHL:SF_HeXOFFedMe)          ; got XON so clear bit
                STR     r0, SerialDeviceFlags

                LDRB    lr, C710_InterruptEnable
 [ Fix710TXEnable
                BIC     lr, lr, #IE_Transmit
                STRB    lr, C710_InterruptEnable
 ]
                ORR     lr, lr, #IE_Transmit                    ; and enable transmit IRQ
                STRB    lr, C710_InterruptEnable
                B       irq710pollloop

; handle transmit interrupt (in FIFO mode we can send FIFO_Size bytes)

handle_txempty
 [ NewTXStrategy
                LDR     r3, SerialDeviceFlags
                TST     r3, #1:SHL:SF_UseFIFOs                  ; if FIFOs are disabled then
                MOVEQ   r0, #0                                  ;   can only send one byte
                MOVNE   r0, #1                                  ; else assume sending 2 with FIFO enabled (would be 1 but 665 screws up timing)
                TSTNE   r3, #1:SHL:SF_FillTXFIFO                ; if we want to fill whole FIFO then
                MOVNE   r0, #FIFO_Size-1                        ;   FIFO_Size-1 bytes left to send
 |
                LDR     r3, SerialDeviceFlags
                TST     r3, #1:SHL:SF_FIFOsEnabled              ; if FIFOs are enabled then
                MOVNE   r0, #FIFO_Size-1                        ;   we have a further FIFO_Size-1 bytes to send
                                                                ;   but at a lower priority than all interrupts
                MOVEQ   r0, #0                                  ; else no further bytes to send
 ]
                STRB    r0, SerialTxByteCount
                BL      irq710txbyte                            ; send one byte now in response to interrupt
                B       irq710pollloop

irq710txbyte
; in:   r3=SerialDeviceFlags
                TST     r3, #1:SHL:SF_StoppingBreak             ; if trying to stop break then
                BNE     %FT80                                   ;   go disable TXI

                TST     r3, #1:SHL:SF_BreakOn                   ; if sending break then
                BNE     %FT60                                   ;   go do it

                MOV     r0, r3                                  ; don't corrupt r3
                TST     r0, #1:SHL:SF_CTSIgnore                 ; if ignoring CTS
                BICNE   r0, r0, #1:SHL:SF_CTSHigh               ;   then pretend its low
                TST     r0, #1:SHL:SF_DSRIgnore                 ; if ignoring DSR
                BICNE   r0, r0, #1:SHL:SF_DSRHigh               ;   then pretend its low
                TST     r0, #(1:SHL:SF_CTSHigh):OR:(1:SHL:SF_DSRHigh) ; if CTS or DSR high and not ignored,
                BNE     %FT80                                         ;   then just disable TXI

                LDRB    r2, SerialXONXOFFChar                   ; if we have to send an XON or an XOFF
                TEQ     r2, #0
                MOVNE   r1, #0
                STRNEB  r1, SerialXONXOFFChar                   ; then zero the byte to send
                BNE     %FT50                                   ; and go send the byte

                TST     r3, #(1:SHL:SF_HeXOFFedMe)              ; if we are XOFFed
                TSTEQ   r3, #(1:SHL:SF_TXDormant)               ; or no chars to send
                BNE     %FT80                                   ; then disable TXI
40
                LDR     r1, OutputBufferHandle
                CMP     r1, #-1                                 ; if no output buffer then
                BEQ     %FT70                                   ;   sleep and disable TXI

                WritePSRc SVC_mode + I_bit, r0                  ; go into SVC mode no IRQs for SWI
                NOP
                Push    "r9,lr"                                 ; save SVC_lr
                MOV     r9, #REMV
                CLRV
                SWI     XOS_CallAVector                         ; C=0 => r2=char, C=1 => buffer empty
                Pull    "r9,lr"                                 ; restore SVC_lr
            [ No32bitCode
                MOV     r0, #SVC_mode :EOR: IRQ_mode
                TEQP    r0, pc                                  ; go back to IRQ mode, preserving C (IRQ_lr unchanged)
            |
                MRS     r0, CPSR
                EOR     r0, r0, #SVC_mode :EOR: IRQ_mode
                MSR     CPSR_c, r0                              ; go back to IRQ mode, preserving C (IRQ_lr unchanged)
            ]
                BCS     %FT70                                   ; if buffer empty then sleep and disable TXI

                TST     r3, #1:SHL:SF_XONXOFFOn                 ; if not using XON/XOFF then
                BEQ     %FT50                                   ;   send the byte

                TEQ     r2, #XOFFChar                           ; else if XOFF char
                ORREQ   r3, r3, #1:SHL:SF_UserXOFFedHim         ;   then set user bit
                TEQ     r2, #XONChar                            ; else if XON char
                BICEQ   r3, r3, #1:SHL:SF_UserXOFFedHim         ;   then clear user bit
                STR     r3, SerialDeviceFlags                   ;   and store modified serial device flags
                BNE     %FT50                                   ;   and skip if not an XON character.....

                TST     r3, #1:SHL:SF_IXOFFedHim                ; if we're trying to XOFF him
                BNE     %BT40                                   ; then don't send XON, go and look for another byte
50
                STRB    r2, C710_DataWord                       ; send the byte
                MOV     pc, lr

60
                LDRB    r1, C710_FormatWord                     ; send break
                ORR     r1, r1, #FW_BreakEnable
                STRB    r1, C710_FormatWord
                MOV     r2, #0
                B       %BT50

70
                ORR     r3, r3, #1:SHL:SF_TXDormant             ; go to sleep
                STR     r3, SerialDeviceFlags
80
                LDRB    r1, C710_InterruptEnable                ; disable Tx interrupt and exit
                BIC     r1, r1, #IE_Transmit
                STRB    r1, C710_InterruptEnable

                MOV     r1, #0                                  ; don't send any more bytes
                STRB    r1, SerialTxByteCount

                MOV     pc, lr

; no more interrupt causes at present so see if we have any more bytes to stuff in the FIFO (if there is one)
; this is done here so that filling any FIFO takes a lower priority than servicing other interrupts

irq710exit
                LDRB    r1, SerialTxByteCount
                SUBS    r1, r1, #1
                EXIT    CC                                      ; exit when no more bytes to be sent
                STRB    r1, SerialTxByteCount                   ; otherwise, update count
                LDR     r3, SerialDeviceFlags                   ; and send another byte
                BL      irq710txbyte
                B       irq710pollloop                          ; then check for more interrupts

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Wake up the serial device driver for transmitting, because there are some more chars in TX buffer
;
; in:   SVC mode
;
; out:  -
;

wakeupTX710     EntryS  "r1, r11"
                LDR     r11, HWAddress
                WritePSRc SVC_mode + I_bit, lr          ; disable IRQs
                LDR     r2, SerialDeviceFlags
                BIC     r2, r2, #1:SHL:SF_TXDormant     ; indicate TX buffer no longer dormant
                STR     r2, SerialDeviceFlags
                BL      UpdateDTRRTSTXI710              ; enable TXI if appropriate
                EXITS   ,cf                             ; exit with r0 preserved => become active

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       thresholdhalt710 - Called when number of spaces in receive buffer has gone below threshold
;
; in:   r0 = reason code
;       r2 = internal handle
;       SVC mode
;

thresholdhalt710 EntryS  "r2,r11"
                LDR     lr, InputHandle                 ; only interested on input stream
                TEQ     lr, r2
                EXIT    NE

;               Palette &0000000F, r2, r11

                LDR     r11, HWAddress
                WritePSRc SVC_mode + I_bit, lr          ; disable IRQs
                LDR     r2, SerialDeviceFlags
                ORR     r2, r2, #1:SHL:SF_Thresholded

                TST     r2, #1:SHL:SF_XONXOFFOn         ; if doing XON/XOFF
                ORRNE   r2, r2, #1:SHL:SF_IXOFFedHim    ; then indicate we're XOFFing him
                STR     r2, SerialDeviceFlags

                MOVNE   lr, #XOFFChar
                STRNEB  lr, SerialXONXOFFChar           ; try to send an XOFF

                BL      UpdateDTRRTSTXI710              ; update RTS, TXI

;               Palette &00000008, r2, r11

                EXITS   ,cf

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       thresholdresume710 - Called when number of spaces in receive buffer goes back above threshold
;
; in:   r0 = reason code
;       r2 = internal handle

thresholdresume710 EntryS "r2, r11"
                LDR     lr, InputHandle
                TEQ     lr, r2
                EXIT    NE

;               Palette &400000F0, r2, r11

                LDR     r11, HWAddress
                WritePSRc SVC_mode + I_bit, lr          ; disable IRQs
                LDR     r2, SerialDeviceFlags
                BIC     r2, r2, #1:SHL:SF_Thresholded

                TST     r2, #1:SHL:SF_XONXOFFOn
                BICNE   r2, r2, #1:SHL:SF_IXOFFedHim    ; clear my XOFF bit
                STR     r2, SerialDeviceFlags
                BEQ     %FT10

                TST     r2, #1:SHL:SF_UserXOFFedHim     ; if user not XOFFing him
                MOVEQ   lr, #XONChar                    ; then send an XON
                STREQB  lr, SerialXONXOFFChar
10
                BL      UpdateDTRRTSTXI710              ; update RTS and TXI

;               Palette &40000080, r2, r11

                EXITS   ,cf

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This code generates an event about a serial error ie framing error, overrun, parity error or DCD high
;
; in:   r1 = PE, OV and FE bits where you want them
;       r2 = character if there was one (pretty useless since you don't know if there was!)
; out:  must preserve flags
;

giveerror710    EntryS  "r0-r3"
                LDR     lr, SerialDeviceFlags
                TST     lr, #1:SHL:SF_DCDHigh
                ORRNE   r1, r1, #SerialError_DCD
                TST     lr, #1:SHL:SF_DSRHigh
                ORRNE   r1, r1, #SerialError_DSR

                SETPSR  SVC_mode, lr,, r3                               ; switch into SVC mode
                NOP

                Push    "lr"
                MOV     r0, #Event_RS423Error
                SWI     XOS_GenerateEvent                               ; and then generate event
                Pull    "lr"                                            ; preserve SVC LR

                RestPSR r3                                              ; restore original mode
                NOP

                EXITS   ,cf

 [ KickSerialTX

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; SetTXKick - set up a call every to kick serial TX every 0.5s
;
; out:  all registers and flags preserved
;
; This works round a problem with the SMC665 and C&T710 where TX irqs can stop
; dead for no apparent reason. The call every 0.5s toggles the TX enable bit if
; set so that TX irqs are kept going. The call back is harmless in normal
; operation.
;

SetTXKick
                Entry   "r0-r2"
                MOV     r0, #49                                         ; 50cs - 1
                ADR     r1, KickTX
                LDR     r2, HWAddress
                SWI     XOS_CallEvery
                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; RemoveTXKick
;
; out:  all registers and flags preserved
;
; Remove the call every set up above.
;

RemoveTXKick
                Entry   "r0,r1"
                ADR     r0, KickTX
                LDR     r1, HWAddress
                SWI     XOS_RemoveTickerEvent
                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; KickTX
;
; Called every 0.5s when serial output is open. Toggles TX interrupt enable bit
; if TX irqs are enabled. This fixes problem with TX irqs stopping for no
; apparent reason on SMC665 and C&T710.
;

KickTX
                Entry   "r0"
                LDRB    r0, [r12, #:INDEX:C710_InterruptEnable]
                TST     r0, #IE_Transmit
                BICNE   lr, r0, #IE_Transmit
                STRNEB  lr, [r12, #:INDEX:C710_InterruptEnable]
                STRNEB  r0, [r12, #:INDEX:C710_InterruptEnable]
                EXIT

 ]

                END

@


4.9
log
@Minor switch clear up
* Remove CMOS_BackCompat switch, that CMOS bit has twice been reallocated
* Use Hdr:OsBytes for OS_Byte definitions
* Allow 'international' to be passed in from outside
* Match EXITS with EntryS in old 6551 code
* true and false use ObjAsm's {TRUE} and {FALSE}
Same binary, no problems anticipated.

Version 0.46. Tagged as 'Serial-0_46'
@
text
@d25 2
d29 2
d399 1
a399 5
 [ PCIHardware
                MOV     r0, #PCI_DeviceNo
 |
                MOV     r0, #IOEB_Serial_DevNo
 ]
d410 1
a410 1
 [ PCIHardware :LOR: HAL
d412 1
a412 5
  [ PCIHardware
                MOV     r0, #PCI_DeviceNo
  |
                MOV     r0, #IOEB_Serial_DevNo
  ]
d461 1
a461 5
 [ PCIHardware
                MOV     r0, #PCI_DeviceNo
 |
                MOV     r0, #Serial_DevNo
 ]
@


4.8
log
@Add implementation of OS_SerialOp 10
Detail:
  hdr/Serial - Added new internal device call number which is issued for OS_SerialOp 10
  s/Common, s/Serial6551, s/Serial710 - Update device call entry points to add support for the new call
Admin:
  Tested in Iyonix ROM softload


Version 0.45. Tagged as 'Serial-0_45'
@
text
@d110 1
a110 1
Combo			* &03010000
d112 4
a115 4
SMIindex		* &3A8
SMIaccess		* &3AC
SMIENBL1		* &0C
serial1_bit		* 8
d423 1
a423 1
 		LDR	r1, =Combo
d429 2
a430 2
                MOV	r0, #SMIENBL1
		STR	r0, [r1, #SMIindex]
d1355 1
a1355 1
                MOV     r0, #OSByte_InsertESC                   ; then insert character, checking for Escape if appropriate
@


4.7
log
@Determine need for IRQ delay at runtime, not with StrongARM switch.
Resolve deprecated pop instruction.

Version 0.44. Tagged as 'Serial-0_44'
@
text
@d202 1
@


4.6
log
@Update SerialDeviceDriver for use with PCIless HAL builds
Detail:
  s/Init - For PCIless HAL builds, use HAL_ControllerAddress to get the 82C710 address
  s/Serial - Only enable PCIHardware for M_Tungsten
  s/Serial710 - Assume IOMD/IOEB IRQ number if not PCIHardware
Admin:
  Tested in Iyonix & IOMD ROM softloads


Version 0.42. Tagged as 'Serial-0_42'
@
text
@d143 1
a143 1
; relevant parameters.  This is mainly to save lots of fafing around in
d1109 1
a1109 1
nobreak710      Entry   "r0,r7,r11"
d1127 1
d1147 1
d1153 3
a1155 9
 [ StrongARM
                ;StrongARM core will not see interrupt unless disable is cleared for at least 5 cycles,
                ;in order to fill synchroniser pipe
                NOP
                NOP
                NOP
                NOP
                NOP
 ]
@


4.5
log
@Commit of Kevin's 32-bit, PCI-aware SerialDeviceDriver.
I've upped the version number because it's silly to claim that a PCI serial
driver was written in 2001.

Version 0.40. Tagged as 'Serial-0_40'
@
text
@d109 1
d111 1
d409 1
a409 1
 [ PCIHardware
d411 1
d413 4
@


4.4
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.39. Tagged as 'Serial-0_39'
@
text
@d23 5
a27 1
C710_UART               * C710 + &3F8*4 ; -> base of 710 UART
d30 2
a31 2
C710_DataWord           # 4             ; byte wide data port
C710_InterruptEnable    # 4             ; interrupt enable bits
d33 5
a37 5
C710_InterruptFlags     # 4             ; flags to indicate what sort of interrupt
C710_FormatWord         # 4             ; format word
C710_ModemControl       # 4             ; control register
C710_LineStatus         # 4             ; current line status
C710_ModemStatus        # 4             ; modem status
d40 2
a41 2
C710_BaudDivisorLSB     # 4             ; bottom 8 bits of baud divisor (only accessable when DRAB =1)
C710_BaudDivisorMSB     # 4             ; top 8 bits of baud divisor (only accessed when DRAB =1)
a146 2
                BIC     lr, lr, #VFlag

d156 1
a156 1
                MOVS    pc, lr
d161 3
a163 3
                MOVS    pc, lr                          ; wake up for RX
                MOVS    pc, lr                          ; sleep rx
                MOVS    pc, lr                          ; enum dir
d168 1
a168 1
                MOVS    pc, lr                          ; eod
d233 1
d235 1
a235 1
                BLNE    SetTXKick                       ; if TX then set up call every to kick serial
d238 1
a238 1
                EXITS   EQ
d242 1
a242 1
                TEQ     r0, lr
d244 1
a244 1
                EXITS   EQ
d252 2
a253 2
                STRNE   r2, OutputHandle
                EXITS
d255 3
d304 2
a305 1
                EXITS
d333 2
a334 1
                EXITS
d336 2
a337 2
UpdateRTSForegd Entry   "r2, r11"
                TEQP    pc, #SVC_mode + I_bit                   ; update RTS call require IRQs off
d339 1
a339 1
                LDR     r11, =C710_UART                         ; and r11 -> UART
d341 1
a341 1
                EXITS
d365 1
a365 1
                LDR     r11, =C710_UART                                 ; -> UART
d392 3
d396 1
d407 7
d419 1
a419 3
                MOV     lr, pc
                ORR     lr, lr, #I_bit                                  ; disable IRQs while IOCIRQMSKB updated
                TEQP    lr, #0
d431 3
a433 1
                EXITS                                                   ; exit (restoring interrupt state)
d455 1
a455 1
                EXITS   EQ
d457 3
d461 1
d471 1
a471 1
                EXITS
d532 3
a534 3
                TEQ     r1, r3                                          ; will the call invoke any change?
                TEQEQ   r2, r4
                EXITS   EQ                                              ; no, so don't bother return now!
d564 1
a564 1
                LDR     r11, =C710_UART                                 ; r11 -> uart base
d600 2
a601 1
                EXITS
d627 3
d748 1
a748 1
change710flags  Entry   "r8-r11"
d752 1
a752 1
                LDR     r11, =C710_UART                                 ; r11 -> UART base
d764 1
a764 1
                TEQP    pc, #SVC_mode + I_bit                           ; disable IRQs
d796 7
a802 3
                BLNE    SetFIFO                                         ; if so, then update FIFO
                BLNE    UpdateDTRRTSTXI710                              ; if so, then update DTR, RTS and TXI
                EXITS
d815 1
a815 1
;       All other regs preserved (including flags)
d822 1
a822 1
                EXITS   EQ                                              ;   nothing to do
d856 1
a856 1
                EXITS
d936 1
a936 1
                EXITS
d946 1
a946 1
                EXITS
d1009 1
a1009 1
                LDR     r11, =C710_UART                                 ; -> 710 uart
d1011 1
a1011 1
                TEQP    pc, #SVC_mode + I_bit                           ; disable IRQs round updates to FormatWord
d1036 1
d1038 1
a1038 1
                EXITS
d1061 1
a1061 1
break710        Entry   "r0, r11"
d1065 1
a1065 1
                TEQP    pc, #SVC_mode + I_bit                   ; disable IRQs round this bit
d1067 1
a1067 1
                LDR     r11, =C710_UART
d1082 1
a1082 1
                EXITS
d1102 1
a1102 1
nobreak710      Entry   "r0,r11"
d1106 1
d1113 5
d1119 1
a1119 1
                LDR     r11, =C710_UART
d1139 1
d1141 3
d1153 1
d1155 4
d1178 1
d1180 4
d1240 1
a1240 1
        EXITS
d1263 1
a1263 1
                LDR     r11, =C710_UART
d1350 1
a1350 1
                TEQP    pc, #SVC_mode + I_bit                   ; switch to SVC mode so we can save lr_svc
d1355 1
a1355 1
                TEQP    pc, #IRQ_mode + I_bit                   ; switch back
d1427 1
a1427 1
                TEQP    pc, #SVC_mode + I_bit                   ; go into SVC mode no IRQs for SWI
d1434 1
d1437 5
d1486 1
a1486 1
                EXITS   CC                                      ; exit when no more bytes to be sent
d1506 3
a1508 3
wakeupTX710     Entry   "r1, r11"
                LDR     r11, =C710_UART
                TEQP    pc, #SVC_mode + I_bit
d1513 1
a1513 1
                EXITS                                   ; exit with r0 preserved => become active
d1524 1
a1524 1
thresholdhalt710 Entry  "r2,r11"
d1527 1
a1527 1
                EXITS   NE
d1531 2
a1532 2
                LDR     r11, =C710_UART
                TEQP    PC, #SVC_mode + I_bit           ; disable IRQs
d1547 1
a1547 1
                EXITS
d1556 1
a1556 1
thresholdresume710 Entry "r2, r11"
d1559 1
a1559 1
                EXITS   NE
d1563 2
a1564 2
                LDR     r11, =C710_UART
                TEQP    PC, #SVC_mode + I_bit           ; disable IRQs
d1581 1
a1581 1
                EXITS
d1592 1
a1592 1
giveerror710    Entry   "r0-r3"
d1599 1
a1599 4
                MOV     lr, pc
                AND     lr, lr, #3
                EOR     r3, lr, #SVC_mode                               ; switch into SVC mode
                TEQP    r3, pc
d1607 1
a1607 1
                TEQP    r3, pc                                          ; restore original mode
d1610 1
a1610 1
                EXITS
d1630 1
a1630 1
                LDR     r2, =C710_UART + 4
d1632 2
a1633 1
                EXITS
d1647 1
a1647 1
                LDR     r1, =C710_UART + 4
d1649 2
a1650 1
                EXITS
d1663 1
a1663 1
                LDRB    r0, [r12]
d1666 3
a1668 3
                STRNEB  lr, [r12]
                STRNEB  r0, [r12]
                EXITS
@


4.3
log
@Ursula branch merged.
PhoebeHardware switch turned off, CMOS_BackCompat set to :LNOT:STB.
Service call table added.
Changed to use srccommit.

Version 0.37. Tagged as 'Serial-0_37'
@
text
@d222 1
a222 1
open710         ENTRY   "r0"
d272 1
a272 1
close710        ENTRY   "r0-r2"
d320 1
a320 1
newstream710    ENTRY   "r0-r2"
d328 1
a328 1
UpdateRTSForegd ENTRY   "r2, r11"
d356 1
a356 1
reset710        ENTRY   "r0-r3, r11"
d433 1
a433 1
remove710       ENTRY   "r0-r3"
d483 1
a483 1
setbaud710      ENTRY   "r0, r5, r11"
d721 1
a721 1
change710flags  ENTRY   "r8-r11"
d787 1
a787 1
SetFIFO         ENTRY   "r1"
d841 1
a841 1
UpdateDTRRTSTXI710 ENTRY   "r0"
d976 1
a976 1
change710format ENTRY   "r9-r11"
d1029 1
a1029 1
break710        ENTRY   "r0, r11"
d1070 1
a1070 1
nobreak710      ENTRY   "r0,r11"
d1175 1
a1175 1
ProcessLineStatusError710 ENTRY "r1, r2"
d1209 1
a1209 1
irq710          ENTRY   "r11"
d1448 1
a1448 1
wakeupTX710     ENTRY   "r1, r11"
d1466 1
a1466 1
thresholdhalt710 ENTRY  "r2,r11"
d1498 1
a1498 1
thresholdresume710 ENTRY "r2, r11"
d1534 1
a1534 1
giveerror710    ENTRY   "r0-r3"
d1572 1
a1572 1
                ENTRY   "r0-r2"
d1589 1
a1589 1
                ENTRY   "r0,r1"
d1605 1
a1605 1
                ENTRY   "r0"
@


4.2
log
@Version RO_3_71 merged
@
text
@d104 8
d395 3
d399 1
a399 1

d403 7
a409 1

d413 1
a413 1

@


4.2.2.1
log
@erial module which supports the backwards compatibility CMOS bit (0x0b:7)
@
text
@a103 8
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Combo			* &03010000
SMIindex		* &3A8
SMIaccess		* &3AC
SMIENBL1		* &0C
serial1_bit		* 8


a386 3
 [ PhoebeHardware
 		LDR	r1, =Combo
 |
d388 1
a388 1
 ]
d392 1
a392 7
 [ PhoebeHardware
                MOV	r0, #SMIENBL1
		STR	r0, [r1, #SMIindex]
                LDR     r0, [r1, #SMIaccess]
                ORR     r0, r0, #serial1_bit
                STR     r0, [r1, #SMIaccess]
 |
d396 1
a396 1
 ]
@


4.1
log
@Initial revision
@
text
@d966 1
a966 1
                
d1085 9
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.3.2
log
@Version RO_3_71 taken
@
text
@d966 1
a966 1

a1084 9
 [ StrongARM
                ;StrongARM core will not see interrupt unless disable is cleared for at least 5 cycles,
                ;in order to fill synchroniser pipe
                NOP
                NOP
                NOP
                NOP
                NOP
 ]
@


4.1.3.1.2.1
log
@Merged in from 3.71 CD
@
text
@d966 1
a966 1

a1084 9
 [ StrongARM
                ;StrongARM core will not see interrupt unless disable is cleared for at least 5 cycles,
                ;in order to fill synchroniser pipe
                NOP
                NOP
                NOP
                NOP
                NOP
 ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

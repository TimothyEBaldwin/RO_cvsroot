head	4.10;
access;
symbols
	Serial-0_47:4.10
	Serial-0_46:4.9
	Serial-0_45:4.8
	Serial-0_44:4.8
	Serial-0_43:4.6
	Serial-0_42:4.5
	Serial-0_41:4.4
	RO_5_07:4.4
	Serial-0_40:4.4
	Serial-0_39:4.3
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	Serial-0_38:4.2
	Ursula_merge:4.1.4.1
	Serial-0_37:4.2
	nturton_Serial-0_35:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_Serial_0_34:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2013.01.14.09.20.56;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	r811zrT2fNc1Q9Aw;

4.9
date	2013.01.05.21.37.46;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	jwUKqlU2NAFJc4zw;

4.8
date	2011.11.27.09.19.40;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	E2M9ey2NioUz8XIv;

4.7
date	2011.11.26.23.17.27;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	VIfzlTfHNQj3OTIv;

4.6
date	2011.07.18.22.44.00;	author jlee;	state Exp;
branches;
next	4.5;
commitid	SFkdKxEuhP1EP3sv;

4.5
date	2011.06.22.00.39.29;	author jlee;	state Exp;
branches;
next	4.4;
commitid	7AENLsN77du4lBov;

4.4
date	2003.11.13.17.02.57;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2001.03.16.16.02.39;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.08.16.12.57.21;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.37.26;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.37.26;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.41.19;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.09.07.13.50.50;	author wturner;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.02.07;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.54.07;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Get PCIHardware option from the components file
No longer switches on M_Tungsten.

Version 0.47. Tagged as 'Serial-0_47'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Init

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                        ^ 0, wp
; word variables

Flags                   # 4
Platform                # 4             ;  = platform ID for hardware (0 = 6551, 1 = 82C710)
DeviceVector            # 4             ; -> routine to call to access device
DeviceHandle            # 4             ;  = handle for DeviceFS calls

; very device specific variables

SerialDeviceFlags       # 4             ;  = serial flags
SerialRXBaud            # 1             ;  = baud rate (8bit) for RX
SerialTXBaud            # 1             ;  = baud rate (8bit) for TX
SerialXONXOFFChar       # 1             ;  = serial XON/XOFF character (8bit)
SerialCurrentError      # 1             ;  = current internal error code (8bit)
SerialThreshold         # 4             ;  = threshold value being used
 [ :LNOT: NewTXStrategy
SerialBaudDivisor       # 4             ;  = current baud divisor (for 710/711/665)
 ]
SerialTxByteCount       # 1             ;  = used by TX IRQ routine to count bytes left to send
                        # 1             ;  = unused
                        # 1             ;  = unused
                        # 1             ;  = unused

InputHandle             # 4             ;  = DeviceFS handle used for input stream
OutputHandle            # 4             ;  = DeviceFS handle used for output stream

InputBufferHandle       # 4             ;  = buffer handle used for input stream  (-1 if none)
OutputBufferHandle      # 4             ;  = buffer handle used for output stream (-1 if none)

PutCharOutputFileHandle # 4             ;  = file handle for putchar stream (0 if none)

HWAddress               # 4             ;  = address of controller

WaitForIRQsToFire       # 4             ; -> routine to allow pending IRQs to fire

; now some power control variables (only valid on machines with 82C710/711)

portable_present        # 4             ;  = 0 if we don't think the Portable module is present
                                        ;  = 1 if we do
power_state             # 4             ;  bit 3  set if power to serial buffer enabled
                                        ;  bit 12 set if power to 711 oscillator must be enabled
                                        ;  all other bits clear

                      [ international
                        AlignSpace
MessagesWorkspace       # 16            ;  = workspace needed for messages routines
                      ]

workspace               * :INDEX: @@


; define global flags etc used by the module

f_SerialIRQ             * 1:SHL:0       ; set => IRQ owned for serial device
f_SerialFIQ             * 1:SHL:1       ; set => FIQ owned for serial device
f_WeHaveMessages        * 1:SHL:2       ; set => we have messages
f_UseFIFOs              * 1:SHL:3       ; set => we can use FIFOs
f_FIFOsEnabled          * 1:SHL:4       ; set => FIFOs are enabled

f_IRQmask               * 2_11

hw_6551                 * 0             ; hardware type
hw_IOEB                 * 1
hw_PCI                  * 2

SerialPowerBits * PortableControl_SerialEnable

 [ :LNOT: HAL
IOC_UARTAddress         * C710 + &3F8*4 ; where the serial port lives in IOC world
 |
IOC_UARTOffset          * &3F8*4        ; offset from C710 for HAL version
 ]
PCI_UARTAddress         * &3F8          ; where the serial port lives in PCI version (yuck)
PCI_DeviceNo            * 25            ; and its interrupt (aargh)

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

module          & 0
                & init -module                          ; => initalise routine
                & final -module                         ; => finalise routine
                & service -module                       ; => service trap

                & title -module                         ; => title string
                & help -module                          ; => help string
                & 0
 [ :LNOT: No32bitCode
                & 0
                & 0
                & 0
                & 0
                & 0
                & modflags -module
 ]

title           = "SerialDeviceDriver", 0
help            = "Serial Device", 9, "$Module_HelpVersion"
              [ debug
                = " Development version"
              ]
                = 0
                ALIGN

printertype     = "Set PrinterType$2 devices#buffer3:$."
devicename      = "Serial", 0

              [ international
resource_file   = "Resources:$.Resources.Serial.Messages", 0
              ]
                ALIGN

modflags        & ModuleFlag_32bit

deviceblock     & devicename -deviceblock
                & DeviceFlag_BufferedDevice+ DeviceFlag_DefinePathVariable
                & 0                                     ; default RX buffer flags
                & 256                                   ; default RX buffer size
                & 0                                     ; default TX buffer flags
                & 192                                   ; default TX buffer size
                & 0                                     ; reserved field (must be zero)

                & 0                                     ; end of table

                MakeErrorBlock Serial_BadHardware
                MakeErrorBlock Serial_BadControlOp
                MakeErrorBlock Serial_BadBaud
                MakeErrorBlock Serial_InUse

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This code handles the startup of the module, the routine most claim the
; required workspace and then initialise the driver (via a callback).
;

init            Entry
                Debug   init, "Device being installed"

                LDR     r2, [wp]
                TEQ     r2, #0                          ; any workspace / warm start?
                BNE     %10

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =workspace                  ; r3  = amount of workspace
                SWI     XOS_Module
                EXIT    VS                              ; return if didn't work

                Debug   init, "Workspace allocated at:", r2

                STR     r2, [wp]
10
                MOV     wp, r2                          ; wp -> workspace

 [ standalone
                ADRL    r0, resourcefsfiles
                SWI     XResourceFS_RegisterFiles   ; ignore errors (starts on Service_ResourceFSStarting)
 ]

                MOV     r0, #0
                STR     r0, Flags                       ; reset flags + device handle
                STR     r0, DeviceHandle
                STR     r0, InputHandle                 ; no streams open currently
                STR     r0, OutputHandle
                STRB    r0, SerialXONXOFFChar           ; and current errors and serial codes
                STRB    r0, SerialCurrentError
                STRB    r0, SerialTxByteCount
                STR     r0, PutCharOutputFileHandle     ; don't have a stream open for putchar
 [ :LNOT: NewTXStrategy
                STR     r0, SerialBaudDivisor
 ]

                MOV     r0, #-1
                STR     r0, InputBufferHandle
                STR     r0, OutputBufferHandle

                MOV     r0, #0                          ; Read feature flags and address of IRQ delay routine too
                MOV     r1, #0                          ; In case of unknown SWI error
                SWI     XOS_PlatformFeatures
                STR     r1, WaitForIRQsToFire

                MOV     r0, #2                          ; =2, read machine hardware type
                SWI     XOS_ReadSysInfo
                EXIT    VS                              ; return if it went wrong!!!

                BIC     r0, r0, #&FF :SHL: 24           ; Not interested in video controller
                BIC     r0, r0, #&FF :SHL: 16           ;   or memory controller.
                AND     r1, r1, #&FF                    ; Only interested in I/O chip type.

 [ OldHardware
                TEQ     r0, #&0000                      ; is it IOC with no IOEB (ie. A1)?
                MOVEQ   r0, #hw_6551
                ADDR    r1, SerialACIA, EQ
                BEQ     %15                             ; yes.
 ]
 [ NewHardware
  [ PCIHardware
                MOV     r0, #1:SHL:30
                LDR     r1, =PCI_UARTAddress
                MOV     r2, #8
                SWI     XPCI_LogicalAddress             ; just look for PCI
                BVS     init_BadHardware

                STR     r4, HWAddress                   ; remember the address

                LDR     r0, Flags                       ; assume FIFOs
                ORR     r0, r0, #f_UseFIFOs
                STR     r0, Flags

                MOV     r0, #hw_PCI
                ADDR    r1, Serial710
                B       %15
  |
                TEQ     r0, #&0001                      ; no, so does it have IOEB
                TEQNE   r0, #&0100                      ; or an IOMD
                TEQEQ   r1, #&01                        ; and a 82C710/711 (or similar)?
                BNE     init_BadHardware                ; No then jump, bad hardware

                MOV     r0, #3
                SWI     XOS_ReadSysInfo                 ; Read hardware particulars
                BVS     init_BadHardware                ; Jump if error

                AND     r0, r0, #(15:SHL:12)            ; Get serial h/w type
                TEQ     r0, #(1:SHL:12)                 ; Do we understand it?
                BNE     init_BadHardware                ; No then jump, bad hardware

                AND     r1, r1, #(15:SHL:12)            ; Get serial extra features
                TEQ     r1, #(1:SHL:12)                 ; If it has FIFOs then
                LDREQ   r0, Flags
                ORREQ   r0, r0, #f_UseFIFOs             ;   set flag
                STREQ   r0, Flags

   [ HAL
                MOV     r0, #9
                MOV     r1, #34<<8
                SWI     XOS_Memory
                BVS     init_BadHardware
                CMP     r1, #0
                BEQ     init_BadHardware
                ADD     r0, r1, #IOC_UARTOffset
   |     
                LDR     r0, =IOC_UARTAddress
   ]            
                STR     r0, HWAddress                   ; note the base address

                MOV     r0, #hw_IOEB                    ; h/w recognized (covers IOMD too)
                ADDR    r1, Serial710                   ; Handler address
                B       %FT15
  ]
 ]
init_BadHardware
                ADR     r0, ErrorBlock_Serial_BadHardware ; H/w not recognized
                PullEnv                               ; tidy stack
                DoError                               ; and return an error

15
                ASSERT  DeviceVector = Platform + 4
                ADR     r2, Platform
                STMIA   r2, {r0, r1}                    ; write device type + vector

                Debug   init, "Hardware platform:", r0, r1
                Debug   init, "Resetting the platform"

                MOV     r0, #-1
                STRB    r0, SerialRXBaud                ; reset copies of baud settings
                STRB    r0, SerialTXBaud

                BL      RegisterDevice
                BL      InitialiseSerial
                CMP     r0, #0                          ; clear V
                EXIT

; initialise serial drivers, set baud rate and data format from CMOS

InitialiseSerial Entry
                MOV     r0, #0
                STR     r0, power_state                 ; set power_state to OFF
                MOV     r1, #1                          ; and pretend portable module present
                STR     r1, portable_present            ; at least until we know better
                LDR     r1, Flags
                TST     r1, #f_UseFIFOs                 ; if we can use FIFOs then
                MOVNE   r0, #1:SHL:SF_UseFIFOs          ;    flag in device flags
                STR     r0, SerialDeviceFlags           ; but just store 0 from above if we can't

                MOV     r0, #serialctrl_Reset
                BL      CallDevice                      ; reset the serial device

                MOV     r0, #OsByte_ReadCMOS
                MOV     r1, #PSITCMOS
                SWI     XOS_Byte
                MOVVC   r2, r2, LSR #2                  ; if succeeded, shift bits down
                ANDVC   r2, r2, #2_111                  ; extract relevant bits (0 => 75, ... ,7 => 19200)
                ADDVC   r2, r2, #1                      ; 1 => 75, ... ,8 => 19200
                MOVVS   r2, #0                          ; use 9600 if error

                Debug   init, "RX/TX baud rates:", r2

                MOV     r0, #serialctrl_ChangeBaud
                MOV     r1, r2                          ; RX = TX
                BL      CallDevice

                MOV     r0, #OsByte_ReadCMOS
                MOV     r1, #DBTBCMOS
                SWI     XOS_Byte
                MOVVC   r2, r2, LSR #5
                ANDVC   r2, r2, #2_111                  ; r2 => serial data format
                MOVVS   r2, #4                          ; default to 8n2 if error
                ADR     r1, datatable
                LDRB    r1, [r1, r2]                    ; convert from configured value to usable value

                Debug   init, "Data format word:", r1

                MOV     r0, #serialctrl_ChangeDataFormat
                BL      CallDevice                      ; call device informing of format changes

                MOV     r0, #OsByte_RW_SerialBufferThreshold
                MOV     r1, #0
                MOV     r2, #&FF                        ; read buffer minimum space
                SWI     XOS_Byte
                MOVVS   r1, #17                         ; if that failed then setup a value
                STR     r1, SerialThreshold             ; and store it away in workspace

                BL      SetPower_Off                    ; power not needed

                EXIT

datatable
                = (1:SHL:0)+ (1:SHL:4)+ (1:SHL:2)+ (1:SHL:3)
                = (1:SHL:0)+ (0:SHL:4)+ (1:SHL:2)+ (1:SHL:3)
                = (1:SHL:0)+ (1:SHL:4)+ (0:SHL:2)+ (1:SHL:3)
                = (1:SHL:0)+ (0:SHL:4)+ (0:SHL:2)+ (1:SHL:3)
                = (0:SHL:0)+ (0:SHL:4)+ (1:SHL:2)+ (0:SHL:3)
                = (0:SHL:0)+ (0:SHL:4)+ (0:SHL:2)+ (0:SHL:3)
                = (0:SHL:0)+ (1:SHL:4)+ (0:SHL:2)+ (1:SHL:3)
                = (0:SHL:0)+ (0:SHL:4)+ (0:SHL:2)+ (1:SHL:3)

                ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle module close down.
;

final           Entry
                LDR     wp, [wp]                        ; -> workspace claimed


                LDR     r0, OutputHandle
                TEQ     r0, #0                          ; Output stream open?
                LDREQ   r0, InputHandle
                TEQEQ   r0, #0                          ; Or input stream open?

                PullEnv NE
                ADDR    r0, ErrorBlock_Serial_InUse, NE
                DoError NE                              ; yes, so return error

                LDR     r0, DeviceHandle                ; am I registered with DeviceFS?
                TEQ     r0, #0
                BEQ     %FT10                           ; no, then jump

                SWI     XDeviceFS_Deregister            ; Closes all streams, ignore errors
                MOV     r0, #0
                STR     r0, DeviceHandle                ; zero the device handle

10              MOV     r1, #Service_SerialDevice
                MOV     r2, #0                          ; from the Serial Device to Serial Support module
                SWI     XOS_ServiceCall                 ; tell them I have died

                MOV     r0, #serialctrl_Dying
                BL      CallDevice                      ; ensure device quiescent

              [ international
                BL      CloseMessages                   ; close any messages files
              ]

 [ standalone
                ADRL    R0, resourcefsfiles
                SWI     XResourceFS_DeregisterFiles
 ]
                CMP     r0, #0                          ; clear V
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle service calls received by the module.
;

                ASSERT  Service_Reset < Service_ResourceFSStarting
                ASSERT  Service_ResourceFSStarting < Service_DeviceFSStarting
                ASSERT  Service_DeviceFSStarting < Service_DeviceFSDying
                ASSERT  Service_DeviceFSDying < Service_SerialDevice
                ASSERT  Service_SerialDevice < Service_DeviceFSCloseRequest
                ASSERT  Service_DeviceFSCloseRequest < Service_Portable
servicetable    DCD     0
                DCD     serviceentry -module
                DCD     Service_Reset
                DCD     Service_ResourceFSStarting
                DCD     Service_DeviceFSStarting
                DCD     Service_DeviceFSDying
                DCD     Service_SerialDevice
                DCD     Service_DeviceFSCloseRequest
                DCD     Service_Portable
                DCD     0

                DCD     servicetable -module
service         ROUT
                MOV     r0, r0
                TEQ     r1, #Service_DeviceFSStarting
                TEQNE   r1, #Service_DeviceFSDying
                TEQNE   r1, #Service_DeviceFSCloseRequest
                TEQNE   r1, #Service_SerialDevice
                TEQNE   r1, #Service_Portable
                TEQNE   r1, #Service_Reset
 [ standalone
                TEQNE   r1, #Service_ResourceFSStarting
 ]
                MOVNE   pc, lr

serviceentry    LDR     wp, [wp]

                TEQ     r1, #Service_DeviceFSStarting
                BEQ     RegisterDevice                  ; attempt to register the device

                TEQ     r1, #Service_DeviceFSDying
                STREQ   r0, DeviceHandle

                TEQ     r1, #Service_DeviceFSCloseRequest
                BNE     %FT20

                Push    "r0-r1,lr"
                LDR     r1, PutCharOutputFileHandle
                TEQ     r1, r2
                Pull    "r0-r1,pc",NE                   ; if not our handle, then pass on service

                MOV     r0, #0                          ; our file handle is not in use any more
                STR     r0, PutCharOutputFileHandle     ; so zero it
                STR     r0, [sp, #1*4]                  ; indicate we've closed it on exit too
                SWI     XOS_Find                        ; close file, ignore errors
                Pull    "r0-r1,pc"

20
 [ standalone
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT30
                Push    "r0-r3,lr"
                ADRL    r0, resourcefsfiles
                MOV     lr, pc
                MOV     pc, r2
                Pull    "r0-r3,pc"
30
 ]
                TEQ     r1, #Service_SerialDevice
                CMPEQ   r2, #-1                         ; is it from Serial Support?
                LDREQ   r0, DeviceHandle                ; yes, so setup device handle
                MOVEQ   r1, #Service_Serviced

                TEQ     r1, #Service_Portable
                BNE     %FT40
                TEQ     r2, #ServicePortable_PowerDown
                BNE     %FT35

                Push    "r0,r2,lr"
                MOV     lr, #1
                STR     lr, portable_present            ; indicate portable module present
                LDR     lr, =SerialPowerBits
                TST     r3, lr                          ; are they trying to power down serial
                Pull    "r0,r2,pc",EQ                   ; no then just pass on the service

                LDR     r0, InputHandle                 ; if either input stream
                LDR     r2, OutputHandle                ; or output stream are open (non-zero handle)
                ORRS    r0, r0, r2                      ; then complain
                BEQ     %FT32                           ; [both closed, so OK]
                BICS    r3, r3, lr                      ; by clearing the serial bits
                MOVEQ   r1, #0                          ; and if there are no more bits being turned off
                Pull    "r0,r2,pc"                      ; then claim service to save time
32
                LDR     r0, power_state                 ; update our record of which bits are on
                BIC     r0, r0, r3
                STR     r0, power_state
                Pull    "r0,r2,pc"

35
                TEQ     r2, #ServicePortable_PowerUp    ; bits being powered up
                MOVNE   pc, lr
                Push    "r0,r3,lr"
                MOV     lr, #1
                STR     lr, portable_present            ; indicate portable module present
                LDR     lr, =SerialPowerBits
                AND     r3, r3, lr                      ; just get serial bits which are being powered up
                LDR     r0, power_state
                ORR     r0, r0, r3                      ; and or them into our current state
                STR     r0, power_state
                Pull    "r0,r3,pc"

40
                TEQ     r1, #Service_Reset              ; is it a Service_Reset?
                MOVNE   pc, lr

                Push    "r0-r2, lr"                     ; yes, so check it's a soft reset

                MOV     r0, #OsByte_RW_LastResetType
                MOV     r1, #0
                MOV     r2, #&FF
                SWI     XOS_Byte
                TEQ     r1, #0

                Pull    "r0-r2, pc",NE                  ; not soft reset, so ignore

                LDR     r0, Flags
                BIC     r0, r0, #f_IRQmask
                STR     r0, Flags                       ; mark vectors as not owned

                MOV     r0, #0
                STR     r0, PutCharOutputFileHandle

                BL      InitialiseSerial                ; set up baud rates etc from CMOS

                Pull    "r0-r2, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; RegisterDevice, this code handles the registering of a device within
; DeviceFS.  Once installed the code will then attempt to setup the device
; handle and then issue the service call that informs the world that
; DeviceFS is now present.
;

RegisterDevice  Entry   "r0-r7"
                MOV     r0, #ParentFlag_FullDuplex      ;    device is full duplex
                ADRL    r1, deviceblock                 ; -> device information block
                LDR     r2, DeviceVector                ; -> code to call for device
                MOV     r3, #0
                MOV     r4, wp                          ; -> workspace for the device
                MOV     r5, #0                          ;    special fields are allowed
                MOV     r6, #1
                MOV     r7, #1                          ; number of input and output streams
                SWI     XDeviceFS_Register
                STRVS   r0, [sp]
                BVS     %FT90                           ; return if it did not work

                Debug   init, "device handle", r0

                STR     r0, DeviceHandle                ; stash the device handle

                MOV     r1, #Service_SerialDevice
                MOV     r2, #0                          ; from me to Serial Support module
                SWI     XOS_ServiceCall

                ADDR    r0, printertype
                SWI     XOS_CLI                         ; define the system variable for printing
90              CMP     r0, #0                          ; clear V
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Power management routines
;

SetPower_On     Entry   "r0,r1"
                LDR     r0, =SerialPowerBits
                B       SetPower                        ; turn on power


SetPower_Off    ALTENTRY
                MOV     r0, #0                          ; turn power off

; and drop thru to...

SetPower        ROUT
                LDR     lr, portable_present            ; if no portable module present
                TEQ     lr, #0
                EXIT    EQ                              ; then do nothing

                LDR     lr, power_state                 ; if current state = new state, do nothing
                TEQ     r0, lr
                EXIT    EQ

                LDR     r1, =:NOT: SerialPowerBits
                SWI     XPortable_Control               ; new = (old AND r1) EOR r0
                STRVC   r1, power_state
                EXIT    VC

                MOV     r0, #0                          ; if we got an error
                STR     r0, portable_present            ; then set portable_present = FALSE
                LDR     r0, =SerialPowerBits
                STR     r0, power_state                 ; and set power_state = ON
                EXIT

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
              [ international


; Attempt to open the messages file.

OpenMessages    Entry   "r0-r3"
                LDR     r3, Flags
                TST     r3, #f_WeHaveMessages                   ; do we have an open messages block?
                BNE     %FT90                                   ; yes, so don't bother again

                ADR     r0, MessagesWorkspace
                ADRL    r1, resource_file                       ; -> path to be opened
                MOV     r2, #0                                  ; allocate some wacky space in RMA
                SWI     XMessageTrans_OpenFile
                LDRVC   r3, Flags
                ORRVC   r3, r3, #f_WeHaveMessages
                STRVC   r3, Flags                               ; assuming it worked mark as having messages
90              CMP     r0, #0
                EXIT                                            ; always return VC, cos don't want to corrupt r0
                                                                ; (will hold a real error pointer)

; Attempt to close the messages file.

CloseMessages   Entry   "r0"
                CMP     r0, #0                                  ; clear V
                LDR     r0, Flags
                TST     r0, #f_WeHaveMessages                   ; do we have any messages?
                EXIT    EQ                                      ; and return if not!

                ADR     r0, MessagesWorkspace
                SWI     XMessageTrans_CloseFile                 ; yes, so close the file
                LDRVC   r0, Flags
                BICVC   r0, r0, #f_WeHaveMessages
                STRVC   r0, Flags                               ; mark as we don't have them
                CMP     r0, #0                                  ; clear V
                EXIT

; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.

MakeError       Entry   "r1-r7"
                LDR     r1, Flags
                TST     r1, #f_WeHaveMessages                   ; has the messages file been closed?
                BLEQ    OpenMessages

                LDR     r1, Flags
                TST     r1, #f_WeHaveMessages
                BEQ     %FT99                                   ; if still not open then return with V set

                ADR     r1, MessagesWorkspace                   ; -> message control block
                MOV     r2, #0
                MOV     r3, #0
                MOV     r4, #0
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0                                  ; no substitution + use internal buffers
                SWI     XMessageTrans_ErrorLookup

                BL      CloseMessages                           ; attempt to close the doofer

99
                SETV
                EXIT                                            ; return, r0 -> block, V set

              ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: CallDevice
;
; in:   r0  = reason code
;   r1..r7  = parameters
;
; out:  -
;
; This routine will call the device with the parameters setup in r1..r7.
;

CallDevice      Entry   "r1-r7"
                MOV     r2, sp                                  ; -> return frame to be used
                MOV     lr, pc
                LDR     pc, DeviceVector                        ; call device with return frame setup
                EXIT                                            ; and return back to the caller!

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                GBLS    conditionalgetbodge
 [ standalone
                GBLS    ApplicationName
ApplicationName SETS    "Serial"
conditionalgetbodge SETS "GET s.ResFiles"
resourcefsfiles
 |
conditionalgetbodge SETS ""
 ]
                $conditionalgetbodge
 [ standalone
                DCD     0
 ]
                END
@


4.9
log
@Minor switch clear up
* Remove CMOS_BackCompat switch, that CMOS bit has twice been reallocated
* Use Hdr:OsBytes for OS_Byte definitions
* Allow 'international' to be passed in from outside
* Match EXITS with EntryS in old 6551 code
* true and false use ObjAsm's {TRUE} and {FALSE}
Same binary, no problems anticipated.

Version 0.46. Tagged as 'Serial-0_46'
@
text
@d183 1
a183 1
 [ standalonemessages
d409 1
a409 1
 [ standalonemessages
d452 1
a452 1
 [ standalonemessages
d480 1
a480 1
 [ standalonemessages
d736 1
a736 1
 [ standalonemessages
d745 1
a745 1
 [ standalonemessages
@


4.8
log
@Correct reason code.
Retagged.
@
text
@a84 6
OSByte_InsertESC	* 153           ; OS_Byte to insert into buffer, checking for escape
OSByte_RemoveChar	* 145           ; OS_Byte to remove from buffer

CMOS_SerCompat		* &0b
SerCompat_Mask		* 2_10000000

a167 9
 [ CMOS_BackCompat
 		MOV	r0, #161
 		MOV	r1, #CMOS_SerCompat
 		SWI	XOS_Byte
 		EXIT	VS
 		TST	r2, #SerCompat_Mask
 		EXIT	EQ				;bitclear == not backwards compatible, so quit
 ]

d316 1
a316 1
                MOV     r0, #ReadCMOS
d330 1
a330 1
                MOV     r0, #ReadCMOS
d344 1
a344 1
                MOV     r0, #&CB
d539 1
a539 1
                MOV     r0, #&FD
@


4.7
log
@Determine need for IRQ delay at runtime, not with StrongARM switch.
Resolve deprecated pop instruction.

Version 0.44. Tagged as 'Serial-0_44'
@
text
@d220 1
a220 1
                MOV     r0, #0 :OR: 1                   ; Read feature flags and address of IRQ delay routine too
@


4.6
log
@Update to use OS_Memory 9 instead of HAL_ControllerAddress
Detail:
  s/Init - Now uses OS_Memory 9 to look for controller #34 instead of HAL_ControllerAddress to look for controller #6. Makes it more portable/future-proof and fixes the HAL_ControllerAddress allocation clash.
Admin:
  Tested in ROM softload on RiscPC.


Version 0.43. Tagged as 'Serial-0_43'
@
text
@d53 2
a136 1
                ! 0, "Internationalised"
d220 5
d490 1
d492 1
a492 3

                MOV     r1, #0                          ; indicate we've closed it
                Pull    "r0,lr,pc"                      ; restore r0, junk r1 and exit
@


4.5
log
@Update SerialDeviceDriver for use with PCIless HAL builds
Detail:
  s/Init - For PCIless HAL builds, use HAL_ControllerAddress to get the 82C710 address
  s/Serial - Only enable PCIHardware for M_Tungsten
  s/Serial710 - Assume IOMD/IOEB IRQ number if not PCIHardware
Admin:
  Tested in Iyonix & IOMD ROM softloads


Version 0.42. Tagged as 'Serial-0_42'
@
text
@d271 3
a273 7
                Push    "r8-r9"
                MOV     r0, #0
                MOV     r1, #&600
                MOV     r8, #0
                MOV     r9, #EntryNo_HAL_ControllerAddress
                SWI     XOS_Hardware
                Pull    "r8-r9"
d275 1
a275 2
                CMP     r0, #0
                CMPNE   r0, #-1
d277 1
a277 1
                ADD     r0, r0, #IOC_UARTOffset
@


4.4
log
@Commit of Kevin's 32-bit, PCI-aware SerialDeviceDriver.
I've upped the version number because it's silly to claim that a PCI serial
driver was written in 2001.

Version 0.40. Tagged as 'Serial-0_40'
@
text
@d91 1
d93 3
d270 17
a286 2
                LDR     r0, =IOC_UARTAddress            ; note the base address
                STR     r0, HWAddress
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.39. Tagged as 'Serial-0_39'
@
text
@d51 2
d81 1
d91 4
d110 8
d136 2
d230 17
d266 3
d272 2
a277 1
 ]
d293 2
a294 1
                EXITS
d348 1
a348 1
                EXITS
d408 2
a409 1
                EXITS
d450 1
a450 1
                MOVNES  pc, lr
d466 1
a466 1
                Pull    "r0-r1,pc",NE,^                 ; if not our handle, then pass on service
d473 1
a473 1
                Pull    "r0,lr,pc",,^                   ; restore r0, junk r1 and exit
d483 1
a483 1
                Pull    "r0-r3,pc",,^
d501 1
a501 1
                Pull    "r0,r2,pc",EQ,^                 ; no then just pass on the service
d509 1
a509 1
                Pull    "r0,r2,pc",,^                   ; then claim service to save time
d514 1
a514 1
                Pull    "r0,r2,pc",,^
d518 1
a518 1
                MOVNES  pc, lr
d527 1
a527 1
                Pull    "r0,r3,pc",,^
d531 1
a531 1
                MOVNES  pc, lr
d541 1
a541 1
                Pull    "r0-r2, pc",NE,^                ; not soft reset, so ignore
d552 1
a552 1
                Pull    "r0-r2, pc",,^
d578 1
a578 1
                EXITS   VS                              ; return if it did not work
d590 2
a591 1
                EXITS
d611 1
a611 1
                EXITS   EQ                              ; then do nothing
d615 1
a615 1
                EXITS   EQ
d620 1
a620 1
                EXITS   VC
d626 1
a626 1
                EXITS
d648 1
a648 1
                EXITS   NE                                      ; yes, so don't bother again
d657 2
a658 1
                EXITS                                           ; always return VC, cos don't want to corrupt r0
d664 1
d667 1
a667 1
                EXITS   EQ                                      ; and return if not!
d674 2
a675 1
                EXITS
d687 1
a687 2
                PullEnv EQ
                ORREQS  pc, lr, #VFlag                          ; if still not open then return with V set
d700 2
@


4.2
log
@Ursula branch merged.
PhoebeHardware switch turned off, CMOS_BackCompat set to :LNOT:STB.
Service call table added.
Changed to use srccommit.

Version 0.37. Tagged as 'Serial-0_37'
@
text
@d105 1
a105 4
help            = "Serial Device", 9, "$Module_MajorVersion ($Module_Date)"
              [ Module_MinorVersion <> ""
                = " $Module_MinorVersion"
              ]
d149 1
a149 1
init            ENTRY
d259 1
a259 1
InitialiseSerial ENTRY
d333 1
a333 1
final           ENTRY
d527 1
a527 1
RegisterDevice  ENTRY   "r0-r7"
d557 1
a557 1
SetPower_On     ENTRY   "r0,r1"
d604 1
a604 1
OpenMessages    ENTRY   "r0-r3"
d621 1
a621 1
CloseMessages   ENTRY   "r0"
d636 1
a636 1
MakeError       ENTRY   "r1-r7"
d678 1
a678 1
CallDevice      ENTRY   "r1-r7"
@


4.1
log
@Initial revision
@
text
@d80 5
a84 2
OSByte_InsertESC  *     153             ; OS_Byte to insert into buffer, checking for escape
OSByte_RemoveChar *     145             ; OS_Byte to remove from buffer
d105 4
a108 1
help            = "Serial Device", 9, "$VString ($Date)"
d110 1
a110 1
                = " Development version",0
d155 9
d384 18
d403 1
d415 1
a415 1
                LDR     wp, [wp]
@


4.1.4.1
log
@erial module which supports the backwards compatibility CMOS bit (0x0b:7)
@
text
@d80 2
a81 5
OSByte_InsertESC	* 153           ; OS_Byte to insert into buffer, checking for escape
OSByte_RemoveChar	* 145           ; OS_Byte to remove from buffer

CMOS_SerCompat		* &0b
SerCompat_Mask		* 2_10000000
a147 9

 [ CMOS_BackCompat
 		MOV	r0, #161
 		MOV	r1, #CMOS_SerCompat
 		SWI	XOS_Byte
 		EXIT	VS
 		TST	r2, #SerCompat_Mask
 		EXIT	EQ				;bitclear == not backwards compatible, so quit
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

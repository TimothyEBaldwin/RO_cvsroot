head	4.4;
access;
symbols
	Manager-3_80:4.4
	Manager-3_79:4.4
	Manager-3_78:4.4
	Manager-3_77:4.4
	Manager-3_76:4.4
	Manager-3_75:4.4
	Manager-3_74:4.4
	Manager-3_73:4.4
	Manager-3_72:4.4
	Manager-3_71:4.4
	Manager-3_70:4.4
	Manager-3_69:4.4
	Manager-3_68:4.4
	Manager-3_67:4.4
	Manager-3_66:4.4
	Manager-3_65:4.4
	Manager-3_64:4.4
	Manager-3_63:4.4
	Manager-3_62:4.4
	Manager-3_61:4.3
	Manager-3_60:4.3
	RO_5_07:4.3
	Manager-3_59:4.3
	Manager-3_58:4.3
	Manager-3_57:4.3
	Manager-3_56:4.3
	Manager-3_55:4.3
	Manager-3_54:4.3
	Manager-3_53:4.3
	Manager-3_52:4.3
	Manager-3_51:4.2
	Manager-3_50:4.2
	Manager-3_49:4.2
	dellis_autobuild_BaseSW:4.2
	Manager-3_48:4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	Manager-3_47:4.1
	Manager-3_46:4.1
	Manager-3_45:4.1
	Manager-3_44:4.1
	Manager-3_43:4.1
	Manager-3_42:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Manager-3_41-4_2_2_13:4.1
	Ursula_RiscPC:4.1.0.10
	Manager-3_41-4_2_2_12:4.1
	Manager-3_41-4_2_2_11:4.1
	Manager-3_41-4_2_2_10:4.1
	Manager-3_41-4_2_2_9:4.1
	Manager-3_41-4_2_2_8:4.1
	Manager-3_41-4_2_2_7:4.1
	Manager-3_41-4_2_2_6:4.1
	Manager-3_41-4_2_2_5:4.1
	Manager-3_41-4_2_2_4:4.1
	Manager-3_41-4_2_2_3:4.1
	Manager-3_41-4_2_2_2:4.1
	Manager-3_41-4_2_2_1:4.1
	NRaine:4.1.0.8
	Manager-3_41:4.1
	Ursula_merge:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	bavison_FontManager-3_40:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Manager-3_40-1_1_2_2:4.1.7.1.4.1
	smiddle_2Mar1998_Fonts16:4.1.7.1.0.4
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2009.05.14.17.24.46;	author jbell;	state Exp;
branches;
next	4.3;

4.3
date	2001.11.12.14.59.58;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.12.12.39.50;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.43.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.43.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.16.20;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.51.37;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.14.37;	author nturton;	state Exp;
branches
	4.1.7.1.4.1;
next	;

4.1.7.1.4.1
date	98.03.03.13.22.55;	author smiddle;	state Exp;
branches;
next	;


desc
@@


4.4
log
@ Seriously reduce the amount of build options, purging those that have
 been enabled by default for years.
Detail:
 Remaining options are: usesetpalette, newunderline, checkhandles,
 lessercheckhandles, and blendingOn.
Admin:
 Resulting binary is identical to 3.61.


Version 3.62. Tagged as 'Manager-3_62'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.FontsM

;;----------------------------------------------------------------------------
;; Macro definitions
;;----------------------------------------------------------------------------

                        ^       0

Pr_None                 #       1       ; 00

Pr_SWI                  #       1       ; 01

Pr_Metrics              #       1       ; 02  Font_CharBBox, Font_StringWidth etc.

Pr_Painting             #       1       ; 03  Font_Paint
Pr_Paint_Init           #       1       ; 04  paintchars .. paintchar loop
Pr_Paint_Rubout         #       1       ; 05  rubout
Pr_Paint_Underline      #       1       ; 06  underline
Pr_Paint_Char           #       1       ; 07  paintchar
Pr_Paint_Metrics        #       1       ; 08  addcharwidth, calcxcoord
Pr_Paint_BBox           #       1       ; 09  getbbox
Pr_Paint_Palette        #       1       ; 0A
Pr_Paint_Mode           #       1       ; 0B
Pr_Paint_Colours        #       1       ; 0C
Pr_Paint_Char4bpp       #       1       ; 0D
Pr_Paint_Char1bpp       #       1       ; 0E
Pr_Paint_Char1bpp_fast  #       1       ; 0F
Pr_Paint_CharClip       #       1       ; 10
Pr_Paint_CharClipped    #       1       ; 11
Pr_Paint_CharMag        #       1       ; 12
Pr_Paint_CharDraw       #       1       ; 13

Pr_Cac_Metrics          #       1       ; 14
Pr_Cac_MetDisc          #       1       ; 15
Pr_Cac_Pixels           #       1       ; 16
Pr_Cac_PixDisc          #       1       ; 17
Pr_Cac_Hint             #       1       ; 18
Pr_Cac_Draw             #       1       ; 19
Pr_Cac_Super            #       1       ; 1A
Pr_Cac_Strip            #       1       ; 1B
Pr_Cac_Switch           #       1       ; 1C

Pr_Res_Find             #       1       ; 1D  finding a block to delete
Pr_Res_Copy             #       1       ; 1E  copying the cache down
Pr_Res_Reloc            #       1       ; 1F  relocating the pointers

Pr_CheckCache           #       1       ; 20

Pr_FindFont             #       1       ; 21
Pr_Find_Matching        #       1       ; 22
Pr_Find_NewOne          #       1       ; 23
Pr_ParseMatrix          #       1       ; 24
Pr_ListFonts            #       1       ; 25
Pr_Mapping              #       1       ; 26
Pr_TransformPt          #       1       ; 27

;..............................................................................

        GBLS    Profile_Last

        MACRO
$l      ProfIn  $which, $cc
        ASSERT  Pr_$which = Pr_$which
$l
      [ debugprofile
Profile_Last    SETS    "$which"
        Push    "R0,LR", $cc
        MOV$cc  R0,#Pr_$which
        BL$cc   profile_in
        Pull    "R0,LR", $cc
      ]
        MEND

;..............................................................................

        MACRO
$l      ProfOut $type, $cc
$l
     [ debugprofile
        Push    "R0,LR", $cc
      [ "$type"=""
        MOV$cc  R0,#Pr_$Profile_Last
      |
        MOV$cc  R0,#Pr_$type
      ]
        BL$cc   profile_out
        Pull    "R0,LR", $cc
     ]
        MEND

;..............................................................................

        MACRO
$l      PEntry  $which, $regs
$l      Entry   "$regs"
        ProfIn  $which
        MEND

        MACRO
$l      PEntryS $which, $regs
$l      EntryS  "$regs"
        ProfIn  $which
        MEND

        MACRO
$l      PExit   $cc
$l      ProfOut ,$cc
        EXIT    $cc
        MEND

        MACRO
$l      PExitS  $cc
$l      ProfOut ,$cc
        EXITS   $cc
        MEND

;..............................................................................

        MACRO
$l      PullS   $regs
$l
        DebugE  err,"Error return:"
    [ "$regs" = ""
      [ No32bitCode
        Pull    "PC",VC,^
        Pull    "LR"
        ORRS    PC,LR,#V_bit
      |
        Pull    "PC"
      ]
    |
        ASSERT  "$regs":RIGHT:2 <> "PC"
        ASSERT  "$regs":RIGHT:2 <> "LR"
        LCLS    temp
temp    SETS    "$regs":LEFT:2
      [ No32bitCode
        Pull    "$regs,PC",VC,^
      [ $temp = R0
        STRVS   R0,[sp]
      ]
        Pull    "$regs,LR"
        ORRS    PC,LR,#V_bit
      |
      [ $temp = R0
        STRVS   R0,[sp]
      ]
        Pull    "$regs,PC"
      ]
    ]
        MEND

;..............................................................................

        MACRO
$l      PPullS  $regs
$l      ProfOut
        PullS   "$regs"
        MEND

        MACRO
        align   $base,$mask
        LCLA    temp
      [ "$mask"=""
temp    SETA    4-1
      |
temp    SETA    $mask-1
      ]
        #       ((@@-$base + &$temp):AND::NOT:&$temp)-(@@-$base)
        MEND

;..............................................................................

Urk     *       4

        MACRO
        AlignCd $mod
      [ ((.-Module_BaseAddr):AND:15) <> $mod
        MOV     R0,R0
      ]
      [ ((.-Module_BaseAddr):AND:15) <> $mod
        MOV     R0,R0
      ]
      [ ((.-Module_BaseAddr):AND:15) <> $mod
        MOV     R0,R0
      ]
        ASSERT  ((.-Module_BaseAddr):AND:15) = $mod
        MEND

;..............................................................................

        MACRO
$lab    BreakPt $string,$cc
$lab
      [ debugbrk
        B$cc    %FT01
        B       %FT02
01
        Push    "R0,LR"
        MOV     R0,PC
        Debug   brk,"Breakpoint: $string at ",R0
        Pull    "R0,LR"
        MOV     R14,#0
        LDR     R14,[R14,#-4]           ; force breakpoint
02
      ]
        MEND

;..............................................................................

        MACRO
$label  CLI     $com
$label  Push    "R0,LR"
      [ No32bitCode
        Push    "PC"
      |
        MRS     LR,CPSR
        Push    "LR"
      ]
        ADR     R0,%FT01
        SWI     XOS_CLI
        B       %FT02
01
        DCB     "$com",cr
02
        Pull    "LR"
      [ No32bitCode
        TEQP    LR,#0
      |
        MSR     CPSR_f,LR
      ]
        Pull    "R0,LR"
        MEND

;..............................................................................

        MACRO
$label  Align   $reg
$label  ADD     $reg,$reg,#3
        BIC     $reg,$reg,#3
        MEND

;..............................................................................

        MACRO
        Claim   $vector,$entry
        MOV     R0,#$vector
        ADRL    R1,$entry
        MOV     R2,R12
        SWI     XOS_Claim
        MEND

        MACRO
        Release $vector,$entry
        MOV     R0,#$vector
        ADRL    R1,$entry
        MOV     R2,R12
        SWI     XOS_Release
        MEND

;..............................................................................

        MACRO
        swi     $label
        DCD     $label-FontSWItable
        MEND

        MACRO
        MySWI   $swiname
        ASSERT  MySWIBase+(.-FontSWItable)/4 = $swiname
        B       SWI$swiname
        MEND

;..............................................................................

; Relocation stack handlers - both destroy R14

        MACRO
$lab    PushP   $message,$reg
        ASSERT  $reg <> R14
$lab
      [ debugbrk
        BL      checkrelocfull
      ]
        LDR     R14,relocSP
        STR     $reg,[R14],#4
        STR     R14,relocSP
      [ debugstk
        BL      debugstk_spaces
        Debug   stk,"--> $message",$reg
      ]
        MEND

;..............................................................................

        MACRO
$lab    PullP   $message,$reg
        ASSERT  $reg <> R14
$lab    LDR     R14,relocSP
        LDR     $reg,[R14,#-4]!
        STR     R14,relocSP
      [ debugstk
        BL      debugstk_spaces
        Debug   stk,"<-- $message",$reg
      ]
        MEND

;..............................................................................

        MACRO
$lab    PullPx  $message,$reg,$offset
        ASSERT  $reg <> R14
$lab    LDR     R14,relocSP
      [ "$offset"=""
        LDR     $reg,[R14,#-4]
      |
        LDR     $reg,[R14,#-4-4*($offset)]
      ]
     [ debugstk
        Push    "R1"
      [ "$offset"=""
        SUB     R1,R14,#4
      |
        SUB     R1,R14,#4+4*($offset)
      ]
        BL      debugstk_spaces_R1
        Debug   stk,"<== $message",$reg
        Pull    "R1"
     ]
        MEND

;..............................................................................

        MACRO
$lab    Get12bit_signed $Rptr,$Rx,$Ry,$Rtemp,$cc
$lab
        LDR$cc.B $Rx,[$Rptr],#1
        LDR$cc.B $Ry,[$Rptr],#1
        MOV$cc   $Rtemp,$Ry,LSL #28             ; bottom 4 bits of byte 1
        ORR$cc   $Rx,$Rx,$Rtemp,ASR #20         ; all 8 bits of byte 0

        LDR$cc.B $Rtemp,[$Rptr],#1
        MOV$cc   $Rtemp,$Rtemp,LSL #24          ; all 8 bits of byte 2
        ORR$cc   $Rtemp,$Rtemp,$Ry,LSL #16      ; top 4 bits of byte 1
        MOV$cc   $Ry,$Rtemp,ASR #20             ; sign-extended

        MEND

;..............................................................................

        MACRO
$lab    Get12bit_unsigned $Rptr,$Rx,$Ry,$Rtemp,$cc
$lab
        LDR$cc.B $Rtemp,[$Rptr],#1
        LDR$cc.B $Ry,[$Rptr],#1
        MOV$cc   $Rx,$Ry,LSL #28                ; bottom 4 bits of byte 1
        ORR$cc   $Rx,$Rtemp,$Rx,LSR #20         ; not sign-extended

        LDR$cc.B $Rtemp,[$Rptr],#1
        MOV$cc   $Ry,$Ry,LSR #4                 ; top 4 bits of byte 1
        ORR$cc   $Ry,$Ry,$Rtemp,LSL #4          ; not sign-extended

        MEND

;..............................................................................

        MACRO
$lab    LoadCacheFree $Reg,$temp,$compacted
$lab
        LDR     $Reg,cacheindex
        TEQ     $Reg,#0
        LDREQ   $Reg,fontcache
      [ "$compacted"<>""
        LDRNE   $temp,[$Reg, #cache_deletedamount]
      ]
        LDRNE   $Reg,[$Reg,#cache_free]
      [ "$compacted"<>""
        SUBNE   $Reg,$Reg,$temp
      ]
        MEND

;..............................................................................

        MACRO
$lab    CheckCache_enable
$lab
      [ debugcache
        STR     PC,checkcache_enabled
      ]
        MEND

;..............................................................................

        MACRO
$lab    CheckCache_disable
$lab
      [ debugcache
        Push    "R14"
        MOV     R14,#0
        STR     R14,checkcache_enabled
        Pull    "R14"
      ]
        MEND

;..............................................................................

        MACRO
$lab    CheckCache $message, $nocacheok
$lab
     [ debugcache
        Push    "R0,LR"
        ADR     R0,%FT46
      [ "$nocacheok"<>""
        LDR     R14,cacheindex
        TEQ     R14,#0
        BLNE    checkcache
      |
        BL      checkcache
      ]
        Pull    "R0,LR"
        B       %FT47
46
        DCB     "$message",0
        ALIGN
47
     ]
        MEND

;..............................................................................

; Link a block into the cache

        MACRO
        MakeLink $r6,$r8, $cc
        ASSERT  $r6 = R6
        ASSERT  $r8 = R8
        BL$cc   makelink
        MEND

;..............................................................................

; remove a block from the 2-way ageing linked list

        MACRO
$l      RemLink $rb, $r1,$r2, $cc
$l
        ASSERT  std_link = 4 :LAND: std_backlink = 8
        ASSERT  $r1 < $r2
        LDM$cc.IB $rb,{$r1,$r2}
        STR$cc  $r1,[$r2,#std_link]
        STR$cc  $r2,[$r1,#std_backlink]
        MEND

;..............................................................................

; link a block into the 2-way ageing list, using the links in $r1, $r2

        MACRO
$l      StrLink $rb, $r1,$r2, $cc
$l
        ASSERT  std_link = 4 :LAND: std_backlink = 8
        ASSERT  $r1 < $r2
        STM$cc.IB $rb,{$r1,$r2}
        STR$cc  $rb,[$r2,#std_link]
        STR$cc  $rb,[$r1,#std_backlink]
        MEND

;..............................................................................

; Mark a block 'accessed'

        MACRO
$l      MarkAge $rb, $rt1,$rt2, $cc
$l
        RemLink $rb,$rt1,$rt2,$cc               ; remove block from original list
        LDR$cc  $rt1,ageheadblock_p             ; then insert before tail of list
        LDR$cc  $rt2,[$rt1,#std_backlink]
        StrLink $rb,$rt1,$rt2,$cc
        MEND

;..............................................................................

; Mark block accessed, with time offset if $cc is true

        MACRO
$l      MarkAgeOffset $rb,$ro, $rt1,$rt2, $cc
$l
        MarkAge $rb,$rt1,$rt2           ; ignore time offset
        MEND

;..............................................................................

; Mark block accessed (unless in ROM)

        MACRO
$l      MarkAccessed $rb, $rt, $cc
$l
        ASSERT  $rb = R6
        ASSERT  $rt = R14
        BL$cc   markaccessed
        MEND

;..............................................................................

; Get address of block just reserved using reservecache2

        MACRO
$l      GetReservedBlockAddr $rd, $rt, $cc
$l
      [ "$rt"<>""
        LDR$cc  $rt,cacheindex
        LDR$cc  $rd,[$rt,#cache_free]
      |
        LDR$cc  $rd,cacheindex
        LDR$cc  $rd,[$rd,#cache_free]
      ]
        MEND

;..............................................................................

; Get end address of block just reserved using reservecache2

        MACRO
$l      GetReservedBlockEnd $rd, $rs, $rt, $cc, $aligned
$l
        LDR$cc  $rt,fontcachesize
        LDR$cc  $rd,fontcache
        ADD$cc  $rt,$rd,$rt
        SUB$cc  $rd,$rt,$rs

        MEND

;..............................................................................

; Set CacheFree to value in $rb, using $rt as a temporary register

        MACRO
$l      SetCacheFree $rb, $rt, $cc
$l      LDR$cc  $rt,cacheindex
        STR$cc  $rb,[$rt,#cache_free]
        MEND

;..............................................................................

; Discard block pointed to by $rb (must be the last one allocated)

        MACRO
$l      DiscardBlock $rb, $rt1, $rt2, $cc
$l      LDR$cc  $rt1,cacheindex
        STR$cc  $rb,[$rt1,#cache_free]
        RemLink $rb, $rt1, $rt2, $cc
        CheckCache "DiscardBlock"
        MEND

;..............................................................................

; Reset size of last block to the given value

        MACRO
$l      SetBlockSize $rb,$rs,$rt,$cc
$l      ORR     $rt,$rs,#size_claimed           ; assume it's a claimed font
        STR     $rt,[$rb,#std_size]
        ADD     $rs,$rb,$rs
        LDR     $rt,cacheindex
        STR     $rs,[$rt,#cache_free]
        MEND

;..............................................................................

; Reset size of last block so block end = $re

        MACRO
$l      SetBlockEnd  $rb, $re, $rt, $gotit, $cc
$l
      [ "$gotit"="No"
        LDR$cc  $rt,cacheindex
      ]
        STR$cc  $re,[$rt,#cache_free]
      [ "$rb"<>""
        SUB$cc  $rt,$re,$rb
        STR$cc  $rt,[$rb,#std_size]
      ]
        MEND

;..............................................................................

; Discard block if V set, else set block end

        MACRO
$l      DiscardOrSetBlockEnd $rb, $re, $rt1, $rt2
$l
        RemLink $rb, $rt1, $rt2, VS
        LDR     $rt1, cacheindex
        STRVS   $rb, [$rt1, #cache_free]
        STRVC   $re, [$rt1, #cache_free]
        SUBVC   $rt1, $re, $rb
        STRVC   $rt1, [$rb, #std_size]
        MEND

;..............................................................................

; Cache hit/miss types

Hit_Font        *       1               ; font header block
Hit_Metrics     *       2               ; metrics block
Hit_Scaffold    *       3               ; outline font scaffold block
Hit_Pixels      *       4               ; 1-bpp or 4-bpp pixel/char block
Hit_Outlines    *       5               ; outline block
Hit_Sprite      *       6               ; sprite switching

; Increment appropriate cache hit/miss entry

        MACRO
$l      CacheHit $type, $cc
$l
      [ debughits
        Push    "r0,r1,lr"
        MOV     r0, #Hit_$type + Hit_Miss
        MOV$cc  r0, #Hit_$type
        ADR     r1, cache_hits
        LDR     r14, [r1, r0, LSL #2]
        ADD     r14, r14, #1
        STR     r14, [r1, r0, LSL #2]
        Pull    "r0,r1,lr"
      ]
        MEND

;..............................................................................

; Display the contents of a fixed-point matrix

        MACRO
$l      DebugM  $dbg,$string,$reg
$l
      [ debug$dbg
        Push    "R1,LR"
        Debuga  $dbg,"$string"
        MOV     R1,$reg
        BL      debug_matrix
        Pull    "R1,LR"
      ]
        MEND

;..............................................................................

; Display the contents of a floating-point matrix

        MACRO
$l      DebugMF $dbg,$string,$reg
$l
      [ debug$dbg
        Push    "R1,R2,LR"
        Debuga  $dbg,"$string"
        MOV     R1,$reg
        MOV     R2,#:LEN:"$string"
        BL      debug_fpmatrix
        Pull    "R1,R2,LR"
      ]
        MEND

;..............................................................................

; Debugging macro used in convert_xy to show scaffolding dependencies

        MACRO
$l      DebugSc $dbg,$xy,$coord,$index,$offx,$offy,$cc
$l
      [ debug$dbg
        B$cc    %FT61
        Debug   $dbg,"output $xy += x-scaffold index, offset",$coord,$index,$offx
        B       %FT62
61
        Debug   $dbg,"output $xy += y-scaffold index, offset",$coord,$index,$offy
62
      ]
        MEND

;..............................................................................

; Debugging macro used in ScanFontDir to print one of two alternative strings

        MACRO
$l      DebugC  $dbg,$cc,$str1,$str2
$l
      [ debug$dbg
        B$cc    %FT1
        Debuga  $dbg,"$str2"
        B       %FT2
1
        Debuga  $dbg,"$str1"
2
      ]
        MEND

;..............................................................................

; Debugging macro used in ScanFontDir to print resulting leafname

        MACRO
$l      DebugLeafname $dbg,$message,$font,$leaf
$l
      [ debug$dbg
      [ No32bitCode
        Push    "R0,PC"
      |
        MRS     LR,CPSR
        Push    "R0,LR"
      ]

        Debuga  $dbg,"$message: font",$font

        LDRB    R14,[$font,#hdr_masterflag]
        TEQ     R14,#msf_master
        DebugC  $dbg,EQ," (master)"," (slave)"

        SUB     R14,$leaf,$font
        TEQ     R14,#hdr1_leafname
        DebugC  $dbg,EQ," 1-bpp"," 4-bpp"

        LDRB    R14,[$leaf]
        CMP     R14,#leaf_fromdisc
        BCS     %f2
        Debug   $dbg," data type =",R14
        B       %f3
2
        DebugS  $dbg," filename ",$leaf,12
3
        Pull    "R0,LR"
      [ No32bitCode
        TEQP    LR,#0                   ; preserve error state!!!
      |
        MSR     CPSR_f,LR               ; preserve error state!!!
      ]
      ]
        MEND

;..............................................................................

; Debugging macro used to check for unexpected zero divide

        MACRO
$l      ChkDv0  $message, $reg
$l
      [ debugbrk
        TEQ     $reg,#0
        BreakPt "$message: divide by 0",EQ
      ]
        MEND

;..............................................................................

; Macro to set a variable to a given range of set bits (inclusive)

        MACRO
$l      EqBits  $b1,$b2
        LCLA    eqb1
        LCLA    eqb2
        ASSERT  $b1 <= $b2
eqb1    SETA    ((1:SHL:$b1)-1)                         ; set bits 0..($b1-1)
eqb2    SETA    ((1:SHL:$b2)-1) :OR: (1:SHL:$b2)        ; set bits 0..$b2
$l      *       eqb2 :AND: (:NOT: eqb1)                 ; set bits $b1..$b2
        MEND

        END

@


4.3
log
@Now supports chunk dependencies outside the first 32 chunks. Needed for the
Korean font.

Version 3.52. Tagged as 'Manager-3_52'
@
text
@a175 1
    [ Version >= 272
a182 10
    |
     [ "$mask"=""
        #       (4-((@@-$base):AND:3)):AND:3
     |
      [ ((@@-$base):AND:($mask-1)) = 0
        !       0,"align macro wasted $mask bytes"
      ]
        #       $mask-((@@-$base):AND:($mask-1))
     ]
    ]
d444 1
a444 1
; Link a block into the cache, storing the anchor pointer if newcache true
a510 1
     [ :LNOT: newcache
a513 1
     ]
@


4.2
log
@32-bit compatible.

Version 3.48. Tagged as 'Manager-3_48'
@
text
@d241 1
a241 1
        mrs    ,LR,CPSR
d254 1
a254 1
        msr    ,CPSR_f,LR
d732 1
a732 1
        mrs    ,LR,CPSR
d758 1
a758 1
        msr    ,CPSR_f,LR               ; preserve error state!!!
@


4.1
log
@Initial revision
@
text
@d114 6
d138 1
d142 3
a147 1
        Pull    "$regs,PC",VC,^
d150 2
d157 6
d203 1
a203 1
        MOVNV   R0,R0
d206 1
a206 1
        MOVNV   R0,R0
d209 1
a209 1
        MOVNV   R0,R0
d238 1
d240 4
d251 1
d253 3
d729 1
d731 4
d755 1
d757 3
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.1.4.1
log
@Checked in RBrowning sources to own branch for 16bit development. This module has been checked
to build the same as it did in his hard disc.

Version 3.40, 1.1.2.2. Tagged as 'Manager-3_40-1_1_2_2'
@
text
@a127 24
$l      PullC   $regs
$l
        DebugE  err,"Error return:"
    [ "$regs" = ""
        Pull    "PC",VC,^
        Pull    "LR"
   	BICS	PC, LR, #V_bit
   |
        ASSERT  "$regs":RIGHT:2 <> "PC"
        ASSERT  "$regs":RIGHT:2 <> "LR"
        Pull    "$regs,PC",VC,^
        LCLS    temp
temp    SETS    "$regs":LEFT:2
      [ $temp = R0
        STRVS   R0,[sp]
      ]
        Pull    "$regs,LR"
	BICS	PC, LR, #V_bit
    ]
        MEND

;..............................................................................

        MACRO
d145 1
a145 1
	ORRS    PC,LR,#V_bit
d148 1
a148 1
        
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

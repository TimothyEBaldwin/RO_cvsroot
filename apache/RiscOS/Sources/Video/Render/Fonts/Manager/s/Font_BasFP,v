head	4.5;
access;
symbols
	Manager-3_80:4.5
	Manager-3_79:4.5
	Manager-3_78:4.5
	Manager-3_77:4.5
	Manager-3_76:4.5
	Manager-3_75:4.5
	Manager-3_74:4.5
	Manager-3_73:4.5
	Manager-3_72:4.5
	Manager-3_71:4.5
	Manager-3_70:4.5
	Manager-3_69:4.4
	Manager-3_68:4.3
	Manager-3_67:4.3
	Manager-3_66:4.3
	Manager-3_65:4.3
	Manager-3_64:4.3
	Manager-3_63:4.3
	Manager-3_62:4.3
	Manager-3_61:4.2
	Manager-3_60:4.2
	RO_5_07:4.2
	Manager-3_59:4.2
	Manager-3_58:4.2
	Manager-3_57:4.2
	Manager-3_56:4.2
	Manager-3_55:4.2
	Manager-3_54:4.2
	Manager-3_53:4.2
	Manager-3_52:4.2
	Manager-3_51:4.2
	Manager-3_50:4.2
	Manager-3_49:4.2
	dellis_autobuild_BaseSW:4.2
	Manager-3_48:4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	Manager-3_47:4.1
	Manager-3_46:4.1
	Manager-3_45:4.1
	Manager-3_44:4.1
	Manager-3_43:4.1
	Manager-3_42:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Manager-3_41-4_2_2_13:4.1
	Ursula_RiscPC:4.1.0.10
	Manager-3_41-4_2_2_12:4.1
	Manager-3_41-4_2_2_11:4.1
	Manager-3_41-4_2_2_10:4.1
	Manager-3_41-4_2_2_9:4.1
	Manager-3_41-4_2_2_8:4.1
	Manager-3_41-4_2_2_7:4.1
	Manager-3_41-4_2_2_6:4.1
	Manager-3_41-4_2_2_5:4.1
	Manager-3_41-4_2_2_4:4.1
	Manager-3_41-4_2_2_3:4.1
	Manager-3_41-4_2_2_2:4.1
	Manager-3_41-4_2_2_1:4.1
	NRaine:4.1.0.8
	Manager-3_41:4.1
	Ursula_merge:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	bavison_FontManager-3_40:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Manager-3_40-1_1_2_2:4.1.7.1
	smiddle_2Mar1998_Fonts16:4.1.7.1.0.4
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2011.12.06.00.06.34;	author jlee;	state Exp;
branches;
next	4.4;
commitid	PU1uxpB734xYM3Kv;

4.4
date	2011.09.24.15.06.05;	author jlee;	state Exp;
branches;
next	4.3;
commitid	ktcX7FIigldY6LAv;

4.3
date	2009.05.14.17.24.45;	author jbell;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.12.12.39.46;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.43.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.43.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.16.29;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.51.40;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.14.39;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Use correct CLZ check
Detail:
  s/Font_BasFP - Only look for ARMv5 support when deciding if CLZ is available, not ARMv5T
Admin:
  Tested in OMAP3 ROM


Version 3.70. Tagged as 'Manager-3_70'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;> fp

;..................................................................................

; float integer in FACC
; Note: Exits EQ if FACC==0, else flags preserved

        GBLL    UseCLZ
UseCLZ  SETL    :LNOT: NoARMv5

IFLT
        Debug   fp,"IFLT in : FACC =",FACC
      [ :LNOT:No32bitCode
        Push    LR
        SavePSR LR
      ]

        MOVS    FSIGN,FACC ;set sign
        BEQ     IFLTZ ;exit if number 0
        AND     FSIGN,FSIGN,#&80000000
        RSBMI   FACC,FACC,#0 ;complement number if rqd
      [ UseCLZ
        CLZ     FACCX,FACC
        MOV     FACC,FACC,LSL FACCX
        RSB     FACCX,FACCX,#&A0
      |
        MOV     FACCX,#&A0 ;initial exponent
IFLTA
        CMP     FACC,#&10000
        MOVCC   FACC,FACC,LSL #16
        SUBCC   FACCX,FACCX,#16
        CMP     FACC,#&1000000
        MOVCC   FACC,FACC,LSL #8
        SUBCC   FACCX,FACCX,#8
        CMP     FACC,#&10000000
        MOVCC   FACC,FACC,LSL #4
        SUBCC   FACCX,FACCX,#4
        CMP     FACC,#&40000000
        MOVCC   FACC,FACC,LSL #2
        SUBCC   FACCX,FACCX,#2
        CMP     FACC,#&80000000
        MOVCC   FACC,FACC,LSL #1
        SUBCC   FACCX,FACCX,#1
      ]
        Debug   fp,"IFLT out: FACC,FACCX,FSIGN =",FACC,FACCX,FSIGN
      [ No32bitCode
        MOVS    PC,LR
      |
        RestPSR LR,,f
        Pull    PC
      ]

IFLTZ   MOV     FACCX,#0
        Debug fp,"IFLT out: FACC,FACCX,FSIGN =",FACC,FACCX,FSIGN
      [ No32bitCode
        MOV     PC,R14
      |
        Pull    PC
      ]

;..................................................................................

; fix fp number to integer in FACC (rounding to nearest)

INTRND
        Debug   fp,"INTRND in : FACC,FACCX,FSIGN =",FACC,FACCX,FSIGN

        SUBS    FACCX,FACCX,#&80        ; subtract bias
        BCC     FCLR                    ; branch if too small
        MOV     FGRD,FACC,LSL FACCX     ; remaining fraction
        RSBS    FACCX,FACCX,#32         ; decide whether possible
        BLS     FOVR                    ; too large
        MOV     FACC,FACC,LSR FACCX     ; shift by exponent
        TEQ     FGRD,#0
        ADDMI   FACC,FACC,#1
        TEQ     FSIGN,#0                ; check sign
        RSBMI   FACC,FACC,#0            ; negate
        Debug   fp,"INTRND out: FACC =",FACC
        MOV     PC,LR

;..................................................................................

; FWACC*FACC

FMUL
        Debug   fp,"FMUL in : FACC, FACCX, FSIGN =",FACC,FACCX,FSIGN
        Debug   fp,"FMUL in : FWACC,FWACCX,FWSIGN=",FWACC,FWACCX,FWSIGN

        TEQ     FACC,#0
        TEQNE   FWACC,#0
        BEQ     FCLR                    ; *0 implies zero
        EOR     FSIGN,FSIGN,FWSIGN      ; correct sign
        ADD     FACCX,FACCX,FWACCX      ; calculate exponent
        SUB     FACCX,FACCX,#&80        ; restore bias
        MOV     FWGRD,FACC,LSR #16
        MOV     FWACCX,FWACC,LSR #16
        EOR     FWSIGN,FACC,FWGRD,LSL #16
        EORS    FWACC,FWACC,FWACCX,LSL #16
        MUL     FGRD,FWSIGN,FWACC
        MULNE   FWACC,FWGRD,FWACC
        MUL     FWSIGN,FWACCX,FWSIGN
        MUL     FWACCX,FWGRD,FWACCX
        ADDS    FWSIGN,FWACC,FWSIGN
        ADDCS   FWACCX,FWACCX,#&10000
        ADDS    FGRD,FGRD,FWSIGN,LSL #16
        ADCS    FACC,FWACCX,FWSIGN,LSR #16
        BMI     FMULTIDY
        ADDS    FGRD,FGRD,FGRD
        ADC     FACC,FACC,FACC
        SUB     FACCX,FACCX,#1

FMULTIDY
        CMP     FGRD,#&80000000
        BCC     FMULTRNDT
        BICEQ   FACC,FACC,#1            ; if eq clear bottom bit so add sets it
        ADDS    FACC,FACC,#1
        MOVCS   FACC,FACC,RRX
        ADDCS   FACCX,FACCX,#1

FMULTRNDT
        Debug   fp,"FMUL out: FACC, FACCX, FSIGN =",FACC,FACCX,FSIGN
        CMP     FACCX,#256
        MOVCC   PC,LR
        TEQ     FACCX,#0
        BMI     FCLR
        B       FOVR

;..................................................................................

; fwacc/facc

FXDIV
        Debug   fp,"FDIV in : FWACC,FWACCX,FWSIGN=",FWACC,FWACCX,FWSIGN
        Debug   fp,"FDIV in : FACC, FACCX, FSIGN =",FACC,FACCX,FSIGN

        TEQ     FACC,#0
        BEQ     ZDIVOR
        TEQ     FWACC,#0
        BEQ     FCLR                    ; if w=0 clear facc and return
FDIVA
        EOR     FSIGN,FSIGN,FWSIGN      ; correct sign
        SUB     FACCX,FWACCX,FACCX      ; calculate final exponent
        ADD     FACCX,FACCX,#&81        ; restore bias
FDIVB
        CMP     FACC,#&80000000
        BEQ     FDIVQUIK
        MOVS    FWSIGN,#256             ; clear carry and init loop count
FDIVC
        CMPCCS  FWACC,FACC
        SUBCS   FWACC,FWACC,FACC
        ADC     FWACCX,FWACCX,FWACCX    ; rotate 0/1 into fwaccx
        MOVS    FWACC,FWACC,ASL #1
        CMPCCS  FWACC,FACC
        SUBCS   FWACC,FWACC,FACC
        ADC     FWACCX,FWACCX,FWACCX    ; rotate 0/1 into fwaccx
        MOVS    FWACC,FWACC,ASL #1
        CMPCCS  FWACC,FACC
        SUBCS   FWACC,FWACC,FACC
        ADC     FWACCX,FWACCX,FWACCX    ; rotate 0/1 into fwaccx
        MOVS    FWACC,FWACC,ASL #1
        CMPCCS  FWACC,FACC
        SUBCS   FWACC,FWACC,FACC
        ADC     FWACCX,FWACCX,FWACCX    ; rotate 0/1 into fwaccx
        MOVS    FWACC,FWACC,ASL #1
        CMPCCS  FWACC,FACC
        SUBCS   FWACC,FWACC,FACC
        ADC     FWACCX,FWACCX,FWACCX    ; rotate 0/1 into fwaccx
        MOVS    FWACC,FWACC,ASL #1
        CMPCCS  FWACC,FACC
        SUBCS   FWACC,FWACC,FACC
        ADC     FWACCX,FWACCX,FWACCX    ; rotate 0/1 into fwaccx
        MOVS    FWACC,FWACC,ASL #1
        CMPCCS  FWACC,FACC
        SUBCS   FWACC,FWACC,FACC
        ADC     FWACCX,FWACCX,FWACCX    ; rotate 0/1 into fwaccx
        MOVS    FWACC,FWACC,ASL #1
        CMPCCS  FWACC,FACC
        SUBCS   FWACC,FWACC,FACC
        ADC     FWACCX,FWACCX,FWACCX    ; rotate 0/1 into fwaccx
        MOVS    FWACC,FWACC,ASL #1
        SUB     FWSIGN,FWSIGN,#64
        TEQ     FWSIGN,#0               ; done like this to preserve carry
        BNE     FDIVC
        TEQ     FWACCX,#0
        BMI     FDIVD                   ; already normalised
        CMPCCS  FWACC,FACC
        SUBCS   FWACC,FWACC,FACC
        ADC     FWACCX,FWACCX,FWACCX    ; rotate 0/1 into fwaccx, thus normalising
        MOVS    FWACC,FWACC,ASL #1
        SUB     FACCX,FACCX,#1
FDIVD   CMPCCS  FWACC,FACC
;       BCC     FDIVF
;       TEQ     FWACC,FACC
;       BICEQ   FWACCX,FWACCX,#1
        ADDCSS  FWACCX,FWACCX,#1
        MOVCS   FWACCX,FWACCX,RRX
        ADDCS   FACCX,FACCX,#1
FDIVF   ADDS    FACC,FWACCX,#0          ; clear V
        BICS    FWACCX,FACCX,#255
        Debug   fp,"FDIV out: FACC, FACCX, FSIGN =",FACC,FACCX,FSIGN
        MOVEQ   PC,LR
        BMI     FCLR
        B       FOVR

FDIVQUIK
        MOV     FACC,FWACC
        BICS    FWACCX,FACCX,#255
        Debug   fp,"FDIV out: FACC, FACCX, FSIGN =",FACC,FACCX,FSIGN
        MOVEQ   PC,LR
        BMI     FCLR
        B       FOVR

;..................................................................................

; add two accs (called from Expr fp +). Fwgrd, fgrd irrelevant

FADDW   ROUT

      [ debugfp
        Push    "LR"
        Debug   fp,"FADD in : FACC, FACCX, FSIGN =",FACC,FACCX,FSIGN
        Debug   fp,"FADD in : FWACC,FWACCX,FWSIGN=",FWACC,FWACCX,FWSIGN
        BL      FADDW_inner
        Debug   fp,"FADD out: FACC, FACCX, FSIGN =",FACC,FACCX,FSIGN
        Pull    "PC"

FADDW_inner     ROUT
      ]

        TEQ     FACC,#0                 ; no work needed?
        BEQ     FWTOA                   ; no round
        SUBS    FWACCX,FACCX,FWACCX     ; difference in exponents
        BEQ     %10                     ; no difference means no normalisation
        BHI     %06                     ; FACCX > FWRKX
        RSB     FWACCX,FWACCX,#0        ; negate
        ADD     FACCX,FWACCX,FACCX      ; update result exponent
        RSBS    FGRD,FWACCX,#32
        BCC     FSWTOA                  ; return if shift too large for significance: no round
        TEQ     FSIGN,FWSIGN            ; test   signs
        BMI     %04                     ; signs  different
        MOV     FGRD,FACC,LSL FGRD
02      ADDS    FACC,FWACC,FACC,LSR FWACCX
        BCC     %16                     ; no renorm needed

; renormalise by right shift with guard

        MOVS    FACC,FACC,RRX
        MOV     FGRD,FGRD,RRX
        ADD     FACCX,FACCX,#1
        CMP     FACCX,#256
        BCS     FOVR
        CMP     FGRD,#&80000000         ;  round with no overflow pain
        BCC     %FT99
03      BICEQ   FACC,FACC,#1            ; if eq clear bottom bit so add sets it
        ADDS    FACC,FACC,#1
        BCC     %FT99
        MOV     FACC,FACC,RRX           ; carry set
        ADD     FACCX,FACCX,#1
        CMP     FACCX,#256
        BCC     %FT99
        B       FOVR
04      MOV     FWGRD,#0
        SUBS    FGRD,FWGRD,FACC,LSL FGRD
        SBCS    FACC,FWACC,FACC,LSR FWACCX
        MOV     FSIGN,FWSIGN
        BPL     %12
        Debug   fp,"FADD out: FACC, FACCX, FSIGN =",FACC,FACCX,FSIGN
        CLRV
        MOV     PC,LR

06      RSBS    FWGRD,FWACCX,#32
        BCC     %FT99                   ; return if shift too large for significance: no round
        TEQ     FSIGN,FWSIGN            ; test signs
        BMI     %08
        MOV     FGRD,FWACC,LSL FWGRD
        ADDS    FACC,FACC,FWACC,LSR FWACCX
        BCC     %16                     ; no renorm needed

; renormalise by right shift with guard

        MOVS    FACC,FACC,RRX
        MOV     FGRD,FGRD,RRX
        ADD     FACCX,FACCX,#1
        CMP     FACCX,#256
        BCS     FOVR
16      CMP     FGRD,#&80000000         ; round with no overflow pain
        BCC     %FT99
        BICEQ   FACC,FACC,#1            ; if eq clear bottom bit so add sets it
        ADDS    FACC,FACC,#1
        BCC     %FT99
        MOV     FACC,FACC,RRX           ; carry set
        ADD     FACCX,FACCX,#1
        CMP     FACCX,#256
        BCC     %FT99
        B       FOVR
08      MOV     FGRD,#0
        SUBS    FGRD,FGRD,FWACC,LSL FWGRD
        SBCS    FACC,FACC,FWACC,LSR FWACCX
        BPL     %12
        Debug   fp,"FADD out: FACC, FACCX, FSIGN =",FACC,FACCX,FSIGN
        CLRV
        MOV     PC,LR

10      MOV     FGRD,#0
        TEQ     FSIGN,FWSIGN
        BPL     %02                     ; signs same
        SUBS    FACC,FACC,FWACC
        MOVCC   FSIGN,FWSIGN
        RSBCCS  FACC,FACC,#0
        BMI     %FT99                   ; return if normalised

; renormalise by left shift with guard: had to subtract mantissas

12      BEQ     FNRMB                   ; no answer in facc: no round possible
        ADDS    FGRD,FGRD,FGRD
        ADCS    FACC,FACC,FACC
        BMI     %18
        ADDS    FGRD,FGRD,FGRD
        ADCS    FACC,FACC,FACC
        BPL     %14
        SUB     FACCX,FACCX,#1
18      SUBS    FACCX,FACCX,#1
        BPL     %16
        CMP     FGRD,#&80000000         ; incipient underflow: see if can round up
        BCC     FCLR                    ; no, underflow to zero
        BICEQ   FACC,FACC,#1            ; if eq clear bottom bit so add sets it
        ADDS    FACC,FACC,#1
        MOVCS   FACC,FACC,RRX
        ADDCS   FACCX,FACCX,#1
        TEQ     FACCX,#0
        BPL     %FT99
        B       FCLR                    ; finally underflow
14      SUB     FACCX,FACCX,#2
        ADDS    FGRD,FGRD,FGRD
        ADCS    FACC,FACC,FACC
        BMI     %18
        ADDS    FGRD,FGRD,FGRD
        ADCS    FACC,FACC,FACC
        BPL     %14
        SUBS    FACCX,FACCX,#2
        BPL     %16
        CMP     FGRD,#&80000000         ; incipient underflow: see if can round up
        BCC     FCLR                    ; no, underflow to zero
        BICEQ   FACC,FACC,#1            ; if eq clear bottom bit so add sets it
        ADDS    FACC,FACC,#1
        MOVCS   FACC,FACC,RRX
        ADDCS   FACCX,FACCX,#1
        TEQ     FACCX,#0
        BPL     %FT99
        B       FCLR                    ; finally underflow
FWTOA   MOV     FACCX,FWACCX
FSWTOA  MOV     FSIGN,FWSIGN
        MOV     FACC,FWACC
99
        CLRV
        MOV     PC,LR

FNRMB   MOVS    FACC,FGRD               ; if facc zero then facc:=fgrd
        BEQ     FCLR
        SUBS    FACCX,FACCX,#32         ; exponent dec by word
     [ UseCLZ
        BMI     FCLR
        CLZ     FGRD,FACC
        MOV     FACC,FACC,LSL FGRD
        SUB     FACCX,FACCX,FGRD
        MOV     PC,LR
     |
      [ :LNOT:No32bitCode
        BMI     FCLR
        Push    LR
        SavePSR LR
        B       IFLTA
      |
        BPL     IFLTA
      ]
     ]

;..................................................................................

; clear  facc
; Note: Can fall through from above

FCLR    MOV     FACCX,#0
        MOV     FACC,#0
        MOV     FSIGN,#0
        MOV     FGRD,#0
        Debug   fp,"FACC = 0"
        CLRV
        MOV     PC,LR

;..................................................................................

; overflow

FOVR    ADR     R0,ErrorBlock_FontOverflow
        Debug   err,"Error: overflow"
        B       MyGenerateError
        MakeInternatErrorBlock FontOverflow,,"NumOFlo"

;..................................................................................

; overflow

ZDIVOR  ADR     R0,ErrorBlock_FontDivby0
        Debug   err,"Error: division by 0"
        B       MyGenerateError
        MakeErrorBlock  FontDivby0

        END
@


4.4
log
@Fix objasm 4 warnings. Allow math code to make use of CLZ. Fix potential crash.
Detail:
  s/Font_BasFP - Uses Hdr:CPU.Arch to decide whether to use CLZ in IFLT routine. Also fixed nasty crash on 32bit systems where FNRMB tail-calls IFLTA; 32bit versions of IFLT stack the LR, but FNRMB wasn't stacking it before jumping into the middle of the code.
  s/Fonts01 - Split up an LDM to avoid deprecated LDM {LR,PC} warning
Admin:
  Tested on rev A2 BB-xM


Version 3.69. Tagged as 'Manager-3_69'
@
text
@d23 1
a23 1
UseCLZ  SETL    :LNOT: (NoARMv5 :LOR: NoARMT)
@


4.3
log
@ Seriously reduce the amount of build options, purging those that have
 been enabled by default for years.
Detail:
 Remaining options are: usesetpalette, newunderline, checkhandles,
 lessercheckhandles, and blendingOn.
Admin:
 Resulting binary is identical to 3.61.


Version 3.62. Tagged as 'Manager-3_62'
@
text
@d20 4
d36 5
d42 2
a43 1
IFLTA   CMP     FACC,#&10000
d58 1
d375 13
d389 2
d395 1
@


4.2
log
@32-bit compatible.

Version 3.48. Tagged as 'Manager-3_48'
@
text
@a384 1
      [ international
a385 3
      |
        MakeErrorBlock  FontOverflow
      ]
@


4.1
log
@Initial revision
@
text
@d23 4
d49 1
d51 4
d58 5
a62 1
        MOV PC,R14
d82 1
a82 1
        MOVS    PC,LR
d126 1
a126 1
        MOVCCS  PC,LR
d201 1
a201 1
FDIVF   MOV     FACC,FWACCX
d204 1
a204 1
        MOVEQS  PC,LR
d212 1
a212 1
        MOVEQS  PC,LR
d256 2
a257 2
        MOVCCS  PC,LR
        BICEQ   FACC,FACC,#1            ; if eq clear bottom bit so add sets it
d259 1
a259 1
        MOVCCS  PC,LR
d263 1
a263 1
        MOVCCS  PC,LR
d271 2
a272 1
        MOVS    PC,LR
d275 1
a275 1
        MOVCCS  PC,LR                   ; return if shift too large for significance: no round
d290 1
a290 1
        MOVCCS  PC,LR
d293 1
a293 1
        MOVCCS  PC,LR
d297 1
a297 1
        MOVCCS  PC,LR
d304 2
a305 1
        MOVS    PC,LR
d313 1
a313 1
        MOVMIS  PC,LR                   ; return if normalised
d334 1
a334 1
        MOVPLS  PC,LR
d352 1
a352 1
        MOVPLS  PC,LR
d357 3
a359 1
        MOVS    PC,LR
d375 2
a376 1
        MOVS    PC,LR
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

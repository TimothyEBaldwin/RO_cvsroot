head	4.6;
access;
symbols
	Manager-3_80:4.6
	Manager-3_79:4.5
	Manager-3_78:4.5
	Manager-3_77:4.5
	Manager-3_76:4.5
	Manager-3_75:4.5
	Manager-3_74:4.4
	Manager-3_73:4.4
	Manager-3_72:4.4
	Manager-3_71:4.3
	Manager-3_70:4.3
	Manager-3_69:4.3
	Manager-3_68:4.3
	Manager-3_67:4.3
	Manager-3_66:4.3
	Manager-3_65:4.3
	Manager-3_64:4.3
	Manager-3_63:4.3
	Manager-3_62:4.3
	Manager-3_61:4.3
	Manager-3_60:4.3
	RO_5_07:4.2
	Manager-3_59:4.2
	Manager-3_58:4.2
	Manager-3_57:4.2
	Manager-3_56:4.2
	Manager-3_55:4.2
	Manager-3_54:4.2
	Manager-3_53:4.2
	Manager-3_52:4.2
	Manager-3_51:4.2
	Manager-3_50:4.2
	Manager-3_49:4.2
	dellis_autobuild_BaseSW:4.2
	Manager-3_48:4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	Manager-3_47:4.1
	Manager-3_46:4.1
	Manager-3_45:4.1
	Manager-3_44:4.1
	Manager-3_43:4.1
	Manager-3_42:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Manager-3_41-4_2_2_13:4.1
	Ursula_RiscPC:4.1.0.10
	Manager-3_41-4_2_2_12:4.1
	Manager-3_41-4_2_2_11:4.1
	Manager-3_41-4_2_2_10:4.1
	Manager-3_41-4_2_2_9:4.1
	Manager-3_41-4_2_2_8:4.1
	Manager-3_41-4_2_2_7:4.1
	Manager-3_41-4_2_2_6:4.1
	Manager-3_41-4_2_2_5:4.1
	Manager-3_41-4_2_2_4:4.1
	Manager-3_41-4_2_2_3:4.1
	Manager-3_41-4_2_2_2:4.1
	Manager-3_41-4_2_2_1:4.1
	NRaine:4.1.0.8
	Manager-3_41:4.1
	Ursula_merge:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	bavison_FontManager-3_40:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Manager-3_40-1_1_2_2:4.1.7.1
	smiddle_2Mar1998_Fonts16:4.1.7.1.0.4
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	StrongARM:4.1.3;
locks; strict;
comment	@# @;


4.6
date	2018.08.13.21.18.45;	author jlee;	state Exp;
branches;
next	4.5;
commitid	zwkox5zv4JSIk0OA;

4.5
date	2013.08.06.23.55.05;	author jlee;	state Exp;
branches;
next	4.4;
commitid	XZW0yxi515Wl7s0x;

4.4
date	2012.02.25.18.15.25;	author jlee;	state Exp;
branches;
next	4.3;
commitid	bMaGSllOAEo5dzUv;

4.3
date	2005.08.03.12.23.34;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.12.12.39.45;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.06.02.15.40;	author nturton;	state Exp;
branches
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.3.1
date	96.11.06.02.15.40;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.51.19;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.14.21;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Fix background blending sometimes setting alpha to zero in 32bpp modes
Detail:
  s/Blending - blend_putdata_32bpp contains an optimisation to avoid reading the screen pixel if the text pixel is fully opaque. However this means that the source alpha can't be preserved, going against the rules set out in the comment preceeding setblendingdata (and in reality, the alpha channel would be set to zero). Fix this by introducing a new blend_putdata_32bppA variant which always reads from the screen, ensuring the alpha channel can be preserved.
Admin:
  Tested on Raspberry Pi 3B
  Hardware overlays underneath the desktop are no longer visible through the zero-alpha font pixels


Version 3.80. Tagged as 'Manager-3_80'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > s.Blending

	GET 	hdr:ITable

; ------------------------------------------------------------------------------
; Blending macro, performs the grunt work of scaling a component by the alpha value.
; ------------------------------------------------------------------------------

;   $mask	=> mask for component within src/destination
;   $destData	=> background colour data
;   $alphaDst	=> alpha value 0-16 for amount of destination to be copied
;   $srcData	=> source colour data
;   $alphaSrc	=> alpha value 0-16 for amount of source to be copied
;   $shift	=> shift value for dealing with high bit guns.
; Assume alphaDst+alphaSrc <= 16
; Corrupts R2, R3

	MACRO
$l	Blend	$mask, $destData, $alphaDst, $srcData, $alphaSrc, $shift
        ASSERT  ("$shift" <> "") :LOR: (($mask :AND: &F0000000)=0)
$l
 [ NoARMT2
     [ ("$shift"="") :LOR: (($mask :AND: &80000000)<>0)
	ANDS	R2, $destData, # $mask
      [ "$shift"<>""
	MOVS	R2, R2, LSR # $shift
      ]
     |
	MOVS	R2, $destData, LSR # $shift
     ]
	MULNE	R2, $alphaDst, R2

      [ "$shift"=""
	ANDS	R3, $srcData, # $mask
      |
	MOVS	R3, $srcData, LSR # $shift
      ]
	MLANE	R2, $alphaSrc, R3, R2

      [ "$shift"=""
	BIC	$destData, $destData, #$mask
	AND	R2, R2, #$mask:SHL:4
	ORR	$destData, $destData, R2, LSR #4
      |
	ASSERT	$shift >= 4
	BIC	$destData, $destData, # $mask
	AND	R2, R2, #$mask:SHR:($shift-4)
	ORR	$destData, $destData, R2, LSL # $shift-4
      ]
 |
        ; Find which bits we're interested in
        LCLA    shift
        LCLA    count
shift   SETA    0
count   SETA    1
        WHILE   ($mask:AND:(1:SHL:shift)) = 0
shift   SETA    shift+1
        WEND
        WHILE   ((shift+count)<32) :LAND: (($mask:AND:(1:SHL:(shift+count))) <> 0)
count   SETA    count+1
        WEND
        ; Now use UBFX/BFI to extract/insert those bits
        UBFX    R2, $destData, #shift, #count
        MUL     R2, $alphaDst, R2
        UBFX    R3, $srcData, #shift, #count
        MLA     R2, $alphaSrc, R3, R2
        MOV     R2, R2, LSR #4
        BFI     $destData, R2, #shift, #count
 ]
	MEND

; Check if plottype has changed since last setblendingdata, and if so,
; mark as invalid
checkblend
        Entry   "R0"
        LDR     R0, plottype
        LDR     LR, blend_plottype
        EOR     R0,R0,LR
      [ blendingOn
        TST     R0, #paint_blendsupr
      |
        TST     R0, #paint_blended:OR:paint_blendsupr
      ]
        EXIT    EQ
        LDRB    LR, setoutputdataflag
        ORR     LR, LR, #setout_badblending
        STRB    LR, setoutputdataflag
        EXIT

; ------------------------------------------------------------------------------
; Prime the blending engine ready to do its work, first we validate our state:
;
;	- is the mode supported
;	- has the client asked for blending to be performed
;	- do we have cached blending information
;
; Assuming that the above is passed then we prepare the pixel writing vectors
; and compute suitable table data which we can use when painting the character
; data onto the screen.
;
; Several routines are used depending on the output mode and paint_blendsupr
; flag:
;
; - 8bpp modes go via a routine that uses InverseTable to convert to 15bpp and
;   back
; - 16bpp 1555 and 16bpp 565 only have normal blending
; - 16bpp 4444 and 32bpp 8888 have three routines: normal, supremacy, and alpha
; - red/blue swapping in true-colour modes is handled by swapping blend_fgvalue
; - alpha/transparency mode of screen is irrelevant for normal blending;
;   existing alpha/transparency of screen pixel is preserved
;
; ------------------------------------------------------------------------------

setblendingdata EntryS "R0-R3,R10"

        LDR     R0, plottype                            ; has client requested background blending?
        STR     R0, blend_plottype
      [ :LNOT: blendingOn
        TST     R0, #paint_blended
        BEQ     %FT80
      ]

        LDR     R10, log2bpp                            ; log2 depth of output device
        CMP     R10, #5                                 ;   if > 32 bit per pixel then ignore
        BGT     %FT80
        ADDEQ   R10, R10, #2                            ; skip the 16bpp entries

        SUBS    R10, R10, #3                            ; convert to a valid index
        BMI     %FT80                                   ;   and if < 8 bit per pixel then ignore

        CMP     R10, #1
        LDR     R2, modeflags
        BNE     %FT10
        LDR     R3, ncolour
        TST     R2, #ModeFlag_64k
        MOVNE   R10, #2
        CMP     R3, #4096
        MOVLT   R10, #3
10
        ADR     R3, blend_table                         ; get pointer to blending functions for the depth
        ADD     R10, R3, R10, LSL #5                    ;   index via the depth offset
        ADD     R1, R10, #8
        TST     R0, #paint_blendsupr                    ; supremacy blending?
        ADDNE   R1, R1, #8
        TSTNE   R2, #ModeFlag_DataFormatSub_Alpha       ; alpha blending?
        ADDNE   R1, R1, #8

        LDMIA   R10, {R0, R10}                          ; get alpha table, conversion function
        ADD     LR, R0, R3
        ADD     R10, R10, R3
        LDMIA   R1, {R0, R1}                            ; get blending functions
        CMP     R0, #0
        BEQ     %FT96
        ; Use the right variant for 32bpp with alpha
        CMP     R0, #blend_convert_32bpp - blend_table
        BNE     %FT20
        TST     R2, #ModeFlag_DataFormatSub_Alpha
        ADDNE   R0, R0, #blend_putdata_32bppA - blend_putdata_32bpp
20
        ADD     R0, R0, R3
        ADD     R1, R1, R3
        ADRL    R3, blend_putdata
        STMIA   R3, {R0, R1, LR}                        ; store blend functions, alpha table
        
        LDR     R0, currentRGB_f                        ; get the foreground pixel colour
        TST     R2, #ModeFlag_DataFormatSub_RGB
        ANDNE   R2, R0, #&FF0000
        BICNE   R0, R0, #&FF
        ORRNE   R0, R2, R0, ROR #16
      [ NoARMv5
        MOV     LR, PC
        MOV     PC, R10                                 ; convert colour
      |
        BLX     R10                                     ; convert colour
      ]
        STR     R0, blend_fgvalue

        LDRB    R0, currentRGB_f                        ; get the foreground supremacy
        RSB     R0, R0, #255                            ;   convert to alpha
        CMP     R0, #128
        ADDGE   R0, R0, #1                              ;   scale to 0-&100
        STR     R0, blend_fgalpha

        LDRB    LR, bitsperpixel                        ; get the real pixel depth
        TEQ     LR, #8                                  ;   is this 8 bit per pixel?
        BNE     %FT95

        SWI     XInverseTable_Calculate                 ; compute the inverse colour table
        ADRVCL  LR, blend_ctable                        ;   it worked so store the table pointers
        STMVCIA LR, { R0, R1 }
        BVC     %FT95

80
        ADRL    R0, putdata_mono                        ; default pointers for functions etc
        ADRL    R1, putdataM_mono
        ADR     R2, outputdata
        ADRL    R3, blend_putdata                       ; and store the table values away
        STMIA   R3, { R0-R1, R2 }
95
        PExitS

96
        PullEnv
xerr_FontBadSupremacyBlend
        ADR     R0,ErrorBlock_FontBadSupremacyBlend
        B       MyGenerateError
        MakeErrorBlock FontBadSupremacyBlend

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Function tables for performing the blending, along with the alpha tables
; used to convert from cache data into data that the blending functions
; can sensibly cope with.
;
;       +0      -> offset to alpha table
;       +4      -> offset to colour conversion function
;       +8      -> offset to putdata function
;       +12     -> offset to putdataM function
;       +16     -> offset to putdataS function
;       +20     -> offset to putdataSM function
;       +24     -> offset to putdataA function
;       +28     -> offset to putdataAM function

blend_table
        &       alpha_table8 - blend_table              ; 8 bpp
        &       blend_convert_1555 - blend_table
        &       blend_putdata_8bpp - blend_table
        &       blend_putdataM_8bpp - blend_table
        &       0
        &       0
        &       0
        &       0

        &       alpha_table16 - blend_table             ; 16 bpp 1555 blending
        &       blend_convert_1555 - blend_table
        &       blend_putdata_1555 - blend_table
        &       blend_putdataM_1555 - blend_table
        &       0
        &       0
        &       0
        &       0

        &       alpha_table16 - blend_table             ; 16 bpp 565 blending
        &       blend_convert_565 - blend_table
        &       blend_putdata_565 - blend_table
        &       blend_putdataM_565 - blend_table
        &       0
        &       0
        &       0
        &       0

        &       alpha_table16 - blend_table             ; 16 bpp 4444 blending
        &       blend_convert_4444 - blend_table
        &       blend_putdata_4444 - blend_table
        &       blend_putdataM_4444 - blend_table
        &       blend_putdataS_4444 - blend_table
        &       blend_putdataSM_4444 - blend_table
        &       blend_putdataA_4444 - blend_table
        &       blend_putdataAM_4444 - blend_table

        &       alpha_table32 - blend_table             ; 32 bpp blending
        &       blend_convert_32bpp - blend_table
        &       blend_putdata_32bpp - blend_table
        &       blend_putdataM_32bpp - blend_table
        &       blend_putdataS_32bpp - blend_table
        &       blend_putdataSM_32bpp - blend_table
        &       blend_putdataA_32bpp - blend_table
        &       blend_putdataAM_32bpp - blend_table

alpha_table8
	& &00000000, &01000000, &02000000, &03000000, &04000000, &05000000, &06000000, &07000000
	& &09000000, &0A000000, &0B000000, &0C000000, &0D000000, &0E000000, &0F000000, &10000000

alpha_table16
	& &00000000, &00010000, &00020000, &00030000, &00040000, &00050000, &00060000, &00070000
	& &00090000, &000A0000, &000B0000, &000C0000, &000D0000, &000E0000, &000F0000, &00100000

alpha_table32
	& &00000000, &00000100, &00000200, &00000300, &00000400, &00000500, &00000600, &00000700
	& &00000900, &00000A00, &00000B00, &00000C00, &00000D00, &00000E00, &00000F00, &00001000

blend_convert_1555
        ColourConv r0, r0, r1, r2, r3, 0, 5, 5, 5, 10, 5
        ORR     r0, r0, r0, LSL #16
        MOV     pc, lr

blend_convert_565
        ColourConv r0, r0, r1, r2, r3, 0, 5, 5, 6, 11, 5
        ORR     r0, r0, r0, LSL #16
        MOV     pc, lr

blend_convert_4444
        ColourConv r0, r0, r1, r2, r3, 0, 4, 4, 4, 8, 4
        ORR     r0, r0, r0, LSL #16
        MOV     pc, lr

blend_convert_32bpp
        MOV     r0, r0, LSR #8
        MOV     pc, lr

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Output function to cope with outputting no data to the destination buffer,
; resets the flags words and advances the pointer.
;
; out:	outptr += 4
;	outdata = &80000000
;	outmask = &00000000

blend_nodata

	ADD	outptr, outptr, #4			; skip this pixel set
	MOV	outdata, #&80000000			;   and if result is nothing then return
	MOV	outmask, #0

	MOV	PC, LR


; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Blending methods for 8 bit per pixel, these are more complicated as we
; must attempt to go from 8 bit index to 15 bit RGB.  Having done this we
; can then perform the blend before returning back to 8 bits again.

blend_putdata_8bpp

	ANDS	outdata, outdata, outmask		; ensure only relevant bits are set
	BEQ	blend_nodata				;   if none set then write out

	Push	"R1-R3, R6-R7, R10-R11, LR"

	ADRL	R1, blend_fgvalue
	LDMIA	R1, { R1, R10, R11 }			; fg, blend_ctable, blend_itable

	LDR	pchar, [ outptr ]			; pick up the background pixel data
	MOV	R6, #4					; number of pixels to process
10
	ANDS	R9, outdata, #&0000001F			; is this pixel set?
	MOVEQ	pchar, pchar, ROR # 8			;   if not then ignore this pixel
	BEQ	%FT20

	AND	R7, pchar, #&000000FF			; get the palette index for this colour
	LDR	R7, [ R10, R7, LSL # 2 ]		;   and convert to 5,5,5 RGB value

	RSB	LR, R9, # 16				; amount of background to be preserved
	Blend 	&0000001f, R7, LR, R1, R9		;   and combine together blended
	Blend 	&000003e0, R7, LR, R1, R9
	Blend	&00007c00, R7, LR, R1, R9

	LDRB	R7, [ R11, R7 ]				; get the new colour number from the 5,5,5 RGB
	MOV	pchar, pchar, LSR #8			;   clear top bits and combine
	ORR	pchar, pchar, R7, LSL # 24
20
	MOV	outdata, outdata, LSR # 8		; move output data down again

	SUBS	R6, R6, #1				; decrease number of pixels to be processed
	BNE	%BT10					;   and keep looping until all done

	STR	pchar, [ outptr ], #4			; write out the new pixel data to the destination

        MOV     outdata, #&80000000              	; set marker bit ready for next set of pixels
        MOV     outmask, #0

	Pull	"R1-R3, R6-R7, R10-R11, PC"

blend_putdataM_8bpp

	ANDS	outdata, outdata, outmask		; ensure only relevant bits are set
	BEQ	blend_nodata				;   if none set then write out

	Push	"outptr, R1-R4, R6-R7, R10-R11, R12, LR"

	ADRL	R1, blend_fgvalue
	LDMIA	R1, { R1, R10, R11 }			; fg, blend_ctable, blend_itable

	LDR	R4, this_ymagcnt			; pick up scaling information
	LDR	R12, linelen				;   line advancement value
05
	LDR	pchar, [ outptr ]			; pick up the background pixel data
	MOV	R6, #4					; number of pixels to process
10
	ANDS	R9, outdata, #&0000001F			; is this pixel set?
	MOVEQ	pchar, pchar, ROR # 8			;   if not then ignore this pixel
	BEQ	%FT20

	AND	R7, pchar, #&000000FF			; get the palette index for this colour
	LDR	R7, [ R10, R7, LSL # 2 ]		;   and convert to 5,5,5 RGB value

	RSB	LR, R9, # 16				; amount of background to be preserved
	Blend 	&0000001f, R7, LR, R1, R9		;   and combine together blended
	Blend 	&000003e0, R7, LR, R1, R9
	Blend	&00007c00, R7, LR, R1, R9

	LDRB	R7, [ R11, R7 ]				; get the new colour number from the 5,5,5 RGB
	MOV	pchar, pchar, LSR #8			;   clear top bits and combine
	ORR	pchar, pchar, R7, LSL # 24
20
	MOV	outdata, outdata, ROR # 8		; move output data down again

	SUBS	R6, R6, #1				; decrease number of pixels to be processed
	BNE	%BT10					;   and keep looping until all done

	STR	pchar, [ outptr ], -R12			; write out the new pixel data to the destination

	SUBS	R4, R4, # 1				; decrease the scaling count
	BNE	%BT05

	Pull	"outptr, R1-R4, R6-R7, R10-R11, R12, LR"
	B	blend_nodata				; reset for end of line, and advance

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Normal blending methods, 16bpp

        MACRO
$l      BlendNormal16  $mask1,$mask2,$mask3,$shift
        AlignCd (Urk):MOD:16
$l
	ANDS	outdata, outdata, outmask		; ensure only relevant bits are set
	BEQ	blend_nodata

	Push	"R1-R3, LR"

	LDR	R1, blend_fgvalue			; foreground painting colour
        LDR     pchar, [ outptr ]			;   and pick up the current background pixel data

	ANDS	R9, outdata, #&0000001F			; what is the intensity of the pixel we want to plot
	BEQ	%FT20					;   if == 0 then nothing therefore skip

	RSB	LR, R9, # 16				; amount of background to be preserved
	Blend 	$mask1, pchar, LR, R1, R9		;   and combine together blended
	Blend 	$mask2, pchar, LR, R1, R9
	Blend	$mask3, pchar, LR, R1, R9
20
	MOVS	outdata, outdata, LSR # 16		; what is the intensity of the pixel we want to plot
	BEQ	%FT30					;   if == 0 then nothing therefore skip

	RSB	LR, outdata, # 16			; amount of background to blend with
	Blend 	$mask1<<16, pchar, LR, R1, outdata	;   and do the blending
	Blend	$mask2<<16, pchar, LR, R1, outdata
	Blend	$mask3<<16, pchar, LR, R1, outdata, $shift
30
        STR     pchar, [ outptr ], #4 			; write the new pixel value out

        MOV     outdata, #&80000000              	; set marker bit ready for next set of pixels
        MOV     outmask, #0

	Pull	"R1-R3, PC"
        MEND 

        MACRO
$l      BlendNormal16M $mask1,$mask2,$mask3,$shift
        AlignCd (Urk):MOD:16
$l
	ANDS	outdata, outdata, outmask
	BEQ	blend_nodata				; nothing to be blended therefore ignore

	Push	"outptr, R1-R3, R6-R7, LR"

	LDR	R1, blend_fgvalue			; colour value ready to blend into the destination

	LDR	R6, linelen
	LDR	R7, this_ymagcnt			; pick up scaling information
10
        LDR     pchar, [ outptr ]			; and pick up the current background pixel data

	ANDS	R9, outdata, #&0000001F			; what is the intensity of the pixel we want to plot
	BEQ	%FT20					;   if == 0 then nothing therefore skip

	RSB	LR, R9, # 16				; amount of background to be preserved
	Blend 	$mask1, pchar, LR, R1, R9		;   and combine together blended
	Blend 	$mask2, pchar, LR, R1, R9
	Blend	$mask3, pchar, LR, R1, R9
20
	MOVS	R9, outdata, LSR # 16			; what is the intensity of the pixel we want to plot
	BEQ	%FT30					;   if == 0 then nothing therefore skip

	RSB	LR, R9, # 16				; amount of background to blend with
	Blend 	$mask1<<16, pchar, LR, R1, R9		;   and do the blending
	Blend	$mask2<<16, pchar, LR, R1, R9
	Blend	$mask3<<16, pchar, LR, R1, R9, $shift
30
        STR     pchar, [ outptr ], -R6 			; write the new pixel value out

	SUBS	R7, R7, # 1				; decrease the counter
	BNE	%BT10					;   and loop again

	Pull	"outptr, R1-R3, R6-R7, LR"
	B	blend_nodata
	MEND

blend_putdata_1555  BlendNormal16  &001F,&03E0,&7C00,26
blend_putdata_565   BlendNormal16  &001F,&07E0,&F800,27
blend_putdata_4444  BlendNormal16  &000F,&00F0,&0F00

blend_putdataM_1555 BlendNormal16M &001F,&03E0,&7C00,26
blend_putdataM_565  BlendNormal16M &001F,&07E0,&F800,27
blend_putdataM_4444 BlendNormal16M &000F,&00F0,&0F00


; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Blend into 32 bit per pixel

        AlignCd (Urk):MOD:16

blend_putdata_32bpp

	ANDS	outdata, outdata, outmask		; ensure only relevant bits are set
	BEQ	blend_nodata

	Push	"R1-R3, LR"

	LDR	R1, blend_fgvalue			; get the foreground painting colour

        ; outdata = &00000000-&00001000 (clear->solid)
	MOV	outdata, outdata, LSR # 8		; amount of foreground to blend
        ; outdata = 0-16 (clear-solid)
	RSBS	LR, outdata, # 16			;   and the amount of background

        MOVEQ   pchar, #0
        LDRNE   pchar, [ outptr ]			; and pick up the current background pixel data
blend_putdata_32bpp_common
	Blend 	&000000FF, pchar, LR, R1, outdata	;   blend them together
	Blend 	&0000FF00, pchar, LR, R1, outdata
	Blend	&00FF0000, pchar, LR, R1, outdata
        STR     pchar, [ outptr ], #4 			; write the new pixel value out

        MOV     outdata, #&80000000              	; set marker bit ready for next set of pixels
        MOV     outmask, #0

	Pull	"R1-R3, PC"

; Variant of blend_putdata_32bpp for alpha channel destination - always pixel up destination word, so that alpha channel is preserved
blend_putdata_32bppA

	ANDS	outdata, outdata, outmask		; ensure only relevant bits are set
	BEQ	blend_nodata

	Push	"R1-R3, LR"

	LDR	R1, blend_fgvalue			; get the foreground painting colour

        ; outdata = &00000000-&00001000 (clear->solid)
	MOV	outdata, outdata, LSR # 8		; amount of foreground to blend
        ; outdata = 0-16 (clear-solid)
	RSB	LR, outdata, # 16			;   and the amount of background

        LDR     pchar, [ outptr ]			; and pick up the current background pixel data
        B       blend_putdata_32bpp_common

blend_putdataM_32bpp

	ANDS	outdata, outdata, outmask
	BEQ	blend_nodata				; nothing to be blended therefore ignore

	Push	"outptr, R1-R3, R6, LR"

	LDR	R1, blend_fgvalue			; get the foreground painting colour
	LDR	R6, linelen				;   and the scaling information
	LDR	R9, this_ymagcnt

	MOV	outdata, outdata, LSR # 8		; amount of foreground to blend
	RSB	LR, outdata, # 16			;   and the amount of background
01
        LDR     pchar, [ outptr ]			; and pick up the current background pixel data
	Blend 	&000000FF, pchar, LR, R1, outdata	;   blend them together
	Blend 	&0000FF00, pchar, LR, R1, outdata
	Blend	&00FF0000, pchar, LR, R1, outdata
        STR     pchar, [ outptr ], -R6 			; write the new pixel value out

	SUBS	R9, R9, #1
	BNE	%BT01

	Pull	"outptr, R1-R3, R6, LR"
	B	blend_nodata

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Blend into 16/32 bit per pixel, with supremacy or alpha blending
; This generates blend_putdataS_32bpp, blend_putdataA_32bpp,
; blend_putdataSM_32bpp, blend_putdataSA_32bpp, blend_putdataS_4444,
; blend_putdataA_4444, blend_putdataSM_4444, and blend_putdataAM_4444

        GBLS    routine

routine SETS    "S"

        AlignCd (Urk):MOD:16

        GET     s.BlendingS

routine SETS    "A"

        AlignCd (Urk):MOD:16

        GET     s.BlendingS

	END
@


4.5
log
@Update to cope with new pixel formats
Detail:
  s/Fonts01, s/Fonts02 - Cache the current mode flags & NColour values
  s/Blending - Font blending code improved to add support for new pixel formats. Supremacy blending code split off into seperate file as it's too big for a macro.
  s/BlendingS - New file containing the guts of the supremacy blending code. Old code only supported supremacy blending in 32bpp &TBGR modes; new code supports supremacy blending in 16bpp 4444 &TBGR, as well as alpha blending in 32bpp &TBGR and 16bpp 4444 &TBGR, and red/blue swapped modes (as well as the main blending code supporting all new RGB modes).
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format Spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 3.75. Tagged as 'Manager-3_75'
@
text
@d168 6
d548 18
@


4.4
log
@Use long multiplies where possible. Simple blended font optimisations.
Detail:
  s/Blending - Optimise blended font plotting a bit. Now use UBFX/BFI on ARMv6T2+, for a speed gain of a few percent. Pre-ARMv6T2 code optimised to get rid of unneeded shifts and result clamping
  s/Font_Arith, s/Fonts04 - Make use of long multiplies where possible. If long multiplies are in use, some routines have been inlined since they're now just a handful of instructions instead of 10 or so.
Admin:
  Tested in IOMD & OMAP3 ROMs
  Blended fonts and transformed fonts seem to work OK


Version 3.72. Tagged as 'Manager-3_72'
@
text
@d34 1
d37 1
a37 1
      [ "$shift"=""
d39 4
a42 1
      |
d44 1
a44 1
      ]
d114 12
d130 1
a130 1
	LDR	R0, plottype				; has client requested background blending?
d133 2
a134 2
	TST	R0, #paint_blended
	BEQ	%FT80
d137 48
a184 34
	LDR	R10, log2bpp				; log2 depth of output device
	CMP	R10, #5					;   if > 32 bit per pixel then ignore
	BGT	%FT80

	SUBS	R10, R10, #3				; convert to a valid index
	BMI	%FT80					;   and if < 8 bit per pixel then ignore

        TST     R0, #paint_blendsupr                    ; supremacy blending only in 32bpp
        BEQ     %FT40
        TEQ     R10, #2
        ADDEQ   R10, R10, #1
        BNE     %FT96

40	ADR	R3, blend_table				; get pointer to blending functions for the depth
	ADD	R0, R3, R10, LSL # 4			;   index via the depth offset
	LDMIA	R0, { R0, R1, R2, R10 }
	ADD	R0, R0, R3
	ADD	R1, R1, R3
	ADD	R2, R2, R3

	Push	"R0-R1"

	TEQ	R10, #32				; check to see what depth we are in:-

	LDR	R0, currentRGB_f			; get the foreground pixel colour
	MOVEQ	R0, R0, LSR # 8				;   if 32 bit per pixel then shift down so aligned to bit 0
	ANDNE	R1, R0, #&f8000000			;   if 16 bit per pixel then generate 5,5,5 from 24 bit colour
	ANDNE	LR, R0, #&00f80000
	ORRNE	R1, R1, LR, LSL # 3
	ANDNE	R0, R0, #&0000f800
	ORRNE	R0, R1, R0, LSL # 6
	ORRNE	R0, R0, R0, LSR # 16
	MOVNE	R0, R0, LSR # 1
	STR	R0, blend_fgvalue
d192 8
a199 8
	LDRB	LR, bitsperpixel			; get the real pixel depth
	TEQ	LR, #8					;   is this 8 bit per pixel?
	BNE	%FT95

	SWI	XInverseTable_Calculate			; compute the inverse colour table
	ADRVCL	LR, blend_ctable			;   it worked so store the table pointers
	STMVCIA	LR, { R0, R1 }
	BVC	%FT95
a200 1
	ADD	SP, SP, # 4*2
d202 5
a206 8
	ADRL	R0, putdata_mono			; default pointers for functions etc
	ADRL	R1, putdataM_mono
	ADR	R2, outputdata
90
	ADRL	R3, blend_putdata			; and store the table values away
	STMIA	R3, { R0-R1, R2 }

	PExitS
d208 1
a208 2
	Pull	"R0-R1"
	B	%BT90
d223 8
a230 4
; 	+0	-> offset to putdata function
;	+4 	-> offset to putdataM function
;	+8	-> offset to alpha table
;	+12 	= bits per pixel (required for 8 bit blending)
d233 44
a276 19
	&	blend_putdata_8bpp - blend_table	; 8 bpp
	&	blend_putdataM_8bpp - blend_table
	&	alpha_table8 - blend_table
	&	16					; (trick internals into 16 bits per pixel)

	&	blend_putdata_16bpp - blend_table	; 16 bpp blending
	&	blend_putdataM_16bpp - blend_table
	&	alpha_table16 - blend_table
	&	16

	&	blend_putdata_32bpp - blend_table	; 32 bpp blending
	&	blend_putdataM_32bpp - blend_table
	&	alpha_table32 - blend_table
	&	32

	&	blend_putdataS_32bpp - blend_table	; 32 bpp supremacy blending
	&	blend_putdataSM_32bpp - blend_table
	&	alpha_table32 - blend_table
	&	32
d290 18
d421 1
a421 1
; Blending methods for 16 bit per pixel.
d423 2
d426 1
a426 3

blend_putdata_16bpp

d439 3
a441 3
	Blend 	&0000001f, pchar, LR, R1, R9		;   and combine together blended
	Blend 	&000003e0, pchar, LR, R1, R9
	Blend	&00007c00, pchar, LR, R1, R9
d447 3
a449 3
	Blend 	&001f0000, pchar, LR, R1, outdata	;   and do the blending
	Blend	&03e00000, pchar, LR, R1, outdata
	Blend	&7c000000, pchar, LR, R1, outdata, 26
d457 1
d459 4
a462 2
blend_putdataM_16bpp

d479 3
a481 3
	Blend 	&0000001f, pchar, LR, R1, R9		;   and combine together blended
	Blend 	&000003e0, pchar, LR, R1, R9
	Blend	&00007c00, pchar, LR, R1, R9
d487 3
a489 3
	Blend 	&001f0000, pchar, LR, R1, R9		;   and do the blending
	Blend	&03e00000, pchar, LR, R1, R9
	Blend	&7c000000, pchar, LR, R1, R9, 26
d498 9
d527 1
a527 1
	RSB	LR, outdata, # 16			;   and the amount of background
d529 2
a530 1
        LDR     pchar, [ outptr ]			; and pick up the current background pixel data
d570 4
a573 3
; Blend into 32 bit per pixel, with supremacy blending
; almost the same as above, but with a check for background supremacy,
; and handling of foreground supremacy.
d575 1
a575 1
        AlignCd (Urk):MOD:16
d577 1
a577 1
blend_putdataS_32bpp
d579 1
a579 2
	ANDS	outdata, outdata, outmask		; ensure only relevant bits are set
	BEQ	blend_nodata
d581 1
a581 1
	Push	"R1-R3, LR"
d583 1
a583 2
	LDR	R1, blend_fgvalue			; get the foreground painting colour
        LDR     R2, blend_fgalpha                       ; and the foreground alpha
d585 1
a585 96
        ; outdata = &00000000-&00001000 (clear->solid)
	MOV	outdata, outdata, LSR # 8		; amount of foreground to blend
        ; outdata = 0-&10 (clear-solid)
        MUL     outdata, R2, outdata                    ; scale by foreground alpha
        ; outdata = 0-&1000 (clear-solid)
        MOVS    outdata, outdata, LSR #8                ; scale back to 0-&10
        ADC     outdata, outdata, #0                    ;   and round

	RSB	LR, outdata, # 16			;   and the amount of background

        LDR     pchar, [ outptr ]			; and pick up the current background pixel data
        MOVS    R2, pchar, LSR #24
        BEQ     blend_putdata_32bpp_common
        ADR     LR, blend_putdata_32bpp_common
        ; fall through into blend_putdataS_32bpp_nonopaque

; In pchar(R0) = screen data (non-opaque)
;    outdata(R8) = anti-alias level 0-16 (clear-solid)
;    R2 = bg supremacy (0-255) (solid-clear)
;    blend_putdata's R1-R3,LR stacked
; Out: outdata and LR updated to reflect correct fg/bg weighting
;      pchar's supremacy byte updated with composite supremacy
;      R2,R3,outmask corrupted
;      may jump out to blend_nodata if applicable

; Terminology: R,G,B,A components
;              suffix t denotes top (ie text)
;                     b denotes bottom (ie screen background)
;                     c denotes composite (ie blended)
blend_putdataS_32bpp_nonopaque
;        Can corrupt R2-R3 freely
; First calculate composite alpha level. FG alpha (At) is in range 0-16,
; BG alpha (Ab) is in range 255-0.
; First Ac = 1 - (1 - At) * (1 - Ab)
        CMP     R2, #128
        ADDGT   R2, R2, #1      ; R2 = 1-Ab scaled 0-&100
        RSB     outmask, outdata, #16; outmask = 1-At scaled 0-&10
        MUL     R3, R2, outmask ; R3 = (1-At)*(1-Ab) - 0-&1000
        RSBS    R3, R3, #4096   ; R3 = Ac (0=clear - &1000=solid)
        BEQ     blend32S_nodata

; Note Ac must >= At

; s := At / Ac
        MOV     R2, outdata, LSL #16    ; R2 = At scaled 0-&100000
        DivRem  outdata, R2, R3, outmask; outdata = At/Ac = s scaled 0-&100
        MOVS    outdata, outdata, LSR #4; s scaled 0-&10
        ADC     outdata, outdata, #0    ; round
        MOVS    R3, R3, LSR #4          ; R3 = Ac scaled 0-&100
        ADC     R3, R3, #0              ; round
        CMP     R3, #128
        SUBGE   R3, R3, #1              ; R3 = Ac scaled 0-&FF
        RSB     R3, R3, #255            ; convert to supremacy &FF-0
        BIC     pchar, pchar, #&FF000000
        ORR     pchar, pchar, R3, LSL #24  ; Place Ac in pchar
        MOV     R2, LR
        RSB     LR, outdata, #16        ; t scaled 0-&10
        MOV     PC, R2

blend32S_nodata
        Pull    "R1-R3, LR"
        B       blend_nodata

blend_putdataSM_32bpp

	ANDS	outdata, outdata, outmask
	BEQ	blend_nodata				; nothing to be blended therefore ignore

	Push	"outptr, R1-R3, R6, LR"

	LDR	R1, blend_fgvalue			; get the foreground painting colour
        LDR     R2, blend_fgalpha                       ;   and the foreground alpha
	LDR	R6, linelen				;   and the scaling information
	LDR	R9, this_ymagcnt

	MOV	outdata, outdata, LSR # 8		; amount of foreground to blend
        ; outdata = 0-&10 (clear-solid)
        MUL     outdata, R2, outdata                    ; scale by foreground alpha
        ; outdata = 0-&1000 (clear-solid)
        MOVS    outdata, outdata, LSR #8                ; scale back to 0-&10
        ADC     outdata, outdata, #0                    ;   and round
	RSB	LR, outdata, # 16			;   and the amount of background
01
        LDR     pchar, [ outptr ]			; and pick up the current background pixel data
        MOVS    R2, pchar, LSR #24
        BLNE    blend_putdataS_32bpp_nonopaque
	Blend 	&000000FF, pchar, LR, R1, outdata	;   blend them together
	Blend 	&0000FF00, pchar, LR, R1, outdata
	Blend	&00FF0000, pchar, LR, R1, outdata
        STR     pchar, [ outptr ], -R6 			; write the new pixel value out

	SUBS	R9, R9, #1
	BNE	%BT01

	Pull	"outptr, R1-R3, R6, LR"
	B	blend_nodata
d587 1
@


4.3
log
@Added support for supremacy blending in 32bpp modes only. If bit 14 is set
in Font_Paint as well as bit 11 (for blending), then the blending takes into
account the supremacy bits of the screen data when compositing. If not in a
32-bpp mode, then an error is returned.

In addition, when bits 11 and 14 are set, the supremacy bits in the chosen
foreground colour (set via ColourTrans_SetFontColours or similar) are used,
so you can plot semi-transparent text. This is a limited facility - it's
not available below 32bpp, and it doesn't work for text above FontMax2.

Also, fixed a bug which meant that successive paints with different blending
flags had to be separated by colour-setting calls to get the new flags to
be obeyed.

Note that, as in previous versions, the blending still doesn't correct for
gamma.

Version 3.60. Tagged as 'Manager-3_60'
@
text
@d25 1
a25 1
;   $alphaDst	=> alpha value 0-31 for amount of destination to be copied
d27 1
a27 1
;   $alphaSrc	=> alpha value 0-31 for amount of source to be copied
d29 2
d35 1
a48 1
	MOV	R2, R2, LSR # 4
a50 3
	CMP	R2, #$mask
	MOVGT	R2, #$mask
	AND	R2, R2, #$mask
d52 2
a53 1
	ORR	$destData, $destData, R2
d55 1
a55 3
	CMP	R2, #$mask:SHR:$shift
	MOVGT	R2, #$mask:SHR:$shift
	AND	R2, R2, #$mask:SHR:$shift
d57 2
a58 1
	ORR	$destData, $destData, R2, LSL # $shift
d60 20
a79 1

@


4.2
log
@32-bit compatible.

Version 3.48. Tagged as 'Manager-3_48'
@
text
@d64 17
d96 2
a98 1
	LDR	R0, plottype				; has client requested background blending?
d110 7
a116 1
	ADR	R3, blend_table				; get pointer to blending functions for the depth
d138 6
d167 6
d201 5
d422 1
d424 1
d428 1
d465 115
@


4.1
log
@Initial revision
@
text
@d77 1
a77 1
setblendingdata Entry "R0-R3,R10"
d193 1
a193 1
	MOVS	PC, LR
d241 1
a241 1
	Pull	"R1-R3, R6-R7, R10-R11, PC",,^
d325 1
a325 1
	Pull	"R1-R3, PC",,^
d393 1
a393 1
	Pull	"R1-R3, PC",,^
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@

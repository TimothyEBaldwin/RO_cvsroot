head	4.14;
access;
symbols
	ITable-0_18:4.14
	ITable-0_17:4.12
	ITable-0_16:4.11
	RO_5_07:4.9
	ITable-0_15:4.9
	ITable-0_14:4.8
	dellis_autobuild_BaseSW:4.8
	ITable-0_13:4.8
	ITable-0_12:4.7
	ITable-0_11:4.6
	ITable-0_10:4.5
	sbrodie_sedwards_16Mar2000:4.4
	dcotton_autobuild_BaseSW:4.9
	ITable-0_09:4.4
	Ursula_merge:4.2.2.1
	ITable-0_08:4.3
	nturton_ITable-0_06:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	StrongARM:4.1.3;
locks; strict;
comment	@# @;


4.14
date	2013.10.06.20.12.57;	author jlee;	state Exp;
branches;
next	4.13;
commitid	JxdGRVFBcUkBVg8x;

4.13
date	2013.10.06.18.08.32;	author jlee;	state Exp;
branches;
next	4.12;
commitid	oZFkvjb2TyyTeg8x;

4.12
date	2013.09.03.19.19.26;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	1oUL9eS7RLgZG14x;

4.11
date	2012.09.16.10.47.29;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	L3uMGInjWeXRaKkw;

4.10
date	2012.09.16.10.45.09;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	Xo2kmLMXFBGX9Kkw;

4.9
date	2001.03.23.17.05.47;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	2000.08.14.13.53.05;	author jfletche;	state Exp;
branches;
next	4.7;

4.7
date	2000.07.07.17.23.13;	author jfletche;	state Exp;
branches;
next	4.6;

4.6
date	2000.06.28.08.55.03;	author arodger;	state Exp;
branches;
next	4.5;

4.5
date	2000.05.12.12.37.07;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.08.27.11.38.16;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.08.05.11.50.48;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.11.26.25;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.06.02.13.37;	author nturton;	state Exp;
branches
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	98.04.14.15.43.41;	author mstphens;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.13.37;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.56.01;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.13.28;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Fix build error
Detail:
  s/ITable - InverseTable_SpriteTable fixed to use new internationalised error handling
Admin:
  Tested on BB-xM


Version 0.18. Retagged as 'ITable-0_18'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > s.ITable

; *********************
; ***  CHANGE LIST  ***
; *********************
;
; 08-Dec-95 0.00 DDV Created
; 11-Dec-95      DDV Added Hourglass display to show that we haven't got stuck.
; 12-Dec-95      DDV Bug fix: R and B in the table calculator needed swapped to map to VIDC format.
; 12-Dec-95      DDV Palette write operations cause inverse table to be invalidated.
; 12-Dec-95      DDV Now use ColourTrans to read palette (should cope with output to sprite).
; 12-Dec-95      DDV Added check to only recompute inverse-table when palette changes.
; 12-Dec-95      DDV Support for switching output to a sprite invalidating the tables.
; 13-Dec-95      DDV Fixed SWI chunk to one from Alan Glover (+ some reformatting).
; 13-Dec-95      DDV Errors reported out of calculate correctly.
; 13-Dec-95 0.01 DDV Uses a temporary dynamic area for storing inverse table distances buffer - when computing.
; 13-Dec-95 0.02 DDV Conditonally removed use of a dynamic area - causes Font Manager/Wimp to barf!
; 13-Dec-95      DDV Reduced workspace usage, tidied some variables
; 13-Dec-95      DDV Now uses dynamic areas properly for storing inverse and distance tables.
; 13-Dec-95 0.03 DDV Dynamic area sized to contain distance table and reduced after use.
; 01-Jul-96 0.04 SJM With standard palette it checks for one in resourcefs before creating.
; 05-Aug-99 0.08 KJB Ursula branch merged. Changed to use srccommit.
; 12-May-00 0.09 KJB 32-bit compatible.

        IMPORT  usermode_donothing

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:Proc
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:HighFSI
        GET     Hdr:NewErrors
        GET     Hdr:Variables
        GET     Hdr:VduExt
        GET     Hdr:ResourceFS
        GET     Hdr:MsgTrans
        GET     Hdr:Sprite
        GET     Hdr:ColourTran
        GET     Hdr:Hourglass
        GET     Hdr:NDRDebug
        GET     Hdr:PublicWS
        GET     Hdr:HostFS
        GET     Hdr:PaletteV

        GET     hdr.ITable                      ; our SWI information
        GET     VersionASM                      ; and version data


; ------------------------------------------------------------------------------
; Constants, macros and structures
; ------------------------------------------------------------------------------

                GBLL    debug
                GBLL    hostvdu
debug           SETL    {FALSE}
hostvdu         SETL    {FALSE}
      [ :LNOT::DEF:standalone
                GBLL    standalone
standalone      SETL    {FALSE}
      ]

                                 GBLL    UseResourceTable
UseResourceTable                 SETL    {TRUE}
                                 GBLL    UseColourTransResourceTable
UseColourTransResourceTable      SETL    {TRUE}
                                 GBLL    CallColourTransForTable
CallColourTransForTable          SETL    {TRUE}
                                 GBLL    DontAssumeRedirectionIsToggling
DontAssumeRedirectionIsToggling  SETL    {TRUE}

; Constants used for computing table

bits            * 5                             ; significant bits per gun used for table index

nbits           * 8 - bits                      ; DO NOT modify computed from bits
x               * 1 << nbits                    ; DO NOT modify computed from bits
xsqr            * 1 << ( 2 * nbits )            ; DO NOT modify computed from bits
colourmax       * 1 << bits                     ; DO NOT modify computed from bits


; Workspace allocation

                ^ 0, WP
iFlags          # 4                             ; = flags ( f_xxx )

f_PaletteV       * &00000001                    ; = 1 => palette vector has been claimed
f_TableValid     * &00000002                    ; = 1 => inverse table is valid for current destination
f_SwitchInvalid  * &00000004                    ; = 1 => Switched to a sprite, therefore if calculating the table is invalid
 [ UseResourceTable
f_StandardPal    * &00000008                    ; = 1 => The current palette is the standard one
 |
f_StandardPal    * &00000000
 ]
 [ DontAssumeRedirectionIsToggling
f_CurrentlyScreen * &00000010                   ; = 1 => currently redirected to the screen
f_TableScreen     * &00000020                   ; = 1 => the table we have is for the screen
 ]
iDynamicArea    # 4                             ; = ID of our dynamic area

pInverseTable   # 4                             ; -> current inverse table
pDistanceTable  # 4                             ; -> distance table

 [ UseResourceTable
pResourceTable  # 4
 ]

iPalette555     # 4 * 256                       ; = palette quanitised down to 5,5,5 RGB

ws_required     * :INDEX: @@


; Dynamic area allocation

                ^ 0
da_iInverseTable        # colourmax * colourmax * colourmax
da_MinimumSize          * :INDEX: @@

da_iDistanceTable       # ( ?da_iInverseTable ) * 4
da_MaximumSize          * :INDEX: @@


; ------------------------------------------------------------------------------
; Module header and basic initialisation of the module.
; ------------------------------------------------------------------------------

        AREA    |ITable$$Code|, CODE, READONLY, PIC

module_base
        DCD     0                               ; No application entry
        DCD     Init - module_base
        DCD     Die - module_base
        DCD     Service - module_base

        DCD     Title - module_base
        DCD     Help - module_base
        DCD     0                               ; no commands

        DCD     InverseTableSWI_Base
        DCD     SWIDespatch - module_base
        DCD     SWINames - module_base
        DCD     0                               ; SWI name decode
        DCD     0                               ; messages
      [ :LNOT: No32bitCode
        DCD     ModuleFlags - module_base
      ]

Help    DCB     "Inverse Table", 9, "$Module_HelpVersion"
      [ debug
        DCB     " Development version"
      ]
        DCB     0
        ALIGN

      [ :LNOT: No32bitCode
ModuleFlags
        DCD     ModuleFlag_32bit
      ]

Title
SWINames
        DCB     "InverseTable", 0               ; prefix
        DCB     "Calculate", 0
        DCB     "SpriteTable", 0
        DCB     0
        ALIGN

;; ------------------------------------------------------------------------------
;; Initialise, claim our workspace and set to a sensible state!
;; ------------------------------------------------------------------------------

Init    Entry   "R1-R3"

        LDR     R2, [WP]                        ; pick up the private word
        TEQ     R2, #0                          ;   do we already have our workspace?
        BNE     %FT10

        MOV     R0, #ModHandReason_Claim
        LDR     R3, =ws_required
        SWI     XOS_Module                      ; attempt to claim our workspace block
        EXIT    VS                              ;   if that fails then return

        STR     R2, [WP]                        ; set the private word to point at our workspace
10
        MOV     WP, R2

      [ standalone
        ADRL    R0, msg_area
        SWI     XResourceFS_RegisterFiles
        EXIT    VS
      ]

 [ DontAssumeRedirectionIsToggling
        MOV     R0, # f_CurrentlyScreen         ; initially we're directed at the screen
        STR     R0, iFlags
        MOV     R0, #0                          ; NULL suitable entries
 |
        MOV     R0, #0                          ; NULL suitable entries
        STR     R0, iFlags
 ]
        STR     R0, iDynamicArea
        STR     R0, pInverseTable

        MOV     R0, # -1                        ; = -1 => invalid 5,5,5 entry
        ADR     R1, iPalette555
        LDR     R2, = ?iPalette555
20
        SUBS    R2, R2, # 4
        STRGE   R0, [ R1 ], # 4
        BGE     %BT20

        Debug_Open      pipe:itable

        BL      claim_vectors                   ; try to claim the vectors
        EXIT                                    ;   and return any possible errors


;; ------------------------------------------------------------------------------
;; Tidy up as about to die!
;; ------------------------------------------------------------------------------

Die     Entry   "R1-R2"

        LDR     WP, [WP]                        ; do we have a workspace pointer currently?
        CMP     WP, # 0                         ;   if not then there is nothing to tidy up
        EXIT    EQ

        LDR     R3, iFlags
        TST     R3, # f_PaletteV                ; do we currently have the palette vector claimed?
        MOVNE   R0, # PaletteV
        ADRNE   R1, palVhandler
        MOVNE   R2, WP
        SWINE   XOS_Release

        BL      release_area                    ; if we have a dynamic area then discard it

      [ standalone
        ADRL    R0, msg_area
        SWI     XResourceFS_DeregisterFiles
      ]
        Debug_Close

        EXIT


;; ------------------------------------------------------------------------------
;; Service calls broadcast, if an interesting one then act on it - but never claim.
;; ------------------------------------------------------------------------------

        ; Ursula format
        ; 
        ASSERT  Service_Reset                   < Service_ModeChange
        ASSERT  Service_ModeChange              < Service_ResourceFSStarted
        ASSERT  Service_ResourceFSStarted       < Service_ResourceFSDying
        ASSERT  Service_ResourceFSDying         < Service_ResourceFSStarting
        ASSERT  Service_ResourceFSStarting      < Service_SwitchingOutputToSprite
        ASSERT  Service_SwitchingOutputToSprite < Service_PostInit
UServTab
        DCD     0
        DCD     UService - module_base
        DCD     Service_Reset
        DCD     Service_ModeChange
  [ UseResourceTable
        DCD     Service_ResourceFSStarted
        DCD     Service_ResourceFSDying
  ]
  [ standalone
        DCD     Service_ResourceFSStarting
  ]
        DCD     Service_SwitchingOutputToSprite
  [ UseResourceTable
        DCD     Service_PostInit
  ]
        DCD     0
        DCD     UServTab - module_base
Service ROUT
        MOV     r0, r0
        TEQ     R1, # Service_Reset             ; filter out only the ones we want
        TEQNE   R1, # Service_ModeChange
        TEQNE   R1, # Service_SwitchingOutputToSprite
 [ UseResourceTable
        TEQNE   R1, # Service_ResourceFSStarted
        TEQNE   R1, # Service_ResourceFSDying
        TEQNE   R1, # Service_PostInit
 ]
 [ standalone
        TEQNE   R1, # Service_ResourceFSStarting
 ]
        MOVNE   PC, LR
UService

        Entry   "R0-R1"

        LDR     WP, [ WP ]                      ; get workspace pointer
        LDR     R0, iFlags                      ;   and current flags word

        TEQ     R1, # Service_Reset
        BNE     %FT10

        ; It was a reset - therefore reset flags / mark as no dynamic area etc

        BIC     R0, R0, # f_TableValid :OR: f_PaletteV :OR: f_StandardPal
        STR     R0, iFlags

        MOV     R0, # 0                         ; remove the dynamic area
        STR     R0, iDynamicArea
        STR     R0, pInverseTable
        STR     R0, pDistanceTable

        BL      claim_vectors                   ; must claim the vectors again

        EXIT

10                                              ; if resourcefs changed get the new ptr
 [ UseResourceTable
        TEQ     R1, # Service_ResourceFSStarted
        TEQNE   R1, # Service_ResourceFSDying
        TEQNE   R1, # Service_PostInit
        BNE     %ft20

        BL      check_resource

        LDR     R1, pResourceTable              ; if table has vanished then clear the StandardPal bit
        CMP     R1, #0                          ; and set the table to invalid
        BICEQ   R0, R0, # f_TableValid
        STREQ   R0, iFlags

        EXIT

20
 ]
 [ standalone
        TEQ     R1, # Service_ResourceFSStarting
        BNE     %FT30

        ADRL    R0, msg_area                    ; reinstall the resource block
        MOV     LR, PC
        MOV     PC, R2
        EXIT
30
 ]
        TEQ     R1, # Service_ModeChange
        BICEQ   R0, R0, # f_TableValid          ; mode change, therefore table bad
        TEQ     R1, # Service_SwitchingOutputToSprite
 [ DontAssumeRedirectionIsToggling
        BNE     %FT40
        ; we're changing redirection
        ORR     R0, R0, # f_SwitchInvalid       ; output gone to sprite - maybe invalid

        TEQ     R3,#0                           ; sprite area
        TEQEQ   R4,#0                           ; sprite name/pointer (both 0 if going to screen)
        BICNE   R0, R0, # f_CurrentlyScreen
        ORREQ   R0, R0, # f_CurrentlyScreen

        TST     R0, # f_TableValid              ; if the table is already invalid
        TSTNE   R0, # f_CurrentlyScreen         ; ... or if we're not going to the screen now
        BEQ     %FT40                           ; ... we don't care
        TST     R0, # f_TableScreen             ; is the table for the screen ?
        BICNE   R0, R0, # f_SwitchInvalid       ; if so, then the table /is/ valid again
40
 |
        EOREQ   R0, R0, # f_SwitchInvalid       ; output gone to sprite - maybe invalid
 ]
        STR     R0, iFlags

        EXIT


;; ------------------------------------------------------------------------------
;; Perform SWI dispatch, first ensuring :
;;
;;  - SWI is within our supported range
;;  - IRQs are enabled as we take some time
;; ------------------------------------------------------------------------------

SWIDespatch ROUT

        LDR     WP, [WP]                        ; de-reference the workspace pointer
        WritePSRc SVC_mode, R10                 ;   ensure that IRQ's get re-enabled

        Push    "LR"
        BL      SWIDespatchInternal
        Pull    "LR"

      [ No32bitCode
        ORRVSS  PC, LR, #V_bit                  ; mark that an error occurred
        MOVS    PC, LR
      |
        TEQ     PC, PC                          ; preserves V
        MOVEQ   PC, LR                          ; 32 bit exit
        ORRVSS  PC, LR, #V_bit                  ; 26 bit error exit
        MOVS    PC, LR
      ]

        MakeInternatErrorBlock ModuleBadSWI,,BadSWI

msg_filename
        DCB     "Resources:$.Resources.ITable.Messages", 0
        ALIGN

SWIDespatchInternal

        CMP     R11, #( %90-%00 ) / 4           ; is the index valid for our swi table
        ADDCC   PC, PC, R11, LSL # 2            ;   if it is then despatch
        B       %FT90
00
        B       ITable_Calculate
        B       ITable_SpriteTable
90
        ADR     R0, ErrorBlock_ModuleBadSWI
make_error
        Push    "R1-R7,LR"
        SUB     SP, SP, #16                     ; temporary MessageTrans structure

        MOV     R7, R0                          ; Push R0
        MOV     R0, SP
        ADR     R1, msg_filename
        MOV     R2, #0
        SWI     XMessageTrans_OpenFile
        BVS     %FT95                           ; someone ate my messages file
        MOV     R0, R7                          ; Pull R0

        MOV     R1, SP
        MOV     R2, #0                          ; use MessageTrans internal buffer
        ADRL    R4, Title
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup

        MOV     R7, R0                          ; Push R0
        MOV     R0, SP
        SWI     XMessageTrans_CloseFile
        MOV     R0, R7                          ; Pull R0
95
        ADD     SP, SP, #16                     ; finished with the structure
        SETV
        Pull    "R1-R7,PC"

;; ------------------------------------------------------------------------------
;; Claim vectors used by the modules
;; ------------------------------------------------------------------------------

claim_vectors Entry "R1-R3"

        CLRV
        LDR     R3, iFlags
        TST     R3, # f_PaletteV                ; is paletteV claimed currently
        EXIT    EQ

        MOV     R0, #PaletteV
        ADR     R1, palVhandler
        MOV     R2, WP
        SWI     XOS_Claim                       ; attempt to claim the palette vector
        ORRVC   R3, R3, # f_PaletteV            ;  if that worked then mark as claimed

        STR     R3, iFlags

        EXIT

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

palVhandler ROUT

        TEQ     R4, # paletteV_Set
        TEQNE   R4, # paletteV_SetDefaultPalette
        TEQNE   R4, # paletteV_BulkWrite
        MOVNE   PC, LR                          ; not a modifying palette operation

        Entry   "WP"

        TEQ     R4, # paletteV_Set              ; are we writing an entry?
        BNE     %FT01

        CMP     R1, # 24                        ; is it the border or cursor colour?
        EXIT    GE
01
        LDR     LR, iFlags
        BIC     LR, LR, # f_TableValid          ; table is no longer valid
        STR     LR, iFlags

        EXIT

;;-----------------------------------------------------------------------------
;;
;; Check on the resource file presence

 [ UseResourceTable
table_filename
  [ UseColourTransResourceTable
        DCB     "Resources:$.Resources.Colours.Tables.8desktop", 0
  |
        DCB     "Resources:$.Resources.ITable.Tables.8desktop", 0
  ]
        ALIGN

check_resource
        Entry   "r0-r11"

        Debug1  ,"check_resource"

        MOV     R0, #0                          ; zero the pointer first
        STR     R0, pResourceTable

        MOV     R0, #open_read :OR: open_nopath :OR: open_nodir
        ADR     R1, table_filename
        SWI     XOS_Find
        EXIT    VS

        MOVS    R11, R0                         ; save the file handle in R11
        EXIT    EQ                              ; exit if zero (can't open file)

        MOV     R1, R0                          ; get the fs number
        MOV     R0, #OSArgs_ReadInfo
        SWI     XOS_Args
        BVS     %ft99

        AND     R0, R2, #&FF                    ; is it ResourceFS?
        CMP     R0, #fsnumber_resourcefs
        BNE     %ft99

        MOV     R0, #FSControl_ReadFSHandle     ; get the internal handle
        SWI     XOS_FSControl
        BVS     %ft99

        STR     R1, pResourceTable              ; save the direct pointer to the file

        Debug   ,"pResourceTable",R1

99      MOV     R0, #0                          ; close the file
        MOV     R1, R11
        SWI     XOS_Find

        EXIT
 ]

;;-----------------------------------------------------------------------------
;; InverseTable_Calculate implementation
;;
;; Return the pointers to the inverse colour table.  If the table is marked
;; as invalid then we must recompute it, also if output has been switched
;; to a sprite we must also recompute it.
;;
;; The table validity is marked by a flag in our flags word (f_TableValid),
;; when this == 1 then the table has been correctly cached, and therefore
;; does not need recomputing.
;;
;; Another bit is used to indicate if output is being swithced to a sprite,
;; this bit is toggled each time output is toggled.  Therefore if this SWI
;; is called and 'f_SwitchInvalid' == 1 then output it redirected to the
;; sprite and we must recompute the inverse table.
;;
;; The two tables returned allow the quick mapping for colour index to
;; 5,5,5 RGB, and 5,5,5 RGB to colour index (the later is often refered
;; to as an inverse table).
;;
;; 5,5,5 RGB contains the data where each gun is represented as 5 bits:
;;
;;      < b14-10 == B >
;;                     < b9-5 == G >
;;                                  < b4-0 == R >
;;
;; So using a colour number as an index into the table at R0 will yield
;; a 32 bit word containing the above data.
;;
;; To convert that word back to a colour number then the 5,5,5 RGB
;; can be used as an index into the byte array of colour numbers.
;;
;; This SWI should only be called if the mode is == 8 bit per pixel,
;; all other depths will result in a 'Bad MODE error'.
;;
;; NB: If the SWI does error then R1 will be corrupt.
;;
;; in   -
;; out  R0 -> index to 5,5,5 RGB data
;;      R1 -> 5,5,5 RGB data to index table
;;-----------------------------------------------------------------------------

ITable_Calculate Entry "R2"

        MOV     R0, #-1
        MOV     R1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable            ; read the log2 bits per pixel for this mode
        TEQ     R2, #3                          ;   if this is not 8 bit then exit
        ADRNE   R0, ErrorBlock_BadMODE
        BLNE    make_error
        BVS     %FT90

        LDR     R2, iFlags                      ; check to see if table is valid
        TST     R2, # f_SwitchInvalid
        BICNE   R2, R2, # f_TableValid :OR: f_SwitchInvalid
        TST     R2, # f_TableValid
        BLEQ    build_itable                    ; if not valid then build the inverse table

 [ UseResourceTable
        EXIT    VS

        LDR     R2, iFlags                      ; reload flags as they may have changed
        ADR     R0, iPalette555                 ; -> RGB 5,5,5 table ( index => 5,5,5 )
        TST     R2, # f_StandardPal
        LDRNE   R1, pResourceTable              ; if bit is not set
        CMPNE   R1, #0                          ; or resource table is not present
        LDREQ   R1, pInverseTable               ; use the built table

        Debug   ,"ITable_Calculate",R0,R1,R2
 |
        ADRVC   R0, iPalette555                 ; -> RGB 5,5,5 table ( index => 5,5,5 )
        LDRVC   R1, pInverseTable               ; -> inverse table (5,5,5 => colour number)
 ]
90
        EXIT

        MakeInternatErrorBlock BadMODE,,BadMODE

;;-----------------------------------------------------------------------------
;; InverseTable_SpriteTable implementation
;;
;; As per InverseTable_Calculate, except we perform the conversion for a
;; user-supplied palette, into a user-supplied destination buffer.
;;
;; As an optimisation we're allowed to replace the user's buffer pointers
;; with pointers of our own if we've got the data cached already. At the
;; moment we only bother to do this if they're requesting a table for the
;; current mode.
;;
;; This SWI should only be called if the mode is == 8 bit per pixel,
;; all other depths will result in a 'Bad MODE error'.
;;
;; in   R0 -> buffer to fill with index to 5,5,5 table
;;      R1 -> buffer to fill with 5,5,5 to index table
;;      R2 = sprite area/mode (same as R0 of ColourTrans_ReadPalette)
;;      R3 = sprite pointer/palette (same as R1 of ColourTrans_ReadPalette)
;;           note: No way of specifying a sprite name
;; out  R0 -> index to 5,5,5 RGB data
;;      R1 -> 5,5,5 RGB data to index table
;;-----------------------------------------------------------------------------

ITable_SpriteTable
        CMP     R2, #-1
        CMPEQ   R3, #-1
        BEQ     ITable_Calculate                ; branch through to InverseTable_Calculate if they're interested in the current mode

        Entry   "R0-R11"

        MOV     R0, R2
        MOV     R4, #0
        
        ; Have we been given a sprite or a mode?
        CMP     R2, #256
        BLO     %FT10
        TST     R2, #1
        BNE     %FT10

        ; Should be a sprite area
        LDR     R0, [R3, #spMode]
        MOV     R4, #1
10
        MOV     R1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable            ; read the log2 bits per pixel for this mode
        TEQ     R2, #3                          ;   if this is not 8 bit then exit
        ADRNE   R0, ErrorBlock_BadMODE
        BLNE    make_error
        STRVS   R0, [sp]
        BVS     %FT90

        ; Fetch the palette
        LDR     R0, [sp, #8] ; Recover R2
        MOV     R1, R3
        LDR     R2, [sp] ; Recover R0
        MOV     R3, #1024
        ; R4 already initialised above
        SWI     XColourTrans_ReadPalette
        STRVS   R0, [sp]
        BVS     %FT90

        SWI     XHourglass_On                   ; this could take some time

        ; If we're using ColourTrans, fetch the table now using the palette
        ; we just fetched
   [ CallColourTransForTable
        LDR     r0, =1 :OR: (5<<27) :OR: (90<<1) :OR: (90<<14) ; source mode,
                                                               ; resolution not relevant but should be valid
        MOV     r1, #-1                                        ; the current palette
        SUB     r3, r2, #1024                                  ; destination palette
        LDR     r2, =1 :OR: (4<<27) :OR: (90<<1) :OR: (90<<14) ; destination mode (8bpp, will be treated as full palette)
        LDR     r4, [sp, #4]                                   ; decent sized buffer for the output
                                                               ; note: the output should be 3 words
        MOV     r5, #0                                         ; flags
        SWI     XColourTrans_GenerateTable
        STRVS   r0, [sp]
        BVS     %FT85                                          ; error is just fatal
        ; check it's something we understand
        LDR     r0, word_32k
        LDMIA   r4, {r1,r2,r3}
        TEQ     r0, r1
        TEQEQ   r0, r3
        BNE     %FT30                                          ; no idea what that is, do it ourselves
        
        ; now copy it to the user's buffer
        MOV     r0, # (colourmax * colourmax * colourmax)
        MOV     r1, r4
        ; r0 = entries
        ; r1->destination
        ; r2->source
16
        LDMIA   r2!, {r3,r4,r5,r6,r7,r8,r9,r10} ; 8 registers = 4*8 bytes
        STMIA   r1!, {r3,r4,r5,r6,r7,r8,r9,r10}
        LDMIA   r2!, {r3,r4,r5,r6,r7,r8,r9,r10} ; 16 registers = 4*16 bytes
        STMIA   r1!, {r3,r4,r5,r6,r7,r8,r9,r10}
        LDMIA   r2!, {r3,r4,r5,r6,r7,r8,r9,r10} ; 24 registers = 4*24 bytes
        STMIA   r1!, {r3,r4,r5,r6,r7,r8,r9,r10}
        LDMIA   r2!, {r3,r4,r5,r6,r7,r8,r9,r10} ; 32 registers = 4*32 bytes
        STMIA   r1!, {r3,r4,r5,r6,r7,r8,r9,r10}
        SUBS    r0, r0, #32*4
        BNE     %BT16

        B       %FT40
   ]

30

        ; Generate the table
        BL      claim_area                      ; The dynamic area is needed for temp storage of the distance table
        LDMVCIA SP, {R0-R1}
        BLVC    build_itable_core
        STRVS   R0, [SP]
        BVS     %FT85

40
        ; Convert the palette we fetched earlier to 555
        LDR     R0, [sp]
        ADD     R2, R0, #1024
50
        LDR     R1, [R2, #-4]!
        AND     R3, R1, #&0000F800
        AND     R4, R1, #&00F80000
        MOV     R3, R3, LSR #8+3
        AND     R5, R1, #&F8000000
        ORR     R1, R3, R4, LSR #16+3-5
        ORR     R1, R1, R5, LSR #24+3-10
        CMP     R0, R2
        STR     R1, [R2]
        BNE     %BT50
85
        SavePSR LR
        Push    "R0,LR"
        SWI     XHourglass_Off                  ; remove hourglass
        Pull    "R0,LR"                         ;   preserving error condition around call
        RestPSR LR,,cf
90
        EXIT


;; ------------------------------------------------------------------------------
;; Dynamic area management code.
;;
;; We keep the inverse table in a dynamic area, we create this dynamic area with
;; enough room to grow and contain the distance table as-well, although this is
;; only claimed when the distance table is needed - therefore we can keep
;; our memory footprint nice and small.
;; ------------------------------------------------------------------------------

claim_area Entry "R1-R8"

        LDR     R0, iDynamicArea
        CMP     R0, # 0                         ; have we already allocated our dynamic area?
        EXIT    NE

        MOV     R0, # 0                         ; = 0 => create dynamic area
        MOV     R1, # -1
        LDR     R2, = da_MinimumSize            ; minimum size (size of inverse table)
        MOV     R3, # -1
        MOV     R4, # ( 1:SHL:7)
        LDR     R5, = da_MaximumSize            ; maximum size (inverse table + distance table)
        MOV     R6, # 0
        MOV     R7, # 0
        ADRL    R8, Title                       ; -> name for dynamic area (Task Manager)
        SWI     XOS_DynamicArea
        STRVC   R1, iDynamicArea
        STRVC   R3, pInverseTable

        EXIT

release_area Entry "R0-R1"

        LDR     R1, iDynamicArea
        CMP     R1, # 0                         ; has a dynamic area been created
        EXIT    EQ

        MOV     R0, # 1                         ; = 1 => discard dynamic area
        SWI     XOS_DynamicArea
        CLRV
        EXIT


;; ------------------------------------------------------------------------------
;; Compute both the inverse colour table, and quantise the 24 bit palette
;; down to its 5,5,5 representation.
;;
;; This code implementes the Incremental Distance algorithm for inverse table generation
;; as outlined in Graphics Gems pp116-119 (see that for the exact details).  Basically,
;; we have an array which contains the position within the colour cube of every
;; entry we are going to visit (based on the 5,5,5 indexes).
;;
;; This table is initialised to -1, ie. all entries must match.  We then
;; have three loops (b,g,r in that order).  And we scan along each axis of the
;; cube seeing if the distance for the colour at this point is greater
;; than the previously stored distance for this point.  If it is then we
;; replace it.
;;
;; Before we can start computing the table we read the current palette, via
;; ColourTrans - this will cope with output directed to a sprite and return
;; the one for that, or the screen palette expanded to full 24 bit.
;;
;; We then quanitise the palette down, by taking the top 5 bits of each
;; gun and composing the 5,5,5 palette data.  Whilst doing this we compare
;; it to the previous entries we have for the 5,5,5 table, if there is
;; no change then we do not need to compute the inverse table (which is
;; a lengthy process and should be avoided).
;;
;; Assuming we have taken the above steps and have determined that the
;; palette has changed then we compute the inverse table.  We make use of
;; the Hourglass to indicate how far through this process we are - therefore
;; the user gets some impression of how long before their compute comes
;; back to life - the process takes about 7 seconds, on a RPC 600.
;;
;; NB: This code uses scratch space.
;;
;; ------------------------------------------------------------------------------

        ; Temporary workspace usage

                ^ ScratchSpace
scratch_palette # 256 * 4


        ; Register allocations

pITable         RN 0    ;                       ---- always ---
pDistances      RN 1    ;                       ---- always ---

rDist           RN 2    ; (outerloop)
gDist           RN 3    ; (outerloop)
bDist           RN 4    ; (outerloop)

rInc            RN 5    ; (outerloop)
gInc            RN 6    ; (outerloop)
bInc            RN 7    ; (outerloop)

r               RN 8    ;              (r inner loop)
g               RN 9    ;                             (g inner loop)
b               RN 10   ;                                            (b inner loop)

scratch         RN 10   ; (outer loop)
iColours        RN 11   ; (outer loop)                  (doubles as return value register)


        ; Table used to set hourglass percentage values

percent_table
        DCB      0,  3, 6,   9, 12, 15, 19, 22
        DCB     25, 28, 31, 35, 38, 41, 44, 47
        DCB     51, 54, 57, 60, 63, 67, 70, 73
        DCB     76, 79, 83, 86, 89, 92, 95, 99
        ALIGN

        ; Do it....

build_itable Entry "R1-R11"

        SWI     XHourglass_On                   ; this could take some time

        ; Get palette for current screen mode / destination

        MOV     R0, # -1                        ; read palette for current destination
        MOV     R1, # -1
        LDR     R2, = scratch_palette           ; into this buffer
        LDR     R3, = ?scratch_palette          ;   which is so big
        MOV     R4, # 0
        SWI     XColourTrans_ReadPalette
        BVS     %FT90

        ; Convert palette from 24 bit RGB to 5,5,5 RGB

        LDR     R0, = scratch_palette
        ADRL    R1, iPalette555
        LDR     R2, = ?scratch_palette
        MOV     R5, # 1                         ; table has not been modified yet

 [ UseResourceTable
        ADRL    R6, StandardPalette             ; standard 8 bit palette
        MOV     R7, # 1                         ; 1 = palette matches standard
 ]
10
        LDR     R3, [ R0 ], #4                  ; pick up 24 bit palette entry
        AND     R4, R3, #&f8000000              ;   and convert to 5,5,5 RGB
        AND     LR, R3, #&00f80000
        ORR     R4, R4, LR, LSL # 3
        AND     R3, R3, #&0000f800
        ORR     R3, R4, R3, LSL # 6
        MOV     R3, R3, LSR # 17

        LDR     LR, [ R1 ]
        TEQ     LR, R3                          ; has the colour changed?
        MOVNE   R5, # 0                         ;   yes, so must re-compute the inverse table
        STR     R3, [ R1 ], #4

 [ UseResourceTable
      [ NoARMv4
        LDRB    R4, [ R6, # 1 ]
        LDRB    LR, [ R6 ], #2
        ORR     LR, LR, R4, LSL # 8
      |
        LDRH    LR, [ R6 ], #2
      ]
        TEQ     LR, R3                          ; is the colour different from the standard
        MOVNE   R7, # 0                         ;   yes, then we can't use the standard table
 ]
        SUBS    R2, R2, # 4
        BGT     %BT10                           ; loop until *ENTIRE* palette converted

        Debug   ,"build_itable changed",R5

        CMP     R5, #0                          ; has the palette actually changed?
 [ UseResourceTable
        LDRNE   LR, pInverseTable               ;   if not then is there a table present
        CMPNE   LR, #0
 ]
        BNE     %FT85                           ;   if so then don't bother re-calculating the colour table

 [ UseResourceTable
        Debug   ,"build_itable standard",R7

        LDR     LR, iFlags

        CMP     R7, # 0                         ; is it actually the standard palette?
        BICEQ   LR, LR, #f_StandardPal          ;   no - clear flag, store and carry on
        STREQ   LR, iFlags
        BEQ     %FT20

        ORR     LR, LR, #f_StandardPal          ;   yes - set flag
        LDR     R7, pResourceTable              ;   check if we have the resource table
        CMP     R7, # 0
        ORRNE   LR, LR, # f_TableValid          ;     yes - then table is now valid
 [ DontAssumeRedirectionIsToggling
        STREQ   LR, iFlags
        BEQ     %FT90

        ; remember what this table was for - the screen or a sprite
        TST     LR, # f_CurrentlyScreen
        BICEQ   LR, LR, # f_TableScreen
        ORRNE   LR, LR, # f_TableScreen
        STR     LR, iFlags
        B       %FT90
 |
        STR     LR, iFlags
        BNE     %FT90                           ;     and exit, else carry on
 ]

20
 ]

        ; Ensure that we have the dynamic area

        BL      claim_area                      ; attempt to claim the dynamic area ready to build the table
        BVS     %FT90

   [ CallColourTransForTable
        LDR     r0, =1 :OR: (5<<27) :OR: (90<<1) :OR: (90<<14) ; source mode,
                                                               ; resolution not relevant but should be valid
        MOV     r1, #-1                                        ; the current palette
        MOV     r2, #-1                                        ; destination mode
        MOV     r3, #-1                                        ; default palette for that mode
        LDR     r4, pInverseTable                              ; decent sized buffer for the output
                                                               ; note: the output should be 3 words
        MOV     r5, #0                                         ; flags (nothing special)
        SWI     XColourTrans_GenerateTable
        BVS     %FT90                                          ; error is just fatal
        ; check it's something we understand
        LDR     r0, word_32k
        LDMIA   r4, {r1,r2,r3}
        TEQ     r0, r1
        TEQEQ   r0, r3
        BNE     %FT17                                          ; no idea what that is, do it ourselves

        ; in theory at this point we can just remember r2, but the current algorithms used mean
        ; that itable could end up remembering a buffer after it had been discarded by CT
        ; so we'll just copy the buffer.
        
        ; now copy it to our buffer
        MOV     r0, # (colourmax * colourmax * colourmax)
        MOV     r1, r4
        ; r0 = entries
        ; r1->destination
        ; r2->source
16
        LDMIA   r2!, {r3,r4,r5,r6,r7,r8,r9,r10} ; 8 registers = 4*8 bytes
        STMIA   r1!, {r3,r4,r5,r6,r7,r8,r9,r10}
        LDMIA   r2!, {r3,r4,r5,r6,r7,r8,r9,r10} ; 16 registers = 4*16 bytes
        STMIA   r1!, {r3,r4,r5,r6,r7,r8,r9,r10}
        LDMIA   r2!, {r3,r4,r5,r6,r7,r8,r9,r10} ; 24 registers = 4*24 bytes
        STMIA   r1!, {r3,r4,r5,r6,r7,r8,r9,r10}
        LDMIA   r2!, {r3,r4,r5,r6,r7,r8,r9,r10} ; 32 registers = 4*32 bytes
        STMIA   r1!, {r3,r4,r5,r6,r7,r8,r9,r10}
        SUBS    r0, r0, #32*4
        BNE     %BT16

        ; done, jump to tail of routine
        B       %FT85

        ; ColourTrans magic word
word_32k
        DCB     "32K."
   ]

        ; here we start to generate the table ourselves
17
        LDR     R0, =scratch_palette
        LDR     R1, pInverseTable
        BL      build_itable_core
85
        LDR     LR, iFlags
        ORR     LR, LR, # f_TableValid          ; table is now valid
  [ DontAssumeRedirectionIsToggling
        ; remember what this table was for - the screen or a sprite
        TST     LR, # f_CurrentlyScreen
        BICEQ   LR, LR, # f_TableScreen
        ORRNE   LR, LR, # f_TableScreen
  ]
        STR     LR, iFlags
90
        SavePSR LR
        Push    "R0,LR"
        SWI     XHourglass_Off                  ; remove hourglass
        Pull    "R0,LR"                         ;   preserving error condition around call
        RestPSR LR,,cf

        EXIT

; Actually build a table
;
; On entry:
; R0 = dest palette (as &BBGGRR00)
; R1 = dest buffer
; DA must exist
; Hourglass on
; On exit:
; All regs corrupt

build_itable_core ROUT
        Entry   "R0-R1"
        LDR     R0, iDynamicArea
        MOV     R1, # ?da_iDistanceTable
        SWI     XOS_ChangeDynamicArea           ; expand to contain our distances table
; JRF note: I believe that this may leak some memory if the claim wasn't completely
;           satisfied; it /may/ return that only part of the claim took place - we
;           rely here on the fact that da_iDistanceTable is a multiple of the page
;           size long. fortunately, it is and we know it.
        STRVS   R0, [SP]                        ;   if that fails then return
        EXIT    VS

        LDR     R0, pInverseTable
        ASSERT  da_iDistanceTable > 0
        ADD     R0, R0, # da_iDistanceTable     ; -> distance table in dynamic area
        STR     R0, pDistanceTable

        ; Initialise the distance table to -1 (assumes R0 points at it!)

        MOV     R1, # -1                        ; initialise the distances table to -1
        LDR     R2, = ( colourmax * colourmax * colourmax )
15
        SUBS    R2, R2, # 1                     ; decrease counter
        STRPL   R1, [ R0 ], #4                  ;   write initial value for distance
        BPL     %BT15                           ;   and loop...

        MOV     iColours, # 0
20
        CMP     iColours, # ?scratch_palette / 4
        BGE     %FT80

        ; Compute steps and build inverse table

        LDR     LR, [SP]
        LDR     LR, [ LR, iColours, LSL # 2 ]   ; pick up RGB value

        AND     rDist, LR, #&FF00
        MOV     rDist, rDist, LSR # 8
        MOV     rInc, rDist, LSL # nbits        ; rInc = rDist (r) << nBits
        RSB     rInc, rInc, # xsqr
        MOV     rInc, rInc, LSL # 1             ; rInc = 2 * ( xsqr - ( r << nbits ) )
        SUB     rDist, rDist, # x / 2           ; rDist = r - ( x / 2 )

        AND     gDist, LR, #&FF0000
        MOV     gDist, gDist, LSR # 16
        MOV     gInc, gDist, LSL # nbits        ; gInc = gDist (g) << nbits
        RSB     gInc, gInc, # xsqr
        MOV     gInc, gInc, LSL # 1             ; gInc = 2 * ( xsqr - ( g << nbits ) )
        SUB     gDist, gDist, # x / 2           ; gDist = g - ( x / 2 )

        MOV     bDist, LR, LSR # 24
        MOV     bInc, bDist, LSL # nbits        ; bInc = bDist (b) << nbits
        RSB     bInc, bInc, # xsqr
        MOV     bInc, bInc, LSL # 1             ; bInc = 2 * ( xsqr - ( b << nbits ) )
        SUB     bDist, bDist, # x / 2           ; bDist = b - ( x / 2 )

        MOV     scratch, bDist
        MUL     bDist, scratch, bDist           ; bDist  = ( bDist * bDist )
        MOV     scratch, gDist
        MLA     bDist, scratch, gDist, bDist    ; bDist += ( gDist * gDist )
        MOV     scratch, rDist
        MLA     bDist, scratch, rDist, bDist    ; bDist += ( rDist * rDist )

        ADR     R0, percent_table
        LDRB    R0, [ R0, iColours, LSR # 3 ]
        SWI     XHourglass_Percentage           ; set the hourglass percentage value

        MOV     b, #0                           ; b = 0

        LDR     pITable, [SP, #4]
        LDR     pDistances, pDistanceTable      ; -> distance table

blue_loop
        ; enable other time critical tasks to continue
        Push    "r0-r3, r12"
        BL      usermode_donothing
        Pull    "r0-r3, r12"
        ; and continue
        CMP     b, # colourmax                  ; finished the red loop
        ADDGE   iColours, iColours, # 1         ;   iColours += 4
        BGE     %BT20                           ;     and advance to the next colour

        MOV     gDist, bDist                    ; gDist = bDist
        MOV     g, #0                           ; g = 0

        Push    "gInc"

green_loop
        CMP     g, # colourmax                  ; finished the green loop
        BGE     end_green_loop

        MOV     rDist, gDist                    ; rDist = gDist
        MOV     r, # 0                          ; r = 0

        Push    "rInc"

red_loop
        CMP     r, # colourmax                  ; blue loop finished?
        BGE     end_red_loop

        TEQ     iColours, #0                    ; is this colour zero?
        STREQ   rDist, [ pDistances ]
        STREQB  iColours, [ pITable ]
        BEQ     %FT30

        LDR     LR, [ pDistances ]
        CMP     LR, rDist                       ; is it closer to this colour
        STRGT   rDist, [ pDistances ]
        STRGTB  iColours, [ pITable ]
30
        ADD     rDist, rDist, rInc              ; rDist += rInc
        ADD     r, r, # 1                       ; r++
        ADD     rInc, rInc, # xsqr * 2          ; rInc += xsqr * 2

        ADD     pITable, pITable, # 1           ; pITable += 1
        ADD     pDistances, pDistances, # 4     ; pDistances += 4

        B       red_loop

end_red_loop
        Pull    "rInc"

        ADD     gDist, gDist, gInc              ; gDist += gInc
        ADD     g, g, # 1                       ; g++
        ADD     gInc, gInc, # xsqr * 2          ; gInc += xsqr * 2

        B       green_loop

end_green_loop
        Pull    "gInc"

        ADD     bDist, bDist, bInc              ; bDist += bInc
        ADD     b, b, #1                        ; b++
        ADD     bInc, bInc, # xsqr * 2          ; bInc += xsqr * 2

        B       blue_loop

        ; Handle the exit conditions - removing temporary memory etc

80
        LDR     R0, iDynamicArea
        LDR     R1, = - ( ?da_iDistanceTable )
        SWI     XOS_ChangeDynamicArea           ; remove distance table from dynamic area
        CLRV
        EXIT

 [ UseResourceTable

StandardPalette
        DCW     &0000,&0842,&1084,&18C6
        DCW     &0008,&084A,&108C,&18CE
        DCW     &2000,&2842,&3084,&38C6
        DCW     &2008,&284A,&308C,&38CE
        DCW     &0011,&0853,&1095,&18D7
        DCW     &0019,&085B,&109D,&18DF
        DCW     &2011,&2853,&3095,&38D7
        DCW     &2019,&285B,&309D,&38DF
        DCW     &0100,&0942,&1184,&19C6
        DCW     &0108,&094A,&118C,&19CE
        DCW     &2100,&2942,&3184,&39C6
        DCW     &2108,&294A,&318C,&39CE
        DCW     &0111,&0953,&1195,&19D7
        DCW     &0119,&095B,&119D,&19DF
        DCW     &2111,&2953,&3195,&39D7
        DCW     &2119,&295B,&319D,&39DF
        DCW     &0220,&0A62,&12A4,&1AE6
        DCW     &0228,&0A6A,&12AC,&1AEE
        DCW     &2220,&2A62,&32A4,&3AE6
        DCW     &2228,&2A6A,&32AC,&3AEE
        DCW     &0231,&0A73,&12B5,&1AF7
        DCW     &0239,&0A7B,&12BD,&1AFF
        DCW     &2231,&2A73,&32B5,&3AF7
        DCW     &2239,&2A7B,&32BD,&3AFF
        DCW     &0320,&0B62,&13A4,&1BE6
        DCW     &0328,&0B6A,&13AC,&1BEE
        DCW     &2320,&2B62,&33A4,&3BE6
        DCW     &2328,&2B6A,&33AC,&3BEE
        DCW     &0331,&0B73,&13B5,&1BF7
        DCW     &0339,&0B7B,&13BD,&1BFF
        DCW     &2331,&2B73,&33B5,&3BF7
        DCW     &2339,&2B7B,&33BD,&3BFF
        DCW     &4400,&4C42,&5484,&5CC6
        DCW     &4408,&4C4A,&548C,&5CCE
        DCW     &6400,&6C42,&7484,&7CC6
        DCW     &6408,&6C4A,&748C,&7CCE
        DCW     &4411,&4C53,&5495,&5CD7
        DCW     &4419,&4C5B,&549D,&5CDF
        DCW     &6411,&6C53,&7495,&7CD7
        DCW     &6419,&6C5B,&749D,&7CDF
        DCW     &4500,&4D42,&5584,&5DC6
        DCW     &4508,&4D4A,&558C,&5DCE
        DCW     &6500,&6D42,&7584,&7DC6
        DCW     &6508,&6D4A,&758C,&7DCE
        DCW     &4511,&4D53,&5595,&5DD7
        DCW     &4519,&4D5B,&559D,&5DDF
        DCW     &6511,&6D53,&7595,&7DD7
        DCW     &6519,&6D5B,&759D,&7DDF
        DCW     &4620,&4E62,&56A4,&5EE6
        DCW     &4628,&4E6A,&56AC,&5EEE
        DCW     &6620,&6E62,&76A4,&7EE6
        DCW     &6628,&6E6A,&76AC,&7EEE
        DCW     &4631,&4E73,&56B5,&5EF7
        DCW     &4639,&4E7B,&56BD,&5EFF
        DCW     &6631,&6E73,&76B5,&7EF7
        DCW     &6639,&6E7B,&76BD,&7EFF
        DCW     &4720,&4F62,&57A4,&5FE6
        DCW     &4728,&4F6A,&57AC,&5FEE
        DCW     &6720,&6F62,&77A4,&7FE6
        DCW     &6728,&6F6A,&77AC,&7FEE
        DCW     &4731,&4F73,&57B5,&5FF7
        DCW     &4739,&4F7B,&57BD,&5FFF
        DCW     &6731,&6F73,&77B5,&7FF7
        DCW     &6739,&6F7B,&77BD,&7FFF
 ]

      [ standalone
msg_area
        ResourceFile    $MergedMsgs, Resources.ITable.Messages
        DCD     0
      ]
      [ debug
        InsertNDRDebugRoutines
      ]

        END
@


4.13
log
@Add InverseTable_SpriteTable implementation
Detail:
  s/ITable - Added an implementation of ROL's InverseTable_SpriteTable SWI, to allow InverseTable to be used on arbitrary sprites.
  hdr/ITable - Fix to use SWI base and name from Hdr:SWIs instead of local definitions
Admin:
  Tested on BB-xM


Version 0.18. Tagged as 'ITable-0_18'
@
text
@d677 4
a680 3
        BLNE    err_badmode
        STRNE   R0, [sp]
        BNE     %FT90
@


4.12
log
@Internationalised
Extra code for the RAM loading version which is included in !Boot for the softloaded FontManager pre RISC OS 3.70.

Version 0.17. Tagged as 'ITable-0_17'
@
text
@d180 1
d424 1
d564 1
a564 1
;  Another bit is used to indicate if output is being swithced to a sprite,
d631 138
d987 1
a987 1
        MOV     r2, #-1                                        ; destrination mode
d1033 34
d1074 2
a1075 1
        BVS     %FT90                           ;   if that fails then return
d1098 1
a1098 1
        LDR     LR, = scratch_palette
d1134 1
a1134 1
        LDR     pITable, pInverseTable
d1208 1
a1208 18

85
        LDR     LR, iFlags
        ORR     LR, LR, # f_TableValid          ; table is now valid
  [ DontAssumeRedirectionIsToggling
        ; remember what this table was for - the screen or a sprite
        TST     LR, # f_CurrentlyScreen
        BICEQ   LR, LR, # f_TableScreen
        ORRNE   LR, LR, # f_TableScreen
  ]
        STR     LR, iFlags
90
        SavePSR LR
        Push    "R0,LR"
        SWI     XHourglass_Off                  ; remove hourglass
        Pull    "R0,LR"                         ;   preserving error condition around call
        RestPSR LR,,cf

@


4.11
log
@Halve the StdPalette table size
Since a 5:5:5 colour number always fits in 16 bits the standard palette table can be accessed with LDRH and constructed with DCW.
Tested in IOMD ROM, font blending still looks right in 256 colour modes.

Version 0.16. Tagged as 'ITable-0_16'
@
text
@a43 1
        GET     Hdr:CPU.Arch
d52 2
a53 1
        GET     Hdr:Debug
a60 1
        GET     Hdr:DDVMacros
d74 4
a87 1

d202 6
a228 4
 [ UseResourceTable :LAND: {FALSE}
        BL      check_resource                  ; deliberately don't check error return
 ]

d252 4
d270 2
a271 1
        ASSERT  Service_ResourceFSDying         < Service_SwitchingOutputToSprite
d282 3
d301 3
d324 1
a324 3
 [ UseResourceTable :LAND: {FALSE}
        STR     R0, pResourceTable
 ]
d347 10
d361 1
a361 1
        BNE     %FT30
d372 1
a372 1
        BEQ     %FT30                           ; ... we don't care
d375 1
a375 1
30
d396 22
d424 25
a448 1
        ADR     R0, ErrorBlock_NaffSWI
d450 3
a452 25
      [ No32bitCode
        ORRS    PC, LR, #V_bit                  ; mark that an error occurred
      |
        MRS     R10, CPSR                       ; preserve other flags on 26-bit system
        TST     R10, #2_11100
        ORREQS  PC, LR, #V_bit                  ; mark that an error occurred (26-bit)
        SETV                                    ;                             (32-bit)
        MOV     PC, LR
     ]

err_badmode
      [ No32bitCode
        ADR     R0, ErrorBlock_BadMODE
        ORRS    PC, LR, #V_bit                  ; mark that an error occurred
      |
        MRS     R0, CPSR                        ; take care to preserve other flags
        ORR     R0, R0, #V_bit
        MSR     CPSR_f, R0
        ADR     R0, ErrorBlock_BadMODE
        MOV     PC, LR
      ]

        MakeErrorBlock NaffSWI
        MakeErrorBlock BadMODE

d503 1
d505 1
a505 1
ResourceFile    = "Resources:$.Resources.Colours.Tables.8desktop", 0
d507 1
a507 1
ResourceFile    = "Resources:$.Resources.ITable.Tables.8desktop", 0
d520 1
a520 1
        ADR     R1, ResourceFile
d599 3
a601 2
        BLNE    err_badmode
        BNE     %FT90
d627 1
d1122 5
@


4.10
log
@Comment spelling and alignment changes
No code change, not tagged.
@
text
@d44 1
d734 7
a740 1
        LDR     LR, [ R6 ], #4
d1006 64
a1069 64
        DCD     &0000,&0842,&1084,&18C6
        DCD     &0008,&084A,&108C,&18CE
        DCD     &2000,&2842,&3084,&38C6
        DCD     &2008,&284A,&308C,&38CE
        DCD     &0011,&0853,&1095,&18D7
        DCD     &0019,&085B,&109D,&18DF
        DCD     &2011,&2853,&3095,&38D7
        DCD     &2019,&285B,&309D,&38DF
        DCD     &0100,&0942,&1184,&19C6
        DCD     &0108,&094A,&118C,&19CE
        DCD     &2100,&2942,&3184,&39C6
        DCD     &2108,&294A,&318C,&39CE
        DCD     &0111,&0953,&1195,&19D7
        DCD     &0119,&095B,&119D,&19DF
        DCD     &2111,&2953,&3195,&39D7
        DCD     &2119,&295B,&319D,&39DF
        DCD     &0220,&0A62,&12A4,&1AE6
        DCD     &0228,&0A6A,&12AC,&1AEE
        DCD     &2220,&2A62,&32A4,&3AE6
        DCD     &2228,&2A6A,&32AC,&3AEE
        DCD     &0231,&0A73,&12B5,&1AF7
        DCD     &0239,&0A7B,&12BD,&1AFF
        DCD     &2231,&2A73,&32B5,&3AF7
        DCD     &2239,&2A7B,&32BD,&3AFF
        DCD     &0320,&0B62,&13A4,&1BE6
        DCD     &0328,&0B6A,&13AC,&1BEE
        DCD     &2320,&2B62,&33A4,&3BE6
        DCD     &2328,&2B6A,&33AC,&3BEE
        DCD     &0331,&0B73,&13B5,&1BF7
        DCD     &0339,&0B7B,&13BD,&1BFF
        DCD     &2331,&2B73,&33B5,&3BF7
        DCD     &2339,&2B7B,&33BD,&3BFF
        DCD     &4400,&4C42,&5484,&5CC6
        DCD     &4408,&4C4A,&548C,&5CCE
        DCD     &6400,&6C42,&7484,&7CC6
        DCD     &6408,&6C4A,&748C,&7CCE
        DCD     &4411,&4C53,&5495,&5CD7
        DCD     &4419,&4C5B,&549D,&5CDF
        DCD     &6411,&6C53,&7495,&7CD7
        DCD     &6419,&6C5B,&749D,&7CDF
        DCD     &4500,&4D42,&5584,&5DC6
        DCD     &4508,&4D4A,&558C,&5DCE
        DCD     &6500,&6D42,&7584,&7DC6
        DCD     &6508,&6D4A,&758C,&7DCE
        DCD     &4511,&4D53,&5595,&5DD7
        DCD     &4519,&4D5B,&559D,&5DDF
        DCD     &6511,&6D53,&7595,&7DD7
        DCD     &6519,&6D5B,&759D,&7DDF
        DCD     &4620,&4E62,&56A4,&5EE6
        DCD     &4628,&4E6A,&56AC,&5EEE
        DCD     &6620,&6E62,&76A4,&7EE6
        DCD     &6628,&6E6A,&76AC,&7EEE
        DCD     &4631,&4E73,&56B5,&5EF7
        DCD     &4639,&4E7B,&56BD,&5EFF
        DCD     &6631,&6E73,&76B5,&7EF7
        DCD     &6639,&6E7B,&76BD,&7EFF
        DCD     &4720,&4F62,&57A4,&5FE6
        DCD     &4728,&4F6A,&57AC,&5FEE
        DCD     &6720,&6F62,&77A4,&7FE6
        DCD     &6728,&6F6A,&77AC,&7FEE
        DCD     &4731,&4F73,&57B5,&5FF7
        DCD     &4739,&4F7B,&57BD,&5FFF
        DCD     &6731,&6F73,&77B5,&7FF7
        DCD     &6739,&6F7B,&77BD,&7FFF
@


4.9
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
  Removed unused resources.
  Fixed some non 32-bit compatible code.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 0.15. Tagged as 'ITable-0_15'
@
text
@d39 1
a39 3
        AREA    |ITable$$Code|, CODE, READONLY, PIC

	IMPORT  usermode_donothing
d41 7
a47 7
        GET     hdr:ListOpts
        GET     hdr:Macros
        GET     hdr:System
        GET     hdr:ModHand
        GET     hdr:Proc
        GET     hdr:Services
        GET     hdr:FSNumbers
d49 12
a60 12
        GET     hdr:NewErrors
        GET     hdr:Variables
        GET     hdr:VduExt
        GET     hdr:Debug
        GET     hdr:Sprite
        GET     hdr:ColourTran
        GET     hdr:Hourglass
        GET     hdr:NDRDebug
        GET     hdr:PublicWS
        GET     hdr:HostFS
        GET     hdr:PaletteV
        GET     hdr:DDVMacros
a69 5
                GBLL    true
                GBLL    false
true            SETL    {TRUE}
false           SETL    {FALSE}

d72 2
a73 2
debug           SETL    false
hostvdu         SETL    false
d76 1
a76 1
UseResourceTable                 SETL    true
d78 1
a78 1
UseColourTransResourceTable      SETL    true
d80 1
a80 1
CallColourTransForTable          SETL    true
d82 1
a82 1
DontAssumeRedirectionIsToggling  SETL    true
a83 1
; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
d87 1
a87 1
bits            * 5                             ; significan bits per gun used for table index
d140 1
a140 1
        AREA     |!!!module$$Code|, CODE, READONLY
d143 14
a156 14
        & 0                                     ; No application entry
        & Init - module_base
        & Die - module_base
        & Service - module_base

        & Title - module_base
        & Help - module_base
        & 0                                     ; no commands

        & &4BF40
        & SWIDespatch - module_base
        & SWINames - module_base
        & 0                                     ; SWI name decode
        & 0                                     ; messages
d158 1
a158 1
        & ModuleFlags - module_base
d161 1
a161 1
Help    = "Inverse Table", 9, "$Module_HelpVersion"
d163 1
a163 1
        = " Development version"
d165 1
a165 1
        = 0
d170 1
a170 1
        & 1                                     ; 32-bit compatible
d175 3
a177 3
        = "InverseTable", 0                     ; prefix
        = "Calculate", 0
        = 0
d256 2
a257 2
;Ursula format
;
a262 1
;
a290 2
;       Debug   ,"Service",R1

d299 1
a299 1
; It was a reset - therefore reset flags / mark as no dynamic area etc
d338 1
a338 1
; we're changing redirection
d470 1
a470 1
        MOV     R0, # &47                       ; open the file
d479 1
a479 1
        MOV     R0, # 254
d483 2
a484 2
        AND     R0, R2, # &FF                   ; is it ResourceFS?
        CMP     R0, # &2E
d487 1
a487 1
        MOV     R0, # 21                        ; get the internal handle
d581 1
a581 1
;; We keep the inverse table in a dynamic area, we create this dyanmic area with
d625 3
a627 3
;; as outlined in Graphics Gems pp116-119 (see that for the exact details).  Basicly,
;; we have an array which contains the postition within the colour cube of every
;; entry we are going to visit (based on the 5,5,5 indexs).
d643 1
a643 1
;; a length process and should be avoided).
d655 1
a655 1
; Temporary workspace usage
d661 1
a661 1
; Register allocations
d676 1
a677 1
b               RN 10   ;                                            (b inner loop)
a678 1

d682 1
a682 1
; Table used to set hourglass percentage values
d685 4
a688 4
        =  0,  3, 6,   9, 12, 15, 19, 22
        = 25, 28, 31, 35, 38, 41, 44, 47
        = 51, 54, 57, 60, 63, 67, 70, 73
        = 76, 79, 83, 86, 89, 92, 95, 99
d691 1
a691 1
; Do it....
d697 1
a697 1
; Get palette for current screen mode / destination
d707 1
a707 1
; Convert palette from 24 bit RGB to 5,5,5 RGB
d767 1
a767 1
; remember what this table was for - the screen or a sprite
d781 1
a781 1
; Ensure that we have the dynamic area
d797 1
a797 1
   ; check it's something we understand
d804 5
a808 5
   ; in theory at this point we can just remember r2, but the current algorithms used mean
   ; that itable could end up remembering a buffer after it had been discarded by CT
   ; so we'll just copy the buffer.

   ; now copy it to our buffer
d811 3
a813 3
   ; r0 = entries
   ; r1->destination
   ; r2->source
d826 1
a826 1
   ; done, jump to tail of routine
d829 1
a829 1
; ColourTrans magic word
d831 1
a831 1
        = "32K."
d834 1
a834 1
   ; here we start to generate the table ourselves
d850 1
a850 1
; Initialise the distance table to -1 (assumes R0 points at it!)
d864 1
a864 1
; Compute steps and build inverse table
d906 5
a910 5
	; and breathe 				; this will enable other time critical tasks to continue
	Push	"r0-r3, r12"
	BL	usermode_donothing
	Pull	"r0-r3, r12"
	; and continue
d970 1
a970 1
; Handle the exit conditions - removing temporary memory etc
d981 1
a981 1
; remember what this table was for - the screen or a sprite
d999 64
a1062 64
    DCD     &0,&842,&1084,&18C6
    DCD     &8,&84A,&108C,&18CE
    DCD     &2000,&2842,&3084,&38C6
    DCD     &2008,&284A,&308C,&38CE
    DCD     &11,&853,&1095,&18D7
    DCD     &19,&85B,&109D,&18DF
    DCD     &2011,&2853,&3095,&38D7
    DCD     &2019,&285B,&309D,&38DF
    DCD     &100,&942,&1184,&19C6
    DCD     &108,&94A,&118C,&19CE
    DCD     &2100,&2942,&3184,&39C6
    DCD     &2108,&294A,&318C,&39CE
    DCD     &111,&953,&1195,&19D7
    DCD     &119,&95B,&119D,&19DF
    DCD     &2111,&2953,&3195,&39D7
    DCD     &2119,&295B,&319D,&39DF
    DCD     &220,&A62,&12A4,&1AE6
    DCD     &228,&A6A,&12AC,&1AEE
    DCD     &2220,&2A62,&32A4,&3AE6
    DCD     &2228,&2A6A,&32AC,&3AEE
    DCD     &231,&A73,&12B5,&1AF7
    DCD     &239,&A7B,&12BD,&1AFF
    DCD     &2231,&2A73,&32B5,&3AF7
    DCD     &2239,&2A7B,&32BD,&3AFF
    DCD     &320,&B62,&13A4,&1BE6
    DCD     &328,&B6A,&13AC,&1BEE
    DCD     &2320,&2B62,&33A4,&3BE6
    DCD     &2328,&2B6A,&33AC,&3BEE
    DCD     &331,&B73,&13B5,&1BF7
    DCD     &339,&B7B,&13BD,&1BFF
    DCD     &2331,&2B73,&33B5,&3BF7
    DCD     &2339,&2B7B,&33BD,&3BFF
    DCD     &4400,&4C42,&5484,&5CC6
    DCD     &4408,&4C4A,&548C,&5CCE
    DCD     &6400,&6C42,&7484,&7CC6
    DCD     &6408,&6C4A,&748C,&7CCE
    DCD     &4411,&4C53,&5495,&5CD7
    DCD     &4419,&4C5B,&549D,&5CDF
    DCD     &6411,&6C53,&7495,&7CD7
    DCD     &6419,&6C5B,&749D,&7CDF
    DCD     &4500,&4D42,&5584,&5DC6
    DCD     &4508,&4D4A,&558C,&5DCE
    DCD     &6500,&6D42,&7584,&7DC6
    DCD     &6508,&6D4A,&758C,&7DCE
    DCD     &4511,&4D53,&5595,&5DD7
    DCD     &4519,&4D5B,&559D,&5DDF
    DCD     &6511,&6D53,&7595,&7DD7
    DCD     &6519,&6D5B,&759D,&7DDF
    DCD     &4620,&4E62,&56A4,&5EE6
    DCD     &4628,&4E6A,&56AC,&5EEE
    DCD     &6620,&6E62,&76A4,&7EE6
    DCD     &6628,&6E6A,&76AC,&7EEE
    DCD     &4631,&4E73,&56B5,&5EF7
    DCD     &4639,&4E7B,&56BD,&5EFF
    DCD     &6631,&6E73,&76B5,&7EF7
    DCD     &6639,&6E7B,&76BD,&7EFF
    DCD     &4720,&4F62,&57A4,&5FE6
    DCD     &4728,&4F6A,&57AC,&5FEE
    DCD     &6720,&6F62,&77A4,&7FE6
    DCD     &6728,&6F6A,&77AC,&7FEE
    DCD     &4731,&4F73,&57B5,&5FF7
    DCD     &4739,&4F7B,&57BD,&5FFF
    DCD     &6731,&6F73,&77B5,&7FF7
    DCD     &6739,&6F7B,&77BD,&7FFF
@


4.8
log
@  InverseTable modified to use ColourTrans to generate tables.
Detail:
  * In the first instance, it is now possible to use the 32k table from
    Resources:$.Resources.Colours.Tables.8desktop instead of the normal
    ...ITable.Tables.8desktop location. This reduces the space used by
    InverseTable by 32k and may free enough room for 2MB ROM builds.
  * Additionally, it is possible to use ColourTrans to generate all
    tables, rather than using the inbuilt table. ColourTrans is much
    faster at generating these tables - presumably at the expense of
    accuracy - and this may help in modes where the default palette is
    in use. Currently, if ColourTrans fails we fall back to the old
    InverseTable method.
  * Both switches can be toggled independantly.
  * Makefile modified to not export the InverseTable in the resources
    phase. If you toggle the UseColourTransForResourceTable switch, you
    must update the makefile to reflect the required export.
Admin:
  Tested, no noticable degradation of blended font readability observed,
  either with standard palettes or with custom palettes, when displayed
  in the desktop, single tasking, or when redirected to sprites.
Performance:
  StrongARM timings:
    ColourTrans takes about 1 second to generate translation tables.
    InverseTable takes about 2 seconds.
  Plus, with ColourTrans you're gaining from the fact that it caches more
  than a single table, so a second render after a sprite switch /does/
  remember the cached entry.
Background:
  Additional space is required for a 2MB ROM build, and the 32k table
  provided by InverseTable in ResourceFS is really redundant as the
  ColourTrans table will suffice.
  InverseTable provides its own table generation code which is similar
  to that in ColourTrans (colourtrans uses simple weightings, inversetable
  uses sum of squares, as I understand it)

Version 0.13. Tagged as 'ITable-0_13'
@
text
@d39 1
a39 1
        AREA    |Asm$$Code|, CODE, READONLY
d169 1
a169 4
Help    = "Inverse Table", 9, "$Module_MajorVersion ($Module_Date)"
      [ Module_MinorVersion <> ""
        = " $Module_MinorVersion"
      ]
d1000 2
a1001 1
        Push    "R0,PC"
d1004 1
a1004 1
        RestoreMODE LR
@


4.7
log
@  Fix for rare bug triggered by multiple nested sprite redirections
  confusing the module's palette tracking.
Detail:
  The problem is that at present InverseTable assumes that when you
  redirect output to a sprite you will be toggling in and out of a sprite
  with a palette it understands. That is that in the sequence Calculate,
  redirect, redirect, Calculate, the final Calculate can be ignored
  because it will have the same table as the first. This is incorrect if
  the second redirect is a redirection to a sprite which was not that
  which the first would have restored to.
  The failure sequence can occur when you generate a bitmap from a font
  for the first time, I believe. It can also be artificially simulated
  (and can happen in real world situations if redirection occurs on a
  callback).
  The new algorithm is :
    At every redirection, record whether we are redirecting to the screen
    When tables are generated, remember whether this was for a screen
      redirection
    Mark every redirection as invalid, UNLESS the table we have cached is
      for the screen and we are redirecting to the screen, in which case
      clear the redirection invalid flag.
  The upshot of this is that for any sequence of redirection the
  inversetable is maintained as valid, BUT redirection between multiple
  sprites can cause InverseTable to recache the tables where previously it
  might have used tables it already had. In the latter case, it would be
  likely that redirection back to the screen would have displayed
  'tutti-fruti' coloured text.
  The speed hit of calculating the tables will be noticable if they are
  needed, but the effect of displaying incorrect text is more noticeable
  when it occurs.
Admin:
  Tested with examples of badly nested sprite redirection, and correctly
  tracked the palettes in use.

Version 0.12. Tagged as 'ITable-0_12'
@
text
@d84 4
d469 3
d473 1
d645 2
a646 2
;; cube seeining if the distance for the colour at this point is greater
;; than the previously stored distance for thsi point.  If it is then we
d759 1
a759 1
        LDRNE   LR, pInverseTable               ;   if not then is there a table presetn
d801 50
d854 4
d991 1
@


4.6
log
@  this is a checkin following a failed checkin.
  added a usermode gap.
Detail:
   the central palette calculation loop was taking sufficiently
   long to disrupt the flow of video.  This has been fixed.
Admin:
   I have tested this on the desktop and the STB.

Version 0.11. Not tagged
@
text
@d82 4
a85 2
                GBLL    UseResourceTable
UseResourceTable        SETL    true
d112 4
d206 5
d213 1
d346 17
d364 1
a364 1

d770 11
d782 2
a784 1
        BNE     %FT90                           ;     and exit, else carry on
d932 6
@


4.5
log
@32-bit compatible.

Version 0.10. Tagged as 'ITable-0_10'
@
text
@d39 4
d138 1
a138 1
        LEADR   Module_LoadAddr
d185 1
a185 1
Init    ENTRY   "R1-R3"
d227 1
a227 1
Die     ENTRY   "R1-R2"
d289 1
a289 1
        ENTRY   "R0-R1"
d364 1
a364 1
        mrs    ,R10, CPSR                       ; preserve other flags on 26-bit system
d376 1
a376 1
        mrs    ,R0, CPSR                        ; take care to preserve other flags
d378 1
a378 1
        msr    ,CPSR_f, R0
d391 1
a391 1
claim_vectors ENTRY "R1-R3"
d417 1
a417 1
        ENTRY   "WP"
d440 1
a440 1
        ENTRY   "r0-r11"
d521 1
a521 1
ITable_Calculate ENTRY "R2"
d564 1
a564 1
claim_area ENTRY "R1-R8"
d585 1
a585 1
release_area ENTRY "R0-R1"
d671 1
a671 1
build_itable ENTRY "R1-R11"
d818 5
@


4.4
log
@Fixed version number string.

Version 0.09. Tagged as 'ITable-0_09'
@
text
@d37 1
d150 4
d165 5
d226 2
a227 2
        TEQ     WP, # 0                         ;   if not then there is nothing to tidy up
        EXITS   EQ
d280 1
a280 1
        MOVNES  PC, LR
d307 1
a307 1
        EXITS
d323 1
a323 1
        EXITS
d334 1
a334 1
        EXITS
d347 1
a347 1
        TEQP    PC, #SVC_mode                   ;   ensure that IRQ's get re-enabled
d356 2
d359 7
d368 1
d371 7
d389 1
d392 1
a392 1
        EXITS   EQ
d411 1
a411 1
        MOVNES  PC, LR                          ; not a modifying palette operation
d419 1
a419 1
        EXITS   GE
d425 1
a425 1
        EXITS
d449 1
a449 1
        EXITS   EQ                              ; exit if zero (can't open file)
d472 1
a472 1
        EXITS
d501 1
a501 1
;; So using a colour number as an index into the table at R0 will yeild
d564 1
a564 1
        EXITS   NE
d584 2
a585 2
        TEQ     R1, # 0                         ; has a dynamic area been created
        EXITS   EQ
d589 2
a590 1
        EXITS
@


4.3
log
@Ursula branch merged (service call table).
Changed to use srccommit.

Version 0.08. Tagged as 'ITable-0_08'
@
text
@d150 4
a153 1
Help    = "Inverse Table", 9, "$VString ($Date)"
@


4.2
log
@NCOS 1.06 version used
@
text
@d22 8
a29 8
; 11-Dec-95	 DDV Added Hourglass display to show that we haven't got stuck.
; 12-Dec-95	 DDV Bug fix: R and B in the table calculator needed swapped to map to VIDC format.
; 12-Dec-95	 DDV Palette write operations cause inverse table to be invalidated.
; 12-Dec-95	 DDV Now use ColourTrans to read palette (should cope with output to sprite).
; 12-Dec-95	 DDV Added check to only recompute inverse-table when palette changes.
; 12-Dec-95	 DDV Support for switching output to a sprite invalidating the tables.
; 13-Dec-95	 DDV Fixed SWI chunk to one from Alan Glover (+ some reformatting).
; 13-Dec-95	 DDV Errors reported out of calculate correctly.
d33 1
a33 1
; 13-Dec-95	 DDV Now uses dynamic areas properly for storing inverse and distance tables.
d36 1
d56 2
a57 2
	GET	hdr:PaletteV
	GET	hdr:DDVMacros
d59 2
a60 2
	GET	hdr.ITable			; our SWI information
	GET	Version				; and version data
d67 9
a75 9
        	GBLL	true
		GBLL	false
true            SETL	{TRUE}
false		SETL 	{FALSE}

		GBLL	debug
		GBLL	hostvdu
debug		SETL	false
hostvdu		SETL	false
d77 2
a78 2
		GBLL	UseResourceTable
UseResourceTable	SETL	true
d84 1
a84 1
bits 		* 5				; significan bits per gun used for table index
d86 4
a89 4
nbits		* 8 - bits			; DO NOT modify computed from bits
x		* 1 << nbits			; DO NOT modify computed from bits
xsqr		* 1 << ( 2 * nbits )		; DO NOT modify computed from bits
colourmax	* 1 << bits			; DO NOT modify computed from bits
d94 2
a95 2
		^ 0, WP
iFlags		# 4				; = flags ( f_xxx )
d97 3
a99 3
f_PaletteV	 * &00000001			; = 1 => palette vector has been claimed
f_TableValid	 * &00000002			; = 1 => inverse table is valid for current destination
f_SwitchInvalid	 * &00000004			; = 1 => Switched to a sprite, therefore if calculating the table is invalid
d101 1
a101 1
f_StandardPal	 * &00000008			; = 1 => The current palette is the standard one
d103 1
a103 1
f_StandardPal	 * &00000000
d105 1
a105 1
iDynamicArea	# 4				; = ID of our dynamic area
d107 2
a108 2
pInverseTable	# 4				; -> current inverse table
pDistanceTable	# 4				; -> distance table
d111 1
a111 1
pResourceTable	# 4
d114 1
a114 1
iPalette555	# 4 * 256			; = palette quanitised down to 5,5,5 RGB
d116 1
a116 1
ws_required	* :INDEX: @@
d121 3
a123 3
		^ 0
da_iInverseTable  	# colourmax * colourmax * colourmax
da_MinimumSize		* :INDEX: @@
d125 2
a126 2
da_iDistanceTable	# ( ?da_iInverseTable ) * 4
da_MaximumSize		* :INDEX: @@
d133 1
a133 1
	LEADR	Module_LoadAddr
d136 13
a148 13
	& 0					; No application entry
	& Init - module_base
	& Die - module_base
	& Service - module_base

	& Title - module_base
	& Help - module_base
	& 0					; no commands

	& &4BF40
	& SWIDespatch - module_base
	& SWINames - module_base
	& 0					; SWI name decode
d150 1
a150 1
Help 	= "Inverse Table", 9, "$VString ($Date)"
d152 1
a152 1
	= " Development version"
d154 2
a155 2
	= 0
	ALIGN
d159 4
a162 4
	= "InverseTable", 0			; prefix
	= "Calculate", 0
	= 0
	ALIGN
d168 1
a168 1
Init	ENTRY 	"R1-R3"
d170 8
a177 8
	LDR	R2, [WP]			; pick up the private word
	TEQ	R2, #0				;   do we already have our workspace?
	BNE	%FT10

	MOV	R0, #ModHandReason_Claim
	LDR	R3, =ws_required
	SWI	XOS_Module			; attempt to claim our workspace block
	EXIT	VS				;   if that fails then return
d179 1
a179 1
	STR	R2, [WP]			; set the private word to point at our workspace
d181 1
a181 1
	MOV	WP, R2
d183 8
a190 8
	MOV	R0, #0				; NULL suitable entries
	STR	R0, iFlags
	STR	R0, iDynamicArea
	STR	R0, pInverseTable

	MOV	R0, # -1			; = -1 => invalid 5,5,5 entry
	ADR	R1, iPalette555
	LDR	R2, = ?iPalette555
d192 3
a194 3
	SUBS	R2, R2, # 4
	STRGE	R0, [ R1 ], # 4
	BGE	%BT20
d196 1
a196 1
	Debug_Open	pipe:itable
d199 1
a199 1
 	BL	check_resource			; deliberately don't check error return
d202 2
a203 2
	BL	claim_vectors			; try to claim the vectors
	EXIT					;   and return any possible errors
d210 1
a210 1
Die	ENTRY	"R1-R2"
d212 3
a214 3
	LDR	WP, [WP]			; do we have a workspace pointer currently?
	TEQ	WP, # 0				;   if not then there is nothing to tidy up
	EXITS	EQ
d216 6
a221 6
	LDR	R3, iFlags
	TST	R3, # f_PaletteV		; do we currently have the palette vector claimed?
	MOVNE	R0, # PaletteV
	ADRNE	R1, palVhandler
	MOVNE	R2, WP
	SWINE	XOS_Release
d223 1
a223 1
	BL	release_area			; if we have a dynamic area then discard it
d225 1
a225 1
	Debug_Close
d227 1
a227 1
	EXIT
d234 37
a270 1
Service	ROUT
d272 1
a272 13
	TEQ	R1, # Service_Reset		; filter out only the ones we want
	TEQNE	R1, # Service_ModeChange
	TEQNE	R1, # Service_SwitchingOutputToSprite
 [ UseResourceTable
	TEQNE	R1, # Service_ResourceFSStarted
	TEQNE	R1, # Service_ResourceFSDying
	TEQNE   R1, # Service_PostInit
 ]
	MOVNES	PC, LR

;	Debug	,"Service",R1

	ENTRY	"R0-R1"
d274 2
a275 2
	LDR	WP, [ WP ]			; get workspace pointer
	LDR	R0, iFlags			;   and current flags word
d277 2
a278 2
	TEQ	R1, # Service_Reset
	BNE	%FT10
d282 2
a283 2
	BIC	R0, R0, # f_TableValid :OR: f_PaletteV :OR: f_StandardPal
	STR	R0, iFlags
d285 4
a288 4
	MOV	R0, # 0				; remove the dynamic area
	STR	R0, iDynamicArea
	STR	R0, pInverseTable
	STR	R0, pDistanceTable
d290 1
a290 1
	STR	R0, pResourceTable
d292 1
a292 1
	BL	claim_vectors			; must claim the vectors again
d294 1
a294 1
	EXITS
d296 1
a296 1
10						; if resourcefs changed get the new ptr
d298 4
a301 4
	TEQ	R1, # Service_ResourceFSStarted
	TEQNE	R1, # Service_ResourceFSDying
	TEQNE   R1, # Service_PostInit
	BNE	%ft20
d303 1
a303 1
	BL	check_resource
d305 4
a308 4
	LDR	R1, pResourceTable		; if table has vanished then clear the StandardPal bit
	CMP	R1, #0				; and set the table to invalid
	BICEQ	R0, R0, # f_TableValid
	STREQ	R0, iFlags
d310 1
a310 1
	EXITS
d314 4
a317 4
	TEQ	R1, # Service_ModeChange
	BICEQ	R0, R0, # f_TableValid 		; mode change, therefore table bad
	TEQ	R1, # Service_SwitchingOutputToSprite
	EOREQ	R0, R0, # f_SwitchInvalid	; output gone to sprite - maybe invalid
d319 1
a319 1
	STR	R0, iFlags
d321 1
a321 1
	EXITS
d333 2
a334 2
	LDR	WP, [WP]			; de-reference the workspace pointer
	TEQP	PC, #SVC_mode			;   ensure that IRQ's get re-enabled
d336 3
a338 3
	CMP	R11, #( %90-%00 ) / 4		; is the index valid for our swi table
	ADDCC	PC, PC, R11, LSL # 2		;   if it is then despatch
	B	%FT90
d340 1
a340 1
	B	ITable_Calculate
d342 2
a343 2
	ADR	R0, ErrorBlock_NaffSWI
	ORRS	PC, LR, #V_bit			; mark that an error occurred
d346 2
a347 2
	ADR	R0, ErrorBlock_BadMODE
	ORRS	PC, LR, #V_bit			; mark that an error occurred
d349 2
a350 2
	MakeErrorBlock NaffSWI
	MakeErrorBlock BadMODE
d359 9
a367 9
	LDR	R3, iFlags
        TST	R3, # f_PaletteV		; is paletteV claimed currently
	EXITS	EQ

	MOV	R0, #PaletteV
	ADR	R1, palVhandler
	MOV	R2, WP
	SWI	XOS_Claim			; attempt to claim the palette vector
	ORRVC	R3, R3, # f_PaletteV		;  if that worked then mark as claimed
d369 1
a369 1
	STR	R3, iFlags
d371 1
a371 1
	EXIT
d377 4
a380 4
	TEQ	R4, # paletteV_Set
	TEQNE	R4, # paletteV_SetDefaultPalette
	TEQNE	R4, # paletteV_BulkWrite
	MOVNES	PC, LR				; not a modifying palette operation
d382 1
a382 1
	ENTRY	"WP"
d384 2
a385 2
	TEQ	R4, # paletteV_Set		; are we writing an entry?
	BNE	%FT01
d387 2
a388 2
        CMP	R1, # 24			; is it the border or cursor colour?
	EXITS	GE
d390 3
a392 3
	LDR	LR, iFlags
	BIC	LR, LR, # f_TableValid		; table is no longer valid
	STR	LR, iFlags
d394 1
a394 1
	EXITS
d401 2
a402 2
ResourceFile	= "Resources:$.Resources.ITable.Tables.8desktop", 0
	ALIGN
d405 1
a405 1
	ENTRY	"r0-r11"
d407 1
a407 1
	Debug1	,"check_resource"
d409 2
a410 2
	MOV	R0, #0				; zero the pointer first
	STR	R0, pResourceTable
d412 4
a415 4
	MOV	R0, # &47			; open the file
	ADR	R1, ResourceFile
	SWI	XOS_Find
	EXIT	VS
d417 2
a418 2
	MOVS	R11, R0				; save the file handle in R11
	EXITS	EQ				; exit if zero (can't open file)
d420 4
a423 4
	MOV	R1, R0				; get the fs number
	MOV	R0, # 254
	SWI	XOS_Args
	BVS	%ft99
d425 3
a427 3
	AND	R0, R2, # &FF			; is it ResourceFS?
	CMP	R0, # &2E
	BNE	%ft99
d429 3
a431 3
	MOV	R0, # 21			; get the internal handle
	SWI	XOS_FSControl
	BVS	%ft99
d433 1
a433 1
	STR	R1, pResourceTable		; save the direct pointer to the file
d435 1
a435 1
	Debug	,"pResourceTable",R1
d437 3
a439 3
99	MOV	R0, #0				; close the file
	MOV	R1, R11
	SWI	XOS_Find
d441 1
a441 1
	EXITS
d466 1
a466 1
;; 	< b14-10 == B >
d468 1
a468 1
;;				    < b4-0 == R >
d481 3
a483 3
;; in	-
;; out 	R0 -> index to 5,5,5 RGB data
;;	R1 -> 5,5,5 RGB data to index table
d488 22
a509 22
	MOV	R0, #-1
	MOV	R1, #VduExt_Log2BPP
	SWI	XOS_ReadModeVariable		; read the log2 bits per pixel for this mode
	TEQ	R2, #3				;   if this is not 8 bit then exit
	BLNE	err_badmode
	BNE	%FT90

	LDR	R2, iFlags			; check to see if table is valid
	TST	R2, # f_SwitchInvalid
	BICNE	R2, R2, # f_TableValid :OR: f_SwitchInvalid
	TST	R2, # f_TableValid
	BLEQ	build_itable			; if not valid then build the inverse table

 [ UseResourceTable
 	EXIT	VS

	LDR	R2, iFlags			; reload flags as they may have changed
	ADR	R0, iPalette555			; -> RGB 5,5,5 table ( index => 5,5,5 )
	TST	R2, # f_StandardPal
	LDRNE	R1, pResourceTable		; if bit is not set
	CMPNE	R1, #0				; or resource table is not present
	LDREQ	R1, pInverseTable		; use the built table
d511 1
a511 1
	Debug	,"ITable_Calculate",R0,R1,R2
d513 2
a514 2
	ADRVC	R0, iPalette555			; -> RGB 5,5,5 table ( index => 5,5,5 )
	LDRVC	R1, pInverseTable		; -> inverse table (5,5,5 => colour number)
d517 1
a517 1
	EXIT
d531 16
a546 16
	LDR	R0, iDynamicArea
	CMP	R0, # 0				; have we already allocated our dynamic area?
	EXITS	NE

	MOV	R0, # 0				; = 0 => create dynamic area
	MOV	R1, # -1
	LDR	R2, = da_MinimumSize		; minimum size (size of inverse table)
	MOV	R3, # -1
	MOV	R4, # ( 1:SHL:7)
	LDR	R5, = da_MaximumSize		; maximum size (inverse table + distance table)
	MOV	R6, # 0
	MOV	R7, # 0
	ADRL	R8, Title			; -> name for dynamic area (Task Manager)
	SWI	XOS_DynamicArea
	STRVC	R1, iDynamicArea
	STRVC	R3, pInverseTable
d548 1
a548 1
	EXIT
d552 7
a558 7
	LDR	R1, iDynamicArea
	TEQ	R1, # 0				; has a dynamic area been created
	EXITS	EQ

	MOV	R0, # 1				; = 1 => discard dynamic area
	SWI	XOS_DynamicArea
	EXITS
d598 2
a599 2
		^ ScratchSpace
scratch_palette	# 256 * 4
d604 2
a605 2
pITable 	RN 0	;			---- always ---
pDistances	RN 1	;			---- always ---
d607 3
a609 3
rDist		RN 2 	; (outerloop)
gDist		RN 3	; (outerloop)
bDist		RN 4	; (outerloop)
d611 3
a613 3
rInc		RN 5	; (outerloop)
gInc		RN 6	; (outerloop)
bInc		RN 7	; (outerloop)
d615 2
a616 2
r		RN 8	;	       (r inner loop)
g		RN 9	;                             (g inner loop)
d618 2
a619 2
b		RN 10	; 	                                     (b inner loop)
scratch		RN 10	; (outer loop)
d621 1
a621 1
iColours	RN 11	; (outer loop) 			(doubles as return value register)
d627 5
a631 5
	=  0,  3, 6,   9, 12, 15, 19, 22
	= 25, 28, 31, 35, 38, 41, 44, 47
	= 51, 54, 57, 60, 63, 67, 70, 73
 	= 76, 79, 83, 86, 89, 92, 95, 99
	ALIGN
d637 1
a637 1
	SWI	XHourglass_On			; this could take some time
d641 7
a647 7
	MOV	R0, # -1			; read palette for current destination
	MOV	R1, # -1
	LDR	R2, = scratch_palette		; into this buffer
	LDR	R3, = ?scratch_palette		;   which is so big
	MOV	R4, # 0
	SWI 	XColourTrans_ReadPalette
	BVS	%FT90
d651 4
a654 4
	LDR	R0, = scratch_palette
	ADRL	R1, iPalette555
	LDR	R2, = ?scratch_palette
	MOV	R5, # 1				; table has not been modified yet
d657 2
a658 2
	ADRL	R6, StandardPalette		; standard 8 bit palette
	MOV	R7, # 1				; 1 = palette matches standard
d661 7
a667 7
	LDR	R3, [ R0 ], #4			; pick up 24 bit palette entry
	AND 	R4, R3, #&f8000000		;   and convert to 5,5,5 RGB
	AND	LR, R3, #&00f80000
	ORR	R4, R4, LR, LSL # 3
	AND	R3, R3, #&0000f800
	ORR	R3, R4, R3, LSL # 6
	MOV	R3, R3, LSR # 17
d669 4
a672 4
	LDR	LR, [ R1 ]
	TEQ	LR, R3				; has the colour changed?
	MOVNE	R5, # 0				;   yes, so must re-compute the inverse table
	STR	R3, [ R1 ], #4
d675 3
a677 3
	LDR	LR, [ R6 ], #4
	TEQ	LR, R3				; is the colour different from the standard
	MOVNE	R7, # 0				;   yes, then we can't use the standard table
d679 2
a680 2
	SUBS	R2, R2, # 4
	BGT	%BT10				; loop until *ENTIRE* palette converted
d682 1
a682 1
	Debug	,"build_itable changed",R5
d684 1
a684 1
	CMP	R5, #0				; has the palette actually changed?
d686 2
a687 2
	LDRNE	LR, pInverseTable		;   if not then is there a table presetn
	CMPNE	LR, #0
d689 1
a689 1
	BNE	%FT85				;   if so then don't bother re-calculating the colour table
d692 1
a692 1
	Debug	,"build_itable standard",R7
d694 1
a694 1
	LDR	LR, iFlags
d696 4
a699 4
	CMP	R7, # 0				; is it actually the standard palette?
	BICEQ	LR, LR, #f_StandardPal		;   no - clear flag, store and carry on
	STREQ	LR, iFlags
	BEQ	%FT20
d701 5
a705 5
	ORR	LR, LR, #f_StandardPal		;   yes - set flag
	LDR	R7, pResourceTable		;   check if we have the resource table
	CMP	R7, # 0
	ORRNE	LR, LR, # f_TableValid		;     yes - then table is now valid
	STR	LR, iFlags
d707 1
a707 1
	BNE	%FT90				;     and exit, else carry on
d713 2
a714 2
	BL	claim_area			; attempt to claim the dynamic area ready to build the table
	BVS	%FT90
d716 9
a724 9
	LDR	R0, iDynamicArea
	MOV	R1, # ?da_iDistanceTable
	SWI	XOS_ChangeDynamicArea		; expand to contain our distances table
	BVS	%FT90				;   if that fails then return

	LDR	R0, pInverseTable
	ASSERT	da_iDistanceTable > 0
	ADD	R0, R0, # da_iDistanceTable	; -> distance table in dynamic area
	STR	R0, pDistanceTable
d728 2
a729 2
	MOV	R1, # -1			; initialise the distances table to -1
	LDR	R2, = ( colourmax * colourmax * colourmax )
d731 3
a733 3
	SUBS	R2, R2, # 1			; decrease counter
	STRPL	R1, [ R0 ], #4			;   write initial value for distance
	BPL	%BT15				;   and loop...
d735 1
a735 1
	MOV	iColours, # 0
d737 2
a738 2
	CMP	iColours, # ?scratch_palette / 4
	BGE	%FT80
d742 2
a743 2
	LDR	LR, = scratch_palette
	LDR	LR, [ LR, iColours, LSL # 2 ]	; pick up RGB value
d745 30
a774 30
	AND	rDist, LR, #&FF00
	MOV	rDist, rDist, LSR # 8
	MOV	rInc, rDist, LSL # nbits	; rInc = rDist (r) << nBits
	RSB	rInc, rInc, # xsqr
	MOV	rInc, rInc, LSL # 1		; rInc = 2 * ( xsqr - ( r << nbits ) )
	SUB	rDist, rDist, # x / 2		; rDist = r - ( x / 2 )

	AND	gDist, LR, #&FF0000
	MOV	gDist, gDist, LSR # 16
	MOV	gInc, gDist, LSL # nbits	; gInc = gDist (g) << nbits
	RSB	gInc, gInc, # xsqr
	MOV	gInc, gInc, LSL # 1		; gInc = 2 * ( xsqr - ( g << nbits ) )
	SUB	gDist, gDist, # x / 2		; gDist = g - ( x / 2 )

	MOV	bDist, LR, LSR # 24
	MOV	bInc, bDist, LSL # nbits	; bInc = bDist (b) << nbits
	RSB	bInc, bInc, # xsqr
	MOV	bInc, bInc, LSL # 1		; bInc = 2 * ( xsqr - ( b << nbits ) )
	SUB	bDist, bDist, # x / 2		; bDist = b - ( x / 2 )

	MOV	scratch, bDist
	MUL	bDist, scratch, bDist		; bDist  = ( bDist * bDist )
	MOV	scratch, gDist
	MLA	bDist, scratch, gDist, bDist	; bDist += ( gDist * gDist )
	MOV	scratch, rDist
	MLA	bDist, scratch, rDist, bDist	; bDist += ( rDist * rDist )

	ADR	R0, percent_table
	LDRB	R0, [ R0, iColours, LSR # 3 ]
	SWI	XHourglass_Percentage		; set the hourglass percentage value
d776 1
a776 1
	MOV	b, #0				; b = 0
d778 2
a779 2
	LDR	pITable, pInverseTable
	LDR	pDistances, pDistanceTable	; -> distance table
d782 3
a784 3
	CMP	b, # colourmax                  ; finished the red loop
	ADDGE	iColours, iColours, # 1		;   iColours += 4
	BGE	%BT20				;     and advance to the next colour
d786 2
a787 2
	MOV	gDist, bDist			; gDist = bDist
	MOV	g, #0				; g = 0
d789 1
a789 1
	Push	"gInc"
d792 2
a793 2
	CMP	g, # colourmax			; finished the green loop
	BGE	end_green_loop
d795 2
a796 2
	MOV	rDist, gDist			; rDist = gDist
	MOV	r, # 0				; r = 0
d798 1
a798 1
	Push	"rInc"
d801 2
a802 2
	CMP	r, # colourmax			; blue loop finished?
	BGE	end_red_loop
d804 9
a812 9
	TEQ	iColours, #0			; is this colour zero?
	STREQ	rDist, [ pDistances ]
	STREQB	iColours, [ pITable ]
	BEQ	%FT30

	LDR	LR, [ pDistances ]
	CMP	LR, rDist                       ; is it closer to this colour
	STRGT	rDist, [ pDistances ]
	STRGTB	iColours, [ pITable ]
d814 3
a816 3
	ADD	rDist, rDist, rInc		; rDist += rInc
	ADD	r, r, # 1			; r++
	ADD	rInc, rInc, # xsqr * 2		; rInc += xsqr * 2
d818 2
a819 2
	ADD	pITable, pITable, # 1		; pITable += 1
	ADD	pDistances, pDistances, # 4	; pDistances += 4
d821 1
a821 1
	B	red_loop
d824 1
a824 1
	Pull	"rInc"
d826 3
a828 3
	ADD	gDist, gDist, gInc		; gDist += gInc
	ADD	g, g, # 1			; g++
	ADD	gInc, gInc, # xsqr * 2		; gInc += xsqr * 2
d830 1
a830 1
	B	green_loop
d833 1
a833 1
	Pull	"gInc"
d835 3
a837 3
	ADD	bDist, bDist, bInc		; bDist += bInc
	ADD	b, b, #1			; b++
	ADD	bInc, bInc, # xsqr * 2		; bInc += xsqr * 2
d839 1
a839 1
	B	blue_loop
d844 3
a846 3
	LDR	R0, iDynamicArea
	LDR	R1, = - ( ?da_iDistanceTable )
	SWI	XOS_ChangeDynamicArea		; remove distance table from dynamic area
d848 3
a850 3
	LDR	LR, iFlags
	ORR	LR, LR, # f_TableValid		; table is now valid
	STR	LR, iFlags
d852 4
a855 4
	Push	"R0,PC"
	SWI	XHourglass_Off			; remove hourglass
	Pull	"R0,LR"				;   preserving error condition around call
	RestoreMODE LR
d857 1
a857 1
	EXIT
d929 1
a929 1
	InsertNDRDebugRoutines
d932 1
a932 1
	END
@


4.2.2.1
log
@update to Ursula service format
@
text
@d22 8
a29 8
; 11-Dec-95      DDV Added Hourglass display to show that we haven't got stuck.
; 12-Dec-95      DDV Bug fix: R and B in the table calculator needed swapped to map to VIDC format.
; 12-Dec-95      DDV Palette write operations cause inverse table to be invalidated.
; 12-Dec-95      DDV Now use ColourTrans to read palette (should cope with output to sprite).
; 12-Dec-95      DDV Added check to only recompute inverse-table when palette changes.
; 12-Dec-95      DDV Support for switching output to a sprite invalidating the tables.
; 13-Dec-95      DDV Fixed SWI chunk to one from Alan Glover (+ some reformatting).
; 13-Dec-95      DDV Errors reported out of calculate correctly.
d33 1
a33 1
; 13-Dec-95      DDV Now uses dynamic areas properly for storing inverse and distance tables.
d55 2
a56 2
        GET     hdr:PaletteV
        GET     hdr:DDVMacros
d58 2
a59 2
        GET     hdr.ITable                      ; our SWI information
        GET     Version                         ; and version data
d66 9
a74 9
                GBLL    true
                GBLL    false
true            SETL    {TRUE}
false           SETL    {FALSE}

                GBLL    debug
                GBLL    hostvdu
debug           SETL    false
hostvdu         SETL    false
d76 2
a77 2
                GBLL    UseResourceTable
UseResourceTable        SETL    true
d83 1
a83 1
bits            * 5                             ; significan bits per gun used for table index
d85 4
a88 4
nbits           * 8 - bits                      ; DO NOT modify computed from bits
x               * 1 << nbits                    ; DO NOT modify computed from bits
xsqr            * 1 << ( 2 * nbits )            ; DO NOT modify computed from bits
colourmax       * 1 << bits                     ; DO NOT modify computed from bits
d93 2
a94 2
                ^ 0, WP
iFlags          # 4                             ; = flags ( f_xxx )
d96 3
a98 3
f_PaletteV       * &00000001                    ; = 1 => palette vector has been claimed
f_TableValid     * &00000002                    ; = 1 => inverse table is valid for current destination
f_SwitchInvalid  * &00000004                    ; = 1 => Switched to a sprite, therefore if calculating the table is invalid
d100 1
a100 1
f_StandardPal    * &00000008                    ; = 1 => The current palette is the standard one
d102 1
a102 1
f_StandardPal    * &00000000
d104 1
a104 1
iDynamicArea    # 4                             ; = ID of our dynamic area
d106 2
a107 2
pInverseTable   # 4                             ; -> current inverse table
pDistanceTable  # 4                             ; -> distance table
d110 1
a110 1
pResourceTable  # 4
d113 1
a113 1
iPalette555     # 4 * 256                       ; = palette quanitised down to 5,5,5 RGB
d115 1
a115 1
ws_required     * :INDEX: @@
d120 3
a122 3
                ^ 0
da_iInverseTable        # colourmax * colourmax * colourmax
da_MinimumSize          * :INDEX: @@
d124 2
a125 2
da_iDistanceTable       # ( ?da_iInverseTable ) * 4
da_MaximumSize          * :INDEX: @@
d132 1
a132 1
        LEADR   Module_LoadAddr
d135 13
a147 13
        & 0                                     ; No application entry
        & Init - module_base
        & Die - module_base
        & Service - module_base

        & Title - module_base
        & Help - module_base
        & 0                                     ; no commands

        & &4BF40
        & SWIDespatch - module_base
        & SWINames - module_base
        & 0                                     ; SWI name decode
d149 1
a149 1
Help    = "Inverse Table", 9, "$VString ($Date)"
d151 1
a151 1
        = " Development version"
d153 2
a154 2
        = 0
        ALIGN
d158 4
a161 4
        = "InverseTable", 0                     ; prefix
        = "Calculate", 0
        = 0
        ALIGN
d167 1
a167 1
Init    ENTRY   "R1-R3"
d169 8
a176 8
        LDR     R2, [WP]                        ; pick up the private word
        TEQ     R2, #0                          ;   do we already have our workspace?
        BNE     %FT10

        MOV     R0, #ModHandReason_Claim
        LDR     R3, =ws_required
        SWI     XOS_Module                      ; attempt to claim our workspace block
        EXIT    VS                              ;   if that fails then return
d178 1
a178 1
        STR     R2, [WP]                        ; set the private word to point at our workspace
d180 1
a180 1
        MOV     WP, R2
d182 8
a189 8
        MOV     R0, #0                          ; NULL suitable entries
        STR     R0, iFlags
        STR     R0, iDynamicArea
        STR     R0, pInverseTable

        MOV     R0, # -1                        ; = -1 => invalid 5,5,5 entry
        ADR     R1, iPalette555
        LDR     R2, = ?iPalette555
d191 3
a193 3
        SUBS    R2, R2, # 4
        STRGE   R0, [ R1 ], # 4
        BGE     %BT20
d195 1
a195 1
        Debug_Open      pipe:itable
d198 1
a198 1
        BL      check_resource                  ; deliberately don't check error return
d201 2
a202 2
        BL      claim_vectors                   ; try to claim the vectors
        EXIT                                    ;   and return any possible errors
d209 1
a209 1
Die     ENTRY   "R1-R2"
d211 3
a213 3
        LDR     WP, [WP]                        ; do we have a workspace pointer currently?
        TEQ     WP, # 0                         ;   if not then there is nothing to tidy up
        EXITS   EQ
d215 6
a220 6
        LDR     R3, iFlags
        TST     R3, # f_PaletteV                ; do we currently have the palette vector claimed?
        MOVNE   R0, # PaletteV
        ADRNE   R1, palVhandler
        MOVNE   R2, WP
        SWINE   XOS_Release
d222 1
a222 1
        BL      release_area                    ; if we have a dynamic area then discard it
d224 1
a224 1
        Debug_Close
d226 1
a226 1
        EXIT
d233 1
a233 37
;Ursula format
;
        ASSERT  Service_Reset                   < Service_ModeChange
        ASSERT  Service_ModeChange              < Service_ResourceFSStarted
        ASSERT  Service_ResourceFSStarted       < Service_ResourceFSDying
        ASSERT  Service_ResourceFSDying         < Service_SwitchingOutputToSprite
        ASSERT  Service_SwitchingOutputToSprite < Service_PostInit
;
UServTab
        DCD     0
        DCD     UService - module_base
        DCD     Service_Reset
        DCD     Service_ModeChange
  [ UseResourceTable
        DCD     Service_ResourceFSStarted
        DCD     Service_ResourceFSDying
  ]
        DCD     Service_SwitchingOutputToSprite
  [ UseResourceTable
        DCD     Service_PostInit
  ]
        DCD     0
        DCD     UServTab - module_base
Service ROUT
        MOV     r0, r0
        TEQ     R1, # Service_Reset             ; filter out only the ones we want
        TEQNE   R1, # Service_ModeChange
        TEQNE   R1, # Service_SwitchingOutputToSprite
 [ UseResourceTable
        TEQNE   R1, # Service_ResourceFSStarted
        TEQNE   R1, # Service_ResourceFSDying
        TEQNE   R1, # Service_PostInit
 ]
        MOVNES  PC, LR
UService

;       Debug   ,"Service",R1
d235 13
a247 1
        ENTRY   "R0-R1"
d249 2
a250 2
        LDR     WP, [ WP ]                      ; get workspace pointer
        LDR     R0, iFlags                      ;   and current flags word
d252 2
a253 2
        TEQ     R1, # Service_Reset
        BNE     %FT10
d257 2
a258 2
        BIC     R0, R0, # f_TableValid :OR: f_PaletteV :OR: f_StandardPal
        STR     R0, iFlags
d260 4
a263 4
        MOV     R0, # 0                         ; remove the dynamic area
        STR     R0, iDynamicArea
        STR     R0, pInverseTable
        STR     R0, pDistanceTable
d265 1
a265 1
        STR     R0, pResourceTable
d267 1
a267 1
        BL      claim_vectors                   ; must claim the vectors again
d269 1
a269 1
        EXITS
d271 1
a271 1
10                                              ; if resourcefs changed get the new ptr
d273 4
a276 4
        TEQ     R1, # Service_ResourceFSStarted
        TEQNE   R1, # Service_ResourceFSDying
        TEQNE   R1, # Service_PostInit
        BNE     %ft20
d278 1
a278 1
        BL      check_resource
d280 4
a283 4
        LDR     R1, pResourceTable              ; if table has vanished then clear the StandardPal bit
        CMP     R1, #0                          ; and set the table to invalid
        BICEQ   R0, R0, # f_TableValid
        STREQ   R0, iFlags
d285 1
a285 1
        EXITS
d289 4
a292 4
        TEQ     R1, # Service_ModeChange
        BICEQ   R0, R0, # f_TableValid          ; mode change, therefore table bad
        TEQ     R1, # Service_SwitchingOutputToSprite
        EOREQ   R0, R0, # f_SwitchInvalid       ; output gone to sprite - maybe invalid
d294 1
a294 1
        STR     R0, iFlags
d296 1
a296 1
        EXITS
d308 2
a309 2
        LDR     WP, [WP]                        ; de-reference the workspace pointer
        TEQP    PC, #SVC_mode                   ;   ensure that IRQ's get re-enabled
d311 3
a313 3
        CMP     R11, #( %90-%00 ) / 4           ; is the index valid for our swi table
        ADDCC   PC, PC, R11, LSL # 2            ;   if it is then despatch
        B       %FT90
d315 1
a315 1
        B       ITable_Calculate
d317 2
a318 2
        ADR     R0, ErrorBlock_NaffSWI
        ORRS    PC, LR, #V_bit                  ; mark that an error occurred
d321 2
a322 2
        ADR     R0, ErrorBlock_BadMODE
        ORRS    PC, LR, #V_bit                  ; mark that an error occurred
d324 2
a325 2
        MakeErrorBlock NaffSWI
        MakeErrorBlock BadMODE
d334 9
a342 9
        LDR     R3, iFlags
        TST     R3, # f_PaletteV                ; is paletteV claimed currently
        EXITS   EQ

        MOV     R0, #PaletteV
        ADR     R1, palVhandler
        MOV     R2, WP
        SWI     XOS_Claim                       ; attempt to claim the palette vector
        ORRVC   R3, R3, # f_PaletteV            ;  if that worked then mark as claimed
d344 1
a344 1
        STR     R3, iFlags
d346 1
a346 1
        EXIT
d352 4
a355 4
        TEQ     R4, # paletteV_Set
        TEQNE   R4, # paletteV_SetDefaultPalette
        TEQNE   R4, # paletteV_BulkWrite
        MOVNES  PC, LR                          ; not a modifying palette operation
d357 1
a357 1
        ENTRY   "WP"
d359 2
a360 2
        TEQ     R4, # paletteV_Set              ; are we writing an entry?
        BNE     %FT01
d362 2
a363 2
        CMP     R1, # 24                        ; is it the border or cursor colour?
        EXITS   GE
d365 3
a367 3
        LDR     LR, iFlags
        BIC     LR, LR, # f_TableValid          ; table is no longer valid
        STR     LR, iFlags
d369 1
a369 1
        EXITS
d376 2
a377 2
ResourceFile    = "Resources:$.Resources.ITable.Tables.8desktop", 0
        ALIGN
d380 1
a380 1
        ENTRY   "r0-r11"
d382 1
a382 1
        Debug1  ,"check_resource"
d384 2
a385 2
        MOV     R0, #0                          ; zero the pointer first
        STR     R0, pResourceTable
d387 4
a390 4
        MOV     R0, # &47                       ; open the file
        ADR     R1, ResourceFile
        SWI     XOS_Find
        EXIT    VS
d392 2
a393 2
        MOVS    R11, R0                         ; save the file handle in R11
        EXITS   EQ                              ; exit if zero (can't open file)
d395 4
a398 4
        MOV     R1, R0                          ; get the fs number
        MOV     R0, # 254
        SWI     XOS_Args
        BVS     %ft99
d400 3
a402 3
        AND     R0, R2, # &FF                   ; is it ResourceFS?
        CMP     R0, # &2E
        BNE     %ft99
d404 3
a406 3
        MOV     R0, # 21                        ; get the internal handle
        SWI     XOS_FSControl
        BVS     %ft99
d408 1
a408 1
        STR     R1, pResourceTable              ; save the direct pointer to the file
d410 1
a410 1
        Debug   ,"pResourceTable",R1
d412 3
a414 3
99      MOV     R0, #0                          ; close the file
        MOV     R1, R11
        SWI     XOS_Find
d416 1
a416 1
        EXITS
d441 1
a441 1
;;      < b14-10 == B >
d443 1
a443 1
;;                                  < b4-0 == R >
d456 3
a458 3
;; in   -
;; out  R0 -> index to 5,5,5 RGB data
;;      R1 -> 5,5,5 RGB data to index table
d463 22
a484 22
        MOV     R0, #-1
        MOV     R1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable            ; read the log2 bits per pixel for this mode
        TEQ     R2, #3                          ;   if this is not 8 bit then exit
        BLNE    err_badmode
        BNE     %FT90

        LDR     R2, iFlags                      ; check to see if table is valid
        TST     R2, # f_SwitchInvalid
        BICNE   R2, R2, # f_TableValid :OR: f_SwitchInvalid
        TST     R2, # f_TableValid
        BLEQ    build_itable                    ; if not valid then build the inverse table

 [ UseResourceTable
        EXIT    VS

        LDR     R2, iFlags                      ; reload flags as they may have changed
        ADR     R0, iPalette555                 ; -> RGB 5,5,5 table ( index => 5,5,5 )
        TST     R2, # f_StandardPal
        LDRNE   R1, pResourceTable              ; if bit is not set
        CMPNE   R1, #0                          ; or resource table is not present
        LDREQ   R1, pInverseTable               ; use the built table
d486 1
a486 1
        Debug   ,"ITable_Calculate",R0,R1,R2
d488 2
a489 2
        ADRVC   R0, iPalette555                 ; -> RGB 5,5,5 table ( index => 5,5,5 )
        LDRVC   R1, pInverseTable               ; -> inverse table (5,5,5 => colour number)
d492 1
a492 1
        EXIT
d506 16
a521 16
        LDR     R0, iDynamicArea
        CMP     R0, # 0                         ; have we already allocated our dynamic area?
        EXITS   NE

        MOV     R0, # 0                         ; = 0 => create dynamic area
        MOV     R1, # -1
        LDR     R2, = da_MinimumSize            ; minimum size (size of inverse table)
        MOV     R3, # -1
        MOV     R4, # ( 1:SHL:7)
        LDR     R5, = da_MaximumSize            ; maximum size (inverse table + distance table)
        MOV     R6, # 0
        MOV     R7, # 0
        ADRL    R8, Title                       ; -> name for dynamic area (Task Manager)
        SWI     XOS_DynamicArea
        STRVC   R1, iDynamicArea
        STRVC   R3, pInverseTable
d523 1
a523 1
        EXIT
d527 7
a533 7
        LDR     R1, iDynamicArea
        TEQ     R1, # 0                         ; has a dynamic area been created
        EXITS   EQ

        MOV     R0, # 1                         ; = 1 => discard dynamic area
        SWI     XOS_DynamicArea
        EXITS
d573 2
a574 2
                ^ ScratchSpace
scratch_palette # 256 * 4
d579 2
a580 2
pITable         RN 0    ;                       ---- always ---
pDistances      RN 1    ;                       ---- always ---
d582 3
a584 3
rDist           RN 2    ; (outerloop)
gDist           RN 3    ; (outerloop)
bDist           RN 4    ; (outerloop)
d586 3
a588 3
rInc            RN 5    ; (outerloop)
gInc            RN 6    ; (outerloop)
bInc            RN 7    ; (outerloop)
d590 2
a591 2
r               RN 8    ;              (r inner loop)
g               RN 9    ;                             (g inner loop)
d593 2
a594 2
b               RN 10   ;                                            (b inner loop)
scratch         RN 10   ; (outer loop)
d596 1
a596 1
iColours        RN 11   ; (outer loop)                  (doubles as return value register)
d602 5
a606 5
        =  0,  3, 6,   9, 12, 15, 19, 22
        = 25, 28, 31, 35, 38, 41, 44, 47
        = 51, 54, 57, 60, 63, 67, 70, 73
        = 76, 79, 83, 86, 89, 92, 95, 99
        ALIGN
d612 1
a612 1
        SWI     XHourglass_On                   ; this could take some time
d616 7
a622 7
        MOV     R0, # -1                        ; read palette for current destination
        MOV     R1, # -1
        LDR     R2, = scratch_palette           ; into this buffer
        LDR     R3, = ?scratch_palette          ;   which is so big
        MOV     R4, # 0
        SWI     XColourTrans_ReadPalette
        BVS     %FT90
d626 4
a629 4
        LDR     R0, = scratch_palette
        ADRL    R1, iPalette555
        LDR     R2, = ?scratch_palette
        MOV     R5, # 1                         ; table has not been modified yet
d632 2
a633 2
        ADRL    R6, StandardPalette             ; standard 8 bit palette
        MOV     R7, # 1                         ; 1 = palette matches standard
d636 7
a642 7
        LDR     R3, [ R0 ], #4                  ; pick up 24 bit palette entry
        AND     R4, R3, #&f8000000              ;   and convert to 5,5,5 RGB
        AND     LR, R3, #&00f80000
        ORR     R4, R4, LR, LSL # 3
        AND     R3, R3, #&0000f800
        ORR     R3, R4, R3, LSL # 6
        MOV     R3, R3, LSR # 17
d644 4
a647 4
        LDR     LR, [ R1 ]
        TEQ     LR, R3                          ; has the colour changed?
        MOVNE   R5, # 0                         ;   yes, so must re-compute the inverse table
        STR     R3, [ R1 ], #4
d650 3
a652 3
        LDR     LR, [ R6 ], #4
        TEQ     LR, R3                          ; is the colour different from the standard
        MOVNE   R7, # 0                         ;   yes, then we can't use the standard table
d654 2
a655 2
        SUBS    R2, R2, # 4
        BGT     %BT10                           ; loop until *ENTIRE* palette converted
d657 1
a657 1
        Debug   ,"build_itable changed",R5
d659 1
a659 1
        CMP     R5, #0                          ; has the palette actually changed?
d661 2
a662 2
        LDRNE   LR, pInverseTable               ;   if not then is there a table presetn
        CMPNE   LR, #0
d664 1
a664 1
        BNE     %FT85                           ;   if so then don't bother re-calculating the colour table
d667 1
a667 1
        Debug   ,"build_itable standard",R7
d669 1
a669 1
        LDR     LR, iFlags
d671 4
a674 4
        CMP     R7, # 0                         ; is it actually the standard palette?
        BICEQ   LR, LR, #f_StandardPal          ;   no - clear flag, store and carry on
        STREQ   LR, iFlags
        BEQ     %FT20
d676 5
a680 5
        ORR     LR, LR, #f_StandardPal          ;   yes - set flag
        LDR     R7, pResourceTable              ;   check if we have the resource table
        CMP     R7, # 0
        ORRNE   LR, LR, # f_TableValid          ;     yes - then table is now valid
        STR     LR, iFlags
d682 1
a682 1
        BNE     %FT90                           ;     and exit, else carry on
d688 2
a689 2
        BL      claim_area                      ; attempt to claim the dynamic area ready to build the table
        BVS     %FT90
d691 9
a699 9
        LDR     R0, iDynamicArea
        MOV     R1, # ?da_iDistanceTable
        SWI     XOS_ChangeDynamicArea           ; expand to contain our distances table
        BVS     %FT90                           ;   if that fails then return

        LDR     R0, pInverseTable
        ASSERT  da_iDistanceTable > 0
        ADD     R0, R0, # da_iDistanceTable     ; -> distance table in dynamic area
        STR     R0, pDistanceTable
d703 2
a704 2
        MOV     R1, # -1                        ; initialise the distances table to -1
        LDR     R2, = ( colourmax * colourmax * colourmax )
d706 3
a708 3
        SUBS    R2, R2, # 1                     ; decrease counter
        STRPL   R1, [ R0 ], #4                  ;   write initial value for distance
        BPL     %BT15                           ;   and loop...
d710 1
a710 1
        MOV     iColours, # 0
d712 2
a713 2
        CMP     iColours, # ?scratch_palette / 4
        BGE     %FT80
d717 2
a718 2
        LDR     LR, = scratch_palette
        LDR     LR, [ LR, iColours, LSL # 2 ]   ; pick up RGB value
d720 30
a749 30
        AND     rDist, LR, #&FF00
        MOV     rDist, rDist, LSR # 8
        MOV     rInc, rDist, LSL # nbits        ; rInc = rDist (r) << nBits
        RSB     rInc, rInc, # xsqr
        MOV     rInc, rInc, LSL # 1             ; rInc = 2 * ( xsqr - ( r << nbits ) )
        SUB     rDist, rDist, # x / 2           ; rDist = r - ( x / 2 )

        AND     gDist, LR, #&FF0000
        MOV     gDist, gDist, LSR # 16
        MOV     gInc, gDist, LSL # nbits        ; gInc = gDist (g) << nbits
        RSB     gInc, gInc, # xsqr
        MOV     gInc, gInc, LSL # 1             ; gInc = 2 * ( xsqr - ( g << nbits ) )
        SUB     gDist, gDist, # x / 2           ; gDist = g - ( x / 2 )

        MOV     bDist, LR, LSR # 24
        MOV     bInc, bDist, LSL # nbits        ; bInc = bDist (b) << nbits
        RSB     bInc, bInc, # xsqr
        MOV     bInc, bInc, LSL # 1             ; bInc = 2 * ( xsqr - ( b << nbits ) )
        SUB     bDist, bDist, # x / 2           ; bDist = b - ( x / 2 )

        MOV     scratch, bDist
        MUL     bDist, scratch, bDist           ; bDist  = ( bDist * bDist )
        MOV     scratch, gDist
        MLA     bDist, scratch, gDist, bDist    ; bDist += ( gDist * gDist )
        MOV     scratch, rDist
        MLA     bDist, scratch, rDist, bDist    ; bDist += ( rDist * rDist )

        ADR     R0, percent_table
        LDRB    R0, [ R0, iColours, LSR # 3 ]
        SWI     XHourglass_Percentage           ; set the hourglass percentage value
d751 1
a751 1
        MOV     b, #0                           ; b = 0
d753 2
a754 2
        LDR     pITable, pInverseTable
        LDR     pDistances, pDistanceTable      ; -> distance table
d757 3
a759 3
        CMP     b, # colourmax                  ; finished the red loop
        ADDGE   iColours, iColours, # 1         ;   iColours += 4
        BGE     %BT20                           ;     and advance to the next colour
d761 2
a762 2
        MOV     gDist, bDist                    ; gDist = bDist
        MOV     g, #0                           ; g = 0
d764 1
a764 1
        Push    "gInc"
d767 2
a768 2
        CMP     g, # colourmax                  ; finished the green loop
        BGE     end_green_loop
d770 2
a771 2
        MOV     rDist, gDist                    ; rDist = gDist
        MOV     r, # 0                          ; r = 0
d773 1
a773 1
        Push    "rInc"
d776 2
a777 2
        CMP     r, # colourmax                  ; blue loop finished?
        BGE     end_red_loop
d779 9
a787 9
        TEQ     iColours, #0                    ; is this colour zero?
        STREQ   rDist, [ pDistances ]
        STREQB  iColours, [ pITable ]
        BEQ     %FT30

        LDR     LR, [ pDistances ]
        CMP     LR, rDist                       ; is it closer to this colour
        STRGT   rDist, [ pDistances ]
        STRGTB  iColours, [ pITable ]
d789 3
a791 3
        ADD     rDist, rDist, rInc              ; rDist += rInc
        ADD     r, r, # 1                       ; r++
        ADD     rInc, rInc, # xsqr * 2          ; rInc += xsqr * 2
d793 2
a794 2
        ADD     pITable, pITable, # 1           ; pITable += 1
        ADD     pDistances, pDistances, # 4     ; pDistances += 4
d796 1
a796 1
        B       red_loop
d799 1
a799 1
        Pull    "rInc"
d801 3
a803 3
        ADD     gDist, gDist, gInc              ; gDist += gInc
        ADD     g, g, # 1                       ; g++
        ADD     gInc, gInc, # xsqr * 2          ; gInc += xsqr * 2
d805 1
a805 1
        B       green_loop
d808 1
a808 1
        Pull    "gInc"
d810 3
a812 3
        ADD     bDist, bDist, bInc              ; bDist += bInc
        ADD     b, b, #1                        ; b++
        ADD     bInc, bInc, # xsqr * 2          ; bInc += xsqr * 2
d814 1
a814 1
        B       blue_loop
d819 3
a821 3
        LDR     R0, iDynamicArea
        LDR     R1, = - ( ?da_iDistanceTable )
        SWI     XOS_ChangeDynamicArea           ; remove distance table from dynamic area
d823 3
a825 3
        LDR     LR, iFlags
        ORR     LR, LR, # f_TableValid          ; table is now valid
        STR     LR, iFlags
d827 4
a830 4
        Push    "R0,PC"
        SWI     XHourglass_Off                  ; remove hourglass
        Pull    "R0,LR"                         ;   preserving error condition around call
        RestoreMODE LR
d832 1
a832 1
        EXIT
d904 1
a904 1
        InsertNDRDebugRoutines
d907 1
a907 1
        END
@


4.1
log
@Initial revision
@
text
@d35 1
a35 1
;
d76 3
d99 5
a103 1

d109 4
a162 1

d195 6
d224 2
d238 5
d245 2
d257 1
a257 1
	BIC	R0, R0, # f_TableValid :OR: f_PaletteV
d264 4
d269 15
a283 1
	BL	claim_vectors			; must claim the vectors again
d286 3
a288 1
10
d290 1
a290 1
	BICEQ	R0, R0, # f_TableValid		; mode change, therefore table bad
d371 47
d476 12
d490 1
d518 1
a518 1
	ADR	R8, Title			; -> name for dynamic area (Task Manager)
a519 1

a607 1

d629 6
a634 1
	MOV	R5, # 0				; table has not been modified yet
d646 1
a646 1
	MOVNE	R5, # 1				;   yes, so must re-compute the inverse table
d649 5
d657 2
d660 25
a684 1
	BEQ	%FT85				;   if not then don't bother re-calculating the colour table
d834 68
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d35 1
a35 1
; 01-Jul-96 0.04 SJM With standard palette it checks for one in resourcefs before creating.
a75 3
		GBLL	UseResourceTable
UseResourceTable	SETL	true

d96 1
a96 5
 [ UseResourceTable
f_StandardPal	 * &00000008			; = 1 => The current palette is the standard one
 |
f_StandardPal	 * &00000000
 ]
a101 4
 [ UseResourceTable
pResourceTable	# 4
 ]

d152 1
a184 6
	Debug_Open	pipe:itable

 [ UseResourceTable :LAND: {FALSE}
 	BL	check_resource			; deliberately don't check error return
 ]

a207 2
	Debug_Close

a219 5
 [ UseResourceTable
	TEQNE	R1, # Service_ResourceFSStarted
	TEQNE	R1, # Service_ResourceFSDying
	TEQNE   R1, # Service_PostInit
 ]
a221 2
;	Debug	,"Service",R1

d232 1
a232 1
	BIC	R0, R0, # f_TableValid :OR: f_PaletteV :OR: f_StandardPal
d239 1
a239 3
 [ UseResourceTable :LAND: {FALSE}
	STR	R0, pResourceTable
 ]
d243 1
a243 19

10						; if resourcefs changed get the new ptr
 [ UseResourceTable
	TEQ	R1, # Service_ResourceFSStarted
	TEQNE	R1, # Service_ResourceFSDying
	TEQNE   R1, # Service_PostInit
	BNE	%ft20

	BL	check_resource

	LDR	R1, pResourceTable		; if table has vanished then clear the StandardPal bit
	CMP	R1, #0				; and set the table to invalid
	BICEQ	R0, R0, # f_TableValid
	STREQ	R0, iFlags

	EXITS

20
 ]
d245 1
a245 1
	BICEQ	R0, R0, # f_TableValid 		; mode change, therefore table bad
a325 47
;;-----------------------------------------------------------------------------
;;
;; Check on the resource file presence

 [ UseResourceTable
ResourceFile	= "Resources:$.Resources.ITable.Tables.8desktop", 0
	ALIGN

check_resource
	ENTRY	"r0-r11"

	Debug1	,"check_resource"

	MOV	R0, #0				; zero the pointer first
	STR	R0, pResourceTable

	MOV	R0, # &47			; open the file
	ADR	R1, ResourceFile
	SWI	XOS_Find
	EXIT	VS

	MOVS	R11, R0				; save the file handle in R11
	EXITS	EQ				; exit if zero (can't open file)

	MOV	R1, R0				; get the fs number
	MOV	R0, # 254
	SWI	XOS_Args
	BVS	%ft99

	AND	R0, R2, # &FF			; is it ResourceFS?
	CMP	R0, # &2E
	BNE	%ft99

	MOV	R0, # 21			; get the internal handle
	SWI	XOS_FSControl
	BVS	%ft99

	STR	R1, pResourceTable		; save the direct pointer to the file

	Debug	,"pResourceTable",R1

99	MOV	R0, #0				; close the file
	MOV	R1, R11
	SWI	XOS_Find

	EXITS
 ]
a383 12
 [ UseResourceTable
 	EXIT	VS

	LDR	R2, iFlags			; reload flags as they may have changed
	ADR	R0, iPalette555			; -> RGB 5,5,5 table ( index => 5,5,5 )
	TST	R2, # f_StandardPal
	LDRNE	R1, pResourceTable		; if bit is not set
	CMPNE	R1, #0				; or resource table is not present
	LDREQ	R1, pInverseTable		; use the built table

	Debug	,"ITable_Calculate",R0,R1,R2
 |
a385 1
 ]
d413 1
a413 1
	ADRL	R8, Title			; -> name for dynamic area (Task Manager)
d415 1
d504 1
d526 1
a526 6
	MOV	R5, # 1				; table has not been modified yet

 [ UseResourceTable
	ADRL	R6, StandardPalette		; standard 8 bit palette
	MOV	R7, # 1				; 1 = palette matches standard
 ]
d538 1
a538 1
	MOVNE	R5, # 0				;   yes, so must re-compute the inverse table
a540 5
 [ UseResourceTable
	LDR	LR, [ R6 ], #4
	TEQ	LR, R3				; is the colour different from the standard
	MOVNE	R7, # 0				;   yes, then we can't use the standard table
 ]
a543 2
	Debug	,"build_itable changed",R5

d545 1
a545 25
 [ UseResourceTable
	LDRNE	LR, pInverseTable		;   if not then is there a table presetn
	CMPNE	LR, #0
 ]
	BNE	%FT85				;   if so then don't bother re-calculating the colour table

 [ UseResourceTable
	Debug	,"build_itable standard",R7

	LDR	LR, iFlags

	CMP	R7, # 0				; is it actually the standard palette?
	BICEQ	LR, LR, #f_StandardPal		;   no - clear flag, store and carry on
	STREQ	LR, iFlags
	BEQ	%FT20

	ORR	LR, LR, #f_StandardPal		;   yes - set flag
	LDR	R7, pResourceTable		;   check if we have the resource table
	CMP	R7, # 0
	ORRNE	LR, LR, # f_TableValid		;     yes - then table is now valid
	STR	LR, iFlags

	BNE	%FT90				;     and exit, else carry on
20
 ]
a694 68
 [ UseResourceTable

StandardPalette
    DCD     &0,&842,&1084,&18C6
    DCD     &8,&84A,&108C,&18CE
    DCD     &2000,&2842,&3084,&38C6
    DCD     &2008,&284A,&308C,&38CE
    DCD     &11,&853,&1095,&18D7
    DCD     &19,&85B,&109D,&18DF
    DCD     &2011,&2853,&3095,&38D7
    DCD     &2019,&285B,&309D,&38DF
    DCD     &100,&942,&1184,&19C6
    DCD     &108,&94A,&118C,&19CE
    DCD     &2100,&2942,&3184,&39C6
    DCD     &2108,&294A,&318C,&39CE
    DCD     &111,&953,&1195,&19D7
    DCD     &119,&95B,&119D,&19DF
    DCD     &2111,&2953,&3195,&39D7
    DCD     &2119,&295B,&319D,&39DF
    DCD     &220,&A62,&12A4,&1AE6
    DCD     &228,&A6A,&12AC,&1AEE
    DCD     &2220,&2A62,&32A4,&3AE6
    DCD     &2228,&2A6A,&32AC,&3AEE
    DCD     &231,&A73,&12B5,&1AF7
    DCD     &239,&A7B,&12BD,&1AFF
    DCD     &2231,&2A73,&32B5,&3AF7
    DCD     &2239,&2A7B,&32BD,&3AFF
    DCD     &320,&B62,&13A4,&1BE6
    DCD     &328,&B6A,&13AC,&1BEE
    DCD     &2320,&2B62,&33A4,&3BE6
    DCD     &2328,&2B6A,&33AC,&3BEE
    DCD     &331,&B73,&13B5,&1BF7
    DCD     &339,&B7B,&13BD,&1BFF
    DCD     &2331,&2B73,&33B5,&3BF7
    DCD     &2339,&2B7B,&33BD,&3BFF
    DCD     &4400,&4C42,&5484,&5CC6
    DCD     &4408,&4C4A,&548C,&5CCE
    DCD     &6400,&6C42,&7484,&7CC6
    DCD     &6408,&6C4A,&748C,&7CCE
    DCD     &4411,&4C53,&5495,&5CD7
    DCD     &4419,&4C5B,&549D,&5CDF
    DCD     &6411,&6C53,&7495,&7CD7
    DCD     &6419,&6C5B,&749D,&7CDF
    DCD     &4500,&4D42,&5584,&5DC6
    DCD     &4508,&4D4A,&558C,&5DCE
    DCD     &6500,&6D42,&7584,&7DC6
    DCD     &6508,&6D4A,&758C,&7DCE
    DCD     &4511,&4D53,&5595,&5DD7
    DCD     &4519,&4D5B,&559D,&5DDF
    DCD     &6511,&6D53,&7595,&7DD7
    DCD     &6519,&6D5B,&759D,&7DDF
    DCD     &4620,&4E62,&56A4,&5EE6
    DCD     &4628,&4E6A,&56AC,&5EEE
    DCD     &6620,&6E62,&76A4,&7EE6
    DCD     &6628,&6E6A,&76AC,&7EEE
    DCD     &4631,&4E73,&56B5,&5EF7
    DCD     &4639,&4E7B,&56BD,&5EFF
    DCD     &6631,&6E73,&76B5,&7EF7
    DCD     &6639,&6E7B,&76BD,&7EFF
    DCD     &4720,&4F62,&57A4,&5FE6
    DCD     &4728,&4F6A,&57AC,&5FEE
    DCD     &6720,&6F62,&77A4,&7FE6
    DCD     &6728,&6F6A,&77AC,&7FEE
    DCD     &4731,&4F73,&57B5,&5FF7
    DCD     &4739,&4F7B,&57BD,&5FFF
    DCD     &6731,&6F73,&77B5,&7FF7
    DCD     &6739,&6F7B,&77BD,&7FFF
 ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d35 1
a35 1
; 01-Jul-96 0.04 SJM With standard palette it checks for one in resourcefs before creating.
a75 3
		GBLL	UseResourceTable
UseResourceTable	SETL	true

d96 1
a96 5
 [ UseResourceTable
f_StandardPal	 * &00000008			; = 1 => The current palette is the standard one
 |
f_StandardPal	 * &00000000
 ]
a101 4
 [ UseResourceTable
pResourceTable	# 4
 ]

d152 1
a184 6
	Debug_Open	pipe:itable

 [ UseResourceTable :LAND: {FALSE}
 	BL	check_resource			; deliberately don't check error return
 ]

a207 2
	Debug_Close

a219 5
 [ UseResourceTable
	TEQNE	R1, # Service_ResourceFSStarted
	TEQNE	R1, # Service_ResourceFSDying
	TEQNE   R1, # Service_PostInit
 ]
a221 2
;	Debug	,"Service",R1

d232 1
a232 1
	BIC	R0, R0, # f_TableValid :OR: f_PaletteV :OR: f_StandardPal
d239 1
a239 3
 [ UseResourceTable :LAND: {FALSE}
	STR	R0, pResourceTable
 ]
d243 1
a243 19

10						; if resourcefs changed get the new ptr
 [ UseResourceTable
	TEQ	R1, # Service_ResourceFSStarted
	TEQNE	R1, # Service_ResourceFSDying
	TEQNE   R1, # Service_PostInit
	BNE	%ft20

	BL	check_resource

	LDR	R1, pResourceTable		; if table has vanished then clear the StandardPal bit
	CMP	R1, #0				; and set the table to invalid
	BICEQ	R0, R0, # f_TableValid
	STREQ	R0, iFlags

	EXITS

20
 ]
d245 1
a245 1
	BICEQ	R0, R0, # f_TableValid 		; mode change, therefore table bad
a325 47
;;-----------------------------------------------------------------------------
;;
;; Check on the resource file presence

 [ UseResourceTable
ResourceFile	= "Resources:$.Resources.ITable.Tables.8desktop", 0
	ALIGN

check_resource
	ENTRY	"r0-r11"

	Debug1	,"check_resource"

	MOV	R0, #0				; zero the pointer first
	STR	R0, pResourceTable

	MOV	R0, # &47			; open the file
	ADR	R1, ResourceFile
	SWI	XOS_Find
	EXIT	VS

	MOVS	R11, R0				; save the file handle in R11
	EXITS	EQ				; exit if zero (can't open file)

	MOV	R1, R0				; get the fs number
	MOV	R0, # 254
	SWI	XOS_Args
	BVS	%ft99

	AND	R0, R2, # &FF			; is it ResourceFS?
	CMP	R0, # &2E
	BNE	%ft99

	MOV	R0, # 21			; get the internal handle
	SWI	XOS_FSControl
	BVS	%ft99

	STR	R1, pResourceTable		; save the direct pointer to the file

	Debug	,"pResourceTable",R1

99	MOV	R0, #0				; close the file
	MOV	R1, R11
	SWI	XOS_Find

	EXITS
 ]
a383 12
 [ UseResourceTable
 	EXIT	VS

	LDR	R2, iFlags			; reload flags as they may have changed
	ADR	R0, iPalette555			; -> RGB 5,5,5 table ( index => 5,5,5 )
	TST	R2, # f_StandardPal
	LDRNE	R1, pResourceTable		; if bit is not set
	CMPNE	R1, #0				; or resource table is not present
	LDREQ	R1, pInverseTable		; use the built table

	Debug	,"ITable_Calculate",R0,R1,R2
 |
a385 1
 ]
d413 1
a413 1
	ADRL	R8, Title			; -> name for dynamic area (Task Manager)
d415 1
d504 1
d526 1
a526 6
	MOV	R5, # 1				; table has not been modified yet

 [ UseResourceTable
	ADRL	R6, StandardPalette		; standard 8 bit palette
	MOV	R7, # 1				; 1 = palette matches standard
 ]
d538 1
a538 1
	MOVNE	R5, # 0				;   yes, so must re-compute the inverse table
a540 5
 [ UseResourceTable
	LDR	LR, [ R6 ], #4
	TEQ	LR, R3				; is the colour different from the standard
	MOVNE	R7, # 0				;   yes, then we can't use the standard table
 ]
a543 2
	Debug	,"build_itable changed",R5

d545 1
a545 25
 [ UseResourceTable
	LDRNE	LR, pInverseTable		;   if not then is there a table presetn
	CMPNE	LR, #0
 ]
	BNE	%FT85				;   if so then don't bother re-calculating the colour table

 [ UseResourceTable
	Debug	,"build_itable standard",R7

	LDR	LR, iFlags

	CMP	R7, # 0				; is it actually the standard palette?
	BICEQ	LR, LR, #f_StandardPal		;   no - clear flag, store and carry on
	STREQ	LR, iFlags
	BEQ	%FT20

	ORR	LR, LR, #f_StandardPal		;   yes - set flag
	LDR	R7, pResourceTable		;   check if we have the resource table
	CMP	R7, # 0
	ORRNE	LR, LR, # f_TableValid		;     yes - then table is now valid
	STR	LR, iFlags

	BNE	%FT90				;     and exit, else carry on
20
 ]
a694 68
 [ UseResourceTable

StandardPalette
    DCD     &0,&842,&1084,&18C6
    DCD     &8,&84A,&108C,&18CE
    DCD     &2000,&2842,&3084,&38C6
    DCD     &2008,&284A,&308C,&38CE
    DCD     &11,&853,&1095,&18D7
    DCD     &19,&85B,&109D,&18DF
    DCD     &2011,&2853,&3095,&38D7
    DCD     &2019,&285B,&309D,&38DF
    DCD     &100,&942,&1184,&19C6
    DCD     &108,&94A,&118C,&19CE
    DCD     &2100,&2942,&3184,&39C6
    DCD     &2108,&294A,&318C,&39CE
    DCD     &111,&953,&1195,&19D7
    DCD     &119,&95B,&119D,&19DF
    DCD     &2111,&2953,&3195,&39D7
    DCD     &2119,&295B,&319D,&39DF
    DCD     &220,&A62,&12A4,&1AE6
    DCD     &228,&A6A,&12AC,&1AEE
    DCD     &2220,&2A62,&32A4,&3AE6
    DCD     &2228,&2A6A,&32AC,&3AEE
    DCD     &231,&A73,&12B5,&1AF7
    DCD     &239,&A7B,&12BD,&1AFF
    DCD     &2231,&2A73,&32B5,&3AF7
    DCD     &2239,&2A7B,&32BD,&3AFF
    DCD     &320,&B62,&13A4,&1BE6
    DCD     &328,&B6A,&13AC,&1BEE
    DCD     &2320,&2B62,&33A4,&3BE6
    DCD     &2328,&2B6A,&33AC,&3BEE
    DCD     &331,&B73,&13B5,&1BF7
    DCD     &339,&B7B,&13BD,&1BFF
    DCD     &2331,&2B73,&33B5,&3BF7
    DCD     &2339,&2B7B,&33BD,&3BFF
    DCD     &4400,&4C42,&5484,&5CC6
    DCD     &4408,&4C4A,&548C,&5CCE
    DCD     &6400,&6C42,&7484,&7CC6
    DCD     &6408,&6C4A,&748C,&7CCE
    DCD     &4411,&4C53,&5495,&5CD7
    DCD     &4419,&4C5B,&549D,&5CDF
    DCD     &6411,&6C53,&7495,&7CD7
    DCD     &6419,&6C5B,&749D,&7CDF
    DCD     &4500,&4D42,&5584,&5DC6
    DCD     &4508,&4D4A,&558C,&5DCE
    DCD     &6500,&6D42,&7584,&7DC6
    DCD     &6508,&6D4A,&758C,&7DCE
    DCD     &4511,&4D53,&5595,&5DD7
    DCD     &4519,&4D5B,&559D,&5DDF
    DCD     &6511,&6D53,&7595,&7DD7
    DCD     &6519,&6D5B,&759D,&7DDF
    DCD     &4620,&4E62,&56A4,&5EE6
    DCD     &4628,&4E6A,&56AC,&5EEE
    DCD     &6620,&6E62,&76A4,&7EE6
    DCD     &6628,&6E6A,&76AC,&7EEE
    DCD     &4631,&4E73,&56B5,&5EF7
    DCD     &4639,&4E7B,&56BD,&5EFF
    DCD     &6631,&6E73,&76B5,&7EF7
    DCD     &6639,&6E7B,&76BD,&7EFF
    DCD     &4720,&4F62,&57A4,&5FE6
    DCD     &4728,&4F6A,&57AC,&5FEE
    DCD     &6720,&6F62,&77A4,&7FE6
    DCD     &6728,&6F6A,&77AC,&7FEE
    DCD     &4731,&4F73,&57B5,&5FF7
    DCD     &4739,&4F7B,&57BD,&5FFF
    DCD     &6731,&6F73,&77B5,&7FF7
    DCD     &6739,&6F7B,&77BD,&7FFF
 ]
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@

head	4.17;
access;
symbols
	Colours-1_95:4.17
	Colours-1_94:4.17
	Colours-1_93:4.16
	Colours-1_92:4.16
	Colours-1_91:4.15
	Colours-1_90:4.14
	Colours-1_89:4.13
	Colours-1_88:4.12
	Colours-1_87:4.11
	Colours-1_86:4.11
	Colours-1_85:4.10
	Colours-1_84:4.9
	Colours-1_83:4.9
	Colours-1_82:4.9
	Colours-1_81:4.9
	Colours-1_80:4.9
	Colours-1_79:4.9
	Colours-1_78:4.8
	Colours-1_77:4.8
	RO_5_07:4.6
	Colours-1_76:4.6
	Colours-1_75:4.6
	Colours-1_74:4.5
	Colours-1_73:4.5
	Colours-1_72:4.5
	dellis_autobuild_BaseSW:4.5
	Colours-1_71:4.5
	Colours-1_70:4.5
	Colours-1_69:4.4
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.6
	Colours-1_68:4.3
	Colours-1_67:4.3
	Ursula_merge:4.2.2.1
	nturton_Colours-1_65:4.2
	dcotton_colours_MPTInitialBuild:4.1.7.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.17
date	2016.05.08.17.31.21;	author jlee;	state Exp;
branches;
next	4.16;
commitid	d1ySJ33i6bBREH5z;

4.16
date	2015.11.02.22.39.36;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	2GUtIYhSqFQfpzHy;

4.15
date	2015.01.16.00.50.07;	author jlee;	state Exp;
branches;
next	4.14;
commitid	X83cRl6g8Bi0ub6y;

4.14
date	2014.03.09.16.03.32;	author jlee;	state Exp;
branches;
next	4.13;
commitid	WOmdzPKUoPn7B2sx;

4.13
date	2014.03.04.20.36.33;	author jlee;	state Exp;
branches;
next	4.12;
commitid	WrPp3rX1ZKdIgqrx;

4.12
date	2014.02.27.23.15.44;	author jlee;	state Exp;
branches;
next	4.11;
commitid	KBVViyk78fRijNqx;

4.11
date	2013.08.06.23.49.21;	author jlee;	state Exp;
branches;
next	4.10;
commitid	wewI5Vx1d9Rn5s0x;

4.10
date	2013.02.11.08.14.40;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	fsgIEEtgergszKDw;

4.9
date	2011.11.26.13.11.53;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	WkHYcZXpLKK5sQIv;

4.8
date	2009.06.16.00.23.28;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2009.06.11.21.53.03;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2001.05.14.15.16.01;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.08.04.17.15.49;	author jfletche;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.12.12.34.34;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.08.05.09.51.59;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.44.32;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.42.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	98.04.15.07.03.36;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.42.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.08.22;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.48.13;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.11.10;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.17
log
@Avoid unnecessary remainder calculations
Detail:
  s/Commons, s/DevicePal, s/Dither, s/FontColour - Avoid unnecessary remainder calculations in DivRem macro
  s/Header - Remove unused Divide macro
Admin:
  Tested on Cortex-A15


Version 1.94. Tagged as 'Colours-1_94'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Header

; ******************************
; *** CHANGES LIST / HISTORY ***
; ******************************
;
; 18-Sep-91 0.96 DDV Bug fix: When calling a buildcolours with R0 <>-1 and R1 =-1 then things act differently
; -------------------------------- RISC OS 3.00 release version ---------------------------
; 22-Sep-91      DDV Fixed the non-internationalised version to use correct Bad SWI error string
; 22-Sep-91 0.97 DDV Bug fix: Modifying error loadings does not always invalidate cache, ie. when reading
; 16-Oct-91      DDV Added ColourTrans_SelectTable with R4 =0 returns size of table generated
; 17-Oct-91      DDV Improved matching in ReturnFontColours (speed up aswell)
; 17-Oct-91      DDV Read/Write error loadings for desktop saving
; 17-Oct-91 0.98 DDV ColourTrans_WriteLoadingsToFile SWI added
; 21-Oct-91      DDV File debugging option added
; 21-Oct-91      DDV Luminance matching replaced by error comparison
; 21-Oct-91 0.99 DDV Removed bonus push in middle of return font colours
;  1-Nov-91      DDV Bug fix: If used on old Font Manager falls back to old method of setting colours
;  2-Nov-91      DDV Fixed some more internationalisation messages for compiling the RISC OS 2.00 version
;  2-Nov-91 1.00 DDV Bug fix: Can always save calibration even if default
; 30-Nov-91      DDV Implement ColourTrans_SetTextColour and SetOppTextColour
; 30-Nov-91 1.01 DDV Added set text colour bit to ColourTrans_SetColour
;  8-Jan-92 1.02 DDV Added support for OS_SetColour gives better ECF handling for foreground / background
; 13-Jan-92      DDV Added the concept of a transfer function to remap the R,G and B on select table calls
; 14-Jan-92      DDV Added ColourTrans_ProcessTable
; 14-Jan-92      DDV Bug fix: Bogus calling of transfer function
; 15-Jan-92 1.03 DDV Changed ColourTrans_ProcessTable to ColourTrans_GenerateTable
; 17-Feb-92 1.04 DDV Bug fix: RISC OS 2.00 code for SetFontColours does not corrupt R3
; 26-Mar-92 1.05 DDV Bug fix: more choosy in the way it selects the colour matching routine.
; 27-Mar-92 1.06 DDV No change - just checking into source filer properly!
; 15-Apr-92 1.07 DDV Bug fix: Font handle -1 = 0; cures bug in RISCOS_Lib
; -------------------------------- RISC OS 3.10 release version ---------------------------
; 23-Jul-92 1.08 DDV Bug fix to SelectTable to yeild colour colours
; --------------------------------- RISC OS 3.10 extra release ----------------------------
;  4-Jun-92      DDV Uses OS_SetColour rather than VDU sequences to change colour
;  6-Jun-92      DDV Changed to colour matching to work in 16 bits per pixel modes
;  6-Jun-92      DDV Build colours no longer attempts to generate a table for 16 bit per pixel modes
;  6-Jun-92      DDV ColourTrans_SelectTable generates a sensible table for 16 and 32 bit per pixel modes
; 15-Jul-92      DDV Dithering at 16 bit-per-pixel implemented
; 16-Jul-92      DDV Abused the cache structure to allow for bit colour numbers / colour words
; 17-Jul-92      DDV Recoded SetGCOL for new depth modes, more sensible about reading palette etc...
; 17-Jul-92      DDV Removed MiscOp to return pattern it was useless anyway
; 17-Jul-92      DDV Removed major bottle neck from 16/32 bit modes, now uses cached routine pointers
; 17-Jul-92      DDV Sorted out support for 256 entry CLUT modes
; 23-Jul-92      DDV Backwards compatibility hack introduced, generate 8 bit-per-pixel tables for deep modes
;  3-Aug-92      DDV Changed that backwards compatibilty hack to return GCOL values, not colour numbers
;  3-Aug-92      DDV ReturnGCOLTable now a service of SelectTable
; 10-Aug-92      DDV Error returned on read / write palette in a depth of mode >= 16 bit per pixel
;  7-Sep-92 1.09 DDV Implemented VIDC20 version of 16 bit-per-pixel handling
;
;-----------------------------------------------------------------------------
; 19-Nov-92 1.08 AMG Recreate DDV's original bug fix for 1.08
; 27-Nov-92      AMG/DDV Fix for dithering with supremacy bit set
; 14-Dec-92 1.09 amg Build non-development version with above fix
;  3-Jan-93      DDV Integeration of Tony's new calibration code finished
;  3-Jan-93      DDV Fall back to old code if old style table / commands issued - wowzer!
;  3-Jan-93      DDV Added ColourTrans_MiscOp (2) to return calibration table type
;  3-Jan-93      DDV Fixed exactly where calibration is applied - always when matching a colour
;
;(amg 16/3/93 merge divergent sources to bring the new calibration code into the Medusa sources)
; 16-Mar-93 1.20 amg Build development version, so I know which code is where!!
; 17-Mar-93      amg Introduce familiarity with new sprite mode words and
;                    pointers to mode selectors.
; 29-Mar-93      amg Select/GenerateTable don't generate a table for 16/32 to 16/32 (any
;                    combination). Table generation for 16/32 down to 8 or below still to be
;                    done.
; 29-Apr-93      amg Complete addition of 32K table generation for 16/32 to 8/lower bpp.
;  4-May-93 1.21 amg new release for return of sources to source filer
; 29-Jul-93 1.22 amg Stop corrupting R7 in Set[Opp]Gcol
; 10-Aug-93 1.23 amg Incorporate fixes from Tony Cheal to code added in 1.09
;                    Add flag to include kludges to get around Green bugs
;                    Fix bug affecting 8bpp non-full CLUT modes
; 20-Aug-93 1.24 amg Add another TCheal bug fix
; 24-Aug-93 1.25 amg Fix another transcription bug in the TCheal code
; 26-Oct-93 1.50 amg Kick the version number up to 1.50 to make space for CC ColourCard
;                    versions. Fix MED-00294. Fix MED-00288. Make bit 4 on R5 to Select/
;                    GenerateTable work. Fix bug MED-00044 (32K table routines call
;                    invalidate cache).
; 02-Nov-93 1.51 amg Fix bug MED-00743 - ReturnFontColours not returning consistent R2
; 04-Nov-93 1.52 amg Fix bug MED-00838 - Setting bit 4 of R5 on Sel/Gen table
;                    still returned bytes - historical bug - using input l2bpp
;                    instead of output l2bpp to decide table width.
; 05-Nov-93 1.53 amg Fix bug with selecttable R2=0 calls
; 06-Nov-93 1.54 amg Fix a historical bug with R0=mode, R1=-1 selecttable calls
; 10-Nov-93 1.55 amg (another day, another ColourTrans). Fix two old bugs, both contributing to
;                    ReturnGCOL sometimes returning Colour numbers instead of GCOL numbers
;                    in 8bpp modes.
; 02-Dec-93 1.56 amg Fix ReturnGCOLForMode - was returning colour numbers when it should
;                    have returned GCOLs.
; 06-Dec-93 1.57 amg No code changes, but added lots more systematic debugging facilities
;                    in readiness for deciding about sorting out what ReturnGCOL etc should
;                    be doing in 16/32bpp. New version number needed so I could lock out
;                    the sources. New debugging switches: input1, input2, output, showswis.
;                    A couple of ADRs become ADRLs when these switches are turned on.
; 07-Jan-94 1.58 amg Fix bug MED-01821. 32K table routine calls the InvalidateCache routine
;                    as a SWI to get R12 set up right.
;                    Also add some early termination tweaks in the routine core having
;                    spotted a way to use a free register.
; 28-Jan-94 1.59 amg Fix bug MED-02212 - ReturnGCOLForMode was failing to give Bad Mode error.
;                    Fix BadDepth error message - using wrong macro to make the error block,
;                    and check for others.
; 02-Feb-94 1.60 amg Fix bug MED-0???? - ColourTrans refuses to die if it has 32K tables in
;                    the rma. Flag 'immortal' controls this.
; 16-Feb-94 1.61 amg Add MED-02882 fixes to memory usage by 32K routines
; 23-Feb-94 1.62 amg Add MED-03007 fix to MED-2882 fix - corruption of R9 in one of the
;                    relocated code sections
; 12-May-99 1.69 KJB 32-bit compatible.

                GET     hdr:ListOpts
                GET     hdr:Macros
                GET     hdr:System
                GET     hdr:FSNumbers
                GET     hdr:ModHand
                GET     hdr:NewErrors
                GET     hdr:VduExt
                GET     hdr:Services
                GET     hdr:Font
                GET     hdr:Sprite
                GET     hdr:PublicWS
                GET     hdr:ExtraLong
                GET     hdr:Proc
                GET     hdr:MsgTrans
                GET     hdr:DDVMacros
                GET     hdr:PaletteV
                GET     hdr:ColourTran
                GET     hdr:Symbols
                GET     hdr:HostFS
                GET     hdr:variables
                GET     hdr:HighFSI
                GET     hdr:FileTypes
                GET     hdr:Squash

                ;Debugging SelectTable with older versions of these macros which
                ;call OS_CLI and hence corrupt scratchspace can cause 'interesting'
                ;side effects....

                GBLL    debug_noscratchspace
debug_noscratchspace SETL {FALSE}
                GET     hdr:NDRDebug

                GBLL    StrongARM
StrongARM       SETL    {TRUE}

                ; True if MUL is slow when given large (or negative) numbers
                ; It seems that ARMv4 (i.e. StrongARM) is the first to have a
                ; decent MUL implementation - ARMv3 and below suffer badly with
                ; large numbers
                GBLL    SlowMultiply
SlowMultiply    SETL    NoARMv4

                GET     VersionASM

                GBLL    debug
                GBLL    hostvdu
                GBLL    file

                GBLL    newpalettestuff
                GBLL    international
                GBLL    callpaletteV
                GBLL    docalibration
                GBLL    fontcache
                GBLL    defaultpalettes
                GBLL    dither
                GBLL    checkluminance
                GBLL    usesetcolour
                GBLL    buginRISCOSLib
                GBLL    newcalibration
                GBLL    work_with_green
                GBLL    immortal

debug           SETL    false
hostvdu         SETL    false
file            SETL    true ;(:LNOT: hostvdu) :LAND: debug
debug_flush     SETL    true

; features

international   SETL    :LNOT: oldos    ; produce internationalised code
callpaletteV    SETL    true            ; call the paletteV routines
docalibration   SETL    true            ; perform calibration when reading the palette
fontcache       SETL    false           ; font colour cacheing
defaultpalettes SETL    false           ; clever palette reading
dither          SETL    true            ; dithering
usesetcolour    SETL    :LNOT: oldos    ; use OS_SetColour to set ECF patterns
buginRISCOSLib  SETL    true            ; fixes handle of -1 passed to SetFontColours
newcalibration  SETL    Module_Version > 109   ; new calibration code in V1.09 and beyond

checkluminance  SETL    Module_Version = 098   ; check using luminance, instead of error calculation
work_with_green SETL    false           ; include kludges to dodge bugs in Wimp/Draw in Green
immortal        SETL    Module_Version >= 160  ; don't die while people are using my 32K tables

                [ work_with_green
usesetcolour    SETL    false
                !       0,"WARNING: Building Green compatible version!"
                ]

; Two kludges are introduced by this switch, both resulting from bugs in Green which
; only manifest themselves when used with newer versions of ColourTrans. In the past
; it has been tolerable to feed a junk sprite area pointer to ColourTrans_SelectTable/
; ColourTrans_GenerateTable. However this pointer must now be valid to allow ColourTrans
; to tell the difference between a pointer to a mode selector and a pointer to a sprite
; area. There are two known culprits in Green:
;
; Wimp: Inadvertently uses 0x8000
; Draw: Uses 256 when it has a sprite with no area.
;
; Secondly, it suppresses the setting of the bits in the help/command table for
; Internationalisation - having these bits set break the module under RO2/3.
;
; Following a FRM decision the first of these has been retained as standard behaviour.

; debugging options

xx              SETD    false           ; misc code
xx2             SETD    false           ; temporary stuff
calibrate       SETD    true            ; debugging calibration
palettes        SETD    false           ; palette reading and writing
fontcolours     SETD    false           ; font colour setting
fontcolours2    SETD    false           ; more conclusive debugging
fontcolours3    SETD    false           ; finally the lowest of the low debugging
buildcolours    SETD    false           ; build colours function
buildcolours2   SETD    false           ; more in-depth debugging of build colours
selecttable     SETD    false           ; processing of select table calls
dither          SETD    false           ; debugging of dither routines
dither2         SETD    false           ; more indepth dithering information
enhanced        SETD    false           ; enhanced graphics modes (16 and 32
                                        ; bit per pixel)
newcalibrate    SETD    true            ; new calibration stuff
ag              SETD    false           ; amg misc debugging - could be
                                        ;   anywhere!
table32K        SETD    true            ; 32K translation tables for Select/GenerateTable
input1          SETD    false           ; terse information on input parameters
input2          SETD    false           ; verbose information on input parameters
output          SETD    false           ; information on returned parameters
showswis        SETD    false           ; details on all SWIs handled

;------------------------------------------------------------------------------
;
; Define workspace
;
;------------------------------------------------------------------------------

; Define structure of cache entries

                        ^ 0

CacheEntry              # 3     ;Check word &00BBGGRR
CacheValid              # 1     ;top byte of first word in cache entry: non-zero implies invalid

CachedColour            # 4     ;Colour number (now 32 bits)
CachedGCOL              # 4     ;As are GCOL values
CachedPattern           # 4*4   ;Pattern block as used for dithering

CachedPatternValid      # 1     ; =-1 if CachedPattern is invalid
CachedSpare             # 3     ; Spare bytes in cache entries. Some get reused for module workspace!

                        ASSERT  (:INDEX: @@)<=32
                        AlignSpace 32

CacheEntrySize          * :INDEX: @@

CacheEntries            * 64    ;Must be power of 2
CacheTotalSize          * CacheEntries *CacheEntrySize


; Workspace hidden in the spare cache entry bytes

                        ASSERT ?CachedSpare = 3
CacheEmpty              * CachedSpare   ; =0 if cache is fully empty, allows us to avoid needless invalidation loops
                        ASSERT ((:INDEX: CachedModeFlags) :AND: 1)=0
CachedModeFlags         * CachedSpare+1 ; cached bits 0-15 of mode flags
CachedL2BPP             * CachedSpare+CacheEntrySize ; cached L2BPP of current mode
CachedL2NColour         * CachedSpare+CacheEntrySize+1 ; cached log2 of (NColour+1)

; Define structure of font colour cache block.

                        ^ 0
FontCol_Link            # 4
FontCol_Back            # 4     ; background colour (&BBGGRR00 + max col offset in bits 0..7)
FontCol_Fore            # 4     ; foreground colour (&BBGGRR00)
FontCol_Data            # 4*16
FontCol_Size            * :INDEX: @@

; Define main workspace layout.

                        ^ 0

Cache                   # CacheTotalSize

Calibration_ptr         # 4     ; -> calibration table for screen
Calibration_pending     # 4     ; *command
Calibration_remaining   # 4     ; *command
                      [ newcalibration
Calibration_newtable    # 4     ; non-zero then new format table (else old style)
                      ]
                        AlignSpace 16

text_buffer12           # 12    ; Whilst writing text
                        AlignSpace 16

PaletteFlags            # 4     ; Flags used when reading palette from area
PaletteAt               # 4     ; Pointer to palette table (=0 if screen)
PaletteCopy             # 4     ; Copy of palette pointer used to see if cache is valid

PaletteCacheStart       # 4     ; Start of cached palette / =0 if not
PaletteCacheEnd         # 4     ; End of palette cache
PaletteBestV            # 4     ; Best routine for this palette to find colour
PaletteWorstV           # 4     ; Worst routine for this palette to find colour

                      [ fontcache
FontColourHead          # 4     ; Pointer to list of font colour blocks
                      ]

ColourErrorLoading      # 4     ; &BlGlRl00

BestColourV             # 4     ; Pointer to best colour routine
WorstColourV            # 4     ; Pointer to worst colour routine
FontColourCodeAt        # 4     ; Pointer to routine to advance the pointers
;;;FontColourCode          # 4*4   ; Four words for self compiling code for font colour caching - not used now

PatternTemp             # 4*8   ; Temporary store for expanding pattern tables into

                      [ international
MessagesBlock           # 16    ; Block used to open messages file
MessagesOpen            # 4     ; When non-zero then messages file is open
                      ]

BuildColoursL2BPP       # 4     ; Log2 value for the previous build colours
TargetL2BPP             # 4     ; Log2 value for dest - used to dimension
                                ; return spacing

grey8bpp_palette        # 4     ; Default 8bpp greyscale palette (black -> white), in ResourceFS cache

                        AlignSpace 16
; These are for the 32K table stuff.
anchor_resourcefs       # 4     ; Initial pointer to chain of ResourceFS palettes
                        AlignSpace 16
anchor_tables           # 4     ; Initial pointer to built/loaded 32K tables
                        AlignSpace 16
temp_palette            # 4     ; Temporary pointer within 32K generation
                        AlignSpace 16
temp_table              # 4     ; Temporary pointer within 32K generation
                        AlignSpace 16
temp_errortable         # 4     ; Temporary pointer within 32K generation
                        AlignSpace 16
temp_gbpb               # 128   ; for gbpb calls and filename expansion
                        [ immortal
persist                 # 4     ; Don't die flag
                        ]

                        AlignSpace 256

CurrentPalette          # 256*4 ; Store for the default palette

ws_required             * :INDEX: @@

; Define some other constants required

DefaultErrorLoading     * &01040200

; Format of new style calibration tables

                        ^ 0
calib_version           # 4     ; Revision of carlibation table ( = 0 then new style )
calib_idealblack        # 4     ; Ideal black for calibration table
calib_idealwhite        # 4     ; Ideal white for calibration table
calib_postprocessSWI    # 4     ; SWI for post processing the colour
calib_tablecount        # 4     ; number of tables (1 or 3)
calib_gammatables       # 0     ; start of the tables

calib_gammasize         * 256

                        ASSERT :INDEX: calib_gammatables = 20

;------------------------------------------------------------------------------
;
; Define some common macros
;
;------------------------------------------------------------------------------

        MACRO                           ; Compile a suitable error block for international versions
$l      MakeEitherErrorBlock $name, $noalign
      [ international
$l      MakeInternatErrorBlock $name, $noalign
      |
$l      MakeErrorBlock $name, $noalign
      ]
        MEND

        MACRO                           ; Jump to best colour routine
$l      GetBestColour $cc
$l      MOV$cc  LR,PC                   ; Setup a return address
        LDR$cc  PC,[WP,#BestColourV]    ; Jump to routine (assumes vector setup)
        MEND

        MACRO                           ; Jump to worst colour routine
$l      GetWorstColour $cc
$l      MOV$cc  LR,PC                   ; Setup a suitable return address
        LDR$cc  PC,[WP,#WorstColourV]   ; Jump to routine (assumes vector setup)
        MEND

        MACRO
$l      BuildColoursForBest
$l
        BL      build_colours           ; Build colour table as required
        STR     R7,[WP,#BestColourV]
        MEND

        MACRO
$l      BuildColoursForWorst
$l
        BL      build_colours           ; Build colour table as required
        STR     R8,[WP,#WorstColourV]
        MEND

        MACRO
$l      BadMODE $cc
      [ international
        addr    R0,ErrorBlock_BadMODE,$cc
      |
        addr    R0,ErrorBlock_NaffMODE,$cc
      ]
        MEND

;------------------------------------------------------------------------------
;
; Define the module header
;
;------------------------------------------------------------------------------

        AREA    |ColourTrans$$Code|, CODE, READONLY, PIC
        ENTRY

ModuleStart
        & 0                             ;not an application
        & Initialise -ModuleStart
        & Die -ModuleStart
        & ServiceCalls -ModuleStart
        & Title -ModuleStart
        & Help -ModuleStart
        & Commands -ModuleStart
        & ColourTransSWI *Module_SWIChunkSize +Module_SWISystemBase
        & SWIs -ModuleStart
        & SWItable -ModuleStart
        & 0                             ;no special decoding
 [ international
        & Filename -ModuleStart
 |
        & 0
 ]
        & ModuleFlags -ModuleStart

Help    = "Colour Selector",9,"$Module_HelpVersion"
      [ oldos
        = " for $whofor"
      ]
      [ debug
        = " Development version"
      ]
        = 0
        ALIGN

ModuleFlags
 [ :LNOT: No32bitCode
        & ModuleFlag_32bit
 |
        & 0
 ]

Commands
        = "ColourTransMapSize",0        ;*ColourTransMapSize
        ALIGN
        & ColourTransMapSize_Code -ModuleStart
        [ work_with_green
        & &00030703
        |
        & &00030703 :OR: International_Help
        ]
        & 0
        & HelpStarCommands -ModuleStart

        = "ColourTransMap",0            ;*ColourTransMap
        ALIGN
        & ColourTransMap_Code -ModuleStart
        [ work_with_green
        & &00FF0001
        |
        & &00FF0001 :OR: International_Help
        ]
        & 0
        & HelpStarCommands -ModuleStart

        = "ColourTransLoadings",0       ;*ColourTransLoadings
        ALIGN
        & ColourTransLoadings_Code -ModuleStart
        [ work_with_green
        & &00030703
        |
        & &00030703 :OR: International_Help
        ]
        & 0
        & HelpStarCommands -ModuleStart

        & 0                             ;end of table

HelpStarCommands
 [ work_with_green
        = "ColourTrans commands are for internal use only",0
 |
 [ international
        = "HCLTINT", 0
 |
        = "ColourTrans commands are for internal use only",0
 ]
 ]

Title
SWItable
        = "ColourTrans", 0
        = "SelectTable", 0
        = "SelectGCOLTable", 0
        = "ReturnGCOL",0
        = "SetGCOL",0
        = "ReturnColourNumber",0
        = "ReturnGCOLForMode",0
        = "ReturnColourNumberForMode",0
        = "ReturnOppGCOL",0
        = "SetOppGCOL",0
        = "ReturnOppColourNumber",0
        = "ReturnOppGCOLForMode",0
        = "ReturnOppColourNumberForMode",0
        = "GCOLToColourNumber",0
        = "ColourNumberToGCOL",0
        = "ReturnFontColours",0
        = "SetFontColours",0
        = "InvalidateCache",0
        = "SetCalibration",0
        = "ReadCalibration",0
        = "ConvertDeviceColour",0
        = "ConvertDevicePalette",0
        = "ConvertRGBToCIE",0
        = "ConvertCIEToRGB",0
        = "WriteCalibrationToFile",0
        = "ConvertRGBToHSV",0
        = "ConvertHSVToRGB",0
        = "ConvertRGBToCMYK",0
        = "ConvertCMYKToRGB",0
        = "ReadPalette",0
        = "WritePalette",0
        = "SetColour",0
        = "MiscOp",0
        = "WriteLoadingsToFile",0
        = "SetTextColour",0
        = "SetOppTextColour",0
        = "GenerateTable",0
        = "",0
        ALIGN

;------------------------------------------------------------------------------
;
; Initalise
;
; Handle the module startup, basicly claim the ColourV ready for calls into the
; module.
;
; in    WP -> workspace of the module
; out   V =1 => R0 -> error block

Initialise ROUT

        Push    "R0-R2,LR"

      [ file
        Debug_Open "<ColourTrans$$Debug>"
      ]

        MOV     R0,#ColourV
        ADRL    R1,ColourVCode
        MOV     R2,WP
        SWI     XOS_Claim               ;Attempt to reclaim the ColourV for SWIs

        STRVS   R0,[SP]
        Pull    "R0-R2,PC"              ;Return any fatal errors

;..............................................................................
;
; validateworkspace
;
; The module has been called, it needs its workspace so we must now attempt to claim
; and reset it.
;
; in    WP -> private word (=0)
;
; out   V =1 => R0 -> error block
;       else,   [Entry WP] -> workspace block
;               WP -> workspace

validateworkspace ROUT
        Push    "R0-R9,LR"

        LDR     LR,[WP]
        CMP     LR,#0                   ;Do I already have the workspace?
        MOVNE   WP,LR
        Pull    "R0-R9,PC",NE           ;Yes so return V will be clear; WP ->Workspace

        MOV     R0,#ModHandReason_Claim
        LDR     R3,=ws_required
        SWI     XOS_Module              ;Attempt to claim the workspace
        STRVS   R0,[SP]
        Pull    "R0-R9,PC",VS           ;Return if it errors; R0 -> error block

        STR     R2,[WP]
        MOV     WP,R2                   ;Setup private word and workspace pointer

	MOV	R0, #-1
	STRB	R0, [WP,#CacheEmpty]	;Force a cache flush

        MOV     R0,#0                   ;Performing default calibration
        [ immortal
        STR     R0,[WP,#persist]        ;We may die
        ]
        STR     R0,[WP,#Calibration_ptr]
        STR     R0,[WP,#Calibration_pending]
        [ newcalibration
        STR     R0,[WP,#Calibration_newtable]
        ]
        STR     R0,[WP,#PaletteAt]      ;Palette currently at screen
        STR     R0,[WP,#PaletteCopy]
        STR     R0,[WP,#PaletteFlags]
        STR     R0,[WP,#BestColourV]    ;Reset the two best and worst colour vectors within workspace
        STR     R0,[WP,#WorstColourV]
      [ fontcache
        STR     R0,[WP,#FontColourHead]
      ]
      [ international
        STR     R0,[WP,#MessagesOpen]
      ]

        ;set up the pointers for 32K tables
        STR     R0,[WP,#anchor_resourcefs]
        STR     R0,[WP,#grey8bpp_palette]

        [ debugtable32K
        ADD     R1,WP,#anchor_resourcefs
        Debug   table32K,"anchor_resourcefs is at",R1
        ]

        STR     R0,[WP,#anchor_tables]

        [ debugtable32K
        ADD     R1,WP,#anchor_tables
        Debug   table32K,"anchor_tables is at",R1
        ]

        STR     R0,[WP,#temp_palette]
        STR     R0,[WP,#temp_table]
        STR     R0,[WP,#temp_errortable]

        LDR     R0,=DefaultErrorLoading ;Setup default error loading
        STR     R0,[WP,#ColourErrorLoading]

        BL      InitCache               ;Reset the cache areas

        Debug   table32K,"Performing initial scan of resourcefs"

        BL      scan_resourcefs

        CLRV
        Pull    "R0-R9,PC"

scan_resourcefs ROUT
        Push    "R0-R7,LR"

        Debug   table32K,"Rebuilding resourcefs structure"

        ; try to build the palette lookup structure
        MOV     R4,#0                   ;Initial offset
10
        MOV     R0,#10
        ADRL    R1,palettedir
        ADD     R2,WP,#temp_gbpb
        MOV     R3,#1
        MOV     R5,#32
        MOV     R6,#0
        SWI     XOS_GBPB
        MOV     R7,R4
        BVS     %FT30

        Debug   table32K,"#entries read:",R3

        CMP     R3,#1
        BNE     %FT30                    ;nothing read

        LDR     R3,[WP,#temp_gbpb+8]     ;length
        Debug   table32K,"File length",R3
        ADD     R3,R3,#cachedtable_palette+16 ; 4 bytes for ROM pointer + 12 bytes extra for name
        MOV     R2,#0
        MOV     R0,#ModHandReason_Claim
        Debug   table32K,"Claiming",R3
        SWI     XOS_Module
        BVS     %FT30
        MOV     R6,R2

        ;link it in to the structure
        LDR     R0,[WP,#anchor_resourcefs]
        TEQ     R0,#0

        STREQ   R2,[WP,#anchor_resourcefs]
        BEQ     %FT20
21
        LDR     R1,[R0,#cachedtable_next] ;fetch the next pointer
        TEQ     R1,#0
        MOVNE   R0,R1
        BNE     %BT21

        STR     R2,[R0,#cachedtable_next]

20      ;now it is linked, fill it
        MOV     R0,#0
        STR     R0,[R2,#cachedtable_next]
        LDR     R3,[WP,#temp_gbpb+8]     ;length
        STR     R3,[R2,#cachedtable_palsize]
        MOV     R3,#32768 ; only 32K colour resfs tables supported atm
        STR     R3,[R2,#cachedtable_tabsize]

        MOV     R0,#12
        ADRL    R4,palettepath
        ADD     R2,R2,#cachedtable_palette
        MOV     R3,#0
        ADD     R1,WP,#temp_gbpb
        ADD     R1,R1,#20
        SWI     XOS_File
        BVS     %FT30

        ADD     R6,R6,#cachedtable_palette

        ; If this was the default 8bpp greyscale palette, remember it so we can use elsewhere
        LDR     R3,[WP,#temp_gbpb+20]
        LDR     R4,grey8bpp_name
        TEQ     R3,R4
        LDREQ   R3,[WP,#temp_gbpb+24]
        LDREQ   R4,grey8bpp_name+4
        BICEQ   R3,R3,#&FF000000
        TEQEQ   R3,R4
        STREQ   R6,[WP,#grey8bpp_palette]

        LDR     R3,[WP,#temp_gbpb+8]     ;length
        ADD     R6,R6,R3

        ;copy the name across
        MOV     R3,#0
        STR     R3,[R6],#4
        LDR     R3,[WP,#temp_gbpb+20]
        STR     R3,[R6],#4
        LDR     R3,[WP,#temp_gbpb+24]
        STR     R3,[R6],#4
        LDR     R3,[WP,#temp_gbpb+28]
        STR     R3,[R6]

        MOV     R4,R7

        B       %BT10

30
        Pull    "R0-R7,PC"

palettedir     = "Resources:$.Resources.Colours.Palettes",0
palettepath    = "Resources:$.Resources.Colours.Palettes.",0
        ALIGN
grey8bpp_name  = "8greys",0,0
        ALIGN

;------------------------------------------------------------------------------
;
; Die
;
; Handle the module die entry.  When recieved we must attempt to tidy up our
; workspace and then return.
;
; in    R10 non-zero if RMReiniting
;       WP -> Workpace block
;
; out   V =1 => R0 -> error block

Die     ROUT

        Push    "LR"

        LDR     R1,[WP]
        TEQ     R1,#0                   ;Do I own any workspace?
        BEQ     %FT10                   ;No, so return

        ; release anything for the 32K tables that still claimed

        [ immortal
        LDR     R2,[R1,#persist]
        TEQ     R2,#0
        MOVNE   WP,R1
        Pull    "LR",NE
        BNE     cannotdie
        ]

        LDR     R2,[R1,#anchor_tables]
        BL      Free32KChain
        MOV     R2,#0
        STR     R2,[R1,#anchor_tables]

        LDR     R2,[R1,#anchor_resourcefs]
        BL      Free32KChain
        MOV     R2,#0
        STR     R2,[R1,#anchor_resourcefs]
        STR     R2,[R1,#grey8bpp_palette]

        LDR     R2,[R1,#temp_palette]
        BL      Free32K
        MOV     R2,#0
        STR     R2,[R1,#temp_palette]

        LDR     R2,[R1,#temp_table]
        BL      Free32K
        MOV     R2,#0
        STR     R2,[R1,#temp_table]

        LDR     R2,[R1,#temp_errortable]
        BL      Free32K
        MOV     R2,#0
        STR     R2,[R1,#temp_errortable]

      [ fontcache
        ADD     R2,R1,#FontColourHead
        BL      FreeChain               ;Release cache of font colours
      ]

        MOVVC   R0,#ModHandReason_Free
        ADDVC   R3,R1,#Calibration_ptr
        BLVC    removeblock             ;Attempt to remove the current calibration tables
        addl    R3,R1,Calibration_pending
        BLVC    removeblock             ;And any pending ones
        Pull    "PC",VS

      [ international

        LDR     R0,[R1,#MessagesOpen]
        TEQ     R0,#0                   ;Is the messages file open yet?
        addl    R0,R1,MessagesBlock,NE
        SWINE   XMessageTrans_CloseFile
      ]
10
        MOV     R0,#ColourV
        ADR     R1,ColourVCode          ;->Routine to trap colour vector calls
        MOV     R2,WP
        SWI     XOS_Release             ;And then remove it from the vector chain

      [ file
        Debug_Close
      ]

        CLRV
        Pull    "PC"

Free32K ROUT
        Push    "LR"
        Debug   table32K,"Freeing",R2

        TEQ     R2,#0
        MOVNE   R0,#ModHandReason_Free
        SWINE   XOS_Module              ;Assumes R0 contains reason code
        Pull    "PC"

Free32KChain ROUT
        Push    "R4,LR"
        Debug   table32K,"Freeing(32k)",R2
10
        TEQ     R2,#0                   ;is this a valid link ?
        Pull    "R4,PC",EQ

        LDR     R4,[R2,#cachedtable_next] ;yes, so see where it goes next
        MOV     R0,#ModHandReason_Free
        SWI     XOS_Module              ;Assumes R0 contains reason code
        MOV     R2,R4                   ;Is next link non-zero ?
        B       %BT10                   ;yes, so go and release it

;..............................................................................
;
; remove block
;
; in    R3 contains address of word block hanging from
;       R10 from init call contains the rmreinit flags
;
; out   V =1 => R0 -> error block
;       else    [R3] updated to contain zero if block released

removeblock ROUT

        Push    "R1,R3,LR"

        LDR     R2,[R3]
        CMP     R2,#0                   ;Is there a block hanging from word?
        Pull    "R1,R3,PC",EQ

        TEQ     R10,#0                  ;Is this an attempt to RMTidy the module?
        BNE     %FT10

        SWI     XOS_Module              ;Assumes R0 contains reason code
        MOVVC   R2,#0
        STRVC   R2,[R3]                 ;Mark as released if worked
        Pull    "R1,R3,PC"
10
      [ immortal
cannotdie
      ]
      [ international
        ADR     R0,ErrorBlock_CantKill
        B       LookupError             ;Complain if unable to kill ColourTrans

        MakeErrorBlock CantKill
      |
        ADR     R0,ErrorBlock_CantKill2
        B       LookupError             ;Complain if unable to kill ColourTrans

        MakeErrorBlock CantKill2
      ]

;-------------------------------------------------------------------------------
;
; Service entry
;
; Process service calls recieved by the module.
;
; in    R1 reason code for call
; out   all should be preserved unless documented

;Ursula format
;
        ASSERT  Service_Reset              < Service_ModeChange
        ASSERT  Service_ModeChange         < Service_ResourceFSStarted
        ASSERT  Service_ResourceFSStarted  < Service_CalibrationChanged
        ASSERT  Service_CalibrationChanged < Service_WimpSaveDesktop
        ASSERT  Service_WimpSaveDesktop    < Service_SwitchingOutputToSprite
;
UServTab
        DCD     0
        DCD     UService - ModuleStart
        DCD     Service_Reset
        DCD     Service_ModeChange
        DCD     Service_ResourceFSStarted
      [ debugcalibrate
        DCD     Service_CalibrationChanged
      ]
        DCD     Service_WimpSaveDesktop
        DCD     Service_SwitchingOutputToSprite
        DCD     0
        DCD     UServTab - ModuleStart
ServiceCalls ROUT
        MOV     r0, r0
UService
      [ debugcalibrate
        TEQ     R1,#Service_CalibrationChanged
        BNE     %FT90                   ;Has the calibration changed

        LDR     WP,[WP]
        Debug   calibrate,"Service_CalibrationChanged recieved"
        MOV     PC,LR
      ]
90
        TEQ     R1,#Service_WimpSaveDesktop
        BEQ     save_desktop_to_file    ;Handle desktop saving

        TEQ     R1,#Service_Reset
        BEQ     Initialise              ;Attempt to get back on the vector after reset

        TEQ     R1,#Service_SwitchingOutputToSprite
        BEQ     output_to_sprite        ;Handle tracking of output to sprites

        TEQ     R1,#Service_ResourceFSStarted
        BEQ     rescan_resourcefs

        TEQ     R1,#Service_ModeChange
        MOVNE   PC,LR

        LDR     WP,[WP]
        TEQ     WP,#0                   ;Any workpsace allocated yet?
        MOVEQ   PC,LR                   ;If not then we must return as cache is invalidated later

        ;also throw away the current collection of 32K tables and release
        ;the space

        STMFD   R13!,{R0-R3,LR}
        LDR     R2,[WP,#anchor_tables]
        BL      Free32KChain
        MOV     R0,#0
        [ immortal
        STR     R0,[WP,#persist]        ;so we can die if told to
        ]
        STR     R0,[WP,#anchor_tables]
        LDMFD   R13!,{R0-R3,LR}

        B       InvalidateCache_Code    ;Yes, so invalidate the cache

rescan_resourcefs
        ; The contents of ResourceFS has changed, which could be because
        ; more palettes and tables have been added - rescan them.

        LDR     WP,[WP]
        TEQ     WP,#0                   ;Any workpsace allocated yet?
        MOVEQ   PC,LR                   ;If not then we must return

        Push    "R0-R4,LR"

        Debug   table32K,"Resourcefs has changed - discarding all cached tables"

        ; release anything for the 32K tables that still claimed
        ; (junk both lists so that anything previously built can be reconsidered
        ; in the light of new palette files)

        MOV     R4,#0
        LDR     R2,[WP,#anchor_resourcefs]
        STR     R4,[WP,#anchor_resourcefs]
        STR     R4,[WP,#grey8bpp_palette]
        BL      Free32KChain

        LDR     R2,[WP,#anchor_tables]
        STR     R4,[WP,#anchor_tables]
        BL      Free32KChain

        BL      scan_resourcefs

        Pull    "R0-R4,PC"

;------------------------------------------------------------------------------
;
; SWI despatching
;
; Handle the despatch of SWIs within the module.  This simply involves calling
; the ColourV so that anyone hanging onto it can recieve the calls.
;
; in    R11 =SWI number minus base
;       WP ->private word
;
; out   V =1 => R0 -> error block

SWIs    ROUT

        WritePSRc SVC_mode, R10         ;Enable IRQs

      [ debugshowswis
        STMFD   R13!,{R11,R12,R14}
        ADRL    R12,SWItable
        ADD     R12,R12,#12              ; Skip "ColourTrans",0 prefix
        TEQ     R11,#0
        BEQ     %FT10
02
        LDRB    R14,[R12],#1
        TEQ     R14,#0
        BNE     %BT02
        SUBS    R11,R11,#1
        BNE     %BT02
10
        DebugS  showswis,"ColourTrans SWI ",R12
        Debug   showswis,"R0-R5",R0,R1,R2,R3,R4,R5
        LDMFD   R13!,{R11,R12,R14}
      ]

        Push    "R8-R9,LR"

        MOV     R8,R11                  ;Get the modol SWI number
        MOV     R9,#ColourV
        SWI     XOS_CallAVector         ;Pass down the vector (number in R9)

       [ :LNOT: No32bitCode
        MRS     R10,CPSR
        TST     R10,#2_11100
        Pull    "R8-R9,PC",NE           ;32-bit return
       ]
        ; 26-bit return
        Pull    "R8-R9,LR"
        MOVVCS  PC,LR
        ORRVSS  PC,LR,#V_bit            ;Return any errors, but preserve other flags

;..............................................................................
;
; ColourVCode
;
; Handle the despatch of events via the ColourV as SWIS within the module, when
; called we may not own any workspace so the workspace pointer needs to be
; validated, also we check to see if we need to invalidate the cache when output
; has been switched away to a sprite
;
; in    R0.. parameters for the call
;       R8 reason code
;       WP -> private word
;       LR -> routine to return to if passing on
;      {LR} routine to return to if claiming
;
; out   V =1 => R0 -> error block
;       as documented

ColourVCode ROUT

        TEQ     R8,#ColourTrans_InvalidateCache -ColourTrans_SelectTable
        TEQNE   R8,#ColourTrans_WriteCalibrationToFile -ColourTrans_SelectTable
        LDREQ   LR,[WP]
        TEQEQ   LR,#0                   ;If not suitable if workspace not owned then return
        Pull    "PC",EQ

        BL      validateworkspace       ;Resolve workspace pointer
        Pull    "PC",VS

        Push    "R0-R1"

        addl    R0,WP,PaletteAt
        LDMIA   R0,{R0,R1}
        TEQ     R0,R1                   ;Have we switched output to a sprite etc?
        BLNE    InvalidateCache_Code

        Pull    "R0-R1,LR"

        CMP     R8,#(%20-%10)/4         ;Within range?
        ADDCC   PC,PC,R8,LSL #2         ;If so then despatch via the table
        B       %20
10
        B       SelectTable_Code
        B       SelectGCOLTable_Code
        B       ReturnGCOL_Code
        B       SetGCOL_Code
        B       ReturnColourNumber_Code
        B       ReturnGCOLForMode_Code
        B       ReturnColourNumberForMode_Code
        B       ReturnOppGCOL_Code
        B       SetOppGCOL_Code
        B       ReturnOppColourNumber_Code
        B       ReturnOppGCOLForMode_Code
        B       ReturnOppColourNumberForMode_Code
        B       GCOLToColourNumber_Code
        B       ColourNumberToGCOL_Code
        B       ReturnFontColours_Code
        B       SetFontColours_Code
        B       InvalidateCache_Code
        B       SetCalibration_Code
        B       ReadCalibration_Code
        B       ConvertDeviceColour_Code
        B       ConvertDevicePalette_Code
        B       ConvertRGBToCIE_Code
        B       ConvertCIEToRGB_Code
        B       WriteCalibrationToFile_Code
        B       ConvertRGBtoHSV_Code
        B       ConvertHSVtoRGB_Code
        B       ConvertRGBtoCMYK_Code
        B       ConvertCMYKtoRGB_Code
        B       ReadPalette_Code
        B       WritePalette_Code
        B       SetColour_Code
        B       MiscOp_Code
        B       WriteLoadingsToFile_Code
        B       SetTextColour_Code
        B       SetOppTextColour_Code
        B       GenerateTable_Code
20
      [ international
        ADR     R0,ErrorBlock_ModuleBadSWI
      |
        ADR     R0,ErrorBlock_NaffSWI
      ]
        B       LookupError                             ;Return invalid call to ColourV

      [ international
        MakeErrorBlock ModuleBadSWI
        MakeEitherErrorBlock BadMODE
      |
        MakeErrorBlock NaffSWI
        MakeEitherErrorBlock NaffMODE
      ]

;------------------------------------------------------------------------------
;
; ColourTrans_InvalidateCache implementation
;
;   Entry: -
;
;   Exit:  V set   => R0 ->Error block
;          V clear => -
;
; Handle the invalidation of the ColourTrans cache.  This should be called
; when output is switched to a sprite and when ever the palette has changed.
;
; The routine will attempt to invalidate the normal colours cache and
; free the chain of blocks containing the font colours.
;
;------------------------------------------------------------------------------

InvalidateCache_Code ROUT
        Debug   input1,"InvalidateCache"
        Debug   input2,"InvalidateCache"
        Push    "R0-R2,LR"

        BL      InitCache               ;Clear the colour cache

      [ fontcache
        ADDVC   R2,R12,#FontColourHead
        BLVC    FreeChain               ;Attempt to release the font colours
      ]

        STRVS   R0,[SP]                 ;Return any errors generated
        Pull    "R0-R2,PC"

;..............................................................................
;
; FreeChain
;
; Attempt to release the list of font colours attached to the word passed in
; at R2.  The routine loops releasing them all and then marks the word addressed
; by R2 as zero on exit.
;
; in    R2 -> head of the chain
; out   V =1 => R0 -> error block
;       else,   chain of blocks in [R2] freed (=0) on exit

      [ fontcache

        ASSERT  FontCol_Link =0

FreeChain ROUT

        EntryS  "R0-R2"

        Debug   xx,"Releasing font colour cache at",R2

        LDR     R1,[R2]                 ;Get pointer to the first block
        NOV     R14,#0
        STR     R14,[R2]                ;Zero the first element of the chain
01
        MOVS    R2,R1
        EXITS   EQ                      ;Return when the end of the chain has been reached

        LDR     R1,[R2]                 ;R1 -> next block
        SWI     XOS_Module
        B       %BT01                   ;Loop back until all released

      ]

;..............................................................................
;
; InitCache
;
; This code will reset the contents of the cache.
;
; in    -
; out   V =1 => R0 -> error block

InitCache ROUT

        Push    "LR"

        MOV     R0,#-1
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ;Attempt to read the current Log2BPP
        STRB    R2,[WP,#CachedL2BPP]

        Debug   xx,"Init cache Log2BPP is",R2

        MOV     R1,#VduExt_ModeFlags
        SWI     XOS_ReadModeVariable    ;Attempt to read the mode flags
        MOVCS   R2,#0
      [ debug
        Debug   xx,"Cache mode flags",R2
      ]
      [ NoARMv4
        STRB    R2,[WP,#CachedModeFlags]
        MOV     R2,R2,LSR #8
        STRB    R2,[WP,#CachedModeFlags+1]
      |
        STRH    R2,[WP,#CachedModeFlags]
      ]


        MOV     R1,#VduExt_NColour
        SWI     XOS_ReadModeVariable    ;Attempt to read NColour
        MOVCS   R2,#0                   ;Is there much point handling errors here?
        ; These code snippets will produce nonsense results for YUV modes
      [ NoARMv5
        MOV     R1,#0
10
        MOVS    R2,R2,LSR #1
        ADDCS   R1,R1,#1
        BCS     %BT10
      |
        CLZ     R1,R2
        RSB     R1,R1,#32
      ]
        STRB    R1,[WP,#CachedL2NColour]
        
        Debug   xx,"Cache L2NColour",R1

        LDR     R0,[WP,#PaletteAt]
        STR     R0,[WP,#PaletteCopy]    ;Mark as source of palette for cached entries

        MOV     R0,#0                   ;Mark as palette not cached
        STR     R0,[WP,#PaletteCacheStart]

        LDRB    R0,[WP,#CacheEmpty]
        CMP     R0,#0                   ;Is the cache currently empty? (clears V!)
        Pull    "PC",EQ

        Debug   xx,"Clearing the cache workspace"

; Loop from end of cache through all entries stonking over them making them
; all clean and tidy

        LDR     R0,=(CacheEntries-1)*CacheEntrySize + CacheValid
        MOV     R1,#-1
50
        STRB    R1,[WP,R0]
        SUB     R0,R0,#CacheValid-CachedPatternValid
        STRB    R1,[WP,R0]
        SUBS    R0,R0,#CacheEntrySize+CachedPatternValid-CacheValid
        BPL     %BT50                   ;Loop back zonking the cache

        MOV     R0,#0
        STRB    R0,[WP,#CacheEmpty]     ;Mark as the cache is empty now

        MOV     R1,#Service_InvalidateCache
        SWI     XOS_ServiceCall         ;Broadcast ignoring errors that cache is now invalid

        Debug   xx,"Cache has been invalidated"

        CLRV
        Pull    "PC"

        LTORG

        GET     Commons.s
        GET     MainSWIs.s
        GET     Cache.s
        GET     FontColour.s

        GetIf   s.Dither, dither
        $GetConditionally

        GET     NewModels.s
        GET     Palettes.s
        GET     MsgCode.s

        GET     FileCal.s
        GET     Calibrate.s
        GET     DevicePal.s

        GetIf   s.DevicePal2, newcalibration
        $GetConditionally

        GET     Enhanced.s
        GET     Tables32K.s

      [ debug
        InsertNDRDebugRoutines
      ]

        END
@


4.16
log
@Correction to help lookup
Broken since version 1.75, ColourTrans' internal commands were trying to use the non internationalised text as the token name to lookup due to a bit of conditional assembly that got reversed.
Spotted by Andrew Conroy.

Version 1.92. Tagged as 'Colours-1_92'
@
text
@a394 7
        MACRO
$l      Divide  $ra,$rb,$rc,$temp,$temp2
$l      SavePSR $temp2
        DivRem  $ra,$rb,$rc,$temp
        RestPSR $temp2,,f               ;Preserve flags around divides
        MEND

@


4.15
log
@Objasm warning fixes: Escape dollar contained in string, fix macro reference
Detail:
  s/Commons - Fix reference to Find256 macro; Find256_Fast was the name I was using during development of this new version
  s/Header - Escape dollar contained in string
Admin:
  Resulting binary unchanged


Version 1.91. Retagged as 'Colours-1_91'
@
text
@d532 2
a534 2
 |
        = "HCLTINT", 0
@


4.14
log
@Use a greyscale palette when screen output is redirected to an alpha mask
Detail:
  s/Header - Update ResourceFS scanning to identify the deafult 8bpp greyscale palette and remember its location
  s/Palettes - When screen output is switching to an alpha mask, instead of trying to use the sprite's palette use the 8bpp greyscale palette instead.
Admin:
  Tested on Iyonix, BB-xM


Version 1.90. Tagged as 'Colours-1_90'
@
text
@d595 1
a595 1
        Debug_Open "<ColourTrans$Debug>"
@


4.13
log
@Add new "32K+" translation table format. Fix a couple of bugs.
Detail:
  Since ColourTrans 1.86, the "32K." tables returned by ColourTrans_SelectTable/ColourTrans_GenerateTable can actually be in several different formats, depending on the pixel format of the source mode. However there was no way for a user of that table to determine what format the table was.
  This change rectifies that, by adding a "32K+" table format which is used whenever a 32K-style table isn't compatible with the RISC OS 3.5 "32K." format.
  This new format has "32K+" in the two guard words instead of "32K.". To increase compatibility with existing code the middle word is still used to point to the start of the lookup table. But in the bytes preceeding the table a header can be found which describes the structure of the table.
  File changes:
  hdr/ColourTran - Describe format of the 32K+ table header
  s/Header, s/Tables32K - Update code to generate and store the new format tables. Strip out nomessagetransfortables option (assume TRUE). Fix reading of tables from ResourceFS to correctly determine whether files are squashed or not (previously always treated as squashed and copied them to RAM). Add simple caching for addresses of ROM tables so we don't have to pester the filesystem all the time. Fix immortality code to set the immortal flag correctly when generating 32K tables (would previously overwrite a random word in a temp array)
Admin:
  Tested on BB-xM


Version 1.89. Tagged as 'Colours-1_89'
@
text
@d346 2
d662 1
d756 12
a769 1
        ADD     R6,R6,#cachedtable_palette
d791 2
d833 1
d1040 1
@


4.12
log
@Performance improvements
Detail:
  A selection of performance improvements, mainly focusing around fixing the terrible ColourTrans_SelectTable performance when using the default 256 colour palette in a full 256 colour mode (i.e. not VIDC1 style)
  s/Header:
  - Add flag for whether MUL of large or negative numbers is slow
  s/Commons:
  - Update palette analysis code so that C256 modes with the default palette can use the same optimised routines as C64 modes with default palette.
  - Also detect G256 modes with the default palette and add a new set of best/worst colour routines for them
  - Remove unused ColErr macro and (now inaccurate) ARM2/ARM3 timing calculations
  - Optimised CompErr macro (used with slow best/worst colour functions). Three different variants depending on CPU, with the Cortex-A8 version being about twice as fast as the original.
  - Rewrote Find256 macro (used with default 256 colour palette), producing four different versions depending on CPU. Even the ARM2 compatible version should be about twice as fast as the original.
  - Strip out a few pointless best/worst wrapper functions
  s/NewModels:
  - Update ColourTrans_ConvertHSVToRGB to make use of SMULL where supported
Admin:
  Tested on Iyonix, BB-xM, StrongARM RiscPC
  Palette analysis fix means 256 colour modes using default RO 5 icon sprites (i.e. custom 256 colour palettes) are no longer as slow as treacle.
  256 grey modes are also nice and snappy too.


Version 1.88. Tagged as 'Colours-1_88'
@
text
@d145 1
a205 6
; this fix is required so that MessageTrans' that use the data to generate
; hashing tables don't blow up. Plus the fact that you shouldn't be using
; MessageTrans to unsquash files anyhow
                         GBLL    nomessagetransfortables
nomessagetransfortables  SETL    true

d714 1
a714 1
        ADD     R3,R3,#cachedtable_palette+12 ; 12 bytes extra for name
d758 2
@


4.11
log
@Update to cope with new pixel formats
Detail:
  s/Commons - Update best/worst colour code to add support for all the new RGB pixel format variations
  s/Dither - Rework code to remove reliance on now removed get_physical16bpp routine
  s/Enhanced - Drop support for VIDC enhancer. "VIDC20" code enhanced to add support for all the new RGB pixel formats, mainly reliant on new ColourConv macro. Drop get_physical16bpp routine as it wasn't really needed and would have been a pain to update.
  s/FontColours - Remove reference to obsolete PseudoPaletteEntry variable
  s/Header - Update workspace to clarify how certain variables are overlaid over the colour cache entries. Rename temp_guardtable to temp_errortable as the name makes more sense to me. Cache current modeflags & log2 NColour in InitCache.
  s/MainSWIs - Flag_* -> ModeFlag_* renaming. Pass through source mode to make32Ktable
  s/Palettes - Strip out some old Module_Version switches to make code more readable. Cache current modeflags and log2 NColour values when dealing with sprite output.
  s/Tables32K - Table generation code rewritten to add support for new 16bpp pixel formats, be faster, and (hopefully) more readable. Core generation code has been split off into seperate file, s/TablesAlgo, as it's needed multiple times but is too big for a macro.
  s/TablesAlgo - New file containing core code for the "32K" table generation. Disregarding pixel format differences, it can be assembled in two forms, optimised either for large or small data caches. New code is 85% faster on BB-xM (large cache version), 43% faster on Iyonix and 80% faster on StrongARM (both small cache version).
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification
  Code is in need of updating to allow caller to identify which type of 32K table has been returned (i.e. old-style 32K table or some new kind of 4K/32K/64K one)


Version 1.86. Tagged as 'Colours-1_86'
@
text
@d157 7
@


4.10
log
@Rework maketables to not need ColourTrans loaded at build time
During generation of the 32k colour lookup tables, the tool already has to hand the 5:5:5 RGB value and 8:8:8 RGB palette, so can do the colour lookup itself. This removes the need to build a platform agnostic ColourTrans module, it's just C code.
* Replace make_32k_table() with brute force colour matcher
* Use <stdio.h> functions to write out the output, change to use <stdint.h>
* Simplify top level makefile
* Header.s: minor warning squashed
Binary output compared with Colours-1_83.

Version 1.85. Tagged as 'Colours-1_85'
@
text
@a175 2
                GBLL    med_02882
                GBLL    med_03007
a196 2
med_02882       SETL    Module_Version >= 161  ; improve 32K routine's memory usage/claiming
med_03007       SETL    Module_Version >= 162 :LAND: med_02882 ; fix a register corruption in med_02882
d266 2
a267 4
CacheEmpty              # 1     ;flag only in first entry: no reinvaldiation if no cache entries
CachedL2BPP             # 1     ;make word sized: also number cache on mode change
CachedPatternValid      # 1     ;Caced ratio of colours: if =-1 then ECF info invalid
CachedFullCLUT          # 1     ;Brain damaged mode if non-zero
d277 9
a285 2
PseudoPaletteEntry      * CacheEmpty +CacheEntrySize
PaletteIsCached         * CachedL2BPP +CacheEntrySize
d354 1
a354 1
temp_guardtable         # 4     ; Temporary pointer within 32K generation
a355 1
                        [ med_02882
a356 3
                        |
temp_gbpb               # 32    ; for gbpb calls
                        ]
d673 1
a673 1
        STR     R0,[WP,#temp_guardtable]
d712 1
a712 1
        ADD     R3,R3,#20 ;
d727 1
a727 1
        LDR     R1,[R0]                  ;fetch the next pointer
d732 1
a732 1
        STR     R2,[R0]
d736 1
a736 1
        STR     R0,[R2]
d738 3
a740 1
        STR     R3,[R2,#4]
d744 1
a744 1
        ADD     R2,R2,#8
d753 1
a753 1
        ADD     R6,R6,#8
d824 1
a824 1
        LDR     R2,[R1,#temp_guardtable]
d827 1
a827 1
        STR     R2,[R1,#temp_guardtable]
d877 1
a877 1
        LDR     R4,[R2]                 ;yes, so see where it goes next
d1263 11
a1273 2
        AND     R2,R2,#Flag_FullPalette
        STRB    R2,[WP,#CachedFullCLUT]
d1275 17
a1291 1
        Debug   xx,"Cache brain damaged flag",R2
a1297 1
        STRB    R0,[WP,#PaletteIsCached]
d1310 1
a1310 1
00
d1315 1
a1315 1
        BPL     %BT00                   ;Loop back zonking the cache
@


4.9
log
@Odd use of StrongARM switch removed.
Should now be considered as "has split I-D caches" flag.
Retagged.
@
text
@d801 1
a801 1
        LDMNEFD R13!,{LR}
@


4.8
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  s.Dither: It looks like CachedPatternValid was once a 4-byte value but
    subsequently three of the bytes in the first cache entry were re-used for
    other purposes. However in getpattern it is still accessed using LDR and
    STR.  This means (a) that it mistakenly thinks that the pattern block is
    never valid and so has to recalculate it every time, and (b) corrupts
    other variables if either this was the first entry, or we're on ARMv6 or
    later and this was the last entry.
  s.MainSWIs: LDR of a 1-byte variable: harmless since only bit 7 tested, but
    faster as an LDRB on ARMv6.
  Added ENTRY directive to permit building of GPA debug listing.
Admin:
  Builds but not tested.

Version 1.77. Tagged as 'Colours-1_77'
@
text
@a634 1
 [ StrongARM
d636 1
a636 4
	STRB	R0, [WP,#CacheEmpty]	;Force a cache flush the nice way :-)
 |
        STRB    PC,[WP,#CacheEmpty]     ;Force cache flush (SVC mode here)
 ]
@


4.7
log
@  GET file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both objasm and asasm.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 1.76. Not tagged
@
text
@d452 1
@


4.6
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 1.75. Tagged as 'Colours-1_75'
@
text
@d1310 4
a1313 4
        GET     s.Commons
        GET     s.MainSWIs
        GET     s.Cache
        GET     s.FontColour
d1318 7
a1324 7
        GET     s.NewModels
        GET     s.Palettes
        GET     s.MsgCode

        GET     s.FileCal
        GET     s.Calibrate
        GET     s.DevicePal
d1329 2
a1330 2
        GET     s.Enhanced
        GET     s.Tables32K
@


4.5
log
@  32k sprites plotted in 256 colour modes crashes.
Detail:
  * MessageTrans now does hashing when files are opened. ColourTrans does
    OpenFile then CloseFile to access the files. This is evil. Changed to
    make ColourTrans unsquash files and load them itself.
Admin:
  Fixes Bugzilla 17.

Version 1.70. Tagged as 'Colours-1_70'
@
text
@d451 1
a451 1
        LEADR   Module_LoadAddr
d465 1
a465 1
 [ International_Help <> 0
d472 1
a472 5
Title   = "ColourTrans",0
Help    = "Colour Selector",9,"$Module_MajorVersion ($Module_Date)"
      [ Module_MinorVersion <> ""
        = " $Module_MinorVersion"
      ]
d529 1
a529 1
 [ International_Help = 0
a534 1
        ALIGN
d536 1
d1074 1
a1074 1
        mrs    ,R10,CPSR
@


4.4
log
@32-bit compatible.

Version 1.69. Tagged as 'Colours-1_69'
@
text
@d143 2
d180 3
a182 2
hostvdu         SETL    true
file            SETL    false ;(:LNOT: hostvdu) :LAND: debug
d202 6
d247 1
a247 1
table32K        SETD    false           ; 32K translation tables for Select/GenerateTable
d251 1
a251 1
showswis        SETD    true            ; details on all SWIs handled
@


4.3
log
@Spinner and Ursula branches merged.
Changed to use srccommit.

Version 1.67. Tagged as 'Colours-1_67'
@
text
@d121 1
d387 1
a387 1
$l      MOV     $temp2,PC
d389 1
a389 1
        TEQP    $temp2,#0               ;Preserve flags around divides
d414 1
a414 1
$l      BuildColoursForBest $cc
d416 2
a417 2
        BL$cc   build_colours           ; Build colour table as required
        STR$cc  R7,[WP,#BestColourV]
d421 1
a421 1
$l      BuildColoursForWorst $cc
d423 2
a424 2
        BL$cc   build_colours           ; Build colour table as required
        STR$cc  R8,[WP,#WorstColourV]
d461 1
d477 7
d857 2
a858 1
        Pull    "PC",,^
d897 2
a898 2
        TEQ     R2,#0                   ;Is there a block hanging from word?
        Pull    "R1,R3,PC",,^
d962 1
a962 1
        MOVS    PC,LR
d978 1
a978 1
        MOVNES  PC,LR
d982 1
a982 1
        MOVEQS  PC,LR                   ;If not then we must return as cache is invalidated later
d1005 1
a1005 1
        MOVEQS  PC,LR                   ;If not then we must return
d1042 1
a1042 1
        TEQ     PC,#SVC_mode            ;Enable IRQs
d1068 6
d1075 2
a1076 2
        ORRVS   LR,LR,#V_bit            ;Return any errors, but preserve other flags
        MOVS    PC,LR
d1222 1
a1222 1
        Push    "R0-R2,LR"
d1231 1
a1231 1
        Pull    "R0-R2,PC",EQ,^         ;Return when the end of the chain has been reached
d1300 2
a1301 1
        Pull    "PC",,^
@


4.2
log
@Version RO_3_70 taken
@
text
@d154 1
a154 1
                GET     Version
d190 1
a190 1
newcalibration  SETL    Version > 109   ; new calibration code in V1.09 and beyond
d192 1
a192 1
checkluminance  SETL    Version = 098   ; check using luminance, instead of error calculation
d194 3
a196 3
immortal        SETL    Version >= 160  ; don't die while people are using my 32K tables
med_02882       SETL    Version >= 161  ; improve 32K routine's memory usage/claiming
med_03007       SETL    Version >= 162 :LAND: med_02882 ; fix a register corruption in med_02882
d462 4
a465 1
Help    = "Colour Selector",9,"$VString ($Date)"
d922 21
d944 2
a945 1

@


4.2.2.1
log
@update to ursula service format
@
text
@a918 21
;Ursula format
;
        ASSERT  Service_Reset              < Service_ModeChange
        ASSERT  Service_ModeChange         < Service_ResourceFSStarted
        ASSERT  Service_ResourceFSStarted  < Service_CalibrationChanged
        ASSERT  Service_CalibrationChanged < Service_WimpSaveDesktop
        ASSERT  Service_WimpSaveDesktop    < Service_SwitchingOutputToSprite
;
UServTab
        DCD     0
        DCD     UService - ModuleStart
        DCD     Service_Reset
        DCD     Service_ModeChange
        DCD     Service_ResourceFSStarted
      [ debugcalibrate
        DCD     Service_CalibrationChanged
      ]
        DCD     Service_WimpSaveDesktop
        DCD     Service_SwitchingOutputToSprite
        DCD     0
        DCD     UServTab - ModuleStart 
d920 1
a920 2
        MOV     r0, r0
UService
@


4.1
log
@Initial revision
@
text
@d151 3
d222 1
a222 1
calibrate       SETD    false           ; debugging calibration
d234 1
a234 1
newcalibrate    SETD    false           ; new calibration stuff
d241 1
a241 1
showswis        SETD    false           ; details on all SWIs handled
d320 1
a320 1
FontColourCode          # 4*4   ; Four words for self compiling code for font colour caching
d617 4
d622 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a150 3
                GBLL    StrongARM
StrongARM       SETL    {TRUE}

d219 1
a219 1
calibrate       SETD    true            ; debugging calibration
d231 1
a231 1
newcalibrate    SETD    true            ; new calibration stuff
d238 1
a238 1
showswis        SETD    true            ; details on all SWIs handled
d317 1
a317 1
;;;FontColourCode          # 4*4   ; Four words for self compiling code for font colour caching - not used now
a613 4
 [ StrongARM
	MOV	R0, #-1
	STRB	R0, [WP,#CacheEmpty]	;Force a cache flush the nice way :-)
 |
a614 2
 ]

@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

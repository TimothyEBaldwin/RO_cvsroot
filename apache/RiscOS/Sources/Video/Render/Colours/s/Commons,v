head	4.6;
access;
symbols
	Colours-1_95:4.6
	Colours-1_94:4.6
	Colours-1_93:4.5
	Colours-1_92:4.5
	Colours-1_91:4.5
	Colours-1_90:4.4
	Colours-1_89:4.4
	Colours-1_88:4.4
	Colours-1_87:4.3
	Colours-1_86:4.3
	Colours-1_85:4.2
	Colours-1_84:4.2
	Colours-1_83:4.2
	Colours-1_82:4.2
	Colours-1_81:4.2
	Colours-1_80:4.2
	Colours-1_79:4.2
	Colours-1_78:4.2
	Colours-1_77:4.2
	RO_5_07:4.2
	Colours-1_76:4.2
	Colours-1_75:4.2
	Colours-1_74:4.2
	Colours-1_73:4.2
	Colours-1_72:4.2
	dellis_autobuild_BaseSW:4.2
	Colours-1_71:4.2
	Colours-1_70:4.2
	Colours-1_69:4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	Colours-1_68:4.1
	Colours-1_67:4.1
	Ursula_merge:4.1
	nturton_Colours-1_65:4.1
	dcotton_colours_MPTInitialBuild:4.1.7.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2016.05.08.17.31.21;	author jlee;	state Exp;
branches;
next	4.5;
commitid	d1ySJ33i6bBREH5z;

4.5
date	2015.01.16.00.50.07;	author jlee;	state Exp;
branches;
next	4.4;
commitid	X83cRl6g8Bi0ub6y;

4.4
date	2014.02.27.23.15.44;	author jlee;	state Exp;
branches;
next	4.3;
commitid	KBVViyk78fRijNqx;

4.3
date	2013.08.06.23.49.20;	author jlee;	state Exp;
branches;
next	4.2;
commitid	wewI5Vx1d9Rn5s0x;

4.2
date	2000.05.12.12.34.33;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.42.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.42.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.08.06;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.48.02;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.11.02;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Avoid unnecessary remainder calculations
Detail:
  s/Commons, s/DevicePal, s/Dither, s/FontColour - Avoid unnecessary remainder calculations in DivRem macro
  s/Header - Remove unused Divide macro
Admin:
  Tested on Cortex-A15


Version 1.94. Tagged as 'Colours-1_94'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Commons

;..............................................................................
;
; build_colours
;
; Fill the specified buffer with suitable data for performing palette lookups,
; the routine builds a table containing the correct data and returns R0,R1
; containing the bounds of the buffer.
;
; R6 is supplied on entry as a temporary buffer to be filled and on exit
; it will have been advanced past any data written into this buffer.
;
; R7,R8 contain pointers to routines on exit to be called to find the best
; and worst colour for the specified physical palette entry.  Whilst the
; routine is building the specified table it uses R7 as an index into a
; routine table which is then resolved on exit from the code.
;
; The cases go as follows:
;
;       default =rc_Simple
;       if 8BPP and default palette then =rc_Clever256
;       if 8BPP and default greyscale (black-to-white) palette then =rc_Grey8BPP
;
; The routine does check for the current palette being cached, if it
; is then it will return that if R0,R1 are -1 on entry.
;
; in    R0 mode to build table for / =-1 for current
;       R1 -> palette block to build mode for / =0 for default / =-1 for current
;       R2 = flags word
;       R7 -> extended flags word
;               bit 0 set => generate extended tables, else limit to eight bit per pixel tables
;
; out   V =1 => R0 -> error block
;       else,   R0,R1 contain limits of the buffer
;               R6 updated to point past last record
;               R7 ->routine to call to find best colour
;               R8 ->routine to call to find worst colour

rc_SimpleMatch  * 0
rc_Clever8BPP   * 1
rc_4444_TBGR    * 2
rc_4444_TRGB    * 3
rc_4444_ABGR    * 4
rc_4444_ARGB    * 5
rc_1555_TBGR    * 6
rc_1555_TRGB    * 7
rc_1555_ABGR    * 8
rc_1555_ARGB    * 9
rc_565_BGR      * 10
rc_565_RGB      * 11
rc_8888_TBGR    * 12
rc_8888_TRGB    * 13
rc_8888_ABGR    * 14
rc_8888_ARGB    * 15
rc_Grey8BPP     * 16

        ASSERT  :INDEX:PaletteCacheEnd =:INDEX: PaletteCacheStart +4
        ASSERT  :INDEX:PaletteBestV    =:INDEX: PaletteCacheStart +8
        ASSERT  :INDEX:PaletteWorstV   =:INDEX: PaletteCacheStart +12

build_colours ROUT

        Debuga  buildcolours,"Build colours mode",R0
        Debuga  buildcolours,", palette",R1
        Debug   buildcolours,", flags",R7

        CMP     R0,#-1                  ;Do they want the current palette?
        CMPEQ   R1,#-1
        BNE     build_colours2          ;If not then skip caching checks

        Debug   buildcolours2,"Attempting to get current palette"

        Push    "R3,R6,LR"

        LDR     R3,[WP,#PaletteCacheStart]
        CMP     R3,#0                   ;Has the palette already been cached?
        BNE     build_colourscached

        Debug   buildcolours2,"Not already cached"

        addl    R6,WP,CurrentPalette    ;->Buffer to fill
        BL      build_colours2
        addl    R6,WP,PaletteCacheStart
        STMIA   R6,{R0,R1,R7,R8}        ;Store the start and end of cache blocks

        Debuga  buildcolours2,"Our store is from",R0
        Debug   buildcolours2," to",R1
        Debug   buildcolours2,"Best routine",R7
        Debug   buildcolours2,"Worst routine",R8

        CLRV
        Pull    "R3,R6,PC"              ;Return because done

build_colourscached
        Debug   buildcolours2,"Current palette already cached"

        addl    R0,WP,PaletteCacheStart
        LDMIA   R0,{R0,R1,R7,R8}        ;Get bounds of cache block
        Pull    "R3,R6,PC"

;..............................................................................
;
; build_colours2
;
; This routine performs the actual table building and then returns the correct
; pointers etc.
;
; in    as above
;
; out   V =1 => R0 -> error block
;       else,   as above


build_colours2

        Push    "R2-R5,R10-R11,LR"

        Debuga  buildcolours2,"Mode",R0
        Debuga  buildcolours2," palette",R1
        Debuga  buildcolours2," scratch",R6
        Debug   buildcolours2," flags",R7

        Debuga  ag,"Mode",R0
        Debuga  ag," palette",R1
        Debuga  ag," scratch",R6
        Debug   ag," flags",R7

        LDR     R10,[WP,#PaletteAt]     ;->Palette table

        CMP     R0,#-1                  ;Are we building for the current mode?
        BEQ     build_coloursvalid      ;Yup so ignore as Palette table is valid

        CMP     R1,#-1                  ;If we are not building for current mode, but current palette then
        MOVEQ   LR,#0                   ;brain damage the palette pointer
        STREQ   LR,[WP,#PaletteAt]
        ;following is intended to fix rendering 256 colour non-palette sprite into
        ;other modes, where, without this, it returns a 1:1 table of the current
        ;palette
        MOVEQ   R1,#0                   ;and force it to use the default for the mode (amg 1.54)

build_coloursvalid
        MOV     R11,R1                  ;Temporary copy of palette pointer

;amg calling modeflags at this point is only sensible for a real mode, not a sprite
;mode word

        CMP     R0,#-1
        BEQ     bc2_oldmode

        CMP     R0,#256
        BCC     bc2_oldmode

        TST     R0,#1                   ;is bit0 set ?
        BEQ     bc2_oldmode             ;it isn't - so it is a modeselector

        ;so it is a sprite mode word
        Debug   buildcolours,"It's a sprite mode word"
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ;Get Log2BPP into flags (R3)
        MOV     R3,R2
        CMP     R3,#3
        MOVLS   R4,#0                   ;Not setting FullPalette; allegedly causes problems with tiled desktop background (see v1.54 changes)
        BLS     bc2_skipmodeflags
        MOV     R1,#VduExt_ModeFlags    ;Get the mode flags as required (R4)
        SWI     XOS_ReadModeVariable
        MOV     R4,R2
bc2_skipmodeflags
        MOV     R1,#VduExt_NColour
        SWI     XOS_ReadModeVariable    ;Get NColour (R5)
        MOV     R5,R2        

        B       bc2_gotmodevars

bc2_oldmode
        Debug   buildcolours,"It's a mode number/selector"
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ;Get Log2BPP into flags (R3)
        MOVCC   R3,R2
        MOVCC   R1,#VduExt_ModeFlags
        SWICC   XOS_ReadModeVariable    ;Get the mode flags as required (R4)
        MOVCC   R4,R2
        MOVCC   R1,#VduExt_NColour
        SWICC   XOS_ReadModeVariable    ;Get NColour (R5)
        MOVCC   R5,R2
        BCC     bc2_gotmodevars

        STR     R10,[WP,#PaletteAt]     ;Restore palette table is at pointer
        Pull    "R2-R5,R10-R11,LR"
        BadMODE
        B       LookupError             ;Balance stack and return bad mode error if not valid

bc2_gotmodevars
        CMP     R3,#3                   ;Is this a sensible mode for building a table in?
        BGT     buildcoloursbigjob      ;No, generating one in this mode is silly!

        MOV     R1,#1
        MOV     LR,R1,ASL R3            ;Convert from Log2BPP to BPP
        MOV     R1,#4
        MOV     R1,R1,ASL LR            ;Get the size of the table to be generated in words

        LDR     R5,[WP,#Calibration_ptr]
        MOV     R7,#rc_SimpleMatch      ;Index for routine to call (defaults to safe jobbie)

        MOVS    R0,R11

        ADREQL  LR,defpals
        LDREQ   R0,[LR,R3,ASL #2]
        ADDEQ   R0,R0,LR                ;->Palette table or default if R1 was zero on entry

        Debug   buildcolours2,"Resolved palette pointer",R0
        Debug   buildcolours2,"Final palette size",R1
        Debug   buildcolours2,"Log2BPP",R3
        Debug   buildcolours2,"Flags",R4
        Debug   buildcolours2,"Calibration table at",R5
        Debug   buildcolours2,"Scratch space",R6

        ;nb this actually the palette pointer

        CMP     R0,#-1                  ;Build palette for current mode?
        BEQ     buildcurrent

        Debug   buildcolours2,"Build from table"

        CMP     R3,#2                   ;Is it an 8BPP mode?
        CMPLE   R5,#0                   ;Calibration table specified?
        ADDLE   R1,R1,R0
        BLE     buildcoloursexit        ;Not 8BPP and no calibration so exit now... R0 ->table & R1 ->end

        TEQ     R3,#3                   ;Is it 8PP mode?
        TSTEQ   R4,#ModeFlag_FullPalette ;Does it have a full palette?
        BNE     buildslowtable

; flow down into "buildfasttable"

;..............................................................................
;
; buildfasttable
;
; Build a fast table of colours, we know that the mode is 8bpp and brain
; damaged and so we can simply read the base 16 entires and interpolate
; from these up to the final values.
;
; in    R0 -> table
;       R1 size of table block +1
;       R5 -> calibration table
;       R6 -> scratch space
;
; out   V =1 => R0 -> error block
;       else,   R0 -> start of table    (exits via calling 'buildcoloursexit')
;               R1 -> end of table
;               R6 updated
;               R7 preserved

buildfasttable
        Push    "R4,R8-R9"

        Debug   buildcolours2,"Building from a table"

        ADRL    R2,hardmode_hardbits    ;-> bit extensions for 8BPP modes
        LDR     R8,=&70307000           ;Bit mask to munge bits around with
        MOV     R9,#255                 ;Maximum colour index within the table

buildfastloop
        AND     LR,R9,#15               ;Get index into base entries
        LDR     R4,[R0,LR,ASL #2]       ;Get the RGB of the base palette entry
        AND     R4,R4,R8
        MOV     LR,R9,LSR #4
        LDR     LR,[R2,LR,ASL #2]       ;Get tint munging values
        ORR     R4,LR,R4
        ORR     R4,R4,R4,LSR #4         ;Combine into a suitable set of colours (including *17/16)
      [ {FALSE}
        TEQ     R5,#0
        BLNE    convert_screen_colour2  ;Attempt to calibrate if table pointer <>0
      ]
        STR     R4,[R6,R9,ASL #2]       ;Store into the table

        SUBS    R9,R9,#1
        BPL     buildfastloop           ;Loop until the entire table has been built

buildfastexit
        Pull    "R4,R8-R9"              ;Restore registers
        MOV     R0,R6
        ADD     R1,R1,R0                ;Setup bounds of table in registers
        MOV     R6,R1                   ;Setup end of scratch buffer pointer
        B       buildcoloursexit

;..............................................................................
;
; buildslowtable
;
; Fill the specified table with suitable data read from the block at R0
; and then stored at R6 performing calibration if required.
;
; in    R0 ->default palette block
;       R1 size of palette block +1
;       R3 log2BPP
;       R5 ->calibration table /=0 for none
;       R6 pointer to scratch buffer
;
; out   V =1 => R0 -> error block
;       else,   R0 -> start of table    (exits via calling 'buildcoloursexit')
;               R1 -> end of table
;               R6 updated
;               R7 preserved

buildslowtable
        Debuga  buildcolours2,"Building for normal modes from",R0
        Debug   buildcolours2," at",R6

        ADD     LR,R6,R1                ;End of table
        Push    "R6,LR"                 ;Push exit R0,R1 to table
        MOV     R2,R4                   ;Take a temporary copy of R4

buildslowloop
        SUBS    R1,R1,#4
        BMI     buildslowexit           ;Exit when finished building the current table

        LDR     R4,[R0],#4              ;Get a palette entry from original table
      [ {FALSE}
        TEQ     R5,#0                   ;Is there a calibration table?
        BLNE    convert_screen_colour2
      ]
        STR     R4,[R6],#4              ;Store the colour after possible calibration
        B       buildslowloop           ;Loop until all written back

buildslowexit
        Pull    "R0,R1"
        MOV     R4,R2                   ;Setup table start, end and restore mode flags
        B       buildcoloursexit        ;And then exit from routines

;..............................................................................
;
; buildcurrent
;
; Build table of current palette entries, to do this we need to fill the table
; at R6 with suitable palette data.
;
; No optimisation has been specified for the 8BPP case of brain damaged
; but we should attempt to find it if we can.
;
; in    R0 =-1
;       R1 size of palette buffer to fill
;       R3 log2bpp
;       R4 flags
;       R5 ->calibration table
;       R6 pointer to scratch buffer
;
; out   V =1 => R0 -> error block
;       else,   R0 -> start of table    (exits via calling 'buildcoloursexit')
;               R1 -> end of table
;               R6 updated
;               R7 preserved

buildcurrent
        ADD     LR,R6,R1                ;Pointer to end of data read
        Push    "R6,LR"                 ;Store the pointers

        MOV     R0,R1,LSR #2            ;R0 index of maxmium colour
        MOV     R1,#16                  ;Setup to return &BBGGRRxx

        Debug   buildcolours2,"Number of colours",R0

        MOV     R1,#17                  ;only actually want first flash state
        BL      fast_read_whole_palette ;R6 = where to, R0 = max colour+1
                                        ;R1 = colour type (16 here)
                                        ;returns R0=0 for correct behaviour below

        MOV     R1,#16                  ;but the original routine uses 16!

buildcurrentloop
        SUBS    R0,R0,#1
        BMI     buildcurrentexit        ;Exit when finished building palette

        Push    "R3,R4"
        BL      my_read_palette         ;Will calibrate result if required
        Pull    "R3,R4"

        STRVC   R2,[R6,R0,ASL #2]       ;Store palette entry obtained
        BVC     buildcurrentloop

buildcurrentexit
        Pull    "R0,R1"                 ;Balance stack pulling the exit parameters
        MOV     R6,R1
        B       buildcoloursexit

;..............................................................................
;
; Routine for coping with 16 and 32 bit per-pixel modes.  In these cases
; we do not attempt to generate a table (would be too big!) we infact
; just setup the pointers to the routines and then let the rest fall into
; place.
;
; R3 = Log2BPP
; R4 = ModeFlags
; R5 = NColour

buildcoloursbigjob

        Debug   buildcolours,"true colour mode, R5=",R5
        ; Assuming it's RGB colour space, work out which routine we need to use
        ; First work out the base format
        MOV     LR,#-1
        MOV     R7,#rc_8888_TBGR        ;8888 by default
        CMP     R5,LR,LSR #8
        BICEQ   R4,R4,#ModeFlag_DataFormatSub_Alpha ; 888 can use 8888, just need to ignore any alpha flag
        CMP     R5,LR,LSR #16
        MOVEQ   R7,#rc_565_BGR          ;Assume 64K
        TSTEQ   R4,#ModeFlag_64k
        MOVEQ   R7,#rc_1555_TBGR        ;Unless flag not set
        CMP     R5,LR,LSR #20
        MOVEQ   R7,#rc_4444_TBGR
        ; Now apply alpha & RGB order modifiers
        CMP     R7,#rc_565_BGR
        TSTNE   R4,#ModeFlag_DataFormatSub_Alpha
        ASSERT  rc_4444_ABGR-rc_4444_TBGR = 2
        ADDNE   R7,R7,#2
        TST     R4,#ModeFlag_DataFormatSub_RGB
        ASSERT  rc_4444_TRGB-rc_4444_TBGR = 1
        ADDNE   R7,R7,#1

;..............................................................................
;
; General purpose exit routine.  Attempts to decide which routine should be used
; to match the colours.
;

buildcoloursexit
        Debug   buildcolours2,"Finished building table"

        STR     R3,[WP,#BuildColoursL2BPP]

        TEQ     R3,#3                   ;Is it an 8BPP mode?
        BNE     buildcoloursdone

      [ docalibration
        LDR     R2,[WP,#Calibration_ptr]
        TEQ     R2,#0                   ;Is there a calibration table in use?
        BNE     buildcoloursdone        ;If so we cannot perform the faster look up
      ]

        TST     R4,#ModeFlag_FullPalette ;Is it brian damaged... borring
        BNE     scannewstyle

        Debug   buildcolours2,"Check for fast colour matching (old style)"

        ADR     R2,modetwofivesix       ;Base of table for 256 colours
        MOV     R3,#16
        LDR     R4,=&70307000           ;Mask to extract colours

scanoldstyle
        SUBS    R3,R3,#1                ;Decrease the counter
        MOVMI   R7,#rc_Clever8BPP       ;Switch to fast 256 table matching
        BMI     buildcoloursdone

        LDR     LR,[R2,R3,LSL #2]       ;Get colour from my table
        LDR     R5,[R0,R3,LSL #2]
        AND     R5,R5,R4                ;Get colour from palette
        TEQ     R5,LR
        BEQ     scanoldstyle            ;Loop back until all checked

scanfailed
        Debug   buildcolours2,"Matching failed"

buildcoloursdone
        Debuga  buildcolours2,"Table from",R0
        Debuga  buildcolours2," to",R1
        Debuga  buildcolours2," scratch",R6
        Debug   buildcolours2," routine index",R7

        ADR     LR,routinetable
        ADD     R7,LR,R7,ASL #3         ;-> routine table to call
        LDMIA   R7,{R7,R8}
        ADD     R7,R7,LR                ;-> best colour routine
        ADD     R8,R8,LR                ;-> worst colour routine

        Debug   buildcolours,"Best match routine",R7
        Debug   buildcolours,"Worst match routine",R8

        STR     R10,[WP,#PaletteAt]     ;Restore the palette table pointer

        CLRV
        Pull    "R2-R5,R10-R11,PC"

scannewstyle
        TST     R4,#ModeFlag_GreyscalePalette
        MOV     R3,#256
        BNE     scangrey256
        
        Debug   buildcolours2, "Check for fast colour matching (new style)"
        ; Use modetwofivesix and hardmode_hardbits to dynamically build the
        ; default 256 colour palette and check it against the input palette
        ; (Probably quicker to have the default palette precalculated somewhere)
        ADR     R2,modetwofivesix+15*4
        ADR     R4,hardmode_hardbits+15*4
        LDR     R8,[R4],#-4             ;Get high nibble
scannewstyle_loop
        LDR     LR,[R2],#-4             ;Get low nibble
        SUB     R3,R3,#1                ;Decrease the counter
        ORR     LR,LR,R8                ;Combine nibbles
        LDR     R5,[R0,R3,LSL #2]       ;Get colour from palette
        ORR     LR,LR,LR,LSR #4         ;Expand to 8 bits
        TEQ     R5,LR
        BNE     scanfailed
        TST     R3,#15
        BNE     scannewstyle_loop
        ADR     R2,modetwofivesix+15*4  ;Reset low nibble pointer
        CMP     R3,#0
        LDR     R8,[R4],#-4             ;Fetch next high nibble value
        BNE     scannewstyle_loop
        MOV     R7,#rc_Clever8BPP       ;Switch to fast 256 table matching
        B       buildcoloursdone

scangrey256
        ; Check if this is the RISC OS 5 default greyscale palette: A linear
        ; gradient from black to white. If so, we can use our fast greyscale
        ; routines.
        MOV     R2,#&FFFFFF00
        LDR     R4,=&01010100
        Debug   buildcolours2, "Check for default 256 grey"
scangrey256_loop
        SUBS    R3,R3,#1
        MOVLT   R7,#rc_Grey8BPP
        BLT     buildcoloursdone
        LDR     LR,[R0,R3,LSL #2]
        TEQ     LR,R2
        SUB     R2,R2,R4
        BEQ     scangrey256_loop
        B       scanfailed
        
;..............................................................................
;
; Routines to be called to find suitable colours.  These routines are given
; as absolute addresses in R7,R8 on return from build_colours.
;
; The routine whilst operating attempts to increase R7 as a suitable index
; within the table so that on exit from the build_colours code it can
; setup a set of suitable pointers
;
        ASSERT  rc_SimpleMatch =0
        ASSERT  rc_Clever8BPP  =1
        ASSERT  rc_4444_TBGR   =2
        ASSERT  rc_4444_TRGB   =3
        ASSERT  rc_4444_ABGR   =4
        ASSERT  rc_4444_ARGB   =5
        ASSERT  rc_1555_TBGR   =6
        ASSERT  rc_1555_TRGB   =7
        ASSERT  rc_1555_ABGR   =8
        ASSERT  rc_1555_ARGB   =9
        ASSERT  rc_565_BGR     =10
        ASSERT  rc_565_RGB     =11
        ASSERT  rc_8888_TBGR   =12
        ASSERT  rc_8888_TRGB   =13
        ASSERT  rc_8888_ABGR   =14
        ASSERT  rc_8888_ARGB   =15
        ASSERT  rc_Grey8BPP    =16

routinetable
        & best_colour_safe       -routinetable
        & worst_colour_safe      -routinetable

        & best_colour256_safe    -routinetable
        & worst_colour256_safe   -routinetable

        & best_colour_4444_TBGR  -routinetable
        & worst_colour_4444_TBGR -routinetable

        & best_colour_4444_TRGB  -routinetable
        & worst_colour_4444_TRGB -routinetable

        & best_colour_4444_ABGR  -routinetable
        & worst_colour_4444_ABGR -routinetable

        & best_colour_4444_ARGB  -routinetable
        & worst_colour_4444_ARGB -routinetable

        & best_colour_1555_TBGR  -routinetable
        & worst_colour_1555_TBGR -routinetable

        & best_colour_1555_TRGB  -routinetable
        & worst_colour_1555_TRGB -routinetable

        & best_colour_1555_ABGR  -routinetable
        & worst_colour_1555_ABGR -routinetable

        & best_colour_1555_ARGB  -routinetable
        & worst_colour_1555_ARGB -routinetable

        & best_colour_565_BGR    -routinetable
        & worst_colour_565_BGR   -routinetable

        & best_colour_565_RGB    -routinetable
        & worst_colour_565_RGB   -routinetable

        & best_colour_8888_TBGR  -routinetable
        & worst_colour_8888_TBGR -routinetable

        & best_colour_8888_TRGB  -routinetable
        & worst_colour_8888_TRGB -routinetable

        & best_colour_8888_ABGR  -routinetable
        & worst_colour_8888_ABGR -routinetable

        & best_colour_8888_ARGB  -routinetable
        & worst_colour_8888_ARGB -routinetable

        & best_colour256_grey    -routinetable
        & worst_colour256_grey   -routinetable

        LTORG

;..............................................................................
;
; Tables required to contain default palette data for the various screen
; modes.
;
; NB: 256 colour modes are a very special case and contain only the base 16
;     entries and interpolation is performed from here to the real
;     values.
;

defpals
        DCD     modetwo         - defpals
        DCD     modefour        - defpals
        DCD     modesixteen     - defpals
        DCD     modetwofivesix  - defpals

modetwo
        DCD     &0              ;  black
        DCD     &FFFFFF00       ;  white

modefour
        DCD     &0              ;  black
        DCD     &FF00           ;  red
        DCD     &FFFF00         ;  yellow
        DCD     &FFFFFF00       ;  white

modesixteen                     ;  actual colours
        DCD     &0              ;  black
        DCD     &FF00           ;  red
        DCD     &FF0000         ;  green
        DCD     &FFFF00         ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white
        DCD     &0              ;  black - flashing
        DCD     &FF00           ;  red
        DCD     &FF0000         ;  green
        DCD     &FFFF00         ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white

modetwofivesix
        DCD     &0              ;  0000
        DCD     &10101000       ;  0001
        DCD     &20202000       ;  0010
        DCD     &30303000       ;  0011
        DCD     &00004000       ;  0100
        DCD     &10105000       ;  0101
        DCD     &20206000       ;  0110
        DCD     &30307000       ;  0111
        DCD     &40000000       ;  1000
        DCD     &50101000       ;  1001
        DCD     &60202000       ;  1010
        DCD     &70303000       ;  1011
        DCD     &40004000       ;  1100
        DCD     &50105000       ;  1101
        DCD     &60206000       ;  1110
        DCD     &70307000       ;  1111

hardmode_hardbits       ;  translation of top nibble of byte to RGB bits
        DCD     &0              ;  0000
        DCD     &00008000       ;  0001
        DCD     &00400000       ;  0010
        DCD     &00408000       ;  0011
        DCD     &00800000       ;  0100
        DCD     &00808000       ;  0101
        DCD     &00C00000       ;  0110
        DCD     &00C08000       ;  0111
        DCD     &80000000       ;  1000
        DCD     &80008000       ;  1001
        DCD     &80400000       ;  1010
        DCD     &80408000       ;  1011
        DCD     &80800000       ;  1100
        DCD     &80808000       ;  1101
        DCD     &80C00000       ;  1110
        DCD     &80C08000       ;  1111

;------------------------------------------------------------------------------
;
; Common routines to find the closest and furthest colour from
; a given RGB value, given a table of colour entries.
;
; The algorithms here are expressed as macros - I find this makes
; register allocation easy while preserving some self documentation
; in the register names.
;
; Colours are encoded in the standard RISC OS way:-
;
;           BBGGRRxx
;
; where ``xx'' is undefined.  This encoding is also used for the
; loading in error calculations, used when determining the closest
; or most distance colour from a given colour.  The error is calculated
; from the errors in each component (be, ge, re) as follows:-
;
;         bl*be^2 + gl*ge^2 + rl*re^2
;
; The loadings are parameterised and stored globally as a single word
; value in the above format, ie:-
;
;           blglrlxx
;
; It will be seen that the maximum loading is thus 255.  This limits
; the maximum error generated by the above calculation to 3*255^3;
; &2F708FD.
;

;
;----------------------------------------------------------------------
;
; MACRO CompErr
;
; This macro also calculates an error value, however the second colour
; is specified as three separate r, g, b values.  The registers containing
; these values can be the same, if desired.  The registers should not be
; the same as any of the other registers.  Similarly the loading values
; are held in separate registers, which can be the same as each other
; if desired
;
        MACRO
$label  CompErr $error, $col, $red, $green, $blue, $rload, $gload, $bload, $temp1, $temp2

$label
    [ NoARMv6 :LOR: SlowMultiply
      [ SlowMultiply
        SUBS    $temp2, $blue, $col, LSR #24
        RSBLT   $temp2, $temp2, #0
      |
        SUB     $temp2, $blue, $col, LSR #24
      ]
        MUL     $temp1, $temp2, $temp2
        MUL     $error, $temp1, $bload       ; loading will be small
        ; $error contains blue term
        AND     $temp1, $col, #&FF0000       ; green component, still shifted
      [ SlowMultiply
        SUBS    $temp2, $green, $temp1, LSR #16
        RSBLT   $temp2, $temp2, #0           ; |green error|
      |
        SUB     $temp2, $green, $temp1, LSR #16
      ]
        MUL     $temp1, $temp2, $temp2
        MLA     $error, $temp1, $gload, $error
        ; $error contains blue+green
        AND     $temp1, $col, #&FF00         ; red component, still shifted
      [ SlowMultiply
        SUBS    $temp2, $red, $temp1, LSR #8
        RSBLT   $temp2, $temp2, #0           ; |red error|
      |
        SUB     $temp2, $red, $temp1, LSR #8
      ]
        MUL     $temp1, $temp2, $temp2
        MLA     $error, $temp1, $rload, $error
    |
        ; Cortex-A8 optimised version
        ; Should execute in 15 cycles, compared to 32 for the above
        ; May help ARMv6 too (minimum ARMv6 required due to MUL Rd==Rn)
        SUB     $error, $blue, $col, LSR #24 ; blue error
        AND     $temp2, $col, #&FF0000       ; green component, still shifted
        AND     $temp1, $col, #&FF00         ; red component, still shifted
        MUL     $error, $error, $error
        SUB     $temp2, $green, $temp2, LSR #16 ; green error
        SUB     $temp1, $red, $temp1, LSR #8 ; red error
        MUL     $temp2, $temp2, $temp2
        MUL     $temp1, $temp1, $temp1
        MUL     $error, $error, $bload
        MLA     $error, $temp2, $gload, $error
        MLA     $error, $temp1, $rload, $error
    ]
        MEND
;
;----------------------------------------------------------------------
;
; MACRO FindCol
;
; This macro finds a colour closest to or furthest from the given colour.
; Which is found is determined by the initial value of $error and the
; test ($test) which is supplied to use when deciding whether the found
; colour is better or worse than the current best.
;
; The $test value is used in instructions conditional on the result of:-
;
;      CMP      $newerror, $error
;
; And the search goes from the top of the colour table down, hence:-
;
;   $test    Initial $error          Interpretation
;   -----    --------------          --------------
;   LS       #&FFFFFFFF      Find closest colour, favour lower indices
;   LO       #&FFFFFFFF      Find closest colour, favour higher indicies
;   HS       #&0             Find furthest colour, favour lower indices
;   HI       #&0             Find furthest colour, favour higher indices
;
; Timings for the search obviously depend on the size of the colour
; table.  The whole table is always searched.
;
; Arguments are as follows:-
;
; $test      Comparison to perform: LS, LO, HS or HI
; $list      Pointer to start of colour table         PRESERVED
; $listend   Pointer to end+4 of colour table         IN
;            Same as $list                            OUT
; $srccol    BBGGRRxx colour to check                 IN
;            Index of colour in table                 OUT
; $load      Error loading in format BBGGRRxx         IN
;            Temporary registered                     TRASHED
; $error     Error value for colour $list[$srccol]    OUT
; $red       TEMPORARY
; $green     TEMPORARY
; $blue      TEMPORARY
; $rload     TEMPORARY
; $gload     TEMPORARY
; $bload     TEMPORARY
; $col       TEMPORARY
; $temp1     TEMPORARY
; $temp2     TEMPORARY
;
        MACRO
$label  FindCol  $test, $list, $listend, $srccol, $load, $error, $red, $green, $blue, $rload, $gload, $bload, $col, $temp1, $temp2

        ; First extract the packed colour and load
$label  MOV      $blue, #255
        AND      $green, $blue, $srccol, LSR #16
        AND      $gload, $blue, $load, LSR #16
        AND      $red, $blue, $srccol, LSR #8
        AND      $rload, $blue, $load, LSR #8
        MOV      $blue, $srccol, LSR #24
        MOV      $bload, $load, LSR #24
        ;
        ; Loop round from the top of the table down
00      LDR      $col, [$listend, #-4]!
        CompErr  $load, $col, $red, $green, $blue, $rload, $gload, $bload, $temp1, $temp2
        CMP      $load, $error
        MOV$test $error, $load
        SUB$test $srccol, $listend, $list             ; index * 4
        CMP      $listend, $list
        BHI      %BT00
        MOV      $srccol, $srccol, LSR #2
        MEND
;
;----------------------------------------------------------------------
;
; MACRO Find256
;
; This macro finds the best matching colour for the *standard* ARM 256
; entry palette - the one with the R/G/B/T (tint) bits.  The algorithm
; returns a palette value encoded in the standard way (BGGRBRTT) in
; $srccol and the error in $error.  The algorithm is expressed in two
; parts; the first to find the closest ARM 24 bit colour, then the
; second to convert this to the ARM standard format.  This allows the
; basic macro to be used either for GCOL (BBGGRRTT) form or colour
; number (BGGRBRTT) form.  The timings below assume colour number form.
;
; This is an improved version of the original Find256 macro. We use a
; lookup table to map the red, green and blue components to the four
; closest VIDC components (four due to the four different tint values).
; The old code used to find the closest colours manually, but using a
; lookup table allows over half of the instructions to be removed from
; the inner loop, making this new version at least twice as fast.
;
; Arguments are as follows:-
;
;Find256
;-------
; $test                           Comparison to perform: LS, LO, HS or HI
; $srccol                         (in) source RGB (out) corrupt
; $load                           (in) error loading (out) corrupt
; $error                          (in/out) best error value
; $newcol                         (in/out) best RGB value
; $temp1-temp3                    (out) corrupt
; $srcred, $srcgreen              (out) corrupt
; $rload, $gload                  (out) corrupt
; $redvals, $greenvals, $bluevals (out) corrupt
;
; All registers must be unique!
;
;Convert24Number, Convert24GCOL
;---------------  -------------
; $col       24 bit colour value                      PRESERVED
; $number    256 palette entry colour number          OUT
; $temp1     TEMPORARY
;
; The ARM palette entries are assumed to expand a 4 bit component to an 8
; bit component using c<<4|c - this has been determined experimentally to
; give good results.
;
; The $error value and the $test condition must be as in FindCol.  Because
; the algorithm searches through the tints starting at the highest the
; behaviour is as follows:-
;
;   $test    Initial $error          Interpretation
;   -----    --------------          --------------
;   LS       #&FFFFFFFF      Find closest colour, favour lower tints
;   LO       #&FFFFFFFF      Find closest colour, favour higher tints
;   HS       #&0             Find furthest colour, favour lower tints
;   HI       #&0             Find furthest colour, favour higher tints
;

        MACRO
$label  Find256  $test, $srccol, $load, $error, $newcol, $temp1, $temp2, $temp3, $srcred, $srcgreen, $rload, $gload, $redvals, $greenvals, $bluevals

        ; Set up a couple of aliases
        LCLS     srcblue
srcblue SETS     "$srccol"
        LCLS     bload
bload   SETS     "$load"                
        
$label

        ; Get lookup table pointer
        ADR      $bluevals, Find256_Table
        ; Get source RGB & loadings into separate registers
      [ NoARMv6
        AND      $srcred, $srccol, #&FF00
        AND      $srcgreen, $srccol, #&FF0000
        MOV      $srcred, $srcred, LSR #8
        MOV      $srcgreen, $srcgreen, LSR #16
        AND      $rload, $load, #&FF00
        AND      $gload, $load, #&FF0000
        MOV      $rload, $rload, LSR #8
        MOV      $gload, $gload, LSR #16
      |
        UXTB     $srcred, $srccol, ROR #8
        UXTB     $srcgreen, $srccol, ROR #16
        UXTB     $rload, $load, ROR #8
        UXTB     $gload, $load, ROR #16
      ]
        ; Get closest RGB values
        LDR      $redvals, [$bluevals, $srcred, LSL #2]
        MOV      $srcblue, $srccol, LSR #24
        LDR      $greenvals, [$bluevals, $srcgreen, LSL #2]
        MOV      $bload, $load, LSR #24
        LDR      $bluevals, [$bluevals, $srcblue, LSL #2]
        ; Get to work!
00
    [ NoARMv6 :LOR: SlowMultiply
        ; If no ARMv6, can't use MUL with Rd==Rn
        ; This makes things a bit ugly because we don't have any spare regs
      [ SlowMultiply
        SUBS     $temp1, $srcred, $redvals, LSR #24
        RSBLT    $temp1, $temp1, #0
      |
        SUB      $temp1, $srcred, $redvals, LSR #24
      ]   
        MUL      $temp3, $temp1, $temp1         ; squared red error in temp3
      [ SlowMultiply
        SUBS     $temp2, $srcgreen, $greenvals, LSR #24
        RSBLT    $temp2, $temp2, #0
      |
        SUB      $temp2, $srcgreen, $greenvals, LSR #24
      ]
        MUL      $temp1, $temp3, $rload         ; weighted red error in temp1
        MUL      $temp3, $temp2, $temp2         ; squared green error in temp3
      [ SlowMultiply
        SUBS     $temp2, $srcblue, $bluevals, LSR #24
        RSBLT    $temp2, $temp2, #0
      |
        SUB      $temp2, $srcblue, $bluevals, LSR #24
      ]
        MLA      $temp1, $temp3, $gload, $temp1 ; accumulate weighted green error
        MOV      $redvals, $redvals, ROR #24    ; advance to next tint
        MUL      $temp3, $temp2, $temp2         ; squared blue error in temp3
        MOV      $greenvals, $greenvals, ROR #24
        MLA      $temp1, $temp3, $bload, $temp1 ; accumulate weighted blue error      
        MOV      $bluevals, $bluevals, ROR #24
        ; Final error in $temp1
    |
        ; $temp1 = red error, $temp2 = green error, $temp3 = blue error
        SUB      $temp1, $srcred, $redvals, LSR #24
        SUB      $temp2, $srcgreen, $greenvals, LSR #24
        SUB      $temp3, $srcblue, $bluevals, LSR #24
        MUL      $temp1, $temp1, $temp1
        MOV      $redvals, $redvals, ROR #24    ; advance to next tint
        MUL      $temp2, $temp2, $temp2
        MOV      $greenvals, $greenvals, ROR #24
        MUL      $temp3, $temp3, $temp3
        MOV      $bluevals, $bluevals, ROR #24
        MUL      $temp1, $temp1, $rload
        MLA      $temp1, $temp2, $gload, $temp1
        MLA      $temp1, $temp3, $bload, $temp1
        ; Final error in $temp1
    ]
        ; Speculative calculation of final RGB while waiting for MLA result
      [ NoARMT2
        MOV      $temp2, $redvals, LSL #24
        MOV      $temp2, $temp2, LSR #8
        ORR      $temp2, $temp2, $greenvals, LSL #24
        MOV      $temp2, $temp2, LSR #8
        CMP      $temp1, $error
        ORR$test $newcol, $temp2, $bluevals, LSL #24
      |
        MOV      $temp2, $bluevals, LSL #24
        BFI      $temp2, $greenvals, #16, #8
        BFI      $temp2, $redvals, #8, #8
        CMP      $temp1, $error
        MOV$test $newcol, $temp2
      ]
        MOV$test $error, $temp1
        TST      $redvals, #&3 ; Check for tint=0, indicating 4 iterations
        BNE      %BT00
        MEND

;
; Convert24Number - convert the above format to the ARM colour number
; format:-
;
;            76543210
;            BGGRBRTT
;
        MACRO
$label  Convert24Number $col, $number, $temp1

$label  AND     $temp1, $col, #&80000000        ; B   (needs >> 24)
        MOV     $number, $temp1, LSR #24
        AND     $temp1, $col, #&C00000          ; GG  (needs >> 17)
        ORR     $number, $number, $temp1, LSR #17
        AND     $temp1, $col, #&8000            ; R   (needs >> 11)
        ORR     $number, $number, $temp1, LSR #11
        AND     $temp1, $col, #&40000000        ; B   (needs >> 27)
        ORR     $number, $number, $temp1, LSR #27
        AND     $temp1, $col, #&7000            ; RTT (needs >> 12)
        ORR     $number, $number, $temp1, LSR #12
        MEND
;
; Convert24GCOL - convert the above format to the ARM colour number
; format:-
;
;            76543210
;            BBGGRRTT
;
        MACRO
$label  Convert24GCOL $col, $number, $temp1

$label  AND     $temp1, $col, #&C0000000        ; BB   (needs >> 24)
        MOV     $number, $temp1, LSR #24
        AND     $temp1, $col, #&C00000          ; GG   (needs >> 18)
        ORR     $number, $number, $temp1, LSR #18
        AND     $temp1, $col, #&F000            ; RRTT (needs >> 12)
        ORR     $number, $number, $temp1, LSR #12
        MEND
;
;----------------------------------------------------------------------
;
; INTERFACE best_colourXXX
;
; Finds the index (returned in R2) of the closest colour to the
; colour given in R2.  If two colours are equally good the one
; with the lowest index in the table is returned.
;
; This interface trashes ALL the registers EXCEPT:-
;
;    R0   colour table start             PRESERVED
;    R1   colour table end +4            IN
;         == R0 (colour table start)     OUT
;    R2   colour to check (BBGGRRxx)     IN
;         index of colour within table   OUT
;    R3   error loading value (BBGGRRxx) IN
;         used as a temporary            TRASHED
;    R4   error for given colour         OUT
;    R12  Workspace pointer              PRESERVED
;
; LR is the return address, and is trashed.  Notice that the routine
; preserves the workspace pointer in r12 - the previous best_colour
; interface did not do this (on the other hand, it did preserve
; other registers - WATCH OUT!)
;
best_colour_fast
        Push    "wp, lr"
        MOV     r4, #&FFFFFFFF                  ; initial error
        FindCol LS,r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r14
        Pull    "wp, pc"
;
; This alternative interface preserves registers; ONLY the following
; registers are used or altered:-
;
;    R0  colour table start          PRESERVED
;    R1  colour table end +4         PRESERVED
;    R2  colour to check (BBGGRRxx)  IN
;        index of colour in table    OUT
;    LR  return address              IN
;        used as a temporary         TRASHED
;
best_colour_safe
        Push    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,lr"
      [ newcalibration
        LDR     r3, [wp, #Calibration_ptr]
        TEQ     r3, #0
        BLNE    convert_screen_colour
      ]
        LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
        BL      best_colour_fast
        Pull    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,pc"

;
; Finds the index (returned in R2) of the closest ARM VIDC 256 entry
; palette colour to the colour given in R2.  If two colours are equally
; good the one with the highest tint is returned.  The value returned is
; a RISC OS colour number NOT a GCOL value.
;
;    R2  colour to check (BBGGRRxx)  IN
;        index of colour in table    OUT
;
best_colour256_safe
        Entry   "r0-r1,r3-r12"
      [ newcalibration
        LDR     r3, [wp, #Calibration_ptr]
        TEQ     r3, #0
        BLNE    convert_screen_colour
      ]
        LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
        MOV     r4, #&FFFFFFFF
        Find256 LO,r2,r3,r4,r0,r1,r5,r6,r7,r8,r9,r10,r11,r12,r14
        Convert24Number r0,r2,r5
        EXIT

;
;----------------------------------------------------------------------
;
; INTERFACE worst_colour_XXX
;
; Finds the index (returned in R2) of the furthest colour from the
; colour given in R2.  If two colours are equally good the one
; with the highest index in the table is returned.
;
; This interface trashes ALL the registers EXCEPT:-
;
;    R0   colour table start             PRESERVED
;    R1   colour table end +4            IN
;         == R0 (colour table start)     OUT
;    R2   colour to check (BBGGRRxx)     IN
;         index of colour within table   OUT
;    R3   error loading value (BBGGRRxx) IN
;         used as a temporary            TRASHED
;    R4   error for given colour         OUT
;    R12  Workspace pointer              PRESERVED
;
; LR is the return address, and is trashed.  As with the best_colour
; routines the work space pointer is preserved, but other things are
; damaged.
;
worst_colour_fast
        Push    "wp, lr"
        MOV     r4, #&0                  ; initial error
        FindCol HI,r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r14
        Pull    "wp, pc"
;
; There is no register preserving interface - this routine is only
; used in one place so this would be a waste of ROM space!  The
; following code is therefore commented out...
;
; This alternative interface preserves registers; ONLY the following
; registers are used or altered:-
;
;    R0  colour table start          PRESERVED
;    R1  colour table end +4         PRESERVED
;    R2  colour to check (BBGGRRxx)  IN
;        index of colour in table    OUT
;    LR  return address              IN
;        used as a temporary         TRASHED
;
worst_colour_safe
        Push    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,lr"
      [ newcalibration
        LDR     r3, [wp, #Calibration_ptr]
        TEQ     r3, #0
        BLNE    convert_screen_colour
      ]
        LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
        BL      worst_colour_fast
        Pull    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,pc"

;
;
; Finds the index (returned in R2) of the furthest ARM VIDC 256 entry
; palette colour from the colour given in R2.  If two colours are equally
; good the one with the lowest tint is returned.  The value returned is
; a RISC OS colour number NOT a GCOL value.
;
;    R2  colour to check (BBGGRRxx)  IN
;        index of colour in table    OUT
;
worst_colour256_safe
        Entry   "r0-r1,r3-r12"
      [ newcalibration
        LDR     r3, [wp, #Calibration_ptr]
        TEQ     r3, #0
        BLNE    convert_screen_colour
      ]
        LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
        MOV     r4, #0
        Find256 HS,r2,r3,r4,r0,r1,r5,r6,r7,r8,r9,r10,r11,r12,r14
        Convert24Number r0,r2,r5
        EXIT

;
; Core code for finding the nearest greyscale colour in standard (RISC OS 5)
; 256 grey modes (palette entry 0 = black, 255 = white). This means that
; calculation of the nearest greyscale value is as simple as:
;
; (red*rload + green*gload + blue*bload)/(rload+gload+bload)
;
; However this macro leaves the division to the caller, as best_colour256_grey
; will want to perform the division but worst_colour256_grey won't.
;
; In:
;  r2 = colour &BBGGRRxx
; Out:
;  lr = numerator
;  r0 = divisor
;  r1-r5 corrupt
;  r2 = 255 if $worst = "worst"
;
        MACRO
        Find256Grey_Core $worst
        LDR     r5, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
    [ NoARMv6
        MOV     r0, r2, LSR #24         ; red
        AND     r1, r2, #&FF0000        ; green (shifted)
        AND     r2, r2, #&FF00          ; blue (shifted)
        MOV     r3, r5, LSR #24         ; rload
        AND     r4, r5, #&FF0000        ; gload (shifted)
        AND     r5, r5, #&FF00          ; bload (shifted)
        MUL     lr, r0, r3              ; red*rload
        MOV     r1, r1, LSR #16
        MOV     r4, r4, LSR #16
        ADD     r0, r3, r5, LSR #8      ; rload+bload
        MUL     r5, r2, r5              ; blue*bload in high 16 bits
        ADD     r0, r0, r4              ; rload+gload+bload
        MLA     lr, r1, r4, lr          ; red*rload + green*gload
      [ "$worst" = "worst"
        MOV     r2, #255                ; Use up a spare cycle
      ]
        ADD     lr, lr, r5, LSR #16     ; red*rload + green*gload + blue*bload
    |
        MOV     r0, r2, LSR #24         ; red
        UXTB    r1, r2, ROR #16         ; green
        UXTB    r2, r2, ROR #8          ; blue
        MOV     r3, r5, LSR #24         ; rload
        UXTB    r4, r5, ROR #16         ; gload
        MUL     lr, r0, r3              ; red*rload
        UXTB    r5, r5, ROR #8          ; bload
        MLA     lr, r2, r5, lr          ; red*rload + blue*bload
        ADD     r0, r3, r5              ; rload+bload
        MLA     lr, r1, r4, lr          ; red*rload + blue*bload + green*gload
        ADD     r0, r0, r4              ; rload+gload+bload
      [ "$worst" = "worst"
        MOV     r2, #255                ; Use up a spare cycle
      ]
    ]
        ADD     lr, lr, r0, LSR #1      ; round to nearest during divide
        MEND

;
; Finds the index (returned in R2) of the closest greyscale colour to the
; colour given in R2.  The palette is assumed to be a linear gradient from 0
; to 255.
;
best_colour256_grey
        Entry   "r0-r1,r3-r5"
        Find256Grey_Core
        DivRem  r2, lr, r0, r1, norem
        EXIT

;
; Find the worst possible greyscale colour. This will either be black (0) or
; white (255). Implementation is basically as above, except we can skip the
; divide as we only need to compare against 128
;
worst_colour256_grey
        Entry   "r0-r1,r3-r5"
        Find256Grey_Core worst          ; will initialise r2 with 255
        CMP     lr, r0, LSL #7          ; will lr/r0 be >= 128?
        MOVGE   r2, #0                  ; yes: black is worst
        EXIT

;
; Lookup table for Find256. Generated using the following bit of BASIC,
; which is based around the code that was in the original Find256 macro.
;
; FOR srccol%=0 TO 255
; val%=0
; FOR tint%=0 TO &30 STEP 16
; temp1%=&20-tint%
; temp2%=srccol%-(srccol%>>4)
; temp1%+=temp2%
; IF temp1%>&FF THEN temp1%=&FF
; IF temp1%<0 THEN temp1%=0
; newcol%=(temp1% AND &C0)+tint%
; newcol%+=newcol%>>4
; val%+=newcol%<<(tint%/2)
; NEXT tint%
; PRINT "        DCD     &";STR$~(val%)
; NEXT srccol%
;
Find256_Table
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221100
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33221144
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33225544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &33665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665544
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77665588
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77669988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &77AA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA9988
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAA99CC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBAADDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &BBEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC
        DCD     &FFEEDDCC

        END
@


4.5
log
@Objasm warning fixes: Escape dollar contained in string, fix macro reference
Detail:
  s/Commons - Fix reference to Find256 macro; Find256_Fast was the name I was using during development of this new version
  s/Header - Escape dollar contained in string
Admin:
  Resulting binary unchanged


Version 1.91. Retagged as 'Colours-1_91'
@
text
@d1288 1
a1288 1
        DivRem  r2, lr, r0, r1
@


4.4
log
@Performance improvements
Detail:
  A selection of performance improvements, mainly focusing around fixing the terrible ColourTrans_SelectTable performance when using the default 256 colour palette in a full 256 colour mode (i.e. not VIDC1 style)
  s/Header:
  - Add flag for whether MUL of large or negative numbers is slow
  s/Commons:
  - Update palette analysis code so that C256 modes with the default palette can use the same optimised routines as C64 modes with default palette.
  - Also detect G256 modes with the default palette and add a new set of best/worst colour routines for them
  - Remove unused ColErr macro and (now inaccurate) ARM2/ARM3 timing calculations
  - Optimised CompErr macro (used with slow best/worst colour functions). Three different variants depending on CPU, with the Cortex-A8 version being about twice as fast as the original.
  - Rewrote Find256 macro (used with default 256 colour palette), producing four different versions depending on CPU. Even the ARM2 compatible version should be about twice as fast as the original.
  - Strip out a few pointless best/worst wrapper functions
  s/NewModels:
  - Update ColourTrans_ConvertHSVToRGB to make use of SMULL where supported
Admin:
  Tested on Iyonix, BB-xM, StrongARM RiscPC
  Palette analysis fix means 256 colour modes using default RO 5 icon sprites (i.e. custom 256 colour palettes) are no longer as slow as treacle.
  256 grey modes are also nice and snappy too.


Version 1.88. Tagged as 'Colours-1_88'
@
text
@d1218 1
a1218 1
        Find256_Fast HS,r2,r3,r4,r0,r1,r5,r6,r7,r8,r9,r10,r11,r12,r14
@


4.3
log
@Update to cope with new pixel formats
Detail:
  s/Commons - Update best/worst colour code to add support for all the new RGB pixel format variations
  s/Dither - Rework code to remove reliance on now removed get_physical16bpp routine
  s/Enhanced - Drop support for VIDC enhancer. "VIDC20" code enhanced to add support for all the new RGB pixel formats, mainly reliant on new ColourConv macro. Drop get_physical16bpp routine as it wasn't really needed and would have been a pain to update.
  s/FontColours - Remove reference to obsolete PseudoPaletteEntry variable
  s/Header - Update workspace to clarify how certain variables are overlaid over the colour cache entries. Rename temp_guardtable to temp_errortable as the name makes more sense to me. Cache current modeflags & log2 NColour in InitCache.
  s/MainSWIs - Flag_* -> ModeFlag_* renaming. Pass through source mode to make32Ktable
  s/Palettes - Strip out some old Module_Version switches to make code more readable. Cache current modeflags and log2 NColour values when dealing with sprite output.
  s/Tables32K - Table generation code rewritten to add support for new 16bpp pixel formats, be faster, and (hopefully) more readable. Core generation code has been split off into seperate file, s/TablesAlgo, as it's needed multiple times but is too big for a macro.
  s/TablesAlgo - New file containing core code for the "32K" table generation. Disregarding pixel format differences, it can be assembled in two forms, optimised either for large or small data caches. New code is 85% faster on BB-xM (large cache version), 43% faster on Iyonix and 80% faster on StrongARM (both small cache version).
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification
  Code is in need of updating to allow caller to identify which type of 32K table has been returned (i.e. old-style 32K table or some new kind of 4K/32K/64K one)


Version 1.86. Tagged as 'Colours-1_86'
@
text
@d36 2
a37 1
;       if 8BPP, brain-damaged and default palette then =rc_Fast256
d70 1
a447 1
        TSTEQ   R4,#ModeFlag_FullPalette ;Is it brian damaged... borring
d455 5
a459 1
        Debug   buildcolours2,"Check for fast colour matching"
d476 1
d499 46
d570 1
d621 3
a734 27
;----------------------------------------------------------------------
; MACRO ColErr
;
; Calculates an error value in $error corresponding to the difference
; between the two colours $col1 and $col2.  Requires two temporary
; registers.  All registers must be different.  This routine requires
; 20 instructions, six of which are multiples.  The routine also requires
; a packed loading value ($load) and a register constant with value
; 255 (this is preserved).
;
; Multiply instruction timing: the multiply instruction implementation
; is under the control of the third operand, which is repeatedly shifted
; by two bits at a time.  When the operand becomes zero the multiply
; is complete (the actual register contents are not, of course, modified).
; So, for fastest multiply, put a small POSITIVE argument in the third
; operand.
;
; The consequence of this is that, in the following macro, the upper
; limit of the MUL instructions which square the error is 1S+5I, the
; time for the loading multiplications can be calculated exactly given
; the loadings, hence:-
;
;  loading         1,1,1   1,2,3   1,3,10
;  max total time 20S+18I 20S+20I 20S+21I
;
        MACRO
$label  ColErr  $error, $col1, $col2, $load, $temp1, $temp2, $t255
a735 25
$label  MOV     $temp1, $col1, LSR #24
        SUBS    $temp2, $temp1, $col2, LSR #24
        RSBLT   $temp2, $temp2, #0             ; speed multiplication
        MUL     $temp1, $temp2, $temp2
        MOV     $temp2, $load, LSR #24
        MUL     $error, $temp1, $temp2         ; loading will be small
        ; $error contains blue term
        ; Use $t255, which must contain 255, to extract the green
        ; components
        AND     $temp1, $t255, $col1, LSR #16
        AND     $temp2, $t255, $col2, LSR #16
        SUBS    $temp2, $temp1, $temp2         ; green error
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        AND     $temp2, $t255, $load, LSR #16  ; green load
        MLA     $error, $temp1, $temp2, $error
        ; Repeat for the red term
        AND     $temp1, $t255, $col1, LSR #8
        AND     $temp2, $t255, $col2, LSR #8
        SUBS    $temp2, $temp1, $temp2         ; red error
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        AND     $temp2, $t255, $load, LSR #8   ; red load
        MLA     $error, $temp1, $temp2, $error
        MEND
d746 1
a746 10
; if desired.  The calculation needs 14 instructions, including six
; multiplies.
;
; Timing calculations show the following:-
;
;  loading         1,1,1   1,2,3   1,3,10
;  max total time 14S+18I 14S+20I 14S+21I
;
; So this macro is 6S cycles quicker than the ColErr macro (note that
; the multiply instructions cost the same in each case).
d751 4
a754 1
$label  SUBS    $temp2, $blue, $col, LSR #24
d756 3
d763 1
d766 3
d773 1
d776 3
d781 16
d822 1
a822 23
; table.  The whole table is always searched.  The following timings
; are derived from those for CompErr.  Overhead is 8S cycles, loop
; cost is 5S+1N+1I plus the CompErr macro cost, plus the branch instruction
; cost (2S+1N, minus 1S+1N at loop end).  This gives:-
;
; Overhead:  7S-1N
; Loop:      CompErr+7S+2N+1I
;
;  loading                 1,1,1            1,2,3            1,3,10
;  loop cost          21S+  2N+  19I   21S+  2N+  21I   21S+  2N+  22I
;  2 colour table     49S+  3N+  38I   49S+  3N+  42I   49S+  3N+  44I
;  4 colour table     91S+  7N+  76I   91S+  7N+  84I   91S+  7N+  88I
;  16 colour table   343S+ 31N+ 304I  343S+ 31N+ 336I  343S+ 31N+ 352I
;  256 colour table 5383S+511N+4864I 5383S+511N+5376I 5383S+511N+5632I
;
; This corresponds to times, in microseconds, of:-
;
;         CPU                ARM2(8MHz)           ARM3(26MHz+12MHz)
;        16 colour table       95                     ~31
;       256 colour table      1500                    ~500
;
; (Note that this assumes the code is running out of RAM; 256 entry
; lookup running out of ROM takes 2.2 milliseconds).
d881 7
d892 11
a902 13
; $test      Comparison to perform: LS, LO, HS or HI
; $srccol    BBGGRRxx colour to check                 PRESERVED
;            Index of colour in table                 OUT
; $load      Error loading in format BBGGRRxx         PRESERVED
; $error     Error value for colour $srccol           OUT
; $tint      TEMPORARY
; $col       TEMPORARY
;            24 bit colour value                      OUT
; $temp1     TEMPORARY
; $temp2     TEMPORARY
; $newerr    TEMPORARY
; $newcol    TEMPORARY
; $t255      MUST contain the value #255 on entry     PRESERVED
a909 19
; All arguments must be different registers.  The body of the loop is 48
; instructions, including the normal six multiplies.  The code goes
; round it four times, there is a further 12 instruction overhead plus
; three taken branch instructions.  The maximum error on any component
; value is 51 (&33), because each tint value is tried the average error
; over the four loops will, however, be less - the worst possible case
; errors still mean quicker multiplies for two of the error calculations.
; This allows more accurate prediction of the loop timings, depending on
; the loadings the timings are approximately:-
;
;  loading                 1,1,1       1,2,3      1,3,10
;  max single loop time  48S+15I     48S+17I     48S+18I
;  max total loop time  192S+51I    192S+59I    192S+63I
;  max total time       200S+51I+3N 200S+59I+3N 200S+63I+3N
;
; This gives a search time:-
;                  ARM2: 34 microseconds
;                  ARM3: 11 microseconds
;
a924 13
; Following comments are supposed to be in the body of the macro...
;
        ;See COMMENTS? below...
        ; At this point the top bits of $temp1 hold the best blue bit values
        ; given the current $tint tint bits, however the desired value may
        ; be >11tt or <00tt, in either case the top bit (bit 31) of $temp1
        ; will be set, hence the N flag will be set in the PSR.  We must
        ; distinguish overflow (>11tt) from a simple negative result (<00tt)
        ; and truncate both to the appropriate end of the scale.  We have
        ; calculated (blue-tint+&22)<<23.  The overflow (V) flag will ONLY
        ; be set for >11tt; the other possible results (in the range &FF<<23
        ; to -&17<<23 are representable without overflow), so:-
        ;
d927 1
a927 1
$label  Find256  $test, $srccol, $load, $error, $tint, $comp, $col, $temp1, $temp2, $newerr, $newcol, $t255
d929 100
a1028 2
        ; $t255 MUST contain the value 255...
$label  MOV     $tint, #&30:SHL:23              ; tint bits unexpanded
a1029 86
00      RSB     $temp1, $tint, #&20:SHL:23      ; overflow not possible here
        MOV     $comp, $srccol, LSR #24         ; extract blue component
        SUB     $temp2, $comp, $comp, LSR #4    ; ~multiplication by 16/17
        ADDS    $temp1, $temp1, $temp2, LSL #23
        ;
        ; *** COMMENTS?  See above (AAsm objects to macro length...)
        ;
        MOVVSS  $temp1, #&7F000000              ; clears the N flag!
        MOVMI   $temp1, #0
        ;
        ; Now extract the blue bits and reconstruct the real (expanded)
        ; blue value.
        ;
        AND     $temp1, $temp1, #&60000000      ; two blue bits
        ADD     $temp1, $temp1, $tint           ; plus tint
        ADD     $newcol, $temp1, $temp1, LSR #4 ; expand component bits -
                                                ; 8 bit blue value
        ;
        ; Calculate the error as in previous macros.
        ;
        SUBS    $temp2, $comp, $newcol, LSR #23
        RSBLT   $temp2, $temp2, #0              ; speeds up multiplication
        MUL     $temp1, $temp2, $temp2
        MOV     $temp2, $load, LSR #24          ; blue error loading
        MUL     $newerr, $temp1, $temp2         ; loading will be small
        ;
        ; Repeat this for the green component, accumulating the error
        ;
        RSB     $temp1, $tint, #&20:SHL:23
        AND     $comp, $t255, $srccol, LSR #16
        SUB     $temp2, $comp, $comp, LSR #4
        ADDS    $temp1, $temp1, $temp2, LSL #23
        MOVVSS  $temp1, #&7F000000
        MOVMI   $temp1, #0
        ;
        AND     $temp1, $temp1, #&60000000       ; two green bits
        ADD     $temp1, $tint, $temp1            ; 4 bit green value
        ADD     $temp1, $temp1, $temp1, LSR #4   ; expand component bits
        ORR     $newcol, $newcol, $temp1, LSR #8 ; Accumulate bits in $newcol
        ;
        SUBS    $temp2, $comp, $temp1, LSR #23
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        AND     $temp2, $t255, $load, LSR #16
        MLA     $newerr, $temp1, $temp2, $newerr
        ;
        ; And the red component:-
        ;
        RSB     $temp1, $tint, #&20:SHL:23
        AND     $comp, $t255, $srccol, LSR #8
        SUB     $temp2, $comp, $comp, LSR #4
        ADDS    $temp1, $temp1, $temp2, LSL #23
        MOVVSS  $temp1, #&7F000000
        MOVMI   $temp1, #0
        ;
        AND     $temp1, $temp1, #&60000000       ; two red bits
        ADD     $temp1, $tint, $temp1            ; 4 bit red value
        ADD     $temp1, $temp1, $temp1, LSR #4   ; expand component bits
        ORR     $newcol, $newcol, $temp1, LSR #16; Accumulate bits in $newcol
        ;
        SUBS    $temp2, $comp, $temp1, LSR #23
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        AND     $temp2, $t255, $load, LSR #8
        MLA     $newerr, $temp1, $temp2, $newerr
        ;
        ; $newerr contains the error for the ARM value in $newcol (actually
        ; this value is shifted right by 1 bit because of the LSL 23 above).
        ; Check the error and see if this is a better pixel.
        ;
        CMP      $newerr, $error
        MOV$test $error, $newerr               ; $test determines result
        MOV$test $col, $newcol, LSL #1         ; $col holds best match
        ;
        ; Try the next tint
        ;
        SUBS    $tint, $tint, #&10:SHL:23
        BGE     %BT00
        ;
        ; $error is the error, and is directly comparable with the $error
        ; value from the other macros.  $col is a 24 bit RGB value in the
        ; format:-
        ;
        ;       BBTTBBTT GGTTGGTT RRTTRRTT 00000000
        ;
        MEND
d1117 1
a1117 1
         LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
d1120 1
a1126 21
; This interface trashes ALL the registers EXCEPT:-
;
;    R0   not used                       PRESERVED
;    R1   set to 255                     TRASHED
;    R2   colour to check (BBGGRRxx)     IN
;         index of colour within table   OUT
;    R3   error loading value (BBGGRRxx) PRESERVED
;    R4   error for given colour         OUT
;    R12  Workspace pointer              PRESERVED
;
; LR is the return address, and is preserved.
;
best_colour256_fast
        MOV     r4, #&FFFFFFFF                  ; initial error
        MOV     r1, #255                        ; macro needs this...
        Find256 LO,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r1
        Convert24Number r7, r2, r5
        MOV     pc, lr
;
; This version of the same interface preserves all the registers except:
;
a1128 2
;    LR  return address              IN
;        used as a temporary         TRASHED
d1131 1
a1131 1
        Push    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,lr"
d1138 5
a1142 2
        BL      best_colour256_fast
        Pull    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,pc"
d1195 1
a1195 1
         LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
d1198 1
a1205 21
; This interface trashes ALL the registers EXCEPT:-
;
;    R0   not used                       PRESERVED
;    R1   set to 255                     TRASHED
;    R2   colour to check (BBGGRRxx)     IN
;         index of colour within table   OUT
;    R3   error loading value (BBGGRRxx) PRESERVED
;    R4   error for given colour         OUT
;    R12  Workspace pointer              PRESERVED
;
; LR is the return address, and is preserved.
;
worst_colour256_fast
        MOV     r4, #&0                         ; initial error
        MOV     r1, #255                        ; macro needs this...
        Find256 HS,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r1
        Convert24Number r7, r2, r5
        MOV     pc, lr
;
; This version of the same interface preserves all the registers except:
;
a1207 2
;    LR  return address              IN
;        used as a temporary         TRASHED
d1210 1
a1210 1
        Push    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,lr"
d1217 362
a1578 2
        BL      worst_colour256_fast
        Pull    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,pc"
@


4.2
log
@32-bit compatible.

Version 1.69. Tagged as 'Colours-1_69'
@
text
@d55 14
a68 2
rc_Enhanced16   * 2
rc_Enhanced32   * 3
d174 10
a183 6

        ;removed 1.54 - causes problems with tilesprite in desktop.
        MOV R4,#0
;        TEQ     R3,#3
;        MOVEQ   R4,#Flag_FullPalette    ;treat any 8bpp sprite as full palette here
;        MOVNE   R4,#0
d195 3
d243 1
a243 1
        TSTEQ   R4,#Flag_FullPalette    ;Does it have a full palette?
d405 4
d412 21
a432 4
        Debug   buildcolours,"16/32bpp mode, R3=",R3
        TEQ     R3,#4                   ;If its 16 bits per pixel
        MOVEQ   R7,#rc_Enhanced16       ;Then setup for the correct routine
        MOVNE   R7,#rc_Enhanced32       ;Otherwise define to be at 32 bits per pixel
d446 1
a446 1
        TSTEQ   R4,#Flag_FullPalette    ;Is it brian damaged... borring
d504 14
a517 2
        ASSERT  rc_Enhanced16  =2
        ASSERT  rc_Enhanced32  =3
d520 38
a557 2
        & best_colour_safe     -routinetable
        & worst_colour_safe    -routinetable
d559 2
a560 2
        & best_colour256_safe  -routinetable
        & worst_colour256_safe -routinetable
d562 2
a563 2
        & best_colour16bpp     -routinetable
        & worst_colour16bpp    -routinetable
d565 2
a566 2
        & best_colour32bpp     -routinetable
        & worst_colour32bpp    -routinetable
@


4.1
log
@Initial revision
@
text
@d18 1
a18 1
; 
d20 1
a20 1
;    
d30 1
a30 1
; routine is building the specified table it uses R7 as an index into a 
d35 1
a35 1
;       default =rc_Simple 
d37 1
a37 1
;              
d40 1
a40 1
; 
d50 1
a50 1
;               R7 ->routine to call to find best colour 
d61 1
a61 1
   
d63 1
a63 1
                         
d73 1
a73 1
                  
d75 1
a75 1
                 
d77 2
a78 2
        TEQ     R3,#0                   ;Has the palette already been cached?
        BNE     build_colourscached   
d81 1
a81 1
                          
d91 3
a93 2
        
        Pull    "R3,R6,PC",,^           ;Return because done
d100 1
a100 1
        Pull    "R3,R6,PC",,^
d103 1
a103 1
; 
d116 1
a116 1
        
d128 2
a129 2
                 
        LDR     R10,[WP,#PaletteAt]     ;->Palette table 
d136 1
a136 1
        STREQ   LR,[WP,#PaletteAt]                                           
d146 2
a147 2
;mode word        
           
d157 1
a157 1
        ;so it is a sprite mode word             
d162 1
a162 1
                            
d166 2
a167 2
;        MOVEQ   R4,#Flag_FullPalette    ;treat any 8bpp sprite as full palette here          
;        MOVNE   R4,#0   
d175 1
a175 1
        MOVCC   R3,R2                   
d179 6
a184 5
         
        STRCS   R10,[WP,#PaletteAt]     ;Restore palette table is at pointer
        Pull    "R2-R5,R10-R11,LR",CS
        BadMODE CS
        BCS     LookupError             ;Balance stack and return bad mode error if not valid
d189 1
a189 1
        
d197 1
a197 1
                                        
d199 1
a199 1
        
d210 1
a210 1
                                               
d214 2
a215 2
        BEQ     buildcurrent            
                
d220 1
a220 1
        ADDLE   R1,R1,R0                
d226 1
a226 1
 
d230 1
a230 1
; 
d235 1
a235 1
; from these up to the final values. 
d241 1
a241 1
; 
d247 1
a247 1
                                    
d269 1
a269 1
        STR     R4,[R6,R9,ASL #2]       ;Store into the table 
d282 1
a282 1
; 
d287 1
a287 1
; 
d293 1
a293 1
; 
d299 1
a299 1
 
d306 1
a306 1
        MOV     R2,R4                   ;Take a temporary copy of R4                 
d318 2
a319 2
        B       buildslowloop           ;Loop until all written back 
                     
d321 1
a321 1
        Pull    "R0,R1" 
d326 1
a326 1
; 
d330 1
a330 1
; at R6 with suitable palette data. 
d334 1
a334 1
; 
d341 1
a341 1
; 
d347 1
a347 1
           
d356 1
a356 1
 
d359 1
a359 1
                                        ;R1 = colour type (16 here) 
d374 2
a375 2
        
buildcurrentexit                    
d389 1
a389 1
        Debug   buildcolours,"16/32bpp mode, R3=",R3                       
d398 1
a398 1
; 
d402 1
a402 1
               
d408 1
a408 1
        
d428 1
a428 1
        TEQ     R5,LR   
d430 1
a430 1
                                   
d437 2
a438 2
        Debug   buildcolours2," routine index",R7                        
                
d443 2
a444 2
        ADD     R8,R8,LR                ;-> worst colour routine          
        
d450 2
a451 1
        Pull    "R2-R5,R10-R11,PC",,^
d454 1
a454 1
; 
d461 1
a461 1
; 
d473 1
a473 1
        
d483 1
a483 1
; 
d561 1
a561 1
                          
d1044 1
a1044 1
; 
d1142 1
a1142 1
; 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

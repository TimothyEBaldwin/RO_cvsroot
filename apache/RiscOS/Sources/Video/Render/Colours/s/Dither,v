head	4.5;
access;
symbols
	Colours-1_95:4.5
	Colours-1_94:4.5
	Colours-1_93:4.4
	Colours-1_92:4.4
	Colours-1_91:4.4
	Colours-1_90:4.4
	Colours-1_89:4.4
	Colours-1_88:4.4
	Colours-1_87:4.4
	Colours-1_86:4.4
	Colours-1_85:4.3
	Colours-1_84:4.3
	Colours-1_83:4.3
	Colours-1_82:4.3
	Colours-1_81:4.3
	Colours-1_80:4.3
	Colours-1_79:4.3
	Colours-1_78:4.3
	Colours-1_77:4.3
	RO_5_07:4.2
	Colours-1_76:4.2
	Colours-1_75:4.2
	Colours-1_74:4.2
	Colours-1_73:4.2
	Colours-1_72:4.2
	dellis_autobuild_BaseSW:4.2
	Colours-1_71:4.2
	Colours-1_70:4.2
	Colours-1_69:4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	Colours-1_68:4.1
	Colours-1_67:4.1
	Ursula_merge:4.1
	nturton_Colours-1_65:4.1
	dcotton_colours_MPTInitialBuild:4.1.7.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2016.05.08.17.31.21;	author jlee;	state Exp;
branches;
next	4.4;
commitid	d1ySJ33i6bBREH5z;

4.4
date	2013.08.06.23.49.21;	author jlee;	state Exp;
branches;
next	4.3;
commitid	wewI5Vx1d9Rn5s0x;

4.3
date	2009.06.16.00.23.28;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.12.12.34.33;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.42.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.42.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.08.13;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.48.07;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.11.06;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Avoid unnecessary remainder calculations
Detail:
  s/Commons, s/DevicePal, s/Dither, s/FontColour - Avoid unnecessary remainder calculations in DivRem macro
  s/Header - Remove unused Divide macro
Admin:
  Tested on Cortex-A15


Version 1.94. Tagged as 'Colours-1_94'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Dither

;..............................................................................
;
; getpattern
;
; Return a suitable pattern block based on the specified physical colour,
; the routine will try hitting the cache to see what is allowed and then it
; will return the correct colour table.
;
; in    R2 physical palette entry
;
; out   R0 GCOL
;       R1 colour number
;       R2 log2bpp of the mode
;       R5 ->pattern block containing four words of pattern data

getpattern ROUT

        Push    "R3-R4,R6-R8,R10,LR"

        MOV     R0,R2
        LDRB    R4,[WP,#CachedL2BPP]    ;Get the depth of the current mode

        BL      TryCache                ;Attempt to find in the cache
        MOVEQ   R10,R1
        BEQ     %FT10                   ;Found a suitable cache entry so skip setting one up

        Debug   dither,"Cache does not contain a suitable entry for",R2

        Push    "R0"                    ;Preserve the physical colour
        MOV     R1,#-1
        MOV     R2,#-1                  ;Return for current palette
        BL      ReturnColourNumberForMode_Code
        Pull    "R2"
        BVS     %FT20                   ;Bad idea it went wrong

        TEQ     R4,#3                   ;Is it an 8BPP mode?
        MOV     R1,R0
        BLEQ    ColourNumberToGCOL_Code ;If its an 8BPP mode then setup a suitable GCOL value
        Swap    R0,R1

        Debuga  dither,"Write cache entry for",R2
        Debuga  dither,", GCOL",R0
        Debug   dither,", colour number",R1

        BL      WriteCacheEntry         ;and finally write the cache entry
10
        MOV     R3,R2                   ;Move palette entry to a safe register
        ADD     R5,R10,#CachedPattern   ;->4 word pattern block

        LDRB    LR,[R10,#CachedPatternValid]
        CMP     LR,#&FF                 ;Is the pattern block valid?
        BNE     %FT20                   ;Yup, so no point building a new copy of it

        MOV     R0,#-1
        MOV     R1,#-1                  ;Return for the current mode
        BuildColoursForBest             ;Assemble the current palette and vector into memory

        Debuga  dither,"Current palette from",R0
        Debug   dither," to",R1
        Debug   dither,"Physical palette entry",R3
        Debug   dither,"Log2BPP of mode",R4

        TEQ     R4,#0                   ;Is it a monochrome screen mode
        BLEQ    getpatternmono
        BLNE    getpatterncolour        ;Setup correct pattern block in workspace

        MOV     R0,#0
        STRB    R0,[R10,#CachedPatternValid]
20
        LDRB    R0,[R10,#CachedGCOL]    ;Return the colour number and the GCOL value
        LDRB    R1,[R10,#CachedColour]
        MOV     R2,R4                   ;Return the Log2BPP

        Debug   dither,"GCOL",R0
        Debug   dither,"Colour number",R1
        Debug   dither,"Log2BPP",R2
        Debug   dither,"Pattern at",R5

        Pull    "R3-R4,R6-R8,R10,PC"

;..............................................................................
;
; getpatternmono
;
; Generate a pattern based on the current palette and log2bpp.  This routine
; assumes that it is dealing with a 1BPP mode (R4=0) and attempts to genereate
; a pattern from the 16 byte matrix.
;
; The routine first converts the physical colour into a suitable value ranging
; from 0..16, it then scans through the table looking for colours numbers
; which are less than the value calculated and toggles those bits within
; the pattern block.
;
; The following 4x4 matrix is used:
;
;                  0   8   2  10
;                 12   4  14   6
;                  3  11   1   9
;                 15   7  13   5
;
; Before returning the pattern data it is expanded to fill the entrie 32x8
; pixel block.
;
; in    R0 ->start of palette table
;       R1 ->end of palette table
;       R3 physical palette entry (&BBGGRR00)
;       R4 log2bpp of current mode
;       R5 ->buffer to fill
;
; out   all preserved

getpatternmono ROUT

        EntryS  "R0-R4,R6"

        MOV     R2,#&00000000           ;Background colour for pattern
        GetBestColour
        MOV     R2,R2,LSL #31           ;Shift so in top bit...
        MOV     R2,R2,ASR #31           ;...and back down again (sign extending)

        MOV     R0,#&FF                 ;Suitable mask to get components from palette
        AND     R1,R0,R3,LSR #16        ;Extract the green element
        AND     R0,R0,R3,LSR #8         ;Extract the red element
        MOV     R3,R3,LSR #24           ;Extract the blue element

        MOV     LR,#77
        MUL     LR,R0,LR                ;  77*red
        MOV     R0,#150
        MLA     LR,R1,R0,LR             ;  77*red +150*green
        RSB     R3,R3,R3,LSL #3         ;  7*blue
        ADD     LR,LR,R3,LSL #2         ;  77*red +150*green +28*blue
        ADD     LR,LR,#&7F
        ADD     LR,LR,LR,LSL #8         ;  &101*X
        ADD     LR,LR,#&100             ;  &101*X +&100
        MOV     R0,LR,LSR #16           ; (&101*X +&100) DIV &10000
        LDR     R1,=&10F5C
        MUL     R0,R1,R0
        MOV     R0,R0,LSR #20           ;((&101*X +&100) DIV &10000)*(16/15)

        Debug   dither2,"Background word",R2
        Debug   dither2,"Intensity",R0

        MOV     R1,#3                   ;Write four lines of pattern data
        MOV     R4,#0                   ;Index into horizontal scan lines
        MOV     R6,#2_1                 ;Bit to toggle
        ADR     R7,pattern
00
        Push    "R2"                    ;Preserve background colour
10
        LDRB    LR,[R7],#1              ;Get a byte from the pattern block
        CMP     R0,LR
        EORGT   R2,R2,R6,LSL R4         ;Toggle bit if value > threshold
        ADD     R4,R4,#1
        ANDS    R4,R4,#3                ;Increase bit index and wrap when > 3
        BNE     %BT10                   ;Loop back until a line of pattern data has been compiled

        AND     R2,R2,#&F
        ORR     R2,R2,R2,LSL #4
        ORR     R2,R2,R2,LSL #8
        ORR     R2,R2,R2,LSL #16        ;Combine to make a word of pattern data
        STR     R2,[R5,R1,LSL #2]       ;Which we then store in the specified buffer

        Pull    "R2"                    ;Restore the background word
        SUBS    R1,R1,#1
        BPL     %BT00                   ;Loop back until full pattern has been compiled

        Debug   dither2,"Pattern compiled and at",R5

        EXITS

pattern = 15,7,13,5,3,11,1,9,12,4,14,6,0,8,2,10

        ALIGN

;..............................................................................
;
; getpatterncolour
;
; Convert the specified physical colour into a 4x4 dither pattern for the colour
; depth of mode.  This is a general purpose routine designed to cope with 2,4 and
; 8BPP screens.
;
; The routine generates the 4x4 cell by taking the specified physical palette entry
; and finding the closest entry to it.  It then takes the difference between
; the specified physical colour and the closest and distributes the error to the
; left, and the two pixels bellow, this then gives a block of four pixels that
; represent the specified colour.
;
; The routine then has to order the pixels within the 4x4 grid to avoid noticeable
; aliasing.  This is done by first sorting the colours based on the &BBGGRR00
; so that the highest value is at the top, this ensures that two physical colours
; the same are then ordered into the correct pixels on the grid.
;
; The routine then attempts to find the closest two colours to place in the
; bottom left and top right (giving the checker board effect).  Then the two
; remaining pixels are placed in the top right and bottom left, the top right
; is filled with the pixel value with a lower error than the other.
;
; in    R0 ->start of palette table
;       R1 ->end of palette table
;       R3 physical palette entry (&BBGGRR00)
;       R4 log2bpp of current mode
;       R5 ->buffer to fill
;
; out   all preserved

getpatterncolour ROUT

        EntryS  "R0-R11"

        MOV     LR,#1
        MOV     R4,LR,LSL R4            ;Convert Log2BPP to a suitable shift for replication

        MOV     R2,R3                   ;Find colour of top left pixel (based on the specified RGB)
        GetBestColour
        LDR     R8,[R0,R2,LSL #2]
        BIC     R8,R8,#&000000FF
        ORR     R8,R8,R2                ;Combine real palette entry and colour number

        MOV     R2,R3,LSR #8            ;Calculate the red error to be passed on
        AND     R2,R2,#&FF              ;as R+R-(Ra)
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF00
        SUBS    R9,R2,LR,LSR #8
        MOVMI   R9,#0
        CMP     R9,#&FF
        MOVGT   R9,#&FF

        MOV     R2,R3,LSR #16           ;Calculate the green error to be passed on
        AND     R2,R2,#&FF              ;as G+G-(Ga)
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF0000
        SUBS    R2,R2,LR,LSR #16
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R9,R9,R2,LSL #8

        MOV     R2,R3,LSR #24           ;Calculate the blue error to be passed on
        MOV     R2,R2,LSL #1            ;as B+B-(Ba)
        SUBS    R2,R2,R8,LSR #24
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R2,R9,R2,LSL #16

        MOV     R2,R2,LSL #8            ;Combine to make &BBGGRR00
        GetBestColour                   ;Lookup colour number relating
        LDR     R10,[R0,R2,LSL #2]
        BIC     R10,R10,#&000000FF
        ORR     R10,R10,R2              ;Get palette entry and combine with colour number

        MOV     R2,R3,LSR #8            ;Calculate the red error to be passed on
        AND     R2,R2,#&FF              ;as R+R-(Ra+Rb)/2
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF00
        AND     R11,R10,#&FF00
        ADD     R11,R11,LR
        MOV     R11,R11,LSR #8
        SUBS    R9,R2,R11,ASR #1
        MOVMI   R9,#0
        CMP     R9,#&FF
        MOVGT   R9,#&FF

        MOV     R2,R3,LSR #16           ;Calculate the green error to be passed on
        AND     R2,R2,#&FF              ;as G+G-(Ga+Gb)/2
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF0000
        AND     R11,R10,#&FF0000
        ADD     R11,R11,LR
        MOV     R11,R11,LSR #16
        SUBS    R2,R2,R11,ASR #1
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R9,R9,R2,LSL #8

        MOV     R2,R3,LSR #24           ;Calculate the blue error to be passed on
        MOV     R2,R2,LSL #1            ;as B+B-(Ba+Bb)/2
        MOV     LR,R8,LSR #24
        ADD     R11,LR,R10,LSR #24
        SUBS    R2,R2,R11,ASR #1
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R2,R9,R2,LSL #16

        MOV     R2,R2,LSL #8            ;Munge together to make a palette entry
        GetBestColour                   ;Find the closest possible colour to it
        LDR     R11,[R0,R2,LSL #2]
        BIC     R11,R11,#&000000FF
        ORR     R11,R11,R2              ;Get palette entry and combine with colour number

        Push    "R4,R5"

        MOV     R2,R3,LSR #8            ;Calculate the red error to be passed on
        AND     R2,R2,#&FF              ;as R+R-(Ra+Rb+Rc)/3
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF00
        AND     R6,R10,#&FF00
        AND     R7,R11,#&FF00
        MOV     LR,LR,LSR #8
        ADD     LR,LR,R6,LSR #8
        ADD     LR,LR,R7,LSR #8
        DivRem  R4,LR,#3,R7,norem       ;Howible divide by 3!!!!
        SUBS    R9,R2,R4
        MOVMI   R9,#0
        CMP     R9,#255
        MOVGT   R9,#255

        MOV     R2,R3,LSR #16           ;Calculate the green error to be passed on
        AND     R2,R2,#&FF              ;as G+G-(Ga+Gb+Gc)/3
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF0000
        AND     R6,R10,#&FF0000
        AND     R7,R11,#&FF0000
        MOV     LR,LR,LSR #16
        ADD     LR,LR,R6,LSR #16
        ADD     LR,LR,R7,LSR #16
        DivRem  R4,LR,#3,R7,norem
        SUBS    R2,R2,R4
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R9,R9,R2,LSL #8

        MOV     R2,R3,LSR #24           ;Calculate the green error to be passed on
        MOV     R2,R2,LSL #1            ;as B+B-(Ba+Bb+Bc)/3
        MOV     LR,R8,LSR #24
        ADD     LR,LR,R10,LSR #24
        ADD     LR,LR,R11,LSR #24
        DivRem  R4,LR,#3,R7,norem
        SUBS    R2,R2,R4
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R2,R9,R2,LSL #16

        MOV     R2,R2,LSL #8
        GetBestColour                   ;Combine to make physical colour and lookup
        LDR     R9,[R0,R2,LSL #2]
        BIC     R9,R9,#&000000FF

        MOV     R9,R9,LSR #8            ;Convert the physical colour so that top eight bits are clear
        MOV     R3,R2                   ;Setup the colour number for that pixel
        AND     R2,R11,#&FF             ;Get the pixel value for the next one
        MOV     R11,R11,LSR #8          ;And convert the physical colour aswell
        AND     R1,R10,#&FF
        MOV     R10,R10,LSR #8
        AND     R0,R8,#&FF
        MOV     R8,R8,LSR #8            ;and so on until all four pixels have been seperated from their owners

        CMP     R8,R10                  ;Now order the colours based on the &00BBGGRR values of each,
        Swap    R8,R10,LE               ;this should result in R8,R10,R11,R9 containing the values sorted
        Swap    R0,R1,LE                ;so that the highest is in R8.   The colour numbers also have
        CMP     R8,R11                  ;to remain in sync with the original physical colours.
        Swap    R8,R11,LE
        Swap    R0,R2,LE
        CMP     R8,R9                   ; C1 < C2 => Swap C1,C2
        Swap    R8,R9,LE                ; C1 < R3 => Swap C2,C3
        Swap    R0,R3,LE                ; C1 < R4 => Swap C3,R4
        CMP     R10,R11
        Swap    R10,R11,LE              ; C2 < R3 => Swap C2,C3
        Swap    R1,R2,LE                ; C2 < R4 => Swap C2,C4
        CMP     R10,R9
        Swap    R10,R9,LE               ; C3 < C4 => Swap C3,C4
        Swap    R1,R3,LE
        CMP     R11,R9
        Swap    R11,R9,LE
        Swap    R2,R3,LE

        Debug   dither2,"Sorted &0RGB",R8,R10,R11,R9
        Debug   dither2,"          CN",R0,R1,R2,R3

        LDR     R4,[WP,#ColourErrorLoading]
        MOV     R5,#&FF                 ;Get error loading for converting physical colours to error values

        AND     R6,R8,R5                ;Extract the red
        AND     LR,R4,R5,LSL #8
        MOV     LR,LR,LSR #8            ;And then the red error loading
        MUL     R6,LR,R6                ;Multiply them together
        AND     R7,R8,R5,LSL #8
        AND     LR,R4,R5,LSL #16
        MOV     R7,R7,LSR #8
        MOV     LR,LR,LSR #16
        MLA     R6,LR,R7,R6             ;Do the same for the green
        AND     R7,R8,R5,LSL #16
        MOV     R7,R7,LSR #16
        MOV     LR,R4,LSR #24
        MLA     R8,LR,R7,R6             ;And finally the same for the blue replacing the original physical colour

        AND     R6,R10,R5               ;Repeat the process for colour 2
        AND     LR,R4,R5,LSL #8
        MOV     LR,LR,LSR #8
        MUL     R6,LR,R6
        AND     R7,R10,R5,LSL #8
        AND     LR,R4,R5,LSL #16
        MOV     R7,R7,LSR #8
        MOV     LR,LR,LSR #16
        MLA     R6,LR,R7,R6
        AND     R7,R10,R5,LSL #16
        MOV     R7,R7,LSR #16
        MOV     LR,R4,LSR #24
        MLA     R10,LR,R7,R6

        AND     R6,R11,R5               ; ... colour 3
        AND     LR,R4,R5,LSL #8
        MOV     LR,LR,LSR #8
        MUL     R6,LR,R6
        AND     R7,R11,R5,LSL #8
        AND     LR,R4,R5,LSL #16
        MOV     R7,R7,LSR #8
        MOV     LR,LR,LSR #16
        MLA     R6,LR,R7,R6
        AND     R7,R11,R5,LSL #16
        MOV     R7,R7,LSR #16
        MOV     LR,R4,LSR #24
        MLA     R11,LR,R7,R6

        AND     R6,R9,R5                ; ... colour 4
        AND     LR,R4,R5,LSL #8
        MOV     LR,LR,LSR #8
        MUL     R6,LR,R6
        AND     R7,R9,R5,LSL #8
        AND     LR,R4,R5,LSL #16
        MOV     R7,R7,LSR #8
        MOV     LR,LR,LSR #16
        MLA     R6,LR,R7,R6
        AND     R7,R9,R5,LSL #16
        MOV     R7,R7,LSR #16
        MOV     LR,R4,LSR #24
        MLA     R9,LR,R7,R6

        Debug   dither2,"Error numbers",R8,R10,R11,R9

        Pull    "R4"

        SUBS    LR,R8,R10               ;Setup the default difference between the first two colours
        RSBMI   LR,LR,#0                ;and then ensure that its +VE
        ORR     R6,R0,R2,LSL R4
        ORR     R7,R3,R1,LSL R4         ;Combine to make a suitable pattern
        BEQ     %FT10                   ;Catch the case of first two rows are the same....

        SUBS    R5,R8,R11               ;Get the difference between the top left and bottom left
        RSBMI   R5,R5,#0                ;If <0 then ensure +ve
        CMP     R5,LR
        MOVLT   LR,R5                   ;If less than the current error then build a new colour
        ORRLT   R6,R0,R1,LSL R4
        ORRLT   R7,R3,R2,LSL R4         ;Combine to make a nice pattern

        SUBS    R5,R8,R9                ;Get difference between top left and bottom right
        RSBMI   R5,R5,#0                ;If <0 then ensure +Ve
        CMP     R5,LR
        MOVLT   LR,R5                   ;If less than current error then compile a new pattern
        ORRLT   R6,R0,R1,LSL R4
        ORRLT   R7,R2,R3,LSL R4

        SUBS    R5,R10,R11              ;Get difference between two different values
        RSBMI   R5,R5,#0                ;And play around with them
        CMP     R5,LR
        MOVLT   LR,R5                   ;Yup there less than the current threshold so build a new pattern
        ORRLT   R6,R1,R0,LSL R4
        ORRLT   R7,R3,R2,LSL R4

        SUBS    R5,R10,R9
        RSBMI   R5,R5,#0                ;Ensure of a suitable value
        CMP     R5,LR                   ;And ensure that it is valid
        MOVLT   LR,R5
        ORRLT   R6,R1,R0,LSL R4
        ORRLT   R7,R2,R3,LSL R4         ;Combine to make a suitable pattern

        SUBS    R5,R11,R9
        RSBMI   R5,R5,#0                ;Is the final check less than the current threshold
        CMP     R5,LR
        MOVLT   LR,R5                   ;Hummm?? think about this one it could be a trick question!
        ORRLT   R6,R2,R0,LSL R4
        ORRLT   R7,R1,R3,LSL R4
10
        Debug   dither2,"Pattern data",R6,R7
00
        MOV     R4,R4,LSL #1            ;Duplicated pattern within the word again
        ANDS    R4,R4,#31               ;Have we wrapped around yet then?
        ORRNE   R6,R6,R6,LSL R4
        ORRNE   R7,R7,R7,LSL R4         ;Duplicate within word again if not
        BNE     %BT00                   ;Loop back until all copied within the word

        Pull    "R5"                    ;Restore the temporary register
        STMIA   R5!,{R6,R7}             ;Write pattern into the specified buffer
        STMIA   R5!,{R6,R7}

        EXITS

;..............................................................................
;
; 16 bit per pixel implementation of the colour dithering routine above,
; this has been optimised for this depth of device.
;
; in    R0 ->start of palette table
;       R1 ->end of palette table
;       R3 physical palette entry (&BBGGRR00)
;       R4 log2bpp of current mode
;       R5 ->buffer to fill
;
; out   all preserved

stack_CN0       * 0
stack_CN1       * 4
stack_CN2       * 8

getpatterncolour16 ROUT

        EntryS  "R0-R11"

        ; Compute the mask value used to convert 24bpp colours (&xxBBGGRR) to
        ; their truncated values after passing through 16bpp conversion, i.e.:
        ;
        ; 24bpp value -> 16bpp -> (24bpp value minus insignificant bits)
        ;
        LDRB    LR,[WP,#CachedL2NColour]
        LDR     R1,=&F0F0F0
        TEQ     LR,#12                  ;4K mode?
        ASSERT  ModeFlag_64k < 256
        LDRNEB  LR,[WP,#CachedModeFlags]
        ORRNE   R1,R1,R1,LSR #1         ;Nope, must be 32K/64K. Use mask of &00F8F8F8
        TSTNE   LR,#ModeFlag_64k        ;64K mode?
        ORRNE   R1,R1,#&400             ;Yes, use mask of &00F8FCF8

        MOV     LR,#1
        MOV     R4,LR,LSL R4            ;Convert Log2BPP to a suitable shift for replication

        MOV     R2,R3                   ;Find colour of top left pixel (based on the specified RGB)
        AND     R8,R1,R2,LSR #8         ;Mask out the insignificant bits
        GetBestColour
        Push    "R2-R4"                 ;Push the colour number and fill stack with new values

        MOV     R2,R3,LSR #8            ;Calculate the red error to be passed on
        AND     R2,R2,#&FF              ;as R+R-(Ra)
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF
        SUBS    R9,R2,LR
        MOVMI   R9,#0
        CMP     R9,#&FF
        MOVGT   R9,#&FF

        MOV     R2,R3,LSR #16           ;Calculate the green error to be passed on
        AND     R2,R2,#&FF              ;as G+G-(Ga)
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF00
        SUBS    R2,R2,LR,LSR #8
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R9,R9,R2,LSL #8

        MOV     R2,R3,LSR #24           ;Calculate the blue error to be passed on
        MOV     R2,R2,LSL #1            ;as B+B-(Ba)
        SUBS    R2,R2,R8,LSR #16
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R2,R9,R2,LSL #16

        AND     R10,R1,R2               ;Mask out the insignificant bits
        MOV     R2,R2,LSL #8            ;Combine to make &BBGGRR00
        GetBestColour                   ;Lookup colour number relating
        STR     R2,[sp,#stack_CN1]

        MOV     R2,R3,LSR #8            ;Calculate the red error to be passed on
        AND     R2,R2,#&FF              ;as R+R-(Ra+Rb)/2
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF
        AND     R11,R10,#&FF
        ADD     R11,R11,LR
        SUBS    R9,R2,R11,ASR #1
        MOVMI   R9,#0
        CMP     R9,#&FF
        MOVGT   R9,#&FF

        MOV     R2,R3,LSR #16           ;Calculate the green error to be passed on
        AND     R2,R2,#&FF              ;as G+G-(Ga+Gb)/2
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF00
        AND     R11,R10,#&FF00
        ADD     R11,R11,LR
        MOV     R11,R11,LSR #8
        SUBS    R2,R2,R11,ASR #1
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R9,R9,R2,LSL #8

        MOV     R2,R3,LSR #24           ;Calculate the blue error to be passed on
        MOV     R2,R2,LSL #1            ;as B+B-(Ba+Bb)/2
        MOV     LR,R8,LSR #16
        ADD     R11,LR,R10,LSR #16
        SUBS    R2,R2,R11,ASR #1
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R2,R9,R2,LSL #16

        AND     R11,R1,R2               ;Mask out the insignificant bits
        MOV     R2,R2,LSL #8            ;Munge together to make a palette entry
        GetBestColour                   ;Find the closest possible colour to it
        STR     R2,[sp,#stack_CN2]

        Push    "R4,R5"

        MOV     R2,R3,LSR #8            ;Calculate the red error to be passed on
        AND     R2,R2,#&FF              ;as R+R-(Ra+Rb+Rc)/3
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF
        AND     R6,R10,#&FF
        AND     R7,R11,#&FF
        ADD     LR,LR,R6
        ADD     LR,LR,R7
        DivRem  R4,LR,#3,R7,norem       ;Howible divide by 3!!!!
        SUBS    R9,R2,R4
        MOVMI   R9,#0
        CMP     R9,#255
        MOVGT   R9,#255

        MOV     R2,R3,LSR #16           ;Calculate the green error to be passed on
        AND     R2,R2,#&FF              ;as G+G-(Ga+Gb+Gc)/3
        MOV     R2,R2,LSL #1
        AND     LR,R8,#&FF00
        AND     R6,R10,#&FF00
        AND     R7,R11,#&FF00
        MOV     LR,LR,LSR #8
        ADD     LR,LR,R6,LSR #8
        ADD     LR,LR,R7,LSR #8
        DivRem  R4,LR,#3,R7,norem
        SUBS    R2,R2,R4
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R9,R9,R2,LSL #8

        MOV     R2,R3,LSR #24           ;Calculate the green error to be passed on
        MOV     R2,R2,LSL #1            ;as B+B-(Ba+Bb+Bc)/3
        MOV     LR,R8,LSR #16
        ADD     LR,LR,R10,LSR #16
        ADD     LR,LR,R11,LSR #16
        DivRem  R4,LR,#3,R7,norem
        SUBS    R2,R2,R4
        MOVMI   R2,#0
        CMP     R2,#&FF
        MOVGT   R2,#&FF
        ORR     R2,R9,R2,LSL #16

        AND     R9,R1,R2                ;Mask out the insignificant bits
        MOV     R2,R2,LSL #8
        GetBestColour                   ;Combine to make physical colour and lookup
        MOV     R3,R2                   ;Take a copy of the colour number word

        ADD     R0,sp,#4*2
        LDMIA   R0,{R0-R2}              ;Pick up the colour numbers (previously stacked!)

; R8  = 1st pixel (significant bits only, &00BBGGRR)
; R9  = 4th pixel (significant bits only, &00BBGGRR)
; R10 = 2nd pixel (significant bits only, &00BBGGRR)
; R11 = 3rd pixel (significant bits only, &00BBGGRR)

; R3 = 4th pixel colour number
; R2 = 3rd pixel colour number
; R1 = 2nd pixel colour number
; R0 = 1st pixel colour number

        CMP     R8,R10                  ;Now order the colours based on the &00BBGGRR values of each,
        Swap    R8,R10,LE               ;this should result in R8,R10,R11,R9 containing the values sorted
        Swap    R0,R1,LE                ;so that the highest is in R8.   The colour numbers also have
        CMP     R8,R11                  ;to remain in sync with the original physical colours.
        Swap    R8,R11,LE
        Swap    R0,R2,LE
        CMP     R8,R9                   ; C1 < C2 => Swap C1,C2
        Swap    R8,R9,LE                ; C1 < R3 => Swap C2,C3
        Swap    R0,R3,LE                ; C1 < R4 => Swap C3,R4
        CMP     R10,R11
        Swap    R10,R11,LE              ; C2 < R3 => Swap C2,C3
        Swap    R1,R2,LE                ; C2 < R4 => Swap C2,C4
        CMP     R10,R9
        Swap    R10,R9,LE               ; C3 < C4 => Swap C3,C4
        Swap    R1,R3,LE
        CMP     R11,R9
        Swap    R11,R9,LE
        Swap    R2,R3,LE

        Debug   dither2,"Sorted &0RGB",R8,R10,R11,R9
        Debug   dither2,"          CN",R0,R1,R2,R3

        LDR     R4,[WP,#ColourErrorLoading]
        MOV     R5,#&FF                 ;Get error loading for converting physical colours to error values

        AND     R6,R8,R5                ;Extract the red
        AND     LR,R4,R5,LSL #8
        MOV     LR,LR,LSR #8            ;And then the red error loading
        MUL     R6,LR,R6                ;Multiply them together
        AND     R7,R8,R5,LSL #8
        AND     LR,R4,R5,LSL #16
        MOV     R7,R7,LSR #8
        MOV     LR,LR,LSR #16
        MLA     R6,LR,R7,R6             ;Do the same for the green
        AND     R7,R8,R5,LSL #16
        MOV     R7,R7,LSR #16
        MOV     LR,R4,LSR #24
        MLA     R8,LR,R7,R6             ;And finally the same for the blue replacing the original physical colour

        AND     R6,R10,R5               ;Repeat the process for colour 2
        AND     LR,R4,R5,LSL #8
        MOV     LR,LR,LSR #8
        MUL     R6,LR,R6
        AND     R7,R10,R5,LSL #8
        AND     LR,R4,R5,LSL #16
        MOV     R7,R7,LSR #8
        MOV     LR,LR,LSR #16
        MLA     R6,LR,R7,R6
        AND     R7,R10,R5,LSL #16
        MOV     R7,R7,LSR #16
        MOV     LR,R4,LSR #24
        MLA     R10,LR,R7,R6

        AND     R6,R11,R5               ; ... colour 3
        AND     LR,R4,R5,LSL #8
        MOV     LR,LR,LSR #8
        MUL     R6,LR,R6
        AND     R7,R11,R5,LSL #8
        AND     LR,R4,R5,LSL #16
        MOV     R7,R7,LSR #8
        MOV     LR,LR,LSR #16
        MLA     R6,LR,R7,R6
        AND     R7,R11,R5,LSL #16
        MOV     R7,R7,LSR #16
        MOV     LR,R4,LSR #24
        MLA     R11,LR,R7,R6

        AND     R6,R9,R5                ; ... colour 4
        AND     LR,R4,R5,LSL #8
        MOV     LR,LR,LSR #8
        MUL     R6,LR,R6
        AND     R7,R9,R5,LSL #8
        AND     LR,R4,R5,LSL #16
        MOV     R7,R7,LSR #8
        MOV     LR,LR,LSR #16
        MLA     R6,LR,R7,R6
        AND     R7,R9,R5,LSL #16
        MOV     R7,R7,LSR #16
        MOV     LR,R4,LSR #24
        MLA     R9,LR,R7,R6

        Debug   dither2,"Error numbers",R8,R10,R11,R9

        Pull    "R4"

        SUBS    LR,R8,R10               ;Setup the default difference between the first two colours
        RSBMI   LR,LR,#0                ;and then ensure that its +VE
        ORR     R6,R0,R2,LSL R4
        ORR     R7,R3,R1,LSL R4         ;Combine to make a suitable pattern
        BEQ     %FT10                   ;Catch the case of first two rows are the same....

        SUBS    R5,R8,R11               ;Get the difference between the top left and bottom left
        RSBMI   R5,R5,#0                ;If <0 then ensure +ve
        CMP     R5,LR
        MOVLT   LR,R5                   ;If less than the current error then build a new colour
        ORRLT   R6,R0,R1,LSL R4
        ORRLT   R7,R3,R2,LSL R4         ;Combine to make a nice pattern

        SUBS    R5,R8,R9                ;Get difference between top left and bottom right
        RSBMI   R5,R5,#0                ;If <0 then ensure +Ve
        CMP     R5,LR
        MOVLT   LR,R5                   ;If less than current error then compile a new pattern
        ORRLT   R6,R0,R1,LSL R4
        ORRLT   R7,R2,R3,LSL R4

        SUBS    R5,R10,R11              ;Get difference between two different values
        RSBMI   R5,R5,#0                ;And play around with them
        CMP     R5,LR
        MOVLT   LR,R5                   ;Yup there less than the current threshold so build a new pattern
        ORRLT   R6,R1,R0,LSL R4
        ORRLT   R7,R3,R2,LSL R4

        SUBS    R5,R10,R9
        RSBMI   R5,R5,#0                ;Ensure of a suitable value
        CMP     R5,LR                   ;And ensure that it is valid
        MOVLT   LR,R5
        ORRLT   R6,R1,R0,LSL R4
        ORRLT   R7,R2,R3,LSL R4         ;Combine to make a suitable pattern

        SUBS    R5,R11,R9
        RSBMI   R5,R5,#0                ;Is the final check less than the current threshold
        CMP     R5,LR
        MOVLT   LR,R5                   ;Hummm?? think about this one it could be a trick question!
        ORRLT   R6,R2,R0,LSL R4
        ORRLT   R7,R1,R3,LSL R4
10
        Debug   dither2,"Pattern data",R6,R7
00
        MOV     R4,R4,LSL #1            ;Duplicated pattern within the word again
        ANDS    R4,R4,#31               ;Have we wrapped around yet then?
        ORRNE   R6,R6,R6,LSL R4
        ORRNE   R7,R7,R7,LSL R4         ;Duplicate within word again if not
        BNE     %BT00                   ;Loop back until all copied within the word

        Pull    "R5"                    ;Restore the temporary register
        STMIA   R5!,{R6,R7}             ;Write pattern into the specified buffer
        STMIA   R5!,{R6,R7}

        ADD     sp,sp,#4*3              ;Balance the stack
        EXITS



        END
@


4.4
log
@Update to cope with new pixel formats
Detail:
  s/Commons - Update best/worst colour code to add support for all the new RGB pixel format variations
  s/Dither - Rework code to remove reliance on now removed get_physical16bpp routine
  s/Enhanced - Drop support for VIDC enhancer. "VIDC20" code enhanced to add support for all the new RGB pixel formats, mainly reliant on new ColourConv macro. Drop get_physical16bpp routine as it wasn't really needed and would have been a pain to update.
  s/FontColours - Remove reference to obsolete PseudoPaletteEntry variable
  s/Header - Update workspace to clarify how certain variables are overlaid over the colour cache entries. Rename temp_guardtable to temp_errortable as the name makes more sense to me. Cache current modeflags & log2 NColour in InitCache.
  s/MainSWIs - Flag_* -> ModeFlag_* renaming. Pass through source mode to make32Ktable
  s/Palettes - Strip out some old Module_Version switches to make code more readable. Cache current modeflags and log2 NColour values when dealing with sprite output.
  s/Tables32K - Table generation code rewritten to add support for new 16bpp pixel formats, be faster, and (hopefully) more readable. Core generation code has been split off into seperate file, s/TablesAlgo, as it's needed multiple times but is too big for a macro.
  s/TablesAlgo - New file containing core code for the "32K" table generation. Disregarding pixel format differences, it can be assembled in two forms, optimised either for large or small data caches. New code is 85% faster on BB-xM (large cache version), 43% faster on Iyonix and 80% faster on StrongARM (both small cache version).
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification
  Code is in need of updating to allow caller to identify which type of 32K table has been returned (i.e. old-style 32K table or some new kind of 4K/32K/64K one)


Version 1.86. Tagged as 'Colours-1_86'
@
text
@d321 1
a321 2
        MOV     R6,#3
        DivRem  R4,LR,R6,R7             ;Howible divide by 3!!!!
d336 1
a336 2
        MOV     R6,#3
        DivRem  R4,LR,R6,R7
d348 1
a348 2
        MOV     R6,#3
        DivRem  R4,LR,R6,R7
d633 1
a633 2
        MOV     R6,#3
        DivRem  R4,LR,R6,R7             ;Howible divide by 3!!!!
d648 1
a648 2
        MOV     R6,#3
        DivRem  R4,LR,R6,R7
d660 1
a660 2
        MOV     R6,#3
        DivRem  R4,LR,R6,R7
@


4.3
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  s.Dither: It looks like CachedPatternValid was once a 4-byte value but
    subsequently three of the bytes in the first cache entry were re-used for
    other purposes. However in getpattern it is still accessed using LDR and
    STR.  This means (a) that it mistakenly thinks that the pattern block is
    never valid and so has to recalculate it every time, and (b) corrupts
    other variables if either this was the first entry, or we're on ARMv6 or
    later and this was the last entry.
  s.MainSWIs: LDR of a 1-byte variable: harmless since only bit 7 tested, but
    faster as an LDRB on ARMv6.
  Added ENTRY directive to permit building of GPA debug listing.
Admin:
  Builds but not tested.

Version 1.77. Tagged as 'Colours-1_77'
@
text
@d533 14
d551 1
a553 2
        BL      get_physical16bpp
        MOV     R8,R2,LSR #8
d582 1
a585 2
        BL      get_physical16bpp
        MOV     R10,R2,LSR #8
d621 1
a624 2
        BL      get_physical16bpp
        MOV     R11,R2,LSR #8
d673 1
a676 2
        BL      get_physical16bpp
        MOV     R9,R2,LSR #8
d681 4
a684 4
; R8  = 1st pixel (as physical entry)
; R9  = 4th pixel (as physical entry)
; R10 = 2nd pixel (as physical entry)
; R11 = 3rd pixel (as physical entry)
@


4.2
log
@32-bit compatible.

Version 1.69. Tagged as 'Colours-1_69'
@
text
@d66 2
a67 2
        LDR     LR,[R10,#CachedPatternValid]
        CMP     LR,#-1                  ;Is the pattern block valid?
d83 2
a84 1
        STR     R10,[R10,#CachedPatternValid]
@


4.1
log
@Initial revision
@
text
@d18 2
a19 2
; 
; getpattern 
d26 1
a26 1
;       
d31 1
a31 1
             
d33 1
a33 1
                              
d35 1
a35 1
                  
d51 1
a51 1
                 
d65 1
a65 1
                           
d73 1
a73 1
        
d78 1
a78 1
                   
d82 1
a82 1
        
d86 1
a86 1
        LDRB    R1,[R10,#CachedColour] 
d94 1
a94 1
        Pull    "R3-R4,R6-R8,R10,PC",,^
d106 2
a107 2
; which are less than the value calculated and toggles those bits within 
; the pattern block. 
d114 1
a114 1
;                 15   7  13   5 
d118 1
a118 1
; 
d129 2
a130 2
        Push    "R0-R4,R6,LR"
      
d144 1
a144 1
        MLA     LR,R1,R0,LR             ;  77*red +150*green    
d166 1
a166 1
        CMP     R0,LR                   
d183 2
a184 2
        
        Pull    "R0-R4,R6,PC",,^
d191 1
a191 1
; 
d193 1
a193 1
;                          
d197 1
a197 1
; 
d201 1
a201 1
; left, and the two pixels bellow, this then gives a block of four pixels that 
d213 1
a213 1
; 
d224 1
a224 1
        Push    "R0-R11,LR"
d228 1
a228 1
        
d230 2
a231 2
        GetBestColour         
        LDR     R8,[R0,R2,LSL #2] 
d239 1
a239 1
        SUBS    R9,R2,LR,LSR #8 
d251 1
a251 1
        MOVGT   R2,#&FF         
d253 1
a253 1
         
d259 1
a259 1
        MOVGT   R2,#&FF         
d262 1
a262 1
        MOV     R2,R2,LSL #8            ;Combine to make &BBGGRR00     
d264 1
a264 1
        LDR     R10,[R0,R2,LSL #2]     
d272 1
a272 1
        AND     R11,R10,#&FF00       
d284 1
a284 1
        AND     R11,R10,#&FF0000       
d305 1
a305 1
        LDR     R11,[R0,R2,LSL #2] 
d308 1
a308 1
                                  
d310 1
a310 1
        
d326 1
a326 1
     
d343 1
a343 1
      
d356 1
a356 1
       
d370 1
a370 1
                         
d453 1
a453 1
                     
d455 1
a455 1
       
d461 1
a461 1
              
d468 1
a468 1
  
d474 1
a474 1
        ORRLT   R7,R2,R3,LSL R4    
d482 1
a482 1
        
d509 1
a509 1
        Pull    "R0-R11,PC",,^
d512 1
a512 1
; 
d515 1
a515 1
; 
d530 1
a530 1
        Push    "R0-R11,LR"
d534 1
a534 1
        
d536 1
a536 1
        GetBestColour         
d557 1
a557 1
        MOVGT   R2,#&FF         
d559 1
a559 1
         
d565 1
a565 1
        MOVGT   R2,#&FF         
d567 2
a568 2
                      
        MOV     R2,R2,LSL #8            ;Combine to make &BBGGRR00     
d578 1
a578 1
        AND     R11,R10,#&FF       
d607 1
a607 1
         
d630 1
a630 1
     
d647 1
a647 1
      
d660 1
a660 1
                               
d666 1
a666 1
        
d679 1
a679 1
         
d762 1
a762 1
                     
d764 1
a764 1
       
d770 1
a770 1
              
d777 1
a777 1
  
d783 1
a783 1
        ORRLT   R7,R2,R3,LSL R4    
d791 1
a791 1
        
d817 1
a817 1
                   
d819 1
a819 1
        Pull    "R0-R11,PC",,^
d823 1
a823 1
        END           
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

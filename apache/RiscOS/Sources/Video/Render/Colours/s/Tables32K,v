head	4.6;
access;
symbols
	Colours-1_95:4.6
	Colours-1_94:4.6
	Colours-1_93:4.6
	Colours-1_92:4.6
	Colours-1_91:4.6
	Colours-1_90:4.6
	Colours-1_89:4.6
	Colours-1_88:4.5
	Colours-1_87:4.5
	Colours-1_86:4.5
	Colours-1_85:4.4
	Colours-1_84:4.4
	Colours-1_83:4.4
	Colours-1_82:4.4
	Colours-1_81:4.4
	Colours-1_80:4.4
	Colours-1_79:4.4
	Colours-1_78:4.4
	Colours-1_77:4.4
	RO_5_07:4.4
	Colours-1_76:4.4
	Colours-1_75:4.4
	Colours-1_74:4.4
	Colours-1_73:4.4
	Colours-1_72:4.4
	dellis_autobuild_BaseSW:4.3
	Colours-1_71:4.3
	Colours-1_70:4.2
	Colours-1_69:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.4
	Colours-1_68:4.1
	Colours-1_67:4.1
	Ursula_merge:4.1
	nturton_Colours-1_65:4.1
	dcotton_colours_MPTInitialBuild:4.1.7.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2014.03.04.20.36.33;	author jlee;	state Exp;
branches;
next	4.5;
commitid	WrPp3rX1ZKdIgqrx;

4.5
date	2013.08.06.23.49.21;	author jlee;	state Exp;
branches;
next	4.4;
commitid	wewI5Vx1d9Rn5s0x;

4.4
date	2000.11.17.12.51.47;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2000.08.07.17.19.38;	author jfletche;	state Exp;
branches;
next	4.2;

4.2
date	2000.08.04.17.15.49;	author jfletche;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.42.20;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.42.20;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.08.42;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.48.20;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.11.17;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Add new "32K+" translation table format. Fix a couple of bugs.
Detail:
  Since ColourTrans 1.86, the "32K." tables returned by ColourTrans_SelectTable/ColourTrans_GenerateTable can actually be in several different formats, depending on the pixel format of the source mode. However there was no way for a user of that table to determine what format the table was.
  This change rectifies that, by adding a "32K+" table format which is used whenever a 32K-style table isn't compatible with the RISC OS 3.5 "32K." format.
  This new format has "32K+" in the two guard words instead of "32K.". To increase compatibility with existing code the middle word is still used to point to the start of the lookup table. But in the bytes preceeding the table a header can be found which describes the structure of the table.
  File changes:
  hdr/ColourTran - Describe format of the 32K+ table header
  s/Header, s/Tables32K - Update code to generate and store the new format tables. Strip out nomessagetransfortables option (assume TRUE). Fix reading of tables from ResourceFS to correctly determine whether files are squashed or not (previously always treated as squashed and copied them to RAM). Add simple caching for addresses of ROM tables so we don't have to pester the filesystem all the time. Fix immortality code to set the immortal flag correctly when generating 32K tables (would previously overwrite a random word in a temp array)
Admin:
  Tested on BB-xM


Version 1.89. Tagged as 'Colours-1_89'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;associated with the 32K tables are two linked lists. The first is
;for the palettes of 32K tables held on resourcefs, and the second
;is for 32K tables held in rma.
;
;Structure is:
;               Palette                Table
;0              Next or 0              Next or 0
;4              Palette size           Palette size
;8              Table size             Table size
;12...          Palette                Palette
;after palette  ROM ptr or 0           CTrans32Kplus header                   
;and then       leafname               32K table data

                    ^ 0
cachedtable_next    # 4
cachedtable_palsize # 4
cachedtable_tabsize # 4
cachedtable_palette # 0

;warning! this routine is written to be fast, and is register intensive
;there are no registers spare in the central routine. note particularly
;that r12 is reused in the main loop (as errorarray).

;returning of colour numbers is the only form supported, likewise transfer
;functions are not supported here - they would slow things up too much!

thiscolour RN 0
blueerrstep RN 6
greenerrstep RN 7
rederrstep RN 8
errorarray RN 12
colourarray RN 10
palette RN 9

        GBLA    red_bits
        GBLA    green_bits
        GBLA    blue_bits
        GBLA    red_shift
        GBLA    green_shift
        GBLA    blue_shift
        GBLL    smallcache

; In:
; R0 = source mode
; R2 = destination mode
; R3 = destination palette
; R4 = pointer to 12 byte output buffer for {"32K.", table pointer, "32K."}
;                                        or {"32K+", table pointer, "32K+"}

; Stack workspace structure
                  ^ 0
make32k_header    # CTrans32Kplus_ExpectedSize
make32k_tablesize # 4
make32k_stacksize # 0

make32Ktable
        Entry   "R0-R12", make32k_stacksize

        Debug   table32K,"_____________________________________________________"
        Debug   table32K,""
        Debug   table32K,"Want to build a 32K table..."

        ROUT

        Debug   table32K,"Stack in is",R13

; find out the number of colours
        FRAMLDR R0,,R2                              ;recover stacked R2
        Debug   table32K,"Target mode",R0
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable                ;read the log2bpp for this mode
        BVS     exit_32k
        MOV     R0,#1
        MOV     R6,R2                               ;save the log2bpp
        MOV     R1,R0,LSL R2                        ;convert log2bpp to bpp
        MOV     R11,R0,LSL R1                       ;convert bpp to #colours (256 for 8bpp)
        Debug   table32K,"Palette entries",R11

        FRAMLDR R5,,R3                              ;get stacked R3 back
                                                    ;either => palette,
                                                    ;       0 for default for mode
                                                    ;       -1 for current
        Debug   table32K,"stacked R3",R5

        CMP     R5,#-1
        BEQ     %FT23                               ; -1 - use current palette
        CMP     R5,#0
        MOVNE   palette,R5
        BNE     %FT24                               ;palette supplied - use it

        ;we want the default palette for the mode
        ADRL    R7,defpals
        LDR     R8,[R7,R6,LSL #2]

        CMP     R6,#3                               ;use the copy in defpals
        MOVCC   palette,R8
        BCC     %FT24
23

; get the memory for it                             ;claim space to keep palette
        MOV     R0,#6                               ;size=#colours * 4
        MOV     R3,R11,LSL #2
        SWI     XOS_Module
        Debug   table32K,"claiming for palette",R3
        BVS     exit_32k
        MOV     palette,R2
        FRAMLDR R0,,R12                             ;fetch R12, workspace pointer
        STR     palette,[R0,#temp_palette]          ;ensure we can deallocate on die
                                                    ;(if necessary)

        ; if R5=0 and R6=3 here, we have to copy over and
        ; create a full 256 palette

        CMP     R5,#0
        CMPEQ   R6,#3
        BNE     %FT22                               ;check for 8bpp and use defpal

        ADRL    R7,modetwofivesix                   ;the condensed palette data
        MOV     R6,#0                               ;colour index
        MOV     R1,#&88000000                       ;mask 1
        MOV     R2,#&00880000                       ;mask 2
        MOV     R3,#&00440000                       ;mask 3
        MOV     R4,#&00008800                       ;mask 4
        MOV     R5,R9                               ;pointer to palette space

50      LDR     R0,[R7,R6,LSL #2]                   ;get the first word
        ORR     R0,R0,R0,LSR #4                     ;duplicate top nibble into bottom

        ORR     R8,R0,R1                            ;or in mask 1
        ORR     R8,R8,R2                            ;and mask 2
        STR     R8,[R5],#64                         ;store in first quarter, and increment
                                                    ;to second quarter

        ORR     R8,R8,R4                            ;or in mask 3
        STR     R8,[R5],#128                        ;store in second quarter, and increment
                                                    ;to fourth quarter

        ORR     R8,R8,R3                            ;or in mask 4
        STR     R8,[R5],#-64                        ;store in fourth quarter, and decrement
                                                    ;to third quarter

        EOR     R8,R8,R4                            ;eor out mask 3
        STR     R8,[R5],#-124                       ;store in third quarter, and move back
                                                    ;to *next* entry in first quarter

        ADD     R6,R6,#1                            ;next colour
        CMP     R6,#16                              ;done 16 yet ?
        BCC     %BT50                               ;continue

        B       %FT24
22
                                                    ;we want the default palette
        MOV     R0,#-1
        MOV     R1,R0
        MOV     R2,palette
        MOV     R3,R11,LSL #2
        MOV     R4,#0
        Debug   table32K,"Calling ReadPalette",R0,R1,R2,R3,R4
        SWI     ColourTrans_ReadPalette
        BVS     exit_32k

        SWI     ColourTrans_InvalidateCache
        Debug   table32K,"Invalidating cache"

; and now - it's showtime.....
24

; work out how many colours are in the source mode, and if we need to do
; red/blue swapping

        FRAMLDR R0                          ; recover R0
        MOV     R1,#VduExt_NColour
        SWI     XOS_ReadModeVariable
        BVS     exit_32k
        CMP     R2,#65536
        MOV     R3,R2
        MOVHI   R0,#32768                   ; Only produce standard 32K table for >16bpp source mode
        MOVHI   R3,#65536
        MOVHI   R10,#0
        SUBHI   R3,R3,#1
        BHI     %FT30
        MOV     R1,#VduExt_ModeFlags
        SWI     XOS_ReadModeVariable
        BVS     exit_32k
        TST     R2,#ModeFlag_64k
        BIC     R10,R2,#ModeFlag_DataFormatSub_Alpha ; Keep just the RGB order+64K flag. Source alpha is ignored in all current table formats.
        MOVNE   R0,#65536
        BNE     %FT30
        ADD     R0,R3,#1
        CMP     R0,#4096
        MOVNE   R0,#32768
30
        Debug table32K,"Lookup table entries",R0
        Debug table32K,"mode flags =",R10
        Debug table32K,"NColour =",R3

        ; Set up the header structure held on the stack
        STR     R3,[SP,#make32k_header+CTrans32Kplus_SrcNColour]
        STR     R10,[SP,#make32k_header+CTrans32Kplus_SrcModeFlags]
        MOV     LR,#4 ; Always 16bpp source
        STR     LR,[SP,#make32k_header+CTrans32Kplus_SrcLog2BPP]
        STR     R11,[SP,#make32k_header+CTrans32Kplus_DestCount]
        ASSERT  CTrans32Kplus_HeaderSize = CTrans32Kplus_TableFormat+2
        LDR     LR,=0+(CTrans32Kplus_ExpectedSize<<16)
        STR     LR,[SP,#make32k_header+CTrans32Kplus_TableFormat]
        ; And remember the number of table entries
        STR     R0,[SP,#make32k_tablesize]

; we may be able to save ourselves some work here.....

; check down the anchor_tables and anchor_resourcefs chains
; if we find it in anchor_tables we already have a ready-made 32K table
; if we find it in anchor_resourcefs we turn this link into a anchor_table
;   entry and load the table from resourcefs

; first test is whether the palette size (#4 in both structures) = R11 LSL #2
; r1-r8 are free at the moment

; check the extant tables first....

        [ debugtable32K
        STMFD R13!,{R0-R8}
        MOV R8,palette
        LDMFD R8!,{R0-R7}
        Debug table32K,"First sixteen words of palette...."
        Debug table32K,"",R0,R1,R2,R3
        Debug table32K,"",R4,R5,R6,R7
        LDMFD R8!,{R0-R7}
        Debug table32K,"",R0,R1,R2,R3
        Debug table32K,"",R4,R5,R6,R7
        LDMFD R13!,{R0-R8}
        ]

        FRAMLDR R3,,R12                     ; recover R12
        LDR     R3,[R3,#anchor_tables]
        TEQ     R3,#0
        BEQ     %FT70                       ; branch if no cached tables
71
        ASSERT  cachedtable_palsize = 4
        ASSERT  cachedtable_tabsize = 8
        LDMIB   R3,{R4,R6}                  ; collect size

        Debug   table32K,"size of palette table =",R4
        Debug   table32K,"size of lookup table =",R6
        CMP     R4,R11,LSL #2
        CMPEQ   R6,R0
        BNE     %FT76                       ; size is wrong

        ; Check the 32K+ header
        ASSERT  CTrans32Kplus_ExpectedSize = 5*4
        ADD     R6,R3,#cachedtable_palette
        ADD     R6,R6,R11,LSL #2
        ADD     R5,SP,#make32k_header
        LDMIA   R6!,{R4,R7}
        LDMIA   R5!,{R2,LR}
        Debug   table32K,"SrcNColour = ",R4
        Debug   table32K,"SrcModeFlags = ",R7
        CMP     R4,R2
        CMPEQ   R7,LR
        LDMEQIA R6!,{R4,R7,LR}
        DebugIf EQ,table32K,"SrcLog2BPP = ",R4
        DebugIf EQ,table32K,"DestCount = ",R7
        DebugIf EQ,table32K,"TableFormat = ",LR
        LDMEQIA R5,{R2,R5}
        CMPEQ   R4,R2
        CMPEQ   R7,R5
        CMPEQ   LR,#0+(CTrans32Kplus_ExpectedSize<<16)
        BNE     %FT76

        ; header is a match - check the entries
        ADD     R6,R3,#cachedtable_palette  ; r6=pointer to one to test
                                            ; palette = our one
        MOV     R7,R11,LSL #2
77
        SUBS    R7,R7,#4
        BMI     %FT78                       ; if we run out of colours both are the same

        LDR     R5,[palette,R7]
        LDR     R8,[R6,R7]
        Debug   table32K,"palette value, table value",R5,R8
        TEQ     R5,R8
        BNE     %FT76                       ;failed - try another
        B       %BT77                       ;matched - try next colour

78                                          ;we have a match!
        Debug   table32K,"we found it (table exists)!!!!!"
        ADD     R6,R6,R11,LSL #2
        ADD     R6,R6,#CTrans32Kplus_ExpectedSize
        B       %FT83                       ;return table

76
        LDR     R4,[R3,#cachedtable_next]   ;read the next pointer
        TEQ     R4,#0
        MOVNE   R3,R4                       ;go round again whilst not at end of chain
        BNE     %BT71


70
        ; Check whether this is the right palette for a table held in resourcefs

        ; At the moment we only support old-style "32K." tables from
        ; resourcefs, so our header held on the stack must match the format
        ; required for that
        
        ASSERT  CTrans32Kplus_SrcNColour = 0
        ASSERT  CTrans32Kplus_SrcModeFlags = 4
        ASSERT  CTrans32Kplus_SrcLog2BPP = 8
        ASSERT  CTrans32Kplus_DestCount = 12
        ASSERT  CTrans32Kplus_TableFormat = 16
        ASSERT  CTrans32Kplus_HeaderSize = 18
        ASSERT  CTrans32Kplus_ExpectedSize = 5*4
        ADD     R2,SP,#make32k_header
        LDMIA   R2,{R2-R6}
        ADD     R2,R2,#1
        CMP     R3,#0
        CMPEQ   R4,#4
        CMPEQ   R2,#65536
        ; R5 check not needed here, handled below
        CMPEQ   R6,#0+(CTrans32Kplus_ExpectedSize<<16)
        DebugIf NE,table32K,"wrong format for resourcefs table"
        BNE     %FT80                       ;wrong format for resourcefs tables

        FRAMLDR R3,,R12
        LDR     R3,[R3,#anchor_resourcefs]
        TEQ     R3,#0
        BEQ     %FT80                       ;branch if no resourcefs tables
72
        ASSERT  cachedtable_palsize = 4
        ASSERT  cachedtable_tabsize = 8
        LDMIB   R3,{R4,R6}                  ; collect size

        Debug   table32K,"size of resourcefs palette =",R4
        Debug   table32K,"size of resourcefs table =",R6

        CMP     R4,R11,LSL #2
        CMPEQ   R6,R0
        BNE     %FT73                       ;wrong number of colours - next!

        ; header is a match - check the entries
        ADD     R6,R3,#cachedtable_palette  ;r6=pointer to one to test
                                            ;palette = our one
        MOV     R7,R11,LSL #2
74
        SUBS    R7,R7,#4
        BMI     %FT75                       ;run out of colours ? matched if so

        LDR     R5,[palette,R7]
        LDR     R8,[R6,R7]
        TEQ     R5,R8
        Debug   table32K,"(resourcefs) palette value, table value",R5,R8
        BNE     %FT73                       ;failed - try another
        B       %BT74                       ;matched - try next colour

75      ;we have a match!
        Debug   table32K,"we found it (need to load table)!!!!!"

        ;instead of using colourarray as scratchspace we use [WP,#temp_gbpb]
        ;registers in at this point:
        ;R6->first word of palette data (ie resourcefs info block + 8)

        SUB     R8, R6, #cachedtable_palette ;now R8->start of record

        ; build filename at WP,#temp_gbpb. safe to use as WP now, since both
        ; errorarray and colourarray are not used yet here

        LDR     R3, [R6, #cachedtable_palsize-cachedtable_palette] ;length of palette table
        ADD     R6, R6, R3
        LDR     R3,[R6]
        Debug   table32K,"cached resourcefs pointer is",R3
        CMP     R3,#0
        MOVNE   R6,R3
        BNE     %FT86

        FRAMLDR WP            
        ADD     colourarray, WP, #temp_gbpb ;point at workspace

        ADRL    R3,tablepath                ;pathname for table in resourcefs
        ADD     R4,colourarray,#16          ;scratchspace for name
91
        LDRB    R5,[R3],#1                  ;copy the path, excluding terminator
        TEQ     R5,#0
        STRNEB  R5,[R4],#1
        BNE     %BT91
        ADD     LR,R6,#4                    ;leafname pointer
92
        LDRB    R5,[LR],#1                  ;copy the name, including terminator
        STRB    R5,[R4],#1
        TEQ     R5,#0
        BNE     %BT92

        MOV     R0,colourarray              ;use first four words as MessageTrans descriptor
        ADD     R1,R0,#16
        Debug   table32K,"full filename at",R1

        ; we need to findout if we can reference it directly or not

        Debug   table32K,"checking for resourcefs"
        ; open file
        MOV     r0, #OSFind_ReadFile
        Debug   table32K," -opening file"
        SWI     XOS_Find
        BVS     exit_32k
        MOV     r4,r0

        ; get internal handle
        MOV     r0, #FSControl_ReadFSHandle
        MOV     r1, r4
        Debug   table32K," -checking FS information"
        SWI     XOS_FSControl
        MOVVS   r3, #0                      ; if error, remember that we didn't get it
        MOVVC   r3, r1                      ; r6 = location of data in ROM
        AND     r2, r2, #&FF                ; get fsinfoword
        TEQ     r2, # fsnumber_resourcefs   ; is it resourcefs ?
        MOVNE   r3, #0

        ; close file
        MOV     r0, #0
        MOV     r1, r4
        Debug   table32K," -closing file"
        SWI     XOS_Find
        BVS     exit_32k

        Debug   table32K,"ROM data = ",r3
        ; did we fail to find the information we wanted ?
        TEQ     r3,#0
        BEQ     %FT84                       ; jump out and do the load anyhow

        LDR     r0,[r3]
        LDR     r1,sqshtag
        TEQ     r0,r1
        BEQ     %FT84
        STR     r3,[r6]                     ; set ROM pointer
        MOV     r6,r3
        Debug   table32K,"Not squashed, we have our data"
        B       %FT86

84      ;entry where filename is in colourarray at +16
        ADD     R1,colourarray,#16
85      ;file needs expanding - build a full record for it

        ;R1 points at assembled filename
        ;R8 is start of record

        ADD     R6, R8, #cachedtable_palette ;point at the palette entries

                                            ;next thing is to build a full
                                            ;entry for this one - the palette is in
                                            ;memory, but the table is still in
                                            ;resourcefs
        MOV     R0,#ModHandReason_Claim
        LDR     R5,[R8,#cachedtable_tabsize] ;32K for the table
        ADD     R3,R5,#cachedtable_palette+CTrans32Kplus_ExpectedSize  ;space needed for header
        ADD     R3,R3,R11,LSL #2            ;space for colours
        Debug   table32K,"claiming for table",R3
        SWI     XOS_Module
        BVS     %FT73
        STR     R5,[R2,#cachedtable_tabsize] ; store table size
                                            ;link it in to the table chain (at the
                                            ;beginning for speed in retrieval)

        MOV     R5,R2                       ;save the start of the block
        FRAMLDR R3,,R12                     ;recover workspace pointer
        LDR     R4,[R3,#anchor_tables]      ;get the anchor value
        STR     R2,[R3,#anchor_tables]      ;replace it with this one
        ASSERT  cachedtable_next = 0
        STR     R4,[R2],#4                  ;and link from this one to the old one

        MOV     R3,R11,LSL #2
        ASSERT  cachedtable_palsize = 4
        STR     R3,[R2],#8                  ;set the palette size (R2 now -> palette)

        ASSERT  cachedtable_palette = 12
81      LDR     R7,[R6],#4                  ;copy the palette entries across
        STR     R7,[R2],#4
        SUBS    R3,R3,#4
        BNE     %BT81                       ;both structures are same up until the end
                                            ;of the palette data.

        ; Copy over the 32K+ header
        ASSERT  CTrans32Kplus_ExpectedSize = 5*4
        ADD     R0,SP,#make32k_header
        LDMIA   R0,{R0,R3,R6,R10,LR}
        STMIA   R2!,{R0,R3,R6,R10,LR}
        

        MOV     R6,R2
        Debug   table32K,"Loading via load_and_unsquash"
        BL      load_and_unsquash
        LDRVS   R0,[SP,#make32k_tablesize]
        LDRVS   R10,[SP,#make32k_header+CTrans32Kplus_SrcModeFlags]
        BVS     %FT80
        Debug   table32K,"Loaded via load_and_unsquash"

        Debug   table32K,"Successfully loaded file"

83
        ;colourarray wasn't claimed from rma, so don't release it!
86

        MOV     colourarray,R6               ;return colourarray=table location

        ; just the palette to release
        B       release_palette

73
        LDR     R4,[R3,#cachedtable_next]    ;fetch the next link
        TEQ     R4,#0                        ;and go round again if not null
        MOVNE   R3,R4
        BNE     %BT72

80
        ;unfortunately this is a brand new palette, so we have to make a 32K table

; new later location to avoid the disruption caused by transient claims for tables
; which turn out to be available from reourcefs

; allocate memory for scratch table

        MOV     R5,R0
        MOV     R0,#ModHandReason_Claim
        ADD     R3,R5,R11,LSL #2
        ADD     R3,R3,#cachedtable_palette+CTrans32Kplus_ExpectedSize
        SWI     XOS_Module
        Debug   table32K,"claiming for scratchtable",R3
        BVS     exit_32k
        MOV     R8,R10                              ;protect modeflags (currently in R10, i.e. colourarray)
        MOV     colourarray,R2
        STR     colourarray,[WP,#temp_table]        ;save location in workspace so it can
                                                    ;be deallocated if still active when
                                                    ;CTrans dies

        Debug   table32K,"Table will be at ",colourarray
        STR     R5,[colourarray,#cachedtable_tabsize] ; store table size

        MOV     R0,#ModHandReason_Claim             ;claim 32K for the error array
        MOV     R3,R5                               ;(holds the error value for the current
                                                    ;colour choice in the 32K array)
        Debug   table32K,"claiming for errorarray",R3
        SWI     XOS_Module
        BVS     exit_32k
        STR     R2,[WP,#temp_errortable]            ;save location in workspace so it can
                                                    ;be deallocated if still active when
                                                    ;CTrans dies
        MOV     errorarray,R2

        Debug   table32K,"errorarray",errorarray

; ***** errorarray = r12 - don't use WP anymore

        ;change colourarray so it points at the 32K block rather than the start of
        ;the claimed area

        Debug   table32K,"Changing colourarray from",colourarray
        MOV     R1,R11,LSL #2
        STR     R1,[colourarray,#cachedtable_palsize] ;set up the palette size
        ADD     colourarray,colourarray,#cachedtable_palette ;add on overhead for next pointer & size word
84      SUBS    R1,R1,#4
        LDR     R2,[palette,R1]              ;copy across palette entries from wherever
        STR     R2,[colourarray,R1]          ;they came from
        BNE     %BT84

        MOV     palette,colourarray          ;point algorithm at the palette

        ; Copy over the 32K+ header, and move colourarray to the 32K space
        ASSERT  CTrans32Kplus_ExpectedSize = 5*4
        ADD     R0,SP,#make32k_header
        LDMIA   R0,{R0-R3,LR}
        ADD     colourarray,colourarray,R11,LSL #2
        STMIA   colourarray!,{R0-R3,LR}

        Debug   table32K,"to",colourarray

        ; Pull in the main algorithm
        ; We have six versions, for the different pixel formats and RGB orders
        ; supported

        LDR     R0,[palette,#cachedtable_tabsize-cachedtable_palette] ; recover table size
        ASSERT  ModeFlag_DataFormatSub_RGB = 4:SHL:12
        AND     R8,R8,#ModeFlag_DataFormatSub_RGB
        CMP     R0,#32768
        ADDLT   R8,R8,#8:SHL:12
        ADDGT   R8,R8,#16:SHL:12
        ADD     PC,PC,R8,LSR #12
        NOP
        B       make32K_32K_BGR
        B       make32K_32K_RGB
        B       make32K_4K_BGR
        B       make32K_4K_RGB
        B       make32K_64K_BGR
        B       make32K_64K_RGB

; Assume ARMv7+ has large enough caches to not need the small cache optimisation. Ideally we'd query the kernel at runtime for the cache size, but for now this will do.
smallcache  SETL NoARMv7

        ; 32K cases
make32K_32K_BGR
red_bits    SETA 5
green_bits  SETA 5
blue_bits   SETA 5
red_shift   SETA 16-5
green_shift SETA 24-5
blue_shift  SETA 32-5
        GET      TablesAlgo.s
        B        make32K_finishing

make32K_32K_RGB
red_shift   SETA 32-5
blue_shift  SETA 16-5
        GET      TablesAlgo.s
        B        make32K_finishing

        ; 4K cases
make32K_4K_BGR
red_bits    SETA 4
green_bits  SETA 4
blue_bits   SETA 4
red_shift   SETA 16-4
green_shift SETA 24-4
blue_shift  SETA 32-4
        GET      TablesAlgo.s
        B        make32K_finishing

make32K_4K_RGB
red_shift   SETA 32-4
blue_shift  SETA 16-4
        GET      TablesAlgo.s
        B        make32K_finishing

        ; 64K cases
make32K_64K_BGR
red_bits    SETA 5
green_bits  SETA 6
blue_bits   SETA 5
red_shift   SETA 16-5
green_shift SETA 24-6
blue_shift  SETA 32-5
        GET      TablesAlgo.s
        B        make32K_finishing

make32K_64K_RGB
red_shift   SETA 32-5
blue_shift  SETA 16-5
        GET      TablesAlgo.s
        ; Fall through....

make32K_finishing
        ;link the table in
        SUB     R5,colourarray,#cachedtable_palette+CTrans32Kplus_ExpectedSize
        SUB     R5,R5,R11,LSL #2            ; set r5 to start of claimed space

        Debug   table32K,"Linking into tables as",R5

        FRAMLDR R2,,R12                     ; fetch the anchor for the tables
        LDR     R3,[R2,#anchor_tables]      ; fetch the present first entry
        STR     R5,[R2,#anchor_tables]      ; store this as new first entry
        STR     R3,[R5,#cachedtable_next]   ; and link from this one to old first entry
        MOV     R5,#0
        STR     R5,[R2,#temp_table]         ; forget about having claimed it - it is
                                             ; now covered in the anchor_tables chain
        ; moved here so we don't get fussy when all that's been returned is a pointer
        ; to a rom table
        [ immortal
        STRVC   LR,[R2,#persist]             ; refuse to die - we have passed out addresses
                                             ; of rma we claimed
        ]

found_a_table
        Debug   table32K,"Found/Built a table - freeing workspace"
        MOV     R0,#ModHandReason_Free
        MOV     R2,errorarray                ; release the guard array & palette
        SWI     XOS_Module
        Debug   table32K,"freeing errorarray"
release_palette
        MOV     R0,#ModHandReason_Free
        MOV     R2,palette
        SWI     XOS_Module
        Debug   table32K,"freeing palette"

        FRAMLDR R5,,R12                      ;fetch stacked R12

        MOV     R4,#0
        STR     R4,[R5,#temp_palette]
        STR     R4,[R5,#temp_errortable]     ; and mark them as released
        CLRV

exit_32k
        FRAMSTR R0,VS                        ; store error pointer if an error occurred
        BVS     exit_32k_error

        FRAMLDR R4                           ; fetch callers R4 (where to put selecttable)

        ; Work out if this needs to be a "32K." or "32K+" table
        ASSERT  CTrans32Kplus_SrcNColour = 0
        ASSERT  CTrans32Kplus_SrcModeFlags = 4
        ASSERT  CTrans32Kplus_SrcLog2BPP = 8
        ADD     R0,SP,#make32k_header
        LDMIA   R0,{R0-R2}
        ADD     R0,R0,#1
        CMP     R1,#0
        CMPEQ   R2,#4
        CMPEQ   R0,#65536
        LDREQ   R0,thirtytwok
        LDRNE   R0,thirtytwokplus
        DebugIf NE,table32K,"Returning 32K+ table"
        STR     R0,[R4,#0]                   ; store the first guardword
        Debug   table32K,"Returned table pointer is",colourarray
        STR     colourarray,[R4,#4]          ; the pointer to the 32K table
        STR     R0,[R4,#8]                   ; and the second guardword

        MOV     R10,#12                      ; set R10 (size of generated table) to 12
        FRAMSTR R10           

exit_32k_error
        [ debugtable32K
        PullEnv                              ; get registers back
        Debug   table32K,"32K return",R0,R1,R2,R3,R4
        Debug   table32K,"stack out is",R13
        MOV     R15,R14
        |
        EXIT
        ]

sqshtag
        = "SQSH"

thirtytwok
        =       "32K."

thirtytwokplus
        =       "32K+"

tablepath = "Resources:$.Resources.Colours.Tables.",0
        ALIGN

; load file and unsquash it if necessary
; => r1-> filename
;    r2-> 32k block to put it in
load_and_unsquash ROUT
        Push     "r1-r8,lr"

        Debug    table32K,"load and unsquash"

        MOV      r7,r2                    ; remember 'real' 32k table pointer
        MOV      r0,#OSFile_ReadInfo
        DebugS   table32K,"readinfo on file ",R1
        SWI      XOS_File
        BVS      %FT80

        MOV      r6,r0
        MOV      r0,#FSControl_InfoToFileType
        SWI      XOS_FSControl
        BVS      %FT80
        Debug    table32K,"to filetype gave ",R2

        SUB      r2,r2,#FileType_Squash :AND: &f00
        TEQ      r2,#FileType_Squash :AND: &0ff
        BNE      %FT90                             ; it's not squashed

        Debug    table32K,"it's squashed; we need to unsquash it"
        ; it's a squash file; we need to
        ;  1 find workspace needed
        ;  2 allocate memory for ws and file
        ;  3 load file
        ;  4 unsquash the file into destination block
        ;  5 unallocate memory

        ; do 1.
        MOV      r0,#2_1000         ; we know it should fit
        MOV      r1,#-1
        SWI      Squash_Decompress
        BVS      %FT80
        ADD      r3,r0,r4           ; amount of space we need
        Debug    table32K,"squash needs ",R0

        ; do 2.
        MOV      R0,#ModHandReason_Claim
        Debug    table32K,"claiming workspace for unsquash ",R3
        SWI      XOS_Module
        BVS      %FT80

        MOV      r8,r2              ; r8-> workspace

        ; do 3.
        MOV      r0,#OSFile_LoadNoPath
        LDR      r1,[sp]            ; re-read filename
        MOV      r3,#0
        Debug    table32K,"loading file to ",R2
        SWI      XOS_File
        BVS      %FT85

        ; do 4.
        MOV      r0,#2_0100         ; we know it should fit
        ADD      r1,r8,r4           ; workspace is at the end
        ADD      r1,r1,#3
        BIC      r1,r1,#3           ; align it
        ADD      r2,r8,#20          ; input pointer
        SUB      r3,r4,#20          ; input size
        MOV      r4,r7              ; output pointer
        MOV      r5,#&8000          ; output size = 32k
        Debug    table32K,"decompressing file"
        SWI      XSquash_Decompress
        BVS      %FT85

        ; do 5.
        MOV      R0,#ModHandReason_Free
        MOV      R2,R8
        Debug    table32K,"releasing workspace for unsquash ",R2
        SWI      XOS_Module
;         BVS      %FT80

80
        Debug    table32K,"returning..."
        Pull     "r1-r8,pc"

85
        Debug    table32K,"error while in processing code ",R2
        MOV      R3,r0

        MOV      R0,#ModHandReason_Free
        MOV      R2,R8
        Debug    table32K,"releasing workspace for unsquash ",R2
        SWI      XOS_Module

        MOV      R0,R3
        SETV
        B        %BT80

90
        Debug    table32K,"loading normal file to ",R7
        MOV      r0,#OSFile_LoadNoPath
        MOV      r2,r7
        MOV      r3,#0
        SWI      XOS_File
        B        %BT80

        END
@


4.5
log
@Update to cope with new pixel formats
Detail:
  s/Commons - Update best/worst colour code to add support for all the new RGB pixel format variations
  s/Dither - Rework code to remove reliance on now removed get_physical16bpp routine
  s/Enhanced - Drop support for VIDC enhancer. "VIDC20" code enhanced to add support for all the new RGB pixel formats, mainly reliant on new ColourConv macro. Drop get_physical16bpp routine as it wasn't really needed and would have been a pain to update.
  s/FontColours - Remove reference to obsolete PseudoPaletteEntry variable
  s/Header - Update workspace to clarify how certain variables are overlaid over the colour cache entries. Rename temp_guardtable to temp_errortable as the name makes more sense to me. Cache current modeflags & log2 NColour in InitCache.
  s/MainSWIs - Flag_* -> ModeFlag_* renaming. Pass through source mode to make32Ktable
  s/Palettes - Strip out some old Module_Version switches to make code more readable. Cache current modeflags and log2 NColour values when dealing with sprite output.
  s/Tables32K - Table generation code rewritten to add support for new 16bpp pixel formats, be faster, and (hopefully) more readable. Core generation code has been split off into seperate file, s/TablesAlgo, as it's needed multiple times but is too big for a macro.
  s/TablesAlgo - New file containing core code for the "32K" table generation. Disregarding pixel format differences, it can be assembled in two forms, optimised either for large or small data caches. New code is 85% faster on BB-xM (large cache version), 43% faster on Iyonix and 80% faster on StrongARM (both small cache version).
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification
  Code is in need of updating to allow caller to identify which type of 32K table has been returned (i.e. old-style 32K table or some new kind of 4K/32K/64K one)


Version 1.86. Tagged as 'Colours-1_86'
@
text
@d25 2
a26 1
;after palette  leafname               32K table
d62 7
d71 2
a80 2
        STMFD   R13!,{R0-R12,R14}

d82 1
a82 1
        LDR     R0,[R13,#8]                         ;recover stacked R2
d93 1
a93 1
        LDR     R5,[R13,#12]                        ;get stacked R3 back
d121 1
a121 1
        LDR     R0,[R13,#48]                        ;fetch R12, workspace pointer
d185 1
a185 1
        LDR     R0,[R13]                    ; recover R0
d190 3
a192 1
        MOVHI   R0,#32768                   ; HACK - only produce standard 32K table for >15bpp source mode
d194 1
a195 1
        MOV     R3,R2
a198 2
        ANDS    R10,R2,#ModeFlag_DataFormatSub_RGB ; Extract RGB order
        LDRNE   R10,=&FF00FF00              ; get mask for red/blue swapping
d200 1
d208 14
a221 1
        Debug table32K,"red/blue swapped =",R10
d248 1
a248 1
        LDR     R3,[R13,#48]                ; recover R12
d263 22
a284 1
                                            ;right size palette - check the entries
a292 1
        AND     R2,R5,R10
a293 2
        BIC     R5,R5,R10
        ORR     R5,R5,R2,ROR #16            ; red/blue swap (or nop if R10=0)
d297 1
a297 1
        BEQ     %BT77                       ;matched - try next colour
d302 1
a310 1
; check whether this is the right palette for a table held in resourcefs
d313 25
a337 1
        LDR     R3,[R13,#48]
d353 1
a353 1
        ;right size palette - check the entries
a361 1
        AND     R2,R5,R10
a362 2
        BIC     R5,R5,R10
        ORR     R5,R5,R2,ROR #16            ; red/blue swap (or nop if R10=0)
d366 1
a366 1
        BEQ     %BT74                       ;matched - try next colour
a370 2
        Push    "R0,R10"                    ;Preserve size, R/B swap mask just in case

d381 6
a386 1
        ADD     R6, R6, R3                  ;start of leafname
d388 1
a388 1
        LDR     WP,[R13,#48+8]
d398 1
d400 1
a400 1
        LDRB    R5,[R6],#1                  ;copy the name, including terminator
d407 1
a407 1
        Debug    table32K,"full filename at",R1
a408 1
      [ nomessagetransfortables
a415 1
        ADDVS   SP,SP,#8
d421 1
a421 1
        MOV     r1, r0
a434 1
        ADDVS   SP,SP,#8
d446 1
a448 1
        ADD     SP,SP,#8
a449 29
sqshtag
        = "SQSH"
      | ; nomessagetransfortables
        ;now call MessageTrans to decide whether the table has to be expanded or not

        SWI     XMessageTrans_FileInfo
        Debug   table32K,"FileInfo returned",R0
        ADDVS   SP,SP,#8
        BVS     exit_32k
        TST     R0, #1                      ;if NE the file may be accessed directly
        BEQ     %FT85

        ;R1 still filename from above
        MOV     R0, colourarray
        MOV     R2, #0                      ; insist on in-situ access
        SWI     XMessageTrans_OpenFile
        ADDVS   SP,SP,#8
        BVS     exit_32k

        ;*** warning *** MessageTrans doesn't tell you where the file is!
        ;so we have to go grubbing around in the info block
        LDR     R6, [R0, #8]                ; word before start of file
        ADD     R6, R6, #4
        SWI     XMessageTrans_CloseFile

        Debug   table32K,"Using it in situ at",R6
        ADD     SP,SP,#8
        B       %FT86                       ; got the address - return it
      ] ; nomessagetransfortables
d466 1
a466 1
        ADD     R3,R5,#cachedtable_palette  ;space needed for header
a469 1
        ADDVS   SP,SP,#8
d476 1
a476 1
        LDR     R3,[R13,#48+8]              ;recover workspace pointer
d493 14
a506 13
      [ nomessagetransfortables
        MOV      R6,R2
        Debug    table32K,"Loading via load_and_unsquash"
        BL       load_and_unsquash
        Pull     "R0,R10",VS
        BVS      %FT80
        Debug    table32K,"Loaded via load_and_unsquash"
      |
        MOV     R6,R2                       ;save the 32K start address

        SUB     R2,R2,#4
        LDR     R7,[R2]                     ;and remember the last word of the palette table
                                            ;which messagetrans will overwrite
d508 1
a508 2
        MOV     R0, colourarray
        Debug    table32K,"full filename at",R1
a509 10
        SWI      XMessageTrans_OpenFile     ;load (and unsquash if squashed text file)
        Pull     "R0,R10",VS
        BVS      %FT80
        SWI      XMessageTrans_CloseFile    ;thankyou MessageTrans, and now forget it!
        STR      R7,[R2]                    ;replace the altered word
        Debug    table32K,"Loaded via MessageTrans"
      ]

        Debug   table32K,"Successfully loaded file"
        ADD     SP,SP,#8
d536 1
a536 1
        ADD     R3,R3,#cachedtable_palette
d540 1
a540 1
        MOV     R8,R10                              ;protect R/B mask (currently in R10, i.e. colourarray)
d573 1
a573 4
        AND     R0,R2,R8                     ;they came from, performing red/blue
        BIC     R2,R2,R8                     ;swapping if necessary
        ORR     R2,R2,R0,ROR #16
        STR     R2,[colourarray,R1]
d576 1
a576 1
        MOV     palette,colourarray          ;point algorithm at the red/blue swapped palette
d578 6
a583 1
        LDR     R0,[colourarray,#cachedtable_tabsize-cachedtable_palette] ; recover table size
d585 1
a585 2
        ADD     colourarray,colourarray,R11,LSL #2
        Debug   table32K,"to",colourarray    ;and move colourarray to the 32K space
d588 2
a589 5
        ; We have three versions, for the different pixel formats supported
        ; Although TablesAlgo is capable of doing red/blue swapping itself,
        ; we currently red/blue swap the palette in order to avoid having large
        ; numbers of routines (plus there's a chance for more cache hits if
        ; we've been given a palette where R==B)
d591 3
d595 10
a604 2
        BLT     make32K_4K
        BGT     make32K_64K
d609 2
a610 1
        ; 32K case
d620 8
a627 2
make32K_4K
        ; 4K case
d637 8
a644 2
make32K_64K
        ; 64K case
d652 1
d654 5
d662 2
a663 2
        SUB      R5,colourarray,#cachedtable_palette
        SUB      R5,R5,R11,LSL #2            ; set r5 to start of claimed space
d665 1
a665 1
        Debug    table32K,"Linking into tables as",R5
d667 6
a672 6
        LDR      R2,[R13,#48]                ; fetch the anchor for the tables
        LDR      R3,[R2,#anchor_tables]      ; fetch the present first entry
        STR      R5,[R2,#anchor_tables]      ; store this as new first entry
        STR      R3,[R5,#cachedtable_next]   ; and link from this one to old first entry
        MOV      R5,#0
        STR      R5,[R2,#temp_table]         ; forget about having claimed it - it is
d677 1
a677 1
        STRVC   LR,[WP,#persist]             ; refuse to die - we have passed out addresses
d693 1
a693 1
        LDR     R5,[R13,#48] ;fetch stacked R12
d701 2
a702 1
        STRVS   R0,[R13]                     ; store error pointer if an error occurred
d704 1
a704 1
        LDRVC   R4,[R13,#16]                 ; fetch callers R4 (where to put selecttable)
d706 14
a719 2
        LDRVC   R0,thirtytwok
        STRVC   R0,[R4,#0]                   ; store the first guardword
d721 2
a722 5
        STRVC   colourarray,[R4,#4]          ; the pointer to the 32K table
        STRVC   R0,[R4,#8]                   ; and the second guardword

        MOVVC   R10,#12                      ; set R10 (size of generated table) to 12
        STRVC   R10,[R13,#40]
d724 2
a725 1
        LDMFD   R13!,{R0-R12,R14}            ; get registers back
d727 1
d729 1
d732 3
d736 3
a738 1
        MOV     R15,R14
d743 3
a748 6
      [ nomessagetransfortables
Squash_Compress      * &42700
XSquash_Compress     * &62700
Squash_Decompress    * &42701
XSquash_Decompress   * &62701

a848 1
      ]
@


4.4
log
@  A couple of fixes for top-bit-set pointers.
Detail:
  ColourTrans_WritePalette:
    * sprite area pointer in R0 can now be top-bit set
  ColourTrans_SelectTable/GenerateTable where R0/R1 reference a mode/palette
  combination rather than a sprite and where the source mode is 16/32bpp:
    * destination palette pointer in R3 can be top-bit set
    * giving R3 a value of 0 (default for the mode) now works
Admin:
  Tested briefly.

Version 1.72. Tagged as 'Colours-1_72'
@
text
@d23 2
a24 1
;8...           Palette                Palette
d27 6
d35 1
a35 6
;that r12 is reused.

         [ med_02882
;r12 is safe now unless we actually need to construct a table from scratch,
;since guardarray is only allocated at that point
         ]
d41 4
a44 5
tableoffset RN 2
loopblue RN 6
loopgreen RN 7
loopred RN 8
guardarray RN 12
d48 14
a72 54
; [R12] = guard array
; [R10] = colours array
; R0, R1 = scratch usage
; R11 = number of colours
; R9 = palette space

        [ med_02882
        ; we do this later now
        | ; med_02882
; allocate memory for scratch table

        MOV     R0,#ModHandReason_Claim             ;claim maximum size likely to be needed
        MOV     R3,#&8400                           ;in case this becomes a permanent block
        ADD     R3,R3,#8
        SWI     XOS_Module
        BVS     exit_32k
        MOV     colourarray,R2
        STR     colourarray,[WP,#temp_table]        ;save location in workspace so it can
                                                    ;be deallocated if still active when
                                                    ;CTrans dies

        Debug   table32K,"Table will be at ",R2

        MOV     R0,#ModHandReason_Claim             ;claim 32K for the guard count array
        MOV     R3,#&8000                           ;(holds the error value for the current
                                                    ;colour choice in the 32K array)
        SWI     XOS_Module
        BVS     exit_32k
        STR     R2,[WP,#temp_guardtable]            ;save location in workspace so it can
                                                    ;be deallocated if still active when
                                                    ;CTrans dies
        MOV     guardarray,R2

        Debug   table32K,"guardarray",guardarray

; ***** guardarray = r12 - don't use WP anymore

        MOV     R2,#-1                              ;Set up the guardarray with the worst
        MOV     R3,R2                               ;possible result so that all entries
        MOV     R4,R2                               ;will get changed (note: max possible
        MOV     R5,R2                               ;value during calculation is 31+31+31
        MOV     R6,R2                               ;ie 93 - we are initing with 255)
        MOV     R7,R2
        MOV     R8,R2
        MOV     R9,R2
        ADD     R1,guardarray,#&8000                ;set up to word above top of array
15
        STMDB   R1!,{R2-R9}                         ;do 8 words at a time
        ;Debug   table32K,"Stored eight words at",R1
        CMP     R1,guardarray
        BHI     %BT15
        Debug   table32K,"Finished"
        ] ; med_02882

d83 1
a83 1
        Debug   table32K,"Number of colours",R11
d174 27
d209 1
a209 1
; r3-r8 are free at the moment
d231 3
a233 1
        LDR     R4,[R3,#4]                  ; collect size
d236 1
d238 1
d242 1
a242 1
        ADD     R6,R3,#8                    ; r6=pointer to one to test
d250 1
d252 2
d262 1
a262 1
        B       %FT83                       ;release claimed space & return table
d265 1
a265 1
        LDR     R4,[R3]                     ;read the next pointer
d272 2
a273 1
70      LDR     R3,[R13,#48]
d278 3
a280 1
        LDR     R4,[R3,#4]                  ;collect size
d282 2
a283 1
        Debug   table32K,"size of resourcefs table =",R4
d286 1
d290 1
a290 1
        ADD     R6,R3,#8                    ;r6=pointer to one to test
d298 1
d300 2
d310 2
a311 1
        [ med_02882
d316 1
a316 1
        SUB     R8, R6, #8                  ;now R8->start of record
d319 1
a319 1
        ; guardarray and colourarray are not used yet here
d321 1
a321 1
        LDR     R3, [R6, #-4]               ;length of palette table
d324 1
a324 1
        LDR     WP,[R13,#48]
d352 1
d372 1
d386 1
d395 1
d404 1
a411 1
      ] ; nomessagetransfortables
d414 1
d416 1
d425 1
a425 1
        ADD     R6, R8, #8                  ;point at the palette entries
d432 2
a433 2
        MOV     R3,#&8000                   ;32K for the table
        ADD     R3,R3,#8                    ;2 words for next pointer and #colours
d437 1
d439 1
d444 1
a444 1
        LDR     R3,[R13,#48]                ;recover workspace pointer
d447 1
d451 2
a452 1
        STR     R3,[R2],#4                  ;set the palette size (R2 now -> palette)
d454 1
d465 1
d479 1
d487 1
a490 93
        | ;med_02882
                                            ;next thing is to build a full
                                            ;entry for this one - the palette is in
                                            ;memory, but the table is still in
                                            ;resourcefs
        MOV     R0,#ModHandReason_Claim
        MOV     R3,#&8000                   ;32K for the table
        ADD     R3,R3,#8                    ;2 words for next pointer and #colours
        ADD     R3,R3,R11,LSL #2            ;space for colours
        SWI     XOS_Module
        BVS     %FT73
                                            ;link it in to the table chain (at the
                                            ;beginning for speed in retrieval)

        MOV     R5,R2                       ;save the start of the block
        LDR     R3,[R13,#48]                ;recover workspace pointer
        LDR     R4,[R3,#anchor_tables]      ;get the anchor value
        STR     R2,[R3,#anchor_tables]      ;replace it with this one
        STR     R4,[R2],#4                  ;and link from this one to the old one

        MOV     R3,R11,LSL #2
        STR     R3,[R2],#4                  ;set the palette size (R2 now -> palette)

81      LDR     R7,[R6],#4                  ;copy the palette entries across
        STR     R7,[R2],#4
        SUBS    R3,R3,#4
        BNE     %BT81                       ;both structures are same up until the end
                                            ;of the palette data.

        Debug   table32K,"filename is at",R6
        Debug   table32K,"load it to",R2

        [ {TRUE}
        ;enable loading of squashed files with automatic decompression
        ;by messagetrans

        ADRL    R3,tablepath                ;pathname for table in resourcefs
        ADD     R4,colourarray,#16          ;scratchspace for name
91
        LDRB    R5,[R3],#1                  ;copy the path, excluding terminator
        TEQ     R5,#0
        STRNEB  R5,[R4],#1
        BNE     %BT91
92
        LDRB    R5,[R6],#1                  ;copy the name, including terminator
        STRB    R5,[R4],#1
        TEQ     R5,#0
        BNE     %BT92

      [ nomessagetransfortables
        MOV     R6,R2
        ADD     r1,colourarray,#16
        Debug   table32K,"full filename at",R1
        BL      load_and_unsquash
        BVS     %FT80
        Debug   table32K,"Loaded via load_and_unsquash"
      |
        MOV     R6,R2                       ;save the 32K start address
        SUB     R2,R2,#4
        LDR     R7,[R2]                     ;and the last word of the palette table
                                            ;which messagetrans will overwrite

        MOV     R0,colourarray              ;use first four words as MessageTrans descriptor
        ADD     R1,R0,#16
        Debug    table32K,"full filename at",R1

        SWI      XMessageTrans_OpenFile     ;load (and unsquash if squashed text file)
        BVS      %FT80
        SWI      XMessageTrans_CloseFile    ;thankyou MessageTrans, and now forget it!
        STR      R7,[R2]                    ;replace the altered word
        Debug    table32K,"Loaded via MessageTrans"
      ]
        |
        MOV     R1,R6
        MOV     R6,R2                        ;save the load destination...
        MOV     R3,#0
        MOV     R0,#12
        ADRL    R4,tablepath
        SWI     XOS_File
        BVS     %FT80
        ] ; {TRUE}

        Debug   table32K,"Successfully loaded file"
83
        MOV     R0,#ModHandReason_Free       ;we don't need colourarray anymore, so
        MOV     R2,colourarray               ;release it
        SWI     XOS_Module

        LDR     R5,[R13,#48] ;fetch stacked R12

        MOV     R4,#0
        STR     R4,[R5,#temp_table]          ;and mark it as released
        ] ; med_02882
a493 1
        [ med_02882
a495 4
        |
        ; rma claims to release
        B       found_a_table                ;(ie where we just loaded it)
        ]
d498 1
a498 1
        LDR     R4,[R3]                      ;fetch the next link
a505 1
        [ med_02882
d511 4
a514 3
        MOV     R0,#ModHandReason_Claim             ;claim maximum size likely to be needed
        MOV     R3,#&8400                           ;in case this becomes a permanent block
        ADD     R3,R3,#8
d518 1
d524 2
a525 1
        Debug   table32K,"Table will be at ",R2
d527 2
a528 2
        MOV     R0,#ModHandReason_Claim             ;claim 32K for the guard count array
        MOV     R3,#&8000                           ;(holds the error value for the current
d530 1
a530 1
        Debug   table32K,"claiming for guardarray",R3
d533 1
a533 1
        STR     R2,[WP,#temp_guardtable]            ;save location in workspace so it can
d536 1
a536 3
        MOV     guardarray,R2

        Debug   table32K,"guardarray",guardarray
d538 1
a538 27
; ***** guardarray = r12 - don't use WP anymore

        [ med_03007
        STMFD   R13!,{palette}                      ;save R9
        ]

        MOV     R2,#-1                              ;Set up the guardarray with the worst
        MOV     R3,R2                               ;possible result so that all entries
        MOV     R4,R2                               ;will get changed (note: max possible
        MOV     R5,R2                               ;value during calculation is 31+31+31
        MOV     R6,R2                               ;ie 93 - we are initing with 255)
        MOV     R7,R2
        MOV     R8,R2
        MOV     R9,R2
        ADD     R1,guardarray,#&8000                ;set up to word above top of array
15
        STMDB   R1!,{R2-R9}                         ;do 8 words at a time
        ;Debug   table32K,"Stored eight words at",R1
        CMP     R1,guardarray
        BHI     %BT15

        [ med_03007
        LDMFD   R13!,{palette}                      ;recover R9
        ]

        Debug   table32K,"Finished"
        ]
d540 1
a540 1
        Debug   table32K,"at 80 guardarray is",guardarray
d547 2
a548 2
        STR     R1,[colourarray,#4]          ;set up the palette size
        ADD     colourarray,colourarray,#8   ;add on overhead for next pointer & size word
d551 4
a554 1
        STR     R2,[colourarray,R1]          ;they came from
d557 4
d564 44
a607 80
        MOV     thiscolour,#0                ; colour number being processed
25
        LDR     R1,[palette,thiscolour,LSL #2]   ; fetch its palette entry

        ;do the indexing the quick and dirty way, ie *32 /256
        ;rather than *31 /255
        AND     R3,R1,#&F8000000             ;mask each down to five bits
        AND     R4,R1,#&00F80000
        AND     R5,R1,#&0000F800

        MOV     tableoffset,R3,LSR #17
        ORR     tableoffset,tableoffset,R4,LSR #14
        ORR     tableoffset,tableoffset,R5,LSR #11 ; r2 = offset into table

        MOV     R3,R3,LSR #27                ; r3 = blue
        MOV     R4,R4,LSR #19                ; r4 = green
        MOV     R5,R5,LSR #11                ; r5 = red

                                             ; fill in the direct hit for this colour
        STRB    thiscolour,[colourarray,tableoffset]

        MOV     loopblue,#0                  ; loop blue
        STRB    loopblue,[guardarray,tableoffset] ; set the guard marker at zero

        MOV     loopgreen,#0                 ; loop green
        MOV     loopred,#0                   ; loop red
        ;Debug   table32K,"thiscolour",thiscolour
35
        ;Debug   table32K,"loopblue, loopgreen, loopred",loopblue,loopgreen,loopred
        ;R1,R2 & LR free

        MOV     R2,loopred
        ORR     R2,R2,loopgreen,LSL #5
        ORR     R2,R2,loopblue,LSL #10       ; build a table index
        LDRB    R2,[guardarray,R2]           ; fetch the current error from there

        CMP     R3,loopblue                  ; calculate positive blue distance
        SUBCS   R1,R3,loopblue
        SUBCC   R1,loopblue,R3
        CMP     R1,R2
        BCS     %FT36

        CMP     R4,loopgreen
        SUBCS   R14,R4,loopgreen             ; calculate positive green distance
        SUBCC   R14,loopgreen,R4
        ADD     R1,R1,R14                    ; and accumulate in R1
        CMP     R1,R2
        BCS     %FT36

        CMP     R5,loopred
        SUBCS   R14,R5,loopred               ; calculate positive red distance
        SUBCC   R14,loopred,R5
        ADD     R1,R1,R14                    ; for final error in R1
        CMP     R1,R2
        BCS     %FT36

        MOV     R2,loopred
        ORR     R2,R2,loopgreen,LSL #5
        ORR     R2,R2,loopblue,LSL #10       ; build a table index

        STRCCB  R1,[guardarray,R2]           ; it is, so replace the error
        STRCCB  thiscolour,[colourarray,R2]  ; ... and the colour choice

;        [ debugtable32K
;        BCS     %FT88
;        Debug   table32K,"Stored colour"
;88
;        ]
36
        ADD     loopred,loopred,#1           ; increment red
        ANDS    loopred,loopred,#31          ; keep in range 0-31
        BNE     %BT35                        ; loop if nonzero (ie not 32 yet)

        ADD     loopgreen,loopgreen,#1       ; green loop
        ANDS    loopgreen,loopgreen,#31
        BNE     %BT35

        ADD     loopblue,loopblue,#1         ; blue loop
        ANDS    loopblue,loopblue,#31
        BNE     %BT35
a608 4
        ADD     thiscolour,thiscolour,#1     ; next colour
        CMP     thiscolour,R11

        BCC     %BT25                        ; around again until we've done all colours
d610 1
d612 1
a612 1
        SUB      R5,colourarray,#8
d620 1
a620 1
        STR      R3,[R5]                     ; and link from this one to old first entry
a623 1
        [ med_02882
a629 1
        ]
d634 1
a634 1
        MOV     R2,guardarray                ; release the guard array & palette
d636 1
a636 2
        Debug   table32K,"freeing guardarray"
        [ med_02882
a638 1
        ]
d647 1
a647 1
        STR     R4,[R5,#temp_guardtable]     ; and mark them as released
a667 13
        ]

        [ med_02882
        ; do this elsewhere, so that we only complain when we've had to build a table
        ; as opposed to simply passing a pointer to one in ROM
        |
        [ immortal
        STRVC   LR,[WP,#persist]             ; refuse to die - we have passed out addresses
                                             ; of rma we claimed
        ]
        ]

        [ debugtable32K
@


4.3
log
@  Corrected minor bug in unsquash code.
Detail:
  * Unsquash code would leave a register unset and corrupt another,
    resulting in some expansions of the files failing. Also, it would fail
    to free the memory that was allocated for the temporary file load.
Admin:
  Tested locally. But then it worked locally last time because it relied
  on one register holding a semi-valid value.

Version 1.71. Tagged as 'Colours-1_71'
@
text
@a128 4
        CMP     R5,#0

        MOVPL   palette,R5
        BPL     %FT24                               ;palette supplied - use it
d130 2
a131 1
; current or default ?
d133 2
a134 1
        BNE     %FT23                               ; -1 - use current palette
@


4.2
log
@  32k sprites plotted in 256 colour modes crashes.
Detail:
  * MessageTrans now does hashing when files are opened. ColourTrans does
    OpenFile then CloseFile to access the files. This is evil. Changed to
    make ColourTrans unsquash files and load them itself.
Admin:
  Fixes Bugzilla 17.

Version 1.70. Tagged as 'Colours-1_70'
@
text
@d66 1
a66 1
        |
d110 1
a110 1
        ]
d385 1
a385 1
      |
d405 2
a406 1
      ]
d475 1
a475 1
        |
d530 1
a530 1
        Debug    table32K,"Loaded via load_and_unsquash"
d555 1
a555 1
        ]
d567 1
a567 1
        ]
d905 1
a905 1
        MOV      r8,#&8000          ; output size = 32k
d915 1
a915 1
        BVS      %FT80
@


4.1
log
@Initial revision
@
text
@d52 1
a52 1
        ROUT                                          
d56 2
a57 2
        STMFD   R13!,{R0-R12,R14}             
                     
d59 1
a59 1
; [R10] = colours array        
d63 1
a63 1
                                
d66 1
a66 1
        |                        
d89 1
a89 1
        MOV     guardarray,R2        
d108 1
a108 1
        BHI     %BT15                     
d118 1
a118 1
        MOV     R0,#1 
d123 1
a123 1
        
d128 1
a128 1
        Debug   table32K,"stacked R3",R5                                         
d137 1
a137 1
         
d150 1
a150 1
        SWI     XOS_Module   
d153 1
a153 1
        MOV     palette,R2  
d204 2
a205 2
        MOV     R4,#0                   
        Debug   table32K,"Calling ReadPalette",R0,R1,R2,R3,R4 
d207 1
a207 1
        BVS     exit_32k                
d211 1
a211 1
        
d213 1
a213 1
24                        
d276 1
a276 1
                                            
d301 1
a301 1
        TEQ     R5,R8                                      
d307 2
a308 2
        Debug   table32K,"we found it (need to load table)!!!!!"    
         
d313 3
a315 3
        
        SUB     R8, R6, #8                  ;now R8->start of record 
        
d318 1
a318 1
        
d321 2
a322 2
 
        LDR     WP,[R13,#48] 
d341 45
a385 1
        
d387 2
a388 2
        
        SWI     XMessageTrans_FileInfo 
d393 2
a394 1
                                                          
a395 1
        ;R1 still filename from above
d399 1
a399 1
        
d403 1
a403 1
        ADD     R6, R6, #4   
d405 1
d408 4
a411 2
        
85      ;file needs expanding - build a full record for it  
d415 1
a415 1
        
d417 2
a418 2
        
                                            ;next thing is to build a full 
d427 1
a427 1
        SWI     XOS_Module   
d429 1
a429 1
                                            ;link it in to the table chain (at the 
d435 1
a435 1
        STR     R2,[R3,#anchor_tables]      ;replace it with this one                     
d445 1
a445 1
                                            ;of the palette data. 
d447 7
d455 1
d457 1
a457 1
        LDR     R7,[R2]                     ;and the last word of the palette table
d468 1
d470 1
a470 1
        Debug   table32K,"Successfully loaded file"    
d475 1
a475 1
                                            ;next thing is to build a full 
d483 1
a483 1
        SWI     XOS_Module   
d485 1
a485 1
                                            ;link it in to the table chain (at the 
d491 1
a491 1
        STR     R2,[R3,#anchor_tables]      ;replace it with this one                     
d501 1
a501 1
                                            ;of the palette data. 
d505 2
a506 2
         
        [ {TRUE}         
d523 8
d545 2
a546 1
        | 
d556 1
a556 1
        Debug   table32K,"Successfully loaded file"    
d558 1
a558 1
        MOV     R0,#ModHandReason_Free       ;we don't need colourarray anymore, so 
d560 2
a561 2
        SWI     XOS_Module  
                          
d569 1
a569 1
        
d573 1
a573 1
        |                         
d584 1
a584 1
80  
d586 1
a586 1
             
d590 1
a590 1
        
d615 1
a615 1
        MOV     guardarray,R2        
d620 1
a620 1
         
d639 2
a640 2
                 
        [ med_03007            
d643 1
a643 1
        
d651 1
a651 1
          
d659 1
a659 1
        BNE     %BT84      
d665 1
a665 1
25                  
d667 1
a667 1
        
d681 1
a681 1
                                           
d683 1
a683 1
        STRB    thiscolour,[colourarray,tableoffset]       
d687 1
a687 1
                                            
d689 1
a689 1
        MOV     loopred,#0                   ; loop red  
d694 1
a694 1
            
d702 2
a703 2
        SUBCC   R1,loopblue,R3               
        CMP     R1,R2  
d705 1
a705 1
        
d712 1
a712 1
        
d718 2
a719 2
        BCS     %FT36    
              
d723 1
a723 1
        
d726 1
a726 1
        
d732 1
a732 1
36                       
d736 1
a736 1
                
d740 1
a740 1
                
d743 2
a744 2
        BNE     %BT35    
                
d746 1
a746 1
        CMP     thiscolour,R11       
d749 1
a749 1
                
d769 2
a770 2
        ]                                     
        ]       
d772 1
a772 1
found_a_table          
d776 1
a776 1
        SWI     XOS_Module  
d783 1
a783 1
        SWI     XOS_Module    
d785 1
a785 1
                          
d793 1
a793 1
exit_32k           
d795 1
a795 1
                                
d812 1
a812 1
             
a819 1
        ]          
d821 3
a823 2
        
        [ debugtable32K                     
d827 1
a827 1
                        
d832 109
a940 1
        ALIGN   
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

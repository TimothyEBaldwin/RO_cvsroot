head	4.4;
access;
symbols
	DrawFile-1_59:4.4
	DrawFile-1_58:4.4
	DrawFile-1_57:4.3
	DrawFile-1_56:4.3
	DrawFile-1_55:4.3
	DrawFile-1_54:4.3
	DrawFile-1_53:4.3
	RO_5_07:4.3
	DrawFile-1_52:4.3
	DrawFile-1_51:4.2
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	DrawFile-1_50:4.2
	dcotton_autobuild_BaseSW:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	DrawFile-1_49:4.2
	nicke_DrawFile-1_48:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	hsimons_BOCA-1_2-Release:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.2
	ARTtmp:4.1.7.2.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2013.07.22.19.54.10;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	umvA53VChGhzgvYw;

4.3
date	2002.11.22.21.41.26;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.49.27;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.42.41;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.05.19.16.01.06;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.42.41;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.11.15;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.49.21;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.12.21;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.11.15.30.08;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Add support for background blended text and text areas
Files saved by !Draw 1.24 or later can opt to have transparent background colour to me use the blending font manager. This is the corresponding change to the renderer.
Ordinary text will not be plotted if the *foreground* colour is transparent - this seems to have been a discrepancy between !Draw and DrawFile, DrawFile used to render it in the background colour instead, imagining that this was like a shadow. The spirit of the draw file spec is that the background colour is an optional hint, however.
The state flags that end up on Service_DrawObjectRender no longer contain the DrawFile modules internal flags, only those documented.

Version 1.58. Tagged as 'DrawFile-1_58'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*main.c - entry points for DrawFile module */

/*From CLib */
#include <kernel.h>
#include <locale.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*From OSLib */
#include "messagetrans.h"
#include "macros.h"
#include "os.h"
#include "osfile.h"
#include "osmodule.h"
#include "resourcefs.h"

/*From Support */
#include "m.h"
#include "riscos.h"
#include "jc_trace.h"

/*Local */
#include "bbox.h"
#include "declare.h"
#include "main.h"
#include "files.h"
#include "render.h"
#include "verify.h"

typedef struct
{
  int object_type;
  callback_fn *fn;
}
Association;

static messagetrans_control_block Control_Block;

static char *Message_Data;

static Association Verification_Table[] =
{
  {drawfile_TYPE_FONT_TABLE, &verify_font_table},
  {drawfile_TYPE_GROUP, &verify_group},
  {drawfile_TYPE_TEXT, &verify_text},
  {drawfile_TYPE_TAGGED, &verify_tagged},
  {drawfile_TYPE_TRFM_TEXT, &verify_trfm_text}
};

static Association Rendering_Table[] =
{
  {drawfile_TYPE_FONT_TABLE, &render_font_table},
  {drawfile_TYPE_TEXT, &render_text},
  {drawfile_TYPE_TEXT, &render_text_system},
  {drawfile_TYPE_PATH, &render_path},
  {drawfile_TYPE_SPRITE, &render_sprite},
  {drawfile_TYPE_GROUP, &render_group},
  {drawfile_TYPE_TAGGED, &render_tagged},
  {drawfile_TYPE_TEXT_AREA, &render_text_area},
  {drawfile_TYPE_TRFM_TEXT, &render_trfm_text},
  {drawfile_TYPE_TRFM_TEXT, &render_trfm_text_system},
  {drawfile_TYPE_TRFM_SPRITE, &render_trfm_sprite},
  {drawfile_TYPE_JPEG, &render_jpeg}
};

static Association Declaration_Table[] =
{
  {drawfile_TYPE_FONT_TABLE, &declare_font_table},
  {drawfile_TYPE_GROUP, &declare_group},
  {drawfile_TYPE_TAGGED, &declare_tagged},
  {drawfile_TYPE_TEXT_AREA, &declare_text_area}
};

static os_trfm Identity =
{
  {
    {0x10000, 0},
    {0, 0x10000},
    {0, 0}}};

callback_l main_verification_callback = NULL, main_render_callback = NULL, main_declaration_callback = NULL;

/*------------------------------------------------------------------------*/
static os_error *Create_List(Association table[], int count,
                             callback_l * l_out)

{
  os_error *error = NULL;
  int i;
  callback_l l;
  osbool done_new = FALSE;

  tracef("main_initialise: creating callback list\n");
  if ((error = callback_new(&l)) != NULL)
    goto finish;
  done_new = TRUE;

  for (i = 0; i < count; i++)
    if ((error = callback_register(l, table[i].fn, NULL, 1,
                                   table[i].object_type)) != NULL)
      goto finish;

  if (l_out != NULL)
    *l_out = l;

finish:
  if (error != NULL)
  {
    if (done_new)
      (void) callback_delete(l);
  }

  return error;
}
/*------------------------------------------------------------------------*/
_kernel_oserror *main_initialise(char *tail, int podule_base,
                                 void *workspace)

{
  os_error *error = NULL;
  int size;
  osbool done_open_file = FALSE;
#ifdef STANDALONE
  osbool done_register_files = FALSE;
#endif
  bits flags;
  char *message_file_name;

  trace_initialise("DrawFile$Trace");

  tracef("main_initialise\n");
  tail = tail, podule_base = podule_base, workspace = workspace;

  if ((error = riscos_territory(territory_CURRENT)) != NULL)
    goto finish;

#ifdef STANDALONE
/* Register files. */
  tracef("main_initialise: registering messages from data at 0x%X\n" _
         files_messages());
  if ((error = xresourcefs_register_files(files_messages())) != NULL)
    goto finish;
  done_register_files = TRUE;
#endif

  tracef("main_initialise: looking up DrawFile$Path\n");
  message_file_name = getenv("DrawFile$Path") == NULL ?
      "Resources:Resources.DrawFile.Messages" : "DrawFile:Messages";

  if ((error = xmessagetrans_file_info(message_file_name, &flags, &size))
      != NULL)
    goto finish;

  if ((flags & messagetrans_DIRECT_ACCESS) != 0)
    Message_Data = NULL;
  else
  {
    if ((Message_Data = m_ALLOC(size)) == NULL)
    {
      error = main_error_lookup(1, "NoMem");
      goto finish;
    }
  }

  if ((error = xmessagetrans_open_file(&Control_Block, message_file_name,
                                       Message_Data)) != NULL)
    goto finish;
  done_open_file = TRUE;

/* Make the verification callback list. */
  tracef("main_initialise: creating verification callback list\n");
  if ((error = Create_List(Verification_Table,
           COUNT(Verification_Table), &main_verification_callback)) != NULL ||
      (error = Create_List(Rendering_Table,
                    COUNT(Rendering_Table), &main_render_callback)) != NULL ||
      (error = Create_List(Declaration_Table,
               COUNT(Declaration_Table), &main_declaration_callback)) != NULL)
    goto finish;

finish:
  if (error != NULL)
  {
    callback_delete(main_declaration_callback);
    callback_delete(main_render_callback);
    callback_delete(main_verification_callback);

    if (done_open_file)
    {
      os_error *error1 = xmessagetrans_close_file(&Control_Block);
      if (error == NULL)
        error = error1;
    }

    m_FREE(Message_Data, size);

       #ifdef STANDALONE
    if (done_register_files)
    {
      os_error *error1 = xresourcefs_deregister_files
      ((resourcefs_file_list *) files_messages());
      if (error == NULL)
        error = error1;
    }
       #endif
  }

  return (_kernel_oserror *) error;
}
/*------------------------------------------------------------------------*/
_kernel_oserror *main_terminate(int fatal, int instance, void *workspace)

{
  fatal = fatal, instance = instance, workspace = workspace;

  tracef("main_terminate\n");
  callback_delete(main_declaration_callback);
  callback_delete(main_render_callback);
  callback_delete(main_verification_callback);
  (void) xmessagetrans_close_file(&Control_Block);
  m_FREE(Message_Data, 0);
#ifdef STANDALONE
  (void) xresourcefs_deregister_files(files_messages());
#endif
  trace_terminate();

  return NULL;
}
/*------------------------------------------------------------------------*/
_kernel_oserror *main_swi(int swi, _kernel_swi_regs * regs, void *workspace)

{
  os_error *error = NULL;
  
  tracef("main_swi\n");
  workspace = workspace;

  if ((error = verify_diagram((drawfile_diagram *) regs->r[1],
                              regs->r[2])) != NULL)
    goto finish;

  switch (swi)
  {
  case DrawFile_Render & 0x1F:
    tracef("main_swi: despatching Render\n");
    if ((error = render((bits) regs->r[0],
                        (drawfile_diagram *) regs->r[1], regs->r[2],
                        regs->r[3] != 0 ? (os_trfm *) regs->r[3] : &Identity,
                        (os_box *) regs->r[4], regs->r[5])) != NULL)
      goto finish;
    break;

  case DrawFile_BBox & 0x1F:
    tracef("main_swi: despatching BBox\n");
    if ((error = bbox((bits) regs->r[0],
                      (drawfile_diagram *) regs->r[1], regs->r[2],
                      regs->r[3] != 0 ? (os_trfm *) regs->r[3] : &Identity,
                      (os_box *) regs->r[4])) != NULL)
      goto finish;
    break;

  case DrawFile_DeclareFonts & 0x1F:
    tracef("main_swi: despatching DeclareFonts\n");
    if ((error = declare((bits) regs->r[0],
                         (drawfile_diagram *) regs->r[1], regs->r[2])) != NULL)
      goto finish;
    break;

  default:
    error = main_error_lookup(0x1E8, "BadSwi", "DrawFile");
    goto finish;
    break;
  }

finish:
  return (_kernel_oserror *) error;
}
/*------------------------------------------------------------------------*/
_kernel_oserror *main_service(int service, _kernel_swi_regs * regs,
                              void *workspace)
{
  osbool unclaimed = TRUE;
  os_error *error = NULL;

  workspace = workspace;

  switch (service)
  {
  case Service_ResourceFSStarting:
#ifdef STANDALONE
    tracef("main_service: servicing ResourceFSStarting\n");
    (*(void (*)(resourcefs_file_list *, int, int, int)) regs->r[2])
        (files_messages(), regs->r[1], regs->r[2],
         regs->r[3]);
#endif
    break;

  case DrawFile_Render:
    switch (regs->r[0])
    {
    case drawfile_TYPE_FONT_TABLE:
      render_font_table(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_TEXT:
      render_text(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_PATH:
      render_path(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_SPRITE:
      render_sprite(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_GROUP:
      render_group(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_TAGGED:
      render_tagged(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_TEXT_AREA:
      render_text_area(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_TRFM_TEXT:
      render_trfm_text(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_TRFM_SPRITE:
      render_trfm_sprite(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_JPEG:
      render_jpeg(NULL, (void *) regs->r[2], &unclaimed);
      break;
    }
    if (!unclaimed)
      regs->r[1] = 0;
    break;

  default:
    error = main_error_lookup(0x1E8, "BadService", "DrawFile");
    break;
  }

  return((_kernel_oserror *) error);
}
/*------------------------------------------------------------------------*/
_kernel_oserror *main_command(char *tail, int argc, int cmd_no,
                              void *workspace)
{
  os_error *error = NULL;
  
  tracef("main_command\n");

  switch (cmd_no)
  {
  case main_COMMAND_RENDER:
    {                                  /* Render */
      os_trfm m;
      struct
      {
        char *file, *m[3][2];
        osbool bbox, suppress;
        char *flatness;
        char argd[1024];
      }
      argl;
      int obj_type, size, flatness, i, j;
      drawfile_diagram *diagram = NULL;

      static int Scale[3][2] =
      {
        {1 << 16, 1 << 16},
        {1 << 16, 1 << 16},
        {draw_OS_UNIT, draw_OS_UNIT}};

      NOT_USED(argc)
          NOT_USED(workspace)

          tracef("tail \"%.*s\"\n" _ riscos_strlen(tail) _ tail);

      if ((error = xos_read_args("file/a,m00,m01,m10,m11,m20,m21,"
                                 "bbox/s,suppress/s,flatness/k", tail,
                                 (char *) &argl, sizeof argl, NULL)) != NULL)
        goto rendered;

      tracef("decoding is:\nfile \"%s\"\nm %s %s %s %s %s %s\n"
             "bbox %s\nsuppress %s\nflatness %s\n" _
             argl.file _ argl.m[0][0] != NULL ? argl.m[0][0] : "NULL" _
             argl.m[0][1] != NULL ? argl.m[0][1] : "NULL" _
             argl.m[1][0] != NULL ? argl.m[1][0] : "NULL" _
             argl.m[1][1] != NULL ? argl.m[1][1] : "NULL" _
             argl.m[2][0] != NULL ? argl.m[2][0] : "NULL" _
             argl.m[2][1] != NULL ? argl.m[2][1] : "NULL" _
             WHETHER(argl.bbox) _ WHETHER(argl.suppress) _
             argl.flatness != NULL ? argl.flatness : "NULL");

      if ((error = xosfile_read_no_path(argl.file, &obj_type, NULL, NULL,
                                        &size, NULL)) != NULL)
        goto rendered;
      if (obj_type != osfile_IS_FILE)
      {
        error = xosfile_make_error(argl.file, obj_type);
        goto rendered;
      }

/* Decode the matrix. */
      for (j = 0; j < 2; j++)
        for (i = 0; i < 3; i++)
          if (argl.m[i][j] == NULL || riscos_scan_fixed
              (argl.m[i][j], &m.entries[i][j], Scale[i][j]) ==
              0)
            m.entries[i][j] = Identity.entries[i][j];

      tracef("matrix ((0x%X 0x%X) (0x%X 0x%X) (%d %d))\n" _
             m.entries[0][0] _ m.entries[0][1] _
             m.entries[1][0] _ m.entries[1][1] _
             m.entries[2][0] _ m.entries[2][1]);

      if (argl.flatness == NULL ||
          riscos_scan_fixed(argl.flatness, &flatness, 256) == 0)
        flatness = -1;

      tracef("flatness %d\n" _ flatness);

      if ((diagram = m_ALLOC(size)) == NULL)
      {
        error = main_error_lookup(os_GLOBAL_NO_MEM, "NoMem");
        goto rendered;
      }

      if ((error = xosfile_load_stamped_no_path(argl.file,
                     (byte *) diagram, NULL, NULL, NULL, NULL, NULL)) != NULL)
        goto rendered;

      if ((error = verify_diagram(diagram, size)) != NULL)
        goto rendered;

      if ((error = render((argl.bbox ? drawfile_RENDER_BBOXES : NONE) |
                          (argl.suppress ? drawfile_RENDER_SUPPRESS : NONE) |
                     (flatness != -1 ? drawfile_RENDER_GIVEN_FLATNESS : NONE),
                          diagram, size, &m, NULL, flatness)) != NULL)
        goto rendered;

    rendered:
      m_FREE(diagram, size);
    }
    break;
  }

  return (_kernel_oserror *) error;
}
/*------------------------------------------------------------------------*/
os_error *main_error_lookup(int no, char *token,...)

{
  va_list list;
  char *p[4];
  int i;
  os_error error;

  tracef("main_error_lookup\n");

/* Assume that 4 args are always given. */
  va_start(list, token);
  for (i = 0; i < 4; i++)
    p[i] = va_arg(list, char *);
  va_end(list);

  error.errnum = no;
  strcpy(error.errmess, token);

  return xmessagetrans_error_lookup(&error, &Control_Block,
                                    NULL, 0, p[0], p[1], p[2], p[3]);
}
@


4.3
log
@Made to work with C99

Version 1.52. Tagged as 'DrawFile-1_52'
@
text
@a98 7
#ifdef USE_ATEXIT
/*------------------------------------------------------------------------*/
static void Exit(void)
{
  (void) main_terminate(SKIP, SKIP, SKIP);
}
#endif
a195 4
#ifdef USE_ATEXIT
  atexit(&Exit);
#endif

d249 1
a249 1

d372 1
a372 1

@


4.2
log
@Version Spin_merge taken
@
text
@d114 1
a114 1
  bool done_new = FALSE;
d145 1
a145 1
  bool done_open_file = FALSE;
d147 1
a147 1
  bool done_register_files = FALSE;
d308 1
a308 1
  bool unclaimed = TRUE;
d394 1
a394 1
        bool bbox, suppress;
@


4.2.2.1
log
@Modified to open "Resources:$...." not "Resources:..."
@
text
@d171 1
a171 1
      "Resources:$.Resources.DrawFile.Messages" : "DrawFile:Messages";
@


4.1
log
@Initial revision
@
text
@d15 1
a15 1
/*main.c - entry points for DrawFile module*/
d17 1
a17 1
/*From CLib*/
d25 1
a25 1
/*From OSLib*/
d33 1
a33 1
/*From Support*/
d36 1
a36 1
#include "trace.h"
d38 1
a38 1
/*Local*/
d46 6
a51 1
typedef struct {int object_type; callback_fn *fn;} Association;
d57 39
a95 31
static Association Verification_Table [] =
   {  {drawfile_TYPE_FONT_TABLE,  &verify_font_table},
      {drawfile_TYPE_GROUP,       &verify_group},
      {drawfile_TYPE_TEXT,        &verify_text},
      {drawfile_TYPE_TAGGED,      &verify_tagged},
      {drawfile_TYPE_TRFM_TEXT,   &verify_trfm_text}
   };

static Association Rendering_Table [] =
   {  {drawfile_TYPE_FONT_TABLE,  &render_font_table},
      {drawfile_TYPE_TEXT,        &render_text},
      {drawfile_TYPE_TEXT,        &render_text_system},
      {drawfile_TYPE_PATH,        &render_path},
      {drawfile_TYPE_SPRITE,      &render_sprite},
      {drawfile_TYPE_GROUP,       &render_group},
      {drawfile_TYPE_TAGGED,      &render_tagged},
      {drawfile_TYPE_TEXT_AREA,   &render_text_area},
      {drawfile_TYPE_TRFM_TEXT,   &render_trfm_text},
      {drawfile_TYPE_TRFM_TEXT,   &render_trfm_text_system},
      {drawfile_TYPE_TRFM_SPRITE, &render_trfm_sprite},
      {drawfile_TYPE_JPEG,        &render_jpeg}
   };

static Association Declaration_Table [] =
   {  {drawfile_TYPE_FONT_TABLE,  &declare_font_table},
      {drawfile_TYPE_GROUP,       &declare_group},
      {drawfile_TYPE_TAGGED,      &declare_tagged},
      {drawfile_TYPE_TEXT_AREA,   &declare_text_area}
   };

static os_trfm Identity = {{{0x10000, 0}, {0, 0x10000}, {0, 0}}};
d97 1
a97 2
callback_l main_verification_callback = NULL, main_render_callback = NULL,
      main_declaration_callback = NULL;
d101 4
a104 2
static void Exit (void)
      {(void) main_terminate (SKIP, SKIP, SKIP);}
d107 2
a108 2
static os_error *Create_List (Association table [], int count,
      callback_l *l_out)
d110 14
a123 7
{  os_error *error = NULL;
   int i;
   callback_l l;
   bool done_new = FALSE;

   tracef ("main_initialise: creating callback list\n");
   if ((error = callback_new (&l)) != NULL)
a124 6
   done_new = TRUE;

   for (i = 0; i < count; i++)
      if ((error = callback_register (l, table [i].fn, NULL, 1,
            table [i].object_type)) != NULL)
         goto finish;
d126 2
a127 1
   if (l_out != NULL) *l_out = l;
d130 5
a134 4
   if (error != NULL)
   {  if (done_new)
         (void) callback_delete (l);
   }
d136 1
a136 1
   return error;
d139 2
a140 2
_kernel_oserror *main_initialise (char *tail, int podule_base,
      void *workspace)
d142 4
a145 3
{  os_error *error = NULL;
   int size;
   bool done_open_file = FALSE;
d147 1
a147 1
   bool done_register_files = FALSE;
d149 2
a150 2
   bits flags;
   char *message_file_name;
d152 1
a152 1
   trace_initialise ("DrawFile$Trace");
d154 2
a155 2
   tracef ("main_initialise\n");
   tail = tail, podule_base = podule_base, workspace = workspace;
d157 2
a158 2
   if ((error = riscos_territory (territory_CURRENT)) != NULL)
      goto finish;
d161 6
a166 6
   /*Register files.*/
   tracef ("main_initialise: registering messages from data at 0x%X\n" _
         files_messages ());
   if ((error = xresourcefs_register_files (files_messages ())) != NULL)
      goto finish;
   done_register_files = TRUE;
d169 15
a183 18
   tracef ("main_initialise: looking up DrawFile$Path\n");
   message_file_name = getenv ("DrawFile$Path") == NULL?
         "Resources:Resources.DrawFile.Messages": "DrawFile:Messages";

   if ((error = xmessagetrans_file_info (message_file_name, &flags, &size))
         != NULL)
      goto finish;

   if ((flags & messagetrans_DIRECT_ACCESS) != 0)
      Message_Data = NULL;
   else
   {  if ((Message_Data = m_ALLOC (size)) == NULL)
      {  error = main_error_lookup (1, "NoMem");
         goto finish;
   }  }

   if ((error = xmessagetrans_open_file (&Control_Block, message_file_name,
         Message_Data)) != NULL)
d185 2
a186 1
   done_open_file = TRUE;
d188 14
a201 9
   /*Make the verification callback list.*/
   tracef ("main_initialise: creating verification callback list\n");
   if ((error = Create_List (Verification_Table,
         COUNT (Verification_Table), &main_verification_callback)) != NULL ||
      (error = Create_List (Rendering_Table,
         COUNT (Rendering_Table), &main_render_callback)) != NULL ||
      (error = Create_List (Declaration_Table,
         COUNT (Declaration_Table), &main_declaration_callback)) != NULL)
      goto finish;
d204 1
a204 1
   atexit (&Exit);
d208 25
a232 20
   if (error != NULL)
   {  callback_delete (main_declaration_callback);
      callback_delete (main_render_callback);
      callback_delete (main_verification_callback);

      if (done_open_file)
      {  os_error *error1 = xmessagetrans_close_file (&Control_Block);
         if (error == NULL) error = error1;
      }

      m_FREE (Message_Data, size);

   #ifdef STANDALONE
      if (done_register_files)
      {  os_error *error1 = xresourcefs_deregister_files
               ((resourcefs_file_list *) files_messages ());
         if (error == NULL) error = error1;
      }
   #endif
   }
d234 1
a234 1
   return (_kernel_oserror *) error;
d237 1
a237 1
_kernel_oserror *main_terminate (int fatal, int instance, void *workspace)
d239 2
a240 1
{  fatal = fatal, instance = instance, workspace = workspace; /**/
d242 6
a247 6
   tracef ("main_terminate\n");
   callback_delete (main_declaration_callback);
   callback_delete (main_render_callback);
   callback_delete (main_verification_callback);
   (void) xmessagetrans_close_file (&Control_Block);
   m_FREE (Message_Data, 0);
d249 1
a249 1
   (void) xresourcefs_deregister_files (files_messages ());
d251 1
a251 1
   trace_terminate ();
d253 1
a253 1
   return NULL;
d256 7
a262 1
_kernel_oserror *main_swi (int swi, _kernel_swi_regs *regs, void *workspace)
d264 14
a277 1
{  os_error *error = NULL;
d279 8
a286 2
   tracef ("main_swi\n");
   workspace = workspace;
d288 4
a291 2
   if ((error = verify_diagram ((drawfile_diagram *) regs->r [1],
         regs->r [2])) != NULL)
d293 7
d301 28
a328 8
   switch (swi)
   {  case DrawFile_Render & 0x1F:
         tracef ("main_swi: despatching Render\n");
         if ((error = render ((bits) regs->r [0],
               (drawfile_diagram *) regs->r [1], regs->r [2],
               regs->r [3] != 0? (os_trfm *) regs->r [3]: &Identity,
               (os_box *) regs->r [4], regs->r [5])) != NULL)
            goto finish;
d331 2
a332 7
      case DrawFile_BBox & 0x1F:
         tracef ("main_swi: despatching BBox\n");
         if ((error = bbox ((bits) regs->r [0],
               (drawfile_diagram *) regs->r [1], regs->r [2],
               regs->r [3] != 0? (os_trfm *) regs->r [3]: &Identity,
               (os_box *) regs->r [4])) != NULL)
            goto finish;
d335 2
a336 5
      case DrawFile_DeclareFonts & 0x1F:
         tracef ("main_swi: despatching DeclareFonts\n");
         if ((error = declare ((bits) regs->r [0],
               (drawfile_diagram *) regs->r [1], regs->r [2])) != NULL)
            goto finish;
d339 2
a340 3
      default:
         error = main_error_lookup (0x1E8, "BadSwi", "DrawFile");
         goto finish;
a341 1
   }
d343 3
a345 6
finish:
   return (_kernel_oserror *) error;
}
/*------------------------------------------------------------------------*/
_kernel_oserror *main_service (int service, _kernel_swi_regs *regs,
      void *workspace)
d347 3
a349 1
{  workspace = workspace;
d351 2
a352 8
   switch (service)
   {  case Service_ResourceFSStarting:
#ifdef STANDALONE
         tracef ("main_service: servicing ResourceFSStarting\n");
         (*(void (*) (resourcefs_file_list *, int, int, int)) regs->r [2])
               (files_messages (), regs->r [1], regs->r [2],
               regs->r [3]);
#endif
a353 1
   }
d355 3
a357 5
   return NULL;
}
/*------------------------------------------------------------------------*/
_kernel_oserror *main_command (char *tail, int argc, int cmd_no,
      void *workspace)
d359 3
a361 1
{  os_error *error = NULL;
d363 12
a374 1
   tracef ("main_command\n");
d376 61
a436 77
   switch (cmd_no)
   {  case main_COMMAND_RENDER:
      {  /*Render*/
         os_trfm m;
         struct {char *file, *m [3] [2]; bool bbox, suppress; char *flatness;
               char argd [1024];} argl;
         int obj_type, size, flatness, i, j;
         drawfile_diagram *diagram = NULL;

         static int Scale [3] [2] = {{1 << 16, 1 << 16}, {1 << 16, 1 << 16},
               {draw_OS_UNIT, draw_OS_UNIT}};

         NOT_USED (argc)
         NOT_USED (workspace)

         tracef ("tail \"%.*s\"\n" _ riscos_strlen (tail) _ tail);

         if ((error = xos_read_args ("file/a,m00,m01,m10,m11,m20,m21,"
               "bbox/s,suppress/s,flatness/k", tail,
               (char *) &argl, sizeof argl, NULL)) != NULL)
            goto rendered;

         tracef ("decoding is:\nfile \"%s\"\nm %s %s %s %s %s %s\n"
               "bbox %s\nsuppress %s\nflatness %s\n" _
               argl.file _ argl.m [0] [0] != NULL? argl.m [0] [0]: "NULL" _
               argl.m [0] [1] != NULL? argl.m [0] [1]: "NULL" _
               argl.m [1] [0] != NULL? argl.m [1] [0]: "NULL" _
               argl.m [1] [1] != NULL? argl.m [1] [1]: "NULL" _
               argl.m [2] [0] != NULL? argl.m [2] [0]: "NULL" _
               argl.m [2] [1] != NULL? argl.m [2] [1]: "NULL" _
               WHETHER (argl.bbox) _ WHETHER (argl.suppress) _
               argl.flatness != NULL? argl.flatness: "NULL");

         if ((error = xosfile_read_no_path (argl.file, &obj_type, NULL, NULL,
               &size, NULL)) != NULL)
            goto rendered;
         if (obj_type != osfile_IS_FILE)
         {  error = xosfile_make_error (argl.file, obj_type);
            goto rendered;
         }

         /*Decode the matrix.*/
         for (j = 0; j < 2; j++)
            for (i = 0; i < 3; i++)
               if (argl.m [i] [j] == NULL || riscos_scan_fixed
                     (argl.m [i] [j], &m.entries [i] [j], Scale [i] [j]) ==
                     0)
                  m.entries [i] [j] = Identity.entries [i] [j];

         tracef ("matrix ((0x%X 0x%X) (0x%X 0x%X) (%d %d))\n" _
               m.entries [0] [0] _ m.entries [0] [1] _
               m.entries [1] [0] _ m.entries [1] [1] _
               m.entries [2] [0] _ m.entries [2] [1]);

         if (argl.flatness == NULL ||
               riscos_scan_fixed (argl.flatness, &flatness, 256) == 0)
            flatness = -1;

         tracef ("flatness %d\n" _ flatness);

         if ((diagram = m_ALLOC (size)) == NULL)
         {  error = main_error_lookup (os_GLOBAL_NO_MEM, "NoMem");
            goto rendered;
         }

         if ((error = xosfile_load_stamped_no_path (argl.file,
               (byte *) diagram, NULL, NULL, NULL, NULL, NULL)) != NULL)
            goto rendered;

         if ((error = verify_diagram (diagram, size)) != NULL)
            goto rendered;

         if ((error = render ((argl.bbox? drawfile_RENDER_BBOXES: NONE) |
               (argl.suppress? drawfile_RENDER_SUPPRESS: NONE) |
               (flatness != -1? drawfile_RENDER_GIVEN_FLATNESS: NONE),
               diagram, size, &m, NULL, flatness)) != NULL)
            goto rendered;
d438 23
a460 2
      rendered:
         m_FREE (diagram, size);
a461 2
      break;
   }
d463 20
a482 1
   return (_kernel_oserror *) error;
d485 1
a485 8
os_error *main_error_lookup (int no, char *token, ...)

{  va_list list;
   char *p [4];
   int i;
   os_error error;

   tracef ("main_error_lookup\n");
d487 13
a499 4
   /*Assume that 4 args are always given.*/
   va_start (list, token);
   for (i = 0; i < 4; i++) p [i] = va_arg (list, char *);
   va_end (list);
d501 2
a502 2
   error.errnum = no;
   strcpy (error.errmess, token);
d504 2
a505 2
   return xmessagetrans_error_lookup (&error, &Control_Block,
         NULL, 0, p [0], p [1], p [2], p [3]);
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d15 1
a15 1
/*main.c - entry points for DrawFile module */
d17 1
a17 1
/*From CLib */
d25 1
a25 1
/*From OSLib */
d33 1
a33 1
/*From Support */
d38 1
a38 1
/*Local */
d46 1
a46 6
typedef struct
{
  int object_type;
  callback_fn *fn;
}
Association;
d52 31
a82 39
static Association Verification_Table[] =
{
  {drawfile_TYPE_FONT_TABLE, &verify_font_table},
  {drawfile_TYPE_GROUP, &verify_group},
  {drawfile_TYPE_TEXT, &verify_text},
  {drawfile_TYPE_TAGGED, &verify_tagged},
  {drawfile_TYPE_TRFM_TEXT, &verify_trfm_text}
};

static Association Rendering_Table[] =
{
  {drawfile_TYPE_FONT_TABLE, &render_font_table},
  {drawfile_TYPE_TEXT, &render_text},
  {drawfile_TYPE_TEXT, &render_text_system},
  {drawfile_TYPE_PATH, &render_path},
  {drawfile_TYPE_SPRITE, &render_sprite},
  {drawfile_TYPE_GROUP, &render_group},
  {drawfile_TYPE_TAGGED, &render_tagged},
  {drawfile_TYPE_TEXT_AREA, &render_text_area},
  {drawfile_TYPE_TRFM_TEXT, &render_trfm_text},
  {drawfile_TYPE_TRFM_TEXT, &render_trfm_text_system},
  {drawfile_TYPE_TRFM_SPRITE, &render_trfm_sprite},
  {drawfile_TYPE_JPEG, &render_jpeg}
};

static Association Declaration_Table[] =
{
  {drawfile_TYPE_FONT_TABLE, &declare_font_table},
  {drawfile_TYPE_GROUP, &declare_group},
  {drawfile_TYPE_TAGGED, &declare_tagged},
  {drawfile_TYPE_TEXT_AREA, &declare_text_area}
};

static os_trfm Identity =
{
  {
    {0x10000, 0},
    {0, 0x10000},
    {0, 0}}};
d84 2
a85 1
callback_l main_verification_callback = NULL, main_render_callback = NULL, main_declaration_callback = NULL;
d89 2
a90 4
static void Exit(void)
{
  (void) main_terminate(SKIP, SKIP, SKIP);
}
d93 2
a94 2
static os_error *Create_List(Association table[], int count,
                             callback_l * l_out)
d96 7
a102 14
{
  os_error *error = NULL;
  int i;
  callback_l l;
  bool done_new = FALSE;

  tracef("main_initialise: creating callback list\n");
  if ((error = callback_new(&l)) != NULL)
    goto finish;
  done_new = TRUE;

  for (i = 0; i < count; i++)
    if ((error = callback_register(l, table[i].fn, NULL, 1,
                                   table[i].object_type)) != NULL)
d104 6
d111 1
a111 2
  if (l_out != NULL)
    *l_out = l;
d114 4
a117 5
  if (error != NULL)
  {
    if (done_new)
      (void) callback_delete(l);
  }
d119 1
a119 1
  return error;
d122 2
a123 2
_kernel_oserror *main_initialise(char *tail, int podule_base,
                                 void *workspace)
d125 3
a127 4
{
  os_error *error = NULL;
  int size;
  bool done_open_file = FALSE;
d129 1
a129 1
  bool done_register_files = FALSE;
d131 2
a132 2
  bits flags;
  char *message_file_name;
d134 1
a134 1
  trace_initialise("DrawFile$Trace");
d136 2
a137 2
  tracef("main_initialise\n");
  tail = tail, podule_base = podule_base, workspace = workspace;
d139 2
a140 2
  if ((error = riscos_territory(territory_CURRENT)) != NULL)
    goto finish;
d143 6
a148 6
/* Register files. */
  tracef("main_initialise: registering messages from data at 0x%X\n" _
         files_messages());
  if ((error = xresourcefs_register_files(files_messages())) != NULL)
    goto finish;
  done_register_files = TRUE;
d151 18
a168 15
  tracef("main_initialise: looking up DrawFile$Path\n");
  message_file_name = getenv("DrawFile$Path") == NULL ?
      "Resources:Resources.DrawFile.Messages" : "DrawFile:Messages";

  if ((error = xmessagetrans_file_info(message_file_name, &flags, &size))
      != NULL)
    goto finish;

  if ((flags & messagetrans_DIRECT_ACCESS) != 0)
    Message_Data = NULL;
  else
  {
    if ((Message_Data = m_ALLOC(size)) == NULL)
    {
      error = main_error_lookup(1, "NoMem");
d170 1
a170 2
    }
  }
d172 9
a180 14
  if ((error = xmessagetrans_open_file(&Control_Block, message_file_name,
                                       Message_Data)) != NULL)
    goto finish;
  done_open_file = TRUE;

/* Make the verification callback list. */
  tracef("main_initialise: creating verification callback list\n");
  if ((error = Create_List(Verification_Table,
           COUNT(Verification_Table), &main_verification_callback)) != NULL ||
      (error = Create_List(Rendering_Table,
                    COUNT(Rendering_Table), &main_render_callback)) != NULL ||
      (error = Create_List(Declaration_Table,
               COUNT(Declaration_Table), &main_declaration_callback)) != NULL)
    goto finish;
d183 1
a183 1
  atexit(&Exit);
d187 20
a206 25
  if (error != NULL)
  {
    callback_delete(main_declaration_callback);
    callback_delete(main_render_callback);
    callback_delete(main_verification_callback);

    if (done_open_file)
    {
      os_error *error1 = xmessagetrans_close_file(&Control_Block);
      if (error == NULL)
        error = error1;
    }

    m_FREE(Message_Data, size);

       #ifdef STANDALONE
    if (done_register_files)
    {
      os_error *error1 = xresourcefs_deregister_files
      ((resourcefs_file_list *) files_messages());
      if (error == NULL)
        error = error1;
    }
       #endif
  }
d208 1
a208 1
  return (_kernel_oserror *) error;
d211 1
a211 1
_kernel_oserror *main_terminate(int fatal, int instance, void *workspace)
d213 1
a213 2
{
  fatal = fatal, instance = instance, workspace = workspace;
d215 6
a220 6
  tracef("main_terminate\n");
  callback_delete(main_declaration_callback);
  callback_delete(main_render_callback);
  callback_delete(main_verification_callback);
  (void) xmessagetrans_close_file(&Control_Block);
  m_FREE(Message_Data, 0);
d222 1
a222 1
  (void) xresourcefs_deregister_files(files_messages());
d224 1
a224 1
  trace_terminate();
d226 1
a226 1
  return NULL;
d229 1
a229 1
_kernel_oserror *main_swi(int swi, _kernel_swi_regs * regs, void *workspace)
d231 1
a231 2
{
  os_error *error = NULL;
d233 2
a234 2
  tracef("main_swi\n");
  workspace = workspace;
d236 2
a237 12
  if ((error = verify_diagram((drawfile_diagram *) regs->r[1],
                              regs->r[2])) != NULL)
    goto finish;

  switch (swi)
  {
  case DrawFile_Render & 0x1F:
    tracef("main_swi: despatching Render\n");
    if ((error = render((bits) regs->r[0],
                        (drawfile_diagram *) regs->r[1], regs->r[2],
                        regs->r[3] != 0 ? (os_trfm *) regs->r[3] : &Identity,
                        (os_box *) regs->r[4], regs->r[5])) != NULL)
a238 1
    break;
d240 18
a257 8
  case DrawFile_BBox & 0x1F:
    tracef("main_swi: despatching BBox\n");
    if ((error = bbox((bits) regs->r[0],
                      (drawfile_diagram *) regs->r[1], regs->r[2],
                      regs->r[3] != 0 ? (os_trfm *) regs->r[3] : &Identity,
                      (os_box *) regs->r[4])) != NULL)
      goto finish;
    break;
d259 6
a264 6
  case DrawFile_DeclareFonts & 0x1F:
    tracef("main_swi: despatching DeclareFonts\n");
    if ((error = declare((bits) regs->r[0],
                         (drawfile_diagram *) regs->r[1], regs->r[2])) != NULL)
      goto finish;
    break;
d266 5
a270 5
  default:
    error = main_error_lookup(0x1E8, "BadSwi", "DrawFile");
    goto finish;
    break;
  }
d273 1
a273 1
  return (_kernel_oserror *) error;
d276 7
a282 11
_kernel_oserror *main_service(int service, _kernel_swi_regs * regs,
                              void *workspace)
{
  bool unclaimed = TRUE;
  os_error *error = NULL;

  workspace = workspace;

  switch (service)
  {
  case Service_ResourceFSStarting:
d284 4
a287 4
    tracef("main_service: servicing ResourceFSStarting\n");
    (*(void (*)(resourcefs_file_list *, int, int, int)) regs->r[2])
        (files_messages(), regs->r[1], regs->r[2],
         regs->r[3]);
a288 7
    break;

  case DrawFile_Render:
    switch (regs->r[0])
    {
    case drawfile_TYPE_FONT_TABLE:
      render_font_table(NULL, (void *) regs->r[2], &unclaimed);
d290 1
d292 5
a296 7
    case drawfile_TYPE_TEXT:
      render_text(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_PATH:
      render_path(NULL, (void *) regs->r[2], &unclaimed);
      break;
d298 1
a298 3
    case drawfile_TYPE_SPRITE:
      render_sprite(NULL, (void *) regs->r[2], &unclaimed);
      break;
d300 1
a300 3
    case drawfile_TYPE_GROUP:
      render_group(NULL, (void *) regs->r[2], &unclaimed);
      break;
d302 77
a378 3
    case drawfile_TYPE_TAGGED:
      render_tagged(NULL, (void *) regs->r[2], &unclaimed);
      break;
d380 3
a382 2
    case drawfile_TYPE_TEXT_AREA:
      render_text_area(NULL, (void *) regs->r[2], &unclaimed);
d384 1
d386 1
a386 22
    case drawfile_TYPE_TRFM_TEXT:
      render_trfm_text(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_TRFM_SPRITE:
      render_trfm_sprite(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_JPEG:
      render_jpeg(NULL, (void *) regs->r[2], &unclaimed);
      break;
    }
    if (!unclaimed)
      regs->r[1] = 0;
    break;

  default:
    error = main_error_lookup(0x1E8, "BadService", "DrawFile");
    break;
  }

  return((_kernel_oserror *) error);
d389 1
a389 83
_kernel_oserror *main_command(char *tail, int argc, int cmd_no,
                              void *workspace)
{
  os_error *error = NULL;

  tracef("main_command\n");

  switch (cmd_no)
  {
  case main_COMMAND_RENDER:
    {                                  /* Render */
      os_trfm m;
      struct
      {
        char *file, *m[3][2];
        bool bbox, suppress;
        char *flatness;
        char argd[1024];
      }
      argl;
      int obj_type, size, flatness, i, j;
      drawfile_diagram *diagram = NULL;

      static int Scale[3][2] =
      {
        {1 << 16, 1 << 16},
        {1 << 16, 1 << 16},
        {draw_OS_UNIT, draw_OS_UNIT}};

      NOT_USED(argc)
          NOT_USED(workspace)

          tracef("tail \"%.*s\"\n" _ riscos_strlen(tail) _ tail);

      if ((error = xos_read_args("file/a,m00,m01,m10,m11,m20,m21,"
                                 "bbox/s,suppress/s,flatness/k", tail,
                                 (char *) &argl, sizeof argl, NULL)) != NULL)
        goto rendered;

      tracef("decoding is:\nfile \"%s\"\nm %s %s %s %s %s %s\n"
             "bbox %s\nsuppress %s\nflatness %s\n" _
             argl.file _ argl.m[0][0] != NULL ? argl.m[0][0] : "NULL" _
             argl.m[0][1] != NULL ? argl.m[0][1] : "NULL" _
             argl.m[1][0] != NULL ? argl.m[1][0] : "NULL" _
             argl.m[1][1] != NULL ? argl.m[1][1] : "NULL" _
             argl.m[2][0] != NULL ? argl.m[2][0] : "NULL" _
             argl.m[2][1] != NULL ? argl.m[2][1] : "NULL" _
             WHETHER(argl.bbox) _ WHETHER(argl.suppress) _
             argl.flatness != NULL ? argl.flatness : "NULL");

      if ((error = xosfile_read_no_path(argl.file, &obj_type, NULL, NULL,
                                        &size, NULL)) != NULL)
        goto rendered;
      if (obj_type != osfile_IS_FILE)
      {
        error = xosfile_make_error(argl.file, obj_type);
        goto rendered;
      }

/* Decode the matrix. */
      for (j = 0; j < 2; j++)
        for (i = 0; i < 3; i++)
          if (argl.m[i][j] == NULL || riscos_scan_fixed
              (argl.m[i][j], &m.entries[i][j], Scale[i][j]) ==
              0)
            m.entries[i][j] = Identity.entries[i][j];

      tracef("matrix ((0x%X 0x%X) (0x%X 0x%X) (%d %d))\n" _
             m.entries[0][0] _ m.entries[0][1] _
             m.entries[1][0] _ m.entries[1][1] _
             m.entries[2][0] _ m.entries[2][1]);

      if (argl.flatness == NULL ||
          riscos_scan_fixed(argl.flatness, &flatness, 256) == 0)
        flatness = -1;

      tracef("flatness %d\n" _ flatness);

      if ((diagram = m_ALLOC(size)) == NULL)
      {
        error = main_error_lookup(os_GLOBAL_NO_MEM, "NoMem");
        goto rendered;
      }
d391 4
a394 18
      if ((error = xosfile_load_stamped_no_path(argl.file,
                     (byte *) diagram, NULL, NULL, NULL, NULL, NULL)) != NULL)
        goto rendered;

      if ((error = verify_diagram(diagram, size)) != NULL)
        goto rendered;

      if ((error = render((argl.bbox ? drawfile_RENDER_BBOXES : NONE) |
                          (argl.suppress ? drawfile_RENDER_SUPPRESS : NONE) |
                     (flatness != -1 ? drawfile_RENDER_GIVEN_FLATNESS : NONE),
                          diagram, size, &m, NULL, flatness)) != NULL)
        goto rendered;

    rendered:
      m_FREE(diagram, size);
    }
    break;
  }
d396 1
a396 4
  return (_kernel_oserror *) error;
}
/*------------------------------------------------------------------------*/
os_error *main_error_lookup(int no, char *token,...)
d398 4
a401 13
{
  va_list list;
  char *p[4];
  int i;
  os_error error;

  tracef("main_error_lookup\n");

/* Assume that 4 args are always given. */
  va_start(list, token);
  for (i = 0; i < 4; i++)
    p[i] = va_arg(list, char *);
  va_end(list);
d403 2
a404 2
  error.errnum = no;
  strcpy(error.errmess, token);
d406 2
a407 2
  return xmessagetrans_error_lookup(&error, &Control_Block,
                                    NULL, 0, p[0], p[1], p[2], p[3]);
@


4.1.7.2
log
@Fixed name clash with trace.h:  New name jc_trace.h
@
text
@d36 1
a36 1
#include "jc_trace.h"
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d15 1
a15 1
/*main.c - entry points for DrawFile module */
d17 1
a17 1
/*From CLib */
d25 1
a25 1
/*From OSLib */
d33 1
a33 1
/*From Support */
d38 1
a38 1
/*Local */
d46 1
a46 6
typedef struct
{
  int object_type;
  callback_fn *fn;
}
Association;
d52 31
a82 39
static Association Verification_Table[] =
{
  {drawfile_TYPE_FONT_TABLE, &verify_font_table},
  {drawfile_TYPE_GROUP, &verify_group},
  {drawfile_TYPE_TEXT, &verify_text},
  {drawfile_TYPE_TAGGED, &verify_tagged},
  {drawfile_TYPE_TRFM_TEXT, &verify_trfm_text}
};

static Association Rendering_Table[] =
{
  {drawfile_TYPE_FONT_TABLE, &render_font_table},
  {drawfile_TYPE_TEXT, &render_text},
  {drawfile_TYPE_TEXT, &render_text_system},
  {drawfile_TYPE_PATH, &render_path},
  {drawfile_TYPE_SPRITE, &render_sprite},
  {drawfile_TYPE_GROUP, &render_group},
  {drawfile_TYPE_TAGGED, &render_tagged},
  {drawfile_TYPE_TEXT_AREA, &render_text_area},
  {drawfile_TYPE_TRFM_TEXT, &render_trfm_text},
  {drawfile_TYPE_TRFM_TEXT, &render_trfm_text_system},
  {drawfile_TYPE_TRFM_SPRITE, &render_trfm_sprite},
  {drawfile_TYPE_JPEG, &render_jpeg}
};

static Association Declaration_Table[] =
{
  {drawfile_TYPE_FONT_TABLE, &declare_font_table},
  {drawfile_TYPE_GROUP, &declare_group},
  {drawfile_TYPE_TAGGED, &declare_tagged},
  {drawfile_TYPE_TEXT_AREA, &declare_text_area}
};

static os_trfm Identity =
{
  {
    {0x10000, 0},
    {0, 0x10000},
    {0, 0}}};
d84 2
a85 1
callback_l main_verification_callback = NULL, main_render_callback = NULL, main_declaration_callback = NULL;
d89 2
a90 4
static void Exit(void)
{
  (void) main_terminate(SKIP, SKIP, SKIP);
}
d93 2
a94 2
static os_error *Create_List(Association table[], int count,
                             callback_l * l_out)
d96 7
a102 14
{
  os_error *error = NULL;
  int i;
  callback_l l;
  bool done_new = FALSE;

  tracef("main_initialise: creating callback list\n");
  if ((error = callback_new(&l)) != NULL)
    goto finish;
  done_new = TRUE;

  for (i = 0; i < count; i++)
    if ((error = callback_register(l, table[i].fn, NULL, 1,
                                   table[i].object_type)) != NULL)
d104 6
d111 1
a111 2
  if (l_out != NULL)
    *l_out = l;
d114 4
a117 5
  if (error != NULL)
  {
    if (done_new)
      (void) callback_delete(l);
  }
d119 1
a119 1
  return error;
d122 2
a123 2
_kernel_oserror *main_initialise(char *tail, int podule_base,
                                 void *workspace)
d125 3
a127 4
{
  os_error *error = NULL;
  int size;
  bool done_open_file = FALSE;
d129 1
a129 1
  bool done_register_files = FALSE;
d131 2
a132 2
  bits flags;
  char *message_file_name;
d134 1
a134 1
  trace_initialise("DrawFile$Trace");
d136 2
a137 2
  tracef("main_initialise\n");
  tail = tail, podule_base = podule_base, workspace = workspace;
d139 2
a140 2
  if ((error = riscos_territory(territory_CURRENT)) != NULL)
    goto finish;
d143 6
a148 6
/* Register files. */
  tracef("main_initialise: registering messages from data at 0x%X\n" _
         files_messages());
  if ((error = xresourcefs_register_files(files_messages())) != NULL)
    goto finish;
  done_register_files = TRUE;
d151 18
a168 15
  tracef("main_initialise: looking up DrawFile$Path\n");
  message_file_name = getenv("DrawFile$Path") == NULL ?
      "Resources:Resources.DrawFile.Messages" : "DrawFile:Messages";

  if ((error = xmessagetrans_file_info(message_file_name, &flags, &size))
      != NULL)
    goto finish;

  if ((flags & messagetrans_DIRECT_ACCESS) != 0)
    Message_Data = NULL;
  else
  {
    if ((Message_Data = m_ALLOC(size)) == NULL)
    {
      error = main_error_lookup(1, "NoMem");
d170 1
a170 2
    }
  }
d172 9
a180 14
  if ((error = xmessagetrans_open_file(&Control_Block, message_file_name,
                                       Message_Data)) != NULL)
    goto finish;
  done_open_file = TRUE;

/* Make the verification callback list. */
  tracef("main_initialise: creating verification callback list\n");
  if ((error = Create_List(Verification_Table,
           COUNT(Verification_Table), &main_verification_callback)) != NULL ||
      (error = Create_List(Rendering_Table,
                    COUNT(Rendering_Table), &main_render_callback)) != NULL ||
      (error = Create_List(Declaration_Table,
               COUNT(Declaration_Table), &main_declaration_callback)) != NULL)
    goto finish;
d183 1
a183 1
  atexit(&Exit);
d187 20
a206 25
  if (error != NULL)
  {
    callback_delete(main_declaration_callback);
    callback_delete(main_render_callback);
    callback_delete(main_verification_callback);

    if (done_open_file)
    {
      os_error *error1 = xmessagetrans_close_file(&Control_Block);
      if (error == NULL)
        error = error1;
    }

    m_FREE(Message_Data, size);

       #ifdef STANDALONE
    if (done_register_files)
    {
      os_error *error1 = xresourcefs_deregister_files
      ((resourcefs_file_list *) files_messages());
      if (error == NULL)
        error = error1;
    }
       #endif
  }
d208 1
a208 1
  return (_kernel_oserror *) error;
d211 1
a211 1
_kernel_oserror *main_terminate(int fatal, int instance, void *workspace)
d213 1
a213 2
{
  fatal = fatal, instance = instance, workspace = workspace;
d215 6
a220 6
  tracef("main_terminate\n");
  callback_delete(main_declaration_callback);
  callback_delete(main_render_callback);
  callback_delete(main_verification_callback);
  (void) xmessagetrans_close_file(&Control_Block);
  m_FREE(Message_Data, 0);
d222 1
a222 1
  (void) xresourcefs_deregister_files(files_messages());
d224 1
a224 1
  trace_terminate();
d226 1
a226 1
  return NULL;
d229 1
a229 1
_kernel_oserror *main_swi(int swi, _kernel_swi_regs * regs, void *workspace)
d231 1
a231 2
{
  os_error *error = NULL;
d233 2
a234 2
  tracef("main_swi\n");
  workspace = workspace;
d236 2
a237 12
  if ((error = verify_diagram((drawfile_diagram *) regs->r[1],
                              regs->r[2])) != NULL)
    goto finish;

  switch (swi)
  {
  case DrawFile_Render & 0x1F:
    tracef("main_swi: despatching Render\n");
    if ((error = render((bits) regs->r[0],
                        (drawfile_diagram *) regs->r[1], regs->r[2],
                        regs->r[3] != 0 ? (os_trfm *) regs->r[3] : &Identity,
                        (os_box *) regs->r[4], regs->r[5])) != NULL)
a238 1
    break;
d240 18
a257 8
  case DrawFile_BBox & 0x1F:
    tracef("main_swi: despatching BBox\n");
    if ((error = bbox((bits) regs->r[0],
                      (drawfile_diagram *) regs->r[1], regs->r[2],
                      regs->r[3] != 0 ? (os_trfm *) regs->r[3] : &Identity,
                      (os_box *) regs->r[4])) != NULL)
      goto finish;
    break;
d259 6
a264 6
  case DrawFile_DeclareFonts & 0x1F:
    tracef("main_swi: despatching DeclareFonts\n");
    if ((error = declare((bits) regs->r[0],
                         (drawfile_diagram *) regs->r[1], regs->r[2])) != NULL)
      goto finish;
    break;
d266 5
a270 5
  default:
    error = main_error_lookup(0x1E8, "BadSwi", "DrawFile");
    goto finish;
    break;
  }
d273 1
a273 1
  return (_kernel_oserror *) error;
d276 7
a282 11
_kernel_oserror *main_service(int service, _kernel_swi_regs * regs,
                              void *workspace)
{
  bool unclaimed = TRUE;
  os_error *error = NULL;

  workspace = workspace;

  switch (service)
  {
  case Service_ResourceFSStarting:
d284 4
a287 4
    tracef("main_service: servicing ResourceFSStarting\n");
    (*(void (*)(resourcefs_file_list *, int, int, int)) regs->r[2])
        (files_messages(), regs->r[1], regs->r[2],
         regs->r[3]);
a288 7
    break;

  case DrawFile_Render:
    switch (regs->r[0])
    {
    case drawfile_TYPE_FONT_TABLE:
      render_font_table(NULL, (void *) regs->r[2], &unclaimed);
d290 1
d292 5
a296 7
    case drawfile_TYPE_TEXT:
      render_text(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_PATH:
      render_path(NULL, (void *) regs->r[2], &unclaimed);
      break;
d298 1
a298 3
    case drawfile_TYPE_SPRITE:
      render_sprite(NULL, (void *) regs->r[2], &unclaimed);
      break;
d300 1
a300 3
    case drawfile_TYPE_GROUP:
      render_group(NULL, (void *) regs->r[2], &unclaimed);
      break;
d302 77
a378 3
    case drawfile_TYPE_TAGGED:
      render_tagged(NULL, (void *) regs->r[2], &unclaimed);
      break;
d380 3
a382 2
    case drawfile_TYPE_TEXT_AREA:
      render_text_area(NULL, (void *) regs->r[2], &unclaimed);
d384 1
d386 1
a386 22
    case drawfile_TYPE_TRFM_TEXT:
      render_trfm_text(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_TRFM_SPRITE:
      render_trfm_sprite(NULL, (void *) regs->r[2], &unclaimed);
      break;

    case drawfile_TYPE_JPEG:
      render_jpeg(NULL, (void *) regs->r[2], &unclaimed);
      break;
    }
    if (!unclaimed)
      regs->r[1] = 0;
    break;

  default:
    error = main_error_lookup(0x1E8, "BadService", "DrawFile");
    break;
  }

  return((_kernel_oserror *) error);
d389 1
a389 83
_kernel_oserror *main_command(char *tail, int argc, int cmd_no,
                              void *workspace)
{
  os_error *error = NULL;

  tracef("main_command\n");

  switch (cmd_no)
  {
  case main_COMMAND_RENDER:
    {                                  /* Render */
      os_trfm m;
      struct
      {
        char *file, *m[3][2];
        bool bbox, suppress;
        char *flatness;
        char argd[1024];
      }
      argl;
      int obj_type, size, flatness, i, j;
      drawfile_diagram *diagram = NULL;

      static int Scale[3][2] =
      {
        {1 << 16, 1 << 16},
        {1 << 16, 1 << 16},
        {draw_OS_UNIT, draw_OS_UNIT}};

      NOT_USED(argc)
          NOT_USED(workspace)

          tracef("tail \"%.*s\"\n" _ riscos_strlen(tail) _ tail);

      if ((error = xos_read_args("file/a,m00,m01,m10,m11,m20,m21,"
                                 "bbox/s,suppress/s,flatness/k", tail,
                                 (char *) &argl, sizeof argl, NULL)) != NULL)
        goto rendered;

      tracef("decoding is:\nfile \"%s\"\nm %s %s %s %s %s %s\n"
             "bbox %s\nsuppress %s\nflatness %s\n" _
             argl.file _ argl.m[0][0] != NULL ? argl.m[0][0] : "NULL" _
             argl.m[0][1] != NULL ? argl.m[0][1] : "NULL" _
             argl.m[1][0] != NULL ? argl.m[1][0] : "NULL" _
             argl.m[1][1] != NULL ? argl.m[1][1] : "NULL" _
             argl.m[2][0] != NULL ? argl.m[2][0] : "NULL" _
             argl.m[2][1] != NULL ? argl.m[2][1] : "NULL" _
             WHETHER(argl.bbox) _ WHETHER(argl.suppress) _
             argl.flatness != NULL ? argl.flatness : "NULL");

      if ((error = xosfile_read_no_path(argl.file, &obj_type, NULL, NULL,
                                        &size, NULL)) != NULL)
        goto rendered;
      if (obj_type != osfile_IS_FILE)
      {
        error = xosfile_make_error(argl.file, obj_type);
        goto rendered;
      }

/* Decode the matrix. */
      for (j = 0; j < 2; j++)
        for (i = 0; i < 3; i++)
          if (argl.m[i][j] == NULL || riscos_scan_fixed
              (argl.m[i][j], &m.entries[i][j], Scale[i][j]) ==
              0)
            m.entries[i][j] = Identity.entries[i][j];

      tracef("matrix ((0x%X 0x%X) (0x%X 0x%X) (%d %d))\n" _
             m.entries[0][0] _ m.entries[0][1] _
             m.entries[1][0] _ m.entries[1][1] _
             m.entries[2][0] _ m.entries[2][1]);

      if (argl.flatness == NULL ||
          riscos_scan_fixed(argl.flatness, &flatness, 256) == 0)
        flatness = -1;

      tracef("flatness %d\n" _ flatness);

      if ((diagram = m_ALLOC(size)) == NULL)
      {
        error = main_error_lookup(os_GLOBAL_NO_MEM, "NoMem");
        goto rendered;
      }
d391 4
a394 18
      if ((error = xosfile_load_stamped_no_path(argl.file,
                     (byte *) diagram, NULL, NULL, NULL, NULL, NULL)) != NULL)
        goto rendered;

      if ((error = verify_diagram(diagram, size)) != NULL)
        goto rendered;

      if ((error = render((argl.bbox ? drawfile_RENDER_BBOXES : NONE) |
                          (argl.suppress ? drawfile_RENDER_SUPPRESS : NONE) |
                     (flatness != -1 ? drawfile_RENDER_GIVEN_FLATNESS : NONE),
                          diagram, size, &m, NULL, flatness)) != NULL)
        goto rendered;

    rendered:
      m_FREE(diagram, size);
    }
    break;
  }
d396 1
a396 4
  return (_kernel_oserror *) error;
}
/*------------------------------------------------------------------------*/
os_error *main_error_lookup(int no, char *token,...)
d398 4
a401 13
{
  va_list list;
  char *p[4];
  int i;
  os_error error;

  tracef("main_error_lookup\n");

/* Assume that 4 args are always given. */
  va_start(list, token);
  for (i = 0; i < 4; i++)
    p[i] = va_arg(list, char *);
  va_end(list);
d403 2
a404 2
  error.errnum = no;
  strcpy(error.errmess, token);
d406 2
a407 2
  return xmessagetrans_error_lookup(&error, &Control_Block,
                                    NULL, 0, p[0], p[1], p[2], p[3]);
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

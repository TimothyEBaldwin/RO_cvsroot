head	4.5;
access;
symbols
	DrawFile-1_59:4.5
	DrawFile-1_58:4.5
	DrawFile-1_57:4.4
	DrawFile-1_56:4.4
	DrawFile-1_55:4.4
	DrawFile-1_54:4.4
	DrawFile-1_53:4.4
	RO_5_07:4.3
	DrawFile-1_52:4.3
	DrawFile-1_51:4.2
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	DrawFile-1_50:4.2
	dcotton_autobuild_BaseSW:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	DrawFile-1_49:4.2
	nicke_DrawFile-1_48:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.2
	ARTtmp:4.1.7.2.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2013.07.22.19.54.10;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	umvA53VChGhzgvYw;

4.4
date	2008.10.17.00.22.42;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.22.21.41.26;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.49.19;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.42.41;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.42.41;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.11.19;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.49.22;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.12.23;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.11.15.30.10;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Add support for background blended text and text areas
Files saved by !Draw 1.24 or later can opt to have transparent background colour to me use the blending font manager. This is the corresponding change to the renderer.
Ordinary text will not be plotted if the *foreground* colour is transparent - this seems to have been a discrepancy between !Draw and DrawFile, DrawFile used to render it in the background colour instead, imagining that this was like a shadow. The spirit of the draw file spec is that the background colour is an optional hint, however.
The state flags that end up on Service_DrawObjectRender no longer contain the DrawFile modules internal flags, only those documented.

Version 1.58. Tagged as 'DrawFile-1_58'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*render.c - implementation file for drawdata_render */

   /* The error handling here is strange because we want to attempt
      to plot all of the draw file before giving up. So all the
      callbacks just store their error codes away, and return NULL.
      In other words, instead of taking the form

      os_error *fn (..., osbool *u) {  os_error *error = NULL; ...

      finish: return error; }

      they look like this

      os_error *fn (..., osbool *u) {  os_error *error = NULL; ...

      finish: if (state->error == NULL) state->error = error; return
      NULL; }

      Also, the callback system is used as follows: the callback list
      is scanned for each object. If a function renders it, it claims
      the callback. If the callback is not claimed, a service call is
      sent round. This system is also used internally: if a text
      object gives an error, it does not claim the callback, and the
      system-font renderer has a go. */

/*From CLib */
#include <limits.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

/*From OSLib */
#include "colourtrans.h"
#include "draw.h"
#include "jpeg.h"
#include "macros.h"
#include "os.h"

/*From Support */
#include "callback.h"
#include "muldiv.h"
#include "riscos.h"
#include "jc_trace.h"
#include "trfm.h"

/*Local */
#include "drawfile.h"
#include "main.h"
#include "render.h"
#include "textarea.h"
#include "verify.h"

#define DEFAULT_FLATNESS (draw_OS_UNIT/2)
   /* The value '0' here (which allows the Draw module to use a
      default of its own choice) results in poor rendering. */

osbool render_can_blend;

/*------------------------------------------------------------------------*/
static os_error *Sprite(osspriteop_header * header, os_trfm * trfm)

{
  os_error *error = NULL;
  int entry_count;
  osspriteop_TRANS_TAB(256) trans_tab;

  entry_count = (header->image - sizeof(osspriteop_header)) /
      sizeof(os_colour_pair);

  if (entry_count > 0)
  {
    if ((error = xcolourtrans_select_table_for_sprite
         (osspriteop_UNSPECIFIED, (osspriteop_id) header,
          colourtrans_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
          (osspriteop_trans_tab *) & trans_tab, colourtrans_GIVEN_SPRITE))
        != NULL)
      goto finish;
  }
  else
  {                                    /* Sprite has no palette. */
    int log2_bpp;
    os_PALETTE(20) palette;
    bits flags;

    if ((error = xos_read_mode_variable(header->mode, os_MODEVAR_LOG2_BPP,
                                        &log2_bpp, &flags)) != NULL)
      goto finish;

    if ((flags & _C) != NONE)
    {
      char s[DEC_WIDTH + 1];

      error = main_error_lookup(error_DRAW_FILE_BAD_MODE, "BadMode",
                              riscos_format_dec(s, (int) header->mode, 0, 1));
      goto finish;
    }

    if (log2_bpp < 3)
      if ((error = xwimp_read_true_palette((os_palette *) & palette)) !=
          NULL)
        goto finish;

/* Fix MED-4786: use the right entries for palettes < 16 entries. J R
   C 6th Mar 1995 */
    switch (log2_bpp)
    {
    case 0:
      palette.entries[1] = palette.entries[7];
      break;

    case 1:
      palette.entries[1] = palette.entries[2];
      palette.entries[2] = palette.entries[4];
      palette.entries[3] = palette.entries[7];
      break;
    }

    if ((error = xcolourtrans_select_table(header->mode, log2_bpp < 3 ?
                       (os_palette *) & palette : colourtrans_CURRENT_PALETTE,
                        colourtrans_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
                               (osspriteop_trans_tab *) & trans_tab)) != NULL)
      goto finish;
  }

  if ((error = xosspriteop_put_sprite_trfm(osspriteop_PTR,
                   osspriteop_UNSPECIFIED, (osspriteop_id) header, NONE, NULL,
           os_ACTION_USE_MASK, trfm, (osspriteop_trans_tab *) & trans_tab)) !=
      NULL)
    goto finish;

finish:
  return error;
}
/*------------------------------------------------------------------------*/
static os_error *Text_System(char *text, os_colour fill, os_trfm * trfm)

   /* Create a sprite, clear it to the text colour, and write the
      character into the mask. */

{
  typedef
  struct
  {
    osspriteop_area area;
    osspriteop_header header;
    os_colour_pair palette[2];
    bits image[8];
    bits mask[8];
  }
  mode0_8x8_sprite;

  os_error *error = NULL;
  int len, r0, r1, r2, r3, i;

  mode0_8x8_sprite sprite =
  {                                    /* area */
    { /* size */ sizeof sprite,
/* sprite_count */ 1,
/* first */ offsetof(mode0_8x8_sprite, header),
/* free */ sizeof sprite
    },

/* header */
    { /* size */ sizeof sprite.header + sizeof sprite.palette +
     sizeof sprite.image + sizeof sprite.mask,
/* name */ "t",
     /* width */ 0 /* 8 columns */ ,
     /* height */ 7 /* 8 rows */ ,
/* left_bit */ 0,
/* right_bit */ 7,
/* image */ sizeof sprite.header + sizeof sprite.palette,
/* mask */ sizeof sprite.header + sizeof sprite.palette +
     sizeof sprite.image,
/* mode */ 0
    },

/* palette */
    {
      { /* on */ SKIP,
                                       /* off */ SKIP
                                       /* filled in with real colour */
      },
      { /* on */ SKIP,
                                       /* off */ SKIP
                                       /* never seen */
      }
    },

/* bitmap */
    {0, 0, 0, 0, 0, 0, 0, 0},

/* mask */
    {-1, -1, -1, -1, -1, -1, -1, -1}
  };
  osbool done_switch_output = FALSE;
  os_coord base =
  {16 * draw_OS_UNIT, 0}, step;
  os_trfm char_trfm = *trfm;

  static char gcol0[] =
  {os_VDU_SET_GCOL, os_ACTION_OVERWRITE, 0};

  tracef("Text_System: trfm_dir\n");
  trfm_dir(&step, trfm, &base);

  len = strlen(text);

/* Fill in the colour to be used. */
  sprite.palette[0].on = sprite.palette[0].off = fill;

  for (i = 0; i < len; i++)
  {
    tracef("Text_System: osspriteop_switch_output_to_mask\n");
    if ((error = xosspriteop_switch_output_to_mask(osspriteop_PTR,
                          &sprite.area, (osspriteop_id) & sprite.header, NULL,
                                                 &r0, &r1, &r2, &r3)) != NULL)
      goto finish;
    done_switch_output = TRUE;

    tracef("Text_System: os_writen\n");
    if ((error = xos_writen(gcol0, sizeof gcol0)) != NULL)
      goto finish;

    tracef("Text_System: os_plot\n");
    if ((error = xos_plot(os_MOVE_TO, 0, 32)) != NULL)
      goto finish;

    tracef("Text_System: os_writec\n");
    if ((error = xos_writec(text[i])) != NULL)
      goto finish;

    tracef("Text_System: osspriteop_unswitch_output (0x%X, %d, %d, %d)\n"
           _ r0 _ r1 _ r2 _ r3);
    if ((error = xosspriteop_unswitch_output(r0, r1, r2, r3)) != NULL)
      goto finish;
    done_switch_output = FALSE;

/* Now we can plot the sprite. We use the internal sprite renderer
   which makes a translation table. */
    tracef("Text_System: Sprite\n");
    if ((error = Sprite(&sprite.header, &char_trfm)) != NULL)
      goto finish;

    char_trfm.entries[2][0] += step.x;
    char_trfm.entries[2][1] += step.y;
  }

finish:
  if (done_switch_output)
  {
    os_error *error1 = xosspriteop_unswitch_output(r0, r1, r2, r3);

    if (error == NULL)
      error = error1;
  }
  return error;
}
/*------------------------------------------------------------------------*/
static os_error *Bbox(os_box * box, os_trfm * trfm)

{
  os_error *error = NULL;
  os_coord u[4], t[4];
  int i;
  char set_dot_style[] =
  {os_VDU_MISC, os_MISC_SET_DOT_STYLE, 0xCC, 0,
   0xCC, 0, 0xCC, 0, 0xCC, 0};

  u[0].x = box->x0, u[0].y = box->y0;
  u[1].x = box->x1, u[1].y = box->y0;
  u[2].x = box->x1, u[2].y = box->y1;
  u[3].x = box->x0, u[3].y = box->y1;

  for (i = 0; i < 4; i++)
  {
    trfm_point(&t[i], trfm, &u[i]);
    t[i].x /= draw_OS_UNIT, t[i].y /= draw_OS_UNIT;
  }

  if ((error = xcolourtrans_set_gcol(os_COLOUR_LIGHT_RED,
                colourtrans_SET_FG_GCOL, os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
    goto finish;

  if ((error = xos_writen(set_dot_style, sizeof set_dot_style)) != NULL)
    goto finish;

  if ((error = xos_plot(os_MOVE_TO, t[3].x, t[3].y)) != NULL)
    goto finish;

  for (i = 0; i < 4; i++)
    if ((error = xos_plot(os_PLOT_TO | os_PLOT_DOTTED, t[i].x, t[i].y))
        != NULL)
      goto finish;

finish:
  return error;
}
/*------------------------------------------------------------------------*/
os_error *render(bits flags, drawfile_diagram * diagram, int size,
                 os_trfm * trfm, os_box * clip, int flatness)

{
  os_error *error = NULL;
  drawfile_object *end, *o;
  drawfile_render_state state;
  os_box inv_clip;
  osbool can_clip, unclaimed;
  int version;

  tracef("render\n");
  xfont_cache_addr(&version, NULL, NULL);
  render_can_blend = version >= 335; /* FontManager does background blending */

  can_clip = clip != NULL && trfm_det(trfm) != 0;

  if (can_clip)
  {                                    /* Transform the clipping box
                                          given back to the
                                          coordinates it would have
                                          had in paper coordinates,
                                          and rebound it there. */
    os_trfm inv;
    int i;
    os_box clip_draw;

    for (i = 0; i < 4; i++)
      (&clip_draw.x0)[i] = (&clip->x0)[i] * draw_OS_UNIT;

    trfm_inv(&inv, trfm);
    trfm_box(&inv_clip, &inv, &clip_draw);
  }

  state.diagram = diagram;
  state.font_table = NULL;
  state.flags = flags;
  state.trfm = trfm;
  state.clip = can_clip ? &inv_clip : NULL;
  state.flatness = (flags & drawfile_RENDER_GIVEN_FLATNESS) != NONE ?
      flatness : DEFAULT_FLATNESS;
  state.error = NULL;

  tracef("render: despatching\n");
  end = (drawfile_object *) & ((byte *) diagram)[size];
  for (o = diagram->objects; o < end; *(byte **) & o += o->size)
  {
    state.object = o;
    if ((error = callback(main_render_callback, &state, &unclaimed, 1,
                          o->type)) != NULL)
      goto finish;

    if (unclaimed && o->type >= 0x100)
    {
      if ((error = xservice_draw_object_render(o->type, &state, NULL)) !=
          NULL)
        goto finish;
    }
  }

finish:
  return error != NULL ? error : state.error;
}
/*------------------------------------------------------------------------*/
os_error *render_font_table(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */

  tracef("render_font_table\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_FONT_TABLE);
   #else
  null = null;
   #endif

/* Save the pointer. */
  state->font_table = state->object;

  *unclaimed = FALSE;

/*finish: */
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_font_table: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_text_system(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */
  os_trfm trfm, text_trfm;
  drawfile_text *text = &state->object->data AS text;

  tracef("render_text_system\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TEXT);
   #else
  null = null;
   #endif

  if (state->clip == NULL || verify_overlap(state->clip, &text->bbox))
  {
    int len = strlen(text->text);

    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&text->bbox, state->trfm);

    if (text->fill != os_COLOUR_TRANSPARENT &&
        (state->flags & drawfile_RENDER_SUPPRESS) == NONE && len > 0)
    {                                  /* If the text is REALLY in
                                          system font, we honour the
                                          baseline and size fields in
                                          the definition; otherwise,
                                          we simply scale system text
                                          to fit inside the bbox the
                                          font claims to have. This
                                          gives better results than
                                          Draw's treatment, since
                                          system text is usually much
                                          wider for a given nominal x
                                          size than an outline font. */

      if (text->style.font_index == font_SYSTEM)
      {                                /* Get the trfm needed to
                                          scale the text to paper
                                          coords. */
        text_trfm.entries[0][0] = text->xsize * ((1 << 16) /
                                                 (16 * draw_OS_UNIT));
        text_trfm.entries[0][1] = 0;
        text_trfm.entries[1][0] = 0;
        text_trfm.entries[1][1] = text->ysize * ((1 << 16) /
                                                 (32 * draw_OS_UNIT));
        text_trfm.entries[2][0] = text->base.x;
        text_trfm.entries[2][1] = text->base.y - text->ysize / 8;
      }
      else
      {                                /* Which trfm takes the text
                                          into its bounding box? */
        text_trfm.entries[0][0] = (text->bbox.x1 - text->bbox.x0) *
            ((1 << 16) / (16 * draw_OS_UNIT)) / len;
        text_trfm.entries[0][1] = 0;
        text_trfm.entries[1][0] = 0;
        text_trfm.entries[1][1] = (text->bbox.y1 - text->bbox.y0) *
            ((1 << 16) / (32 * draw_OS_UNIT));
        text_trfm.entries[2][0] = text->bbox.x0;
        text_trfm.entries[2][1] = text->bbox.y0;
      }

      tracef("render_text_system: trfm_mul\n");
      trfm_mul(&trfm, state->trfm, &text_trfm);

      if ((error = Text_System(text->text, text->fill, &trfm)) != NULL)
        goto finish;
    }
  }

  *unclaimed = FALSE;

finish:
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_text_system: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_text(void *null, void *s, osbool * unclaimed)

{
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */
  os_error *error = NULL;
  drawfile_text *text = &state->object->data AS text;
  char *font_name;
  osbool done_find_font = FALSE;
  font_string_flags blend;
  font_f f;
  os_trfm trfm;
  os_coord base;

  tracef("render_text\n");

   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TEXT);
   #else
  null = null;
   #endif

  if (text->style.font_index != font_SYSTEM)
  {
    if (state->clip == NULL || verify_overlap(state->clip, &text->bbox))
    {
      if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
        (void) Bbox(&text->bbox, state->trfm);

/* Get the font table pointer. */
      font_name = verify_lookup_font_index(text->style.font_index,
                                           state->font_table);
/* we know that |state->font_table| is not NULL and that
   |verify_lookup_font_index()| returns a value because of
   |verify()|. */

      if (text->fill != os_COLOUR_TRANSPARENT &&
          (state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      {
        tracef("finding font \"%s\", size (%d, %d)\n" _
               font_name _ text->xsize / 40 _
               text->ysize / 40);
        if ((error = xfont_find_font(font_name, text->xsize / 40,
                             text->ysize / 40, 0, 0, &f, NULL, NULL)) != NULL)
          goto finish;
        done_find_font = TRUE;

        tracef("setting colours 0x%X, 0x%X\n" _
               text->bg_hint _ text->fill);
        if ((error = xcolourtrans_set_font_colours(f,
                    text->bg_hint, text->fill, 14, NULL, NULL, NULL)) != NULL)
          goto finish;

/* For bitmapped fonts, the font manager can't cope with translations
   in the matrix ... so move the translation part out of the matrix
   into the baseline origin. */
        trfm = *state->trfm;
        trfm.entries[2][0] = 0;
        trfm.entries[2][1] = 0;

        trfm_point(&base, state->trfm, &text->base);

        blend = (render_can_blend &&
                (text->bg_hint == os_COLOUR_TRANSPARENT)) ? font_BLEND_FONT : 0;

/* Paint the text. */
        tracef("painting \"%s\" at (%d, %d) through ((%d, %d), "
               "(%d, %d), (%d, %d))\n" _
               text->text _ base.x _ base.y _
               trfm.entries[0][0] _ trfm.entries[0][1] _
               trfm.entries[1][0] _ trfm.entries[1][1] _
               trfm.entries[2][0] _ trfm.entries[2][1]);
        if ((error = xfont_paint(f, text->text, font_OS_UNITS |
                     font_GIVEN_TRFM | font_GIVEN_FONT | blend, base.x / draw_OS_UNIT,
                           base.y / draw_OS_UNIT, SKIP, &trfm, SKIP)) != NULL)
          goto finish;
      }
    }

    *unclaimed = FALSE;
  }

finish:
  if (done_find_font)
  {
    os_error *error1 = xfont_lose_font(f);
    if (error == NULL)
      error = error1;
  }

  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_text: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_path(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */
  drawfile_path *path = &state->object->data AS path;
  draw_path *elements;
  draw_dash_pattern *pattern;
  draw_line_style line_style;

  tracef("render_path\n");
#ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_PATH);
#else
  null = null;
#endif

#if TRACE
  if (state->clip != NULL)
  {
    tracef("clipping rectangle given as ((%d, %d), (%d, %d))\n" _
           state->clip->x0 _ state->clip->y0 _
           state->clip->x1 _ state->clip->y1);
    tracef("testing against bbox of ((%d, %d), (%d, %d))\n" _
           path->bbox.x0 _ path->bbox.y0 _
           path->bbox.x1 _ path->bbox.y1);
    tracef("-> overlap %s\n" _ WHETHER(verify_overlap(state->clip,
                                                      &path->bbox)));
  }
#endif

  if (state->clip == NULL || verify_overlap(state->clip, &path->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&path->bbox, state->trfm);

     #if TRACE
    {
      int i;
      tracef("using style 0x");
      for (i = 0; i < sizeof(drawfile_path_style); i++)
        trace_f(NULL, 0, "%.2X" _
                ((byte *) & path->style)[i]);
      trace_f(NULL, 0, "\n");
    }
     #endif
    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
    {                                  /* Convert the
                                          drawfile_path_style into a
                                          draw_line_style. */
      byte flags = path->style.flags;

      line_style.join_style = (flags & drawfile_PATH_JOIN) >>
          drawfile_PATH_JOIN_SHIFT;
      line_style.start_cap_style = (flags & drawfile_PATH_START) >>
          drawfile_PATH_START_SHIFT;
      line_style.end_cap_style = (flags & drawfile_PATH_END) >>
          drawfile_PATH_END_SHIFT;
      line_style.reserved = 0;
      line_style.mitre_limit = 10 << 16;  /* Postscript default */
      line_style.start_cap_width = line_style.end_cap_width =
          16 * path->style.cap_width;
      line_style.start_cap_length = line_style.end_cap_length =
          16 * path->style.cap_length;

/* Get the draw_pattern. */
      if ((flags & drawfile_PATH_DASHED) != NONE)
      {
        pattern = &state->object->data AS path_with_pattern.pattern;
        elements = (draw_path *) ((byte *) pattern +
                            draw_SIZEOF_DASH_PATTERN(pattern->element_count));
      }
      else
      {
        pattern = NULL;
        elements = &path->path;
      }

      if (path->fill != os_COLOUR_TRANSPARENT)
      {
        if ((error = xcolourtrans_set_gcol(path->fill,
                                    colourtrans_SET_FG_GCOL | colourtrans_USE_ECFS_GCOL,
                                    os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
          goto finish;

        if ((error = xdraw_fill(elements, draw_FILL_FULL_INTERIOR |
                                draw_FILL_INTERIOR_BOUNDARY | ((flags &
                                     drawfile_PATH_WINDING_EVEN_ODD) != NONE ?
                         draw_FILL_EVEN_ODD : draw_FILL_NONZERO), state->trfm,
                                state->flatness)) != NULL)
          goto finish;
      }

      if (path->outline != os_COLOUR_TRANSPARENT)
      {
        if ((error = xcolourtrans_set_gcol(path->outline,
                                    colourtrans_SET_FG_GCOL | colourtrans_USE_ECFS_GCOL,
                                    os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
          goto finish;

               #if TRACE
        {
          int i;
          tracef("using line_style 0x");
          for (i = 0; i < sizeof(draw_line_style); i++)
            trace_f(NULL, 0, "%.2X" _((byte *) & line_style)[i]);
          trace_f(NULL, 0, "\n");
        }
               #endif
        if ((error = xdraw_stroke(elements, draw_FILL_FULL_INTERIOR |
                    draw_FILL_INTERIOR_BOUNDARY | draw_FILL_EXTERIOR_BOUNDARY,
                       state->trfm, state->flatness, path->width, &line_style,
                                  pattern)) != NULL)
          goto finish;
      }
    }
  }

  *unclaimed = FALSE;

finish:
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_path: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_sprite(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */
  drawfile_sprite *sprite = &state->object->data AS sprite;
  int xeig, yeig, width, height;
  bits flags1, flags2;
  os_trfm trfm, sprite_trfm;

  tracef("render_sprite\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_SPRITE);
   #else
  null = null;
   #endif

  if (state->clip == NULL || verify_overlap(state->clip, &sprite->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&sprite->bbox, state->trfm);

    if ((error = xosspriteop_read_sprite_size(osspriteop_PTR,
              osspriteop_UNSPECIFIED, (osspriteop_id) & state->object->data AS
                         sprite.header, &width, &height, NULL, NULL)) != NULL)
      goto finish;

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE &&
        width > 0 && height > 0)
    {
      if ((error = xos_read_mode_variable(sprite->header.mode,
                             os_MODEVAR_XEIG_FACTOR, &xeig, &flags1)) != NULL)
        goto finish;

      if ((error = xos_read_mode_variable(sprite->header.mode,
                             os_MODEVAR_YEIG_FACTOR, &yeig, &flags2)) != NULL)
        goto finish;

      if (((flags1 | flags2) & _C) != NONE)
      {
        char s[DEC_WIDTH + 1];

        error = main_error_lookup(error_DRAW_FILE_BAD_MODE, "BadMode",
                       riscos_format_dec(s, (int) sprite->header.mode, 0, 1));
        goto finish;
      }

/* Get the trfm needed to scale the sprite to paper coords. */
      sprite_trfm.entries[0][0] = muldiv(sprite->bbox.x1 -
                      sprite->bbox.x0, 1 << 16, width * draw_OS_UNIT << xeig);
      sprite_trfm.entries[0][1] = 0;
      sprite_trfm.entries[1][0] = 0;
      sprite_trfm.entries[1][1] = muldiv(sprite->bbox.y1 -
                     sprite->bbox.y0, 1 << 16, height * draw_OS_UNIT << yeig);
      sprite_trfm.entries[2][0] = sprite->bbox.x0;
      sprite_trfm.entries[2][1] = sprite->bbox.y0;

/* Multiply the matrix in the sprite by the given matrix to get the
   matrix to plot through. */
      trfm_mul(&trfm, state->trfm, &sprite_trfm);

      if ((error = Sprite(&sprite->header, &trfm)) != NULL)
        goto finish;
    }
  }

  *unclaimed = FALSE;

finish:
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_sprite: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_group(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s  /* save
                                                                 typing */ ;
  drawfile_group *group = &state->object->data AS group;
  drawfile_object *o, *end;
  osbool u;

  tracef("render_group\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_GROUP);
   #else
  null = null;
   #endif

  if (state->clip == NULL || verify_overlap(state->clip, &group->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&group->bbox, state->trfm);

    end = (drawfile_object *) & ((byte *) state->object)
        [state->object->size];
    for (o = (drawfile_object *) & group->objects; o < end;
         *(byte **) & o += o->size)
    {
      state->object = o;
      if ((error = callback(main_render_callback, state, &u, 1,
                            o->type)) != NULL)
        goto finish;

      if (u && o->type >= 0x100)
      {
        if ((error = xservice_draw_object_render(o->type, state, NULL))
            != NULL)
          goto finish;
      }
    }
  }

  *unclaimed = FALSE;

finish:
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_group: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_tagged(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s  /* save
                                                                 typing */ ;
  drawfile_tagged *tagged = &state->object->data AS tagged;
  drawfile_object *o, *end;
  osbool u;

  tracef("render_tagged\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TAGGED);
   #else
  null = null;
   #endif

  o = (drawfile_object *) & tagged->object;
  end = (drawfile_object *) & ((byte *) state->object)
      [state->object->size];
  if ((drawfile_object *) & ((byte *) o)[o->size] > end)
  {
    error = main_error_lookup(error_DRAW_FILE_BAD_TAG, "BadTag");
    goto finish;
  }

  state->object = o;
  if ((error = callback(main_render_callback, state, &u, 1, o->type)) !=
      NULL)
    goto finish;

  if (u && o->type >= 0x100)
  {
    if ((error = xservice_draw_object_render(o->type, state, NULL)) !=
        NULL)
      goto finish;
  }

  *unclaimed = FALSE;

finish:
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_tagged: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_text_area(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */
  drawfile_text_area *text_area = &state->object->data AS text_area;

  tracef("render_text_area\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TEXT_AREA);
   #else
  null = null;
   #endif

  if (state->clip == NULL || verify_overlap(state->clip, &text_area->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&text_area->bbox, state->trfm);

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      if ((error = textarea_render(state->object, state->trfm,
                                   state->clip, state->flags)) != NULL)
        goto finish;
  }

  *unclaimed = FALSE;

finish:
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_text_area: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_trfm_text_system(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */
  drawfile_trfm_text *trfm_text = &state->object->data AS trfm_text;
  os_trfm trfm, text_trfm;

  tracef("render_trfm_text_system\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TRFM_TEXT);
   #else
  null = null;
   #endif

  if (state->clip == NULL || verify_overlap(state->clip, &trfm_text->bbox))
  {
    int len = strlen(trfm_text->text);

    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&trfm_text->bbox, state->trfm);

    if (trfm_text->fill != os_COLOUR_TRANSPARENT &&
        (state->flags & drawfile_RENDER_SUPPRESS) == NONE && len > 0)
    {                                  /* If the text is REALLY in
                                          system font, we honour the
                                          baseline, transformation
                                          and size fields in the
                                          definition; otherwise, we
                                          simply scale system text to
                                          fit inside the bbox the
                                          font claims to have,
                                          without making any attempt
                                          to apply the
                                          transformation. To scale
                                          the text to fit inside the
                                          bounding box WITH the
                                          transformation applied
                                          would involve solving a
                                          linear optimisation problem
                                          (for the font width) with
                                          eight constraints. */

      if (trfm_text->style.font_index == font_SYSTEM)
      {                                /* Get the trfm needed to
                                          scale the text to the
                                          coords it would have if it
                                          were a "real" font. */
        os_trfm trfm1, trfm2;

        trfm1.entries[0][0] = trfm_text->xsize * ((1 << 16) /
                                                  (16 * draw_OS_UNIT));
        trfm1.entries[0][1] = 0;
        trfm1.entries[1][0] = 0;
        trfm1.entries[1][1] = trfm_text->ysize * ((1 << 16) /
                                                  (32 * draw_OS_UNIT));
        trfm1.entries[2][0] = 0;
        trfm1.entries[2][1] = -trfm_text->ysize / 8;

        trfm_mul(&trfm2, &trfm_text->trfm, &trfm1);

        trfm1.entries[0][0] = 1 << 16;
        trfm1.entries[0][1] = 0;
        trfm1.entries[1][0] = 0;
        trfm1.entries[1][1] = 1 << 16;
        trfm1.entries[2][0] = trfm_text->base.x;
        trfm1.entries[2][1] = trfm_text->base.y;

        trfm_mul(&text_trfm, &trfm1, &trfm2);
      }
      else
      {                                /* Which trfm takes the text
                                          into its bounding box? */
        text_trfm.entries[0][0] = (trfm_text->bbox.x1 -
                trfm_text->bbox.x0) * ((1 << 16) / (16 * draw_OS_UNIT)) / len;
        text_trfm.entries[0][1] = 0;
        text_trfm.entries[1][0] = 0;
        text_trfm.entries[1][1] = (trfm_text->bbox.y1 -
                      trfm_text->bbox.y0) * ((1 << 16) / (32 * draw_OS_UNIT));
        text_trfm.entries[2][0] = trfm_text->bbox.x0;
        text_trfm.entries[2][1] = trfm_text->bbox.y0;
      }

      tracef("render_trfm_text_system: trfm_mul\n");
      trfm_mul(&trfm, state->trfm, &text_trfm);

      if ((error = Text_System(trfm_text->text, trfm_text->fill, &trfm))
          != NULL)
        goto finish;
    }
  }

  *unclaimed = FALSE;

finish:
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_trfm_text_system: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_trfm_text(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */
  drawfile_trfm_text *trfm_text = &state->object->data AS trfm_text;
  char *font_name;
  osbool done_find_font = FALSE;
  font_string_flags blend;
  font_f f;
  os_trfm trfm;
  os_coord base;

  tracef("render_trfm_text\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TRFM_TEXT);
   #else
  null = null;
   #endif

  if (trfm_text->style.font_index != font_SYSTEM)
  {
    if (state->clip == NULL || verify_overlap(state->clip,
                                              &trfm_text->bbox))
    {
      if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
        (void) Bbox(&trfm_text->bbox, state->trfm);

/* Check the font table pointer. */
      font_name = verify_lookup_font_index(trfm_text->style.font_index,
                                           state->font_table);
/* we know that |state->font_table| is not NULL and that
   |verify_lookup_font_index()| returns a value because of
   |verify()|. */

      if (trfm_text->fill != os_COLOUR_TRANSPARENT
          && (state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      {
        char tmp[3], *text;
        tracef("finding font \"%s\", size (%d, %d)\n" _
               font_name _ trfm_text->xsize / 40 _ trfm_text->ysize / 40);

        if ((error = xfont_find_font(font_name, trfm_text->xsize / 40,
                        trfm_text->ysize / 40, 0, 0, &f, NULL, NULL)) != NULL)
          goto finish;
        done_find_font = TRUE;

        tracef("setting colours 0x%X, 0x%X\n" _
               trfm_text->bg_hint _ trfm_text->fill);
        if ((error = xcolourtrans_set_font_colours(f,
                          trfm_text->bg_hint, trfm_text->fill, 14, NULL, NULL,
                                                   NULL)) != NULL)
          goto finish;

/* Stupid Font_Paint wants OS Units in the matrix */
        trfm_mul(&trfm, state->trfm, &trfm_text->trfm);
        trfm.entries[2][0] /= draw_OS_UNIT;
        trfm.entries[2][1] /= draw_OS_UNIT;

        trfm_point(&base, state->trfm, &trfm_text->base);

        blend = (render_can_blend &&
                (trfm_text->bg_hint == os_COLOUR_TRANSPARENT)) ? font_BLEND_FONT : 0;

/* Paint the text. */
        text = trfm_text->text;
        if ((trfm_text->flags & drawfile_TEXT_UNDERLINE) != NONE)
        {
          text -= 3;
          memcpy(tmp, text, 3);
          text[0] = font_COMMAND_UNDERLINE;
          text[1] = -25 + 0x100;
          text[2] = 15;
        }
        tracef("painting \"%s\" at (%d, %d)\n" _ text _
               trfm_text->base.x _ trfm_text->base.y);
        error = xfont_paint(f, text, font_OS_UNITS | font_GIVEN_TRFM |
                    font_GIVEN_FONT | blend
                    | ((trfm_text->flags & drawfile_TEXT_KERN)
                            != NONE ? font_KERN : NONE) | ((trfm_text->flags &
                   drawfile_TEXT_RIGHT_TO_LEFT) != NONE ? font_RIGHT_TO_LEFT :
                    NONE), base.x / draw_OS_UNIT, base.y / draw_OS_UNIT, SKIP,
                            &trfm, SKIP);
        if ((trfm_text->flags & drawfile_TEXT_UNDERLINE) != 0)
          memcpy(text, tmp, 3);
      }

      *unclaimed = FALSE;
    }
  }

finish:
  if (done_find_font)
  {
    os_error *error1 = xfont_lose_font(f);
    if (error == NULL)
      error = error1;
  }

  if (state->error == NULL)
    state->error = error;
/* Claim this call if everything went o k. (If not,
   render_trfm_text_system() will have a go.) */
  if (error != NULL)
    tracef("render_trfm_text: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_trfm_sprite(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */
  drawfile_trfm_sprite *trfm_sprite = &state->object->data AS trfm_sprite;
  os_trfm trfm;

  tracef("render_trfm_sprite\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TRFM_SPRITE);
   #else
  null = null;
   #endif

  if (state->clip == NULL || verify_overlap(state->clip,
                                            &trfm_sprite->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&trfm_sprite->bbox, state->trfm);

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
    {                                  /* Multiply the matrix in the
                                          sprite by the given matrix
                                          to get the matrix  to plot
                                          through. */
      trfm_mul(&trfm, state->trfm, &trfm_sprite->trfm);

      if ((error = Sprite(&trfm_sprite->header, &trfm)) != NULL)
        goto finish;
    }
  }

  *unclaimed = FALSE;

finish:
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_trfm_sprite: \"%s\"\n" _ error->errmess);
  return NULL;
}
/*------------------------------------------------------------------------*/
os_error *render_jpeg(void *null, void *s, osbool * unclaimed)

{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
                                                                  typing */
  drawfile_jpeg *jpeg = &state->object->data AS jpeg;
  os_trfm trfm;

  tracef("render_jpeg\n");
   #ifdef TEST
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_JPEG);
   #else
  null = null;
   #endif

  if (state->clip == NULL || verify_overlap(state->clip, &jpeg->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&jpeg->bbox, state->trfm);

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
    {                                  /* Multiply the matrix in the
                                          JPEG by the given matrix to
                                          get the matrix  to plot
                                          through. */
      trfm_mul(&trfm, state->trfm, &jpeg->trfm);

      if ((error = xjpeg_plot_transformed(&jpeg->image,
                          jpeg_TRANSFORM_DITHERED, &trfm, jpeg->len)) != NULL)
        goto finish;
    }
  }

  *unclaimed = FALSE;

finish:
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_jpeg: \"%s\"\n" _ error->errmess);
  return NULL;
}
@


4.4
log
@Renamed symbols in order to build with OSLib 6.90.

Version 1.53. Tagged as 'DrawFile-1_53'
@
text
@d71 2
d322 1
d325 3
d497 1
d551 3
d562 1
a562 1
                     font_GIVEN_TRFM | font_GIVEN_FONT | (state->flags & font_BLEND_FONT), base.x / draw_OS_UNIT,
d1045 1
d1099 3
d1115 1
a1115 1
                    font_GIVEN_FONT | (state->flags & font_BLEND_FONT)
@


4.3
log
@Made to work with C99

Version 1.52. Tagged as 'DrawFile-1_52'
@
text
@d293 1
a293 1
                colourtrans_SET_FG, os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
d659 1
a659 1
                                    colourtrans_SET_FG | colourtrans_USE_ECFS,
d674 1
a674 1
                                    colourtrans_SET_FG | colourtrans_USE_ECFS,
@


4.2
log
@Version Spin_merge taken
@
text
@d22 1
a22 1
      os_error *fn (..., bool *u) {  os_error *error = NULL; ...
d28 1
a28 1
      os_error *fn (..., bool *u) {  os_error *error = NULL; ...
d131 1
a131 1
                                (os_palette *) & palette : (os_palette *) - 1,
d207 1
a207 1
  bool done_switch_output = FALSE;
d319 1
a319 1
  bool can_clip, unclaimed;
d371 1
a371 1
os_error *render_font_table(void *null, void *s, bool * unclaimed)
d399 1
a399 1
os_error *render_text_system(void *null, void *s, bool * unclaimed)
d482 1
a482 1
os_error *render_text(void *null, void *s, bool * unclaimed)
d490 1
a490 1
  bool done_find_font = FALSE;
d576 1
a576 1
os_error *render_path(void *null, void *s, bool * unclaimed)
d706 1
a706 1
os_error *render_sprite(void *null, void *s, bool * unclaimed)
d784 1
a784 1
os_error *render_group(void *null, void *s, bool * unclaimed)
d792 1
a792 1
  bool u;
d836 1
a836 1
os_error *render_tagged(void *null, void *s, bool * unclaimed)
d844 1
a844 1
  bool u;
d885 1
a885 1
os_error *render_text_area(void *null, void *s, bool * unclaimed)
d922 1
a922 1
os_error *render_trfm_text_system(void *null, void *s, bool * unclaimed)
d1026 1
a1026 1
os_error *render_trfm_text(void *null, void *s, bool * unclaimed)
d1034 1
a1034 1
  bool done_find_font = FALSE;
d1132 1
a1132 1
os_error *render_trfm_sprite(void *null, void *s, bool * unclaimed)
d1177 1
a1177 1
os_error *render_jpeg(void *null, void *s, bool * unclaimed)
@


4.1
log
@Initial revision
@
text
@d15 1
a15 1
/*render.c - implementation file for drawdata_render*/
d17 8
a24 12
   /*The error handling here is strange because we want to attempt to plot
      all of the draw file before giving up. So all the callbacks just store
      their error codes away, and return NULL. In other words, instead of
      taking the form

            os_error *fn (..., bool *u)
            {  os_error *error = NULL;
               ...

            finish:
               return error;
            }
d28 4
a31 15
            os_error *fn (..., bool *u)
            {  os_error *error = NULL;
               ...

            finish:
               if (state->error == NULL) state->error = error;
               return NULL;
            }

   Also, the callback system is used as follows: the callback list is scanned
     for each object. If a function renders it, it claims the callback. If
     the callback is not claimed, a service call is sent round. This system
     is also used internally: if a text object gives an error, it does not
     claim the callback, and the system-font renderer has a go.
   */
d33 8
a40 1
/*From CLib*/
d46 1
a46 1
/*From OSLib*/
d53 1
a53 1
/*From Support*/
d57 1
a57 1
#include "trace.h"
d60 1
a60 1
/*Local*/
d68 2
a69 2
   /*The value '0' here (which allows the Draw module to use a default
      of its own choice) results in poor rendering.*/
d72 1
a72 1
static os_error *Sprite (osspriteop_header *header, os_trfm *trfm)
d74 30
a103 32
{  os_error *error = NULL;
   int entry_count;
   osspriteop_TRANS_TAB (256) trans_tab;

   entry_count = (header->image - sizeof (osspriteop_header))/
         sizeof (os_colour_pair);

   if (entry_count > 0)
   {  if ((error = xcolourtrans_select_table_for_sprite
            (osspriteop_UNSPECIFIED, (osspriteop_id) header,
            colourtrans_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
            (osspriteop_trans_tab *) &trans_tab, colourtrans_GIVEN_SPRITE))
            != NULL)
         goto finish;
   }
   else
   {  /*Sprite has no palette.*/
      int log2_bpp;
      os_PALETTE (20) palette;
      bits flags;

      if ((error = xos_read_mode_variable (header->mode, os_MODEVAR_LOG2_BPP,
            &log2_bpp, &flags)) != NULL)
         goto finish;

      if ((flags & _C) != NONE)
      {  char s [DEC_WIDTH + 1];

         error = main_error_lookup (error_DRAW_FILE_BAD_MODE, "BadMode",
               riscos_format_dec (s, (int) header->mode, 0, 1));
         goto finish;
      }
d105 4
a108 18
      if (log2_bpp < 3)
         if ((error = xwimp_read_true_palette ((os_palette *) &palette)) !=
               NULL)
            goto finish;

      /*Fix MED-4786: use the right entries for palettes < 16 entries. J R C
         6th Mar 1995*/
      switch (log2_bpp)
      {  case 0:
            palette.entries [1] = palette.entries [7];
         break;

         case 1:
            palette.entries [1] = palette.entries [2];
            palette.entries [2] = palette.entries [4];
            palette.entries [3] = palette.entries [7];
         break;
      }
d110 24
a133 11
      if ((error = xcolourtrans_select_table (header->mode, log2_bpp < 3?
            (os_palette *) &palette: (os_palette *) -1,
            colourtrans_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
            (osspriteop_trans_tab *) &trans_tab)) != NULL)
         goto finish;
   }

   if ((error = xosspriteop_put_sprite_trfm (osspriteop_PTR,
         osspriteop_UNSPECIFIED, (osspriteop_id) header, NONE, NULL,
         os_ACTION_USE_MASK, trfm, (osspriteop_trans_tab *) &trans_tab)) !=
         NULL)
d135 7
d144 1
a144 1
   return error;
d147 1
a147 1
static os_error *Text_System (char *text, os_colour fill, os_trfm *trfm)
d149 2
a150 2
   /*Create a sprite, clear it to the text colour, and write the character
      into the mask.*/
d152 46
a197 7
{  typedef
      struct
      {  osspriteop_area area;
         osspriteop_header header;
         os_colour_pair palette [2];
         bits image [8];
         bits mask [8];
d199 1
a199 1
      mode0_8x8_sprite;
d201 34
a234 2
   os_error *error = NULL;
   int len, r0, r1, r2, r3, i;
d236 3
a238 7
   mode0_8x8_sprite sprite =
   {  /*area*/
      {  /*size*/         sizeof sprite,
         /*sprite_count*/ 1,
         /*first*/        offsetof (mode0_8x8_sprite, header),
         /*free*/         sizeof sprite
      },
d240 3
a242 13
      /*header*/
      {  /*size*/         sizeof sprite.header + sizeof sprite.palette +
                                sizeof sprite.image + sizeof sprite.mask,
         /*name*/         "t",
         /*width*/        0 /*8 columns*/,
         /*height*/       7 /*8 rows*/,
         /*left_bit*/     0,
         /*right_bit*/    7,
         /*image*/        sizeof sprite.header + sizeof sprite.palette,
         /*mask*/         sizeof sprite.header + sizeof sprite.palette +
                                sizeof sprite.image,
         /*mode*/         0
      },
d244 5
a248 8
      /*palette*/
      {  {  /*on*/        SKIP,
            /*off*/       SKIP /*filled in with real colour*/
         },
         {  /*on*/        SKIP,
            /*off*/       SKIP /*never seen*/
         }
      },
d250 5
a254 2
      /*bitmap*/
      {0, 0, 0, 0, 0, 0, 0, 0},
d256 3
a258 52
      /*mask*/
      {-1, -1, -1, -1, -1, -1, -1, -1}
   };
   bool done_switch_output = FALSE;
   os_coord base = {16*draw_OS_UNIT, 0}, step;
   os_trfm char_trfm = *trfm;

   static char gcol0 [] = {os_VDU_SET_GCOL, os_ACTION_OVERWRITE, 0};

   tracef ("Text_System: trfm_dir\n");
   trfm_dir (&step, trfm, &base);

   len = strlen (text);

   /*Fill in the colour to be used.*/
   sprite.palette [0].on = sprite.palette [0].off = fill;

   for (i = 0; i < len; i++)
   {  tracef ("Text_System: osspriteop_switch_output_to_mask\n");
      if ((error = xosspriteop_switch_output_to_mask (osspriteop_PTR,
            &sprite.area, (osspriteop_id) &sprite.header, NULL,
            &r0, &r1, &r2, &r3)) != NULL)
         goto finish;
      done_switch_output = TRUE;

      tracef ("Text_System: os_writen\n");
      if ((error = xos_writen (gcol0, sizeof gcol0)) != NULL)
         goto finish;

      tracef ("Text_System: os_plot\n");
      if ((error = xos_plot (os_MOVE_TO, 0, 32)) != NULL)
         goto finish;

      tracef ("Text_System: os_writec\n");
      if ((error = xos_writec (text [i])) != NULL)
         goto finish;

      tracef ("Text_System: osspriteop_unswitch_output (0x%X, %d, %d, %d)\n"
            _ r0 _ r1 _ r2 _ r3);
      if ((error = xosspriteop_unswitch_output (r0, r1, r2, r3)) != NULL)
         goto finish;
      done_switch_output = FALSE;

      /*Now we can plot the sprite. We use the internal sprite renderer which
         makes a translation table.*/
      tracef ("Text_System: Sprite\n");
      if ((error = Sprite (&sprite.header, &char_trfm)) != NULL)
         goto finish;

      char_trfm.entries [2] [0] += step.x;
      char_trfm.entries [2] [1] += step.y;
   }
d261 8
a268 6
   if (done_switch_output)
   {  os_error *error1 = xosspriteop_unswitch_output (r0, r1, r2, r3);

      if (error == NULL) error = error1;
   }
   return error;
d271 1
a271 17
static os_error *Bbox (os_box *box, os_trfm *trfm)

{  os_error *error = NULL;
   os_coord u [4], t [4];
   int i;
   char set_dot_style [] = {os_VDU_MISC, os_MISC_SET_DOT_STYLE, 0xCC, 0,
         0xCC, 0, 0xCC, 0, 0xCC, 0};

   u [0].x = box->x0, u [0].y = box->y0;
   u [1].x = box->x1, u [1].y = box->y0;
   u [2].x = box->x1, u [2].y = box->y1;
   u [3].x = box->x0, u [3].y = box->y1;

   for (i = 0; i < 4; i++)
   {  trfm_point (&t [i], trfm, &u [i]);
      t [i].x /= draw_OS_UNIT, t [i].y /= draw_OS_UNIT;
   }
d273 32
a304 2
   if ((error = xcolourtrans_set_gcol (os_COLOUR_LIGHT_RED,
         colourtrans_SET_FG, os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
a306 11
   if ((error = xos_writen (set_dot_style, sizeof set_dot_style)) != NULL)
      goto finish;

   if ((error = xos_plot (os_MOVE_TO, t [3].x, t [3].y)) != NULL)
      goto finish;

   for (i = 0; i < 4; i++)
      if ((error = xos_plot (os_PLOT_TO | os_PLOT_DOTTED, t [i].x, t [i].y))
            != NULL)
         goto finish;

d308 1
a308 1
   return error;
d311 2
a312 2
os_error *render (bits flags, drawfile_diagram *diagram, int size,
      os_trfm *trfm, os_box *clip, int flatness)
d314 44
a357 15
{  os_error *error = NULL;
   drawfile_object *end, *o;
   drawfile_render_state state;
   os_box inv_clip;
   bool can_clip, unclaimed;

   tracef ("render\n");
   can_clip = clip != NULL && trfm_det (trfm) != 0;

   if (can_clip)
   {  /*Transform the clipping box given back to the coordinates it would
         have had in paper coordinates, and rebound it there.*/
      os_trfm inv;
      int i;
      os_box clip_draw;
d359 7
a365 30
      for (i = 0; i < 4; i++)
         (&clip_draw.x0) [i] = (&clip->x0) [i]*draw_OS_UNIT;

      trfm_inv (&inv, trfm);
      trfm_box (&inv_clip, &inv, &clip_draw);
   }

   state.diagram    = diagram;
   state.font_table = NULL;
   state.flags      = flags;
   state.trfm       = trfm;
   state.clip       = can_clip? &inv_clip: NULL;
   state.flatness   = (flags & drawfile_RENDER_GIVEN_FLATNESS) != NONE?
         flatness: DEFAULT_FLATNESS;
   state.error      = NULL;

   tracef ("render: despatching\n");
   end = (drawfile_object *) &((byte *) diagram) [size];
   for (o = diagram->objects; o < end; *(byte **) &o += o->size)
   {  state.object = o;
      if ((error = callback (main_render_callback, &state, &unclaimed, 1,
            o->type)) != NULL)
         goto finish;

      if (unclaimed && o->type >= 0x100)
      {  if ((error = xservice_draw_object_render (o->type, &state, NULL)) !=
               NULL)
            goto finish;
      }
   }
d368 1
a368 1
   return error != NULL? error: state.error;
d371 1
a371 1
os_error *render_font_table (void *null, void *s, bool *unclaimed)
d373 4
a376 2
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
d378 1
a378 1
   tracef ("render_font_table\n");
d380 2
a381 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_FONT_TABLE);
d383 1
a383 1
      null = null;
d386 2
a387 2
   /*Save the pointer.*/
   state->font_table = state->object;
d389 1
a389 1
   *unclaimed = FALSE;
d391 6
a396 5
/*finish:*/
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_font_table: \"%s\"\n" _ error->errmess);
   return NULL;
d399 1
a399 1
os_error *render_text_system (void *null, void *s, bool *unclaimed)
d401 6
a406 4
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
   os_trfm trfm, text_trfm;
   drawfile_text *text = &state->object->data AS text;
d408 1
a408 1
   tracef ("render_text_system\n");
d410 2
a411 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_TEXT);
d413 1
a413 1
      null = null;
d416 47
a462 2
   if (state->clip == NULL || verify_overlap (state->clip, &text->bbox))
   {  int len = strlen (text->text);
d464 2
a465 2
      if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
         (void) Bbox (&text->bbox, state->trfm);
d467 4
a470 38
      if (text->fill != os_COLOUR_TRANSPARENT &&
            (state->flags & drawfile_RENDER_SUPPRESS) == NONE && len > 0)
      {  /*If the text is REALLY in system font, we honour the baseline and
            size fields in the definition; otherwise, we simply scale system
            text to fit inside the bbox the font claims to have. This gives
            better results than Draw's treatment, since system text is
            usually much wider for a given nominal x size than an outline
            font.*/

         if (text->style.font_index == font_SYSTEM)
         {  /*Get the trfm needed to scale the text to paper coords.*/
            text_trfm.entries [0] [0] = text->xsize*((1 << 16)/
                  (16*draw_OS_UNIT));
            text_trfm.entries [0] [1] = 0;
            text_trfm.entries [1] [0] = 0;
            text_trfm.entries [1] [1] = text->ysize*((1 << 16)/
                  (32*draw_OS_UNIT));
            text_trfm.entries [2] [0] = text->base.x;
            text_trfm.entries [2] [1] = text->base.y - text->ysize/8;
         }
         else
         {  /*Which trfm takes the text into its bounding box?*/
            text_trfm.entries [0] [0] = (text->bbox.x1 - text->bbox.x0)*
                  ((1 << 16)/(16*draw_OS_UNIT))/len;
            text_trfm.entries [0] [1] = 0;
            text_trfm.entries [1] [0] = 0;
            text_trfm.entries [1] [1] = (text->bbox.y1 - text->bbox.y0)*
                  ((1 << 16)/(32*draw_OS_UNIT));
            text_trfm.entries [2] [0] = text->bbox.x0;
            text_trfm.entries [2] [1] = text->bbox.y0;
         }

         tracef ("render_text_system: trfm_mul\n");
         trfm_mul (&trfm, state->trfm, &text_trfm);

         if ((error = Text_System (text->text, text->fill, &trfm)) != NULL)
            goto finish;
   }  }
d472 1
a472 1
   *unclaimed = FALSE;
d475 5
a479 4
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_text_system: \"%s\"\n" _ error->errmess);
   return NULL;
d482 1
a482 1
os_error *render_text (void *null, void *s, bool *unclaimed)
d484 10
a493 8
{  drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
   os_error *error = NULL;
   drawfile_text *text = &state->object->data AS text;
   char *font_name;
   bool done_find_font = FALSE;
   font_f f;
   os_trfm trfm;
   os_coord base;
d495 1
a495 1
   tracef ("render_text\n");
d498 2
a499 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_TEXT);
d501 1
a501 1
      null = null;
d504 51
a554 49
   if (text->style.font_index != font_SYSTEM)
   {  if (state->clip == NULL || verify_overlap (state->clip, &text->bbox))
      {  if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
            (void) Bbox (&text->bbox, state->trfm);

         /*Get the font table pointer.*/
         font_name = verify_lookup_font_index (text->style.font_index,
               state->font_table);
            /*we know that |state->font_table| is not NULL and that
               |verify_lookup_font_index()| returns a value because of
               |verify()|.*/

         if (text->fill != os_COLOUR_TRANSPARENT &&
               (state->flags & drawfile_RENDER_SUPPRESS) == NONE)
         {  tracef ("finding font \"%s\", size (%d, %d)\n" _
                  font_name _ text->xsize/40 _
                  text->ysize/40);
            if ((error = xfont_find_font (font_name, text->xsize/40,
                  text->ysize/40, 0, 0, &f, NULL, NULL)) != NULL)
               goto finish;
            done_find_font = TRUE;

            tracef ("setting colours 0x%X, 0x%X\n" _
                  text->bg_hint _ text->fill);
            if ((error = xcolourtrans_set_font_colours (f,
                  text->bg_hint, text->fill, 14, NULL, NULL, NULL)) != NULL)
               goto finish;

            /*For bitmapped fonts, the font manager can't cope with
               translations in the matrix ... so move the translation part
               out of the matrix into the baseline origin.*/
            trfm = *state->trfm;
            trfm.entries [2] [0] = 0;
            trfm.entries [2] [1] = 0;

            trfm_point (&base, state->trfm, &text->base);

            /*Paint the text.*/
            tracef ("painting \"%s\" at (%d, %d) through ((%d, %d), "
                  "(%d, %d), (%d, %d))\n" _
                  text->text _ base.x _ base.y _
                  trfm.entries [0] [0] _ trfm.entries [0] [1] _
                  trfm.entries [1] [0] _ trfm.entries [1] [1] _
                  trfm.entries [2] [0] _ trfm.entries [2] [1]);
            if ((error = xfont_paint (f, text->text, font_OS_UNITS |
                  font_GIVEN_TRFM | font_GIVEN_FONT, base.x/draw_OS_UNIT,
                  base.y/draw_OS_UNIT, SKIP, &trfm, SKIP)) != NULL)
               goto finish;
         }
d556 1
d558 2
a559 2
      *unclaimed = FALSE;
   }
d562 12
a573 9
   if (done_find_font)
   {  os_error *error1 = xfont_lose_font (f);
      if (error == NULL) error = error1;
   }

   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_text: \"%s\"\n" _ error->errmess);
   return NULL;
d576 1
a576 1
os_error *render_path (void *null, void *s, bool *unclaimed)
d578 8
a585 6
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
   drawfile_path *path = &state->object->data AS path;
   draw_path *elements;
   draw_dash_pattern *pattern;
   draw_line_style line_style;
d587 1
a587 1
   tracef ("render_path\n");
d589 2
a590 2
   riscos_assert (null == NULL);
   riscos_assert (state->object->type == drawfile_TYPE_PATH);
d592 1
a592 1
   null = null;
d596 11
a606 10
   if (state->clip != NULL)
   {  tracef ("clipping rectangle given as ((%d, %d), (%d, %d))\n" _
            state->clip->x0 _ state->clip->y0 _
            state->clip->x1 _ state->clip->y1);
      tracef ("testing against bbox of ((%d, %d), (%d, %d))\n" _
            path->bbox.x0 _ path->bbox.y0 _
            path->bbox.x1 _ path->bbox.y1);
      tracef ("-> overlap %s\n" _ WHETHER (verify_overlap (state->clip,
            &path->bbox)));
   }
d609 86
a694 75
   if (state->clip == NULL || verify_overlap (state->clip, &path->bbox))
   {  if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
         (void) Bbox (&path->bbox, state->trfm);

   #if TRACE
   {  int i;
      tracef ("using style 0x");
      for (i = 0; i < sizeof (drawfile_path_style); i++)
         trace_f (NULL, 0, "%.2X" _
               ((byte *) &path->style) [i]);
      trace_f (NULL, 0, "\n");
   }
   #endif
      if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      {  /*Convert the drawfile_path_style into a draw_line_style.*/
         byte flags = path->style.flags;

         line_style.join_style = (flags & drawfile_PATH_JOIN) >>
               drawfile_PATH_JOIN_SHIFT;
         line_style.start_cap_style = (flags & drawfile_PATH_START) >>
               drawfile_PATH_START_SHIFT;
         line_style.end_cap_style = (flags & drawfile_PATH_END) >>
               drawfile_PATH_END_SHIFT;
         line_style.reserved = 0;
         line_style.mitre_limit = 10 << 16; /*Postscript default*/
         line_style.start_cap_width = line_style.end_cap_width =
               16*path->style.cap_width;
         line_style.start_cap_length = line_style.end_cap_length =
               16*path->style.cap_length;

         /*Get the draw_pattern.*/
         if ((flags & drawfile_PATH_DASHED) != NONE)
         {  pattern = &state->object->data AS path_with_pattern.pattern;
            elements = (draw_path *) ((byte *) pattern +
                  draw_SIZEOF_DASH_PATTERN (pattern->element_count));
         }
         else
         {  pattern = NULL;
            elements = &path->path;
         }

         if (path->fill != os_COLOUR_TRANSPARENT)
         {  if ((error = xcolourtrans_set_gcol (path->fill,
                  colourtrans_SET_FG | colourtrans_USE_ECFS,
                  os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
               goto finish;

            if ((error = xdraw_fill (elements, draw_FILL_FULL_INTERIOR |
                  draw_FILL_INTERIOR_BOUNDARY | ((flags &
                  drawfile_PATH_WINDING_EVEN_ODD) != NONE?
                  draw_FILL_EVEN_ODD: draw_FILL_NONZERO), state->trfm,
                  state->flatness)) != NULL)
               goto finish;
         }

         if (path->outline != os_COLOUR_TRANSPARENT)
         {  if ((error = xcolourtrans_set_gcol (path->outline,
                  colourtrans_SET_FG | colourtrans_USE_ECFS,
                  os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
               goto finish;

         #if TRACE
         {  int i;
            tracef ("using line_style 0x");
            for (i = 0; i < sizeof (draw_line_style); i++)
               trace_f (NULL, 0, "%.2X" _ ((byte *) &line_style) [i]);
            trace_f (NULL, 0, "\n");
         }
         #endif
            if ((error = xdraw_stroke (elements, draw_FILL_FULL_INTERIOR |
                  draw_FILL_INTERIOR_BOUNDARY | draw_FILL_EXTERIOR_BOUNDARY,
                  state->trfm, state->flatness, path->width, &line_style,
                  pattern)) != NULL)
               goto finish;
   }  }  }
d696 1
a696 1
   *unclaimed = FALSE;
d699 5
a703 4
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_path: \"%s\"\n" _ error->errmess);
   return NULL;
d706 1
a706 1
os_error *render_sprite (void *null, void *s, bool *unclaimed)
d708 8
a715 6
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
   drawfile_sprite *sprite = &state->object->data AS sprite;
   int xeig, yeig, width, height;
   bits flags1, flags2;
   os_trfm trfm, sprite_trfm;
d717 1
a717 1
   tracef ("render_sprite\n");
d719 2
a720 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_SPRITE);
d722 1
a722 1
      null = null;
d725 48
a772 44
   if (state->clip == NULL || verify_overlap (state->clip, &sprite->bbox))
   {  if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
         (void) Bbox (&sprite->bbox, state->trfm);

      if ((error = xosspriteop_read_sprite_size (osspriteop_PTR,
            osspriteop_UNSPECIFIED, (osspriteop_id) &state->object->data AS
            sprite.header, &width, &height, NULL, NULL)) != NULL)
         goto finish;

      if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE &&
            width > 0 && height > 0)
      {  if ((error = xos_read_mode_variable (sprite->header.mode,
               os_MODEVAR_XEIG_FACTOR, &xeig, &flags1)) != NULL)
            goto finish;

         if ((error = xos_read_mode_variable (sprite->header.mode,
               os_MODEVAR_YEIG_FACTOR, &yeig, &flags2)) != NULL)
            goto finish;

         if (((flags1 | flags2) & _C) != NONE)
         {  char s [DEC_WIDTH + 1];

            error = main_error_lookup (error_DRAW_FILE_BAD_MODE, "BadMode",
                  riscos_format_dec (s, (int) sprite->header.mode, 0, 1));
            goto finish;
         }

         /*Get the trfm needed to scale the sprite to paper coords.*/
         sprite_trfm.entries [0] [0] = muldiv (sprite->bbox.x1 -
               sprite->bbox.x0, 1 << 16, width*draw_OS_UNIT << xeig);
         sprite_trfm.entries [0] [1] = 0;
         sprite_trfm.entries [1] [0] = 0;
         sprite_trfm.entries [1] [1] = muldiv (sprite->bbox.y1 -
               sprite->bbox.y0, 1 << 16, height*draw_OS_UNIT << yeig);
         sprite_trfm.entries [2] [0] = sprite->bbox.x0;
         sprite_trfm.entries [2] [1] = sprite->bbox.y0;

         /*Multiply the matrix in the sprite by the given matrix to get the
            matrix to plot through.*/
         trfm_mul (&trfm, state->trfm, &sprite_trfm);

         if ((error = Sprite (&sprite->header, &trfm)) != NULL)
            goto finish;
   }  }
d774 1
a774 1
   *unclaimed = FALSE;
d777 5
a781 4
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_sprite: \"%s\"\n" _ error->errmess);
   return NULL;
d784 1
a784 1
os_error *render_group (void *null, void *s, bool *unclaimed)
d786 7
a792 5
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s /*save typing*/;
   drawfile_group *group = &state->object->data AS group;
   drawfile_object *o, *end;
   bool u;
d794 1
a794 1
   tracef ("render_group\n");
d796 2
a797 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_GROUP);
d799 1
a799 1
      null = null;
d802 23
a824 19
   if (state->clip == NULL || verify_overlap (state->clip, &group->bbox))
   {  if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
         (void) Bbox (&group->bbox, state->trfm);

      end = (drawfile_object *) &((byte *) state->object)
            [state->object->size];
      for (o = (drawfile_object *) &group->objects; o < end;
            *(byte **) &o += o->size)
      {  state->object = o;
         if ((error = callback (main_render_callback, state, &u, 1,
               o->type)) != NULL)
            goto finish;

         if (u && o->type >= 0x100)
         {  if ((error = xservice_draw_object_render (o->type, state, NULL))
                  != NULL)
               goto finish;
         }
   }  }
d826 1
a826 1
   *unclaimed = FALSE;
d829 5
a833 4
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_group: \"%s\"\n" _ error->errmess);
   return NULL;
d836 1
a836 1
os_error *render_tagged (void *null, void *s, bool *unclaimed)
d838 7
a844 5
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s /*save typing*/;
   drawfile_tagged *tagged = &state->object->data AS tagged;
   drawfile_object *o, *end;
   bool u;
d846 1
a846 1
   tracef ("render_tagged\n");
d848 2
a849 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_TAGGED);
d851 1
a851 1
      null = null;
d854 18
a871 11
   o = (drawfile_object *) &tagged->object;
   end = (drawfile_object *) &((byte *) state->object)
         [state->object->size];
   if ((drawfile_object *) &((byte *) o) [o->size] > end)
   {  error = main_error_lookup (error_DRAW_FILE_BAD_TAG, "BadTag");
      goto finish;
   }

   state->object = o;
   if ((error = callback (main_render_callback, state, &u, 1, o->type)) !=
         NULL)
d873 1
d875 1
a875 7
   if (u && o->type >= 0x100)
   {  if ((error = xservice_draw_object_render (o->type, state, NULL)) !=
            NULL)
         goto finish;
   }

   *unclaimed = FALSE;
d878 5
a882 4
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_tagged: \"%s\"\n" _ error->errmess);
   return NULL;
d885 1
a885 1
os_error *render_text_area (void *null, void *s, bool *unclaimed)
d887 5
a891 3
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
   drawfile_text_area *text_area = &state->object->data AS text_area;
d893 1
a893 1
   tracef ("render_text_area\n");
d895 2
a896 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_TEXT_AREA);
d898 1
a898 1
      null = null;
d901 10
a910 9
   if (state->clip == NULL || verify_overlap (state->clip, &text_area->bbox))
   {  if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
         (void) Bbox (&text_area->bbox, state->trfm);

      if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
         if ((error = textarea_render (state->object, state->trfm,
               state->clip, state->flags)) != NULL)
            goto finish;
   }
d912 1
a912 1
   *unclaimed = FALSE;
d915 5
a919 4
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_text_area: \"%s\"\n" _ error->errmess);
   return NULL;
d922 1
a922 1
os_error *render_trfm_text_system (void *null, void *s, bool *unclaimed)
d924 6
a929 4
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
   drawfile_trfm_text *trfm_text = &state->object->data AS trfm_text;
   os_trfm trfm, text_trfm;
d931 1
a931 1
   tracef ("render_trfm_text_system\n");
d933 2
a934 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_TRFM_TEXT);
d936 1
a936 1
      null = null;
d939 67
a1005 2
   if (state->clip == NULL || verify_overlap (state->clip, &trfm_text->bbox))
   {  int len = strlen (trfm_text->text);
d1007 2
a1008 2
      if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
         (void) Bbox (&trfm_text->bbox, state->trfm);
d1010 5
a1014 55
      if (trfm_text->fill != os_COLOUR_TRANSPARENT &&
            (state->flags & drawfile_RENDER_SUPPRESS) == NONE && len > 0)
      {  /*If the text is REALLY in system font, we honour the baseline,
            transformation and size fields in the definition; otherwise, we
            simply scale system text to fit inside the bbox the font claims
            to have, without making any attempt to apply the transformation.
            To scale the text to fit inside the bounding box WITH the
            transformation applied would involve solving a linear
            optimisation problem (for the font width) with eight
            constraints.*/

         if (trfm_text->style.font_index == font_SYSTEM)
         {  /*Get the trfm needed to scale the text to the coords it would
               have if it were a "real" font.*/
            os_trfm trfm1, trfm2;

            trfm1.entries [0] [0] = trfm_text->xsize*((1 << 16)/
                  (16*draw_OS_UNIT));
            trfm1.entries [0] [1] = 0;
            trfm1.entries [1] [0] = 0;
            trfm1.entries [1] [1] = trfm_text->ysize*((1 << 16)/
                  (32*draw_OS_UNIT));
            trfm1.entries [2] [0] = 0;
            trfm1.entries [2] [1] = -trfm_text->ysize/8;

            trfm_mul (&trfm2, &trfm_text->trfm, &trfm1);

            trfm1.entries [0] [0] = 1 << 16;
            trfm1.entries [0] [1] = 0;
            trfm1.entries [1] [0] = 0;
            trfm1.entries [1] [1] = 1 << 16;
            trfm1.entries [2] [0] = trfm_text->base.x;
            trfm1.entries [2] [1] = trfm_text->base.y;

            trfm_mul (&text_trfm, &trfm1, &trfm2);
         }
         else
         {  /*Which trfm takes the text into its bounding box?*/
            text_trfm.entries [0] [0] = (trfm_text->bbox.x1 -
                  trfm_text->bbox.x0)*((1 << 16)/(16*draw_OS_UNIT))/len;
            text_trfm.entries [0] [1] = 0;
            text_trfm.entries [1] [0] = 0;
            text_trfm.entries [1] [1] = (trfm_text->bbox.y1 -
                  trfm_text->bbox.y0)*((1 << 16)/(32*draw_OS_UNIT));
            text_trfm.entries [2] [0] = trfm_text->bbox.x0;
            text_trfm.entries [2] [1] = trfm_text->bbox.y0;
         }

         tracef ("render_trfm_text_system: trfm_mul\n");
         trfm_mul (&trfm, state->trfm, &text_trfm);

         if ((error = Text_System (trfm_text->text, trfm_text->fill, &trfm))
               != NULL)
            goto finish;
   }  }
d1016 1
a1016 1
   *unclaimed = FALSE;
d1019 5
a1023 4
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_trfm_text_system: \"%s\"\n" _ error->errmess);
   return NULL;
d1026 1
a1026 1
os_error *render_trfm_text (void *null, void *s, bool *unclaimed)
d1028 10
a1037 8
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
   drawfile_trfm_text *trfm_text = &state->object->data AS trfm_text;
   char *font_name;
   bool done_find_font = FALSE;
   font_f f;
   os_trfm trfm;
   os_coord base;
d1039 1
a1039 1
   tracef ("render_trfm_text\n");
d1041 2
a1042 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_TRFM_TEXT);
d1044 1
a1044 1
      null = null;
d1047 7
a1053 58
   if (trfm_text->style.font_index != font_SYSTEM)
   {  if (state->clip == NULL || verify_overlap (state->clip,
            &trfm_text->bbox))
      {  if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
            (void) Bbox (&trfm_text->bbox, state->trfm);

         /*Check the font table pointer.*/
         font_name = verify_lookup_font_index (trfm_text->style.font_index,
               state->font_table);
            /*we know that |state->font_table| is not NULL and that
               |verify_lookup_font_index()| returns a value because of
               |verify()|.*/

         if (trfm_text->fill != os_COLOUR_TRANSPARENT
               && (state->flags & drawfile_RENDER_SUPPRESS) == NONE)
         {  char tmp [3], *text;
            tracef ("finding font \"%s\", size (%d, %d)\n" _
                  font_name _ trfm_text->xsize/40 _ trfm_text->ysize/40);

            if ((error = xfont_find_font (font_name, trfm_text->xsize/40,
                  trfm_text->ysize/40, 0, 0, &f, NULL, NULL)) != NULL)
               goto finish;
            done_find_font = TRUE;

            tracef ("setting colours 0x%X, 0x%X\n" _
                  trfm_text->bg_hint _ trfm_text->fill);
            if ((error = xcolourtrans_set_font_colours (f,
                  trfm_text->bg_hint, trfm_text->fill, 14, NULL, NULL,
                  NULL)) != NULL)
               goto finish;

            /*Stupid Font_Paint wants OS Units in the matrix*/
            trfm_mul (&trfm, state->trfm, &trfm_text->trfm);
            trfm.entries [2] [0] /= draw_OS_UNIT;
            trfm.entries [2] [1] /= draw_OS_UNIT;

            trfm_point (&base, state->trfm, &trfm_text->base);

            /*Paint the text.*/
            text = trfm_text->text;
            if ((trfm_text->flags & drawfile_TEXT_UNDERLINE) != NONE)
            {  text -= 3;
               memcpy (tmp, text, 3);
               text [0] = font_COMMAND_UNDERLINE;
               text [1] = -25 + 0x100;
               text [2] = 15;
            }
            tracef ("painting \"%s\" at (%d, %d)\n" _ text _
                  trfm_text->base.x _ trfm_text->base.y);
            error = xfont_paint (f, text, font_OS_UNITS | font_GIVEN_TRFM |
                  font_GIVEN_FONT | ((trfm_text->flags & drawfile_TEXT_KERN)
                  != NONE? font_KERN: NONE) | ((trfm_text->flags &
                  drawfile_TEXT_RIGHT_TO_LEFT) != NONE? font_RIGHT_TO_LEFT:
                  NONE), base.x/draw_OS_UNIT, base.y/draw_OS_UNIT, SKIP,
                  &trfm, SKIP);
            if ((trfm_text->flags & drawfile_TEXT_UNDERLINE) != 0)
               memcpy (text, tmp, 3);
         }
d1055 54
a1108 1
         *unclaimed = FALSE;
d1110 4
a1113 1
   }
d1116 14
a1129 11
   if (done_find_font)
   {  os_error *error1 = xfont_lose_font (f);
      if (error == NULL) error = error1;
   }

   if (state->error == NULL) state->error = error;
   /*Claim this call if everything went o k. (If not,
      render_trfm_text_system() will have a go.)*/
   if (error != NULL)
      tracef ("render_trfm_text: \"%s\"\n" _ error->errmess);
   return NULL;
d1132 1
a1132 1
os_error *render_trfm_sprite (void *null, void *s, bool *unclaimed)
d1134 6
a1139 4
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
   drawfile_trfm_sprite *trfm_sprite = &state->object->data AS trfm_sprite;
   os_trfm trfm;
d1141 1
a1141 1
   tracef ("render_trfm_sprite\n");
d1143 2
a1144 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_TRFM_SPRITE);
d1146 1
a1146 1
      null = null;
d1149 17
a1165 13
   if (state->clip == NULL || verify_overlap (state->clip,
         &trfm_sprite->bbox))
   {  if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
         (void) Bbox (&trfm_sprite->bbox, state->trfm);

      if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      {  /*Multiply the matrix in the sprite by the given matrix to get the
            matrix  to plot through.*/
         trfm_mul (&trfm, state->trfm, &trfm_sprite->trfm);

         if ((error = Sprite (&trfm_sprite->header, &trfm)) != NULL)
            goto finish;
   }  }
d1167 1
a1167 1
   *unclaimed = FALSE;
d1170 5
a1174 4
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_trfm_sprite: \"%s\"\n" _ error->errmess);
   return NULL;
d1177 1
a1177 1
os_error *render_jpeg (void *null, void *s, bool *unclaimed)
d1179 6
a1184 4
{  os_error *error = NULL;
   drawfile_render_state *state = (drawfile_render_state *) s; /*save typing*/
   drawfile_jpeg *jpeg = &state->object->data AS jpeg;
   os_trfm trfm;
d1186 1
a1186 1
   tracef ("render_jpeg\n");
d1188 2
a1189 2
      riscos_assert (null == NULL);
      riscos_assert (state->object->type == drawfile_TYPE_JPEG);
d1191 1
a1191 1
      null = null;
d1194 17
a1210 13
   if (state->clip == NULL || verify_overlap (state->clip, &jpeg->bbox))
   {  if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
         (void) Bbox (&jpeg->bbox, state->trfm);

      if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      {  /*Multiply the matrix in the JPEG by the given matrix to get the
            matrix  to plot through.*/
         trfm_mul (&trfm, state->trfm, &jpeg->trfm);

         if ((error = xjpeg_plot_transformed (&jpeg->image,
               jpeg_TRANSFORM_DITHERED, &trfm, jpeg->len)) != NULL)
            goto finish;
   }  }
d1212 1
a1212 1
   *unclaimed = FALSE;
d1215 5
a1219 4
   if (state->error == NULL) state->error = error;
   if (error != NULL)
      tracef ("render_jpeg: \"%s\"\n" _ error->errmess);
   return NULL;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d15 1
a15 1
/*render.c - implementation file for drawdata_render */
d17 12
a28 8
   /* The error handling here is strange because we want to attempt
      to plot all of the draw file before giving up. So all the
      callbacks just store their error codes away, and return NULL.
      In other words, instead of taking the form

      os_error *fn (..., bool *u) {  os_error *error = NULL; ...

      finish: return error; }
d32 15
a46 4
      os_error *fn (..., bool *u) {  os_error *error = NULL; ...

      finish: if (state->error == NULL) state->error = error; return
      NULL; }
d48 1
a48 8
      Also, the callback system is used as follows: the callback list 
      is scanned for each object. If a function renders it, it claims 
      the callback. If the callback is not claimed, a service call is 
      sent round. This system is also used internally: if a text
      object gives an error, it does not claim the callback, and the
      system-font renderer has a go. */

/*From CLib */
d54 1
a54 1
/*From OSLib */
d61 1
a61 1
/*From Support */
d68 1
a68 1
/*Local */
d76 2
a77 2
   /* The value '0' here (which allows the Draw module to use a
      default of its own choice) results in poor rendering. */
d80 1
a80 1
static os_error *Sprite(osspriteop_header * header, os_trfm * trfm)
d82 51
a132 22
{
  os_error *error = NULL;
  int entry_count;
  osspriteop_TRANS_TAB(256) trans_tab;

  entry_count = (header->image - sizeof(osspriteop_header)) /
      sizeof(os_colour_pair);

  if (entry_count > 0)
  {
    if ((error = xcolourtrans_select_table_for_sprite
         (osspriteop_UNSPECIFIED, (osspriteop_id) header,
          colourtrans_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
          (osspriteop_trans_tab *) & trans_tab, colourtrans_GIVEN_SPRITE))
        != NULL)
      goto finish;
  }
  else
  {                                    /* Sprite has no palette. */
    int log2_bpp;
    os_PALETTE(20) palette;
    bits flags;
d134 11
a144 2
    if ((error = xos_read_mode_variable(header->mode, os_MODEVAR_LOG2_BPP,
                                        &log2_bpp, &flags)) != NULL)
d147 5
a151 3
    if ((flags & _C) != NONE)
    {
      char s[DEC_WIDTH + 1];
d153 2
a154 4
      error = main_error_lookup(error_DRAW_FILE_BAD_MODE, "BadMode",
                              riscos_format_dec(s, (int) header->mode, 0, 1));
      goto finish;
    }
d156 9
a164 26
    if (log2_bpp < 3)
      if ((error = xwimp_read_true_palette((os_palette *) & palette)) !=
          NULL)
        goto finish;

/* Fix MED-4786: use the right entries for palettes < 16 entries. J R 
   C 6th Mar 1995 */
    switch (log2_bpp)
    {
    case 0:
      palette.entries[1] = palette.entries[7];
      break;

    case 1:
      palette.entries[1] = palette.entries[2];
      palette.entries[2] = palette.entries[4];
      palette.entries[3] = palette.entries[7];
      break;
    }

    if ((error = xcolourtrans_select_table(header->mode, log2_bpp < 3 ?
                                (os_palette *) & palette : (os_palette *) - 1,
                        colourtrans_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
                               (osspriteop_trans_tab *) & trans_tab)) != NULL)
      goto finish;
  }
d166 2
a167 5
  if ((error = xosspriteop_put_sprite_trfm(osspriteop_PTR,
                   osspriteop_UNSPECIFIED, (osspriteop_id) header, NONE, NULL,
           os_ACTION_USE_MASK, trfm, (osspriteop_trans_tab *) & trans_tab)) !=
      NULL)
    goto finish;
d169 7
a175 5
finish:
  return error;
}
/*------------------------------------------------------------------------*/
static os_error *Text_System(char *text, os_colour fill, os_trfm * trfm)
d177 13
a189 2
   /* Create a sprite, clear it to the text colour, and write the
      character into the mask. */
d191 7
a197 42
{
  typedef
  struct
  {
    osspriteop_area area;
    osspriteop_header header;
    os_colour_pair palette[2];
    bits image[8];
    bits mask[8];
  }
  mode0_8x8_sprite;

  os_error *error = NULL;
  int len, r0, r1, r2, r3, i;

  mode0_8x8_sprite sprite =
  {                                    /* area */
    { /* size */ sizeof sprite,
/* sprite_count */ 1,
/* first */ offsetof(mode0_8x8_sprite, header),
/* free */ sizeof sprite
    },

/* header */
    { /* size */ sizeof sprite.header + sizeof sprite.palette +
     sizeof sprite.image + sizeof sprite.mask,
/* name */ "t",
     /* width */ 0 /* 8 columns */ ,
     /* height */ 7 /* 8 rows */ ,
/* left_bit */ 0,
/* right_bit */ 7,
/* image */ sizeof sprite.header + sizeof sprite.palette,
/* mask */ sizeof sprite.header + sizeof sprite.palette +
     sizeof sprite.image,
/* mode */ 0
    },

/* palette */
    {
      { /* on */ SKIP,
                                       /* off */ SKIP
                                       /* filled in with real colour */
a198 5
      { /* on */ SKIP,
                                       /* off */ SKIP
                                       /* never seen */
      }
    },
d200 55
a254 2
/* bitmap */
    {0, 0, 0, 0, 0, 0, 0, 0},
d256 3
a258 27
/* mask */
    {-1, -1, -1, -1, -1, -1, -1, -1}
  };
  bool done_switch_output = FALSE;
  os_coord base =
  {16 * draw_OS_UNIT, 0}, step;
  os_trfm char_trfm = *trfm;

  static char gcol0[] =
  {os_VDU_SET_GCOL, os_ACTION_OVERWRITE, 0};

  tracef("Text_System: trfm_dir\n");
  trfm_dir(&step, trfm, &base);

  len = strlen(text);

/* Fill in the colour to be used. */
  sprite.palette[0].on = sprite.palette[0].off = fill;

  for (i = 0; i < len; i++)
  {
    tracef("Text_System: osspriteop_switch_output_to_mask\n");
    if ((error = xosspriteop_switch_output_to_mask(osspriteop_PTR,
                          &sprite.area, (osspriteop_id) & sprite.header, NULL,
                                                 &r0, &r1, &r2, &r3)) != NULL)
      goto finish;
    done_switch_output = TRUE;
d260 6
a265 3
    tracef("Text_System: os_writen\n");
    if ((error = xos_writen(gcol0, sizeof gcol0)) != NULL)
      goto finish;
d267 15
a281 3
    tracef("Text_System: os_plot\n");
    if ((error = xos_plot(os_MOVE_TO, 0, 32)) != NULL)
      goto finish;
d283 2
a284 2
    tracef("Text_System: os_writec\n");
    if ((error = xos_writec(text[i])) != NULL)
d287 1
a287 3
    tracef("Text_System: osspriteop_unswitch_output (0x%X, %d, %d, %d)\n"
           _ r0 _ r1 _ r2 _ r3);
    if ((error = xosspriteop_unswitch_output(r0, r1, r2, r3)) != NULL)
a288 1
    done_switch_output = FALSE;
d290 1
a290 4
/* Now we can plot the sprite. We use the internal sprite renderer
   which makes a translation table. */
    tracef("Text_System: Sprite\n");
    if ((error = Sprite(&sprite.header, &char_trfm)) != NULL)
d293 4
a296 3
    char_trfm.entries[2][0] += step.x;
    char_trfm.entries[2][1] += step.y;
  }
d299 1
a299 8
  if (done_switch_output)
  {
    os_error *error1 = xosspriteop_unswitch_output(r0, r1, r2, r3);

    if (error == NULL)
      error = error1;
  }
  return error;
d302 2
a303 1
static os_error *Bbox(os_box * box, os_trfm * trfm)
d305 15
a319 33
{
  os_error *error = NULL;
  os_coord u[4], t[4];
  int i;
  char set_dot_style[] =
  {os_VDU_MISC, os_MISC_SET_DOT_STYLE, 0xCC, 0,
   0xCC, 0, 0xCC, 0, 0xCC, 0};

  u[0].x = box->x0, u[0].y = box->y0;
  u[1].x = box->x1, u[1].y = box->y0;
  u[2].x = box->x1, u[2].y = box->y1;
  u[3].x = box->x0, u[3].y = box->y1;

  for (i = 0; i < 4; i++)
  {
    trfm_point(&t[i], trfm, &u[i]);
    t[i].x /= draw_OS_UNIT, t[i].y /= draw_OS_UNIT;
  }

  if ((error = xcolourtrans_set_gcol(os_COLOUR_LIGHT_RED,
                colourtrans_SET_FG, os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
    goto finish;

  if ((error = xos_writen(set_dot_style, sizeof set_dot_style)) != NULL)
    goto finish;

  if ((error = xos_plot(os_MOVE_TO, t[3].x, t[3].y)) != NULL)
    goto finish;

  for (i = 0; i < 4; i++)
    if ((error = xos_plot(os_PLOT_TO | os_PLOT_DOTTED, t[i].x, t[i].y))
        != NULL)
      goto finish;
d321 2
a322 6
finish:
  return error;
}
/*------------------------------------------------------------------------*/
os_error *render(bits flags, drawfile_diagram * diagram, int size,
                 os_trfm * trfm, os_box * clip, int flatness)
d324 27
a350 52
{
  os_error *error = NULL;
  drawfile_object *end, *o;
  drawfile_render_state state;
  os_box inv_clip;
  bool can_clip, unclaimed;

  tracef("render\n");
  can_clip = clip != NULL && trfm_det(trfm) != 0;

  if (can_clip)
  {                                    /* Transform the clipping box
                                          given back to the
                                          coordinates it would have
                                          had in paper coordinates,
                                          and rebound it there. */
    os_trfm inv;
    int i;
    os_box clip_draw;

    for (i = 0; i < 4; i++)
      (&clip_draw.x0)[i] = (&clip->x0)[i] * draw_OS_UNIT;

    trfm_inv(&inv, trfm);
    trfm_box(&inv_clip, &inv, &clip_draw);
  }

  state.diagram = diagram;
  state.font_table = NULL;
  state.flags = flags;
  state.trfm = trfm;
  state.clip = can_clip ? &inv_clip : NULL;
  state.flatness = (flags & drawfile_RENDER_GIVEN_FLATNESS) != NONE ?
      flatness : DEFAULT_FLATNESS;
  state.error = NULL;

  tracef("render: despatching\n");
  end = (drawfile_object *) & ((byte *) diagram)[size];
  for (o = diagram->objects; o < end; *(byte **) & o += o->size)
  {
    state.object = o;
    if ((error = callback(main_render_callback, &state, &unclaimed, 1,
                          o->type)) != NULL)
      goto finish;

    if (unclaimed && o->type >= 0x100)
    {
      if ((error = xservice_draw_object_render(o->type, &state, NULL)) !=
          NULL)
        goto finish;
    }
  }
d353 1
a353 1
  return error != NULL ? error : state.error;
d356 1
a356 1
os_error *render_font_table(void *null, void *s, bool * unclaimed)
d358 2
a359 4
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
d361 1
a361 1
  tracef("render_font_table\n");
d363 2
a364 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_FONT_TABLE);
d366 1
a366 1
  null = null;
d369 2
a370 2
/* Save the pointer. */
  state->font_table = state->object;
d372 1
a372 1
  *unclaimed = FALSE;
d374 5
a378 6
/*finish: */
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_font_table: \"%s\"\n" _ error->errmess);
  return NULL;
d381 1
a381 1
os_error *render_text_system(void *null, void *s, bool * unclaimed)
d383 4
a386 6
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  os_trfm trfm, text_trfm;
  drawfile_text *text = &state->object->data AS text;
d388 1
a388 1
  tracef("render_text_system\n");
d390 2
a391 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TEXT);
d393 1
a393 1
  null = null;
d396 2
a397 47
  if (state->clip == NULL || verify_overlap(state->clip, &text->bbox))
  {
    int len = strlen(text->text);

    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&text->bbox, state->trfm);

    if (text->fill != os_COLOUR_TRANSPARENT &&
        (state->flags & drawfile_RENDER_SUPPRESS) == NONE && len > 0)
    {                                  /* If the text is REALLY in
                                          system font, we honour the
                                          baseline and size fields in 
                                          the definition; otherwise,
                                          we simply scale system text 
                                          to fit inside the bbox the
                                          font claims to have. This
                                          gives better results than
                                          Draw's treatment, since
                                          system text is usually much 
                                          wider for a given nominal x 
                                          size than an outline font. */

      if (text->style.font_index == font_SYSTEM)
      {                                /* Get the trfm needed to
                                          scale the text to paper
                                          coords. */
        text_trfm.entries[0][0] = text->xsize * ((1 << 16) /
                                                 (16 * draw_OS_UNIT));
        text_trfm.entries[0][1] = 0;
        text_trfm.entries[1][0] = 0;
        text_trfm.entries[1][1] = text->ysize * ((1 << 16) /
                                                 (32 * draw_OS_UNIT));
        text_trfm.entries[2][0] = text->base.x;
        text_trfm.entries[2][1] = text->base.y - text->ysize / 8;
      }
      else
      {                                /* Which trfm takes the text
                                          into its bounding box? */
        text_trfm.entries[0][0] = (text->bbox.x1 - text->bbox.x0) *
            ((1 << 16) / (16 * draw_OS_UNIT)) / len;
        text_trfm.entries[0][1] = 0;
        text_trfm.entries[1][0] = 0;
        text_trfm.entries[1][1] = (text->bbox.y1 - text->bbox.y0) *
            ((1 << 16) / (32 * draw_OS_UNIT));
        text_trfm.entries[2][0] = text->bbox.x0;
        text_trfm.entries[2][1] = text->bbox.y0;
      }
d399 2
a400 2
      tracef("render_text_system: trfm_mul\n");
      trfm_mul(&trfm, state->trfm, &text_trfm);
d402 38
a439 4
      if ((error = Text_System(text->text, text->fill, &trfm)) != NULL)
        goto finish;
    }
  }
d441 1
a441 1
  *unclaimed = FALSE;
d444 4
a447 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_text_system: \"%s\"\n" _ error->errmess);
  return NULL;
d450 1
a450 1
os_error *render_text(void *null, void *s, bool * unclaimed)
d452 8
a459 10
{
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  os_error *error = NULL;
  drawfile_text *text = &state->object->data AS text;
  char *font_name;
  bool done_find_font = FALSE;
  font_f f;
  os_trfm trfm;
  os_coord base;
d461 1
a461 1
  tracef("render_text\n");
d464 2
a465 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TEXT);
d467 1
a467 1
  null = null;
d470 49
a518 51
  if (text->style.font_index != font_SYSTEM)
  {
    if (state->clip == NULL || verify_overlap(state->clip, &text->bbox))
    {
      if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
        (void) Bbox(&text->bbox, state->trfm);

/* Get the font table pointer. */
      font_name = verify_lookup_font_index(text->style.font_index,
                                           state->font_table);
/* we know that |state->font_table| is not NULL and that
   |verify_lookup_font_index()| returns a value because of
   |verify()|. */

      if (text->fill != os_COLOUR_TRANSPARENT &&
          (state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      {
        tracef("finding font \"%s\", size (%d, %d)\n" _
               font_name _ text->xsize / 40 _
               text->ysize / 40);
        if ((error = xfont_find_font(font_name, text->xsize / 40,
                             text->ysize / 40, 0, 0, &f, NULL, NULL)) != NULL)
          goto finish;
        done_find_font = TRUE;

        tracef("setting colours 0x%X, 0x%X\n" _
               text->bg_hint _ text->fill);
        if ((error = xcolourtrans_set_font_colours(f,
                    text->bg_hint, text->fill, 14, NULL, NULL, NULL)) != NULL)
          goto finish;

/* For bitmapped fonts, the font manager can't cope with translations 
   in the matrix ... so move the translation part out of the matrix
   into the baseline origin. */
        trfm = *state->trfm;
        trfm.entries[2][0] = 0;
        trfm.entries[2][1] = 0;

        trfm_point(&base, state->trfm, &text->base);

/* Paint the text. */
        tracef("painting \"%s\" at (%d, %d) through ((%d, %d), "
               "(%d, %d), (%d, %d))\n" _
               text->text _ base.x _ base.y _
               trfm.entries[0][0] _ trfm.entries[0][1] _
               trfm.entries[1][0] _ trfm.entries[1][1] _
               trfm.entries[2][0] _ trfm.entries[2][1]);
        if ((error = xfont_paint(f, text->text, font_OS_UNITS |
                     font_GIVEN_TRFM | font_GIVEN_FONT | (state->flags & font_BLEND_FONT), base.x / draw_OS_UNIT,
                           base.y / draw_OS_UNIT, SKIP, &trfm, SKIP)) != NULL)
          goto finish;
a519 1
    }
d521 2
a522 2
    *unclaimed = FALSE;
  }
d525 9
a533 12
  if (done_find_font)
  {
    os_error *error1 = xfont_lose_font(f);
    if (error == NULL)
      error = error1;
  }

  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_text: \"%s\"\n" _ error->errmess);
  return NULL;
d536 1
a536 1
os_error *render_path(void *null, void *s, bool * unclaimed)
d538 6
a543 8
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_path *path = &state->object->data AS path;
  draw_path *elements;
  draw_dash_pattern *pattern;
  draw_line_style line_style;
d545 1
a545 1
  tracef("render_path\n");
d547 2
a548 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_PATH);
d550 1
a550 1
  null = null;
d554 10
a563 11
  if (state->clip != NULL)
  {
    tracef("clipping rectangle given as ((%d, %d), (%d, %d))\n" _
           state->clip->x0 _ state->clip->y0 _
           state->clip->x1 _ state->clip->y1);
    tracef("testing against bbox of ((%d, %d), (%d, %d))\n" _
           path->bbox.x0 _ path->bbox.y0 _
           path->bbox.x1 _ path->bbox.y1);
    tracef("-> overlap %s\n" _ WHETHER(verify_overlap(state->clip,
                                                      &path->bbox)));
  }
d566 75
a640 4
  if (state->clip == NULL || verify_overlap(state->clip, &path->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&path->bbox, state->trfm);
d642 1
a642 83
     #if TRACE
    {
      int i;
      tracef("using style 0x");
      for (i = 0; i < sizeof(drawfile_path_style); i++)
        trace_f(NULL, 0, "%.2X" _
                ((byte *) & path->style)[i]);
      trace_f(NULL, 0, "\n");
    }
     #endif
    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
    {                                  /* Convert the
                                          drawfile_path_style into a
                                          draw_line_style. */
      byte flags = path->style.flags;

      line_style.join_style = (flags & drawfile_PATH_JOIN) >>
          drawfile_PATH_JOIN_SHIFT;
      line_style.start_cap_style = (flags & drawfile_PATH_START) >>
          drawfile_PATH_START_SHIFT;
      line_style.end_cap_style = (flags & drawfile_PATH_END) >>
          drawfile_PATH_END_SHIFT;
      line_style.reserved = 0;
      line_style.mitre_limit = 10 << 16;  /* Postscript default */
      line_style.start_cap_width = line_style.end_cap_width =
          16 * path->style.cap_width;
      line_style.start_cap_length = line_style.end_cap_length =
          16 * path->style.cap_length;

/* Get the draw_pattern. */
      if ((flags & drawfile_PATH_DASHED) != NONE)
      {
        pattern = &state->object->data AS path_with_pattern.pattern;
        elements = (draw_path *) ((byte *) pattern +
                            draw_SIZEOF_DASH_PATTERN(pattern->element_count));
      }
      else
      {
        pattern = NULL;
        elements = &path->path;
      }

      if (path->fill != os_COLOUR_TRANSPARENT)
      {
        if ((error = xcolourtrans_set_gcol(path->fill,
                                    colourtrans_SET_FG | colourtrans_USE_ECFS,
                                    os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
          goto finish;

        if ((error = xdraw_fill(elements, draw_FILL_FULL_INTERIOR |
                                draw_FILL_INTERIOR_BOUNDARY | ((flags &
                                     drawfile_PATH_WINDING_EVEN_ODD) != NONE ?
                         draw_FILL_EVEN_ODD : draw_FILL_NONZERO), state->trfm,
                                state->flatness)) != NULL)
          goto finish;
      }

      if (path->outline != os_COLOUR_TRANSPARENT)
      {
        if ((error = xcolourtrans_set_gcol(path->outline,
                                    colourtrans_SET_FG | colourtrans_USE_ECFS,
                                    os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
          goto finish;

               #if TRACE
        {
          int i;
          tracef("using line_style 0x");
          for (i = 0; i < sizeof(draw_line_style); i++)
            trace_f(NULL, 0, "%.2X" _((byte *) & line_style)[i]);
          trace_f(NULL, 0, "\n");
        }
               #endif
        if ((error = xdraw_stroke(elements, draw_FILL_FULL_INTERIOR |
                    draw_FILL_INTERIOR_BOUNDARY | draw_FILL_EXTERIOR_BOUNDARY,
                       state->trfm, state->flatness, path->width, &line_style,
                                  pattern)) != NULL)
          goto finish;
      }
    }
  }

  *unclaimed = FALSE;
d645 4
a648 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_path: \"%s\"\n" _ error->errmess);
  return NULL;
d651 1
a651 1
os_error *render_sprite(void *null, void *s, bool * unclaimed)
d653 6
a658 8
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_sprite *sprite = &state->object->data AS sprite;
  int xeig, yeig, width, height;
  bits flags1, flags2;
  os_trfm trfm, sprite_trfm;
d660 1
a660 1
  tracef("render_sprite\n");
d662 2
a663 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_SPRITE);
d665 1
a665 1
  null = null;
d668 44
a711 48
  if (state->clip == NULL || verify_overlap(state->clip, &sprite->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&sprite->bbox, state->trfm);

    if ((error = xosspriteop_read_sprite_size(osspriteop_PTR,
              osspriteop_UNSPECIFIED, (osspriteop_id) & state->object->data AS
                         sprite.header, &width, &height, NULL, NULL)) != NULL)
      goto finish;

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE &&
        width > 0 && height > 0)
    {
      if ((error = xos_read_mode_variable(sprite->header.mode,
                             os_MODEVAR_XEIG_FACTOR, &xeig, &flags1)) != NULL)
        goto finish;

      if ((error = xos_read_mode_variable(sprite->header.mode,
                             os_MODEVAR_YEIG_FACTOR, &yeig, &flags2)) != NULL)
        goto finish;

      if (((flags1 | flags2) & _C) != NONE)
      {
        char s[DEC_WIDTH + 1];

        error = main_error_lookup(error_DRAW_FILE_BAD_MODE, "BadMode",
                       riscos_format_dec(s, (int) sprite->header.mode, 0, 1));
        goto finish;
      }

/* Get the trfm needed to scale the sprite to paper coords. */
      sprite_trfm.entries[0][0] = muldiv(sprite->bbox.x1 -
                      sprite->bbox.x0, 1 << 16, width * draw_OS_UNIT << xeig);
      sprite_trfm.entries[0][1] = 0;
      sprite_trfm.entries[1][0] = 0;
      sprite_trfm.entries[1][1] = muldiv(sprite->bbox.y1 -
                     sprite->bbox.y0, 1 << 16, height * draw_OS_UNIT << yeig);
      sprite_trfm.entries[2][0] = sprite->bbox.x0;
      sprite_trfm.entries[2][1] = sprite->bbox.y0;

/* Multiply the matrix in the sprite by the given matrix to get the
   matrix to plot through. */
      trfm_mul(&trfm, state->trfm, &sprite_trfm);

      if ((error = Sprite(&sprite->header, &trfm)) != NULL)
        goto finish;
    }
  }
d713 1
a713 1
  *unclaimed = FALSE;
d716 4
a719 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_sprite: \"%s\"\n" _ error->errmess);
  return NULL;
d722 1
a722 1
os_error *render_group(void *null, void *s, bool * unclaimed)
d724 5
a728 7
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s  /* save 
                                                                 typing */ ;
  drawfile_group *group = &state->object->data AS group;
  drawfile_object *o, *end;
  bool u;
d730 1
a730 1
  tracef("render_group\n");
d732 2
a733 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_GROUP);
d735 1
a735 1
  null = null;
d738 19
a756 23
  if (state->clip == NULL || verify_overlap(state->clip, &group->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&group->bbox, state->trfm);

    end = (drawfile_object *) & ((byte *) state->object)
        [state->object->size];
    for (o = (drawfile_object *) & group->objects; o < end;
         *(byte **) & o += o->size)
    {
      state->object = o;
      if ((error = callback(main_render_callback, state, &u, 1,
                            o->type)) != NULL)
        goto finish;

      if (u && o->type >= 0x100)
      {
        if ((error = xservice_draw_object_render(o->type, state, NULL))
            != NULL)
          goto finish;
      }
    }
  }
d758 1
a758 1
  *unclaimed = FALSE;
d761 4
a764 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_group: \"%s\"\n" _ error->errmess);
  return NULL;
d767 1
a767 1
os_error *render_tagged(void *null, void *s, bool * unclaimed)
d769 5
a773 7
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s  /* save 
                                                                 typing */ ;
  drawfile_tagged *tagged = &state->object->data AS tagged;
  drawfile_object *o, *end;
  bool u;
d775 1
a775 1
  tracef("render_tagged\n");
d777 2
a778 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TAGGED);
d780 1
a780 1
  null = null;
d783 11
a793 18
  o = (drawfile_object *) & tagged->object;
  end = (drawfile_object *) & ((byte *) state->object)
      [state->object->size];
  if ((drawfile_object *) & ((byte *) o)[o->size] > end)
  {
    error = main_error_lookup(error_DRAW_FILE_BAD_TAG, "BadTag");
    goto finish;
  }

  state->object = o;
  if ((error = callback(main_render_callback, state, &u, 1, o->type)) !=
      NULL)
    goto finish;

  if (u && o->type >= 0x100)
  {
    if ((error = xservice_draw_object_render(o->type, state, NULL)) !=
        NULL)
a794 1
  }
d796 7
a802 1
  *unclaimed = FALSE;
d805 4
a808 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_tagged: \"%s\"\n" _ error->errmess);
  return NULL;
d811 1
a811 1
os_error *render_text_area(void *null, void *s, bool * unclaimed)
d813 3
a815 5
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_text_area *text_area = &state->object->data AS text_area;
d817 1
a817 1
  tracef("render_text_area\n");
d819 2
a820 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TEXT_AREA);
d822 1
a822 1
  null = null;
d825 9
a833 10
  if (state->clip == NULL || verify_overlap(state->clip, &text_area->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&text_area->bbox, state->trfm);

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      if ((error = textarea_render(state->object, state->trfm,
                                   state->clip, state->flags)) != NULL)
        goto finish;
  }
d835 1
a835 1
  *unclaimed = FALSE;
d838 4
a841 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_text_area: \"%s\"\n" _ error->errmess);
  return NULL;
d844 1
a844 1
os_error *render_trfm_text_system(void *null, void *s, bool * unclaimed)
d846 4
a849 6
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_trfm_text *trfm_text = &state->object->data AS trfm_text;
  os_trfm trfm, text_trfm;
d851 1
a851 1
  tracef("render_trfm_text_system\n");
d853 2
a854 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TRFM_TEXT);
d856 1
a856 1
  null = null;
d859 2
a860 52
  if (state->clip == NULL || verify_overlap(state->clip, &trfm_text->bbox))
  {
    int len = strlen(trfm_text->text);

    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&trfm_text->bbox, state->trfm);

    if (trfm_text->fill != os_COLOUR_TRANSPARENT &&
        (state->flags & drawfile_RENDER_SUPPRESS) == NONE && len > 0)
    {                                  /* If the text is REALLY in
                                          system font, we honour the
                                          baseline, transformation
                                          and size fields in the
                                          definition; otherwise, we
                                          simply scale system text to 
                                          fit inside the bbox the
                                          font claims to have,
                                          without making any attempt
                                          to apply the
                                          transformation. To scale
                                          the text to fit inside the
                                          bounding box WITH the
                                          transformation applied
                                          would involve solving a
                                          linear optimisation problem 
                                          (for the font width) with
                                          eight constraints. */

      if (trfm_text->style.font_index == font_SYSTEM)
      {                                /* Get the trfm needed to
                                          scale the text to the
                                          coords it would have if it
                                          were a "real" font. */
        os_trfm trfm1, trfm2;

        trfm1.entries[0][0] = trfm_text->xsize * ((1 << 16) /
                                                  (16 * draw_OS_UNIT));
        trfm1.entries[0][1] = 0;
        trfm1.entries[1][0] = 0;
        trfm1.entries[1][1] = trfm_text->ysize * ((1 << 16) /
                                                  (32 * draw_OS_UNIT));
        trfm1.entries[2][0] = 0;
        trfm1.entries[2][1] = -trfm_text->ysize / 8;

        trfm_mul(&trfm2, &trfm_text->trfm, &trfm1);

        trfm1.entries[0][0] = 1 << 16;
        trfm1.entries[0][1] = 0;
        trfm1.entries[1][0] = 0;
        trfm1.entries[1][1] = 1 << 16;
        trfm1.entries[2][0] = trfm_text->base.x;
        trfm1.entries[2][1] = trfm_text->base.y;
d862 2
a863 14
        trfm_mul(&text_trfm, &trfm1, &trfm2);
      }
      else
      {                                /* Which trfm takes the text
                                          into its bounding box? */
        text_trfm.entries[0][0] = (trfm_text->bbox.x1 -
                trfm_text->bbox.x0) * ((1 << 16) / (16 * draw_OS_UNIT)) / len;
        text_trfm.entries[0][1] = 0;
        text_trfm.entries[1][0] = 0;
        text_trfm.entries[1][1] = (trfm_text->bbox.y1 -
                      trfm_text->bbox.y0) * ((1 << 16) / (32 * draw_OS_UNIT));
        text_trfm.entries[2][0] = trfm_text->bbox.x0;
        text_trfm.entries[2][1] = trfm_text->bbox.y0;
      }
d865 55
a919 2
      tracef("render_trfm_text_system: trfm_mul\n");
      trfm_mul(&trfm, state->trfm, &text_trfm);
d921 1
a921 7
      if ((error = Text_System(trfm_text->text, trfm_text->fill, &trfm))
          != NULL)
        goto finish;
    }
  }

  *unclaimed = FALSE;
d924 4
a927 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_trfm_text_system: \"%s\"\n" _ error->errmess);
  return NULL;
d930 1
a930 1
os_error *render_trfm_text(void *null, void *s, bool * unclaimed)
d932 8
a939 10
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_trfm_text *trfm_text = &state->object->data AS trfm_text;
  char *font_name;
  bool done_find_font = FALSE;
  font_f f;
  os_trfm trfm;
  os_coord base;
d941 1
a941 1
  tracef("render_trfm_text\n");
d943 2
a944 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TRFM_TEXT);
d946 1
a946 1
  null = null;
d949 58
a1006 7
  if (trfm_text->style.font_index != font_SYSTEM)
  {
    if (state->clip == NULL || verify_overlap(state->clip,
                                              &trfm_text->bbox))
    {
      if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
        (void) Bbox(&trfm_text->bbox, state->trfm);
d1008 1
a1008 54
/* Check the font table pointer. */
      font_name = verify_lookup_font_index(trfm_text->style.font_index,
                                           state->font_table);
/* we know that |state->font_table| is not NULL and that
   |verify_lookup_font_index()| returns a value because of
   |verify()|. */

      if (trfm_text->fill != os_COLOUR_TRANSPARENT
          && (state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      {
        char tmp[3], *text;
        tracef("finding font \"%s\", size (%d, %d)\n" _
               font_name _ trfm_text->xsize / 40 _ trfm_text->ysize / 40);

        if ((error = xfont_find_font(font_name, trfm_text->xsize / 40,
                        trfm_text->ysize / 40, 0, 0, &f, NULL, NULL)) != NULL)
          goto finish;
        done_find_font = TRUE;

        tracef("setting colours 0x%X, 0x%X\n" _
               trfm_text->bg_hint _ trfm_text->fill);
        if ((error = xcolourtrans_set_font_colours(f,
                          trfm_text->bg_hint, trfm_text->fill, 14, NULL, NULL,
                                                   NULL)) != NULL)
          goto finish;

/* Stupid Font_Paint wants OS Units in the matrix */
        trfm_mul(&trfm, state->trfm, &trfm_text->trfm);
        trfm.entries[2][0] /= draw_OS_UNIT;
        trfm.entries[2][1] /= draw_OS_UNIT;

        trfm_point(&base, state->trfm, &trfm_text->base);

/* Paint the text. */
        text = trfm_text->text;
        if ((trfm_text->flags & drawfile_TEXT_UNDERLINE) != NONE)
        {
          text -= 3;
          memcpy(tmp, text, 3);
          text[0] = font_COMMAND_UNDERLINE;
          text[1] = -25 + 0x100;
          text[2] = 15;
        }
        tracef("painting \"%s\" at (%d, %d)\n" _ text _
               trfm_text->base.x _ trfm_text->base.y);
        error = xfont_paint(f, text, font_OS_UNITS | font_GIVEN_TRFM |
                    font_GIVEN_FONT | (state->flags & font_BLEND_FONT)
                    | ((trfm_text->flags & drawfile_TEXT_KERN)
                            != NONE ? font_KERN : NONE) | ((trfm_text->flags &
                   drawfile_TEXT_RIGHT_TO_LEFT) != NONE ? font_RIGHT_TO_LEFT :
                    NONE), base.x / draw_OS_UNIT, base.y / draw_OS_UNIT, SKIP,
                            &trfm, SKIP);
        if ((trfm_text->flags & drawfile_TEXT_UNDERLINE) != 0)
          memcpy(text, tmp, 3);
d1010 1
a1010 4

      *unclaimed = FALSE;
    }
  }
d1013 11
a1023 14
  if (done_find_font)
  {
    os_error *error1 = xfont_lose_font(f);
    if (error == NULL)
      error = error1;
  }

  if (state->error == NULL)
    state->error = error;
/* Claim this call if everything went o k. (If not,
   render_trfm_text_system() will have a go.) */
  if (error != NULL)
    tracef("render_trfm_text: \"%s\"\n" _ error->errmess);
  return NULL;
d1026 1
a1026 1
os_error *render_trfm_sprite(void *null, void *s, bool * unclaimed)
d1028 4
a1031 6
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_trfm_sprite *trfm_sprite = &state->object->data AS trfm_sprite;
  os_trfm trfm;
d1033 1
a1033 1
  tracef("render_trfm_sprite\n");
d1035 2
a1036 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TRFM_SPRITE);
d1038 1
a1038 1
  null = null;
d1041 13
a1053 17
  if (state->clip == NULL || verify_overlap(state->clip,
                                            &trfm_sprite->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&trfm_sprite->bbox, state->trfm);

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
    {                                  /* Multiply the matrix in the
                                          sprite by the given matrix
                                          to get the matrix  to plot
                                          through. */
      trfm_mul(&trfm, state->trfm, &trfm_sprite->trfm);

      if ((error = Sprite(&trfm_sprite->header, &trfm)) != NULL)
        goto finish;
    }
  }
d1055 1
a1055 1
  *unclaimed = FALSE;
d1058 4
a1061 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_trfm_sprite: \"%s\"\n" _ error->errmess);
  return NULL;
d1064 1
a1064 1
os_error *render_jpeg(void *null, void *s, bool * unclaimed)
d1066 4
a1069 6
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_jpeg *jpeg = &state->object->data AS jpeg;
  os_trfm trfm;
d1071 1
a1071 1
  tracef("render_jpeg\n");
d1073 2
a1074 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_JPEG);
d1076 1
a1076 1
  null = null;
d1079 13
a1091 17
  if (state->clip == NULL || verify_overlap(state->clip, &jpeg->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&jpeg->bbox, state->trfm);

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
    {                                  /* Multiply the matrix in the
                                          JPEG by the given matrix to 
                                          get the matrix  to plot
                                          through. */
      trfm_mul(&trfm, state->trfm, &jpeg->trfm);

      if ((error = xjpeg_plot_transformed(&jpeg->image,
                          jpeg_TRANSFORM_DITHERED, &trfm, jpeg->len)) != NULL)
        goto finish;
    }
  }
d1093 1
a1093 1
  *unclaimed = FALSE;
d1096 4
a1099 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_jpeg: \"%s\"\n" _ error->errmess);
  return NULL;
@


4.1.7.2
log
@Fixed name clash with trace.h:  New name jc_trace.h
@
text
@d33 3
a35 3
      Also, the callback system is used as follows: the callback list
      is scanned for each object. If a function renders it, it claims
      the callback. If the callback is not claimed, a service call is
d57 1
a57 1
#include "jc_trace.h"
d115 1
a115 1
/* Fix MED-4786: use the right entries for palettes < 16 entries. J R
d375 1
a375 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d403 1
a403 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d427 1
a427 1
                                          baseline and size fields in
d429 1
a429 1
                                          we simply scale system text
d434 2
a435 2
                                          system text is usually much
                                          wider for a given nominal x
d485 1
a485 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d535 1
a535 1
/* For bitmapped fonts, the font manager can't cope with translations
d580 1
a580 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d710 1
a710 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d788 1
a788 1
  drawfile_render_state *state = (drawfile_render_state *) s  /* save
d840 1
a840 1
  drawfile_render_state *state = (drawfile_render_state *) s  /* save
d889 1
a889 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d926 1
a926 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d953 1
a953 1
                                          simply scale system text to
d963 1
a963 1
                                          linear optimisation problem
d1030 1
a1030 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d1136 1
a1136 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d1181 1
a1181 1
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save
d1201 1
a1201 1
                                          JPEG by the given matrix to
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d15 1
a15 1
/*render.c - implementation file for drawdata_render */
d17 12
a28 8
   /* The error handling here is strange because we want to attempt
      to plot all of the draw file before giving up. So all the
      callbacks just store their error codes away, and return NULL.
      In other words, instead of taking the form

      os_error *fn (..., bool *u) {  os_error *error = NULL; ...

      finish: return error; }
d32 15
a46 4
      os_error *fn (..., bool *u) {  os_error *error = NULL; ...

      finish: if (state->error == NULL) state->error = error; return
      NULL; }
d48 1
a48 8
      Also, the callback system is used as follows: the callback list 
      is scanned for each object. If a function renders it, it claims 
      the callback. If the callback is not claimed, a service call is 
      sent round. This system is also used internally: if a text
      object gives an error, it does not claim the callback, and the
      system-font renderer has a go. */

/*From CLib */
d54 1
a54 1
/*From OSLib */
d61 1
a61 1
/*From Support */
d68 1
a68 1
/*Local */
d76 2
a77 2
   /* The value '0' here (which allows the Draw module to use a
      default of its own choice) results in poor rendering. */
d80 1
a80 1
static os_error *Sprite(osspriteop_header * header, os_trfm * trfm)
d82 51
a132 22
{
  os_error *error = NULL;
  int entry_count;
  osspriteop_TRANS_TAB(256) trans_tab;

  entry_count = (header->image - sizeof(osspriteop_header)) /
      sizeof(os_colour_pair);

  if (entry_count > 0)
  {
    if ((error = xcolourtrans_select_table_for_sprite
         (osspriteop_UNSPECIFIED, (osspriteop_id) header,
          colourtrans_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
          (osspriteop_trans_tab *) & trans_tab, colourtrans_GIVEN_SPRITE))
        != NULL)
      goto finish;
  }
  else
  {                                    /* Sprite has no palette. */
    int log2_bpp;
    os_PALETTE(20) palette;
    bits flags;
d134 11
a144 2
    if ((error = xos_read_mode_variable(header->mode, os_MODEVAR_LOG2_BPP,
                                        &log2_bpp, &flags)) != NULL)
d147 5
a151 3
    if ((flags & _C) != NONE)
    {
      char s[DEC_WIDTH + 1];
d153 2
a154 4
      error = main_error_lookup(error_DRAW_FILE_BAD_MODE, "BadMode",
                              riscos_format_dec(s, (int) header->mode, 0, 1));
      goto finish;
    }
d156 9
a164 26
    if (log2_bpp < 3)
      if ((error = xwimp_read_true_palette((os_palette *) & palette)) !=
          NULL)
        goto finish;

/* Fix MED-4786: use the right entries for palettes < 16 entries. J R 
   C 6th Mar 1995 */
    switch (log2_bpp)
    {
    case 0:
      palette.entries[1] = palette.entries[7];
      break;

    case 1:
      palette.entries[1] = palette.entries[2];
      palette.entries[2] = palette.entries[4];
      palette.entries[3] = palette.entries[7];
      break;
    }

    if ((error = xcolourtrans_select_table(header->mode, log2_bpp < 3 ?
                                (os_palette *) & palette : (os_palette *) - 1,
                        colourtrans_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
                               (osspriteop_trans_tab *) & trans_tab)) != NULL)
      goto finish;
  }
d166 2
a167 5
  if ((error = xosspriteop_put_sprite_trfm(osspriteop_PTR,
                   osspriteop_UNSPECIFIED, (osspriteop_id) header, NONE, NULL,
           os_ACTION_USE_MASK, trfm, (osspriteop_trans_tab *) & trans_tab)) !=
      NULL)
    goto finish;
d169 7
a175 5
finish:
  return error;
}
/*------------------------------------------------------------------------*/
static os_error *Text_System(char *text, os_colour fill, os_trfm * trfm)
d177 13
a189 2
   /* Create a sprite, clear it to the text colour, and write the
      character into the mask. */
d191 7
a197 42
{
  typedef
  struct
  {
    osspriteop_area area;
    osspriteop_header header;
    os_colour_pair palette[2];
    bits image[8];
    bits mask[8];
  }
  mode0_8x8_sprite;

  os_error *error = NULL;
  int len, r0, r1, r2, r3, i;

  mode0_8x8_sprite sprite =
  {                                    /* area */
    { /* size */ sizeof sprite,
/* sprite_count */ 1,
/* first */ offsetof(mode0_8x8_sprite, header),
/* free */ sizeof sprite
    },

/* header */
    { /* size */ sizeof sprite.header + sizeof sprite.palette +
     sizeof sprite.image + sizeof sprite.mask,
/* name */ "t",
     /* width */ 0 /* 8 columns */ ,
     /* height */ 7 /* 8 rows */ ,
/* left_bit */ 0,
/* right_bit */ 7,
/* image */ sizeof sprite.header + sizeof sprite.palette,
/* mask */ sizeof sprite.header + sizeof sprite.palette +
     sizeof sprite.image,
/* mode */ 0
    },

/* palette */
    {
      { /* on */ SKIP,
                                       /* off */ SKIP
                                       /* filled in with real colour */
a198 5
      { /* on */ SKIP,
                                       /* off */ SKIP
                                       /* never seen */
      }
    },
d200 55
a254 2
/* bitmap */
    {0, 0, 0, 0, 0, 0, 0, 0},
d256 3
a258 27
/* mask */
    {-1, -1, -1, -1, -1, -1, -1, -1}
  };
  bool done_switch_output = FALSE;
  os_coord base =
  {16 * draw_OS_UNIT, 0}, step;
  os_trfm char_trfm = *trfm;

  static char gcol0[] =
  {os_VDU_SET_GCOL, os_ACTION_OVERWRITE, 0};

  tracef("Text_System: trfm_dir\n");
  trfm_dir(&step, trfm, &base);

  len = strlen(text);

/* Fill in the colour to be used. */
  sprite.palette[0].on = sprite.palette[0].off = fill;

  for (i = 0; i < len; i++)
  {
    tracef("Text_System: osspriteop_switch_output_to_mask\n");
    if ((error = xosspriteop_switch_output_to_mask(osspriteop_PTR,
                          &sprite.area, (osspriteop_id) & sprite.header, NULL,
                                                 &r0, &r1, &r2, &r3)) != NULL)
      goto finish;
    done_switch_output = TRUE;
d260 6
a265 3
    tracef("Text_System: os_writen\n");
    if ((error = xos_writen(gcol0, sizeof gcol0)) != NULL)
      goto finish;
d267 15
a281 3
    tracef("Text_System: os_plot\n");
    if ((error = xos_plot(os_MOVE_TO, 0, 32)) != NULL)
      goto finish;
d283 2
a284 2
    tracef("Text_System: os_writec\n");
    if ((error = xos_writec(text[i])) != NULL)
d287 1
a287 3
    tracef("Text_System: osspriteop_unswitch_output (0x%X, %d, %d, %d)\n"
           _ r0 _ r1 _ r2 _ r3);
    if ((error = xosspriteop_unswitch_output(r0, r1, r2, r3)) != NULL)
a288 1
    done_switch_output = FALSE;
d290 1
a290 4
/* Now we can plot the sprite. We use the internal sprite renderer
   which makes a translation table. */
    tracef("Text_System: Sprite\n");
    if ((error = Sprite(&sprite.header, &char_trfm)) != NULL)
d293 4
a296 3
    char_trfm.entries[2][0] += step.x;
    char_trfm.entries[2][1] += step.y;
  }
d299 1
a299 8
  if (done_switch_output)
  {
    os_error *error1 = xosspriteop_unswitch_output(r0, r1, r2, r3);

    if (error == NULL)
      error = error1;
  }
  return error;
d302 2
a303 1
static os_error *Bbox(os_box * box, os_trfm * trfm)
d305 15
a319 33
{
  os_error *error = NULL;
  os_coord u[4], t[4];
  int i;
  char set_dot_style[] =
  {os_VDU_MISC, os_MISC_SET_DOT_STYLE, 0xCC, 0,
   0xCC, 0, 0xCC, 0, 0xCC, 0};

  u[0].x = box->x0, u[0].y = box->y0;
  u[1].x = box->x1, u[1].y = box->y0;
  u[2].x = box->x1, u[2].y = box->y1;
  u[3].x = box->x0, u[3].y = box->y1;

  for (i = 0; i < 4; i++)
  {
    trfm_point(&t[i], trfm, &u[i]);
    t[i].x /= draw_OS_UNIT, t[i].y /= draw_OS_UNIT;
  }

  if ((error = xcolourtrans_set_gcol(os_COLOUR_LIGHT_RED,
                colourtrans_SET_FG, os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
    goto finish;

  if ((error = xos_writen(set_dot_style, sizeof set_dot_style)) != NULL)
    goto finish;

  if ((error = xos_plot(os_MOVE_TO, t[3].x, t[3].y)) != NULL)
    goto finish;

  for (i = 0; i < 4; i++)
    if ((error = xos_plot(os_PLOT_TO | os_PLOT_DOTTED, t[i].x, t[i].y))
        != NULL)
      goto finish;
d321 2
a322 6
finish:
  return error;
}
/*------------------------------------------------------------------------*/
os_error *render(bits flags, drawfile_diagram * diagram, int size,
                 os_trfm * trfm, os_box * clip, int flatness)
d324 27
a350 52
{
  os_error *error = NULL;
  drawfile_object *end, *o;
  drawfile_render_state state;
  os_box inv_clip;
  bool can_clip, unclaimed;

  tracef("render\n");
  can_clip = clip != NULL && trfm_det(trfm) != 0;

  if (can_clip)
  {                                    /* Transform the clipping box
                                          given back to the
                                          coordinates it would have
                                          had in paper coordinates,
                                          and rebound it there. */
    os_trfm inv;
    int i;
    os_box clip_draw;

    for (i = 0; i < 4; i++)
      (&clip_draw.x0)[i] = (&clip->x0)[i] * draw_OS_UNIT;

    trfm_inv(&inv, trfm);
    trfm_box(&inv_clip, &inv, &clip_draw);
  }

  state.diagram = diagram;
  state.font_table = NULL;
  state.flags = flags;
  state.trfm = trfm;
  state.clip = can_clip ? &inv_clip : NULL;
  state.flatness = (flags & drawfile_RENDER_GIVEN_FLATNESS) != NONE ?
      flatness : DEFAULT_FLATNESS;
  state.error = NULL;

  tracef("render: despatching\n");
  end = (drawfile_object *) & ((byte *) diagram)[size];
  for (o = diagram->objects; o < end; *(byte **) & o += o->size)
  {
    state.object = o;
    if ((error = callback(main_render_callback, &state, &unclaimed, 1,
                          o->type)) != NULL)
      goto finish;

    if (unclaimed && o->type >= 0x100)
    {
      if ((error = xservice_draw_object_render(o->type, &state, NULL)) !=
          NULL)
        goto finish;
    }
  }
d353 1
a353 1
  return error != NULL ? error : state.error;
d356 1
a356 1
os_error *render_font_table(void *null, void *s, bool * unclaimed)
d358 2
a359 4
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
d361 1
a361 1
  tracef("render_font_table\n");
d363 2
a364 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_FONT_TABLE);
d366 1
a366 1
  null = null;
d369 2
a370 2
/* Save the pointer. */
  state->font_table = state->object;
d372 1
a372 1
  *unclaimed = FALSE;
d374 5
a378 6
/*finish: */
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_font_table: \"%s\"\n" _ error->errmess);
  return NULL;
d381 1
a381 1
os_error *render_text_system(void *null, void *s, bool * unclaimed)
d383 4
a386 6
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  os_trfm trfm, text_trfm;
  drawfile_text *text = &state->object->data AS text;
d388 1
a388 1
  tracef("render_text_system\n");
d390 2
a391 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TEXT);
d393 1
a393 1
  null = null;
d396 2
a397 47
  if (state->clip == NULL || verify_overlap(state->clip, &text->bbox))
  {
    int len = strlen(text->text);

    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&text->bbox, state->trfm);

    if (text->fill != os_COLOUR_TRANSPARENT &&
        (state->flags & drawfile_RENDER_SUPPRESS) == NONE && len > 0)
    {                                  /* If the text is REALLY in
                                          system font, we honour the
                                          baseline and size fields in 
                                          the definition; otherwise,
                                          we simply scale system text 
                                          to fit inside the bbox the
                                          font claims to have. This
                                          gives better results than
                                          Draw's treatment, since
                                          system text is usually much 
                                          wider for a given nominal x 
                                          size than an outline font. */

      if (text->style.font_index == font_SYSTEM)
      {                                /* Get the trfm needed to
                                          scale the text to paper
                                          coords. */
        text_trfm.entries[0][0] = text->xsize * ((1 << 16) /
                                                 (16 * draw_OS_UNIT));
        text_trfm.entries[0][1] = 0;
        text_trfm.entries[1][0] = 0;
        text_trfm.entries[1][1] = text->ysize * ((1 << 16) /
                                                 (32 * draw_OS_UNIT));
        text_trfm.entries[2][0] = text->base.x;
        text_trfm.entries[2][1] = text->base.y - text->ysize / 8;
      }
      else
      {                                /* Which trfm takes the text
                                          into its bounding box? */
        text_trfm.entries[0][0] = (text->bbox.x1 - text->bbox.x0) *
            ((1 << 16) / (16 * draw_OS_UNIT)) / len;
        text_trfm.entries[0][1] = 0;
        text_trfm.entries[1][0] = 0;
        text_trfm.entries[1][1] = (text->bbox.y1 - text->bbox.y0) *
            ((1 << 16) / (32 * draw_OS_UNIT));
        text_trfm.entries[2][0] = text->bbox.x0;
        text_trfm.entries[2][1] = text->bbox.y0;
      }
d399 2
a400 2
      tracef("render_text_system: trfm_mul\n");
      trfm_mul(&trfm, state->trfm, &text_trfm);
d402 38
a439 4
      if ((error = Text_System(text->text, text->fill, &trfm)) != NULL)
        goto finish;
    }
  }
d441 1
a441 1
  *unclaimed = FALSE;
d444 4
a447 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_text_system: \"%s\"\n" _ error->errmess);
  return NULL;
d450 1
a450 1
os_error *render_text(void *null, void *s, bool * unclaimed)
d452 8
a459 10
{
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  os_error *error = NULL;
  drawfile_text *text = &state->object->data AS text;
  char *font_name;
  bool done_find_font = FALSE;
  font_f f;
  os_trfm trfm;
  os_coord base;
d461 1
a461 1
  tracef("render_text\n");
d464 2
a465 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TEXT);
d467 1
a467 1
  null = null;
d470 49
a518 51
  if (text->style.font_index != font_SYSTEM)
  {
    if (state->clip == NULL || verify_overlap(state->clip, &text->bbox))
    {
      if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
        (void) Bbox(&text->bbox, state->trfm);

/* Get the font table pointer. */
      font_name = verify_lookup_font_index(text->style.font_index,
                                           state->font_table);
/* we know that |state->font_table| is not NULL and that
   |verify_lookup_font_index()| returns a value because of
   |verify()|. */

      if (text->fill != os_COLOUR_TRANSPARENT &&
          (state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      {
        tracef("finding font \"%s\", size (%d, %d)\n" _
               font_name _ text->xsize / 40 _
               text->ysize / 40);
        if ((error = xfont_find_font(font_name, text->xsize / 40,
                             text->ysize / 40, 0, 0, &f, NULL, NULL)) != NULL)
          goto finish;
        done_find_font = TRUE;

        tracef("setting colours 0x%X, 0x%X\n" _
               text->bg_hint _ text->fill);
        if ((error = xcolourtrans_set_font_colours(f,
                    text->bg_hint, text->fill, 14, NULL, NULL, NULL)) != NULL)
          goto finish;

/* For bitmapped fonts, the font manager can't cope with translations 
   in the matrix ... so move the translation part out of the matrix
   into the baseline origin. */
        trfm = *state->trfm;
        trfm.entries[2][0] = 0;
        trfm.entries[2][1] = 0;

        trfm_point(&base, state->trfm, &text->base);

/* Paint the text. */
        tracef("painting \"%s\" at (%d, %d) through ((%d, %d), "
               "(%d, %d), (%d, %d))\n" _
               text->text _ base.x _ base.y _
               trfm.entries[0][0] _ trfm.entries[0][1] _
               trfm.entries[1][0] _ trfm.entries[1][1] _
               trfm.entries[2][0] _ trfm.entries[2][1]);
        if ((error = xfont_paint(f, text->text, font_OS_UNITS |
                     font_GIVEN_TRFM | font_GIVEN_FONT | (state->flags & font_BLEND_FONT), base.x / draw_OS_UNIT,
                           base.y / draw_OS_UNIT, SKIP, &trfm, SKIP)) != NULL)
          goto finish;
a519 1
    }
d521 2
a522 2
    *unclaimed = FALSE;
  }
d525 9
a533 12
  if (done_find_font)
  {
    os_error *error1 = xfont_lose_font(f);
    if (error == NULL)
      error = error1;
  }

  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_text: \"%s\"\n" _ error->errmess);
  return NULL;
d536 1
a536 1
os_error *render_path(void *null, void *s, bool * unclaimed)
d538 6
a543 8
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_path *path = &state->object->data AS path;
  draw_path *elements;
  draw_dash_pattern *pattern;
  draw_line_style line_style;
d545 1
a545 1
  tracef("render_path\n");
d547 2
a548 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_PATH);
d550 1
a550 1
  null = null;
d554 10
a563 11
  if (state->clip != NULL)
  {
    tracef("clipping rectangle given as ((%d, %d), (%d, %d))\n" _
           state->clip->x0 _ state->clip->y0 _
           state->clip->x1 _ state->clip->y1);
    tracef("testing against bbox of ((%d, %d), (%d, %d))\n" _
           path->bbox.x0 _ path->bbox.y0 _
           path->bbox.x1 _ path->bbox.y1);
    tracef("-> overlap %s\n" _ WHETHER(verify_overlap(state->clip,
                                                      &path->bbox)));
  }
d566 75
a640 4
  if (state->clip == NULL || verify_overlap(state->clip, &path->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&path->bbox, state->trfm);
d642 1
a642 83
     #if TRACE
    {
      int i;
      tracef("using style 0x");
      for (i = 0; i < sizeof(drawfile_path_style); i++)
        trace_f(NULL, 0, "%.2X" _
                ((byte *) & path->style)[i]);
      trace_f(NULL, 0, "\n");
    }
     #endif
    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
    {                                  /* Convert the
                                          drawfile_path_style into a
                                          draw_line_style. */
      byte flags = path->style.flags;

      line_style.join_style = (flags & drawfile_PATH_JOIN) >>
          drawfile_PATH_JOIN_SHIFT;
      line_style.start_cap_style = (flags & drawfile_PATH_START) >>
          drawfile_PATH_START_SHIFT;
      line_style.end_cap_style = (flags & drawfile_PATH_END) >>
          drawfile_PATH_END_SHIFT;
      line_style.reserved = 0;
      line_style.mitre_limit = 10 << 16;  /* Postscript default */
      line_style.start_cap_width = line_style.end_cap_width =
          16 * path->style.cap_width;
      line_style.start_cap_length = line_style.end_cap_length =
          16 * path->style.cap_length;

/* Get the draw_pattern. */
      if ((flags & drawfile_PATH_DASHED) != NONE)
      {
        pattern = &state->object->data AS path_with_pattern.pattern;
        elements = (draw_path *) ((byte *) pattern +
                            draw_SIZEOF_DASH_PATTERN(pattern->element_count));
      }
      else
      {
        pattern = NULL;
        elements = &path->path;
      }

      if (path->fill != os_COLOUR_TRANSPARENT)
      {
        if ((error = xcolourtrans_set_gcol(path->fill,
                                    colourtrans_SET_FG | colourtrans_USE_ECFS,
                                    os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
          goto finish;

        if ((error = xdraw_fill(elements, draw_FILL_FULL_INTERIOR |
                                draw_FILL_INTERIOR_BOUNDARY | ((flags &
                                     drawfile_PATH_WINDING_EVEN_ODD) != NONE ?
                         draw_FILL_EVEN_ODD : draw_FILL_NONZERO), state->trfm,
                                state->flatness)) != NULL)
          goto finish;
      }

      if (path->outline != os_COLOUR_TRANSPARENT)
      {
        if ((error = xcolourtrans_set_gcol(path->outline,
                                    colourtrans_SET_FG | colourtrans_USE_ECFS,
                                    os_ACTION_OVERWRITE, NULL, NULL)) != NULL)
          goto finish;

               #if TRACE
        {
          int i;
          tracef("using line_style 0x");
          for (i = 0; i < sizeof(draw_line_style); i++)
            trace_f(NULL, 0, "%.2X" _((byte *) & line_style)[i]);
          trace_f(NULL, 0, "\n");
        }
               #endif
        if ((error = xdraw_stroke(elements, draw_FILL_FULL_INTERIOR |
                    draw_FILL_INTERIOR_BOUNDARY | draw_FILL_EXTERIOR_BOUNDARY,
                       state->trfm, state->flatness, path->width, &line_style,
                                  pattern)) != NULL)
          goto finish;
      }
    }
  }

  *unclaimed = FALSE;
d645 4
a648 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_path: \"%s\"\n" _ error->errmess);
  return NULL;
d651 1
a651 1
os_error *render_sprite(void *null, void *s, bool * unclaimed)
d653 6
a658 8
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_sprite *sprite = &state->object->data AS sprite;
  int xeig, yeig, width, height;
  bits flags1, flags2;
  os_trfm trfm, sprite_trfm;
d660 1
a660 1
  tracef("render_sprite\n");
d662 2
a663 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_SPRITE);
d665 1
a665 1
  null = null;
d668 44
a711 48
  if (state->clip == NULL || verify_overlap(state->clip, &sprite->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&sprite->bbox, state->trfm);

    if ((error = xosspriteop_read_sprite_size(osspriteop_PTR,
              osspriteop_UNSPECIFIED, (osspriteop_id) & state->object->data AS
                         sprite.header, &width, &height, NULL, NULL)) != NULL)
      goto finish;

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE &&
        width > 0 && height > 0)
    {
      if ((error = xos_read_mode_variable(sprite->header.mode,
                             os_MODEVAR_XEIG_FACTOR, &xeig, &flags1)) != NULL)
        goto finish;

      if ((error = xos_read_mode_variable(sprite->header.mode,
                             os_MODEVAR_YEIG_FACTOR, &yeig, &flags2)) != NULL)
        goto finish;

      if (((flags1 | flags2) & _C) != NONE)
      {
        char s[DEC_WIDTH + 1];

        error = main_error_lookup(error_DRAW_FILE_BAD_MODE, "BadMode",
                       riscos_format_dec(s, (int) sprite->header.mode, 0, 1));
        goto finish;
      }

/* Get the trfm needed to scale the sprite to paper coords. */
      sprite_trfm.entries[0][0] = muldiv(sprite->bbox.x1 -
                      sprite->bbox.x0, 1 << 16, width * draw_OS_UNIT << xeig);
      sprite_trfm.entries[0][1] = 0;
      sprite_trfm.entries[1][0] = 0;
      sprite_trfm.entries[1][1] = muldiv(sprite->bbox.y1 -
                     sprite->bbox.y0, 1 << 16, height * draw_OS_UNIT << yeig);
      sprite_trfm.entries[2][0] = sprite->bbox.x0;
      sprite_trfm.entries[2][1] = sprite->bbox.y0;

/* Multiply the matrix in the sprite by the given matrix to get the
   matrix to plot through. */
      trfm_mul(&trfm, state->trfm, &sprite_trfm);

      if ((error = Sprite(&sprite->header, &trfm)) != NULL)
        goto finish;
    }
  }
d713 1
a713 1
  *unclaimed = FALSE;
d716 4
a719 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_sprite: \"%s\"\n" _ error->errmess);
  return NULL;
d722 1
a722 1
os_error *render_group(void *null, void *s, bool * unclaimed)
d724 5
a728 7
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s  /* save 
                                                                 typing */ ;
  drawfile_group *group = &state->object->data AS group;
  drawfile_object *o, *end;
  bool u;
d730 1
a730 1
  tracef("render_group\n");
d732 2
a733 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_GROUP);
d735 1
a735 1
  null = null;
d738 19
a756 23
  if (state->clip == NULL || verify_overlap(state->clip, &group->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&group->bbox, state->trfm);

    end = (drawfile_object *) & ((byte *) state->object)
        [state->object->size];
    for (o = (drawfile_object *) & group->objects; o < end;
         *(byte **) & o += o->size)
    {
      state->object = o;
      if ((error = callback(main_render_callback, state, &u, 1,
                            o->type)) != NULL)
        goto finish;

      if (u && o->type >= 0x100)
      {
        if ((error = xservice_draw_object_render(o->type, state, NULL))
            != NULL)
          goto finish;
      }
    }
  }
d758 1
a758 1
  *unclaimed = FALSE;
d761 4
a764 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_group: \"%s\"\n" _ error->errmess);
  return NULL;
d767 1
a767 1
os_error *render_tagged(void *null, void *s, bool * unclaimed)
d769 5
a773 7
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s  /* save 
                                                                 typing */ ;
  drawfile_tagged *tagged = &state->object->data AS tagged;
  drawfile_object *o, *end;
  bool u;
d775 1
a775 1
  tracef("render_tagged\n");
d777 2
a778 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TAGGED);
d780 1
a780 1
  null = null;
d783 11
a793 18
  o = (drawfile_object *) & tagged->object;
  end = (drawfile_object *) & ((byte *) state->object)
      [state->object->size];
  if ((drawfile_object *) & ((byte *) o)[o->size] > end)
  {
    error = main_error_lookup(error_DRAW_FILE_BAD_TAG, "BadTag");
    goto finish;
  }

  state->object = o;
  if ((error = callback(main_render_callback, state, &u, 1, o->type)) !=
      NULL)
    goto finish;

  if (u && o->type >= 0x100)
  {
    if ((error = xservice_draw_object_render(o->type, state, NULL)) !=
        NULL)
a794 1
  }
d796 7
a802 1
  *unclaimed = FALSE;
d805 4
a808 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_tagged: \"%s\"\n" _ error->errmess);
  return NULL;
d811 1
a811 1
os_error *render_text_area(void *null, void *s, bool * unclaimed)
d813 3
a815 5
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_text_area *text_area = &state->object->data AS text_area;
d817 1
a817 1
  tracef("render_text_area\n");
d819 2
a820 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TEXT_AREA);
d822 1
a822 1
  null = null;
d825 9
a833 10
  if (state->clip == NULL || verify_overlap(state->clip, &text_area->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&text_area->bbox, state->trfm);

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      if ((error = textarea_render(state->object, state->trfm,
                                   state->clip, state->flags)) != NULL)
        goto finish;
  }
d835 1
a835 1
  *unclaimed = FALSE;
d838 4
a841 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_text_area: \"%s\"\n" _ error->errmess);
  return NULL;
d844 1
a844 1
os_error *render_trfm_text_system(void *null, void *s, bool * unclaimed)
d846 4
a849 6
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_trfm_text *trfm_text = &state->object->data AS trfm_text;
  os_trfm trfm, text_trfm;
d851 1
a851 1
  tracef("render_trfm_text_system\n");
d853 2
a854 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TRFM_TEXT);
d856 1
a856 1
  null = null;
d859 2
a860 52
  if (state->clip == NULL || verify_overlap(state->clip, &trfm_text->bbox))
  {
    int len = strlen(trfm_text->text);

    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&trfm_text->bbox, state->trfm);

    if (trfm_text->fill != os_COLOUR_TRANSPARENT &&
        (state->flags & drawfile_RENDER_SUPPRESS) == NONE && len > 0)
    {                                  /* If the text is REALLY in
                                          system font, we honour the
                                          baseline, transformation
                                          and size fields in the
                                          definition; otherwise, we
                                          simply scale system text to 
                                          fit inside the bbox the
                                          font claims to have,
                                          without making any attempt
                                          to apply the
                                          transformation. To scale
                                          the text to fit inside the
                                          bounding box WITH the
                                          transformation applied
                                          would involve solving a
                                          linear optimisation problem 
                                          (for the font width) with
                                          eight constraints. */

      if (trfm_text->style.font_index == font_SYSTEM)
      {                                /* Get the trfm needed to
                                          scale the text to the
                                          coords it would have if it
                                          were a "real" font. */
        os_trfm trfm1, trfm2;

        trfm1.entries[0][0] = trfm_text->xsize * ((1 << 16) /
                                                  (16 * draw_OS_UNIT));
        trfm1.entries[0][1] = 0;
        trfm1.entries[1][0] = 0;
        trfm1.entries[1][1] = trfm_text->ysize * ((1 << 16) /
                                                  (32 * draw_OS_UNIT));
        trfm1.entries[2][0] = 0;
        trfm1.entries[2][1] = -trfm_text->ysize / 8;

        trfm_mul(&trfm2, &trfm_text->trfm, &trfm1);

        trfm1.entries[0][0] = 1 << 16;
        trfm1.entries[0][1] = 0;
        trfm1.entries[1][0] = 0;
        trfm1.entries[1][1] = 1 << 16;
        trfm1.entries[2][0] = trfm_text->base.x;
        trfm1.entries[2][1] = trfm_text->base.y;
d862 2
a863 14
        trfm_mul(&text_trfm, &trfm1, &trfm2);
      }
      else
      {                                /* Which trfm takes the text
                                          into its bounding box? */
        text_trfm.entries[0][0] = (trfm_text->bbox.x1 -
                trfm_text->bbox.x0) * ((1 << 16) / (16 * draw_OS_UNIT)) / len;
        text_trfm.entries[0][1] = 0;
        text_trfm.entries[1][0] = 0;
        text_trfm.entries[1][1] = (trfm_text->bbox.y1 -
                      trfm_text->bbox.y0) * ((1 << 16) / (32 * draw_OS_UNIT));
        text_trfm.entries[2][0] = trfm_text->bbox.x0;
        text_trfm.entries[2][1] = trfm_text->bbox.y0;
      }
d865 55
a919 2
      tracef("render_trfm_text_system: trfm_mul\n");
      trfm_mul(&trfm, state->trfm, &text_trfm);
d921 1
a921 7
      if ((error = Text_System(trfm_text->text, trfm_text->fill, &trfm))
          != NULL)
        goto finish;
    }
  }

  *unclaimed = FALSE;
d924 4
a927 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_trfm_text_system: \"%s\"\n" _ error->errmess);
  return NULL;
d930 1
a930 1
os_error *render_trfm_text(void *null, void *s, bool * unclaimed)
d932 8
a939 10
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_trfm_text *trfm_text = &state->object->data AS trfm_text;
  char *font_name;
  bool done_find_font = FALSE;
  font_f f;
  os_trfm trfm;
  os_coord base;
d941 1
a941 1
  tracef("render_trfm_text\n");
d943 2
a944 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TRFM_TEXT);
d946 1
a946 1
  null = null;
d949 58
a1006 7
  if (trfm_text->style.font_index != font_SYSTEM)
  {
    if (state->clip == NULL || verify_overlap(state->clip,
                                              &trfm_text->bbox))
    {
      if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
        (void) Bbox(&trfm_text->bbox, state->trfm);
d1008 1
a1008 54
/* Check the font table pointer. */
      font_name = verify_lookup_font_index(trfm_text->style.font_index,
                                           state->font_table);
/* we know that |state->font_table| is not NULL and that
   |verify_lookup_font_index()| returns a value because of
   |verify()|. */

      if (trfm_text->fill != os_COLOUR_TRANSPARENT
          && (state->flags & drawfile_RENDER_SUPPRESS) == NONE)
      {
        char tmp[3], *text;
        tracef("finding font \"%s\", size (%d, %d)\n" _
               font_name _ trfm_text->xsize / 40 _ trfm_text->ysize / 40);

        if ((error = xfont_find_font(font_name, trfm_text->xsize / 40,
                        trfm_text->ysize / 40, 0, 0, &f, NULL, NULL)) != NULL)
          goto finish;
        done_find_font = TRUE;

        tracef("setting colours 0x%X, 0x%X\n" _
               trfm_text->bg_hint _ trfm_text->fill);
        if ((error = xcolourtrans_set_font_colours(f,
                          trfm_text->bg_hint, trfm_text->fill, 14, NULL, NULL,
                                                   NULL)) != NULL)
          goto finish;

/* Stupid Font_Paint wants OS Units in the matrix */
        trfm_mul(&trfm, state->trfm, &trfm_text->trfm);
        trfm.entries[2][0] /= draw_OS_UNIT;
        trfm.entries[2][1] /= draw_OS_UNIT;

        trfm_point(&base, state->trfm, &trfm_text->base);

/* Paint the text. */
        text = trfm_text->text;
        if ((trfm_text->flags & drawfile_TEXT_UNDERLINE) != NONE)
        {
          text -= 3;
          memcpy(tmp, text, 3);
          text[0] = font_COMMAND_UNDERLINE;
          text[1] = -25 + 0x100;
          text[2] = 15;
        }
        tracef("painting \"%s\" at (%d, %d)\n" _ text _
               trfm_text->base.x _ trfm_text->base.y);
        error = xfont_paint(f, text, font_OS_UNITS | font_GIVEN_TRFM |
                    font_GIVEN_FONT | (state->flags & font_BLEND_FONT)
                    | ((trfm_text->flags & drawfile_TEXT_KERN)
                            != NONE ? font_KERN : NONE) | ((trfm_text->flags &
                   drawfile_TEXT_RIGHT_TO_LEFT) != NONE ? font_RIGHT_TO_LEFT :
                    NONE), base.x / draw_OS_UNIT, base.y / draw_OS_UNIT, SKIP,
                            &trfm, SKIP);
        if ((trfm_text->flags & drawfile_TEXT_UNDERLINE) != 0)
          memcpy(text, tmp, 3);
d1010 1
a1010 4

      *unclaimed = FALSE;
    }
  }
d1013 11
a1023 14
  if (done_find_font)
  {
    os_error *error1 = xfont_lose_font(f);
    if (error == NULL)
      error = error1;
  }

  if (state->error == NULL)
    state->error = error;
/* Claim this call if everything went o k. (If not,
   render_trfm_text_system() will have a go.) */
  if (error != NULL)
    tracef("render_trfm_text: \"%s\"\n" _ error->errmess);
  return NULL;
d1026 1
a1026 1
os_error *render_trfm_sprite(void *null, void *s, bool * unclaimed)
d1028 4
a1031 6
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_trfm_sprite *trfm_sprite = &state->object->data AS trfm_sprite;
  os_trfm trfm;
d1033 1
a1033 1
  tracef("render_trfm_sprite\n");
d1035 2
a1036 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_TRFM_SPRITE);
d1038 1
a1038 1
  null = null;
d1041 13
a1053 17
  if (state->clip == NULL || verify_overlap(state->clip,
                                            &trfm_sprite->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&trfm_sprite->bbox, state->trfm);

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
    {                                  /* Multiply the matrix in the
                                          sprite by the given matrix
                                          to get the matrix  to plot
                                          through. */
      trfm_mul(&trfm, state->trfm, &trfm_sprite->trfm);

      if ((error = Sprite(&trfm_sprite->header, &trfm)) != NULL)
        goto finish;
    }
  }
d1055 1
a1055 1
  *unclaimed = FALSE;
d1058 4
a1061 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_trfm_sprite: \"%s\"\n" _ error->errmess);
  return NULL;
d1064 1
a1064 1
os_error *render_jpeg(void *null, void *s, bool * unclaimed)
d1066 4
a1069 6
{
  os_error *error = NULL;
  drawfile_render_state *state = (drawfile_render_state *) s;  /* save 
                                                                  typing */
  drawfile_jpeg *jpeg = &state->object->data AS jpeg;
  os_trfm trfm;
d1071 1
a1071 1
  tracef("render_jpeg\n");
d1073 2
a1074 2
  riscos_assert(null == NULL);
  riscos_assert(state->object->type == drawfile_TYPE_JPEG);
d1076 1
a1076 1
  null = null;
d1079 13
a1091 17
  if (state->clip == NULL || verify_overlap(state->clip, &jpeg->bbox))
  {
    if ((state->flags & drawfile_RENDER_BBOXES) != NONE)
      (void) Bbox(&jpeg->bbox, state->trfm);

    if ((state->flags & drawfile_RENDER_SUPPRESS) == NONE)
    {                                  /* Multiply the matrix in the
                                          JPEG by the given matrix to 
                                          get the matrix  to plot
                                          through. */
      trfm_mul(&trfm, state->trfm, &jpeg->trfm);

      if ((error = xjpeg_plot_transformed(&jpeg->image,
                          jpeg_TRANSFORM_DITHERED, &trfm, jpeg->len)) != NULL)
        goto finish;
    }
  }
d1093 1
a1093 1
  *unclaimed = FALSE;
d1096 4
a1099 5
  if (state->error == NULL)
    state->error = error;
  if (error != NULL)
    tracef("render_jpeg: \"%s\"\n" _ error->errmess);
  return NULL;
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

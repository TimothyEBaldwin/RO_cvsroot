head	4.8;
access;
symbols
	Hourglass-2_19:4.8
	Hourglass-2_18:4.7
	Hourglass-2_17:4.6
	RO_5_07:4.6
	Hourglass-2_16:4.6
	Hourglass-2_15:4.5
	Hourglass-2_14:4.4
	Hourglass-2_13:4.3
	dellis_autobuild_BaseSW:4.2
	Hourglass-2_12:4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.4
	Ursula_RiscPC:4.1.4.4.0.2
	rleggett_Hourglass-0_14b:4.1.4.6
	rleggett_Hourglass-0_14:4.1.4.5
	nicke_Hourglass_11:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.4
	UrsulaBuild_FinalSoftload:4.1.4.4
	rthornb_UrsulaBuild-12Aug1998:4.1.4.4
	aglover_UrsulaBuild-05Aug1998:4.1.4.4
	rthornb_UrsulaBuild-29Jul1998:4.1.4.4
	rthornb_UrsulaBuild-22Jul1998:4.1.4.4
	rthornb_UrsulaBuild-15Jul1998:4.1.4.4
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.4
	rleggett_Hourglass-0_13:4.1.4.4
	rthornb_UrsulaBuild-17Jun1998:4.1.4.4
	rthornb_UrsulaBuild-03Jun1998:4.1.4.4
	rthornb_UrsulaBuild-27May1998:4.1.4.3
	rthornb_UrsulaBuild-21May1998:4.1.4.3
	rthornb_UrsulaBuild_01May1998:4.1.4.3
	bavison_Hourglass_213:4.1.4.2
	bavison_Hourglass_212:4.1.4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2013.11.10.14.44.01;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	ztFtOE31ogeXYJcx;

4.7
date	2013.08.25.18.49.42;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	kyVH9q9lYd0IOR2x;

4.6
date	2002.11.29.15.16.04;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.28.10.33.23;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.01.16.34.38;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2001.03.23.17.09.49;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.12.12.46.58;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.44.32;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.44.32;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.37.55;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.07.07.11.10.26;	author bavison;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.03.06.17.27.04;	author bavison;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.04.15.09.59.52;	author rleggett;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.06.03.09.13.32;	author rleggett;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.09.01.10.24.02;	author rleggett;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.09.02.15.27.27;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.56.14;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.18.45;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Make 0 easier to distinguish from 8
Unlike the written word where '0' and 'O' might be confused, a percentage can't contain a 'O'. However as the character set is only 8 pixels wide it is easy to misread '0' and '8'.
Altered the character definition to not have a slash.

Version 2.19. Tagged as 'Hourglass-2_19'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > &.Hourglass.Hourglass

        AREA    |Hourglass$$Code|, CODE, READONLY, PIC

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:Hourglass
        GET     Hdr:MsgTrans
        GET     Hdr:FSNumbers
        GET     Hdr:OsBytes
        GET     Hdr:OsWords
        GET     Hdr:NewErrors
        GET     Hdr:Proc
        GET     Hdr:Wimp

        GET     VersionASM

        GET     Hdr:NdrDebug
        GET     Hdr:HostFS
                GBLL    hostvdu
hostvdu         SETL    {FALSE}
                GBLL    debug_flush
debug_flush     SETL    {TRUE}
                GBLL    debug
debug           SETL    {FALSE}
                GBLL    debugswientry
debugswientry   SETL    {FALSE}
                GBLL    debugdepth
debugdepth      SETL    {FALSE}
                GBLL    debugcurrent
debugcurrent    SETL    {FALSE}

bignum          * &3FFFFFFF             ; A large number to put into PercentageDepth

      [ :LNOT: :DEF: international_help
                GBLL    international_help
international_help SETL {TRUE}          ; Default to RISC OS 3.60+ internationalisation
      ]

; The constants defining the hourglass shape and position

HgX             * 4
HgY             * 2
HgSize          * 16
ActiveX         * HgX + (HgSize :SHR: 1)
ActiveY         * HgY + (HgSize :SHR: 1)

; The constants defining the Hourglass time behaviour

UpdateDelay     * 15
StartupDelay    * 33

; These define the things round the hourglass
; nb. keep on byte boundries !

PixelsPerByte   * 4
BytesPerLine    * 6
HeightInPixels  * 30
DataSize        * (BytesPerLine * HeightInPixels + 3):AND: :NOT: 3

PercX           * 0
PercY           * 21
CharWidth       * 8
CharHeight      * 9

DefaultColour1  * &00FFFF00               ; Cyan
DefaultColour3  * &00FF0000               ; Blue

MySWIChunkBase  * Module_SWISystemBase + HourglassSWI * Module_SWIChunkSize
 ASSERT MySWIChunkBase = Hourglass_On

; Workspace

        ^ 0, wp
HourglassData           #       DataSize                ; My Hourglass data is in here
HourglassDataEnd        #       0

ReturnColours           #       0                       ; Colours to return to when switched fully off
ReturnColour1           #       4
ReturnColour3           #       4
NextHColours            #       0                       ; Colours to (re)assert at next frame update
NextHColour1            #       4
NextHColour3            #       4
CurrentColours          #       0                       ; Colours actually in use (updated on PaletteV)
CurrentColour1          #       4
CurrentColour3          #       4

HourglassTimer          #       4
HourglassDepth          #       4
PercentageDepth         #       4
OldPercentage           #       1
NewPercentage           #       1
OldLEDs                 #       1
NewLEDs                 #       1

ReturnPointer           #       1                       ; Pointer number to return to when switched fully off
HourglassState          #       1                       ; State of sand (0..5)

        AlignSpace      4, 2                            ; so that the data ptr in the
                                                        ; OS_Word block is word-aligned

OSWord15Block           #       0                       ; Block for defining pointer shape
Block_ReasonCode        #       1
Block_PointerNumber     #       1
Block_Width             #       1
Block_Height            #       1
Block_ActiveX           #       1
Block_ActiveY           #       1
Block_DataPtr           #       4
        ASSERT  (3 :AND: :INDEX: Block_DataPtr)=0

PointerDirty            #       1                       ; 0 => shape set up etc
                                                        ; 1 => shape not set up etc
UpdateSemaphore         #       1                       ; 0 => not in update code
                                                        ; non0 => in update code

        AlignSpace

RAMSpaceRequired       * :INDEX: @@

Module_BaseAddr
        DCD     0                                       ; StartCode
        DCD     InitialisationCode-Module_BaseAddr
        DCD     FinalisationCode-Module_BaseAddr
        DCD     ServiceCall-Module_BaseAddr
        DCD     TitleString-Module_BaseAddr
        DCD     HelpString-Module_BaseAddr
        DCD     HelpAndCommandKeywordTable-Module_BaseAddr
        DCD     MySWIChunkBase
        DCD     SWIHandlerCode-Module_BaseAddr
        DCD     SWIDecodingTable-Module_BaseAddr
        DCD     0                                       ; SWIDecodingCode
      [ international_help
        DCD     MessageFileName-Module_BaseAddr         ; MessagesFile
      |
        DCD     0                                       
      ]
        DCD     FlagsTable-Module_BaseAddr

SWIDecodingTable
TitleString
        DCB     "Hourglass", 0  ; Share
        DCB     "On", 0
        DCB     "Off", 0
        DCB     "Smash", 0
        DCB     "Start", 0
        DCB     "Percentage", 0
        DCB     "LEDs", 0
        DCB     "Colours", 0
        DCB     0

HelpString
        DCB     "Hourglass", 9, "$Module_HelpVersion", 0
        ALIGN

HelpAndCommandKeywordTable
      [ international_help
        Command "HOn",  0, 0, International_Help
        Command "HOff", 0, 0, International_Help
        DCB     0
HOn_Help
        DCB     "HHON", 0
HOn_Syntax
        DCB     "SHON", 0
HOff_Help
        DCB     "HHOFF", 0
HOff_Syntax
        DCB     "SHOFF", 0
        ALIGN
MessageFileName
        DCB     "Resources:$.Resources.Hourglass.Messages", 0
      |
        Command "HOn",  0, 0, 0
        Command "HOff", 0, 0, 0
        DCB     0
HOn_Help
        DCB     "*HOn switches the hourglass on", 13
HOn_Syntax
        DCB     "Syntax: *HOn", 0
HOff_Help
        DCB     "*HOff switches the hourglass off", 13
HOff_Syntax
        DCB     "Syntax: *HOff", 0
      ]
        ALIGN

HOn_Code
        MOV     R6, LR
        MOV     R0, #1
        MOV     R1, #-1
        SWI     XWimp_SetPointerShape
        SWIVC   XHourglass_On
        MOV     PC, R6

HOff_Code
        MOV     R6, LR
        SWI     XHourglass_Smash
        MOV     PC, R6

FlagsTable
        [ :LNOT: No32bitCode
        DCD     ModuleFlag_32bit
        |
        DCD     0
        ]

      [ debug
        InsertNDRDebugRoutines
      ]

InitialisationCode ROUT
      [ debug
        Debug_Open "<Hourglass$Debug>1"
        Debug   swientry, "Module initialisation"
      ]
        Push    "r0-r2, lr"                             ; Push the same registers as Service
        LDR     r2, [ r12 ]                             ; Is our workspace here already?
        TEQ     r2, #0                                  ; If not this will be zero
        BNE     SoftInitialisation                      ; Don't claim if we already have workspace
        MOV     r0, #ModHandReason_Claim                ; Claim some workspace
        MOV     r3, #RAMSpaceRequired                   ; We need this much free space
        SWI     XOS_Module                              ; Claim RMA
        BVS     ErrorExitInit
        STR     r2, [ r12 ]                             ; Update the private word
SoftInitialisation
        MOV     wp, r2                                  ; Now point to my workspace
InitialiseWorkspace
        MOV     r14, #bignum
        STR     r14, PercentageDepth
        MOV     r14, #0
        STR     r14, HourglassDepth
        STRB    r14, UpdateSemaphore
        ADR     r0, OSWord15BlockData                   ; Set up OSWord block in my workspace
        LDMIA   r0, { r1, r2 }
        ADR     r0, OSWord15Block-2
        STMIA   r0, { r1, r2 }
        ADR     r0, HourglassData
        STR     r0, Block_DataPtr
        BL      InitialisePointerInfo
ErrorExitInit
        STRVS   r0, [ sp, #0 ]
ExitInit
        Pull    "r0-r2, pc"

OSWord15BlockData
        DCB     0                                       ; two dummy bytes so that the
        DCB     0                                       ; data pointer is on a word boundary
        DCB     OWPointerAndMouse_SetPointerShape       ; Reason code: program pointer shape
        DCB     3                                       ; Initial pointer number
                                                        ; (this toggles between 3 and 4)
        DCB     BytesPerLine
        DCB     HeightInPixels
        DCB     ActiveX
        DCB     ActiveY
        ALIGN

DefaultColours
        DCD     DefaultColour1
        DCD     DefaultColour3

FinalisationCode ROUT
        Debug   swientry, "Module finalisation"
        LDR     wp, [ r12 ]
        Push    "lr"
        BL      HourglassSmash
      [ debug
        Debug_Close
      ]
        Pull    "pc"

        ASSERT  Service_Error < Service_Reset
ServiceCallTable
        DCD     0
        DCD     ServiceCallEntry - Module_BaseAddr
        DCD     Service_Error
        DCD     Service_Reset
        DCD     0

        DCD     ServiceCallTable - Module_BaseAddr
ServiceCall     ROUT
        MOV     r0, r0
        TEQ     r1, #Service_Reset
        TEQNE   r1, #Service_Error
        MOVNE   pc, lr

ServiceCallEntry
        LDR     wp, [ r12 ]                             ; get my private word
        TEQ     r1, #Service_Error
        BEQ     HourglassSmash                          ; All errors turn off the hourglass

DoServiceReset
        Push    "r0-r2, lr"
        MOV     r0, #OsByte_RW_LastResetType            ; Now check reset was NOT hard
        MOV     r1, #0                                  ; Read last reset type,
        MOV     r2, #255
        SWI     XOS_Byte                                ; only do reset when it was soft
        BVS     ErrorExitInit
        TEQ     r1, #0                                  ; Was it a soft-reset
        BNE     ExitInit                                ; No, it was hard, so exit
        B       InitialiseWorkspace

SWIHandlerCode  ROUT
        LDR     wp, [ r12 ]
        CMP     r11, #(EndOfJumpTable - SWIJumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        B       UnknownSWIError
SWIJumpTable
        B       HourglassOn
        B       HourglassOff
        B       HourglassSmash
        B       HourglassStart
        B       HourglassPercentage
        B       HourglassLEDs
        B       HourglassColours
EndOfJumpTable

 ASSERT HourglassSWICheckValue-Hourglass_On=(EndOfJumpTable - SWIJumpTable)/4

UnknownSWIError
        Push    "r1-r7, lr"
        ADR     r0, ErrorBlock_ModuleBadSWI
        MOV     r1, #0                                  ; No message block
        MOV     r2, #0                                  ; No buffer
        ADR     r4, TitleString
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        Pull    "r1-r7, pc"

        MakeInternatErrorBlock ModuleBadSWI,,BadSWI

; *****************************************************************************
;
;       HourglassOn - Turn on after default startup delay
;
; in:   -
;
; out:  -
;

HourglassOn Entry "r0"
        Debug   swientry, "Hourglass_On"
        MOV     r0, #StartupDelay
        BL      HourglassStart
        EXIT    VC
        STR     r0, [ sp ]
        EXIT

; *****************************************************************************
;
;       HourglassStart - Turn on after specified delay
;       If already on, just increment depth count
;
; in:   R0 = delay in centiseconds (0 => never update hourglass)
;
; out:  -
;

HourglassStart Entry "r0-r2,r11"
        Debug   swientry, "Hourglass_Start, R0 =", r0

        LDR     r11, HourglassDepth
        Debug   depth, "Hourglass_Start: old HourglassDepth =", r11
        ADD     r11, r11, #1                            ; update my depth count
        STR     r11, HourglassDepth

        LDR     r1, HourglassTimer
        CMP     r11, #1                                 ; update the hourglass timer if this is the first level
        CMPHI   r0, r1                                  ; or if a deeper level is requesting an even earlier display
        STRLS   r0, HourglassTimer

        CMP     r11, #1                                 ; that's all we need to do unless this is the first level
        EXIT    HI

        BL      InitialisePointerInfo

        MOV     r0, #TickerV                            ; get on TickerV
        ADR     r1, MyTickRoutine                       ; to do things
        MOV     r2, wp
        SWI     XOS_Claim
        EXIT    VC
        STR     r0, [ sp ]
        EXIT

; *****************************************************************************
;
;       HourglassOff - If at outer level, turn off hourglass, else dec depth
;
; in:   -
;
; out:  -
;

HourglassOff Entry "r0-r3, r10"
        Debug   swientry, "Hourglass_Off"

        LDR     r10, HourglassDepth
        Debug   depth, "Hourglass_Off: old HourglassDepth =", r10
        LDR     r14, PercentageDepth                    ; turn off percentage if we're at the controlling depth now
        TEQ     r10, r14
        MOVEQ   r14, #-1
        STREQB  r14, NewPercentage
        MOVEQ   r14, #bignum                            ; also reset PercentageDepth so we can turn it on again next time
        STREQ   r14, PercentageDepth
        SUBS    r10, r10, #1                            ; update my depth count
        STRCS   r10, HourglassDepth                     ; store back if wasn't already zero
        EXIT    NE                                      ; if not bottom, leave alone

        MOV     r0, #TickerV                            ; get off TickerV
        ADR     r1, MyTickRoutine
        MOV     r2, wp
        SWI     XOS_Release

        LDRB    r0, PointerDirty                        ; have we set up shape yet ?
        TEQ     r0, #0

        BLEQ    RestorePointer                          ; yes - undo it
        EXIT

; *****************************************************************************
;
;       HourglassSmash - Unconditionally turn off hourglass
;
; in:   -
;
; out:  -
;

HourglassSmash Entry "r0"
        Debug   swientry, "Hourglass_Smash"

        LDR     r0, HourglassDepth
        Debug   depth, "Hourglass_Smash: old HourglassDepth =", r0
        TEQ     r0, #0                                  ; if at top, ignore

        MOVNE   r0, #1                                  ; depth count becomes one
        STRNE   r0, HourglassDepth
        MOVNE   r0, #bignum
        STRNE   r0, PercentageDepth
        Debug swientry, "r10 on entry =", r10
        BLNE    HourglassOff                            ; to force turn-off
        Debug swientry, "r10 on exit =", r10
        EXIT    VC
        STR     r0, [sp]
        EXIT

; *****************************************************************************
;
;       HourglassPercentage - Set percentage figures
;
; in:   R0 = percentage to display, outside 0-99 to turn figures off
;
; out:  -
;

HourglassPercentage Entry "r1"
        Debug   swientry, "Hourglass_Percentage, percentage =", r0

        LDR     r14, HourglassDepth
        LDR     r1, PercentageDepth
        CMP     r14, r1                                 ; Are we at or below the controlling depth?
        STRLT   r14, PercentageDepth                    ; if so, we can set the percentage
        STRLEB  r0, NewPercentage

        LDRB    r14, NewPercentage                      ; if percentages were turned off,
        CMP     r14, #100                               ; re-enable percentage changes at lower levels
        MOVHS   r14, #bignum
        STRHS   r14, PercentageDepth

        EXIT

; *****************************************************************************
;
;       HourglassLEDs - Set LED states (currently 2 of them)
;
; in:   R0 = EOR mask
;       R1 = AND mask
;
; out:  R0 = old LED state
;

HourglassLEDs Entry "r10, r11"
        Debug   swientry, "Hourglass_LEDs, R0,R1 =", r0, r1

        LDRB    r10, NewLEDs                            ; read previous values
        AND     r11, r1, r10
        EOR     r0, r0, r11
        STRB    r0, NewLEDs                             ; store new value
        MOV     r0, r10                                 ; return old value
        EXIT

; *****************************************************************************
;
;       HourglassColours - Set the colours used for the hourglass
;
; in:   R0 = New colour to use as colour 1 (-1 for no change)
;       R1 = New colour to use as colour 3 (-1 for no change)
;
; out:  R0 = Old colour that was being used as colour 1
;       R1 = Old colour that was being used as colour 3
;

HourglassColours Push "r0, r1, r14"
        Debug   swientry, "Hourglass_Colours, new colours 1,3 =", r0, r1

        LDR     r14, NextHColour1                       ; Save the old value of Colour1
        STR     r14, [ sp, #0 ]                         ; Put old value in exit stack frame
        LDR     r14, NextHColour3                       ; Save the old value of Colour3
        STR     r14, [ sp, #4 ]                         ; Put old value in exit stack frame
        CMP     r0, #-1                                 ; Are we changing this colour(1)?
        STRNE   r0, NextHColour1                        ; Put down the new value
        CMP     r1, #-1                                 ; Are we changing this colour(3)?
        STRNE   r1, NextHColour3                        ; Put down the new value
        CMP     pc, pc                                  ; clears V in 32-bit modes, sets Z if in 32-bit mode
        Pull    "r0, r1, pc",EQ                         ; Return with V clear (32-bit)
        Pull    "r0, r1, pc",,^                         ; Return with V clear (26-bit)

; *****************************************************************************
;
;       MyTickRoutine - TickerV routine
;

MyTickRoutine ROUT
        Push    "lr"
        LDRB    r14, UpdateSemaphore
        TEQ     r14, #0                                 ; Are we already doing this?
        Pull    "pc", NE                                ; Yes, so stay out
        INC     r14
        STRB    r14, UpdateSemaphore
        LDR     r14, HourglassTimer
        SUBS    r14, r14, #1                            ; decrement timer
        MOVEQ   r14, #UpdateDelay                       ; if now zero, reset timer
        STRCS   r14, HourglassTimer                     ; if wasn't zero before, store back
        BNE     ExitTickRoutine                         ; exit if not zero now
        Push    "r0-r6"
        WritePSRc SVC_mode,r0,,r6
        Push    "r14"                                   ; save SVC r14
        LDRB    r0, PointerDirty                        ; if pointer shape needs setting up
        TEQ     r0, #0
        DebugIf NE, swientry, "Hourglass being shown"
        BLNE    SetupPointer                            ; then do it
        BL      FillHourglass                           ; some sand falls
        BL      SetupPercentage
        BL      SetupLEDs
        BL      ProgramPointer                          ; and show the world
        Pull    "r14"                                   ; restore SVC r14
        RestPSR r6,,cf                                  ; restore the mode
        Pull    "r0-r6"
ExitTickRoutine
        MOV     r14, #0
        STRB    r14, UpdateSemaphore
        Pull    "pc"

; *****************************************************************************
;
;       SetupPointer - Program initial shape of hourglass etc
;       Called only when the pointer is dirty - ie first time through ticker routine
;
; in:   -
;
; out:  R0-R5 may be corrupted
;

SetupPointer ROUT
        Push    "lr"

        MOV     r0, #-1
        STRB    r0, OldPercentage
        STRB    r0, NewPercentage

        ADR     r0, HourglassData
        ADRL    r1, HourglassShape
        ADRL    r2, HourglassShapeEnd
10
        LDR     r3, [r1], #4
        STR     r3, [r0], #4
        TEQ     r1, r2
        BNE     %BT10

        ADR     r2, HourglassDataEnd
        MOV     r3, #0
20
        STR     r3, [r0], #4
        TEQ     r0, r2
        BNE     %BT20

        STRB    r3, HourglassState                      ; zero hourglass state
        STRB    r3, PointerDirty                        ; pointer now clean

        Pull    "pc"

; *****************************************************************************
;
;       FillHourglass - Go to next state of hourglass
;
; in:   -
;
; out:  R0-R3 corrupted
;

FillHourglass ROUT
        LDRB    r0, HourglassState
        ADD     r0, r0, #1                              ; go to next state
        TEQ     r0, #6                                  ; keep in range 0..5
        MOVEQ   r0, #0
        STRB    r0, HourglassState

        ADRL    r1, DiffOffsetTable
        LDR     r0, [r1, r0, LSL #2]                    ; load offset to diff table
        ADD     r0, r0, r1                              ; convert to address
        ADR     r3, HourglassData
        LDR     r1, [r0], #4
10
        MOV     r2, r1, LSR #16
        STRB    r2, [r3, r2, LSR #8]
        EOR     r2, r1, r2, LSL #16
        STRB    r2, [r3, r2, LSR #8]

        LDR     r1, [r0], #4
        TEQ     r1, #0
        BNE     %BT10
        MOV     pc, lr

; *****************************************************************************
;
;       SetupLEDs - Set up LED data in hourglass shape
;
; in:   -
;
; out:  R0-R3 corrupted
;

        ASSERT HgSize = 16
        ASSERT HgY > 0
        ASSERT (HgX :MOD: PixelsPerByte) = 0

SetupLEDs ROUT
        LDRB    r0, OldLEDs
        LDRB    r1, NewLEDs
        TEQ     r0, r1
        MOVEQ   pc, r14

        STRB    r1, OldLEDs
        ADR     r2, HourglassData+(HgX/PixelsPerByte)+((HgY-1)*BytesPerLine)
        TST     r1, #1
        MOVNE   r3, #&FF
        MOVEQ   r3, #&55
        STRB    r3, [r2, #0]
        STRB    r3, [r2, #1]
        STRB    r3, [r2, #2]
        STRB    r3, [r2, #3]

        ADD     r2, r2, #(HgSize+1)*BytesPerLine
        TST     r1, #2
        MOVNE   r3, #&FF
        MOVEQ   r3, #&55
        STRB    r3, [r2, #0]
        STRB    r3, [r2, #1]
        STRB    r3, [r2, #2]
        STRB    r3, [r2, #3]

        MOV     pc, lr

; *****************************************************************************
;
;       SetupPercentage - Set up percentage digits in hourglass shape
;
; in:   -
;
; out:  R0-R3 corrupted
;

SetupPercentage ROUT
        LDRB    r1, OldPercentage
        LDRB    r2, NewPercentage
        TEQ     r1, r2
        MOVEQ   pc, r14

        Push    "r14"
        STRB    r2, OldPercentage
        CMP     r2, #100
        BHS     %f1                                     ; turn it off
        MOV     r1, #10
        DivRem  r0, r2, r1, r14
        ADRL    r3, ChDefNumbers
 ASSERT  CharHeight = 9
        ADD     r1, r0, r0, LSL #3  ; * 9
        ADD     r1, r3, r1, LSL #1
        ADR     r0, HourglassData+(PercX/PixelsPerByte)+(PercY * BytesPerLine)
        BL      SetupChar
        ADD     r1, r2, r2, LSL #3  ; * 9
        ADD     r1, r3, r1, LSL #1
        ADD     r0, r0, #8 / PixelsPerByte
        BL      SetupChar
        ADRL    r1, ChDefPercent
        ADD     r0, r0, #8 / PixelsPerByte
        BL      SetupChar
        Pull    "pc"
1
        ADR     r0, HourglassData+(PercX/PixelsPerByte)+(PercY * BytesPerLine)
      [ debug
        ADRL    r1, ChDefSpace
      |
        ADR     r1, ChDefSpace
      ]
        BL      SetupChar
        ADD     r0, r0, #8 / PixelsPerByte
        BL      SetupChar
        ADD     r0, r0, #8 / PixelsPerByte
        BL      SetupChar
        Pull    "pc"

; *****************************************************************************
;
;       SetupChar - Copy character definition into hourglass shape
;
; in:   R0 = address of top left of character in hourglass
;       R1 = address of first byte of character definition
;

SetupChar ROUT
        Push    "r0-r2, lr"
        MOV     r2, #9
SetupCharLoop
        LDRB    r14, [r1], #1
        STRB    r14, [r0], #1
        LDRB    r14, [r1], #1
        STRB    r14, [r0], #BytesPerLine-1
        SUBS    r2, r2, #1
        BNE     SetupCharLoop
        Pull    "r0-r2, pc"

; *****************************************************************************
;
;       ProgramPointer - Call OS_Word to define pointer shape
;

ProgramPointer ROUT
        Push    "r0-r6, lr"

        LDRB    r0, Block_PointerNumber
        EOR     r0, r0, #(3 :EOR: 4)
        STRB    r0, Block_PointerNumber

        MOV     r0, #OsWord_DefinePointerAndMouse
        ADR     r1, OSWord15Block
        SWI     XOS_Word                                ; reprogram our pointer

        ADR     r0, NextHColours
        LDMIA   r0, { r3, r4 }
        ADR     r0, CurrentColours
        LDMIA   r0, { r5, r6 }

        TEQ     r5, r3                                  ; set the colour(s)/number for the next frame
        TEQEQ   r6, r4                                  ; avoid reprogramming colours unless strictly necessary
        BEQ     %FT10
        MOV     r0, #OsByte_Wait                        ; at least one needs changing, so wait until VSync
        SWI     XOS_Byte
        MOV     r0, #PaletteV
        ADR     r1, MyPaletteVRoutine
        MOV     r2, r12                                 ; get off PaletteV
        SWI     XOS_Release                             ; so that we don't end up setting ReturnColour
        MOV     r0, #1
        TEQ     r5, r3
        MOVNE   r1, r3
        BLNE    SetColour ; logical Colour 1
        MOV     r0, #3
        TEQ     r6, r4
        MOVNE   r1, r4
        BLNE    SetColour ; logical Colour 3
        MOV     r0, #PaletteV
        ADR     r1, MyPaletteVRoutine
        MOV     r2, r12
        SWI     XOS_Claim                               ; get on PaletteV to catch other people setting pointer colours
        ADR     r0, CurrentColours
        STMIA   r0, { r3, r4 }                          ; update our idea of the current colour
10
        MOV     r0, #OsByte_SelectPointer
        LDRB    r1, Block_PointerNumber
        SWI     XOS_Byte ; on exit, R1 is old shape/linkage
        AND     r1, r1, #&FF

        CMP     r1, #3                                  ; if we weren't the last to set a colour/number,
        STRLOB  r1, ReturnPointer                       ; remember the current one for when we switch off

        Pull    "r0-r6, pc"

        LTORG

; *****************************************************************************
;
;       SetColour - Program a pointer colour
;
; in:   R0 = pointer colour to program (1..3)
;       R1 = value to program &00BBGGRR
;
; out:  -
;

SetColour ROUT
        Push    "r0-r1, lr"
        ORR     r0, r0, r1, LSL #16
        ORR     r0, r0, #&1900
        MOV     r14, r1, LSR #16
        Push    "r0, r14"                               ; Put data in to a stack frame
        MOV     r1, sp                                  ; Address of recently stored data
        MOV     r0, #OsWord_WritePalette
        SWI     XOS_Word
        ADD     sp, sp, #8                              ; Trash stack frame
        Pull    "r0-r1, pc"

; *****************************************************************************
;
;       InitialisePointerInfo - sets up colour, number etc information
;
; in:   -
;
; out:  Registers preserved.

InitialisePointerInfo Entry "r0-r2"
        BL      ReadPointerColours                      ; get CurrentColours

        ADR     r0, CurrentColours                      ; Return = Current
        LDMIA   r0, { r1, r2 }
        ADR     r0, ReturnColours
        STMIA   r0, { r1, r2 }

        MOV     r0, #PaletteV
        ADR     r1, MyPaletteVRoutine
        MOV     r2, r12
        SWI     XOS_Claim                               ; get on PaletteV to catch other people setting pointer colours

        MOV     r0, #1
        STRB    r0, ReturnPointer ; mustn't read current pointer
                                  ; number here, it causes flicker

        ADRL    r0, DefaultColours                      ; NextH = Default
        LDMIA   r0, { r1, r2 }
        ADR     r0, NextHColours
        STMIA   r0, { r1, r2 }

        MOV     r0, #1
        STRB    r0, PointerDirty                        ; indicate shape needs setting up

        MOV     r0, #0
        STRB    r0, OldLEDs
        STRB    r0, NewLEDs

        EXIT

; *****************************************************************************
;
;       RestorePointer - changes pointer number and colours back to the "off" values.
;
; in:   -
;
; out:  Registers preserved.

RestorePointer Entry "r0-r4,r10-r11"
        MOV     r0, #OsByte_SelectPointer               ; restore old pointer iff it was most recently changed by us
        LDRB    r1, ReturnPointer
        SWI     XOS_Byte ; on exit, R1 is old shape/linkage
        AND     r3, r1, #&FF
        CMP     r3, #3
        SWILO   XOS_Byte ; Oops, shouldn't have done that
                         ; because someone else had changed
                         ; the pointer - switch it back.
                         ; Having pointer-switch flicker
                         ; here is far better than having it
                         ; during a pre-emptive read routine.

        MOV     r0, #PaletteV
        ADR     r1, MyPaletteVRoutine
        MOV     r2, r12
        SWI     XOS_Release                             ; get off PaletteV

        LDR     r10, ReturnColour1
        LDR     r11, ReturnColour3
        LDR     r3, CurrentColour1
        LDR     r4, CurrentColour3
        TEQ     r3, r10
        TEQEQ   r4, r11
        MOVNE   r0, #OsByte_Wait                        ; at least one needs changing, so wait until VSync
        SWINE   XOS_Byte                                ; if called R1, R2 trashed

        MOV     r0, #1
        TEQ     r3, r10
        LDRNE   r1, ReturnColour1
        BLNE    SetColour ; logical Colour 1

        MOV     r0, #3
        TEQ     r4, r11
        LDRNE   r1, ReturnColour3
        BLNE    SetColour ; logical Colour 3

        EXIT

; *****************************************************************************
;
;       ReadPointerColours - read the current pointer number and colours 1 & 3
;       The colours are stored in CurrentColour1 and CurrentColour3.
;
; in:   -
;
; out:  Registers preserved.

ReadPointerColours Entry "r0-r3"
        MOV     r0, #1
        MOV     r1, #25
        SWI     XOS_ReadPalette
        MOVVC   r2, r2, LSR #8
        STRVC   r2, CurrentColour1
        Debug   current, "Current colour 1 =", r2

        MOV     r0, #3
        MOV     r1, #25
        SWI     XOS_ReadPalette
        MOVVC   r2, r2, LSR #8
        STRVC   r2, CurrentColour3
        Debug   current, "Current colour 3 =", r2

        EXIT

; *****************************************************************************
;
;       MyPaletteVRoutine - take note of anyone else changing the pointer colours
;

MyPaletteVRoutine
        TEQ     r4, #2          ; 'set palette entry'
        TEQNE   r4, #8          ; or 'write palette entries' reason codes?
        MOVNE   pc, lr          ; no, exit

        TST     r4, r4, LSR #4
        TEQCC   r1, #25
        MOVNE   pc, lr          ; 'set palette entry' not for pointer - exit
        BCS     %FT50           ; more work needed for 'write palette entries'

        Push    "lr"
        MOV     lr, r2, LSR #8
        TEQ     r0, #1          ; colour 1?
        STREQ   lr, ReturnColour1
        STREQ   lr, CurrentColour1
        TEQ     r0, #3          ; colour 13
        STREQ   lr, ReturnColour3
        STREQ   lr, CurrentColour3
        Pull    "pc"
50
        Push    "lr"
        MOV     lr, r1, LSR #24
        TEQ     lr, #25         ; setting pointer colours?
        Pull    "pc", NE        ; no, exit
      [ {TRUE}
        TEQ     r0, #0          ; the kernel doesn't like r0=0
        Pull    "pc", EQ        ; so for compatibility, don't make it work when the hourglass is on either
      ]
        Push    "r0-r4"
        BIC     lr, r1, #&FF000000 ; number of colours programmed
        MOV     r3, #0          ; colour index counter
51
      [ {TRUE}
        LDR     r1, [r0], #4
      |
        TEQ     r0, #0
        LDRNE   r1, [r0], #4    ; if list of logical colours, load logical colour
        MOVEQ   r1, r3          ; else logical colour = index
      ]

        TEQ     r1, #1
        TEQNE   r1, #3          ; if we're interested
        LDREQ   r4, [r2], #4    ; then load colour
        ADDNE   r2, r2, #4      ; else skip this entry
        MOVEQ   r4, r4, LSR #8

        TEQ     r1, #1          ; colour 1?
        STREQ   r4, ReturnColour1
        STREQ   r4, CurrentColour1
        TEQ     r1, #3          ; colour 13
        STREQ   r4, ReturnColour3
        STREQ   r4, CurrentColour3

        ADD     r3, r3, #1
        TEQ     r3, lr
        BNE     %BT51
        Pull    "r0-r4,pc"

; *****************************************************************************

; Shape data

HourglassShape
        DCB     &00, &55, &55, &55, &55, &00
        DCB     &00, &55, &55, &55, &55, &00
        DCB     &00, &55, &55, &55, &55, &00
        DCB     &00, &FD, &FF, &FF, &7F, &00
        DCB     &00, &74, &55, &55, &1D, &00
        DCB     &00, &D0, &55, &55, &07, &00
        DCB     &00, &40, &57, &D5, &01, &00
        DCB     &00, &00, &5D, &75, &00, &00
        DCB     &00, &00, &74, &1D, &00, &00
        DCB     &00, &00, &D0, &07, &00, &00
        DCB     &00, &00, &D0, &07, &00, &00
        DCB     &00, &00, &F4, &1F, &00, &00
        DCB     &00, &00, &FD, &7F, &00, &00
        DCB     &00, &40, &FF, &FF, &01, &00
        DCB     &00, &D0, &FF, &FF, &07, &00
        DCB     &00, &F4, &FF, &FF, &1F, &00
        DCB     &00, &FD, &FF, &FF, &7F, &00
        DCB     &00, &55, &55, &55, &55, &00
        DCB     &00, &55, &55, &55, &55, &00
        DCB     &00, &55, &55, &55, &55, &00
        ALIGN
HourglassShapeEnd

DiffOffsetTable
        &       ShapeDiffs0-DiffOffsetTable
        &       ShapeDiffs1-DiffOffsetTable
        &       ShapeDiffs2-DiffOffsetTable
        &       ShapeDiffs3-DiffOffsetTable
        &       ShapeDiffs4-DiffOffsetTable
        &       ShapeDiffs5-DiffOffsetTable

ShapeDiffs0
        DCB     &74,&19, &55,&1A, &55,&1B, &1D,&1C, &55,&20, &55,&21
        DCB     &57,&26, &D5,&27, &5D,&2C, &75,&2D, &74,&32, &1D,&33
        DCB     &F4,&44, &1F,&45, &FD,&4A, &7F,&4B, &FF,&50, &FF,&51
        DCB     &FF,&56, &FF,&57, &F4,&5B, &FF,&5C, &FF,&5D, &1F,&5E
        DCB     &00,&00, &00,&00

ShapeDiffs1
        DCB     &F4,&19, &FF,&1A, &FF,&1B, &1F,&1C, &7F,&5C, &FD,&5D
        DCB     &00,&00, &00,&00

ShapeDiffs2
        DCB     &FF,&20, &FF,&21, &7F,&56, &FD,&57, &5F,&5C, &F5,&5D
        DCB     &00,&00, &00,&00

ShapeDiffs3
        DCB     &FF,&26, &FF,&27, &7F,&50, &FD,&51, &5F,&56, &F5,&57
        DCB     &57,&5C, &D5,&5D, &00,&00, &00,&00

ShapeDiffs4
        DCB     &FD,&2C, &7F,&2D, &7D,&4A, &7D,&4B, &5F,&50, &F5,&51
        DCB     &57,&56, &D5,&57, &55,&5C, &55,&5D, &00,&00, &00,&00

ShapeDiffs5
        DCB     &F4,&32, &1F,&33, &74,&44, &1D,&45, &5D,&4A, &75,&4B
        DCB     &57,&50, &D5,&51, &55,&56, &55,&57, &74,&5B, &1D,&5E
        DCB     &00,&00, &00,&00

ChDefSpace
        DCD     0, 0, 0, 0, 0

ChDefNumbers
    = &55,&55,&F5,&5F,&7D,&7D,&7D,&7D,&7D,&7D,&7D,&7D,&7D,&7D,&F5,&5F,&55,&55
    = &55,&55,&D5,&57,&F5,&57,&D5,&57,&D5,&57,&D5,&57,&D5,&57,&FD,&7F,&55,&55
    = &55,&55,&F5,&5F,&7D,&7D,&55,&7D,&55,&5F,&D5,&57,&F5,&55,&FD,&7F,&55,&55
    = &55,&55,&F5,&5F,&7D,&7D,&55,&7D,&D5,&5F,&55,&7D,&7D,&7D,&F5,&5F,&55,&55
    = &55,&55,&55,&5F,&D5,&5F,&F5,&5F,&7D,&5F,&FD,&7F,&55,&5F,&55,&5F,&55,&55
    = &55,&55,&FD,&7F,&7D,&55,&FD,&5F,&55,&7D,&55,&7D,&7D,&7D,&F5,&5F,&55,&55
    = &55,&55,&D5,&5F,&F5,&55,&7D,&55,&FD,&5F,&7D,&7D,&7D,&7D,&F5,&5F,&55,&55
    = &55,&55,&FD,&7F,&55,&7D,&55,&5F,&D5,&57,&F5,&55,&F5,&55,&F5,&55,&55,&55
    = &55,&55,&F5,&5F,&7D,&7D,&7D,&7D,&F5,&5F,&7D,&7D,&7D,&7D,&F5,&5F,&55,&55
    = &55,&55,&F5,&5F,&7D,&7D,&7D,&7D,&F5,&7F,&55,&7D,&55,&5F,&F5,&57,&55,&55

ChDefPercent
    = &55,&55,&7D,&55,&7D,&7D,&55,&5F,&D5,&57,&F5,&55,&7D,&7D,&55,&7D,&55,&55

        ALIGN
        END
@


4.7
log
@Internationalised the command help and syntax
Deleted RISC OS 2 support. Use defines from OS_Byte and OS_Word headers.
Tested in a ROM build, help and syntax looked OK.

Version 2.18. Tagged as 'Hourglass-2_18'
@
text
@d1073 1
a1073 1
    = &55,&55,&F5,&5F,&7D,&7D,&7D,&7F,&FD,&7F,&FD,&7D,&7D,&7D,&F5,&5F,&55,&55
@


4.6
log
@  Bugfix for pointer colour restoration.
Detail:
  In Ursula, functionality was added such that if anyone else changes the
  pointer colours (except via SWI Hourglass_Colours) then the Hourglass module
  remembered the change, and re-applied it when the hourglass was turned off.
  The problem was that it determines that the colours have been changed by
  reading the colours in use at each animation stage, and comparing them with
  those that it programmed most recently. We got away with this in the final
  Ursula version (and in a branched version, derived thereof) because the
  hourglass used unusual colours; however, we've picked up an intermediate
  version that still has a RISC OS 3 style hourglass, with pointer colour 1
  being full intensity cyan - /the same as the default Wimp pointer colour 1/.
  This means that the hourglass ignored the Wimp's initial programming of
  pointer colour 1, and restored it to black at the end of the boot sequence.
  The solution I have used is to install a routine on PaletteV, and note
  the pointer colours being programmed (either singly or in bulk) directly.
Admin:
  Tested on Tungsten.

Version 2.16. Tagged as 'Hourglass-2_16'
@
text
@d27 2
d50 1
a50 1
bignum          * &3FFFFFFF                             ; A large number to put into PercentageDepth
d52 4
a55 5
; RISC OS 2 compatibility
    [ :LNOT: :DEF: OldOs
        GBLL    OldOs
OldOs   SETL    {FALSE}
    ]
a85 7
WaitForVSync    * 19

SetPointer      * 106
NoPointer       * 0
PointerOSWord   * 21
WritePalette    * 12

d150 5
a154 1
        DCD     0                                       ; MessagesFile
a156 6

        [       OldOs
UnknownSWIErrorMsg
        DCD     ErrorNumber_ModuleBadSWI
        DCB     "SWI value out of range for module "
        ]
d174 18
a191 2
        Command "HOn", 0, 0
        Command "HOff", 0, 0
d201 1
d265 1
a265 1
        DCB     0                                       ; Reason code: program pointer shape
d310 1
a310 1
        MOV     r0, #253                                ; Now check reset was NOT hard
a336 4
        [       OldOs
        ADR     r0, UnknownSWIErrorMsg
        ORRS    pc, lr, #V_bit
        |       ; OldOs
d348 1
a348 2
        MakeErrorBlock     ModuleBadSWI
        ]       ; OldOs
d763 1
a763 1
        MOV     r0, #PointerOSWord
d775 1
a775 1
        MOV     r0, #WaitForVSync                       ; at least one needs changing, so wait until VSync
d796 1
a796 1
        MOV     r0, #SetPointer
d825 1
a825 1
        MOV     r0, #WritePalette
d878 1
a878 1
        MOV     r0, #SetPointer                         ; restore old pointer iff it was most recently changed by us
d901 1
a901 1
        MOVNE   r0, #WaitForVSync                       ; at least one needs changing, so wait until VSync
@


4.5
log
@Addition of Hon and Hoff commands.
Currently the help text is not internationalised :-(

Version 2.15. Tagged as 'Hourglass-2_15'
@
text
@d34 1
d104 1
a104 1
NextHColours            #       0                       ; Colours to reassert at next frame update
d107 1
a107 4
LastHColours            #       0                       ; Colours set at last frame update
LastHColour1            #       4
LastHColour3            #       4
CurrentColours          #       0                       ; Colours actually in use
d110 1
a585 1
      [ debug
a587 4
      |
        ADR     r1, HourglassShape
        ADR     r2, HourglassShapeEnd
      ]
a621 1
      [ debug
a622 3
      |
        ADR     r1, DiffOffsetTable
      ]
a698 1
      [ debug
a699 3
      |
        ADR     r3, ChDefNumbers
      ]
a762 2
        BL      ReadPointerColours                      ; get CurrentColours

d770 7
a776 2
        MOVNE   r0, #WaitForVSync                       ; at least one needs changing, so wait until VSync
        SWINE   XOS_Byte
d785 7
a798 8
        ADR     r0, LastHColours
        LDMIA   r0, { r1, r2 }
        TEQ     r5, r1
        STRNE   r5, ReturnColour1
        TEQ     r6, r2
        STRNE   r6, ReturnColour3

        STMIA   r0, { r3, r4 }                          ; LastHColours = NextHColours
d841 6
a855 4
        MOV     r0, #-1                                 ; LastH = -1 (ie guaranteed != current)
        STR     r0, LastHColour1
        STR     r0, LastHColour3

a873 2
        BL      ReadPointerColours                      ; get CurrentColours

d886 7
a892 2
        LDR     r10, LastHColour1                       ; restore old colour(s) iff they were most recently changed by us
        LDR     r11, LastHColour3
d896 3
a898 3
        TEQNE   r4, r11
        MOVEQ   r0, #WaitForVSync                       ; at least one needs changing, so wait until VSync
        SWIEQ   XOS_Byte                                ; if called R1, R2 trashed
d902 2
a903 2
        LDREQ   r1, ReturnColour1
        BLEQ    SetColour ; logical Colour 1
d907 2
a908 2
        LDREQ   r1, ReturnColour3
        BLEQ    SetColour ; logical Colour 3
d937 63
@


4.4
log
@Merged in version bavison_Hourglass_213 (on the Ursula branch).

Version 2.14. Tagged as 'Hourglass-2_14'
@
text
@d29 1
d145 1
a145 1
ModuleStart
d147 6
a152 6
        DCD     InitialisationCode-ModuleStart
        DCD     FinalisationCode-ModuleStart
        DCD     ServiceCall-ModuleStart
        DCD     TitleString-ModuleStart
        DCD     HelpString-ModuleStart
        DCD     0                                       ; HelpAndCommandKeywordTable
d154 2
a155 2
        DCD     SWIHandlerCode-ModuleStart
        DCD     SWIDecodingTable-ModuleStart
d158 1
a158 1
        DCD     FlagsTable-ModuleStart
d182 27
d283 1
a283 1
        DCD     ServiceCallEntry - ModuleStart
d288 1
a288 1
        DCD     ServiceCallTable - ModuleStart
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 2.13. Tagged as 'Hourglass-2_13'
@
text
@d28 1
d32 14
d99 12
a110 5
OldColour1              #       4
OldColour3              #       4
NewColours              #       0
NewColour1              #       4
NewColour3              #       4
d119 1
a119 1
OldPointer              #       1                       ; Pointer no. the user was using
d188 4
d193 4
d220 1
a220 4
        ADR     r0, DefaultColours
        LDMIA   r0, { r1, r2 }
        ADR     r0, NewColours
        STMIA   r0, { r1, r2 }
d243 1
d245 6
a250 26

        LDR     r0, HourglassDepth                      ; any hourglasses around ?
        CMP     r0, #0
        MOVEQ   pc, lr

        Push    lr
        MOV     r0, #TickerV                            ; get off TickerV
        ADR     r1, MyTickRoutine
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r0, #SetPointer                         ; restore old pointer
        LDRB    r1, OldPointer
        SWI     XOS_Byte

        MOV     r0, #WaitForVSync
        SWI     XOS_Byte                                ; reprogram palette only during flyback

        MOV     r0, #1                                  ; logical Colour 1
        LDR     r1, OldColour1
        BL      SetColour

        MOV     r0, #3                                  ; logical Colour 3
        LDR     r1, OldColour3
        BL      SetColour
        Pull    pc
d328 2
a329 2
HourglassOn ROUT
        Push    "r0, lr"
d332 3
a334 2
        STRVS   r0, [ sp ]
        Pull    "r0, pc"
d346 3
a348 1
HourglassStart ROUT
d350 1
a352 2
        CMP     r11, #1                                 ; on 1st entry, really do something
        MOVHI   pc, lr
d354 4
a357 2
        Push    "r0-r2, lr"
        STR     r0, HourglassTimer                      ; the startup delay
d359 2
a360 2
        MOV     r0, #1
        STRB    r0, PointerDirty                        ; indicate shape needs setting up
d362 1
a362 3
        MOV     r0, #0
        STRB    r0, OldLEDs
        STRB    r0, NewLEDs
d368 3
a370 2
        STRVS   r0, [ sp ]
        Pull    "r0-r2, pc"
d381 2
a382 2
HourglassOff ROUT
        Push    "r0-r3, lr"
d385 1
d394 1
a394 1
        Pull    "r0-r3, pc", NE                         ; if not bottom, leave alone
a402 25
        Pull    "r0-r3, pc",NE                          ; no, then exit

        MOV     r0, #SetPointer                         ; restore old pointer
        LDRB    r1, OldPointer
        SWI     XOS_Byte

        LDR     r10, OldColour1
        LDR     r11, OldColour3
        LDR     r3, NewColour3
        TEQ     r11, r3                                 ; Are we changing colour 3?
        LDR     r3, NewColour1
        TEQEQ   r10, r3                                 ; If not are we changing colour 1
        MOVNE   r0, #WaitForVSync                       ; wait until VSync
        SWINE   XOS_Byte                                ; if called R1, R2 trashed

        MOV     r0, #1                                  ; logical Colour 1
        MOV     r1, r10
        TEQ     r1, r3                                  ; NewColour1
        BLNE    SetColour

        MOV     r0, #3                                  ; logical Colour 3
        MOV     r1, r11
        LDR     r10, NewColour3
        TEQ     r1, r10
        BLNE    SetColour
d404 2
a405 1
        Pull    "r0-r3, pc"
d416 3
a418 6
HourglassSmash ROUT
        Push    "r0, r1, lr"
        ADR     r14, DefaultColours
        LDMIA   r14, { r0, r1 }
        ADR     r14, NewColours
        STMIA   r14, { r0, r1 }
d420 2
a421 1
        CMP     r0, #0                                  ; if at top, ignore
d427 6
a432 2
        SWINE   XHourglass_Off                          ; to force turn-off
        Pull    "r0, r1, pc"
d438 1
a438 1
; in:   R0b = percentage to display, outside 0-99 to turn figures off
d443 2
a444 2
HourglassPercentage ROUT
        Push    "r1, lr"
d457 1
a457 1
        Pull    "r1, pc"
d469 3
a471 1
HourglassLEDs ROUT
d477 1
a477 1
        MOV     pc, lr
d490 4
a493 3
HourglassColours
        Push    "r0, r1, r14"
        LDR     r14, NewColour1                         ; Save the old value of Colour1
d495 1
a495 1
        LDR     r14, NewColour3                         ; Save the old value of Colour3
d498 1
a498 1
        STRNE   r0, NewColour1                          ; Put down the new value
d500 1
a500 1
        STRNE   r1, NewColour3                          ; Put down the new value
d502 2
a503 2
        Pull    "r0, r1, pc",NE,^                       ; Return with V clear (26-bit)
        Pull    "r0, r1, pc"                            ; Return with V clear (32-bit)
d511 1
a511 1
        Push    lr
d514 1
a514 1
        Pull    pc, NE                                  ; Yes, so stay out
d524 1
a524 1
        Push    r14                                     ; save SVC r14
d527 1
d533 2
a534 2
        Pull    r14                                     ; restore SVC r14
        RestPSR r6,,c                                   ; restore the mode
d539 1
a539 1
        Pull    pc
d544 1
d552 1
a552 19
        Push    lr

        MOV     r0, #SetPointer                         ; set the pointer
        MOV     r1, #NoPointer
        SWI     XOS_Byte
        STRVCB  r1, OldPointer                          ; so we can read the old one
        SWIVC   XOS_Byte                                ; switch back - we only examine it

        MOV     r0, #1
        MOV     r1, #25
        SWI     XOS_ReadPalette                         ; examine what the cursor colour was
        MOVVC   r2, r2, LSR #8
        STRVC   r2, OldColour1

        MOV     r0, #3
        MOV     r1, #25
        SWI     XOS_ReadPalette                         ; examine what the cursor colour was
        MOVVC   r2, r2, LSR #8
        STRVC   r2, OldColour3
d559 4
d565 1
d582 1
a582 1
        Pull    pc
d600 3
d604 1
d675 1
a675 1
        Push    r14
d681 3
d685 1
d695 1
a695 1
        ADR     r1, ChDefPercent
d698 1
a698 1
        Pull    pc
d701 3
d705 1
d711 1
a711 1
        Pull    pc
d739 1
a739 1
        Push    lr
d749 1
a749 7
        MOV     r0, #1                                  ; logical Colour 1
        LDR     r1, NewColour1
        BL      SetColour

        MOV     r0, #3                                  ; logical Colour 3
        LDR     r1, NewColour3
        BL      SetColour
d751 18
a768 1
        MOV     r0, #SetPointer                         ; and switch to it
d770 11
a780 1
        SWI     XOS_Byte
d782 3
a784 1
        Pull    pc
d809 107
@


4.2
log
@32-bit compatible. Tagged as Hourglass-2_12.
@
text
@d17 2
a25 1
;        GET     Hdr:EcoMacros
d29 1
a29 1
        GET     Time+Date
d33 6
a154 7
                GBLS    OsString
        [       OldOs
OsString        SETS    " (2.00)"
        |
OsString        SETS    ""
        ]

d156 1
a156 12
        DCB     "Hourglass", 9, "2.", CurrentVersion
        [       ReleaseVersion
        !       0, "Assembling Hourglass 2.$CurrentVersion$OsString"
        |
        DCB     "/", CurrentIteration
        !       0, "Assembling Hourglass 2.$CurrentVersion/$CurrentIteration$OsString"
        ]
        DCB     " (", CurrentDate, ")"
        [       :LNOT: ReleaseVersion
        DCB     " assembled  at ", CurrentTime, "."
        ]
        DCB     "$OsString", 0
d508 2
a509 5
        MOV     r0, #0
        mrs    ,r0, CPSR
        TST     r0, #2_11100
        Pull    "r0, r1, pc",EQ,^                       ; Return with V clear (26-bit)
        CMP     r0, r0
d530 1
a530 10
      [ No32bitCode
        MOV     r6, pc
        TEQP    pc, #3                                  ; must be SVC mode here, Enables Ints
        NOP
      |
        mrs    ,r6, CPSR
        BIC     r0, r6, #I32_bit+F32_bit                ; enable interrupts
        ORR     r0, r0, #SVC_mode                       ; into SVC26/32
        msr    ,CPSR_c, r0
      ]
d540 1
a540 6
       [ No32bitCode
        TEQP    r6, #0                                  ; restore the mode
        NOP
       |
        msr    ,CPSR_c, r6
       ]
@


4.1
log
@Initial revision
@
text
@d127 2
d133 1
a133 1
        DCD     ErrorNumber_ModuleBadSWI     
d170 7
d255 9
d265 3
a267 2
        CMP     r1, #Service_Reset                      ; is it reset ? EQ,CSet if so
        TEQNE   r1, #Service_Error*4,2                  ; or error ? EQ, CClear if so
d270 1
d272 2
a273 2
        BCS     DoServiceReset
        B       HourglassSmash                          ; All errors turn off the hourglass
d402 1
a402 1
        Pull    "r0-r3, pc",NE, ^                       ; no, then exit
d428 1
a428 1
        Pull    "r0-r3, pc",, ^
d519 6
a524 1
        Pull    "r0, r1, pc",,^                         ; Return with V clear
d544 1
d548 6
d563 1
d566 3
@


4.1.4.1
log
@Bugfix: new hourglass colours are marked as pending until they are
implemented (at the next animation frame), so if the hourglass is turned
all the way off before then, the module can correctly determine which
pointer colours need redefining to correctly display the standard pointer.
@
text
@a78 3
PendingColours          #       0
PendingColour1          #       4
PendingColour3          #       4
d194 1
a194 1
        ADR     r0, PendingColours
a195 3
        MOV     r1, #-1
        STR     r1, NewColour1
        STR     r1, NewColour3
a407 4
        MOV     r0, #-1
        STR     r0, NewColour1
        STR     r0, NewColour3

d423 1
a423 1
        ADR     r14, PendingColours
a424 3
        MOV     r0, #-1
        STR     r0, NewColour1
        STR     r0, NewColour3
d491 1
a491 1
        LDR     r14, PendingColour1                     ; Save the old value of Colour1
d493 1
a493 1
        LDR     r14, PendingColour3                     ; Save the old value of Colour3
d496 1
a496 1
        STRNE   r0, PendingColour1                      ; Put down the new value
d498 1
a498 1
        STRNE   r1, PendingColour3                      ; Put down the new value
d748 3
a750 4
        LDR     r1, PendingColour1
        STR     r1, NewColour1
        BL      SetColour                               ; we have to do this every time, in case someone else
                                                        ; has messed up the pointer colours since last time
d752 1
a752 2
        LDR     r1, PendingColour3
        STR     r1, NewColour3
@


4.1.4.2
log
@Bugfixes:
* Killing the module before it had shown the hourglass used to remove the
  pointer.
* If an hourglass with a long lead-in time is pending, and a (shorter lead-in)
  second hourglass is started, the time that the animation actually starts is
  now determined by the sooner of the two, rather than always by the top-level
  hourglass' lead-in time.
* If something else changes the pointer number or colours while the Hourglass
  is animating, the new values are remembered and put into effect when the
  hourglass stops, overriding those that were active when the hourglass started.
* Under certain circumstances, R10 could be corrupted on exit, leading to
  data aborts being generated by the Wimp error box code. Fixing this also
  means that Hourglass_Smash can call Hourglass_Off directly, rather than
  having to issue Hourglass_Off as a SWI.
@
text
@a26 1
        GET     Hdr:Proc
a28 14
        
        GET     Hdr:NdrDebug
                GBLL    hostvdu
hostvdu         SETL    {FALSE}
                GBLL    debug_flush
debug_flush     SETL    {TRUE}
                GBLL    debug
debug           SETL    {FALSE}
                GBLL    debugswientry
debugswientry   SETL    {FALSE}
                GBLL    debugdepth
debugdepth      SETL    {FALSE}
                GBLL    debugcurrent
debugcurrent    SETL    {FALSE}
d77 8
a84 12
ReturnColours           #       0                       ; Colours to return to when switched fully off
ReturnColour1           #       4
ReturnColour3           #       4
NextHColours            #       0                       ; Colours to reassert at next frame update
NextHColour1            #       4
NextHColour3            #       4
LastHColours            #       0                       ; Colours set at last frame update
LastHColour1            #       4
LastHColour3            #       4
CurrentColours          #       0                       ; Colours actually in use
CurrentColour1          #       4
CurrentColour3          #       4
d93 1
a93 1
ReturnPointer           #       1                       ; Pointer number to return to when switched fully off
a170 4
      [ debug
        InsertNDRDebugRoutines
      ]

a171 4
      [ debug
        Debug_Open "<Hourglass$Debug>1"
        Debug   swientry, "Module initialisation"
      ]
d195 7
a201 1
        BL      InitialisePointerInfo
a223 1
        Debug   swientry, "Module finalisation"
d225 26
a250 6
        Push    "lr"
        BL      HourglassSmash
      [ debug
        Debug_Close
      ]
        Pull    "pc"
d317 2
a318 2
HourglassOn ENTRY "r0"
        Debug   swientry, "Hourglass_On"
d321 2
a322 3
        EXITS   VC
        STR     r0, [ sp ]
        EXIT
d334 1
a334 3
HourglassStart ENTRY "r0-r2,r11"
        Debug   swientry, "Hourglass_Start, R0 =", r0
        
a335 1
        Debug   depth, "Hourglass_Start: old HourglassDepth =", r11
d338 12
a349 8
        
        LDR     r1, HourglassTimer
        CMP     r11, #1                                 ; update the hourglass timer if this is the first level
        CMPHI   r0, r1                                  ; or if a deeper level is requesting an even earlier display
        STRLS   r0, HourglassTimer
        
        CMP     r11, #1                                 ; that's all we need to do unless this is the first level
        EXITS   HI
a350 2
        BL      InitialisePointerInfo
        
d355 2
a356 3
        EXITS   VC
        STR     r0, [ sp ]
        EXIT
d367 2
a368 2
HourglassOff ENTRY "r0-r3, r10"
        Debug   swientry, "Hourglass_Off"
a370 1
        Debug   depth, "Hourglass_Off: old HourglassDepth =", r10
d379 1
a379 1
        EXITS   NE                                      ; if not bottom, leave alone
d388 31
a418 3
        
        BLEQ    RestorePointer                          ; yes - undo it
        EXITS                                           ; ignore errors
d429 9
a437 3
HourglassSmash ENTRY "r0"
        Debug   swientry, "Hourglass_Smash"
        
d439 1
a439 2
        Debug   depth, "Hourglass_Smash: old HourglassDepth =", r0
        TEQ     r0, #0                                  ; if at top, ignore
d445 2
a446 6
        Debug swientry, "r10 on entry =", r10
        BLNE    HourglassOff                            ; to force turn-off
        Debug swientry, "r10 on exit =", r10
        EXITS   VC
        STR     r0, [sp]
        EXIT
d452 1
a452 1
; in:   R0 = percentage to display, outside 0-99 to turn figures off
d457 2
a458 2
HourglassPercentage ENTRY "r1"
        Debug   swientry, "Hourglass_Percentage, percentage =", r0
d471 1
a471 1
        EXITS
d483 1
a483 3
HourglassLEDs ENTRY "r10, r11"
        Debug   swientry, "Hourglass_LEDs, R0,R1 =", r0, r1
        
d489 1
a489 1
        EXITS
d502 3
a504 4
HourglassColours ENTRY "r0, r1"
        Debug   swientry, "Hourglass_Colours, new colours 1,3 =", r0, r1
        
        LDR     r14, NextHColour1                       ; Save the old value of Colour1
d506 1
a506 1
        LDR     r14, NextHColour3                       ; Save the old value of Colour3
d509 1
a509 1
        STRNE   r0, NextHColour1                        ; Put down the new value
d511 2
a512 2
        STRNE   r1, NextHColour3                        ; Put down the new value
        EXITS                                           ; Return with V clear
d520 1
a520 1
        Push    "lr"
d523 1
a523 1
        Pull    "pc", NE                                ; Yes, so stay out
d535 1
a535 1
        Push    "r14"                                   ; save SVC r14
a537 1
        DebugIf NE, swientry, "Hourglass being shown"
d543 1
a543 1
        Pull    "r14"                                   ; restore SVC r14
d550 1
a550 1
        Pull    "pc"
a554 1
;       Called only when the pointer is dirty - ie first time through ticker routine
d562 19
a580 1
        Push    "lr"
a586 4
      [ debug
        ADRL    r1, HourglassShape
        ADRL    r2, HourglassShapeEnd
      |
a588 1
      ]
d605 1
a605 1
        Pull    "pc"
a622 3
      [ debug
        ADRL    r1, DiffOffsetTable
      |
a623 1
      ]
d694 1
a694 1
        Push    "r14"
a699 3
      [ debug
        ADRL    r3, ChDefNumbers
      |
a700 1
      ]
d710 1
a710 1
        ADRL    r1, ChDefPercent
d713 1
a713 1
        Pull    "pc"
a715 3
      [ debug
        ADRL    r1, ChDefSpace
      |
a716 1
      ]
d722 1
a722 1
        Pull    "pc"
d750 1
a750 1
        Push    "r0-r6, lr"
d760 11
a770 20
        BL      ReadPointerColours                      ; get CurrentColours
        
        ADR     r0, NextHColours
        LDMIA   r0, { r3, r4 }
        ADR     r0, CurrentColours
        LDMIA   r0, { r5, r6 }
        
        TEQ     r5, r3                                  ; set the colour(s)/number for the next frame
        TEQEQ   r6, r4                                  ; avoid reprogramming colours unless strictly necessary
        MOVNE   r0, #WaitForVSync                       ; at least one needs changing, so wait until VSync
        SWINE   XOS_Byte
        MOV     r0, #1
        TEQ     r5, r3
        MOVNE   r1, r3
        BLNE    SetColour ; logical Colour 1
        MOV     r0, #3
        TEQ     r6, r4
        MOVNE   r1, r4
        BLNE    SetColour ; logical Colour 3
        MOV     r0, #SetPointer
d772 1
a772 13
        SWI     XOS_Byte ; on exit, R1 is old shape/linkage
        AND     r1, r1, #&FF
        
        CMP     r1, #3                                  ; if we weren't the last to set a colour/number,
        STRLOB  r1, ReturnPointer                       ; remember the current one for when we switch off
        ADR     r0, LastHColours
        LDMIA   r0, { r1, r2 }
        TEQ     r5, r1
        STRNE   r5, ReturnColour1
        TEQ     r6, r2
        STRNE   r6, ReturnColour3
        
        STMIA   r0, { r3, r4 }                          ; LastHColours = NextHColours
d774 1
a774 1
        Pull    "r0-r6, pc"
a798 107

; *****************************************************************************
;
;       InitialisePointerInfo - sets up colour, number etc information
;
; in:   -
;
; out:  Registers preserved.

InitialisePointerInfo ENTRY "r0-r2"
        BL      ReadPointerColours                      ; get CurrentColours
        
        ADR     r0, CurrentColours                      ; Return = Current
        LDMIA   r0, { r1, r2 }
        ADR     r0, ReturnColours
        STMIA   r0, { r1, r2 }
        MOV     r0, #1
        STRB    r0, ReturnPointer ; mustn't read current pointer
                                  ; number here, it causes flicker
        
        ADRL    r0, DefaultColours                      ; NextH = Default
        LDMIA   r0, { r1, r2 }
        ADR     r0, NextHColours
        STMIA   r0, { r1, r2 }
        
        MOV     r0, #-1                                 ; LastH = -1 (ie guaranteed != current)
        STR     r0, LastHColour1
        STR     r0, LastHColour3
        
        MOV     r0, #1
        STRB    r0, PointerDirty                        ; indicate shape needs setting up

        MOV     r0, #0
        STRB    r0, OldLEDs
        STRB    r0, NewLEDs

        EXIT

; *****************************************************************************
;
;       RestorePointer - changes pointer number and colours back to the "off" values.
;
; in:   -
;
; out:  Registers preserved.

RestorePointer ENTRY "r0-r4,r10-r11"
        BL      ReadPointerColours                      ; get CurrentColours

        MOV     r0, #SetPointer                         ; restore old pointer iff it was most recently changed by us
        LDRB    r1, ReturnPointer
        SWI     XOS_Byte ; on exit, R1 is old shape/linkage
        AND     r3, r1, #&FF
        CMP     r3, #3
        SWILO   XOS_Byte ; Oops, shouldn't have done that
                         ; because someone else had changed
                         ; the pointer - switch it back.
                         ; Having pointer-switch flicker
                         ; here is far better than having it
                         ; during a pre-emptive read routine.

        LDR     r10, LastHColour1                       ; restore old colour(s) iff they were most recently changed by us
        LDR     r11, LastHColour3
        LDR     r3, CurrentColour1
        LDR     r4, CurrentColour3
        TEQ     r3, r10
        TEQNE   r4, r11
        MOVEQ   r0, #WaitForVSync                       ; at least one needs changing, so wait until VSync
        SWIEQ   XOS_Byte                                ; if called R1, R2 trashed

        MOV     r0, #1
        TEQ     r3, r10
        LDREQ   r1, ReturnColour1
        BLEQ    SetColour ; logical Colour 1

        MOV     r0, #3
        TEQ     r4, r11
        LDREQ   r1, ReturnColour3
        BLEQ    SetColour ; logical Colour 3

        EXIT

; *****************************************************************************
;
;       ReadPointerColours - read the current pointer number and colours 1 & 3
;       The colours are stored in CurrentColour1 and CurrentColour3.
;
; in:   -
;
; out:  Registers preserved.

ReadPointerColours ENTRY "r0-r3"
        MOV     r0, #1
        MOV     r1, #25
        SWI     XOS_ReadPalette
        MOVVC   r2, r2, LSR #8
        STRVC   r2, CurrentColour1
        Debug   current, "Current colour 1 =", r2

        MOV     r0, #3
        MOV     r1, #25
        SWI     XOS_ReadPalette
        MOVVC   r2, r2, LSR #8
        STRVC   r2, CurrentColour3
        Debug   current, "Current colour 3 =", r2
        
        EXIT
@


4.1.4.3
log
@Added Ursula service call table.
@
text
@a253 18

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Table of service calls we want

        ASSERT  Service_Error < Service_Reset

ServiceTable
        DCD     0
        DCD     ServiceUrsula - ModuleStart
        DCD     Service_Error
        DCD     Service_Reset
        DCD     0
        DCD     ServiceTable - ModuleStart


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Module service entry point

a254 3
        MOV     r0, r0                                  ; Indicates there is a service call table

ServiceUrsula
@


4.1.4.4
log
@Hourglass shape changed.
@
text
@a43 2
                GBLL    ursula
ursula          SETL    {TRUE}
d65 1
a65 1
HeightInPixels  * 32
d69 1
a69 1
PercY           * 23
d72 4
a75 1
 
a82 7
; Define number of frames and palette data
HourglassFrames * 8

DefaultColour1  * &fff6d5
DefaultColour2  * &0
DefaultColour3  * &ffa100

a93 3
 [ ursula
ReturnColour2           #       4
 ]
a96 3
 [ ursula
NextHColour2            #       4
 ]
a99 3
 [ ursula
LastHColour2            #       4
 ]
a102 3
 [ ursula
CurrentColour2          #       4
 ]
a241 3
       [ ursula
        DCD     DefaultColour2
       ]
d572 1
a572 1
      [ debug :LOR: ursula
a608 4

      [ ursula
        TEQ     r0, #HourglassFrames
      |
a609 1
      ]
d613 1
a613 1
      [ debug :LOR: ursula
d694 1
a694 2

      [ debug :LOR: ursula
a698 1
      
d714 1
a714 1
      [ debug :LOR: ursula
a745 2

 [ ursula
d752 1
a752 1
        Push    "r0-r9, lr"
d759 1
a759 1
        ADRL     r1, OSWord15Block
d765 1
a765 1
        LDMIA   r0, { r4, r5, r6 }
d767 1
a767 1
        LDMIA   r0, { r7, r8, r9 }
d769 2
a770 3
        TEQ     r7, r4                                  ; set the colour(s)/number for the next frame
        TEQEQ   r8, r5                                  ; avoid reprogramming colours unless strictly necessary
        TEQEQ   r9, r6
d774 2
a775 2
        TEQ     r7, r4
        MOVNE   r1, r4
a776 4
        MOV     r0, #2
        TEQ     r8, r5
        MOVNE   r1, r5
        BLNE    SetColour ; logical Colour 2       
d778 2
a779 2
        TEQ     r9, r6
        MOVNE   r1, r6
d789 5
a793 7
        LDMIA   r0, { r1, r2, r3 }
        TEQ     r7, r1
        STRNE   r7, ReturnColour1
        TEQ     r8, r2
        STRNE   r8, ReturnColour2
        TEQ     r9, r3
        STRNE   r9, ReturnColour3
d795 1
a795 1
        STMIA   r0, { r4, r5, r6 }                          ; LastHColours = NextHColours
d797 1
a797 1
        Pull    "r0-r9, pc"
a799 2
 ]

a822 2

 [ ursula
d831 1
a831 1
InitialisePointerInfo ENTRY "r0-r3"
d835 1
a835 1
        LDMIA   r0, { r1, r2, r3 }
d837 1
a837 1
        STMIA   r0, { r1, r2, r3 }
d843 1
a843 1
        LDMIA   r0, { r1, r2, r3 }
d845 1
a845 1
        STMIA   r0, { r1, r2, r3 }
a848 1
        STR     r0, LastHColour2
a858 2
 ]

a859 1
 [ ursula
d868 1
a868 1
RestorePointer ENTRY "r0-r5,r9-r11"
d883 1
a883 2
        LDR     r9, LastHColour1                       ; restore old colour(s) iff they were most recently changed by us
        LDR     r10, LastHColour2
d886 3
a888 5
        LDR     r4, CurrentColour2
        LDR     r5, CurrentColour3
        TEQ     r3, r9
        TEQNE   r4, r10
        TEQNE   r5, r11
d893 1
a893 1
        TEQ     r3, r9
a896 5
        MOV     r0, #2
        TEQ     r4, r10
        LDREQ   r1, ReturnColour2
        BLEQ    SetColour ; logical Colour 2
        
d898 1
a898 1
        TEQ     r5, r11
a902 1
 ]
a903 1
 
a920 9
 [ ursula
        MOV     r0, #2
        MOV     r1, #25
        SWI     XOS_ReadPalette
        MOVVC   r2, r2, LSR #8
        STRVC   r2, CurrentColour2
        Debug   current, "Current colour 2 =", r2
 ]

d930 1
d932 1
a932 2
; ***************************************************************************
; Hourglass data
a933 1
        ALIGN
d935 20
a954 22
        DCB     &00, &a8, &aa, &aa, &aa, &00
        DCB     &00, &f8, &ff, &ff, &bf, &00
        DCB     &00, &58, &55, &55, &95, &00
        DCB     &00, &58, &55, &55, &95, &00
        DCB     &00, &d8, &ff, &ff, &9f, &00
        DCB     &00, &d8, &ff, &ff, &9f, &00
        DCB     &00, &60, &ff, &ff, &27, &00
        DCB     &00, &60, &ff, &ff, &27, &00
        DCB     &00, &80, &fd, &ff, &09, &00
        DCB     &00, &00, &f6, &7f, &02, &00
        DCB     &00, &00, &d8, &9f, &00, &00
        DCB     &00, &00, &58, &95, &00, &00
        DCB     &00, &00, &56, &57, &02, &00
        DCB     &00, &80, &55, &55, &09, &00
        DCB     &00, &60, &55, &57, &25, &00
        DCB     &00, &60, &55, &55, &25, &00
        DCB     &00, &58, &55, &57, &95, &00
        DCB     &00, &58, &55, &55, &95, &00
        DCB     &00, &58, &55, &57, &95, &00
        DCB     &00, &58, &55, &57, &95, &00
        DCB     &00, &f8, &ff, &ff, &bf, &00
        DCB     &00, &a8, &aa, &aa, &aa, &00
a957 1

d959 6
a964 8
       &       ShapeDiffs0-DiffOffsetTable
       &       ShapeDiffs1-DiffOffsetTable
       &       ShapeDiffs2-DiffOffsetTable
       &       ShapeDiffs3-DiffOffsetTable
       &       ShapeDiffs4-DiffOffsetTable
       &       ShapeDiffs5-DiffOffsetTable
       &       ShapeDiffs6-DiffOffsetTable
       &       ShapeDiffs7-DiffOffsetTable
d966 6
d974 1
a974 1
        DCB     &d5,&74, &5f,&75
d978 1
a978 2
        DCB     &58,&19, &55,&1a, &55,&1b, &95,&1c, &57,&69, &d5,&6e
        DCB     &5f,&6f, &f5,&74, &7f,&75, &7f,&75
d982 2
a983 3
        DCB     &58,&1f, &55,&20, &55,&21, &95,&22, &d5,&68, &5f,&69
        DCB     &f5,&6e, &7f,&6f, &fd,&74, &ff,&75
        DCB     &00,&00, &00,&00
d986 2
a987 3
        DCB     &55,&26, &55,&27, &25,&28, &57,&5d, &d5,&62, &5f,&63
        DCB     &f5,&68, &7f,&69, &fd,&6e, &ff,&6f, &ff,&74, &97,&76
        DCB     &00,&00, &00,&00
d990 2
a991 3
        DCB     &55,&2c, &55,&2d, &25,&2e, &d5,&5c, &5f,&5d, &f5,&62
        DCB     &7f,&63, &fd,&68, &ff,&69, &ff,&6e, &97,&70, &d8,&73
        DCB     &9f,&76, &9f,&76
a993 27
ShapeDiffs6
        DCB     &55,&32, &55,&33, &55,&4b, &57,&51, &d5,&56, &5f,&57
        DCB     &f5,&5c, &7f,&5d, &fd,&62, &ff,&63, &ff,&68, &97,&6a
        DCB     &d8,&6d, &9f,&70
        DCB     &00,&00, &00,&00

ShapeDiffs7
        DCB     &56,&38, &55,&39, &58,&3e, &95,&3f, &d5,&50, &5f,&51
        DCB     &f5,&56, &7f,&57, &fd,&5c, &ff,&5d, &ff,&62, &97,&64
        DCB     &d8,&67, &9f,&6a
        DCB     &00,&00, &00,&00

ShapeDiffs0
        DCB     &d8,&19, &ff,&1a, &ff,&1b, &9f,&1c, &d8,&1f, &ff,&20
        DCB     &ff,&21, &9f,&22, &ff,&26, &ff,&27, &27,&28, &ff,&2c
        DCB     &ff,&2d, &27,&2e, &fd,&32, &ff,&33, &f6,&38, &7f,&39
        DCB     &d8,&3e, &9f,&3f, &57,&4b, &55,&50, &55,&51, &55,&56
        DCB     &57,&57, &55,&5c, &55,&5d, &55,&62, &57,&63, &95,&64
        DCB     &58,&67, &55,&68, &55,&69, &95,&6a, &58,&6d, &55,&6e
        DCB     &57,&6f, &95,&70, &58,&73, &55,&74, &57,&75, &95,&76
        DCB     &00,&00, &00,&00


; ***************************************************************************
; Character definitions

        ALIGN
d998 10
a1007 10
    = &ff,&ff,&5f,&f5,&d7,&d7,&d7,&d7,&d7,&d7,&d7,&d7,&d7,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&7f,&fd,&5f,&fd,&7f,&fd,&7f,&fd,&7f,&fd,&7f,&fd,&7f,&fd,&ff,&ff
    = &ff,&ff,&5f,&f5,&d7,&d7,&ff,&d7,&7f,&f5,&5f,&ff,&d7,&ff,&57,&d5,&ff,&ff
    = &ff,&ff,&5f,&f5,&57,&d7,&ff,&d7,&ff,&f5,&ff,&d7,&57,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&7f,&f5,&5f,&f5,&d7,&f5,&d7,&f5,&57,&d5,&ff,&f5,&ff,&f5,&ff,&ff
    = &ff,&ff,&57,&d5,&d7,&ff,&57,&f5,&ff,&d7,&ff,&d7,&d7,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&5f,&d5,&d7,&ff,&d7,&ff,&57,&f5,&d7,&d7,&d7,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&57,&d5,&ff,&f5,&7f,&fd,&7f,&fd,&5f,&ff,&5f,&ff,&5f,&ff,&ff,&ff
    = &ff,&ff,&5f,&f5,&d7,&d7,&d7,&d7,&5f,&f5,&d7,&d7,&d7,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&5f,&f5,&d7,&d7,&d7,&d7,&5f,&d5,&ff,&d7,&ff,&d7,&5f,&f5,&ff,&ff
d1010 1
a1010 2
    = &ff,&ff,&df,&df,&77,&f7,&77,&f7,&df,&dd,&7f,&77,&7f,&77,&df,&df,&ff,&ff

d1012 1
@


4.1.4.5
log
@Added new style LEDs, plus changed text.
@
text
@d24 1
d28 1
d30 1
a31 2


d44 2
a45 4
                GBLL    threecolours                    ; set to TRUE for three colour hourglass
threecolours    SETL    {TRUE}                          ; or to FALSE for old two colour hourglass
                GBLL    ursulaLEDs                      ; set to TRUE for Ursula OS left/right LEDs
ursulaLEDs      SETL    {TRUE}                          ; or to FALSE for <3.70 style top and bottom
d47 1
d49 1
a49 2
; A large number to put into PercentageDepth
bignum          * &3FFFFFFF                             
a50 1
; The constants defining the hourglass shape and position
d57 1
a57 6
; LED positioning
LeftLedX        * 0
LeftLedY        * 8
RightLedX       * 4
RightLedY       * 8
LedHeight       * 6
a58 1
; The constants defining the Hourglass time behaviour
d64 1
d84 1
a88 1

d93 1
d97 1
d100 1
a100 1
 [ threecolours
d106 1
a106 1
 [ threecolours
d112 1
a112 1
 [ threecolours
d118 1
a118 1
 [ threecolours
d150 1
a154 3

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

d260 1
a260 1
       [ threecolours
a351 1

a368 1

a404 1

a439 1

a466 1

a491 1

a511 1

a535 1

a574 1

d593 1
a593 1
      [ debug :LOR: threecolours
a617 1

d631 1
a631 1
      [ threecolours
d639 1
a639 1
      [ debug :LOR: threecolours
a658 1

a672 1

a678 38

 [ ursulaLEDs
        ADR     r2, HourglassData + (LeftLedY * BytesPerLine) + LeftLedX
        TST     r1, #1
        ADRNEL  r3, LeftLEDOn
        ADREQL  r3, LeftLEDOff
        
        MOV     r1, #LedHeight
        
10      LDRB    r0, [r3]
        STRB    r0, [r2]
        LDRB    r0, [r3, #1]
        STRB    r0, [r2, #1]
        ADD     r2, r2, #BytesPerLine
        ADD     r3, r3, #2
        SUBS    r1, r1, #1
        BNE     %BT10
        
        LDRB    r1, OldLEDs

        ADR     r2, HourglassData + (RightLedY * BytesPerLine) + RightLedX
        TST     r1, #2
        ADRNEL  r3, RightLEDOn
        ADREQL  r3, RightLEDOff
        
        MOV     r1, #LedHeight
        
20      LDRB    r0, [r3]
        STRB    r0, [r2]
        LDRB    r0, [r3, #1]
        STRB    r0, [r2, #1]
        ADD     r2, r2, #BytesPerLine
        ADD     r3, r3, #2
        SUBS    r1, r1, #1
        BNE     %BT20
 ]
 
 [ :LNOT: ursulaLEDs
d696 1
a696 2
 ]
         
a698 1

d721 1
a721 1
      [ debug :LOR: threecolours
d742 1
a742 1
      [ debug :LOR: threecolours
a753 1

d775 1
a775 1
 [ threecolours
d863 1
a863 1
 [ threecolours
d901 1
d904 1
d976 1
a976 1
 [ threecolours
d1093 10
a1102 10
    = &a8,&2a,&5a,&a5,&96,&96,&96,&96,&96,&96,&96,&96,&96,&96,&5a,&a5,&a8,&2a
    = &a0,&0a,&68,&09,&58,&09,&68,&09,&60,&09,&60,&09,&60,&09,&60,&09,&a0,&0a
    = &a8,&2a,&5a,&a5,&96,&96,&aa,&96,&68,&a5,&5a,&2a,&96,&aa,&56,&95,&aa,&aa
    = &a8,&2a,&5a,&a5,&56,&96,&aa,&96,&80,&a5,&aa,&96,&56,&96,&5a,&a5,&a8,&2a
    = &a0,&2a,&68,&25,&5a,&25,&96,&25,&96,&a5,&56,&95,&aa,&a5,&80,&25,&80,&2a
    = &aa,&aa,&56,&95,&96,&aa,&56,&a5,&aa,&96,&aa,&96,&96,&96,&5a,&a5,&a8,&2a
    = &a8,&aa,&5a,&95,&96,&aa,&96,&2a,&56,&a5,&96,&96,&96,&96,&5a,&a5,&a8,&2a
    = &aa,&aa,&56,&95,&aa,&a5,&60,&29,&68,&09,&58,&0a,&58,&02,&58,&02,&a8,&02
    = &a8,&2a,&5a,&a5,&96,&96,&96,&96,&5a,&a5,&96,&96,&96,&96,&5a,&a5,&a8,&2a
    = &a8,&2a,&5a,&a5,&96,&96,&96,&96,&5a,&95,&aa,&96,&a8,&96,&58,&a5,&a8,&2a
d1105 1
a1105 2
    = &a8,&a8,&9a,&9a,&66,&a6,&66,&26,&9a,&a5,&68,&99,&68,&99,&98,&a6,&a8,&2a

a1106 13
; ***************************************************************************
; LED definitions

        ALIGN
LeftLEDOn
        DCB     &80, &82, &60, &09, &58, &25, &58, &25, &60, &09, &80, &82
LeftLEDOff
        DCB     &00, &80, &00, &00, &00, &00, &00, &00, &00, &00, &00, &80

RightLEDOn
        DCB     &09, &0a, &82, &25, &60, &95, &60, &95, &82, &25, &09, &0a
RightLEDOff
        DCB     &09, &00, &02, &00, &00, &00, &00, &00, &02, &00, &09, &00
@


4.1.4.6
log
@Changed character definitions.
@
text
@d1142 1
d1155 1
a1155 1
    = &a0,&2a,&68,&25,&5a,&25,&96,&25,&a6,&a5,&56,&95,&aa,&a5,&80,&25,&80,&2a
d1157 2
a1158 2
    = &a0,&2a,&68,&25,&5a,&2a,&96,&2a,&56,&a5,&96,&96,&96,&96,&5a,&a5,&a8,&2a
    = &aa,&aa,&56,&95,&aa,&a5,&68,&29,&58,&0a,&58,&02,&58,&02,&58,&02,&a8,&02
d1160 1
a1160 1
    = &a8,&2a,&5a,&a5,&96,&96,&96,&96,&5a,&95,&a8,&96,&a8,&a5,&58,&29,&a8,&0a
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

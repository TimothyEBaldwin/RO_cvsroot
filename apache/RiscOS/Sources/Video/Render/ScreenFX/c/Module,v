head	1.6;
access;
symbols
	ScreenFX-0_09-1:1.6
	ScreenFX-0_09:1.6
	ScreenFX-0_08:1.6
	ScreenFX-0_07:1.5
	ScreenFX-0_06:1.4
	ScreenFX-0_05:1.4
	ScreenFX-0_04:1.3
	ScreenFX-0_03:1.2
	ScreenFX-0_02:1.2
	ScreenFX-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2007.07.22.20.38.24;	author rool;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.16.15.48.47;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.24.08.18.26;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.19.16.33.14;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.19.13.31.26;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.18.21.08.34;	author ahodgkin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.08.18.21.08.34;	author ahodgkin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@  Various bug fixes; new 'escape' feature.
Detail:
  Incorrect command line help text fixed. Failure to pass duration to
  effects engine for crossfades corrected. New bit to Fade and CrossFade
  SWIs with corresponding "-escape" switch on the command line; allows
  Escape key to interrupt fades. Documentation updated. Internal effects
  initialisation and finalisation tidied up a bit. Now uses header files
  in Global for EventV and PaletteV definitions (note, BBE will require
  the addition of Global/h/PaletteV in the Export tree).
Testing:
  Moderate developer testing on Iyonix platform. Test harness unchanged.

Version 0.08. Tagged as 'ScreenFX-0_08'
@
text
@/* Copyright 2005 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Module.c                                          */
/*          (C) 2005 Tematic                                  */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Module mechanisms for ScreenFX.                   */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 18-Aug-2005 (ADH): Created.                       */
/**************************************************************/

#include <string.h>
#include <Global/Services.h> /* Has to come before Global.h as, unlike Global.h, Global/Services.h doesn't check for existing definitions - so it may try to redefine items */

#include "Global.h"

#include "CLI.h"
#include "Effect.h"
#include "SWI.h"

#include "Module.h"

/* This macro, when defined, includes the code for the two debugging *-commands
 * You need to enable the commands in the CMHG header file too.
 */

#if CMHG_VERSION < 516
  #define CMHG_CONST
#else
  #define CMHG_CONST const
#endif

/* Declare in RAM builds the resources accessor function, which
 * returns a pointer to a resource file block for ResourceFS.
 * It is automatically generated by resgen in one of the shared
 * Makefile components (at the time of writing, the relevant
 * file is "RiscOS/Sources/Video/PRISM/PRISM/CommonMF").
 */

#ifndef ROM
  extern int resmess_ResourcesFiles(void);
#endif

/* In RAM builds, define a private copy of errno if asked to do so */

#ifndef ROM
  #ifdef DEFINE_ERRNO
    int __errno;
  #endif
#endif

/* Private word, set up in module_initialise */

void * module_pw;

/**************************************************************/
/* module_initialise()                                        */
/*                                                            */
/* Startup code, usual initialisation entry point stuff.      */
/*                                                            */
/* Note that this module does not attempt to patch around a   */
/* faulty realloc() and so won't work on RISC OS 3.1.         */
/*                                                            */
/* Parameters: As normal for a CMHG initialisation function.  */
/**************************************************************/

_kernel_oserror * module_initialise(CMHG_CONST char * cmd_fail, int podule_base, void * pw)
{
  _kernel_oserror * e;

  module_pw = pw;

  (void) cmd_fail;
  (void) podule_base;

  /* Earlier CMHGs won't call atexit() handlers if we return an
   * error here. Could work around it but since there is a fixed
   * version available, insist on that.
   */

  #if CMHG_VERSION < 530
    #error You need CMHG 5.30 or later to build ScreenFX.
  #endif

  /* Get DebugLib up and running */

  #ifdef TRACE
    {
      debug_device dev = FILE_OUTPUT;

      debug_initialise(Module_Title, "ADFS::4.$." Module_Title "Debug", NULL);
      debug_atexit();
      debug_set_screen_cornering(FALSE);
      debug_set_unbuffered_files(TRUE);
      debug_set_device(dev);
    }
  #endif

  dprintf(("Module", "module_initialise: Hello!\n"));

  /* Sort out the Messages file */

  #ifndef ROM_MODULE

    e = _swix(ResourceFS_RegisterFiles,
              _IN(0),

              resmess_ResourcesFiles());

    if (e != NULL)
    {
      dprintf(("Module", "module_initialise: Failed to register ResourceFS files\n"));
      return e;
    }

  #endif

  if (getenv(Module_Title "$Path"))
  {
    e = prismlib_open_messages(Module_Title ":Messages");
  }
  else
  {
    e = prismlib_open_messages(Module_MessagesFile);
  }

  if (e != NULL)
  {
    dprintf(("Module", "module_initialise: Failed to open messages file\n"));

    #ifndef ROM_MODULE

      (void) _swix(ResourceFS_DeregisterFiles,
                   _IN(0),

                   resmess_ResourcesFiles());

    #endif

    return e;
  }

  /* Program the assumed initial values of the SRGB tables */

  for (uint32_t i = 0; i < 256; i++) starting_r[i] = i;

  memcpy(starting_g, starting_r, 256);
  memcpy(starting_b, starting_r, 256);
  memcpy(starting_s, starting_r, 256);

  memcpy(current_r,  starting_r, 256);
  memcpy(current_g,  starting_r, 256);
  memcpy(current_b,  starting_r, 256);
  memcpy(current_s,  starting_r, 256);

  /* Finished */

  dprintf(("Module", "module_initialise: Successful\n"));
  return NULL;
}

/**************************************************************/
/* module_finalise()                                          */
/*                                                            */
/* Tidy everything up on shutdown.                            */
/**************************************************************/

_kernel_oserror * module_finalise(int fatal, int podule, void * pw)
{
  (void) fatal;
  (void) podule;
  (void) pw;

  dprintf(("Module", "module_finalise: Called\n"));

  /* Shut down any running effects and reset the tables */

  PRISMLIB_RETERR(effect_cancel(false));
  PRISMLIB_RETERR(effect_reset());

  /* Close the messages file */

  (void) prismlib_close_messages();

  #ifndef ROM_MODULE

    (void) _swix(ResourceFS_DeregisterFiles,
                 _IN(0),

                 resmess_ResourcesFiles());

  #endif

  /* Finished */

  dprintf(("Module", "module_finalise: Goodbye!\n"));
  return NULL;
}

/**************************************************************/
/* module_swi_handler()                                       */
/*                                                            */
/* Simple SWI dispatch table.                                 */
/*                                                            */
/* Parameters: As normal for a CMHG SWI handler.              */
/**************************************************************/

_kernel_oserror * module_swi_handler(int swi_no, _kernel_swi_regs * r, void * pw)
{
  (void) pw;
  (void) r;

  dprintf(("Module",
           "module_swi_handler: Called for SWI &%08X\n",

           swi_no + ScreenFX_00));

  switch (swi_no)
  {
    /* Reserved or unknown SWIs */

    default:
      return error_BAD_SWI;

    /* Main interface */

    case ScreenFX_Fade      - ScreenFX_00:
      return swi_fade(r);

    case ScreenFX_Cancel    - ScreenFX_00:
      return swi_cancel(r);

    case ScreenFX_Reset     - ScreenFX_00:
      return swi_reset(r);

    case ScreenFX_Status    - ScreenFX_00:
      return swi_status(r);

    case ScreenFX_CrossFade - ScreenFX_00:
      return swi_crossfade(r);
  }
}

/**************************************************************/
/* module_cli_handler()                                       */
/*                                                            */
/* Simple *-command handler.                                  */
/*                                                            */
/* Parameters: As normal for a CMHG *-command handler.        */
/**************************************************************/

_kernel_oserror * module_cli_handler(CMHG_CONST char * a, int ac, int cmd_no, void * pw)
{
  (void) ac;
  (void) pw;

  switch (cmd_no)
  {
    case CMD_ScreenFXFade:
      return cli_fade((const char *) a);

    case CMD_ScreenFXCrossFade:
      return cli_crossfade((const char *) a);

    case CMD_ScreenFXCancel:
      return cli_cancel((const char *) a);

    case CMD_ScreenFXReset:
      return cli_reset((const char *) a);

    case CMD_ScreenFXStatus:
      return cli_status((const char *) a);

    /* Should never happen... */

    default:
      return NULL;
  }
}

/**************************************************************/
/* module_event_handler()                                     */
/*                                                            */
/* Handle a EventV events 4 (VSync) and 6 (Escape).           */
/*                                                            */
/* Parameters: As normal for a CMHG event handler.            */
/**************************************************************/

int module_event_handler(_kernel_swi_regs * r, void * pw)
{
  (void) pw;
  (void) r;

  switch (r->r[0])
  {
    case Event_VSync:
    {
      switch (fade_running)
      {
        case screenfx_effect_type_FADE:      effect_process_fade();      break;
        case screenfx_effect_type_CROSSFADE: effect_process_crossfade(); break;
      }
    }
    break;

    case Event_Escape:
    {
      if (fade_running != screenfx_effect_type_NONE)
      {
        effect_cancel(true);

        /* Clear the current escape condition */

        _swix(OS_Byte,
              _IN(0),

              OsByte_ClearEscape);
      }
    }
    break;
  }

  return 1; /* Don't claim event */
}
@


1.5
log
@  Feature addition.
Detail:
  ScreenFX_CrossFade / *ScreenFXCrossFade - see API documentation for
  details.
Admin:
  16bpp and 32bpp modes tested; ran out of time to check 8bpp cross fades.

Version 0.07. Tagged as 'ScreenFX-0_07'
@
text
@d193 1
a193 1
  PRISMLIB_RETERR(effect_cancel());
d297 1
a297 1
/* module_vsync_handler()                                     */
d299 1
a299 1
/* Handle a VSync event.                                      */
d304 1
a304 1
int module_vsync_handler(_kernel_swi_regs * r, void * pw)
d309 1
a309 1
  if (r->r[0] == Event_VSync)
d311 1
a311 1
    switch (fade_running)
d313 5
a317 2
      case screenfx_effect_type_FADE:      effect_process_fade();      break;
      case screenfx_effect_type_CROSSFADE: effect_process_crossfade(); break;
d319 17
@


1.4
log
@  Official allocations. Copyright message changes.
Detail:
  Now includes official SWI base and error block allocations. The star
  commands are registered too. Meanwhile, copyright messages have been
  changed from "Castle Technology Ltd" to "Tematic".
Admin:
  Rebuilt from clean, simple test harness passes.

Version 0.05. Tagged as 'ScreenFX-0_05'
@
text
@d253 3
d277 3
d309 1
a309 1
  if (r->r[0] == Event_VSync && fade_running == true)
d311 5
a315 1
    effect_process_fade();
@


1.3
log
@  Tweaks.
Detail:
  *ScreenFXStatus didn't give remaining fade time, it gave absolute time,
  which isn't what Docs.API says. Fixed. ScreenFX_Status didn't return time
  at all, instead returning the pointer to the tables in R3 - the BASIC
  test program conformed to the broken API not the documented API. Fixed
  this too. Now cancels and resets on module exit, rather than just
  cancelling the current operation but leaving the display state alone.
Admin:
  Tested; test program (such as it is!) updated.

Version 0.04. Tagged as 'ScreenFX-0_04'
@
text
@d17 1
a17 1
/*          (C) 2005 Castle Technology Ltd                    */
@


1.2
log
@  Bug fixes, redundant code removed, new feature.
Detail:
  Rounding errors fixed, so test harness now completes - fades always do
  completely achieve the target parameters. Interruption timing: When a
  new fade interrupts an old one, the percentage of its duration that is
  used depends on how long the fade had been going, not how long it had
  left to go. See Docs.API for why. Now links with PRISMLib the module
  version - stops various odd effects (the bits of shared Makefile in use
  do *not* automatically add a "zm" suffix, so the old version didn't
  work so well). New feature: *ScreenFXReset, or SWI ScreenFX_Reset - as
  ScreenFX_Cancel, plus a reset to default gamma and supremacy tables.
  Again, see Docs.API for details. Finally, the Service_MessagesFileClosed
  handler has been removed - the module does not *maintain* pointers into
  the messages file, since it looks up tokens anew each time they are
  needed, so therefore it does not need to handle the service call.
Admin:
  Interrupted fade timing looks better. No more odd effects when switching
  between debug and non-debug modules. Test harness passes its check that
  the tables are programmed as expected at the end of a fade. Reset feature
  works as it should.

Version 0.02. Tagged as 'ScreenFX-0_02'
@
text
@d191 1
a191 1
  /* Shut down any running effects */
d194 1
@


1.1
log
@Initial revision
@
text
@a214 47
/* module_service_handler()                                   */
/*                                                            */
/* General service call handler.                              */
/*                                                            */
/* Parameters: As normal for a CMHG service call handler.     */
/**************************************************************/

void module_service_handler(int service_number, _kernel_swi_regs * r, void * pw)
{
  (void) r;
  (void) pw;

  dprintf(("Module",
           "module_service_handler: Called for service &%08X (R0: %d, R2: %d, R3: &%08X)\n",

           service_number,
           r->r[0],
           r->r[2],
           r->r[3]));

  switch (service_number)
  {
    case Service_MessageFileClosed:
    {
      _kernel_oserror * e;

      dprintf(("Module", "module_service_handler: Messages file closed - reopening it...\n"));

      if (getenv(Module_Title "$Path"))
      {
        e = prismlib_open_messages(Module_Title ":Messages");
      }
      else
      {
        e = prismlib_open_messages(Module_MessagesFile);
      }

      dprintf(("Module", "module_service_handler: Reopen call returned &%08X\n", (uint32_t) e));
    }
    break;

  } /* 'switch (service_number)' */

  dprintf(("Module", "module_service_handler: Successful\n"));
}

/**************************************************************/
d247 3
d276 3
@


1.1.1.1
log
@Initial import of ScreenFX module to CVS.
@
text
@@

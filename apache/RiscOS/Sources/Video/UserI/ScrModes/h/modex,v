head	4.20;
access;
symbols
	ScrModes-0_71:4.20
	ScrModes-0_70:4.19
	ScrModes-0_69:4.19
	ScrModes-0_68:4.19
	ScrModes-0_67:4.19
	ScrModes-0_66:4.19
	ScrModes-0_65:4.19
	ScrModes-0_64:4.18
	ScrModes-0_62:4.18
	ScrModes-0_61:4.18
	ScrModes-0_60:4.17
	ScrModes-0_59:4.17
	ScrModes-0_58:4.17
	ScrModes-0_57:4.17
	ScrModes-0_56-smalltables:4.17
	ScrModes-0_56:4.16
	ScrModes-0_55-mallocfree:4.15
	ScrModes-0_55-cvs3fix:4.15
	ScrModes-0_55:4.15
	ScrModes-0_53-split:4.14
	ScrModes-0_54:4.14
	ScrModes-0_53-tables:4.13
	ScrModes-0_53:4.12
	ScrModes-0_52:4.12
	ScrModes-0_51:4.12
	ScrModes-0_50:4.12
	ScrModes-0_49:4.12
	ScrModes-0_48:4.11
	ScrModes-0_47:4.11
	ScrModes-0_46:4.10
	ScrModes-0_45:4.10
	ScrModes-0_44:4.10
	ScrModes-0_43:4.10
	ScrModes-0_42:4.10
	ScrModes-0_41:4.10
	ScrModes-0_40:4.10
	ScrModes-0_39:4.10
	ScrModes-0_38:4.9
	ScrModes-0_37:4.9
	ScrModes-0_36:4.8
	ScrModes-0_35:4.7
	ScrModes-0_34:4.7
	ScrModes-0_33:4.6
	ScrModes-0_32:4.6
	ScrModes-0_31:4.5
	RO_5_07:4.5
	ScrModes-0_30:4.5
	ScrModes-0_29:4.5
	ScrModes-0_28:4.5
	dellis_autobuild_BaseSW:4.4
	ScrModes-0_27:4.4
	ScrModes-0_26:4.4
	sbrodie_sedwards_16Mar2000:4.4
	ScrModes-0_25:4.4
	ScrModes-0_24:4.3
	dcotton_autobuild_BaseSW:4.5
	ScrModes-0_23:4.3
	ScrModes-0_22:4.3
	ScrModes-0_21:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	ScrModes-0_20:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.20
date	2018.11.07.22.38.43;	author jlee;	state Exp;
branches;
next	4.19;
commitid	AU2ztWfFYsRL04ZA;

4.19
date	2017.06.07.21.16.24;	author jlee;	state Exp;
branches;
next	4.18;
commitid	VTErhLKp4wwPcuUz;

4.18
date	2017.03.05.15.21.11;	author rool;	state Exp;
branches;
next	4.17;
commitid	dv9rieZmjERhgnIz;

4.17
date	2016.08.06.09.33.52;	author rool;	state Exp;
branches;
next	4.16;
commitid	NoDZxDMSFpBS6ehz;

4.16
date	2016.07.30.08.45.32;	author rool;	state Exp;
branches;
next	4.15;
commitid	1UbggudwDv735kgz;

4.15
date	2016.07.30.08.34.58;	author rool;	state Exp;
branches;
next	4.14;
commitid	pWJuqQAvK4Jo1kgz;

4.14
date	2016.05.14.12.45.38;	author rool;	state Exp;
branches;
next	4.13;
commitid	DAkVsTOsI1rFSr6z;

4.13
date	2016.05.14.12.40.26;	author rool;	state Exp;
branches;
next	4.12;
commitid	UkO7RI5AYo6IQr6z;

4.12
date	2015.11.29.20.34.58;	author jlee;	state Exp;
branches;
next	4.11;
commitid	X917PzTaosbDQ1Ly;

4.11
date	2015.02.20.22.00.18;	author jlee;	state Exp;
branches;
next	4.10;
commitid	Y4rZtzOMEfbVnNay;

4.10
date	2015.02.08.16.18.08;	author srevill;	state Exp;
branches;
next	4.9;
commitid	diy9pjBgTsmrSd9y;

4.9
date	2014.01.19.17.22.17;	author jlee;	state Exp;
branches;
next	4.8;
commitid	dGze9YD5M2lNBKlx;

4.8
date	2013.12.15.22.00.57;	author jlee;	state Exp;
branches;
next	4.7;
commitid	Y1CypBuj2rr7hhhx;

4.7
date	2012.08.28.07.08.07;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	oDpFFAGAvHPszhiw;

4.6
date	2012.07.14.19.39.02;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	YTNC4KmzhMQIazcw;

4.5
date	2001.03.01.09.57.12;	author mstephen;	state Exp;
branches;
next	4.4;

4.4
date	2000.01.10.10.59.29;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.09.16.13.19.21;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.13.08.06;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.46.31;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.46.31;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.50.57;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.02.12;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.24.14;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.20
log
@Improve mode substitution logic
Detail:
  This updates ScreenModes to use similar mode substition logic to Kernel-6_14:
  - Try higher colour depths
  - Try lower colour depths
  - Try alternate resolutions (half-width non-double-pixel if original was double-pixel, assorted industry-standard resolutions, and monitor preferred resolution/timings)
  - Plus tries to preserve as many attributes as possible (eigen values, gap mode type, etc.)
  Additionally, LineLength values in the input mode selector block will be used to influence the VIDC list ExtraBytes value, as per the kernel
  File changes:
  - c/ScrModes - Update Service_ModeTranslation and Service_ModeExtension handlers, as described above
  - h/modex - "const PixelFormatRef" is a const pointer to a non-const PixelFormat, but we want "const PixelFormat *", for a pointer to a const PixelFormat
Admin:
  Tested on Raspberry Pi 3, Iyonix, IGEPv5
  Note that we can't easily remove the Service_ModeTranslation handler from ScreenModes and rely purely on the one in the kernel because the kernel can't easily see which modes ScreenModes provides (ditto other Service_ModeTranslation handlers).


Version 0.71. Tagged as 'ScrModes-0_71'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* modex.h */

/*
 * Internal definitions used by ScreenModes module.
 */

#ifndef DODEBUG
#define DODEBUG 0
#endif

#if DODEBUG
#define IFDEBUG    if (!1) {} else
#else
#define IFDEBUG    if (1) {} else
#endif

/* When defined, we can derive monitor definitions from the
 * DMT set using the 3-byte lookup table.
 */
#define DERIVE_CVT3_FROM_DMT

/* When defined, set the value to force a particular timing
 * calculation type from the available set.
 */
#undef  FORCE_TIMINGS /* eg. EDID_USE_CVTRB */

/* When defined, force calculated values (ie. don't prefer DMT) */
#undef  FORCE_CALCULATED_VALUES

/* HSync & VSync polarities for use by display_monitor_timings */
#define HSync_Positive 0
#define HSync_Negative SyncPol_InvertHSync
#define VSync_Positive 0
#define VSync_Negative SyncPol_InvertVSync
#define PP HSync_Positive+VSync_Positive
#define PN HSync_Positive+VSync_Negative
#define NP HSync_Negative+VSync_Positive
#define NN HSync_Negative+VSync_Negative

/* Defines which is the most advanced timing calculation available
 * We use DMT if defined for that mode and calculate using the timing
 * If not. If USE_DMT is highest it is DMT or nothing.
 */
#define EDID_USE_DMT   (0) /* Display monitor timings */
#define EDID_USE_GTF   (1) /* Generalised timing formula */
#define EDID_USE_GTF2  (2)
#define EDID_USE_CVT   (3) /* Coordinated video timings from VESA */
#define EDID_USE_CVTRB (4) /* CVT with reduced blanking */

/*
 * The 6 field framing parameters for each direction, horizontal and
 * vertical.  In horizontal case, the parameters are measured in VIDC
 * pixel times; for vertical, VIDC raster times.
 */
#define FR_SYNC         0               /* sync pulse width */
#define FR_BPCH         1               /* back porch */
#define FR_BDR1         2               /* top (V) / left (H) border height/width */
#define FR_DISP         3               /* active data display height/width  */
#define FR_BDR2         4               /* bottom (V) / right (H) border height/width */
#define FR_FPCH         5               /* front porch */
#define FR__COUNT       6               /* how many parameters altogether */

/*
 * The video control list parameter index for indicating DPMS state
 */

/**Added by WT 13-1-95 for Stork **/
    #define LCDMODE_VALUE       1       /*Enable*/
    #define LCDDUAL_VALUE       1       /*Enable*/
    #define LCDOFF0_VALUE       6       /*Defining a 640x480 dual-panel LCD as used in Stork*/
    #define LCDOFF1_VALUE       129     /*Defining a 640x480 dual-panel LCD as used in Stork*/
    #define DACCTRL_VALUE       1       /*Enable - testing only*/
/**End of additions**/

/* Pixel format representation used by GraphicsV */
typedef struct
{
    int32_t  ncolour;                   /* NColour mode variable */
    uint32_t modeflags;                 /* relevant ModeFlags */
    uint32_t log2bpp;                   /* Log2BPP mode variable */
} PixelFormat, *PixelFormatRef;

/* Two-word structure in a mode selector or VIDC list */
typedef struct
{
    int32_t index;                      /* -1 as index is invalid & marks end of list */
    int32_t value;
} ModeParam;

typedef struct
{
    uint32_t bit0:1, format:7, flags:24;
    uint32_t xresol;
    uint32_t yresol;
    uint32_t depth;                     /* as log2(bpp) */
    int32_t  framerate;                 /* in integer Hz */
    ModeParam param[1];                 /* minimum case + 1 word: may be 0 params + 1 term */
} ModeSelector, *ModeSelectorRef;

/* VIDC list as filled in when handling Service_ModeExtension */
typedef struct
{
    uint32_t format;                    /* type 3 for Medusa */
    uint32_t depth;                     /* log code, 0=1bpp to 5=32bpp */
    uint32_t hpar[FR__COUNT];           /* horizontal parameters */
    uint32_t vpar[FR__COUNT];           /* vertical parameters */
    uint32_t pixelrate;                 /* pixel rate measured in kHz */
    uint32_t syncpol;                   /* sync polarity code, 0..3 */
    ModeParam vcparam[13];              /* Holds VCparameters: LCD mode, LCD dual-panel, LCD offsets(2), DAC control, ExtraBytes, -1
                                         * with optional NColour, ModeFlags, DPMS, HCLK Interlaced and/or output_format fields
                                         */
} VIDCList, *VIDCListRef;

/* Mode information block as filled in when handling Service_EnumerateScreenModes */
typedef struct
{
    uint32_t blocksize;                 /* size of this block in bytes */
    uint32_t bit0:1, format:7, flags:24;  /* format == 0 */
    uint32_t xresol;                    /* user-pixels */
    uint32_t yresol;                    /* user-lines */
    uint32_t depth;                     /* as log2(bpp) */
    uint32_t framerate;                 /* to nearest whole Hz value */
    char name[1];                       /* name starts here (dummy size for struct def) */
} ModeInfoBlock, *ModeInfoBlockRef;

/* New format block for specifying new pixel formats */
typedef struct
{
    uint32_t blocksize;                 /* size of this block in bytes */
    uint32_t bit0:1, format:7, flags:24; /* format == 1 */
    uint32_t xresol;                    /* user-pixels */
    uint32_t yresol;                    /* user-lines */
    PixelFormat pixelformat;            /* pixel format */
    uint32_t framerate;                 /* to nearest whole Hz value */
    char name[1];                       /* name starts here (dummy size for struct def) */
} ModeInfoBlock1, *ModeInfoBlock1Ref;

#define IS_MODE_NUMBER(p)  ((uint32_t)(p) < 256)
#define IS_MODE_SEL_PTR(p) (!IS_MODE_NUMBER(p))
#define ALIGN(a)           (((a) + 3) & ~3)
#define UNUSED(k)          ((k)=(k))
#define MODESEL(p)         ((ModeSelectorRef)(p))
#define MAX(a,b)           (((a)<(b))?(b):(a))
#define MIN(a,b)           (((a)>(b))?(b):(a))

/*
 * Monitor & modes description as loaded from ModeInfo file: note,
 * this does not include pixel depth.
 */
#define MAXMONITORNAME     31 /* arbitrary, but careful not to overrun Display Manager title bar */
#define MAXMODENAME        31 /* arbitrary, but careful not to clip Display Manager menu width */

typedef struct
{
    uint32_t xres;                      /* User quoted xres (may differ from hpar[FR_DISP], especially in interlaced modes) */
    uint32_t yres;                      /* User quoted yres (may differ from vpar[FR_DISP], ... */
    uint16_t hpar[FR__COUNT];           /* H. framing in pixel times */
    uint16_t vpar[FR__COUNT];           /* V. framing in raster times */
    uint32_t pixel_khz;                 /* pixel rate in kHz */
    uint32_t external_clock;            /* rate of external clock in kHz (use it instead of VCO), or -1 */
    uint8_t  syncpol;                   /* sync polarity code (0..3 for now) */
    uint8_t  interlaced;                /* whether mode is interlaced using two seperate framebuffers (0 or 1) */
    uint8_t  freq, spare2;              /* explicit padding so struct is N*4 bytes long */
} ModeDef; /* Abbreviated form, without the name */

typedef struct
{
    char    name[MAXMODENAME+1];
    ModeDef timings;
} ModeDefinition;

/* As stored internally by ScreenModes module */
typedef struct mode_description_
{
    struct mode_description_ *next;     /* in list built during file parsing */
    ModeDefinition definition;          /* as extracted from the file */
    /* The following are computed once the mode definition is read in from the file */
    uint32_t line_hz;                   /* line rate in Hz (for diagnostics only) */
    uint32_t frame_hz:8;                /* frame rate in Hz, for user frame rate selection */
    uint32_t frame_mhz:24;              /* also in mHz (millihertz), for more precise cmp */
    uint8_t  priority;                  /* Bits 0-2 = 'Parameter type' from? (EDID 1.4 Section 5) */
                                        /*            0 = Undefined (MDF or something which overrides all else) */
                                        /*            1 = Preferred Timing Mode from base EDID */
                                        /*            2 = Detailed Timing Mode in the base EDID */
                                        /*            3 = Any detailed timing modes in extension blocks */
                                        /*            4 = Any optional 3-byte CVT codes in the base EDID or extension block */
                                        /*            5 = Standard Timings listed in base EDID or extension blocks */
                                        /*            6 = Additional timing mode information: Established Timings I, II, III, */
                                        /*                default GTF, GTF secondary curve and CVT */
                                        /*            7 = Base VIDEO MODE (defined as 640 x 480 x 60Hz). */
} ModeDescription, *ModeDescriptionRef;

/* Audio format information extracted from EDID */
typedef struct
{
    uint8_t format_code;                /* As per CEA 861-D */
    uint8_t max_channels;
    uint8_t sample_rates;               /* Byte #2 of short audio descriptor */
    uint8_t format_specific;            /* Byte #3 of short audio descriptor */
} AudioFormat;

/* Description of a monitor & its associated modes */
typedef struct
{
    char name[MAXMONITORNAME+1];
    ModeDescriptionRef modelist;
    uint32_t dpms_state;                /* value specified by DPMS_state keyword, or 0 if none */
    uint32_t lcd_support;               /* 0=>modefile is CRT, 1=>LCD single-panel, 2=>LCD dual panel [WT13-01-95] */
    uint32_t external_clock;            /* rate of external clock in kHz (use it instead of VCO) */
    uint32_t output_format;             /* 0=analogue, 1=digital */

    AudioFormat *audio_formats;         /* (Optional) list of supported audio formats */
    int      audio_format_count;        /* Length of list */
    uint8_t  speaker_mask;              /* (Optional) speaker mask (as per CEA 861-D) */
    bool     speaker_mask_provided;
} MonitorDescription, *MonitorDescriptionRef;

/* Maps a 2-byte 'STD code' to a DMT (STD codes defined in EDID spec) */
typedef struct
{
    char stdcode[2];                    /* TODO: comment required here */
    char dmt;                           /* TODO: comment required here */
} STDTiming;

/* Maps a 3-byte 'CVT code' to a DMT (CVT codes defined in EDID spec) */
typedef struct
{
    char cvtcode[3];                    /* TODO: comment required here */
    char dmt;                           /* TODO: comment required here */
} CVTTiming;

/* Extern variables and functions */
extern ModeSelectorRef preferred_mode;
extern MonitorDescriptionRef current_monitor;
extern int old_monitortype;
extern int preferred_sync_type;

_kernel_oserror *error(int, const char *, const char *, const char *);
_kernel_oserror *messages_lookup(char *, size_t, const char *, const char *, const char *, const char *);
_kernel_oserror *new_monitordescription(MonitorDescriptionRef *);
void release_currentmonitor(void);
void free_monitordescription(MonitorDescriptionRef);
void compute_modedescription(ModeDescriptionRef);
void sort_modelist(ModeDescriptionRef *);
bool is_old_format(const PixelFormat *);
bool find_deepest_by_xyhz(PixelFormatRef, ModeDescriptionRef);
_kernel_oserror *set_monitortype(int);
int read_monitortype(void);
_kernel_oserror *restore_monitortype(void);

/* EOF modex.h */
@


4.19
log
@Add support for new GraphicsV_VetMode2 call
Detail:
  VetMode2 allows the driver to give the OS extra feedback about a proposed mode. In particular, it allows the driver to suggest a value for the ExtraBytes control list item, so by using the VetMode2 call ScreenModes is able to support modes where the video driver requires extra padding to be added to the framebuffer.
  h/modex - Remove local definitions of control list item numbers. Reserve space for one extra control list item in the VIDCList structure.
  c/ScrModes - Use Global/VIDCList.h for control list item numbers. Update mode_valid to make use of VetMode2 where available, and give it the ability to copy the resulting VIDCList into a caller-supplied buffer, allowing service_modeextension to easily use the correct ExtraBytes setting.
Admin:
  Tested on Raspberry Pi 3
  Requires Kernel-5_82


Version 0.65. Tagged as 'ScrModes-0_65'
@
text
@d259 1
a259 1
bool is_old_format(const PixelFormatRef);
@


4.18
log
@Offer export of raw EDID blob and complementary MDF export
Detail:
  Export the EDID raw data as a file in ResourceFS. This allows the Screen Setup plugin to scan that directory to pick up the currently connected monitor, and similarly select it from !Boot.Choices.PreDesk. The EDID data can also be drag & drop copied or exported for offline analysis.
  Add SaveModeFile command. This differs in that it works on the current set, to be symmetrical with LoadModeFile which loads the current set. Also fixes issues of losing the original mode names given; NULL pointer dereference when the EDID block contains no modes (eg. VIDCDriver); and no long writes out malformed MDFs which can't be loaded into !MakeModes (this seems to be because the CreateModeFile command was based on a stale copy of EDIDDecode which fixed the same bug circa 2012).
  Query the current GraphicsV driver for the deepest colour depth for the preferred mode, rather than assuming 32bpp is always possible (eg. because of bandwidth or graphics controller constraints).
  If the configured MonitorType is EDID but no EDID could be read, or it was corrupt, substitute a safe VESA monitor to allow the kernel to select something close to MODE 28.
  Add ScreenModes_Features SWI so the Screen Setup plugin knows whether it's safe to offer EDID in its dialogues.
  Retire the ReadEDID command (no longer needed since LoadModeFile can load the exported EDID blob, or one from disc) and CreateModeFile commands (see SaveModeFile).
  Internationalise the default monitor title ("Unidentified") used when EDID doesn't contain one.
Admin:
  New file - doc/BootStates documents all possible situations, and their recovery, for both the MDF and (non-hotplug) EDID schemes.
  New file - doc/EDIDGoals states the aims of the EDID support from both a user and support perspective.

  Submission for the EDID bounty.

Version 0.61. Tagged as 'ScrModes-0_61'
@
text
@a81 1
#define LCDMODE_INDEX   01
a82 1
#define LCDDUAL_INDEX   02
a83 1
#define LCDOFF0_INDEX   03
a84 1
#define LCDOFF1_INDEX   04
a85 1
#define DACCTRL_INDEX   06
a88 7
#define HCLK_INDEX       9
#define DPMS_INDEX       11
#define INTERLACED_INDEX 12
#define OPFORMAT_INDEX   13
#define NCOLOUR_INDEX    15
#define MODEFLAGS_INDEX  16

d123 1
a123 1
    ModeParam vcparam[12];              /* Holds VCparameters: LCD mode, LCD dual-panel, LCD offsets(2), DAC control, -1
@


4.17
log
@Omit mode name from lookup tables
Detail:
  Save 4k of ROM space by not storing the mode name string; always generate it at run time.
  Split the ModeDefinition struct into the timings part (ModeDef) and full definition (ModeDefinition).
Admin:
  Submission for the EDID bounty.
  Tagged as ScrModes-0_56-smalltables.
@
text
@d166 1
a260 1
extern bool EDIDEnabled;
d265 2
d271 2
@


4.16
log
@Take advantage of tail of generate functions being common
Detail:
  Now all generation steps end in compute_modedescription()/add_proposed_mode()/display_mode_parameters(), combine these steps into the add_proposed_mode() function.
  Fix for CVT and GTF generation steps never setting the 'priority' member of the descriptor. These are now set to 6 per Table 5.1 of EDID spec 1.4.
Admin:
  Submission for the EDID bounty.

Version 0.56. Tagged as 'ScrModes-0_56'
@
text
@a179 1
    char name[MAXMODENAME+1];
d189 6
a197 1

@


4.15
log
@Switch to integer implementation
Detail:
  The dynamic range of the values being computed easily fit within integer types, so use these instead of doubles. This makes ScrModes independent of its position in intialisation with respect to FPEmulator once more, and saves 1k of code space too.
  Functions generate_mode_using_gtf(), generate_mode_using_cvt_rb(), generate_cvt3_timing() affected.
Admin:
  Test added to brute force compare float and fixed point results.
  Submission for the EDID bounty.

Version 0.55. Tagged as 'ScrModes-0_55'
@
text
@d183 3
a185 3
    uint16_t hpar[FR__COUNT];           /* H. framing in vidc pixel times */
    uint16_t vpar[FR__COUNT];           /* V. framing in vidc raster times */
    uint32_t pixel_khz;                 /* vidc pixel rate in kHz */
d202 1
a202 1
    uint8_t  priority;                  /* Bits 0-2 = 'Parameter type' - where did the definition come from? (EDID 1.4 Section 5 */
d205 1
a205 1
                                        /*            2 = A Detailed timing mode in the base EDID */
d208 1
a208 1
                                        /*            5 = Standard Timings listed in Base EDID or extension blocks */
d211 1
a211 1
                                        /*            7 = Base VIDEO MODE (defined as 640 X 480 X 60Hz). */
@


4.14
log
@Split out MDF and EDID support
Detail:
  Main source file split into 3.
Admin:
  Tested briefly, functionality unchanged.
  Submission for the EDID bounty.
  Tagged as ScrModes-0_53-split
@
text
@d168 2
@


4.13
log
@Split out data tables, stylistic refactoring
Detail:
  Move the 500+ lines of tables into a new source file and remove storage inferred by former CEAModes.h.
  Tame some of the rampant style from various authors, even within 1 function, to something reasonably consistent.
  Uppercase the 'debug' macro to 'IFDEBUG'.
  Relocate ScrModes specific defines out of EDIDModes header, rename to edidmemory.h.
  Add monitor type 6 to monitors.h.
  Fix for unguarded debug printout "Can't allocate space for monitor list" in parseedid.
Admin:
  Tested briefly, functionality unchanged.
  Submission for the EDID bounty.
  Tagged as ScrModes-0_53-tables
@
text
@d21 10
d251 16
@


4.12
log
@Add support for parsing and reporting the contents of CEA 861-D audio-related EDID blocks
Detail:
  Makefile - Export a C version of hdr/ScrModes
  Resources/Germany/Messages, Resources/UK/Messages, h/errors - Add new error message
  cmhg/ScrModesv, hdr/ScrModes - Declare existence of ScreenModes_EnumerateAudioFormats SWI. Declare ScreenModes_ReadInfo reason codes.
  h/modex - Extend MonitorDefinition struct to allow it to store the speaker mask & audio format information that's extracted from the EDID
  c/ScrModes - Extend support for processing of CEA extension blocks. All block revisions > 0 should now be accepted, and rudimentary parsing of CEA data block collections is implemented (currently, only extracts information from audio related blocks). Add SWI ScreenModes_EnumerateAudioFormats to allow details of the supported formats to be returned in either "raw" or "friendly" forms. Add ScreenModes_ReadInfo reason code 1 to allow reading of the speaker mask (+ validity bits). Also fix *LoadModeFile to allow EDID blocks to be loaded without first having to issue *ReadEDID first (EDIDEnabled flag issue).
Admin:
  Tested on iMX6 with assorted EDID blocks
  German messages file in need of translation


Version 0.49. Tagged as 'ScrModes-0_49'
@
text
@d21 33
d94 1
a94 1
    int32_t ncolour;                    /* NColour mode variable */
d221 4
a224 4
    AudioFormat* audio_formats;         /* (Optional) list of supported audio formats */
    int audio_format_count;             /* Length of list */
    uint8_t speaker_mask;               /* (Optional) speaker mask (as per CEA 861-D) */
    bool speaker_mask_provided;
d227 1
a227 1
/* Maps a 2-byte 'STD code' to a DMT (STD codes defined in EDID spec)*/
d234 1
a234 1
/* Maps a 3-byte 'CVT code' to a DMT (CVT codes defined in EDID spec)*/
a240 1

@


4.11
log
@Add support for CVT 3 byte codes & VTB-EXT blocks. Other misc fixes.
Detail:
  c/ScrModes, h/modex - Added support for CVT 3 byte codes & VTB-EXT blocks. Add framework for sorting modes by EDID priority. Move CEA extension block handling into its own function & increase error checking.
  Resources/Germany/CmdHelp, Resources/UK/CmdHelp - Fix missing message token & incorrect syntax of syntax message
Admin:
  Code submission from William Harden
  Tested on Raspberry Pi


Version 0.47. Tagged as 'ScrModes-0_47'
@
text
@d169 9
d187 5
@


4.10
log
@Added prototype EDID support code.

This should be considered beta-quality work-in-progress code that gives us a
new *command (ReadEDID) that attempts to read the list of supported display
mode information from a connected monitory and configure the system for it,
as if an MDF file had been loaded containing that information.

Admin:

Community testing is required for this feature. Please try replacing the
LoadModeFile line in your !Boot.Choices.Boot.PreDesk.Configure.Monitor
file with a line saying "ReadEDID". If you get a sensible looking list
of modes when the machine boots, then things should be OK. If you see an
error, please get in touch with ROOL on the "Bounties - ReadEDID" topic.
You'll clearly need to be running a ROM with this version of ScreenModes
in it!

Version 0.39. Tagged as 'ScrModes-0_39'
@
text
@d144 1
a144 1
    uint8_t  freq, spare2;            /* explicit padding so struct is N*4 bytes long */
d157 10
@


4.9
log
@Ensure syncpol word of VIDC list initialised correctly
Detail:
  h/modex - Define the syncpol flags as taking up a full word of space, to avoid bits 2-31 being left undefined when generating a VIDC list, and potentially resulting in wrong interlace setting being used
Admin:
  Tested on Raspberry Pi


Version 0.37. Tagged as 'ScrModes-0_37'
@
text
@a20 1

d144 1
a144 1
    uint8_t  spare1, spare2;            /* explicit padding so struct is N*4 bytes long */
d170 14
@


4.8
log
@Update to add support for new pixel formats and basic support for multiple GraphicsV drivers
Detail:
  c/ScrModes - All GraphicsV calls now use the current driver number instead of always calling driver 0. Get the list of supported pixel formats via GraphicsV 17 if implemented, otherwise fall back to GraphicsV 8. Generate old or new style mode provider blocks as appropriate.
  h/modex - Update definitions for new mode provider block format, new control list items
Admin:
  Tested in Tungsten, IOMD, OMAP3, BCM2835 ROMs
  Requires HdrSrc-2_38 and Kernel-5_35-4_79_2_203


Version 0.36. Tagged as 'ScrModes-0_36'
@
text
@d92 1
a92 1
    uint32_t syncpol:2, :0;             /* sync polarity code, 0..3 */
@


4.7
log
@Relax clipping of mode names
19 characters is a bit mean if you want to say "2048 x 1024 big monitor" or similar, so bumped it to 31+terminator.
100 characters for the monitor title is a bit lavish, since (in System font) display manager's title bar can only fit 33 characters, reduced to 31+terminator too.
Fixes ticket #302.

Version 0.34. Tagged as 'ScrModes-0_34'
@
text
@d56 2
d59 7
d93 2
a94 2
    ModeParam vcparam[10];              /* Holds VCparameters: LCD mode, LCD dual-panel, LCD offsets(2), DAC control, -1
                                         * with optional DPMS, HCLK Interlaced and/or output_format fields
d102 1
a102 1
    uint32_t bit0:1, format:7, flags:24;
d110 12
d144 1
a144 1
    uint8_t  interlaced;                /* whether mode is interlaced (0 or 1) */
d171 1
@


4.6
log
@Clean up pass
* Makefile recreated from fragments
* Swap to C99 types, remove 'machtypes.h'
* Use centralised SWI and service call definitions, remove 'newswis.h' and 'services.h'
* Error E21 taken out of resources, CMHG generates this one for free
* Compiler warnings squashed

Version 0.32. Tagged as 'ScrModes-0_32'
@
text
@d104 1
a104 1
#define MODESEL(p) ((ModeSelectorRef)(p))
d110 2
a111 2
#define MAXMONITORNAME 100              /* for now */
#define MAXMODENAME 19                  /* for now */
d142 1
a142 1
    char name[MAXMONITORNAME];
@


4.5
log
@added support for output_format keyword in MDFs, value of 1 means digital
intended for cases like video controller attached to Chrontel for TV display
untested

Version 0.27. Not tagged
@
text
@d61 2
a62 2
    int32 index;                        /* -1 as index is invalid & marks end of list */
    int32 value;
d67 5
a71 5
    uns32 bit0:1, format:7, flags:24;
    uns32 xresol;
    uns32 yresol;
    uns32 depth;                        /* as log2(bpp) */
    int32 framerate;                    /* in integer Hz */
d78 7
a84 7
    uns32 format;                       /* type 3 for Medusa */
    uns32 depth;                        /* log code, 0=1bpp to 5=32bpp */
    uns32 hpar[FR__COUNT];              /* horizontal parameters */
    uns32 vpar[FR__COUNT];              /* vertical parameters */
    uns32 pixelrate;                    /* pixel rate measured in kHz */
    uns32 syncpol:2, :0;                /* sync polarity code, 0..3 */
    ModeParam vcparam[10];               /* Holds VCparameters: LCD mode, LCD dual-panel, LCD offsets(2), DAC control, -1
d92 6
a97 6
    uns32 blocksize;                    /* size of this block in bytes */
    uns32 bit0:1, format:7, flags:24;
    uns32 xresol;                       /* user-pixels */
    uns32 yresol;                       /* user-lines */
    uns32 depth;                        /* as log2(bpp) */
    uns32 framerate;                    /* to nearest whole Hz value */
d101 1
a101 1
#define IS_MODE_NUMBER(p) ((uns32)(p) < 256)
d103 1
a103 1

d116 9
a124 9
    uns32 xres;                         /* User quoted xres (may differ from hpar[FR_DISP], especially in interlaced modes) */
    uns32 yres;                         /* User quoted yres (may differ from vpar[FR_DISP], ... */
    uns16 hpar[FR__COUNT];              /* H. framing in vidc pixel times */
    uns16 vpar[FR__COUNT];              /* V. framing in vidc raster times */
    uns32 pixel_khz;                    /* vidc pixel rate in kHz */
    uns32 external_clock;               /* rate of external clock in kHz (use it instead of VCO), or -1 */
    uns8 syncpol;                       /* sync polarity code (0..3 for now) */
    uns8 interlaced;                    /* whether mode is interlaced (0 or 1) */
    uns8 spare1, spare2;                /* explicit padding so struct is N*4 bytes long */
d134 3
a136 3
    uns32 line_hz;                      /* line rate in Hz (for diagnostics only) */
    uns32 frame_hz:8;                   /* frame rate in Hz, for user frame rate selection */
    uns32 frame_mhz:24;                 /* also in mHz (millihertz), for more precise cmp */
d144 4
a147 4
    uns32 dpms_state;                   /* value specified by DPMS_state keyword, or 0 if none */
    uns32 lcd_support;                  /* 0=>modefile is CRT, 1=>LCD single-panel, 2=>LCD dual panel [WT13-01-95] */
    uns32 external_clock;               /* rate of external clock in kHz (use it instead of VCO) */
    uns32 output_format;                /* 0=analogue, 1=digital */
@


4.4
log
@Can now add the line "external_clock:xxx" to individual modes - this overrides
any directive (or lack of one) at the top of the file.

Untested, but required for Lazarus NTSC TV MDF.

Version 0.25. Tagged as 'ScrModes-0_25'
@
text
@d55 1
d84 3
a86 3
    ModeParam vcparam[9];               /* Holds VCparameters: LCD mode, LCD dual-panel, LCD offsets(2), DAC control, -1
    					 * with optional DPMS, HCLK and/or Interlaced fields
    					 */
d116 2
a117 2
    uns32 xres;				/* User quoted xres (may differ from hpar[FR_DISP], especially in interlaced modes) */
    uns32 yres;				/* User quoted yres (may differ from vpar[FR_DISP], ... */
d123 2
a124 2
    uns8 interlaced;			/* whether mode is interlaced (0 or 1) */
    uns8 spare1, spare2; 	        /* explicit padding so struct is N*4 bytes long */
d147 1
@


4.3
log
@Added support for "external_clock" keyword - if specified, gives the
frequency of HCLK, and instructs the kernel to use it instead of the VCO.
Corresponds to video control parameter 9 (PRM 5a-126).

Version 0.21. Tagged as 'ScrModes-0_21'
@
text
@d120 1
@


4.2
log
@NCOS 1.06 version used
@
text
@d52 1
d83 2
a84 2
    ModeParam vcparam[8];               /* Holds VCparameters: LCD mode, LCD dual-panel, LCD offsets(2), DAC control, -1
    					 * with optional DPMS and/or Interlaced fields
d144 1
@


4.1
log
@Initial revision
@
text
@d21 1
d39 15
a53 1
#define DPMS_INDEX      11
d57 1
a57 1
typedef struct 
d82 3
a84 1
    ModeParam vcparam[2];               /* holds either just -1 terminator, or (DPMS_index, DPMS_value), -1 */
d114 2
d120 2
a121 1
    uns8 spare1, spare2, spare3;        /* explicit padding so struct is N*4 bytes long */
d142 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a20 1

d38 1
a38 15
/**Added by WT 13-1-95 for Stork **/
#define LCDMODE_INDEX   01
    #define LCDMODE_VALUE       1       /*Enable*/
#define LCDDUAL_INDEX   02
    #define LCDDUAL_VALUE       1       /*Enable*/
#define LCDOFF0_INDEX   03
    #define LCDOFF0_VALUE       6       /*Defining a 640x480 dual-panel LCD as used in Stork*/
#define LCDOFF1_INDEX   04
    #define LCDOFF1_VALUE       129     /*Defining a 640x480 dual-panel LCD as used in Stork*/
#define DACCTRL_INDEX   06
    #define DACCTRL_VALUE       1       /*Enable - testing only*/
/**End of additions**/

#define DPMS_INDEX       11
#define INTERLACED_INDEX 12
d42 1
a42 1
typedef struct
d67 1
a67 3
    ModeParam vcparam[8];               /* Holds VCparameters: LCD mode, LCD dual-panel, LCD offsets(2), DAC control, -1
    					 * with optional DPMS and/or Interlaced fields
    					 */
a96 2
    uns32 xres;				/* User quoted xres (may differ from hpar[FR_DISP], especially in interlaced modes) */
    uns32 yres;				/* User quoted yres (may differ from vpar[FR_DISP], ... */
d101 1
a101 2
    uns8 interlaced;			/* whether mode is interlaced (0 or 1) */
    uns8 spare1, spare2; 	        /* explicit padding so struct is N*4 bytes long */
a121 1
    uns32 lcd_support;                  /* 0=>modefile is CRT, 1=>LCD single-panel, 2=>LCD dual panel [WT13-01-95] */
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a20 1

d38 1
a38 15
/**Added by WT 13-1-95 for Stork **/
#define LCDMODE_INDEX   01
    #define LCDMODE_VALUE       1       /*Enable*/
#define LCDDUAL_INDEX   02
    #define LCDDUAL_VALUE       1       /*Enable*/
#define LCDOFF0_INDEX   03
    #define LCDOFF0_VALUE       6       /*Defining a 640x480 dual-panel LCD as used in Stork*/
#define LCDOFF1_INDEX   04
    #define LCDOFF1_VALUE       129     /*Defining a 640x480 dual-panel LCD as used in Stork*/
#define DACCTRL_INDEX   06
    #define DACCTRL_VALUE       1       /*Enable - testing only*/
/**End of additions**/

#define DPMS_INDEX       11
#define INTERLACED_INDEX 12
d42 1
a42 1
typedef struct
d67 1
a67 3
    ModeParam vcparam[8];               /* Holds VCparameters: LCD mode, LCD dual-panel, LCD offsets(2), DAC control, -1
    					 * with optional DPMS and/or Interlaced fields
    					 */
a96 2
    uns32 xres;				/* User quoted xres (may differ from hpar[FR_DISP], especially in interlaced modes) */
    uns32 yres;				/* User quoted yres (may differ from vpar[FR_DISP], ... */
d101 1
a101 2
    uns8 interlaced;			/* whether mode is interlaced (0 or 1) */
    uns8 spare1, spare2; 	        /* explicit padding so struct is N*4 bytes long */
a121 1
    uns32 lcd_support;                  /* 0=>modefile is CRT, 1=>LCD single-panel, 2=>LCD dual panel [WT13-01-95] */
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a20 1

a37 13
/**Added by WT 13-1-95 for Stork **/
#define LCDMODE_INDEX   01
    #define LCDMODE_VALUE       1       /*Enable*/
#define LCDDUAL_INDEX   02
    #define LCDDUAL_VALUE       1       /*Enable*/
#define LCDOFF0_INDEX   03
    #define LCDOFF0_VALUE       6       /*Defining a 640x480 dual-panel LCD as used in Stork*/
#define LCDOFF1_INDEX   04
    #define LCDOFF1_VALUE       129     /*Defining a 640x480 dual-panel LCD as used in Stork*/
#define DACCTRL_INDEX   06
    #define DACCTRL_VALUE       1       /*Enable - testing only*/
/**End of additions**/

d42 1
a42 1
typedef struct
d67 1
a67 1
    ModeParam vcparam[6];               /* Holds VCparameters: LCD mode, LCD dual-panel, LCD offsets(2), DAC control, -1 or DPMS, -1 (WT) */
a121 1
    uns32 lcd_support;                  /* 0=>modefile is CRT, 1=>LCD single-panel, 2=>LCD dual panel [WT13-01-95] */
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

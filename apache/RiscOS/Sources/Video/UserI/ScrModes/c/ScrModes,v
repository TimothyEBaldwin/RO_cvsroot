head	4.48;
access;
symbols
	ScrModes-0_71:4.48
	ScrModes-0_70:4.47
	ScrModes-0_69:4.46
	ScrModes-0_68:4.45
	ScrModes-0_67:4.44
	ScrModes-0_66:4.44
	ScrModes-0_65:4.43
	ScrModes-0_64:4.42
	ScrModes-0_62:4.41
	ScrModes-0_61:4.40
	ScrModes-0_60:4.39
	ScrModes-0_59:4.39
	ScrModes-0_58:4.39
	ScrModes-0_57:4.38
	ScrModes-0_56-smalltables:4.38
	ScrModes-0_56:4.37
	ScrModes-0_55-mallocfree:4.37
	ScrModes-0_55-cvs3fix:4.37
	ScrModes-0_55:4.37
	ScrModes-0_53-split:4.37
	ScrModes-0_54:4.37
	ScrModes-0_53-tables:4.36
	ScrModes-0_53:4.35
	ScrModes-0_52:4.34
	ScrModes-0_51:4.33
	ScrModes-0_50:4.32
	ScrModes-0_49:4.31
	ScrModes-0_48:4.30
	ScrModes-0_47:4.28
	ScrModes-0_46:4.25
	ScrModes-0_45:4.24
	ScrModes-0_44:4.23
	ScrModes-0_43:4.22
	ScrModes-0_42:4.21
	ScrModes-0_41:4.20
	ScrModes-0_40:4.19
	ScrModes-0_39:4.18
	ScrModes-0_38:4.17
	ScrModes-0_37:4.16
	ScrModes-0_36:4.16
	ScrModes-0_35:4.15
	ScrModes-0_34:4.14
	ScrModes-0_33:4.13
	ScrModes-0_32:4.12
	ScrModes-0_31:4.11
	RO_5_07:4.11
	ScrModes-0_30:4.11
	ScrModes-0_29:4.10
	ScrModes-0_28:4.10
	dellis_autobuild_BaseSW:4.9
	ScrModes-0_27:4.9
	ScrModes-0_26:4.8
	sbrodie_sedwards_16Mar2000:4.7
	ScrModes-0_25:4.7
	ScrModes-0_24:4.6
	dcotton_autobuild_BaseSW:4.10
	ScrModes-0_23:4.5
	ScrModes-0_22:4.4
	ScrModes-0_21:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	ScrModes-0_20:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.48
date	2018.11.07.22.38.40;	author jlee;	state Exp;
branches;
next	4.47;
commitid	AU2ztWfFYsRL04ZA;

4.47
date	2018.09.25.17.06.09;	author rsprowson;	state Exp;
branches;
next	4.46;
commitid	itewjqPZSC8oyvTA;

4.46
date	2018.09.16.20.21.42;	author jlee;	state Exp;
branches;
next	4.45;
commitid	EbAbYepMbBenVmSA;

4.45
date	2018.03.31.20.09.40;	author rsprowson;	state Exp;
branches;
next	4.44;
commitid	nCwnyjaeiOh4iEwA;

4.44
date	2017.06.17.14.54.59;	author jlee;	state Exp;
branches;
next	4.43;
commitid	coWHi23JVMh5MJVz;

4.43
date	2017.06.07.21.16.19;	author jlee;	state Exp;
branches;
next	4.42;
commitid	VTErhLKp4wwPcuUz;

4.42
date	2017.05.01.22.56.45;	author jballance;	state Exp;
branches;
next	4.41;
commitid	5CirA5GqnOtYWJPz;

4.41
date	2017.03.12.21.51.13;	author jballance;	state Exp;
branches;
next	4.40;
commitid	OQXOPuW08nWacjJz;

4.40
date	2017.03.05.15.21.05;	author rool;	state Exp;
branches;
next	4.39;
commitid	dv9rieZmjERhgnIz;

4.39
date	2016.11.26.13.11.04;	author jlee;	state Exp;
branches;
next	4.38;
commitid	urAfrqa1D6g0JDvz;

4.38
date	2016.08.06.09.33.44;	author rool;	state Exp;
branches;
next	4.37;
commitid	NoDZxDMSFpBS6ehz;

4.37
date	2016.05.14.12.45.35;	author rool;	state Exp;
branches;
next	4.36;
commitid	DAkVsTOsI1rFSr6z;

4.36
date	2016.05.14.12.40.23;	author rool;	state Exp;
branches;
next	4.35;
commitid	UkO7RI5AYo6IQr6z;

4.35
date	2016.01.10.18.01.19;	author jlee;	state Exp;
branches;
next	4.34;
commitid	elsfIXLp0rhgEpQy;

4.34
date	2016.01.08.23.47.09;	author jlee;	state Exp;
branches;
next	4.33;
commitid	CKX18tvKaVSTCbQy;

4.33
date	2016.01.06.21.39.02;	author jlee;	state Exp;
branches;
next	4.32;
commitid	wyReCAfb7LMVYUPy;

4.32
date	2015.12.15.21.30.38;	author jlee;	state Exp;
branches;
next	4.31;
commitid	GWLnKhwlawnTD5Ny;

4.31
date	2015.11.29.20.34.53;	author jlee;	state Exp;
branches;
next	4.30;
commitid	X917PzTaosbDQ1Ly;

4.30
date	2015.02.24.00.25.10;	author jlee;	state Exp;
branches;
next	4.29;
commitid	B1b4uf3XadvH5cby;

4.29
date	2015.02.24.00.18.04;	author jlee;	state Exp;
branches;
next	4.28;
commitid	bwAKx0u0U03g3cby;

4.28
date	2015.02.20.22.13.12;	author jlee;	state Exp;
branches;
next	4.27;
commitid	nm5Di7IUt9XpsNay;

4.27
date	2015.02.20.22.07.01;	author jlee;	state Exp;
branches;
next	4.26;
commitid	4zU1s0te3x0jqNay;

4.26
date	2015.02.20.22.00.16;	author jlee;	state Exp;
branches;
next	4.25;
commitid	Y4rZtzOMEfbVnNay;

4.25
date	2015.02.16.20.52.31;	author jlee;	state Exp;
branches;
next	4.24;
commitid	OjWtIwiTjABG8hay;

4.24
date	2015.02.16.14.28.53;	author jballance;	state Exp;
branches;
next	4.23;
commitid	Opb0gcw7dLV21fay;

4.23
date	2015.02.14.18.31.47;	author jlee;	state Exp;
branches;
next	4.22;
commitid	PzpEhkyiJLuoq0ay;

4.22
date	2015.02.14.00.46.24;	author jlee;	state Exp;
branches;
next	4.21;
commitid	7V3sVxHfYkNTwU9y;

4.21
date	2015.02.12.23.33.11;	author jballance;	state Exp;
branches;
next	4.20;
commitid	9NbbcEtKle1M9M9y;

4.20
date	2015.02.11.14.26.04;	author jballance;	state Exp;
branches;
next	4.19;
commitid	6EKF0rYxx0X1aB9y;

4.19
date	2015.02.10.01.25.10;	author jballance;	state Exp;
branches;
next	4.18;
commitid	swACId1zhgf7So9y;

4.18
date	2015.02.08.16.18.03;	author srevill;	state Exp;
branches;
next	4.17;
commitid	diy9pjBgTsmrSd9y;

4.17
date	2014.03.09.16.07.24;	author jlee;	state Exp;
branches;
next	4.16;
commitid	TZY0XSUVr5ArC2sx;

4.16
date	2013.12.15.22.00.54;	author jlee;	state Exp;
branches;
next	4.15;
commitid	Y1CypBuj2rr7hhhx;

4.15
date	2013.01.06.21.19.53;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	Xbz0V5WctaNB4czw;

4.14
date	2012.08.28.07.08.05;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	oDpFFAGAvHPszhiw;

4.13
date	2012.08.12.16.21.28;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	nNXWhBWs82za9hgw;

4.12
date	2012.07.14.19.38.59;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	YTNC4KmzhMQIazcw;

4.11
date	2003.02.03.10.26.32;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2001.03.01.09.57.12;	author mstephen;	state Exp;
branches;
next	4.9;

4.9
date	2000.06.06.12.42.58;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2000.03.24.18.03.31;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2000.01.10.10.59.28;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.10.12.13.53.20;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.09.16.17.38.11;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.09.16.17.09.01;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.09.16.13.19.20;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.13.08.04;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.46.30;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.46.30;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.50.41;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.02.03;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.24.09;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.48
log
@Improve mode substitution logic
Detail:
  This updates ScreenModes to use similar mode substition logic to Kernel-6_14:
  - Try higher colour depths
  - Try lower colour depths
  - Try alternate resolutions (half-width non-double-pixel if original was double-pixel, assorted industry-standard resolutions, and monitor preferred resolution/timings)
  - Plus tries to preserve as many attributes as possible (eigen values, gap mode type, etc.)
  Additionally, LineLength values in the input mode selector block will be used to influence the VIDC list ExtraBytes value, as per the kernel
  File changes:
  - c/ScrModes - Update Service_ModeTranslation and Service_ModeExtension handlers, as described above
  - h/modex - "const PixelFormatRef" is a const pointer to a non-const PixelFormat, but we want "const PixelFormat *", for a pointer to a const PixelFormat
Admin:
  Tested on Raspberry Pi 3, Iyonix, IGEPv5
  Note that we can't easily remove the Service_ModeTranslation handler from ScreenModes and rely purely on the one in the kernel because the kernel can't easily see which modes ScreenModes provides (ditto other Service_ModeTranslation handlers).


Version 0.71. Tagged as 'ScrModes-0_71'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* ScrModes.c */

/*
 * ScreenModes module main code.
 */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>

#include "kernel.h"
#include "swis.h"
#include "Global/RISCOS.h"
#include "Global/GraphicsV.h"
#include "Global/Services.h"
#include "Global/VduExt.h"
#include "Global/Variables.h"
#include "Global/FileTypes.h"
#include "Global/OsBytes.h"
#include "Global/CMOS.h"
#include "Global/ModHand.h"
#include "Global/VIDCList.h"
#undef   Module_Title /* CMHG defines this too */
#include "Interface/HighFSI.h"
#include "Interface/ScrModes.h"

#include "ScrModesv.h"
#include "errors.h"
#include "monitors.h"
#include "modex.h"
#include "mdfsupport.h"
#include "edidsupport.h"

/* Switch to define whether live EDID read from the monitor is in use.
 * If the graphics driver supports it and MonitorType is EDID this
 * will cause the EDID to be reloaded if the graphics driver changes.
 * Should an MDF be loaded, this behaviour is cancelled (latching). 
 */
static bool using_edid = false;

/* Pointer to (root block of) current monitor definition structure.
 * This becomes valid (non NULL) on successful completion of a
 * *loadmodefile command.  The memory space it consumes is thereafter
 * released on either (a) shutdown of the module or (b) successful
 * completion of another *loadmodefile command.
 */
MonitorDescriptionRef current_monitor = NULL; /* not defined to start with */

ModeSelectorRef preferred_mode = NULL; /* The preferred mode */

/* The sync type for the preferred mode
 * NB only service_monitorleadtranslation uses this value
 */
int preferred_sync_type = 0;
 
/* Keep a copy of the current monitor type at the time of the first
 * successful *LoadModeFile, to restore on exit.
 */
int old_monitortype = -1; /* -1 means we haven't loaded a file yet */

/* Bit mask of which control list items are supported by the current driver */
static uint32_t supported_controllist_items = 0;

static void check_supported_controllist_items(int driver)
{
    _kernel_swi_regs r;
    uint32_t items[ControlList_InvalidReason+1];
    r.r[0] = GVReadInfo_ControlListItems;
    r.r[1] = (int) items;
    r.r[2] = sizeof(items);
    r.r[4] = GraphicsV_ReadInfo | (driver<<24);
    r.r[9] = GraphicsV;
    _kernel_swi(OS_CallAVector, &r, &r);
    
    supported_controllist_items = 0;
 
    if (r.r[4] != 0)
    {
        return;
    }
    int len = (r.r[2] >= 0 ? sizeof(items) - r.r[2] : sizeof(items));
    len >>= 2;
    int idx = 0;
    while (idx < len)
    {
        if (items[idx] < 32)
        {
            supported_controllist_items |= 1u << items[idx];
        }
        idx++;
    }
}

/* Construct an error block from the given ScreenModes module-specific
 * error code and the list of up to 3 arguments.  To ensure easy
 * internationalisability, this is done using text from our Messages
 * file, via MessageTrans_Lookup.  Note that all errors from this
 * module cause the whole process to stop (i.e. there should only be
 * one error generated for any *loadmodefile command) so don't worry
 * about efficiency; e.g. we could keep the file open and the handle
 * lying around, but there really isn't any point.
 */
_kernel_oserror *messages_lookup(char *buffer, size_t space, const char *token,
                                 const char *arg0, const char *arg1, const char *arg2)
{
    /* Handle for MessageTrans. */
    int file_data[4];
    _kernel_oserror *res;

    /* Open the Messages file */
    res = _swix(MessageTrans_OpenFile, _INR(0,2),
                file_data, Module_MessagesFile, 0);
    if (res != NULL)
    {
        return res;
    }

    res = _swix(MessageTrans_Lookup, _INR(0,7),
                file_data, token, buffer, space, arg0, arg1, arg2, NULL);
    /* Always close the messages file, ignoring possible but most unlikely errors */
    (void)_swix(MessageTrans_CloseFile, _IN(0), file_data);
    if (res != NULL)
    {
        buffer[0] = '?'; buffer[1] = '\0'; /* lookup failed */
    }
    return res;
}

_kernel_oserror *error(int error, const char *arg0, const char *arg1, const char *arg2)
{
    /* Where the final returned message is constructed */
    static _kernel_oserror theerror;
    _kernel_oserror *res;
    char token[8];

    sprintf(token, "E%02d", error);
    res = messages_lookup(theerror.errmess, sizeof(theerror.errmess), token, arg0, arg1, arg2);
    if (res != NULL)
    {
        return res;
    }
    /* Construct the rest of the error block, i.e. the error number */
    theerror.errnum = ERROR_BASE + error;
    return &theerror;
}

_kernel_oserror *new_monitordescription(MonitorDescriptionRef *description)
{
    MonitorDescriptionRef md;

    md = (MonitorDescriptionRef) calloc(1, sizeof(MonitorDescription));
    if (md == NULL)
    {
        return error(ERR_NOSPACE, 0, 0, 0);
    }

    messages_lookup(md->name, sizeof(md->name), "NoName", NULL, NULL, NULL);

    md->output_format = -1; /* Output format */
    md->external_clock = -1; /* External clock not present */
    md->modelist = NULL; /* Empty initially */
    md->audio_formats = NULL; /* Empty initially */

    *description = md;

    return NULL;
}

void free_monitordescription(MonitorDescriptionRef description)
{
    ModeDescriptionRef md;
    md = description->modelist;
    while (md)
    {
        ModeDescriptionRef td = md;
        md = md->next;
        free(td);
    }
    if (description->audio_formats)
    {
        free(description->audio_formats);
    }
    free(description);
}

void release_currentmonitor(void)
{
    if (current_monitor)
    {
        IFDEBUG printf("releasing previous monitor description\n");
        free_monitordescription(current_monitor);
    }
}

void compute_modedescription(ModeDescriptionRef md)
{
    uint32_t vtot, htot;
    int pn;
    ModeDef *mp = &md->definition.timings; /* for terseness! */
    for (htot = 0, vtot = 0, pn = 0; pn < FR__COUNT; ++pn)
    {
        htot += mp->hpar[pn];
        vtot += mp->vpar[pn];
    }
    md->line_hz = mp->pixel_khz * 1000 / htot;  /* compute line frequency in Hz */
    md->frame_mhz = md->line_hz * 1000 / vtot; /* frame frequency in milliHz, high-prec */
    if (mp->interlaced)
    {
        md->frame_mhz /= 2; /* if interlaced, one frame is 2 fields */
    }
    md->frame_hz = (md->frame_mhz + 500) / 1000; /* & low-prec for user integer Hz matching */
}

/* For efficiency in handling the Service_ModeExtension service call,
 * we keep the list of supported modes in order.  The keys used for
 * comparison of modes are (in order of use):
 *   (1) increasing x resolution
 *   (2) increasing y resolution
 *   (3) decreasing frame rate
 *   (4) increasing peak datarate at a given depth, i.e. pixelrate
 */
static int modes_inorder(ModeDescriptionRef m1, ModeDescriptionRef m2)
{
    if (m1->definition.timings.xres < m2->definition.timings.xres)
    {
        return 1;
    }
    if (m1->definition.timings.xres > m2->definition.timings.xres)
    {
        return 0;
    }
    if (m1->definition.timings.yres < m2->definition.timings.yres)
    {
        return 1;
    }
    if (m1->definition.timings.yres > m2->definition.timings.yres)
    {
        return 0;
    }
    if (m1->frame_mhz > m2->frame_mhz)
    {
        return 1;
    }
    if (m1->frame_mhz < m2->frame_mhz)
    {
        return 0;
    }
    if (m1->definition.timings.pixel_khz < m2->definition.timings.pixel_khz)
    {
        return 1;
    }
    if (m1->definition.timings.pixel_khz > m2->definition.timings.pixel_khz)
    {
        return 0;
    }
    return 1;                           /* arbitrary here - modes seem the same! */
}

void sort_modelist(ModeDescriptionRef *list)
{
    ModeDescriptionRef prev, this, next;
    int swapped;
    do
    {
        prev = NULL;                    /* marks being at start of list */
        this = *list;                   /* not NULL */
        next = this->next;              /* might be NULL, for 1-entry list */
        swapped = 0;
        while (next)
        {
            if (!modes_inorder(this, next))
            {
                ModeDescriptionRef t;
                /* Move whatever is pointing at this to point at next */
                if (prev == NULL)
                {
                    *list = next;       /* swap at start of list */
                }
                else
                {
                    prev->next = next;
                }
                /* The new successor to this record is what was after the next one */
                this->next = next->next;
                /* The new successor to what was the next record is now this record */
                next->next = this;
                /* Swap our local this and next pointers */
                t = this;  this = next;  next = t;
                swapped = 1;
            }
            /* Step all the pointers on by one in the (perhaps re-ordered) list */
            prev = this;
            this = next;
            next = next->next;
        }
    } while (swapped);
}

_kernel_oserror *set_monitortype(int monitortype)
{
    _kernel_swi_regs regs;
    regs.r[0] = 3;
    regs.r[1] = monitortype;
    return _kernel_swi(OS_ScreenMode, &regs, &regs);
}

int read_monitortype(void)
{
    _kernel_swi_regs regs;
    _kernel_oserror *res;
    regs.r[0] = 1;
    res = _kernel_swi(OS_ReadSysInfo, &regs, &regs);
    if (res)
    {
        return -1;
    }
    else
    {
        return regs.r[1];
    }
}

_kernel_oserror *restore_monitortype(void)
{
    int temp = old_monitortype;
    if (temp != -1)
    {
        old_monitortype = -1;
        return set_monitortype(temp);
    }
    return NULL;
}

static _kernel_oserror *open_modefile(const char *filename, FILE **handle)
{
    _kernel_oserror *res;
    FILE *f = fopen(filename, "r");
    *handle = f;
    if (f != NULL)
    {
        res = NULL;                     /* all OK */
    }
    else
    {
        res = _kernel_last_oserror();
        if (res == NULL)
        {
            _kernel_swi_regs regs;
            /* Couldn't open file but only C library knows why: let's find out. */
            regs.r[0] = OSFind_OpenIn | open_nopath | open_nodir | open_mustopen;
            regs.r[1] = (int) filename;
            regs.r[2] = 0;
            res = _kernel_swi(OS_Find, &regs, &regs);
            if (res == NULL)
            {
                /* Hmmm, fopen failed but we *can* open it: give up!
                 * First re-close this file handle.
                 */
                int fh = regs.r[0];
                regs.r[0] = OSFind_Close;
                regs.r[1] = fh;
                (void) _kernel_swi(OS_Find, &regs, &regs);
                res = error(ERR_OPENFAIL, filename, 0, 0);
            }
        }
    }
    return res;
}

static _kernel_oserror *loadmodefile(const char *file)
{
  _kernel_oserror *res;
  FILE *handle;

  res = open_modefile(file, &handle);
  if (res != NULL)
  {
      IFDEBUG printf("failed to open modefile\n");
  }
  else
  {
      /* Now need to differentiate if text file or EDID file. */
      /* We do so by looking for the EDID header 0x00ffffffffffff00 */
      int is_edid = 1;
      int c;
      for (int i = 0; i<8;i++)
      {
          c = getc(handle);
          if (((i == 0) || (i == 7)) && (c != 0x00))
          {
              is_edid = 0;
          }
          if (((i > 0) && (i < 7)) && (c != 0xff))
          {
              is_edid = 0;
          }
      }

      if (is_edid == 1)
      {
          /* Close the file - we need to load the whole file to map it
           * onto the EDID struct.
           */
          fclose(handle);
          /* Now pass loadEDID the path */
          res = loadedid(file);
      }
      else
      {
          rewind(handle); /* Reset the pointer to the beginning */
          res = loadtextMDF(file, handle);
      }
      if (res == NULL)
      {
          /* Use of an MDF cancels (latching) the automatic EDID side effects */
          using_edid = false;
      }
  }
  return res;
}

static _kernel_oserror *savemodefile(const char *file)
{
    char  *fbuf;
    FILE  *f = NULL;
    size_t length; 
    ModeDescriptionRef this;

    if (current_monitor == NULL)
    {
        return error(ERR_NOMODEFILE, 0, 0, 0);
    }

    /* open file for new mode file if required */
    /* file is a string terminated in 0x0D */
    length = strcspn(file, "\r");
    fbuf = malloc(length + 1);
    if (fbuf)
    {
        memcpy(fbuf, file, length);
        fbuf[length] = '\0';
        f = fopen(fbuf, "w");
        free(fbuf);
    }
    if (f == NULL)
    {
        return _kernel_last_oserror();
    }
    fprintf(f, "# Exported from ScrModes " Module_VersionString "\n"
               "file_format:1\n"
               "monitor_title:%s\n", current_monitor->name);
    if (current_monitor->dpms_state!=-1)
    {
        fprintf(f, "DPMS_state:%d\n\n", current_monitor->dpms_state);
    }
    this = current_monitor->modelist;
    while (this)
    {
        ModeDef *mp = &this->definition.timings;
        fprintf(f, "# Mode: %d x %d @@ %dHz\n", mp->xres, mp->yres, this->frame_hz);
        fprintf(f, "startmode\n"
                   " mode_name:%s\n"
                   " x_res:%d\n"
                   " y_res:%d\n"
                   " pixel_rate:%d\n", this->definition.name, mp->xres, mp->yres, mp->pixel_khz);
        fprintf(f, " h_timings:%d,%d,%d,%d,%d,%d\n", mp->hpar[0], mp->hpar[1], mp->hpar[2],
                                                     mp->hpar[3], mp->hpar[4], mp->hpar[5]);
        fprintf(f, " v_timings:%d,%d,%d,%d,%d,%d\n", mp->vpar[0], mp->vpar[1], mp->vpar[2],
                                                     mp->vpar[3], mp->vpar[4], mp->vpar[5]);
        fprintf(f, " sync_pol:%d\n", mp->syncpol);
        if (mp->interlaced == 1)
        {
            fprintf(f, " interlaced\n");
        }
        fprintf(f,"endmode\n\n");
        this = this->next;
    }
    fclose(f);

    return NULL;
}

/* List of pixel formats supported by the kernel, in priority order for higher BPP search by service_modetranslation */
/* Also, for GraphicsV drivers that don't support GraphicsV_PixelFormats, the first few entries are expected to be the 'old formats' that they may support */
static const PixelFormat pixelformats[] = {
    {1,0,0},
    {3,0,1},
    {15,0,2},
    {255,ModeFlag_FullPalette,3},
    {65535,0,4},
    {-1,0,5},
    /* RISC OS 6 64K */
    {65535,  ModeFlag_64k,         4},
    /* Red/blue swapped */
    {65535,  ModeFlag_DataFormatSub_RGB,              4},
    {-1,     ModeFlag_DataFormatSub_RGB,              5},
    {65535,  ModeFlag_DataFormatSub_RGB+ModeFlag_64k, 4},
    /* 4K */
    {4095,   0,                                       4},
    {4095,   ModeFlag_DataFormatSub_RGB,              4},
    /* Alpha */
    {65535,  ModeFlag_DataFormatSub_Alpha,                                         4},
    {-1,     ModeFlag_DataFormatSub_Alpha,                                         5},
    {65535,  ModeFlag_DataFormatSub_Alpha+ModeFlag_64k,                            4},
    {65535,  ModeFlag_DataFormatSub_Alpha+ModeFlag_DataFormatSub_RGB,              4},
    {-1,     ModeFlag_DataFormatSub_Alpha+ModeFlag_DataFormatSub_RGB,              5},
    {65535,  ModeFlag_DataFormatSub_Alpha+ModeFlag_DataFormatSub_RGB+ModeFlag_64k, 4},
    {4095,   ModeFlag_DataFormatSub_Alpha,                                         4},
    {4095,   ModeFlag_DataFormatSub_Alpha+ModeFlag_DataFormatSub_RGB,              4},
};

#define OLDFORMATS pixelformats
#define NUM_OLDFORMATS 6

/* Convert an old pixel depth value to a PixelFormat value */
static void pixelformat_from_depth(PixelFormatRef pf,int depth)
{
    pf->log2bpp = depth;
    pf->ncolour = (1<<(1<<depth))-1;
    pf->modeflags = (depth==3?ModeFlag_FullPalette:0);
}

/* Can this PixelFormat be represented as a pixel depth? (if so, pf->log2bpp is the value) */
bool is_old_format(const PixelFormat *pf)
{
    if (pf->log2bpp > 5)
        return false;
    if (pf->ncolour != (1<<(1<<pf->log2bpp))-1)
        return false;
    if (pf->modeflags != (pf->log2bpp==3?ModeFlag_FullPalette:0))
        return false;
    return true;
}

/* Return current GraphicsV driver number */
static int current_graphicsv_driver(void)
{
    int variables[2];
    variables[0] = VduExt_CurrentGraphicsVDriver;
    variables[1] = -1;
    _swix(OS_ReadVduVariables, _INR(0,1), variables, variables);
    return variables[0];
}

/* Return mask of which pixel formats are supported by the driver (from pixelformats table) */
static int get_supported_pixel_formats(int driver)
{
    _kernel_swi_regs r;
    r.r[4] = GraphicsV_PixelFormats | (driver<<24);
    r.r[9] = GraphicsV;
    _kernel_swi(OS_CallAVector, &r, &r);
    if (r.r[4] != 0)
    {
        /* Old driver, just spam it with some basic formats */
        return (1<<NUM_OLDFORMATS)-1;
    }
    /* Scan the list to build up a flag word of supported formats */
    const PixelFormat *list = pixelformats;
    const PixelFormat *f = (const PixelFormat *) r.r[0];
    int bit = 1;
    int supported = 0;
    while (--r.r[1] >= 0)
    {
        if (f->modeflags & ModeFlag_DataFormatFamily_Mask)
        {
            continue;
        }
        /* Note that for each step of the outer loop, we retain the 'list' and
           'bit' values from the inner loop so that drivers which arrange
           their format lists in a similar order to ours will require fewer
           iterations */
        for (int i=0;i<sizeof(pixelformats)/sizeof(pixelformats[0]);i++)
        {
            bool match = false;
            if ((f->ncolour == list->ncolour) && (f->modeflags == list->modeflags) && (f->log2bpp == list->log2bpp))
            {
                supported |= bit;
                match = true;
            }
            if (bit == (1 << ((sizeof(pixelformats)/sizeof(pixelformats[0]))-1)))
            {
                bit = 1;
                list = pixelformats;
            }
            else
            {
                bit = bit<<1;
                list++;
            }
            if (match)
            {
                break;
            }
        }
        f++;
    }
    return supported;
}

/* Build a VIDC list
 * Returns the number of control list items
 */
static int build_a_vidclist(VIDCListRef vp, ModeDescriptionRef mp, const PixelFormat *pf)
{
    int fn;
    int ctrllistpos = 0;

    /* Fill in the fields */
    vp->format = 3;
    vp->depth = pf->log2bpp;
    for (fn = 0; fn < FR__COUNT; ++fn)
    {
        vp->hpar[fn] = mp->definition.timings.hpar[fn];
        vp->vpar[fn] = mp->definition.timings.vpar[fn];
    }
    vp->pixelrate = mp->definition.timings.pixel_khz;
    vp->syncpol = mp->definition.timings.syncpol;

    /* Only specify ModeFlags & NColour if necessary? */
    if (!is_old_format(pf))
    {
        vp->vcparam[ctrllistpos].index = ControlList_NColour;
        vp->vcparam[ctrllistpos].value = pf->ncolour;
        ctrllistpos++;
        vp->vcparam[ctrllistpos].index = ControlList_ModeFlags;
        vp->vcparam[ctrllistpos].value = pf->modeflags;
        ctrllistpos++;
    }

    if (current_monitor->dpms_state != -1)
    {
        vp->vcparam[ctrllistpos].index = ControlList_DPMSState;
        vp->vcparam[ctrllistpos].value = current_monitor->dpms_state;
        ctrllistpos++;
    }

    if (current_monitor->lcd_support != 0)
    {
        IFDEBUG printf("I'm an LCD panel & I'm going to tell the Kernel!\n");
        vp->vcparam[ctrllistpos].index = ControlList_LCDMode;
        vp->vcparam[ctrllistpos].value = LCDMODE_VALUE;
        ctrllistpos++;
        if (current_monitor->lcd_support != 3)
        {
            vp->vcparam[ctrllistpos].index = ControlList_LCDDualPanelMode;
            vp->vcparam[ctrllistpos].value = LCDDUAL_VALUE;
            ctrllistpos++;
        }
        vp->vcparam[ctrllistpos].index = ControlList_LCDOffset0;
        vp->vcparam[ctrllistpos].value = LCDOFF0_VALUE;
            ctrllistpos++;
        vp->vcparam[ctrllistpos].index = ControlList_LCDOffset1;
        vp->vcparam[ctrllistpos].value = LCDOFF1_VALUE;
            ctrllistpos++;
        vp->vcparam[ctrllistpos].index = ControlList_DACControl;
        vp->vcparam[ctrllistpos].value = DACCTRL_VALUE;
            ctrllistpos++;
    }

    if (mp->definition.timings.external_clock != -1)
    {
        vp->vcparam[ctrllistpos].index = ControlList_HClockSelect;
        vp->vcparam[ctrllistpos].value = mp->definition.timings.external_clock;
        ctrllistpos++;
    }

    if (mp->definition.timings.interlaced)
    {
        vp->vcparam[ctrllistpos].index = ControlList_Interlaced;
        vp->vcparam[ctrllistpos].value = 1;
        ctrllistpos++;
    }

    if (current_monitor->output_format != -1)
    {
        vp->vcparam[ctrllistpos].index = ControlList_OutputFormat;
        vp->vcparam[ctrllistpos].value = current_monitor->output_format;
        ctrllistpos++;
    }

    vp->vcparam[ctrllistpos].index = -1;      /* List terminator */

    return ctrllistpos;
}

/* Test for whether a given mode definition is usable within the
 * specified data rate and video memory size bounds, at a given pixel
 * depth.  Limitations of the current video controller chip (if known)
 * are also factored in to the test.
 * If the mode is valid, it optionally copies the VIDC list into the
 * provided buffer.
 */
static int mode_valid(ModeDescriptionRef mp, const PixelFormat *pf,
                       uint32_t maxdatarate /* kB/s */,
                       uint32_t maxdatasize /* bytes */,
                       int extrabytes,
                       VIDCListRef outlist)
{
    _kernel_swi_regs r;
    VIDCList         vetlist;
    uint32_t pixrate = mp->definition.timings.pixel_khz;
    uint32_t mx = mp->definition.timings.xres;
    uint32_t my = mp->definition.timings.yres;
    uint32_t pixels = mx * my;
    uint32_t datarate, datasize;

    /* Get true bpp value */
    uint32_t bpp = 1<<pf->log2bpp;
    if (pf->log2bpp == 6) /* 24bit packed formats */
        bpp = 24;
    else if (pf->log2bpp == 7) /* YUV formats - TODO! */
        return 0;

    /* Convert from pixels to bytes: method varies according to depth */
    if ((bpp > 4) && (current_monitor->lcd_support == 1))
    {
        return 0;         /** Eek! 4bpp is max for b/w panels! **/
    }

    if (bpp < 8)
    {
        uint8_t shift = 3 - pf->log2bpp;
        uint32_t round = (1 << shift) - 1;
        datarate = (pixrate + round) >> shift;
        datasize = (pixels + round) >> shift;
    }
    else
    {
        uint8_t mult = bpp>>3;
        datarate = pixrate * mult;
        datasize = pixels * mult;
    }

    /* Check global data rate/size limits */
    if (datarate > maxdatarate || datasize > maxdatasize)
    {
        return 0;
    }

    /* Apply video-controller-specific checks */
    int driver = current_graphicsv_driver();

    r.r[4] = GraphicsV_PixelFormats | (driver<<24);
    r.r[9] = GraphicsV;
    _kernel_swi(OS_CallAVector, &r, &r);
    if (r.r[4] == 0)
    {
        int i=r.r[1];
        PixelFormatRef formats = (PixelFormatRef) r.r[0];
        while (i)
        {
            if ((formats->ncolour == pf->ncolour)
              && (formats->modeflags == pf->modeflags)
              && (formats->log2bpp == pf->log2bpp))
                break;
            formats++;
            i--;
        }
        if (i == 0)
            return 0;    /* Had a definitive answer from GraphicsV that this bpp is forbidden */
    }
    else
    {
        /* Try the old DisplayFeatures call */
        if (!is_old_format(pf))
            return 0;    /* Not a format supported by DisplayFeatures */
        r.r[4] = GraphicsV_DisplayFeatures | (driver<<24);
        r.r[9] = GraphicsV;
        _kernel_swi(OS_CallAVector, &r, &r);
        if ((r.r[4] == 0) && ((r.r[1] & (1<<pf->log2bpp)) == 0))
        {
            return 0;    /* Had a definitive answer from GraphicsV that this bpp is forbidden */
        }
    }

    /* Propose the resulting mode to the graphics driver */
    int ctrllistpos = build_a_vidclist(&vetlist, mp, pf);

    if (extrabytes < 0)
    {
        extrabytes = 0;
    }
    if (extrabytes > 0)
    {
        if (!(supported_controllist_items & (1 << ControlList_ExtraBytes)))
        {
            return 0; /* ExtraBytes wanted by user but not supported by driver */
        }
        /* Check this won't push us over maxdatasize */
        if (extrabytes * my + datasize > maxdatasize)
        {
            return 0;
        }
        vetlist.vcparam[ctrllistpos].index = ControlList_ExtraBytes;
        vetlist.vcparam[ctrllistpos].value = extrabytes;
        ctrllistpos++;
        vetlist.vcparam[ctrllistpos].index = -1;      /* List terminator */
    }

    r.r[0] = (int)&vetlist;
    r.r[1] = 0; /* Flags */
    r.r[4] = GraphicsV_VetMode2 | (driver<<24);
    r.r[9] = GraphicsV;
    _kernel_swi(OS_CallAVector, &r, &r);
    if ((r.r[4] == 0) && !(r.r[0] & ~7)) /* Call claimed, and no unknown flags returned? */
    {
        if ((r.r[0] & GVVetMode2_ResultMask) == 0)
        {
            return 0; /* Had a definitive answer from GraphicsV that it no-likey */
        }
        else if (r.r[0] & GVVetMode2_ExtraBytes_Invalid)
        {
            /* Check to see if this ExtraBytes value will cause us to exceed
             * maxdatasize.
             */
            datasize += r.r[2] * my;
            if (datasize > maxdatasize)
            {
                return 0;
            }
            /* ExtraBytes value is acceptable, use it */
            if ((ctrllistpos > 0) && (vetlist.vcparam[ctrllistpos-1].index == ControlList_ExtraBytes))
            {
                ctrllistpos--;
            }
            vetlist.vcparam[ctrllistpos].index = ControlList_ExtraBytes;
            vetlist.vcparam[ctrllistpos].value = r.r[2];
            ctrllistpos++;
            vetlist.vcparam[ctrllistpos].index = -1;      /* List terminator */
        }
    }
    else
    {
        /* Try the old vet call */
        r.r[0] = (int)&vetlist;
        r.r[1] = NULL;
        r.r[4] = GraphicsV_VetMode | (driver<<24);
        _kernel_swi(OS_CallAVector, &r, &r);
        if ((r.r[4] == 0) && (r.r[0] != 0))
        {
            return 0; /* Had a definitive answer from GraphicsV that it no-likey */
        }
    }

    /* No obvious conflicts, accept the mode */
    if (outlist != NULL)
    {
        *outlist = vetlist;
    }
    return 1;
}

bool find_deepest_by_xyhz(PixelFormatRef fp, ModeDescriptionRef mp)
{
    _kernel_swi_regs r;
    const PixelFormat *pflist;
    size_t pflistlen;
    int    driver, maxlog2bpp = 0;
    bool   found = false;

    /* See if the driver is helpful in listing the pixel formats */
    driver = current_graphicsv_driver();
    r.r[4] = GraphicsV_PixelFormats | (driver<<24);
    r.r[9] = GraphicsV;
    _kernel_swi(OS_CallAVector, &r, &r);
    if (r.r[4] == 0)
    {
        pflist = (PixelFormatRef) r.r[0];
        pflistlen = r.r[1];
    }
    else
    {
        /* Use the old list */
        pflist = OLDFORMATS;
        pflistlen = NUM_OLDFORMATS;
    }
    IFDEBUG printf("Trying %d pixel formats\n", pflistlen);

    /* The format list isn't necessarily sorted by depth, so just try them
     * all to find the highest log2bpp.
     */
    while (pflistlen)
    {
        if (mode_valid(mp, pflist, INT32_MAX, INT32_MAX, 0, NULL))
        {
            /* That depth is achievable, keep it if bigger */
            if (pflist->log2bpp > maxlog2bpp)
            {
                maxlog2bpp = pflist->log2bpp;
                IFDEBUG printf("Deeper mode_valid at log2bpp = %d\n", maxlog2bpp);
                *fp = *pflist;
                found = true;
            }
        }
        pflist++;
        pflistlen--;
    }

    return found;
}

static ModeDescriptionRef find_by_xy(ModeDescriptionRef mp,
                                      uint32_t xres, uint32_t yres, int *count)
{
    while (mp && mp->definition.timings.xres < xres)
        mp = mp->next;
    while (mp && mp->definition.timings.xres == xres && mp->definition.timings.yres < yres)
        mp = mp->next;
    if (mp && mp->definition.timings.xres == xres && mp->definition.timings.yres == yres)
    {
        int entries;
        ModeDescriptionRef head = mp;
        entries = 0;
        do
        {
            ++entries;
            mp = mp->next;
        } while (mp && mp->definition.timings.xres == xres &&
                 mp->definition.timings.yres == yres);
        *count = entries;
        return head;
    }
    return NULL;
}

static int restrict_bandwidth(int os_limit)
{
    /* On a HAL based kernel the kernel doesn't know what the bandwidth limitations
     * for a given mode are (an LCD graphics controller might for example be able
     * to use local SRAM buffering for smallish modes, but swap to shared slow DRAM
     * for bigger modes, both of which have differing bandwidths). The kernel
     * therefore just guesses a value, which we choose to ignore here and leave any
     * vetting up to GraphicsV.
     */
    UNUSED(os_limit);

    return INT32_MAX;
}

static void service_modeextension(_kernel_swi_regs *regs)
{
    /* Static allocation of a single VIDCList, for return from
     * Service_ModeExtension in the case that we have a mode
     * satisfying the requirements.  The data in this block is
     * overwritten by the next Service_ModeExtension call which we
     * also satisfy.  NB. Since we currently have no mechanism whereby
     * additional fields can be specified (e.g. in the ModeInfo file)
     * to be returned in a video control parameters list at the end of
     * the main block, there is no need for this block to be variable
     * length.  If that were ever added, the space would need to be
     * claimed either by assuming some maximum possible VCP list size
     * and keeping it static, or allocating the right size
     * dynamically; the latter case would imply keeping a file-scope
     * static pointer so that the space can be released as required
     * when module_shutdown is called.
     *
     * TMD 02-Nov-93 - A video control parameters list is now appended
     * if the file includes the DPMS_state keyword. However since this
     * is only 1 pair of words, I have allocated it statically.
     * If no list is necessary, the 1st word holds -1.
     * If a list is necessary, the 1st word holds DPMS_INDEX, the 2nd
     * holds the dpms value, and the 3rd word holds -1.
     *
     * WT 19-Jan-95 - The parameters list is extended to cater for LCD
     * panels, both single and dual panel, as defined in the LCD_support
     * field of the mode definition file. So, now 6 words are statically
     * allocated.
     */
    static VIDCList thevidclist;

    ModeSelectorRef    sel;
    ModeDescriptionRef mp;
    uint32_t dataratelimit, datasizelimit;
    int nmodes;
    PixelFormat pf;

    /* Check for being passed a mode selector as opposed to a mode
     * number - we only handle the former.
     */
    if (!IS_MODE_SEL_PTR(regs->r[2]))
    {
        return;
    }

    /* Check for suitable monitor type being requested - we handle
     * don't-care case as well as explicit file-specified monitor
     * type, but don't touch other specific monitor class codes.
     */
    if (regs->r[3] != -1 && regs->r[3] != MONITOR_FILE)
    {
        return;                         /* pass service on */
    }

    /* Address the mode selector (R2 on entry has been found to be a
     * pointer), and check for known format (bit 0 set, bits 7..1
     * clear).
     */
    sel = MODESEL(regs->r[2]);
    if (sel->bit0 != 1 || sel->format != 0)
    {
        return;                         /* pass service on */
    }

    /* Examine the mode selector to deduce the pixel format */
    pixelformat_from_depth(&pf,sel->depth);
    ModeParam *param = sel->param;
    int extrabytes = 0;
    while (param->index != -1)
    {
        if (param->index == VduExt_ModeFlags)
            pf.modeflags = param->value;
        else if (param->index == VduExt_NColour)
            pf.ncolour = param->value;
        else if (param->index == VduExt_LineLength)
            extrabytes = param->value - (((sel->xresol << sel->depth) + 7) >> 3);
        param++;
    }

    /* BBC gap modes have Log2BPP 1, NColour 1 */
    if ((pf.modeflags & ModeFlag_BBCGapMode) && (pf.log2bpp == 1) && (pf.ncolour == 1))
    {
        pf.ncolour = 3;
    }

    /* Mask out unwanted mode flags */
    pf.modeflags &= ~(ModeFlag_NonGraphic | ModeFlag_Teletext | ModeFlag_GapMode | ModeFlag_BBCGapMode | ModeFlag_HiResMono | ModeFlag_DoubleVertical | ModeFlag_HardScrollDisabled | ModeFlag_InterlacedMode);

    /* Massage flags for RGB modes a bit */
    if ((pf.modeflags & ModeFlag_DataFormatFamily_Mask) == ModeFlag_DataFormatFamily_RGB)
    {
        /* Detect 64 colour modes and convert to 256 colour */
        if ((pf.ncolour == 63) && (pf.log2bpp == 3))
        {
            pf.ncolour = 255;
            pf.modeflags |= ModeFlag_FullPalette;
        }
        /* Clear the greyscale flag. TODO - keep it so greyscale-only devices can make use of it? */
        pf.modeflags &= ~ModeFlag_GreyscalePalette;
    }

    /* Bail if we see something unexpected */
    if (pf.modeflags & ~(ModeFlag_FullPalette | ModeFlag_64k | ModeFlag_ChromaSubsampleMode | ModeFlag_DataFormat_Mask))
        return;

    /* Pick up data size limit from args to service call */
    datasizelimit = regs->r[5]; /* data size is measured in bytes */

    /* Current Screen Mode selection API FuncSpec (0197,290/FS, Issue
     * D) says data rate figure in R4 is in bytes/sec.  Since Medusa
     * h/ware can do up to 170,000,000 bytes/sec, and that number is a
     * factor of only 12 times smaller than the max number in a 32-bit
     * signed integer, it would seem more future-proof and consistent
     * (cf. pixel rate specs which use kHz not Hz) to use 1000's of
     * bytes/sec, but for now convert to preferred units as used internally.
     */
    dataratelimit = restrict_bandwidth(regs->r[4]) / 1000;

    /* Scan all available modes, looking for a match.  First find the
     * subset of all known modes which have the right resolution.
     * They are contiguous on the master list.  We track where to stop
     * by knowing how many of them there are (find_by_xy counts up)
     * rather than by rechecking the pointer and x/y fields every
     * time.
     */
    mp = find_by_xy(current_monitor->modelist, sel->xresol, sel->yresol, &nmodes);
    if (mp == NULL)
    {
        return;                         /* no match */
    }
    do
    {
        /* Test whether this mode can satisfy the requirements */
        if ((sel->framerate == -1 || sel->framerate == mp->frame_hz) &&
            mode_valid(mp, &pf, dataratelimit, datasizelimit, extrabytes, &thevidclist))
        {
            /* And claim the service */
            regs->r[1] = 0;                 /* Service_Serviced */
            regs->r[3] = (int)&thevidclist; /* return pointer to VIDC list to use (mode_valid will have filled this in for us) */
            regs->r[4] = NULL;              /* marks no workspace list(mode selector given) */
            return;
        }
        mp = mp->next;
    } while (--nmodes);
}

static void service_enumeratescreenmodes(_kernel_swi_regs *regs)
{
    ModeDescriptionRef mp;
    uint32_t dataratelimit, datasizelimit;
    const PixelFormat *pf,*pflist;
    int numformats,pflistlen;
    _kernel_swi_regs r;

    /* We do monitor type 7 only */
    if (regs->r[3] != MONITOR_FILE || !current_monitor)
    {
        return;
    }

    /* See comments re. data-rate spec in service_modeextension */
    dataratelimit = restrict_bandwidth(regs->r[4]) / 1000;
    datasizelimit = regs->r[5];

    /* Get list of pixel formats supported by driver */
    int driver = current_graphicsv_driver();

    r.r[4] = GraphicsV_PixelFormats | (driver<<24);
    r.r[9] = GraphicsV;
    _kernel_swi(OS_CallAVector, &r, &r);
    if (r.r[4] == 0)
    {
        pflist = (PixelFormatRef) r.r[0];
        pflistlen = r.r[1];
    }
    else
    {
        /* Use the old list */
        pflist = OLDFORMATS;
        pflistlen = NUM_OLDFORMATS;
    }

    /* Scan all available modes at all available pixel formats */
    mp = current_monitor->modelist;
    pf = pflist;
    numformats = pflistlen;

    for (;;)
    {
        if (!mode_valid(mp, pf, dataratelimit, datasizelimit, 0, NULL))
        {
            /* TMD 03-Nov-93: Fix bug MED-00833
             * Code used to set depth to 5 here, assuming that if the mode
             * was invalid at a low depth, it would be invalid at all higher
             * depths. This is a wrong assumption when a mode can fail because
             * the length of the line is not a suitable multiple.
             */
        }
        else
        {
            /* OK, it fits; what to do with it?  Follow algorithm from F.S. */
            if (regs->r[2] > 0)
            {
                /* skipping (in a partial enumeration) - nowt to do */
            }
            else
            {
                int nlen = strlen(mp->definition.name);
                int entrysize = 24 + ((nlen + 1 + 3) & ~3);
                bool old_format = is_old_format(pf);
                if (!old_format)
                {
                    entrysize += 8;
                }
                if (regs->r[6] != 0)
                {
                    /* Enumeration case - filling in block */
                    if (regs->r[7] >= entrysize)
                    {
                        if (old_format)
                        {
                            ModeInfoBlockRef ip = (ModeInfoBlockRef)regs->r[6];
                            int i;

                            /* Copy the mode information into the supplied data buffer */
                            ip->blocksize = entrysize;
                            ip->format = 0;  ip->flags = 0;  ip->bit0 = 1;
                            ip->xresol = mp->definition.timings.xres;
                            ip->yresol = mp->definition.timings.yres;
                            ip->depth = pf->log2bpp; /* log2(bits/pixel) */
                            ip->framerate = mp->frame_hz; /* integer Hz value used here */

                            /* Copy name + 1 terminating null into block */
                            strcpy(ip->name, mp->definition.name);
                            /* Pad name field out with 0's to N*4 */
                            for (i = nlen+1; (i & 3) != 0; ++i)
                                ip->name[i] = 0;
                        }
                        else
                        {
                            ModeInfoBlock1Ref ip = (ModeInfoBlock1Ref)regs->r[6];
                            int i;

                            /* Copy the mode information into the supplied data buffer */
                            ip->blocksize = entrysize;
                            ip->format = 1;  ip->flags = 0;  ip->bit0 = 1;
                            ip->xresol = mp->definition.timings.xres;
                            ip->yresol = mp->definition.timings.yres;
                            ip->pixelformat = *pf;
                            ip->framerate = mp->frame_hz; /* integer Hz value used here */

                            /* Copy name + 1 terminating null into block */
                            strcpy(ip->name, mp->definition.name);
                            /* Pad name field out with 0's to N*4 */
                            for (i = nlen+1; (i & 3) != 0; ++i)
                                ip->name[i] = 0;
                        }
                        /* Step buffer pointer past this new entry */
                        regs->r[6] += entrysize;
                    }
                    else
                    {
                        regs->r[1] = 0; /* Service_Serviced */
                        return;
                    }
                }
                /* Update remaining size of user data area */
                regs->r[7] -= entrysize;
            }
            /* count down matching modes in calling r2 */
            --regs->r[2];
        }

        /* Move on to next mode, if there are any left */
        if (numformats--)
        {
            pf++;                       /* next deeper mode of current def'n */
        }
        else
        {
            mp = mp->next;              /* next mode in list */
            if (mp == NULL)
            {
                return;                 /* no more modes from this module */
            }
            pf = pflist;                /* start with min. depth */
            numformats = pflistlen;
        }
    }
}

static int modevar(int mode, int var, int dfault)
{
    int value, flags;
    if (_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2)|_OUT(_FLAGS),
              mode, var, &value, &flags) || (flags & _C)) {
        value = dfault;
    }
    return value;
}

static bool resolution_supported(int x,int y,int doublepixel)
{
    int nmodes;
    if (find_by_xy(current_monitor->modelist, x, y, &nmodes))
    {
        return true;
    }
    if (!doublepixel)
    {
        return false;
    }
    /* Try non-doublepixel version */
    return find_by_xy(current_monitor->modelist, x >> 1, y, &nmodes) != NULL;
}

/* Call Service_ModeExtension, but also tries downgrading doublepixel modes to non-doublepixel */
static bool offer_doublepixel_modeextension(ModeSelector *m, int *doublepixel)
{
    /* Assume that we're the only thing providing support for this monitor type */
    _kernel_swi_regs regs;
    regs.r[1] = Service_ModeExtension;
    regs.r[2] = (int) m;
    regs.r[3] = MONITOR_FILE;
    regs.r[4] = INT32_MAX;
    regs.r[5] = INT32_MAX;
    if (!*doublepixel)
    {
        service_modeextension(&regs);
        return (regs.r[1] == Service_Serviced);
    }
    /* Double-pixel only valid for <= 16bpp */
    if (m->depth > 4)
    {
        return false;
    }
    service_modeextension(&regs);
    if (regs.r[1] == Service_Serviced)
    {
        return true;
    }
    /* Halve the width and try again */
    int orig = m->xresol;
    m->xresol = orig>>1;
    service_modeextension(&regs);
    if (regs.r[1] == Service_Serviced)
    {
        *doublepixel = false;
        return true;
    }
    m->xresol = orig;
    return false;
}

/* Some industry-standard resolutions to use as fallbacks.
   We could simply try all the resolutions listed in the MDF/EDID, but that
   might not work so well if we end up picking a mode with an odd aspect ratio.
 */
static const int fallback_resolutions[] = {
    640, 350,
    640, 400,
    720, 400,
    640, 480,
    720, 480,
    720, 576,
    800, 600,
    1024, 768,
    1280, 1024,
    1280, 720,
    1920, 1080,
};
static const int num_fallbacks = sizeof(fallback_resolutions)/8;

/*
  
  Find an alternative mode which is supported by the hardware:
  
  * Try higher BPPs (including true colour)
  * Try lower BPPs
  * Try alternate resolutions
  
  Check for validity using Service_ModeExtension (although since we're only
  dealing with known modes for known monitor types, we could optimise it to
  go straight to HandleServiceModeExtension instead)
  
  Be careful with special mode types (double-vertical, BBC gap mode, etc.)
  because Service_ModeExtension won't be aware of kernel restrictions (and
  using OS_CheckModeValid instead will introduce the risk of recursion
  - although maybe we can mitigate that by only passing mode selector blocks
  to OS_CheckModeValid?)
  
  Non-teletext special mode type handling:
  
  * Allow special mode types to be downgraded to non-special types:
    * Double-pixel to normal
    * BBC gap mode to regular gap mode
    * Double-vertical to normal
    * Hi-res mono to regular mono (always downgraded)
  * There's no need to downgrade gap modes to non-gap modes, since gap modes
    can be supported in any BPP
  * Double-pixel is the only one that will affect Service_ModeExtension, since
    that affects the physical resolution of the mode. So we'll potentially have
    to vet double-pixel modes twice (once with it enabled, once with it
    disabled)
  * Theoretically we could upgrade regular modes to double-pixel in order to
    work around hardware restrictions - but since double-pixel modes aren't
    widely supported it's probably best to avoid that.

 */      
static void service_modetranslation(_kernel_swi_regs *regs)
{
    /* We do monitor type 7 only */
    if (regs->r[3] != MONITOR_FILE || !current_monitor)
    {
        return;
    }

    /* Mode selector block with space for 8 parameters:
       ModeFlags, NColour, XEig, YEig, Log2BPC, ScrRCol, ScrBRow, XWindLimit */
    union {
        ModeSelector m;
        char c[sizeof(ModeSelector) + sizeof(ModeParam)*7 + 4];
    } u;

    /* Convert input mode to selector block (as a standard bitmap mode) */
    u.m.bit0 = 1;
    u.m.format = 0;
    u.m.flags = 0;
    int log2bpc = modevar(regs->r[2], VduExt_Log2BPC, 3);
    int log2bpp = modevar(regs->r[2], VduExt_Log2BPP, 3);
    int doublepixel = log2bpc - log2bpp;
    if (log2bpp > 5) /* TODO: Handle unusual colour depths better */
    {
        log2bpp = 5;
    }
    int orig_xresol = (modevar(regs->r[2], VduExt_XWindLimit, 639) + 1) << doublepixel;
    u.m.xresol = orig_xresol;
    int orig_yresol = modevar(regs->r[2], VduExt_YWindLimit, 479) + 1;
    u.m.yresol = orig_yresol;
    u.m.framerate = -1; /* Don't care (yet) */
    u.m.param[0].index = VduExt_ModeFlags;
    u.m.param[1].index = VduExt_NColour;
    u.m.param[2].index = -1;
    
    int driver = current_graphicsv_driver();
    int formatmask = get_supported_pixel_formats(driver);
    
    int orig_modeflags = modevar(regs->r[2], VduExt_ModeFlags, ModeFlag_FullPalette);
    
    /* Restrict pixel formats for teletext modes */
    if (orig_modeflags & ModeFlag_Teletext)
    {
        formatmask &= ~7;
    }
    
    int fallback_phase = 0;
    int fallback_res = -1;
    
    while(1)
    {
        /* Assume that we're the only thing providing support for this monitor type, and peek at
           the mode list to see if this resolution is supported at all */
        if (resolution_supported(u.m.xresol, u.m.yresol, doublepixel))
        {
            /* Try same-or-higher colour depths */
            int depthidx = log2bpp-1;
            while ((1 << ++depthidx) <= formatmask)
            {
                if (!(formatmask & (1 << depthidx)))
                {
                    continue;
                }
                u.m.depth = pixelformats[depthidx].log2bpp;
                u.m.param[0].value = pixelformats[depthidx].modeflags;
                u.m.param[1].value = pixelformats[depthidx].ncolour;
                if (offer_doublepixel_modeextension(&u.m, &doublepixel))
                {
                    goto found;
                }
            }
            
            /* Try lower colour depths */
            depthidx = log2bpp;
            while (--depthidx >= 0)
            {
                if (!(formatmask & (1 << depthidx)))
                {
                    continue;
                }
                u.m.depth = pixelformats[depthidx].log2bpp;
                u.m.param[0].value = pixelformats[depthidx].modeflags;
                u.m.param[1].value = pixelformats[depthidx].ncolour;
                if (offer_doublepixel_modeextension(&u.m, &doublepixel))
                {
                    goto found;
                }
            }
        }
        /* Try assorted fallback resolutions */
        switch (fallback_phase)
        {
        case 0:
            /* Fallback resolutions, but only if higher than current */
            while (++fallback_res < num_fallbacks)
            {
                u.m.xresol = fallback_resolutions[fallback_res*2];
                u.m.yresol = fallback_resolutions[fallback_res*2+1];
                if (((u.m.xresol >= orig_xresol) && (u.m.yresol >= orig_yresol))
                 && ((u.m.xresol != orig_xresol) || (u.m.yresol != orig_yresol)))
                {
                    break;
                }
            }
            if (fallback_res < num_fallbacks)
            {
                break;
            }
            /* Fall through ... */
            fallback_phase = 1;
        case 1:
            /* Preferred mode (assumed to be the highest res mode the monitor supports) */
            if ((preferred_mode != NULL) && (preferred_mode->bit0 == 1) && (u.m.xresol != preferred_mode->xresol) && (u.m.yresol != preferred_mode->yresol))
            {
                u.m.xresol = preferred_mode->xresol;
                u.m.yresol = preferred_mode->yresol;
                break;
            }
            /* Fall through... */
            fallback_phase = 2;
            fallback_res = num_fallbacks;
        default:
            /* Fallback resolutions, but lower resolutions */
            while (--fallback_res >= 0)
            {
                u.m.xresol = fallback_resolutions[fallback_res*2];
                u.m.yresol = fallback_resolutions[fallback_res*2+1];
                if (!((u.m.xresol >= orig_xresol) && (u.m.yresol >= orig_yresol))
                 && ((u.m.xresol != orig_xresol) || (u.m.yresol != orig_yresol)))
                {
                    break;
                }
            }
            if (fallback_res >= 0)
            {
                break;
            }
            /* Give up */
            return;
        }
    }
found:;
    /* Successfully found a mode
       Fill in any extra attributes that are necessary for the mode */
    
    ModeParam *p = &u.m.param[2];
    /* XEig, YEig are always stored */
    p->index = VduExt_XEigFactor;
    p->value = modevar(regs->r[2], VduExt_XEigFactor, 1);
    p++;
    p->index = VduExt_YEigFactor;
    p->value = modevar(regs->r[2], VduExt_YEigFactor, 1);
    p++;

    /* Log2BPC, XWindLimit, ScrRCol only needed for double-pixel */
    if (doublepixel)
    {
        p->index = VduExt_Log2BPC;
        p->value = u.m.depth+1;
        p++;
        p->index = VduExt_XWindLimit;
        p->value = (u.m.xresol>>1)-1;
        p++;
        p->index = VduExt_ScrRCol;
        p->value = (u.m.xresol>>4)-1;
        p++;
    }
    
    int modeflags = u.m.param[0].value | (orig_modeflags & (ModeFlag_GapMode+ModeFlag_BBCGapMode+ModeFlag_DoubleVertical+ModeFlag_NonGraphic+ModeFlag_Teletext));

    /* Teletext doesn't need any more attributes specified, and doesn't want the following rules applying */
    if (!(orig_modeflags & ModeFlag_Teletext))
    {
        /* (non-Teletext) Double-vertical only supported by kernel for 1bpp */
        if (u.m.depth)
        {
            modeflags &= ~ModeFlag_DoubleVertical;
        }

        if (modeflags & ModeFlag_BBCGapMode)
        {
            /* BBC gap modes only supported by kernel for 2bpp */
            if (u.m.depth != 1)
            {
                modeflags &= ~(ModeFlag_BBCGapMode | ModeFlag_NonGraphic); /* Assume BBC gap modes and teletext are the only non-graphic modes (and teletext won't get here). So if it's no longer a BBC gap mode, it's no longer non-graphic. */
            }
            else
            {
                /* Set the correct NColour value if it's remaining a BBC gap mode */
                p->index = VduExt_NColour;
                p->value = 1;
                p++;
            }
        }

        /* Downgrade to partial 8bpp palette, for consistency with numbered modes */
        if (u.m.depth == 3)
        {
            modeflags &= ~ModeFlag_FullPalette;
            u.m.param[1].value = 63;
        }

        /* ScrBRow needed for gap modes, double-vertical */
        if (modeflags & (ModeFlag_GapMode | ModeFlag_DoubleVertical))
        {
            int charheight = 8;
            if (modeflags & ModeFlag_GapMode)
            {
                charheight = 10;
            }
            if (modeflags & ModeFlag_DoubleVertical)
            {
                charheight <<= 1;
            }
            p->index = VduExt_ScrBRow;
            p->value = (u.m.yresol / charheight) - 1;
            p++;
        }
    }
    else
    {
        /* If the new mode is higher-res than the original, restrict ScrRCol & ScrBRow so that software which expects standard teletext (i.e. mode 7) resolution will continue to work */
        int charwidth = 3; /* Shift */
        int charheight = 10; /* Rows */
        if (modeflags & ModeFlag_DoubleVertical)
        {
            /* HiResTTX */
            charwidth = 4;
            charheight = 20;
        }
        int orig_cols = modevar(regs->r[2], VduExt_ScrRCol, 39) + 1;
        int orig_rows = modevar(regs->r[2], VduExt_ScrBRow, 24) + 1;
        if ((u.m.xresol >> charwidth) > orig_cols)
        {
            p->index = VduExt_ScrRCol;
            p->value = orig_cols - 1;
            p++;
        }
        if ((u.m.yresol / charheight) > orig_rows)
        {
            p->index = VduExt_ScrBRow;
            p->value = orig_rows - 1;
            p++;
        }
    }
    
    u.m.param[0].value = modeflags;
    p->index = -1;
    
    /* TODO: Try and map back to a numbered mode */
    
    /* Copy the mode selector block to somewhere safe so we can return it */
    static char static_mode[sizeof(ModeSelector) + sizeof(ModeParam)*7 + 4];
    memcpy(static_mode, u.c, sizeof(u.c));
    regs->r[1] = Service_Serviced;
    regs->r[2] = (int) static_mode;
}

static void service_displaychanged(_kernel_swi_regs *regs)
{
    switch (regs->r[0])
    {
        case DisplayChanged_Changing:
            /* The current driver is changing. We must recache any
             * driver-specific things which we store.
             */
            check_supported_controllist_items(regs->r[2]);
             
            /*
             * Check the monitor's still there.
             * Note that doing it here means:
             * a) ScreenModes must precede the driver if you want a mode defined
             *    during module init AND the MonitorType is EDID. If the MonitorType
             *    is some other value, including Auto, it doesn't matter
             *    where ScreenModes is as the Kernel will use a built in numbered mode.
             * b) Loading ScreenModes off disc won't automatically load the EDID data
             *    as this service call doesn't happen. Calling readedid() from module
             *    init isn't possible because the module isn't linked to the service
             *    call chain, so Display Manager et al can't enumerate the modes
             *    with OS_ScreenMode 2. This is only a problem for developers, who
             *    can manually re-read it (standalone builds are only partly supported today).
            */
            readedid(regs->r[2], using_edid);
            break;
    }
}

static void service_monitorleadtranslation(_kernel_swi_regs *regs)
{
    if ((preferred_mode != NULL) && (preferred_mode->bit0 == 1))
    {
        regs->r[1] = Service_Serviced;
        regs->r[3] = (int) preferred_mode;
        regs->r[4] = MONITOR_FILE;
        regs->r[5] = preferred_sync_type;
    }
}

static int we_are_preferred(void *pw)
{
    _kernel_swi_regs sregs;
    sregs.r[0] = ModHandReason_LookupName;
    sregs.r[1] = (int)"ScreenModes";
    (void)_kernel_swi(OS_Module, &sregs, &sregs);
    return (sregs.r[4] == *(int *)pw);
}

static const int samplerates[] =
{
     32000*1024,
     44100*1024,
     48000*1024,
     88200*1024,
     96000*1024,
    176400*1024,
    192000*1024,
};

static _kernel_oserror *swi_enumerateaudioformats(_kernel_swi_regs *regs)
{
    if (!current_monitor)
    {
        return error(ERR_NOMODEFILE, 0, 0, 0);
    }

    /* In:  r0 = flags:
     *           bit 0: 0 -> read raw data
     *                  1 -> read friendly data
     *      r1 = format code to start from (-1 = first)
     *      r2 = index within format code (-1 = first)
     * Out: r1 = format code of this entry (-1 if no more formats)
     *      r2 = index within format code (-1 if no more formats)
     *      r3 = max channels
     *      raw data:
     *        r4 = audio short descriptor byte 2
     *        r5 = audio short descriptor byte 3
     *      friendly data:
     *        r4 = sample rate (Hz*1024)
     *        r5 = LPCM: bit depth
     *             codes 2-8: max bit rate in Hz
     *             other codes: not supported by this API
     *
     * n.b. index values (r2) differ between raw & friendly modes
     */
    if (regs->r[0] & ~1)
    {
        return error(ERR_BADENUMAUDIO, 0, 0, 0);
    }
    /* Find the right index to start from */
    AudioFormat *current = current_monitor->audio_formats;
    int count = current_monitor->audio_format_count;
    int format = regs->r[1];
    int start_index = regs->r[2];
    while (count && (current->format_code < format))
    {
        current++;
        count--;
    }
    if (regs->r[0] & 1)
    {
        /* Friendly mode */
        /* Skip formats we don't understand */
        int my_index = 0;
find_next_entry:;
        int sample_rate = 0;
        int bits = 0;
        while (count && ((current->format_code < 1) || (current->format_code > 8)))
        {
            current++;
            count--;
        }
        if (!count)
        {
            regs->r[1] = -1;
            regs->r[2] = -1;
            return NULL;
        }
        bool is_LPCM = (current->format_code == 1);
        if (is_LPCM)
        {
            if ((current->format_specific & 0xf8) || !(current->format_specific & 0x7))
            {
                /* Weird bit depth mask for LPCM, skip entry */
                current++;
                count--;
                goto find_next_entry;
            }
        }
find_next_sub_entry:
        /* Find first sample_rate & bits value */
        while (!(current->sample_rates & (1<<sample_rate)))
        {
            sample_rate++;
        }
        if (is_LPCM)
        {
            while (!(current->format_specific & (1<<bits)))
            {
                bits++;
            }
        }
        /* Skip entries as necessary */
        if ((current->format_code == format) && (my_index <= start_index))
        {
            my_index++;
            /* Step to next sample rate */
            sample_rate++;
            if ((1<<sample_rate) > current->sample_rates)
            {
                /* Step to next bit depth value */
                sample_rate = 0;
                bits++;
                if (!is_LPCM || ((1<<bits) > current->format_specific))
                {
                    /* Step to next format list entry */
                    current++;
                    count--;
                    goto find_next_entry;
                }
            }
            goto find_next_sub_entry;
        }
        if (current->format_code > format)
        {
            my_index = 0;
        }
        regs->r[1] = current->format_code;
        regs->r[2] = my_index;
        regs->r[3] = current->max_channels;
        regs->r[4] = samplerates[sample_rate];
        regs->r[5] = is_LPCM ? (16 + 4*bits) : (current->format_specific*8000);

        return NULL;
    }
    else
    {
        /* Raw mode */
        int my_index = 0;
        while (count && (current->format_code == format) && (my_index <= start_index))
        {
            current++;
            count--;
            my_index++;
        }
        if (!count)
        {
            regs->r[1] = -1;
            regs->r[2] = -1;
            return NULL;
        }
        if (current->format_code > format)
        {
            my_index = 0;
        }
        regs->r[1] = current->format_code;
        regs->r[2] = my_index;
        regs->r[3] = current->max_channels;
        regs->r[4] = current->sample_rates;
        regs->r[5] = current->format_specific;

        return NULL;
    }
}

/* EXPORTED */
_kernel_oserror *ScreenModes_initialise(const char *cmd_tail, int podule_base, void *pw)
{
    char typevar[16];
    int  config;

    /* Keep a preferred mode with space for 2 extra mode variables */
    preferred_mode = calloc(1, sizeof(ModeSelector) + (2 * sizeof(ModeParam)));

    /* Define the EDID type name */
    sprintf(typevar, "File$Type_%03X", FileType_EDID);
    _swix(OS_SetVarVal, _INR(0,4), typevar, FileType_EDID_Name,
                                   strlen(FileType_EDID_Name), 0, VarType_String);

    /* Look at the MonitorType to see whether to proactively parse EDID */
    if (!_swix(OS_Byte, _INR(0,1) | _OUT(2), OsByte_ReadCMOS, VduCMOS, &config))
    {
        using_edid = ((config & MonitorTypeBits) >> MonitorTypeShift) == MONITOR_EDID;
    }
    
    check_supported_controllist_items(current_graphicsv_driver());

    UNUSED(cmd_tail);
    UNUSED(podule_base);
    UNUSED(pw);

    return NULL;
}

/* EXPORTED */
_kernel_oserror *ScreenModes_final(int fatal, int podule, void *pw)
{
    /* Free the space claimed for the current monitor
     * description (if any) and revert to the configured monitor type,
     * when the module is shut down.
     */
    (void) restore_monitortype(); /* restore old value */
    release_currentmonitor();
    release_edidblocks();
    if (preferred_mode)
    {
        free(preferred_mode);
    }

    UNUSED(pw);
    UNUSED(podule);
    UNUSED(fatal);

    return NULL;
}

/* EXPORTED */
void ScreenModes_servicecall(int servicecallno, _kernel_swi_regs *regs, void *pw)
{
    if ((current_monitor == NULL) && (servicecallno != Service_DisplayChanged))
    {
        return;                         /* nothing loaded */
    }

    /* Ignore service calls if we are not the current preferred instantiation */
    if (!we_are_preferred(pw))
    {
        return;
    }

    if (servicecallno == Service_ModeExtension)
    {
        service_modeextension(regs);
    }
    else if (servicecallno == Service_EnumerateScreenModes)
    {
        service_enumeratescreenmodes(regs);
    }
    else if (servicecallno == Service_ModeTranslation)
    {
        service_modetranslation(regs);
    }
    else if (servicecallno == Service_DisplayChanged)
    {
        service_displaychanged(regs);
    }
    else if (servicecallno == Service_MonitorLeadTranslation)
    {
        service_monitorleadtranslation(regs);
    }
}

/* EXPORTED */
_kernel_oserror *ScreenModes_cmdhandler(const char *arg_string, int argc, int cmd_no, void *pw)
{
    _kernel_oserror *result;

    switch (cmd_no)
    {
        case CMD_LoadModeFile:
            result = loadmodefile(arg_string);
            break;
        case CMD_SaveModeFile:
            result = savemodefile(arg_string);
            break;
        default:
            return NULL;
    }

    UNUSED(pw);
    UNUSED(argc);

    return result;
}

/* EXPORTED */
_kernel_oserror *ScreenModes_swihandler(int swi_no, _kernel_swi_regs *r, void *pw)
{
    _kernel_oserror *result;

    switch (swi_no)
    {
        case ScreenModes_ReadInfo - ScreenModes_00:
            switch (r->r[0])    /* r0 = subreason code */
            {
                case ScreenModes_ReadInfo_MonitorName: /* Return pointer to monitor name */
                    if (current_monitor)
                    {
                        r->r[0] = (int) &current_monitor->name;
                        result = NULL;
                    }
                    else
                    {
                        /* No monitor description file loaded */
                        result = error(ERR_NOMODEFILE, 0, 0, 0);
                    }
                    break;

                case ScreenModes_ReadInfo_DPMS: /* Read supported DPMS state of monitor */
                    if (current_monitor)
                    {
                        r->r[0] = current_monitor->dpms_state;
                        result = NULL;
                    }
                    else
                    {
                        /* No monitor description file loaded */
                        result = error(ERR_NOMODEFILE, 0, 0, 0);
                    }
                    break;

                case ScreenModes_ReadInfo_SpeakerMask: /* Read monitor speaker mask */
                    if (current_monitor)
                    {
                        r->r[0] = current_monitor->speaker_mask; /* Mask */
                        r->r[1] = current_monitor->speaker_mask_provided ? 0x7f : 0; /* Validity of each bit */
                        result = NULL;
                    }
                    else
                    {
                        /* No monitor description file loaded */
                        result = error(ERR_NOMODEFILE, 0, 0, 0);
                    }
                    break;                        

                default:        /* Unknown ScreenModes_ReadInfo call */
                    result = error(ERR_BADREADINFO, 0, 0, 0);
            }
            break;

        case ScreenModes_EnumerateAudioFormats - ScreenModes_00:
            return swi_enumerateaudioformats(r);

        case ScreenModes_Features - ScreenModes_00:
            r->r[0] = ScreenModes_Features_EDID; /* These extra features are supported */
            result = NULL;
            break;

        default:                /* Unknown ScreenModes SWI */
            return error_BAD_SWI;
    }
    UNUSED(pw);

    return result;
}

/* EOF ScrModes.c */
@


4.47
log
@Fix memory leak and undefined behaviour
edidsupport.c: for each CVT3 and standard timing block encountered a ModeDescription was allocated but never used, thus leaked.
ScrModes.c: start the bit masking loop at 0, otherwise a mask of 1<<-1 is used.
Found by cppcheck static analysis.

Aside - edidsupport.c the calls to dtd_block_to_modedesc() could be refactored to let it do the allocation, rather than each caller doing so and having to deal with clean up on error. Not done in these changes.

Version 0.70. Tagged as 'ScrModes-0_70'
@
text
@d77 33
d499 3
a501 2
/* List of new PixelFormats available from old GraphicsV_DisplayFeatures */
static PixelFormat oldformats[] = {
d508 18
d528 3
d540 1
a540 1
bool is_old_format(const PixelFormatRef pf)
d561 55
d619 1
a619 1
static int build_a_vidclist(VIDCListRef vp, ModeDescriptionRef mp, const PixelFormatRef pf)
d709 1
a709 1
static int mode_valid(ModeDescriptionRef mp, const PixelFormatRef pf,
d712 1
d794 22
a830 2
             * (n.b. it's assumed that build_a_vidclist will never set
             * ExtraBytes itself)
d838 4
d872 1
a872 1
    PixelFormatRef   pflist;
d890 2
a891 2
        pflist = oldformats;
        pflistlen = sizeof(oldformats)/sizeof(oldformats[0]);
d900 1
a900 1
        if (mode_valid(mp, pflist, INT32_MAX, INT32_MAX, NULL))
d1023 1
d1030 2
d1090 1
a1090 1
            mode_valid(mp, &pf, dataratelimit, datasizelimit, &thevidclist))
d1106 1
a1106 1
    PixelFormatRef pf,pflist;
d1110 6
d1134 2
a1135 2
        pflist = oldformats;
        pflistlen = sizeof(oldformats)/sizeof(oldformats[0]);
d1145 1
a1145 1
        if (!mode_valid(mp, pf, dataratelimit, datasizelimit, NULL))
d1247 11
a1257 1
static int mode_available(uint32_t xres, uint32_t yres, const PixelFormatRef pf, int framerate)
a1258 1
    ModeDescriptionRef mp;
d1260 11
d1272 22
a1293 2
    mp = find_by_xy(current_monitor->modelist, xres, yres, &nmodes);
    if (mp == NULL)
d1295 1
a1295 1
        return 0;
d1297 5
a1301 1
    do
d1303 25
a1327 7
        if ((framerate == -1 || framerate == mp->frame_hz) &&
            mode_valid(mp, pf, INT32_MAX, INT32_MAX, NULL))
        {
            return 1;
        }
        mp = mp->next;
    } while (--nmodes);
d1329 34
a1362 2
    return 0;
}
d1364 1
a1366 8
    unsigned int flags;
    int depth;
    PixelFormat pf;

    static const char pal[4]  = {  0,  8, 12, 15 };
    static const char ntsc[4] = { 44, 45, 46, 46 };
    static const char vga[4]  = { 25, 26, 27, 28 };

d1368 1
a1368 1
    if (regs->r[3] != 7 || !current_monitor)
d1373 132
a1504 21
    /* Someone has asked for an old-style mode number, but we
     * must have refused it.
     *
     * If we don't handle this, the Kernel will select one of
     * modes 25, 26, 27 or 28. This would be fine, except
     * we may not have mode 25, due to interlacing problems, or
     * we may have only non-interlaced modes.
     *
     * Note we're not told the bandwidth and memory limits.
     * Could deal with this by issuing OS_CheckModeValid for
     * each mode, but that adds reentrancy problems :) The
     * selection of modes above are within the limits of even
     * an A310, so we assume they won't be too big/fast.
     */

    /* What depth are they looking for? If the mode is
     * unknown, use 1bpp (as the Kernel does).
     */
    if (_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2)|_OUT(_FLAGS),
              regs->r[2], 9, &depth, &flags) || (flags & _C)) {
        depth = 0;
d1506 37
d1544 15
a1558 7
    /* Clamp depth to 8bpp to restrict ourselves to old-style
     * modes.
     */
    if (depth > 3)
    {
        depth = 3;
    }
d1560 6
a1565 2
retry_with_4bpp:
     pixelformat_from_depth(&pf,depth);
d1567 54
a1620 47
    /* Check if 640x480xdepth @@ 60Hz is available. If so, allow
     * kernel to do normal.
     */
     if (mode_available(640, 480, &pf, 60))
     {
         regs->r[1] = Service_Serviced;
         regs->r[2] = vga[depth];       /* substitute mode */
         return;
     }

     /* We don't have a standard VGA mode. Let's try a PAL TV
      * mode.
      */
     if (mode_available(640, 256, &pf, 50))
     {
         regs->r[1] = Service_Serviced;
         regs->r[2] = pal[depth];       /* substitute mode */
         return;
     }

     /* Alright then. How about a NTSC TV mode? */
     if (mode_available(640, 200, &pf, 60))
     {
         regs->r[1] = Service_Serviced;
         regs->r[2] = ntsc[depth];      /* substitute mode */
         return;
     }

     /* Check if 640x480xdepth @@ any rate is available */
     if (mode_available(640, 480, &pf, -1))
     {
         regs->r[1] = Service_Serviced;
         regs->r[2] = vga[depth];       /* substitute mode */
         return;
     }

     /* Still getting nowhere? Maybe we can't do 1bpp or 8bpp for
      * various reasons. Try again with 4bpp.
      */
     if (depth != 2)
     {
         depth = 2;
         goto retry_with_4bpp;
     }

     /* I give up. Let someone else worry about it. */
     return;
d1630 5
a1634 2
             * At the moment all the driver-specific stuff happens during the
             * enumerate/translate calls, so just check the monitor's still there.
d1848 2
@


4.46
log
@Allow selection of BBC gap modes via mode selector blocks
Detail:
  c/ScrModes - Adjust pixel format selection to take into account BBC gap modes, which have non-standard NColour values.
Admin:
  Tested on BB-xM


Version 0.69. Tagged as 'ScrModes-0_69'
@
text
@d1328 2
a1329 2
        int sample_rate = -1;
        int bits = -1;
@


4.45
log
@Service call API clean up
There's no need to graft in a special sub-sub-reason for Service_DisplayChanged, since ScrModes always reads the EDID at power up the data blob is already there. To force it to be used (in situations where the user had selected a disc based textual MDF) simply load it with *LoadModeFile.

Version 0.68. Tagged as 'ScrModes-0_68'
@
text
@d897 6
@


4.44
log
@Fix EDID use at startup
Detail:
  c/ScrModes - Re-introduce the using_edid check in the Service_DsiplayChanged handler, that was removed in ScreenModes 0.64.
  Removing the check completely breaks automatic EDID use (via MonitorType EDID), causing the kernel to panic and treat everything as mode 0 (due to no mode definitions being available).
Admin:
  Tested on Raspberry Pi 3
  Should fix issue reported on forums (bad screen mode during boot after upgrading from RC15):
  https://www.riscosopen.org/forum/forums/4/topics/9342


Version 0.66. Tagged as 'ScrModes-0_66'
@
text
@d1240 1
a1240 3
            /* added new reason code of 1 to indicate reset to edid based definitions
            */
            readedid(regs->r[2], (regs->r[3]==1) || using_edid);
@


4.43
log
@Add support for new GraphicsV_VetMode2 call
Detail:
  VetMode2 allows the driver to give the OS extra feedback about a proposed mode. In particular, it allows the driver to suggest a value for the ExtraBytes control list item, so by using the VetMode2 call ScreenModes is able to support modes where the video driver requires extra padding to be added to the framebuffer.
  h/modex - Remove local definitions of control list item numbers. Reserve space for one extra control list item in the VIDCList structure.
  c/ScrModes - Use Global/VIDCList.h for control list item numbers. Update mode_valid to make use of VetMode2 where available, and give it the ability to copy the resulting VIDCList into a caller-supplied buffer, allowing service_modeextension to easily use the correct ExtraBytes setting.
Admin:
  Tested on Raspberry Pi 3
  Requires Kernel-5_82


Version 0.65. Tagged as 'ScrModes-0_65'
@
text
@d1242 1
a1242 1
            readedid(regs->r[2], regs->r[3]==1?true:false);
@


4.42
log
@Remove ReadEDID command. Extend Service_DisplayChanged response
Detail:
ReadEDID command removed. New subreason code added to reason code 0
of Service_DisplayChanged to oblige ScrModes to load the EDID based
modes it discovered. Required because current behaviour would ignore
any EDID based modes once a LoadModeFile command had been issued.
Admin:
Tested on iMx6

Version 0.64. Tagged as 'ScrModes-0_64'
@
text
@d38 1
d506 4
a509 1
static void build_a_vidclist(VIDCListRef vp, ModeDescriptionRef mp, const PixelFormatRef pf)
d528 1
a528 1
        vp->vcparam[ctrllistpos].index = NCOLOUR_INDEX;
d531 1
a531 1
        vp->vcparam[ctrllistpos].index = MODEFLAGS_INDEX;
d538 1
a538 1
        vp->vcparam[ctrllistpos].index = DPMS_INDEX;
d546 1
a546 1
        vp->vcparam[ctrllistpos].index = LCDMODE_INDEX;
d551 1
a551 1
            vp->vcparam[ctrllistpos].index = LCDDUAL_INDEX;
d555 1
a555 1
        vp->vcparam[ctrllistpos].index = LCDOFF0_INDEX;
d558 1
a558 1
        vp->vcparam[ctrllistpos].index = LCDOFF1_INDEX;
d561 1
a561 1
        vp->vcparam[ctrllistpos].index = DACCTRL_INDEX;
d568 1
a568 1
        vp->vcparam[ctrllistpos].index = HCLK_INDEX;
d575 1
a575 1
        vp->vcparam[ctrllistpos].index = INTERLACED_INDEX;
d582 1
a582 1
        vp->vcparam[ctrllistpos].index = OPFORMAT_INDEX;
d588 2
d596 2
d601 2
a602 1
                       uint32_t maxdatasize /* bytes */)
d682 1
a682 1
    build_a_vidclist(&vetlist, mp, pf);
d684 2
a685 2
    r.r[1] = NULL;
    r.r[4] = GraphicsV_VetMode | (driver<<24);
d688 1
a688 1
    if ((r.r[4] == 0) && (r.r[0] != 0))
d690 34
a723 1
        return 0;    /* Had a definitive answer from GraphicsV that it no-likey */
d727 4
d765 1
a765 1
        if (mode_valid(mp, pflist, INT32_MAX, INT32_MAX))
d946 1
a946 1
            mode_valid(mp, &pf, dataratelimit, datasizelimit))
a947 2
            build_a_vidclist(&thevidclist, mp, &pf); /* use the local static structure */

d950 1
a950 1
            regs->r[3] = (int)&thevidclist; /* return pointer to VIDC list to use */
d995 1
a995 1
        if (!mode_valid(mp, pf, dataratelimit, datasizelimit))
d1110 1
a1110 1
            mode_valid(mp, pf, INT32_MAX, INT32_MAX))
a1512 1
            int display = 0;
@


4.41
log
@  Reinstall *readedid command as it IS needed in some circumstances
Detail:
Admin:
  tested on iMx6

Version 0.62. Tagged as 'ScrModes-0_62'
@
text
@d1195 4
a1198 2
             */
            readedid(regs->r[2], using_edid);
a1478 4
        case CMD_ReadEDID:
            if(argc > 1) sscanf(arg_string,"%1d",&display);
            result = readedid(display, true);
            break;
@


4.40
log
@Offer export of raw EDID blob and complementary MDF export
Detail:
  Export the EDID raw data as a file in ResourceFS. This allows the Screen Setup plugin to scan that directory to pick up the currently connected monitor, and similarly select it from !Boot.Choices.PreDesk. The EDID data can also be drag & drop copied or exported for offline analysis.
  Add SaveModeFile command. This differs in that it works on the current set, to be symmetrical with LoadModeFile which loads the current set. Also fixes issues of losing the original mode names given; NULL pointer dereference when the EDID block contains no modes (eg. VIDCDriver); and no long writes out malformed MDFs which can't be loaded into !MakeModes (this seems to be because the CreateModeFile command was based on a stale copy of EDIDDecode which fixed the same bug circa 2012).
  Query the current GraphicsV driver for the deepest colour depth for the preferred mode, rather than assuming 32bpp is always possible (eg. because of bandwidth or graphics controller constraints).
  If the configured MonitorType is EDID but no EDID could be read, or it was corrupt, substitute a safe VESA monitor to allow the kernel to select something close to MODE 28.
  Add ScreenModes_Features SWI so the Screen Setup plugin knows whether it's safe to offer EDID in its dialogues.
  Retire the ReadEDID command (no longer needed since LoadModeFile can load the exported EDID blob, or one from disc) and CreateModeFile commands (see SaveModeFile).
  Internationalise the default monitor title ("Unidentified") used when EDID doesn't contain one.
Admin:
  New file - doc/BootStates documents all possible situations, and their recovery, for both the MDF and (non-hotplug) EDID schemes.
  New file - doc/EDIDGoals states the aims of the EDID support from both a user and support perspective.

  Submission for the EDID bounty.

Version 0.61. Tagged as 'ScrModes-0_61'
@
text
@d1467 1
d1477 4
@


4.39
log
@Resolve allocation clash with RISCOS Ltd
Detail:
  Some cross-checking against the RISC OS Select documentation revealed that ScreenModes_ReadInfo 1 had already been claimed by ROL for the purpose of reading the monitor's supported DMPS state, causing a clash with our recently-introduced usage of reading the monitor speaker mask.
  Implement ScreenModes_ReadInfo 1 as per ROL's spec, and change the "read speaker mask" call to ScreenModes_ReadInfo 2.
  File changes:
  - c/ScrModes, hdr/ScrModes - as above
Admin:
  Tested on Raspberry Pi


Version 0.58. Tagged as 'ScrModes-0_58'
@
text
@d33 4
d49 4
a52 3
/* Switch to define whether EDID is computed, or whether only traditional
 * loadmodefile activity happens. EDID activity enabled by a ReadEDID
 * command, and disabled by a LoadModeFile command.
d54 1
a54 1
bool EDIDEnabled;
d85 2
a86 1
_kernel_oserror *error(int error, const char *arg0, const char *arg1, const char *arg2)
a87 2
    /* Where the final returned message is constructed */
    static _kernel_oserror theerror;
a89 1
    _kernel_swi_regs r;
a90 1
    char token[8];
d93 3
a95 4
    r.r[0] = (int)file_data;
    r.r[1] = (int)Module_MessagesFile;
    r.r[2] = 0;
    if ((res = _kernel_swi(MessageTrans_OpenFile, &r, &r)) != NULL)
d100 18
d119 2
a120 15

    r.r[0] = (int)file_data;
    r.r[1] = (int)token;
    r.r[2] = (int)theerror.errmess;
    r.r[3] = 252;
    r.r[4] = (int)arg0;                 /* for %0 */
    r.r[5] = (int)arg1;                 /* for %1 */
    r.r[6] = (int)arg2;                 /* for %2 */
    r.r[7] = 0;                         /* not expecting %3, so don't substitute */
    res = _kernel_swi(MessageTrans_Lookup, &r, &r);
    /* Always close the messages file, ignoring possible but most unlikely errors */
    r.r[0] = (int)file_data;
    (void)_kernel_swi(MessageTrans_CloseFile, &r, &r);
    /* Check for error from the lookup */
    if (res)
d122 1
a122 1
        return res;                     /* lookup failed */
d129 22
d395 5
d404 61
d484 1
a484 1
static bool is_old_format(const PixelFormatRef pf)
d688 49
a943 1

a1176 1
    _kernel_oserror *res;
d1183 12
a1194 14
             * enumerate/translate calls, so there's nothing to do.
             */
            if (EDIDEnabled)
            {
                res = readedid(regs->r[2],NULL);
            }

            break;
        case DisplayChanged_Changed:
            /* Display change is complete
             * Issue mode file changed service call so that the display manager
             * is up to date.
             * (might be possible to skip this if EDID is in use and EDID has
             * already issued it)
d1196 1
a1196 1
            _swix(OS_ServiceCall,_IN(1),Service_ModeFileChanged);
d1381 13
a1393 2
    preferred_mode = malloc(sizeof(ModeSelector));
    if (preferred_mode)
d1395 1
a1395 1
        memset(preferred_mode,0,sizeof(ModeSelector));
d1397 1
a1400 1
    EDIDEnabled = 0;          /* not enabled on module boot */
d1405 1
d1414 1
d1473 2
a1474 5
        case CMD_ReadEDID:
            result = readedid(current_graphicsv_driver(),NULL);
            break;
        case CMD_CreateModeFile:
            result = readedid(current_graphicsv_driver(),arg_string);
d1544 5
@


4.38
log
@Omit mode name from lookup tables
Detail:
  Save 4k of ROM space by not storing the mode name string; always generate it at run time.
  Split the ModeDefinition struct into the timings part (ModeDef) and full definition (ModeDefinition).
Admin:
  Submission for the EDID bounty.
  Tagged as ScrModes-0_56-smalltables.
@
text
@d1360 13
@


4.37
log
@Split out MDF and EDID support
Detail:
  Main source file split into 3.
Admin:
  Tested briefly, functionality unchanged.
  Submission for the EDID bounty.
  Tagged as ScrModes-0_53-split
@
text
@d153 1
a153 1
    ModeDefinition *mp = &md->definition; /* for terseness! */
d178 1
a178 1
    if (m1->definition.xres < m2->definition.xres)
d182 1
a182 1
    if (m1->definition.xres > m2->definition.xres)
d186 1
a186 1
    if (m1->definition.yres < m2->definition.yres)
d190 1
a190 1
    if (m1->definition.yres > m2->definition.yres)
d202 1
a202 1
    if (m1->definition.pixel_khz < m2->definition.pixel_khz)
d206 1
a206 1
    if (m1->definition.pixel_khz > m2->definition.pixel_khz)
d421 2
a422 2
        vp->hpar[fn] = mp->definition.hpar[fn];
        vp->vpar[fn] = mp->definition.vpar[fn];
d424 2
a425 2
    vp->pixelrate = mp->definition.pixel_khz;
    vp->syncpol = mp->definition.syncpol;
d468 1
a468 1
    if (mp->definition.external_clock != -1)
d471 1
a471 1
        vp->vcparam[ctrllistpos].value = mp->definition.external_clock;
d475 1
a475 1
    if (mp->definition.interlaced)
d503 3
a505 3
    uint32_t pixrate = mp->definition.pixel_khz;
    uint32_t mx = mp->definition.xres;
    uint32_t my = mp->definition.yres;
d597 1
a597 1
    while (mp && mp->definition.xres < xres)
d599 1
a599 1
    while (mp && mp->definition.xres == xres && mp->definition.yres < yres)
d601 1
a601 1
    if (mp && mp->definition.xres == xres && mp->definition.yres == yres)
d610 2
a611 2
        } while (mp && mp->definition.xres == xres &&
                 mp->definition.yres == yres);
d847 2
a848 2
                            ip->xresol = mp->definition.xres;
                            ip->yresol = mp->definition.yres;
d866 2
a867 2
                            ip->xresol = mp->definition.xres;
                            ip->yresol = mp->definition.yres;
@


4.36
log
@Split out data tables, stylistic refactoring
Detail:
  Move the 500+ lines of tables into a new source file and remove storage inferred by former CEAModes.h.
  Tame some of the rampant style from various authors, even within 1 function, to something reasonably consistent.
  Uppercase the 'debug' macro to 'IFDEBUG'.
  Relocate ScrModes specific defines out of EDIDModes header, rename to edidmemory.h.
  Add monitor type 6 to monitors.h.
  Fix for unguarded debug printout "Can't allocate space for monitor list" in parseedid.
Admin:
  Tested briefly, functionality unchanged.
  Submission for the EDID bounty.
  Tagged as ScrModes-0_53-tables
@
text
@a21 1
#include <ctype.h>
a24 2
#include <math.h>
#include <assert.h>
a32 1
#include "Global/VIDCList.h"
a38 1
#include "edidmemory.h"
d42 2
a43 15
#include "tables.h"

#ifndef DODEBUG
#define DODEBUG 0
#endif

#if DODEBUG
static int dodebug = 1;
#define IFDEBUG    if (!dodebug) {} else
#else
#define IFDEBUG    if (1) {} else
#endif

/* By default we only use DMT timings; we will check for additional support later */
static int timing_support = EDID_USE_DMT;
d49 1
a49 63
static bool EDIDEnabled;

/* Tweak to force the keyword table to be stored in the code area, by
 * making it all into a single char array including embedded NULs to
 * terminate individual entries.  We trust the compiler to spot the
 * multiple (2) source instances of this string constant and arrange to
 * use a single copy of it.
 */
#define keywordset     \
    "x_res\0         " \
    "y_res\0         " \
    "h_timings\0     " \
    "v_timings\0     " \
    "pixel_rate\0    " \
    "sync_pol\0      " \
    "external_clock\0" \
    "mode_name\0     " \
    "file_format\0   " \
    "monitor_title\0 " \
    "dpms_state\0    " \
    "lcd_support\0   " \
    "interlaced\0    " \
    "output_format\0 " \
    "startmode\0     " \
    "endmode"
#define MAXKEYWORDLEN 14
#define keyword(n) (keywordset + ((n) * (MAXKEYWORDLEN+1)))

/* Must keep this consistent with keywordset above: order has to match
 * exactly.
 */
enum keycode
{
    /* First in the set are those keywords which may be encountered
     * when reading an individual mode definition (i.e. between
     * "startmode", and "endmode").  These values are kept together in
     * the enumeration to make it easier to form a bitmap of seen
     * keywords in parse_mode() below.  At the moment, every keyword
     * must be seen exactly once in each definition.
     */
    k_x_res = 0,
    k_y_res,
    k_h_timings,
    k_v_timings,
    k_pixel_rate,
    k_sync_pol,
    k_external_clock,
    k_mode_name,
#define last_mode_key k_mode_name  /* last in *enumeration* - order in file not fixed! */

    k_file_format,
    k_monitor_title,
    k_dpms_state,
    k_lcd_support,
    k_interlaced,
    k_output_format,
    k_startmode,
    k_endmode,

    /* Now specials which do not correspond to actual file keywords */
    k_nokey,                       /* identifer not recog. as keyword */
    k_eof                          /* end of file */
};
d57 1
a57 1
static MonitorDescriptionRef current_monitor = NULL; /* not defined to start with */
d59 1
a59 4
static ModeSelectorRef preferred_mode = NULL; /* The preferred mode */
static int preferred_sync_type = 0; /* The sync type for the preferred mode
                                       NB only service_monitorleadtranslation
                                       uses this value */
d61 5
d69 1
a69 1
static int old_monitortype = -1;       /* -1 means we haven't loaded a file yet */
d80 1
a80 1
static _kernel_oserror *error(int error, const char *arg0, const char *arg1, const char *arg2)
d123 1
a123 1
static void free_monitordescription(MonitorDescriptionRef description)
d140 1
a140 1
static void release_currentmonitor(void)
d149 1
a149 1
static int matchtext(char *text, const char *ref)
d151 4
a154 1
    while (tolower(*text) == *ref)
d156 2
a157 5
        if (*text == '\0')
        {
            return 1;
        }
        ++text; ++ref;
d159 3
a161 19
    return 0;
}

#define using_stdio 1

#if using_stdio
static FILE *thefile;
#else                                   /* in-memory file */
static struct { char *base, *next, *lim; } thefile;
#endif
static const char *thefilename;         /* only valid during processing */
static int lineno;

static _kernel_oserror *open_modefile(const char *filename)
{
    _kernel_oserror *res;
#if using_stdio
    FILE *f = fopen(filename, "r");
    if (f != NULL)
d163 1
a163 1
        res = NULL;                     /* all OK */
d165 1
a165 31
    else
    {
        res = _kernel_last_oserror();
        if (res == NULL)
        {
            _kernel_swi_regs regs;
            /* Couldn't open file but only C library knows why: let's find out. */
            regs.r[0] = OSFind_OpenIn | open_nopath | open_nodir | open_mustopen;
            regs.r[1] = (int) filename;
            regs.r[2] = 0;
            res = _kernel_swi(OS_Find, &regs, &regs);
            if (res == NULL)
            {
                /* Hmmm, fopen failed but we *can* open it: give up!
                 * First re-close this file handle.
                 */
                int fh = regs.r[0];
                regs.r[0] = OSFind_Close;
                regs.r[1] = fh;
                (void) _kernel_swi(OS_Find, &regs, &regs);
                res = error(ERR_OPENFAIL, filename, 0, 0);
            }
        }
    }
    thefile = f;
#else
#error only stdio supported for now!
#endif
    lineno = 1;
    thefilename = filename;
    return res;
d168 9
a176 1
static int nextc(void)
d178 1
a178 5
    int c;
#if using_stdio
    c = getc(thefile);
#else
    if (thefile.ptr < thefile.lim)
d180 1
a180 1
        c = *thefile.ptr++;
d182 1
a182 1
    else
d184 1
a184 1
        c = EOF;
d186 1
a186 2
#endif
    if (c == '\n')
d188 1
a188 1
        ++lineno;
d190 1
a190 6
    return c;
}

static void pushback(int c)
{
    if (c != EOF)
d192 1
a192 12
#if using_stdio
        ungetc(c, thefile);
#else
        if (thefile.ptr > thefile.base && thefile.ptr[-1] == c)
        {
            --thefile.ptr;
        }
#endif
        if (c == '\n')
        {
            --lineno;
        }
d194 1
a194 59
}

static void close_modefile(void)
{
#if using_stdio
    fclose(thefile);
#else
    free(thefile.base);
#endif
}

static _kernel_oserror *synerr0(int code)
{
    char linebuff[10+1];
    sprintf(linebuff, "%u", lineno);
    return error(code, thefilename, linebuff, 0);
}

static _kernel_oserror *synerrC(int errcode, int thechar)
{
    char linebuff[10+1], charbuff[1+1];
    sprintf(linebuff, "%u", lineno);
    charbuff[0] = thechar; charbuff[1] = '\0';
    return error(errcode, thefilename, linebuff, charbuff);
}

static _kernel_oserror *synerrK(int errcode, enum keycode keycode)
{
    char linebuff[10+1];
    sprintf(linebuff, "%u", lineno);
    return error(errcode, thefilename, linebuff, keyword(keycode));
}

/* Semantic errors are not directly associated with a single line, so
 * no line number is shown.  The distinction between syntatic errors
 * and semantic ones is a little fine at times...
 */
static _kernel_oserror *semerr0(int code)
{
    return error(code, thefilename, 0, 0);
}

static _kernel_oserror *semerrS(int code, char *thestring)
{
    return error(code, thefilename, thestring, 0);
}

static int skip_space(void)
{
    int c;
    while ((c = nextc()) != '\n' && isspace(c))
        ;
    return c;
}

static int skip_comment_or_blank(void)
{
    int c;
    while ((c = skip_space()) == '\n' || c == '#')
d196 1
a196 11
        if (c == '#')
        {
            /* Comment - extends to end of line */
            /* TMD 25-Nov-93 - Fix bug MED-01177
               Wasn't checking for EOF here, so if comment line
               ended in EOF, it looped indefinitely
             */
            do
                c = nextc();
            while (c != '\n' && c != EOF);
        }
d198 1
a198 13
    return c;
}


static enum keycode read_keyword(void)
{
    char buff[MAXKEYWORDLEN+1+1];
    int i, c;
    enum keycode k;

    c = skip_comment_or_blank();
    i = 0;
    if (c == EOF)
d200 1
a200 1
        return k_eof;
d202 1
a202 1
    while (isalpha(c) || c == '_')
d204 1
a204 6
        if (i < MAXKEYWORDLEN+1)
        {
            /* allow one extra char, to catch junk at end */
            buff[i++] = c;
        }
        c = nextc();
d206 1
a206 14
    pushback(c);                       /* backstep over terminating char */
    buff[i] = '\0';                     /* terminate it */
    k = (enum keycode) 0;
    while (k < k_nokey && !matchtext(buff, keyword(k)))
        k = (enum keycode) (k + 1);
    return k;
}

static _kernel_oserror *skip_char(int ch)
{
    int c;
    while ((c = nextc()) != '\n' && isspace(c))
        ;
    if (c == ch)
d208 1
a208 1
        return NULL;
d210 1
a210 6
    if (c == EOF)
    {
        return synerr0(ERR_EOF);
    }
    pushback(c);                       /* in case of '\n', to get lineno right */
    return synerrC(ERR_EXPCHAR, ch);
d213 1
a213 1
static _kernel_oserror *check_eol(int eofok)
d215 3
a217 2
    int c = skip_space();
    if (c == '\n' || (eofok && c == EOF))
d219 5
a223 32
        return NULL;
    }
    if (c == EOF)
    {
        return synerr0(ERR_EOF);
    }
    return synerr0(ERR_EXTRAINPUT);
}

/* Read text (starting with the next non-space character) up to the
 * end of the current line. EOF is not acceptable to terminate it.
 * Trailing spaces are removed.  Text longer than the available buffer
 * size is (for now) just truncated.
 *
 * TMD 13-Dec-93: Allow zero length lines if blankerror=-1,
 * because blank mode names are now OK.
 */
static _kernel_oserror *read_text(char *buff, int size, int blankerror)
{
    int c, i, excess;
    i = 0;  excess = 0;
    /* Skip leading white-space */
    c = skip_space();
    if (c == '\n' && blankerror != -1)
    {
        /* blank field - complain if necessary */
        pushback(c);                   /* to get line number correct! */
        return synerr0(blankerror);
    }
    while (c != EOF && c != '\n')
    {
        if (i < size-1)
d225 1
a225 6
            buff[i++] = c;
        }
        else
        {
            /* Should we complain, or issue a warning? Do nowt for now. */
            if (!isspace(c))
d227 17
a243 7
                ++excess;
#if DODEBUG
                    if (excess == 1)
                    {
                        printf("excess chars ignored on text at line %d\n", lineno);
                    }
#endif                    
d245 4
d250 1
a250 12
        c = nextc();
    }
    if (c == EOF)
    {
        return synerr0(ERR_EOF);       /* EOF not allowed */
    }
    /* Remove trailing white-space */
    while (i > 0 && isspace(buff[i-1]))
        --i;
    /* Terminate the string */
    buff[i] = '\0';
    return NULL;
d253 1
a253 1
static _kernel_oserror *read_u32(uint32_t *var)
d255 4
a258 20
    int c;
    uint32_t acc;
    c = skip_space();
    if (!isdigit(c))
    {
        return synerr0(ERR_EXPNUM);
    }
    acc = c - '0';
    while (isdigit(c = nextc()))
    {
        int digit = c - '0';
        if (acc > UINT32_MAX/10 ||
            (acc == UINT32_MAX/10 && digit > UINT32_MAX%10)) {
            return synerr0(ERR_VALUEOVF);
        }
        acc = acc * 10 + digit;
    }
    pushback(c);                       /* leave terminating char waiting to be read */
    *var = acc;
    return NULL;
d261 1
a261 1
static _kernel_oserror *read_one_u32(uint32_t *var, uint32_t fault_zero)
d263 4
a266 1
    _kernel_oserror *res = read_u32(var);
d269 1
a269 1
        return res;
d271 1
a271 1
    if (fault_zero && *var == 0)
d273 1
a273 1
        return synerr0(ERR_INVALIDPAR);
a274 1
    return check_eol(0);
d277 1
a277 1
static _kernel_oserror *check_keyword(enum keycode code, int colon)
d279 2
a280 3
    enum keycode kc;
    kc = read_keyword();
    if (kc == k_eof)
d282 2
a283 2
        /* we never explicitly look for k_eof */
        return synerr0(ERR_EOF);
d285 9
a293 1
    if (kc != code)
d295 1
a295 5
        return synerrK(ERR_EXPKEY, code);
    }
    if (colon)
    {
        return skip_char(':');
d299 21
a319 1
        return NULL;
d321 1
d324 1
a324 1
static _kernel_oserror *parse_mode(ModeDefinition *mode)
d326 2
a327 1
    uint32_t keyseen;
d329 20
a348 2574
    keyseen = 0;
    mode->interlaced = 0; /* Assume mode is not interlaced, unless we see the keyword */
    mode->external_clock = -1;
    for (;;)
    {
        enum keycode kc = read_keyword();
        uint32_t param, missed, ok_to_miss;
        _kernel_oserror *res;
        if (kc <= last_mode_key)
        {
            if (keyseen & (1 << kc))
            {
                return synerrK(ERR_REPKEY, kc);
            }
            res = skip_char(':');
            if (res)
            {
                return res;
            }
            keyseen |= 1 << kc;
        }
        switch (kc)
        {
          case k_eof:
            return synerr0(ERR_EOF);

          case k_endmode:
            /* Work out which, if any, of the entries have not been supplied */
            assert(last_mode_key <= 31);
            missed = ((1u << (last_mode_key + 1)) - 1) & ~keyseen;

            /* In format 1, we normally insist that x_res = hdisp and
             * y_res = vdisp so x_res and y_res are in fact optional.
             * However if the mode is interlaced, then x_res and y_res are compulsory.
             * We insist that all other keywords do occur.
             */
            ok_to_miss = mode->interlaced ? 0 : (1 << k_x_res) | (1 << k_y_res);
            ok_to_miss |= (1 << k_interlaced) | (1 << k_external_clock);
            if (missed & ~ok_to_miss)
            {
                /* If some other keyword(s) not seen, complain.  If
                 * mode_name is one of them, must identify by line
                 * number so treat it as a syntactic error, else as
                 * semantic, providing debugging info in terms of the
                 * mode name.
                 */
                if (missed & (1 << k_mode_name))
                {
                    return synerr0(ERR_NOMODENAME);
                }
                else
                {
                    return semerrS(ERR_INCOMPLETE, mode->name);
                }
            }
            /* If xres and/or yres missing, use the xdisp and/or ydisp values */
            if (!(keyseen & (1 << k_x_res)))
            {
              mode->xres = mode->hpar[FR_DISP];
            }
            if (!(keyseen & (1 << k_y_res)))
            {
              mode->yres = mode->vpar[FR_DISP];
            }

            /* xres must equal xdisp, and yres must equal ydisp (or ydisp*2 for interlaced modes) */
            if (mode->xres != mode->hpar[FR_DISP] ||
                mode->yres != mode->vpar[FR_DISP] * (mode->interlaced+1))
            {
                return semerrS(ERR_INCONSISTENT, mode->name);
            }
            return check_eol(1);

          case k_nokey:
            return synerr0(ERR_UNKNOWNPAR);

          default:
            /* Known keyword but out of place */
            return synerrK(ERR_WRONGCONTEXT, kc);

          case k_x_res:
            res = read_one_u32(&mode->xres, 1);
            if (res)
            {
                return res;
            }
            break;

          case k_y_res:
            res = read_one_u32(&mode->yres, 1);
            if (res)
            {
                return res;
            }
            break;

          case k_pixel_rate:
            res = read_one_u32(&mode->pixel_khz, 1);
            if (res)
            {
                return res;
            }
            break;

          case k_sync_pol:
            res = read_one_u32(&param, 0);
            if (res)
            {
                return res;
            }
            if (param > 3)
            {   /* must fit in (currently) 2 bits */
                return synerr0(ERR_VALUEOVF);
            }
            mode->syncpol = param;
            break;

          case k_interlaced:
            mode->interlaced = 1; /* It is an interlaced mode */
            res = check_eol(0);
            if (res)
            {
                return res;
            }
            break;

          case k_external_clock:
            res = read_one_u32(&mode->external_clock, 0);
            if (res)
            {
                return res;
            }
            break;

          case k_mode_name:
            /* TMD 13-Dec-93: We must allow blank mode names now -
             * they mean a mode is not shown in DisplayManager menu.
             * Passing in -1 as the error number for read_text means don't
             * fault blank lines.
             */
            res = read_text(mode->name, sizeof(mode->name), -1);
            if (res)
            {
                return res;
            }
            break;

          case k_h_timings:
          case k_v_timings:
            {
                int pn;
                uint16_t *par = kc == k_h_timings ? mode->hpar : mode->vpar;
                for (pn = 0; pn < FR__COUNT; ++pn)
                {
                    uint32_t param;
                    res = read_u32(&param);
                    if (res)
                    {
                        return res;
                    }
                    if (param >= 0x10000)
                    {   /* must fit in 16 bits (unsigned) */
                        return synerr0(ERR_VALUEOVF);
                    }
                    par[pn] = param;
                    /* Check for following comma or end of line */
                    if (pn < FR__COUNT-1)
                    {
                        res = skip_char(',');
                    }
                }
                if (par[FR_DISP] == 0)
                {
                    return synerr0(ERR_INVALIDPAR);
                }

                res = check_eol(0);
                if (res)
                {
                    return res;
                }
            }
            break;
        }
    }
}

static void compute_modedescription(ModeDescriptionRef md)
{
    uint32_t vtot, htot;
    int pn;
    ModeDefinition *mp = &md->definition; /* for terseness! */
    for (htot = 0, vtot = 0, pn = 0; pn < FR__COUNT; ++pn)
    {
        htot += mp->hpar[pn];
        vtot += mp->vpar[pn];
    }
    md->line_hz = mp->pixel_khz * 1000 / htot;  /* compute line frequency in Hz */
    md->frame_mhz = md->line_hz * 1000 / vtot; /* frame frequency in milliHz, high-prec */
    if (mp->interlaced)
    {
        md->frame_mhz /= 2; /* if interlaced, one frame is 2 fields */
    }
    md->frame_hz = (md->frame_mhz + 500) / 1000; /* & low-prec for user integer Hz matching */
}

static _kernel_oserror *parse_modelist(MonitorDescriptionRef monitor, enum keycode kc)
{
    for (;;)
    {
        if (kc == k_startmode)
        {
            ModeDescriptionRef mp;
#if 0
            ModeDescriptionRef rp;
#endif
            _kernel_oserror *res;
            res = check_eol(0);
            if (res)
            {
                return res;
            }
            mp = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
            if (mp == NULL)
            {
                return error(ERR_NOSPACE, 0, 0, 0);
            }
            /* Chain the new (as yet un-filled-in) mode on as the head
             * of the existing list, so the space will get released
             * properly on error.
             */
            mp->next = monitor->modelist;
            monitor->modelist = mp;
            /* Go parse the definition, filling in the record fields */
            res = parse_mode(&mp->definition);
            if (res)
            {
                return res;                     /* failed */
            }
            /* fill in defaults */
            if (mp->definition.external_clock == -1)
            {
                mp->definition.external_clock = monitor->external_clock;
            }
            /* derive frame and line rates */
            compute_modedescription(mp);
#if 0
            /* Check for uniqueness of mode name */
            rp = mp->next;
            while (rp)
            {
                if (strcmp(rp->definition.name, mp->definition.name) == 0)
                {
                    return semerrS(ERR_DUPMODENAME, mp->definition.name);
                }
                rp = rp->next;
            }
#endif
        }
        else if (kc == k_eof)
        {
            /* OK provided there is at least one mode! */
            if (monitor->modelist != NULL)
            {
                return NULL;            /* ALL DONE */
            }
            return semerr0(ERR_NOMODES);
        }
        else
        {
            return synerrK(ERR_EXPKEY, k_startmode);
        }
        kc = read_keyword();               /* read next startmode, hopefully */
    }
}

static _kernel_oserror *parse_modefile(MonitorDescriptionRef *description)
{
    uint32_t ffmt;
    _kernel_oserror *res;
    MonitorDescriptionRef md;
    enum keycode kc = k_nokey;

    res = check_keyword(k_file_format, 1);
    if (res)
    {
        return res;
    }
    res = read_one_u32(&ffmt, 0);
    if (res)
    {
        return res;
    }
    if (ffmt != 1)
    {
        return synerr0(ERR_UNKNOWNFMT);
    }

    res = check_keyword(k_monitor_title, 1);
    if (res)
    {
        return res;
    }
    /* OK, commit to reading a monitor description - go allocate space */
    md = (MonitorDescriptionRef) malloc(sizeof(MonitorDescription));
    if (md == NULL)
    {
        return error(ERR_NOSPACE, 0, 0, 0);
    }
    /* From here on, need to release memory on error, so do most of
     * the rest as a subroutine.
     */
    memset(md, 0, sizeof(MonitorDescription));
    md->modelist = NULL;                                       /* to start with */
    res = read_text(md->name, sizeof(md->name), ERR_BLANKMONTITLE);

    /* Now check for optional DPMS_state keyword */
    if (res == NULL)
    {
        md->dpms_state = -1;                                   /* indicates field not present */
        kc = read_keyword();
        if (kc == k_dpms_state)
        {
            res = skip_char(':');
            if (res == NULL)
            {
                res = read_one_u32(&md->dpms_state, 0);       /* read DPMS_state value */
            }
            if (res == NULL)
            {
                kc = read_keyword();                          /* then read next keyword */
            }
        }
    }

    /* Now check for optional LCD_support keyword */
    if (res == NULL)
    {
        md->lcd_support = 0;                                   /* Indicates CRT as default */
        if (kc == k_lcd_support)
        {
            IFDEBUG printf("Got the lcdsupport keyword\n");
            res = skip_char(':');
            if (res == NULL)
            {
                res = read_one_u32(&md->lcd_support, 0);      /* read LCD_support value */
                if (md->lcd_support != 0)
                {
                  md->dpms_state = -1;                         /* LCD and DPMS are mutually exclusive */
                }
                IFDEBUG printf("Read the value as %d\n",md->lcd_support);
            }
            if (res == NULL)
            {
              kc = read_keyword();                            /* then read next keyword */
            }
        }
    }

    /* Now check for optional output_format keyword */
    if (res == NULL)
    {
        md->output_format = -1;                                /* indicates field not present */
        if (kc == k_output_format)
        {
            res = skip_char(':');
            if (res == NULL)
            {
                res = read_one_u32(&md->output_format, 0);    /* read output_format value */
            }
            if (res == NULL)
            {
                kc = read_keyword();                          /* then read next keyword */
            }
        }
    }

    /* Now check for optional external_clock keyword */
    if (res == NULL)
    {
        md->external_clock = -1;                               /* indicates field not present */
        if (kc == k_external_clock)
        {
            res = skip_char(':');
            if (res == NULL)
            {
                res = read_one_u32(&md->external_clock, 0);   /* read external_clock value */
            }
            if (res == NULL)
            {
                kc = read_keyword();                          /* then read next keyword */
            }
        }
    }

    if (res == NULL)
    {
        IFDEBUG printf("Going to read the modes now...\n");
        res = parse_modelist(md, kc);                         /* pass in read keyword token */
    }

    if (res)
    {
        free_monitordescription(md);
        md = NULL;
    }
    *description = md;
    return res;
}

/* For efficiency in handling the Service_ModeExtension service call,
 * we keep the list of supported modes in order.  The keys used for
 * comparison of modes are (in order of use):
 *   (1) increasing x resolution
 *   (2) increasing y resolution
 *   (3) decreasing frame rate
 *   (4) increasing peak datarate at a given depth, i.e. pixelrate
 */
static int modes_inorder(ModeDescriptionRef m1, ModeDescriptionRef m2)
{
    if (m1->definition.xres < m2->definition.xres)
    {
        return 1;
    }
    if (m1->definition.xres > m2->definition.xres)
    {
        return 0;
    }
    if (m1->definition.yres < m2->definition.yres)
    {
        return 1;
    }
    if (m1->definition.yres > m2->definition.yres)
    {
        return 0;
    }
    if (m1->frame_mhz > m2->frame_mhz)
    {
        return 1;
    }
    if (m1->frame_mhz < m2->frame_mhz)
    {
        return 0;
    }
    if (m1->definition.pixel_khz < m2->definition.pixel_khz)
    {
        return 1;
    }
    if (m1->definition.pixel_khz > m2->definition.pixel_khz)
    {
        return 0;
    }
    return 1;                           /* arbitrary here - modes seem the same! */
}

static void sort_modelist(ModeDescriptionRef *list)
{
    ModeDescriptionRef prev, this, next;
    int swapped;
    do
    {
        prev = NULL;                    /* marks being at start of list */
        this = *list;                   /* not NULL */
        next = this->next;              /* might be NULL, for 1-entry list */
        swapped = 0;
        while (next)
        {
            if (!modes_inorder(this, next))
            {
                ModeDescriptionRef t;
                /* Move whatever is pointing at this to point at next */
                if (prev == NULL)
                {
                    *list = next;       /* swap at start of list */
                }
                else
                {
                    prev->next = next;
                }
                /* The new successor to this record is what was after the next one */
                this->next = next->next;
                /* The new successor to what was the next record is now this record */
                next->next = this;
                /* Swap our local this and next pointers */
                t = this;  this = next;  next = t;
                swapped = 1;
            }
            /* Step all the pointers on by one in the (perhaps re-ordered) list */
            prev = this;
            this = next;
            next = next->next;
        }
    } while (swapped);
}

static _kernel_oserror *set_monitortype(int monitortype)
{
    _kernel_swi_regs regs;
    regs.r[0] = 3;
    regs.r[1] = monitortype;
    return _kernel_swi(OS_ScreenMode, &regs, &regs);
}

static int read_monitortype(void)
{
    _kernel_swi_regs regs;
    _kernel_oserror *res;
    regs.r[0] = 1;
    res = _kernel_swi(OS_ReadSysInfo, &regs, &regs);
    if (res)
    {
        return -1;
    }
    else
    {
        return regs.r[1];
    }
}

static _kernel_oserror *restore_monitortype(void)
{
    int temp = old_monitortype;
    if (temp != -1)
    {
        old_monitortype = -1;
        return set_monitortype(temp);
    }
    return NULL;
}

#if DODEBUG
static void show_monitor(MonitorDescriptionRef monitor)
{
    ModeDescriptionRef mode;
    printf("Monitor title: \"%s\"\n", monitor->name);
    for (mode = monitor->modelist; mode; mode = mode->next)
    {
        ModeDefinition *dp = &mode->definition;
        uint32_t pixrate = dp->pixel_khz;
        uint32_t pixels = dp->xres * dp->yres;
        int log2bpp;
        printf("  Mode name \"%s\"\n", mode->definition.name);
        printf("  Resolution %u x %u\n", dp->xres, dp->yres);
        printf("  Line rate %u.%03u kHz, Frame rate %d.%03d Hz\n",
               mode->line_hz / 1000, mode->line_hz % 1000,
               mode->frame_mhz / 1000, mode->frame_mhz % 1000);
        printf("  Pixel rate %u kHz, Sync type %u\n", dp->pixel_khz, dp->syncpol);
        printf("  Line timings\n"
               "    sync %u b-porch %u l-border %u display %u r-border %u f-porch %u\n",
               dp->hpar[FR_SYNC], dp->hpar[FR_BPCH], dp->hpar[FR_BDR1],
               dp->hpar[FR_DISP], dp->hpar[FR_BDR2], dp->hpar[FR_FPCH]);
        printf("  Frame timings\n"
               "    sync %u b-porch %u t-border %u display %u b-border %u f-porch %u\n",
               dp->vpar[FR_SYNC], dp->vpar[FR_BPCH], dp->vpar[FR_BDR1],
               dp->vpar[FR_DISP], dp->vpar[FR_BDR2], dp->vpar[FR_FPCH]);
        if (dp->interlaced)
        {
            printf("  Interlaced\n");
        }
        for (log2bpp = 0; log2bpp <= 5; ++log2bpp) {
            uint32_t bits = 1 << log2bpp;
            uint32_t drate, dsize;
            if (bits < 8)
            {
                uint8_t shift = 3 - log2bpp;
                uint32_t round = (1 << shift) - 1;
                drate = (pixrate + round) >> shift;
                dsize = (pixels + round) >> shift;
            }
            else
            {
                uint8_t shift = log2bpp - 3;
                drate = pixrate << shift;
                dsize = pixels << shift;
            }
            printf("  %2u bpp: bandwidth %6u000 bytes/sec, data size %7u bytes\n", bits, drate, dsize);
        }
        printf("\n");
    }
}
#endif

static _kernel_oserror *loadtextMDF(const char *file)
{
    _kernel_oserror *res;
    MonitorDescriptionRef new_monitor;
    EDIDEnabled = 0;   /* disable any automatic edid stuff */

    IFDEBUG printf("file opened OK\n");
    res = parse_modefile(&new_monitor);
    IFDEBUG printf("closing file\n");
    close_modefile();
    if (res != NULL)
    {
        IFDEBUG printf("failed to parse mode file\n");
    }
    else
    {
        IFDEBUG printf("monitor description parsed OK\n");
        sort_modelist(&new_monitor->modelist);
#if DODEBUG
        show_monitor(new_monitor);
#endif
        /* If we haven't got a file loaded at present, then
         * read current monitortype, to restore on module shutdown
         */
        if (old_monitortype == -1)
        {
            old_monitortype = read_monitortype();
        }

        /* Now tell kernel to use monitor type 7 (File) */
        res = set_monitortype(MONITOR_FILE);
        if (res != NULL)
        {
            _kernel_oserror *res2;
            IFDEBUG printf("setting of monitor type to type `FILE' failed\n");
            res2 = restore_monitortype(); /* restore old value */
#if DODEBUG
            if (res2 != NULL)
            {
                printf("couldn't reset monitor type to CMOS default!\n");
            }
#endif                
        }
        else
        {
            char *path, *dot;
            _kernel_swi_regs regs;

            path = malloc(strlen(file) + 32);
            if (path != NULL)
            {
                /* Allow the MDF to come with an accompanying sprite */
                strcpy(path,"IconSprites ");
                dot = strrchr(file, '.');
                if (dot != NULL)
                {
                    strcat(path, file);    /* Grab the path */
                    dot = 1 + strrchr(path, '.');
                    *dot = '\0';           /* Slice off the leafname */
                }
                strcat(path, "!Sprites");
                _kernel_oscli(path);
                free(path);
            }

            release_currentmonitor();
            current_monitor = new_monitor;
            /* Forget any old preferred mode */
            preferred_mode->bit0 = 0;

            /* Newly defined monitor, announce it */
            regs.r[1] = Service_ModeFileChanged;
            _kernel_swi(OS_ServiceCall, &regs, &regs);
        }
    }
    return res;
}

#if DODEBUG
/* Produce debug output showing the
 * mode descriptor being passed for a particular mode
 */
static void display_mode_parameters(ModeDescriptionRef mode_desc)
{
    printf("XRes: %i YRes: %i ",
           mode_desc->definition.xres,
           mode_desc->definition.yres);
    if (mode_desc->definition.interlaced == 1)
    {
        printf("(interlaced)");
    }
    else
    {
        printf("(non-interlaced)");
    }
  
    printf(" PixRate: %i\nHSync:%i Hbpch:%i Hlbdr:%i Hdisp:%i Hrbdr:%i Hfpch:%i\nVSync:%i Vbpch:%i Vtbdr:%i Vdispl:%i Vbbdr:%i Vfpch:%i\n\n",
           mode_desc->definition.pixel_khz,
           mode_desc->definition.hpar[FR_SYNC],
           mode_desc->definition.hpar[FR_BPCH],
           mode_desc->definition.hpar[FR_BDR1],
           mode_desc->definition.hpar[FR_DISP],
           mode_desc->definition.hpar[FR_BDR2],
           mode_desc->definition.hpar[FR_FPCH],
           mode_desc->definition.vpar[FR_SYNC],
           mode_desc->definition.vpar[FR_BPCH],
           mode_desc->definition.vpar[FR_BDR1],
           mode_desc->definition.vpar[FR_DISP],
           mode_desc->definition.vpar[FR_BDR2],
           mode_desc->definition.vpar[FR_FPCH]);
}
#endif

/* Check if a new mode is present already.
 * If it has, we won't be adding it to the chain.
 * Return 1 if successful, and 0 if we have rejected it for any reason
 */
static int add_proposed_mode(MonitorDescriptionRef monitor_definition, ModeDescriptionRef proposed_mode)
{
    proposed_mode->next = monitor_definition->modelist;
    monitor_definition->modelist = proposed_mode;
    return 1;
}

/* Copy a builtin mode and add it to the monitor description
 */
static _kernel_oserror *add_builtin_mode(MonitorDescriptionRef monitor, const ModeDefinition *mode, uint8_t priority)
{
    ModeDescriptionRef mode_desc = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
    if (mode_desc == NULL)
    {
        return error(ERR_NOSPACE, 0, 0, 0);
    }

    mode_desc->definition = *mode;
    compute_modedescription(mode_desc);
    mode_desc->frame_hz = mode->freq;
    mode_desc->priority = priority;

    if (add_proposed_mode(monitor, mode_desc) == 0)
    {
        free(mode_desc);
        return NULL;
    }

#if DODEBUG
    display_mode_parameters(mode_desc);
#endif
    return NULL;
}

/* generate_dmt_mode creates a mode using standardised timing parameters.
 * These come from the Display Monitor Timing Document (VESA).
 * They are part of EDID 1.0 to 1.3 and should be used where a DMT
 * standard exists (refer Appendix B of EDID 1.4 spec and the DMT document).
 */
static _kernel_oserror *generate_dmt_mode(char dmt, MonitorDescriptionRef monitor, uint8_t priority)
{
    /* If there is no established timing, ignore (for now).
     * Later we will generate a mode here and add
     */
    if (dmt > 0)
    {
        dmt--; /* Convert DMT back to array number */
        IFDEBUG printf("Established Modes Display Monitor Timing :\n");

        return add_builtin_mode(monitor, &display_monitor_timings[dmt], priority);
    }
#if DODEBUG
    else
    {
        printf("Ignoring established timing(not a standard mode).\n\n");
    }
#endif

    return 0;
}

static _kernel_oserror *Check_EDID_Checksum(EDIDBlockRef edidblock, bool checkall)
{
    _kernel_oserror *res = NULL;
    size_t byte, block, blocks_to_check = 0;

    for (block = 0; block <= blocks_to_check; block++) {
        uint8_t count = 0;
        uint8_t *ediddata = (uint8_t *)&edidblock[block];
        for (byte = 0; byte < sizeof(EDIDBlock); byte++) {
            count = count + ediddata[byte];
        }
        if (count != 0)
        {
            char linebuff1[4];
            char linebuff2[4];
            sprintf(linebuff1, "%u", block);
            sprintf(linebuff2, "%u", blocks_to_check);
            res = error(ERR_BADCHECKSUM, linebuff1, linebuff2, 0);
        }
        else
        {
            if ((block == 0) && checkall)
            {
                blocks_to_check = edidblock->extension_block_count;
            }
            IFDEBUG printf("Checksum: Block %i of %i OK\n", block, blocks_to_check);
        }
    }

    return res;
}

/* Get_DTD_ASCII takes a block of text from an 18-byte EDID data block
 * And fills a supplied character buffer with a usable 0-terminated string
 * Buffer must be at least 14 bytes in length.
 */
static void Get_DTD_ASCII(EDIDBlockRef edidblockref, int block_number, char *data)
{
    int i;
    for (i = 0; i < 13; ++i)
    {
        data[i] = edidblockref->data_block[block_number][i+5];
        if (data[i] == 0x0A)
        {
            break;
        }
        else if ((data[i] < 32) || (data[i] == 127))
        {
            /* Strip out any control characters for safety */
            data[i] = ' ';
        }
    }
    data[i] = 0;
}

static void generate_mode_using_gtf(double h_pixels, double v_lines, double ip_freq_rqd, ModeDescriptionRef mode_desc, MonitorDescriptionRef monitor)
{
    const int margins_rqd = 0; /* Set to 1 if margins are wanted. */
    const double margin_per = 0; /* Percentage size of margin (0 to 100) if reqd */
    double v_lines_rnd = 0; /* Number of desired visible lines rounded down to */
                            /* The nearest character cell */
    double v_sync_rqd = 3; /* The width of the v sync in lines */
    double h_sync_percent = 8; /* The width of the H sync as percentage of the total line period */
    double cell_gran_rnd = 8; /* Character cell width in pixels. May be able to confirm this value in hardware but at present hardcode this to 8 (usual value), */
    const int int_rqd = 0; /* int_rqd specifies whether the mode should be interlaced. Most modes used are not. */
    double v_field_rate_reqd = 0; /* The actual vertical field rate after interlacing is taking into consideration */
    double interlace = 0; /* If interlacing is used, this will be set to 0.5 */

    const double min_vsync_and_bp = 550; /* The minimum time of vertical sync and back porch interval(us) */
    const double min_porch = 1; /* Minimum front porch in lines (vertical) and character cells (horizontal) */
    const double c = 40; /* The blanking formula offset */
    const double m = 600; /* The blanking formula gradient */
    const double k = 128; /* The blanking formula scaling factor */
    const double j = 20; /* The blanking formula scaling factor weighting */

    /* coefficient calculations. These should be constants in standard GTF */
    double C = ((c-j) * k / 256) + j;
    double M = k / 256 * m;

    /* Find the refresh rate required (Hz) */

    /* If interlaced, the number of vertical lines assumed by the
     * calculation must be halved, as the computation calculates the
     * number of vertical lines per field. In either case, the number
     * of lines is rounded down to the nearest integer.
     */

    if (int_rqd == 1)
    {
        v_lines_rnd = floor(v_lines / 2);
        v_field_rate_reqd = ip_freq_rqd * 2;
        interlace = 0.5;
    }
    else
    {
        v_lines_rnd = round(v_lines);
        v_field_rate_reqd = ip_freq_rqd;
        /* Interlace is automatically set to 0 */
    }

    /* Round the number of pixels to the nearest character */
    /* cell boundary */
    double h_pixels_rnd = (round(h_pixels/cell_gran_rnd)) * cell_gran_rnd;

    /* Determine the width of the left and right borders */
    double left_margin = 0; /* Number of pixels in the left hand margin, rounded */
                          /* down to the nearest character cell. If no margins */
                          /* required this is set to 0. */
    double right_margin = 0; /* see left_margin */
    double top_margin = 0; /* No of lines rounded down to nearest line. */
    double bot_margin = 0; /* See top, left, right */

    if (margins_rqd == 1)
    {
        left_margin = round(h_pixels_rnd * margin_per / 100 / cell_gran_rnd) *cell_gran_rnd;
        right_margin = left_margin;
        top_margin = round(margin_per / 100 * v_lines_rnd);
        bot_margin = top_margin;
    }

    /* For the calculations below, refer to the VESA GTF v1.1 spec */

    /* Estimate the horizontal period */
    double h_period_est = ((1 / v_field_rate_reqd) - min_vsync_and_bp/1000000)
             / (v_lines_rnd + (2 * top_margin) + min_porch + interlace)
             * 1000000;

    /* Find the number of lines in V sync + B Porch */
    double vsync_and_bp = round(min_vsync_and_bp / h_period_est);

    /* Find number of lines in back porch alone */
    double v_back_porch = vsync_and_bp - v_sync_rqd;

    /* Find the total number of lines in the vertical field period */
    double total_v_lines = v_lines_rnd + top_margin + bot_margin + vsync_and_bp + interlace + min_porch;

    /* Estimate the vertical field frequency */
    double v_field_rate_est = 1/h_period_est/total_v_lines * 1000000;

    /* Find the actual horizontal period */
    double h_period = h_period_est / (v_field_rate_reqd / v_field_rate_est);

    /* Find the actual vertical field frequency */
    double v_field_rate = 1/h_period/total_v_lines * 1000000;

    /* Find the vertical frame frequency */
    if (int_rqd == 1)
    {
      v_field_rate = v_field_rate / 2;
    }

    /* GTF calculates margins using a percentage here. We use actual pixels */
    /* (and 0 always at present) */

    double total_active_pixels = h_pixels_rnd + left_margin + right_margin;

    /* Find the ideal blanking duty cycle from the blanking duty cycle equation */
    double ideal_duty_cycle = C - (M * h_period / 1000);

    /* Find the number of pixels in the blanking time to the nearest double */
    /* character cell */
    double h_blank_pixels = (round(total_active_pixels * ideal_duty_cycle / (100 - ideal_duty_cycle) / (2 * cell_gran_rnd))) * (2 * cell_gran_rnd);

    /* Find the total number of pixels */
    double total_pixels = total_active_pixels + h_blank_pixels;

    /* Find pixel clock frequency */
    double pixel_freq = total_pixels / h_period;

    /* Find horizontal frequency */
    /* double h_freq = 1000 / h_period; */

    /* From GTF spec - Using Stage 1 parameters to derive stage 2 parameters */

    /* Find addressable lines per frame */
    double addr_lines_per_frame;
    if (int_rqd == 1)
    {
        addr_lines_per_frame = v_lines_rnd * 2;
    }
    else
    {
        addr_lines_per_frame = v_lines_rnd;
    }

    /* Find the total number of lines in a frame: */
    double total_lines_per_frame = v_lines_rnd + top_margin + bot_margin + vsync_and_bp + interlace + min_porch;
    if (int_rqd == 1)
    {
        total_lines_per_frame = total_lines_per_frame * 2;
    }

    /* Find the number of pixels in the horizontal sync period */
    double h_sync_pixels = (round(h_sync_percent/100 * total_pixels
      / cell_gran_rnd)) * cell_gran_rnd;

    /* Find the number of pixels in the horizontal front porch period */
    double h_front_porch = (h_blank_pixels / 2) - h_sync_pixels;

    double h_back_porch = h_front_porch + h_sync_pixels;

    /* Find the odd front porch period (lines) (36) */
    double v_fporch = min_porch + interlace;

    mode_desc->definition.xres = (int)h_pixels;
    mode_desc->definition.yres = (int)v_lines;
    mode_desc->definition.hpar[FR_SYNC] = (int) h_sync_pixels;
    mode_desc->definition.hpar[FR_BPCH] = (int) h_back_porch;
    mode_desc->definition.hpar[FR_BDR1] = (int) left_margin;
    mode_desc->definition.hpar[FR_DISP] = (int) h_pixels;
    mode_desc->definition.hpar[FR_BDR2] = (int) right_margin;
    mode_desc->definition.hpar[FR_FPCH] = (int) h_front_porch;
    mode_desc->definition.vpar[FR_SYNC] = (int) v_sync_rqd;
    mode_desc->definition.vpar[FR_BPCH] = (int) v_back_porch;
    mode_desc->definition.vpar[FR_BDR1] = (int) top_margin;

    if (int_rqd)
    {
        mode_desc->definition.vpar[FR_DISP] = (int) v_lines / 2;
    }
    else
    {
        mode_desc->definition.vpar[FR_DISP] = (int) v_lines;
    }

    mode_desc->definition.vpar[FR_BDR2] = (int) bot_margin;
    mode_desc->definition.vpar[FR_FPCH] = (int) v_fporch;
    mode_desc->definition.pixel_khz = (int) round(pixel_freq * 1000);
    mode_desc->definition.external_clock = -1;
    if (timing_support == EDID_USE_GTF)
    {
        mode_desc->definition.syncpol = HSync_Negative+VSync_Positive; /* Default GTF */
    }
    else
    {
        mode_desc->definition.syncpol = HSync_Positive+VSync_Negative; /* Secondary GTF */
    }
    mode_desc->definition.interlaced = int_rqd;

    sprintf(mode_desc->definition.name, "%d x %d", (int)h_pixels, (int)v_lines);
    compute_modedescription(mode_desc);

    if (add_proposed_mode(monitor, mode_desc) == 0)
    {
        free(mode_desc);
    }
#if DODEBUG
    display_mode_parameters(mode_desc);
#endif    
}

static void generate_mode_using_cvt_rb(double h_pixels, double v_lines, double ip_freq_rqd, ModeDescriptionRef mode_desc, MonitorDescriptionRef monitor)
{
    const int int_rqd = 0; /* int_rqd specifies whether the mode should be interlaced. Most modes used are not. */
    const int margins_rqd = 0; /* Set to 1 if margins are wanted. */
    const double margin_per = 0; /* Percentage size of margin(0 to 100) if reqd */
    double cell_gran_rnd = 8; /* Character cell width in pixels. May be able to confirm this value in hardware but at present hardcode this to 8 (usual value), */
    double v_field_rate_reqd = 0; /* The actual vertical field rate after interlacing is taking into consideration */
    double v_lines_rnd = 0; /* Number of desired visible lines rounded down to the nearest character cell */
    double interlace = 0; /* If interlacing is used, this will be set to 0.5 */

    /* Determine the aspect ratio and set the v_sync_rnd variable
     * This is a slightly messy lookup table - VESA recommends the lookup
     * approach. We match on X, but in some cases we need to also check Y if
     * there are other modes with different heights.
     */
    int v_sync_rnd = 0;

    if ((h_pixels == 640)  ||
        (h_pixels == 800)  ||
        (h_pixels == 1024) ||
        (h_pixels == 1400) ||
        (h_pixels == 1600) ||
        (h_pixels == 1920) ||
        (h_pixels == 2048) ||
        (h_pixels == 2560) ||
        (h_pixels == 3200) ||
        (h_pixels == 3840)) {
        v_sync_rnd = 4;
    }

    if ((h_pixels == 1280) && ((v_lines == 1024) || (v_lines == 768)))
    {
        v_sync_rnd = 7;
    }

    if ((h_pixels == 848) ||
        (h_pixels == 1064) ||
        ((h_pixels == 1280) && (v_lines == 720)) ||
        (h_pixels == 1360) ||
        (h_pixels == 1704) ||
        (h_pixels == 1864) ||
        ((h_pixels == 1920) && (v_lines == 1080)) ||
        (h_pixels == 2128) ||
        (h_pixels == 2560) ||
        (h_pixels == 2728) ||
        (h_pixels == 3408) ||
        (h_pixels == 4264)) {
        v_sync_rnd = 5;
    }

    if ((int) (h_pixels / v_lines * 10) == 16)
    {
        v_sync_rnd = 6;
    }

    if (v_sync_rnd == 0)
    {
        IFDEBUG printf("Error - Cannot handle this aspect ratio\n");
        /* If this happens we should just ignore the mode */
        free(mode_desc);
        return;
    }

    /* The variable names used below are those in the VESA Coordinated Timings
     * Standard. I've kept this code as close to the original as possible for
     * clarity at the cost of some speed. When this works 110%, this can be
     * optimised out.
     */

    /* Find the refresh rate required (Hz) */

    /* If interlaced, the number of vertical lines assumed by the
     * calculation must be halved, as the computation calculates the
     * number of vertical lines per field. In either case, the number
     * of lines is rounded down to the nearest integer.
     */
    if (int_rqd == 1)
    {
        v_lines_rnd = floor(v_lines / 2);
        v_field_rate_reqd = ip_freq_rqd * 2;
        interlace = 0.5;
    }
    else
    {
        v_lines_rnd = floor(v_lines);
        v_field_rate_reqd = ip_freq_rqd;
        /* Interlace is automatically set to 0 */
    }

    /* Round the number of pixels to the nearest character cell boundary */
    double h_pixels_rnd = (floor(h_pixels/cell_gran_rnd)) * cell_gran_rnd;

    /* Determine the width of the left and right borders */
    double left_margin = 0; /* Number of pixels in the left hand margin, rounded down to the nearest character cell. If no margins required this is set to 0. */
    double right_margin = 0; /* see left_margin */
    double top_margin = 0; /* No of lines rounded down to nearest line. */
    double bot_margin = 0; /* See top, left, right */

    if (margins_rqd == 1)
    {
        left_margin = floor(h_pixels_rnd * margin_per / 100 / cell_gran_rnd) *cell_gran_rnd;
        right_margin = left_margin;
        top_margin = floor(margin_per / 100 * v_lines_rnd);
        bot_margin = top_margin;
    }

    /* Minimum vertical back porch (used in both sets of calcs). */
    const double min_v_bporch = 6;

    /* The total number of active pixels is equal to the rounded
     * horizontal pixels and the margins:
     */
    double total_active_pixels = h_pixels_rnd + left_margin + right_margin;

    /* Pixel clock resolution - see CVT spec S3.2 */
    const double clock_step = 0.25;

    /* Define back porch (used in our final block) */
    int v_back_porch;

    /* Define actual pixel frequency (for final block) */
    double act_pixel_freq;

    /* H blanking period (for final block) */
    int h_blank;

    /* H sync (for final block) */
    int h_sync;

    /* V front porch (NB in CVT this is min_v_porch_rnd and in CVT-RB this is
     * rb_v_fporch but as they are both constants declare them.
     */
    double v_front_porch = 3;

    if (timing_support == EDID_USE_CVT)
    {
        /* Computation of "CRT" (ie non-RB) CVT timings */
        /* Minimum timing for vertical blanking for 'CRT' timings */
        const double min_vsync_bp = 550;
        /* Standard 'CRT' timing vertical front porch */

        /* Estimate the horizontal period (kHz) */
        double h_period_est = ((1 / v_field_rate_reqd) - min_vsync_bp / 1000000) / (v_lines_rnd + (2 * top_margin) + v_front_porch + interlace) * 1000000;
        /* Find the number of lines in V sync + back porch */
        double v_sync_bp = floor(min_vsync_bp / h_period_est) + 1;
        if (v_sync_bp < v_sync_rnd + min_v_bporch)
        {
            v_sync_bp = v_sync_rnd + min_v_bporch;
        }

        /* Find the number of lines in V back porch */
        v_back_porch = (int) (v_sync_bp - v_sync_rnd);

        /* Find total number of lines in vertical field period */
        double total_v_lines = v_lines_rnd + top_margin + bot_margin + v_sync_bp + interlace + v_front_porch;

        /* C_PRIME = ((C-J) * K / 256 + J (from CVT spec) */
        const double c_prime = 30;

        /* M_PRIME = K / 256 * M (from CVT spec) */
        const double m_prime = 300;

        /* Find the ideal blanking duty cycle from the blanking duty cycle equation (%): */
        double ideal_duty_cycle = c_prime - (m_prime * h_period_est / 1000);

        /* Find the number of pixels in the horizontal blanking time to the nearest double character cell
         * (limit horizontal blanking so that it is >= 20% of the horizontal total).
         */
        if (ideal_duty_cycle < 20)
        {
            h_blank = (int) (floor(total_active_pixels * 20 / (100-20) / (2 * cell_gran_rnd)) * (2 * cell_gran_rnd));
        }
        else
        {
            h_blank = (int) (floor(total_active_pixels * ideal_duty_cycle / (100 - ideal_duty_cycle) / (2 * cell_gran_rnd)) * (2 * cell_gran_rnd));
        }

        /* Find the total number of pixels in a line */
        double total_pixels = total_active_pixels + h_blank;

        /* Find pixel clock frequency (MHz): */
        act_pixel_freq = clock_step * floor((total_pixels / h_period_est) / clock_step);

        /* Find actual horizontal frequency (kHz) */
        double act_h_freq = 1000 * act_pixel_freq / total_pixels;

        /* Find actual field rate (Hz) */
        double act_field_rate = 1000 * act_h_freq / total_v_lines;

        /* Find actual refresh rate (Hz) */
        double act_frame_rate = act_field_rate;
        if (int_rqd == 1)
        {
            act_frame_rate = act_field_rate / 2;
        }

        /* H sync per is the percentage of horizontal total period that
         * defines horizontal sync width
         */
        const double h_sync_per = 8;

        /* Calculate H sync */
        h_sync = (int) (floor(h_sync_per / 100 * total_pixels / cell_gran_rnd) * cell_gran_rnd);
    }
    else
    {
        /* Computation of Reduced Blanking timing parameters. */

        /* Estimate the horizontal period (kHz) */
        const double rb_min_v_blank = 460; /* Min V blank for reduced timings */
        double h_period_est = ((1000000/v_field_rate_reqd) - rb_min_v_blank) / (v_lines_rnd + top_margin + bot_margin);

        double vbi_lines = floor(rb_min_v_blank / h_period_est) + 1;

        /* Vertical front porch is fixed in reduced blanking */
        v_front_porch = 3;

        double rb_min_vbi = v_front_porch + v_sync_rnd + min_v_bporch;

        double act_vbi_lines; /* Actual number of vertical blanking lines */
        if (vbi_lines < rb_min_vbi)
        {
            act_vbi_lines = rb_min_vbi;
        }
        else
        {
            act_vbi_lines = vbi_lines;
        }

        double total_v_lines = act_vbi_lines + v_lines_rnd + top_margin + bot_margin + interlace;

        h_sync = 32;   /* H sync is fixed in reduced blanking */
        h_blank = 160; /* H Blank is fixed in reduced blanking */

        /* Find total number of pixel clocks per line */
        double total_pixels = h_blank + total_active_pixels;

        const double clock_step = 0.25;

        /* Calculate the pixel clock frequency to nearest 0.125MHz */
        act_pixel_freq = clock_step * floor(v_field_rate_reqd * total_v_lines * total_pixels / 1000000) / clock_step;

        /* Find the number of lines in V_sync + back porch: */
        v_back_porch = (int) (act_vbi_lines - v_front_porch - v_sync_rnd);
    }

    /* Calculate front and back porch */
    int h_back_porch = h_blank / 2;
    int h_front_porch = h_blank - h_back_porch - h_sync;

    /* Now populate the mode definition block */
    mode_desc->definition.xres = (int)h_pixels;
    mode_desc->definition.yres = (int)v_lines;
    mode_desc->definition.hpar[FR_SYNC] = h_sync;
    mode_desc->definition.hpar[FR_BPCH] = h_back_porch;
    mode_desc->definition.hpar[FR_BDR1] = (int) left_margin;
    mode_desc->definition.hpar[FR_DISP] = (int) h_pixels;
    mode_desc->definition.hpar[FR_BDR2] = (int) right_margin;
    mode_desc->definition.hpar[FR_FPCH] = h_front_porch;
    mode_desc->definition.vpar[FR_SYNC] = (int) v_sync_rnd;
    mode_desc->definition.vpar[FR_BPCH] = v_back_porch;
    mode_desc->definition.vpar[FR_BDR1] = (int) top_margin;
    if (int_rqd)
    {
        mode_desc->definition.vpar[FR_DISP] = (int) v_lines / 2;
    }
    else
    {
        mode_desc->definition.vpar[FR_DISP] = (int) v_lines;
    }
    mode_desc->definition.vpar[FR_BDR2] = (int) bot_margin;
    mode_desc->definition.vpar[FR_FPCH] = (int) v_front_porch;
    mode_desc->definition.pixel_khz = (int) (act_pixel_freq * 1000);
    mode_desc->definition.external_clock = -1;
    if (timing_support == EDID_USE_CVT)
    {
        mode_desc->definition.syncpol = HSync_Negative+VSync_Positive;
    }
    else
    {
        /* EDID_USE_CVTRB */
        mode_desc->definition.syncpol = HSync_Positive+VSync_Negative;
    }
    mode_desc->definition.interlaced = int_rqd;

    sprintf(mode_desc->definition.name, "%d x %d", (int)h_pixels, (int)v_lines);
    compute_modedescription(mode_desc);

    if (add_proposed_mode(monitor, mode_desc) == 0)
    {
        free(mode_desc);
    }
#if DODEBUG
    display_mode_parameters(mode_desc);
#endif    
}

static _kernel_oserror *generate_standard_timing(char std1, char std2, MonitorDescriptionRef monitor)
{
    ModeDescriptionRef mode_desc = NULL;
    /* If this mode is defined as a DMT standard, use this by checking the
     * bytes directly with the lookup table
     */
    int i = 0;

    IFDEBUG printf("Standard Timing(%x %x) ", std1, std2);

    while (std_timings[i].stdcode[0] || std_timings[i].stdcode[1])
    {
        if ((std1 == std_timings[i].stdcode[0]) &&
            (std2 == std_timings[i].stdcode[1])) {
            mode_desc = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
            if (mode_desc == NULL)
            {
                return error(ERR_NOSPACE, 0, 0, 0);
            }
            mode_desc->definition = display_monitor_timings[std_timings[i].dmt-1];
            compute_modedescription(mode_desc);
            mode_desc->frame_hz = display_monitor_timings[std_timings[i].dmt-1].freq;
            mode_desc->priority = 5;

#if DODEBUG
            printf("(derived from DMT standard):\n");
            display_mode_parameters(mode_desc);
#endif

            if (add_proposed_mode(monitor, mode_desc) == 0)
            {
                free(mode_desc);
            }
            return NULL;
        }
        i++;
    }

    /* If it's not in the DMT lookups and we can generate a timing, do so */
    if (timing_support != EDID_USE_DMT)
    {
        int yres = 0;
        int xres = (std1 + 31) * 8;
        char pixel_ratio_flags = (std2 & 0xC0);
        if (pixel_ratio_flags == 0)
          { /* 00 = 16:10 */
            yres = (int) ((xres * 10) / 16);
        }
        if (pixel_ratio_flags == (1<<6))
        {   /* 01 = 4:3 */
            yres = (int) ((xres * 3) / 4);
        }
        if (pixel_ratio_flags == (1<<7))
        {   /* 10 = 5:4 */
            yres = (int) ((xres * 4) / 5);
        }
        if (pixel_ratio_flags == ((1<<7) + (1<<6)))
        {   /* 11 = 16:9 */
            yres = (int) ((xres * 9) / 16);
        }

        int freq = (std2 & 0x3f) + 60;

        mode_desc = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
        if (mode_desc == NULL)
        {
            return error(ERR_NOSPACE, 0, 0, 0);
        }
        IFDEBUG printf("(calculated):\n");

        if ((timing_support == EDID_USE_GTF) ||
            (timing_support == EDID_USE_GTF2)) {
            generate_mode_using_gtf(xres, yres, freq, mode_desc, monitor);
        }
        if ((timing_support == EDID_USE_CVT) ||
            (timing_support == EDID_USE_CVTRB)) {
            generate_mode_using_cvt_rb(xres, yres, freq, mode_desc, monitor);
        }

    }
    return NULL;
}

/* Generates a mode from a 3-byte CVT code
 * NB this is UNTESTED as I haven't got an appropriate EDID to test from
 */
static _kernel_oserror *generate_cvt3_timing(char cvt1, char cvt2, char cvt3, MonitorDescriptionRef monitor)
{
    ModeDescriptionRef mode_desc = NULL;
    /* If this mode is defined as a DMT standard, use this by checking the
     * bytes directly with the lookup table
     */
    IFDEBUG printf("CVT 3-byte Timing(%x %x %x) ", cvt1, cvt2, cvt3);

    /* Check the reserved bits are 00. If not, let this mode fail silently */
    if ((cvt2 & 0x03) != 0)
    {
        IFDEBUG printf("has unknown values in the reserved bits of byte 2 - skipped.\n");
        return NULL;
    }

#ifdef DERIVE_CVT3_FROM_DMT
    int i = 0;
    while (cvt_timings[i].cvtcode[0] || cvt_timings[i].cvtcode[1] || cvt_timings[i].cvtcode[2])
    {
        if ((cvt1 == cvt_timings[i].cvtcode[0]) && (cvt2 == cvt_timings[i].cvtcode[1]) && (cvt3 == cvt_timings[i].cvtcode[2]))
        {
            mode_desc = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
            if (mode_desc == NULL)
            {
                return error(ERR_NOSPACE, 0, 0, 0);
            }
            mode_desc->definition = display_monitor_timings[cvt_timings[i].dmt-1];
            compute_modedescription(mode_desc);
            mode_desc->frame_hz = display_monitor_timings[cvt_timings[i].dmt-1].freq;
            mode_desc->priority = 4; /* CVT timing */

#if DODEBUG
            printf("(derived from DMT standard):\n");
            display_mode_parameters(mode_desc);
#endif
            if (add_proposed_mode(monitor, mode_desc) == 0)
            {
                free(mode_desc);
            }
            return NULL;
        }
        i++;
    }
#endif

    /* If it's not in the DMT lookups and we can generate a timing, do so */
    if ((mode_desc == NULL) && (timing_support != EDID_USE_DMT))
    {
        int vsize = cvt1 + ((cvt2 & 0xf0)<<4);
        int yres = (vsize+1)*2;
        int xres = 0;
        int freq = 0;

        /* Use the vertical line count to generate the horizontal addressable
         * Resolution (HAdd). Use 8 X {RoundDown[(VAdd X Aspect ratio / 8]}
         * Per the EDID guidance (p48).
         */
        char pixel_ratio_flags = (cvt2 & 0x0c)>>2;
        switch (pixel_ratio_flags)
        {
            case 0:
                xres = (int) (8 * floor((((double) yres * 4) / 3) / 8));
                break;
            case 1:
                xres = (int) (8 * floor((((double) yres * 16) / 9) / 8));
                break;
            case 2:
                xres = (int) (8 * floor((((double) yres * 16) / 10) / 8));
                break;
            case 3:
                xres = (int) (8 * floor((((double) yres * 15) / 9) / 8));
                break;
        }

        /* First generate a descriptor using the display-preferred frequency
         * (bits 5 and 6 of cvt3)
         */
        switch ((cvt3 & 0x60) >> 5)
        {
            case 0:
                freq = 50;
                break;
            case 1:
                freq = 60;
                break;
            case 2:
                freq = 75;
                break;
            case 3:
                freq = 85;
                break;
        }
        if (freq != 0)
        {
            mode_desc = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
            if (mode_desc == NULL)
            {
                return error(ERR_NOSPACE, 0, 0, 0);
            }
            IFDEBUG printf("\nAt %x Hz(calculated):\n", freq);
            generate_mode_using_cvt_rb(xres, yres, freq, mode_desc, monitor);
            if (add_proposed_mode(monitor, mode_desc) == 0)
            {
                free(mode_desc);
            }
        }
        int preferred_freq = freq;

        /* Now we add any other frequencies it supports */

        /* Use timing_support to switch the timing method we use in the
         * CVT calculations and restore it at the end.
         */
        int timing_support_preferred = timing_support;

        for (int supported_freq=0; supported_freq<5; supported_freq++)
        {
            if ((cvt3 & (1<<supported_freq)) == (1<<supported_freq))
            {
                switch (supported_freq)
                {
                    case 0:
                        freq = 60;
                        timing_support = EDID_USE_CVTRB;
                    case 1:
                        freq = 85;
                        timing_support = EDID_USE_CVT;
                    case 2:
                        freq = 75;
                        timing_support = EDID_USE_CVT;
                    case 3:
                        freq = 60;
                        timing_support = EDID_USE_CVT;
                    case 4:
                        freq = 50;
                        timing_support = EDID_USE_CVT;
                }
          
                if (freq != preferred_freq)
                {
                    mode_desc = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
                    if (mode_desc == NULL)
                    {
                        return error(ERR_NOSPACE, 0, 0, 0);
                    }
                    IFDEBUG printf("\nAt %x Hz(calculated):\n", freq);
                    generate_mode_using_cvt_rb(xres, yres, freq, mode_desc, monitor);
                    if (add_proposed_mode(monitor, mode_desc) == 0)
                    {
                        free(mode_desc);
                    }
                }
            }
        }
        timing_support = timing_support_preferred;
    }
    return NULL;
}

/* Converts a detailed timing descriptor block into a mode descriptor
 * block. The defines above help it pick out the data which is split
 * across nibbles into the parameters.
 * dtd_data on entry should be a pointer to the first byte of the 18 byte
 * dtd block.
 */
static bool dtd_block_to_modedesc(char* dtd_data, ModeDescriptionRef mode_desc)
{
    IFDEBUG printf("Detailed timing descriptor:\n");
    mode_desc->definition.xres          = dtd_data[2] + ((dtd_data[4] & 0xf0) << 4);
    mode_desc->definition.yres          = dtd_data[5] + ((dtd_data[7] & 0xf0) << 4);
    mode_desc->definition.interlaced    = ((dtd_data[17]>>7) & 1);
    mode_desc->definition.hpar[FR_SYNC] = dtd_data[9] + ((dtd_data[11] & 0x30) << 4);
    mode_desc->definition.hpar[FR_BDR1] = dtd_data[15];
    mode_desc->definition.hpar[FR_DISP] = mode_desc->definition.xres;
    mode_desc->definition.hpar[FR_BDR2] = dtd_data[15];
    mode_desc->definition.hpar[FR_FPCH] = dtd_data[8] + ((dtd_data[11] & 0xc0) << 2);
    mode_desc->definition.hpar[FR_BPCH] = dtd_data[3] + ((dtd_data[4] & 0x0f) << 8) -
                                          mode_desc->definition.hpar[FR_SYNC] -
                                          mode_desc->definition.hpar[FR_FPCH] -
                                          mode_desc->definition.hpar[FR_BDR1] -
                                          mode_desc->definition.hpar[FR_BDR2];
    mode_desc->definition.vpar[FR_SYNC] = (dtd_data[10] & 0xf) + ((dtd_data[11] & 0x3) << 4);
    mode_desc->definition.vpar[FR_BDR1] = dtd_data[16];
    mode_desc->definition.vpar[FR_DISP] = mode_desc->definition.yres;
    mode_desc->definition.vpar[FR_BDR2] = dtd_data[16];
    mode_desc->definition.vpar[FR_FPCH] = (dtd_data[10] >> 4) + ((dtd_data[11] & 0xc) << 2);
    mode_desc->definition.vpar[FR_BPCH] = dtd_data[6] + ((dtd_data[7] & 0x0f) << 8) -
                                          mode_desc->definition.vpar[FR_SYNC] -
                                          mode_desc->definition.vpar[FR_FPCH] -
                                          mode_desc->definition.vpar[FR_BDR1] -
                                          mode_desc->definition.vpar[FR_BDR2];
    mode_desc->definition.pixel_khz     = (dtd_data[0] + (dtd_data[1]<<8)) * 10;
    mode_desc->definition.external_clock = -1;

    /* Only accept non-stereoscopic modes
     * Technically we should check for sync here (since we only really support
     * digital separate syncs), but for now we'll assume that misrepresenting
     * the sync isn't going to cause major problems, as it will allow more
     * modes to work (e.g. BenQ FP241W HDMI port advertises 1080p as being
     * serrated sync-on-RGB, even though the monitor is perfectly happy with
     * digital syncs)
     */
    if ((dtd_data[17] & 0x60) != 0x00)
    {
        IFDEBUG printf("Rejecting DTD due to unsupported frame format\n");
        return false;
    }

    /* -----00- is negative-negative, start with that and then invert if necessary */
    mode_desc->definition.syncpol = HSync_Negative+VSync_Negative;
    if (dtd_data[17] & 4)
    {
        mode_desc->definition.syncpol ^= VSync_Negative^VSync_Positive;
    }
    if (dtd_data[17] & 2)
    {
        mode_desc->definition.syncpol ^= HSync_Negative^HSync_Positive;
    }

    /* If we are interlaced, we need to double the number of vertical pixels */
    if (mode_desc->definition.interlaced == 1)
    {
        mode_desc->definition.yres = mode_desc->definition.yres * 2;
    }

    sprintf(mode_desc->definition.name, "%d x %d", mode_desc->definition.xres, mode_desc->definition.yres);
    compute_modedescription(mode_desc);
#if DODEBUG
    display_mode_parameters(mode_desc);
#endif
    return true;
}

/* Checks the 18-byte data blocks for their type.
 * The type returned is then either 10 (empty), 0 (detailed mode descriptor)
 * or other type numbers per the EDID specification
 */
static int get_extd_type(EDIDBlockRef edidblockref, int block_no)
{
    if (edidblockref->data_block[block_no][0] + edidblockref->data_block[block_no][1] + edidblockref->data_block[block_no][2] == 0)
    {
        return edidblockref->data_block[block_no][3];
    }
    return -1; /* -1 = display descriptor */
}

/* Add to our list of audio formats */
static _kernel_oserror *add_audio_format(uint8_t byte1, uint8_t byte2, uint8_t byte3, MonitorDescriptionRef new_monitor)
{
    AudioFormat newformat;
    newformat.format_code = (byte1 >> 3) & 0x7f;
    newformat.max_channels = (byte1 & 7) + 1;
    newformat.sample_rates = byte2;
    newformat.format_specific = byte3;
    /* Discard if bogus */
    if ((!newformat.sample_rates) || ((newformat.format_code == 1) && !(newformat.format_specific)))
    {
        return NULL;
    }
    /* Work out where to merge it into our list
     * CEA 861-D doesn't state what we should do if multiple descriptors are
     * found for the same format code, so we should be conservative with how
     * we merge blocks together
     */
    int i;
    for (i=0;i<new_monitor->audio_format_count;i++)
    {
        AudioFormat *candidate = &new_monitor->audio_formats[i];
        if (candidate->format_code > newformat.format_code)
        {
            break;
        }
        else if (candidate->format_code < newformat.format_code)
        {
            continue;
        }
        /* Try and merge with this entry
         * note - currently not doing any fancy merging of the format-specific
         * byte (could be a bit tricky for LPCM depending on what future meaning
         * is given to the reserved bits)
         */
        if (newformat.format_specific == candidate->format_specific)
        {
            if (newformat.max_channels == candidate->max_channels)
            {
                /* Merge our list of sample rates into the candidate and call
                 * it a day.
                 */
                candidate->sample_rates |= newformat.sample_rates;
                return NULL;
            }
            else if (newformat.max_channels < candidate->max_channels)
            {
                /* Candidate supports more channels than us with same
                 * format-specific settings, so ignore any sample rates which
                 * the candidate supports.
                 */
                newformat.sample_rates &= ~candidate->sample_rates;
                if (!newformat.sample_rates)
                {
                    return NULL;
                }
            }
            else if (newformat.max_channels > candidate->max_channels)
            {
                /* We support more channels than the candidate, so remove
                 * sample rates from the candidate.
                 */
                candidate->sample_rates &= ~newformat.sample_rates;
                if (!candidate->sample_rates)
                {
                    /* Candidate can be removed completely */
                    new_monitor->audio_format_count--;
                    memmove(candidate, candidate+1, sizeof(AudioFormat)*(new_monitor->audio_format_count-i));
                    void *new = realloc(new_monitor->audio_formats, new_monitor->audio_format_count*sizeof(AudioFormat));
                    if (new || !new_monitor->audio_format_count)
                    {
                        new_monitor->audio_formats = (AudioFormat*) new;
                    }
                    /* Everything's been shuffled down, so process this entry
                     * again.
                     */
                    i--;
                    continue;
                }
            }
        }
    }
    /* Need to insert a new entry */
    void *new = realloc(new_monitor->audio_formats, (new_monitor->audio_format_count+1)*sizeof(AudioFormat));
    if (!new)
    {
        return error(ERR_NOSPACE, 0, 0, 0);
    }
    new_monitor->audio_formats = (AudioFormat*) new;

    /* Shuffle following entries up */
    memmove(new_monitor->audio_formats+i+1, new_monitor->audio_formats+i, sizeof(AudioFormat)*(new_monitor->audio_format_count-i));

    new_monitor->audio_format_count++;
    new_monitor->audio_formats[i] = newformat;

    return NULL;
}

/* Process an audio data block from a CEA extension block */
static _kernel_oserror *process_cea_audio_data_block(EDIDExtensionBlockRef ext_block, int length, const uint8_t *block, MonitorDescriptionRef new_monitor)
{
    while (length >= 3)
    {
        IFDEBUG printf("CEA Short Audio Descriptor %02x %02x %02x\n",block[0],block[1],block[2]);

        /* Ignore if any reserved bits in the first couple of bytes are set */
        if (!(block[0] & 128) && !(block[1] & 128))
        {
            _kernel_oserror *err = add_audio_format(block[0], block[1], block[2], new_monitor);
            if (err)
            {
                return err;
            }
        }
        block += 3;
        length -= 3;
    }
    return NULL;
}

/* Process a video data block from a CEA extension block */
static _kernel_oserror *process_cea_video_data_block(EDIDExtensionBlockRef ext_block, int length, const uint8_t *block, MonitorDescriptionRef new_monitor)
{
    /* Parse SVDs and add to mode list */
    while (length--)
    {
        uint8_t num = block[0] & 0x7f;

        IFDEBUG printf("CEA SVD %02x -> CEA mode %d%s\n", block[0], num, (block[0] & 128) ? " (native)" : "");
        block++;
        if ((num == 0) || (num > MAXCEAMODENUM))
        {
            continue;
        }
        /* Ignore modes that require pixel repetition (currently we have no way of indicating that requirement to the driver) */
        const ModeDefinition *mode = &cea_modes[num-1];
        if ((mode->xres != mode->hpar[FR_DISP]) || (mode->xres == 2880))
        {
            continue;
        }
        _kernel_oserror *err = add_builtin_mode(new_monitor, mode, 3); /* SVDs should be considered the same priority as DTDs */
        if (err)
        {
            return err;
        }
    }
    return NULL;
}

/* Process a speaker allocation block from a CEA extension block */
static _kernel_oserror *process_cea_speaker_allocation_data_block(EDIDExtensionBlockRef ext_block, int length, const uint8_t *block, MonitorDescriptionRef new_monitor)
{
    if (length == 3)
    {
        IFDEBUG printf("CEA Speaker Allocation %02x %02x %02x\n",block[0],block[1],block[2]);
        new_monitor->speaker_mask = block[0] & 0x7f;
        new_monitor->speaker_mask_provided = true;
    }
    return NULL;
}

/* Process a data block from a CEA extension block */
static _kernel_oserror *process_cea_data_block(EDIDExtensionBlockRef ext_block, int tag_code, int length, const uint8_t *block, MonitorDescriptionRef new_monitor)
{
    if (tag_code == 7)
    {
        /* Extended tag */
        tag_code = *block++;
        length--;
        IFDEBUG printf("CEA extended data block code %d data length %d\n",tag_code,length);

        /* TODO: Process any interesting ones */
        return NULL;
    }
    IFDEBUG printf("CEA data block code %d data length %d\n",tag_code,length);
    switch (tag_code)
    {
        case 1:  return process_cea_audio_data_block(ext_block, length, block, new_monitor);
        case 2:  return process_cea_video_data_block(ext_block, length, block, new_monitor);
        case 4:  return process_cea_speaker_allocation_data_block(ext_block, length, block, new_monitor);
        default: return NULL;
    }
}

/* Process a CEA extension block */
static _kernel_oserror *process_cea_extension(EDIDExtensionBlockRef ext_block, MonitorDescriptionRef new_monitor)
{
    /* Offset from the start of the extension block to the
     * first dtd in the extension block. Uses the offset from block+2.
     */
    const uint8_t *extdata = (uint8_t *) ext_block;
    int dtd_offset = extdata[2];

    if (dtd_offset > (126 - 18))
    {
        /* Bogus DTD offset, ignore block */
        return NULL;
    }

    bool basic_audio = (ext_block->revision >= 2) && (extdata[3] & 0x40);
    if (basic_audio)
    {
        IFDEBUG printf("Basic audio supported\n");
        /* 2-ch LPCM at 32kHz, 44.1kHz, 48kHz
         * Assume 16/20/24bit supported (spec is a bit vague, but in reality it
         * shouldn't matter that much because they all get packaged the same)
         */
        _kernel_oserror *err = add_audio_format(0x9, 0x7, 0x7, new_monitor);
        if (err)
        {
            return err;
        }
    }

    if ((ext_block->revision >= 3) && (dtd_offset > 4))
    {
        /* CEA Data Block Collection present */
        int block_offset = 4;
        while (block_offset < dtd_offset)
        {
            int tag_code = extdata[block_offset] >> 5;
            int length = extdata[block_offset] & 0x1f;
            block_offset++;
            if (!tag_code || !length || (length > (dtd_offset-block_offset)))
            {
                /* Bad block length or invalid tag code. TODO - Should probably throw away everything we've learnt so far from this extension block. */
                return NULL;
            }
            _kernel_oserror *err = process_cea_data_block(ext_block, tag_code, length, extdata+block_offset, new_monitor);
            if (err)
            {
                return err;
            }
            block_offset += length;
        }
    }

    if (dtd_offset < 4)
    {
        /* No DTD's provided in this block */
        return NULL;
    }

    while ((dtd_offset <= (126 - 18)) &&
           (extdata[dtd_offset] != 0) && (extdata[dtd_offset+1] != 0))
    {
        ModeDescriptionRef mp;
        mp = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
        if (mp == NULL)
        {
            return error(ERR_NOSPACE, 0, 0, 0);
        }

        if (!dtd_block_to_modedesc((char *) &(extdata[dtd_offset]), mp))
        {
            free(mp);
        }
        else
        {
            mp->priority = 3;
            if (add_proposed_mode(new_monitor, mp) == 0)
            {
                free(mp);
            }
        }
        dtd_offset += 18; /* 18 is the size of a DTD block */
    }

    return NULL;
}

/* Process a VTB extension block */
static _kernel_oserror *process_vtb_extension_block(EDIDExtensionBlockRef ext_block, MonitorDescriptionRef new_monitor)
{
    _kernel_oserror *res = NULL;
    const uint8_t *extdata = (uint8_t *) ext_block;

    /* 'w', 'y' and 'z' originate from the VTB specification */
    int w = extdata[2]; /* 'w' is the number of detailed timing blocks (DTB) */
    int y = extdata[3]; /* 'y' is the number of CVT descriptions */
    int z = extdata[4]; /* 'z' is the number of standard timing descriptions */

    /* There's only space for 122 bytes of timing data. If the block looks like it needs more than that then it's a bad block. */
    if (w*0x12 + y*0x3 + z*0x2 > 122)
    {
        return NULL;
    }
    /* Unused bytes should be zero */
    for (int byte = 0x5 + w*0x12 + y*0x3 + z*0x2; byte < 127; byte++) {
        if (extdata[byte])
        {
            return NULL;
        }
    }

    for (int dtb_blockno = 0; dtb_blockno < w; dtb_blockno++)
    {
        ModeDescriptionRef mp;
        mp = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
        if (mp == NULL)
        {
            return error(ERR_NOSPACE, 0, 0, 0);
        }

        if (!dtd_block_to_modedesc((char *) &(extdata[0x5 + dtb_blockno*0x12]), mp))
        {
            free(mp);
        }
        else
        {
            mp->priority = 3;
            if (add_proposed_mode(new_monitor, mp) == 0)
            {
                free(mp);
            }
        }
    }

    for (int cvt_blockno = 0; cvt_blockno < y; cvt_blockno++)
    {
        ModeDescriptionRef mp;
        mp = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
        if (mp == NULL)
        {
            return error(ERR_NOSPACE, 0, 0, 0);
        }
        int cvt_byte = 0x5 + w*0x12 + cvt_blockno*0x3;
        if (!((extdata[cvt_byte] == 0) &&
            (extdata[cvt_byte+1] == 0) &&
            (extdata[cvt_byte+2] == 0))) {

            res = generate_cvt3_timing(extdata[cvt_byte], extdata[cvt_byte+1], extdata[cvt_byte+2], new_monitor);
            if (res)
            {
                return res;
            }
        }
    }

    for (int std_blockno = 0; std_blockno < z; std_blockno++)
    {
        ModeDescriptionRef mp;
        mp = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
        if (mp == NULL)
        {
            return error(ERR_NOSPACE, 0, 0, 0);
        }
        int std_byte = 0x5 + w*0x12 + y*0x3 + std_blockno*0x2;
        if (!((extdata[std_byte] == 0x1) &&
            (extdata[std_byte+1] == 0x1))) {

            res = generate_standard_timing(extdata[std_byte], extdata[std_byte+1], new_monitor);
            if (res)
            {
                return res;
            }
        }
    }

    return NULL;
}

static _kernel_oserror *parseedid(char *ediddata, const char *file)
{
    _kernel_oserror *res = NULL;
    FILE *f = NULL;
    MonitorDescriptionRef new_monitor;
    ModeDescriptionRef new_preferred_mode = NULL; /* No preferred mode */
    EDIDBlockRef edidblockref = (EDIDBlockRef) ediddata;
    int RangeBlock = -1;                          /* edid block containing timimg limits */

    /* OK, commit to reading a monitor description - go allocate space */
    new_monitor = (MonitorDescriptionRef) malloc(sizeof(MonitorDescription));
    if (new_monitor == NULL)
    {
        IFDEBUG printf("Can't allocate space for monitor list\n");
        return error(ERR_NOSPACE, 0, 0, 0);
    }
    memset(new_monitor, 0, sizeof(MonitorDescription));

    strcpy(new_monitor->name,"Display");

    new_monitor->dpms_state = -1; /* DPMS -1 = Indicates not available */
    new_monitor->lcd_support = 0; /* 'CRT by default' - what does this do???*/
    new_monitor->output_format = -1; /* Output format */
    new_monitor->external_clock = -1; /* External clock not present */
    new_monitor->modelist = NULL; /* Make sure the mode list is initially nil. */

    /* If we are EDID 1.4 compliant or above GTF and CVT support should be
     * present. Use CVT in preference, fallback to DMT only.
     */
    timing_support = EDID_USE_DMT; /* Default at DMT */
    if ((edidblockref->edid_version >= 1) && (edidblockref->edid_revision >= 4))
    {
        IFDEBUG printf("Use CVT; fallback to DMT if unavailable\n");
        timing_support = EDID_USE_CVT;
    }

    /* If we are EDID 1.4 compliant or above GTF support should be
     * present. Use GTF in preference, fallback to DMT only.
     */
    if ((edidblockref->edid_version == 1) && ((edidblockref->edid_revision == 2) || (edidblockref->edid_revision == 3)))
    {
        IFDEBUG printf("Use GTF; fallback to DMT if unavailable\n");
        timing_support = EDID_USE_GTF;
    }
#if DODEBUG
    if (timing_support == EDID_USE_DMT)
    {
        printf("Use DMT only\n");
    }
    else{
        if ((edidblockref->feature_support & 1) == 1)
        {
            printf("This display supports continuous frequency modes(but we don't use this yet\n");
        }
        else
        {
            printf("This display supports only non-continuous frequency modes - use only the resolutions defined\n");
        }
    }
#endif

#ifdef FORCE_TIMINGS
    /* Now if we have set force_timings as a debug option, override the
     * timing_support setting for testing calculations
     */
    timing_support = FORCE_TIMINGS;
#endif

    /* Next do each of the 2-byte 'standard timings' (Priority 5). */
    /* NB GTF support must be functional for these */
    for (int std_timing_code=0; std_timing_code<8;std_timing_code++)
    {
        if (!((edidblockref->standard_timings[std_timing_code*2] == 0x01) && (edidblockref->standard_timings[std_timing_code*2+1] == 0x01)))
        {
            res = generate_standard_timing(edidblockref->standard_timings[std_timing_code*2], edidblockref->standard_timings[std_timing_code*2+1], new_monitor);
            if (res)
            {
                return res;
            }
        }
    }

    /* Sort the data blocks - store information strings and detailed
     * timing descriptors. Defer CVT codes and Established timings III
     * The first block is the 'preferred timing mode' and has highest
     * priority to go in the MDF. Any other 'detailed timing modes
     * have second priority so they will go in next.
     */
    for (int blockno = 0; blockno < 4; blockno++)
    {
        switch (get_extd_type(edidblockref, blockno))
        {
            case -1: /* Normal descriptor block */
            {
                IFDEBUG printf("Data block\n");
                ModeDescriptionRef mp;
                mp = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
                if (mp == NULL)
                {
                    return error(ERR_NOSPACE, 0, 0, 0);
                }

                if (!dtd_block_to_modedesc((char *) &(edidblockref->data_block[blockno][0]), mp))
                {
                    free(mp);
                }
                else
                {
                    IFDEBUG printf("Detailed Mode: %s, X: %i Y: %i\n", mp->definition.name,mp->definition.xres, mp->definition.yres);
                    if (add_proposed_mode(new_monitor, mp) == 0)
                    {
                        free(mp);
                    }
                    else
                    {
                        /* The first block should define the preferred mode */
                        if (blockno == 0)
                        {
                            new_preferred_mode = mp;
                            mp->priority = 0x01;
                        }
                        else
                        {
                            mp->priority = 0x02;
                        }
                    }
                }

                break;
            }
            case 0xFD: /* Display range limits */
            {
                IFDEBUG printf("Display range limits\n");
                RangeBlock = blockno; /* remember */

                /* Not 100% sure about this but think this is how we pick up CVT-RB support */
                if (timing_support == EDID_USE_CVT)
                {
                    char cvt_blanking = edidblockref->data_block[blockno][15];
                    if ((cvt_blanking & 0x10) == 0x10)
                    {
                        timing_support = EDID_USE_CVTRB;
                    }
                }
                break;
            }
            case 0xFC: /* Model name, will form title of Display menu */
            {
                Get_DTD_ASCII(edidblockref, blockno, new_monitor->name);
                IFDEBUG printf("Model name: %s\n", new_monitor->name);
                break;
            }
            case 0xf7:
            {
                IFDEBUG printf("Established timings III");
                for (int timings_byte=0; timings_byte<6; timings_byte++)
                {
                    for (int timings_bit=0; timings_bit<8; timings_bit++)
                    {
                        if ((edidblockref->data_block[blockno][6+timings_byte] & (1<<(timings_bit%8))) == (1<<(timings_bit%8)))
                        {
                            generate_dmt_mode(established_timings3[(timings_byte * 8) + (7 - timings_bit)],
                                              new_monitor, 6);
                        }
                    }
                }
                break;
            }
            case 0xf8: /* 3-byte CVT timings if found (Priority 4) */
            {
                IFDEBUG printf("CVT 3 Byte timing codes\n");
                for (int cvt_byte = 6;cvt_byte < 18; cvt_byte+=3)
                {
                    if (!((edidblockref->data_block[blockno][cvt_byte] == 0) &&
                          (edidblockref->data_block[blockno][cvt_byte+1] == 0) &&
                          (edidblockref->data_block[blockno][cvt_byte+2] == 0))) {
                        res = generate_cvt3_timing(
                            edidblockref->data_block[blockno][cvt_byte],
                            edidblockref->data_block[blockno][cvt_byte+1],
                            edidblockref->data_block[blockno][cvt_byte+2],
                            new_monitor);
                        if (res)
                        {
                            return res;
                        }
                    }
                }
                break;
            }
#if DODEBUG
            case 0xFF: /* Serial number - not used so only on in debug mode */
            {
                char serial_number[15];

                Get_DTD_ASCII(edidblockref, blockno, serial_number);
                printf("Product serial number %s\n", serial_number);
                break;
            }
            case 0xFB: /* Colour point data */
                printf("Colour point data\n");
                break;
            case 0xFA:
                printf("Standard timing identifications\n");
                break;
            case 0xf9:
                printf("Display colour management(DCM) data\n");
                break;
            case 0x10:
                printf("Empty\n");
                break;
#endif
        }
    }

#if DODEBUG
    printf("Timings bitfield 0 = %02x\n",edidblockref->established_timings[0]);
    printf("Timings bitfield 1 = %02x\n",edidblockref->established_timings[1]);
    printf("Timings bitfield 2 = %02x\n",edidblockref->established_timings[2]);
#endif

    /* Add Established timings I and II  (priority 6) */
    for (int timings_byte=0; timings_byte<2; timings_byte++)
    {
        for (int timings_bit=0; timings_bit<8; timings_bit++)
        {
            if ((edidblockref->established_timings[timings_byte] & (1<<(timings_bit%8))) == (1<<(timings_bit%8)))
            {
                IFDEBUG printf("Timings bitfield byte %d bit %d:\n", timings_byte, timings_bit);
                int dmt_mode = established_timings[(timings_byte * 8)+(7 - timings_bit)];
                if (dmt_mode > 0)
                {
                    generate_dmt_mode(dmt_mode, new_monitor, 6);
                }
                else
                {
                    /* Established timings for 720x400 @@ 70Hz, derived from:
                     * http://www.javiervalcarce.eu/html/vga-signal-format-timming-specs-en.html
                     * http://www.epanorama.net/documents/pc/vga_timing.html
                     */
                    static const ModeDefinition established_timing_7 =
                    {
                        /* 720 x 400 @@ 70Hz */
                        "720 x 400", 720, 400, 108, 54, 0,  720, 0, 18,
                                               2,   34, 0,  400, 0, 13,
                                               28322, -1, NP, 0, 70, 0
                    };
                
                    /* There are 3 cases which do not have defined DMT codes.
                     * These are byte 0 bits 7, 6 and 4 which we will calculate.
                     */
                    int xres = 0;
                    int yres = 0;
                    int freq = 0;
                    switch (timings_bit | (timings_byte << 3))
                    {
                      case 7: /* 720 X 400 @@ 70Hz */
                        /* Use some fixed timings for better compatibility */
                        add_builtin_mode(new_monitor, &established_timing_7, 6);
                        break;
                      case 6: /* 720 X 400 @@ 88Hz */
                        xres = 720;
                        yres = 400;
                        freq = 88;
                        break;
                      case 4: /* 640 X 480 @@ 67Hz */
                        xres = 640;
                        yres = 480;
                        freq = 67;
                        break;
                    }
                
                    if (xres > 0)
                    {
                        ModeDescriptionRef mp;
                        mp = (ModeDescriptionRef) malloc(sizeof(ModeDescription));
                        if (mp == NULL)
                        {
                            return error(ERR_NOSPACE, 0, 0, 0);
                        }
                
                        if ((timing_support == EDID_USE_GTF) ||
                            (timing_support == EDID_USE_GTF2)) {
                            generate_mode_using_gtf(xres, yres, freq, mp, new_monitor);
                        }
                        if ((timing_support == EDID_USE_CVT) ||
                            (timing_support == EDID_USE_CVTRB)) {
                            generate_mode_using_cvt_rb(xres, yres, freq, mp, new_monitor);
                        }
                    }
                }
            }
        }
    }

    /* Now check extension blocks for modes. Detailed timing modes found here have 3rd priority */
    if (edidblockref->extension_block_count > 0)
    {
        IFDEBUG printf("%i Extension block(s) found\n", edidblockref->extension_block_count);

        for (int ext_block_id = 1; ext_block_id <= edidblockref->extension_block_count; ext_block_id++)
        {
            EDIDExtensionBlockRef ext_block = (EDIDExtensionBlockRef)&ediddata[sizeof(EDIDBlock) * ext_block_id];

            /* Different block types to be handled here */

            /* CEA Extension - uses Tag 0x02 */
            if (ext_block->tag == 0x02)
            {
                IFDEBUG printf("Block %i: CEA Extension block found\n", ext_block_id);
                IFDEBUG printf("Version %i\n", ext_block->revision);

                if (ext_block->revision != 0) /* Revision 0 doesn't exist. All othe revisions(including future ones we don't know about) should be at least partially parseable. */
                {
                    res = process_cea_extension(ext_block, new_monitor);
                    if (res)
                    {
                        return res;
                    }
                }
            }

            /* VTB Extension block - Uses Tag 0x10, revision 0x01 */
            if ((ext_block->tag == 0x10) && (ext_block->revision == 0x01))
            {
                res = process_vtb_extension_block(ext_block, new_monitor);
                if (res)
                {
                    return res;
                }
            }
        }
    }

    /* Then sort the modes */
    if (new_monitor->modelist == NULL)
    {
        return semerr0(ERR_NOMODES);
    }
    else
    {
        sort_modelist(&new_monitor->modelist);
    }

    IFDEBUG printf("Modes sorted\n");
    if (file)
    {
        /* open file for new mode file if required */
        /* file is a string terminated in 0x0D */
        char *ptr,*fbuf;
        int length = strcspn(file,"\r");
        fbuf = malloc(length+MAXMONITORNAME+2);
        /* get around the CR terminated file name */
        if (fbuf)
        {
            memcpy(fbuf,file,length);
            fbuf[length] = '.';
            strcpy(fbuf+length+1,new_monitor->name);
            while (ptr=strpbrk(fbuf+length+1," \"#$%&*.:@@\\^|\x7f<>"),ptr)
            {
               *ptr='_';
            }
    
            f = fopen(fbuf,"w");
            free(fbuf);
        }
        if (!f)
        {
            return _kernel_last_oserror();
        }
    }

    if (f)
    {
        fprintf(f,"# Monitor description file for %s\n",new_monitor->name);
        fprintf(f,"# Created by ScrModes %s\n",Module_VersionString);
        fprintf(f,"# (EDID specified modes only, no calculated modes)\n\n");
        fprintf(f,"# Max Viewable H %d cm \n",edidblockref->horizontal_screen_size);
        fprintf(f,"# Max Viewable V %d cm\n",edidblockref->vertical_screen_size);
        if (RangeBlock != -1)
        {
            uint8_t flags = edidblockref->data_block[RangeBlock][4];
            int vmin = 0, vmax = 0, hmin = 0, hmax = 0, pixmax = 0;
            if ((flags & 0x3) == 0x2) { vmax = 255;}
            if ((flags & 0x3) == 0x2) { vmax = 255; vmin = 255;}
            if ((flags & 0xc) == 0x8) { hmax = 255;}
            if ((flags & 0xc) == 0xc) { hmax = 255; hmin = 255;}
            vmin  += edidblockref->data_block[RangeBlock][5];
            vmax  += edidblockref->data_block[RangeBlock][6];
            hmin  += edidblockref->data_block[RangeBlock][7];
            hmax  += edidblockref->data_block[RangeBlock][8];
            pixmax = edidblockref->data_block[RangeBlock][9];
            fprintf(f,"# Line rate:     %2d - %2dkHz\n",hmin,hmax);
            fprintf(f,"# Frame rate:    %2d - %2dHz\n",vmin,vmax);
            fprintf(f,"# Max Dot rate: %3dMHz(rounded down)\n",pixmax*10);
        }
        fprintf(f,"# Uses %s frequency pixel clocks\n", ((edidblockref->feature_support & 1) == 1)?"Continuous":"Specific");
        
        char *rules="unknown";
        switch (timing_support) {
            case EDID_USE_CVT:rules="CVT";break;
            case EDID_USE_DMT:rules="DMT";break;
            case EDID_USE_CVTRB:rules="CVTRB";break;
            case EDID_USE_GTF:rules="GTF";break;
            case EDID_USE_GTF2:rules="GTF2";break;
        }
        fprintf(f,"# Use %s timing rules\n#\n",rules);
        
        fprintf(f,"file_format:1\nmonitor_title:%s\n",new_monitor->name);
        if (new_monitor->dpms_state!=-1)
        {
            fprintf(f,"DPMS_state:%d\n",new_monitor->dpms_state);
        }
        ModeDescriptionRef this = new_monitor->modelist;
        do {
            fprintf(f,"\n# Mode:  %d x %d @@ %dHz",this->definition.xres,this->definition.yres,this->frame_hz);
            fprintf(f,"\n# Bounds: H  %3.2fkHz, V %3.2f, DClock %3.2fMHz",((float)(this->line_hz))/1000.0f,((float)(this->frame_mhz))/1000.0f,((float)(this->definition.pixel_khz))/1000.0f);
            fprintf(f,"\nstartmode");
            fprintf(f,"\n mode_name:%d x %d",this->definition.xres,this->definition.yres);
            fprintf(f,"\n x_res:%d",this->definition.xres);
            fprintf(f,"\n y_res:%d",this->definition.yres);
            fprintf(f,"\n pixel_rate:%d",this->definition.pixel_khz);
            fprintf(f,"\n h_timings:%d,%d,%d,%d,%d,%d",this->definition.hpar[0],this->definition.hpar[1],this->definition.hpar[2],this->definition.hpar[3],this->definition.hpar[4],this->definition.hpar[5]);
            fprintf(f,"\n v_timings:%d,%d,%d,%d,%d,%d",this->definition.vpar[0],this->definition.vpar[1],this->definition.vpar[2],this->definition.vpar[3],this->definition.vpar[4],this->definition.vpar[5]);
            fprintf(f,"\n sync_pol:%d",this->definition.syncpol);
            if (this->definition.interlaced == 1)
            {
              fprintf(f,"\n interlaced");
            }
            fprintf(f,"\nEndMode\n");
            this = this->next;  /* will be NULL at list end*/
        } while (this);
        /* now fo hex dump of EDID block */
        fprintf(f,"# EDID block dump\n#\n");
        for (int i=0; i<(edidblockref->extension_block_count+1)*0x80;i+=16) {
            fprintf(f,"# %02x %02x %02x %02x  %02x %02x %02x %02x",
                    ediddata[i],ediddata[i+1],ediddata[i+2],ediddata[i+3],
                    ediddata[i+4],ediddata[i+5],ediddata[i+6],ediddata[i+7]);
            fprintf(f,"  %02x %02x %02x %02x  %02x %02x %02x %02x\n",
                    ediddata[i+8],ediddata[i+9],ediddata[i+10],ediddata[i+11],
                    ediddata[i+12],ediddata[i+13],ediddata[i+14],ediddata[i+15]);
        }
        fprintf(f,"#\n#End\n");
        fclose(f);
    }
    else
    {
       /* Below taken from the loadmodefile code
        * If we haven't got a file loaded at present, then
        * read current monitortype, to restore on module shutdown
        */
       if (old_monitortype == -1)
       {
           old_monitortype = read_monitortype();
       }

       res = set_monitortype(MONITOR_FILE);
       if (res != NULL)
       {
           _kernel_oserror *res2;
           IFDEBUG printf("setting of monitor type to type `FILE' failed\n");
           res2 = restore_monitortype(); /* restore old value */
           if (res2 != NULL)
           {
               IFDEBUG printf("couldn't reset monitor type to CMOS default!\n");
           }
       }
       else
       {
           _kernel_swi_regs regs;
           release_currentmonitor();
           current_monitor = new_monitor;

           /* Set up the mode specifier */
           if (preferred_mode && new_preferred_mode)
           {
               preferred_mode->bit0 = 1;
               preferred_mode->format = 0;
               preferred_mode->xresol = new_preferred_mode->definition.xres;
               preferred_mode->yresol = new_preferred_mode->definition.yres;
               preferred_mode->depth = 5;
               preferred_mode->framerate = new_preferred_mode->frame_hz;
               preferred_mode->param[0].index = -1;
           }
           else if (preferred_mode)
           {
               preferred_mode->bit0 = 0;
           }

           /* Set the preferred sync type from video input definition bit 3. */
           /* (ref EDID spec table 3.11) */
           if ((edidblockref->video_input_definition & 0x8) == 0x8)
           {
               preferred_sync_type = 0;
           }
           else
           {
               preferred_sync_type = 1;
           }

           IFDEBUG printf("Monitor type changed\n");

           /* Newly defined monitor, announce it */
           regs.r[1] = Service_ModeFileChanged;
           _kernel_swi(OS_ServiceCall, &regs, &regs);
           IFDEBUG printf("Service_ModeFileChanged issued\n");
       }
    }

    return res;
}

static _kernel_oserror *loadedid(const char *file)
{
    _kernel_oserror *res;
    /* Load the EDID data into a data block. */

    /* Disable automatic EDID reading when an EDID file is in use */ 
    EDIDEnabled = 0;

    int file_length, object_found;

    res = _swix(OS_File, _INR(0,1) | _OUT(0) | _OUT(4),
                OSFile_ReadWithTypeNoPath, file, &object_found, &file_length);
    if (!res && (object_found == object_file))
    {
        char *edidblock = (char *) malloc(file_length + 4);

        if (edidblock == NULL)
        {
            return error(ERR_NOSPACE, 0, 0, 0);
        }
        res = _swix(OS_File, _INR(0,3), OSFile_Load, file, edidblock, 0);

        /* Check the block is valid */
        if (!res)
        {
            res = Check_EDID_Checksum((EDIDBlockRef)edidblock, true);
        }
        if (!res)
        {
            res = parseedid(edidblock,NULL);
        }
        free(edidblock);
    }
    return res;
}

static _kernel_oserror *loadmodefile(const char *file)
{
  _kernel_oserror *res;

  res = open_modefile(file);
  if (res != NULL)
  {
      IFDEBUG printf("failed to open modefile\n");
  }
  else
  {
      /* Now need to differentiate if text file or EDID file. */
      /* We do so by looking for the EDID header 0x00ffffffffffff00 */
      int is_edid = 1;
      int c;
      for (int i = 0; i<8;i++)
      {
          c = getc(thefile);
          if (((i == 0) || (i == 7)) && (c != 0x00))
          {
              is_edid = 0;
          }
          if (((i > 0) && (i < 7)) && (c != 0xff))
          {
d358 1
a358 1
          fclose(thefile);
d364 2
a365 2
          rewind(thefile); /* Reset the pointer to the beginning */
          res = loadtextMDF(file);
a370 89
static _kernel_oserror *readedidblock(int displaynum, EDIDBlockRef edidblock, int offset, int count)
{
    _kernel_oserror *res;
    int iic_code = (0xa1 << 16) | (0x80*offset << 0);
    int op_code = (displaynum << 24) | (0 << 16) | (GraphicsV_IICOp << 0);

    res = _swix(OS_CallAVector, _INR(0,2) | _IN(4) | _IN(9) | _OUT(0) | _OUT(4), iic_code, edidblock+offset, 0x80*count, op_code, GraphicsV, &iic_code, &op_code);

    /* If GraphicsV 14 was not claimed, R4 (op_code) should return
     * unchanged in which case we need to alert the user that the
     * hardware doesn't like EDID :-(
     */
    if (iic_code != 0)
    {
        res = error(ERR_IICOPFAIL, 0, 0, 0);
    }

    /* An 'EDID read not supported' error will trump an IIC failure. */
    if (op_code != 0)
    {
        res = error(ERR_CANTREADEDID, 0, 0, 0);
    }
    return res;
}

static _kernel_oserror *readedid(int displaynum, const char *file)
{
    _kernel_oserror *res;
    EDIDBlockRef edidblock = (EDIDBlockRef)malloc(sizeof(EDIDBlock));
    if (edidblock == NULL)
    {
        return error(ERR_NOSPACE, 0, 0, 0);
    }
    IFDEBUG printf("ReadEDID called\n");

    res = readedidblock(displaynum, edidblock, 0, 1);

    /* Check the block is valid */
    if (!res)
    {
        res = Check_EDID_Checksum(edidblock, false);
   }

    /* Now use a separate pointer to the block for extending it and
     * setting up extensions (because if it fails we use the original
     * pointer to free up the memory block and exit).
     */
    char *ediddata = (char *)edidblock;

    /* If it is, resize to accomodate extension blocks */
    if (!res)
    {
        IFDEBUG printf("%i EDID extension blocks found\n", edidblock->extension_block_count);

        if (edidblock->extension_block_count > 0)
        {
            ediddata = realloc(edidblock, sizeof(EDIDBlock) * (edidblock->extension_block_count + 1));
            if (ediddata == NULL)
            {
                res = error(ERR_NOSPACE, 0, 0, 0);
            }
            else
            {
                edidblock = (EDIDBlockRef) ediddata;

                res = readedidblock(displaynum, edidblock, 1, edidblock->extension_block_count);

                /* Check the block is valid */
                if (!res)
                {
                    res = Check_EDID_Checksum(edidblock, true);
                }
            }
        }
    }

    if (!res)
    {
        IFDEBUG printf("Parsing EDID block\n");
        EDIDEnabled = 1;
        /* ERR_NOMODES expects a filename, give it something vaguely sensible */
        thefilename = "(EDID)";
        res = parseedid(ediddata,file);
    }

    free(edidblock);
    return res;
}

@


4.35
log
@Add support for parsing CEA Short Video Descriptors (SVDs). Fix loaded EDID files being overwritten with monitor EDID during Service_DisplayChanged.
Detail:
  h/CEAModes - Table of CEA mode timings from CEA 861-D
  s/ScrModes - Implement process_cea_video_data_block() in order to support SVD parsing. Ensure loadedid() sets the EDIDEnabled flag to 0, to prevent the loaded EDID (potentially) being replaced during Service_DisplayChanged.
Admin:
  Tested on iMx6


Version 0.53. Tagged as 'ScrModes-0_53'
@
text
@d37 3
a41 3
#include "EDIDModes.h"

/* Locally defined but actually global values */
d43 1
d47 1
a47 8

/* By default we only use DMT timings; we will check for additional support later */
static int timing_support = EDID_USE_DMT;

/* If the below flag is set, we can derive monitor definitions from the
 * DMT set using the 3-byte lookup table (defaulted to 'unset')
 */
//#define DERIVE_CVT3_FROM_DMT
d53 6
a58 4
/* switch to define whether EDID is computed, or whether only traditional *
 * loadmodefile activity happens. EDID activity enabled by a ReadEDID     *
 * command, and disabled by a LoadModeFile command                        */
static bool EDIDEnabled;
d60 2
a61 2
/* Uncomment the next line and set the value to force a particular timing calculation type */
//#define FORCE_TIMINGS EDID_USE_CVTRB
d63 5
d69 1
a69 5
/* Uncomment the below to force calculated values (ie. don't prefer DMT) */
//#define FORCE_CALCULATED_VALUES

/*
 * Tweak to force the keyword table to be stored in the code area, by
d95 1
a95 434
#define HSync_Positive 0
#define HSync_Negative SyncPol_InvertHSync
#define VSync_Positive 0
#define VSync_Negative SyncPol_InvertVSync

/* HSync & VSync polarities for use by display_monitor_timings */
#define PP HSync_Positive+VSync_Positive
#define PN HSync_Positive+VSync_Negative
#define NP HSync_Negative+VSync_Positive
#define NN HSync_Negative+VSync_Negative

/* These timings are taken from the Display Monitor Timings v1.0 r11 Spec */

static const ModeDefinition display_monitor_timings[] = {
    /* 640 x 350 @@ 85Hz STD n/a, CVT n/a */
    "640 x 350",    640, 350,   64,  96, 0,  640, 0, 32,
                                 3,  60, 0,  350, 0, 32,
                    31500, -1,  PN,   0, 85,   0,
    /* 640 x 400 @@ 85Hz STD n/a, CVT n/a */
    "640 x 400",    540, 400,   64,  96, 0,  640, 0, 32,
                                 3,  41, 0,  400, 0,  1,
                    31500, -1,  NP,   0, 85,   0,
    /* 720 x 400 @@ 85Hz STD n/a, CVT n/a */
    "720 x 400",    720, 400,   72, 108, 0,  720, 0, 36,
                                 3,  42, 0,  400, 0,  1,
                    35500, -1,  NP,   0, 85,   0,
    /* 640 x 480 @@ 60Hz, STD (31, 40)h, CVT n/a */
    "640 x 480",    640, 480,   96,  40, 8,  640, 8,  8,
                                 2,  25, 8,  480, 8,  2,
                    25175, -1,  NN,   0, 60,   0,
    /* 640 x 480 @@ 72Hz, STD (31, 4C), CVT n/a */
    "640 x 480",    640, 480,   40, 120, 8,  640, 8, 16,
                                 3,  20, 8,  480, 8,  1,
                    31500, -1,  NN,   0, 72,   0,
    /* 640 x 480 @@ 75Hz, STD (31, 4F), non-CVT com */
    "640 x 480",    640, 480,   64, 120, 0,  640, 0, 16,
                                 3,  16, 0,  480, 0,  1,
                    31500, -1,  NN,   0, 75,   0,
    /* 640 x 480 @@ 85Hz, STD (31, 59), non-CVT compliant */
    "640 x 480",    640, 480,   56,  80, 0,  640, 0, 56,
                                 3,  25, 0,  480, 0,  1,
                    36000, -1,  NN,   0, 85,   0,
    /* 800 x 600 @@ 56Hz, STD n/a, CVT n/a */
    "800 x 600",    800, 600,   72, 128, 0,  800, 0, 24,
                                 2,  22, 0,  600, 0,  1,
                    36000, -1,  PP,   0, 56,   0,
    /* 800 x 600 @@ 60Hz, STD (45, 50), CVT n/a */
    "800 x 600",    800, 600,  128,  88, 0,  800, 0, 40,
                                 4,  23, 0,  600, 0,  1,
                    40000, -1,  PP,   0, 60,   0,
    /* 800 x 600 @@ 72Hz, STD (45, 4C), CVT n/a */
    "800 x 600",    800, 600,  120,  64, 0,  800, 0, 56,
                                 6,  23, 0,  600, 0, 37,
                    50000, -1,  PP,   0, 72,   0,
    /* 800 x 600 @@ 75Hz, STD (45, 4F), CVT n/a */
    "800 x 600",    800, 600,   80, 160, 0,  800, 0, 16,
                                 3,  21, 0,  600, 0,  1,
                    49500, -1,  PP,   0, 75,   0,
    /* 800 x 600 @@ 85Hz, STD (45, 59), CVT n/a */
    "800 x 600",    800, 600,   64, 152, 0,  800, 0, 32,
                                 3,  27, 0,  600, 0,  1,
                    56250, -1,  PP,   0, 85,   0,
    /* 800 x 600 @@ 120Hz CVT (RB), STD n/a, CVT n/a */
    "800 x 600",    800, 600,   32,  80, 0,  800, 0, 48,
                                 4,  29, 0,  600, 0,  3,
                    73250, -1,  PN,   0, 120,  0,
    /* 848 x 480 @@ 60Hz, STD n/a, CVT n/a */
    "848 x 480",    848, 480,  112, 112, 0,  848, 0, 16,
                                 8,  23, 0,  480, 0,  6,
                    33750, -1,  PP,   0, 60,   0,
    /* 1024 x 768 @@ 43Hz (I), STD n/a, CVT n/a */
    "1024 x 768",  1024, 768,  176,  56, 0, 1024, 0,  8,
                                 4,  20, 0,  384, 0,  0,
                    44900, -1,  PP,   1, 43,   0,
    /* 1024 x 768 @@ 60Hz, STD (61, 40), CVT n/a */
    "1024 x 768",  1024, 768,  136, 160, 0, 1024, 0, 24,
                                 6,  29, 0,  768, 0,  3,
                    65000, -1,  NN,   0, 60,   0,
    /* 1024 x 768 @@ 70Hz, STD (61, 4A), CVT n/a */
    "1024 x 768",  1024, 768,  136, 144, 0, 1024, 0, 24,
                                 6,  29, 0,  768, 0,  3,
                    75000, -1,  NN,   0, 70,   0,
    /* 1024 x 768 @@ 75Hz, STD (61, 4F), CVT n/a */
    "1024 x 768",  1024, 768,   96, 176, 0, 1024, 0, 16,
                                 3,  28, 0,  768, 0,  1,
                    78750, -1,  PP,   0, 75,   0,
    /* 1024 x 768 @@ 85Hz, STD (61, 59), CVT n/a */
    "1024 x 768",  1024, 768,   96, 208, 0, 1024, 0, 48,
                                 3,  36, 0,  768, 0,  1,
                    94500, -1,  PP,   0, 85,   0,
    /* 1024 x 768 @@ 120Hz CVT (RB), STD n/a, CVT n/a */
    "1024 x 768",  1024, 768,   32,  80, 0, 1024, 0, 48,
                                 4,  38, 0,  768, 0,  3,
                   115500, -1,  PN,   0, 120,  0,
    /* 1152 x 864 @@ 75Hz, STD (71, 4F), CVT n/a */
    "1152 x 864",  1152, 864,  128, 256, 0, 1152, 0, 64,
                                 3,  32, 0,  864, 0,  1,
                   108000, -1,  PP,   0, 75,   0,
    /* 1280 x 768 @@ 60Hz, STD n/a, CVT-RB (7f, 1c, 21) */
    "1280 x 768",  1280, 768,   32,  80, 0, 1280, 0, 48,
                                 7,  12, 0,  768, 0,  3,
                    68250, -1,  PN,   0, 60,   0,
    /* 1280 x 768 @@ 60Hz, STD n/a, CVT (7f, 1c, 28) */
    "1280 x 768",  1280, 768,  128, 192, 0, 1280, 0, 64,
                                 7,  20, 0,  768, 0,  3,
                    79500, -1,  NP,   0, 60,   0,
    /* 1280 x 768 @@ 75Hz, STD n/a, CVT (7f, 1c, 44) */
    "1280 x 768",  1280, 768,  128, 208, 0, 1280, 0, 80,
                                 7,  27, 0,  768, 0,  3,
                   102250, -1,  NP,   0, 75,   0,
    /* 1280 x 768 @@ 85Hz, STD n/a, CVT (7F, 1c, 62) */
    "1280 x 768",  1280, 768,  136, 216, 0, 1280, 0, 80,
                                 7,  31, 0,  768, 0,  3,
                   117500, -1,  NP,   0, 85,   0,
    /* 1280 x 768 @@ 120Hz RB, STD n/a, CVT n/a (non-interlaced) */
    "1280 x 768",  1280, 768,   32,  80, 0, 1280, 0, 48,
                                 7,  35, 0,  768, 0,  3,
                   140250, -1,  PN,   0, 120,  0,
    /* 1280 x 800 @@ 60Hz, STD n/a, CVT-RB (8f, 18, 21) */
    "1280 x 800",  1280, 800,   32,  80, 0, 1280, 0, 48,
                                 6,  14, 0,  800, 0,  3,
                    71000, -1,  PN,   0, 60,   0,
    /* 1280 x 800 @@ 60Hz, STD (81, 00), CVT (8f, 18, 28) */
    "1280 x 800",  1280, 800,  128, 200, 0, 1280, 0, 72,
                                 6,  22, 0,  800, 0,  3,
                    83500, -1,  NP,   0, 60,   0,
    /* 1280 x 800 @@ 75Hz, STD (81, 0f), CVT (8f, 18, 44) */
    "1280 x 800",  1280, 800,  128, 208, 0, 1280, 0, 80,
                                 6,  29, 0,  800, 0,  3,
                   106500, -1,  NP,   0, 75,   0,
    /* 1280 x 800 @@ 85Hz, STD (81, 19), CVT (8f, 18, 62) */
    "1280 x 800",  1280, 800,  136, 216, 0, 1280, 0, 80,
                                 6,  34, 0,  800, 0,  3,
                   122500, -1,  NP,   0, 85,   0,
    /* 1280 x 800 @@ 120Hz RB, STD n/a, CVT n/a (non-interlaced) */
    "1280 x 800",  1280, 800,   32,  80, 0, 1280, 0, 48,
                                 6,  38, 0,  800, 0,  3,
                   146250, -1,  PN,   0, 120,  0,
    /* 1280 x 960 @@ 60Hz, STD (81, 40), CVT n/a */
    "1280 x 960",  1280, 960,  112, 312, 0, 1280, 0, 96,
                                 3,  36, 0,  960, 0,  1,
                   108000, -1,  PP,   0, 60,   0,
    /* 1280 x 960 @@ 85Hz, STD (81, 59), CVT n/a */
    "1280 x 960",  1280, 960,  160, 224, 0, 1280, 0, 64,
                                 3,  47, 0,  960, 0,  1,
                   148500, -1,  PP,   0, 85,   0,
    /* 1280 x 960 @@ 120Hz RB, STD n/a, CVT n/a */
    "1280 x 960",  1280, 960,   32,  80, 0, 1280, 0, 48,
                                 4,  50, 0,  960, 0,  3,
                   175500, -1,  PN,   0, 120,  0,
    /* 1280 x 1024 @@ 60Hz, STD n/a, CVT n/a */
    "1280 x 1024", 1280, 1024, 112, 248, 0, 1280, 0, 48,
                                 3,  38, 0, 1024, 0,  1,
                   108000, -1,  PP,   0, 60,   0,
    /* 1280 x 1024 @@ 75Hz, STD (81, 8f), CFT n/a */
    "1280 x 1024", 1280, 1024, 144, 248, 0, 1280, 0, 16,
                                 3,  38, 0, 1024, 0,  1,
                   135000, -1,  PP,   0, 75,   0,
    /* 1280 x 1024 @@ 85Hz, STD (81, 99), CVT n/a */
    "1280 x 1024", 1280, 1024, 160, 224, 0, 1280, 0, 64,
                                 3,  44, 0, 1024, 0,  1,
                   157500, -1,  PP,   0, 85,   0,
    /* 1280 x 1024 @@ 120Hz (RB), STD n/a, CVT n/a */
    "1280 x 1024", 1280, 1024,  32,  80, 0, 1280, 0, 48,
                                 7,  50, 0, 1024, 0,  3,
                   187250, -1,  PN,   0, 120, 0,
    /* 1360 x 768 @@ 60Hz, STD n/a, CVT n/a */
    "1360 x 768",  1360,  768, 112, 256, 0, 1360, 0, 64,
                                 6,  18, 0,  768, 0,  3,
                    85500, -1,  PP,   0, 60, 0,
    /* 1360 x 768 @@ 120Hz (RB), STD n/a, CVT n/a */
    "1360 x 768",  1360,  768,  32,  80, 0, 1360, 0, 48,
                                 5,  37, 0,  768, 0,  3,
                   148250, -1,  PN,   0, 120, 0,
    /* 1400 x 1050 @@ 60Hz CVT (RB), STD n/a, CVT (0c, 20, 21) */
    "1400 x 1050", 1400, 1050,  32,  80, 0, 1400, 0, 48,
                                 4,  23, 0, 1050, 0,  3,
                   101000, -1,  PN,   0, 60, 0,
    /* 1400 x 1050 @@ 60Hz, STD (90, 40), CVT (0c, 20, 28) */
    "1400 x 1050", 1400, 1050, 144, 232, 0, 1400, 0, 88,
                                 4,  32, 0, 1050, 0, 3,
                   121750, -1,  NP,   0, 60, 0,
    /* 1400 x 1050 @@ 75Hz, STD (90, 4f), CVT (0c, 20, 44) */
    "1400 x 1050", 1400, 1050, 144, 248, 0, 1400, 0, 104,
                                 4,  42, 0, 1050, 0, 3,
                   156000, -1,  NP,   0, 75, 0,
    /* 1400 x 1050 @@ 85Hz, STD (90, 59), CVT (0c, 20, 62) */
    "1400 x 1050", 1400, 1050, 152, 256, 0, 1400, 0, 104,
                                 4,  48, 0, 1050, 0, 3,
                   179500, -1,  NP,   0, 85, 0,
    /* 1400 x 1050 @@ 120Hz CVT (RB), STD n/a, CVT n/a */
    "1400 x 1050", 1400, 1050,  32,  80, 0, 1400, 0, 48,
                                 4,  55, 0, 1050, 0, 3,
                   208000, -1,  PN,   0, 120, 0,
    /* 1440 x 900 @@ 60Hz CVT (RB), STD n/a, CVT (c1, 18, 21) */
    "1440 x 900",  1440,  900,  32,  80, 0, 1440, 0, 48,
                                 6,  17, 0,  900, 0, 3,
                   88750, -1,   PN,   0, 60, 0,
    /* 1440 x 900 @@ 60Hz, STD (95,00), CVT (C1, 18, 28) */
    "1440 x 900",  1440,  900, 152, 232, 0, 1440, 0, 80,
                                 6,  25, 0,  900, 0, 3,
                  106500, -1,   NP,   0, 60, 0,
    /* 1440 x 900 @@ 75Hz, STD (95,0f), CVT (C1, 18, 44) */
    "1440 x 900",  1440,  900, 152, 248, 0, 1440, 0, 96,
                                 6,  33, 0,  900, 0, 3,
                  136750, -1,   NP,   0, 75, 0,
    /* 1440 x 900 @@ 85Hz, STD (95,19), CVT (C1, 18, 68) */
    "1440 x 900",  1440,  900, 152, 256, 0, 1440, 0, 104,
                                 6,  39, 0,  900, 0, 3,
                  157000, -1,   NP,   0, 85, 0,
    /* 1440 x 900 @@ 120Hz RB, STD n/a, CVT n/a, */
    "1440 x 900",  1440,  900,  32,  80, 0, 1440, 0, 48,
                                 6,  44, 0,  900, 0, 3,
                  182750, -1,   PN,   0, 120, 0,
    /* 1600 x 1200 @@ 60Hz, STD (a9, 40), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  162000, -1,   PP,   0, 60, 0,
    /* 1600 x 1200 @@ 65Hz, STD (a9,45), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  175500, -1,   PP,   0, 65, 0,
    /* 1600 x 1200 @@ 70Hz, STD (a9,4a), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  189000, -1,   PP,   0, 70, 0,
    /* 1600 x 1200 @@ 75Hz, STD (a9,4f), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  202500, -1,   PP,   0, 75, 0,
    /* 1600 x 1200 @@ 85Hz, STD (a9,59), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  229500, -1,   PP,   0, 85, 0,
    /* 1600 x 1200 @@ 120Hz, STD n/a, CVT n/a */
    "1600 x 1200", 1600, 1200,  32,  80, 0, 1600, 0, 48,
                                 4,  64, 0, 1200, 0, 3,
                  268250, -1,   PN,   0, 120, 0,
    /* 1680 x 1050 @@ 60Hz CVT (RB), STD n/a, CVT (0c, 28, 21) */
    "1680 x 1050", 1680, 1050,  32,  80, 0, 1680, 0, 48,
                                 6,  21, 0, 1050, 0, 3,
                  119000, -1,   PN,   0, 60, 0,
    /* 1680 x 1050 @@ 60Hz, STD (b3, 00), CVT (0c, 28, 28) */
    "1680 x 1050", 1680, 1050, 176, 280, 0, 1680, 0, 104,
                                 6,  30, 0, 1050, 0, 3,
                  146250, -1,   NP,   0, 60, 0,
    /* 1680 x 1050 @@ 75Hz, STD (b3, 0f), CVT (0c, 28, 44) */
    "1680 x 1050", 1680, 1050, 176, 296, 0, 1680, 0, 120,
                                 6,  40, 0, 1050, 0, 3,
                  187000, -1,   NP,   0, 75, 0,
    /* 1680 x 1050 @@ 85Hz, STD (b3, 19), CVT (0c, 2c, 68) */
    "1680 x 1050", 1680, 1050, 176, 304, 0, 1680, 0, 128,
                                 6,  46, 0, 1050, 0, 3,
                  214750, -1,   NP,   0, 85, 0,
    /* 1680 x 1050 @@ 120Hz CVT-RN. STD n/a, CVT n/a */
    "1680 x 1050", 1680, 1050,  32,  80, 0, 1680, 0, 48,
                                 6,  53, 0, 1050, 0, 3,
                  245500, -1,   PN,   0, 120, 0,
    /* 1792 x 1344 @@ 60Hz, STD (c1, 40), CVT n/a */
    "1792 x 1344", 1792, 1344, 200, 328, 0, 1792, 0, 128,
                                 3,  46, 0, 1344, 0, 1,
                  204750, -1,   NP,   0, 60, 0,
    /* 1792 x 1344 @@ 75Hz, STD (c1, 4f), CVT n/a */
    "1792 x 1344", 1792, 1344, 216, 352, 0, 1792, 0, 96,
                                 3,  69, 0, 1344, 0, 1,
                  261000, -1,   NP,   0, 75, 0,
    /* 1792 x 1344 @@ 120Hz CVT-RB, STD n/a, CVT n/a */
    "1792 x 1344", 1792, 1344,  32,  80, 0, 1792, 0, 48,
                                 4,  72, 0, 1344, 0, 3,
                  333250, -1,   PN,   0, 120, 0,
    /* 1856 x 1392 @@ 60Hz, STD (c9, 40), CVT n/a */
    "1856 x 1392", 1856, 1392, 224, 352, 0, 1856, 0, 96,
                                 3,  43, 0, 1392, 0, 1,
                  218250, -1,   NP,   0, 60, 0,
    /* 1856 x 1392 @@ 75Hz, STD (c9, 4f), CVT n/a */
    "1856 x 1392", 1856, 1392, 224, 352, 0, 1856, 0, 128,
                                 3, 104, 0, 1392, 0, 1,
                  288000, -1,   NP,   0, 75, 0,
    /* 1856 x 1392 @@ 120Hz CVT-RB, STD n/a, CVT n/a */
    "1856 x 1392", 1856, 1392,  32,  80, 0, 1856, 0, 48,
                                 4,  75, 0, 1392, 0, 3,
                  356500, -1,   PN,   0, 120, 0,
    /* 1920 x 1200 @@ 60Hz RB, STD n/a, CVT (57,28,21) */
    "1920 x 1200", 1920, 1200,  32,  80, 0, 1920, 0, 48,
                                 6,  26, 0, 1200, 0, 3,
                  154000, -1,   PN,   0, 60, 0,
    /* 1920 x 1200 @@ 60Hz, STD (d1, 00), CVT (57, 28, 28) */
    "1920 x 1200", 1920, 1200, 200, 336, 0, 1920, 0, 136,
                                 6,  36, 0, 1200, 0, 3,
                  193250, -1,   NP,   0, 60, 0,
    /* 1920 x 1200 @@ 75Hz, STD (d1, 0f), CVT (57, 28, 44) */
    "1920 x 1200", 1920, 1200, 208, 344, 0, 1920, 0, 136,
                                 6,  46, 0, 1200, 0, 3,
                  245250, -1,   NP,   0, 75, 0,
    /* 1920 x 1200 @@ 85Hz, STD (d1, 19), CVT (57, 28, 62) */
    "1920 x 1200", 1920, 1200, 208, 352, 0, 1920, 0, 144,
                                 6,  53, 0, 1200, 0, 3,
                  281250, -1,   NP,   0, 85, 0,
    /* 1920 x 1200 @@ 120Hz CVT-RB, STD n/a, CVT n/a */
    "1920 x 1200", 1920, 1200,  32,  80, 0, 1920, 0, 48,
                                 6,  62, 0, 1200, 0, 3,
                  317000, -1,   PN,   0, 120, 0,
    /* 1920 x 1440 @@ 60Hz, STD (d1, 40), CVT n/a */
    "1920 x 1440", 1920, 1440, 208, 344, 0, 1920, 0, 128,
                                 3,  56, 0, 1440, 0, 1,
                  234000, -1,   NP,   0, 60, 0,
    /* 1920 x 1440 @@ 75Hz, STD (d1, 4f), CVT n/a */
    "1920 x 1440", 1920, 1440, 224, 352, 0, 1920, 0, 144,
                                 3,  56, 0, 1440, 0, 1,
                  297000, -1,   NP,   0, 75, 0,
    /* 1920 x 1440 @@ 120Hz RB, STD n/a, CVT n/a */
    "1920 x 1440", 1920, 1440,  32,  80, 0, 1920, 0, 48,
                                 4,  78, 0, 1440, 0, 3,
                  380500, -1,   PN,   0, 120, 0,
    /* 2560 x 1600 CVT-RB, STD n/a, CVT (1f, 38, 21) */
    "2560 x 1600", 2560, 1600,  32,  80, 0, 2560, 0, 48,
                                 6,  37, 0, 1600, 0, 3,
                  268500, -1,   PN,   0, 60, 0,
    /* 2560 x 1600 @@ 60Hz, STD n/a, CVT (1f, 38, 28) */
    "2560 x 1600", 2560, 1600, 280, 472, 0, 2560, 0, 192,
                                 6,  49, 0, 1600, 0, 3,
                  348500, -1,   NP,   0, 60, 0,
    /* 2560 x 1600 @@ 75Hz, STD n/a, CVT (1f, 38, 44) */
    "2560 x 1600", 2560, 1600, 280, 488, 0, 2560, 0, 208,
                                 6,  63, 0, 1600, 0, 3,
                  443250, -1,   NP,   0, 75, 0,
    /* 2560 x 1600 @@ 85Hz, STD n/a, CVT (1f, 38, 62) */
    "2560 x 1600", 2560, 1600, 280, 488, 0, 2560, 0, 208,
                                 6,  73, 0, 1600, 0, 3,
                  505250, -1,   NP,   0, 85, 0,
    /* 2560 x 1600 @@ 120Hz RB, STD n/a, CVT n/a */
    "2560 x 1600", 2560, 1600,  32,  80, 0, 2560, 0, 48,
                                 6,  85, 0, 1600, 0, 3,
                  552750, -1,   PN,   0, 120, 0
};

/*
 * established timings maps the established timings bitfield onto
 * standard timings defined by the Display Monitor Timings Spec
 * Where there is no timing (0 - yes this /is/ a value on the table
 * but it's not used by the bitfield fortunately) then we use the
 * calculation method preferred by the display.
 */

/*    b7    b6    b5    b4    b3    b2    b1    b0 */
static const char established_timings[] = {
    0x00, 0x00, 0x04, 0x00, 0x05, 0x06, 0x08, 0x09,
    0x0a, 0x0b, 0x00, 0x0f, 0x10, 0x11, 0x12, 0x24
    /* N.B. third byte not checked */
};

static const char established_timings3[] = {
    0x01, 0x02, 0x03, 0x07, 0x0e, 0x0c, 0x13, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x20, 0x21, 0x23, 0x25,
    0x27, 0x2e, 0x2f, 0x30, 0x31, 0x29, 0x2a, 0x2b,
    0x2c, 0x39, 0x3a, 0x3b, 0x3c, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x3e, 0x3f, 0x41, 0x42, 0x44, 0x45,
    0x46, 0x47, 0x49, 0x4a, 0x00, 0x00, 0x00, 0x00
    /* N.B. 7th byte not checked */
};

/*
 * Established timings for 720x400 @@ 70Hz
 * Derived from:
 *
 * http://www.javiervalcarce.eu/html/vga-signal-format-timming-specs-en.html
 * http://www.epanorama.net/documents/pc/vga_timing.html
 *
 */

static const ModeDefinition established_timing_7 =
{
    /* 720 x 400 @@ 70Hz */
    "720 x 400",    720,  400, 108,  54, 0,  720, 0, 18,
                                 2,  34, 0,  400, 0, 13,
                   28322, -1,   NP,   0, 70, 0
};

/* List of standard timings - ie modes who have a defined 2-byte code in the DMT document.
 *
 * NB The third parameter is DMT NUMBER, not ARRAY NUMBER. This is usually
 * array value -1. This is to make cross-checks against the DMT spec easier.
 * We have used 4x3 columns to prevent the source file getting too long.
 * The list should be 0-terminated.
 */
static const STDTiming std_timings[] = {
#ifndef FORCE_CALCULATED_VALUES /* (Removes the table for debugging) */
    0x31, 0x19, 0x2,   0x31, 0x40, 0x4,   0x31, 0x4c, 0x5,   0x31, 0x4f, 0x6,
    0x31, 0x59, 0x7,   0x45, 0x40, 0x9,   0x45, 0x4c, 0xa,   0x45, 0x4f, 0xb,
    0x45, 0x59, 0xc,   0x61, 0x40, 0x10,  0x61, 0x4a, 0x11,  0x61, 0x4f, 0x12,
    0x61, 0x59, 0x13,  0x71, 0x4f, 0x15,  0x81, 0x00, 0x1c,  0x81, 0x0f, 0x1d,
    0x81, 0x19, 0x1e,  0x81, 0x40, 0x20,  0x81, 0x59, 0x21,  0x81, 0x80, 0x23,
    0x81, 0x8f, 0x24,  0x81, 0x99, 0x25,  0x90, 0x40, 0x2a,  0x90, 0x4f, 0x2b,
    0x90, 0x59, 0x2c,  0x95, 0x00, 0x2f,  0x90, 0x0f, 0x30,  0x95, 0x19, 0x31,
    0xa9, 0x40, 0x33,  0xa9, 0x45, 0x34,  0xa9, 0x4a, 0x35,  0xa9, 0x4f, 0x36,
    0xa9, 0x59, 0x37,  0xb3, 0x00, 0x3a,  0xb3, 0x0f, 0x3b,  0xb3, 0x19, 0x3c,
    0xc1, 0x40, 0x3e,  0xc1, 0x4f, 0x3f,  0xc9, 0x40, 0x41,  0xc9, 0x4f, 0x42,
    0xd1, 0x00, 0x45,  0xd1, 0x0f, 0x46,  0xd1, 0x19, 0x47,  0xd1, 0x40, 0x49,
    0xd1, 0x4f, 0x4a,
#endif
    0x00, 0x00, 0
};


/* List of 3-byte CVT timings - ie modes who have a defined 3-byte code in the DMT document.
 *
 * NB The third parameter is DMT NUMBER, not ARRAY NUMBER. This is usually
 * array value -1. This is to make cross-checks against the DMT spec easier.
 * We have used 4x3 columns to prevent the source file getting too long.
 * The list should be 0-terminated.
 */
#ifdef DERIVE_CVT3_FROM_DMT
static const CVTTiming cvt_timings[] = {
#ifndef FORCE_CALCULATED_VALUES /* (Removes the table for debugging) */
    0x7f, 0x1c, 0x21, 0x16,  0x7f, 0x1c, 0x28, 0x17,  0x7f, 0x1c, 0x44, 0x18,
    0x7f, 0x1c, 0x62, 0x19,  0x8f, 0x18, 0x21, 0x1b,  0x8f, 0x18, 0x28, 0x1c,
    0x8f, 0x18, 0x44, 0x1d,  0x8f, 0x18, 0x62, 0x1e,  0x0c, 0x20, 0x21, 0x29,
    0x0c, 0x20, 0x28, 0x2a,  0x0c, 0x20, 0x44, 0x2b,  0x0c, 0x20, 0x62, 0x2c,
    0xc1, 0x18, 0x21, 0x2e,  0xc1, 0x18, 0x28, 0x2f,  0xc1, 0x18, 0x44, 0x30,
    0xc1, 0x18, 0x68, 0x31,  0x0c, 0x28, 0x21, 0x39,  0x0c, 0x28, 0x28, 0x3a,
    0x0c, 0x28, 0x44, 0x3b,  0x0c, 0x28, 0x68, 0x3c,  0x57, 0x28, 0x21, 0x44,
    0x57, 0x28, 0x28, 0x45,  0x57, 0x28, 0x44, 0x46,  0x57, 0x28, 0x62, 0x47,
    0x1f, 0x38, 0x21, 0x4c,  0x1f, 0x38, 0x28, 0x4d,  0x1f, 0x38, 0x44, 0x4e,
    0x1f, 0x38, 0x62, 0x4f,
#endif
    0x00, 0x00, 0x00, 0
};
#endif

/* CEA 861-D mode timings */
#include "CEAModes.h"

/*
 * Must keep this consistent with keywordset above: order has to match
d131 1
a131 9
#if DODEBUG
static int dodebug = 1;
#define debug if (!dodebug) {} else
#else
#define debug if (1) {} else
#endif

/*
 * Pointer to (root block of) current monitor definition structure.
d144 1
a144 2
/*
 * Keep a copy of the current monitor type at the time of the first
d149 1
a149 2
/*
 * Construct an error block from the given ScreenModes module-specific
d158 1
a158 1
static _kernel_oserror *error (int error, const char *arg0, const char *arg1, const char *arg2)
d172 2
a173 1
    if ((res = _kernel_swi (MessageTrans_OpenFile, &r, &r)) != NULL) {
d177 1
a177 1
    sprintf (token, "E%02d", error);
d187 1
a187 1
    res = _kernel_swi (MessageTrans_Lookup, &r, &r);
d190 1
a190 1
    (void)_kernel_swi (MessageTrans_CloseFile, &r, &r);
d192 2
a193 1
    if (res) {
d201 1
a201 1
static void free_monitordescription (MonitorDescriptionRef description)
d209 1
a209 1
        free (td);
d213 1
a213 1
        free (description->audio_formats);
d215 1
a215 1
    free (description);
d218 1
a218 1
static void release_currentmonitor (void)
d222 2
a223 2
        debug printf ("releasing previous monitor description\n");
        free_monitordescription (current_monitor);
d227 1
a227 1
static int matchtext (char *text, const char *ref)
d229 1
a229 1
    while (tolower (*text) == *ref)
d231 2
a232 1
        if (*text == '\0') {
d250 1
a250 1
static _kernel_oserror *open_modefile (const char *filename)
d254 3
a256 2
    FILE *f = fopen (filename, "r");
    if (f != NULL) {
d261 1
a261 1
        res = _kernel_last_oserror ();
d266 4
a269 3
            regs.r[0] = 0x4f;           /* go try opening it */
            regs.r[1] = (int) filename;  regs.r[2] = 0;
            res = _kernel_swi (OS_Find, &regs, &regs);
d272 1
a272 2
                /*
                 * Hmmm, fopen failed but we *can* open it: give up!
d276 4
a279 3
                regs.r[0] = 0;  regs.r[1] = fh;
                (void) _kernel_swi (OS_Find, &regs, &regs);
                res = error (ERR_OPENFAIL, filename, 0, 0);
d292 1
a292 1
static int nextc (void)
d296 1
a296 1
    c = getc (thefile);
d298 2
a299 1
    if (thefile.ptr < thefile.lim) {
d302 2
a303 1
    else {
d307 2
a308 1
    if (c == '\n') {
d314 1
a314 1
static void pushback (int c)
d319 1
a319 1
        ungetc (c, thefile);
d326 2
a327 1
        if (c == '\n') {
d333 1
a333 1
static void close_modefile (void)
d336 1
a336 1
    fclose (thefile);
d338 1
a338 1
    free (thefile.base);
d342 1
a342 1
static _kernel_oserror *synerr0 (int code)
d345 2
a346 2
    sprintf (linebuff, "%u", lineno);
    return error (code, thefilename, linebuff, 0);
d349 1
a349 1
static _kernel_oserror *synerrC (int errcode, int thechar)
d352 1
a352 1
    sprintf (linebuff, "%u", lineno);
d354 1
a354 1
    return error (errcode, thefilename, linebuff, charbuff);
d357 1
a357 1
static _kernel_oserror *synerrK (int errcode, enum keycode keycode)
d360 2
a361 2
    sprintf (linebuff, "%u", lineno);
    return error (errcode, thefilename, linebuff, keyword(keycode));
d364 1
a364 2
/*
 * Semantic errors are not directly associated with a single line, so
d368 1
a368 1
static _kernel_oserror *semerr0 (int code)
d370 1
a370 1
    return error (code, thefilename, 0, 0);
d373 1
a373 1
static _kernel_oserror *semerrS (int code, char *thestring)
d375 1
a375 1
    return error (code, thefilename, thestring, 0);
d378 1
a378 1
static int skip_space (void)
d381 1
a381 1
    while ((c = nextc()) != '\n' && isspace (c))
d386 1
a386 1
static int skip_comment_or_blank (void)
d389 1
a389 1
    while ((c = skip_space ()) == '\n' || c == '#')
d399 1
a399 1
                c = nextc ();
d407 1
a407 1
static enum keycode read_keyword (void)
d413 1
a413 1
    c = skip_comment_or_blank ();
d415 2
a416 1
    if (c == EOF) {
d419 1
a419 1
    while (isalpha (c) || c == '_')
d421 1
a421 1
        if (i < MAXKEYWORDLEN+1)        /* allow one extra char, to catch junk at end */
d423 1
d426 1
a426 1
        c = nextc ();
d428 1
a428 1
    pushback (c);                       /* backstep over terminating char */
d431 1
a431 1
    while (k < k_nokey && !matchtext (buff, keyword(k)))
d436 1
a436 1
static _kernel_oserror *skip_char (int ch)
d439 1
a439 1
    while ((c = nextc ()) != '\n' && isspace (c))
d441 2
a442 1
    if (c == ch) {
d445 3
a447 2
    if (c == EOF) {
        return synerr0 (ERR_EOF);
d449 2
a450 2
    pushback (c);                       /* in case of '\n', to get lineno right */
    return synerrC (ERR_EXPCHAR, ch);
d453 1
a453 1
static _kernel_oserror *check_eol (int eofok)
d455 3
a457 2
    int c = skip_space ();
    if (c == '\n' || (eofok && c == EOF)) {
d460 3
a462 2
    if (c == EOF) {
        return synerr0 (ERR_EOF);
d464 1
a464 1
    return synerr0 (ERR_EXTRAINPUT);
d467 1
a467 2
/*
 * Read text (starting with the next non-space character) up to the
d475 1
a475 1
static _kernel_oserror *read_text (char *buff, int size, int blankerror)
d480 2
a481 2
    c = skip_space ();
    if (c == '\n' && blankerror != -1)  /* blank field - complain if necessary */
d483 3
a485 2
        pushback (c);                   /* to get line number correct! */
        return synerr0 (blankerror);
d489 2
a490 1
        if (i < size-1) {
d499 4
a502 3
                debug
                    if (excess == 1) {
                        printf ("excess chars ignored on text at line %d\n", lineno);
d504 1
d507 1
a507 1
        c = nextc ();
d509 3
a511 2
    if (c == EOF) {
        return synerr0 (ERR_EOF);       /* EOF not allowed */
d514 1
a514 1
    while (i > 0 && isspace (buff[i-1]))
d521 1
a521 1
static _kernel_oserror *read_u32 (uint32_t *var)
d525 4
a528 3
    c = skip_space ();
    if (!isdigit (c)) {
        return synerr0 (ERR_EXPNUM);
d531 1
a531 1
    while (isdigit (c = nextc()))
d536 2
a537 2
            return synerr0 (ERR_VALUEOVF);
            }
d540 1
a540 1
    pushback (c);                       /* leave terminating char waiting to be read */
d545 1
a545 1
static _kernel_oserror *read_one_u32 (uint32_t *var, uint32_t fault_zero)
d547 3
a549 2
    _kernel_oserror *res = read_u32 (var);
    if (res) {
d552 3
a554 2
    if (fault_zero && *var == 0) {
        return synerr0 (ERR_INVALIDPAR);
d556 1
a556 1
    return check_eol (0);
d559 1
a559 1
static _kernel_oserror *check_keyword (enum keycode code, int colon)
d562 5
a566 3
    kc = read_keyword ();
    if (kc == k_eof)                    /* we never explicitly look for k_eof */ {
        return synerr0 (ERR_EOF);
d568 3
a570 2
    if (kc != code) {
        return synerrK (ERR_EXPKEY, code);
d572 3
a574 2
    if (colon) {
        return skip_char (':');
d576 2
a577 1
    else {
d582 1
a582 1
static _kernel_oserror *parse_mode (ModeDefinition *mode)
d591 1
a591 1
        enum keycode kc = read_keyword ();
d596 3
a598 2
            if (keyseen & (1 << kc)) {
                return synerrK (ERR_REPKEY, kc);
d600 3
a602 2
            res = skip_char (':');
            if (res) {
d610 1
a610 1
            return synerr0 (ERR_EOF);
d614 1
a614 1
            assert (last_mode_key <= 31);
d617 1
a617 2
            /*
             * In format 1, we normally insist that x_res = hdisp and
d626 1
a626 2
                /*
                 * If some other keyword(s) not seen, complain.  If
d632 3
a634 2
                if (missed & (1 << k_mode_name)) {
                    return synerr0 (ERR_NOMODENAME);
d636 3
a638 2
                else {
                    return semerrS (ERR_INCOMPLETE, mode->name);
d642 2
a643 1
            if (!(keyseen & (1 << k_x_res))) {
d646 2
a647 1
            if (!(keyseen & (1 << k_y_res))) {
d652 4
a655 2
            if (mode->xres != mode->hpar[FR_DISP] || mode->yres != mode->vpar[FR_DISP] * (mode->interlaced+1)) {
                return semerrS (ERR_INCONSISTENT, mode->name);
d657 1
a657 1
            return check_eol (1);
d660 1
a660 1
            return synerr0 (ERR_UNKNOWNPAR);
d664 1
a664 1
            return synerrK (ERR_WRONGCONTEXT, kc);
d667 3
a669 2
            res = read_one_u32 (&mode->xres, 1);
            if (res) {
d675 3
a677 2
            res = read_one_u32 (&mode->yres, 1);
            if (res) {
d683 3
a685 2
            res = read_one_u32 (&mode->pixel_khz, 1);
            if (res) {
d691 3
a693 2
            res = read_one_u32 (&param, 0);
            if (res) {
d696 3
a698 2
            if (param > 3) { /* must fit in (currently) 2 bits */
                return synerr0 (ERR_VALUEOVF);
d705 3
a707 2
            res = check_eol (0);
            if (res) {
d713 3
a715 2
            res = read_one_u32 (&mode->external_clock, 0);
            if (res) {
d726 3
a728 2
            res = read_text (mode->name, sizeof(mode->name), -1);
            if (res) {
d741 3
a743 2
                    res = read_u32 (&param);
                    if (res) {
d746 3
a748 2
                    if (param >= 0x10000) {    /* must fit in 16 bits (unsigned) */
                        return synerr0 (ERR_VALUEOVF);
d752 3
a754 2
                    if (pn < FR__COUNT-1) {
                        res = skip_char (',');
d757 3
a759 2
                if (par[FR_DISP] == 0) {
                    return synerr0 (ERR_INVALIDPAR);
d762 3
a764 2
                res = check_eol (0);
                if (res) {
d773 1
a773 1
static void compute_modedescription (ModeDescriptionRef md)
d785 3
a787 2
    if (mp->interlaced) {
      md->frame_mhz /= 2; /* if interlaced, one frame is 2 fields */
d792 1
a792 1
static _kernel_oserror *parse_modelist (MonitorDescriptionRef monitor, enum keycode kc)
d803 3
a805 2
            res = check_eol (0);
            if (res) {
d808 4
a811 3
            mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
            if (mp == NULL) {
                return error (ERR_NOSPACE, 0, 0, 0);
d813 1
a813 2
            /*
             * Chain the new (as yet un-filled-in) mode on as the head
d820 3
a822 2
            res = parse_mode (&mp->definition);
            if (res) {
d826 2
a827 1
            if (mp->definition.external_clock == -1) {
d831 1
a831 1
            compute_modedescription (mp);
d837 3
a839 2
                if (strcmp (rp->definition.name, mp->definition.name) == 0) {
                    return semerrS (ERR_DUPMODENAME, mp->definition.name);
d848 2
a849 1
            if (monitor->modelist != NULL) {
d852 1
a852 1
            return semerr0 (ERR_NOMODES);
d856 1
a856 1
            return synerrK (ERR_EXPKEY, k_startmode);
d858 1
a858 1
        kc = read_keyword ();               /* read next startmode, hopefully */
d862 1
a862 1
static _kernel_oserror *parse_modefile (MonitorDescriptionRef *description)
d869 3
a871 2
    res = check_keyword (k_file_format, 1);
    if (res) {
d874 3
a876 2
    res = read_one_u32 (&ffmt, 0);
    if (res) {
d879 3
a881 2
    if (ffmt != 1) {
        return synerr0 (ERR_UNKNOWNFMT);
d884 3
a886 2
    res = check_keyword (k_monitor_title, 1);
    if (res) {
d890 4
a893 3
    md = (MonitorDescriptionRef) malloc (sizeof(MonitorDescription));
    if (md == NULL) {
        return error (ERR_NOSPACE, 0, 0, 0);
d895 1
a895 2
    /*
     * From here on, need to release memory on error, so do most of
d900 1
a900 1
    res = read_text (md->name, sizeof(md->name), ERR_BLANKMONTITLE);
d902 3
a904 4
    /*
     * Now check for optional DPMS_state keyword
     */
    if (res == NULL) {
d906 1
a906 1
        kc = read_keyword ();
d909 1
a909 1
            res = skip_char (':');
d912 1
a912 1
                res = read_one_u32 (&md->dpms_state, 0);       /* read DPMS_state value */
d916 1
a916 1
                kc = read_keyword ();                          /* then read next keyword */
d921 3
a923 4
    /*
     * Now check for optional LCD_support keyword
     */
    if (res == NULL) {
d927 7
a933 5
            debug printf("Got the lcdsupport keyword\n");
            res = skip_char (':');
            if (res == NULL) {
                res = read_one_u32 (&md->lcd_support, 0);      /* read LCD_support value */
                if (md->lcd_support != 0) {
d936 1
a936 1
                debug printf("Read the value as %d\n",md->lcd_support);
d938 3
a940 2
            if (res == NULL) {
              kc = read_keyword ();                            /* then read next keyword */
d945 3
a947 4
    /*
     * Now check for optional output_format keyword
     */
    if (res == NULL) {
d951 4
a954 3
            res = skip_char (':');
            if (res == NULL) {
                res = read_one_u32 (&md->output_format, 0);    /* read output_format value */
d956 3
a958 2
            if (res == NULL) {
                kc = read_keyword ();                          /* then read next keyword */
d963 3
a965 4
    /*
     * Now check for optional external_clock keyword
     */
    if (res == NULL) {
d969 4
a972 3
            res = skip_char (':');
            if (res == NULL) {
                res = read_one_u32 (&md->external_clock, 0);   /* read external_clock value */
d974 3
a976 2
            if (res == NULL) {
                kc = read_keyword ();                          /* then read next keyword */
d981 4
a984 3
    if (res == NULL) {
        debug printf("Going to read the modes now...\n");
        res = parse_modelist (md, kc);                         /* pass in read keyword token */
d987 3
a989 2
    if (res) {
        free_monitordescription (md);
d996 1
a996 2
/*
 * For efficiency in handling the Service_ModeExtension service call,
d1004 1
a1004 1
static int modes_inorder (ModeDescriptionRef m1, ModeDescriptionRef m2)
d1006 2
a1007 1
    if (m1->definition.xres < m2->definition.xres) {
d1010 2
a1011 1
    if (m1->definition.xres > m2->definition.xres) {
d1014 2
a1015 1
    if (m1->definition.yres < m2->definition.yres) {
d1018 2
a1019 1
    if (m1->definition.yres > m2->definition.yres) {
d1022 2
a1023 1
    if (m1->frame_mhz > m2->frame_mhz) {
d1026 2
a1027 1
    if (m1->frame_mhz < m2->frame_mhz) {
d1030 2
a1031 1
    if (m1->definition.pixel_khz < m2->definition.pixel_khz) {
d1034 2
a1035 1
    if (m1->definition.pixel_khz > m2->definition.pixel_khz) {
d1041 1
a1041 1
static void sort_modelist (ModeDescriptionRef *list)
d1051 4
a1054 2
        while (next) {
            if (!modes_inorder (this, next)) {
d1057 2
a1058 1
                if (prev == NULL) {
d1061 2
a1062 1
                else {
d1081 1
a1081 1
static _kernel_oserror *set_monitortype (int monitortype)
d1086 1
a1086 1
    return _kernel_swi (OS_ScreenMode, &regs, &regs);
d1089 1
a1089 1
static int read_monitortype (void)
d1094 4
a1097 3
    res = _kernel_swi (OS_ReadSysInfo, &regs, &regs);
    if (res) {
      return -1;
d1099 3
a1101 2
    else {
      return regs.r[1];
d1105 1
a1105 1
static _kernel_oserror *restore_monitortype (void)
d1108 2
a1109 1
    if (temp != -1) {
d1111 1
a1111 4
        return set_monitortype (temp);
    }
    else {
        return NULL;
d1113 1
d1117 1
a1117 1
static void show_monitor (MonitorDescriptionRef monitor)
d1120 1
a1120 1
    printf ("Monitor title: \"%s\"\n", monitor->name);
d1127 16
a1142 15
        printf ("  Mode name \"%s\"\n", mode->definition.name);
        printf ("  Resolution %u x %u\n", dp->xres, dp->yres);
        printf ("  Line rate %u.%03u kHz, Frame rate %d.%03d Hz\n",
                mode->line_hz / 1000, mode->line_hz % 1000,
                mode->frame_mhz / 1000, mode->frame_mhz % 1000);
        printf ("  Pixel rate %u kHz, Sync type %u\n", dp->pixel_khz, dp->syncpol);
        printf ("  Line timings\n"
                "    sync %u b-porch %u l-border %u display %u r-border %u f-porch %u\n",
                dp->hpar[FR_SYNC], dp->hpar[FR_BPCH], dp->hpar[FR_BDR1],
                dp->hpar[FR_DISP], dp->hpar[FR_BDR2], dp->hpar[FR_FPCH]);
        printf ("  Frame timings\n"
                "    sync %u b-porch %u t-border %u display %u b-border %u f-porch %u\n",
                dp->vpar[FR_SYNC], dp->vpar[FR_BPCH], dp->vpar[FR_BDR1],
                dp->vpar[FR_DISP], dp->vpar[FR_BDR2], dp->vpar[FR_FPCH]);
        if (dp->interlaced) {
d1148 2
a1149 1
            if (bits < 8) {
d1155 2
a1156 1
            else {
d1161 1
a1161 1
            printf ("  %2u bpp: bandwidth %6u000 bytes/sec, data size %7u bytes\n", bits, drate, dsize);
d1163 1
a1163 1
        printf ("\n");
d1168 1
a1168 1
static _kernel_oserror *loadtextMDF (const char *file)
d1171 2
a1172 2
        MonitorDescriptionRef new_monitor;
        EDIDEnabled = 0;   /* disable any automatic edid stuff */
d1174 21
a1194 6
        debug printf ("file opened OK\n");
        res = parse_modefile (&new_monitor);
        debug printf ("closing file\n");
        close_modefile ();
        if (res != NULL) {
            debug printf ("failed to parse mode file\n");
d1196 4
a1199 1
        else
d1201 3
a1203 2
            debug printf ("monitor description parsed OK\n");
            sort_modelist (&new_monitor->modelist);
d1205 3
a1207 7
            debug show_monitor (new_monitor);
#endif
            /* If we haven't got a file loaded at present, then
             * read current monitortype, to restore on module shutdown
             */
            if (old_monitortype == -1) {
                old_monitortype = read_monitortype ();
d1209 6
d1216 11
a1226 10
            /* Now tell kernel to use monitor type 7 (File) */
            res = set_monitortype (MONITOR_FILE);
            if (res != NULL)
            {
                _kernel_oserror *res2;
                debug printf ("setting of monitor type to type `FILE' failed\n");
                res2 = restore_monitortype (); /* restore old value */
                debug
                if (res2 != NULL) {
                    printf ("couldn't reset monitor type to CMOS default!\n");
d1228 3
a1231 19
            else
            {
                char *path, *dot;
                _kernel_swi_regs regs;

                path = malloc((size_t)strlen(file)+32);
                if (path != NULL) {
                    /* Allow the MDF to come with an accompanying sprite */
                    strcpy(path,"IconSprites ");
                    dot = strrchr(file, '.');
                    if (dot != NULL) {
                        strcat(path, file);    /* Grab the path */
                        dot = 1 + strrchr(path, '.');
                        *dot = '\0';           /* Slice off the leafname */
                    }
                    strcat(path, "!Sprites");
                    _kernel_oscli(path);
                    free(path);
                }
d1233 8
a1240 9
                release_currentmonitor ();
                current_monitor = new_monitor;
                /* Forget any old preferred mode */
                preferred_mode->bit0 = 0;

                /* Newly defined monitor, announce it */
                regs.r[1] = Service_ModeFileChanged;
                _kernel_swi (OS_ServiceCall, &regs, &regs);
            }
d1242 1
d1247 1
a1247 1
/* display_mode_parameters produces debug output showing the
d1252 26
a1277 24
  printf("XRes: %i YRes: %i ",
              mode_desc->definition.xres,
              mode_desc->definition.yres);
  if (mode_desc->definition.interlaced == 1) {
    printf("(interlaced)");
  }
  else {
    printf("(non-interlaced)");
  }

  printf(" PixRate: %i\nHSync:%i Hbpch:%i Hlbdr:%i Hdisp:%i Hrbdr:%i Hfpch:%i\nVSync:%i Vbpch:%i Vtbdr:%i Vdispl:%i Vbbdr:%i Vfpch:%i\n\n",
         mode_desc->definition.pixel_khz,
         mode_desc->definition.hpar[FR_SYNC],
         mode_desc->definition.hpar[FR_BPCH],
         mode_desc->definition.hpar[FR_BDR1],
         mode_desc->definition.hpar[FR_DISP],
         mode_desc->definition.hpar[FR_BDR2],
         mode_desc->definition.hpar[FR_FPCH],
         mode_desc->definition.vpar[FR_SYNC],
         mode_desc->definition.vpar[FR_BPCH],
         mode_desc->definition.vpar[FR_BDR1],
         mode_desc->definition.vpar[FR_DISP],
         mode_desc->definition.vpar[FR_BDR2],
         mode_desc->definition.vpar[FR_FPCH]);
d1281 3
a1283 5

/*
 *  add_proposed_modes checks if a new mode is present already.
 *  If it has, we won't be adding it to the chain.
 *  Return 1 if successful, and 0 if we have rejected it for any reason
d1287 3
a1289 4

   proposed_mode->next = monitor_definition->modelist;
   monitor_definition->modelist = proposed_mode;
   return 1;
a1291 1

d1296 4
a1299 3
    ModeDescriptionRef mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
    if (mode_desc == NULL) {
        return error (ERR_NOSPACE, 0, 0, 0);
d1307 4
a1310 3
    if (add_proposed_mode(monitor, mode_desc) == 0) {
      free(mode_desc);
      return NULL;
a1315 1

d1332 1
a1333 4
        #if DODEBUG
        printf("Established Modes Display Monitor Timing :\n");
        #endif
        
d1339 1
a1339 1
        printf("Ignoring established timing (not a standard mode).\n\n");
d1346 1
a1346 3
#define EDID_Check_BaseOnly 0
#define EDID_Check_AllBlocks 1
static _kernel_oserror *Check_EDID_Checksum(char *EDIDData, char check_type)
d1349 1
d1351 5
a1355 9
    char blocks_to_check = 0;
    char count = 0;

    EDIDBlockRef edidblock = (EDIDBlockRef) EDIDData;

    for (int block = 0; block <= blocks_to_check; block++) {
        count = 0;
        for (int byte = 0; byte < 128; byte++) {
            count = count + EDIDData[(block * 128) + byte];
d1357 2
a1358 1
        if (count != 0) {
d1361 3
a1363 3
            sprintf (linebuff1, "%u", block);
            sprintf (linebuff2, "%u", blocks_to_check);
            res = error (ERR_BADCHECKSUM, linebuff1, linebuff2, 0);
d1367 2
a1368 1
            if ((block == 0) && (check_type == EDID_Check_AllBlocks)) {
d1371 1
a1371 4
#if DODEBUG
            /* For debug we confirm each block is OK as well as failed */
            printf("Checksum: Block %i of %i OK\n", block, blocks_to_check);
#endif
d1380 1
a1380 1
 * Buffer must be at least 14 bytes in length
a1381 1

d1414 1
a1414 1
    const double min_vsync_and_bp = 550; /* The minimum time of vertical sync and back porch interval (us) */
d1427 5
a1431 4
    /* If interlaced, the number of vertical lines assumed by the */
    /* calculation must be halved, as the computation calculates the */
    /* number of vertical lines per field. In either case, the number */
    /* of lines is rounded down to the nearest integer. */
d1492 2
a1493 1
    if (int_rqd == 1) {
d1518 1
a1518 3
    /*
     * From GTF spec - Using Stage 1 parameters to derive stage 2 parameters
     */
d1522 2
a1523 1
    if (int_rqd == 1) {
d1526 2
a1527 1
    else {
d1533 2
a1534 1
    if (int_rqd == 1) {
d1562 2
a1563 1
    if (int_rqd) {
d1575 2
a1576 1
    if (timing_support == EDID_USE_GTF) {
d1588 3
a1590 2
    if (add_proposed_mode(monitor, mode_desc) == 0) {
      free(mode_desc);
a1591 1

d1594 1
a1594 1
#endif
d1601 1
a1601 1
    const double margin_per = 0; /* Percentage size of margin (0 to 100) if reqd */
d1607 5
a1611 4
    /* Determine the aspect ratio and set the v_sync_rnd variable */
    /* This is a slightly messy lookup table - VESA recommends the lookup */
    /* approach. We match on X, but in some cases we need to also check Y if */
    /* there are other modes with different heights */
d1627 3
a1629 2
    if ((h_pixels == 1280) && ((v_lines == 1024) || (v_lines == 768))) {
      v_sync_rnd = 7;
d1647 2
a1648 1
    if ((int) (h_pixels / v_lines * 10) == 16) {
d1652 6
a1657 7
    if (v_sync_rnd == 0) {
#if DODEBUG
      printf("Error - Cannot handle this aspect ratio\n");
#endif
      /* If this happens we should just ignore the mode */
      free(mode_desc);
      return;
d1661 3
a1663 3
     *  Standard. I've kept this code as close to the original as possible for
     *  clarity at the cost of some speed. When this works 110%, this can be
     *  optimised out.
d1668 5
a1672 5
    /* If interlaced, the number of vertical lines assumed by the */
    /* calculation must be halved, as the computation calculates the */
    /* number of vertical lines per field. In either case, the number */
    /* of lines is rounded down to the nearest integer. */

d1706 3
a1708 2
    /* The total number of active pixels is equal to the rounded */
    /* horizontal pixels and the margins: */
d1726 3
a1728 2
    /* V front porch (NB in CVT this is min_v_porch_rnd and in CVT-RB this is */
    /* rb_v_fporch but as they are both constants declare them. */
d1734 1
a1734 1
        /* Minimum timng for vertical blanking for 'CRT' timings */
d1742 2
a1743 1
        if (v_sync_bp < v_sync_rnd + min_v_bporch) {
d1762 3
a1764 2
        /* Find the number of pixels in the horizontal blanking time to the nearest double character cell */
        /* (limit horizontal blanking so that it is >= 20% of the horizontal total). */
d1788 2
a1789 1
        if (int_rqd == 1) {
d1793 3
a1795 2
        /* H sync per is the percentage of horizontal total period that */
        /* defines horizontal sync width */
d1805 1
a1805 1
        /* Estimate the horizontal period (kHZ) */
d1817 3
a1819 2
        if (vbi_lines < rb_min_vbi) {
          act_vbi_lines = rb_min_vbi;
d1821 3
a1823 2
        else {
          act_vbi_lines = vbi_lines;
d1859 2
a1860 1
    if (int_rqd) {
d1871 2
a1872 1
    if (timing_support == EDID_USE_CVT) {
d1875 1
a1875 1
    else /* EDID_USE_CVTRB */
d1877 1
d1885 3
a1887 2
    if (add_proposed_mode(monitor, mode_desc) == 0) {
      free(mode_desc);
a1888 1

d1891 1
a1891 1
#endif
d1897 3
a1899 2
    /* If this mode is defined as a DMT standard, use this by checking the */
    /* bytes directly with the lookup table */
d1902 1
a1902 3
#if DODEBUG
    printf("Standard Timing (%x %x) ", std1, std2);
#endif
d1906 6
a1911 5
        if ((std1 == std_timings[i].stdcode[0]) && (std2 == std_timings[i].stdcode[1]))
        {
            mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
            if (mode_desc == NULL) {
                return error (ERR_NOSPACE, 0, 0, 0);
d1923 3
a1925 2
            if (add_proposed_mode(monitor, mode_desc) == 0) {
              free(mode_desc);
d1938 15
a1952 11
        if (pixel_ratio_flags == 0) { /* 00 = 16:10 */
          yres = (int) ((xres * 10) / 16);
        }
        if (pixel_ratio_flags == (1<<6)) { /* 01 = 4:3 */
          yres = (int) ((xres * 3) / 4);
        }
        if (pixel_ratio_flags == (1<<7)) { /* 10 = 5:4 */
          yres = (int) ((xres * 4) / 5);
        }
        if (pixel_ratio_flags == ((1<<7) + (1<<6))) { /* 11 = 16:9 */
          yres = (int) ((xres * 9) / 16);
d1957 4
a1960 3
        mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mode_desc == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
d1962 1
a1962 3
#if DODEBUG
        printf("(calculated):\n");
#endif
d1965 1
a1965 2
            (timing_support == EDID_USE_GTF2))
        {
d1969 1
a1969 2
            (timing_support == EDID_USE_CVTRB))
        {
d1977 2
a1978 4

/*
 *  Generates a mode from a 3-byte CVT code
 *  NB this is UNTESTED as I haven't got an appropriate EDID to test from
d1983 4
a1986 6
    /* If this mode is defined as a DMT standard, use this by checking the */
    /* bytes directly with the lookup table */

#if DODEBUG
    printf("CVT 3-byte Timing (%x %x %x) ", cvt1, cvt2, cvt3);
#endif
d1989 4
a1992 5
    if ((cvt2 & 0x03) != 0) {
#if DODEBUG
      printf("has unknown values in the reserved bits of byte 2 - skipped.\n");
#endif
      return NULL;
d2001 4
a2004 3
            mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
            if (mode_desc == NULL) {
                return error (ERR_NOSPACE, 0, 0, 0);
d2015 3
a2017 3

            if (add_proposed_mode(monitor, mode_desc) == 0) {
              free(mode_desc);
d2035 2
a2036 1
         * Per the EDID guidance (p48). */
d2040 12
a2051 12
          case 0:
            xres = (int) (8 * floor((((double) yres * 4) / 3) / 8));
            break;
          case 1:
            xres = (int) (8 * floor((((double) yres * 16) / 9) / 8));
            break;
          case 2:
            xres = (int) (8 * floor((((double) yres * 16) / 10) / 8));
            break;
          case 3:
            xres = (int) (8 * floor((((double) yres * 15) / 9) / 8));
            break;
d2055 2
a2056 1
         * (bits 5 and 6 of cvt3) */
d2059 12
a2070 12
          case 0:
            freq = 50;
            break;
          case 1:
            freq = 60;
            break;
          case 2:
            freq = 75;
            break;
          case 3:
            freq = 85;
            break;
d2074 11
a2084 11
          mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
          if (mode_desc == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
          }
#if DODEBUG
          printf("\nAt %x Hz (calculated):\n", freq);
#endif
          generate_mode_using_cvt_rb(xres, yres, freq, mode_desc, monitor);
          if (add_proposed_mode(monitor, mode_desc) == 0) {
            free(mode_desc);
          }
d2091 2
a2092 1
         * CVT calculations and restore it at the end */
d2095 1
a2095 1
        for(int supported_freq=0; supported_freq<5; supported_freq++)
d2097 1
a2097 3
          if ((cvt3 & (1<<supported_freq)) == (1<<supported_freq))
          {
            switch (supported_freq)
d2099 33
a2131 30
              case 0:
                freq = 60;
                timing_support = EDID_USE_CVTRB;
              case 1:
                freq = 85;
                timing_support = EDID_USE_CVT;
              case 2:
                freq = 75;
                timing_support = EDID_USE_CVT;
              case 3:
                freq = 60;
                timing_support = EDID_USE_CVT;
              case 4:
                freq = 50;
                timing_support = EDID_USE_CVT;
            }

            if (freq != preferred_freq)
            {
              mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
              if (mode_desc == NULL) {
                return error (ERR_NOSPACE, 0, 0, 0);
              }
#if DODEBUG
              printf("\nAt %x Hz (calculated):\n", freq);
#endif
              generate_mode_using_cvt_rb(xres, yres, freq, mode_desc, monitor);
              if (add_proposed_mode(monitor, mode_desc) == 0) {
                free(mode_desc);
              }
a2132 1
          }
a2134 1

d2139 5
a2143 6

/*  dtd_block_to_modedesc converts a detailed timing descriptor block
 *  into a mode descriptor block. The defines above help it pick out
 *  the data which is split across nibbles into the parameters.
 *  dtd_data on entry should be a pointer to the first byte of the 18 byte
 *  dtd block.
d2147 1
a2147 3
#if DODEBUG
    printf("Detailed timing descriptor:\n");
#endif
d2182 3
a2184 4
    if ((dtd_data[17] & 0x60) != 0x00) {
#if DODEBUG
        printf("Rejecting DTD due to unsupported frame format\n");
#endif
d2190 2
a2191 1
    if (dtd_data[17] & 4) {
d2194 2
a2195 1
    if (dtd_data[17] & 2) {
d2200 3
a2202 3
    if (mode_desc->definition.interlaced == 1) {
          mode_desc->definition.yres = mode_desc->definition.yres * 2;

a2206 1

a2209 1

d2213 1
a2213 2

/* Get extd type checks the 18-byte data blocks for their type
d2223 1
a2223 4
    else
    {
        return -1; /* -1 = display descriptor */
    }
d2330 2
a2331 3
#if DODEBUG
        printf("CEA Short Audio Descriptor %02x %02x %02x\n",block[0],block[1],block[2]);
#endif
d2354 2
a2355 3
#if DODEBUG
        printf("CEA SVD %02x -> CEA mode %d%s\n",block[0],num,(block[0]&128)?" (native)":"");
#endif
d2357 1
a2357 1
        if ((num == 0) || (num > (sizeof(cea_modes)/sizeof(cea_modes[0]))))
d2381 1
a2381 3
#if DODEBUG
        printf("CEA Speaker Allocation %02x %02x %02x\n",block[0],block[1],block[2]);
#endif
d2396 2
a2397 3
#if DODEBUG
        printf("CEA extended data block code %d data length %d\n",tag_code,length);
#endif
d2401 2
a2402 4
#if DODEBUG
    printf("CEA data block code %d data length %d\n",tag_code,length);
#endif
    switch(tag_code)
d2404 4
a2407 4
    case 1: return process_cea_audio_data_block(ext_block, length, block, new_monitor);
    case 2: return process_cea_video_data_block(ext_block, length, block, new_monitor);
    case 4: return process_cea_speaker_allocation_data_block(ext_block, length, block, new_monitor);
    default: return NULL;
d2414 3
a2416 2
    /* offset from the start of the extension block to the */
    /* first dtd in the extension block. Uses the offset from block+2. */
d2429 1
a2429 3
#if DODEBUG
        printf("Basic audio supported\n");
#endif
d2464 2
a2465 1
    if (dtd_offset < 4) {
d2474 4
a2477 3
        mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mp == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
d2480 2
a2481 1
        if (!dtd_block_to_modedesc((char *) &(extdata[dtd_offset]), mp)) {
d2487 2
a2488 1
            if (add_proposed_mode(new_monitor, mp) == 0) {
d2505 3
a2507 6
    /* 'w' is the number of detailed timing blocks (DTB) */
    int w = extdata[2];
    /* 'y' is the number of CVT descriptions */
    int y = extdata[3];
    /* 'z' is the number of standard timing descriptions */
    int z = extdata[4];
d2510 2
a2511 1
    if (w*0x12 + y*0x3 + z*0x2 > 122) {
d2516 2
a2517 1
        if (extdata[byte]) {
d2525 4
a2528 3
        mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mp == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
d2531 2
a2532 1
        if (!dtd_block_to_modedesc((char *) &(extdata[0x5 + dtb_blockno*0x12]), mp)) {
d2538 2
a2539 1
            if (add_proposed_mode(new_monitor, mp) == 0) {
d2548 4
a2551 3
        mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mp == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
d2558 3
a2560 2
            res = generate_cvt3_timing (extdata[cvt_byte], extdata[cvt_byte+1], extdata[cvt_byte+2], new_monitor);
            if (res) {
d2569 4
a2572 3
        mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mp == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
d2578 3
a2580 2
            res = generate_standard_timing (extdata[std_byte], extdata[std_byte+1], new_monitor);
            if (res) {
d2599 5
a2603 4
    new_monitor = (MonitorDescriptionRef) malloc (sizeof(MonitorDescription));
    if (new_monitor == NULL) {
        printf("Can't allocate space for monitor list\n");
        return error (ERR_NOSPACE, 0, 0, 0);
d2615 3
a2617 2
    /* If we are EDID 1.4 compliant or above GTF and CVT support should be */
    /* present. Use CVT in preference, fallback to DMT only */
d2621 1
a2621 3
#if DODEBUG
        printf("Use CVT; fallback to DMT if unavailable\n");
#endif
d2625 3
a2627 2
    /* If we are EDID 1.4 compliant or above GTF support should be */
    /* present. Use GTF in preference, fallback to DMT only */
d2630 1
a2630 4
#if DODEBUG
        printf("Use GTF; fallback to DMT if unavailable\n");
#endif

d2638 9
a2646 8
    else
    {
      if ((edidblockref->feature_support & 1) == 1) {
          printf("This display supports continuous frequency modes (but we don't use this yet\n");
      }
      else {
          printf("This display supports only non-continuous frequency modes - use only the resolutions defined\n");
      }
a2649 3
    /* Now if we have set force_timings as a debug option, override the */
    /* timing_support setting (debug option for testing calculations) */

d2651 3
a2656 1

d2661 7
a2667 7
         if (!((edidblockref->standard_timings[std_timing_code*2] == 0x01) && (edidblockref->standard_timings[std_timing_code*2+1] == 0x01)))
         {
             res = generate_standard_timing(edidblockref->standard_timings[std_timing_code*2], edidblockref->standard_timings[std_timing_code*2+1], new_monitor);
             if (res)
             {
                 return res;
             }
d2671 6
a2676 6
    /* Sort the data blocks - store information strings and detailed */
    /* timing descriptors. Defer CVT codes and Established timings III */
    /* The first block is the 'preferred timing mode' and has highest */
    /* priority to go in the MDF. Any other 'detailed timing modes */
    /* have second priority so they will go in next */

d2679 1
a2679 1
        switch (get_extd_type(edidblockref,blockno))
d2683 1
a2683 3
#if DODEBUG
                printf("Data block\n");
#endif
d2685 4
a2688 3
                mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
                if (mp == NULL) {
                    return error (ERR_NOSPACE, 0, 0, 0);
d2691 2
a2692 1
                if (!dtd_block_to_modedesc((char *) &(edidblockref->data_block[blockno][0]), mp)) {
d2697 3
a2699 4
#if DODEBUG
                    printf("Detailed Mode: %s, X: %i Y: %i\n", mp->definition.name,mp->definition.xres, mp->definition.yres);
#endif
                    if (add_proposed_mode(new_monitor, mp) == 0) {
d2702 2
a2703 1
                    else {
d2705 2
a2706 1
                        if (blockno == 0) {
d2710 2
a2711 1
                        else {
d2719 4
a2722 5
        case 0xFD: /* Display range limits */
#if DODEBUG
            printf ("Display range limits\n");
#endif
            RangeBlock = blockno; /* remember*/
d2724 12
a2735 3

            /* Not 100% sure about this but think this is how we pick up CVT-RB support */
            if (timing_support == EDID_USE_CVT)
d2737 3
a2739 4
                char cvt_blanking = edidblockref->data_block[blockno][15];
                if ((cvt_blanking & 0x10) == 0x10) {
                    timing_support = EDID_USE_CVTRB;
                }
d2741 1
a2741 12
            break;
        case 0xFC: /* Model name, will form title of Display menu */
           Get_DTD_ASCII(edidblockref, blockno, new_monitor->name);
#if DODEBUG
           printf("Model name: %s\n", new_monitor->name);
#endif
           break;
        case 0xf7:
#if DODEBUG
            printf("Established timings III");
#endif
            for (int timings_byte=0; timings_byte<6; timings_byte++)
d2743 2
a2744 1
                for (int timings_bit=0; timings_bit<8; timings_bit++)
d2746 1
a2746 1
                    if ((edidblockref->data_block[blockno][6+timings_byte] & (1<<(timings_bit%8))) == (1<<(timings_bit%8)))
d2748 5
a2752 1
                        generate_dmt_mode(established_timings3[(timings_byte * 8) +(7 - timings_bit)], new_monitor, 6);
d2755 1
d2757 1
a2757 6
            break;
          case 0xf8: /* 3-byte CVT timings if found (Priority 4) */
#if DODEBUG
            printf("CVT 3 Byte timing codes\n");
#endif
            for (int cvt_byte = 6;cvt_byte < 18; cvt_byte+=3)
d2759 15
a2773 11
                if (!((edidblockref->data_block[blockno][cvt_byte] == 0) &&
                      (edidblockref->data_block[blockno][cvt_byte+1] == 0) &&
                      (edidblockref->data_block[blockno][cvt_byte+2] == 0))) {

                    res = generate_cvt3_timing (
                      edidblockref->data_block[blockno][cvt_byte],
                      edidblockref->data_block[blockno][cvt_byte+1],
                      edidblockref->data_block[blockno][cvt_byte+2],
                      new_monitor);
                    if (res) {
                        return res;
d2776 1
d2778 4
d2783 16
a2798 21
            break;
#if DODEBUG
          case 0xFF: /* Serial number - not used so only on in debug mode */
          {
              char serial_number[15];
              Get_DTD_ASCII(edidblockref, blockno, serial_number);
              printf ("Product serial number %s\n", serial_number);
              break;
          }
          case 0xFB: /* Colour point data */
              printf ("Colour point data\n");
              break;
          case 0xFA:
              printf ("Standard timing identifications\n");
              break;
          case 0xf9:
              printf ("Display colour management (DCM) data\n");
              break;
          case 0x10:
              printf("Empty\n");
              break;
a2800 1

a2802 2
    /* Add Established timings I and II  (priority 6) */

d2809 1
d2816 63
a2878 49
#if DODEBUG
              printf("Timings bitfield byte %d bit %d:\n", timings_byte, timings_bit);
#endif
              int dmt_mode = established_timings[(timings_byte * 8)+(7 - timings_bit)];
              if (dmt_mode > 0) {
                  generate_dmt_mode(dmt_mode, new_monitor, 6);
              }
              else {
                  // There are 3 cases who do not have defined DMT codes.
                  // These are byte 0 bits 7, 6 and 4 which we will calculate
                  int xres = 0;
                  int yres = 0;
                  int freq = 0;
                  switch (timings_bit | (timings_byte << 3))
                  {
                    case 7: // 720 X 400 @@ 70Hz
                      /* Use some fixed timings for better compatibility */
                      add_builtin_mode(new_monitor, &established_timing_7, 6);
                      break;
                    case 6: // 720 X 400 @@ 88Hz
                      xres = 720;
                      yres = 400;
                      freq = 88;
                      break;
                    case 4: // 640 X 480 @@ 67Hz
                      xres = 640;
                      yres = 480;
                      freq = 67;
                      break;
                  }

                  if (xres > 0) {
                      ModeDescriptionRef mp;
                      mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
                      if (mp == NULL) {
                          return error (ERR_NOSPACE, 0, 0, 0);
                      }

                      if ((timing_support == EDID_USE_GTF) ||
                          (timing_support == EDID_USE_GTF2)) {
                          generate_mode_using_gtf(xres, yres, freq, mp, new_monitor);
                      }
                      if ((timing_support == EDID_USE_CVT) ||
                          (timing_support == EDID_USE_CVTRB)) {
                          generate_mode_using_cvt_rb(xres, yres, freq, mp, new_monitor);
                      }
                  }

              }
a2882 1

d2886 1
a2886 1
        debug printf("%i Extension block(s) found\n", edidblockref->extension_block_count);
d2890 1
a2890 1
            EDIDExtensionBlockRef ext_block = (EDIDExtensionBlockRef) &ediddata[128*ext_block_id];
d2897 2
a2898 2
                debug printf("Block %i: CEA Extension block found\n", ext_block_id);
                debug printf("Version %i\n", ext_block->revision);
d2900 1
a2900 1
                if (ext_block->revision != 0) /* Revision 0 doesn't exist. All othe revisions (including future ones we don't know about) should be at least partially parseable. */
d2903 2
a2904 1
                    if (res) {
d2914 2
a2915 1
                if (res) {
a2921 1

d2923 3
a2925 2
    if (new_monitor->modelist == NULL) {
        return semerr0 (ERR_NOMODES);
d2927 2
a2928 1
    else {
d2932 25
a2956 18


#if DODEBUG
    printf("Modes sorted\n");
#endif
    if(file) {
      /* open file for new mode file if required */
      /* file is a string terminated in 0x0D */
      char *ptr,*fbuf;
      int length=strcspn(file,"\r");
      fbuf = malloc(length+MAXMONITORNAME+2);
      /* get around the CR terminated file name */
      if(fbuf) {
        memcpy(fbuf,file,length);
        fbuf[length] = '.';
        strcpy(fbuf+length+1,new_monitor->name);
        while(ptr=strpbrk(fbuf+length+1," \"#$%&*.:@@\\^|\x7f<>"),ptr) {
           *ptr='_';
a2957 7

        f=fopen(fbuf,"w");
        free(fbuf);
      }
      if(!f) {
        return _kernel_last_oserror();
      }
d2960 72
a3031 68
    if(f) {
      fprintf(f,"# Monitor description file for %s\n",new_monitor->name);
      fprintf(f,"# Created by ScrModes %s\n",Module_VersionString);
      fprintf(f,"# (EDID specified modes only, no calculated modes)\n\n");
      fprintf(f,"# Max Viewable H %d cm \n",edidblockref->horizontal_screen_size);
      fprintf(f,"# Max Viewable V %d cm\n",edidblockref->vertical_screen_size);
      if (RangeBlock != -1) {
        uint8_t flags = edidblockref->data_block[RangeBlock][4];
        int vmin=0,vmax=0,hmin=0,hmax=0, pixmax=0;
        if((flags&0x3)==0x2) {vmax=255;}
        if((flags&0x3)==0x2) {vmax=255; vmin=255;}
        if((flags&0xc)==0x8) {hmax=255;}
        if((flags&0xc)==0xc) {hmax=255; hmin=255;}
        vmin+=edidblockref->data_block[RangeBlock][5];
        vmax+=edidblockref->data_block[RangeBlock][6];
        hmin+=edidblockref->data_block[RangeBlock][7];
        hmax+=edidblockref->data_block[RangeBlock][8];
        pixmax=edidblockref->data_block[RangeBlock][9];
        fprintf(f,"# Line rate:     %2d - %2dkHz\n",hmin,hmax);
        fprintf(f,"# Frame rate:    %2d - %2dHz\n",vmin,vmax);
        fprintf(f,"# Max Dot rate: %3dMHz (rounded down)\n",pixmax*10);
      }
      fprintf(f,"# Uses %s frequency pixel clocks\n", ((edidblockref->feature_support & 1) == 1)?"Continuous":"Specific");

      char *rules="unknown";
      switch(timing_support) {
        case EDID_USE_CVT:rules="CVT";break;
        case EDID_USE_DMT:rules="DMT";break;
        case EDID_USE_CVTRB:rules="CVTRB";break;
        case EDID_USE_GTF:rules="GTF";break;
        case EDID_USE_GTF2:rules="GTF2";break;
      }
      fprintf(f,"# Use %s timing rules\n#\n",rules);

      fprintf(f,"file_format:1\nmonitor_title:%s\n",new_monitor->name);
      if(new_monitor->dpms_state!=-1) {
        fprintf(f,"DPMS_state:%d\n",new_monitor->dpms_state);
      }
      ModeDescriptionRef this = new_monitor->modelist;
      do {
        fprintf(f,"\n# Mode:  %d x %d @@ %dHz",this->definition.xres,this->definition.yres,this->frame_hz);
        fprintf(f,"\n# Bounds: H  %3.2fkHz, V %3.2f, DClock %3.2fMHz",((float)(this->line_hz))/1000.0f,((float)(this->frame_mhz))/1000.0f,((float)(this->definition.pixel_khz))/1000.0f);
        fprintf(f,"\nstartmode");
        fprintf(f,"\n mode_name:%d x %d",this->definition.xres,this->definition.yres);
        fprintf(f,"\n x_res:%d",this->definition.xres);
        fprintf(f,"\n y_res:%d",this->definition.yres);
        fprintf(f,"\n pixel_rate:%d",this->definition.pixel_khz);
        fprintf(f,"\n h_timings:%d,%d,%d,%d,%d,%d",this->definition.hpar[0],this->definition.hpar[1],this->definition.hpar[2],this->definition.hpar[3],this->definition.hpar[4],this->definition.hpar[5]);
        fprintf(f,"\n v_timings:%d,%d,%d,%d,%d,%d",this->definition.vpar[0],this->definition.vpar[1],this->definition.vpar[2],this->definition.vpar[3],this->definition.vpar[4],this->definition.vpar[5]);
        fprintf(f,"\n sync_pol:%d",this->definition.syncpol);
        if (this->definition.interlaced == 1) {
          fprintf(f,"\n interlaced");
        }
        fprintf(f,"\nEndMode\n");
        this = this->next;  /* will be NULL at list end*/
      } while (this);
      /* now fo hex dump of EDID block */
      fprintf(f,"# EDID block dump\n#\n");
      for (int i=0; i<(edidblockref->extension_block_count+1)*0x80;i+=16) {
        fprintf(f,"# %02x %02x %02x %02x  %02x %02x %02x %02x",
           ediddata[i],ediddata[i+1],ediddata[i+2],ediddata[i+3],
           ediddata[i+4],ediddata[i+5],ediddata[i+6],ediddata[i+7]);
        fprintf(f,"  %02x %02x %02x %02x  %02x %02x %02x %02x\n",
           ediddata[i+8],ediddata[i+9],ediddata[i+10],ediddata[i+11],
           ediddata[i+12],ediddata[i+13],ediddata[i+14],ediddata[i+15]);
      }
      fprintf(f,"#\n#End\n");
      fclose (f);
d3039 3
a3041 2
       if (old_monitortype == -1) {
           old_monitortype = read_monitortype ();
d3044 10
a3053 9
       res = set_monitortype (MONITOR_FILE);
       if (res != NULL) {
         _kernel_oserror *res2;
         debug printf ("setting of monitor type to type `FILE' failed\n");
         res2 = restore_monitortype (); /* restore old value */
         if (res2 != NULL)
         {
             debug printf ("couldn't reset monitor type to CMOS default!\n");
         }
d3055 39
a3093 36
       else {
         _kernel_swi_regs regs;
         release_currentmonitor ();
         current_monitor = new_monitor;

         /* Set up the mode specifier */
         if(preferred_mode && new_preferred_mode)
         {
           preferred_mode->bit0 = 1;
           preferred_mode->format = 0;
           preferred_mode->xresol = new_preferred_mode->definition.xres;
           preferred_mode->yresol = new_preferred_mode->definition.yres;
           preferred_mode->depth = 5;
           preferred_mode->framerate = new_preferred_mode->frame_hz;
           preferred_mode->param[0].index = -1;
         }
         else if(preferred_mode)
         {
           preferred_mode->bit0 = 0;
         }

         /* Set the preferred sync type from video input definition bit 3. */
         /* (ref EDID spec table 3.11) */
         if ((edidblockref->video_input_definition & 0x8) == 0x8) {
             preferred_sync_type = 0;
         }
         else {
             preferred_sync_type = 1;
         }

         debug printf("Monitor type changed\n");

         /* Newly defined monitor, announce it */
         regs.r[1] = Service_ModeFileChanged;
         _kernel_swi (OS_ServiceCall, &regs, &regs);
         debug printf("Service_ModeFileChanged issued\n");
d3100 1
a3100 1
static _kernel_oserror *loadedid (const char *file)
d3108 1
a3108 1
    int file_length, file_found;
d3110 3
a3112 2
    res = _swix(OS_File, _INR(0,1) | _OUT(0) | _OUT(4), 23, file, &file_found, &file_length);
    if (!res && (file_found == 1))
d3114 1
a3114 1
        char *edidblock = (char *) malloc (file_length + 4);
d3116 3
a3118 2
        if (edidblock == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
d3120 1
a3120 1
        res = _swix(OS_File,_INR(0,3),0xff,file,edidblock,0);
d3123 3
a3125 2
        if (!res) {
            res = Check_EDID_Checksum((char *)edidblock, EDID_Check_AllBlocks);
d3127 3
a3129 2
        if (!res) {
          res = parseedid(edidblock,NULL);
d3136 1
a3136 1
static _kernel_oserror *loadmodefile (const char *file)
d3140 4
a3143 3
  res = open_modefile (file);
  if (res != NULL) {
      debug printf ("failed to open modefile\n");
d3154 2
a3155 1
          if (((i == 0) || (i == 7)) && (c != 0x00)) {
d3158 2
a3159 1
          if (((i > 0) && (i < 7)) && (c != 0xff)) {
d3166 3
a3168 3
          /* Close the file - we need to load the whole file to map it */
          /* onto the EDID struct */

d3182 1
a3182 1
static _kernel_oserror *readedidblock (int displaynum, EDIDBlockRef edidblock, int offset, int count)
d3191 6
a3196 4
       unchanged in which case we need to alert the user that the
       hardware doesn't like EDID :-( */
    if (iic_code != 0) {
        res = error (ERR_IICOPFAIL, 0, 0, 0);
d3200 3
a3202 2
    if (op_code != 0) {
        res = error (ERR_CANTREADEDID, 0, 0, 0);
d3207 1
a3207 1
static _kernel_oserror *readedid (int displaynum, const char *file)
d3210 4
a3213 3
    EDIDBlockRef edidblock = (EDIDBlockRef) malloc(128);
    if (edidblock == NULL) {
        return error (ERR_NOSPACE, 0, 0, 0);
d3215 1
a3215 1
    debug printf ("ReadEDID called\n");
d3217 1
a3217 1
    res = readedidblock (displaynum, edidblock, 0, 1);
d3220 3
a3222 2
    if (!res) {
        res = Check_EDID_Checksum((char *)edidblock, EDID_Check_BaseOnly);
d3225 4
a3228 4
    /* Now use a separate pointer to the block for extending it and */
    /* setting up extensions */
    /* (because if it fails we use the original pointer to free up the */
    /* memory block and exit). */
d3232 3
a3234 2
    if (!res) {
        debug printf ("%i EDID extension blocks found\n", edidblock->extension_block_count);
d3236 6
a3241 4
        if (edidblock->extension_block_count > 0) {
            ediddata = realloc (edidblock, 128 * (edidblock->extension_block_count + 1));
            if (ediddata == NULL) {
                res = error (ERR_NOSPACE, 0, 0, 0);
d3243 2
a3244 1
            else {
d3247 1
a3247 1
                res = readedidblock (displaynum, edidblock, 1, edidblock->extension_block_count);
d3250 3
a3252 2
                if (!res) {
                    res = Check_EDID_Checksum((char *)edidblock, EDID_Check_AllBlocks);
d3258 7
a3264 6
    if (!res) {
      debug printf ("Parsing EDID block\n");
      EDIDEnabled = 1;
      /* ERR_NOMODES expects a filename, give it something vaguely sensible */
      thefilename = "(EDID)";
      res = parseedid(ediddata,file);
d3292 1
a3292 1
    if(pf->log2bpp > 5)
d3294 1
a3294 1
    if(pf->ncolour != (1<<(1<<pf->log2bpp))-1)
d3296 1
a3296 1
    if(pf->modeflags != (pf->log2bpp==3?ModeFlag_FullPalette:0))
d3302 1
a3302 1
static int current_graphicsv_driver (void)
d3307 1
a3307 1
    _swix(OS_ReadVduVariables,_INR(0,1),variables,variables);
d3311 1
a3311 1
static void build_a_vidclist (VIDCListRef vp, ModeDescriptionRef mp, const PixelFormatRef pf)
d3328 1
a3328 1
    if(!is_old_format(pf))
d3347 1
a3347 1
        debug printf("I'm an LCD panel & I'm going to tell the Kernel!\n");
d3392 1
a3392 2
/*
 * Test for whether a given mode definition is usable within the
d3397 1
a3397 1
static int mode_valid (ModeDescriptionRef mp, const PixelFormatRef pf,
d3411 1
a3411 1
    if(pf->log2bpp == 6) /* 24bit packed formats */
d3413 1
a3413 1
    else if(pf->log2bpp == 7) /* YUV formats - TODO! */
d3417 2
a3418 1
    if ((bpp > 4) && (current_monitor->lcd_support == 1)) {
d3437 2
a3438 1
    if (datarate > maxdatarate || datasize > maxdatasize) {
d3447 1
a3447 1
    _kernel_swi (OS_CallAVector, &r, &r);
d3452 1
a3452 1
        while(i)
d3454 1
a3454 1
            if((formats->ncolour == pf->ncolour)
d3461 1
a3461 1
        if(i == 0)
d3467 1
a3467 1
        if(!is_old_format(pf))
d3471 3
a3473 2
        _kernel_swi (OS_CallAVector, &r, &r);
        if ((r.r[4] == 0) && ((r.r[1] & (1<<pf->log2bpp)) == 0)) {
d3479 1
a3479 1
    build_a_vidclist (&vetlist, mp, pf);
d3484 3
a3486 2
    _kernel_swi (OS_CallAVector, &r, &r);
    if ((r.r[4] == 0) && (r.r[0] != 0)) {
d3494 1
a3494 1
static ModeDescriptionRef find_by_xy (ModeDescriptionRef mp,
d3515 1
a3515 2
    else
        return NULL;
d3518 1
a3518 1
static int restrict_bandwidth (int os_limit)
d3520 1
a3520 2
    /*
     * On a HAL based kernel the kernel doesn't know what the bandwidth limitations
d3532 1
a3532 1
static void service_modeextension (_kernel_swi_regs *regs)
d3534 1
a3534 2
    /*
     * Static allocation of a single VIDCList, for return from
d3569 1
a3569 2
    /*
     * Check for being passed a mode selector as opposed to a mode
d3572 2
a3573 1
    if (!IS_MODE_SEL_PTR (regs->r[2])) {
d3577 1
a3577 2
    /*
     * Check for suitable monitor type being requested - we handle
d3581 2
a3582 1
    if (regs->r[3] != -1 && regs->r[3] != MONITOR_FILE) {
d3586 1
a3586 2
    /*
     * Address the mode selector (R2 on entry has been found to be a
d3591 2
a3592 1
    if (sel->bit0 != 1 || sel->format != 0) {
d3596 1
a3596 3
    /*
     * Examine the mode selector to deduce the pixel format
     */
d3599 1
a3599 1
    while(param->index != -1)
d3601 1
a3601 1
        if(param->index == VduExt_ModeFlags)
d3603 1
a3603 1
        else if(param->index == VduExt_NColour)
d3612 1
a3612 1
    if((pf.modeflags & ModeFlag_DataFormatFamily_Mask) == ModeFlag_DataFormatFamily_RGB)
d3615 1
a3615 1
        if((pf.ncolour == 63) && (pf.log2bpp == 3))
d3625 1
a3625 1
    if(pf.modeflags & ~(ModeFlag_FullPalette | ModeFlag_64k | ModeFlag_ChromaSubsampleMode | ModeFlag_DataFormat_Mask))
d3631 1
a3631 2
    /*
     * Current Screen Mode selection API FuncSpec (0197,290/FS, Issue
d3639 1
a3639 1
    dataratelimit = restrict_bandwidth (regs->r[4]) / 1000;
d3641 1
a3641 2
    /*
     * Scan all available modes, looking for a match.  First find the
d3648 3
a3650 2
    mp = find_by_xy (current_monitor->modelist, sel->xresol, sel->yresol, &nmodes);
    if (mp == NULL) {
d3657 1
a3657 1
             mode_valid (mp, &pf, dataratelimit, datasizelimit))
d3659 1
a3659 1
            build_a_vidclist (&thevidclist, mp, &pf); /* use the local static structure */
d3664 1
a3664 1
            regs->r[4] = NULL;              /* marks no workspace list (mode selector given) */
d3671 1
a3671 1
static void service_enumeratescreenmodes (_kernel_swi_regs *regs)
d3679 2
a3680 4
    /*
     * See comments re. data-rate spec in service_modeextension.
     */
    dataratelimit = restrict_bandwidth (regs->r[4]) / 1000;
d3688 1
a3688 1
    _kernel_swi (OS_CallAVector, &r, &r);
d3709 1
a3709 1
        if (!mode_valid (mp, pf, dataratelimit, datasizelimit))
d3711 1
a3711 2
            /*
             * TMD 03-Nov-93: Fix bug MED-00833
d3727 1
a3727 1
                int nlen = strlen (mp->definition.name);
d3730 2
a3731 1
                if (!old_format) {
d3739 1
a3739 1
                        if(old_format)
d3749 1
a3749 1
                            ip->depth = pf->log2bpp; /* log2 (bits/pixel) */
d3753 1
a3753 1
                            strcpy (ip->name, mp->definition.name);
d3772 1
a3772 1
                            strcpy (ip->name, mp->definition.name);
d3801 2
a3802 1
            if (mp == NULL) {
d3816 3
a3818 2
    mp = find_by_xy (current_monitor->modelist, xres, yres, &nmodes);
    if (mp == NULL) {
d3824 1
a3824 1
            mode_valid (mp, pf, INT32_MAX, INT32_MAX))
d3834 1
a3834 1
static void service_modetranslation (_kernel_swi_regs *regs)
d3845 2
a3846 1
    if (regs->r[3] != 7 || !current_monitor) {
d3850 1
a3850 2
    /*
     * Someone has asked for an old-style mode number, but we
d3865 1
a3865 2
    /*
     * What depth are they looking for? If the mode is
d3871 1
a3871 1
              }
d3873 1
a3873 2
    /*
     * Clamp depth to 8bpp to restrict ourselves to old-style
d3876 2
a3877 1
    if (depth > 3) {
d3884 1
a3884 2
    /*
     * Check if 640x480xdepth @@ 60Hz is available. If so, allow
d3889 1
a3889 1
         regs->r[1] = 0;                /* Service_Serviced */
d3894 1
a3894 2
     /*
      * We don't have a standard VGA mode. Let's try a PAL TV
d3899 1
a3899 1
         regs->r[1] = 0;                /* Service_Serviced */
d3904 1
a3904 3
     /*
      * Alright then. How about a NTSC TV mode?
      */
d3907 1
a3907 1
         regs->r[1] = 0;                /* Service_Serviced */
d3912 1
a3912 3
     /*
      * Check if 640x480xdepth @@ any rate is available.
      */
d3915 1
a3915 1
         regs->r[1] = 0;                /* Service_Serviced */
d3920 1
a3920 2
     /*
      * Still getting nowhere? Maybe we can't do 1bpp or 8bpp for
d3933 1
a3933 1
static void service_displaychanged (_kernel_swi_regs *regs)
d3936 1
a3936 1
    switch(regs->r[0])
d3940 4
a3943 3
               driver-specific things which we store.
               At the moment all the driver-specific stuff happens during the
               enumerate/translate calls, so there's nothing to do. */
d3951 6
a3956 5
            /* Display change is complete */
            /* Issue mode file changed service call so that the display manager
               is up to date.
               (might be possible to skip this if EDID is in use and EDID has
               already issued it) */
d3962 1
a3962 2

static void service_monitorleadtranslation (_kernel_swi_regs *regs)
d3964 7
a3970 7
  if ((preferred_mode != NULL) && (preferred_mode->bit0 == 1))
  {
    regs->r[1] = 0;
    regs->r[3] = (int) preferred_mode;
    regs->r[4] = 7;
    regs->r[5] = preferred_sync_type;
  }
d3973 1
a3973 1
static int we_are_preferred (void *pw)
d3976 1
a3976 1
    sregs.r[0] = 18;
d3978 1
a3978 1
    (void)_kernel_swi (OS_Module, &sregs, &sregs);
d4001 18
a4018 18
                 bit 0: 0 -> read raw data
                        1 -> read friendly data
            r1 = format code to start from (-1 = first)
            r2 = index within format code (-1 = first)
       Out: r1 = format code of this entry (-1 if no more formats)
            r2 = index within format code (-1 if no more formats)
            r3 = max channels
            raw data:
              r4 = audio short descriptor byte 2
              r5 = audio short descriptor byte 3
            friendly data:
              r4 = sample rate (Hz*1024)
              r5 = LPCM: bit depth
                   codes 2-8: max bit rate in Hz
                   other codes: not supported by this API

       n.b. index values (r2) differ between raw & friendly modes
    */
a4138 1

d4155 1
a4155 1
_kernel_oserror *ScreenModes_final (int fatal, int podule, void *pw)
d4157 1
a4157 2
    /*
     * Free the space claimed for the current monitor
d4161 2
a4162 2
    (void) restore_monitortype (); /* restore old value */
    release_currentmonitor ();
a4174 1

d4176 1
a4176 1
void ScreenModes_servicecall (int servicecallno, _kernel_swi_regs *regs, void *pw)
d4178 2
a4179 1
    if ((current_monitor == NULL) && (servicecallno != Service_DisplayChanged)) {
d4184 3
a4186 2
    if (!we_are_preferred (pw)) {
      return;
d4189 3
a4191 2
    if (servicecallno == Service_ModeExtension) {
        service_modeextension (regs);
d4193 3
a4195 2
    else if (servicecallno == Service_EnumerateScreenModes) {
        service_enumeratescreenmodes (regs);
d4197 3
a4199 2
    else if (servicecallno == Service_ModeTranslation) {
        service_modetranslation (regs);
d4201 3
a4203 2
    else if (servicecallno == Service_DisplayChanged) {
        service_displaychanged (regs);
d4205 3
a4207 2
    else if (servicecallno == Service_MonitorLeadTranslation) {
        service_monitorleadtranslation (regs);
a4210 1

d4212 1
a4212 1
_kernel_oserror *ScreenModes_cmdhandler (const char *arg_string, int argc, int cmd_no, void *pw)
d4219 2
a4220 2
                result = loadmodefile (arg_string);
                break;
d4222 2
a4223 2
                result = readedid (current_graphicsv_driver(),NULL);
                break;
d4225 2
a4226 2
                result = readedid (current_graphicsv_driver(),arg_string);
                break;
d4228 1
a4228 1
                return NULL;
a4236 1

d4238 1
a4238 1
_kernel_oserror *ScreenModes_swihandler (int swi_no, _kernel_swi_regs *r, void *pw)
d4256 1
a4256 1
                        result = error (ERR_NOMODEFILE, 0, 0, 0);
d4270 1
a4270 1
                        result = error (ERR_NOMODEFILE, 0, 0, 0);
d4275 1
a4275 1
                    result = error (ERR_BADREADINFO, 0, 0, 0);
a4289 1

@


4.34
log
@Fix *LoadModeFile not reporting errors when parsing EDID files. Fix another "RMA allocation failed" bug with audio format processing.
Detail:
  c/ScrModes - Fix loadedid() not returning errors from parseedid()
  c/ScrModes - Fix bad use of realloc() in add_audio_format() - if audio_format_count hits zero then it's expected for realloc to return NULL.
Admin:
  Tested on iMx6


Version 0.52. Tagged as 'ScrModes-0_52'
@
text
@d527 3
d2717 24
a2740 1
    /* TODO: Parse SVDs and add to mode list */
d3444 3
a3446 1
    /* NB at present we aren't loading extension blocks */
@


4.33
log
@Fix audio format merge logic
Detail:
  c/ScrModes - When removing 'candidate' from the list of audio formats, it's the number of formats which we want to decrement, not the pointer to the start of the list.
Admin:
  Tested on iMx6
  Fixes "RMA allocation failed" and other issues when dealing with monitors with complex audio capabilities


Version 0.51. Tagged as 'ScrModes-0_51'
@
text
@d2658 1
a2658 1
                    if (new)
d3437 1
a3437 1
          parseedid(edidblock,NULL);
@


4.32
log
@Fix a few issues with EDID established timings
Detail:
  c/ScrModes:
  - Added established timings for 720x400 @@ 70Hz to be used in place of the auto-generated timings. For a BenQ FP737s-D, these match the expected timings listed in the manual, and they actually result in a picture displaying (auto-generated timings did not).
  - Split the guts of generate_dmt_mode out into a separate function so it can easily be used for adding the 720x400 @@ 70Hz ModeDefinition
  - Fix established timing handling to only call generate_dmt_mode if the DMT defines timings for a given mode (old logic meant that only 720x400 @@ 70Hz was falling through to the auto-generate case)
  - Fix established timing auto-generation to cope with the possibility of timings_byte being non-zero
Admin:
  Tested on iMx6 on a variety of monitors
  720x400 @@ 70Hz now displays correctly on a FP737s-D
  640x480 @@ 67Hz now works too (albeit with a warning about being a non-preset mode, this one is listed in the EDID but not in the manual)


Version 0.50. Tagged as 'ScrModes-0_50'
@
text
@d2655 1
a2655 1
                    new_monitor->audio_formats--;
@


4.31
log
@Add support for parsing and reporting the contents of CEA 861-D audio-related EDID blocks
Detail:
  Makefile - Export a C version of hdr/ScrModes
  Resources/Germany/Messages, Resources/UK/Messages, h/errors - Add new error message
  cmhg/ScrModesv, hdr/ScrModes - Declare existence of ScreenModes_EnumerateAudioFormats SWI. Declare ScreenModes_ReadInfo reason codes.
  h/modex - Extend MonitorDefinition struct to allow it to store the speaker mask & audio format information that's extracted from the EDID
  c/ScrModes - Extend support for processing of CEA extension blocks. All block revisions > 0 should now be accepted, and rudimentary parsing of CEA data block collections is implemented (currently, only extracts information from audio related blocks). Add SWI ScreenModes_EnumerateAudioFormats to allow details of the supported formats to be returned in either "raw" or "friendly" forms. Add ScreenModes_ReadInfo reason code 1 to allow reading of the speaker mask (+ validity bits). Also fix *LoadModeFile to allow EDID blocks to be loaded without first having to issue *ReadEDID first (EDIDEnabled flag issue).
Admin:
  Tested on iMX6 with assorted EDID blocks
  German messages file in need of translation


Version 0.49. Tagged as 'ScrModes-0_49'
@
text
@d459 17
d1656 26
a1694 13
        ModeDescriptionRef mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mode_desc == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
        }

        mode_desc->definition = display_monitor_timings[dmt];
        compute_modedescription(mode_desc);
        mode_desc->frame_hz = display_monitor_timings[dmt].freq;
        mode_desc->priority = priority;

        if (add_proposed_mode(monitor, mode_desc) == 0) {
          free(mode_desc);
        }
a1697 1
        display_mode_parameters(mode_desc);
d1699 2
d3155 4
a3158 1
              int dmt_mode = (timings_byte * 8)+(7 - timings_bit);
d3160 1
a3160 1
                  generate_dmt_mode(established_timings[dmt_mode], new_monitor, 6);
d3168 1
a3168 1
                  switch (timings_bit)
d3170 3
a3172 4
                    case 7: // 720 X 400 @@ 40Hz
                      xres = 720;
                      yres = 400;
                      freq = 70;
@


4.30
log
@Fix some more sync polarity issues. Don't support DTDs for stereoscopic modes.
Detail:
  c/ScrModes - Replace magic numbers used for sync polarities with HSync_Positive, VSync_Negative, etc. #defines. Fix GTF2 polarity to be correct. Fix CVT/CVT RB polarities to be correct (+ some incorrect code indentation). Make dtd_block_to_modedesc return true/false for success/failure so we can reject stereoscopic 3D modes.
Admin:
  Tested on Pandaboard


Version 0.48. Tagged as 'ScrModes-0_48'
@
text
@d37 1
d635 4
d1269 1
d2558 171
a2728 2
/* Process a CEA type 3 extension block */
static _kernel_oserror *process_cea_extension_type_3(EDIDExtensionBlockRef ext_block, MonitorDescriptionRef new_monitor)
d2734 47
d2786 1
a2786 1
    while ((dtd_offset < (128 - 18)) &&
a2903 3
    if(!EDIDEnabled) {                            /* only if needed!! */
      return res;
    }
d2911 1
d3193 1
a3193 1
                if (ext_block->revision == 0x03)
d3195 1
a3195 1
                    res = process_cea_extension_type_3(ext_block, new_monitor);
d4253 157
d4516 1
a4516 1
                case 0:         /* Return pointer to monitor name */
d4529 14
d4548 3
@


4.29
log
@Fix decoding of DTD sync polarities. Add support for some missing established timings.
Detail:
  c/ScrModes - Fixed decoding of DTD polarties in dtd_block_to_modedesc. Add support for some missing established timings (generated by GTF/CVT as we don't have any known-good values to use as a reference)
Admin:
  Tested on Pandaboard
  Submission from William Harden


Version 0.47. Not tagged
@
text
@d97 5
d103 4
a106 4
#define PP 0
#define PN SyncPol_InvertVSync
#define NP SyncPol_InvertHSync
#define NN SyncPol_InvertHSync+SyncPol_InvertVSync
d1907 7
a1913 1
    mode_desc->definition.syncpol = 1; /* H Pol. -ve, V Pol +veYes, */
d1981 1
d1983 1
d1985 2
d2162 1
a2162 1
      }
d2164 3
a2166 29
      /* Calculate front and back porch */
      int h_back_porch = h_blank / 2;
      int h_front_porch = h_blank - h_back_porch - h_sync;

      /* Now populate the mode definition block */
      mode_desc->definition.xres = (int)h_pixels;
      mode_desc->definition.yres = (int)v_lines;
      mode_desc->definition.hpar[FR_SYNC] = h_sync;
      mode_desc->definition.hpar[FR_BPCH] = h_back_porch;
      mode_desc->definition.hpar[FR_BDR1] = (int) left_margin;
      mode_desc->definition.hpar[FR_DISP] = (int) h_pixels;
      mode_desc->definition.hpar[FR_BDR2] = (int) right_margin;
      mode_desc->definition.hpar[FR_FPCH] = h_front_porch;
      mode_desc->definition.vpar[FR_SYNC] = (int) v_sync_rnd;
      mode_desc->definition.vpar[FR_BPCH] = v_back_porch;
      mode_desc->definition.vpar[FR_BDR1] = (int) top_margin;
      if (int_rqd) {
          mode_desc->definition.vpar[FR_DISP] = (int) v_lines / 2;
      }
      else
      {
          mode_desc->definition.vpar[FR_DISP] = (int) v_lines;
      }
      mode_desc->definition.vpar[FR_BDR2] = (int) bot_margin;
      mode_desc->definition.vpar[FR_FPCH] = (int) v_front_porch;
      mode_desc->definition.pixel_khz = (int) (act_pixel_freq * 1000);
      mode_desc->definition.external_clock = -1;
      mode_desc->definition.syncpol = 0;
      mode_desc->definition.interlaced = int_rqd;
d2168 31
a2198 2
      sprintf(mode_desc->definition.name, "%d x %d", (int)h_pixels, (int)v_lines);
      compute_modedescription(mode_desc);
d2200 6
a2205 3
      if (add_proposed_mode(monitor, mode_desc) == 0) {
        free(mode_desc);
      }
d2464 1
a2464 1
static void dtd_block_to_modedesc(char* dtd_data, ModeDescriptionRef mode_desc)
a2493 1
    mode_desc->definition.syncpol       = ((!((dtd_data[17]>>2) & 1)<<1) + !((dtd_data[17]>>1) & 1));
d2495 23
d2531 2
d2573 1
a2573 3
        dtd_block_to_modedesc((char *) &(extdata[dtd_offset]), mp);
        mp->priority = 3;
        if (add_proposed_mode(new_monitor, mp) == 0) {
d2576 7
d2622 1
a2622 3
        dtd_block_to_modedesc((char *) &(extdata[0x5 + dtb_blockno*0x12]), mp);
        mp->priority = 3;
        if (add_proposed_mode(new_monitor, mp) == 0) {
d2625 7
d2781 5
a2785 2
                dtd_block_to_modedesc((char *) &(edidblockref->data_block[blockno][0]), mp);

d2787 1
a2787 1
                printf("Detailed Mode: %s, X: %i Y: %i\n", mp->definition.name,mp->definition.xres, mp->definition.yres);
d2789 2
a2790 9

                if (add_proposed_mode(new_monitor, mp) == 0) {
                    free(mp);
                }
                else {
                    /* The first block should define the preferred mode */
                    if (blockno == 0) {
                        new_preferred_mode = mp;
                        mp->priority = 0x01;
d2793 8
a2800 1
                        mp->priority = 0x02;
@


4.28
log
@Avoid potential read of bad address in CEA block processing
Detail:
  c/ScrModes - Reorder while loop conditions to ensure the DTD offset is checked before we try reading any data; prevents potential data abort if initial offset is too large to be valid.
Admin:
  Builds, untested


Version 0.47. Retagged as 'ScrModes-0_47'
@
text
@d2473 1
a2473 1
    mode_desc->definition.syncpol       = (!((dtd_data[17]>>2) & 1) + (!((dtd_data[17]>>1) & 1)<<1));
a2690 19
    /* Add Established timings I, II and III (priority 6) */

#if DODEBUG
    printf("Timings bitfield 0 = %02x\n",edidblockref->established_timings[0]);
    printf("Timings bitfield 1 = %02x\n",edidblockref->established_timings[1]);
    printf("Timings bitfield 2 = %02x\n",edidblockref->established_timings[2]);
#endif

    for (int timings_byte=0; timings_byte<2; timings_byte++)
    {
        for (int timings_bit=0; timings_bit<8; timings_bit++)
        {
            if ((edidblockref->established_timings[timings_byte] & (1<<(timings_bit%8))) == (1<<(timings_bit%8)))
            {
                generate_dmt_mode(established_timings[(timings_byte * 8)+(7 - timings_bit)], new_monitor, 6);
            }
        }
    }

d2832 66
@


4.27
log
@Fix DERIVE_CVT3_FROM_DMT
Detail:
  c/ScrModes - Swap 'return;' for 'return NULL;' in the (currently unused) DERIVE_CVT3_FROM_DMT code to ensure the function has a sensible return value
Admin:
  Untested


Version 0.47. Retagged as 'ScrModes-0_47'
@
text
@d2519 2
a2520 2
    while ((extdata[dtd_offset] != 0) && (extdata[dtd_offset+1] != 0) &&
           (dtd_offset < (128 - 18)))
@


4.26
log
@Add support for CVT 3 byte codes & VTB-EXT blocks. Other misc fixes.
Detail:
  c/ScrModes, h/modex - Added support for CVT 3 byte codes & VTB-EXT blocks. Add framework for sorting modes by EDID priority. Move CEA extension block handling into its own function & increase error checking.
  Resources/Germany/CmdHelp, Resources/UK/CmdHelp - Fix missing message token & incorrect syntax of syntax message
Admin:
  Code submission from William Harden
  Tested on Raspberry Pi


Version 0.47. Tagged as 'ScrModes-0_47'
@
text
@d2318 1
a2318 1
            return;
@


4.25
log
@Fix bad merge. Improve Get_DTD_ASCII & MDF saving.
Detail:
  c/ScrModes - Fix a bad merge causing a compute_modedescription() call to go missing. Fix Get_DTD_ASCII to avoid reading one byte too many, and to ensure the buffer is null terminated. Also strip any control characters. Improve MDF saving to return an error if the file couldn't be created, and to substitute various unsafe characters with underscores
Admin:
  Tested on Pandaboard


Version 0.46. Tagged as 'ScrModes-0_46'
@
text
@d49 5
d478 26
d1613 16
a1628 1
/* add_dmt_mode creates a mode using standardised timing parameters.
d1633 1
a1633 1
static _kernel_oserror *add_dmt_mode(char dmt, MonitorDescriptionRef monitor)
d1649 1
d1651 3
a1653 2
        mode_desc->next = monitor->modelist;
        monitor->modelist = mode_desc;
d1908 3
a1910 2
    mode_desc->next = monitor->modelist;
    monitor->modelist = mode_desc;
d2182 3
a2184 2
      mode_desc->next = monitor->modelist;
      monitor->modelist = mode_desc;
d2191 1
a2191 1
static _kernel_oserror *add_standard_timing(char std1, char std2, MonitorDescriptionRef monitor)
d2213 1
a2213 3

            mode_desc->next = monitor->modelist;
            monitor->modelist = mode_desc;
d2219 5
d2229 1
a2229 1
    if ((mode_desc == NULL) && (timing_support != EDID_USE_DMT))
d2272 165
d2490 1
d2507 111
d2690 2
a2691 1
    /* Next add inbuilt modes */
d2699 1
a2699 1
    for (int i=0; i<2; i++)
d2701 1
a2701 1
        for (int j=0; j<8; j++)
d2703 1
a2703 1
            if ((edidblockref->established_timings[i] & (1<<(j%8))) == (1<<(j%8)))
d2705 1
a2705 1
                add_dmt_mode(established_timings[(i * 8)+(7 - j)], new_monitor);
d2710 1
a2710 1
    /* Next do each of the 'standard timings'. */
d2712 1
a2712 1
    for (int i=0; i<8;i++)
d2714 1
a2714 1
         if (!((edidblockref->standard_timings[i*2] == 0x01) && (edidblockref->standard_timings[i*2+1] == 0x01)))
d2716 1
a2716 1
             res = add_standard_timing(edidblockref->standard_timings[i*2], edidblockref->standard_timings[i*2+1], new_monitor);
d2724 6
a2729 1
    /* Sort the data blocks */
a2746 9
                /* The first block should define the preferred mode */
                if (blockno == 0)
                {
                    new_preferred_mode = mp;
                }

                mp->next = new_monitor->modelist;
                new_monitor->modelist = mp;

d2750 15
d2788 1
a2788 1
          break;
d2793 1
a2793 1
            for (int i=0; i<6; i++)
d2795 1
a2795 1
                for (int j=0; j<8; j++)
d2797 1
a2797 1
                    if ((edidblockref->data_block[blockno][6+i] & (1<<(j%8))) == (1<<(j%8)))
d2799 22
a2820 1
                        add_dmt_mode(established_timings3[(i * 8) +(7 - j)], new_monitor);
d2824 1
a2842 3
          case 0xf8:
              printf("CVT 3 Byte timing codes\n");
              break;
d2851 1
a2860 1
            /* But we only deal with CEA Ext V3 types for now... */
d2862 1
a2862 1
            /* CEA Extension type 3 - uses Tag 0x02 */
d2868 1
a2868 6
                /* dtd offset if the offset from the start of the EDID data to the */
                /* first dtd in the extension block. Uses the offset from block+2. */
                int dtd_offset = 128 * ext_block_id + ediddata[128*ext_block_id + 2];

                while ((ediddata[dtd_offset] != 0) && (ediddata[dtd_offset+1] != 0) &&
                       (dtd_offset < ((128 * (edidblockref->extension_block_count + 1)) - 18)))
d2870 3
a2872 4
                    ModeDescriptionRef mp;
                    mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
                    if (mp == NULL) {
                        return error (ERR_NOSPACE, 0, 0, 0);
d2874 2
d2877 6
a2882 4
                    dtd_block_to_modedesc((char *) &(ediddata[dtd_offset]), mp);
                    mp->next = new_monitor->modelist;
                    new_monitor->modelist = mp;
                    dtd_offset += 18; /* 18 is the size of a DTD block */
d2888 1
@


4.24
log
@  Added 'CreateModeFile' instead of optional file name on ReadEDID
  now needs a file path for where to save the created mdf. It'll use the name in
  the EDID for the file name
Admin:
 tested in iMx6

Version 0.45. Tagged as 'ScrModes-0_45'
@
text
@d1662 1
d1668 1
a1668 1
    for (i = 0; i < 14; ++i)
d1673 6
a1678 1
            data[i] = 0;
d1681 1
a2106 1
      mode_desc->frame_hz = (int)ip_freq_rqd;
d2265 1
d2547 1
a2547 1
      res = _swix(OS_Module, _IN(0) | _IN(3) | _OUT(2), 6, length+24, &fbuf);
d2549 5
a2553 8
      if(!res) {
        fbuf[length] = 0;
        while((--length)>=0){
          fbuf[length] = file[length];
        }
        strcat (fbuf,".");
        strncat (fbuf,new_monitor->name,22);
        while(ptr=strpbrk(fbuf," "),ptr) {
d2558 4
a2561 1
        res = _swix(OS_Module, _IN(0) |_IN(2) , 7, fbuf);
@


4.23
log
@Fix bogus vertical bounds reported in MDF comments
Detail:
  c/ScrModes - Make sure compute_modedescription is used to initialise frame_mhz (and line_hz). Fixes bogus vertical bounds in MDF comments, and will fix order of modes as defined by sorting function modes_inorder.
  Also change horizontal bounds comment to use stored line_hz value instead of computing it on the fly
Admin:
  Tested on Pandaboard


Version 0.44. Tagged as 'ScrModes-0_44'
@
text
@d2100 1
a2258 1
    compute_modedescription(mode_desc);
d2282 1
a2282 1
static _kernel_oserror *parseedid(char *ediddata, FILE *f)
d2285 1
d2530 2
d2535 23
d2625 1
a2786 1
    FILE *f = NULL;
a2787 1

a2790 5
    if (file)
    {
       f = fopen (file, "w");
    }

d2833 1
a2833 5
      res = parseedid(ediddata,f);
    }

    if(f) {
      fclose(f);
a2836 1

d3641 3
@


4.22
log
@Numerous tweaks and fixes
Detail:
  c/ScrModes:
  - Double-checked all the DMT timings against the spec and corrected a few mistakes in both the DMT timings list and the established timings list.
  - Tidied up DMT & established timing formatting a bit, made static data arrays const
  - Fixed preferred mode handling so that it'll forget the preferred mode if you load an MDF after reading EDID (preferred_mode->bit0 used as a cheeky flag, in preference over malloc/free). Fixes crash/bad behaviour on startup caused by returning a duff preferred mode from Service_MonitorLeadTranslation on startup.
  - Added sanity checks to avoid null pointer dereferences if preferred_mode or new_preferred_mode are null
  - Fixed preferred mode handling to work correctly with interlaced modes (fixed it to use the frame width & height instead of the field width & height)
  - Tweaked CVT extension block handling - swapped the "- 17" with "- 18" in order to take into account the presence of the checksum byte
  - Tweaked GTF calculation to round pixel_khz to nearest when calculating it. I don't think this is mentioned in the spec, but when comparing some timings against the GTF spreadsheet this fixes ScreenModes being off by 1kHz in a few cases
  - When outputing an MDF, don't output display range parameters if the block wasn't found
  - Fix MDF output of interlaced modes (frame width/height vs. field width/height), use more accurate mHz frame rate value instead of Hz one
  - Make GraphicsV_IICOp calls use the correct GraphicsV driver number; current_graphicsv_driver() function added to replace ad-hoc code in a couple of other places
  - Fix reading of extension blocks. Also tweak logic to avoid re-reading the first block.
  - Initialise 'thefilename' when calling parseedid so that ERR_NOMODES will display something vaguely sensible
Admin:
  Tested on Raspberry Pi (ROM), Pandaboard (ROM), Iyonix (softload)
  Appears to read EDID correctly from test monitors (BenQ FP737s, BenQ FP241W, ADI TD-523N), but there are some minor discrepancies in MDF output for some modes


Version 0.43. Tagged as 'ScrModes-0_43'
@
text
@a1824 1
    mode_desc->frame_hz = (int)ip_freq_rqd;
d1851 1
a2099 1
      mode_desc->frame_hz = (int)ip_freq_rqd;
d2124 1
a2256 21
    /* Calculate the frequency for the mode description */
    int HTotal = mode_desc->definition.hpar[FR_SYNC] +
                 mode_desc->definition.hpar[FR_BPCH] +
                 mode_desc->definition.hpar[FR_BDR1] +
                 mode_desc->definition.hpar[FR_DISP] +
                 mode_desc->definition.hpar[FR_BDR2] +
                 mode_desc->definition.hpar[FR_FPCH];
    int VTotal = mode_desc->definition.vpar[FR_SYNC] +
                 mode_desc->definition.vpar[FR_BPCH] +
                 mode_desc->definition.vpar[FR_BDR1] +
                 mode_desc->definition.vpar[FR_DISP] +
                 mode_desc->definition.vpar[FR_BDR2] +
                 mode_desc->definition.vpar[FR_FPCH];

    mode_desc->line_hz = mode_desc->definition.pixel_khz * 1000 / HTotal;  /* compute line frequency in Hz */
    mode_desc->frame_mhz = mode_desc->line_hz * 1000 / VTotal; /* frame frequency in milliHz, high-prec */
    if (mode_desc->definition.interlaced) {
        mode_desc->frame_mhz /= 2; /* if interlaced, one frame is 2 fields */
    }
    mode_desc->frame_hz = (mode_desc->frame_mhz + 500) / 1000; /* & low-prec for user integer Hz matching */

d2258 1
d2573 1
a2573 2
        float tmp =(float)(this->definition.hpar[0]+this->definition.hpar[1]+this->definition.hpar[2]+this->definition.hpar[3]+this->definition.hpar[4]+this->definition.hpar[5]);
        fprintf(f,"\n# Bounds: H  %3.2fkHz, V %3.2f, DClock %3.2fMHz",((float)(this->definition.pixel_khz))/tmp,((float)(this->frame_mhz))/1000.0f,((float)(this->definition.pixel_khz))/1000.0f);
@


4.21
log
@  Corrected 'interlaced:' to 'interlaced'
Detail:
Admin:


Version 0.42. Tagged as 'ScrModes-0_42'
@
text
@d36 1
d92 6
d100 1
a100 1
static ModeDefinition display_monitor_timings[] = {
d104 1
a104 1
                    31500, -1,   2,   0, 85,   0,
d108 1
a108 1
                    31500, -1,   1,   0, 85,   0,
a109 1
    /* NB CHARACTER WIDTH OF 9, CHECK IMPLICATIONS OF THIS! */
d112 1
a112 1
                    35500, -1,   1,   0, 85,   0,
d116 1
a116 1
                    25175, -1,   3,   0, 60,   0,
d120 1
a120 1
                    31500, -1,   3,   0, 72,   0,
d124 1
a124 1
                    31500, -1,   3,   0, 75,   0,
d128 1
a128 1
                    36000, -1,   3,   0, 85,   0,
d132 1
a132 1
                    36000, -1,   0,   0, 56,   0,
d136 1
a136 1
                    40000, -1,   0,   0, 60,   0,
d140 1
a140 1
                    50000, -1,   0,   0, 72,   0,
d144 1
a144 1
                    49500, -1,   0,   0, 75,   0,
d146 1
a146 1
    "800 x 600",    800, 600,    8,  19, 0,  800, 0,  4,
d148 1
a148 1
                    56250, -1,   0,   0, 85,   0,
d152 1
a152 1
                    73250, -1,   2,   0, 120,  0,
d155 2
a156 2
                                23,   6, 0,  480, 0,  6,
                    33750, -1,   0,   0, 60,   0,
d159 2
a160 2
                                 4,  20, 0,  768, 0,  0,
                    44900, -1,   0,   1, 75,   0,
d163 2
a164 2
                                 6,  29, 0,  384, 0,  3,
                    65000, -1,   3,   0, 60,   0,
d168 1
a168 1
                    75000, -1,   3,   0, 70,   0,
d172 1
a172 1
                    78750, -1,   0,   0, 75,   0,
d176 1
a176 1
                    94500, -1,   0,   0, 85,   0,
d180 1
a180 1
                   115500, -1,   2,   0, 120,  0,
d184 1
a184 1
                   108800, -1,   0,   0, 75,   0,
d188 1
a188 1
                    68250, -1,   2,   0, 60,   0,
d192 1
a192 1
                    79500, -1,   1,   0, 60,   0,
d196 1
a196 1
                   102250, -1,   1,   0, 75,   0,
d200 1
a200 1
                   117500, -1,   1,   0, 85,   0,
d204 1
a204 1
                   140250, -1,   2,   0, 120,  0,
d208 1
a208 1
                    71000, -1,   2,   0, 60,   0,
d212 1
a212 1
                    83500, -1,   1,   0, 60,   0,
d216 1
a216 1
                   106500, -1,   1,   0, 75,   0,
d220 1
a220 1
                   122500, -1,   1,   0, 85,   0,
d224 1
a224 1
                   146250, -1,   2,   0, 120,  0,
d228 1
a228 1
                   108000, -1,   0,   0, 60,   0,
d232 1
a232 1
                   148500, -1,   0,   0, 85,   0,
d236 1
a236 1
                   175500, -1,   2,   0, 120,  0,
d240 1
a240 1
                   108000, -1,   0,   0, 60,   0,
d244 1
a244 1
                   135000, -1,   0,   0, 75,   0,
d248 1
a248 1
                   157500, -1,   0,   0, 85,   0,
d252 1
a252 1
                   187250, -1,   2,   0, 120, 0,
d256 1
a256 1
                    85500, -1,   0,   0, 60, 0,
d260 1
a260 1
                   148250, -1,   1,   0, 120, 0,
d264 1
a264 1
                   101000, -1,   2,   0, 60, 0,
d268 1
a268 1
                   121750, -1,   1,   0, 60, 0,
d272 1
a272 1
                   156000, -1,   1,   0, 75, 0,
d276 1
a276 1
                   179500, -1,   1,   0, 75, 0,
d280 1
a280 1
                   208000, -1,   2,   0, 120, 0,
d284 1
a284 1
                   88750, -1,    2,   0, 60, 0,
d288 1
a288 1
                  106500, -1,    1,   0, 60, 0,
d292 1
a292 1
                  136750, -1,    1,   0, 75, 0,
d296 1
a296 1
                  157000, -1,    1,   0, 85, 0,
d300 1
a300 1
                  182750, -1,    2,   0, 120, 0,
d304 1
a304 1
                  162000, -1,    0,   0, 60, 0,
d308 1
a308 1
                  175500, -1,    0,   0, 65, 0,
d312 1
a312 1
                  189000, -1,    0,   0, 70, 0,
d316 1
a316 1
                  202500, -1,    0,   0, 75, 0,
d320 1
a320 1
                  229500, -1,    0,   0, 85, 0,
d324 1
a324 1
                  268250, -1,    2,   0, 120, 0,
d328 1
a328 1
                  119000, -1,    2,   0, 60, 0,
d332 1
a332 1
                  146250, -1,    1,   0, 60, 0,
d336 1
a336 1
                  187000, -1,    1,   0, 75, 0,
d340 1
a340 1
                  214750, -1,    1,   0, 85, 0,
d344 1
a344 1
                  245500, -1,    2,   0, 120, 0,
d348 1
a348 1
                  204750, -1,    1,   0, 60, 0,
d352 1
a352 1
                  261000, -1,    1,   0, 75, 0,
d356 1
a356 1
                  333250, -1,    2,   0, 120, 0,
d360 1
a360 1
                  218250, -1,    1,   0, 60, 0,
d364 1
a364 1
                  288000, -1,    1,   0, 75, 0,
d368 1
a368 1
                  356500, -1,    2,   0, 85, 0,
d372 1
a372 1
                  154000, -1,    2,   0, 60, 0,
d376 1
a376 1
                  193250, -1,    1,   0, 60, 0,
d380 1
a380 1
                  245250, -1,    1,   0, 75, 0,
d384 1
a384 1
                  281250, -1,    1,   0, 85, 0,
d388 1
a388 1
                  317000, -1,    2,   0, 120, 0,
d392 1
a392 1
                  234000, -1,    1,   0, 60, 0,
d396 1
a396 1
                  297000, -1,    1,   0, 75, 0,
d400 1
a400 1
                  380500, -1,    2,   0, 120, 0,
d404 1
a404 1
                  268500, -1,    2,   0, 60, 0,
d408 1
a408 1
                  348500, -1,    1,   0, 60, 0,
d411 2
a412 2
                                 6, 63,  0, 1600, 0, 3,
                  443250, -1,    1,   0, 75, 0,
d416 1
a416 1
                  505250, -1,    1,   0, 85, 0,
d420 1
a420 1
                  552750, -1,    2,   0, 120, 0
d431 5
a435 2
static char established_timings[] = {
    0, 0, 4, 0, 5, 6, 8, 9, 0xa, 0xb, 0, 0xf, 0x10, 0x11, 0x12, 0x24, 0
d438 8
a445 5
static char established_timings3[] = {
    0x01, 0x02, 0x03, 0x07, 0x0e, 0x0c, 0x13, 0x15, 0x16, 0x17, 0x18, 0x19,
    0x20, 0x21, 0x23, 0x25, 0x27, 0x2e, 0x2f, 0x30, 0x31, 0x29, 0x2a, 0x2b,
    0x2c, 0x39, 0x3a, 0x3b, 0x3c, 0x36, 0x37, 0x3e, 0x3f, 0x41, 0x42, 0x44,
    0x45, 0x46, 0x47, 0x49, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00
d455 1
a455 1
static STDTiming std_timings[] = {
d1538 2
d1846 1
a1846 1
    mode_desc->definition.pixel_khz = (int) (pixel_freq * 1000);
d2308 1
a2308 1
    int RangeBlock = 0;                           /* edid block containing timimg limits */
d2504 1
a2504 1
        debug printf("%o Extension block(s) found\n", edidblockref->extension_block_count);
d2524 1
a2524 1
                       (dtd_offset < ((128 * (edidblockref->extension_block_count + 1)) - 17)))
d2558 16
a2573 14
      uint8_t flags = edidblockref->data_block[RangeBlock][4];
      int vmin=0,vmax=0,hmin=0,hmax=0, pixmax=0;
      if((flags&0x3)==0x2) {vmax=255;}
      if((flags&0x3)==0x2) {vmax=255; vmin=255;}
      if((flags&0xc)==0x8) {hmax=255;}
      if((flags&0xc)==0xc) {hmax=255; hmin=255;}
      vmin+=edidblockref->data_block[RangeBlock][5];
      vmax+=edidblockref->data_block[RangeBlock][6];
      hmin+=edidblockref->data_block[RangeBlock][7];
      hmax+=edidblockref->data_block[RangeBlock][8];
      pixmax=edidblockref->data_block[RangeBlock][9];
      fprintf(f,"# Line rate:     %2d - %2dkHz\n",hmin,hmax);
      fprintf(f,"# Frame rate:    %2d - %2dHz\n",vmin,vmax);
      fprintf(f,"# Max Dot rate: %3dMHz (rounded down)\n",pixmax*10);
d2587 1
a2587 1
   if(new_monitor->dpms_state!=-1) {
d2592 1
a2592 1
        fprintf(f,"\n# Mode:  %d x %d @@ %dHz",this->definition.hpar[FR_DISP],this->definition.vpar[FR_DISP],this->frame_hz);
d2594 1
a2594 1
        fprintf(f,"\n# Bounds: H  %3.2fkHz, V %3.2f, DClock %3.2fMHz",((float)(this->definition.pixel_khz))/tmp,(float)(this->frame_hz),(float)(this->definition.pixel_khz)/1000);
d2596 3
a2598 3
        fprintf(f,"\n mode_name:%d x %d",this->definition.hpar[FR_DISP],this->definition.vpar[FR_DISP]);
        fprintf(f,"\n x_res:%d",this->definition.hpar[FR_DISP]);
        fprintf(f,"\n y_res:%d",this->definition.vpar[FR_DISP]);
d2647 14
a2660 7
         preferred_mode->bit0 = 1;
         preferred_mode->format = 0;
         preferred_mode->xresol = new_preferred_mode->definition.hpar[FR_DISP];
         preferred_mode->yresol = new_preferred_mode->definition.vpar[FR_DISP];
         preferred_mode->depth = 5;
         preferred_mode->framerate = new_preferred_mode->frame_hz;
         preferred_mode->param[0].index = -1;
d2756 1
a2756 1
static _kernel_oserror *readedidblock (EDIDBlockRef edidblock, int count)
d2759 2
a2760 2
    int iic_code = (0xa1 << 16) | (0 << 0);
    int op_code = (0 << 24) | (0 << 16) | (14 << 0);
d2762 1
a2762 1
    res = _swix(OS_CallAVector, _INR(0,2) | _IN(4) | _IN(9) | _OUT(0) | _OUT(4), iic_code, edidblock, 0x80*count, op_code, 42, &iic_code, &op_code);
a2767 1
        /*res = error (iic_code, 0, 0, 0);*/
d2794 1
a2794 1
    res = readedidblock (edidblock, 1);
d2815 3
d2819 1
a2819 2
                /* TO DO NOW READ THE ADDITIONAL EDID DATA HERE */
                res = readedidblock (edidblock, edidblock->extension_block_count + 1);
d2832 2
d2876 10
d3017 1
a3017 4
    int variables[2];
    variables[0] = VduExt_CurrentGraphicsVDriver;
    variables[1] = -1;
    _swix(OS_ReadVduVariables,_INR(0,1),variables,variables);
d3019 1
a3019 1
    r.r[4] = GraphicsV_PixelFormats | (variables[0]<<24);
d3043 1
a3043 1
        r.r[4] = GraphicsV_DisplayFeatures | (variables[0]<<24);
d3055 1
a3055 1
    r.r[4] = GraphicsV_VetMode | (variables[0]<<24);
d3264 1
a3264 4
    int variables[2];
    variables[0] = VduExt_CurrentGraphicsVDriver;
    variables[1] = -1;
    _swix(OS_ReadVduVariables,_INR(0,1),variables,variables);
d3266 1
a3266 1
    r.r[4] = GraphicsV_PixelFormats | (variables[0]<<24);
d3529 4
a3532 1
               res = readedid(0,NULL);
d3549 1
a3549 1
  if (preferred_mode != NULL)
d3572 4
d3593 4
a3596 1
    free(preferred_mode);
d3647 1
a3647 1
                result = readedid (0,arg_string);
@


4.20
log
@  Made safer to deploy in current ROMS, and added further stuff to generated mdf
Detail:
  Added several things
  1) Readedid routine not called in module initialise.
  2) Flag added to determine whether old loadmodefile usage, or new readedid usage.
     Defaults to loadmodefile mode until a readedid command with no parameters,
     then swirches to edid reading mode. Reverts again if loadmodefile command is used.
  3) Tidied up error message when graphicsv fails to read the edid due to connectivity
     issues.
  4) Added hex dump of edid data blocks read to end of a saved mdf file.
  5) Implemented read of second ans subsequent 128 byte edid blocks, if required.

Admin:
  tested in imx rom

Version 0.41. Tagged as 'ScrModes-0_41'
@
text
@d2588 1
a2588 1
          fprintf(f,"\n interlaced:");
@


4.19
log
@  Extended to optionally generate a saved mdf instead of updating the current loaded mdf.
Detail:
  For field support it is extremely helpful to determine what a customer's monitor
  reports. Whilst (hopefully) this module will correctly produce modes the monitor
  can handle and the computer generate, when that doesn't happen support types need
  to be able to find out why, ideally using the same exact information that is generated.
  So:
  The ReadEDID command, if called with a full file name, will now save the discovered
  mdf information to that file instead of loading it.
  The resultant mdf can be used directly, or used as the basis for further
  modifications. It exports additional information in the header section
  which may prove helpful to 'mdf tweakers'.
Admin:
  Tested in imx rom. In 'advertised' use it is the same code as before. It is
  only when the  filename is given to the readedid command that different paths
  are invoked. Further enhancements may be desirable.

Version 0.40. Tagged as 'ScrModes-0_40'
@
text
@d52 5
d1469 1
d2290 1
a2290 1
    _kernel_oserror *res;
d2295 3
d2309 1
a2309 1
    new_monitor->lcd_support = 0; /* 'CRT by default' - what does this do??? */
d2538 1
a2538 2
    if(f)
    {
d2561 1
a2561 2
      switch(timing_support)
      {
d2568 1
a2568 1
      fprintf(f,"# Use %s timing rules\n",rules);
d2570 4
a2573 1
      fprintf(f,"file_format:1\nmonitor_title:%s\nDPMS_state:%d\n",new_monitor->name,(new_monitor->dpms_state==-1)?0:new_monitor->dpms_state);
d2575 17
a2591 15
      do
      {
         fprintf(f,"\n# Mode:  %d x %d @@ %dHz",this->definition.hpar[FR_DISP],this->definition.vpar[FR_DISP],this->frame_hz);
         float tmp =(float)(this->definition.hpar[0]+this->definition.hpar[1]+this->definition.hpar[2]+this->definition.hpar[3]+this->definition.hpar[4]+this->definition.hpar[5]);
         fprintf(f,"\n# Bounds: H  %3.2fkHz, V %3.2f, DClock %3.2fMHz",((float)(this->definition.pixel_khz))/tmp,(float)(this->frame_hz),(float)(this->definition.pixel_khz)/1000);
         fprintf(f,"\nstartmode");
         fprintf(f,"\n mode_name:%d x %d",this->definition.hpar[FR_DISP],this->definition.vpar[FR_DISP]);
         fprintf(f,"\n x_res:%d",this->definition.hpar[FR_DISP]);
         fprintf(f,"\n y_res:%d",this->definition.vpar[FR_DISP]);
         fprintf(f,"\n pixel_rate:%d",this->definition.pixel_khz);
         fprintf(f,"\n h_timings:%d,%d,%d,%d,%d,%d",this->definition.hpar[0],this->definition.hpar[1],this->definition.hpar[2],this->definition.hpar[3],this->definition.hpar[4],this->definition.hpar[5]);
         fprintf(f,"\n v_timings:%d,%d,%d,%d,%d,%d",this->definition.vpar[0],this->definition.vpar[1],this->definition.vpar[2],this->definition.vpar[3],this->definition.vpar[4],this->definition.vpar[5]);
         fprintf(f,"\n sync_pol:%d",this->definition.syncpol);
         fprintf(f,"\nEndMode\n");
         this = this->next;  /* will be NULL at list end*/
d2593 11
a2603 1
      fprintf(f,"#End\n");
d2616 8
a2623 9
       if (res != NULL)
       {
           _kernel_oserror *res2;
           debug printf ("setting of monitor type to type `FILE' failed\n");
           res2 = restore_monitortype (); /* restore old value */
           if (res2 != NULL)
           {
               debug printf ("couldn't reset monitor type to CMOS default!\n");
           }
d2625 29
a2653 30
       else
       {
           _kernel_swi_regs regs;
           release_currentmonitor ();
           current_monitor = new_monitor;

           /* Set up the mode specifier */
           preferred_mode->bit0 = 1;
           preferred_mode->format = 0;
           preferred_mode->xresol = new_preferred_mode->definition.hpar[FR_DISP];
           preferred_mode->yresol = new_preferred_mode->definition.vpar[FR_DISP];
           preferred_mode->depth = 5;
           preferred_mode->framerate = new_preferred_mode->frame_hz;
           preferred_mode->param[0].index = -1;

           /* Set the preferred sync type from video input definition bit 3. */
           /* (ref EDID spec table 3.11) */
           if ((edidblockref->video_input_definition & 0x8) == 0x8) {
               preferred_sync_type = 0;
           }
           else {
               preferred_sync_type = 1;
           }

           debug printf("Monitor type changed\n");

           /* Newly defined monitor, announce it */
           regs.r[1] = Service_ModeFileChanged;
           _kernel_swi (OS_ServiceCall, &regs, &regs);
           debug printf("Service_ModeFileChanged issued\n");
d2733 1
a2733 1
static _kernel_oserror *readedid (const char *file)
a2735 13
    FILE *f = NULL;
    EDIDBlockRef edidblock = (EDIDBlockRef) malloc(128);

    if (edidblock == NULL) {
        return error (ERR_NOSPACE, 0, 0, 0);
    }
    if (file)
    {
       f = fopen (file, "w");
    }

    debug printf ("ReadEDID called\n");

d2739 1
a2739 1
    res = _swix(OS_CallAVector, _INR(0,2) | _IN(4) | _IN(9) | _OUT(0) | _OUT(4), iic_code, edidblock, 0x80, op_code, 42, &iic_code, &op_code);
d2745 2
a2746 1
        res = error (iic_code, 0, 0, 0);
d2753 20
d2795 2
d2806 3
a2808 2
        debug printf ("Parsing EDID block\n");
        res = parseedid(ediddata,f);
d3499 1
a3499 1
               res = readedid(NULL);
d3542 1
a3542 2

    readedid(NULL);
d3607 1
a3607 1
                result = readedid (arg_string);
@


4.18
log
@Added prototype EDID support code.

This should be considered beta-quality work-in-progress code that gives us a
new *command (ReadEDID) that attempts to read the list of supported display
mode information from a connected monitory and configure the system for it,
as if an MDF file had been loaded containing that information.

Admin:

Community testing is required for this feature. Please try replacing the
LoadModeFile line in your !Boot.Choices.Boot.PreDesk.Configure.Monitor
file with a line saying "ReadEDID". If you get a sensible looking list
of modes when the machine boots, then things should be OK. If you see an
error, please get in touch with ROOL on the "Bounties - ReadEDID" topic.
You'll clearly need to be running a ROM with this version of ScreenModes
in it!

Version 0.39. Tagged as 'ScrModes-0_39'
@
text
@d2282 1
a2282 1
static _kernel_oserror *parseedid(char *ediddata)
d2288 1
d2418 3
d2529 22
d2552 10
a2561 7
    /* Below taken from the loadmodefile code
     * If we haven't got a file loaded at present, then
     * read current monitortype, to restore on module shutdown
     */
    if (old_monitortype == -1) {
        old_monitortype = read_monitortype ();
    }
d2563 19
a2581 10
    res = set_monitortype (MONITOR_FILE);
    if (res != NULL)
    {
        _kernel_oserror *res2;
        debug printf ("setting of monitor type to type `FILE' failed\n");
        res2 = restore_monitortype (); /* restore old value */
        if (res2 != NULL)
        {
            debug printf ("couldn't reset monitor type to CMOS default!\n");
        }
d2585 50
a2634 28
        _kernel_swi_regs regs;
        release_currentmonitor ();
        current_monitor = new_monitor;

        /* Set up the mode specifier */
        preferred_mode->bit0 = 1;
        preferred_mode->format = 0;
        preferred_mode->xresol = new_preferred_mode->definition.hpar[FR_DISP];
        preferred_mode->yresol = new_preferred_mode->definition.vpar[FR_DISP];
        preferred_mode->depth = 5;
        preferred_mode->framerate = new_preferred_mode->frame_hz;
        preferred_mode->param[0].index = -1;

        /* Set the preferred sync type from video input definition bit 3. */
        /* (ref EDID spec table 3.11) */
        if ((edidblockref->video_input_definition & 0x8) == 0x8) {
            preferred_sync_type = 0;
        }
        else {
            preferred_sync_type = 1;
        }

        debug printf("Monitor type changed\n");

        /* Newly defined monitor, announce it */
        regs.r[1] = Service_ModeFileChanged;
        _kernel_swi (OS_ServiceCall, &regs, &regs);
        debug printf("Service_ModeFileChanged issued\n");
d2663 1
a2663 1
            parseedid(edidblock);
d2713 1
a2713 1
static _kernel_oserror *readedid (void)
d2716 1
d2722 4
d2732 1
a2732 1
    res = _swix(OS_CallAVector, _INR(0,2) | _IN(4) | _IN(9) | _OUT(0) | _OUT(4), iic_code, edidblock, 0x7f,op_code, 42, &iic_code, &op_code);
a2736 1

d2749 1
a2749 1
    }
d2777 5
a2781 1
        res = parseedid(ediddata);
d3468 1
a3468 1
               res = readedid();
d3512 1
a3512 1
    readedid();
d3577 1
a3577 1
                result = readedid ();
@


4.17
log
@Pay attention to Service_DisplayChanged
Detail:
  c/ScrModes, cmhg/ScrModesv - Fire off Service_ModeFileChanged whenever we receive Service_DisplayChanged, so that our clients are informed of the fact the mode list may have changed
Admin:
  Tested on Iyonix, BB-xM


Version 0.38. Tagged as 'ScrModes-0_38'
@
text
@d26 1
d37 2
d45 3
d52 7
d66 17
a82 17
#define keywordset \
 "x_res\0         " \
 "y_res\0         " \
 "h_timings\0     " \
 "v_timings\0     " \
 "pixel_rate\0    " \
 "sync_pol\0      " \
 "external_clock\0" \
 "mode_name\0     " \
 "file_format\0   " \
 "monitor_title\0 " \
 "dpms_state\0    " \
 "lcd_support\0   " \
 "interlaced\0    " \
 "output_format\0 " \
 "startmode\0     " \
 "endmode"
d86 369
d462 1
a462 2
    /*
     * First in the set are those keywords which may be encountered
d489 2
a490 2
    k_nokey,                            /* identifer not recog. as keyword */
    k_eof                               /* end of file */
d509 5
d544 1
a544 1
    if ((res = _kernel_swi (MessageTrans_OpenFile, &r, &r)) != NULL)
d546 1
d563 1
a563 1
    if (res)
d565 1
d597 1
a597 1
        if (*text == '\0')
d599 1
d620 1
a620 1
    if (f != NULL)
d622 1
d661 1
a661 1
    if (thefile.ptr < thefile.lim)
d663 2
a664 1
    else
d666 1
d668 1
a668 1
    if (c == '\n')
d670 1
d686 1
a686 1
        if (c == '\n')
d688 1
d775 1
a775 1
    if (c == EOF)
d777 1
d781 1
d783 1
d799 1
a799 1
    if (c == ch)
d801 2
a802 1
    if (c == EOF)
d804 1
d812 1
a812 1
    if (c == '\n' || (eofok && c == EOF))
d814 2
a815 1
    if (c == EOF)
d817 1
d843 1
a843 1
        if (i < size-1)
d845 1
d853 1
a853 1
                    if (excess == 1)
d855 1
d860 1
a860 1
    if (c == EOF)
d862 1
d876 1
a876 1
    if (!isdigit (c))
d878 1
d884 1
a884 1
            (acc == UINT32_MAX/10 && digit > UINT32_MAX%10))
d886 1
d897 1
a897 1
    if (res)
d899 2
a900 1
    if (fault_zero && *var == 0)
d902 1
d910 1
a910 1
    if (kc == k_eof)                    /* we never explicitly look for k_eof */
d912 2
a913 1
    if (kc != code)
d915 2
a916 1
    if (colon)
d918 2
a919 1
    else
d921 1
d938 1
a938 1
            if (keyseen & (1 << kc))
d940 1
d942 1
a942 1
            if (res)
d944 1
d974 1
a974 1
                if (missed & (1 << k_mode_name))
d976 2
a977 1
                else
d979 1
d982 6
a987 2
            if (!(keyseen & (1 << k_x_res))) mode->xres = mode->hpar[FR_DISP];
            if (!(keyseen & (1 << k_y_res))) mode->yres = mode->vpar[FR_DISP];
d990 1
a990 1
            if (mode->xres != mode->hpar[FR_DISP] || mode->yres != mode->vpar[FR_DISP] * (mode->interlaced+1))
d992 1
d1004 1
a1004 1
            if (res)
d1006 1
d1011 1
a1011 1
            if (res)
d1013 1
d1018 1
a1018 1
            if (res)
d1020 1
d1025 1
a1025 1
            if (res)
d1027 2
a1028 1
            if (param > 3)      /* must fit in (currently) 2 bits */
d1030 1
d1037 1
a1037 1
            if (res)
d1039 1
d1044 1
a1044 1
            if (res)
d1046 1
d1056 1
a1056 1
            if (res)
d1058 1
d1070 1
a1070 1
                    if (res)
d1072 2
a1073 1
                    if (param >= 0x10000)       /* must fit in 16 bits (unsigned) */
d1075 1
d1078 1
a1078 1
                    if (pn < FR__COUNT-1)
d1080 1
d1082 1
a1082 1
                if (par[FR_DISP] == 0)
d1084 1
d1087 1
a1087 1
                if (res)
d1089 1
d1108 3
a1110 1
    if (mp->interlaced) md->frame_mhz /= 2; /* if interlaced, one frame is 2 fields */
d1126 1
a1126 1
            if (res)
d1128 1
d1130 1
a1130 1
            if (mp == NULL)
d1132 1
d1142 1
a1142 1
            if (res)
d1144 1
d1146 1
a1146 1
            if (mp->definition.external_clock == -1)
d1148 1
d1156 1
a1156 1
                if (strcmp (rp->definition.name, mp->definition.name) == 0)
d1158 1
d1166 1
a1166 1
            if (monitor->modelist != NULL)
d1168 1
d1187 1
a1187 1
    if (res)
d1189 1
d1191 1
a1191 1
    if (res)
d1193 2
a1194 1
    if (ffmt != 1)
d1196 1
d1199 1
a1199 1
    if (res)
d1201 1
d1204 1
a1204 1
    if (md == NULL)
d1206 1
d1211 1
a1211 1
    md->modelist = NULL;                /* to start with */
d1217 2
a1218 3
    if (res == NULL)
    {
        md->dpms_state = -1;                     /* indicates field not present */
d1224 7
a1230 2
                res = read_one_u32 (&md->dpms_state, 0);    /* read DPMS_state value */
            if (res == NULL) kc = read_keyword ();          /* then read next keyword */
d1237 2
a1238 3
    if (res == NULL)
    {
        md->lcd_support = 0;                                /* Indicates CRT as default */
d1243 5
a1247 4
            if (res == NULL)
            {
                res = read_one_u32 (&md->lcd_support, 0);    /* read LCD_support value */
                if (md->lcd_support != 0) md->dpms_state = -1;    /* LCD and DPMS are mutually exclusive */
d1250 3
a1252 1
            if (res == NULL) kc = read_keyword ();          /* then read next keyword */
d1259 1
a1259 2
    if (res == NULL)
    {
d1264 1
a1264 2
            if (res == NULL)
            {
d1267 3
a1269 1
            if (res == NULL) kc = read_keyword ();          /* then read next keyword */
d1276 2
a1277 3
    if (res == NULL)
    {
        md->external_clock = -1;                            /* indicates field not present */
d1281 6
a1286 3
            if (res == NULL)
                res = read_one_u32 (&md->external_clock, 0);/* read external_clock value */
            if (res == NULL) kc = read_keyword ();          /* then read next keyword */
d1290 1
a1290 2
    if (res == NULL)
    {
d1292 1
a1292 1
        res = parse_modelist (md, kc);          /* pass in read keyword token */
d1295 1
a1295 2
    if (res)
    {
d1314 1
a1314 1
    if (m1->definition.xres < m2->definition.xres)
d1316 2
a1317 1
    if (m1->definition.xres > m2->definition.xres)
d1319 2
a1320 1
    if (m1->definition.yres < m2->definition.yres)
d1322 2
a1323 1
    if (m1->definition.yres > m2->definition.yres)
d1325 2
a1326 1
    if (m1->frame_mhz > m2->frame_mhz)
d1328 2
a1329 1
    if (m1->frame_mhz < m2->frame_mhz)
d1331 2
a1332 1
    if (m1->definition.pixel_khz < m2->definition.pixel_khz)
d1334 2
a1335 1
    if (m1->definition.pixel_khz > m2->definition.pixel_khz)
d1337 1
d1351 2
a1352 4
        while (next)
        {
            if (!modes_inorder (this, next))
            {
d1355 1
a1355 1
                if (prev == NULL)
d1357 2
a1358 1
                else
d1360 1
d1391 6
a1396 1
    if (res) return -1; else return regs.r[1];
d1402 1
a1402 2
    if (temp != -1)
    {
d1406 1
a1406 2
    else
    {
d1422 1
a1422 1
        printf ("%p: Mode name \"%s\"\n", mode, mode->definition.name);
d1436 4
a1439 3
        if (dp->interlaced) printf("  Interlaced\n");
        for (log2bpp = 0; log2bpp <= 5; ++log2bpp)
        {
d1442 1
a1442 2
            if (bits < 8)
            {
d1448 1
a1448 2
            else
            {
d1453 1
a1453 2
            printf ("  %2u bpp: bandwidth %6u000 bytes/sec, data size %7u bytes\n",
                    bits, drate, dsize);
d1460 1
a1460 1
static _kernel_oserror *loadmodefile (const char *file)
d1463 1
a1464 6
    res = open_modefile (file);
    if (res != NULL)
        debug printf ("failed to open modefile\n");
    else
    {
        MonitorDescriptionRef new_monitor;
d1469 1
a1469 1
        if (res != NULL)
d1471 1
d1482 3
a1484 1
            if (old_monitortype == -1) old_monitortype = read_monitortype ();
d1494 3
a1496 2
                    if (res2 != NULL)
                        printf ("couldn't reset monitor type to CMOS default!\n");
d1504 1
a1504 2
                if (path != NULL)
                {
d1508 1
a1508 2
                    if (dot != NULL)
                    {
d1517 1
a1517 1
                
a1525 1
    }
d1529 5
a1533 12
/* List of new PixelFormats available from old GraphicsV_DisplayFeatures */
static PixelFormat oldformats[] = {
    {1,0,0},
    {3,0,1},
    {15,0,2},
    {255,ModeFlag_FullPalette,3},
    {65535,0,4},
    {-1,0,5},
};

/* Convert an old pixel depth value to a PixelFormat value */
static void pixelformat_from_depth(PixelFormatRef pf,int depth)
d1535 24
a1558 3
    pf->log2bpp = depth;
    pf->ncolour = (1<<(1<<depth))-1;
    pf->modeflags = (depth==3?ModeFlag_FullPalette:0);
d1560 1
d1562 6
a1567 2
/* Can this PixelFormat be represented as a pixel depth? (if so, pf->log2bpp is the value) */
static bool is_old_format(const PixelFormatRef pf)
d1569 17
a1585 8
    if(pf->log2bpp > 5)
        return false;
    if(pf->ncolour != (1<<(1<<pf->log2bpp))-1)
        return false;
    if(pf->modeflags != (pf->log2bpp==3?ModeFlag_FullPalette:0))
        return false;
    return true;
}
d1587 7
a1593 9
static void build_a_vidclist (VIDCListRef vp, ModeDescriptionRef mp, const PixelFormatRef pf)
{
    int fn;
    int ctrllistpos = 0;
    
    /* Fill in the fields */
    vp->format = 3;
    vp->depth = pf->log2bpp;
    for (fn = 0; fn < FR__COUNT; ++fn)
d1595 1
a1595 2
        vp->hpar[fn] = mp->definition.hpar[fn];
        vp->vpar[fn] = mp->definition.vpar[fn];
d1597 4
a1600 2
    vp->pixelrate = mp->definition.pixel_khz;
    vp->syncpol = mp->definition.syncpol;
d1602 33
a1634 9
    /* Only specify ModeFlags & NColour if necessary? */
    if(!is_old_format(pf))
    {
        vp->vcparam[ctrllistpos].index = NCOLOUR_INDEX;
        vp->vcparam[ctrllistpos].value = pf->ncolour;
        ctrllistpos++;
        vp->vcparam[ctrllistpos].index = MODEFLAGS_INDEX;
        vp->vcparam[ctrllistpos].value = pf->modeflags;
        ctrllistpos++;
d1637 11
a1647 8
    if (current_monitor->dpms_state != -1)
    {
        vp->vcparam[ctrllistpos].index = DPMS_INDEX;
        vp->vcparam[ctrllistpos].value = current_monitor->dpms_state;
        ctrllistpos++;
    }
    
    if (current_monitor->lcd_support != 0)
d1649 2
a1650 5
        debug printf("I'm an LCD panel & I'm going to tell the Kernel!\n");
        vp->vcparam[ctrllistpos].index = LCDMODE_INDEX;
        vp->vcparam[ctrllistpos].value = LCDMODE_VALUE;
        ctrllistpos++;
        if (current_monitor->lcd_support != 3)
d1652 1
a1652 3
            vp->vcparam[ctrllistpos].index = LCDDUAL_INDEX;
            vp->vcparam[ctrllistpos].value = LCDDUAL_VALUE;
            ctrllistpos++;
a1653 9
        vp->vcparam[ctrllistpos].index = LCDOFF0_INDEX;
        vp->vcparam[ctrllistpos].value = LCDOFF0_VALUE;
            ctrllistpos++;
        vp->vcparam[ctrllistpos].index = LCDOFF1_INDEX;
        vp->vcparam[ctrllistpos].value = LCDOFF1_VALUE;
            ctrllistpos++;
        vp->vcparam[ctrllistpos].index = DACCTRL_INDEX;
        vp->vcparam[ctrllistpos].value = DACCTRL_VALUE;
            ctrllistpos++;
d1655 34
a1688 2
    
    if (mp->definition.external_clock != -1)
d1690 3
a1692 3
        vp->vcparam[ctrllistpos].index = HCLK_INDEX;
        vp->vcparam[ctrllistpos].value = mp->definition.external_clock;
        ctrllistpos++;
d1694 1
a1694 2
    
    if (mp->definition.interlaced)
d1696 3
a1698 3
        vp->vcparam[ctrllistpos].index = INTERLACED_INDEX;
        vp->vcparam[ctrllistpos].value = 1;
        ctrllistpos++;
d1700 1122
a2821 1
    
d2828 1
a2828 1
    
d2855 1
a2855 1
        return 0; 
d2858 1
a2858 1
    if ((bpp > 4) && (current_monitor->lcd_support == 1))
d2860 1
d2877 1
a2877 1
    if (datarate > maxdatarate || datasize > maxdatasize)
d2879 1
d2914 1
a2914 1
        if ((r.r[4] == 0) && ((r.r[1] & (1<<pf->log2bpp)) == 0))
d2916 1
d2926 1
a2926 1
    if ((r.r[4] == 0) && (r.r[0] != 0))
d2928 1
d2970 1
a2970 1
    
d3016 1
a3016 1
    if (!IS_MODE_SEL_PTR (regs->r[2]))
d3018 1
d3025 1
a3025 1
    if (regs->r[3] != -1 && regs->r[3] != MONITOR_FILE)
d3027 1
d3035 1
a3035 1
    if (sel->bit0 != 1 || sel->format != 0)
d3037 1
d3096 1
a3096 1
    if (mp == NULL)
d3098 1
d3123 1
a3123 1
    _kernel_swi_regs r; 
d3151 1
a3151 1
    
d3171 1
a3171 1
        {   
d3182 1
a3182 1
                if (!old_format)
d3184 1
d3194 1
a3194 1
    
d3202 1
a3202 1
    
d3213 1
a3213 1
    
d3221 1
a3221 1
    
d3252 1
a3252 1
            if (mp == NULL)
d3254 1
d3267 1
a3267 1
    if (mp == NULL)
d3269 1
d3294 1
a3294 1
    if (regs->r[3] != 7 || !current_monitor)
d3296 1
d3319 1
a3319 1
              regs->r[2], 9, &depth, &flags) || (flags & _C))
d3321 1
d3327 1
a3327 1
    if (depth > 3)
d3329 1
d3392 1
d3400 2
a3401 1
            /* TODO read EDID here */
d3414 12
d3437 12
d3458 1
d3463 1
a3463 1
    
d3471 1
a3471 1
    if (current_monitor == NULL)
d3473 1
d3476 3
a3478 1
    if (!we_are_preferred (pw)) return;
d3480 1
a3480 1
    if (servicecallno == Service_ModeExtension)
d3482 2
a3483 1
    else if (servicecallno == Service_EnumerateScreenModes)
d3485 2
a3486 1
    else if (servicecallno == Service_ModeTranslation)
d3488 2
a3489 1
    else if (servicecallno == Service_DisplayChanged)
d3491 4
d3508 3
a3510 1

d3554 1
a3554 1
    
@


4.16
log
@Update to add support for new pixel formats and basic support for multiple GraphicsV drivers
Detail:
  c/ScrModes - All GraphicsV calls now use the current driver number instead of always calling driver 0. Get the list of supported pixel formats via GraphicsV 17 if implemented, otherwise fall back to GraphicsV 8. Generate old or new style mode provider blocks as appropriate.
  h/modex - Update definitions for new mode provider block format, new control list items
Admin:
  Tested in Tungsten, IOMD, OMAP3, BCM2835 ROMs
  Requires HdrSrc-2_38 and Kernel-5_35-4_79_2_203


Version 0.36. Tagged as 'ScrModes-0_36'
@
text
@d1726 22
d1792 2
@


4.15
log
@Filter out impossible modes from a modefile super set
New function, build_a_vidclist() allows the GraphicsV Vet_Mode entry point to be called when validating a mode, so the graphics driver can decide on a mode by mode basis whether it can be achieved.
This resolves the problem where an MDF has a super set of modes that the hardware only supports a subset of.
Also
* Inlined inform_modefilechanged
* Removed redundant CFLAGS from makefile
* Made a few braces and spaces consistent with their surroundings

Tested in an IOMD ROM build on a machine with and without VRAM fitted, looking in display manager that the menus are rebuilt accordingly.
Fixes ticket #315.

Version 0.35. Tagged as 'ScrModes-0_35'
@
text
@d27 1
d34 1
d1071 31
a1101 1
static void build_a_vidclist (VIDCListRef vp, ModeDescriptionRef mp, uint8_t log2bpp)
d1108 1
a1108 1
    vp->depth = log2bpp;
d1116 12
a1127 1
    
d1188 1
a1188 1
static int mode_valid (ModeDescriptionRef mp, uint8_t depth,
d1200 7
d1208 1
a1208 1
    if ((depth > 2) && (current_monitor->lcd_support == 1))
d1211 1
a1211 1
    if (depth < 3)
d1213 1
a1213 1
        uint8_t shift = 3 - depth;
d1220 3
a1222 3
        uint8_t shift = depth - 3;
        datarate = pixrate << shift;
        datasize = pixels << shift;
d1230 6
a1235 1
    r.r[4] = GraphicsV_DisplayFeatures;
d1238 27
a1264 2
    if ((r.r[4] == 0) && ((r.r[1] & (1<<depth)) == 0))
        return 0;    /* Had a definitive answer from GraphicsV that this bpp is forbidden */
d1267 1
a1267 1
    build_a_vidclist (&vetlist, mp, depth);
d1270 1
a1270 1
    r.r[4] = GraphicsV_VetMode;
d1356 1
d1382 34
d1445 1
a1445 1
             mode_valid (mp, sel->depth, dataratelimit, datasizelimit))
d1447 1
a1447 1
            build_a_vidclist (&thevidclist, mp, sel->depth); /* use the local static structure */
d1463 3
a1465 1
    int depth;                          /* logarithmic: 0 = 1bpp .. 5 = 32bpp */
d1473 23
a1495 1
    /* Scan all available modes at all available pixel depths */
d1497 2
a1498 1
    depth = 0;
d1502 1
a1502 1
        if (!mode_valid (mp, depth, dataratelimit, datasizelimit))
d1523 3
d1531 38
a1568 16
                        ModeInfoBlockRef ip = (ModeInfoBlockRef)regs->r[6];
                        int i;

                        /* Copy the mode information into the supplied data buffer */
                        ip->blocksize = entrysize;
                        ip->format = 0;  ip->flags = 0;  ip->bit0 = 1;
                        ip->xresol = mp->definition.xres;
                        ip->yresol = mp->definition.yres;
                        ip->depth = depth; /* log2 (bits/pixel) */
                        ip->framerate = mp->frame_hz; /* integer Hz value used here */

                        /* Copy name + 1 terminating null into block */
                        strcpy (ip->name, mp->definition.name);
                        /* Pad name field out with 0's to N*4 */
                        for (i = nlen+1; (i & 3) != 0; ++i)
                            ip->name[i] = 0;
d1586 4
a1589 2
        if (depth < 5)
            ++depth;                    /* next deeper mode of current def'n */
d1595 2
a1596 1
            depth = 0;                  /* start with min. depth */
d1601 1
a1601 1
static int mode_available(uint32_t xres, uint32_t yres, int depth, int framerate)
d1612 1
a1612 1
            mode_valid (mp, depth, INT32_MAX, INT32_MAX))
d1626 1
d1668 1
d1674 1
a1674 1
     if (mode_available(640, 480, depth, 60))
d1685 1
a1685 1
     if (mode_available(640, 256, depth, 50))
d1695 1
a1695 1
     if (mode_available(640, 200, depth, 60))
d1705 1
a1705 1
     if (mode_available(640, 480, depth, -1))
@


4.14
log
@Relax clipping of mode names
19 characters is a bit mean if you want to say "2048 x 1024 big monitor" or similar, so bumped it to 31+terminator.
100 characters for the monitor title is a bit lavish, since (in System font) display manager's title bar can only fit 33 characters, reduced to 31+terminator too.
Fixes ticket #302.

Version 0.34. Tagged as 'ScrModes-0_34'
@
text
@d156 1
a156 1
    if ((res = _kernel_swi(MessageTrans_OpenFile, &r, &r)) != NULL)
d513 1
a513 1
    assert (last_mode_key <= 32);
d538 3
a540 1
            missed = ~(~(uint32_t)0 << (last_mode_key+1)) - keyseen;
d791 2
a792 1
            if (res == NULL) {
d794 1
a794 1
                if(md->lcd_support != 0) md->dpms_state = -1;    /* LCD and DPMS are mutually exclusive */
d810 2
a811 1
            if (res == NULL) {
d833 2
a834 1
    if (res == NULL) {
a944 7
static void inform_modefilechanged (void)
{
    _kernel_swi_regs regs;
    regs.r[1] = Service_ModeFileChanged;
    (void)_kernel_swi (OS_ServiceCall, &regs, &regs);
}

d1037 2
a1038 1
                char *path,*dot;
d1059 4
a1062 1
                inform_modefilechanged ();
d1069 70
d1145 1
a1145 1
static int mode_valid (ModeDescriptionRef mp, int depth,
d1150 1
d1158 1
a1158 1
    if((depth > 2) && (current_monitor->lcd_support == 1))
d1182 1
a1182 1
    _kernel_swi(OS_CallAVector, &r, &r);
d1186 10
a1199 1

d1272 1
a1272 1
    ModeSelectorRef sel;
a1275 1
    int ctrllistpos = 0;
d1324 1
a1324 1
    if (!mp)
d1332 1
a1332 59
            VIDCListRef vp = &thevidclist; /* use the local static structure */
            int fn;
            /* OK, fill in the fields */
            vp->format = 3;
            vp->depth = sel->depth;
            for (fn = 0; fn < FR__COUNT; ++fn)
            {
                vp->hpar[fn] = mp->definition.hpar[fn];
                vp->vpar[fn] = mp->definition.vpar[fn];
            }
            vp->pixelrate = mp->definition.pixel_khz;
            vp->syncpol = mp->definition.syncpol;

            if (current_monitor->dpms_state != -1) {
                vp->vcparam[ctrllistpos].index = DPMS_INDEX;
                vp->vcparam[ctrllistpos].value = current_monitor->dpms_state;
                ctrllistpos++;
            }

            if (current_monitor->lcd_support != 0) {
                debug printf("I'm an LCD panel & I'm going to tell the Kernel!\n");
                vp->vcparam[ctrllistpos].index = LCDMODE_INDEX;
                vp->vcparam[ctrllistpos].value = LCDMODE_VALUE;
                ctrllistpos++;
                if (current_monitor->lcd_support != 3) {
                    vp->vcparam[ctrllistpos].index = LCDDUAL_INDEX;
                    vp->vcparam[ctrllistpos].value = LCDDUAL_VALUE;
                    ctrllistpos++;
                }
                vp->vcparam[ctrllistpos].index = LCDOFF0_INDEX;
                vp->vcparam[ctrllistpos].value = LCDOFF0_VALUE;
                    ctrllistpos++;
                vp->vcparam[ctrllistpos].index = LCDOFF1_INDEX;
                vp->vcparam[ctrllistpos].value = LCDOFF1_VALUE;
                    ctrllistpos++;
                vp->vcparam[ctrllistpos].index = DACCTRL_INDEX;
                vp->vcparam[ctrllistpos].value = DACCTRL_VALUE;
                    ctrllistpos++;
            }

            if (mp->definition.external_clock != -1) {
                vp->vcparam[ctrllistpos].index = HCLK_INDEX;
                vp->vcparam[ctrllistpos].value = mp->definition.external_clock;
                ctrllistpos++;
            }

            if (mp->definition.interlaced) {
                vp->vcparam[ctrllistpos].index = INTERLACED_INDEX;
                vp->vcparam[ctrllistpos].value = 1;
                ctrllistpos++;
            }

            if (current_monitor->output_format != -1) {
                vp->vcparam[ctrllistpos].index = OPFORMAT_INDEX;
                vp->vcparam[ctrllistpos].value = current_monitor->output_format;
                ctrllistpos++;
            }

            vp->vcparam[ctrllistpos].index = -1;      /* List terminator */
d1334 4
a1337 4
            /* Now modify the register set to reflect servicing the call */
            regs->r[1] = 0;             /* Service_Serviced */
            regs->r[3] = (int)vp;       /* return pointer to vidc list */
            regs->r[4] = 0;             /* marks no workspace list (mode selector given) */
d1438 2
a1439 2
    mp = find_by_xy( current_monitor->modelist, xres, yres, &nmodes);
    if (!mp)
@


4.13
log
@Retire VIDCBandwidthLimit command
Was previously for internal use only, but largely irrelevant as the majoirty of targets don't contain a VIDC, and those that do use a GraphicsV driver anyway.
* CMHG and resources updated to remove the command from the command/syntax table
* Don't bother probing OS_ReadSysInfo 2 for the video controller, assume it's always GraphicsV
* Don't try vetting modes based on VIDC limitations (leave that to VIDC20Video module)
* Don't listen to the kernel's bandwidth limit suggestion, always use INT32_MAX
Also
* Fix potential null pointer dereference if there's not enough RAM to build an ICONSPRITES command
* Rather than setting up an atexit() handler in the module init, just use a module finalisation handler
* Makefile tickled to not use Norcroft specific flags

Version 0.33. Tagged as 'ScrModes-0_33'
@
text
@a485 5
static int end_of_num_char (int c)
{
    return (c == '\x00' || c == '\x0A' || c == '\x0D' || c == ' ');
}

@


4.12
log
@Clean up pass
* Makefile recreated from fragments
* Swap to C99 types, remove 'machtypes.h'
* Use centralised SWI and service call definitions, remove 'newswis.h' and 'services.h'
* Error E21 taken out of resources, CMHG generates this one for free
* Compiler warnings squashed

Version 0.32. Tagged as 'ScrModes-0_32'
@
text
@a117 13
 * Record of video controller type, determined at initialisation:
 * codes used here match those values returned in r0 bits 31:24 by a
 * call to OS_ReadSysInfo 2, as implemented in RISC OS for Medusa and
 * (presumably all) subsequent versions.  For a new video controller
 * type (beyond VIDC1=0 and VIDC20=1), add the new code value
 * definition here, before V_UNKNOWN, and update all code which uses
 * it.  If an unknown controller code is ever seen, the hardware will
 * be assumed to be able to support any set of video timings given in
 * the mode file, without restriction or modification.
 */
static enum vidctype { V_VIDC1=0, V_VIDC20=1, V_UNKNOWN } vidc_type;

/*
a126 12
 * The initial VIDC20s cannot cope with modes whose bandwidth is above
 * 155 MB/s (rather than 160 MB/s as designed) but we don't want to put
 * this limit into the kernel, so on these chips we want to take what
 * the kernel passes us as the available bandwidth and limit it to 155.
 * To this end we provide a *-command VIDCBandwidthLimit to set the limit.
 * The units are bytes/second.
 * The default value (zero) means don't limit it.
 */

static uint32_t bandwidth_limit = 0;       /* by default don't limit it */

/*
a129 1

d476 2
a477 2
        if (acc > 0xFFFFFFFF/10 ||
            (acc == 0xFFFFFFFF/10 && digit > 0xFFFFFFFF%10))
a490 29
static _kernel_oserror *sread_u32 (uint32_t *var, const char **sptr)
{
    int c;
    uint32_t acc = 0;
    const char *s2 = *sptr;
    while (!end_of_num_char (c = (int)*s2))
    {
        if (isdigit (c))
        {
            int digit = c - '0';
            if (acc > 0xFFFFFFFF/10 ||
                (acc == 0xFFFFFFFF/10 && digit > 0xFFFFFFFF%10))
                return synerr0 (ERR_VALUEOVF2);
            acc = acc * 10 + digit;
            s2++;
        }
        else
        {
            return synerr0 (ERR_EXPNUM2);
        }
    }
    if (s2 == *sptr)    /* no digits */
        return synerr0 (ERR_EXPNUM2);

    *var = acc;
    *sptr = s2;
    return NULL;
}

d570 1
a570 1
	    /* xres must equal xdisp, and yres must equal ydisp (or ydisp*2 for interlaced modes) */
d653 1
a653 14
                /*
                 * Apply vidc-specific checks: VIDC1 and VIDC20 both
                 * require an even number of pixels in a line.
                 */
                switch (vidc_type)
                {
                  case V_VIDC1:
                  case V_VIDC20:
                    if (kc == k_h_timings && par[FR_DISP] % 2 != 0)
                        return synerr0 (ERR_INVALIDPAR);
                    break;
                  default:
                    break;
                }
a656 1

d1047 16
a1062 12
                strcpy(path,"IconSprites \0");
                dot = strrchr(file, '.');
                if (dot != NULL)
                   {
                   strcat(path,file);         /* Grab the path */
                   dot = 1 + strrchr(path, '.');
                   *dot = '\0';               /* Slice off the leafname */
                   }
                strcat(path, "!Sprites\0");
                _kernel_oscli(path);          /* Have a go at *IconSprites !Sprites */
                free(path);

a1071 30
static _kernel_oserror *vidcbandwidthlimit (const char *numstring)
{
    uint32_t limit0, limit1, limit2, vram;
    _kernel_swi_regs r;
    _kernel_oserror *res;

    res = sread_u32 (&limit0, &numstring);      /* read number for no VRAM*/
    if (res) return res;                        /* if error return it */

    while (*numstring == ' ') numstring++;      /* skip spaces after 1st number */

    res = sread_u32 (&limit1, &numstring);      /* read number for 1M VRAM*/
    if (res) return res;                        /* if error return it */

    while (*numstring == ' ') numstring++;      /* skip spaces after 2nd number */

    res = sread_u32 (&limit2, &numstring);      /* read number for 2M VRAM*/
    if (res) return res;                        /* if error return it */

    r.r[0] = 0x208;                                     /* reason code for 'read amount of VRAM' */
    res = _kernel_swi (OS_Memory, &r, &r);              /* returns r1 = number of pages, r2 = page size */
    if (res) return res;

    vram = r.r[1] * r.r[2];                     /* vram = total amount of VRAM in bytes */
    bandwidth_limit = (vram >= 2*1024*1024) ? limit2 : (vram >= 1024*1024) ? limit1 : limit0;

    return NULL;                                /* exit OK */
}


d1076 1
a1076 4
 * are also factored in to the test.  For example, with VIDC20 all
 * modes must have a multiple of 32 bits in a line, so modes with
 * horizontal dimensions not a multiple of 32 cannot be displayed in
 * the lowest depth mode(s).
d1079 2
a1080 1
                       uint32_t maxdatarate, uint32_t maxdatasize)
d1082 1
a1087 5
    /*
     * TMD 03-Apr-96: For interlaced modes, the line length must be a
     * multiple of 32 bytes, ie 256 bits
     */
    uint32_t bit_multiple = mp->definition.interlaced ? 256 : 32;
d1090 2
a1091 2

    if((depth > 2) && (current_monitor->lcd_support == 1)) return 0;         /** Eek! 4bpp is max for b/w panels! **/
d1112 7
a1118 31
    /*
     * For both VIDC1 and VIDC20, we must ensure that data for one
     * line is a whole number of 32-bit words (VIDC1 data sheet
     * actually says 128 bits, but it does work for e.g. mode 29 which
     * is 32 MOD 128).  This check can cut out lower depths for
     * certain unusually-dimensioned modes.
     *
     */
    switch (vidc_type)
    {
      case V_VIDC1:
        if ((mx << depth) % bit_multiple != 0)
            return 0;
        break;

      case V_VIDC20:
        if ((mx << depth) % bit_multiple != 0)
            return 0;
        break;

      default:
        {
        _kernel_swi_regs r;
        r.r[4] = GraphicsV_DisplayFeatures;
        r.r[9] = GraphicsV;
        _kernel_swi(OS_CallAVector, &r, &r);
        if ((r.r[4] == 0) && ((r.r[1] & (1<<depth)) == 0))
           return 0;                    /* had a definitive answer from GraphicsV that this bpp is forbidden */
        break;                          /* can't be sure,let everything through */
        }
    }
d1150 7
a1156 3
    /* Return as the limit the minimum of (os_limit, bandwidth_limit),
     * where bandwidth_limit is set up by the command *VIDCBandwidthLimit
     * (but zero means no limit)
d1158 3
a1160 10

/*    if (bandwidth_limit == 0 || os_limit < bandwidth_limit)
        return os_limit;
    else
--Commented out by WT 1-8-95 so that 'Turbo' Krytens can be tried (they have
a higher bandwidth & it is inconvenient to reblow ROMs every time. Whether this
becomes a permanent change or not remains to be seen.
*/
      if (bandwidth_limit == 0) return os_limit;
      else return bandwidth_limit;
d1331 1
d1333 1
a1333 1
     * See comments re. data-rate spec in handle_modeextension.
d1335 2
a1336 3
    dataratelimit = restrict_bandwidth (regs->r[4]);
    dataratelimit /= 1000;      /* convert to our preferred, internally used, units */
    datasizelimit = regs->r[5]; /* data size is measured in bytes */
d1426 1
a1426 1
            mode_valid (mp, depth, 0xFFFFFFFF, 0xFFFFFFFF))
d1480 1
a1480 1
  retry_with_4bpp:
a1537 6
static void module_shutdown (void)
{
    (void) restore_monitortype (); /* restore old value */
    release_currentmonitor ();
}

d1549 1
a1549 1
_kernel_oserror *ScreenModes_init (const char *cmd_tail, int podule_base, void *pw)
a1550 26
    _kernel_swi_regs regs;
    _kernel_oserror *res;
    enum vidctype vcode;

    /* Determine Video Controller type for this machine. */
    regs.r[0] = 2;
    res = _kernel_swi (OS_ReadSysInfo, &regs, &regs);
    if (res != NULL)
        return res;                     /* ought never to happen! */
    vcode = (enum vidctype) ((regs.r[0] >> 24) & 0xFF);
    switch (vcode)
    {
      case V_VIDC1:
      case V_VIDC20:
        /*
         * Add new known video controller type codes as additional
         * cases here, if ever there are any more!
         */
        vidc_type = vcode;
        break;
      default:
        /* What hardware is this?! */
        vidc_type = V_UNKNOWN;
        break;
    }

d1552 1
a1552 1
     * Arrange to free the space claimed for the current monitor
d1554 1
a1554 6
     * when the module is shut down.  It is extremely unlikely that
     * the atexit call will fail, and even if it does, it just means
     * we will leave some memory allocated when we are shut down
     * (which is a pretty rare event in itself). Not resetting the
     * monitor type would be slightly more problematic, but we don't
     * worry here.
d1556 2
a1557 1
    (void) atexit (module_shutdown);
d1560 2
a1561 2
    UNUSED(podule_base);
    UNUSED(cmd_tail);
d1586 1
a1586 1
_kernel_oserror *ScreenModes_command (const char *arg_string, int argc, int cmd_no, void *pw)
d1596 2
a1597 5
        case CMD_VIDCBandwidthLimit:
                result = vidcbandwidthlimit (arg_string);
                break;

        default: result = NULL;         /* eh? */
d1606 1
@


4.11
log
@When the video controller is V_UNKNOWN (ie.not a VIDC) then an attempt
will be made to validate the desired bpp via GraphicsV.That way,when
the screen modes are enumerated only achievable ones are returned.
Also added an iconsprites command to the loadmodefile command,so that
if a sprite file exists in the same dir as the MDF it can override the
default display manager icon.

Version 0.30. Tagged as 'ScrModes-0_30'
@
text
@d24 1
a24 1
#include <stdarg.h>
a29 2
#include "newswis.h"
#include "errors.h"
d31 2
d35 2
a36 1
#include "services.h"
a37 2

#include "machtypes.h"
d41 1
a41 1
#define DODEBUG 1
a43 2
#define MESSAGE_FILE    "Resources:$.Resources.ScreenMode.Messages"

d149 1
a149 1
static uns32 bandwidth_limit = 0;       /* by default don't limit it */
d180 1
a180 1
    r.r[1] = (int)MESSAGE_FILE;
d220 1
a220 1
static void release_currentmonitor ()
d289 1
a289 1
static int nextc ()
d322 1
a322 1
static void close_modefile ()
d368 1
a368 1
static int skip_space ()
d376 1
a376 1
static int skip_comment_or_blank ()
d397 1
a397 1
static enum keycode read_keyword ()
d491 1
a491 1
static _kernel_oserror *read_u32 (uns32 *var)
d494 1
a494 1
    uns32 acc;
d517 1
a517 1
static _kernel_oserror *sread_u32 (uns32 *var, char **sptr)
d520 2
a521 2
    uns32 acc = 0;
    char *s2 = *sptr;
d546 1
a546 1
static _kernel_oserror *read_one_u32 (uns32 *var, uns32 fault_zero)
d572 1
a572 1
    uns32 keyseen;
d580 1
a580 1
        uns32 param, missed, ok_to_miss;
d598 1
a598 1
            missed = ~(~(uns32)0 << (last_mode_key+1)) - keyseen;
d692 1
a692 1
                uns16 *par = kc == k_h_timings ? mode->hpar : mode->vpar;
d695 1
a695 1
                    uns32 param;
d734 1
a734 1
    uns32 vtot, htot;
d809 1
a809 1
    uns32 ffmt;
d812 1
a812 1
    enum keycode kc;
d991 1
a991 1
static int read_monitortype ()
d1000 1
a1000 1
static _kernel_oserror *restore_monitortype ()
d1014 1
a1014 1
static void inform_modefilechanged ()
d1029 2
a1030 2
        uns32 pixrate = dp->pixel_khz;
        uns32 pixels = dp->xres * dp->yres;
d1049 2
a1050 2
            uns bits = 1 << log2bpp;
            uns32 drate, dsize;
d1053 2
a1054 2
                uns shift = 3 - log2bpp;
                uns round = (1 << shift) - 1;
d1060 1
a1060 1
                uns shift = log2bpp - 3;
d1072 1
a1072 1
static _kernel_oserror *loadmodefile (char *file)
d1137 1
a1137 1
static _kernel_oserror *vidcbandwidthlimit (char *numstring)
d1139 1
a1139 1
    uns32 limit0, limit1, limit2, vram;
d1177 1
a1177 1
                       uns32 maxdatarate, uns32 maxdatasize)
d1179 5
a1183 5
    uns32 pixrate = mp->definition.pixel_khz;
    uns32 mx = mp->definition.xres;
    uns32 my = mp->definition.yres;
    uns32 pixels = mx * my;
    uns32 datarate, datasize;
d1188 1
a1188 1
    uns32 bit_multiple = mp->definition.interlaced ? 256 : 32;
d1196 2
a1197 2
        uns shift = 3 - depth;
        uns round = (1 << shift) - 1;
d1203 1
a1203 1
        uns shift = depth - 3;
d1236 1
a1236 1
        r.r[4] = 8;
d1249 1
a1249 1
                                      uns32 xres, uns32 yres, int *count)
d1325 1
a1325 1
    uns32 dataratelimit, datasizelimit;
d1457 1
a1457 1
    uns32 dataratelimit, datasizelimit;
d1543 1
a1543 1
static int mode_available(uns32 xres, uns32 yres, int depth, int framerate)
d1666 1
a1666 1
static void module_shutdown ()
d1683 1
a1683 1
_kernel_oserror *ScreenModes_init (char *cmd_tail, int podule_base, void *pw)
d1722 5
d1750 1
a1750 1
_kernel_oserror *ScreenModes_command (char *arg_string, int argc, int cmd_no, void *pw)
d1756 2
a1757 1
        case 0: result = loadmodefile (arg_string);
d1760 2
a1761 1
        case 1: result = vidcbandwidthlimit (arg_string);
d1766 4
d1780 2
a1781 2
        case 0:
            switch (r->r[0])      /* In ScreenModes_ReadInfo, r0 on entry is reason code */
d1802 1
a1802 1
            result = error (ERR_UNKNOWNSWI, 0, 0, 0);
d1804 2
@


4.10
log
@added support for output_format keyword in MDFs, value of 1 means digital
intended for cases like video controller attached to Chrontel for TV display
untested

Version 0.27. Not tagged
@
text
@d32 1
d1116 15
d1237 9
a1245 1
        break;                          /* be generous! */
d1486 1
a1486 1
        {
@


4.9
log
@Now attempts to substitute a 1bpp mode for unknown mode numbers passed to
Service_ModeTranslation - previously just left it to the Kernel, which would
select mode 25 with hilarious results on an NC/STB.

Version 0.27. Tagged as 'ScrModes-0_27'
@
text
@d67 1
d103 1
d875 16
d1412 6
@


4.8
log
@"external_clock" keyword now parsed correctly within a mode.

Version 0.26. Tagged as 'ScrModes-0_26'
@
text
@d1548 4
a1551 1
    /* What depth are they looking for? */
d1554 1
a1554 1
        return;
@


4.7
log
@Can now add the line "external_clock:xxx" to individual modes - this overrides
any directive (or lack of one) at the top of the file.

Untested, but required for Lazarus NTSC TV MDF.

Version 0.25. Tagged as 'ScrModes-0_25'
@
text
@d60 1
a66 1
 "external_clock\0" \
d93 1
a101 1
    k_external_clock,
d606 1
@


4.6
log
@Claims Service_ModeTranslation to get better alternatives than those the
Kernel generates, which are often not suitable for a TV.

Version 0.24. Tagged as 'ScrModes-0_24'
@
text
@d576 1
d670 6
d775 3
d1384 1
a1384 1
            if (current_monitor->external_clock != -1) {
d1386 1
a1386 1
                vp->vcparam[ctrllistpos].value = current_monitor->external_clock;
@


4.5
log
@Why is every modification taking me 3 attempts today? Too much MSG,
probably.

Version 0.23. Tagged as 'ScrModes-0_23'
@
text
@d266 1
a266 1
            res = _kernel_swi (OS_Find | XOS_Bit, &regs, &regs);
d275 1
a275 1
                (void) _kernel_swi (OS_Find | XOS_Bit, &regs, &regs);
d961 1
a961 1
    return _kernel_swi (OS_ScreenMode | XOS_Bit, &regs, &regs);
d969 1
a969 1
    res = _kernel_swi (OS_ReadSysInfo | XOS_Bit, &regs, &regs);
d991 1
a991 1
    (void)_kernel_swi (OS_ServiceCall | XOS_Bit, &regs, &regs);
d1115 1
a1115 1
    res = _kernel_swi (OS_Memory | XOS_Bit, &r, &r);    /* returns r1 = number of pages, r2 = page size */
d1487 120
d1618 1
a1618 1
    (void)_kernel_swi (OS_Module | XOS_Bit, &sregs, &sregs);
d1632 1
a1632 1
    res = _kernel_swi (OS_ReadSysInfo | XOS_Bit, &regs, &regs);
d1680 2
@


4.4
log
@Naughty Bracey broke the parser. He didn't realise people would want to use
"startmode". Straight to bed, without any supper.

Version 0.22. Tagged as 'ScrModes-0_22'
@
text
@a866 1
        kc = read_keyword ();
@


4.3
log
@Added support for "external_clock" keyword - if specified, gives the
frequency of HCLK, and instructs the kernel to use it instead of the VCO.
Corresponds to video control parameter 9 (PRM 5a-126).

Version 0.21. Tagged as 'ScrModes-0_21'
@
text
@d54 12
a65 12
 "x_res\0        " \
 "y_res\0        " \
 "h_timings\0    " \
 "v_timings\0    " \
 "pixel_rate\0   " \
 "sync_pol\0     " \
 "mode_name\0    " \
 "file_format\0  " \
 "monitor_title\0" \
 "dpms_state\0   " \
 "lcd_support\0  " \
 "interlaced\0   " \
d67 1
a67 1
 "startmode\0    " \
d69 1
a69 1
#define MAXKEYWORDLEN 13
@


4.2
log
@NCOS 1.06 version used
@
text
@d66 1
d101 1
d400 2
a401 1
    int i, k, c;
d415 1
a415 1
    k = 0;
d417 1
a417 1
        ++k;
d861 16
d1375 6
d1509 1
a1509 1
    int vcode;
d1516 1
a1516 1
    vcode = (regs.r[0] >> 24) & 0xFF;
@


4.1
log
@Initial revision
@
text
@d64 2
d88 1
a88 1
    k_h_timings, 
d98 2
d109 2
a110 2
static int dodebug = 0;
#define debug if (!dodebug) {} else 
d125 1
a125 1
 */ 
d323 1
a323 1
    fclose (thefile); 
d412 1
a412 1
    k = 0; 
d417 1
a417 1
    
d570 1
a570 2
    uns32 xres, yres;
    assert (last_mode_key <= 32); 
d572 1
d576 1
a576 1
        uns32 param, missed;
d596 4
a599 3
             * In format 1, we insist that x_res = hdisp and y_res =
             * vdisp so x_res and y_res are in fact optional.  We
             * insist that all other keywords do occur.
d601 2
a602 1
            if (missed & ~(1 << k_x_res | 1 << k_y_res))
d616 6
a621 3
            /* All keywords seen - check consistency */
            if (keyseen & (1 << k_x_res) && xres != mode->hpar[FR_DISP] ||
                keyseen & (1 << k_y_res) && yres != mode->vpar[FR_DISP])
d632 2
a633 2
          case k_x_res: 
            res = read_one_u32 (&xres, 1); 
d638 2
a639 2
          case k_y_res: 
            res = read_one_u32 (&yres, 1); 
d644 1
a644 1
          case k_pixel_rate: 
d659 7
d677 1
a677 1
          case k_h_timings: 
d733 1
d839 3
d843 17
d861 1
d883 1
a883 1
    if (m1->definition.hpar[FR_DISP] < m2->definition.hpar[FR_DISP])
d885 1
a885 1
    if (m1->definition.hpar[FR_DISP] > m2->definition.hpar[FR_DISP])
d887 1
a887 1
    if (m1->definition.vpar[FR_DISP] < m2->definition.vpar[FR_DISP])
d889 1
a889 1
    if (m1->definition.vpar[FR_DISP] > m2->definition.vpar[FR_DISP])
d932 1
a932 1
            this = next; 
d985 1
a985 1
        uns32 pixels = dp->vpar[FR_DISP] * dp->hpar[FR_DISP];
d988 1
a988 1
        printf ("  Resolution %u x %u\n", dp->hpar[FR_DISP], dp->vpar[FR_DISP]);
d1001 1
d1023 1
a1023 1
    }    
d1030 1
a1030 1
    
d1116 1
a1116 1
static int mode_valid (ModeDescriptionRef mp, int depth, 
d1120 2
a1121 2
    uns32 mx = mp->definition.hpar[FR_DISP];
    uns32 my = mp->definition.vpar[FR_DISP];
d1124 6
d1131 3
d1159 1
d1164 1
a1164 1
        if ((mx << depth) % 32 != 0)
d1169 1
a1169 1
        if ((mx << depth) % 32 != 0)
d1180 1
a1180 1
static ModeDescriptionRef find_by_xy (ModeDescriptionRef mp, 
d1183 1
a1183 1
    while (mp && mp->definition.hpar[FR_DISP] < xres)
d1185 1
a1185 1
    while (mp && mp->definition.hpar[FR_DISP] == xres && mp->definition.vpar[FR_DISP] < yres)
d1187 1
a1187 1
    if (mp && mp->definition.hpar[FR_DISP] == xres && mp->definition.vpar[FR_DISP] == yres)
d1196 2
a1197 2
        } while (mp && mp->definition.hpar[FR_DISP] == xres && 
                 mp->definition.vpar[FR_DISP] == yres);
d1202 1
a1202 1
        return NULL;       
d1212 1
a1212 1
    if (bandwidth_limit == 0 || os_limit < bandwidth_limit)
d1215 6
a1220 1
        return bandwidth_limit;
d1247 5
d1259 1
d1313 1
a1313 1
        if ((sel->framerate == -1 || sel->framerate == mp->frame_hz) && 
d1328 26
a1353 3
            if (current_monitor->dpms_state == -1)
            {
                vp->vcparam[0].index = -1;      /* terminator - no extra video control parameters */
d1355 5
a1359 5
            else
            {
                vp->vcparam[0].index = DPMS_INDEX;
                vp->vcparam[0].value = current_monitor->dpms_state;
                vp->vcparam[1].index = -1;      /* terminator */
d1361 3
d1399 1
a1399 1
             * the length of the line is not a multiple of 1 word.
d1424 2
a1425 2
                        ip->xresol = mp->definition.hpar[FR_DISP];
                        ip->yresol = mp->definition.vpar[FR_DISP];
d1444 1
a1444 1
                regs->r[7] -= entrysize;                
d1459 1
a1459 1
        }   
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a63 2
 "lcd_support\0  " \
 "interlaced\0   " \
d86 1
a86 1
    k_h_timings,
a95 2
    k_lcd_support,
    k_interlaced,
d105 2
a106 2
static int dodebug = 1;
#define debug if (!dodebug) {} else
d121 1
a121 1
 */
d319 1
a319 1
    fclose (thefile);
d408 1
a408 1
    k = 0;
d413 1
a413 1

d566 2
a567 1
    assert (last_mode_key <= 32);
a568 1
    mode->interlaced = 0; /* Assume mode is not interlaced, unless we see the keyword */
d572 1
a572 1
        uns32 param, missed, ok_to_miss;
d592 3
a594 4
             * In format 1, we normally insist that x_res = hdisp and
             * y_res = vdisp so x_res and y_res are in fact optional.
             * However if the mode is interlaced, then x_res and y_res are compulsory.
             * We insist that all other keywords do occur.
d596 1
a596 2
            ok_to_miss = mode->interlaced ? 0 : (1 << k_x_res) | (1 << k_y_res);
            if (missed & ~ok_to_miss)
d610 3
a612 6
            /* If xres and/or yres missing, use the xdisp and/or ydisp values */
            if (!(keyseen & (1 << k_x_res))) mode->xres = mode->hpar[FR_DISP];
            if (!(keyseen & (1 << k_y_res))) mode->yres = mode->vpar[FR_DISP];

	    /* xres must equal xdisp, and yres must equal ydisp (or ydisp*2 for interlaced modes) */
            if (mode->xres != mode->hpar[FR_DISP] || mode->yres != mode->vpar[FR_DISP] * (mode->interlaced+1))
d623 2
a624 2
          case k_x_res:
            res = read_one_u32 (&mode->xres, 1);
d629 2
a630 2
          case k_y_res:
            res = read_one_u32 (&mode->yres, 1);
d635 1
a635 1
          case k_pixel_rate:
a649 7
          case k_interlaced:
            mode->interlaced = 1; /* It is an interlaced mode */
            res = check_eol (0);
            if (res)
                return res;
            break;

d661 1
a661 1
          case k_h_timings:
a716 1
    if (mp->interlaced) md->frame_mhz /= 2; /* if interlaced, one frame is 2 fields */
a821 3
    /*
     * Now check for optional LCD_support keyword
     */
a822 17
    {
        md->lcd_support = 0;                                /* Indicates CRT as default */
        if (kc == k_lcd_support)
        {
            debug printf("Got the lcdsupport keyword\n");
            res = skip_char (':');
            if (res == NULL) {
                res = read_one_u32 (&md->lcd_support, 0);    /* read LCD_support value */
                if(md->lcd_support != 0) md->dpms_state = -1;    /* LCD and DPMS are mutually exclusive */
                debug printf("Read the value as %d\n",md->lcd_support);
            }
            if (res == NULL) kc = read_keyword ();          /* then read next keyword */
        }
    }

    if (res == NULL) {
        debug printf("Going to read the modes now...\n");
a823 1
    }
d845 1
a845 1
    if (m1->definition.xres < m2->definition.xres)
d847 1
a847 1
    if (m1->definition.xres > m2->definition.xres)
d849 1
a849 1
    if (m1->definition.yres < m2->definition.yres)
d851 1
a851 1
    if (m1->definition.yres > m2->definition.yres)
d894 1
a894 1
            this = next;
d947 1
a947 1
        uns32 pixels = dp->xres * dp->yres;
d950 1
a950 1
        printf ("  Resolution %u x %u\n", dp->xres, dp->yres);
a962 1
        if (dp->interlaced) printf("  Interlaced\n");
d984 1
a984 1
    }
d991 1
a991 1

d1077 1
a1077 1
static int mode_valid (ModeDescriptionRef mp, int depth,
d1081 2
a1082 2
    uns32 mx = mp->definition.xres;
    uns32 my = mp->definition.yres;
a1084 6
    /*
     * TMD 03-Apr-96: For interlaced modes, the line length must be a
     * multiple of 32 bytes, ie 256 bits
     */
    uns32 bit_multiple = mp->definition.interlaced ? 256 : 32;

a1085 3

    if((depth > 2) && (current_monitor->lcd_support == 1)) return 0;         /** Eek! 4bpp is max for b/w panels! **/

a1110 1
     *
d1115 1
a1115 1
        if ((mx << depth) % bit_multiple != 0)
d1120 1
a1120 1
        if ((mx << depth) % bit_multiple != 0)
d1131 1
a1131 1
static ModeDescriptionRef find_by_xy (ModeDescriptionRef mp,
d1134 1
a1134 1
    while (mp && mp->definition.xres < xres)
d1136 1
a1136 1
    while (mp && mp->definition.xres == xres && mp->definition.yres < yres)
d1138 1
a1138 1
    if (mp && mp->definition.xres == xres && mp->definition.yres == yres)
d1147 2
a1148 2
        } while (mp && mp->definition.xres == xres &&
                 mp->definition.yres == yres);
d1153 1
a1153 1
        return NULL;
d1163 1
a1163 1
/*    if (bandwidth_limit == 0 || os_limit < bandwidth_limit)
d1166 1
a1166 6
--Commented out by WT 1-8-95 so that 'Turbo' Krytens can be tried (they have
a higher bandwidth & it is inconvenient to reblow ROMs every time. Whether this
becomes a permanent change or not remains to be seen.
*/
      if (bandwidth_limit == 0) return os_limit;
      else return bandwidth_limit;
a1192 5
     *
     * WT 19-Jan-95 - The parameters list is extended to cater for LCD
     * panels, both single and dual panel, as defined in the LCD_support
     * field of the mode definition file. So, now 6 words are statically
     * allocated.
a1199 1
    int ctrllistpos = 0;
d1253 1
a1253 1
        if ((sel->framerate == -1 || sel->framerate == mp->frame_hz) &&
d1268 3
a1270 5

            if (current_monitor->dpms_state != -1) {
                vp->vcparam[ctrllistpos].index = DPMS_INDEX;
                vp->vcparam[ctrllistpos].value = current_monitor->dpms_state;
                ctrllistpos++;
d1272 5
a1276 20

            if (current_monitor->lcd_support != 0) {
                debug printf("I'm an LCD panel & I'm going to tell the Kernel!\n");
                vp->vcparam[ctrllistpos].index = LCDMODE_INDEX;
                vp->vcparam[ctrllistpos].value = LCDMODE_VALUE;
                ctrllistpos++;
                if (current_monitor->lcd_support != 3) {
                    vp->vcparam[ctrllistpos].index = LCDDUAL_INDEX;
                    vp->vcparam[ctrllistpos].value = LCDDUAL_VALUE;
                    ctrllistpos++;
                }
                vp->vcparam[ctrllistpos].index = LCDOFF0_INDEX;
                vp->vcparam[ctrllistpos].value = LCDOFF0_VALUE;
                    ctrllistpos++;
                vp->vcparam[ctrllistpos].index = LCDOFF1_INDEX;
                vp->vcparam[ctrllistpos].value = LCDOFF1_VALUE;
                    ctrllistpos++;
                vp->vcparam[ctrllistpos].index = DACCTRL_INDEX;
                vp->vcparam[ctrllistpos].value = DACCTRL_VALUE;
                    ctrllistpos++;
a1277 9

            if (mp->definition.interlaced) {
                vp->vcparam[ctrllistpos].index = INTERLACED_INDEX;
                vp->vcparam[ctrllistpos].value = 1;
                ctrllistpos++;
            }

            vp->vcparam[ctrllistpos].index = -1;      /* List terminator */

d1313 1
a1313 1
             * the length of the line is not a suitable multiple.
d1338 2
a1339 2
                        ip->xresol = mp->definition.xres;
                        ip->yresol = mp->definition.yres;
d1358 1
a1358 1
                regs->r[7] -= entrysize;
d1373 1
a1373 1
        }
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a63 2
 "lcd_support\0  " \
 "interlaced\0   " \
d86 1
a86 1
    k_h_timings,
a95 2
    k_lcd_support,
    k_interlaced,
d105 2
a106 2
static int dodebug = 1;
#define debug if (!dodebug) {} else
d121 1
a121 1
 */
d319 1
a319 1
    fclose (thefile);
d408 1
a408 1
    k = 0;
d413 1
a413 1

d566 2
a567 1
    assert (last_mode_key <= 32);
a568 1
    mode->interlaced = 0; /* Assume mode is not interlaced, unless we see the keyword */
d572 1
a572 1
        uns32 param, missed, ok_to_miss;
d592 3
a594 4
             * In format 1, we normally insist that x_res = hdisp and
             * y_res = vdisp so x_res and y_res are in fact optional.
             * However if the mode is interlaced, then x_res and y_res are compulsory.
             * We insist that all other keywords do occur.
d596 1
a596 2
            ok_to_miss = mode->interlaced ? 0 : (1 << k_x_res) | (1 << k_y_res);
            if (missed & ~ok_to_miss)
d610 3
a612 6
            /* If xres and/or yres missing, use the xdisp and/or ydisp values */
            if (!(keyseen & (1 << k_x_res))) mode->xres = mode->hpar[FR_DISP];
            if (!(keyseen & (1 << k_y_res))) mode->yres = mode->vpar[FR_DISP];

	    /* xres must equal xdisp, and yres must equal ydisp (or ydisp*2 for interlaced modes) */
            if (mode->xres != mode->hpar[FR_DISP] || mode->yres != mode->vpar[FR_DISP] * (mode->interlaced+1))
d623 2
a624 2
          case k_x_res:
            res = read_one_u32 (&mode->xres, 1);
d629 2
a630 2
          case k_y_res:
            res = read_one_u32 (&mode->yres, 1);
d635 1
a635 1
          case k_pixel_rate:
a649 7
          case k_interlaced:
            mode->interlaced = 1; /* It is an interlaced mode */
            res = check_eol (0);
            if (res)
                return res;
            break;

d661 1
a661 1
          case k_h_timings:
a716 1
    if (mp->interlaced) md->frame_mhz /= 2; /* if interlaced, one frame is 2 fields */
a821 3
    /*
     * Now check for optional LCD_support keyword
     */
a822 17
    {
        md->lcd_support = 0;                                /* Indicates CRT as default */
        if (kc == k_lcd_support)
        {
            debug printf("Got the lcdsupport keyword\n");
            res = skip_char (':');
            if (res == NULL) {
                res = read_one_u32 (&md->lcd_support, 0);    /* read LCD_support value */
                if(md->lcd_support != 0) md->dpms_state = -1;    /* LCD and DPMS are mutually exclusive */
                debug printf("Read the value as %d\n",md->lcd_support);
            }
            if (res == NULL) kc = read_keyword ();          /* then read next keyword */
        }
    }

    if (res == NULL) {
        debug printf("Going to read the modes now...\n");
a823 1
    }
d845 1
a845 1
    if (m1->definition.xres < m2->definition.xres)
d847 1
a847 1
    if (m1->definition.xres > m2->definition.xres)
d849 1
a849 1
    if (m1->definition.yres < m2->definition.yres)
d851 1
a851 1
    if (m1->definition.yres > m2->definition.yres)
d894 1
a894 1
            this = next;
d947 1
a947 1
        uns32 pixels = dp->xres * dp->yres;
d950 1
a950 1
        printf ("  Resolution %u x %u\n", dp->xres, dp->yres);
a962 1
        if (dp->interlaced) printf("  Interlaced\n");
d984 1
a984 1
    }
d991 1
a991 1

d1077 1
a1077 1
static int mode_valid (ModeDescriptionRef mp, int depth,
d1081 2
a1082 2
    uns32 mx = mp->definition.xres;
    uns32 my = mp->definition.yres;
a1084 6
    /*
     * TMD 03-Apr-96: For interlaced modes, the line length must be a
     * multiple of 32 bytes, ie 256 bits
     */
    uns32 bit_multiple = mp->definition.interlaced ? 256 : 32;

a1085 3

    if((depth > 2) && (current_monitor->lcd_support == 1)) return 0;         /** Eek! 4bpp is max for b/w panels! **/

a1110 1
     *
d1115 1
a1115 1
        if ((mx << depth) % bit_multiple != 0)
d1120 1
a1120 1
        if ((mx << depth) % bit_multiple != 0)
d1131 1
a1131 1
static ModeDescriptionRef find_by_xy (ModeDescriptionRef mp,
d1134 1
a1134 1
    while (mp && mp->definition.xres < xres)
d1136 1
a1136 1
    while (mp && mp->definition.xres == xres && mp->definition.yres < yres)
d1138 1
a1138 1
    if (mp && mp->definition.xres == xres && mp->definition.yres == yres)
d1147 2
a1148 2
        } while (mp && mp->definition.xres == xres &&
                 mp->definition.yres == yres);
d1153 1
a1153 1
        return NULL;
d1163 1
a1163 1
/*    if (bandwidth_limit == 0 || os_limit < bandwidth_limit)
d1166 1
a1166 6
--Commented out by WT 1-8-95 so that 'Turbo' Krytens can be tried (they have
a higher bandwidth & it is inconvenient to reblow ROMs every time. Whether this
becomes a permanent change or not remains to be seen.
*/
      if (bandwidth_limit == 0) return os_limit;
      else return bandwidth_limit;
a1192 5
     *
     * WT 19-Jan-95 - The parameters list is extended to cater for LCD
     * panels, both single and dual panel, as defined in the LCD_support
     * field of the mode definition file. So, now 6 words are statically
     * allocated.
a1199 1
    int ctrllistpos = 0;
d1253 1
a1253 1
        if ((sel->framerate == -1 || sel->framerate == mp->frame_hz) &&
d1268 3
a1270 5

            if (current_monitor->dpms_state != -1) {
                vp->vcparam[ctrllistpos].index = DPMS_INDEX;
                vp->vcparam[ctrllistpos].value = current_monitor->dpms_state;
                ctrllistpos++;
d1272 5
a1276 20

            if (current_monitor->lcd_support != 0) {
                debug printf("I'm an LCD panel & I'm going to tell the Kernel!\n");
                vp->vcparam[ctrllistpos].index = LCDMODE_INDEX;
                vp->vcparam[ctrllistpos].value = LCDMODE_VALUE;
                ctrllistpos++;
                if (current_monitor->lcd_support != 3) {
                    vp->vcparam[ctrllistpos].index = LCDDUAL_INDEX;
                    vp->vcparam[ctrllistpos].value = LCDDUAL_VALUE;
                    ctrllistpos++;
                }
                vp->vcparam[ctrllistpos].index = LCDOFF0_INDEX;
                vp->vcparam[ctrllistpos].value = LCDOFF0_VALUE;
                    ctrllistpos++;
                vp->vcparam[ctrllistpos].index = LCDOFF1_INDEX;
                vp->vcparam[ctrllistpos].value = LCDOFF1_VALUE;
                    ctrllistpos++;
                vp->vcparam[ctrllistpos].index = DACCTRL_INDEX;
                vp->vcparam[ctrllistpos].value = DACCTRL_VALUE;
                    ctrllistpos++;
a1277 9

            if (mp->definition.interlaced) {
                vp->vcparam[ctrllistpos].index = INTERLACED_INDEX;
                vp->vcparam[ctrllistpos].value = 1;
                ctrllistpos++;
            }

            vp->vcparam[ctrllistpos].index = -1;      /* List terminator */

d1313 1
a1313 1
             * the length of the line is not a suitable multiple.
d1338 2
a1339 2
                        ip->xresol = mp->definition.xres;
                        ip->yresol = mp->definition.yres;
d1358 1
a1358 1
                regs->r[7] -= entrysize;
d1373 1
a1373 1
        }
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a63 1
 "lcd_support\0  " \
d86 1
a86 1
    k_h_timings,
a95 1
    k_lcd_support,
d105 2
a106 2
static int dodebug = 1;
#define debug if (!dodebug) {} else
d121 1
a121 1
 */
d319 1
a319 1
    fclose (thefile);
d408 1
a408 1
    k = 0;
d413 1
a413 1

d567 1
a567 1
    assert (last_mode_key <= 32);
d623 2
a624 2
          case k_x_res:
            res = read_one_u32 (&xres, 1);
d629 2
a630 2
          case k_y_res:
            res = read_one_u32 (&yres, 1);
d635 1
a635 1
          case k_pixel_rate:
d661 1
a661 1
          case k_h_timings:
a821 3
    /*
     * Now check for optional LCD_support keyword
     */
a822 17
    {
        md->lcd_support = 0;                                /* Indicates CRT as default */
        if (kc == k_lcd_support)
        {
            debug printf("Got the lcdsupport keyword\n");
            res = skip_char (':');
            if (res == NULL) {
                res = read_one_u32 (&md->lcd_support, 0);    /* read LCD_support value */
                if(md->lcd_support != 0) md->dpms_state = -1;    /* LCD and DPMS are mutually exclusive */
                debug printf("Read the value as %d\n",md->lcd_support);
            }
            if (res == NULL) kc = read_keyword ();          /* then read next keyword */
        }
    }

    if (res == NULL) {
        debug printf("Going to read the modes now...\n");
a823 1
    }
d894 1
a894 1
            this = next;
d984 1
a984 1
    }
d991 1
a991 1

d1077 1
a1077 1
static int mode_valid (ModeDescriptionRef mp, int depth,
a1085 3

    if((depth > 2) && (current_monitor->lcd_support == 1)) return 0;         /** Eek! 4bpp is max for b/w panels! **/

d1131 1
a1131 1
static ModeDescriptionRef find_by_xy (ModeDescriptionRef mp,
d1147 1
a1147 1
        } while (mp && mp->definition.hpar[FR_DISP] == xres &&
d1153 1
a1153 1
        return NULL;
d1163 1
a1163 1
/*    if (bandwidth_limit == 0 || os_limit < bandwidth_limit)
d1166 1
a1166 6
--Commented out by WT 1-8-95 so that 'Turbo' Krytens can be tried (they have
a higher bandwidth & it is inconvenient to reblow ROMs every time. Whether this
becomes a permanent change or not remains to be seen.
*/
      if (bandwidth_limit == 0) return os_limit;
      else return bandwidth_limit;
a1192 5
     *
     * WT 19-Jan-95 - The parameters list is extended to cater for LCD
     * panels, both single and dual panel, as defined in the LCD_support
     * field of the mode definition file. So, now 6 words are statically
     * allocated.
a1199 1
    int ctrllistpos = 0;
d1253 1
a1253 1
        if ((sel->framerate == -1 || sel->framerate == mp->frame_hz) &&
d1268 1
a1268 1
            if ((current_monitor->dpms_state == -1) && (current_monitor->lcd_support == 0))
d1274 3
a1276 28
                if(current_monitor->dpms_state != -1) {
                    vp->vcparam[ctrllistpos].index = DPMS_INDEX;
                    vp->vcparam[ctrllistpos].value = current_monitor->dpms_state;
                    ctrllistpos++;
                }

                if(current_monitor->lcd_support != 0) {
                    debug printf("I'm an LCD panel & I'm going to tell the Kernel!\n");
                    vp->vcparam[ctrllistpos].index = LCDMODE_INDEX;
                    vp->vcparam[ctrllistpos].value = LCDMODE_VALUE;
                    ctrllistpos++;
                    if(current_monitor->lcd_support != 3) {
                        vp->vcparam[ctrllistpos].index = LCDDUAL_INDEX;
                        vp->vcparam[ctrllistpos].value = LCDDUAL_VALUE;
                        ctrllistpos++;
                    }
                    vp->vcparam[ctrllistpos].index = LCDOFF0_INDEX;
                    vp->vcparam[ctrllistpos].value = LCDOFF0_VALUE;
                        ctrllistpos++;
                    vp->vcparam[ctrllistpos].index = LCDOFF1_INDEX;
                    vp->vcparam[ctrllistpos].value = LCDOFF1_VALUE;
                        ctrllistpos++;
                    vp->vcparam[ctrllistpos].index = DACCTRL_INDEX;
                    vp->vcparam[ctrllistpos].value = DACCTRL_VALUE;
                        ctrllistpos++;
                }

                vp->vcparam[ctrllistpos].index = -1;      /* List terminator */
d1358 1
a1358 1
                regs->r[7] -= entrysize;
d1373 1
a1373 1
        }
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

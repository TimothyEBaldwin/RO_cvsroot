head	1.12;
access;
symbols
	IMXVideo-0_27:1.12
	IMXVideo-0_26:1.11
	IMXVideo-0_25:1.10
	IMXVideo-0_24:1.9
	IMXVideo-0_23:1.8
	IMXVideo-0_22:1.8
	IMXVideo-0_21:1.8
	IMXVideo-0_20:1.7
	IMXVideo-0_19:1.6
	IMXVideo-0_18:1.6
	IMXVideo-0_17:1.5
	IMXVideo-0_16:1.5
	IMXVideo-0_15:1.4
	IMXVideo-0_13:1.3
	IMXVideo-0_12:1.2
	IMXVideo-0_03:1.1.1.1
	Vendor:1.1.1;
locks; strict;
comment	@# @;


1.12
date	2018.04.25.14.38.41;	author jballance;	state Exp;
branches;
next	1.11;
commitid	1C3fWi0qDolHEPzA;

1.11
date	2018.03.31.20.13.17;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	hgdJturC6gtjjEwA;

1.10
date	2018.02.15.23.04.28;	author jballance;	state Exp;
branches;
next	1.9;
commitid	tIqQjRmFq02KF0rA;

1.9
date	2018.02.15.08.45.41;	author jballance;	state Exp;
branches;
next	1.8;
commitid	PMKUVPte89n7VVqA;

1.8
date	2018.02.06.20.33.19;	author jlee;	state Exp;
branches;
next	1.7;
commitid	vRykJTfTsDCN7QpA;

1.7
date	2018.02.04.23.05.03;	author jlee;	state Exp;
branches;
next	1.6;
commitid	vCVYz5w6GNEP1BpA;

1.6
date	2018.02.03.18.28.31;	author jlee;	state Exp;
branches;
next	1.5;
commitid	bIUy9hlDNPOXwrpA;

1.5
date	2017.12.31.14.32.00;	author jballance;	state Exp;
branches;
next	1.4;
commitid	6sKxxmK4qR5vj3lA;

1.4
date	2017.05.01.22.43.25;	author jballance;	state Exp;
branches;
next	1.3;
commitid	OfRRjNRAvphrSJPz;

1.3
date	2017.04.18.22.27.17;	author jballance;	state Exp;
branches;
next	1.2;
commitid	iWtpR6Pt4qpOc4Oz;

1.2
date	2017.04.14.20.49.49;	author jballance;	state Exp;
branches;
next	1.1;
commitid	xH4jIm7E9P2mNxNz;

1.1
date	2017.01.20.23.07.41;	author jballance;	state Exp;
branches
	1.1.1.1;
next	;
commitid	h7Ww9g2WBNf0gLCz;

1.1.1.1
date	2017.01.20.23.07.41;	author jballance;	state Exp;
branches;
next	;
commitid	h7Ww9g2WBNf0gLCz;


desc
@@


1.12
log
@  Convert ADR to ADRL to complete build
Detail:
  changes elsewhere appear to have pushed an offest just beyond the
  range of an ADR. converted to ADRL to buld correctly
Admin:
  tested on iMx6 and smp builds


Version 0.27. Tagged as 'IMXVideo-0_27'
@
text
@; Copyright 2017 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
        ; You'll often see these prefixed with Hdr: for historic reasons.
        ; This is no longer necessary, and in fact omitting them makes it
        ; possible to cross-compile your source code.
        GET     ListOpts
        GET     Macros
        GET     System
        GET     ModHand
        GET     Services
        GET     ResourceFS
        GET     VersionASM
        GET     Proc
        GET     FSNumbers
        GET     HighFSI
        GET     NewErrors
        GET     VideoDevice
        GET     HALEntries
        GET     VidcList
        GET     PCI
        GET     GraphicsV
        GET     VduExt
        GET     AudioDevice
        GET     VFPSupport
        GET     OSMisc
        GET     MsgTrans
        GET     CMOS
        GET     ScrModes

        GBLL    Debug
Debug   SETL    {FALSE};{TRUE};

        ; Allow disable of hardware pointer for testing
        GBLL    HardwarePointer
HardwarePointer SETL {TRUE}

        GBLL    SupportInterlace
SupportInterlace SETL {FALSE} ; Interlaced modes aren't fully working at the moment - needs debugging

        ; Enable/disable HDMI audio code
        GBLL    HDMIAudio
HDMIAudio       SETL {TRUE}

        ; StereoReverse {TRUE} -> we perform stereo reversal
        ; StereoReverse {FALSE} -> OS performs stereo reversal
        ; Should generally be quicker for us to perform it, as it will save the
        ; OS from needing to do a post-process pass on the audio
        GBLL    StereoReverse
StereoReverse   SETL {TRUE}

        ; Support loading ontop of the HAL video driver
  [ :LNOT::DEF: HijackHAL
        GBLL    HijackHAL
HijackHAL       SETL {FALSE}
  ]

        ; Support ReadEDID command + builtin MDF
  [ :LNOT::DEF: CustomBits
         GBLL    CustomBits
CustomBits      SETL {FALSE}
  ]

  [ :LNOT::DEF:standalone
        GBLL    standalone
  ]

        ; Our headers
        GET     Debug
        GET     Video
        GET     iMx6qMemMap
        GET     iMx6qReg
        GET     cpmem
        GET     StaticWS


; Device-specific struct for the VDU device

                        ^ 0
VDUDevSpec_SizeField    # 4 ; Size field
VDUDevSpec_Flags        # 4 ; Misc flags
VDUDevSpec_HDMI_TX_INT  # 4 ; hdmi transmitter interrupt number
VDUDevSpec_CCM_Base     # 4 ; CCM base address
VDUDevSpec_IOMUXC_Base  # 4 ; IOMUXC base address
VDUDevSpec_HDMI_Log     # 4 ; HDMI base address
VDUDevSpec_SRC_Log      # 4 ; System Reset unit logical address
VDUDevSpec_IPU1_Log     # 4 ;
VDUDevSpec_IPU2_Log     # 4 ;
VDUDevSpec_CCMAn_Log    # 4 ;
VDUDevSpec_Size         # 0 ; Size value to write to size field


        ; Assembler modules are conventionally, but not necessarily,
        ; position-independent code. Area name |!| is guaranteed to appear
        ; first in link order, whatever your other areas are named.
        AREA    |!|, CODE, READONLY, PIC

        ENTRY

Module_BaseAddr
        DCD     0 ; Start
        DCD     Init - |Module_BaseAddr|
        DCD     Final - |Module_BaseAddr|
        DCD     ServiceCall - |Module_BaseAddr|; Service call handler
        DCD     Title - |Module_BaseAddr|
        DCD     Help - |Module_BaseAddr|
        DCD     HCKTab -  |Module_BaseAddr|; Keyword table
        DCD     0 ; SWI chunk
        DCD     0 ; SWI handler
        DCD     0 ; SWI table
        DCD     0 ; SWI decoder
        DCD     message_filename - |Module_BaseAddr|
        DCD     Flags - |Module_BaseAddr|

Title   =       Module_ComponentName, 0
Help    =       Module_ComponentName, 9, 9, Module_HelpVersion, 0
        ALIGN
Flags   &       ModuleFlag_32bit

HCKTab
      [ CustomBits
        Command "ReadEDID",  0, 0, 0
      ]
        Command "HDMIOn",  0, 0, International_Help
        Command "HDMIOff", 0, 0, International_Help
        DCB     0
      [ CustomBits
ReadEDID_Help
        DCB     "*ReadEDID loads the available modes from the current monitor's EDID file", 13
ReadEDID_Syntax
        DCB     "Syntax: *ReadEDID", 0
      ]
HDMIOn_Help
        DCB     "CHON", 0
HDMIOn_Syntax
        DCB     "SHON", 0
HDMIOff_Help
        DCB     "CHOF", 0
HDMIOff_Syntax
        DCB     "SHOF", 0
        ALIGN
      [ CustomBits
ReadEDID_Code
        Entry   "sb"
        LDR     sb, [R12]
        ADR     r1, %FT20
        MOV     r0, #OSFile_ReadNoPath
        SWI     XOS_File
        MOVVS   r0, #object_nothing
        CMP     r0, #object_file
        ADREQ   r0, %FT10         ; obliges ScrModes to reload EDID
        ADRNEL  r0, ErrorBlock_FailedEDID
        BLNE    CopyError         ; sets V
        SWIVC   XOS_CLI
        EXIT
10
        DCB     "%LoadModeFile "
20
        DCB     "Resources:$.Resources.ScreenMode.Monitors.EDID0", 0
      ]
HDMIOn_Code
        Entry   "sb"
        MOV     R0, #1
        B       HDMIOnOff_Common

HDMIOff_Code
        ALTENTRY
        MOV     R0, #0
HDMIOnOff_Common
        LDR     sb, [R12]
        LDRB    R1, HDMIEnabled
        CMP     R0, R1
        EXIT    EQ
      [ HDMIAudio
        ; Shutdown audio device if HDMI is being disabled
        CMP     R0, #0
        BLEQ    Audio_Deregister
      ]
        ; Warn the OS that the available modes are about to change
        Push    "r0-r3"
        MOV     r0, #DisplayStatus_Changing
        MOV     r1, #Service_DisplayStatus
        LDRB    r2, GVinstance
      [ CustomBits
        MOV     r3, #0            ; subreason 0 - display changing
      ]
        SWI     XOS_ServiceCall
        Pull    "r0-r3"
        STRB    R0, HDMIEnabled
        ; Reprogram current mode in order to enact the change
        STR     R0, mHdmiDviSel
        BL      ReInitVideoMode
        ; Let the OS know that everything is OK
        Push    "r0-r3"
        MOV     r0, #DisplayStatus_Changed
        MOV     r1, #Service_DisplayStatus
        LDRB    r2, GVinstance
      [ CustomBits
        MOV     r3, #0            ; subreason 0 - display changing
      ]
        SWI     XOS_ServiceCall
        Pull    "r0-r3"
      [ HDMIAudio
        ; Re-register audio device if HDMI now on
        CMP     R0, #0
        BLNE    Audio_Register
      ]
        EXIT

        ASSERT  Service_PostInit < Service_ModulePostInit
        ASSERT  Service_ModulePostInit < Service_ModulePostFinal
ServiceCallTable
        DCD     0
        DCD     ServiceCallEntry - Module_BaseAddr
      [ CustomBits
        DCD     Service_PostInit
      ]
      [ HDMIAudio
        DCD     Service_ModulePostInit
        DCD     Service_ModulePostFinal
      ]
        DCD     0

        DCD     ServiceCallTable - Module_BaseAddr
ServiceCall     ROUT
        MOV     r0, r0
        TEQ     r1, #Service_PostInit
      [ HDMIAudio
        TEQNE   r1,#Service_ModulePostInit
        TEQNE   r1,#Service_ModulePostFinal
      ]
        MOVNE   pc, lr

ServiceCallEntry
        Entry   "r0-r1,sb"
        LDR     sb, [r12]
      [ HDMIAudio
        TEQ     r1, #Service_ModulePostInit
        TEQNE   r1, #Service_ModulePostFinal
        BNE     %FT80
        ADR     r0, Module_VFPSupport
        BL      mystrcmp
        BLEQ    VFPInitFinal
        B       %FT90
      ]
80
      [ CustomBits
        ; Service_PostInit
        adrl    r0, loadmodefilecommand         ; do this if EDID not configured
        swi     XOS_CLI
        ldrb    r0, MonitorType
        teq     r0, #MonitorTypeEDID
        bne     %ft90
        mov     r0, #0
        mov     r1, #Service_DisplayChanged
        ldrb    r2, GVinstance
        mov     r3, #1             ; r3=1 obliges ScrModes to reload EDID
        swi     XOS_ServiceCall
        MOV     r0, #1
        SWI     XOS_ScreenMode
        MOVVC   r0, #0
        SWIVC   XOS_ScreenMode
      ]
90
        CLRV
        EXIT

mystrcmp ROUT
        ; Compare r0 with r2
        ; Exit EQ if equal
        Entry   "r0-r2"
10
        LDRB    r1, [r0], #1
        LDRB    lr, [r2], #1
        CMP     r1, lr
        EXIT    NE
        CMP     r1, #0
        BNE     %BT10
        EXIT

 [ HDMIAudio
Module_VFPSupport
        DCB     "VFPSupport", 0
        ALIGN
VFPInitFinal ROUT
        Entry
        CMP     r1, #Service_ModulePostInit
        BEQ     %FT50
        ; ModulePostFinal
        ; VFPSupport actually issues this manually, just before it shuts down
        ; This allows us to clean up properly (unlike a real PostFinal)
        BL      Audio_Deregister ; Deregistering is the easiest way of stopping playback
        BL      Finalise_NEON
        EXIT
50
        ; ModulePostInit
        ; Attempt to re-register if HDMI is enabled (will automatically create VFP context)
        LDRB    lr, HDMIEnabled
        CMP     lr, #0
        BLNE    Audio_Register
        EXIT
 ]


Init    ROUT
        Entry   "r8,sb"
        IMPORT  __RelocCode
        BL      __RelocCode

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =TotalRAMRequired
        SWI     XOS_Module
        EXIT    VS

        STR     r2, [r12]
        mov     sb, r2
        MOV     r6, #0
01
        SUBS    r3, r3, #4
        STR     r6, [r2], #4
        BGT     %BT01

; Get DMB_Write ARMop
        LDR     r0, =MMUCReason_GetARMop+(ARMop_DMB_Write:SHL:8)
        SWI     XOS_MMUControl
        ADRVSL  r0, NullFunc
        STR     r0, DMB_Write

      [ standalone :LOR: CustomBits
; register an MDF with our default startup mode in it so HAL_VideoStartupMode
; or GraphicsV_VideoStartupMode can be to our liking
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_RegisterFiles
        BVS     ExitInitModule
        ORR     R6, R6, #InitFlag_ResFiles
      ]

; locate the Video device address.. HAL should have registered it by now
        mov     r1, #0                  ; first time through
05
        ldr     r0, = HALDeviceType_Video + HALDeviceVideo_VDU +(HALDeviceID_VDU_IMX6<<16)
        mov     r8, #OSHW_DeviceEnumerate
        swi     XOS_Hardware
        CMP     r1, #-1                 ; if -1, no find the Video device
        BNE     %FT10
        ADRL    r0, ErrorBlock_HardwareDepends ; else we cannot do anything here
        BL      CopyError
        B       ExitInitModule
10
        LDR     lr, [r2, #HALDevice_VDUDeviceSpecificField]
      [ :LNOT: HijackHAL
        LDR     r0, [lr, #VDUDevSpec_Flags]
        TST     r0, #1                  ; Bit 1 will be set if video is in HAL - if we don't support that, look for another device (and most likely throw an error)
        BNE     %BT05
      ]

        STR     r2, HALDevice

        LDR     r0, [lr, #VDUDevSpec_CCM_Base]
        STR     r0, CCM_Base
        LDR     r0, [lr, #VDUDevSpec_IOMUXC_Base]
        STR     r0, IOMUXC_Base
        LDR     r0, [lr, #VDUDevSpec_HDMI_Log]
        STR     r0, HDMI_Log
        LDR     r0, [lr, #VDUDevSpec_SRC_Log]
        STR     r0, SRC_Log
        LDR     r0, [lr, #VDUDevSpec_IPU1_Log]
        STR     r0, IPU1_Log
        LDR     r0, [lr, #VDUDevSpec_IPU2_Log]
        STR     r0, IPU2_Log
        LDR     r0, [lr, #VDUDevSpec_CCMAn_Log]
        STR     r0, CCMAn_Log

 [ HardwarePointer
        ; Allocate some memory for the pointer image
        mov     a1, #HW_CURSOR_WIDTH*HW_CURSOR_HEIGHT*4
        mov     a2, #HW_CURSOR_WIDTH*4
        mov     a3, #0
        swi     XPCI_RAMAlloc
        bvs     ExitInitModule
        str     a1, PointerLog
        str     a2, PointerPhys
        ;DebugReg a1, "PointerLog "
        ;DebugReg a1, "PointerPhys "
 ]

      [ CustomBits
        MOV     r0, #ReadCMOS
        MOV     r1, #VduCMOS
        SWI     XOS_Byte
        MOV     r0, #MonitorType4       ; default to svga
        ANDVC   r0, r2, #MonitorTypeBits; clear out irrelevant bits
        STRB    r0, MonitorType         ; remember if EDID monitor configured
      ]

      [ HijackHAL
        ; Skip most of this if the HAL driver is active
        LDR     r0, HALDevice
        LDR     r0, [r0, #HALDevice_VDUDeviceSpecificField]
        LDR     r0, [r0, #VDUDevSpec_Flags]
        TST     r0, #1
        BEQ     %FT30
        MOV     r0, #0 ; Hijack the HAL GV driver number (should be 0)
        STRB    r0, GVinstance
        MOV     r0, #GraphicsV                          ; grab GraphicsV
        ADRL    r1, GraphicsV_Handler
        MOV     r2, sb
        SWI     XOS_Claim
        BVS     ExitInitModule
        ORR     r6, r6, #InitFlag_GVClaim+InitFlag_HALHijacked

        ; Trigger a mode change to make sure we're initialised correctly
        MOV     r0, #1
        SWI     XOS_ScreenMode
        MOVVC   r0, #0
        SWIVC   XOS_ScreenMode
        BVS     ExitInitModule
        B       %FT50
30
      ]
        MOV     r0, #ScreenModeReason_RegisterDriver
        MOV     r1, #0
        ADRL    r2, Title
        SWI     XOS_ScreenMode                          ; get a driver number
        BVS     ExitInitModule
        ORR     r6, r6, #InitFlag_GVRegistered
        STRB    r0, GVinstance

        ; Set up the VSync handler
        LDR     r3, HALDevice
        LDR     r0, [r3, #HALDevice_Device]
        ADRL    r1, VSync_Handler
        MOV     r2, sb
        SWI     XOS_ClaimDeviceVector
        BVS     ExitInitModule
        ORR     r6, r6, #InitFlag_VSyncClaim
        LDR     r0, [r3, #HALDevice_Device]
        MOV     r8, #OSHW_CallHAL
        Push    "sb"
        MOV     r9, #EntryNo_HAL_IRQEnable
        SWI     XOS_Hardware
        Pull    "sb"
        BVS     ExitInitModule

        MOV     r0, #GraphicsV                          ; grab GraphicsV
        ADRL    r1, GraphicsV_Handler
        MOV     r2, sb
        SWI     XOS_Claim
        BVS     ExitInitModule
        ORR     r6, r6, #InitFlag_GVClaim

        MOV     r0, #ScreenModeReason_StartDriver
        LDRB    r1, GVinstance
        SWI     XOS_ScreenMode                          ; let the OS know we're ready
        BVS     ExitInitModule
        ORR     r6, r6, #InitFlag_GVStarted

50
      [ HDMIAudio
        BL      Audio_ModInit
      ]
      [ CustomBits
        MOV     r0, #0
        MOV     r1, #Service_DisplayChanged
        LDRB    r2, GVinstance
        MOV     r3, #0
        SWI     XOS_ServiceCall          ; oblige ScrModes to readedid if poss
      ]
ExitInitModule
        STR     r6, InitFlags
        EXIT    VC
        ; Re-use finalisation code to perform a shutdown (but return our error)
        ; N.B. this only works because we don't touch R12 during init
        Push    "r0"
        BL      Final
        Pull    "r0"
        SETV
        EXIT

Final   ROUT
        Entry   "sb"
        LDR     sb, [r12]
        LDR     r6, InitFlags

      [ HDMIAudio
        BL      Audio_ModFinal
      ]

        CLRV
        TST     r6, #InitFlag_GVStarted
        MOVNE   r0, #ScreenModeReason_StopDriver
        LDRNEB  r1, GVinstance
        SWINE   XOS_ScreenMode                ; tell the OS we're leaving
        BVS     %FT90
        BIC     r6, r6, #InitFlag_GVStarted

        TST     r6, #InitFlag_GVClaim
        MOVNE   r0, #GraphicsV
        ADRNEL  r1, GraphicsV_Handler
        MOVNE   r2, sb
        SWINE   XOS_Release
        BVS     %FT90
        BIC     r6, r6, #InitFlag_GVClaim

      [ HijackHAL
        TST     r6, #InitFlag_HALHijacked
        BEQ     %FT40
        ; Trigger a mode change to make sure the HAL is back in control
        MOV     r0, #1
        SWI     XOS_ScreenMode
        MOVVC   r0, #0
        SWIVC   XOS_ScreenMode
        CLRV ; Ignore any error that comes through from this, it's not our fault if the kernel/HAL can't find a suitable mode
        BIC     r6, r6, #InitFlag_HALHijacked
40
      ]

        TST     r6, #InitFlag_VSyncClaim
        LDRNE   r0, HALDevice
        LDRNE   r0, [r0, #HALDevice_Device]
        ADRNEL  r1, VSync_Handler
        MOVNE   r2, sb
        SWINE   XOS_ReleaseDeviceVector
        BVS     %FT90
        BIC     r6, r6, #InitFlag_VSyncClaim

        TST     r6, #InitFlag_GVRegistered
        MOVNE   r0, #ScreenModeReason_DeregisterDriver
        LDRNEB  r1, GVinstance
        SWINE   XOS_ScreenMode
        BVS     %FT90
        BIC     r6, r6, #InitFlag_GVRegistered

        LDR     r0, PointerLog
        CMP     r0, #0
        SWINE   XPCI_RAMFree
        CLRV ; A potential memory leak isn't so bad, ignore any error from here
        MOV     r0, #0
        STR     r0, PointerLog
        STR     r0, PointerPhys

        BL      close_messagefile

      [ standalone :LOR: CustomBits
        TST     R6,#InitFlag_ResFiles
        ADRNEL  R0,resourcefsfiles
        SWINE   XResourceFS_DeregisterFiles
        BVS     %FT90
        BIC     R6,R6,#InitFlag_ResFiles
      ]

90
        STR     r6, InitFlags
        EXIT

HAL_CounterDelay ROUT
        Entry   "r8,r9"
        MOV     r8,#OSHW_CallHAL
        MOV     r9,#EntryNo_HAL_CounterDelay
        SWI     XOS_Hardware
        EXIT

VSync_Handler
        Entry   "r0-r5,r8,sb"
        ; Drop into SVC mode for SWI calls
        MRS     r5, CPSR
        ORR     r0, r5, #SVC32_mode
        MSR     CPSR_c, r0
        Push    "lr"
        MOV     sb, r12
        ; Clear the IRQ
        LDR     a2, IPU1_Log
        ADD     a2, a2, #IPU_REGISTERS_OFFSET
        MVN     a3, #0
        STR     a3, [a2, #IPU_IPU_INT_STAT_15_OFFSET-IPU_REGISTERS_OFFSET]
        LDR     r0, HALDevice
        LDR     r0, [r0, #HALDevice_Device]
        MOV     r8, #OSHW_CallHAL
        Push    "sb"
        MOV     r9, #EntryNo_HAL_IRQClear
        SWI     XOS_Hardware
        Pull    "sb"
        ; Trigger VSync in OS
        LDRB    r4, GVinstance
        MOV     r9, #GraphicsV
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_VSync
        SWI     XOS_CallAVector
        Pull    "lr"
        MSR     CPSR_c, r5
        EXIT

NullFunc
        MOV     pc, lr

CopyError ROUT
        Entry   "r0-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     R1, MessageFile_Block
        MOV     R2, #0
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        STR     r0, [sp]
        EXIT

message_filename
        DCB     "Resources:$.Resources.IMXVideo.Messages", 0
        ALIGN

open_messagefile ROUT
        Entry   "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     R0, MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

close_messagefile ROUT
        Entry   "r0"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        ADRNE   r0, MessageFile_Block
        SWINE   XMessageTrans_CloseFile
        CLRV
        MOV     r0, #0
        STR     r0, MessageFile_Open
        EXIT

        LTORG

      [ CustomBits
; make sure the command matches the resource file below!!
loadmodefilecommand
        DCB     "loadmodefile Resources:Resources.IMXVideo.IMX6Mon",0
        ALIGN
      ]

resourcefsfiles
      [ CustomBits
        ResourceFile    Resources.IMX6Mon, Resources.IMXVideo.IMX6Mon
      ]
      [ standalone
        ResourceFile    $MergedMsgs, Resources.IMXVideo.Messages
      ]
        DCD     0                   ; terminator
        GET     s.GraphicsV
        GET     s.Debug
        GET     s.Video
      [ HDMIAudio
        GET     s.Audio
      ]
        GET     s.Errors
        END
@


1.11
log
@Use the existing command rather than a special handshake
To force the EDID blob to be used, simply load it with *LoadModeFile.
Check it's there first and translate to a nice error message if not (ie. the monitor's not provided any EDID data).
See rationale in ScrModes-0_68.

Version 0.26. Tagged as 'IMXVideo-0_26'
@
text
@d435 1
a435 1
        ADR     r2, Title
@


1.10
log
@   HijackHAL flag now elso nclosed in '[ :LNOT::DEF' construct
to permit compile time flag definition
Detail:
Admin:
 testes on imx6smp

Version 0.25. Tagged as 'IMXVideo-0_25'
@
text
@d28 1
d157 10
a166 6
        LDR     sb, [r12]
        MOV     r0, #0
        MOV     r1, #Service_DisplayChanged
        LDRB    r2, GVinstance
        MOV     r3, #1             ; r3=1 obliges ScrModes to reload EDID
        SWI     XOS_ServiceCall
d168 4
@


1.9
log
@  Recent changes meant that certain features got a conditional assembly
  flag 'CustomBits'. Flag now enclosed in '[ :LNOT::DEF' construct
  to permit compile time flag definition
Detail:
Admin:
  tested on iMx6


Version 0.24. Tagged as 'IMXVideo-0_24'
@
text
@d64 1
d67 1
@


1.8
log
@Improve error handling during module init/final
Detail:
  s/IMXVideo, hdr/StaticWS - Keep track of what's been initialised during module init so that it can be torn down properly on module finalisation or if initialisation fails
Admin:
  Tested on wandboard


Version 0.21. Tagged as 'IMXVideo-0_21'
@
text
@d68 2
a69 1
        GBLL    CustomBits
d71 1
d497 1
a497 1
        
@


1.7
log
@Improve mode vetting. Internationalise help text.
Detail:
  s/GraphicsV - Mode vetting now checks the mode timings
  s/IMXVideo, Resources/UK/CmdHelp - Internationalise help text
  s/Video - Update a few debug messages to more closely match the register names
Admin:
  Tested on wandboard


Version 0.20. Tagged as 'IMXVideo-0_20'
@
text
@d312 1
a312 1
        BVS     ExitInitModule
d316 1
a316 1
        MOV     r0, #0
d319 1
a319 1
        STR     r0, [r2], #4
d332 3
a334 1
        SWI     XResourceFS_RegisterFiles   ; ignore errors
d379 1
a379 1
        EXIT    VS
d408 2
d416 1
d425 1
d434 2
d442 1
d448 2
d454 2
d468 9
a476 4
        EXIT

ExitInitModule                          ; need to check for what is allocated
        BL      close_messagefile
d482 1
d488 15
a502 17
      [ HijackHAL
        ; Skip appropriate bits of shutdown logic if we're hijacking the HAL driver
        LDR     r3, HALDevice
        LDR     r3, [r3, #HALDevice_VDUDeviceSpecificField]
        LDR     r3, [r3, #VDUDevSpec_Flags]
        TST     r3, #1
        BNE     %FT20
      ]

        MOV     r0, #ScreenModeReason_StopDriver
        LDRB    r1, GVinstance
        SWI     XOS_ScreenMode                ; tell the OS we're leaving
20
        MOV     r0, #GraphicsV
        ADRL    r1, GraphicsV_Handler
        MOV     r2, sb
        SWI     XOS_Release
d505 1
a505 1
        TST     r3, #1
d512 2
a513 1
        B       %FT50
d517 16
a532 9
        LDR     r0, HALDevice
        LDR     r0, [r0, #HALDevice_Device]
        ADRL    r1, VSync_Handler
        MOV     r2, sb
        SWI     XOS_ReleaseDeviceVector
        MOV     r0, #ScreenModeReason_DeregisterDriver
        LDRB    r1, GVinstance
        SWI     XOS_ScreenMode
50
d534 6
a539 1
        SWI     XPCI_RAMFree
d544 5
a548 2
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles ; ignore errors
d551 2
a552 1
        CLRV
d634 3
@


1.6
log
@Cleanup pass
Detail:
  s/IMXVideo, s/GraphicsV, hdr/StaticWS - Turn off HijackHAL now that the HAL video driver is disabled. Wrap *ReadEDID command, builtin MDF, and other unusual code in a CustomBits switch, and disable it, to remove some blockers for the stable RISC OS 5.24 release.
Admin:
  Tested on wandboard
  EDID & HDMI audio still functional


Version 0.18. Tagged as 'IMXVideo-0_18'
@
text
@d71 4
d119 1
a119 1
        DCD     0 ; Messages
d131 2
a132 2
        Command "HDMIOn",  0, 0, 0
        Command "HDMIOff", 0, 0, 0
d141 1
a141 1
        DCB     "*HDMIOn enables HDMI mode video", 13
d143 1
a143 1
        DCB     "Syntax: *HDMIOn", 0
d145 1
a145 1
        DCB     "*HDMIOff enables DVI mode video", 13
d147 1
a147 1
        DCB     "Syntax: *HDMIOff", 0
d328 1
d333 1
a507 3
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles ; ignore errors

d513 5
d615 3
@


1.5
log
@Resync IMXVideo with development version


Version 0.16. Tagged as 'IMXVideo-0_16'
@
text
@d65 5
a69 1
HijackHAL       SETL {TRUE}
d120 1
d124 1
d126 1
d130 1
d135 1
d145 1
d155 1
d179 1
d181 1
d193 3
a196 1
        MOV     r3, #0            ; subreason 0 - display changing
d210 1
d212 1
d242 1
d258 1
d378 9
a400 7
        MOV     r0, #ReadCMOS
        MOV     r1, #VduCMOS
        SWI     XOS_Byte
        MOV     r0, #MonitorType4       ; default to svga
        ANDVC   r0, r2, #MonitorTypeBits; clear out irrelevant bits
        STRB    r0, MonitorType         ; remember if EDID monitor configured

d442 1
d448 1
a448 1

d596 1
d601 1
d604 1
d606 1
@


1.4
log
@Adjust ReadEDID command to match ScrModes new code
Detail:
ScrModes Service_DisplayChanged reason code 0 can be used to force reading
of the EDID. It has been extended with sub reason 1 to oblige it to load
the EDID found.
Admin:
Tested on iMx6


Version 0.15. Tagged as 'IMXVideo-0_15'
@
text
@a27 1
        GET     CMOS
d31 3
a33 1
        GET     Debug
d35 6
a40 1

d45 21
a65 2
          GBLL  SWPointer ; Software pointer
SWPointer SETL  {FALSE}
d67 7
a73 49
          GBLL  UseGraphV ; Use GraphicsV?
UseGraphV SETL  {FALSE}

          GBLL  HWPointer ; Hardware pointer via VCHIQ/dispmanx
HWPointer SETL  {FALSE}

; workspace definition
                 ^       0,      wp                              ; Store

PeriBase         #       4              ; io base address

mbram            #       0           ; structure needed for frame buffer descriptor
mbxres           #       4
mbyres           #       4
mbxvres          #       4
mbyvres          #       4
mbpitch          #       4 ; byte pitch
mbbpp            #       4 ; 8/16/32
mbxoff           #       4
mbyoff           #       4
mbbase           #       4 ; physical base of frame buffer
mbscrsz          #       4 ; size


PaletteDirty     #       4 ; whether 8bpp palette dirty; also indicates whether ticker event is pending

vdu_init         #       4 ; VDU init phys addr, for GV_Render

HDMI_Log         #       4 ; HDMI Logical address
VideoDevice      #       HALDeviceSize + 32 ; ******* need to link acress from HAL
CurPalette       #       4*4
GVRenderNotAvailable #   1 ; Whether GraphicsV_Render is available
GVinstance           #   1
MonitorType      #   1
                     #   1 ; back to word alignment
 [ SWPointer
SWPAddr          #       4 ; where to restore cursor image, or 0 for none, or 1 to disable pointer updates
SWPHeight        #       4
SWPUnder         #       32*4*32
 ]

modedefbuf       #       256
modedefbufref    #       256

Palette          #       256*4

; align to 4 byte boundary
                 #       (((:INDEX:@@)+3):AND::NOT:3)-(:INDEX:@@)
TotalRAMRequired *      :INDEX: @@
d80 9
a88 2
VDUDevSpec_DMAChan      # 4 ; Pointer to DMA channel
VDUDevSpec_BurstLen     # 4 ; Burst length for use with DMA channel
d124 1
a124 1
        DCB     "*ReadEDID loads the available modes from the current monitor's EDID table", 13
a135 1

d137 8
a144 9
        MOV     R6, LR
        ldr     r12, [r12]
        mov     r0, #0
        mov     r1, #Service_DisplayChanged
        mov     r2, #0
        mov     r3, #1             ; oblige it to reset to edid mode file
        swi     XOS_ServiceCall
        MOV     PC, R6

d146 3
a148 15
        MOV     R6, LR
        ldr     r12, [r12]
        ldr     r1, HDMI_Log
        teq     r1, #0
        beq     %ft1
        add     r1, r1, #&1000
        ldrb    r2, [r1]
        orr     r2, r2, #8                 ; hdmi/dvi selector
        strb    r2, [r1]
        MOV     PC, R6
1
        SWI     XOS_WriteS
        =       "Cannot find it, I wish I could",10,13,0
        ALIGN
        MOV     PC, R6
d151 38
a188 16
        MOV     R6, LR
        ldr     r12, [r12]
        ldr     r1, HDMI_Log
        teq     r1, #0
        beq     %ft1
        add     r1, r1, #&1000
        ldrb    r2, [r1]
        bic     r2, r2, #8                 ; hdmi/dvi selector
        strb    r2, [r1]
        MOV     PC, R6
1
        SWI     XOS_WriteS
        =       "Cannot find it, I really wish I could",10,13,0
        ALIGN
        MOV     PC, R6

d191 1
d196 4
a199 3
;      [ HWPointer
;        DCD     Service_ModulePostInit
;      ]
d206 4
a209 3
;      [ HWPointer
;        TEQNE   r1, #Service_ModulePostInit
;      ]
d213 13
a225 9
;    [ HWPointer
;        TEQ      r1, #Service_ModulePostInit
;        BNE      %FT90
;        Entry    "r0-r2"
;        EXIT
;90
;    ]
        stmfd    sp!, {r0,lr}
        ldr     r12, [r12]
d230 50
a279 36
        moveq   r0, #0
        moveq   r1, #Service_DisplayChanged
        moveq   r2, #0
        moveq   r3, #1
        swieq   XOS_ServiceCall          ; oblige ScrModes to readedid if poss
        ldmfd    sp!, {r0,pc}

;; must specify interlace, as otherwise the kernel will attempt
;; to write this.. it may not be in writable space
;modedefv3
;        DCD  3          ; type 3 list
;        DCD  5          ; bpp
;        DCD  0          ; h sync
;        DCD  0          ; h back porch
;        DCD  0          ; h left border
;        DCD  1280       ; h pixels
;        DCD  0          ; h right border
;        DCD  0          ; h front porch
;        DCD  0          ; v sync
;        DCD  0          ; v back porch
;        DCD  0          ; v left border
;        DCD  800        ; v pixels
;        DCD  0          ; v right border
;        DCD  0          ; v front porch
;        DCD  0          ; pixel rate
;        DCD  4          ; sync flags interlace not speccd .. no interlace
;        DCD  -1         ; list end
;        DCD  -1         ; list end
;modedefv3size     * .-modedefv3
;startupmode
;        DCD 1           ; mode selector block format 0
;        DCD 1280        ; x pixels
;        DCD 800         ; y pixels
;        DCD 5           ; log2bpp = 32
;        DCD -1          ; frame rate or (-1)first match
;        DCD -1          ; end of list, no further mode variables
d282 4
a285 1
        Push    "r8-r9,lr"
d292 1
a292 1
        mov     r12, r2
d298 7
a304 5
        MOV     r0, #1
        STRB    r0, GVRenderNotAvailable
      [ SWPointer
        STR     r0, SWPAddr
      ]
a309 24
;      [ HWPointer
;        ; Get IRQTrigger routine
;        MOV     r0, #0
;        SWI     XOS_PlatformFeatures
;        MOVVS   r0, #0
;        TST     r0, #2
;        ADREQ   r1, NullFunc ; Just use NullFunc if no trigger needed
;        STR     r1, IRQTrigger
;        BL      HWP_Init
;        CLRV
;      ]

;        adrl    r3, modedefbuf
;        adrl    r4, modedefbufref
;        adr     r1, modedefv3
;11      ldr     r0, [r1] , #4
;        str     r0, [r3] , #4
;        str     r0, [r4] , #4
;        cmn     r0, #1
;        bne     %bt11

;        adrl    r0, modedefbuf
;        bl      SetModeFromVIDCList

d311 2
d314 1
a314 2
        mov     r1, #0                  ; first time through
        mov     r8, #4                  ; enumerate_drivers
d316 14
a329 11
 DebugReg r1, "looking.. r1= "
 DebugReg r2, "DevPtr... "
        teq     r1, #0                  ; if -1, no find the Video device
        EXIT    LE                      ; else we cannot do anything here
 DebugReg r12, "mod pwp... "
        adrl    r1, VideoDevice
        mov     r0, #HALDeviceSize
1       subs    r0, r0, #4
        ldrge   lr, [r2, r0]
        strge   lr, [r1, r0]           ; copy it
        bgt     %bt1
d331 27
d359 9
a367 1
 [  UseGraphV
d370 1
a370 1
        MOV     r2, r12
d372 1
a372 1
 ]
d380 8
d394 19
a412 6
        ldr     r1, =&120000              ; HDMI Base Address
        mov     r2, #&100000               ; lets do a meg (should already be there
        mov     r0, #13; + &300            ; non cache non buffer
        swi     XOS_Memory
        movvs   r3, #0
        str     r3, HDMI_Log             ; remember
d415 1
a415 1
        SWI     XOS_ScreenMode           ; let the OS know we're ready
d417 9
a425 5
        mov     r0, #0
        mov     r2, #0
        mov     r3, #1
        mov     r1, #Service_DisplayChanged
        swi     XOS_ServiceCall          ; oblige ScrModes to readedid if poss
d427 1
a427 1
        Pull    "r8-r9,pc"
d429 3
a431 2
ExitInitModule                            ; need to check for what is allocated
        Pull    "r8-r9,pc"
d434 16
a449 4
        Push    "lr"
        LDR     r12, [r12]
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles ; ignore errors
d453 1
a453 1
 [  UseGraphV
d456 1
a456 1
        MOV     r2, r12
d458 18
a475 1
 ]
d479 3
a481 2
        CLRV
        Pull    "pc"
d483 2
a484 159
;
; format of a VIDC list type 3
;
                                ^       4
VIDCList3_PixelDepth            #       4
VIDCList3_HorizSyncWidth        #       4
VIDCList3_HorizBackPorch        #       4
VIDCList3_HorizLeftBorder       #       4
VIDCList3_HorizDisplaySize      #       4
VIDCList3_HorizRightBorder      #       4
VIDCList3_HorizFrontPorch       #       4
VIDCList3_VertiSyncWidth        #       4
VIDCList3_VertiBackPorch        #       4
VIDCList3_VertiTopBorder        #       4
VIDCList3_VertiDisplaySize      #       4
VIDCList3_VertiBottomBorder     #       4
VIDCList3_VertiFrontPorch       #       4
VIDCList3_PixelRate             #       4
VIDCList3_SyncPol               #       4  ; sync polarity/flag bits
VIDCList3_ControlList           #       0  ; possibly empty list of pairs of
                                           ; index,value words
;
; and VIDCList3 is terminated by a -1 word
;
; Indices in VIDCList3_ControlList
;
                                ^       1
ControlList_LCDMode             #       1
ControlList_LCDDualPanelMode    #       1
ControlList_LCDOffset0          #       1
ControlList_LCDOffset1          #       1
ControlList_HiResMode           #       1
ControlList_DACControl          #       1
ControlList_RGBPedestals        #       1
ControlList_ExternalRegister    #       1
ControlList_HClockSelect        #       1
ControlList_RClockFrequency     #       1
ControlList_DPMSState           #       1
ControlList_Interlaced          #       1
ControlList_OutputFormat        #       1
ControlList_ExtraBytes          #       1
ControlList_InvalidReason       #       0

; bits/flags in VIDCList3_SyncPol word:
;
SyncPol_InvertHSync        *  1
SyncPol_InvertVSync        *  2
SyncPol_InterlaceSpecified *  4   ; if set, interlace bit has been specified, else filled in by kernel
SyncPol_Interlace          *  8   ; set=interlaced, either specified by service call claimant or filled in from *TV by kernel


;; r0->VIDCList3   (writable!!)
;; r12-> workspace
;SetModeFromVIDCList     ROUT
;        Push    "r0-r7,lr"
;        mov     r6, r0                     ; preserve the list pointer
;  DebugTX "start SetMode"
;
; [  UseGraphV
;        ; Block GV_Render, and sync any current transfer for paranoia
;        MOV     r0, #1
;        STRB    r0, GVRenderNotAvailable
;        BL      GV_Render_Sync
; ]
;   [ SWPointer
;        ; Block pointer updates
;        STR     r0, SWPAddr
;   ]
;        adrl    r7,modedefbuf
;11      ldr     r0, [r6] , #4
;        str     r0, [r7] , #4
; DebugRegNCR r0, ""
;        cmn     r0, #1
;        bne     %bt11
;        ldr     r6, [sp]                   ; recover the pointer
;
;        LDR     r0, [r6, #VIDCList3_PixelDepth]
; DebugRegNCR r0, "PixelDepth in "
;        CMP     r0, #4
;        MOVLO   r0, #8
;        MOVEQ   r0, #16
;        MOVHI   r0, #32
;        STR     r0, mbbpp
; DebugReg r0, "used "
;;        str     r0, [r3, #dispbpp-tagb]
;        LDR     r0, [r6, #VIDCList3_HorizDisplaySize]
;        STR     r0, mbxres
;        STR     r0, mbxvres
;;        str     r0, [r3, #phyx-tagb]
;;        str     r0, [r3, #virtx-tagb]
; DebugRegNCR r0, "XRes="
;        LDR     r0, [r6, #VIDCList3_VertiDisplaySize]
;        STR     r0, mbyres
;        STR     r0, mbyvres
;;        str     r0, [r3, #phyy-tagb]
;;        str     r0, [r3, #virty-tagb]
; DebugRegNCR r0, "YRes="
;        mov     r0, r3
;        mov     r0,#&14000000   ;;;; tempo hard code
;        str     r0, mbscrsz
; DebugRegNCR r0, "Temp initial screen size "
;        mov     r0, #&02000000 ;;;; temop hard code
;        str     r0, mbbase
; DebugReg r0, "at phys addr "
;        STR     r0, vdu_init ; just in case GV_Render calls are received before RISC OS tells us the VDU address
;
;;        ldr     r0, [r3,#dispit-tagb]
;;        str     r0, mbpitch
;; DebugRegNCR r0, "pitch="
;
;;        ; Allow GV_Render, if DMA channel available
;;        LDR     r0, DMA_Chan
;;        TEQ     r0, #0
;;        MOVNE   r0, #0
;;        STRNEB  r0, GVRenderNotAvailable
; [ SWPointer
;        ; Allow pointer updates
;        MOV     r0, #0
;        STR     r0, SWPAddr
; ]
;; [ HWPointer
;;        ; Recache display values
;;        LDR     r0, HWPActive
;;        CMP     r0, #0
;;        BLNE    HWP_CalcDisplayScaleOffset
;; ]
; DebugTX "done FB2"
;
;        Pull    "r0-r7,pc"



; r0 = mode or->VIDCList3   (writable!!)
; r12-> workspace
VetModeFromVIDCList     ROUT
        Push    "r0-r7,lr"
        mov     r6, r0                     ; preserve the list pointer
  DebugTX "start vmfv3"
        adrl    r7,modedefbuf
11      ldr     r0, [r6] , #4
        str     r0, [r7] , #4
 DebugRegNCR r0,""
        cmn     r0, #1
        bne     %bt11
        Pull    "r6"                       ; recover the pointer
  DebugTX "modedefbuf printed"
  cmn     r0, #1


        ; The VC 'test' calls seem to be broken and just return the current FB settings
        ; So don't bother doing a full vet sequence
        ; However exerimentation suggests that the VC rounds up the display pitch to a multiple of 32 bytes
        ; So as a simple vet, make sure no padding is being introduced, as RISC OS won't expect it
        ; TODO - Should also pay attention to ExtraBytes control list entry
        LDR     r0, [r6, #VIDCList3_HorizDisplaySize]
        LDR     r1, [r6, #VIDCList3_PixelDepth]
        MOV     r0, r0, LSL r1
        TST     r0, #(32*8)-1
        BNE     %FT999
d486 1
a486 1
 DebugTX "done vFB2"
d488 1
a488 52
        mov     r0, #0
; exit r0=0 if we like the mode, else untouched
        Pull    "r1-r7,pc"
999

 DebugTX "done vFB2 - mode vet fail"

        MOV     r0, r6                   ; recover original r0
        Pull    "r1-r7"
        Pull    "pc"



; in: r1 = pointer to palette entries
;     r2 = base
;     r3 = count
; Palette updates seem to be quite slow, not helped by the fact that RISC OS likes to update them one at a time. To counter this, we buffer the updates and perform them on the next tick.
; TODO - If the updates are slow, it's probably a bad thing to be doing them with IRQs disabled, but at the moment that's the only way of ensuring the message buffer isn't in use already
SetPalette      ROUT
        Entry   "r0-r4"
        ; Copy over new data
        ADRL    r0, Palette
        ADD     r0, r0, r2, LSL #2
10
        SUBS    r3, r3, #1
        LDRGE   r4, [r1], #4
        STRGE   r4, [r0], #4
        BGT     %BT10
        ; Register ticker event
        PHPSEI
        LDR     r0, PaletteDirty
        MOV     r1, #1
        STR     r1, PaletteDirty
        PLP
        CMP     r0, #0
        EXIT    NE
        MOV     r0, #1
        ADR     r1, PaletteTicker
        MOV     r2, r12
        SWI     XOS_CallAfter
        ; If call failed, just do it immediately
        BVS     PaletteTicker
        EXIT

PaletteTicker  ROUT
        Entry   "r0-r6"
        Pull "lr"
        PLP
        EXIT

SetBlankState   ROUT
        Entry   "r0-r4"
d491 5
a495 11

VSync_Test      ROUT
        Entry   "r0-r4,r8-r9"
        ; Drop into SVC mode for SWI calls
        MRS     r4, CPSR
        ORR     r0, r4, #SVC32_mode
        MSR     CPSR_c, r0
        Push    "lr"
        ; Clear IRQ in SMI
        Pull    "lr"
        MSR     CPSR_c, r4
d499 1
a499 1
        Entry   "r0-r4,r8-r9"
d501 2
a502 2
        MRS     r4, CPSR
        ORR     r0, r4, #SVC32_mode
d505 13
a517 10
;        ; Clear IRQ in SMI
;        LDR     r0, PeriBase
;        ADD     r0, r0, #SMICS
;        MOV     r1, #0
;        STR     r1, [r0]
;        ; Clear IRQ in controller
;        MOV     r0, #iDev_GPU_SMI
;        MOV     r8, #0
;        MOV     r9, #EntryNo_HAL_IRQClear
;        SWI     XOS_Hardware
d519 1
a519 3
 [  UseGraphV
        MOV     r3, r4
        MOV     r4, #GraphicsV_VSync
d521 2
a523 1
 ]
d525 45
a569 1
        MSR     CPSR_c, r3
a572 4
;; make sure the command matches the resource file below!!
;wimpmodecommand
;        DCB     "wimpmode X1280Y800C16m ",0
;        ALIGN
a581 1
 [  UseGraphV
a582 1
 ]
d584 5
a588 3
 [ SWPointer
        GET     s.SWPointer
 ]
@


1.3
log
@ More work to make Scrmodes EDID functional with ScrModes EDID functionality
Detail:
Admin:
Tested in iMx6

Version 0.13. Tagged as 'IMXVideo-0_13'
@
text
@d153 1
a153 1
        mov     r3, #0
d221 2
d225 5
a229 7
        adrnel  r0, loadmodefilecommand         ; do this if EDID not configured
        swine   XOS_CLI
;        mov     r0, #0
;        mov     r1, #Service_DisplayChanged
;        mov     r2, #0
;        mov     r3, #0
;        swi     XOS_ServiceCall          ; oblige ScrModes to readedid if poss
d359 1
a359 1
        mov     r3, #0
@


1.2
log
@Make aware of ScrModes EDID parsing
Add our own ReadEDID command
Detail:
Admin:

Tested on iMx6


Version 0.12. Tagged as 'IMXVideo-0_12'
@
text
@d75 1
a75 1
EDIDMonitorType     #   1
d152 2
d220 4
a223 3
        ldrb    r0, EDIDMonitorType
        teq     r0, #0
        adrnel  r0, loadmodefilecommand         ;
d225 5
a229 5
;        mov    r0, #0
;        adr    r1,startupmode
;        swi    XOS_ScreenMode
;        adrl   r0,wimpmodecommand
;        swi    XOS_CLI
a280 8
        MOV     r0, #ReadCMOS
        MOV     r1, #MonitorTypeBits
        SWI     XOS_Byte
        MOV     r0, #0
        TSTVC   r2, #1<<16              ; EDID type?
        ADDNE   r0, r0, #1
        STRB    r0, EDIDMonitorType

d334 7
d356 1
d358 2
d361 2
a362 1
        swi     XOS_ServiceCall          ; oblige SceModes to readedid if poss
@


1.1
log
@Initial revision
@
text
@d28 1
d33 2
d74 3
a76 1
                     #   3 ; back to word alignment
d129 1
d133 4
d146 9
d218 4
a221 2
        adrl    r0, loadmodefilecommand         ;
        swi     XOS_CLI
d278 8
d339 6
d351 6
a356 1

d367 3
d376 3
@


1.1.1.1
log
@nitial import
@
text
@@

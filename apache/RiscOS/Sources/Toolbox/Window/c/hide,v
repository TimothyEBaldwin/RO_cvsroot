head	4.8;
access;
symbols
	Window-1_79:4.8
	Window-1_78:4.8
	Window-1_77:4.8
	Window-1_76:4.8
	Window-1_75:4.7
	Window-1_74:4.7
	Window-1_73:4.7
	Window-1_72:4.7
	Window-1_71:4.7
	RO_5_07:4.7
	Window-1_70:4.7
	Window-1_69:4.7
	Window-1_68:4.7
	Window-1_67:4.7
	Window-1_66:4.7
	Window-1_65:4.7
	Window-1_64:4.7
	Window-1_63:4.7
	Window-1_62:4.7
	Window-1_61:4.7
	Window-1_60:4.7
	Window-1_59:4.7
	mstphens_UrsulaRiscPCBuild_20Nov98:4.7
	sbrodie_Toolbox_Ursula_231198:4.7
	Window-1_58:4.7
	Ursula_RiscPC:4.7.0.4
	Window-1_57:4.7
	rthornb_UrsulaBuild-19Aug1998:4.7
	UrsulaBuild_FinalSoftload:4.7
	rthornb_UrsulaBuild-12Aug1998:4.7
	Ursula:4.7.0.2
	Ursula_bp:4.7
	aglover_UrsulaBuild-05Aug1998:4.7
	Window-1_56:4.7
	rthornb_UrsulaBuild-29Jul1998:4.7
	Window-1_55:4.7
	rthornb_UrsulaBuild-22Jul1998:4.7
	rthornb_UrsulaBuild-15Jul1998:4.7
	rthornb_UrsulaBuild-07Jul1998:4.7
	Window-1_54:4.7
	rthornb_UrsulaBuild-17Jun1998:4.7
	Window-1_53:4.7
	Window-1_52:4.7
	Window-1_51:4.6
	rthornb_UrsulaBuild-03Jun1998:4.5
	rthornb_UrsulaBuild-27May1998:4.5
	rthornb_UrsulaBuild-21May1998:4.5
	Ursula_12May1998:4.2.0.4
	rthornb_UrsulaBuild_01May1998:4.2
	sbrodie_Window_1_49:4.5
	afrost_NC2_Generic:4.1.7.2
	sbrodie_Window_1_48:4.4
	Daytona:4.2.0.2
	Daytona_bp:4.2
	sbrodie_Expresso_final_190298:4.3
	sbrodie_Window_1_46:4.3
	sbrodie_Expresso_BETA6_19980204:4.3
	sbrodie_Window_1_44:4.3
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spin_merge_8Jul97:4.1.7.2
	Ursula_bp_8Jul97:4.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Ursula_bp_13Jun97:4.2
	Spin_merge_13Jun97:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Spin_merge_13May97:4.1.7.1
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	pwombwel_Rel_1_36:4.1.7.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2015.08.18.22.05.00;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	oMg9J5QqfRoPENxy;

4.7
date	98.06.11.15.26.48;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	98.06.11.11.53.31;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	98.04.21.16.56.19;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	98.04.21.15.29.32;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.01.15.13.19.20;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.13.09.12.13;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.23.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.23.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.46.18;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.18.21;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.42.00;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.19.18.57.28;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Makefile recreated from fragments
Include paths changed to Unix style.
Debug and non debug CMHG definitions replaced by one which is selected by passing predefines to CMHG.
Removed dummy services.h.
Don't bother calling TinyStubs SWI since in ROM it does nothing, and the RAM versions haven't used it since ~1997.
Use module header constants generated from CMHG rather than hand made one.
Reject out of range SWIs (fixes ticket #305).
Dependencies cleaned from tests.

Version 1.76. Tagged as 'Window-1_76'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Title:   hide.c
 * Purpose: hide a Window Object
 * Author:  IDJ
 * History: 14-Jan-94: IDJ: created
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"

#include "const.h"
#include "macros.h"
#include "debug.h"
#include "mem.h"
#include "string32.h"
#include "messages.h"

#include "objects/toolbox.h"
#include "objects/window.h"
#include "objects/menu.h"

#include "object.h"
#include "task.h"
#include "toolbar.h"
#include "events.h"

#include "hide.h"

static _kernel_oserror *send_hidden_event(WindowInternal *w)
{
       WindowHasBeenHiddenEvent event;

       DEBUG debug_output("hide", "Generating HasBeenHidden (or other) event for %p %08x\n",
       	w, w->wimp_window_handle);

       event.hdr.flags =0;
       event.hdr.event_code = w->hide_event;
       event.hdr.size = sizeof(event);

       return( _swix (Toolbox_RaiseToolboxEvent, _INR(0,3),
                             0,
                             w->id, /* object id of this window */
                             -1,    /* no component id */
                             &event
                     ));
}

_kernel_oserror * _hide_raise_hidden(WindowInternal *w)
{
    if (w->flags & Window_GenerateHasBeenHidden) {
       DEBUG debug_output("hide", "Want to generate HasBeenHidden: balance is %d\n",
       	w->show_balance);

       if (w->show_balance > 0) {
               w->show_balance--;
               return send_hidden_event(w);
       }
       else {
   		wimp_GetWindowState state;

   		state.open.window_handle = w ->wimp_window_handle;
   		wimp_get_window_state (&state);

   		if (!(state.flags & wimp_WINDOWFLAGS_OPEN)) return NULL;
                return send_hidden_event(w);
       }
    }
    return NULL;
}

extern WindowInternal *ShowingAsMenu;

static void hide_flush_pending_events(int min)
{
   TaskDescriptor *t;

   DEBUG debug_output("hide", "Searching pending hide list\n");
   for (t = task_get_head(); t; t=t->next) {
      WindowInternal *w;
      for (w = t->object_list; w; w = w->next) {
         if (w->show_balance > min) {
           _kernel_oserror *e;
	   DEBUG debug_output("hide", "Issuing pending hidden event (show_bal=%d)\n",
	     w->show_balance);
           e = _hide_raise_hidden(w);
           if (e) { DEBUG debug_output("hide", "hide error: %s\n", e->errmess); }
         }
      }
   }
   DEBUG debug_output("hide", "End search of pending hide list\n");
}

/* This function is called is a Message_MenusDeleted is ever received.
 */
void hide_raise_hidden(int object)
{
   if (ShowingAsMenu) {
           if (task_find_from_window(ShowingAsMenu) != NULL) {
	           if (ShowingAsMenu->wimp_window_handle == object) {
		           _kernel_oserror *e;
	        	   DEBUG debug_output("hide", "calling _hide_raise_hidden\n");
		           e = _hide_raise_hidden(ShowingAsMenu);
		           if (e) { DEBUG debug_output("hide", "hide error: %s\n", e->errmess); }
		           ShowingAsMenu = NULL;
        	   }
           }
           else {
                   DEBUG debug_output("force", "SHOWINGASMENU WAS INVALID!!!!!!!!\n");
                   ShowingAsMenu = NULL;
           }
   }
   hide_flush_pending_events(0);
}

void raise_if_become_hidden(void)
{
        hide_flush_pending_events(0);
}

extern _kernel_oserror *hide_submenu_autohide (_kernel_swi_regs *r)
{
    /*
     * pre-warning of a sub-menu show being issued
     * R0 = flags
     */

    /* This function is invoked as a result of a Window_PreSubMenuShow SWI call
     * being issued by the Toolbox during its Toolbox_ShowObject code before
     * the class SWI is issued.
     */

        if (ShowingAsMenu) {
          _swix(Toolbox_HideObject, _INR(0,1), 0, ShowingAsMenu->id);
          hide_raise_hidden(ShowingAsMenu->wimp_window_handle);
        }
	r->r[0] = 0;
	return NULL;
}

extern _kernel_oserror *hide_object (_kernel_swi_regs *r, TaskDescriptor *t)
{

    /*
     * request to hide an object
     * R0 = 4
     * R1 = Object ID
     * R2 = internal handle returned when Object was created
     * R3 = wimp task handle of caller (use to identify task descriptor)
     * R4 -> user regs R0-R9
     *      R0 =  flags
     *      R1 =  Object ID
     *
     */

    /*
     * Remove the object from view.  For efficiency, we should stop expressing
     * interest in any events which can't happen whilst the Object is
     * hidden.
     *
     */

    /*
     * A Window has been shown using Wimp_OpenWindow, or Wimp_CreateMenu or Wimp_CreateSubMenu.
     * This is remembered in the window's state field.  If it was shown as a top-level menu
     * then we must close the menu tree, else we use Wimp_CloseWindow.  In any case as a
     * sanity check we first see whether the window is open!
     */

    wimp_GetWindowState  state;
    WindowInternal      *window = (WindowInternal *)r->r[2];
    _kernel_oserror     *e      = NULL;
    wimp_PointerInfo  info;

    t=t;

    state.open.window_handle = window->wimp_window_handle;

    if ((e = wimp_get_window_state(&state)) != NULL) return e;

    /* This conditional is part of the fix for PAN-01317 */
    if ((window->state & WindowInternalFlags_PreventHideDelete) == 0) {
        if (state.flags & wimp_WINDOWFLAGS_OPEN)
        {
            wimp_get_pointer_info(&info);
            if (window->wimp_window_handle == info.window_handle)
                events_pointer_leaving_window(window);

            if (window->state & (Toolbox_ShowObject_AsMenu | Toolbox_ShowObject_AsSubMenu))
            {
                e = wimp_create_menu(CloseMenu,0,0);
                window->state &= ~(Toolbox_ShowObject_AsMenu | Toolbox_ShowObject_AsSubMenu);
            }
            else
            {
                /* reuse state block cos it contains window handle */
                e = wimp_close_window (&state.open.window_handle);
                if (!e) close_panes(window);
            }

            if (window->flags & Window_GenerateHasBeenHidden) {
              if (window->show_balance <= 0) window->show_balance = 1;
              _hide_raise_hidden(window);
              if(ShowingAsMenu == window) ShowingAsMenu = NULL;
            }
        }
        hide_flush_pending_events(0);
    }
    if (window->flags & Window_IsToolBar) {
        _kernel_swi_regs regs;
        regs.r[3] = (int) window->id;
        remove_pane(window->parent,&regs);
    }
    return e;
}
@


4.7
log
@I missed one call to _hide_raise_hidden which resulted in problems with
non-transient windows, which strangely decided to hang on until 1.51 was
committed before revealing themselves.  These are now fixed.

Version 1.52. Tagged as 'Window-1_52'
@
text
@a29 1
#include "services.h"
d35 3
a37 3
#include "objects.toolbox.h"
#include "objects.window.h"
#include "objects.menu.h"
@


4.6
log
@Event ordering for transient submenu objects fixed (SNB-U002).
Module now uses srccommit to maintain its version number

Version 1.51. Tagged as 'Window-1_51'
@
text
@d47 1
a47 1
_kernel_oserror * _hide_raise_hidden(WindowInternal *w)
a48 1
    if (w->flags & Window_GenerateHasBeenHidden) {
d51 3
a57 7
       DEBUG debug_output("hide", "Generating HasBeenHidden (or other) event for %p %08x\n",
       	w, w->wimp_window_handle);
       DEBUG debug_output("hide", "Want to generate HasBeenHidden: balance is %d\n",
       	w->show_balance);

       if (w->show_balance > 0) w->show_balance--; else return NULL;

d64 21
a135 12
        #if 0
   wimp_GetWindowState state;

   if (!ShowingAsMenu) return;
   state.open.window_handle = ShowingAsMenu ->wimp_window_handle;
   wimp_get_window_state (&state);

   if (state.flags & wimp_WINDOWFLAGS_OPEN) return;

   _hide_raise_hidden(ShowingAsMenu);
   ShowingAsMenu = NULL;
        #endif
d205 1
d217 1
d219 1
@


4.5
log
@Second new version for the day - sorry - a second bug thought to lie
elsewhere turned out to be in the Window module too.  Also related to
transient Window objects, this fix stops random pointer dereferencing
when a message_MENUS_DELETED is generated by the Wimp and Window
doesn't know about the window object in its ShowingAsMenu global.
@
text
@d38 1
a55 1
       if (w->show_balance > 0) w->show_balance--;
d58 4
d75 20
a98 2
   TaskDescriptor *t;

d114 1
a114 13

   DEBUG debug_output("hide", "Searching pending hide list\n");
   for (t = task_get_head(); t; t=t->next) {
      WindowInternal *w;
      for (w = t->object_list; w; w = w->next) {
         if (w->show_balance > 0) {
           _kernel_oserror *e;
	   DEBUG debug_output("hide", "Issuing pending hidden event\n");
           e = _hide_raise_hidden(w);
           if (e) { DEBUG debug_output("hide", "hide error: %s\n", e->errmess); }
         }
      }
   }
d119 2
d131 1
d134 19
a215 1

d217 1
@


4.4
log
@Window 1.48

WindowHasBeenHidden events are now generated consistently for
transiently shown windows. Instead of relying upon a single static
variable indicating which, if any, window is showing transiently, a
shown/hidden counter is kept and pending HasBeenHidden events are
flushed when message_MENUS_CLOSED arrives.  This solves the problems
observed with several Toolbox applications which variously did not
appear to get a HasBeenHidden event for a closed transient or got
duplicate messages (which confused applications wishing to show a
shared window object transiently, wait for it to close, and then open
it again (eg. a dbox asking the user to make a choice).
@
text
@d78 12
a89 4
           if (ShowingAsMenu->wimp_window_handle == object) {
	           _kernel_oserror *e = _hide_raise_hidden(ShowingAsMenu);
	           if (e) { DEBUG debug_output("hide", "hide error: %s\n", e->errmess); }
	           ShowingAsMenu = NULL;
d93 1
@


4.3
log
@PAN-01317 fixed: Wimp dying when Window deletes transiently shown objects
@
text
@d55 4
d71 3
a73 1
void hide_raise_hidden(void)
d75 21
a95 2
   if (ShowingAsMenu) _hide_raise_hidden(ShowingAsMenu);
   ShowingAsMenu = NULL;
d175 1
a175 1
    
@


4.2
log
@Spinner branch merged
@
text
@d128 3
a130 6
    if (state.flags & wimp_WINDOWFLAGS_OPEN)
    {
        wimp_get_pointer_info(&info);
        if (window->wimp_window_handle == info.window_handle)
            events_pointer_leaving_window(window);
        if (window->state & (Toolbox_ShowObject_AsMenu | Toolbox_ShowObject_AsSubMenu))
d132 19
a150 2
            e = wimp_create_menu(CloseMenu,0,0);
            window->state &= ~(Toolbox_ShowObject_AsMenu | Toolbox_ShowObject_AsSubMenu);
a151 11
        else
        {
            /* reuse state block cos it contains window handle */
            e = wimp_close_window (&state.open.window_handle);
            if (!e) close_panes(window);
        }
        if (window->flags & Window_GenerateHasBeenHidden) {
          _hide_raise_hidden(window);
          if(ShowingAsMenu == window) ShowingAsMenu = NULL;
        }

@


4.1
log
@Initial revision
@
text
@d48 2
a49 1
   _kernel_swi_regs regs;
a50 3
    WindowHasBeenHiddenEvent event;
                   
    if (w->flags & Window_GenerateHasBeenHidden) {
d55 6
a60 6
       regs.r[0] = 0;
       regs.r[1] = (int)w->id;  /* object id of this window */
       regs.r[2] = -1;              /* no component id */
       regs.r[3] = (int)&event;

       return( _kernel_swi (Toolbox_RaiseToolboxEvent, &regs, &regs));
d63 1
a63 1
}                    
d74 1
a74 1
{            
d77 1
a77 1
   if (!ShowingAsMenu) return;        
d91 1
a91 1
    /* 
d131 1
a131 1
        if (window->wimp_window_handle == info.window_handle) 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Add "Extendable X and Extendable Y" toolbars.
Improve pane-handling algorithms.
Fix alignment of labels in labelled boxes.
Align numberrange's slider more neatly and put adjusters in right place
Stringsets tidied up
Some useful checking added to string_set_toolbox_event
Showing as subwindow fixed up a lot.
@
text
@d48 4
a52 2
       WindowHasBeenHiddenEvent event;

d57 6
a62 6
       return( _swix (Toolbox_RaiseToolboxEvent, _INR(0,3),
                             0,
                             w->id, /* object id of this window */
                             -1,    /* no component id */
                             &event
                     ));
d65 1
a65 1
}
d76 1
a76 1
{
d79 1
a79 1
   if (!ShowingAsMenu) return;
d93 1
a93 1
    /*
d133 1
a133 1
        if (window->wimp_window_handle == info.window_handle)
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

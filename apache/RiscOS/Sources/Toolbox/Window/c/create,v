head	4.5;
access;
symbols
	Window-1_79:4.5
	Window-1_78:4.5
	Window-1_77:4.5
	Window-1_76:4.5
	Window-1_75:4.4
	Window-1_74:4.4
	Window-1_73:4.4
	Window-1_72:4.4
	Window-1_71:4.4
	RO_5_07:4.4
	Window-1_70:4.4
	Window-1_69:4.4
	Window-1_68:4.4
	Window-1_67:4.4
	Window-1_66:4.4
	Window-1_65:4.4
	Window-1_64:4.4
	Window-1_63:4.4
	Window-1_62:4.4
	Window-1_61:4.4
	Window-1_60:4.4
	Window-1_59:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.4
	sbrodie_Toolbox_Ursula_231198:4.4
	Window-1_58:4.4
	Ursula_RiscPC:4.4.0.4
	Window-1_57:4.4
	rthornb_UrsulaBuild-19Aug1998:4.4
	UrsulaBuild_FinalSoftload:4.4
	rthornb_UrsulaBuild-12Aug1998:4.4
	Ursula:4.4.0.2
	Ursula_bp:4.4
	aglover_UrsulaBuild-05Aug1998:4.4
	Window-1_56:4.4
	rthornb_UrsulaBuild-29Jul1998:4.4
	Window-1_55:4.4
	rthornb_UrsulaBuild-22Jul1998:4.4
	rthornb_UrsulaBuild-15Jul1998:4.4
	rthornb_UrsulaBuild-07Jul1998:4.4
	Window-1_54:4.4
	rthornb_UrsulaBuild-17Jun1998:4.4
	Window-1_53:4.4
	Window-1_52:4.4
	Window-1_51:4.4
	rthornb_UrsulaBuild-03Jun1998:4.4
	rthornb_UrsulaBuild-27May1998:4.4
	rthornb_UrsulaBuild-21May1998:4.4
	Ursula_12May1998:4.3.0.4
	rthornb_UrsulaBuild_01May1998:4.3
	sbrodie_Window_1_49:4.4
	afrost_NC2_Generic:4.1.7.4
	sbrodie_Window_1_48:4.4
	Daytona:4.3.0.2
	Daytona_bp:4.3
	sbrodie_Expresso_final_190298:4.3
	sbrodie_Window_1_46:4.3
	sbrodie_Expresso_BETA6_19980204:4.3
	sbrodie_Window_1_44:4.3
	Spinner_RCA116:4.1.7.4
	Spinner_B20_2:4.1.7.4
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.4
	Spinner_B17:4.1.7.4
	Spin_merge_8Jul97:4.1.7.4
	Ursula_bp_8Jul97:4.3
	Spinner_B15:4.1.7.4
	Spinner_B14:4.1.7.4
	Spinner_B13:4.1.7.3
	Ursula_bp_13Jun97:4.2
	Spin_merge_13Jun97:4.1.7.3
	Spinner_B12:4.1.7.3
	Spinner_B10:4.1.7.3
	Spin_merge_13May97:4.1.7.1
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.3
	RCA_bp:4.1
	pwombwel_Rel_1_36:4.1.7.3
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.4
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2015.08.18.22.05.00;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	oMg9J5QqfRoPENxy;

4.4
date	98.04.21.15.29.30;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	97.06.13.11.16.51;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.13.09.12.08;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.23.15;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.06.13.11.27.42;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.23.15;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.46.11;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.18.14;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.41.53;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.02.04.17.22.41;	author pwombwel;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.03.19.18.57.23;	author kbracey;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.06.05.17.21.51;	author pwombwel;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Makefile recreated from fragments
Include paths changed to Unix style.
Debug and non debug CMHG definitions replaced by one which is selected by passing predefines to CMHG.
Removed dummy services.h.
Don't bother calling TinyStubs SWI since in ROM it does nothing, and the RAM versions haven't used it since ~1997.
Use module header constants generated from CMHG rather than hand made one.
Reject out of range SWIs (fixes ticket #305).
Dependencies cleaned from tests.

Version 1.76. Tagged as 'Window-1_76'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Title:   create.c
 * Purpose: create a Window Object
 * Author:  IDJ
 * History: 14-Jan-94: IDJ: created
 *          05-Jun-97:  PW: Fixed bug where SetTitle crashes with a window
 *                          without a titlebar.
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "const.h"
#include "macros.h"
#include "debug.h"
#include "mem.h"
#include "string32.h"
#include "messages.h"

#include "objects/toolbox.h"
#include "objects/window.h"

#include "object.h"
#include "task.h"
#include "gadgets.h"
#include "toolbar.h"

#include "create.h"
#include "utils.h"


static Gadget *next_gadget_template (Gadget *gt)
{
    /*
     * Move on to the next gadget template in a list.
     */

    static int sizes [MAX_GADGET_CODE+1] = {sizeof(ActionButton),
                                            sizeof(OptionButton),
                                            sizeof(LabelledBox),
                                            sizeof(Label),
                                            sizeof(RadioButton),
                                            sizeof(DisplayField),
                                            sizeof(WritableField),
                                            sizeof(Slider),
                                            sizeof(Draggable),
                                            sizeof(PopUp),
                                            sizeof(Adjuster),
                                            sizeof(NumberRange),
                                            sizeof(StringSet),
                                            sizeof(Button)
                                           };

    if (gt->hdr.type & 0x7fff0000) return (Gadget *)((char *)gt + (gt->hdr.type >>16));
    return (Gadget *)((char *)gt + sizeof(GadgetHeader) + sizes[(gt->hdr.type - Gadget_Max) / 64]);
}

extern _kernel_oserror *create_extractgadget (_kernel_swi_regs *r)
{
    WindowTemplate       *window_template     = (WindowTemplate *)(((ObjectTemplateHeader *)r->r[1])->body);
    int num;
    Gadget *g = window_template->gadgets,*n;

    DEBUG debug_output ("extract", "Found %d gadgets at %d\n\r",window_template->num_gadgets,g );

    for (num=0; num < (window_template->num_gadgets); num ++) {

    DEBUG debug_output ("extract", "Found gadget with CID %d\n\r", g->hdr.component_id);

       n=next_gadget_template(g);
       if (g->hdr.component_id == r->r[2]) {

          r->r[0]= (int) g;
          r->r[1]= (int) ((char *) n - (char *)g);
          DEBUG debug_output ("extract", "Found gadget we were looking for at %d, size %d\n\r", r->r[0],r->r[1]);

          return NULL;
       }
       g=n;
    }
    /* didn't find requested component */

    return invalid_component ((ComponentID) r->r[2]);

}

/* #pragma -s0 */

extern _kernel_oserror *create_object (_kernel_swi_regs *r, TaskDescriptor *t)
{

    /*
     * request to create an object
     * R0 = 0
     * R1 = Object ID
     * R2 = 0  (will be internal handle for other SWIs
     * R3 = wimp task handle of caller (use to identify task descriptor)
     * R4 -> user regs R0-R9
     *      R0 = flags
     *           bit 0 set => create from memory
     *      R1 -> description block
     */

    /*
     * The Toolbox has already checked that this is not just a create
     * call for a shared Object which already exists.
     * We create a new Object, and add it to the list of Objects for this
     * task.
     * We need to remember the ObjectID passed to us by the Toolbox, so
     * that we can identify this Object if we are given an ID from the
     * client's "id block".
     * Note that if any template names are held in the Object, then we
     * create an Object from that template, and store its ID.
     * Note also that the Toolbox has changed the client's R1 to point
     * at an in-core template, if it wasn't already!
     */

    /*
     * For a Window Object, we need to set up a wimp window definition
     * and call Wimp_CreateWindow.  We then go down the list of
     * Gadgets, and create suitable collections of icons using Wimp_CreateIcon.
     *
     * Any attached menu is created, and we store its object id
     *
     */

    _kernel_swi_regs     *user_regs           = USER_REGS(r);
    WindowTemplate       *window_template     = (WindowTemplate *)(((ObjectTemplateHeader *)user_regs->r[1])->body);
    _kernel_oserror      *e;
    WindowInternal       *new_window;
    int                   window_size;
    char                 *indirected_data;
    int                   gi,pass;
    Gadget               *gt;                /* gadget templates */
#ifdef SUPPORT_101
    WindowTemplate        temp;
#endif
    int k;


    DEBUG debug_output ("create", "Create window object -- ID %x, task %x, flags %x\n", r->r[1], r->r[3], user_regs->r[0]);


#ifdef SUPPORT_101
    if ( ((ObjectTemplateHeader *)user_regs->r[1])-> version == 101) {

        /* old template does not have show/hide events or toolbars*/
        WindowTemplate101 *old = (WindowTemplate101*) window_template;

        memcpy(&temp,old,sizeof(WindowTemplate101) - sizeof(wimp_Window));
        memcpy(&(temp.window),&(old->window),sizeof(wimp_Window));

        temp.hide_event = 0;
        temp.show_event = 0;

        temp.toolbar_ibl = 0;
        temp.toolbar_ebl = 0;
        temp.toolbar_itl = 0;
        temp.toolbar_etl = 0;

        window_template = &temp;
    } else
      /* note that if enabled, the next if becomes an else-if */
#endif
       if ( ((ObjectTemplateHeader *)user_regs->r[1])-> version != 102) {
        char buf [16];
        sprintf(buf,"%d",((ObjectTemplateHeader *)user_regs->r[1]) -> version);
        return make_error (Window_BadVersion, 1, buf );
    }

    /*
     * create new WindowInternal structure and initialise
     * NOTE: indirected strings are held "after" the main structure in memory (see object.h)
     */

    DEBUG debug_output ("create", "window template is at %p\n\r", window_template);

    window_size = sizeof (WindowInternal) +                                                   /* the window structure */
                  window_template->max_help +                                                 /* buffer for int. help msg */
                  window_template->max_pointer_shape +                                        /* buffer for pointer sprite name */
                  window_template->window.title.indirect_text.buff_len +                      /* buffer for title bar string */
                  string_length (window_template->window.title.indirect_text.valid_string)+1; /* validation string */


    DEBUG debug_output ("create", "Window size is %d\n", window_size);

    if ((new_window = mem_allocate (window_size, "window object")) == NULL)
        return out_of_memory ();


    indirected_data = (char *)(new_window+1);   /* yuk */

    /*
     * copy template as it is, then fix up fields.
     */

    memcpy (&new_window->window, &window_template->window, sizeof(wimp_Window));

    new_window->id                 = (ObjectID)r->r[1];
    new_window->flags              = window_template->flags;

#if 0
    /* mem_allocate uses calloc */
    new_window->keyboard_shortcuts = NULL; /* so we know whether to delete them after error or not */
    new_window->state              = 0;
    new_window->panes              = NULL;
    new_window->num_gadgets        = 0;      /* gets incremented by gadgets_add() */
    new_window->gadgets            = NULL;
    new_window->icon_mappings      = NULL;
#endif

    new_window->show_balance       = 0;

    /*
     * copy help message string
     */

    if (window_template->max_help != 0)
    {
        DEBUG debug_output ("create", "Storing help message %s\n", window_template->help_message);
        new_window->max_help     = window_template->max_help;
        new_window->help_message = indirected_data;
        string_copy (new_window->help_message, window_template->help_message);
    }
    else
    {
        new_window->help_message = NULL;
        new_window->max_help = 0;
    }


    /*
     * copy pointer sprite name
     */

    if (window_template->max_pointer_shape != 0)
    {
        DEBUG debug_output ("create", "Storing pointer shape %s\n", window_template->pointer_shape);

        new_window->pointer_shape     = indirected_data + window_template->max_help;
        new_window->max_pointer_shape = window_template->max_pointer_shape;
        new_window->pointer_x_hot     = window_template->pointer_x_hot;
        new_window->pointer_y_hot     = window_template->pointer_y_hot;
        string_copy (new_window->pointer_shape, window_template->pointer_shape);
    }
    else
    {
        new_window->max_pointer_shape = 0;
        new_window->pointer_shape = NULL;
    }

     /* set up events */

    if ((new_window->hide_event = window_template->hide_event) == 0)
        new_window->hide_event = Window_HasBeenHidden;
    if ((new_window->show_event = window_template->show_event) == 0)
        new_window->show_event = Window_AboutToBeShown;

    /*
     * copy title string, and its validation string
     */

//    if (window_template->window.title.indirect_text.buffer != NULL)
    if (window_template->window.title.indirect_text.buff_len != 0)
    {

        DEBUG debug_output ("create", "title is %s, size %d\n", window_template->window.title.indirect_text.buffer,
                        window_template->window.title.indirect_text.buff_len);

        new_window->window.title.indirect_text.buffer = indirected_data + window_template->max_help + window_template->max_pointer_shape;
        new_window->window.title.indirect_text.valid_string = indirected_data +
                                                              window_template->max_help +
                                                              window_template->max_pointer_shape +
                                                              window_template->window.title.indirect_text.buff_len;
        string_copy_chk (new_window->window.title.indirect_text.buffer, window_template->window.title.indirect_text.buffer
                ,window_template->window.title.indirect_text.buff_len);

        DEBUG debug_output ("create", "Storing title %s\n", new_window->window.title.indirect_text.buffer);

        if (window_template->window.title.indirect_text.valid_string != NULL)
            string_copy (new_window->window.title.indirect_text.valid_string,
                         window_template->window.title.indirect_text.valid_string);
        else new_window->window.title.indirect_text.valid_string = "";

        DEBUG debug_output ("create", "Storing validation %s\n", new_window->window.title.indirect_text.valid_string);

    }
    else
    {
        new_window->window.title.indirect_text.valid_string = NULL;
        new_window->window.title.indirect_text.buff_len = 0;
    }


    /*
     * create a real wimp window and store its handle (no icons for the moment)
     *
     */

    if ((e = wimp_create_window(&new_window->window, &new_window->wimp_window_handle)) != NULL)
        goto error;

    /* work out window furniture dimensions so that toolbars can
       be correctly positioned - in a block to reduce stack usage */

    {
        wimp_GetWindowOutline furn;
        wimp_OpenWindow       show;

        show.behind = -3;
        show.window_handle = new_window->wimp_window_handle;
        memcpy(&show.visible_area,&new_window->window.box,24) ;
        furn.window_handle = new_window->wimp_window_handle;

        wimp_open_window(&show);
        wimp_get_window_outline( &furn);
        wimp_close_window(&(show.window_handle));

        /* only require size of bottom & left window furniture for this release */

        new_window->fb = show.visible_area.ymin - furn.box.ymin;
        new_window->fl = show.visible_area.xmin - furn.box.xmin;
    }

    /*
     * create any attached menu
     */

    if (window_template->menu != NULL)
    {
        DEBUG debug_output ("create", "Making attached menu %s\n", window_template->menu);

        if ((e = _swix (Toolbox_CreateObject, _INR(0,1)|_OUT(0),
                              0,
                              window_template->menu,
                              &new_window->menu
                       )) != NULL)
            goto error;
    }

    /*
     * create any toolbars
     */


    for (k=0; k<4;k++)
    {
        static int types[] = { pane_CLIPBOUNCE|pane_INTERNAL|pane_BOTRIGHT,
                               pane_CLIPBOUNCE|pane_INTERNAL|pane_TOPLEFT,
                               pane_CLIPBOUNCE|pane_EXTERNAL|pane_BOTRIGHT,
                               pane_CLIPBOUNCE|pane_EXTERNAL|pane_TOPLEFT};
        _kernel_swi_regs r;

        if (*(&(window_template->toolbar_ibl)+k)) {
           DEBUG debug_output ("create", "Making attached toolbar %s\n", &(window_template->toolbar_ibl)+k);

           if ((e = _swix (Toolbox_CreateObject, _INR(0,1)|_OUT(0),
                             0,
                             *(&(window_template->toolbar_ibl)+k),
                             &(new_window->ibl)+k
                          )) != NULL) {
               *(&(new_window->ibl)+k) = NULL;
               goto error;
           }

           r.r[3] = *(&(new_window->ibl)+k);
           r.r[4] = types[k];
           r.r[5] = 0;
           r.r[6] = 0;
           set_pane(new_window,&r);
        }
    }

    /*
     * take copy of keyboard shortcuts (creating any objects which are to be shown on a
     * key click).
     */

    if (window_template->num_keyboard_shortcuts > 0 && window_template->keyboard_shortcuts != NULL)
    {
        int num_shorts = window_template->num_keyboard_shortcuts;

        if ((new_window->keyboard_shortcuts = mem_allocate (num_shorts*sizeof(KeyBoardShortcutInternal), "window keybd shorts")) == NULL)
        {
            e = out_of_memory ();
            goto error;
        }

        new_window->num_keyboard_shortcuts = num_shorts;

        for (k = 0; k < num_shorts; k++)
        {
            new_window->keyboard_shortcuts[k].flags         = window_template->keyboard_shortcuts[k].flags;
            new_window->keyboard_shortcuts[k].wimp_key_code = window_template->keyboard_shortcuts[k].wimp_key_code;
            new_window->keyboard_shortcuts[k].key_event     = window_template->keyboard_shortcuts[k].key_event;

            /*
             * if object is attached to shortcut, then create it
             */

            if (window_template->keyboard_shortcuts[k].key_show != NULL)
            {
                DEBUG debug_output ("create", "Making attached kb object %s\n", window_template->keyboard_shortcuts[k].key_show);

                if ((e = _swix(Toolbox_CreateObject, _INR(0,1)|_OUT(0),
                                0,
                                window_template->keyboard_shortcuts[k].key_show,
                                &new_window->keyboard_shortcuts[k].key_show
                              )) != NULL)
                    goto error;
            }
        }
    }


    /*
     * create gadgets, from gadget templates.
     */


    for (pass = 0; pass< 2; pass++) {
    gt = window_template->gadgets;

       for (gi = 0; gi < window_template->num_gadgets; gi++)
       {
           ComponentID dummy;

           if (((pass ==0 ) && (gt->hdr.flags & Gadget_AtBack)) ||
                ((pass ==1) && (!(gt->hdr.flags & Gadget_AtBack)))) {
              if ((e = gadgets_add (gt, new_window, &dummy)) != NULL)
                  goto error;
           }

           gt = next_gadget_template(gt);
       }
    }

    new_window->default_focus = window_template->default_focus;

    /*
     * ... and add to list for this task
     */

    new_window->next = t->object_list;
    new_window->prev = NULL;
    if (t->object_list != NULL)
        t->object_list->prev = new_window;
    t->object_list = new_window;


    /*
     * We return internal handle in Toolbox's R0
     */

    r->r[0] = (int)new_window;


    return NULL;


error:

    if (new_window->menu != 0)
    {
        _swix (Toolbox_DeleteObject, _INR(0,1), 0, new_window->menu);
    }

    if ((new_window->num_keyboard_shortcuts > 0) && (new_window->keyboard_shortcuts != NULL))
    {
        int k;

        for (k = 0; k < new_window->num_keyboard_shortcuts; k++)
        {
            /*
             * if object is attached to shortcut, then delete it
             */

            if (new_window->keyboard_shortcuts[k].key_show != NULL)
            {
                _swix (Toolbox_DeleteObject, _INR(0,1),
                                0,
                                new_window->keyboard_shortcuts[k].key_show);
            }
        }

        mem_free (new_window->keyboard_shortcuts, "window create error - kbshorts");
    }

    gadgets_remove_all (new_window,0);

    if (new_window->icon_mappings != NULL)
        mem_free (new_window->icon_mappings, "window create error (icon mappings)");

    mem_free (new_window, "window create error");

    return e;
}

/* #pragma -s1 */

void create_extras(Gadget *g, WindowInternal *win)
{
    Button *data = (Button *) &(g->data);
    char name[13];
    _kernel_swi_regs regs;
    int dummy;

    if (!strncmp(data->value,"pane ",5)) {
        extern int SWI_WimpCreateIcon;
        if (SWI_WimpCreateIcon == Wimp_PlotIcon) return ;

        sscanf(data->value+5,"%s %d %d %d",&name,&(regs.r[4]),&(regs.r[5]),&(regs.r[6]));
        if (CreateObjectFromTemplate(name,&(regs.r[3]))) return;
        set_pane(win,&regs);
    }
    if (!strncmp(data->value,"gadget ",7)) {
        Gadget gad = *g;
        sscanf(data->value+7," %x %x",&(gad.hdr.type),&(gad.hdr.flags));
        gadgets_add(&gad,win,&dummy);
    }
}
@


4.4
log
@Window 1.48

WindowHasBeenHidden events are now generated consistently for
transiently shown windows. Instead of relying upon a single static
variable indicating which, if any, window is showing transiently, a
shown/hidden counter is kept and pending HasBeenHidden events are
flushed when message_MENUS_CLOSED arrives.  This solves the problems
observed with several Toolbox applications which variously did not
appear to get a HasBeenHidden event for a closed transient or got
duplicate messages (which confused applications wishing to show a
shared window object transiently, wait for it to close, and then open
it again (eg. a dbox asking the user to make a choice).
@
text
@a32 1
#include "services.h"
d38 2
a39 2
#include "objects.toolbox.h"
#include "objects.window.h"
@


4.3
log
@Spinner branch merged
@
text
@d231 2
@


4.2
log
@Spinner branch merged
@
text
@d19 2
d280 2
a281 1
    if (window_template->window.title.indirect_text.buffer != NULL)
d304 5
@


4.2.2.1
log
@Fix for SetTitle crashing if no title bar incorporated from Spinner
@
text
@a18 2
 *          05-Jun-97:  PW: Fixed bug where SetTitle crashes with a window
 *                          without a titlebar.
d278 1
a278 2
//    if (window_template->window.title.indirect_text.buffer != NULL)
    if (window_template->window.title.indirect_text.buff_len != 0)
a300 5
    }
    else
    {
        new_window->window.title.indirect_text.valid_string = NULL;
        new_window->window.title.indirect_text.buff_len = 0;
@


4.1
log
@Initial revision
@
text
@d43 1
d109 1
a109 1
    /* 
d139 1
a139 1
     * 
a146 1
    _kernel_swi_regs      regs;
d160 1
a160 1
      
d163 1
a163 1
                                                                  
d179 2
a180 2
    } else 
      /* note that if enabled, the next if becomes an else-if */ 
d194 1
a194 1
    
d201 1
a201 1
                                                  
d209 1
a209 1
   
d216 1
a216 1
    new_window->id                 = (ObjectID)r->r[1];   
d218 1
a218 1
                                                                   
d233 1
a233 1
    if (window_template->help_message != NULL)
d240 5
d251 1
a251 1
    if (window_template->pointer_shape != NULL)
d261 5
d285 2
a286 2
        new_window->window.title.indirect_text.valid_string = indirected_data + 
                                                              window_template->max_help + 
d295 1
a295 1
            string_copy (new_window->window.title.indirect_text.valid_string, 
d305 1
a305 1
     * create a real wimp window and store its handle (no icons for the moment) 
d311 1
a311 1
                               
d327 1
a327 1
                                                                              
d334 1
a334 1
    /* 
d342 5
a346 3
        regs.r[0] = 0;
        regs.r[1] = (int)window_template->menu;
        if ((e = _kernel_swi (Toolbox_CreateObject, &regs, &regs)) != NULL)
a347 2

        new_window->menu = (ObjectID)regs.r[0];
d351 1
a351 1
     * create any toolbars 
d356 5
a360 2
    {                              
        static int types[] = {17,19,16,18};
d362 1
a362 1
                              
d366 5
a370 3
           regs.r[0] = 0;
           regs.r[1] = (int) *(&(window_template->toolbar_ibl)+k);
           if ((e = _kernel_swi (Toolbox_CreateObject, &regs, &regs)) != NULL) {
d372 1
a372 1
               goto error;                    
d374 2
a375 2
                      
           r.r[3] = regs.r[0];
d379 1
a379 2
           *(&(new_window->ibl)+k) = (ObjectID)regs.r[0];
           set_pane(new_window,&r);                
d383 2
a384 2
    /* 
     * take copy of keyboard shortcuts (creating any objects which are to be shown on a 
d391 1
a391 1
        
d396 1
a396 1
        }                                               
d404 1
a404 1
            new_window->keyboard_shortcuts[k].key_event     = window_template->keyboard_shortcuts[k].key_event; 
d414 5
a418 3
                regs.r[0] = 0;
                regs.r[1] = (int)window_template->keyboard_shortcuts[k].key_show;
                if ((e = _kernel_swi (Toolbox_CreateObject, &regs, &regs)) != NULL)
a419 2

                new_window->keyboard_shortcuts[k].key_show = (ObjectID)regs.r[0];
d437 1
a437 1
           if (((pass ==0 ) && (gt->hdr.flags & Gadget_AtBack)) || 
d450 1
a450 1
     * ... and add to list for this task 
d466 1
a466 1
  
d474 1
a474 3
        regs.r[0] = 0;
        regs.r[1] = (int)new_window->menu;
        _kernel_swi (Toolbox_DeleteObject, &regs, &regs);
d489 3
a491 3
                regs.r[0] = 0;
                regs.r[1] = (int)new_window->keyboard_shortcuts[k].key_show;
                _kernel_swi (Toolbox_DeleteObject, &regs, &regs);
d507 1
a507 1
           
d514 1
a514 1
    _kernel_swi_regs regs;          
d516 1
a516 1
    
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Added support for nested windows and showtypes 2 and 3 - centred and at pointer
@
text
@d233 1
a233 1
    if (window_template->max_help != 0)
a239 5
    else
    {
        new_window->help_message = NULL;
        new_window->max_help = 0;
    }
d246 1
a246 1
    if (window_template->max_pointer_shape != 0)
a254 5
    }
    else
    {
        new_window->max_pointer_shape = 0;
        new_window->pointer_shape = NULL;
@


4.1.7.3
log
@Add "Extendable X and Extendable Y" toolbars.
Improve pane-handling algorithms.
Fix alignment of labels in labelled boxes.
Align numberrange's slider more neatly and put adjusters in right place
Stringsets tidied up
Some useful checking added to string_set_toolbox_event
Showing as subwindow fixed up a lot.
@
text
@a42 1
#include "toolbar.h"
d108 1
a108 1
    /*
d138 1
a138 1
     *
d146 1
d160 1
a160 1

d163 1
a163 1

d179 2
a180 2
    } else
      /* note that if enabled, the next if becomes an else-if */
d194 1
a194 1

d201 1
a201 1

d209 1
a209 1

d216 1
a216 1
    new_window->id                 = (ObjectID)r->r[1];
d218 1
a218 1

d285 2
a286 2
        new_window->window.title.indirect_text.valid_string = indirected_data +
                                                              window_template->max_help +
d295 1
a295 1
            string_copy (new_window->window.title.indirect_text.valid_string,
d305 1
a305 1
     * create a real wimp window and store its handle (no icons for the moment)
d311 1
a311 1

d327 1
a327 1

d334 1
a334 1
    /*
d342 3
a344 5
        if ((e = _swix (Toolbox_CreateObject, _INR(0,1)|_OUT(0),
                              0,
                              window_template->menu,
                              &new_window->menu
                       )) != NULL)
d346 2
d351 1
a351 1
     * create any toolbars
d356 2
a357 5
    {
        static int types[] = { pane_CLIPBOUNCE|pane_INTERNAL|pane_BOTRIGHT,
                               pane_CLIPBOUNCE|pane_INTERNAL|pane_TOPLEFT,
                               pane_CLIPBOUNCE|pane_EXTERNAL|pane_BOTRIGHT,
                               pane_CLIPBOUNCE|pane_EXTERNAL|pane_TOPLEFT};
d359 1
a359 1

d363 3
a365 5
           if ((e = _swix (Toolbox_CreateObject, _INR(0,1)|_OUT(0),
                             0,
                             *(&(window_template->toolbar_ibl)+k),
                             &(new_window->ibl)+k
                          )) != NULL) {
d367 1
a367 1
               goto error;
d369 2
a370 2

           r.r[3] = *(&(new_window->ibl)+k);
d374 2
a375 1
           set_pane(new_window,&r);
d379 2
a380 2
    /*
     * take copy of keyboard shortcuts (creating any objects which are to be shown on a
d387 1
a387 1

d392 1
a392 1
        }
d400 1
a400 1
            new_window->keyboard_shortcuts[k].key_event     = window_template->keyboard_shortcuts[k].key_event;
d410 3
a412 5
                if ((e = _swix(Toolbox_CreateObject, _INR(0,1)|_OUT(0),
                                0,
                                window_template->keyboard_shortcuts[k].key_show,
                                &new_window->keyboard_shortcuts[k].key_show
                              )) != NULL)
d414 2
d433 1
a433 1
           if (((pass ==0 ) && (gt->hdr.flags & Gadget_AtBack)) ||
d446 1
a446 1
     * ... and add to list for this task
d462 1
a462 1

d470 3
a472 1
        _swix (Toolbox_DeleteObject, _INR(0,1), 0, new_window->menu);
d487 3
a489 3
                _swix (Toolbox_DeleteObject, _INR(0,1),
                                0,
                                new_window->keyboard_shortcuts[k].key_show);
d505 1
a505 1

d512 1
a512 1
    _kernel_swi_regs regs;
d514 1
a514 1

@


4.1.7.4
log
@Fixed bug where SetTitle crashes with a window without a titlebar.
@
text
@a18 2
 *          05-Jun-97:  PW: Fixed bug where SetTitle crashes with a window
 *                          without a titlebar.
d278 1
a278 2
//    if (window_template->window.title.indirect_text.buffer != NULL)
    if (window_template->window.title.indirect_text.buff_len != 0)
a300 5
    }
    else
    {
        new_window->window.title.indirect_text.valid_string = NULL;
        new_window->window.title.indirect_text.buff_len = 0;
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

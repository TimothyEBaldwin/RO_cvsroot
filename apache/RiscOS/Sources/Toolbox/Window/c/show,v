head	4.8;
access;
symbols
	Window-1_79:4.8
	Window-1_78:4.8
	Window-1_77:4.8
	Window-1_76:4.8
	Window-1_75:4.7
	Window-1_74:4.7
	Window-1_73:4.7
	Window-1_72:4.7
	Window-1_71:4.7
	RO_5_07:4.7
	Window-1_70:4.7
	Window-1_69:4.7
	Window-1_68:4.6
	Window-1_67:4.6
	Window-1_66:4.6
	Window-1_65:4.6
	Window-1_64:4.6
	Window-1_63:4.6
	Window-1_62:4.6
	Window-1_61:4.6
	Window-1_60:4.6
	Window-1_59:4.6
	mstphens_UrsulaRiscPCBuild_20Nov98:4.6
	sbrodie_Toolbox_Ursula_231198:4.6
	Window-1_58:4.6
	Ursula_RiscPC:4.6.0.4
	Window-1_57:4.6
	rthornb_UrsulaBuild-19Aug1998:4.6
	UrsulaBuild_FinalSoftload:4.6
	rthornb_UrsulaBuild-12Aug1998:4.6
	Ursula:4.6.0.2
	Ursula_bp:4.6
	aglover_UrsulaBuild-05Aug1998:4.6
	Window-1_56:4.6
	rthornb_UrsulaBuild-29Jul1998:4.6
	Window-1_55:4.6
	rthornb_UrsulaBuild-22Jul1998:4.6
	rthornb_UrsulaBuild-15Jul1998:4.6
	rthornb_UrsulaBuild-07Jul1998:4.6
	Window-1_54:4.6
	rthornb_UrsulaBuild-17Jun1998:4.6
	Window-1_53:4.6
	Window-1_52:4.6
	Window-1_51:4.5
	rthornb_UrsulaBuild-03Jun1998:4.4
	rthornb_UrsulaBuild-27May1998:4.4
	rthornb_UrsulaBuild-21May1998:4.4
	Ursula_12May1998:4.2.0.4
	rthornb_UrsulaBuild_01May1998:4.2
	sbrodie_Window_1_49:4.4
	afrost_NC2_Generic:4.1.7.5
	sbrodie_Window_1_48:4.4
	Daytona:4.2.0.2
	Daytona_bp:4.2
	sbrodie_Expresso_final_190298:4.3
	sbrodie_Window_1_46:4.3
	sbrodie_Expresso_BETA6_19980204:4.3
	sbrodie_Window_1_44:4.3
	Spinner_RCA116:4.1.7.5
	Spinner_B20_2:4.1.7.5
	Spinner_19_3:4.1.7.5
	Spinner_B18:4.1.7.5
	Spinner_B17:4.1.7.5
	Spin_merge_8Jul97:4.1.7.5
	Ursula_bp_8Jul97:4.2
	Spinner_B15:4.1.7.5
	Spinner_B14:4.1.7.5
	Spinner_B13:4.1.7.5
	Ursula_bp_13Jun97:4.2
	Spin_merge_13Jun97:4.1.7.5
	Spinner_B12:4.1.7.5
	Spinner_B10:4.1.7.5
	Spin_merge_13May97:4.1.7.1
	Spinner_B7:4.1.7.5
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.5
	RCA_bp:4.1
	pwombwel_Rel_1_36:4.1.7.5
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.5
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2015.08.18.22.05.00;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	oMg9J5QqfRoPENxy;

4.7
date	2002.12.12.20.28.25;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	98.06.11.15.26.49;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	98.06.11.11.53.33;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	98.04.21.15.29.34;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.01.15.13.19.22;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.13.09.12.16;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.23.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.23.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.46.21;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.18.25;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.42.03;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.01.29.15.12.48;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.02.04.17.22.49;	author pwombwel;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.03.17.17.08.53;	author pwombwel;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.03.19.18.57.31;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Makefile recreated from fragments
Include paths changed to Unix style.
Debug and non debug CMHG definitions replaced by one which is selected by passing predefines to CMHG.
Removed dummy services.h.
Don't bother calling TinyStubs SWI since in ROM it does nothing, and the RAM versions haven't used it since ~1997.
Use module header constants generated from CMHG rather than hand made one.
Reject out of range SWIs (fixes ticket #305).
Dependencies cleaned from tests.

Version 1.76. Tagged as 'Window-1_76'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Title:   show.c
 * Purpose: show a Window Object
 * Author:  IDJ
 * History: 14-Jan-94: IDJ: created
 *           9-Feb-95: IDJ: bug-fix AQU-01205
 *          28-Sep-96: EPW: Added flag to Toolbox_ShowObject_FullSpec to
 *                          mean embedded inside a parent window.
 *          07-Oct-96: EPW: Added Toolbox_ShowObject_Centre
 *          02-Feb-97: EPW: Added Toolbox_ShowObject_AtPointer
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "const.h"
#include "macros.h"
#include "debug.h"
#include "mem.h"
#include "string32.h"
#include "messages.h"

#include "objects/toolbox.h"
#include "objects/window.h"

#include "object.h"
#include "task.h"
#include "hide.h"
#include "gadgets.h"
#include "globals.h"

#include "show.h"
#include "toolbar.h"

extern _kernel_oserror *wimp_open_window2(wimp_NestedOpenWindow *, int, unsigned int);

/* keep track of showing something as a menu, so that we can send has_been_hidden */

WindowInternal *ShowingAsMenu = 0;

/*  NB have to remember how the show was done, so we can hide it appropriately */


static _kernel_oserror *show__raise_about_to_be_shown (WindowInternal *window, int r0, int r2, void *r3)
{
    WindowAboutToBeShownEvent        event;
    _kernel_swi_regs                 regs;

    event.hdr.size = sizeof(WindowAboutToBeShownEvent);
    event.hdr.event_code = window->show_event;
    event.hdr.flags = r0;

    event.r2 = r2;

    switch (r2)
    {
        case Toolbox_ShowObject_Default:
            /* just use old coords of window */
            break;

        case Toolbox_ShowObject_FullSpec:
            event.r3.full_spec = *((WindowShowObjectBlock *)r3);
            break;

        case Toolbox_ShowObject_TopLeft:
            event.r3.top_left = *((TopLeft *)r3);
            break;

        case Toolbox_ShowObject_Centre:
            /* just use the old coords of the window */
            break;

        case Toolbox_ShowObject_AtPointer:
            /* just use the old coords of the window */
            break;

        default:
            break;
    }

    regs.r[0] = 0;
    regs.r[1] = (int)window->id;  /* object id of this window */
    regs.r[2] = -1;              /* no component id */
    regs.r[3] = (int)&event;

    _kernel_swi (Toolbox_RaiseToolboxEvent, &regs, &regs);

    if (event.hdr.event_code == Window_AboutToBeShown) return 0;
    event.hdr.event_code = Window_AboutToBeShown;

    return (_kernel_swi (Toolbox_RaiseToolboxEvent, &regs, &regs));

}


_kernel_oserror *show__open_window(int r0, wimp_NestedOpenWindow *open,
				WindowInternal *w,
				unsigned int parent_window_handle,
				unsigned int alignment_flags)
{
    _kernel_oserror *e = NULL;
    wimp_GetWindowState state;
    int flags, alreadyopen;

    /*
     *
     *    R0 flags tell us whether to open as Menu or SubMenu, using
     *    Wimp_CreateMenu and Wimp_CreateSubMenu, else we use
     *    Wimp_OpenWindow.
     *
     */

    DEBUG debug_output ("show","Window: about to show 0x%x as type %d\n", open->window_handle,r0);

    state.open.window_handle = w->wimp_window_handle;
    wimp_get_window_state(&state);
    flags = state.flags;
    alreadyopen = flags & wimp_WINDOWFLAGS_OPEN;


    switch (r0)
    {
        case Toolbox_ShowObject_AsMenu:
        case Toolbox_ShowObject_AsSubMenu:
            {
#ifdef DIALOGUESGOCREAM
                set_window_focus_colour(w->wimp_window_handle,2);
#endif
                set_window_flags(w->wimp_window_handle,wimp_WINDOWFLAGS_HAS_BACK_ICON,0);
                if(r0 == Toolbox_ShowObject_AsMenu)
                   e = wimp_create_menu((void *) open->window_handle,open->visible_area.xmin,open->visible_area.ymax);
                else
                   e = wimp_create_submenu((void *) open->window_handle,open->visible_area.xmin,open->visible_area.ymax);

                /* this will cause any transient window currently showing to go */
                if (ShowingAsMenu && !e) {
                   if (ShowingAsMenu->show_balance > 0) {
                      _hide_raise_hidden(ShowingAsMenu);
                   }
                   ShowingAsMenu = NULL;
                }

                if((!e) && (w->flags & Window_GenerateHasBeenHidden)) {
                   ShowingAsMenu = w;
                }
    		w->show_balance++;

            }
            break;

        default:
            if (!alreadyopen)
            {
#ifdef DIALOGUESGOCREAM
               set_window_focus_colour(w->wimp_window_handle,w->window.colours[6]);
#endif
               if (WIMP_VERSION_NUMBER < 380)
               {
                  set_window_flags(w->wimp_window_handle,
        	    	           wimp_WINDOWFLAGS_HAS_BACK_ICON,w->window.flags);
               }
            }

            if (WIMP_VERSION_NUMBER >= 380)
            {
                wimp_GetWindowState state;

                if ((r0 & Toolbox_ShowObject_AsSubWindow) && (alignment_flags & 1))
                    state.flags = open->window_flags;
                else
                {
                    int current_parent;
                    unsigned int current_align;
                    state.open.window_handle = w->wimp_window_handle;
                    wimp_get_window_state2(&state, &current_parent, &current_align);
                    if (!(r0 & Toolbox_ShowObject_AsSubWindow))
                    {
                        parent_window_handle = current_parent;
                        alignment_flags = current_align;
                    }
                }
                open->window_flags = ((state.flags) &
            			~wimp_WINDOWFLAGS_HAS_BACK_ICON) |
            			(w->window.flags &
            				wimp_WINDOWFLAGS_HAS_BACK_ICON);
            }
            if(w == ShowingAsMenu) ShowingAsMenu = 0;

            e = show_with_panes(w, open, 0x4b534154,
                		parent_window_handle, alignment_flags | 1);

            break;
    }

    if (!alreadyopen && !e) {

        DEBUG debug_output ("show","Window: show with default focus %d\n", w->default_focus);

        /* need to put the caret somewhere according to default_focus */

        if (w->default_focus == DontSetFocus) return NULL;                /* no focus */

        if (w->default_focus == SetFocusToWindow)
           wimp_set_caret_position(open->window_handle,-1,0,0,1<<25,0); /*ignore errors */
        else {
           GadgetInternal *g = w->gadgets;

           while (g != NULL)
           {
             if (g->gadget_hdr.component_id == w->default_focus)
             break;

             g = g->next;
           }
           if(g) e = gadgets_set_focus(g,w->wimp_window_handle,1);
        }

    }

    return e;
}


extern _kernel_oserror *show_do_the_show (WindowInternal *w, int r0, int r2, void *r3)
{
    /*
     * Function to actually show the window.  This may have been
     * deferred til after a warning has been received by the
     * client.
     *
     * Showing a Window is easy :-)
     *    If show in default place:
     *            if already shown, show again
     *            else show where template tells you
     *
     *    If show top left:
     *            if already shown, get state, and set xmin, ymax
     *            else get template and set xmin, ymax
     *
     *    If show full info:
     *            use supplied block:
     *               window show type == 0, show as rest of block
     *                                == 1, bring to top
     *                                == 2, stagger
     *
     *    If show centre:
     *            if already shown, get state, set xmin, ymax
     *            else get template and set xmin, ymax
     *
     *    If show at pointer:
     *            if already shown, get state, set xmin, ymax
     *            else get template and set xmin, ymax
     */

    /* R0 is flags word
     * R2 is generic "show type"
     * R3 is block of data for fully-specified show
     */

    wimp_NestedOpenWindow     open;
    wimp_GetWindowState state;
    _kernel_oserror    *e = NULL;
    unsigned int parent_window_handle = 0;
    unsigned int alignment_flags = 0;

    /*
     * Get Window's current state, for use in opening it
     */

    state.open.window_handle = w->wimp_window_handle;

    if ((e = wimp_get_window_state(&state)) != NULL) return e;
#if 0
    if (state.flags & wimp_WINDOWFLAGS_OPEN)
       open = state.open;
    else {
       wimp_GetWindowInfo info;
       info.window_handle = w->wimp_window_handle;
       wimp_get_window_info((void *) (((int) &info) +1));
       memcpy (&open,&info,sizeof(open));
    }
#else
    memcpy(&open, &state.open, sizeof(state.open));
#endif
    open.behind = wimp_OpenWindow_TopOfStack;

    /*
     * Set up a wimp open window block, from user info
     */

    switch (r2)
    {
        case Toolbox_ShowObject_Default:
            /* just use old coords of window */

            if (w->flags & Window_IsToolBar) {
               _kernel_swi_regs regs;
               /* is it one of the toolbars for its parent ? */
               WindowInternal *parent = w->parent;

               regs.r[3] = (int) w->id;
               remove_pane(parent,&regs);

               regs.r[4] = 0;

               regs.r[5] = 0;
               regs.r[6] = 0;
               if (parent->ibl == w->id) regs.r[4] = 17;
               if (parent->itl == w->id) regs.r[4] = 19;
               if (parent->ebl == w->id) regs.r[4] = 16;
               if (parent->etl == w->id) regs.r[4] = 18;

               if (regs.r[4]) set_pane(parent,&regs);
               else return make_error(Window_NotToolbar,0);

               return NULL;

            }
            break;

        case Toolbox_ShowObject_FullSpec:
            {
                WindowShowObjectBlock *show = r3;

                open.visible_area = show->visible_area;
                open.scx = show->scx;
                open.scy = show->scy;
                open.behind = show->behind;

                if (r0 & Toolbox_ShowObject_AsSubWindow)
                {
                    parent_window_handle = show->parent_window_handle;
                    alignment_flags = show->alignment_flags;
                    if (alignment_flags & 1)
                        open.window_flags = show->window_flags;
                }
            }
            break;

        case Toolbox_ShowObject_TopLeft:
            {
            int xoff = -open.visible_area.xmin + ((TopLeft *)r3)->x;
            int yoff = -open.visible_area.ymax + ((TopLeft *)r3)->y;
            open.visible_area.xmin = ((TopLeft *)r3)->x;
            open.visible_area.ymax = ((TopLeft *)r3)->y;
            open.visible_area.xmax += xoff;
            open.visible_area.ymin += yoff;
            break;
            }

        case Toolbox_ShowObject_Centre:
            {
            int width = open.visible_area.xmax - open.visible_area.xmin;
            int height = open.visible_area.ymax - open.visible_area.ymin;
            open.visible_area.xmin = (((Display.XPix + 1) << Display.XEig) -
            				width) / 2;
            open.visible_area.xmax = open.visible_area.xmin + width;
            open.visible_area.ymax = (((Display.YPix + 1) << Display.YEig) +
            				height) / 2;
            open.visible_area.ymin = open.visible_area.ymax - height;
            break;
            }

        case Toolbox_ShowObject_AtPointer:
            {
            int width = open.visible_area.xmax - open.visible_area.xmin;
            int height = open.visible_area.ymax - open.visible_area.ymin;
            wimp_PointerInfo pointer;

            wimp_get_pointer_info(&pointer);

            open.visible_area.xmin = pointer.x - 64;
            open.visible_area.ymax = pointer.y;
            open.visible_area.xmax = open.visible_area.xmin + width;
            open.visible_area.ymin = open.visible_area.ymax - height;
            break;
            }

        default:
            break;
    }


    /*
     * Get the Wimp to actually open the window (finally!)
     */

    /* IDJ: 9-Feb-95: bug-fix AQU-01205: must remember the way the window was shown if error
     *                is due to no unfaded writables left to put caret into, since
     *                window will have been shown, despite error!
     */

    if ((e = show__open_window(r0 & (Toolbox_ShowObject_AsMenu |
    					Toolbox_ShowObject_AsSubMenu |
    					Toolbox_ShowObject_AsSubWindow),
    				&open,
    				w,
    				parent_window_handle,
    				alignment_flags)) != NULL)
    {
        if (e->errnum != Window_NoGadgetsLeft)
            return e;
    }

    /*
     * remember how it was shown, so we know how to hide it!
     */

    w->state = ((w->state) & ~ (Toolbox_ShowObject_AsMenu|Toolbox_ShowObject_AsSubMenu)) |
                (r0 & (Toolbox_ShowObject_AsMenu|Toolbox_ShowObject_AsSubMenu));


    return e;
}


extern _kernel_oserror *show_object (_kernel_swi_regs *r, TaskDescriptor *t)
{

    /*
     * request to show an object
     * R0 = 3
     * R1 = Object ID
     * R2 = internal handle returned when Object was created
     * R3 = wimp task handle of caller (use to identify task descriptor)
     * R4 -> user regs R0-R9
     *      R0 =  flags
     *      R1 =  Object ID
     *      R2 =  "show type"
     *            0 => default place
     *            1 => R3 points to buffer with full data for showing
     *            2 => R3 points to buffer with coordinates
     *            3 => Show centred
     *            4 => At pointer
     *      R3 = 0
     *   OR R3 -> buffer giving Object-specific data for showing this
     *            Object
     *      R4 =  Parent Object ID
     *      R5 =  Parent Component ID
     */

    /*
     * Function to "display" an Object on the screen.  If R2 == 0, then
     * display in default place.
     * If Object has bit set to say warn before show, then we should just
     * send Toolbox Event, and wait for the next call to Wimp_Poll after
     * the event is delivered before the Object is actually shown
     * (ie catch it in the prefilter).
     *
     */

    _kernel_swi_regs *user_regs = (_kernel_swi_regs *)r->r[4];
    _kernel_oserror  *e         = NULL;
    WindowInternal   *window    = (WindowInternal *)r->r[2];

    /*
     * If a Window_AboutToBeShown needs to be sent, we defer the show til
     * later, and just cache the parameters passed to this SWI.
     */

    IGNORE(t);

    DEBUG debug_output("force", "show_object: show_balance = %d", window->show_balance);

    /* Added this test in 1.51 to flush HasBeenHidden events *BEFORE* AboutToBeShown
     * events
     */
    if (window->show_balance > 0 && (window->flags & Window_GenerateHasBeenHidden)) {
        window->show_balance--;
        _hide_raise_hidden(window);
    }

    if (window->flags & Window_GenerateAboutToBeShown)
    {
        e = show__raise_about_to_be_shown (window,user_regs->r[0], user_regs->r[2], (void *)user_regs->r[3]);
    }
    else
    {
        /* no event to be raised, so just do the show */

        e = show_do_the_show (window, user_regs->r[0], user_regs->r[2], (void *)user_regs->r[3]);
    }

    return e;
}

/*
 * This routine is somewhat convoluted. The basic problem is
 * that the window may not open at the position specified in
 * the open block - it may get forced on screen. This can
 * screw up panes something rotten.
 *
 * The simplistic solution (as employed in Window 1.31) is
 * to open the panes according to the open parameter, then
 * the window, then check whether we opened where we expected.
 * If not, open the panes again and the window again.
 * However, this allows you to see panes jumping between the
 * two positions (especially if you try dragging a force on
 * screen window off the screen).
 *
 * So, now we look for any easy cases that allow us to
 * open the panes after the main window
 */
_kernel_oserror *show_with_panes(WindowInternal *w, wimp_NestedOpenWindow *open,
                                 unsigned int magic, unsigned int parent_window_handle,
                                 unsigned int alignment_flags)
{
    wimp_GetWindowState state;
    int flags;
    _kernel_oserror *e;

    if (!w->panes)
       return magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                      wimp_open_window((wimp_OpenWindow *) open);

    state.open.window_handle = w->wimp_window_handle;
    wimp_get_window_state(&state);
    flags = state.flags;

    /*
     * If either of these flags are set and we have some panes
     * to open, we need to muck around to check where the window
     * actually opens
     */
    if (flags & (wimp_WINDOWFLAGS_FORCE_ON_SCREEN |
                 wimp_WINDOWFLAGS_FORCE_ONCE_ON_SCREEN))
    {
       if (open->behind == -1)
       {
          state.open.window_handle = get_frontmost_pane(w)->wimp;
          wimp_get_window_state(&state);
          if ((state.flags & wimp_WINDOWFLAGS_OPEN)
                 && state.open.behind == -1)
          {
             /*
              * We're opening at the front, and are already at
              * the front. To eliminate flicker, open the main
              * window at the same level (behind the rearmost
              * pane), then open the panes according to the
              * actual opened position.
              */
             open->behind = get_rearmost_pane(w)->wimp;
             e = magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                         wimp_open_window((wimp_OpenWindow *) open);
             open->behind = -1;
             open_panes(w, open, magic, parent_window_handle, alignment_flags);

             return e;
          }
       }
    }

    state.open.window_handle = open->window_handle;
    state.open.visible_area = open->visible_area;

    if (open->behind == -2)
    {
        /*
         * We've been sent to the back. Open the main
         * window at the back first, find who it's
         * actually behind, then open the pane
         * windows
         */
        e = magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                    wimp_open_window((wimp_OpenWindow *) open);
        wimp_get_window_state(&state);
        open->behind = state.open.behind;
        open_panes(w, open, magic, parent_window_handle, alignment_flags);
        return e;
    }
    else if (open->behind == open->window_handle ||
             open->behind == get_rearmost_pane(w)->wimp)
    {
        /*
         * We're opening at the same level (eg dragging with
         * adjust). This is easy: open the main window first,
         * then the panes
         */
        e = magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                    wimp_open_window((wimp_OpenWindow *) open);
        state.open.window_handle = get_frontmost_pane(w)->wimp;
        wimp_get_window_state(&state);
        open->behind = state.open.behind;
        open_panes(w, open, magic, parent_window_handle, alignment_flags);
        return e;
    }

    /* Okay, it's either a simple case, or a very nasty one */
    open->behind = open_panes(w, open, magic, parent_window_handle, alignment_flags);

    if ((e = magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                     wimp_open_window((wimp_OpenWindow *) open)
        ) != NULL)
       return e;

    /*
     * it's possible that the window hasn't opened
     * where we expected it to be...
     */
    if (memcmp(&open->visible_area,
               &state.open.visible_area,
               sizeof open->visible_area)) {
       /* they're different */
       open->behind = state.open.behind;
       open->behind = open_panes(w,open, 0, 0, 0);
       return wimp_open_window((wimp_OpenWindow *) open);
    }

    return NULL;
}

void show_shutdown(int taskhandle)
{
        if (ShowingAsMenu == NULL) return;
        if (taskhandle == 0) {
		_swix(Wimp_CreateMenu, _IN(1), -1);
		ShowingAsMenu = NULL;
	}
	else {
                TaskDescriptor *t = task_find(taskhandle);
                if (t != NULL && t == task_find_from_window(ShowingAsMenu)) {
			_swix(Wimp_CreateMenu, _IN(1), -1);
                        ShowingAsMenu = NULL;
                }
	}
}
@


4.7
log
@Fixes to sizes of event blocks.
Now the Toolbox module only memcpy's what ou asked for it helps if
you ask for the right amount!
This manifested itself in lots of missing event_raise messages when
for example adjusters were pressed leading to false bug reports of
other apps which included adjuster icons.

Version 1.69. Tagged as 'Window-1_69'
@
text
@a35 1
#include "services.h"
d41 2
a42 2
#include "objects.toolbox.h"
#include "objects.window.h"
d48 1
a51 1
#include "main.h"
@


4.6
log
@I missed one call to _hide_raise_hidden which resulted in problems with
non-transient windows, which strangely decided to hang on until 1.51 was
committed before revealing themselves.  These are now fixed.

Version 1.52. Tagged as 'Window-1_52'
@
text
@d148 1
@


4.5
log
@Event ordering for transient submenu objects fixed (SNB-U002).
Module now uses srccommit to maintain its version number

Version 1.51. Tagged as 'Window-1_51'
@
text
@d139 1
a155 1
                      ShowingAsMenu->show_balance--;
d158 1
a158 1
                      ShowingAsMenu = NULL;
a162 1
                   w->show_balance++;
d164 2
@


4.4
log
@Window 1.48

WindowHasBeenHidden events are now generated consistently for
transiently shown windows. Instead of relying upon a single static
variable indicating which, if any, window is showing transiently, a
shown/hidden counter is kept and pending HasBeenHidden events are
flushed when message_MENUS_CLOSED arrives.  This solves the problems
observed with several Toolbox applications which variously did not
appear to get a HasBeenHidden event for a closed transient or got
duplicate messages (which confused applications wishing to show a
shared window object transiently, wait for it to close, and then open
it again (eg. a dbox asking the user to make a choice).
@
text
@d480 10
@


4.3
log
@PAN-01317 fixed: Wimp dying when Window deletes transiently shown objects
@
text
@d154 5
a158 2
                   _hide_raise_hidden(ShowingAsMenu);
                   ShowingAsMenu = NULL;
d161 4
a164 1
                if((!e) && (w->flags & Window_GenerateHasBeenHidden)) ShowingAsMenu = w;
@


4.2
log
@Spinner branch merged
@
text
@d612 16
@


4.1
log
@Initial revision
@
text
@d20 4
d52 3
d88 8
d115 4
a118 1
_kernel_oserror *show__open_window (int r0, wimp_OpenWindow *open,WindowInternal *w)
d121 2
a122 1
    wimp_OpenWindow open2;
d134 5
d143 1
a143 1
            {                            
a146 1
                set_window_flags(w->wimp_window_handle,wimp_WINDOWFLAGS_HAS_BACK_ICON,0);
d163 2
a164 1
            open2 = *open;
d166 1
a166 1
            set_window_focus_colour(w->wimp_window_handle,w->window.colours[6]);
d168 6
a173 1
            set_window_flags(w->wimp_window_handle,wimp_WINDOWFLAGS_HAS_BACK_ICON,w->window.flags);
d175 3
a177 2
            if (w->panes) open->behind = open_panes(w,open);
            e = wimp_open_window(open);
d179 18
a196 7
            /* its possible that the window hasn't opened where we 
               expected it to be... */
            if (memcmp(open,&open2,20) && w->panes) {
               /* they're different */
               open->behind = open2.behind;
               open->behind = open_panes(w,open);
               e = wimp_open_window(open);
d198 5
a202 1
            if(w == ShowingAsMenu) ShowingAsMenu = 0;  
a203 1

d206 1
a206 1
    if (!e) {
d214 1
a214 1
        if (w->default_focus == SetFocusToWindow) 
d256 8
d271 1
a271 1
    wimp_OpenWindow     open;
d274 2
d285 1
a285 1
    if (state.flags & wimp_WINDOWFLAGS_OPEN) 
d292 1
a292 1
    } 
d294 1
a294 1
    open = state.open;
d314 1
a314 1
                            
d316 1
a316 1
                  
d333 16
a348 1
            memcpy ((void *)&open.visible_area, r3, sizeof(WindowShowObjectBlock));
d356 1
a356 1
            open.visible_area.ymax = ((TopLeft *)r3)->y;           
d359 29
a387 1
            break;                                      
d404 7
a410 1
    if ((e = show__open_window (r0 & (Toolbox_ShowObject_AsMenu|Toolbox_ShowObject_AsSubMenu), &open, w)) != NULL)
a415 1

d444 2
d488 124
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Imported from SrcFiler
@
text
@a19 1
 *          25-Nov-96: EPW: extended to handle nested windows
d100 1
a100 4
_kernel_oserror *show__open_window(int r0, wimp_NestedOpenWindow *open,
				WindowInternal *w,
				unsigned int parent_window_handle,
				unsigned int alignment_flags)
d119 1
a119 1
            {
d140 1
a140 1
            open2 = *((wimp_OpenWindow *)open);
d142 1
a142 2
            set_window_focus_colour(w->wimp_window_handle,
            				w->window.colours[6]);
d144 1
a144 2
            set_window_flags(w->wimp_window_handle,
            		     wimp_WINDOWFLAGS_HAS_BACK_ICON,w->window.flags);
d146 2
a147 9
            if (w->panes) open->behind = open_panes(w,
            					(wimp_OpenWindow *) open);
            if (r0 == Toolbox_ShowObject_AsSubWindow)
            {
                e = _swix(Wimp_OpenWindow, _INR(1,4), open, 0x4b534154,
                		parent_window_handle, alignment_flags);
            }
            else
                e = wimp_open_window((wimp_OpenWindow *) open);
d149 1
a149 1
            /* its possible that the window hasn't opened where we
d151 5
a155 12
            if (memcmp(open, &open2, 20) && w->panes)
            {
                /* they're different */
                open->behind = open2.behind;
                open->behind = open_panes(w, (wimp_OpenWindow *) open);
                if (r0 == Toolbox_ShowObject_AsSubWindow)
                {
                    e = _swix(Wimp_OpenWindow, _INR(1,4), open, 0x4b534154,
    	           		parent_window_handle, alignment_flags);
                }
                else
                    e = wimp_open_window((wimp_OpenWindow *) open);
d157 1
a157 2
            if (w == ShowingAsMenu)
                ShowingAsMenu = 0;
d159 1
d170 1
a170 1
        if (w->default_focus == SetFocusToWindow)
d219 1
a219 1
    wimp_NestedOpenWindow     open;
a221 2
    unsigned int parent_window_handle = 0;
    unsigned int alignment_flags = 0;
d231 1
a231 1
    if (state.flags & wimp_WINDOWFLAGS_OPEN)
d238 1
a238 1
    }
d240 1
a240 1
    memcpy(&open, &state.open, sizeof(state.open));
d260 1
a260 1

d262 1
a262 1

d279 1
a279 15
            {
                WindowShowObjectBlock *show = r3;

                open.visible_area = show->visible_area;
                open.scx = show->scx;
                open.scy = show->scy;
                open.behind = show->behind;

                if (r0 | Toolbox_ShowObject_AsSubWindow)
                {
                    open.window_flags = show->window_flags;
                    parent_window_handle = show->parent_window_handle;
                    alignment_flags = show->alignment_flags;
                }
            }
d287 1
a287 1
            open.visible_area.ymax = ((TopLeft *)r3)->y;
d290 1
a290 1
            break;
d307 1
a307 7
    if ((e = show__open_window(r0 & (Toolbox_ShowObject_AsMenu |
    					Toolbox_ShowObject_AsSubMenu |
    					Toolbox_ShowObject_AsSubWindow),
    				&open,
    				w,
    				parent_window_handle,
    				alignment_flags)) != NULL)
a310 7
    }

    // We need to inform any gadget handlers that the window's just
    // appeared
    if (!(state.flags & 1<<16)) // WimpWindow_Open
    {
        gadget_window_appeared(w);
@


4.1.7.3
log
@Added support for nested windows and showtypes 2 and 3 - centred and at pointer
@
text
@d20 1
a20 4
 *          28-Sep-96: EPW: Added flag to Toolbox_ShowObject_FullSpec to
 *                          mean embedded inside a parent window.
 *          07-Oct-96: EPW: Added Toolbox_ShowObject_Centre
 *          02-Feb-97: EPW: Added Toolbox_ShowObject_AtPointer
a48 1
#include "main.h"
a81 8
        case Toolbox_ShowObject_Centre:
            /* just use the old coords of the window */
            break;

        case Toolbox_ShowObject_AtPointer:
            /* just use the old coords of the window */
            break;

d149 2
d154 1
a154 5

            if (r0 != Toolbox_ShowObject_AsSubWindow)
                parent_window_handle = -1;

            if (WIMP_VERSION_NUMBER < 380)
d156 2
a157 2
                set_window_flags(w->wimp_window_handle,
            		     wimp_WINDOWFLAGS_HAS_BACK_ICON,w->window.flags);
d160 1
a160 12
            {
                wimp_GetWindowState state;

                state.open.window_handle = w->wimp_window_handle;
                e = wimp_get_window_state(&state);
                open->window_flags = ((state.flags) &
            			~wimp_WINDOWFLAGS_HAS_BACK_ICON) |
            			(w->window.flags &
            				wimp_WINDOWFLAGS_HAS_BACK_ICON);
            }
            e = _swix(Wimp_OpenWindow, _INR(1,4), open, 0x4b534154,
                		parent_window_handle, alignment_flags | 1);
a231 8
     *
     *    If show centre:
     *            if already shown, get state, set xmin, ymax
     *            else get template and set xmin, ymax
     *
     *    If show at pointer:
     *            if already shown, get state, set xmin, ymax
     *            else get template and set xmin, ymax
a328 28
        case Toolbox_ShowObject_Centre:
            {
            int width = open.visible_area.xmax - open.visible_area.xmin;
            int height = open.visible_area.ymax - open.visible_area.ymin;
            open.visible_area.xmin = (((Display.XPix + 1) << Display.XEig) -
            				width) / 2;
            open.visible_area.xmax = open.visible_area.xmin + width;
            open.visible_area.ymax = (((Display.YPix + 1) << Display.YEig) +
            				height) / 2;
            open.visible_area.ymin = open.visible_area.ymax - height;
            break;
            }

        case Toolbox_ShowObject_AtPointer:
            {
            int width = open.visible_area.xmax - open.visible_area.xmin;
            int height = open.visible_area.ymax - open.visible_area.ymin;
            wimp_PointerInfo pointer;

            wimp_get_pointer_info(&pointer);

            open.visible_area.xmin = pointer.x - 64;
            open.visible_area.ymax = pointer.y;
            open.visible_area.xmax = open.visible_area.xmin + width;
            open.visible_area.ymin = open.visible_area.ymax - height;
            break;
            }

d355 8
a390 1
     *            3 => Show centred
@


4.1.7.4
log
@Added SetFont methods for Radio & Option buttons
Added Service_StartWimp (0x49) to cope with softloading a
window manager *after* this module.
@
text
@a444 1
     *            4 => At pointer
@


4.1.7.5
log
@Add "Extendable X and Extendable Y" toolbars.
Improve pane-handling algorithms.
Fix alignment of labels in labelled boxes.
Align numberrange's slider more neatly and put adjusters in right place
Stringsets tidied up
Some useful checking added to string_set_toolbox_event
Showing as subwindow fixed up a lot.
@
text
@a53 2
extern _kernel_oserror *wimp_open_window2(wimp_NestedOpenWindow *, int, unsigned int);

d119 1
a119 2
    wimp_GetWindowState state;
    int flags, alreadyopen;
a130 5
    state.open.window_handle = w->wimp_window_handle;
    wimp_get_window_state(&state);
    flags = state.flags;
    alreadyopen = flags & wimp_WINDOWFLAGS_OPEN;

d139 1
d156 1
a156 2
            if (!alreadyopen)
            {
d158 2
a159 1
               set_window_focus_colour(w->wimp_window_handle,w->window.colours[6]);
d161 11
a171 5
               if (WIMP_VERSION_NUMBER < 380)
               {
                  set_window_flags(w->wimp_window_handle,
        	    	           wimp_WINDOWFLAGS_HAS_BACK_ICON,w->window.flags);
               }
d173 1
a173 2

            if (WIMP_VERSION_NUMBER >= 380)
d177 2
a178 14
                if ((r0 & Toolbox_ShowObject_AsSubWindow) && (alignment_flags & 1))
                    state.flags = open->window_flags;
                else
                {
                    int current_parent;
                    unsigned int current_align;
                    state.open.window_handle = w->wimp_window_handle;
                    wimp_get_window_state2(&state, &current_parent, &current_align);
                    if (!(r0 & Toolbox_ShowObject_AsSubWindow))
                    {
                        parent_window_handle = current_parent;
                        alignment_flags = current_align;
                    }
                }
d184 1
a184 3
            if(w == ShowingAsMenu) ShowingAsMenu = 0;

            e = show_with_panes(w, open, 0x4b534154,
d187 17
d207 1
a207 1
    if (!alreadyopen && !e) {
d342 1
a342 1
                if (r0 & Toolbox_ShowObject_AsSubWindow)
d344 1
a346 2
                    if (alignment_flags & 1)
                        open.window_flags = show->window_flags;
a487 124
/*
 * This routine is somewhat convoluted. The basic problem is
 * that the window may not open at the position specified in
 * the open block - it may get forced on screen. This can
 * screw up panes something rotten.
 *
 * The simplistic solution (as employed in Window 1.31) is
 * to open the panes according to the open parameter, then
 * the window, then check whether we opened where we expected.
 * If not, open the panes again and the window again.
 * However, this allows you to see panes jumping between the
 * two positions (especially if you try dragging a force on
 * screen window off the screen).
 *
 * So, now we look for any easy cases that allow us to
 * open the panes after the main window
 */
_kernel_oserror *show_with_panes(WindowInternal *w, wimp_NestedOpenWindow *open,
                                 unsigned int magic, unsigned int parent_window_handle,
                                 unsigned int alignment_flags)
{
    wimp_GetWindowState state;
    int flags;
    _kernel_oserror *e;

    if (!w->panes)
       return magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                      wimp_open_window((wimp_OpenWindow *) open);

    state.open.window_handle = w->wimp_window_handle;
    wimp_get_window_state(&state);
    flags = state.flags;

    /*
     * If either of these flags are set and we have some panes
     * to open, we need to muck around to check where the window
     * actually opens
     */
    if (flags & (wimp_WINDOWFLAGS_FORCE_ON_SCREEN |
                 wimp_WINDOWFLAGS_FORCE_ONCE_ON_SCREEN))
    {
       if (open->behind == -1)
       {
          state.open.window_handle = get_frontmost_pane(w)->wimp;
          wimp_get_window_state(&state);
          if ((state.flags & wimp_WINDOWFLAGS_OPEN)
                 && state.open.behind == -1)
          {
             /*
              * We're opening at the front, and are already at
              * the front. To eliminate flicker, open the main
              * window at the same level (behind the rearmost
              * pane), then open the panes according to the
              * actual opened position.
              */
             open->behind = get_rearmost_pane(w)->wimp;
             e = magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                         wimp_open_window((wimp_OpenWindow *) open);
             open->behind = -1;
             open_panes(w, open, magic, parent_window_handle, alignment_flags);

             return e;
          }
       }
    }

    state.open.window_handle = open->window_handle;
    state.open.visible_area = open->visible_area;

    if (open->behind == -2)
    {
        /*
         * We've been sent to the back. Open the main
         * window at the back first, find who it's
         * actually behind, then open the pane
         * windows
         */
        e = magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                    wimp_open_window((wimp_OpenWindow *) open);
        wimp_get_window_state(&state);
        open->behind = state.open.behind;
        open_panes(w, open, magic, parent_window_handle, alignment_flags);
        return e;
    }
    else if (open->behind == open->window_handle ||
             open->behind == get_rearmost_pane(w)->wimp)
    {
        /*
         * We're opening at the same level (eg dragging with
         * adjust). This is easy: open the main window first,
         * then the panes
         */
        e = magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                    wimp_open_window((wimp_OpenWindow *) open);
        state.open.window_handle = get_frontmost_pane(w)->wimp;
        wimp_get_window_state(&state);
        open->behind = state.open.behind;
        open_panes(w, open, magic, parent_window_handle, alignment_flags);
        return e;
    }

    /* Okay, it's either a simple case, or a very nasty one */
    open->behind = open_panes(w, open, magic, parent_window_handle, alignment_flags);

    if ((e = magic ? wimp_open_window2(open, parent_window_handle, alignment_flags) :
                     wimp_open_window((wimp_OpenWindow *) open)
        ) != NULL)
       return e;

    /*
     * it's possible that the window hasn't opened
     * where we expected it to be...
     */
    if (memcmp(&open->visible_area,
               &state.open.visible_area,
               sizeof open->visible_area)) {
       /* they're different */
       open->behind = state.open.behind;
       open->behind = open_panes(w,open, 0, 0, 0);
       return wimp_open_window((wimp_OpenWindow *) open);
    }

    return NULL;
}
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.7;
access;
symbols
	Window-1_79:4.7
	Window-1_78:4.7
	Window-1_77:4.7
	Window-1_76:4.7
	Window-1_75:4.6
	Window-1_74:4.6
	Window-1_73:4.6
	Window-1_72:4.6
	Window-1_71:4.6
	RO_5_07:4.6
	Window-1_70:4.6
	Window-1_69:4.5
	Window-1_68:4.5
	Window-1_67:4.5
	Window-1_66:4.5
	Window-1_65:4.4
	Window-1_64:4.4
	Window-1_63:4.4
	Window-1_62:4.4
	Window-1_61:4.4
	Window-1_60:4.4
	Window-1_59:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	sbrodie_Toolbox_Ursula_231198:4.4
	Window-1_58:4.4
	Ursula_RiscPC:4.3.0.4
	Window-1_57:4.3
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	Ursula:4.3.0.2
	Ursula_bp:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	Window-1_56:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	Window-1_55:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	Window-1_54:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	Window-1_53:4.3
	Window-1_52:4.3
	Window-1_51:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	Ursula_12May1998:4.2.0.4
	rthornb_UrsulaBuild_01May1998:4.2
	sbrodie_Window_1_49:4.3
	afrost_NC2_Generic:4.1.7.3
	sbrodie_Window_1_48:4.3
	Daytona:4.2.0.2
	Daytona_bp:4.2
	sbrodie_Expresso_final_190298:4.3
	sbrodie_Window_1_46:4.3
	sbrodie_Expresso_BETA6_19980204:4.3
	sbrodie_Window_1_44:4.3
	Spinner_RCA116:4.1.7.3
	Spinner_B20_2:4.1.7.3
	Spinner_19_3:4.1.7.3
	Spinner_B18:4.1.7.3
	Spinner_B17:4.1.7.3
	Spin_merge_8Jul97:4.1.7.3
	Ursula_bp_8Jul97:4.2
	Spinner_B15:4.1.7.3
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Ursula_bp_13Jun97:4.2
	Spin_merge_13Jun97:4.1.7.3
	Spinner_B12:4.1.7.3
	Spinner_B10:4.1.7.3
	Spin_merge_13May97:4.1.7.1
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.3
	RCA_bp:4.1
	pwombwel_Rel_1_36:4.1.7.3
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.3
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2015.08.18.22.05.08;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	oMg9J5QqfRoPENxy;

4.6
date	2003.06.03.10.50.34;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2001.02.13.12.48.50;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	98.11.23.13.43.06;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.01.15.12.44.37;	author pwombwel;	state Exp;
branches;
next	4.2;

4.2
date	97.05.13.09.12.31;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.23.22;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.23.22;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.46.44;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.18.53;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.42.24;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.02.04.17.23.01;	author pwombwel;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.03.19.18.57.37;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Makefile recreated from fragments
Include paths changed to Unix style.
Debug and non debug CMHG definitions replaced by one which is selected by passing predefines to CMHG.
Removed dummy services.h.
Don't bother calling TinyStubs SWI since in ROM it does nothing, and the RAM versions haven't used it since ~1997.
Use module header constants generated from CMHG rather than hand made one.
Reject out of range SWIs (fixes ticket #305).
Dependencies cleaned from tests.

Version 1.76. Tagged as 'Window-1_76'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Title:   stringset.c
 * Purpose: number range gadgets
 * Author:
 * History: 22-Feb-94: IDJ:
 *          27-Apr-94: NK : really started
 *          03-Feb-97: EPW: Increased stringset string length on menu items
 *                          from 128 to 512.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "swis.h"
#include "kernel.h"

#include "const.h"
#include "macros.h"
#include "debug.h"
#include "mem.h"
#include "string32.h"
#include "messages.h"

#include "style.h"
#include "objects/toolbox.h"
#include "objects/window.h"
#include "objects/menu.h"

#include "../globals.h"
#include "../gadgets.h"
#include "../object.h"
#include "../veneers.h"
#include "../utils.h"

#include "stringset.h"

/* __flags for window wide gadget flags, eg. faded, back bit */

static int __flags;
extern int WIMP_WINDOW;
extern int SWI_WimpCreateIcon;
extern WindowInternal *CURRENT_WINDOW;

typedef struct _stringset_internal {
  ComponentID      popup;
  ComponentID      number;
  int entries;
  int ticked;
  ObjectID      window_id,menu_id;
  int max_value_len;
  char *value;
} stringset_internal ;

static _kernel_oserror *_set_tick(ObjectID menu_id,ComponentID cid)
{
   return _swix(Toolbox_ObjectMiscOp, _INR(0,4), 0, menu_id, Menu_SetTick, cid, 1);
}

/* ctrl terminated compare function */

static char *string_compare(char *a,char *b)
{
   char x=1,y;

   while (x) {
      x = *a++;
      y = *b++;

      if (x<32) x =0;
      if (y<32) y =0;

      if (x!=y) return (a-1);
   }
   return NULL;
}

static _kernel_oserror *_untick(ObjectID menu_id,ComponentID cid)
{
   return _swix(Toolbox_ObjectMiscOp, _INR(0,4), 0, menu_id, Menu_SetTick, cid, 0);
}

        /* To improve efficiency, break up:
                N = old no. of entries, M = new no.
           1) for (e =0; e < N; e++) menu_set_text
           *** problem here is that menu entry may not have enough store ***

           2) then if N=M return
              if N>M, for (;e<N;e++) menu_delete_entry
              else, for (; e<M; e++) menu_add_entry
         */

static void _set_available(stringset_internal *ss, char *new)
{
        int e,off;
        _kernel_oserror *er=NULL;
        MenuTemplateEntry entry;
        char buf[512];

        ss->ticked =-1;

        if (new) {
          DEBUG debug_output ("stringset", "Setting entries to %s\n\r",new);
        }
        else {
          DEBUG debug_output ("stringset", "Setting entries to <none>\n\r");
        }

        for (e=0;e<ss->entries;e++) {
                _swix(Toolbox_ObjectMiscOp, _INR(0,3), 0, ss->menu_id, Menu_RemoveEntry, e);
        }
        if(!new) return;

        e=0; /* start at beginning */
        entry.click_show=NULL;
        entry.submenu_show=NULL;
        entry.submenu_event=NULL;
        entry.click_event=0;
        entry.help_message=NULL;
        entry.max_entry_help=1;
        entry.text=buf;
        while (*new >= 32) {
                off=0;
                while ((*new >=32) && (*new !=','))
                   { if (*new == '\\') buf[off++] = *(++new); else buf[off++]=*new; new++;}
                if(*new ==',') new++;
                buf[off]='\0';
                if (!(string_compare(ss->value,buf))) {
                   ss->ticked=e;
                   entry.flags=1;
                }
                else
                   entry.flags=0;

                entry.max_text=off+1;
                entry.component_id=e;

                er=_swix(Toolbox_ObjectMiscOp, _INR(0,4), 0, ss->menu_id, Menu_AddEntry,
                                               (e++)-1, /* Add after last one, or -1 for first */
                                               &entry);


                if (er) {
                  DEBUG debug_output ("stringset", "Got error from add entry %s\n\r",er->errmess);
                }

                DEBUG debug_output ("stringset", "Added entry %s, size %d\n\r",buf,off+1);

        }
        ss->entries=e;
}

static _kernel_oserror *_set_displayfield(stringset_internal *ss,char * value,GadgetInternal *gadget)
{
    if (!(gadget->gadget_hdr.flags & StringSet_NoDisplay)) {
       return (gadget_method(ss->window_id,(gadget->gadget_hdr.flags & StringSet_Writable) ?
                WritableField_SetValue : DisplayField_SetValue,ss->number,(int) value,0));
    }
    return NULL;
}

static _kernel_oserror *_set_entry_byindex(stringset_internal *ss,int index,GadgetInternal *gadget)
{
  _kernel_oserror *e=NULL;

    if (ss->ticked >=0) _untick(ss->menu_id,ss->ticked);
    ss->ticked =-1;                             /* in case something goes wrong ! */

    /* if we get an error here then we've gone past the end of the menu */

    if ((e = _swix(Toolbox_ObjectMiscOp, _INR(0,5), 0, ss->menu_id, Menu_GetEntryText,
                                                    index, ss->value, ss->max_value_len)) != NULL)
            return e;

    /* update display/writable field */

    _set_displayfield(ss,ss->value,gadget);

    e = _set_tick(ss->menu_id,index);
    if (!e) ss->ticked=index;

    return e;        /* all clear */
}

static _kernel_oserror *_set_entry_bystring(stringset_internal *ss,char *index,GadgetInternal *gadget)
{
  _kernel_oserror *e=NULL;
  int en;
  char buf[128];

  gadget = gadget;

    if (ss->ticked >=0) _untick(ss->menu_id,ss->ticked);
    ss->ticked =-1;                             /* in case something goes wrong ! */

    for (en=0; en < ss->entries; en++) {

       /* if we get an error here then we've gone passed the end of the menu */

       if ((e = _swix(Toolbox_ObjectMiscOp, _INR(0,5), 0, ss->menu_id, Menu_GetEntryText,
                                                       en, buf, 128)) != NULL)
               return e;

       if (!string_compare(index,buf)) break;
    }

    if (en <ss->entries) {
       e = _set_tick(ss->menu_id,en);
       if (!e) ss->ticked=en;
    }

    string_copy_chk(ss->value,index,ss->max_value_len);

    return e;        /* all clear */
}

_kernel_oserror *string_set_add (GadgetInternal *gadget, ObjectID window,
                                    int **icon_list, Gadget *gadget_template,
                                    int window_handle)
{
    _kernel_oserror *e;
    _kernel_swi_regs regs,r2;
    MenuTemplateHeader menu;
    ObjectTemplateHeader obj= {
          Menu_ObjectClass,
          Object_CreateOnLoad,
          102,
          "_none",
          0,0,0
        };
    stringset_internal *num;
    Gadget create;

    IGNORE (window_handle);
    IGNORE (icon_list);

    /*
     * Allocate our own data to hang off the GadgetInternal structure.
     * We take a copy of the button's template (ie its textual string).
     */

    num = mem_allocate (sizeof (stringset_internal), "stringset_add, stringset_internal type") ;
    if (num == NULL)
        return out_of_memory();

    num->max_value_len = gadget_template->data.string_set.max_selected_string_len;
    num->value = mem_allocate(num->max_value_len, "stringset_add, value buffer");
    if (num->value == NULL) {
        mem_free(num, "stringset_add, stringset_internal type (value buffer alloc failed");
        return out_of_memory();
    }

    gadget->data = (void *) num ;
    __flags = gadget_template->hdr.flags & 0xff000000u;

    num->window_id=window;
    num->entries=0;
    num->ticked =-1;

    string_copy_chk(num->value,gadget_template->data.string_set.initial_selected_string,
                gadget_template->data.string_set.max_selected_string_len);

    create.hdr.ymin=gadget_template->hdr.ymin;
    create.hdr.ymax=gadget_template->hdr.ymax;

    create.hdr.help_message=gadget_template->hdr.help_message;
    create.hdr.max_help=gadget_template->hdr.max_help;

    if (!(gadget_template->hdr.flags & StringSet_NoDisplay)) {
       if (!(gadget_template->hdr.flags & StringSet_Writable)) /* its writable */ {
       create.hdr.type = DisplayField_Type;

    switch (gadget_template->hdr.flags & StringSet_Justification) {
        case StringSet_LeftJustify:
          create.hdr.flags= DisplayField_LeftJustify;
          break;
        case StringSet_RightJustify:
          create.hdr.flags= DisplayField_RightJustify;
          break;
        case StringSet_Centred:
          create.hdr.flags= DisplayField_Centred;
          break;
    }
       create.hdr.flags |= __flags;

       create.data.display_field.text=gadget_template->data.string_set.initial_selected_string;
       create.data.display_field.max_text_len=gadget_template->data.string_set.max_selected_string_len;

       }
       else {
       create.hdr.type = WritableField_Type;

    switch (gadget_template->hdr.flags & StringSet_Justification) {
        case StringSet_LeftJustify:
          create.hdr.flags= WritableField_LeftJustify | WritableField_GenerateUserValueChanged;
          break;
        case StringSet_RightJustify:
          create.hdr.flags= WritableField_RightJustify | WritableField_GenerateUserValueChanged;
          break;
        case StringSet_Centred:
          create.hdr.flags= WritableField_Centred | WritableField_GenerateUserValueChanged;
          break;
    }
       create.hdr.flags |= __flags;

       create.data.writable_field.before=gadget_template->data.string_set.before;
       create.data.writable_field.after=gadget_template->data.string_set.after;

       create.data.writable_field.text=gadget_template->data.string_set.initial_selected_string;
       create.data.writable_field.max_text_len=gadget_template->data.string_set.max_selected_string_len;
       create.data.writable_field.allowable=gadget_template->data.string_set.allowable;
       create.data.writable_field.max_allowable_len=255;

       }

       create.hdr.xmin=gadget_template->hdr.xmin;
       create.hdr.xmax=gadget_template->hdr.xmax-52;

       if ((e = CreateSubGadget(window,&create,&(num->number),0x104)) != NULL) goto error;
    } else num->number =0;

    create.hdr.type = PopUp_Base;

    create.hdr.flags=1 | __flags;
    create.hdr.xmin=gadget_template->hdr.xmax-44;
    create.hdr.xmax=gadget_template->hdr.xmax;
    create.hdr.ymin=(gadget_template->hdr.ymin+gadget_template->hdr.ymax)/2-22;
    create.hdr.ymax=create.hdr.ymin+44;

    create.data.popup.menu=NULL;

    if ((e = CreateSubGadget(window,&create,&(num->popup),0x105)) != NULL) goto error;

    if (SWI_WimpCreateIcon == Wimp_PlotIcon) return NULL;

    menu.flags=1;
    menu.title= gadget_template->data.string_set.title;
    menu.max_title=string_length(gadget_template->data.string_set.title) +1 ;
    menu.max_help=gadget_template->hdr.max_help;
    menu.help_message=gadget_template->hdr.help_message;
    menu.num_entries=0;
    menu.show_event =0;
    menu.hide_event =0;

    DEBUG debug_output ("stringset", "Creating Menu title %s\n\r",menu.title);

    obj.total_size=sizeof(obj)+sizeof(menu);
    obj.body=(void *) &menu;
    obj.body_size=sizeof(menu);

    if (SWI_WimpCreateIcon == Wimp_CreateIcon) {
       CreateObjectFromMemory (&obj,& (num->menu_id));

       regs.r[0] = 0;
       regs.r[1] = (int)window;
       regs.r[2] = PopUp_SetMenu;
       regs.r[3] = num->popup;
       regs.r[4] = (int) num->menu_id;
       r2.r[4]=(int) &regs;
       if ((e = gadgets_method (&r2, CURRENT_WINDOW)) != NULL)
         goto error;

       DEBUG debug_output ("stringset", "Added Menu to popup\n\r");

       _set_available(num,gadget_template->data.string_set.string_set);
    }

    return NULL;

error:

    if (num != NULL) {
        if (num->value != NULL) {
          mem_free (num->value, "freeing string set value buffer");
        }
        mem_free (num, "freeing string set");
    }

    return e;
}

_kernel_oserror *string_set_method    (GadgetInternal *gadget,
                                        ObjectID window,
                                        _kernel_swi_regs *r)
{

  _kernel_swi_regs       *user_regs = USER_REGS (r) ;
  int                     method    = user_regs->r[2];
  stringset_internal *s        = (stringset_internal *) gadget->data ;

  window=window;

  DEBUG debug_output ("stringset", "stringset_method: entry\n\r") ;

  if (method == Gadget_SetHelpMessage)
  {
      (void) gadget_method(s->window_id, Gadget_SetHelpMessage, s->number, user_regs->r[4], 0);
      (void) gadget_method(s->window_id, Gadget_SetHelpMessage, s->popup, user_regs->r[4], 0);
      (void) _swix(Toolbox_ObjectMiscOp, _INR(0,3), 0, s->menu_id, Menu_SetHelpMessage, user_regs->r[4]);
  }
  else
  switch (method - StringSet_Base)
  {
    case (StringSet_SetAvailable -StringSet_Base):

        _set_available(s,(char *) (user_regs->r[4]));

        break;

    case (StringSet_SetSelected -StringSet_Base):
        if (user_regs->r[0] & 1)
           _set_entry_byindex(s,user_regs->r[4],gadget);
        else {
           _set_entry_bystring(s,(char *) user_regs->r[4],gadget);
           _set_displayfield (s,(char *) user_regs->r[4],gadget);
        }
        break;

    case (StringSet_GetSelected -StringSet_Base):
        if (user_regs->r[0] & 1)
           user_regs->r[0] = s->ticked;
        else
           string_to_buffer((char *) user_regs->r[4], s->value,&(user_regs->r[5]));
        break;

    case (StringSet_SetAllowable -StringSet_Base):
       if ((!(gadget->gadget_hdr.flags & StringSet_NoDisplay)) && (gadget->gadget_hdr.flags & StringSet_Writable)) {
           gadget_method(s->window_id,WritableField_SetAllowable,s->number,user_regs->r[4],0);
        }
        break;

    case (StringSet_GetAllowable -StringSet_Base):
       if ((!(gadget->gadget_hdr.flags & StringSet_NoDisplay)) && (gadget->gadget_hdr.flags & StringSet_Writable)) {
           gadget_method(s->window_id,WritableField_GetAllowable,s->number,user_regs->r[4],&(user_regs->r[5]));
        }
        break;

    case (StringSet_GetComponents - StringSet_Base):
      {
      int flags = user_regs->r[0];

      if (flags & 1) user_regs->r[0] = s->number;
      if (flags & 2) user_regs->r[1] = s->popup;

        }

        break;

    case (StringSet_SetFont - StringSet_Base):
      return _swix(Toolbox_ObjectMiscOp, _INR(0,6), 0, s->window_id,
       		(gadget->gadget_hdr.flags & StringSet_Writable) ?
       			WritableField_SetFont : DisplayField_SetFont,
       		s->number, user_regs->r[4], user_regs->r[5],
       		user_regs->r[6]);
      break;

    default:
        return (BadMethod(method));
        break;
   }

   return NULL;

}



_kernel_oserror *string_set_toolbox_event   (GadgetInternal *gadget,
                                                ToolboxEvent *event,
                                                ComponentID cid, ObjectID ob)
{
  _kernel_oserror *e;
 StringSetValueChangedEvent ev;
 int genevent =0;

 stringset_internal *ss = (stringset_internal *)gadget->data;

  DEBUG debug_output ("stringset", "String set got toolbox event: Cid %d, code %d\n\r",
                        cid, event->hdr.event_code) ;

  /* Handle menu selections */
  if (event->hdr.event_code == Menu_Selection && ob == ss->menu_id) {
     _set_entry_byindex(ss,cid,gadget);
     genevent =1;
  }

  /* Handle the writable field being edited */
  else if (event->hdr.event_code == WritableField_ValueChanged &&
           ob == ss->window_id && cid == ss->number) {
     WritableFieldValueChangedEvent *ev =(WritableFieldValueChangedEvent *) event;
     _set_entry_bystring(ss,ev->string,gadget);
     genevent =1;

  }

  /* Handle the popup being clicked on */
  else if (event->hdr.event_code == PopUp_AboutToBeShown &&
           ob == ss->window_id && cid == ss->popup &&
           gadget->gadget_hdr.flags & StringSet_GenerateAboutToBeShown) {
        StringSetAboutToBeShownEvent event;

          /* raise event, note we don't have to listen for this event as
             we've created the menu with 'GenerateMenuAboutToBeShown' which can
             only be delivered after this event goes out ! */

        event.hdr.flags=0;
        event.hdr.size       = sizeof (event) ;

        event.hdr.event_code = StringSet_AboutToBeShown;

        if ((e = gadgets_raise_event (ss->window_id, gadget->gadget_hdr.component_id, &event)) != NULL)
           return (e);
  }

  /* Send a StringSet_ValueChanged if necessary */
  if(genevent && (gadget->gadget_hdr.flags & StringSet_GenerateUserValueChanged)) {
        ev.hdr.event_code = StringSet_ValueChanged;

        if(strlen(ss->value) > (sizeof(ToolboxEvent)-sizeof(ToolboxEventHeader)-sizeof(int) -1)) {
           ev.hdr.size = sizeof(ToolboxEventHeader);
           ev.hdr.flags = StringSet_ValueChanged_TooLong;
        }
        else {
           strcpy(ev.string,ss->value);
           ev.hdr.flags =0;

                         /*  header size                 flags      <- string size ->    roundup */
           ev.hdr.size = (sizeof(ToolboxEventHeader) + sizeof(int) +1 + strlen(ss->value) +3) & ~3;

        }

        if ((e = gadgets_raise_event (ss->window_id, gadget->gadget_hdr.component_id, &ev)) != NULL)
           return (e);
   }

  return NULL;

}

_kernel_oserror *string_set_set_fade (GadgetInternal *gadget,
                                         ObjectID window,
                                         int do_fade)
{
  stringset_internal *ss = (stringset_internal *) gadget->data ;

  IGNORE (window);

  DEBUG debug_output ("fade", "stringset_set_fade: fade flag is %d\n\r", do_fade) ;

  if (ss->number)              gadgets_set_fade(ss->number,do_fade);
  if (ss->popup)               gadgets_set_fade(ss->popup,do_fade);

   return NULL;
}

_kernel_oserror *string_set_remove   (GadgetInternal *gadget, ObjectID window,int rec)
{
    stringset_internal *ss = (stringset_internal *) gadget->data;

    IGNORE (window);

    if (!(StringSet_NoDisplay & gadget->gadget_hdr.flags)) {
      gadgets_remove(ss->number,CURRENT_WINDOW,rec);
    }
    gadgets_remove(ss->popup,CURRENT_WINDOW,rec);

    if(ss->menu_id) toolbox_delete_object(0,ss->menu_id);

    if (ss->value) mem_free (ss->value, "stringset gadget value data");
    mem_free (ss, "removing stringset gadget data");

    return NULL;
}

_kernel_oserror *string_set_move     (GadgetInternal *gadget,
                                         ObjectID window,
                                         int window_handle,
                                         wimp_Bbox *box)
{
   /* resize 'number' gadget to new_xmin ... new_xmax -52
             'popup'         to new_xmax - 44 ... new_xmax */

   _kernel_swi_regs regs;
   _kernel_oserror *e     = NULL;
   wimp_Bbox new          = *box;
   stringset_internal *ss = (stringset_internal *)gadget->data;

   IGNORE (window_handle);

   regs.r[0] = 0;
   regs.r[1] = window;
   regs.r[2] = Gadget_MoveGadget;
   regs.r[4] = (int) &new;

   if (ss->number > 0) {
     regs.r[3] = (int) ss->number;
     new.xmax = new.xmax -52;
     e = _kernel_swi(Toolbox_ObjectMiscOp,&regs,&regs);

   }
   if (!e) {
     regs.r[3] = (int) ss->popup;
     new.xmin = box->xmax -44;
     new.xmax = box->xmax;
     new.ymin = (box->ymax + box->ymin) / 2 - 22;
     new.ymax = new.ymin + 44;
     e = _kernel_swi(Toolbox_ObjectMiscOp,&regs,&regs);

   }

   return e;
}

_kernel_oserror *string_set_set_focus (GadgetInternal *gadget, int window_handle, int dir)
{
    _kernel_swi_regs regs;
    stringset_internal *ss = (stringset_internal *)gadget->data;
    IGNORE(window_handle);

    if (gadget->gadget_hdr.flags & StringSet_Writable) {
            /* contains a writable */
    regs.r[0] = dir ? 1 :0;
    regs.r[1] = ss->window_id;
    regs.r[2] = Gadget_SetFocus;
    regs.r[3] = ss->number;
    return (_kernel_swi (Toolbox_ObjectMiscOp, &regs, &regs));

    }
    return NULL; /* not throwing an error */
}

@


4.6
log
@Merge change (singular!) from 4.02 sources.
StringSet_GetComponent was returning the menu_id not the popup.

Version 1.70. Tagged as 'Window-1_70'
@
text
@a32 1
#include "services.h"
d39 9
a47 9
#include "objects.toolbox.h"
#include "objects.window.h"
#include "objects.menu.h"

#include "^.globals.h"
#include "^.gadgets.h"
#include "^.object.h"
#include "^.veneers.h"
#include "^.utils.h"
@


4.5
log
@  set_stringset_available could cause mayhem and destruction if the
    string length to be set exceeded the length of the buffer in the
    gadget.
Detail:
  Conveniently, the stringset_internal data structure didn't contain
    a note of the buffer length and variously assumed it to be:
    a) at least 64 characters long.
    b) long enough
    These assumptions are no longer present and should avoid problems.
Admin:
  Fixed bugzilla bug #43
  Tested.

Version 1.66. Tagged as 'Window-1_66'
@
text
@d457 1
a457 1
      if (flags & 2) user_regs->r[1] = s->menu_id;
@


4.4
log
@  Setting gadget help messages now works on composite gadgets.
Detail:
  Gadget_SetHelpMessage methods issued to the Window module weren't being
  propagated down to sub-gadgets comprising a composite gadget.  Hence the
  new help message was never being shown.  New gadgets should be prepared to
  receive this method code through their private method handlers.  Existing
  gadgets will be OK so long as they reject unknown methods with no error OR
  with Window_NoSuchMiscOpMethod (which all the internal gadgets do).
Admin:
  Built and tested.  Attempted to set help texts on normal, external
  and composite gadgets, and they all worked as expected.

Version 1.58. Tagged as 'Window-1_58'
@
text
@d65 1
d186 1
a186 1
                                                    index, ss->value, 63)) != NULL)
d226 1
a226 1
    string_copy(ss->value,index);
d256 1
a256 2
    num = mem_allocate (gadget_template->data.string_set.max_selected_string_len +
            sizeof (stringset_internal), "stringset_add, stringset_internal type") ;
d260 7
a271 1
    num->value = ((char *) num) + sizeof (stringset_internal);
d386 4
a389 1
    if (num != NULL)
d391 1
d583 1
@


4.3
log
@Implenented StringSet_SetFont
@
text
@d399 7
@


4.2
log
@Spinner branch merged
@
text
@d446 8
@


4.1
log
@Initial revision
@
text
@d20 2
d70 2
a71 2
  _kernel_swi_regs      regs;
  _kernel_oserror *e=NULL;
a72 10
        regs.r[0] = 0;
        regs.r[1] = (int) menu_id;
        regs.r[2] = Menu_SetTick;
        regs.r[3] = (int) cid;
        regs.r[4] = 1;
        e = _kernel_swi (Toolbox_ObjectMiscOp, &regs, &regs);

        return e;
}
   
d87 1
a87 1
   }       
d93 1
a93 11
  _kernel_swi_regs      regs;
  _kernel_oserror *e=NULL;

        regs.r[0] = 0;
        regs.r[1] = (int) menu_id;
        regs.r[2] = Menu_SetTick;
        regs.r[3] = (int) cid;
        regs.r[4] = 0;
        _kernel_swi (Toolbox_ObjectMiscOp, &regs, &regs);

        return e;
d100 1
a100 1
 
a108 1
        _kernel_swi_regs regs;
d111 1
a111 1
        char buf[128];
d123 1
a123 5
                regs.r[0]=0;    /* flags */
                regs.r[1]=(int) ss->menu_id;
                regs.r[2]=Menu_RemoveEntry;
                regs.r[3]=e;
                _kernel_swi(Toolbox_ObjectMiscOp,&regs,&regs);
a149 5
                regs.r[0]=0;
                regs.r[1]=(int) ss->menu_id;
                regs.r[2]=Menu_AddEntry;
                regs.r[3]=e-1;            /* Add after last one, or -1 for first */
                regs.r[4]=(int) &entry;
d151 3
a153 1
                e++;
a154 1
                er=_kernel_swi(Toolbox_ObjectMiscOp,&regs,&regs);
a176 1
  _kernel_swi_regs      regs;
d182 1
a182 6
    regs.r[0]=0;
    regs.r[1]=(int) ss->menu_id;
    regs.r[2]=Menu_GetEntryText;
    regs.r[3]=(int) index;
    regs.r[4]=(int) ss->value;
    regs.r[5]= 63;
d184 2
a185 3
                /* if we get an error here then we've gone passed the end of the menu */

    if ((e = _kernel_swi (Toolbox_ObjectMiscOp, &regs, &regs)) != NULL)
d188 1
a188 1
                /* update display/writable field */
a199 1
  _kernel_swi_regs      regs;
a209 6
       regs.r[0]=0;
       regs.r[1]=(int) ss->menu_id;
       regs.r[2]=Menu_GetEntryText;
       regs.r[3]=(int) en;
       regs.r[4]=(int) buf;
       regs.r[5]= 128;
d211 1
a211 1
                   /* if we get an error here then we've gone passed the end of the menu */
d213 2
a214 1
       if ((e = _kernel_swi (Toolbox_ObjectMiscOp, &regs, &regs)) != NULL)
d333 1
a333 1
    create.hdr.xmin=gadget_template->hdr.xmax-52;
d335 2
d434 1
a434 1
                            
d470 2
a471 2
  if (ss->menu_id == ob) {
      /* ought to check that this is a menu selection */
d476 3
a478 1
  if (ss->number == cid) {
d485 4
a488 2
  if ((ss->popup == cid) && (ob == ss->window_id) &&
     (gadget->gadget_hdr.flags & StringSet_GenerateAboutToBeShown)) {
d504 1
d531 1
a531 1
                                         int do_fade) 
d555 1
a555 1
                            
d566 1
a566 1
                                         wimp_Bbox *box) 
d568 3
a570 3
   /* resize 'number' gadget to new_xmin ... new_xmax -60
             'popup'         to new_xmax - 52 ... new_xmax */
  
d572 1
a572 1
   _kernel_oserror *e     = NULL;    
d585 1
a585 1
     new.xmax = new.xmax -60;
d588 1
a588 1
   }                                                   
d591 1
a591 1
     new.xmin = box->xmax -52;
d593 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Added support for nested windows and showtypes 2 and 3 - centred and at pointer
@
text
@a19 2
 *          03-Feb-97: EPW: Increased stringset string length on menu items
 *                          from 128 to 512.
d130 1
a130 1
        char buf[512];
@


4.1.7.3
log
@Add "Extendable X and Extendable Y" toolbars.
Improve pane-handling algorithms.
Fix alignment of labels in labelled boxes.
Align numberrange's slider more neatly and put adjusters in right place
Stringsets tidied up
Some useful checking added to string_set_toolbox_event
Showing as subwindow fixed up a lot.
@
text
@d70 11
a80 1
   return _swix(Toolbox_ObjectMiscOp, _INR(0,4), 0, menu_id, Menu_SetTick, cid, 1);
d82 1
a82 1

d97 1
a97 1
   }
d103 11
a113 1
   return _swix(Toolbox_ObjectMiscOp, _INR(0,4), 0, menu_id, Menu_SetTick, cid, 0);
d120 1
a120 1

d129 1
d144 5
a148 1
                _swix(Toolbox_ObjectMiscOp, _INR(0,3), 0, ss->menu_id, Menu_RemoveEntry, e);
d175 5
d181 1
a181 3
                er=_swix(Toolbox_ObjectMiscOp, _INR(0,4), 0, ss->menu_id, Menu_AddEntry,
                                               (e++)-1, /* Add after last one, or -1 for first */
                                               &entry);
d183 1
d206 1
d212 6
a217 1
    /* if we get an error here then we've gone past the end of the menu */
d219 3
a221 2
    if ((e = _swix(Toolbox_ObjectMiscOp, _INR(0,5), 0, ss->menu_id, Menu_GetEntryText,
                                                    index, ss->value, 63)) != NULL)
d224 1
a224 1
    /* update display/writable field */
d236 1
d247 6
d254 1
a254 1
       /* if we get an error here then we've gone passed the end of the menu */
d256 1
a256 2
       if ((e = _swix(Toolbox_ObjectMiscOp, _INR(0,5), 0, ss->menu_id, Menu_GetEntryText,
                                                       en, buf, 128)) != NULL)
d375 1
a375 1
    create.hdr.xmin=gadget_template->hdr.xmax-44;
a376 2
    create.hdr.ymin=(gadget_template->hdr.ymin+gadget_template->hdr.ymax)/2-22;
    create.hdr.ymax=create.hdr.ymin+44;
d474 1
a474 1

d510 2
a511 2
  /* Handle menu selections */
  if (event->hdr.event_code == Menu_Selection && ob == ss->menu_id) {
d516 1
a516 3
  /* Handle the writable field being edited */
  else if (event->hdr.event_code == WritableField_ValueChanged &&
           ob == ss->window_id && cid == ss->number) {
d523 2
a524 4
  /* Handle the popup being clicked on */
  else if (event->hdr.event_code == PopUp_AboutToBeShown &&
           ob == ss->window_id && cid == ss->popup &&
           gadget->gadget_hdr.flags & StringSet_GenerateAboutToBeShown) {
a539 1
  /* Send a StringSet_ValueChanged if necessary */
d566 1
a566 1
                                         int do_fade)
d590 1
a590 1

d601 1
a601 1
                                         wimp_Bbox *box)
d603 3
a605 3
   /* resize 'number' gadget to new_xmin ... new_xmax -52
             'popup'         to new_xmax - 44 ... new_xmax */

d607 1
a607 1
   _kernel_oserror *e     = NULL;
d620 1
a620 1
     new.xmax = new.xmax -52;
d623 1
a623 1
   }
d626 1
a626 1
     new.xmin = box->xmax -44;
a627 2
     new.ymin = (box->ymax + box->ymin) / 2 - 22;
     new.ymax = new.ymin + 44;
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.13;
access;
symbols
	Toolbox-1_58:4.13
	Toolbox-1_57:4.13
	Toolbox-1_56:4.13
	Toolbox-1_55:4.12
	Toolbox-1_54:4.11
	Toolbox-1_53:4.11
	RO_5_07:4.11
	Toolbox-1_52:4.11
	Toolbox-1_51:4.10
	Toolbox-1_50:4.10
	Toolbox-1_49:4.9
	Toolbox-1_48:4.8
	Toolbox-1_47:4.7
	Toolbox-1_46:4.7
	mstphens_UrsulaRiscPCBuild_20Nov98:4.5
	sbrodie_Toolbox_Ursula_231198:4.6
	Ursula_RiscPC:4.5.0.4
	Toolbox-1_45:4.6
	Toolbox-1_44:4.5
	rthornb_UrsulaBuild-19Aug1998:4.5
	UrsulaBuild_FinalSoftload:4.5
	rthornb_UrsulaBuild-12Aug1998:4.5
	aglover_UrsulaBuild-05Aug1998:4.5
	rthornb_UrsulaBuild-29Jul1998:4.5
	rthornb_UrsulaBuild-22Jul1998:4.5
	rthornb_UrsulaBuild-15Jul1998:4.5
	rthornb_UrsulaBuild-07Jul1998:4.5
	rthornb_UrsulaBuild-17Jun1998:4.5
	Ursula_bp:4.5
	Ursula:4.5.0.2
	Toolbox-1_43:4.5
	sbrodie_Toolbox_dev:4.4.0.4
	sbrodie_Toolbox_dev_bp:4.4
	Toolbox-1_42:4.4
	rthornb_UrsulaBuild-03Jun1998:4.4
	rthornb_UrsulaBuild-27May1998:4.4
	rthornb_UrsulaBuild-21May1998:4.4
	Ursula_12May1998:4.2.0.4
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Daytona:4.2.0.2
	Daytona_bp:4.2
	sbrodie_Expresso_final_190298:4.4
	sbrodie_Toolbox_1_40:4.4
	sbrodie_Expresso_BETA6_19980204:4.4
	sbrodie_Toolbox_1_38:4.3
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spin_merge_8Jul97:4.1.7.1
	Ursula_bp_8Jul97:4.2
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Spin_merge_13May97:4.1.7.1
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1.2.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2015.08.18.21.54.54;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	LoNyVfxnoIUlBNxy;

4.12
date	2014.07.26.20.50.57;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	4kgjygW8uK7HIVJx;

4.11
date	2003.01.17.16.11.09;	author bavison;	state Exp;
branches;
next	4.10;

4.10
date	2001.10.04.14.10.17;	author srevill;	state Exp;
branches;
next	4.9;

4.9
date	2000.05.04.12.56.57;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	99.04.28.11.20.08;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.01.18.12.32.02;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	98.10.30.16.09.13;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	98.06.16.13.05.59;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	98.02.04.19.49.28;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.01.16.10.33.26;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.07.15.08.50;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.23.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.23.10;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.45.46;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.17.41;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.41.25;	author nturton;	state Exp;
branches
	4.1.7.1.2.1;
next	;

4.1.7.1.2.1
date	97.04.22.14.32.27;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Makefile recreated from fragments
Include paths changed to Unix style.
Debug and non debug CMHG definitions replaced by one which is selected by passing predefines to CMHG.
Removed dummy services.h.
Don't bother calling TinyStubs SWI since in ROM it does nothing, and the RAM versions haven't used it since ~1997.
Use module header constants generated from CMHG rather than hand made one.
Reject out of range SWIs (fixes ticket #305).
Move structure document into Docs directory.
Get module base from AsmUtils.

Version 1.56. Tagged as 'Toolbox-1_56'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* File:    task.c
 * Purpose: tasks running under the Toolbox
 * Author:  Ian Johnson
 * History: 9-Sep-93:  IDJ:   created
 *          15-Jun-94: IDJ:   fixed confusion over null msg list, and msg list with just 0 in it
 *                            (now reflects wimp behaviour)
 *          21-Jun-94: IDJ:   deliver Quit message even if not asked for.
 *          29-Jul-94: IDJ:   make sure error is reported if occurs while loading a res file.
 *                            (used to just say Could not load resource file).
 *          21-Nov-94: IDJ:   bug-fix AQU-00071 (task_exit).
 *          23-nov-94: IDJ:   bug fix AQU-00591: check for invalid reason code
 *          22-Dec-94: IDJ:   use string_length on dir name not strlen.
 *
 */

#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "Global/FSNumbers.h"
#include "Global/Services.h"

#include "const.h"
#include "macros.h"
#include "debug.h"
#include "mem.h"
#include "string32.h"
#include "messages.h"

#include "globals.h"
#include "callback.h"
#include "task.h"


#define SPRITES11


static TaskDescriptor *task__list;    /* the list of all tasks */

static char           *prefilter_name = "tbox_pre";      /* names of the filters.  These are globals */
static char           *postfilter_name = "tbox_post";    /* so that the same register contents are   */
                                                         /* passed to the registration and           */
                                                         /* deregistration filter SWIs.  Not that    */
                                                         /* code area string constants are not good  */
                                                         /* enough! */


/**************************************** linked list of tasks handling *****************************/

static void task__add_to_list (TaskDescriptor *t)
{
    /*
     * Function to add an element to the list of tasks
     * (add to head of list)
     */

    t->next = task__list;
    t->prev = NULL;
    if (task__list != NULL)
        task__list->prev = t;
    task__list = t;
}


static void task__remove_from_list (TaskDescriptor *t)
{
    /*
     * Function to remove a given task descriptor from the active list
     */

    DEBUG mem_chk(t, CHECK_HEAP | CHECK_NONZERO);

    if (t == task__list)
        task__list = t->next;
    else
        t->prev->next = t->next;

    if (t->next != NULL)
        t->next->prev = t->prev;

}


static void task__delete (TaskDescriptor *t)
{
    /*
     * Function to delete a task descriptor (inc remove it from the list)
     * All store associated with this task is freed.
     */

    _kernel_swi_regs regs;

    DEBUG mem_chk(t, CHECK_HEAP | CHECK_NONZERO);

    /*
     * first free up store used to hold task info which task.c knows about
     */

    if (t->info.name != NULL)
        mem_free (t->info.name, "removing task name");

    if (t->info.dir_name != NULL)
        mem_free (t->info.dir_name, "removing dir name");

    if (t->info.sprite_area != NULL && t->info.sprite_area != (void *)1 &&
        !t->info.sprite_area_in_resourcefs)
        mem_free (t->info.sprite_area, "removing sprite area");

    if (t->toolbox_event_list != NULL)
        mem_free (t->toolbox_event_list, "removing toolbox event list");

    if (t->wimp_msg_list != NULL)
        mem_free (t->wimp_msg_list, "removing wimp msg list");

    object_remove_list ();

    resf_remove_list ();

    filters_remove_list ();


    /*
     * remove main pre and postfilters for this task
     */

    regs.r[0] = (int)prefilter_name;
    regs.r[1] = (int)&prefilter_veneer;
    regs.r[2] = (int)t;
    regs.r[3] = t->info.wimp_handle;
    _kernel_swi (Filter_DeRegisterPreFilter, &regs, &regs);

    regs.r[0] = (int)postfilter_name;
    regs.r[1] = (int)&postfilter_veneer;
    regs.r[2] = (int)t;
    regs.r[3] = t->info.wimp_handle;
    regs.r[4] = 0;
    _kernel_swi (Filter_DeRegisterPostFilter, &regs, &regs);


    /*
     * close the task's messages file for it
     */

    _swix (MessageTrans_CloseFile, _IN(0), &t->info.messages_fd);
    if (t->info.messages_name != NULL)
        mem_free (t->info.messages_name, "removing messages name");

    /*
     * ... and finally remove the task descriptor
     */

    task__remove_from_list (t);

    mem_free (t, "removing task descriptor");

    mem_print_list();
}


/********************************************** client SWIs *****************************************/

extern _kernel_oserror *task_get_sys_info (_kernel_swi_regs *r)
{

    /*
     *   Entry:
     *         R0  =  flags
     *
     *         R0 Value       Meaning
     *         --------       -------
     *             0          return task name
     *             1          return 4-word messages file descriptor
     *             2          return name of directory passed to
     *                        Toolbox_Initialise
     *             3          return task's Wimp task handle
     *             4          return pointer to sprite area used.
     *
     *         R1, R2 depends on entry value of R0 (see below)
     *
     *   Exit:
     *         R0 on entry      On exit
     *         -----------      -------
     *              0           if R1 was 0
     *                              R2 holds size of buffer required
     *                          else
     *                              buffer pointed at by R1 holds task
     *                              name.
     *              1           buffer pointed at by R1 contains a
     *                          4-word messages file descriptor.
     *              2           if R1 was 0
     *                              R2 holds size of buffer required
     *                          else
     *                              buffer pointed at by R1 holds
     *                              directory name passed to
     *                              Toolbox_Initialise.
     *              3           R0 contains task handle.
     *              4           R0 contains sprite area pointer.
     *
     */

    DEBUG mem_chk(r, CHECK_NONZERO);

    switch (r->r[0])
    {
        case Toolbox_GetSysInfo_TaskName:
            string_to_buffer ((char *)r->r[1], task->info.name, &r->r[2]);
            break;

        case Toolbox_GetSysInfo_DirName:
            {
                int reqd;

                reqd = string_length (task->info.dir_name) + 1 /* terminator */;
                if (task->info.dir_name_was_dir) reqd--; /* un pathify */
                if (r->r[1] == 0)
                {
                    r->r[2] = reqd; /* override string_to_buffer's view of length */
                    return NULL;
                }
                r->r[2] = MIN (reqd, r->r[2]);
                string_to_buffer ((char *)r->r[1], task->info.dir_name, &r->r[2]);
            }
            break;

        case Toolbox_GetSysInfo_MessagesFD:
            if (r->r[1] != 0)
            {
                /*
                 * return message file descriptor block in buffer pointed at by R1
                 */

                memcpy ((void *)r->r[1], (void *)task->info.messages_fd, 4*sizeof(int));
            }
            break;

        case Toolbox_GetSysInfo_TaskHandle:
            r->r[0] = task->info.wimp_handle;
            break;

        case Toolbox_GetSysInfo_SpriteArea:
            r->r[0] = (int)task->info.sprite_area;

            DEBUG debug_output ("sprite", "T:Returning sprite area %p\n", task->info.sprite_area);
            break;

        default:
            /* bug fix AQU-00591: IDJ: 23-Nov-94: check for invalid reason code */
            return make_error (Toolbox_BadGetSysInfoReason, 0);
    }

    return NULL;
}

static _kernel_oserror *task__load_messages_file (TaskDescriptor *t, _kernel_swi_regs *r)
{

    /*
     * Function to load a sibling Messages file.  Tries <app$dir>.Message<territorynumber>
     * first, then <app$dir>.Messages
     */

    char             filename[MAXFILENAME];
    _kernel_oserror *e = NULL;
    int              territory = 0;
    int              pass;

    for (pass = 0; pass < 2; pass++)
    {
        switch (pass)
        {
            /*
             * First pass - read territory number and try Message<n>
             */
          case 0:
            if (_swix(Territory_Number, _OUT(0), &territory) != NULL)
                continue;
            sprintf(filename, "%sMessage%d", t->info.dir_name, territory);
            break;
            /*
             * Second pass - try Messages
             */
          case 1:
            sprintf(filename, "%sMessages", t->info.dir_name);
            break;
        }

        /*
         * Need to keep filename in RMA so MessageTrans can refer to it later
         */
        t->info.messages_name = mem_allocate(string_length(filename)+1, "messages name");
        if (t->info.messages_name == NULL)
            return make_error(Toolbox_NoMem, 0);
        string_copy(t->info.messages_name, filename);

        DEBUG debug_output ("start", "T:Trying messages file %s\n", t->info.messages_name);

        e = _swix(MessageTrans_OpenFile, _INR(0,2), t->info.messages_fd, t->info.messages_name, 0);
        if (e) {
            DEBUG debug_output("start", "T:error -> %s\n", e->errmess);
            mem_free(t->info.messages_name, "removing messages name");
            t->info.messages_name = NULL;
        }
        else {
            break;
        }
    }

    if (e)
        return e;

    /* return messages file descriptor to caller */
    if (r->r[5] != 0)
        memcpy ((void *)r->r[5], t->info.messages_fd, sizeof(t->info.messages_fd));

    DEBUG debug_output ("start", " writing messages fd @@%p \n", (void *)r->r[5]);

    return NULL;
}


static _kernel_oserror *task__start_wimp_task (TaskDescriptor *t, _kernel_swi_regs *r, int*wimp_version)
{

    /*
     * Function to start up as a Wimp task.  The wimp version number is returned
     * and the task's wimp task handle is stored in the task descriptor
     */

    char            *appname;
    _kernel_swi_regs regs;
    _kernel_oserror *e;
    int              events[2];

    /* look up task name */
    regs.r[0] = (int)t->info.messages_fd;
    regs.r[1] = (int)"_TaskName";
    regs.r[2] = 0;                  /* use looked up message in-place */
    regs.r[3] = 0;
    regs.r[4] = 0;
    regs.r[5] = 0;
    regs.r[6] = 0;
    regs.r[7] = 0;
    if ((e = _kernel_swi (MessageTrans_Lookup, &regs, &regs)) != NULL)
    {
        return e;
    }
    appname = (char *)regs.r[2];

    if ((t->info.name = (char *)mem_allocate (string_length(appname)+1, "task name")) == NULL)
        return make_error (Toolbox_NoMem, 0);

    string_copy (t->info.name, appname);

    DEBUG debug_output ("start", "T:Start Wimp task %s", appname);

    /* initialise as Wimp task */
    regs.r[0] = r->r[1];
    regs.r[1] = 0x4b534154;    /*'TASK'*/
    regs.r[2] = (int)appname;
    regs.r[3] = r->r[2];
    if ((e = _kernel_swi (Wimp_Initialise, &regs, &regs)) != NULL)
        return e;

    t->info.wimp_handle = regs.r[1];
    *wimp_version       = regs.r[0];


    /*
     * a client must always get wimp_MTOOLBOX_EVENT, so that Toolbox_RaiseToolboxEvent works
     */

    if (!(t->wimp_msg_list != NULL && t->wimp_msg_list[0] == 0))
    {
        events[0] = wimp_MTOOLBOX_EVENT;
        events[1] = 0;
        regs.r[0] = (int)events;
        if ((e = _kernel_swi (Wimp_AddMessages, &regs, &regs)) != NULL)
            return e;
    }

    return NULL;
}


static _kernel_oserror *task__try_sprite_load (TaskDescriptor *t, char *filename, BOOL *report_error)
{
    /*
     * Function to try to load a given sprites file.  This function
     * allocates a block of memory big enough and init's it as a sprite
     * area
     */

    _kernel_oserror *e = NULL;
    int              area_len;
    int             *sprite_area;
    int              file_handle;
    int              object_type;
    int              file_length;
    int              internal_handle;
    int              filing_system;

    *report_error = FALSE;

    DEBUG debug_output ("start", "T:Try sprite load %s\n", filename);

    /* read catalogue info for the file */
    if ((e = _swix (OS_File, _INR(0,1)|_OUT(0)|_OUT(4), 17, filename, &object_type, &file_length)) != NULL)
    {
        *report_error = TRUE;
        return e;
    }

    DEBUG debug_output ("start", "T:Read catalogue info\n");

    if (object_type != 1)    /* file not found */
    {
        *report_error = FALSE;
        return make_error (Toolbox_NoMem, 0);
    }

    /* Check to see if it's in ResourceFS */
    if ((e = _swix (OS_Find, _INR(0,1)|_OUT(0), 0x4F, filename, &file_handle)) != NULL)
    {
        *report_error = TRUE;
        return e;
    }

    e = _swix (OS_FSControl, _INR(0,1)|_OUTR(1,2), 21, file_handle, &internal_handle, &filing_system);

    _swix (OS_Find, _INR(0,1), 0, file_handle); /* close the file */

    if (e)
    {
        *report_error = TRUE;
        return e;
    }

    if ((filing_system & 0xFF) == fsnumber_resourcefs)
    {
        sprite_area = (int *)internal_handle - 1; /* take a direct pointer */
        t->info.sprite_area_in_resourcefs = 1;
    }
    else
    {
        area_len = file_length + sizeof(int);   /* area is file contents plus length word */

        if ((sprite_area = (int *)mem_allocate (area_len, "sprite area")) == NULL)
        {
            *report_error = TRUE;
            return make_error (Toolbox_NoMem, 0);
        }

        /* initialise the sprite area */
        sprite_area[0] = area_len;
        sprite_area[1] = 0;
        sprite_area[2] = 16;
        sprite_area[3] = 16;

        /* load the sprites file */
        if ((e = _swix(OS_SpriteOp, _INR(0,2), 10 + 256, sprite_area, filename)) != NULL)
        {
            *report_error = TRUE;
            return e;
        }
        t->info.sprite_area_in_resourcefs = 0;
    }

    /* record the sprite area pointer */
    t->info.sprite_area = (void *)sprite_area;

    return NULL;
}


static _kernel_oserror *task__load_sprites_file (TaskDescriptor *t)
{

    /*
     * Function to load a sibling sprites file.  First tries
     * <app$dir>.Sprites<mode> then <app$dir>.Sprites
     */

    char             filename[MAXFILENAME];
    const char      *suffix = "";
    int              modeflags = 0;
    _kernel_oserror *e;
    BOOL             report_error = FALSE;

#ifdef SPRITES11
    
    int              bufferspace = 0;
    
    /* Read the mode flags - we're interested in bit 8 */
    _swix (OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 0, &modeflags);
    
    /* First time, check if the Wimp supports Wimp_Extend 13 */
    if (modeflags & 0x100)
    {
        sprintf (filename, "%sTvSprs", t->info.dir_name);
    }
    else
    {
        sprintf (filename, "%s<Wimp$IconTheme>Sprites", t->info.dir_name);
    }
    
    e = _swix (Wimp_Extend, _INR(0,3)|_OUT(3), 13, filename, filename, MAXFILENAME, &bufferspace);
    
    if (bufferspace != MAXFILENAME) /* Wimp_Extend 13 is supported */
    {
        if (e && (modeflags & 0x100))
        {
            sprintf (filename, "%s<Wimp$IconTheme>Sprites", t->info.dir_name);
            
            e = _swix (Wimp_Extend, _INR(0,3), 13, filename, filename, MAXFILENAME);
        }
        
        if (e)
        {
            sprintf (filename, "%sSprites", t->info.dir_name);
            
            e = _swix (Wimp_Extend, _INR(0,3), 13, filename, filename, MAXFILENAME);
        }
        
        if (!e)
        {
            e = task__try_sprite_load (t, filename, &report_error);
            
            if (!e || report_error == TRUE)
                return e;
        }
    }
    
    else /* Wimp_Extend 13 is not supported, fall back to old code */
    {
#endif

    /*
     * try: 1) TVSprs<suffix>   (only if mode flag 8 (interlaced) is set)
     *      2) Sprites<suffix>
     *      3) TVSprs           (only if mode flag 8 is set)
     *      4) Sprites
     */

    /* read mode-dependent suffix string */
    _swix (Wimp_ReadSysInfo, _IN(0)|_OUT(0), 2, &suffix);

#ifndef SPRITES11
    /* read the mode flags - we're interested in bit 8 */
    _swix (OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 0, &modeflags);
#endif

    if (suffix[0])
    {
        if (modeflags & 0x100)
        {
            sprintf (filename, "%sTVSprs%s", t->info.dir_name, suffix);

            e = task__try_sprite_load (t, filename, &report_error);

            if (!e || report_error == TRUE)
                return e;
        }

        sprintf (filename, "%sSprites%s", t->info.dir_name, suffix);

        e = task__try_sprite_load (t, filename, &report_error);

        if (!e || report_error == TRUE)
            return e;
    }

    if (modeflags & 0x100)
    {
        sprintf (filename, "%sTVSprs", t->info.dir_name);

        e = task__try_sprite_load (t, filename, &report_error);

        if (!e || report_error == TRUE)
            return e;
    }

    sprintf (filename, "%sSprites", t->info.dir_name);

    e = task__try_sprite_load (t, filename, &report_error);

    if (!e || report_error == TRUE)
        return e;

#ifdef SPRITES11
    }
#endif

    return NULL;
}


static _kernel_oserror *task__load_resource_file (TaskDescriptor *t)
{

    /*
     * Function to load sibling resources file. No errors if the Res file is missing.
     */

    char             filename[MAXFILENAME];
    _kernel_swi_regs regs;
    int              pass, territory = 0, modeflags = 0;

    _swix(Territory_Number, _OUT(0), &territory);
    _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 0, &modeflags);

    for (pass = 0; pass < 4; pass++)
    {
        switch (pass)
        {
            /*
             * First pass - read territory number and try TVRes<n> (if interlaced)
             */
          case 0:
            if (!(modeflags & 0x100)) continue;
            if (!territory) continue;
            sprintf(filename, "%sTVRes%d", t->info.dir_name, territory);
            break;

            /*
             * Second pass - read territory number and try Res<n>
             */
          case 1:
            if (!territory) continue;
            sprintf(filename, "%sRes%d", t->info.dir_name, territory);
            break;

            /*
             * Third pass - try TVRes (if interlaced)
             */
          case 2:
            if (!(modeflags & 0x100)) continue;
            sprintf(filename, "%sTVRes", t->info.dir_name);
            break;

            /*
             * Fourth pass - try Res
             */
          case 3:
            sprintf(filename, "%sRes", t->info.dir_name);
            break;
        }

        /*
         * first need to see if file exists (so we know whether to return file load
         * errors.
         */

        regs.r[0] = 17;   /* no path */
        regs.r[1] = (int)filename;
        _kernel_swi (OS_File, &regs, &regs);
        if (regs.r[0] == 1)
        {
            /*
             * now try to load res file
             */

            regs.r[0] = 0;
            regs.r[1] = (int)filename;
            return resf_load_resource_file (&regs);
        }
    }

    return NULL;
}


static _kernel_oserror *task__register_filters (TaskDescriptor *t)
{

    /*
     * Function to add pre- and postfilters for the current task.  This task's
     * descriptor will be passed to the filter veneers in R12.  The veneers will
     * use this value to set up static data relocations.
     */

    _kernel_swi_regs regs;
    _kernel_oserror *e = NULL;


    /*
     * add another pre-filter to the chain (nb this is not the list maintained
     * by filters.c, which refers to filters registered using
     * Toolbox_RegisterPreFilter)
     */

    regs.r[0] = (int)prefilter_name;
    regs.r[1] = (int)&prefilter_veneer;
    regs.r[2] = (int)t;
    regs.r[3] = t->info.wimp_handle;
    e = _kernel_swi (Filter_RegisterPreFilter, &regs, &regs);


    /*
     * add another post-filter to the chain (nb this is not the list maintained
     * by filters.c, which refers to filters registered using
     * Toolbox_RegisterPostFilter)
     */

    regs.r[0] = (int)postfilter_name;
    regs.r[1] = (int)&postfilter_veneer;
    regs.r[2] = (int)t;
    regs.r[3] = t->info.wimp_handle;
    regs.r[4] = 0;                     /* get all events which the task gets */
    e = _kernel_swi (Filter_RegisterPostFilter, &regs, &regs);

    return e;
}


extern _kernel_oserror *task_filtermgr_restarting (void)
{
    TaskDescriptor  *t = task__list;
    _kernel_oserror *e;

    /*
     * filter mgr is re-starting, so we must re-register all of our pre-
     * and post-filters
     */

    while (t != NULL)
    {
        if ((e = task__register_filters (t)) != NULL)
            return e;

        t = t->next;
    }

    return NULL;
}



extern _kernel_oserror *task_initialise (_kernel_swi_regs *r)
{

    /*
     *   Entry:
     *         R0  =  flags
     *         R1  =  last Wimp version number known to task * 100
     *                (must be >= 310)
     *         R2  -> list of Wimp message numbers which the client wishes
     *                to receive, terminated by a 0 word.
     *                If R2 = 0, then all messages are delivered.
     *                If R2 points to just a 0 word, then no messages are
     *                delivered (apart from the Quit message).
     *         R3  -> list of Toolbox Event codes which the client wishes
     *                to receive, terminated by a 0 word.
     *                If R3 = 0, then all Toolbox Events are delivered.
     *                If R3 points to just a 0 word, then no Toolbox Events
     *                are delivered.
     *         R4  -> Directory name or path with which we find our resources.
     *         R5  -> 4-word buffer to receive messages file descriptor.
     *         R6  -> buffer to hold Object ids on return from Wimp_Poll.
     *
     *   Exit:
     *         R0 = current Wimp version number * 100
     *         R1 = Wimp task handle for this client
     *         R2 = Pointer to Sprite area used.
     *         Buffer pointed to by R5 is filled in with a MessageTrans
     *         file descriptor for the messages file to be used.
     *
     */

    _kernel_oserror        *e;
    TaskDescriptor         *new_task = NULL;
    int                     wimp_version;
    int                    *p, *q;
    int                     len;
    _kernel_swi_regs        regs;

    DEBUG debug_output ("start", "T:New task starting! (0x%x 0x%x 0x%x)\n", r->r[0], r->r[2], r->r[3]);

    /*
     * check parameters
     */

    if (r->r[4] == 0)
        return make_error (Toolbox_NoDirName, 0);

    if (r->r[5] == 0)
        return make_error (Toolbox_NoMsgsFD, 0);

    if (r->r[6] == 0)
        return make_error (Toolbox_NoIDBlock, 0);

    /*
     * create a new Task descriptor, add it to the list of tasks, and make it the current task
     */

    if ((new_task = mem_allocate (sizeof(TaskDescriptor), "task descriptor")) == NULL)
        return make_error (Toolbox_NoMem, 0);

    len = string_length((char *)r->r[4]);
    if ((new_task->info.dir_name = mem_allocate (len+2, "dir name")) == NULL)
        return make_error (Toolbox_NoMem, 0);
    string_copy (new_task->info.dir_name, (char *)r->r[4]);
    new_task->info.dir_name_was_dir = FALSE;
    if (new_task->info.dir_name[len-1] != ':')
    {
        /* the caller has given a directory (rather than a path), append a dot
         * so all the subsequent uses can treat everything as though a path
         */
        strcat (new_task->info.dir_name, ".");
        new_task->info.dir_name_was_dir = TRUE;
    }

    new_task->id_block = (IDBlock *)r->r[6];    /* id block filled in on Wimp_Poll */

    new_task->pw = private_word;                /* remember Toolbox's private word in task descriptor */

    new_task->info.sprite_area = (void *)1;     /* default to wimp sprite area */

    task__add_to_list (new_task);

    task = new_task;                            /* this is now the current task */


    /*
     * remember the lists of wimp messages, and toolbox events which the client wishes to receive
     */

    p = (int *)r->r[2];   /* list of wimp message numbers */

    if (p != NULL)
    {
        while (*p++ != 0)
            ;

        if ((task->wimp_msg_list = mem_allocate (sizeof(int)*(p-(int *)r->r[2]), "wimp msg list")) == NULL)
        {
            e = make_error (Toolbox_NoMem, 0);
            goto error;
        }

        p = (int *)r->r[2];
        q = task->wimp_msg_list;

        while ((*q++ = *p++) != 0)
            ;
    }
    else
        task->wimp_msg_list = NULL;

    DEBUG { q = task->wimp_msg_list;
            do
            {
                debug_output ("start", "T:msg 0x%x\n", *q);
            } while (*q++ != 0);
            debug_output ("start", "T:\n");
          }


    p = (int *)r->r[3];   /* list of toolbox events */

    if (p != NULL)
    {
        while (*p++ != 0)
            ;

        if ((task->toolbox_event_list = mem_allocate (sizeof(int)*(p-(int *)r->r[3]), "toolbox event list")) == NULL)
        {
            e = make_error (Toolbox_NoMem, 0);
            goto error;
        }

        p = (int *)r->r[3];
        q = task->toolbox_event_list;

        while ((*q++ = *p++) != 0)
            ;
    }
    else
        task->toolbox_event_list = NULL;

    DEBUG { q = task->toolbox_event_list;
            do
            {
                debug_output ("start", "T:event 0x%x\n", *q);
            } while (*q++ != 0);
            debug_output ("start", "T:\n");
          }

    /*
     * load and register messages file with MessageTrans and store descriptor
     * first try <app$dir>.Messages, then Message<CountryNumber>
     * Messages file is loaded into RMA by the MessageTrans module
     */

    if ((e = task__load_messages_file (new_task, r)) != NULL)
        goto error;


    /*
     * start up as a Wimp task, and store the task handle.
     */

    if ((e = task__start_wimp_task (new_task, r, &wimp_version)) != NULL)
        goto error;


    /*
     * issue service call to inform Object modules that a new client has started up
     */

    regs.r[0] = new_task->info.wimp_handle;
    regs.r[1] = Service_ToolboxTaskBorn;
    regs.r[2] = (int) new_task;
    _kernel_swi (OS_ServiceCall, &regs, &regs);


    /*
     * if a sprites file is there, then load it and store the area pointer
     */

    if ((e = task__load_sprites_file (new_task)) != NULL)
        goto error2;


    /*
     * try to load the resources file.  Try "res", then try "res<countrynumber>"
     */

    if ((e = task__load_resource_file (new_task)) != NULL)
        goto error2;


    /*
     * register pre- and post-filters for this task
     */

    if ((e = task__register_filters (new_task)) != NULL)
        goto error2;


    /*
     * set up return registers
     */

    r->r[0] = wimp_version;
    r->r[1] = new_task->info.wimp_handle;
    r->r[2] = (int)new_task->info.sprite_area;

    mem_print_list();

    return NULL;


error2:
    regs.r[0] = new_task->info.wimp_handle;
    regs.r[1] = Service_ToolboxTaskDied;
    _kernel_swi (OS_ServiceCall, &regs, &regs);
error:
    task__delete(new_task);
    return e;
}



/************************************** task manipulation functions ********************************/


extern BOOL task_any_active (void)
{
    return task__list != NULL;
}

extern BOOL task_expected_wimp_message (int action)
{
    int *p = task->wimp_msg_list;

    if (action == 0)
        return TRUE;

    if (p == NULL)
        return FALSE;

    if (*p == 0)
        return TRUE;    /* null list means all msgs delivered */

    while (*p != 0)
    {
        if (*p == action)
            return TRUE;
        p++;
    }

    return FALSE;
}


extern BOOL task_expected_toolbox_event (int event_code)
{
    int *p = task->toolbox_event_list;

    if (p == NULL)
        return FALSE;

    if (*p == 0)
        return TRUE;    /* null list means all events delivered */

    while (*p != 0)
    {
        if (*p == event_code)
            return TRUE;
        p++;

    }

    return FALSE;
}


extern TaskDescriptor *task_find (int task_handle)
{

    /*
     * Function to return a TaskDescriptor corresponding to
     * a task with a given Wimp handle
     */

    TaskDescriptor *t;

    t = task__list;

    while (t != NULL)
    {
        if (t->info.wimp_handle == task_handle)
            break;

        t = t->next;
    }

    return t;
}


extern void task_exit (TaskDescriptor *t)
{
    /*
     * Delete task descriptor.
     */

    DEBUG debug_output ("exit", "Task died %p (0x%x)\n", (void *)t, t->info.wimp_handle);

    task__delete (t);

    if (t == task)
        task = NULL;  /* IDJ: 21-Nov-94: bug-fix AQU-00071: reset task swapped in */
}


/* This function fixed in Toolbox 1.38 to issue N service calls, one per task, instead of N
 * service calls all for the same task.
 *
 * 'task' must be set to the handle of the task being announced because the Object modules
 * will set pre-filters/post-filters etc. and we need to ensure that task is correct for
 * those to succeed.
 */
extern void task_inform_object_modules (void)
{
    DEBUG debug_output ("inform", "Informing object modules\n");

    if (task__list != NULL) {
        (void) _swix(OS_AddCallBack, _INR(0,1), task_inform_callback_handler, private_word);
    }
}


extern void task_inform_object_modules_callback (void);
extern void task_inform_object_modules_callback (void)
{
    TaskDescriptor  *t = task__list, *const current_task = task;

    DEBUG debug_output ("inform", "Informing object modules: callback executing\n");

    while (t != NULL)
    {
        task = t;
        DEBUG debug_output ("inform", "Informing object modules: task %08x\n", (int) t);
        (void) _swix(OS_ServiceCall, _INR(0,2), t->info.wimp_handle, Service_ToolboxTaskBorn, t);
        t = t->next;
    }

    /* Restore current setting of task after issuing the service calls */
    task = current_task;
}

#if debugging
extern _kernel_oserror *task_list(void)
{
    	TaskDescriptor  *t = task__list;

    	for (; t; t = t->next) {
            	object_t *o;
        	printf("Task `%s'\n", t->info.name);
		for (o = t->object_list; o; o = o->next) {
		        static char buf[256];
		        int len;
		        _swix(OS_SWINumberToString, _INR(0,2)|_OUT(0), o->header.class_id, buf, sizeof(buf), &len);
		        printf("  %#08x %02x %06x (%.*s)\n", o->header.class_id,
		        	o->reference_count >> 24, o->reference_count & ~0xFF000000,
		        	len, buf);
		}
        }

    	return NULL;
}
#endif
@


4.12
log
@Fix for asymmetry in Toolbox_GetSysInfo 2
The enhancement in 1.50 to allow tasks to initialise with either a path variable or a directory meant that internally everything is considered as a path.
However, Toolbox_GetSysInfo 2 is specified as returning the "directory name passed to Toolbox_Initialise", except that now a directory is stored in its modified (path-like) form internally, so doesn't read back as expected.
Add boolean flag to remember that the dir was changed to a path so it can be knocked off again if appropriate.
Remove some excess #includes.

Tested with the following for path=FALSE and path=TRUE

DIM poll 256,block 16,dirbuf 128
IF path THEN
 *set MyTest$Path $.!Boot.RO500Hook.Res.Configure.!HelpSetup.
 SYS"Toolbox_Initialise",0,380,0,0,"MyTest:",block,poll TO ,id%
ELSE
 SYS"Toolbox_Initialise",0,380,0,0,"$.!Boot.RO500Hook.Res.Configure.!HelpSetup",block,poll TO ,id%
ENDIF
PRINT "Task ";~id%
SYS"Toolbox_GetSysInfo",2 TO,,r2
PRINT "Want buffer ";r2;" long"
SYS"Toolbox_GetSysInfo",2,dirbuf,128 TO,,r2
SYS"XOS_GenerateError",dirbuf TO dir$
PRINT dir$;" is ";r2;" long (inc terminator), check ";LEN(dir$)+1

Version 1.55. Tagged as 'Toolbox-1_55'
@
text
@d35 1
a42 1
#include "services.h"
@


4.11
log
@Added support for Sprites11 files (ie uses Wimp_Extend 13 to work out
suffix for Sprites files) and the Wimp$IconTheme prefix.

Version 1.52. Tagged as 'Toolbox-1_52'
@
text
@a30 1
#include <stdlib.h>
d34 1
a37 1
#include "services.h"
a39 1
#include "twimp.h"
d42 1
a42 1
#include "objects.toolbox.h"
a44 5
#include "services.h"

#include "resf.h"
#include "filters.h"
#include "object.h"
a45 1

a216 5
    /* bug fix AQU-00591: IDJ: 23-Nov-94: check for invalid reason code */

    if (r->r[0] < 0 || r->r[0] > Toolbox_GetSysInfo_SpriteArea)
        return make_error (Toolbox_BadGetSysInfoReason, 0);

d220 3
d225 1
a225 1
                char *src = (r->r[0] == Toolbox_GetSysInfo_TaskName)?task->info.name:task->info.dir_name;
d227 9
a235 1
                string_to_buffer ((char *)r->r[1], src, &r->r[2]);
d261 2
a262 1
            break;
d452 1
a452 1
    if ((filing_system & 0xFF) == 46)
d816 1
d819 5
a823 1
        strcat(new_task->info.dir_name, ".");
@


4.10
log
@  Modified Toolbox_Initialise SWI slightly.
Detail:
  You can now pass a path from which to locate your resources to the
  Toolbox_Initialise SWI, as well as simply a directory. This does not
  affect backwards-compatibility and means that newer software can use
  this rather than the "MyPath:a.^" pathname trick.

  Also fixed the !Mk* TaskObey files so that they actually work.
Admin:
  Tested on RiscPC with existing Toolbox applications (i.e. Phoenix and
  others) and new ones using paths to specify the location of their
  resources.

Version 1.50. Tagged as 'Toolbox-1_50'
@
text
@d57 3
d504 48
d562 1
d565 1
d603 4
@


4.9
log
@  Changed to use common Makefile system.
  Debug build facility added.
Detail:
  Uses core facilities from Common instead of having private copies.
  Makefile vastly simplified to simply define a few macros, then include
    the common Toolbox Makefile which is exported by Common.
Admin:
  Requires Common 0.09 or later (RiscOS/Sources/Toolbox/Common; Common-0_09)
  Requires BuildSys 1.92 or later (RiscOS/BuildSys; BuildSys-1_92)
  Requires Library 0.41 or later (RiscOS/Library; Library-0_41)

Version 1.49. Tagged as 'Toolbox-1_49'
@
text
@d289 1
a289 1
            sprintf(filename, "%s.Message%d", (char *)r->r[4], territory);
d295 1
a295 1
            sprintf(filename, "%s.Messages", (char *)r->r[4]);
d518 1
a518 1
            sprintf (filename, "%s.TVSprs%s", t->info.dir_name, suffix);
d526 1
a526 1
        sprintf (filename, "%s.Sprites%s", t->info.dir_name, suffix);
d536 1
a536 1
        sprintf (filename, "%s.TVSprs", t->info.dir_name);
d544 1
a544 1
    sprintf (filename, "%s.Sprites", t->info.dir_name);
d579 1
a579 1
            sprintf(filename, "%s.TVRes%d", t->info.dir_name, territory);
d587 1
a587 1
            sprintf(filename, "%s.Res%d", t->info.dir_name, territory);
d595 1
a595 1
            sprintf(filename, "%s.TVRes", t->info.dir_name);
d602 1
a602 1
            sprintf(filename, "%s.Res", t->info.dir_name);
d714 1
a714 1
     *         R4  -> Directory name in which to find resources.
d731 1
d756 2
a757 1
    if ((new_task->info.dir_name = mem_allocate (string_length((char *)r->r[4])+1, "dir name")) == NULL)
d760 4
@


4.8
log
@Changed to allow TV-specific Sprites and Res files. If bit 8 of the mode flags
is set (ie interlaced), then it will try the files TVSprs<nn>, TVSprs,
TVRes<n> and TVRes, in addition to the usual files.

Version 1.48. Tagged as 'Toolbox-1_48'
@
text
@a498 1
    _kernel_swi_regs regs;
d859 1
d1051 2
a1052 2
		        _swix(OS_SWINumberToString, _INR(0,2)|_OUT(0), o->header.class, buf, sizeof(buf), &len);
		        printf("  %#08x %02x %06x (%.*s)\n", o->header.class,
@


4.7
log
@  Updated ToolboxObjectDeletedEvent structure to hold class and client handle.
Detail:
  Currently, there is no way of ascertaining the client handle that used to
    belong to a deleted object.  Thus applications cannot rely on this event
    to close down any associated data structures referenced via the client
    handle.  This event now provides the client handle and the class ID of
    the deleted object as per the structure and flags exported by Toolboxlib.
  Debug builds now have an extra *-command "*Toolbox_Counts" which dumps out
    the name of each active Toolbox task and a list of the objects that that
    task has created and what class each object is (it simply does a name
    lookup on the class ID (SWI base) and prints out the SWI name - so you
    get Window_ClassSWI for window objects and DCS_16 for quit objects)
Admin:
  Requires RiscOS/Sources/Toolbox/Common version 0.01 or later (Common-0_01).
  Requires RiscOS/Sources/Toolbox/Libs version 0.02 or later (Libs-0_02).


Version 1.46. Tagged as 'Toolbox-1_46'
@
text
@a494 1
    char             base_filename[MAXFILENAME];
d496 2
a501 3
    sprintf (base_filename, "%s.Sprites", t->info.dir_name);
    strcpy  (filename, base_filename);

d503 4
a506 1
     * try using Sprites<suffix> first, then Sprites
d509 17
a525 3
    regs.r[0] = 2;  /* read mode-dependent suffix string */
    if ((e = _kernel_swi (Wimp_ReadSysInfo, &regs, &regs)) == NULL)
        strcat (filename, (char *)regs.r[0]);
d527 17
a543 1
    e = task__try_sprite_load (t, filename, &report_error);
d545 1
a545 2
    if (report_error == TRUE)
        return e;
d547 1
a547 5
    /* IDJ: bug-fix AQU-00328: 6-Jan-95 only try sprites file if
       sprites file with suffix failed
     */
    if (e)
        e = task__try_sprite_load (t, base_filename, &report_error);
d549 1
a549 1
    if (report_error == TRUE)
d560 1
a560 2
     * Function to load sibling resources file.  First tries <app$dir>.Res<territorynumber>
     * then <app$dir>.Res. No errors if the Res file is missing.
d565 4
a568 1
    int              pass, territory;
d570 1
a570 1
    for (pass = 0; pass < 2; pass++)
d575 1
a575 1
             * First pass - read territory number and try Res<n>
d578 10
a587 2
            if (_swix(Territory_Number, _OUT(0), &territory) != NULL)
                continue;
d592 1
a592 1
             * Second pass - try Res
d594 10
a603 2
          case 1:
            sprintf (filename, "%s.Res", t->info.dir_name);
@


4.6
log
@Will access a task's Sprites file directly if in ResourceFS.

Version 1.45. Tagged as 'Toolbox-1_45'
@
text
@d995 22
@


4.5
log
@New null pointer check added to make sure that the Toolbox module no
longer data aborts if the application's Messages file cannot be found.

Version 1.43. Tagged as 'Toolbox-1_43'
@
text
@d124 2
a125 1
    if (t->info.sprite_area != NULL && t->info.sprite_area != (void *)1)
a404 1
    _kernel_swi_regs regs;
d408 5
d419 1
a419 3
    regs.r[0] = 17;     /* no path */
    regs.r[1] = (int)filename;
    if ((e = _kernel_swi (OS_File, &regs, &regs)) != NULL)
d427 1
a427 1
    if (regs.r[0] != 1)    /* file not found */
d433 2
a434 3
    area_len = regs.r[4] + sizeof(int);   /* area is file contents plus length word */

    if ((sprite_area = (int *)mem_allocate (area_len, "sprite area")) == NULL)
d437 1
a437 1
        return make_error (Toolbox_NoMem, 0);
d440 5
a444 11
    /* initialise the sprite area */
    sprite_area[0] = area_len;
    sprite_area[1] = 0;
    sprite_area[2] = 16;
    sprite_area[3] = 16;

    /* load the sprites file */
    regs.r[0] = 10 + 256;              /* load in user area */
    regs.r[1] = (int)sprite_area;
    regs.r[2] = (int)filename;
    if ((e = _kernel_swi (OS_SpriteOp, &regs, &regs)) != NULL)
d448 30
@


4.4
log
@Build process improvements:
  !MkRam,fd7 added to enable RAM builds of all Toolbox modules
  MakeFile tidied up and support for RAM build added
Module now uses Toolbox memory allocation instead of calling OS_Module.
@
text
@d163 2
a164 1
    mem_free (t->info.messages_name, "removing messages name");
d304 1
a304 1
        strcpy(t->info.messages_name, filename);
d309 2
a310 1
        if (e)
d312 3
a314 1
        else
d316 1
@


4.3
log
@Service_ToolboxTaskBorn issued once for each task instead of multiple times for
the same task when new object modules register.
@
text
@d793 1
a793 1
        goto error;
d801 1
a801 1
        goto error;
d809 1
a809 1
        goto error;
d825 4
@


4.2
log
@ARTtmp branch folded in
@
text
@d925 10
a934 1
static int task__block_for_callback[3];
d936 4
a939 7
/*
 * Here we install a callback handler to send Service_TaskBorn for each
 * active task.  The global variable "task" must get set so that each
 * task becomes, in turn, the "current" task, since object modules
 * will call register_prefilter/postfilter SWIs as a result of
 * receiving the service call (clear?)
 */
d942 2
a943 1
extern void task_inform_object_modules (void)
d945 1
a945 2
    TaskDescriptor  *t = task__list;
    _kernel_swi_regs regs;
d947 1
a947 1
    DEBUG debug_output ("inform", "Informing object modules\n");
d951 3
a953 7
        task__block_for_callback[0] = t->info.wimp_handle;      /* wimp task handle */
        task__block_for_callback[1] = (int)&task;               /* address of "task" variable */
        task__block_for_callback[2] = (int)t;                   /* value to put in "task" */
        regs.r[0] = (int)&task_inform_callback_handler;
        regs.r[1] = (int)&task__block_for_callback;
        _kernel_swi (OS_AddCallBack, &regs, &regs);

d956 3
@


4.1
log
@Initial revision
@
text
@d25 1
a25 1
 *          23-nov-94: IDJ:   bug fix AQU-00591: check for invalid reason code 
d91 1
a91 1
       
d99 1
a99 1
    
d114 1
a114 1
    /* 
d126 2
a127 2
  
    if (t->toolbox_event_list != NULL)  
d130 1
a130 1
    if (t->wimp_msg_list != NULL)  
d143 1
a143 1
    
d162 2
a163 3
    regs.r[0] = (int)&t->info.messages_fd;
    _kernel_swi (MessageTrans_CloseFile, &regs, &regs);

d211 1
a211 1
     *                              directory name passed to 
d239 1
a239 1
                /* 
a263 1

d268 2
a269 2
     * Function to load a sibling Messages file.  Tries <app$dir>.Messages
     * first, then <app$dir>.Message<countrynumber>
a272 1
    _kernel_swi_regs regs;
d274 2
d277 1
a277 10
    sprintf (filename, "%s.Messages", (char *)r->r[4]);

    DEBUG debug_output ("start", "T:Loading messages file %s", filename);

    regs.r[0] = (int)t->info.messages_fd;
    regs.r[1] = (int)filename;
    regs.r[2] = 0;                  /* hold file data in RMA */
    e = _kernel_swi (MessageTrans_OpenFile, &regs, &regs);

    if (e != 0)
d279 17
a295 10
        /*
         * read country number
         */
        int country = 0;

        regs.r[0] = 240;
        regs.r[1] = 0;
        regs.r[2] = 255;
        _kernel_swi (OS_Byte, &regs, &regs);
        country = regs.r[1];
d298 1
a298 1
         * try again with country number
d300 13
a312 1
        sprintf (filename, "%s.Message%d", (char *)r->r[4], country);
d314 2
a315 1
        DEBUG debug_output ("start", "%d", country);
a316 9
        regs.r[0] = (int)t->info.messages_fd;
        regs.r[1] = (int)filename;
        regs.r[2] = 0;                  /* hold file data in RMA */
        if ((e = _kernel_swi (MessageTrans_OpenFile, &regs, &regs)) != NULL)
        {
            return e;
        }
    }
   
d319 1
a319 1
        memcpy ((void *)r->r[5], (void *)t->info.messages_fd, 4*sizeof(int));
d328 1
a328 1
{ 
d330 1
a330 1
    /* 
d334 1
a334 1
    
d398 1
a398 1
                       
d451 1
a451 1
    
d466 1
a466 1
    _kernel_oserror *e; 
d485 1
a485 1
        
d494 1
a494 1
   
d503 2
a504 2
     * Function to load sibling resources file.  First tries <app$dir>.res
     * then <app$dir>.res<countrynumber>
d509 1
a509 15
    _kernel_oserror *e = NULL;
    BOOL             base_res_file_exists = FALSE, country_res_file_exists = FALSE;

    sprintf (filename, "%s.res", t->info.dir_name);

    /*
     * first need to see if file exists (so we know whether to return file load
     * errors.
     */

    regs.r[0] = 17;   /* no path */
    regs.r[1] = (int)filename;
    _kernel_swi (OS_File, &regs, &regs);
    if (regs.r[0] == 1)
        base_res_file_exists = TRUE;
d511 1
a511 16
    /*
     * now try to load res file
     */

    regs.r[0] = 0;
    regs.r[1] = (int)filename;
    e = resf_load_resource_file (&regs);

    /* base file exists and there was an error loading it, so report it */

    if (e != 0 && base_res_file_exists)
        return e;

    /* no base file, so try res<country number> */

    if (e != 0)
d513 10
a522 11
        /*
         * read country number
         */

        int country = 0;

        regs.r[0] = 240;
        regs.r[1] = 0;
        regs.r[2] = 255;
        _kernel_swi (OS_Byte, &regs, &regs);
        country = regs.r[1];
d524 7
a530 6

        /*
         * try again with country number
         */

        sprintf (filename, "%s.res%d", t->info.dir_name, country);
a540 5
            country_res_file_exists = TRUE;

        regs.r[0] = 0;
        regs.r[1] = (int)filename;
        if ((e = resf_load_resource_file (&regs)) != NULL)
d542 7
a548 2
            if (base_res_file_exists || country_res_file_exists)
                return e;
d551 1
a551 1
   
d597 2
a598 2
 
   
d610 1
a610 1
    {               
d615 1
a615 1
    } 
d621 1
a621 1
     
d630 1
a630 1
     *         R2  -> list of Wimp message numbers which the client wishes 
d692 1
a692 1
                     
d696 1
a696 1
    /* 
d706 1
a706 1
         
d718 1
a718 1
    } 
d722 2
a723 2
    DEBUG { q = task->wimp_msg_list; 
            do 
d727 1
a727 1
            debug_output ("start", "T:\n"); 
d729 1
a729 1
   
d737 1
a737 1
         
d749 1
a749 1
    } 
d751 4
a754 4
        task->toolbox_event_list = NULL; 
  
    DEBUG { q = task->toolbox_event_list; 
            do 
d758 1
a758 1
            debug_output ("start", "T:\n"); 
d771 1
a771 1
    /* 
d782 1
a782 1
 
d813 1
a813 1
     * set up return registers 
d889 1
a889 1
    /* 
d913 1
a913 1
     * Delete task descriptor.  
d917 1
a917 1
        
d923 1
a923 1
                    
d942 1
a942 1
  
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.1.2.1
log
@Ensured that filename passed to MessageTrans_OpenFile is stored in RMA.
Made the Toolbox look for Res<territory> then Res, rather than Res then
Res<country>. Ditto for Messages.
@
text
@d25 1
a25 1
 *          23-nov-94: IDJ:   bug fix AQU-00591: check for invalid reason code
d91 1
a91 1

d99 1
a99 1

d114 1
a114 1
    /*
d126 2
a127 2

    if (t->toolbox_event_list != NULL)
d130 1
a130 1
    if (t->wimp_msg_list != NULL)
d143 1
a143 1

d162 3
a164 2
    _swix (MessageTrans_CloseFile, _IN(0), &t->info.messages_fd);
    mem_free (t->info.messages_name, "removing messages name");
d212 1
a212 1
     *                              directory name passed to
d240 1
a240 1
                /*
d265 1
d270 2
a271 2
     * Function to load a sibling Messages file.  Tries <app$dir>.Message<territorynumber>
     * first, then <app$dir>.Messages
d275 1
a276 2
    int              territory = 0;
    int              pass;
d278 10
a287 1
    for (pass = 0; pass < 2; pass++)
d289 10
a298 17
        switch (pass)
        {
            /*
             * First pass - read territory number and try Message<n>
             */
          case 0:
            if (_swix(Territory_Number, _OUT(0), &territory) != NULL)
                continue;
            sprintf(filename, "%s.Message%d", (char *)r->r[4], territory);
            break;
            /*
             * Second pass - try Messages
             */
          case 1:
            sprintf(filename, "%s.Messages", (char *)r->r[4]);
            break;
        }
d301 1
a301 1
         * Need to keep filename in RMA so MessageTrans can refer to it later
d303 1
a303 13
        t->info.messages_name = mem_allocate(string_length(filename)+1, "messages name");
        if (t->info.messages_name == NULL)
            return make_error(Toolbox_NoMem, 0);
        strcpy(t->info.messages_name, filename);

        DEBUG debug_output ("start", "T:Trying messages file %s\n", t->info.messages_name);

        e = _swix(MessageTrans_OpenFile, _INR(0,2), t->info.messages_fd, t->info.messages_name, 0);
        if (e)
            mem_free(t->info.messages_name, "removing messages name");
        else
            break;
    }
d305 1
a305 2
    if (e)
        return e;
d307 9
d318 1
a318 1
        memcpy ((void *)r->r[5], t->info.messages_fd, sizeof(t->info.messages_fd));
d327 1
a327 1
{
d329 1
a329 1
    /*
d333 1
a333 1

d397 1
a397 1

d450 1
a450 1

d465 1
a465 1
    _kernel_oserror *e;
d484 1
a484 1

d493 1
a493 1

d502 2
a503 2
     * Function to load sibling resources file.  First tries <app$dir>.Res<territorynumber>
     * then <app$dir>.Res. No errors if the Res file is missing.
d508 15
a522 1
    int              pass, territory;
d524 16
a539 1
    for (pass = 0; pass < 2; pass++)
d541 16
a556 10
        switch (pass)
        {
            /*
             * First pass - read territory number and try Res<n>
             */
          case 0:
            if (_swix(Territory_Number, _OUT(0), &territory) != NULL)
                continue;
            sprintf(filename, "%s.Res%d", t->info.dir_name, territory);
            break;
d558 1
a558 7
            /*
             * Second pass - try Res
             */
          case 1:
            sprintf (filename, "%s.Res", t->info.dir_name);
            break;
        }
d569 5
d575 2
a576 7
            /*
             * now try to load res file
             */

            regs.r[0] = 0;
            regs.r[1] = (int)filename;
            return resf_load_resource_file (&regs);
d579 1
a579 1

d625 2
a626 2


d638 1
a638 1
    {
d643 1
a643 1
    }
d649 1
a649 1

d658 1
a658 1
     *         R2  -> list of Wimp message numbers which the client wishes
d720 1
a720 1

d724 1
a724 1
    /*
d734 1
a734 1

d746 1
a746 1
    }
d750 2
a751 2
    DEBUG { q = task->wimp_msg_list;
            do
d755 1
a755 1
            debug_output ("start", "T:\n");
d757 1
a757 1

d765 1
a765 1

d777 1
a777 1
    }
d779 4
a782 4
        task->toolbox_event_list = NULL;

    DEBUG { q = task->toolbox_event_list;
            do
d786 1
a786 1
            debug_output ("start", "T:\n");
d799 1
a799 1
    /*
d810 1
a810 1

d841 1
a841 1
     * set up return registers
d917 1
a917 1
    /*
d941 1
a941 1
     * Delete task descriptor.
d945 1
a945 1

d951 1
a951 1

d970 1
a970 1

@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

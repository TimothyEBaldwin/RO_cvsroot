head	4.10;
access;
symbols
	Toolbox-1_58:4.10
	Toolbox-1_57:4.10
	Toolbox-1_56:4.10
	Toolbox-1_55:4.9
	Toolbox-1_54:4.9
	Toolbox-1_53:4.9
	RO_5_07:4.9
	Toolbox-1_52:4.9
	Toolbox-1_51:4.9
	Toolbox-1_50:4.9
	Toolbox-1_49:4.9
	Toolbox-1_48:4.8
	Toolbox-1_47:4.8
	Toolbox-1_46:4.8
	mstphens_UrsulaRiscPCBuild_20Nov98:4.7
	sbrodie_Toolbox_Ursula_231198:4.7
	Ursula_RiscPC:4.7.0.6
	Toolbox-1_45:4.7
	Toolbox-1_44:4.7
	rthornb_UrsulaBuild-19Aug1998:4.7
	UrsulaBuild_FinalSoftload:4.7
	rthornb_UrsulaBuild-12Aug1998:4.7
	aglover_UrsulaBuild-05Aug1998:4.7
	rthornb_UrsulaBuild-29Jul1998:4.7
	rthornb_UrsulaBuild-22Jul1998:4.7
	rthornb_UrsulaBuild-15Jul1998:4.7
	rthornb_UrsulaBuild-07Jul1998:4.7
	rthornb_UrsulaBuild-17Jun1998:4.7
	Ursula_bp:4.7
	Ursula:4.7.0.4
	Toolbox-1_43:4.7
	sbrodie_Toolbox_dev:4.7.0.2
	sbrodie_Toolbox_dev_bp:4.7
	Toolbox-1_42:4.7
	rthornb_UrsulaBuild-03Jun1998:4.6
	rthornb_UrsulaBuild-27May1998:4.6
	rthornb_UrsulaBuild-21May1998:4.6
	Ursula_12May1998:4.3.0.4
	rthornb_UrsulaBuild_01May1998:4.3
	afrost_NC2_Generic:4.1.7.1
	Daytona:4.3.0.2
	Daytona_bp:4.3
	sbrodie_Expresso_final_190298:4.6
	sbrodie_Toolbox_1_40:4.6
	sbrodie_Expresso_BETA6_19980204:4.5
	sbrodie_Toolbox_1_38:4.4
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spin_merge_8Jul97:4.1.7.1
	Ursula_bp_8Jul97:4.2
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Spin_merge_13May97:4.1.7.1
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1.2.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2015.08.18.21.54.53;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	LoNyVfxnoIUlBNxy;

4.9
date	2000.05.04.12.56.57;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	99.01.18.12.31.59;	author sbrodie;	state Exp;
branches;
next	4.7;

4.7
date	98.06.11.11.56.23;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	98.02.11.18.16.44;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	98.02.04.19.49.24;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	98.01.16.10.33.25;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	97.07.08.10.14.00;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.07.15.08.49;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.23.09;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.05.19.15.53.50;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.23.09;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.45.42;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.17.37;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.41.22;	author nturton;	state Exp;
branches
	4.1.7.1.2.1;
next	;

4.1.7.1.2.1
date	97.04.22.14.32.26;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Makefile recreated from fragments
Include paths changed to Unix style.
Debug and non debug CMHG definitions replaced by one which is selected by passing predefines to CMHG.
Removed dummy services.h.
Don't bother calling TinyStubs SWI since in ROM it does nothing, and the RAM versions haven't used it since ~1997.
Use module header constants generated from CMHG rather than hand made one.
Reject out of range SWIs (fixes ticket #305).
Move structure document into Docs directory.
Get module base from AsmUtils.

Version 1.56. Tagged as 'Toolbox-1_56'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Title:   main.c
 * Purpose: main module of the Toolbox
 * Author:  IDJ
 * History: 21-Jul-93: IDJ: created
 *          26-Jul-94: IDJ: added Service_ToolboxStarting/TaskDied
 *          24-Jan-95: IDJ: don't send round Toolbox_Starting svc call, when started up
 *                          from ROM start-up sequence.
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "Global/Services.h"
#include "AsmUtils/rminfo.h"

#include "const.h"
#include "macros.h"
#include "debug.h"
#include "mem.h"
#include "messages.h"
#include "rmensure.h"
#include "objects.toolbox.h"
#include "objmodule.h"

#include "globals.h"

#include "object.h"
#include "task.h"
#include "resf.h"
#include "event.h"
#include "filters.h"
#include "callback.h"
#include "memory.h"

#include "ToolboxHdr.h"


#define MAX_SWIS 64

/* --- array of Toolbox SWIs (64 entries) --- */

static _kernel_oserror *(*swis [MAX_SWIS])(_kernel_swi_regs *r)  =
        {
          /* --- client SWIs --- */
          object_create,                  /* Toolbox_SWIChunkBase + 0  */
          object_delete,                  /* Toolbox_SWIChunkBase + 1  */
          NULL,                           /* Toolbox_SWIChunkBase + 2  */
          object_show,                    /* Toolbox_SWIChunkBase + 3  */
          object_hide,                    /* Toolbox_SWIChunkBase + 4  */
          object_get_state,               /* Toolbox_SWIChunkBase + 5  */
          object_miscop,                  /* Toolbox_SWIChunkBase + 6  */
          object_set_client_handle,       /* Toolbox_SWIChunkBase + 7  */
          object_get_client_handle,       /* Toolbox_SWIChunkBase + 8  */
          object_get_class,               /* Toolbox_SWIChunkBase + 9  */
          object_get_parent,              /* Toolbox_SWIChunkBase + 10 */
          object_get_ancestor,            /* Toolbox_SWIChunkBase + 11 */
          object_get_template_name,       /* Toolbox_SWIChunkBase + 12 */
          event_raise_toolbox_event,      /* Toolbox_SWIChunkBase + 13 */
          task_get_sys_info,              /* Toolbox_SWIChunkBase + 14 */
          task_initialise,                /* Toolbox_SWIChunkBase + 15 */
          resf_load_resource_file,        /* Toolbox_SWIChunkBase + 16 */

          /* --- unused --- */
          NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
          NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
          NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
          NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

          /* --- memory management SWIs --- */
          toolbox_memory_swi,

          /* --- object class SWIs --- */
          object_deregister_module,      /* Toolbox_SWIChunkBase + 58 */
          resf_template_lookup,          /* Toolbox_SWIChunkBase + 59 */
          object_get_internal_handle,    /* Toolbox_SWIChunkBase + 60 */
          object_register_module,        /* Toolbox_SWIChunkBase + 61 */
          filters_register_prefilter,    /* Toolbox_SWIChunkBase + 62 */
          filters_register_postfilter    /* Toolbox_SWIChunkBase + 63 */
        };

/* +++++++++++++++++++++++++++++++++ finalisation code +++++++++++++++++++++++++++++++++ */

#ifdef ROM
static int ROM_started = 0;
#else
extern int Resources(void);
#endif

extern _kernel_oserror *Toolbox_finalise (int fatal, int podule, void *pw)
{
    _kernel_oserror *e;

    IGNORE(fatal);
    IGNORE(podule);
    IGNORE(pw);

    /*
     * if tasks are active or modules registered, refuse to die
     */

    if (task_any_active())
    {
        e = make_error (Toolbox_TasksActive, 0);
        DEBUG debug_output ("finalise", "T:failed to finalise %s\n", e->errmess);
        return e;
    }


    /*
     * clean up before module exit
     */

    /*
     * close the Toolbox messages file
     */

    messages_file_close();


#ifndef ROM
    /*
     * ... and deregister from ResourceFS
     */

    objmodule_deregister_resources(Resources());
#endif

    /*
     * free up all memory that we may have left allocated!
     */

    mem_free_all ();

    (void) memory_finalise();

    _swix (OS_ServiceCall, _INR(0,1), 0, Service_ToolboxDying);

    return NULL;
}


/* ++++++++++++++++++++++++++++++++ initialisation code +++++++++++++++++++++++++++++++ */

extern _kernel_oserror *Toolbox_init(const char *cmd_tail, int podule_base, void *pw)
{
    _kernel_oserror *e;

    IGNORE(cmd_tail);
    IGNORE(podule_base);

    /* Inform the memory system that we want it to call our SWIs regardless of
     * any memory allocation strategy auto-discovery tricks.
     */
    mem_i_am_the_toolbox ();

    /*
     * store value of private word, so that we can use it when creating a new
     * task descriptor.  This value is then read, in pre and postfilters.
     */

    DEBUG debug_set_var_name("Toolbox$Debug");
    DEBUG debug_output ("init", "T:Toolbox init\n");

    /*
     * we need the new filter manager which passes on claimed events to
     * other filters
     */

    if ((e = rmensure ("FilterManager", "FilterMgr", "0.09")) != NULL)
        return e;

    private_word = pw;

    if ((e = memory_initialise()) != NULL)
        return e;


#ifndef ROM
    /*
     * register our resources with ResourceFS
     */

    if ((e = objmodule_register_resources(Resources())) != NULL)
        return e;
#endif


    /*
     * register our messages file with MessageTrans (assumes messages module loaded)
     */

    objmodule_ensure_path("Toolbox$Path", "Resources:$.Resources.Toolbox.");

    if ((e = messages_file_open("Toolbox:Messages")) != NULL)
        goto error1;


    /*
     * register callback handler to send round Service_ToolboxStarting after
     * we have init'ed OK.
     */

#ifdef ROM
    _swix(OS_AddCallBack, _INR(0,1), &toolbox_starting_callback_handler, &ROM_started);
#else
    _swix(OS_AddCallBack, _INR(0,1), &toolbox_starting_callback_handler, 0);
#endif

    return NULL;

error1:
#ifndef ROM
    objmodule_deregister_resources(Resources());
#endif

    return e;
}



/* +++++++++++++++++++++++++++++++++ service handler code ++++++++++++++++++++++++++++++ */


extern void Toolbox_services(int service_number, _kernel_swi_regs *r, void *pw)
{
    _kernel_swi_regs regs;

    IGNORE(pw);

    DEBUG debug_output ("services", "T:Service call %d\n", r->r[1]);

    /* look at mode change, and maybe reload sprites for that mode */

    if (service_number == Service_Memory && r->r[2] == (int)Image_RO_Base)
    {
       /* wimp is trying to map out app space - don't let it !*/
       /* r2 holds CAO pointer */
       r->r[1] = 0;  /* don't map out app space */
    }
    else if (service_number == Service_WimpCloseDown)
    {
        TaskDescriptor *t;

        /* task dying - r2 holds task handle */
        if ((t = task_find (r->r[2])) != NULL)
        {
            task = t;

            regs.r[0] = r->r[2];
            regs.r[1] = Service_ToolboxTaskDied;
            _kernel_swi (OS_ServiceCall, &regs, &regs);

            task_exit (t);
        }
    }
    else if (service_number == Service_FilterManagerInstalled)
    {
        task_filtermgr_restarting();
    }
    else if (service_number == Service_DynamicAreaRenumber)
    {
        memory_renumber_da(r->r[2], r->r[3]);
    }
#ifdef ROM
    else if (service_number == Service_PostInit)
    {
        ROM_started = 1;
    }
#endif
}

/* ++++++++++++++++++++++++++++++++++++++ SWI code +++++++++++++++++++++++++++++++++++++ */


extern _kernel_oserror *Toolbox_SWI_handler(int swi_no, _kernel_swi_regs *r, void *pw)
{
    _kernel_oserror *e = NULL;

    IGNORE(pw);

    DEBUG debug_output ("SWIs", "T:Toolbox SWI %d\n", swi_no);

    /*
     * We disallow "object" SWIs and get_sys_info for non-toolbox tasks)
     */

    if (task == NULL && (swi_no < Toolbox_GetTemplateName - Toolbox_SWIChunkBase ||
                         swi_no == Toolbox_GetSysInfo - Toolbox_SWIChunkBase))
        return make_error (Toolbox_NotaToolboxTask, 0);


    /*
     * despatch the swi, reporting out of range errors
     */

    if (swi_no > MAX_SWIS || swis[swi_no] == NULL) {
        e = error_BAD_SWI;
    }
    else {
        e = (*swis[swi_no])(r);
    }

    DEBUG debug_output ("SWIs", "T:Exit Toolbox SWI %d --> %s\n", swi_no,e?e->errmess:"<No Error>");

    return e;
}


/* ++++++++++++++++++++++++++++++++++++++ star commands ++++++++++++++++++++++++++++++++++++*/

#if debugging
extern _kernel_oserror *Toolbox_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
    IGNORE(argc);
    IGNORE(pw);
    IGNORE(arg_string);

    switch (cmd_no)
    {
        case CMD_Toolbox_Memory:
            mem_print_list();
            break;

	case CMD_Toolbox_Counts:
	    task_list();
	    break;

        default:
            break;
    }

    return NULL;
}
#endif
@


4.9
log
@  Changed to use common Makefile system.
  Debug build facility added.
Detail:
  Uses core facilities from Common instead of having private copies.
  Makefile vastly simplified to simply define a few macros, then include
    the common Toolbox Makefile which is exported by Common.
Admin:
  Requires Common 0.09 or later (RiscOS/Sources/Toolbox/Common; Common-0_09)
  Requires BuildSys 1.92 or later (RiscOS/BuildSys; BuildSys-1_92)
  Requires Library 0.41 or later (RiscOS/Library; Library-0_41)

Version 1.49. Tagged as 'Toolbox-1_49'
@
text
@d31 2
a35 1
#include "services.h"
a43 1
#include "services.h"
d53 1
a53 1
#include "main.h"
a101 1
static _kernel_oserror *__ROM;
d104 1
a104 1
extern int messages_file(void);
d143 1
a143 1
    objmodule_deregister_resources(messages_file());
a155 4
#ifdef ROM
    if(!__ROM) _swix(0x82c41, 0);
#endif

d162 1
a162 1
extern _kernel_oserror *Toolbox_init(char *cmd_tail, int podule_base, void *pw)
a168 4
#ifdef ROM
    __ROM = _swix(0x82c43, _IN(0), pw);
#endif

d201 1
a201 1
    if ((e = objmodule_register_resources(messages_file())) != NULL)
d231 1
a231 1
    objmodule_deregister_resources(messages_file());
d252 1
a252 1
    if (service_number == Service_Memory && r->r[2] == (int)Image__RO_Base)
d315 1
a315 3
        e = make_error_hex (Toolbox_BadSWI, 1, swi_no + Toolbox_SWIChunkBase);
        e->errnum = 0x1e6;
        return e;
d317 1
a317 1
    else
d319 1
a319 1

d330 1
a330 1
extern _kernel_oserror *Toolbox_commands(char *arg_string, int argc, int cmd_no, void *pw)
d338 1
a338 1
        case 0:
d342 1
a342 1
	case 1:
@


4.8
log
@  Updated ToolboxObjectDeletedEvent structure to hold class and client handle.
Detail:
  Currently, there is no way of ascertaining the client handle that used to
    belong to a deleted object.  Thus applications cannot rely on this event
    to close down any associated data structures referenced via the client
    handle.  This event now provides the client handle and the class ID of
    the deleted object as per the structure and flags exported by Toolboxlib.
  Debug builds now have an extra *-command "*Toolbox_Counts" which dumps out
    the name of each active Toolbox task and a list of the objects that that
    task has created and what class each object is (it simply does a name
    lookup on the class ID (SWI base) and prints out the SWI name - so you
    get Window_ClassSWI for window objects and DCS_16 for quit objects)
Admin:
  Requires RiscOS/Sources/Toolbox/Common version 0.01 or later (Common-0_01).
  Requires RiscOS/Sources/Toolbox/Libs version 0.02 or later (Libs-0_02).


Version 1.46. Tagged as 'Toolbox-1_46'
@
text
@d40 1
a54 4
/* service call sent round after ROM initialisation */

#define Service_PostInit 0x73

d104 2
a110 3
#ifndef ROM
    extern int       messages_file(void);
#endif
d144 1
a144 1
    _swix (ResourceFS_DeregisterFiles, _IN(0), messages_file());
d158 1
a158 1
    if(!__ROM) _swix(0xa2c41, 0);
a169 5
    _kernel_swi_regs regs;
    char            *messages_filename;
#ifndef ROM
    extern int       messages_file(void);
#endif
d175 1
a175 1
    __ROM = _swix(0xa2c43, _IN(0), pw);
d210 1
a210 2
    regs.r[0] = messages_file();
    if ((e = _kernel_swi (ResourceFS_RegisterFiles, &regs, &regs)) != NULL)
d219 1
a219 4
    if (getenv ("Toolbox$Path") == NULL)
        messages_filename = "Resources:$.Resources.Toolbox.Messages";
    else
        messages_filename = "Toolbox:Messages";
d221 1
a221 1
    if ((e = messages_file_open(messages_filename)) != NULL)
a229 1
    regs.r[0] = (int) &toolbox_starting_callback_handler;
d231 1
a231 1
    regs.r[1] = (int)&ROM_started;
d233 1
a233 1
    regs.r[1] = 0;
a234 1
    _kernel_swi (OS_AddCallBack, &regs, &regs);
d240 1
a240 1
    _swix(ResourceFS_DeregisterFiles, _IN(0), messages_file());
@


4.7
log
@Event ordering problems fixed (SNB-U002).  Needs Window 1.51's
co-operation for this to work properly.
Version number now maintained by srccommit.

Version 1.42. Tagged as 'Toolbox-1_42'
@
text
@d355 1
d368 4
d378 1
a378 4




@


4.6
log
@Toolbox 1.40

SWI dispatcher fixed to dispatch Toolbox_Memory calls - this prevented
version 1.39 from providing the advertised memory services to the other
object modules.

Object ID validation is now performed by the Toolbox module itself
instead of the slow OS_ValidateAddress SWI call.  This is possible for
both the normal RMA usage and dynamic area usage since the Toolbox
knows the dynamic area address range (it reads the RMA details for RISC
OS 3.1 machines with OS_ReadDynamicArea on every access but that can't
be helped).
@
text
@d346 3
@


4.5
log
@Build process improvements:
  !MkRam,fd7 added to enable RAM builds of all Toolbox modules
  MakeFile tidied up and support for RAM build added
Module now uses Toolbox memory allocation instead of calling OS_Module.
@
text
@d89 3
a91 1
          NULL,
d338 5
a342 2
    if (swi_no > MAX_SWIS || swis[swi_no] == NULL)
        return make_error_hex (Toolbox_BadSWI, 1, swi_no + Toolbox_SWIChunkBase);
@


4.4
log
@Service_ToolboxTaskBorn issued once for each task instead of multiple times for
the same task when new object modules register.
@
text
@d50 1
d68 1
a68 5
#if 0
          object_copy,                    /* Toolbox_SWIChunkBase + 2  */
#else
          NULL,
#endif
d155 4
d185 5
d208 4
d222 1
d233 1
a233 1
        return e;
d249 1
d251 6
a256 1
    return NULL;
d299 4
@


4.3
log
@Ursula branch merged
@
text
@d255 1
a255 1
    /* /* look at mode change, and maybe reload sprites for that mode */
@


4.2
log
@ARTtmp branch folded in
@
text
@d217 1
a217 1
        messages_filename = "Resources:Resources.Toolbox.Messages";
@


4.2.2.1
log
@Added tokenisation directives to Messages files.
Made modules open "Resources:$...." not "Resources:....".
@
text
@d217 1
a217 1
        messages_filename = "Resources:$.Resources.Toolbox.Messages";
@


4.1
log
@Initial revision
@
text
@d62 1
a62 1
static _kernel_oserror *(*swis [MAX_SWIS])(_kernel_swi_regs *r)  = 
d64 1
a64 1
          /* --- client SWIs --- */ 
d68 1
a68 1
          object_copy,                    /* Toolbox_SWIChunkBase + 2  */ 
a111 1
    _kernel_swi_regs regs;
d149 1
a149 2
    regs.r[0] = messages_file();
    _kernel_swi (ResourceFS_DeregisterFiles, &regs, &regs);
d158 1
a158 1
#ifdef ROM 
d203 1
a203 1
    /* 
d248 1
a248 1
{  
d250 1
a250 1
           
d283 1
a283 1
#ifdef ROM 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.1.2.1
log
@Ensured that filename passed to MessageTrans_OpenFile is stored in RMA.
Made the Toolbox look for Res<territory> then Res, rather than Res then
Res<country>. Ditto for Messages.
@
text
@d62 1
a62 1
static _kernel_oserror *(*swis [MAX_SWIS])(_kernel_swi_regs *r)  =
d64 1
a64 1
          /* --- client SWIs --- */
d68 1
a68 1
          object_copy,                    /* Toolbox_SWIChunkBase + 2  */
d112 1
d150 2
a151 1
    _swix (ResourceFS_DeregisterFiles, _IN(0), messages_file());
d160 1
a160 1
#ifdef ROM
d205 1
a205 1
    /*
d250 1
a250 1
{
d252 1
a252 1

d285 1
a285 1
#ifdef ROM
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

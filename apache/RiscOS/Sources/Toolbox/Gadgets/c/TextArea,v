head	1.15;
access;
symbols
	Gadgets-0_44:1.15
	Gadgets-0_43:1.14
	Gadgets-0_42:1.14
	Gadgets-0_41:1.14
	Gadgets-0_40:1.14
	Gadgets-0_39:1.13
	Gadgets-0_38:1.13
	Gadgets-0_37:1.13
	Gadgets-0_36:1.12
	Gadgets-0_35:1.11
	Gadgets-0_34:1.11
	Gadgets-0_33:1.10
	Gadgets-0_32:1.10
	Gadgets-0_31:1.9
	Gadgets-0_30:1.8
	Gadgets-0_29:1.8
	Gadgets-0_28:1.8
	RO_5_07:1.8
	Gadgets-0_27:1.8
	Gadgets-0_26:1.8
	Gadgets-0_25:1.7
	Gadgets-0_24:1.7
	Gadgets-0_23:1.7
	Gadgets-0_22:1.7
	Gadgets-0_21:1.7
	Gadgets-0_20:1.6
	Gadgets-0_19:1.5
	Gadgets-0_18:1.5
	Gadgets-0_17:1.5
	Gadgets-0_16:1.5
	Gadgets-0_15:1.5
	sforrest_daytona_appflash-0_31:1.1.1.9.2.3
	Gadgets-0_14:1.4
	mjrobert_Java_26_08_98:1.1.1.13
	blaughto_daytona_appflash-0_30:1.1.1.9.2.3
	blaughto_daytona_appflash-0_29:1.1.1.9.2.3
	blaughto_daytona_appflash-0_28:1.1.1.9.2.3
	Gadgets-0_11:1.3
	sbrodie_TextGadgets_merged_19Jun98:1.2
	sbrodie_Daytona_merge_19Jun98:1.1.1.9.2.4
	sbrodie_Spin_merge_18Jun98:1.1.1.13
	jberanek_gadgets-0_08:1.1.1.9.2.4
	Gadgets-0_10-1_1_2_2:1.1.1.13
	blaughto_daytona_appflash-0_27:1.1.1.9.2.3
	blaughto_daytona_appflash-0_26:1.1.1.9.2.3
	blaughto_daytona_appflash-0_25:1.1.1.9.2.3
	blaughto_daytona_appflash-0_24:1.1.1.9.2.3
	blaughto_daytona_appflash-0_23:1.1.1.9.2.3
	blaughto_daytona_appflash-0_21:1.1.1.9.2.3
	blaughto_daytona_appflash-0_20:1.1.1.9.2.3
	blaughto_daytona_appflash-0_19:1.1.1.9.2.3
	jberanek_gadgets-0_07:1.1.1.9.2.3
	blaughto_daytona_appflash-0_18:1.1.1.9.2.2
	mrison_gadgets-0_06:1.1.1.9.2.2
	pwombwel_0_09:1.1.1.13
	mrison_gadgets-0_05:1.1.1.9.2.1
	Daytona:1.1.1.9.0.2
	Daytona_bp:1.1.1.9
	Spinner_RCA116:1.1.1.4
	Spinner_B20_2:1.1.1.3
	Spinner_19_3:1.1.1.3
	Spinner_B18:1.1.1.3
	Spinner_B17:1.1.1.3
	Spinner_B15:1.1.1.3
	Spinner_B14:1.1.1.3
	Spinner_B13:1.1.1.2
	Spinner_B12:1.1.1.2
	Spinner_B10:1.1.1.1
	Initial:1.1.1.1
	Spinner:1.1.1;
locks; strict;
comment	@# @;


1.15
date	2018.02.09.09.00.19;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	hvuSc2WpQ5n6caqA;

1.14
date	2015.11.28.19.08.33;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	Hv9ItC5GsjO1pTKy;

1.13
date	2013.08.30.21.32.36;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	Ah6FHegdauBDyw3x;

1.12
date	2013.08.30.19.34.37;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	cFJZhP2Bmu3bUv3x;

1.11
date	2012.01.14.17.18.00;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	I6w6cgQsKF85faPv;

1.10
date	2011.06.25.22.38.48;	author jlee;	state Exp;
branches;
next	1.9;
commitid	SJmoual8pfcHx6pv;

1.9
date	2010.02.28.10.40.27;	author rsprowson;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.18.22.01.04;	author rsprowson;	state Exp;
branches;
next	1.7;

1.7
date	99.06.18.14.20.54;	author jberanek;	state Exp;
branches;
next	1.6;

1.6
date	99.06.17.11.47.07;	author jberanek;	state Exp;
branches;
next	1.5;

1.5
date	99.03.26.12.25.13;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	98.10.21.14.27.28;	author pgoodlif;	state Exp;
branches;
next	1.3;

1.3
date	98.06.19.13.21.07;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	98.06.19.12.47.50;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	97.05.13.16.25.53;	author rlougher;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.13.16.25.53;	author rlougher;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.23.16.40.49;	author rlougher;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.06.18.15.06.17;	author rlougher;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.07.03.18.18.31;	author pwombwel;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.08.21.16.38.35;	author rlougher;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.11.21.13.16.45;	author rlougher;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.11.21.14.42.37;	author rlougher;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.12.16.12.54.53;	author rlougher;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.12.16.15.27.11;	author mrison;	state Exp;
branches
	1.1.1.9.2.1;
next	1.1.1.10;

1.1.1.10
date	97.12.16.18.16.35;	author rlougher;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.01.07.17.17.17;	author rlougher;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.01.20.20.01.45;	author rlougher;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.01.20.20.14.08;	author rlougher;	state Exp;
branches;
next	;

1.1.1.9.2.1
date	97.12.16.17.19.48;	author blaughto;	state Exp;
branches;
next	1.1.1.9.2.2;

1.1.1.9.2.2
date	98.01.28.18.15.17;	author mrison;	state Exp;
branches;
next	1.1.1.9.2.3;

1.1.1.9.2.3
date	98.03.16.16.22.11;	author jberanek;	state Exp;
branches;
next	1.1.1.9.2.4;

1.1.1.9.2.4
date	98.06.18.17.07.03;	author jberanek;	state Exp;
branches;
next	;


desc
@@


1.15
log
@SetColour method flag fixes
Fix checking of the DesktopColours flag to the scrolllist and textarea gadget SetColour methods - didn't match docs.
Fix for expression precedence of + and ? operators by sprinkling in some brackets.
Ref https://www.riscosopen.org/forum/forums/4/topics/9503#posts-72595

Also, optimise the forced redraw if the text area colour overall didn't change (reduces flicker).
Docs corrected to list RISC OS palette words in the right order.

Version 0.44. Tagged as 'Gadgets-0_44'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Title:   textarea.c
 * Purpose: text area gadget for textgadgets module
 *
 * Revision History
 * piers    18/06/1996 Created
 * piers    02/09/1996 Implemented insert text method
 * piers    20/12/1996 Incorporated RLougher's textarea source
 * piers    23/12/1996 Fixed selections to use drag type 9 so it doesn't need
 *                     to claim null events
 * piers    03/02/1997 Implemented fade flag
 * rlougher 18/03/1997 Added MemChecking code
 * rlougher 20/03/1997 Fixed bug in updating insert position after
 *                     keyboard input
 * rlougher 20/03/1997 Fixed set selection
 * rlougher 11/08/1997 Added ability to turn scrollbars on/off
 * rlougher 01/09/1997 Added ability to turn word wrap on/off
 * rlougher 04/09/1997 Wordwrap can now be changed dynamically at runtime
 * rlougher 05/09/1997 Scrollbars can now be turned on/off at runtime
 * rlougher 10/09/1997 Keyboard selection using shift + cursor keys
 * ADH      24/03/1999 Years in this history now four digit. Used same code
 *                     as ScrollList.c to get embedded window to correctly
 *                     fit the gadget bounding box. Title background colour
 *                     now 2, rather than incorrect value of 0.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "macros.h"
#include "messages.h"
#include "twimp.h"
#include "objects/gadgets.h"

#include "glib.h"
#include "riscos_uti.h"
#include "MemMan.h"
#include "TextMan.h"
#include "TextGadget.h"
#include "TextAreaP.h"
#include "Font.h"
#include "Sizes.h"
#include "Utils.h"

extern void print_info(FILE *);

#ifdef MemCheck_MEMCHECK
#include "MemCheck:MemCheck.h"
#endif

#ifdef Daytona_BUILD
#define IconHigh_Start 0x4e702
#define IconHigh_Start_HighlightOut 4
#define IconHigh_Direction_Up 1
#endif

static PrivateTextArea		*dragging = NULL;

static int my_icons[] = {-1};

static unsigned int vscroll_width  = SIZES_TOOL_DEFAULT;
static unsigned int hscroll_height = SIZES_TOOL_DEFAULT;

static PrivateTextArea **text_area_list = NULL;

static const WindowTemplate window_template =
{
    1<<1 | 1<<2, 		// flags
    NULL,	// help_message
    0, 		// max_help
    NULL,	// pointer_shape
    0,		// max_pointer_shape
    0,		// pointer_x_hot
    0,		// pointer_y_hot
    NULL,	// no menu
    0,		// num_keyboard_shortcuts
    NULL,	// keyboard_shortcuts
    0,		// num_gadgets
    NULL,	// gadgets
    -1,		// default_focus
    0,		// show_event
    0,		// hide_event
    NULL,	// toolbar_ibl
    NULL,	// toolbar_itl
    NULL,	// toolbar_ebl
    NULL,	// toolbar_etl
    {
        // WimpWindow struct
        {0, -100, 0, 0},	// visible_area
        0,			// xscroll
        0,			// yscroll
        -1,			// behind
        (int)wimp_WINDOWFLAGS_USE_NEW_FLAGS | wimp_WINDOWFLAGS_ALLOW_OFF_SCREEN,  	// flags
#ifndef Daytona_BUILD_NOBORDER
        7,			// title_fg
#else
        0xff,			// transparent title == no borders
#endif
        2,			// title_bg
        7,			// work_fg
        0xff,			// work_bg
        3,			// scroll_outer
        1,			// scroll_inner
        12,			// highlight_by
        0,			// reserved
        {0, -40960, 12800, 0},	// extent
        0,			// title_flags
        6 * wimp_ICONFLAGS_BUTTON_TYPE,// work_flags
        NULL,			// sprite_area
        0x00010001,		// min_width/min height
        {
            // WimpIconData
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        },
        0			// nicons
    }
};

static /* const */ ObjectTemplateHeader text_area_window =
{
    Window_ObjectClass,		// object_class
    0,				// flags
    102,			// version
    "__editor",			// name
    sizeof(ObjectTemplateHeader) + sizeof(WindowTemplate),	// total_size
    NULL,			// body - due to a bug in the compiler, we
    				// have to set this at run-time
    sizeof(WindowTemplate)	// body_size
};

static wimp_Bbox redraw_all_box = {0, -0xffff, 0xffff, 0};

static void update_display(PrivateTextArea *tdata,
			int first_line, int last_line, int line_delta);

_kernel_oserror *textarea_init(void)
{
    char wsname[64]; // For the name of the dynamic area 
    int  wsnamesize = sizeof(wsname);

    messages_file_lookup("WSName", wsname, &wsnamesize, 0);
    text_area_window.body = (void*) &window_template;

    return initialise_memory(wsname);
}

int textarea_active(void)
{
    return text_area_list != NULL;
}

_kernel_oserror *textarea_die(void)
{

    release_memory();

    return NULL;
}

/* ------------------------------------------------------------------------
 */
static _kernel_oserror *add_redraw_handler(PrivateTextArea *tb)
{

    if (text_area_list == NULL)
    {
        if ( (text_area_list = malloc(sizeof(PrivateTextArea*) * 2)) == NULL)
            return make_error(TextGadgets_AreaAllocFailed, 0);

        text_area_list[0] = tb;
        text_area_list[1] = NULL;
    }
    else
    {
        PrivateTextArea **new_list;
        unsigned int i;

        for (i = 0; text_area_list[i] != NULL; i++)
            ;

        new_list = realloc(text_area_list,sizeof(PrivateTextArea *) * (i+2));

        if (new_list == NULL)
            return make_error(TextGadgets_AreaAllocFailed, 0);

        text_area_list = new_list;

        text_area_list[i] = tb;
        text_area_list[i + 1] = NULL;
    }

    return NULL;
}

static _kernel_oserror *remove_redraw_handler(PrivateTextArea *tb)
{
    unsigned int i, j;

    if (text_area_list == NULL)
        return make_error(TextGadgets_UKTextArea, 0);

    for (i = 0;
        (text_area_list[i] != NULL) && (text_area_list[i] != tb);
        i++)
        ;

    if (text_area_list[i] == NULL)
        return make_error(TextGadgets_UKTextArea, 0);

    for (j = i; text_area_list[j] != NULL; j++)
        ;

    // j points to last entry

    if (j <= 1)
    {
        free(text_area_list);
        text_area_list = NULL;
    }
    else
    {
        PrivateTextArea **new_list;

        for (; i < j; i++)
            text_area_list[i] = text_area_list[i + 1];

        // No need to generate an error if the realloc fails, 'cos
        // it'll just realloc next time, hopefully
        new_list = realloc(text_area_list, sizeof(PrivateTextArea *) * (j+1));

        if (new_list != NULL)
            text_area_list = new_list;
    }

    return NULL;
}

static void deselect(PrivateTextArea *tdata)
{
    tdata->text->sel_stop_pos = -1;

    if(tdata->text->sel_stop_line < tdata->text->insert_line)
        update_display(tdata, tdata->text->sel_stop_line,
        				tdata->text->insert_line, 0);
    else
        update_display(tdata, tdata->text->insert_line,
        				tdata->text->sel_stop_line, 0);

    tdata->text->sel_stop_line = -1;
}

static void set_caret(int win, Text *text, int caret_x, int caret_y, int force, int invisible)
{
    wimp_GetWindowState     state;
    int xmax, ymax, new_x = -1, new_y = -1;

    state.open.window_handle = win;
    wimp_get_window_state(&state);

    xmax = state.open.visible_area.xmax - state.open.visible_area.xmin + state.open.scx;
    ymax = state.open.visible_area.ymax - state.open.visible_area.ymin - state.open.scy;

    if(xmax < caret_x)
        new_x = caret_x - xmax + state.open.scx + 10;
    else
        if(state.open.scx > caret_x)
            new_x = caret_x;

    if(ymax < caret_y)
        new_y = caret_y - ymax - state.open.scy;
    else
        if(-state.open.scy > (caret_y - text->line_height))
            new_y = (caret_y - text->line_height);

    if((new_x != -1) || (new_y != -1))
    {
        state.open.scx = new_x == -1 ? state.open.scx : new_x;
        state.open.scy = new_y == -1 ? state.open.scy : -new_y;

        wimp_open_window(&state.open);
    }

    if(!force)
    {
        wimp_GetCaretPosition block;

        wimp_get_caret_position(&block);
        if(block.window_handle != win)
            return;
    }

    wimp_set_caret_position(win, -1, caret_x, -caret_y,
                            text->line_height | (invisible ? 1<<25 : 0), -1);
}

static void _set_selection(PrivateTextArea *tdata, int from, int to)
{
    int		caret_x, caret_y;
    Text	*text = tdata->text;
    int		window;

    window_get_wimp_handle(0, tdata->object_id, &window);

    if(text->sel_stop_pos != -1)
        deselect(tdata);

    if((to == -1) || (to > get_text_size(text)))
        to = get_text_size(text);

    close_insertion(text);
    create_insertion(text, from);

    text->sel_stop_pos = to;
    text->sel_stop_line = line_index_of_char(text, to);

    char_pos(text, text->insert_pos, &caret_x, &caret_y);
    set_caret(window, text, caret_x, caret_y, 1, 1);
    update_display(tdata, text->insert_line, text->sel_stop_line, 0);
}

static _kernel_oserror *handle_drag(void)
{
    wimp_PointerInfo block;
    wimp_GetWindowState state;
    int win, xcoord, ycoord, old_line, new_line, index, xpos, ypos;

    window_get_wimp_handle(0, dragging->object_id, &win);
    state.open.window_handle = win;
    wimp_get_window_state(&state);
    wimp_get_pointer_info(&block);

    xcoord = block.x - state.open.visible_area.xmin + state.open.scx;
    ycoord = state.open.visible_area.ymax - state.open.scy - block.y;


    char_block(dragging->text, xcoord, ycoord, &new_line, &index, &xpos, &ypos);

    if(((old_line = dragging->text->sel_stop_line) == new_line) &&
       (index == dragging->text->sel_stop_pos))
          return NULL;

    dragging->text->sel_stop_pos = index;
    dragging->text->sel_stop_line = new_line;

    if(old_line < new_line)
        update_display(dragging, old_line, new_line, 0);
    else
        update_display(dragging, new_line, old_line, 0);

    return NULL;
}

static _kernel_oserror *handle_drag_stop(wimp_Bbox *box)
{
    IGNORE(box);

    dragging = NULL;

    return NULL;
}

static _kernel_oserror *_show(PrivateTextArea *tdata)
{
    WindowShowObjectBlock show_block;
    wimp_Bbox             newbox;
    unsigned int          dx = sizes_x_scale();
    unsigned int          dy = sizes_y_scale();
    int                   text_xmax, text_ymax, xextent, yextent, new_y, new_x;

    /* Work out scroll bar dimensions */

    sizes_tool_sizes(NULL, &vscroll_width, &hscroll_height);

    vscroll_width  -= dx;
    hscroll_height -= dy;

#ifndef Daytona_BUILD

    {

        /* Adjust show block for scrollbars and window outline */

        tdata->box.xmin += dx;
        tdata->box.ymin += dy;
        tdata->box.xmax -= dx;
        tdata->box.ymax -= dy;

        if(tdata->state & TextArea_Scrollbar_Horizontal)
            tdata->box.ymin += hscroll_height;

        if(tdata->state & TextArea_Scrollbar_Vertical)
            tdata->box.xmax -= vscroll_width;
    }

#endif

    work_to_screen_handle(&show_block.visible_area, &tdata->box,
    				tdata->wimpw);

    show_block.scx = show_block.scy = 0;
    show_block.behind = -1;
    show_block.window_flags = 0;
    show_block.parent_window_handle = tdata->wimpw;
    show_block.alignment_flags = 0;

    xextent = show_block.visible_area.xmax - show_block.visible_area.xmin;
    if(tdata->state & TextArea_WordWrap)
        new_x = xextent;
    else
    {
        text_xmax = tdata->text->xmax + 10;
        new_x = text_xmax > xextent ? text_xmax : xextent;
    }

    text_ymax = tdata->text->no_of_lines * tdata->text->line_height;
    yextent = show_block.visible_area.ymax - show_block.visible_area.ymin;
    new_y = text_ymax > yextent ? text_ymax : yextent;

    newbox.xmin = 0;
    newbox.xmax = new_x;
    newbox.ymin = -new_y;
    newbox.ymax = 0;

    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, tdata->object_id, Window_SetExtent, &newbox);

    _swix(Toolbox_ShowObject, _INR(0,5),
          Toolbox_ShowObject_AsSubWindow, tdata->object_id, Toolbox_ShowObject_FullSpec,
          &show_block, tdata->parent_id, -1);

    return NULL;
}

_kernel_oserror *textarea_plot(TextArea *tdata)
{
    wimp_GetWindowState	state;
    _kernel_oserror		*e;
    wimp_Bbox			box, bar;
    wimp_Icon			label;

    state.open.window_handle = redrawing_window;
    if ((e = wimp_get_window_state(&state)) != NULL)
        return e;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(tdata, sizeof(TextArea));
#endif

    box.xmin = tdata->hdr.xmin;
    box.ymin = tdata->hdr.ymin;
    box.xmax = tdata->hdr.xmax;
    box.ymax = tdata->hdr.ymax;
    label.bbox = box;
    work_to_screen(&box, &state);

    // Plot background
     colourtrans_set_gcol(tdata->background, 1<<7, 0);
    os_plot(PLOT_MOVE, box.xmin, box.ymin);
    os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK,
    		box.xmax, box.ymax);

    // Plot foreground
    colourtrans_set_gcol(tdata->foreground, 0, 0);
    os_plot(PLOT_DRAW, box.xmin, box.ymax);
    os_plot(PLOT_DRAW, box.xmin, box.ymin);
    os_plot(PLOT_DRAW, box.xmax, box.ymin);
    os_plot(PLOT_DRAW, box.xmax, box.ymax);

    if (tdata->hdr.flags & TextArea_Scrollbar_Vertical)
    {
        // Has vertical scrollbar
        bar = box;
        bar.xmin = MAX(bar.xmax - SIZES_TOOL_DEFAULT, bar.xmin);
        label.bbox.xmax = label.bbox.xmax - (bar.xmax - bar.xmin);
        if (tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
        	bar.ymin = MIN(bar.ymin + SIZES_TOOL_DEFAULT, bar.ymax);
        plot_2d_scrollbar(&bar, tdata->foreground, TRUE);
    }

    if (tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
    {
        // Has horizontal scrollbar
        bar = box;
        bar.ymax = MIN(bar.ymin + SIZES_TOOL_DEFAULT, bar.ymax);
        label.bbox.ymin = label.bbox.ymin + (bar.ymax - bar.ymin);
        if (tdata->hdr.flags & TextArea_Scrollbar_Vertical)
        	bar.xmax = MAX(bar.xmax - SIZES_TOOL_DEFAULT, bar.xmin);
        plot_2d_scrollbar(&bar, tdata->foreground, FALSE);
    }

    // Overlay a virtual label in the non scrollbar bit
    label.flags = wimp_ICONFLAGS_TEXT |
                  wimp_ICONFLAGS_VCENTRE | wimp_ICONFLAGS_HCENTRE |
                  (wimp_ICONFLAGS_FORECOL * wimp_BLACK) |
                  (wimp_ICONFLAGS_BACKCOL * wimp_WHITE);
    strcpy(label.data.text, "TextArea");
    wimp_plot_icon(&label);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(tdata);
#endif

    return NULL;
}

_kernel_oserror *textarea_move(int type, PrivateTextArea *tdata,
				wimp_Bbox *box)
{
    IGNORE(type);

    tdata->box = *box;

    return _show(tdata);
}

/* ------------------------------------------------------------------------
 */
static void update_display(PrivateTextArea *tdata,
			int first_line, int last_line, int line_delta)
{
    Text			*text = tdata->text;
    wimp_Bbox			current_ext;
    WindowRedraw		block;
    wimp_GetWindowState		state;
    int				redraw_top, redraw_bottom;
    int				more;
    int				window;
    int                         xextent, yextent, text_xmax;
    int                         new_x, new_y, text_ymax;
    unsigned int		foreground, background;

    if (tdata->state & Gadget_Faded)
    {
        int fore, back;

        fore = tdata->foreground >> 8;
        back = tdata->background >> 8;

        foreground = tdata->foreground;

#ifdef Daytona_BUILD_FADEWHITE
	background = tdata->background;
#else
        background = ( ((((fore & 0xff0000) -
        			(back & 0xff0000)) / 5 +
        			(back & 0xff0000)) & 0xff0000)|
        		((((fore & 0xff00) -
        			(back & 0xff00)) / 5 +
        			(back & 0xff00)) & 0xff00)|
        		((((fore & 0xff) -
        			(back & 0xff)) / 5 +
        			(back & 0xff)) & 0xff) ) << 8;
#endif
    }
    else
    {
        foreground = tdata->foreground;
        background = tdata->background;
    }

    window_get_wimp_handle(0, tdata->object_id, &window);

    state.open.window_handle = window;
    wimp_get_window_state(&state);

    xextent = state.open.visible_area.xmax - state.open.visible_area.xmin;
    if(tdata->state & TextArea_WordWrap)
        new_x = xextent;
    else
    {
        text_xmax = text->xmax + 10;
        new_x = text_xmax > xextent ? text_xmax : xextent;
    }

    text_ymax = text->no_of_lines * text->line_height;
    yextent = state.open.visible_area.ymax - state.open.visible_area.ymin;
    new_y = text_ymax > yextent ? text_ymax : yextent;

    redraw_top = -first_line * text->line_height;
    redraw_bottom = -(last_line + line_delta + 1) * text->line_height;

    if (line_delta != 0)
    {
        int src_top, src_bottom, dest_bottom;

        dest_bottom = state.open.visible_area.ymin - state.open.visible_area.ymax +
                      state.open.scy;
        src_top = -(last_line + 1) * text->line_height;
        src_bottom = dest_bottom + line_delta * text->line_height;

        wimp_block_copy(window, 0, src_bottom, 0xffff, src_top, 0,
                        dest_bottom);
    }

    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, tdata->object_id, Window_GetExtent, &current_ext);

    if((new_x != current_ext.xmax) || (new_y != -current_ext.ymin))
    {
        current_ext.xmax = new_x;
        current_ext.ymin = -new_y;

        _swix(Toolbox_ObjectMiscOp, _INR(0,3),
              0, tdata->object_id, Window_SetExtent, &current_ext);
        wimp_open_window(&state.open);
    }

    block.visible.xmin = 0;
    block.visible.ymin = redraw_bottom;
    block.visible.xmax = 0xffff;
    block.visible.ymax = redraw_top;
    block.window = window;

    wimp_update_window(&block, &more);
    while (more)
    {
        int xorg = block.visible.xmin - block.scx;
        int yorg = block.visible.ymax - block.scy;

        display_lines(text, yorg - block.current.ymax,
                        yorg - block.current.ymin,
                        xorg, yorg, foreground, background);

        wimp_get_rectangle (&block,&more);
    }
}

static void key_pressed(wimp_KeyPressed *event, PrivateTextArea *tdata)
{
    static char str[] = " ";
    Text *text = tdata->text;
    int win = event->caret.window_handle;
    int key = event->key_code;

    int first_line, last_line, line_delta;
    int l, new_pos = -1, caret_x, caret_y;

    _kernel_oserror *er;

    if (tdata->state & Gadget_Faded)
    {
        /* wimp_process_key(key); This shouldn't be called in a gadget. */
        return;
    }

#if !NEWDELETE
    if((key == 8) || (key == 127))	// Backspace and Delete respectively
#else
    if (key == 8)
#endif
    {
        if(text->sel_stop_pos != -1)
        {
            if(text->sel_stop_pos < text->insert_pos)
                replace_text(text, text->sel_stop_pos, text->insert_pos,
                             "", &first_line, &last_line, &line_delta);
            else
                replace_text(text, text->insert_pos, text->sel_stop_pos,
                             "", &first_line, &last_line, &line_delta);

            text->sel_stop_pos = -1;
        }
        else
        {
            if(text->insert_pos == 0)
                return;

            replace_text(text, text->insert_pos - 1, text->insert_pos, "",
                         &first_line, &last_line, &line_delta);
        }
        char_pos(text, text->insert_pos, &caret_x, &caret_y);
        set_caret(win, text, caret_x, caret_y, 1, 0);
        update_display(tdata, first_line, last_line, line_delta);
    }
#if NEWDELETE
    else if (key == 127)
#else
    else if (key == 0x18b)		// Copy/End (Windows-style "Delete")
#endif
    {
        if(text->sel_stop_pos != -1)
        {
            if(text->sel_stop_pos < text->insert_pos)
                replace_text(text, text->sel_stop_pos, text->insert_pos,
                             "", &first_line, &last_line, &line_delta);
            else
                replace_text(text, text->insert_pos, text->sel_stop_pos,
                             "", &first_line, &last_line, &line_delta);

            text->sel_stop_pos = -1;
        }
        else
        {
            if(text->insert_pos >= get_text_size (text))
                return;

            replace_text(text, text->insert_pos, text->insert_pos + 1, "",
                         &first_line, &last_line, &line_delta);
        }
        char_pos(text, text->insert_pos, &caret_x, &caret_y);
        set_caret(win, text, caret_x, caret_y, 1, 0);
        update_display(tdata, first_line, last_line, line_delta);
    }
#ifdef Daytona_BUILD
    else if (key == 0x19a)		// Shift-Tab
    {
        _swix (IconHigh_Start, _INR (0,1), IconHigh_Start_HighlightOut, IconHigh_Direction_Up);
        return;
    }
#endif
    else
    {
        switch(key & ~0x10)
        {
            case 0x18c:			// Left
                new_pos = text->insert_pos == 0 ? 0 : text->insert_pos -1;
                char_pos(text, new_pos, &caret_x, &caret_y);
                break;

            case 0x18d:			// Right
                new_pos = text->insert_pos > line_end(text,
                          text->no_of_lines - 1) ? text->insert_pos :
                          text->insert_pos + 1;
                char_pos(text, new_pos, &caret_x, &caret_y);
                break;

            case 0x18e:			// Down
                char_block(text, event->caret.x_caret_offset,
                  -(event->caret.y_caret_offset - text->line_height +1),
                  &l, &new_pos, &caret_x, &caret_y);
                break;

            case 0x18f:			// Up
#ifdef Daytona_BUILD
                if (-(event->caret.yoffset + text->line_height +1) < 0) {
                   _swix (IconHigh_Start, _INR (0,1), IconHigh_Start_HighlightOut, IconHigh_Direction_Up);
                   return;
                }
#endif
                char_block(text, event->caret.x_caret_offset,
                  -(event->caret.y_caret_offset + text->line_height +1),
                  &l, &new_pos, &caret_x, &caret_y);
                break;

            case 13:			// Return
                key = 10;

            default:
                if (((key < 32) || (key > 255))
#ifndef Daytona_BUILD
                // Tab handling doesn't seem to be very stable!
                // It would be possible to generate key 9 by using Ctrl-I on a PS/2 keyboard,
                // so play it safe and reject these...
                   && (key != 9)
#endif
                   && (key != 10))
                {
                    /* wimp_process_key(key);  This shouldn't be called in a gadget. */
                    return;
                }

                str[0] = key;
                if(text->sel_stop_pos != -1)
                {
                    if(text->sel_stop_pos < text->insert_pos)
                    {
                        er = replace_text(text, text->sel_stop_pos,
                                     text->insert_pos, str, &first_line,
                                     &last_line, &line_delta);
                        /* if there's an error from replace_text return straight away */
                        if (er)
                          return;
                    }
                    else
                    {
                        er = replace_text(text, text->insert_pos,
                                    text->sel_stop_pos, str, &first_line,
                                    &last_line, &line_delta);
                        /* if there's an error from replace_text return straight away */
                        if (er)
                          return;

                          close_insertion(text);
                          create_insertion(text, text->insert_pos + 1);
                    }

                    text->sel_stop_pos = -1;
                }
                else
                {
                    er = insert_text(text, str, &first_line, &last_line, &line_delta);
                    /* if there's an error from insert_text return straight away */
                    if (er)
                      return;
                }

                if(line_delta >= 0)
                {
                    update_display(tdata, first_line, last_line, line_delta);
                    char_pos(text, text->insert_pos, &caret_x, &caret_y);
                    set_caret(win, text, caret_x, caret_y, 1, 0);
                }
                else
                {
                    char_pos(text, text->insert_pos, &caret_x, &caret_y);
                    set_caret(win, text, caret_x, caret_y, 1, 0);
                    update_display(tdata, first_line, last_line, line_delta);
                }
        }
        if(new_pos != -1)
        {
#ifndef Daytona_BUILD_NOSELECTIONS
            if(key & 0x10)
            {
                int old_line = text->insert_line;
                int old_pos = text->insert_pos;

                close_insertion(text);
                create_insertion(text, new_pos);

                if((old_line != text->insert_line) || (old_pos != text->insert_pos))
                {

                    if(text->sel_stop_pos == -1)
                    {
                        text->sel_stop_pos = old_pos;
                        text->sel_stop_line = old_line;
                    }

                    if(old_line < text->insert_line)
                        update_display(tdata, old_line, text->insert_line, 0);
                    else
                        update_display(tdata, text->insert_line, old_line, 0);
                }
            }
            else
#endif
            {
                if(text->sel_stop_pos != -1)
                    deselect(tdata);

                close_insertion(text);
                create_insertion(text, new_pos);
            }

            char_pos(text, text->insert_pos, &caret_x, &caret_y);
            set_caret(win, text, caret_x, caret_y, 1, 0);
        }
    }
    return;
}

static void _redraw(wimp_RedrawWindowRequest *event, PrivateTextArea *tdata)
{
   int				more;
   WindowRedraw			block;
   Text				*text = tdata->text;
   unsigned int			foreground, background;

    if (tdata->state & Gadget_Faded)
    {
        int fore, back;

        fore = tdata->foreground >> 8;
        back = tdata->background >> 8;

        foreground = tdata->foreground;

#ifdef Daytona_BUILD_FADEWHITE
	background = tdata->background;
#else
        background = ( ((((fore & 0xff0000) -
        			(back & 0xff0000)) / 5 +
        			(back & 0xff0000)) & 0xff0000)|
        		((((fore & 0xff00) -
        			(back & 0xff00)) / 5 +
        			(back & 0xff00)) & 0xff00)|
        		((((fore & 0xff) -
        			(back & 0xff)) / 5 +
        			(back & 0xff)) & 0xff) ) << 8;
#endif
    }
    else
    {
        foreground = tdata->foreground;
        background = tdata->background;
    }

   block.window = event->window_handle;

   wimp_redraw_window(&block, &more);

   while (more)
   {
      int xorg = block.visible.xmin - block.scx;
      int yorg = block.visible.ymax - block.scy;

      colourtrans_set_gcol(background, 1<<7, 0);

      os_plot(PLOT_MOVE, block.current.xmin, block.current.ymin);
      os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK, block.current.xmax,
      			block.current.ymax);

      display_lines(text, yorg - block.current.ymax,
                          yorg - block.current.ymin,
                          xorg, yorg, foreground, background);

      wimp_get_rectangle(&block, &more);
   }

   return;
}


/* textarea_add -----------------------------------------------------------
 */
_kernel_oserror *
textarea_add(TextArea *tdata, int wimpw, ObjectID parent_id,
				int **icons, int **data)
{
    PrivateTextArea		*tb;
    _kernel_oserror		*e;

    tb = (PrivateTextArea *) mem_allocate(sizeof(PrivateTextArea));
    if (!tb)
        return make_error(TextGadgets_AreaAllocFailed, 0);

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(tb, sizeof(PrivateTextArea));
#endif

    tb->box.xmin = tdata->hdr.xmin;
    tb->box.ymin = tdata->hdr.ymin;
    tb->box.xmax = tdata->hdr.xmax;
    tb->box.ymax = tdata->hdr.ymax;

#ifndef Daytona_BUILD
    if(tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
        ((WindowTemplate *)text_area_window.body)->window.flags |= wimp_WINDOWFLAGS_HAS_HSCROLLBAR;
    else
        ((WindowTemplate *)text_area_window.body)->window.flags &= ~wimp_WINDOWFLAGS_HAS_HSCROLLBAR;

    if(tdata->hdr.flags & TextArea_Scrollbar_Vertical)
        ((WindowTemplate *)text_area_window.body)->window.flags |= wimp_WINDOWFLAGS_HAS_VSCROLLBAR;
    else
        ((WindowTemplate *)text_area_window.body)->window.flags &= ~wimp_WINDOWFLAGS_HAS_VSCROLLBAR;
#endif

    e = _swix(Toolbox_CreateObject, _INR(0,1) | _OUT(0),
              Toolbox_CreateObject_InCore, &text_area_window,
              &tb->object_id);
    if (e != NULL)
    {
#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(tb);
#endif
        mem_free(tb);
        return e;
    }

    *data = (int *) tb;

    tb->state = tdata->hdr.flags;
    tb->parent_id = parent_id;
    tb->component_id = tdata->hdr.component_id;

    tb->type = tdata->type;
    tb->wimpw = wimpw;
    tb->foreground = tdata->foreground;
    tb->background = tdata->background;
    tb->indent = TextArea_DefaultIndent;

    e = font_find_font(TextArea_DefaultFont, TextArea_DefaultWidth,
   		TextArea_DefaultHeight, 0, 0, (&tb->font_handle));
    if (e) tb->font_handle = 0;

    e = create_text(0, tb->font_handle, &tb->text);
    /* If there's an error from create_text return straight away */
    if (e)
      return e;

    if(tb->state & TextArea_WordWrap)
    {
        int width = tb->box.xmax - tb->box.xmin - 10;

        if(tb->state & TextArea_Scrollbar_Vertical)
            width -= vscroll_width;

        _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1), width > 0 ? width : 0, 0,
                                   &tb->text->margin);
    }
    else
        tb->text->margin = 0xffffff;

    if(tdata->text)
    {
        int f, l, d;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(tdata->text, strlen(tdata->text));
#endif
        e = insert_text(tb->text, tdata->text, &f, &l, &d);
        if (e)
          return e;

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(tdata->text);
#endif
    }

    *icons = my_icons;

    add_redraw_handler(tb);

    add_task_interest(GLib_ToolboxEvents, filter_toolbox_events,
    				TextGadgets_Filter);
    add_task_interest(GLib_WimpEvents, filter_wimp_events,
    				TextGadgets_Filter);

    _show(tb);

    return NULL;
}

static _kernel_oserror *textarea_mclick(PrivateTextArea *tdata,
		wimp_MouseClick *event)
{
    Text			*text = tdata->text;
    wimp_GetWindowState	state;
    int				win = event->window_handle;
    static int			dragging_workspace[4];
				// static int arrays are initialised to 0

#ifdef Daytona_BUILD
    if (tdata->state & Gadget_Faded)
       return NULL;
#endif

    /* The dragging_workspace block (set up below) is modified by the
       assembler veneers.
       by checking sliding[3] we can determine if this is just a mouse click
       (ie. the start of a drag) or a faked click - ie a dragging */

    if (dragging_workspace[3])
    {
        _kernel_oserror *e;

        e = handle_drag();

        dragging_workspace[3] = 0;

        return e;
    }

    if(text->sel_stop_pos != -1)
        deselect(tdata);

    state.open.window_handle = win;
    wimp_get_window_state(&state);

    if (event->buttons == 2)
    {
        // Menu clicked
        ObjectID	menu_id;

        _swix(Toolbox_ObjectMiscOp, _INR(0,2) | _OUT(0),
              0, tdata->parent_id, Window_GetMenu,
              &menu_id);
        if (menu_id != NULL_ObjectID)
        {
            _swix(Toolbox_ShowObject, _INR(0,5),
                  0, menu_id, 0,
                  0, tdata->parent_id, tdata->component_id);
        }

        return NULL;
    }

    if(event->buttons >= 16)
    {
        /* This stuff is based on the slider gadget. */
        static DragBox	drag_box;

       /* from s.TAsel_ven */
       extern void		_textarea_drag_draw(void);
       extern void		_textarea_drag_move(void);
       extern void		_textarea_drag_remove(void);

        dragging = tdata;

        drag_box.draw = _textarea_drag_draw;
        drag_box.move = _textarea_drag_move;
        drag_box.remove = _textarea_drag_remove;
        drag_box.wimp_window = event->window_handle;
        drag_box.drag_type = 9;
        drag_box.workspace = dragging_workspace;

        // This provides data to create a suitable mouse click
        dragging_workspace[1] = event->window_handle;
        dragging_workspace[0] = event->buttons >> 4;
        dragging_workspace[2] = event->icon_handle;
        dragging_workspace[3] = 0;

        drag_box.parent_box.xmin = state.open.visible_area.xmin;
        drag_box.parent_box.ymin = state.open.visible_area.ymin;
        drag_box.parent_box.xmax = state.open.visible_area.xmax;
        drag_box.parent_box.ymax = state.open.visible_area.ymax;

        drag_box.dragging_box.xmin = event->x;
        drag_box.dragging_box.ymin = event->y;
        drag_box.dragging_box.xmax = event->x;
        drag_box.dragging_box.ymax = event->y;

        wimp_drag_box(&drag_box);
    }
    else
    {
        int l, index, xpos, ypos;
        int xcoord = event->x - state.open.visible_area.xmin +
               state.open.scx;
        int ycoord = state.open.visible_area.ymax - state.open.scy -
               event->y;

        char_block(text, xcoord, ycoord, &l, &index, &xpos, &ypos);
        close_insertion(text);
        create_insertion(text, index);
        set_caret(win, text, xpos, ypos, 1, 0);
    }

    return NULL;
}


/* Method to set the cursor position in a TextArea */
static _kernel_oserror *_set_cursor_position (PrivateTextArea *tdata, unsigned int *index,
                                              unsigned int flags)
{
  int caret_x, caret_y, window_handle;
  unsigned int old_index;
  int force = 0, invisible = 0;
  _kernel_oserror *er;

  if (flags & 1)
    force = 1;

  if (flags & 2)
    invisible = 1;

  er = window_get_wimp_handle(0, tdata->object_id, &window_handle);
  if (er)
    return er;

  /* Save the old index */
  old_index = tdata->text->insert_pos;

  /* It appears the next line is unneeded, and can cause problems */
#if 0
  /* Then set the new index */
  tdata->text->insert_pos = *index;
#endif

  char_pos(tdata->text, *index, &caret_x, &caret_y);
  set_caret(window_handle, tdata->text, caret_x, caret_y, force, invisible);

  /* And return the old index */
  *index = old_index;

  /* Seems to work OK without any display update ... */
  /*  update_display(tdata, first_line, last_line, line_delta);*/

  return NULL;
}


/* Method to get the cursor position in a TextArea */
static _kernel_oserror *_get_cursor_position (PrivateTextArea *tdata, unsigned int *index,
                                              unsigned int flags)
{
  IGNORE(flags);

  *index = tdata->text->insert_pos;

  return NULL;
}


static _kernel_oserror *_set_colour(PrivateTextArea *handle,
	unsigned int flags, unsigned int foreground, unsigned int background)
{
    BOOL changed;

    if ((flags & TextArea_DesktopColours) != 0)
    {
        /* Need to translate desktop colours to real colours */
        Palette	palette;

        if ((foreground > 15) || (background > 15))
            return make_error(TextGadgets_DuffColour, 0);

        _swix(Wimp_ReadPalette, _IN(1)|_IN(2),&palette,0x45555254/*'TRUE'*/);
        foreground = palette.colours[foreground] & ~0xff;
        background = palette.colours[background] & ~0xff;
    }
    changed = (handle->foreground != foreground) ||
              (handle->background != background);
    handle->foreground = foreground;
    handle->background = background;

    if (changed)
    {
        /* Generate a force_redraw */
        _swix(Toolbox_ObjectMiscOp, _INR(0,3),
              0, handle->object_id, Window_ForceRedraw, &redraw_all_box);
    }

    return NULL;
}

static _kernel_oserror *_set_text(PrivateTextArea *handle, const char *text)
{
    int first_line, last_line, line_delta;
    int caret_x, caret_y;
    int window_handle;
    _kernel_oserror *er;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(text, strlen(text) + 1);
#endif

    if(handle->text->sel_stop_pos != -1)
        deselect(handle);

    window_get_wimp_handle(0, handle->object_id, &window_handle);

    er = replace_text(handle->text, 0, -1, text,
    			&first_line, &last_line, &line_delta);
    /* If there's an error from replace_text return straight away */
    if (er)
      return er;

    // PJG: Swapped latter two function calls and made char_pos look up the
    //      end of the text to position the caret at the end.
    char_pos(handle->text, get_handle(handle->text->text_data)->size, &caret_x, &caret_y);
    update_display(handle, first_line, last_line, line_delta);
    set_caret(window_handle, handle->text, 0, caret_y, 0, 1);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(text);
#endif

    return NULL;
}

static _kernel_oserror *_get_text(PrivateTextArea *handle, char *buffer,
				unsigned int buff_size, int *nbytes)
{
    if (buffer == NULL)
    {
        // No buffer, so return amount of bytes needed for buffer
        if (nbytes)
            *nbytes = get_text_size(handle->text) + 1;
    }
    else
    {
        get_text(handle->text, 0, buff_size - 1, buffer);

        *nbytes = strlen(buffer);
    }

    return NULL;
}

static _kernel_oserror *_insert_text(PrivateTextArea *tdata, int index,
				char *buffer)
{
    unsigned int length;
    int first_line, last_line, line_delta;
    int caret_x, caret_y;
    int window_handle;
    _kernel_oserror *er;

    if (buffer == NULL)
        return NULL;
    length = strlen(buffer);
    if (length == 0)
        return NULL;

    if(tdata->text->sel_stop_pos != -1)
        deselect(tdata);

    window_get_wimp_handle(0, tdata->object_id, &window_handle);

    er = replace_text(tdata->text, index, index, buffer,
                	&first_line, &last_line, &line_delta);
    /* If there's an error from replace_text return straight away */
    if (er)
      return er;

    char_pos(tdata->text, tdata->text->insert_pos, &caret_x, &caret_y);
    set_caret(window_handle, tdata->text, caret_x, caret_y, 0, 1);
    update_display(tdata, first_line, last_line, line_delta);

    return NULL;
}

static _kernel_oserror *_replace_text(PrivateTextArea *tdata,
				int start, int end, char *buffer)
{
    unsigned int length;
    int first_line, last_line, line_delta;
    int caret_x, caret_y;
    int window_handle;
    _kernel_oserror *er;

    if (buffer == NULL)
        return NULL;
    length = strlen(buffer);
    if (length == 0)
        return NULL;

    if(tdata->text->sel_stop_pos != -1)
        deselect(tdata);

    window_get_wimp_handle(0, tdata->object_id, &window_handle);

    er = replace_text(tdata->text, start, end, buffer,
    			&first_line, &last_line, &line_delta);
    if (er)
      return er;

    char_pos(tdata->text, tdata->text->insert_pos, &caret_x, &caret_y);
    set_caret(window_handle, tdata->text, caret_x, caret_y, 0, 0);
    update_display(tdata, first_line, last_line, line_delta);

    return NULL;
}

static _kernel_oserror *_get_selection(PrivateTextArea *handle, int flags,
			char *buff, int buff_size, int *start, int *end)
{
    if (flags & 1<<0)
    {
        // Return text rather than indexes
        if (buff == NULL)
        {
            if (end)
                *end = abs(handle->text->insert_pos -
                	        handle->text->sel_stop_pos) + 1;
        }
        else
        {
            unsigned int nbytes;

            nbytes = MIN(buff_size - 1, abs(handle->text->insert_pos -
                				handle->text->sel_stop_pos));

            if(handle->text->insert_pos < handle->text->sel_stop_pos)
                get_text(handle->text, handle->text->insert_pos,
            			handle->text->insert_pos + nbytes + 1, buff);
            else
                get_text(handle->text, handle->text->sel_stop_pos,
            	              handle->text->sel_stop_pos + nbytes + 1, buff);

            if (end)
                *end = nbytes;
        }
    }
    else
    {
        // Return indexes
        if (start)
            *start = handle->text->insert_pos;
        if (end)
        {
            if(handle->text->sel_stop_pos == -1)
                *end = *start;
            else
                *end = handle->text->sel_stop_pos;
        }
    }

    return NULL;
}

static _kernel_oserror *_set_font(PrivateTextArea *handle, const char *font,
				unsigned int width, unsigned int height)
{
    _kernel_oserror	*e;
    int window_handle, caret_x, caret_y;

    if (handle->font_handle != 0)
    {
        // Free existing font handle
        // Note that we do this even for fonts that were passed in by handle,
        // to match the behaviour of the Window module (see gadgets_set_font)
        font_lose_font(handle->font_handle);
        handle->font_handle = 0;
    }

    // Get new font handle
    if (((unsigned int)font)<256)
    {
        handle->font_handle = (unsigned int) font;
    }
    else if (font[0] < ' ')
    {
        handle->font_handle = 0;
    }
    else
    {
        e = font_find_font(font, width, height, 0, 0,
        			&handle->font_handle);
        if (e)
        {
            handle->font_handle = 0;
            return e;
        }
        set_font(handle->text, handle->font_handle);
    }

    window_get_wimp_handle(0, handle->object_id, &window_handle);
    char_pos(handle->text, handle->text->insert_pos, &caret_x, &caret_y);
    set_caret(window_handle, handle->text, caret_x, caret_y, 0, 0);

    /* Generate a force_redraw */
    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, handle->object_id, Window_ForceRedraw, &redraw_all_box);

    return NULL;
}

static void _set_state(PrivateTextArea *handle, unsigned int state)
{
    wimp_GetWindowState wstate;
    wimp_Bbox                    current_ext;
    unsigned int            changed = state ^ handle->state;
    int                     caret_x, caret_y, win;
    int                     parent, alignment;
    int                     xextent, yextent, new_x, new_y, text_ymax;
    _kernel_oserror        *er;

    if(!changed) return;

    handle->state = state;

    window_get_wimp_handle(0, handle->object_id, &win);
    wstate.open.window_handle = win;

    _swix(Wimp_GetWindowState,_IN(1)|_IN(2)|_OUT(3)|_OUT(4), &wstate,
                              0x4B534154 /* TASK */, &parent, &alignment);

#ifndef Daytona_BUILD
    if(changed & TextArea_Scrollbar_Vertical)
    {
        if(state & TextArea_Scrollbar_Vertical)
        {
            wstate.flags |= wimp_WINDOWFLAGS_HAS_VSCROLLBAR;
            wstate.open.visible_area.xmax -= vscroll_width;
        }
        else
        {
            wstate.flags &= ~wimp_WINDOWFLAGS_HAS_VSCROLLBAR;
            wstate.open.visible_area.xmax += vscroll_width;
        }
        alignment |= 1;

        if(state & TextArea_WordWrap)
            changed |= TextArea_WordWrap;
    }

    if(changed & TextArea_Scrollbar_Horizontal)
    {
        if(state & TextArea_Scrollbar_Horizontal)
        {
            wstate.flags |= wimp_WINDOWFLAGS_HAS_HSCROLLBAR;
            wstate.open.visible_area.ymin += hscroll_height;
        }
        else
        {
            wstate.flags &= ~wimp_WINDOWFLAGS_HAS_HSCROLLBAR;
            wstate.open.visible_area.ymin -= hscroll_height;
        }
        alignment |= 1;
    }
#endif

    xextent = wstate.open.visible_area.xmax - wstate.open.visible_area.xmin;

    if(changed & TextArea_WordWrap)
    {
        if(state & TextArea_WordWrap)
            _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1),
                              xextent > 10 ? xextent - 10 : xextent, 0, &handle->text->margin);
        else
            handle->text->margin = 0xffffff;

         er = compose_text(handle->text);
         /* If there's an error from compose_text return straight away */
         if (er)
           return;
    }

    if(state & TextArea_WordWrap)
        new_x = xextent;
    else
        new_x = (handle->text->xmax + 10) > xextent ? handle->text->xmax + 10 : xextent;

    yextent = wstate.open.visible_area.ymax - wstate.open.visible_area.ymin;
    text_ymax = handle->text->no_of_lines * handle->text->line_height;
    new_y = text_ymax > yextent ? text_ymax : yextent;

    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, handle->object_id, Window_GetExtent, &current_ext);

    if((new_x != current_ext.xmax) || (new_y != -current_ext.ymin))
    {
        current_ext.xmax = new_x;
        current_ext.ymin = -new_y;

        _swix(Toolbox_ObjectMiscOp, _INR(0,3),
              0, handle->object_id, Window_SetExtent, &current_ext);
    }

    _swix(Wimp_OpenWindow,_INR(1,4), &wstate, 0x4B534154 /* TASK */,
                          parent, alignment);

    char_pos(handle->text, handle->text->insert_pos, &caret_x, &caret_y);
    set_caret(win, handle->text, caret_x, caret_y, 0, 0);
    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, handle->object_id, Window_ForceRedraw, &redraw_all_box);
}

_kernel_oserror *textarea_method(PrivateTextArea *handle,
				_kernel_swi_regs *regs)
{
    _kernel_oserror *e = NULL;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(regs, sizeof(_kernel_swi_regs));
#endif

    switch (regs->r[2])
    {
        case TextArea_GetState:
            regs->r[0] = handle->state;
            break;
        case TextArea_SetState:
            _set_state(handle, regs->r[4]);
            break;
        case TextArea_SetText:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void *)regs->r[4], 10240);  // Say 10K - don't know size
#endif
            e = _set_text(handle, (char *)regs->r[4]);
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void *)regs->r[4]);
#endif
            break;
        case TextArea_GetText:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void *)regs->r[4], regs->r[5]);
#endif
            e = _get_text(handle, (char *)regs->r[4], regs->r[5],
            				&(regs->r[5]));
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void *)regs->r[4]);
#endif
            break;
        case TextArea_InsertText:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void *)regs->r[5], 10240);  // Say 10K - don't know size
#endif
            e = _insert_text(handle, regs->r[4], (char *) regs->r[5]);
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void *)regs->r[5]);
#endif
            break;
        case TextArea_ReplaceText:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void *)regs->r[6], 10240);  // Say 10K - don't know size
#endif
            e = _replace_text(handle, regs->r[4], regs->r[5],
            			(char *) regs->r[6]);
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void *)regs->r[6]);
#endif
            break;
        case TextArea_GetSelection:
            _get_selection(handle, regs->r[0], (char *) regs->r[4], regs->r[5],
            			&(regs->r[4]), &(regs->r[5]));
            break;
        case TextArea_SetSelection:
            _set_selection(handle, regs->r[4], regs->r[5]);
            break;
        case TextArea_SetFont:
            e = _set_font(handle, (char *)regs->r[4], regs->r[5],regs->r[6]);
            break;
        case TextArea_SetColour:
            // R4 = foreground col, R5 = background col
            e = _set_colour(handle, regs->r[0], regs->r[4], regs->r[5]);
            break;
        case TextArea_GetColour:
            regs->r[0] = handle->foreground;
            regs->r[1] = handle->background;
            break;
        case TextArea_SetCursorPosition:
            e = _set_cursor_position (handle, (unsigned int *)&regs->r[4], (unsigned int)regs->r[0]);
            break;

        case TextArea_GetCursorPosition:
            e = _get_cursor_position (handle, (unsigned int *)&regs->r[4], (unsigned int)regs->r[0]);
            break;

        default:
            break;
    }

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(regs);
#endif

    return e;
}

/* ------------------------------------------------------------------------
 */
_kernel_oserror *textarea_remove(PrivateTextArea *handle)
{
    remove_redraw_handler(handle);

    if (handle->font_handle)
        font_lose_font(handle->font_handle);

    remove_task_interest(GLib_ToolboxEvents, filter_toolbox_events);
    remove_task_interest(GLib_WimpEvents, filter_wimp_events);
    _swix(Toolbox_DeleteObject, _INR(0,1), 0, handle->object_id);

    delete_text(handle->text);

    #ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(handle);
#endif

    mem_free(handle);

    return NULL;
}

_kernel_oserror *textarea_fade(PrivateTextArea *tdata, int fade)
{
    IGNORE(fade);

    tdata->state &= ~Gadget_Faded;
    tdata->state |= fade ? Gadget_Faded : 0;

    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, tdata->object_id, Window_ForceRedraw, &redraw_all_box);

    return NULL;
}

/* ------------------------------------------------------------------------
 */
#ifdef MemCheck_MEMCHECK
static _kernel_oserror *textarea_filter2(_kernel_swi_regs *regs)
#else
_kernel_oserror *textarea_filter(_kernel_swi_regs *regs)
#endif
{
    ToolboxEvent *event = (ToolboxEvent *)regs->r[1];
    IDBlock	*id_block = (IDBlock *)regs->r[3];
    int		event_code = regs->r[0];
    unsigned int i;

    if (text_area_list == NULL)
        return NULL;

    if (event_code == wimp_EBUT)
    {
        for (i = 0; text_area_list[i] != NULL; i++)
        {
            wimp_MouseClick *wimp_mouse_event = (wimp_MouseClick *)event;
            int			window_handle;

            window_get_wimp_handle(0, text_area_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_mouse_event->window_handle)
            {
                textarea_mclick(text_area_list[i], wimp_mouse_event);
                // Claim event, since we don't want the application to know
                // what's going on?
                regs->r[0] = -1;
            }
        }

        return NULL;
    }
    else if (event_code == wimp_EKEY)
    {
        for (i = 0; text_area_list[i] != NULL; i++)
        {
            wimp_KeyPressed *wimp_key_event = (wimp_KeyPressed *)event;
            int			window_handle;

            window_get_wimp_handle(0, text_area_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_key_event->caret.window_handle)
            {
                key_pressed(wimp_key_event, text_area_list[i]);
            }
        }

        return NULL;
    }
    else if (event_code == wimp_EREDRAW)
    {
        for (i = 0; text_area_list[i] != NULL; i++)
        {
            wimp_RedrawWindowRequest *wimp_redraw_event =
            				(wimp_RedrawWindowRequest *) event;
            int			window_handle;

            window_get_wimp_handle(0, text_area_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_redraw_event->window_handle)
            {
                _redraw(wimp_redraw_event, text_area_list[i]);

                // Claim event, since we don't want the application to do any
                // redraw
                regs->r[0] = -1;
            }
        }

        return NULL;
    }
    else if (event_code == wimp_EUSER_DRAG)
    {
        if (dragging)
        {
            handle_drag_stop((wimp_Bbox *) event);

            // Claim event, since we don't want the application to think
            // the drag belongs to it
            regs->r[0] = -1;
        }

        return NULL;
    }

    if ((event_code != wimp_ETOOLBOX_EVENT) ||
        ((id_block->self_component & 0xfff) != 0x800) ||
        (text_area_list == NULL))
        return NULL;

    if (event->hdr.event_code == Toolbox_ObjectDeleted)
    {
        int remaining = 0;
        PrivateTextArea **new_list;
        // An object has been deleted, so remove from internal list
        // any gadgets inside it.
        for (i = 0; text_area_list[i] != NULL; i++)
        {
            if (text_area_list[i]->parent_id == id_block->self_id)
            {
                // Found one!
                int j;
                for (j = i; text_area_list[j] != NULL; j++)
                {
                    // Copy down following gadgets
                    text_area_list[j] = text_area_list[j+1];
                }
            }
            else
                remaining++;
        }

        // Shrink memory block
        if (remaining == 0)
        {
            free(text_area_list);
            text_area_list = NULL;
        }
        else
        {
            new_list = realloc(text_area_list,
        			sizeof(PrivateTextArea*) * (remaining + 1));
            if (new_list != NULL)
                text_area_list = new_list;
        }
    }

    return NULL;
}

#ifdef MemCheck_MEMCHECK
_kernel_oserror *textarea_filter(_kernel_swi_regs *regs)
{
    _kernel_oserror *e;

    MemCheck_RegisterMiscBlock((void*)regs->r[1], 256);
    MemCheck_RegisterMiscBlock((void*)regs->r[3], sizeof(IdBlock));
    e = textarea_filter2(regs);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[1]);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[3]);

    return e;
}
#endif

@


1.14
log
@Plot a more credible rendition of TextArea and ScrollList
Both the TextArea gadget and ScrollList were outputting an unhelpful white rectangle and mysterious black rectangle when asked to plot the gadget prototype (eg. in the gadget palette in ResEd). The black rectangle turned out to represent a scroll bar, though it was the wrong width.
Changed to plot a 2D scrollbar (ala RISC OS 2) then overlay a virtual icon with the name of the gadget type.
main.c:
Relocate helper functions into glib.
Return 'Bad SWI' for unknown subreasons.
glib.c/glib3.c:
Remove various unused functions.
Added new function to plot a grey scrollbar from nested rectangles.
TextArea.c:
Add a vertical, or horixontal, or both, scrollbar plus the label "TextArea".
ScrollList.c:
Add a vertical scrollbar plus the label "ScrollList".

Requires Common-0_25 for the colour defines. Tested in !ResEd in various eigenfactor modes.

Version 0.40. Tagged as 'Gadgets-0_40'
@
text
@d1206 3
a1208 1
    if (flags | TextArea_DesktopColours == flags)
d1220 2
d1225 6
a1230 3
    /* Generate a force_redraw */
    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, handle->object_id, Window_ForceRedraw, &redraw_all_box);
@


1.13
log
@Internationalised
Supporting code borrowed from 'Iconbar' toolbox module.
Tested in a ROM build and RAM build, triggering one error message and checking the dynamic area in task manager.

Version 0.37. Tagged as 'Gadgets-0_37'
@
text
@d59 1
a59 1
#include "utils.h"
d77 2
a78 2
static unsigned int vscroll_width  = SCROLLBAR_SIZE;
static unsigned int hscroll_height = SCROLLBAR_SIZE;
d454 2
a455 1
    wimp_Bbox			box;
d469 1
d472 2
a473 1
    colourtrans_set_gcol(tdata->background, 1<<7, 0);
d477 2
d488 6
a493 8
        int x, y;

        colourtrans_set_gcol(0 /* black */, 1<<7, 0);
        x = MAX(box.xmax - vscroll_width, box.xmin);
        y = (tdata->hdr.flags & TextArea_Scrollbar_Horizontal) ?
        	MIN(box.ymin + hscroll_height, box.ymax) : box.ymin;
        os_plot(PLOT_MOVE, x, y);
        os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK, box.xmax, box.ymax);
d499 7
a505 1
        int x, y;
d507 7
a513 7
        colourtrans_set_gcol(0 /* black */, 1<<7, 0);
        x = (tdata->hdr.flags & TextArea_Scrollbar_Vertical) ?
        	MAX(box.xmax - vscroll_width, box.xmin) : box.xmax;
        y = MIN(box.ymin + hscroll_height, box.ymax);
        os_plot(PLOT_MOVE, box.xmin, box.ymin);
        os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK, x, y);
    }
@


1.12
log
@Change to link against tboxlibint
For some reason this toolbox module was unique in linking against the public toolboxlib rather than the internal one, this meant having to carefully tippy toe around not mixing header files (as they contain similar but differently named definitions).
A massive search and replace job.
Tested briefly using ResEd/ResTest and a textarea and scrolllist in a ROM build.
Requires Common-0_21.

Version 0.36. Tagged as 'Gadgets-0_36'
@
text
@d47 1
a57 1
#include "Text.h"
d154 4
d160 1
a160 1
    return initialise_memory("TextArea workspace");
d184 1
a184 1
            return (_kernel_oserror *)&e_outofareamem;
d200 1
a200 1
            return (_kernel_oserror *)&e_outofareamem;
d216 1
a216 1
        return (_kernel_oserror *)&e_badarea;
d224 1
a224 1
        return ( _kernel_oserror *)&e_badarea;
d933 1
a933 1
        return (_kernel_oserror *)&e_outofareamem;
d1203 1
a1203 1
            return (_kernel_oserror *)&e_badcol;
@


1.11
log
@Remove unnecessary includes of "Modhdr.h".
The last change meant it was no longer being generated, so ammended the code to not need it in line with all the other toolbox modules.

Version 0.34. Tagged as 'Gadgets-0_34'
@
text
@a39 1

a42 2
#include <math.h>

d46 2
a47 2
#include "toolbox.h"
#include "window.h"
a48 1
#include "wimplib.h"
a50 1
#include "string32.h"
d52 2
a54 1
#include "TextArea.h"
a57 2
#include "Scrollbar.h"
#include "ScrollbarP.h"
a74 4
#define IGNORE(a) (a)=(a)
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#define MAX(x, y) ((x) > (y) ? (x) : (y))

d109 1
a109 1
        WimpWindow_NewFormat | WimpWindow_NoBounds,  	// flags
d124 1
a124 1
        6 * WimpIcon_ButtonType,// work_flags
d126 1
a126 2
        1,			// min_width
        1,			// min_height
d147 1
a147 1
static BBox redraw_all_box = {0, -0xffff, 0xffff, 0};
d266 1
a266 1
    WimpGetWindowStateBlock     state;
d269 1
a269 1
    state.window_handle = win;
d272 2
a273 2
    xmax = state.visible_area.xmax - state.visible_area.xmin + state.xscroll;
    ymax = state.visible_area.ymax - state.visible_area.ymin - state.yscroll;
d276 1
a276 1
        new_x = caret_x - xmax + state.xscroll + 10;
d278 1
a278 1
        if(state.xscroll > caret_x)
d282 1
a282 1
        new_y = caret_y - ymax - state.yscroll;
d284 1
a284 1
        if(-state.yscroll > (caret_y - text->line_height))
d289 2
a290 2
        state.xscroll = new_x == -1 ? state.xscroll : new_x;
        state.yscroll = new_y == -1 ? state.yscroll : -new_y;
d292 1
a292 1
        wimp_open_window((WimpOpenWindowBlock *) &state);
d297 1
a297 1
        WimpGetCaretPositionBlock block;
d335 2
a336 2
    WimpGetPointerInfoBlock block;
    WimpGetWindowStateBlock state;
d340 1
a340 1
    state.window_handle = win;
d344 2
a345 2
    xcoord = block.x - state.visible_area.xmin + state.xscroll;
    ycoord = state.visible_area.ymax - state.yscroll - block.y;
d365 1
a365 1
static _kernel_oserror *handle_drag_stop(BBox *box)
d377 1
a377 1
    BBox                  newbox;
d412 1
a412 1
    show_block.xscroll = show_block.yscroll = 0;
d436 2
a437 1
    window_set_extent(0, tdata->object_id, &newbox);
d439 3
a441 3
    toolbox_show_object(Toolbox_ShowObject_AsSubWindow, tdata->object_id,
  			Toolbox_ShowObject_FullSpec, &show_block,
  			tdata->parent_id, -1);
d448 1
a448 1
    WimpGetWindowStateBlock	state;
d450 1
a450 1
    BBox			box;
d452 1
a452 1
    state.window_handle = redrawing_window;
d460 4
a463 1
    box = tdata->hdr.box;
d510 1
a510 1
				BBox *box)
d525 3
a527 3
    BBox			current_ext;
    WimpRedrawWindowBlock	block;
    WimpGetWindowStateBlock     state;
d566 1
a566 1
    state.window_handle = window;
d569 1
a569 1
    xextent = state.visible_area.xmax - state.visible_area.xmin;
d579 1
a579 1
    yextent = state.visible_area.ymax - state.visible_area.ymin;
d589 2
a590 2
        dest_bottom = state.visible_area.ymin - state.visible_area.ymax +
                      state.yscroll;
d598 2
a599 1
    window_get_extent(0, tdata->object_id, &current_ext);
d606 3
a608 2
        window_set_extent(0, tdata->object_id, &current_ext);
        wimp_open_window((WimpOpenWindowBlock *) &state);
d611 5
a615 5
    block.visible_area.xmin = 0;
    block.visible_area.ymin = redraw_bottom;
    block.visible_area.xmax = 0xffff;
    block.visible_area.ymax = redraw_top;
    block.window_handle = window;
d620 2
a621 2
        int xorg = block.visible_area.xmin - block.xscroll;
        int yorg = block.visible_area.ymax - block.yscroll;
d623 2
a624 2
        display_lines(text, yorg - block.redraw_area.ymax,
                        yorg - block.redraw_area.ymin,
d631 1
a631 1
static void key_pressed(WimpKeyPressedEvent *event, PrivateTextArea *tdata)
d731 2
a732 2
                char_block(text, event->caret.xoffset,
                  -(event->caret.yoffset - text->line_height +1),
d743 2
a744 2
                char_block(text, event->caret.xoffset,
                  -(event->caret.yoffset + text->line_height +1),
d856 1
a856 1
static void _redraw(WimpRedrawWindowRequestEvent *event, PrivateTextArea *tdata)
d859 1
a859 1
   WimpRedrawWindowBlock	block;
d892 1
a892 1
   block.window_handle = event->window_handle;
d898 2
a899 2
      int xorg = block.visible_area.xmin - block.xscroll;
      int yorg = block.visible_area.ymax - block.yscroll;
d903 3
a905 3
      os_plot(PLOT_MOVE, block.redraw_area.xmin, block.redraw_area.ymin);
      os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK, block.redraw_area.xmax,
      			block.redraw_area.ymax);
d907 2
a908 2
      display_lines(text, yorg - block.redraw_area.ymax,
                          yorg - block.redraw_area.ymin,
d921 1
a921 1
textarea_add(TextArea *tdata, int wimpw, ObjectId parent_id,
d935 4
a938 1
    tb->box = tdata->hdr.box;
d942 1
a942 1
        ((WindowTemplate *)text_area_window.body)->window.flags |= WimpWindow_HScroll;
d944 1
a944 1
        ((WindowTemplate *)text_area_window.body)->window.flags &= ~WimpWindow_HScroll;
d947 1
a947 1
        ((WindowTemplate *)text_area_window.body)->window.flags |= WimpWindow_VScroll;
d949 1
a949 1
        ((WindowTemplate *)text_area_window.body)->window.flags &= ~WimpWindow_VScroll;
d952 4
a955 2
    if ((e = toolbox_create_object(1, &text_area_window,
    					&tb->object_id)) != NULL)
d1029 1
a1029 1
		WimpMouseClickEvent *event)
d1032 1
a1032 1
    WimpGetWindowStateBlock	state;
d1061 1
a1061 1
    state.window_handle = win;
d1067 1
a1067 1
        ObjectId	menu_id;
d1069 9
a1077 4
        window_get_menu(0, tdata->parent_id, &menu_id);
        if (menu_id != 0)
            toolbox_show_object(0, menu_id, 0, 0,
                                tdata->parent_id, tdata->component_id);
d1085 1
a1085 1
        static WimpDragBox	drag_box;
d1107 9
a1115 9
        drag_box.parent_box.xmin = state.visible_area.xmin;
        drag_box.parent_box.ymin = state.visible_area.ymin;
        drag_box.parent_box.xmax = state.visible_area.xmax;
        drag_box.parent_box.ymax = state.visible_area.ymax;

        drag_box.dragging_box.xmin = event->mouse_x;
        drag_box.dragging_box.ymin = event->mouse_y;
        drag_box.dragging_box.xmax = event->mouse_x;
        drag_box.dragging_box.ymax = event->mouse_y;
d1122 4
a1125 4
        int xcoord = event->mouse_x - state.visible_area.xmin +
               state.xscroll;
        int ycoord = state.visible_area.ymax - state.yscroll -
               event->mouse_y;
d1195 1
a1195 1
        // Need to translate desktop colours to real colours
d1208 3
a1210 2
    // Generate a force_redraw
    window_force_redraw(0, handle->object_id, &redraw_all_box);
d1421 3
a1423 2
    // Generate a force_redraw
    window_force_redraw(0, handle->object_id, &redraw_all_box);
d1430 2
a1431 2
    WimpGetWindowStateBlock wstate;
    BBox                    current_ext;
d1443 1
a1443 1
    wstate.window_handle = win;
d1453 2
a1454 2
            wstate.flags |= WimpWindow_VScroll;
            wstate.visible_area.xmax -= vscroll_width;
d1458 2
a1459 2
            wstate.flags &= ~WimpWindow_VScroll;
            wstate.visible_area.xmax += vscroll_width;
d1471 2
a1472 2
            wstate.flags |= WimpWindow_HScroll;
            wstate.visible_area.ymin += hscroll_height;
d1476 2
a1477 2
            wstate.flags &= ~WimpWindow_HScroll;
            wstate.visible_area.ymin -= hscroll_height;
d1483 1
a1483 1
    xextent = wstate.visible_area.xmax - wstate.visible_area.xmin;
d1504 1
a1504 1
    yextent = wstate.visible_area.ymax - wstate.visible_area.ymin;
d1508 2
a1509 1
    window_get_extent(0, handle->object_id, &current_ext);
d1516 2
a1517 1
        window_set_extent(0, handle->object_id, &current_ext);
d1525 2
a1526 1
    window_force_redraw(0, handle->object_id, &redraw_all_box);
d1632 1
a1632 1
    toolbox_delete_object(0, handle->object_id);
d1652 2
a1653 1
    window_force_redraw(0, tdata->object_id, &redraw_all_box);
d1667 1
a1667 1
    IdBlock	*id_block = (IdBlock *)regs->r[3];
d1674 1
a1674 1
    if (event_code == Wimp_EMouseClick)
d1678 1
a1678 1
            WimpMouseClickEvent *wimp_mouse_event = (WimpMouseClickEvent*)event;
d1695 1
a1695 1
    else if (event_code == Wimp_EKeyPressed)
d1699 1
a1699 1
            WimpKeyPressedEvent *wimp_key_event = (WimpKeyPressedEvent*)event;
d1713 1
a1713 1
    else if (event_code == Wimp_ERedrawWindow)
d1717 2
a1718 2
            WimpRedrawWindowRequestEvent *wimp_redraw_event =
            				(WimpRedrawWindowRequestEvent *) event;
d1736 1
a1736 1
    else if (event_code == Wimp_EUserDrag)
d1740 1
a1740 1
            handle_drag_stop((BBox *) event);
d1750 1
a1750 1
    if ((event_code != Wimp_EToolboxEvent) ||
@


1.10
log
@TextGadgets module fixes & improvements
Detail:
  c/ScrollList, c/TextArea - ScrollList_SetFont and TextArea_SetFont now accept font handles instead of just font names. The handles are handled in the same way as the Window module, i.e. the handle will be managed and freed by the TextGadgets modules. Fixes bug #212.
  c/ScrollList, c/Scrollbar, c/TextArea - Fix handling of Toolbox_ObjectDeleted events. Original code would corrupt the object lists when deleting items, and reallocate much more memory than was actually needed. Fixes bug #214
  c/MemMan - Fix grow_handlers to not leave handle_list as NULL if the realloc fails. Fixes bug #216.
  c/MemMan, c/TextArea, c/TextMan, h/MemMan, h/TextMan - Changed how the 'Handle' type is handled. Instead of MemMan giving out direct pointers to Handle instances, it now gives out identifiers (HandleId). These identifiers are then converted to Handle pointers via get_handle whenever the contents need to be accessed. This allows the handle_list to be safely realloc'd without breaking all the existing Handle pointers. Fixes bug #217
  c/MemMan - Reduced HDNLE_GRW_BY from 1000 to 128 to save a bit of memory
Admin:
  Module compiles and runs, but actual functionality is untested.
  Fixes bugs 212, 214, 216, 217.


Version 0.32. Tagged as 'Gadgets-0_32'
@
text
@a64 1
#include "ModHdr.h"
@


1.9
log
@Function returns no longer use stack structures.
Previously, a number of errors were contructed as automatic variables then returned to the caller - potentially accessing stale stack area. All error blocks are now held in ROM and cast from there.
Error numbers are now not &00000000 or &20202020, using the allocated base - requires 'Common-0_15'.
Trimmed some unused debugging code out, saves about 3k.
Renamed C++ clashing variables to stop the compiler moaning.
Implemented feature request to accept the empty string "" as no font handle in _SetFont calls.
At some point, this module needs internationalising.

Version 0.31. Tagged as 'Gadgets-0_31'
@
text
@d1234 1
a1234 1
    char_pos(handle->text, handle->text->text_data->size, &caret_x, &caret_y);
d1385 2
d1392 5
a1396 1
    if ((font == NULL) || (font[0] < ' '))
d1760 1
a1760 1
                    text_area_list[j] = text_area_list[j+i];
d1776 1
a1776 1
        			sizeof(PrivateTextArea) * (remaining + 1));
@


1.8
log
@Change so it does delete and backspace like Windows (controlled by the
NEWDELETE switch like RISCOSLib is now).
Key 8 deletes left
Key 127 deletes right
The Copy key does nothing (home and end aren't implemented it seems).
Fix from Kevin for it claiming a Dynamic area of maximum size - greedy
guts now limited to 16M.

Version 0.26. Tagged as 'Gadgets-0_26'
@
text
@d51 1
a163 5
static _kernel_oserror *out_of_memory(void)
{
   return (_kernel_oserror *) "    Unable to allocate memory to store text area gadget definition";
}

a187 1
    _kernel_oserror no_mem = {0, "Not enough memory"};
d192 1
a192 1
            return &no_mem;
d205 1
a205 1
        new_list = realloc(text_area_list,sizeof(PrivateTextArea*) * (i+2));
d208 1
a208 1
            return &no_mem;
a220 1
    _kernel_oserror bad_area = {0, "No such text area"};
d224 1
a224 1
        return &bad_area;
d232 1
a232 1
        return &bad_area;
d253 1
a253 1
        new_list = realloc(text_area_list, sizeof(PrivateTextArea) * (j+1));
d389 1
a389 1
    BBox                  new;
d443 4
a446 4
    new.xmin = 0;
    new.xmax = new_x;
    new.ymin = -new_y;
    new.ymax = 0;
d448 1
a448 1
    window_set_extent(0, tdata->object_id, &new);
d935 1
a935 1
        return out_of_memory();
a1192 1
        _kernel_oserror bad_col = {0, "Invalid desktop colour"};
d1195 1
a1195 1
            return &bad_col;
d1390 1
a1390 1
    if (font == NULL)
@


1.7
log
@ * Fixed the textarea_set/get_cursor_position methods to use the method
   interface as specified in docs.textarea.  I wasn't returning values
   in R4 as it showed in the document, I am now.  The fetching of the
   cursor position (in both the get and set calls) doesn't appear to
   work (always returns 0) with what appears to be the correct code to
   achieve this.  The fixing of this is left as an exercise for the bored
   and very brave person...textarea internals are "interesting".

 * Added some description of the methods into docs.textarea


Version 0.21. Tagged as 'Gadgets-0_21'
@
text
@d661 1
d663 3
d690 3
d694 1
d764 1
a764 4
                if (((key < 32) || (key > 255)
                    || (key == 127))
                // This used to be 126, but Rob himself can't remember why he rejected tildes.
                // Assumed to be a typo for 127 (Delete), even though this is trapped above.
@


1.6
log
@ * Added 2 new TextArea calls, as they were defined in docs.TextArea.
   TextArea_SetCursorPosition and TextArea_GetCursorPosition.

 * Removed a lot of unneeded comments that wrapped around changes I made
   a while ago.

 * !MkRam now enables throwback.


Version 0.20. Tagged as 'Gadgets-0_20'
@
text
@d1134 3
a1136 3
/* New method added by JBeranek */
static _kernel_oserror *_set_cursor_position (PrivateTextArea *tdata, unsigned int index,
                                              unsigned int *old_index, unsigned int flags)
d1139 1
d1153 10
a1162 4
  if (old_index)
    *old_index = tdata->text->insert_pos;
  tdata->text->insert_pos = index;
  char_pos(tdata->text, tdata->text->insert_pos, &caret_x, &caret_y);
d1165 3
d1175 1
a1175 1
/* New method added by JBeranek */
d1179 3
a1181 2
  if (index)
    *index = tdata->text->insert_pos;
d1590 1
a1590 2
            e = _set_cursor_position (handle, (unsigned int)regs->r[4], (unsigned int *)regs->r[5],
                                      (unsigned int)regs->r[0]);
d1594 1
a1594 1
            e = _get_cursor_position (handle, (unsigned int *)regs->r[4], (unsigned int)regs->r[0]);
@


1.5
log
@Various fixes and extensions to ScrollList, plus a related fix in TextArea
and ScrollBar.

Title background colour of gadgets was either undefined or set to 0; should
be 2. Corrected. Would be apparent with 2D tools or any transparent tool
sprite set.

SELECT clicks on deselected entries in a ScrollList now deselect any other
selected items before selecting the new one.

Embedded window of TextArea and ScrollList now put in the right place. At
create time, the sizes of the current tool sprite set is also checked; this
used to be hard coded. If the tool sizes and/or Desktop scaling changes at
run-time this won't be noticed yet, as no mechanism to pass Wimp messages
to *external* gadgets exists in the Toolbox currently. Still, at least it
gets it right the next time a new instance of the gadget is created.

Flag bit ScrollList_SelectionChangingMethod_SendEvent to any of
scrolllist_select_item, scrolllist_deselect_item or scrolllist_delete_items
prompts them to send ScrollList_Selection to the client on completion. This
can help simplify client UI code for UIs which depend on what is selected
(e.g. a "Select all" button greys out if all items are selected by a
keyboard shortcut - this can now all work on just the one event handler).

Flag bit ScrollList_SelectionChangingMethod_OnAll to either of
scrolllist_select_item or scrolllist_deselect_item tells the methods to
act like a "Select all" or "Clear selection" call. This is a common client
operation and it's a lot easier for the ScrollList gadget to do it than
have the client iterate over all items.

Supports new method ScrollList_CountItems (scrolllist_count_items veneer
present in tboxlibs 0.04 or later). Returns number of entries in gadget.
Avoids clumsy situation of both the gadget and the clienty keeping track
of how many entries are present.

Note that docs.ScrollList mis-documented some flags settings. Now fixed.

Version 0.15. Not tagged
@
text
@d657 1
a657 1
        /* wimp_process_key(key); This shouldn't be called in a gadget. JBeranek */
d768 1
a768 1
                    /* wimp_process_key(key);  This shouldn't be called in a gadget. JBeranek */
a776 1
                        /* JBeranek fixes (Start) */
a782 1
                        /* JBeranek fixes (End) */
a785 1
                        /* JBeranek fixes (Start) */
a791 1
                        /* JBeranek fixes (End) */
a800 1
                    /* JBeranek fixes (Start) */
a804 1
                    /* JBeranek fixes (End) */
a981 1
    /* JBeranek fixes (Start) */
a985 1
    /* JBeranek fixes (End) */
d1133 43
a1216 1
    /* JBeranek fixes (Start) */
a1221 1
    /* JBeranek fixes (End) */
a1274 1
    /* JBeranek fixes (Start) */
a1279 1
    /* JBeranek fixes (End) */
a1307 1
    /* JBeranek fixes (Start) */
a1309 1
    /* If there's an error from replace_text return straight away */
a1311 1
    /* JBeranek fixes (End) */
a1471 1
         /* JBeranek fixes (Start) */
a1475 1
         /* JBeranek fixes (End) */
d1578 9
@


1.4
log
@TextArea_SetText now positions the caret at the beginning of the last line.

Version 0.13. Not tagged
@
text
@d19 19
a37 15
 * piers    18/06/96 Created
 * piers    02/09/96 Implemented insert text method
 * piers    20/12/96 Incorporated RLougher's textarea source
 * piers    23/12/96 Fixed selections to use drag type 9 so it doesn't need
 *                   to claim null events
 * piers    03/02/97 Implemented fade flag
 * rlougher 18/03/97 Added MemChecking code
 * rlougher 20/03/97 Fixed bug in updating insert position after
 *                   keyboard input
 * rlougher 20/03/97 Fixed set selection
 * rlougher 11/08/97 Added ability to turn scrollbars on/off
 * rlougher 01/09/97 Added ability to turn word wrap on/off
 * rlougher 04/09/97 Wordwrap can now be changed dynamically at runtime
 * rlougher 05/09/97 Scrollbars can now be turned on/off at runtime
 * rlougher 10/09/97 Keyboard selection using shift + cursor keys
d63 1
d87 3
d123 1
a123 1
	0xff,			// transparent title == no borders
d125 1
a125 1
        0,			// title_bg
d394 12
a405 3
    WindowShowObjectBlock	show_block;
    BBox			new;
    int text_xmax, text_ymax, xextent, yextent, new_y, new_x;
a407 2
    if(tdata->state & TextArea_Scrollbar_Horizontal)
        tdata->box.ymin += SCROLLBAR_SIZE;
d409 16
a424 2
    if(tdata->state & TextArea_Scrollbar_Vertical)
        tdata->box.xmax -= SCROLLBAR_SIZE;
d496 1
a496 1
        x = MAX(box.xmax - SCROLLBAR_SIZE, box.xmin);
d498 1
a498 1
        	MIN(box.ymin + SCROLLBAR_SIZE, box.ymax) : box.ymin;
d510 2
a511 2
        	MAX(box.xmax - SCROLLBAR_SIZE, box.xmin) : box.xmax;
        y = MIN(box.ymin + SCROLLBAR_SIZE, box.ymax);
d1000 1
a1000 1
            width -= SCROLLBAR_SIZE;
d1405 1
a1405 1
            wstate.visible_area.xmax -= SCROLLBAR_SIZE;
d1410 1
a1410 1
            wstate.visible_area.xmax += SCROLLBAR_SIZE;
d1423 1
a1423 1
            wstate.visible_area.ymin += SCROLLBAR_SIZE;
d1428 1
a1428 1
            wstate.visible_area.ymin -= SCROLLBAR_SIZE;
@


1.3
log
@Changed out of memory error message to not be prefixed JBERANEK.
Changed TextArea windows to be created with the NoBounds window flag set.

Version 0.11. Tagged as 'Gadgets-0_11'
@
text
@d1161 3
a1163 2
    char_pos(handle->text, handle->text->insert_pos, &caret_x, &caret_y);
    set_caret(window_handle, handle->text, caret_x, caret_y, 0, 1);
d1165 1
@


1.2
log
@* Merged in fixes from Daytona branch (tag sbrodie_Daytona_merge_19Jun98)

* Fixed 'long' #include directives.
* Removed duplicate function prototypes from TextGadget.h (use ModHdr.h
  for correct prototypes).
* Capability to build with pre- and post-5.16 versions of CMHG.
@
text
@d111 1
a111 1
        WimpWindow_NewFormat,  	// flags
d657 1
a657 2
#ifdef Daytona_BUILD
    else if (key == 0x18b)		// Copy/End (Windows-style "Delete" on Daytona)
d682 1
@


1.1
log
@Initial revision
@
text
@d29 5
d51 2
a52 2
#include "riscos_utils.h"
#include "TextGadgets.h"
d59 1
a59 1
#include "myswis.h"
d62 2
d68 6
d111 2
a112 2
        WimpWindow_NewFormat | WimpWindow_VScroll | WimpWindow_HScroll,
        			// flags
d114 3
d160 1
a160 2
// Return length of ctrl-terminated string
int string_length (char *txt)
d162 1
a162 1
   int i=0;
d164 1
a164 7
   if (!txt) return 0;
   while ((*txt>=32) || (*txt==9))
   {
       txt++;
       i++;
   }
   return i;
d167 1
a167 1
_kernel_oserror *textarea_init(void)
d169 1
a169 5
    text_area_window.body = (void*) &window_template;

    initialise_memory("TextArea workspace");

    return NULL;
d174 1
d274 44
d323 1
a323 1
    
a331 4
    char_pos(text, from, &caret_x, &caret_y);
    wimp_set_caret_position(window, -1, caret_x, -caret_y,
                            text->line_height, -1);

d337 3
a339 1
        
d357 1
d390 8
a399 2
    show_block.visible_area.xmax -= SCROLLBAR_SIZE;
    show_block.visible_area.ymin += SCROLLBAR_SIZE;
a406 1
    text_xmax = tdata->text->xmax + 10;
d408 7
a414 1
    new_x = text_xmax > xextent ? text_xmax : xextent;
d439 1
a439 1
    
d443 1
a443 1
    
d450 1
a450 1
    
d460 1
a460 1
    
d465 1
a465 1
        
d486 1
a486 1
    
d516 2
a517 2
    int                         work_xmax, work_ymax, text_xmax;
    int                         new_x = -1, new_y = -1, text_ymax;
d519 1
a519 1
    
d523 1
a523 1
        
a526 6
//        foreground = ( (((fore & 0xff0000) / 2 +
//        		(back & 0xff0000) / 2) & 0xff0000) |
//        	(((fore & 0xff00) / 2 +
//        		(back & 0xff00) / 2) & 0xff00) |
//        	(((fore & 0xff) / 2 +
//        		(back & 0xff) / 2) & 0xff) ) << 8;
d528 4
a531 1
        
d541 1
a551 1
    window_get_extent(0, tdata->object_id, &current_ext);
d554 3
a556 4
    work_xmax = current_ext.xmax;
    text_xmax = text->xmax + 10;
    if(text_xmax > work_xmax)
        new_x = text_xmax;
d559 2
a560 3
        int xextent = state.visible_area.xmax - state.visible_area.xmin;
        if((text_xmax < work_xmax) && (xextent < work_xmax))
            new_x = text_xmax > xextent ? text_xmax : xextent;
a562 1
    work_ymax = -current_ext.ymin;
d564 2
a565 9

    if(text_ymax > work_ymax)
        new_y = text_ymax;
    else
    {
        int yextent = state.visible_area.ymax - state.visible_area.ymin;
        if((text_ymax < work_ymax) && (yextent < work_ymax))
            new_y = text_ymax > yextent ? text_ymax : yextent;
    }
d583 3
a585 1
    if((new_x != -1) || (new_y != -1))
d587 2
a588 12
        BBox new;

        if(new_x == -1)
            new_x = work_xmax;
        else
            if(new_y == -1)
                new_y = work_ymax;

        new.xmin = 0;
        new.xmax = new_x;
        new.ymin = -new_y;
        new.ymax = 0;
d590 1
a590 1
        window_set_extent(0, tdata->object_id, &new);
a613 35
static void set_caret(int win, Text *text, int caret_x, int caret_y)
{
    WimpGetWindowStateBlock     state;
    int xmax, ymax, new_x = -1, new_y = -1;

    state.window_handle = win;
    wimp_get_window_state(&state);

    xmax = state.visible_area.xmax - state.visible_area.xmin + state.xscroll;
    ymax = state.visible_area.ymax - state.visible_area.ymin - state.yscroll;

    if(xmax < caret_x)
        new_x = caret_x - xmax + state.xscroll + 10;
    else
        if(state.xscroll > caret_x)
            new_x = caret_x;

    if(ymax < caret_y)
        new_y = caret_y - ymax - state.yscroll;
    else
        if(-state.yscroll > (caret_y - text->line_height))
            new_y = (caret_y - text->line_height);

    if((new_x != -1) || (new_y != -1))
    {
        state.xscroll = new_x == -1 ? state.xscroll : new_x;
        state.yscroll = new_y == -1 ? state.yscroll : -new_y;
        wimp_open_window((WimpOpenWindowBlock *) &state);
    }

    wimp_set_caret_position(win, -1, caret_x, -caret_y,
                            text->line_height, -1);
}


d624 2
d627 2
d630 1
d632 1
a632 1
    if((key == 8) || (key == 127))
d654 27
a680 1
        set_caret(win, text, caret_x, caret_y);
d683 6
d691 1
a691 1
        switch(key)
d693 1
a693 1
            case 0x18c:		// Left
d698 1
a698 1
            case 0x18d:		// Right
d705 1
a705 1
            case 0x18e:		// Down
d711 7
a717 1
            case 0x18f:		// Up
d723 1
a723 1
            case 13:
d727 13
a739 2
                if(((key < 32) || (key > 255) || (key == 126)) &&
                    (key != 10) && (key != 9))
d741 1
d747 3
a749 1
                        replace_text(text, text->sel_stop_pos,
d752 5
d759 2
a760 1
                        replace_text(text, text->insert_pos,
d763 7
a769 1
                        new_pos = text->insert_pos + 1;
d776 6
a781 2
                    insert_text(text, str, &first_line, &line_delta);
                    last_line = first_line;
d783 1
d788 1
a788 1
                    set_caret(win, text, caret_x, caret_y);
d793 1
a793 1
                    set_caret(win, text, caret_x, caret_y);
d799 34
a832 4
            if(text->sel_stop_pos != -1)
                deselect(tdata);
            close_insertion(text);
            create_insertion(text, new_pos);
d834 1
a834 1
            set_caret(win, text, caret_x, caret_y);
d850 1
a850 1
        
a853 6
//        foreground = ( (((fore & 0xff0000) / 2 +
//        		(back & 0xff0000) / 2) & 0xff0000) |
//        	(((fore & 0xff00) / 2 +
//        		(back & 0xff00) / 2) & 0xff00) |
//        	(((fore & 0xff) / 2 +
//        		(back & 0xff) / 2) & 0xff) ) << 8;
d855 4
a858 1
        
d868 1
d901 1
a909 1
    Scrollbar			sdata;
d919 14
a944 1
//    tb->event = tdata->event ? tdata->event : TextArea_StateChanged;
a953 1
    tb->box = tdata->hdr.box;
d959 10
a968 1
    create_text(0, tb->font_handle, &tb->text);
d970 2
a971 1
    *icons = my_icons;
d973 5
a977 1
    add_redraw_handler(tb);
d979 1
a979 1
    if (tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
d981 12
a992 7
        if (tdata->hdr.flags & TextArea_Scrollbar_Vertical)
            sdata.hdr.box.xmax -= SCROLLBAR_SIZE;
    }
    if (tdata->hdr.flags & TextArea_Scrollbar_Vertical)
    {
        if (tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
            sdata.hdr.box.ymin += SCROLLBAR_SIZE;
d994 4
d1018 5
d1106 1
a1106 1
        set_caret(win, text, xpos, ypos);
d1142 1
d1153 2
a1154 1
    replace_text(handle->text, 0, -1, text,
d1156 4
d1162 1
a1162 1
    set_caret(window_handle, handle->text, caret_x, caret_y);
d1198 1
d1211 7
a1217 2
    replace_text(tdata->text, index, index, buffer,
        		&first_line, &last_line, &line_delta);
d1220 1
a1220 1
    set_caret(window_handle, tdata->text, caret_x, caret_y);
d1233 1
d1240 1
a1240 1
        
d1246 2
a1247 1
    replace_text(tdata->text, start, end, buffer,
d1249 4
d1255 1
a1255 1
    set_caret(window_handle, tdata->text, caret_x, caret_y);
d1340 1
a1340 1
    set_caret(window_handle, handle->text, caret_x, caret_y);
d1348 100
d1463 1
a1463 1
            handle->state = regs->r[4];
d1543 1
d1545 3
a1547 1
#ifdef MemCheck_MEMCHECK
d1550 1
@


1.1.1.1
log
@The Java directory contains the sources for the Java support modules
(TextGadget, etc.) and the makefiles to complete the Java ROM build
under RiscOS.

@
text
@@


1.1.1.2
log
@Removed string_length
@
text
@d144 13
@


1.1.1.3
log
@Stopped textArea grabbing focus when focus was held by another window (unless
mouse clicked).
@
text
@d562 1
a562 1
static void set_caret(int win, Text *text, int caret_x, int caret_y, int force)
a564 1
    WimpGetCaretPositionBlock 	block;
d592 1
a592 3
    wimp_get_caret_position(&block);
    if (force || block.window_handle == win)
        wimp_set_caret_position(win, -1, caret_x, -caret_y,
d632 1
a632 1
        set_caret(win, text, caret_x, caret_y, 1);
d697 1
a697 1
                    set_caret(win, text, caret_x, caret_y, 1);
d702 1
a702 1
                    set_caret(win, text, caret_x, caret_y, 1);
d713 1
a713 1
            set_caret(win, text, caret_x, caret_y, 1);
d947 1
a947 1
        set_caret(win, text, xpos, ypos, 1);
d997 1
a997 1
    set_caret(window_handle, handle->text, caret_x, caret_y, 0);
d1049 1
a1049 1
    set_caret(window_handle, tdata->text, caret_x, caret_y, 0);
d1078 1
a1078 1
    set_caret(window_handle, tdata->text, caret_x, caret_y, 0);
d1163 1
a1163 1
    set_caret(window_handle, handle->text, caret_x, caret_y, 0);
@


1.1.1.4
log
@Added shading to ScrollLists, and changed look of textareas if built with -DDAYTONA_BUILD
@
text
@a99 1
#ifndef DAYTONA_BUILD
a100 3
#else
	0xff,			// transparent title == no borders
#endif
d260 1
a260 1

d278 1
a278 1

d366 1
a366 1

d370 1
a370 1

d377 1
a377 1

d387 1
a387 1

d392 1
a392 1

d413 1
a413 1

d446 1
a446 1

d450 1
a450 1

d461 1
a461 4

#ifdef DAYTONA_BUILD
	background = tdata->background;
#else
a470 1
#endif
d732 1
a732 1

d743 1
a743 1

d1071 1
a1071 1

a1268 1
    toolbox_delete_object(0, handle->object_id);
@


1.1.1.5
log
@Implemented tabbing, word-wrapping, keyboard selection, dynamic scrollbars, etc.
@
text
@a28 5
 * rlougher 11/08/97 Added ability to turn scrollbars on/off
 * rlougher 01/09/97 Added ability to turn word wrap on/off
 * rlougher 04/09/97 Wordwrap can now be changed dynamically at runtime
 * rlougher 05/09/97 Scrollbars can now be turned on/off at runtime
 * rlougher 10/09/97 Keyboard selection using shift + cursor keys
d98 2
a99 1
        WimpWindow_NewFormat,  	// flags
a147 1
//FILE *debug;
a154 2
//    debug = fopen("debug", "w");
    
d334 2
d342 2
a343 1
    
d345 2
a346 8
    if(tdata->state & TextArea_WordWrap)
        new_x = xextent;
    else
    {
        text_xmax = tdata->text->xmax + 10;
        new_x = text_xmax > xextent ? text_xmax : xextent;
    }
    
d447 2
a448 2
    int                         xextent, yextent, text_xmax;
    int                         new_x, new_y, text_ymax;
d489 1
d491 5
a495 4
    
    xextent = state.visible_area.xmax - state.visible_area.xmin;
    if(tdata->state & TextArea_WordWrap)
        new_x = xextent;
d498 15
a512 2
        text_xmax = text->xmax + 10;
        new_x = text_xmax > xextent ? text_xmax : xextent;
a513 4
    
    text_ymax =text->no_of_lines * text->line_height;
    yextent = state.visible_area.ymax - state.visible_area.ymin;
    new_y = text_ymax > yextent ? text_ymax : yextent;
a529 2
    
    window_get_extent(0, tdata->object_id, &current_ext);
d531 1
a531 1
    if((new_x != current_ext.xmax) || (new_y != -current_ext.ymin))
d533 12
a544 2
        current_ext.xmax = new_x;
        current_ext.ymin = -new_y;
d546 1
a546 1
        window_set_extent(0, tdata->object_id, &current_ext);
d581 1
a581 1
      
a597 1
    
a618 2
    {
        wimp_process_key(key);
d620 1
a620 2
    }
    
d648 1
a648 1
        switch(key & ~0x10)
a679 2
                {
                    wimp_process_key(key);
d681 1
a681 2
                }
                    
d694 1
a694 2
                          close_insertion(text);
                          create_insertion(text, text->insert_pos + 1);
d700 4
a703 2
                    insert_text(text, str, &first_line, &last_line, &line_delta);
                    
d719 4
a722 32
            if(key & 0x10)
            {
                int old_line = text->insert_line;
                int old_pos = text->insert_pos;
            
                close_insertion(text);
                create_insertion(text, new_pos);
                
                if((old_line != text->insert_line) || (old_pos != text->insert_pos))
                {
            
                    if(text->sel_stop_pos == -1)
                    {
                        text->sel_stop_pos = old_pos;
                        text->sel_stop_line = old_line;
                    }
                    
                    if(old_line < text->insert_line)
                        update_display(tdata, old_line, text->insert_line, 0);
                    else
                        update_display(tdata, text->insert_line, old_line, 0);
                }
            }
            else
            {
                if(text->sel_stop_pos != -1)
                    deselect(tdata);
                    
                close_insertion(text);
                create_insertion(text, new_pos);
            }
               
d751 1
a751 4
        
#ifdef DAYTONA_BUILD
	background = tdata->background;
#else
a760 1
#endif
a810 20
    tb->box = tdata->hdr.box;

#ifndef DAYTONA_BUILD
    if(tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
    {
        tb->box.ymin += SCROLLBAR_SIZE;
        ((WindowTemplate *)text_area_window.body)->window.flags |= WimpWindow_HScroll;
    }
    else
        ((WindowTemplate *)text_area_window.body)->window.flags &= ~WimpWindow_HScroll;

    if(tdata->hdr.flags & TextArea_Scrollbar_Vertical)
    {
        tb->box.xmax -= SCROLLBAR_SIZE;
        ((WindowTemplate *)text_area_window.body)->window.flags |= WimpWindow_VScroll;
    }
    else
        ((WindowTemplate *)text_area_window.body)->window.flags &= ~WimpWindow_VScroll;
#endif
    
d833 1
d840 1
a840 11
    
    if(tb->state & TextArea_WordWrap)
    {
        int width = tb->box.xmax - tb->box.xmin - 10;
        
        _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1), width > 0 ? width : 0, 0,
                                   &tb->text->margin);
    }
    else
        tb->text->margin = 0xffffff;
        
a1181 92
static void _set_state(PrivateTextArea *handle, unsigned int state)
{
    WimpGetWindowStateBlock wstate;
    BBox                    current_ext;
    unsigned int            changed = state ^ handle->state;
    int                     caret_x, caret_y, win;
    int                     parent, alignment;
    int                     xextent, yextent, new_x, new_y, text_ymax;
    
    if(!changed) return;
    
    handle->state = state;
    
    window_get_wimp_handle(0, handle->object_id, &win);
    wstate.window_handle = win;
       
    _swix(Wimp_GetWindowState,_IN(1)|_IN(2)|_OUT(3)|_OUT(4), &wstate,
                              0x4B534154 /* TASK */, &parent, &alignment);
    
    if(changed & TextArea_Scrollbar_Vertical)
    {
        if(state & TextArea_Scrollbar_Vertical)
        {
            wstate.flags |= WimpWindow_VScroll;
            wstate.visible_area.xmax -= SCROLLBAR_SIZE;
        }
        else
        {
            wstate.flags &= ~WimpWindow_VScroll;
            wstate.visible_area.xmax += SCROLLBAR_SIZE;
        }        
        alignment |= 1;
        
        if(state & TextArea_WordWrap)
            changed |= TextArea_WordWrap;
    }
    
    if(changed & TextArea_Scrollbar_Horizontal)
    {
        if(state & TextArea_Scrollbar_Horizontal)
        {
            wstate.flags |= WimpWindow_HScroll;
            wstate.visible_area.ymin += SCROLLBAR_SIZE;
        }
        else
        {
            wstate.flags &= ~WimpWindow_HScroll;
            wstate.visible_area.ymin -= SCROLLBAR_SIZE;
        }
        alignment |= 1;
    }
    
    xextent = wstate.visible_area.xmax - wstate.visible_area.xmin;
    
    if(changed & TextArea_WordWrap)
    {      
        if(state & TextArea_WordWrap)
            _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1),
                              xextent > 10 ? xextent - 10 : xextent, 0, &handle->text->margin);
        else
            handle->text->margin = 0xffffff;
            
         compose_text(handle->text);
    }
    
    if(state & TextArea_WordWrap)
        new_x = xextent;
    else
        new_x = (handle->text->xmax + 10) > xextent ? handle->text->xmax + 10 : xextent;
    
    yextent = wstate.visible_area.ymax - wstate.visible_area.ymin;
    text_ymax = handle->text->no_of_lines * handle->text->line_height;
    new_y = text_ymax > yextent ? text_ymax : yextent;
        
    window_get_extent(0, handle->object_id, &current_ext);

    if((new_x != current_ext.xmax) || (new_y != -current_ext.ymin))
    {
        current_ext.xmax = new_x;
        current_ext.ymin = -new_y;

        window_set_extent(0, handle->object_id, &current_ext);
    }

    _swix(Wimp_OpenWindow,_INR(1,4), &wstate, 0x4B534154 /* TASK */,
                          parent, alignment);
                          
    char_pos(handle->text, handle->text->insert_pos, &caret_x, &caret_y);
    set_caret(win, handle->text, caret_x, caret_y, 0);                     
    window_force_redraw(0, handle->object_id, &redraw_all_box);
}

d1197 1
a1197 1
            _set_state(handle, regs->r[4]);
@


1.1.1.6
log
@Default text specified in ResEd now appears...
@
text
@d152 2
d160 2
d468 6
d510 1
a510 1
    text_ymax = text->no_of_lines * text->line_height;
d769 6
a898 3
    if(tdata->text)
       insert_text(tb->text, tdata->text, &f, &l, &d);    
    
d1258 1
a1258 2

#ifndef DAYTONA_BUILD  
a1290 1
#endif
@


1.1.1.7
log
@Removed one too many lines before checking it in :-)
@
text
@d884 1
a884 4
    {
        int f, l, d;
        insert_text(tb->text, tdata->text, &f, &l, &d);    
    }
@


1.1.1.8
log
@Fixed a couple of data aborts, made all gadgets not quit if tasks are
still using them and freed all memory when they do quit.
@
text
@a61 2
extern void print_info(FILE *);

a160 5
int textarea_active(void)
{
    return text_area_list != NULL;
}

a162 1
        
a301 1
    
d308 1
a308 1
          
d316 1
a316 1
        
a333 4
    
#ifndef DAYTONA_BUILD
    if(tdata->state & TextArea_Scrollbar_Horizontal)
        tdata->box.ymin += SCROLLBAR_SIZE;
a334 4
    if(tdata->state & TextArea_Scrollbar_Vertical)
        tdata->box.xmax -= SCROLLBAR_SIZE;
#endif
    
a805 3

FILE *debug = NULL;

d814 1
d828 2
d831 1
d836 2
d839 1
d856 1
a875 2
        if(tb->state & TextArea_Scrollbar_Vertical)
            width -= SCROLLBAR_SIZE;
d882 1
a882 1
    
d886 1
a886 5
        
        if(!debug) debug = fopen("adfs::rlougher.$.debug5", "w");
        
        insert_text(tb->text, tdata->text, &f, &l, &d);  
        dump_object(debug, tb->text);  
d893 11
a1006 1

a1423 2

    delete_text(handle->text);
@


1.1.1.9
log
@Twiddles for Daytona project.
@
text
@a67 6
#ifdef DAYTONA_BUILD
#define IconHigh_Start 0x4e702
#define IconHigh_Start_HighlightOut 4
#define IconHigh_Direction_Up 1
#endif

d106 1
a106 1
#ifndef DAYTONA_BUILD_NOBORDER
d170 1
a170 1

d310 1
a310 1

d317 1
a317 1

d325 1
a325 1

d343 1
a343 1

d351 1
a351 1

d360 1
a360 1

d369 1
a369 1

d483 1
a483 1
#ifdef DAYTONA_BUILD_FADEWHITE
d507 1
a507 1

d516 1
a516 1

d536 1
a536 1

d579 1
a579 1

d596 1
a596 1

a618 1
#ifndef DAYTONA_BUILD
a619 1
#endif
d622 1
a622 1

a647 7
#ifdef DAYTONA_BUILD
    else if (key == 0x19a)		// Shift-Tab
    {
        _swix (IconHigh_Start, _INR (0,1), IconHigh_Start_HighlightOut, IconHigh_Direction_Up);
        return;
    }
#endif
a670 6
#ifdef DAYTONA_BUILD
                if (-(event->caret.yoffset + text->line_height +1) < 0) {
                   _swix (IconHigh_Start, _INR (0,1), IconHigh_Start_HighlightOut, IconHigh_Direction_Up);
                   return;
                }
#endif
a682 1
#ifndef DAYTONA_BUILD
a683 1
#endif
d686 1
a686 1

d707 1
a707 1

a722 1
#ifndef DAYTONA_BUILD
d727 1
a727 1

d730 1
a730 1

d733 1
a733 1

d739 1
a739 1

a746 1
#endif
d750 1
a750 1

d754 1
a754 1

d777 2
a778 2

#ifdef DAYTONA_BUILD_FADEWHITE
d856 1
a856 1

d884 1
a884 1

a887 1

d890 1
a890 1

d896 1
a896 1

d900 1
a900 1

d902 3
a904 3

        insert_text(tb->text, tdata->text, &f, &l, &d);
        dump_object(debug, tb->text);
d906 1
a906 1

a929 5
#ifdef DAYTONA_BUILD
    if (tdata->state & Gadget_Faded)
       return NULL;
#endif

d1246 1
a1246 1

d1248 1
a1248 1

d1250 1
a1250 1

d1253 1
a1253 1

d1257 1
a1257 1
#ifndef DAYTONA_BUILD
d1269 1
a1269 1
        }
d1271 1
a1271 1

d1275 1
a1275 1

d1291 1
a1291 1

d1293 1
a1293 1

d1295 1
a1295 1
    {
d1301 1
a1301 1

d1304 1
a1304 1

d1309 1
a1309 1

d1313 1
a1313 1

d1326 1
a1326 1

d1328 1
a1328 1
    set_caret(win, handle->text, caret_x, caret_y, 0);
@


1.1.1.10
log
@Moved a MemCheck_UnRegisterMiscBlock by one line - was causing spurious
memory violations to be reported by MemCheck...
@
text
@d849 2
d927 2
d930 1
a1459 2
    delete_text(handle->text);
    
d1464 1
@


1.1.1.11
log
@Fixed bug in re-composing text after set_font...
@
text
@a924 3
#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(tdata->text, strlen(tdata->text));
#endif
a925 4
        
#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(tdata->text);
#endif
d1272 1
a1272 1
    
@


1.1.1.12
log
@Changed _insert_text to call set_caret, forcing window to scroll.  Also
uses  more efficient insert_text.  Changes to set_caret to allow
invisibility.
@
text
@a275 44
static void set_caret(int win, Text *text, int caret_x, int caret_y, int force, int invisible)
{
    WimpGetWindowStateBlock     state;
    int xmax, ymax, new_x = -1, new_y = -1;

    state.window_handle = win;
    wimp_get_window_state(&state);

    xmax = state.visible_area.xmax - state.visible_area.xmin + state.xscroll;
    ymax = state.visible_area.ymax - state.visible_area.ymin - state.yscroll;

    if(xmax < caret_x)
        new_x = caret_x - xmax + state.xscroll + 10;
    else
        if(state.xscroll > caret_x)
            new_x = caret_x;

    if(ymax < caret_y)
        new_y = caret_y - ymax - state.yscroll;
    else
        if(-state.yscroll > (caret_y - text->line_height))
            new_y = (caret_y - text->line_height);

    if((new_x != -1) || (new_y != -1))
    {
        state.xscroll = new_x == -1 ? state.xscroll : new_x;
        state.yscroll = new_y == -1 ? state.yscroll : -new_y;

        wimp_open_window((WimpOpenWindowBlock *) &state);
    }

    if(!force)
    {
        WimpGetCaretPositionBlock block;
        
        wimp_get_caret_position(&block);
        if(block.window_handle != win)
            return;
    }
    
    wimp_set_caret_position(win, -1, caret_x, -caret_y,
                            text->line_height | (invisible ? 1<<25 : 0), -1);
}

d289 5
a293 1
                            
a299 2
    char_pos(text, text->insert_pos, &caret_x, &caret_y);
    set_caret(window, text, caret_x, caret_y, 1, 1);
d574 39
d653 1
a653 1
        set_caret(win, text, caret_x, caret_y, 1, 0);
d735 1
a735 1
                    set_caret(win, text, caret_x, caret_y, 1, 0);
d740 1
a740 1
                    set_caret(win, text, caret_x, caret_y, 1, 0);
d781 1
a781 1
            set_caret(win, text, caret_x, caret_y, 1, 0);
d1046 2
a1047 1
        set_caret(win, text, xpos, ypos, 1, 0);
d1097 1
a1097 1
    set_caret(window_handle, handle->text, caret_x, caret_y, 0, 1);
a1125 2
FILE *debug = NULL;

a1142 5
    if(!debug)
        debug = fopen("adfs::rlougher.$.crappy", "w");
       
    fprintf(debug, "Inserting text at: %d...\n", index);
            
d1145 1
a1145 4
    close_insertion(tdata->text);
    create_insertion(tdata->text, index);
    
    insert_text(tdata->text, buffer,
a1147 5
//    replace_text(tdata->text, index, index, buffer,
//    			&first_line, &last_line, &line_delta);

    fprintf(debug, "Returns  first_line %d last_line %d line_delta %d\n", first_line, last_line, line_delta);
    
d1149 1
a1149 1
    set_caret(window_handle, tdata->text, caret_x, caret_y, 0, 1);
d1178 1
a1178 1
    set_caret(window_handle, tdata->text, caret_x, caret_y, 0, 0);
d1263 1
a1263 1
    set_caret(window_handle, handle->text, caret_x, caret_y, 0, 0);
d1361 1
a1361 1
    set_caret(win, handle->text, caret_x, caret_y, 0, 0);
@


1.1.1.13
log
@Debug stuff I'd forgotten about again!!
@
text
@d1128 2
d1146 6
a1151 1
           
d1154 2
a1155 5
    if(tdata->text->insert_pos != index)
    {
        close_insertion(tdata->text);
        create_insertion(tdata->text, index);
    }
d1157 2
a1158 1
    insert_text(tdata->text, buffer, &first_line, &last_line, &line_delta);
d1160 5
@


1.1.1.9.2.1
log
@Made a single, unified Makefile.  myswis.h renamed to ModHdr.h so that it can be
automatically generated by CMHG.  Changed DAYTONA_BUILD flag to Daytona_BUILD so
that it can be automatically defined in the Makefile using the build
environment's System variable (called ${SYSTEM} in Makefiles).
@
text
@d59 1
a59 1
#include "ModHdr.h"
d68 1
a68 1
#ifdef Daytona_BUILD
d112 1
a112 1
#ifndef Daytona_BUILD_NOBORDER
d350 1
a350 1
#ifndef Daytona_BUILD
d489 1
a489 1
#ifdef Daytona_BUILD_FADEWHITE
d625 1
a625 1
#ifndef Daytona_BUILD
d656 1
a656 1
#ifdef Daytona_BUILD
d686 1
a686 1
#ifdef Daytona_BUILD
d704 1
a704 1
#ifndef Daytona_BUILD
d746 1
a746 1
#ifndef Daytona_BUILD
d803 1
a803 1
#ifdef Daytona_BUILD_FADEWHITE
d870 1
a870 1
#ifndef Daytona_BUILD
d956 1
a956 1
#ifdef Daytona_BUILD
d1288 1
a1288 1
#ifndef Daytona_BUILD
@


1.1.1.9.2.2
log
@Manually merge in v0.06 bugfixes from Spinner branch, add CLR
functionality and tilde support, reinstate region select, and explicitly
disallow Ctrl-I (tab support is not functional in TextGadget anyway).
@
text
@d631 1
a631 1
    if((key == 8) || (key == 127))	// Backspace and Delete respectively
a656 25
    else if (key == 0x18b)		// Copy/End (Windows-style "Delete" on Daytona)
    {
        if(text->sel_stop_pos != -1)
        {
            if(text->sel_stop_pos < text->insert_pos)
                replace_text(text, text->sel_stop_pos, text->insert_pos,
                             "", &first_line, &last_line, &line_delta);
            else
                replace_text(text, text->insert_pos, text->sel_stop_pos,
                             "", &first_line, &last_line, &line_delta);

            text->sel_stop_pos = -1;
        }
        else
        {
            if(text->insert_pos >= get_text_size (text))
                return;

            replace_text(text, text->insert_pos, text->insert_pos + 1, "",
                         &first_line, &last_line, &line_delta);
        }
        char_pos(text, text->insert_pos, &caret_x, &caret_y);
        set_caret(win, text, caret_x, caret_y, 1);
        update_display(tdata, first_line, last_line, line_delta);
    }
d667 1
a667 1
            case 0x18c:			// Left
d672 1
a672 1
            case 0x18d:			// Right
d679 1
a679 1
            case 0x18e:			// Down
d685 1
a685 1
            case 0x18f:			// Up
d697 1
a697 1
            case 13:			// Return
d701 2
a702 11
                if (((key < 32) || (key > 255)
                    || (key == 127))
                // This used to be 126, but Rob himself can't remember why he rejected tildes.
                // Assumed to be a typo for 127 (Delete), even though this is trapped above.
#ifndef Daytona_BUILD
                // Tab handling doesn't seem to be very stable!
                // It would be possible to generate key 9 by using Ctrl-I on a PS/2 keyboard,
                // so play it safe and reject these...
                   && (key != 9)
#endif
                   && (key != 10))
d746 1
a746 1
#ifndef Daytona_BUILD_NOSELECTIONS
d849 2
d927 2
a928 3
#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(tdata->text, strlen(tdata->text));
#endif
d930 1
a930 4

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(tdata->text);
#endif
a1459 2
    delete_text(handle->text);

d1464 1
@


1.1.1.9.2.3
log
@  Improved textarea's handling of low memory conditions.  Should now act in
a slightly better way when it uses up all available memory.
@
text
@d164 3
a166 1
    return initialise_memory("TextArea workspace");
a622 2
    _kernel_oserror *er;

d748 1
a748 2
                    {
                        er = replace_text(text, text->sel_stop_pos,
a750 3
                        if (er)
                          return;
                    }
d753 1
a753 1
                        er = replace_text(text, text->insert_pos,
a755 3
                        if (er)
                          return;

d763 1
a763 5
                {
                    er = insert_text(text, str, &first_line, &last_line, &line_delta);
                    if (er)
                      return;
                }
d940 1
a940 3
    e = create_text(0, tb->font_handle, &tb->text);
    if (e)
      return e;
d962 1
a962 3
        e = insert_text(tb->text, tdata->text, &f, &l, &d);
        if (e)
          return e;
a1116 1
    _kernel_oserror *er;
d1127 1
a1127 1
    er = replace_text(handle->text, 0, -1, text,
a1128 2
    if (er)
      return er;
a1166 1
    _kernel_oserror *er;
d1179 2
a1180 4
    er = replace_text(tdata->text, index, index, buffer,
                	&first_line, &last_line, &line_delta);
    if (er)
      return er;
a1195 1
    _kernel_oserror *er;
d1208 1
a1208 1
    er = replace_text(tdata->text, start, end, buffer,
a1209 2
    if (er)
      return er;
a1312 1
    _kernel_oserror        *er;
d1369 1
a1369 3
         er = compose_text(handle->text);
         if (er)
           return;
@


1.1.1.9.2.4
log
@Added comments to the bits that I fixed in c/TextArea and c/TextMan in
preparation for eventual merging to the trunk.
@
text
@d625 3
a627 1
        /* wimp_process_key(key); This shouldn't be called in a gadget. JBeranek */
d738 3
a740 1
                    /* wimp_process_key(key);  This shouldn't be called in a gadget. JBeranek */
a748 1
                        /* JBeranek fixes (Start) */
a751 1
                        /* if there's an error from replace_text return straight away */
a753 1
                        /* JBeranek fixes (End) */
a756 1
                        /* JBeranek fixes (Start) */
a759 1
                        /* if there's an error from replace_text return straight away */
a761 1
                        /* JBeranek fixes (End) */
a770 1
                    /* JBeranek fixes (Start) */
a771 1
                    /* if there's an error from insert_text return straight away */
a773 1
                    /* JBeranek fixes (End) */
a950 1
    /* JBeranek fixes (Start) */
a951 1
    /* If there's an error from create_text return straight away */
a953 1
    /* JBeranek fixes (End) */
a1142 1
    /* JBeranek fixes (Start) */
a1144 1
    /* If there's an error from replace_text return straight away */
a1146 1
    /* JBeranek fixes (End) */
a1197 1
    /* JBeranek fixes (Start) */
a1199 1
    /* If there's an error from replace_text return straight away */
a1201 1
    /* JBeranek fixes (End) */
a1229 1
    /* JBeranek fixes (Start) */
a1231 1
    /* If there's an error from replace_text return straight away */
a1233 1
    /* JBeranek fixes (End) */
a1393 1
         /* JBeranek fixes (Start) */
a1394 1
         /* If there's an error from compose_text return straight away */
a1396 1
         /* JBeranek fixes (End) */
@

head	1.16;
access;
symbols
	Gadgets-0_44:1.16
	Gadgets-0_43:1.16
	Gadgets-0_42:1.16
	Gadgets-0_41:1.16
	Gadgets-0_40:1.16
	Gadgets-0_39:1.16
	Gadgets-0_38:1.16
	Gadgets-0_37:1.16
	Gadgets-0_36:1.15
	Gadgets-0_35:1.14
	Gadgets-0_34:1.14
	Gadgets-0_33:1.13
	Gadgets-0_32:1.13
	Gadgets-0_31:1.12
	Gadgets-0_30:1.11
	Gadgets-0_29:1.11
	Gadgets-0_28:1.11
	RO_5_07:1.11
	Gadgets-0_27:1.11
	Gadgets-0_26:1.10
	Gadgets-0_25:1.10
	Gadgets-0_24:1.9
	Gadgets-0_23:1.9
	Gadgets-0_22:1.9
	Gadgets-0_21:1.6
	Gadgets-0_20:1.5
	Gadgets-0_19:1.5
	Gadgets-0_18:1.4
	Gadgets-0_17:1.3
	Gadgets-0_16:1.3
	Gadgets-0_15:1.3
	sforrest_daytona_appflash-0_31:1.1.1.2.2.1
	Gadgets-0_14:1.2
	mjrobert_Java_26_08_98:1.1.1.4
	blaughto_daytona_appflash-0_30:1.1.1.2.2.1
	blaughto_daytona_appflash-0_29:1.1.1.2.2.1
	blaughto_daytona_appflash-0_28:1.1.1.2.2.1
	Gadgets-0_11:1.2
	sbrodie_TextGadgets_merged_19Jun98:1.2
	sbrodie_Daytona_merge_19Jun98:1.1.1.2.2.1
	sbrodie_Spin_merge_18Jun98:1.1.1.4
	jberanek_gadgets-0_08:1.1.1.2.2.1
	Gadgets-0_10-1_1_2_2:1.1.1.4
	blaughto_daytona_appflash-0_27:1.1.1.2.2.1
	blaughto_daytona_appflash-0_26:1.1.1.2.2.1
	blaughto_daytona_appflash-0_25:1.1.1.2.2.1
	blaughto_daytona_appflash-0_24:1.1.1.2.2.1
	blaughto_daytona_appflash-0_23:1.1.1.2.2.1
	blaughto_daytona_appflash-0_21:1.1.1.2.2.1
	blaughto_daytona_appflash-0_20:1.1.1.2.2.1
	blaughto_daytona_appflash-0_19:1.1.1.2.2.1
	jberanek_gadgets-0_07:1.1.1.2.2.1
	blaughto_daytona_appflash-0_18:1.1.1.2.2.1
	mrison_gadgets-0_06:1.1.1.2.2.1
	pwombwel_0_09:1.1.1.4
	mrison_gadgets-0_05:1.1.1.2.2.1
	Daytona:1.1.1.2.0.2
	Daytona_bp:1.1.1.2
	Spinner_RCA116:1.1.1.1
	Spinner_B20_2:1.1.1.1
	Spinner_19_3:1.1.1.1
	Spinner_B18:1.1.1.1
	Spinner_B17:1.1.1.1
	Spinner_B15:1.1.1.1
	Spinner_B14:1.1.1.1
	Spinner_B13:1.1.1.1
	Spinner_B12:1.1.1.1
	Spinner_B10:1.1.1.1
	Initial:1.1.1.1
	Spinner:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2013.08.30.21.32.36;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	Ah6FHegdauBDyw3x;

1.15
date	2013.08.30.19.34.37;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	cFJZhP2Bmu3bUv3x;

1.14
date	2012.01.14.17.17.59;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	I6w6cgQsKF85faPv;

1.13
date	2011.06.25.22.38.48;	author jlee;	state Exp;
branches;
next	1.12;
commitid	SJmoual8pfcHx6pv;

1.12
date	2010.02.28.10.40.27;	author rsprowson;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.16.10.57.55;	author rsprowson;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.16.17.37.57;	author blaughto;	state Exp;
branches;
next	1.9;

1.9
date	99.06.23.12.10.20;	author pgoodlif;	state Exp;
branches;
next	1.8;

1.8
date	99.06.23.11.54.13;	author pgoodlif;	state Exp;
branches;
next	1.7;

1.7
date	99.06.21.07.46.10;	author pgoodlif;	state Exp;
branches;
next	1.6;

1.6
date	99.06.18.11.13.12;	author pgoodlif;	state Exp;
branches;
next	1.5;

1.5
date	99.04.20.16.29.12;	author pwombwel;	state Exp;
branches;
next	1.4;

1.4
date	99.04.15.13.29.06;	author pwombwel;	state Exp;
branches;
next	1.3;

1.3
date	99.03.26.12.25.12;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	98.06.19.12.47.49;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	97.05.13.16.25.53;	author rlougher;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.13.16.25.53;	author rlougher;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.12.16.12.54.52;	author rlougher;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	98.01.19.19.20.52;	author pwombwel;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.02.16.14.38.49;	author pwombwel;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	97.12.16.17.19.46;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Internationalised
Supporting code borrowed from 'Iconbar' toolbox module.
Tested in a ROM build and RAM build, triggering one error message and checking the dynamic area in task manager.

Version 0.37. Tagged as 'Gadgets-0_37'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Title:   Scrollbar.c
 * Purpose: Scrollbar gadget for textgadgets module
 *
 * Revision History
 * piers    12/07/96 Created
 * piers    26/09/96 Rewritten to use nested windows rather than drawing
 *                   scrollbar manually
 * piers    20/11/96 Got around a bug in the toolbox where if a gadget isn't
 *                   made up of icons, it creates new ones. Passing a NULL
 *                   list fails, but passing an empty list containing -1 works.
 * piers    19/01/98 Added dragging support
 * ADH      24/03/99 Set title_bg to 2 rather than leaving it uninitialised.
 *                   Put scroll_inner and scroll_outer the right way around.
 * pete     18/6/99  Added fading support.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "macros.h"
#include "messages.h"
#include "twimp.h"
#include "objects/gadgets.h"

#include "glib.h"
#include "TextGadget.h"
#include "ScrollbarP.h"
#include "Utils.h"

#ifdef MemCheck_MEMCHECK
#include "MemCheck:MemCheck.h"
#endif

typedef struct
{
    unsigned int	flags;
    wimp_Bbox		box;
    unsigned int	min;
    unsigned int	max;
    unsigned int	value;
    unsigned int	visible;
    unsigned int	line_inc;
    unsigned int	page_inc;
} ScrollbarPlotInfo;

static int my_icons[] = {-1};

static PrivateScrollbar **scrollbar_list = NULL;

static _kernel_oserror *add_redraw_handler(PrivateScrollbar *tb)
{

    if (scrollbar_list == NULL)
    {
        if ( (scrollbar_list = malloc(sizeof(PrivateScrollbar*) * 2)) ==NULL)
            return make_error(TextGadgets_BarAllocFailed, 0);

        scrollbar_list[0] = tb;
        scrollbar_list[1] = NULL;
    }
    else
    {
        PrivateScrollbar **new_list;
        unsigned int i;

        for (i = 0; scrollbar_list[i] != NULL; i++)
            ;

        new_list = realloc(scrollbar_list,sizeof(PrivateScrollbar *) * (i+2));

        if (new_list == NULL)
            return make_error(TextGadgets_BarAllocFailed, 0);

        scrollbar_list = new_list;

        scrollbar_list[i] = tb;
        scrollbar_list[i + 1] = NULL;
    }

    return NULL;
}

static _kernel_oserror *remove_redraw_handler(const PrivateScrollbar *tb)
{
    unsigned int i, j;

    if (scrollbar_list == NULL)
        return make_error(TextGadgets_UKScrollbar, 0);

    for (i = 0;
        (scrollbar_list[i] != NULL) && (scrollbar_list[i] != tb);
        i++)
        ;

    if (scrollbar_list[i] == NULL)
        return make_error(TextGadgets_UKScrollbar, 0);

    for (j = i; scrollbar_list[j] != NULL; j++)
        ;

    // j points to last entry

    if (j <= 1)
    {
        free(scrollbar_list);
        scrollbar_list = NULL;
    }
    else
    {
        PrivateScrollbar **new_list;

        for (; i < j; i++)
            scrollbar_list[i] = scrollbar_list[i + 1];

        // No need to generate an error if the realloc fails, 'cos
        // it'll just realloc next time, hopefully
        new_list = realloc(scrollbar_list, sizeof(PrivateScrollbar *) * (j+1));

        if (new_list != NULL)
            scrollbar_list = new_list;
    }

    return NULL;
}

static _kernel_oserror *scrollbar_show(PrivateScrollbar *sdata)
{
    wimp_OpenWindow	open_win;
    wimp_Bbox		extent = {0, 0, 0, 0};

    open_win.window_handle = sdata->scrollbar_window;
    work_to_screen_handle(&open_win.visible_area, &sdata->box,
    						sdata->parent_window);
    if (sdata->state & Scrollbar_Horizontal)
    {
        open_win.visible_area.ymin = open_win.visible_area.ymax;

        if (sdata->visible != 0)
        {
            extent.xmax = (sdata->box.xmax - sdata->box.xmin) *
        		(sdata->max - sdata->min + sdata->visible) /
        		(int)sdata->visible;
            if (extent.xmax < (sdata->box.xmax - sdata->box.xmin))
                extent.xmax = sdata->box.xmax - sdata->box.xmin;
        }
        else
            extent.xmax = -0xffff;

        if (sdata->value - sdata->min == 0)
            open_win.scx = 0;
        else
            open_win.scx = (extent.xmax) /
            	(int)(sdata->max - sdata->min) * (sdata->value - sdata->min);
    }
    else
    {
        open_win.visible_area.xmax = open_win.visible_area.xmin;

        if (sdata->visible != 0)
        {
            extent.ymin = -((sdata->box.ymax - sdata->box.ymin) *
        		(sdata->max - sdata->min + sdata->visible) /
        		(int)sdata->visible);
            if (extent.ymin > (sdata->box.ymax - sdata->box.ymin))
                extent.ymin = sdata->box.ymax - sdata->box.ymin;
        }
        else
            extent.ymin = -0xffff;

        if (sdata->value - sdata->min == 0)
            open_win.scy = 0;
        else
            open_win.scy = (extent.ymin) /
            	(int)(sdata->max - sdata->min) * (sdata->value - sdata->min);
    }

    /* PJG: (18/6/99) Now, if the scrollbar is faded, just set the extent to
    *                 be the window size so we get one big sausage.
     */
    if (sdata->faded)
    {
        extent.xmin = 0;
        extent.xmax = sdata->box.xmax - sdata->box.xmin;
        extent.ymax = 0;
        extent.ymin = -(sdata->box.ymax - sdata->box.ymin);
    }

    wimp_set_extent(sdata->scrollbar_window, &extent);
    open_win.behind = 0;
    _swix(Wimp_OpenWindow, _INR(1,4), &open_win, 0x4B534154 /*'TASK'*/,
    				sdata->parent_window, 0);

    return NULL;
}

int scrollbar_active(void)
{
    return scrollbar_list != NULL;
}

/* scrollbar_die -----------------------------------------------------------
 * Need to remove all scrollbar windows
 */
_kernel_oserror *scrollbar_die(void)
{
    return NULL;
}

/* scrollbar_add ----------------------------------------------------------
 */
_kernel_oserror *
scrollbar_add(Scrollbar *sdata, int wimpw, ObjectID object_id,
				int **icons, int **data)
{
    PrivateScrollbar		*sb;
    wimp_Window			win;
    wimp_GetWindowState		open_win;

    sb = (PrivateScrollbar *) mem_allocate(sizeof(PrivateScrollbar));
    if (!sb)
        return make_error(TextGadgets_BarAllocFailed, 0);

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(sb, sizeof(PrivateScrollbar));
#endif

    sb->event = sdata->event ? sdata->event : Scrollbar_PositionChanged;
    sb->state = sdata->hdr.flags;
    sb->object_id = object_id;
    sb->component_id = sdata->hdr.component_id;

    sb->type = sdata->type;
    sb->faded = 0; // PJG (18/6/99) scrollbar is not faded
    sb->parent_window = wimpw;

    sb->box.xmin = sdata->hdr.xmin;
    sb->box.ymin = sdata->hdr.ymin;
    sb->box.xmax = sdata->hdr.xmax;
    sb->box.ymax = sdata->hdr.ymax;
    sb->min = sdata->min;
    if ((sb->max = sdata->max) < sb->min)
        sb->max = sb->min;
    if ((sb->value = sdata->value) > sb->max)
        sb->value = sb->max;
    if (sb->value < sb->min)
        sb->value = sb->min;
    if ((sb->visible = sdata->visible) > sb->max)
        sb->visible = sb->max;
    sb->line_inc = sdata->line_inc;
    sb->page_inc = sdata->page_inc;

    win.box.xmin = 0;
    win.box.ymin = 0;
    win.box.xmax = 0;
    win.box.ymax = 0;
    win.scx = 0;
    win.scy = 0;
    win.behind = -1;
    win.flags = wimp_WINDOWFLAGS_AUTOREDRAW | wimp_WINDOWFLAGS_PANE |
    		wimp_WINDOWFLAGS_ALLOW_OFF_SCREEN | wimp_WINDOWFLAGS_CLICK_SCROLL_REQUEST |
    		(int)wimp_WINDOWFLAGS_USE_NEW_FLAGS;
    if (sb->state & Scrollbar_Horizontal)
        win.flags |= wimp_WINDOWFLAGS_HAS_HSCROLLBAR;
    else
        win.flags |= wimp_WINDOWFLAGS_HAS_VSCROLLBAR;
    win.colours[0] = 0xff;
    win.colours[1] = 2;
    win.colours[4] = 3;
    win.colours[5] = 1;
    win.ex.xmin = 0;
    win.ex.ymin = -0xffff;
    win.ex.xmax = 0xffff;
    win.ex.ymax = 0;
    win.title_flags = 0;
    win.work_area_flags = 0;
    win.sprite_area = NULL;
    win.min_size = 0x00010001;
    win.title.indirect_text.buffer = NULL;
    win.title.indirect_text.valid_string = NULL;
    win.title.indirect_text.buff_len = 0;
    win.nicons = 0;

    // Display scrollbar if parent is showing
    open_win.open.window_handle = sb->parent_window;
    wimp_get_window_state(&open_win);

    wimp_create_window(&win, &sb->scrollbar_window);

    scrollbar_show(sb);

    *icons = my_icons;

    add_redraw_handler(sb);

    *data = (int *) sb;

    add_task_interest(GLib_ToolboxEvents, filter_toolbox_events,
    				TextGadgets_Filter);
    add_task_interest(GLib_WimpEvents, filter_wimp_events,
    				TextGadgets_Filter);

    return NULL;
}

static _kernel_oserror *_set_bounds(unsigned int flags,
		PrivateScrollbar *sdata,
		unsigned int min, unsigned int max, unsigned int visible)
{
    if (flags & Scrollbar_Lower_Bound)
        sdata->min = min;
    if (flags & Scrollbar_Upper_Bound)
        sdata->max = max;
    if (flags & Scrollbar_Visible_Len)
        sdata->visible = visible;

    if (sdata->max < sdata->min)
        sdata->max = sdata->min;
    if (sdata->visible > sdata->max)
        sdata->visible = sdata->max;
    if (sdata->visible < sdata->min)
        sdata->visible = sdata->min;

    // Need to set window extent

    return NULL;
}

static _kernel_oserror *_get_bounds(unsigned int flags,
		PrivateScrollbar *sdata, _kernel_swi_regs *regs)
{
    if (flags & Scrollbar_Lower_Bound)
        regs->r[0] = sdata->min;
    if (flags & Scrollbar_Upper_Bound)
        regs->r[1] = sdata->max;
    if (flags & Scrollbar_Visible_Len)
        regs->r[2] = sdata->visible;

    return NULL;
}

static _kernel_oserror *_set_increments(unsigned int flags,
		PrivateScrollbar *sdata,
		unsigned int line, unsigned int page)
{
    if (flags & Scrollbar_Line_Inc)
        sdata->line_inc = line;
    if (flags & Scrollbar_Page_Inc)
        sdata->page_inc = page;

    return NULL;
}

static _kernel_oserror *_get_increments(unsigned int flags,
		PrivateScrollbar *sdata, _kernel_swi_regs *regs)
{
    if (flags & Scrollbar_Line_Inc)
        regs->r[0] = sdata->line_inc;
    if (flags & Scrollbar_Page_Inc)
        regs->r[1] = sdata->page_inc;

    return NULL;
}

_kernel_oserror *scrollbar_method(PrivateScrollbar *handle,
				_kernel_swi_regs *regs)
{
    _kernel_oserror *e = NULL;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(regs, sizeof(_kernel_swi_regs));
#endif

    switch (regs->r[2])
    {
        case Scrollbar_GetState:
            regs->r[0] = handle->state;
            break;
        case Scrollbar_SetState:
            handle->state = regs->r[4];
            break;
        case Scrollbar_SetBounds:
            e = _set_bounds(regs->r[0], handle, regs->r[4], regs->r[5],
            		regs->r[6]);
            break;
        case Scrollbar_GetBounds:
            e = _get_bounds(regs->r[0], handle, regs);
            break;
        case Scrollbar_SetValue:
            handle->value = regs->r[4];
            scrollbar_show(handle);
            break;
        case Scrollbar_GetValue:
            regs->r[0] = handle->value;
            break;
        case Scrollbar_SetIncrements:
            e = _set_increments(regs->r[0], handle, regs->r[4], regs->r[5]);
            break;
        case Scrollbar_GetIncrements:
            e = _get_increments(regs->r[0], handle, regs);
            break;
        case Scrollbar_SetEvent:
            handle->event = regs->r[4];
            break;
        case Scrollbar_GetEvent:
            regs->r[0] = handle->event;
        default:
            break;
   }

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(regs);
#endif

   return e;
}

/* ------------------------------------------------------------------------
 */
_kernel_oserror *scrollbar_remove(PrivateScrollbar *handle)
{
    remove_redraw_handler(handle);

    remove_task_interest(GLib_ToolboxEvents, filter_toolbox_events);
    remove_task_interest(GLib_WimpEvents, filter_wimp_events);

    mem_free(handle);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(handle);
#endif

    return NULL;
}

_kernel_oserror *scrollbar_fade(PrivateScrollbar *handle, int fade)
{
    /* PJG: (18/6/99) Now the sausage will be plotted as big as possible
     *                and we will ignore it.
     */
    handle->faded = fade;
    scrollbar_show(handle);

    return NULL;
}

_kernel_oserror *scrollbar_plot(Scrollbar *sdata)
{
    wimp_GetWindowState	state;

    if ((state.open.window_handle = redrawing_window) == 0)
        return NULL;

sdata = sdata;

    return NULL;
}

static _kernel_oserror *_do_drag_scroll(wimp_OpenWindowRequest *event)
{
    int old_position, i;

    for (i = 0; scrollbar_list[i] != NULL; i++)
        if (scrollbar_list[i]->scrollbar_window == event->open_block.window_handle)
        {
            PrivateScrollbar *sdata = scrollbar_list[i];
            ScrollbarPositionChangedEvent changed;

            if (sdata->faded) return NULL; // PJG (18/6/99) Ignore if faded
                                           //               bit is set.

            old_position = sdata->value;

            if (sdata->state & Scrollbar_Horizontal)
            {
                int extent = (sdata->box.xmax - sdata->box.xmin) *
                	(sdata->max - sdata->min + sdata->visible);

                if (extent == 0)
                    sdata->value = sdata->max;
                else
                    sdata->value = (event->open_block.scx *
                    	(sdata->max - sdata->min) *
	                sdata->visible / extent) + sdata->min;
            }
            else
            {
                int extent = (sdata->box.ymax - sdata->box.ymin) *
                	(sdata->max - sdata->min + sdata->visible);

	        if (extent == 0)
	            sdata->value = sdata->max;
	        else
                    sdata->value = (-event->open_block.scy *
                        (sdata->max - sdata->min) *
                	sdata->visible / extent) + sdata->min;
            }

            if (old_position != sdata->value)
            {
                changed.hdr.size = sizeof(ScrollbarPositionChangedEvent);
                changed.hdr.event_code = sdata->event;
                changed.hdr.flags = 0;

                changed.direction = 0;

                changed.new_position = sdata->value;

                _swix(Toolbox_RaiseToolboxEvent, _INR(0,3),
                      0, sdata->object_id, sdata->component_id, (ToolboxEvent *)&changed);

                scrollbar_show(sdata);
            }
        }


    return NULL;
}

static _kernel_oserror *_do_scroll(wimp_ScrollRequest *event)
{
    PrivateScrollbar	*sdata;
    int			i;

    for (i = 0; scrollbar_list[i] != NULL; i++)
        if (scrollbar_list[i]->scrollbar_window == event->open_block.window_handle)
        {
            // Found it!
            ScrollbarPositionChangedEvent changed;
            int old_position;

            sdata = scrollbar_list[i];
            old_position = sdata->value;

            if (sdata->faded) return NULL; // PJG (18/6/99) Ignore if faded
                                           //               bit is set.

            changed.hdr.size = sizeof(ScrollbarPositionChangedEvent);
            changed.hdr.event_code = sdata->event;
            changed.hdr.flags = 0;

            if (sdata->state & Scrollbar_Horizontal)
                changed.direction = event->x_scroll_direction;
            else
                changed.direction = -event->y_scroll_direction;

            switch (changed.direction)
            {
              case -2:
                if (sdata->value > sdata->page_inc)
                    sdata->value = sdata->value - sdata->page_inc;
                else
                    sdata->value = sdata->min;
                break;
              case -1:
                if (sdata->value > sdata->line_inc)
                    sdata->value = sdata->value - sdata->line_inc;
                else
                    sdata->value = sdata->min;
                break;
              case 0:
                break;
              case 1:
                sdata->value = sdata->value + sdata->line_inc;
                break;
              case 2:
                sdata->value = sdata->value + sdata->page_inc;
                break;
            }
            if (sdata->value < sdata->min)
                sdata->value = sdata->min;
            if (sdata->value > sdata->max)
                sdata->value = sdata->max;

            changed.new_position = sdata->value;

            if (old_position != sdata->value)
            {
                _swix(Toolbox_RaiseToolboxEvent, _INR(0,3),
                      0, sdata->object_id, sdata->component_id, (ToolboxEvent *)&changed);

                scrollbar_show(sdata);
            }
        }

    return NULL;
}

#ifdef MemCheck_MEMCHECK
static _kernel_oserror *scrollbar_filter2(_kernel_swi_regs *regs)
#else
_kernel_oserror *scrollbar_filter(_kernel_swi_regs *regs)
#endif
{
    ToolboxEvent *event = (ToolboxEvent *)regs->r[1];
    IDBlock	*id_block = (IDBlock *)regs->r[3];
    int		event_code = regs->r[0];
    unsigned int i;

    if (scrollbar_list == NULL)
        return NULL;

    if (event_code == wimp_ESCROLL)
    {
        _do_scroll((wimp_ScrollRequest *)regs->r[1]);
    }
    else if (event_code == wimp_EOPEN)
    {
        _do_drag_scroll((wimp_OpenWindowRequest *)regs->r[1]);
    }

    // All checks after here should assume event is a toolbox event
    if (event_code != wimp_ETOOLBOX_EVENT)
         return NULL;

    if (event->hdr.event_code == Toolbox_ObjectDeleted)
    {
        int remaining = 0;
        PrivateScrollbar **new_list;

        // An object has been deleted, so remove from internal list
        // any gadgets inside it.
        for (i = 0; scrollbar_list[i] != NULL; i++)
        {
            if (scrollbar_list[i]->object_id == id_block->self_id)
            {
                // Found one!
                int j;

                wimp_delete_window( (wimp_DeleteWindow *)
                		&(scrollbar_list[i]->scrollbar_window));

                for (j = i; scrollbar_list[j] != NULL; j++)
                {
                    // Copy down following gadgets
                    scrollbar_list[j] = scrollbar_list[j+1];
                }
            }
            else
                remaining++;
        }

        // Shrink memory block
        if (remaining == 0)
        {
            free(scrollbar_list);
            scrollbar_list = NULL;
        }
        else
        {
            new_list = realloc(scrollbar_list,
        			sizeof(PrivateScrollbar*) * (remaining + 1));
            if (new_list != NULL)
                scrollbar_list = new_list;
        }
    }

    return NULL;
}

#ifdef MemCheck_MEMCHECK
_kernel_oserror *scrollbar_filter(_kernel_swi_regs *regs)
{
    _kernel_oserror *e;

    MemCheck_RegisterMiscBlock((void*)regs->r[1], 256);
    MemCheck_RegisterMiscBlock((void*)regs->r[3], sizeof(IdBlock));
    e = scrollbar_filter2(regs);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[1]);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[3]);

    return e;
}
#endif

_kernel_oserror *scrollbar_move(PrivateScrollbar *sdata, wimp_Bbox *box)
{
    wimp_GetWindowState	state;

    sdata->box = *box;

    state.open.window_handle = sdata->scrollbar_window;
    wimp_get_window_state(&state);

    return scrollbar_show(sdata);
}
@


1.15
log
@Change to link against tboxlibint
For some reason this toolbox module was unique in linking against the public toolboxlib rather than the internal one, this meant having to carefully tippy toe around not mixing header files (as they contain similar but differently named definitions).
A massive search and replace job.
Tested briefly using ResEd/ResTest and a textarea and scrolllist in a ROM build.
Requires Common-0_21.

Version 0.36. Tagged as 'Gadgets-0_36'
@
text
@d38 1
a44 1
#include "Text.h"
d73 1
a73 1
            return (_kernel_oserror *)&e_outofbarmem;
d89 1
a89 1
            return (_kernel_oserror *)&e_outofbarmem;
d105 1
a105 1
        return (_kernel_oserror *)&e_badsbar;
d113 1
a113 1
        return (_kernel_oserror *)&e_badsbar;
d238 1
a238 1
        return (_kernel_oserror *)&e_outofbarmem;
@


1.14
log
@Remove unnecessary includes of "Modhdr.h".
The last change meant it was no longer being generated, so ammended the code to not need it in line with all the other toolbox modules.

Version 0.34. Tagged as 'Gadgets-0_34'
@
text
@a33 2
#include <math.h>

d37 2
a38 3
#include "toolbox.h"
#include "window.h"
#include "wimplib.h"
a41 2
#include "string32.h"
#include "riscos_uti.h"
a42 1
#include "Scrollbar.h"
d44 1
a50 2
#define IGNORE(a) (a)=(a)

d54 1
a54 1
    BBox		box;
d145 2
a146 2
    WimpOpenWindowBlock	open_win;
    BBox		extent = {0, 0, 0, 0};
d167 1
a167 1
            open_win.xscroll = 0;
d169 1
a169 1
            open_win.xscroll = (extent.xmax) /
d188 1
a188 1
            open_win.yscroll = 0;
d190 1
a190 1
            open_win.yscroll = (extent.ymin) /
d229 1
a229 1
scrollbar_add(Scrollbar *sdata, int wimpw, ObjectId object_id,
d233 2
a234 2
    WimpWindow			win;
    WimpGetWindowStateBlock	open_win;
d253 4
a256 1
    sb->box = sdata->hdr.box;
d269 6
a274 6
    win.visible_area.xmin = 0;
    win.visible_area.ymin = 0;
    win.visible_area.xmax = 0;
    win.visible_area.ymax = 0;
    win.xscroll = 0;
    win.yscroll = 0;
d276 3
a278 3
    win.flags = WimpWindow_AutoRedraw | WimpWindow_Pane |
    		WimpWindow_NoBounds | WimpWindow_ScrollRepeat |
    		WimpWindow_NewFormat;
d280 1
a280 1
        win.flags |= WimpWindow_HScroll;
d282 9
a290 9
        win.flags |= WimpWindow_VScroll;
    win.title_fg = 0xff;
    win.title_bg = 2;
    win.scroll_outer = 3;
    win.scroll_inner = 1;
    win.extent.xmin = 0;
    win.extent.ymin = -0xffff;
    win.extent.xmax = 0xffff;
    win.extent.ymax = 0;
d292 1
a292 1
    win.work_flags = 0;
d294 4
a297 4
    win.min_width = win.min_height = 1;
    win.title_data.it.buffer = NULL;
    win.title_data.it.validation = NULL;
    win.title_data.it.buffer_size = 0;
d301 1
a301 1
    open_win.window_handle = sb->parent_window;
d465 1
a465 1
    WimpGetWindowStateBlock	state;
d467 1
a467 1
    if ((state.window_handle = redrawing_window) == 0)
d475 1
a475 1
static _kernel_oserror *_do_drag_scroll(WimpOpenWindowRequestEvent *event)
d480 1
a480 1
        if (scrollbar_list[i]->scrollbar_window == event->window_handle)
d498 1
a498 1
                    sdata->value = (event->xscroll *
d510 1
a510 1
                    sdata->value = (-event->yscroll *
d525 2
a526 2
                toolbox_raise_toolbox_event(0, sdata->object_id,
                	sdata->component_id, (ToolboxEvent *) &changed);
d536 1
a536 1
static _kernel_oserror *_do_scroll(WimpScrollRequestEvent *event)
d542 1
a542 1
        if (scrollbar_list[i]->scrollbar_window == event->open.window_handle)
d559 1
a559 1
                changed.direction = event->xscroll;
d561 1
a561 1
                changed.direction = -event->yscroll;
d595 2
a596 2
                toolbox_raise_toolbox_event(0, sdata->object_id,
            		sdata->component_id, (ToolboxEvent *) &changed);
d612 1
a612 1
    IdBlock	*id_block = (IdBlock *)regs->r[3];
d619 1
a619 1
    if (event_code == Wimp_EScrollRequest)
d621 1
a621 1
        _do_scroll((WimpScrollRequestEvent *)regs->r[1]);
d623 1
a623 1
    else if (event_code == Wimp_EOpenWindow)
d625 1
a625 1
        _do_drag_scroll((WimpOpenWindowRequestEvent *)regs->r[1]);
d629 1
a629 1
    if (event_code != Wimp_EToolboxEvent)
d646 1
a646 1
                wimp_delete_window( (WimpDeleteWindowBlock *)
d692 1
a692 1
_kernel_oserror *scrollbar_move(PrivateScrollbar *sdata, BBox *box)
d694 1
a694 1
    WimpGetWindowStateBlock	state;
d698 1
a698 1
    state.window_handle = sdata->scrollbar_window;
@


1.13
log
@TextGadgets module fixes & improvements
Detail:
  c/ScrollList, c/TextArea - ScrollList_SetFont and TextArea_SetFont now accept font handles instead of just font names. The handles are handled in the same way as the Window module, i.e. the handle will be managed and freed by the TextGadgets modules. Fixes bug #212.
  c/ScrollList, c/Scrollbar, c/TextArea - Fix handling of Toolbox_ObjectDeleted events. Original code would corrupt the object lists when deleting items, and reallocate much more memory than was actually needed. Fixes bug #214
  c/MemMan - Fix grow_handlers to not leave handle_list as NULL if the realloc fails. Fixes bug #216.
  c/MemMan, c/TextArea, c/TextMan, h/MemMan, h/TextMan - Changed how the 'Handle' type is handled. Instead of MemMan giving out direct pointers to Handle instances, it now gives out identifiers (HandleId). These identifiers are then converted to Handle pointers via get_handle whenever the contents need to be accessed. This allows the handle_list to be safely realloc'd without breaking all the existing Handle pointers. Fixes bug #217
  c/MemMan - Reduced HDNLE_GRW_BY from 1000 to 128 to save a bit of memory
Admin:
  Module compiles and runs, but actual functionality is untested.
  Fixes bugs 212, 214, 216, 217.


Version 0.32. Tagged as 'Gadgets-0_32'
@
text
@a49 1
#include "ModHdr.h"
@


1.12
log
@Function returns no longer use stack structures.
Previously, a number of errors were contructed as automatic variables then returned to the caller - potentially accessing stale stack area. All error blocks are now held in ROM and cast from there.
Error numbers are now not &00000000 or &20202020, using the allocated base - requires 'Common-0_15'.
Trimmed some unused debugging code out, saves about 3k.
Renamed C++ clashing variables to stop the compiler moaning.
Implemented feature request to accept the empty string "" as no font handle in _SetFont calls.
At some point, this module needs internationalising.

Version 0.31. Tagged as 'Gadgets-0_31'
@
text
@d657 1
a657 1
                    scrollbar_list[j] = scrollbar_list[j+i];
d673 1
a673 1
        			sizeof(PrivateScrollbar) * (remaining + 1));
@


1.11
log
@Fix for data abort triggered in the following case:
 create res file with a single TextArea in it
 change flags to be auto create and auto display
 drop into restest
 delete the 8 character "TextArea" default text
 press enter
 press backspace
Also,there was a _swix(&107) left in from some point in the past.

Version 0.27. Tagged as 'Gadgets-0_27'
@
text
@d42 1
a74 5
static _kernel_oserror *out_of_memory(void)
{
   return (_kernel_oserror *) "    Unable to allocate memory to store scrollbar gadget definition";
}

a76 1
    _kernel_oserror no_mem = {0, "Not enough memory"};
d81 1
a81 1
            return &no_mem;
d94 1
a94 1
        new_list = realloc(scrollbar_list,sizeof(PrivateScrollbar*) * (i+2));
d97 1
a97 1
            return &no_mem;
a109 1
    _kernel_oserror bad_scrollbar = {0, "No such scrollbar"};
d113 1
a113 1
        return &bad_scrollbar;
d121 1
a121 1
        return &bad_scrollbar;
d142 1
a142 1
        new_list = realloc(scrollbar_list, sizeof(PrivateScrollbar) * (j+1));
d246 1
a246 1
        return out_of_memory();
@


1.10
log
@  Removed unused files that were preventing build.
Detail:
  debug.s was still in the build and included a header which had been removed
  in a previous version.  The code in debug.s in not used anywhere, so I've
  just removed it (and the corresponding debug.h, which was empty anyway).
Admin:
  Compiled.

Version 0.25. Tagged as 'Gadgets-0_25'
@
text
@a647 1
_swix(0x107,0);
@


1.9
log
@Scrollbars now handle fading.
Detail:
faded flag added to ScrollbarP.h, Scrollbar.c uses this to calculate extent.
scrollbar_fade function called as a PRIVATE_HANDLER from TextGadget.c
Admin:
Built and tested on Pete Goodliffe's Risc PC. Problem with CVS misusage fixed
(a couple of modifications were accidentally removed).

Version 0.22. Tagged as 'Gadgets-0_22'
@
text
@a48 1
#include "debug.h"
@


1.8
log
@Replaced some fixes that got removed due to CVS usage error. D'oh.
@
text
@d467 1
a467 1
     *                and we will ignore it
@


1.7
log
@Removal of spurious beep.
@
text
@d26 3
a28 1
 * pete     18/6/99  Added fading support
d209 2
a210 2
    /* PJG: (18/6/99) Now, if the scrollbar is faded, just set the extent to be the window
     *                size so we get one big sausage.
d296 3
a298 2
    win.scroll_outer = 1;
    win.scroll_inner = 3;
d307 3
d419 1
a419 1
//            scrollbar_update(handle);
d466 3
a468 3
    // Plot scrollbar without sausage? (huge extent doesn't work. argh!)

    // PJG: (18/6/99) Now the sausage will be plotted as big as possible and we will ignore it
d497 2
a498 1
            if (sdata->faded) return NULL; // PJG (18/6/99) Ignore if faded bit is set
a552 1

d563 2
a564 1
            if (sdata->faded) return NULL; // PJG (18/6/99) Ignore if faded bit is set
@


1.6
log
@The scrollbar gadget can now be 'faded' (it doesn't actually fade - it just stops responding and maximises the sausage).
@
text
@a464 1
_swix(0x107,0);
@


1.5
log
@Changed scrollbar gadget to initialise title-bar validation string despite not having a title bar, to get around a crash in the wimp

Version 0.19. Tagged as 'Gadgets-0_19'
@
text
@d26 1
a26 2
 * ADH      24/03/99 Set title_bg to 2 rather than leaving it uninitialised.
 *                   Put scroll_inner and scroll_outer the right way around.
d206 12
d263 1
d294 2
a295 3
    win.title_bg = 2;
    win.scroll_outer = 3;
    win.scroll_inner = 1;
a303 3
    win.title_data.it.buffer = NULL;
    win.title_data.it.validation = NULL;
    win.title_data.it.buffer_size = 0;
d413 1
a413 1
            scrollbar_show(handle);
d458 1
a458 1
_kernel_oserror *scrollbar_fade(int *handle, int fade)
d461 5
a465 2
    IGNORE(handle);
    IGNORE(fade);
d492 2
d547 1
d557 2
@


1.4
log
@Fixed SetValue for Scrollbar gadget so it updates the display.

Version 0.18. Tagged as 'Gadgets-0_18'
@
text
@d293 3
@


1.3
log
@Various fixes and extensions to ScrollList, plus a related fix in TextArea
and ScrollBar.

Title background colour of gadgets was either undefined or set to 0; should
be 2. Corrected. Would be apparent with 2D tools or any transparent tool
sprite set.

SELECT clicks on deselected entries in a ScrollList now deselect any other
selected items before selecting the new one.

Embedded window of TextArea and ScrollList now put in the right place. At
create time, the sizes of the current tool sprite set is also checked; this
used to be hard coded. If the tool sizes and/or Desktop scaling changes at
run-time this won't be noticed yet, as no mechanism to pass Wimp messages
to *external* gadgets exists in the Toolbox currently. Still, at least it
gets it right the next time a new instance of the gadget is created.

Flag bit ScrollList_SelectionChangingMethod_SendEvent to any of
scrolllist_select_item, scrolllist_deselect_item or scrolllist_delete_items
prompts them to send ScrollList_Selection to the client on completion. This
can help simplify client UI code for UIs which depend on what is selected
(e.g. a "Select all" button greys out if all items are selected by a
keyboard shortcut - this can now all work on just the one event handler).

Flag bit ScrollList_SelectionChangingMethod_OnAll to either of
scrolllist_select_item or scrolllist_deselect_item tells the methods to
act like a "Select all" or "Clear selection" call. This is a common client
operation and it's a lot easier for the ScrollList gadget to do it than
have the client iterate over all items.

Supports new method ScrollList_CountItems (scrolllist_count_items veneer
present in tboxlibs 0.04 or later). Returns number of entries in gadget.
Avoids clumsy situation of both the gadget and the clienty keeping track
of how many entries are present.

Note that docs.ScrollList mis-documented some flags settings. Now fixed.

Version 0.15. Not tagged
@
text
@d402 1
a402 1
//            scrollbar_update(handle);
@


1.2
log
@* Merged in fixes from Daytona branch (tag sbrodie_Daytona_merge_19Jun98)

* Fixed 'long' #include directives.
* Removed duplicate function prototypes from TextGadget.h (use ModHdr.h
  for correct prototypes).
* Capability to build with pre- and post-5.16 versions of CMHG.
@
text
@d26 2
d282 3
a284 2
    win.scroll_outer = 1;
    win.scroll_inner = 3;
@


1.1
log
@Initial revision
@
text
@d25 1
d42 2
a43 2
#include "riscos_utils.h"
#include "TextGadgets.h"
d47 1
a47 1
#include "myswis.h"
d177 1
a177 1
        
d198 1
a198 1
        
d213 5
d434 1
a434 1
    
d465 58
d534 1
a534 1
            
d607 4
d666 1
a666 1
    
d672 1
a672 1
    
d685 1
a685 1
    
@


1.1.1.1
log
@The Java directory contains the sources for the Java support modules
(TextGadget, etc.) and the makefiles to complete the Java ROM build
under RiscOS.

@
text
@@


1.1.1.2
log
@Fixed a couple of data aborts, made all gadgets not quit if tasks are
still using them and freed all memory when they do quit.
@
text
@a211 5
int scrollbar_active(void)
{
    return scrollbar_list != NULL;
}

@


1.1.1.3
log
@Added scrollbar dragging
@
text
@a24 1
 * piers    19/01/98 Added dragging support
d176 1
a176 1

d197 1
a197 1

d433 1
a433 1

a463 46
static _kernel_oserror *_do_drag_scroll(WimpOpenWindowRequestEvent *event)
{
    int old_position, i;

    for (i = 0; scrollbar_list[i] != NULL; i++)
        if (scrollbar_list[i]->scrollbar_window == event->window_handle)
        {
            PrivateScrollbar *sdata = scrollbar_list[i];
            ScrollbarPositionChangedEvent changed;

            old_position = sdata->value;

            if (sdata->state & Scrollbar_Horizontal)
            {
                sdata->value = (event->xscroll * (sdata->max - sdata->min) *
                	sdata->visible / ((sdata->box.xmax - sdata->box.xmin) *
                	(sdata->max - sdata->min + sdata->visible))) + sdata->min;
            }
            else
            {
                sdata->value = (-event->yscroll * (sdata->max - sdata->min) *
                	sdata->visible / ((sdata->box.ymax - sdata->box.ymin) *
                	(sdata->max - sdata->min + sdata->visible))) + sdata->min;
            }

            if (old_position != sdata->value)
            {
                changed.hdr.size = sizeof(ScrollbarPositionChangedEvent);
                changed.hdr.event_code = sdata->event;
                changed.hdr.flags = 0;

                changed.direction = 0;

                changed.new_position = sdata->value;

                toolbox_raise_toolbox_event(0, sdata->object_id,
                	sdata->component_id, (ToolboxEvent *) &changed);

                scrollbar_show(sdata);
            }
        }


    return NULL;
}

d475 1
a475 1

a547 4
    else if (event_code == Wimp_EOpenWindow)
    {
        _do_drag_scroll((WimpOpenWindowRequestEvent *)regs->r[1]);
    }
d603 1
a603 1

d609 1
a609 1

d622 1
a622 1

@


1.1.1.4
log
@Fixed dragging of scrollbar - occasionally caused a div. by zero error
@
text
@d479 3
a481 9
                int extent = (sdata->box.xmax - sdata->box.xmin) *
                	(sdata->max - sdata->min + sdata->visible);

                if (extent == 0)
                    sdata->value = sdata->max;
                else
                    sdata->value = (event->xscroll *
                    	(sdata->max - sdata->min) *
	                sdata->visible / extent) + sdata->min;
d485 3
a487 9
                int extent = (sdata->box.ymax - sdata->box.ymin) *
                	(sdata->max - sdata->min + sdata->visible);

	        if (extent == 0)
	            sdata->value = sdata->max;
	        else
                    sdata->value = (-event->yscroll *
                        (sdata->max - sdata->min) *
                	sdata->visible / extent) + sdata->min;
@


1.1.1.2.2.1
log
@Made a single, unified Makefile.  myswis.h renamed to ModHdr.h so that it can be
automatically generated by CMHG.  Changed DAYTONA_BUILD flag to Daytona_BUILD so
that it can be automatically defined in the Makefile using the build
environment's System variable (called ${SYSTEM} in Makefiles).
@
text
@d46 1
a46 1
#include "ModHdr.h"
d176 1
a176 1

d197 1
a197 1

d433 1
a433 1

d475 1
a475 1

d603 1
a603 1

d609 1
a609 1

d622 1
a622 1

@

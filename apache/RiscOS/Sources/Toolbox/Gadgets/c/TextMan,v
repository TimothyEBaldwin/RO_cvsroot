head	1.9;
access;
symbols
	Gadgets-0_44:1.9
	Gadgets-0_43:1.9
	Gadgets-0_42:1.9
	Gadgets-0_41:1.8
	Gadgets-0_40:1.8
	Gadgets-0_39:1.8
	Gadgets-0_38:1.8
	Gadgets-0_37:1.8
	Gadgets-0_36:1.7
	Gadgets-0_35:1.6
	Gadgets-0_34:1.6
	Gadgets-0_33:1.6
	Gadgets-0_32:1.6
	Gadgets-0_31:1.5
	Gadgets-0_30:1.4
	Gadgets-0_29:1.4
	Gadgets-0_28:1.4
	RO_5_07:1.4
	Gadgets-0_27:1.4
	Gadgets-0_26:1.3
	Gadgets-0_25:1.3
	Gadgets-0_24:1.3
	Gadgets-0_23:1.3
	Gadgets-0_22:1.3
	Gadgets-0_21:1.3
	Gadgets-0_20:1.3
	Gadgets-0_19:1.3
	Gadgets-0_18:1.3
	Gadgets-0_17:1.3
	Gadgets-0_16:1.3
	Gadgets-0_15:1.3
	sforrest_daytona_appflash-0_31:1.1.1.3.2.2
	Gadgets-0_14:1.3
	mjrobert_Java_26_08_98:1.1.1.5
	blaughto_daytona_appflash-0_30:1.1.1.3.2.2
	blaughto_daytona_appflash-0_29:1.1.1.3.2.2
	blaughto_daytona_appflash-0_28:1.1.1.3.2.2
	Gadgets-0_11:1.3
	sbrodie_TextGadgets_merged_19Jun98:1.2
	sbrodie_Daytona_merge_19Jun98:1.1.1.3.2.3
	sbrodie_Spin_merge_18Jun98:1.1.1.5
	jberanek_gadgets-0_08:1.1.1.3.2.3
	Gadgets-0_10-1_1_2_2:1.1.1.5
	blaughto_daytona_appflash-0_27:1.1.1.3.2.2
	blaughto_daytona_appflash-0_26:1.1.1.3.2.2
	blaughto_daytona_appflash-0_25:1.1.1.3.2.2
	blaughto_daytona_appflash-0_24:1.1.1.3.2.2
	blaughto_daytona_appflash-0_23:1.1.1.3.2.2
	blaughto_daytona_appflash-0_21:1.1.1.3.2.2
	blaughto_daytona_appflash-0_20:1.1.1.3.2.2
	blaughto_daytona_appflash-0_19:1.1.1.3.2.2
	jberanek_gadgets-0_07:1.1.1.3.2.2
	blaughto_daytona_appflash-0_18:1.1.1.3.2.1
	mrison_gadgets-0_06:1.1.1.3.2.1
	pwombwel_0_09:1.1.1.5
	mrison_gadgets-0_05:1.1.1.3
	Daytona:1.1.1.3.0.2
	Daytona_bp:1.1.1.3
	Spinner_RCA116:1.1.1.1
	Spinner_B20_2:1.1.1.1
	Spinner_19_3:1.1.1.1
	Spinner_B18:1.1.1.1
	Spinner_B17:1.1.1.1
	Spinner_B15:1.1.1.1
	Spinner_B14:1.1.1.1
	Spinner_B13:1.1.1.1
	Spinner_B12:1.1.1.1
	Spinner_B10:1.1.1.1
	Initial:1.1.1.1
	Spinner:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2016.05.02.19.25.49;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	8wlp4pdOjHz5uW4z;

1.8
date	2013.08.30.21.32.36;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	Ah6FHegdauBDyw3x;

1.7
date	2013.08.30.19.34.37;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	cFJZhP2Bmu3bUv3x;

1.6
date	2011.06.25.22.38.48;	author jlee;	state Exp;
branches;
next	1.5;
commitid	SJmoual8pfcHx6pv;

1.5
date	2010.02.28.10.40.28;	author rsprowson;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.16.10.57.55;	author rsprowson;	state Exp;
branches;
next	1.3;

1.3
date	98.06.19.13.21.08;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	98.06.19.12.47.52;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	97.05.13.16.25.53;	author rlougher;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.13.16.25.53;	author rlougher;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.21.16.37.53;	author rlougher;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.12.16.12.54.55;	author rlougher;	state Exp;
branches
	1.1.1.3.2.1;
next	1.1.1.4;

1.1.1.4
date	98.01.07.17.17.19;	author rlougher;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	98.01.20.20.01.46;	author rlougher;	state Exp;
branches;
next	;

1.1.1.3.2.1
date	98.01.28.18.15.20;	author mrison;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	98.03.16.16.22.13;	author jberanek;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	98.06.18.17.07.05;	author jberanek;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Fix for memory leak in error case
Rather than leak 40 bytes by failing to free(), just use an automatic variable and let the compiler worry about function exits.
From a tip off in https://www.riscosopen.org/forum/forums/4/topics/3990

Version 0.42. Tagged as 'Gadgets-0_42'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Title:   TextMan.c
 * Purpose: Text management functions.
 *
 * Revision History
 * rlougher  Nov 96  Created
 * rlougher 18/12/96 Added code to keep track of max x-extent during editing
 * rlougher 14/02/97 Fixed line limit (1000) on text replace
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include "kernel.h"
#include "swis.h"

#include "macros.h"
#include "messages.h"
#include "objects/gadgets.h"

#include "twimp.h"
#include "MemMan.h"
#include "TextMan.h"

typedef struct {
    int  *new_lines;
    int  line_no;
    int  max_line;
    char *split_pos;
    int  split_xpoint;
    int  x_pos;
} Scan;

_kernel_oserror *grow_lines(Text *text, int size);
_kernel_oserror *grow_lines_by(Text *text, int size);
_kernel_oserror *create_insertion(Text *text, int pos);
int             line_start(Text *text, int line_no);
int             line_end(Text *text, int line_no);
int             line_index_of_char(Text *text, int pos);
char            *text_to_mem(Text *text, int pos);
char            *expand_tabs(char *str, int *len);

_kernel_oserror *create_text(int size, int font_handle, Text **t_pntr)
{
    _kernel_oserror *err;
    Text            *text;
    HandleId        handle;

    /* Create the memory block to hold the text data */

    if((err = create_block(size + 1, &handle)) != NULL)
        return err;

    if((text = malloc(sizeof(Text))) == NULL)
    {
        delete_block(handle);
        return make_error(TextGadgets_IntMallocFail, 0);
    }

    *(get_handle(handle)->base) = '\0';

    text->insert_line    = 0;
    text->insert_delta   = 0;
    text->insert_pos     = 0;
    text->insert_gap_end = 0;
    text->no_of_lines    = 1;
    text->lne_tbl_sze    = 0;
    text->line_table     = NULL;
    text->xmax_table     = NULL;
    text->sel_stop_pos   = -1;
    text->sel_stop_line  = 0;
    text->xmax           = 0;
    text->xmax_line      = 0;

    /* Create the line table for the text */

    if((err = grow_lines(text, size)) != NULL)
    {
        free(text);
        delete_block(handle);
        return err;
    }

    text->line_table[0] = -1;
    text->xmax_table[0] = 0;
    text->text_data = handle;
    *t_pntr = text;

    return set_font(text, font_handle);
}


_kernel_oserror *set_font(Text *text, int font_handle)
{
    int min, max;

    text->font_handle = font_handle;
    _swix(Font_ReadInfo,_IN(0)|_OUT(2)|_OUT(4), font_handle, &min, &max);
    text->line_height = max + (min < 0 ? - min : 0);
    text->font_base = max;

    text->tab_stop = 72000;
    _swix(Font_ScanString,_INR(0,4)|_OUT(3), text->font_handle, " ", 1<<8,
                              0xfffffff, 0, &text->space);

    if(get_text_size(text) > 0)
        return compose_text(text);

    return NULL;
}


void delete_text(Text *text)
{
    delete_block(text->text_data);
    free(text->line_table);
    free(text->xmax_table);
    free(text);
}


static void update_lines(Text *text)
{
    int i;

    for(i = text->insert_line; i < text->no_of_lines; i++)
        text->line_table[i] += text->insert_delta;

    text->insert_delta = 0;
}


_kernel_oserror *move_insertion(Text *text, int pos)
{
    int diff = text->insert_gap_end - text->insert_pos;

    if(diff == 0)
        return create_insertion(text, pos);
    else
    {
        char *base = get_handle(text->text_data)->base;

        if(pos < text->insert_pos)
            memmove(base + pos + diff, base + pos, text->insert_pos - pos);
        else
            memmove(base + text->insert_pos, base + text->insert_gap_end,
                    pos - text->insert_gap_end);
    }
    text->insert_pos = pos;
    text->insert_gap_end = pos + diff;

    update_lines(text);
    text->insert_line = line_index_of_char(text, pos);

    return NULL;
}


_kernel_oserror *create_insertion(Text *text, int pos)
{
    _kernel_oserror *err;
    Handle *handle = get_handle(text->text_data);

    if((err = extend_block(text->text_data, pos, INSERTION_GAP)) != NULL)
        return err;

    *(handle->base + pos) = '\0';

    text->insert_pos = pos;
    text->insert_gap_end = pos + INSERTION_GAP;
    text->insert_delta = 0;
    text->insert_line = line_index_of_char(text, pos);

    return NULL;
}


void close_insertion(Text *text)
{
    shrink_block(text->text_data, text->insert_pos,
                 text->insert_gap_end - text->insert_pos);

    text->insert_gap_end = text->insert_pos;

    update_lines(text);
}

static int line_len(Text *text, int line_no)
{
    int xpoints;

    if(line_no == text->insert_line)
    {
        int start = line_start(text, line_no);
        int len = text->insert_pos - start;
        char *start_pntr = text_to_mem(text, start);
        int xpoints2;

        if((text->insert_gap_end - text->insert_pos) > 0)
            *(get_handle(text->text_data)->base + text->insert_pos) = '\0';

        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                              text->font_handle, start_pntr, 1<<7|1<<8,
                              0xfffffff, 0, len,
                              &xpoints);

        len = line_end(text, line_no) - text->insert_pos + 1;
        start_pntr = text_to_mem(text, text->insert_pos);

        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                              text->font_handle, start_pntr, 1<<7|1<<8,
                              0xfffffff, 0, len,
                              &xpoints2);

        xpoints += xpoints2;
    }
    else
    {
        int start = line_start(text, line_no);
        int len = line_end(text, line_no) - start + 1;
        char *start_pntr = text_to_mem(text, start);

        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                              text->font_handle, start_pntr, 1<<7|1<<8,
                              0xfffffff, 0, len,
                              &xpoints);
    }
    _swix(Font_ConverttoOS,_IN(1)|_IN(2)|_OUT(1), xpoints, 0, &xpoints);

    return xpoints;
}

static _kernel_oserror *new_line(Scan *scan, int pos, char *end, char *start)
{
    scan->new_lines[scan->line_no++] = pos;
    if(scan->line_no == scan->max_line)
    {
        int extra = (end - start + 1) / 20 + 5;

        if((scan->new_lines = realloc(scan->new_lines,
                       (scan->max_line += extra) * sizeof(int))) == NULL)
            return make_error(TextGadgets_IntMallocFail, 0);
    }

    return NULL;
}

static _kernel_oserror *scan_text(Text *text, char *start_pntr, char *end, char *con, Scan *scan)
{
        _kernel_oserror *e;
        int             tab_stop = text->tab_stop;
       	char            *char_pntr = start_pntr;
       	int             xpoints, xp;
       	int             margin = text->margin;

        while(char_pntr <= end)
        {
            if(*char_pntr == ' ' || *char_pntr == '\t' || *char_pntr == '\n')
            {
               int old_line_no = scan->line_no;

                _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                                      text->font_handle, start_pntr, 1<<7|1<<8,
                                      0xffffff, 0, char_pntr - start_pntr,
                                      &xpoints);

                if((scan->x_pos + xpoints) > margin)
                {
                    if(scan->split_pos != NULL)
                    {
                        if((e = new_line(scan, scan->split_pos - con - 1, end, char_pntr)) != NULL)
                            return e;
                        scan->x_pos -= scan->split_xpoint;
                    }

                    while((scan->x_pos + xpoints) > margin)
                    {
                        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(1)|_OUT(3),
                                               text->font_handle, start_pntr, 1<<17|1<<7|1<<8,
                                               margin - scan->x_pos, 0, char_pntr - start_pntr,
                                               &start_pntr, &xp);

                        if((e = new_line(scan, (scan->split_pos = start_pntr) - con - 1, end,
                                            char_pntr)) != NULL)
                            return e;
                        scan->x_pos = 0;
                        xpoints -= xp;
                    }
                }

                scan->x_pos += xpoints;

                if(*char_pntr == ' ')
                    scan->x_pos += text->space;
                else
                    if(*char_pntr == '\t')
                    {
                        int offset = tab_stop - (scan->x_pos % tab_stop);
                        *++char_pntr = (char) offset;
                        *++char_pntr = (char) (offset >> 8);
                        *++char_pntr = (char) (offset >> 16);
                        scan->x_pos += offset;
                    }
                    else
                        if((old_line_no == scan->line_no) | (scan->split_pos != char_pntr))
                        {
                            if((e = new_line(scan, char_pntr - con, end, char_pntr)) != NULL)
                                return e;
                            scan->x_pos = 0;
                        }

                if(*char_pntr++ != '\n')
                {
                    scan->split_pos = char_pntr;
                    scan->split_xpoint = scan->x_pos;
                }
                else
                    scan->split_pos = NULL;
                start_pntr = char_pntr;
            }
            else
                char_pntr++;
        }

    if(start_pntr <= end)
    {
        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                          text->font_handle, start_pntr, 1<<7|1<<8,
                          0xffffff, 0, end - start_pntr + 1,
                          &xpoints);

        if((scan->x_pos + xpoints) > margin)
        {
            if(scan->split_pos != NULL)
            {
                if((e = new_line(scan, scan->split_pos - con - 1, end, start_pntr)) != NULL)
                    return e;
                scan->x_pos -= scan->split_xpoint;
            }

            while((scan->x_pos + xpoints) > margin)
            {
                _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(1)|_OUT(3),
                                       text->font_handle, start_pntr, 1<<17|1<<7|1<<8,
                                       margin - scan->x_pos, 0, end - start_pntr + 1,
                                       &start_pntr, &xp);

                if((e = new_line(scan, start_pntr - con - 1, end, start_pntr)) != NULL)
                    return e;
                scan->x_pos = 0;
                xpoints -= xp;
            }
            scan->split_pos = NULL;
        }
        scan->x_pos += xpoints;
    }

    return NULL;
}

_kernel_oserror *compose_text(Text *text)
{
    _kernel_oserror *err;
    Handle          *handle = get_handle(text->text_data);
    char            *end, *base = handle->base;
    int             insert_pos = text->insert_pos;
    Scan            scan;
    int             i;

    if(text->insert_gap_end > insert_pos)
        close_insertion(text);

    end = base + handle->size - 2;

    scan.max_line = (end - base + 1) / 20 + 5;
    scan.new_lines = malloc((scan.max_line + 1) * sizeof(int));

    /* If the malloc fails ... */
    if (scan.new_lines == NULL)
    {
      /* ... return an error message */
      return make_error(TextGadgets_IntMallocFail, 0);
    }

    scan.line_no = 0;

    scan.x_pos = 0;
    scan.split_pos = NULL;

    if((err = scan_text(text, base, end, base, &scan)) != NULL)
        return err;

    if((end < base) || (*end != '\n'))
        scan.new_lines[scan.line_no++] = end - base;

    if(scan.line_no > text->lne_tbl_sze)
        if((err = grow_lines_by(text, scan.line_no - text->lne_tbl_sze)) != NULL)
            return err;

    for(i = 0; i < scan.line_no; i++)
        text->line_table[i] = scan.new_lines[i];

    text->no_of_lines = scan.line_no;
    text->insert_line = text->insert_pos = 0;

    text->insert_line = line_index_of_char(text, insert_pos);
    text->insert_pos = insert_pos;

    if(text->sel_stop_pos != -1)
        text->sel_stop_line = line_index_of_char(text, text->sel_stop_pos);

    text->xmax_line = text->xmax = 0;
    for(i = 0; i < scan.line_no; i++)
    {
        text->xmax_table[i] = line_len(text, i);
        if(text->xmax_table[i] > text->xmax)
        {
            text->xmax_line = i;
            text->xmax = text->xmax_table[i];
        }
    }
    free(scan.new_lines);

    return NULL;
}


char *expand_tabs(char *str, int *len)
{
    char *new_str;
    int no_tabs = 0;
    char *pos = str, *pos2;

    while(*pos)
       if(*pos++ == '\t')
          no_tabs++;

    *len = pos - str;
    if(no_tabs == 0)
        return str;

    *len += no_tabs * 3;
    pos2 = new_str = malloc(*len + 1);

    if (new_str == NULL)
      return new_str;

    for(pos = str; (*pos2++ = *pos) != NULL;)
        if(*pos++ == '\t')
            pos2 += 3;

    return new_str;
}


_kernel_oserror *replace_text(Text *text, int from, int ex_to, const char *s,
                      int *first_line_p, int *last_line_p, int *line_delta_p)
{
    Handle          *handle = get_handle(text->text_data);
    _kernel_oserror *err;
    int             str_size;
    char            *str = expand_tabs((char *)s, &str_size);
    int             to = ex_to - 1;
    int             delta;
    int             insert_pos = text->insert_pos;
    int             insert_line = text->insert_line;
    int             first_line, last_line, last_line_end, first_line_start;
    char            *base = handle->base;
    int             line_delta;
    char            *end, *con;
    int             old_xmax;
    int             gap_size = text->insert_gap_end - insert_pos;
    Scan            scan;
    char            *old_end;
    int             old_line_no;
    int             old_split = 0;
    char            *start;
    int             ld = 0, ln = 0;
    int             step_back = FALSE;
    int             i;

    /* If expand_tabs failed */
    if (str == NULL)
    {
      /* return an error message */
      return make_error(TextGadgets_IntMallocFail, 0);
    }

    if((ex_to == -1) || (to > line_end(text, text->no_of_lines - 1)))
        to = line_end(text, text->no_of_lines - 1);

    if(from == -1 || (from > line_end(text, text->no_of_lines - 1)))
        from = line_end(text, text->no_of_lines - 1) + 1;

    delta = str_size - (to - from + 1);

    if((str_size == 0) && (delta == 0)) return NULL;

    first_line = line_index_of_char(text, from);

    if((to < insert_pos) && (from != insert_pos))
    {
        if(delta < 0)
            shrink_block(text->text_data, from, -delta);
        else
            if((err = extend_block(text->text_data, from, delta)) != NULL)
                return err;

        memcpy(base + from, str, str_size);

        insert_pos = text->insert_pos += delta;
        text->insert_gap_end += delta;
    }
    else
    {
        if(from <= insert_pos)
        {
            text->insert_gap_end += to - insert_pos + 1;
            text->insert_pos = insert_pos = from;
            text->insert_line = insert_line = first_line;
            gap_size = text->insert_gap_end - insert_pos;

            if((err = extend_block(text->text_data, from + gap_size,
                      str_size)) != NULL)
                return err;
        }
        else
        {
            if(delta < 0)
                shrink_block(text->text_data, from + gap_size, -delta);
            else
                if((err = extend_block(text->text_data, from + gap_size,
                        delta)) != NULL)
                    return err;
        }

        memcpy(base + from + gap_size, str, str_size);
    }

    if((first_line > 0) && (*text_to_mem(text, line_end(text, first_line - 1)) != '\n'))
    {
        first_line--;
        step_back = TRUE;
    }

    last_line = line_index_of_char(text, to);
    first_line_start = line_start(text, first_line);
    last_line_end = line_end(text, last_line);

    scan.max_line = (last_line_end - first_line_start + 1 + delta) / 20 + 5;
    scan.new_lines = malloc((scan.max_line + 1) * sizeof(int));

    /* If the malloc fails ... */
    if (scan.new_lines == NULL)
    {
      /* ... attempt to clean up, this is largely intelligent guesswork */
      if((to < insert_pos) && (from != insert_pos))
      {
        if (delta > 0)
          shrink_block(text->text_data, from, -delta);
      }
      else
      {
        if(from <= insert_pos)
        {
          shrink_block(text->text_data, from + gap_size, str_size);
        }
        else
        {
          if (delta > 0)
            shrink_block(text->text_data, from + gap_size, -delta);
        }
      }

      /* and return an error */
      return make_error(TextGadgets_IntMallocFail, 0);
    }

    scan.line_no = scan.x_pos = 0;
    scan.split_pos = NULL;

    if((first_line <= insert_line) && (last_line >= insert_line))
    {
        end = base + text->insert_pos - 1;
        if((err = scan_text(text, start = base + first_line_start, end, base, &scan)) != NULL)
            return err;

        con = base + gap_size + text->insert_delta;
        old_end = end + gap_size;
        if(gap_size > 0) *old_end = '\0';
        ld = scan.line_no - (insert_line - first_line);
        ln = scan.line_no;

        if(scan.split_pos != NULL)
        {
            old_split = scan.split_pos - base - 1;
            scan.split_pos = (char *) 1;
        }
        end = last_line_end + base + gap_size + delta;
        if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
           return err;
    }
    else
    {
        if(last_line < insert_line)
        {
            start = base + first_line_start,
            end = base + last_line_end + delta;
            con = base;
        }
        else
        {
            start = base + first_line_start + gap_size;
            end = base + last_line_end + delta + gap_size;
            con = base + gap_size + text->insert_delta;
        }
        if((err = scan_text(text, start, end, con, &scan)) != NULL)
            return err;
    }

    if((++last_line < text->no_of_lines) && ((start >  end) || (*end != '\n')))
    {
        old_line_no = scan.line_no;
        do {
           old_end = end;

           if(last_line == text->insert_line)
           {
               end = base + text->insert_pos - 1;
               if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
                   return err;

               con = base + gap_size + text->insert_delta;
               ld = scan.line_no -  (last_line - first_line);
               ln = scan.line_no;

               if(scan.split_pos != NULL)
               {
                   old_split = scan.split_pos - base - 1;
                   scan.split_pos = (char *) 1;
               }

               old_end = end + gap_size;
               if(gap_size > 0) *old_end = '\0';
           }
           end = line_end(text, last_line) + base + delta;
           if(last_line++ >= text->insert_line) end += gap_size;
           if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
               return err;

        } while((*end != '\n') && (last_line < text->no_of_lines) &&
               ((scan.line_no == old_line_no) ||
               ((scan.new_lines[scan.line_no - 1] + con) > old_end)));
    }
    last_line --;

    if((ln < scan.line_no) && (scan.new_lines[ln] == - (int) con))
    {
        scan.new_lines[ln] = old_split;
        ld++;
    }
    if((start > end) || (*end != '\n'))
        scan.new_lines[scan.line_no++] = end - con;

    line_delta = scan.line_no - (last_line - first_line + 1);
    *first_line_p = first_line;
    *last_line_p = last_line;
    *line_delta_p = line_delta;

    if(step_back && (scan.new_lines[0] == text->line_table[first_line]) &&
       ((first_line != insert_line) || ld == 0))
          (*first_line_p)++;

    if(last_line < insert_line)
    {
        for(i = last_line + 1; i < text->insert_line; i++)
            text->line_table[i] += delta;
        text->insert_delta += delta;
        text->insert_line += line_delta;
    }
    else
    {
        if(first_line < insert_line)
            text->insert_line += ld;
        for(i = last_line + 1; i < text->no_of_lines; i++)
            text->line_table[i] += delta;
    }

    if(line_delta != 0)
    {
        if(line_delta < 0)
            for(i = last_line + 1; i < text->no_of_lines; i++)
            {
                text->line_table[i + line_delta] = text->line_table[i];
                text->xmax_table[i + line_delta] = text->xmax_table[i];
            }
        else
        {
            int free = text->lne_tbl_sze - text->no_of_lines - line_delta;
            if((free < 0) && ((err = grow_lines_by(text, -free)) != NULL))
                return err;
            for(i = text->no_of_lines - 1; i > last_line; i--)
            {
                text->line_table[i + line_delta] = text->line_table[i];
                text->xmax_table[i + line_delta] = text->xmax_table[i];
            }
        }
    }

    for(i = 0; i < scan.line_no; i++)
        text->line_table[first_line + i] = scan.new_lines[i];

    free(scan.new_lines);

    text->no_of_lines += line_delta;

    old_xmax = text->xmax;

    for(i = first_line; i < (first_line + scan.line_no); i++)
    {
        text->xmax_table[i] = line_len(text, i);

        if(text->xmax_table[i] > text->xmax)
        {
            text->xmax_line = i;
            text->xmax = text->xmax_table[i];
        }
    }

    if(text->xmax == old_xmax)
    {
      if(text->xmax_line > last_line)
          text->xmax_line += line_delta;
      else
          if(text->xmax_line >= first_line)
          {
              text->xmax_line = 0;
              text->xmax = text->xmax_table[0];
              for(i = 0; i < text->no_of_lines; i++)
                  if(text->xmax_table[i] > text->xmax)
                  {
                      text->xmax_line = i;
                      text->xmax = text->xmax_table[i];
                  }
          }
    }

    if(s != str)
        free(str);

    return NULL;
}


_kernel_oserror *insert_text(Text *text, char *s,
                      int *first_line_p, int *last_line_p, int *line_delta)
{
    Handle          *handle = get_handle(text->text_data);
    _kernel_oserror *err;
    int             left = text->insert_gap_end - text->insert_pos;
    int             str_size;
    char            *str = expand_tabs((char *) s, &str_size);
    char            *start, *end, *con, *char_pntr;
    int             i, old_xmax;
    char            *base = handle->base;
    int             gap_size;
    int             ld, ln;
    int             first_line = text->insert_line;
    int             last_line = first_line;
    char            *old_end;
    Scan            scan;
    int             new_lines[10];
    int             old_split = 0;
    int             old_line_no;

    /* If expand_tabs failed */
    if (str == NULL)
    {
      /* return an error message */
      return make_error(TextGadgets_IntMallocFail, 0);
    }

    scan.new_lines = new_lines;
    scan.max_line = (sizeof(new_lines) / sizeof(new_lines[0])) - 1;
    scan.line_no = 0;

    if(left <= str_size)
    {
        left -= str_size + INSERTION_GAP;
        if((err = extend_block(text->text_data, text->insert_pos, -left))
               != NULL)
            return err;

        text->insert_gap_end -= left;
    }

    memcpy(end = base + text->insert_pos, str, str_size);

    text->insert_delta += str_size;
    text->insert_pos += str_size;
    gap_size = text->insert_gap_end - text->insert_pos;

    *(base + text->insert_pos) = '\0';

    start = base + line_start(text, first_line);

    scan.x_pos = 0;
    scan.split_pos = NULL;

    if((last_line > 0) && (*(start - 1) != '\n'))
    {
        for(char_pntr = start;
            (*char_pntr != ' ') && (*char_pntr != '\t') && (char_pntr < end);
            char_pntr++);

        if(char_pntr == end)
            start = base + line_start(text, --first_line);
    }

    end = base + text->insert_pos - 1;
    if((err = scan_text(text, start, end, base, &scan)) != NULL)
        return err;

    con = base + gap_size + text->insert_delta;
    old_end = end + gap_size;
    if(gap_size > 0) *old_end = '\0';
    ld = scan.line_no -  (last_line - first_line);
    ln = scan.line_no;

    if(scan.split_pos != NULL)
    {
        old_split = scan.split_pos - base - 1;
        scan.split_pos = (char *) 1;
    }

    end = line_end(text, last_line++) + base + gap_size;
    if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
        return err;

    if((*end != '\n') && (last_line < text->no_of_lines))
    {
        do {
           old_end = end;
           end = line_end(text, last_line++) + base + gap_size;

           old_line_no = scan.line_no;
           if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
               return err;

        } while((*end != '\n') && (last_line < text->no_of_lines) &&
               ((scan.line_no == old_line_no) ||
               ((scan.new_lines[scan.line_no - 1] + con) > old_end)));
    }

    if((ln < scan.line_no) && (scan.new_lines[ln] == - (int) con))
    {
        scan.new_lines[ln] = old_split;
        ld++;
    }

    if(*end != '\n')
        scan.new_lines[scan.line_no++] =  end - con;

    *line_delta = scan.line_no - (last_line - first_line);
    *last_line_p = last_line - 1;
    if(*line_delta != 0)
    {
        if(*line_delta < 0)
            for(i = last_line; i < text->no_of_lines; i++)
            {
                text->line_table[i + *line_delta] = text->line_table[i];
                text->xmax_table[i + *line_delta] = text->xmax_table[i];
            }
        else
        {
            int free = text->lne_tbl_sze - text->no_of_lines - *line_delta;
            if((free < 0) && ((err = grow_lines_by(text, -free)) != NULL))
                return err;
            for(i = text->no_of_lines - 1; i >= last_line; i--)
            {
                text->line_table[i + *line_delta] = text->line_table[i];
                text->xmax_table[i + *line_delta] = text->xmax_table[i];
            }
        }
    }
     for(i = 0; i < scan.line_no; i++)
        text->line_table[first_line + i] = scan.new_lines[i];

    *first_line_p = first_line;

    text->insert_line += ld;
    text->no_of_lines += *line_delta;

    old_xmax = text->xmax;

    for(i = first_line; i < (first_line + scan.line_no); i++)
    {
        text->xmax_table[i] = line_len(text, i);

        if(text->xmax_table[i] > text->xmax)
        {
            text->xmax_line = i;
            text->xmax = text->xmax_table[i];
        }
    }

    if(text->xmax == old_xmax)
    {
      if(text->xmax_line > first_line)
          text->xmax_line += *line_delta;
      else
          if(text->xmax_line == first_line)
          {
              text->xmax_line = 0;
              text->xmax = text->xmax_table[0];
              for(i = 0; i < text->no_of_lines; i++)
                  if(text->xmax_table[i] > text->xmax)
                  {
                      text->xmax_line = i;
                      text->xmax = text->xmax_table[i];
                  }
          }
    }

    if(s != str)
        free(str);

    return NULL;
}


char *get_text(Text *text, int from, int ex_to, char *buff)
{
    char *base = get_handle(text->text_data)->base;
    int to = ex_to - 1;

    if((ex_to == -1) || (to > line_end(text, text->no_of_lines - 1)))
        to = line_end(text, text->no_of_lines - 1);

    if(to < text->insert_pos)
        memcpy(buff, base + from, to - from + 1);
    else
    {
        if(from >= text->insert_pos)
            memcpy(buff, base + from - text->insert_pos +
                    text->insert_gap_end, to - from + 1);
        else
        {
            int size;
            memcpy(buff, base + from, size = text->insert_pos - from);
            memcpy(buff + size, base + text->insert_gap_end,
                   to - text->insert_pos + 1);
        }
    }
    *(buff + to - from + 1) = '\0';
    return buff;
}


char *get_line(Text *text, int line_no, char *buff)
{
    return get_text(text, line_start(text, line_no),
                          line_end(text, line_no) + 1, buff);
}


int get_text_size(Text *text)
{
    return line_end(text, text->no_of_lines - 1) + 1;
}


int line_start(Text *text, int line_no)
{
    int start;

    if(line_no == 0)
        return 0;

    start = text->line_table[line_no - 1] + 1;
    return line_no <= text->insert_line ? start : start + text->insert_delta;
}


int line_end(Text *text, int line_no)
{
    int end;

    if(line_no >= text->no_of_lines)
       line_no = text->no_of_lines - 1;

    end = text->line_table[line_no];
    return line_no < text->insert_line ? end : end + text->insert_delta;
}


int line_index_of_char(Text *text, int pos)
{
    int low, high, i;
    int *lines = text->line_table;

    if(pos > (lines[text->insert_line] + text->insert_delta))
    {
        low = text->insert_line;
        high = text->no_of_lines - 1;
        pos -= text->insert_delta;
    }
    else
    {
        low = 0;
        high = text->insert_line;
    }

    if(pos <= lines[low])
       return low;

    while(high - low > 1)
    {
        i = (high + low) / 2;
        if(lines[i] < pos)
            low = i;
        else
            high = i;
    }
    return high;
}


char *text_to_mem(Text *text, int text_pos)
{
    int pos = (text_pos < text->insert_pos ? text_pos :
                    text_pos + text->insert_gap_end - text->insert_pos);

    return get_handle(text->text_data)->base + pos;
}


_kernel_oserror *grow_lines(Text *text, int text_size)
{
    int by  = text_size / 20 + 5; /* Rough estimate of how many lines
                                     needed for text */

    return grow_lines_by(text, by);
}


_kernel_oserror *grow_lines_by(Text *text, int by)
{
    int *new_table, *new_xmax, new_size;

    new_size = text->lne_tbl_sze + by;

    if((new_table = realloc(text->line_table,
                               new_size * sizeof(int))) == NULL)
        return make_error(TextGadgets_IntMallocFail, 0);

    if((new_xmax = realloc(text->xmax_table,
                               new_size * sizeof(int))) == NULL)
        return make_error(TextGadgets_IntMallocFail, 0);

    text->line_table = new_table;
    text->xmax_table = new_xmax;
    text->lne_tbl_sze = new_size;

    return NULL;
}


void char_block(Text *text, int xcoord, int ycoord, int *line, int *index,
                int *xpos, int *ypos)
{
    int xpoints, ypoints;
    int line_no = ycoord / text->line_height;

    if(line_no >= text->no_of_lines)
       line_no = text->no_of_lines - 1;
    else
        if(line_no < 0)
            line_no = 0;

    _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1), xcoord, 0, &xpoints);

    if(line_no == text->insert_line)
    {
        int start = line_start(text, line_no);
        int end = line_end(text, line_no);
        int len = text->insert_pos - start;
        char *start_pntr = text_to_mem(text, start);
        char *char_pntr;
        int points = xpoints;

        if((text->insert_gap_end - text->insert_pos) > 0)
            *(get_handle(text->text_data)->base + text->insert_pos) = '\0';

        _swix(Font_ScanString,_INR(0,4)|_IN(7)|
                              _OUT(1)|_OUT(3)|_OUT(4), text->font_handle,
                              start_pntr, 1<<17|1<<7|1<<8, xpoints, 0, len,
                              &char_pntr, &xpoints, &ypoints);

        *index = start + (int)(char_pntr - start_pntr);
        if(*index == text->insert_pos)
        {
            len = end - text->insert_pos + 1;
            start_pntr = text_to_mem(text, text->insert_pos);
            points -= xpoints;

            _swix(Font_ScanString,_INR(0,4)|_IN(7)|
                                  _OUT(1)|_OUT(3)|_OUT(4), text->font_handle,
                                   start_pntr, 1<<17|1<<7|1<<8, points, 0,
                                  len, &char_pntr, &points, &ypoints);

            *index += (int)(char_pntr - start_pntr);
            xpoints += points;
        }
    }
    else
    {
        int start = line_start(text, line_no);
        int len = line_end(text, line_no) - start + 1;
        char *start_pntr = text_to_mem(text, start);
        char *char_pntr;

        _swix(Font_ScanString,_INR(0,4)|_IN(7)|
                              _OUT(1)|_OUT(3)|_OUT(4), text->font_handle,
                              start_pntr, 1<<17|1<<7|1<<8, xpoints, 0,
                              len, &char_pntr, &xpoints, &ypoints);

        *index = start + (int)(char_pntr - start_pntr);
    }
    _swix(Font_ConverttoOS,_IN(1)|_IN(2)|_OUT(1), xpoints, 0, xpos);
    *ypos = (line_no + 1) * text->line_height;
    *line = line_no;
}


void char_pos(Text *text, int index, int *xpos, int *ypos)
{
    int xpoints;
    int line_no = line_index_of_char(text, index);

    if((line_no == text->insert_line) && (index > text->insert_pos))
    {
        int start = line_start(text, line_no);
        int len = text->insert_pos - start;
        char *start_pntr = text_to_mem(text, start);
        int xpoints2;

        if((text->insert_gap_end - text->insert_pos) > 0)
            *(get_handle(text->text_data)->base + text->insert_pos) = '\0';

        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                              text->font_handle, start_pntr, 1<<7|1<<8,
                              0xfffffff, 0, len,
                              &xpoints);

        len = index - text->insert_pos;
        start_pntr = text_to_mem(text, text->insert_pos);

        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                              text->font_handle, start_pntr, 1<<7|1<<8,
                              0xfffffff, 0, len,
                              &xpoints2);

        xpoints += xpoints2;
    }
    else
    {
        int start = line_start(text, line_no);
        int len = index - start;
        char *start_pntr = text_to_mem(text, start);

        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                              text->font_handle, start_pntr, 1<<7|1<<8,
                              0xfffffff, 0, len,
                              &xpoints);
    }
    _swix(Font_ConverttoOS,_IN(1)|_IN(2)|_OUT(1), xpoints, 0, xpos);
    *ypos = (line_no + 1) * text->line_height;
}


static void draw_line(Text *text, int line_no, int base, int *block, int right,
               int fg, int bg)
{
    int start = line_start(text, line_no);
    int len = line_end(text, line_no) - start + 1;
    char *start_pntr = text_to_mem(text, start);

    _swix(ColourTrans_SetFontColours,_IN(0)|_IN(1)|_IN(2)|_IN(3), 0, bg,
          fg, 14);

    block[6] = right;
    _swix(Font_Paint,_INR(0,5)|_IN(7),
                     0, start_pntr, 1<<1|1<<5|1<<7|1<<8, block[4], base,
                     block, len);
}

static void draw_line2(Text *text, int line_no, int split, int base, int *block,
                int right, int fg, int bg, int fg2, int bg2)
{
    int start = line_start(text, line_no);
    int len = split - start;
    char *start_pntr = text_to_mem(text, start);
    int split_pnt;

    _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                      0, start_pntr,1<<7|1<<8, 0xfffffff, 0, len, &split_pnt);
    block[6] = block[4] + split_pnt;

    _swix(ColourTrans_SetFontColours,_IN(0)|_IN(1)|_IN(2)|_IN(3), 0, bg,
          fg, 14);


    _swix(Font_Paint,_INR(0,5)|_IN(7),
                     0, start_pntr, 1<<1|1<<5|1<<7|1<<8, block[4], base,
                     block, len);

    len = line_end(text, line_no) - split + 1;
    start_pntr = text_to_mem(text, split);
    block[4] = block[6];
    block[6] = right;

    _swix(ColourTrans_SetFontColours,_IN(0)|_IN(1)|_IN(2)|_IN(3), 0, bg2,
          fg2, 14);

    _swix(Font_Paint,_INR(0,5)|_IN(7),
                     0, start_pntr, 1<<1|1<<5|1<<7|1<<8, block[4], base,
                     block, len);
}

static void draw_insert(Text *text, int line_no, int split, int base,
              int *block, int right, int fg, int bg, int fg2, int bg2)
{
    int start = line_start(text, line_no);
    int len = split - start;
    char *start_pntr = text_to_mem(text, start);
    int split_pnt;

    if((text->insert_gap_end - text->insert_pos) > 0)
        *(get_handle(text->text_data)->base + text->insert_pos) = '\0';

    _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                      0, start_pntr,1<<7|1<<8, 0xfffffff, 0, len, &split_pnt);
    block[6] = block[4] + split_pnt;

    _swix(ColourTrans_SetFontColours,_IN(0)|_IN(1)|_IN(2)|_IN(3), 0, bg,
          fg, 14);


    _swix(Font_Paint,_INR(0,5)|_IN(7),
                     0, start_pntr, 1<<1|1<<5|1<<7|1<<8, block[4], base,
                     block, len);

    len = line_end(text, line_no) - split + 1;
    start_pntr = text_to_mem(text, split);
    block[4] = block[6];
    block[6] = right;

    _swix(ColourTrans_SetFontColours,_IN(0)|_IN(1)|_IN(2)|_IN(3), 0, bg2,
          fg2, 14);

    _swix(Font_Paint,_INR(0,5)|_IN(7),
                     0, start_pntr, 1<<1|1<<5|1<<7|1<<8, block[4], base,
                     block, len);
}

static void draw_line3(Text *text, int line_no, int split1, int split2,
                int base, int *block, int right, int fg, int bg)
{
    int start = line_start(text, line_no);
    int len = split1 - start;
    char *start_pntr = text_to_mem(text, start);
    int split_pnt;

    _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                      0, start_pntr, 1<<7|1<<8, 0xfffffff, 0, len, &split_pnt);
    block[6] = block[4] + split_pnt;

    _swix(ColourTrans_SetFontColours,_IN(0)|_IN(1)|_IN(2)|_IN(3), 0, bg,
          fg, 14);

    _swix(Font_Paint,_INR(0,5)|_IN(7),
                     0, start_pntr, 1<<1|1<<5|1<<7|1<<8, block[4], base,
                     block, len);

    len = split2 - split1;
    start_pntr = text_to_mem(text, split1);

    _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                    0, start_pntr, 1<<7|1<<8, 0xfffffff, 0, len, &split_pnt);
    block[4] = block[6];
    block[6] += split_pnt;

    _swix(ColourTrans_SetFontColours,_IN(0)|_IN(1)|_IN(2)|_IN(3), 0, fg,
          bg, 14);

    _swix(Font_Paint,_INR(0,5)|_IN(7),
                     0, start_pntr, 1<<1|1<<5|1<<7|1<<8, block[4], base,
                     block, len);
    len = line_end(text, line_no) - split2 + 1;
    start_pntr = text_to_mem(text, split2);
    block[4] = block[6];
    block[6] = right;

    _swix(ColourTrans_SetFontColours,_IN(0)|_IN(1)|_IN(2)|_IN(3), 0, bg,
          fg, 14);

    _swix(Font_Paint,_INR(0,5)|_IN(7),
                     0, start_pntr, 1<<1|1<<5|1<<7|1<<8, block[4], base,
                     block, len);
}

static void draw_selected(Text *text, int line1, int pos1, int line2, int pos2,
                   int base, int right, int *block, int fg, int bg)
{
    if(line1 < line2)
        draw_line2(text, line1, pos1, base, block, right, fg, bg, bg, fg);
    else
        if(line1 > line2)
            draw_line2(text, line1, pos1, base, block, right, bg, fg,
                       fg, bg);
        else
            if(pos1 < pos2)
                draw_line3(text, line1, pos1, pos2, base, block, right,
                           fg, bg);
            else
                draw_line3(text, line1, pos2, pos1, base, block, right,
                           fg, bg);
}


void display_lines(Text *text, int ymin, int ymax, int xorg, int yorg,
                   int fg, int bg)
{
    int ypos, i, step;
    int top_line, bottom_line;
    int top, bottom, left, right;
    int block[8];
    int start, stop;

    if(text->insert_line < text->sel_stop_line)
    {
        start = text->insert_line;
        stop = text->sel_stop_line;
    }
    else
    {
        stop = text->insert_line;
        start = text->sel_stop_line;
    }

    block[0] = block[1] = block[2] = block[3] = 0;

    if((top_line = ymin / text->line_height) < text->no_of_lines)
    {
        bottom_line = ymax / text->line_height;
        if(bottom_line >= text->no_of_lines)
            bottom_line = text->no_of_lines - 1;

        top = yorg - (top_line * text->line_height);
        bottom = top - text->line_height;
        ypos = top - text->font_base;

        _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1)|_OUT(2),
              xorg, top, &left, &top);
        _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1)|_OUT(2),
              0xffff, bottom, &right, &bottom);
        _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1)|_OUT(2),
              text->line_height, ypos, &step, &ypos);

        _swix(Font_SetFont,_IN(0), text->font_handle);

        for(i = top_line; i <= bottom_line; i++)
        {
            block[4] = left;
            block[5] = bottom;
            block[7] = top;

            if(i == text->insert_line)
                if(text->sel_stop_pos == -1)
                    draw_insert(text, i, text->insert_pos, ypos, block, right,
                               fg, bg, fg, bg);
                else
                    draw_selected(text, i, text->insert_pos,
                                  text->sel_stop_line, text->sel_stop_pos,
                                  ypos, right, block, fg, bg);
            else
                 if(i == text->sel_stop_line)
                     if(text->sel_stop_pos != -1)
                         draw_selected(text, i, text->sel_stop_pos,
                                  text->insert_line, text->insert_pos,
                                  ypos, right, block, fg, bg);
                    else
                        draw_line(text, i, ypos, block, right, fg, bg);
                 else
                     if((text->sel_stop_pos == -1) || (i > stop) ||
                         (i < start))
                         draw_line(text, i, ypos, block, right, fg, bg);
                     else
                         draw_line(text, i, ypos, block, right, bg, fg);

            top = bottom;
            bottom -= step;
            ypos -= step;
        }
    }
}


#if 0
void dump_object(FILE *out, Text *text)
{
    int i;
    char line[256];

    fprintf(out, "\n\nTEXT OBJECT\n-----------\n\n");
    fprintf(out, "Insert_line   : %d\n", text->insert_line);
    fprintf(out, "Insert_delta  : %d\n", text->insert_delta);
    fprintf(out, "Insert_pos    : %d\n", text->insert_pos);
    fprintf(out, "Insert_gap_end: %d\n", text->insert_gap_end);
    fprintf(out, "No_of_lines   : %d\n", text->no_of_lines);
    fprintf(out, "lne_tbl_sze   : %d\n", text->lne_tbl_sze);
    fprintf(out, "sel_stop_pos  : %d\n", text->sel_stop_pos);
    fprintf(out, "sel_stop_line : %d\n", text->sel_stop_line);
    fprintf(out, "xmax          : %d\n", text->xmax);
    fprintf(out, "xmax_line     : %d\n", text->xmax_line);

    fprintf(out, "\nLine table:\n");
    for(i = 0; i < text->no_of_lines; i++)
    {
        fprintf(out, "\tLine: %d\n", i);
        fprintf(out, "\t\traw: %d start: %d end: %d xmax: %d\n", text->line_table[i],
                  line_start(text, i), line_end(text, i), text->xmax_table[i]);
        fprintf(out, "\t\t%s", get_line(text, i, line));
    }

    fprintf(out, "\nMemory block:\n");
    fprintf(out, "\tbase address: %d\n", (int) text->text_data->base);
    fprintf(out, "\tsize        : %d\n", text->text_data->size);
    fprintf(out, "\tfree        : %d\n", text->text_data->free);
}
#endif
@


1.8
log
@Internationalised
Supporting code borrowed from 'Iconbar' toolbox module.
Tested in a ROM build and RAM build, triggering one error message and checking the dynamic area in task manager.

Version 0.37. Tagged as 'Gadgets-0_37'
@
text
@d786 1
d797 2
a798 10
    scan.new_lines = malloc(10 * sizeof(int));

    /* If the malloc fails */
    if (scan.new_lines == NULL)
    {
      /* return an error message */
      return make_error(TextGadgets_IntMallocFail, 0);
    }

    scan.max_line = 9;
a902 1
   free(scan.new_lines);
@


1.7
log
@Change to link against tboxlibint
For some reason this toolbox module was unique in linking against the public toolboxlib rather than the internal one, this meant having to carefully tippy toe around not mixing header files (as they contain similar but differently named definitions).
A massive search and replace job.
Tested briefly using ResEd/ResTest and a textarea and scrolllist in a ROM build.
Requires Common-0_21.

Version 0.36. Tagged as 'Gadgets-0_36'
@
text
@d32 1
a36 1
#include "Text.h"
d71 1
a71 1
        return (_kernel_oserror *)&e_outofmem;
d256 1
a256 1
            return (_kernel_oserror *)&e_outofmem;
d396 1
a396 1
      return (_kernel_oserror *)&e_outofmem;
d500 1
a500 1
      return (_kernel_oserror *)&e_outofmem;
d590 1
a590 1
      return (_kernel_oserror *)&e_outofmem;
d793 1
a793 1
      return (_kernel_oserror *)&e_outofmem;
d802 1
a802 1
      return (_kernel_oserror *)&e_outofmem;
d1077 1
a1077 1
        return (_kernel_oserror *)&e_outofmem;
d1081 1
a1081 1
        return (_kernel_oserror *)&e_outofmem;
@


1.6
log
@TextGadgets module fixes & improvements
Detail:
  c/ScrollList, c/TextArea - ScrollList_SetFont and TextArea_SetFont now accept font handles instead of just font names. The handles are handled in the same way as the Window module, i.e. the handle will be managed and freed by the TextGadgets modules. Fixes bug #212.
  c/ScrollList, c/Scrollbar, c/TextArea - Fix handling of Toolbox_ObjectDeleted events. Original code would corrupt the object lists when deleting items, and reallocate much more memory than was actually needed. Fixes bug #214
  c/MemMan - Fix grow_handlers to not leave handle_list as NULL if the realloc fails. Fixes bug #216.
  c/MemMan, c/TextArea, c/TextMan, h/MemMan, h/TextMan - Changed how the 'Handle' type is handled. Instead of MemMan giving out direct pointers to Handle instances, it now gives out identifiers (HandleId). These identifiers are then converted to Handle pointers via get_handle whenever the contents need to be accessed. This allows the handle_list to be safely realloc'd without breaking all the existing Handle pointers. Fixes bug #217
  c/MemMan - Reduced HDNLE_GRW_BY from 1000 to 128 to save a bit of memory
Admin:
  Module compiles and runs, but actual functionality is untested.
  Fixes bugs 212, 214, 216, 217.


Version 0.32. Tagged as 'Gadgets-0_32'
@
text
@d31 1
a31 2
#include "toolbox.h"
#include "window.h"
d34 3
a36 2
#include "wimplib.h"
#include "TextGadget.h"
@


1.5
log
@Function returns no longer use stack structures.
Previously, a number of errors were contructed as automatic variables then returned to the caller - potentially accessing stale stack area. All error blocks are now held in ROM and cast from there.
Error numbers are now not &00000000 or &20202020, using the allocated base - requires 'Common-0_15'.
Trimmed some unused debugging code out, saves about 3k.
Renamed C++ clashing variables to stop the compiler moaning.
Implemented feature request to accept the empty string "" as no font handle in _SetFont calls.
At some point, this module needs internationalising.

Version 0.31. Tagged as 'Gadgets-0_31'
@
text
@d61 1
a61 1
    Handle          *handle;
d74 1
a74 1
    *(handle->base) = '\0';
d155 1
a155 1
        char *base = text->text_data->base;
d176 1
d181 1
a181 1
    *(text->text_data->base + pos) = '\0';
d214 1
a214 1
            *(text->text_data->base + text->insert_pos) = '\0';
d378 2
a379 1
    char            *end, *base = text->text_data->base;
d387 1
a387 1
    end = base + text->text_data->size - 2;
d473 1
d482 1
a482 1
    char            *base = text->text_data->base;
d772 1
d779 1
a779 1
    char            *base = text->text_data->base;
d956 1
a956 1
    char *base = text->text_data->base;
d1056 1
a1056 1
    return text->text_data->base + pos;
d1115 1
a1115 1
            *(text->text_data->base + text->insert_pos) = '\0';
d1171 1
a1171 1
            *(text->text_data->base + text->insert_pos) = '\0';
d1262 1
a1262 1
        *(text->text_data->base + text->insert_pos) = '\0';
@


1.4
log
@Fix for data abort triggered in the following case:
 create res file with a single TextArea in it
 change flags to be auto create and auto display
 drop into restest
 delete the 8 character "TextArea" default text
 press enter
 press backspace
Also,there was a _swix(&107) left in from some point in the past.

Version 0.27. Tagged as 'Gadgets-0_27'
@
text
@a27 1

d31 6
a38 3
#define TRUE  1
#define FALSE 0

a53 1

d55 1
a55 1
char		*expand_tabs(char *str, int *len);
d71 1
a71 1
        return (_kernel_oserror*)"    Out of memory.";
d255 1
a255 1
            return (_kernel_oserror *)"    Out of memory";
d394 1
a394 1
      return (_kernel_oserror*)"    Out of memory.";
d484 1
a484 1
    Scan	    scan;
d497 1
a497 1
      return (_kernel_oserror*)"    Out of memory.";
d587 1
a587 1
      return (_kernel_oserror*)"    Out of memory.";
d789 1
a789 1
      return (_kernel_oserror*)"    Out of memory.";
d798 1
a798 1
      return (_kernel_oserror*)"    Out of memory.";
d1073 1
a1073 1
        return (_kernel_oserror*)"    Out of memory.";
d1077 1
a1077 1
        return (_kernel_oserror*)"    Out of memory.";
d1428 1
a1428 1

d1460 1
@


1.3
log
@Changed out of memory error message to not be prefixed JBERANEK.
Changed TextArea windows to be created with the NoBounds window flag set.

Version 0.11. Tagged as 'Gadgets-0_11'
@
text
@d631 1
a631 1
    if((++last_line < text->no_of_lines) && ((*end != '\n') || (start >  end)))
@


1.2
log
@* Merged in fixes from Daytona branch (tag sbrodie_Daytona_merge_19Jun98)

* Fixed 'long' #include directives.
* Removed duplicate function prototypes from TextGadget.h (use ModHdr.h
  for correct prototypes).
* Capability to build with pre- and post-5.16 versions of CMHG.
@
text
@d393 1
a393 1
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";
d496 1
a496 1
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";
d586 1
a586 1
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";
d788 1
a788 1
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";
d797 1
a797 1
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
 * rlougher 18/12/96 Added code to keep track of max x-extent during editing 
d27 1
d34 12
d54 1
d64 1
a64 1
    if((err = create_block(size, &handle)) != NULL)
d73 5
a77 3
    text->insert_line = 0;
    text->insert_delta = 0;
    text->insert_pos = 0;
d79 8
a86 8
    text->no_of_lines = 1;
    text->lne_tbl_sze = 0;
    text->line_table = NULL;
    text->xmax_table = NULL;
    text->sel_stop_pos = -1;
    text->sel_stop_line = 0;
    text->xmax = 0;
    text->xmax_line = 0;
d98 1
d100 1
d102 1
a102 3
    set_font(text, font_handle);
    *t_pntr = text;
    return NULL;
d106 1
a106 1
void set_font(Text *text, int font_handle)
d115 4
d120 3
a122 1
        compose_text(text);
d126 7
a132 6
//static void delete_text(Text *text)
//{
//    delete_block(text->text_data);
//    free(text->line_table);
//    free(text);
//}
d179 2
a199 1

d245 128
d376 3
a378 4
    int             line_no = 0;
    int             max_lines = text->lne_tbl_sze;
    int             *lines = text->line_table;
    char            *end, *char_pntr, *base = text->text_data->base;
d381 1
a381 1
    if(text->insert_gap_end > text->insert_pos)
d384 7
a390 3
    char_pntr = base;
    end = base + text->text_data->size;
    do
d392 24
a415 9
        while((char_pntr < end) && (*char_pntr++ != '\n'));
        if(line_no >= max_lines)
        {
            if((err = grow_lines(text, end - char_pntr)) != NULL)
                return err;
            max_lines = text->lne_tbl_sze;
        }
        lines[line_no++] = char_pntr - base - 1;
    } while(char_pntr < end);
d417 2
a418 1
    text->no_of_lines = line_no;
d420 2
a421 2
    text->xmax_line = 0;
    text->xmax = text->xmax_table[0];
d423 2
a424 1
    for(i = 0; i < line_no; i++)
a426 1

d433 1
d438 30
a467 1
_kernel_oserror *replace_text(Text *text, int from, int ex_to, const char *str,
d471 2
a473 1
    int             str_size = strlen(str);
d476 1
a477 2
    int             line_no = 0;
    int             *new_lines, max_line;
a478 1
    char            *char_pntr, *end;
d480 10
a490 1
    char            *con;
d492 6
a497 1
    int             old_xmax;
d503 1
a503 1
        from = line_end(text, text->no_of_lines - 1) + 1;    
d506 1
a506 1
    
d508 1
a508 1
    
d510 1
a510 8
    last_line = line_index_of_char(text, to);
    
    first_line_start = line_start(text, first_line);
    last_line_end = line_end(text, last_line);
    
    max_line = (last_line_end - first_line_start + 1 + delta) / 20 + 5;
    new_lines = malloc(max_line * sizeof(int));
    
a512 4
        char_pntr = base + first_line_start;
        end = base + to + delta;
        con = base + 1;

d521 1
a521 17
        while(char_pntr <= end)
            if(*char_pntr++ == '\n')
            {                           
                new_lines[line_no++] = char_pntr - con;
                if(line_no == max_line)
                    if((new_lines = realloc(new_lines, (max_line += ((end - char_pntr
                                         + 1) / 20 + 5)) * sizeof(int))) == NULL)
                        return (_kernel_oserror *)"  Out of memory";
            }
            
        if((last_line_end != to) || (last_line == (text->no_of_lines -1)))
           new_lines[line_no++] = last_line_end + delta;
        else if((str_size == 0) || (*end != '\n'))
                new_lines[line_no++] = line_end(text, ++last_line) + delta;

        text->insert_delta += delta;
        text->insert_pos += delta;
a522 10

        if(last_line == text->insert_line)
            new_lines[line_no - 1] -= text->insert_delta;
        else
            for(i = last_line + 1; i < text->insert_line; i++)
                text->line_table[i] += delta;

        line_delta = line_no - (last_line - first_line + 1);
        text->insert_line += line_delta;

a525 2
        int gap_size;

d530 1
a530 1
            text->insert_line = first_line;
a538 2
            gap_size = text->insert_gap_end - insert_pos;

d547 12
a558 3
        char_pntr = base + from + gap_size;
        end = base + last_line_end + delta + gap_size;
        con = base + gap_size + text->insert_delta + 1;
d560 2
a561 11
        memcpy(char_pntr, str, str_size);
                
        while(char_pntr <= end)
            if(*char_pntr++ == '\n')
            {                           
                new_lines[line_no++] = char_pntr - con;
                if(line_no == max_line)
                    if((new_lines = realloc(new_lines, (max_line += ((end - char_pntr
                                            + 1) / 20 + 5)) * sizeof(int))) == NULL)
                        return (_kernel_oserror *)"  Out of memory";
            }
d563 15
a577 2
        if(last_line == (text->no_of_lines - 1))
            new_lines[line_no++] = char_pntr - con;
d579 9
a587 2
            if(*end != '\n')
                new_lines[line_no++] = text->line_table[++last_line] + delta;
d589 8
a596 2
        for(i = last_line + 1; i < text->no_of_lines; i++)
            text->line_table[i] += delta;
d598 5
a602 1
        line_delta = line_no - (last_line - first_line + 1);
d604 1
a604 3
    }
    if(line_delta < 0)
        for(i = last_line + 1; i < text->no_of_lines; i++)
d606 2
a607 2
            text->line_table[i + line_delta] = text->line_table[i];
            text->xmax_table[i + line_delta] = text->xmax_table[i];
d609 4
d615 7
a621 4
        int free = text->lne_tbl_sze - text->no_of_lines - line_delta;
        if((free < 0) && ((err = grow_lines_by(text, -free)) != NULL))
            return err;
        for(i = text->no_of_lines - 1; i > last_line; i--)
d623 3
a625 2
            text->line_table[i + line_delta] = text->line_table[i];
            text->xmax_table[i + line_delta] = text->xmax_table[i];
d627 2
d631 43
a673 6
    for(i = 0; i < line_no; i++)
        text->line_table[first_line + i] = new_lines[i];

    free(new_lines);
    
    text->no_of_lines += line_delta;
d675 1
d680 47
d729 1
a729 1
    for(i = first_line; i < (first_line + line_no); i++)
d757 4
d765 2
a766 2
_kernel_oserror *insert_text(Text *text, char *str,
                      int *first_line, int *line_delta)
d769 30
a798 8
    int free = text->insert_gap_end - text->insert_pos;
    int str_size = strlen(str);
    char *char_pntr = text->text_data->base + text->insert_pos;
    char *end = char_pntr + str_size;
    char *con = text->text_data->base + 1;
    int new_lines[100];
    int line_no = 0;
    int i;
d800 2
a801 1
    int old_xmax;
d803 1
a803 1
    if(free < str_size)
d805 2
a806 2
        free -= str_size + INSERTION_GAP;
        if((err = extend_block(text->text_data, text->insert_pos, -free))
d810 1
a810 1
        text->insert_gap_end -= free;
d813 1
a813 1
    memcpy(char_pntr, str, str_size);
d815 3
a817 3
    while(char_pntr < end)
        if(*char_pntr++ == '\n')
            new_lines[line_no++] = char_pntr - con;
d819 1
a819 1
    new_lines[line_no++] = text->line_table[text->insert_line];
d821 55
a875 2
    text->insert_delta += str_size;
    text->insert_pos += str_size;
d877 2
a878 1
    *line_delta = line_no - 1;
d880 3
a882 4
    free = text->lne_tbl_sze - text->no_of_lines - *line_delta;
    if(free < 0)
        grow_lines_by(text, -free);
    for(i = text->no_of_lines - 1; i > text->insert_line; i--)
d884 17
a900 2
        text->line_table[i + *line_delta] = text->line_table[i];
        text->xmax_table[i + *line_delta] = text->xmax_table[i];
d902 2
a903 2
    for(i = 0; i < line_no; i++)
        text->line_table[text->insert_line + i] = new_lines[i];
d905 2
a906 1
    *first_line = text->insert_line;
d908 1
a908 1
    text->insert_line += *line_delta;
d913 1
a913 1
    for(i = *first_line; i < (*first_line + line_no); i++)
d926 1
a926 1
      if(text->xmax_line > *first_line)
d929 1
a929 1
          if(text->xmax_line == *first_line)
d941 4
d1006 5
a1010 2
   end = text->line_table[line_no];
   return line_no < text->insert_line ? end : end + text->insert_delta;
d1426 3
a1428 2
#if 0
void dump_object(Text *text)
d1433 13
a1445 13
    printf("\n\nTEXT OBJECT\n-----------\n\n");
    printf("Insert_line   : %d\n", text->insert_line);
    printf("Insert_delta  : %d\n", text->insert_delta);
    printf("Insert_pos    : %d\n", text->insert_pos);
    printf("Insert_gap_end: %d\n", text->insert_gap_end);
    printf("No_of_lines   : %d\n", text->no_of_lines);
    printf("lne_tbl_sze   : %d\n", text->lne_tbl_sze);
    printf("sel_stop_pos  : %d\n", text->sel_stop_pos);
    printf("sel_stop_line : %d\n", text->sel_stop_line);
    printf("xmax          : %d\n", text->xmax);
    printf("xmax_line     : %d\n", text->xmax_line);
    
    printf("\nLine table:\n");
d1448 2
a1449 2
        printf("\tLine: %d\n", i);
        printf("\t\traw: %d start: %d end: %d xmax: %d\n", text->line_table[i],
d1451 1
a1451 1
        printf("\t\t%s", get_line(text, i, line));
d1454 4
a1457 4
    printf("\nMemory block:\n");
    printf("\tbase address: %d\n", (int) text->text_data->base);
    printf("\tsize        : %d\n", text->text_data->size);
    printf("\tfree        : %d\n", text->text_data->free);
a1458 2
#endif

@


1.1.1.1
log
@The Java directory contains the sources for the Java support modules
(TextGadget, etc.) and the makefiles to complete the Java ROM build
under RiscOS.

@
text
@@


1.1.1.2
log
@Implemented tabbing and word-wrapping
@
text
@a32 12
#define TRUE  1
#define FALSE 0

typedef struct {
    int  *new_lines;
    int  line_no;
    int  max_line;
    char *split_pos;
    int  split_xpoint;
    int  x_pos;
} Scan;

a40 1
char		*expand_tabs(char *str, int *len);
a98 4
    text->tab_stop = 72000;
    _swix(Font_ScanString,_INR(0,4)|_OUT(3), text->font_handle, " ", 1<<8,
                              0xfffffff, 0, &text->space);

d221 1
a221 1
static _kernel_oserror *new_line(Scan *scan, int pos, char *start, char *end)
d223 6
a228 5
    scan->new_lines[scan->line_no++] = pos;
    if(scan->line_no == scan->max_line)
        if((scan->new_lines = realloc(scan->new_lines, (scan->max_line +=
                              ((end - start + 1) / 20 + 5)) * sizeof(int))) == NULL)
            return (_kernel_oserror *)"  Out of memory";
d230 2
a231 2
    return NULL;
}
d233 3
a235 73
static _kernel_oserror *scan_text(Text *text, char *start_pntr, char *end, char *con, Scan *scan)
{
        int tab_stop = text->tab_stop;
       	char *char_pntr = start_pntr;
       	int xpoints, xp;
       	int margin = text->margin;
       	
        while(char_pntr <= end)
        {
            if(*char_pntr == ' ' || *char_pntr == '\t' || *char_pntr == '\n')
            {
               int old_line_no = scan->line_no;
               
                _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                                      text->font_handle, start_pntr, 1<<7|1<<8,
                                      0xffffff, 0, char_pntr - start_pntr,
                                      &xpoints);      
                                      
                if((scan->x_pos + xpoints) > margin)
                {
                    if(scan->split_pos != NULL)
                    {
                        new_line(scan, scan->split_pos - con - 1, end, char_pntr);
                        scan->x_pos -= scan->split_xpoint;
                    }

                    while((scan->x_pos + xpoints) > margin)
                    {
                        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(1)|_OUT(3),
                                               text->font_handle, start_pntr, 1<<17|1<<7|1<<8,
                                               margin - scan->x_pos, 0, char_pntr - start_pntr,
                                               &start_pntr, &xp);
                                               
                        new_line(scan, (scan->split_pos = start_pntr) - con - 1, end, char_pntr); 
                        scan->x_pos = 0;
                        xpoints -= xp;
                    }
                }
                
                scan->x_pos += xpoints;
                
                if(*char_pntr == ' ')
                    scan->x_pos += text->space;
                else
                    if(*char_pntr == '\t')
                    {
                        int offset = tab_stop - (scan->x_pos % tab_stop);
                        *++char_pntr = (char) offset;
                        *++char_pntr = (char) (offset >> 8);
                        *++char_pntr = (char) (offset >> 16);
                        scan->x_pos += offset;
                    }
                    else
                        if((old_line_no == scan->line_no) | (scan->split_pos != char_pntr))
                        {
                            new_line(scan, char_pntr - con, end, char_pntr);
                            scan->x_pos = 0;
                        }
            
                if(*char_pntr++ != '\n')
                {
                    scan->split_pos = char_pntr;
                    scan->split_xpoint = scan->x_pos;
                }
                else
                    scan->split_pos = NULL;
                start_pntr = char_pntr;
            }
            else
                char_pntr++;
        }
        
    if(start_pntr <= end)
d237 2
a238 6
        _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(3),
                          text->font_handle, start_pntr, 1<<7|1<<8,
                          0xffffff, 0, end - start_pntr + 1,
                          &xpoints);      
                                      
        if((scan->x_pos + xpoints) > margin)
d240 3
a242 18
            if(scan->split_pos != NULL)
            {
                new_line(scan, scan->split_pos - con - 1, end, start_pntr);
                scan->x_pos -= scan->split_xpoint;
            }

            while((scan->x_pos + xpoints) > margin)
            {
                _swix(Font_ScanString,_INR(0,4)|_IN(7)|_OUT(1)|_OUT(3),
                                       text->font_handle, start_pntr, 1<<17|1<<7|1<<8,
                                       margin - scan->x_pos, 0, end - start_pntr + 1,
                                       &start_pntr, &xp);
                                               
                new_line(scan, start_pntr - con - 1, end, start_pntr); 
                scan->x_pos = 0;
                xpoints -= xp;
            }
            scan->split_pos = NULL;
d244 2
a245 5
        scan->x_pos += xpoints;
    }
   
    return NULL;
}
d247 1
d249 2
a250 19
_kernel_oserror *compose_text(Text *text)
{
    _kernel_oserror *err;
    char *end, *base = text->text_data->base;
    int insert_pos = text->insert_pos;
    Scan scan;
    int i;
    
    if(text->insert_gap_end > insert_pos)
        close_insertion(text);
        
    end = base + text->text_data->size - 1;
    
    scan.max_line = (end - base + 1) / 20 + 5;
    scan.new_lines = malloc((scan.max_line + 1) * sizeof(int));
    scan.line_no = 0;
    
    scan.x_pos = 0;
    scan.split_pos = NULL;
d252 1
a252 23
    scan_text(text, base, end, base, &scan);
            
    if(*end != '\n')  
        scan.new_lines[scan.line_no++] = end - base;
    
    if(scan.line_no > text->lne_tbl_sze)
        if((err = grow_lines_by(text, scan.line_no - text->lne_tbl_sze)) != NULL)
            return err;
       
    for(i = 0; i < scan.line_no; i++)
        text->line_table[i] = scan.new_lines[i];
    
    text->no_of_lines = scan.line_no;
    text->insert_line = text->insert_pos = 0;
        
    text->insert_line = line_index_of_char(text, insert_pos); 
    text->insert_pos = insert_pos;
    
    if(text->sel_stop_pos != -1)
        text->sel_stop_line = line_index_of_char(text, text->sel_stop_pos);
           
    text->xmax_line = text->xmax = 0;
    for(i = 0; i < scan.line_no; i++)
d255 1
d261 2
a262 3
    }        
    free(scan.new_lines);
       
d266 1
a266 27

char *expand_tabs(char *str, int *len)
{
    char *new_str;
    int no_tabs = 0;
    char *pos = str, *pos2;
    
    while(*pos)
       if(*pos++ == '\t')
          no_tabs++;
          
    *len = pos - str;
    if(no_tabs == 0)
        return str;
    
    *len += no_tabs * 3;
    pos2 = new_str = malloc(*len + 1);
    
    for(pos = str; *pos2++ = *pos;)
        if(*pos++ == '\t')
            pos2 += 3;
    
    return new_str;
}


_kernel_oserror *replace_text(Text *text, int from, int ex_to, const char *s,
a269 2
    int             str_size;
    char            *str = expand_tabs((char *)s, &str_size);
d271 1
a273 1
    int             insert_line = text->insert_line;
d275 2
d278 1
d281 2
a282 1
    char            *end, *con;
d284 1
a284 9
    int             gap_size = text->insert_gap_end - insert_pos;
    Scan	    scan;
    char            *old_end;
    int             old_line_no;
    int             old_split = 0;
    char            *start;
    int             ld = 0, ln = 0;
    int             step_back = FALSE;
    
d296 8
a303 1

d306 4
d317 18
a334 2
        
        insert_pos = text->insert_pos += delta;
d336 10
d349 2
d364 2
d374 18
a391 46
        memcpy(base + from + gap_size, str, str_size);
    }
   
    if((first_line > 0) && (*text_to_mem(text, line_end(text, first_line - 1)) != '\n'))
    {
        first_line--;
        step_back = TRUE;
    }
    
    last_line = line_index_of_char(text, to);
    first_line_start = line_start(text, first_line);
    last_line_end = line_end(text, last_line);
        
    scan.max_line = (last_line_end - first_line_start + 1 + delta) / 20 + 5;
    scan.new_lines = malloc((scan.max_line + 1) * sizeof(int));
    scan.line_no = scan.x_pos = 0;
    scan.split_pos = NULL;

    if((first_line <= insert_line) && (last_line >= insert_line))
    {
        end = base + text->insert_pos - 1;
        scan_text(text, start = base + first_line_start, end, base, &scan);
        
        con = base + gap_size + text->insert_delta;
        old_end = end + gap_size;
        if(gap_size > 0) *old_end = '\0';
        ld = scan.line_no - (insert_line - first_line);
        ln = scan.line_no;
        
        if(scan.split_pos != NULL)
        {
            old_split = scan.split_pos - base - 1;
            scan.split_pos = (char *) 1;
        }
  
        end = line_end(text, last_line) + base + gap_size + delta;
        scan_text(text, old_end + 1, end, con, &scan);
    }
    else
    {
        if(last_line < insert_line)
        {
            start = base + first_line_start,
            end = base + last_line_end + delta;
            con = base;
        }
d393 2
a394 54
        {
            start = base + first_line_start + gap_size;
            end = base + last_line_end + delta + gap_size;
            con = base + gap_size + text->insert_delta;
        }
        scan_text(text, start, end, con, &scan);
    }
    if((++last_line < text->no_of_lines) && ((*end != '\n') || (start >  end)))
    {
        old_line_no = scan.line_no;
        do {
           old_end = end;

           if(last_line == text->insert_line)
           {
               end = base + text->insert_pos - 1;
               scan_text(text, old_end + 1, end, con, &scan);
               
               con = base + gap_size + text->insert_delta;
               ld = scan.line_no -  (last_line - first_line);
               ln = scan.line_no;
    
               if(scan.split_pos != NULL)
               {
                   old_split = scan.split_pos - base - 1;
                   scan.split_pos = (char *) 1;
               }
               
               old_end = end + gap_size;
               if(gap_size > 0) *old_end = '\0';
           }
           end = line_end(text, last_line) + base + delta;
           if(last_line++ >= text->insert_line) end += gap_size;
           scan_text(text, old_end + 1, end, con, &scan);
           
        } while((*end != '\n') && (last_line < text->no_of_lines) &&
               ((scan.line_no == old_line_no) ||
               ((scan.new_lines[scan.line_no - 1] + con) > old_end)));
    }
    last_line --;
  
    if((ln < scan.line_no) && (scan.new_lines[ln] == - (int) con))
    {
        scan.new_lines[ln] = old_split;
        ld++;
    }
       
    if(*end != '\n')  
        scan.new_lines[scan.line_no++] = end - con;
   
    line_delta = scan.line_no - (last_line - first_line + 1);
    *first_line_p = first_line;
    *last_line_p = last_line;
    *line_delta_p = line_delta;
a395 15
    if(step_back && (scan.new_lines[0] == text->line_table[first_line]) &&
       ((first_line != insert_line) || ld == 0))
          (*first_line_p)++;
    
    if(last_line < insert_line)
    {
        for(i = last_line + 1; i < text->insert_line; i++)
            text->line_table[i] += delta;
        text->insert_delta += delta;
        text->insert_line += line_delta; 
    }
    else
    {
        if(first_line < insert_line)
            text->insert_line += ld; 
d398 3
a401 1
    
d420 2
a421 2
    for(i = 0; i < scan.line_no; i++)
        text->line_table[first_line + i] = scan.new_lines[i];
d423 1
a423 1
    free(scan.new_lines);
d427 4
a430 1
        
d433 1
a433 1
    for(i = first_line; i < (first_line + scan.line_no); i++)
a460 5
    
    if(s != str)
        free(str);
        
    
d464 3
a466 2
_kernel_oserror *insert_text(Text *text, char *s,
                      int *first_line_p, int *last_line_p, int *line_delta)
d469 7
a475 7
    int left = text->insert_gap_end - text->insert_pos;
    int str_size;
    char *str = expand_tabs((char *) s, &str_size);
    char *start;
    char *end;
    char *con;
    char *char_pntr;
d477 1
d479 2
a480 15
    char *base = text->text_data->base;
    int gap_size;
    int ld, ln;
    int first_line = text->insert_line;
    int last_line = first_line;
    char *old_end; 
    Scan scan;
    int old_split = 0;
    int old_line_no;
    
    scan.new_lines = malloc(10 * sizeof(int));
    scan.max_line = 9;
    scan.line_no = 0;
    
    if(left < str_size)
d482 2
a483 2
        left -= str_size + INSERTION_GAP;
        if((err = extend_block(text->text_data, text->insert_pos, -left))
d487 1
a487 1
        text->insert_gap_end -= left;
d489 9
a497 3
    
    memcpy(end = base + text->insert_pos, str, str_size);
    
d500 7
a506 65
    gap_size = text->insert_gap_end - text->insert_pos;
    
    start = base + line_start(text, first_line);
               
    scan.x_pos = 0;
    scan.split_pos = NULL;
    
    if((last_line > 0) && (*(start - 1) != '\n'))
    {
        for(char_pntr = start;
            (*char_pntr != ' ') && (*char_pntr != '\t') && (char_pntr < end);
            char_pntr++);
        
        if(char_pntr == end)
            start = base + line_start(text, --first_line);
    }
    
    end = base + text->insert_pos - 1;    
    scan_text(text, start, end, base, &scan);
    
    con = base + gap_size + text->insert_delta;
    old_end = end + gap_size;
    if(gap_size > 0) *old_end = '\0';
    ld = scan.line_no -  (last_line - first_line);
    ln = scan.line_no;
    
    if(scan.split_pos != NULL)
    {
        old_split = scan.split_pos - base - 1;
        scan.split_pos = (char *) 1;
    }
          
    end = line_end(text, last_line++) + base + gap_size;
    scan_text(text, old_end + 1, end, con, &scan);
    old_line_no = scan.line_no;
    
    if((*end != '\n') && (last_line < text->no_of_lines))
    {
        do {
           old_end = end;
           end = line_end(text, last_line++) + base + gap_size;

           scan_text(text, old_end + 1, end, con, &scan);
           
        } while((*end != '\n') && (last_line < text->no_of_lines) &&
               ((scan.line_no == old_line_no) ||
               ((scan.new_lines[scan.line_no - 1] + con) > old_end)));
    }
        
    if((ln < scan.line_no) && (scan.new_lines[ln] == - (int) con))
    {
        scan.new_lines[ln] = old_split;
        ld++;
    }
    
    if(*end != '\n')  
        scan.new_lines[scan.line_no++] =  end - con;
    
    *line_delta = scan.line_no - (last_line - first_line);
    *last_line_p = last_line - 1;
    
    left = text->lne_tbl_sze - text->no_of_lines - *line_delta;
    if(left < 0)
        grow_lines_by(text, -left);
    for(i = text->no_of_lines - 1; i >= last_line; i--)
d511 2
a512 2
    for(i = 0; i < scan.line_no; i++)
        text->line_table[first_line + i] = scan.new_lines[i];
d514 1
a514 2
    free(scan.new_lines);
    *first_line_p = first_line;    
d516 1
a516 1
    text->insert_line += ld;
d521 1
a521 1
    for(i = first_line; i < (first_line + scan.line_no); i++)
d534 1
a534 1
      if(text->xmax_line > first_line)
d537 1
a537 1
          if(text->xmax_line == first_line)
a548 5
    
    if(s != str)
        free(str);
        
        
d610 2
a611 5
    if(line_no >= text->no_of_lines)
       line_no = text->no_of_lines - 1;
       
    end = text->line_table[line_no];
    return line_no < text->insert_line ? end : end + text->insert_delta;
d1027 2
a1028 3


void dump_object(FILE *out, Text *text)
d1033 11
a1043 11
    fprintf(out, "\n\nTEXT OBJECT\n-----------\n\n");
    fprintf(out, "Insert_line   : %d\n", text->insert_line);
    fprintf(out, "Insert_delta  : %d\n", text->insert_delta);
    fprintf(out, "Insert_pos    : %d\n", text->insert_pos);
    fprintf(out, "Insert_gap_end: %d\n", text->insert_gap_end);
    fprintf(out, "No_of_lines   : %d\n", text->no_of_lines);
    fprintf(out, "lne_tbl_sze   : %d\n", text->lne_tbl_sze);
    fprintf(out, "sel_stop_pos  : %d\n", text->sel_stop_pos);
    fprintf(out, "sel_stop_line : %d\n", text->sel_stop_line);
    fprintf(out, "xmax          : %d\n", text->xmax);
    fprintf(out, "xmax_line     : %d\n", text->xmax_line);
d1045 1
a1045 1
    fprintf(out, "\nLine table:\n");
d1048 2
a1049 2
        fprintf(out, "\tLine: %d\n", i);
        fprintf(out, "\t\traw: %d start: %d end: %d xmax: %d\n", text->line_table[i],
d1051 1
a1051 1
        fprintf(out, "\t\t%s", get_line(text, i, line));
d1054 4
a1057 4
    fprintf(out, "\nMemory block:\n");
    fprintf(out, "\tbase address: %d\n", (int) text->text_data->base);
    fprintf(out, "\tsize        : %d\n", text->text_data->size);
    fprintf(out, "\tfree        : %d\n", text->text_data->free);
d1059 2
@


1.1.1.3
log
@Fixed a couple of data aborts, made all gadgets not quit if tasks are
still using them and freed all memory when they do quit.
@
text
@a26 1
#include <assert.h>
d63 1
a63 1
    if((err = create_block(size + 1, &handle)) != NULL)
d72 3
a74 5
    *(handle->base) = '\0';
    
    text->insert_line    = 0;
    text->insert_delta   = 0;
    text->insert_pos     = 0;
d76 8
a83 8
    text->no_of_lines    = 1;
    text->lne_tbl_sze    = 0;
    text->line_table     = NULL;
    text->xmax_table     = NULL;
    text->sel_stop_pos   = -1;
    text->sel_stop_line  = 0;
    text->xmax           = 0;
    text->xmax_line      = 0;
a94 1
    text->xmax_table[0] = 0;
d96 2
d99 1
a99 2

    return set_font(text, font_handle);
d103 1
a103 1
_kernel_oserror *set_font(Text *text, int font_handle)
d117 1
a117 3
        return compose_text(text);
        
    return NULL;
d121 6
a126 7
void delete_text(Text *text)
{
    delete_block(text->text_data);
    free(text->line_table);
    free(text->xmax_table);
    free(text);
}
a172 2
    *(text->text_data->base + pos) = '\0';
    
d192 1
d238 1
a238 1
static _kernel_oserror *new_line(Scan *scan, int pos, char *end, char *start)
d242 3
a244 2
    {
        int extra = (end - start + 1) / 20 + 5;
a245 5
        if((scan->new_lines = realloc(scan->new_lines,
                       (scan->max_line += extra) * sizeof(int))) == NULL)
            return (_kernel_oserror *)"    Out of memory";
    }
    
d251 4
a254 5
        _kernel_oserror *e;
        int             tab_stop = text->tab_stop;
       	char            *char_pntr = start_pntr;
       	int             xpoints, xp;
       	int             margin = text->margin;
d271 1
a271 2
                        if((e = new_line(scan, scan->split_pos - con - 1, end, char_pntr)) != NULL)
                            return e;
d282 1
a282 3
                        if((e = new_line(scan, (scan->split_pos = start_pntr) - con - 1, end,
                                            char_pntr)) != NULL)
                            return e; 
d304 1
a304 2
                            if((e = new_line(scan, char_pntr - con, end, char_pntr)) != NULL)
                                return e;
d332 1
a332 2
                if((e = new_line(scan, scan->split_pos - con - 1, end, start_pntr)) != NULL)
                    return e;
d343 1
a343 2
                if((e = new_line(scan, start_pntr - con - 1, end, start_pntr)) != NULL)
                    return e; 
d355 1
d359 4
a362 4
    char            *end, *base = text->text_data->base;
    int             insert_pos = text->insert_pos;
    Scan            scan;
    int             i;
d366 3
a368 3

    end = base + text->text_data->size - 2;
            
d376 1
a376 2
    if((err = scan_text(text, base, end, base, &scan)) != NULL)
        return err;
d378 1
a378 1
    if((end < base) || (*end != '\n'))  
d408 1
a408 1
      
d430 1
a430 1
    for(pos = str; (*pos2++ = *pos) != NULL;)
d451 1
a461 1
    int             i;
d532 1
a532 2
        if((err = scan_text(text, start = base + first_line_start, end, base, &scan)) != NULL)
            return err;
d547 1
a547 2
        if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
           return err;
d563 1
a563 2
        if((err = scan_text(text, start, end, con, &scan)) != NULL)
            return err;
d574 1
a574 2
               if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
                   return err;
d591 1
a591 2
           if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
               return err;
d657 1
d691 2
a692 1
                
d700 18
a717 14
    int             left = text->insert_gap_end - text->insert_pos;
    int             str_size;
    char            *str = expand_tabs((char *) s, &str_size);
    char            *start, *end, *con, *char_pntr;
    int             i, old_xmax;
    char            *base = text->text_data->base;
    int             gap_size;
    int             ld, ln;
    int             first_line = text->insert_line;
    int             last_line = first_line;
    char            *old_end; 
    Scan            scan;
    int             old_split = 0;
    int             old_line_no;
d722 2
a723 2

    if(left <= str_size)
a738 2
    *(base + text->insert_pos) = '\0';
    
d755 1
a755 2
    if((err = scan_text(text, start, end, base, &scan)) != NULL)
        return err;
d770 2
a771 2
    if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
        return err;
d779 1
a779 3
           old_line_no = scan.line_no;
           if((err = scan_text(text, old_end + 1, end, con, &scan)) != NULL)
               return err;
d798 4
a801 7
    if(*line_delta < 0)
        for(i = last_line; i < text->no_of_lines; i++)
        {
            text->line_table[i + *line_delta] = text->line_table[i];
            text->xmax_table[i + *line_delta] = text->xmax_table[i];
        }
    else
d803 2
a804 8
        int free = text->lne_tbl_sze - text->no_of_lines - *line_delta;
        if((free < 0) && ((err = grow_lines_by(text, -free)) != NULL))
            return err;
        for(i = text->no_of_lines - 1; i >= last_line; i--)
        {
            text->line_table[i + *line_delta] = text->line_table[i];
            text->xmax_table[i + *line_delta] = text->xmax_table[i];
        }
d806 1
a806 2
    
     for(i = 0; i < scan.line_no; i++)
d808 2
a809 2
        
   free(scan.new_lines);
d820 1
a820 1
        
d848 1
@


1.1.1.3.2.1
log
@Manually merge in v0.06 bugfixes from Spinner branch, add CLR
functionality and tilde support, reinstate region select, and explicitly
disallow Ctrl-I (tab support is not functional in TextGadget anyway).
@
text
@d20 1
a20 1
 * rlougher 18/12/96 Added code to keep track of max x-extent during editing
d74 1
a74 1

d121 1
a121 1

d180 1
a180 1

d256 1
a256 1

d267 1
a267 1

d273 1
a273 1

d277 2
a278 2
                                      &xpoints);

d294 1
a294 1

d297 1
a297 1
                            return e;
d302 1
a302 1

d304 1
a304 1

d323 1
a323 1

d336 1
a336 1

d342 2
a343 2
                          &xpoints);

d359 1
a359 1

d361 1
a361 1
                    return e;
d369 1
a369 1

d380 1
a380 1

d385 1
a385 1

d389 1
a389 1

d395 2
a396 2

    if((end < base) || (*end != '\n'))
d398 1
a398 1

d402 1
a402 1

d405 1
a405 1

d408 2
a409 2

    text->insert_line = line_index_of_char(text, insert_pos);
d411 1
a411 1

d414 1
a414 1

d424 1
a424 1
    }
d426 1
a426 1

d436 1
a436 1

d440 1
a440 1

d444 1
a444 1

d447 1
a447 1

d451 1
a451 1

d480 1
a480 1

d485 1
a485 1
        from = line_end(text, text->no_of_lines - 1) + 1;
d488 1
a488 1

d490 1
a490 1

d502 1
a502 1

d512 1
a512 1
            text->insert_line = insert_line = first_line;
d531 1
a531 1

d537 1
a537 1

d541 1
a541 1

d552 1
a552 1

d558 1
a558 1

d564 2
a565 2

        end = last_line_end + base + gap_size + delta;
a585 1

d597 1
a597 1

d601 1
a601 1

d607 1
a607 1

d615 1
a615 1

d621 1
a621 1

d627 2
a628 2

    if((start > end) || (*end != '\n'))
d630 1
a630 1

d639 1
a639 1

d645 1
a645 1
        text->insert_line += line_delta;
d650 1
a650 1
            text->insert_line += ld;
d654 8
a661 2

    if(line_delta != 0)
d663 4
a666 7
        if(line_delta < 0)
            for(i = last_line + 1; i < text->no_of_lines; i++)
            {
                text->line_table[i + line_delta] = text->line_table[i];
                text->xmax_table[i + line_delta] = text->xmax_table[i];
            }
        else
d668 2
a669 8
            int free = text->lne_tbl_sze - text->no_of_lines - line_delta;
            if((free < 0) && ((err = grow_lines_by(text, -free)) != NULL))
                return err;
            for(i = text->no_of_lines - 1; i > last_line; i--)
            {
                text->line_table[i + line_delta] = text->line_table[i];
                text->xmax_table[i + line_delta] = text->xmax_table[i];
            }
d677 1
a677 1

d710 1
a710 1

d713 1
a713 1

a716 1

d731 1
a731 1
    char            *old_end;
d735 1
a735 1

d749 1
a749 1

d751 1
a751 1

d755 1
a755 1

d757 1
a757 1

d759 1
a759 1

d762 1
a762 1

d768 1
a768 1

d772 2
a773 2

    end = base + text->insert_pos - 1;
d776 1
a776 1

d782 1
a782 1

d788 1
a788 1

d792 1
a792 1

d802 1
a802 1

d807 1
a807 1

d813 2
a814 2

    if(*end != '\n')
d816 1
a816 1

d819 8
a826 2

    if(*line_delta != 0)
d828 4
a831 7
        if(*line_delta < 0)
            for(i = last_line; i < text->no_of_lines; i++)
            {
                text->line_table[i + *line_delta] = text->line_table[i];
                text->xmax_table[i + *line_delta] = text->xmax_table[i];
            }
        else
d833 2
a834 8
            int free = text->lne_tbl_sze - text->no_of_lines - *line_delta;
            if((free < 0) && ((err = grow_lines_by(text, -free)) != NULL))
                return err;
            for(i = text->no_of_lines - 1; i >= last_line; i--)
            {
                text->line_table[i + *line_delta] = text->line_table[i];
                text->xmax_table[i + *line_delta] = text->xmax_table[i];
            }
d837 1
a837 1

d840 1
a840 1

d842 1
a842 1
    *first_line_p = first_line;
d852 1
a852 1

d877 1
a877 1

d880 1
a880 1

d944 1
a944 1

d1380 1
a1380 1

@


1.1.1.3.2.2
log
@  Improved textarea's handling of low memory conditions.  Should now act in
a slightly better way when it uses up all available memory.
@
text
@a387 3
    if (scan.new_lines == NULL)
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";

a447 3
    if (new_str == NULL)
      return new_str;

a480 4
    /* If expand_tabs failed */
    if (str == NULL)
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";

a543 21
    if (scan.new_lines == NULL)
    {
      if((to < insert_pos) && (from != insert_pos))
      {
        if (delta > 0)
          shrink_block(text->text_data, from, -delta);
      }
      else
      {
        if(from <= insert_pos)
        {
          shrink_block(text->text_data, from + gap_size, str_size);
        }
        else
        {
          if (delta > 0)
            shrink_block(text->text_data, from + gap_size, -delta);
        }
      }
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";
    }
a740 3
    if (str == NULL)
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";

a741 3
    if (scan.new_lines == NULL)
      return (_kernel_oserror*)"    JBERANEK> Out of memory.";

@


1.1.1.3.2.3
log
@Added comments to the bits that I fixed in c/TextArea and c/TextMan in
preparation for eventual merging to the trunk.
@
text
@a387 2

    /* If the malloc fails ... */
a388 2
    {
      /* ... return an error message */
a389 1
    }
a488 2
    {
      /* return an error message */
a489 1
    }
a553 2

    /* If the malloc fails ... */
a555 1
      /* ... attempt to clean up, this is largely intelligent guesswork */
a572 2

      /* and return an error */
a574 1

a771 1
    /* If expand_tabs failed */
a772 2
    {
      /* return an error message */
a773 1
    }
a775 2

    /* If the malloc fails */
a776 2
    {
      /* return an error message */
a777 1
    }
@


1.1.1.4
log
@Fixed bug in re-composing text after set_font...
@
text
@d480 1
a480 1
       
d512 1
a512 1
            text->insert_line = insert_line = first_line;
d565 1
a565 1
        end = last_line_end + base + gap_size + delta;
a585 1

d628 1
a628 1
    if((start > end) || (*end != '\n'))  
d654 13
a666 10

    if(line_delta != 0)
    {    
        if(line_delta < 0)
            for(i = last_line + 1; i < text->no_of_lines; i++)
            {
                text->line_table[i + line_delta] = text->line_table[i];
                text->xmax_table[i + line_delta] = text->xmax_table[i];
            }
        else
d668 2
a669 8
            int free = text->lne_tbl_sze - text->no_of_lines - line_delta;
            if((free < 0) && ((err = grow_lines_by(text, -free)) != NULL))
                return err;
            for(i = text->no_of_lines - 1; i > last_line; i--)
            {
                text->line_table[i + line_delta] = text->line_table[i];
                text->xmax_table[i + line_delta] = text->xmax_table[i];
            }
d713 1
a713 1
             
a716 1

d735 1
a735 1

d820 7
a826 1
    if(*line_delta != 0)
d828 4
a831 7
        if(*line_delta < 0)
            for(i = last_line; i < text->no_of_lines; i++)
            {
                text->line_table[i + *line_delta] = text->line_table[i];
                text->xmax_table[i + *line_delta] = text->xmax_table[i];
            }
        else
d833 2
a834 8
            int free = text->lne_tbl_sze - text->no_of_lines - *line_delta;
            if((free < 0) && ((err = grow_lines_by(text, -free)) != NULL))
                return err;
            for(i = text->no_of_lines - 1; i >= last_line; i--)
            {
                text->line_table[i + *line_delta] = text->line_table[i];
                text->xmax_table[i + *line_delta] = text->xmax_table[i];
            }
d838 1
a838 1
    for(i = 0; i < scan.line_no; i++)
d880 1
a880 1
                
@


1.1.1.5
log
@Changed _insert_text to call set_caret, forcing window to scroll.  Also
uses  more efficient insert_text.  Changes to set_caret to allow
invisibility.
@
text
@d650 1
a650 1
        if(first_line <= insert_line)
@

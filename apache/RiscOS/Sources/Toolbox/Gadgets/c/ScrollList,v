head	1.16;
access;
symbols
	Gadgets-0_44:1.16
	Gadgets-0_43:1.15
	Gadgets-0_42:1.15
	Gadgets-0_41:1.15
	Gadgets-0_40:1.14
	Gadgets-0_39:1.13
	Gadgets-0_38:1.12
	Gadgets-0_37:1.12
	Gadgets-0_36:1.11
	Gadgets-0_35:1.10
	Gadgets-0_34:1.9
	Gadgets-0_33:1.8
	Gadgets-0_32:1.8
	Gadgets-0_31:1.7
	Gadgets-0_30:1.6
	Gadgets-0_29:1.6
	Gadgets-0_28:1.6
	RO_5_07:1.6
	Gadgets-0_27:1.6
	Gadgets-0_26:1.6
	Gadgets-0_25:1.6
	Gadgets-0_24:1.5
	Gadgets-0_23:1.5
	Gadgets-0_22:1.5
	Gadgets-0_21:1.5
	Gadgets-0_20:1.5
	Gadgets-0_19:1.5
	Gadgets-0_18:1.5
	Gadgets-0_17:1.5
	Gadgets-0_16:1.4
	Gadgets-0_15:1.3
	sforrest_daytona_appflash-0_31:1.1.1.4.2.1
	Gadgets-0_14:1.2
	mjrobert_Java_26_08_98:1.1.1.6
	blaughto_daytona_appflash-0_30:1.1.1.4.2.1
	blaughto_daytona_appflash-0_29:1.1.1.4.2.1
	blaughto_daytona_appflash-0_28:1.1.1.4.2.1
	Gadgets-0_11:1.2
	sbrodie_TextGadgets_merged_19Jun98:1.2
	sbrodie_Daytona_merge_19Jun98:1.1.1.4.2.1
	sbrodie_Spin_merge_18Jun98:1.1.1.6
	jberanek_gadgets-0_08:1.1.1.4.2.1
	Gadgets-0_10-1_1_2_2:1.1.1.6
	blaughto_daytona_appflash-0_27:1.1.1.4.2.1
	blaughto_daytona_appflash-0_26:1.1.1.4.2.1
	blaughto_daytona_appflash-0_25:1.1.1.4.2.1
	blaughto_daytona_appflash-0_24:1.1.1.4.2.1
	blaughto_daytona_appflash-0_23:1.1.1.4.2.1
	blaughto_daytona_appflash-0_21:1.1.1.4.2.1
	blaughto_daytona_appflash-0_20:1.1.1.4.2.1
	blaughto_daytona_appflash-0_19:1.1.1.4.2.1
	jberanek_gadgets-0_07:1.1.1.4.2.1
	blaughto_daytona_appflash-0_18:1.1.1.4.2.1
	mrison_gadgets-0_06:1.1.1.4.2.1
	pwombwel_0_09:1.1.1.5
	mrison_gadgets-0_05:1.1.1.4.2.1
	Daytona:1.1.1.4.0.2
	Daytona_bp:1.1.1.4
	Spinner_RCA116:1.1.1.3
	Spinner_B20_2:1.1.1.2
	Spinner_19_3:1.1.1.2
	Spinner_B18:1.1.1.2
	Spinner_B17:1.1.1.2
	Spinner_B15:1.1.1.2
	Spinner_B14:1.1.1.2
	Spinner_B13:1.1.1.1
	Spinner_B12:1.1.1.1
	Spinner_B10:1.1.1.1
	Initial:1.1.1.1
	Spinner:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2018.02.09.09.00.19;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	hvuSc2WpQ5n6caqA;

1.15
date	2016.03.25.23.35.52;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	J2IhnS5wMSjA550z;

1.14
date	2015.11.28.19.08.32;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	Hv9ItC5GsjO1pTKy;

1.13
date	2015.10.12.21.17.41;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	KKgpfp0vznFZCREy;

1.12
date	2013.08.30.21.32.36;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	Ah6FHegdauBDyw3x;

1.11
date	2013.08.30.19.34.37;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	cFJZhP2Bmu3bUv3x;

1.10
date	2013.03.16.22.46.54;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	28v2kuHlRYNTk4Iw;

1.9
date	2012.01.14.17.17.59;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	I6w6cgQsKF85faPv;

1.8
date	2011.06.25.22.38.48;	author jlee;	state Exp;
branches;
next	1.7;
commitid	SJmoual8pfcHx6pv;

1.7
date	2010.02.28.10.40.26;	author rsprowson;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.16.17.37.56;	author blaughto;	state Exp;
branches;
next	1.5;

1.5
date	99.03.31.07.26.45;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	99.03.30.15.11.42;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	99.03.26.12.25.10;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	98.06.19.12.47.48;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	97.05.13.16.25.53;	author rlougher;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.13.16.25.53;	author rlougher;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.06.18.15.06.50;	author rlougher;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.07.03.18.18.30;	author pwombwel;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.12.16.12.54.51;	author rlougher;	state Exp;
branches
	1.1.1.4.2.1;
next	1.1.1.5;

1.1.1.5
date	98.01.19.19.20.50;	author pwombwel;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	98.06.18.15.32.27;	author sbrodie;	state Exp;
branches;
next	;

1.1.1.4.2.1
date	97.12.16.17.19.45;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.16
log
@SetColour method flag fixes
Fix checking of the DesktopColours flag to the scrolllist and textarea gadget SetColour methods - didn't match docs.
Fix for expression precedence of + and ? operators by sprinkling in some brackets.
Ref https://www.riscosopen.org/forum/forums/4/topics/9503#posts-72595

Also, optimise the forced redraw if the text area colour overall didn't change (reduces flicker).
Docs corrected to list RISC OS palette words in the right order.

Version 0.44. Tagged as 'Gadgets-0_44'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Title:   ScrollList.c
 * Purpose: Scrolling list gadget for textgadgets module
 *
 * Revision History
 * piers    01/08/1996 Created
 * piers    23/12/1996 Added in MemCheck thingies
 * piers    06/01/1997 Recoded to use a nested window so scrollbar is nicer
 * SNB      18/06/1998 (Stewart Brodie) See comments within code.
 * ADH      24/03/1999 These history entries now use a four digit year
 *                     field. Added SNB entry above. Title BG colour in
 *                     window_template now 2. SELECT click on an unselected
 *                     item deselects all others in the gadget first. Works
 *                     out vertical scroll bar and window frame size to
 *                     ensure it correctly fits gadget wimp_Bbox. Can ask the
 *                     select/deselect/delete routines to send a Selection
 *                     event just before exitting now. Can also ask the
 *                     select/deselect routines to operate on all items
 *                     rather than just one (Select All, Clear Selection).
 * ADH      30/03/1999 Added scrolllist_set_item_text. Tweak to extent
 *                     setting to account for window border. _add_item fix
 *                     ('>' should've read '>=' in index range check). Can
 *                     now tell _add_item to make the new item visible
 *                     (flag ScrollList_AddItem_MakeVisible), else it will
 *                     try to maintain the y scroll position. _delete_items
 *                     continues to jump to the top as before, but you can
 *                     ask it to try and maintain the y scroll position too
 *                     (flag ScrollList_DeleteItems_DoNotJumpToTop).
 * ADH      31/03/1999 Ooops, empty lists always shrunk themselves to zero
 *                     height - fixed.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "macros.h"
#include "messages.h"
#include "twimp.h"
#include "objects/gadgets.h"
#include "Global/Sprite.h"

#include "glib.h"
#include "riscos_uti.h"
#include "Font.h"
#include "TextGadget.h"
#include "ScrollLisP.h"
#include "Sizes.h"
#include "Utils.h"

#ifdef MemCheck_MEMCHECK
#include "MemCheck:MemCheck.h"
#endif

static int my_icons[2] = {0, -1};

static unsigned int vscroll_width = SIZES_TOOL_DEFAULT;

static PrivateScrollList **scrolllist_list = NULL;

static const wimp_Bbox redraw_all_box = {0, -0xffff, 0xffff, 0};

static _kernel_oserror *_make_visible(const PrivateScrollList *sdata,
			int visible);
static _kernel_oserror *_scrolllist_redraw(const PrivateScrollList *sdata,
			WindowRedraw *block, wimp_Bbox *box,
			unsigned int sprite_width,
			unsigned int item_height, int base_line);

static const WindowTemplate window_template =
{
    1<<1 | 1<<2, 		// flags
    NULL,	// help_message
    0, 		// max_help
    NULL,	// pointer_shape
    0,		// max_pointer_shape
    0,		// pointer_x_hot
    0,		// pointer_y_hot
    NULL,	// no menu
    0,		// num_keyboard_shortcuts
    NULL,	// keyboard_shortcuts
    0,		// num_gadgets
    NULL,	// gadgets
    -1,		// default_focus
    0,		// show_event
    0,		// hide_event
    NULL,	// toolbar_ibl
    NULL,	// toolbar_itl
    NULL,	// toolbar_ebl
    NULL,	// toolbar_etl
    {
        // WimpWindow struct
        {0, -100, 0, 0},	// visible_area
        0,			// xscroll
        0,			// yscroll
        -1,			// behind
        (int)wimp_WINDOWFLAGS_USE_NEW_FLAGS | wimp_WINDOWFLAGS_HAS_VSCROLLBAR,
        			// flags
        7,			// title_fg
        2,			// title_bg
        7,			// work_fg
        0xff,			// work_bg
        3,			// scroll_outer
        1,			// scroll_inner
        12,			// highlight_by
        0,			// reserved
        {0, -40960, 12800, 0},	// extent
        0,			// title_flags
        10 * wimp_ICONFLAGS_BUTTON_TYPE,// work_flags
        NULL,			// sprite_area
        0x00010001,		// min_width/min_height
        {
            // WimpIconData
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        },
        0			// nicons
    }
};

static /* const */ ObjectTemplateHeader scroll_list_window =
{
    Window_ObjectClass,		// object_class
    0,				// flags
    102,			// version
    "__list",			// name
    sizeof(ObjectTemplateHeader) + sizeof(WindowTemplate),	// total_size
    NULL,			// body - due to a bug in the compiler, we
    				// have to set this at run-time
    sizeof(WindowTemplate)	// body_size
};

_kernel_oserror *scrolllist_init(void)
{
    scroll_list_window.body = (void*) &window_template;

    return NULL;
}

static _kernel_oserror *add_redraw_handler(PrivateScrollList *sl)
{
    if (scrolllist_list == NULL)
    {
        if ( (scrolllist_list = malloc(sizeof(PrivateScrollList*)*2)) == NULL)
            return make_error(TextGadgets_ListAllocFailed, 0);

        scrolllist_list[0] = sl;
        scrolllist_list[1] = NULL;
    }
    else
    {
        PrivateScrollList **new_list;
        unsigned int i;

        for (i = 0; scrolllist_list[i] != NULL; i++)
            ;

        new_list = realloc(scrolllist_list,
        			sizeof(PrivateScrollList*) * (i+2));

        if (new_list == NULL)
            return make_error(TextGadgets_ListAllocFailed, 0);

        scrolllist_list = new_list;

        scrolllist_list[i] = sl;
        scrolllist_list[i + 1] = NULL;
    }

    return NULL;
}

static _kernel_oserror *remove_redraw_handler(PrivateScrollList *sl)
{
    unsigned int i, j;

    if (scrolllist_list == NULL)
        return make_error(TextGadgets_UKScrollList, 0);

    for (i = 0;
        (scrolllist_list[i] != NULL) && (scrolllist_list[i] != sl);
        i++)
        ;

    if (scrolllist_list[i] == NULL)
        return make_error(TextGadgets_UKScrollList, 0);

    for (j = i; scrolllist_list[j] != NULL; j++)
        ;

    // j points to last entry

    if (j <= 1)
    {
        free(scrolllist_list);
        scrolllist_list = NULL;
    }
    else
    {
        PrivateScrollList **new_list;

        for (; i < j; i++)
            scrolllist_list[i] = scrolllist_list[i + 1];

        // No need to generate an error if the realloc fails, 'cos
        // it'll just realloc next time, hopefully
        new_list = realloc(scrolllist_list,
        			sizeof(PrivateScrollList) * (j+1));

        if (new_list != NULL)
            scrolllist_list = new_list;
    }

    return NULL;
}

/* ------------------------------------------------------------------------
 */
static unsigned int _get_height_of_entry(const PrivateScrollList *sdata,
		int *base_line)
{
    unsigned int font_handle;
    int min, max;

    font_handle = sdata->font_handle;
    if (!font_handle)
    {
        _kernel_oserror *e;

        e = _swix(Wimp_ReadSysInfo, _IN(0)|_OUT(0), 8, &font_handle);
        if (e)
            return 0;
    }

    if (!font_handle) {
        // bug fix.  SNB - 19980618: Must zero base_line otherwise when desktop font
        // is the system font, all the text disappears because base_line remains
        // uninitialised.
        if (base_line)
            *base_line = 0;
        return 32;
    }

    _swix(Font_ReadInfo, _IN(0)|_OUT(2)|_OUT(4),
    		font_handle, &min, &max);
    if (base_line)
        *base_line = min;

    return abs(min) + abs(max);
}

static void _get_size_of_sprites(const PrivateScrollList *sdata,
		unsigned int *max_sprite_width, unsigned int *max_sprite_height)
{
    unsigned int i;

    if (max_sprite_width != NULL)
        *max_sprite_width = 0;
    if (max_sprite_height != NULL)
        *max_sprite_height = 0;

    for (i = 0; i < sdata->no_entries; i++)
    {
        unsigned int sprite_info = sdata->entries[i].flags &
        			(FLAGS_SPRITE_AREA | FLAGS_SPRITE_NAME);

        if (sdata->entries[i].sprite_name)
        {
            unsigned int sprite_width = 0, sprite_height = 0;

            if (sprite_info == 3)
                continue;

            if (sprite_info == 0)
            {
                // Sprite in wimp poll
                _swix(Wimp_SpriteOp, _IN(0)|_IN(2)|_OUTR(3,4),
                	SpriteReason_ReadSpriteSize,
                	sdata->entries[i].sprite_name,
                	&sprite_width, &sprite_height);
            }
            else
            {
                // Sprite in sprite area
                _swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,4),
                	(sprite_info == 1) ? (SpriteReason_ReadSpriteSize + 256)
                	                   : (SpriteReason_ReadSpriteSize + 512),
                	sdata->entries[i].sprite_area,
                	sdata->entries[i].sprite_name,
                	&sprite_width, &sprite_height);
            }

            if (!(sdata->entries[i].flags & FLAGS_HALF_SIZE))
            {
                sprite_width *= 2;
                sprite_height *= 2;
            }

            if (max_sprite_width && (sprite_width > *max_sprite_width))
                *max_sprite_width = sprite_width;
            if (max_sprite_height && (sprite_height > *max_sprite_height))
                *max_sprite_height = sprite_height;
        }
    }
}

static void _get_item_size(const PrivateScrollList *sdata,
	unsigned int *width, unsigned int *height, int *base_line)
{
    unsigned int	item_height, font_height, item_width;
    int			base;

    _get_size_of_sprites(sdata, &item_height, &item_width);

    if (height)
    {
        font_height = _get_height_of_entry(sdata, &base);
        *height = MAX(font_height, item_height) + 4;
    }

    if (width)
        *width = item_width + 4;

    if (base_line)
        *base_line = base;
}

static void _set_extent(const PrivateScrollList *sdata)
{
    wimp_Bbox		newbox;
    int			limit;
    unsigned int	entry_height;

    _get_item_size(sdata, NULL, &entry_height, NULL);

    newbox.xmin = 0;
    newbox.xmax = 0xfff;
    newbox.ymin = -sdata->no_entries * entry_height;
    newbox.ymax = 0;

    limit = sdata->box.ymin - sdata->box.ymax + sizes_y_scale() * 2;
    if (newbox.ymin > limit) newbox.ymin = limit;

    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, sdata->object_id, Window_SetExtent, &newbox);
}

static _kernel_oserror *_show(PrivateScrollList *sdata)
{
    WindowShowObjectBlock show_block;
    unsigned int          dx = sizes_x_scale();
    unsigned int          dy = sizes_y_scale();

    work_to_screen_handle(&show_block.visible_area, &sdata->box,
    				sdata->parent_window);

    /* Adjust show block for scrollbars and window outline */

    sizes_tool_sizes(NULL, &vscroll_width, NULL);
    vscroll_width -= dx;

    show_block.visible_area.xmin += dx;
    show_block.visible_area.ymin += dy;
    show_block.visible_area.xmax -= (dx + vscroll_width);
    show_block.visible_area.ymax -= dy;

    /* Fill in the rest */

    show_block.scx = show_block.scy = 0;
    show_block.behind = -1;
    show_block.window_flags = 0;
    show_block.parent_window_handle = sdata->parent_window;
    show_block.alignment_flags = 0;

    _set_extent(sdata);

    _swix(Toolbox_ShowObject, _INR(0,5),
          Toolbox_ShowObject_AsSubWindow, sdata->object_id,
          Toolbox_ShowObject_FullSpec, &show_block, sdata->parent_id, NULL_ComponentID);

    return NULL;
}

static void _redraw(PrivateScrollList *sdata,
				wimp_RedrawWindowRequest *event)
{
    WindowRedraw	block;
    int			more;
    wimp_Bbox		box;
    unsigned int	max_height, max_sprite_width;
    int			convertx, converty, base_line;

    block.window = event->window_handle;

    wimp_redraw_window(&block, &more);

    convertx = block.visible.xmin - block.scx;
    converty = block.visible.ymax - block.scy;

    // Calculate item height
    _get_item_size(sdata, &max_sprite_width, &max_height, &base_line);

    while (more)
    {
        colourtrans_set_gcol(sdata->background, 1<<7, 0);

        os_plot(PLOT_MOVE, block.current.xmin, block.current.ymin);
        os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK,
        		block.current.xmax, block.current.ymax);

        box.xmin = block.current.xmin - convertx;
        box.xmax = block.current.xmax - convertx;
        box.ymin = block.current.ymin - converty;
        box.ymax = block.current.ymax - converty;

        _scrolllist_redraw(sdata, &block, &box, max_sprite_width, max_height,
        				base_line);

        wimp_get_rectangle(&block, &more);
    }

    return;
}

int scrolllist_active(void)
{
    return scrolllist_list != NULL;
}

_kernel_oserror *scrolllist_die(void)
{
    return NULL;
}

/* scrolllist_add ---------------------------------------------------------
 */
_kernel_oserror *
scrolllist_add(ScrollList *sdata, int wimpw, ObjectID object_id,
				int **icons, int **data)
{
    _kernel_oserror	*e;
    PrivateScrollList	*sl;

    sl = (PrivateScrollList *) mem_allocate(sizeof(PrivateScrollList));
    if (!sl)
        return make_error(TextGadgets_ListAllocFailed, 0);

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(sl, sizeof(PrivateScrollList));
#endif

    e = _swix(Toolbox_CreateObject, _INR(0,1) | _OUT(0),
              Toolbox_CreateObject_InCore, &scroll_list_window,
              &sl->object_id); 
    if (e != NULL)
    {
#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(sl);
#endif
        mem_free(sl);
        return e;
    }
    *data = (int *) sl;

    sl->event = sdata->event ? sdata->event : ScrollList_Selection;
    sl->state = sdata->hdr.flags;
    sl->parent_id = object_id;
    sl->component_id = sdata->hdr.component_id;

    sl->parent_window = wimpw;
    sl->box.xmin = sdata->hdr.xmin;
    sl->box.xmax = sdata->hdr.xmax;
    sl->box.ymin = sdata->hdr.ymin;
    sl->box.ymax = sdata->hdr.ymax;
    sl->entries = NULL;
    sl->no_entries = 0;
    sl->foreground = sdata->foreground;
    sl->background = sdata->background;
    sl->font_handle = 0;
    sl->visible = 0;

    *icons = my_icons;

    add_redraw_handler(sl);

    add_task_interest(GLib_ToolboxEvents, filter_toolbox_events,
    				TextGadgets_Filter);
    add_task_interest(GLib_WimpEvents, filter_wimp_events,
    				TextGadgets_Filter);

    _show(sl);

    return NULL;
}

_kernel_oserror *scrolllist_remove(PrivateScrollList *handle)
{
    remove_redraw_handler(handle);

    if (handle->font_handle)
        font_lose_font(handle->font_handle);

    if (handle->entries)
    {
        while (handle->no_entries)
        {
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock(
            		handle->entries[handle->no_entries - 1].text);
#endif
            mem_free(handle->entries[handle->no_entries - 1].text);
            if (handle->entries[handle->no_entries - 1].sprite_name != NULL)
            {
#ifdef MemCheck_MEMCHECK
                MemCheck_UnRegisterMiscBlock(
            		handle->entries[handle->no_entries - 1].sprite_name);
#endif
                mem_free(handle->entries[handle->no_entries - 1].sprite_name);
            }
            handle->no_entries--;
        }

        free(handle->entries);
    }

    remove_task_interest(GLib_ToolboxEvents, filter_toolbox_events);
    remove_task_interest(GLib_WimpEvents, filter_wimp_events);
    _swix(Toolbox_DeleteObject, _INR(0,1), 0, handle->object_id);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(handle);
#endif
    mem_free(handle);

    return NULL;
}

static _kernel_oserror *_set_colour(PrivateScrollList *handle,
	unsigned int flags, unsigned int foreground, unsigned int background)
{
    BOOL changed;

    if ((flags & ScrollList_DesktopColours) != 0)
    {
        // Need to translate desktop colours to real colours
        Palette	palette;

        if ((foreground > 15) || (background > 15))
            return make_error(TextGadgets_DuffColour, 0);

        _swix(Wimp_ReadPalette, _IN(1)|_IN(2),&palette,0x45555254/*'TRUE'*/);
        foreground = palette.colours[foreground] & ~0xff;
        background = palette.colours[background] & ~0xff;
    }
    changed = (handle->foreground != foreground) ||
              (handle->background != background);
    handle->foreground = foreground;
    handle->background = background;

    if (changed)
    {
        // Redraw, given colour change
        _swix(Toolbox_ObjectMiscOp, _INR(0,3),
              0, handle->object_id, Window_ForceRedraw, &redraw_all_box);
    }

    return NULL;
}

static _kernel_oserror *_add_item(PrivateScrollList *sdata,
	const char *text, const void *sprite_area, const char *sprite_name,
	int index, unsigned int flags)
{
    wimp_GetWindowState	state;
    struct _entries		*new_list;

    // Alloc array of char *s
    if (sdata->entries == NULL)
        new_list = malloc(sizeof(struct _entries));
    else
        new_list = realloc(sdata->entries, sizeof(struct _entries) *
        					(sdata->no_entries + 1));
    if (new_list == NULL)
        return make_error(TextGadgets_ListAllocFailed, 0);

    sdata->entries = new_list;

    if ((index < 0) || (index >= sdata->no_entries) ||
    	(sdata->no_entries == 0))
    {
        // Add item at end of list

        sdata->entries[sdata->no_entries].text = mem_allocate(strlen(text) + 1);
        if (sdata->entries[sdata->no_entries].text == NULL)
        {
            // Can't be bothered to shrink sdata->entries - only one bit
            // bigger, and will get realloc'd down on next call anyway
            return make_error(TextGadgets_ListAllocFailed, 0);
        }
#ifdef MemCheck_MEMCHECK
        MemCheck_RegisterMiscBlock(sdata->entries[sdata->no_entries].text,
        			strlen(text) + 1);
#endif
        strcpy(sdata->entries[sdata->no_entries].text, text);

        sdata->entries[sdata->no_entries].sprite_area = (const int*)sprite_area;
        if (sprite_name != NULL)
        {
            sdata->entries[sdata->no_entries].sprite_name = mem_allocate(13);
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock(
        			sdata->entries[sdata->no_entries].sprite_name,
        			13);
#endif
            if (sdata->entries[sdata->no_entries].sprite_name == NULL)
                return make_error(TextGadgets_ListAllocFailed, 0);

            strncpy(sdata->entries[sdata->no_entries].sprite_name,
            	sprite_name, 12);
            sdata->entries[sdata->no_entries].sprite_name[12] = '\0';
        }
        else
            sdata->entries[sdata->no_entries].sprite_name = NULL;

        sdata->entries[sdata->no_entries].flags = flags & 7;
    }
    else
    {
        // Insert entry
        unsigned int i;
        char *new_item;
        char *new_spr_name;

        new_item = mem_allocate(strlen(text) + 1);
        if (new_item == NULL)
            return make_error(TextGadgets_ListAllocFailed, 0);
#ifdef MemCheck_MEMCHECK
        MemCheck_RegisterMiscBlock(new_item, strlen(text) + 1);
#endif
        strcpy(new_item, text);

        if (sprite_name != NULL)
        {
            new_spr_name = mem_allocate(strlen(sprite_name) + 1);
            if (new_spr_name == NULL)
                return make_error(TextGadgets_ListAllocFailed, 0);
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock(new_spr_name, strlen(sprite_name) + 1);
#endif
            strcpy(new_spr_name, sprite_name);
        }
        else new_spr_name = NULL;

        for (i = sdata->no_entries; i > index; i--)
        {
            sdata->entries[i].text = sdata->entries[i - 1].text;
            sdata->entries[i].sprite_area = sdata->entries[i - 1].sprite_area;
            sdata->entries[i].sprite_name = sdata->entries[i - 1].sprite_name;
            sdata->entries[i].flags = sdata->entries[i - 1].flags;
        }

        sdata->entries[index].text = new_item;
        sdata->entries[index].sprite_area = sprite_area;
        sdata->entries[index].sprite_name = new_spr_name;
        sdata->entries[index].flags = flags & 7;
    }

    sdata->no_entries++;

    if (!(flags & ScrollList_AddItem_MakeVisible))
    {
        // Remember existing window details
        window_get_wimp_handle(0, sdata->object_id, &state.open.window_handle);
        wimp_get_window_state(&state);
    }
    
    // Update window extent (this scrolls to the top of the display too)
    _show(sdata);

    if (flags & ScrollList_AddItem_MakeVisible)
    {
        // Been asked to make the new item visible
        if ((index < 0) || (index >= sdata->no_entries - 1))
            _make_visible(sdata, sdata->no_entries - 1);
        else
            _make_visible(sdata, index);
    }
    else
    {
        int x = state.open.scx, y = state.open.scy;

        // Restore scroll position
        if (!wimp_get_window_state(&state))
        {
            state.open.scx = x;
            state.open.scy = y;

            wimp_open_window((wimp_OpenWindow *) &state);
        }
    }

    // Redraw, given addition
    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, sdata->object_id, Window_ForceRedraw, &redraw_all_box);

    return NULL;
}

static _kernel_oserror *_send_selection_event(const PrivateScrollList *sdata,
                                              unsigned int flags, int item)
{
    ScrollListSelectionEvent event;

    event.hdr.size             = sizeof(ScrollListSelectionEvent);
    event.hdr.reference_number = 0;
    event.hdr.event_code       = sdata->event;
    event.hdr.flags            = 0;

    event.item  = item;
    event.flags = flags;

    _swix(Toolbox_RaiseToolboxEvent, _INR(0,3),
          0, sdata->parent_id, sdata->component_id, (ToolboxEvent *)&event);

    return NULL;
}

static _kernel_oserror *_delete_items(PrivateScrollList *sdata,
				unsigned int flags, int start, int end)
{
    wimp_GetWindowState	state;
    unsigned int		i, j;

    if (start < 0)
        start = 0;
    if (end > sdata->no_entries - 1)
        end = sdata->no_entries - 1;

    if ((end < start) || (sdata->no_entries == 0))
        return NULL;

    // Free all memory used
    for (i = start; i <= end; i++)
    {
#ifdef MemCheck_MEMCHECK
        MemCheck_UnRegisterMiscBlock(sdata->entries[i].text);
#endif
        mem_free(sdata->entries[i].text);
        if (sdata->entries[i].sprite_name != NULL)
        {
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock(sdata->entries[i].sprite_name);
#endif
            mem_free(sdata->entries[i].sprite_name);
        }
    }

    // Compact down any existing entries
    for (j = start; i < sdata->no_entries; i++, j++)
    {
        sdata->entries[j].text = sdata->entries[i].text;
        sdata->entries[j].sprite_area = sdata->entries[i].sprite_area;
        sdata->entries[j].sprite_name = sdata->entries[i].sprite_name;
        sdata->entries[j].flags = sdata->entries[i].flags;
    }

    sdata->no_entries -= end - start + 1;

    if (flags & ScrollList_DeleteItems_DoNotJumpToTop)
    {
        // Remember existing window details
        window_get_wimp_handle(0, sdata->object_id, &state.open.window_handle);
        wimp_get_window_state(&state);
    }

    // Update window extent (this scrolls to the top of the display too)
    _show(sdata);

    if (flags & ScrollList_DeleteItems_DoNotJumpToTop)
    {
        int x = state.open.scx, y = state.open.scy;

        // Restore scroll position
        if (!wimp_get_window_state(&state))
        {
            state.open.scx = x;
            state.open.scy = y;

            wimp_open_window((wimp_OpenWindow *) &state);
        }
    }

    // Redraw, given deletion
    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, sdata->object_id, Window_ForceRedraw, &redraw_all_box);

    if (flags & ScrollList_SelectionChangingMethod_SendEvent)
        return _send_selection_event(sdata, 0, -1);
    else
        return NULL;
}

#define SELECT_SELECT	0
#define SELECT_DESELECT	1
#define SELECT_TOGGLE	2
#define SELECT_ONLYONE	3

static _kernel_oserror *_select_item(const PrivateScrollList *sdata, unsigned int flags,
					int index, unsigned int selected)
{
    wimp_Bbox		box;
    unsigned int	item_height;
    int			item_start, item_end;

    if ((index < 0) || (index >= sdata->no_entries))
        return make_error(TextGadgets_BadIndex, 0);

    _get_item_size(sdata, NULL, &item_height, NULL);
    box.xmin = 0;
    box.xmax = 0xfff;

    /*
     * If we're only supposed to select one thing or the list doesn't
     * allow multiple selections, deselect everything to start with.
     */

    if (
         selected == SELECT_ONLYONE ||
         !(sdata->state & ScrollList_MultipleSelections)
       )
    {
        int i;

        if (selected == SELECT_ONLYONE) selected = SELECT_SELECT;

        for (i = 0; i < sdata->no_entries; i++)
        {
            if (i == index)
                continue;

            if (sdata->entries[i].flags & FLAGS_SELECTED)
            {
                sdata->entries[i].flags &= ~FLAGS_SELECTED;

                box.ymin = -(i + 1) * item_height;
                box.ymax = -i * item_height;

                _swix(Toolbox_ObjectMiscOp, _INR(0,3),
                      0, sdata->object_id, Window_ForceRedraw, &box);
            }
        }
    }

    /* Do we want to operate on all items, or just one? */

    if (flags & ScrollList_SelectionChangingMethod_OnAll)
    {
        item_start = 0;
        item_end   = sdata->no_entries;
    }
    else item_start = index, item_end = index + 1;

    /* Do the selection / deselection / toggling */

    for ( index = item_start; index < item_end; index++)
    {
        unsigned int old_flags = sdata->entries[index].flags;

        if (selected == SELECT_SELECT)
            sdata->entries[index].flags |= FLAGS_SELECTED;
        else if (selected == SELECT_DESELECT)
            sdata->entries[index].flags &= ~FLAGS_SELECTED;
        else /* SELECT_TOGGLE */
            sdata->entries[index].flags ^= FLAGS_SELECTED;

        /* Only redraw if we changed the flags */

        if (old_flags != sdata->entries[index].flags)
        {
            box.ymin = -(index + 1) * item_height;
            box.ymax = -index * item_height;

            _swix(Toolbox_ObjectMiscOp, _INR(0,3),
                  0, sdata->object_id, Window_ForceRedraw, &box);
        }
    }

    /* Send an event now we've finished? */

    if (flags & ScrollList_SelectionChangingMethod_SendEvent)
    {
        unsigned int event_flags = 0;

        /*
         * ScrollList.h says we'll send an item number of 0 if
         * selecting all items.
         */

        if (flags & ScrollList_SelectionChangingMethod_OnAll) index = 0;

        /* Did we select or deselect items? */

        if (sdata->entries[index].flags & FLAGS_SELECTED)
            event_flags |= ScrollList_Selection_Flags_Set;

        /* Exit by sending the event */

        return _send_selection_event(sdata, event_flags, index);
    }
    else return NULL;
}

static _kernel_oserror *_set_font(PrivateScrollList *sdata,
				const char *font,
				unsigned int width, unsigned int height)
{
    _kernel_oserror	*e;
    wimp_GetWindowState	state;

    if (sdata->font_handle != 0)
    {
        // Free existing font handle
        // Note that we do this even for fonts that were passed in by handle,
        // to match the behaviour of the Window module (see gadgets_set_font)
        font_lose_font(sdata->font_handle);
        sdata->font_handle = 0;
    }

    // Get new font handle
    if (((unsigned int)font)<256)
    {
        sdata->font_handle = (unsigned int) font;
    }
    else if (font[0] < ' ')
    {
        sdata->font_handle = 0;
    }
    else
    {
        e = font_find_font(font, width, height, 0, 0,
        			&sdata->font_handle);
        if (e)
        {
            sdata->font_handle = 0;
            return e;
        }
    }

    // Remember existing window details
    window_get_wimp_handle(0, sdata->object_id, &state.open.window_handle);
    wimp_get_window_state(&state);

    // Update window extent (this scrolls to the top of the display too)
    _show(sdata);

    if (1)
    {
        int x = state.open.scx, y = state.open.scy;

        // Restore scroll position
        if (!wimp_get_window_state(&state))
        {
            state.open.scx = x;
            state.open.scy = y;

            wimp_open_window((wimp_OpenWindow *) &state);
        }
    }

    // Redraw, given font change
    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, sdata->object_id, Window_ForceRedraw, &redraw_all_box);

    return NULL;
}

static _kernel_oserror *_get_selected(const PrivateScrollList *sdata,
				unsigned int offset, int *new_offset)
{
    if (sdata == NULL || new_offset == NULL)
        return NULL;

    for (offset++; offset < sdata->no_entries; offset++)
    {
        if (sdata->entries[offset].flags & FLAGS_SELECTED)
        {
            *new_offset = offset;
            return NULL;
        }
    }

    *new_offset = -1;

    return NULL;
}

static _kernel_oserror *_make_visible(const PrivateScrollList *sdata,
			int visible)
{
    unsigned int		item_height;
    wimp_GetWindowState	block;

    _get_item_size(sdata, NULL, &item_height, NULL);

    window_get_wimp_handle(0, sdata->object_id, &block.open.window_handle);

    wimp_get_window_state(&block);

    block.open.scy = -visible * item_height;

    wimp_open_window((wimp_OpenWindow *) &block);

    return NULL;
}

static _kernel_oserror *_get_item_text(const PrivateScrollList *sdata,
			char *buffer, int buffer_size, int index, int *nbytes)
{
    if (index >= sdata->no_entries)
        return make_error(TextGadgets_BadIndex, 0);

    if (buffer == NULL)
    {
        *nbytes = strlen(sdata->entries[index].text) + 1;
        return NULL;
    }

    strncpy(buffer, sdata->entries[index].text, buffer_size);

    *(buffer + buffer_size - 1) = '\0';

    if (nbytes)
        *nbytes = strlen(buffer) + 1;

    return NULL;
}

static _kernel_oserror *_set_item_text(const PrivateScrollList *sdata,
			char *new_text, int index)
{
    char            * new_item;
    unsigned int      item_height;
    wimp_Bbox              box;

    /* Sanity checks */

    if (index < 0 || index >= sdata->no_entries)
        return make_error(TextGadgets_BadIndex, 0);

    if (!new_text) return NULL;

    /* Do nothing if the string hasn't changed */

    if (!strcmp(new_text, sdata->entries[index].text)) return NULL;

    /* Ditch the existing text */

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(sdata->entries[index].text);
#endif
    mem_free(sdata->entries[index].text);

    /*
     * Make sure things aren't going to fall over horribly if
     * the allocation fails below
     */

    sdata->entries[index].text = "";

    /* Allocate and copy in the new string */

    new_item = mem_allocate(strlen(new_text) + 1);
    if (new_item == NULL)
        return make_error(TextGadgets_ListAllocFailed, 0);

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(new_item, strlen(new_text) + 1);
#endif

    strcpy(new_item, new_text);
    sdata->entries[index].text = new_item;

    /* Redraw it */

    _get_item_size(sdata, NULL, &item_height, NULL);

    box.xmin = 0;
    box.xmax = 0xfff;
    box.ymin = -(index + 1) * item_height;
    box.ymax = -index * item_height;

    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, sdata->object_id, Window_ForceRedraw, &box);

    /* Finished */

    return NULL;
}

_kernel_oserror *scrolllist_method(PrivateScrollList *sdata,
				_kernel_swi_regs *regs)
{
    _kernel_oserror *e = NULL;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(regs, sizeof(_kernel_swi_regs));
#endif

    switch (regs->r[2])
    {
        case ScrollList_GetState:
            regs->r[0] = sdata->state;
            break;

        case ScrollList_SetState:
            sdata->state = regs->r[4];
            break;

        case ScrollList_AddItem:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void*)regs->r[4],
            			strlen((char*)regs->r[4]) + 1);
            MemCheck_SetBlockAccess((void*)regs->r[4], 1, 0); // read only
            MemCheck_RegisterMiscBlock((void*)regs->r[5], 4);
            if (regs->r[5] != NULL)
            {
                MemCheck_ResizeMiscBlock((void*)regs->r[5],*((int*)regs->r[5]));
            }
            MemCheck_SetBlockAccess((void*)regs->r[5], 1, 0); // read only
            MemCheck_RegisterMiscBlock((void*)regs->r[6],
            			strlen((char*)regs->r[6]) + 1);
            MemCheck_SetBlockAccess((void*)regs->r[6], 1, 0); // read only
#endif
            e = _add_item(sdata, (const char *)regs->r[4],
            		(const void *)regs->r[5], (const char *)regs->r[6],
            		regs->r[7], regs->r[0]);
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void*)regs->r[4]);
            MemCheck_UnRegisterMiscBlock((void*)regs->r[5]);
            MemCheck_UnRegisterMiscBlock((void*)regs->r[6]);
#endif
            break;

        case ScrollList_DeleteItems:
            e = _delete_items(sdata, regs->r[0], regs->r[4], regs->r[5]);
            break;

        case ScrollList_SelectItem:
            e = _select_item(sdata, regs->r[0], regs->r[4], SELECT_SELECT);
            break;

        case ScrollList_DeselectItem:
            e = _select_item(sdata, regs->r[0], regs->r[4], SELECT_DESELECT);
            break;

        case ScrollList_GetSelected:
            e = _get_selected(sdata, regs->r[4], &(regs->r[0]));
            break;

        case ScrollList_MakeVisible:
            _make_visible(sdata, regs->r[4] < 0 ? 0 : regs->r[4]);
            break;

        case ScrollList_SetColour:
            // R4 = foreground col, R5 = background col
            e = _set_colour(sdata, regs->r[0], regs->r[4], regs->r[5]);
            break;

        case ScrollList_GetColour:
            regs->r[0] = sdata->foreground;
            regs->r[1] = sdata->background;
            break;

        case ScrollList_SetFont:
            e = _set_font(sdata, (const char *)regs->r[4], regs->r[5],
            			regs->r[6]);
            break;

        case ScrollList_GetItemText:
            e = _get_item_text(sdata, (char*)regs->r[4], regs->r[5],
            			regs->r[6], &(regs->r[5]));
            break;

        case ScrollList_SetItemText:
            e = _set_item_text(sdata, (char*)regs->r[4], regs->r[5]);
            break;

        case ScrollList_CountItems:
            regs->r[0] = sdata->no_entries;
            break;

        default:
            break;
   }

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(regs);
#endif

   return e;
}

/* ------------------------------------------------------------------------
 */
_kernel_oserror *scrolllist_fade(PrivateScrollList *sdata, int fade)
{
    // Redraw all of gadget, faded
    // (plot foreground colour as foreground + background / 2, and
    // background as background
    IGNORE(fade);

    sdata->state &= ~Gadget_Faded;
    sdata->state |= fade ? Gadget_Faded : 0;

    _swix(Toolbox_ObjectMiscOp, _INR(0,3),
          0, sdata->object_id, Window_ForceRedraw, &redraw_all_box);

    return NULL;
}

_kernel_oserror *scrolllist_move(int type, PrivateScrollList *sdata,
				wimp_Bbox *box)
{
    IGNORE(type);

    sdata->box = *box;

    return _show(sdata);
}

/* ------------------------------------------------------------------------
 */

_kernel_oserror *scrolllist_plot(ScrollList *sdata)
{
    _kernel_oserror		*e;
    wimp_GetWindowState		state;
    wimp_Bbox			box;
    wimp_Icon			label;

    if (redrawing_window == 0)
        return NULL;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(sdata, sizeof(ScrollList));
#endif

    state.open.window_handle = redrawing_window;
    if ((e = wimp_get_window_state(&state)) != NULL)
        return e;

    box.xmin = sdata->hdr.xmin;
    box.xmax = sdata->hdr.xmax;
    box.ymin = sdata->hdr.ymin;
    box.ymax = sdata->hdr.ymax;
    label.bbox = box;
    work_to_screen(&box, &state);

    // Plot background
    colourtrans_set_gcol(sdata->background, 0, 0);
    os_plot(PLOT_MOVE, box.xmin, box.ymin);
    os_plot(PLOT_RECTANGLE_FILL | PLOT_DRAW, box.xmax, box.ymax);

    // Plot foreground (no actual sub-window on plotting...)
    colourtrans_set_gcol(sdata->foreground, 0, 0);
    os_plot(PLOT_DRAW, box.xmin, box.ymax);
    os_plot(PLOT_DRAW, box.xmin, box.ymin);
    os_plot(PLOT_DRAW, box.xmax, box.ymin);
    os_plot(PLOT_DRAW, box.xmax, box.ymax);

    box.xmin = MAX(box.xmax - SIZES_TOOL_DEFAULT, box.xmin);
    label.bbox.xmax = label.bbox.xmax - (box.xmax - box.xmin);
    plot_2d_scrollbar(&box, sdata->foreground, TRUE);

    // Overlay a virtual label in the non scrollbar bit
    label.flags = wimp_ICONFLAGS_TEXT |
                  wimp_ICONFLAGS_VCENTRE | wimp_ICONFLAGS_HCENTRE |
                  (wimp_ICONFLAGS_FORECOL * wimp_BLACK) |
                  (wimp_ICONFLAGS_BACKCOL * wimp_WHITE);
    strcpy(label.data.text, "ScrollList");
    wimp_plot_icon(&label);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(sdata);
#endif

    return NULL;
}

static _kernel_oserror *_scrolllist_redraw(const PrivateScrollList *sdata,
				WindowRedraw *block, wimp_Bbox *box,
				unsigned int sprite_width,
				unsigned int item_height, int base_line)
{
    unsigned int	i, y;

    IGNORE(block);

    if (sdata->entries == NULL)
        return NULL;

    i = (-box->ymax) / item_height;

    for (y = block->visible.ymax - block->scy - ((i+1) * item_height);
    	(y + item_height > block->current.ymin) && (i < sdata->no_entries);
    	y -= item_height, i++)
    {
        // Plot item i
        unsigned int foreground, background;

        if (sdata->entries[i].flags & FLAGS_SELECTED)
        {
            colourtrans_set_gcol(sdata->foreground, 0, 0);
            os_plot(PLOT_MOVE, block->visible.xmin, y);
            os_plot(PLOT_RECTANGLE_FILL | PLOT_DRAW,
            	block->visible.xmax - 1, y + item_height - 1);
        }

        // Plot sprite
        if (sdata->entries[i].sprite_name)
        {
            unsigned int sprite_info = sdata->entries[i].flags &
            			(FLAGS_SPRITE_AREA | FLAGS_SPRITE_NAME);

            if (sprite_info != (FLAGS_SPRITE_AREA | FLAGS_SPRITE_NAME))
            {
                // We have a sprite to plot
                wimp_Icon	icon;

                icon.bbox.xmin = 4;
                icon.bbox.ymin = -(i+1) * item_height;
                icon.bbox.xmax = sprite_width + 8;
                icon.bbox.ymax = -i * item_height;
                icon.flags = wimp_ICONFLAGS_SPRITE | wimp_ICONFLAGS_HCENTRE |
                			wimp_ICONFLAGS_VCENTRE | wimp_ICONFLAGS_INDIRECT;

                icon.data.indirect_sprite.sprite.name = sdata->entries[i].sprite_name;
                if (sprite_info == 0)
                    icon.data.indirect_sprite.sprite_area = (int*)1; // Wimp sprite area
                else
                    icon.data.indirect_sprite.sprite_area = (int*)
                    				sdata->entries[i].sprite_area;
                if (sprite_info == 2)
                    icon.data.indirect_sprite.name_len = 0;
                else
                    icon.data.indirect_sprite.name_len = strlen(
                    				icon.data.indirect_sprite.sprite.name);

                if (sdata->entries[i].flags & FLAGS_HALF_SIZE)
                    icon.flags |= wimp_ICONFLAGS_HALF_SIZE;

                if (sdata->entries[i].flags & FLAGS_SELECTED)
                    icon.flags |= wimp_ICONFLAGS_INVERT;

                if (sdata->state & Gadget_Faded)
                    icon.flags |= wimp_ICONFLAGS_FADED;

                wimp_plot_icon(&icon);
            }
        }

        if (sdata->entries[i].flags & FLAGS_SELECTED)
        {
            foreground = sdata->background;
            background = sdata->foreground;
        }
        else
        {
            foreground = sdata->foreground;
            background = sdata->background;
        }

        if (sdata->state & Gadget_Faded)
            foreground = foreground & 0xfdfdfd00;

        // Plot text
        if (!sdata->font_handle)
        {
            // No outline font set so use Wimp_TextOp - this is safe, since we
            // already require nested windows, so must have this SWI too...

            // Set the colours
            _swix(Wimp_TextOp, _INR(0,2), 0, foreground, background);

            // Plot the text
            _swix(Wimp_TextOp, _INR(0,5), 2 | 1<<30, sdata->entries[i].text,
       	    		-1, -1, block->visible.xmin + sprite_width +12,
       			y - base_line);
        }
        else
        {
            // Plot using an outline font
            colourtrans_set_font_colours(sdata->font_handle, background,
            			foreground, 14);

            font_paint(sdata->font_handle, sdata->entries[i].text,
            		1<<4 | 1<<9, // OS units, kerning...
            		block->visible.xmin + sprite_width + 12,
            		y - base_line, 0, 0, 0);
        }
    }

    return NULL;
}

static _kernel_oserror *scrolllist_mclick(const PrivateScrollList *sdata,
		wimp_MouseClick *click)
{
    _kernel_oserror		*e;
    wimp_GetWindowState	state;
    int				mouse_x, mouse_y;
    int                         event_item;
    unsigned int                event_flags;
    unsigned int		item_height;

    if (click->buttons == 2)
    {
        // Menu clicked
        ObjectID	menu_id;

        _swix(Toolbox_ObjectMiscOp, _INR(0,2) | _OUT(0),
              0, sdata->parent_id, Window_GetMenu,
              &menu_id);
        if (menu_id != NULL_ObjectID)
        {
            _swix(Toolbox_ShowObject, _INR(0,5),
                  0, menu_id,
                  0, 0, sdata->parent_id, sdata->component_id);
        }
        return NULL;
    }

    // Check if it's a drag
    if (click->buttons >= 16 && click->buttons <256)
        return NULL;

    window_get_wimp_handle(0, sdata->object_id, &state.open.window_handle);
    e = wimp_get_window_state(&state);
    if (e) return e;

    mouse_x = click->x + state.open.visible_area.xmin + state.open.scx;
    mouse_y = click->y - state.open.visible_area.ymax + state.open.scy;

    _get_item_size(sdata, NULL, &item_height, NULL);

    event_item = -mouse_y / item_height;

    /* SNB: 19980518: changed condition to >= to stop "extra item" events. */
    if (event_item >= sdata->no_entries)
        return NULL;

    if (click->buttons >= 256)
    {
        if ((click->buttons / 256) & (1<<0))
        {
            _select_item(sdata, 0, event_item, SELECT_TOGGLE);
        }
        else if ((click->buttons / 256) & (1<<2))
        {
            if (!(sdata->entries[event_item].flags & FLAGS_SELECTED))
                _select_item(sdata, 0, event_item, SELECT_ONLYONE);
        }
    }

    // Send event -
    event_flags = 0;

    if (click->buttons < 16)
    {
        // double click
        event_flags |= ScrollList_Selection_Flags_DoubleClick;
    }

    /* SNB: 19980618: added flagging of adjust clicks */
    if (click->buttons & (1 | 256)) {
            event_flags |= ScrollList_Selection_Flags_AdjustClick;
    }

    return _send_selection_event(sdata, event_flags, event_item);
}

#ifdef MemCheck_MEMCHECK
static _kernel_oserror *scrolllist_filter2(_kernel_swi_regs *regs)
#else
_kernel_oserror *scrolllist_filter(_kernel_swi_regs *regs)
#endif
{
    ToolboxEvent	*event = (ToolboxEvent *)regs->r[1];
    IDBlock		*id_block = (IDBlock *)regs->r[3];
    int			event_code = regs->r[0];
    unsigned int	i;

    if (scrolllist_list == NULL)
        return NULL;

    if (event_code == wimp_EREDRAW)
    {
        for (i = 0; scrolllist_list[i] != NULL; i++)
        {
            wimp_RedrawWindowRequest *wimp_redraw_event =
            				(wimp_RedrawWindowRequest *) event;
            int			window_handle;

            window_get_wimp_handle(0, scrolllist_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_redraw_event->window_handle)
            {
                _redraw(scrolllist_list[i], wimp_redraw_event);

                // Claim event, since we don't want the application to do any
                // redraw
                regs->r[0] = -1;
            }
        }

        return NULL;
    }
    else if (event_code == wimp_EBUT)
    {
        for (i = 0; scrolllist_list[i] != NULL; i++)
        {
            wimp_MouseClick *wimp_mouse_event = (wimp_MouseClick *)event;
            int			window_handle;

            window_get_wimp_handle(0, scrolllist_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_mouse_event->window_handle)
            {
                scrolllist_mclick(scrolllist_list[i], wimp_mouse_event);
                // Claim event
                regs->r[0] = -1;
            }
        }

        return NULL;
    }

    if ((event_code != wimp_ETOOLBOX_EVENT) ||
        ((id_block->self_component & 0xfff) != 0x800) ||
        (scrolllist_list == NULL))
        return NULL;

    if (event->hdr.event_code == Toolbox_ObjectDeleted)
    {
        int remaining = 0;
        PrivateScrollList **new_list;
        // An object has been deleted, so remove from internal list
        // any gadgets inside it.
        for (i = 0; scrolllist_list[i] != NULL; i++)
        {
            if (scrolllist_list[i]->parent_id == id_block->self_id)
            {
                // Found one!
                int j;
                for (j = i; scrolllist_list[j] != NULL; j++)
                {
                    // Copy down following gadgets
                    scrolllist_list[j] = scrolllist_list[j+1];
                }
            }
            else
                remaining++;
        }

        // Shrink memory block
        if (remaining == 0)
        {
            free(scrolllist_list);
            scrolllist_list = NULL;
        }
        else
        {
            new_list = realloc(scrolllist_list,
        			sizeof(PrivateScrollList*) * (remaining + 1));
            if (new_list != NULL)
                scrolllist_list = new_list;
        }
    }

    return NULL;
}

#ifdef MemCheck_MEMCHECK
_kernel_oserror *scrolllist_filter(_kernel_swi_regs *regs)
{
    _kernel_oserror *e;

    MemCheck_RegisterMiscBlock((void*)regs->r[1], 256);
    MemCheck_RegisterMiscBlock((void*)regs->r[3], sizeof(IdBlock));
    e = scrolllist_filter2(regs);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[1]);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[3]);

    return e;
}
#endif
@


1.15
log
@Fix for null pointer dereference
When there are no items in the scroll list, the check of select/adjust clicks were using event_item=0 and looking up in a NULL sdata list.
Move the (existing) early exit a bit higher up, since there are no entries in the list the _select_item() calls aren't needed anyway.
Fixes issue reported by John Rickman https://www.riscosopen.org/forum/forums/4/topics/4011

Version 0.41. Tagged as 'Gadgets-0_41'
@
text
@d56 1
d291 2
a292 1
                _swix(Wimp_SpriteOp, _IN(0)|_IN(2)|_OUTR(3,4), 40,
d300 2
a301 1
                	40 + (sprite_info == 1) ? 256 : 512,
d557 1
a557 1
    if (flags | ScrollList_DesktopColours == flags)
@


1.14
log
@Plot a more credible rendition of TextArea and ScrollList
Both the TextArea gadget and ScrollList were outputting an unhelpful white rectangle and mysterious black rectangle when asked to plot the gadget prototype (eg. in the gadget palette in ResEd). The black rectangle turned out to represent a scroll bar, though it was the wrong width.
Changed to plot a 2D scrollbar (ala RISC OS 2) then overlay a virtual icon with the name of the gadget type.
main.c:
Relocate helper functions into glib.
Return 'Bad SWI' for unknown subreasons.
glib.c/glib3.c:
Remove various unused functions.
Added new function to plot a grey scrollbar from nested rectangles.
TextArea.c:
Add a vertical, or horixontal, or both, scrollbar plus the label "TextArea".
ScrollList.c:
Add a vertical scrollbar plus the label "ScrollList".

Requires Common-0_25 for the colour defines. Tested in !ResEd in various eigenfactor modes.

Version 0.40. Tagged as 'Gadgets-0_40'
@
text
@d1459 4
a1476 5
    /* SNB: 19980518: changed condition to >= to stop "extra item" events. */

    if (event_item >= sdata->no_entries)
        return NULL;

@


1.13
log
@ScrollList gadget redraw fixes
When _set_colour() is called, remember to redraw the gadget if the colours changed.
When _set_font() is called, remember to redraw the gadget and try to preserve the scroll bar positions.
Save a couple of SWIs if we know the scroll bars must jump in 2 other places.
Remove ScrollLisS, its (never called) function did nothing but return.
Removed duplicate redraw_box, same as redraw_all_box and marked as const.

Reported by Fred Graute, reference
  https://www.riscosopen.org/forum/forums/4/topics/3628
the memory leak aspects of the report have been transferred to ticket #414 for later consideration.
Tested with !ExifEdit and some special versions from Fred with the redraw workarounds removed.

Version 0.39. Tagged as 'Gadgets-0_39'
@
text
@d63 1
a63 1
#include "utils.h"
d71 1
a71 1
static unsigned int vscroll_width = SCROLLBAR_SIZE;
d1250 1
a1250 1
    int				x;
d1267 1
d1282 11
a1292 5
    // Plot fake scrollbar (black)
    colourtrans_set_gcol(0 /* black */, 1<<7, 0);
    x = MAX(box.xmax - vscroll_width, box.xmin);
    os_plot(PLOT_MOVE, x, box.ymin);
    os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK, box.xmax, box.ymax);
@


1.12
log
@Internationalised
Supporting code borrowed from 'Iconbar' toolbox module.
Tested in a ROM build and RAM build, triggering one error message and checking the dynamic area in task manager.

Version 0.37. Tagged as 'Gadgets-0_37'
@
text
@d75 1
a75 2
// Cannot be a const, 'cos of the stupid blimmin' tbox header files
static wimp_Bbox		redraw_box = {0, -0xffff, 0xffff, 0};
d79 4
a145 2
static wimp_Bbox redraw_all_box = {0, -0xffff, 0xffff, 0};

d552 2
d566 2
d571 7
d681 7
a687 4
    // Remember existing window details
    window_get_wimp_handle(0, sdata->object_id, &state.open.window_handle);
    wimp_get_window_state(&state);

d713 1
a713 2
//    scrolllist_update(sdata, sdata->box.xmin, sdata->box.ymin,
//    		sdata->box.xmax - vscroll_width, sdata->box.ymax);
d715 1
a715 1
          0, sdata->object_id, Window_ForceRedraw, &redraw_box);
d780 6
a785 4

    // Remember existing window details
    window_get_wimp_handle(0, sdata->object_id, &state.open.window_handle);
    wimp_get_window_state(&state);
d804 1
a804 2
//    scrolllist_update(sdata, sdata->box.xmin, sdata->box.ymin,
//    		sdata->box.xmax - vscroll_width, sdata->box.ymax);
d806 1
a806 1
          0, sdata->object_id, Window_ForceRedraw, &redraw_box);
d929 1
d960 24
a983 2
    scrolllist_update(sdata, sdata->box.xmin, sdata->box.ymin,
    		sdata->box.xmax - vscroll_width, sdata->box.ymax);
a1177 2
            scrolllist_update(sdata, sdata->box.xmin, sdata->box.ymin,
    		sdata->box.xmax - vscroll_width, sdata->box.ymax);
d1294 1
a1294 1
_kernel_oserror *_scrolllist_redraw(const PrivateScrollList *sdata,
@


1.11
log
@Change to link against tboxlibint
For some reason this toolbox module was unique in linking against the public toolboxlib rather than the internal one, this meant having to carefully tippy toe around not mixing header files (as they contain similar but differently named definitions).
A massive search and replace job.
Tested briefly using ResEd/ResTest and a textarea and scrolllist in a ROM build.
Requires Common-0_21.

Version 0.36. Tagged as 'Gadgets-0_36'
@
text
@d53 1
a61 1
#include "Text.h"
d157 1
a157 1
            return (_kernel_oserror *)&e_outoflistmem;
d174 1
a174 1
            return (_kernel_oserror *)&e_outoflistmem;
d190 1
a190 1
        return (_kernel_oserror *)&e_badslist;
d198 1
a198 1
        return (_kernel_oserror *)&e_badslist;
d456 1
a456 1
        return (_kernel_oserror *)&e_outoflistmem;
d557 1
a557 1
            return (_kernel_oserror *)&e_badcol;
d583 1
a583 1
        return (_kernel_oserror *)&e_outoflistmem;
d597 1
a597 1
            return (_kernel_oserror *)&e_outoflistmem;
d615 1
a615 1
                return (_kernel_oserror *)&e_outoflistmem;
d635 1
a635 1
            return (_kernel_oserror *)&e_outoflistmem;
d645 1
a645 1
                return (_kernel_oserror *)&e_outoflistmem;
d812 1
a812 1
        return (_kernel_oserror *)&e_badindex;
d993 1
a993 1
        return (_kernel_oserror *)&e_badindex;
d1021 1
a1021 1
        return (_kernel_oserror *)&e_badindex;
d1047 1
a1047 1
        return (_kernel_oserror *)&e_outoflistmem;
@


1.10
log
@ScrollList gadget fix
When 'select only one' or 'multiple selections forbidden' is in use any selection changes first deselect all.
However, in the second case, the module overrode the caller's selection reason so adjust clicking on an item would not deselect it - instead reselecting it!
Logic ammended.
From http://www.riscosopen.org/forum/forums/4/topics/1057

Version 0.35. Tagged as 'Gadgets-0_35'
@
text
@d28 1
a28 1
 *                     ensure it correctly fits gadget BBox. Can ask the
a48 2
#include <math.h>

d52 2
a53 2
#include "toolbox.h"
#include "window.h"
a54 1
#include "wimplib.h"
a56 1
#include "string32.h"
a59 1
#include "ScrollList.h"
d61 1
a61 1
#include "ScrollLisS.h"
a68 4
#define IGNORE(a) (a)=(a)
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#define MAX(x, y) ((x) > (y) ? (x) : (y))

d76 1
a76 1
static BBox		redraw_box = {0, -0xffff, 0xffff, 0};
d108 1
a108 1
        WimpWindow_NewFormat | WimpWindow_VScroll,
d120 1
a120 1
        10 * WimpIcon_ButtonType,// work_flags
d122 1
a122 2
        1,			// min_width
        1,			// min_height
d143 1
a143 1
static BBox redraw_all_box = {0, -0xffff, 0xffff, 0};
d340 1
a340 1
    BBox		newbox;
d354 2
a355 1
    window_set_extent(0, sdata->object_id, &newbox);
d379 1
a379 1
    show_block.xscroll = show_block.yscroll = 0;
d387 3
a389 3
    toolbox_show_object(Toolbox_ShowObject_AsSubWindow, sdata->object_id,
  			Toolbox_ShowObject_FullSpec, &show_block,
  			sdata->parent_id, -1);
d395 1
a395 1
				WimpRedrawWindowRequestEvent *event)
d397 1
a397 1
    WimpRedrawWindowBlock block;
d399 1
a399 1
    BBox		box;
d403 1
a403 1
    block.window_handle = event->window_handle;
d407 2
a408 2
    convertx = block.visible_area.xmin - block.xscroll;
    converty = block.visible_area.ymax - block.yscroll;
d417 1
a417 1
        os_plot(PLOT_MOVE, block.redraw_area.xmin, block.redraw_area.ymin);
d419 1
a419 1
        		block.redraw_area.xmax, block.redraw_area.ymax);
d421 4
a424 4
        box.xmin = block.redraw_area.xmin - convertx;
        box.xmax = block.redraw_area.xmax - convertx;
        box.ymin = block.redraw_area.ymin - converty;
        box.ymax = block.redraw_area.ymax - converty;
d448 1
a448 1
scrolllist_add(ScrollList *sdata, int wimpw, ObjectId object_id,
d462 4
a465 2
    if ((e = toolbox_create_object(1, &scroll_list_window,
    					&sl->object_id)) != NULL)
d481 4
a484 1
    sl->box = sdata->hdr.box;
d538 1
a538 1
    toolbox_delete_object(0, handle->object_id);
d573 1
a573 1
    WimpGetWindowStateBlock	state;
d670 1
a670 1
    window_get_wimp_handle(0, sdata->object_id, &state.window_handle);
d686 1
a686 1
        int x = state.xscroll, y = state.yscroll;
d691 2
a692 2
            state.xscroll = x;
            state.yscroll = y;
d694 1
a694 1
            wimp_open_window((WimpOpenWindowBlock *) &state);
d700 2
a701 1
    window_force_redraw(0, sdata->object_id, &redraw_box);
d719 2
a720 4
    toolbox_raise_toolbox_event(0,
                                sdata->parent_id,
                                sdata->component_id,
                                (ToolboxEvent *) &event);
d728 1
a728 1
    WimpGetWindowStateBlock	state;
d768 1
a768 1
    window_get_wimp_handle(0, sdata->object_id, &state.window_handle);
d776 1
a776 1
        int x = state.xscroll, y = state.yscroll;
d781 2
a782 2
            state.xscroll = x;
            state.yscroll = y;
d784 1
a784 1
            wimp_open_window((WimpOpenWindowBlock *) &state);
d790 2
a791 1
    window_force_redraw(0, sdata->object_id, &redraw_box);
d807 1
a807 1
    BBox		box;
d844 2
a845 1
                window_force_redraw(0, sdata->object_id, &box);
d879 2
a880 1
            window_force_redraw(0, sdata->object_id, &box);
d974 1
a974 1
    WimpGetWindowStateBlock	block;
d978 1
a978 1
    window_get_wimp_handle(0, sdata->object_id, &block.window_handle);
d982 1
a982 1
    block.yscroll = -visible * item_height;
d984 1
a984 1
    wimp_open_window((WimpOpenWindowBlock *) &block);
d1016 1
a1016 1
    BBox              box;
d1065 2
a1066 1
    window_force_redraw(0, sdata->object_id, &box);
d1190 2
a1191 1
    window_force_redraw(0, sdata->object_id, &redraw_all_box);
d1197 1
a1197 1
				BBox *box)
d1212 2
a1213 2
    WimpGetWindowStateBlock	state;
    BBox			box;
d1223 1
a1223 1
    state.window_handle = redrawing_window;
d1227 4
a1230 1
    box = sdata->hdr.box;
d1259 1
a1259 1
				WimpGetRectangleBlock *block, BBox *box,
d1272 2
a1273 2
    for (y = block->visible_area.ymax - block->yscroll - ((i+1) * item_height);
    	(y + item_height > block->redraw_area.ymin) && (i < sdata->no_entries);
d1282 1
a1282 1
            os_plot(PLOT_MOVE, block->visible_area.xmin, y);
d1284 1
a1284 1
            	block->visible_area.xmax - 1, y + item_height - 1);
d1296 1
a1296 1
                WimpPlotIconBlock	icon;
d1302 2
a1303 2
                icon.flags = WimpIcon_Sprite | WimpIcon_HCentred |
                			WimpIcon_VCentred | WimpIcon_Indirected;
d1305 1
a1305 1
                icon.data.is.sprite = sdata->entries[i].sprite_name;
d1307 1
a1307 1
                    icon.data.is.sprite_area = (int*)1; // Wimp sprite area
d1309 1
a1309 1
                    icon.data.is.sprite_area = (int*)
d1312 1
a1312 1
                    icon.data.is.sprite_name_length = 0;
d1314 2
a1315 2
                    icon.data.is.sprite_name_length = strlen(
                    				icon.data.is.sprite);
d1318 1
a1318 1
                    icon.flags |= WimpIcon_HalfSize;
d1321 1
a1321 1
                    icon.flags |= WimpIcon_Selected;
d1324 1
a1324 1
                    icon.flags |= WimpIcon_Shaded;
d1355 1
a1355 1
       	    		-1, -1, block->visible_area.xmin + sprite_width +12,
d1366 1
a1366 1
            		block->visible_area.xmin + sprite_width + 12,
d1375 1
a1375 1
		WimpMouseClickEvent *click)
d1378 1
a1378 1
    WimpGetWindowStateBlock	state;
d1387 1
a1387 6
        ObjectId	menu_id;

        window_get_menu(0, sdata->parent_id, &menu_id);
        if (menu_id != 0)
            toolbox_show_object(0, menu_id, 0, 0,
                                sdata->parent_id, sdata->component_id);
d1389 9
d1405 1
a1405 1
    window_get_wimp_handle(0, sdata->object_id, &state.window_handle);
d1409 2
a1410 2
    mouse_x = click->mouse_x + state.visible_area.xmin + state.xscroll;
    mouse_y = click->mouse_y - state.visible_area.ymax + state.yscroll;
d1458 1
a1458 1
    IdBlock		*id_block = (IdBlock *)regs->r[3];
d1465 1
a1465 1
    if (event_code == Wimp_ERedrawWindow)
d1469 2
a1470 2
            WimpRedrawWindowRequestEvent *wimp_redraw_event =
            				(WimpRedrawWindowRequestEvent *) event;
d1488 1
a1488 1
    else if (event_code == Wimp_EMouseClick)
d1492 1
a1492 1
            WimpMouseClickEvent *wimp_mouse_event = (WimpMouseClickEvent*)event;
d1509 1
a1509 1
    if ((event_code != 512) ||
@


1.9
log
@Remove unnecessary includes of "Modhdr.h".
The last change meant it was no longer being generated, so ammended the code to not need it in line with all the other toolbox modules.

Version 0.34. Tagged as 'Gadgets-0_34'
@
text
@d834 1
a834 1
        selected = SELECT_SELECT;
@


1.8
log
@TextGadgets module fixes & improvements
Detail:
  c/ScrollList, c/TextArea - ScrollList_SetFont and TextArea_SetFont now accept font handles instead of just font names. The handles are handled in the same way as the Window module, i.e. the handle will be managed and freed by the TextGadgets modules. Fixes bug #212.
  c/ScrollList, c/Scrollbar, c/TextArea - Fix handling of Toolbox_ObjectDeleted events. Original code would corrupt the object lists when deleting items, and reallocate much more memory than was actually needed. Fixes bug #214
  c/MemMan - Fix grow_handlers to not leave handle_list as NULL if the realloc fails. Fixes bug #216.
  c/MemMan, c/TextArea, c/TextMan, h/MemMan, h/TextMan - Changed how the 'Handle' type is handled. Instead of MemMan giving out direct pointers to Handle instances, it now gives out identifiers (HandleId). These identifiers are then converted to Handle pointers via get_handle whenever the contents need to be accessed. This allows the handle_list to be safely realloc'd without breaking all the existing Handle pointers. Fixes bug #217
  c/MemMan - Reduced HDNLE_GRW_BY from 1000 to 128 to save a bit of memory
Admin:
  Module compiles and runs, but actual functionality is untested.
  Fixes bugs 212, 214, 216, 217.


Version 0.32. Tagged as 'Gadgets-0_32'
@
text
@a67 1
#include "ModHdr.h"
@


1.7
log
@Function returns no longer use stack structures.
Previously, a number of errors were contructed as automatic variables then returned to the caller - potentially accessing stale stack area. All error blocks are now held in ROM and cast from there.
Error numbers are now not &00000000 or &20202020, using the allocated base - requires 'Common-0_15'.
Trimmed some unused debugging code out, saves about 3k.
Renamed C++ clashing variables to stop the compiler moaning.
Implemented feature request to accept the empty string "" as no font handle in _SetFont calls.
At some point, this module needs internationalising.

Version 0.31. Tagged as 'Gadgets-0_31'
@
text
@d921 2
d928 5
a932 1
    if ((font == NULL) || (font[0] < ' '))
d1523 1
a1523 1
                    scrolllist_list[j] = scrolllist_list[j+i];
d1539 1
a1539 1
        			sizeof(PrivateScrollList) * (remaining + 1));
@


1.6
log
@  Removed unused files that were preventing build.
Detail:
  debug.s was still in the build and included a header which had been removed
  in a previous version.  The code in debug.s in not used anywhere, so I've
  just removed it (and the corresponding debug.h, which was empty anyway).
Admin:
  Compiled.

Version 0.25. Tagged as 'Gadgets-0_25'
@
text
@d56 1
a84 2
static _kernel_oserror bad_index = {0, "Bad index"};

a155 5
static _kernel_oserror *out_of_memory(void)
{
   return (_kernel_oserror *) "    Unable to allocate memory to store scrolllist gadget definition";
}

a164 2
    _kernel_oserror no_mem = {0, "Not enough memory"};

d168 1
a168 1
            return &no_mem;
d185 1
a185 1
            return &no_mem;
a197 1
    _kernel_oserror bad_scrolllist = {0, "No such scrolling list"};
d201 1
a201 1
        return &bad_scrolllist;
d209 1
a209 1
        return &bad_scrolllist;
d351 1
a351 1
    BBox		new;
d357 4
a360 4
    new.xmin = 0;
    new.xmax = 0xfff;
    new.ymin = -sdata->no_entries * entry_height;
    new.ymax = 0;
d363 1
a363 1
    if (new.ymin > limit) new.ymin = limit;
d365 1
a365 1
    window_set_extent(0, sdata->object_id, &new);
d466 1
a466 1
        return out_of_memory();
a559 1
        _kernel_oserror bad_col = {0, "Invalid desktop colour"};
d562 1
a562 1
            return &bad_col;
a578 1
    _kernel_oserror		no_mem = {0, "Not enough memory to add item"};
d588 1
a588 1
        return &no_mem;
d602 1
a602 1
            return &no_mem;
d620 1
a620 1
                return &no_mem;
d640 1
a640 1
            return &no_mem;
d650 1
a650 1
                return &no_mem;
d817 1
a817 1
        return &bad_index;
d926 1
a926 1
    if (font == NULL)
d990 1
a990 1
        return &bad_index;
a1011 1
    _kernel_oserror   no_mem = {0, "Not enough memory"};
d1018 1
a1018 1
        return &bad_index;
d1044 1
a1044 1
        return &no_mem;
@


1.5
log
@An unsigned int was involved in a signed comparison (no compiler warning?)
which led to empty lists contracting to zero height. Fixed.

Version 0.17. Tagged as 'Gadgets-0_17'
@
text
@a66 1
#include "debug.h"
@


1.4
log
@ScrollList changes.

Added scrolllist_set_item_text. Tweak to extent setting to account for
window border. _add_item fix ('>' should've read '>=' in index range
check). Can now tell _add_item to make the new item visible (flag
ScrollList_AddItem_MakeVisible), else it will try to maintain the y
scroll position. _delete_items continues to jump to the top as before,
but you can ask it to try and maintain the y scroll position too
(flag ScrollList_DeleteItems_DoNotJumpToTop).

Version 0.16. Tagged as 'Gadgets-0_16'
@
text
@d42 2
d362 1
a363 1
    unsigned int	limit;
@


1.3
log
@Various fixes and extensions to ScrollList, plus a related fix in TextArea
and ScrollBar.

Title background colour of gadgets was either undefined or set to 0; should
be 2. Corrected. Would be apparent with 2D tools or any transparent tool
sprite set.

SELECT clicks on deselected entries in a ScrollList now deselect any other
selected items before selecting the new one.

Embedded window of TextArea and ScrollList now put in the right place. At
create time, the sizes of the current tool sprite set is also checked; this
used to be hard coded. If the tool sizes and/or Desktop scaling changes at
run-time this won't be noticed yet, as no mechanism to pass Wimp messages
to *external* gadgets exists in the Toolbox currently. Still, at least it
gets it right the next time a new instance of the gadget is created.

Flag bit ScrollList_SelectionChangingMethod_SendEvent to any of
scrolllist_select_item, scrolllist_deselect_item or scrolllist_delete_items
prompts them to send ScrollList_Selection to the client on completion. This
can help simplify client UI code for UIs which depend on what is selected
(e.g. a "Select all" button greys out if all items are selected by a
keyboard shortcut - this can now all work on just the one event handler).

Flag bit ScrollList_SelectionChangingMethod_OnAll to either of
scrolllist_select_item or scrolllist_deselect_item tells the methods to
act like a "Select all" or "Clear selection" call. This is a common client
operation and it's a lot easier for the ScrollList gadget to do it than
have the client iterate over all items.

Supports new method ScrollList_CountItems (scrolllist_count_items veneer
present in tboxlibs 0.04 or later). Returns number of entries in gadget.
Avoids clumsy situation of both the gadget and the clienty keeping track
of how many entries are present.

Note that docs.ScrollList mis-documented some flags settings. Now fixed.

Version 0.15. Not tagged
@
text
@d33 9
d83 1
a83 1
static _kernel_oserror	bad_index = {0, "Bad index"};
d88 3
d361 1
a367 2
    if (new.ymin > (sdata->box.ymin - sdata->box.ymax))
        new.ymin = sdata->box.ymin - sdata->box.ymax;
d370 3
d587 3
a589 2
    _kernel_oserror	no_mem = {0, "Not enough memory to add item"};
    struct _entries	*new_list;
d602 1
a602 1
    if ((index < 0) || (index > sdata->no_entries) ||
d684 5
a688 1
    // Update window extent
d691 22
d744 2
a745 1
    unsigned int	i, j;
d782 6
a787 1
    // Update extent
d790 14
d1018 62
d1164 4
@


1.2
log
@* Merged in fixes from Daytona branch (tag sbrodie_Daytona_merge_19Jun98)

* Fixed 'long' #include directives.
* Removed duplicate function prototypes from TextGadget.h (use ModHdr.h
  for correct prototypes).
* Capability to build with pre- and post-5.16 versions of CMHG.
@
text
@d19 14
a32 3
 * piers    01/08/96 Created
 * piers    23/12/96 Added in MemCheck thingies
 * piers    06/01/97 Recoded to use a nested window so scrollbar is nicer
d55 1
d70 2
d109 1
a109 1
        0,			// title_bg
d364 3
a366 1
    WindowShowObjectBlock	show_block;
d370 12
a381 1
    show_block.visible_area.xmax -= SCROLLBAR_SIZE;
d673 1
a673 1
//    		sdata->box.xmax - SCROLLBAR_SIZE, sdata->box.ymax);
d679 21
d701 1
a701 1
				int start, int end)
d744 1
a744 1
//    		sdata->box.xmax - SCROLLBAR_SIZE, sdata->box.ymax);
d747 4
a750 1
    return NULL;
d756 1
d758 2
a759 2
static _kernel_oserror *_select_item(const PrivateScrollList *sdata, int index,
					unsigned int selected)
d763 1
d772 9
a780 1
    if (!(sdata->state & ScrollList_MultipleSelections))
a781 1
        // Deselect all
d784 2
d803 45
a847 6
    if (selected == SELECT_SELECT)
        sdata->entries[index].flags |= FLAGS_SELECTED;
    else if (selected == SELECT_DESELECT)
        sdata->entries[index].flags &= ~FLAGS_SELECTED;
    else // SELECT_TOGGLE
        sdata->entries[index].flags ^= FLAGS_SELECTED;
d849 1
a849 2
    box.ymin = -(index + 1) * item_height;
    box.ymax = -index * item_height;
d851 2
a852 1
    window_force_redraw(0, sdata->object_id, &box);
d854 5
a858 1
    return NULL;
d891 1
a891 1
    		sdata->box.xmax - SCROLLBAR_SIZE, sdata->box.ymax);
d1002 1
a1002 1
            e = _delete_items(sdata, regs->r[4], regs->r[5]);
d1006 1
a1006 1
            e = _select_item(sdata, regs->r[4], SELECT_SELECT);
d1010 1
a1010 1
            e = _select_item(sdata, regs->r[4], SELECT_DESELECT);
d1025 1
a1025 1
    		sdata->box.xmax - SCROLLBAR_SIZE, sdata->box.ymax);
d1043 4
d1123 1
a1123 1
    x = MAX(box.xmax - SCROLLBAR_SIZE, box.xmin);
d1256 2
a1257 1
    ScrollListSelectionEvent	event;
d1286 1
a1286 1
    event.item = -mouse_y / item_height;
d1292 1
a1292 1
            _select_item(sdata, event.item, SELECT_TOGGLE);
d1296 2
a1297 2
            if (!(sdata->entries[event.item].flags & FLAGS_SELECTED))
                _select_item(sdata, event.item, SELECT_SELECT);
d1304 1
a1304 1
    if (event.item >= sdata->no_entries)
d1307 1
a1307 5
    event.hdr.size = sizeof(ScrollListSelectionEvent);
    event.hdr.reference_number = 0;
    event.hdr.event_code = sdata->event;
    event.hdr.flags = 0;
    event.flags = 0;
d1312 1
a1312 1
        event.flags |= ScrollList_Selection_Flags_DoubleClick;
d1317 1
a1317 1
            event.flags |= ScrollList_Selection_Flags_AdjustClick;
d1320 1
a1320 4
    toolbox_raise_toolbox_event(0, sdata->parent_id, sdata->component_id,
    			(ToolboxEvent *) &event);

    return NULL;
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
#include "riscos_utils.h"
d40 1
a40 1
#include "TextGadgets.h"
d45 1
a45 1
#include "myswis.h"
d128 2
d240 6
a245 1
    if (!font_handle)
d247 1
d315 1
a315 1
    
d317 1
a317 1
    
d326 1
a326 1
        
d412 10
d510 1
d626 1
a626 1
        for (i = sdata->no_entries; i >= index; i--)
d711 1
a711 1
    
d723 1
a723 1
        
d728 1
a728 1
                
d735 1
a735 1
 
d740 1
a740 1
    
d747 1
a747 1
    
d796 1
a796 1
    
d805 1
a805 1
    
d807 20
a826 1
    
d835 1
a835 1
    
d841 1
a841 1
    
d843 1
a843 1
    
d845 1
a845 1
    
d848 1
a848 1
    
d913 1
a913 6
            if (regs->r[4] < 0)
                sdata->visible = 0;
            else
                sdata->visible = regs->r[4];
            scrolllist_update(sdata, sdata->box.xmin, sdata->box.ymin,
    		sdata->box.xmax - SCROLLBAR_SIZE, sdata->box.ymax);
d951 1
a951 1
_kernel_oserror *scrolllist_fade(int *handle, int fade)
a955 1
    IGNORE(handle);
d958 5
d1060 1
a1060 1
            if (sprite_info != 3)
d1078 1
a1078 1
                if (sprite_info == 3)
d1089 4
a1092 1
            
d1096 1
a1096 1
        
d1108 3
d1122 2
a1123 2
            		-1, -1, block->visible_area.xmin + sprite_width +12,
            		y - base_line);
d1149 1
a1149 1
    
d1177 1
a1177 1
    
d1190 5
a1194 4
    
    // Send event
    
    if (event.item > sdata->no_entries)
d1196 1
a1196 1
        
d1202 1
a1202 1
    
d1209 5
d1270 1
a1270 2
                // Claim event, since we don't want the application to know
                // what's going on?
@


1.1.1.1
log
@The Java directory contains the sources for the Java support modules
(TextGadget, etc.) and the makefiles to complete the Java ROM build
under RiscOS.

@
text
@@


1.1.1.2
log
@Added a delete toolbox object call...
@
text
@a491 1
    toolbox_delete_object(0, handle->object_id);
@


1.1.1.3
log
@Added shading to ScrollLists, and changed look of textareas if built with -DDAYTONA_BUILD
@
text
@a127 2
static BBox redraw_all_box = {0, -0xffff, 0xffff, 0};

d307 1
a307 1

d309 1
a309 1

d318 1
a318 1

d693 1
a693 1

d705 1
a705 1

d710 1
a710 1

d717 1
a717 1

d722 1
a722 1

d729 1
a729 1

d778 1
a778 1

d787 1
a787 1

d789 1
a789 1

d798 1
a798 1

d804 1
a804 1

d806 1
a806 1

d808 1
a808 1

d811 1
a811 1

d919 1
a919 1
_kernel_oserror *scrolllist_fade(PrivateScrollList *sdata, int fade)
d924 1
a926 5
    sdata->state &= ~Gadget_Faded;
    sdata->state |= fade ? Gadget_Faded : 0;

    window_force_redraw(0, sdata->object_id, &redraw_all_box);

d1053 1
a1053 4

                if (sdata->state & Gadget_Faded)
                    icon.flags |= WimpIcon_Shaded;

d1057 1
a1057 1

a1068 3
        if (sdata->state & Gadget_Faded)
            foreground = foreground & 0xfdfdfd00;

d1107 1
a1107 1

d1135 1
a1135 1

d1148 1
a1148 1

d1150 1
a1150 1

d1153 1
a1153 1

d1159 1
a1159 1

@


1.1.1.4
log
@Fixed a couple of data aborts, made all gadgets not quit if tasks are
still using them and freed all memory when they do quit.
@
text
@a405 10
int scrolllist_active(void)
{
    return scrolllist_list != NULL;
}

_kernel_oserror *scrolllist_die(void)
{
    return NULL;
}

@


1.1.1.5
log
@Added scrollbar dragging
@
text
@d620 1
a620 1
        for (i = sdata->no_entries; i > index; i--)
a804 19
static _kernel_oserror *_make_visible(const PrivateScrollList *sdata,
			int visible)
{
    unsigned int		item_height;
    WimpGetWindowStateBlock	block;

    _get_item_size(sdata, NULL, &item_height, NULL);

    window_get_wimp_handle(0, sdata->object_id, &block.window_handle);

    wimp_get_window_state(&block);

    block.yscroll = -visible * item_height;

    wimp_open_window((WimpOpenWindowBlock *) &block);

    return NULL;
}

d888 6
a893 1
            _make_visible(sdata, regs->r[4] < 0 ? 0 : regs->r[4]);
d1040 1
a1040 1
            if (sprite_info != (FLAGS_SPRITE_AREA | FLAGS_SPRITE_NAME))
d1058 1
a1058 1
                if (sprite_info == 2)
d1244 2
a1245 1
                // Claim event
@


1.1.1.6
log
@* Event generation for ScrollList fixed - you no longer get spurious events
  for a phantom extra item on the list.
* Flag added to ScrollList_Selection event to indicate adjust click.
* Fixed un-initialised base_line variable causing text of ScrollList
  items to disappear when the desktop font was the System font.

Version 0.10, 1.1.2.2. Tagged as 'Gadgets-0_10-1_1_2_2'
@
text
@d240 1
a240 6
    if (!font_handle) {
        // bug fix.  SNB - 19980618: Must zero base_line otherwise when desktop font
        // is the system font, all the text disappears because base_line remains
        // uninitialised.
        if (base_line)
            *base_line = 0;
a241 1
    }
d1116 2
a1117 2
       	    		-1, -1, block->visible_area.xmin + sprite_width +12,
       			y - base_line);
d1185 1
a1185 2
    // Send event -
    /* SNB: 19980518: changed condition to >= to stop "extra item" events. */
d1187 1
a1187 1
    if (event.item >= sdata->no_entries)
a1199 5
    }

    /* SNB: 19980618: added flagging of adjust clicks */
    if (click->buttons & (1 | 256)) {
            event.flags |= ScrollList_Selection_Flags_AdjustClick;
@


1.1.1.4.2.1
log
@Made a single, unified Makefile.  myswis.h renamed to ModHdr.h so that it can be
automatically generated by CMHG.  Changed DAYTONA_BUILD flag to Daytona_BUILD so
that it can be automatically defined in the Makefile using the build
environment's System variable (called ${SYSTEM} in Makefiles).
@
text
@d45 1
a45 1
#include "ModHdr.h"
@

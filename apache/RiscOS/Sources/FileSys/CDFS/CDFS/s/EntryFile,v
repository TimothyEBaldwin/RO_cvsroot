head	4.10;
access;
symbols
	CDFS-2_63:4.10
	CDFS-2_62:4.9
	CDFS-2_61:4.9
	CDFS-2_60:4.8
	CDFS-2_59:4.7
	CDFS-2_58:4.7
	CDFS-2_57:4.7
	CDFS-2_56:4.7
	CDFS-2_55:4.6
	CDFS-2_54:4.6
	CDFS-2_53:4.5
	CDFS-2_52:4.3
	CDFS-2_51:4.3
	CDFS-2_50:4.3
	CDFS-2_49:4.3
	CDFS-2_48:4.3
	RO_5_07:4.3
	CDFS-2_47:4.3
	CDFS-2_46:4.3
	CDFS-2_45:4.3
	CDFS-2_44:4.3
	CDFS-2_43:4.3
	CDFS-2_42:4.3
	CDFS-2_41:4.3
	CDFS-2_40:4.3
	CDFS-2_39:4.3
	CDFS-2_38:4.3
	CDFS-2_37:4.2
	CDFS-2_35:4.2
	CDFS-2_30:4.1
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	nturton_CDFS-2_29:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_CDFS_2_28:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2016.05.08.16.52.45;	author jlee;	state Exp;
branches;
next	4.9;
commitid	rsdrFYAPguHCrH5z;

4.9
date	2013.08.15.14.25.03;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	5ab0m7C1cVfMFy1x;

4.8
date	2013.08.15.14.13.05;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	6zDw3cu1Q3LIBy1x;

4.7
date	2012.04.22.15.48.27;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	bybtPibvH0K2zS1w;

4.6
date	2012.04.22.11.09.01;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	MNiwWuPGZIIb1R1w;

4.5
date	2012.04.21.21.56.37;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	LsBEkd8YV89lDM1w;

4.4
date	2012.04.16.21.42.01;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	E6l0nP00WOBxH81w;

4.3
date	2002.11.04.21.21.42;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2002.11.01.19.47.49;	author bavison;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.51;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.51;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.52.42;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.31.44;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.28.04;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Avoid unnecessary remainder calculations
Detail:
  s/EntryFile, s/FileMan, s/Misc - Avoid unnecessary remainder calculation in DivRem macro
Admin:
  Tested on Cortex-A15


Version 2.63. Tagged as 'CDFS-2_63'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; ->EntryFile

;*************************************************************************
;*************************************************************************

; This part deals with the FSEntry_File part of FileSwitch

; It contains:

;             LoadFile
;             ReadCatalogue
;             SaveFile       - is now in 'Error'
;             ReadBlockSize  - RISC OS 3

;*************************************************************************
;*************************************************************************

;*************************************************************************
LoadFile
;*************************************************************************

; on entry:
; R0 = 255
; R1 -> pointer to pathname
; R2 = address to load file
; R6 -> pointer to special field if present

; on exit:
; R0 is corrupted
; R2 = load address
; R3 = execution address
; R4 = file length
; R5 = file attributes
; R6 = pointer to name for printing *OPT 1 info


; R9 -> disc buffer



        Push    "R2"

        MOV     R0, R1

;*************************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
        MOV     R1, #0                  ; Looking for a file
        BL      Dir                     
;*************************

        MOV     r8, r4
        
        MOV     r9, r3
        
        Pull    "r2"
        
        STR     r1, temp2               ; R1 -> entry details



;------------------------------------
; Added in version 2.23 30-Aug-94
; Read mode 2 form 2 files properly
;------------------------------------

; r1 -> Object information
; r3 =  mode of disc

        MACRO__XA_WHAT_DATA_MODE r0, r1, r2, r3
                
        TEQ     r0, # 2
        BNE     LoadFile_Ordinary


;***************
; Work out actual lba start offset - for different size logical blocks
;***************

; R3 = start LBA
; R5 = block size

        LDR     r5, [ r1, # LBASTARTOFFSET ]
        MOV     r5, r5, LSR #8          ; remove objecttype rubbish
                
        STR     r5, temp1               ; temp1 = Start LBA
                
        MOV     r6, r2                  ; R6 -> start of load address
                
        LDR     r2, [ r1, # LENGTHOFFSET ]
                
        MOV     r0, r8
        BL      PreConvertDriveNumberToDeviceID
        BVS     ErrorExit
                
        MOV     r0, # 2
        BL      ChangeDiscMode          ; R0 = mode, R7 -> control block

; XCD_ReadUserData
; on entry:
;          r0 =  LBAFormat (0)
;          r1 =  block
;          r2 =  length in bytes
;          r3 -> memory
;          r7 -> control block

        CLRV
                
        MOV     r0, #LBAFormat
        MOV     r1, r5
        MOV     r3, r6
                
        CMP     r2, # 0
        SWIGT   XCD_ReadUserData
                
        BVS     ErrorExit

        ; exit neatly

02

        PullAllFromFrame
        LDR     r6, temp2
        
        LDMIB   r6, { r2, r3, r4 }
        
        LDRB    r5, [ r6, # FILEATTRIBUTESOFFSET ]
        
        ADD     r6, r6, # OBJECTNAMEOFFSET
        
        MOV     pc, r14 ; V still clear





;-----------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------
LoadFile_Ordinary

        LDR     R4, [ R1, #LENGTHOFFSET ]

        MOV     R5, #myblocksize
        DivRem  R7, R4, R5, R14, norem  ; r7 = r4 DIV r5


;***************
; Work out actual lba start offset - for different size logical blocks
;***************

; R3 = start LBA
; R5 = block size

        MOV     R4, #myblocksize
                
        LDR     R5, [ R9, #DiscBuff_BlockSize ]
                
        DivRem  R6, R4, R5, R14, norem  ; R6 = log. sec size / lbsize
                
        LDR     R5, [ R1, #LBASTARTOFFSET ]
        MOV     R5, R5, LSR #8          ; remove objecttype rubbish
                
;------------------------------------------------------
; Make sure that don't try to divide by 0 or locks up !
;------------------------------------------------------

        TEQ     r6, #0

        MOVEQ   r0, #ERROR_INTERNALERROR
        BEQ     ErrorExit

;------------------------------------------------------


        DivRem  R3, R5, R6, R14, norem  ; R3 = start LBA / R6
        
        STR     R3, temp1               ; temp1 = STart LBA
                
        MOV     R6, R2                  ; R6 -> start of load address
                
        MOV     R2, R7                  ; Load less than or equal number of blocks


; number_of_bytes - ( ( number_of_bytes DIV blocksize ) * blocksize )

; ( ABOVE function ) this gives the number of bytes left in the last block

        MOV     R0, R8
        BL      PreConvertDriveNumberToDeviceID
        BVS     ErrorExit
                
        LDRB    R0, [ R9, #DiscBuff_DiscMode ]
        BL      ChangeDiscMode          ; R0 = mode, R7 -> control block


        MOV     R0, #LBAFormat
        MOV     R1, R3
        MOV     R3, R6
                
        MOV     R4, #myblocksize
                
        CMP     R2, #0
        SWIGT   XCD_ReadData

        BVS     ErrorExit

; Load in the remaining bytes from the last block

                                 ; R2 = NUMBER_OF_BYTES DIV BLOCKSIZE

; LDR R1, [ R9, #DiscBuff_BlockSize ]
        MOV     R1, #myblocksize
                
        MUL     R3, R1, R2              ; R3 = number of bytes loaded so far
                
                
        LDR     R14, temp2
        LDR     R4, [ R14, #LENGTHOFFSET ] ; R4 = number_of_bytes
                
        SUBS    R4, R4, R3              ; No more bytes to load ?
                                        ;
        BLE     %FT02                   ; [ all done ]


                      ; Load last block into temp buffer

                      ; then transfer correct number of bytes to their mem

 ; WORK OUT POSITION TO PUT BYTES AT

 ; R6 = start address of load

 ; R4 = number of bytes left to load

 ; R3 = number of bytes loaded so far

 ; R2 = number of blocks loaded so far



                               ; = position to dump rest of data


                               ; R3 = position to copy to


        ADD     R3, R3, R6
                
        LDR     R1, temp1               ; start LBA +
        ADD     R1, R1, R2              ; number of blocks = last block
                
        MOV     R0, #LBAFormat
                
        MOV     R2, #1

 ;   OK       WRONG       OK      OK           WRONG
 ; R0 = 0, R1 = block, R2 = 1, R3 -> place, R4 = number bytes


        SWI     XCD_ReadData
                
        BVS     ErrorExit

                           ; exit neatly

02

        PullAllFromFrame
        LDR     R6, temp2
        LDMIB   R6, { R2, R3, R4 }
                
        LDRB    R5, [ R6, #FILEATTRIBUTESOFFSET ]
                
        ADDS    R6, R6, #OBJECTNAMEOFFSET ; should clear V
                
        MOV     PC, R14



;*************************************************************************
ReadCatalogue ROUT
;*************************************************************************

; entry: R0 = 5
;        R1 = pointer to pathname ( null terminated )
;        R6 = pointer to special field if present, else 0

; exit:  R0 = 0 if not found, 1 if file, 2 if directory
;        R2 = load address
;        R3 = execution address
;        R4 = file length
;        R5 = file attributes

        log_on

        MOV     R0, R1


;***********************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
        MOV     R1, #2    ; Don't care what I find
        BL      Dir
;***********************


;************
; Object not found ( so tell fileswitch )
;************

        TEQ     R2, #object_nothing     ; If not found then tell FS
        PullAllFromFrame EQ             ;
        SUBEQS  R0, R0, R0              ; clears V
        MOVEQ   PC, R14                 ;

;************
; Was object a directory ? ( so get information from 'TempArea' )
;************

        TEQ     R2, #object_directory
        ADREQ   R1, TempArea
        STREQB  R2, [ R1, #OBJECTTYPEOFFSET ]

;************
; Save pointer to block of information
;************

02

        STR     R1, temp1
        PullAllFromFrame
        LDR     R1, temp1

;************
; Tell fileswitch about object
;************

        LDRB    R0, [ R1, #OBJECTTYPEOFFSET ]
        ASSERT  LOADADDRESS + 4 = EXECUTIONADDRESS
        ASSERT  EXECUTIONADDRESS + 4 = LENGTH
        LDMIB   R1, { R2, R3, R4 }
        LDRB    R5, [ R1, #FILEATTRIBUTESOFFSET ]

        CLRV
        MOV     PC, R14




;**********************************************************************************************
; FUNCTION: ReadBlockSize
;
; on entry:
;          r0 =  10
;          r1 -> filename
;          r6 -> special field, or 0
; on exit:
;          r2 = natural block size of file
;
; see page 4-30 of RISC OS 3 PRMs
;**********************************************************************************************
ReadBlockSize

; Just make sure that the file exists, if it does then the natural size is 2048 bytes.
        MOV     r0, r1
        MOV     r1, #0
        BL      Dir
        PullAllFromFrame
        MOV     r2, #2048
        CLRV
        MOV     pc, r14


;**********************************************************************************************


        LTORG

        END

@


4.9
log
@Add support for Joliet format CD-ROMs
hdr/Hashes
s/Directory
s/EntryFile
s/FileMan
s/Filer
s/Free
 - mass search and replace of lots of poorly named definitions, removing unused ones, creating implicit ones
hdr/MyMacros
 - shuffle some registers in ConvertToArchyDate to save one temporary so it can be used for something else
 - moved ReplaceBadCharacters here
hdr/Options
 - extra debug option
s/DiscOp
 - add Joliet, rename buffer indicies per hdr/Hashes
 - the fallback filetype assignment (when neither the ARCHIMEDES system extension nor MimeMap can help) can now be overridden by setting CDFS$DefaultType (which defaults to &FFD)
s/SWI
 - remove DAT<->MPEG mapping from the internal mapping table
s/Variables
 - trim out unused SWI_buffer reservation

Tested with valid ISO/Joliet/RockRidge supported combinations, documented in Docs/Combos, and accompanying test ISO images now stored there.
Tested with CD-I format disc 'Jigsaw' from Britannica.
Tested with High Sierra format disc 'Kings Quest V'.
Tested with photo CD sampler from Kodak.

Version 2.61. Tagged as 'CDFS-2_61'
@
text
@d160 1
a160 1
        DivRem  R7, R4, R5, R14         ; r7 = r4 DIV r5
d174 1
a174 1
        DivRem  R6, R4, R5, R14         ; R6 = log. sec size / lbsize
d191 1
a191 1
        DivRem  R3, R5, R6, R14         ; R3 = start LBA / R6
@


4.8
log
@Various CDFS enhancements
* Increase BGET/BPUT buffer declared to FileSwitch to 2k to match the natural sector size (FileSwitch has been able to support this since version 2.28)
* Remove local debug macros, use those from NDRDebug instead
* Change to use SETV/CLRV macros now the ones in HdrSrc are 26/32 neutral
* Clarify those situations where LBA mode is being selected by using symbol 'LBAFormat'
* Extend *WHICHDISC to allow an optional drive number to be provided (the code has existed for years, but the GSTrans flags and help denied its use)

Version 2.60. Tagged as 'CDFS-2_60'
@
text
@d172 1
a172 1
        LDR     R5, [ R9, #BLOCKSIZEOFFSETINABUFFER ]
d208 1
a208 1
        LDRB    R0, [ R9, #DISCMODEOFFSETINABUFFER ]
d227 1
a227 1
; LDR R1, [ R9, #BLOCKSIZEOFFSETINABUFFER ]
@


4.7
log
@Fix a few bugs
When lining up the code in 2.52, a few bugs became apparent (now the source was readable).
* In a handful of places it was assumed SWIs preserved flags, these have been reordered or branched around.
* The probe of UtilityModule 2.12 has been set to 3.00 and the logic now considers >= 3.00 rather than subtracting 1 from it to deduce the default filename truncation value.
* Removed support for supplemental filetype table in CDFSNewFileTypePath$File as this has been superceded by the MimeMap module (which CDFS uses). This mirrors the behaviour of DOSFS and LanManFS which consult the MimeMap first then (small) internal table second.
* Fix stack imbalance when reading the current setting with CDFS_Truncation leading to an abort

Other changes
* When the MimeMap module is absent ".doc" is taken to be a MS Word document.
* Changed the manual loads from :INDEX: of R12 to be ADR's or ADRL's so there's less literal pool thrashing.
* Three Push/Pull sequences to restore registers swapped for LDMIA's (in Directory.s).
* Reason codes to OS_ SWIs swapped for header file names.


Version 2.56. Tagged as 'CDFS-2_56'
@
text
@d123 1
a123 1
        VCLEAR
d125 1
a125 1
        MOV     r0, # LBAFormat
d212 1
a212 1
        MOV     R0, #0
d268 1
a268 1
        MOV     R0, #0
d362 1
a362 1
        VCLEAR
d388 1
a388 1
        VCLEAR
@


4.6
log
@Exchange local definitions for central ones.
Hdr:HighFSI LowFSI Services CDROM CMOS UpCall and CDFS now used in preference to local definitions.
Macro 'Command' used to build the keyword table.
Some asserts added for safety.


Version 2.54. Tagged as 'CDFS-2_54'
@
text
@a203 1
; ADD R7, R12, #INDEX:sparecontrolblock
d339 1
a339 1
        ADDEQ   R1, R12, #:INDEX:TempArea
@


4.5
log
@Resolve the 32 assembler warnings
Mostly by swapping STASH/GRAB for Push/Pull macros.
Inlined the module header rather than defining it in a header file.
Renamed "Debug" macro to "DebugInline" to avoid clash with similarly named macro.

Version 2.53. Tagged as 'CDFS-2_53'
@
text
@d330 1
a330 1
        TEQ     R2, #NOTFOUND           ; If not found then tell FS
d339 1
a339 1
        TEQ     R2, #DIRECTORY
@


4.4
log
@Line up sources to normal columns.
Around 25000 spaces required, but rather easier to read as a result - it has revealed some bugs (not addressed in this commit).
Not quite binary identical, because an 'addr' of the ambiguous disc name error has moved by 1 byte due to a missing ALIGN directive.
Not tagged.
@
text
@d55 1
a55 2
        STASH   R2

d72 1
a72 1
        GRAB    r2
d138 1
a138 1
        GRABALL
d285 1
a285 1
        GRABALL
d331 1
a331 1
        GRABALL EQ                      ;
d350 1
a350 1
        GRABALL
d387 1
a387 1
        GRABALL
@


4.3
log
@  Lots of changes for RISC OS 5.
Detail:
  * Updated to use objasm, shared makefiles and global headers
  * Ripped out lots of RISC OS 2 support code so we can see the wood for the
    trees now
  * 32-bit compatible (a bit of a slog)
  * Now has its own resources phase, replacing the use of the CDFSResources
    module. Also means that messages can now be tokenised properly. For
    good measure, split out CmdHelp tokens into separate file
  * Hopefully fixed more bugs along the way than I introduced. I've seen
    lots of nasty stack imbalances in error cases, but not fixed all of
    them, I'm afraid
Admin:
  Tested briefly on a Risc PC; not enough support modules to run on Tungsten
  yet.

Version 2.38. Tagged as 'CDFS-2_38'
@
text
@d55 1
a55 1
 STASH R2
d58 1
a58 1
 MOV R0, R1
d65 2
a66 2
 MOV R1, #0 ; Looking for a file
 BL Dir
d69 7
a75 7
 MOV        r8, r4

 MOV        r9, r3

 GRAB       r2

 STR        r1, temp2                        ; R1 -> entry details
d87 4
a90 4
 MACRO__XA_WHAT_DATA_MODE r0, r1, r2, r3

 TEQ        r0, # 2
 BNE        LoadFile_Ordinary
d100 15
a114 16
 LDR        r5, [ r1, # LBASTARTOFFSET ]
 MOV        r5, r5, LSR #8               ; remove objecttype rubbish

 STR        r5, temp1                    ; temp1 = Start LBA

 MOV        r6, r2                       ; R6 -> start of load address

 LDR        r2, [ r1, # LENGTHOFFSET ]

 MOV        r0, r8
 BL         PreConvertDriveNumberToDeviceID
 BVS        ErrorExit

; LDRB       r0, [ r9, # DISCMODEOFFSETINABUFFER ]
 MOV        r0, # 2
 BL         ChangeDiscMode         ; R0 = mode, R7 -> control block
d124 10
a133 8
 VCLEAR

 MOV      r0, # LBAFormat
 MOV      r1, r5
 MOV      r3, r6

 CMP      r2, # 0
 SWIGT    XCD_ReadUserData
d135 1
a135 3
 BVS      ErrorExit

                           ; exit neatly
d139 10
a148 10
 GRABALL
 LDR      r6, temp2

 LDMIB    r6, { r2, r3, r4 }

 LDRB     r5, [ r6, # FILEATTRIBUTESOFFSET ]

 ADD      r6, r6, # OBJECTNAMEOFFSET

 MOV      pc, r14 ; V still clear
d158 1
a158 1
 LDR R4, [ R1, #LENGTHOFFSET ]
d160 2
a161 2
 MOV R5, #myblocksize
 DivRem R7, R4, R5, R14      ; r7 = r4 DIV r5
d171 9
a179 9
 MOV R4, #myblocksize

 LDR R5, [ R9, #BLOCKSIZEOFFSETINABUFFER ]

 DivRem R6, R4, R5, R14           ; R6 = log. sec size / lbsize

 LDR R5, [ R1, #LBASTARTOFFSET ]
 MOV R5, R5, LSR #8               ; remove objecttype rubbish

d184 1
a184 1
 TEQ        r6, #0
d186 2
a187 2
            MOVEQ       r0, #ERROR_INTERNALERROR
            BEQ         ErrorExit
d192 7
a198 7
 DivRem R3, R5, R6, R14           ; R3 = start LBA / R6

 STR R3, temp1                    ; temp1 = STart LBA

 MOV R6, R2                       ; R6 -> start of load address

 MOV R2, R7                 ; Load less than or equal number of blocks
d206 16
a221 11
 MOV R0, R8
 BL PreConvertDriveNumberToDeviceID
 BVS ErrorExit

 LDRB R0, [ R9, #DISCMODEOFFSETINABUFFER ]
 BL ChangeDiscMode         ; R0 = mode, R7 -> control block


 MOV R0, #0
 MOV R1, R3
 MOV R3, R6
d223 1
a223 6
 MOV R4, #myblocksize

 CMP R2, #0
 SWIGT XCD_ReadData

 BVS ErrorExit
d230 11
a240 11
 MOV R1, #myblocksize

 MUL R3, R1, R2                  ; R3 = number of bytes loaded so far


 LDR R14, temp2
 LDR R4, [ R14, #LENGTHOFFSET ]   ; R4 = number_of_bytes

 SUBS R4, R4, R3                 ; No more bytes to load ?
                                 ;
 BLE %FT02                       ; [ all done ]
d265 8
a272 8
 ADD R3, R3, R6

 LDR R1, temp1                 ; start LBA +
 ADD R1, R1, R2                ; number of blocks = last block

 MOV R0, #0

 MOV R2, #1
d278 3
a280 3
 SWI XCD_ReadData

 BVS ErrorExit
d286 9
a294 9
 GRABALL
 LDR R6, temp2
 LDMIB R6, { R2, R3, R4 }

 LDRB R5, [ R6, #FILEATTRIBUTESOFFSET ]

 ADDS R6, R6, #OBJECTNAMEOFFSET ; should clear V

 MOV PC, R14
a310 4
 log_on


;********************
d312 1
d314 1
a314 1
 MOV R0, R1
d322 2
a323 2
 MOV R1, #2    ; Don't care what I find
 BL Dir
d331 4
a334 4
 TEQ R2, #NOTFOUND              ; If not found then tell FS
 GRABALL EQ                     ;
 SUBEQS R0, R0, R0              ; clears V
 MOVEQ PC, R14                  ;
d340 3
a342 3
 TEQ R2, #DIRECTORY
 ADDEQ R1, R12, #:INDEX:TempArea
 STREQB R2, [ R1, #OBJECTTYPEOFFSET ]
d350 3
a352 3
 STR R1, temp1
 GRABALL
 LDR R1, temp1
d358 5
a362 6
 LDRB R0, [ R1, #OBJECTTYPEOFFSET ]
; LDR R2, [ R1, #LOADADDRESSOFFSET ]
; LDR R3, [ R1, #EXECUTIONADDRESSOFFSET ]
; LDR R4, [ R1, #LENGTHOFFSET ]
 LDMIB R1, { R2, R3, R4 }
 LDRB R5, [ R1, #FILEATTRIBUTESOFFSET ]
d364 2
a365 2
 VCLEAR
 MOV PC, R14
d385 7
a391 7
       MOV       r0, r1
       MOV       r1, #0
       BL        Dir
       GRABALL
       MOV       r2, #2048
       VCLEAR
       MOV       pc, r14
d397 1
a397 1
 LTORG
d399 1
a399 1
 END
@


4.2
log
@This is a manual merge of CDFS 2.35 from RiscOS/UnU/OS_Core/CDFS/CDFS234
treating nturton_CDFS-2_29 as the branch point.
@
text
@a57 16
 [ RISC_OS = 2
;********************
; Find out if CDFSFiler requested spritedata (A540)
;********************

 addr R0, SpriteDataPathName

 MOV R2, #?SpriteDataPathName

 BL CompareStrings     ; returns 'eq' or 'ne'

 BEQ %FT03
 ]



d111 1
a111 1
 BVS        Error
d125 1
a125 1
 CLV
d134 1
a134 1
 BVS      Error
d149 1
a149 1
 BICS     pc, r14, # Overflow_Flag
a186 4
 [ RISC_OS=2
 ADREQL     r0, InternalError
 BEQ        Error
 |
d188 2
a189 2
            BEQ         Error
 ]
d209 1
a209 1
 BVS Error
d224 1
a224 1
 BVS Error
d262 1
a262 1
              
d268 1
a268 1
 LDR R1, temp1                 ; start LBA + 
d281 1
a281 1
 BVS Error
d293 1
a293 40
 ADD R6, R6, #OBJECTNAMEOFFSET

 BICS PC, R14, #Overflow_Flag  ; explicitly Clear the overflow flag




 [ RISC_OS = 2

;------ Someone wanted to load the sprite for the filer

03

; R0 = 255
; R1 -> pointer to pathname
; R2 = address to load file
; R6 -> pointer to special field if present

 GRAB R2

 ADRL R1,StartOfSpriteData
 LDR R3, spritelength
 BL CopyMemory

; R2=load address
; R3=execution address
; R4=length
; R5=file attributes
; R6=full file name

 GRABALL

 ADR R2, spriteloadaddress
 LDMIA R2, { R2, R3, R4 }
 MOV R5, #RLRL
 MOV R6, R1

 BICS PC, R14, #Overflow_Flag

 ]
d295 1
a314 15
 [ RISC_OS = 2
;********************
; Find out if CDFSFiler requested spritedata
;********************

 addr R0, SpriteDataPathName

 MOV R2, #?SpriteDataPathName

 BL CompareStrings     ; returns 'eq' or 'ne'

 ADREQ R1, FalseSpriteData
 BEQ %FT02
 ]

d337 2
a338 2
 MOVEQ R0, #0                   ;
 BICEQS PC, R14, #Overflow_Flag ;
d369 2
a370 11
 BICS PC, R14, #Overflow_Flag   ; Explicitly clear the overflow flag




 [ RISC_OS = 2
;**************
; This structure is built in the same way as a file.
;**************

FalseSpriteData
a371 10
 DCD FILE                      ; object type = FILE
spriteloadaddress
 DCD SPRITELOADADDRESS         ; load address
spriteexecuteaddress
 DCD SPRITEEXECUTIONADDRESS    ; execution address
spritelength
 DCD EndOfSpriteData - StartOfSpriteData ; Length
 DCD 0
 DCB 0
 DCB RLRL
a372 1
 ALIGN
a373 1
 ]
a374 1
 [ RISC_OS > 2
d395 2
a396 1
       BICS      pc, r14, #Overflow_Flag
a397 1
 ]
@


4.1
log
@Initial revision
@
text
@d27 1
a52 1
 log_on
a53 1
 Debug " Load "
d57 1
a71 2
;********************

d85 30
a114 1
 MOV R8, R4
d116 2
a117 3
; TEQ R2, #FILE
; ADRNEL R0, NotFound
; BNE Error
d119 1
a119 1
 MOV R9, R3
d121 34
a154 1
 GRAB R2
d156 2
a157 3
;**************
; Find file name in path ( last leaf )
;**************
d159 1
d161 1
a161 1
; MOV R3, R0    ; R3 -> last '.'
d163 1
a163 1
;01
d165 1
a165 5
; LDRB R14, [ R0 ], #1
; TEQ R14, #"."
; MOVEQ R3, R0
; TEQ R14, #0
; BNE %BT01
a167 1
; MOV R0, R3
a168 1
;**************
a169 1
; STR R0, temp3                        ; temp3 -> file name
d171 3
a173 1
 STR R1, temp2                        ; R1 -> entry details
a308 4
; LDR R2, [ R6, #LOADADDRESSOFFSET ]
; LDR R3, [ R6, #EXECUTIONADDRESSOFFSET ]
; LDR R4, [ R6, #LENGTHOFFSET ]

a312 1
; LDR R6, temp3
a330 2
 Debug " Give filesprite "

a333 1
; LDR R3,=EndOfSpriteData-StartOfSpriteData
a344 3
; LDR R2, spriteloadaddress
; LDR R3, spriteexecuteaddress
; LDR R4, spritelength
d355 2
a371 2
 Debug " Find the file "

d393 1
a393 1
 Debug " Before DIR "
a402 1
 Debug " After DIR "
a415 2

 Debug " FOUND "
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

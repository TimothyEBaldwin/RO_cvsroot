head	4.18;
access;
symbols
	CDFS-2_63:4.18
	CDFS-2_62:4.18
	CDFS-2_61:4.18
	CDFS-2_60:4.16
	CDFS-2_59:4.15
	CDFS-2_58:4.15
	CDFS-2_57:4.15
	CDFS-2_56:4.15
	CDFS-2_55:4.14
	CDFS-2_54:4.13
	CDFS-2_53:4.11
	CDFS-2_52:4.9
	CDFS-2_51:4.8
	CDFS-2_50:4.8
	CDFS-2_49:4.8
	CDFS-2_48:4.7
	RO_5_07:4.7
	CDFS-2_47:4.7
	CDFS-2_46:4.6
	CDFS-2_45:4.6
	CDFS-2_44:4.5
	CDFS-2_43:4.5
	CDFS-2_42:4.5
	CDFS-2_41:4.5
	CDFS-2_40:4.4
	CDFS-2_39:4.4
	CDFS-2_38:4.4
	CDFS-2_37:4.3
	CDFS-2_35:4.2
	CDFS-2_30:4.2
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	nturton_CDFS-2_29:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_CDFS_2_28:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.18
date	2015.01.16.00.25.35;	author jlee;	state Exp;
branches;
next	4.17;
commitid	3pG90B9w2VrAlb6y;

4.17
date	2013.08.15.14.25.03;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	5ab0m7C1cVfMFy1x;

4.16
date	2013.08.15.14.13.05;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	6zDw3cu1Q3LIBy1x;

4.15
date	2012.04.22.15.48.27;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	bybtPibvH0K2zS1w;

4.14
date	2012.04.22.11.13.13;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	FhAGZUD5Y3dD2R1w;

4.13
date	2012.04.22.11.09.02;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	MNiwWuPGZIIb1R1w;

4.12
date	2012.04.22.11.04.31;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	6PVuneYjhUEDZQ1w;

4.11
date	2012.04.21.21.56.37;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	LsBEkd8YV89lDM1w;

4.10
date	2012.04.16.21.42.01;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	E6l0nP00WOBxH81w;

4.9
date	2012.04.14.20.12.38;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	7fHfwG83pDVChS0w;

4.8
date	2009.05.17.02.56.32;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2003.01.08.11.38.14;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2002.11.26.17.24.30;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.22.15.05.40;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.04.21.21.42;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.01.20.15.29;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2000.11.30.11.44.22;	author jberanek;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.52;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.52;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.53.43;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.31.50;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.28.09;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.18
log
@Escape some dollars
Detail:
  s/DiscOp, s/Main - Escape some dollars contained in strings to avoid warnings from objasm
Admin:
  Resulting binary unchanged


Version 2.61. Retagged as 'CDFS-2_61'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; -> CDFS module

;*****************************************************************
;                   Procedures in this file
;*****************************************************************

; initialisingcode     ; Start up as a filing system
; finalisingcode       ; Kill filing system and claimed RMA space
; servicecode          ; Service call handler
; registerFS           ; Register module as a filing system
; InformationBlock     ; Block used by FileSwitch

;*****************************************************************
;                       Include other files
;*****************************************************************

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:MsgTrans
        GET     Hdr:ModHand
        GET     Hdr:Free
        GET     Hdr:FSNumbers
        GET     Hdr:FileTypes
        GET     Hdr:HighFSI
        GET     Hdr:LowFSI
        GET     Hdr:Services
        GET     Hdr:Variables
        GET     Hdr:OsBytes
        GET     Hdr:MimeMap
        GET     Hdr:CDROM
        GET     Hdr:CDErrors
        GET     Hdr:CMOS
        GET     Hdr:HostFS
        GET     Hdr:UpCall
        GET     Hdr:Proc
        GET     Hdr:NdrDebug
        GET     hdr.Options             ; Link in options
        GET     hdr.Hashes              ; Link in hash define file
        GET     hdr.MyMacros            ; Link in macro file
        GET     hdr.CDFS
        GET     VersionASM              ; Date/version strings

;*****************************************************************
;                       MODULE HEADER
;*****************************************************************

        AREA    |CDFS$$Code|, CODE, READONLY, PIC
        ENTRY

Module_BaseAddr

        DCD     0
        DCD     initialisingcode - Module_BaseAddr
        DCD     finalisingcode - Module_BaseAddr
        DCD     servicecode - Module_BaseAddr
        DCD     title - Module_BaseAddr
        DCD     help - Module_BaseAddr
        DCD     KeywordTable - Module_BaseAddr
        DCD     CDROMFSSWI_Base
        DCD     CDFSSWIentry - Module_BaseAddr
        DCD     CDFStableofswinames - Module_BaseAddr
        DCD     0                       ; decoding code
      [ international_help
        DCD     message_filename - Module_BaseAddr
      |
        DCD     0                       ; international help
      ]
        DCD     ModuleFlags - Module_BaseAddr

message_filename
        ; CANNOT USE CDFS$Path 'cause it screws up *dir cdfs::0
        DCB     "CDFSMessages:Messages", 0
Path
        DCB     "CDFSMessages$$Path", 0
PathDefault
        DCB     "Resources:$.Resources.CDFS."
PathDefaultEnd
        ALIGN

ModuleFlags
        DCD     ModuleFlag_32bit

;-----------------------------------------------------------------------------------------------
initialisingcode ROUT
;
; on entry:
;          R10 -> enviroment string ( see page 631 )
;          R11 = I/O base or instantiation number
;          R12 -> currently preferred instantiation of module
;          R13 -> supervisor stack
;
; on exit:
;         must preserve R7 - R11, and R13, forget the rest
;
;-----------------------------------------------------------------------------------------------

        Push    "r14"

;----------------------------------------------------------
; initialise CDFSMessages$Path if not already done
;----------------------------------------------------------

        ADR     r0, Path                
        MOV     r2, #-1                 
        MOV     r3, #0                  
        MOV     r4, #VarType_Expanded                  
        SWI     XOS_ReadVarVal          ; returns R2=0 if doesn't exist
        CMP     r2, #0                  ; clears V as well!
                                        
        ADREQ   r0, Path                
        ADREQ   r1, PathDefault         
        MOVEQ   r2, #PathDefaultEnd - PathDefault       
        MOVEQ   r3, #0                  
        MOVEQ   r4, #VarType_String                  
        SWIEQ   XOS_SetVarVal           

;-----------------------------------------------------------------------------------------------
; Read configured number of drives.
;-----------------------------------------------------------------------------------------------

        MOV     r0, #OsByte_ReadCMOS
        MOV     r1, #CDROMFSCMOS        ; Cmos RAM location
        SWI     XOS_Byte                ; R2 = contents of location

      [ CheckConfiguredDrives
        TST     r2, #BITSUSEDBYDRIVENUMBER

        BNE     %FT00

        SUB     r13, r13, #16           ; local buffer for MessageTrans file descriptor
        MOV     r0, r13                 ; open message file
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile

        ADRVCL  r0, noconfigureddrives_tag ; lookup error (or use error from OpenFile)
        MOVVC   r1, r13
        SWIVC   XMessageTrans_ErrorLookup

        MOV     r1, r0                  ; at this point we definitely have an error of some sort
        MOV     r0, r13
        SWI     XMessageTrans_CloseFile
        MOV     r0, r1                  ; ignore any error from CloseFile

        ADD     r13, r13, #16           ; free buffer and return error (don't start up)
        SETV
        Pull    "pc"
00
      ]

        MOV     r6, r2

;-----------------------------------------------------------------------------------------------
; Claim space from RMA for workspace
;-----------------------------------------------------------------------------------------------

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =SIZEOFRMA          ; Amount of memory required
        SWI     XOS_Module
        MOVVS   r4, r0
        BVS     kill_filing_system

        STR     r2, [ r12 ]             ; Save it in the private word

        MOV     r12, r2

;-----------------------------------------------------------------------------------------------
; Clear the reserved memory
;-----------------------------------------------------------------------------------------------

        MOV     r1, #0                  ; R1 = Wiper
        MOV     r0, r12                 ; R0 -> Start of wipe
        LDR     r3, =SIZEOFRMA          ; R3 -> end of wipe
        ADD     r3, r3, r12             
03                                      
        STR     r1, [r0], #4            
        CMP     r0, r3                  
        BLE     %BT03                   

;----------------------------------------------------------
; Set up MessageTrans expecting the CDSFSResources module
; to have put the files into ResourceFS
;----------------------------------------------------------

        ADR     r0, message_block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        MOVVS   r4, r0
        BVS     free_workspace

;--------------------------------------------------------------------------
; Extract the buffer value from the CMOS byte
;--------------------------------------------------------------------------

        AND     r0, r6, #BITSUSEDBYBUFFER

        MOV     r0, r0, LSR #BUFFERSHIFT


        ; First find out how big the buffer size is

        BL      ConvertBufferSizeToReal ; R0 = bit size, RETURNS R1 = number of K


        TEQ     r1, #0                  ; If no memory is needed then do not claim it
        MOVEQ   r1, #6                  ; Cheat - claim a minimum amount of 6K
                                        
        MOV     r5, r1                  ; preserve R1
                                        
        MOV     r3, r1, ASL #10         ; R1 = number of K * 1024 = number of bytes
        STR     r3, discbuffersize

        MOV     r0, #6

        SWI     XOS_Module              ; R0 = 6, R3 = amount required
                                        ; RETURNS R2 -> claimed block
                                        
        MOVVS   r2, #0                  ; If cannot get memory then use 0 buffers
        STRVS   r2, discbuffersize      ; ( Display message )
        BVS     display_no_buffers      ;

        STR     r2, discbufferpointer
        STR     r2, disclastpointer

;--------------------------------------------------------------------------
; Clear the disc buffer space ; R2 -> start, R3 = length, R14 = temp
;--------------------------------------------------------------------------

        ADD     r3, r3, r2              ; R3 -> end of space
        MOV     r14, #0                 ; R14 = wiper
02                                      
        STR     r14, [r2], #4
        CMP     r2, r3                  
        BLT     %BT02                   

;--------------------------------------------------------------------------
; Claim space for pointers  ( length depends on size of configured buffer )
;--------------------------------------------------------------------------

; R5 = size of cache in K

        MOV     r3, r5, ASL #2
        STR     r3, maxnumberofbuffers

; R3 = ( size_of_cache_in_K * 4 * 3 * 2 ) + 4 just in case
;    = ( R5 * 8 * 3 ) + 4

; R5 = 32
; R3 = 32 * 8 = 256
; R3 = 256 * 3 = 768
; R3 = 768 + 4 = 772

      [ SIZEOFBUFFERENTRY<>16
        ! 0, " See 'Main' "
      ]

        MOV     r3, r5, ASL #6          ; xK * 4 * 16
        
        ADD     r3, r3, #SIZEOFBUFFERENTRY + 4
        
        MOV     r0, #6
        
        SWI     XOS_Module              ; R3 = total size of cache required
        MOVVS   r4, r0
        BVS     free_disc_cache
        
        STR     r2, pointerToBufferList
        
        
        ADD     r3, r3, r2
        MOV     r4, #0
        MOV     r1, r2
04      
        STR     r4, [r1], #4
        CMP     r1, r3
        BLT     %BT04

no_disc_buffer

;--------------------------------------------------------------------------
; Read the configure option, if 0 drives configured, then look for one
;--------------------------------------------------------------------------

;----------------------------------
; Seperate byte in CMOS from number
;----------------------------------

        ANDS    r0, r6, #BITSUSEDBYDRIVENUMBER

        STR     r0, maxnumberofdrives

;----------------------------------
; Set module up as a filing system
;----------------------------------

        BL      registerFS
        MOVVS   r4, r0
        BVS     free_pointer_list

;------------------------------
; Register with the Free module
;------------------------------
        MOV     r0, #fsnumber_CDFS
        ADRL    r1, Free_Entry
        MOV     r2, r12
        SWI     XFree_Register
        ; It's not fatal if this produces an error

;---------------------------------------------------
; Set disc has changed value for all possible drives
;---------------------------------------------------

        Push    "r7"                    ; SMC: Don't want to corrupt r7, do we!

        ADR     r7, sparecontrolblock
        MOV     r6, #0
01
        SWI     XCD_DiscHasChanged
        ADD     r6, r6, #1
        AND     r2, r6, #2_111          ; R2 = device number
        MOV     r3, r6, ASR #3          ; R3 = card number
        AND     r3, r3, #2_11
        MOV     r4, r6, ASR #5          ; R4 = LUN
        AND     r4, r4, #2_11
        STMIA   r7, { r2, r3, r4 }
        CMP     r6, #2_1111111          ; If device =7,LUN=3,card=3 THEN end
        BLE     %BT01

        Pull    "r7"

      [ log
        ADRL    R14, log_memory
        STR     R14, log_pointer
      ]

;----------------------------------
; Check for presence of RISC_OS 3.0
;----------------------------------

        ADR     r0, rmensure
        SWI     XOS_CLI                 ; No error, so must be OK (?) !!!
                                        
        MOV     r0, #2                  ; default of 0 for RISC OS 2, and 2 for RISC OS 3+                  
        STRVCB  r0, truncation
        MOVVS   r0, #1
        STRVCB  r0, max_truncation

;----------------------------------------------------------
; Set the PhotoCD file type to read 'PhotoCD'
;----------------------------------------------------------

        ADR     r0, photocd_filetype
        SWI     XOS_CLI

;----------------------------------------------------------
; End Initialisation process
;----------------------------------------------------------
        CMP     R0,#0
        Pull    "pc"

;----------------------------------------------------------

photocd_filetype
        DCB     "Set File$$Type_BE8 PhotoCD", 0

rmensure
        DCB     "RMENSURE UtilityModule 3.00", 0
        ALIGN
        
;*****************
display_no_buffers
; If the disc buffer space not available
; Then print a message and use 0 buffers
;*****************

        ADRL    r0, nospace_tag
        ADR     r1, message_block
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        ADD     r0, r0, #4
        SWI     XOS_Write0
                
        SWI     XOS_NewLine
                
        SWI     XOS_ReadMonotonicTime   ; RETURNS R0 = time in centi-seconds since
                                        ; last hard reset
        ADD     R1, R0, #2*100
06
        SWI     XOS_ReadMonotonicTime   ; RETURNS R0 = time in centi-seconds since
                                        ; last hard reset
        CMP     R0, R1
        BLT     %BT06

        B       no_disc_buffer


;-----------------------------------------------------------------------------------------------
finalisingcode ROUT
;
; on entry:
;          r4  = 0 or -> error block ( may have jumped in from InitialisationCode )
;          R10 = fatality indicator, 0 = non-fatal, 1 = fatal
;          R11 = instantiation number
;          R12 -> private word
;          R13 -> supervisor stack
;
; on exit:
;          R7 - R11 and R13 must be preserved, forget the rest
;-----------------------------------------------------------------------------------------------

        Push    "r14"
        MOV     r4, #0
        LDR     r12, [ r12 ]

;----------------------------------------------------------
; Close the message trans file for RISC OS 3
; added: 9-June-93 for CDFS v 2.16
;----------------------------------------------------------

        ADR     r0, message_block
        SWI     XMessageTrans_CloseFile

;--------------------------------
; Deregister from the Free module
;--------------------------------
        MOV     r0, #fsnumber_CDFS
        ADRL    r1, Free_Entry
        MOV     r2, r12
        SWI     XFree_DeRegister

;----------------------------------------------------------
; free the pointer list - if it was claimed
;----------------------------------------------------------
free_pointer_list

        LDR     r14, discbuffersize
        TEQ     r14, #0
        MOVNE   r0, #ModHandReason_Free
        LDRNE   r2, pointerToBufferList
        SWI     XOS_Module              ; R0 = 7, R2 -> RMA to free

;----------------------------------------------------------
; free the disc cache space
;----------------------------------------------------------
free_disc_cache

        LDR     r14, discbuffersize
        TEQ     r14, #0
        MOVNE   r0, #ModHandReason_Free
        LDRNE   r2, discbufferpointer
        SWI     XOS_Module              ; R0 = 7, R2 -> RMA to free

;--------------------------------------------------------------------------
; free the workspace
;--------------------------------------------------------------------------
free_workspace

        MOV     r0, #ModHandReason_Free
        MOV     r2, r12
        SWI     XOS_Module              ; R0 = 7, R2 -> RMA to free

;--------------------------------------------------------------------------
; Kill module as a filing system
;--------------------------------------------------------------------------
kill_filing_system

        MOV     r0, #FSControl_RemoveFS
        ADRL    r1, FilingSystemName
        SWI     XOS_FSControl

;--------------------------------------------------------------------------
; Exit returning error
;--------------------------------------------------------------------------

        MOVS    r0, r4                  ; Tell about the error
        Pull    "pc", EQ
        SETV
        Pull    "pc"

;--------------------------------------------------------------------------
ServiceTable
        DCD     0                       ; flag word
        DCD     serviceursula - Module_BaseAddr
        DCD     Service_FSRedeclare
        DCD     0
        DCD     ServiceTable - Module_BaseAddr

servicecode ROUT
;
; on entry:
;          r1 = service call reason code
;          other registers service call specific
;
; on exit:
;          r1 = 0 (service claimed) or preserved (service not claimed)
;          other registers service call specific
;--------------------------------------------------------------------------
        MOV     r0,r0                   ; nop to indicate service table present
        TEQ     r1, #Service_FSRedeclare
        MOVNE   pc, lr

serviceursula
        LDR     r12, [r12]
        ; Drop through to...

;--------------------------------------------------------------------------
registerFS ROUT
;
; Register our filing system.
;--------------------------------------------------------------------------

        Push    "r0-r3,lr"
                
        MOV     r0, #FSControl_AddFS
        addr    r1, Module_BaseAddr
        ADR     r2, InformationBlock
        SUB     r2, r2, r1
        MOV     r3, r12                 ; Passed in R12 when call to filing system
        SWI     XOS_FSControl
                
        Pull    "r0-r3,pc"

;--------------------------------------------------------------------------
;        This next block is used by FileSwitch

; All of the routines are held in the file 'FileMan'
;--------------------------------------------------------------------------

InformationBlock

        DCD     FilingSystemName - Module_BaseAddr              ; &00
        DCD     StartUpText - Module_BaseAddr                   ; &04
        DCD     OpenFile - Module_BaseAddr                      ; &08
        DCD     GetByte - Module_BaseAddr                       ; &0c
        DCD     PutByte - Module_BaseAddr                       ; &10
        DCD     ControlOpenFile - Module_BaseAddr               ; &14
        DCD     CloseFile - Module_BaseAddr                     ; &18
        DCD     WholeFile - Module_BaseAddr                     ; &1c
        DCD     FS_INFORMATIONWORD                            ; &20
        DCD     FSOperations - Module_BaseAddr                  ; &24
        DCD     0                                             ; &28  GBPB not supported
      [ (FS_INFORMATIONWORD :AND: fsinfo_extrainfo) = 0 
        DCD     FS_EXTRAINFORMATIONWORD                       ; &2c
      ]

; Not part of Information Block

        GET     Args.s                  ; deals with FSEntry_Args (ControlFile)
        GET     Strings.s               ; Any old string
        GET     Misc.s                  ; Deals with miscellaneous *COMMANDS
        GET     DiscOp.s                ; Deals with most disc operations
        GET     FileMan.s               ; Handles file operations - See keyword table
        GET     Filer.s                 ; Routines called by 'FileMan'
        GET     Directory.s             ; move to and cat directory
        GET     EntryFile.s             ; deals with FSEntry_File
        GET     Open.s                  ; deals with open / close extras
        GET     SWI.s                   ; deals with the SWI CDFS_...
        GET     Error.s                 ; Deals with errors from SWI XCD_...
        GET     Tables.s                ; Unchanging tables
        GET     StarHelp.s              ; RISC OS 3 Contains *help routines
        GET     WordTable3.s            ; RISC OS 3 Contains keyword table ( *CDFS, *PLAY ... )
        GET     Variables.s             ; Layout of variables in workspace
        GET     ByteCopy.s
        GET     Free.s                  ; Support for Free module

      [ debug
        InsertNDRDebugRoutines
      ]

        LTORG

        END


@


4.17
log
@Add support for Joliet format CD-ROMs
hdr/Hashes
s/Directory
s/EntryFile
s/FileMan
s/Filer
s/Free
 - mass search and replace of lots of poorly named definitions, removing unused ones, creating implicit ones
hdr/MyMacros
 - shuffle some registers in ConvertToArchyDate to save one temporary so it can be used for something else
 - moved ReplaceBadCharacters here
hdr/Options
 - extra debug option
s/DiscOp
 - add Joliet, rename buffer indicies per hdr/Hashes
 - the fallback filetype assignment (when neither the ARCHIMEDES system extension nor MimeMap can help) can now be overridden by setting CDFS$DefaultType (which defaults to &FFD)
s/SWI
 - remove DAT<->MPEG mapping from the internal mapping table
s/Variables
 - trim out unused SWI_buffer reservation

Tested with valid ISO/Joliet/RockRidge supported combinations, documented in Docs/Combos, and accompanying test ISO images now stored there.
Tested with CD-I format disc 'Jigsaw' from Britannica.
Tested with High Sierra format disc 'Kings Quest V'.
Tested with photo CD sampler from Kodak.

Version 2.61. Tagged as 'CDFS-2_61'
@
text
@d89 1
a89 1
        DCB     "CDFSMessages$Path", 0
d380 1
a380 1
        DCB     "Set File$Type_BE8 PhotoCD", 0
@


4.16
log
@Various CDFS enhancements
* Increase BGET/BPUT buffer declared to FileSwitch to 2k to match the natural sector size (FileSwitch has been able to support this since version 2.28)
* Remove local debug macros, use those from NDRDebug instead
* Change to use SETV/CLRV macros now the ones in HdrSrc are 26/32 neutral
* Clarify those situations where LBA mode is being selected by using symbol 'LBAFormat'
* Extend *WHICHDISC to allow an optional drive number to be provided (the code has existed for years, but the GSTrans flags and help denied its use)

Version 2.60. Tagged as 'CDFS-2_60'
@
text
@d38 1
@


4.15
log
@Fix a few bugs
When lining up the code in 2.52, a few bugs became apparent (now the source was readable).
* In a handful of places it was assumed SWIs preserved flags, these have been reordered or branched around.
* The probe of UtilityModule 2.12 has been set to 3.00 and the logic now considers >= 3.00 rather than subtracting 1 from it to deduce the default filename truncation value.
* Removed support for supplemental filetype table in CDFSNewFileTypePath$File as this has been superceded by the MimeMap module (which CDFS uses). This mirrors the behaviour of DOSFS and LanManFS which consult the MimeMap first then (small) internal table second.
* Fix stack imbalance when reading the current setting with CDFS_Truncation leading to an abort

Other changes
* When the MimeMap module is absent ".doc" is taken to be a MS Word document.
* Changed the manual loads from :INDEX: of R12 to be ADR's or ADRL's so there's less literal pool thrashing.
* Three Push/Pull sequences to restore registers swapped for LDMIA's (in Directory.s).
* Reason codes to OS_ SWIs swapped for header file names.


Version 2.56. Tagged as 'CDFS-2_56'
@
text
@a42 1
        GET     Hdr:CPU.Arch
a47 1
        GET     Hdr:NdrDebug
a48 1
      [ debug
d50 1
a50 1
      ]
d160 1
a160 1
        VSET
a193 4
;-----------------------------------------------------------------------------------------------
; Claim space from RMA for LIB & URD paths ( and clear them )
;-----------------------------------------------------------------------------------------------

d492 1
a492 1
        VSET
@


4.14
log
@CDDriver error numbers taken from header file.
Note: CDFS' error block is actually offset within CDDriver's (by 64).
The report for *CDDevices now lines up properly with disc sizes < 100MB.
The syntax error for *PlayMSF no longer uses MessageTrans_GSLookup which tried to substitute the <> arguments.
Non internationalised module now has syntax error messages too.

Version 2.55. Tagged as 'CDFS-2_55'
@
text
@d41 1
d123 1
a123 1
        MOV     r4, #2                  
d131 1
a131 1
        MOVEQ   r4, #0                  
d174 1
a174 1
        MOV     r0, #6                  ; Reason code
d337 1
a337 1
        ADD     r7, r12, #:INDEX:sparecontrolblock
d354 1
a354 2
        LDR     R14, =:INDEX:log_memory
        ADD     R14, R14, R12
d362 1
a362 1
        ADR     r0, rmensure            
d365 4
a368 5
        MOV     r0, #2                  
        STRVCB  r0, truncation          
                                        
        MOVVC   r0, #3                  ; remember what os version is being run
        STRB    r0, os_version          
d389 1
a389 1
        DCB     "RMENSURE UtilityModule 2.12", 0
d460 1
a460 1
        MOVNE   r0, #7
d471 1
a471 1
        MOVNE   r0, #7
d480 1
a480 1
        MOV     r0, #7
d489 1
a489 2
        MOV     r0, #16

a490 1

d536 1
a536 1
        MOV     r0, #12                 ; Reason code to add a filing system
@


4.13
log
@Exchange local definitions for central ones.
Hdr:HighFSI LowFSI Services CDROM CMOS UpCall and CDFS now used in preference to local definitions.
Macro 'Command' used to build the keyword table.
Some asserts added for safety.


Version 2.54. Tagged as 'CDFS-2_54'
@
text
@d45 1
@


4.12
log
@Collapse old switches.
Switches from 10+ years ago removed. Demo version switch removed.

Version 2.53. Not tagged
@
text
@d38 3
d44 2
d48 1
d55 1
d65 1
a65 1
startofheader
d68 9
a76 9
        DCD     initialisingcode - startofheader
        DCD     finalisingcode - startofheader
        DCD     servicecode - startofheader
        DCD     title - startofheader
        DCD     help - startofheader
        DCD     KeywordTable - startofheader
        DCD     CDFSSWIBaseNumber
        DCD     CDFSSWIentry - startofheader
        DCD     CDFStableofswinames - startofheader
d78 2
a79 2
      [ LazyIntHelp
        DCD     message_filename - startofheader
d83 1
a83 1
        DCD     ModuleFlags - startofheader
d137 1
a137 1
        MOV     r1, #HARDRAMLOCATION    ; Cmos RAM location
d351 1
a351 1
      [ log=ON
d507 1
a507 1
        DCD     serviceursula - startofheader
d510 1
a510 1
        DCD     ServiceTable - startofheader
d539 1
a539 1
        addr    r1, startofheader
d555 15
a569 13
        DCD     FilingSystemName - startofheader              ; &00
        DCD     StartUpText - startofheader                   ; &04
        DCD     OpenFile - startofheader                      ; &08
        DCD     GetByte - startofheader                       ; &0c
        DCD     PutByte - startofheader                       ; &10
        DCD     ControlOpenFile - startofheader               ; &14
        DCD     CloseFile - startofheader                     ; &18
        DCD     WholeFile - startofheader                     ; &1c
        DCD     FILINGSYSTEMINFORMATIONWORD                   ; &20
        DCD     FSOperations - startofheader                  ; &24
        DCD     0                                             ; &28  Not supported
        DCD     EXTRA_FILINGSYSTEMINFORMATIONWORD             ; &2c
                
@


4.11
log
@Resolve the 32 assembler warnings
Mostly by swapping STASH/GRAB for Push/Pull macros.
Inlined the module header rather than defining it in a header file.
Renamed "Debug" macro to "DebugInline" to avoid clash with similarly named macro.

Version 2.53. Tagged as 'CDFS-2_53'
@
text
@d366 1
a366 1
      [ Module_Version >= 220
a368 1
      ]
a377 1
     [ Module_Version >= 220
a379 2
     ]

@


4.10
log
@Line up sources to normal columns.
Around 25000 spaces required, but rather easier to read as a result - it has revealed some bugs (not addressed in this commit).
Not quite binary identical, because an 'addr' of the ambiguous disc name error has moved by 1 byte due to a missing ALIGN directive.
Not tagged.
@
text
@d17 3
d21 5
a25 1
; IF ERROR &1E6 ( SWI ... NOT KNOWN ) THEN SUICIDE ?
d27 3
a29 11
; ON SWI ENTRY :

;               R11 = SWI number % 64

;               R12 = private word pointer  - USE GRAB & STASH

;               R13 = supervisor stack

;               R14 = return register

        AREA    |CDFS$$Code|, CODE, READONLY, PIC
a40 1

d43 3
a45 36

        GBLL    debug
debug   SETL    {FALSE}

        GBLL    hostvdu
hostvdu SETL    {TRUE}

;*****************************************************************
;*****************************************************************
;                   Procedures in this file
;*****************************************************************
;*****************************************************************

; initialisingcode     ; Start up as a filing system

; finalisingcode       ; Kill filing system and claimed RMA space

; servicecode          ; Service call handler

; registerFS           ; Register module as a filing system

; InformationBlock     ; Block used by FileSwitch

;*****************************************************************
;*****************************************************************





;*****************************************************************
;                       MODULE HEADER
;*****************************************************************

startofheader

a50 9
        ENTRY

        ModuleDescriptionHeader

 [ debug
        GET     Hdr:Proc
        InsertNDRDebugRoutines
 ]

d52 1
a52 1
;                       Include other files
d55 2
a56 17
        GET     s.Args                  ; deals with FSEntry_Args (ControlFile)
        GET     s.Strings               ; Any old string
        GET     s.Misc                  ; Deals with miscellaneous *COMMANDS
        GET     s.DiscOp                ; Deals with most disc operations
        GET     s.FileMan               ; Handles file operations - See keyword table
        GET     s.Filer                 ; Routines called by 'FileMan'
        GET     s.Directory             ; move to and cat directory
        GET     s.EntryFile             ; deals with FSEntry_File
        GET     s.Open                  ; deals with open / close extras
        GET     s.SWI                   ; deals with the SWI CDFS_...
        GET     s.Error                 ; Deals with errors from SWI XCD_...
        GET     s.Tables                ; Unchanging tables
        GET     s.StarHelp              ; RISC OS 3 Contains *help routines
        GET     s.WordTable3            ; RISC OS 3 Contains keyword table ( *CDFS, *PLAY ... )
        GET     s.Variables             ; Layout of variables in workspace
        GET     s.ByteCopy              
        GET     s.Free                  ; Support for Free module
d58 1
d60 17
a76 3
;-----------------------------------------------------------------------------------------------

; CANNOT USE CDFS$Path 'cause it screws up *dir cdfs::0
d79 1
d89 1
a89 1
        DCD    ModuleFlag_32bit
d105 1
a105 1
        STASH   r14
d133 1
a133 1
 [ CheckConfiguredDrives
d155 1
a155 1
        GRAB    pc
d157 1
a157 1
 ]
d245 1
a245 1
        STMIA   r2!, { r14 }            
d326 1
a326 1
        STASH   r7                      ; SMC: Don't want to corrupt r7, do we!
d342 1
a342 1
        GRAB    r7
d375 1
a375 1
        GRAB    pc
d430 1
a430 1
        STASH   r14
d488 1
a488 1
        addr    r1, FilingSystemName
d497 1
a497 1
        GRAB    pc, EQ
d499 1
a499 1
        GRAB    pc
d533 1
a533 1
        STASH   "r0-r3,lr"
d542 1
a542 1
        GRAB    "r0-r3,pc"
d567 22
@


4.9
log
@Updated to use Hdr:MimeMap
Some explicit single register LDM/STM changed to LDR/STR equivalents

Version 2.52. Tagged as 'CDFS-2_52'
@
text
@d81 4
a84 4
 GET hdr.Options           ; Link in options
 GET hdr.Hashes            ; Link in hash define file
 GET hdr.MyMacros          ; Link in macro file
 GET VersionASM            ; Date/version strings
d86 1
a86 1
 ENTRY
d88 1
a88 1
 ModuleDescriptionHeader
d99 17
a115 17
 GET s.Args        ; deals with FSEntry_Args (ControlFile)
 GET s.Strings     ; Any old string
 GET s.Misc        ; Deals with miscellaneous *COMMANDS
 GET s.DiscOp      ; Deals with most disc operations
 GET s.FileMan     ; Handles file operations - See keyword table
 GET s.Filer       ; Routines called by 'FileMan'
 GET s.Directory   ; move to and cat directory
 GET s.EntryFile   ; deals with FSEntry_File
 GET s.Open        ; deals with open / close extras
 GET s.SWI         ; deals with the SWI CDFS_...
 GET s.Error       ; Deals with errors from SWI XCD_...
 GET s.Tables      ; Unchanging tables
 GET s.StarHelp    ; RISC OS 3 Contains *help routines
 GET s.WordTable3  ; RISC OS 3 Contains keyword table ( *CDFS, *PLAY ... )
 GET s.Variables   ; Layout of variables in workspace
 GET s.ByteCopy
 GET s.Free        ; Support for Free module
d122 8
a129 1
message_filename DCB    "CDFSMessages:Messages", 0
d131 2
a132 8

Path             DCB    "CDFSMessages$Path"
                 DCB    0
PathDefault      DCB    "Resources:$.Resources.CDFS."
                 DCB    0
                 ALIGN

ModuleFlags      DCD    ModuleFlag_32bit
d148 1
a148 1
         STASH         r14
d154 13
a166 13
         ADR       r0, Path
         MOV       r2, #-1
         MOV       r3, #0
         MOV       r4, #2
         SWI       XOS_ReadVarVal          ; returns R2=0 if doesn't exist
         CMP       r2, #0                  ; clears V as well!

         ADREQ     r0, Path
         ADREQ     r1, PathDefault
         MOVEQ     r2, #?PathDefault
         MOVEQ     r3, #0
         MOVEQ     r4, #0
         SWIEQ     XOS_SetVarVal
d172 3
a174 3
         MOV         r0, #OsByte_ReadCMOS
         MOV         r1, #HARDRAMLOCATION    ; Cmos RAM location
         SWI         XOS_Byte                ; R2 = contents of location
d177 1
a177 1
         TST         r2, #BITSUSEDBYDRIVENUMBER
d179 1
a179 1
         BNE         %FT00
d181 18
a198 18
         SUB         r13, r13, #16              ; local buffer for MessageTrans file descriptor
         MOV         r0, r13                    ; open message file
         ADR         r1, message_filename
         MOV         r2, #0
         SWI         XMessageTrans_OpenFile

         ADRVCL      r0, noconfigureddrives_tag ; lookup error (or use error from OpenFile)
         MOVVC       r1, r13
         SWIVC       XMessageTrans_ErrorLookup

         MOV         r1, r0                     ; at this point we definitely have an error of some sort
         MOV         r0, r13
         SWI         XMessageTrans_CloseFile
         MOV         r0, r1                     ; ignore any error from CloseFile

         ADD         r13, r13, #16              ; free buffer and return error (don't start up)
         VSET
         GRAB        pc
d202 1
a202 11
         MOV         r6, r2

;-----------------------------------------------------------------------------------------------
; Free w/s if already got some
;-----------------------------------------------------------------------------------------------

         ; LDR        r14, [ r12 ]
         ; TEQ        r14, #0

         ; BLNE       finalisingcode

d208 5
a212 5
         MOV         r0, #6                  ; Reason code
         LDR         r3, =SIZEOFRMA          ; Amount of memory required
         SWI         XOS_Module
         MOVVS       r4, r0
         BVS         kill_filing_system
d214 1
a214 1
         STR         r2, [ r12 ]                 ; Save it in the private word
d216 1
a216 1
         MOV         r12, r2
d222 8
a229 8
         MOV         r1, #0          ; R1 = Wiper
         MOV         r0, r12         ; R0 -> Start of wipe
         LDR         r3, =SIZEOFRMA  ; R3 -> end of wipe
         ADD         r3, r3, r12
03
         STR         r1, [r0], #4
         CMP         r0, r3
         BLE         %BT03
d240 6
a245 6
         ADR       r0, message_block
         ADR       r1, message_filename
         MOV       r2, #0
         SWI       XMessageTrans_OpenFile
         MOVVS     r4, r0
         BVS       free_workspace
d251 1
a251 1
         AND         r0, r6, #BITSUSEDBYBUFFER
d253 1
a253 1
         MOV         r0, r0, LSR #BUFFERSHIFT
d258 1
a258 5
         BL          ConvertBufferSizeToReal ; R0 = bit size, RETURNS R1 = number of K


         TEQ         r1, #0                 ; If no memory is needed then do not claim it
         MOVEQ       r1, #6                 ; Cheat - claim a minimum amount of 6K
a259 1
         MOV         r5, r1                 ; preserve R1
d261 16
a276 2
         MOV         r3, r1, ASL #10        ; R1 = number of K * 1024 = number of bytes
         STR         r3, discbuffersize
d278 2
a279 11
         MOV         r0, #6

         SWI         XOS_Module           ; R0 = 6, R3 = amount required
                                  ; RETURNS R2 -> claimed block

         MOVVS       r2, #0             ; If cannot get memory then use 0 buffers
         STRVS       r2, discbuffersize ; ( Display message )
         BVS         display_no_buffers   ;

         STR         r2, discbufferpointer
         STR         r2, disclastpointer
d285 6
a290 6
         ADD         r3, r3, r2        ; R3 -> end of space
         MOV         r14, #0           ; R14 = wiper
02
         STMIA       r2!, { r14 }
         CMP         r2, r3
         BLT         %BT02
d298 2
a299 2
         MOV         r3, r5, ASL #2
         STR         r3, maxnumberofbuffers
d309 1
a309 1
         [ SIZEOFBUFFERENTRY<>16
d311 1
a311 14
         ]

         MOV         r3, r5, ASL #6     ; xK * 4 * 16

         ADD         r3, r3, #SIZEOFBUFFERENTRY + 4

         MOV         r0, #6

         SWI         XOS_Module     ; R3 = total size of cache required
         MOVVS       r4, r0
         BVS         free_disc_cache

         STR         r2, pointerToBufferList

d313 20
a332 7
         ADD         r3, r3, r2
         MOV         r4, #0
         MOV         r1, r2
04
         STR         r4, [r1], #4
         CMP         r1, r3
         BLT         %BT04
d344 1
a344 1
         ANDS        r0, r6, #BITSUSEDBYDRIVENUMBER
d346 1
a346 3
         STR         r0, maxnumberofdrives

;         BLEQ        AnotherDriveHasBeenAdded  ; R0 = drive number
d352 3
a354 3
         BL          registerFS
         MOVVS       r4, r0
         BVS         free_pointer_list
d359 5
a363 5
         MOV         r0, #fsnumber_CDFS
         ADRL        r1, Free_Entry
         MOV         r2, r12
         SWI         XFree_Register
         ; It's not fatal if this produces an error
d369 1
a369 1
         STASH       r7                            ; SMC: Don't want to corrupt r7, do we!
d371 2
a372 2
         ADD         r7, r12, #:INDEX:sparecontrolblock
         MOV         r6, #0
d374 18
a391 18
         SWI         XCD_DiscHasChanged
         ADD         r6, r6, #1
         AND         r2, r6, #2_111                ; R2 = device number
         MOV         r3, r6, ASR #3                ; R3 = card number
         AND         r3, r3, #2_11
         MOV         r4, r6, ASR #5                ; R4 = LUN
         AND         r4, r4, #2_11
         STMIA       r7, { r2, r3, r4 }
         CMP         r6, #2_1111111                ; If device =7,LUN=3,card=3 THEN end
         BLE         %BT01

         GRAB        r7

         [ log=ON
         LDR R14, =:INDEX:log_memory
         ADD R14, R14, R12
         STR R14, log_pointer
         ]
d397 8
a404 8
         ADR         r0, rmensure
         SWI         XOS_CLI                 ; No error, so must be OK (?) !!!

         MOV         r0, #2
         STRVCB      r0, truncation

         MOVVC       r0, #3                ; remember what os version is being run
         STRB        r0, os_version
d409 4
a412 4
       [ Module_Version >= 220
         ADR       r0, photocd_filetype
         SWI       XOS_CLI
       ]
d417 2
a418 2
         CMP       R0,#0
         GRAB      pc
d422 4
a425 3
       [ Module_Version >= 220
photocd_filetype = "Set File$Type_BE8 PhotoCD", 0
       ]
d428 4
a431 3
rmensure         DCB "RMENSURE UtilityModule 2.12", 0

 ALIGN
d438 12
a449 12
 ADRL   r0, nospace_tag
 ADR    r1, message_block
 MOV    r2, #0
 SWI    XMessageTrans_ErrorLookup
 ADD    r0, r0, #4
 SWI    XOS_Write0

 SWI XOS_NewLine

 SWI XOS_ReadMonotonicTime   ; RETURNS R0 = time in centi-seconds since
                             ; last hard reset
 ADD R1, R0, #2*100
d451 4
a454 4
 SWI XOS_ReadMonotonicTime   ; RETURNS R0 = time in centi-seconds since
                             ; last hard reset
 CMP R0, R1
 BLT %BT06
d456 1
a456 1
 B no_disc_buffer
d473 3
a475 3
         STASH     r14
         MOV       r4, #0
         LDR       r12, [ r12 ]
d482 2
a483 2
         ADR       r0, message_block
         SWI       XMessageTrans_CloseFile
d488 4
a491 4
         MOV       r0, #fsnumber_CDFS
         ADRL      r1, Free_Entry
         MOV       r2, r12
         SWI       XFree_DeRegister
d498 5
a502 5
         LDR       r14, discbuffersize
         TEQ       r14, #0
         MOVNE     r0, #7
         LDRNE     r2, pointerToBufferList
         SWI       XOS_Module              ; R0 = 7, R2 -> RMA to free
d509 5
a513 5
         LDR       r14, discbuffersize
         TEQ       r14, #0
         MOVNE     r0, #7
         LDRNE     r2, discbufferpointer
         SWI       XOS_Module              ; R0 = 7, R2 -> RMA to free
d520 3
a522 3
         MOV       r0, #7
         MOV       r2, r12
         SWI       XOS_Module              ; R0 = 7, R2 -> RMA to free
d529 1
a529 1
         MOV       r0, #16
d531 1
a531 1
         addr      r1, FilingSystemName
d533 1
a533 1
         SWI       XOS_FSControl
d539 4
a542 4
         MOVS      r0, r4                        ; Tell about the error
         GRAB      pc, EQ
         VSET
         GRAB      pc
d546 5
a550 5
	 DCD	0			; flag word
	 DCD	serviceursula - startofheader
	 DCD	Service_FSRedeclare
	 DCD	0
	 DCD	ServiceTable - startofheader
d562 3
a564 3
	 MOV	 r0,r0			; nop to indicate service table present
         TEQ     r1, #Service_FSRedeclare
         MOVNE   pc, lr
d567 2
a568 2
         LDR     r12, [r12]
         ; Drop through to...
d576 10
a585 10
         STASH  "r0-r3,lr"

         MOV    r0, #12                 ; Reason code to add a filing system
         addr   r1, startofheader
         ADR    r2, InformationBlock
         SUB    r2, r2, r1
         MOV    r3, r12                 ; Passed in R12 when call to filing system
         SWI    XOS_FSControl

         GRAB   "r0-r3,pc"
a592 2
 ALIGN

d595 13
a607 24
 DCD FilingSystemName - startofheader              ; &00

 DCD StartUpText - startofheader                   ; &04

 DCD OpenFile - startofheader                      ; &08

 DCD GetByte - startofheader                       ; &0c

 DCD PutByte - startofheader                       ; &10

 DCD ControlOpenFile - startofheader               ; &14

 DCD CloseFile - startofheader                     ; &18

 DCD WholeFile - startofheader                     ; &1c

 DCD FILINGSYSTEMINFORMATIONWORD                   ; &20

 DCD FSOperations - startofheader                  ; &24

 DCD 0                                             ; &28  Not supported

 DCD EXTRA_FILINGSYSTEMINFORMATIONWORD             ; &2c

d610 1
a610 1
 LTORG
d612 1
a612 1
 END
@


4.8
log
@  Build fix
Detail:
  This module uses the LDW macro, so now it needs to include Hdr:CPU.Arch
  to decide whether to use ARMv6 optimisations
Admin:
  Untested, but should be safe

Version 2.49. Tagged as 'CDFS-2_49'
@
text
@d32 10
a41 8
        GET     hdr:ListOpts
        GET     hdr:Macros
        GET     hdr:System
        GET     hdr:MsgTrans
        GET     hdr:ModHand
        GET     hdr:Free
        GET     hdr:FSNumbers
        GET     hdr:CPU.Arch
d43 2
a44 2
        GET     hdr:HostFS
        GET     hdr:NdrDebug
d47 1
a47 1
debug   SETL    false
d50 1
a50 1
hostvdu SETL    true
a81 1
 GET hdr.MimeMap           ; Link in MimeMap handling
d150 1
a150 1
; initialise CDFSFiler$Path if not already done
d171 1
a171 1
         MOV         r0, #161                ; Reason code              FOR GET
d236 1
a236 1
         STMIA       r0!, { r1 }
d339 1
a339 1
         STMIA       r1!, { r4 }
@


4.7
log
@Fixed top-bit-set problem that stopped *Configure from working outside the
desktop. Added GPA capability.

Version 2.47. Tagged as 'CDFS-2_47'
@
text
@d39 1
@


4.6
log
@  Nice new features.
Detail:
  * Reenabled BootFromCD option, and finished it off (so FSFunc_ReadBoot
    returns 2 (Run) to match the enforced action on booting); booting
    command line changed to "Run $.!BOOT"
  * Added 32-bit and 64-bit ReadFreeSpace FSFunc entries
  * Added support for interfacing with the Free module (so *ShowFree -FS CDFS
    now works)
  * Added missing * in syntax messags for *Lock and *Unlock
Admin:
  Tested on Tungsten.

Version 2.45. Tagged as 'CDFS-2_45'
@
text
@d84 2
@


4.5
log
@  A few fixes.
Detail:
  * Fixed a couple of top-bit-set pointer problems
  * Fixed a couple of places where it was assumed that SWIs preserved flags
  * Uses kernel internationalisation for command help, so full tokenisation
    now works properly
  * Added NdrDebug support
Admin:
  Tested on Tungsten.

Version 2.41. Tagged as 'CDFS-2_41'
@
text
@d37 2
d111 1
d363 9
d489 8
@


4.4
log
@  Lots of changes for RISC OS 5.
Detail:
  * Updated to use objasm, shared makefiles and global headers
  * Ripped out lots of RISC OS 2 support code so we can see the wood for the
    trees now
  * 32-bit compatible (a bit of a slog)
  * Now has its own resources phase, replacing the use of the CDFSResources
    module. Also means that messages can now be tokenised properly. For
    good measure, split out CmdHelp tokens into separate file
  * Hopefully fixed more bugs along the way than I introduced. I've seen
    lots of nasty stack imbalances in error cases, but not fixed all of
    them, I'm afraid
Admin:
  Tested briefly on a Risc PC; not enough support modules to run on Tungsten
  yet.

Version 2.38. Tagged as 'CDFS-2_38'
@
text
@d38 9
d83 5
@


4.3
log
@Manual merge of the RISC OS 4.02 version of CDFS (2.37, based upon Acorn's
RiscOS/UnU/OS_Core/FileSys/CDFS/CDFS234 version 2.35).

Tagged as 'CDFS-2_37'
@
text
@d30 1
a30 3
 NOFP    ;   NO FLOATING POINT STUFF

; LEADR &FFFFFA00        ; module filetype
d32 5
d70 1
a70 1
 GET hdr.Macros            ; Link in macro file
a91 1
 GET s.WordTable2  ; RISC OS 2 Contains keyword table ( *CDFS, *PLAY ... )
a92 1
 GET s.Sprites     ; RISC OS 2 - Sprite data for
d101 1
a101 2
 [ RISC_OS > 2
message_filename DCB    "<CDFSMessages$Path>Messages", 0
d109 2
a110 1
 ]
a131 2
         [ RISC_OS > 2

a145 2
         ]

a156 1
  [ RISC_OS > 2
d175 2
a176 2
         GRAB        r14
         ORRS        pc, r14, #Overflow_Flag
a177 5
  |
         ADREQ       r0, NoConfiguredDrives
         GRAB        r14, EQ
         ORREQS      pc, r14, #Overflow_Flag
  ]
a222 28
;--------------------------------------------------------------------------
; Under RISC OS 3 all URD and LIB stuff is done by OS
;--------------------------------------------------------------------------

         [ RISC_OS=2

         MOV         r0, #6
         MOV         r3, #( LIBLENGTH + URDLENGTH )
         ANDS        r14, r6, #BITSUSEDBYDRIVENUMBER   ; If number of drives = 0
         MOVEQ       r14, #1                          ; THEN R14 = 1
         MUL         r3, r14, r3
         SWI         XOS_Module

         MOVVS       r4, r0
         BVS         free_workspace                     ; Could not get the memory needed

         STR         r2, pointertolibandurd


         ADD         r14, r2, r3         ; R14 -> end of wipe
         MOV         r1, #0              ; R1 = wiper
01
         STRB        r1, [ r2 ], #1     ; R2 -> place to wipe
         CMP         r2, r14
         BLE         %BT01

         ]

a227 2
         [ RISC_OS > 2

a234 2
         ]

d398 2
a399 2
         GRAB      r14
         BICS      pc, r14, #Overflow_Flag
a416 1
 [ RISC_OS > 2
a421 3
 |
 ADR    r0, NoSpace+4
 ]
a460 2
         [ RISC_OS > 2

a463 2
         ]

a486 14
; Under RISC OS 3 all URD and LIB stuff is done by OS
;--------------------------------------------------------------------------

         [ RISC_OS=2

free_lib_and_urd

         MOV       r0, #7
         LDR       r2, pointertolibandurd
         SWI       XOS_Module              ; R0 = 7, R2 -> RMA to free

         ]

;--------------------------------------------------------------------------
a509 2
         GRAB      r14

d511 3
a513 3
         ORRNES    pc, r14, #Overflow_Flag

         BICS      pc, r14, #Overflow_Flag
d535 1
a535 1
         MOVNES  pc, lr
a554 11
         STRVS  r0, [sp]

         [ RISC_OS=2

         MOVVC  r0, #"$"                ; Setup CSD, URD, and LIB as '$'
         LDRVC  r3, =:INDEX:CSD_path
         STRVCB r0, [ r12, r3 ]
         LDRVC  r3, =:INDEX:BackPath
         STRVCB r0, [ r12, r3 ]

         ]
@


4.2
log
@  Ursula branch merge, plus srccommit usage.
Detail:
  Merged Ursula branch, it just removed dynamic dependencies from
   Makefile.

  Moved to srccommit, changed lots of occurrences of "Version" to module
   version, as defined in "VersionASM".  Removed old "Version" file.
Admin:
  Added stripdepend call into clean rule.


Version 2.30. Tagged as 'CDFS-2_30'
@
text
@d64 2
d93 1
d157 1
a157 1
 [ CheckConfiguredDrives=ON
d581 7
d598 1
d602 1
@


4.1
log
@Initial revision
@
text
@d66 1
a66 1
 GET Version               ; Date/version strings
d89 1
a89 1
 GET s.Sprites     ; RISC OS 2 - Sprite data for 
d428 1
a428 1
       [ Version >= 220
d441 1
a441 1
       [ Version >= 220
d621 1
a621 1
        
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

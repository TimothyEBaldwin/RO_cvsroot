head	4.14;
access;
symbols
	CDFS-2_63:4.14
	CDFS-2_62:4.14
	CDFS-2_61:4.14
	CDFS-2_60:4.14
	CDFS-2_59:4.13
	CDFS-2_58:4.13
	CDFS-2_57:4.13
	CDFS-2_56:4.13
	CDFS-2_55:4.12
	CDFS-2_54:4.12
	CDFS-2_53:4.11
	CDFS-2_52:4.9
	CDFS-2_51:4.9
	CDFS-2_50:4.9
	CDFS-2_49:4.8
	CDFS-2_48:4.8
	RO_5_07:4.7
	CDFS-2_47:4.7
	CDFS-2_46:4.7
	CDFS-2_45:4.7
	CDFS-2_44:4.7
	CDFS-2_43:4.6
	CDFS-2_42:4.6
	CDFS-2_41:4.6
	CDFS-2_40:4.5
	CDFS-2_39:4.5
	CDFS-2_38:4.5
	CDFS-2_37:4.4
	CDFS-2_35:4.3
	CDFS-2_30:4.2
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	nturton_CDFS-2_29:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_CDFS_2_28:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.14
date	2013.08.15.14.13.06;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	6zDw3cu1Q3LIBy1x;

4.13
date	2012.04.22.15.48.27;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	bybtPibvH0K2zS1w;

4.12
date	2012.04.22.11.04.31;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	6PVuneYjhUEDZQ1w;

4.11
date	2012.04.21.21.56.37;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	LsBEkd8YV89lDM1w;

4.10
date	2012.04.16.21.42.02;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	E6l0nP00WOBxH81w;

4.9
date	2011.12.07.00.11.40;	author jlee;	state Exp;
branches;
next	4.8;
commitid	RArFkKa8dlsJMbKv;

4.8
date	2005.04.22.21.47.48;	author jballance;	state Exp;
branches;
next	4.7;

4.7
date	2002.11.25.16.16.58;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2002.11.22.15.05.40;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.04.21.21.42;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.01.20.15.29;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.01.19.47.49;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2000.11.30.11.44.22;	author jberanek;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.52;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.52;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.55.02;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.31.53;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.28.11;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Various CDFS enhancements
* Increase BGET/BPUT buffer declared to FileSwitch to 2k to match the natural sector size (FileSwitch has been able to support this since version 2.28)
* Remove local debug macros, use those from NDRDebug instead
* Change to use SETV/CLRV macros now the ones in HdrSrc are 26/32 neutral
* Clarify those situations where LBA mode is being selected by using symbol 'LBAFormat'
* Extend *WHICHDISC to allow an optional drive number to be provided (the code has existed for years, but the GSTrans flags and help denied its use)

Version 2.60. Tagged as 'CDFS-2_60'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Open

; PROCS:

; NumberOfNextFreeFileHandle
; INFO                              ; RISC OS 2 only
; AnotherDriveHasBeenAdded
; DisplayHeader                     ; RISC OS 2 only
; CheckDiscName
; ValidatePathName
; ShuffleStringUp       ( used by 'Directory' )
; ConvertBufferSizeToReal
; ConvertRealBufferToSize

;**************************************************************************
NumberOfNextFreeFileHandle ; Returns R0 = number of free handle, 0 if fail
;**************************************************************************

        Push    "R1, R3,R14"
                
        ADRL    R1, OpenFileList        ; R1 -> start of list
        MOV     R3, #MAXNUMBEROFOPENFILES

search_for_space                        ; look through list

        LDR     R14, [ R1 ], #4
                
        SUBS    R3, R3, #1
        TEQNE   R14, #0
        BNE     search_for_space
                
        TEQ     R14, #0
        RSBEQ   R0, R3, #MAXNUMBEROFOPENFILES
        MOVNE   R0, #0                  ; If not found then R0 = 0
                
        Pull    "R1, R3,PC"
        
        LTORG


;***************************************************************************
AnotherDriveHasBeenAdded ROUT ; R0 = drive number requested

; If an error, then V set, R0 -> error message

;***************************************************************************

        Push    "R0 - R9, R14"

        ; R5 = drive number requested
        ; R6 = device id
        ; R7 -> sparecontrolblock_offset

        LDRB    R6, numberofdrives      ; already know the drive number
        CMP     R0, R6                  ;
        Pull    "R0 - R9, PC", LO       ; exit, V (almost certainly) clear

;*******************
; Only allow the configured number of drives to be selected
;*******************

        LDR     R6, maxnumberofdrives   ; Error if not configged enough
        TEQ     R6, #0

        SUBNES  R6, R6, #1
        ; If 0 drives configged then make an exception

        RSBHSS  R14, R0, R6
        Pull    "R0 - R9, R14", LO
        
        BLO     baddrive

32

;*******************

; R3 = device id
; R4 = card number
; R5 = LUN
; R6 = drive number requested
; R7 -> control block

        MOV     R3, #0
        MOV     R4, #3

;----------------------------
; Logical unit number support
;----------------------------

        MOV     r5, #0
        MOV     R6, R0
        ADR     R7, sparecontrolblock
        
        ; 1. Find a drive that has been turned on

look_for_device


;**************
; CheckIDKnown                    ;
;**************

; R0 = composite id
; R1 -> list
; R2 -> end of list

        ORR     R0, R3, R4, LSL #3
        ORR     r0, r0, r5, LSL #5

        ADRL    R1, ListOfDrivesAttached ; R1 -> first entry
                
        LDRB    R2, numberofdrives      ; R2 -> last entry
        ADD     R2, R1, R2              ;

04

        LDRB    R14, [ R1 ], #1
                
        CMP     R1, R2
        BHI     %FT05                   ; Reached end of list - so NOT FOUND
                
        TEQ     R14, R0
                
        BNE     %BT04

;***************
; Next device
;***************
01                                      ; Found the drive - so don't bother to check

;---------------------------------
; Support for Logical Unit Numbers
;---------------------------------

        ; Faster because it searches for devices with LUN 0 first
        ADD     r3, r3, #1              ; Next device id
        ANDS    r3, r3, #2_111

        ADDEQ   r5, r5, #1              ; New LUN
        ANDS    r5, r5, #2_111

        TEQEQ   r3, #0
        SUBEQ   r4, r4, #1              ; Next card
        CMPEQ   r4, #-1                 ; Last card reached ?

        BNE     look_for_device

        Pull    "R0 - R9, R14"

        Debug   mi,"AnotherDriveHasBeenAdded returning error"

baddrive
        Push    "r1-r2, r14"
        addr    r0, baddrive_tag
        ADR     r1, message_block
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        Pull    "r1-r2, pc"



;**************
; CheckDevice                     ; Is device a CDROM drive ?
;**************
05
        ; Make sparecontrolblock = device id
        MOV     R8, #0

        ;----------------------------------
        ; Preserve the Logical Unit Numbers
        ;----------------------------------

        STMIA   R7, { R3 - R5, R8 }
        STR     R8, [ R7, #16 ]

        ;-----------------------------------
        ; Not a good idea to forget the LUN
        ;-----------------------------------

06

        ; 2. Add drive number to list

        SWI     XCD_Identify
        BVS     %BT01
        
        CMP     r2, #-1
        BEQ     %BT01
        
        MOV     r9, r2

        ; R9 = drive type

        LDRB    R0, numberofdrives
                
        ADRL    R14, ListOfDrivesAttached
                
        ORR     R2, R3, R4, LSL #3

        ;---------------------------------
        ; Support for logical unit numbers
        ;---------------------------------

        ORR     r2, r2, r5, LSL #5
        STRB    R2, [ R14, R0 ]
                
        ADRL    R14, DriveTypes
        STRB    R9, [ R14, R0 ]
                
        ADD     R0, R0, #1
        STRB    R0, numberofdrives

;************
; Set SCSIControl          ; set the error response of the drive
;************              ;

        MOV     R0, #1
        SWI     XCD_Control             ; R0 = error level, R7 -> control block
                                        
                                        
        LDRB    R0, numberofdrives      ; Another drive been attached ?
                                        ;
        CMP     R0, R6                  ;
                                        ;
                                        
        BLS     look_for_device         
                                        
        Pull    "R0 - R9, PC"           



;***************************************************************************
CheckDiscName ROUT; R0 -> name, RETURNS R1 = TRUE/FALSE
;***************************************************************************

; ISO Spec allows the following characters in a disc name:

;               A - Z             0 - 9        _

; Justin allows the following characters in a disc name:

;               /   (because otherwise I can't open the linux CD)
;               -   (because otherwise I can't open Jan 1998 MSDN Platform
;                    Archive disc 1)
;               ,   (because someone said they'd found a disc that used that)

; JB .. also allow hard space &A0 and lowercase letters
; This routine converts CR to a null

        Push    "R0, R2"

01

        LDRB    R1, [ R0 ], #1
                                        
        TEQ     R1, #&0D                ; Convert CR to null
        TEQNE   R1, #SPACE              ; Convert SPACE to null
        MOVEQ   R1, #0                  ;
        CMP     R1, #32                 
        MOVLE   R1, #0                  
                                        
        STRB    R1, [ R0, #-1 ]         ; Converted to uppercase, and terminated
                                        
        Pull    "R0, R2", LE            ; last entry
        MOVLE   R1, #TRUE               ;
        MOVLE   PC, R14                 ;
                                        
        BIC     R2, R1, #32             ; clear the upper/lowercase bit
        CMP     R2, #"A"                ; characters 'A - Z'
        RSBHSS  R2, R2, #"Z"            ;
        BHS     %BT01                   ;
                                        
        CMP     R1, #"0"                ; characters '0 - 9'
        RSBHSS  R2, R1, #"9"            ;
        BHS     %BT01                   ;
                                        
        TEQ     R1, #"_"                ; character 'underline'
      [ AllowSlashInDiscName            
        TEQNE   R1, #"/"                ; character 'slash' (by Justin)
      ]                                 
      [ AllowHyphenInDiscName           
        TEQNE   R1, #"-"                ; character 'hyphen' (by Justin)
      ]                                 
      [ AllowCommaInDiscName            
        TEQNE   R1, #","                ; character 'comma' (by Justin)
      ]                                 
      [ AllowHardSpaceInDiscName        
        TEQNE   R1, #&A0                ; character 'hard space' (by Jwb)
      ]                                 
        BEQ     %BT01                   ;

02
        Pull    "R0, R2"
        MOV     R1, #FALSE
        MOV     PC, R14

;***************************************************************************
ConvertBufferSizeToReal ROUT ; R0 = CMOS number, RETURNS R1 = size in K
;    FLAGS CORRUPTED
;***************************************************************************

        Push    "R0, R14"

;**************
; Convert number into a Kbytes value
;**************

        TEQ     R0, #0
                
        MOVEQ   R1, #0
                
        MOVNE   R1, #1
        ADDNE   R0, R0, #2
        MOVNE   R1, R1, ASL R0
                
        Pull    "R0, PC"

;***************************************************************************
ConvertRealBufferToSize ROUT    ; R0 = number of K, RETURNS R1 = bit setting
;***************************************************************************

        Push    "R0, R2"

;**************
; Calculate the actual number to go in the CMOSRAM byte
; This is done by taking the top bit set in R0 ( from bits 9 to 0 )
; K    to  number
; 0    to    0
; 8    to    1
; 16   to    2
; 32   to    3
; 64   to    4
; 128  to    5
; 256  to    6
; 512  to    7
;**************

        MVN     R0, R0, ASL #22
        MOV     R2, #7
01                                      ; Top bit set or done enough bits ?
                                        ;
        MOVS    R0, R0, ASL #1          ;
        SUBCSS  R2, R2, #1              ;
        BCS     %BT01                   ; [ no ]


        CMP     R2, #0                  ; R2 = number to go in CMOS RAM
        MOVLT   R1, #0                  ;
        MOVGE   R1, R2

        Pull    "R0, R2"

        MOV     PC, R14

        LTORG

        END
@


4.13
log
@Fix a few bugs
When lining up the code in 2.52, a few bugs became apparent (now the source was readable).
* In a handful of places it was assumed SWIs preserved flags, these have been reordered or branched around.
* The probe of UtilityModule 2.12 has been set to 3.00 and the logic now considers >= 3.00 rather than subtracting 1 from it to deduce the default filename truncation value.
* Removed support for supplemental filetype table in CDFSNewFileTypePath$File as this has been superceded by the MimeMap module (which CDFS uses). This mirrors the behaviour of DOSFS and LanManFS which consult the MimeMap first then (small) internal table second.
* Fix stack imbalance when reading the current setting with CDFS_Truncation leading to an abort

Other changes
* When the MimeMap module is absent ".doc" is taken to be a MS Word document.
* Changed the manual loads from :INDEX: of R12 to be ADR's or ADRL's so there's less literal pool thrashing.
* Three Push/Pull sequences to restore registers swapped for LDMIA's (in Directory.s).
* Reason codes to OS_ SWIs swapped for header file names.


Version 2.56. Tagged as 'CDFS-2_56'
@
text
@d164 1
a164 1
        DebugInline "AnotherDriveHasBeenAdded returning error",NL
@


4.12
log
@Collapse old switches.
Switches from 10+ years ago removed. Demo version switch removed.

Version 2.53. Not tagged
@
text
@d35 1
a35 3
        LDR     R1, =:INDEX:OpenFileList ; R1 -> start of list
        ADD     R1, R1, R12
                
d106 1
a106 1
        ADD     R7, R12, #:INDEX:sparecontrolblock
d124 1
a124 2
        LDR     R1, =:INDEX:ListOfDrivesAttached ; R1 -> first entry
        ADD     R1, R1, R12
d210 1
a210 2
        LDR     R14, =:INDEX:ListOfDrivesAttached
        ADD     R14, R12, R14
a218 1

d221 1
a221 2
        LDR     R14, =:INDEX:DriveTypes
        ADD     R14, R14, R12
@


4.11
log
@Resolve the 32 assembler warnings
Mostly by swapping STASH/GRAB for Push/Pull macros.
Inlined the module header rather than defining it in a header file.
Renamed "Debug" macro to "DebugInline" to avoid clash with similarly named macro.

Version 2.53. Tagged as 'CDFS-2_53'
@
text
@a105 1
      [ Module_Version >= 218
a106 2
      ]

d152 1
a152 4
    [ Module_Version >= 218
      [ Module_Version >= 220

        ; The new way - faster because it searches for devices with LUN 0 first
a161 19
      |
        ADD     r5, r5, #1              ; New LUN
        ANDS    r5, r5, #2_111

        ADDEQ   r3, r3, #1              ; Next device id
        ANDS    r3, r3, #2_111

        TEQEQ   r5, #0
        ADDEQ   r4, r4, #1              ; Next card
        TEQEQ   r4, #4                  ; Last card reached ?
      ]
    |
        ; The old way

        ADD     R3, R3, #1              ; Next device id
        ANDS    R3, R3, #2_111          ; Next card
        ADDEQ   R4, R4, #1              ; Screw the LUN
        TEQEQ   R4, #4                  ; Last card reached ?
    ]
a189 4
     [ Module_Version < 218
        MOV     R5, #0
      ]

a192 3
        ; Request info from drive
        ; Make sure 'Z' set ( ADDS ... )

a196 7
      [ Module_Version < 218

        MOV     R5, #DEVICERETRYCOUNT         ; retry count = 0 ( and 'Z' = 1 )
      ]

;-----------------------------------

a221 2
      [ Module_Version >= 218

a223 2
      ]

@


4.10
log
@Line up sources to normal columns.
Around 25000 spaces required, but rather easier to read as a result - it has revealed some bugs (not addressed in this commit).
Not quite binary identical, because an 'addr' of the ambiguous disc name error has moved by 1 byte due to a missing ALIGN directive.
Not tagged.
@
text
@d33 1
a33 1
        STASH   "R1, R3,R14"
d52 1
a52 1
        GRAB    "R1, R3,PC"
d64 1
a64 1
        STASH   "R0 - R9, R14"
d72 1
a72 1
        GRAB    "R0 - R9, PC", LO       ; exit, V (almost certainly) clear
d85 1
a85 1
        GRAB    "R0 - R9, R14", LO
d190 1
a190 1
        GRAB    "R0 - R9, R14"
d192 1
a192 1
; Debug "AnotherDriveHasBeenAdded returning error",NL
d195 1
a195 1
        STASH   "r1-r2, r14"
d200 1
a200 1
        GRAB    "r1-r2, pc"
d291 1
a291 1
        GRAB    "R0 - R9, PC"           
d313 1
a313 1
        STASH   "R0, R2"
d327 1
a327 1
        GRAB    "R0, R2", LE            ; last entry
d356 1
a356 1
        GRAB    "R0, R2"
d365 1
a365 1
        STASH   "R0, R14"
d379 1
a379 1
        GRAB    "R0, PC"
d385 1
a385 1
        STASH   "R0, R2"
d414 1
a414 1
        GRAB    "R0, R2"
@


4.9
log
@Change drive search order
Detail:
  s/Open - CDFS now searches for drives starting from card 3 instead of card 0.
  This should help things work a bit better when dealing with fake SCSI devices (CDFSSoftATAPI, CDFaker, etc.) - assuming 4 SCSI cards aren't fitted, the fake devices will now all claim the unused SCSI device IDs on card 3 instead of claiming card 0 IDs which may later get used by SCSI or USB devices.
Admin:
  Tested in Iyonix ROM softload


Version 2.50. Tagged as 'CDFS-2_50'
@
text
@d33 22
a54 22
 STASH "R1, R3,R14"

 LDR R1, =:INDEX:OpenFileList       ; R1 -> start of list
 ADD R1, R1, R12                    ;

 MOV R3, #MAXNUMBEROFOPENFILES

search_for_space                    ; look through list

 LDR R14, [ R1 ], #4

 SUBS R3, R3, #1
 TEQNE R14, #0
 BNE search_for_space

 TEQ R14, #0
 RSBEQ R0, R3, #MAXNUMBEROFOPENFILES
 MOVNE R0, #0                       ; If not found then R0 = 0

 GRAB "R1, R3,PC"

 LTORG
d64 1
a64 1
 STASH "R0 - R9, R14"
d66 7
a72 7
; R5 = drive number requested
; R6 = device id
; R7 -> sparecontrolblock_offset

 LDRB R6, numberofdrives           ; already know the drive number
 CMP R0, R6                        ;
 GRAB "R0 - R9, PC", LO            ; exit, V (almost certainly) clear
d78 2
a79 6
 LDR R6, maxnumberofdrives                   ; Error if not configged enough
 TEQ R6, #0
; BEQ %FT32

 SUBNES R6, R6, #1
 ; If 0 drives configged then make an exception
d81 2
a82 2
 RSBHSS R14, R0, R6                          ;
 GRAB "R0 - R9, R14", LO
d84 4
a87 1
 BLO         baddrive
d99 2
a100 2
 MOV R3, #0
 MOV R4, #3
d106 8
a113 14
 [ Module_Version >= 218

          MOV        r5, #0
 ]

;----------------------------

 MOV R6, R0


 ADD R7, R12, #:INDEX:sparecontrolblock


; 1. Find a drive that has been turned on
d126 2
a127 1
 ORR R0, R3, R4, LSL #3
d129 5
a133 13
;----------------------------
; Added for version 2.18
;----------------------------

          ORR        r0, r0, r5, LSL #5

;----------------------------

 LDR R1, =:INDEX:ListOfDrivesAttached  ; R1 -> first entry
 ADD R1, R1, R12                       ;

 LDRB R2, numberofdrives               ; R2 -> last entry
 ADD R2, R1, R2                        ;
d137 8
a144 8
 LDRB R14, [ R1 ], #1

 CMP R1, R2
 BHI %FT05                       ; Reached end of list - so NOT FOUND

 TEQ R14, R0

 BNE %BT04
d149 1
a149 1
01                       ; Found the drive - so don't bother to check
d155 2
a156 27
 [ Module_Version >= 218


   [ Module_Version >= 220

; The new way - faster because it searches for devices with LUN 0 first
          ADD        r3, r3, #1                ; Next device id
          ANDS       r3, r3, #2_111

          ADDEQ      r5, r5, #1                ; New LUN
          ANDS       r5, r5, #2_111

          TEQEQ      r3, #0
          SUBEQ      r4, r4, #1                ; Next card
          CMPEQ      r4, #-1                   ; Last card reached ?

   |

          ADD        r5, r5, #1                ; New LUN
          ANDS       r5, r5, #2_111

          ADDEQ      r3, r3, #1                ; Next device id
          ANDS       r3, r3, #2_111

          TEQEQ      r5, #0
          ADDEQ      r4, r4, #1                ; Next card
          TEQEQ      r4, #4                    ; Last card reached ?
d158 28
a186 3
 |

 ; The old way
d188 1
a188 4
 ADD R3, R3, #1                  ; Next device id
 ANDS R3, R3, #2_111             ; Next card
 ADDEQ R4, R4, #1                ; Screw the LUN
 TEQEQ R4, #4                    ; Last card reached ?
d190 1
a190 7
 ]

;---------------------------------

 BNE look_for_device

 GRAB "R0 - R9, R14"
d195 6
a200 6
            STASH      "r1-r2, r14"
            addr       r0, baddrive_tag
            ADR        r1, message_block
            MOV        r2, #0
            SWI        XMessageTrans_ErrorLookup
            GRAB       "r1-r2, pc"
d208 2
d211 3
a213 21
; Make sparecontrolblock = device id

; STASH R6

 MOV R8, #0


;----------------------------------
; Preserve the Logical Unit Numbers
;----------------------------------

 [ Module_Version < 218

 MOV R5, #0

 ]

;----------------------------

 STMIA R7, { R3 - R5, R8 }
 STR R8, [ R7, #16 ]
d215 3
a217 1
; GRAB R6
d219 2
a220 1
; Request info from drive
d222 2
a223 1
 ; Make sure 'Z' set ( ADDS ... )
d225 3
d229 1
a229 5
;-----------------------------------
; Not a good idea to forget the LUN
;-----------------------------------

 [ Module_Version < 218
d231 2
a232 3
 MOV R5, #DEVICERETRYCOUNT         ; retry count = 0 ( and 'Z' = 1 )

 ]
d238 1
a238 26
; 2. Add drive number to list

 SWI      XCD_Identify
 BVS      %BT01

 CMP      r2, #-1
 BEQ      %BT01

 MOV      r9, r2


; R9 = drive type


 LDRB R0, numberofdrives

 LDR R14, =:INDEX:ListOfDrivesAttached
 ADD R14, R12, R14

 ORR R2, R3, R4, LSL #3

;---------------------------------
; Support for logical unit numbers
;---------------------------------

 [ Module_Version >= 218
d240 35
a274 14
            ORR        r2, r2, r5, LSL #5

 ]

;---------------------------------

 STRB R2, [ R14, R0 ]

 LDR R14, =:INDEX:DriveTypes
 ADD R14, R14, R12
 STRB R9, [ R14, R0 ]

 ADD R0, R0, #1
 STRB R0, numberofdrives
d280 12
a291 12
 MOV R0, #1
 SWI XCD_Control           ; R0 = error level, R7 -> control block


 LDRB R0, numberofdrives   ; Another drive been attached ?
                           ;
 CMP R0, R6                ;
                           ;

 BLS look_for_device

 GRAB "R0 - R9, PC"
d313 1
a313 1
 STASH "R0, R2"
d317 37
a353 40
 LDRB R1, [ R0 ], #1

; UpperCase R1, R2            ; Convert to uppercase

 TEQ R1, #&0D                ; Convert CR to null
 TEQNE R1, #SPACE            ; Convert SPACE to null
 MOVEQ R1, #0                ;
 CMP R1, #32
 MOVLE R1, #0

 STRB R1, [ R0, #-1 ]        ; Converted to uppercase, and terminated

; TEQ R1, #0                  ; Either null terminated or CR terminated
 GRAB "R0, R2", LE           ; last entry
 MOVLE R1, #TRUE             ;
 MOVLE PC, R14               ;

 BIC R2, R1, #32             ; clear the upper/lowercase bit
 CMP R2, #"A"                ; characters 'A - Z'
 RSBHSS R2, R2, #"Z"         ;
 BHS %BT01                   ;

 CMP R1, #"0"                ; characters '0 - 9'
 RSBHSS R2, R1, #"9"         ;
 BHS %BT01                   ;

 TEQ R1, #"_"                ; character 'underline'
 [ AllowSlashInDiscName
 TEQNE R1, #"/"              ; character 'slash' (by Justin)
 ]
 [ AllowHyphenInDiscName
 TEQNE R1, #"-"              ; character 'hyphen' (by Justin)
 ]
 [ AllowCommaInDiscName
 TEQNE R1, #","              ; character 'comma' (by Justin)
 ]
 [ AllowHardSpaceInDiscName
 TEQNE R1, #&A0              ; character 'hard space' (by Jwb)
 ]
 BEQ %BT01                   ;
d356 3
a358 128
 GRAB "R0, R2"
 MOV R1, #FALSE
 MOV PC, R14

 [ {FALSE} ; not used!
;***************************************************************************
ValidatePathName ROUT      ; R0 -> path name
; corrupts 'TempArea'
;***************************************************************************

; This checks a pathname, also converts CR at end to null

; Checks made:
;             1. Path entry is no longer than 'MAXLENGTHOFNAME'
;             2. Number of path entries <= MAXNUMBEROFPATHENTRIES
;             3. Characters in path are ISO valid


 STASH "R0 - R4"

;*******************
; First check the disc name if present ( copy to another area )
;*******************

 LDRB R4, [ R0 ]
 CMP R4, #":"
 BNE %FT02 ;no_disc_name

 ADD R4, R12, #:INDEX:TempArea

 MOV R3, R0

; R3 -> start of path name
; R4 -> TempArea
; R2 = temp


01 ;copy_for_discname_check

 LDRB R2, [ R3, #1 ]!
 STRB R2, [ R4 ], #1
 TEQ R2, #"."
 TEQNE R2, #0

 BNE %BT01 ;copy_for_discname_check

 TEQ R2, #"."

 MOVEQ R2, #0
 STREQB R2, [ R4, #-1 ]

 SUBEQ R3, R3, #1             ; R3 -> start of path name

 BL CheckDiscName             ; R0 -> disc name, RETURNS R1 = TRUE/FALSE

 TEQ R1, #FALSE
          MOVEQ      r0, #ERROR_BADNAME
          BEQ        ErrorExit

 MOV R0, R3                   ; Point R0 at past disc name

;*************
02 ;no_disc_name
;*************

; characters checked for: A - Z  a - z  0 - 9  _ ! $ & ^ * # %

; R0 -> disc name
; R1 = temp
; R4 = number of dots counted

 MOV R4, #0

03 ;validate_path

 LDRB R1, [ R0 ], #1                 ;

 TEQ R1, #"."                        ; Make sure only 8 paths used
 ADDEQ R4, R4, #1                    ;
 TEQEQ R4, #MAXNUMBEROFPATHS         ;
          MOVEQ      r0, #ERROR_BADNAME
          BEQ        ErrorExit


 TEQ R1, #"."
 BEQ %BT03 ;validate_path

 TEQ R1, #"$"
 TEQNE R1, #"%"
 TEQNE R1, #"&"
 TEQNE R1, #"^"
 TEQNE R1, #"/"
 TEQNE R1, #WILDANY
 TEQNE R1, #"@@"
 TEQNE R1, #"!"
 TEQNE R1, #WILDCHAR
 TEQNE R1, #REPLACEMENTFORDOT
 BEQ %BT03 ;validate_path

 CMP R1, #"a"                ; characters 'a - z' converted to upper case
 RSBHSS R2, R1, #"z"         ;
 BHS %BT03 ;validate_path     ;

 CMP R1, #"A"                ; characters 'A - Z'
 RSBHSS R2, R1, #"Z"         ;
 BHS %BT03 ;validate_path     ;

 CMP R1, #"0"                ; characters '0 - 9'
 RSBHSS R2, R1, #"9"         ;
 BHS %BT03 ;validate_path     ;

 CMP R1, #"_"                ; character 'underline'
 BEQ %BT03 ;validate_path     ;

 TEQ R1, #13                         ; Convert CR or LF into null
 TEQNE R1, #0                        ;
 TEQNE R1, #SPACE                    ;

        MOVNE     r0, #ERROR_BADNAME
        BNE       ErrorExit

 SUBS R1, R1, R1
 STRB R1, [ R0, #-1 ]

 GRAB "R0 - R4"

 MOV PC, R14
 ]
d365 1
a365 1
 STASH "R0, R14"
d371 9
a379 11
 TEQ R0, #0

 MOVEQ R1, #0

 MOVNE R1, #1
 ADDNE R0, R0, #2
 MOVNE R1, R1, ASL R0

 GRAB "R0, PC"

; BICS PC, R14, #Overflow_Flag
d385 1
a385 1
 STASH "R0, R2"
d401 7
a407 1
 MVN R0, R0, ASL #22
a408 1
 MOV R2, #7
d410 3
a412 7
01                               ; Top bit set or done enough bits ?
                                 ;
 MOVS R0, R0, ASL #1             ;
                                 ;
 SUBCSS R2, R2, #1               ;
                                 ;
 BCS %BT01                       ; [ no ]
d414 1
d416 1
a416 15
 CMP R2, #0                      ; R2 = number to go in CMOS RAM
                                 ;
 MOVLT R1, #0                    ;
                                 ;
 MOVGE R1, R2

 GRAB "R0, R2"

 MOV PC, R14


;***************************************************************************
;***************************************************************************
;***************************************************************************
;***************************************************************************
d418 1
a418 1
 LTORG
d420 1
a420 1
 END
@


4.8
log
@     	Added RockRidge name extension to CDFS and removed
	the 'force uppercase' constraint to render it
	more user friendly.
Detail:
Admin:  castle added IP .. tested at castle.


Version 2.48. Tagged as 'CDFS-2_48'
@
text
@d101 1
a101 1
 MOV R4, #0
d182 2
a183 2
          ADDEQ      r4, r4, #1                ; Next card
          TEQEQ      r4, #4                    ; Last card reached ?
@


4.7
log
@  Some more bugfixes.
Detail:
  * Return registers for FSEntry_Func 14, 15 and 19 were getting corrupted
    due to stack manipulations, resulting in aborts inside FileSwitch
    whe enumerating some directories
  * Fixed an assumption of flag preservation across the PromptForDisc
    routine (the one that does UpCalls) that led initially to aborts (fixed
    by some top-bit-set safety measures), then later to bogus "CD-ROM drive
    not known" errors when accessig an object on a CD not currently in a
    drive
Admin:
  Tested on Tungsten.

Version 2.44. Tagged as 'CDFS-2_44'
@
text
@d351 1
d360 1
a360 1
 UpperCase R1, R2            ; Convert to uppercase
d375 3
a377 2
 CMP R1, #"A"                ; characters 'A - Z'
 RSBHSS R2, R1, #"Z"         ;
d394 3
d399 1
@


4.6
log
@  A few fixes.
Detail:
  * Fixed a couple of top-bit-set pointer problems
  * Fixed a couple of places where it was assumed that SWIs preserved flags
  * Uses kernel internationalisation for command help, so full tokenisation
    now works properly
  * Added NdrDebug support
Admin:
  Tested on Tungsten.

Version 2.41. Tagged as 'CDFS-2_41'
@
text
@d72 1
a72 1
 GRAB "R0 - R9, PC", LT            ; exit, V (almost certainly) clear
d86 1
a86 1
 GRAB "R0 - R9, R14", LT
d88 1
a88 1
 BLT         baddrive
d154 1
a154 1
 BGT %FT05                       ; Reached end of list - so NOT FOUND
d330 1
a330 1
 BLE look_for_device
@


4.5
log
@  Lots of changes for RISC OS 5.
Detail:
  * Updated to use objasm, shared makefiles and global headers
  * Ripped out lots of RISC OS 2 support code so we can see the wood for the
    trees now
  * 32-bit compatible (a bit of a slog)
  * Now has its own resources phase, replacing the use of the CDFSResources
    module. Also means that messages can now be tokenised properly. For
    good measure, split out CmdHelp tokens into separate file
  * Hopefully fixed more bugs along the way than I introduced. I've seen
    lots of nasty stack imbalances in error cases, but not fixed all of
    them, I'm afraid
Admin:
  Tested briefly on a Risc PC; not enough support modules to run on Tungsten
  yet.

Version 2.38. Tagged as 'CDFS-2_38'
@
text
@d215 1
a215 1
 Debug "AnotherDriveHasBeenAdded returning error",NL
@


4.4
log
@Manual merge of the RISC OS 4.02 version of CDFS (2.37, based upon Acorn's
RiscOS/UnU/OS_Core/FileSys/CDFS/CDFS234 version 2.35).

Tagged as 'CDFS-2_37'
@
text
@d52 1
a52 1
 GRABS "R1, R3,PC"
a56 139
 [ RISC_OS = 2
;***************************************************************************
INFO ROUT ; R0 -> pathname, R1 -> details, R2 -> buffer for info
      ; RETURNS R2 -> end of buffer
; only processes one object !!!!!!!!

;***************************************************************************

 STASH "R0 - R1, R3 - R7, R14"

 ; Format for buffer - filename, WR, filetype, time, date, size

 MOV R7, #HARDSPACE

 MOV R6, R2                    ; R6 -> nice place for next details

 ADD R2, R1, #OBJECTNAMEOFFSET ; R1 -> start of entry

 LDRB R3, [ R2 ], #1           ; No entry there !
 STRB R3, [ R6 ], #1
 TEQ R3, #0                    ;
 SUBEQ R2, R6, #1
 GRABS "R0 - R1, R3 - R7, PC", EQ       ;

that_ex_feeling                ; File name
 LDRB R3, [ R2 ], #1           ;
 STRB R3, [ R6 ], #1           ;
 TEQ R3, #0                    ;
 BNE that_ex_feeling           ;


 SUB R2, R2, R1                          ;  R2 = number of spaces to do
 SUBS R2, R2, #OBJECTNAMEOFFSET + MAXLENGTHOFNAME + 2
                                         ; Pad name with spaces
 SUB R6, R6, #1                          ;
                                         ;
more_spaces                              ;
 STRLTB R7, [ R6 ], #1                   ;
 ADDLTS R2, R2, #1                       ;
 BLT more_spaces

 LDRB R3, [ R1, #OBJECTTYPEOFFSET ]      ; attributes ALL FILES ARE LOCKED !
                                         ; READABLE, owner & public
 TEQ R3, #DIRECTORY                      ; directory
 MOVNE R4, #"L"                          ;
 MOVEQ R4, #"D"                          ;
 STRB R4, [ R6 ], #1                     ;
 MOVNE R4, #"R"                          ; file
 MOVEQ R4, #"L"                          ;
 STRB R4, [ R6 ], #1                     ;
 STRB R7, [ R6 ], #1                     ;
                                         ;
11
 TST R6, #3                              ; Pad with spaces for alignment
 STRNEB R7, [ R6 ], #1                   ;
 BNE %BT11


 LDR R3, [ R1, #LOADADDRESSOFFSET ]      ; R2 = file type
 MOV R2, R3, ASR #8                      ;
 LDR R3, =&FFF                           ;
 AND R2, R2, R3                          ;

 LDRB R3, [ R1, #OBJECTTYPEOFFSET ]      ; could be a directory
 TEQ R3, #DIRECTORY                      ;

 MOVNE R0, #18                           ; reason code to convert file type
                                         ;
 SWINE XOS_FSControl                     ; R2 & R3 = file type string

; ADREQL R4, NAMEDIRECTORY                ; 'Director'
 addr R4, NAMEDIRECTORY, EQ
 LDMEQIA R4, { R2, R3 }                  ;

 STMIA R6!, { R2, R3 }

 MOVEQ R2, #"y"                          ; 'y' of Directory
 MOVNE R2, #HARDSPACE                    ;
 STRB R2, [ R6 ], #1                     ;
 STRB R7, [ R6 ], #1                     ;


; FROM -10 TO -3 STEP 1

 MOV R5, #-10
12
 LDRB R2, [ R6, R5 ]
 TEQ R2, #&20
 STREQB R7, [ R6, R5 ]
 ADD R5, R5, #1
 CMP R5, #-3
 BLE %BT12

 MOV R5, R1

 ADD R0, R1, #TIMEDATEOFFSET           ; TIME
 MOV R1, R6                            ;
 MOV R2, #30                           ;
; ADRL R3, NULL                         ;
 addr R3, NULL
                                       ;
 SWI XOS_ConvertDateAndTime            ; ConvertStandardDateAndTime !!!!
 BVS Error

 STRB R7, [ R1 ], #1                   ; Seperate date from length

 LDR R0, [ R5, #LENGTHOFFSET ]         ; SIZE
 MOV R2, #13                           ; R0 = size, R1->buffer,R2=buffer size
                                       ;
 SWI XOS_ConvertFixedFileSize          ;
 BVS Error


 MOV R5, #3
15
 LDRB  R3, [ R0 ], #1
 TEQ R3, #32
 STREQB R7, [ R0, #-1 ]
 SUBS R5, R5, #1
 BNE %BT15
                                       ;
; STRB R7, [ R0 ]                       ;

14
 TST R1, #3
 STRNEB R7, [ R1 ], #1
 BNE %BT14

 MOV R4, #0
 STRB R4, [ R1, #-1 ]!

 MOV R2, R1

 GRABS "R0 - R1, R3 - R7, PC"

 ]



d72 1
a72 1
 GRABS "R0 - R9, PC", LT           ;
a87 4
 [ RISC_OS=2
 addr R0, BadDrive, LT                      ; Send error back to caller of
 ORRLTS PC, R14, #Overflow_Flag              ; this proc.
 |
a89 2
 ]

a216 5
 [ RISC_OS=2
 addr R0, BadDrive               ; Could not find the drive - so error to
 ORRS PC, R14, #Overflow_Flag    ; caller
 |

d223 1
a223 3
            GRAB       "r1-r2, r14"
            ORRS       pc, r14, #Overflow_Flag
 ]
d332 1
a332 1
 GRABS "R0 - R9, PC"
a335 407
 [ RISC_OS = 2
;***************************************************************************
DisplayHeader ROUT ; R0 -> pathname, R1 = drive number, R2 -> disc buffer
; These are NOT necessarily the CSD settings, can be anything
;***************************************************************************

; R9 -> disc buffer
; R10 = drive number
; R11 = HARDSPACE

 STASH "R0 - R11, R14"


 MOV R9, R2
 MOV R10, R1
 MOV R11, #HARDSPACE

;**************
; Display title string
;**************

                                 ; R1 -> start of current entry
 ADD R2, R12, #:INDEX:TempArea   ; R2 -> buffer for printing later

 MOV R8, R2

;****************
; Find the last leaf in the full pathname
;****************

 MOV R3, R0

; R3->path
; R7 should -> leaf

 MOV R7, R3
02

 LDRB R5, [ R3 ], #1
 TEQ R5, #"."
 MOVEQ R7, R3
 TEQ R5, #0
 BNE %BT02

03
 LDRB R5, [ R7 ], #1
 TEQ R5, #0
 STRNEB R5, [ R2 ], #1
 BNE %BT03

;**********************
; Space between path and disc name
;**********************

; R7 -> last characters displayed

 ADD R7, R8, #MAXLENGTHOFNAME + 8

04
 STRB R11, [ R2 ], #1
 CMP R2, R7

 BLE %BT04

20
 TST R2, #3
 STRNEB R11, [ R2 ], #1
 BNE %BT20

;**********************
; Put 'Disc' in header
;**********************

 LDR R14, DISCstring
 STR R14, [ R2 ], #4

 STRB R11, [ R2 ], #1      ; HARDSPACE

;**********************
; Put in disc name, R4 = drive number
;**********************

 MOV R0, R4
 MOV R1, R2
 MOV R2, R9
 BL GetDiscName              ; R0 = drive number, R1 -> put disc name
 MOV R0, R1
 BL CutSpace                 ; R0 -> name

 MOV R2, R0
26
 LDRB R14, [ R2 ], #1
 CMP R14, #32
 BGT %BT26

 STRB R11, [ R2, #-1 ]
 STRB R11, [ R2 ]
 STRB R11, [ R2 ], #1
21
 TST R2, #3
 STRNEB R11, [ R2 ], #1
 BNE %BT21

 MOV R5, #":"
 STRB R5, [ R2 ], #1

 MOV R0, R4                  ; Drive number of directory display
 MOV R1, R2                  ;
 MOV R2, #6                  ;
 SWI XOS_ConvertCardinal1    ;

 MOV R2, R1



 TST R2, #3                  ; Align to a word
 STRNEB R11, [ R2 ], #1       ;
22
 TST R2, #3                  ;
 STRNEB R11, [ R2 ], #1       ;
 BNE %BT22

 ADR R3, OptionMessage
 LDR R14, =HARDSPACE+(HARDSPACE:SHL:8)+(HARDSPACE:SHL:16)+(SPACE:SHL:24)
 LDMIA R3, { R1, R4, R5, R7 }     ; Option 00 (Off)
 STMIA R2!, { R1, R4, R5, R7, R14 }    ;

23
 TST R2, #3
 STRNEB R11, [ R2 ], #1
 BNE %BT23

;********************************** Urd. .... it through the grapevine

 LDR R14, UrdMessage
 STR R14, [ R2 ], #4

 STRB R11, [ R2 ], #1

;**************
; Has urd been set for this drive ?
; R3 -> start of urd buffer for this drive
;**************

 LDRB R14, numberofdrives      ; R3 -> start of urd buffer
 LDR R3, pointertolibandurd    ;
 MOV R4, #LIBLENGTH            ;
 MLA R3, R14, R4, R3           ;

 [ URDLENGTH <> LIBLENGTH
 MOV R4, #URDLENGTH            ;
 ]
; LDRB R14, CurrentDriveNumber  ; R3 -> correct urd buffer
 MLA R3, R10, R4, R3           ;

 LDRB R14, [ R3 ]
 TEQ R14, #0

 addr R3, Unset, EQ

;****************
; Find the last leaf in the URD
;****************

; R3 -> path
; R7 should -> leaf

 MOV R7, R3

01
 LDRB R5, [ R3 ], #1
 TEQ R5, #"."
 MOVEQ R7, R3
 TEQ R5, #0
 BNE %BT01

;********************
; Put end leaf into buffer R7 -> end URD leaf, R2 -> buffer
;********************

; MOV R8, R2               ; R8 = start of R2 transfer
 ADD R8, R2, #MAXLENGTHOFNAME + 2

end_URD

 LDRB R5, [ R7 ], #1
 STRB R5, [ R2 ], #1
 TEQ R5, #0

 BNE end_URD

;************************
; Seperate URD path from URD drive with spaces
;************************

 STRB R11, [ R2, #-1 ]
 STRB R11, [ R2 ]

space_URD_path

 STRB R11, [ R2 ], #1

 CMP R2, R8

 BLE space_URD_path

 LDRB R5, [ R3 ]
 TEQ R5, #0
 BEQ urd_not_set

;************************
; Put URD drive number into display
;************************

 MOV R0, #":"
 STRB R0, [ R2 ], #1

 MOV R0, R10

 MOV R1, R2                  ; Display current drive number
 MOV R2, #4                  ;
 SWI XOS_ConvertCardinal1    ;

 MOV R2, R1

 STRB R11, [ R2 ], #1

;*************

urd_not_set

24
 TST R2, #3
 STRNEB R11, [ R2 ], #1
 BNE %BT24

;********************************** Dir. .... dir dir durrrr

 LDR R14, DirMessage
 STR R14, [ R2 ], #4

 STRB R11, [ R2 ], #1

 LDR R3, =:INDEX:CSD_path
 ADD R3, R3, R12

;****************
; Find the last leaf in the CSD
;****************

 ADD R8, R2, #MAXLENGTHOFNAME + 2               ; R8 = start of R2 transfer

; R3->path
; R7 should -> leaf

 MOV R7, R3
05

 LDRB R5, [ R3 ], #1
 TEQ R5, #"."
 MOVEQ R7, R3
 TEQ R5, #0
 BNE %BT05

06
 LDRB R5, [ R7 ], #1
 TEQ R5, #0
 STRNEB R5, [ R2 ], #1
 BNE %BT06


;************************
; Seperate CSD path from CSD drive with spaces
;************************

08

 STRB R11, [ R2 ], #1

 CMP R2, R8

 BLE %BT08

;************************
; Put CSD drive number into display
;************************

 MOV R0, #":"
 STRB R0, [ R2 ], #1

 LDRB R0, CurrentDriveNumber

 MOV R1, R2                  ; Display current drive number
 MOV R2, #4                  ;
 SWI XOS_ConvertCardinal1    ;

 MOV R2, R1

;**********************
; Put spaces between CSDDrive and lib name
;**********************

 STRB R11, [ R2 ], #1
 MOV R4, #SPACE
 STRB R4, [ R2 ], #1

25
 TST R2, #3
 STRNEB R4, [ R2 ], #1
 BNE %BT25

;***********************
; Display library directory
;***********************

 LDR R5, LibMessage
 STR R5, [ R2 ], #4

 STRB R11, [ R2 ], #1

;**************
; Has lib been set for this drive ?
;**************

 LDR R3, pointertolibandurd
 MOV R14, #LIBLENGTH
 MLA R3, R14, R10, R3

 LDRB R14, [ R3 ]

 TEQ R14, #0                ;
                            ;
; ADREQL R3, Unset           ; [ no ]
 addr R3, Unset, EQ

;****************
; Find the last leaf in the LIB
;****************


 ADD R8, R2, #MAXLENGTHOFNAME + 2

 MOV R7, R3
08

 LDRB R5, [ R3 ], #1
 TEQ R5, #"."
 MOVEQ R7, R3
 TEQ R5, #0
 BNE %BT08

07
 LDRB R5, [ R7 ], #1
 TEQ R5, #0
 STRNEB R5, [ R2 ], #1
 BNE %BT07


;***********************
; Put in library drive number
;***********************

09

 STRB R11, [ R2 ], #1

 CMP R2, R8

 BLE %BT09

 LDRB R5, [ R3 ]
 TEQ R5, #0
 BEQ lib_not_set

;************************
; Put LIB drive number into display
;************************

 MOV R0, #":"
 STRB R0, [ R2 ], #1

 MOV R0, R10

 MOV R1, R2                  ; Display library drive number
 MOV R2, #4                  ;
 SWI XOS_ConvertCardinal1    ;

lib_not_set

 ADD R0, R12, #:INDEX:TempArea

 SWI XOS_PrettyPrint

 SWI XOS_NewLine
 SWI XOS_NewLine

 GRAB "R0 - R11, PC"

DISCstring = "Disc"
DirMessage = "Dir."
LibMessage = "Lib."
UrdMessage = "Urd."
OptionMessage = "Option 00 (Off)", HARDSPACE
 ALIGN

 ]

d372 1
a372 1
 MOVLES PC, R14              ;
d396 1
a396 1
 MOVS PC, R14
d398 1
a449 4
 [ RISC_OS=2
 addr R0, BadName, EQ
 BEQ Error
 |
d451 1
a451 2
          BEQ        Error
 ]
a473 4
 [ RISC_OS=2
 addr R0, BadName, EQ
 BEQ   Error
 |
d475 1
a475 2
          BEQ        Error
 ]
a511 4
 [ RISC_OS=2
 addr R0, BadName, NE
 BNE Error
 |
d513 1
a513 2
        BNE       Error
 ]
d515 1
a515 1
 MOV R1, #0
d520 2
a521 1
 BICS PC, R14, #Overflow_Flag
d587 1
a587 1
 BICS PC, R14, #Overflow_Flag
@


4.3
log
@This is a manual merge of CDFS 2.35 from RiscOS/UnU/OS_Core/CDFS/CDFS234
treating nturton_CDFS-2_29 as the branch point.
@
text
@d903 7
d941 10
a950 1
 CMP R1, #"_"                ; character 'underline'
@


4.2
log
@  Ursula branch merge, plus srccommit usage.
Detail:
  Merged Ursula branch, it just removed dynamic dependencies from
   Makefile.

  Moved to srccommit, changed lots of occurrences of "Version" to module
   version, as defined in "VersionASM".  Removed old "Version" file.
Admin:
  Added stripdepend call into clean rule.


Version 2.30. Tagged as 'CDFS-2_30'
@
text
@a204 2
 Debug " ANOTHER DRIVE HAS BEEN ADDED "

@


4.1
log
@Initial revision
@
text
@d254 1
a254 1
 [ Version >= 218
d316 1
a316 1
 [ Version >= 218
d319 1
a319 1
   [ Version >= 220
d397 1
a397 1
 [ Version < 218
d419 1
a419 1
 [ Version < 218
d454 1
a454 1
 [ Version >= 218
d665 1
a665 1
 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

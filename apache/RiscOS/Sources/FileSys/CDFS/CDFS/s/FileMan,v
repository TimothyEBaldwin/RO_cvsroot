head	4.13;
access;
symbols
	CDFS-2_63:4.13
	CDFS-2_62:4.12
	CDFS-2_61:4.12
	CDFS-2_60:4.11
	CDFS-2_59:4.10
	CDFS-2_58:4.10
	CDFS-2_57:4.10
	CDFS-2_56:4.10
	CDFS-2_55:4.9
	CDFS-2_54:4.9
	CDFS-2_53:4.7
	CDFS-2_52:4.5
	CDFS-2_51:4.5
	CDFS-2_50:4.5
	CDFS-2_49:4.5
	CDFS-2_48:4.5
	RO_5_07:4.5
	CDFS-2_47:4.5
	CDFS-2_46:4.5
	CDFS-2_45:4.5
	CDFS-2_44:4.4
	CDFS-2_43:4.4
	CDFS-2_42:4.4
	CDFS-2_41:4.4
	CDFS-2_40:4.4
	CDFS-2_39:4.4
	CDFS-2_38:4.4
	CDFS-2_37:4.3
	CDFS-2_35:4.2
	CDFS-2_30:4.1
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	nturton_CDFS-2_29:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_CDFS_2_28:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2016.05.08.16.52.45;	author jlee;	state Exp;
branches;
next	4.12;
commitid	rsdrFYAPguHCrH5z;

4.12
date	2013.08.15.14.25.03;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	5ab0m7C1cVfMFy1x;

4.11
date	2013.08.15.14.13.05;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	6zDw3cu1Q3LIBy1x;

4.10
date	2012.04.22.15.48.27;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	bybtPibvH0K2zS1w;

4.9
date	2012.04.22.11.09.01;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	MNiwWuPGZIIb1R1w;

4.8
date	2012.04.22.11.04.31;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	6PVuneYjhUEDZQ1w;

4.7
date	2012.04.21.21.56.37;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	LsBEkd8YV89lDM1w;

4.6
date	2012.04.16.21.42.01;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	E6l0nP00WOBxH81w;

4.5
date	2002.11.26.17.24.29;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.04.21.21.42;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.01.20.15.29;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2002.11.01.19.47.49;	author bavison;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.51;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.51;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.52.45;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.31.47;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.28.06;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Avoid unnecessary remainder calculations
Detail:
  s/EntryFile, s/FileMan, s/Misc - Avoid unnecessary remainder calculation in DivRem macro
Admin:
  Tested on Cortex-A15


Version 2.63. Tagged as 'CDFS-2_63'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; -> FileMan

;***************************************************************************

;***************************************************************************
;        This handles all of the file manipulating parts
;***************************************************************************

;***************************************************************************

; procedures in here:

; CloseFile
; ControlOpenFile
; FSOperations
; GetByte
; MultiOperations
; OpenFile
; CDFS_Code  (for *CDFS)
; WholeFile

;***************************************************************************
CDFS_Code ROUT
;        Selects filing system when *CDFS is typed
;***************************************************************************

        ;R0 - R6 corruptible
        ;R7 - R11 must be preserved
        
        ; R12 = pointer to latest version of module
        ; R13 = pointer to full descending stack
        ; R14 = return address

        log_on

        Push    "R14"
        
        MOV     R0, #FSControl_SelectFS
        ADR     R1, FilingSystemName    ; Select CDFS
        SWI     XOS_FSControl
        
        Pull    "PC"

StartUpText
        DCB     "Next Technology "      ; let it run on !
title                                   ; identical strings
FilingSystemName
        DCB     "CDFS", 0               ;
        ALIGN

;*************************************************************************
OpenFile ROUT      ;  see page 973
;*************************************************************************

; on entry:
; R0 = 0 for read, 1 for create and update, 2 for update
; R1 -> filename
; R3 = file switch handle for the file
; R6 -> special field, else 0

; on exit:
; R0 = file information word ( see page 974 )
; R1 = file handle used by me
; R2 = buffer size for FS to use
; R3 = file extent ( buffered files only )
; R4 = space currently allocated to file ( buffered files )

; If a directory is opened, THEN it will NOT have bytes requested from it !
; this means that the object type is not needed

; R8 -> disc buffer
        log_on
        
        
        PushAllWithReturnFrame

;**************
; Trying to write to CDROM ?
;**************

        TEQ     R0, #fsopen_ReadOnly    ; Open for read only
        TEQNE   R0, #fsopen_Update      ; Or updating, but no actual writing

        MOVNE   r0, #ERROR_WRITETOCD
        BNE     ErrorExit


        MOV     R0, R1

;*********************************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
        MOV     R1, #2
        BL      Dir
;*********************************

        TEQ     R2, #object_nothing     ; File not found
        PullAllFromFrame EQ
        SUBEQS  R1, R1, R1              ; R1 = 0, also clear V
        MOVEQ   PC, R14
        
        MOV     R8, R3
        
        MOV     r9, r1
        
                                        ; see 'Open' for below proc
        BL      NumberOfNextFreeFileHandle  ; Returns R0 = FileHandle ( 1 - 256 )

        STR     R0, verytemporary       ;


        MOV     R0, #ModHandReason_Claim
        MOV     R3, #SizeOfOpenBuffer   ; 45 bytes claimed
        SWI     XOS_Module

        BVC     %FT01
        PullAllFromFrame                ; if cannot get it, then cry to FS
        LDR     R0, temp1               ;
        SUBS    R1, R1, R1              ; R1 = 0, clear V
        MOV     PC, R14                 ;
01

;***************
; Put details into my small buffer
;***************

        Push    "R1"                    ; add drive number to details
        MOV     R0, R4                  ;
        Push    "R2"
        
        BL      PreGetUniqueNumber      ; R0=drive number, RETURNS R1, R2
        Pull    "R2"
        STR     R1, [ R2, #DISCNUMBEROPEN ]
        
        ADD     R1, R2, #DISCNAMEOPENOFFSET ; add disc name to details
        Push    "R2"
        MOV     R2, R8
        BL      GetDiscName             ; R0 = drive, R1 -> where to put
        MOV     R0, R1                  ; R2 -> disc buffer
        BL      CutSpace                ;
        Pull    "R2"
        Pull    "R1"
                
        STRB    R4, [ R2, #DRIVENUMBEROPEN ]; add drive number to details
                
        LDRB    R3, [ R8, #DiscBuff_DiscMode ]  ; disc mode details

        ;------------------------------------
        ; Added in version 2.23 30-Aug-94
        ; Read mode 2 form 2 files properly
        ;------------------------------------

        ; r3 =  mode of disc
        ; r9 -> Object information

        MACRO__XA_WHAT_DATA_MODE r3, r9, r0, r1

        STRB    R3, [ R2, #DISCMODEOPEN ]
        
        LDR     R3, [ R8, #DiscBuff_BlockSize ] ; add size of block to details
        STR     R3, [ R2, #SIZEOFBLOCKOPEN ]


        ; Work out actual LBA start

        MOV     R7, #myblocksize
        
        DivRem  R8, R7, R3, R14, norem
        
        LDR     R3, [ R1, #LBASTARTOFFSET ] ; add start block to details
        MOV     R3, R3, LSR #8
        
        DivRem  R7, R3, R8, R14, norem
        
        STR     R7, [ R2, #STARTLBAOPEN ]

        ;         ************
        
        LDR     R3, [ R1, #LENGTHOFFSET ] ; add length of file to details
        STR     R3, [ R2, #SIZEOFFILEOPEN ]
        STR     R3, temp1               ; tell FS the size of the file
        
        ;*****************
        
        
        ADRL    R4, OpenFileList - 4       ; Put pointer to claimed memory in list
        LDR     R0, verytemporary          ;
        STR     R2, [ R4, R0, ASL #2 ]     ; R2 -> my small buffer
        
        
        MOV     R3, #0                  ; obj is a dir, so set info word for FS
        
        LDRB    R2, [ R1, #OBJECTTYPEOFFSET ]
        TEQ     R2, #object_directory           
        ORREQ   R3, R3, #1:SHL:29        
        
        
        LDRB    R2, [ R1, #FILEATTRIBUTESOFFSET ] ; read is permitted from this entry
        TST     R2, #2_10001      
        ORRNE   R3, R3, #1:SHL:30 
        STR     R3, temp2         
        
        PullAllFromFrame
        
        LDR     R0, temp2               ; info word for FileSwitch about entry
                
        LDR     R1, verytemporary       ; file handle
                
        MOV     R2, #FSBUFFERSIZE       ; size of buffer that FileSwitch should use
                
        LDR     R3, temp1               ; file extent
        
        ADDS    R4, R3, #0              ; space currently allocated to file; clear V
        
        MOV     PC, R14


;***************************************************************************
GetByte ROUT      ; see page 975
;
; on entry:
;          r1 = my file handle
;          r2 = memory address to put data
;          r3 = number of bytes to read
;          r4 = file offset to get data from
; on exit:
;          preserve all registers except for usual error blocks in r0
;***************************************************************************

; on exit:
;         nothing

; temp1 = disc number
; bufferedblockdiscnumber
; bufferedblocknumber

; R7 = blocksize, R10 = blocksize ( in loop )
; R8 = block
; R11 = memory address to put data at    SEE IN LOOP FOR MORE FIXS !


        PushAllWithReturnFrame
        
        Debug   fs,"Get byte"

        MOV     r11, r2
        
        ADRL    r5, OpenFileList - 4    ; R6 -> my little buffer of entry details
        LDR     r6, [ r5, r1, LSL #2 ]

;******************
; Make sure that correct disc is in drive
;******************

        LDR     r5, [ r6, # DISCNUMBEROPEN ]
        LDRB    r0, [ r6, # DRIVENUMBEROPEN ]
        MOV     r2, # 1
        BL      GetUniqueNumber         ; R0 = drive number, RETURNS R1 = number
                                        ; R2 = 1 no error
        STR     r1, temp1
                                        ; R2 = 0 if error, else RETURNS R1=0
        TEQ     r1, r5
        
        MOV     r1, r0
        ADDNE   r0, r6, # DISCNAMEOPEN
        BLNE    PromptForDisc           ; R0 -> disc name, R1 = drive number


;******************


        LDR     r5, [ r6, # STARTLBAOPEN ] ; R4 = start LBA of load
        LDRB    r0, [ r6, # DISCMODEOPEN ]
        ADR     r7, sparecontrolblock
        
        TEQ     r0, # 2
        BNE     GB_Ordinary

        BL      ChangeDiscMode          ; R0 = mode, R7 -> control block


        ;----------------------------------
        ; Where is the byte of user data ?
        ;----------------------------------
        MOV     r1, r5
        MOV     r0, #LBAFormat
        MOV     r2, r4
        
        SWI     XCD_SeekUserData
        BVS     ErrorExit
        
        MOV     r4, r2

; R0  =
; R1  = start block
; R2  =
; R3  = number of bytes to load
; R4  = start byte
; R5  =
; R6  =
; R7  -> controlblock
; R8  =
; R9  =
; R10 =
; R11 -> where to put data
; R14 =

        MOV     r0, #LBAFormat
        MOV     r2, r3
        MOV     r3, r11
        SWI     XCD_ReadUserData
        BVS     ErrorExit
        
        PullAllFromFrameAndExit

;----------------------------------------------------------------------------------------------
; This loads data in for normal mode 1 discs
;----------------------------------------------------------------------------------------------

GB_Ordinary

        BL      ChangeDiscMode          ; R0 = mode, R7 -> control block


        MOV     R0, #1
                
                
        LDR     R10, [ R6, #SIZEOFBLOCKOPEN ]

                                        ; work out where to start from:
                                        ; R4 = offset to get data from

        ADD     R6, R4, R3              ; R9 = file offset + number of bytes to read
        
        DivRem  R0, R4, R10, R14        ; R0 = block to read from
        ADD     R0, R0, R5              ; R4 = bytes offset in a block to read from
        
        
        DivRem  R2, R6, R10, R14        ; R2 = block to end at
        ADD     R2, R2, R5              ; R6 = bytes offset in a block to end at
        
        ADR     R7, sparecontrolblock

; R0 = start block
; R1 = drive number
; R2 = end block
; R3
; R4 = start byte
; R5 = number to load
; R6 = endbyte
; R7 -> controlblock
; R8 =
; R9 =
; R10 = blocksize
; R11 -> where to put data
; R14 =

;          . If the byte to start from is not 0 THEN
;          .                                    {
;          .                                     load a block into my buffer
;          .                                     copy out whats needed
;          .                                     add 1 to start block
;          .                                    }

        TEQ     R4, #0
        BEQ     %FT01
        
        Push    "R0-R3"
        
        MOV     R3, R1
        
        MOV     R2, #1
        
        BL      PreLoadBlockFromDrive   ; r1->buffer

        ; This assumes that I am not asked for 0 bytes
        ;
        ; if (end byte==0) THEN
        ;     Copy from r1+start byte, r11, length (blocksize-start byte)
        ; else
        ;     IF (end block==start block)
        ;         Copy from r1+start byte, r11, length (end byte-start byte)
        ;     else
        ;         Copy from r1+start byte, r11, length (blocksize-start byte)

        ADD     R1, R1, R4
        MOV     R2, R11
        
        TEQ     R6, #0
        SUBEQ   R3, R10, R4
        BEQ     %FT11
        
        TEQ     R2, R0
        SUBNE   R3, R10, R4
        SUBEQ   R3, R6, R4

11
        ADD     R11, R11, R3            ; Move to further along the buffer
                                        
        CD_ByteCopy                     
                                        
        Pull    "R0-R3"                   
                                        
        ADD     R0, R0, #1              ; start block++
                                        
        MOV     R4, #0                  ; start byte=0

01

;          . if (start block < end block)
;          .    {

        CMP     R0, R2
        BGE     %FT02

;          .     if (end byte ==0 (or blocksize ?) )
;          .        number_to_load=end block-start block

        SUB     R5, R2, R0

;          .    else
;          .        number_to_load=(end block-start block)-1
;          .
;          .     if (number_to_load > 0)

        CMP     R5, #0

;          .         load number_to_load blocks into users area


        BLE     %FT02
                
        Push    "R1-R3"
                
        MOV     R3, R1
        MOV     R1, R11
        MOV     R2, R5
                
        BL      LoadBlockFromDrive
                
        Pull    "R1-R3"
                
        ADD     R0, R0, R5

      [ myblocksize<>2048
        ! 0, "AAAAAAAAa see fileman"
      ]
        ADD     R11, R11, R5, LSL #11

;          .    }

02

;          . if (end_byte !=0 )

        TEQ     R6, #0
        BEQ     %FT04

;          .    {
;          .     load a block into my buffer

        MOV     R2, #1
        MOV     R3, R1
        BL      PreLoadBlockFromDrive

;          .     copy out whatevers needed
;          .    }

        MOV     R2, R11
        MOV     R3, R6
        CD_ByteCopy

04

        CLRV
        PullAllFromFrameAndExit

;***************************************************************************
ControlOpenFile ROUT   ; see page 979 ( FSEntry_Args )
;***************************************************************************

        PushAllWithReturnFrame
        log_on
        
        CMP     R0, #(EndOfJumpTableForFSEntry_Args-StartOfJumpTableForFSEntry_Args)/4
        
        PullAllFromFrameAndExit HS
        
        
        LDR     r14, [ pc, r0, LSL #2 ]
        ADD     pc, pc, r14

StartOfJumpTableForFSEntry_Args

        ; 0. Read sequential pointer for unbuffered file
        DCD     Nothing - StartOfJumpTableForFSEntry_Args - 4
        
        ; 1. Write sequential pointer
        DCD     SaveFile - StartOfJumpTableForFSEntry_Args - 4
        
        ; 2. Reads the size of the file of unbuffered
        DCD     Nothing - StartOfJumpTableForFSEntry_Args - 4
        
        ; 3. Writes the size of the file
        DCD     SaveFile - StartOfJumpTableForFSEntry_Args - 4
        
        ; 4. Reads the size of the file (all types)
        DCD     ReadSizeAllocatedToFile - StartOfJumpTableForFSEntry_Args - 4
        
        ; 5. EOF check for unbuffered files
        DCD     Nothing - StartOfJumpTableForFSEntry_Args - 4
        
        ; 6. Flush buffers, if bit 27 was set
        DCD     Nothing - StartOfJumpTableForFSEntry_Args - 4
        
        ; 7. Ensure the size of the file (all types)
        DCD     ReadSizeAllocatedToFile - StartOfJumpTableForFSEntry_Args - 4
        
        ; 8. Write zeros to a file
        DCD     SaveFile - StartOfJumpTableForFSEntry_Args - 4
        
        ; 9. Read the date stamp of the file
        DCD     ReadFileDateStamp - StartOfJumpTableForFSEntry_Args - 4

EndOfJumpTableForFSEntry_Args


;----------------------------------------------------------------------------------------------
CloseFile ROUT
;
; see page 983   DONE
; on entry:
;          R1 = my file handle
;          R2 = new load address
;          R3 = new execution address
;----------------------------------------------------------------------------------------------

        PushAllWithReturnFrame

;******************
; Free the claimed buffer used for the open file details
;******************

        ADRL    R3, OpenFileList - 4
        LDR     R2, [ r3, r1, LSL #2 ]!
                
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module

;******************
; Remove the buffer from the list
;******************

        SUBS    R0, R0, R0  ; clears V
        STR     R0, [ R3 ]

        PullAllFromFrameAndExit

;----------------------------------------------------------------------------------------------
WholeFile ROUT
; on entry:
;          r0 = reason code
; on exit:
;
;
; see PRM2 page 983 ( FSEntry_File )  see 'EntryFile'
;----------------------------------------------------------------------------------------------

        log_on

        PushAllWithReturnFrame
        
        TEQ     R0, #255                ; MUST BE HERE BEFORE ENDOFTABLECHECK !!!!!
        BEQ     LoadFile                ; DONE

        ; Make sure that the reason code is supported by me

        CMP     R0, #( EndOfJumpTableForFSEntry_File - JumpTableForFSEntry_File ) / 4
        PullAllFromFrameAndExit HS
        
        LDR     r14, [ pc, r0, LSL #2 ]
        ADD     pc, pc, r14

JumpTableForFSEntry_File

        DCD     SaveFile - JumpTableForFSEntry_File - 4 ; 0  n / a       DONE
        DCD     SaveFile - JumpTableForFSEntry_File - 4 ; 1  n / a       DONE
        DCD     SaveFile - JumpTableForFSEntry_File - 4 ; 2  n / a       DONE
        DCD     SaveFile - JumpTableForFSEntry_File - 4 ; 3  n / a       DONE
        DCD     SaveFile - JumpTableForFSEntry_File - 4 ; 4  n / a       DONE
        DCD     ReadCatalogue - JumpTableForFSEntry_File - 4 ; 5  used to find an object
        DCD     SaveFile - JumpTableForFSEntry_File - 4 ; 6  n / a       DONE
        DCD     SaveFile - JumpTableForFSEntry_File - 4 ; 7  n / a       DONE
        DCD     SaveFile - JumpTableForFSEntry_File - 4 ; 8  n / a       DONE
        DCD     Nothing - JumpTableForFSEntry_File - 4  ; 9  only called if bit 26 set ( not supported )
        DCD     ReadBlockSize - JumpTableForFSEntry_File - 4 ; 10        DONE natural block size

EndOfJumpTableForFSEntry_File

;----------------------------------------------------------------------------------------------
FSOperations ROUT
;
; on entry:
;          r0 = reason code
;          r1 - r6 depends on reason code
; on exit:
;
;  see page 988 ( FSEntry_Func )
;
;      These are to be found in 'Filer'
;----------------------------------------------------------------------------------------------

        log_on
        
        PushAllWithReturnFrame

        ; Make sure that the reason code is supported by me
        CMP     R0, #( EndOfJumpTableForFSEntry_Func - JumpTableForFSEntry_Func ) / 4
        PullAllFromFrameAndExit HS
        
        LDR     r14, [ pc, r0, LSL #2 ]
        ADD     pc, pc, r14

JumpTableForFSEntry_Func

        ; Under RISC OS 3 this is done for me
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 0  *DIR
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 1  *LIB
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 2  *CAT
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 3  *EX
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 4  *LCAT
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 5  *LEX
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 6  *INFO
                                                                 
        DCD     SaveFile - JumpTableForFSEntry_Func - 4          ; 7  *OPT
        DCD     SaveFile - JumpTableForFSEntry_Func - 4          ; 8  *RENAME
        DCD     SaveFile - JumpTableForFSEntry_Func - 4          ; 9  *ACCESS
      [ BootFromCD                                               
        DCD BootFromCDFS - JumpTableForFSEntry_Func - 4          ; 10  attempt to boot from CD - yay, lets do this!
      |                                                          
        DCD Nothing - JumpTableForFSEntry_Func - 4               ; 10  attempt to boot from CD - ignore
      ]

        ; Under RISC OS 3 this is done for me
        DCD     ReadBoot_OS3 - JumpTableForFSEntry_Func - 4      ; 11 Get disc name
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 12 Read dir name
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 13 Read lib name
                
        DCD     CurrentDirObjects - JumpTableForFSEntry_Func - 4 ; 14
        DCD     ObjectInfo - JumpTableForFSEntry_Func - 4        ; 15
        DCD     Shutdown - JumpTableForFSEntry_Func - 4          ; 16 *SHUTDOWN
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 17 not used -see 'Information Block'
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 18 SET DIR CONTEXTS not used (bit 24)
        DCD     ReadEntriesAndLength - JumpTableForFSEntry_Func - 4; 19 READ DIR ENTRIES
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 20 *FileInfo not used (bit 25)
                
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 21 notification of new image (RISC OS3)
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 22 image about to be closed (RISC OS3)
        DCD     CanonicaliseName - JumpTableForFSEntry_Func - 4  ; 23 Canoncalise name (RISC OS3)
        DCD     ResolveWildcard - JumpTableForFSEntry_Func - 4   ; 24 Get a complete file name
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 25 Read defect list
        DCD     SaveFile - JumpTableForFSEntry_Func - 4          ; 26 Add a defect to the list
      [ BootFromCD
        DCD     ReadBoot2 - JumpTableForFSEntry_Func - 4         ; 27 Read boot option 2
      |
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 27 Read boot option 2
      ]
        DCD     SaveFile - JumpTableForFSEntry_Func - 4          ; 28 Write boot option
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 29 Read used space map
        DCD     ReadFreeSpace - JumpTableForFSEntry_Func - 4     ; 30 Read free space
        DCD     SaveFile - JumpTableForFSEntry_Func - 4          ; 31 Name image
        DCD     SaveFile - JumpTableForFSEntry_Func - 4          ; 32 Stamp image
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 33 Get usage of offset
        DCD     Nothing - JumpTableForFSEntry_Func - 4           ; 34 Notification of changed directory
        DCD     ReadFreeSpace64 - JumpTableForFSEntry_Func - 4   ; 35 Read 64-bit free space

EndOfJumpTableForFSEntry_Func


;************* End of jump table

;****************
;MultiOperations    ; see page 998 ( FSEntry_GBPB ) not used ( bit 28 in Open)
;****************

        LTORG

        END
@


4.12
log
@Add support for Joliet format CD-ROMs
hdr/Hashes
s/Directory
s/EntryFile
s/FileMan
s/Filer
s/Free
 - mass search and replace of lots of poorly named definitions, removing unused ones, creating implicit ones
hdr/MyMacros
 - shuffle some registers in ConvertToArchyDate to save one temporary so it can be used for something else
 - moved ReplaceBadCharacters here
hdr/Options
 - extra debug option
s/DiscOp
 - add Joliet, rename buffer indicies per hdr/Hashes
 - the fallback filetype assignment (when neither the ARCHIMEDES system extension nor MimeMap can help) can now be overridden by setting CDFS$DefaultType (which defaults to &FFD)
s/SWI
 - remove DAT<->MPEG mapping from the internal mapping table
s/Variables
 - trim out unused SWI_buffer reservation

Tested with valid ISO/Joliet/RockRidge supported combinations, documented in Docs/Combos, and accompanying test ISO images now stored there.
Tested with CD-I format disc 'Jigsaw' from Britannica.
Tested with High Sierra format disc 'Kings Quest V'.
Tested with photo CD sampler from Kodak.

Version 2.61. Tagged as 'CDFS-2_61'
@
text
@d184 1
a184 1
        DivRem  R8, R7, R3, R14
d189 1
a189 1
        DivRem  R7, R3, R8, R14
@


4.11
log
@Various CDFS enhancements
* Increase BGET/BPUT buffer declared to FileSwitch to 2k to match the natural sector size (FileSwitch has been able to support this since version 2.28)
* Remove local debug macros, use those from NDRDebug instead
* Change to use SETV/CLRV macros now the ones in HdrSrc are 26/32 neutral
* Clarify those situations where LBA mode is being selected by using symbol 'LBAFormat'
* Extend *WHICHDISC to allow an optional drive number to be provided (the code has existed for years, but the GSTrans flags and help denied its use)

Version 2.60. Tagged as 'CDFS-2_60'
@
text
@d162 1
a162 1
        LDRB    R3, [ R8, #DISCMODEOFFSETINABUFFER ]  ; disc mode details
d176 1
a176 1
        LDR     R3, [ R8, #BLOCKSIZEOFFSETINABUFFER ] ; add size of block to details
d261 1
@


4.10
log
@Fix a few bugs
When lining up the code in 2.52, a few bugs became apparent (now the source was readable).
* In a handful of places it was assumed SWIs preserved flags, these have been reordered or branched around.
* The probe of UtilityModule 2.12 has been set to 3.00 and the logic now considers >= 3.00 rather than subtracting 1 from it to deduce the default filename truncation value.
* Removed support for supplemental filetype table in CDFSNewFileTypePath$File as this has been superceded by the MimeMap module (which CDFS uses). This mirrors the behaviour of DOSFS and LanManFS which consult the MimeMap first then (small) internal table second.
* Fix stack imbalance when reading the current setting with CDFS_Truncation leading to an abort

Other changes
* When the MimeMap module is absent ".doc" is taken to be a MS Word document.
* Changed the manual loads from :INDEX: of R12 to be ADR's or ADRL's so there's less literal pool thrashing.
* Three Push/Pull sequences to restore registers swapped for LDMIA's (in Directory.s).
* Reason codes to OS_ SWIs swapped for header file names.


Version 2.56. Tagged as 'CDFS-2_56'
@
text
@d260 1
d301 1
a301 1
        MOV     r0, # LBAFormat
d323 1
a323 1
        MOV     r0, # LBAFormat
d490 1
a490 1
        VCLEAR
@


4.9
log
@Exchange local definitions for central ones.
Hdr:HighFSI LowFSI Services CDROM CMOS UpCall and CDFS now used in preference to local definitions.
Macro 'Command' used to build the keyword table.
Some asserts added for safety.


Version 2.54. Tagged as 'CDFS-2_54'
@
text
@d52 1
a52 1
        MOV     R0, #14                 ; Reason code
d128 1
a128 1
        MOV     R0, #6                  ; claim some memory for my little buffer
d202 1
a202 2
        LDR     R4, =:INDEX:OpenFileList-4 ; Put pointer to claimed memory in list
        ADD     R4, R4, R12                ;
d262 1
a262 2
        LDR     r5, =:INDEX:OpenFileList - 4 ; R6 -> my little buffer of entry details
        ADD     r5, r5, r12
d356 1
a356 1
        ADD     R7, R12, #:INDEX:sparecontrolblock
d558 1
a558 2
        LDR     R3, =:INDEX:OpenFileList - 4
        ADD     R3, R3, R12
d561 2
a562 2
        MOV     R0, #7                  ; Free memory
        SWI     XOS_Module              ;
@


4.8
log
@Collapse old switches.
Switches from 10+ years ago removed. Demo version switch removed.

Version 2.53. Not tagged
@
text
@d33 1
a33 1
; SelectFilingSystem               ( *CDFS )
d37 1
a37 1
SelectFilingSystem ROUT
d95 2
a96 2
        TEQ     R0, #READONLY           ; Open for read only
        TEQNE   R0, #UPDATEONLY         ; Or updating, but no actual writing
d113 1
a113 1
        TEQ     R2, #NOTFOUND           ; File not found
d211 1
a211 1
        TEQ     R2, #DIRECTORY           
@


4.7
log
@Resolve the 32 assembler warnings
Mostly by swapping STASH/GRAB for Push/Pull macros.
Inlined the module header rather than defining it in a header file.
Renamed "Debug" macro to "DebugInline" to avoid clash with similarly named macro.

Version 2.53. Tagged as 'CDFS-2_53'
@
text
@a89 8
      [ demoversion=ON
        LDR     R14, demotries          ; For demo version
        ADD     R14, R14, #1            ; Lock up if done enough
        STR     R14, demotries          ;
        CMP     R14, #NUMBEROFDEMOTRIES 
        MOVGE   R14, #0
        MOVGE   PC, R14
      ]
a589 9
      [ demoversion=ON
        LDR     R14, demotries          ; For demo version
        ADD     R14, R14, #1            ; Lock up if done enough
        STR     R14, demotries          ;
        CMP     R14, #NUMBEROFDEMOTRIES ;
        MOVGE   R14, #0                 ;
        MOVGE   PC, R14                 ;
      ]
        
a633 9
      [ demoversion=ON
        LDR     R14, demotries          ; For demo version
        ADD     R14, R14, #1            ; Lock up if done enough
        STR     R14, demotries          ;
        CMP     R14, #NUMBEROFDEMOTRIES ;
        MOVGE   R14, #0                 ;
        MOVGE   PC, R14                 ;
      ]

@


4.6
log
@Line up sources to normal columns.
Around 25000 spaces required, but rather easier to read as a result - it has revealed some bugs (not addressed in this commit).
Not quite binary identical, because an 'addr' of the ambiguous disc name error has moved by 1 byte due to a missing ALIGN directive.
Not tagged.
@
text
@d50 1
a50 1
        STASH   R14
a52 1
        
a53 1
        
d56 1
a56 1
        GRAB    PC
d89 1
a89 1
        STASHALL
d122 1
a122 1
        GRABALL EQ
d141 1
a141 1
        GRABALL                         ; if cannot get it, then cry to FS
d151 1
a151 1
        STASH   R1                      ; add drive number to details
d153 1
a153 1
        STASH   R2
d156 1
a156 1
        GRAB    R2
d160 1
a160 1
        STASH   R2
d165 2
a166 2
        GRAB    R2
        GRAB    R1
d228 1
a228 1
        GRABALL
d267 1
a267 1
        STASHALL
d338 1
a338 1
        GRABALLANDRETURN
d392 1
a392 1
        STASH   R0-R3
d426 1
a426 1
        GRAB    R0-R3                   
d457 1
a457 1
        STASH   "R1-R3"
d465 1
a465 1
        GRAB    "R1-R3"
d500 1
a500 1
        GRABALLANDRETURN
d506 1
a506 1
        STASHALL
d511 1
a511 1
        GRABALLANDRETURN HS
d562 1
a562 1
        STASHALL
d582 1
a582 1
        GRABALLANDRETURN
d596 1
a596 1
        STASHALL
d613 1
a613 1
        GRABALLANDRETURN HS
d649 1
a649 1
        STASHALL
d662 1
a662 1
        GRABALLANDRETURN HS
@


4.5
log
@  Nice new features.
Detail:
  * Reenabled BootFromCD option, and finished it off (so FSFunc_ReadBoot
    returns 2 (Run) to match the enforced action on booting); booting
    command line changed to "Run $.!BOOT"
  * Added 32-bit and 64-bit ReadFreeSpace FSFunc entries
  * Added support for interfacing with the Free module (so *ShowFree -FS CDFS
    now works)
  * Added missing * in syntax messags for *Lock and *Unlock
Admin:
  Tested on Tungsten.

Version 2.45. Tagged as 'CDFS-2_45'
@
text
@d41 25
a65 26
 ALIGN

 ;R0 - R6 corruptible
 ;R7 - R11 must be preserved

 ; R12 = pointer to latest version of module
 ; R13 = pointer to full descending stack
 ; R14 = return address

 log_on

 STASH R14

 MOV R0, #14                ; Reason code

 ADR R1, FilingSystemName   ; Select CDFS

 SWI XOS_FSControl

 GRAB PC

StartUpText = "Next Technology "     ; let it run on !
title                                ; identical strings
FilingSystemName = "CDFS", 0         ;

 ALIGN
d88 12
a99 12
 log_on


 STASHALL
 [ demoversion=ON
 LDR R14, demotries                   ;For demo version
 ADD R14, R14, #1                       ; Lock up if done enough
 STR R14, demotries                   ;
 CMP R14, #NUMBEROFDEMOTRIES  ;
 MOVGE R14, #0                          ;
 MOVGE PC, R14                          ;
 ]
d105 2
a106 2
 TEQ R0, #READONLY              ; Open for read only
 TEQNE R0, #UPDATEONLY          ; Or updating, but no actual writing
d108 2
a109 2
          MOVNE       r0, #ERROR_WRITETOCD
          BNE         ErrorExit
d112 1
a112 1
 MOV R0, R1
d119 2
a120 2
 MOV R1, #2
 BL Dir
d123 24
a146 29
 TEQ R2, #NOTFOUND              ; File not found
 GRABALL EQ
 SUBEQS R1, R1, R1 ; R1 = 0, also clear V
 MOVEQ PC, R14

 MOV R8, R3

 MOV      r9, r1

                                ; see 'Open' for below proc
 BL NumberOfNextFreeFileHandle  ; Returns R0 = FileHandle ( 1 - 256 )

; TEQ R0, #0                     ; could not find a free place
; ADREQL R0, InternalError       ; FS or me screwed up
; BEQ ErrorExit                      ;

 STR R0, verytemporary          ;


 MOV R0, #6                     ; claim some memory for my little buffer
 MOV R3, #SizeOfOpenBuffer      ; 45 bytes claimed

 SWI XOS_Module

 BVC %FT01
 GRABALL                        ; if cannot get it, then cry to FS
 LDR R0, temp1                  ;
 SUBS R1, R1, R1 ; R1 = 0, clear V
 MOV PC, R14                    ;
d153 90
a242 125
 STASH R1                         ; add drive number to details
 MOV R0, R4                       ;
 STASH R2
; MOV R2, #0
 BL PreGetUniqueNumber            ; R0=drive number, RETURNS R1, R2
 GRAB R2
 STR R1, [ R2, #DISCNUMBEROPEN ]  ;

 ADD R1, R2, #DISCNAMEOPENOFFSET  ; add disc name to details
 STASH R2
 MOV R2, R8
 BL GetDiscName                   ; R0 = drive, R1 -> where to put
 MOV R0, R1                       ; R2 -> disc buffer
 BL CutSpace                      ;
 GRAB R2
 GRAB R1                          ;

 STRB R4, [ R2, #DRIVENUMBEROPEN ]; add drive number to details

 LDRB R3, [ R8, #DISCMODEOFFSETINABUFFER ]  ; disc mode details

;------------------------------------
; Added in version 2.23 30-Aug-94
; Read mode 2 form 2 files properly
;------------------------------------

; r3 =  mode of disc
; r9 -> Object information

 MACRO__XA_WHAT_DATA_MODE r3, r9, r0, r1

;------------------------------------

 STRB R3, [ R2, #DISCMODEOPEN ]             ;

 LDR R3, [ R8, #BLOCKSIZEOFFSETINABUFFER ]; add size of block to details
 STR R3, [ R2, #SIZEOFBLOCKOPEN ] ;


; Work out actual LBA start

 MOV R7, #myblocksize

 DivRem R8, R7, R3, R14

 LDR R3, [ R1, #LBASTARTOFFSET ]  ; add start block to details
 MOV R3, R3, LSR #8

 DivRem R7, R3, R8, R14

 STR R7, [ R2, #STARTLBAOPEN ]    ;

;------------------------------------
; Added in version 2.22
; Read mode 2 form 2 files properly
;------------------------------------

; STASH     "r0-r7"

; LDRB      r3, [ r2, # DISCMODEOPEN ]

; TEQ       r3, # 1
; BEQ       OF_SkipModeCheck

;; Get a control block
; MOV       r0, r4
; BL        PreConvertDriveNumberToDeviceID   ; R0 = drive number, R7 -> sparecontrolblock
; BVS       OF_SkipModeCheck

;; EnquireDataMode on the start block
; MOV       r0, # LBAFormat
; LDR       r1, [ r2, # STARTLBAOPEN ]
; SWI       XCD_EnquireDataMode
; BVS       OF_SkipModeCheck

; TEQ       r0, # 2
; STREQB    r0, [ r2, # DISCMODEOPEN ]


;OF_SkipModeCheck

; GRAB      "r0-r7"

;------------------------------------

;         ************

 LDR R3, [ R1, #LENGTHOFFSET ]    ; add length of file to details
 STR R3, [ R2, #SIZEOFFILEOPEN ]  ;
 STR R3, temp1                    ; tell FS the size of the file

;*****************


 LDR R4, =:INDEX:OpenFileList-4 ; Put pointer to claimed memory in list
 ADD R4, R4, R12                ;
 LDR R0, verytemporary          ;
 STR R2, [ R4, R0, ASL #2 ]     ; R2 -> my small buffer


 MOV R3, #0                     ; obj is a dir, so set info word for FS

 LDRB R2, [ R1, #OBJECTTYPEOFFSET ]
 TEQ R2, #DIRECTORY             ;
 ORREQ R3, R3, #1:SHL:29        ;


 LDRB R2, [ R1, #FILEATTRIBUTESOFFSET ]; read is permitted from this entry
 TST R2, #2_10001          ;
 ORRNE R3, R3, #1:SHL:30        ;   ORREQ
 STR R3, temp2                  ;

 GRABALL

 LDR R0, temp2                   ; info word for FileSwitch about entry

 LDR R1, verytemporary           ; file handle

 MOV R2, #FSBUFFERSIZE           ; size of buffer that FileSwitch should use

 LDR R3, temp1                   ; file extent

 ADDS R4, R3, #0                 ; space currently allocated to file; clear V

 MOV PC, R14
d269 7
a275 7
 STASHALL

 MOV        r11, r2

 LDR        r5, =:INDEX:OpenFileList - 4 ; R6 -> my little buffer of entry details
 ADD        r5, r5, r12                  ;
 LDR        r6, [ r5, r1, LSL #2 ]       ;
d281 12
a292 12
 LDR        r5, [ r6, # DISCNUMBEROPEN ]
 LDRB       r0, [ r6, # DRIVENUMBEROPEN ]
 MOV        r2, # 1
 BL         GetUniqueNumber               ; R0 = drive number, RETURNS R1 = number
                                          ; R2 = 1 no error
 STR        r1, temp1
                                          ; R2 = 0 if error, else RETURNS R1=0
 TEQ        r1, r5

 MOV        r1, r0
 ADDNE      r0, r6, # DISCNAMEOPEN
 BLNE       PromptForDisc                 ; R0 -> disc name, R1 = drive number
d298 21
a318 23
 LDR        r5, [ r6, # STARTLBAOPEN ]   ; R4 = start LBA of load
 LDRB       r0, [ r6, # DISCMODEOPEN ]
 ADR        r7, sparecontrolblock

 TEQ        r0, # 2
 BNE        GB_Ordinary

;---------------------------------------------------------------------------------------------

 BL         ChangeDiscMode                        ; R0 = mode, R7 -> control block


;----------------------------------
; Where is the byte of user data ?
;----------------------------------
 MOV        r1, r5
 MOV        r0, # LBAFormat
 MOV        r2, r4

 SWI        XCD_SeekUserData
 BVS        ErrorExit

 MOV        r4, r2
d334 7
a340 14
 MOV       r0, # LBAFormat
 MOV       r2, r3
 MOV       r3, r11
 SWI       XCD_ReadUserData
 BVS       ErrorExit

 GRABALLANDRETURN







d348 1
a348 1
 BL ChangeDiscMode                        ; R0 = mode, R7 -> control block
d351 18
a368 19
 MOV R0, #1


 LDR R10, [ R6, #SIZEOFBLOCKOPEN ]

                                 ; work out where to start from:
                                 ; R4 = offset to get data from


 ADD R6, R4, R3                  ; R9 = file offset + number of bytes to read

 DivRem R0, R4, R10, R14         ; R0 = block to read from
 ADD R0, R0, R5                  ; R4 = bytes offset in a block to read from


 DivRem R2, R6, R10, R14         ; R2 = block to end at
 ADD R2, R2, R5                  ; R6 = bytes offset in a block to end at

 ADD R7, R12, #:INDEX:sparecontrolblock
d391 31
a421 31
 TEQ R4, #0
 BEQ %FT01

 STASH R0-R3

 MOV R3, R1

 MOV R2, #1

 BL PreLoadBlockFromDrive ; r1->buffer

; This assumes that I am not asked for 0 bytes

; if (end byte==0) THEN
;     Copy from r1+start byte, r11, length (blocksize-start byte)
; else
;     IF (end block==start block)
;         Copy from r1+start byte, r11, length (end byte-start byte)
;     else
;         Copy from r1+start byte, r11, length (blocksize-start byte)

 ADD R1, R1, R4
 MOV R2, R11

 TEQ R6, #0
 SUBEQ R3, R10, R4
 BEQ %FT11

 TEQ R2, R0
 SUBNE R3, R10, R4
 SUBEQ R3, R6, R4
d424 9
a432 9
 ADD R11, R11, R3  ; Move to further along the buffer

 CD_ByteCopy

 GRAB R0-R3

 ADD R0, R0, #1    ; start block++

 MOV R4, #0        ; start byte=0
d439 2
a440 2
 CMP R0, R2
 BGE %FT02
a442 3

; TEQ R6, #0

d445 1
a445 3
 SUB R5, R2, R0

; ADDEQ R5, R5, #1
a448 3

; SUBNE R5, R5, #1

d452 1
a452 1
 CMP R5, #0
d457 18
a474 20
 BLE %FT02

 STASH "R1-R3"

 MOV R3, R1

 MOV R1, R11

 MOV R2, R5

 BL LoadBlockFromDrive

 GRAB "R1-R3"

 ADD R0, R0, R5

 [ myblocksize<>2048
 ! 0, "AAAAAAAAa see fileman"
 ]
 ADD R11, R11, R5, LSL #11
d482 2
a483 3
 TEQ R6, #0

 BEQ %FT04
d488 3
a490 5
 MOV R2, #1

 MOV R3, R1

 BL PreLoadBlockFromDrive
d495 3
a497 5
 MOV R2, R11

 MOV R3, R6

 CD_ByteCopy
d501 2
a502 2
 VCLEAR
 GRABALLANDRETURN
d508 10
a517 11
 STASHALL
 log_on

 CMP R0, #(EndOfJumpTableForFSEntry_Args-StartOfJumpTableForFSEntry_Args)/4

 GRABALLANDRETURN HS


 LDR     r14, [ pc, r0, LSL #2 ]
 ADD     pc, pc, r14

d521 29
a549 29
; 0. Read sequential pointer for unbuffered file
 DCD Nothing                 - StartOfJumpTableForFSEntry_Args - 4

; 1. Write sequential pointer
 DCD SaveFile                - StartOfJumpTableForFSEntry_Args - 4

; 2. Reads the size of the file of unbuffered
 DCD Nothing                 - StartOfJumpTableForFSEntry_Args - 4

; 3. Writes the size of the file
 DCD SaveFile                - StartOfJumpTableForFSEntry_Args - 4

; 4. Reads the size of the file (all types)
 DCD ReadSizeAllocatedToFile - StartOfJumpTableForFSEntry_Args - 4

; 5. EOF check for unbuffered files
 DCD Nothing - StartOfJumpTableForFSEntry_Args - 4

; 6. Flush buffers, if bit 27 was set
 DCD Nothing                 - StartOfJumpTableForFSEntry_Args - 4

; 7. Ensure the size of the file (all types)
 DCD ReadSizeAllocatedToFile - StartOfJumpTableForFSEntry_Args - 4

; 8. Write zeros to a file
 DCD SaveFile                - StartOfJumpTableForFSEntry_Args - 4

; 9. Read the date stamp of the file
 DCD ReadFileDateStamp       - StartOfJumpTableForFSEntry_Args - 4
d564 1
a564 1
 STASHALL
d570 6
a575 6
 LDR R3, =:INDEX:OpenFileList - 4
 ADD R3, R3, R12
 LDR R2, [ r3, r1, LSL #2 ]!

 MOV R0, #7                          ; Free memory
 SWI XOS_Module                      ;
d581 2
a582 10
 SUBS R0, R0, R0  ; clears V
 STR R0, [ R3 ]

;******************
; Home James
;******************

 GRABALLANDRETURN


d584 1
d596 1
a596 26
 log_on


 STASHALL

 [ demoversion=ON
 LDR R14, demotries                   ;For demo version
 ADD R14, R14, #1                       ; Lock up if done enough
 STR R14, demotries                   ;
 CMP R14, #NUMBEROFDEMOTRIES  ;
 MOVGE R14, #0                          ;
 MOVGE PC, R14                          ;
 ]

 TEQ R0, #255    ; MUST BE HERE BEFORE ENDOFTABLECHECK !!!!!
 BEQ LoadFile                                ; DONE


           ; Make sure that the reason code is supported by me


 CMP R0, #( EndOfJumpTableForFSEntry_File - JumpTableForFSEntry_File ) / 4
 GRABALLANDRETURN HS

 LDR     r14, [ pc, r0, LSL #2 ]
 ADD     pc, pc, r14
d598 21
d622 11
a632 11
 DCD SaveFile - JumpTableForFSEntry_File - 4 ; 0  n / a       DONE
 DCD SaveFile - JumpTableForFSEntry_File - 4 ; 1  n / a       DONE
 DCD SaveFile - JumpTableForFSEntry_File - 4 ; 2  n / a       DONE
 DCD SaveFile - JumpTableForFSEntry_File - 4 ; 3  n / a       DONE
 DCD SaveFile - JumpTableForFSEntry_File - 4 ; 4  n / a       DONE
 DCD ReadCatalogue - JumpTableForFSEntry_File - 4 ; 5  used to find an object
 DCD SaveFile - JumpTableForFSEntry_File - 4 ; 6  n / a       DONE
 DCD SaveFile - JumpTableForFSEntry_File - 4 ; 7  n / a       DONE
 DCD SaveFile - JumpTableForFSEntry_File - 4 ; 8  n / a       DONE
 DCD Nothing - JumpTableForFSEntry_File - 4  ; 9  only called if bit 26 set ( not supported )
 DCD ReadBlockSize - JumpTableForFSEntry_File - 4 ; 10        DONE natural block size
d649 19
a667 22
 log_on


 STASHALL

 [ demoversion=ON
 LDR R14, demotries                   ;For demo version
 ADD R14, R14, #1                       ; Lock up if done enough
 STR R14, demotries                   ;
 CMP R14, #NUMBEROFDEMOTRIES  ;
 MOVGE R14, #0                          ;
 MOVGE PC, R14                          ;
 ]

;-------------------------------------------------------------------------
; Make sure that the reason code is supported by me
;-------------------------------------------------------------------------
 CMP R0, #( EndOfJumpTableForFSEntry_Func - JumpTableForFSEntry_Func ) / 4
 GRABALLANDRETURN HS

 LDR     r14, [ pc, r0, LSL #2 ]
 ADD     pc, pc, r14
d671 50
a720 52
; Under RISC OS 3 this is done for me
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 0  *DIR
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 1  *LIB
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 2  *CAT
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 3  *EX
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 4  *LCAT
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 5  *LEX
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 6  *INFO

 DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 7  *OPT
 DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 8  *RENAME
 DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 9  *ACCESS
 [ BootFromCD
 DCD BootFromCDFS - JumpTableForFSEntry_Func - 4      ; 10  attempt to boot from CD - yay, lets do this!
 |
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 10  attempt to boot from CD - ignore
 ]

; Under RISC OS 3 this is done for me
 DCD ReadBoot_OS3 - JumpTableForFSEntry_Func - 4      ; 11 Get disc name
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 12 Read dir name
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 13 Read lib name

 DCD CurrentDirObjects - JumpTableForFSEntry_Func - 4 ; 14
 DCD ObjectInfo - JumpTableForFSEntry_Func - 4        ; 15
 DCD Shutdown - JumpTableForFSEntry_Func - 4          ; 16 *SHUTDOWN
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 17 not used -see 'Information Block'
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 18 SET DIR CONTEXTS not used (bit 24)
 DCD ReadEntriesAndLength - JumpTableForFSEntry_Func - 4; 19 READ DIR ENTRIES
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 20 *FileInfo not used (bit 25)

 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 21 notification of new image (RISC OS3)
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 22 image about to be closed (RISC OS3)
 DCD CanonicaliseName - JumpTableForFSEntry_Func - 4  ; 23 Canoncalise name (RISC OS3)
 DCD ResolveWildcard - JumpTableForFSEntry_Func - 4   ; 24 Get a complete file name
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 25 Read defect list
 DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 26 Add a defect to the list
 [ BootFromCD
 DCD ReadBoot2 - JumpTableForFSEntry_Func - 4         ; 27 Read boot option 2
 |
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 27 Read boot option 2
 ]
 DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 28 Write boot option
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 29 Read used space map
 DCD ReadFreeSpace - JumpTableForFSEntry_Func - 4     ; 30 Read free space
 DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 31 Name image
 DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 32 Stamp image
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 33 Get usage of offset
 DCD Nothing - JumpTableForFSEntry_Func - 4           ; 34 Notification of changed directory
 DCD ReadFreeSpace64 - JumpTableForFSEntry_Func - 4   ; 35 Read 64-bit free space
; DCD DefectList64 - JumpTableForFSEntry_Func - 4      ; 36 Read 64-bit defect list
; DCD AddDefect64 - JumpTableForFSEntry_Func - 4       ; 37 Add a 64-bit defect to the list
d731 1
d733 1
a733 9


 LTORG





 END
@


4.4
log
@  Lots of changes for RISC OS 5.
Detail:
  * Updated to use objasm, shared makefiles and global headers
  * Ripped out lots of RISC OS 2 support code so we can see the wood for the
    trees now
  * 32-bit compatible (a bit of a slog)
  * Now has its own resources phase, replacing the use of the CDFSResources
    module. Also means that messages can now be tokenised properly. For
    good measure, split out CmdHelp tokens into separate file
  * Hopefully fixed more bugs along the way than I introduced. I've seen
    lots of nasty stack imbalances in error cases, but not fixed all of
    them, I'm afraid
Admin:
  Tested briefly on a Risc PC; not enough support modules to run on Tungsten
  yet.

Version 2.38. Tagged as 'CDFS-2_38'
@
text
@d787 17
a803 8
; DCD ReadDefectlist - JumpTableForFSEntry_Func - 4    ; 25 Read defect list
; DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 26 Add a defect to the list
; DCD ReadBoot2 - JumpTableForFSEntry_Func - 4         ; 27 Read boot option 2
; DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 28 Write boot option
; DCD ReadUsedSpace - JumpTableForFSEntry_Func - 4     ; 29 Read used space map
; DCD ReadFreeSpace - JumpTableForFSEntry_Func - 4     ; 30 Read free space
; DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 31 Name image
; DCD SaveFile - JumpTableForFSEntry_Func - 4          ; 31 Stamp image
@


4.3
log
@Manual merge of the RISC OS 4.02 version of CDFS (2.37, based upon Acorn's
RiscOS/UnU/OS_Core/FileSys/CDFS/CDFS234 version 2.35).

Tagged as 'CDFS-2_37'
@
text
@a65 4
 [ RISC_OS = 2
SpriteDataPathName = ":29.$.SPRITES", 0
 ]

a108 4
 [ RISC_OS=2
 addr R0, CannotWriteYouFool, NE  ; Cannot write to cdrom
 BNE Error                      ;
 |
d110 1
a110 20
          BNE         Error
 ]


 [ RISC_OS = 2

;**************
; Is CDFSFiler requesting sprite data ?
;**************

 ADR R0, SpriteDataPathName

 MOV R2, #?SpriteDataPathName

 BL CompareStrings    ; returns 'eq' or 'ne'

 BEQ %FT01                      ; [ yes ]

;**************
 ]
d126 2
a127 2
 MOVEQ R1, #0
 BICEQS PC, R14, #Overflow_Flag
d138 1
a138 1
; BEQ Error                      ;
d148 6
a153 4
 GRABALL VS                     ; if cannot get it, then cry to FS
 LDRVS R0, temp1                ;
 MOVVS R1, #0                   ;
 BICVSS PC, R14, #Overflow_Flag ;
d281 1
a281 3
 MOV R4, R3                      ; space currently allocated to file

 BICS PC, R14, #Overflow_Flag
d283 1
a284 23
 [ RISC_OS = 2
;********************
; Give CDFSFiler requested spritedata
;********************

01
                                ; see 'Open' for below proc
 BL NumberOfNextFreeFileHandle  ; Returns R0 = FileHandle ( 1 - 256 )

 STR R0, handleforspritedata

 GRABALL

 MOV R0, #1:SHL:30              ; read is permitted from this file (ofcourse)
 LDR R1, handleforspritedata
 MOV R2, #FSBUFFERSIZE
 LDR R3, =EndOfSpriteData - StartOfSpriteData    ;
; LDR R4, =EndOfSpriteData - StartOfSpriteData    ; space currently allocated
 MOV R4, R3

 BICS PC, R14, #Overflow_Flag

 ]
a311 14
 [ RISC_OS = 2
;**************
; Quicky to give sprite data to filer
;**************

 LDR R5, handleforspritedata          ; Did filer request sprite data ?
 TEQ R5, R1                           ;
 BEQ %FT05                            ;

;**************

 ]


d359 1
a359 1
 BVS        Error
d381 1
a381 19
 BVS       Error








 GRABALL
 BICS PC, R14, #Overflow_Flag








d383 1
d516 3
a518 1
 STASH R1-R3, GT
d520 1
a520 1
 MOVGT R3, R1
d522 1
a522 1
 MOVGT R1, R11
d524 1
a524 1
 MOVGT R2, R5
d526 1
a526 1
 BLGT LoadBlockFromDrive
d528 1
a528 1
 GRAB R1-R3, GT
d530 1
a530 1
 ADDGT R0, R0, R5
d535 1
a535 1
 ADDGT R11, R11, R5, LSL #11
d567 2
a568 34
 GRABALL
 BICS PC, R14, #Overflow_Flag

 [ RISC_OS = 2
;**********************
; Give the sprite data to the filer
;**********************
05
; on entry:
; R2 -> put here
; R3 = length of data
; R4 = offset


;*******************
; Give sprite data                ; R2 -> place to put data
;*******************


 ADRL r1, StartOfSpriteData
 ADD R1, R1, R4

; R1 -> copy from
; R2 -> copy to
; R3 = length of copy

 CD_ByteCopy

 GRABALL

 BICS PC, R14, #Overflow_Flag

 ]

d579 1
a579 2
 GRABALL GT
 BICGTS PC, R14, #Overflow_Flag
a632 13
 [ RISC_OS = 2
;******************
; Is Fileswitch trying to close the CDFSFiler icon sprite ?
;******************

 LDR R5, handleforspritedata         ;
 TEQ R5, R1                          ; [ yes  - then tidy up ]
 MOVEQ R5, #0                        ;
 STREQ R5, handleforspritedata       ;
 GRABALL EQ                          ;
 BICEQS PC, R14, #Overflow_Flag      ;
 ]

d648 1
a648 1
 MOV R0, #0
d655 1
a655 3
 GRABALL

 BICS PC, R14, #Overflow_Flag
d692 1
a692 2
 GRABALL GE
 MOVGES PC, R14
a709 2

 [ RISC_OS > 2
a710 1
 ]
d745 1
a745 2
 GRABALL GT
 BICGTS PC, R14, #Overflow_Flag
a751 10
 [ RISC_OS = 2
 DCD SetDIR - JumpTableForFSEntry_Func - 4            ; 0  *DIR
 DCD SetLIB - JumpTableForFSEntry_Func - 4            ; 1  *LIB
 DCD Catalogue - JumpTableForFSEntry_Func - 4         ; 2  *CAT
 DCD EX - JumpTableForFSEntry_Func - 4                ; 3  *EX
 DCD LCAT - JumpTableForFSEntry_Func - 4              ; 4  *LCAT
 DCD LEX - JumpTableForFSEntry_Func - 4               ; 5  *LEX
 DCD Info - JumpTableForFSEntry_Func - 4              ; 6  *INFO
 |

a759 1
 ]
a769 5
 [ RISC_OS = 2
 DCD ReadBoot_OS2 - JumpTableForFSEntry_Func - 4      ; 11 Get disc name
 DCD CurrentDirectory - JumpTableForFSEntry_Func - 4  ; 12
 DCD ReadLIBName - JumpTableForFSEntry_Func - 4       ; 13 READ LIB NAME
 |
a773 1
 ]
a782 1
 [ RISC_OS <> 2
a794 1
 ]
@


4.2
log
@This is a manual merge of CDFS 2.35 from RiscOS/UnU/OS_Core/CDFS/CDFS234
treating nturton_CDFS-2_29 as the branch point.
@
text
@d426 1
a426 1
; R0  = 
d428 1
a428 1
; R2  = 
d432 1
a432 1
; R6  = 
d436 1
a436 1
; R10 = 
d504 1
a504 1
; R3 
d557 1
a557 1
 SWI     XCD_ByteCopy
d641 1
a641 1
 SWI    XCD_ByteCopy
d671 1
a671 1
 SWI        XCD_ByteCopy
d791 1
a791 1
;          
d853 1
a853 1
; 
d906 3
d910 1
d914 1
a914 1
 DCD CurrentDirectory - JumpTableForFSEntry_Func - 4  ; 12 
@


4.1
log
@Initial revision
@
text
@a105 2
 Debug " Open "

d158 2
d204 13
a224 3

; STASH R7 - R8

d236 22
d259 9
a267 1
; GRAB R7 - R8
d337 8
a346 6
; on entry:
;          R1 = my file handle
;          R2 = memory address to put data
;          R3 = number of bytes to read
;          R4 = file offset to get data from

a349 29

; strategy:
;          . work out which block to start from
;          . work out which block to end at
;          . work out which byte to start from in the block
;          . work out which byte to end at in the block
;          . If the byte to start from is not 0 THEN
;          .                                    {
;          .                                     load a block into my buffer
;          .                                     copy out whats needed
;          .                                     add 1 to start block
;          .                                    }
;          . if (start block != end block)
;          .    {
;          .     if (end byte ==0 (or blocksize ?) )
;          .        number_to_load=end block-start block
;          .    else
;          .        number_to_load=(end block-start block)-1
;          .
;          .     if (number_to_load > 0)
;          .         load number_to_load blocks into users area
;          .    }
;          .
;          . if (end_byte !=0 )
;          .    {
;          .     load a block into my buffer
;          .     copy out whatevers needed
;          .    }

a356 1
 log_on
a359 15
 [ demoversion=ON
 LDR R14, demotries                   ;For demo version
 ADD R14, R14, #1                       ; Lock up if done enough
 STR R14, demotries                   ;
 CMP R14, #NUMBEROFDEMOTRIES  ;
 MOVGE R14, #0                          ;
 MOVGE PC, R14                          ;
 ]

 Debug " Get byte "

 [ debug=ON
 MOV R5, R3
 DebugDisplay R5
 ]
d375 1
a375 1
 MOV R11, R2
d377 3
a379 6
 LDR R5, =:INDEX:OpenFileList - 4 ; R6 -> my little buffer of entry details
 ADD R5, R5, R12                  ;
 LDR R6, [ R5, R1, LSL #2 ]       ;
; TEQ R6, #0                       ;
; ADREQL R0, InternalError         ;
; BEQ Error                        ;
d385 73
a457 1
 LDR R5, [ R6, #DISCNUMBEROPEN ]
a459 1
 LDRB R0, [ R6, #DRIVENUMBEROPEN ]
a460 1
 MOV R2, #1
a461 2
 BL GetUniqueNumber               ; R0 = drive number, RETURNS R1 = number
                                  ; R2 = 1 no error
a462 3
 STR R1, temp1
                                  ; R2 = 0 if error, else RETURNS R1=0
 TEQ R1, R5
a463 3
 MOV R1, R0
 ADDNE R0, R6, #DISCNAMEOPEN
 BLNE PromptForDisc               ; R0 -> disc name, R1 = drive number
a465 1
;******************
a468 1
 LDR R5, [ R6, #STARTLBAOPEN ]   ; R4 = start LBA of load
a470 1
 ADD R7, R12, #:INDEX:sparecontrolblock
d472 3
a474 4
; Will already be done because of uniquenumber
; LDRB R0, [ R6, #DRIVENUMBEROPEN ]
; BL ConvertDriveNumberToDeviceID          ; r0 = drive, R7 -> control block
; BVS Error
d476 1
a476 1
 LDRB R0, [ R6, #DISCMODEOPEN ]
a483 1
; LDR R7, [ R6, #SIZEOFBLOCKOPEN ]
a485 1
; LDRB R1, [ R6, #DRIVENUMBEROPEN ]        ; R1 = drive number
a491 2
; MOV R10, R7

a657 1
 Debug " Give the sprite data to the filer "
a666 15
 [ debug=ON
 MOV R5, R1
 Debug " Copy from :"
 DebugDisplay R5

 MOV R5, R2
 Debug " Copy to :"
 DebugDisplay R5

 MOV R5, R3
 Debug " Length :"
 DebugDisplay R5
 Debug ": "
 ]

d679 1
a686 3

 Debug " Control open file "

a743 2
 Debug " Close "

a808 1
 Debug " Whole files "
a870 2
 Debug " FSOperations "

d955 4
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.20;
access;
symbols
	CDFS-2_63:4.20
	CDFS-2_62:4.19
	CDFS-2_61:4.18
	CDFS-2_60:4.18
	CDFS-2_59:4.17
	CDFS-2_58:4.17
	CDFS-2_57:4.17
	CDFS-2_56:4.16
	CDFS-2_55:4.14
	CDFS-2_54:4.13
	CDFS-2_53:4.11
	CDFS-2_52:4.9
	CDFS-2_51:4.9
	CDFS-2_50:4.9
	CDFS-2_49:4.9
	CDFS-2_48:4.9
	RO_5_07:4.9
	CDFS-2_47:4.9
	CDFS-2_46:4.8
	CDFS-2_45:4.7
	CDFS-2_44:4.7
	CDFS-2_43:4.6
	CDFS-2_42:4.5
	CDFS-2_41:4.5
	CDFS-2_40:4.4
	CDFS-2_39:4.4
	CDFS-2_38:4.4
	CDFS-2_37:4.3
	CDFS-2_35:4.2
	CDFS-2_30:4.2
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	nturton_CDFS-2_29:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_CDFS_2_28:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.20
date	2016.05.08.16.52.45;	author jlee;	state Exp;
branches;
next	4.19;
commitid	rsdrFYAPguHCrH5z;

4.19
date	2015.07.11.09.21.08;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	TEToI1r4jZ6xEQsy;

4.18
date	2013.08.15.14.13.06;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	6zDw3cu1Q3LIBy1x;

4.17
date	2013.03.29.11.04.32;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	LFLy3SDDryC52GJw;

4.16
date	2012.04.22.17.12.51;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	aaGArXXLP7fP1T1w;

4.15
date	2012.04.22.15.48.27;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	bybtPibvH0K2zS1w;

4.14
date	2012.04.22.11.13.13;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	FhAGZUD5Y3dD2R1w;

4.13
date	2012.04.22.11.09.02;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	MNiwWuPGZIIb1R1w;

4.12
date	2012.04.22.11.04.31;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	6PVuneYjhUEDZQ1w;

4.11
date	2012.04.21.21.56.37;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	LsBEkd8YV89lDM1w;

4.10
date	2012.04.16.21.42.01;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	E6l0nP00WOBxH81w;

4.9
date	2003.01.08.11.38.14;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2002.11.26.20.13.02;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2002.11.25.16.16.58;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2002.11.22.21.19.36;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.22.15.05.40;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.04.21.21.42;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.01.20.15.29;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2000.11.30.11.44.22;	author jberanek;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.52;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.52;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.54.53;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.31.52;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.28.10;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.20
log
@Avoid unnecessary remainder calculations
Detail:
  s/EntryFile, s/FileMan, s/Misc - Avoid unnecessary remainder calculation in DivRem macro
Admin:
  Tested on Cortex-A15


Version 2.63. Tagged as 'CDFS-2_63'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; -> Misc            *COMMANDS


; Preserve R7 - R11
;
; CONTAINS:
;          *Back
;          *Buf         only works if 'debug' = ON
;          *Bye
;          *CDDevices
;          *CDFS
;          *CDSpeed
;          *Con. CDROMDrives
;          *Con. CDROMBuffers
;          *Dismount
;          *Drive
;          *EJECT
;          *Lock
;          *Mount
;          *NoDir
;          *NoLib
;          *NoURD
;          *Play
;          *PlayList
;          *PlayMSF
;          *Stop
;          *Supported
;          *Unlock
;          *URD
;          *WhichDisc





      [ bufferlist                      ; Only works during debugging
Buf_Help ; No help or syntax lookup
Buf_Syntax
        DCB       0
        ALIGN
Buf_Code ; Display buffers
;*************************************************************************

        PushAllWithReturnFrame

        BL      DisplayBuffers

        CLRV
        PullAllFromFrameAndExit

;*************************************************************************

      ]

        LTORG

;*************************************************************************
Bye_Code ROUT ; Closes all files, emptys all drives
;*************************************************************************

        PushAllWithReturnFrame

Shutdown

;**********
; Close all files on filing system
;**********

        MOV     R0, #0
        MOV     R1, #0
        SWI     XOS_Find
        
        CLRV
        PullAllFromFrameAndExit


;*************************************************************************
CDDevices_Code  ROUT                     ; no parameters *CDDevices
;*************************************************************************
; on entry: R1 = number of parameters on line

; on exit : nothing


; layout of display:
;                                                            
;  drive  deviceid     LUN     cardnumber     productid     capacity     Firmware
;  2 + 5  1 + 4        1 + 4   1 + 4          16 + 5        upto 11 + 3  4
;
; ( + 4 indicates number of spaces )

        LDR     r12, [ r12 ]

        PushAllWithReturnFrame
        
        ; R0 -> tempbuffer is used to receive the details of the Inquiry command
        ; R4 = hardspace
        ; R6 -> Buffer is used to hold the characters to be displayed
        ; R7 -> spare control block
        ; R9 = Number of CDROMs found
        
        MOV     R4, #HARDSPACE
                
        MOV     R9, #0
                
        ADRL    R6, buffer

        ADR     r0, message_block
        addr    r1, cddevicesheader_tag
        MOV     r2, r6
        MOV     r3, #128
        SWI     XMessageTrans_GSLookup
        BVS     ErrorExit
        MOV     r0, r2
        SWI     XOS_PrettyPrint

        MOV     R11, R6

and_why_not

;**************
; Check that device is recognised by CDFS
;**************

        MOV     R0, R9
        BL      PreConvertDriveNumberToDeviceID ; on VS R0 -> error block
        BVS     DisplayDevice           ; No such device

;**************
; Inquiry device
;**************

        ADR     R0, tempbuffer
        SWI     XCD_Inquiry             ; R0 -> where to put data,R7 -> control block
        BVS     inquiryerror

;**************
; Drive number, device, card, lun
;**************

;************
; R1 = R9 MOD 10 R4 = R9 DIV 10
;************

        MOV     R1, R9
        
        DivideBy10 R1, R3, R14
        
        ADD     R1, R1, #"0"
        STRB    R1, [ R6 ], #1
        ADD     R3, R3, #"0"
        STRB    R3, [ R6 ], #1
        
        BL      space

        STRB    R4, [ R6 ], #1          ; Extra space

        LDMIA   R7, { R1, R2, R10 }
        
        ADD     R1, R1, #"0"            ; device id
        STRB    R1, [ R6 ], #1          ;
        
        BL      space                   ; R6 -> place to space, R4 = SPACE


        ;------------------------------------------------
        ; The LUN and card number are the wrong way round
        ;------------------------------------------------

        ADD     r1, r10, #"0"           ; card number
        STRB    r1, [ r6 ], #1          
                                        
        BL      space                   
                                        
        ADD     r1, r2, #"0"            ; LUN
        STRB    r1, [ r6 ], #1          
                                        
        BL      space                   

;------------------------------------------------

;**************
; Copy 'CDU-xxxx' to print buffer
;**************

        ADD     R2, R0, #16             ; CD-ROM CDU 6XXX or LMS 212
        ADD     R1, R2, #16             

01

        LDRB    R14, [ R2 ], #1         
                                        
        TEQ     R14, #SPACE             ; Convert spaces to hard spaces
        MOVEQ   R14, #HARDSPACE         
        STRB    R14, [ R6 ], #1
                                        
        TEQ     R1, R2                  
        BNE     %BT01                   
                                        
        BL      space                   ; R6 -> place to space, R4 = SPACE

        STRB    R4, [ R6 ], #1          ; Extra space

;*******************
; Disc capacity
;*******************

        MOV     R10, R6
        SUB     SP, SP, #8
        MOV     R1, SP
        MOV     R0, #LBAFormat
                
        SWI     XCD_DiscUsed
        Pull    "R1,R3"                 ; R1 = number of blocks
                                        ; R3 = size of a block

;****** If unknown then 'Unknown'

        ADRVS   R2, Unknown             ; capacity is unknown
        BVS     %FT05

;****** ELSE convert blocksize to Megabytes

        MOV     R14, R1, LSL #16
        MOV     R1, R1, LSR #16         ; r1 = mshw of block count
        MOV     R0, r14, LSR #16        ; r0 = lshw of block count

        MUL     R14, R1, R3
        MUL     R0, R3, R0
        MOV     R1, R14, LSR #16
        ADDS    R0, R0, R14, LSL #16
        ADC     R1, R1, #0              ; r0,r1 are lsw,msw of disc size

        MOVS    R0, R0, LSR #20
        ORR     R0, R0, R1, LSL #12     ; Crude, but definitely covers 0 to 9999 MB
        ADDCS   R0, R0, #1

        TEQ     R0, #1
        ADREQ   R2, OneMegaByte         ; Singular
        BEQ     %FT05

        MOV     R1, R6                  ; R1 -> buffer to put
        MOV     R2, #20                 ; R2 = length of buffer
        SWI     XOS_ConvertCardinal2    ; While OS_ConvertFileSize almost does what is desired, it
        MOV     R6, R1                  ; jumps at 4096 and we're more interested in fine MB than coarse GB
        ADR     R2, MegaBytes
05
        LDRB    R14, [ R2 ], #1
        TEQ     R14, #0                 ; strcpy(R6, R2)
        STRNEB  R14, [ R6 ], #1
        BNE     %BT05

        SUB     R2, R6, R10             ; Length of capacity
        SUB     R2, R2, #14 - 8         ; Padding correction after 8 spaces
        BL      space                   ; R6 -> place to space, R4 = SPACE
        BL      space                   
        SUB     R6, R6, R2

;*******************
; Firmware revision number, eg '2.01'
;*******************

        LDR     R2, tempbuffer + 32
13
        STRB    R2, [ R6 ], #1
        MOVS    R2, R2, LSR #8
        BNE     %BT13
                
        MOV     R3, #13
        STRB    R3, [ R6 ], #1

inquiryerror

        ADD     R9, R9, #1
        LDRB    R14, numberofdrives     ; any more drives to look for ?
        CMP     R14, R9
        BHS     and_why_not             ; [ yes ]

;*********************
; Display number of CDROMs found     R9 = number found
;*********************

DisplayDevice

        TEQ     R9, #0
        MOVNE   R0, R11                 ; Some drive(s) were found
        MOVNE   R4, #0
        STRNEB  R4, [ R6 ]
        BNE     %FT10

        ADR     r0, message_block       ; No drive was found
        addr    r1, nodrivesfound_tag
        MOV     r2, r6
        MOV     r3, #128
        ASSERT  ?buffer >= 128
        SWI     XMessageTrans_Lookup
        ADDVS   r0, r0, #4              ; Show the error instead
        MOVVC   r0, r2
10
        SWI     XOS_PrettyPrint
        TEQ     r9, #0
        SWIEQ   XOS_NewLine
        
        CLRV
        PullAllFromFrameAndExit

Unknown
        DCB     "Unknown", 0
MegaBytes
        DCB     HARDSPACE, "Mbytes", 0
OneMegaByte
        DCB     "1", HARDSPACE, "Mbyte", 0        
        ALIGN

space
        STRB    R4, [ R6 ], #1
        STRB    R4, [ R6 ], #1
        STRB    R4, [ R6 ], #1
        STRB    R4, [ R6 ], #1
        MOV     PC, R14

;----------------------------------------------------------------------------------------------
; *CDSpeed
; If '*CDSpeed' without any parameters, then current speed for current drive returned
; if '*CDSpeed <d>' then current speed for drive 'd' returned
; if '*CDSpeed <d> <s>' then set the speed for drive 'd' to 's'.  If 's' == 255 then set to
;     maximum.  1 is standard, 2 is double.
CDSpeed_Code ROUT
;----------------------------------------------------------------------------------------------
; on entry:
;          r0 -> parameter line
;          r1 =  number of parameters on line

        PushAllWithReturnFrame
        
        MOV     r4, r1

        ;----------------
        ; Current drive ?
        ;----------------
        CMP     r1, #1
        
        BLGE    atoi
        BVS     ErrorExit
        MOVGT   r3, r0
        MOVGE   r0, r2
        LDRLTB  r0, CurrentDriveNumber

        ;----------------
        ; Device number ?
        ;----------------
        BL      PreConvertDriveNumberToDeviceID ; R0 = drive number, returns R7 -> block
        BVS     ErrorExit

        ;---------------------
        ; Get current settings
        ;---------------------
        ADR     r0, TempArea            
        SWI     XCD_GetParameters       ; r0->storage area, r7->block
        BVS     ErrorExit               

        ;--------------------------
        ; Display current setting ?
        ;--------------------------
        CMP     r4, #2
        BGE     %FT01
        
        MOV     r1, r0
        LDRB    r0, [ r1, #12 ]
        MOV     r2, #4
        SWI     XOS_BinaryToDecimal
        MOV     r0, r1
 
        Push    "r0-r3"
        ADR     r0, message_block
        addr    r1, currentspeed_tag
        ADR     r2, TempArea + 100
        MOV     r3, #128
        SWI     XMessageTrans_Lookup
        BVS     ErrorExit
        MOV     r0, r2
        SWI     XOS_Write0
        Pull    "r0-r3"

        MOV     r1, r2
        SWI     XOS_WriteN
        SWI     XOS_NewLine
        B       common_end

;--------------
; Set speed
;--------------
01

;------------------------------
; Decode the string to a number
;------------------------------
        MOV     r4, r0
        MOV     r0, r3
        BL      atoi
        BVS     ErrorExit
        STRB    r2, [ r4, #12 ]

;----------------
; Change CD speed
;----------------
        MOV     r0, r4
        SWI     XCD_SetParameters
                
        B       common_end


;*************************************************************************
; This is the *CONFIGURE CDROMBuffers
;*************************************************************************

; on entry:
;          R0 = 0   THEN *CONFIGURE with no option
;          R0 = 1   THEN *STATUS
;          R0 <> 0 AND R0 <> 1 THEN *CONFIGURE R0 -> string

; This works out if a *configure or *status has been performed

CDROMBuffers_Code ROUT

        LDR R12, [ R12 ]
        
        PushAllWithReturnFrame
                                        ; Just print the configure description
        CMP     R0, #1                  ; message
        BHI     SetNumberOfBuffers      ;  *CONFIGURE number
        BEQ     %FT10
        
        ADR     R0, ConfigureMessageForBuffers ; Show *CONFIGURE syntax
        SWI     XOS_PrettyPrint
        SWIVC   XOS_NewLine

        PullAllFromFrameAndExit

10
        ; Print *STATUS of CDROMBuffers
        ADR     R0, ConfigureMessageForBuffers ; Display 'CDROMBuffers '
        MOV     R1, #13                 ;
        SWI     XOS_WriteN              ;
                
        SWI     XCDFS_GetBufferSize     ; RETURNS R0 = 0 to 7
                
        BL      ConvertBufferSizeToReal ; R0 = bit values, RETURNS R1 = buffer actual
                
        MOV     R0, R1
        ADR     R1, TempArea
        MOV     R2, #20
        SWI     XOS_ConvertCardinal2    ; see page 602  ( integers from 0 to 65535 )
                
        SWI     XOS_PrettyPrint
        SWI     XOS_WriteI + "K"
        SWI     XOS_NewLine
                
        CLRV
        PullAllFromFrameAndExit

;**************
SetNumberOfBuffers
;**************

; This gets the value currently stored in CMOS ram
; then combines it with the desired setting, so that the other bits
; in the byte are preserved

        MOV     R1, R0                  ; R1 -> string
        
        MOV     R0, #10                 ; base 10
        
        ; restrict number to be in range 0 - maxnumberofdrivessupported
        
        ORR     R0, R0, #(1:SHL:29)
        MOV     R2, #MAXBUFFERSIZE
        SWI     XOS_ReadUnsigned
        
        PullAllFromFrame VS             ; Indicate 'Parameter too big'
        MOVVS   R0, #2                  ;
        MOVVS   PC, R14                 ;

        MOV     R0, R2
        BL      ConvertRealBufferToSize ; R0 = number of K, RETURNS R1 = bit setting
        
        MOV     R0, R1
        SWI     XCDFS_SetBufferSize
        B       common_end

ConfigureMessage
        DCB     "CDROMDrives <D>", 0
ConfigureMessageForBuffers
        DCB     "CDROMBuffers <D>[K]", 0
        ALIGN

;*************************************************************************
; This is the *CONFIGURE CDROMDrives
;*************************************************************************

; on entry:
;          R0 = 0   THEN *CONFIGURE with no option
;          R0 = 1   THEN *STATUS
;          R0 <> 0 AND R0 <> 1 THEN *CONFIGURE R0 -> string

; This works out if a *configure or *status has been performed

CDROMDrives_Code ROUT

        LDR     R12, [ R12 ]
        
        PushAllWithReturnFrame
                                        ; Just print the configure description
        CMP     R0, #1                  ; message
        BHI     SetNumberOfDrives       ;  *CONFIGURE number
        BEQ     %FT10

        ADR     R0, ConfigureMessage    ; Show *CONFIGURE syntax
        SWI     XOS_PrettyPrint
        SWIVC   XOS_NewLine

        PullAllFromFrameAndExit

10
        ; Print *STATUS of CDROMDrives

        ADR     R0, ConfigureMessage    ; Display 'CDROMDrives '
        MOV     R1, #12
        SWI     XOS_WriteN              ;
                
        SWI     XCDFS_GetNumberOfDrives ; RETURNS R0 = number of drives conf.
        BVS     ErrorExit
                
        ADR     R1, TempArea
        MOV     R2, #20
        SWI     XOS_ConvertCardinal1    ; see page 602
                
        SWI     XOS_PrettyPrint
        SWI     XOS_NewLine
                
        CLRV
        PullAllFromFrameAndExit

;**************
SetNumberOfDrives
;**************

; This gets the value currently stored in CMOS ram
; then combines it with the desired setting, so that the other bits
; in the byte are preserved


        ; Make the string into a real number
        
        MOV     R1, R0                  ; R1 -> string
        MOV     R0, #10                 ; base 10
        
        ; restrict number to be in range 0 - maxnumberofdrivessupported
        
        ORR     R0, R0, #(1:SHL:29)
        MOV     R2, #MAXNUMBEROFDRIVESSUPPORTED
        SWI     XOS_ReadUnsigned
        
        PullAllFromFrame VS             ; Indicate 'Parameter too big'
        MOVVS   R0, #2                  ;
        MOVVS   PC, R14                 ;
        
        ; This gets the value currently stored in CMOS ram
        
        MOV     R0, R2
        SWI     XCDFS_SetNumberOfDrives
        
        STRVS   R0, [R13]               ; Indicate the unknown error to FS
        PullAllFromFrame VS             ;
        MOVVS   PC, R14                 ;
        
        PullAllFromFrameAndExit

;*************************************************************************
Dismount_Code ROUT  ; *Dismount drive number or disc name
;*************************************************************************

; R0 -> parameters passed in
; R1 = number of parameters

        PushAllWithReturnFrame

;******************
; Were any parameters following *Dismount ?
;******************

        TEQ     R1, #0                  ;
        LDREQB  R0, CurrentDriveNumber  ; [ no - so dismount current drive ]
        BEQ     %FT04                   ;

;******************
; If a ':' was the first char of the parameter THEN ignore it
;******************

        Push    "R0"
                
        LDRB    R1, [ R0 ]
        TEQ     R1, #":"
        ADDEQ   R0, R0, #1

;******************
; Validate the parameter for valid characters
;******************

        BL      CheckDiscName           ; R0 -> string

        Pull    "R0"

;******************
; Copy parameter into 'TempArea' prefixed with ':' if necessary
;******************

 ; Make sure that the name or number is prefixed with ":"

        MOV     R1, #":"
        ADR     R2, TempArea
        MOV     R3, R2
                
        STRB    R1, [ R2 ], #1
                
        LDRB    R1, [ R0 ], #1
        TEQ     R1, #":"
        STRNEB  R1, [ R2 ], #1

03

        LDRB    R1, [ R0 ], #1
        STRB    R1, [ R2 ], #1
        TEQ     R1, #0
                
        BNE     %BT03

;******************
; Prompt for disc to be inserted ( as it isn't buffered )
;******************

        ADD     R0, R3, #1
        BL      FindDiscNameInList
        CMP     R1, #-1
        SUBEQ   R0,R0,#1
        BLEQ    FindDriveNumber         ; R0 -> name or number, RETURNS R1 = drive

;******************
; Now I know the drive number !
;******************

        MOV     R0, R1
04

;******************
; Wipe the disc name from the list of discs mounted
;******************

        LDR     R2, =:INDEX:DiscNameList
      [ MAXLENGTHOFDISCNAME<>32
        MOV     R3, #MAXLENGTHOFDISCNAME
        MLA     R4, R3, R0, R2
      |
        ADD     R4, R2, R0, LSL #5
      ]
        MOV     R3, #0
        STRB    R3, [ R4, R12 ]!
                
        ADRL    R14, discsMounted
        STR     R3, [ R14, R0, LSL #2 ]

;******************
; Remove the disc number from the list of discs mounted
;******************

        ADRL    R14, ListOfDiscsInDrives
        LDR     R0, [ R14, R0, LSL #2 ]!
        STR     R3, [ R14 ]
                
        BL      PreConvertDriveNumberToDeviceID
        SWI     XCD_DiscHasChanged
        BVS     ErrorExit

;******************
; Close all the files on the disc
; R0 = unique number
;******************

;**********
; Make sure that all files related to this disc are closed
;**********

        ; R0 = disc
        ; R1 = block
        ; R2 -> buffer list
        LDR     R2, pointerToBufferList

;**********
; Close all directory buffers on the disc
;**********

01

        LDMIA   R2!, { R1, R4, R5, R6 } ; R1 = disc, R4 = buffer, R5 = block
                                        ; r6=offset
        TEQ     R4, #0                  ; Last entry in list ?
        BEQ     %FT02                   ; [ yes ]
        
        
        TEQ     R1, R0
        BNE     %BT01
                
        MOV     R1, R5
        BL      DeleteBuffer            ; R0 = unique number, R1 = block number
        LDR     R2, pointerToBufferList ; start from begining again
        
        B       %BT01

02

;**********
; Close all files on the disc
;**********

        ; R0 = disc number to look for
        ; R1 -> current pointer in list
        ; R2 = number searched so far ( 255 to 0 ) BACKWARDS !
        ; R3 = disc number of little buffer
        ; R4 -> little buffer
        ADRL    R1, OpenFileList        ; This list contains pointers to small
                                        ; buffers for each open file or 0
        MOV     R2, #MAXNUMBEROFOPENFILES - 3   ; From 253 to 0

05

        LDR     R4, [ R1 ], #4
                
        SUBS    R2, R2, #1              ; Reached end ?
        PullAllFromFrame EQ             ;
        MOVEQ   PC, R14                 ; [ yes ]  V is clear
                                        
        TEQ     R4, #0                  ; Number not used ?
        BEQ     %BT05                   ; [ not used ]

        LDR     R3, [ R4, #DISCNUMBEROPEN ] ; Does this buffer come from this disc ?
        TEQ     R3, R0
        BNE     %BT05
                                        ;
        Push    "R0-R1"                 ; [ yes ] - so close that file
        
        MOV     R0, #0
        LDR     R1, [ R4, #FILESWITCHHANDLE ]
        SWI     XOS_Find

        Pull    "R0-R1"
        
        B       %BT05

;*************************************************************************
; This is the *EJECT command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

Eject_Code

        PushAllWithReturnFrame

        TEQ     R1, #1

;*****************
; Deal with parameter
;*****************

        BLEQ    atoi
        BVS     ErrorExit
        LDRNEB  R0, CurrentDriveNumber
        MOVEQ   R0, R2
        
        BL      PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> block
        
        SWIVC   XCD_OpenDrawer
        
        B       common_end

;*************************************************************************
; This is the *LOCK command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

Lock_Code

        PushAllWithReturnFrame

        TEQ     R1, #1

;*****************
; Deal with parameter
;*****************

        BLEQ    atoi
        BVS     ErrorExit
        LDRNEB  R0, CurrentDriveNumber
        MOVEQ   R0, R2
        
        BL      PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block
        
        MOVVC   R0, #1
        
        SWIVC   XCD_EjectButton

        B       common_end


;*************************************************************************
Drive_Code ROUT     ; *Drive is now implemented as *Mount
Mount_Code ROUT     ; *Mount drive number or disc name
;*************************************************************************

; R0 -> parameters passed in ( terminated by a char < 32 )
; R1 = number of parameters

        PushAllWithReturnFrame

        ; IF NOTHING SUPPLIED THEN COPY IN THE CSD DISC NAME/ DRIVE NUMBER

        TEQ     R1, #0
        ; MB FIX
        ; this caused attempted writing to ROM doh!
        ; original code: ADREQ R0, BlankPath     ; R0 -> '$'
        ; instead of that, construct a "$" string in the tenpbuffer area and use that
        ADREQ   R0,tempbuffer
        MOVEQ   R1,#"$"
        STREQB  R1,[R0,#0]
        MOVEQ   R1,#0
        STREQB  R1,[R0,#1]
        ; end MB FIX
        MOVEQ   r6, #0

        BEQ     SetDir_fixed_for_mount

;*****************
; Deal with parameter
;*****************

        ; Make sure that the name or number is prefixed with ":"

        ADR     R2, tempbuffer
        MOV     R3, R2
        
        LDRB    R1, [ R0 ]
        TEQ     R1, #":"
        MOVNE   R1, #":"
        ADDEQ   R0, R0, #1
        STRB    R1, [ R2 ], #1

01

        LDRB   R1, [ R0 ], #1
        CMP    R1, #32
        STRGTB R1, [ R2 ], #1
        BGT    %BT01
        
        MOV    R1, #"."
        STRB   R1, [ R2 ], #1
        MOV    R1, #"$"
        STRB   R1, [ R2 ], #1
        MOV    R1, #0
        STRB   R1, [ R2 ], #1
        
        MOV    R0, R3
        MOV    r6, #0

        B      SetDir_fixed_for_mount   ; R0 -> path

BlankPath
        DCB    "$", 0
        ALIGN


;*************************************************************************
; This is the *PLAY command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=1 then use current drive,
;          r1=2 then use drive specified

Play_Code

        PushAllWithReturnFrame
        
        TEQ     R1, #2

;*****************
; Deal with parameter
;*****************

        BL      atoi                    ; r0->first parameter, RETURNS r0->next param (if any),
                                        ; RETURNS r2=value
        BVS     ErrorExit
        
        Push    "R2"

;****************
; Make sure that that track exists
;****************

;*****************
; Find number of tracks on disc
;*****************

        BLEQ    atoi
        ADDVS   R13, R13, #4
        BVS     ErrorExit
        
        LDRNEB  R0, CurrentDriveNumber
        MOVEQ   R0, R2
        ADR     R1, TempArea
        
        BL      PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block
        
        MOVVC   R0, #0
        SWIVC   XCD_EnquireTrack
        BVS     ErrorExit
                
        Pull    "R2"
                
        LDRB    R6, [ R1, #0 ]          ; start track
        LDRB    R14, [ R1, #1 ]         ; end track
        CMP     R2, R14                 ; number too big ?

        MOVGT   r0, #ERROR_TOOBIG
        BGT     ErrorExit

        CMP     R2, R6                  ; number too small ?

        MOVLT   r0, #ERROR_TOOSMALL
        BLT     ErrorExit

;****************
; Play track
;****************


        MOV     R1, #&FF                ; R1 = play to end of disc
                                        ; ( or to start of a data track )
        MOV     R0, R2                  ; R2 contains the integer result
        SWI     XCD_PlayTrack
        
        B       common_end

;---------------------------------------------------------------------------
atoi        ; convert ascii to integer
;---------------------------------------------------------------------------

; on entry:
;          r0->ascii value
; on exit:
;          r0->next parameter or end_of_string+1
;          r1 corrupted
;          r2=integer
;          V set if error (we don't know how much to adjust SP by before
;            branching to ErrorExit ourselves) else flags preserved

        Push    "R14"
        MRS     R1, CPSR
        TEQ     PC, PC
        Push    "R1", EQ
        
        MOV     R1, R0
        MOV     R0, #10+(1:SHL:31)      ; make sure terminator is control char or space
        SWI     XOS_ReadUnsigned
        
        MOVVC   R0, R1
        
        TEQ     PC, PC
        Pull    "R1", EQ
        Pull    "PC", VS
        Pull    "PC", NE, ^
        MSR     CPSR_f, R1
        Pull    "PC"


;*************************************************************************
; This is the *PlayList command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

; R6 = current track
; R7 -> spare control block
; R9 -> current position in buffer
; R10 = start track
; R11 = end track
; temp3 = current track

PlayList_Code

        PushAllWithReturnFrame
        
        TEQ     R1, #1

;*****************
; Deal with parameter(s)
;*****************

        BLEQ    atoi
        BVS     ErrorExit
        LDRNEB  R0, CurrentDriveNumber
        MOVEQ   R0, R2
        
        BL     PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block
        
        
        ADRL    R1, buffer              ; storage area = buffer
        MOVVC   R0, #0
        SWIVC   XCD_EnquireTrack
        BVS     ErrorExit
        
        LDRB    R10, [ R1 ]             ; start track
        LDRB    R11, [ R1, #1 ]         ; end track
        MOV     R6, R10                 ; current track
        
        MOV     R9, R1

        ADR     r0, message_block
        addr    r1, playlist_tag
        MOV     r2, r9
        MOV     r3, #128
        SWI     XMessageTrans_Lookup
        BVS     ErrorExit
        MOV     r0, r2
        SWI     XOS_Write0
        SWI     XOS_NewLine

PlayListLoop            ; loop

        MOV     R0, R6
        ADD     R1, R12, #:INDEX:TempArea
        SWI     XCD_EnquireTrack
        BVS     ErrorExit

;****************
; DISPLAY TRACK
;****************

        ADR     r0, message_block
        addr    r1, track_tag
        MOV     r2, r9
        MOV     r3, #128
        SWI     XMessageTrans_GSLookup
        BVS     ErrorExit
        ADD     r9, r2, r3

        MOV     R0, R6
        MOV     R1, R9
        MOV     R2, #255
                
        CMP     R0, #10
        MOVLT   R14, #"0"
        STRLTB  R14, [ R1 ], #1

        SWI     XOS_ConvertCardinal1    ; R0 = value, R1->buffer, R2=buffersize
                                        ; RETURNS R0->buffer,R1->end,R2=bytes left

        MOV     R9, R1
        MOV     R14, #HARDSPACE
12
        TST     R9, #3
        STRNEB  R14, [ R9 ], #1
        BNE     %BT12
                
        LDRB    R14, TempArea + 4       ; If control bits AND 1 = 0 THEN audio
        TST     R14, #1                 ; ELSE data

        ADR     r0, message_block
        addr    r1, audio_tag, EQ
        addr    r1, data_tag, NE
        MOV     r2, r9
        MOV     r3, #128
        SWI     XMessageTrans_GSLookup
        BVS     ErrorExit
        ADD     r9, r2, r3

;****************
; MM:SS:FF
;****************

        ; R5 = LBA of start of track
        ; R6 = frames
        ; R3 = seconds
        ; R0 = minutes
        LDR     R5, TempArea
        ADD     R5, R5, #150

                                                      ; R3 = address DIV 75
                                                      ;
        DivRem  R3, R5, #MaxNumberOfBlocks + 1, R14   ; R5 = address MOD 75
       
        DivRem  R0, R3, #MaxNumberOfSeconds + 1, R14  ; R0 = ( address / 75 ) / 60
                                                      ;
                                                      ; R3 = ( address/75 ) MOD 60

        MOV     R8, #":"
        MOV     R4, #"0"
                
        MOV     R1, R9
        CMP     R0, #10
        STRLTB  R4, [ R1 ], #1
        SWI     XOS_ConvertCardinal1    ; R0 = value, R1->buffer, R2=buffersize
                                        ; RETURNS R0->buffer,R1->end,R2=bytes left

        STRB    R8, [ R1 ], #1
        
        MOV     R0, R3
        CMP     R0, #10
        STRLTB  R4, [ R1 ], #1
        SWI     XOS_ConvertCardinal1    ; R0 = value, R1->buffer, R2=buffersize
        
        STRB    R8, [ R1 ], #1
        
        MOV     R0, R5
        CMP     R0, #10
        STRLTB  R4, [ R1 ], #1
        SWI     XOS_ConvertCardinal1    ; R0 = value, R1->buffer, R2=buffersize
        
        MOV     R9, R1
        
        MOV     R0, #HARDSPACE
13
        ADD     R14, R9, #1             ; Word align for "Track"
        TST     R14, #3
        STRNEB  R0, [ R9 ], #1
        BNE     %BT13

;****************
; LINE FEED
;****************

        MOV     R0, #NEWLINE
        STRB    R0, [ R9 ], #1

;****************
; NEXT loop
;****************

        ADD     R6, R6, #1              ;  Increment current_track%
                
        CMP     R6, #99                 ;  Make sure that can't infinite loop
        CMPLE   R6, R11
                
        BLE     PlayListLoop

;****************
; empty buffer
;****************

        MOV     R0, #0                  ; terminator
        STRB    R0, [ R9 ]
        
        ADRL    R0, buffer
        MOV     R9, R0
                
        SWI     XOS_PrettyPrint

;***************
; Print "Total of "      ; finish_track% - start_track% + 1; " tracks "
;***************

        ADR     r0, message_block
        addr    r1, total_tag
        ADR     r2, TempArea
        MOV     r3, #128
        ASSERT  ?TempArea >= 128
        SWI     XMessageTrans_GSLookup
        MOVVC   r0, r2
        ADDVS   r0, r0, #4
        SWI     XOS_Write0

        SUB     R0, R11, R10
        ADD     R0, R0, #1
        MOV     R3, R0                  ; Copy for after SWI

        ADR     R1, TempArea
        MOV     R2, #3
        ASSERT  ?TempArea >= 3
        SWI     XOS_ConvertCardinal1

        CMP     R3, #10                 ; Pad when < 10
        SWICC   XOS_WriteI + "0"
        SWI     XOS_Write0

        ADR     r0, message_block
        addr    r1, tracks2_tag
        ADR     r2, TempArea
        MOV     r3, #128
        ASSERT  ?TempArea >= 128
        SWI     XMessageTrans_GSLookup
        MOVVC   r0, r2
        ADDVS   r0, r0, #4
        SWI     XOS_PrettyPrint


        MOV     R0, #MSFFormat
        ADR     R1, TempArea
        SWI     XCD_DiscUsed
        BVS     ErrorExit
                
        LDR     R6, [ R1 ]              ; R0 = end of disc

        MOV     R1, R9
        MOV     R2, #255
        MOV     R7, #":"
        MOV     R8, #"0"

;**********************
; MINUTES

        MOV     R0, R6, ASR #16         ; MINUTES
        AND     R0, R0, #&FF            ;
                
        CMP     R0, #10
        STRLTB  R8, [ R1 ], #1          ; '0'
        
        SWI     XOS_ConvertCardinal1    ; R0 = value,R1->buffer,R2=sizeofbuffer
                                        ; RETURNS R0 -> buffer,R1->end,R2=bytes left
        STRB    R7, [ R1 ], #1          ; ':'

; SECONDS

        MOV     R0, R6, ASR #8          ; SECONDS
        AND     R0, R0, #&FF            ;
                
        CMP     R0, #10
        STRLTB  R8, [ R1 ], #1          ; '0'
        
        SWI     XOS_ConvertCardinal1    ; R0 = value,R1->buffer,R2=sizeofbuffer
                                        ; RETURNS R0 -> buffer,R1->end,R2=bytes left
        STRB    R7, [ R1 ], #1          ; ':'

; FRAMES

        AND     R0, R6, #&FF            ;
                
        CMP     R0, #10
        STRLTB  R8, [ R1 ], #1          ; '0'
        
        SWI     XOS_ConvertCardinal1    ; R0 = value,R1->buffer,R2=sizeofbuffer
                                        ; RETURNS R0 -> buffer,R1->end,R2=bytes left

        MOV     R0, R9
        SWI     XOS_Write0
                
        SWI     XOS_NewLine
                
        CLRV
        PullAllFromFrameAndExit

;*************************************************************************
PlayMSF_Code ROUT ; Plays from time 1 to time 2
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=2 then use current drive,
;          r1=3 then use drive specified

        PushAllWithReturnFrame

;******************
; Check parameters for correctness - should be 'MM:SS:FF'
;******************

        MOV     R2, R0
                
        MOV     R5, #2

01
        BL      %FT10                   ; check for '0' to '9', R4 corrupted
        BL      %FT10                   ; check for '0' to '9', R4 corrupted
        
        LDRB    R3, [ R2 ], #1       
        TEQ     R3, #":"             
        BNE     %FT01                
        
        SUBS    R5, R5, #1
        BNE     %BT01
        
        BL      %FT10                   ; check for '0' to '9', R4 corrupted
        BL      %FT10                   ; check for '0' to '9', R4 corrupted
        
        SUB     R14, R2, R0             ; Check the second parameter ?
        CMP     R14, #8                 ;
        BLT     %BT01                   ; [ yes ]

;******************
; Convert the parameters to numbers and store them in registers
; These are then sent to CD_PlayAudio SWI in MSF form ( mode 1 )
;******************

; R8 = first parameter
; R9 = second parameter

;**************
; Set R8 to imposs. value for first parameter
; This means that a general proc. can be made for converting text to
; digit
;**************

        MOV     R8, #-1

;**************
; R2 -> start of parameters following '*PlayMSF'
; This works out from the characters given, to an MSF value
;**************

        MOV     R2, R0

;**************

03

        BL      %FT20
        ADD     R9, R3, R4, ASL #1
                
        BL      %FT20
        ADD     R3, R3, R4, ASL #1
        ORR     R9, R3, R9, ASL #8
                
        BL      %FT20
        ADD     R3, R3, R4, ASL #1
        ORR     R9, R3, R9, ASL #8

;*************
; Do the second parameter ?
;*************

        CMP     R8, #-1                 ; If R8 = -1 Then do the second parameter
        MOVEQ   R8, R9                  ;
        BEQ     %BT03                   ;

;******************
; Send parameters to current drive number [drive] specified ?
;******************

        TEQ     R1, #3
        MOVEQ   R0, R2
        BLEQ    atoi
        BVS     ErrorExit
        MOVEQ   R0, R2
        LDRNEB  R0, CurrentDriveNumber

        BL      PreConvertDriveNumberToDeviceID

        MOVVC   R0, #1
        MOVVC   R1, R8
        MOVVC   R2, R9
                
        SWIVC   XCD_PlayAudio
        BVS     ErrorExit

        B       %FT02

;******************
; Resolve digits from characters
;******************

20
        LDRB    R4, [ R2 ], #1          ;
        LDRB    R3, [ R2 ], #2          ; Move past ':'
        SUB     R4, R4, #"0"            ; R4 = M
        SUB     R3, R3, #"0"            ; R3 = M
                
        ADD     R4, R4, R4, ASL #2      ; R9 = First digit * 10
                
        MOV     PC, R14

;******************
; Check for a digit
;******************

10
        LDRB    R3, [ R2 ], #1
        CMP     R3, #"0"                
        RSBHSS  R4, R3, #"9"+1          
        MOVHI   PC, R14                 ; ALLOW TO RUN ON

;******************
01     ; Incorrect syntax on parameter line
;******************

        ADR     r0, message_block
        addr    r1, playmsf_tag
        ADR     r2, TempArea
        MOV     r3, #128
        SWI     XMessageTrans_Lookup
        BVS     ErrorExit
        MOV     r0, r2
        SWI     XOS_PrettyPrint
        SWI     XOS_NewLine
02
        CLRV
        PullAllFromFrameAndExit


;*************************************************************************
; This is the *STOP command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

Stop_Code

        PushAllWithReturnFrame

        TEQ     R1, #1

;*****************
; Deal with parameter
;*****************

        BLEQ    atoi
        BVS     ErrorExit
        LDRNEB  R0, CurrentDriveNumber
        MOVEQ   R0, R2
                
        BL      PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block
                
        SWIVC   XCD_StopDisc
                
        B       common_end

;*************************************************************************
; This is the *Supported command - lists drives recognised by CDFS
;*************************************************************************

Supported_Code
        
        Push    "R14"
                
        ADR     r0, message_block
        ADR     r1, drivessupported
        ADR     r2, tempbuffer
        MOV     r3, #256
        SWI     XMessageTrans_Lookup
        Pull    "PC", VS
        MOV     r0, r2
        SWI     XOS_PrettyPrint         ; SMC: Why??
        SWI     XOS_NewLine
                
        CLRV
        Pull    "PC"

drivessupported
        DCB     "dr",0
        ALIGN

;*************************************************************************
; This is the *UNLOCK command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

Unlock_Code

        PushAllWithReturnFrame
        
        TEQ     R1, #1

;*****************
; Deal with parameter
;*****************

        BLEQ    atoi
        BVS     ErrorExit
        LDRNEB  R0, CurrentDriveNumber
        MOVEQ   R0, R2
                
        BL      PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block
                
        MOVVC   R0, #0
                
        SWIVC   XCD_EjectButton

common_end

        BVS    ErrorExit
        PullAllFromFrameAndExit

;*************************************************************************
WhichDisc_Code ROUT        ; displays a unique number for the disc in the drive
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

        PushAllWithReturnFrame
        
        TEQ     R1, #1                  ; Optional drive parameter?
        BLEQ    atoi
        BVS     ErrorExit
        LDRNEB  R0, CurrentDriveNumber
        MOVEQ   R0, R2

        BL      PreGetUniqueNumber      ; R0 = drive number
                                        ; RETURNS R1 = uid, R2 = changed/notchanged flag
        
        MOV     R0, R1                  ; R0 = value to be converted
        ADR     R1, TempArea            ; R1 -> place to put string
        MOV     R2, #?TempArea
        SWI     XOS_ConvertCardinal4
        SWIVC   XOS_Write0
        SWIVC   XOS_NewLine
        
        CLRV
        PullAllFromFrameAndExit

;*************************************************************************
Free_Code ROUT        ; displays used space
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

        PushAllWithReturnFrame

;******************
; Were any parameters following *Free ?
;******************

        TEQ     R1, #0                  ;
        LDREQB  R0, CurrentDriveNumber  ; [ no - so dismount current drive ]
        BEQ     %FT04                   ;

;******************
; If a ':' was the first char of the parameter THEN ignore it
;******************

        Push    "R0"

        LDRB    R1, [ R0 ]
        TEQ     R1, #":"
        ADDEQ   R0, R0, #1

;******************
; Validate the parameter for valid characters
;******************

        BL      CheckDiscName           ; R0 -> string
        
        Pull    "R0"

;******************
; Copy parameter into 'TempArea' prefixed with ':' if necessary
;******************

        ; Make sure that the name or number is prefixed with ":"
        MOV     R1, #":"
        ADR     R2, TempArea
        MOV     R3, R2

        STRB    R1, [ R2 ], #1
                
        LDRB    R1, [ R0 ], #1
        TEQ     R1, #":"
        STRNEB  R1, [ R2 ], #1
03
        LDRB    R1, [ R0 ], #1
        STRB    R1, [ R2 ], #1
        TEQ     R1, #0
        BNE     %BT03

;******************
; Prompt for disc to be inserted ( as it isn't buffered )
;******************

        ADD     R0, R3, #1
        BL      FindDiscNameInList
        CMP     R1, #-1
        SUBEQ   R0,R0,#1
        BLEQ    FindDriveNumber         ; R0 -> name or number, RETURNS R1 = drive

;******************
; Now I know the drive number !
;******************

        MOV     R0, R1

04
        BL      PreConvertDriveNumberToDeviceID
        
        SUBVC   sp, sp, #8
        MOVVC   r0, #LBAFormat
        MOVVC   r1, sp
        SWIVC   XCD_DiscUsed
        BVS     ErrorExit
        
        Pull    "r1,r2"
        
        MOV     r14, r1, LSL #16
        MOV     r1, r1, LSR #16         ; r1 = mshw of block count
        MOV     r0, r14, LSR #16        ; r0 = lshw of block count
        
        MUL     r14, r1, r2
        MUL     r3, r2, r0
        MOV     r4, r14, LSR #16
        ADDS    r3, r3, r14, LSL #16    ; r3 = lsw of usage
        ADCS    r4, r4, #0              ; r4 = msw of usage
        BNE     %FT64                   ; big disc?

        ; 32-bit size case
        MOV     r0, r3
        ADR     r1, TempArea
        MOV     r2, #9
        SWI     XOS_ConvertHex8         ; build bytecount as hex

        MOVS    r0, r3, LSR #20
        ADC     r0, r0, #0
        ADR     r1, TempArea+32
        MOV     r2, #11
        SWI     XOS_ConvertInteger4     ; build round-to-nearest megabytes as integer

        B       %FT70

64
        ; 64-bit size case
        MOV     r0, r4
        ADR     r1, TempArea
        MOV     r2, #17
        SWI     XOS_ConvertHex8
        MOV     r0, r3
        SWI     XOS_ConvertHex8         ; build bytecount as hex
        
        MOVS    r0, r3, LSR #20
        ADC     r0, r0, r4, LSL #12
        ADR     r1, TempArea+32
        MOV     r2, #11
        SWI     XOS_ConvertInteger4     ; build round-to-nearest megabytes as integer

70
        ADR     r0, message_block
        ADRL    r1, free_tag
        ADR     r2, TempArea+64
        MOV     r3, #128
        ADR     r4, TempArea
        ADR     r5, TempArea+32
        SWI     XMessageTrans_Lookup
        MOVVC   r0, r2
        SWIVC   XOS_Write0
        SWIVC   XOS_NewLine

        B       common_end

;*************************************************************************
;*************************************************************************

        LTORG

        END

@


4.19
log
@Reclassify *CDDevices
Unlike SCSI/USB/PCI/SDIO device list commands, *CDDevices required CDFS to be the active filing system. Remove the FS flag from its command table entry so it can be entered at other times.
Tested briefly, drive was listed with SCSIFS active.

Version 2.62. Tagged as 'CDFS-2_62'
@
text
@d1128 1
a1128 1
        DivRem  R3, R5, #MaxNumberOfBlocks + 1, R14   ; R6 = address MOD 75
@


4.18
log
@Various CDFS enhancements
* Increase BGET/BPUT buffer declared to FileSwitch to 2k to match the natural sector size (FileSwitch has been able to support this since version 2.28)
* Remove local debug macros, use those from NDRDebug instead
* Change to use SETV/CLRV macros now the ones in HdrSrc are 26/32 neutral
* Clarify those situations where LBA mode is being selected by using symbol 'LBAFormat'
* Extend *WHICHDISC to allow an optional drive number to be provided (the code has existed for years, but the GSTrans flags and help denied its use)

Version 2.60. Tagged as 'CDFS-2_60'
@
text
@d106 2
@


4.17
log
@Fixes for ISO format DVDs
The report for *CDDEVICES didn't line up properly for media > 999MB.
Tentative fix for DVDs formatted with directories placed above the 4GB boundary.

DiscOp.s: Preshift the directory block offset so it doesn't overflow for a DVD.
Filer.s/Free.s: Use LBA definition instead of 0.
Misc.s: Rework capacity display to handle up to 9999MB. Note, unlike OS_ConvertFileSize which rounds at 4096MB to 4GB we always express the result in MB.

Tested with a selection of CDs and DVDs from 10MB to 4800MB, all line up nicely.
The reporter of the directory issue, Steffen Huber, has been unable to test this change in time, but it should be low risk.

Version 2.57. Tagged as 'CDFS-2_57'
@
text
@d62 1
a62 1
        VCLEAR
d87 1
a87 1
        VCLEAR
d316 1
a316 1
        VCLEAR
d471 1
a471 1
        VCLEAR
d553 1
a553 1
        VCLEAR
a599 2
        Debug0

d1284 1
a1284 1
        VCLEAR
d1431 1
a1431 1
        VCLEAR
d1484 1
a1484 1
        VCLEAR
d1539 1
a1539 6
        TEQ     R1, #1

;*****************
; Deal with parameter
;*****************

d1544 3
a1546 2
        
        BL      PreGetUniqueNumber ;R0 = drive number, RETURNS R1, R2 -> disc name, or 0
d1549 2
a1550 3
                                        ; R1 -> place to put string
        ADR     R1, TempArea
        MOV     R2, #255
d1552 2
d1555 1
a1555 7
        TEQ     R0, R1
        
        SWINE   XOS_Write0
        
        SWI     XOS_NewLine
        
        VCLEAR
@


4.16
log
@Get the message right when no drives at all are present.
Retagged as CDFS-2_56.
@
text
@d102 1
a102 1
;  2 + 5  1 + 4        1 + 4   1 + 4          16 + 5        upto 11 + n  4
d220 4
a223 2
        ADR     R1, TempArea
        MOV     R0, #0
d226 3
a228 2
                
        BVC     %FT03
d231 2
a232 7
        ADR     R2, Unknown             ; capacity is unknown
02
        LDRB    R14, [ R2 ], #1         ; Copy Unknown
        TEQ     R14, #0
        STRNEB  R14, [ R6 ], #1         ;
        BNE     %BT02                   
        B       %FT11
a233 1
03
d236 18
a253 2
        LDMIA   R1, { R0, R2 }
        MUL     R0, R2, R0              ; R0 = number of blocks * size of a block
d256 8
a263 3
        SWI     XOS_ConvertFileSize
                
        MOV     R6, R1                  ; R1 -> null terminating byte
d265 2
a266 8
        SUB     R2, R1, R0              ; Length of capacity
        RSBS    R2, R2, #14 - 4         ; 3 >= n >= 0
        BEQ     %FT12
        CMP     R2, #2
        STRHIB  R4, [ R6 ], #1
        STRCSB  R4, [ R6 ], #1
        STRB    R4, [ R6 ], #1
11
d268 8
a275 2
12
        LDR     R2, tempbuffer + 32     ; Firmware revision number, eg '2.01'
d320 5
a324 1
        DCB     "Unknown", HARDSPACE, HARDSPACE, HARDSPACE, 0
d1234 1
a1234 1
        MOV     R0, #1                  ; Get MSF length of disc
d1647 1
a1647 1
        MOVVC   r0, #0                  ; LBA addressing mode
d1680 1
a1680 1
        ; 64    -bit size case
@


4.15
log
@Fix a few bugs
When lining up the code in 2.52, a few bugs became apparent (now the source was readable).
* In a handful of places it was assumed SWIs preserved flags, these have been reordered or branched around.
* The probe of UtilityModule 2.12 has been set to 3.00 and the logic now considers >= 3.00 rather than subtracting 1 from it to deduce the default filename truncation value.
* Removed support for supplemental filetype table in CDFSNewFileTypePath$File as this has been superceded by the MimeMap module (which CDFS uses). This mirrors the behaviour of DOSFS and LanManFS which consult the MimeMap first then (small) internal table second.
* Fix stack imbalance when reading the current setting with CDFS_Truncation leading to an abort

Other changes
* When the MimeMap module is absent ".doc" is taken to be a MS Word document.
* Changed the manual loads from :INDEX: of R12 to be ADR's or ADRL's so there's less literal pool thrashing.
* Three Push/Pull sequences to restore registers swapped for LDMIA's (in Directory.s).
* Reason codes to OS_ SWIs swapped for header file names.


Version 2.56. Tagged as 'CDFS-2_56'
@
text
@d280 1
a280 2

        MOVNE   R0, R11
d283 1
a283 2
        SWI     XOS_PrettyPrint
        B       %FT10
d285 1
a285 1
        ADR     r0, message_block
d293 1
d295 3
a297 2
        SWIVC   XOS_NewLine
10
@


4.14
log
@CDDriver error numbers taken from header file.
Note: CDFS' error block is actually offset within CDDriver's (by 64).
The report for *CDDevices now lines up properly with disc sizes < 100MB.
The syntax error for *PlayMSF no longer uses MessageTrans_GSLookup which tried to substitute the <> arguments.
Non internationalised module now has syntax error messages too.

Version 2.55. Tagged as 'CDFS-2_55'
@
text
@d118 1
a118 2
        LDR     R6, =:INDEX:buffer
        ADD     R6, R12, R6
d145 1
a145 1
        ADD     R0, R12, #:INDEX:tempbuffer
d220 1
a220 1
        ADD     R1, R12, #:INDEX:TempArea
d257 1
a257 1
        LDR     R2, [ R12, #:INDEX:tempbuffer + 32 ];Firmware revision number, eg '2.01'
d280 1
a280 1
        
d284 2
d287 8
a294 7
        ADREQ   r0, message_block
        addr    r1, nodrivesfound_tag, EQ
        MOVEQ   r2, r6
        MOVEQ   r3, #128
        SWIEQ   XMessageTrans_Lookup
        MOVEQ   r0, r2

d296 2
a297 3

        SWIEQ   XOS_NewLine

d414 1
a414 1
CDROMBuffers_Code
d422 1
d424 3
a426 9
        ADRLO   R0, ConfigureMessageForBuffers
        BLO     configuredrivesdoesthis

;**************
;StatusMessage                     ;  *STATUS
;**************

; This gets the value stored in CMOS ram
; then prints it in *status format
d428 1
d430 2
d441 1
a441 1
        ADD     R1, R12, #:INDEX:TempArea
d498 1
a498 1
CDROMDrives_Code
d506 1
a506 1
        ADRLO   R0, ConfigureMessage    ;
d508 3
a510 1
configuredrivesdoesthis
d512 1
a512 4
        SWILO   XOS_PrettyPrint         ;
        SWILO   XOS_NewLine             ;
                                        ;
        PullAllFromFrameAndExit LO      ; we can reasonably assume that V is clear
d514 2
d517 1
a517 9

;**************
;StatusMessage                     ;  *STATUS
;**************

        ; This gets the value stored in CMOS ram
        ; then prints it in *status format

        ADR     R0, ConfigureMessage    ; Display 'CDFSNumberOfDrives '
d524 1
a524 1
        ADD     R1, R12, #:INDEX:TempArea
d613 1
a613 1
        ADD     R2, R12, #:INDEX:TempArea
d661 1
a661 2
        LDR     R14, =:INDEX:discsMounted
        ADD     R14, R14, R12
d668 1
a668 3
        LDR     R14, =:INDEX:ListOfDiscsInDrives
        ADD     R14, R14, R12
                
d722 2
a723 3
        LDR     R1, =:INDEX:OpenFileList        ; This list contains pointers to small
        ADD     R1, R1, R12                     ; buffers for each open file or 0
                
d849 1
a849 1
        ADD     R2, R12, #:INDEX:tempbuffer
d922 1
a922 1
        ADD     R1, R12, #:INDEX:TempArea
d1023 1
a1023 3
        LDR     R1, =:INDEX:buffer      
        ADD     R1, R12, R1             ; storagea area = buffer
        
a1024 1
        
a1025 1
        
d1169 1
a1169 2
        LDR     R0, =:INDEX:buffer
        ADD     R0, R0, R12
d1182 1
d1190 3
a1192 3
        ADD     R1, R12, #:INDEX:TempArea
        CMP     R0, #10
                
d1194 1
a1194 1
                
d1197 2
a1198 1
        SWILT   &100+"0"
d1205 1
d1213 1
a1213 1
        ADD     R1, R12, #:INDEX:TempArea
d1534 1
a1534 1
        ADD     R1, R12, #:INDEX:TempArea
d1591 1
a1591 1
        ADD     R2, R12, #:INDEX:TempArea
@


4.13
log
@Exchange local definitions for central ones.
Hdr:HighFSI LowFSI Services CDROM CMOS UpCall and CDFS now used in preference to local definitions.
Macro 'Command' used to build the keyword table.
Some asserts added for safety.


Version 2.54. Tagged as 'CDFS-2_54'
@
text
@d100 1
a100 1

d102 2
a103 3

;   1 + 4  1 + 4        1 + 4   1 + 4          8 + 4         10 + 4       4

d169 1
a169 1
        STRB    R4, [ R6 ], #1
d176 1
a176 1
        BL      space                   ; R0 -> place to space, R4 = SPACE
d208 1
a208 2
                                        
        STRB    R14, [ R6 ], #1         
d213 3
a215 1
        BL      space                   ; R0 -> place to space, R4 = SPACE
d229 1
a229 3
        ADRVS   R2, Unknown             ; capacity is unknown
        ADDVS   R1, R2, #:LEN:" Unknown "       

d231 3
a233 5

        LDRVSB  R14, [ R2 ], #1         ; Copy Unknown
        STRVSB  R14, [ R6 ], #1         ;
                                        
        TEQVS   R1, R2                  
d235 1
a235 4
                                        
        STRVSB  R4, [ R6 ], #1          ;
        STRVSB  R4, [ R6 ], #1          ;
        MOVVS   R1, R6                  ;
d240 18
a257 12
        LDMVCIA R1, { R0, R2 }          ; R0 = number of blocks * size of a block
        MULVC   R0, R2, R0              ;
                
        MOVVC   R1, R6                  ; R1 -> buffer to put
        MOVVC   R2, #20                 ; R2 = length of buffer
                
        SWIVC   XOS_ConvertFixedFileSize
                
        MOV     R6, R1                  ; R0 -> null terminating byte
                
        BL      space                   ; R0 -> place to space, R4 = SPACE
        
a258 1

d301 1
a301 1
        DCB     " Unknown "
d1419 1
a1419 1
        SWI     XMessageTrans_GSLookup
@


4.12
log
@Collapse old switches.
Switches from 10+ years ago removed. Demo version switch removed.

Version 2.53. Not tagged
@
text
@d50 6
a55 3
      [ bufferlist=ON                   ; Only works during debugging

Buf ; Display buffers
d72 1
a72 1
Bye ROUT ; Closes all files, emptys all drives
d92 1
a92 1
CDDevices  ROUT                     ; no parameters *CDDevices
d319 1
a319 1
CDSpeed ROUT
d415 1
a415 1
Buffers
d469 1
a469 2
        ORR     R0, R0, #bit_29
        
a470 1
        
d501 1
a501 1
NumberOfDrives
d560 1
a560 1
        ORR     R0, R0, #bit_29
d580 1
a580 1
Dismount ROUT  ; *Dismount drive number or disc name
d662 2
a663 2
      [ LENGTHOFDISCNAME<>32
        MOV     R3, #LENGTHOFDISCNAME
d775 1
a775 1
Eject
d806 1
a806 1
Lock
d831 2
a832 2
Drive ROUT     ; *Drive is now implemented as *Mount
Mount ROUT     ; *Mount drive number or disc name
d906 1
a906 1
Play
d989 1
a989 2
        MOV     R0, #10
        ORR     R0, R0, #(1:SHL:31)     ; make sure terminator is control char or space
d1019 1
a1019 1
PlayList
d1284 1
a1284 1
PlayMSF ROUT ; Plays from time 1 to time 2
d1441 1
a1441 1
Stop
d1466 1
a1466 1
Supported
d1497 1
a1497 1
Unlock
d1524 1
a1524 1
WhichDisc ROUT        ; displays a unique number for the disc in the drive
d1564 1
a1564 1
Free ROUT        ; displays used space
@


4.11
log
@Resolve the 32 assembler warnings
Mostly by swapping STASH/GRAB for Push/Pull macros.
Inlined the module header rather than defining it in a header file.
Renamed "Debug" macro to "DebugInline" to avoid clash with similarly named macro.

Version 2.53. Tagged as 'CDFS-2_53'
@
text
@a180 3
      [ Module_Version >= 218

        ; the new way
a190 15
      |

        ; the old way
        ADD     R1, R2, #"0"            ; LUN
        STRB    R1, [ R6 ], #1          ;
        
        BL      space                   ; R0 -> place to space, R4 = SPACE
        
        ADD     R1, R10, #"0"           ; card number
        STRB    R1, [ R6 ], #1          ;
        
        BL      space                   ; R0 -> place to space, R4 = SPACE

      ]

a763 37

; This now uses *Mount
    [ Module_Version < 220
;*************************************************************************
; This is the *Drive command
Drive ROUT
;*************************************************************************

        ; entry
        ; R0 -> parameters following '*Drive'
        ; R1 = number of parameters on line
       
        PushAllWithReturnFrame

        MOV     R1, R0                  ; R1 -> value to convert
        MOV     R0, #10                 ; base 10, use maximum value in R2
        ORR     R0, R0, #bit_29         ;
        MOV     R2, #MAXNUMBEROFDRIVESSUPPORTED ; maximum number = 27
        SWI     XOS_ReadUnsigned        ; RETURNS R2 = drive number

        MOVVS   r0, #ERROR_BADDRIVE
        BVS     ErrorExit

        STRB    R2, CurrentDriveNumber
        ADR     R0, root_dir

      [ Module_Version >= 220
        MOV     r6, #0
      ]

        B       SetDir_fixed_for_drive

root_dir
        DCB     "$", 0
        ALIGN
    ]

a828 4
; *Drive is now implemented as *Mount
      [ Module_Version >= 220
Drive ROUT
      ]
d830 1
a851 1
      [ Module_Version >= 220
d853 1
a853 1
      ]
a885 2

      [ Module_Version >= 220
a886 1
      ]
@


4.10
log
@Line up sources to normal columns.
Around 25000 spaces required, but rather easier to read as a result - it has revealed some bugs (not addressed in this commit).
Not quite binary identical, because an 'addr' of the ambiguous disc name error has moved by 1 byte due to a missing ALIGN directive.
Not tagged.
@
text
@a17 2
; EACH NEW STAR COMMAND ADDED SHOULD USE STASHALL AND GRABALL IF TRAP ERRORS

d19 1
a19 1

d55 1
a55 1
        STASHALL
d60 1
a60 1
        GRABALLANDRETURN
d72 1
a72 1
        STASHALL
d85 1
a85 1
        GRABALLANDRETURN
d104 1
a104 1
        STASHALL
d315 1
a315 1
        GRABALLANDRETURN
d340 1
a340 1
        STASHALL
d380 1
a380 1
        STASH   r0-r3
d389 1
a389 1
        GRAB    r0-r3
d434 1
a434 1
        STASHALL
d468 1
a468 1
        GRABALLANDRETURN
d490 1
a490 1
        GRABALL VS                      ; Indicate 'Parameter too big'
d522 1
a522 1
        STASHALL
d533 1
a533 1
        GRABALLANDRETURN LO             ; we can reasonably assume that V is clear
d559 1
a559 1
        GRABALLANDRETURN
d581 1
a581 1
        GRABALL VS                      ; Indicate 'Parameter too big'
d591 1
a591 1
        GRABALL VS                      ;
d594 1
a594 1
        GRABALLANDRETURN
d603 1
a603 1
        STASHALL
d619 1
a619 1
        STASH   R0
d631 1
a631 1
        GRAB    R0
d762 1
a762 1
        GRABALL EQ                      ;
d772 1
a772 1
        STASH   R0-R1                   ; [ yes ] - so close that file
d778 1
a778 1
        GRAB    R0-R1
d794 1
a794 1
        STASHALL
d831 1
a831 1
        STASHALL
d862 1
a862 1
        STASHALL
d895 1
a895 1
        STASHALL
d969 1
a969 1
        STASHALL
d981 1
a981 1
        STASH   R2
d1005 1
a1005 1
        GRAB    R2
d1044 1
a1044 1
        STASH   "R14"
d1047 1
a1047 1
        STASH   "R1", EQ
d1057 3
a1059 3
        GRAB    "R1", EQ
        GRAB    "PC", VS
        GRABS   "PC", NE
d1061 1
a1061 1
        GRAB    "PC"
d1083 1
a1083 1
        STASHALL
d1343 1
a1343 1
        GRABALLANDRETURN
d1355 1
a1355 1
        STASHALL
d1490 1
a1490 1
        GRABALLANDRETURN
d1505 1
a1505 1
        STASHALL
d1530 1
a1530 1
        STASH   "R14"
d1537 1
a1537 1
        GRAB    "PC", VS
d1543 1
a1543 1
        GRAB    "PC"
d1561 1
a1561 1
        STASHALL
d1583 1
a1583 1
        GRABALLANDRETURN
d1595 1
a1595 1
        STASHALL
d1623 1
a1623 1
        GRABALLANDRETURN
d1635 1
a1635 1
        STASHALL
d1649 1
a1649 1
        STASH   R0
d1661 1
a1661 1
        GRAB    R0
d1708 1
a1708 1
        GRAB    "r1,r2"
a1766 2
; EACH NEW STAR COMMAND ADDED SHOULD USE STASHALL AND GRABALL IF TRAP ERRORS

@


4.9
log
@Fixed top-bit-set problem that stopped *Configure from working outside the
desktop. Added GPA capability.

Version 2.47. Tagged as 'CDFS-2_47'
@
text
@d52 1
a52 1
 [ bufferlist=ON           ; Only works during debugging
d57 1
a57 1
 STASHALL
d59 1
a59 1
 BL DisplayBuffers
d61 2
a62 2
 VCLEAR
 GRABALLANDRETURN
d66 1
a66 1
 ]
d68 1
a68 1
 LTORG
d74 1
a74 1
 STASHALL
d82 6
a87 6
 MOV R0, #0
 MOV R1, #0
 SWI XOS_Find

 VCLEAR
 GRABALLANDRETURN
d106 23
a128 28
 STASHALL

 ; R0 -> tempbuffer is used to receive the details of the Inquiry command

 ; R4 = hardspace

 ; R6 -> Buffer is used to hold the characters to be displayed

 ; R7 -> spare control block

 ; R9 = Number of CDROMs found

 MOV R4, #HARDSPACE

 MOV R9, #0

 LDR R6, =:INDEX:buffer
 ADD R6, R12, R6

             ADR       r0, message_block
             addr      r1, cddevicesheader_tag
             MOV       r2, r6
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             BVS       ErrorExit
             MOV       r0, r2
             SWI       XOS_PrettyPrint

d130 1
a130 3
 MOV R11, R6

; ADD R7, R12, #sparecontrolblock_offset
a133 1

d138 3
a140 3
 MOV R0, R9
 BL PreConvertDriveNumberToDeviceID ; on VS R0 -> error block
 BVS DisplayDevice               ; No such device
d146 3
a148 3
 ADD R0, R12, #:INDEX:tempbuffer
 SWI XCD_Inquiry          ; R0 -> where to put data,R7 -> control block
 BVS inquiryerror
d158 50
a207 21
 MOV R1, R9

; DivRem R3, R1, #10, R14
 DivideBy10 R1, R3, R14

 ADD R1, R1, #"0"
 STRB R1, [ R6 ], #1
 ADD R3, R3, #"0"
 STRB R3, [ R6 ], #1

 BL space


;************

 STRB R4, [ R6 ], #1

 LDMIA R7, { R1, R2, R10 }

 ADD R1, R1, #"0"         ; device id
 STRB R1, [ R6 ], #1      ;
d209 1
a209 35
 BL space                 ; R0 -> place to space, R4 = SPACE


;------------------------------------------------
; The LUN and card number are the wrong way round
;------------------------------------------------

 [ Module_Version >= 218

; the new way

           ADD       r1, r10, #"0"         ; card number
           STRB      r1, [ r6 ], #1

           BL        space

           ADD       r1, r2, #"0"          ; LUN
           STRB      r1, [ r6 ], #1

           BL        space

 |

; the old way
 ADD R1, R2, #"0"         ; LUN
 STRB R1, [ R6 ], #1      ;

 BL space                 ; R0 -> place to space, R4 = SPACE

 ADD R1, R10, #"0"        ; card number
 STRB R1, [ R6 ], #1      ;

 BL space                 ; R0 -> place to space, R4 = SPACE

 ]
d217 2
a218 2
 ADD R2, R0, #16           ; CD-ROM CDU 6XXX or LMS 212
 ADD R1, R2, #16
d222 11
a232 11
 LDRB R14, [ R2 ], #1

 TEQ R14, #SPACE         ; Convert spaces to hard spaces
 MOVEQ R14, #HARDSPACE   ;

 STRB R14, [ R6 ], #1

 TEQ R1, R2
 BNE %BT01

 BL space                ; R0 -> place to space, R4 = SPACE
d238 6
a243 6
 ADD R1, R12, #:INDEX:TempArea
 MOV R0, #0

 SWI XCD_DiscUsed

 BVC %FT03
d246 2
a247 3
 ADRVS R2, Unknown          ; capacity is unknown

 ADDVS R1, R2, #?Unknown
d251 9
a259 9
 LDRVSB R14, [ R2 ], #1   ; Copy Unknown
 STRVSB R14, [ R6 ], #1   ;

 TEQVS R1, R2
 BNE %BT02

 STRVSB R4, [ R6 ], #1    ;
 STRVSB R4, [ R6 ], #1    ;
 MOVVS R1, R6             ;
d264 13
a276 13
 LDMVCIA R1, { R0, R2 }     ; R0 = number of blocks * size of a block
 MULVC R0, R2, R0           ;

 MOVVC R1, R6               ; R1 -> buffer to put
 MOVVC R2, #20              ; R2 = length of buffer

 SWIVC XOS_ConvertFixedFileSize

 MOV R6, R1                 ; R0 -> null terminating byte

 BL space                   ; R0 -> place to space, R4 = SPACE

 LDR R2, [ R12, #:INDEX:tempbuffer + 32 ];Firmware revision number, eg '2.01'
d279 6
a284 6
 STRB R2, [ R6 ], #1
 MOVS R2, R2, LSR #8
 BNE %BT13

 MOV R3, #13
 STRB R3, [ R6 ], #1
d288 4
a291 4
 ADD R9, R9, #1
 LDRB R14, numberofdrives; any more drives to look for ?
 CMP R14, R9
 BHS and_why_not         ; [ yes ]
d299 23
a321 25
 TEQ R9, #0

 MOVNE R0, R11
 MOVNE R4, #0
 STRNEB R4, [ R6 ]

             ADREQ     r0, message_block
             addr      r1, nodrivesfound_tag, EQ
             MOVEQ     r2, r6
             MOVEQ     r3, #128
             SWIEQ     XMessageTrans_Lookup
             MOVEQ     r0, r2

 SWI XOS_PrettyPrint

 SWIEQ XOS_NewLine

;*********************

 VCLEAR
 GRABALLANDRETURN

Unknown =  " Unknown "

 ALIGN
d324 5
a328 5
 STRB R4, [ R6 ], #1
 STRB R4, [ R6 ], #1
 STRB R4, [ R6 ], #1
 STRB R4, [ R6 ], #1
 MOV PC, R14
d342 55
a396 56
 STASHALL

 MOV         r4, r1

;----------------
; Current drive ?
;----------------
 CMP         r1, #1

 BLGE        atoi
 BVS         ErrorExit
  MOVGT       r3, r0
 MOVGE       r0, r2
 LDRLTB      r0, CurrentDriveNumber

;----------------
; Device number ?
;----------------
 BL          PreConvertDriveNumberToDeviceID        ; R0 = drive number, returns R7 -> block
 BVS         ErrorExit

;---------------------
; Get current settings
;---------------------
 ADR         r0, TempArea
 SWI         XCD_GetParameters ; r0->storage area, r7->block
 BVS         ErrorExit

;--------------------------
; Display current setting ?
;--------------------------
 CMP         r4, #2
 BGE         %FT01

 MOV         r1, r0
 LDRB        r0, [ r1, #12 ]
 MOV         r2, #4
 SWI         XOS_BinaryToDecimal
 MOV         r0, r1

             STASH     r0-r3
             ADR       r0, message_block
             addr      r1, currentspeed_tag
             ADR       r2, TempArea + 100
             MOV       r3, #128
             SWI       XMessageTrans_Lookup
             BVS       ErrorExit
             MOV       r0, r2
             SWI       XOS_Write0
             GRAB      r0-r3


 MOV         r1, r2
 SWI         XOS_WriteN
 SWI         XOS_NewLine
 B           common_end
d406 5
a410 5
 MOV         r4, r0
 MOV         r0, r3
 BL          atoi
 BVS         ErrorExit
 STRB        r2, [ r4, #12 ]
d415 4
a418 4
 MOV         r0, r4
 SWI         XCD_SetParameters

 B           common_end
d434 9
a442 13
 LDR R12, [ R12 ]

 STASHALL
                                  ; Just print the configure description
 CMP R0, #1                       ; message

 BHI SetNumberOfBuffers           ;  *CONFIGURE number


 ADRLO R0, ConfigureMessageForBuffers;
                                  ;
 BLO configuredrivesdoesthis

d452 19
a470 24
 ADR R0, ConfigureMessageForBuffers ; Display 'CDROMBuffers '
 MOV R1, #13                        ;
 SWI XOS_WriteN                     ;

 SWI XCDFS_GetBufferSize        ; RETURNS R0 = 0 to 7

 BL ConvertBufferSizeToReal     ; R0 = bit values, RETURNS R1 = buffer actual

 MOV R0, R1

 ADD R1, R12, #:INDEX:TempArea

 MOV R2, #20

 SWI XOS_ConvertCardinal2      ; see page 602  ( integers from 0 to 65535 )

 SWI XOS_PrettyPrint

 SWI XOS_WriteI + "K"

 SWI XOS_NewLine

 VCLEAR
 GRABALLANDRETURN
d480 28
a507 38
 MOV R1, R0                  ; R1 -> string

 MOV R0, #10                 ; base 10

 ; restrict number to be in range 0 - maxnumberofdrivessupported

 ORR R0, R0, #bit_29

 MOV R2, #MAXBUFFERSIZE

 SWI XOS_ReadUnsigned

 GRABALL VS                     ; Indicate 'Parameter too big'
 MOVVS R0, #2                   ;
 MOVVS PC, R14                  ;



 MOV R0, R2

 BL ConvertRealBufferToSize     ; R0 = number of K, RETURNS R1 = bit setting

 MOV R0, R1

 SWI XCDFS_SetBufferSize

; BVS ErrorExit                   ; Indicate the unknown error to FS

; GRABALL

; BICS PC, R14, #Overflow_Flag

 B common_end

ConfigureMessage = "CDROMDrives", SPACE, "<D>", 0
ConfigureMessageForBuffers = "CDROMBuffers", SPACE, "<D>[K]", 0

 ALIGN
d522 7
a528 10
 LDR R12, [ R12 ]

 STASHALL
                                  ; Just print the configure description
 CMP R0, #1                       ; message

 BHI SetNumberOfDrives            ;  *CONFIGURE number


 ADRLO R0, ConfigureMessage       ;
d532 4
a535 5
 SWILO XOS_PrettyPrint            ;
                                  ;
 SWILO XOS_NewLine                ;
                                  ;
 GRABALLANDRETURN LO              ; we can reasonably assume that V is clear
d543 2
a544 21
; This gets the value stored in CMOS ram
; then prints it in *status format


 ADR R0, ConfigureMessage      ; Display 'CDFSNumberOfDrives '
 MOV R1, #12
 SWI XOS_WriteN                ;

 SWI XCDFS_GetNumberOfDrives    ; RETURNS R0 = number of drives conf.

 BVS ErrorExit

 ADD R1, R12, #:INDEX:TempArea

 MOV R2, #20

 SWI XOS_ConvertCardinal1      ; see page 602

 SWI XOS_PrettyPrint

 SWI XOS_NewLine
d546 16
a561 2
 VCLEAR
 GRABALLANDRETURN
d572 25
a596 30
;                   Make the string into a real number

 MOV R1, R0                    ; R1 -> string

 MOV R0, #10                   ; base 10

 ; restrict number to be in range 0 - maxnumberofdrivessupported

 ORR R0, R0, #bit_29

 MOV R2, #MAXNUMBEROFDRIVESSUPPORTED

 SWI XOS_ReadUnsigned

 GRABALL VS                     ; Indicate 'Parameter too big'
 MOVVS R0, #2                   ;
 MOVVS PC, R14                  ;


; This gets the value currently stored in CMOS ram

 MOV R0, R2

 SWI XCDFS_SetNumberOfDrives

 STRVS R0, [R13]                ; Indicate the unknown error to FS
 GRABALL VS                     ;
 MOVVS PC, R14                  ;

 GRABALLANDRETURN
d605 1
a605 1
 STASHALL
d607 1
a607 2
; Debug " *Dismount "
 Debug0
d613 3
a615 3
 TEQ R1, #0                          ;
 LDREQB R0, CurrentDriveNumber       ; [ no - so dismount current drive ]
 BEQ %FT04                           ;
d621 5
a625 7
; Debug " Check : "

 STASH R0

 LDRB R1, [ R0 ]
 TEQ R1, #":"
 ADDEQ R0, R0, #1
d631 1
a631 1
 BL CheckDiscName              ; R0 -> string
d633 1
a633 1
 GRAB R0
d639 1
a639 11
; Make sure that the name or number is prefixed with ":"

 MOV R1, #":"
 ADD R2, R12, #:INDEX:TempArea
 MOV R3, R2

 STRB R1, [ R2 ], #1

 LDRB R1, [ R0 ], #1
 TEQ R1, #":"
 STRNEB R1, [ R2 ], #1
d641 9
d653 5
a657 5
 LDRB R1, [ R0 ], #1
 STRB R1, [ R2 ], #1
 TEQ R1, #0

 BNE %BT03
d663 5
a667 6
 ADD R0, R3, #1
 BL FindDiscNameInList
 CMP R1, #-1
 SUBEQ R0,R0,#1
; MOV R0, R3
 BLEQ FindDriveNumber             ; R0 -> name or number, RETURNS R1 = drive
d673 1
a673 2
 MOV R0, R1

d680 13
a692 26
; Version 2.12 needs this back in
; [ RISC_OS =2

; [ debug=ON
; SWI &100+4
; SWI &100+12
; Debug " Wipe name, drive = "
; MOV    R4, R0
; DebugDisplay R4
; ]

 LDR    R2, =:INDEX:DiscNameList
 [      LENGTHOFDISCNAME<>32
 MOV    R3, #LENGTHOFDISCNAME
 MLA    R4, R3, R0, R2
 |
 ADD    R4, R2, R0, LSL #5
 ]
 MOV    R3, #0
 STRB   R3, [ R4, R12 ]!
; STRB   R3, [ R4, #1 ]

 LDR    R14, =:INDEX:discsMounted
 ADD    R14, R14, R12
 STR    R3, [ R14, R0, LSL #2 ]
; ]
d698 9
a706 13
; Version 2.12 needs this back in
; [ RISC_OS=2
 LDR R14, =:INDEX:ListOfDiscsInDrives
 ADD R14, R14, R12

 LDR    R0, [ R14, R0, LSL #2 ]!
 STR    R3, [ R14 ]
; ]

; ADD R7, R12, #:INDEX:sparecontrolblock
 BL PreConvertDriveNumberToDeviceID
 SWI XCD_DiscHasChanged
 BVS ErrorExit
d717 4
a720 5
; R0 = disc
; R1 = block
; R2 -> buffer list

 LDR R2, pointerToBufferList
d728 14
a741 15
 LDMIA R2!, { R1, R4, R5, R6 }    ; R1 = disc, R4 = buffer, R5 = block
                                  ; r6=offset
 TEQ R4, #0                       ; Last entry in list ?
 BEQ %FT02                        ; [ yes ]


 TEQ R1, R0
 BNE %BT01

 MOV R1, R5
 BL DeleteBuffer                   ; R0 = unique number, R1 = block number
; SUB R2, R2, #SIZEOFBUFFERENTRY    ; Move back ( list is shuffled )
 LDR R2, pointerToBufferList       ; start from begining again

 B %BT01
d749 9
a757 11
; R0 = disc number to look for
; R1 -> current pointer in list
; R2 = number searched so far ( 255 to 0 ) BACKWARDS !
; R3 = disc number of little buffer
; R4 -> little buffer


 LDR R1, =:INDEX:OpenFileList        ; This list contains pointers to small
 ADD R1, R1, R12                     ; buffers for each open file or 0

 MOV R2, #MAXNUMBEROFOPENFILES - 3   ; From 253 to 0
d761 22
a782 24
 LDR R4, [ R1 ], #4

 SUBS R2, R2, #1                     ; Reached end ?
 GRABALL EQ                          ;
 MOVEQ PC, R14                       ; [ yes ]  V is clear

 TEQ R4, #0                          ; Number not used ?
 BEQ %BT05                           ; [ not used ]

 LDR R3, [ R4, #DISCNUMBEROPEN ]     ; Does this buffer come from this disc ?
                                     ;
 TEQ R3, R0                          ;

 BNE %BT05
                                     ;
 STASH R0-R1                         ; [ yes ] - so close that file

 MOV R0, #0
 LDR R1, [ R4, #FILESWITCHHANDLE ]
 SWI XOS_Find
                                     ;
 GRAB R0-R1

 B %BT05
d786 1
a786 1
 [ Module_Version < 220
d792 28
a819 47
; entry
; R0 -> parameters following '*Drive'
; R1 = number of parameters on line


 STASHALL

 MOV R1, R0                      ; R1 -> value to convert

 MOV R0, #10                     ; base 10, use maximum value in R2
 ORR R0, R0, #bit_29             ;

 MOV R2, #MAXNUMBEROFDRIVESSUPPORTED  ; maximum number = 27

 SWI XOS_ReadUnsigned            ; RETURNS R2 = drive number

           MOVVS       r0, #ERROR_BADDRIVE
           BVS         ErrorExit

; MOV R3, #LENGTHOFDISCNAME       ; If drive has not been mounted then cannot
; LDR R0, =DiscNameList_offset    ; change to it
; MLA R0, R3, R2, R0              ;
; ADD R0, R0, R12                 ;
; LDRB R1, [ R0 ]                 ;
; TEQ R1, #0                      ;
; GRABALL EQ                      ;
; BICEQS PC, R14, #Overflow_Flag  ;


 STRB R2, CurrentDriveNumber

 ADR R0, root_dir

 [ Module_Version >= 220
       MOV        r6, #0
 ]

 B SetDir_fixed_for_drive

; GRABALL

; BICS PC, R14, #Overflow_Flag

root_dir = "$", 0
 ALIGN

 ]
d833 1
a833 7
 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************
d835 1
a835 4
 BLEQ atoi
 BVS ErrorExit
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2
d837 14
a850 10
 BL PreConvertDriveNumberToDeviceID        ; R0 = drive number, R7 -> block

 SWIVC XCD_OpenDrawer

; BVS ErrorExit

; GRABALL

; BICS PC, R14, #Overflow_Flag
 B common_end
d864 1
a864 7
 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************
d866 1
a866 4
 BLEQ atoi
 BVS ErrorExit
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2
d868 14
a881 1
 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block
d883 1
a883 10
 MOVVC R0, #1

 SWIVC XCD_EjectButton

; BVS ErrorExit

; GRABALL

; BICS PC, R14, #Overflow_Flag
 B common_end
d887 1
a887 1
 [ Module_Version >= 220
d889 1
a889 1
 ]
d897 1
a897 3
 STASHALL

; IF NOTHING SUPPLIED THEN COPY IN THE CSD DISC NAME/ DRIVE NUMBER
d899 1
a899 19
 TEQ R1, #0
; MB FIX
; this caused attempted writing to ROM doh!
; original code: ADREQ R0, BlankPath     ; R0 -> '$'
; instead of that, construct a "$" string in the tenpbuffer area and use that
 ADREQ R0,tempbuffer
 MOVEQ R1,#"$"
 STREQB R1,[R0,#0]
 MOVEQ R1,#0
 STREQB R1,[R0,#1]
; end MB FIX
 [ Module_Version >= 220
       MOVEQ      r6, #0
 ]
 BEQ SetDir_fixed_for_mount

 ;*****************
 ; Deal with parameter
 ;*****************
d901 30
a930 10
 ; Make sure that the name or number is prefixed with ":"

 ADD R2, R12, #:INDEX:tempbuffer
 MOV R3, R2

 LDRB R1, [ R0 ]
 TEQ R1, #":"
 MOVNE R1, #":"
 ADDEQ R0, R0, #1
 STRB R1, [ R2 ], #1
d934 23
a956 25
 LDRB R1, [ R0 ], #1
 CMP R1, #32
 STRGTB R1, [ R2 ], #1
 BGT %BT01

 MOV R1, #"."
 STRB R1, [ R2 ], #1
 MOV R1, #"$"
 STRB R1, [ R2 ], #1
 MOV R1, #0
 STRB R1, [ R2 ], #1

 MOV R0, R3

 [ Module_Version >= 220
       MOV        r6, #0
 ]

 B SetDir_fixed_for_mount          ; R0 -> path

BlankPath = "$", 0

 ALIGN


d971 13
a983 1
 STASHALL
d985 3
a987 1
 TEQ R1, #2
d989 23
a1011 3
 ;*****************
 ; Deal with parameter
 ;*****************
d1013 2
a1014 3
 BL atoi ; r0->first parameter, RETURNS r0->next param (if any),
         ; RETURNS r2=value
 BVS ErrorExit
d1016 1
a1016 1
 STASH R2
d1018 2
a1019 3
 ;****************
 ; Make sure that that track exists
 ;****************
d1021 3
a1023 43
 ;*****************
 ; Find number of tracks on disc
 ;*****************

 BLEQ atoi
 ADDVS R13, R13, #4
 BVS ErrorExit
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 ADD R1, R12, #:INDEX:TempArea

 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block

; SWI XCD_StopDisc   ; Hitachi doesn't like enquiring while playing audio

 MOVVC R0, #0

 SWIVC XCD_EnquireTrack

 BVS ErrorExit

 GRAB R2

 LDRB R6, [ R1, #0 ]  ; start track

 LDRB R14, [ R1, #1 ]  ; end track

 CMP R2, R14                           ; number too big ?

         MOVGT     r0, #ERROR_TOOBIG
         BGT       ErrorExit

 CMP R2, R6                            ; number too small ?

         MOVLT     r0, #ERROR_TOOSMALL
         BLT       ErrorExit



 ;****************
 ; Play track
 ;****************
d1026 6
a1031 14
 MOV R1, #&FF                          ; R1 = play to end of disc
                                       ; ( or to start of a data track )

 MOV R0, R2                            ; R2 contains the integer result

 SWI XCD_PlayTrack

; BVS ErrorExit

; GRABALL

; BICS PC, R14, #Overflow_Flag

 B common_end
d1046 18
a1063 31
; STASH R14
; convert parameter to integer
; SWI XOS_EvaluateExpression
;; addr R0, InvalidParameter, VS ; result is not an integer (or something)
; BVS ErrorExit
; Move to next param
;01
; LDRB R1, [ R0 ], #1
; CMP R1, #32
; BGT %BT01
; GRAB R14
; MOVS PC, R14

 STASH "R14"
 MRS R1, CPSR
 TEQ PC, PC
 STASH "R1", EQ

 MOV R1, R0
 MOV R0, #10
 ORR R0, R0, #(1:SHL:31)  ; make sure terminator is control char or space
 SWI XOS_ReadUnsigned

 MOVVC R0, R1

 TEQ PC, PC
 GRAB "R1", EQ
 GRAB "PC", VS
 GRABS "PC", NE
 MSR CPSR_f, R1
 GRAB "PC"
a1075 1

a1080 1

d1085 40
a1124 41
 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter(s)
 ;*****************

 BLEQ atoi
 BVS ErrorExit
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block


 LDR R1, =:INDEX:buffer
 ADD R1, R12, R1             ; storagea area = buffer

 MOVVC R0, #0

 SWIVC XCD_EnquireTrack

 BVS ErrorExit

 LDRB R10, [ R1 ]        ; start track
 LDRB R11, [ R1, #1 ]    ; end track
 MOV R6, R10             ; current track

 MOV R9, R1

             ADR       r0, message_block
             addr      r1, playlist_tag
             MOV       r2, r9
             MOV       r3, #128
             SWI       XMessageTrans_Lookup
             BVS       ErrorExit
             MOV       r0, r2
             SWI       XOS_Write0

 SWI XOS_NewLine
d1128 4
a1131 4
 MOV R0, R6
 ADD R1, R12, #:INDEX:TempArea
 SWI XCD_EnquireTrack
 BVS ErrorExit
d1137 15
a1151 15
             ADR       r0, message_block
             addr      r1, track_tag
             MOV       r2, r9
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             BVS       ErrorExit
             ADD       r9, r2, r3

 MOV R0, R6
 MOV R1, R9
 MOV R2, #255

 CMP R0, #10
 MOVLT R14, #"0"
 STRLTB R14, [ R1 ], #1
d1153 2
a1154 2
 SWI XOS_ConvertCardinal1      ; R0 = value, R1->buffer, R2=buffersize
                               ; RETURNS R0->buffer,R1->end,R2=bytes left
d1156 2
a1157 2
 MOV R9, R1
 MOV R14, #HARDSPACE
d1159 15
a1173 15
 TST R9, #3
 STRNEB R14, [ R9 ], #1
 BNE %BT12

 LDRB R14, TempArea + 4        ; If control bits AND 1 = 0 THEN audio
 TST R14, #1                   ; ELSE data

             ADR       r0, message_block
             addr      r1, audio_tag, EQ
             addr      r1, data_tag, NE
             MOV       r2, r9
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             BVS       ErrorExit
             ADD       r9, r2, r3
d1179 41
a1219 43
; R5 = LBA of start of track

 LDR R5, TempArea
 ADD R5, R5, #150

; R6 = frames
; R3 = seconds
; R0 = minutes
                                               ; R3 = address DIV 75
                                               ;
 DivRem R3, R5, #MaxNumberOfBlocks + 1, R14    ; R6 = address MOD 75

 DivRem R0, R3, #MaxNumberOfSeconds + 1, R14   ; R0 = ( address / 75 ) / 60
                                               ;
                                               ; R3 = ( address/75 ) MOD 60

 MOV R8, #":"
 MOV R4, #"0"

 MOV R1, R9
; MOV R2, #255
 CMP R0, #10
 STRLTB R4, [ R1 ], #1
 SWI XOS_ConvertCardinal1      ; R0 = value, R1->buffer, R2=buffersize
                              ; RETURNS R0->buffer,R1->end,R2=bytes left

 STRB R8, [ R1 ], #1

 MOV R0, R3
 CMP R0, #10
 STRLTB R4, [ R1 ], #1
 SWI XOS_ConvertCardinal1      ; R0 = value, R1->buffer, R2=buffersize

 STRB R8, [ R1 ], #1

 MOV R0, R5
 CMP R0, #10
 STRLTB R4, [ R1 ], #1
 SWI XOS_ConvertCardinal1      ; R0 = value, R1->buffer, R2=buffersize

 MOV R9, R1

 MOV R0, #HARDSPACE
d1221 4
a1224 4
 ADD R14, R9, #1              ; Word align for "Track"
 TST R14, #3
 STRNEB R0, [ R9 ], #1
 BNE %BT13
d1230 2
a1231 2
 MOV R0, #NEWLINE
 STRB R0, [ R9 ], #1
d1237 6
a1242 6
 ADD R6, R6, #1               ;  Increment current_track%

 CMP R6, #99                  ;  Make sure that can't infinite loop
 CMPLE R6, R11

 BLE PlayListLoop
d1248 8
a1255 9
 MOV R0, #0                   ; terminator
 STRB R0, [ R9 ]

 LDR R0, =:INDEX:buffer
 ADD R0, R0, R12

 MOV R9, R0

 SWI XOS_PrettyPrint
d1261 42
a1302 44
             ADR       r0, message_block
             addr      r1, total_tag
             ADR       r2, TempArea
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             MOVVC     r0, r2
             ADDVS     r0, r0, #4
             SWI       XOS_Write0

 SUB R0, R11, R10
 ADD R0, R0, #1
 ADD R1, R12, #:INDEX:TempArea
 CMP R0, #10

 MOV R2, #3

 SWI XOS_ConvertCardinal1

 SWILT &100+"0"
 SWI XOS_Write0

             ADR       r0, message_block
             addr      r1, tracks2_tag
             ADR       r2, TempArea
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             MOVVC     r0, r2
             ADDVS     r0, r0, #4
             SWI       XOS_PrettyPrint


 MOV R0, #1                        ; Get MSF length of disc
 ADD R1, R12, #:INDEX:TempArea     ;
 SWI XCD_DiscUsed                  ;
 BVS ErrorExit

 LDR R6, [ R1 ]               ; R0 = end of disc

; LDR R1, =buffer_offset       ; R1 -> buffer for printing
; ADD R1, R1, R12              ;
 MOV R1, R9
 MOV R2, #255
 MOV R7, #":"
 MOV R8, #"0"
a1304 1

d1307 9
a1315 9
 MOV R0, R6, ASR #16          ; MINUTES
 AND R0, R0, #&FF             ;

 CMP R0, #10
 STRLTB R8, [ R1 ], #1        ; '0'

 SWI XOS_ConvertCardinal1     ; R0 = value,R1->buffer,R2=sizeofbuffer
                              ; RETURNS R0 -> buffer,R1->end,R2=bytes left
 STRB R7, [ R1 ], #1          ; ':'
d1319 9
a1327 9
 MOV R0, R6, ASR #8           ; SECONDS
 AND R0, R0, #&FF             ;

 CMP R0, #10
 STRLTB R8, [ R1 ], #1        ; '0'

 SWI XOS_ConvertCardinal1     ; R0 = value,R1->buffer,R2=sizeofbuffer
                              ; RETURNS R0 -> buffer,R1->end,R2=bytes left
 STRB R7, [ R1 ], #1          ; ':'
d1331 15
a1345 18
 AND R0, R6, #&FF             ;

 CMP R0, #10
 STRLTB R8, [ R1 ], #1        ; '0'

 SWI XOS_ConvertCardinal1     ; R0 = value,R1->buffer,R2=sizeofbuffer
                              ; RETURNS R0 -> buffer,R1->end,R2=bytes left


; LDR R0, =buffer_offset       ; R0 -> buffer for printing
; ADD R0, R0, R12              ;
 MOV R0, R9
 SWI XOS_Write0

 SWI XOS_NewLine

 VCLEAR
 GRABALLANDRETURN
d1357 1
a1357 1
 STASHALL
d1363 3
a1365 3
 MOV R2, R0

 MOV R5, #2
d1368 16
a1383 19

 BL %FT10               ; check for '0' to '9', R4 corrupted

 BL %FT10               ; check for '0' to '9', R4 corrupted

 LDRB R3, [ R2 ], #1                  ;
 TEQ R3, #":"                         ;
 BNE %FT01                            ;

 SUBS R5, R5, #1
 BNE %BT01

 BL %FT10               ; check for '0' to '9', R4 corrupted

 BL %FT10               ; check for '0' to '9', R4 corrupted

 SUB R14, R2, R0                 ; Check the second parameter ?
 CMP R14, #8                     ;
 BLT %BT01                       ; [ yes ]
d1399 1
a1399 1
 MOV R8, #-1
d1406 1
a1406 1
 MOV R2, R0
d1412 10
a1421 13
 BL %FT20

 ADD R9, R3, R4, ASL #1

 BL %FT20

 ADD R3, R3, R4, ASL #1
 ORR R9, R3, R9, ASL #8

 BL %FT20

 ADD R3, R3, R4, ASL #1
 ORR R9, R3, R9, ASL #8
d1427 3
a1429 9
 CMP R8, #-1                    ; If R8 = -1 Then do the second parameter
 MOVEQ R8, R9                   ;
 BEQ %BT03                      ;

;*************

; ADD R8, R8, #2:SHL:8           ; The first 2 seconds of a disc are not
; ADD R9, R9, #2:SHL:8           ; accessible

d1435 15
a1449 12
 TEQ R1, #3
 MOVEQ R0, R2
 BLEQ atoi
 BVS ErrorExit
 MOVEQ R0, R2
 LDRNEB R0, CurrentDriveNumber

 BL PreConvertDriveNumberToDeviceID

 MOVVC R0, #1
 MOVVC R1, R8
 MOVVC R2, R9
d1451 1
a1451 7
 SWIVC XCD_PlayAudio

 BVS ErrorExit

;******************

 B %FT02
d1458 8
a1465 9

 LDRB R4, [ R2 ], #1            ;
 LDRB R3, [ R2 ], #2            ; Move past ':'
 SUB R4, R4, #"0"               ; R4 = M
 SUB R3, R3, #"0"               ; R3 = M

 ADD R4, R4, R4, ASL #2      ; R9 = First digit * 10

 MOV PC, R14
d1472 4
a1475 8

 LDRB R3, [ R2 ], #1
 CMP R3, #"0"
 RSBHSS R4, R3, #"9"+1
 MOVHI PC, R14              ; ALLOW TO RUN ON



d1481 9
a1489 9
             ADR       r0, message_block
             addr      r1, playmsf_tag
             ADR       r2, TempArea
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             BVS       ErrorExit
             MOV       r0, r2
             SWI       XOS_PrettyPrint
             SWI       XOS_NewLine
d1491 2
a1492 2
 VCLEAR
 GRABALLANDRETURN
a1504 1

d1507 1
a1507 17
 STASHALL


 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************

 BLEQ atoi
 BVS ErrorExit
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block

 SWIVC XCD_StopDisc
d1509 1
a1509 1
; BVS ErrorExit
d1511 14
a1524 4
; GRABALL

; BICS PC, R14, #Overflow_Flag
 B common_end
d1531 19
a1549 19

 STASH  "R14"

 ADR    r0, message_block
 ADR    r1, drivessupported
 ADR    r2, tempbuffer
 MOV    r3, #256
 SWI    XMessageTrans_Lookup
 GRAB   "PC", VS
 MOV    r0, r2
 SWI    XOS_PrettyPrint         ; SMC: Why??
 SWI    XOS_NewLine

 VCLEAR
 GRAB   "PC"

drivessupported = "dr",0

 ALIGN
d1563 18
a1580 18
 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************

 BLEQ atoi
 BVS ErrorExit
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block

 MOVVC R0, #0

 SWIVC XCD_EjectButton
d1584 2
a1585 6
 BVS ErrorExit

 GRABALLANDRETURN



d1597 29
a1625 34
 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************

 BLEQ atoi
 BVS ErrorExit
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

; MOV R2, #0

 BL PreGetUniqueNumber ;R0 = drive number, RETURNS R1, R2 -> disc name, or 0

 MOV R0, R1                ; R0 = value to be converted
                           ; R1 -> place to put string

 ADD R1, R12, #:INDEX:TempArea

 MOV R2, #255

 SWI XOS_ConvertCardinal4

 TEQ R0, R1

 SWINE XOS_Write0

 SWI XOS_NewLine

 VCLEAR
 GRABALLANDRETURN
d1637 1
a1637 1
 STASHALL
d1643 3
a1645 3
 TEQ R1, #0                          ;
 LDREQB R0, CurrentDriveNumber       ; [ no - so dismount current drive ]
 BEQ %FT04                           ;
d1651 1
a1651 3
; Debug " Check : "

 STASH R0
d1653 3
a1655 3
 LDRB R1, [ R0 ]
 TEQ R1, #":"
 ADDEQ R0, R0, #1
d1661 3
a1663 3
 BL CheckDiscName              ; R0 -> string

 GRAB R0
d1669 10
a1678 13
; Make sure that the name or number is prefixed with ":"

 MOV R1, #":"
 ADD R2, R12, #:INDEX:TempArea
 MOV R3, R2

 STRB R1, [ R2 ], #1

 LDRB R1, [ R0 ], #1
 TEQ R1, #":"
 STRNEB R1, [ R2 ], #1


d1680 4
a1683 6

 LDRB R1, [ R0 ], #1
 STRB R1, [ R2 ], #1
 TEQ R1, #0

 BNE %BT03
d1689 5
a1693 6
 ADD R0, R3, #1
 BL FindDiscNameInList
 CMP R1, #-1
 SUBEQ R0,R0,#1
; MOV R0, R3
 BLEQ FindDriveNumber             ; R0 -> name or number, RETURNS R1 = drive
d1699 1
a1699 1
 MOV R0, R1
d1702 32
a1733 32
 BL PreConvertDriveNumberToDeviceID

 SUBVC sp, sp, #8
 MOVVC r0, #0                     ; LBA addressing mode
 MOVVC r1, sp
 SWIVC XCD_DiscUsed
 BVS ErrorExit

 GRAB "r1,r2"

 MOV r14, r1, LSL #16
 MOV r1, r1, LSR #16              ; r1 = mshw of block count
 MOV r0, r14, LSR #16             ; r0 = lshw of block count

 MUL r14, r1, r2
 MUL r3, r2, r0
 MOV r4, r14, LSR #16
 ADDS r3, r3, r14, LSL #16        ; r3 = lsw of usage
 ADCS r4, r4, #0                  ; r4 = msw of usage
 BNE %FT64                        ; big disc?

; 32-bit size case
 MOV r0, r3
 ADR r1, TempArea
 MOV r2, #9
 SWI XOS_ConvertHex8              ; build bytecount as hex

 MOVS r0, r3, LSR #20
 ADC r0, r0, #0
 ADR r1, TempArea+32
 MOV r2, #11
 SWI XOS_ConvertInteger4          ; build round-to-nearest megabytes as integer
d1735 1
a1735 1
 B %FT70
d1738 13
a1750 13
 ; 64-bit size case
 MOV r0, r4
 ADR r1, TempArea
 MOV r2, #17
 SWI XOS_ConvertHex8
 MOV r0, r3
 SWI XOS_ConvertHex8              ; build bytecount as hex

 MOVS r0, r3, LSR #20
 ADC r0, r0, r4, LSL #12
 ADR r1, TempArea+32
 MOV r2, #11
 SWI XOS_ConvertInteger4          ; build round-to-nearest megabytes as integer
d1753 10
d1764 1
a1764 12
 ADR r0, message_block
 ADRL r1, free_tag
 ADR r2, TempArea+64
 MOV r3, #128
 ADR r4, TempArea
 ADR r5, TempArea+32
 SWI XMessageTrans_Lookup
 MOVVC r0, r2
 SWIVC XOS_Write0
 SWIVC XOS_NewLine

 B common_end
d1771 1
d1773 1
a1773 4
 LTORG

 END

@


4.8
log
@  Grubbing around with * commands.
Detail:
  * Added *Free.
  * Gave *Mount and *Dismount some help, based on the PRMs.
Admin:
  Tested on Tungsten.

Version 2.46. Tagged as 'CDFS-2_46'
@
text
@d457 1
a457 1
 BGT SetNumberOfBuffers           ;  *CONFIGURE number
d460 1
a460 1
 ADRLT R0, ConfigureMessageForBuffers;
d462 1
a462 1
 BLT configuredrivesdoesthis
d564 1
a564 1
 BGT SetNumberOfDrives            ;  *CONFIGURE number
d567 1
a567 1
 ADRLT R0, ConfigureMessage       ;
d571 1
a571 1
 SWILT XOS_PrettyPrint            ;
d573 1
a573 1
 SWILT XOS_NewLine                ;
d575 1
a575 1
 GRABALLANDRETURN LT              ; we can reasonably assume that V is clear
@


4.7
log
@  Some more bugfixes.
Detail:
  * Return registers for FSEntry_Func 14, 15 and 19 were getting corrupted
    due to stack manipulations, resulting in aborts inside FileSwitch
    whe enumerating some directories
  * Fixed an assumption of flag preservation across the PromptForDisc
    routine (the one that does UpCalls) that led initially to aborts (fixed
    by some top-bit-set safety measures), then later to bogus "CD-ROM drive
    not known" errors when accessig an object on a CD not currently in a
    drive
Admin:
  Tested on Tungsten.

Version 2.44. Tagged as 'CDFS-2_44'
@
text
@d1815 148
@


4.6
log
@  Minor bugfixes.
Detail:
  * Fixed a flags-preserving problem with the atoi function called by lots
    of * command handlers
  * Fixed trashing of error messages returned from OS_ReadUnsigned
  * Removed erroneous * from syntax messages for Lock and Unlock
  * Standardised spelling of CD-ROM in messages files (not CDROM or CD ROM)
Admin:
  Tested on Tungsten.

Version 2.43. Tagged as 'CDFS-2_43'
@
text
@d305 1
a305 1
 BGE and_why_not         ; [ yes ]
@


4.5
log
@  A few fixes.
Detail:
  * Fixed a couple of top-bit-set pointer problems
  * Fixed a couple of places where it was assumed that SWIs preserved flags
  * Uses kernel internationalisation for command help, so full tokenisation
    now works properly
  * Added NdrDebug support
Admin:
  Tested on Tungsten.

Version 2.41. Tagged as 'CDFS-2_41'
@
text
@d369 1
a369 1
 MOVGT       r3, r0
d1186 1
a1187 1
 MRSEQ R1, CPSR
d1195 1
a1195 1
 MOV R0, R1
@


4.4
log
@  Lots of changes for RISC OS 5.
Detail:
  * Updated to use objasm, shared makefiles and global headers
  * Ripped out lots of RISC OS 2 support code so we can see the wood for the
    trees now
  * 32-bit compatible (a bit of a slog)
  * Now has its own resources phase, replacing the use of the CDFSResources
    module. Also means that messages can now be tokenised properly. For
    good measure, split out CmdHelp tokens into separate file
  * Hopefully fixed more bugs along the way than I introduced. I've seen
    lots of nasty stack imbalances in error cases, but not fixed all of
    them, I'm afraid
Admin:
  Tested briefly on a Risc PC; not enough support modules to run on Tungsten
  yet.

Version 2.38. Tagged as 'CDFS-2_38'
@
text
@d256 1
d275 1
d657 1
a657 1
 Debug " *Dismount "
d672 1
a672 1
 Debug " Check : "
d739 7
a745 7
 [ debug=ON
 SWI &100+4
 SWI &100+12
 Debug " Wipe name, drive = "
 MOV    R4, R0
 DebugDisplay R4
 ]
d1200 3
a1202 3
 MSREQ CPSR_f, R1
 GRAB "PC", EQ
 GRABS "PC"
d1705 1
a1705 1
; This is the *Supported command - lists drives recognized by CDFS
@


4.3
log
@Manual merge of the RISC OS 4.02 version of CDFS (2.37, based upon Acorn's
RiscOS/UnU/OS_Core/FileSys/CDFS/CDFS234 version 2.35).

Tagged as 'CDFS-2_37'
@
text
@a47 72
 [ RISC_OS = 2
;*************************************************************************
Back                   ; *back
;*************************************************************************

 STASHALL

 ; 1. find start of CSD

 LDR R2, =:INDEX:CSD_path
 ADD R2, R2, R12


 ; 2. find start of old CSD

 LDR R3, =:INDEX:BackPath
 ADD R3, R3, R12


 ; 3. find end of old CSD

 LDR R4, =( MAXLENGTHOFNAME + 1 ) * MAXNUMBEROFPATHS + 2
 ADD R4, R3, R4


load_from_CSD

 ; 4. load from CSD

 LDRB R5, [ R2 ]


 ; 5. load from old CSD

 LDRB R6, [ R3 ]


 ; 6. store CSD at old CSD

 STRB R5, [ R3 ], #1


 ; 7. store old CSD at CSD

 STRB R6, [ R2 ], #1


 ; 8. reached end yet ? No - then goto 4

 CMP R3, R4
 BLE load_from_CSD

; 9. Swap drives


 LDRB R0, CurrentDriveNumber

 LDRB R1, olddrivenumber

 STRB R1, CurrentDriveNumber
 STRB R0, olddrivenumber

;----

 GRABALL

 BICS PC, R14, #Overflow_Flag

 ] ; RISC OS 2 only



d61 2
a62 3
 GRABALL

 BICS PC, R14, #Overflow_Flag
d86 2
a87 3

 GRABALL
 BICS PC, R14, #Overflow_Flag
a124 4
 [ RISC_OS=2
 addr R0, CDDevicesHeader
 SWI XOS_PrettyPrint
 |
d130 1
a130 1
             BVS       Error
a132 1
 ]
a316 3
 [ RISC_OS=2
 addr R0, NoDrivesFound, EQ
 |
a322 1
 ]
d330 2
a331 3
 GRABALL

 BICS PC, R14, #Overflow_Flag
d342 1
a342 1
 MOVS PC, R14
d366 1
d375 1
a375 1
 BVS         Error
d382 1
a382 1
 BVS         Error
a395 5
 [ RISC_OS=2
 SWI         XOS_WriteS
 = "Current speed setting is ",0
 ALIGN
 |
d402 1
a402 1
             BVS       Error
a405 1
 ]
d424 1
d493 2
a494 3
 GRABALL

 BICS PC, R14, #Overflow_Flag
d518 1
a518 1
 ORRVSS PC, R14, #Overflow_Flag ;
d530 1
a530 1
; BVS Error                   ; Indicate the unknown error to FS
d573 1
a573 2
 GRABALL LT                       ;
 BICLTS PC, R14, #Overflow_Flag   ;
d591 1
a591 1
 BVS Error
d603 2
a604 3
 GRABALL

 BICS PC, R14, #Overflow_Flag
d631 1
a631 1
 ORRVSS PC, R14, #Overflow_Flag ;
d640 1
a640 1
 STRVS R0, verytemporary        ; Indicate the unknown error to FS
d642 1
a642 4
 LDRVS R0, verytemporary        ;
 ORRVSS PC, R14, #Overflow_Flag ;

 GRABALL
d644 1
a644 1
 BICS PC, R14, #Overflow_Flag
a730 15
; R0 = drive number
; IF R0 = current drive number THEN CSD path = '$', 0
;******************

 [ RISC_OS=2

 LDRB R2, CurrentDriveNumber
 TEQ R0, R2
 LDREQ R4, =:INDEX:CSD_path
 MOVEQ R2, #"$"
 STREQ R2, [ R4, R12 ]

 ]

;******************
d777 1
a777 1
 BVS Error
d840 1
a840 1
 BICEQS PC, R14, #Overflow_Flag      ; [ yes ]
a884 4
 [ RISC_OS=2
 ADRVSL R0, BadDrive
 BVS Error
 |
d886 1
a886 2
           BVS         Error
 ]
d938 1
d946 1
a946 1
; BVS Error
d974 1
d984 1
a984 1
; BVS Error
a1065 92
 [ RISC_OS=2
;*************************************************************************
NoDir ROUT      ; Unset the CSD directory
;*************************************************************************

; R0 -> parameters follwing '*nodir'
; R1 = number of parameters


 LDR R1, =:INDEX:CSD_path
 MOV R0, #"$"
 STR R0, [ R1, R12 ]


 BICS PC, R14, #Overflow_Flag

 ]




 [ RISC_OS=2

;*************************************************************************
NoLib       ; Unsets the current library directory
;*************************************************************************

; R0 -> parameters follwing '*nodir'
; R1 = number of parameters

; STASHALL


;****************
; Blank the first byte of the path for the current library directory to
; indicate that it is unset
;****************

 LDRB R2, CurrentDriveNumber   ; R3 -> lib and urd buffer + drive * length
 LDR R3, pointertolibandurd    ;
 MOV R4, #LIBLENGTH            ;
 MLA R3, R2, R4, R3            ;

 MOV R2, #0                    ; Unset library
 STRB R2, [ R3 ]               ;

; GRABALL

 BICS PC, R14, #Overflow_Flag

 ]



 [ RISC_OS=2
;*************************************************************************
NoUrd       ; Unset the URD directory
;*************************************************************************

; R0 -> parameters follwing '*nodir'
; R1 = number of parameters

; STASHALL

;****************
; Blank the first byte of the path for the current library directory to
; indicate that it is unset
;****************

 LDRB R2, numberofdrives       ; R3 -> start of urd buffer
 LDR R3, pointertolibandurd    ;
 MOV R4, #LIBLENGTH            ;
 MLA R3, R2, R4, R3            ;

 [ URDLENGTH <> LIBLENGTH
 MOV R4, #URDLENGTH            ;
 ]
 LDRB R2, CurrentDriveNumber   ; R3 -> correct urd buffer
 MLA R3, R2, R4, R3            ;

 MOV R2, #0                    ; Unset library
 STRB R2, [ R3 ]               ;


; GRABALL

 BICS PC, R14, #Overflow_Flag

 ]



d1088 2
a1089 1
         ; RETURNS r2=value, does not return if error (not integer)
d1102 2
d1117 1
a1117 1
 BVS Error
a1126 4
 [ RISC_OS=2
 addr R0, TrackTooBig, GT
 BGT Error
 |
d1128 1
a1128 2
         BGT       Error
 ]
a1131 4
 [ RISC_OS=2
 addr R0, TrackTooSmall, LT
 BLT Error
 |
d1133 1
a1133 2
         BLT       Error
 ]
d1149 1
a1149 1
; BVS Error
d1167 2
a1168 1
;          V cleared, if error then won't return
d1174 1
a1174 1
; BVS Error
d1184 3
a1191 1
 BVS Error
d1195 7
a1201 1
 GRAB PC
d1233 1
d1247 1
a1247 1
 BVS Error
a1254 5
 [ RISC_OS=2
 SWI XOS_WriteS
 = "Track number, contains, starts from MM:SS:FF", 0
 ALIGN
 |
d1260 1
a1260 1
             BVS       Error
a1262 1
 ]
d1271 1
a1271 1
 BVS Error
a1276 5
 [ RISC_OS=2
 ADR R3, Track
 LDMIA R3, { R3, R4 }           ; "Track", HARDSPACE
 STMIA R9!, { R3, R4 }          ;
 |
d1282 1
a1282 1
             BVS       Error
a1283 1
 ]
a1305 7
 [ RISC_OS=2
 ADREQ R3, audio
 ADRNE R3, data
 LDMIA R3, { R3, R4 }
 LDR R1, is                   ; " is "
 STMIA R9!, { R1, R3, R4 }
 |
d1312 1
a1312 1
             BVS       Error
a1313 1
 ]
a1403 5
 [ RISC_OS=2
 SWI XOS_WriteS
 = "Total   ", 0
 ALIGN
 |
a1411 1
 ]
a1424 5
 [ RISC_OS=2
 SWI XOS_WriteS
 = " track(s)     ", 0
 ALIGN
 |
a1432 1
 ]
d1438 1
a1438 1
 BVS Error
d1493 2
a1494 10
 GRABALL

 BICS PC, R14, #Overflow_Flag

 [ RISC_OS=2
Track = "Track", HARDSPACE, HARDSPACE, HARDSPACE
is = HARDSPACE,"is",HARDSPACE
audio = "audio",HARDSPACE, HARDSPACE, HARDSPACE
data = "data",HARDSPACE, HARDSPACE, HARDSPACE, HARDSPACE
 ]
d1599 1
d1611 1
a1611 1
 BVS Error
a1649 5
 [ RISC_OS=2
 addr R0, PlayMSFSyntax
 SWI XOS_Write0
 SWI XOS_NewLine
 |
d1655 1
a1655 1
             BVS       Error
a1658 1
 ]
d1660 2
a1661 2
 GRABALL
 BICS PC, R14, #Overflow_Flag
d1687 1
d1695 1
a1695 1
; BVS Error
d1708 1
a1708 1
 STASH  R14
a1709 3
 [ RISC_OS =2
 ADR    R0, drivessupported
 |
d1715 1
a1715 1
 GRAB   PC,VS
a1716 1
 ]
d1720 2
a1721 2
 GRAB   R14
 BICS   PC, R14, #Overflow_Flag
a1722 3
 [ RISC_OS = 2
drivessupported = "SONY, LMS, TOSHIBA, HITACHI, CHINON", 0
 |
a1723 1
 ]
d1748 1
d1760 1
a1760 103
 BVS Error

 GRABALL

 BICS PC, R14, #Overflow_Flag




 [ RISC_OS=2
;*************************************************************************
Urd ROUT        ; Sets the URD directory
;*************************************************************************

 STASHALL

; entry:
;       R0 -> pointer to wildcarded directory name
;       R1 = number of parameters on line

; exit:
;       ------- nothing


; R6 -> Full pathname

; First move to the correct directory, also expand name to whole path
; eg '%.fred' = '$.image03.fred'

; Then save this whole path as the current directory name IF VALID

 TEQ R1, #0                  ; If no parameter following *URD THEN *URD $
; ADREQL R0, BlankPath        ;
 addr R0, BlankPath, EQ

 BL ValidatePathName         ; R0 -> pathname ( see 'Open' )

;*******************

; R0 -> pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number

 MOV R1, #1        ; Looking for a directory
 BL Dir

;*******************

 TEQ R2, #DIRECTORY          ; If it is a file, or not found then error

 [ RISC_OS=2
 BNE notfound
 |
         MOVNE      r0, #ERROR_NOTFOUND
         BNE        Error
 ]


 ; keep the full pathname, eg :FreddyDisc.$.pathname


;****************
; R1 -> urd path for drive [ R4 ]
;****************

 STASH R0

 LDRB R2, numberofdrives       ; R3 -> start of urd buffer
 LDR R1, pointertolibandurd    ;
 MOV R14, #LIBLENGTH           ;
 MLA R1, R2, R14, R1           ;

 [ URDLENGTH <> LIBLENGTH        ; R3 -> correct urd buffer
 MOV R14, #URDLENGTH           ;
 ]
 MLA R1, R4, R14, R1            ;

;****************

 MOV R0, #":"             ;
 STRB R0, [ R1 ], #1      ;
 MOV R0, R4               ; Keep the name of the URD disc
 MOV R2, R3
 BL GetDiscName           ; R0 = drive, R1 -> place to put name, R2 -> buffer
 MOV R0, R1               ;
 BL CutSpace              ;


 LengthOfString R1, R2, R3
 ADD R1, R1, R2
 MOV R0, #"."
 STRB R0, [ R1, #-1 ]

 GRAB R0

;****************
;2. copy from 'Fullpathname' to 'URDPath'
;****************

; R0 -> FullPathName
; R1 -> URDPath
; R4 = byte
d1762 1
a1762 15


01

 LDRB R4, [ R0 ], #1
 STRB R4, [ R1 ], #1
 TEQ R4, #0

 BNE %BT01


 GRABALL
 BICS PC, R14, #Overflow_Flag

 ]
d1786 1
d1809 2
a1810 3
 GRABALL

 BICS PC, R14, #Overflow_Flag
@


4.2
log
@  Ursula branch merge, plus srccommit usage.
Detail:
  Merged Ursula branch, it just removed dynamic dependencies from
   Makefile.

  Moved to srccommit, changed lots of occurrences of "Version" to module
   version, as defined in "VersionASM".  Removed old "Version" file.
Admin:
  Added stripdepend call into clean rule.


Version 2.30. Tagged as 'CDFS-2_30'
@
text
@d1120 10
a1129 1
 ADREQ R0, BlankPath     ; R0 -> '$'
@


4.1
log
@Initial revision
@
text
@d231 1
a231 1
;**************  
d274 1
a274 1
 [ Version >= 218
d522 1
a522 1
 
d972 1
a972 1
 [ Version < 220
d1016 1
a1016 1
 [ Version >= 220
d1105 1
a1105 1
 [ Version >= 220
d1121 1
a1121 1
 [ Version >= 220
d1157 1
a1157 1
 [ Version >= 220
d1181 1
a1181 1
 
d1186 1
a1186 1
   
d1201 1
a1201 1
 
d1203 1
a1203 1
; Blank the first byte of the path for the current library directory to 
d1234 1
a1234 1
; Blank the first byte of the path for the current library directory to 
d1446 1
a1446 1
             
d1875 1
a1875 1
 
d2147 1
a2147 1
 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

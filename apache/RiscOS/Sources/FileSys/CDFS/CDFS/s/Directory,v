head	4.15;
access;
symbols
	CDFS-2_63:4.15
	CDFS-2_62:4.15
	CDFS-2_61:4.15
	CDFS-2_60:4.14
	CDFS-2_59:4.13
	CDFS-2_58:4.12
	CDFS-2_57:4.12
	CDFS-2_56:4.12
	CDFS-2_55:4.11
	CDFS-2_54:4.11
	CDFS-2_53:4.9
	CDFS-2_52:4.7
	CDFS-2_51:4.7
	CDFS-2_50:4.7
	CDFS-2_49:4.7
	CDFS-2_48:4.7
	RO_5_07:4.6
	CDFS-2_47:4.6
	CDFS-2_46:4.6
	CDFS-2_45:4.6
	CDFS-2_44:4.6
	CDFS-2_43:4.6
	CDFS-2_42:4.6
	CDFS-2_41:4.6
	CDFS-2_40:4.6
	CDFS-2_39:4.6
	CDFS-2_38:4.5
	CDFS-2_37:4.4
	CDFS-2_35:4.3
	CDFS-2_30:4.2
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	nturton_CDFS-2_29:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_CDFS_2_28:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2013.08.15.14.25.02;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	5ab0m7C1cVfMFy1x;

4.14
date	2013.08.15.14.13.05;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	6zDw3cu1Q3LIBy1x;

4.13
date	2013.07.15.20.37.00;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	ArzVzGqij5ueJBXw;

4.12
date	2012.04.22.15.48.26;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	bybtPibvH0K2zS1w;

4.11
date	2012.04.22.11.09.01;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	MNiwWuPGZIIb1R1w;

4.10
date	2012.04.22.11.04.30;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	6PVuneYjhUEDZQ1w;

4.9
date	2012.04.21.21.56.36;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	LsBEkd8YV89lDM1w;

4.8
date	2012.04.16.21.42.00;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	E6l0nP00WOBxH81w;

4.7
date	2005.04.22.21.47.47;	author jballance;	state Exp;
branches;
next	4.6;

4.6
date	2002.11.07.18.25.45;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.04.21.21.42;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.01.20.15.29;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.01.19.47.48;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2000.11.30.11.44.22;	author jberanek;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.50;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.50;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.51.13;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.31.42;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.28.01;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.15
log
@Add support for Joliet format CD-ROMs
hdr/Hashes
s/Directory
s/EntryFile
s/FileMan
s/Filer
s/Free
 - mass search and replace of lots of poorly named definitions, removing unused ones, creating implicit ones
hdr/MyMacros
 - shuffle some registers in ConvertToArchyDate to save one temporary so it can be used for something else
 - moved ReplaceBadCharacters here
hdr/Options
 - extra debug option
s/DiscOp
 - add Joliet, rename buffer indicies per hdr/Hashes
 - the fallback filetype assignment (when neither the ARCHIMEDES system extension nor MimeMap can help) can now be overridden by setting CDFS$DefaultType (which defaults to &FFD)
s/SWI
 - remove DAT<->MPEG mapping from the internal mapping table
s/Variables
 - trim out unused SWI_buffer reservation

Tested with valid ISO/Joliet/RockRidge supported combinations, documented in Docs/Combos, and accompanying test ISO images now stored there.
Tested with CD-I format disc 'Jigsaw' from Britannica.
Tested with High Sierra format disc 'Kings Quest V'.
Tested with photo CD sampler from Kodak.

Version 2.61. Tagged as 'CDFS-2_61'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >Directory

;**************************************************************************
;**************************************************************************

;   This will move to the correct LBA, indicated by a pathname, pointed
; at by R0.


; contains:
;               AddDiscNameInList      - puts disc into drive list
;               ConvertDotToUnderLine
;               CutSpace               - removes messy spaces from a string
;               Dir
;               FindDiscNameInList     - Looks through drive mounted list
;               FullPathName
;               LoadBlockFromDrive

;**************************************************************************
Dir
; on entry:
;          R0->pathname
;          R1=0 if looking for a file, 1 if looking for a directory
;             2 if don't care (ie opening a file)

; on exit:
;          R1 -> block of object info, 0 if not found,
;          R2 = 1 if a file, 2 if a directory )
;          R3 -> start of disc buffer
;          R4 = drive number
;          V clear, other flags corrupted
;          all other regs preserved
;**************************************************************************

; object type = FILE / NOTFOUND / DIRECTORY

; R6 = PointerToEntry
; R8 = Drive number (0..7), name is a dir(8), ultimate object(9..10)
;      end of path reached (11) if clear
; R9 = Word
; R10 = PointerToPath
; R11 = PointerToDiscBuffer ( each individual buffer, starts as main one )
; R12 -> workspace
; R13 -> FD stack

; Variables used:
; tempLength                    = length in blocks of directory
; tempBlockSize
; discnumberofdirinbuffer

        Push    "R5 - R11, R14"


;****************
; R10 -> pathname passed in ( changed later )
;****************

        MOV     R8, R1, ASL #9
        MOV     R10, R0

;****************
; This will return the drive number for a given disc ( prompts for disc name
;                                                     etc; )
;****************


        BL      FindDriveNumber         ; R0 -> pathname, RETURNS R1 = drive number

;****************
; R8 = drive number implied ( constant )
;****************

        ORR     R8, R8, R1

;****************
; If drive has not yet been used, then find its device & LUN number
;****************

        AND     R0, R8, #255

;****************
; This also validates the path
;****************

        MOV     R2, R1
        MOV     R0, R10
        AND     R1, R8, #255

        BL      FullPathName            ; RETURNS R0 -> whole name, R1 = drive number
                                        ; R2 = disc number



;****************
; R10 now points at the new pathname ( stripped of leading drive number )
;****************

        MOV     R10, R0

;****************
; This gets a pointer to the disc main directory ( and header info )
;****************

        AND     R0, R8, #255
                
        BL      TestKnowDisc            ; R0 = drive number, RETURNS R1 -> buffer
                                        ; RETURNS R2 = disc number

;****************
; R11 -> start of directory ( past header information in root directory )
;****************

        STR     R2, discnumberofdirinbuffer
                
        ; Make sure that blocky offset starts from zero
                
        MOV     R14, #0
        STR     R14, tempInk


;****************
; Remember where main directory information is
;****************

        STR     R1, maindirpointer
        ADD     R1, R1, #DiscBuff_MainDirBuffer

;****************
; tempbufferpointer -> start of this directory buffer
;****************

        STR     R1, tempbufferpointer
        LDR     R4, [ R1, #DiscBuff_SizeOfMainDir - DiscBuff_MainDirBuffer ]
        STR     R4, tempLength

;****************
; Remember block size
;****************
    
        LDR     R4, [ R1, #DiscBuff_BlockSize - DiscBuff_MainDirBuffer ]
        STR     R4, tempBlockSize

;****************
; Remember disc type
;****************

        LDRB    R3, [ R1, #DiscBuff_DiscType - DiscBuff_MainDirBuffer ]
        STRB    R3, tempDisctype

;****************
; Remember block start
;****************

        LDR     R9, [ R1, #DiscBuff_LBAOfMainDir - DiscBuff_MainDirBuffer ]
        STR     R9, tempBlock

;****************
; Start with branch/leaf 1
;****************

        MOV     R9, #0                  ; Word = 1

;*******************************************
try_again
;*******************************************

        ; R11 -> directory details ( past header info, so have to back track )
        MOV     R11, R1

;****************
; Move to next branch/leaf in path
;****************

        ADD     R9, R9, #1

;****************
; Put next leaf/branch in 'tempbuffer'
;****************

        MOV     R0, R10
        ADR     R1, tempbuffer
       
        ; R0 -> pathname$,R1 -> word$, R9 = word number
        ; R0 & R2 - R5 corrupted
        
        MOV     R5, #0
        MOV     R4, R1

;*****************
; First move to correct '.'
;*****************

01

        LDRB    R3, [ R0 ], #1          
                                        
        TEQ     R3, #0                  ; Reached end of path, but didn't find word ?
        BEQ     directory               
                                        
        TEQ     R3, #ARCHYDIVIDER            
        ADDEQ   R5, R5, #1              ; Increase word count if found '.'
                                        
        CMP     R5, R9                  
                                        
        BLT     %BT01                   

;**************
; Found start position, now copy word to caller
;**************

02

        LDRB    R3, [ R0 ], #1
        STRB    R3, [ R4 ], #1
        TEQ     R3, #ARCHYDIVIDER
        TEQNE   R3, #0
                
        BNE     %BT02

        ; --- End of path ? BUT DID I WANT A DIRECTORY OR A FILE ? ---

        TEQ     R3, #0
        ORRNE   R8, R8, #1:SHL:11
        BICEQ   R8, R8, #1:SHL:11

        TST     R8, #512                
        ORRNE   R8, R8, #256            ; Directory
        BICEQ   R8, R8, #256            ; File

        ; --- If divider following, then must be a directory wanted ---

        TEQ     R3, #ARCHYDIVIDER            
        ORREQ   R8, R8, #256            ; Directory
        BICNE   R8, R8, #256            ; File

        ; --- Get rid of last dot ---

        MOV     R3, #0
        STRB    R3, [ R4, #-1 ]

;****************
; Look through directory for the branch/leaf name [ Vset if not found ]
;****************

        MOV     R0, R11

        ; R0 -> memory, R1 -> name$, RETURN R2 = position  Vset if not found

        MOV     R5, R0
        MOV     R0, R1

01

        ADD     R1, R5, #OBJECTNAMEOFFSET ; R0 -> wildcarded string
                                          ; R1 -> prepared string in buffer

        ; --- Do I care what I'm looking for ? ---

        CLRV

        TST     R8, #1024               
        BNE     %FT11                   ; [ no ]

        ; --- If haven't reached end of path, then must look for a directory ---

        TST     R8, #256                ; If it's a directory that you want
                                        ; but you don't find one, ignore it
        LDRB    R14, [ R5, #OBJECTTYPEOFFSET ]
        TEQNE   R14, #object_directory
        SETV    NE

11

;-------------------------------------------------------------------
; RISC OS 3 finds it's wildcarded filenames differently
;-------------------------------------------------------------------
        Push    "r0-r3"
15
        LDRB    r2, [ r0 ], #1
        LDRB    r3, [ r1 ], #1
        CMP     r3,#'a'
        RSBGES  r14,r3,#'z'
        SUBGE   r3,r3,#&20
        CMP     r2,#'a'
        RSBGES  r14,r2,#'z'
        SUBGE   r2,r2,#&20
        TEQ     r2, r3

        ; not found
        Pull    "r0-r3", NE
        BNE     %FT16

        CMP     r2, #32
        BGE     %BT15

        ; found
        Pull    "r0-r3"
        MOV     r2, r5
        B       %FT02
16

        ADD     R5, R5, #OBJECTNAMEOFFSET + 1

04
        LDRB    R4, [ R5 ], #1
        TEQ     R4, #0
        BNE     %BT04

        ALIGNREG R5

        LDR     R4, [ R5, #LBASTARTOFFSET ]
        MOVS    R4, R4, LSR #8
                
        BNE     %BT01

        ; Move to next block, if there is one

        LDR     R14, tempLength
                
        LDR     R0, tempBlockSize
        SUBS    R14, R14, R0
                
        MOVLE   R1, #0                  ; NOT FOUND
        MOVLE   R2, #object_nothing     ;
        Pull    "R5 - R11, PC", LE      ;
                
        STR     R14, tempLength
                
        LDR     R14, tempInk
        ADD     R14, R14, #MAX_BLOCKS_BUFFERED
        STR     R14, tempInk
        LDR     R0, tempBlock           ; need to keep this as start block
        ADD     R0, R14, R0             ; 'cause use in other procedures (sorry)
                
        SUB     R9, R9, #1              ; 'cause I haven't found anything
                
        B       more_blocky

02      ; Found

;****************
; R6 -> entry details
;****************

        ; blocky offset back to zero

        MOV     R6, #0
        STR     R6, tempInk
                
        MOV     R6, R2

;****************
; Copy entry details into 'TempArea' ( so that 'ReadCatalogue' can use it )
;****************

        MOV     R1, R6                                      ; Copy from
        ADR     R2, TempArea                                ; Copy to
        MOV     R3, #OBJECTNAMEOFFSET + MAXLENGTHOFNAME + 1 ; Copy length
        CD_ByteCopy

;****************
; The object was a file ? [ yes - then end search ]
;****************

        LDRB    R4, [ R6, #OBJECTTYPEOFFSET ]
        TEQ     R4, #object_file        ; If it is A FILE then the end has been reached
        BNE     %FT23

        TST     R8, #1:SHL:11           ; end of path ?
        MOVNE   R1, #0                  ; [ no - so NOT FOUND ]
        MOVNE   R2, #object_nothing     ;
                                        
        MOVEQ   R0, R10                 ; [ yes - so return file details ]
        MOVEQ   R1, R6                  ;
        MOVEQ   R2, #object_file        ;
        LDREQ   R3, maindirpointer      ;
        ANDEQ   R4, R8, #255            ;

        CLRV
        Pull    "R5 - R11, PC"

23

;****************
; Work out real length of dir/file from block size and length
;****************

        LDR     R5, [ R6, #LENGTHOFFSET ]
        STR     R5, tempLength

;*******
; R0 = LBA of start of next dir ( LBA is stored packed )
;*******

        LDR     R0, [ R6, #LBASTARTOFFSET ]
        MOV     R0, R0, LSR #8
        STR     R0, tempBlock

more_blocky


;*************
; This will store a directory in the buffer, if possible ( or not there )
;*************

; R0 = Start LBA
; R1 ~
; R2 ~
; R3 ~
; R4 ~
; R5 ~
; R6 ~

        Push    "R0, R2"
        MOV     R2, R0
        LDR     R0, discnumberofdirinbuffer
        BL      FindDiscInBufferList    ; R0 = disc, RETURNS R1 -> buf, R2 = LBA
                                        ; C set if not found, else C clear

;*************
; Make R1 -> directory if found, else R1 -> place to put dir
;*************

        ADRCSL  R1, sparedirectorybuffer + :INDEX:DiscBuff_MainDirBuffer
        STR     R1, tempbufferpointer
                
        Pull    "R0, R2"
        BCC     try_again

;*************
; This will store a directory in the buffer, if not cached
;*************


        ; R0 = start LBA, R1 -> place to put, R2 UNUSED
        ; R3 = disc type, R4 = blocksize, R5 = drive number, RETURNS R6 = size of mem
        
        Push    "R0 - R5"
        
        ADR     R3, tempBlockSize
        LDMIA   R3, { R4, R6 }
        
        LDRB    R3, tempDisctype
        
        AND     R5, R8, #255
        
        BL      StoreDirectory


;----------------------------------------------------------------------------
; Check for Revelation CD which claims to use 4 blocks but really only uses 2
;----------------------------------------------------------------------------

        ; If there was nothing in that directory block AND expected something then exit
        CMP     r6, # 4
        BNE     D_FullBlock
        
        LDR     r14, tempLength
        LDR     r2, tempBlockSize
        TEQ     r14, r2
        
        Pull    "r0 - r5", NE
        MOVNE   r1, #0                  ; NOT FOUND
        MOVNE   r2, #object_nothing     ;
        Pull    "r5 - r11, pc", NE      ;

D_FullBlock

        MOV     R2, R0
        MOV     R3, R1
        MOV     R1, R6
        LDR     R0, discnumberofdirinbuffer
        BL      AddDirectoryToBuffer    ; R0 = disc, R1 = size, R2 = block, R3->dire

        ; Refresh pointer to the main directory (the buffers may have moved)
        LDR     r0, discnumberofdirinbuffer
        MOV     r2, #PVD
        BL      FindDiscInBufferList
        MOVCS   r0, #ERROR_INTERNALERROR
        BCS     ErrorExit               ; It's gone! That's bad
                
        STR     r1, maindirpointer

        Pull    "R0-R5"

        B       try_again

        ; --- Reached end of path, but didn't find word ? ---

directory


        MOV     R0, R10                 ; R0 -> expanded pathname
        MOV     R1, R11                 ; R1 -> current buffer
        MOV     R2, #object_directory   ; R2 = directory attrib
        LDR     R3, maindirpointer      ; R3 -> main dir header
        AND     R4, R8, #255            ; R4 = drive number
        CLRV
        Pull    "R5 - R11, PC"

;********************************************************************
; Compare 2 strings
;entry:
; R0 -> first string
; R1 -> second string
; R2 = length
; exit:
; Z = 1 if found, else Z = 0
; All other flags preserved

CompareStrings ROUT
;********************************************************************
; If length = 0 THEN must be same !

        TEQ     R2, #0
        MOVEQ   PC, R14

        ; R2 -> end of R1

        Push    "R0 - R4"

        ADD     R2, R2, R1

01
        LDRB    R4, [ R0 ], #1
        LDRB    R3, [ R1 ], #1
        TEQ     R4, R3
                
        Pull    "R0 - R4", NE
        MOVNE   PC, R14

        CMP     R1, R2
        BLT     %BT01

        ; Z is now set
        Pull    "R0 - R4"
        MOV     PC, R14

;********************************************************************
; Strip leading and trailing spaces from a string ( R0 -> string )
CutSpace ROUT
;********************************************************************

        Push    "R0 - R4, R14"

        MOV     R3, R0                  ; Find the length of the string
01
        LDRB    R2, [ R3 ], #1          
        TEQ     R2, #0                  
        BNE     %BT01

        MOV     R1, R3                  ; R3 -> byte *after* null terminator
        SUB     R3, R3, #2              ; R3 -> last char of string

;***************
; First chop the trailing spaces
;***************

02
        LDRB    R4, [ R3 ], #-1
        TEQ     R4, #SPACE
        BNE     %FT05

        CMP     R3, R0                  ; If string is all spaces
        BCS     %BT02
        
        MOV     R4, #0
        STRB    R4, [ R3, #1 ]
        Pull    "R0 - R4, PC"
05
        MOV     R4, #0
        STRB    R4, [ R3, #2 ]!         ; R3 -> terminating null

;***************
; Now chop the leading spaces
;***************

        MOV     R1, R0
10
        LDRB    R4, [ R1 ], #1
        CMP     R1, R3
        Pull    "R0 - R4, PC", CS
                
        TEQ     R4, #SPACE
        BEQ     %BT10

        SUB     R1, R1, #1              ; R1 -> left trimmed start
        CMP     R1, R0
        Pull    "R0 - R4, PC", LS

;**************
; Shuffle string back if needed
;**************

15
        LDRB    R4, [ R1 ], #1
        STRB    R4, [ R0 ], #1
        CMP     R1, R3
        BLS     %BT15                   ; shuffle up to and including terminator
                
        Pull    "R0 - R4, PC"


;------------------------------------------------------------------------------------------
FullPathName ROUT;( RETURNS R0 -> pathname, R1 = drive number, R2 =disc number )

        Push    "r1-r4, r14"
        
        LDRB    r3, [ r0 ]
        TEQ     r3, #":"
        Pull    "r1-r4, pc", NE
        
        ADD     r0, r0, #1
        
02      
        LDRB    r3, [ r0 ], #1
        TEQ     r3, #"."
        BNE     %BT02
        
        Pull    "r1-r4, pc"


;********************************************************************

PreLoadBlockFromDrive ; This sets R1=buffer in preparation

        ADRL    R1, buffer
        ; Fall through

;********************************************************************
LoadBlockFromDrive ROUT ; R0 = block, R1 -> memory, R2 = length ( blocks )
                   ; R3 = drive number
;********************************************************************

        Push    "R0 - R7, R14"

        MOV     R4, R0
        MOV     R5, R1
        
        MOV     R0, R3
        BL      PreConvertDriveNumberToDeviceID   ; R0 = drive number, R7 -> memory

        MOVVC   R0, #LBAFormat
        MOVVC   R1, R4
        MOVVC   R3, R5
        MOVVC   R4, #myblocksize
        SWIVC   XCD_ReadData
        BVS     ErrorExit
                
        Pull    "R0 - R7, PC"

;********************************************************************
FindDriveNumber ROUT ;( R0 -> pathname, RETURNS R1 = drive )
;********************************************************************

        Push    "R0, R2 - R7, R14"

        MOV     R6, R0
01
        LDRB    R2, [ R6 ]
        STRB    R2, [ R6 ], #1
        TEQ     R2, #0
        BNE     %BT01
                
        MOV     R6, R0
                
        LDRB    R1, [ R6 ]
        TEQ     R1, #":"                ; drive specified in pathname
        BEQ     %FT02                   ; either by name, or number ?
                                        ; [ must mean current drive number ]

        TEQ     R1, #"\\"               ; Use the old drive number ! if previous
        LDREQB  R1, olddrivenumber      ; path is required
        LDRNEB  R1, CurrentDriveNumber  ;
        Pull    "R0, R2 - R7, PC"       ;

02
        ADD     R1, R0, #1              ; Copy into a safe area
        
        LDRB    R3, [ R1 ]              ; Nothing specified ? ( no name, no number )
        TEQ     R3, #0                  ;
        MOVEQ   r0, #ERROR_BADNAME
        BEQ     ErrorExit

        ADR     R3, TempArea
        MOV     R4, R3                     

04                              
        LDRB    R2, [ R1 ], #1          ; 
        STRB    R2, [ R3 ], #1          ; 
        TEQ     R2, #"."                ; 
        TEQNE   R2, #0                  ; 
        TEQNE   R2, #&0D                ; 
        TEQNE   R2, #SPACE              ; 
        BNE     %BT04                   ; 

        ; Make sure that 'drive.&', 'drive.%', 'drive.\', 'drive.@@'
        ; give a 'bad name' error

        TEQ     R2, #0
        BEQ     fine

        LDRB    R2, [ R1 ]
        TEQ     R2, #"&"
        TEQNE   R2, #"%"
        TEQNE   R2, #"\\"
        TEQNE   R2, #"@@"

        MOVEQ   r0, #ERROR_BADNAME
        BEQ     ErrorExit

fine

        MOV     R2, #0                  ; Null terminate entry
        STRB    R2, [ R3, #-1 ]         
        MOV     R1, R4                  

        Push    "R0"

        MOV     R0, #10
        SWI     XOS_ReadUnsigned

        Pull    "R0"                    ; must be a name
        BVS     SoItIsADiscName
                                        ; was a number

        CMP     R2, #MAXNUMBEROFDRIVESSUPPORTED
        MOVGT   r0, #ERROR_BADDRIVE
        BGT     ErrorExit

        MOV     R1, R2

        Pull    "R0, R2 - R7, PC"

;******************
SoItIsADiscName
;******************

        MOV     R0, R4
        BL      CheckDiscName           ; R0 -> disc name, RETURNS R1 TRUE/FALSE

        TEQ     R1, #FALSE
        MOVEQ   r0, #ERROR_BADNAME
        BEQ     ErrorExit

        BL      FindDiscNameInList      ; R0 -> disc name, RETURNS R1 = drive number

        CMP     R1, #-1                 ; Disc known ?
        LDREQB  R1, CurrentDriveNumber  ; [ no ]
        BL      PromptForDisc           ; R0 -> disc name to prompt for, R1 = drive

        Pull    "R0, R2 - R7, PC"       ; 'V' already cleared


;********************************************************************
PromptForDisc ROUT ; R0 -> name of disc, R1 = drive number
;********************************************************************

        Push    "R0 - R8, R14"
        
        ; First look at disc in drive to see if known
        
        MOV     R6, R0
        MOV     R8, R1
        MOV     R2, R0
                
        LDR     R14, discbuffersize
        TEQ     R14, #0
        BEQ     fiddle_buffer_for_prompt

;-----------------------------
; Is disc in drive already ?
;-----------------------------

        ; Is drive mounted ?
        ; Is disc in drive same ?
        ; Is disc_name in disc list ?        - no so not_in_memory

        BL      FindDiscNameInList      ; R0 -> disc name, RETURNS R1 = drive number
        CMP     R1, #-1                 ; Disc known ?
        BEQ     fiddle_buffer_for_prompt

        ; Is drive same as requested drive ? - no so not_in_memory
        TEQ     R8, R1
        BNE     fiddle_buffer_for_prompt

        ; Is disc in drive same as requested disc ?
        Push    "R2"

        MOV     R2, #1
        MOV     R0, R8
        BL      GetUniqueNumber
        TEQ     R1, #0
        Pull    "R2"
        BEQ     fiddle_buffer_for_prompt

        ADRL    R14, discsMounted
        LDR     R14, [ R14, R0, LSL #2 ]
        CMP     R14, R1
        ; Yes so exit without prompt
        Pull    "R0 - R8, PC", EQ

        B       fiddle_buffer_for_prompt

;-----------------------------

not_in_memory

        MOV     R0, R6

prompt_for_disc

        MOV     R1, #fsnumber_CDFS      ; R1 = CDFS
        MOV     R2, R0                  ; R2 -> disc name
        MOV     R3, R8                  ; R3 = drive number
        MOV     R0, #UpCall_MediaNotPresent
        MOV     R4, #0                  ; R4 = iteration count
        MOV     R5, #-1                 ; R5 = Timeout never
        ADR     R6, COMPACTDISC         ; R6 = media type name
        SWI     XOS_UpCall

        MOVVS   r0, #ERROR_DISCNOTFOUND
        BVS     ErrorExit


        TEQ     R0, #0                  ; Forget it ?
        MOVNE   r0, #ERROR_DISCNOTFOUND
        BNE     ErrorExit

fiddle_buffer_for_prompt

        MOV     R0, R8
        BL      PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> controlblock
        BVS     ErrorExit

;********
; Is drive ready ?
;********

        SWI     XCD_DriveStatus
        TEQ     R0, #1                  ; Drive not ready so try again
        SETV    NE                      ;
        LDMVSIA sp, {R0 - R8, R14}      ; Recover entry regs
        MOVVS   R8, R1                  ;
        BVS     prompt_for_disc         ;
                
        MOV     R0, #LBAFormat          ;
        MOV     R1, #PVD                ; R1 = some valid block number that always exists  
        SWI     XCD_EnquireDataMode     ; make sure that disc is in mode 1 or 2

        ; This just makes sure that it's not an audio disc
        TEQ     r0, #0
        SETV    EQ
        LDMVSIA sp, {r0 - r8, r14}      ; Recover entry regs
        MOVVS   r8, r1
        BVS     prompt_for_disc

        SWI     XCD_DiscHasChanged


        Push    "R2 - R3"
        MOV     R0, #PVD                ; Call to GetDiscNameNotInBuffer tries the SVD if needed
        MOV     R2, #1
        MOV     R3, R8
        BL      PreLoadBlockFromDrive   ; R0 = block, R1 -> memory, R2 = length ( blocks )
                                        ; R3 = drive number
        Pull    "R2 - R3"

        MOV     R0, R8                  
        BL      GetDiscNameNotInBuffer  ; R0 = drive, R1 -> name of disc in drive
        MOV     R0, R1                  
        BL      CutSpace                ; R0 -> disc name
                                        
        MOV     R1, R2                  ; R0 -> disc name to hope for

        LengthOfString R0, R2, R14
        LengthOfString R1, R3, R14

        TEQ     R2, R3
        BLEQ    CompareStrings          ; returns 'eq' or 'ne'

        LDMNEIA sp, {R0 - R8, R14}      ; Recover entry regs
        MOVNE   R8, R1
        BNE     prompt_for_disc

        ; Found the right disc, now tell UpCall about it
        MOV     R0, #UpCall_MediaSearchEnd
        SWI     XOS_UpCall
                
        Pull    "R0 - R8, PC"

COMPACTDISC
        DCB     "CD-ROM", 0             ; Keep together
        ALIGN

;********************************************************************
FindDiscNameInList ROUT    ; R0 -> disc name, RETURNS R1 = drive number
                           ;                          R1 = -1 if not found
;********************************************************************

; R2 -> disc name in list
; R5 = number of discs left to search
; R6 -> disc name to search for
; R8 = -1 if no names found so far, else = drive found at

        Push    "R0, R2 - R8, R14"
                
        MOV     R8, #-1
        MOV     R5, #MAXNUMBEROFDRIVESSUPPORTED
        MOV     R7, R0
        ADRL    R2, DiscNameList

REPEAT_find_disc_name

        MOV     R4, R2                  ; R4 -> disc name in list
        MOV     R6, R7                  ; R6 -> start of name to search for
        ADD     R0, R4, #MAXLENGTHOFDISCNAME ; R0 -> end of R4

REPEAT_compare_disc_names               ; Is disc name in list = disc name ?
                                        ;
        LDRB    R3, [ R4 ], #1          ;
        LDRB    R1, [ R6 ], #1          ;

        CMP     R4, R0                  ; End of disc name ?
        BGE     disc_name_not_found     ; [ yes ]

        TEQ     R3, #0                  ;
        TEQEQ   R1, #0                  ; If both terminate at same time,must be same
        BEQ     UNTIL_compare_disc_names

        CMP     r3,#'A'
        RSBGES  r14,r3,#'Z'
        SUBGE   r3,r3,#&20
        CMP     r1,#'A'
        RSBGES  r14,r1,#'Z'
        SUBGE   r1,r1,#&20
        TEQ     r3,r1
        BEQ     UNTIL_compare_disc_names

        TEQ     R3, R1                    
        BEQ     REPEAT_compare_disc_names 
                                        ;
                                        ; [ no ]

disc_name_not_found

        SUBS    R5, R5, #1
        ADDNE   R2, R2, #MAXLENGTHOFDISCNAME
        BNE     REPEAT_find_disc_name
                
        CMP     R8, #-1                 ; Name occurs once, ie/ NOT Ambig name
        MOVNE   R1, R8                  ;
        Pull    "R0, R2 - R8, PC", NE


        MOV     R1, #-1                 ; not found
                                        ;
        Pull    "R0, R2 - R8, PC"       ;


UNTIL_compare_disc_names

        CMP     R8, #-1                 ; Ambiguous disc name check
        BEQ     %FT10

        addr    r0, AmbiguousDiscNameError_tag
        ADR     r1, message_block
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        BVS     ErrorExit
10
        RSB     R8, R5, #MAXNUMBEROFDRIVESSUPPORTED ; drive found at = 28 - R5
        
        SUBS    R5, R5, #1
        ADDNE   R2, R2, #MAXLENGTHOFDISCNAME
        BNE     REPEAT_find_disc_name
        
        MOV     R1, R8
        Pull    "R0, R2-R8,PC"

;********************************************************************
AddDiscNameInList ; R0 = drive number, R1 -> disc name
 ROUT
;********************************************************************

        Push    "R0 - R7, R14"

        ; Find where to put the name

        ADRL    R2, DiscNameList         ; R2 -> start of list place to put name
      [ MAXLENGTHOFDISCNAME<>32
        MOV     R3, #MAXLENGTHOFDISCNAME ;
        MLA     R2, R0, R3, R2           ;
      |
        ADD     R2, R2, R0, LSL #5
      ]
        ADD     R3, R2, #MAXLENGTHOFDISCNAME ; R3 -> end of disc name in list
        MOV     R5, R2

REPEAT_copy_disc_name

        LDRB    R4, [ R1 ], #1
        STRB    R4, [ R2 ], #1
        CMP     R2, R3

        BLT     REPEAT_copy_disc_name
                
        MOV     R2, #0
        STRB    R2, [ R3, #-2 ]
                
        Pull    "R0 - R7, PC"           ; V clear

;********************************************************************

        LTORG

        END
@


4.14
log
@Various CDFS enhancements
* Increase BGET/BPUT buffer declared to FileSwitch to 2k to match the natural sector size (FileSwitch has been able to support this since version 2.28)
* Remove local debug macros, use those from NDRDebug instead
* Change to use SETV/CLRV macros now the ones in HdrSrc are 26/32 neutral
* Clarify those situations where LBA mode is being selected by using symbol 'LBAFormat'
* Extend *WHICHDISC to allow an optional drive number to be provided (the code has existed for years, but the GSTrans flags and help denied its use)

Version 2.60. Tagged as 'CDFS-2_60'
@
text
@d63 1
a63 1
; DiscNumberOfDirectoryInBuffer
d96 1
a96 1
; This sorts out the URD, LIB, CSD etc; and also validates the path
d127 1
a127 1
        STR     R2, DiscNumberOfDirectoryInBuffer
d140 1
a140 1
        ADD     R1, R1, #MAINDIRECTORYOFFSETINABUFFER
d147 1
a147 1
        LDR     R4, [ R1, #LENGTHOFMAINDIROFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER ]
d154 1
a154 1
        LDR     R4, [ R1, #BLOCKSIZEOFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER ]
d158 1
a158 1
; Remember disc type ( ISO or HISIERRA )
d161 1
a161 1
        LDRB    R3, [ R1, #DISCTYPEOFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER ]
d168 1
a168 1
        LDR     R9, [ R1, #LBAOFMAINDIROFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER]
d430 1
a430 1
        LDR     R0, DiscNumberOfDirectoryInBuffer
d438 1
a438 1
        ADRCSL  R1, sparedirectorybuffer + MAINDIRECTORYOFFSETINABUFFER
d445 1
a445 1
; This will store a directory in the buffer, if not known
d486 1
a486 1
        LDR     R0, DiscNumberOfDirectoryInBuffer
d489 2
a490 4
;----------------------------------------
; The main directory entry may have moved
;----------------------------------------
        LDR     r0, DiscNumberOfDirectoryInBuffer
a492 1
                
d494 1
a494 1
        BCS     ErrorExit
d639 1
a639 1
PreLoadBlockFromDrive ; This sets R1=buffer in preperation
a646 1
; , R4 = unique disc number ????????
d862 2
a863 2
        MOV     R1, #PVD                ; make sure that disc is in mode 1 or 2
        SWI     XCD_EnquireDataMode     ;
d876 1
a876 1
        MOV     R0, #PVD
d879 2
a880 2
        BL      PreLoadBlockFromDrive ; R0 = block, R1 -> memory, R2 = length ( blocks )
                                      ; R3 = drive number
@


4.13
log
@Replace indexes into PVD with sensible names
All references into the PVD now use defines rather than mystic numbers.
Fix in CutSpace for 2 letter CD titles being cropped to 1 letter.
Tested with 2 letter CD ISO and with a photo CD/ISO9660/CD-I test disc.

Version 2.59. Tagged as 'CDFS-2_59'
@
text
@d273 1
a273 1
        VCLEAR
d284 1
a284 1
        VSET    NE
d393 1
a393 1
        VCLEAR
d515 1
a515 1
        VCLEAR
d657 1
d661 2
a663 4
        MOVVC   R1, R4
        MOVVC   R0, #0
                
        ; ADD EXTRA PARAMETER HERE
d860 1
a860 1
        VSET    NE                      ;
d865 1
a865 1
        MOV     R0, #0                  ;
d871 1
a871 1
        VSET    EQ
d911 1
a911 3
        DCB     "CD-ROM"                ; Keep together
NULL
        DCB     0
@


4.12
log
@Fix a few bugs
When lining up the code in 2.52, a few bugs became apparent (now the source was readable).
* In a handful of places it was assumed SWIs preserved flags, these have been reordered or branched around.
* The probe of UtilityModule 2.12 has been set to 3.00 and the logic now considers >= 3.00 rather than subtracting 1 from it to deduce the default filename truncation value.
* Removed support for supplemental filetype table in CDFSNewFileTypePath$File as this has been superceded by the MimeMap module (which CDFS uses). This mirrors the behaviour of DOSFS and LanManFS which consult the MimeMap first then (small) internal table second.
* Fix stack imbalance when reading the current setting with CDFS_Truncation leading to an abort

Other changes
* When the MimeMap module is absent ".doc" is taken to be a MS Word document.
* Changed the manual loads from :INDEX: of R12 to be ADR's or ADRL's so there's less literal pool thrashing.
* Three Push/Pull sequences to restore registers swapped for LDMIA's (in Directory.s).
* Reason codes to OS_ SWIs swapped for header file names.


Version 2.56. Tagged as 'CDFS-2_56'
@
text
@a25 1
;               CheckForISO9660        - checks disc for ISO or HISIERRA
d214 1
a214 1
        TEQ     R3, #DIVIDER            
d229 1
a229 1
        TEQ     R3, #DIVIDER
d246 1
a246 1
        TEQ     R3, #DIVIDER            
a563 1

d567 4
a570 6
                                        
        BNE     %BT01                   
                                        
        SUB     R2, R3, R0              ; R2 = length of string
                                        ; R3 -> end of string
        MOV     R1, R3                  
a575 2
        SUB     R3, R3, #2

d578 2
d581 7
a587 8
        TEQ     R3, R0                  ; If string is all spaces
        MOVEQ   R4, #0
        STREQB  R4, [ R3, #1 ]
        Pull    "R0 - R4, PC", EQ
                
        TEQ     R4, #SPACE
        BEQ     %BT02
                
d589 1
a589 3
        STRB    R4, [ R3, #2 ]!
                
        SUB     R2, R3, R0              ; length of string
d596 1
a596 1
03
d599 1
a599 1
        Pull    "R0 - R4, PC", GE
d602 1
a602 1
        BEQ     %BT03
d604 1
a604 1
        SUB     R1, R1, #1
d606 1
a606 2
                
        Pull    "R0 - R4, PC", LE
d612 1
a612 1
04
a614 1
                
d616 1
a616 1
        BLE     %BT04
@


4.11
log
@Exchange local definitions for central ones.
Hdr:HighFSI LowFSI Services CDROM CMOS UpCall and CDFS now used in preference to local definitions.
Macro 'Command' used to build the keyword table.
Some asserts added for safety.


Version 2.54. Tagged as 'CDFS-2_54'
@
text
@d196 1
a196 1
        ADD     R1, R12, #:INDEX:tempbuffer
d372 1
a372 1
        ADD     R2, R12, #:INDEX:TempArea                   ; Copy to
d439 1
a439 2
        LDRCS   R1, =:INDEX:sparedirectorybuffer + MAINDIRECTORYOFFSETINABUFFER
        ADDCS   R1, R1, R12
d455 1
a455 1
        ADD     R3, R12, #:INDEX:tempBlockSize
d653 2
a654 2
        LDR     R1, =:INDEX:buffer
        ADD     R1, R1, R12
d713 1
a713 1
        ADD     R3, R12, #:INDEX:TempArea  
d825 1
a825 2
        LDR     R14, =:INDEX:discsMounted
        ADD     R14, R14, R12
d871 1
a871 2
        Pull    "R0 - R8, R14", VS      ;
        Push    "R0 - R8, R14", VS      ;
d882 1
a882 2
        Pull    "r0 - r8, r14", VS
        Push    "r0 - r8, r14", VS
d910 1
a910 2
        Pull    "R0 - R8, R14", NE
        Push    "R0 - R8, R14", NE
d941 1
a941 2
        LDR     R2, =:INDEX:DiscNameList
        ADD     R2, R2, R12
d994 1
d996 6
a1001 6
        addr    r0, AmbiguousDiscNameError_tag, NE
        ADRNE   r1, message_block
        MOVNE   r2, #0
        SWINE   XMessageTrans_ErrorLookup
        BNE     ErrorExit

d1020 1
a1020 2
        LDR     R2, =:INDEX:DiscNameList ; R2 -> start of list place to put name
        ADD     R2, R2, R12              ;
@


4.10
log
@Collapse old switches.
Switches from 10+ years ago removed. Demo version switch removed.

Version 2.53. Not tagged
@
text
@d284 1
a284 1
        TEQNE   R14, #DIRECTORY
d339 1
a339 1
        MOVLE   R2, #NOTFOUND           ;
d381 1
a381 1
        TEQ     R4, #FILE               ; If it is A FILE then the end has been reached
d386 1
a386 1
        MOVNE   R2, #NOTFOUND           ;
d390 1
a390 1
        MOVEQ   R2, #FILE               ;
d479 2
a480 2
        MOVNE   r1, # 0                 ; NOT FOUND
        MOVNE   r2, # NOTFOUND          ;
d514 1
a514 1
        MOV     R2, #DIRECTORY          ; R2 = directory attrib
d843 1
a843 1
        MOV     R1, #FILINGSYSTEMNUMBER ; R1 = CDFS
d846 1
a846 1
        MOV     R0, #Medium_Not_Present ; R0 = media not present ( see page 137 of PRM )
d920 1
a920 1
        MOV     R0, #Medium_Found
d953 1
a953 1
        ADD     R0, R4, #LENGTHOFDISCNAME ; R0 -> end of R4
d984 1
a984 1
        ADDNE   R2, R2, #LENGTHOFDISCNAME
d1010 1
a1010 1
        ADDNE   R2, R2, #LENGTHOFDISCNAME
d1026 8
a1033 4
        ADD     R2, R2, R12             ;
        MOV     R3, #LENGTHOFDISCNAME   ;
        MLA     R2, R0, R3, R2          ;
        ADD     R3, R2, R3              ; R3 -> end of disc name in list
@


4.9
log
@Resolve the 32 assembler warnings
Mostly by swapping STASH/GRAB for Push/Pull macros.
Inlined the module header rather than defining it in a header file.
Renamed "Debug" macro to "DebugInline" to avoid clash with similarly named macro.

Version 2.53. Tagged as 'CDFS-2_53'
@
text
@a469 8
      [ Module_Version <= 220
        CMP     R6, #0
                
        Pull    "R0-R5",EQ
        MOVEQ   R1, #0                  ; NOT FOUND
        MOVEQ   R2, #NOTFOUND           ;
        Pull    "R5 - R11, PC", EQ      ;
      |
a483 1
      ]
a881 2
      [ Module_Version > 218

a889 11
      |
        ; old way that only checks for mode 1 and mode 2
        TEQ     R0, #1
        TEQNE   R0, #2
        VSET    NE
        Pull    "R0 - R8, R14", VS     
        Push    "R0 - R8, R14", VS     
        MOVVS   R8, R1
        BVS     prompt_for_disc        
      ]

@


4.8
log
@Line up sources to normal columns.
Around 25000 spaces required, but rather easier to read as a result - it has revealed some bugs (not addressed in this commit).
Not quite binary identical, because an 'addr' of the ambiguous disc name error has moved by 1 byte due to a missing ALIGN directive.
Not tagged.
@
text
@d66 1
a66 1
        STASH   "R5 - R11, R14"
d292 1
a292 1
        STASH   "r0-r3"
d305 1
a305 1
        GRAB    "r0-r3", NE
d312 1
a312 1
        GRAB    "r0-r3"
d340 1
a340 1
        GRAB    "R5 - R11, PC", LE      ;
d395 1
a395 1
        GRAB    "R5 - R11, PC"
d429 1
a429 1
        STASH   "R0, R2"
d443 1
a443 1
        GRAB    "R0, R2"
d454 1
a454 1
        STASH   "R0 - R5"
d473 1
a473 1
        GRAB    "R0-R5",EQ
d476 1
a476 1
        GRAB    "R5 - R11, PC", EQ      ;
d486 1
a486 1
        GRAB    "r0 - r5", NE
d489 1
a489 1
        GRAB    "r5 - r11, pc", NE      ;
d512 1
a512 1
        GRAB    "R0-R5"
d527 1
a527 1
        GRAB    "R5 - R11, PC"
d548 1
a548 1
        STASH   "R0 - R4"
d557 1
a557 1
        GRAB    "R0 - R4", NE
d564 1
a564 1
        GRAB    "R0 - R4"
d572 1
a572 1
        STASH   "R0 - R4, R14"
d598 1
a598 1
        GRAB    "R0 - R4, PC", EQ
d616 1
a616 1
        GRAB    "R0 - R4, PC", GE
d624 1
a624 1
        GRAB    "R0 - R4, PC", LE
d637 1
a637 1
        GRAB    "R0 - R4, PC"
d643 1
a643 1
        STASH   "r1-r4, r14"
d647 1
a647 1
        GRAB    "r1-r4, pc", NE
d656 1
a656 1
        GRAB    "r1-r4, pc"
d672 1
a672 1
        STASH   "R0 - R7, R14"
d688 1
a688 1
        GRAB    "R0 - R7, PC"
d694 1
a694 1
        STASH   "R0, R2 - R7, R14"
d713 1
a713 1
        GRAB    "R0, R2 - R7, PC"       ;
d756 1
a756 1
        STASH   R0
d761 1
a761 1
        GRAB    "R0"                    ; must be a name
d771 1
a771 1
        GRAB    "R0, R2 - R7, PC"
d790 1
a790 1
        GRAB    "R0, R2 - R7, PC"       ; 'V' already cleared
d797 1
a797 1
        STASH   "R0 - R8, R14"
d826 1
a826 1
        STASH   R2
d832 1
a832 1
        GRAB    R2
d840 1
a840 1
        GRAB    "R0 - R8, PC", EQ
d882 2
a883 2
        GRAB    "R0 - R8, R14", VS      ;
        STASH   "R0 - R8, R14", VS      ;
d896 2
a897 2
        GRAB    "r0 - r8, r14", VS
        STASH   "r0 - r8, r14", VS
d906 2
a907 2
        GRAB    "R0 - R8, R14", VS     
        STASH   "R0 - R8, R14", VS     
d915 1
a915 1
        STASH   R2 - R3
d921 1
a921 1
        GRAB    R2 - R3
d936 2
a937 2
        GRAB    "R0 - R8, R14", NE
        STASH   "R0 - R8, R14", NE
d945 1
a945 1
        GRAB    "R0 - R8, PC"
d963 1
a963 1
        STASH   "R0, R2 - R8, R14"
d1011 1
a1011 1
        GRAB    "R0, R2 - R8, PC", NE
d1016 1
a1016 1
        GRAB    "R0, R2 - R8, PC"       ;
d1036 1
a1036 1
        GRAB    "R0, R2-R8,PC"
d1043 1
a1043 1
        STASH   "R0 - R7, R14"
d1065 1
a1065 1
        GRAB    "R0 - R7, PC"           ; V clear
@


4.7
log
@     	Added RockRidge name extension to CDFS and removed
	the 'force uppercase' constraint to render it
	more user friendly.
Detail:
Admin:  castle added IP .. tested at castle.


Version 2.48. Tagged as 'CDFS-2_48'
@
text
@a20 1

a32 1
;               WildCompareStrings     - RISC OS 2 ONLY
d66 1
a66 1
 STASH "R5 - R11, R14"
d73 2
a74 3
 MOV R8, R1, ASL #9

 MOV R10, R0
d82 1
a82 1
 BL FindDriveNumber           ; R0 -> pathname, RETURNS R1 = drive number
d88 1
a88 1
 ORR R8, R8, R1
d94 1
a94 12
; LDRB R4, numberofdrives

 AND R0, R8, #255


; CMP R8, R4                    ; drive number > number of drives ?

; BLGT AnotherDriveHasBeenAdded ; R0 = drive number added, RETURNS V set if error
; BVS ErrorExit

;****************

d100 3
a102 3
 MOV R2, R1
 MOV R0, R10
 AND R1, R8, #255
d104 2
a105 2
 BL FullPathName             ; RETURNS R0 -> whole name, R1 = drive number
                             ; R2 = disc number
d113 1
a113 1
 MOV R10, R0
d119 4
a122 7
 AND R0, R8, #255

 BL TestKnowDisc              ; R0 = drive number, RETURNS R1 -> buffer
                              ; RETURNS R2 = disc number
; TEQ R1, #0                   ; Not found the buffer for that disc
; addr R0, InternalError, EQ
; BEQ ErrorExit
d128 6
a133 7

 STR R2, DiscNumberOfDirectoryInBuffer

; Make sure that blocky offset starts from zero

 MOV R14, #0
 STR R14, tempInk
d140 2
a141 10
 STR R1, maindirpointer

 ADD R1, R1, #MAINDIRECTORYOFFSETINABUFFER







d147 3
a149 21
 STR R1, tempbufferpointer












;****************
; Remember length
;****************

; R11 -> directory details ( past header info, so have to back track )

 LDR R4, [ R1, #LENGTHOFMAINDIROFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER ]
 STR R4, tempLength
d154 3
a156 5

; R11 -> directory details ( past header info, so have to back track )

 LDR R4, [ R1, #BLOCKSIZEOFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER ]
 STR R4, tempBlockSize
d162 2
a163 4
; R11 -> directory details ( past header info, so have to back track )

 LDRB R3, [ R1, #DISCTYPEOFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER ]
 STRB R3, tempDisctype
d169 2
a170 2
 LDR R9, [ R1, #LBAOFMAINDIROFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER]
 STR R9, tempBlock
d176 1
a176 4
 MOV R9, #0                  ; Word = 1

;****************

d182 2
a183 1
 MOV R11, R1
d189 1
a189 1
 ADD R9, R9, #1
d195 8
a202 11
 MOV R0, R10

 ADD R1, R12, #:INDEX:tempbuffer

; R0 -> pathname$,R1 -> word$, R9 = word number
; R0 & R2 - R5 corrupted

; WordFromPath    ; Macro

 MOV R5, #0
 MOV R4, R1
d210 11
a220 11
 LDRB R3, [ R0 ], #1

 TEQ R3, #0                     ; Reached end of path, but didn't find word ?
 BEQ directory

 TEQ R3, #DIVIDER
 ADDEQ R5, R5, #1                   ; Increase word count if found '.'

 CMP R5, R9

 BLT %BT01
d228 6
a233 6
 LDRB R3, [ R0 ], #1
 STRB R3, [ R4 ], #1
 TEQ R3, #DIVIDER
 TEQNE R3, #0

 BNE %BT02
d235 1
a235 1
; --- End of path ? BUT DID I WANT A DIRECTORY OR A FILE ? ---
d237 3
a239 3
 TEQ      R3, #0
 ORRNE    R8, R8, #1:SHL:11
 BICEQ    R8, R8, #1:SHL:11
d241 3
a243 2
; TEQ R3, #0
; BNE %FT12
d245 1
a245 3
 TST R8, #512
 ORRNE R8, R8, #256   ; Directory
 BICEQ R8, R8, #256   ; File
d247 3
a249 1
; --- If divider following, then must be a directory wanted ---
d251 1
a251 3
 TEQ R3, #DIVIDER
 ORREQ R8, R8, #256   ; Directory
 BICNE R8, R8, #256   ; File
d253 2
a254 4
; --- Get rid of last dot ---

 MOV R3, #0
 STRB R3, [ R4, #-1 ]
d260 1
a260 1
 MOV R0, R11
d262 1
a262 1
; R0 -> memory, R1 -> name$, RETURN R2 = position  Vset if not found
d264 2
a265 2
 MOV R5, R0
 MOV R0, R1
d269 2
a270 3
 ADD R1, R5, #OBJECTNAMEOFFSET         ; R0 -> wildcarded string
                                       ; R1 -> prepared string in buffer
; --- Do I care what I'm looking for ? ---
d272 1
a272 1
 VCLEAR
d274 1
a274 2
 TST R8, #1024
 BNE %FT11                        ; [ no ]
d276 2
a277 1
; --- If haven't reached end of path, then must look for a directory ---
d279 1
a279 1
; VCLEAR
d281 5
a285 5
 TST R8, #256                          ; If it's a directory that you want
                                       ; but you don't find one, ignore it
 LDRB R14, [ R5, #OBJECTTYPEOFFSET ]
 TEQNE R14, #DIRECTORY
 VSET NE
d292 1
a292 1
         STASH      "r0-r3"
d294 21
a314 21
         LDRB       r2, [ r0 ], #1
         LDRB       r3, [ r1 ], #1
         CMP        r3,#'a'
         RSBGES     r14,r3,#'z'
         SUBGE      r3,r3,#&20
         CMP        r2,#'a'
         RSBGES     r14,r2,#'z'
         SUBGE      r2,r2,#&20
         TEQ        r2, r3

; not found
         GRAB       "r0-r3", NE
         BNE        %FT16

         CMP        r2, #32
         BGE        %BT15

; found
         GRAB       "r0-r3"
         MOV        r2, r5
         B          %FT02
d317 1
a317 5

;-------------------------------------------------------------------


 ADD R5, R5, #OBJECTNAMEOFFSET + 1
d320 33
a352 8
 LDRB R4, [ R5 ], #1
 TEQ R4, #0
 BNE %BT04

 ALIGNREG R5

 LDR R4, [ R5, #LBASTARTOFFSET ]
 MOVS R4, R4, LSR #8
d354 1
a354 28
 BNE %BT01

; Move to next block, if there is one

 LDR R14, tempLength

 LDR R0, tempBlockSize
 SUBS R14, R14, R0

 MOVLE R1, #0                            ; NOT FOUND
 MOVLE R2, #NOTFOUND                     ;
 GRAB "R5 - R11, PC", LE                 ;

 STR R14, tempLength

 LDR R14, tempInk
 ADD R14, R14, #MAX_BLOCKS_BUFFERED
 STR R14, tempInk
 LDR R0, tempBlock                   ; need to keep this as start block
 ADD R0, R14, R0                     ; 'cause use in other procedures (sorry)

 SUB R9, R9, #1                      ; 'cause I haven't found anything

 B more_blocky



02  ; Found
d360 1
a360 4
; blocky offset back to zero

 MOV R6, #0
 STR R6, tempInk
d362 4
a365 11
 MOV R6, R2

;****************
; Change wildcarded name in path to full name that was found
;****************

; MOV R0, R10
; ADD R1, R2, #OBJECTNAMEOFFSET
; MOV R2, R9

; BL CompleteName                       ; R0-> wild path, R1 -> name, R2=word
d371 4
a374 8
 MOV R1, R6                                       ; Copy from

 ADD R2, R12, #:INDEX:TempArea                    ; Copy to

 MOV R3, #OBJECTNAMEOFFSET + MAXLENGTHOFNAME + 1  ; Copy length

 ; R1 -> from, R2 -> to, R3 = length
 CD_ByteCopy
d380 13
a392 13
 LDRB R4, [ R6, #OBJECTTYPEOFFSET ]
 TEQ R4, #FILE                ; If it is A FILE then the end has been reached
 BNE    %FT23

 TST   R8, #1:SHL:11          ; end of path ?
 MOVNE R1, #0                 ; [ no - so NOT FOUND ]
 MOVNE R2, #NOTFOUND          ;

 MOVEQ R0, R10                ; [ yes - so return file details ]
 MOVEQ R1, R6                 ;
 MOVEQ R2, #FILE              ;
 LDREQ R3, maindirpointer     ;
 ANDEQ R4, R8, #255           ;
d394 2
a395 2
 VCLEAR
 GRAB "R5 - R11, PC"
d403 2
a404 9
 LDR R5, [ R6, #LENGTHOFFSET ]

 STR R5, tempLength

;****************
; Attempt to buffer this directory, if possible
;****************


d410 3
a412 3
 LDR R0, [ R6, #LBASTARTOFFSET ]
 MOV R0, R0, LSR #8
 STR R0, tempBlock
d429 5
a433 5
 STASH "R0, R2"
 MOV R2, R0
 LDR R0, DiscNumberOfDirectoryInBuffer
 BL FindDiscInBufferList  ; R0 = disc, RETURNS R1 -> buf, R2 = LBA
                          ; C set if not found, else C clear
d439 6
a444 6
 LDRCS R1, =:INDEX:sparedirectorybuffer + MAINDIRECTORYOFFSETINABUFFER
 ADDCS R1, R1, R12
 STR R1, tempbufferpointer

 GRAB "R0, R2"
 BCC try_again
d451 13
a463 13
;R0 = start LBA, R1 -> place to put, R2 UNUSED
;R3 = disc type, R4 = blocksize, R5 = drive number, RETURNS R6 = size of mem

 STASH "R0 - R5"

 ADD R3, R12, #:INDEX:tempBlockSize
 LDMIA R3, { R4, R6 }

 LDRB R3, tempDisctype

 AND R5, R8, #255

 BL StoreDirectory
d470 20
a489 23
 [ Module_Version <= 220

 CMP    R6, #0

 GRAB  "R0-R5",EQ
 MOVEQ R1, #0                            ; NOT FOUND
 MOVEQ R2, #NOTFOUND                     ;
 GRAB "R5 - R11, PC", EQ                 ;

 |

; If there was nothing in that directory block AND expected something then exit
 CMP       r6, # 4
 BNE       D_FullBlock

 LDR       r14, tempLength
 LDR       r2, tempBlockSize
 TEQ       r14, r2

 GRAB      "r0 - r5", NE
 MOVNE     r1, # 0                            ; NOT FOUND
 MOVNE     r2, # NOTFOUND                     ;
 GRAB      "r5 - r11, pc", NE                 ;
d492 1
a492 1
 ]
d494 5
a498 5
 MOV R2, R0
 MOV R3, R1
 MOV R1, R6                                ;
 LDR R0, DiscNumberOfDirectoryInBuffer
 BL AddDirectoryToBuffer      ; R0 = disc, R1 = size, R2 = block, R3->dire
d503 8
a510 6
 LDR       r0, DiscNumberOfDirectoryInBuffer
 MOV       r2, #PVD
 BL        FindDiscInBufferList

 MOVCS     r0, #ERROR_INTERNALERROR
 BCS       ErrorExit
d512 1
a512 3
 STR       r1, maindirpointer

;----------------------------------------
d514 1
a514 1
 GRAB "R0-R5"
d516 1
a516 3
 B try_again

; --- Reached end of path, but didn't find word ? ---
d521 7
a527 7
 MOV R0, R10                        ; R0 -> expanded pathname
 MOV R1, R11                        ; R1 -> current buffer
 MOV R2, #DIRECTORY                 ; R2 = directory attrib
 LDR R3, maindirpointer             ; R3 -> main dir header
 AND R4, R8, #255                   ; R4 = drive number
 VCLEAR
 GRAB "R5 - R11, PC"
d543 2
a544 2
 TEQ R2, #0
 MOVEQ PC, R14
d546 1
a546 1
; R2 -> end of R1
d548 1
a548 1
 STASH "R0 - R4"
d550 1
a550 1
 ADD R2, R2, R1
d553 13
a565 15

 LDRB R4, [ R0 ], #1
 LDRB R3, [ R1 ], #1

 TEQ R4, R3

 GRAB "R0 - R4", NE
 MOVNE PC, R14

 CMP R1, R2
 BLT %BT01

 ; Z is now set
 GRAB "R0 - R4"
 MOV PC, R14
d572 1
a572 1
 STASH "R0 - R4, R14"
d574 1
a574 1
 MOV R3, R0                   ; Find the length of the string
d577 8
a584 9

 LDRB R2, [ R3 ], #1
 TEQ R2, #0

 BNE %BT01

 SUB R2, R3, R0               ; R2 = length of string
                              ; R3 -> end of string
 MOV R1, R3
d590 1
a590 1
 SUB R3, R3, #2
d593 1
d595 12
a606 14
 LDRB R4, [ R3 ], #-1

 TEQ R3, R0                      ; If string is all spaces
 MOVEQ R4, #0
 STREQB R4, [ R3, #1 ]
 GRAB "R0 - R4, PC", EQ

 TEQ R4, #SPACE
 BEQ %BT02

 MOV R4, #0
 STRB R4, [ R3, #2 ]!

 SUB R2, R3, R0                   ; length of string
d612 1
a612 2
 MOV R1, R0

d614 11
a624 15

 LDRB R4, [ R1 ], #1

 CMP R1, R3
 GRAB "R0 - R4, PC", GE

 TEQ R4, #SPACE
 BEQ %BT03


 SUB R1, R1, #1

 CMP R1, R0

 GRAB "R0 - R4, PC", LE
d631 7
a637 9

 LDRB R4, [ R1 ], #1
 STRB R4, [ R0 ], #1

 CMP R1, R3
 BLE %BT04

 GRAB "R0 - R4, PC"

d643 14
a656 18
; uses tempbuffer_offset
; uses TempArea_offset
;------------------------------------------------------------------------------------------

            STASH       "r1-r4, r14"

            LDRB        r3, [ r0 ]
            TEQ         r3, #":"
            GRAB        "r1-r4, pc", NE

            ADD         r0, r0, #1

02
            LDRB        r3, [ r0 ], #1
            TEQ         r3, #"."
            BNE         %BT02

            GRAB        "r1-r4, pc"
a658 5
;------------------------------------------------------------------------------------------


;-----------------------------------------------------------------------------

d663 2
a664 2
 LDR R1, =:INDEX:buffer
 ADD R1, R1, R12
d672 1
a672 23
 STASH "R0 - R7, R14"

 MOV R4, R0
 MOV R5, R1

; ADD R7, R12, #sparecontrolblock_offset

 MOV R0, R3

 BL PreConvertDriveNumberToDeviceID   ; R0 = drive number, R7 -> memory

 MOVVC R3, R5

 MOVVC R1, R4

 MOVVC R0, #0

; ADD EXTRA PARAMETER HERE
 MOVVC R4, #myblocksize

 SWIVC XCD_ReadData

 BVS ErrorExit
d674 15
a688 1
 GRAB "R0 - R7, PC"
d694 1
a694 7
 STASH "R0, R2 - R7, R14"

;**********************
; convert lower case to upper case
;**********************

 MOV R6, R0
d696 1
d698 16
a713 24

 LDRB R2, [ R6 ]

; UpperCase R2, R14

 STRB R2, [ R6 ], #1

 TEQ R2, #0

 BNE %BT01


 MOV R6, R0

 LDRB R1, [ R6 ]
 TEQ R1, #":"                     ; drive specified in pathname
 BEQ %FT02                        ; either by name, or number ?
                                  ; [ must mean current drive number ]

 TEQ R1, #"\\"                    ; Use the old drive number ! if previous
 LDREQB R1, olddrivenumber        ; path is required
 LDRNEB R1, CurrentDriveNumber    ;
 GRAB "R0, R2 - R7, PC"           ;

d716 30
d747 2
a748 34
 ADD R1, R0, #1                 ; Copy into a safe area

 LDRB R3, [ R1 ]                ; Nothing specified ? ( no name, no number )
 TEQ R3, #0                     ;
      MOVEQ      r0, #ERROR_BADNAME
      BEQ        ErrorExit

 ADD R3, R12, #:INDEX:TempArea  ;
 MOV R4, R3                     ;
                                ;
04                              ;
 LDRB R2, [ R1 ], #1            ;
 STRB R2, [ R3 ], #1            ;
 TEQ R2, #"."                   ;
 TEQNE R2, #0                   ;
 TEQNE R2, #&0D                 ;
 TEQNE R2, #SPACE               ;
 BNE %BT04                      ;

 ; Make sure that 'drive.&', 'drive.%', 'drive.\', 'drive.@@'
 ; give a 'bad name' error

 TEQ R2, #0

 BEQ fine

 LDRB R2, [ R1 ]
 TEQ R2, #"&"
 TEQNE R2, #"%"
 TEQNE R2, #"\\"
 TEQNE R2, #"@@"

      MOVEQ      r0, #ERROR_BADNAME
      BEQ        ErrorExit
d752 3
a754 4
 MOV R2, #0                     ; Null terminate entry
 STRB R2, [ R3, #-1 ]

 MOV R1, R4
d756 1
a756 1
 STASH R0
d758 2
a759 1
 MOV R0, #10
d761 3
a763 1
 SWI XOS_ReadUnsigned
d765 3
a767 3
 GRAB "R0"                 ; must be a name
 BVS SoItIsADiscName
                           ; was a number
d769 1
a769 3
 CMP R2, #MAXNUMBEROFDRIVESSUPPORTED
     MOVGT       r0, #ERROR_BADDRIVE
     BGT         ErrorExit
d771 1
a771 4

 MOV R1, R2

 GRAB "R0, R2 - R7, PC"
d777 2
a778 7
 MOV R0, R4

 BL CheckDiscName              ; R0 -> disc name, RETURNS R1 TRUE/FALSE

 TEQ R1, #FALSE
       MOVEQ        r0, #ERROR_BADNAME
       BEQ          ErrorExit
d780 3
a782 1
 BL FindDiscNameInList         ; R0 -> disc name, RETURNS R1 = drive number
d784 1
a784 1
 CMP R1, #-1                   ; Disc known ?
d786 3
a788 1
 LDREQB R1, CurrentDriveNumber ; [ no ]
d790 1
a790 7
 BL PromptForDisc         ; R0 -> disc name to prompt for, R1 = drive

; MOV R0, R1
; BL TestKnowDisc   ; R0 = drive number, RETURNS R1->buf, RETURNS R2 = disc
; MOV R1, R0

 GRAB "R0, R2 - R7, PC"                ; 'V' already cleared
d797 11
a807 11
 STASH "R0 - R8, R14"

 ; First look at disc in drive to see if known

 MOV R6, R0
 MOV R8, R1
 MOV R2, R0

 LDR R14, discbuffersize
 TEQ R14, #0
 BEQ fiddle_buffer_for_prompt
d813 28
a840 11
; Is drive mounted ?
; Is disc in drive same ?


; Is disc_name in disc list ?        - no so not_in_memory

 BL FindDiscNameInList         ; R0 -> disc name, RETURNS R1 = drive number

 CMP R1, #-1                   ; Disc known ?

 BEQ fiddle_buffer_for_prompt
d842 1
a842 27
; Is drive same as requested drive ? - no so not_in_memory

 TEQ R8, R1
 BNE fiddle_buffer_for_prompt


; Is disc in drive same as requested disc ?

 STASH R2

 MOV R2, #1
 MOV R0, R8
 BL GetUniqueNumber
 TEQ R1, #0
 GRAB R2
 BEQ fiddle_buffer_for_prompt



 LDR R14, =:INDEX:discsMounted
 ADD R14, R14, R12
 LDR R14, [ R14, R0, LSL #2 ]
 CMP R14, R1
; Yes so exit without prompt
 GRAB "R0 - R8, PC", EQ

 B fiddle_buffer_for_prompt
d848 1
a848 1
 MOV R0, R6
d852 16
a867 17
 MOV R1, #FILINGSYSTEMNUMBER ; R1 = CDFS
 MOV R2, R0            ; R2 -> disc name
 MOV R3, R8            ; R3 = drive number
 MOV R0, #Medium_Not_Present ; R0 = media not present ( see page 137 of PRM )
 MOV R4, #0            ; R4 = iteration count
 MOV R5, #-1           ; R5 = Timeout never
 ADR R6, COMPACTDISC   ; R6 = media type name

 SWI XOS_UpCall

             MOVVS       r0, #ERROR_DISCNOTFOUND
             BVS         ErrorExit


 TEQ R0, #0                      ; Forget it ?
             MOVNE       r0, #ERROR_DISCNOTFOUND
             BNE         ErrorExit
d871 3
a873 7
 MOV R0, R8


; ADD R7, R12, #sparecontrolblock_offset
 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> controlblock
 BVS ErrorExit

d879 73
a951 86
 SWI XCD_DriveStatus

 TEQ R0, #1                      ; Drive not ready so try again
 VSET NE                         ;
 GRAB "R0 - R8, R14", VS         ;
 STASH "R0 - R8, R14", VS        ;
 MOVVS R8, R1                    ;
 BVS prompt_for_disc             ;


;********

 MOV R0, #0                      ;
 MOV R1, #PVD                    ; make sure that disc is in mode 1 or 2
 SWI XCD_EnquireDataMode         ;


;---------------------------------------------

 [ Module_Version > 218

; This just makes sure that it's not an audio disc

 TEQ       r0, #0
 VSET      EQ
 GRAB      "r0 - r8, r14", VS
 STASH     "r0 - r8, r14", VS
 MOVVS     r8, r1
 BVS       prompt_for_disc

 | ; old way that only checks for mode 1 and mode 2
 TEQ R0, #1
 TEQNE R0, #2
 VSET NE
 GRAB "R0 - R8, R14", VS         ;
 STASH "R0 - R8, R14", VS        ;
 MOVVS R8, R1
 BVS prompt_for_disc             ;

 ]

;---------------------------------------------

 SWI XCD_DiscHasChanged


 STASH R2 - R3
 MOV R0, #PVD
 MOV R2, #1
 MOV R3, R8
 BL PreLoadBlockFromDrive ; R0 = block, R1 -> memory, R2 = length ( blocks )
                       ; R3 = drive number
 GRAB R2 - R3

 MOV R0, R8
 BL GetDiscNameNotInBuffer ; R0 = drive, R1 -> name of disc in drive
 MOV R0, R1
 BL CutSpace               ; R0 -> disc name

 MOV R1, R2                ; R0 -> disc name to hope for

 LengthOfString R0, R2, R14
 LengthOfString R1, R3, R14


 TEQ R2, R3

 BLEQ CompareStrings    ; returns 'eq' or 'ne'

 GRAB "R0 - R8, R14", NE
 STASH "R0 - R8, R14", NE
 MOVNE R8, R1
 BNE prompt_for_disc


 ; Found the right disc, now tell UpCall about it

 MOV R0, #Medium_Found
 SWI XOS_UpCall

 GRAB "R0 - R8, PC"

COMPACTDISC = "CD-ROM"                ; Keep together
NULL        = 0                       ;

 ALIGN
d963 7
a969 10
 STASH "R0, R2 - R8, R14"

 MOV R8, #-1

 MOV R5, #MAXNUMBEROFDRIVESSUPPORTED
 MOV R7, R0
 LDR R2, =:INDEX:DiscNameList
 ADD R2, R2, R12


d973 29
a1001 31

 MOV R4, R2                     ; R4 -> disc name in list
 MOV R6, R7                     ; R6 -> start of name to search for
 ADD R0, R4, #LENGTHOFDISCNAME  ; R0 -> end of R4

REPEAT_compare_disc_names       ; Is disc name in list = disc name ?
                                ;
  LDRB R3, [ R4 ], #1           ;
  LDRB R1, [ R6 ], #1           ;

  CMP R4, R0                    ; End of disc name ?
  BGE disc_name_not_found       ; [ yes ]

  TEQ R3, #0                    ;
  TEQEQ R1, #0                  ; If both terminate at same time,must be same
  BEQ UNTIL_compare_disc_names  ;
                                ;
        CMP    r3,#'A'
        RSBGES r14,r3,#'Z'
        SUBGE  r3,r3,#&20
        CMP    r1,#'A'
        RSBGES r14,r1,#'Z'
        SUBGE  r1,r1,#&20
        TEQ    r3,r1
  BEQ UNTIL_compare_disc_names  ;
                                ;
  TEQ R3, R1                    ;
  BEQ REPEAT_compare_disc_names ;
                                ;
                                ; [ no ]

d1005 7
a1011 7
  SUBS R5, R5, #1
  ADDNE R2, R2, #LENGTHOFDISCNAME
  BNE REPEAT_find_disc_name

  CMP     R8, #-1               ; Name occurs once, ie/ NOT Ambig name
  MOVNE   R1, R8                ;
  GRAB "R0, R2 - R8, PC", NE    ;
d1014 3
a1016 3
 MOV R1, #-1                    ; not found
                                ;
 GRAB "R0, R2 - R8, PC"         ;
d1021 1
a1021 13
 CMP     R8, #-1                 ; Ambiguous disc name check

        addr      r0, AmbiguousDiscNameError_tag, NE
        ADRNE     r1, message_block
        MOVNE     r2, #0
        SWINE     XMessageTrans_ErrorLookup
        BNE       ErrorExit

 RSB     R8, R5, #MAXNUMBEROFDRIVESSUPPORTED ; drive found at = 28 - R5

 SUBS    R5, R5, #1
 ADDNE   R2, R2, #LENGTHOFDISCNAME
 BNE     REPEAT_find_disc_name
d1023 14
a1036 2
 MOV     R1, R8
 GRAB    "R0, R2-R8,PC"
d1043 1
a1043 1
 STASH "R0 - R7, R14"
d1045 1
a1045 1
; Find where to put the name
d1047 6
a1052 10
 LDR R2, =:INDEX:DiscNameList   ; R2 -> start of list place to put name
 ADD R2, R2, R12                ;
                                ;
 MOV R3, #LENGTHOFDISCNAME      ;
                                ;
 MLA R2, R0, R3, R2             ;

 ADD R3, R2, R3                 ; R3 -> end of disc name in list

 MOV R5, R2
d1056 10
a1065 5
 LDRB R4, [ R1 ], #1
 STRB R4, [ R2 ], #1
 CMP R2, R3

 BLT REPEAT_copy_disc_name
a1066 10
 MOV R2, #0
 STRB R2, [ R3, #-2 ]

 GRAB "R0 - R7, PC" ; V clear




;********************************************************************
;********************************************************************
d1069 1
a1069 1
 LTORG
d1071 1
a1071 1
 END
@


4.6
log
@Fixed a bit of errant non-32-bitness.

Version 2.39. Tagged as 'CDFS-2_39'
@
text
@d353 6
d823 1
a823 1
 UpperCase R2, R14
d1162 7
a1168 2
  TEQ R3, #0                    ;
  TEQEQ R1, #"."                ; If both terminate at same time,must be same
@


4.5
log
@  Lots of changes for RISC OS 5.
Detail:
  * Updated to use objasm, shared makefiles and global headers
  * Ripped out lots of RISC OS 2 support code so we can see the wood for the
    trees now
  * 32-bit compatible (a bit of a slog)
  * Now has its own resources phase, replacing the use of the CDFSResources
    module. Also means that messages can now be tokenised properly. For
    good measure, split out CmdHelp tokens into separate file
  * Hopefully fixed more bugs along the way than I introduced. I've seen
    lots of nasty stack imbalances in error cases, but not fixed all of
    them, I'm afraid
Admin:
  Tested briefly on a Risc PC; not enough support modules to run on Tungsten
  yet.

Version 2.38. Tagged as 'CDFS-2_38'
@
text
@a804 1
 BIC R14, R14, #Overflow_Flag
@


4.4
log
@Manual merge of the RISC OS 4.02 version of CDFS (2.37, based upon Acorn's
RiscOS/UnU/OS_Core/FileSys/CDFS/CDFS234 version 2.35).

Tagged as 'CDFS-2_37'
@
text
@d48 2
a49 1
;          all other regs & flags preserved
d105 1
a105 1
; BVS Error
a109 8
 [ RISC_OS=2

; MOV R2, #0
 BL PreGetUniqueNumber ; R0 = drive number, RETURNS R1, R2 = 0 or 1


 ]

d139 1
a139 1
; BEQ Error
d329 1
a329 1
 CLV
d336 1
a336 1
; CLV
d342 1
a342 1
 SEV NE
a348 6
 [ RISC_OS=2
 BLVC WildCompareStrings               ; RETURNS VCLEAR if found

 MOVVC R2, R5                          ; [ yes ]
 BVC %FT02                             ;
 |
a367 1
 ]
d395 1
a395 1
 GRABS "R5 - R11, PC", LE                ;
d465 2
a466 1
 GRABS "R5 - R11, PC"
d541 1
a541 1
 BL StoreDirectory          ; RETURNS EQ if end of dir reached, else NE
d550 1
a550 1
 TEQ    R6, #0
d555 1
a555 1
 GRABS "R5 - R11, PC", EQ                ;
d560 1
a560 1
 TEQ       r6, # 4
d570 1
a570 1
 GRABS     "r5 - r11, pc", NE                 ;
a587 4
 [ RISC_OS=2
 ADRCSL    r0, Internalerror
 BCS       Error
 |
d589 1
a589 2
 BCS       Error
 ]
d609 2
a610 2
 GRAB "R5 - R11, R14"
 BICS PC, R14, #Overflow_Flag
d627 1
a627 1
 ORREQS PC, R14, #Zero_Flag
d643 1
a643 1
 BICNES PC, R14, #Zero_Flag
d648 1
d650 1
a650 1
 ORRS PC, R14, #Zero_Flag
d716 1
a716 2
 GRAB "R0 - R4, R14", LE
 MOVLES PC, R14
a732 182
 [ RISC_OS=2

;********************************************************************
FullPathName ROUT;( RETURNS R0 -> pathname, R1 = drive number, R2 =disc number )

; uses tempbuffer_offset
; uses TempArea_offset
;********************************************************************

 STASH "R1 - R8, R14"

; R6 always -> path passed in
; R7 always = drive number
; R8 = unique disc number

 MOV R7, R1

 MOV R8, R2

 MOV R6, R0

 LDRB R1, [ R0 ]
 TEQ R1, #":"                   ; drive specified in pathname

 BNE %FT02

;**************
; Move past number to path name
; R6 -> $.fhgsj.fjfhgd
;**************

01

 LDRB R1, [ R6 ], #1
 TEQ R1, #0                   ; terminator or divider
 SUBEQ R6, R6, #1             ; Move back a pos. if end of string
 TEQNE R1, #"."               ;
 BNE %BT01


;**************
; Make sure that 'drive.\', 'drive.@@'
; give a 'bad name' error
;**************

 LDRB R1, [ R6 ]
 TEQ R1, #"\"
 TEQNE R1, #"@@"

 [ RISC_OS=2
 BEQ       badname
 |
 MOVEQ     r0, #ERROR_BADNAME
 BEQ       Error
 ]

;*************
; Copy the '$.jfhdjs.gdf' into 'tempbuffer' and make sure that the whole
; path is specified in upper case
;*************

; R0 -> start of pathname, $.FHSDHGA.GFJA

02

;03

;*************
; If lib, urd, previous, current directories were spec. then fill them in
; R6 -> $.jhjh.ghghg
; R7 = drive number
;*************


 LDRB R4, [ R6 ]              ; What is this character I see before me ?

 TEQ R4, #"$"                 ; Wonderful ! The main directory !
 BEQ fill_in_ROOT



 [ RISC_OS=2

 TEQ R4, #"&"                 ; The User Root Directory
 BEQ fill_in_URD

 TEQ R4, #"@@"                 ; The current directory
 BEQ fill_in_CSD

 TEQ R4, #"\"                 ; The previous directory
 BEQ fill_in_previous

 TEQ R4, #"%"                 ; The library directory
 BEQ fill_in_library

 B fill_in_CSD                ; Must mean current directory

 ]


;*************
; Remove the'^' ( move up branch ) from thefull string
; R0 & R4 -> start of path
;*************

Cut_rubbish

 fill_in_up_pathMacro   ; MACRO to remove '^' from path and END !

;**************
fill_in_URD
;**************
; R1 -> buffer
; R2 = drive number
; R6 -> '&.arfle.fred'



 fill_in_URDMacro      ; MACRO to remove '^' from path and END !


 B Cut_rubbish

;*******************
fill_in_CSD              ; The current directory R1 -> buffer
;*******************     ; R6 -> '&....' R2 = drive number

 fill_in_CSDMacro        ; MACRO to handle currently selected directory

 B Cut_rubbish

;******************
fill_in_parent
; This only appends '^.fks.fds' to the CSD and fill_in_upMacro deals with
; the '^' in the string
;******************
; R1 -> buffer
; R2 = drive number
; R6 -> '^.arfle.fred'


 fill_in_parentMacro

 B Cut_rubbish

;******************
fill_in_previous
;******************
; R1 -> buffer
; R2 = drive number
; R6 -> '\.arfle.fred'

 fill_in_previousMacro

 B Cut_rubbish

;********************
fill_in_library
;********************
; R1 -> buffer
; R6 -> '%.arfle.fred'
; R7 = drive number

 fill_in_libraryMacro

 B Cut_rubbish



;*******************
fill_in_ROOT             ; The ROOT directory  R1 -> start of buffer
;*******************     ; R6 -> '$....' R2 = drive number
                         ; RETURNS R0 -> new pathname


 fill_in_rootMacro


 B Cut_rubbish


 |
a758 1
 ]
d797 1
a797 1
 BVS Error
d799 1
a799 2
 GRAB "R0 - R7, R14"
 MOVS PC, R14
d834 1
a834 1
 TEQ R1, #"\"                     ; Use the old drive number ! if previous
d837 1
a837 1
 GRABS "R0, R2 - R7, PC"          ;
a845 3
 [ RISC_OS=2
 BEQ badname                     ; [ nothing ] so error
 |
d847 1
a847 2
      BEQ        Error
 ]
d871 1
a871 1
 TEQNE R2, #"\"
a873 3
 [ RISC_OS=2
 BEQ badname
 |
d875 1
a875 2
      BEQ        Error
 ]
a894 4
 [ RISC_OS=2
 addr R0, BadDrive, GT         ; Not a valid drive ( > than allowable number
 BGT Error
 |
d896 1
a896 2
     BGT         Error
 ]
d901 1
a901 1
 GRABS "R0, R2 - R7, PC"
a911 3
 [ RISC_OS=2
 BEQ badname
 |
d913 1
a913 2
       BEQ          Error
 ]
d927 1
a927 1
 GRABS "R0, R2 - R7, PC"                ; 'V' already cleared
a933 1
 BIC R14, R14, #Overflow_Flag
d984 1
a984 1
 TEQ R14, R1
d986 1
a986 1
 GRABS "R0 - R8, PC", EQ
a1007 3
 [ RISC_OS=2
 BVS discnotfound                 ; Escape pressed
 |
d1009 1
a1009 2
             BVS         Error
 ]
a1012 3
 [ RISC_OS=2
 BNE discnotfound                 ; [ yes ]
 |
d1014 1
a1014 2
             BNE         Error
 ]
d1023 1
a1023 1
 BVS Error
d1033 1
a1033 1
 SEV NE                          ;
d1054 1
a1054 1
 SEV       EQ
d1063 1
a1063 1
 SEV NE
d1175 1
a1175 1
  GRABS "R0, R2 - R8, PC", NE   ;
d1180 1
a1180 1
 GRABS "R0, R2 - R8, PC"        ;
a1186 4
 [ RISC_OS=2
 addr    R0, AmbiguousDiscNameError, NE
 BNE     Error
 |
d1191 1
a1191 2
        BNE       Error
 ]
d1200 1
a1200 1
 GRABS   "R0, R2-R8,PC"
d1233 1
a1233 96
 GRABS "R0 - R7, PC"



 [ RISC_OS=2
;********************************************************************
WildCompareStrings ROUT ; R0 -> wild carded string, R1 -> string
                        ; RETURNS VCLEAR if same, ELSE VSET
;********************************************************************

 STASH "R0 - R2, R4 - R6"

hello_wildman

 LDRB R4, [ R0 ], #1
 LDRB R3, [ R1 ], #1

 TEQ R4, #WILDANY                ; Lots of wild chars ?   '*'
 BEQ found_lots_of_chars         ; [ yes ]

 TEQ R4, #0                      ; Strings are the same
 TEQEQ R3, #0                    ;
 GRAB "R0 - R2, R4 - R6", EQ     ;
 BICEQS PC, R14, #Overflow_Flag  ; [ yes ]


 TEQ R4, R3                      ; Chars are the same ?
 TEQNE R4, #WILDCHAR             ;
                                 ;
 GRAB "R0 - R2, R4 - R6", NE     ;
 ORRNES PC, R14, #Overflow_Flag  ; [ no ]

 B hello_wildman

;************
found_lots_of_chars              ; R0-> past star, R1->string
;************

 LDRB R4, [ R0 ], #1
 TEQ R4, #0                      ; End of string, so terminate ?
 GRAB "R0 - R2, R4 - R6", EQ     ;
 BICEQS PC, R14, #Overflow_Flag  ; [ yes ]

 TEQ R4, #WILDANY                ; Followed by another '*'
 BEQ found_lots_of_chars         ;

; R0 -> wild string
; R1 -> string
; R4 = letter after *, could be '#'

find_that_char

 LDRB R3, [ R1 ], #1
 TEQ R3, #0
 GRAB "R0 - R2, R4 - R6", EQ     ; End of normal string ?
 ORREQS PC, R14, #Overflow_Flag  ; [ yes ]

 TEQ R4, #WILDCHAR
 TEQNE R3, R4
 BNE find_that_char

; R0 -> wild string
; R1 -> normal string
; R3 = normal char = R4
; R4 = wild char = R3 or '#'

 SUB R5, R0, #1
 MOV R6, R1

oh_my_word

 LDRB R4, [ R0 ], #1
 LDRB R3, [ R1 ], #1

 TEQ R4, #WILDANY                ; Another wild card
 BEQ found_lots_of_chars         ;

 TEQ R3, #0                      ; Strings terminated together
 TEQEQ R4, #0                    ;
 GRAB "R0 - R2, R4 - R6", EQ     ;
 BICEQS PC, R14, #Overflow_Flag  ; [ yes ]

 TEQ R3, #0                      ; End of either string ?
 TEQNE R4, #0                    ;
 GRAB "R0 - R2, R4 - R6", EQ     ;
 ORREQS PC, R14, #Overflow_Flag  ; [ yes ]


 TEQ R4, #WILDCHAR               ; Next part doesn't match, maybe later on ?
 TEQNE R3, R4                    ;
 LDRNEB R4, [ R5 ]               ;
 MOVNE R0, R5                    ;
 MOVNE R1, R6                    ;
 BNE find_that_char              ; [ yes ]

 B oh_my_word
a1235 1
 ] ; ONLY NEEDED FOR RISC OS 2
@


4.3
log
@This is a manual merge of CDFS 2.35 from RiscOS/UnU/OS_Core/CDFS/CDFS234
treating nturton_CDFS-2_29 as the branch point.
@
text
@d459 1
a459 4


 SWI       XCD_ByteCopy

@


4.2
log
@  Ursula branch merge, plus srccommit usage.
Detail:
  Merged Ursula branch, it just removed dynamic dependencies from
   Makefile.

  Moved to srccommit, changed lots of occurrences of "Version" to module
   version, as defined in "VersionASM".  Removed old "Version" file.
Admin:
  Added stripdepend call into clean rule.


Version 2.30. Tagged as 'CDFS-2_30'
@
text
@a95 2
 Debug " R4 = number of drives "

a107 3
 Debug " Get disc number "


a164 2
 Debug " Store R1 "

a245 2
 Debug " Next word "

a281 2
 Debug " Found right branch "

a322 2
 Debug " R0 = R11 "

a430 2
 Debug " R6 = R2 "

a445 8
 [ debug=ON
 Debug " Name found = "
 STASH R0
 MOV R0, R1
 Debug0
 GRAB R0
 ]

a451 3

 Debug " Copy TempArea "

a489 2
 Debug " Real length "

a514 2
 Debug " Buffer directory "

d559 7
d573 18
a1012 2
 Debug " FindDriveNumber "

a1106 8
 [ debug=ON
 STASH "R4,R14"
 Debug " Drive number = "
 MOV R4, R2
 DebugDisplay R4
 GRAB "R4,R14"
 ]

a1158 8
; STASH "R0-R4,R14"
; SWI &100+12
; Debug "Drive = "
; MOV R4, R1
; DebugDisplay R4
; WaitForAKey
; GRAB "R0-R4,R14"

a1184 4

 Debug " R1 != -1 "


a1190 3
 Debug " r1 = r8 "


a1202 2
 Debug " BL GetUniqueNumber "

a1303 7

 [ debug=ON
 SWI XOS_NewLine
 Debug " SET DISC CHANGED "
 SWI XOS_NewLine
 ]

a1306 4
; LDR R1, =buffer_offset
; ADD R1, R12, R1


a1361 13
 [ debug=ON
 STASH R0
 Debug " FindDiscNameInList discname = "
 Debug0
 SWI XOS_NewLine
 GRAB R0
 ]

; LDR R5, discbuffersize
; TEQ R5, #0
; MOVEQ R1, #-1
; GRABS "R0, R2 - R8, PC", EQ

a1366 7
 [ debug=ON
 STASH r4
 Debug " disc name list = &"
 MOV r4, r2
 DebugDisplay r4
 GRAB r4
 ]
a1409 2

 Debug " Not found "
a1414 2

 Debug " Found "
@


4.1
log
@Initial revision
@
text
@d60 1
a60 1
; R13 -> FD stack  
d233 1
a233 1
 
d850 1
a850 1
 
d1048 2
a1049 2
 LDRNEB R1, CurrentDriveNumber    ; 
 GRABS "R0, R2 - R7, PC"          ; 
d1141 1
a1141 1
 
d1312 1
a1312 1
 [ Version > 218
d1625 1
a1625 1
 TEQNE R3, R4                    ; 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

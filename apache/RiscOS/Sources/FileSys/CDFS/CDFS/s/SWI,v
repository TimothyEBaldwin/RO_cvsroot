head	4.18;
access;
symbols
	CDFS-2_63:4.18
	CDFS-2_62:4.18
	CDFS-2_61:4.18
	CDFS-2_60:4.17
	CDFS-2_59:4.16
	CDFS-2_58:4.16
	CDFS-2_57:4.16
	CDFS-2_56:4.16
	CDFS-2_55:4.15
	CDFS-2_54:4.15
	CDFS-2_53:4.13
	CDFS-2_52:4.11
	CDFS-2_51:4.10
	CDFS-2_50:4.10
	CDFS-2_49:4.10
	CDFS-2_48:4.10
	RO_5_07:4.9
	CDFS-2_47:4.9
	CDFS-2_46:4.9
	CDFS-2_45:4.9
	CDFS-2_44:4.9
	CDFS-2_43:4.8
	CDFS-2_42:4.8
	CDFS-2_41:4.7
	CDFS-2_40:4.6
	CDFS-2_39:4.6
	CDFS-2_38:4.6
	CDFS-2_37:4.5
	CDFS-2_35:4.4
	CDFS-2_30:4.3
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	nturton_CDFS-2_29:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_CDFS_2_28:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.18
date	2013.08.15.14.25.04;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	5ab0m7C1cVfMFy1x;

4.17
date	2013.08.15.14.13.06;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	6zDw3cu1Q3LIBy1x;

4.16
date	2012.04.22.15.48.28;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	bybtPibvH0K2zS1w;

4.15
date	2012.04.22.11.09.02;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	MNiwWuPGZIIb1R1w;

4.14
date	2012.04.22.11.04.31;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	6PVuneYjhUEDZQ1w;

4.13
date	2012.04.21.21.56.37;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	LsBEkd8YV89lDM1w;

4.12
date	2012.04.16.21.42.02;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	E6l0nP00WOBxH81w;

4.11
date	2012.04.14.20.12.38;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	7fHfwG83pDVChS0w;

4.10
date	2005.04.22.21.47.48;	author jballance;	state Exp;
branches;
next	4.9;

4.9
date	2002.11.25.16.16.58;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2002.11.22.15.14.14;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2002.11.22.15.05.40;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2002.11.04.21.21.42;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.01.20.15.29;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.01.19.47.49;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2000.11.30.11.44.22;	author jberanek;	state Exp;
branches;
next	4.2;

4.2
date	97.01.06.11.41.50;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.53;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.53;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.55.32;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.31.58;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.28.16;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.18
log
@Add support for Joliet format CD-ROMs
hdr/Hashes
s/Directory
s/EntryFile
s/FileMan
s/Filer
s/Free
 - mass search and replace of lots of poorly named definitions, removing unused ones, creating implicit ones
hdr/MyMacros
 - shuffle some registers in ConvertToArchyDate to save one temporary so it can be used for something else
 - moved ReplaceBadCharacters here
hdr/Options
 - extra debug option
s/DiscOp
 - add Joliet, rename buffer indicies per hdr/Hashes
 - the fallback filetype assignment (when neither the ARCHIMEDES system extension nor MimeMap can help) can now be overridden by setting CDFS$DefaultType (which defaults to &FFD)
s/SWI
 - remove DAT<->MPEG mapping from the internal mapping table
s/Variables
 - trim out unused SWI_buffer reservation

Tested with valid ISO/Joliet/RockRidge supported combinations, documented in Docs/Combos, and accompanying test ISO images now stored there.
Tested with CD-I format disc 'Jigsaw' from Britannica.
Tested with High Sierra format disc 'Kings Quest V'.
Tested with photo CD sampler from Kodak.

Version 2.61. Tagged as 'CDFS-2_61'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

; CDFS SWI commands in here are:

; CDFS_ConvertDriveToDevice_Code 0
; CDFS_SetBufferSize_Code        1
; CDFS_GetBufferSize_Code        2
; CDFS_SetNumberOfDrives_Code    3
; CDFS_GetNumberOfDrives_Code    4
; CDFS_GiveFileType_Code         5
; CDFS_DescribeDisc_Code         6
; CDFS_WhereIsFile_Code          7
; CDFS_Truncation_Code           8

; Tables in here:
; IBMExtensions
; ArchyFileTypes


; SWI process -

; 1. Load R12 with w/s pointer

; 2. Save all registers at start of stack

; 3. Check that SWI is a valid number ( in the range 0 to x ( < 64 ) )

; 4. Branch to proc to control that part

; 5. Terminate the proc with BICS PC, R14, #Overflow_Flag or ORRVSS PC, R14,

; IF ERROR &1E6 ( SWI ... NOT KNOWN ) THEN SUICIDE ?
; ON SWI ENTRY :
;               R11 = SWI number % 64
;               R12 = private word pointer  - USE Pull & Push 
;               R13 = supervisor stack
;               R14 = return register


;*********************************************************************
CDFSSWIentry
;*********************************************************************

        LDR     R12, [ R12 ]

        ; TURN IRQS ON
      [ No26bitCode
        CLRPSR  I_bit, R10
      |
        TEQ     PC, PC
        MVNNE   R10, #I_bit    ; R10 can safely be corrupted
        TSTNEP  R10, PC
        MRSEQ   R10, CPSR
        BICEQ   R10, R10, #I32_bit
        MSREQ   CPSR_c, R10
      ]

;**************************************************************************
;                          Check SWI Number
;**************************************************************************


        CMP     R11, #( EndSWIJumpTable - StartSWIJumpTable ) / 4
        BCS     SWITooBig

;***************************************************************************
;                    Jump table for each SWI ( very fast ) !!
;***************************************************************************

        Push    "R0 - R9, R14"

        Debug   sw,"SWI SWI"

        LDR     R14, [ PC, R11, LSL #2 ]    ; R14 corrupted !!!!!!!!!!!
        ADD     PC, PC, R14                 ;


StartSWIJumpTable

        DCD     CDFS_ConvertDriveToDevice_Code - StartSWIJumpTable - 4
        DCD     CDFS_SetBufferSize_Code - StartSWIJumpTable - 4
        DCD     CDFS_GetBufferSize_Code - StartSWIJumpTable - 4
        DCD     CDFS_SetNumberOfDrives_Code - StartSWIJumpTable - 4
        DCD     CDFS_GetNumberOfDrives_Code - StartSWIJumpTable - 4
        DCD     CDFS_GiveFileType_Code - StartSWIJumpTable - 4
        DCD     CDFS_DescribeDisc_Code - StartSWIJumpTable - 4
        DCD     CDFS_WhereIsFile_Code - StartSWIJumpTable - 4
        DCD     CDFS_Truncation_Code - StartSWIJumpTable - 4

EndSWIJumpTable

SWITooBig
        Push    "r1-r3, r14"
        addr    r0, switoobig_tag
        ADR     r1, message_block
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        Pull    "r1-r3, r14"
        TEQ     pc, pc
        MOVEQ   pc, r14
        ORRS    pc, r14, #V_bit

;***************************************************************************
;***************************************************************************
;***************************************************************************
;***************************************************************************

;**************************************************************************
;                          Do CDFS_ConvertDriveToDevice
;**************************************************************************

CDFS_ConvertDriveToDevice_Code


; on entry:
;          R0 = drive number

; on exit:
;         R0, R2 - R10 preserved
;         R1 = composite device id ( b0..b2 = device,b3..b4=card,b5..b7=LUN)
;            + drivetype ( b8 .. b15 )
;            ( b16 .. b30 RESERVED )
;         If error, for some reason, then R1 = &ffffffff ( -1 )


;****************
; First check to see if R0 >= number of drives in my list
;****************

        Debug   sw,"Convert drive"

        LDRB    R1, numberofdrives
                
        CMP     R0, R1
                
        BLHS    AnotherDriveHasBeenAdded ; RETURNS V set if error
        BVS     %FT91 ; temp hack
                
        LDRB    R1, numberofdrives
                
        CMP     R0, #0                  ; R0 > 0 and < numberofdrives ?
        RSBHSS  R14, R0, R1             ;
        BLO     %FT90

;****************
; Give the composite device id to Leonardo
;****************

        ADRL    R14, ListOfDrivesAttached
        LDRB    R1, [ R0, R14 ]
                
        ADRL    R14, DriveTypes
        LDRB    R2, [ R0, R14 ]
        ORR     R1, R1, R2, ASL #8
                
        MOV     R10, R1

        Debug   sw,"End convert"

        Pull    "R0 - R9, R14"

        MOV     R1, R10

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

90              
        Pull    "R0-R9, R14"
        MOV     R1, #-1
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

91
        ADD     sp,sp,#4
        Pull    "r1-r9,pc"

;**************************************************************************
CDFS_SetBufferSize_Code   ROUT ; R0 = bit number
;**************************************************************************

        MOV     R4, R0

;**************
; Get byte currently in CMOS RAM
;**************

        MOV     R0, #OsByte_ReadCMOS
                
        MOV     R1, #CDROMFSCMOS        ; Cmos RAM location
                
        SWI     XOS_Byte                ; R2 = contents of location


;************
; Mix byte in CMOS with number
;************

        BIC     R2, R2, #BITSUSEDBYBUFFER
                
        ORR     R2, R2, R4, ASL #BUFFERSHIFT


;************
; Store mixed byte back into CMOS
;************

        MOV     R0, #OsByte_WriteCMOS
                
        MOV     R1, #CDROMFSCMOS    
                
                                        ; R2 = number
        SWI     XOS_Byte

        Pull    "R0 - R9, R14"

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

;**************************************************************************
CDFS_GetBufferSize_Code   ROUT ; RETURNS R0 = bit number
;**************************************************************************

;**************
; Get byte currently in CMOS RAM
;**************

        MOV     R0, #OsByte_ReadCMOS
                
        MOV     R1, #CDROMFSCMOS        ; Cmos RAM location
                
        SWI     XOS_Byte                ; R2 = contents of location


;**************
; Extract the buffer value from the CMOS byte
;**************

        AND     R2, R2, #BITSUSEDBYBUFFER
                
        MOV     R2, R2, ASR #BUFFERSHIFT


        MOV     R10, R2

        Pull    "R0 - R9, R14"

        MOV     R0, R10

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

;**************************************************************************
CDFS_SetNumberOfDrives_Code  ROUT  ; R0 = number of drives
;**************************************************************************

        MOV     R4, R0

;**************
; Get byte currently in CMOS RAM
;**************

        MOV     R0, #OsByte_ReadCMOS
                
        MOV     R1, #CDROMFSCMOS        ; Cmos RAM location
                
        SWI     XOS_Byte                ; R2 = contents of location


;************
; Mix byte in CMOS with number
;************

        BIC     R2, R2, #BITSUSEDBYDRIVENUMBER
        ORR     R2, R2, R4

;************
; Store mixed byte back into CMOS
;************

        MOV     R0, #OsByte_WriteCMOS
                
        MOV     R1, #CDROMFSCMOS    
                
                                        ; R2 = number
        SWI     XOS_Byte

        Pull    "R0 - R9, R14"

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14                 
        MOVS    PC, R14                 

;**************************************************************************
CDFS_GetNumberOfDrives_Code  ROUT ; RETURNS R0 = number of drives
;**************************************************************************

;**************
; Get byte currently in CMOS RAM
;**************

        MOV     R0, #OsByte_ReadCMOS
                
        MOV     R1, #CDROMFSCMOS        ; Cmos RAM location
                
        SWI     XOS_Byte                ; RETURNS R2 = contents of location


;************
; Mix byte in CMOS with number
;************

        AND     R10, R2, #BITSUSEDBYDRIVENUMBER

        Pull    "R0 - R9, R14"

        MOV     R0, R10
                                        
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14                 
        MOVS    PC, R14                 


;**************************************************************************
CDFS_GiveFileType_Code ROUT   ; R0 -> filename, RETURNS R1 = file type or 0
;**************************************************************************

; on entry:
;          R0 -> filename ( not necc. word aligned )
; on exit:
;          R1 = file type for name ( 0 if none found ) ( 0 TO &FFF )

        MOV     R8, R0                  ; Find extension ( after dot )
        MOV     R14, #0                 ; Last dot seen ( deals with 'filename.tar.gz' )
        MOV     R10, #0                 ; Get ready to fail

find_that_dot

        LDRB    R2, [ R8 ], #1
        TEQ     R2, #"."
        MOVEQ   R14, R8
        CMP     R2, #32                 ; Allow control terminated
        BHS     find_that_dot
        
        MOVS    R8, R14                 ; No dot
        BEQ     %FT20
        
        LDRB    R1, [ R8 ]              ; A dot but nothing follows it
        CMP     R1, #32
        BLT     %FT20

        ; R8 -> extension name, ie TXT

      [ UseMimeMapTranslations
        MOV     r0,#MMM_TYPE_DOT_EXTN
        MOV     r1,r8 ; -> extension
        MOV     r2,#MMM_TYPE_RISCOS
        SWI     XMimeMap_Translate
        BVS     %FT30
        MOV     r10,r3
      |
        B       %FT30
      ]
20
        ; R10 = result
        Pull    "R0 - R9, R14"
        MOV     R1, R10
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14
30
        ; Try our lookup table
        ADR     R4, IBMExtensions
        MOV     R6, #0                  ; List index

repeat_search_for_extension

        LDRB    R1, [ R4 ]
        TEQ     R1, #0
        BEQ     %BT20                   ; Reached end of list, give up
        
        MOV     R5, R8                  ; -> extension

compare_extension_with_name             ; Compare the names with the one passed
                                        ; in
        LDRB    R2, [ R5 ], #1          ; part from name passed in
        CMP     r2,#32                  
        MOVLT   r2,#0                   


        LDRB    R1, [ R4 ], #1          ; part from list of names
        TEQ     R1, #0                  ; end of table entry?
        TEQEQ   R2, #0                  ; end user string?
        
        ADREQ   R0, ArchyFileTypes      ; Reached the end of both
        LDREQ   R10, [ R0, R6, ASL #2 ] ; Load corresponding Archy file type
        BEQ     %BT20

        ASCII_UpperCase r2, r14
        TEQ     R2, R1                  ; same
        BEQ     compare_extension_with_name

different

        TEQ     R1, #0                  ; Move to next entry in list
        LDRNEB  R1, [ R4 ], #1          ;
        BNE     different               ;
        ADD     R6, R6, #1              ; Not found
                                        ;
        B       repeat_search_for_extension

;**************************************************************************
IBMExtensions
;**************************************************************************


        ; Must be of length 4 chars ( fill with zeroes if nec. )

        DCB     "DOC", 0    ; 0
        DCB     "TXT", 0    ; 1
        DCB     "BAT", 0    ; 2
        DCB     "EXE", 0    ; 3
        DCB     "BIN", 0    ; 4
        DCB     "TIF", 0    ; 5
        DCB     "COM", 0    ; 6
        DCB     "PCD", 0    ; 7
        DCB     "MPG", 0    ; 8

        ; Insert more extensions here ( don't forget to add matching
        ;                              Archy file type below )
        ASSERT  ((. - IBMExtensions) :AND:3) = 0
        DCB     0
        ALIGN

;**************************************************************************
ArchyFileTypes
;**************************************************************************

        DCD     &AE6      ; ms-word    0
        DCD     &FFF      ; text       1
        DCD     &FDA      ; MSDOSbat   2
        DCD     &FD9      ; MSDOSexe   3
        DCD     &FFD      ; Data       4
        DCD     &FF0      ; TIFF       5
        DCD     &FD8      ; MSDOScom   6
        DCD     &be8      ; PhotoCD    7
        DCD     &BF8      ; MPEG       8

        ; Insert more Archy file types here
        ;
        DCD 0


;**************************************************************************
CDFS_DescribeDisc_Code ROUT
;**************************************************************************
; on entry:
;          R0 = drive number
;          R1 -> 64 byte block

; on exit:
;         nowt


; R9 -> 64 byte block


; 0. Is block word aligned ?

        TST     R1, #3
        BNE     swiinvalidparameter

        MOV     R9, R1


        ; Kludge any error to return

        LDR     R14, stackreturn
        Push    "R14"
        ADR     R14, return_here
        PushAllWithReturnFrame


        BL      TestKnowDisc            ; R0 = drive, RETURNS R1->buf, RETURNS R2 =disc

return_here

        STRVS   R0, swi_verytemporary
        STRVC   R1, swi_verytemporary
        PullAllFromFrame 
        LDRVC   R1, swi_verytemporary
        Pull    "R14"
        STR     R14, stackreturn

        Pull    "R0 - R9, R14", VS
        LDRVS   R0, swi_verytemporary
        TEQ     PC, PC
        TEQVC   PC, #0
        MOVEQ   PC, R14                 ; 32-bit error exit
        ORRVSS  PC, R14, #V_bit         ; 26-bit error exit

; 4. Enter details into block

        ;a. Size of disc ( 1 word )
        
        LDR     R14, [ R1, #DiscBuff_SizeOfDisc ]
                
        STR     R14, [ R9, #SIZEOFDISCOFFSETFORDESCRIBE ]

        ;b. Block size ( 1 word )
        
        LDR     R14, [ R1, #DiscBuff_BlockSize ]
                
        STR     R14, [ R9, #BLOCKSIZEOFFSETFORDESCRIBE ]

        ;c. Block number of root directory ( 1 word )
                
        LDR     R14, [ R1, #DiscBuff_LBAOfMainDir ]
                
        STR     R14, [ R9, #STARTLBAOFFSETFORDESCRIBE ]

        ;d. Disc name ( up to 32 bytes )
                
        ADD     R8, R1, #DiscBuff_DiscName
        ADD     R7, R9, #DISCNAMEOFFSETFORDESCRIBE
        ADD     R6, R7, #MAXLENGTHOFDISCNAME
01
        LDRB    R5, [ R8 ], #1
        TEQ     R5, #SPACE
        MOVEQ   R5, #0
        STRB    R5, [ R7 ], #1
                
        CMP     R7, R6
        BLE     %BT01

        ;e. Boot option ( 1 byte )
        
        MOV     R5, #0
        STRB    R5, [ R9, #BOOTOPTIONOFFSETFORDESCRIBE ]

        Pull    "R0 - R9, R14"

        ; Not grabbing the correct return registers first time around

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

;**************************************************************************
CDFS_WhereIsFile_Code  ; R0 -> pathname RETURNS R1 = block number or -1
                       ; RETURNS R2 = length in bytes of file
;**************************************************************************
;*********************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number

        ; Kludge any error to return

        ADR     R14, here
        PushAllWithReturnFrame
        
        CLRV
        
        MOV     R1, #2 ; Don't care what I find
        BL      Dir

here
        BVS     error_here

        TEQ     R2, #object_file        ; A file ?

        STREQ   R1, swi_verytemporary

        PullAllFromFrame

        Pull    "R0 - R9, R14"
        LDREQ   R10, swi_verytemporary
        LDREQ   R2, [ R10, #LENGTHOFFSET ]
        LDREQ   R1, [ R10, #LBASTARTOFFSET ]
        MOVEQ   R1, R1, LSR #8
        MOVNE   R1, #-1
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

error_here ; V is already set

        STR     R0, swi_verytemporary
        PullAllFromFrame
        Pull    "R0-R9,R14"
        LDR     R0, swi_verytemporary
        TEQ     PC, PC
        MOVEQ   PC, R14
        ORRS    PC, R14, #V_bit

;**************************************************************************
CDFS_Truncation_Code
;**************************************************************************

; on entry:
;          r0=0 THEN read current truncation type
;                    on exit:
;                            r1=current value
;               ELSE
;          r0=1
;               set truncation type
;               r1=0 then truncate from right  (default for risc os 2.00)
;               r1=1 then truncate from left
;               r1=2 then no truncation        (default for risc os 3.00 > )
;               r1=-1 then use default for os version

        TEQ     R0, #0
        Pull    "R0-R9,R14",EQ
        LDREQB  R1, truncation
        BEQ     %FT80
        
        TEQ     R0, #1
        BNE     swiinvalidparameter

        LDRB    R14, max_truncation
        CMP     R1, #-1                 ; Convert max truncation to default truncation for RISC OS version
        ANDEQ   R1, R14, #2_10          ; r14=1 or 2 convert to 0 or 2
        
        CMP     R1, #0
        RSBHSS  R3, R1, R14
        BLO     swiinvalidparameter
        
        STRB    R1, truncation

        Pull    "R0 - R9, R14"
80
        TEQ     PC, PC
        MOVEQ   PC, R14
        MOVS    PC, R14

swiinvalidparameter
        Pull    "R0-R9,R14"

        Push    "r1-r4, r14"
        addr    r0, invalidparameter_tag
        ADR     r1, message_block
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        Pull    "r1-r4, r14"
        TEQ     pc, pc
        MOVEQ   pc, r14                 ; V set by MessageTrans
        ORRS    pc, r14, #V_bit

        LTORG

        END
@


4.17
log
@Various CDFS enhancements
* Increase BGET/BPUT buffer declared to FileSwitch to 2k to match the natural sector size (FileSwitch has been able to support this since version 2.28)
* Remove local debug macros, use those from NDRDebug instead
* Change to use SETV/CLRV macros now the ones in HdrSrc are 26/32 neutral
* Clarify those situations where LBA mode is being selected by using symbol 'LBAFormat'
* Extend *WHICHDISC to allow an optional drive number to be provided (the code has existed for years, but the GSTrans flags and help denied its use)

Version 2.60. Tagged as 'CDFS-2_60'
@
text
@a443 2
        DCB     "DAT", 0    ; 9

a463 1
        DCD     &BF8      ; DATA       9 - needs to be MPEG for some discs ;-(
d522 1
a522 1
        LDR     R14, [ R1, #SIZEOFDISCOFFSETINABUFFER ]
d528 1
a528 1
        LDR     R14, [ R1, #BLOCKSIZEOFFSETINABUFFER ]
d534 1
a534 1
        LDR     R14, [ R1, #LBAOFMAINDIROFFSETINABUFFER ]
d540 1
a540 1
        ADD     R8, R1, #DISCNAMEOFFSETINABUFFER
@


4.16
log
@Fix a few bugs
When lining up the code in 2.52, a few bugs became apparent (now the source was readable).
* In a handful of places it was assumed SWIs preserved flags, these have been reordered or branched around.
* The probe of UtilityModule 2.12 has been set to 3.00 and the logic now considers >= 3.00 rather than subtracting 1 from it to deduce the default filename truncation value.
* Removed support for supplemental filetype table in CDFSNewFileTypePath$File as this has been superceded by the MimeMap module (which CDFS uses). This mirrors the behaviour of DOSFS and LanManFS which consult the MimeMap first then (small) internal table second.
* Fix stack imbalance when reading the current setting with CDFS_Truncation leading to an abort

Other changes
* When the MimeMap module is absent ".doc" is taken to be a MS Word document.
* Changed the manual loads from :INDEX: of R12 to be ADR's or ADRL's so there's less literal pool thrashing.
* Three Push/Pull sequences to restore registers swapped for LDMIA's (in Directory.s).
* Reason codes to OS_ SWIs swapped for header file names.


Version 2.56. Tagged as 'CDFS-2_56'
@
text
@d85 1
a85 1
        DebugInline " SWI SWI "
d143 1
a143 1
        DebugInline " Convert drive "
d171 1
a171 1
        DebugInline " End convert "
d583 1
a583 1
        VCLEAR
@


4.15
log
@Exchange local definitions for central ones.
Hdr:HighFSI LowFSI Services CDROM CMOS UpCall and CDFS now used in preference to local definitions.
Macro 'Command' used to build the keyword table.
Some asserts added for safety.


Version 2.54. Tagged as 'CDFS-2_54'
@
text
@d18 9
a26 9
; MyCDFS_ConvertDriveToDevice 0
; MyCDFS_SetBufferSize        1
; MyCDFS_GetBufferSize        2
; MyCDFS_SetNumberOfDrives    3
; MyCDFS_GetNumberOfDrives    4
; MyCDFS_GiveFileType         5
; MyCDFS_DescribeDisc         6
; MyCDFS_WhereIsFile          7
; MyCDFS_Truncation           8
d162 1
a162 3
        LDR     R14, =:INDEX:ListOfDrivesAttached
        ADD     R14, R14, R12
                
d165 1
a165 2
        LDR     R14, =:INDEX:DriveTypes
        ADD     R14, R14, R12
d349 3
a351 32
        Push    "R0 - R3"

;********************
; First look to see if the path to read optional info from has been set up
;********************

        ADR     R0, RedirectedFileTypes
                
        LDR     R1, =:INDEX:SWI_buffer
        ADD     R1, R1, R12
                
        MOV     R11, R1
                
        MOV     R2, #MAXLENGTHOFDISCNAME + ( MAXLENGTHOFNAME + 1 ) * MAXNUMBEROFPATHS + 4
                
        MOV     R3, #0
                
        SWI     XOS_ReadVarVal          ; system variable set ?
                                        ;
        Pull    "R0 - R3"

        BVS     no_extensions           ; [ no ]


;********************   *********************    *********************
; Read file extensions from a file instead of the mem table
;********************   *********************    *********************

; Find extension ( after dot )

        MOV     R8, R0
        MOV     R14, #0
d355 2
a356 2
        LDRB    R1, [ R8 ], #1
        TEQ     R1, #"."
d358 2
a359 2
        TEQ     R1, #0
        BNE     find_that_dot
d362 1
a362 31
        LDRNEB  R1, [ R8 ]              ; A dot but nothing follows it
        TEQNE   R1, #0                  
        Pull    "R0 - R9, R14", EQ
        MOVEQ   R1, #0                  
        BEQ     %FT80


; R6 = file type number of current name
; R7 = number of lines done
; R8 -> extension name, ie TXT
; R9 = file handle
; R10 = finish ( TRUE / FALSE )
; R11 -> SWI_buffer

                ; Look through all of file for extensions

;*****
; Copy '<CDFSFilefdgfjsa>' into SWI_buffer

        MOV     R14, #"<"
        MOV     R0, R11
        STRB    R14, [ R0 ], #1
                
        ADR     R1, RedirectedFileTypes

08

        LDRB    R14, [ R1 ], #1
        TEQ     R14, #0
        STRNEB  R14, [ R0 ], #1
        BNE     %BT08
d364 3
a366 135
        MOV     R14, #">"
        STRB    R14, [ R0 ], #1
        MOV     R14, #0
        STRB    R14, [ R0 ], #1

        MOV     R0, #&40 + 2_1100       ; OPENIN ( no writing to file necc. )
        MOV     R1, R11
        MOV     R2, #0
                
        SWI     XOS_Find                ; Path is rubbish ?

        BVS     no_extensions           ; [ yes ]
                                        ; RETURNS R0 = file handle ( or 0 if VS )

        MOV     R9, R0
                
        MOV     R10, #FALSE
        MOV     R7, #1

; ******************** Validate file extension **********************

;*******************
REPEAT_start_checks
;*******************

; R2 -> place to put next char
; R3 -> last place to put char

        MOV     R2, #namebufferexe
        ADD     R2, R11, R2

        ADD     R3, R2, #5

05

        MOV     R1, R9                  ;
        SWI     XOS_BGet                ; RETURNS R0 = byte got from file

        STRB    R0, [ R2 ], #1
                
        TEQ     R0, #SPACE
        TEQNE   R2, R3
        BNE     %BT05
                
        TEQ     R2, R3
        BEQ     %FT01
                
        MOV     R3, #0
        STRB    R3, [ R2, #-1 ]

; ******************** Validate file type **********************


; R2 -> place to put next char
; R3 -> last place to put char

        ADD     R2, R11, #numberbufferexe
                
        ADD     R3, R2, #7

06

        MOV     R1, R9                  ;
        SWI     XOS_BGet                ; RETURNS R0 = byte got from file

        STRB    R0, [ R2 ], #1
                
        TEQ     R0, #&A
        TEQNE   R2, R3
        BNE     %BT06
                
                
        TEQ     R2, R3
        BEQ     %FT01
                
        MOV     R3, #0
        STRB    R3, [ R2, #-1 ]

        DebugInline " File type "

        LDR     R0, =10+(1:SHL:29)          ; Get number from string in number buffer
        ADD     R1, R11, #numberbufferexe   ;
        MOV     R2, #&1000                  ;
        SWI     XOS_ReadUnsigned            ; RETURNS R2 = number
                
                
        MOV     R6, R2
       
        ; Compare namebuffer & entryname passed in


        MOV     R0, R8
        ADD     R1, R11, #namebufferexe


; R0 -> entryname
; R1 -> namebuffer
; R2 = byte from entry name
; R3 = byte from name buffer
; R4 = temp
; R14 = counter

        MOV     R14, #0

07

        LDRB    R2, [ R0, R14 ]
        LDRB    R3, [ R1, R14 ]
                
        CMP     R2, #32
        MOVLT   R2, #0
                
        ADD     R14, R14, #1
                
        TEQ     R2, #0
        TEQEQ   R3, #0
        BNE     %FT08
                
        MOV     R10, R6
        MOV     R0, #0                  ; Close file if found
        MOV     R1, R9                  ;
        SWI     XOS_Find                ;
                
        Pull    "R0 - R9, R14"
                
        MOV     R1, R10
        B       %FT80

08

        TEQ     R2, R3
        BEQ     %BT07

end_mems      ; R4 = TRUE / FALSE  name same

d368 1
a368 16
        ADD     R7, R7, #1              ; line = line + 1


        MOV     R0, #5                  ; EOF
        MOV     R1, R9                  ;
        SWI     XOS_Args                ; RETURNS R2 = 0 if not EOF, else EOF

        TEQVC   R2, #0
        BEQ     REPEAT_start_checks

;********************   ;********************    ;********************
; close file
;********************   ;********************    ;********************

        MOV     R0, #0
        SWI     XOS_Find
a370 1
        ; it's NOT in the file
d375 1
a375 1
        BVS     %FT55
d377 5
a381 1

d387 2
a388 37

55
      ]
        Pull    "R0 - R9, R14"
        MOV     R1, #0
        CMP     PC, PC ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

;********************   ;********************    ;********************

01

        MOV     R0, #0                  ; Close file then carry on with the internal extens
        MOV     R1, R9                  ;
        SWI     XOS_Find                ;

no_extensions

        ; 1/ Find if there is a dot in the name
        
        MOV     R3, R0
        MOV     R7, #0

find_me_the_dot                         ; Look for the last dot
        LDRB    R1, [ R3 ], #1          ;
        TEQ     R1, #"."
        MOVEQ   R7, R3
        TEQ     R1, #0
        BNE     find_me_the_dot

        MOVS    R3, R7                  ; No dot found in the name
                
        Pull    "R0 - R9, R14", EQ
        MOVEQ   R1, #0                  
        BEQ     %FT80
                
d390 1
a390 1
        MOV     R6, #0
d394 5
a398 35
        LDRB    R1, [ R4 ]              ; Reached end of list
        TEQ     R1, #0                  ;

      [ UseMimeMapTranslations
        BNE     %FT02

        ; it's NOT in the internal DB
        MOV     r0,#MMM_TYPE_DOT_EXTN
        MOV     r1,r3 ; -> extension
        MOV     r2,#MMM_TYPE_RISCOS
        SWI     XMimeMap_Translate
        BVS     %FT55
        MOV     r10,r3

        Pull    "R0 - R9, R14"
        MOV     R1, R10
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

55 ; failed
        Pull    "R0 - R9, R14"
        MOV     R1, #0                  ;
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

02
      |
        Pull    "R0 - R9, R14", EQ
        MOVEQ   R1, #0
        BEQ     %FT80
      ]

        MOV     R5, R3
d408 8
a415 3
        TEQ     R1, #0                  ; different
        TEQEQ   R2, #0                  ;
        BEQ     same                    ;
d417 1
a417 15
        BNE     different               ;
        B       compare_extension_with_name

same

        ADR     R0, ArchyFileTypes      ; Load corresponding Archy file type
        LDR     R1, [ R0, R6, ASL #2 ]  ;

        MOV     R10, R1
        Pull    "R0 - R9, R14"
        MOV     R1, R10
        CMP     PC, PC ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

a427 10

80
        CMP     PC, PC ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

RedirectedFileTypes
        DCB     "CDFSNewFileTypePath$File", 0
        ALIGN

a456 1
      [ DOCisMSWord
a457 3
      |         
        DCD     &FFF      ; text       0
      ]         
d465 2
a466 2
        DCD     &BF8      ; MPEG   8
        DCD     &BF8      ; DATA   9 - needs to be MPEG for some discs ;-(
a638 1
        
d641 2
a642 6
        ; check for risc os 3, if so then allow r1=0 to 2 else r1=0 to 1

        LDRB    R14, os_version
        SUB     R14, R14, #1            ; OK AT THE MOMENT
        
        CMP     R1, #-1                 ; Use default truncation for risc os version
d651 1
a652 1
        Pull    "R0 - R9, R14"
d667 1
a667 1
        MOVEQ   pc, r14
@


4.14
log
@Collapse old switches.
Switches from 10+ years ago removed. Demo version switch removed.

Version 2.53. Not tagged
@
text
@d18 9
a26 9
; CDFS_ConvertDriveToDevice 0
; CDFS_SetBufferSize        1
; CDFS_GetBufferSize        2
; CDFS_SetNumberOfDrives    3
; CDFS_GetNumberOfDrives    4
; CDFS_GiveFileType         5
; CDFS_DescribeDisc         6
; CDFS_WhereIsFile          7
; CDFS_Truncation           8
d93 9
a101 9
        DCD     CDFS_ConvertDriveToDevice - StartSWIJumpTable - 4
        DCD     CDFS_SetBufferSize - StartSWIJumpTable - 4
        DCD     CDFS_GetBufferSize - StartSWIJumpTable - 4
        DCD     CDFS_SetNumberOfDrives - StartSWIJumpTable - 4
        DCD     CDFS_GetNumberOfDrives - StartSWIJumpTable - 4
        DCD     CDFS_GiveFileType - StartSWIJumpTable - 4
        DCD     CDFS_DescribeDisc - StartSWIJumpTable - 4
        DCD     CDFS_WhereIsFile - StartSWIJumpTable - 4
        DCD     CDFS_Truncation - StartSWIJumpTable - 4
d114 1
a114 1
        ORRS    pc, r14, #Overflow_Flag
d125 1
a125 1
CDFS_ConvertDriveToDevice
d196 1
a196 1
CDFS_SetBufferSize   ROUT ; R0 = bit number
d207 1
a207 1
        MOV     R1, #HARDRAMLOCATION    ; Cmos RAM location
d227 1
a227 1
        MOV     R1, #HARDRAMLOCATION
d239 1
a239 1
CDFS_GetBufferSize   ROUT ; RETURNS R0 = bit number
d248 1
a248 1
        MOV     R1, #HARDRAMLOCATION    ; Cmos RAM location
d273 1
a273 1
CDFS_SetNumberOfDrives  ROUT  ; R0 = number of drives
d284 1
a284 1
        MOV     R1, #HARDRAMLOCATION    ; Cmos RAM location
d302 1
a302 1
        MOV     R1, #HARDRAMLOCATION
d314 1
a314 1
CDFS_GetNumberOfDrives  ROUT ; RETURNS R0 = number of drives
d323 1
a323 1
        MOV     R1, #HARDRAMLOCATION    ; Cmos RAM location
d344 1
a344 1
CDFS_GiveFileType ROUT   ; R0 -> filename, RETURNS R1 = file type or 0
d365 1
a365 1
        MOV     R2, #LENGTHOFDISCNAME + ( MAXLENGTHOFNAME + 1 ) * MAXNUMBEROFPATHS + 4
d759 2
a760 2
        DCD     FILETYPE__MPEG; MPEG   8
        DCD     FILETYPE__MPEG; DATA   9 - needs to be MPEG for some discs ;-(
d768 1
a768 1
CDFS_DescribeDisc ROUT
d813 1
a813 1
        ORRVSS  PC, R14, #Overflow_Flag ; 26-bit error exit
d839 1
a839 1
        ADD     R6, R7, #LENGTHOFDISCNAME
d863 2
a864 2
CDFS_WhereIsFile  ; R0 -> pathname RETURNS R1 = block number or -1
                  ; RETURNS R2 = length in bytes of file
d885 1
a885 1
        TEQ     R2, #FILE               ; A file ?
d909 1
a909 1
        ORRS    PC, R14, #Overflow_Flag
d912 1
a912 1
CDFS_Truncation
d967 1
a967 1
        ORRS    pc, r14, #Overflow_Flag
@


4.13
log
@Resolve the 32 assembler warnings
Mostly by swapping STASH/GRAB for Push/Pull macros.
Inlined the module header rather than defining it in a header file.
Renamed "Debug" macro to "DebugInline" to avoid clash with similarly named macro.

Version 2.53. Tagged as 'CDFS-2_53'
@
text
@a731 2

      [ Module_Version >= 220
a732 2
      ]

a757 2

      [ Module_Version >= 220
a758 2
      ]

@


4.12
log
@Line up sources to normal columns.
Around 25000 spaces required, but rather easier to read as a result - it has revealed some bugs (not addressed in this commit).
Not quite binary identical, because an 'addr' of the ambiguous disc name error has moved by 1 byte due to a missing ALIGN directive.
Not tagged.
@
text
@a30 3
;                 DO NOT USE GRABALL OR STASHALL !!!!!!!!!

;                 HANDLE YOUR OWN ERRORS
d45 7
d60 3
a62 1

d69 1
d83 1
a83 1
        STASH   "R0 - R9, R14"
d85 1
a85 1
        ; Debug " SWI SWI "
d106 1
a106 1
        STASH   "r1-r3, r14"
d111 1
a111 1
        GRAB    "r1-r3, r14"
d143 1
a143 1
; Debug " Convert drive "
d174 1
a174 1
        ; Debug " End convert "
d176 1
a176 1
        GRAB    "R0 - R9, R14"
d185 1
a185 1
        GRAB    "R0-R9, R14"
d193 1
a193 1
        GRAB    "r1-r9,pc"
d232 1
a232 1
        GRAB    "R0 - R9, R14"
d264 1
a264 1
        GRAB    "R0 - R9, R14"
d307 1
a307 1
        GRAB    "R0 - R9, R14"
d334 1
a334 1
        GRAB    "R0 - R9, R14"
d352 1
a352 1
        STASH   R0 - R3
d371 1
a371 1
        GRAB    R0 - R3
d396 1
a396 1
        GRAB    "R0 - R9, R14", EQ
d504 1
a504 1
        ; Debug " File type "
d549 1
a549 1
        GRAB    "R0 - R9, R14"
d588 1
a588 1
        GRAB    "R0 - R9, R14"
d596 1
a596 1
        GRAB    "R0 - R9, R14"
d626 1
a626 1
        GRAB    "R0 - R9, R14", EQ
d649 1
a649 1
        GRAB    "R0 - R9, R14"
d656 1
a656 1
        GRAB    "R0 - R9, R14"
d664 1
a664 1
        GRAB    "R0 - R9, R14", EQ
d692 1
a692 1
        GRAB    "R0 - R9, R14"
d800 1
a800 1
        STASH   R14
d802 1
a802 1
        STASHALL
d811 1
a811 1
        GRABALL 
d813 1
a813 1
        GRAB    R14
d816 1
a816 1
        GRAB    "R0 - R9, R14", VS
d862 1
a862 1
        GRAB    "R0 - R9, R14"
d883 1
a883 1
        STASHALL
d897 1
a897 1
        GRABALL
d899 1
a899 1
        GRAB    "R0 - R9, R14"
d912 2
a913 2
        GRABALL
        GRAB    "R0-R9,R14"
d936 1
a936 1
        GRAB    "R0-R9,R14",EQ
d959 1
a959 1
        GRAB    "R0 - R9, R14"
d965 1
a965 1
        GRAB "R0-R9,R14"
d967 1
a967 1
        STASH   "r1-r4, r14"
d972 1
a972 1
        GRAB    "r1-r4, r14"
@


4.11
log
@Updated to use Hdr:MimeMap
Some explicit single register LDM/STM changed to LDR/STR equivalents

Version 2.52. Tagged as 'CDFS-2_52'
@
text
@d53 1
a53 1
 LDR R12, [ R12 ]
d55 1
a55 1
; TURN IRQS ON
d57 6
a62 8
 TEQ PC, PC
 MVNNE R10, #I_bit    ; R10 can safely be corrupted
 TSTNEP R10, PC
 MRSEQ R10, CPSR
 BICEQ R10, R10, #I32_bit
 MSREQ CPSR_c, R10

; SWI_STASHALL
d69 2
a70 2
 CMP R11, #( EndSWIJumpTable - StartSWIJumpTable ) / 4
 BCS SWITooBig
d76 1
a76 1
 STASH "R0 - R9, R14"
d78 1
a78 1
; Debug " SWI SWI "
d80 2
a81 2
 LDR R14, [ PC, R11, LSL #2 ]    ; R14 corrupted !!!!!!!!!!!
 ADD PC, PC, R14                 ;
d86 9
a94 9
 DCD CDFS_ConvertDriveToDevice - StartSWIJumpTable - 4
 DCD CDFS_SetBufferSize - StartSWIJumpTable - 4
 DCD CDFS_GetBufferSize - StartSWIJumpTable - 4
 DCD CDFS_SetNumberOfDrives - StartSWIJumpTable - 4
 DCD CDFS_GetNumberOfDrives - StartSWIJumpTable - 4
 DCD CDFS_GiveFileType - StartSWIJumpTable - 4
 DCD CDFS_DescribeDisc - StartSWIJumpTable - 4
 DCD CDFS_WhereIsFile - StartSWIJumpTable - 4
 DCD CDFS_Truncation - StartSWIJumpTable - 4
d99 9
a107 9
        STASH     "r1-r3, r14"
        addr      r0, switoobig_tag
        ADR       r1, message_block
        MOV       r2, #0
        SWI       XMessageTrans_ErrorLookup
        GRAB      "r1-r3, r14"
        TEQ       pc, pc
        MOVEQ     pc, r14
        ORRS      pc, r14, #Overflow_Flag
d138 12
a149 12
 LDRB R1, numberofdrives

 CMP R0, R1

 BLHS AnotherDriveHasBeenAdded    ; RETURNS V set if error
 BVS %FT91 ; temp hack

 LDRB R1, numberofdrives

 CMP R0, #0                       ; R0 > 0 and < numberofdrives ?
 RSBHSS R14, R0, R1               ;
 BLO %FT90
d155 32
a186 35
 LDR R14, =:INDEX:ListOfDrivesAttached
 ADD R14, R14, R12

 LDRB R1, [ R0, R14 ]

 LDR R14, =:INDEX:DriveTypes
 ADD R14, R14, R12
 LDRB R2, [ R0, R14 ]
 ORR R1, R1, R2, ASL #8

; STR R1, swi_verytemporary
 MOV R10, R1

; SWI_GRABALL

; Debug " End convert "

 GRAB "R0 - R9, R14"

; LDR R1, swi_verytemporary
 MOV R1, R10

 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14

90
 GRAB "R0-R9, R14"
 MOV R1, #-1
 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14

91 ADD sp,sp,#4
 GRAB "r1-r9,pc"
d192 1
a192 1
 MOV R4, R0
d198 5
a202 7
 MOV R0, #OsByte_ReadCMOS

 MOV R1, #HARDRAMLOCATION    ; Cmos RAM location

 SWI XOS_Byte                ; R2 = contents of location

; BVS SWI_Error
d209 3
a211 3
 BIC R2, R2, #BITSUSEDBYBUFFER

 ORR R2, R2, R4, ASL #BUFFERSHIFT
d218 12
a229 17
 MOV R0, #OsByte_WriteCMOS

 MOV R1, #HARDRAMLOCATION

                             ; R2 = number
 SWI XOS_Byte

; BVS SWI_Error



; SWI_GRABALL
 GRAB "R0 - R9, R14"

 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d239 5
a243 7
 MOV R0, #OsByte_ReadCMOS

 MOV R1, #HARDRAMLOCATION    ; Cmos RAM location

 SWI XOS_Byte                ; R2 = contents of location

; BVS SWI_Error
d250 3
a252 3
 AND R2, R2, #BITSUSEDBYBUFFER

 MOV R2, R2, ASR #BUFFERSHIFT
d255 1
a255 2
; STR R2, swi_verytemporary
 MOV R10, R2
d257 1
a257 1
; SWI_GRABALL
d259 1
a259 1
 GRAB "R0 - R9, R14"
d261 3
a263 6
; LDR R0, swi_verytemporary
 MOV R0, R10

 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d269 1
a269 1
 MOV R4, R0
d275 5
a279 7
 MOV R0, #OsByte_ReadCMOS

 MOV R1, #HARDRAMLOCATION    ; Cmos RAM location

 SWI XOS_Byte                ; R2 = contents of location

; BVS SWI_Error
d286 2
a287 2
 BIC R2, R2, #BITSUSEDBYDRIVENUMBER
 ORR R2, R2, R4
d293 12
a304 18
 MOV R0, #OsByte_WriteCMOS

 MOV R1, #HARDRAMLOCATION

                             ; R2 = number
 SWI XOS_Byte

; BVS SWI_Error



; SWI_GRABALL

 GRAB "R0 - R9, R14"

 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d314 5
a318 7
 MOV R0, #OsByte_ReadCMOS

 MOV R1, #HARDRAMLOCATION    ; Cmos RAM location

 SWI XOS_Byte                ; RETURNS R2 = contents of location

; BVS SWI_Error
d325 1
a325 8
; AND R2, R2, #BITSUSEDBYDRIVENUMBER

; STR R2, swi_verytemporary

 AND R10, R2, #BITSUSEDBYDRIVENUMBER

; SWI_GRABALL
 GRAB "R0 - R9, R14"
d327 1
a327 2
; LDR R0, swi_verytemporary
 MOV R0, R10
d329 5
a333 3
 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d345 1
a345 1
 STASH R0 - R3
d351 14
a364 1
 ADR R0, RedirectedFileTypes
d366 1
a366 14
 LDR R1, =:INDEX:SWI_buffer
 ADD R1, R1, R12

 MOV R11, R1

 MOV R2, #LENGTHOFDISCNAME + ( MAXLENGTHOFNAME + 1 ) * MAXNUMBEROFPATHS + 4

 MOV R3, #0

 SWI XOS_ReadVarVal         ; system variable set ?
                            ;
 GRAB R0 - R3

 BVS no_extensions          ; [ no ]
d375 2
a376 2
 MOV R8, R0
 MOV R14, #0
d380 12
a391 13
 LDRB R1, [ R8 ], #1
 TEQ R1, #"."
 MOVEQ R14, R8
 TEQ   R1, #0
 BNE find_that_dot

 MOVS R8, R14                       ; No dot
 LDRNEB R1, [ R8 ]                  ; A dot but nothing follows it
 TEQNE R1, #0                       ;
; SWI_GRABALL EQ                     ;
 GRAB "R0 - R9, R14", EQ
 MOVEQ R1, #0                       ;
 BEQ %FT80
d406 5
a410 5
 MOV R14, #"<"
 MOV R0, R11
 STRB R14, [ R0 ], #1

 ADR R1, RedirectedFileTypes
d414 23
a436 29
 LDRB R14, [ R1 ], #1
 TEQ R14, #0
 STRNEB R14, [ R0 ], #1
 BNE %BT08

 MOV R14, #">"
 STRB R14, [ R0 ], #1
 MOV R14, #0
 STRB R14, [ R0 ], #1

; Debug "Hi "

;*****

 MOV R0, #&40 + 2_1100          ; OPENIN ( no writing to file necc. )
 MOV R1, R11
 MOV R2, #0

 SWI XOS_Find                   ; Path is rubbish ?
                                ;
 BVS no_extensions              ; [ yes ]
                                ; RETURNS R0 = file handle ( or 0 if VS )

; Debug " Good handle "

 MOV R9, R0

 MOV R10, #FALSE
 MOV R7, #1
d447 2
a448 2
 MOV R2, #namebufferexe
 ADD R2, R11, R2
d450 1
a450 1
 ADD R3, R2, #5
d454 2
a455 4
 MOV R1, R9             ;
 SWI XOS_BGet           ; RETURNS R0 = byte got from file

; BVS SWI_Error
d457 11
a467 13
 STRB R0, [ R2 ], #1

 TEQ R0, #SPACE
 TEQNE R2, R3
 BNE %BT05

; Debug " Go byte "

 TEQ R2, R3
 BEQ %FT01

 MOV R3, #0
 STRB R3, [ R2, #-1 ]
d475 3
a477 3
 ADD R2, R11, #numberbufferexe

 ADD R3, R2, #7
d481 2
a482 10
 MOV R1, R9             ;
 SWI XOS_BGet           ; RETURNS R0 = byte got from file

; BVS SWI_Error

 STRB R0, [ R2 ], #1

 TEQ R0, #&A
 TEQNE R2, R3
 BNE %BT06
d484 24
a508 2
 TEQ R2, R3
 BEQ %FT01
d510 2
a511 18
 MOV R3, #0
 STRB R3, [ R2, #-1 ]

; Debug " File type "

 LDR R0, =10+(1:SHL:29)          ; Get number from string in number buffer
 ADD R1, R11, #numberbufferexe   ;
 MOV R2, #&1000                  ;
 SWI XOS_ReadUnsigned            ; RETURNS R2 = number


 MOV R6, R2

; Compare namebuffer & entryname passed in


 MOV R0, R8
 ADD R1, R11, #namebufferexe
d521 1
a521 1
 MOV R14, #0
d525 21
a545 28
 LDRB R2, [ R0, R14 ]
 LDRB R3, [ R1, R14 ]

 CMP R2, #32
 MOVLT R2, #0
; UpperCase R2, R4
; UpperCase R3, R4

; STASH "R0, R14"
; MOV R0, R3
; SWI XOS_WriteC
; GRAB "R0, R14"

 ADD R14, R14, #1

 TEQ R2, #0
 TEQEQ R3, #0
 BNE %FT08
; STR R6, swi_verytemporary        ;
 MOV R10, R6
 MOV R0, #0                       ; Close file if found
 MOV R1, R9                       ;
 SWI XOS_Find                     ;
; SWI_GRABALL                      ;
 GRAB "R0 - R9, R14"
; LDR R1, swi_verytemporary        ;
 MOV R1, R10
 B %FT80
d549 2
a550 2
 TEQ R2, R3
 BEQ %BT07
d555 1
a555 1
 ADD R7, R7, #1        ; line = line + 1
d558 3
a560 3
 MOV R0, #5                           ; EOF
 MOV R1, R9                           ;
 SWI XOS_Args                         ; RETURNS R2 = 0 if not EOF, else EOF
d562 2
a563 2
 TEQVC R2, #0
 BEQ REPEAT_start_checks
d569 17
a585 18
 MOV R0, #0
; MOV R1, R9
 SWI XOS_Find

 [ UseMimeMapTranslations
; it's NOT in the file
 MOV r0,#MMM_TYPE_DOT_EXTN
 MOV r1,r8 ; -> extension
 MOV r2,#MMM_TYPE_RISCOS
 SWI XMimeMap_Translate
 BVS %FT55
 MOV r10,r3

 GRAB "R0 - R9, R14"
 MOV R1, R10
 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d588 6
a593 6
 ]
 GRAB "R0 - R9, R14"
 MOV R1, #0
 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d599 3
a601 3
 MOV R0, #0              ; Close file then carry on with the internal extens
 MOV R1, R9              ;
 SWI XOS_Find            ;
d605 20
a624 20
 ; 1/ Find if there is a dot in the name

 MOV R3, R0
 MOV R7, #0

find_me_the_dot                    ; Look for the last dot
 LDRB R1, [ R3 ], #1               ;
 TEQ R1, #"."
 MOVEQ R7, R3
 TEQ R1, #0
 BNE find_me_the_dot

 MOVS R3, R7                       ; No dot found in the name
; SWI_GRABALL EQ                    ;
 GRAB "R0 - R9, R14", EQ
 MOVEQ R1, #0                      ;
 BEQ %FT80

 ADR R4, IBMExtensions
 MOV R6, #0
d628 2
a629 2
 LDRB R1, [ R4 ]                   ; Reached end of list
 TEQ R1, #0                        ;
d631 2
a632 2
 [ UseMimeMapTranslations
 BNE %FT02
d634 13
a646 13
; it's NOT in the internal DB
 MOV r0,#MMM_TYPE_DOT_EXTN
 MOV r1,r3 ; -> extension
 MOV r2,#MMM_TYPE_RISCOS
 SWI XMimeMap_Translate
 BVS %FT55
 MOV r10,r3

 GRAB "R0 - R9, R14"
 MOV R1, R10
 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d649 5
a653 5
 GRAB "R0 - R9, R14"
 MOV  R1, #0                     ;
 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d656 22
a677 24
 |
 GRAB "R0 - R9, R14", EQ
 MOVEQ R1, #0                      ;
 BEQ %FT80
 ]

 MOV R5, R3

compare_extension_with_name        ; Compare the names with the one passed
                                   ; in
 LDRB R2, [ R5 ], #1               ; part from name passed in
 CMP  r2,#32
 MOVLT r2,#0

; UpperCase R2, R14           ; characters 'a - z' converted to upper case


 LDRB R1, [ R4 ], #1               ; part from list of names
 TEQ R1, #0                        ; different
 TEQEQ R2, #0                      ;
 BEQ same                          ;
 TEQ R2, R1                        ; same
 BNE different                     ;
 B   compare_extension_with_name
d681 2
a682 2
 ADR R0, ArchyFileTypes         ; Load corresponding Archy file type
 LDR R1, [ R0, R6, ASL #2 ]      ;
d684 6
a689 9
; STR R1, swi_verytemporary           ;
 MOV R10, R1
; SWI_GRABALL                         ;
 GRAB "R0 - R9, R14"
; LDR R1, swi_verytemporary           ; Matched
 MOV R1, R10
 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d694 6
a699 7
 TEQ R1, #0                        ; Move to next entry in list
 LDRNEB R1, [ R4 ], #1             ;
 BNE different                     ;

 ADD R6, R6, #1                    ; Not found
                                   ;
 B repeat_search_for_extension     ;
d703 7
a709 7
 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14

RedirectedFileTypes = "CDFSNewFileTypePath$File", 0

 ALIGN
d716 1
a716 13
 ; Must be of length 4 chars ( fill with zeroes if nec. )

 = "DOC", 0    ; 0
 = "TXT", 0    ; 1
 = "BAT", 0    ; 2
 = "EXE", 0    ; 3
 = "BIN", 0    ; 4
 = "TIF", 0    ; 5
 = "COM", 0    ; 6

 [ Module_Version >= 220
 = "PCD", 0    ; 7
 ]
d718 21
a738 9
 = "MPG", 0    ; 8
 = "DAT", 0    ; 9

               ; Insert more extensions here ( don't forget to add matching
               ;                              Archy file type below )

 = 0

 ALIGN
d744 22
a765 22
 [ DOCisMSWord
 DCD &AE6      ; ms-word    0
 |
 DCD &FFF      ; text       0
 ]
 DCD &FFF      ; text       1
 DCD &FDA      ; MSDOSbat   2
 DCD &FD9      ; MSDOSexe   3
 DCD &FFD      ; Data       4
 DCD &FF0      ; TIFF       5
 DCD &FD8      ; MSDOScom   6

 [ Module_Version >= 220
 DCD &be8      ; PhotoCD    7
 ]

 DCD FILETYPE__MPEG; MPEG   8
 DCD FILETYPE__MPEG; DATA   9 - needs to be MPEG for some discs ;-(

               ; Add Archy file types here

 DCD 0
d784 2
a785 5
 TST R1, #3
; GRAB "R0 - R9, R14", NE
; ADRNEL R0, InvalidParameter
; ORRNES PC, R14, #Overflow_Flag
 BNE swiinvalidparameter
d787 1
a787 1
 MOV R9, R1
d790 1
a790 1
; Kludge any error to return
d792 4
a795 4
 LDR R14, stackreturn
 STASH R14
 ADR R14, return_here
 STASHALL
d798 1
a798 1
 BL TestKnowDisc             ; R0 = drive, RETURNS R1->buf, RETURNS R2 =disc
d802 13
a814 13
 STRVS R0, swi_verytemporary
 STRVC R1, swi_verytemporary
 GRABALL
 LDRVC R1, swi_verytemporary
 GRAB R14
 STR R14, stackreturn

 GRAB "R0 - R9, R14", VS
 LDRVS R0, swi_verytemporary
 TEQ PC, PC
 TEQVC PC, #0
 MOVEQ PC, R14                  ; 32-bit error exit
 ORRVSS PC, R14, #Overflow_Flag ; 26-bit error exit
d818 23
a840 24
 ;a. Size of disc ( 1 word )

 LDR R14, [ R1, #SIZEOFDISCOFFSETINABUFFER ]

 STR R14, [ R9, #SIZEOFDISCOFFSETFORDESCRIBE ]

 ;b. Block size ( 1 word )

 LDR R14, [ R1, #BLOCKSIZEOFFSETINABUFFER ]

 STR R14, [ R9, #BLOCKSIZEOFFSETFORDESCRIBE ]

 ;c. Block number of root directory ( 1 word )

 LDR R14, [ R1, #LBAOFMAINDIROFFSETINABUFFER ]

 STR R14, [ R9, #STARTLBAOFFSETFORDESCRIBE ]

 ;d. Disc name ( up to 32 bytes )

 ADD R8, R1, #DISCNAMEOFFSETINABUFFER
 ADD R7, R9, #DISCNAMEOFFSETFORDESCRIBE
 ADD R6, R7, #LENGTHOFDISCNAME

d842 20
a861 22


 LDRB R5, [ R8 ], #1
 TEQ R5, #SPACE
 MOVEQ R5, #0
 STRB R5, [ R7 ], #1

 CMP R7, R6
 BLE %BT01

 ;e. Boot option ( 1 byte )

 MOV R5, #0
 STRB R5, [ R9, #BOOTOPTIONOFFSETFORDESCRIBE ]

 GRAB "R0 - R9, R14"

; Not grabbing the correct return registers first time around

 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d873 1
a873 6
; Kludge any error to return

 ADR R14, here
 STASHALL

 VCLEAR
d875 7
a881 3
 MOV R1, #2 ; Don't care what I find
 BL Dir
;*********************
d884 1
a884 1
 BVS     error_here
d886 1
a886 1
 TEQ R2, #FILE                     ; A file ?
d888 1
a888 1
 STREQ     R1, swi_verytemporary
d890 1
a890 1
 GRABALL
d892 9
a900 9
 GRAB "R0 - R9, R14"
 LDREQ R10, swi_verytemporary
 LDREQ R2, [ R10, #LENGTHOFFSET ]
 LDREQ R1, [ R10, #LBASTARTOFFSET ]
 MOVEQ R1, R1, LSR #8
 MOVNE R1, #-1
 CMP PC, PC ; clears V in 32-bit mode
 MOVEQ PC, R14
 MOVS PC, R14
d904 8
a911 7
 STR     R0, swi_verytemporary
 GRABALL
 GRAB    "R0-R9,R14"
 LDR     R0, swi_verytemporary
 TEQ     PC, PC
 MOVEQ   PC, R14
 ORRS    PC, R14, #Overflow_Flag
d928 22
a949 22
 TEQ R0, #0
 GRAB "R0-R9,R14",EQ
 LDREQB R1, truncation
 BEQ %FT80

 TEQ R0, #1

 BNE swiinvalidparameter

; check for risc os 3, if so then allow r1=0 to 2 else r1=0 to 1

 LDRB R14, os_version
 SUB R14, R14, #1      ; OK AT THE MOMENT

 CMP R1, #-1            ; Use default truncation for risc os version
 ANDEQ R1, R14, #2_10      ; r14=1 or 2 convert to 0 or 2

 CMP R1, #0
 RSBHSS R3, R1, R14
 BLO swiinvalidparameter

 STRB R1, truncation
d952 4
a955 4
 GRAB "R0 - R9, R14"
 TEQ PC, PC
 MOVEQ PC, R14
 MOVS PC, R14
d958 1
a958 11
 GRAB "R0-R9,R14"

            STASH      "r1-r4, r14"
            addr       r0, invalidparameter_tag
            ADR        r1, message_block
            MOV        r2, #0
            SWI        XMessageTrans_ErrorLookup
            GRAB       "r1-r4, r14"
            TEQ        pc, pc
            MOVEQ      pc, r14
            ORRS       pc, r14, #Overflow_Flag
d960 9
a968 1
;**************************************************************************
d970 1
a970 1
 LTORG
d972 1
a972 1
 END
@


4.10
log
@     	Added RockRidge name extension to CDFS and removed
	the 'force uppercase' constraint to render it
	more user friendly.
Detail:
Admin:  castle added IP .. tested at castle.


Version 2.48. Tagged as 'CDFS-2_48'
@
text
@d203 1
a203 1
 MOV R0, #161                ; Reason code              FOR GET
d225 1
a225 1
 MOV R0, #162                ;  (reason code )          FOR PUT
d251 1
a251 1
 MOV R0, #161                ; Reason code              FOR GET
d293 1
a293 1
 MOV R0, #161                ; Reason code              FOR GET
d313 1
a313 1
 MOV R0, #162                ;  (reason code )          FOR PUT
d340 1
a340 1
 MOV R0, #161                ; Reason code              FOR GET
@


4.9
log
@  Some more bugfixes.
Detail:
  * Return registers for FSEntry_Func 14, 15 and 19 were getting corrupted
    due to stack manipulations, resulting in aborts inside FileSwitch
    whe enumerating some directories
  * Fixed an assumption of flag preservation across the PromptForDisc
    routine (the one that does UpCalls) that led initially to aborts (fixed
    by some top-bit-set safety measures), then later to bogus "CD-ROM drive
    not known" errors when accessig an object on a CD not currently in a
    drive
Admin:
  Tested on Tungsten.

Version 2.44. Tagged as 'CDFS-2_44'
@
text
@d577 2
a578 2
 UpperCase R2, R4
 UpperCase R3, R4
d725 1
a725 1
 UpperCase R2, R14           ; characters 'a - z' converted to upper case
@


4.8
log
@Fixed long-running problems (ie totally non-functionality) of filename
extension mapping. Built-in mappings and file-based mappings now work (and
the module will go on to look at MimeMap if those fail, with ROL's changes).

Version 2.42. Tagged as 'CDFS-2_42'
@
text
@d144 1
a144 1
 BLGE AnotherDriveHasBeenAdded    ; RETURNS V set if error
@


4.7
log
@  A few fixes.
Detail:
  * Fixed a couple of top-bit-set pointer problems
  * Fixed a couple of places where it was assumed that SWIs preserved flags
  * Uses kernel internationalisation for command help, so full tokenisation
    now works properly
  * Added NdrDebug support
Admin:
  Tested on Tungsten.

Version 2.41. Tagged as 'CDFS-2_41'
@
text
@d410 1
d415 3
a417 3
 TEQ R1, #DOT
 TEQNE R1, #0

d420 1
a420 1
 TEQ R1, #0                         ; No dot
d575 4
d589 13
a601 10
; STREQ R6, swi_verytemporary      ;
 MOVEQ R10, R6
 MOVEQ R0, #0                     ; Close file if found
 MOVEQ R1, R9                     ;
 SWIEQ XOS_Find                   ;
; SWI_GRABALL EQ                   ;
 GRAB "R0 - R9, R14", EQ
; LDREQ R1, swi_verytemporary      ;
 MOVEQ R1, R10
 BEQ %FT80
d663 1
d665 1
a665 1
find_me_the_dot                    ; Look for the dot
d667 6
a672 1
 TEQ R1, #0                        ; No dot found in the name
a676 15
 TEQ R1, #"."                      ;
 BNE find_me_the_dot               ;

 MOV R7, R3

find_me_the_end                    ; Find end of name passed in
 LDRB R1, [ R7 ], #1               ;
 TEQ R1, #0                        ;
 BNE find_me_the_end               ;

 SUB R6, R7, R3
 CMP R6, #4                        ; Last char might have been the dot
 GRAB "R0 - R9, R14", GT
 MOVGT R1, #0                      ;
 BGT %FT80
a680 2
 SUB R7, R7, #1

d734 1
a734 3
 TEQ r5,r7
 BNE compare_extension_with_name
 B   different
@


4.6
log
@  Lots of changes for RISC OS 5.
Detail:
  * Updated to use objasm, shared makefiles and global headers
  * Ripped out lots of RISC OS 2 support code so we can see the wood for the
    trees now
  * 32-bit compatible (a bit of a slog)
  * Now has its own resources phase, replacing the use of the CDFSResources
    module. Also means that messages can now be tokenised properly. For
    good measure, split out CmdHelp tokens into separate file
  * Hopefully fixed more bugs along the way than I introduced. I've seen
    lots of nasty stack imbalances in error cases, but not fixed all of
    them, I'm afraid
Admin:
  Tested briefly on a Risc PC; not enough support modules to run on Tungsten
  yet.

Version 2.38. Tagged as 'CDFS-2_38'
@
text
@d80 1
a80 1
 Debug " SWI SWI "
d138 1
a138 1
 Debug " Convert drive "
d145 1
a145 1
 BVS %FT90
d172 1
a172 1
 Debug " End convert "
d190 3
d458 1
a458 1
 Debug "Hi "
d471 1
a471 1
 Debug " Good handle "
d505 1
a505 1
 Debug " Go byte "
d543 1
a543 1
 Debug " File type "
@


4.5
log
@Manual merge of the RISC OS 4.02 version of CDFS (2.37, based upon Acorn's
RiscOS/UnU/OS_Core/FileSys/CDFS/CDFS234 version 2.35).

Tagged as 'CDFS-2_37'
@
text
@a47 6
 [ RISC_OS=2
switoobig DCD &1E6
            = "Unknown CDFS operation", 0
 ALIGN
 ]

d57 6
a62 2
 MVN R10, #I_bit    ; R10 can safely be corrupted
 TSTP R10, PC
d72 1
a72 13

 [ RISC_OS=2
 addr R0, switoobig, GT
 ORRGTS PC, R14, #Overflow_Flag
 |
        STASH     "r1-r3, r14", GT
        addr      r0, switoobig_tag, GT
        ADRGT     r1, message_block
        MOVGT     r2, #0
        SWIGT     XMessageTrans_ErrorLookup
        GRAB      "r1-r3, r14", GT
        ORRGTS    pc, r14, #Overflow_Flag
 ]
d100 10
d145 1
a145 4

 GRAB "R0 - R9, R14", VS          ; Error from drive search
 MOVVS R1, #-1                    ;
 BICVSS PC, R14, #Overflow_Flag   ;
d151 1
a151 3
 GRAB "R0 - R9, R14", LO          ;
 MOVLO R1, #-1                    ;
 BICLOS PC, R14, #Overflow_Flag   ;
d179 10
a188 1
 BICS PC, R14, #Overflow_Flag
d236 3
a238 1
 BICS PC, R14, #Overflow_Flag
d276 3
a278 1
 BICS PC, R14, #Overflow_Flag
d325 3
a327 1
 BICS PC, R14, #Overflow_Flag
d362 3
a364 1
 BICS PC, R14, #Overflow_Flag
d422 1
a422 1
 BICEQS PC, R14, #Overflow_Flag     ;
d590 1
a590 1
 BICEQS PC, R14, #Overflow_Flag   ;
d627 3
a629 1
 BICS PC, R14, #Overflow_Flag   ; return without VS
d635 3
a637 1
 BICS PC, R14, #Overflow_Flag
d659 1
a659 1
 BICEQS PC, R14, #Overflow_Flag    ;
d674 1
a674 1
 BICGTS PC, R14, #Overflow_Flag    ;
d699 3
a701 1
 BICS PC, R14, #Overflow_Flag   ; return without VS
d706 3
a708 1
 BICS PC, R14, #Overflow_Flag    ;
d714 1
a714 1
 BICEQS PC, R14, #Overflow_Flag    ;
d749 3
a751 1
 BICS PC, R14, #Overflow_Flag        ;
d765 5
d877 4
a880 1
 ORRVSS PC, R14, #Overflow_Flag
d928 3
a930 1
 BICS PC, R14, #Overflow_Flag
d947 1
a947 1
 CLV
d968 3
a970 1
 BICS PC, R14, #Overflow_Flag
d972 1
a972 1
error_here
d978 2
d1000 1
a1000 1
 BICEQS PC, R14, #Overflow_Flag ; doesn't hurt
d1020 5
a1024 1
 GRABS "R0 - R9, PC"
a1028 4
 [ RISC_OS=2
 addr R0, InvalidParameter
 ORRS PC, R14, #Overflow_Flag
 |
d1035 2
a1037 1
 ]
@


4.4
log
@This is a manual merge of CDFS 2.35 from RiscOS/UnU/OS_Core/CDFS/CDFS234
treating nturton_CDFS-2_29 as the branch point.
@
text
@d608 15
a622 1
; SWI_GRABALL
d658 5
a662 7
 ADD R6, R3, #3

 CMP R7, R6                        ; Last char might have been the dot
; SWI_GRABALL LE                    ;
 GRAB "R0 - R9, R14", LE
 MOVLE R1, #0                      ;
 BICLES PC, R14, #Overflow_Flag    ;
d673 23
a695 1
; SWI_GRABALL EQ                    ;
d699 1
d706 2
d718 1
a718 1
 TEQ R5, R7                        ;
d720 1
d784 3
d788 1
d801 1
a801 1
 DCD FILETYPE__MPEG; MPEG   9
@


4.3
log
@  Ursula branch merge, plus srccommit usage.
Detail:
  Merged Ursula branch, it just removed dynamic dependencies from
   Makefile.

  Moved to srccommit, changed lots of occurrences of "Version" to module
   version, as defined in "VersionASM".  Removed old "Version" file.
Admin:
  Added stripdepend call into clean rule.


Version 2.30. Tagged as 'CDFS-2_30'
@
text
@a727 3
               ; Insert more extensions here ( don't forget to add matching
               ;                              Archy file type below )

d732 6
a753 2
               ; Add Archy file types here

d755 1
a755 1
 DCD &be8      ; PhotoCD
d757 5
@


4.2
log
@RiscOS 3.70 version taken
@
text
@d731 1
a731 1
 [ Version >= 220
d753 1
a753 1
 [ Version >= 220
@


4.1
log
@Initial revision
@
text
@d581 1
a581 1
 MOVEQ R10, R1
d709 1
a709 1
RedirectedFileTypes = "CDFSNewFileTypePath$File"
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d581 1
a581 1
 MOVEQ R1, R10
d709 1
a709 1
RedirectedFileTypes = "CDFSNewFileTypePath$File", 0
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

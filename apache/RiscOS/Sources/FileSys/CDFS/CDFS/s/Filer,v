head	4.17;
access;
symbols
	CDFS-2_63:4.17
	CDFS-2_62:4.17
	CDFS-2_61:4.17
	CDFS-2_60:4.16
	CDFS-2_59:4.15
	CDFS-2_58:4.15
	CDFS-2_57:4.15
	CDFS-2_56:4.14
	CDFS-2_55:4.13
	CDFS-2_54:4.13
	CDFS-2_53:4.11
	CDFS-2_52:4.9
	CDFS-2_51:4.9
	CDFS-2_50:4.9
	CDFS-2_49:4.9
	CDFS-2_48:4.9
	RO_5_07:4.9
	CDFS-2_47:4.9
	CDFS-2_46:4.9
	CDFS-2_45:4.8
	CDFS-2_44:4.7
	CDFS-2_43:4.6
	CDFS-2_42:4.6
	CDFS-2_41:4.6
	CDFS-2_40:4.5
	CDFS-2_39:4.5
	CDFS-2_38:4.5
	CDFS-2_37:4.4
	CDFS-2_35:4.3
	CDFS-2_30:4.2
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	nturton_CDFS-2_29:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_CDFS_2_28:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.17
date	2013.08.15.14.25.03;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	5ab0m7C1cVfMFy1x;

4.16
date	2013.08.15.14.13.05;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	6zDw3cu1Q3LIBy1x;

4.15
date	2013.03.29.11.04.32;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	LFLy3SDDryC52GJw;

4.14
date	2012.04.22.15.48.27;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	bybtPibvH0K2zS1w;

4.13
date	2012.04.22.11.09.02;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	MNiwWuPGZIIb1R1w;

4.12
date	2012.04.22.11.04.31;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	6PVuneYjhUEDZQ1w;

4.11
date	2012.04.21.21.56.37;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	LsBEkd8YV89lDM1w;

4.10
date	2012.04.16.21.42.01;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	E6l0nP00WOBxH81w;

4.9
date	2002.11.27.13.59.37;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2002.11.26.17.24.29;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2002.11.25.16.16.58;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2002.11.22.15.05.40;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.04.21.21.42;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.01.20.15.29;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.01.19.47.49;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2000.11.30.11.44.22;	author jberanek;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.51;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.51;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.53.08;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.31.48;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.28.07;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.17
log
@Add support for Joliet format CD-ROMs
hdr/Hashes
s/Directory
s/EntryFile
s/FileMan
s/Filer
s/Free
 - mass search and replace of lots of poorly named definitions, removing unused ones, creating implicit ones
hdr/MyMacros
 - shuffle some registers in ConvertToArchyDate to save one temporary so it can be used for something else
 - moved ReplaceBadCharacters here
hdr/Options
 - extra debug option
s/DiscOp
 - add Joliet, rename buffer indicies per hdr/Hashes
 - the fallback filetype assignment (when neither the ARCHIMEDES system extension nor MimeMap can help) can now be overridden by setting CDFS$DefaultType (which defaults to &FFD)
s/SWI
 - remove DAT<->MPEG mapping from the internal mapping table
s/Variables
 - trim out unused SWI_buffer reservation

Tested with valid ISO/Joliet/RockRidge supported combinations, documented in Docs/Combos, and accompanying test ISO images now stored there.
Tested with CD-I format disc 'Jigsaw' from Britannica.
Tested with High Sierra format disc 'Kings Quest V'.
Tested with photo CD sampler from Kodak.

Version 2.61. Tagged as 'CDFS-2_61'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >Filer

;**************************************************************************
;**************************************************************************
;     This contains the routines called by 'FileMan'
;**************************************************************************
;**************************************************************************

; routines in here:

;                   SetDir                   ; RISC OS 2 only
;                   SetLib                   ; RISC OS 2 only
;                   Nothing
;                   Catalogue                ; RISC OS 2 only
;                   EX                       ; RISC OS 2 only
;                   LCAT                     ; RISC OS 2 only
;                   LEX                      ; RISC OS 2 only
;                   Info                     ; RISC OS 2 only
;                   Boot
;                   ReadBoot
;                   CurrentDirectory
;                   ReadLIBName
;                   CurrentDirObjects
;                   ObjectInfo
;                   ReadEntriesAndLength
;                   CanoncaliseName          ; RISC OS 3 only
;                   ResolveWildcard          ; RISC OS 3 only
;                   SearchRoutine ( see ReadEntriesAndLength etc; )


;**************************************************************************
SetDIR ROUT                 ; 0    *DIR ( pathname$ )
;**************************************************************************

; entry:
;       R0 = 0
;       R1 -> pointer to wildcarded directory name
;       R6 -> special field ( if present )

; exit:
;       ------- nothing

; R6 != 0 to call 'OS_FSControl 0' to set current directory, else == 0 to not set it

; First move to the correct directory, also expand name to whole path
; eg '%.fred' = '$.image03.fred'

; Then save this whole path as the current directory name IF VALID

;--- If '*dir' then *dir &

        log_on
        
        LDRB    R14, [ R1 ]
        TEQ     R14, #0
        ADREQ   R0, BlankUrd
                
        MOVNE   R0, R1
        
        MOV     r6, #1

;-------------------------------
; Set the current directory.
; This has to ---- around with the stack 'cause of the way that it is abused.
;-------------------------------
SetDir_fixed_for_mount
SetDir_fixed_for_drive

        log_on

        TEQ     r6, #1
        BEQ     %FT10

        Push    "r0-r1"
        MOV     r1, r0
             
        LDR     r8, stackreturn
        SUB     r8, r8, #4*20
        STR     r8, stackreturn
             
        MOV     r0, #FSControl_Dir
        SWI     XOS_FSControl
             
        ADD     r8, r8, #4*20
        STR     r8, stackreturn
        
        Pull    "r0-r1"
10

;************************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
        MOV     R1, #1                  ; Looking for a directory
        BL      Dir                     
;************************

        TEQ     R2, #object_directory   ; If it is a file, or not found then error
        MOVNE   r0, #ERROR_NOTFOUND
        BNE     ErrorExit


        LDRB    R14, CurrentDriveNumber ; Preserve drive number for *DIR \ 
                
        STRB    R14, olddrivenumber     ; used by *DIR \ 
                
        STRB    R4, CurrentDriveNumber  ; change to that drive
                
        Push    "R0"

        MOV     R0, R4
        BL      PreGetUniqueNumber      ; R0 = drive number, RETURNS R1 = number
        
        ;--- Update the list of discs mounted

        ADRL    R14, discsMounted
        STR     R1, [ R14, R0, LSL #2 ]

        ; keep the full pathname, eg :FreddyDisc.$.pathname

        ADR     r1, TempArea

        MOV     R0, R4                  ; Keep the name of the CSD disc
        MOV     R2, R3                  
        BL      GetDiscName             ; R0 = drive, R1 -> place to put name, R2 -> buffer
        MOV     R0, R1                  ;
        BL      CutSpace                ;
        
        Push    "R0"                    ; R0 = drive number
        MOV     R0, R4                  ; R1 -> disc name
        BL      AddDiscNameInList       ;
        Pull    "R0"                    ;
        
        Pull    "R0"

        CLRV
        PullAllFromFrameAndExit

BlankUrd
        DCB     "&", 0
        ALIGN

;**************************************************************************
Nothing ROUT
;**************************************************************************

        log_on

        PullAllFromFrameAndExit

;-----------------------------------------------------------------------------------------------
ReadBoot_OS3 ROUT                ; 11
;
; on entry:
;          R0 = 11
;          R2 = memory address to put data at   ( how big ??? )
;          R6 = 0 ( cannot specify a context )
; on exit:
;          --------
; Layout of memory:
;                  < length of name byte >< disc name >< boot option byte >
;
; This is the RISC OS 3 version of ReadBoot
;  BJGA 2002: NB since we set bit 23 of the filing system information word,
;             this is never called by modern FileSwitch!
;
;-----------------------------------------------------------------------------------------------

        MOV     r5, r2


        LDRB    r0, CurrentDriveNumber
        BL      TestKnowDisc
        ADD     r1, r1, #DiscBuff_DiscName

;------------------------------------
; Copy the name into a RISC OS buffer
;------------------------------------

        MOV     r2, #0

01
        LDRB    r0, [ r1 ], #1
        STRB    r0, [ r5 ], #1
        ADD     r2, r2, #1
        CMP     r0, #32
        BGT     %BT01

;------------------------------------
; Store the boot option
;------------------------------------
      [ BootFromCD
        MOV     lr, #2
        STRB    lr, [ r5 ]
      |
        STRB    r6, [ r5 ]
      ]

;------------------------------------
; Store the length byte
;------------------------------------
        STRB      r2, [ r5, -r2 ]

        PullAllFromFrameAndExit         ; V is clear


;**************************************************************************
CurrentDirObjects ROUT       ; 14   ( OS_GBPB 8 )
;**************************************************************************

; This is the same as 15, but only returns the names in the directory

; This is used to make a list of the contents of a directory

;entry:
;      R0 = 14
;      R1 -> pointer to directory name
;      R2 = memory address to put data
;      R3 = number of object names to read
;      R4 = offset of first item to read in directory
;      R5 = buffer length
;      R6 = pointer to special field if present ( network ? )

;exit:

;     R3 = number of records read
;     R4 = offset of next item to read in directory ( -1 if end )

        log_on
        
        MOV     R11, #0
        B       SearchRoutine           ; R0 -> routine




;**************************************************************************
ObjectInfo ROUT             ; 15 ( OS_GBPB 10 )
;**************************************************************************

; This is used to make a list of the contents of a directory

; All the way through, the latest entry is updated into loadaddress,

; execaddress, LBA ( used for copying ), temp4

;entry:
;      R0 = 15
;      R1 -> pointer to directory name
;      R2 = memory address to put data
;      R3 = number of object names to read
;      R4 = offset of first item to read in directory
;      R5 = buffer length
;      R6 = pointer to special field if present ( network ? )

;exit:

;     R3 = number of records read
;     R4 = offset of next item to read in directory ( -1 if end )

        log_on
        
        ADR     R11, ObjectInfo15

;**************************************************************************
SearchRoutine ROUT        ; R11 -> routine to call when needed OR 0
;**************************************************************************

; expects the following to be true:
; frame pushed with PushAllWithReturnFrame

;          R1 -> pointer to path
;          R2 = address of Archy buffer
;          R3 = number of objects to read
;          R4 = offset to read from
;          R5 = buffer length
;          R6 = pointer to special field


; during this procedure:

; R1 = number of objects left to read / or offset so far
; R2 -> current place where data is put in their buffer
; R3 = number of objects to read
; R4 = offset reached
; R5 -> end of buffer
; R6 -> start of entry in my buffer
; R8 = count
; ----R9 = !!!!!! number of object names matching wildcarded name
; ----R10 -> filename
; R11 -> routine to call

; The routine to call can use the following regs safely:
; R0, R7

; Return from your routine with MOV PC, R14

; Bit dodgy 'cause it uses a variable set by the 'Dir' procedure

        MOV     R7, R2
        ADD     R5, R5, R2           ; R5 -> end of Archies buffer
        SUB     R5, R5, #4
                
        MOV     R0, R1

;****************
; Find file name from pathname
;****************

; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
        Push    "R1 - R4"
        
        MOV     R1, #1                  ; Must find a directory
        
        BL      Dir
        
        TEQ     R2, #object_directory   ; If it is a file, or not found then error
        MOVNE   r0, #ERROR_NOTFOUND
        BNE     ErrorExit
        
        MOV     R6, R1                  ; R6 CORRECT HERE
        
        STRB    R4, tempdrivenumber
        
        LDR     R1, tempBlock
        STR     R1, lastblocknumber
                
        LDR     R1, discnumberofdirinbuffer
        STR     R1, lastdiscnumber

I_ll_be_back

        Pull    "R1 - R4"

        MOV     R8, #0
        MOV     R2, R7
        ADD     R3, R3, R4

02                                      ; Move to correct start pos.
        LDR     R0, [ R6, #0 ]          ; Empty directory ?
        TEQ     R0, #0                  ;
        BLEQ    %FT08                   ; [ yes ]

        ; --- Reached starting offset ? ---

        CMP     R8, R4
                
        BGE     %FT04
                
        ADD     R8, R8, #1

;*****************
; Move to next object in buffer
;*****************

        ADD     R6, R6, #OBJECTNAMEOFFSET + 1

03

        LDRB    R0, [ R6 ], #1
        TEQ     R0, #0
        LDRNEB  R0, [ R6 ], #1
        TEQNE   R0, #0
        BNE     %BT03

        ALIGNREG R6
        B       %BT02

04

06
        LDR     R0, [ R6, #0 ]
        TEQ     R0, #0
        BLEQ    %FT08

;********************
; Invoke specialised routine ( only if routine specified )
;********************
                
        TEQ     R11, #0
        MOVNE   R14, PC
        MOVNE   PC, R11

;******************** Returns to this point (!)

        ADD     R6, R6, #OBJECTNAMEOFFSET

05
        LDRB    R0, [ R6 ], #1
        STRB    R0, [ R2 ], #1
        
        CMP     R2, R5                  ; Run out of buffer space ?
        BGT     %FT07                   ; [ yes ]
        
        TEQ     R0, #0
        BNE     %BT05
        
        TEQ     R11, #0                 ; Only GBPB 9 & 10 need to be aligned
        TSTNE   R2, #3                  ;
        ADDNE   R2, R2, #4              ;
        BICNE   R2, R2, #3              ;
        
        ALIGNREG R6
        
        ADD     R8, R8, #1
        
        CMP     R8, R3
        
        BLT     %BT06


;************
; Done all that was asked for, or filled buffer
;************
07

        STR     R8, verytemporary
        
        PullAllFromFrame
        LDR     R0, verytemporary       ; R3=number of entries read ( matching wildname )
                                        ; R4 = next offset
        SUB     R3, R0, R4
        SUBS    R4, R0, #0              ; clears V
        
        MOV     PC, R14

;************
; Reached end of directory, but not end of buffer
; I NOW HAVE TO CHECK TO SEE IF ANY MORE DIRECTORY SPACE

; R14 is return address if needed

;************

08

        LDR     R0, tempBlockSize
                
        CMP     R0, #myblocksize
        MOVLT   R0, #myblocksize
                
        LDR     R10, tempLength
        SUBS    R10, R10, R0

end_of_search
        STRLE   R8, verytemporary
        PullAllFromFrame LE                      
        LDRLE   R3, verytemporary       ; [ yes ]
        SUBLE   R3, R3, R4
        MOVLE   R4, #-1                 ; ( That was the last entry )
        MOVLE   PC, R14                 ; (V almost certainly clear) GETS HERE, BUT AFTER ?
        
        STR     R10, tempLength
        
        LDR     R6, tempBlock
        ADD     R6, R6, #MAX_BLOCKS_BUFFERED
        STR     R6, tempBlock
                
        MOV     R6, #2

        ; Get next directory r2 r3 r4 r5 r6 r7 r8 ON ENTRY r6=2 or 0
09

        ; --- Keep up to date with object number found

        Push    "R1-R5,R7,R14"

        LDR     R2, tempBlock
                
        LDR     R0, discnumberofdirinbuffer
       
        ; r0=disc number, R2 = block, returns r1->buffer, CC if found
       
        BL      FindDiscInBufferList    ; Found details ?


        MOVCC   R6, R1                  ; [ yes ]
        Pull    "R1-R5,R7,PC", CC       ;

        ; Need to load this by hand
        ; r0 =start LBA, r1->put here, r3=disc type, r4=blocksize, r5=drive number
        ; r6=0 then skip 2 entries, else don't RETURNS r6=size used
        LDR     R0, tempBlock
        ADRL    R1, sparedirectorybuffer + DiscBuff_MainDirBuffer
        LDRB    R3, tempDisctype
        LDR     R4, tempBlockSize
        LDRB    R5, tempdrivenumber
        BL      StoreDirectory


        ;--------------------------------------------------------------
        ; Was block empty ? Just in case of funny discs, ie/ Revelation
        ;--------------------------------------------------------------
        
        TEQ     R6, #4
        BEQ     end_of_search           ; [ yes - so exit ]

        ;--------------------------------------------------------------

        MOV     R2, R0
        MOV     R3, R1
                
        MOV     R1, R6
        MOV     R6, R3
                
        LDR     R0, discnumberofdirinbuffer

        ; R0 = disc, R1 = size, R2 = block, R3->dire

        BL      AddDirectoryToBuffer

        Pull    "R1-R5, R7,PC"

WildSentence
        DCB     "*", 0
        ALIGN

;**************************************************************************
ReadEntriesAndLength ROUT  ; 19 ( OS_GBPB 11 )
;**************************************************************************

; on entry:
;          R0 = 19
;          R1 -> pointer to path
;          R2 = address of Archy buffer
;          R3 = number of objects to read
;          R4 = offset to read from
;          R5 = buffer length
;          R6 = pointer to special field


; on exit:
;         R3 = number of records read
;         R4 = offset of next item to read ( -1 if end )

        log_on
        
        ADR     R11, ObjectInfo19
        B       SearchRoutine           ; R0 -> routine


;**************************************************************************
ObjectInfo15 ROUT
;**************************************************************************
; Corruptable regs: R0, R7, R9, R10
; This corrupts R0 and R7 and R10

        LDR     R0, [ R6, #LOADADDRESSOFFSET ]
        LDR     R7, [ R6, #EXECUTIONADDRESSOFFSET ]
        
        STMIA   R2!, { R0, R7 }
        
        LDR     R0, [ R6, #LENGTHOFFSET ]
        LDRB    R7, [ R6, #FILEATTRIBUTESOFFSET ]
                
        LDRB    R10, [ R6, #OBJECTTYPEOFFSET ]
        STMIA   R2!, { R0, R7, R10 }
        
        MOV     PC, R14

;**************************************************************************
ObjectInfo19
;**************************************************************************
; Corruptable regs: R0, R7, R9, R10
; This corrupts R0, R7 and R9

        LDR     R0, [ R6, #LOADADDRESSOFFSET ]
        LDR     R7, [ R6, #EXECUTIONADDRESSOFFSET ]
        
        LDR     R9, [ R6, #LENGTHOFFSET ]
        LDRB    R10, [ R6, #FILEATTRIBUTESOFFSET ]
        STMIA   R2!, { R0, R7, R9, R10 }
        
        LDRB    R0, [ R6, #OBJECTTYPEOFFSET ]
        MOV     R7, #0                  ; System internal name
        
        LDR     R10, [ R6, #TIMEDATEOFFSET ]
        STMIA   R2!, { R0, R7, R10 }
                
        LDRB    R0, [ R6, #TIMEDATEHIBYTEOFFSET ] ; Date stamp
        STRB    R0, [ R2 ], #1                    
        
        MOV     PC, R14

;-----------------------------------------------------------------------------------------------

      [ BootFromCD
BootFromCDFS ROUT
; on entry:
;          r0  = 10
        LDR     r1, stackreturn
        ADR     r0, BootCommand
        SWI     XOS_CLI
        STR     r1, stackreturn
        B       common_end

BootCommand
        DCB     "Run $.!BOOT", 0
        ALIGN
      ]


CanonicaliseName ROUT
; on entry:
;          r0  = 23
;          r1 -> special field or 0
;          r2 -> disc name or 0
;          r3 -> buffer to hold canonical special field or 0 to return required length
;          r4 -> buffer to hold canonical disc name, or 0 to return required length
;          r5  = length of buffer to hold canonical special field
;          r6  = length of buffer to hold canonical disc name
; on exit:
;          r1 -> canonical special field or 0
;          r2 -> canonical disc name or 0
;          r3 = bytes overflow from special field buffer
;          r4 = bytes overflow from canonical disc name

; See page 4-47 of RISC OS 3 PRMs
;-----------------------------------------------------------------------------------------------

        ;----------------------------
        ; Is the disc name required ?
        ;----------------------------
        TEQ     r2, #0
        BEQ     disc_name_done
        
        TEQ     r4, #0
        MOVEQ   r6, #0
        
        
        ;--------------------------
        ; Get the drive number/name
        ;--------------------------
        MOV     r9, r2
        
        
        MOV     r0, #10
        MOV     r1, r2
        SWI     XOS_ReadUnsigned        ; r2 = value
        MOVVC   r0, r2
        BVC     %FT00
        MOV     r0, r9
        BL      FindDiscNameInList
        MOV     r0, r1
00

        ;---------------------------------------
        ; Disc name not found so ask User for it
        ;---------------------------------------
        CMP     r0, #-1
        BNE     %FT19
        LDRB    r1, CurrentDriveNumber
        MOV     r0, r9
        BL      PromptForDisc
        MOV     r0, r1

19
        BL      TestKnowDisc            ; r0 = drive, RETURNS r1 -> buffer
        ADD     r1, r1, #DiscBuff_DiscName



        ;--- Update the list of discs mounted
        Push    "r1"
        BL      AddDiscNameInList
        
        BL      PreGetUniqueNumber      ; R0 = drive number, RETURNS R1 = number
        
        ADRL    r14, discsMounted
        STR     r1, [ r14, r0, LSL #2 ]
        Pull    "r1"

        ;---------------------------------
        ; Find the length of the disc name, and copy to the caller
        ;---------------------------------

02

        MOV     r8, #0
01
        LDRB    r14, [ r1 ], #1
        
        SUBS    r6, r6, #1
        CMPHI   r4, #0                  ; pointers can be negative!
        STRHIB  r14, [ r4 ], #1
        
        CMP     r14, #32
        ADDGT   r8, r8, #1
        BGT     %BT01
        
        RSBS    r6, r6, #0
        MOVMI   r6, #0
        STR     r6, verytemporary
        PullAllFromFrame
        ADDS    r2, r4, #0              ; clears V
        LDR     r4, verytemporary
        MOV     pc, r14

disc_name_done

        CLRV
        PullAllFromFrameAndExit


;-----------------------------------------------------------------------------------------------

ResolveWildcard ROUT
; on entry:
;          r1 -> directory path
;          r2 -> buffer to hold resolved name, or 0
;          r3 -> wildcarded object name
;          r4 ???
;          r5 =  length of buffer
;          r6 -> special field or 0
; on exit:
;          r1   preserved
;          r2 = -1 if not found, else preserved
;          r3   preserved
;          r4 = -1 if fileswitch should work it out itself, else bytes overflow from buffer
;          r5   preserved
;
; see page 4-48 RISC OS 3 PRMs
;
;-----------------------------------------------------------------------------------------------

        PullAllFromFrame
        MOV     r4, #-1
        CLRV
        MOV     pc, r14



      [ BootFromCD
;-----------------------------------------------------------------------------------------------
ReadBoot2 ROUT
; on entry:
;          r1 -> pathname of any object on image
;          r6 -> special field or 0
; on exit:
;          r2 = boot option
;-----------------------------------------------------------------------------------------------
        PullAllFromFrame                         
        MOV     r2, #2                  ; Run
        MOV     pc, r14                 
      ]



;-----------------------------------------------------------------------------------------------
ReadFreeSpace ROUT
; on entry:
;          r1 -> pathname of any object on image
;          r6 -> special field or 0
; on exit:
;          r0 = free space (0)
;          r1 = biggest creatable object (0)
;          r2 = disc size
;-----------------------------------------------------------------------------------------------
        BL      ReadFreeSpaceCommon
        TEQ     r4, #0
        MOVNE   r2, #-1
        MOVEQ   r2, r3
        PullAllFromFrameAndExit AL, 3


;-----------------------------------------------------------------------------------------------
ReadFreeSpace64 ROUT
; on entry:
;          r1 -> pathname of any object on image
;          r6 -> special field or 0
; on exit:
;          r0 = lsw of free space (0)
;          r1 = msw of free space (0)
;          r2 = biggest creatable object (0)
;          r3 = lsw of disc size
;          r4 = msw of disc size
;-----------------------------------------------------------------------------------------------
        BL      ReadFreeSpaceCommon
        PullAllFromFrameAndExit AL, 5


ReadFreeSpaceCommon
        Push    "r14"
        MOV     r0, r1
        BL      FindDriveNumber
        MOVVC   r0, r1
        BLVC    PreConvertDriveNumberToDeviceID
        
        SUB     sp, sp, #8
        MOVVC   r0, #LBAFormat
        MOVVC   r1, sp
        SWIVC   XCD_DiscUsed
        Pull    "r1,r2"
        Pull    "pc", VS
        
        MOV     r14, r1, LSL #16
        MOV     r1, r1, LSR #16         ; r1 = mshw of block count
        MOV     r0, r14, LSR #16        ; r0 = lshw of block count
        
        MUL     r14, r1, r2
        MUL     r3, r0, r2
        MOV     r4, r14, LSR #16
        ADDS    r3, r3, r14, LSL #16
        ADC     r4, r4, #0
        
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        Pull    "pc"

;-----------------------------------------------------------------------------------------------

        LTORG
        
        END
@


4.16
log
@Various CDFS enhancements
* Increase BGET/BPUT buffer declared to FileSwitch to 2k to match the natural sector size (FileSwitch has been able to support this since version 2.28)
* Remove local debug macros, use those from NDRDebug instead
* Change to use SETV/CLRV macros now the ones in HdrSrc are 26/32 neutral
* Clarify those situations where LBA mode is being selected by using symbol 'LBAFormat'
* Extend *WHICHDISC to allow an optional drive number to be provided (the code has existed for years, but the GSTrans flags and help denied its use)

Version 2.60. Tagged as 'CDFS-2_60'
@
text
@a128 2
        STR     R1, CSDDiscNumber

d189 1
a189 1
        ADD     r1, r1, #DISCNAMEOFFSETINABUFFER
d346 1
a346 1
        LDR     R1, DiscNumberOfDirectoryInBuffer
d488 1
a488 1
        LDR     R0, DiscNumberOfDirectoryInBuffer
d501 6
a506 2

        BL VeryPreStoreDirectory
d524 1
a524 1
        LDR     R0, DiscNumberOfDirectoryInBuffer
d677 1
a677 1
        ADD     r1, r1, #DISCNAMEOFFSETINABUFFER
@


4.15
log
@Fixes for ISO format DVDs
The report for *CDDEVICES didn't line up properly for media > 999MB.
Tentative fix for DVDs formatted with directories placed above the 4GB boundary.

DiscOp.s: Preshift the directory block offset so it doesn't overflow for a DVD.
Filer.s/Free.s: Use LBA definition instead of 0.
Misc.s: Rework capacity display to handle up to 9999MB. Note, unlike OS_ConvertFileSize which rounds at 4096MB to 4GB we always express the result in MB.

Tested with a selection of CDs and DVDs from 10MB to 4800MB, all line up nicely.
The reporter of the directory issue, Steffen Huber, has been unable to test this change in time, but it should be low risk.

Version 2.57. Tagged as 'CDFS-2_57'
@
text
@d153 1
a153 1
        VCLEAR
d717 1
a717 1
        VCLEAR
d744 1
a744 1
        VCLEAR
@


4.14
log
@Fix a few bugs
When lining up the code in 2.52, a few bugs became apparent (now the source was readable).
* In a handful of places it was assumed SWIs preserved flags, these have been reordered or branched around.
* The probe of UtilityModule 2.12 has been set to 3.00 and the logic now considers >= 3.00 rather than subtracting 1 from it to deduce the default filename truncation value.
* Removed support for supplemental filetype table in CDFSNewFileTypePath$File as this has been superceded by the MimeMap module (which CDFS uses). This mirrors the behaviour of DOSFS and LanManFS which consult the MimeMap first then (small) internal table second.
* Fix stack imbalance when reading the current setting with CDFS_Truncation leading to an abort

Other changes
* When the MimeMap module is absent ".doc" is taken to be a MS Word document.
* Changed the manual loads from :INDEX: of R12 to be ADR's or ADRL's so there's less literal pool thrashing.
* Three Push/Pull sequences to restore registers swapped for LDMIA's (in Directory.s).
* Reason codes to OS_ SWIs swapped for header file names.


Version 2.56. Tagged as 'CDFS-2_56'
@
text
@d806 1
a806 1
        MOVVC   r0, #0                  ; LBA addressing mode
@


4.13
log
@Exchange local definitions for central ones.
Hdr:HighFSI LowFSI Services CDROM CMOS UpCall and CDFS now used in preference to local definitions.
Macro 'Command' used to build the keyword table.
Some asserts added for safety.


Version 2.54. Tagged as 'CDFS-2_54'
@
text
@d86 14
d101 2
a102 14
        Push    "r0-r1", NE
        MOVNE   r1, r0
        
        LDRNE   r8, stackreturn
        SUBNE   r8, r8, #4*20
        STRNE   r8, stackreturn
        
        MOVNE   r0, #0
        SWINE   XOS_FSControl
        
        ADDNE   r8, r8, #4*20
        STRNE   r8, stackreturn
        
        Pull    "r0-r1", NE
d133 1
a133 2
        LDR     R14, =:INDEX:discsMounted
        ADD     R14, R14, R12
d685 1
a685 2
        LDR     r14, =:INDEX:discsMounted
        ADD     r14, R14, R12
@


4.12
log
@Collapse old switches.
Switches from 10+ years ago removed. Demo version switch removed.

Version 2.53. Not tagged
@
text
@d111 1
a111 1
        TEQ     R2, #DIRECTORY          ; If it is a file, or not found then error
d336 1
a336 1
        TEQ     R2, #DIRECTORY          ; If it is a file, or not found then error
a399 1
                
a400 1
                
a406 2
; R0 -> wild carded string, R1 -> string, RETURNS R3 = SAME / NOT SAME

a407 1

@


4.11
log
@Resolve the 32 assembler warnings
Mostly by swapping STASH/GRAB for Push/Pull macros.
Inlined the module header rather than defining it in a header file.
Renamed "Debug" macro to "DebugInline" to avoid clash with similarly named macro.

Version 2.53. Tagged as 'CDFS-2_53'
@
text
@a73 1
      [ Module_Version >= 220
a74 1
      ]
a84 1
      [ Module_Version >= 220
a100 1
      ]
a136 1
      [ Module_Version >= 202
a137 1
      ]
a149 7
      [ Module_Version < 220
        LengthOfString R1, R2, R3
        ADD     R1, R1, R2
        MOV     R0, #"."
        STRB    R0, [ R1, #-1 ]
      ]
        
@


4.10
log
@Line up sources to normal columns.
Around 25000 spaces required, but rather easier to read as a result - it has revealed some bugs (not addressed in this commit).
Not quite binary identical, because an 'addr' of the ambiguous disc name error has moved by 1 byte due to a missing ALIGN directive.
Not tagged.
@
text
@a41 1

a43 2
; DO NOT USE STASHALL UNLESS DIRECTLY AFTER A GRABALL !!!!!!!!1

d90 1
a90 1
        STASH   "r0-r1", NE
d103 1
a103 1
        GRAB    "r0-r1", NE
d126 1
a126 1
        STASH   R0
d151 1
a151 1
        STASH   R0                      ; R0 = drive number
d154 1
a154 1
        GRAB    R0                      ;
d163 1
a163 1
        GRAB    R0
d166 1
a166 1
        GRABALLANDRETURN
d178 1
a178 1
        GRABALLANDRETURN
d231 1
a231 1
      STRB      r2, [ r5, -r2 ]
d233 1
a233 1
      GRABALLANDRETURN                  ; V is clear
d299 1
a299 2

; already STASHALLed
d343 1
a343 1
        STASH   R1 - R4
d365 1
a365 1
        GRAB    R1 - R4
d456 1
a456 1
        GRABALL
d484 1
a484 1
        GRABALL LE                      
d503 1
a503 1
        STASH   "R1-R5,R7,R14"
d515 1
a515 1
        GRAB    "R1-R5,R7,PC", CC       ;
d545 1
a545 1
        GRAB    "R1-R5, R7,PC"
d598 1
a598 1
; This corrupts R0 and R7
d603 1
a603 2
        LDR     R10, [ R6, #LENGTHOFFSET ]
        STMIA   R2!, { R0, R7, R10 }
d605 1
a605 1
        STMIA   R2!, { R10 }
d697 1
a697 1
        STASH   r1
d705 1
a705 1
        GRAB    r1
d728 1
a728 1
        GRABALL
d736 1
a736 1
        GRABALLANDRETURN
d760 1
a760 1
        GRABALL
d776 1
a776 1
        GRABALL                         
d797 1
a797 1
        GRABALLANDRETURNRESULTS 3
d813 1
a813 1
        GRABALLANDRETURNRESULTS 5
d817 1
a817 1
        STASH   "r14"
d827 2
a828 2
        GRAB    "r1,r2"
        GRAB    "pc", VS
d843 1
a843 1
        GRAB    "pc"
@


4.9
log
@Fixed booting from CDs - three problems in four lines of ROL code:
* r14_svc is corrupted by SWIs, so MOV pc,r14 to exit loops indefinitely
* r0-r11 ae still on the stack from the STASHALL, and they weren't being pulled
* no action was taken to compensate for reentrancy (corruption of stackreturn)

Retagged as 'CDFS-2_46'
@
text
@d69 11
a79 19
 log_on

 LDRB R14, [ R1 ]
 TEQ R14, #0
 ADREQ R0, BlankUrd

 MOVNE R0, R1


 [ Module_Version >= 220
      MOV       r6, #1
 ]


SetDir_fixed_for_mount
SetDir_fixed_for_drive

 log_on

d85 2
a86 1
 [ Module_Version >= 220
d88 1
a88 19
      TEQ       r6, #1

      STASH     "r0-r1", NE
      MOVNE     r1, r0

      LDRNE     r8, stackreturn
      SUBNE     r8, r8, #4*20
      STRNE     r8, stackreturn

      MOVNE     r0, #0
      SWINE     XOS_FSControl

      ADDNE     r8, r8, #4*20
      STRNE     r8, stackreturn

      GRAB      "r0-r1", NE
 ]

;-------------------------------
d90 18
d114 2
a115 2
 MOV R1, #1 ; Looking for a directory
 BL Dir
d118 23
a140 3
 TEQ R2, #DIRECTORY          ; If it is a file, or not found then error
       MOVNE      r0, #ERROR_NOTFOUND
       BNE        ErrorExit
d142 1
d144 3
a146 1
 LDRB R14, CurrentDriveNumber    ; Preserve drive number for *DIR \ 
d148 19
a166 58
 STRB R14, olddrivenumber        ; used by *DIR \ 

 STRB R4, CurrentDriveNumber     ; change to that drive

 STASH R0

 MOV R0, R4
 BL PreGetUniqueNumber           ; R0 = drive number, RETURNS R1 = number

 STR R1, CSDDiscNumber

;--- Update the list of discs mounted

 LDR R14, =:INDEX:discsMounted
 ADD R14, R14, R12
 STR R1, [ R14, R0, LSL #2 ]

;---

 ; keep the full pathname, eg :FreddyDisc.$.pathname

  [ Module_Version >= 202
       ADR      r1, TempArea
  ]

 MOV R0, R4               ; Keep the name of the CSD disc
 MOV R2, R3
 BL GetDiscName           ; R0 = drive, R1 -> place to put name, R2 -> buffer
 MOV R0, R1               ;
 BL CutSpace              ;

 STASH R0                 ; R0 = drive number
 MOV R0, R4               ; R1 -> disc name
 BL AddDiscNameInList     ;
 GRAB R0                  ;

 [ Module_Version < 220
 LengthOfString R1, R2, R3
 ADD R1, R1, R2
 MOV R0, #"."
 STRB R0, [ R1, #-1 ]
 ]

 GRAB R0


;********************
; Mark the CSD as being selected
;********************

; MOV R0, #SELECTED
; STRB R0, CSDSelected

 VCLEAR
 GRABALLANDRETURN

BlankUrd = "&", 0
 ALIGN
d168 2
d171 3
d179 1
a179 5
 log_on

 GRABALLANDRETURN


d181 1
d201 1
a201 1
        MOV         r5, r2
d204 3
a206 3
        LDRB        r0, CurrentDriveNumber
        BL          TestKnowDisc
        ADD         r1, r1, #DISCNAMEOFFSETINABUFFER
d212 1
a212 1
        MOV         r2, #0
d215 5
a219 5
        LDRB        r0, [ r1 ], #1
        STRB        r0, [ r5 ], #1
        ADD         r2, r2, #1
        CMP         r0, #32
        BGT         %BT01
d225 2
a226 2
        MOV         lr, #2
        STRB        lr, [ r5 ]
d228 1
a228 1
        STRB        r6, [ r5 ]
d234 1
a234 9
        STRB        r2, [ r5, -r2 ]


;------------------------------------

        ; V is clear
        GRABALLANDRETURN


d236 1
d261 4
a264 4
 log_on

 MOV R11, #0
 B SearchRoutine           ; R0 -> routine
d293 3
a295 3
 log_on

 ADR R11, ObjectInfo15
d333 5
a337 8

; MOV R9, #0

 MOV R7, R2
 ADD R5, R5, R2           ; R5 -> end of Archies buffer
 SUB R5, R5, #4

 MOV R0, R1
a342 16
; MOV R10, R1

;01

; LDRB R14, [ R1 ], #1
; TEQ R14, #"."
; MOVEQ R10, R1
; TEQ R14, #0
; BNE %BT01

;****************

; LDRB R14, [ R0 ]                 ; If points at 'null' path then point at
; TEQ R14, #0                      ; wild card instead !
; ADREQ R10, WildSentence          ;
;************************
d347 19
a365 22
 STASH R1 - R4

 MOV R1, #1 ; Must find a directory

 BL Dir

 TEQ R2, #DIRECTORY          ; If it is a file, or not found then error
           MOVNE      r0, #ERROR_NOTFOUND
           BNE        ErrorExit

 MOV R6, R1        ; R6 CORRECT HERE

 STRB R4, tempdrivenumber




 LDR R1, tempBlock
 STR R1, lastblocknumber

 LDR R1, DiscNumberOfDirectoryInBuffer
 STR R1, lastdiscnumber
d369 1
a369 8
 GRAB R1 - R4


 MOV R8, #0

;************************

 MOV R2, R7
d371 16
a386 15
 ADD R3, R3, R4

02                      ; Move to correct start pos.

 LDR R0, [ R6, #0 ]                   ; Empty directory ?
 TEQ R0, #0                           ;
 BLEQ %FT08                           ; [ yes ]

; --- Reached starting offset ? ---

 CMP R8, R4

 BGE %FT04

 ADD R8, R8, #1
d392 1
a392 1
 ADD R6, R6, #OBJECTNAMEOFFSET + 1
d396 5
a400 5
 LDRB R0, [ R6 ], #1
 TEQ R0, #0
 LDRNEB R0, [ R6 ], #1
 TEQNE R0, #0
 BNE %BT03
d402 2
a403 5
 ALIGNREG R6

;*****************

 B %BT02
a406 4
; GRABALL                      Crashes ****
; BICS PC, R14, #Overflow_Flag


d408 3
a410 4

 LDR R0, [ R6, #0 ]
 TEQ R0, #0
 BLEQ %FT08
d415 6
a420 6

 TEQ R11, #0

 MOVNE R14, PC

 MOVNE PC, R11
d424 1
a424 1
 ADD R6, R6, #OBJECTNAMEOFFSET
a427 7
; MOV R0, R10
; STASH "R1, R3"
; MOV R1, R6
; BL WildCompareStrings
; ADDVC R9, R9, #1
; GRAB "R1, R3"

d430 21
a450 24
 LDRB R0, [ R6 ], #1
 STRB R0, [ R2 ], #1

 CMP R2, R5                  ; Run out of buffer space ?
 BGT %FT07                   ; [ yes ]

 TEQ R0, #0
 BNE %BT05

 TEQ R11, #0                 ; Only GBPB 9 & 10 need to be aligned
 TSTNE R2, #3                ;
 ADDNE R2, R2, #4            ;
 BICNE R2, R2, #3            ;


 ALIGNREG R6

 ADD R8, R8, #1

 CMP R8, R3

; BLE %BT06
 BLT %BT06

d458 9
a466 11
 STR R8, verytemporary

 GRABALL
 LDR R0, verytemporary     ; R3=number of entries read ( matching wildname )
                           ; R4 = next offset
 SUB R3, R0, R4
; SUB R3, R3, #1
; SUB R4, R0, #1
 SUBS R4, R0, #0           ; clears V

 MOV PC, R14
d478 7
a484 7
 LDR R0, tempBlockSize

 CMP   R0, #myblocksize
 MOVLT R0, #myblocksize

 LDR R10, tempLength
 SUBS R10, R10, R0
d487 14
a500 12
 STRLE R8, verytemporary
 GRABALL LE                           ;
 LDRLE R3, verytemporary              ; [ yes ]
 SUBLE R3, R3, R4
 MOVLE R4, #-1                        ; ( That was the last entry )
 MOVLE PC, R14                        ; (V almost certainly clear) GETS HERE, BUT AFTER ?

 STR R10, tempLength

 LDR R6, tempBlock
 ADD R6, R6, #MAX_BLOCKS_BUFFERED
 STR R6, tempBlock
d502 1
a502 3
 MOV R6, #2

; Get next directory r2 r3 r4 r5 r6 r7 r8 ON ENTRY r6=2 or 0
d505 1
a505 1
; --- Keep up to date with object number found
d507 1
a507 1
 STASH "R1-R5,R7,R14"
d509 7
a515 1
 LDR R2, tempBlock
a516 1
 LDR R0, DiscNumberOfDirectoryInBuffer
d518 2
a519 1
; r0=disc number, R2 = block, returns r1->buffer, CC if found
d521 3
a523 1
 BL FindDiscInBufferList                 ; Found details ?
d525 1
a526 2
 MOVCC     R6, R1                         ; [ yes ]
 GRAB      "R1-R5,R7,PC", CC                  ;
d528 6
d535 1
a535 1
; Need to load this by hand
d537 7
a543 2
; r0 =start LBA, r1->put here, r3=disc type, r4=blocksize, r5=drive number
; r6=0 then skip 2 entries, else don't RETURNS r6=size used
d545 1
a545 1
 BL VeryPreStoreDirectory
d547 1
d549 1
a549 3
;--------------------------------------------------------------
; Was block empty ? Just in case of funny discs, ie/ Revelation
;--------------------------------------------------------------
d551 3
a553 22
 TEQ  R6, #4
 BEQ  end_of_search    ; [ yes - so exit ]


;--------------------------------------------------------------

 MOV R2, R0
 MOV R3, R1

 MOV R1, R6
 MOV R6, R3

 LDR R0, DiscNumberOfDirectoryInBuffer

; R0 = disc, R1 = size, R2 = block, R3->dire

 BL AddDirectoryToBuffer

 GRAB "R1-R5, R7,PC"

WildSentence = "*", 0
 ALIGN
d573 4
a576 10
 log_on

 ADR R11, ObjectInfo19
 B SearchRoutine        ; R0 -> routine


;**************************************************************************
;**************************************************************************
;**************************************************************************
;**************************************************************************
a582 1

d585 12
a596 22
 LDR R0, [ R6, #LOADADDRESSOFFSET ]
 LDR R7, [ R6, #EXECUTIONADDRESSOFFSET ]

; CHECK TO SEE IF TIME=0 IF SO, THEN COPY FROM TIMEDATEOFFSET

; TEQ R7, #0

; LDREQB R7, [ R6, #TIMEDATEHIBYTEOFFSET ]
; ORREQ R0, R7, R0
; LDREQ R7, =&FFF00000
; ORREQ R0, R0, R7
; LDREQ R7, [ R6, #TIMEDATEOFFSET ]

 STMIA R2!, { R0, R7 }

 LDR R0, [ R6, #LENGTHOFFSET ]
 LDRB R7, [ R6, #FILEATTRIBUTESOFFSET ]

 LDRB R10, [ R6, #OBJECTTYPEOFFSET ]
 STMIA R2!, { R0, R7, R10 }

 MOV PC, R14
a600 1

a601 1

d604 18
a621 21
 LDR R0, [ R6, #LOADADDRESSOFFSET ]
 LDR R7, [ R6, #EXECUTIONADDRESSOFFSET ]

 LDR R10, [ R6, #LENGTHOFFSET ]
 STMIA R2!, { R0, R7, R10 }
 LDRB R10, [ R6, #FILEATTRIBUTESOFFSET ]
 STMIA R2!, { R10 }
; LDR R9, [ R6, #LENGTHOFFSET ]
; LDRB R10, [ R6, #FILEATTRIBUTESOFFSET ]
; STMIA R2!, { R0, R7, R9, R10 }

 LDRB R0, [ R6, #OBJECTTYPEOFFSET ]
 MOV R7, #0                                ; System internal name

 LDR R10, [ R6, #TIMEDATEOFFSET ]           ;
 STMIA R2!, { R0, R7, R10 }                 ;

 LDRB R0, [ R6, #TIMEDATEHIBYTEOFFSET ]    ; Date stamp
 STRB R0, [ R2 ], #1                       ;

 MOV PC, R14
d625 1
a625 1
 [ BootFromCD
a632 1
;        VCLEAR
d638 1
a638 2

 ]
d659 24
a682 24
;----------------------------
; Is the disc name required ?
;----------------------------
 TEQ         r2, #0
 BEQ         disc_name_done

 TEQ         r4, #0
 MOVEQ       r6, #0


;--------------------------
; Get the drive number/name
;--------------------------
 MOV         r9, r2


 MOV         r0, #10
 MOV         r1, r2
 SWI         XOS_ReadUnsigned                   ; r2 = value
 MOVVC       r0, r2
 BVC         %FT00
 MOV         r0, r9
 BL          FindDiscNameInList
 MOV         r0, r1
d685 9
a693 9
;---------------------------------------
; Disc name not found so ask User for it
;---------------------------------------
 CMP         r0, #-1
 BNE         %FT19
 LDRB        r1, CurrentDriveNumber
 MOV         r0, r9
 BL          PromptForDisc
 MOV         r0, r1
d696 2
a697 3
 BL          TestKnowDisc                       ; r0 = drive, RETURNS r1 -> buffer
 ADD         r1, r1, #DISCNAMEOFFSETINABUFFER

a699 3
;--- Update the list of discs mounted
 STASH       r1
 BL          AddDiscNameInList
d701 14
a714 10
 BL          PreGetUniqueNumber           ; R0 = drive number, RETURNS R1 = number

 LDR         r14, =:INDEX:discsMounted
 ADD         r14, R14, R12
 STR         r1, [ r14, r0, LSL #2 ]
 GRAB        r1

;---------------------------------
; Find the length of the disc name, and copy to the caller
;---------------------------------
d718 1
a718 1
 MOV         r8, #0
d720 17
a736 19
 LDRB        r14, [ r1 ], #1

 SUBS        r6, r6, #1
 CMPHI       r4, #0                     ; pointers can be negative!
 STRHIB      r14, [ r4 ], #1

 CMP         r14, #32
 ADDGT       r8, r8, #1
 BGT         %BT01

 RSBS        r6, r6, #0
 MOVMI       r6, #0
 STR         r6, verytemporary
 GRABALL
 ADDS        r2, r4, #0 ; clears V
 LDR         r4, verytemporary
 MOV         pc, r14

;---------------------------------
d740 2
a741 2
 VCLEAR
 GRABALLANDRETURN
d765 4
a768 4
 GRABALL
 MOV         r4, #-1
 VCLEAR
 MOV         pc, r14
d772 1
a772 1
 [ BootFromCD
d781 4
a784 4
 GRABALL
 MOV         r2, #2     ; Run
 MOV         pc, r14
 ]
d798 5
a802 5
 BL          ReadFreeSpaceCommon
 TEQ         r4, #0
 MOVNE       r2, #-1
 MOVEQ       r2, r3
 GRABALLANDRETURNRESULTS 3
d817 2
a818 2
 BL          ReadFreeSpaceCommon
 GRABALLANDRETURNRESULTS 5
d822 27
a848 29
 STASH       "r14"
 MOV         r0, r1
 BL          FindDriveNumber
 MOVVC       r0, r1
 BLVC        PreConvertDriveNumberToDeviceID

 SUB         sp, sp, #8
 MOVVC       r0, #0                     ; LBA addressing mode
 MOVVC       r1, sp
 SWIVC       XCD_DiscUsed
 GRAB        "r1,r2"
 GRAB        "pc", VS

 MOV         r14, r1, LSL #16
 MOV         r1, r1, LSR #16            ; r1 = mshw of block count
 MOV         r0, r14, LSR #16           ; r0 = lshw of block count

 MUL         r14, r1, r2
 MUL         r3, r0, r2
 MOV         r4, r14, LSR #16
 ADDS        r3, r3, r14, LSL #16
 ADC         r4, r4, #0

 MOV         r0, #0
 MOV         r1, #0
 MOV         r2, #0
 GRAB        "pc"


d852 3
a854 4

 LTORG

 END
@


4.8
log
@  Nice new features.
Detail:
  * Reenabled BootFromCD option, and finished it off (so FSFunc_ReadBoot
    returns 2 (Run) to match the enforced action on booting); booting
    command line changed to "Run $.!BOOT"
  * Added 32-bit and 64-bit ReadFreeSpace FSFunc entries
  * Added support for interfacing with the Free module (so *ShowFree -FS CDFS
    now works)
  * Added missing * in syntax messags for *Lock and *Unlock
Admin:
  Tested on Tungsten.

Version 2.45. Tagged as 'CDFS-2_45'
@
text
@d729 1
d732 1
d734 1
a734 1
        MOV     pc, r14
@


4.7
log
@  Some more bugfixes.
Detail:
  * Return registers for FSEntry_Func 14, 15 and 19 were getting corrupted
    due to stack manipulations, resulting in aborts inside FileSwitch
    whe enumerating some directories
  * Fixed an assumption of flag preservation across the PromptForDisc
    routine (the one that does UpCalls) that led initially to aborts (fixed
    by some top-bit-set safety measures), then later to bogus "CD-ROM drive
    not known" errors when accessig an object on a CD not currently in a
    drive
Admin:
  Tested on Tungsten.

Version 2.44. Tagged as 'CDFS-2_44'
@
text
@d217 2
d245 4
d250 1
d731 1
a731 1
        VCLEAR
d735 1
a735 1
        DCB     "CDFS:%Run $.!Boot", 13
d872 79
@


4.6
log
@  A few fixes.
Detail:
  * Fixed a couple of top-bit-set pointer problems
  * Fixed a couple of places where it was assumed that SWIs preserved flags
  * Uses kernel internationalisation for command help, so full tokenisation
    now works properly
  * Added NdrDebug support
Admin:
  Tested on Tungsten.

Version 2.41. Tagged as 'CDFS-2_41'
@
text
@d525 1
a525 1
 STR R8, [R13]
d528 1
a528 1
                           ; R3=number of entries read ( matching wildname )
d556 1
a556 1
 STRLE R8, [R13, #3*4]
d558 1
d782 5
a786 4
 LDREQB      r1, CurrentDriveNumber
 MOVEQ       r0, r9
 BLEQ        PromptForDisc
 MOVEQ       r0, r1
d788 1
a788 1
;19
@


4.5
log
@  Lots of changes for RISC OS 5.
Detail:
  * Updated to use objasm, shared makefiles and global headers
  * Ripped out lots of RISC OS 2 support code so we can see the wood for the
    trees now
  * 32-bit compatible (a bit of a slog)
  * Now has its own resources phase, replacing the use of the CDFSResources
    module. Also means that messages can now be tokenised properly. For
    good measure, split out CmdHelp tokens into separate file
  * Hopefully fixed more bugs along the way than I introduced. I've seen
    lots of nasty stack imbalances in error cases, but not fixed all of
    them, I'm afraid
Admin:
  Tested briefly on a Risc PC; not enough support modules to run on Tungsten
  yet.

Version 2.38. Tagged as 'CDFS-2_38'
@
text
@d814 2
a815 2
 CMPGT       r4, #0
 STRGTB      r14, [ r4 ], #1
@


4.4
log
@Manual merge of the RISC OS 4.02 version of CDFS (2.37, based upon Acorn's
RiscOS/UnU/OS_Core/FileSys/CDFS/CDFS234 version 2.35).

Tagged as 'CDFS-2_37'
@
text
@a125 4
 [ RISC_OS=2
 ADRNEL R0, NotFound
 BNE Error
 |
d127 1
a127 783
       BNE        Error
 ]


 LDRB R14, CurrentDriveNumber    ; Preserve drive number for *DIR \

 STRB R14, olddrivenumber        ; used by *DIR \

 STRB R4, CurrentDriveNumber     ; change to that drive

 STASH R0

 MOV R0, R4
 BL PreGetUniqueNumber           ; R0 = drive number, RETURNS R1 = number

 STR R1, CSDDiscNumber

;--- Update the list of discs mounted

 LDR R14, =:INDEX:discsMounted
 ADD R14, R14, R12
 STR R1, [ R14, R0, LSL #2 ]

;---

 ; keep the full pathname, eg :FreddyDisc.$.pathname

 [ RISC_OS=2

 LDR R1, =:INDEX:CSD_path ; Copy full path into DIR_path
 ADD R1, R1, R12          ; prefixed with ':'
 MOV R0, #":"             ;
 STRB R0, [ R1 ], #1      ;

 |
  [ Module_Version >= 202
       ADR      r1, TempArea
  ]
 ]

 MOV R0, R4               ; Keep the name of the CSD disc
 MOV R2, R3
 BL GetDiscName           ; R0 = drive, R1 -> place to put name, R2 -> buffer
 MOV R0, R1               ;
 BL CutSpace              ;

 STASH R0                 ; R0 = drive number
 MOV R0, R4               ; R1 -> disc name
 BL AddDiscNameInList     ;
 GRAB R0                  ;

 [ Module_Version < 220
 LengthOfString R1, R2, R3
 ADD R1, R1, R2
 MOV R0, #"."
 STRB R0, [ R1, #-1 ]
 ]

 GRAB R0

;*****************
; Keep a copy of the old directory so that it can be swapped '\'
;*****************

;1. copy from 'CSDPath' to 'BackPath'

; R2 -> CSDPath
; R3 -> BackPath
; R4 = byte


 [ RISC_OS=2

 LDR R2, =:INDEX:CSD_path
 ADD R2, R2, R12

 LDR R3, =:INDEX:BackPath
 ADD R3, R3, R12


01

 LDRB R4, [ R2 ], #1
 STRB R4, [ R3 ], #1
 TEQ R4, #0

 BNE %BT01

;****************
;2. copy from 'Fullpathname' to 'CSDPath'
;****************

; R0 -> FullPathName
; R1 -> CSDPath
; R4 = byte

copy_preserve_path

 LDRB R4, [ R0 ], #1
 STRB R4, [ R1 ], #1
 TEQ R4, #0

 BNE copy_preserve_path
 ] ; RISC OS 2 only




;********************
; Mark the CSD as being selected
;********************

; MOV R0, #SELECTED
; STRB R0, CSDSelected

 GRABALL
 BICS PC, R14, #Overflow_Flag

BlankUrd = "&", 0
 ALIGN


 [ RISC_OS = 2

;**************************************************************************
SetLIB ROUT                ; 1
;**************************************************************************

; on entry:
;          R0 = 1
;          R1 -> wildcarded directory name
;          R6 -> pointer to special field ( 0 if not present )

 log_on

 MOV R0, R1

;*************************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 MOV R1, #1  ; looking for a directory
 BL Dir
;*************************
 TEQ R2, #DIRECTORY
 ADRNEL R0, NotFound
 BNE Error

; STRB R4, LibraryDriveNumber ; keep the drive number of the library disc

 ; keep the full pathname, eg :FreddyDisc.$.pathname

;********************
; Copy the name of the disc into the library for that drive
;********************

 STASH R0

 LDR R1, pointertolibandurd ; R1 -> place to put library path in
 MOV R2, #LIBLENGTH         ;
 MLA R1, R2, R4, R1         ;

 MOV R0, #":"             ;
 STRB R0, [ R1 ], #1      ;
 MOV R0, R4               ; Keep the name of the library disc
 MOV R2, R3
 BL GetDiscName           ; R0 = drive, R1 -> place to put name, R2->buffer
 MOV R0, R1               ;
 BL CutSpace              ;

 LengthOfString R1, R2, R3
 ADD R1, R1, R2
 MOV R0, #"."
 STRB R0, [ R1, #-1 ]

 GRAB R0

;****************
;2. copy from 'Fullpathname' to 'LIBPath'
;****************

; R0 -> FullPathName
; R1 -> LIBPath
; R4 = byte

01

 LDRB R4, [ R0 ], #1
 STRB R4, [ R1 ], #1
 TEQ R4, #0

 BNE %BT01             ; ALLOW TO RUN ON !!!!!!!!!!

 ]

;**************************************************************************
Nothing ROUT
;**************************************************************************

 log_on

 GRABALL
 BICS PC, R14, #Overflow_Flag




 [ RISC_OS = 2

;**************************************************************************
LCAT ROUT              ; 4
;**************************************************************************

; on entry:
;          R0 = 4
;          R1 -> path name
;          R6 -> special field ( or 0 )

; on exit:
;         ----------------------- nothing

 log_on

 MOV R0, R1

 LDRB R1, [ R0 ]  ; The offset must be from the library directory
 TEQ R1, #"%"     ; not from the CSD directory
 TEQNE R1, #"\"   ;
 TEQNE R1, #"$"   ;
 TEQNE R1, #"&"   ;
 TEQNE R1, #"@@"   ; if 'EQ' then doesn't matter

 BEQ %FT02

 TEQ R1, #0       ; see below

 ADD R1, R12, #:INDEX:tempbuffer ; Prefix path with '%.'

 MOV R3, R1

 MOV R2, #"%"                 ;
 STRB R2, [ R1 ], #1          ; "%."


 MOVNE R2, #"."               ; "below"
 STRNEB R2, [ R1 ], #1        ;


01                            ; R0 -> get path, R1 -> put path, R2 = temp

 LDRB R2, [ R0 ], #1
 STRB R2, [ R1 ], #1
 TEQ R2, #0

 BNE %BT01

 MOV R0, R3


02                    ; R1 -> path

 MOV R1, R0           ; ALLOW TO RUN ON !!!!!!!!!!


 ]


 [ RISC_OS = 2

;**************************************************************************
Catalogue ROUT            ; 2    *CAT ( pathname$ )
;**************************************************************************

; on entry:
;          R0 = 2
;          R1 -> wildcarded directory name ( null terminated )
;          R6 = pointer to special field

; on exit:
;         -------- nothing

 log_on

 MOV R0, R1

;**********************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 MOV R1, #1 ; Looking for a directory
 BL Dir
;**********************
 TEQ R2, #DIRECTORY
 ADRNEL R0, NotFound
 BNE Error

 STRB R4, tempdrivenumber

 STASH R1

 MOV R1, R4

 MOV R2, R3
 BL DisplayHeader           ; R0 -> pathname, R1 = drive number see (Open)
                            ; R2 -> disc buffer
 GRAB R1

09

 LDR R2, =:INDEX:buffer
 ADD R2, R2, R12

 LDR R3, [ R1, #0 ]
 TEQ R3, #0
 BEQ %FT05                 ; display_directory

01

 ADD R4, R1, #OBJECTNAMEOFFSET

 ADD R7, R2, #MAXLENGTHOFNAME + 2

02                             ; copy file name into buffer

 LDRB R3, [ R4 ], #1
 TEQ R3, #0
 STRNEB R3, [ R2 ], #1
 BNE %BT02

 MOV R3, #HARDSPACE

03

 STRB R3, [ R2 ], #1
 CMP R2, R7
 BLE %BT03

 LDRB R3, [ R1, #OBJECTTYPEOFFSET ]
 TEQ R3, #FILE
 MOVNE R5, #"D"
 BNE %FT04

 LDRB R3, [ R1, #FILEATTRIBUTESOFFSET ]  ; file attributes
 TST R3, #1                              ; 2_11001 read / not
 MOVNE R5, #"R"
 MOVEQ R5, #HARDSPACE

04

 STRB R5, [ R2 ], #1

 TST R3, #2_1000             ; locked / not
 MOVNE R5, #"L"
 MOVEQ R5, #HARDSPACE
 STRB R5, [ R2 ], #1

 MOV R3, #SPACE
 STRB R3, [ R2 ], #1

 ALIGNREG R4

 LDR R3, [ R4, #0 ]
 TEQ R3, #0
 MOVNE R1, R4
 BNE %BT01

05             ; display_directory

 STRB R3, [ R2 ]



 LDR R0, =:INDEX:buffer
 ADD R0, R0, R12

 MOV R2, R0

 SWI XOS_PrettyPrint              ; Print contents of buffer

; --- Any more blocks in the directory to do ? ---

 LDR R0, tempBlockSize

 CMP   R0, #myblocksize
 MOVLT R0, #myblocksize

 LDR R14, tempLength

 SUBS R14, R14, R0

end_of_cat
 SWILE XOS_NewLine                 ; [ no ]
                                   ;
 GRABALL LE                        ;
 BICLES PC, R14, #Overflow_Flag    ;

 STR R14, tempLength

; Space out the text a bit

 SWI &100+32

 LDR R2, tempBlock
 ADD R2, R2, #MAX_BLOCKS_BUFFERED
 STR R2, tempBlock

 LDR R0, DiscNumberOfDirectoryInBuffer
 BL FindDiscInBufferList                 ; Found details ?
                                         ; RETURNS r1->buffer

 BCC %BT09

 MOV R6, #2

 BL VeryPreStoreDirectory         ; RETURNS EQ if end of dir reached, else NE


; Was block empty ? Just in case of funny discs, ie/ Revalation

 TEQ  R6, #4
 BEQ end_of_cat                       ; [ yes ]

 MOV R2, R0                                ;
 MOV R3, R1                                ;
 MOV R1, R6                                ;
 LDR R0, DiscNumberOfDirectoryInBuffer
 BL AddDirectoryToBuffer      ; R0 = disc, R1 = size, R2 = block, R3->dire

 MOV R1, R3


 B %BT09

 ]



 [ RISC_OS = 2

;**************************************************************************
LEX ROUT                      ; 5   *LEX
;**************************************************************************

; on entry:
;          R0 = 5
;          R1 -> directory name

; on exit:
;         ----------

 log_on

 MOV R0, R1

 LDRB R1, [ R0 ]  ; The offset must be from the library directory
 TEQ R1, #"%"     ; not from the CSD directory
 TEQNE R1, #"\"   ;
 TEQNE R1, #"$"   ;
 TEQNE R1, #"&"   ;
 TEQNE R1, #"@@"   ; if 'EQ' then doesn't matter

 BEQ %FT02

 TEQ R1, #0       ; see below

 ADD R1, R12, #:INDEX:tempbuffer ; Prefix path with '%.'

 MOV R3, R1

 MOV R2, #"%"                 ;
 STRB R2, [ R1 ], #1          ; "%."


 MOVNE R2, #"."               ; "below"
 STRNEB R2, [ R1 ], #1        ;


01                            ; R0 -> get path, R1 -> put path, R2 = temp

 LDRB R2, [ R0 ], #1
 STRB R2, [ R1 ], #1
 TEQ R2, #0

 BNE %BT01

 MOV R0, R3


02                       ; R1 -> path

 MOV R1, R0              ; ALLOW TO RUN ON !!!!!!!!!!!!


 ]


 [ RISC_OS = 2

;**************************************************************************
EX ROUT                       ; 3   *EX
;**************************************************************************

; on entry:
;          R0 = 3
;          R1 -> directory name

; on exit:
;         ----------
 log_on

 MOV R0, R1


;***********************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 MOV R1, #1  ; Looking for a directory
 BL Dir
;***********************

 TEQ R2, #DIRECTORY          ; Not found, or is a file
 ADRNEL R0, NotFound         ;
 BNE Error                   ;

 STRB R4, tempdrivenumber

 STASH R1

 MOV R1, R4

 MOV R2, R3

 BL DisplayHeader           ; R0 -> pathname, R1 = drive number see (Open)
                            ; R2 -> disc buffer

 GRAB R1

09

 MOV R5, #SIZEOFBUFFER / 100 ; make sure that the buffer is not overwritten !


 LDR R2, [ R1, #0 ]                  ; Empty directory ?
 TEQ R2, #0                          ;
 GRABALL EQ                          ; [ yes ]
 BICEQS PC, R14, #Overflow_Flag      ;

 LDR R4, =:INDEX:buffer      ; R4 -> next free place in buffer
 ADD R4, R4, R12             ;



02

 LDR R2, [ R1, #LBASTARTOFFSET ]     ; last entry done ?
 MOVS R2, R2, LSR #8
 BEQ terminate_buffer


 SUBS R5, R5, #1                     ; Null terminate if at end
 STREQB R5, [ R4 ]                   ;
 LDREQ R0, =:INDEX:buffer            ; Display buffer if chance of overflow
 ADDEQ R0, R0, R12                   ;
 MOVEQ R4, R0
 SWIEQ XOS_PrettyPrint               ;
 MOVEQ R5, #SIZEOFBUFFER / 100       ;

 MOV R2, R4
 BL INFO                 ; R0 -> pathname, R1 -> details, R2 -> print buffer
                         ; RETURNS R2 -> end of buffer

 MOV R4, R2              ; Seperate entries with a NEWLINE
 MOV R2, #NEWLINE        ;
 STRB R2, [ R4 ], #1     ;

 LDRB R2, [ R1, #OBJECTNAMEOFFSET ]!
 TEQ R2, #0

01                       ; Move past name to start of next entry
 LDRNEB R2, [ R1 ], #1   ;
 TEQNE R2, #0            ;
 BNE %BT01               ;


 ALIGNREG R1             ; Move R1 to start of next entry

 B %BT02

; --- Any more blocks in the directory ? ---

terminate_buffer

 STRB R2, [ R4, #-1 ]              ; terminate buffer
 LDR R0, =:INDEX:buffer            ; Display buffer
 ADD R0, R0, R12                   ;
 MOV R1, #0                        ;
 MOV R2, #0                        ;
 SWI XOS_PrettyPrint               ;

; --- Any more blocks ---

 LDR R0, tempBlockSize

 CMP   R0, #myblocksize
 MOVLT R0, #myblocksize

 LDR R14, tempLength

 SUBS R14, R14, R0

end_of_ex
 SWILE XOS_NewLine                   ;
 GRABALL LE                          ; End of list of names
 BICLES PC, R14, #Overflow_Flag      ;

 STR R14, tempLength

 LDR R2, tempBlock
 ADD R2, R2, #MAX_BLOCKS_BUFFERED
 STR R2, tempBlock

 LDR R0, DiscNumberOfDirectoryInBuffer
 BL FindDiscInBufferList                 ; Found details ?
                                         ; RETURNS r1->buffer

 BCC %BT09

 MOV R6, #2

 BL VeryPreStoreDirectory    ; RETURNS EQ if end of dir reached, else NE

; Was block empty ? Just in case of funny discs, ie/ Revelation

 TEQ  R6, #4
 BEQ end_of_ex                       ; [ yes - end ]

 MOV R2, R0                                ;
 MOV R3, R1                                ;
 MOV R1, R6                                ;
 LDR R0, DiscNumberOfDirectoryInBuffer
 BL AddDirectoryToBuffer      ; R0 = disc, R1 = size, R2 = block, R3->dire

 MOV R1, R3

 B %BT09

 ]


 [ RISC_OS = 2

;**************************************************************************
Info ROUT                    ; 6   *INFO
;**************************************************************************

; on entry:
; R0 = 6
; R1 -> path
; R6 ->

; on exit:
;         nothing

 log_on

; R7 -> last leaf in directory name
; R8 = number found matching wildcarded spec.


;***************
; Find last leaf in path    ; R0 -> path
;***************

 MOV R8, R1                 ; R8 ->
 MOV R7, R1                 ; R7 -> start of last leaf

01

 LDRB R14, [ R8 ], #1
 TEQ R14, #"."
 MOVEQ R7, R8

 CMP R14, #32
 BGT %BT01

; R1->path name
; R7->leaf name
; R8->end of path

 MOV R14, #0

;--- Any directories specified ?

 TEQ R7, R1
; SUBEQ R7, R8, #1              ; [ no - so use current dir ]
 SUBEQ R0, R7, #1              ; ->0

 STASH R1

 STRNEB R14, [ R7, #-1 ]       ; [ yes-so search for directory ]
 MOVNE R0, R1

; STREQB R14, [ R8, #-1 ]    ; [ no- so search for current directory ]
; ADREQ R0, CURRENTDIR

; STASH R0
; SWI XOS_WriteS
; = "path=:",0
; ALIGN
; SWI XOS_Write0
; SWI &100+":"
; GRAB R0
;***************************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 MOV R1, #1 ; Looking for a directory
 BL Dir
;***************************

 GRAB R14

 TEQ R2, #DIRECTORY          ; Not found, or is a file
 ADRNEL R0, NotFound         ;
 BNE Error                   ;

;***************
; Check to see if '*info $'       !!! OK !!!
;***************

; TEQ R7, R0                      ; '*info $' ?
 LDRB R5, [ R14 ]
 TEQ R5, #"$"
 LDREQB R5, [ R14, #1 ]
 TEQEQ R5, #0

 ADREQ R0, MainDirInfo           ; [ yes - Display '$ DL 2048' ]
 SWIEQ XOS_Write0                ;
 SWIEQ XOS_NewLine               ;
 GRABALL EQ                      ;
 BICEQS PC, R14, #Overflow_Flag  ;

;***************

09

 MOV R5, #SIZEOFBUFFER / 100 ; make sure that the buffer is not overwritten !


 LDR R2, [ R1, #LBASTARTOFFSET ]     ; Empty directory ?
 TEQ R2, #0                          ;
 GRABALL EQ                          ;
 BICEQS PC, R14, #Overflow_Flag      ; [ empty - so leave ]


 LDR R4, =:INDEX:buffer      ; R4 -> next free place in buffer
 ADD R4, R4, R12             ;

 MOV R8, #0

another_name_another_day

 LDR R2, [ R1, #LBASTARTOFFSET ]     ; last entry done ?
 TEQ R2, #0                          ;

 BEQ end_of_day

 SUBS R5, R5, #1
 MOVEQ R0, #0
 STREQB R0, [ R4 ]
 LDREQ R0, =:INDEX:buffer            ; Display buffer if chance of overflow
 ADDEQ R0, R0, R12                   ;
 MOVEQ R5, R0
 SWIEQ XOS_PrettyPrint               ;
; LDREQ R4, =:INDEX:buffer            ;
; ADDEQ R4, R4, R12                   ;
 MOVEQ R4, R5
 MOVEQ R5, #SIZEOFBUFFER / 100       ;
a128 1
 MOV R2, R4
d130 1
a130 1
; Only display info if wildcard spec. is same.
d132 1
a132 1
 STASH R0 - R3
d134 1
a134 2
 MOV R0, R7
 ADD R1, R1, #OBJECTNAMEOFFSET
d136 1
a136 1
 BL WildCompareStrings   ; R0 -> wild string, R1 -> norm string, VCLEAR if found
d138 2
a139 1
 GRAB R0 - R3
d141 1
a141 1
 ADDVC R8, R8, #1        ; R8 = number matched correctly
d143 1
a143 1
 ADDVS R5, R5, #1
d145 3
a147 2
 BLVC INFO               ; R0 -> pathname, R1 -> details, R2 -> print buffer
                         ; RETURNS R2 -> end of buffer
d149 1
a149 3
 MOVVC R4, R2              ; Seperate entries with a NEWLINE
 MOVVC R2, #NEWLINE        ;
 STRVCB R2, [ R4 ], #1     ;
d151 1
a151 2
 LDRB R2, [ R1, #OBJECTNAMEOFFSET ]!
 TEQ R2, #0
d153 3
a155 4
more_questing_ok         ; Move past name to start of next entry
 LDRNEB R2, [ R1 ], #1   ;
 TEQNE R2, #0            ;
 BNE more_questing_ok    ;
d157 5
a161 1
 ALIGNREG R1             ; Move R1 to start of next entry
d163 4
d168 6
a173 1
 B another_name_another_day
d175 1
a175 3
;***********
end_of_day
;***********
a176 1
 STRB R2, [ R4, #-1 ]              ; terminate buffer
d178 3
a180 1
 TEQ R8, #0
d182 2
a183 2
 ADREQL R0, NotFound               ; None matched wild spec.
 BEQ Error
d185 2
a186 2
 LDR R0, =:INDEX:buffer            ; Display buffer
 ADD R0, R0, R12                   ;
d188 1
a188 59
 MOV R1, #0                        ;
 MOV R2, #0                        ;
 SWI XOS_PrettyPrint               ;


; --- Any more blocks ---

 LDR R0, tempBlockSize

 CMP   R0, #myblocksize
 MOVLT R0, #myblocksize

 LDR R14, tempLength

 SUBS R14, R14, R0

end_of_info
 SWILE XOS_NewLine                   ;
 GRABALL LE                          ; End of list of names
 BICLES PC, R14, #Overflow_Flag      ;

 STR R14, tempLength

 LDR R2, tempBlock
 ADD R2, R2, #MAX_BLOCKS_BUFFERED
 STR R2, tempBlock

 LDR R0, DiscNumberOfDirectoryInBuffer
 BL FindDiscInBufferList                 ; Found details ?
                                         ; RETURNS r1->buffer

 BCC %BT09

 MOV R6, #2

 BL VeryPreStoreDirectory    ; RETURNS EQ if end of dir reached, else NE

; Was block empty ? Just in case of funny discs, ie/ Revalation

 TEQ  R6, #4
 BEQ  end_of_info

 MOV R2, R0                                ;
 MOV R3, R1                                ;
 MOV R1, R6                                ;
 LDR R0, DiscNumberOfDirectoryInBuffer
 BL AddDirectoryToBuffer      ; R0 = disc, R1 = size, R2 = block, R3->dire

 MOV R1, R3

 B %BT09

MainDirInfo   = "$          DL   "
NAMEDIRECTORY = "Directory"
              = "                      2048  bytes"
              = 0

 ALIGN
CURRENTDIR = "@@",0
a191 2
 ]

a192 1
 [ RISC_OS = 2
d194 1
a194 1
ReadBoot_OS2 ROUT                ; 11
a196 10
; on entry:
;          R0 = 11
;          R2 = memory address to put data at   ( how big ??? )
;          R6 = 0 ( cannot specify a context )

; on exit:
;          --------

; Layout of memory:
;                  < length of name byte >< disc name >< boot option byte >
d199 1
a201 130
;*********************************************************************************
;  R1 must point to full path of CSD
;*********************************************************************************

 LDR R1, =:INDEX:CSD_path



;*********************************************************************************
;  If unset ($ = first char) R5 -> "Unset", R1 = Length
;*********************************************************************************

 LDRB R5, [ R12, R1 ]
 TEQ R5, #"$"
 ADREQ R5, Unset                ; R5 -> "Unset"
 MOVEQ R1, #?Unset              ; R1 = Length of data to copy
 BEQ %FT02                      ;


;*******************
; Make a string ':x', 0 to pass to Dir
;*******************

; R1 -> place to put
; R0 = drive number

 LDRB R0, CurrentDriveNumber
 ADD R1, R12, #:INDEX:OpenedOutString

 MOV R14, #":"
 STRB R14, [ R1 ], #1

; convert R0 to a string in [ R1 ] and DONT FORGET TO TERMINATE !

; R0 = value to be converted
; R1 -> place to put
; R2 = size of buffer

 STASH R2

 MOV R2, #255

 SWI XOS_ConvertCardinal1
 BVS Error

; R0 -> start of buffer + 1
; R1 -> end of string
; R2 = number of bytes free in buffer

 SUB R0, R0, #1

 MOV R14, #"."
 STRB R14, [ R1 ], #1
 MOV R14, #"$"
 STRB R14, [ R1 ], #1
 MOV R14, #0
 STRB R14, [ R1 ]


;*******************

; Dir: R0 -> pathname$
;      RETURN R1 -> block of object info, 0 if not found,
;      RETURN R2 = 1 if a file, 2 if a directory
;      RETURN R3 -> start of disc buffer
;      RETURN R4 = drive number

 MOV R1, #1 ; Looking for a directory
 BL Dir

 TEQ R2, #DIRECTORY          ; If it is a file, or not found then error
 ADRNEL R0, NotFound
 BNE Error


; R1 -> copy from
; R2 -> copy to
; R3 = length of copy

 ADD R1, R3, #DISCNAMEOFFSETINABUFFER
 ADD R2, R12, #:INDEX:TempArea
 MOV R3, #LENGTHOFDISCNAME

 CD_ByteCopy

; cutspace

 ADD R0, R12, #:INDEX:TempArea

 BL CutSpace

 GRAB R2

;*********************************************************************************
;  Calculate R5 -> to discname, R1 length of name
;*********************************************************************************

 MOV R5, R0
 MOV R1, R0

01
 LDRB R3, [R1], #1
 TEQ R3, #0
 BNE %BT01

 SUB R1, R1, R5
 SUB R1, R1, #1


02
 STRB R1, [ R2 ], #1            ; Write length into buffer, R2 -> next free space


;*********************************************************************************
;  Copy exact number of characters in dirname (without 0 terminator) to user buffer
;*********************************************************************************

022
 LDRB R3, [ R5 ], #1            ; R5 -> to next char
 STRB R3, [ R2 ], #1            ; R2 -> to next space in buffer
 SUBS R1, R1, #1                ; No. of bytes to copy
 BNE %BT022

 STRB R6, [ R2 ]                ; boot option = 0


 GRABALL
 BICS PC, R14, #Overflow_Flag

 ]
a203 1
 [ RISC_OS > 2
d253 2
a254 84
        GRABALL
        BICS PC, R14, #Overflow_Flag

 ]






 [ RISC_OS = 2
;**************************************************************************
CurrentDirectory ROUT        ; 12
;**************************************************************************

; on entry:
;          R0 = 12
;          R2 -> place to put information
;          R6 = 0 ( cannot specify a context )

; layout of memory:
; <zero byte> <name length byte> <CSD name> <privilege byte>

 log_on

 STRB R6, [ R2 ], #1


;*********************************************************************************
;  R1 must point to full path of CSD
;*********************************************************************************

 LDR R1, =:INDEX:CSD_path
 ADD R1, R12, R1                ; R1 points to CSD



;*********************************************************************************
;  If CSD is unset ($ = first char) R5 -> "Unset", R1 = Length
;*********************************************************************************

 LDRB R5, [ R1 ]
 TEQ R5, #"$"
 ADREQ R5, Unset                ; R5 -> "Unset"
 MOVEQ R1, #?Unset              ; R1 = Length of data to copy
 BEQ %FT02                      ;



;*********************************************************************************
;  Calculate R5 -> to dirname, R1 length of name
;*********************************************************************************

01                              ; Only return the last branch of the pathname
 LDRB R3, [ R1 ], #1            ; Find where the last dot was
 TEQ R3, #"."                   ;
 MOVEQ R5, R1                   ; R5 -> "dirname"
 TEQ R3, #0                     ;
 BNE %BT01                      ; R1 points to byte after 0 terminator

 SUB R1, R1, R5                 ; ie R1 = (R1 - R5)
 SUB R1, R1, #1                 ;    R1 = Length of "dirname"


02
 STRB R1, [ R2 ], #1            ; Write length into buffer, R2 -> next free space


;*********************************************************************************
;  Copy exact number of characters in dirname (without 0 terminator) to user buffer
;*********************************************************************************

022
 LDRB R3, [ R5 ], #1            ; R5 -> to next char
 STRB R3, [ R2 ], #1            ; R2 -> to next space in buffer
 SUBS R1, R1, #1                ; No. of bytes to copy
 BNE %BT022


 MOV R1, #&00                   ; this gives everyone 'owner' status
 STRB R1, [ R2 ]

 GRABALL
 BICS PC, R14, #Overflow_Flag
a256 15
 ]



 [ RISC_OS = 2                  ; SMC
Unset = 34, "Unset", 34
 GBLA counter
counter SETA 0
 WHILE counter < MAXLENGTHOFNAME - ?Unset + 2
      = HARDSPACE
counter SETA counter + 1
 WEND
 = 0
 ALIGN
 ]
a287 85
 [ RISC_OS = 2
;**************************************************************************
ReadLIBName ROUT         ; 13
;**************************************************************************

 ; see 12, but with LIB path

; on entry:
;          R0 = 12
;          R2 -> place to put information
;          R6 = 0 ( cannot specify a context )

; layout of memory:
; <zero byte> <name length byte> <LIB name> <privilege byte>
 log_on

 STRB R6, [ R2 ], #1


;********************
; R1 must point at lib path for current drive
;********************

 LDRB R5, CurrentDriveNumber
 LDR R1, pointertolibandurd
 MOV R3, #LIBLENGTH
 MLA R1, R3, R5, R1

;********************
; If the library is not set, then R5 -> 'Unset'
; The library is unset if first byte of path = 0
;********************


 LDRB R5, [ R1 ]                ; Is the library set ?
 TEQ R5, #0                     ; [ no ]

 ADREQ R5, Unset                ; R5 -> "Unset"
 MOVEQ R1, #?Unset              ; R1 = Length of data to copy
 BEQ %FT02                      ;


;*********************************************************************************
;  Calculate R5 -> to leaf of the library path, R1 length of name
;*********************************************************************************

01                              ; Only return the last branch of the pathname
 LDRB R3, [ R1 ], #1            ; Find where the last dot was
 TEQ R3, #"."                   ;
 MOVEQ R5, R1                   ; R5 -> "libname"
 TEQ R3, #0                     ;
 BNE %BT01                      ; R1 points to byte after 0 terminator

 SUB R1, R1, R5                 ; ie R1 = (R1 - R5)
 SUB R1, R1, #1                 ;    R1 = Length of "libname"


02
 STRB R1, [ R2 ], #1            ; Write length into buffer, R2 -> next free space


;*********************************************************************************
;  Copy exact number of characters in libname (without 0 terminator) to user buffer
;*********************************************************************************

022
 LDRB R3, [ R5 ], #1            ; R5 -> to next char
 STRB R3, [ R2 ], #1            ; R2 -> to next space in buffer
 SUBS R1, R1, #1                ; No. of bytes to copy
 BNE %BT022


 MOV R1, #&00                   ; this gives everyone 'owner' status
 STRB R1, [ R2 ]


;*********************
; Return to sender
;*********************

 GRABALL
 BICS PC, R14, #Overflow_Flag


 ]
a393 4
 [ RISC_OS=2
 ADRNEL R0, NotFound
 BNE Error
 |
d395 1
a395 2
           BNE        Error
 ]
a403 89
 [ RISC_OS=2


; --- Only bother to search for known details if last<wanted ---

 LDR R14,lastobjectnumber
 LDR R4, [ R13, #4*4 ]

 CMP R14, R4

 BGT dont_want

 LDR R14, lastdiscnumber
 LDR R4, DiscNumberOfDirectoryInBuffer
 TEQ R4, R14
 BNE dont_want

; Is this the same path as searched last time ?

 STASH "R0-R4"

 LDR R1, =:INDEX:lastdirectory
 ADD R1, R1, R12

13

 LDRB R14, [ R0 ], #1
 LDRB R4, [ R1 ], #1
 TEQ R4, #0              ; End of paths together ?
 TEQEQ R14, #0           ; [ yes ]
 BEQ %FT12

 TEQ R4, R14             ; Paths same ?
 BEQ %BT13               ; [ yes ]

12

 TEQ R4, #0              ; End of paths together ?
 TEQEQ R14, #0           ; [ yes ]

 GRAB "R0-R4"

 BNE dont_want

; tempLength-((lastblocknumber-tempBlock)*tempBlockSize)

 LDR R14, lastblocknumber

 LDR R4, tempBlock
 SUBS R4, R14, R4

; --- Decide whether or not to skip first 2 dummy entries in a directory

 MOVEQ R6, #0
 MOVNE R6, #2

 LDR R8, tempBlockSize
 MUL R4, R8, R4

 LDR R8, tempLength
 SUB R8, R8, R4
 STR R8, tempLength

 LDR R8, lastobjectnumber

 STR R14, tempBlock


 ADR R14, I_ll_be_back
 B %FT09

; Keep a copy of the path to look for, so I can find it quickly next time

dont_want ; could be NE or GT here

 MOV R8, #0
 STR R8, lastobjectnumber

 MOV R1, R0
 LDR R2, =:INDEX:lastdirectory
 ADD R2, R2, R12
 MOV R3, #256

 CD_ByteCopy

 ]



d525 1
a525 1
 STR R8, verytemporary
d528 1
a528 1
 LDR R0, verytemporary     ; R3=number of entries read ( matching wildname )
d533 1
a533 1
 MOV R4, R0
d535 1
a535 1
 BICS PC, R14, #Overflow_Flag
d556 1
a556 1
 STRLE R8, verytemporary
a557 1
 LDRLE R3, verytemporary              ; [ yes ]
d560 1
a560 1
 BICLES PC, R14, #Overflow_Flag       ; GETS HERE, BUT AFTER ?
d595 1
a595 1
 BL VeryPreStoreDirectory   ; RETURNS EQ if end of dir reached, else NE
d723 2
a724 1
        MOVS    pc, r14
a732 2
 [ RISC_OS > 2

d771 5
a775 3
 MOVVS       r0, r9
 BLVS        FindDiscNameInList
 MOVVS       r0, r1
d825 1
a825 1
 MOV         r2, r4
d827 1
a827 1
 BICS        pc, r14, #Overflow_Flag
d833 2
a834 2
 GRABALL
 BICS        pc, r14, #Overflow_Flag
a835 1
 ]
a838 2
 [ RISC_OS > 2

d860 2
a861 1
 BICS        pc, r14, #Overflow_Flag
a862 2

 ]
@


4.3
log
@This is a manual merge of CDFS 2.35 from RiscOS/UnU/OS_Core/CDFS/CDFS234
treating nturton_CDFS-2_29 as the branch point.
@
text
@d1133 1
a1133 1
 SWI      XCD_ByteCopy
d1653 1
a1653 1
 SWI     XCD_ByteCopy
d1972 15
@


4.2
log
@  Ursula branch merge, plus srccommit usage.
Detail:
  Merged Ursula branch, it just removed dynamic dependencies from
   Makefile.

  Moved to srccommit, changed lots of occurrences of "Version" to module
   version, as defined in "VersionASM".  Removed old "Version" file.
Admin:
  Added stripdepend call into clean rule.


Version 2.30. Tagged as 'CDFS-2_30'
@
text
@a1357 1
 Debug " 14"
a1379 2
 Debug "ReadLIBName"

a1476 2
 Debug "ObjectInfo "

a1523 7
 [ debug=ON
 STASH R0
 Debug " Pathname passed in = "
 Debug0
 GRAB R0
 ]

a1577 7
 [ debug=ON
 STASH R14
 Debug " offset= "
 DebugDisplay R4
 GRAB R14
 ]

a1716 5
 [ debug=ON
 STASH R14
 Debug " Found start pos "
 GRAB R14
 ]
a1779 6
 [ debug=ON
 STASH R14
 Debug " Filled buffer "
 GRAB R14
 ]

a1801 6
 [ debug=ON
 STASH R14
 Debug " End of directory "
 GRAB R14
 ]

a1832 2
 Debug " 09 "

d1841 4
a1844 2
 MOVCC R6, R1                            ; [ yes ]
 GRAB "R1-R5,R7,PC", CC              ;
d1853 4
a1856 1
; Was block empty ? Just in case of funny discs, ie/ Revalation
d1862 2
a1898 3

 Debug " 19 "

a1991 3


 Debug " ~~CanonicaliseName "
@


4.1
log
@Initial revision
@
text
@d78 1
a78 1
 [ Version >= 220
d93 1
a93 1
 [ Version >= 220
d154 1
a154 1
;--- 
d166 1
a166 1
  [ Version >= 202
d182 1
a182 1
 [ Version < 220
d793 1
a793 1
; R6 -> 
d808 1
a808 1
 MOV R8, R1                 ; R8 -> 
d1144 1
a1144 1
;  Calculate R5 -> to discname, R1 length of name  
d1204 1
a1204 1
        ADD         r1, r1, #DISCNAMEOFFSETINABUFFER 
d1207 1
a1207 1
; Copy the name into a RISC OS buffer 
d1267 1
a1267 1
 
d1282 1
a1282 1
;  Calculate R5 -> to dirname, R1 length of name  
d1410 1
a1410 1
;  Calculate R5 -> to leaf of the library path, R1 length of name  
d2065 1
a2065 1
 ADD         r1, r1, #DISCNAMEOFFSETINABUFFER 
d2127 1
a2127 1
; on exit: 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

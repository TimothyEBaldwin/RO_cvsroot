head	4.15;
access;
symbols
	ADFS-3_54:4.15
	ADFS-3_53:4.15
	ADFS-3_52:4.14
	ADFS-3_51:4.14
	ADFS-3_50:4.13
	ADFS-3_49:4.12
	ADFS-3_48:4.12
	ADFS-3_47:4.12
	ADFS-3_46:4.12
	ADFS-3_45:4.10
	ADFS-3_44:4.9
	ADFS-3_43:4.9
	ADFS-3_42:4.9
	ADFS-3_41:4.9
	ADFS-3_40:4.8
	ADFS-3_39:4.8
	ADFS-3_38:4.8
	ADFS-3_37:4.7
	ADFS-3_36:4.6
	RO_5_07:4.6
	ADFS-3_35:4.6
	ADFS-3_34:4.4
	ADFS-3_33:4.2
	dellis_autobuild_BaseSW:4.2
	ADFS-3_32:4.2
	Ursula_merge:4.2
	Ursula_RiscPC_merge:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.2
	sbrodie_UrsulaRiscPC_ADFS-3_30:4.2
	Ursula_RiscPC_bp:4.2
	nturton_ADFS-3_29:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	sproven_ADFS-3_31:4.2.2.1
	nicke_ADFS_3_26:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	sproven_330:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2017.07.15.15.15.09;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	HV4MfWKq4QocZkZz;

4.14
date	2016.01.10.00.06.44;	author jlee;	state Exp;
branches;
next	4.13;
commitid	26rNliXrGuQCHjQy;

4.13
date	2016.01.05.21.49.10;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	els1sSTqH2Im4NPy;

4.12
date	2012.10.21.16.27.50;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	ReyUVZewswdRVgpw;

4.11
date	2012.10.21.11.42.56;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	yOiiX7g8HT2Zlfpw;

4.10
date	2012.10.21.11.38.09;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	L8DklCrHdjSrkfpw;

4.9
date	2011.10.14.07.38.46;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	tK3tjaAo92QGZhDv;

4.8
date	2011.06.22.01.01.02;	author jlee;	state Exp;
branches;
next	4.7;
commitid	CpEhHiDhv8LssBov;

4.7
date	2010.12.06.14.14.47;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2003.04.03.18.47.57;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2003.01.28.15.14.02;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2003.01.17.19.33.27;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2002.09.18.15.03.29;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.00.24;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.31.19;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	98.09.02.18.37.29;	author sproven;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.31.19;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.35.16;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.28.56;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.24.27;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.15
log
@Calculate the offset to the hardware-dependent information
Don't assume that the disc address to MiscOp_Mount is always &C00, in order to locate the hardware-dependent information (see PRM 2-215), calculate the offset properly. This fixes a problem that FileCore 3.74 triggered where the LBA flag was no longer being recovered now the alignment of the request in R2 has changed, causing some drives to no longer mount if they also don't support CHS addressing.
Strictly speaking there's no guarantee that FileCore is even asking for the boot block at all; ADFS should read the sectors itself before fulfilling the request, but historically it's always assumed that the boot block was being read, so let sleeping dogs lie.
Ref https://www.riscosopen.org/forum/forums/4/topics/9390

Version 3.53. Tagged as 'ADFS-3_53'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    Hard disc driver common entry points etc. -> Adfs12

; Change record
; =============
;
; CDP - Christopher Partington, Cambridge Systems Design
; LVR - Lawrence Rust, Cambridge Beacon
;
; 25-Oct-90
; ADFS version 2.06
;
; 28-Nov-90         LVR
; File created. Winchester entry point code split from other source
; files to facilitate addition of IDE drivers.
;
; 30-Nov-90  18:00  CDP
; Minor changes to make existing drivers compatible with previous
; version of ADFS (conditionals removed by LR added back, comments
; corrected).
;
; 07-Jan-91  10:00  CDP
; IDE driver started.
;
; 11-Mar-91  15:48  CDP
; DoSwiWinControllerType now assumes that the drive number passed is >3.
; 82710 initialisation, commented out when drivers merged, now removed.
; Code using MachineID adjusted to use new values.
;
; 12-Mar-91  11:33  CDP
; IDE power state variables initialised. This will need to be changed
; when the initial power state is read from CMOS.
;
; 12-Mar-91  14:05  CDP
; Added WinIDEPoduleDying.
;
; 18-Mar-91  18:03  CDP
; Initialisation of WinIDECommandActive added.
;
; 20-Mar-91  13:01  CDP
; Added code to read power state from CMOS and setup a timer event
; to initialise drives when they become ready.
;
; 27-Mar-91  10:36  CDP
; Added initialisation of WinIDEPowerSetupActive so PowerSetup can tell
; when it has added a callback to remove itself and avoid doing it again.
;
; 08-Apr-91  17:22  CDP
; Internationalised error return from DoSwiWinControllerType.
; Now installs WinIDEPowerSetup even if there appears to be no IDE
; controller (but IDEdrives configured != 0). Podule will notify driver
; of its presence later and the power setup stuff must run then.
;
; 10-Jan-92  12:01  CDP
; The way FileCore mounts a disc has been changed and it no longer provides
; the defect list read from the disc by the mount entry when reading other
; bits of the disc when trying to understand the disc format. The IDE driver
; used this to access the drive init flag so that InitDriveParms could be
; issued before accessing other bits of the disc. The driver has now been
; changed to save the flag from the data read by the mount as FileCore is
; guaranteed to read the boot block by the call to the mount entry.
; WinLowLevel/WinMount changed to clear/set flag to indicate mount before
; calling WinLowLevelIDE. WinMount changed to extract init flag from data
; read from disc.
;
; 09-Mar-92  16:50  CDP
; Mount changed again as FileCore does two reads of the boot block before
; validating it and the second read was causing the driver to initialise
; the drive (only a problem with discs with a trashed boot block).
; Driver now validates the boot block itself in the Mount entry.
;
; 02-Apr-92  16:18  CDP
; WinInit now zeroes WinIDEDriveSecsPerTrk for each drive.
; Mount entry now saves drive parameters from (validated) boot block so that
; any op following reset of drive will reinit drive shape.
;
; 06-12-94 16:49 SBP
; WinMount altered so that init flag in debug output is shown correctly.
;
;*End of change record*

;*********************************************************************
;
; This file contains the following routines:
;
; WinInit
;    Initialise the driver.
;    Called when the module receives the initialization call.
;
; WinDie
;    Shutdown the driver.
;    Called when the module receives a finalisation call.
;
; WinReset
;    Called when the module receives a post reset service call.
;
; WinIDEPoduleDying
;    Called when the module receives an IDE podule dying service call.
;
; WinLowLevel
;    Called when the module receives a FileCore low-level call with a
;    drive number in the range 4 to 7.
;
; WinMount
;    Called when the module receives a FileCore miscellaneous call
;    with a reason code of 0 (R0 = 0, mount disc).
;
; WinUpdateCMOSMapSize
;    Updates the approximate map size of a disc, held in CMOS RAM.
;
; DoSwiWinControllerType
;    Returns the controller type of a hard disc.
;
;*********************************************************************

        GBLS    GetDebugIDE

 [ Debug20
GetDebugIDE     SETS    "GET     s.DebugIDE"
 |
GetDebugIDE     SETS    "; IDE debugging routines not required"
 ]

        $GetDebugIDE

;*********************************************************************

WinInit ROUT
;
; Initialize the driver.
; Called when the module receives the initialization call.
;
; Entry:
;    R4  = bit map from CMOS giving number of IDE and ST506 hard discs
;    R11 = -> Instantiation number, 0= first init
;    SB  = -> Local storage
;    LR  = Return address
;
; Exit:
;    VC => no error
;          R0 undefined
;          R1 = No. of responding drives
;          WinnieSizes = approx map sizes (1 byte per drive)
;    VS => error
;          R0 -> error pointer/code
;          R1 undefined
;    R2 undefined

        Push    "R3-R9,LR"              ; Save caller's regs

 [ Debug21
        DREG    R4,"WinInit: R4="
        LDR     R0,MachineID
        DREG    R0,"MachineID:"
 ]

; Initialise variables - this could be moved to the preinitialised
; data area to save space.

; Invalidate the IDE data transfer code sitting in RAM

        MOV     R0,#&FF
        STRB    R0,WinIDERAMOp

; Set IDE features to 0

        MOV     R0,#0
        STRB    R0,WinIDEPrecomp

; Indicate not currently in IDE IRQ
; R0 = 0

        STRB    R0,WinIDEIRQFlag

; Indicate no cmd currently running
; R0 = 0

        STR     R0,WinIDECommandActive

 [ IDEDMA
; Zero out our sector-padding data
        sbaddr  LR,WinIDEDMAZeroes
        MOV     R1,#?WinIDEDMAZeroes
01      STR     R0,[LR],#4
        SUBS    R1,R1,#4
        BNE     %BT01

        STR     R0,WinIDECopiedScatterList
        STR     R0,WinIDECopiedScatterSize
 ]

; Flag both IDE drives not initialised
; R0 = 0

        ASSERT  WinIDEDriveStateReset = 0
 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
        ASSERT  WinIDEMaxDrives = 2
 ]
        STRB    R0,WinIDEDriveState+0
        STRB    R0,WinIDEDriveState+1
 [ TwinIDEHardware
        STRB    R0,WinIDEDriveState+2
        STRB    R0,WinIDEDriveState+3
 ]

; Zero SecPerTrk for each drive to indicate not valid
; R0 = 0

 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
        ASSERT  WinIDEMaxDrives = 2
 ]
        STRB    R0,WinIDEDriveSecsPerTrk+0
        STRB    R0,WinIDEDriveSecsPerTrk+1
 [ TwinIDEHardware
        STRB    R0,WinIDEDriveSecsPerTrk+2
        STRB    R0,WinIDEDriveSecsPerTrk+3
 ]

; Initialise IDE hardware flag
; R0 = 0

        STRB    R0,WinIDEHardware+WinIDEIRQDevNo       ; no hardware yet
 [ TwinIDEHardware
        STRB    R0,WinIDEHardware+SzWinIDEHardware+WinIDEIRQDevNo
 ]

; Split configured IDE and ST506 drives from passed parameter


        AND     R0,R4,#2_00000111       ; mask to get ST506 drives
        STRB    R0,Winnies              ; save ST506 drives
 [ :LNOT:AutoDetectIDE
        MOV     R4,R4,LSR #3            ; shift to get IDE drives
        STRB    R4,WinIDEDrives

; See if there's any IDE to setup

        TEQS    R4,#0                   ; any?
        BEQ     %FT20                   ; branch if not (R4=0)
 ]

; Some configured IDE drives
; Claim TickerV to do timers

        BL      WinClaimTickerV         ; (->R0,V)
        BVS     %FT80                   ; branch if error

 [ HAL
      [ IDEDMA
        SUB     SP,SP,#4*4
        MOV     R3,#4*4
        MOV     R2,SP
        MOV     R1,#-1
        LDR     R0,HAL_IDEDevice_pointer
        Push    "R12"
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_IDEControllerInfo]
        Pull    "R12"
        MOV     R6,#0
        CMPVC   R0,#4*4
        SETV    LO
        ADD     SP,SP,#4
        Pull    "R0-R2"
        BLVC    CreateBusMaster
        STR     R6,WinIDEDMADeviceHandle

        SUB     SP,SP,#12*4
        MOV     R3,#12*4
      |
        SUB     SP,SP,#8*4
        MOV     R3,#8*4
      ]
        MOV     R2,SP
        MOV     R1,#0                   ; bus 0
        LDR     R0,HAL_IDEDevice_pointer
        Push    "R12"
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_IDEControllerInfo]
        Pull    "R12"
        Pull    "R2-R8,R14"
        BVS     %FT05
        CMP     R0,#8*4
        BLO     %FT05

        ADR     R9,WinIDEHardware
        STR     R2,[R9,#WinIDEHWFlags]
        STR     R3,[R9,#WinIDEPtr]
        STR     R4,[R9,#WinIDECtrlPtr]
        STRB    R6,[R9,#WinIDEHWDevNo]

        TST     R2,#WinIDEHWFlag_32bitPIO
        ADDR    R7,WinIDEReadASector,EQ
        ADDR    R7,WinIDEReadASector32,NE
        STR     R7,[R9,#WinIDEReadPtr]
        ADDR    R7,WinIDEWriteASector,EQ
        ADDR    R7,WinIDEWriteASector32,NE
        STR     R7,[R9,#WinIDEWritePtr]

        MOV     R14,#WinIDEHW_HAL
        STRB    R14,[R9,#WinIDEHWType]
        MOV     R14,#0
        STRB    R14,[R9,#WinIDEBusNo]

      [ IDEDMA
        MOV     R1,R0
      ]
        MOV     R0,#0
        BL      WinIDESetDefaultTimings

        TEQ     R3,#0
        BLNE    WinClaimIDEIRQs
        BVS     %FT80

      [ IDEDMA
        Push    "R1-R5"
        ADDR    R0, WinIDEDMAEnable
        ADDR    R1, WinIDEDMADisable
        ADDR    R2, WinIDEDMAStart
        ADDR    R3, WinIDEDMACompleted
        ADDR    R4, WinIDEDMASync
        ADR     R5, WinIDEDMAHandlers
        STMIA   R5, {R0-R4}
        Pull    "R1-R5"
      ]

        MOV     R0,#0                   ; -SRST IEN
        STRB    R0,[R4,#:INDEX:IDERegDevCtrl]

      [ IDEDMA
        CMP     R1,#12*4
        LDRHS   R0,[SP,#3*4]
        CMPHS   R0,#-1
        MOVEQ   R0,#1
        SWIEQ   XDMA_AllocateLogicalChannels
        MOV     R3,R0
        STR     R3,[R9,#WinIDEDMALC]
        Pull    "R0-R2"                 ; R5 already set up
        ADD     SP,SP,#4
        LDR     R6,WinIDEDMADeviceHandle
        CMP     R1,#12*4
        BLHS    AddBusMasterChannel
      ]

 [ TwinIDEHardware
      [ IDEDMA
        SUB     SP,SP,#12*4
        MOV     R3,#12*4
      |
        SUB     SP,SP,#8*4
        MOV     R3,#8*4
      ]
        MOV     R2,SP
        MOV     R1,#1                   ; bus 1
        LDR     R0,HAL_IDEDevice_pointer
        Push    "R12"
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_IDEControllerInfo]
        Pull    "R12"
        Pull    "R2-R8,R14"
        BVS     %FT05
        CMP     R0,#32
        BLO     %FT05

        ADR     R9,WinIDEHardware + SzWinIDEHardware
        STR     R2,[R9,#WinIDEHWFlags]
        STR     R3,[R9,#WinIDEPtr]
        STR     R4,[R9,#WinIDECtrlPtr]
        STRB    R6,[R9,#WinIDEHWDevNo]

        TST     R2,#WinIDEHWFlag_32bitPIO
        ADDR    R7,WinIDEReadASector,EQ
        ADDR    R7,WinIDEReadASector32,NE
        STR     R7,[R9,#WinIDEReadPtr]
        ADDR    R7,WinIDEWriteASector,EQ
        ADDR    R7,WinIDEWriteASector32,NE
        STR     R7,[R9,#WinIDEWritePtr]

        MOV     R14,#WinIDEHW_HAL
        STRB    R14,[R9,#WinIDEHWType]
        MOV     R14,#1
        STRB    R14,[R9,#WinIDEBusNo]

      [ IDEDMA
        MOV     R1,R0
      ]
        MOV     R0,#2
        BL      WinIDESetDefaultTimings

        TEQ     R3,#0
        BLNE    WinClaimIDEIRQs
        BVS     %FT80

        MOV     R0,#0                   ; -SRST IEN
        STRB    R0,[R4,#:INDEX:IDERegDevCtrl]

      [ IDEDMA
        CMP     R1,#12*4
        LDRHS   R0,[SP,#3*4]
        CMPHS   R0,#-1
        MOVEQ   R0,#1
        SWIEQ   XDMA_AllocateLogicalChannels
        MOV     R3,R0
        STR     R3,[R9,#WinIDEDMALC]
        Pull    "R0-R2"                 ; R5 already set up
        ADD     SP,SP,#4
        LDR     R6,WinIDEDMADeviceHandle
        CMP     R1,#12*4
        BLHS    AddBusMasterChannel
      ]
 ]
      [ IDEDMA
        TEQ     R6,#0
        BLNE    RegisterBusMaster

        ADR     R9,WinIDEHardware
        BL      WinIDERegisterDMAChannel
       [ TwinIDEHardware
        ADR     R9,WinIDEHardware + SzWinIDEHardware
        BL      WinIDERegisterDMAChannel
       ]
      ]

 [ :LNOT:AutoDetectIDE
        LDRB    R4,WinIDEDrives         ; needed later
        B       %FT15
 ]

05
 ]

 [ ByteAddressedHW
        B       %FT15                   ; no alternative to HAL call (yet?)
 |
; Set up regs to point to default (motherboard) IDE hardware

 [ HAL
        sbaddr  R9,WinIDEHardware
        ADD     R1,R9,#WinIDEPtr
 |
        baddr   R1,DefaultIDEHardware
 ]
        LDMIA   R1,{R2-R6}
        MOV     R7,#0                   ; initialise data in ptr
        MOV     R8,#0                   ; and data out ptr

; Issue a service call to let an IDE podule change the registers to
; point to its hardware

        LDR     R1,=Service_ADFSPoduleIDE
        SWI     XOS_ServiceCall

 [ Debug21
        DREG    R1,"Service_ADFSPoduleIDE:R1:"
 ]

; If IDE podule present, regs will have been changed to point to
; podule hardware info
; Sort out the pointers to the data transfer routines

        TEQS    R7,#0                   ; default data in routine?
        ADDR    R7,WinIDEReadASector,EQ ; if yes, set it up
        TEQS    R8,#0                   ; default data out routine?
        ADDR    R8,WinIDEWriteASector,EQ ; if yes, set it up

 [ HAL
        TEQ     R1,#Service_Serviced
        BNE     %FT15                   ; no IDE podule present

        ADD     R14,R9,#WinIDEPtr
 |
        LDR     R14, =DefaultIDE
 ]
        TEQ     R2, R14
 [ HAL
        MOVEQ   R14, #IOMD_IDE_DevNo
 [ Override_PDevNo <> -1
        MOVNE   R14, #Override_PDevNo
 |
        MOVNE   R14, #Podule_DevNo
 ]
        STRB    R14, WinIDEHardware+WinIDEHWDevNo
 ]
        MOVEQ   R14, #WinIDEHW_Default
        MOVNE   R14, #WinIDEHW_Podule

; Save info

      [ HAL
        ASSERT  WinIDEPtr = 4
      |
        ASSERT  WinIDEPtr = 0
      ]
        ASSERT  WinIDEPollPtr = WinIDEPtr + 4
        ASSERT  WinIDEPollBits = WinIDEPollPtr + 4
        ASSERT  WinIDEIRQPtr = WinIDEPollBits + 4
        ASSERT  WinIDEIRQBits = WinIDEIRQPtr + 4
        ASSERT  WinIDEReadPtr = WinIDEIRQBits + 4
        ASSERT  WinIDEWritePtr = WinIDEReadPtr + 4

        sbaddr  R9,WinIDEHardware
      [ HAL
        STMIB   R9,{R2-R8}
      |
        STMIA   R9,{R2-R8}
      ]
        STRB    R14,WinIDEHardware+WinIDEHWType

 [ HAL
        ADD     R14,R2,#IDERegCtlDefaultOffset
        STR     R14,WinIDEHardware+WinIDECtrlPtr
 ]

; Check whether there really is IDE hardware to talk to (yet - podule
; may tell us about it later).
; Set R4 = configured drives as, even if we find no hardware, podule may
; tell us later about it and we must have allowed for it

        LDRB    R4,WinIDEDrives         ; needed later

; IF service call claimed OR 710-based machine THEN IDE present

        TEQS    R1,#Service_Serviced    ; service call claimed? EQ => claimed
        LDRNE   R1,MachineID            ; not claimed, IDE on motherboard?
        TEQNES  R1,#MachHas82710        ; EQ => yes
        BNE     %FT15                   ; if no IDE yet, branch
                                        ; (assume podule will appear later)
 ]

10
; Some IDE hardware present - claim the device vector

        BL      WinClaimIDEIRQs         ; (R9->R0,V)
        BVS     %FT80                   ; branch if error

; Enable interrupts in the controller.
; This is ok as it is not until the IRQ is enabled in IOC or on the
; podule that it will actually be able to interrupt.

 [ HAL
        LDR     R2,WinIDEHardware+WinIDECtrlPtr
 ]
        MOV     R0,#0                   ; -SRST IEN
        STRB    R0,[R2,#:INDEX:IDERegDevCtrl]

15
; Read CMOS spin down delay and save

        MOV     R0,#OsByte_ReadCMOS
        MOV     R1,#ADFSSpinDownCMOS
        SWI     XOS_Byte                ; (R0,R1->R2,V)
        MOVVS   R2,#0                   ; if error, spindown = 0
 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
        ASSERT  WinIDEMaxDrives = 2
 ]
        STRB    R2,WinIDEPowerState+0
        STRB    R2,WinIDEPowerState+1
 [ TwinIDEHardware
        STRB    R2,WinIDEPowerState+2
        STRB    R2,WinIDEPowerState+3
 ]

; If the power state indicates that the drives should have
; autospindown enabled, install handler to do this when they become
; ready.
; R2 = spindown parameter, 0 => no spindown

        STRB    R2,WinIDEPowerSetupActive ; so can tell when to remove it
                                        ; !0 => not removed
        TEQS    R2,#0                   ; need to add CallEvery?
        MOVNE   R0,#100                 ; if so, R0 = centisecond count
        ADDR    R1,WinIDEPowerSetup,NE  ; ...R1 -> handler
        MOVNE   R2,SB                   ; ...R2 = R12 value
        SWINE   XOS_CallEvery           ; ...(R0-R2->V) ignore error

 [ IDEPower
; Iff on a portable - set up a handler to examine the Winnie, on finding it spun down,
;                     the handler will power down the drive and interface.
;
        SWI     XPortable_ReadFeatures  ;returns flags in R1
        BVS     %FT20                   ;VS: not a portable, so skip handler setup code

        MOV     R0,#1000                ; R0 = centisecond count (10 seconds)
        ADDR    R1,WinIDEPowerShutdown  ; ...R1 -> handler
        MOV     R2,SB                   ; ...R2 = R12 value
        SWI     XOS_CallEvery           ; ...(R0-R2->V) ignore error
 ]

20
 [ AutoDetectIDE
        BL      ProbeIDEDevices
        STRB    R4, WinIDEDrives
 ]
; R4 = number of IDE drives present

; Set up the drive map to indicate which driver should be called
; for each logical drive

        LDR     R1,MachineID
        LDRB    R2,Winnies              ; ST506 drives

; R1=0 => ST506-based machine
; R2 = ST506 drives
; R4 = IDE drives

        TEQS    R1,#MachHas82710        ; 710 based machine?

        MOVEQ   R5,#0                   ; yes, IDE starts at 0...
        MOVEQ   R3,R4                   ; ...ST506 after

        MOVNE   R3,#0                   ; no, ST506 starts at 0...
        MOVNE   R5,R2                   ; ...IDE after

; R2 = ST506 drives
; R3 = logical drive number start for ST506
; R4 = IDE drives
; R5 = logical drive number start for IDE

        ADR     R1,WinDriveTypes
        MVN     R0,#0                   ; R0 = &FFFFFFFF
        STR     R0,[R1]

        ADD     R3,R3,R1
        ADD     R5,R5,R1

; R3 -> where ST506 drives should go
; R5 -> where IDE drives should go

; Do ST506 drives
; These are stored with &08 ORred into them so that, when shifted to
; bits 31..29 as for a FileCore op, carry is set to indicate ST506.

        TEQS    R2,#0                   ; any ST506 drives?
        MOVNE   R0,#8                   ; yes, store &08 for first...
        STRNEB  R0,[R3,#0]

        TEQS    R2,#2                   ; 2 drives?
        MOVEQ   R0,#9                   ; yes, store &09 for second
        STREQB  R0,[R3,#1]

; do IDE drives

 [ AutoDetectIDE
        MOV     LR,#0
        sbaddr  R3,WinIDEDeviceMappings
30      LDRB    R0,[R3,LR]
 [ Debug23
        DREG    LR, "Physical drive ",cc,Integer
        BREG    R0, " has class "
 ]
        TEQ     R0,#0
        BNE     %FT35
        SUB     R0,R5,R1
        ADD     R0,R0,#4
        STRB    R0,[R3,LR]
        STRB    LR,[R5],#1
 [ Debug23
        DREG    R0, "Logical drive ",cc,Integer
        DREG    LR, " is IDE physical drive ",,Integer
 ]
35
        ADD     LR,LR,#1
        CMP     LR,#WinIDEMaxDrives
        BLO     %BT30
 |
        CMPS    R4,#1                   ; any IDE drives?
        MOVHS   R0,#0                   ; yes, store &00 for first
        STRHSB  R0,[R5,#0]

        MOVHI   R0,#1                   ; 2 drives?
        STRHSB  R0,[R5,#1]              ; yes, store &01 for second

 [ TwinIDEHardware
        CMPS    R4,#3                   ; 3 drives?
        MOVHS   R0,#2                   ; yes, store &02 for third
        STRHSB  R0,[R5,#2]

        MOVHI   R0,#3                   ; 4 drives?
        STRHSB  R0,[R5,#3]              ; yes, store &03 for fourth
 ]
 ]

; save total drives

        ADD     R4,R4,R2                ; R4 = ST506 + IDE drives

; Read approx map sizes from CMOS and save them
; ***** contrary to comments here and elsewhere,
; ***** the next call NEVER returns error

 [ :LNOT:BigDisc
        BL      ReadWinnieSizeCMOS      ;(->R0,R6,V)
        STR     R6,WinnieSizes          ; Save approx map size
 ]

        MOV     R1,R4                   ; Return no. of drives from CMOS
        sbaddr  LR,WinIDEDriveLBAFlags  ;
        MOV     R3,#0                   ; clear LBA usage flags
        STRB    R3,[LR]
        STRB    R3,[LR,#1]

 [ AutoDetectIDE
        MOV     R0, #0
        BL      WinIDESetTimings
  [ TwinIDEHardware
        MOV     R0, #2
        BL      WinIDESetTimings
  ]
 ]

        CLRV
        Pull    "R3-R9,PC"              ; Return to caller with no error

;****** Never fall through

80
; Error initialising IDE

        Push    "R0"                    ; save error pointer
        BL      WinDie                  ; release vectors
        SETV
        Pull    "R0,R3-R9,PC"           ; return error

        LTORG

;*********************************************************************

WinDie  ROUT
;
; Shutdown the driver.
; Called when the module receives a finalisation call.
;
; Entry:
;    R11 = -> Instantiation number
;    SB  = -> Local storage
;    LR  = Return address
;
; Exit:
;    All registers preserved
;    Flags undefined

        Push    "R0,R9,LR"

 [ Debug21

        DLINE   "WinDie"
 ]

 [ :LNOT: AutoDetectIDE
; check if any IDE drives and ignore rest if none

        LDRB    LR,WinIDEDrives         ; any IDE drives?
        TEQS    LR,#0
        Pull    "R0,R9,PC",EQ           ; return if not
 ]

; release the device vector for the IDE driver (if owned)

        sbaddr  R9,WinIDEHardware
        BL      WinReleaseIDEIRQs       ; (R9->R0,V)
 [ IDEDMA
        BL      WinIDEDeregisterDMAChannel
 ]
 [ TwinIDEHardware
        ADD     R9,R9,#SzWinIDEHardware
        BL      WinReleaseIDEIRQs       ; (R9->R0,V)
 [ IDEDMA
        BL      WinIDEDeregisterDMAChannel
 ]
 ]

 [ IDEDMA
        Push    "R2,R6"

; deregister DMA devices (if registered)
        LDR     R6,WinIDEDMADeviceHandle
        TEQ     R6,#0
        BLNE    DeleteBusMaster

; free up our copied scatter list
        MOV     R0,#ModHandReason_Free
        LDR     R2,WinIDECopiedScatterList
        TEQ     R2,#0
        SWINE   XOS_Module

        Pull    "R2,R6"
 ]

; release TickerV (if owned)

        BL      WinReleaseTickerV       ; (->R0,V)

; remove the power setup routine (it may not be installed)

        BL      WinIDEKillPowerSetup    ; all regs/flags preserved
 [ IDEPower
        BL      WinIDEKillPowerShutdown ; all regs/flags preserved
 ]
        Pull    "R0,R9,PC"

;*********************************************************************

WinReset        ROUT
;
; Called when the module receives a post reset service call.
;
; Entry:
;    R11 = -> Instantiation number
;    SB  = -> static workspace
;    LR  = Return address
;
; Exit:
;    All registers preserved
;    Flags undefined

        Push    "R0,R9,LR"              ; Save caller's regs

 [ Debug21

        DLINE   "WinReset"
 ]

        MOV     LR,#&FF                 ; HDC has been reset
        STRB    LR,SpecifiedWinnie

10
 [ :LNOT: AutoDetectIDE
; Check if IDE drives configured

        LDRB    LR,WinIDEDrives
        TEQS    LR,#0
        Pull    "R0,R9,PC",EQ
 ]

; IDE drives configured

; Indicate not currently in IDE IRQ

        MOV     R0,#0
        STRB    R0,WinIDEIRQFlag

; Flag drives as not initialised as, on a soft reset, the init code will
; not have been called but the drives will still have been reset
; R0 = 0

        ASSERT  WinIDEDriveStateReset = 0
 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
        ASSERT  WinIDEMaxDrives = 2
 ]
        STRB    R0,WinIDEDriveState+0
        STRB    R0,WinIDEDriveState+1
 [ TwinIDEHardware
        STRB    R0,WinIDEDriveState+2
        STRB    R0,WinIDEDriveState+3
 ]

; Release and reclaim Tickerv

        BL      WinReleaseTickerV       ; (->R0,V)
        BL      WinClaimTickerV         ; (->R0,V)

; If we have a device, release and reclaim it

        sbaddr  R9,WinIDEHardware
        LDRB    R0,[R9,#WinIDEIRQDevNo]
        TEQS    R0,#0                   ; got device?
        BEQ     %FT30

; Got a device so release and reclaim it

        BL      WinReleaseIDEIRQs       ; (R9->R0,V)
        BL      WinClaimIDEIRQs         ; (R9->R0,V)

 [ IDEDMA
        BL      WinIDEDeregisterDMAChannel
        BL      WinIDERegisterDMAChannel
 ]

30
 [ TwinIDEHardware
        ADD     R9,R9,#SzWinIDEHardware
        LDRB    R0,[R9,#WinIDEIRQDevNo]
        TEQS    R0,#0                   ; got device?
        Pull    "R0,R9,PC",EQ

; Got a device so release and reclaim it

        BL      WinReleaseIDEIRQs       ; (R9->R0,V)
        BL      WinClaimIDEIRQs         ; (R9->R0,V)

 [ IDEDMA
        BL      WinIDEDeregisterDMAChannel
        BL      WinIDERegisterDMAChannel
 ]
 ]

        Pull    "R0,R9,PC"              ; Return to caller

;*********************************************************************

WinIDEPoduleDying       ROUT
;
; Called when the module receives an IDE podule dying service call.
;
; Entry:
;    R11 = -> Instantiation number
;    SB  = -> static workspace
;    LR  = Return address
;
; Exit:
;    All registers and flags preserved

        Push    "R0,R9,LR"

; Ignore all this if no drives configured

        LDRB    R0,WinIDEDrives
        TEQS    R0,#0
        Pull    "R0,R9,PC",EQ

; Some IDE drives configured
; If currently using a device, release its IRQ

        sbaddr  R9,WinIDEHardware
        BL      WinReleaseIDEIRQs       ; (->R0,V)

; If release failed, must still stop hardware being used so
; set device number to 0

        MOVVS   R0,#0
        STRVSB  R0,[R9,#WinIDEIRQDevNo]

        Pull    "R0,R9,PC"

;*********************************************************************

WinLowLevel  ROUT
;
; Called when the module receives a FileCore low-level call with a
; drive number in the range 4 to 7.
;
; Entry:
;    R1 = b0-3: reason code
;            0= verify, 1= read, 2= write sectors
;            3= verify track, 4= format track,
;            5= Seek, 6= Restore, 7= Step in, 8= Step out,
;            15= specify
;         b4 = Alternate defect map
;         b5 = R3 -> scatter list
;         b6 = Ignore escape
;         b7 = No ready timeout
;         b8 = Background op
 [ BigDisc
;    R2 = sector disc address (sector/track aligned),
 |
;    R2 = byte disc address (sector/track aligned),
 ]
;         top 3 bits = drive (4..7, not 0..3)
;    R3 -> transfer buffer
;    R4 = length in bytes
;    R5 -> disc record
;    R6 -> defect list
;    R12 = SB
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0 (definition)
;    R2 = disc address of next byte to transfer
;    R3 -> Next buffer address
;    R4 = Number of bytes left in buffer


        Push    "R5-R9,LR"                      ; Save caller's regs


 [ Debug21
        DREG    R0,"WinLowLevel: R0-R6: ",cc
        DREG    R1,,cc
        DREG    R2,,cc
        DREG    R3,,cc
        DREG    R4,,cc
        DREG    R5,,cc
        DREG    R6
 ]

 [ :LNOT: BigDisc
; Check that map size held in CMOS is up-to-date and correct it if not

        LDRB    R9,[R5,#Zones]          ; get number of zones on disc
        LDRB    R8,[R5,#SectorSize]     ; and sector size (log2)
        MOV     R8,R9,LSL R8            ; get number of bits for zone (number of zones x size of sector)
        MOVS    R8,R8,LSR #8            ; make into number of bytes(?)
        MOVEQ   R8,#2                   ; if zero, then make 2.
        sbaddr  R7,WinnieSizes-4        ;
        LDRB    LR,[R7,R2,LSR #(32-3)]  ;
        TEQS    LR,R8                   ; if not same as old cmos value...
        BLNE    WinUpdateCMOSMapSize    ; ...go update it
 ]

; Determine which driver (ST506/IDE) should handle this
; and the physical drive number

        MOV     R0,R2,LSR #(32-3)               ; R0 = drive 4..7
        STRB    R0,WinLogicalDrive              ; save it

        ADD     R0,R0,#:INDEX:WinDriveTypes - 4
        LDRB    R0,[SB,R0]                      ; get code for this drive
        BIC     R2,R2,#DiscBits                 ; remove disc bits
        ORRS    R2,R2,R0,LSL #(32-3)            ; put in drive number
                                                ; will set carry if ST506

; Call the driver C=1 => ST506
; The disc address passed to the driver includes a physical drive number,
; not the logical drive number passed by FileCore. The drivers return
; with the LOGICAL drive number substituted back in. That substitution
; is done in the driver rather than here because other things e.g. process
; error may also need to include it and that is best done in the
; driver.

        BL      WinLowLevelIDE

;~~~~~~~~~~~~~~~

10

; Calls to drivers return here
; Don't need to put logical drive number back in disc address as
; driver will have done so.

 [ Debug21
        DREG    R0,"LowLevel end R0-R4: ",cc
        DREG    R1,,cc
        DREG    R2,,cc
        DREG    R3,,cc
        DREG    R4
 ]
        Pull    "R5-R9,PC"

;*********************************************************************

WinMount        ROUT
;
; Called when the module receives a FileCore miscellaneous call
; with a reason code of 0 (R0 = 0, mount disc).
;
; Entry:
;    R0 = 0
;    R1 = drive (4..7)
;    R2 = disc byte address to read (sector aligned)
;    R3 -> transfer buffer (word aligned)
;    R4 = length in bytes
;   (R5 -> disc record to fill in: floppies only)
;    R12 = SB
;    LR = Return address
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 undefined
;    All other registers preserved

 [ Debug21
        DREG    R1,"WinMount R1-R5: ",cc
        DREG    R2,,cc
        DREG    R3,,cc
        DREG    R4,,cc
        DREG    R5
 ]

        Push    "R0-R9,LR"              ; save caller's regs

; Save logical drive number for driver's use

        STRB    R1,WinLogicalDrive      ; 4..7

; determine which driver to call

        ADD     R1,R1,#:INDEX:WinDriveTypes - 4
        LDRB    R0,[SB,R1]              ; get code for this drive
        BIC     R2,R2,#DiscBits         ; remove disc bits
 [ BigDisc
        MOV     R2,R2,LSR #9
 ]
        ORRS    R2,R2,R0,LSL #(32-3)    ; put in drive number
                                        ; will set carry if ST506

; Call the driver: C=1 => ST506
; The disc address passed to the driver includes a physical drive number,
; not the logical drive number passed by FileCore. The drivers return
; with the LOGICAL drive number substituted back in. That substitution
; is done in the driver rather than here because other things e.g. process
; error may also need to include it and that is best done in the
; driver.

        MOV     R1,#DiscOp_ReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag ; read sectors
        MOV     R6,#NIL                 ; no defect list yet

        MOVCS   LR,#&FF                 ; if ST506, say no disc specified
        STRCSB  LR,SpecifiedWinnie

        baddr   R5,WinnieTestDiscRec    ; R5 -> test disc record

; IDE: we need to get the InitDriveParms flag from the boot block on
; completion of the read

        Push    "R2-R3"                 ; save dataptr and disc addr
        BL      WinLowLevelIDE          ; call IDE driver
        Pull    "R2-R3"                 ; restore dataptr and disc addr

 [ Debug21

        DLINE   "Boot block read ",cc
        BVS     %F01
        DLINE   "OK"
        B       %F02
01
        DLINE   "FAIL"
02
 ]

 [ BigDisc:LAND::LNOT:NewErrors
        BVS     %FT82                   ; branch if read failed
 |
        BVS     %FT80                   ; branch if read failed
 ]

; IDE: read of boot block succeeded
; Check it and, if it's valid, init drive if flag says we should
; (can use almost any regs now as they get restored on exit)
;
; First check defect list
; R3 -> boot block read from disc

 [ BigDisc
        MOV     LR,R2,LSL#9             ; turn back into a byte offet (knocks out DiscBits too)
 |
        BIC     LR,R2,#DiscBits
 ]
        RSB     R5,LR,#DefectListDiscAdd
        ADD     R3,R3,R5                ; Offset from dataptr to boot block
        MOV     R5,R3                   ; R5 -> boot block
        MOV     R1,#0                   ; zero checksum
        MOV     R4,#SzDefectList - MaxStruc
10
        LDR     R0,[R5],#4              ; get defect
        TSTS    R0,#DiscBits            ; valid defect?
        BNE     %FT11                   ; branch if not
        EOR     R1,R0,R1,ROR #13        ; work into checksum
        SUBS    R4,R4,#4                ; make sure don't run off end
        BGT     %BT10

; Hit end of defect list and not found terminator

 [ Debug21

        DLINE   "Defect list missing terminator"
 ]
        B       %FT85                   ; error

;~~~~~~~~~~~~~~~~
11
        EOR     R1,R1,R1,LSR #16
        EOR     R1,R1,R1,LSR #8

; R1 = calculated checksum, R0 = checksum from disc

        EOR     R1,R1,R0
        TSTS    R1,#&FF                 ; checksum is LSB only

 [ Debug21

        DLINE   "Defect list ",cc
        BNE     %F01
        DLINE   "VALID"
        B       %F02
01
        DLINE   "BAD"
02
 ]

        BNE     %FT85                   ; branch if bad checksum

; Defect list OK
; Check checksum of boot block
; R3 -> boot block

        MOV     R1,#SzDefectList        ; R1 = size of boot block
        ADDS    R5,R3,R1                ; R5 -> end + 1, C=0
        SUB     R1,R5,#1                ; R1 -> check byte
        MOV     R6,#0                   ; sum
        B       %FT30

;~~~~~~~~~~~~~~~

20
        LDRB    R4,[R1,#-1]!            ; get next byte
        ADC     R6,R6,R4                ; add into checksum
        MOVS    R6,R6,LSL #24           ; bit 8 into carry
        MOV     R6,R6,LSR #24           ; restore R6
30
        TEQS    R1,R3                   ; finished?
        BNE     %BT20                   ; branch if not
        LDRB    R4,[R5,#-1]             ; get stored checksum
        TEQS    R6,R4                   ; matches?

 [ Debug21
        DREG    R5,"R5="
        BREG    R4,"Stored="
        BREG    R6,"Calced="
        DLINE   "Boot block checksum ",cc
        BNE     %F01
        DLINE   "VALID"
        B       %F02
01
        DLINE   "BAD"
02
 ]

        BNE     %FT85                   ; branch if boot block invalid

; Boot block VALID, save parameters
; R3 -> boot block
; R2 still holds disc address from above

        MOV     R1,R2,LSR#(32-3)                ; R1 = drive number

        LDRB    R0,[R3,#SzDefectList - MaxStruc + SecsPerTrk]
        sbaddr  LR,WinIDEDriveSecsPerTrk        ; set up WinIDEDriveSecsPerTrk
        STRB    R0,[LR,R1]

        LDRB    R0,[R3,#SzDefectList - MaxStruc + Heads]
        sbaddr  LR,WinIDEDriveHeads             ; set up WinIDEDriveHeads
        STRB    R0,[LR,R1]

        LDRB    R0,[R3,#WinIDENeedsInit]        ; get flag read from disc
        sbaddr  LR,WinIDEDriveInitFlags         ; set up init flags
        STRB    R0,[LR,R1]

 [ Debug21

        DLINE   "Init flag ",cc
        TSTS    R0,#1
        BNE     %F01
        DLINE   "CLEAR"
        B       %F02
01
        DLINE   "SET"
02
 ]

; SBP 23-Aug-1994 Added support for IDE LBA flag

        LDRB    R0,[R3,#WinIDEUseLBA]           ; get flag read from disc
        sbaddr  LR,WinIDEDriveLBAFlags          ; set up LBA flags
        STRB    R0,[LR,R1]

; SBP 23-Aug-1994 end of LBA flag support

; Parameters saved: the next op will initialise the drive shape if the
; drive needs it.

        CLRV


80
; Calls to drivers return here
; Don't need to put logical drive number back in disc address as
; driver will have done so.

        STRVS   R0,[SP]                 ; save error code if error
 [ Debug21
        Pull    "R0-R9,LR"              ; restore caller's regs and return
        DREG    R0,"   EndMount R0: "
        MOV     PC,LR
 |
        Pull    "R0-R9,PC"              ; restore caller's regs and return
 ]

 [ BigDisc :LAND: :LNOT:NewErrors
82
; a nicety - Mount doesn't use sector addressing, and when called,
; FileCore doesn't know the sector size yet, so if we return a new-style
; disc error, it will not print a correct address. So, convert a any
; new-style disc errors to old-style.
        AND     LR,R0,#ExternalErrorBit+DiscErrorBit
        TEQ     LR,#ExternalErrorBit+DiscErrorBit
        BNE     %BT80                   ; V still set
        BIC     R0,R0,#ExternalErrorBit+DiscErrorBit
        LDMIA   R0,{R0,R1}              ; R0=error code, R1=disc/addr
        AND     R0,R0,#MaxDiscErr       ; mask out error
        MOV     R0,R0,LSL #24           ; put error in bits 24-29
        ORR     R0,R0,#DiscErrorBit     ; set bit 31
        AND     LR,R1,#DiscBits
        BIC     R1,R1,#&FF000000        ; isolate bottom 20 bits of sector address
        BIC     R1,R1,#&00F00000        ; (29 bits of byte address)
        ORR     R0,R0,LR,LSR #8         ; put disc in bits 21-23
        ORR     R0,R0,R1,LSL #1         ; put byte address / 256 in bits 0-20
        B       %BT80                   ; V still set
 ]

;~~~~~~~~~~~~~~~

85
; invalid defect list or checksum

 [ {TRUE}
        CLRV
 |
        MOV     R0,#BadDiscErr
        SETV
 ]
        B       %BT80

 [ :LNOT:BigDisc
;*********************************************************************

WinUpdateCMOSMapSize    ROUT
;
; Update map size held in CMOS
;
; Entry:
;    R2 = b31..b29 drive number (4..7)
;    R7-> RAM copy of map sizes - 4
;    R8 = map size for this drive
;
; Exit:
;    All registers and flags preserved

        Push    "R0-R2,LR"

        STRB    R8,[R7,R2,LSR #(32-3)]
        MOV     R0,#OsByte_WriteCMOS
        MOV     R1,R2,LSR #(32-3)

 [ Debug2
        wrhex   R1
        wrhex   R8
        mess    ,"oldsize drive newsize",NL
 ]

        ADD     R1,R1,#WinniSizeCMOS-4
        MOV     R2,R8
        SWI     XOS_Byte                ; (R0-R2->R0-R2,V)
        Pull    "R0-R2,PC"
 ]

;*********************************************************************

DoSwiWinControllerType  ROUT
;
; Returns the controller type of a hard disc.
;
; Entry:
;    R0 = drive number (4..7)
;
; Exit:
;    VC => valid drive number
;          R0 = controller type
;               0 => disc not present
;               3 => ST506
;               4 => IDE
;    VS => error
;          R0 -> error block
;    All other registers preserved

        Push    "LR"

; Check drive number

        CMPS    R0,#7                           ; valid drive number?
        BHI     %FT80                           ; branch if not

; Drive number valid
; Get type from drive map

        ADD     R0,R0,#:INDEX:WinDriveTypes - 4
        LDRB    LR,[SB,R0]

; R0 = &FF => no drive
;      0/1 => IDE
;      8/9 => ST506

        TSTS    LR,#bit3                        ; 8/9?
        MOVNE   R0,#3                           ; yes, ST506
        MOVEQ   R0,#4                           ; no, IDE

        CMPS    LR,#&FF                         ; not valid? (clears V)
        MOVEQ   R0,#0

        Pull    "PC"

;****** Never fall through

80
; return bad drive error using international stuff

        baddr   R0,BadDriveErrBlk               ; R0 -> error block
        BL      copy_error                      ; (R0->R0)
        SETV
        Pull    "PC"

;*********************************************************************

        END
@


4.14
log
@Preserve R12 across HAL device calls
Detail:
  s/Adfs12, s/IDEDetect - Ensure R12 is preserved over HAL device calls, the calling conventions allow the HAL to clobber it
Admin:
  Tested on Iyonix
  Fixes abort during ROM init


Version 3.51. Tagged as 'ADFS-3_51'
@
text
@d1071 1
a1071 1
;    R2 = disc address to read (sector aligned)
d1157 7
d1248 1
a1248 1
        MOV     R1,R2,LSR#(32-3)                ; R1 = 0/1
@


4.13
log
@Use HAL device for PATA IDE controller, and a few minor fixes
ADFS 3 is currently both a filing system and a hardware poker, so have it own the PATA device for now as a stepping stone to a PATADriver module; export the header.
No longer call HAL entries, look for the HAL device, activate, and call that instead. At API 0.00 it just has the exact same 3 functions as the previous HAL entries only refactored to pass a device pointer in R0.

Makefile/IDEDevice.hdr/ADFS.s/Adfs00.s:
  Export, include, and reserve workspace.
Adfs12.s/IDEDetect.s:
  Refactor function calls.
Messages:
  Unrelated correction to pluralisation of 'Sectors'.
Adfs50.s:
  Hunt for the IDE controller device.
  Fix oflaofla error if run on a non HAL machine - OS_Hardware errors but the ErrXFree code label expects the error pointer in R9 not R0.

Tested in an IOMD build.

Version 3.50. Tagged as 'ADFS-3_50'
@
text
@d272 1
d275 1
d293 1
d296 1
d372 1
d375 1
@


4.12
log
@Reinstate floppies on IOMD platform
ADFS.s:
  Remove redundant header file.
Adfs05.s/Adfs15.s:
  Group the options a bit more simply, use {TRUE} and {FALSE}.
Adfs12.s/BusMaster.s/IDEDetect.s:
  Use defines instead of magic numbers.
Adfs17.s:
  Organise the offsets from the floppy controller to cover both PCI and IO based controllers.
  Only do the dummy read from the PBI on Tungsten.
Adfs18.s:
  Implement the FIQ equivalent of the 'FlpUseVerify' command switch, modern controllers (!) have a built in verify rather than using a sector read, but the verify command has no data phase and the FIQ handler was sitting waiting for a sector that never arrives.
  Rationalise FlpDRQmask and FlpDRQmaskbit.
Adfs19:
  Rationalise the calls to OS_Hardware by rejigging the assembly time switches.
  Reinstate the non HAL version of IRQ enable for reference.
  On RPCEmu 0.8.8 and 0.8.9 the emulator hangs during the four set of DCB's used to autodetect the drive (Recalibrate/Seek/Seek/Sense) which seems to be due to the way the emulator splits CPU time to floppy emulation time, to avoid this we wait 128us (real time) which is enough emulated time for the controller to have changed state. You probably just want to *CONFIGURE FLOPPIES 0 though.

Tested om A7000, ARM610, StrongARM manipulating a veriety of disc densities for read and write. Also ran the "Test/TestADFS" test program.
RPCEmu 0.8.8 and 0.8.9 boots still, but no attempt has been made to use emulated floppies.

Version 3.46. Tagged as 'ADFS-3_46'
@
text
@d268 6
a273 6
        MOV     R2,#4*4
        MOV     R0,#-1
        MOV     R1,SP
        MOV     R8,#OSHW_CallHAL
        MOV     R9,#EntryNo_HAL_ATAControllerInfo
        SWI     XOS_Hardware
d283 1
a283 1
        MOV     R2,#12*4
d286 1
a286 1
        MOV     R2,#8*4
d288 5
a292 5
        MOV     R0,#0
        MOV     R1,SP
        MOV     R8,#OSHW_CallHAL
        MOV     R9,#EntryNo_HAL_ATAControllerInfo
        SWI     XOS_Hardware
d360 1
a360 1
        MOV     R2,#12*4
d363 1
a363 1
        MOV     R2,#8*4
d365 5
a369 5
        MOV     R0,#1
        MOV     R1,SP
        MOV     R8,#OSHW_CallHAL
        MOV     R9,#EntryNo_HAL_ATAControllerInfo
        SWI     XOS_Hardware
d478 1
a478 30
        BEQ     %FT05

      [ {FALSE} ; This code is using an obsolete version of the ATAControllerInfo call
                ; and its functionality has already been performed above anyway
        Push    "R9,R12"
        SUB     SP,SP,#32
        MOV     R0,SP
        MOV     R1,#32
        MOV     R8,#OSHW_CallHAL
        MOV     R9,#EntryNo_HAL_ATAControllerInfo
        SWI     XOS_Hardware
        Pull    "R2-R8,R14"
        Pull    "R9,R12"
        BVS     %FT05

        STR     R3,WinIDEPtr
        STR     R4,WinIDECtrlPtr
        STRB    R8,WinIDEHWDevNo

        ADDR    R7,WinIDEReadASector
        STR     R7,WinIDEReadPtr
        ADDR    R7,WinIDEWriteASector
        STR     R7,WinIDEWritePtr

        MOV     R14,#WinIDEHW_HAL
        STRB    R14,WinIDEHWType

        LDRB    R4,WinIDEDrives         ; needed later
      ]
        B       %FT15
a479 1
05
@


4.11
log
@Tabs expanded
Assembler source uses spaces round here in general, follow suit.
Not tagged.
@
text
@d271 1
a271 1
        MOV     R8,#0
d290 1
a290 1
        MOV     R8,#0
d367 1
a367 1
        MOV     R8,#0
d486 1
a486 1
        MOV     R8,#0
@


4.10
log
@Tidy up pass
ADFS.s:
  Redundant header files trimmed
  Get OsWords and OsBytes
  Switches rationalised
ADFS_SA.a
  Removed ARM810 support
Adfs00.s:
  Unused MEMC flag removed
Adfs05.s/Adfs12.s/Adfs13.s/Adfs14.s/Adfs15.s/Adfs19.s:
  Use defines instead of magic numbers
  Make use of FileCore exported bit fields
Adfs17.s/Adfs18.s/ConstIDE:
  {TRUE} and {FALSE} used with objasm
Adfs20.s
  Use AND of the opmask instead of BIC of all the flags except the opmask
Adfs50.s
  Unused MEMC flag no longer initialised
  Make use of FileCore exported bit fields
  Service call table reordered so the Ursula despatch doesn't incur a branch
  OsByte defines used
Consts:
  Removed those definitions now duplicating FileCore's exports
DebugOpts/Fixes:
  All options brought under one roof
ModHeader:
  Now uses VersionNum directly
Ver/*:
  Redundant switches deleted
  Removed used of 'Version' header


Version 3.45. Tagged as 'ADFS-3_45'
@
text
@d739 4
a742 4
	sbaddr	LR,WinIDEDriveLBAFlags	;
	MOV	R3,#0                   ; clear LBA usage flags
	STRB	R3,[LR]
	STRB	R3,[LR,#1]
d1035 7
a1041 7
        LDRB    R9,[R5,#Zones]		; get number of zones on disc
        LDRB    R8,[R5,#SectorSize]	; and sector size (log2)
        MOV     R8,R9,LSL R8		; get number of bits for zone (number of zones x size of sector)
        MOVS    R8,R8,LSR #8		; make into number of bytes(?)
        MOVEQ   R8,#2			; if zero, then make 2.
        sbaddr  R7,WinnieSizes-4	;
        LDRB    LR,[R7,R2,LSR #(32-3)]	;
d1129 1
a1129 1
	MOV	R2,R2,LSR #9
d1293 3
a1295 3
	LDRB	R0,[R3,#WinIDEUseLBA]		; get flag read from disc
	sbaddr	LR,WinIDEDriveLBAFlags		; set up LBA flags
	STRB	R0,[LR,R1]
@


4.9
log
@Update to use some of the exported FileCore headers.
There are still a large number of local copies that should be visited, but this change at least allows it to assemble again FileCore-3_45.
Tungsten and IOMD variants assemble, but others untested.

Version 3.41. Tagged as 'ADFS-3_41'
@
text
@d589 1
a589 1
        MOV     R0,#OsbyteReadCMOS
d1346 1
a1346 1
 [ T
d1372 1
a1372 1
        MOV     R0,#OsbyteWriteCMOS
@


4.8
log
@IOMD/HAL build fixes
Detail:
  s/Adfs12 - Don't use DefaultIDEHardware in HAL builds, use the proper addresses instead
  s/Adfs19 - Make floppy code use HAL_ControllerAddress to get 82C710 address in non-PCI, non-Podule, HAL builds. However floppy code is currently disabled in this configuration because it hangs the machine when floppy access is attempted.
  s/Consts, s/StaticsIDE - Get rid of some bad address constants for HAL builds
Admin:
  Tested in Iyonix & IOMD ROM softloads.


Version 3.38. Tagged as 'ADFS-3_38'
@
text
@d1142 1
a1142 1
        MOV     R1,#ReadSecsOp :OR: NoEscape ; read sectors
@


4.7
log
@  Reintroduced support for IOMD machines
Detail:
  There was no "Ver" file for Machine=32, and the code for build switch
  settings appropriate for IOMD had not been kept up-to-date with various
  changes to the module which were made to support Tungsten. This version
  provides working IDE support for IOMD HAL builds, although there are
  still some issues with floppy support. Tungsten builds should be
  functionally identical.
Admin:
  Tested on a Risc PC. Joint development effort by Tom Walker and Ben Avison.

Version 3.37. Tagged as 'ADFS-3_37'
@
text
@d447 4
d452 1
d510 3
a513 1
        LDR     R14, =DefaultIDE
@


4.6
log
@* DMA support completed.
* Selects PIO/DMA/Ultra DMA modes appropriate for each device.
* DMA support added to ADFS_IDEUserOp, but not yet ADFS_ATAPIOp.
* WinIDEMaxSectorsPerTransfer increased to 256.
* Floppy driver reattaches to DMA Manager if it's reinitialised.

Version 3.35. Tagged as 'ADFS-3_35'
@
text
@d327 1
d337 1
d475 2
d501 1
d515 1
a515 1
        STRB    R14, WinIDEHWDevNo
d522 5
a526 1
        ASSERT  WinIDEPtr = WinIDEHardware
d535 3
d539 2
a540 1
        STRB    R14,WinIDEHWType
d544 1
a544 1
        STR     R14,WinIDECtrlPtr
@


4.5
log
@First bits of DMA support: reads bus master information from the HAL and
uses it to create a set of DMA "HAL" devices for use by the DMA Manager.
Also responds to Service_ModulePostInit for the DMA Manager to reregister
(currently only the floppy) DMA channel(s).

Version 3.34. Not tagged
@
text
@d193 12
d327 10
d347 1
d412 1
d423 7
d783 3
d789 3
d795 2
a797 1
        Push    "R6"
d801 8
a808 1
        Pull    "R6"
d898 5
d914 5
@


4.4
log
@* ADFS_DiscOp64 and ADFS_ATAPIOp added.
* New FileCore error passing scheme supported.
* PCI floppy support functional.
* 48-bit LBA support added for ADFS_IDEUserOp and accessing beyond the
  first 128GB of a drive - not thoroughly tested.
* IDE autodetection improved

Version 3.34. Tagged as 'ADFS-3_34'
@
text
@d254 22
a275 2
        Push    "R9,R12"
        SUB     SP,SP,#32
a277 1
        MOV     R2,#32
a281 1
        Pull    "R9,R12"
d283 1
a283 1
        CMP     R0,#32
d305 6
d318 14
d333 7
a339 2
        Push    "R9,R12"
        SUB     SP,SP,#32
a341 1
        MOV     R2,#32
a345 1
        Pull    "R9,R12"
d350 1
a350 1
        ADD     R9,R9,#SzWinIDEHardware
d369 3
a371 3
        MOV     R0,#0
        BL      WinIDESetDefaultTimings
 [ TwinIDEHardware
a373 1
 ]
d381 19
a399 1
 ]
d755 9
@


4.3
log
@32-bit conversion started, Tungsten hard disc support added.
Hard disc functional, but PIO mode only. Don't go near the floppy.

Version 3.33. Not tagged
@
text
@d191 1
a191 1
        STRB    R0,WinIDECommandActive
d292 1
a292 1
        STRB    R0,[R4,#:INDEX:IDERegDigOutput]
d328 7
d340 1
a340 1
        STRB    R0,[R4,#:INDEX:IDERegDigOutput]
d475 1
a475 1
        STRB    R0,[R2,#:INDEX:IDERegDigOutput]
a1005 1
 [ IDEFixedLowSector
a1006 4
 |
        baddr   R5,WinnieTestDiscRec,CS ; R5 -> ST506 test disc record
        baddr   R5,WinIDETestDiscRec,CC ; R5 -> IDE test disc record
 ]
d1026 1
a1026 1
 [ BigDisc
d1105 3
a1107 1

d1177 1
a1177 1
 [ BigDisc
d1183 2
a1184 2
        AND     LR,R0,#&E0000000        ; note checking bit 29 clear - I intend
        TEQ     LR,#&C0000000           ; to have bit 29 set => new-style 32-bit addr
d1186 1
a1186 1
        BIC     R0,R0,#&C0000000
d1190 1
a1190 1
        ORR     R0,R0,#bit31            ; set bit 31
@


4.2
log
@Version Spin_merge taken
@
text
@d162 1
a162 1
        Push    "R3-R8,LR"              ; Save caller's regs
d197 3
d201 1
d204 4
d212 3
d216 1
d219 4
d227 4
a230 1
        STRB    R0,WinIDEIRQDevNo       ; no hardware yet
d237 1
d241 1
a241 3
 [ Top16Write
; See if any ST506 to setup
; R0 = configured ST506 drives
d243 3
a245 2
        TEQS    R0,#0                   ; Any drives configured?
        BEQ     %FT10                   ; No then skip ST506 bit
d247 2
a248 2
; Some ST506 drives configured - sort them out
; Set up regs to point to the default (motherboard) Winchester Hardware
d250 2
a251 2
        baddr   R1,DefaultWinnieHardware
        LDMIA   R1,{R2-R6}
d253 37
a289 2
; Issue a service call to let an ST506 podule change the registers to
; point to its hardware
d291 2
a292 2
        MOV     R1,#WinnieService
        SWI     XOS_ServiceCall
d294 37
a330 8
  [ Debug2
        wrhex   R2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        mess    ,"*winnie hardware",NL
  ]
d332 3
a334 1
; Save hardware information
d336 4
a339 10
        sbaddr  R0,WinnieHardware
  [ MEMC1A
        ADD     R2,R2,#dataRead
  ]
        STMIA   R0,{R2-R6}

  [ FileCache

; ***** contrary to comments here and elsewhere,
; ***** ClaimWinnieIRQs expects no regs and returns nothing
d341 1
a341 4
        BL      ClaimWinnieIRQs
  ]

10
d344 3
a346 12
        LDRB    R4,WinIDEDrives         ; get configured drives
; See if there's any IDE to setup

        TEQS    R4,#0                   ; any?
        BEQ     %FT20                   ; branch if not (R4=0)

; Some configured IDE drives
; Claim TickerV to do timers

        BL      WinClaimTickerV         ; (->R0,V)
        BVS     %FT80                   ; branch if error

d373 46
d429 8
a436 2
        sbaddr  R0,WinIDEHardware
        STMIA   R0,{R2-R8}
d452 1
d454 1
d457 1
a457 1
        BL      WinClaimIDEIRQs         ; (->R0,V)
d464 3
d477 3
d481 1
d484 4
d516 4
d569 39
a607 7
        TEQS    R4,#0                   ; any IDE drives?
        MOVNE   R0,#0                   ; yes, store &00 for first
        STRNEB  R0,[R5,#0]

        TEQS    R4,#2                   ; 2 drives?
        MOVEQ   R0,#1                   ; yes, store &01 for second
        STREQB  R0,[R5,#1]
d617 1
d620 1
d628 11
a638 2
        Pull    "R3-R8,LR"              ; Restore regs
        BICS    PC,LR,#V_bit            ; Return to caller with no error
d647 2
a648 2
        Pull    "R0,R3-R8,LR"           ; restore regs
        ORRS    PC,LR,#V_bit            ; return error
d668 1
a668 1
        Push    "R0,LR"
d671 1
a671 1
	
d675 1
a675 11
  [ FileCache

; check if any ST506 drives and release IRQs if so

        LDRB    LR,Winnies              ; any ST506 drives?
        TEQS    LR,#0
   [ Top16Write
        BLNE    ReleaseWinnieIRQs       ; release IRQs if so
   ]
  ]

d680 2
a681 1
        Pull    "R0,PC",EQ              ; return if not
d685 6
a690 1
        BL      WinReleaseIDEIRQs       ; (->R0,V)
d702 1
a702 1
        Pull    "R0,PC"
d719 1
a719 1
        Push    "R0,LR"                 ; Save caller's regs
d722 1
a722 1
	
a728 13
  [ FileCache

; check if any ST506 drives and release and reclaim IRQs if so

        LDRB    LR,Winnies              ; any ST506 drives?
        TEQS    LR,#0
        BEQ     %FT10
   [ Top16Write
        BL      ReleaseWinnieIRQs
        BL      ClaimWinnieIRQs
   ]
  ]

d730 1
d735 2
a736 1
        Pull    "R0,PC",EQ
d750 3
d754 1
d757 4
d769 2
a770 1
        LDRB    R0,WinIDEIRQDevNo
d772 1
a772 1
        Pull    "R0,PC",EQ              ; return if not
d776 15
a790 2
        BL      WinReleaseIDEIRQs       ; (->R0,V)
        BL      WinClaimIDEIRQs         ; (->R0,V)
d792 1
a792 1
        Pull    "R0,PC"                 ; Return to caller
d808 1
a808 1
        Push    "R0,LR"
d814 1
a814 1
        Pull    "R0,PC",EQ,^
d819 1
d826 1
a826 1
        STRVSB  R0,WinIDEIRQDevNo
d828 1
a828 1
        Pull    "R0,PC",,^
d883 1
d895 1
a916 1
 [ :LNOT: Top16Write
a917 5
 |
        pcadr   LR,%F10                         ; set return address
        BCS     WinnieDrivers                   ; old ST506 driver
        B       WinLowLevelIDE                  ; new IDE driver
 ]
a1005 5
 [ Top16Write
        pcadr   LR,%F80,CS              ; set return address
        BCS     WinnieDrivers           ; branch to old ST506 driver
 ]

d1014 1
a1014 1
	
d1024 3
d1028 1
d1051 1
a1051 1
	
d1067 1
a1067 1
	
d1103 1
a1103 1
	
d1134 1
a1134 1
	
d1173 22
d1208 1
d1238 2
a1239 1
        Pull    "R0-R2,PC",,^
d1281 1
a1281 1
        TEQS    LR,#&FF                         ; not valid?
d1284 1
a1284 2
        Pull    "LR"
        BICS    PC,LR,#V_bit
d1293 2
a1294 2
        Pull    "LR"
        ORRS    PC,LR,#V_bit
@


4.2.2.1
log
@This version of ADFS implements support for Ursula discs and stuff.

New SWI ADFS_IDEDeviceInfo

ADFS_IDEUserOp, ADFS_ControllerType modified for more drives.

Low level driver modified to use twin controllers.

Auto-detection of devices.  ProbeIDEDevices implemented to find them.

Mapping of devices made flexible to cope with any arrangement of devices.

Code to use ID information instead of boot block numbers not yet active,
needs to be brought up to date with autodetect code, and needs to do the
LBA side of things properly.

*configure IDETimeout added.

This uses CMOS byte 189, which ADFS previously used for approx winnie sizes,
but this is obsolete use.

To do:


Need to remove *configure IDEDiscs!

Need to support fast PIO modes and selection of appropriate mode.
@
text
@a196 3
 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
a197 1
 ]
a200 5
 [ TwinIDEHardware
        STRB    R0,WinIDEDriveState+2
        STRB    R0,WinIDEDriveState+3
 ]

a203 3
 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
a204 1
 ]
a206 2
        STRB    R0,WinIDEDriveSecsPerTrk+2
        STRB    R0,WinIDEDriveSecsPerTrk+3
a267 1
 [ :LNOT: AutoDetectIDE
a274 3

 ]

a281 28
 [ TwinIDEHardware

        baddr   R1,DefaultIDEHardware
        LDMIA   R1!,{R2-R8}

	ASSERT  WinIDEPtr = WinIDEHardware			; R2
        ASSERT  WinIDEPollPtr = WinIDEPtr + 4			; R3
        ASSERT  WinIDEPollBits = WinIDEPollPtr + 4		; R4
        ASSERT  WinIDEIRQPtr = WinIDEPollBits + 4		; R5
        ASSERT  WinIDEIRQBits = WinIDEIRQPtr + 4		; R6
	ASSERT	WinIDEPrimaryPtr = WinIDEIRQBits +4		; R7
	ASSERT	WinIDESecondaryPtr = WinIDEPrimaryPtr +4	; R8
	ASSERT	WinIDEPollBits2 = WinIDESecondaryPtr +4		; R2 (second batch)
	ASSERT	WinIDEIRQBits2 = WinIDEPollBits2 +4		; R3 (second batch)
        ASSERT  WinIDEReadPtr =  WinIDEIRQBits2 + 4		; R4 (second batch)
        ASSERT  WinIDEWritePtr = WinIDEReadPtr + 4		; R5 (second batch)

        sbaddr  R0,WinIDEHardware
        STMIA   R0!,{R2-R8}

	LDMIA	R1!,{R2, R3}

        ADDR    R4,WinIDEReadASector
        ADDR    R5,WinIDEWriteASector

	STMIA	R0!, {R2-R5}

 |
a289 2
; we don't issue Service_ADFSPoduleIDE on Phoebe

a296 1

d301 3
a303 3
        TEQS    R7,#0                    ; default data in routine?
        ADDR    R7,WinIDEReadASector,EQ  ; if yes, set it up
        TEQS    R8,#0                    ; default data out routine?
a318 2
 ]

a338 14
 [ AutoDetectIDE
; here's where we attempt to find the IDE devices

					; probe for the IDE devices.  number of
					; devices will be set according to the
					; wotsit thing


	BL	ProbeIDEDevices		; (->r4)

	STRB	R4, WinIDEDrives

 ]

a352 4

 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
a353 1
 ]
a356 5
 [ TwinIDEHardware
        STRB    R2,WinIDEPowerState+2
        STRB    R2,WinIDEPowerState+3
 ]

a432 19
 [ TwinIDEHardware

	TEQS	R4, #0			; any IDE drives?
	MOVNE	R0, #0			; yes, sgore &00 for first
	STRNEB	R0, [R5, #0]

	CMPS	R4, #1			; more than one drive?
	MOVHS	R0, #1			; yes, store & 01 for second
	STRHS	R0, [R5, #1]

	CMPS	R4, #2			; more than two drives?
	MOVHS	R0, #2			; yes, store &02 for the third
	STRHS	R0, [R5, #2]

	CMPS	R4, #3			; more than three drives
	MOVHS	R0, #3			; yes, store &03 for the fourth
	STRHS	R0, [R5, #3]

 |
a440 2
 ]

a448 3
 [ AutoDetectIDE
	MOV	R6,#0			; map sizes are not needed any more
 |
a449 1
 ]
d492 1
a492 1

d547 1
a547 1

a585 4

 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
a586 1
 ]
a589 5
 [ TwinIDEHardware
        STRB    R0,WinIDEDriveState+2
        STRB    R0,WinIDEDriveState+3
 ]

a697 2
 [ :LNOT: AutoDetectIDE

a706 1
 ]
d713 1
a713 3
  [ TwinIDEHardware
	SUB	R0, R0, #4
  |
a715 1
  ]
a792 4
 [ TwinIDEHardware
	SUB	R0, R1, #4
 |

a794 1
 ]
a827 85
 [ UseIdentify
	Push	"R0, R1, r2, R3"

	SUB	sp, sp, #SzWinIDEId
	MOV	r3, sp

	MOV	r0, r2, LSR #29

	BL	IdentifyDrive
	ADDVS	sp, sp, #SzWinIDEId
	Pull	"R0, R1, r2, R3",VS
	BVS	%FT80

; here we have the Id structure; try to make some sense of it

	LDR	r0, [sp, #WinIDEIdCyls]
	LDR	lr, =&ffff

	AND	r0, r0, lr

 [ Debug23
	DREG	r0, "Cylinders: "
 ]

	LDR	r0, [sp, #WinIDEIdHeads]

	AND	r0, r0, lr

 [ Debug23
	DREG	r0, "Heads: "
 ]

        MOV     R1,R2,LSR#(32-3)                ; R1 = 0/1

        sbaddr  r2,WinIDEDriveHeads             ; set up WinIDEDriveHeads
        STRB    R0,[r2,R1]

	LDR	r0, [sp, #WinIDEIdSecs]

	AND	r0, r0, lr

 [ Debug23
	DREG	r0, "Secs: "
 ]

        sbaddr  r2,WinIDEDriveSecsPerTrk        ; set up WinIDEDriveSecsPerTrk
        STRB    R0,[R2,R1]

	LDR	r0, [sp, #WinIDEIdCurCyls]

	AND	r0, r0, lr

 [ Debug23
	DREG	r0, "cur Cylinders: "
 ]

	LDR	r0, [sp, #WinIDEIdCurHeads]

	AND	r0, r0, lr

 [ Debug23
	DREG	r0, "cur Heads: "
 ]

	LDR	r0, [sp, #WinIDEIdCurSecs]

	AND	r0, r0, lr

 [ Debug23
	DREG	r0, "cur Secs: "
 ]

	ADD	sp, sp, #SzWinIDEId


; now the LBA support flag has to be checked.  LBA being
; supported is what we like to see




	Pull	"R0, R1, r2, R3"

 ]

d836 1
a836 1

d869 1
a869 1

d885 1
a885 1

d921 1
a921 1

a936 4
 [ TwinIDEHardware
	LDRB	R1, WinIDEPhysDriveNum		; physical drive number
 |

a937 3
 ]

 [ :LNOT: UseIdentify
a945 1
 ]
d952 1
a952 1

a962 1
 [ :LNOT: UseIdentify
a970 2
 ]

a973 1

a1005 2
 [ :LNOT: AutoDetectIDE

a1034 2
 ]

a1091 2

	LTORG
@


4.1
log
@Initial revision
@
text
@d370 13
d524 3
a526 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a369 13
 [ IDEPower
; Iff on a portable - set up a handler to examine the Winnie, on finding it spun down,
;                     the handler will power down the drive and interface.
;
        SWI     XPortable_ReadFeatures  ;returns flags in R1
        BVS     %FT20                   ;VS: not a portable, so skip handler setup code

        MOV     R0,#1000                ; R0 = centisecond count (10 seconds)
        ADDR    R1,WinIDEPowerShutdown  ; ...R1 -> handler
        MOV     R2,SB                   ; ...R2 = R12 value
        SWI     XOS_CallEvery           ; ...(R0-R2->V) ignore error
 ]

d511 1
a511 3
 [ IDEPower
        BL      WinIDEKillPowerShutdown ; all regs/flags preserved
 ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a369 13
 [ IDEPower
; Iff on a portable - set up a handler to examine the Winnie, on finding it spun down,
;                     the handler will power down the drive and interface.
;
        SWI     XPortable_ReadFeatures  ;returns flags in R1
        BVS     %FT20                   ;VS: not a portable, so skip handler setup code

        MOV     R0,#1000                ; R0 = centisecond count (10 seconds)
        ADDR    R1,WinIDEPowerShutdown  ; ...R1 -> handler
        MOV     R2,SB                   ; ...R2 = R12 value
        SWI     XOS_CallEvery           ; ...(R0-R2->V) ignore error
 ]

d511 1
a511 3
 [ IDEPower
        BL      WinIDEKillPowerShutdown ; all regs/flags preserved
 ]
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a369 13
 [ IDEPower
; Iff on a portable - set up a handler to examine the Winnie, on finding it spun down,
;                     the handler will power down the drive and interface.
;
        SWI     XPortable_ReadFeatures  ;returns flags in R1
        BVS     %FT20                   ;VS: not a portable, so skip handler setup code

        MOV     R0,#1000                ; R0 = centisecond count (10 seconds)
        ADDR    R1,WinIDEPowerShutdown  ; ...R1 -> handler
        MOV     R2,SB                   ; ...R2 = R12 value
        SWI     XOS_CallEvery           ; ...(R0-R2->V) ignore error
 ]

d511 1
a511 3
 [ IDEPower
        BL      WinIDEKillPowerShutdown ; all regs/flags preserved
 ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

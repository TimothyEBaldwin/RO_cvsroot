head	4.6;
access;
symbols
	ADFS-3_54:4.6
	ADFS-3_53:4.6
	ADFS-3_52:4.6
	ADFS-3_51:4.6
	ADFS-3_50:4.6
	ADFS-3_49:4.6
	ADFS-3_48:4.6
	ADFS-3_47:4.6
	ADFS-3_46:4.6
	ADFS-3_45:4.5
	ADFS-3_44:4.4
	ADFS-3_43:4.4
	ADFS-3_42:4.4
	ADFS-3_41:4.4
	ADFS-3_40:4.4
	ADFS-3_39:4.4
	ADFS-3_38:4.4
	ADFS-3_37:4.4
	ADFS-3_36:4.4
	RO_5_07:4.4
	ADFS-3_35:4.4
	ADFS-3_34:4.3
	ADFS-3_33:4.1
	dellis_autobuild_BaseSW:4.1
	ADFS-3_32:4.1
	Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	sbrodie_UrsulaRiscPC_ADFS-3_30:4.1
	Ursula_RiscPC_bp:4.1
	nturton_ADFS-3_29:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sproven_ADFS-3_31:4.1.4.1
	nicke_ADFS_3_26:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	sproven_330:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2012.10.21.11.42.57;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	yOiiX7g8HT2Zlfpw;

4.5
date	2012.10.21.11.38.10;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	L8DklCrHdjSrkfpw;

4.4
date	2003.04.03.18.47.57;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2003.01.17.19.33.28;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2002.09.18.15.03.30;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.22;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.22;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.35.34;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.09.02.18.37.40;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.29.16;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.24.45;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Tabs expanded
Assembler source uses spaces round here in general, follow suit.
Not tagged.
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    Constant definitions for IDE driver -> ConstIDE

; Change record
; =============
;
; CDP - Christopher Partington, Cambridge Systems Design
; SBP - Simon Proven
;
;
; 11-Jan-91  11:45  CDP
; File created.
;
; 08-Apr-91  17:20  CDP
; Added WinIDEMaxSectorsPerTransfer to make it easier to adjust the
; maximum transfer size to get around problems with some manufacturers'
; firmware.
; IDEUseRAMCode removed and code dependent on it made permanent.
; As needed to change bits or'ed in during drive/head selection to please
; various manufacturers, replaced literals with constant IDEDrvHeadMagicBits.
;
; 02-Apr-92  16:18  CDP
; WinIDETimeoutSpinup, WinIDETimeoutTransfer, WinIDETimeoutMisc changed from
; 15 to 30 seconds to allow for slower drives (RP-2001).
;
; 24-Aug-1994 SBP
; Added WinIDEUseLBA to allow selection of CHS or LBA addressing by examining
; the boot block.  WinIDEFileCoreOpFormat - code of Format operation.
; BootBlockAddr added to check if we are reading the boot block
;
;*End of change record*

;*********************************************************************

; Assembler flags
;
; IDEResetOnInit, if enabled, causes the drive to be reset when
; the module initialises. This should not be necessary unless
; something bad happened before and it adds a long delay before the
; drives can be used.
;
; IDEResetOnError, if enabled, causes the drive to be reset when
; an error occurs. This would be a good thing but for the fact that
; a drive can take 30 seconds to recover from reset.

                        GBLL    IDEResetOnInit
                        GBLL    IDEResetOnError

IDEResetOnInit          SETL    {FALSE}
IDEResetOnError         SETL    {TRUE}

;*********************************************************************

; Service calls used by ADFS to talk to ST506/IDE podules.
; ADFS defines WinnieService - this should be same as that
; allocated in $.Hdr.Services

        ASSERT  WinnieService = Service_ADFSPodule

; IDE uses Service_ADFSPoduleIDE

;*********************************************************************

 [ TwinIDEHardware
WinIDEMaxDrives *       4
 |
WinIDEMaxDrives *       2
 ]


; IDE registers - addressed using register "IDE".
; All registers are byte wide apart from data register.

IDE     RN      11
 [ HAL
IDECtrl RN      10
 ]

        GBLA    IDEReg_Spacing
 [ ByteAddressedHW
IDEReg_Spacing  SETA    1
 |
IDEReg_Spacing  SETA    4
 ]

                ^       0,IDE
; Command block registers

IDERegCmdBase   #       0
IDERegData      #       IDEReg_Spacing
IDERegFeatures  #       IDEReg_Spacing  ; write only
IDERegSecCount  #       IDEReg_Spacing  ; read/write
IDERegLBALow    #       IDEReg_Spacing
IDERegLBAMid    #       IDEReg_Spacing
IDERegLBAHigh   #       IDEReg_Spacing
IDERegDevice    #       IDEReg_Spacing
IDERegCommand   #       IDEReg_Spacing  ; write only

IDERegError     *       IDERegFeatures  ; read only
IDERegStatus    *       IDERegCommand   ; read only

IDERegSecNumber *       IDERegLBALow    ; (obsolete in ATA-6)
IDERegCylLo     *       IDERegLBAMid    ;         ""
IDERegCylHi     *       IDERegLBAHigh   ;         ""
IDERegDrvHead   *       IDERegDevice    ;         ""

; Bits which must be ORRed into the drive/head select bits

IDEDrvHeadMagicBits     *       2_10100000
IDEDrvLBA24to27MagicBits *      2_11100000
IDEDriveShift   *       4               ; bit number in RegDrvHead

; Stuff for choosing CHS or LBA addressing

WinIDEFileCoreOpFormat  *       4
BootEnd                 *       &E00

IDERegCtlDefaultOffset  * (&3F4 - &1F0) * IDEReg_Spacing

 [ HAL
                ^       0,IDECtrl
 |
                ^       IDERegCtlDefaultOffset,IDE
 ]
; Control block registers

IDERegCtlBase   #       0
IDERegCtlUnused #       2 * IDEReg_Spacing
IDERegAltStatus #       IDEReg_Spacing  ; read only
IDERegDevCtrl   *       IDERegAltStatus ; write only
IDERegDriveAddr #       IDEReg_Spacing  ; read only (obsolete in ATA-2)

IDEDevCtrlHOB   *       bit7            ; High Order Byte (48-bit addressing)
IDEDevCtrlSRST  *       bit2            ; Software Reset
IDEDevCtrlnIEN  *       bit1            ; not Interrupt Enable


; Bits in status register

IDEStatusBSY    *       bit7            ; 1 => controller is busy
IDEStatusDRDY   *       bit6            ; 1 => drive is ready
IDEStatusDF     *       bit5            ; 1 => device fault
IDEStatusDSC    *       bit4            ; 1 => drive seek complete (obsolete in ATA-4)
IDEStatusDRQ    *       bit3            ; 1 => data request
IDEStatusCORR   *       bit2            ; 1 => corrected data (obsolete in ATA-4)
IDEStatusIDX    *       bit1            ; 1 => disc index (obsolete in ATA-4)
IDEStatusERR    *       bit0            ; 1 => some error, err reg is valid
IDEStatusErrorBits      *       IDEStatusBSY:OR:IDEStatusDF:OR:IDEStatusERR

ATAPIStatusBSY  *       bit7            ; 1 => controller is busy
ATAPIStatusDRDY *       bit6            ; 1 => drive is ready
ATAPIStatusDMRD *       bit5            ; 1 => DMA ready
ATAPIStatusDF   *       bit5            ; 1 => device fault
ATAPIStatusSERV *       bit4            ; 1 => another command ready to be serviced
ATAPIStatusDRQ  *       bit3            ; 1 => data request
ATAPIStatusCHK  *       bit0            ; 1 => error has occurred - check

; Bits in error register

IDEErrorBBK     *       bit7            ; 1 => bad block mark encountered (obsolete in ATA-2)
IDEErrorICRC    *       bit7            ; 1 => interface CRC error (Ultra DMA) (new in ATA-4)
IDEErrorUNC     *       bit6            ; 1 => uncorrectable data
IDEErrorMC      *       bit5            ; 1 => media changed
IDEErrorIDNF    *       bit4            ; 1 => sector id not found
IDEErrocMCR     *       bit3            ; 1 => media change requested
IDEErrorABRT    *       bit2            ; 1 => command aborted
IDEErrorNTK0    *       bit1            ; 1 => track 0 not found
IDEErrorNDAM    *       bit0            ; 1 => no data address mark (obsolete in ATA-4)

ATAPIErrorSense *       2_11110000
ATAPIErrorSenseShift *  4               ; sense key (command specific)
ATAPIErrorABRT  *       bit2            ; 1 => command aborted
ATAPIErrorEOM   *       bit1            ; command specific
ATAPIErrorILI   *       bit0            ; command specific

; Key: M = mandatory (for non-ATAPI)
;      O = optional (for non-ATAPI)
;      A = ATAPI only
;      m = mandatory, but hosts shouldn't use

;                                                  ATA spec
; IDE commands                          used?   1 2 3 4 5 6 7

IDECmdNOP       *       &00             ; N     O O O O O O O
IDECmdDeviceReset *     &08             ; Y           A A A A
IDECmdRestore   *       &10             ; Y     M O O
IDECmdReadSecs  *       &20             ; Y     M M M M M M M
IDECmdReadSecsEng *     &21             ; N     M M M m
IDECmdReadLong  *       &22             ; N     M O O
IDECmdReadLongEng *     &23             ; N     M O O
IDECmdReadSecsExt *     &24             ; Y               O O
IDECmdReadDMAExt *      &25             ; Y               O O
IDECmdReadDMAQueuedExt * &26            ; N               O O
IDECmdReadNativeMaxAddrExt * &27        ; N               O O
IDECmdReadMultipleExt * &29             ; N               O O
IDECmdReadStreamDMA *   &2A             ; N                 O
IDECmdReadStreamPIO *   &2B             ; N                 O
IDECmdReadLogExt *      &2F             ; N                 O
IDECmdWriteSecs *       &30             ; Y     M M M M M M M
IDECmdWriteSecsEng *    &31             ; N     M M M m
IDECmdWriteLong  *      &32             ; N     M O O
IDECmdWriteLongEng *    &33             ; N     M O O
IDECmdWriteSecsExt *    &34             ; Y               O O
IDECmdWriteDMAExt *     &35             ; Y               O O
IDECmdWriteDMAQueuedExt * &36           ; N               O O
IDECmdSetMaxAddrExt *   &37             ; N               O O
IDECmdWriteMultipleExt * &39            ; N               O O
IDECmdWriteStreamDMA *  &3A             ; N                 O
IDECmdWriteStreamPIO *  &3B             ; N                 O
IDECmdWriteVerify *     &3C             ; N     O O O
IDECmdWriteDMAFUAExt *  &3D             ; N                 O
IDECmdWriteDMAQueuedFUAExt * &3E        ; N                 O
IDECmdWriteLogExt *     &3F             ; N               O O
IDECmdVerify    *       &40             ; Y     M M M M M M M
IDECmdVerifyEng *       &41             ; Y     M M M m
IDECmdVerifyExt *       &42             ; Y               O O
IDECmdFormatTrk *       &50             ; Y     M V V
IDECmdConfigureStream * &51             ; N                 O
IDECmdSeek      *       &70             ; Y     M M M M M M
IDECmdDiagnose  *       &90             ; N     M M M M M M M
IDECmdInitParms *       &91             ; Y     M M M M M
IDECmdDownloadMicrocode * &92           ; N       O O O O O O
IDECmdPacket    *       &A0             ; Y           A A A A
IDECmdIdentifyPacket *  &A1             ; Y           A A A A
IDECmdService   *       &A2             ; N           A A O O
IDECmdSMART     *       &B0             ; N         O O O O O
IDECmdDeviceConfig *    &B1             ; N               O O
IDECmdReadMultiple *    &C4             ; N     O O M M M M M
IDECmdWriteMultiple *   &C5             ; N     O O M M M M M
IDECmdSetMultiple *     &C6             ; N     O O M M M M M
IDECmdReadDMAQueued *   &C7             ; N           O O O O
IDECmdReadDMA   *       &C8             ; Y     O O M M M M M
IDECmdReadDMAEng *      &C9             ; N     O O M m
IDECmdWriteDMA  *       &CA             ; Y     O O M M M M M
IDECmdWriteDMAEng *     &CB             ; N     O O M m
IDECmdWriteDMAQueued *  &CC             ; N           O O O O
IDECmdWriteMultipleFUAExt * &CE         ; N                 O
IDECmdCheckMediaCardType * &D1          ; N               O O
IDECmdGetMediaStatus *  &DA             ; N           O O O O
IDECmdAckMediaChange *  &DB             ; N     O O
IDECmdBootPostBoot *    &DC             ; N     O O
IDECmdBootPreBoot *     &DD             ; N     O O
IDECmdMediaLock *       &DE             ; N     O O O O O O O
IDECmdMediaUnlock *     &DF             ; N     O O O O O O O
IDECmdStandbyImm *      &E0             ; N     O O O M M M M
IDECmdIdleImm   *       &E1             ; N     O O O M M M M
IDECmdStandby   *       &E2             ; Y     O O O M M M M
IDECmdIdle      *       &E3             ; Y     O O O M M M M
IDECmdReadBuffer *      &E4             ; N     O O O O O O O
IDECmdCheckPower *      &E5             ; Y     O O O M M M M
IDECmdSleep     *       &E6             ; N     O O O M M M M
IDECmdFlushCache *      &E7             ; N           O M M M
IDECmdWriteBuffer *     &E8             ; N     O O O O O O O
IDECmdWriteSame *       &E9             ; N     O O
IDECmdFlushCacheExt *   &EA             ; N               O O
IDECmdIdentify  *       &EC             ; Y     O M M M M M M (ATAPI will abort)
IDECmdMediaEject *      &ED             ; N       O O O O O O
IDECmdIdentifyDMA *     &EE             ; N         O
IDECmdSetFeatures *     &EF             ; Y     O O M M M M M
IDECmdSecSetPassword *  &F1             ; N         O O O O O
IDECmdSecUnlock *       &F2             ; N         O O O O O
IDECmdSecErasePrepare * &F3             ; N         O O O O O
IDECmdSecEraseUnit *    &F4             ; N         O O O O O
IDECmdSecFreezeLock *   &F5             ; N         O O O O O
IDECmdSecDisPassword *  &F6             ; N         O O O O O
IDECmdReadNativeMaxAddr * &F8           ; N           O O O O
IDECmdSetMaxAddr *      &F9             ; N           O O O O

; Identify block
                        ^       0
WinIDEIdGeneral         #       2       ; 0
IIGeneral_Removable     * bit7          ;       F F F F F F
IIGeneral_PacketLength  * bit1+bit0
IIGeneral_Packet12      * 0
IIGeneral_Packet16      * 1
WinIDEIdCylinders       #       2       ; 1     F F F F f
                        #       2       ; 2
WinIDEIdHeads           #       2       ; 3     F F F F f
                        #       4       ; 4-5
WinIDEIdSectors         #       2       ; 6     F F F F f
                        #       6       ; 7-9
WinIDEIdSerialNumber    #       20      ; 10-19 F F F F F F
                        #       4       ; 20-21
WinIDEIdECCBytes        #       2       ; 22
WinIDEIdFirmwareRevision #      8       ; 23-26 F F F F F F
WinIDEIdModel           #       40      ; 27-46 F F F F F F
WinIDEIdMaxMultiple     #       1       ; 47    F F F
                        #       1
                        #       2       ; 48
WinIDEIdCapabilities    #       2       ; 49
IICap_LBA * bit8                        ;       F F (ATA-3 mandates LBA)
IICap_DMA * bit9                        ;       F F (ATA-3 removed single word DMA)
IICap_IORDYdisable * bit10              ;         F F F
IICap_IORDY * bit11                     ;         F F F
IICap_StandbyTimer * bit13              ;         F F F
WinIDEIdCapabilities2   #       2       ; 50            F
                        #       1       ; 51
WinIDEIdPIOTiming       #       1       ;       F F F
                        #       1       ; 52
WinIDEIdDMATiming       #       1       ;       F F (ATA-3 removed single word DMA)
WinIDEIdValidWordsFlags #       2       ; 53
IIValid_Words54_58 * bit0               ;       V V V V V
IIValid_Words64_70 * bit1               ;         F F F F F
IIValid_Word88     * bit2               ;             F F F

WinIDEIdCurrentCylinders #      2       ; 54    v v v v v
WinIDEIdCurrentHeads    #       2       ; 55    v v v v v
WinIDEIdCurrentSectors  #       2       ; 56    v v v v v
WinIDEIdCurrentCHSCapacity #    4       ; 57-58 v v v v v

WinIDEIdCurrentMultiple #       2       ; 59    V V V V V V
WinIDEIdLBAAddressable  #       4       ; 60-61 F F F F F F
WinIDEIdDMAMode         #       2       ; 62    V V
WinIDEIdMultiwordDMAMode #      2       ; 63    V V V V

WinIDEIdPIOModes        #       2       ; 64      f f f f f
WinIDEIdMinMultiwordDMACycle #  2       ; 65      f f f f f
WinIDEIdRecMultiwordDMACycle #  2       ; 66      f f f f f
WinIDEIdMinPIOCycle     #       2       ; 67      f f f f f
WinIDEIdMinPIOCycleIORDY #      2       ; 68      f f f f f
                        #       12      ; 69-74
WinIDEIdQueueDepth      #       2       ; 75            f f
                        #       8       ; 76-79
WinIDEIdMajorATAVersion #       2       ; 80        F F F F
WinIDEIdMinorATAVersion #       2       ; 81        F F F F
WinIDEIdCommandSets1    #       2       ; 82        F F F F
WinIDEIdCommandSets2    #       2       ; 83        F F F F
IICS2_48bit * bit10
WinIDEIdCommandSets3    #       2       ; 84          F F F
WinIDEIdCommandEnabled1 #       2       ; 85          V V V
WinIDEIdCommandEnabled2 #       2       ; 86          V V V
WinIDEIdCommandDefaults #       2       ; 87          V V V
WinIDEIdUltraDMAMode    #       2       ; 88            v v
                        #       8       ; 89-92
WinIDEIdResetResult     #       2       ; 93            F F
                        #       12      ; 94-99
WinIDEIdLBA48Addressable #      8       ; 100-103         f
                        #       48      ; 104-127
WinIDEIdSecurityStatus  #       2       ; 128         v
                        #       252     ; 129-254
WinIDEIdIntegritySig    #       1       ; 255
WinIDEIdChecksum        #       1

        ASSERT  @@ = 512

SzWinIDEId              *       512





; IDE drive parameters

WinIDEBytesPerSector    *       512     ; bytes per sector
WinIDELowSector         *       1       ; lowest-numbered sector


; WinIDEMaxSectorsPerTransfer is a limit on the number of sectors that
; can be requested for any transfer. This *should* be 256 according to
; the CAM spec. but several drive manufacturers (Seagate, Sony etc.) have
; firmware bugs that causes this to fail. Most manufacturers seem to
; handle 255 ok.

WinIDEMaxSectorsPerTransfer     *       256

;*********************************************************************

; Error numbers (0 < n <= MaxDiscErr)
; =============
;
; I have attempted to map as many as possible onto the error numbers
; returned by the ST506 driver. The error codes for these are shown
; in brackets.

WinIDEErrABRT           *       &02     ; (IVC) command aborted by controller
WinIDEErrWFT            *       &07     ; (WFL) write fault
WinIDEErrCmdNotRdy      *       &08     ; (NRY) drive not ready
WinIDEErrNTK0           *       &09     ; (NSC) track 0 not found
WinIDEErrUNC            *       &13     ; (DFE) uncorrected data error
WinIDEErrIDNF           *       &16     ; (TOV) sector id field not found
WinIDEErrBBK            *       &17     ; (NIA) bad block mark detected
WinIDEErrNDAM           *       &18     ; (NDA) no data address mark


; Errors which cannot be mapped onto the error codes returned
; by the ST506 controller.

WinIDEErrNoDRQ          *       &20     ; no DRQ when expected
WinIDEErrCmdBusy        *       &21     ; drive busy when commanded
WinIDEErrBusy           *       &22     ; drive busy on command completion
WinIDEErrTimeout        *       &23     ; controller did not respond
WinIDEErrUnknown        *       &24     ; unknown code in error reg
WinIDEErrPacket         *       &25     ; other error in Packet command
WinIDEErrICRC           *       &26     ; interface CRC error

;*********************************************************************

; Hardware-dependent fields in the boot block addressed from the
; register pointing to the defect list.


WinIDENeedsInit *       ParkDiscAdd - 1 ; !0 => drive needs init before use
WinIDEUseLBA    *       ParkDiscAdd - 2 ; !0 => drive accessed using LBA addressing

;*********************************************************************

; Timeouts in centiseconds - most set large enough to allow for drive
; spinning up after autospindown. Could change this in future to be
; short when drive known to be spinning.

WinIDETimeoutSpinup     *       &C00    ; ~30 seconds spinup
WinIDETimeoutIdle       *       &C00    ; ~30 seconds recovery from idle cmd
WinIDETimeoutTransfer   *       &C00    ; ~30 seconds data transfer ops
WinIDETimeoutMisc       *       &C00    ; ~30 seconds seek, restore etc.

WinIDETimeoutUser       *       10*100  ; 10 seconds user ops

;*********************************************************************

; States of IDE drives to control spinup and parameter initialisation
; (stored in WinIDEDriveState variables)

WinIDEDriveStateReset           *       0       ; has been reset
WinIDEDriveStateIdled           *       1       ; rcvd idle cmd
WinIDEDriveStateSpinning        *       2       ; needs parm init
WinIDEDriveStateActive          *       3       ; ready for access

;*********************************************************************

; ATAPI constants

WinIDEATAPIByteCount    *       4096    ; max data per DRQ

;*********************************************************************

; Data direction stuff

WinIDEControllerShift   *       16
WinIDEDirectionRead     *       bit24
WinIDEDirectionWrite    *       bit25
WinIDEDirectionNone     *       0
WinIDEDirectionMask     *       bit24 :OR: bit25

;*********************************************************************

; Bit in podule interrupt status that tells OS that podule is
; interrupting

WinIDEPodIRQRequest     *       bit0

;*********************************************************************

        END
@


4.5
log
@Tidy up pass
ADFS.s:
  Redundant header files trimmed
  Get OsWords and OsBytes
  Switches rationalised
ADFS_SA.a
  Removed ARM810 support
Adfs00.s:
  Unused MEMC flag removed
Adfs05.s/Adfs12.s/Adfs13.s/Adfs14.s/Adfs15.s/Adfs19.s:
  Use defines instead of magic numbers
  Make use of FileCore exported bit fields
Adfs17.s/Adfs18.s/ConstIDE:
  {TRUE} and {FALSE} used with objasm
Adfs20.s
  Use AND of the opmask instead of BIC of all the flags except the opmask
Adfs50.s
  Unused MEMC flag no longer initialised
  Make use of FileCore exported bit fields
  Service call table reordered so the Ursula despatch doesn't incur a branch
  OsByte defines used
Consts:
  Removed those definitions now duplicating FileCore's exports
DebugOpts/Fixes:
  All options brought under one roof
ModHeader:
  Now uses VersionNum directly
Ver/*:
  Redundant switches deleted
  Removed used of 'Version' header


Version 3.45. Tagged as 'ADFS-3_45'
@
text
@d123 1
a123 1
IDEDrvLBA24to27MagicBits *	2_11100000
d128 2
a129 2
WinIDEFileCoreOpFormat	*	4
BootEnd			*	&E00
d416 1
a416 1
WinIDEUseLBA	*	ParkDiscAdd - 2 ; !0 => drive accessed using LBA addressing
@


4.4
log
@* DMA support completed.
* Selects PIO/DMA/Ultra DMA modes appropriate for each device.
* DMA support added to ADFS_IDEUserOp, but not yet ADFS_ATAPIOp.
* WinIDEMaxSectorsPerTransfer increased to 256.
* Floppy driver reattaches to DMA Manager if it's reinitialised.

Version 3.35. Tagged as 'ADFS-3_35'
@
text
@d62 2
a63 2
IDEResetOnInit          SETL    F
IDEResetOnError         SETL    T
@


4.3
log
@* ADFS_DiscOp64 and ADFS_ATAPIOp added.
* New FileCore error passing scheme supported.
* PCI floppy support functional.
* 48-bit LBA support added for ADFS_IDEUserOp and accessing beyond the
  first 128GB of a drive - not thoroughly tested.
* IDE autodetection improved

Version 3.34. Tagged as 'ADFS-3_34'
@
text
@d174 1
a174 1
IDEErrocICRC    *       bit7            ; 1 => interface CRC error (Ultra DMA) (new in ATA-4)
d189 4
a192 2
;                                                 ATA spec
; IDE commands                          used?   1 2 3 4 5 6
d194 5
a198 2
IDECmdNOP       *       &00             ; N     O O O O O O
IDECmdDeviceReset *     &08             ; Y         (ATAPI only)
d200 30
a229 11
IDECmdReadSecs  *       &20             ; Y     M M M M M M
IDECmdReadSecsExt *     &24             ; Y               O
IDECmdReadDMAExt *      &25             ; N               O
IDECmdReadMultipleExt * &29             ; N               O
IDECmdWriteSecs *       &30             ; Y     M M M M M M
IDECmdWriteSecsExt *    &34             ; Y               O
IDECmdWriteDMAExt *     &35             ; N               O
IDECmdWriteMultipleExt * &39            ; N               O
IDECmdVerify    *       &40             ; Y     M M M M M M
IDECmdVerifyEng *       &41             ; Y     M M M
IDECmdVerifyExt *       &42             ; Y               O
d231 1
d233 1
a233 1
IDECmdDiagnose  *       &90             ; N     M M M M M M
d235 46
a280 12
IDECmdPacket    *       &A0             ; Y         (ATAPI only)
IDECmdIdentifyPacket *  &A1             ; Y         (ATAPI only)
IDECmdReadMultiple *    &C4             ; N     O O M M M M
IDECmdWriteMultiple *   &C5             ; N     O O M M M M
IDECmdSetMultiple *     &C6             ; N     O O M M M M
IDECmdReadDMA   *       &C8             ; N     O O M M M M
IDECmdWriteDMA  *       &CA             ; N     O O M M M M
IDECmdStandby   *       &E2             ; Y     O O O M M M
IDECmdIdle      *       &E3             ; Y     O O O M M M
IDECmdCheckPower *      &E5             ; Y     O O O M M M
IDECmdIdentify  *       &EC             ; Y     O M M M M M (ATAPI will abort)
IDECmdSetFeatures *     &EF             ; Y     O O M M M M
d330 1
a330 1
WinIDEIdMinMultiWordDMACycle #  2       ; 65      f f f f f
d347 1
a347 1
                        #       9       ; 89-92
d353 5
d377 1
a377 1
WinIDEMaxSectorsPerTransfer     *       255
d407 1
@


4.2
log
@32-bit conversion started, Tungsten hard disc support added.
Hard disc functional, but PIO mode only. Don't go near the floppy.

Version 3.33. Not tagged
@
text
@a57 5
;
; IDEFixedLowSector, if enabled, causes an immediate value to be
; used for the lowest-numbered sector on a track, rather than
; reading it from the disc record. This seems to be necessary to
; stop existing programs falling over.
a60 1
                        GBLL    IDEFixedLowSector
a63 1
IDEFixedLowSector       SETL    T
d106 4
a109 4
IDERegLBA0to7   #       IDEReg_Spacing
IDERegLBA8to15	#       IDEReg_Spacing
IDERegLBA16to23	#       IDEReg_Spacing
IDERegDrvLBA24to27 #    IDEReg_Spacing
d115 4
a118 4
IDERegSecNumber *       IDERegLBA0to7   ; (obsolete in ATA-6)
IDERegCylLo     *       IDERegLBA8to15  ;         ""
IDERegCylHi     *       IDERegLBA16to23 ;         ""
IDERegDrvHead   *       IDERegDrvLBA24to27 ;      ""
d124 1
d143 1
a143 1
IDERegDigOutput *       IDERegAltStatus ; write only
d146 3
a148 2

IDEDriveShift   *       4               ; bit number in RegDrvHead
d163 7
d183 5
d193 1
d196 3
d200 3
d205 1
d210 2
a211 1
IDECmdIdentifyPacket *  &A1             ; N         (ATAPI only)
d220 2
a221 2
IDECmdIdentify  *       &EC             ; N     O M M M M M (ATAPI will abort)
IDECmdSetFeatures *     &EF             ; N     O O M M M M
d227 3
d282 1
a303 1
 [ IDEFixedLowSector
a304 1
 ]
d317 1
a317 1
; Error numbers (0 < n < MaxDiscErr)
d342 1
d375 6
@


4.1
log
@Initial revision
@
text
@a49 5
; IDEAllowTrackWrap, if enabled, causes ops to transfer up to
; WinIDEMaxSectorsPerTransfer sectors at once, not just the number to the
; end of the current track. The drive does the head/cylinder incrementing
; itself. This IS faster.
;
a62 7
;
; IDETrustDrive, if enabled, causes the physical address at the end of
; a transfer to be read from the drive's registers. If disabled, the
; new address is calculated from the amount transferred. Given the
; number of manufacturers whose drives do not update the registers
; correctly (e.g. Seagate, Quantum), it is probably safest to keep
; this disabled.
a63 1
                        GBLL    IDEAllowTrackWrap
a66 1
                        GBLL    IDETrustDrive
a67 1
IDEAllowTrackWrap       SETL    T
a70 1
IDETrustDrive           SETL    F
d84 3
d88 1
d95 10
d110 10
a119 13
IDERegData      #       4
IDERegPrecomp   #       4               ; write only
IDERegError     *       IDERegPrecomp   ; read only
IDERegSecCount  #       4               ; read/write
IDERegSecNumber #       4               ; read/write
IDERegLBA0to7   *	IDERegSecNumber
IDERegCylLo     #       4               ; read/write
IDERegLBA8to15	*	IDERegCylLo
IDERegCylHi     #       4               ; read/write
IDERegLBA16to23	*	IDERegCylHi
IDERegDrvHead   #       4               ; read/write
IDERegDrvLBA24to27	*	IDERegDrvHead
IDERegCommand   #       4               ; write only
d122 5
d137 1
d139 5
a143 1
                ^       ((&3F0 - &1F0) * 4),IDE
d147 2
a148 2
IDERegCtlUnused #       6 * 4
IDERegAltStatus #       4               ; read only
d150 1
a150 1
IDERegDriveAddr #       4               ; read only
d160 2
a161 2
IDEStatusWFT    *       bit5            ; 1 => write fault
IDEStatusDSC    *       bit4            ; 1 => drive seek complete
d163 2
a164 2
IDEStatusCORR   *       bit2            ; 1 => corrected data
IDEStatusIDX    *       bit1            ; 1 => disc index
d166 1
a166 1
IDEStatusErrorBits      *       IDEStatusBSY:OR:IDEStatusWFT:OR:IDEStatusERR
d171 2
a172 1
IDEErrorBBK     *       bit7            ; 1 => bad block mark encountered
d174 1
d176 1
d179 97
a275 1
IDEErrorNDAM    *       bit0            ; 1 => no data address mark
a277 1
; IDE commands
a278 2
IDECmdOptNoRetry        *       bit0    ; setting this bit suppresses retries
                                        ; on ops ReadSecs, WriteSecs, Verify
a279 20
IDECmdRestore   *       2_00010000      ; restore to cylinder 0 (recalibrate)
IDECmdReadSecs  *       2_00100000      ; read sectors
IDECmdWriteSecs *       2_00110000      ; write sectors
 [ EngineeringMode
IDECmdVerify    *       2_01000000      ; verify (with ECC correction)
IDECmdVerifyEng *       2_01000000:OR:IDECmdOptNoRetry ; verify (engineering mode (no ECC))
 |
  [ version="2.70"
IDECmdVerify    *       2_01000000      ; verify sectors with retry for soak test
  |
IDECmdVerify    *       2_01000000:OR:IDECmdOptNoRetry ; verify sectors
  ]
 ]
IDECmdFormatTrk *       2_01010000      ; format track
IDECmdSeek      *       2_01110000      ; seek track
IDECmdDiagnose  *       2_10010000      ; execute diagnostics
IDECmdInitParms *       2_10010001      ; initialise drive parameters
IDECmdIdle      *       2_11100011      ; enter idle mode
IDECmdStandby   *       2_11100010      ; enter standby mode
IDECmdCheckPower *      2_11100101      ; check power mode
d340 4
a343 4
WinIDETimeoutSpinup     *       &1800   ; ~60 seconds spinup
WinIDETimeoutIdle       *       &1800   ; ~60 seconds recovery from idle cmd
WinIDETimeoutTransfer   *       &1800   ; ~60 seconds data transfer ops
WinIDETimeoutMisc       *       &1800   ; ~60 seconds seek, restore etc.
d361 1
@


4.1.4.1
log
@This version of ADFS implements support for Ursula discs and stuff.

New SWI ADFS_IDEDeviceInfo

ADFS_IDEUserOp, ADFS_ControllerType modified for more drives.

Low level driver modified to use twin controllers.

Auto-detection of devices.  ProbeIDEDevices implemented to find them.

Mapping of devices made flexible to cope with any arrangement of devices.

Code to use ID information instead of boot block numbers not yet active,
needs to be brought up to date with autodetect code, and needs to do the
LBA side of things properly.

*configure IDETimeout added.

This uses CMOS byte 189, which ADFS previously used for approx winnie sizes,
but this is obsolete use.

To do:


Need to remove *configure IDEDiscs!

Need to support fast PIO modes and selection of appropriate mode.
@
text
@a99 3
 [ TwinIDEHardware
WinIDEMaxDrives *       4
 |
a100 1
 ]
a199 8
 [ UseIdentify :LOR: AutoDetectIDE
IDECmdIdentify 	*	2_11101100	; identify device
 ]

 [ AutoDetectIDE
IDECmdIdentifyPacket *	2_10100001	; identify packet device
 ]

a290 223

;*********************************************************************

 [ UseIdentify :LOR: AutoDetectIDE

; here is the definition for the Identify structure's values

	^ 	0
WinIDEIdConfig		#	2	;  15	0 = ATA device
					; 14-8	retired
					;   7	1 = removable media device
					;   6   1 = not removable controller and/or device
					;  5-1	retired
					;   0   reserved

WinIDEIdCyls		#	2	; number of logical cylinders

			#	2	; reserved

WinIDEIdHeads		#	2	; number of logical heads

			#	2	; retired

			#	2	; retired

WinIDEIdSecs		#	2	; number of logical sectors per logical track

			#	2	; retired

			#	2	; retired

			#	2	; retired

WinIDEIdSerialNo	#	20	; serial number (ASCII)

			#	2	; retired

			#	2	; retired

			#	2	; obsolete

WinIDEIdFirmware	#	8	; firmware revision (ASCII)

WinIDEIdModelNo		#	40	; model number

WinIDEIdMaxSecsPerIRQ	#	2	; 15-8	&80
					;  7-0  &00 = reserved
					;       &01-&ff=Max sectors per irq for read/write multiple

			#	2	; reserved

WinIDEIdCapabilities0	#	2	; 15-14	Reserved for id packet device command
					;  13	1 = standby timer values as specced in standard
					;	0 = standby timer values managed by device
					;  12	Reserved for id packet device command
					;  11	1 = IORDY supported
					;	0 = IORDY may be supported
					;  10	1 = IORDY may be disabled
					;   9	Shall be set to 1
					;   8	Shall be set to 1
					;  7-0	Retired

WinIDEIdCapabilities1	#	2	;  15	Shall be cleared to zero
					;  14	Shall be set to one
					; 13-1	Reserved
					;   0	Shall be set to one to indicate a device specific Standby timer value minimum

WinIDEIdPIOMode		#	2	; 15-8	PIO data transfer mode number
					;  7-0	retired

			#	2	; retired

WinIDEIdValidBits	#	2	; 15-3	reserved
					;   2	1 = word 88 valid
					;	0 = word 88 not valid
					;   1	1 = words 64-70 valid
					;	0 = words 64-70 not valid
					;   0	1 = words 54-58 valid
					;       0 = words 54-58 may be valid

WinIDEIdCurCyls		#	2	; number of current logical cylinders

WinIDEIdCurHeads	#	2	; number of current logical heads

WinIDEIdCurSecs		#	2	; number of current logical sectors per track

WinIDEIdCurCapacity	#	4	; current capacity in sectors

WinIDEIdSecsPerIRQ	#	2	; 15-9	reserved
					;  8	1 = setting is valid
					; 7-0	Current setting

WinIDEIdLBASecs		#	4	; total number of addressable secs (LBA mode only)

			#	2	; retired

WinIDEIdMultiDMA	#	2	; 15-11	reserved
					;  10	1 = Multi word DMA mode 2 is selected
					;	0 = Multi word DMA mode 2 not selected
					;   9	1 = Multi word DMA mode 1 is selected
					;	0 = Multi word DMA mode 1 not selected
					;   8	1 = Multi word DMA mode 0 is selected
					;	0 = Multi word DMA mode 0 not selected
					;  7-3	reserved
					;   2	1 = Multi word DMA mode 2 and below are supported
					;   1	1 = Multi word DMA mode 1 and below are supported
					;   0	1 = Multi word DMA mode 0 is supported

WinIDEIdAdvPIOSupport	#	2	; 15-8	reserved
					;  7-0	advanced PIO modes supported:

					;    1  1 = Mode 4 supported
					;    0  1 = Mode 3 supported

WinIDEIdMinMultiDMACyc	#	2	; min multiword dma cycle time in nanoseconds

WinIDEIdRecMultiDMACyc	#	2	; recommended multiword dma cycle time in nanoseconds

WinIDEIdMinPIOTime	#	2	; min PIO transfer time without flow control

WinIDEIdMinPIOFlowTime	#	2	; min PIO transfer time with flow control

			#	2	; reserved

			#	2	; reserved

			#	8	; reserved

WinIDEIdQueueDepth	#	2	; 15-5 	reserved
					;  4-0	max queue depth

			#	8	; reserved

WinIDEIdMajorVersion	#	2	; 0000 or FFFF - device does not report version
					; 15	Reserved
					; 14    Reserved for ATA/ATAPI-14
					; etc
					;  4	1 = supports ATA/ATAPI-4
					;  3	1 = supports ATA-3
					;  2	1 = supports ATA-2
					;  1	1 = supports ATA-1
					;  0	reserved

WinIDEIdMinorVersion	#	2	; minor version number

; next pair - 0000 or FFFF mean not supported

WinIDEIdCommands	#	2	; commands supported bits
					;
					; 15	obsolete
					; 14	1 = NOP supported
					; 13	1 = READ BUFFER command supported
					; 12	1 = WRITE BUFFER command supported
					; 11	obsolete
					; 10	1 = Host Protected Area feature set supported
					;  9	1 = DEVICE RESET command supported
					;  8	1 = SERVICE interrupt supported
					;  7	1 = release interrupt supported
					;  6	1 = look-ahead supported
					;  5	1 = write cache supported
					;  4	1 = supports PACKET command feature set
					;  3	1 = suppports power management feature set
					;  2	1 = supports removable media feature set
					;  1	1 = supports security mode feature set
					;  0	1 = supports SMART feature set


			#	2	;  15	shall be cleared to zero
					;  14	shall be set to one
					; 13-5	reserved
					;   4	1 = Removable Media Status Notification feature set supported
					;   3	1 = Advanced Power Management feature set supported
					;   2	1 = CFA feature set supported
					;   1	1 = READ/WRITE DMA QUEUED supported
					;   0   1 = DOWNLOAD MICROCODE command supported

			#	2	; no use to us

			#	2	; no use to us

			#	2	; no use to us

			#	2	; no use to us

WinIDEIdUltraDMA	#	2	; 15-11	reserved
					;  10	1 = ultra DMA mode 2 is selected
					;	0 = ultra DMA mode 2 not selected
					;   9	1 = ultra DMA mode 1 is selected
					;	0 = ultra DMA mode 1 not selected
					;   8	1 = ultra DMA mode 0 is selected
					;	0 = ultra DMA mode 0 not selected
					;  7-3	reserved
					;   2	1 = ultra DMA mode 2 and below are supported
					;   1	1 = ultra DMA mode 1 and below are supported
					;   0	1 = ultra DMA mode 0 is supported

			#	2	; word 89

			#	2	; word 90

			#	2	; word 91

			#	70	; reserved

			#	2	; word 127

			#	2	; word 128

			#	62	; vendor specific

			#	192	; reserved

SzWinIDEId		#	0	; end of it

	ASSERT	SzWinIDEId=512

 ]

 [ AutoDetectIDE
WinIDEAutoDetectTimeout	*	512	; 512cs timeout
WinIDENoDevice		*	&FF	; means no device
WinIDEATAPIDevice	*	&FE	; means ATAPI device
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

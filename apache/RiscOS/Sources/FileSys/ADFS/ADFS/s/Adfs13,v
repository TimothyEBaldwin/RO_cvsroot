head	4.9;
access;
symbols
	ADFS-3_54:4.9
	ADFS-3_53:4.9
	ADFS-3_52:4.9
	ADFS-3_51:4.9
	ADFS-3_50:4.9
	ADFS-3_49:4.9
	ADFS-3_48:4.9
	ADFS-3_47:4.9
	ADFS-3_46:4.9
	ADFS-3_45:4.8
	ADFS-3_44:4.7
	ADFS-3_43:4.7
	ADFS-3_42:4.7
	ADFS-3_41:4.7
	ADFS-3_40:4.6
	ADFS-3_39:4.6
	ADFS-3_38:4.6
	ADFS-3_37:4.6
	ADFS-3_36:4.5
	RO_5_07:4.5
	ADFS-3_35:4.5
	ADFS-3_34:4.4
	ADFS-3_33:4.2
	dellis_autobuild_BaseSW:4.2
	ADFS-3_32:4.2
	Ursula_merge:4.2
	Ursula_RiscPC_merge:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.2
	sbrodie_UrsulaRiscPC_ADFS-3_30:4.2
	Ursula_RiscPC_bp:4.2
	nturton_ADFS-3_29:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	sproven_ADFS-3_31:4.2.2.1
	nicke_ADFS_3_26:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	sproven_330:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2012.10.21.11.42.56;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	yOiiX7g8HT2Zlfpw;

4.8
date	2012.10.21.11.38.09;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	L8DklCrHdjSrkfpw;

4.7
date	2011.10.14.07.38.46;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	tK3tjaAo92QGZhDv;

4.6
date	2010.12.06.14.14.47;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2003.04.03.18.47.57;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2003.01.17.19.33.27;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2002.09.18.15.03.29;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.00.25;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.31.19;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	98.09.02.18.37.30;	author sproven;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.31.19;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.35.17;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.28.57;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.24.28;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Tabs expanded
Assembler source uses spaces round here in general, follow suit.
Not tagged.
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    IDE Winchester driver entry points -> Adfs13

; Change record
; =============
;
; CDP - Christopher Partington, Cambridge Systems Design
; SBP - Simon Proven, Acorn Computers Ltd.
;
;
; 07-Jan-91  10:00  CDP
; IDE driver started.
;
; 11-Mar-91  17:10  CDP
; Reset added to DoSwiIDEUserOp
;
; 12-Mar-91  14:18  CDP
; Entry points now check whether IDE device has been claimed before
; attempting any access.
;
; 13-Mar-91  15:23  CDP
; DoSwiWinPowerControl now only checks for presence of IDE controller
; after confirming that the request is for an IDE drive.
; WinLowLevelIDE now checks for controller only after setting up the
; variables that the error exit uses.
;
; 14-Mar-91  12:31  CDP
; DoSwiWinPowerControl check for IDE controller had BNE instead of BEQ
; FIXED.
;
; 18-Mar-91  18:14  CDP
; Increments/decrements WinIDECommandActive on way into/out of
; low-level entry.
;
; 20-Mar-91  13:03  CDP
; InitDrive rewritten to initialise power state of drives on first
; access and take account of timer event routine doing same in
; background.
; WinIDEOpStatus renamed WinIDEAdjustStatus to avoid confusion (it
; is not an op).
;
; 26-Mar-91  15:01  JSR
; Internationalise the error messages
;
; 26-Mar-91  17:03  CDP
; Change internationalisation of DoSwiWinPowerControl error exit so as
; to substitute an error number into the error string.
;
; 27-Mar-91  17:19  CDP
; DoSwiIDEUserOp now stops data transfer to/from the controller when
; the count becomes <=0. Previously it carried on (without accessing
; user memory) in order to satisfy the controller. It is up to the
; user to get this right. Waiting until !DRQ has caused problems on
; a flaky system that refused to deassert DRQ. The next command will
; abort any pending I/O anyway. The only problem is leaving the access
; light on. Reset seems a bit aggressive since the drive can take quite
; some time to recover. I hope that the user will notice the DRQ status
; bit and act accordingly.
;
; 08-Apr-91  17:22  CDP
; Calls to WaitNotBusy now cancel timer afterwards if not busy to speed
; up ticker routine.
; Internationalised error return from DoSwiIDEUserOp.
; Code previously conditional on IDEUseRAMCode now made permanent.
; DoSwiIDEUserOp now waits for upto 20ms for DRQ to be asserted. This
; is necessary for CAM class 3 commands.
; Added checks for command active to DoSwiWinPowerControl and
; DoSwiIDEUserOp.
;
; 11-Apr-91  12:58  CDP
; DoSwiIDEUserOp now validates parameter block and buffer addresses.
; All other entry points assume that FileCore/FileSwitch etc. have
; validated the addresses passed.
;
; 10-Jan-92  12:02  CDP
; WinIDEInitDrive changed to use different data to determine whether to
; issue InitDriveParms to the drive (see change record of same date in
; Adfs12 for more details).
;
; 13-Jan-92  12:04  CDP
; DoSwiWinPowerControl, DoSwiIDEUserOp now call LockIDEController rather
; than just testing the CommandActive flag.
; WinLowLevelIDE now calls LockIDEController and calls UnlockIDEController
; on exit if no background transfer is still in progress.
;
; 09-Mar-92  11:17  CDP
; WinIDEInitDrive no longer issues InitialiseDriveParameters as this is done
; by mount entry point. State WinIDEDriveStateSpinning now redundant.
;
; 02-Apr-92  16:18  CDP
; WinIDEInitDrive now issues SpecifyOp when necessary (and parameters have
; been set up) so that the drive shape is reinitialised following a disc
; error (which resets the drive). This should restore all the disc shape
; initialisation that was originally in the driver but effectively disabled
; by changes to FileCore.
; Made WinLowLevelIDE check that it managed to lock controller. Previously
; it took priority but, when symmetrical locking was added 13Jan92, no
; check was added in WinLowLevelIDE that it actually got the lock.
;
; 06-Sep-1994 SBP
; Changed to make use of BigDisc option.
;
;*End of change record*

;*********************************************************************
;
; This file contains the following routines:
;
; DoSwiSetIDEController
;    Gives the IDE driver the details of an alternative controller.
;
; DoSwiWinPowerControl
;    Controls the power-saving features of IDE drives
;
; DoSwiIDEUserOp
;    Direct user interface for low-level IDE commands.
;
; WinLowLevelIDE
;    Handles a low-level call for the IDE discs.
;
; WinIDEAdjustStatus
;    Sorts out status at the end of an operation.
;
; WinIDEInitDrive
;    Initialises drive before access.
;
; WinIDEOpVerify
;    Carries out a verify op on an IDE disc.
;
; WinIDEOpFormatTrk
;    Carries out a format track op on an IDE disc.
;
; WinIDEOpSeek
;    Carries out a seek track op on an IDE disc.
;
; WinIDEOpRestore
;    Carries out a restore op on an IDE disc.
;
; WinIDEOpSpecify
;    Specify heads and sectors per track on drive.
;
; WinIDEOpWriteSecs
;    Carries out a write sectors op on an IDE disc.
;
; WinIDEOpReadSecs
;    Carries out a read sectors op on an IDE disc.
;
; WinIDEReadWriteSecs
;    The main body of code used to read and write sectors from/to an
;    IDE disc.
;
;*********************************************************************

DoSwiSetIDEController   ROUT
;
; Gives the IDE driver the details of an alternative controller.
;
; Entry:
;    R2 -> IDE controller
;    R3 -> interrupt status of controller
;    R4 =  AND with status, NE => IRQ
;    R5 -> interrupt mask
;    R6 =  OR into mask enables IRQ
;    R7 -> data read routine (0 for default)
;    R8 -> data write routine (0 for default)
;    SB -> static workspace
;
; Exit:
;    VS => error
;          R0 = error
;    VC => no error
;          R0 preserved
;    All other registers preserved

        Push    "R0,R7-R9,LR"

 [ :LNOT:ByteAddressedHW ; Call assumes word-addressed HW

; Ignore all this if no drives configured

 [ :LNOT:AutoDetectIDE
        LDRB    R0,WinIDEDrives
        TEQS    R0,#0
        BEQ     %FT90
 ]

; Some IDE drives configured
; If currently using a device, release its IRQ

        sbaddr  R9,WinIDEHardware
        BL      WinReleaseIDEIRQs       ; (R9->R0,V)

; If data transfer routine addresses not passed, use default

        TEQS    R7,#0                   ; default data in routine?
        ADDR    R7,WinIDEReadASector,EQ ; if yes, set it up
        TEQS    R8,#0                   ; default data out routine?
        ADDR    R8,WinIDEWriteASector,EQ ; if yes, set it up

; Save info

      [ HAL
        ASSERT  WinIDEPtr = 4
      |
        ASSERT  WinIDEPtr = 0
      ]
        ASSERT  WinIDEPollPtr = WinIDEPtr + 4
        ASSERT  WinIDEPollBits = WinIDEPollPtr + 4
        ASSERT  WinIDEIRQPtr = WinIDEPollBits + 4
        ASSERT  WinIDEIRQBits = WinIDEIRQPtr + 4
        ASSERT  WinIDEReadPtr = WinIDEIRQBits + 4
        ASSERT  WinIDEWritePtr = WinIDEReadPtr + 4

      [ HAL
        STMIB   R9,{R2-R8}
      |
        STMIA   R9,{R2-R8}
      ]

 [ HAL
 [ Override_PDevNo <> -1
        MOV     R14, #Override_PDevNo
 |
        MOV     R14, #Podule_DevNo
 ]
        STRB    R14, WinIDEHardware+WinIDEHWDevNo
 ]
        MOV     R14, #WinIDEHW_Podule
        STRB    R14, WinIDEHardware+WinIDEHWType

 [ HAL
        ADD     R14,R2,#IDERegCtlDefaultOffset
        STR     R14,WinIDEHardware+WinIDECtrlPtr
 ]

; Claim the device vector

        BL      WinClaimIDEIRQs         ; (R9->R0,V)
        STRVS   R0,[SP]                 ; on error, return
        Pull    "R0,R7-R9,PC",VS

; Enable interrupts in the controller.
; This is ok as it is not until the IRQ is enabled in the podule that it
; will actually be able to interrupt.

 [ HAL
        LDR     R2,WinIDEHardware+WinIDECtrlPtr
 ]
        MOV     R0,#0                   ; IEN
        STRB    R0,[R2,#:INDEX:IDERegDevCtrl]

; Mark drives as uninitialised

        MOV     R0,#WinIDEDriveStateReset
        ASSERT  WinIDEMaxDrives = 2
        STRB    R0,WinIDEDriveState+0
        STRB    R0,WinIDEDriveState+1
 ] ; :LNOT: ByteAddressedHW
90
        CLRV
        Pull    "R0,R7-R9,PC"

;*********************************************************************

DoSwiWinPowerControl    ROUT
;
; Controls the power-saving features of the ADFS system
;
; Entry:
;    R0 = reason
;
;         0 => read drive spin status
;           Entry:
;              R1 = drive (4..7)
;           Exit:
;              R2 = 0 => drive is not spinning
;                  !0 => drive is spinning
;
;         1 => set drive autospindown
;           Entry:
;              R1 = drive (4..7)
;              R2 =  0 => disable autospindown and spinup drive
;                   !0 => set autospindown to R2*5 seconds
;           Exit:
;                 R3 = previous enable value
;
;         2 => manual control of drive spin without affecting autospindown
;           Entry:
;              R1 = drive (4..7)
;              R2 = 0 => spin down immediately
;                  !0 => spin up immediately

 [ HAL
        Push    "R3-R5,R9,IDECtrl,IDE,LR"
 |
        Push    "R3-R5,R9,IDE,LR"
 ]

; Get drive type (ST506/IDE)

        AND     LR,R1,#2_11
        ADD     LR,LR,#:INDEX:WinDriveTypes
        LDRB    R5,[SB,LR]              ; get type from map
        TEQS    R5,#&FF
        BEQ     %FT80                   ; branch if not installed

; Drive is present

        TSTS    R5,#bit3                ; 8/9 => ST506
        BNE     %FT80                   ; branch if not IDE

; Drive is IDE
; Check that we have an IDE controller

        sbaddr  R9,WinIDEHardware
 [ TwinIDEHardware
        TST     R5,#2
        ADDNE   R9,R9,#SzWinIDEHardware
        STR     R9,WinIDECurrentHW
 ]
        LDRB    LR,[R9,#WinIDEIRQDevNo]
        TEQS    LR,#0                   ; got controller ?
        BEQ     %FT80                   ; branch if not

; Lock controller

        BL      LockIDEController
        baddr   R0,DriverInUseErrBlk,VS ; if error, make R0 -> err block
        BVS     %FT89

; Get current power state

        STRB    R5,WinIDEDriveNum       ; save logical drive (0-3)

        sbaddr  R3,WinIDEPowerState     ; R3 -> drive power states
        LDRB    R3,[R3,R5]              ; R3 = state of this drive

 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        LDMIA   R9,{IDECtrl,IDE}        ; set IDE -> IDE controller
 |
        LDR     IDE,[R9,#WinIDEPtr]     ; set IDE -> IDE controller
 ]


; Select drive

        Push    "R0"
        MOV     R0,#0                   ; head
        BL      WinIDESetDriveAndHead   ; (R0->R0)
        Pull    "R0"

; Set timeout register

        MOV     R5,#WinIDETimeoutMisc

; R0 = reason
; R1 = ADFS drive number
; R2 = parameter
; R3 = previous enable state
; R5 = timeout for command
; WinIDEDriveNum is IDE logical drive number (0/1)
; Switch(command)

        CMPS    R0,#3
        ADDCC   PC,PC,R0,LSL #2         ; dispatch if in range
        ASSERT  %FT05 = . + 4
        B       %FT84                   ; branch if not

;****** Insert nothing here
05
        B       %FT10                   ; read spin state
        B       %FT20                   ; set autospindown
        B       %FT30                   ; direct control

;****** Never fall through

10
; Case R0 = 0 - read drive spin status
;    Cmd(CheckPower), return SecCount

 [ IDEPower
;If drive is powered down, return a 'not spinning' indication.
;
;
        LDR     R0, Portable_Flags
        TST     R0, #PortableControl_IDEEnable
        MOVEQ   R2, #0                          ; power off, so not spinning
        BEQ     %FT15
;we know the drive is powered, so no need to call WinIDEcontrol to power it up
 ]
        MOV     R0,#IDECmdCheckPower
        BL      WinIDEPollCommand       ; (R0,R5->R0,V)
        BVS     %FT70                   ; branch if error
        LDRB    R2,IDERegSecCount       ; if ok, get power state
 [ IDEPower
15
 ]
        BL      UnlockIDEController
 [ HAL
        Pull    "R3-R5,R9,IDECtrl,IDE,PC"
 |
        Pull    "R3-R5,R9,IDE,PC"
 ]

;****** Never fall through

20
; Case R0 = 1 - set drive autospindown
;    Cmd(Idle,n)
;    Pstate = n
;    return old state

 [ IDEPower
        Push    "R1"
        MOV     R0, #1
        BL      WinIDEcontrol
        Pull    "R1"

        Push    "R5"
        LDRB    R0, WinIDEDriveNum
        MOV     R5,#WinIDETimeoutSpinup
        BL      WinIDEWaitReady
        Pull    "R5"
 ]

        STRB    R2,WinIDEParmSecCount   ; save parameter for command
        MOV     R0,#IDECmdIdle
        BL      WinIDEPollCommand       ; (R0,R5->R0,V)
        STR     R3,[SP]                 ; return old value
        BVS     %FT70                   ; branch if error

; command completed ok - update stored state

        LDRB    LR,WinIDEDriveNum       ; LR = drive number
        sbaddr  R3,WinIDEPowerState     ; R3 -> drive power states
        STRB    R2,[R3,LR]              ; write new state
        BL      UnlockIDEController
 [ HAL
        Pull    "R3-R5,R9,IDECtrl,IDE,PC"
 |
        Pull    "R3-R5,R9,IDE,PC"
 ]

;****** Never fall through

30
; Case R0 = 2 - control drive
;    Case R2 = 0 - spin down
;       Cmd(Standby,Pstate)
;    Case R2 != 0 - spin up
;       Cmd(Idle,Pstate)

 [ IDEPower
        LDR     R0, Portable_Flags
        TST     R0, #PortableControl_IDEEnable
        CMPEQ   R2, #0
        BEQ     %FT35
        Push    "R1"
        MOV     R0, #1
        BL      WinIDEcontrol
        Pull    "R1"

        Push    "R5"
        LDRB    R0, WinIDEDriveNum
        MOV     R5,#WinIDETimeoutSpinup
        BL      WinIDEWaitReady
        Pull    "R5"
 ]
        LDRB    LR,WinIDEDriveNum       ; LR = drive number
        sbaddr  R3,WinIDEPowerState     ; R3 -> drive power states
        LDRB    R0,[R3,LR]              ; R0 = power state of this drive
        STRB    R0,WinIDEParmSecCount   ; set up sector count for op

        TEQS    R2,#0                   ; spin down?
        MOVEQ   R0,#IDECmdStandby       ; if so, set standby mode
        MOVNE   R0,#IDECmdIdle          ; else set idle mode
        BL      WinIDEPollCommand       ; (R0,R5->R0,V)
 [ IDEPower
35
 ]
        BLVC    UnlockIDEController
 [ HAL
        Pull    "R3-R5,R9,IDECtrl,IDE,PC",VC ; return if no error
 |
        Pull    "R3-R5,R9,IDE,PC",VC       ; return if no error
 ]

; fall through on error

70
; error executing command (R0 = disc error number)
; convert disc error number to ASCII for substitution into
; error string

        SUB     sp,sp,#4                ; make space for xx<0>
        MOV     R1,sp                   ; R1 -> buffer
        MOV     R2,#4                   ; R2 = buffer size
        SWI     XOS_ConvertHex2         ; convert error code in R0

; call international stuff to do substitution etc.

        baddr   R0,DiscErrBlk           ; R0 -> error block
        MOVVC   R4,sp                   ; R4 -> parameter to substitute
        MOVVS   R4,#0                   ; no subst if convert failed
        BL      copy_error1             ; (R0,R4->R0)
        ADD     sp,sp,#4                ; collapse stack

        BL      UnlockIDEController

        SETV
 [ HAL
        Pull    "R3-R5,R9,IDECtrl,IDE,PC"
 |
        Pull    "R3-R5,R9,IDE,PC"
 ]

;****** Never fall through

84
; bad command (controller is locked)

        baddr   R0,BadComErrBlk         ; R0 -> error block
        BL      UnlockIDEController
        B       %FT89

;****** Never fall through

80
; drive not present or not IDE drive (controller not locked)

        baddr   R0,BadDriveErrBlk       ; R0 -> error block

89
; call international stuff to make R0 -> international error block

        BL      copy_error              ; (R0->R0)
        SETV
 [ HAL
        Pull    "R3-R5,R9,IDECtrl,IDE,PC"
 |
        Pull    "R3-R5,R9,IDE,PC"
 ]

;*********************************************************************

          GBLL  UserOpDMA
UserOpDMA SETL  {TRUE} :LAND: IDEDMA

DoSwiIDEUserOp  ROUT
;
; Direct user interface for low-level IDE commands.
; Must not be called in background.
;
; Entry:
;    R0 = b0 = action
;              1 => reset controller
;              0 => process command
;         b1 = don't wait for DRDY
;         b3 = 48-bit addressing command
;         b23..b16 = controller number
;         b25..b24 = transfer direction
;              00 => no transfer
;              01 => read
;              10 => write
;              11 reserved
;         b26 = transfer using DMA
;    R2 -> parameter block for command and results
;           original form: +0 Features          48-bit form: +0 Features
;                          +1 Sector Count                   +1 Sector Count Low
;                          +2 LBA Low/Sector No              +2 Sector Count High
;                          +3 LBA Mid/Cyl Low                +3 LBA 7..0
;                          +4 LBA High/Cyl High              +4 LBA 15..8
;                          +5 Device (+head)                 +5 LBA 23..16
;                          +6 Command                        +6 LBA 31..24
;                                                            +7 LBA 39..32
;                                                            +8 LBA 47..40
;                                                            +9 Device
;                                                           +10 Command
;    R3 -> buffer
;    R4 = length to transfer
;    R5 = timeout in centiseconds (0 = default)
;    SB -> static workspace
;    MODE: SVC
;    IRQ state: unknown
;
; Exit:
;    VS => error
;          R0 -> error block
;    VC => no error
;          R0 = command status (0 or a disc error number)
;          Parameter block updated
;    R3 updated
;    R4 updated
;    R5 undefined
;    All other registers preserved
;    IRQ state: preserved but IRQs enabled during call

 [ Debug21

        DLINE   "DoSwiIDEUserOp",cc
 ]

 [ HAL
        Push    "R1,R6,R7,R9,IDECtrl,IDE,LR"
 |
        Push    "R1,R6,R7,R9,IDE,LR"
 ]
        SavePSR LR
        Push    "LR"

; Check that we have an IDE controller

        AND     LR,R0,#&FF:SHL:WinIDEControllerShift
        sbaddr  R9,WinIDEHardware
 [ TwinIDEHardware
        CMP     LR,#1:SHL:WinIDEControllerShift
        ADDEQ   R9,R9,#SzWinIDEHardware
        LDRLSB  LR,[R9,#WinIDEIRQDevNo]
        MOVHI   LR,#0
 |
        TEQ     LR,#0
        LDREQB  LR,[R9,#WinIDEIRQDevNo]
        MOVNE   LR,#0
 ]

        TEQS    LR,#0                   ; got controller?
        baddr   R0,BadDriveErrBlk,EQ    ; if not, R0 -> error block
        BEQ     %FT89                   ; ...and branch

; We do have a controller to talk to - lock it

        BL      LockIDEController
        baddr   R0,DriverInUseErrBlk,VS ; if error, R0 -> error block
        BVS     %FT89                   ; ...and branch

; Check parameter block is valid address

        MOV     R7,R0                   ; save R0
        MOV     R0,R2
        TST     R7,#bit3
        ADDEQ   R1,R0,#7                ; bytes we need in parameter block
        ADDNE   R1,R0,#11
        SWI     XOS_ValidateAddress     ; check the addresses
        BCS     %FT82                   ; branch if invalid

; Enable interrupts so timers work

        WritePSRc SVC_mode,LR

; Set R5 = timeout

        TEQS    R5,#0                   ; default timeout?
        MOVEQ   R5,#WinIDETimeoutUser

; Set IDE -> IDE controller

 [ TwinIDEHardware
        STR     R9,WinIDECurrentHW
 ]
 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        LDMIA   R9,{IDECtrl,IDE}
 |
        LDR     IDE,[R9,#WinIDEPtr]
 ]

; Check if user wants to issue command or reset controller
; R7 = original R0

        TSTS    R7,#bit0                        ; 0 => reset
        BNE     %FT30                           ; branch if reset

; Set up R6 to point to data transfer routine (or 0) and R1 to be either
; ReadSecsOp or WriteSecsOp for WinIDEInstallTransferCode

        MOV     R6,#0                           ; assume no data transfer
        AND     LR,R7,#WinIDEDirectionMask      ; direction bits
        TEQS    LR,#WinIDEDirectionWrite        ; write?
        LDREQ   R6,[R9,#WinIDEWritePtr]         ; if write, R6 -> write code
        MOVEQ   R1,#DiscOp_WriteSecs            ;           R1 = write sectors
        TEQS    LR,#WinIDEDirectionRead         ; else read?
        LDREQ   R6,[R9,#WinIDEReadPtr]          ; if read, R6 -> read code
        MOVEQ   R1,#DiscOp_ReadSecs             ;          R1 = read sectors

; If data transfer requested, validate buffer address, install transfer
; code and set R1 -> buffer

        TEQS    R6,#0                           ; data transfer requested?
        BEQ     %FT05                           ; branch if not

; R1 = value to determine what transfer code is needed
; R3 -> buffer
; R4 = buffer length
; R6 -> data transfer routine

 [ :LNOT: NewTransferCode
 [ Debug21

        DLINE   "Installing transfer code..."
 ]
        BL      WinIDEInstallTransferCode       ; install RAM code (R1->R0)
 [ Debug21

        DLINE   "Installation successful"
 ]
 ]

        MOV     R0,R3                           ; R0 -> start of buffer
        ADD     R1,R0,R4                        ; R1 -> end of buffer
        SWI     XOS_ValidateAddress             ; check the addresses
        BCS     %FT82                           ; branch if invalid

; buffer addresses are valid

        MOV     R1,R3                           ; R1 -> buffer
05
; Set up command

        TSTS    R7,#bit3                ; 48-bit?

        MOV     LR,R2

        LDRB    R0,[LR],#1              ; get precomp reg value
        STRB    R0,WinIDEParmPrecomp

        LDRB    R0,[LR],#1              ; get sector count reg value
        STRB    R0,WinIDEParmSecCount

        LDRNEB  R0,[LR],#1              ; get sector count high reg value
        STRNEB  R0,WinIDEParmSecCountHigh

        LDRB    R0,[LR],#1              ; get sector number/LBA0to7 reg value
        STRB    R0,WinIDEParmSecNumber

        LDRB    R0,[LR],#1              ; get cylinder low/LBA8to15 reg value
        STRB    R0,WinIDEParmCylLo

        LDRB    R0,[LR],#1              ; get cylinder high/LBA16to23 reg value
        STRB    R0,WinIDEParmCylHi

        LDRNEB  R0,[LR],#1              ; get LBA24to31 reg value
        STRNEB  R0,WinIDEParmLBA24to31

        LDRNEB  R0,[LR],#1              ; get LBA32to39 reg value
        STRNEB  R0,WinIDEParmLBA32to39

        LDRNEB  R0,[LR],#1              ; get LBA40to47 reg value
        STRNEB  R0,WinIDEParmLBA40to47

        LDRB    R0,[LR],#1              ; get drive/head reg value
        STRB    R0,WinIDEParmDrvHead

        LDRB    R0,[LR],#1              ; get command reg value

        ORRNE   R0,R0,#WinIDECmdFlag_48bit :SHL:8

; Start the command
        TSTS    R7,#bit1                ; pass through "ignore DRDY" flag
        ORRNE   R0,R0,#WinIDECmdFlag_NoDRDY:SHL:8
        MOV     LR,R0,LSR #8
        STRB    LR,WinIDECommandFlags
        STRB    R0,WinIDECommandCode

 [ UserOpDMA
        TSTS    R7,#bit26               ; DMA command?
        BNE     %FT40
 ]

        BL      WinIDECommandDisc       ; (R0->R0,V)
        BVS     %FT70

; Allow time for drive to go busy (upto 400ns according to CAM 2.1).

07      MOV     R0,#1*2                 ; 1/2 us units
        BL      DoMicroDelay

; Start timer

        STR     R5,WinTickCount

10
; Wait for !BSY or timeout
; !BSY rather than interrupt as not ALL commands end with interrupt

        BL      WinIDEWaitNotBusy       ; NE => busy
        MOVNE   R0,#WinIDEErrTimeout    ; if still busy, error...
        BNE     %FT70                   ; ...branch

; Drive no longer busy but other status bits not valid for 400ns so wait

        MOV     R0,#1*2                 ; 1/2 us units
        BL      DoMicroDelay

; Check for error

        LDRB    R0,IDERegStatus
        TSTS    R0,#IDEStatusErrorBits
        BEQ     %FT15
        BL      WinIDEDecodeDriveStatus ; if error, decode status...
        B       %FT70                   ; ...and branch

15
; No error, R0 = status
; Check if transfer requested

        TEQS    R6,#0                   ; any transfer routine?
        BEQ     %FT50                   ; branch if not

; Transfer requested - check data length

        CMPS    R4,#0                   ; any data (left) to move
        BLE     %FT50                   ; branch if not

; Transfer requested and data length > 0
; Wait for DRQ to become asserted: according to CAM 2.1, this can
; take as long as 20ms (class 3 command) although Conner drives appear
; to assert it immediately. This loop is inaccurate because the resolution
; of the delay routine is only 0.5us but it is good enough for this.

        MOV     R7,#&4F00                       ; counter for loop
                                                ; approx 20*1000
20
        LDRB    R0,IDERegStatus                 ; get status
        AND     R0,R0,#IDEStatusDRQ             ; mask bits except DRQ
        TEQS    R0,#IDEStatusDRQ                ; EQ => got DRQ
        SUBNES  R7,R7,#1                        ; if not, decrement count...
        MOVNE   R0,#1*2                         ; ...and wait (1/2 us units)
        BLNE    DoMicroDelay                    ; (preserves flags)
        BNE     %BT20

; Have got DRQ or are giving up waiting

        LDRB    R0,IDERegStatus                 ; get status
        TSTS    R0,#IDEStatusDRQ
        BEQ     %FT50                           ; branch if no DRQ

; DRQ and data transfer requested: move data

 [ Debug21

        DLINE   "Moving data",cc
 ]

        MOV     R0,R4                   ; R0 = limit on transfer...
        MOV     LR,PC                   ; set link
        MOV     PC,R6                   ; branch to routine

; data transfer routine returns here (all flags preserved)

        SUBS    R4,R4,#WinIDEBytesPerSector ; decrement count by 1 sector
        MOVMI   R4,#0                   ; if all done, set limit=0
        B       %BT10                   ; go again

;****** Never fall through

30
; Reset controller
; R2 -> where to return register contents
; R5 = timeout for drive !busy
; IDE -> controller

        BL      WinIDEResetDrives       ; preserves registers

; Start timer

        STR     R5,WinTickCount

; Wait for drive to be not busy so can return register contents

        BL      WinIDEWaitNotBusy       ; NE => busy
        MOVNE   R0,#WinIDEErrTimeout    ; if so, error...
        BNE     %FT70                   ; ...and branch

; Drive no longer busy but other status bits not valid for 400ns so wait

        MOV     R0,#1*2                 ; 1/2 us units
        BL      DoMicroDelay

; Check for error

        LDRB    R0,IDERegStatus
        TSTS    R0,#IDEStatusErrorBits
        BEQ     %FT50
        BL      WinIDEDecodeDriveStatus ; if error, decode status...
        B       %FT70                   ; ...and branch

 [ UserOpDMA
40
; DMA command - we just program up the transfer, and it's the DMA manager's
; job, together with our callbacks (in Adfs14), to tell us when it's finished.

        ORR     LR,LR,#WinIDECmdFlag_DMA
        STRB    LR,WinIDECommandFlags

        STR     R5,WinTickCount
        MOV     LR,#0
        STRB    LR,WinIDECommandCode_PIO        ; no PIO fallback

        TST     R7,#bit24                       ; read or write (Z flag also used
        MOVNE   R0,#0                           ; below)
        MOVEQ   R0,#1

        sbaddr  LR,WinIDEFakeScatterList        ; turn it into a scatter list
        STMIA   LR!,{R3,R4}

        MOV     R7,#WinIDEBytesPerSector        ; add in padding to make it a multiple
        SUB     R7,R7,#1                        ; of the sector size
        MOV     R3,R4
        ADD     R4,R4,R7                        ; R4 = length rounded up to
        BIC     R4,R4,R7                        ;      a sector
        SUB     R7,R4,R3                        ; R7 = amount of padding
        sbaddr  R3,WinIDEDMASink,NE             ; excess reads -> sink
        sbaddr  R3,WinIDEDMAZeroes,EQ           ; excess writes as 0
        STMIA   LR,{R3,R7}

        SUB     R3,LR,#8                        ; R3 -> scatter, R4 = rounded length
        BL      WinIDEQueueTransfer             ; DMA handlers will issue
        BVS     %FT48                           ; actual ATA command

41      LDRB    LR,WinIDEDMAStatus
        TST     LR,#DMAStat_Completed
        BNE     %FT45
        BL      WinIDEExamineTransfer           ; We need to "prod" the DMA manager
        BVS     %FT48                           ; like this, as the bus master
                                                ; has no interrupts of its own.

        LDR     R7,WinTickCount
        TEQS    R7,#0
        BNE     %BT41

        MOV     R0,#WinIDEErrTimeout
        BL      WinIDETerminateTransfer ; this will cause "Completed" status
        B       %BT41

45      LDR     R0,WinIDEDMAResult

48      TEQ     R0, #0                  ; R0 = error from DMA routine
        BEQ     %FT49                   ; if 0, check drive status
        CMP     R0, #256                ; if <256, it's already a status
        BLO     %FT70
        LDR     LR, [R0]                ; else if error = "Device error"
        LDR     R7, =&C36
        TEQ     LR, R7
        BEQ     %FT49                   ; then check drive status
        B       %FT88                   ; else return the error

49
        LDRB    R0,IDERegStatus
        ANDS    R0,R0,#IDEStatusErrorBits
        BLNE    WinIDEDecodeDriveStatus ; if error, decode status...
        B       %FT70                   ; ...and branch
 ]


50
; No error

        MOV     R0,#0                   ; all ok

70
; Transfer done or no data transfer requested
; R0 = status to return to user
; Cancel timer to speed up ticker routine

        MOV     LR,#0
        STR     LR,WinTickCount

; Update register block

        LDRB    LR,WinIDECommandFlags
        TST     LR,#WinIDECmdFlag_48bit

        MOV     R7,R2

        LDRB    LR,IDERegError
        STRB    LR,[R7],#1

        LDRB    LR,IDERegSecCount
        STRB    LR,[R7],#1
        ADDNE   R7,R7,#1                ; leave room for high byte

        LDRB    LR,IDERegLBALow
        STRB    LR,[R7],#1

        LDRB    LR,IDERegLBAMid
        STRB    LR,[R7],#1

        LDRB    LR,IDERegLBAHigh
        STRB    LR,[R7],#1
        ADDNE   R7,R7,#3                ; leave room for high bytes

        LDRB    LR,IDERegDrvHead
        STRB    LR,[R7],#1

        LDRB    LR,IDERegStatus
        STRB    LR,[R7],#1
        BEQ     %FT75

        MOV     LR,#IDEDevCtrlHOB       ; set High Order Byte bit
        STRB    LR,IDERegDevCtrl        ; (will be reset by next register write)

        LDRB    LR,IDERegSecCount
        STRB    LR,[R2,#2]

        LDRB    LR,IDERegLBALow
        STRB    LR,[R2,#6]

        LDRB    LR,IDERegLBAMid
        STRB    LR,[R2,#7]

        LDRB    LR,IDERegLBAHigh
        STRB    LR,[R2,#8]

75

; unlock IDE controller

        BL      UnlockIDEController

; Return

        Pull    "LR"
        BIC     LR,LR,#V_bit
        RestPSR LR,,cf
 [ HAL
        Pull    "R1,R6,R7,R9,IDECtrl,IDE,PC" ; restore IRQ state and return
 |
        Pull    "R1,R6,R7,R9,IDE,PC"       ; restore IRQ state and return
 ]

;****** Never fall through

88
; other error (controller is locked)
        BL      UnlockIDEController
        B       %FT98
82
; bad parameter block or buffer address (controller is locked)

        baddr   R0,BadAddressErrBlk     ; R0 -> error block
        BL      UnlockIDEController
89
; call international stuff to make R0 -> international error block

        BL      copy_error              ; (R0->R0)
98
        Pull    "LR"
        ORR     LR,LR,#V_bit
        RestPSR LR,,cf
 [ HAL
        Pull    "R1,R6,R7,R9,IDECtrl,IDE,PC"
 |
        Pull    "R1,R6,R7,R9,IDE,PC"
 ]

        LTORG

;*********************************************************************

 [ AutoDetectIDE

; DoSwiIDEDeviceInfo

; entry:

; r0 = flags/reason code.  any non-zero value will result in BadParmsErr

; R1 = physical device (0-3)

; on exit

; R0 = preserved

; R1 = type of device:
;       0 - no device
;       1 - non-packet
;       2 - packet device

; R2 = ADFS drive number of device, if applicable.  otherwise undefined

; R3 = pointer to device id info for this device, or zero

DoSwiIDEDeviceInfo ROUT
        Push    "R0,LR"

        ; check that the reason code/flags is zero

        TEQS    r0, #0

        BEQ     %FT10                   ; ok if zero

05
        ADRL    r0, BadParmsErrBlk      ; return bad parameters error
        BL      copy_error
        STR     r0, [SP]
        SETV
        Pull    "R0,PC"

10
        ; check the drive number is valid

        CMPS    r1, #WinIDEMaxDrives
        BHS     %BT05                   ; if greater than or equal then exit with error

        ; drive number checked

        ADRL    r3, WinIDEDeviceMappings
        LDRB    r2, [r3, r1]            ; get drive number (also gives type)

        ADR     r3, WinIDEDeviceNoIdFlags
        LDRB    r3, [r3, r1]            ; check it had Identify information
        TEQ     r3, #0
        ADREQ   r3, WinIDEDeviceIds
        ADDEQ   r3, r3, r1, LSL #9      ; point to device info
        MOVNE   r3, #0

        TEQS    r2, #WinIDEATAPIDevice  ; is it atapi
        MOVEQ   r1, #2
        BEQ     %FT90

        TEQS    r2, #WinIDENoDevice
        MOVEQ   r1, #0
        MOVEQ   r3, #0                  ; no device, so no info
        MOVNE   r1, #1                  ; ATA device

90
        CLRV
        Pull    "R0,PC"

 ]

;*********************************************************************
 [ IDEPower
WinIDEcontrol   ROUT
;
; Enable/Disable IDE hardware for power saving on the portable
;
; Entry:
;    R0 = New state, 0= disable, !0= enable
;
; Exit:
;    R1 = Portable_Flags
;
; Modifies:
;       R0
;       Updates Portable_Flags word

        LDR     R1, Portable_Flags
        TST     R1, #Portable_Present           ; Portable present?
        MOVEQ   PC, LR                          ; No then exit

        Push    "R2,LR"
        TEQ     R0, #0                          ; Disabling IDE?
        MOVNE   R0, #PortableControl_IDEEnable  ; No then set enable bit
        AND     LR, R1, #PortableControl_IDEEnable ; Get IDE enable bit
        TEQ     LR, R0                          ; Any change
        Pull    "R2,PC",EQ                      ; No then exit

        SETPSR  SVC26_mode, LR,, R2             ; Switch to SVC mode
        NOP
        Push    "LR"                            ; Save SVC_LR

        MOV     R1, #:NOT:PortableControl_IDEEnable ; IDE enable bit mask
        SWI     XPortable_Control               ; En/Disable IDE H/W
        ORRVC   R1, R1, #Portable_Present       ; No error -> portable
        MOVVS   R1, #PortableControl_FDCEnable  ; Error -> not portable, FDC enabled
        ORRVS   R1, R1, #PortableControl_IDEEnable ; Error -> not portable, IDE enabled

        Pull    "LR"                            ; Restore SVC_LR
        RestPSR R2,,cf                          ; Restore CPU mode
        NOP

 [ Debug10p
        DREG    R1,"New portable flags:"
 ]
        STR     R1, Portable_Flags              ; Save enable state
        Pull    "R2,PC"

;*********************************************************************
 ]
WinLowLevelIDE  ROUT
;
; Called from WinLowLevel when the drive number indicates that
; the drive is an IDE drive.
;
; Entry:
;    R1 = b0-3: reason code
;            0= verify, 1= read, 2= write sectors
;            3= verify track, 4= format track,
;            5= Seek, 6= Restore, 7= Step in, 8= Step out,
;            15= specify
;         b4 = Alternate defect map
;         b5 = R3 -> scatter list
;         b6 = Ignore escape
;         b7 = No ready timeout
;         b8 = Background op
 [ BigDisc
;    R2 = sector disc address (sector/track aligned), top 3 bits = drive (0-3)
 |
;    R2 = byte disc address (sector/track aligned), top 3 bits = drive (0-3)
 ]
;    R3 -> transfer buffer/scatter list
;    R4 = length in bytes
;    R5 -> disc record
;    R6 -> defect list
;    R12 = SB
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0 (definition)
;    R2 = disc address of next byte to transfer
;    R3 -> Next buffer address
;    R4 = Number of bytes left in buffer
;    R5-R9 undefined

 [ HAL
        Push    "R9,IDECtrl,IDE,LR"
 |
        Push    "R9,IDE,LR"
 ]

 [ IDEPower
;
; Ensure power is on,
;
        Push    "R0, R1"
        MOV     R0, #1
        BL      WinIDEcontrol           ; Enable IDE H/W
        Pull    "R0, R1"
 ]

; try to lock IDE controller

        BL      LockIDEController
        baddr   R0,DriverInUseErrBlk,VS ; if error, set R0 -> err block
        BLVS    copy_error              ; (R0->R0)
        BVS     %FT15                   ; ... and branch

; Set IDE -> IDE controller

        sbaddr  R9,WinIDEHardware
 [ TwinIDEHardware
        TST     R2,#1:SHL:30
        ADDNE   R9,R9,#SzWinIDEHardware
        STR     R9,WinIDECurrentHW
 ]
 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        ASSERT  WinIDEPtr = WinIDECtrlPtr + 4
        LDMIA   R9,{IDECtrl,IDE}
 |
        LDR     IDE,[R9,#WinIDEPtr]
 ]

; Save drive number

        MOV     R0,R2,LSR #(32-3)               ; 0/1
        STRB    R0,WinIDEDriveNum

; Save op

        STR     R1,WinIDEFileCoreOp

; Remove the disc bits from the disc address

        BIC     R2,R2,#DiscBits

; Check if we have a controller to talk to

        LDRB    LR,[R9,#WinIDEIRQDevNo]
        TEQS    LR,#0                   ; got controller?
        MOVEQ   R0,#BadDriveErr         ; if not, return error
        BEQ     %FT30

; We do have a controller to talk to

        ASSERT  WinIDEBytesPerSector = 512
 [ BigDisc
 |
; Sector align the disc address
        MOV     R2,R2,LSR #9
        MOV     R2,R2,LSL #9
 ]
; save the disc address
        STR     R2,WinIDEDiscAddress
 [ BigDisc
        MOV     LR,#0
        STR     LR, WinIDESectorOffset
 ]

; Save some physical attributes of drive for later
; - Sectors per track

        LDRB    LR,[R5,#SecsPerTrk]
        STRB    LR,WinIDESecsPerTrk

; - Heads

        LDRB    LR,[R5,#Heads]
        STRB    LR,WinIDEHeads

; Disc size (limit on any transfer)

        LDR     LR,[R5,#DiscSize]               ; get disc size (bytes)
        STR     LR,WinIDEDiscSize               ; and save it
 [ BigDisc
        LDR     LR,[R5,#DiscSize2]              ; get disc size (bytes)
        STR     LR,WinIDEDiscSize2              ; and save it
 ]

; Check if drive needs initialising and handle it if so
; (check inline for speed during normal access)
; R0 = drive number (0/1)

        sbaddr  R8,WinIDEDriveState             ; R8 -> drive states
        LDRB    R9,[R8,R0]                      ; get this drive's state
        CLRV                                    ; as, on init, VS => error
        TEQS    R9,#WinIDEDriveStateActive      ; drive fully initialised?
        BLNE    WinIDEInitDrive                 ; (R0,R6,R8,R9->R0,R5-R7,R9,V)
        BVS     %FT30                           ; branch if error (no callback)

; Switch(op)

        AND     R0,R1,#DiscOp_Op_Mask
        CMPS    R0,#WinIDEJmpTableSize          ; check op in range
        BCS     %FT20                           ; branch if not
        MOV     LR,PC                           ; set return link
        ADD     PC,PC,R0,LSL #2                 ; dispatch if in range
        ASSERT  %FT10 = . + 4

; valid ops return here

        B       %FT30

;****** Do not insert anything here ******
10
        B       WinIDEOpVerify
        B       WinIDEOpReadSecs
        B       WinIDEOpWriteSecs
        B       %FT20                           ; unknown op
        B       WinIDEOpFormatTrk
        B       WinIDEOpSeek
        B       WinIDEOpRestore
WinIDEJmpTableSize      *       (.-%BT10)/4

;****** Never fall through

15 ; here if failed to lock controller - same as code below but leave controller locked

 [ :LNOT:NewErrors
        ORR     R0,R0,#ExternalErrorBit ; for FileCore
 ]
;        LDR     R1,WinIDEFileCoreOp     ; restore R1 = Op
;        DREG    R1, "WinIDEFileCoreOp:"
        TSTS    R1,#DiscOp_Op_BackgroundOp_Flag
;        BLEQ    UnlockIDEController     ; unlock controller if not bg
        TSTNES  R1,#DiscOp_Op_ScatterList_Flag
        TEQNES  R0,#0
        BLNE    WinIDECallbackBg_LockFailed ; unlocks controller
;       BL      LockIDEController       ; leave it locked

 [ HAL
        Pull    "R9,IDECtrl,IDE,LR"
 |
        Pull    "R9,IDE,LR"
 ]
        B       SetVOnR0
20
; Opcode not in table
; Check for specify

        TEQS    R0,#DiscOp_Specify              ; specify
        MOVNE   R0,#BadParmsErr                 ; if not, error
        BLEQ    WinIDEOpSpecify                 ; if so, do it


30
; R0 = completion code
; R2 = disc address (minus disc bits)
; R3 -> buffer/scatter list
; R4 = amount not transferred

; Unlock IDE controller if no background transfer still running
; If background not started due to foreground error, callback FileCore
; i.e.
;
; if !background
;    unlock IDE controller
; else
;    if scatter_list and foreground error (i.e. background not started)
;       do FileCore callback

        LDR     R1,WinIDEFileCoreOp     ; restore R1 = Op
        TSTS    R1,#DiscOp_Op_BackgroundOp_Flag
        BLEQ    UnlockIDEController     ; unlock controller if not bg
        TSTNES  R1,#DiscOp_Op_ScatterList_Flag
        TEQNES  R0,#0
        BLNE    WinIDECallbackBg        ; unlocks controller

 [ HAL
        Pull    "R9,IDECtrl,IDE,LR"
 |
        Pull    "R9,IDE,LR"
 ]
        ASSERT  .=WinIDEAdjustStatus

;****** Fall through to WinIDEAdjustStatus

;*********************************************************************

WinIDEAdjustStatus      ROUT
;
; Adjusts completion code to be in FileCore completion code format.
;
; Entry:
;    R0 = completion code
 [ BigDisc
;    R2 = sector disc address (minus disc bits)
 |
;    R2 = byte disc address (minus disc bits)
 ]
;    WinLogicalDrive = logical drive number (as passed by FileCore)
;    MODE: SVC (IRQ state unknown) or IRQ (IRQs disabled)
;
; Exit:
;    R0 = return value for FileCore
 [ BigDisc
;    R2 = sector disc address (including disc bits)
 |
;    R2 = byte disc address (including disc bits)
 ]
;    V is set/clear according to contents of R0
;    R5 undefined
;    All other registers preserved


 [ Debug20
        DREG    R0,"WinIDEAdjustStatus: R0="
 ]

 [ BigDisc
        LDRB    R5,WinLogicalDrive      ; get drive number (4..7)
        ORR     R2,R2,R5,LSL #(32-3)

        CMPS    R0,#0                   ; error?
        RSBHIS  R5,R0,#MaxDiscErr+1     ; if yes, is it a disc error ?
        BLS     %FT01
 [ NewErrors
        Push    "R1-R4"
        MOV     R1,R0,LSL #8
        ORR     R1,R1,R2,LSR #(32-3)
        BIC     R2,R2,#DiscBits
        ASSERT  WinIDEBytesPerSector = 512
        MOV     R3,R2,LSR #(32-9)
        MOV     R2,R2,LSL #9
        ADR     R0,WinIDEErrorNo
        STMIA   R0,{R1,R2,R3}
        ORR     R0,R0,#NewDiscErrorBit
        Pull    "R1-R4"
 |
        Push    "R1"
        MOV     R1, R0
        ADR     R0, WinIDEErrorNo       ;
        STMIA   R0, {R1,R2}
        ORR     R0,R0,#DiscErrorBit+ExternalErrorBit
        Pull    "R1"
 ]
01
 |
        LDRB    R5,WinLogicalDrive      ; get drive number (4..7)
        ORR     R2,R2,R5,LSL #(32-3)

        CMPS    R0,#0                   ; error?
        RSBHIS  R5,R0,#MaxDiscErr+1     ; if yes, is it a disc error ?
        MOVHI   R0,R0,LSL #24           ; if yes, put error number in place
        ORRHI   R0,R0,R2,LSR #8         ;         and disc address
        ORRHI   R0,R0,#DiscErrorBit     ;         and disc error bit
 ]

        B       SetVOnR0

;*********************************************************************

WinIDEInitDrive ROUT
;
; Initialises drive when it appears not to have been initialised
;
; Entry:
;    R0 = drive number 0=>master, 1=>slave
;    R6 -> defect list and drive-specific parameters
;    SB -> static workspace
;    R8 -> WinIDEDriveState (i.e. R8+R0 -> state for this drive)
;    R9 = initialisation flag for this drive != WinIDEDriveStateActive
;    IDE -> IDE controller (locked)
;    WinIDEDriveNum valid
;    MODE: SVC
;    IRQ state: enabled
;    TickerV: claimed
;
; Exit:
;    VS => error
;          R0 = error code
;    VC => all ok
;          R0 = 0
;    R5,R7,R9 undefined
;    All other registers preserved
;    Drive state of drive [R0] updated

        Push    "LR"

 [ Debug21
        DLINE    "WinIDEInitDrive"
 ]

; Ticker routine cannot get in to interfere as locked out by
; WinIDECommandActive so no need to disable interrupts etc.

        MOV     R7,R0                           ; save drive number

; If drive is still recovering from reset or has just received power
; command, wait for it to become ready. This is the only time that this
; happens. All other entry points expect the drive to be ready.

        MOV     R5,#WinIDETimeoutIdle           ; R5 = short timeout
        TEQS    R9,#WinIDEDriveStateReset       ; has drive just been reset?
        MOVEQ   R5,#WinIDETimeoutSpinup         ; if so, R5 = long timeout
        TEQNES  R9,#WinIDEDriveStateIdled       ; else, just idled?
        BNE     %FT20                           ; branch if not

; Need to wait for drive to become ready

        BL      WinIDEWaitReady                 ; (R0,R5->R0,V)
        Pull    "PC",VS                         ; return if error

; If drive recovering from reset, issue power command to it if it needs it

        TEQS    R9,#WinIDEDriveStateReset       ; just reset?
        BNE     %FT10                           ; branch if not

; Drive has just been reset

 [ Debug21
        BREG    R7,"InitIdle "
 ]
        sbaddr  LR,WinIDEPowerState             ; LR -> power states
        LDRB    LR,[LR,R7]                      ; get value for this drive
        TEQS    LR,#0                           ; drive needs idle cmd?
        BEQ     %FT10                           ; branch if not

; Drive *does* need idle command

        STRB    LR,WinIDEParmSecCount
        MOV     R0,#IDECmdIdle
        MOV     R5,#WinIDETimeoutIdle
        BL      WinIDEPollCommand               ; (R0,R5->R0,R5,V)

; Ignore any error as this must not prevent disc access

        MOV     R0,R7                           ; R0 = drive
        MOV     R5,#WinIDETimeoutIdle           ; R5 = short timeout
        BL      WinIDEWaitReady                 ; (R0,R5->R0,V) ignore error
 [ Debug21

        BVC     %FT01
        DLINE   "*Not* "
01
        DLINE   "Ready"
02
        ]
10

; Drive now spinning

        MOV     R9,#WinIDEDriveStateSpinning    ; move to next state

20

; See if have parameters to initialise it and whether it needs it
; R7 = IDE drive number (0/1)

        sbaddr  LR,WinIDEDriveSecsPerTrk        ; LR -> secs/trk for drives
        LDRB    R0,[LR,R7]                      ; R0 = secs/trk for this drive
        CMPS    R0,#0                           ; initialised yet?
        STREQB  R9,[R8,R7]                      ; if not, update state
        Pull    "PC",EQ                         ; ...and return

; Drive parameter variables have been initialised by Mount
; See if this drive needs initialisation

        sbaddr  LR,WinIDEDriveInitFlags         ; LR -> init flags for drives
        LDRB    R0,[LR,R7]                      ; R0 = flag for this drive
        TSTS    R0,#1                           ; needs init?
        MOVEQ   R9,#WinIDEDriveStateActive      ; if not, all done
        STREQB  R9,[R8,R7]                      ; update state
        Pull    "PC",EQ                         ; ...and return

; Drive does need initialisation
; Issue a Specify op to set up its shape
; Need to set up WinIDESecsPerTrk, WinIDEHeads for Specify but must preserve
; previous values for whatever op comes next as they will have been copied
; out of the disc record passed in the op

        LDRB    LR,WinIDESecsPerTrk
        LDRB    R0,WinIDEHeads
        Push    "R0,LR"

        sbaddr  LR,WinIDEDriveSecsPerTrk        ; set up WinIDESecsPerTrk
        LDRB    R0,[LR,R7]
        STRB    R0,WinIDESecsPerTrk

        sbaddr  LR,WinIDEDriveHeads             ; set up WinIDEHeads
        LDRB    R0,[LR,R7]
        STRB    R0,WinIDEHeads

; WinIDEDriveNum already set up by WinLowLevelIDE

        BL      WinIDEOpSpecify                 ; init the drive shape
        MOVVC   R9,#WinIDEDriveStateActive      ; flag active if ok

; Restore WinIDESecsPerTrk, WinIDEHeads

        Pull    "R5,LR"
        STRB    LR,WinIDESecsPerTrk
        STRB    R5,WinIDEHeads

; R9 = drive state
; R8+R7 -> state variable for this drive

        STRB    R9,[R8,R7]                      ; update state
        Pull    "PC"                            ; return result of specify

;*********************************************************************

WinIDEOpVerify          ROUT
;
; Verify sectors on an IDE drive.
; Called from WinLowLevelIDE.
;
; Entry:
;    R1 = b0-3: reason code
;            0= verify, 1= read, 2= write sectors
;            3= verify track, 4= format track,
;            5= Seek, 6= Restore, 7= Step in, 8= Step out,
;            15= specify
;         b4 = Alternate defect map
;         b5 = R3 -> scatter list
;         b6 = Ignore escape
;         b7 = No ready timeout
;         b8 = Background op
 [ BigDisc
;    R2 = sector disc address (sector/track aligned), top 3 bits = drive (0/1)
 |
;    R2 = byte disc address (sector/track aligned), top 3 bits = drive (0/1)
 ]
;    R4 = length in bytes
;    IDE -> IDE controller
;    SB -> static workspace
;    WinIDEDriveNum = physical drive number
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0
;    R2 = disc address of next byte to verify
;    R4 = number of bytes left to verify
;    R5 undefined
;    All other registers preserved

        Push    "R3,LR"

 [ EngineeringMode
        LDR     R0, IDEVerifyType
        LDR     LR, ECCData ;=&43434578          ; "xECC"
        TEQ     R0, LR
        MOVNE   R0, #IDECmdVerify
        MOVEQ   R0, #IDECmdVerifyEng
  [ Debug20
        DREG    R0, "Verify command used="
  ]
 |
        MOV     R0,#IDECmdVerify
 ]
 [ BigDisc
        ORR     R0,R0,#IDECmdVerifyExt:SHL:16
 ]
        BL      WinIDEReadWriteSecs             ; (R0-R4->R0,R2-R5,V)

        Pull    "R3,PC"

ECCData DCD &43434578

;*********************************************************************

WinIDEOpFormatTrk       ROUT
;
; Format a track on an IDE drive.
; Called from WinLowLevelIDE.
;
; Entry:
;    R1 = b0-3: reason code
;            0= verify, 1= read, 2= write sectors
;            3= verify track, 4= format track,
;            5= Seek, 6= Restore, 7= Step in, 8= Step out,
;            15= specify
;         b4 = Alternate defect map
;         b5 = R3 -> scatter list
;         b6 = Ignore escape
;         b7 = No ready timeout
;         b8 = Background op
 [ BigDisc
;    R2 = disc address (sector/track aligned), no disc bits
 |
;    R2 = disc address (sector/track aligned), no disc bits
 ]
;    R3 -> buffer/scatter list
;    R4 = bytes to transfer
;    IDE -> IDE controller
;    SB -> static workspace
;    WinIDEDriveNum = physical drive number
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0
;    R5 undefined
;    All other registers preserved

        Push    "R2-R4,LR"

; This must be a foreground op...

        TSTS    R1,#DiscOp_Op_BackgroundOp_Flag ; background ?

; ...with no scatter list

        TSTEQS  R1,#DiscOp_Op_ScatterList_Flag  ; if not bg, scatter list ?

; ...and exactly one sector of data to write

        TEQEQS  R4,#WinIDEBytesPerSector        ; if ok so far, check length

        MOVNE   R0,#BadParmsErr                 ; if wrong, return bad parms
        SETV    NE
        MOVVS   PC,LR

; OK so far

        MOV     R0,#IDECmdFormatTrk
        BL      WinIDEReadWriteSecs             ; (R0-R4->R0,R2-R5,V)

        Pull    "R2-R4,PC"

;*********************************************************************

WinIDEOpSeek            ROUT
;
; Seek to a specified track on an IDE drive.
; Called from WinLowLevelIDE.
;
; Entry:
 [ BigDisc
;    R2 = sector disc address (no disc bits)
 |
;    R2 = byte disc address (no disc bits)
 ]
;    IDE -> IDE controller
;    SB -> static workspace
;    WinIDEDriveNum = physical drive number
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0
;    R5 undefined
;    All other registers preserved

        Push    "LR"

; Set up the disk address

 [ BigDisc
; Quietly ignore seek requests to high (>28-bit) addresses, as
; there is no extended form of the seek command.
        CMP     R2,#&10000000
        BHS     %FT90
 ]

        MOV     LR,#0
        STRB    LR,WinIDECommandFlags

        BL      WinIDESetPhysAddress            ; (R2->R0)

; Cylinder, drive/head have already been set up in parameter block.
; Start command

        MOV     R0,#IDECmdSeek
        MOV     R5,#WinIDETimeoutMisc

        BL      WinIDEPollCommand               ; (R0,R5->R0,R5,V)

90      MOVVC   R0,#0

        Pull    "PC"

;*********************************************************************

WinIDEOpRestore         ROUT
;
; Restore (seek track 0 and recalibrate) an IDE drive.
; Called from WinLowLevelIDE.
;
; Entry:
;    IDE -> IDE controller
;    SB -> static workspace
;    WinIDEDriveNum = physical drive number
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0
;    R5 undefined
;    All other registers preserved

        Push    "LR"

; Select drive

        MOV     R0,#0
        BL      WinIDESetDriveAndHead           ; (R0->)

; Do command

        MOV     R0,#IDECmdRestore
        MOV     R5,#WinIDETimeoutMisc
        BL      WinIDEPollCommand               ; (R0,R5->R0,R5,V)

        MOVVC   R0,#0

        Pull    "PC"

;*********************************************************************

WinIDEOpSpecify ROUT
;
; Specify heads and sectors per track on drive.
; Called from WinLowLevelIDE.
;
; Entry:
;    IDE -> IDE controller
;    SB -> static workspace
;    WinIDEDriveNum = physical drive number
;    WinIDEHeads, WinIDESecsPerTrk valid
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0
;    R5 undefined
;    All other registers preserved

        Push    "LR"

 [ Debug21

        DLINE   "WinIDEOpSpecify"
 ]

; Setup IDE registers to say how many heads and how many sectors per track

        LDRB    R0,WinIDEHeads                  ; get requested heads
        SUB     R0,R0,#1                        ; spec says so
        BL      WinIDESetDriveAndHead           ; (R0->)

        LDRB    R0,WinIDESecsPerTrk             ; get sectors per track
        STRB    R0,WinIDEParmSecCount           ; save it for CommandDisc

; Do command

        MOV     R0,#IDECmdInitParms
        MOV     R5,#WinIDETimeoutMisc
        BL      WinIDEPollCommand               ; (R0,R5->R0,R5,V)

        MOVVC   R0,#0

        Pull    "PC"

;*********************************************************************

WinIDEOpWriteSecs       ROUT
;
; Write sectors to an IDE drive.
; Called from WinLowLevelIDE.
;
; Entry:
;    R1 = b0-3: reason code
;            0= verify, 1= read, 2= write sectors
;            3= verify track, 4= format track,
;            5= Seek, 6= Restore, 7= Step in, 8= Step out,
;            15= specify
;         b4 = Alternate defect map
;         b5 = R3 -> scatter list
;         b6 = Ignore escape
;         b7 = No ready timeout
;         b8 = Background op
 [ BigDisc
;    R2 = sector disc address (no disc bits)
 |
;    R2 = byte disc address (no disc bits)
 ]
;    R3 -> buffer/scatter list
;    R4 = bytes to transfer
;    IDE -> IDE controller
;    SB -> static workspace
;    WinIDEDriveNum = physical drive number
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0
 [ BigDisc
;    R2 = sector disc address of next byte to transfer
 |
;    R2 = byte disc address of next byte to transfer
 ]
;    R3 = updated buffer/scatter list pointer
;    R4 = bytes not transferred
;    R5 undefined
;    All other registers preserved

        LDR     R0,WinIDEWriteCmds
        B       WinIDEReadWriteSecs             ; (R0-R4->R0,R2-R5,V)

;*********************************************************************

WinIDEOpReadSecs        ROUT
;
; Read sectors from an IDE drive.
; Called from WinLowLevelIDE.
;
; Entry:
;    R1 = b0-3: reason code
;            0= verify, 1= read, 2= write sectors
;            3= verify track, 4= format track,
;            5= Seek, 6= Restore, 7= Step in, 8= Step out,
;            15= specify
;         b4 = Alternate defect map
;         b5 = R3 -> scatter list
;         b6 = Ignore escape
;         b7 = No ready timeout
;         b8 = Background op
 [ BigDisc
;    R2 = sector disc address (no disc bits)
 |
;    R2 = byte disc address (no disc bits)
 ]
;    R3 -> buffer/scatter list
;    R4 = bytes to transfer
;    IDE -> IDE controller
;    SB -> static workspace
;    WinIDEDriveNum = physical drive number
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0
 [ BigDisc
;    R2 = sector disc address of next byte to transfer
 |
;    R2 = byte disc address of next byte to transfer
 ]
;    R3 = updated buffer/scatter list pointer
;    R4 = bytes not transferred
;    R5 undefined
;    All other registers preserved

        LDR     R0,WinIDEReadCmds
        ASSERT  . = WinIDEReadWriteSecs

;****** Fall through to WinIDEReadWriteSecs

;*********************************************************************

WinIDEReadWriteSecs     ROUT
;
; Read, write, verify or format sectors on an IDE drive.
; Branched to from WinIDEOpReadSecs, WinIDEOpWriteSecs, WinIDEOpVerify
; and WinIDEOpFormatTrk.
;
; Entry:
;    R0 = IDE command code for the op.
;         bits 8..15 = DMA code (0 if none)
;         bits 15..23 = 48-bit addressing code (0 if none)
;         bits 24..31 = 48-bit DMA code (0 if none)
;    R1 = b0-3: reason code
;            0= verify, 1= read, 2= write sectors
;            3= verify track, 4= format track,
;            5= Seek, 6= Restore, 7= Step in, 8= Step out,
;            15= specify
;         b4 = Alternate defect map
;         b5 = R3 -> scatter list
;         b6 = Ignore escape
;         b7 = No ready timeout
;         b8 = Background op
 [ BigDisc
;    R2 = sector disc address (no disc bits)
 |
;    R2 = byte disc address (no disc bits)
 ]
;    R3 -> buffer/scatter list
;    R4 = bytes to transfer
;    IDE -> IDE controller
;    SB -> static workspace
;    WinIDEDriveNum = physical drive number
;
; Exit:
;    VS => error
;          R0 = error pointer/code
;    VC => no error
;          R0 = 0
;    R2 = disc address of next byte to transfer
;    R3 = updated buffer/scatter list pointer
;    R4 = bytes not transferred
;    R5 undefined
;    All other registers preserved

        Push    "LR"

; Save the command code for the IRQ routine

        MOV     LR,#0
 [ BigDisc
        ASSERT  WinIDEBytesPerSector = 512
        ADD     R5,R2,R4,LSR #9                 ; R5 = end disc address
        CMP     R5,#&10000000
        BLO     %FT05
        ; If end address is >= &10000000 then switch to a 48-bit command
        MOV     LR,#WinIDECmdFlag_48bit
        MOVS    R0,R0,LSR #16
        BNE     %FT05
        ; no 48-bit form? Then can't do command.
        MOV     R0,#BadParmsErr
        SETV
        Pull    "PC"
05
 ]
 [ IDEDMA
        TST     R0,#&FF:SHL:8                   ; if the command has a DMA form
        BEQ     %FT08
        LDRB    R5,WinIDEDriveNum
        Push    "R1"
        sbaddr  R1,WinIDEDriveDMAFlags          ; and DMA is enabled for this drive
        LDRB    R5,[R1,R5]
        Pull    "R1"
        TEQ     R5,#0
        BEQ     %FT08
        ORR     LR,LR,#WinIDECmdFlag_DMA        ; then use the DMA form (with a
        STRB    R0,WinIDECommandCode_PIO        ; PIO fallback)
        MOV     R0,R0,LSR #8
08
 ]
        STRB    R0,WinIDECommandCode
        STRB    LR,WinIDECommandFlags

; Install code in RAM to move data into/out of the IDE controller

 [ :LNOT:NewTransferCode
 [ Debug21

        DLINE   "Installing transfer code"
 ]
        BL      WinIDEInstallTransferCode       ; (R1->R0)
 [ Debug21

        DLINE   "Installation complete"
 ]
 ]

; See if there is anything to do in foreground

        TSTS    R1,#DiscOp_Op_BackgroundOp_Flag ; NE => background

; if background op, make it foreground if no scatter list

        TSTNES  R1,#DiscOp_Op_ScatterList_Flag  ; NE => scatter list

        TOGPSR  Z_bit,R8                        ; make NE => no fg bit

; if background op with scatter list,check for foreground bit

        TEQEQS  R4,#0
        BEQ     %FT20

; something to do in foreground

        BL      WinIDEDoForeground              ; (R1-R4->R0,R2-R5,V)
        Pull    "PC",VS                         ; return if error

; fall through to do background stuff

 [ Debug21
        DLINE   "Falling thru to background op"
 ]

20
; Here if no foreground or foreground completed ok
; See if there is anything to do in background

        TSTS    R1,#DiscOp_Op_BackgroundOp_Flag ; NE => background
        TSTNES  R1,#DiscOp_Op_ScatterList_Flag  ; NE => scatter

; NE => background AND scatter list

        MOVEQ   R0,#0                           ; if nothing to do, return 0
        Pull    "PC",EQ

; Background transfer requested

        BL      WinIDEDoBackground              ; (R2-R3->R0,R3,R5,V)

        MOVVC   R0,#0                           ; if no err, return 0
        Pull    "PC"

;*********************************************************************

WinIDEReadCmds
        =       IDECmdReadSecs, IDECmdReadDMA, IDECmdReadSecsExt, IDECmdReadDMAExt
WinIDEWriteCmds
        =       IDECmdWriteSecs,IDECmdWriteDMA,IDECmdWriteSecsExt,IDECmdWriteDMAExt

        END
@


4.8
log
@Tidy up pass
ADFS.s:
  Redundant header files trimmed
  Get OsWords and OsBytes
  Switches rationalised
ADFS_SA.a
  Removed ARM810 support
Adfs00.s:
  Unused MEMC flag removed
Adfs05.s/Adfs12.s/Adfs13.s/Adfs14.s/Adfs15.s/Adfs19.s:
  Use defines instead of magic numbers
  Make use of FileCore exported bit fields
Adfs17.s/Adfs18.s/ConstIDE:
  {TRUE} and {FALSE} used with objasm
Adfs20.s
  Use AND of the opmask instead of BIC of all the flags except the opmask
Adfs50.s
  Unused MEMC flag no longer initialised
  Make use of FileCore exported bit fields
  Service call table reordered so the Ursula despatch doesn't incur a branch
  OsByte defines used
Consts:
  Removed those definitions now duplicating FileCore's exports
DebugOpts/Fixes:
  All options brought under one roof
ModHeader:
  Now uses VersionNum directly
Ver/*:
  Redundant switches deleted
  Removed used of 'Version' header


Version 3.45. Tagged as 'ADFS-3_45'
@
text
@d1098 1
a1098 1
	Push	"R0,LR"
d1100 1
a1100 1
	; check that the reason code/flags is zero
d1102 1
a1102 1
	TEQS	r0, #0
d1104 1
a1104 1
	BEQ	%FT10			; ok if zero
d1107 3
a1109 3
	ADRL	r0, BadParmsErrBlk	; return bad parameters error
	BL	copy_error
	STR	r0, [SP]
d1111 1
a1111 1
	Pull	"R0,PC"
d1114 1
a1114 1
	; check the drive number is valid
d1116 2
a1117 2
	CMPS	r1, #WinIDEMaxDrives
	BHS	%BT05			; if greater than or equal then exit with error
d1119 1
a1119 1
	; drive number checked
d1121 2
a1122 2
	ADRL	r3, WinIDEDeviceMappings
	LDRB	r2, [r3, r1]		; get drive number (also gives type)
d1127 2
a1128 2
	ADREQ	r3, WinIDEDeviceIds
	ADDEQ	r3, r3, r1, LSL #9	; point to device info
d1131 8
a1138 8
	TEQS	r2, #WinIDEATAPIDevice	; is it atapi
	MOVEQ	r1, #2
	BEQ	%FT90

	TEQS	r2, #WinIDENoDevice
	MOVEQ	r1, #0
	MOVEQ	r3, #0			; no device, so no info
	MOVNE	r1, #1			; ATA device
d1142 1
a1142 1
	Pull	"R0,PC"
d1303 2
a1304 2
	MOV	LR,#0
	STR	LR, WinIDESectorOffset
d1367 1
a1367 1
	ORR	R0,R0,#ExternalErrorBit ; for FileCore
d1376 1
a1376 1
;	BL	LockIDEController	; leave it locked
d1383 1
a1383 1
        B	SetVOnR0
d1421 1
a1421 1
	ASSERT	.=WinIDEAdjustStatus
d2124 1
a2124 1
	DLINE	"Falling thru to background op"
@


4.7
log
@Update to use some of the exported FileCore headers.
There are still a large number of local copies that should be visited, but this change at least allows it to assemble again FileCore-3_45.
Tungsten and IOMD variants assemble, but others untested.

Version 3.41. Tagged as 'ADFS-3_41'
@
text
@d1340 1
a1340 1
        AND     R0,R1,#OpMask
d1371 1
a1371 1
        TSTS    R1,#BackgroundOp
d1373 1
a1373 1
        TSTNES  R1,#ScatterBit
d1410 1
a1410 1
        TSTS    R1,#BackgroundOp
d1412 1
a1412 1
        TSTNES  R1,#ScatterBit
d1750 1
a1750 1
        TSTS    R1,#BackgroundOp                ; background ?
d1754 1
a1754 1
        TSTEQS  R1,#ScatterBit                  ; if not bg, scatter list ?
d2103 1
a2103 1
        TSTS    R1,#BackgroundOp                ; NE => background
d2107 1
a2107 1
        TSTNES  R1,#ScatterBit                  ; NE => scatter list
d2131 2
a2132 2
        TSTS    R1,#BackgroundOp                ; NE => background
        TSTNES  R1,#ScatterBit                  ; NE => scatter
@


4.6
log
@  Reintroduced support for IOMD machines
Detail:
  There was no "Ver" file for Machine=32, and the code for build switch
  settings appropriate for IOMD had not been kept up-to-date with various
  changes to the module which were made to support Tungsten. This version
  provides working IDE support for IOMD HAL builds, although there are
  still some issues with floppy support. Tungsten builds should be
  functionally identical.
Admin:
  Tested on a Risc PC. Joint development effort by Tom Walker and Ben Avison.

Version 3.37. Tagged as 'ADFS-3_37'
@
text
@d694 1
a694 1
        MOVEQ   R1,#WriteSecsOp                 ;           R1 = write sectors
d697 1
a697 1
        MOVEQ   R1,#ReadSecsOp                  ;          R1 = read sectors
d1388 1
a1388 1
        TEQS    R0,#SpecifyOp                   ; specify
@


4.5
log
@* DMA support completed.
* Selects PIO/DMA/Ultra DMA modes appropriate for each device.
* DMA support added to ADFS_IDEUserOp, but not yet ADFS_ATAPIOp.
* WinIDEMaxSectorsPerTransfer increased to 256.
* Floppy driver reattaches to DMA Manager if it's reinitialised.

Version 3.35. Tagged as 'ADFS-3_35'
@
text
@d215 5
a219 1
        ASSERT  WinIDEPtr = WinIDEHardware
d227 3
d231 1
d239 1
a239 1
        STRB    R14, WinIDEHWDevNo
d242 1
a242 1
        STRB    R14, WinIDEHWType
d246 1
a246 1
        STR     R14,WinIDECtrlPtr
d260 1
a260 1
        LDR     R2,WinIDECtrlPtr
d263 1
a263 1
        STRB    R0,[R2,#:INDEX:IDERegDigOutput]
d1121 1
a1121 1
	ADR	r3, WinIDEDeviceMappings
@


4.4
log
@* ADFS_DiscOp64 and ADFS_ATAPIOp added.
* New FileCore error passing scheme supported.
* PCI floppy support functional.
* 48-bit LBA support added for ADFS_IDEUserOp and accessing beyond the
  first 128GB of a drive - not thoroughly tested.
* IDE autodetection improved

Version 3.34. Tagged as 'ADFS-3_34'
@
text
@d553 1
a553 1
UserOpDMA SETL  {FALSE}
d760 2
a761 4
        ORRNE   R0,R0,#bit9             ; pass through "48-bit" flag
        ASSERT  WinIDECmdFlag_48bit = bit0
        MOV     LR,R0,LSR #9
        STRB    LR,WinIDECommandFlags
d765 3
a767 1
        ORRNE   R0,R0,#bit8
a768 2
        BL      WinIDECommandDisc       ; (R0->R0,V)
        BVS     %FT70
d775 3
d895 2
a896 2
; DMA command - we always get an interrupt on completion/error,
; so program up the DMA channel and wait for an interrupt.
d898 9
a906 2
        TST     R7,#bit24
        MOVNE   R0,#0
a907 2
        LDR     R1, WinIDEDMAHandle
        SWI     XDMA_QueueTransfer
d909 2
a910 1
        STR     R5,WinTickCount
d912 20
a931 2
41      BL      WinIDECheckIRQStatus
        BNE     %FT42
d936 1
d938 4
a941 1
        B       %FT70
d943 15
a957 5
42      LDRB    R0,IDERegStatus
        TSTS    R0,#IDEStatusErrorBits
        BEQ     %FT43
        BL      WinIDEDecodeDriveStatus
        B       %FT70
d1039 4
d1052 1
d1062 2
d1457 1
a1457 1
        Push    "R1,R3,R4"
d1467 1
a1467 1
        Pull    "R1,R3,R4"
d1693 1
a1693 1
        ORR     R0,R0,#IDECmdVerifyExt:SHL:8
d1944 1
a1944 4
        MOV     R0,#IDECmdWriteSecs
 [ BigDisc
        ORR     R0,R0,#IDECmdWriteSecsExt:SHL:8
 ]
d1991 1
a1991 4
        MOV     R0,#IDECmdReadSecs
 [ BigDisc
        ORR     R0,R0,#IDECmdReadSecsExt:SHL:8
 ]
d2006 3
a2008 3
 [ BigDisc
;         bits 8..15 = 48-bit addressing code (0 if none)
 ]
d2053 1
a2053 1
        MOVS    R0,R0,LSR #8
d2061 15
d2139 5
@


4.3
log
@32-bit conversion started, Tungsten hard disc support added.
Hard disc functional, but PIO mode only. Don't go near the floppy.

Version 3.33. Not tagged
@
text
@d552 3
d565 1
d572 1
d574 11
d646 3
a648 1
        ADD     R1,R0,#7                ; bytes we need in parameter block
d725 5
a729 1
        LDRB    R0,[R2,#0]              ; get precomp reg value
d732 1
a732 1
        LDRB    R0,[R2,#1]              ; get sector count reg value
d735 4
a738 1
        LDRB    R0,[R2,#2]              ; get sector number reg value
d741 1
a741 1
        LDRB    R0,[R2,#3]              ; get cylinder low reg value
d744 1
a744 1
        LDRB    R0,[R2,#4]              ; get cylinder high reg value
d747 10
a756 1
        LDRB    R0,[R2,#5]              ; get drive/head reg value
d759 5
a763 1
        LDRB    R0,[R2,#6]              ; get command reg value
d768 1
d772 5
d892 30
d937 5
d943 1
a943 1
        STRB    LR,[R2,#0]
d946 2
a947 1
        STRB    LR,[R2,#1]
d949 2
a950 2
        LDRB    LR,IDERegSecNumber
        STRB    LR,[R2,#2]
d952 2
a953 2
        LDRB    LR,IDERegCylLo
        STRB    LR,[R2,#3]
d955 3
a957 2
        LDRB    LR,IDERegCylHi
        STRB    LR,[R2,#4]
d960 1
a960 1
        STRB    LR,[R2,#5]
d963 10
d975 8
d1075 1
a1263 9
 [ IDEFixedLowSector
 |
; - Number of lowest-numbered sector on track

        LDRB    LR,[R5,#LowSector]
        AND     LR,LR,#&3F              ; mask to get start sector
        STRB    LR,WinIDEStartSec
 ]

d1312 3
a1314 1
	ORR	R0,R0,#1 :SHL: 30	; for FileCore
d1399 4
d1410 13
d1427 1
a1427 1
        ORR     R0,R0,#&C0000000        ; tell FileCore its a ptr
d1429 1
d1466 1
a1466 1
;          R0 undefined
d1584 1
a1584 1
        Pull    "R0,LR"
d1586 1
a1586 1
        STRB    R0,WinIDEHeads
d1626 1
a1626 1
;          R0 undefined
d1646 3
d1688 1
a1688 1
;          R0 undefined
d1738 1
a1738 1
;          R0 undefined
d1746 10
d1766 2
d1786 1
a1786 1
;          R0 undefined
d1803 2
d1824 1
a1824 1
;          R0 undefined
d1850 2
d1887 1
a1887 1
;          R0 undefined
d1891 1
a1891 1
;    R2 = bytr disc address of next byte to transfer
d1899 3
d1937 1
a1937 1
;          R0 undefined
d1949 3
d1966 3
d1994 1
a1994 1
;          R0 undefined
d2005 16
d2022 1
@


4.2
log
@Version Spin_merge taken
@
text
@d188 3
a190 1
        Push    "R0,R7-R8,LR"
d194 1
d198 1
d203 2
a204 1
        BL      WinReleaseIDEIRQs       ; (->R0,V)
d223 17
a239 2
        sbaddr  R0,WinIDEHardware
        STMIA   R0,{R2-R8}
d243 1
a243 1
        BL      WinClaimIDEIRQs         ; (->R0,V)
d245 1
a245 1
        Pull    "R0,R7-R8,PC",VS
d251 3
d263 1
a263 1

d265 2
a266 2
        Pull    "R0,R7-R8,LR"
        BICS    PC,LR,#V_bit
d298 5
a302 1
        Push    "R3-R5,IDE,LR"
d320 7
a326 1
        LDRB    LR,WinIDEIRQDevNo
d338 1
a338 1
        STRB    R5,WinIDEDriveNum       ; save logical drive (0/1)
d343 7
a349 1
        LDR     IDE,WinIDEPtr           ; set IDE -> IDE controller
d405 5
a409 1
        Pull    "R3-R5,IDE,PC"
d426 1
a426 1
        MOV     R0, #0                  ;>>>drive number
d444 5
a448 1
        Pull    "R3-R5,IDE,PC"
d470 1
a470 1
        MOV     R0, #0                  ;>>>drive number
d488 5
a492 1
        Pull    "R3-R5,IDE,PC",VC       ; return if no error
d516 6
a521 2
        Pull    "R3-R5,IDE,LR"
        ORRS    PC,LR,#V_bit
d543 6
a548 2
        Pull    "R3-R5,IDE,LR"
        ORRS    PC,LR,#V_bit
d561 3
a563 1
;         b25..b25 = transfer direction
d589 1
a589 1
	
d593 7
a599 1
        Push    "R1,R6,R7,IDE,LR"
d603 13
a615 1
        LDRB    LR,WinIDEIRQDevNo
d636 1
a636 1
        TEQP    PC,#SVC_mode
d645 9
a653 1
        LDR     IDE,WinIDEPtr                   ; IDE -> IDE controller
d665 3
a667 3
        AND     R7,R7,#WinIDEDirectionMask      ; direction bits
        TEQS    R7,#WinIDEDirectionWrite        ; write?
        LDREQ   R6,WinIDEWritePtr               ; if write, R6 -> write code
d669 2
a670 2
        TEQS    R7,#WinIDEDirectionRead         ; else read?
        LDREQ   R6,WinIDEReadPtr                ; if read, R6 -> read code
d684 1
d686 1
a686 1
	
d691 1
a691 1
	
d694 1
d728 2
a729 1

d731 1
a731 1
        BVS     %FT70                   ; branch if error
d735 1
a735 1
        MOV     R0,#1*2                 ; 1/2 us units
d759 3
a761 2
        BLNE    WinIDEDecodeDriveStatus ; if error, decode status...
        BNE     %FT70                   ; ...and branch
d763 1
d801 1
a801 1
	
d844 3
a846 2
        BLNE    WinIDEDecodeDriveStatus ; if error, decode status...
        BNE     %FT70                   ; ...and branch
d890 8
a897 2
        Pull    "R1,R6,R7,IDE,LR"
        BICS    PC,LR,#V_bit            ; restore IRQ state and return
d910 81
a990 2
        Pull    "R1,R6,R7,IDE,LR"
        ORRS    PC,LR,#V_bit
a1005 1
;       Preserves flags
d1010 1
a1010 1
        MOVEQS  PC, LR                          ; No then exit
d1017 3
a1019 5
        Pull    "R2,PC",EQ,^                    ; No then exit
                 
        MOV     R2, PC                          ; Save CPU mode
        ORR     LR, R2, #SVC_mode
        TEQP    LR, #0                          ; Switch to SVC mode
d1030 1
a1030 1
        TEQP    R2, #0                          ; Restore CPU mode
d1037 1
a1037 1
        Pull    "R2,PC",,^
d1058 1
a1058 1
;    R2 = sector disc address (sector/track aligned), top 3 bits = drive (0/1)
d1060 1
a1060 1
;    R2 = byte disc address (sector/track aligned), top 3 bits = drive (0/1)
d1078 5
a1082 1
        Push    "IDE,LR"
d1086 1
a1086 1
; Ensure power is on, 
d1103 13
a1115 1
        LDR     IDE,WinIDEPtr                   ; IDE -> IDE controller
d1132 1
a1132 1
        LDRB    LR,WinIDEIRQDevNo
d1231 5
a1235 1
        Pull    "IDE,LR"
d1269 5
a1273 1
        Pull    "IDE,LR"
d1286 3
d1290 1
d1296 3
d1300 1
d1362 4
d1414 1
a1414 1
	
d1434 1
a1434 1
        TEQS    R0,#0                           ; initialised yet?
d1436 1
a1436 2
        Pull    "LR",EQ                         ; ...and return
        BICEQS  PC,LR,#V_bit
d1446 1
a1446 2
        Pull    "LR",EQ                         ; ...and return
        BICEQS  PC,LR,#V_bit
d1593 2
a1594 1
        ORRNES  PC,LR,#V_bit
d1703 1
a1703 1
	
d1870 1
d1872 1
a1872 1
	
d1877 1
a1877 1
	
d1879 1
@


4.2.2.1
log
@This version of ADFS implements support for Ursula discs and stuff.

New SWI ADFS_IDEDeviceInfo

ADFS_IDEUserOp, ADFS_ControllerType modified for more drives.

Low level driver modified to use twin controllers.

Auto-detection of devices.  ProbeIDEDevices implemented to find them.

Mapping of devices made flexible to cope with any arrangement of devices.

Code to use ID information instead of boot block numbers not yet active,
needs to be brought up to date with autodetect code, and needs to do the
LBA side of things properly.

*configure IDETimeout added.

This uses CMOS byte 189, which ADFS previously used for approx winnie sizes,
but this is obsolete use.

To do:


Need to remove *configure IDEDiscs!

Need to support fast PIO modes and selection of appropriate mode.
@
text
@a189 2
 [ :LNOT: TwinIDEHardware

a240 2
 ]

a490 104
 [ UseIdentify :LOR: AutoDetectIDE

;*********************************************************************

; this routine identifies a given drive

; Entry

;   R0 = physical drive number (0/1/2/3)
;   R3 = buffer ptr

; exit

;   R0 = command status (0 or a disc error no.)

;   if other error, V set, R0 -> error block

IdentifyDrive ROUT
	Push	"R1-R5,LR"

; have to construct a parameter block; use the stack

	MOV	R1, #0
	MOV	r2, #0

	Push	"R1-R2"

	MOV	r1, #&a0
	ORR	r1, r1, r0, LSL #4
	STRB	r1, [sp, #5]
	MOV	r1, #IDECmdIdentify
	STRB	r1, [sp, #6]

	TSTS	r0, #2

	MOVEQ	r0, #1<<24		; read
	MOVNE	r0, #(1<<24)+(1<<26)	; read
	MOV	r2, sp
	MOV	r4, #512
	MOV	r5, #0

	BL	DoSwiIDEUserOp

 [ DebugA
	DREG	r4, "r4: "
 ]

	TEQS	r4, #0
	MOVNE	r0, #-1
	ADD	sp, sp, #8

	Pull	"R1-R5,PC"

;*********************************************************************

; this routine identifies a given drive, assuming it's ATAPI

; Entry

;   R0 = physical drive number (0/1)
;   R3 = buffer ptr

; exit

;   R0 = command status (0 or a disc error no.)

;   if other error, V set, R0 -> error block

IdentifyPacketDrive ROUT
	Push	"R1-R5,LR"

; have to construct a parameter block; use the stack

	MOV	R1, #0
	MOV	r2, #0

	Push	"R1-R2"

	MOV	r1, #&a0
	ORR	r1, r1, r0, LSL #4
	STRB	r1, [sp, #5]
	MOV	r1, #IDECmdIdentifyPacket
	STRB	r1, [sp, #6]

	MOV	r0, #1<<24	; read
	MOV	r2, sp
	MOV	r4, #512
	MOV	r5, #0

	BL	DoSwiIDEUserOp

 [ DebugA
	DREG	r4, "r4: "
 ]

	TEQS	r4, #0
	MOVNE	r0, #-1

	ADD	sp, sp, #8

	Pull	"R1-R5,PC"

 ]

a506 7

 [ TwinIDEHardware
; 	  b26 = port number
;		0 - primary port
;		1 - secondary port
 ]

d528 1
a528 1

d566 1
a566 9
 [ TwinIDEHardware
	; now need to select the appropriate physical device
	TSTS	R7, #1<<26
	LDREQ	IDE, WinIDEPrimaryPtr		; 0 -> primary
	LDRNE	IDE, WinIDESecondaryPtr		; 1 -> secondary
	STR	IDE, WinIDEPtr			; now we have selected the active controller.  be happy
 |
        LDR     IDE, WinIDEPtr                  ; IDE -> IDE controller
 ]
d598 1
a598 1

d603 1
a603 1

d709 1
a709 1

a814 72

 [ AutoDetectIDE :LAND: TwinIDEHardware

; DoSwiIDEDeviceInfo

; entry:

; r0 = flags/reason code.  any non-zero value will result in BadParmsErr

; R1 = physical device (0-3)

; on exit

; R0 = preserved

; R1 = type of device:
;       0 - no device
;       1 - non-packet
;       2 - packet device

; R2 = ADFS drive number of device, if applicable.  otherwise undefined

; R3 = pointer to device id info for this device, or zero

DoSwiIDEDeviceInfo ROUT
	Push	"R0,LR"

	; check that the reason code/flags is zero

	TEQS	r0, #0

	BEQ	%FT10			; ok if zero

05
	ADRL	r0, BadParmsErrBlk	; return bad parameters error
	BL	copy_error
	STR	r0, [SP]

	Pull	"R0,LR"
	ORRS	PC, LR, #V_bit

10
	; check the drive number is valid

	CMPS	r1, #WinIDEMaxDrives
	BHS	%BT05			; if greater than or equal then exit with error

	; drive number checked

	ADR	r3, WinIDEDeviceMappings
	LDRB	r2, [r3, r1]		; get drive number (also gives type)

	ADR	r3, WinIDEDeviceIds
	ADD	r3, r3, r1, LSL #9	; point to device info

	TEQS	r2, #WinIDEATAPIDevice	; is it atapi
	MOVEQ	r1, #2
	BEQ	%FT90

	TEQS	r2, #WinIDENoDevice
	MOVEQ	r1, #0
	MOVEQ	r3, #0			; no device, so no info
	MOVNE	r1, #1			; ATA device

90

	Pull	"R0,LR"
	BICS	PC, LR, #V_bit

 ]

;*********************************************************************
d841 1
a841 1

d907 1
a907 1
; Ensure power is on,
a921 37
 [ TwinIDEHardware
	; have to map drive to device
	MOV	r0, r2, LSR #(32-3)
	sbaddr	lr, WinIDEDriveMappings
 [ Debug21
	Push	"R0"
	DLINE	"drive mappings: "
	LDRB	r0, [lr, #0]
	DREG	r0, "0: "
	LDRB	r0, [lr, #1]
	DREG	r0, "1: "
	LDRB	r0, [lr, #2]
	DREG	r0, "2: "
	LDRB	r0, [lr, #3]
	DREG	r0, "3: "
	Pull    "R0"
 ]
 [ Debug21
	DREG	r0, "logical device: "
 ]
	LDRB	r0, [lr, r0]
; now have physical drive in r0
	STRB	r0, WinIDEPhysDriveNum	; store the physical drive number

 [ Debug21
	DREG	r0, "Physical device: "
 ]
	TSTS	r0, #2
	LDREQ	IDE, WinIDEPrimaryPtr
	LDRNE	IDE, WinIDESecondaryPtr

 [ Debug21
	DREG	IDE, "IDE set to: "
 ]
	STR	IDE, WinIDEPtr

 |
a924 2
 ]

a942 4
 [ TwinIDEHardware
	LDRNEB	LR,WinIDEIRQDevNo2
	TEQNES	LR, #0
 ]
a995 3
 [ TwinIDEHardware
	LDRB	r0, WinIDEPhysDriveNum		; physical drive to init
 ]
d1203 1
a1203 1

d1493 1
a1493 1

d1661 1
a1661 1

d1666 1
a1666 1

a1715 372

 [ AutoDetectIDE

AutoDetect1
	= "Finding ATA/ATAPI devices...",0

AutoDetectATA
	= "ATA   ",0

AutoDetectATAPI
	= "ATAPI ",0

ALIGN

; ====================================================================

; ProbeIDEDevices

; the job of this routine is to locate all the IDE devices, and
; fill in the mappings of drives to devices

ProbeIDEDevices ROUT
	Push	"R0-R3,R5-R11, LR"

	BL	ReadCMOSTimeout		; (->R2) get the timeout

	MOV	R0, #100
	MUL	R9, R2, R0		; timeout now in cs

	MOV	lr, #WinIDENoDevice
	ADR	r0, WinIDEDeviceMappings

	STRB	lr, [r0, #0]
	STRB	lr, [r0, #1]

 [ WinIDEMaxDrives=4
	STRB	lr, [r0, #2]
	STRB	lr, [r0, #3]
 ]

	ADRL	r0, WinIDEDriveMappings

	STRB	lr, [r0, #0]
	STRB	lr, [r0, #1]

 [ WinIDEMaxDrives=4
	STRB	lr, [r0, #2]
	STRB	lr, [r0, #3]
 ]

; print a message, saying what we're doing
	ADR	r0, AutoDetect1
	SWI	XOS_Write0
	SWI	XOS_NewLine

; the method used is to wait for a set time, until a drive becomes DRDY
; and not BSY

	MOV	R4, #0  ; number of ATA drives found
	MOV	R6, #4  ; logical device
	MOV	R5, #0	; current physical device

	LDR	IDE, WinIDEPtr	; set up ptr to IDE controller

; we have to wait until the IDE controller becomes ready...

	SWI	XOS_ReadMonotonicTime	; ->R0

	BVS	%FT90			; if an error occurs, assume no drives

	MOV	R10, R0			; store the initial time

	MOV	r0, #4
	STR	R0, IDERegDigOutput	; reset the drive

	MOV	r0, #5*2
	BL	DoMicroDelay

	MOV	r0, #0
	STR	r0, IDERegDigOutput

	MOV	r0, #2048*2
	BL	DoMicroDelay

10
	; we select drive r5

	LDRB	R0, IDERegAltStatus	; get contents of alternate status register

	; if BSY, or DRQ are set then round we go again

	TSTS	R0, #IDEStatusBSY+IDEStatusDRQ
	BNE	%FT70

	; here BSY=0, DRQ=0, so select drive.

	MOV	R0, r5, LSL #4		; select drive.  other bits obsolete, so ignore 'em
	ORR	R0, R0, #IDEDrvHeadMagicBits

	STRB	R0, IDERegDrvHead	; and store value

	; now wait for a little while

	MOV	R0, #1*2
	BL	DoMicroDelay		; wait a suitable length of time

	; now get the status again

	LDRB	R0, IDERegAltStatus

	; want BSY=0, DRQ=0

	TSTS	R0, #IDEStatusBSY+IDEStatusDRQ
	BNE	%FT70

	; check for DRDY

	TSTS	r0, #IDEStatusDRDY

	BEQ	%FT40	; ATA drive not ready, or might be ATAPI?

	MOV	lr, r5, LSL #3

; now do an Identify on the device

	ADR	r3, WinIDEDeviceIds
	ASSERT	SzWinIDEId=512
	ADD	r3, r3, r5, LSL #9
	MOV	r0, r5

	BL	IdentifyDrive

	TEQS	r0, #0

	BEQ	%FT20

	ADRL	r0, NoDriveString
	SWI	XOS_Write0

	B	%FT35

20

	; now sp->id information for this drive

	ADR	r0, WinIDEDeviceIds
	ASSERT	SzWinIDEId=512
	ADD	r0, r0, r5, LSL #9
	MOV	r1, r5
	MOV	r2, r6

	BL	PrintDeviceInfo

; now we have to set up the mappings
	ADRL	lr, WinIDEDeviceMappings	; set mapping from device to drive
	STRB	r6, [lr, r5]

	SUB	r6, r6, #4

	ADRL	lr, WinIDEDriveMappings		; set mapping from drive to device
	STRB	r5, [lr, r6]

	ADD	r6, r6, #5
	ADD	r4, r4, #1

  	SWI	XOS_NewLine

35

	ADD	R5, R5, #1
	CMPS	R5, #WinIDEMaxDrives-1
	BHI	%FT90

	B	%BT10

40

	ADR	r3, WinIDEDeviceIds
	ASSERT	SzWinIDEId=512
	ADD	r3, r3, r5, LSL #9
	MOV	r0, r5

	BL	IdentifyPacketDrive

 [ DebugA
	DREG	r0, "returned: "
 ]

	CMPS	r0, #-1
	BNE	%FT60

	ADRL	r0, NoDriveString
	SWI	XOS_Write0

	B	%FT65

60
	TEQS	r0, #0
	BNE	%FT70		; error, don't give up yet!

	ADR	r0, WinIDEDeviceIds
	ASSERT	SzWinIDEId=512
	ADD	r0, r0, r5, LSL #9
	MOV	r1, r5
	MVN	r2, #0

	BL	PrintDeviceInfo

  	SWI	XOS_NewLine

	ADR	lr, WinIDEDeviceMappings
	MOV	r0, #WinIDEATAPIDevice
	STR	r0, [lr, r5]

65
	ADD	R5, R5, #1
	CMPS	R5, #WinIDEMaxDrives-1

	BHI	%FT90

	B	%BT10


70
	SWI	XOS_ReadMonotonicTime	; get the current time
	BVS	%FT90

	SUB	R0, R0, R10

	CMPS	R0, R9			; check for timeout elapsed
	BLE	%FT80			; back around we go

	ADRL	r0, NoDriveString
	SWI	XOS_Write0

	B	%BT65

80

	CMPS	R5, #WinIDEMaxDrives-1
	BLS	%BT10

90

	Pull	"R0-R3,R5-R11, PC",,^

; ========================================================

; this routine outputs a string from an ATA/ATAPI device
; identify.  each of the strings in the identify device
; data is held in an unusual form, where alternate characters
; are swapped; strings are padded with spaces to fill the
; field.

; for instance, the string "FUJITSU" would be represented
; as "UFIJST U", plus any padding with further spaces

; it is assumed that the name is a multiple of 2 chars in length,
; and is at least 2 characters.  all the padding spaces are
; printed in the message.

; entry

; R0 -> string
; R1  = number of characters


PrintATAName	ROUT
	Push	"R0-R3, LR"

	MOV	R2, R0
10
	LDRB	R0, [R2, #1]
	SWI	XOS_WriteC
	BVS	%FT90
	LDRB	R0, [R2], #2	; get next thing and advance the pointer
	SWI	XOS_WriteC
	BVS	%FT90

; now check if we've nothing left to do
	SUBS	R1, R1, #2
	BGT	%BT10		; go round again if we have more to do

	CLRV
90
	Pull	"R0-R3, PC"


; ========================================================

; PrintDeviceInfo

; this rountine prints information about a given device; the

; entry:

; r0 -> ATA/ATAPI information structure
; r1  = device no
; r2  = ADFS drive no, or -1 if not an adfs drive (ie ATAPI)

PrintDeviceInfo	ROUT
	Push	"R0-R4, LR"

	SUB	sp, sp, #8	; size of buffer for output values

	MOV	r4, r0
	MOV	r3, r2
	MOV	r0, r1

	MOV	r1, sp
	MOV	r2, #8

	CMPS	r3, #-1
	BNE	%FT10

	ADR	r0, ATAPIString
	SWI	XOS_Write0
	BVS	%FT90

	B	%FT20

10
	MOV	r0, r3
	MOV	r1, sp
	MOV	r2, #8
	SWI	XOS_ConvertCardinal1
	SWIVC	XOS_Write0
	BLVC	%FT99		; pad with spaces

	BVS	%FT90
	ADR	r0, ATAString
	SWI	XOS_Write0
	BVS	%FT90

20
; finally, we print the device name

	ADD	r0, r4, #WinIDEIdModelNo
	MOV	r1, #40		; length of the string
	BL	PrintATAName

90
	ADD	sp, sp, #8
	Pull	"R0-R4, PC",,^

; subroutine to pad with spaces
99
	Push	"LR"
;	ADD	R2, R2, #1

	MOV	r0, #" "
01
	SWI	XOS_WriteC
	BVS	%FT02
	SUBS	R2, R2, #1
	BNE	%BT01

02
	Pull	"PC",,^

ATAPIString
	DCB	"-       ATAPI   ",0

ATAString
	DCB	"ATA     ",0

NoDriveString
	DCB	"-       -",10,13,0

	ALIGN

 ]
@


4.1
log
@Initial revision
@
text
@d348 10
d362 3
d376 13
d412 16
d437 3
d815 42
d858 8
d904 10
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a347 10
 [ IDEPower
;If drive is powered down, return a 'not spinning' indication.
;
;
        LDR     R0, Portable_Flags
        TST     R0, #PortableControl_IDEEnable
        MOVEQ   R2, #0                          ; power off, so not spinning
        BEQ     %FT15
;we know the drive is powered, so no need to call WinIDEcontrol to power it up
 ]
a351 3
 [ IDEPower
15
 ]
a362 13
 [ IDEPower
        Push    "R1"
        MOV     R0, #1
        BL      WinIDEcontrol
        Pull    "R1"

        Push    "R5"
        MOV     R0, #0                  ;>>>drive number
        MOV     R5,#WinIDETimeoutSpinup
        BL      WinIDEWaitReady
        Pull    "R5"
 ]

a385 16
 [ IDEPower
        LDR     R0, Portable_Flags
        TST     R0, #PortableControl_IDEEnable
        CMPEQ   R2, #0
        BEQ     %FT35
        Push    "R1"
        MOV     R0, #1
        BL      WinIDEcontrol
        Pull    "R1"

        Push    "R5"
        MOV     R0, #0                  ;>>>drive number
        MOV     R5,#WinIDETimeoutSpinup
        BL      WinIDEWaitReady
        Pull    "R5"
 ]
a394 3
 [ IDEPower
35
 ]
a769 42
 [ IDEPower
WinIDEcontrol   ROUT
;
; Enable/Disable IDE hardware for power saving on the portable
;
; Entry:
;    R0 = New state, 0= disable, !0= enable
;
; Exit:
;    R1 = Portable_Flags
;
; Modifies:
;       R0
;       Preserves flags
;       Updates Portable_Flags word

        LDR     R1, Portable_Flags
        TST     R1, #Portable_Present           ; Portable present?
        MOVEQS  PC, LR                          ; No then exit

        Push    "R2,LR"
        TEQ     R0, #0                          ; Disabling IDE?
        MOVNE   R0, #PortableControl_IDEEnable  ; No then set enable bit
        AND     LR, R1, #PortableControl_IDEEnable ; Get IDE enable bit
        TEQ     LR, R0                          ; Any change
        Pull    "R2,PC",EQ,^                    ; No then exit
                 
        MOV     R2, PC                          ; Save CPU mode
        ORR     LR, R2, #SVC_mode
        TEQP    LR, #0                          ; Switch to SVC mode
        NOP
        Push    "LR"                            ; Save SVC_LR

        MOV     R1, #:NOT:PortableControl_IDEEnable ; IDE enable bit mask
        SWI     XPortable_Control               ; En/Disable IDE H/W
        ORRVC   R1, R1, #Portable_Present       ; No error -> portable
        MOVVS   R1, #PortableControl_FDCEnable  ; Error -> not portable, FDC enabled
        ORRVS   R1, R1, #PortableControl_IDEEnable ; Error -> not portable, IDE enabled

        Pull    "LR"                            ; Restore SVC_LR
        TEQP    R2, #0                          ; Restore CPU mode
        NOP
a770 8
 [ Debug10p
        DREG    R1,"New portable flags:"
 ]
        STR     R1, Portable_Flags              ; Save enable state
        Pull    "R2,PC",,^

;*********************************************************************
 ]
a808 10

 [ IDEPower
;
; Ensure power is on, 
;
        Push    "R0, R1"
        MOV     R0, #1
        BL      WinIDEcontrol           ; Enable IDE H/W
        Pull    "R0, R1"
 ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a347 10
 [ IDEPower
;If drive is powered down, return a 'not spinning' indication.
;
;
        LDR     R0, Portable_Flags
        TST     R0, #PortableControl_IDEEnable
        MOVEQ   R2, #0                          ; power off, so not spinning
        BEQ     %FT15
;we know the drive is powered, so no need to call WinIDEcontrol to power it up
 ]
a351 3
 [ IDEPower
15
 ]
a362 13
 [ IDEPower
        Push    "R1"
        MOV     R0, #1
        BL      WinIDEcontrol
        Pull    "R1"

        Push    "R5"
        MOV     R0, #0                  ;>>>drive number
        MOV     R5,#WinIDETimeoutSpinup
        BL      WinIDEWaitReady
        Pull    "R5"
 ]

a385 16
 [ IDEPower
        LDR     R0, Portable_Flags
        TST     R0, #PortableControl_IDEEnable
        CMPEQ   R2, #0
        BEQ     %FT35
        Push    "R1"
        MOV     R0, #1
        BL      WinIDEcontrol
        Pull    "R1"

        Push    "R5"
        MOV     R0, #0                  ;>>>drive number
        MOV     R5,#WinIDETimeoutSpinup
        BL      WinIDEWaitReady
        Pull    "R5"
 ]
a394 3
 [ IDEPower
35
 ]
a769 42
 [ IDEPower
WinIDEcontrol   ROUT
;
; Enable/Disable IDE hardware for power saving on the portable
;
; Entry:
;    R0 = New state, 0= disable, !0= enable
;
; Exit:
;    R1 = Portable_Flags
;
; Modifies:
;       R0
;       Preserves flags
;       Updates Portable_Flags word

        LDR     R1, Portable_Flags
        TST     R1, #Portable_Present           ; Portable present?
        MOVEQS  PC, LR                          ; No then exit

        Push    "R2,LR"
        TEQ     R0, #0                          ; Disabling IDE?
        MOVNE   R0, #PortableControl_IDEEnable  ; No then set enable bit
        AND     LR, R1, #PortableControl_IDEEnable ; Get IDE enable bit
        TEQ     LR, R0                          ; Any change
        Pull    "R2,PC",EQ,^                    ; No then exit
                 
        MOV     R2, PC                          ; Save CPU mode
        ORR     LR, R2, #SVC_mode
        TEQP    LR, #0                          ; Switch to SVC mode
        NOP
        Push    "LR"                            ; Save SVC_LR

        MOV     R1, #:NOT:PortableControl_IDEEnable ; IDE enable bit mask
        SWI     XPortable_Control               ; En/Disable IDE H/W
        ORRVC   R1, R1, #Portable_Present       ; No error -> portable
        MOVVS   R1, #PortableControl_FDCEnable  ; Error -> not portable, FDC enabled
        ORRVS   R1, R1, #PortableControl_IDEEnable ; Error -> not portable, IDE enabled

        Pull    "LR"                            ; Restore SVC_LR
        TEQP    R2, #0                          ; Restore CPU mode
        NOP
a770 8
 [ Debug10p
        DREG    R1,"New portable flags:"
 ]
        STR     R1, Portable_Flags              ; Save enable state
        Pull    "R2,PC",,^

;*********************************************************************
 ]
a808 10

 [ IDEPower
;
; Ensure power is on, 
;
        Push    "R0, R1"
        MOV     R0, #1
        BL      WinIDEcontrol           ; Enable IDE H/W
        Pull    "R0, R1"
 ]
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a347 10
 [ IDEPower
;If drive is powered down, return a 'not spinning' indication.
;
;
        LDR     R0, Portable_Flags
        TST     R0, #PortableControl_IDEEnable
        MOVEQ   R2, #0                          ; power off, so not spinning
        BEQ     %FT15
;we know the drive is powered, so no need to call WinIDEcontrol to power it up
 ]
a351 3
 [ IDEPower
15
 ]
a362 13
 [ IDEPower
        Push    "R1"
        MOV     R0, #1
        BL      WinIDEcontrol
        Pull    "R1"

        Push    "R5"
        MOV     R0, #0                  ;>>>drive number
        MOV     R5,#WinIDETimeoutSpinup
        BL      WinIDEWaitReady
        Pull    "R5"
 ]

a385 16
 [ IDEPower
        LDR     R0, Portable_Flags
        TST     R0, #PortableControl_IDEEnable
        CMPEQ   R2, #0
        BEQ     %FT35
        Push    "R1"
        MOV     R0, #1
        BL      WinIDEcontrol
        Pull    "R1"

        Push    "R5"
        MOV     R0, #0                  ;>>>drive number
        MOV     R5,#WinIDETimeoutSpinup
        BL      WinIDEWaitReady
        Pull    "R5"
 ]
a394 3
 [ IDEPower
35
 ]
a769 42
 [ IDEPower
WinIDEcontrol   ROUT
;
; Enable/Disable IDE hardware for power saving on the portable
;
; Entry:
;    R0 = New state, 0= disable, !0= enable
;
; Exit:
;    R1 = Portable_Flags
;
; Modifies:
;       R0
;       Preserves flags
;       Updates Portable_Flags word

        LDR     R1, Portable_Flags
        TST     R1, #Portable_Present           ; Portable present?
        MOVEQS  PC, LR                          ; No then exit

        Push    "R2,LR"
        TEQ     R0, #0                          ; Disabling IDE?
        MOVNE   R0, #PortableControl_IDEEnable  ; No then set enable bit
        AND     LR, R1, #PortableControl_IDEEnable ; Get IDE enable bit
        TEQ     LR, R0                          ; Any change
        Pull    "R2,PC",EQ,^                    ; No then exit
                 
        MOV     R2, PC                          ; Save CPU mode
        ORR     LR, R2, #SVC_mode
        TEQP    LR, #0                          ; Switch to SVC mode
        NOP
        Push    "LR"                            ; Save SVC_LR

        MOV     R1, #:NOT:PortableControl_IDEEnable ; IDE enable bit mask
        SWI     XPortable_Control               ; En/Disable IDE H/W
        ORRVC   R1, R1, #Portable_Present       ; No error -> portable
        MOVVS   R1, #PortableControl_FDCEnable  ; Error -> not portable, FDC enabled
        ORRVS   R1, R1, #PortableControl_IDEEnable ; Error -> not portable, IDE enabled

        Pull    "LR"                            ; Restore SVC_LR
        TEQP    R2, #0                          ; Restore CPU mode
        NOP
a770 8
 [ Debug10p
        DREG    R1,"New portable flags:"
 ]
        STR     R1, Portable_Flags              ; Save enable state
        Pull    "R2,PC",,^

;*********************************************************************
 ]
a808 10

 [ IDEPower
;
; Ensure power is on, 
;
        Push    "R0, R1"
        MOV     R0, #1
        BL      WinIDEcontrol           ; Enable IDE H/W
        Pull    "R0, R1"
 ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

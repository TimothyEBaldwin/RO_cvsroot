head	4.12;
access;
symbols
	ADFS-3_54:4.12
	ADFS-3_53:4.12
	ADFS-3_52:4.12
	ADFS-3_51:4.12
	ADFS-3_50:4.12
	ADFS-3_49:4.12
	ADFS-3_48:4.12
	ADFS-3_47:4.12
	ADFS-3_46:4.11
	ADFS-3_45:4.8
	ADFS-3_44:4.7
	ADFS-3_43:4.7
	ADFS-3_42:4.7
	ADFS-3_41:4.7
	ADFS-3_40:4.6
	ADFS-3_39:4.6
	ADFS-3_38:4.6
	ADFS-3_37:4.6
	ADFS-3_36:4.5
	RO_5_07:4.5
	ADFS-3_35:4.5
	ADFS-3_34:4.5
	ADFS-3_33:4.3
	dellis_autobuild_BaseSW:4.2
	ADFS-3_32:4.2
	Ursula_merge:4.2
	Ursula_RiscPC_merge:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	sbrodie_UrsulaRiscPC_ADFS-3_30:4.2
	Ursula_RiscPC_bp:4.2
	nturton_ADFS-3_29:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	sproven_ADFS-3_31:4.2
	nicke_ADFS_3_26:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	sproven_330:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.12
date	2012.10.23.19.59.54;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	5hNsJpgA09dD2ypw;

4.11
date	2012.10.21.17.00.19;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	UTqmwqEEM1TP6hpw;

4.10
date	2012.10.21.16.27.50;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	ReyUVZewswdRVgpw;

4.9
date	2012.10.21.11.42.57;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	yOiiX7g8HT2Zlfpw;

4.8
date	2012.10.21.11.38.10;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	L8DklCrHdjSrkfpw;

4.7
date	2011.10.14.07.38.46;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	tK3tjaAo92QGZhDv;

4.6
date	2010.12.06.14.14.47;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2003.01.17.19.33.28;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2002.09.18.15.03.30;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.11.17.12.25.56;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	97.01.06.11.31.46;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.21;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.21;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.35.24;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.29.05;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.24.36;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Allow background ops again
Adfs20.s:
  Earlier tidy up 3.44->3.45 had erroneously cleared the background transfer bit, so they were being rejected leading to various things hanging while they never completed.
Adfs18.s:
  Safety NOP after mode change before banked register use for consistency with other mode changes in ADFS.
Consts.s/ModHeader.s:
  Documented CMOS bits, use ADFSSWI_Base from Hdr:SWIs, assert local definition matches FileCore.

Floppy *and* harddiscs tested this time.

Version 3.47. Tagged as 'ADFS-3_47'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;>Adfs18
        SUBT    82C710/'765 FDC FileCore Interface
;-----------------------------------------------------------------------;
; (C) Copyright 1990 Acorn Computers Limited,                           ;
; Fulbourn Road, Cambridge CB1 4JN, England.                            ;
; Telephone 0223 214411.                                                ;
;                                                                       ;
; All rights reserved.  The software code in this listing is proprietary;
; to Acorn Computers Ltd., and is covered by copyright protection.      ;
; The unauthorized copying, adaptation, distribution, use or display    ;
; is prohibited without prior consent.                                  ;
;-----------------------------------------------------------------------;
; Revision History:                                                     ;
; No.    Date    By     Reason                                          ;
;-----------------------------------------------------------------------;
; 01  11 Dec 90  lrust  Conception                                      ;
; 02  08 Mar 91  lrust  Alpha version                                   ;
; 03  15 Mar 91  lrust  RiscOS 2.09 release                             ;
;                       Added FlpMediaCheck assembler switch            ;
; 04  22 Mar 91  lrust  Drive Status turns off drive if drive wasn't    ;
;                       ready when started.                             ;
; 05  26 Mar 91  lrust  Drive status delays turning off empty drives to ;
;                       speed next poll changed request.                ;
; 06  28 May 91  lrust  Fixed bug in drive status processing            ;
; 07  09 Aug 91  jroach Fix the data transfer FIQ routines to not       ;
;                       suffer chronic latency problems and do the      ;
;                       scatter lists properly                          ;
; 08  17 Sep 91  lrust  Sector not found errors on side 1 are retried   ;
;                       with sector ID head number set to 0 for DFS and ;
;                       some protected discs (ZARCH,LOGO etc.)          ;
; 09  05 Feb 92  lrust  ReadID terminated by timeout returns FlpErrNoIDs;
;                       This allows 'PacMania' and other discs to be    ;
;                       mounted since the FDC hangs!! when attemping a  ;
;                       ReadID @@ 500Kb on these media?? The new error is;
;                       non-fatal to allow further densities to be tried;
; 10  27 Feb 96  MJS    StrongARM changes for modifying code            ;
;_______________________________________________________________________;
;
Adfs18Ed        * 10            ; Edition number

;-----------------------------------------------------------------------;
; This file provides the support routines for the Disk Control Block    ;
; (DCB) messaging system.  The following routines are included:         ;
;                                                                       ;
;       FlpMessage      - Send message to current DCB                   ;
;       FlpHandlerData  - Handle messages for data transfer type DCB's  ;
;       FlpHandlerReadID - Handle messages for ReadID command           ;
;       FlpHandlerSeek  - Handle messages for seek/restore DCB's        ;
;       FlpHandlerDrv   - Handle messages for sense drive status DCB    ;
;       FlpGetDrvStatus - Gets drive status and handles disk change     ;
;       FlpHandlerImm   - Handle messages for immediate type DCB's      ;
;       FlpAddDCB       - Add a DCB to the active queue                 ;
;       FlpDqDCB        - Terminate a DCB and de-queue it               ;
;_______________________________________________________________________;


; DCB structure
;--------------
        ^ 0
FlpDCBbuffer    a4 4            ; Data buffer pointer
FlpDCBlength    a4 4            ; Data buffer size, bit31= read, bit30= scatter list
FlpDCBsb        a4 4            ; R12 for post routine
FlpDCBpost      a4 4            ; -> post routine (called on command completion)
FlpDCBstatus    a4 4            ; -1= pending, 0= no error else error code
FlpDCBpending   * -1            ; DCB pending
FlpDCBesc       # 1             ; Escape inhibit flag
FlpDCBtimeOut   # 1             ; Command timeout in centiseconds, 0= none
FlpDCBretries   # 1             ; Retries, 0= none
FlpDCBselect    # 1             ; Clock: 00=500K, 01=300K, 10=250K, 11=1000K
FlpDCBtrack     # 1             ; Track required
FlpDCBcmdLen    # 1             ; Command block length: 1..10 bytes, bit7= immediate
FlpDCBcdb       # 2             ; Command block
                                ; Offset 0= command byte
                                ; Offset 1= drive select, b7= implied seek
FlpDCBparam     a4 8            ; Offset 2..9 variable, offset9= &FF for verify
FlpDCBresults   a4 8            ; Result block

; flags in FlpDCBlength
FlpDCBread        * bit31
FlpDCBscatter     * bit30
FlpDCBflags       * bit31+bit30

;
; The following locations are reserved for driver use only
;
FlpDCBlink      a4 4            ; -> next DCB
FlpDCBhandler   a4 4            ; -> message handler for this command
FlpDCBphase     # 1             ; Current command phase
FlpDCBbgnd      # 1             ; non-zero if backgrounding transfer op
                # 2             ; Spare, align to word boundary
FlpDCBtxbytes   a4 4            ; location which accumulates number of bytes transfered (for use by client)
FlpDCBtxgobytes a4 4            ; initial txbytes in each step (for use by driver)
 ASSERT  {VAR} = FlpDCBsize     ; Total size 64 bytes


; Message types
;--------------
;
 ASSERT FlpEventIRQ = 1                 ; IRQ event == IRQ message
FlpMsgIP        * 2                     ; Drive ready index pulse
FlpMsgSeekDone  * 3                     ; Seek complete
FlpMsgError     * 4                     ; Command error
FlpMsgESC       * 5                     ; Escape message
FlpMsgStart     * 6                     ; Start command
FlpMsgResetOK   * 7                     ; FDC reset complete

; Driver error codes
;
        MACRO
$label  DrvErr  $num
        ASSERT  $num > 0
        ASSERT  $num <= MaxDiscErr
 [ NewErrors
$label  * $num
 |
$label  * DiscErrorBit + $num :SHL: 24
 ]
        MEND

; Prioritized controller errors
;
 [ NewErrors
FlpDiscError    *      DiscErr
 |
FlpDiscError    *      DiscErrorBit
 ]

; Fatal errors
;
FlpErrFDC       DrvErr &01              ; FDC H/W error
FlpErrTimeOut   DrvErr &02              ; Command timed out
FlpErrTrk0Fault DrvErr &03              ; Track 0 not found

; Critical errors
;
FlpErrSeekFault DrvErr &10              ; Seek fault
FlpErrDskChng   DrvErr &11              ; Disk changed

; Recoverable errors
;
FlpErrSoft      DrvErr &20              ; Non specific FDC error, see ST1/2
FlpErrLost      DrvErr &21              ; Data over/underrun
FlpErrCRC       DrvErr &22              ; Data CRC error
FlpErrNotFound  DrvErr &23              ; Sector or ID not found
FlpErrNoAM      DrvErr &24              ; Missing address mark
FlpErrNoIDs     DrvErr &25              ; Can't read sector ID's


; DCB command phases
;
FlpPhaseIdle    * 0                     ; DCB inactive
FlpPhaseDrv     * 1                     ; DCB awaiting drive ready
FlpPhaseSeek    * 2                     ; DCB awaiting seek done
FlpPhaseIRQ     * 3                     ; DCB awaiting IRQ
FlpPhaseReset   * 4                     ; DCB awaiting reset complete
FlpPhaseIP      * 5                     ; DCB awaiting index pulse
FlpPhaseIRQip   * 6                     ; DCB awaiting IRQ or index
FlpPhaseDone    * 7                     ; DCB complete
FlpPhaseRetry   * 8                     ; DCB reseeking during retry


;-----------------------------------------------------------------------;
; DCB Message system                                                    ;
;       Messages are sent to the current head of the DCB queue          ;
;                                                                       ;
; Input:                                                                ;
;       R0 = Message                                                    ;
;       R1 = Parameter                                                  ;
;       R12 -> Local storage                                            ;
;                                                                       ;
; Output:                                                               ;
;       None                                                            ;
;                                                                       ;
; Modifies:                                                             ;
;       None                                                            ;
;_______________________________________________________________________;
;
FlpMessage      ROUT
        Push    "R2,LR"
        LDR     R2, FlpDCBqueue         ; Get start of DCB queue
        TEQS    R2, #0                  ; Any DCB's?
        MOVNE   LR, PC                  ; Yes then set return address
        LDRNE   PC, [R2, #FlpDCBhandler] ;   and call handler (R0-R2->)
        Pull    "R2,PC"                 ; Return

 [ Debug10v
SlowDownFactor * 10
 ]

 [ FloppyPCI
FlpDMAEnable
FlpDMADisable
FlpDMAStart
FlpDMASync
        MOV     PC, R14

FlpDMACompleted
        Push    "R14"
  [ Debug10d
        DLINE   "FlpDMACompleted (V ",cc
        BVS     %FT01
        DLINE   "clear)"
        B       %FT02
01
        DLINE   "set)"
02
  ]
        MOV     R14, #-1
        STR     R14, FlpDMATag
        LDRVC   R14, [r11, #FlpDCBtxgobytes]
        STRVC   R14, FlpDMACount
        Pull    "PC"
 |

;=======================================================================;
;                                                                       ;
;                                                                       ;
;                                                                       ;
;                                                                       ;
;                    F I Q   r o u t i n e s                            ;
;                                                                       ;
;                                                                       ;
;                                                                       ;
;                                                                       ;
;=======================================================================;

; The routines have a special copy routine to patch them up when
; they're copied into place.
;
; The 0 word terminating the code will have txcount's address patched into
; it.
; The word before the terminator will have FlpDCBbuffer put there.

;-----------------------------------------------------------------------;
; FlpVerifyFIQ                                                          ;
;       Verify data FIQ routine                                         ;
;                                                                       ;
; Input:                                                                ;
;  R9=temp reg                                                          ;
;  R11=bytes to TC                                                      ;
;  R12=bytes left                                                       ;
;  R13=DMA (bytes left>1) +TC(bytes left=1)                             ;
;                                                                       ;
; Output:                                                               ;
;       R12 -= 1                                                        ;
;                                                                       ;
; Modifies:                                                             ;
;       R8, R14, preserves flags                                        ;
;_______________________________________________________________________;
;
FlpVerifyFIQ    ROUT
 [ Debug10v
        STR     lr, %FT11
        MOV     lr, #SlowDownFactor
10
        STR     lr, %FT12
        SUBS    lr, lr, #1
        BNE     %BT10
        B       %FT20
11
        DCD     10
12
        DCD     10
20
        LDR     lr, %BT11
 ]
      [ FlpUseVerify
        MOV     R12, #0                 ; We should never get here
        ADD     R9, R13, #FlpDACK_TC_Offset
        LDRB    R9, [R9]                ; Try a terminal count? Can't hurt!
      |
        LDRB    R9, [R13]
        SUB     R12, R12, #1
        SUBS    R11, R11, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset
      ]
        retfiq
        DCD     1                       ; Where FlpDCBbuffer will be put
        DCD     0                       ; End of FIQ routine
        DCD     0                       ; End of instructions needing 1 x sector size
        DCD     0                       ; End of instructions needing 2 x sector size

;-----------------------------------------------------------------------;
; FlpReadNonScatter                                                     ;
;         Read data FIQ routine                                         ;
;                                                                       ;
; Input:                                                                ;
 [ FlpUseFIFO
; Input:
;   R8 = destination
;   R9 = temp
;   R10 = -
;   R11 = bytes to TC
;   R12 = bytes to end of transfer
;   R13 = DACK or DACK_TC
 |
;  R9=temp reg                                                          ;
;  R10=bytes left-1                                                     ;
;  R13=DMA (bytes left>1) +TC(bytes left=1)                             ;
;                                                                       ;
; Output:                                                               ;
;       R12 += 4                                                        ;
 ]
;                                                                       ;
; Modifies:                                                             ;
;       R8, R14, preserves flags                                        ;
;_______________________________________________________________________;
;
FlpReadNonScatter       ROUT
 [ Debug10v
        STR     lr, %FT11
        MOV     lr, #SlowDownFactor
10
        STR     lr, %FT12
        SUBS    lr, lr, #1
        BNE     %BT10
        B       %FT20
11
        DCD     10
12
        DCD     10
20
        LDR     lr, %BT11
 ]
 [ FlpUseFIFO
        LDRB    R9, [R13]
        SUBS    R11, R11, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset
        SUBS    R12, R12, #1
        STRGEB  R9, [R8], #1
        retfiq
 |
        LDRB    R9, [R13]
        STRB    R9, [R8], #1
        SUBS    R10, R10, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset
        retfiq
 ]
        DCD     1               ; Where FlpDCBbuffer will be put
        DCD     0
        DCD     0
        DCD     0

;-----------------------------------------------------------------------;
; FlpReadFIQ_FG                                                         ;
;       Read data FIQ routine                                           ;
;                                                                       ;
; Input:                                                                ;
 [ FlpUseFIFO
;       R8 = RAM destination                                            ;
;       R9 = temp                                                       ;
;       R10 = bytes left to scatter entry's end                         ;
;       R11 = bytes left to switch to DACK_TC (ie bytes left-1)         ;
;       R12 = bytes left to end of transfer to RAM                      ;
;       R13 = DACK or DACK_TC                                           ;
;                                                                       ;
; Output:                                                               ;
;       counts decremented and R13 might be DACK_TC                     ;
 |
;       CPU in FIQ mode                                                 ;
;       R8 ->  data destination                                         ;
;       R9 =   temporary data register                                  ;
;       R10 =  amount remaining in this scatter entry                   ;
;       R11 -> next scatter list entry                                  ;
;       R12=bytes left in transfer-1                                    ;
;       R13=DMA(bytes left>1) +TC(bytes left=1)                         ;
;                                                                       ;
; Output:                                                               ;
;       More to go:                                                     ;
;       R8 advanced to next destination                                 ;
;       R9 trashed                                                      ;
;       R10-- or length of new scatter entry as appropriate             ;
;       R11 unchanged or advanced to next scatter entry                 ;
;       R12--                                                           ;
;       R13 unchanged                                                   ;
;       Transfer was last                                               ;
;       R8++                                                            ;
;       R9 trashed                                                      ;
;       R10 = 0                                                         ;
;       R11 unchanged                                                   ;
;       R12 = 0                                                         ;
;       R13 unchanged                                                   ;
;       transfer stopped by asserting TC                                ;
 ]
;_______________________________________________________________________;
;
FlpReadFIQ_FG   ROUT
 [ Debug10v
        STR     lr, %FT11
        MOV     lr, #SlowDownFactor
10
        STR     lr, %FT12
        SUBS    lr, lr, #1
        BNE     %BT10
        B       %FT20
11
        DCD     10
12
        DCD     10
20
        LDR     lr, %BT11
 ]
 [ FlpUseFIFO
        LDRB    R9, [R13]
        SUBS    R11, R11, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset
        SUBS    R12, R12, #1
        STRGEB  R9, [R8], #1
        SUBS    R10, R10, #1
        retfiq  GT
        CMP     R12, #0
        LDRGT   R8, ReadNonScatterPtr
        ADDGT   R8, R8, #8
        STRGT   R8, ReadNonScatterPtr
        LDMGTIA R8, {R8,R10}
        retfiq
ReadNonScatterPtr
 |
        LDRB    R9, [R13]
        STRB    R9, [R8], #1
        SUBS    R12, R12, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset
        SUBS    R10, R10, #1
        retfiq  GT
        CMP     R12, #0
        LDMGEIA R11!, {R8,R10}
        retfiq
 ]
        DCD     1       ; Where FlpDCBbuffer will be put
        DCD     0       ; End of FIQ routine
        DCD     0       ; End of instructions needing SectorSize plugged in
        DCD     0       ; End of instructions needing 2 x sector size

;-----------------------------------------------------------------------;
; FlpReadFIQ_BG                                                         ;
;       Read data FIQ routine                                           ;
;                                                                       ;
;  well, actually it's for the '665 controller                          ;
; Input:                                                                ;
;       FIQ mode (FIQ pin asserted)                                     ;
;       R8 -> data destination                                          ;
;       R9 unused                                                       ;
;       R10 number of transfers to sector end                           ;
;       R11 number of transfers before switching to TC space            ;
;               Will be EOTrack or EOSector as appropriate              ;
;       R12 -> previous sector's scatter list entry                     ;
;               (=1 to indicate no previous sector)                     ;
;       R13 = FlpDACK or FlpDACK_TC as determined by R11 on             ;
;               previous FIQs                                           ;
;       FlpReadThisRover -> this sector's scatter list entry            ;
;                                                                       ;
; Output:                                                               ;
;       The byte gets transfered                                        ;
;       The above get advanced by one byte's worth                      ;
;_______________________________________________________________________;
;
FlpReadFIQ_BG   ROUT
 [ Debug10v
        STR     lr, %FT11
        MOV     lr, #SlowDownFactor
10
        STR     lr, %FT12
        SUBS    lr, lr, #1
        BNE     %BT10
        B       %FT20
11
        DCD     10
12
        DCD     10
20
        LDR     lr, %BT11
 ]

        ; Well, actually the '665
        ; The problem here is that late termination doesn't go on the '665, ho hum!
        ; So, how does it go:
        ; The idea is we've got big time gaps between sectors, so we use that to do
        ; the processing under FIQ. During a sector we do as little processing as possible.
        ; This involves counting down to TC which will only occur at the sector's end, and
        ; counting down to the sector's end itself.
        ; Once the sectors end has been reached we do this:
        ; * advance the previous sector (1)
        ; * advance txcount (1)
        ; * Find out where the next sector should be transfered to
        ; * Find out whether there's a sector after that waiting
        ; (1) These only happen if there was a previous sector and only happen for the
        ; previous sector and not this sector as just because we've picked a byte off the controller
        ; doesn't mean we haven't overrun or got a CRC error.

        ; Transfer the byte
        LDRB    R9, [R13]
        STRB    R9, [R8], #1

        ; Check for TC assertion next byte
        SUBS    R11, R11, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset

        ; Check for sector end
        SUBS    R10, R10, #1
        retfiq  GT

        ; Sector end reached

        ; Advance the prev sector (if there is a prev sector)
        ; Also advance txcount
        TEQ     R12, #1
        LDMNEIA R12, {R9,R10}
FlpReadFIQ_1xSectorSize1
        ADDNE   R9, R9, #&3FC0          ; 1xSectorSize
FlpReadFIQ_1xSectorSize2
        SUBNE   R10, R10, #&3FC0        ; 1xSectorSize
        STMNEIA R12, {R9,R10}
        LDRNE   R10, FlpReadFIQ_txcount
        LDRNE   R9, [R10]
FlpReadFIQ_1xSectorSize3
        ADDNE   R9, R9, #&3FC0          ; 1xSectorSize
        STRNE   R9, [R10]
        LDR     R12, FlpReadThisRover   ; This is next sector's prev thingy
                                        ; move on 1 sector's worth of scatter list

        ; Check if this was the TC transfer
        CMP     r11, #-1
        retfiq  EQ

        ; We haven't TCed the byte just transfered, hence there *is* a next sector

        ; Get this sector's scatter entry's address
        ; Need to determine:
        ; * next sector's start address
        ; * Whether there's more after the next sector

        ; Prepare standard goop for the next sector
FlpReadFIQ_1xSectorSize4
        MOV     R10, #&3FC0             ; 1xSectorSize

        LDR     R9, [R12, #4]
FlpReadFIQ_2xSectorSize1
        CMP     R9, #&3FC0              ; 2xSectorSize
        BLO     %FT50

        ; This sector's scatter entry has >= 2xSectorSize in it
        ; Hence: r8 is correct

        ; If This sector's scatter entry is > 2xSectorSize then
        ; there's definitely a sector after the next one and we
        ; can go for the next sector without any worries
        retfiq  HI

        ; This sector's entry has = 2xSectorSize hence we must check the next
        ; scatter entry for being present
        LDR     R9, [R12, #8]
 [ FixTBSAddrs
        CMN     R9, #ScatterListNegThresh
        ADDCS   R9, R12, R9
        LDRCS   R9, [R9, #8+4]
        LDRCC   R9, [R12, #8+4]
 |
        TEQ     R9, #0
        ADDMI   R9, R12, R9
        LDRMI   R9, [R9, #8+4]
        LDRPL   R9, [R12, #8+4]
 ]
20
        TEQ     R9, #0
        SUBEQ   R11, R10, #1            ; Terminate on last byte of next sector
        retfiq

50
        ; This scatter entry has 1xSectorSize in it, hence r8 is wrong
        ADD     R10, R12, #8
        LDR     R8, [R10]
 [ FixTBSAddrs
        CMN     R8, #ScatterListNegThresh
        LDRCS   R8, [R10, R8]!
 |
        TEQ     R8, #0
        LDRMI   R8, [R10, R8]!
 ]
        STR     R10, FlpReadThisRover
        LDR     R9, [R10, #4]
FlpReadFIQ_1xSectorSize5
        CMP     R9, #&3FC0              ; 1xSectorSize
FlpReadFIQ_1xSectorSize7
        MOVHI   R10, #&3FC0             ; 1xSectorSize
        retfiq  HI
        LDR     R9, [R10, #8]!
 [ FixTBSAddrs
        CMN     R9, #ScatterListNegThresh
        ADDCS   R10, R10, R9
 |
        TEQ     R9, #0
        ADDMI   R10, R10, R9
 ]
        LDR     R9, [R10, #4]
FlpReadFIQ_1xSectorSize6
        MOV     R10, #&3FC0             ; 1xSectorSize
        B       %BT20

FlpReadThisRover DCD 1  ; Where FlpDCBbuffer will be put
FlpReadFIQ_txcount
        DCD     0       ; End of FIQ routine
  [ {PC}-FlpReadFIQ_BG + FiqVector > FlpFiqStackBase
        ! 0,"Fiq overflow by ":CC::STR:(({PC}-FlpReadFIQ_BG + FiqVector) - FlpFiqStackBase)
  ]
        ASSERT  {PC}-FlpReadFIQ_BG + FiqVector <= FlpFiqStackBase

; List of locations needing 1xSectorSize plugged into instruction
        DCD     FlpReadFIQ_1xSectorSize1 - FlpReadFIQ_BG + FiqVector
        DCD     FlpReadFIQ_1xSectorSize2 - FlpReadFIQ_BG + FiqVector
        DCD     FlpReadFIQ_1xSectorSize3 - FlpReadFIQ_BG + FiqVector
        DCD     FlpReadFIQ_1xSectorSize4 - FlpReadFIQ_BG + FiqVector
        DCD     FlpReadFIQ_1xSectorSize5 - FlpReadFIQ_BG + FiqVector
        DCD     FlpReadFIQ_1xSectorSize6 - FlpReadFIQ_BG + FiqVector
        DCD     FlpReadFIQ_1xSectorSize7 - FlpReadFIQ_BG + FiqVector
        DCD     0

; List of locations needing 2xSectorSize plugged into instruction
        DCD     FlpReadFIQ_2xSectorSize1 - FlpReadFIQ_BG + FiqVector
        DCD     0       ; End of instructions needing 2 x sector size

; --------------------------------------------------------------;
; FlpWriteNonScatter                                            ;
;       Write data (non scatter) FIQ routine                    ;
;                                                               ;
 [ FlpUseFIFO
; Input:                                                        ;
;       R8 = RAM source                                         ;
;       R9 = byte for transfer                                  ;
;       R10 = -                                                 ;
;       R11 = bytes to TC                                       ;
;       R12 = bytes to end of transfer                          ;
;       R13 = DACK or DACK_TC                                   ;
; Output:                                                       ;
;       byte transfered                                         ;
;       counts decremented                                      ;
;       R13 may be switched to DACK_TC                          ;
 |
;                                                               ;
; In                                                            ;
; R8=RAM source                                                 ;
; R9=byte for transfer                                          ;
; R10=bytes left-1                                              ;
; R13=DMA(bytes left>1) +TC(bytes left=1)                       ;
 ]
;---------------------------------------------------------------;

FlpWriteNonScatter ROUT
 [ Debug10v
        STR     lr, %FT11
        MOV     lr, #SlowDownFactor
10
        STR     lr, %FT12
        SUBS    lr, lr, #1
        BNE     %BT10
        B       %FT20
11
        DCD     10
12
        DCD     10
20
        LDR     lr, %BT11
 ]
 [ FlpUseFIFO
        STRB    R9, [R13]
      [ FlpFlushPBI
        LDRB    R9, [R13, #4]
      ]
        SUBS    R11, R11, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset
        SUBS    R12, R12, #1
        LDRGTB  R9, [R8], #1
        MOVLE   R9, #0
        retfiq
 |
        STRB    R9, [R13]
      [ FlpFlushPBI
        LDRB    R9, [R13, #4]
      ]
        SUBS    R10, R10, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset
        LDRGE   R9, [R8], #1
        retfiq
 ]
        DCD     1       ; Where FlpDCBbuffer will be put
        DCD     0
        DCD     0
        DCD     0

;-----------------------------------------------------------------------;
; FlpWriteFIQ_FG                                                        ;
;       Write data FIQ routine                                          ;
;                                                                       ;
 [ FlpUseFIFO
;       R8 = RAM source                                                 ;
;       R9 = byte to transfer                                           ;
;       R10 = bytes left to scatter entry's end                         ;
;       R11 = bytes left to switch to DACK_TC (ie bytes left-1)         ;
;       R12 = bytes left to end of transfer to RAM                      ;
;       R13 = DACK or DACK_TC                                           ;
;                                                                       ;
; Output:                                                               ;
;       counts decremented and R13 might be DACK_TC                     ;
 |
; Input:                                                                ;
;       CPU in FIQ mode                                                 ;
;       R8 ->  (source address for R9)+1                                ;
;       R9 =   data ready to transfer to controller                     ;
;       R10 =  amount remaining in this scatter entry                   ;
;       R11 -> next scatter list entry                                  ;
;       R12=bytes left-1                                                ;
;       R13=DMA (bytes left>1) +TC(bytes left=1)                        ;
;                                                                       ;
; Output:                                                               ;
;       More to go:                                                     ;
;       R8 advanced to next destination                                 ;
;       R9 data ready for next transfer to controller                   ;
;       R10-- or length of new scatter entry as appropriate             ;
;       R11 unchanged or advanced to next scatter entry                 ;
;       R12--                                                           ;
;       R13 unchanged                                                   ;
;       Transfer was last                                               ;
;       R8++                                                            ;
;       R9 trashed                                                      ;
;       R10 = 0                                                         ;
;       R11 unchanged                                                   ;
;       R12 = 0                                                         ;
;       R13 unchanged                                                   ;
;       transfer stopped by asserting TC                                ;
 ]
;_______________________________________________________________________;
;
FlpWriteFIQ_FG  ROUT
 [ Debug10v
        STR     lr, %FT11
        MOV     lr, #SlowDownFactor
10
        STR     lr, %FT12
        SUBS    lr, lr, #1
        BNE     %BT10
        B       %FT20
11
        DCD     10
12
        DCD     10
20
        LDR     lr, %BT11
 ]
 [ FlpUseFIFO
        STRB    R9, [R13]
      [ FlpFlushPBI
        LDRB    R9, [R13, #4]
      ]
        SUBS    R11, R11, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset
        SUBS    R12, R12, #1
        LDRGTB  R9, [R8], #1
        MOVLE   R9, #0
        SUBS    R10, R10, #1
        retfiq  GT
        CMP     R12, #1
        LDRGT   R8, WriteNonScatterPtr
        ADDGT   R8, R8, #8
        STRGT   R8, WriteNonScatterPtr
        LDMGTIA R8, {R8,R10}
        retfiq
WriteNonScatterPtr
 |
        STRB    R9, [R13]
      [ FlpFlushPBI
        LDRB    R9, [R13, #4]
      ]
        SUBS    R12, R12, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset
        SUBS    R10, R10, #1
        LDRGTB  R9, [R8], #1
        retfiq  GT
        CMP     R12, #0
        LDMGEIA R11!, {R8, R10}
        LDRGEB  R9, [R8], #1
        retfiq
 ]
        DCD     1       ; Where FlpDCBbuffer will be put
        DCD     0       ; End of FIQ routine
        DCD     0       ; End of instructions needing 1 x sector size
        DCD     0       ; End of instructions needing 2 x sector size

;-----------------------------------------------------------------------;
; FlpWriteFIQ_BG                                                        ;
;       Write data FIQ routine for backgrounding                        ;
;                                                                       ;
;  well, actually it's for the '665 controller                          ;
; Input:                                                                ;
;       FIQ mode (FIQ pin asserted)                                     ;
;       R8 -> data destination                                          ;
;       R9 byte ready to transfer                                       ;
;       R10 number of transfers to sector end                           ;
;       R11 number of transfers before switching to TC space            ;
;               Will be EOTrack or EOSector as appropriate              ;
;       R12 -> previous sector's scatter list entry                     ;
;               (=1 to indicate no previous sector)                     ;
;       R13 = FlpDACK or FlpDACK_TC as determined by R11 on             ;
;               previous FIQs                                           ;
;       FlpWriteThisRover -> this sector's scatter list entry           ;
;                                                                       ;
; Output:                                                               ;
;       The byte gets transfered                                        ;
;       The above get advanced by one byte's worth                      ;
;_______________________________________________________________________;
;
FlpWriteFIQ_BG   ROUT

        ; Well, actually the '665
        ; The problem here is that late termination doesn't go on the '665, ho hum!
        ; So, how does it go:
        ; The idea is we've got big time gaps between sectors, so we use that to do
        ; the processing under FIQ. During a sector we do as little processing as possible.
        ; This involves counting down to TC which will only occur at the sector's end, and
        ; counting down to the sector's end itself.
        ; Once the sectors end has been reached we do this:
        ; * advance the previous sector (1)
        ; * advance txcount (1)
        ; * Find out where the next sector should be transfered to
        ; * Find out whether there's a sector after that waiting
        ; (1) These only happen if there was a previous sector and only happen for the
        ; previous sector and not this sector as just because we've picked a byte off the controller
        ; doesn't mean we haven't overrun or got a CRC error.

        ; Transfer the byte
        STRB    R9, [R13]
      [ FlpFlushPBI
        LDRB    R9, [R13, #4]
      ]

        ; Check for TC assertion next byte
        SUBS    R11, R11, #1
        ADDEQ   R13, R13, #FlpDACK_TC_Offset

        ; Check for sector end
        SUBS    R10, R10, #1
        LDRGTB  R9, [R8], #1
        retfiq  GT

        ; Sector end reached

        ; Advance the prev sector (if there is a prev sector)
        ; Also advance txcount
        TEQ     R12, #1
        LDMNEIA R12, {R9,R10}
FlpWriteFIQ_1xSectorSize1
        ADDNE   R9, R9, #&3FC0          ; 1xSectorSize
FlpWriteFIQ_1xSectorSize2
        SUBNE   R10, R10, #&3FC0        ; 1xSectorSize
        STMNEIA R12, {R9,R10}
        LDRNE   R10, FlpWriteFIQ_txcount
        LDRNE   R9, [R10]
FlpWriteFIQ_1xSectorSize3
        ADDNE   R9, R9, #&3FC0          ; 1xSectorSize
        STRNE   R9, [R10]
        LDR     R12, FlpWriteThisRover  ; Advance the scatter by 1 sector
                                        ; ie load the next sector's prev thingy

        ; Check if this was the TC transfer
        CMP     r11, #-1
        retfiq  EQ

        ; We haven't TCed the byte just transfered, hence there *is* a next sector

        ; Get this sector's scatter entry's address
        ; Need to determine:
        ; * next sector's start address
        ; * Whether there's more after the next sector

        ; Prepare standard goop for the next sector
FlpWriteFIQ_1xSectorSize4
        MOV     R10, #&3FC0             ; 1xSectorSize

        LDR     R9, [R12, #4]
FlpWriteFIQ_2xSectorSize1
        CMP     R9, #&3FC0              ; 2xSectorSize
        BLO     %FT50

        ; This sector's scatter entry has >= 2xSectorSize in it
        ; Hence: r8 is correct

        ; If This sector's scatter entry is > 2xSectorSize then
        ; there's definitely a sector after the next one and we
        ; can go for the next sector without any worries
        LDRHIB  r9, [r8], #1
        retfiq  HI

        ; This sector's entry has = 2xSectorSize hence we must check the next
        ; scatter entry for being present
        LDR     R9, [R12, #8]
 [ FixTBSAddrs
        CMN     R9, #ScatterListNegThresh
        ADDCS   R9, R12, R9
        LDRCS   R9, [R9, #8+4]
        LDRCC   R9, [R12, #8+4]
 |
        TEQ     R9, #0
        ADDMI   R9, R12, R9
        LDRMI   R9, [R9, #8+4]
        LDRPL   R9, [R12, #8+4]
 ]
20
        TEQ     R9, #0
        SUBEQ   R11, R10, #1            ; Terminate on last byte of next sector
        LDRB    R9, [R8], #1
        retfiq

50
        ; This scatter entry has 1xSectorSize in it, hence r8 is wrong
        ADD     R10, R12, #8
        LDR     R8, [R10]
 [ FixTBSAddrs
        CMN     R8, #ScatterListNegThresh
        LDRCS   R8, [R10, R8]!
 |
        TEQ     R8, #0
        LDRMI   R8, [R10, R8]!
 ]
        STR     R10, FlpWriteThisRover
        LDR     R9, [R10, #4]
FlpWriteFIQ_1xSectorSize5
        CMP     R9, #&3FC0              ; 1xSectorSize
        LDRHIB  R9, [R8], #1
FlpWriteFIQ_1xSectorSize7
        MOVHI   R10, #&3FC0             ; 1xSectorSize
        retfiq  HI
        LDR     R9, [R10, #8]!
 [ FixTBSAddrs
        CMN     R9, #ScatterListNegThresh
        ADDCS   R10, R10, R9
 |
        TEQ     R9, #0
        ADDMI   R10, R10, R9
 ]
        LDR     R9, [R10, #4]
FlpWriteFIQ_1xSectorSize6
        MOV     R10, #&3FC0             ; 1xSectorSize
        B       %BT20

FlpWriteThisRover DCD 1 ; Where FlpDCBbuffer will be put
FlpWriteFIQ_txcount
        DCD     0       ; End of FIQ routine
  [ {PC}-FlpWriteFIQ_BG + FiqVector > FlpFiqStackBase
        ! 0,"Fiq overflow by ":CC::STR:(({PC}-FlpWriteFIQ_BG + FiqVector) - FlpFiqStackBase)
  ]
        ASSERT  {PC}-FlpWriteFIQ_BG + FiqVector <= FlpFiqStackBase

; List of locations needing 1xSectorSize plugged into instruction
        DCD     FlpWriteFIQ_1xSectorSize1 - FlpWriteFIQ_BG + FiqVector
        DCD     FlpWriteFIQ_1xSectorSize2 - FlpWriteFIQ_BG + FiqVector
        DCD     FlpWriteFIQ_1xSectorSize3 - FlpWriteFIQ_BG + FiqVector
        DCD     FlpWriteFIQ_1xSectorSize4 - FlpWriteFIQ_BG + FiqVector
        DCD     FlpWriteFIQ_1xSectorSize5 - FlpWriteFIQ_BG + FiqVector
        DCD     FlpWriteFIQ_1xSectorSize6 - FlpWriteFIQ_BG + FiqVector
        DCD     FlpWriteFIQ_1xSectorSize7 - FlpWriteFIQ_BG + FiqVector
        DCD     0

; List of locations needing 2xSectorSize plugged into instruction
        DCD     FlpWriteFIQ_2xSectorSize1 - FlpWriteFIQ_BG + FiqVector
        DCD     0       ; End of instructions needing 2 x sector size


;=======================================================================;
;                                                                       ;
;                                                                       ;
;                                                                       ;
;                                                                       ;
;            E n d   o f   F I Q   r o u t i n e s                      ;
;                                                                       ;
;                                                                       ;
;                                                                       ;
;                                                                       ;
;=======================================================================;

 ] ; :LNOT:FloppyPCI


;-----------------------------------------------------------------------;
; FlpHandlerData                                                        ;
;       Message handler for data transfer type FDC commands             ;
;                                                                       ;
; Input:                                                                ;
;       R0 = Message                                                    ;
;       R1 = Parameter                                                  ;
;       R12 = SB                                                        ;
;                                                                       ;
; Output:                                                               ;
;       None                                                            ;
;                                                                       ;
; Modifies:                                                             ;
;       None, preserves flags                                           ;
;_______________________________________________________________________;
;
FlpHandlerData  ROUT
 [ Debug10v :LOR: Debug10
        BREG    r0,"E",cc
        DLINE   " ",cc
 ]
 [ Debug10e
        Push    "R0,LR"
        SWI     XOS_ReadMonotonicTime
        DREG    R0,,cc,Integer
        Pull    "R0,LR"
        DREG    R0," ",,Byte
 ]
        CMPS    R0, #FlpEventIRQ        ; FDC interrupt?
        BEQ     %FT60                   ; Yes then jump
        CMPS    R0, #FlpMsgIP           ; Drive ready index pulse?
        BEQ     %FT20                   ; Yes then jump
        CMPS    R0, #FlpMsgSeekDone     ; Seek complete?
        BEQ     FlpHandlerData_SeekDone ; Yes then jump
        CMPS    R0, #FlpMsgStart        ; Initialise?
        BEQ     %FT10                   ; Yes then jump
        CMPS    R0, #FlpMsgResetOK      ; Reset complete?
        BEQ     %FT90                   ; Yes then jump
        CMPS    R0, #FlpMsgError        ; Fatal error?
        BEQ     %FT05                   ; Yes then jump
        CMPS    R0, #FlpMsgESC          ; Escape?
        MOVNE   PC, LR                  ; No then return

; Handle escape message

        Push    "LR"
        LDRB    LR, [R2, #FlpDCBesc]    ; Get escape enable flag
        TEQS    LR, #0                  ; Escapes enabled?
        Pull    "LR"
        MOVNE   PC, LR                  ; No then exit

; Handle error message, R1= error code
05
        Push    "R0,LR"
        LDRB    LR, [R2, #FlpDCBphase]
        TEQS    LR, #FlpPhaseIdle       ; Idle phase?
        BEQ     %FT06

        BL      Flp765reset             ; No then reset FDC

 [ FloppyPCI
        BL      FlpDMATerminate
 |
    [ HAL
        Push    "R0-R3,R9,R12"
        sbaddr  R1, HAL_FIQDisableAll_routine
        MOV     LR, PC
        LDMIA   R1,{R9,PC}
        Pull    "R0-R3,R9,R12"
      [ FloppyPodule
        LDR     LR, FlpDACK_TC
        SUB     LR, LR, #&400000
        MOV     R0, #0
        STRB    R0, [LR, #8]
      ]
    |
        MOV     LR, #IOC                ; LR-> IOC base address
        ASSERT  IOC :AND: &FF = 0
        STRB    LR, [LR, #IOCFIQMSK]    ; Disable Data ReQuest FIQs
    ]
 ]

06      MOV     LR, #0
        STR     LR, [R2, #FlpDCBlength] ; No data transferred
        MOV     R0, R1                  ; Get error code
        BL      FlpDqDCB                ; Terminate DCB (R0,R2->)
        Pull    "R0,PC"

; Process initialization message, R2->DCB
10
        Push    "R0,R1,R4,LR"
        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    R0, #FlpPhaseIdle       ; Idle phase?
        Pull    "R0,R1,R4,PC",NE        ; No then exit

; Select requested drive

        SETPSR  I_bit, LR,, R4          ; Disable IRQ's

        LDRB    R1, [R2, #FlpDCBcdb+1]  ; Get drive select
        AND     R1, R1, #3              ; Retain drive select bits
        MOV     R0, #FlpEventDrvSel     ; Drive select event
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpDrive            ; Call drive state system (R0,R1->R0)

        MOV     LR, #FlpPhaseDrv        ; Next phase is awaiting drive ready
        STRB    LR, [R2, #FlpDCBphase]  ; Update phase
        TSTS    R0, #MiscOp_PollChanged_Empty_Flag+MiscOp_PollChanged_Ready_Flag ; Drive empty or ready?
        BNE     %FT15
        RestPSR R4,,c                   ; No then restore regs and wait
        Pull    "R0,R1,R4,PC"

15      TSTS    R0, #MiscOp_PollChanged_Empty_Flag          ; Drive empty?
        BEQ     %FT18

        MOV     R0, #0                  ; Yes then no data transferred
        STR     R0, [R2, #FlpDCBlength] ; And update length
        MOV     R0, #DriveEmptyErr      ; And drive empty error
        BL      FlpDqDCB                ; And terminate DCB (R0,R2->)
        RestPSR R4,,c                   ; Restore IRQ's
        Pull    "R0,R1,R4,PC"           ; Restore regs and exit

18
        RestPSR R4,,c                   ; Restore IRQ's
        Pull    "R0,R1,R4,LR"

; Process index pulse message, R2->DCB
20
        Push    "R0,R1,LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
 [ Debug10
        DREG    lr, "Index pulse gotten and phase is "
 ]
        CMPS    LR, #FlpPhaseDrv        ; Phase is awaiting drive ready?
        Pull    "R0,R1,PC",NE          ; No then exit

; Ensure '765 FDC has completed reset

        MOV     LR, #FlpPhaseReset      ; Assume waiting for reset
        STRB    LR, [R2, #FlpDCBphase]  ; Update phase
        baddr   R0, FlpStateReset       ; Reset state address
        LDR     LR, FlpState            ; Get current FDC state
 [ Debug10
        DLINE   "Check we're not is FlpStateReset"
 ]
        CMPS    LR, R0                  ; Currently reset?
        Pull    "R0,R1,PC",EQ           ; Yes then wait

; Lock the drive during execution

        LDRB    LR, FlpDriveLock        ; Get lock state
        ORR     LR, LR, #bit0+bit2      ; Set command lock bit, inhibit empty
        STRB    LR, FlpDriveLock        ; Update lock state

; Implied seek required?

        LDRB    R0, [R2, #FlpDCBcdb+1]  ; Get drive/head/implied seek
        TSTS    R0, #bit7               ; Implied seek?
 [ Debug10
        DLINE   "Check for implied seek"
 ]
        Pull    "R0,R1,LR",EQ           ; No, then restore regs
        BEQ     FlpHandlerData_ExecuteCommand ; and jump, issue command

; Request seek to required track

25
        MOV     LR, #FlpPhaseSeek       ; Next phase is waiting for seek done
        STRB    LR, [R2, #FlpDCBphase]  ; Update command phase
        MOV     R1, R2                  ; Get->DCB
        MOV     R0, #FlpEventSeek
 [ Debug10 :LOR: Debug10T
        DLINE   "Do the seek"
 ]
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpState            ; Call state system (R0,R1->R0,V)
        BVS     FlpHandlerData_SeekFault

 [ Debug10 :LOR: Debug10T
        DREG    r0, "Seek in progress with flag "
 ]
        TEQS    R0, #0                  ; Seek in progress?
        Pull    "R0,R1,LR"
        MOVNE   PC, LR                  ; Yes then exit

; Process seek done message, R2->DCB
FlpHandlerData_SeekDone
 [ Debug10
        DLINE   "Seek done"
 ]
        Push    "LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
        TEQS    LR, #FlpPhaseRetry      ; Retrying?
        LDREQB  LR, [R2, #FlpDCBresults+7] ; Yes, get old track reg
        STREQB  LR, [R2, #FlpDCBtrack]  ; And restore track reg
        Pull    "LR",EQ                 ; And restore regs
        Push    "R0,R1,LR",EQ           ; And setup stack
        BEQ     %BT25                   ; And retry seek

        TEQS    LR, #FlpPhaseSeek       ; Phase is awaiting seek done?
        Pull    "LR"
        MOVNE   PC, LR                  ; No then exit

; Seek completed, setup for command execution, R2->DCB
FlpHandlerData_ExecuteCommand
        Push    "R0,R1,LR"

 [ Debug10
        DREG    r2, "ExecuteCommand with DCB="
 ]

        LDR     R0, [R2, #FlpDCBtxbytes]
        STR     R0, [R2, #FlpDCBtxgobytes]

        ; Length has all sort of useful flags in it...
        LDR     R0, [R2, #FlpDCBlength] ; Get transfer size and direction

 [ :LNOT:FloppyPCI
; Copy FIQ handler to FIQ vector

        ; Choose handler...

        TST     R0, #FlpDCBscatter
        BNE     %FT33

        TST     R0, #FlpDCBread
        baddr   R0, FlpWriteNonScatter, EQ
        baddr   R0, FlpReadNonScatter, NE
        B       %FT39

33
        TST     R0, #FlpDCBread
        BNE     %FT35

        ; Writing
        LDRB    R0, [R2, #FlpDCBbgnd]
        TEQ     R0, #0
        baddr   R0, FlpWriteFIQ_FG, EQ
        baddr   R0, FlpWriteFIQ_BG, NE
        B       %FT39

35
        ; Reading
        LDRB    R0, [R2, #FlpDCBcdb+9]  ; Else get read/verify
        TEQS    R0, #&FF                ; Verifying?
        baddr   R0, FlpVerifyFIQ, EQ    ; Yes then use verify FIQ routine
        BEQ     %FT39

        LDRB    R0, [R2, #FlpDCBbgnd]
        TEQ     R0, #0
        baddr   R0, FlpReadFIQ_FG, EQ
        baddr   R0, FlpReadFIQ_BG, NE

39


        ; Switch to _32 mode with IRQs and FIQs off
        ; Note must switch interrupts off before switching mode as
        ; there can be an interrupt after the msr instruction
        ; but before the following instruction.
        ; For non-32-bit processors this section reads:
        ; NOP
        ; Push "r1"
        ; ORR   r1, r1, #number
        ; NOP
        ; ORR   r1, r1, #number
        ; NOP
        MRS     r1, CPSR
        Push    "r1"
        ORR     r1, r1, #I32_bit :OR: F32_bit
        MSR     CPSR_c, r1
        ORR     r1, r1, #2_10000
        MSR     CPSR_c, r1
        NOP

        MOV     LR, #FiqVector          ; FIQ vector address

        ; Copy handler
40      LDR     R1, [R0], #4            ; Get opcode
        TEQS    R1, #0                  ; All done?
        STRNE   R1, [LR], #4            ; No then copy to FIQ area
        BNE     %BT40                   ; And repeat

        ; And switch back - this bit reads as follows for non-32-bit processors:
        ; Pull  "r1"
        ; NOP
        Pull    "r1"
        MSR     CPSR_c, r1

        ; Put DCBbuffer into place
        LDR     R1, [R2, #FlpDCBbuffer]
        STR     R1, [LR, #-4]

        ; Put txcount into place
        ADD     R1, R2, #FlpDCBtxbytes
        STR     R1, [LR], #4

 [ Debug10 :LOR: Debug10t
        LDR     r1, [r2, #FlpDCBtxbytes]
        DREG    r1, "Start txbytes="
 ]

        ; Patch up the areas needing 1xSectorSize
        LDRB    R1, [R2, #FlpDCBcdb+5]  ; Log2SectorSize-7
        MOV     LR, #1 :SHL: (7 - 6)    ; SHL 7 for the -7 above, SHL -6 for the immediate
                                        ; rotate in the instructions we're patching
        MOV     R1, LR, ASL R1

45      LDR     LR, [R0], #4           ; Address of instruction to patch up
        TEQS    LR, #0
        STRNEB  R1, [LR]
        BNE     %BT45

        ; Patch up the areas needing 2xSectorSize
        MOV     r1, r1, ASL #1

50      LDR     LR, [R0], #4           ; Address of instruction to patch up
        TEQS    LR, #0
        STRNEB  R1, [LR]
        BNE     %BT50

  [ StrongARM
        ;now that we have finished arsing about, synchronise with respect to modified code
        Push    "R0-R2,LR"
        MOV     R0,#FiqVector                 ;start virtual address
        MOV     R1,#FiqVectorMaxCode          ;worst case end virtual address (inclusive)
        BL      ADFSsync
        Pull    "R0-R2,LR"
  ]

; Setup FIQ registers
        ; Choose handler...

        LDR     R1, FlpDACK_TC          ; before R12 gets banked out

        WritePSRc I_bit + F_bit + FIQ_mode,LR,,R0 ; FIQ mode, FIQ/IRQ disabled
        NOP                             ; delay for mode change

        ADR     LR, %FT59

        MOV     R13, R1                 ; R13-> DMA data reg with TC
        LDRB    R10, [R2, #FlpDCBcdb+5]
        MOV     R11, #1 :SHL: 7
        MOV     R10, R11, ASL R10       ; R10 = SectorSize
        LDR     R12, [R2, #FlpDCBlength]; R12 = DCBlength (inc flags)
        TST     R12, #FlpDCBscatter
        BNE     %FT54

        ; non-scatter register initialisation
 [ FlpUseFIFO
        LDR     R8, [R2, #FlpDCBbuffer]         ; r8 set

        TST     R12, #FlpDCBread
        LDREQB  R9, [R8], #1                    ; r9 set
        BIC     R12, R12, #FlpDCBflags          ; r12 set

        ; SectorSize-1 in R10
        SUB     R10, R10, #1

        ; R11 = round up of R12 to a sector
        ADD     R11, R12, R10
        BIC     R11, R11, R10

        ; Process for termination at sector's end
        SUBS    R11, R11, #1                    ; r11 set
        SUBNE   R13, R13, #FlpDACK_TC_Offset    ; r13 set
 |
        BIC     R10, R12, #FlpDCBflags
        SUBS    R10, R10, #1
        SUBNE   R13, R13, #FlpDACK_TC_Offset
        LDR     R8, [R2, #FlpDCBbuffer]
        TST     R12, #FlpDCBread
        LDREQB  R9, [R8], #1
 ]
        B       %FT59

54
        TST     R12, #FlpDCBread
        BIC     R12, R12, #bit29 :OR: FlpDCBflags
        BNE     %FT55

        ; Writing
        LDRB    R8, [R2, #FlpDCBbgnd]
        TEQ     R8, #0
        BEQ     FIQSetupWrite_FG
        B       FIQSetupWrite_BG

55
        ; Reading
        LDRB    R8, [R2, #FlpDCBcdb+9]  ; Else get read/verify
        TEQS    R8, #&FF                ; Verifying?
        BEQ     FIQSetupVerify
        LDRB    R8, [R2, #FlpDCBbgnd]
        TEQ     R8, #0
        BEQ     FIQSetupRead_FG
        B       FIQSetupRead_BG

59

; Enable Data ReQuest FIQ's

 [ :LNOT:HAL
        MOV     R1, #IOC                ; R1-> IOC base address
        MOV     LR, #1:SHL:FlpDRQmaskbit; DRQ FIQ mask
        STRB    LR, [R1, #IOCFIQMSK]    ; Enable Data ReQuest FIQs
 ]
 | ; FloppyPCI
        ; up to SVC mode for SWI calls
        LDR     R0, [R2, #FlpDCBlength] ; Get transfer size and direction

        ; Ensure no transfers lingering
        BL      FlpDMATerminate

        TST     R0, #FlpDCBscatter
        BNE     %FT54

        Push    "R3,R4"
        ADR     R3, FlpDMAScatter

        LDR     R1, [R2, #FlpDCBbuffer]         ; R1 = buffer
        BIC     R4, R0, #FlpDCBflags            ; R4 = length

        STMIA   R3, {R1, R4}

        TST     R0, #FlpDCBread
        MOVEQ   R0, #1+8
        MOVNE   R0, #0
        LDR     R1, FlpDMAHandle
        BL      FlpDMAQueueTransfer
        Pull    "R3,R4"
        BVS     FlpHandlerData_DMAErr
        STR     R0, FlpDMATag
        B       %FT59

54
 [ Debug10d
        DREG    R0, "Cmd/length = "
        LDRB    R1, [R2, #FlpDCBbgnd]
        DREG    R1, "Background flag = ",, Byte
        LDRB    R1, [R2, #FlpDCBcdb+9]
        DREG    R1, "Command = ",, Byte
 ]
        ADR     LR, %FT59
        TST     R0, #FlpDCBread
        BIC     R0, R0, #bit29 :OR: FlpDCBflags
        BNE     %FT55

        ; Writing
        LDRB    R1, [R2, #FlpDCBbgnd]
        TEQ     R1, #0
        BEQ     DMASetupWrite_FG
        B       DMASetupWrite_BG

55
        ; Reading
        LDRB    R1, [R2, #FlpDCBcdb+9]  ; Else get read/verify
        TEQS    R1, #&FF                ; Verifying?
        BEQ     DMASetupVerify
        LDRB    R1, [R2, #FlpDCBbgnd]
        TEQ     R1, #0
        BEQ     DMASetupRead_FG
        B       DMASetupRead_BG

59
        SavePSR R0
 ]

 [ No32bitCode
        ORR     R1, R0, #I_bit          ; Ensure IRQ's disabled
 |
        ORR     R1, R0, #I32_bit        ; Ensure IRQ's disabled
 ]
        RestPSR R1,,c                   ; Restore CPU mode
        NOP

 [ HAL
  [ :LNOT:FloppyPCI
        Push    "R0,R2,R3,R9,R12"
        MOV     R0, #FlpDRQmaskbit
        sbaddr  R1, HAL_FIQEnable_routine
        MOV     LR, PC
        LDMIA   R1, {R9, PC}
        Pull    "R0,R2,R3,R9,R12"
   [ FloppyPodule
        LDR     R1, FlpDACK_TC
        SUB     R1, R1, #&400000
        MOV     LR, #1
        STRB    LR, [R1, #8]
   ]
  ]
 ]

        Push    "r0"

 [ Debug10s :LAND: {FALSE}
        LDR     lr, [r2, #FlpDCBlength]
        AND     lr, lr, #FlpDCBflags
        TEQ     lr, #FlpDCBscatter :OR: FlpDCBread
        BNE     %FT01
        ; Scatter reading...
        LDRB    lr, [r2, #FlpDCBcdb+9]
        TEQ     lr, #&ff
        BEQ     %FT01
        ; non-verify...
        LDRB    lr, [r2, #FlpDCBbgnd]
        TEQ     lr, #0
        BEQ     %FT01
        ; background...
        LDR     lr, [r2, #FlpDCBbuffer]
02
        LDMIA   lr, {r0,r1}
        DREG    r0, " ",cc
        DREG    r1, ",",cc
 [ FixTBSAddrs
        CMN     r0, #ScatterListNegThresh
        ADDCS   lr, lr, r0
        BCS     %BT02
 |
        TEQ     r0, #0
        ADDMI   lr, lr, r0
        BMI     %BT02
 ]
        ADD     lr, lr, #8
        TEQ     r1, #0
        BNE     %BT02
01
 ]

; Call FDC state system to execute the command

        MOV     R0, #FlpPhaseIRQ        ; Next phase isawaiting IRQ
        STRB    R0, [R2, #FlpDCBphase]  ; Update DCB phase
        MOV     R0, #FlpEventCmd        ; Command request
        MOV     R1, R2                  ; R1->DCB
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpState            ; Call state system (R0,R1->V)
 [ Debug10d
        BVC     %FT01
        DLINE   "Error from FlpEventCmd"
01
 ]
        BVS     FlpHandlerData_BadComErr

        LDRB    LR, FlpDriveLock        ; Get lock state
        BIC     LR, LR, #bit2           ; Enable empty timer
        STRB    LR, FlpDriveLock        ; Update lock state


 [ Debug10s
        LDR     lr, [r2, #FlpDCBlength]
        AND     lr, lr, #FlpDCBflags
        TEQ     lr, #FlpDCBscatter :OR: FlpDCBread
        BNE     %FT01
        ; Scatter reading...
        LDRB    lr, [r2, #FlpDCBcdb+9]
        TEQ     lr, #&ff
        BEQ     %FT01
        ; non-verify...
        LDRB    lr, [r2, #FlpDCBbgnd]
        TEQ     lr, #0
        BEQ     %FT01
        ; background...
        LDR     lr, [r2, #FlpDCBbuffer]
02
        LDMIA   lr, {r0,r1}
        DREG    r0, " ",cc
        DREG    r1, ",",cc
 [ FixTBSAddrs
        CMN     r0, #ScatterListNegThresh
        ADDCS   lr, lr, r0
        BCS     %BT02
 |
        TEQ     r0, #0
        ADDMI   lr, lr, r0
        BMI     %BT02
 ]
        ADD     lr, lr, #8
        TEQ     r1, #0
        BNE     %BT02
01
 ]
        Pull    "lr"
 [ No32bitCode
        BIC     lr, lr, #F_bit          ; Return and enable FIQs if OK
 |
        BIC     lr, lr, #F32_bit
 ]
        RestPSR lr
        Pull    "R0,R1,PC"              ; Restore regs and return

FlpHandlerData_BadComErr
        MOV     R0, #BadComErr          ; Return bad command if error in FDC
        BL      FlpDqDCB                ; Terminate DCB if error occurred
        LDRB    LR, FlpDriveLock        ; Get lock state
        BIC     LR, LR, #bit2           ; Enable empty timer
        STRB    LR, FlpDriveLock        ; Update lock state
        Pull    "lr"
        RestPSR lr
        Pull    "R0,R1,PC"              ; Restore regs and return

FlpHandlerData_DMAErr
 [ :LNOT: NewErrors
        ORR     R0, R0, #ExternalErrorBit
 ]
        BL      FlpDqDCB
        Pull    "R0,R1,PC"

FlpHandlerData_SeekFault
        MOV     R0, #FlpErrSeekFault    ; Return seek fault if error
        BL      FlpDqDCB                ;   and terminate DCB (R0,R1->)
        Pull    "R0,R1,PC"              ;   and return

; Process IRQ message
60
        Push    "R0,R1,R3,LR"
        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    R0, #FlpPhaseIRQ        ; Phase is awaiting results?
        Pull    "R0,R1,R3,PC",NE        ; No then execute

 [ Debug10
        DREG    r2, "DCB="
 ]

; Command completed, disable FIQ's

 [ FloppyPCI
        MOV     R0, #0
        LDR     R1, FlpDMATag
        CMP     R1, #-1
        BEQ     %FT63
        BL      FlpDMAExamineTransfer
        MOVVS   R0, #0
        STR     R0, FlpDMACount
        BL      FlpDMATerminate
63

 |
  [ HAL
        Push    "R2,R9,R12"
        sbaddr  R1, HAL_FIQDisableAll_routine
        MOV     LR, PC
        LDMIA   R1, {R9, PC}
        Pull    "R2,R9,R12"
   [ FloppyPodule
        LDR     LR, FlpDACK_TC
        SUB     LR, LR, #&400000
        MOV     R0, #0
        STRB    R0, [LR, #8]
   ]
  |
        MOV     R1, #IOC                ; R1-> IOC base address
        MOV     R0, #0
        STRB    R0, [R1, #IOCFIQMSK]    ; Disable Data ReQuest FIQs
  ]
 ]
        MOV     R1, #FlpPhaseDone
        STRB    R1, [R2, #FlpDCBphase]

; Get '765 FDC results, R2->DCB

        MOV     R3, #7                  ; 7 result bytes
        ADD     R1, R2, #FlpDCBresults  ; R1-> result buffer

65      BL      Flp765read              ; Get result byte
        MOVVS   R0, #BadParmsErr        ; Bad parameters if can't read all results
        BVS     %FT70                   ; Jump if error
        STRB    R0, [R1], #1            ; Save result in DCB, R1++
        SUBS    R3, R3, #1              ; 1 less result
        BNE     %BT65                   ; Loop for all results

 [ Debug10v :LOR: Debug10 :LOR: Debug10t
        Push    "r0"
        LDRB    r0, [r2, #FlpDCBresults+0]
        BREG    r0,"ST0,ST1,ST2,C,H,R,N=",cc
        LDRB    r0, [r2, #FlpDCBresults+1]
        BREG    r0,",",cc
        LDRB    r0, [r2, #FlpDCBresults+2]
        BREG    r0,",",cc
        LDRB    r0, [r2, #FlpDCBresults+3]
        BREG    r0,",",cc
        LDRB    r0, [r2, #FlpDCBresults+4]
        BREG    r0,",",cc
        LDRB    r0, [r2, #FlpDCBresults+5]
        BREG    r0,",",cc
        LDRB    r0, [r2, #FlpDCBresults+6]
        BREG    r0,","
        LDR     r0, [r2, #FlpDCBtxbytes]
        DREG    r0, "End txbytes = "
        Pull    "r0"
 ]

  [ FlpUseVerify
        LDRB    R0, [R2, #FlpDCBcdb+9]
        TEQ     R0, #&FF
        BNE     %FT66
        BL      FlpController_TransferSize
    [ FloppyPCI
        STR     R1, FlpDMACount
    ]
66
  ]

; Advance command to where we're up to
        BL      FlpAdvanceTransfer

        LDRB    R0, [R2, #FlpDCBresults] ; Get ST0
        ANDS    R0, R0, #&C0            ; Test interrupt code or fault bits
        BNE     %FT80                   ; Jump if error

70
; DCB complete, R0= completion status

 [ Debug10
        DREG    r0,"DCB completed with RC "
 ]
        BL      FlpDqDCB                ; Terminate DCB (R0,R2->)
        Pull    "R0,R1,R3,PC"

; !!-Operation faulted-!!

80      LDRB    R1, [R2, #FlpDCBresults+1] ; Get ST1
 [ :LNOT: Debug10 :LOR: {TRUE}  ; Allow retry testing with write protected disk
        TSTS    R1, #bit1               ; Write protect?
        MOVNE   R0, #FlpDiscError       ; Yes, return FDC error
        BNE     %BT70                   ; And exit
 ]

; Check for sector not found on side 1, in case sector ID says head 0

        TSTS    R1, #bit2               ; Sector not found?
        LDRNEB  R0, [R2, #FlpDCBcdb+1]  ; Get drive/head data
        TSTNES  R0, #bit2               ; And head 1?
        BEQ     %FT81                   ; No then jump

        LDRB    R0, [R2, #FlpDCBcdb+3]  ; Get head number from sector ID
        TEQS    R0, #0                  ; H forced to 0?
        MOVEQ   R0, #1                  ; Restore H=1 if was 0
        MOVNE   R0, #0                  ; Else try H=0 for DFS and odd discs
        STRB    R0, [R2, #FlpDCBcdb+3]  ; Set head number for sector ID
        Pull    "R0,R1,R3,LR",NE        ; Restore regs
        BNE     FlpHandlerData_ExecuteCommand ; And retry operation with H=0

; Count down retries

81      LDRB    R0, [R2, #FlpDCBretries]
        SUBS    R0, R0, #1              ; Knock retry counter
        STRPLB  R0, [R2, #FlpDCBretries] ; Update it
        MOVMI   R0, #FlpDiscError       ; Error if retries exhausted
        BMI     %BT70                   ; And exit

 [ Debug10
        DREG    R0, "Retry# "
        DREG    R1, " ST1: "
 ]
        TSTS    R1, #bit4               ; Overrun?
        BEQ     %FT85                   ; No then jump

; Data overrun - inhibit video DMA

        LDR     LR, FlpMEMCstate
        TEQS    LR, #0                  ; MEMC_CR state saved?
 [ Debug10v :LOR: Debug10
        BNE     %FT810
        DLINE   "Data lost - inhibiting video DMA"
810
 ]
        BNE     %FT83

        ; Faff about in SVC mode to preserve flags etc
        WritePSRc SVC_mode + I_bit,lr,,r0
        NOP
        Push    "r0, lr"                ; SVC_lr
        MOV     r0, #MEMC_mystate
        MOV     r1, #MEMC_DMA_bits
        SWI     XOS_UpdateMEMC
        ORRVC   r0, r0, #bit31          ; ensures non-0
        STRVC   r0, FlpMEMCstate
        Pull    "r0, lr"                ; SVC_lr
        RestPSR r0,,c
        NOP
83
        Pull    "R0,R1,R3,LR"           ; Restore regs
        B       FlpHandlerData_ExecuteCommand ; And retry operation

; Just retry operation if no implied seek

85      LDRB    R0, [R2, #FlpDCBcdb+1]  ; Get head/drive/option bits
        TSTS    R0, #bit7               ; Implied seek?
        Pull    "R0,R1,R3,LR",EQ        ; No?, then restore regs
        BEQ     FlpHandlerData_ExecuteCommand ; And retry operation only

; Implied seek type DCB, try re-positioning head

        LDRB    LR, [R2, #FlpDCBresults+2] ; Get ST2
        TSTS    LR, #bit4               ; Wrong cylinder?
        LDRB    LR, [R2, #FlpDCBcdb+1]  ; Get drive
        AND     LR, LR, #3              ; Ignore head etc
        DrvRecPtr R1, LR
        MOVNE   LR, #PositionUnknown    ; Yes, force restore
        STRNE   LR, [R1, #HeadPosition]

        LDRB    LR, [R2, #FlpDCBtrack]  ; Get cylinder
        STRB    LR, [R2, #FlpDCBresults+7] ; Save track
        BNE     %FT87                   ; And jump

; Step in 2 tracks and retry operation

        LDR     R0, [R1, #DrvFlags]
        TSTS    R0, #MiscOp_PollChanged_40Track_Flag        ; 40 track?
        MOVNE   R0, #TrksPerSide/2      ; Yes, max track = tracks per side /2
        MOVEQ   R0, #TrksPerSide        ; Else max track
        ADD     LR, LR, #2              ; Try track+2
        CMPS    LR, R0                  ; At end of drive?
        SUBHS   LR, LR, #4              ; Yes, then try track-2
        STRB    LR, [R2, #FlpDCBtrack]  ; Write new track

; Request seek to new track

87      LDRB    LR, FlpDriveLock        ; Get lock state
        ORR     LR, LR, #bit0+bit2      ; Set command lock bit, inhibit empty
        STRB    LR, FlpDriveLock        ; Update lock state

        MOV     LR, #FlpPhaseRetry      ; New phase is retrying op
        STRB    LR, [R2, #FlpDCBphase]  ; Get current phase

        MOV     R1, R2                  ; Get->DCB
        MOV     R0, #FlpEventSeek
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpState            ; Call state system (R0,R1->R0,V)
        BVS     FlpHandlerData_SeekFault2

        TEQS    R0, #0                  ; Seek in progress?
        Pull    "R0,R1,R3,LR"
        MOVNE   PC, LR                  ; Yes then exit
        B       FlpHandlerData_SeekDone ; Else jump, seek done

FlpHandlerData_SeekFault2
        MOV     R0, #FlpErrSeekFault    ; Return seek fault if error
        BL      FlpDqDCB                ;   and terminate DCB (R0,R1->)
        Pull    "R0,R1,R3,PC"           ;   and return

; Process reset OK message
90
        Push    "LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    LR, #FlpPhaseReset      ; Phase is awaiting reset?
        Pull    "PC",NE                 ; No then exit

; Reset complete

        MOV     LR, #FlpPhaseDrv        ; Awaiting drive ready
        STRB    LR, [R2, #FlpDCBphase]  ; Update command phase
        Pull    "LR"
        B       %BT20                   ; Simulate drive ready

        LTORG

 [ FloppyPCI
; R0 = transfer size
; R2 -> DCB
DMASetupWrite_FG ROUT
        Push    "R3,R4,LR"
        MOV     R4, R0
        MOV     R0, #1+8
        B       %FT20

DMASetupRead_FG
        Push    "R3,R4,LR"
        MOV     R4, R0
        MOV     R0, #0+8

20      LDR     R3, [R2, #FlpDCBbuffer]
 [ Debug10d
        LDMIA   R3, {R1, R14}
        DREG    R1, "Scatter:",cc
        DREG    R14, ","
 ]
        LDR     R1, FlpDMAHandle
        BL      FlpDMAQueueTransfer
        STRVC   R0, FlpDMATag
        Pull    "R3,R4,PC",VC
        Pull    "R3,R4,LR"
        B       FlpHandlerData_DMAErr

DMASetupWrite_BG ROUT
        Push    "R3,R4,LR"
        MOV     R4, R0
        MOV     R0, #1+8
        B       %FT20

DMASetupRead_BG
        Push    "R3,R4,LR"
        MOV     R4, R0
        MOV     R0, #0+8

20      LDR     R3, [R2, #FlpDCBbuffer]
 [ Debug10d
        LDMIA   R3, {R1, R14}
        DREG    R1, "Scatter:",cc
        DREG    R14, ","
 ]
        BL      FlpLimitLengthToScatterList
        LDR     R1, FlpDMAHandle
        BL      FlpDMAQueueTransfer
        STRVC   R0, FlpDMATag
        Pull    "R3,R4,PC",VC
        Pull    "R3,R4,LR"
        B       FlpHandlerData_DMAErr


DMASetupVerify ROUT
        ASSERT  FlpUseVerify
        MOV     PC,LR
 |
; Entered in FIQ mode, FIQs and IRQs disabled
; R2 -> DCB
; R10 = SectorLength
; R12 = transfer size
; R13 -> controller DMA+TC
;
; Setup FIQ registers for foreground write transfer
FIQSetupWrite_FG ROUT
 [ FlpUseFIFO
        SUB     R10, R10, #1            ; SectorSize-1
        ADD     R11, R12, R10
        BIC     R11, R11, R10           ; transfer size rounded to a sector boundary
        LDR     R8, [R2, #FlpDCBbuffer]
        LDMIA   R8, {R8, R10}           ; Destination and length of scatter entry
        SUB     R10, R10, #1
        LDRB    R9, [R8], #1            ; byte to transfer
        SUB     R11, R11, #1
        SUB     R13, R13, #FlpDACK_TC_Offset
 |
        LDR     R11, [R2, #FlpDCBbuffer] ; Get buffer/scatter list pointer
        LDMIA   R11!, {R8, R10}
        LDRB    R9, [R8], #1
        SUBS    R12, R12, #1
        SUBNE   R13, R13, #FlpDACK_TC_Offset
 ]
 [ Debug10
        MOV     r1, #ScratchSpace
        STMIA   r1, {r8-r13}
        MRS     r1, CPSR
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode
        Push    "r0,r2,lr"
        MOV     r2, #ScratchSpace
        LDR     r0, [r2, #0]
        DREG    r0, "SetupWrite_FG->(",cc
        LDR     r0, [r2, #4]
        DREG    r0, ",",cc
        LDR     r0, [r2, #8]
        DREG    r0, ",",cc
        LDR     r0, [r2, #12]
        DREG    r0, ",",cc
        LDR     r0, [r2, #16]
        DREG    r0, ",",cc
        LDR     r0, [r2, #20]
        DREG    r0, ",",cc
        DLINE   ")"
        Pull    "r0,r2,lr"
        MSR     CPSR_c, r1
 ]
        MOV     PC, LR
FIQSetupWrite_BG ROUT
        ; Well, actually it's for the '665 controller

        ; Set up EOT length in R11
        SUB     R11, R12, #1

        LDR     R12, [R2, #FlpDCBbuffer]
        LDR     R8, [R12]               ; r8 now set
        LDR     R9, [R12, #4]
        CMP     R9, R10                 ; SectorSize
        BHI     %FT50

        ; 1xSectorSize in this sector's entry - find the next sector's entry
        LDR     R9, [R12, #8]!
 [ FixTBSAddrs
        CMN     R9, #ScatterListNegThresh
        ADDCS   R12, R12, R9
 |
        TEQ     R9, #0
        ADDMI   R12, R12, R9
 ]
        LDR     R9, [R12, #4]
        CMP     R9, #0
50
        ; If HI then more than 1 sector
        SUBLS   R11, R10, #1            ; terminate at this sector's end
                                        ; r11 now set
        MOV     r12, #1                 ; r12 now set
        SUB     R13, R13, #FlpDACK_TC_Offset ; r13 now set
        LDRB    R9, [R8], #1
 [ Debug10 :LOR: Debug10t
        MOV     r1, #ScratchSpace
        STMIA   r1, {r8-r13}
        MRS     r1, CPSR
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode
        Push    "r0,r2,lr"
        MOV     r2, #ScratchSpace
        LDR     r0, [r2, #0]
        DREG    r0, "SetupWrite_BG->(",cc
        LDR     r0, [r2, #4]
        DREG    r0, ",",cc
        LDR     r0, [r2, #8]
        DREG    r0, ",",cc
        LDR     r0, [r2, #12]
        DREG    r0, ",",cc
        LDR     r0, [r2, #16]
        DREG    r0, ",",cc
        LDR     r0, [r2, #20]
        DREG    r0, ",",cc
        DLINE   ")"
        Pull    "r0,r2,lr"
        MSR     CPSR_c, r1
 ]
        MOV     PC, LR
FIQSetupVerify ROUT
 [ FlpUseVerify
        MOV     R12, #0                 ; No data transfer so implicitly none left
 |
        SUB     R10, R10, #1
        ADD     R11, R12, R10
        BIC     R11, R11, R10           ; round up to sector boundary
        SUB     R11, R11, #1
        SUB     R13, R13, #FlpDACK_TC_Offset ; r13 now set
 ]
 [ Debug10
        MOV     r1, #ScratchSpace
        STMIA   r1, {r8-r13}
        MRS     r1, CPSR
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode
        Push    "r0,r2,lr"
        MOV     r2, #ScratchSpace
        LDR     r0, [r2, #0]
        DREG    r0, "SetupVerify->(",cc
        LDR     r0, [r2, #4]
        DREG    r0, ",",cc
        LDR     r0, [r2, #8]
        DREG    r0, ",",cc
        LDR     r0, [r2, #12]
        DREG    r0, ",",cc
        LDR     r0, [r2, #16]
        DREG    r0, ",",cc
        LDR     r0, [r2, #20]
        DREG    r0, ",",cc
        DLINE   ")"
        Pull    "r0,r2,lr"
        MSR     CPSR_c, r1
 ]
        MOV     PC, LR
FIQSetupRead_FG ROUT
 [ FlpUseFIFO
        SUB     R10, R10, #1            ; SectorSize-1
        ADD     R11, R12, R10
        BIC     R11, R11, R10           ; transfer size rounded to a sector boundary
        LDR     R8, [R2, #FlpDCBbuffer]
        LDMIA   R8, {R8, R10}           ; Destination and length of scatter entry
        SUB     R11, R11, #1
        SUB     R13, R13, #FlpDACK_TC_Offset
 |
        LDR     R11, [R2, #FlpDCBbuffer] ; Get buffer/scatter list pointer
        LDMIA   R11!, {R8, R10}
        SUBS    R12, R12, #1
        SUBNE   R13, R13, #FlpDACK_TC_Offset
 ]
 [ Debug10
        MOV     r1, #ScratchSpace
        STMIA   r1, {r8-r13}
        MRS     r1, CPSR
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode
        Push    "r0,r2,lr"
        MOV     r2, #ScratchSpace
        LDR     r0, [r2, #0]
        DREG    r0, "SetupRead_FG->(",cc
        LDR     r0, [r2, #4]
        DREG    r0, ",",cc
        LDR     r0, [r2, #8]
        DREG    r0, ",",cc
        LDR     r0, [r2, #12]
        DREG    r0, ",",cc
        LDR     r0, [r2, #16]
        DREG    r0, ",",cc
        LDR     r0, [r2, #20]
        DREG    r0, ",",cc
        DLINE   ")"
        Pull    "r0,r2,lr"
        MSR     CPSR_c, r1
 ]
        MOV     PC, LR
FIQSetupRead_BG ROUT
        ; Well, actually it's for the '665 controller

        ; Set up EOT length in R11
        SUB     R11, R12, #1

        LDR     R12, [R2, #FlpDCBbuffer]
        LDR     R8, [R12]               ; r8 now set
        LDR     R9, [R12, #4]
        CMP     R9, R10                 ; SectorSize
        BHI     %FT50

        ; 1xSectorSize in this sector's entry - find the next sector's entry
        LDR     R9, [R12, #8]!
 [ FixTBSAddrs
        CMN     R9, #ScatterListNegThresh
        ADDCS   R12, R12, R9
 |
        TEQ     R9, #0
        ADDMI   R12, R12, R9
 ]
        LDR     R9, [R12, #4]
        CMP     R9, #0
50
        ; If HI then more than 1 sector
        SUBLS   R11, R10, #1            ; terminate at this sector's end
                                        ; r11 now set
        MOV     r12, #1                 ; r12 now set
        SUB     R13, R13, #FlpDACK_TC_Offset ; r13 now set

 [ Debug10 :LOR: Debug10t
        MOV     r1, #ScratchSpace
        STMIA   r1, {r8-r13}
        MRS     r1, CPSR
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode
        Push    "r0,r2,lr"
        MOV     r2, #ScratchSpace
        LDR     r0, [r2, #0]
        DREG    r0, "SetupRead_BG->(",cc
        LDR     r0, [r2, #4]
        DREG    r0, ",",cc
        LDR     r0, [r2, #8]
        DREG    r0, ",",cc
        LDR     r0, [r2, #12]
        DREG    r0, ",",cc
        LDR     r0, [r2, #16]
        DREG    r0, ",",cc
        LDR     r0, [r2, #20]
        DREG    r0, ",",cc
        MOV     r0, #FlpReadThisRover - FlpReadFIQ_BG + FiqVector
        LDR     r0, [r0]
        DREG    r0, ",Rover=",cc
        DLINE   ")"
        Pull    "r0,r2,lr"
        MSR     CPSR_c, r1
 ]
        MOV     PC, LR
 ]

        LTORG

; -----------------------------------------------------------------------
; FlpAdvanceTransfer
;
; In
;       r2 -> DCB
;
; Out
;       Transfer advanced to restart/completion point.
;
FlpAdvanceTransfer ROUT
        Push    "r0,lr"

        LDR     r0, [r2, #FlpDCBlength]
        TST     r0, #FlpDCBscatter
        JumpAddress lr,FlpATRet,forward
        BEQ     FlpAdvanceNonScatterTransfer

        ; Scatter transfer
        LDRB    r0, [r2, #FlpDCBbgnd]
        TEQ     r0, #0
        BEQ     FlpAdvanceForegroundTransfer
        BNE     FlpAdvanceBackgroundTransfer

FlpATRet
        ; Move restart results to command
        LDRB    r1, [r2, #FlpDCBresults+3]      ; C
        STRB    r1, [r2, #FlpDCBcdb+2]
        LDRB    r1, [r2, #FlpDCBresults+4]      ; H
        STRB    r1, [r2, #FlpDCBcdb+3]
        LDRB    r1, [r2, #FlpDCBresults+6]      ; N
        STRB    r1, [r2, #FlpDCBcdb+5]
        LDRB    r1, [r2, #FlpDCBresults+5]      ; R
 [ FlpUseVerify
        LDRB    lr, [r2, #FlpDCBcdb+9]
        LDRB    r0, [r2, #FlpDCBcdb+4]          ; r0 = original R
 ]
        STRB    r1, [r2, #FlpDCBcdb+4]          ; r1 = final R

 [ FlpUseVerify
        TEQ     lr, #&FF
        BNE     %FT01
; For verify, need to decrement sector count
        LDRB    lr, [r2, #FlpDCBcdb+8]
        ADD     lr, lr, r0
        SUB     lr, lr, r1
        STRB    lr, [r2, #FlpDCBcdb+8]
01
 ]

        Pull    "r0,pc"

; -----------------------------------------------------------------------
; FlpAdvanceNonScatterTransfer
;
; In
;       r2 -> DCB
;
; Out
;       Transfer advanced to restart/completion point.
;
; As advance transfer, but does foreground specific parts only
;
FlpAdvanceNonScatterTransfer ROUT
        Push    "r0,r1,r3,lr"

 [ FloppyPCI
        LDR     r0, FlpDMACount
 |
        WritePSRc I_bit + F_bit + FIQ_mode,r1,,r3

        ; r0 = bytes left to transfer
        MOV     r0, r12

        RestPSR r3

        CMP     r0, #0
        MOVMI   r0, #0

        ; r0 = bytes transfered
        LDR     r1, [r2, #FlpDCBlength]
        BIC     r1, r1, #FlpDCBflags
        SUB     r0, r1, r0
 ]

 [ Debug10
        DREG    r0, "Advance transfer by "
 ]

        LDR     r1, [r2, #FlpDCBlength]
        SUB     r1, r1, r0
        STR     r1, [r2, #FlpDCBlength]
 [ Debug10
        DREG    r1, "DCBlength now ",cc
 ]
        LDR     r1, [r2, #FlpDCBtxbytes]
        ADD     r1, r1, r0
        STR     r1, [r2, #FlpDCBtxbytes]
 [ Debug10
        DREG    r1, ", txbytes now ",cc
 ]
        LDR     r1, [r2, #FlpDCBbuffer]
        ADD     r1, r1, r0
        STR     r1, [r2, #FlpDCBbuffer]
 [ Debug10
        DREG    r1, " and DCBbuffer now "
 ]

        Pull    "r0,r1,r3,pc"

; -----------------------------------------------------------------------
; FlpAdvanceForegroundTransfer
;
; In
;       r2 -> DCB
;
; Out
;       Transfer advanced to restart/completion point.
;
; As advance transfer, but does foreground specific parts only
;
FlpAdvanceForegroundTransfer ROUT
        Push    "r0,r1,r3,lr"

 [ FloppyPCI
        LDR     r0, FlpDMACount
 |
        WritePSRc I_bit + F_bit + FIQ_mode,r0,,r3

        ; r0 = bytes left to transfer
        MOV     r0, r12

        RestPSR r3

 [ Debug10t
        DREG    r0, "Bytes left="
 ]
        CMP     r0, #0
        MOVMI   r0, #0

        ; r0 = bytes transfered
        LDR     r1, [r2, #FlpDCBlength]
        BIC     r1, r1, #FlpDCBflags
        SUB     r0, r1, r0
 ]

        ; Determine how many sectors have been transfered from results
        BL      FlpController_TransferSize

        ; Advance not more than the finished sector's worth
        CMP     r0, r1
        MOVHI   r0, r1

        BL      FlpAdvanceScatter
        Pull    "r0,r1,r3,pc"


; -----------------------------------------------------------------------
; FlpAdvanceBackgroundTransfer
;
; In
;       r2 -> DCB
;
; Out
;       Transfer advanced to restart/completion point.
;
; As advance transfer, but does background specific parts only
;
FlpAdvanceBackgroundTransfer ROUT
        Push    "r0,r1,lr"

        ; Pick up scatter we're certain about and adjust DCB
 [ FloppyPCI
        LDR     r0, FlpDMACount
        BL      FlpController_TransferSize
 [ Debug10t
        DREG    r0, "transfer routine's transfered "
        DREG    r1, "controller's transfered "
 ]

        ; Advance not more than the finished sector's worth
        CMP     r0, r1
        MOVHI   r0, r1

        BL      FlpAdvanceScatter
 |
        LDR     lr, [r2, #FlpDCBlength]
        ; Well, actually it's for the '665
        WritePSRc I_bit + F_bit + FIQ_mode,r0,,r1
        MOV     r0, r12
        RestPSR r1
 [ Debug10s :LAND: {FALSE}
        NOP
        LDR     lr, [r2, #FlpDCBbuffer]
        Push    "lr"
 ]
        TEQ     r0, #1
        STRNE   r0, [r2, #FlpDCBbuffer]
 [ Debug10t
        DREG    r0, "Scatter pointer at end is "
 ]

        ; Work amount definitely transfered
        LDR     r0, [r2, #FlpDCBtxgobytes]
        LDR     r1, [r2, #FlpDCBtxbytes]
        SUB     r0, r1, r0

        ; Check if there's more...
        BL      FlpController_TransferSize
 [ Debug10t
        DREG    r0, "transfer routine's transfered "
        DREG    r1, "controller's transfered "
 ]

        ; Reduce Length by amount transfered by transfer routine
        LDR     lr, [r2, #FlpDCBlength]
        SUB     lr, lr, r0
        STR     lr, [r2, #FlpDCBlength]
 [ Debug10t
        DREG    lr, "DCBlength is now "
 ]

        ; If controller's transfered more, then advance by that amount
        CMP     r0, r1
        SUBLO   r0, r1, r0
 [ Debug
        SavePSR lr
        Push    "lr"
        BLO     %FT01
        DLINE   "NO BACKGROUND SCATTER ADVANCE"
01
        MRS     lr, CPSR
        TST     lr, #I32_bit
        BNE     %FT02
        DLINE   "IRQs ENABLED WHILST ADVANCING SCATTER LIST"
02
        TEQ     r0, #1024
        BEQ     %FT03
        DREG    r0, "SCATTER ADVANCE ISN'T EXACTLY ONE SECTOR:"
03
        Pull    "lr"
        RestPSR lr
 ]
        BLLO    FlpAdvanceScatter                  ; There's more the controller's taken
 ]

 [ Debug10s :LAND: {FALSE}
        Pull    "r0"
        LDR     r1, [r2, #FlpDCBbuffer]
        DREG    r0,,cc
        DREG    r1,"->",cc
10
        LDR     lr, [r0, #0]
        DREG    lr, " (",cc
        LDR     lr, [r0, #4]
        DREG    lr, ",",cc
        DLINE   ")",cc
        TEQ     r0, r1
        BEQ     %FT20
        LDR     lr, [r0, #0]
 [ FixTBSAddrs
        CMN     lr, #ScatterListNegThresh
        ADDCS   r0, r0, lr
        ADDCC   r0, r0, #8
 |
        TEQ     lr, #0
        ADDMI   r0, r0, lr
        ADDPL   r0, r0, #8
 ]
        TEQ     r0, r1
        B       %BT10
20
        DLINE   ""
 ]

        Pull    "r0,r1,pc"


; -----------------------------------------------------------------------
; FlpAdvanceScatter
;
; In
;       r0 = length to advance by
;       r2 -> DCB
;
; Out
;       Scatter and transfer counts advanced by amount specified
;
FlpAdvanceScatter ROUT
        Push    "r0,r1,r3,r4,r5,lr"
 [ Debug10
        DREG    r0, "Advance scatter by "
 ]

        ; Advance txbytes
        LDR     r1, [r2, #FlpDCBtxbytes]
        ADD     r1, r1, r0
        STR     r1, [r2, #FlpDCBtxbytes]
 [ Debug10
        DREG    r1, "txbytes now ",cc
 ]

        ; Reduce Length
        LDR     r1, [r2, #FlpDCBlength]
        SUB     r1, r1, r0
        STR     r1, [r2, #FlpDCBlength]
 [ Debug10
        DREG    r1, " and DCBlength now "
 ]

        ; Advance scatter list
        LDR     r1, [r2, #FlpDCBbuffer]
        LDRB    r5, [r2, #FlpDCBbgnd]
        B       %FT20
10
        ; Disable IRQs
;        MOV     lr, pc
;        TST     lr, #I_bit
;        TEQEQP  lr, #I_bit

        ; Obtain scatter
        LDMIA   r1, {r3, r4}
 [ Debug10s
        DREG    r3,"^",cc
        DREG    r4,",",cc
 ]

        ; Is scatter > amount left?
        CMP     r4, r0

        ; If scatter > amount left then reduce by amount left and amount left is 0
        ADDHI   r3, r3, r0
        SUBHI   r4, r4, r0
        MOVHI   r0, #0
 [ Debug10s
        BLS     %FT01
        DREG    r3,"v",cc
        DREG    r4,",",cc
01
 ]
        STMHIIA r1, {r3, r4}

        ; else scatter <= amount left so use scatter entry and reduce amount left
        ADDLS   r3, r3, r4
        SUBLS   r0, r0, r4
        MOVLS   r4, #0
 [ Debug10s
        BHI     %FT01
        DREG    r3,"w",cc
        DREG    r4,",",cc
01
 ]
        STMLSIA r1!, {r3, r4}

        ; Restore IRQs to old state
;        TEQP    pc, lr
15
        ; Check for wrapping in bg transfers
        TEQ     r5, #0
        BEQ     %FT20
        LDR     r3, [r1]
 [ FixTBSAddrs
        CMN     r3, #ScatterListNegThresh
        ADDCS   r1, r1, r3
 |
        TEQ     r3, #0
        ADDMI   r1, r1, r3
 ]
20
        CMP     r0, #0
        BHI     %BT10

        STR     r1, [r2, #FlpDCBbuffer]

        Pull    "r0,r1,r3,r4,r5,pc"


; -----------------------------------------------------------------------
; FlpLimitLengthToScatterList
;
; In
;       r3 -> background scatter list
;       r4 = length
;
; Out
;       r4 = min(list length, input r4)
;

FlpLimitLengthToScatterList
        Push    "R3,R5,LR"
        MOV     R14, #0
10      LDR     R5, [R3, #0]
 [ FixTBSAddrs
        CMN     R5, #ScatterListNegThresh
        ADDHS   R3, R5, R3
 |
        TEQ     R5, #0
        ADDMI   R3, R5, R3
 ]
        LDR     R5, [R3, #4]
        TEQ     R5, #0
        BEQ     %FT90
        ADD     R14, R14, R5
        CMP     R14, R4
        ADDLS   R3, R3, #8
        BLO     %BT10
90      CMP     R14, R4
        MOVLO   R4, R14
        Pull    "R3,R5,PC"

; -----------------------------------------------------------------------
; FlpController_TransferSize
;
; In
;       r2 -> DCB
;
; Out
;       r1 = amount controller transfered [(end sector-start sector)*sector size]
;
FlpController_TransferSize ROUT
        Push    "r3,lr"

        ; If advanced to a different track return DCBlength instead
        LDRB    r3, [r2, #FlpDCBresults+4]      ; H!=H?
        LDRB    lr, [r2, #FlpDCBcdb+3]
        TEQ     r3, lr
        LDREQB  r3, [r2, #FlpDCBresults+3]      ; OR C!=C?
        LDREQB  lr, [r2, #FlpDCBcdb+2]
        TEQEQ   r3, lr
        LDRNE   r1, [r2, #FlpDCBlength]
        BICNE   r1, r1, #FlpDCBflags
        Pull    "r3,pc",NE

        ; Else size of transfer is size of sector difference between start and end
        LDRB    r1, [r2, #FlpDCBresults+5]      ; end sector number
        LDRB    r3, [r2, #FlpDCBcdb+4]          ; start sector number
        SUB     r1, r1, r3

        LDRB    r3, [r2, #FlpDCBcdb+5]
        ADD     r3, r3, #7
        MOV     r1, r1, ASL r3                  ; sectors worth of bytes
        Pull    "r3,pc"

; -----------------------------------------------------------------------

 [ FloppyPCI

FlpDMATerminate ROUT
        Push    "R0-R2,LR"
        LDR     R1, FlpDMATag
        CMP     R1, #-1
        BEQ     %FT99
        MRS     R2, CPSR
        ORR     R1, R2, #3
        MSR     CPSR_c, R1
        Push    "LR"
        MOV     R0, #0
        LDR     R1, FlpDMATag
        CMP     R1, #-1
        SWINE   XDMA_TerminateTransfer
        Pull    "LR"
        MSR     CPSR_c, R2
99
        Pull    "R0-R2,PC"

FlpDMAQueueTransfer ROUT
 [ Debug10d
        DREG    R0,"DMA_QueueTransfer(",cc
        DREG    R1,",",cc
        DREG    R2,",",cc
        DREG    R3,",",cc
        DREG    R4,",",cc
        DLINE   ")"
 ]
        CMP     R4, #0
        MOVEQ   R0, #-1
        MOVEQ   PC, LR
        Push    "R10,LR"
        MRS     R10, CPSR
        ORR     R14, R10, #3
        MSR     CPSR_c, R14
        Push    "LR"
        SWI     XDMA_QueueTransfer
        Pull    "LR"
        MSR     CPSR_c, R10
        Pull    "R10,PC"

FlpDMAExamineTransfer ROUT
        Push    "R4,LR"
        MRS     R4, CPSR
        ORR     R14, R4, #3
        MSR     CPSR_c, R14
        Push    "LR"
        SWI     XDMA_ExamineTransfer
        Pull    "LR"
        MSR     CPSR_c, R4
        Pull    "R4,PC"
 ]

;-----------------------------------------------------------------------;
; FlpHandlerReadID                                                      ;
;       Message handler for ReadID type FDC command.                    ;
;       Reads the next sector ID if buffer size is 0 or as many from the;
;       specified track that fit into the buffer, starting with the     ;
;       first sector after the index pulse and stopping at the next     ;
;       index pulse.  Each ID requires 4 bytes and is arranged:         ;
;                                                                       ;
;               Cylinder No., Head No, Sector No., Sector Size          ;
;                                                                       ;
; Input:                                                                ;
;       R0 = Message                                                    ;
;       R1 = Parameter                                                  ;
;       R12 = SB                                                        ;
;                                                                       ;
; Output:                                                               ;
;       None                                                            ;
;                                                                       ;
; Modifies:                                                             ;
;       None                                                            ;
;_______________________________________________________________________;
;
FlpHandlerReadID ROUT
 [ No32bitCode
        Push    "LR"
        BL      %FT00
        Pull    "PC",,^
 |
        Push    "R6,LR"
        MRS     R6, CPSR
        BL      %FT00
        MSR     CPSR_cf, R6
        Pull    "R6,PC"
 ]
00
        CMPS    R0, #FlpEventIRQ        ; FDC interrupt?
        BEQ     %FT60                   ; Yes then jump
        CMPS    R0, #FlpMsgIP           ; Drive ready index pulse?
        BEQ     %FT20                   ; Yes then jump
        CMPS    R0, #FlpMsgSeekDone     ; Seek complete?
        BEQ     %FT30                   ; Yes then jump
        CMPS    R0, #FlpMsgStart        ; Initialise?
        BEQ     %FT10                   ; Yes then jump
        CMPS    R0, #FlpMsgResetOK      ; Reset complete?
        BEQ     %FT80                   ; Yes then jump
        CMPS    R0, #FlpMsgError        ; Fatal error?
        BEQ     %FT05                   ; Yes then jump
        CMPS    R0, #FlpMsgESC          ; Escape?
        MOVNE   PC, LR                  ; No then return

; Handle escape message

        Push    "LR"
        LDRB    LR, [R2, #FlpDCBesc]    ; Get escape enable flag
        TEQS    LR, #0                  ; Escapes enabled?
        Pull    "LR"
        MOVNE   PC, LR                  ; No then exit

; Handle error message, R1= error code
05
        Push    "R0,LR"
        LDRB    LR, [R2, #FlpDCBphase]
        TEQS    LR, #FlpPhaseIdle       ; Idle phase?
        BLNE    Flp765reset             ; No then reset FDC

        MOV     LR, #0
        STR     LR, [R2, #FlpDCBlength] ; No data transferred
        TEQ     R1, #FlpErrTimeOut      ; Command timed out?
        MOVEQ   R0, #FlpErrNoIDs        ; Yes then no IDs
        MOVNE   R0, R1                  ; Else get error code
        BL      FlpDqDCB                ; Terminate DCB (R0,R2->)
        Pull    "R0,PC"


; Process initialization message, R2->DCB
10
        Push    "R0,R1,LR"
        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    R0, #FlpPhaseIdle       ; Idle phase?
        Pull    "R0,R1,PC",NE           ; No then exit

; Select requested drive

        SETPSR  I_bit, LR               ; Disable IRQ's

        LDRB    R1, [R2, #FlpDCBcdb+1]  ; Get drive select
        AND     R1, R1, #3              ; Retain drive select bits
        MOV     R0, #FlpEventDrvSel     ; Drive select event
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpDrive            ; Call drive state system (R0,R1->R0)

        MOV     LR, #FlpPhaseDrv        ; Next phase is awaiting drive ready
        STRB    LR, [R2, #FlpDCBphase]  ; Update phase
        TSTS    R0, #MiscOp_PollChanged_Empty_Flag+MiscOp_PollChanged_Ready_Flag ; Drive empty or ready?
        Pull    "R0,R1,PC",EQ           ; No then restore regs and wait

        TSTS    R0, #MiscOp_PollChanged_Empty_Flag          ; Drive empty?
        MOVNE   R0, #DriveEmptyErr      ; Yes, drive empty error
        BLNE     FlpDqDCB               ;   then terminate DCB (R0,R2->)
        Pull    "R0,R1,LR"
        MOVNE   PC, LR                  ;   then exit

; Drive is ready, fall thru to drive ready message

 [ No32bitCode
        TEQP    LR, #0                  ; Restore IRQ state
 |
        RestPSR R6                      ; Restore IRQ state
 ]

; Process drive ready message (index pulse), R2->DCB
20
        Push    "LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
        TEQS    LR, #FlpPhaseIRQip      ; Expecting IP or IRQ?
        Pull    "LR",EQ                 ; Yes restore regs
        BEQ     %FT75                   ; And jump

        TEQS    LR, #FlpPhaseIP         ; Awaiting IP?
        Pull    "LR",EQ                 ; Yes restore regs
        BEQ     %FT40                   ; And jump

        TEQS    LR, #FlpPhaseDrv        ; Phase is awaiting drive ready?
        Pull    "LR"
        MOVNE   PC, LR                  ; No then exit

; Ensure '765 FDC has completed reset

        Push    "R0,R1,LR"
        MOV     LR, #FlpPhaseReset      ; Assume waiting for reset
        STRB    LR, [R2, #FlpDCBphase]  ; Update phase
        baddr   R0, FlpStateReset       ; Reset state address
        LDR     LR, FlpState            ; Get current FDC state
        CMPS    LR, R0                  ; Currently reset?
        Pull    "R0,R1,PC",EQ           ; Yes then wait

; Lock the drive during execution

        LDRB    LR, FlpDriveLock        ; Get lock state
        ORR     LR, LR, #bit0+bit2      ; Set command lock bit, inhibit empty
        STRB    LR, FlpDriveLock        ; Update lock state

; Implied seek required?

        LDRB    R0, [R2, #FlpDCBcdb+1]  ; Get drive/head/implied seek
        TSTS    R0, #bit7               ; Implied seek?
        Pull    "R0,R1,LR",EQ           ; No, then restore regs
        BEQ     %FT40                   ;   and jump, issue command

; Request seek to required track

        MOV     LR, #FlpPhaseSeek       ; Next phase is waiting for seek done
        STRB    LR, [R2, #FlpDCBphase]  ; Update command phase
        MOV     R1, R2                  ; Get->DCB
        MOV     R0, #FlpEventSeek
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpState            ; Call state system (R0,R1->V)

        MOVVS   R0, #FlpErrSeekFault    ; Return seek fault if error
        BLVS    FlpDqDCB                ;   and terminate DCB (R0,R1->)
        Pull    "R0,R1,PC",VS           ;   and return

        TEQS    R0, #0                  ; Seek in progress?
        Pull    "R0,R1,LR"
        MOVNE   PC, LR                  ; Yes then exit


; Process seek done message, R2->DCB
30
        Push    "LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
        TEQS    LR, #FlpPhaseSeek       ; Phase is awaiting seek done?
        Pull    "PC",NE                 ;No then exit

; Ensure ReadID starts immediately after an index pulse.

        LDR     LR, [R2, #FlpDCBlength] ; Get buffer size
        TEQS    LR, #0                  ; Zero?
        MOVNE   LR, #FlpPhaseIP         ; No, next phase is awaiting IP
        STRNEB  LR, [R2, #FlpDCBphase]  ; Update DCB phase
        Pull    "LR"
        MOVNE   PC, LR                  ; No, exit - wait for IP

; Issue ReadID command
40
        Push    "R0,R1,LR"
        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        TEQS    R0, #FlpPhaseIRQip      ; IRQ or IP phase
        MOVNE   R0, #FlpPhaseIRQ        ; No then goto IRQ phase
        STRNEB  R0, [R2, #FlpDCBphase]  ; And update phase

        LDRB    LR, FlpDriveLock        ; Get lock state
        BIC     LR, LR, #bit2           ; Enable empty timer
        STRB    LR, FlpDriveLock        ; Update lock state

        MOV     LR, #2                  ; 2 byte command
        STRB    LR, [R2, #FlpDCBcmdLen] ; Write command length

        MOV     R0, #FlpEventCmd        ; Command request
        MOV     R1, R2                  ; R1->DCB
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpState            ; Call state system (R0,R1->V)
        MOVVS   R0, #BadComErr          ; Return bad command if error in FDC
        BLVS    FlpDqDCB                ; Terminate DCB if error occurred
        Pull    "R0,R1,PC"              ; Restore regs


; Process IRQ message
60
        Push    "R0,R1,R3,LR"
        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        TEQS    R0, #FlpPhaseIRQ        ; Phase is awaiting results?
        TEQNES  R0, #FlpPhaseIRQip      ; Or awaiting IRQ or IP
        TEQNES  R0, #FlpPhaseDone       ; Or done
        Pull    "R0,R1,R3,PC",NE        ; No then exit

; Command completed, get '765 FDC results, R2->DCB

        MOV     R3, #7                  ; 7 result bytes
        ADD     R1, R2, #FlpDCBresults  ; Yes R1-> result buffer

65      BL      Flp765read              ; Get result byte
        MOVVS   R0, #BadParmsErr        ; Bad parameters if can't read all results
        BVS     %FT69                   ; Jump if error
        STRB    R0, [R1], #1            ; Save result in DCB, R1++
 [ {FALSE}    ; LA trigger for debugging IDE interaction
        CMPS    R3, #2                  ; Next byte is last?
        LDREQ   LR, FlpBase             ; FDC register base (&3F0 in PC/AT)
        LDREQB  LR, [LR, #FlpStatusA]   ; Yes, read CnTbase + &FC0
 ]
        SUBS    R3, R3, #1              ; 1 less result
        BNE     %BT65                   ; Loop for all results

; Check for errors

        LDRB    R0, [R2, #FlpDCBresults] ; Get ST0
        TSTS    R0, #&C0                ; Bad completion?
        BNE     %FT70                   ; Yes then jump

        LDR     R0, [R2, #FlpDCBlength] ; Get buffer size
        TEQS    R0, #0                  ; Zero?
        BEQ     %FT69                   ; Yes then exit

; Copy sector ID to buffer

        MOV     R3, #4                  ; 4 sector ID bytes
        ADD     R0, R2, #FlpDCBresults+3 ; R0-> ID bytes
        LDR     R1, [R2, #FlpDCBbuffer] ; R1-> buffer address
67      LDRB    LR, [R0], #1            ; Get ID, R0++
        STRB    LR, [R1], #1            ; Copy it, R1++
        SUBS    R3, R3, #1
        BNE     %BT67                   ; For all bytes

        STR     R1, [R2, #FlpDCBbuffer] ; Save new buffer ptr

        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        TEQS    R0, #FlpPhaseDone       ; Read all track?
        MOVEQ   R0, #0                  ; Yes then no errors
        BEQ     %FT69                   ; And then exit

        MOV     R0, #FlpPhaseIRQip      ; Next phase isawaiting IRQ or IP
        STRB    R0, [R2, #FlpDCBphase]  ; Update DCB phase

; Update buffer size remaining

        LDR     R0, [R2, #FlpDCBlength]
        SUBS    R0, R0, #4              ; Decrement length
        STR     R0, [R2, #FlpDCBlength] ; Update length
        Pull    "R0,R1,R3,LR",HI        ; Restore regs if more left
        BHI     %BT40                   ; And read next ID

        MOV     R0, #0                  ; Else all done, no error
69      BL      FlpDqDCB                ; Terminate DCB (R0,R2->)
        Pull    "R0,R1,R3,PC"           ; And exit

; Retry faulty operation

70      LDRB    R0, [R2, #FlpDCBretries]
        SUBS    R0, R0, #1              ; Knock retry counter
        STRPLB  R0, [R2, #FlpDCBretries] ; Update it
        MOVMI   R0, #FlpDiscError       ; Error if retries exhausted
        BMI     %BT69                   ; And exit

 [ Debug10
        DREG    R0, "ReadID retry# ",cc
        DREG    R1, " ST1: "
 ]
        MOV     LR, #FlpPhaseSeek
        STRB    LR, [R2, #FlpDCBphase]  ; Change to seek phase
        Pull    "R0,R1,R3,LR"           ; Restore regs
        B       %BT30                   ; Retry operation

; End of track index pulse received
75
        Push    "LR"
        MOV     LR, #FlpPhaseDone
        STRB    LR, [R2, #FlpDCBphase]  ; Goto done phase
        Pull    "PC"                    ; Exit


; Process reset OK message
80
        Push    "LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    LR, #FlpPhaseReset      ; Phase is awaiting reset?
        Pull    "PC",NE                 ; No then exit

; Reset complete

        MOV     LR, #FlpPhaseDrv        ; Awaiting drive ready
        STRB    LR, [R2, #FlpDCBphase]  ; Update command phase
        Pull    "LR"
        B       %BT20                   ; Simulate drive ready



;-----------------------------------------------------------------------;
; FlpHandlerSeek                                                        ;
;       Message handler for seek and recalibrate commands.              ;
;                                                                       ;
; Input:                                                                ;
;       R0 = Message                                                    ;
;       R1 = Parameter                                                  ;
;       R12 = SB                                                        ;
;                                                                       ;
; Output:                                                               ;
;       None                                                            ;
;                                                                       ;
; Modifies:                                                             ;
;       None, preserves flags                                           ;
;_______________________________________________________________________;
;
FlpHandlerSeek  ROUT
 [ No32bitCode
        Push    "LR"
        BL      %FT00
        Pull    "PC",,^
 |
        Push    "R6,LR"
        MRS     R6, CPSR
        BL      %FT00
        MSR     CPSR_cf, R6
        Pull    "R6,PC"
 ]
00
        CMPS    R0, #FlpEventIRQ        ; FDC interrupt?
        BEQ     %FT60                   ; Yes then jump
        CMPS    R0, #FlpMsgIP           ; Drive ready index pulse?
        BEQ     %FT20                   ; Yes then jump
        CMPS    R0, #FlpMsgStart        ; Initialise?
        BEQ     %FT10                   ; Yes then jump
        CMPS    R0, #FlpMsgResetOK      ; Reset complete?
        BEQ     %FT80                   ; Yes then jump
        CMPS    R0, #FlpMsgError        ; Fatal error?
        MOVNE   PC, LR                  ; No then return

; Handle error message, R1= error code

        Push    "R0,LR"
        TEQS    R1, #DriveEmptyErr      ; Drive empty error?
        LDREQB  LR, [R2, #FlpDCBtimeOut]
        TEQEQS  LR, #0                  ; And no timeout?
        Pull    "R0,PC",EQ              ; Yes ignore it

        LDRB    LR, [R2, #FlpDCBphase]
        TEQS    LR, #FlpPhaseIdle       ; Idle phase?
        BLNE    Flp765reset             ; No then reset FDC

        MOV     R0, R1                  ; Get error code
        BL      FlpDqDCB                ; Terminate DCB (R0,R2->)
        Pull    "R0,PC"


; Process initialization message, R2->DCB
10
        Push    "R0,R1,LR"
        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    R0, #FlpPhaseIdle       ; Idle phase?
        Pull    "R0,R1,PC",NE           ; No then exit

; Select requested drive

        SETPSR  I_bit, lr               ; Disable IRQ's

        LDRB    R1, [R2, #FlpDCBcdb+1]  ; Get drive select
        AND     R1, R1, #3              ; Retain drive select bits
        MOV     R0, #FlpEventDrvSel     ; Drive select event
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpDrive            ; Call drive state system (R0,R1->R0)

        MOV     LR, #FlpPhaseDrv        ; Next phase is awaiting drive ready
        STRB    LR, [R2, #FlpDCBphase]  ; Update phase

        LDRB    LR, [R2, #FlpDCBtimeOut]
        TEQS    LR, #0                  ; Timeout's disabled?
        Pull    "R0,R1,LR",EQ
        BEQ     %FT20                   ; Yes then jump

        TSTS    R0, #MiscOp_PollChanged_Empty_Flag+MiscOp_PollChanged_Ready_Flag ; Drive empty or ready?
        Pull    "R0,R1,PC",EQ           ; No then restore regs and wait

        TSTS    R0, #MiscOp_PollChanged_Empty_Flag          ; Drive empty?
        MOVNE   R0, #DriveEmptyErr      ; Yes, drive empty error
        BLNE     FlpDqDCB               ;   then terminate DCB (R0,R2->)
        Pull    "R0,R1,LR"
        MOVNE   PC, LR                  ;   then exit

; Drive is ready, fall thru to drive ready message


; Process drive ready message (index pulse), R2->DCB
20
        Push    "LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
        TEQS    LR, #FlpPhaseDrv        ; Phase is awaiting drive ready?
        Pull    "LR"
        MOVNE   PC, LR                  ; No then exit

; Ensure '765 FDC has completed reset

        Push    "R0,R1,LR"
        SETPSR  I_bit, LR               ; Ensure IRQ's disabled
        MOV     LR, #FlpPhaseReset      ; Assume waiting for reset
        STRB    LR, [R2, #FlpDCBphase]  ; Update phase
        baddr   R0, FlpStateReset       ; Reset state address
        LDR     LR, FlpState            ; Get current FDC state
        CMPS    LR, R0                  ; Currently reset?
        Pull    "R0,R1,LR"
        MOVEQ   PC, LR                  ; Yes then wait

; Lock the drive during execution
25
        Push    "R0,R1,LR"
        SETPSR  I_bit, LR               ; Ensure IRQ's disabled
        LDRB    LR, FlpDriveLock        ; Get lock state
        ORR     LR, LR, #bit0+bit2      ; Set command lock bit, inhibit empty
        STRB    LR, FlpDriveLock        ; Update lock state

        LDRB    R0, [R2, #FlpDCBselect] ; Get clock requested
        BL      Flp765specify           ; Set drive step rate

        MOV     R0, #FlpPhaseIRQ        ; Goto IRQ phase
        STRB    R0, [R2, #FlpDCBphase]  ; Update phase

        LDRB    LR, [R2, #FlpDCBcdb]    ; Get command
        TEQS    LR, #FlpCmdRecal        ; Recalibrate?
        MOVEQ   LR, #2                  ; Yes 2 byte command
        MOVNE   LR, #3                  ; Else 3 byte seek command
        STRB    LR, [R2, #FlpDCBcmdLen] ; Write command length

        MOV     R0, #FlpEventCmd        ; Command request
        MOV     R1, R2                  ; R1->DCB
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpState            ; Call state system (R0,R1->V)
        MOVVS   R0, #BadComErr          ; Return bad command if error in FDC
        BLVS    FlpDqDCB                ; Terminate DCB if error occurred

        Pull    "R0,R1,PC"              ; Restore regs


; Process IRQ message
60
        Push    "R0,R1,R3,LR"
        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        TEQS    R0, #FlpPhaseIRQ        ; Phase is awaiting results?
        Pull    "R0,R1,R3,PC",NE        ; No then exit

; Seek/restore completed, get '765 FDC results, R2->DCB

        BL      FlpIRQstatus            ; Request interrupt status (->R0,R1,V)
        MOVVS   R0, #FlpErrFDC          ; FDC error if VS
        BVS     %FT69                   ; Jump if error

        LDRB    LR, FlpDrvNum           ; Get current drive
        AND     LR, LR, #3              ; 0..3
        DrvRecPtr R3, LR                ; Get ->  current drive record

; Check for errors

        TSTS    R1, #&C0                ; Bad completion?
        ORRNE   R0, R0, #PositionUnknown ; Yes then ensure restore next
 [ {FALSE}
        DREG    R1, "Seek ST0: ",cc
        DREG    R0, " PCN: "
 ]
        STR     R0, [R3, #HeadPosition] ; Save new head position
        STRB    R0, [R2, #FlpDCBresults+1] ; Save PCN
        STRB    R1, [R2, #FlpDCBresults] ; Save ST0
        BNE     %FT70                   ; Jump if error

        MOV     R0, #0                  ; Else no error
69      BL      FlpDqDCB                ; Terminate DCB (R0,R2->)
        Pull    "R0,R1,R3,PC"

; Retry faulty operation

70      LDRB    R0, [R2, #FlpDCBretries]
        SUBS    R0, R0, #1              ; Knock retry counter
        STRPLB  R0, [R2, #FlpDCBretries] ; Update it
        MOVMI   R0, #FlpDiscError       ; Error if retries exhausted
        BMI     %BT69                   ; And exit

 [ Debug10
        DREG    R0, "Seek Retry# ",cc
        DREG    R1, " ST0: "
 ]
        Pull    "R0,R1,R3,LR"
        B       %BT25                   ; Else retry operation


; Process reset OK message
80
        Push    "LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    LR, #FlpPhaseReset      ; Phase is awaiting reset?
        Pull    "LR"
        MOVNE   PC, LR                  ; No then exit
        B       %BT25                   ; Simulate drive ready


;-----------------------------------------------------------------------;
; FlpHandlerDrv                                                         ;
;       Message handler for sense drive status type FDC command         ;
;                                                                       ;
; Input:                                                                ;
;       R0 = Message                                                    ;
;       R1 = Parameter                                                  ;
;       R12 = SB                                                        ;
;                                                                       ;
; Output:                                                               ;
;       None                                                            ;
;                                                                       ;
; Modifies:                                                             ;
;       None, preserves flags                                           ;
;_______________________________________________________________________;
;
FlpHandlerDrv   ROUT
 [ No32bitCode
        Push    "LR"
        BL      %FT00
        Pull    "PC",,^
 |
        Push    "R6,LR"
        MRS     R6, CPSR
        BL      %FT00
        MSR     CPSR_cf, R6
        Pull    "R6,PC"
 ]
00
        CMPS    R0, #FlpMsgIP           ; Index pulse?
        BEQ     %FT20                   ; Yes then jump
        CMPS    R0, #FlpMsgSeekDone     ; Seek complete?
        BEQ     %FT30                   ; Yes then jump
        CMPS    R0, #FlpMsgStart        ; Initialise?
        BEQ     %FT10                   ; Yes then jump
        CMPS    R0, #FlpMsgResetOK      ; Reset complete?
        BEQ     %FT80                   ; Yes then jump
        CMPS    R0, #FlpMsgError        ; Fatal error?
        MOVNE   PC, LR                  ; No then return

; Handle error message, R1= error code

        TEQS    R1, #DriveEmptyErr      ; Drive empty error?
        MOVNE   PC, LR                  ; No then exit

        Push    "LR"
        LDRB    LR, [R2, #FlpDCBphase]
        TEQS    LR, #FlpPhaseDrv        ; Awaiting drive ready?
        Pull    "LR"
        MOVNE   PC, LR                  ; No then exit
        B       FlpGetDrvStatus         ; Get status and terminate DCB


; Process initialization message, R2->DCB
10
        Push    "R0,R1,LR"
        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    R0, #FlpPhaseIdle       ; Idle phase?
        Pull    "R0,R1,PC",NE           ; No then exit

        SETPSR  I_bit,LR                ; Disable IRQ's

; Select requested drive

        LDRB    R1, [R2, #FlpDCBcdb+1]  ; Get drive select
        AND     R1, R1, #3              ; Retain drive select bits
        MOV     R0, #FlpEventDrvSel     ; Drive select event
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpDrive            ; Call drive state system (R0,R1->R0)

        STR     R0, [R2, #FlpDCBresults+4] ; Save drive status
        LDRB    LR, [R2, #FlpDCBcdb+1]  ; Get drive/head/implied seek
        TSTS    LR, #bit7               ; Implied seek?
        BLEQ    FlpGetDrvStatus         ; No, then get status
        Pull    "R0,R1,PC",EQ           ;   And restore regs and exit

        TSTS    R0, #MiscOp_PollChanged_Ready_Flag          ; Drive ready?
        BNE     %FT15                   ; Yes then jump
        TSTS    R0, #MiscOp_PollChanged_Empty_Flag          ; Drive empty?
        BLNE    FlpGetDrvStatus         ; Yes then get status
        Pull    "R0,R1,PC",NE           ;  and exit

; Check state of disk change from drive

15      MOV     R1, R0                  ; Save drive status
        BL      FlpGetDskChng           ; Read disk changed (->R0)
        TSTS    R0, #FlpDIRchanged      ; Disk changed from drive?
        BLEQ    FlpGetDrvStatus         ; No then get status
        Pull    "R0,R1,PC",EQ           ;  and exit, not changed
        MOV     R0, R1                  ; Restore drive status
 [ Debug10
        DLINE   "DskChng detected ",cc
 ]

; Drive reports changed

        LDRB    LR, FlpDriveLock        ; Get lock state
        ORR     LR, LR, #bit0+bit2      ; Set command lock bit
        STRB    LR, FlpDriveLock        ; Update lock state

        MOV     LR, #FlpPhaseDrv        ; Phase is awaiting drive ready
        STRB    LR, [R2, #FlpDCBphase]  ; Update command phase
        TSTS    R0, #MiscOp_PollChanged_Ready_Flag          ; Drive ready?
        Pull    "R0,R1,LR"
        MOVEQ   PC, LR                  ; No then wait exit


; Process index pulse message, R2->DCB
20
        Push    "R0,R1,LR"
        LDRB    R0, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    R0, #FlpPhaseDrv        ; Phase is awaiting drive ready?
        Pull    "R0,R1,PC",NE           ; No then exit

; Ensure '765 FDC has completed reset

        SETPSR  I_bit,LR                ; Disable IRQ's
        baddr   R0, FlpStateReset       ; Reset state address
        LDR     LR, FlpState            ; Get current FDC state
        TEQS    LR, R0                  ; Currently reset?
        MOVEQ   LR, #FlpPhaseReset      ; Yes then awaiting reset
        STREQB  LR, [R2, #FlpDCBphase]  ;   and update phase
        Pull    "R0,R1,PC",EQ           ;   and wait

; Attempt to reset disk changed signal by step pulse

        MOV     LR, #FlpCCR500K
        STRB    LR, [R2, #FlpDCBselect] ; Use 500K clock
        MOV     LR, #FlpPhaseSeek       ; Next phase is waiting for seek done
        STRB    LR, [R2, #FlpDCBphase]  ; Update command phase
        MOV     LR, #FlpDCBread
        STR     LR, [R2, #FlpDCBlength] ; Read mode - no settling

        MOV     LR, #1
25      STRB    LR, [R2, #FlpDCBtrack]  ; Request track 1
        MOV     R1, R2                  ; Get->DCB
        MOV     R0, #FlpEventSeek
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpState            ; Call state system (R0,R1->V)
        BLVS    FlpGetDrvStatus         ; If error terminate DCB (R0,R1->)
        Pull    "R0,R1,PC",VS           ;   and return

        TEQS    R0, #0                  ; Seek in progress
        Pull    "R0,R1,LR"
        MOVNE   PC, LR                  ; Yes then exit


; Process seek done message, R2->DCB
30
        Push    "R0,R1,LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
        TEQS    LR, #FlpPhaseSeek       ; Phase is awaiting seek done?
        Pull    "R0,R1,PC",NE

        LDRB    LR, [R2, #FlpDCBtrack]  ; Get track
        TEQS    LR, #0                  ; On track 0
        MOVNE   LR, #0
        BNE     %BT25                   ; No then seek track 0

        LDRB    R0, [R2, #FlpDCBcdb+1]
        AND     R0, R0, #3              ; Get drive number
        DrvRecPtr R1, R0                ; R1-> drive record
        BL      FlpGetDskChng           ; Read disk changed status (->R0)
        TSTS    R0, #FlpDIRchanged      ; Disk still changed from drive?
        LDR     R0, [R1, #DrvFlags]     ; Get drive flags
        BNE     %FT35                   ; Yes then jump

 [ Debug10
        DLINE   "DskChng Reset"
 ]
        BIC     R0, R0, #MiscOp_PollChanged_MaybeChanged_Flag+MiscOp_PollChanged_NotChanged_Flag+MiscOp_PollChanged_Empty_Flag+MiscOp_PollChanged_Ready_Flag
        ORR     R0, R0, #MiscOp_PollChanged_ChangedWorks_Flag+MiscOp_PollChanged_Changed_Flag ; Show changed works
        STR     R0, [R1, #DrvFlags]     ; Update drive flags
        BL      FlpGetDrvStatus         ; Get drive status

        MOV     LR, #PositionUnknown
        STR     LR, [R1, #HeadPosition] ; Force restore
        Pull    "R0,R1,PC"              ; Exit

; Can't reset disk changed
35
 [ {TRUE}
; Report empty whenever disk changed won't clear

        BIC     R0, R0, #MiscOp_PollChanged_NotChanged_Flag+MiscOp_PollChanged_Changed_Flag+MiscOp_PollChanged_MaybeChanged_Flag ; Reset not changed
        ORR     R0, R0, #MiscOp_PollChanged_Empty_Flag      ; Set drive empty
        STR     R0, [R1, #DrvFlags]     ; And update drive flags
 |
; Report empty only when disk changed works but won't clear

        TSTS    R0, #MiscOp_PollChanged_ChangedWorks_Flag   ; Does change work?
        BICNE   R0, R0, #MiscOp_PollChanged_NotChanged_Flag+MiscOp_PollChanged_Changed_Flag ; Yes reset not changed
        ORRNE   R0, R0, #MiscOp_PollChanged_Empty_Flag      ; And set drive empty
        STRNE   R0, [R1, #DrvFlags]     ; And update drive flags
 ]

 [ Debug10
        TSTS    R0, #MiscOp_PollChanged_Empty_Flag
        BEQ     %FT40
        DLINE   "DskChng not reset, drive empty"
40
 ]
        BL      FlpGetDrvStatus         ; Get drive status
        Pull    "R0,R1,PC"              ; And exit


; Process reset OK message
80
        Push    "LR"
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
        CMPS    LR, #FlpPhaseReset      ; Phase is awaiting reset?
        Pull    "PC",NE                 ; No then exit

        MOV     LR, #FlpPhaseDrv        ; Yes, now awaiting drive ready
        STRB    LR, [R2, #FlpDCBphase]  ; Update command phase
        Pull    "LR"
        B       %BT20                   ; And retry


;-----------------------------------------------------------------------;
; FlpGetDrvStatus                                                       ;
;       Issue Sense Drive Interrupt command and read results            ;
;                                                                       ;
; Input:                                                                ;
;       R2 -> DCB                                                       ;
;       R12 = SB                                                        ;
;                                                                       ;
; Output:                                                               ;
;       None                                                            ;
;                                                                       ;
; Modifies:                                                             ;
;       None, preserves flags                                           ;
;_______________________________________________________________________;
;
FlpGetDrvStatus ROUT                    ; Get drives status
        Push    "R0,R1,R6,LR"
        SavePSR R6
        ADD     R1, R2, #FlpDCBcdb      ; R1-> command block
        MOV     R0, #2                  ; 2 bytes
        BL      Flp765BlkWr             ; Issue command (R0,R1->V)
        MOVVS   R0, #&FF
        BLVC    Flp765read              ; Get result byte (->R0)
        STRB    R0, [R2, #FlpDCBresults] ; And return results

; Get drive density

        BL      FlpMediaID              ; Get MediaID (->R0)
        LDRB    LR, [R2, #FlpDCBcdb+1]
        AND     LR, LR, #3              ; Get drive number
        DrvRecPtr R1, LR                ; R1-> drive record
        LDR     LR, [R1, #DrvFlags]     ; Get drive flags
        TSTS    R0, #FlpHiDensity       ; Hi density?
        ORRNE   LR, LR, #MiscOp_PollChanged_HiDensity_Flag  ; Yes set hi density bit
        BICEQ   LR, LR, #MiscOp_PollChanged_HiDensity_Flag  ; Else reset hi density bit
        ORREQ   LR, LR, #MiscOp_PollChanged_DensityWorks_Flag ; And show density works
        LDR     R0, [R2, #FlpDCBresults+4] ; Get drive state on entry
        STR     LR, [R2, #FlpDCBresults+4] ; Return them

; Get disk changed state

        TSTS    LR, #MiscOp_PollChanged_MaybeChanged_Flag+MiscOp_PollChanged_Changed_Flag ; Maybe/is changed?
        BICNE   LR, LR, #MiscOp_PollChanged_MaybeChanged_Flag+MiscOp_PollChanged_Changed_Flag ; Yes then reset is/maybe
        ORRNE   LR, LR, #MiscOp_PollChanged_NotChanged_Flag ;   and set not changed
        STR     LR, [R1, #DrvFlags]     ; Update drive flags

; Restore drive state

 [ Debug10
        DREG    R0,"Drive state was:"
 ]
        AND     R0, R0, #MiscOp_PollChanged_Ready_Flag+MiscOp_PollChanged_Empty_Flag
        TEQS    R0, #MiscOp_PollChanged_Ready_Flag          ; Was drive ready?
        BEQ     %FT10                   ; Yes then jump, leave drive on

        ANDS    R1, LR, #MiscOp_PollChanged_Ready_Flag+MiscOp_PollChanged_Empty_Flag ; Drive now not ready nor empty?
        TEQNES  R1, #MiscOp_PollChanged_Ready_Flag+MiscOp_PollChanged_Empty_Flag ; Or changed not reset?
        BNE     %FT05                   ; No then jump

; Turn off drives that are neither ready nor empty or won't reset changed

        MOV     R1, #-1                 ; Turn drives off now
        MOV     R0, #FlpEventDrvSel     ; Drive select event
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpDrive            ; Call drive state system (R0,R1->R0)
        B       %FT10

; Set timeout for drive off for empty or ready drives

05      TSTS    LR, #MiscOp_PollChanged_Ready_Flag          ; Is drive ready?
        MOVNE   LR, #1
        STRNEB  LR, FlpDriveIP          ; Yes, then turn off in 1 rev
        MOVEQ   LR, #5                  ; Else set small timeout
        STREQB  LR, FlpMotorTimer       ; To turn motors off

10      MOV     R0, #0                  ; No error
        BL      FlpDqDCB                ; Terminate DCB (R0,R2->)
        RestPSR R6,,f
        Pull    "R0,R1,R6,PC"           ; And exit


;-----------------------------------------------------------------------;
; FlpHandlerImm                                                         ;
;       Handle messages for immediate type FDC commands                 ;
;                                                                       ;
; Input:                                                                ;
;       R0 = Message                                                    ;
;       R1 = Parameter                                                  ;
;       R12 = SB                                                        ;
;                                                                       ;
; Output:                                                               ;
;       None                                                            ;
;                                                                       ;
; Modifies:                                                             ;
;       None                                                            ;
;_______________________________________________________________________;
;
FlpHandlerImm   ROUT
        CMPS    R0, #FlpMsgStart        ; Initialise?
        BEQ     %FT10                   ; Yes then jump
        CMPS    R0, #FlpMsgError        ; Error?
        MOVNE   PC, LR                  ; No then return

; Handle error message, R1= error code

        Push    "R0,R1,LR"
        MOV     R0, R1                  ; Get error code
        BL      FlpDqDCB                ; Terminate DCB (R0,R2->)
        Pull    "R0,R1,PC"

; Process initialization message, R2->DCB
10
        Push    "R0,R1,LR"
 [ Debug10
        DLINE   "FlpHandlerNoIRQ: Iniz"
 ]
        MOV     R0, #FlpEventCmd        ; Command request
        MOV     R1, R2                  ; R1->DCB
        MOV     LR, PC                  ; Setup return link
        LDR     PC, FlpState            ; Call state system (R0,R1->V)

; Return command completion status

        MOVVS   R0, #BadComErr          ; Return bad command if error in FDC
        MOVVC   R0, #0                  ; Else return good command
        BL      FlpDqDCB                ; Terminate DCB (R0,R2->)
        Pull    "R0,R1,PC"              ; Restore regs and return


;-----------------------------------------------------------------------;
; FlpAddDCB                                                             ;
;       Add a DCB to the active queue                                   ;
;                                                                       ;
; Input:                                                                ;
;       R1 -> DCB                                                       ;
;       R12 = SB                                                        ;
;                                                                       ;
; Output:                                                               ;
;       R0 = 0, VC, No error                                            ;
;          = Error code, VS                                             ;
;                                                                       ;
; Modifies:                                                             ;
;       None                                                            ;
;_______________________________________________________________________;
;
; '765 command type lookup table
;
FlpMsgTable
        DCD     0                       ; &00, Illegal
        DCD     0                       ; &01, Illegal
        DCD     FlpHandlerData-org      ; &02, Read track
        DCD     FlpHandlerImm-org       ; &03, Specify
        DCD     FlpHandlerDrv-org       ; &04, Sense drive status
        DCD     FlpHandlerData-org      ; &05, Write sectors
        DCD     FlpHandlerData-org      ; &06, Read sectors
        DCD     FlpHandlerSeek-org      ; &07, Recalibrate
        DCD     FlpHandlerImm-org       ; &08, Sense interrupt status
        DCD     FlpHandlerData-org      ; &09, Write deleted data
        DCD     FlpHandlerReadID-org    ; &0A, Read sector ID
        DCD     0                       ; &0B, Illegal
        DCD     FlpHandlerData-org      ; &0C, Read deleted data
        DCD     FlpHandlerData-org      ; &0D, Format track
        DCD     FlpHandlerImm-org       ; &0E, Dump registers (665)
        DCD     FlpHandlerSeek-org      ; &0F, Seek
        DCD     FlpHandlerImm-org       ; &10, Version
        DCD     FlpHandlerData-org      ; &11, Scan equal
        DCD     FlpHandlerImm-org       ; &12, Perpendicular mode (665)
        DCD     FlpHandlerImm-org       ; &13, Configure (665)
        DCD     FlpHandlerImm-org       ; &14, Lock (665)
        DCD     0                       ; &15, Illegal
        DCD     FlpHandlerData-org      ; &16, Verify sectors (665)
        DCD     FlpHandlerImm-org       ; &17, Powerdown mode (665)
        DCD     0                       ; &18, Illegal
        DCD     FlpHandlerData-org      ; &19, Scan low or equal
        DCD     0                       ; &1A, Illegal
        DCD     0                       ; &1B, Illegal
        DCD     0                       ; &1C, Illegal
        DCD     FlpHandlerData-org      ; &1D, Scan high or equal
        DCD     0                       ; &1E, Illegal
        DCD     0                       ; &1F, Illegal
        ALIGN

FlpAddDCB       ROUT
        Push    "R2,LR"

; Lookup type of command

        LDRB    LR, [R1, #FlpDCBcdb]    ; Get command code
 [ Debug10
        DREG    LR, "Add DCB with command "
 ]
        BIC     LR, LR, #FlpCmdMT + FlpCmdFM + FlpCmdSK ; Ignore option bits
        MOV     LR, LR, LSL #2          ; Word entries
        baddr   R2, FlpMsgTable         ; R2-> lookup table
        LDR     R2, [R2, LR]            ; Get address
        CMPS    R2, #0                  ; Unsupported command type?
        MOVEQ   R0, #BadParmsErr        ; Yes, then bad parameters
        MOVNE   R0, #FlpDCBpending      ; Else set pending status
        STR     R0, [R1, #FlpDCBstatus] ; Write status to DCB
        BNE     %FT05
        SETV
        Pull    "R2,PC"                 ; Restore regs and return with error
05

 [ Debug10
        DLINE   "Command vetted OK"
 ]

; Get address of message handler for command type found

        baddr   R0, org                 ; Base address of module
        ADD     R2, R2, R0              ; Relocate handler entry
        STR     R2, [R1, #FlpDCBhandler] ; Set message handler for new DCB

; Initialise reserved data areas

        MOV     LR, #0
        STR     LR, [R1, #FlpDCBlink]   ; Mark new end of chain
        MOV     LR, #FlpPhaseIdle
        STRB    LR, [R1, #FlpDCBphase]  ; Set current DCB phase to idle

; Find end of current DCB chain

        sbaddr  R0, FlpDCBqueue         ; Get start of chain
10      LDR     LR, [R0]                ; Get pointer to next DCB
        CMPS    LR, #0                  ; At end of queue?
        ADDNE   R0, LR, #FlpDCBlink     ; NO, get address of ptr to next DCB
        BNE     %BT10                   ; Loop until reached end of queue

        STR     R1, [R0]                ; Add new DCB to end of chain

 [ Debug10
        DLINE   "Command added to command chain OK"
 ]

; Send "start processing" message to top of queue DCB

        MOV     R0, #FlpMsgStart
 [ Debug10s :LAND: {FALSE}
        DLINE   " Add ",cc
 ]
        BL      FlpMessage              ; Send start process message
 [ Debug10
        DLINE   "Command started"
 ]

        MOV     R0, #0                  ; No error
        CLRV
        Pull    "R2,PC"                 ; Return, no error


;-----------------------------------------------------------------------;
; FlpDqDCB                                                              ;
;       DeQueue a DCB                                                   ;
;                                                                       ;
; Input:                                                                ;
;       R0 = Final return code                                          ;
;       R2 -> DCB to remove                                             ;
;       R12 = SB                                                        ;
;                                                                       ;
; Output:                                                               ;
;       None                                                            ;
;                                                                       ;
; Modifies:                                                             ;
;       None, preserves flags                                           ;
;_______________________________________________________________________;
;
FlpDqDCB        ROUT
        Push    "R0,R1,R4,LR"
        SavePSR R4
        LDR     R1, FlpDCBqueue         ; Get top of chain
        TEQS    R1, #0                  ; Any DCB's queued?
        BNE     %FT00
        RestPSR R4,,f
        Pull    "R0,R1,R4,PC"           ; No then exit
00
; Unlock the drive

        LDRB    LR, FlpDriveLock        ; Get lock state
        BIC     LR, LR, #bit0+bit2      ; Clear command lock bit & empty
        STRB    LR, FlpDriveLock        ; Update command lock state

; Remove DCB at top of queue

        LDR     LR, [R1, #FlpDCBlink]   ; Get pointer to second DCB in queue
        STR     LR, FlpDCBqueue         ; Remove top of queue
        STR     R0, [R1, #FlpDCBstatus] ; Set final status

        ;Check whether R0=DriveEmptyErr
        CMP     R0, #DriveEmptyErr
        BNE     %FT01
        ;If so, check whether it should be NoFloppy error, and change if so
        SWI     XPortable_Status
        BVS     %FT01
        TST     R0, #PortableStatus_PrinterFloppy
        BNE     %FT01
        ADRL    R0, NoFloppyErrBlk
        BL      copy_error              ;Convert the token into an error string
 [ :LNOT:NewErrors
        ORR     R0, R0, #ExternalErrorBit
 ]
        STR     R0, [R1, #FlpDCBstatus] ; Set final status (again!)

; Restore MEMC state if it has been changed

01      LDR     R0, FlpMEMCstate
        TEQS    R0, #0                  ; MEMC state saved?
 [ Debug10v
        BEQ     %FT01
        DLINE   "Re-enabling video DMA"
01
 ]

        BEQ     %FT05
        Push    "r1"
        WritePSRc SVC_mode + I_bit,lr,,r1
        NOP
        Push    "r1,lr"
        MOV     r1, #0
        STR     r1, FlpMEMCstate
        MOV     r1, #MEMC_DMA_bits
        BIC     r0, r0, #bit31
        SWI     XOS_UpdateMEMC
        Pull    "r1,lr"
        RestPSR r1
        Pull    "r1"
05

; Call post routine for DCB removed

        LDR     LR, [R1, #FlpDCBpost]   ; Get post routine address
        TEQS    LR, #0                  ; Valid?
        BEQ     %FT10                   ; No then jump

        Push    "SB"
        LDR     R0, [R1, #FlpDCBstatus] ; Get completionstatus
        LDR     SB, [R1, #FlpDCBsb]     ; Yes, then set SB for post routine
        MOV     LR, PC                  ;   Set return address
        LDR     PC, [R1, #FlpDCBpost]   ;   Call post routine (R0,R1,SB->)
        Pull    "SB"

; Send "start processing" message to new top of DCB queue

10      MOV     R0, #FlpMsgStart
 [ Debug10s :LAND: {FALSE}
        DLINE   " Dq ",cc
 ]
        BL      FlpMessage              ; Send start process message
        RestPSR R4,,f
        Pull    "R0,R1,R4,PC"


        LTORG

        END
@


4.11
log
@Minor typo correction
Retagged as ADFS-3_46.
@
text
@d1268 1
a1269 1
        NOP
d3699 1
@


4.10
log
@Reinstate floppies on IOMD platform
ADFS.s:
  Remove redundant header file.
Adfs05.s/Adfs15.s:
  Group the options a bit more simply, use {TRUE} and {FALSE}.
Adfs12.s/BusMaster.s/IDEDetect.s:
  Use defines instead of magic numbers.
Adfs17.s:
  Organise the offsets from the floppy controller to cover both PCI and IO based controllers.
  Only do the dummy read from the PBI on Tungsten.
Adfs18.s:
  Implement the FIQ equivalent of the 'FlpUseVerify' command switch, modern controllers (!) have a built in verify rather than using a sector read, but the verify command has no data phase and the FIQ handler was sitting waiting for a sector that never arrives.
  Rationalise FlpDRQmask and FlpDRQmaskbit.
Adfs19:
  Rationalise the calls to OS_Hardware by rejigging the assembly time switches.
  Reinstate the non HAL version of IRQ enable for reference.
  On RPCEmu 0.8.8 and 0.8.9 the emulator hangs during the four set of DCB's used to autodetect the drive (Recalibrate/Seek/Seek/Sense) which seems to be due to the way the emulator splits CPU time to floppy emulation time, to avoid this we wait 128us (real time) which is enough emulated time for the controller to have changed state. You probably just want to *CONFIGURE FLOPPIES 0 though.

Tested om A7000, ARM610, StrongARM manipulating a veriety of disc densities for read and write. Also ran the "Test/TestADFS" test program.
RPCEmu 0.8.8 and 0.8.9 boots still, but no attempt has been made to use emulated floppies.

Version 3.46. Tagged as 'ADFS-3_46'
@
text
@d1398 1
a1398 1
        MOV     LR, #1:SHL:FlpDRQmask   ; DRQ FIQ mask
@


4.9
log
@Tabs expanded
Assembler source uses spaces round here in general, follow suit.
Not tagged.
@
text
@a54 3
        GBLL    FlpMediaCheck
FlpMediaCheck   SETL    {FALSE} ; T to check density from disc/drive

a203 5
; Dummy read for 80321 PBI, which is accessed through PCI, and needs
; a read to flush out writes
        GBLL    DummyReadFudge
DummyReadFudge  SETL FloppyPodule

d281 5
d290 1
d679 1
a679 1
 [ DummyReadFudge
d681 1
a681 1
 ]
d690 1
a690 1
 [ DummyReadFudge
d692 1
a692 1
 ]
d764 1
a764 1
 [ DummyReadFudge
d766 1
a766 1
 ]
d783 1
a783 1
 [ DummyReadFudge
d785 1
a785 1
 ]
d844 1
a844 1
 [ DummyReadFudge
d846 1
a846 1
 ]
d1058 1
a1058 1
 [ HAL
d1064 1
a1064 1
  [ FloppyPodule
d1069 2
a1070 2
  ]
 |
d1074 1
a1074 1
 ]
d1397 2
a1398 2
        MOV     R1, #IOC                ; R0-> IOC base address
        MOV     LR, #FlpDRQmask         ; DRQ FIQ mask
d2013 3
d2021 1
@


4.8
log
@Tidy up pass
ADFS.s:
  Redundant header files trimmed
  Get OsWords and OsBytes
  Switches rationalised
ADFS_SA.a
  Removed ARM810 support
Adfs00.s:
  Unused MEMC flag removed
Adfs05.s/Adfs12.s/Adfs13.s/Adfs14.s/Adfs15.s/Adfs19.s:
  Use defines instead of magic numbers
  Make use of FileCore exported bit fields
Adfs17.s/Adfs18.s/ConstIDE:
  {TRUE} and {FALSE} used with objasm
Adfs20.s
  Use AND of the opmask instead of BIC of all the flags except the opmask
Adfs50.s
  Unused MEMC flag no longer initialised
  Make use of FileCore exported bit fields
  Service call table reordered so the Ursula despatch doesn't incur a branch
  OsByte defines used
Consts:
  Removed those definitions now duplicating FileCore's exports
DebugOpts/Fixes:
  All options brought under one roof
ModHeader:
  Now uses VersionNum directly
Ver/*:
  Redundant switches deleted
  Removed used of 'Version' header


Version 3.45. Tagged as 'ADFS-3_45'
@
text
@d1599 1
a1599 1
	ORR	R0, R0, #ExternalErrorBit
d3669 3
a3671 3
	;Check whether R0=DriveEmptyErr
	CMP	R0, #DriveEmptyErr
	BNE	%FT01
d3673 1
a3673 1
	SWI	XPortable_Status
d3675 4
a3678 4
	TST     R0, #PortableStatus_PrinterFloppy
	BNE	%FT01
	ADRL	R0, NoFloppyErrBlk
	BL	copy_error		;Convert the token into an error string
d3680 1
a3680 1
	ORR	R0, R0, #ExternalErrorBit
d3682 1
a3682 1
        STR	R0, [R1, #FlpDCBstatus] ; Set final status (again!)
@


4.7
log
@Update to use some of the exported FileCore headers.
There are still a large number of local copies that should be visited, but this change at least allows it to assemble again FileCore-3_45.
Tungsten and IOMD variants assemble, but others untested.

Version 3.41. Tagged as 'ADFS-3_41'
@
text
@d56 1
a56 1
FlpMediaCheck   SETL    F       ; T to check density from disc/drive
d2867 1
a2867 1
 [ F    ; LA trigger for debugging IDE interaction
d3123 1
a3123 1
 [ F
d3343 1
a3343 1
 [ T
@


4.6
log
@  Reintroduced support for IOMD machines
Detail:
  There was no "Ver" file for Machine=32, and the code for build switch
  settings appropriate for IOMD had not been kept up-to-date with various
  changes to the module which were made to support Tungsten. This version
  provides working IDE support for IOMD HAL builds, although there are
  still some issues with floppy support. Tungsten builds should be
  functionally identical.
Admin:
  Tested on a Risc PC. Joint development effort by Tom Walker and Ben Avison.

Version 3.37. Tagged as 'ADFS-3_37'
@
text
@d1104 1
a1104 1
        TSTS    R0, #Drv_Empty+Drv_Ready ; Drive empty or ready?
d1109 1
a1109 1
15      TSTS    R0, #Drv_Empty          ; Drive empty?
d1805 1
a1805 1
        TSTS    R0, #Drv_40Track        ; 40 track?
d2735 1
a2735 1
        TSTS    R0, #Drv_Empty+Drv_Ready ; Drive empty or ready?
d2738 1
a2738 1
        TSTS    R0, #Drv_Empty          ; Drive empty?
d3040 1
a3040 1
        TSTS    R0, #Drv_Empty+Drv_Ready ; Drive empty or ready?
d3043 1
a3043 1
        TSTS    R0, #Drv_Empty          ; Drive empty?
d3238 1
a3238 1
        TSTS    R0, #Drv_Ready          ; Drive ready?
d3240 1
a3240 1
        TSTS    R0, #Drv_Empty          ; Drive empty?
d3264 1
a3264 1
        TSTS    R0, #Drv_Ready          ; Drive ready?
d3332 2
a3333 2
        BIC     R0, R0, #Drv_MaybeChanged+Drv_NotChanged+Drv_Empty+Drv_Ready
        ORR     R0, R0, #Drv_ChangedWorks+Drv_Changed ; Show changed works
d3346 2
a3347 2
        BIC     R0, R0, #Drv_NotChanged+Drv_Changed+Drv_MaybeChanged ; Reset not changed
        ORR     R0, R0, #Drv_Empty      ; Set drive empty
d3352 3
a3354 3
        TSTS    R0, #Drv_ChangedWorks   ; Does change work?
        BICNE   R0, R0, #Drv_NotChanged+Drv_Changed ; Yes reset not changed
        ORRNE   R0, R0, #Drv_Empty      ; And set drive empty
d3359 1
a3359 1
        TSTS    R0, #Drv_Empty
d3414 3
a3416 3
        ORRNE   LR, LR, #Drv_HiDensity  ; Yes set hi density bit
        BICEQ   LR, LR, #Drv_HiDensity  ; Else reset hi density bit
        ORREQ   LR, LR, #Drv_DensityWorks ; And show density works
d3422 3
a3424 3
        TSTS    LR, #Drv_MaybeChanged+Drv_Changed ; Maybe/is changed?
        BICNE   LR, LR, #Drv_MaybeChanged+Drv_Changed ; Yes then reset is/maybe
        ORRNE   LR, LR, #Drv_NotChanged ;   and set not changed
d3432 2
a3433 2
        AND     R0, R0, #Drv_Ready+Drv_Empty
        TEQS    R0, #Drv_Ready          ; Was drive ready?
d3436 2
a3437 2
        ANDS    R1, LR, #Drv_Ready+Drv_Empty ; Drive now not ready nor empty?
        TEQNES  R1, #Drv_Ready+Drv_Empty ; Or changed not reset?
d3450 1
a3450 1
05      TSTS    LR, #Drv_Ready          ; Is drive ready?
@


4.5
log
@* ADFS_DiscOp64 and ADFS_ATAPIOp added.
* New FileCore error passing scheme supported.
* PCI floppy support functional.
* 48-bit LBA support added for ADFS_IDEUserOp and accessing beyond the
  first 128GB of a drive - not thoroughly tested.
* IDE autodetection improved

Version 3.34. Tagged as 'ADFS-3_34'
@
text
@a1473 1
   [ FloppyPodule
d1475 1
a1475 1
        MOV     R0, #0
d1480 1
a1484 2
   |
        ! 1, "Don't know about FIQs for HAL, non-Podule"
d1693 1
d1695 1
@


4.4
log
@32-bit conversion started, Tungsten hard disc support added.
Hard disc functional, but PIO mode only. Don't go near the floppy.

Version 3.33. Not tagged
@
text
@d94 6
d130 3
d134 1
d139 6
d207 30
d681 3
d692 3
d766 3
d785 3
d846 3
d994 1
d1018 7
d1053 3
a1055 1
        BLNE    Flp765reset             ; No then reset FDC
d1057 17
a1073 1
        MOVNE   LR, #IOC                ; R0-> IOC base address
d1075 3
a1077 1
        STRNEB  LR, [LR, #IOCFIQMSK]    ; Disable Data ReQuest FIQs
d1079 1
a1079 1
        MOV     LR, #0
d1214 1
d1219 1
a1219 1
        TST     R0, #bit30
d1222 1
a1222 1
        TST     R0, #bit31
d1228 1
a1228 1
        TST     R0, #bit31
d1330 2
d1337 1
a1337 1
        LDR     R13, FlpDACK_TC         ; R13-> DMA data reg with TC
d1341 2
a1342 2
        LDR     R12, [R2, #FlpDCBlength]; R12 = DCBlenght (inc flags)
        TST     R12, #bit30
d1349 1
a1349 1
        TST     R12, #bit31
d1351 1
a1351 1
        BIC     R12, R12, #bit30 :OR: bit31     ; r12 set
d1364 1
a1364 1
        BIC     R10, R12, #bit30 :OR: bit31
d1368 1
a1368 1
        TST     R12, #bit31
d1374 2
a1375 2
        TST     R12, #bit31
        BIC     R12, R12, #bit29 :OR: bit30 :OR: bit31
d1398 1
d1402 61
d1472 19
d1495 2
a1496 2
        AND     lr, lr, #bit30 :OR: bit31
        TEQ     lr, #bit30 :OR: bit31
d1535 5
d1549 2
a1550 2
        AND     lr, lr, #bit30 :OR: bit31
        TEQ     lr, #bit30 :OR: bit31
d1599 7
d1624 25
d1652 2
d1690 9
d1720 1
a1720 1
        MOVNE   R0, #DiscErrorBit       ; Yes, return FDC error
d1744 1
a1744 1
        MOVMI   R0, #DiscErrorBit       ; Error if retries exhausted
d1854 57
d2140 1
d2157 1
a2157 1
        TST     r0, #bit30
a2172 2
        LDRB    r1, [r2, #FlpDCBresults+5]      ; R
        STRB    r1, [r2, #FlpDCBcdb+4]
d2175 17
d2209 3
d2224 9
d2235 3
d2241 3
d2247 3
d2267 3
d2285 1
a2285 1
        BIC     r1, r1, #bit31 :OR: bit30
d2287 1
d2315 14
a2329 1
        TST     lr, #bit31
d2387 1
d2434 1
a2434 1
        DREG    r0, "Advance transfer by "
d2499 1
a2499 1

d2514 1
d2521 33
d2573 1
a2573 1
        BICNE   r1, r1, #bit31 :OR: bit30
d2586 56
d2665 12
d2725 1
a2725 2
        PHPSEI  ,r1                     ; Disable IRQ's
        Push    "lr"
d2736 1
a2736 1
        BEQ     %FT49                   ; No then restore regs and wait
d2739 4
a2742 4
        BEQ     %FT19
        MOV     R0, #DriveEmptyErr      ; Yes, drive empty error
        BL      FlpDqDCB                ;   then terminate DCB (R0,R2->)
        B       %FT49                   ;   then exit
a2743 1
19
d2746 5
a2750 3
        Pull    "lr"                    ; Restore IRQ state
        PLP
        Pull    "R0,R1,LR"
d2799 4
a2802 1
        BVS     FlpHandlerReadID_SeekFault
a2847 9
49
        Pull    "lr"
        PLP                             ; Restore IRQs
        Pull    "R0,R1,PC"              ; and return

FlpHandlerReadID_SeekFault
        MOV     R0, #FlpErrSeekFault    ; Return seek fault if error
        BL      FlpDqDCB                ;   and terminate DCB (R0,R1->)
        Pull    "R0,R1,PC"              ;   and return
d2922 1
a2922 1
        MOVMI   R0, #DiscErrorBit       ; Error if retries exhausted
d2975 12
d3024 1
a3024 2
        PHPSEI  ,r1                     ; Disable IRQ's
        Push    "lr"
d3037 2
a3038 1
        BEQ     %FT18                   ; Yes then jump
d3041 1
a3041 1
        BEQ     %FT28                   ; No then restore regs and wait
d3044 4
a3047 4
        BEQ     %FT18
        MOV     R0, #DriveEmptyErr      ; Yes, drive empty error
        BL      FlpDqDCB                ;   then terminate DCB (R0,R2->)
        B       %FT28                   ;   then exit
d3050 1
a3050 4
18
        Pull    "lr"
        PLP
        Pull    "R0,R1,LR"
d3063 1
a3063 2
        PHPSEI  ,r0                     ; Ensure IRQ's disabled
        Push    "lr"
d3069 2
a3070 1
        BEQ     %FT28                   ; Yes then wait
d3074 2
a3098 3
28
        Pull    "lr"
        PLP
d3141 1
a3141 1
        MOVMI   R0, #DiscErrorBit       ; Error if retries exhausted
a3148 3
        Push    "R0,R1,LR"
        PHPSEI  ,r0                     ; Ensure IRQ's disabled
        Push    "lr"
d3157 2
a3158 4
        Pull    "PC",NE                 ; No then exit
        Push    "R0,R1"
        PHPSEI  ,r0                     ; Ensure IRQ's disabled
        Push    "lr"
d3179 12
d3222 1
a3222 2
        PHPSEI  ,r1                     ; Disable IRQ's
        Push    "lr"
d3236 1
a3236 1
        BEQ     %FT28                   ;   And restore regs and exit
d3242 1
a3242 1
        BNE     %FT28                   ;  and exit
d3250 1
a3250 1
        BEQ     %FT28                   ;  and exit, not changed
d3265 2
a3266 2
        BEQ     %FT28                   ; No then wait exit
        B       %FT22
d3278 1
a3278 3
        PHPSEI  ,r0                     ; Disable IRQ's
        Push    "lr"
22
d3284 1
a3284 1
        BEQ     %FT28                   ;   and wait
d3292 1
a3292 1
        MOV     LR, #bit31
d3302 1
a3302 1
        BVS     %FT28                   ;   and return
d3305 3
a3307 10
        BEQ     %FT31                   ; No, then move to done
                                        ; Yes then exit
28
        Pull    "lr"
        PLP
        Pull    "R0,R1,PC"
31
        Pull    "lr"
        PLP
        B       %FT32
d3312 1
a3312 1
32      LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
d3397 2
a3398 3
        Push    "R0,R1,LR"
        SavePSR lr
        Push    "lr"
d3458 2
a3459 3
        Pull    "lr"
        RestPSR lr
        Pull    "R0,R1,PC"              ; And exit
d3543 1
a3543 1
        DCD     0                       ; &0E, Illegal
d3545 1
a3545 1
        DCD     FlpHandlerImm-org       ; &10, (Version)
d3547 3
a3549 3
        DCD     0                       ; &12, Illegal
        DCD     0                       ; &13, Illegal
        DCD     0                       ; &14, Illegal
d3551 2
a3552 2
        DCD     0                       ; &16, Illegal
        DCD     0                       ; &17, Illegal
d3645 1
a3645 1
;       None                                                            ;
d3649 2
a3650 1
        Push    "R0,R1,LR"
d3653 4
a3656 2
        Pull    "R0,R1,PC",EQ           ; No then exit

d3679 3
a3681 1
	ORR	R0, R0, #1<<30
d3728 2
a3729 1
        Pull    "R0,R1,PC"
@


4.3
log
@  Loading to/saving from top-bit-set addresses should now work.
Detail:
  The problem was in the API definition of the scatter lists used in
  background data transfer. These consist of a sequence of word pairs,
  holding addresses and lengths; any negative (ie top-bit-set) address word
  is defined to mean that the list continues at an location that is offset
  by that amount. To get around this, the check is now made not on whether
  the address word is negative, but on whether it is equal to or greater
  than (less negative than) &FFFF0000. This means that accesses to these
  addresses will still fail, but such addresses should be reserved for
  system use anyway.
Admin:
  Tested briefly.

Version 3.33. Tagged as 'ADFS-3_33'
@
text
@d15 1
a15 1
n;>Adfs18
d176 1
a176 1
;       None, preserves flags                                           ;
d185 1
a185 1
        Pull    "R2,PC",,^              ; Return
d246 1
a246 1
        ADDEQ   R13, R13, #FlpDACK_TC-FlpDACK
d298 1
a298 1
        ADDEQ   R13, R13, #FlpDACK_TC - FlpDACK
d306 1
a306 1
        ADDEQ   R13, R13, #FlpDACK_TC-FlpDACK
d376 1
a376 1
        ADDEQ   R13, R13, #FlpDACK_TC-FlpDACK
d392 1
a392 1
        ADDEQ   R13, R13, #FlpDACK_TC-FlpDACK
d466 1
a466 1
        ADDEQ   R13, R13, #FlpDACK_TC-FlpDACK
d636 1
a636 1
        ADDEQ   R13, R13, #FlpDACK_TC - FlpDACK
d644 1
a644 1
        ADDEQ   R13, R13, #FlpDACK_TC-FlpDACK
d715 1
a715 1
        ADDEQ   R13, R13, #FlpDACK_TC-FlpDACK
d731 1
a731 1
        ADDEQ   R13, R13, #FlpDACK_TC - FlpDACK
d791 1
a791 1
        ADDEQ   R13, R13, #FlpDACK_TC-FlpDACK
d969 1
a969 1
        MOVNES  PC, LR                  ; No then return
d977 1
a977 1
        MOVNES  PC, LR                  ; No then exit
d994 1
a994 1
        Pull    "R0,PC",,^
d998 1
a998 1
        Push    "R0,R1,LR"
d1001 1
a1001 1
        Pull    "R0,R1,PC",NE,^         ; No then exit
d1005 1
a1005 2
        ORR     LR, LR, #I_bit
        TEQP    LR, #0                  ; Disable IRQ's
d1016 17
a1032 11
        Pull    "R0,R1,PC",EQ,^         ; No then restore regs and wait

        TSTS    R0, #Drv_Empty          ; Drive empty?
        MOVNE   R0, #0                  ; Yes then no data transferred
        STRNE   R0, [R2, #FlpDCBlength] ; And update length
        MOVNE   R0, #DriveEmptyErr      ; And drive empty error
        BLNE    FlpDqDCB                ; And terminate DCB (R0,R2->)
        Pull    "R0,R1,LR"              ; Restore regs
        MOVNES  PC, LR                  ; And exit

        TEQP    LR, #0                  ; Restore IRQ's
d1042 1
a1042 1
        Pull    "R0,R1,PC",NE,^         ; No then exit
d1054 1
a1054 1
        Pull    "R0,R1,PC",EQ,^         ; Yes then wait
d1084 1
a1084 3
        MOVVS   R0, #FlpErrSeekFault    ; Return seek fault if error
        BLVS    FlpDqDCB                ;   and terminate DCB (R0,R1->)
        Pull    "R0,R1,PC",VS,^         ;   and return
d1091 1
a1091 1
        MOVNES  PC, LR                  ; Yes then exit
d1109 1
a1109 1
        MOVNES  PC, LR                  ; No then exit
d1174 1
a1174 1
        mrs     AL, r1, CPSR_all
d1177 1
a1177 1
        msr     AL, CPSR_all, r1
d1179 1
a1179 1
        msr     AL, CPSR_all, r1
d1194 1
a1194 1
        msr     AL, CPSR_all, r1
d1240 2
a1241 3
        MOV     R0, PC                  ; Save mode bits
        TEQP    PC, #I_bit + F_bit + FIQ_mode ; FIQ mode, FIQ/IRQ disabled
        nop                             ; delay for mode change
d1245 1
a1245 1
        LDR     R13, =FlpDACK_TC        ; R13-> DMA data reg with TC
d1270 1
a1270 1
        ADDNE   R13, R13, #FlpDACK - FlpDACK_TC ; r13 set
d1274 1
a1274 1
        ADDNE   R13, R13, #FlpDACK-FlpDACK_TC
d1310 9
a1318 3
        ORR     R0, R0, #I_bit          ; Ensure IRQ's disabled
        TEQP    R0, #0                  ; Restore CPU mode
        nop
d1362 1
a1362 2
        MOVVS   R0, #BadComErr          ; Return bad command if error in FDC
        BLVS    FlpDqDCB                ; Terminate DCB if error occurred
d1402 8
a1409 3
        Pull    "R0,R1,LR"              ; Restore regs
        BICVCS  PC, LR, #F_bit          ; Return and enable FIQs if OK
        MOVS    PC, LR                  ; Else just return
d1411 14
d1431 1
a1431 1
        Pull    "R0,R1,R3,PC",NE,^      ; No then execute
d1492 1
a1492 1
        Pull    "R0,R1,R3,PC",,^
d1545 1
a1545 2
        MOV     r0, pc
        TEQP    pc, #SVC_mode + I_bit
d1554 1
a1554 1
        TEQP    pc, r0
d1605 1
a1605 3
        MOVVS   R0, #FlpErrSeekFault    ; Return seek fault if error
        BLVS    FlpDqDCB                ;   and terminate DCB (R0,R1->)
        Pull    "R0,R1,R3,PC",VS,^      ;   and return
d1609 1
a1609 1
        MOVNES  PC, LR                  ; Yes then exit
d1612 4
d1622 1
a1622 1
        Pull    "PC",NE,^               ; No then exit
d1650 1
a1650 1
        ADD     R13, R13, #FlpDACK - FlpDACK_TC
d1656 1
a1656 1
        ADDNE   R13, R13, #FlpDACK-FlpDACK_TC
d1661 2
a1662 3
        MOV     r1, pc
        TEQP    pc, #I_bit :OR: SVC_mode
        nop
d1679 1
a1679 2
        TEQP    r1, #0
        nop
d1710 1
a1710 1
        ADD     R13, R13, #FlpDACK-FlpDACK_TC ; r13 now set
d1715 2
a1716 3
        MOV     r1, pc
        TEQP    pc, #I_bit :OR: SVC_mode
        nop
d1733 1
a1733 2
        TEQP    r1, #0
        nop
d1741 1
a1741 1
        ADD     R13, R13, #FlpDACK-FlpDACK_TC ; r13 now set
d1745 2
a1746 3
        MOV     r1, pc
        TEQP    pc, #I_bit :OR: SVC_mode
        nop
d1763 1
a1763 2
        TEQP    r1, #0
        nop
d1774 1
a1774 1
        ADD     R13, R13, #FlpDACK - FlpDACK_TC
d1779 1
a1779 1
        ADDNE   R13, R13, #FlpDACK-FlpDACK_TC
d1784 2
a1785 3
        MOV     r1, pc
        TEQP    pc, #I_bit :OR: SVC_mode
        nop
d1802 1
a1802 2
        TEQP    r1, #0
        nop
d1833 1
a1833 1
        ADD     R13, R13, #FlpDACK-FlpDACK_TC ; r13 now set
d1838 2
a1839 3
        MOV     r1, pc
        TEQP    pc, #I_bit :OR: SVC_mode
        nop
d1859 1
a1859 2
        TEQP    r1, #0
        nop
d1879 2
a1880 2
        BLEQ    FlpAdvanceNonScatterTransfer
        BEQ     %FT50
d1885 2
a1886 2
        BLEQ    FlpAdvanceForegroundTransfer
        BLNE    FlpAdvanceBackgroundTransfer
d1888 1
a1888 1
50
d1899 1
a1899 1
        Pull    "r0,pc",,^
d1915 1
a1915 3
        MOV     r3, pc
        TEQP    pc, #I_bit + F_bit + FIQ_mode
        nop
d1920 1
a1920 2
        TEQP    pc, r3
        nop
d1936 1
a1936 1
        Pull    "r0,r1,r3,pc",,^
d1952 1
a1952 3
        MOV     r3, pc
        TEQP    pc, #I_bit + F_bit + FIQ_mode
        nop
d1957 1
a1957 2
        TEQP    pc, r3
        nop
d1978 1
a1978 1
        Pull    "r0,r1,r3,pc",,^
d1999 1
a1999 3
        MOV     r1, pc
        TEQP    PC, #FIQ_mode :OR: I_bit :OR: F_bit
        NOP
d2001 1
a2001 1
        TEQP    PC, r1
d2037 1
a2037 1
        MOV     lr, pc
d2042 2
a2043 2
        MOV     lr, pc
        TST     lr, #I_bit
d2052 1
a2052 1
        TEQP    pc, lr
d2085 1
a2085 1
        Pull    "r0,r1,pc",,^
d2183 1
a2183 1
        Pull    "r0,r1,r3,r4,r5,pc",,^
d2207 1
a2207 1
        Pull    "r3,pc",NE,^
d2217 1
a2217 1
        Pull    "r3,pc",,^
d2238 1
a2238 1
;       None, preserves flags                                           ;
d2255 1
a2255 1
        MOVNES  PC, LR                  ; No then return
d2263 1
a2263 1
        MOVNES  PC, LR                  ; No then exit
d2278 1
a2278 1
        Pull    "R0,PC",,^
d2286 1
a2286 1
        Pull    "R0,R1,PC",NE,^         ; No then exit
d2290 2
a2291 2
        ORR     LR, LR, #I_bit
        TEQP    LR, #0                  ; Disable IRQ's
d2302 1
a2302 1
        Pull    "R0,R1,PC",EQ,^         ; No then restore regs and wait
d2305 4
a2308 4
        MOVNE   R0, #DriveEmptyErr      ; Yes, drive empty error
        BLNE     FlpDqDCB               ;   then terminate DCB (R0,R2->)
        Pull    "R0,R1,LR"
        MOVNES  PC, LR                  ;   then exit
d2310 1
d2313 3
a2315 1
        TEQP    LR, #0                  ; Restore IRQ state
d2331 1
a2331 1
        MOVNES  PC, LR                  ; No then exit
d2341 1
a2341 1
        Pull    "R0,R1,PC",EQ,^         ; Yes then wait
d2364 1
a2364 4

        MOVVS   R0, #FlpErrSeekFault    ; Return seek fault if error
        BLVS    FlpDqDCB                ;   and terminate DCB (R0,R1->)
        Pull    "R0,R1,PC",VS,^         ;   and return
d2368 1
a2368 1
        MOVNES  PC, LR                  ; Yes then exit
d2376 1
a2376 1
        Pull    "PC",NE,^               ;No then exit
d2385 1
a2385 1
        MOVNES  PC, LR                  ; No, exit - wait for IP
d2408 6
a2413 1
        Pull    "R0,R1,PC",,^           ; Restore regs
d2415 4
d2427 1
a2427 1
        Pull    "R0,R1,R3,PC",NE,^      ; No then exit
d2440 1
a2440 1
        LDREQ   LR, =FlpBase            ; FDC register base (&3F0 in PC/AT)
d2486 1
a2486 1
        Pull    "R0,R1,R3,PC",,^        ; And exit
d2510 1
a2510 1
        Pull    "PC",,^                 ; Exit
d2518 1
a2518 1
        Pull    "PC",NE,^               ; No then exit
d2555 1
a2555 1
        MOVNES  PC, LR                  ; No then return
d2563 1
a2563 1
        Pull    "R0,PC",EQ,^            ; Yes ignore it
d2571 1
a2571 1
        Pull    "R0,PC",,^
d2579 1
a2579 1
        Pull    "R0,R1,PC",NE,^         ; No then exit
d2583 2
a2584 2
        ORR     LR, LR, #I_bit
        TEQP    LR, #0                  ; Disable IRQ's
d2596 2
a2597 3
        TEQS    LR, #0                  ; Timeout's diasbled?
        Pull    "R0,R1,LR",EQ
        BEQ     %FT20                   ; Yes then jump
d2600 1
a2600 1
        Pull    "R0,R1,PC",EQ,^         ; No then restore regs and wait
d2603 4
a2606 4
        MOVNE   R0, #DriveEmptyErr      ; Yes, drive empty error
        BLNE     FlpDqDCB               ;   then terminate DCB (R0,R2->)
        Pull    "R0,R1,LR"
        MOVNES  PC, LR                  ;   then exit
d2609 4
a2612 1

d2620 1
a2620 1
        MOVNES  PC, LR                  ; No then exit
d2625 2
a2626 2
        ORR     LR, LR, #I_bit          ; Ensure IRQ's disabled
        TEQP    LR, #0
d2632 1
a2632 2
        Pull    "R0,R1,LR"
        MOVEQS  PC, LR                  ; Yes then wait
a2635 3
        Push    "R0,R1,LR"
        ORR     LR, LR, #I_bit          ; Ensure IRQ's disabled
        TEQP    LR, #0
d2659 4
a2662 1
        Pull    "R0,R1,PC",,^           ; Restore regs
d2670 1
a2670 1
        Pull    "R0,R1,R3,PC",NE,^      ; No then exit
d2697 1
a2697 1
        Pull    "R0,R1,R3,PC",,^
d2712 3
d2723 4
a2726 2
        Pull    "LR"
        MOVNES  PC, LR                  ; No then exit
d2756 1
a2756 1
        MOVNES  PC, LR                  ; No then return
d2761 1
a2761 1
        MOVNES  PC, LR                  ; No then exit
d2767 1
a2767 1
        MOVNES  PC, LR                  ; No then exit
d2776 1
a2776 1
        Pull    "R0,R1,PC",NE,^         ; No then exit
d2778 2
a2779 2
        ORR     LR, LR, #I_bit
        TEQP    LR, #0                  ; Disable IRQ's
d2793 1
a2793 1
        Pull    "R0,R1,PC",EQ,^         ;   And restore regs and exit
d2799 1
a2799 1
        Pull    "R0,R1,PC",NE,^         ;  and exit
d2807 1
a2807 1
        Pull    "R0,R1,PC",EQ,^         ;  and exit, not changed
d2822 2
a2823 2
        Pull    "R0,R1,LR"
        MOVEQS  PC, LR                  ; No then wait exit
d2831 1
a2831 1
        Pull    "R0,R1,PC",NE,^         ; No then exit
d2835 3
a2837 2
        ORR     LR, LR, #I_bit
        TEQP    LR, #0                  ; Disable IRQ's
d2843 1
a2843 1
        Pull    "R0,R1,PC",EQ,^         ;   and wait
d2861 1
a2861 1
        Pull    "R0,R1,PC",VS,^         ;   and return
d2864 10
a2873 3
        Pull    "R0,R1,LR"
        MOVNES  PC, LR                  ; Yes then exit

d2878 1
a2878 1
        LDRB    LR, [R2, #FlpDCBphase]  ; Get current phase
d2880 1
a2880 1
        Pull    "R0,R1,PC",NE,^
d2905 1
a2905 1
        Pull    "R0,R1,PC",,^           ; Exit
d2931 1
a2931 1
        Pull    "R0,R1,PC",,^           ; And exit
d2939 1
a2939 1
        Pull    "PC",NE,^               ; No then exit
d2964 2
d3025 3
a3027 1
        Pull    "R0,R1,PC",,^           ; And exit
d3043 1
a3043 1
;       None, preserves flags                                           ;
d3050 1
a3050 1
        MOVNES  PC, LR                  ; No then return
d3057 1
a3057 1
        Pull    "R0,R1,PC",,^
d3075 1
a3075 1
        Pull    "R0,R1,PC",,^           ; Restore regs and return
d3091 1
a3091 1
;       None, preserves flags except V                                  ;
d3148 4
a3151 2
        Pull    "R2,LR",EQ              ; Restore regs if error
        ORREQS  PC, LR, #V_bit          ;  and return with error
d3196 2
a3197 2
        Pull    "R2,LR"
        BICS    PC, LR, #V_bit          ; Return, no error
d3213 1
a3213 1
;       None, preserves flags                                           ;
d3220 1
a3220 1
        Pull    "R0,R1,PC",EQ,^         ; No then exit
d3259 1
a3259 3
        MOV     r1, pc
        TEQP    pc, #SVC_mode + I_bit
        NOP
d3267 1
a3267 2
        TEQP    pc, r1
        NOP
d3291 1
a3291 1
        Pull    "R0,R1,PC",,^
@


4.2
log
@Taken from RiscOS 3.70
@
text
@d522 6
d532 1
d542 4
d548 1
d557 4
d563 1
d849 6
d859 1
d870 4
d876 1
d886 4
d892 1
d1331 5
d1339 1
d1381 5
d1389 1
d1671 4
d1677 1
d1800 4
d1806 1
d2061 5
d2069 1
d2162 4
d2168 1
@


4.1
log
@Initial revision
@
text
@d15 1
a15 1
;>Adfs18
d50 1
d53 1
a53 1
Adfs18Ed        * 09            ; Edition number
d70 2
a71 2
;       FlpDqDCB        - Terminate a DCB and de-queue it               ; 
;_______________________________________________________________________; 
d92 1
a92 1
FlpDCBparam     a4 8            ; Offset 2..9 variable, offset9= &FF for verify 
d126 1
a126 1
                        
d1191 9
d1462 1
a1462 1
             
d1941 1
a1941 1
 ] 
d2536 1
a2536 1
                 
d2688 1
a2688 1
        TEQP    LR, #0                  ; Disable IRQ's 
d2718 1
a2718 1
 [ Debug10 
d2745 1
a2745 1
        TEQP    LR, #0                  ; Disable IRQ's 
d3066 1
a3066 1
                
d3129 13
d3144 1
a3144 1
        LDR     R0, FlpMEMCstate
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d15 1
a15 1
n;>Adfs18
d69 2
a70 2
;       FlpDqDCB        - Terminate a DCB and de-queue it               ;
;_______________________________________________________________________;
d91 1
a91 1
FlpDCBparam     a4 8            ; Offset 2..9 variable, offset9= &FF for verify
d125 1
a125 1

d1452 1
a1452 1

d1931 1
a1931 1
 ]
d2526 1
a2526 1

d2678 1
a2678 1
        TEQP    LR, #0                  ; Disable IRQ's
d2708 1
a2708 1
 [ Debug10
d2735 1
a2735 1
        TEQP    LR, #0                  ; Disable IRQ's
d3056 1
a3056 1

a3118 13
	;Check whether R0=DriveEmptyErr
	CMP	R0, #DriveEmptyErr
	BNE	%FT01
        ;If so, check whether it should be NoFloppy error, and change if so
	SWI	XPortable_Status
        BVS     %FT01
	TST     R0, #PortableStatus_PrinterFloppy
	BNE	%FT01
	ADRL	R0, NoFloppyErrBlk
	BL	copy_error		;Convert the token into an error string
	ORR	R0, R0, #1<<30
        STR	R0, [R1, #FlpDCBstatus] ; Set final status (again!)

d3121 1
a3121 1
01      LDR     R0, FlpMEMCstate
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d15 1
a15 1
n;>Adfs18
d69 2
a70 2
;       FlpDqDCB        - Terminate a DCB and de-queue it               ;
;_______________________________________________________________________;
d91 1
a91 1
FlpDCBparam     a4 8            ; Offset 2..9 variable, offset9= &FF for verify
d125 1
a125 1

d1452 1
a1452 1

d1931 1
a1931 1
 ]
d2526 1
a2526 1

d2678 1
a2678 1
        TEQP    LR, #0                  ; Disable IRQ's
d2708 1
a2708 1
 [ Debug10
d2735 1
a2735 1
        TEQP    LR, #0                  ; Disable IRQ's
d3056 1
a3056 1

a3118 13
	;Check whether R0=DriveEmptyErr
	CMP	R0, #DriveEmptyErr
	BNE	%FT01
        ;If so, check whether it should be NoFloppy error, and change if so
	SWI	XPortable_Status
        BVS     %FT01
	TST     R0, #PortableStatus_PrinterFloppy
	BNE	%FT01
	ADRL	R0, NoFloppyErrBlk
	BL	copy_error		;Convert the token into an error string
	ORR	R0, R0, #1<<30
        STR	R0, [R1, #FlpDCBstatus] ; Set final status (again!)

d3121 1
a3121 1
01      LDR     R0, FlpMEMCstate
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d15 1
a15 1
n;>Adfs18
a49 1
; 10  27 Feb 96  MJS    StrongARM changes for modifying code            ;
d52 1
a52 1
Adfs18Ed        * 10            ; Edition number
d69 2
a70 2
;       FlpDqDCB        - Terminate a DCB and de-queue it               ;
;_______________________________________________________________________;
d91 1
a91 1
FlpDCBparam     a4 8            ; Offset 2..9 variable, offset9= &FF for verify
d125 1
a125 1

a1189 9
  [ StrongARM
        ;now that we have finished arsing about, synchronise with respect to modified code
        Push    "R0-R2,LR"
        MOV     R0,#FiqVector                 ;start virtual address
        MOV     R1,#FiqVectorMaxCode          ;worst case end virtual address (inclusive)
        BL      ADFSsync
        Pull    "R0-R2,LR"
  ]

d1452 1
a1452 1

d1931 1
a1931 1
 ]
d2526 1
a2526 1

d2678 1
a2678 1
        TEQP    LR, #0                  ; Disable IRQ's
d2708 1
a2708 1
 [ Debug10
d2735 1
a2735 1
        TEQP    LR, #0                  ; Disable IRQ's
d3056 1
a3056 1

a3118 13
	;Check whether R0=DriveEmptyErr
	CMP	R0, #DriveEmptyErr
	BNE	%FT01
        ;If so, check whether it should be NoFloppy error, and change if so
	SWI	XPortable_Status
        BVS     %FT01
	TST     R0, #PortableStatus_PrinterFloppy
	BNE	%FT01
	ADRL	R0, NoFloppyErrBlk
	BL	copy_error		;Convert the token into an error string
	ORR	R0, R0, #1<<30
        STR	R0, [R1, #FlpDCBstatus] ; Set final status (again!)

d3121 1
a3121 1
01      LDR     R0, FlpMEMCstate
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

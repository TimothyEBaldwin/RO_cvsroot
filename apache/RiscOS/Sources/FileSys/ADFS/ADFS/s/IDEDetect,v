head	4.9;
access;
symbols
	ADFS-3_54:4.9
	ADFS-3_53:4.9
	ADFS-3_52:4.9
	ADFS-3_51:4.9
	ADFS-3_50:4.8
	ADFS-3_49:4.7
	ADFS-3_48:4.7
	ADFS-3_47:4.6
	ADFS-3_46:4.6
	ADFS-3_45:4.4
	ADFS-3_44:4.4
	ADFS-3_43:4.4
	ADFS-3_42:4.4
	ADFS-3_41:4.4
	ADFS-3_40:4.4
	ADFS-3_39:4.4
	ADFS-3_38:4.4
	ADFS-3_37:4.4
	ADFS-3_36:4.3
	RO_5_07:4.3
	ADFS-3_35:4.3
	ADFS-3_34:4.2;
locks; strict;
comment	@# @;


4.9
date	2016.01.10.00.06.44;	author jlee;	state Exp;
branches;
next	4.8;
commitid	26rNliXrGuQCHjQy;

4.8
date	2016.01.05.21.49.10;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	els1sSTqH2Im4NPy;

4.7
date	2013.03.28.20.30.41;	author jlee;	state Exp;
branches;
next	4.6;
commitid	M0DGVV3z3qYjcBJw;

4.6
date	2012.10.21.16.27.51;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	ReyUVZewswdRVgpw;

4.5
date	2012.10.21.11.42.57;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	yOiiX7g8HT2Zlfpw;

4.4
date	2010.12.06.14.14.47;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2003.04.03.18.47.57;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2003.01.17.19.33.28;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	2002.09.18.15.03.30;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Preserve R12 across HAL device calls
Detail:
  s/Adfs12, s/IDEDetect - Ensure R12 is preserved over HAL device calls, the calling conventions allow the HAL to clobber it
Admin:
  Tested on Iyonix
  Fixes abort during ROM init


Version 3.51. Tagged as 'ADFS-3_51'
@
text
@; Copyright 2002 Tematic Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    IDE device detection code -> IDEDetect

;*********************************************************************

 [ AutoDetectIDE

MaxUDMAMode * 7


; ====================================================================

; ProbeIDEDevices

; the job of this routine is to locate all the IDE devices on an
; interface

ProbeIDEDevices ROUT
        Push    "R0-R3,R5-R9,IDECtrl,IDE, LR"

        MOV     R0, #WinIDENoDevice
        STRB    R0, WinIDEDeviceMappings+0
        STRB    R0, WinIDEDeviceMappings+1
      [ :LNOT: TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 2
      |
        ASSERT  WinIDEMaxDrives = 4
        STRB    R0, WinIDEDeviceMappings+2
        STRB    R0, WinIDEDeviceMappings+3
      ]

        SWI     XOS_ReadMonotonicTime
        BVS     %FT95
        MOV     R8, R0

        MOV     R6, #0  ; controller number (*2)

; we have to wait until the IDE controller becomes ready...

        BL      LockIDEController
        baddr   R0,DriverInUseErrBlk,VS ; if error, make R0 -> err block
        BVS     %FT95

; Reset both ATA buses simultaneously (to save having TWO lots of 31s timeouts)

        sbaddr  R9, WinIDEHardware
 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        ASSERT  WinIDEPtr = 4
        LDMIA   R9, {IDECtrl,IDE}
 |
        LDR     IDE, [R9, #WinIDEPtr]
 ]
 [ TwinIDEHardware
        ADD     R4, R9, #SzWinIDEHardware
 [ HAL
        ASSERT  :BASE:IDERegDevCtrl=IDECtrl
        LDR     R4, [R4, #WinIDECtrlPtr]
 |
        ASSERT  :BASE:IDERegDigOutput=IDE
        LDR     R4, [R4, #WinIDEPtr]    ; R5 = "IDE2"
 ]
 ]

        MOV     r0, #IDEDevCtrlSRST
        STRB    R0, IDERegDevCtrl       ; reset the drive
 [ TwinIDEHardware
        STRB    R0, [R4, #:INDEX:IDERegDevCtrl]
 ]

        MOV     r0, #5*2                ; keep SRST on for 5us
        BL      DoMicroDelay

        MOV     r0, #0
        STRB    r0, IDERegDevCtrl
 [ TwinIDEHardware
        STRB    R0, [R4, #:INDEX:IDERegDevCtrl]
 ]

        MOV     r0, #2048*2             ; wait 2ms
        BL      DoMicroDelay

 [ Debug23
        DLINE   "Done reset"
 ]

        BL      UnlockIDEController

; Now in HSR2:Check_status state (or HHR2:Check_status)
10
        sbaddr  R9, WinIDEHardware
        MOV     LR, #SzWinIDEHardware/2
        MLA     R9,R6,LR,R9
 [ Debug23
        DREG    R6,"R6=",cc,Integer
        DREG    R9," R9="
 ]
 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        ASSERT  WinIDEPtr = 4
        LDMIA   R9, {IDECtrl,IDE}
 |
        LDR     IDE, [R9, #WinIDEPtr]
 ]
        LDRB    LR, [R9, #WinIDEIRQDevNo]
        TEQ     LR, #0
        BEQ     %FT90

        BL      LockIDEController
        baddr   R0,DriverInUseErrBlk,VS ; if error, make R0 -> err block
        BVS     %FT95

15      LDRB    R0,IDERegAltStatus      ; get contents of alternate status register

        ; if BSY is set then round we go again (if no devices present, BSY is pulled
        ; low by a motherboard pull-down).

        TSTS    R0,#IDEStatusBSY
        BEQ     Probe_BusyReleased
        SWI     XOS_ReadMonotonicTime
        BVS     %FT19
        SUB     R0, R0, R8
        CMPS    R0, #3200
        BLO     %BT15

        ; BSY not released - something wrong

19
 [ Debug23
        DLINE   "BSY timeout"
 ]
        MOV     R4, #WinIDENoDevice
        MOV     R5, #WinIDENoDevice
        BL      UnlockIDEController
        B       %FT70

Probe_BusyReleased

        MOV     r0, #10*2       ; wait 10us for luck - found to help with a number
        BL      DoMicroDelay    ; of drives

; Now check signatures

        LDRB    R5, IDERegError
        TEQ     R5, #&01        ; device 0 passed/not present, device 1 pass/not present
        TEQNE   R5, #&81        ; device 0 passed/not present, device 1 failed
        MOVNE   R0, #WinIDENoDevice
        BLEQ    ReadSignature   ; (->R0)
        MOV     R4, R0

        TEQ     R4, #WinIDENoDevice
        MOVEQ   R5, #WinIDENoDevice
        BEQ     %FT50

; Now device 1 (we will see device 0's again if absent)

        TST     R5, #&80        ; check device 1 didn't fail
        MOVNE   R5, #WinIDENoDevice
        BNE     %FT50

        MOV     R0,#IDEDrvHeadMagicBits + (1:SHL:IDEDriveShift)
        STRB    R0,IDERegDevice
        BL      ReadSignature
        MOV     R5, R0

; Got signatures
50
 [ Debug23
        BREG    R4, "Device 0 signature "
        BREG    R5, "Device 1 signature "
 ]

        BL      UnlockIDEController

; Send Identify Device / Identify Packet Device commands

; Device 1 first (to clear PDIAG-/CBLID-)

        TEQ     R4, #WinIDENoDevice
        BEQ     %FT70

        TEQ     R5, #WinIDENoDevice
        BEQ     %FT60

 [ Debug23
        DLINE   "Identifying device 1"
 ]
        ADD     R0, R6, #1
        MOV     R1, R5
        sbaddr  R3, WinIDEDeviceIds
        ASSERT  SzWinIDEId = 512
        ADD     R3, R3, R0, LSL #9
        BL      IdentifyDevice

 [ Debug23
        DREG    R0,"Return code = "
 ]
        MOVVS   R5, #WinIDENoDevice
        TEQ     R0, #WinIDEErrNoDRQ
        TEQNE   R0, #WinIDEErrCmdNotRdy
        MOVEQ   R5, #WinIDENoDevice
        TEQ     R0, #0
        ORRNE   R5, R5, #bit7

60
; Now device 0

 [ Debug23
        DLINE   "Identifying device 0"
 ]
        ADD     R0, R6, #0
        MOV     R1, R4
        sbaddr  R3, WinIDEDeviceIds
        ASSERT  SzWinIDEId = 512
        ADD     R3, R3, R0, LSL #9
        BL      IdentifyDevice
 [ Debug23
        DREG    R0,"Return code = "
 ]
        MOVVS   R4, #WinIDENoDevice
        TEQ     R0, #WinIDEErrNoDRQ
        MOVEQ   R4, #WinIDENoDevice
        TEQ     R0, #0
        ORRNE   R4, R4, #bit7

; Got signature and identification results
70
        TEQ     R4, #WinIDENoDevice             ; definitely enforce no Device 1-only
        MOVEQ   R5, #WinIDENoDevice             ; configurations
 [ Debug23
        BREG    R4, "Device 0 class=&"
        TST     R4, #bit7
        BNE     %FT110
        DLINE   "Device 0 is ",cc
        sbaddr  R0, WinIDEDeviceIds+WinIDEIdModel
        ADD     R0, R0, R6, LSL #9
        MOV     R1, #?WinIDEIdModel
        BL      DebugATAName
        DLINE
110
        BREG    R5, "Device 1 class=&"
        TST     R5, #bit7
        BNE     %FT120

        DLINE   "Device 1 is ",cc
        sbaddr  R0, WinIDEDeviceIds+SzWinIDEId+WinIDEIdModel
        ADD     R0, R0, R6, LSL #9
        MOV     R1, #?WinIDEIdModel
        BL      DebugATAName
        DLINE
120

        sbaddr  R0, WinIDEDeviceIds
        DREG    R0,"ID table at "
 ]
        sbaddr  LR, WinIDEDeviceMappings
        STRB    R4, [LR, R6]!
        STRB    R5, [LR, #1]

90      ADD     R6, R6, #2
        CMP     R6, #WinIDEMaxDrives
        BLO     %BT10
95
        STRVS   R0,[SP]
        BVS     %FT99

        ; Count total drives present, and fill in NoIdFlags table
        sbaddr  R3, WinIDEDeviceMappings
        sbaddr  R6, WinIDEDeviceNoIdFlags
        MOV     R4, #0
        MOV     R5, #0
98      LDRB    LR, [R3, R5]
        TST     LR, #bit7
        MOVEQ   R7, #0
        MOVNE   R7, #1
        STRB    R7, [R6, R5]
        BICS    LR, LR, #bit7
        STRB    LR, [R3, R5]
        ADDEQ   R4, R4, #1
        ADD     R5, R5, #1
        CMP     R5, #WinIDEMaxDrives
        BLO     %BT98
99
        Pull    "R0-R3,R5-R9,IDECtrl,IDE,PC"

; ========================================================

; Out: R0 = &00 if ATA signature
;           WinIDEATAPIDevice if ATAPI signature
;           WinIDENoDevice if bad signature
ReadSignature   ROUT
        LDRB    R0, IDERegSecCount
 [ Debug23
        BREG    R0,"Count=",cc
 ]
        TEQ     R0, #&01
        LDREQB  R0, IDERegLBALow
 [ Debug23
        BNE     %FT01
        BREG    R0,",Low=",cc
01
 ]
        TEQEQ   R0, #&01
        BNE     %FT90
        LDRB    R0, IDERegLBAMid
 [ Debug23
        BREG    R0,",Mid=",cc
 ]
        TEQ     R0, #&00
        BEQ     %FT10
        TEQ     R0, #&14
        BNE     %FT90
; Maybe ATAPI
        LDRB    R0, IDERegLBAHigh
 [ Debug23
        BREG    R0,",High="
 ]
        TEQ     R0, #&EB
        MOVEQ   R0, #WinIDEATAPIDevice
        MOVEQ   PC, LR
        B       %FT90
; Maybe ATA
10      LDRB    R0, IDERegLBAHigh
 [ Debug23
        BREG    R0,",High="
 ]
        TEQ     R0, #0
90      MOVNE   R0, #WinIDENoDevice
        MOV     PC, LR


; ========================================================

; this routine outputs a string from an ATA/ATAPI device
; identify.  each of the strings in the identify device
; data is held in an unusual form, where alternate characters
; are swapped; strings are padded with spaces to fill the
; field.

; for instance, the string "FUJITSU" would be represented
; as "UFIJST U", plus any padding with further spaces

; it is assumed that the name is a multiple of 2 chars in length,
; and is at least 2 characters.  all the padding spaces are
; printed in the message.

; entry

; R0 -> string
; R1  = number of characters


PrintATAName    ROUT
        Push    "R0-R3, LR"

        MOV     R2, R0
10
        LDRB    R0, [R2, #1]
        CMP     R0, #32
        RSBHSS  LR, R0, #126
        MOVLO   R0, #"."
        SWI     XOS_WriteC
        BVS     %FT90
        LDRB    R0, [R2], #2    ; get next thing and advance the pointer
        CMP     R0, #32
        RSBHSS  LR, R0, #126
        MOVLO   R0, #"."
        SWI     XOS_WriteC
        BVS     %FT90

; now check if we've nothing left to do
        SUBS    R1, R1, #2
        BGT     %BT10           ; go round again if we have more to do

        CLRV
90
        Pull    "R0-R3, PC"

 [ Debug23
DebugATAName    ROUT
        Push    "R0-R3, LR"

        MOV     R2, R0
10
        LDRB    R0, [R2, #1]
        CMP     R0, #32
        RSBHSS  LR, R0, #126
        MOVLO   R0, #"."
        DWriteC
        LDRB    R0, [R2], #2    ; get next thing and advance the pointer
        CMP     R0, #32
        RSBHSS  LR, R0, #126
        MOVLO   R0, #"."
        DWriteC

; now check if we've nothing left to do
        SUBS    R1, R1, #2
        BGT     %BT10           ; go round again if we have more to do

        CLRV
90
        Pull    "R0-R3, PC"
 ]

 [ {FALSE}
; ========================================================

; PrintDeviceInfo

; this rountine prints information about a given device; the

; entry:

; r0 -> ATA/ATAPI information structure
; r1  = device no
; r2  = ADFS drive no, or -1 if not an adfs drive (ie ATAPI)

PrintDeviceInfo ROUT
        Push    "R0-R4, LR"

        SUB     sp, sp, #8      ; size of buffer for output values

        MOV     r4, r0
        MOV     r3, r2
        MOV     r0, r1

        MOV     r1, sp
        MOV     r2, #8

        CMPS    r3, #-1
        BNE     %FT10

        ADR     r0, ATAPIString
        SWI     XOS_Write0
        BVS     %FT90

        B       %FT20

10
        MOV     r0, r3
        MOV     r1, sp
        MOV     r2, #8
        SWI     XOS_ConvertCardinal1
        SWIVC   XOS_Write0
        BLVC    %FT99           ; pad with spaces

        BVS     %FT90
        ADR     r0, ATAString
        SWI     XOS_Write0
        BVS     %FT90

20
; finally, we print the device name

        ADD     r0, r4, #WinIDEIdModelNo
        MOV     r1, #40         ; length of the string
        BL      PrintATAName

90
        ADD     sp, sp, #8
        Pull    "R0-R4, PC",,^

; subroutine to pad with spaces
99
        Push    "LR"
;       ADD     R2, R2, #1

        MOV     r0, #" "
01
        SWI     XOS_WriteC
        BVS     %FT02
        SUBS    R2, R2, #1
        BNE     %BT01

02
        Pull    "PC",,^

ATAPIString
        DCB     "-       ATAPI   ",0

ATAString
        DCB     "ATA     ",0

NoDriveString
        DCB     "-       -",10,13,0

        ALIGN

 ]


;*********************************************************************

; this routine identifies a given drive

; Entry

;   R0 = physical drive number (0-3)
;   R1 = &EB if ATAPI
;   R3 = buffer ptr

; exit

;   R0 = command status (0 or a disc error no.)

;   if other error, V set, R0 -> error block

IdentifyDevice ROUT
        Push    "R1-R6,R10,LR"

        MOV     R6, R0
        SWI     XOS_ReadMonotonicTime
        BVS     %FT95
        MOV     R10, R0

; first - try IDENTIFY PACKET DEVICE. This doesn't require DRDY,
; and should be aborted by non-ATAPI devices. If no device is
; present (ie a non-existant device 1 hidden by device 0), we
; will get a failure fast (failure to assert DRQ - which is
; actually returned by IDEUserOp as return code 0, but no
; data transferred).

; have to construct a parameter block; use the stack

        MOV     R4, #0
        MOV     R5, #0

        Push    "R4-R5"

        MOV     LR, #IDEDrvHeadMagicBits
        ORR     R1, LR, r6, LSL #IDEDriveShift
        STRB    R1, [sp, #5]
        MOV     LR, #IDECmdIdentifyPacket
        STRB    LR, [sp, #6]

        MOV     R6, R6, LSR #1
        MOV     R6, R6, LSL #WinIDEControllerShift
        ORR     R6, R6, #WinIDEDirectionRead
        ORR     R0, R6, #bit1                   ; ignore DRDY
        MOV     r2, sp
        MOV     r4, #512
        MOV     r5, #0

        BL      DoSwiIDEUserOp
        BVS     %FT90

        TEQ     R0,#0
        TEQEQ   R4,#0
        BEQ     %FT90                           ; ooh, it worked - got data

        TEQ     R0,#0                           ; no error, but data not transferred
        MOVEQ   R0,#WinIDEErrNoDRQ              ; probably an absent device
        BEQ     %FT90

        TEQ     R0,#WinIDEErrABRT
        BNE     %FT90

; It aborted the command - that means we know something is there.
; Now we can do the 30s wait for DRDY to go high before issuing IDENTIFY
; DEVICE.

        MOV     R0, #0
        STR     R0, [sp, #0]
        STR     R0, [sp, #4]
        STRB    R1, [sp, #5]
        MOV     LR, #IDECmdIdentify
        STRB    LR, [sp, #6]

10      MOV     R0, R6
        MOV     r2, sp
        MOV     r4, #512
        MOV     r5, #0

        BL      DoSwiIDEUserOp
        BVS     %FT90

        TEQ     r0, #0
        BNE     %FT70

 [ Debug23
        DREG    r0, "r0: "
        DREG    r4, "r4: "
 ]

        CMP     r4, #0                          ; return code 0 - check everything
        MOVNE   r0, #WinIDEErrNoDRQ             ; transferred (it doesn't return NoDRQ)

        ADD     sp, sp, #8
        Pull    "R1-R6,R10,PC"

70      TEQ     R0, #WinIDEErrCmdNotRdy
        BNE     %FT90
        SWI     XOS_ReadMonotonicTime
        BVS     %FT90
        SUB     R0, R0, R10
        CMP     R0, #3104
        BLO     %BT10
        MOV     R0, #WinIDEErrCmdNotRdy
90
 [ Debug23
        DREG    r0, "UserOp error, R0="
 ]
        ADD     sp, sp, #8

95
        Pull    "R1-R6,R10,PC"

 [ HAL

; Entry: R0=device number (ie 0 or 2)

WinIDESetTimings
        Push    "R1-R9,LR"
        SUB     SP,SP,#16

        sbaddr  R9,WinIDEHardware
 [ TwinIDEHardware
        TST     R0, #2
        ADDNE   R9,R9, #SzWinIDEHardware
 ]
        LDRB    LR,[R9,#WinIDEIRQDevNo]
        TEQ     LR, #0
        BEQ     %FT95

        sbaddr  LR,WinIDEDeviceNoIdFlags
        LDRB    R4,[LR,R0]!
        LDRB    R5,[LR,#1]
; R4 = 0 <=> have identify data for device 0
; R5 = 0 <=> have identify data for device 1
        sbaddr  LR,WinIDEDeviceIds
        TEQ     R4,#0
        ADDEQ   R4,LR,R0,LSL #9
        MOVNE   R4,#0
        TEQ     R5,#0
        ADDEQ   R5,LR,R0,LSL #9
        ADDEQ   R5,R5,#SzWinIDEId
        MOVNE   R5,#0
; R4->identify data for device 0 (or 0)
; R5->identify data for device 1 (or 0)
        sbaddr  LR,WinIDEDeviceMappings
        LDRB    R6,[LR,R0]!
        LDRB    R7,[LR,#1]
; R6 = drive number / type of device 0
; R7 = drive number / type of device 1

        CMP     R6, #8
        MOVLO   LR, #bit0               ; enable FIFO if our drive
        MOVHS   LR, #0
        STR     LR, [SP,#0]

        CMP     R7, #8
        MOVLO   LR, #bit0               ; enable FIFO if our drive
        MOVHS   LR, #0
        STR     LR, [SP,#8]

        MOV     LR, #&FFFFFF00          ; PIO mode 0, no DMA
        STR     LR, [SP,#4]
        STR     LR, [SP,#12]

        BL      WinIDEDetectCableType

        MOV     R1, SP
        MOV     R2, R4
        MOV     R3, R6
        BL      WinIDEGetTimingForDevice

        ADD     R1, SP, #8
        MOV     R2, R5
        MOV     R3, R7
        BL      WinIDEGetTimingForDevice

        Push    "R0-R3,R12"
        LDRB    R1, [R9,#WinIDEBusNo]
        TEQ     R6, #WinIDENoDevice
        MOVEQ   R2, #0
        ADDNE   R2, SP, #5*4+0
        TEQ     R7, #WinIDENoDevice
        MOVEQ   R3, #0
        ADDNE   R3, SP, #5*4+8
 [ Debug23
        DREG    R1,"Bus ",cc,Integer
        DREG    R2,", Block1=",cc
        DREG    R3,", Block2="
        LDR     R14,[R2,#0]
        DREG    R14,,cc
        LDR     R14,[R2,#4]
        DREG    R14," ",cc
        LDR     R14,[R3,#0]
        DREG    R14,", ",cc
        LDR     R14,[R3,#4]
        DREG    R14," "
 ]
        LDR     R0, HAL_IDEDevice_pointer
        MOV     LR, PC
        LDR     PC, [R0,#HALDevice_IDESetModes]
        Pull    "R0-R3,R12"

        MOV     R3, R0
        TEQ     R6, #WinIDENoDevice
        MOVNE   R1, SP
        BLNE    WinIDESetTransferModes

        ADD     R0, R3, #1
        TEQ     R7, #WinIDENoDevice
        ADDNE   R1, SP, #8
        BLNE    WinIDESetTransferModes

95
        ADD     SP, SP, #16
        Pull    "R1-R9,PC"

 ]

; In: R0 = bus number * 2
;     R4 -> identify block for device 0 (0 if none)
;     R5 -> identify block for device 1 (0 if none)
;     R6 = drive number / type of device 0
;     R7 = drive number / type of device 1
; Out: R8 = 40 or 80

; This follows the algorithm in the ATA spec. Basic idea is that
; a 40-way cable has CBLID- bussed between the host and the devices,
; which contain pull-ups. An 80-way cable has CBLID- in the host
; connector pulled low, isolated from the 2 drives.
;
; This is complicated by CBLID-'s other, older function as PDIAG-,
; a line that may be pulled low by device 1, but we get some backup
; from newer devices that can detect and report the state of CBLID-
; at their end of the cable.
;
; We deduce that it is an 80-way cable if we see CBLID- low, and
; we are confident that it's not a device (bugged or pre-ATA-3)
; pulling it low via a 40-way cable. See ATA-6 section C.6 for more
; details.

WinIDEDetectCableType ROUT
        Push    "R0-R5,LR"
        MOV     R1, R0, LSR #1
 [ Debug23
        DREG    R1, "Cable of bus ",cc,Integer
 ]
        LDR     R0, HAL_IDEDevice_pointer
        Push    "R12"
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_IDECableID]
        Pull    "R12"

        TEQ     R0, #0                  ; If we see CBLID- line high
        BEQ     %40                     ; then it's definitely 40-way

        TEQ     R4, #0
        LDRNE   R4, [R4, #WinIDEIdResetResult]
        AND     R4, R4, #2_111:SHL:13   ; R4 = cable detect from device 0 (if any)

        TEQ     R7, #WinIDENoDevice
        BNE     %FT10

        ; No device 1 present, CBLID- low. Almost certainly 80-way,
        ; unless device 0 says it's low, in which case something odd
        ; has happened.

        TEQ     R4, #2_010:SHL:13
        BEQ     %40
        BNE     %80

        ; Device 1 is present. More complex, as pre ATA-3 devices
        ; may be pulling PDIAG-:CBLID- low for too long.

10      TEQ     R5, #0
        LDRNE   R1, [R5, #WinIDEIdMajorATAVersion]
        MOVEQ   R1, #0
        LDRNE   R5, [R5, #WinIDEIdResetResult]
        LDR     LR, =&FFFF
        AND     R5, R5, #2_111:SHL:13   ; R5 = cable detect from device 1 (if any)
        TEQ     R1, LR                  ; check for &FFFF case (version not reported)
        MOVEQ   R1, #0                  ; R1 = bitmask of supported versions

        TEQ     R4, #2_010:SHL:13       ; if either device says CBLID- is low
        TEQNE   R5, #2_010:SHL:13       ; then something wrong - say 40-way
        BEQ     %40

        TEQ     R4, #2_011:SHL:13       ; else if either device says CBLID-
        TEQNE   R5, #2_011:SHL:13       ; is high then it's 80-way
        BEQ     %80

        TST     R1, #bit6+bit5+bit4+bit3; else if device 1 is ATA-3 to 6 compatible
        BNE     %80                     ; then it must be 80-way (as these specs
                                        ; require device 1 to release PDIAG- after
                                        ; receiving its first command)

                                        ; else we don't know - device 1 may be old
                                        ; and may be interfering; say 40-way

40      MOV     R8, #40
 [ Debug23
        DLINE   " is 40-way"
 ]
        Pull    "R0-R5,PC"

80      MOV     R8, #80
 [ Debug23
        DLINE   " is 80-way"
 ]
        Pull    "R0-R5,PC"

        LTORG

; In: R1 -> speed setting block for device
;           (initially indicating PIO mode 0 only)
;     R2 -> identify block for device (or 0 if none)
;     R3 = drive number/type of device
;     R8 = 80 or 40 indicating cable type
;     R9 -> hardware block for controller
;
; Out: speed setting block updated to indicate capabilities
;      of device/cable combination (the HAL will reduce this
;      further if necessary when passed the setting block)

WinIDEGetTimingForDevice
        Push    "R0,R4,LR"
        TEQ     R2, #0
        BEQ     %FT99

        ; Get basic PIO mode (0,1 or 2)
        LDRB    R0, [R2, #WinIDEIdPIOTiming]
        CMP     R0, #2
        MOVHI   R0, #2

        ; Check for ATA-2 extra timing words
        LDR     LR, [R2, #WinIDEIdValidWordsFlags]
        TST     LR, #IIValid_Words64_70
        BEQ     %FT30

        ; Use "advanced" PIO modes 3 or 4 if available
        LDR     LR, [R2, #WinIDEIdPIOModes]
        TST     LR, #bit0
        MOVNE   R0, #3
        TST     LR, #bit1
        MOVNE   R0, #4

        ; Extra checks against cycle time - switch to a
        ; slower mode if necessary (eg if they do a slow
        ; mode 3, then just switch to mode 2). Check first
        ; whether we support IORDY.
        LDR     LR, [R9, #WinIDEHWFlags]
        TST     LR, #WinIDEHWFlag_IORDYSupported
        LDREQ   LR, [R2, #WinIDEIdMinPIOCycle]
        LDRNE   LR, [R2, #WinIDEIdMinPIOCycleIORDY]
        MOV     LR, LR, LSL #16
        MOV     LR, LR, LSR #16
        MOV     R4, #4
        CMP     LR, #120
        MOVGT   R4, #3
        CMP     LR, #180
        MOVGT   R4, #2
        CMP     LR, #240
        MOVGT   R4, #1
        SUB     LR, LR, #300
        CMP     LR, #83
        MOVGT   R4, #0

        CMP     R0, R4
        MOVHS   R0, R4

30
 [ Debug23
        DREG    R0, "PIO mode ",,Integer
 ]

        STRB    R0, [R1,#4]

        ; Now multiword DMA...

        LDR     LR, [R2, #WinIDEIdMultiwordDMAMode]
        MOV     R0, #-1
        TST     LR, #bit0
        MOVNE   R0, #0
        TST     LR, #bit1
        MOVNE   R0, #1
        TST     LR, #bit2
        MOVNE   R0, #2

        ; Check for ATA-2 extra timing words
        LDR     LR, [R2, #WinIDEIdValidWordsFlags]
        TST     LR, #IIValid_Words64_70
        BEQ     %FT60

        ; Extra checks against cycle time - switch to a
        ; slower mode if necessary (eg if they do a slow
        ; mode 2, then just switch to mode 1).
        LDR     LR, [R2, #WinIDEIdMinMultiwordDMACycle]
        MOV     LR, LR, LSL #16
        MOV     LR, LR, LSR #16
        MOV     R4, #2
        CMP     LR, #120
        MOVGT   R4, #1
        CMP     LR, #150
        MOVGT   R4, #0
        CMP     LR, #480
        MOVGT   R4, #-1

        CMP     R0, R4
        MOVGT   R0, R4

        ; Also check recommended cycle time - drop
        ; down a mode, if appropriate.
        LDR     LR, [R2, #WinIDEIdRecMultiwordDMACycle]
        MOV     LR, LR, LSL #16
        MOV     LR, LR, LSR #16
        MOV     R4, #2
        CMP     LR, #130                ; go to mode 1 (150ns) if recommended > 130ns
        MOVGT   R4, #1
        CMP     LR, #300                ; go to mode 0 (480ns) if recommended > 300ns
        MOVGT   R4, #0

        CMP     R0, R4
        MOVGT   R0, R4

60
 [ Debug23
        DREG    R0, "Multiword DMA mode ",,Integer
 ]

        STRB    R0, [R1,#5]

        ; And finally, Ultra DMA...

        LDR     LR, [R2, #WinIDEIdValidWordsFlags]
        TST     LR, #IIValid_Word88
        BEQ     %FT99

        LDR     LR, [R2, #WinIDEIdUltraDMAMode]
        MOV     R0, #-1
        TST     LR, #bit0
        MOVNE   R0, #0
        TST     LR, #bit1
        MOVNE   R0, #1
        TST     LR, #bit2
        MOVNE   R0, #2

        TEQ     R8, #80         ; if not an 80-way cable
        BNE     %FT90           ; limit to UltraDMA mode 2

        TST     LR, #bit3
        MOVNE   R0, #3
        TST     LR, #bit4
        MOVNE   R0, #4
        TST     LR, #bit5
        MOVNE   R0, #5
        TST     LR, #bit6
        MOVNE   R0, #6

90
 [ Debug23
        DREG    R0, "Ultra DMA mode ",,Integer
 ]

        STRB    R0, [R1,#6]

99
        Pull    "R0,R4,PC"


; In: R0 = physical device number
;     R1 -> speed descriptor block

WinIDESetTransferModes
        Push    "R0-R3,R5,LR"

        MOV     LR, #0
        STR     LR, [SP, #-4]!
        STR     LR, [SP, #-4]!

        MOV     LR, #3
        STRB    LR, [SP, #0]            ; Set transfer mode

        LDRB    R3, [R1, #4]
        CMP     R3, #7
        MOVHI   R3, #7
        ORR     LR, R3, #&08            ; PIO flow control mode <n>
        STRB    LR, [SP, #1]
        MOV     LR, R0, LSL #IDEDriveShift
        ORR     LR, LR, #IDEDrvHeadMagicBits
        STRB    LR, [SP, #5]
        MOV     LR, #IDECmdSetFeatures
        STRB    LR, [SP, #6]
 [ Debug23
        DREG    R0, "Setting PIO transfer mode for device ",cc,Integer
        DREG    R3, " to ",,Integer
 ]

        MOV     R0, R0, LSL #WinIDEControllerShift-1
        ASSERT  WinIDEDirectionNone = 0
        MOV     R2, SP
        MOV     R5, #0
        BL      DoSwiIDEUserOp

        LDR     R0, [SP, #8]            ; recover device number

        MOV     LR, #3
        STRB    LR, [SP, #0]            ; Set transfer mode

        LDRB    R3, [R1, #6]            ; Ultra DMA?
        TEQ     R3, #&FF
        BEQ     %FT30
        CMP     R3, #MaxUDMAMode
        MOVHI   R3, #MaxUDMAMode
        ORR     R3, R3, #&40            ; set Ultra DMA flag
        B       %FT40
30      LDRB    R3, [R1, #5]            ; else Multiword DMA?
        TEQ     R3, #&FF
        BEQ     %FT90
        CMP     R3, #7                  ; clamp to mode 7
        MOVHI   R3, #7
        ORR     R3, R3, #&20            ; set Multiword DMA flag
40
        STRB    R3, [SP, #1]
        MOV     LR, R0, LSL #IDEDriveShift
        ORR     LR, LR, #IDEDrvHeadMagicBits
        STRB    LR, [SP, #5]
        MOV     LR, #IDECmdSetFeatures
        STRB    LR, [SP, #6]
 [ Debug23
        DREG    R0, "Setting DMA transfer mode for device ",cc,Integer
        DLINE   " to ",cc
        TST     R3, #&40
        BEQ     %FT02
        DLINE   "Ultra",cc
        B       %FT04
02
        DLINE   "Multiword",cc
04
        AND     LR, R3, #7
        DREG    LR," DMA mode ",,Integer
 ]

        MOV     R0, R0, LSL #WinIDEControllerShift-1
        ASSERT  WinIDEDirectionNone = 0
        MOV     R2, SP
        MOV     R5, #0
        BL      DoSwiIDEUserOp
        TEQ     R0, #0
        BNE     %FT90

        ; If this command issued successfully, mark drive as being
        ; ready for DMA.
        MOV     R1, #1
        LDR     R0, [SP, #8]            ; recover device number
        sbaddr  R2, WinIDEDriveDMAFlags
        STRB    R1, [R2, R0]

90      ADD     SP, SP, #8

        Pull    "R0-R3,R5,PC"

 ]

 [ HAL
; Entry: R0=device number (0 or 2)

WinIDESetDefaultTimings
        Push    "R0-R3,LR"
        MOV     R2,#0
        MOV     R3,#&FFFFFF00
        STMFD   SP!,{R2,R3}
        STMFD   SP!,{R2,R3}
        MOV     R1,R0,LSR #1
        MOV     R2,SP
        ADD     R3,SP,#8
        LDR     R0,HAL_IDEDevice_pointer
        Push    "R12"
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_IDESetModes]
        LDR     R12, [SP], #20
        MOV     LR,#0
        LDR     R0,[SP]
        sbaddr  R1,WinIDEDriveDMAFlags
        STRB    LR,[R1,R0]!
        STRB    LR,[R1,#1]
        Pull    "R0-R3,PC"
 ]

        END
@


4.8
log
@Use HAL device for PATA IDE controller, and a few minor fixes
ADFS 3 is currently both a filing system and a hardware poker, so have it own the PATA device for now as a stepping stone to a PATADriver module; export the header.
No longer call HAL entries, look for the HAL device, activate, and call that instead. At API 0.00 it just has the exact same 3 functions as the previous HAL entries only refactored to pass a device pointer in R0.

Makefile/IDEDevice.hdr/ADFS.s/Adfs00.s:
  Export, include, and reserve workspace.
Adfs12.s/IDEDetect.s:
  Refactor function calls.
Messages:
  Unrelated correction to pluralisation of 'Sectors'.
Adfs50.s:
  Hunt for the IDE controller device.
  Fix oflaofla error if run on a non HAL machine - OS_Hardware errors but the ErrXFree code label expects the error pointer in R9 not R0.

Tested in an IOMD build.

Version 3.50. Tagged as 'ADFS-3_50'
@
text
@d685 1
a685 1
        Push    "R0-R3"
d689 1
a689 1
        ADDNE   R2, SP, #4*4+0
d692 1
a692 1
        ADDNE   R3, SP, #4*4+8
d709 1
a709 1
        Pull    "R0-R3"
d756 1
d759 1
d1084 1
d1087 1
a1087 1
        ADD     SP,SP,#16
@


4.7
log
@Replace a couple of magic numbers with constants
Detail:
  s/StaticsIDE - Add definitions for the "IORDY supported" & "No 48bit DMA" flags
  s/Adfs14, s/IDEDetect - Replace a couple of magic numbers with the more descriptive named flags
Admin:
  Tested in RiscPC ROM softload


Version 3.48. Retagged as 'ADFS-3_48'
@
text
@d685 2
a686 2
        Push    "R0-R3,R9"
        LDRB    R0, [R9,#WinIDEBusNo]
d688 2
a689 2
        MOVEQ   R1, #0
        ADDNE   R1, SP, #5*4+0
d691 2
a692 4
        MOVEQ   R2, #0
        ADDNE   R2, SP, #5*4+8
        MOV     R8, #OSHW_CallHAL
        MOV     R9, #EntryNo_HAL_ATASetModes
d694 4
a697 4
        DREG    R0,"Bus ",cc,Integer
        DREG    R1,", Block1=",cc
        DREG    R2,", Block2="
        LDR     R14,[R1,#0]
d699 1
a699 1
        LDR     R14,[R1,#4]
d701 1
a701 1
        LDR     R14,[R2,#0]
d703 1
a703 1
        LDR     R14,[R2,#4]
d706 4
a709 2
        SWI     XOS_Hardware
        Pull    "R0-R3,R9"
d750 2
a751 2
        Push    "R0-R5,R9,LR"
        MOV     R0, R0, LSR #1
d753 1
a753 1
        DREG    R0, "Cable of bus ",cc,Integer
d755 4
a758 3
        MOV     R8, #OSHW_CallHAL
        MOV     R9, #EntryNo_HAL_ATACableID
        SWI     XOS_Hardware
d809 1
a809 1
        Pull    "R0-R5,R9,PC"
d815 1
a815 1
        Pull    "R0-R5,R9,PC"
d1073 1
a1073 1
        Push    "R0-R3,R8,R9,LR"
d1078 6
a1083 6
        MOV     R0,R0,LSR #1
        MOV     R1,SP
        ADD     R2,SP,#8
        MOV     R8,#OSHW_CallHAL
        MOV     R9,#EntryNo_HAL_ATASetModes
        SWI     XOS_Hardware
d1090 1
a1090 1
        Pull    "R0-R3,R8,R9,PC"
@


4.6
log
@Reinstate floppies on IOMD platform
ADFS.s:
  Remove redundant header file.
Adfs05.s/Adfs15.s:
  Group the options a bit more simply, use {TRUE} and {FALSE}.
Adfs12.s/BusMaster.s/IDEDetect.s:
  Use defines instead of magic numbers.
Adfs17.s:
  Organise the offsets from the floppy controller to cover both PCI and IO based controllers.
  Only do the dummy read from the PBI on Tungsten.
Adfs18.s:
  Implement the FIQ equivalent of the 'FlpUseVerify' command switch, modern controllers (!) have a built in verify rather than using a sector read, but the verify command has no data phase and the FIQ handler was sitting waiting for a sector that never arrives.
  Rationalise FlpDRQmask and FlpDRQmaskbit.
Adfs19:
  Rationalise the calls to OS_Hardware by rejigging the assembly time switches.
  Reinstate the non HAL version of IRQ enable for reference.
  On RPCEmu 0.8.8 and 0.8.9 the emulator hangs during the four set of DCB's used to autodetect the drive (Recalibrate/Seek/Seek/Sense) which seems to be due to the way the emulator splits CPU time to floppy emulation time, to avoid this we wait 128us (real time) which is enough emulated time for the controller to have changed state. You probably just want to *CONFIGURE FLOPPIES 0 though.

Tested om A7000, ARM610, StrongARM manipulating a veriety of disc densities for read and write. Also ran the "Test/TestADFS" test program.
RPCEmu 0.8.8 and 0.8.9 boots still, but no attempt has been made to use emulated floppies.

Version 3.46. Tagged as 'ADFS-3_46'
@
text
@d856 1
a856 1
        TST     LR, #bit2
@


4.5
log
@Tabs expanded
Assembler source uses spaces round here in general, follow suit.
Not tagged.
@
text
@d693 1
a693 1
        MOV     R8, #0
d755 1
a755 1
        MOV     R8, #0
d1080 1
a1080 1
        MOV     R8,#0
@


4.4
log
@  Reintroduced support for IOMD machines
Detail:
  There was no "Ver" file for Machine=32, and the code for build switch
  settings appropriate for IOMD had not been kept up-to-date with various
  changes to the module which were made to support Tungsten. This version
  provides working IDE support for IOMD HAL builds, although there are
  still some issues with floppy support. Tungsten builds should be
  functionally identical.
Admin:
  Tested on a Risc PC. Joint development effort by Tom Walker and Ben Avison.

Version 3.37. Tagged as 'ADFS-3_37'
@
text
@d32 1
a32 1
	Push	"R0-R3,R5-R9,IDECtrl,IDE, LR"
d49 1
a49 1
	MOV	R6, #0  ; controller number (*2)
d78 2
a79 2
	MOV	r0, #IDEDevCtrlSRST
	STRB    R0, IDERegDevCtrl       ; reset the drive
d84 2
a85 2
	MOV	r0, #5*2                ; keep SRST on for 5us
	BL	DoMicroDelay
d87 2
a88 2
	MOV	r0, #0
	STRB    r0, IDERegDevCtrl
d93 2
a94 2
	MOV	r0, #2048*2             ; wait 2ms
	BL	DoMicroDelay
d126 1
a126 1
15      LDRB    R0,IDERegAltStatus	; get contents of alternate status register
d128 1
a128 1
	; if BSY is set then round we go again (if no devices present, BSY is pulled
d132 1
a132 1
	BEQ	Probe_BusyReleased
d152 2
a153 2
	MOV	r0, #10*2       ; wait 10us for luck - found to help with a number
	BL	DoMicroDelay    ; of drives
d297 1
a297 1
	Pull	"R0-R3,R5-R9,IDECtrl,IDE,PC"
d366 2
a367 2
PrintATAName	ROUT
	Push	"R0-R3, LR"
d369 1
a369 1
	MOV	R2, R0
d371 1
a371 1
	LDRB	R0, [R2, #1]
d375 3
a377 3
	SWI	XOS_WriteC
	BVS	%FT90
	LDRB	R0, [R2], #2	; get next thing and advance the pointer
d381 2
a382 2
	SWI	XOS_WriteC
	BVS	%FT90
d385 2
a386 2
	SUBS	R1, R1, #2
	BGT	%BT10		; go round again if we have more to do
d388 1
a388 1
	CLRV
d390 1
a390 1
	Pull	"R0-R3, PC"
d393 2
a394 2
DebugATAName	ROUT
	Push	"R0-R3, LR"
d396 1
a396 1
	MOV	R2, R0
d398 1
a398 1
	LDRB	R0, [R2, #1]
d403 1
a403 1
	LDRB	R0, [R2], #2	; get next thing and advance the pointer
d410 2
a411 2
	SUBS	R1, R1, #2
	BGT	%BT10		; go round again if we have more to do
d413 1
a413 1
	CLRV
d415 1
a415 1
	Pull	"R0-R3, PC"
d431 2
a432 2
PrintDeviceInfo	ROUT
	Push	"R0-R4, LR"
d434 1
a434 1
	SUB	sp, sp, #8	; size of buffer for output values
d436 3
a438 3
	MOV	r4, r0
	MOV	r3, r2
	MOV	r0, r1
d440 2
a441 2
	MOV	r1, sp
	MOV	r2, #8
d443 2
a444 2
	CMPS	r3, #-1
	BNE	%FT10
d446 3
a448 3
	ADR	r0, ATAPIString
	SWI	XOS_Write0
	BVS	%FT90
d450 1
a450 1
	B	%FT20
d453 11
a463 11
	MOV	r0, r3
	MOV	r1, sp
	MOV	r2, #8
	SWI	XOS_ConvertCardinal1
	SWIVC	XOS_Write0
	BLVC	%FT99		; pad with spaces

	BVS	%FT90
	ADR	r0, ATAString
	SWI	XOS_Write0
	BVS	%FT90
d468 3
a470 3
	ADD	r0, r4, #WinIDEIdModelNo
	MOV	r1, #40		; length of the string
	BL	PrintATAName
d473 2
a474 2
	ADD	sp, sp, #8
	Pull	"R0-R4, PC",,^
d478 2
a479 2
	Push	"LR"
;	ADD	R2, R2, #1
d481 1
a481 1
	MOV	r0, #" "
d483 4
a486 4
	SWI	XOS_WriteC
	BVS	%FT02
	SUBS	R2, R2, #1
	BNE	%BT01
d489 1
a489 1
	Pull	"PC",,^
d492 1
a492 1
	DCB	"-       ATAPI   ",0
d495 1
a495 1
	DCB	"ATA     ",0
d498 1
a498 1
	DCB	"-       -",10,13,0
d500 1
a500 1
	ALIGN
d522 1
a522 1
	Push	"R1-R6,R10,LR"
d538 2
a539 2
	MOV	R4, #0
	MOV	R5, #0
d541 1
a541 1
	Push	"R4-R5"
d543 3
a545 3
	MOV	LR, #IDEDrvHeadMagicBits
	ORR	R1, LR, r6, LSL #IDEDriveShift
	STRB	R1, [sp, #5]
d547 1
a547 1
	STRB	LR, [sp, #6]
d553 3
a555 3
	MOV	r2, sp
	MOV	r4, #512
	MOV	r5, #0
d557 1
a557 1
	BL	DoSwiIDEUserOp
d583 3
a585 3
	MOV	r2, sp
	MOV	r4, #512
	MOV	r5, #0
d587 1
a587 1
	BL	DoSwiIDEUserOp
d594 2
a595 2
	DREG	r0, "r0: "
	DREG	r4, "r4: "
d616 1
a616 1
	ADD	sp, sp, #8
d619 1
a619 1
	Pull	"R1-R6,R10,PC"
d996 1
a996 1
	STRB	LR, [SP, #6]
d1032 1
a1032 1
	STRB	LR, [SP, #6]
@


4.3
log
@* DMA support completed.
* Selects PIO/DMA/Ultra DMA modes appropriate for each device.
* DMA support added to ADFS_IDEUserOp, but not yet ADFS_ATAPIOp.
* WinIDEMaxSectorsPerTransfer increased to 256.
* Floppy driver reattaches to DMA Manager if it's reinitialised.

Version 3.35. Tagged as 'ADFS-3_35'
@
text
@a33 1
        ASSERT  WinIDEMaxDrives = 4
d37 4
d43 1
@


4.2
log
@* ADFS_DiscOp64 and ADFS_ATAPIOp added.
* New FileCore error passing scheme supported.
* PCI floppy support functional.
* 48-bit LBA support added for ADFS_IDEUserOp and accessing beyond the
  first 128GB of a drive - not thoroughly tested.
* IDE autodetection improved

Version 3.34. Tagged as 'ADFS-3_34'
@
text
@d21 2
d248 1
a248 1
        DNewLine
d259 1
a259 1
        DNewLine
d622 1
a622 1
        Push    "R1-R7,R9,LR"
d669 2
d681 1
a681 1
        Push    "R0-R3,R8,R9"
d685 1
a685 1
        ADDNE   R1, SP, #6*4+0
d688 1
a688 1
        ADDNE   R2, SP, #6*4+8
d705 1
a705 1
        Pull    "R0-R3,R8,R9"
d709 2
a710 2
        LDRNEB  R1, [SP, #4]
        BLNE    WinIDESetPIOMode
d714 3
a716 2
        LDRNEB  R1, [SP, #12]
        BLNE    WinIDESetPIOMode
d719 41
a759 1
        Pull    "R1-R7,R9,PC"
d761 48
d810 1
d812 1
d814 5
a818 1
; In: R2 = identify block for device (or 0 if none)
d820 5
d826 1
a826 1
        Push    "R0,LR"
d838 1
a838 1
        BEQ     %FT90
d840 1
a840 1
        ; Use PIO modes 3 or 4 if available
d857 1
a857 1
        MOV     R2, #4
d859 1
a859 1
        MOVGT   R2, #3
d861 3
a863 1
        MOVGT   R2, #2
a864 2
        CMP     LR, #30
        MOVGT   R2, #1
d866 1
a866 1
        MOVGT   R2, #0
d868 2
a869 2
        CMP     R0, R2
        MOVHS   R0, R2
d871 1
a871 1
90
d877 89
d967 1
a967 1
        Pull    "R0,PC"
d971 1
a971 1
;     R1 = PIO mode
d973 2
a974 2
WinIDESetPIOMode
        Push    "R1,R2,R5,LR"
d983 4
a986 3
        CMP     R1, #7
        MOVHI   R1, #7
        ORR     LR, R1, #&08            ; PIO flow control mode <n>
d995 46
a1040 1
        DREG    R1, " to "
d1048 11
a1058 1
        ADD     SP, SP, #8
d1060 1
a1060 1
        Pull    "R1,R2,R5,PC"
d1080 5
@


4.1
log
@32-bit conversion started, Tungsten hard disc support added.
Hard disc functional, but PIO mode only. Don't go near the floppy.

Version 3.33. Not tagged
@
text
@d64 1
a64 1
        ASSERT  :BASE:IDERegDigOutput=IDECtrl
d72 2
a73 2
	MOV	r0, #4
	STR	R0, IDERegDigOutput	; reset the drive
d75 1
a75 1
        STR     R0, [R4, #:INDEX:IDERegDigOutput]
d82 1
a82 1
	STR	r0, IDERegDigOutput
d84 1
a84 1
        STR     R0, [R4, #:INDEX:IDERegDigOutput]
d146 3
d169 1
a169 1
        STRB    R0,IDERegDrvLBA24to27
d201 1
d207 1
d245 2
a246 2
        BL      PrintATAName
        SWI     XOS_NewLine
d256 2
a257 2
        BL      PrintATAName
        SWI     XOS_NewLine
d285 1
a285 1
        STREQB  LR, [R3, R5]
d304 1
a304 1
        LDREQB  R0, IDERegLBA0to7
d312 1
a312 1
        LDRB    R0, IDERegLBA8to15
d321 1
a321 1
        LDRB    R0, IDERegLBA16to23
d323 1
a323 1
        BREG    R0,",High=",cc
d330 1
a330 1
10      LDRB    R0, IDERegLBA16to23
d332 1
a332 1
        BREG    R0,",High=",cc
d335 1
a335 4
90      MOVNE   R0, #&FF
 [ Debug23
        DLINE   ""
 ]
d386 25
d584 1
d615 1
d716 1
d719 2
d724 1
a724 1
        BEQ     %FT20
d726 6
d734 1
a734 1
        BEQ     %FT20
d736 1
a736 2
        ; Use PIO modes 3 or 4 if available, else drop to 0
        MOV     R0, #4
d738 2
d741 1
a741 3
        MOVEQ   R0, #3
        TSTEQ   LR, #bit0
        MOVEQ   R0, #0
d743 8
a750 2
        ; Slow down if they have a long cycle time
        LDR     LR, [R2, #WinIDEIdMinPIOCycleIORDY]
d767 1
d773 2
a775 2
20
        Pull    "R0,PC"
d813 19
@


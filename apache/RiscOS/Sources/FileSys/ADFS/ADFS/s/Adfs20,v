head	4.8;
access;
symbols
	ADFS-3_54:4.8
	ADFS-3_53:4.8
	ADFS-3_52:4.8
	ADFS-3_51:4.8
	ADFS-3_50:4.8
	ADFS-3_49:4.8
	ADFS-3_48:4.7
	ADFS-3_47:4.7
	ADFS-3_46:4.6
	ADFS-3_45:4.5
	ADFS-3_44:4.4
	ADFS-3_43:4.4
	ADFS-3_42:4.4
	ADFS-3_41:4.4
	ADFS-3_40:4.3
	ADFS-3_39:4.3
	ADFS-3_38:4.3
	ADFS-3_37:4.3
	ADFS-3_36:4.3
	RO_5_07:4.3
	ADFS-3_35:4.3
	ADFS-3_34:4.3
	ADFS-3_33:4.1
	dellis_autobuild_BaseSW:4.1
	ADFS-3_32:4.1
	Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	sbrodie_UrsulaRiscPC_ADFS-3_30:4.1
	Ursula_RiscPC_bp:4.1
	nturton_ADFS-3_29:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sproven_ADFS-3_31:4.1
	nicke_ADFS_3_26:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	sproven_330:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2015.10.28.21.18.58;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	eQ0PZPWgLdfy7VGy;

4.7
date	2012.10.23.19.59.54;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	5hNsJpgA09dD2ypw;

4.6
date	2012.10.21.11.42.57;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	yOiiX7g8HT2Zlfpw;

4.5
date	2012.10.21.11.38.10;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	L8DklCrHdjSrkfpw;

4.4
date	2011.10.14.07.38.46;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	tK3tjaAo92QGZhDv;

4.3
date	2003.01.17.19.33.28;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2002.09.18.15.03.30;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.22;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.31.22;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.35.29;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.29.10;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.24.40;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Refactor unaligned LDM in old style error return
Would only trigger if ADFS was being run on an ARMv7 but using an old style FileCore that didn't support the new error scheme, hence mostly for completeness.
Spotted by Jon Abbott, ref https://www.riscosopen.org/forum/forums/4/topics/3682

Typo in error string corrected in passing.

Version 3.49. Tagged as 'ADFS-3_49'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >Adfs20
;
; Change record
; =============
;
; CDP - Christopher Partington, Cambridge Systems Design
; LVR - Lawrence Rust, Cambridge Beacon
;
; 21-Mar-91  09:09  LVR
; 82710 drivers always use 1 second poll period
;
; 04-Apr-91  16:15  CDP
; Removed Debug20-dependent debug (IDE).
;
;
;*End of change record*

 LTORG

; =============
; LowLevelEntry
; =============

;entry
; R1  reason
 [ BigDisc
; R2  sector disc address top 3 bits drive
 |
; R2  byte disc address top 3 bits drive
 ]
; R3  RAM ptr
; R4  length
; R5  -> disc rec
; R6  -> defect list
; R12 -> private word

LowLevelEntry ROUT
 CMPS   R4, #0                  ;IF 0 length
 BICEQ  R0, R1, #DiscOp_Op_Atomic_Flag :OR: DiscOp_Op_ScatterList_Flag :OR: DiscOp_Op_AltDefectList_Flag
 ASSERT  DiscOp_Verify < DiscOp_ReadTrk
 ASSERT  DiscOp_ReadSecs < DiscOp_ReadTrk
 ASSERT  DiscOp_WriteSecs < DiscOp_ReadTrk
 CMPEQS R0, #DiscOp_ReadTrk     ;AND verify, read/write secs, not background
 MOVLO  PC, LR                  ;THEN nothing to do

 getSB
 Push   "LR"

 [ Debug3

 DREG  R1," ",cc
 DREG  R2," ",cc
 DREG  R3," ",cc
 DREG  R4," ",cc
 DREG  R5," ",cc
 DREG  R6," ",cc
 DLINE "*>LowLevel"
 ]
 TSTS   R2, #bit31              ; Drives 0..3?
 [ BigDisc
        BNE     %FT01
        Push    "R10"                   ; get some workspace
        LDRB    LR, [R5, #SectorSize]   ; get the sector size
        BIC     R10, R2, #DiscBits      ; sector offset
        AND     R2, R2, #DiscBits       ; drive
        ORR     R2, R2, R10, LSL LR     ; combine back as a byte offset addr
        BL      FlpLowLevel             ; FlpLowLevel still uses byte addresses; just munge addrs to work
        LDRB    LR, [R5, #SectorSize]   ; get the sector size back again
        BIC     R10, R2, #DiscBits      ; convert disc addr back
        AND     R2, R2, #DiscBits       ;
        ORR     R2, R2, R10, LSR LR     ;
        Pull    "R10"
        B       %FT02
01
        BL      WinLowLevel     ; winnie code has been changed to handle BigDisc properly
02
 |
        JumpAddress lr,LowLevelExit,forward
        BEQ     FlpLowLevel     ; Yes then do floppy operation
        BNE     WinLowLevel     ; Else winchester
LowLevelExit
 ]

 [ NewErrors
 BLVS   ConvertErrorForParent
 ]
 [ Debug3

 DREG  R0," ",cc
 DREG  R1," ",cc
 DREG  R2," ",cc
 DREG  R3," ",cc
 DREG  R4," ",cc
 DLINE "*<LowLevel"
 ]
 Pull   "PC"

 MACRO
 Misc   $str
 ASSERT MiscOp_$str=(.-MiscTable) :SHR: 2
 B      Do$str
 MEND

; =========
; MiscEntry
; =========

MiscEntry ROUT
        Push    "LR"
        getSB
 [ Debug4 :LOR: Debug10f
  [ :LNOT: Debug4
        TST     R1, #4
        BNE     %FT01
  ]
        DREG    R0," ",cc
        DREG    R1," ",cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," ",cc
        DREG    R5," ",cc
        DLINE   "*>Misc"
01
 ]

        CMPS    R0, #MiscOp_FirstUnknown
        BLO     %FT10
        MOV     R0, #BadParmsErr
        BL      SetV
        B       %FT90
10
        MOV     LR, PC
        ADD     PC, PC, R0, LSL #2
        B       %FT90
MiscTable
        Misc    Mount
        Misc    PollChanged
        Misc    LockDrive
        Misc    UnlockDrive
        Misc    PollPeriod
        Misc    Eject
        Misc    ReadInfo           ; this is done by FileCore
        Misc    DriveStatus

90
 [ NewErrors
        BLVS    ConvertErrorForParent
 ]
 [ Debug4

        DREG    R0," ",cc
        DREG    R1," ",cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," ",cc
        DREG    R5," ",cc
        DLINE   "*<Misc"
 ]
        Pull    "PC"


; =======
; DoMount
; =======

;entry
; R1 drive
; R2 disc address
; R3 -> buffer
; R4 length
; R5 -> disc rec to fill in for floppies

;exit R0,V internal error

DoMount ROUT
 [ Debug4
 DREG   r2, "Misc mount address:"
 ]
 TSTS   R2, #bit31                      ; Drives 0..3?
 BEQ    FlpMount                        ; Yes then jump, mount floppy
 B      WinMount                        ; Else mount winchester


DiscString
 = "disc",0
 ALIGN

; ============
; DoEject - Eject the drive in r1 if on A500 (or drive 0 if top bit set).
; ============
DoEject ROUT
        MOV     pc, lr

; ==========
; DoReadInfo
; ==========

; this miscop is handled entirely by filecore

DoReadInfo ROUT
        Push    "lr"
        MOV     R0, #BadParmsErr
        BL      SetV
        Pull    "pc"

; =============
; DoDriveStatus
; =============

DoDriveStatus ROUT
        Push    "lr"
        TSTS    r1, #4
        LDRNE   r2, WinIDECommandActive
        TEQNE   r2, #0
        MOVNE   r2, #1
        MOVEQ   r2, #0
        Pull    "pc"

; ============
; DoPollPeriod
; ============
DoPollPeriod ROUT
 [ fix_2
        Push    "R1,R2,LR"

        LDR     LR, MachineID
        TEQS    LR, #MachHas82710       ; 82710 controller?
        MOVEQ   R5, #PollPeriodLong     ; Yes then always poll slowly
        BEQ     %FT30

        MOV     R5, #3
        LDRB    R1, Floppies
        sbaddr  R2, DrvRecs+DrvFlags
        B       %FT20
10
        LDRB    LR, [R2], #SzDrvRec
        TST     LR, #MiscOp_PollChanged_ChangedWorks_Flag   ;RCM>>> Arn't these bits always
        TSTNE   LR, #MiscOp_PollChanged_EmptyWorks_Flag     ;       set the same
        MOVEQ   R5, #0
        TST     LR, #ResetChangedByWrite
        BICEQ   R5, R5, #2
20
        SUBS    R1, R1, #1
        BPL     %BT10

; R5 is 3 = Drive has a 'disc changed reset' line so poll quickly
;       1 = 'Disc changed' reset by step, so poll slowly cos DBell prefers it
;       0 = No disc changed line, so don't poll

        CMP     R5, #1
        MOVGT   R5, #PollPeriodShort
        MOVEQ   R5, #PollPeriodLong
        MOVLT   R5, #-1                 ;Infinite
30
        baddr   R6, DiscString
        Pull    "R1,R2,PC"
 |
        Push    "R1,R2,LR"
        MOV     R5, #PollPeriod
        LDRB    R1, Floppies
        sbaddr  R2, DrvRecs+DrvFlags
        B       %FT20
10
        LDRB    LR, [R2], #SzDrvRec                     ;RCM>>> equivalant to
        ASSERT  MiscOp_PollChanged_ChangedWorks_Flag = bit7 ; ==> NOT Zero  ; LDRB   LR, [R2], #SzDrvRec
        ASSERT  MiscOp_PollChanged_EmptyWorks_Flag   = bit6 ; ==> Carry     ; TST    LR, #MiscOp_PollChanged_ChangedWorks_Flag
        MOVS    LR, LR, LSR #7                          ; TSTNE  LR, #MiscOp_PollChanged_EmptyWorks_Flag
        MOVLS   R5, #-1 ; Test C=0 or Z=1               ; MOVEQ  R5, #-1
20
        SUBS    R1, R1, #1
        BPL     %BT10
        baddr   R6, DiscString
        Pull    "R1,R2,PC"
 ]

 [ NewErrors
; =====================
; ConvertErrorForParent
; =====================
; in: R0 = new-style FileCore error
; out: R0 = old- or new-style FileCore error, as appropriate
;      V preserved
ConvertErrorForParent ROUT
        Push    "LR"
        LDRB    LR, NewErrorsFlag
        TEQS    LR, #0                  ; new FileCore? then leave untouched
        Pull    "PC", NE
        BICS    LR, R0, #&FF            ; (CMP would corrupt V flag)
        Pull    "PC", EQ                ; < 256? Then standard error, leave untouched
        TSTS    R0, #NewDiscErrorBit    ; not a disc error?
        ORREQ   R0, R0, #ExternalErrorBit
        Pull    "PC", EQ                ; then set external error bit, and return
        Push    "R1,R2"
        BIC     R3, R0, #3              ; Knock out the 2 flags
        LDMIA   R3, {R1,R2,R3}
 [ BigDisc
        TSTS    R2, #DiscBits
        TEQEQS  R3, #0                  ; return old-style error if address is small
        BEQ     %FT05
        ; only IDE hard drives handle such large addresses, so..
        ASSERT  WinIDEBytesPerSector = 512
        MOV     R2, R2, LSR #9
        ORR     R2, R2, R3, LSL #(32-9)
        BIC     R2, R2, #DiscBits
        ORR     R2, R2, R1, LSL #(32-3)
        MOV     R1, R1, LSR #8
        AND     R1, R1, #&FF
        ADR     R0, WinIDEErrorNo
        STMIA   R0, {R1,R2}
        ORR     R0, R0, #DiscErrorBit+ExternalErrorBit
        B       %FT90
05
 ]
        BIC     R2, R2, #DiscBits
        MOV     R0, R2, LSR #8
        AND     LR, R1, #7
        ORR     R0, R0, LR, LSL #21
        AND     LR, R1, #MaxDiscErr:SHL:8
        ORR     R0, R0, LR, LSL #(24-8)
        ORR     R0, R0, #DiscErrorBit
90
        Pull    "R1,R2,PC"
 ]

 END
@


4.7
log
@Allow background ops again
Adfs20.s:
  Earlier tidy up 3.44->3.45 had erroneously cleared the background transfer bit, so they were being rejected leading to various things hanging while they never completed.
Adfs18.s:
  Safety NOP after mode change before banked register use for consistency with other mode changes in ADFS.
Consts.s/ModHeader.s:
  Documented CMOS bits, use ADFSSWI_Base from Hdr:SWIs, assert local definition matches FileCore.

Floppy *and* harddiscs tested this time.

Version 3.47. Tagged as 'ADFS-3_47'
@
text
@d308 2
a309 4
        ASSERT  NewDiscErrorBit < bit2  ; LDM ignores bits 0 and 1
        LDMIA   R0, {R1,R2,R3}
;          MOV     LR, #&80
;          STMIA   LR, {R0-R3}
a324 2
;          MOV     LR,#&A0
;          STMIA   LR, {R0,R1,R2}
a334 2
;          MOV     LR,#&A0
;          STMIA   LR, {R0}
@


4.6
log
@Tabs expanded
Assembler source uses spaces round here in general, follow suit.
Not tagged.
@
text
@d53 1
a53 1
 ANDEQ  R0, R1, #DiscOp_Op_Mask
@


4.5
log
@Tidy up pass
ADFS.s:
  Redundant header files trimmed
  Get OsWords and OsBytes
  Switches rationalised
ADFS_SA.a
  Removed ARM810 support
Adfs00.s:
  Unused MEMC flag removed
Adfs05.s/Adfs12.s/Adfs13.s/Adfs14.s/Adfs15.s/Adfs19.s:
  Use defines instead of magic numbers
  Make use of FileCore exported bit fields
Adfs17.s/Adfs18.s/ConstIDE:
  {TRUE} and {FALSE} used with objasm
Adfs20.s
  Use AND of the opmask instead of BIC of all the flags except the opmask
Adfs50.s
  Unused MEMC flag no longer initialised
  Make use of FileCore exported bit fields
  Service call table reordered so the Ursula despatch doesn't incur a branch
  OsByte defines used
Consts:
  Removed those definitions now duplicating FileCore's exports
DebugOpts/Fixes:
  All options brought under one roof
ModHeader:
  Now uses VersionNum directly
Ver/*:
  Redundant switches deleted
  Removed used of 'Version' header


Version 3.45. Tagged as 'ADFS-3_45'
@
text
@d75 13
a87 13
	BNE	%FT01
	Push	"R10"			; get some workspace
	LDRB	LR, [R5, #SectorSize]	; get the sector size
	BIC	R10, R2, #DiscBits	; sector offset
	AND	R2, R2, #DiscBits	; drive
	ORR	R2, R2, R10, LSL LR	; combine back as a byte offset addr
	BL	FlpLowLevel		; FlpLowLevel still uses byte addresses; just munge addrs to work
	LDRB	LR, [R5, #SectorSize]	; get the sector size back again
	BIC	R10, R2, #DiscBits	; convert disc addr back
	AND	R2, R2, #DiscBits	;
	ORR	R2, R2, R10, LSR LR	;
	Pull	"R10"
	B	%FT02
d89 1
a89 1
	BL	WinLowLevel	; winnie code has been changed to handle BigDisc properly
d93 2
a94 2
 	BEQ	FlpLowLevel	; Yes then do floppy operation
 	BNE	WinLowLevel	; Else winchester
@


4.4
log
@Update to use some of the exported FileCore headers.
There are still a large number of local copies that should be visited, but this change at least allows it to assemble again FileCore-3_45.
Tungsten and IOMD variants assemble, but others untested.

Version 3.41. Tagged as 'ADFS-3_41'
@
text
@d53 1
a53 1
 BICEQ  R0, R1, #NoTimeOut :OR: NoEscape :OR: ScatterBit :OR: AltDefectBit
@


4.3
log
@* ADFS_DiscOp64 and ADFS_ATAPIOp added.
* New FileCore error passing scheme supported.
* PCI floppy support functional.
* 48-bit LBA support added for ADFS_IDEUserOp and accessing beyond the
  first 128GB of a drive - not thoroughly tested.
* IDE autodetection improved

Version 3.34. Tagged as 'ADFS-3_34'
@
text
@d54 4
a57 1
 CMPEQS R0, #Param3Op           ;AND verify, read/write secs, not background
d114 1
a114 1
 ASSERT Misc_$str=(.-MiscTable) :SHR: 2
d140 1
a140 1
        CMPS    R0, #Misc_Unused
d251 2
a252 2
        TST     LR, #Drv_ChangedWorks   ;RCM>>> Arn't these bits always
        TSTNE   LR, #Drv_EmptyWorks     ;       set the same
d279 3
a281 3
        ASSERT  Drv_ChangedWorks = bit7 ; ==> NOT Zero  ; LDRB   LR, [R2], #SzDrvRec
        ASSERT  Drv_EmptyWorks   = bit6 ; ==> Carry     ; TST    LR, #Drv_ChangedWorks
        MOVS    LR, LR, LSR #7                          ; TSTNE  LR, #Drv_EmptyWorks
@


4.2
log
@32-bit conversion started, Tungsten hard disc support added.
Hard disc functional, but PIO mode only. Don't go near the floppy.

Version 3.33. Not tagged
@
text
@d95 3
d123 4
a126 1

d134 1
d157 3
d224 3
a226 1
        LDRNEB  r2, WinIDECommandActive
d287 54
@


4.1
log
@Initial revision
@
text
@d55 1
a55 1
 MOVLOS PC, LR                  ;THEN nothing to do
d89 4
a92 2
 	BLEQ	FlpLowLevel	; Yes then do floppy operation
 	BLNE	WinLowLevel	; Else winchester
d160 1
a160 3
        Pull    "LR"
        BICVCS  PC, LR, #V_bit
        ORRVSS  PC, LR, #V_bit
a191 1
 [ A1
d193 1
a193 31
        MOVS    pc, lr
 |
DoEject ENTRY "r0-r4"
        TST     r1, #(1 :SHL: 31)               ; Eject preferred drive,
        MOVNE   r1, #0                          ; which is zero.

        MOV     r3, pc
        ORR     r0, r3, #(I_bit :OR: F_bit)
        TEQP    r0, #0                          ; Disable IRQs and FIQs

        LDRB    r4, DiscLatchCopy               ; Read soft copy
        BIC     r2, r4, #&80                    ; Pull eject line low
        MOV     r0, #1
        BIC     r1, r2, r0, LSL r1              ; Clear bit for drive

        LDR     r2, =DiscLatch
        STRB    r1, [r2]                        ; Twiddle the lines.
        STRB    r1, [r2]                        ; Do it enough times
        STRB    r1, [r2]                        ; to be certain (1 fails,
        STRB    r1, [r2]                        ; 2 is OK on Turbo+ARM3).
        STRB    r1, [r2]                        ; Each one is 0.5uS, so
        STRB    r1, [r2]                        ; 8 of them is 4uS which
        STRB    r1, [r2]                        ; really ought to be
        STRB    r1, [r2]                        ; enough.

        STRB    r4, [r2]                        ; Restore soft copy

        TEQP    r3, #0                          ; Restore IRQ and FIQ status
        NOP                                     ; EXIT uses r13 (ARM2as)
        EXITS
 ]
d216 1
a216 1
        Pull    "pc",,^
d255 1
a255 1
        Pull    "R1,R2,PC",,^
d272 1
a272 1
        Pull    "R1,R2,PC",,^
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.14;
access;
symbols
	ADFS-3_54:4.14
	ADFS-3_53:4.13
	ADFS-3_52:4.13
	ADFS-3_51:4.13
	ADFS-3_50:4.13
	ADFS-3_49:4.13
	ADFS-3_48:4.13
	ADFS-3_47:4.12
	ADFS-3_46:4.12
	ADFS-3_45:4.11
	ADFS-3_44:4.10
	ADFS-3_43:4.10
	ADFS-3_42:4.10
	ADFS-3_41:4.10
	ADFS-3_40:4.9
	ADFS-3_39:4.8
	ADFS-3_38:4.8
	ADFS-3_37:4.8
	ADFS-3_36:4.7
	RO_5_07:4.7
	ADFS-3_35:4.7
	ADFS-3_34:4.6
	ADFS-3_33:4.4
	dellis_autobuild_BaseSW:4.3
	ADFS-3_32:4.3
	Ursula_merge:4.3
	Ursula_RiscPC_merge:4.3
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.4
	sbrodie_UrsulaRiscPC_ADFS-3_30:4.3
	Ursula_RiscPC_bp:4.3
	nturton_ADFS-3_29:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.6
	sproven_ADFS-3_31:4.3.2.1
	nicke_ADFS_3_26:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	rthornb_UrsulaBuild_01May1998:4.3
	sproven_330:4.3
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula:4.3.0.2
	Ursula_bp:4.3
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.14
date	2017.11.18.19.51.32;	author jlee;	state Exp;
branches;
next	4.13;
commitid	Em21492i286UsyfA;

4.13
date	2013.03.28.20.30.41;	author jlee;	state Exp;
branches;
next	4.12;
commitid	M0DGVV3z3qYjcBJw;

4.12
date	2012.10.21.11.42.57;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	yOiiX7g8HT2Zlfpw;

4.11
date	2012.10.21.11.38.09;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	L8DklCrHdjSrkfpw;

4.10
date	2011.10.14.07.38.46;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	tK3tjaAo92QGZhDv;

4.9
date	2011.08.07.19.35.54;	author jlee;	state Exp;
branches;
next	4.8;
commitid	AILCacyEauof9Cuv;

4.8
date	2010.12.06.14.14.47;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2003.04.03.18.47.57;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2003.01.17.19.33.27;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2002.09.18.15.03.30;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.11.17.12.25.56;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	97.05.02.09.12.19;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.06.11.31.43;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.31.19;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	98.09.02.18.37.32;	author sproven;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.31.19;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.35.19;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.14.32.32;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.11.50.45;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.28.59;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.24.30;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Remove legacy 700us DRQ timeout for write ops
Detail:
  Early versions of the ATA spec mandated that drives should assert DRQ within 700us of a write command being issued. However later versions of the spec have dropped this limit, and some devices (e.g. CF cards) are known to regularly exceed the limit.
  Remove the 700us timeout from ADFS, so that these devices can operate correctly.
  s/Adfs14 - Modify DRQ timeout check so that it will fall back to polling from TickerV if the initial 700us loop times out.
  s/StaticsIDE - Add extra word to workspace, so that the TickerV routine can still timeout the operation
Admin:
  Tested on IOMD (~4M FSBash ops), Tungsten (~500K FSBash ops)
  Fixes "disc error 20" seen when using IDE-CF adapter on RiscPC, thanks to reasarch by Jon Abbot:
  https://www.riscosopen.org/forum/forums/4/topics/9557


Version 3.54. Tagged as 'ADFS-3_54'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    IDE Winchester low level routines -> Adfs14

; Change record
; =============
;
; CDP - Christopher Partington, Cambridge Systems Design
; SBP - Simon Proven
; MJS - Mike Stephens
;
;
; 07-Jan-91  10:00  CDP
; IDE driver started.
;
; 11-Mar-91  16:38  CDP
; TestPresent routine, previously conditioned out, now removed.
; WinIDEWaitNotBusy added as it's needed all over the place.
;
; 13-Mar-91  14:51  CDP
; Fixed incorrect updated of scatter list entry on read error.
;
; 14-Mar-91  13:18  CDP
; Fixed typos in WinClaimIDEIRQs and WinReleaseIDEIRQs (PollPtr
; instead of WinIDEPollPtr - unfortunately, PollPtr is defined
; in the ST506 driver).
;
; 18-Mar-91  18:15  CDP
; Added WinIDEUpdateScatterList routine and calls in IRQHandler.
; (This update is done in more than one place but not between sectors
; of a chunk anymore and therefore not critical timing.)
; Increments WinIDECommandActive when starting a background op and
; decrements it following the background callback.
;
; 20-Mar-91  13:04  CDP
; Added WinIDEPowerSetup and WinIDEKillPowerSetup.
; WinIDEWaitReady changed to take a timeout parameter instead of using
; a fixed value and to return R0,V instead of Z.
;
; 27-Mar-91  10:47  CDP
; WinIDEPowerSetup now checks and clears a flag to determine whether
; it has installed a callback to remove itself. Without this, the
; callback could get added more than once before the first execution
; and this seems to be bad for the machine.
;
; 08-Apr-91  17:22  CDP
; WinIDEStartTransfer now limits the number of sectors to be transferred
; by one IDE op to WinIDEMaxSectorsPerTransfer instead of 256 sectors.
; This is to work around problems with some manufacturers' firmware,
; notably Seagate. It should not affect performance dramatically.
; Code previously conditional on IDEUseRAMCode now made permanent.
; Code to calculate new disc address from drive registers at end of lump
; now made conditional on IDETrustDrive. If this is false, the new disc
; address is calculated from the lump size.
;
; 01-May-91  10:39  CDP
; WinIDEIRQHandler now updates scatter list on write error, using the
; controller's registers (sanity checked) to determine how much was written.
; This was previously not done because there are bugs with some drives in
; this area.
;
; 15-Jul-91  11:57  CDP
; Applied fix suggested by Conner to fix problem with CP3044 (and other
; non-CAM drives?): it is impossible to select a drive that is busy and it
; is impossible to determine whether a drive is busy until is has been
; selected. The combined hardware/software fix, which is especially
; necessary when selecting a slave drive after reset, is to pull up the BUSY
; bit on the bus so that it always reads as 1 when neither drive is driving
; the bus and select drives by repeatedly writing to the drive/head register
; when trying to determine whether the drive is busy (changes to
; WinIDEWaitReady).
;
; 13-Jan-92  11:51  CDP
; Added LockIDEController and UnlockIDEController.
; WinIDEDoBackground: removed controller locking (now handled elsewhere);
; now issues callback to FileCore if nothing to do.
; WinIDECallbackBg: calls UnlockIDEController.
; WinIDECallbackBg now preserves registers so that callers don't need to;
; callers changed.
;
; 14-Jan-92  17:04  CDP
; WinIDECommandDisc changed to wait after selecting drive before testing
; status (similar to WinIDEWaitReady). ANDS in same routine changed to AND
; (there was no point in the S but it did no harm).
;
; 15-Jan-92  13:01  CDP
; WinIDEPowerSetup changed to use Lock/UnlockIDEController.
;
; 02-Apr-92  16:18  CDP
; Changed WinIDECallbackBg to unlock controller *before* calling FileCore
; as FileCore appears to call the low-level entry point from the callback
; routine under certain circumstances.
; WinIDESetDriveAndHead now masks head number to be only bits 0..3 for
; safety (avoids too large head number causing wrong drive to be selected).
;
;
; 23-Aug-1994 SBP
; Changed disc addressing system to support LBA mode when appropriate.
; Not all drives support this, so the WinIDEDriveLBAFlag variable is
; used to determine whether a drive supports LBA or not.  Some commands
; can't use LBA, so there's WinIDESetPhysAddressCHS - which will always
; use CHS addressing.  WinIDESetPhysAddress will choose LBA or CHS
; according to the relevant parameters passed.
;
; 24-Aug-94 SBP
; Modified WinIDEPhysAddrToLogical to support LBA mode.
;
; 06-Sep-1994 SBP
; Added support for BigDisc addressing (sector addresses).
;
; 06-12-94 16:52 SBP
; Fixed WinIDESetPhysAddress when BigDisc turned on.
;
; 08-12-94 11:04 SBP
; Incorporated comments from CDP:
;
; Made SetPhysAddress preserve flags and make choice of
; calling SetPhysAddress or SetPhysAddressCHS use cond.
; BLs instead of branching round code.
;
; Removed unnecessary branch round single instruction, line 1156.
;
; Fixed WinIDEIRQHandler to correctly clear 'in irq' flag on exit.
;
; Conditialised some more instructions to avoid branch.
;
; Removed spurious load of R5 before WinIDEAdjustStatus
;
; 27-02-96 MJS
; StrongARM changes for modifying code
;
;*End of change record*

;*********************************************************************
;
; This file contains the following routines:
;
; WinIDEDoForeground
;    Carries out the foreground part of a data transfer operation.
;
; WinIDEDoBackground
;    Initiates the background part of a data transfer operation.
;
; WinIDEStartTransfer
;    Starts a data transfer operation.
;
; WinIDEIRQHandler
;    Handles interrupts from the IDE discs.
;
; WinIDETimeout
;    Called when a data transfer operation times out.
;
; WinIDEUpdateScatterList
;    Updates scatter list by the length of a transfer.
;
; WinIDECallbackFg
;    The callback routine for foreground data transfer operations.
;
; WinIDECallbackBg
;    The callback routine for background data transfer operations.
;
; WinIDESetPhysAddress
;    Translates a logical disc address to a physical disc address and
;    sets up the IDE parameter block accordingly.  Uses CHS or LBA
;    addressing according to drive boot block flag.
;
; WinIDESetPhysAddressCHS
;    Same as WinIDESetPhysAddress but only uses CHS.
;
; WinIDESetDriveAndHead
;    Sets up the drive/head parameter byte in the IDE parameter block.
;
; WinIDECommandDisc
;    Issues a command to an IDE disc.
;
; WinIDEDecodeDriveStatus
;    Decodes drive status into an error number
;
; WinIDEPhysAddrToLogical
;    Calculates logical disc address of current sector from contents
;    of IDE registers.
;
; WinIDEInstallTransferCode
;    Copies code into RAM for moving data to/from the IDE discs.
;
; WinIDEReadASector
;    Reads up to a sector from an IDE disc.
;
; WinIDEWriteASector
;    Writes up to a sector to an IDE disc.
;
; WinIDEPowerSetup
;    Entered on timer event to setup power-saving mode of drives.
;
; WinIDEKillPowerSetup
;    Callback routine to remove WinIDEPowerSetup when finished.
;
; WinIDEPollCommand
;    Start a command and poll for the IRQ that indicates completion.
;
; WinIDEResetDrives
;    Resets the IDE drives and enables interrupts in the controller.
;
; WinIDEWaitReady
;    Waits for an IDE drive to become ready.
;
; WinIDEWaitNotBusy
;    Waits for controller to become not busy.
;
; WinIDECheckEscape
;    Checks if escape is allowed during an op and, if it is, checks whether
;    it has been pressed.
;
; WinClaimIDEIRQs
;    Installs an interrupt handler for IDE discs.
;
; WinReleaseIDEIRQs
;    Removes an interrupt handler for IDE discs.
;
; WinTickerHandler
;    Called every centisecond from TickerV.
;
; WinClaimTickerV
;    Installs a routine on TickerV.
;
; WinReleaseTickerV
;    Removes a routine from TickerV.
;
; DoMicroDelay
;    Delays a specified number of 1/2 microsecond units.
;
; LockIDEController
;    Sets flag to lock IDE controller.
;
; UnlockIDEController
;    Clears flag to unlock IDE controller.
;
;*********************************************************************

                GBLA    WinIDEDMAAlignment
WinIDEDMAAlignment SETA 4               ; to work around M1535+ bug for now

WinIDEDMAAlignmentMask * WinIDEDMAAlignment-1

WinIDEDoForeground ROUT
;
; Do the foreground part of an operation
;
; Entry:
;    R1 = operation as passed by FileCore
 [ BigDisc
;    R2 = sector disc address
 |
;    R2 = byte disc address
 ]
;    R3 -> buf or scatter list
;    R4 = length of transfer
;    IDE -> IDE controller
;    MODE: SVC
;
; Exit:
;    VS => error occurred
;          R0 = error code
;    VC => no error
;          R0 undefined
;    R1 preserved
 [ BigDisc
;    R2 updated sector disc address
 |
;    R2 updated byte disc address
 ]
;    R3 updated scatter list/buffer pointer
;    R4 updated amount to transfer
;    R5 undefined
;    All other registers preserved

; check that there really is something to do

        CMPS    R4,#0
        MOVEQ   PC,LR                   ; return (no error) if nothing to do

 [ Debug21

        DLINE   "WinIDEDoForeground"
 ]

; if scatter list, first transfer is first entry in scatter list
;            else, first transfer is passed R3,R4

        TSTS    R1,#DiscOp_Op_ScatterList_Flag
        ADREQ   R0,WinIDEFakeScatterList        ; if no scatter, fake it...
        STMEQIA R0,{R3,R4}
        MOVEQ   R3,R0                   ; ...and set R3 to point to it
        BEQ     %FT20                   ; ...and branch (R4 also = limit)

; scatter list provided

10
        LDMIA   R3,{R0,R5}              ; get scatter list entry
 [ FixTBSAddrs
        CMN     R0,#ScatterListNegThresh; addr < 0 ?
        ADDCS   R3,R3,R0                ; if yes, add in...
        BCS     %BT10                   ; and go again
 |
        TEQS    R0,#0                   ; addr < 0 ?
        ADDMI   R3,R3,R0                ; if yes, add in...
        BMI     %BT10                   ; and go again
 ]

; got non-negative address from scatter list entry, check for 0 len

        CMPS    R5,#0                   ; null entry?
        MOVEQ   PC,LR                   ; return (no error) if nothing to do

; found the first scatter list entry that has adr >= 0 and len != 0

20
 [ Debug21

        DLINE   "WinIDEDoForeground actually got stuff to do"
 ]
; R3 -> scatter list entry to do
; R4 = data to transfer in foreground

; flag "transfer in progress"

        MOV     R0,#0
        STRB    R0,WinIDEOpDone

; set the callback address

        ADDR    R0,WinIDECallbackFg
        STR     R0,WinIDECallbackPtr

; adjust length in R4 to take account of bytes to end of disc

        LDR     R0,WinIDEDiscSize       ; get size of disc

 [ BigDisc
        ASSERT  WinIDEBytesPerSector=512
        MOV     R0,R0,LSR #9            ; convert to sectors (assume disc has whole no. of sectors!)
        Push    "LR"
        LDR     LR, WinIDEDiscSize2
        ORR     R0, R0, LR, LSL #(32-9) ; add in discsize2
        MOV     LR, LR, LSR #9
        SUBS    R0,R0,R2                ; (R0,LR)= sectors to end of disc
        SBCS    LR,LR,#0                ; NE if >4G sectors
        Pull    "LR"
        BNE     %FT23
        CMP     R0,#&800000             ; check to see if >4G bytes (&800000 sectors)
 [ Debug21a

        DREG    R0,"Length to end of disc :"
 ]
        BHS     %FT23                   ; > 4G, beyond max possible transfer
        MOV     R0,R0,LSL #9
        CMPS    R0,R4                   ;
        MOVLO   R4,R0                   ; ...use it instead
 [ Debug21a

        DREG    R4,"Transfer length set to :"
 ]
 |
        SUB     R0,R0,R2                ; R0 = bytes to end
        CMPS    R0,R4                   ; if < transfer requested...
        MOVCC   R4,R0                   ; ...use it instead
 ]

23
; R3 -> scatter list entry
; R4 = max data to be transferred

        Push    "LR"

; Convert disc address passed to Cylinder/Head/Sector or LBA

 [ Debug21

        DLINE   "WinIDEDoForeground call to WinIDESetPhysAddress"
 ]
        CMP     R1,#WinIDEFileCoreOpFormat
        BLNE    WinIDESetPhysAddress    ; (R2->R0)
        BLEQ    WinIDESetPhysAddressCHS ; (R2->R0)

; Start the transfer

 [ Debug21

        DLINE   "WinIDEDoForeground phys address set so start transfer..."
 ]
        BL      WinIDEStartTransfer     ; (R3-R4,IDE->R0,V)
 [ Debug21

        DLINE   "Transfer start returned"
 ]
        Pull    "PC",VS                 ; return if error

; Enable CPU IRQs

        CLRPSR  I_bit,R0,,LR            ; enable IRQs

; busy wait loop

30
        LDRB    R0,WinIDEOpDone         ; get flag
        TEQS    R0,#0                   ; has IRQ set it yet?
        BEQ     %BT30                   ; branch if not

        RestPSR LR,,c                   ; restore IRQ state

; operation has completed - load registers for return

        LDRB    R0,WinIDECompletion     ; get completion code
        LDR     R1,WinIDEFileCoreOp     ; get op
        LDR     R2,WinIDEDiscAddress    ; get updated disc address
        LDR     R3,WinIDEScatterPtr     ; get scatter list pointer

        Pull    "LR"
        TSTS    R1,#DiscOp_Op_ScatterList_Flag ; was there a scatter list provided?
        LDMEQIA R3,{R3,R4}                     ; if no, get faked one
        BEQ     SetVOnR0

; Scatter list provided - if we exhausted the current entry, step to
; next so that any background part of this op has something to transfer.

        LDR     R4,[R3,#4]              ; if yes, get amount left
        CMPS    R4,#0                   ; exhausted ?
        ADDLE   R3,R3,#8                ; if yes, step to next

; It doesn't matter if R3 now points to a negative entry as this will
; be handled.

; Must return R4 = amount of original request not transferred, not amount
; of scatter list entry.

        LDR     R4,WinIDETransferLimit

 [ Debug21

        DREG    R4,"WinIDEStartTransfer : Limit at end = "
 ]

        B       SetVOnR0

;*********************************************************************

WinIDEDoBackground      ROUT
;
; Start a background data transfer
;
; Entry:
 [ BigDisc
;    R2 = sector disc address
 |
;    R2 = byte disc address
 ]
;    R3 -> scatter list (we know there is a scatter list)
;    IDE -> IDE controller
;
; Exit:
;    VS => error
;          R0 = error code
;    VC => no error
;          R0 undefined
;    R3 updated to point to first real entry in scatter list
;    R5 undefined
;    All other registers preserved

        Push    "R4,LR"
 [ Debug21

        DLINE   "WinIDEDoBackground"
 ]

; Get first chunk address/length from scatter list. Don't need to check
; for scatter list as will only do a background op when a scatter list
; has been provided.

10
        LDMIA   R3,{R0,R5}              ; get scatter list entry
 [ FixTBSAddrs
        CMN     R0,#ScatterListNegThresh; offset backwards?
        ADDCS   R3,R3,R0                ; if yes, add in...
        BCS     %BT10                   ; and go again
 |
        TEQS    R0,#0                   ; offset backwards?
        ADDMI   R3,R3,R0                ; if yes, add in...
        BMI     %BT10                   ; and go again
 ]

; got non-negative address from scatter list entry, check for 0 len

        TEQS    R5,#0                   ; null entry?
        BEQ     %FT80                   ; branch if so

; Found the first scatter list entry that has adr >= 0 and len != 0
; Set transfer length to bytes to end of disc as it will be a null entry in
; the scatter list which will really terminate the transfer.

 [ BigDisc
        ASSERT  WinIDEBytesPerSector=512
        LDR     R4,WinIDEDiscSize       ; size of disc...
        MOV     R4,R4,LSR #9            ; ...in sectors
        LDR     LR, WinIDEDiscSize2
        ORR     R4, R4, LR, LSL #(32-9)
        SUB     R4,R4,R2                ; R4 = sectors to end

; SBP 13 Dec 1996 Fix for ADFSBuffers<>0 on >2G discs

 [ {FALSE}
        CMPS    R4,#&800000             ; is this >=4Gbytes...
        MVNHS   R4,#0                   ; yes, so R4=4G-1
 |
        CMPS    R4,#&400000             ; is this >=2Gbytes...
        MVNHS   R4,#&80000000           ; yes, so R4=2G-1
 ]
        MOVLO   R4,R4,LSL #9            ; no, so R4 = bytes to end
 [ Debug21a

        DREG    R4,"Length set to :"
 ]
 |
        LDR     R4,WinIDEDiscSize       ; get size of disc
        SUB     R4,R4,R2                ; R4 = bytes to end
 ]

; set the callback address

        ADDR    R0,WinIDECallbackBg
        STR     R0,WinIDECallbackPtr

; Set up Cylinder/Head/Sector and do the background bit

        LDR     LR,WinIDEFileCoreOp
        CMP     LR,#WinIDEFileCoreOpFormat

        BLNE    WinIDESetPhysAddress    ; (R2->R0)
        BLEQ    WinIDESetPhysAddressCHS

; Start the transfer
; R3 -> scatter list entry
; R4 = max data to be transferred

 [ Debug21

        DLINE   "Start transfer..."
 ]
        BL      WinIDEStartTransfer     ; (R3-R4,IDE->R0,V)
 [ Debug21

        DLINE   "Transfer start returned"
 ]
        Pull    "R4,PC",VC              ; return if ok

; background op not started
; R0 = completion code
; Don't do background callback here as caller will when it sees error

        Pull    "R4,PC"                 ; error

;****** Never fall through

80
; nothing to do in background: callback FileCore

        MOV     R0,#0                   ; status = ok
        BL      WinIDECallbackBg

        CLRV
        Pull    "R4,PC"                 ; return to caller (status ok)

;*********************************************************************

WinIDEStartTransfer     ROUT
;
; Called to start a data transfer op (read, write, verify, format)
;
; Entry:
;    R3 -> scatter list entry
;    R4 =  overall limit on transfer
;    IDE -> IDE controller
;    WinIDECommandCode = IDE opcode for this op
;    MODE: SVC
;
; Exit:
;    VS => some error occurred starting xfer
;          R0 = error code
;    VC => no error
;          R0 undefined
;    All other registers preserved

        Push    "R1-R6,R8-R9,LR"

 [ Debug21

        DLINE   "WinIDEStartTransfer:Start transfer"
 ]

; save limit - will decrement on each transfer

        STR     R4,WinIDETransferLimit

; save scatter list pointer

        STR     R3,WinIDEScatterPtr             ; save for IRQ etc.

; check for escape if enabled - must do this after limit and scatterptr
; setup

        BL      WinIDECheckEscape               ; (->R0,V)
        Pull    "R1-R6,R8-R9,PC",VS             ; return if escape

 [ Debug21

        DLINE   "WinIDEStartTransfer: Escape not pressed"
 ]
; no escape - save scatter list pointer and first entry
; first scatter list entry is known to be valid

        STR     R3,WinIDETmpScatterPtr
        MOV     R8,R3
        LDMIA   R3,{R0,R5}
        sbaddr  R1,WinIDETmpScatterEntry
        STMIA   R1,{R0,R5}

; See how much there is to transfer in the scatter list (upto the amount
; passed as the limit on the transfer). This is safe to do even when the
; scatter list has been faked provided that we stop when our limit has been
; reached.

        MOV     R1,#0                           ; bytes found in scatter list
10
        LDMIA   R3,{R0,R5}                      ; get scatter entry
 [ FixTBSAddrs
        CMN     R0,#ScatterListNegThresh        ; wrap around?
        ADDCS   R3,R3,R0                        ; yes, add it in
        BCS     %BT10                           ; and go again
 |
        TEQS    R0,#0                           ; wrap around?
        ADDMI   R3,R3,R0                        ; yes, add it in
        BMI     %BT10                           ; and go again
 ]

; found real entry in scatter list

        TEQS    R5,#0                           ; end of scatter list?
        BEQ     %FT20                           ; branch if so
        ADD     R1,R1,R5                        ; add in length

        CMPS    R1,R4                           ; hit limit?
        ADDCC   R3,R3,#8                        ; if not, step to next entry
        BCC     %BT10                           ; branch if so


20
; Have added up what we found in scatter list.
; Check total in scatter list is less than limit as final addition may
; have exceeded limit
; R1 = length to try to transfer

        CMPS    R1,R4                           ; found more than limit?
        MOVHI   R1,R4                           ; if yes, use limit

; R1 = bytes we want = MIN(amount in scatter list, limit)

 [ Debug21

        DREG    R1, "WinIDEStartTransfer:Bytes we want="
 ]

; Check that this will not blow maximum allowed request of IDE drive
; Note: request of 0 (i.e. 256 MOD 256) requests 256 sectors

 [ WinIDEMaxSectorsPerTransfer = 256

        CMPS    R1,#256 * WinIDEBytesPerSector  ; R1 > max allowed?
        MOVHI   R1,#256 * WinIDEBytesPerSector  ; if yes, R1 = max allowed
        MOV     R9,R1                           ; save size of xfer

 |
        MOV     R9,#WinIDEMaxSectorsPerTransfer ; get max size of xfer
        ASSERT  WinIDEBytesPerSector = 512
        MOV     R9,R9,LSL #9                    ; convert to bytes
        CMPS    R1,R9                           ; R1 > max allowed?
        MOVHI   R1,R9                           ; if yes, R1 = max allowed
        MOVLS   R9,R1                           ; save size of xfer
 ]

21
; R1 = R9 = bytes to transfer in one IDE op (lump size)

        LDRB    R6,WinIDECommandCode            ; get command
 [ Debug21

        DREG    R6, "WinIDEStartTransfer: command="
        DREG    R1, "WinIDEStartTransfer: Lump size="
 ]
        STR     R9,WinIDELumpSize               ; save for IRQ
        STR     R9,WinIDESaveLumpSize

; R6 = command
; R9 = lump size

; Calculate and save the number of bytes to be used from the first sector
; (the blocksize). If this is a real data transfer op (read or write) this
; should be the minimum of the sector size and the size of the first
; entry in the scatter list. Since all except the final entry in the list
; must be a multiple of the sector size, it is ok to use the minimum of
; the sector size and the lump size.
; For verify, the blocksize will be the same as the lumpsize as we only
; get an IRQ when all sectors have been verified.

        CMPS    R9,#WinIDEBytesPerSector        ; MIN(lumpsize, sector size)
        MOVHI   R9,#WinIDEBytesPerSector

        TEQS    R6,#IDECmdVerify                ; verify?
        TEQNES  R6,#IDECmdVerifyExt
 [ EngineeringMode
        TEQNES  R6,#IDECmdVerifyEng
 ]
        MOVEQ   R9,R1                           ; if yes, blocksize = lumpsize
        STR     R9,WinIDEBlockSize

; R6 = command
; R1 = bytes to transfer in this lump
; If format, CAM 2.1 says that sector count register should contain
;    number of sectors per track

        TEQS    R6,#IDECmdFormatTrk             ; format?
        LDREQB  R1,WinIDESecsPerTrk             ; if yes, get secs/trk

; If not format, round up to whole number of sectors
;    = (bytes + bytes_per_sector-1)/bytes_per_sector

        ADDNE   R1,R1,#WinIDEBytesPerSector     ; else round xfer to sectors
        SUBNE   R1,R1,#1
        ASSERT  WinIDEBytesPerSector = 512
        MOVNE   R1,R1,LSR #9

; R1 = number of sectors we will ask for this time
;      (the final one may not be transferred in its entirety)
; If format, R1 = sectors/track

        STRB    R1,WinIDEParmSecCount
        MOV     R1,R1,LSR #8
        STRB    R1,WinIDEParmSecCountHigh

; set value for features/precomp register

        LDRB    R1,WinIDEPrecomp
        STRB    R1,WinIDEParmPrecomp

 [ IDEDMA
; work out if we're actually going to do it through DMA

        LDRB    R0,WinIDECommandFlags
        TST     R0,#WinIDECmdFlag_DMA           ; is it a DMA commond
        BEQ     %FT30
 [ Debug21
        DLINE   "WinIDEStartTransfer: DMA command... ",cc
 ]

        LDR     R1,WinIDECurrentHW
        LDR     R4,WinIDELumpSize

; check DMA system is ready
        LDR     LR,[R1,#WinIDEDMAHandle]
        CMP     LR,#-1
        BEQ     %FT23

; avoid 48-bit DMA commands if not supported by controller (sigh)
        TST     R0,#WinIDECmdFlag_48bit
        BEQ     %FT25
        LDR     LR,[R1,#WinIDEHWFlags]
        TST     LR,#WinIDEHWFlag_No48bitDMA
        BEQ     %FT25

; unable to do DMA command - switch to PIO form
23      LDRB    R6,WinIDECommandCode_PIO
 [ Debug21
        DREG    R6,"backed off to command ",,Byte
 ]
        STRB    R6,WinIDECommandCode
        BIC     R0,R0,#WinIDECmdFlag_DMA
        STRB    R0,WinIDECommandFlags
        B       %FT30

; the DMA version of command starting

25      LDR     R3,WinIDEScatterPtr
        TEQS    R6,#IDECmdReadDMA
        TEQNES  R6,#IDECmdReadDMAExt
        MOVEQ   R0,#0+8
        MOVNE   R0,#1+8
        MOV     R9,R4
        BL      WinIDEPadScatterList
        BVS     %FT40
        TST     R6,#WinIDEDMAAlignmentMask      ; any addresses misaligned (partial check)?
        BNE     %BT23                           ; then drop back to PIO
        TST     R9,#WinIDEDMAAlignmentMask      ; length not halfword multiple?
        BNE     %FT28                           ; then try trimming off excess
 [ Debug21
        DLINE   "queued"
 ]
        LDRVC   R9,WinIDECurrentHW
        BLVC    WinIDEQueueTransfer
        LDRB    LR,WinIDEDMAStatus
        TST     LR,#DMAStat_Completed           ; allow the "Completed" routine to
        LDRNE   R0,WinIDEDMAResult              ; override the error (because it can
        BLNE    SetVOnR0                        ; choose to back off from DMA)
        LDRB    R6,WinIDECommandCode            ; (may have been changed)
        B       %FT40

        ASSERT  WinIDEBytesPerSector=512
28      MOVS    LR,R9,LSR #9                    ; round lump size down to whole
        MOVNE   R9,LR,LSL #9                    ; sector to do bulk of transfer
        MOVNE   R1,R9                           ; with DMA. last sector will use PIO
        BNE     %BT21
        LDRB    R0,WinIDECommandFlags
        B       %BT23

30
 ]

; R6 = command

        MOV     R0,R6                           ; R0 = command code
 [ BigDisc
        LDRB    LR,WinIDECommandFlags
        ORR     R0,R0,LR,LSL #8
 ]
 [ Debug21

        DLINE   "WinIDEStartTransfer: command disc"
 ]
        BL      WinIDECommandDisc               ; (R0,IDE->R0,V)
 [ Debug21

        DLINE   "WinIDEStartTransfer: command disc returned"
 ]
40
        Pull    "R1-R6,R8-R9,PC",VS

; Op started ok (V=0), R0 = R6 = command
; Start timer - this times out the whole IDE op i.e. not each sector.
; If a FileCore op takes more than one IDE op, the timer gets restarted
; for each IDE op.

        MOV     R0,#WinIDETimeoutTransfer
        STR     R0,WinTickCount
        ADDR    R0,WinIDETimeout
        STR     R0,WinTickCallAddress

; WinIDETimeout will now be called if the timeout expires

; Enable interrupt.
; If it's motherboard IDE, will need to enable IRQ in IOC.
; If podule IDE, the IRQ is always enabled in IOC but must be enabled
; on the podule. In either case, the interrupt is always enabled
; on the IDE controller itself.
; For podule, assumes that register is write-only and that bits other
; than the enable bit are safe to alter.

        PHPSEI  LR                              ; IRQs off (preserves C/V)

 [ TwinIDEHardware
        LDR     R1,WinIDECurrentHW
 |
        sbaddr  R1,WinIDEHardware
 ]
 [ HAL
        LDRB    R0,[R1,#WinIDEHWType]
        TEQ     R0,#WinIDEHW_Podule
        ADDEQ   R0,R1,#WinIDEIRQPtr             ; R0-> interrupt mask reg
        ASSERT  WinIDEIRQBits = WinIDEIRQPtr + 4
        LDMEQIA R0,{R0,R1}
        STREQB  R1,[R0]                         ; write to podule
        BEQ     %FT65
        Push    "R0-R3,R9,R12,LR"
        LDRB    R0,[R1,#WinIDEIRQDevNo]
        sbaddr  R1,HAL_IRQEnable_routine
        MOV     LR,PC
        LDMIA   R1,{R9,PC}
        Pull    "R0-R3,R9,R12,LR"
65
 |
        LDRB    R2,[R1,#WinIDEHWType]
        SUBS    R2,R2,#WinIDEHW_Podule          ; motherboard? (NE if yes)
        ADD     R0,R1,#WinIDEIRQPtr             ; R0-> interrupt mask reg
        ASSERT  WinIDEIRQBits = WinIDEIRQPtr + 4
        LDMIA   R0,{R0,R1}
        LDRNEB  R2,[R0]                         ; yes, get IOC mask
        ORR     R2,R2,R1                        ; or in enable bit
        STRB    R2,[R0]                         ; write to IOC/podule
 ]

        PLP     LR                              ; restore IRQ state

 [ IDEDMA
        LDRB    LR,WinIDECommandFlags
        TST     LR,#WinIDECmdFlag_DMA
        Pull    "R1-R6,R8-R9,PC",NE
 ]

; if write or format op, write first sector of data

 [ Debug21

        DLINE   "WinIDEStartTransfer: Check for write or format"
 ]
        CMPS    R6,#IDECmdWriteSecs             ; write?
        CMPNES  R6,#IDECmdWriteSecsExt
        CMPNES  R6,#IDECmdFormatTrk             ; or format?
        Pull    "R1-R6,R8-R9,PC",NE             ; return if not

 [ Debug21

        DLINE   "WinIDEStartTransfer: was write or format - transfer 1st sector"
 ]
; it was a data out op
; R8 -> scatter list
; R9 = bytes we want from/for first sector
; We need to wait for DRQ to be asserted before we can send the first sector of
; data. However the drive won't raise an interrupt - we must poll the
; controller.
; Early versions of the ATA spec state that it can take up to 700us before DRQ
; is asserted, but later versions of the spec have dropped this limit. We might
; be in an IRQ, so we can't wait here forever, as that would ruin interrupt
; latency. Most drives will respond within 700us, so go for a compromise of
; waiting here for up to 700us, with a fallback of polling from TickerV for
; drives that take longer.

        MOV     R1,#700                         ; counter for loop
80
        LDRB    R0,IDERegAltStatus              ; get status
        AND     R0,R0,#IDEStatusDRQ             ; mask bits except DRQ
        TEQS    R0,#IDEStatusDRQ                ; EQ => got DRQ
        SUBNES  R1,R1,#1                        ; if not, decrement count...
        MOVNE   R0,#1*2                         ; ...and wait (1/2 us units)
        BLNE    DoMicroDelay                    ; (preserves flags)
        BNE     %BT80

; have got DRQ or are giving up waiting

        CMPS    R1,#0                           ; giving up?
        BEQ     %FT81

; got DRQ so write data

        LDR     R1,[R8,#0]                      ; R1 -> buffer
        MOV     R0,R9                           ; R0 = max bytes to move

; R0 = length to transfer (up to 512 bytes will be moved)
; R1 -> buffer
; Call data write routine

 [ TwinIDEHardware
        LDR     R9, WinIDECurrentHW
 |
        sbaddr  R9, WinIDEHardware
 ]

        MOV     LR,PC                           ; set link
        LDR     PC,[R9,#WinIDEWritePtr]         ; (R0,R1,IDE->R0,R1)
                                                ; returns here

; Do NOT adjust buffer address and lengths as the write may fail.
; IRQ routine does update.
; All done - return

        CLRV
        Pull    "R1-R6,R8-R9,PC"

81
; set up the TickerV DRQ poll routine
        PHPSEI  LR
        LDR     R1, WinTickCount                ; preserve current timeout
        STR     R1, WinIDEDRQTimeout
        MOV     R1, #1
        STR     R1, WinTickCount
        ADR     R1, WinIDEDRQPoll
        STR     R1, WinTickCallAddress
        PLP     LR
        Pull    "R1-R6,R8-R9,PC"

        LTORG

;*********************************************************************

; The following variables define the registers pushed by the
; IRQ routine that the timer routine must also push.
;
; WinIDEIRQRegsA are the registers pushed before switching processor
; modes. WinIDEIRQRegsB are the main registers.
;
; LR is not included in either set but MUST be pushed/pulled

                GBLS    WinIDEIRQRegsA          ; regs pushed
                GBLS    WinIDEIRQRegsB

WinIDEIRQRegsA  SETS    "R0"
 [ HAL
WinIDEIRQRegsB  SETS    "R0-R9,IDECtrl,IDE"
 |
WinIDEIRQRegsB  SETS    "R0-R9,IDE"
 ]

;*********************************************************************

WinIDEIRQHandler        ROUT
;
; Called from an IRQ from the IDE system during a data transfer op.
;
; Entry:
;    SB -> static workspace
;    MODE: IRQ
;    IRQs disabled
;
; Exit:
;    All registers and flags preserved

; Switch to SVC mode so can enable IRQs without R14 being destroyed
; by the first IRQ. Should also allow us to use HostFS debug routines
; once the interrupt has been cleared.

        Push    "$WinIDEIRQRegsA,LR"
        WritePSRc SVC_mode :OR: I_bit,LR,,R0    ; keep IRQs disabled
        NOP

; Now in SVC mode - save regs

        Push    "$WinIDEIRQRegsB,LR"

; Set IDE -> IDE controller

 [ TwinIDEHardware
        LDR     R9,WinIDECurrentHW
 |
        sbaddr  R9,WinIDEHardware
 ]
 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        ASSERT  WinIDEPtr = 4
        LDMIA   R9,{IDECtrl,IDE}        ; IDE -> IDE hardware
 |
        LDR     IDE,[R9,#WinIDEPtr]
 ]

; Set flag to indicate currently in IRQ to prevent timer interfering
; when IRQ being processed.

        MOV     R0,#&FF
        STRB    R0,WinIDEIRQFlag

; Disable IRQs from the IDE controller so can reenable interrupts
; without risk of interrupt from IDE whilst servicing this one

;        MOV     R0,#bit1                ; -IEN
;        STRB    R0,IDERegDigOutput

 [ HAL
        LDRB    R1,[R9,#WinIDEHWType]
        TEQ     R1,#WinIDEHW_Podule
        LDREQ   R4,[R9,#WinIDEIRQPtr]           ; R4-> interrupt mask reg
        MOVEQ   R1,#0
        STREQB  R1,[R4]                         ; write to podule
        BEQ     %FT03
        Push    "R0-R3,R9,R12"
        LDRB    R0,[R9,#WinIDEIRQDevNo]
        sbaddr  R1,HAL_IRQDisable_routine
        MOV     LR,PC
        LDMIA   R1,{R9,PC}
        Pull    "R0-R3,R9,R12"
03
 |
        ADD     R4,R9,#WinIDEIRQPtr     ; R4 -> address of irq mask reg
        ASSERT  WinIDEIRQBits = WinIDEIRQPtr + 4
        LDMIA   R4,{R4,R5}              ; get mask and bits
        LDRB    R1,[R9,#WinIDEHWType]
        SUBS    R1,R1,#WinIDEHW_Podule  ; motherboard? (NE if yes)
        LDRNEB  R1,[R4]                 ; yes, get IOC mask
        BIC     R1,R1,R5                ; clear enable bit
        STRB    R1,[R4]                 ; write to IOC/podule
 ]

 [ Debug22; :LOR: {TRUE}
;
        DLINE   "I",cc
;        DLINE   "IDE IRQ incoming..."
 ]

; Now safe for data transfer routines to reenable IRQs to improve
; IRQ latency - they must restore state on exit

; Set R3 -> TmpScatterEntry
;     R4,R5 = TmpScatterEntry
;     R7 = IDE command code of current op

        sbaddr  R3,WinIDETmpScatterEntry ; R3 -> tmp scatter entry
        LDMIA   R3,{R4,R5}              ; get tmp scatter entry
        LDRB    R7,WinIDECommandCode    ; R7 = IDE command code

 [ IDEDMA
        LDRB    LR,WinIDECommandFlags
        TST     LR,#WinIDECmdFlag_DMA
        BNE     %FT20
 ]

; Get status (will clear IRQ) and check for error

        LDRB    R8,IDERegStatus
        TSTS    R8,#IDEStatusErrorBits  ; test here for speed
        BNE     %FT80                   ; ...and branch if error

 [ Debug22

        DLINE   "No error - block transfer expected"
 ]

; No error - get blockSize (bytes of this sector to move)

        LDR     R6,WinIDEBlockSize      ; R0 = bytes to move

; R3 -> TmpScatterEntry
; R4,R5 = TmpScatterEntry
; R6 = bytes of this sector we want (blockSize)
; R7 = IDE command code of current command
; R8 = status from controller

; If read op, need to read data - check for DRQ first

        TEQS    R7,#IDECmdReadSecs      ; read?
        TEQNES  R7,#IDECmdReadSecsExt
        TSTEQS  R8,#IDEStatusDRQ        ; got DRQ?
        MOVEQ   R0,#WinIDEErrNoDRQ      ; error if not
        BEQ     %FT85

 [ Debug22

        DREG    R7, "Is a DRQ as expected for command "
 ]

; NE => not read or read and DRQ asserted

        TEQS    R7,#IDECmdReadSecs      ; read? (check again)
        TEQNES  R7,#IDECmdReadSecsExt
 [ Debug22
        BNE     %FT01
        LDR     LR, [R9,#WinIDEReadPtr]

        DREG    LR, "ReadSecs with routine at "
01
 ]
        MOVEQ   R1,R4                   ; if so, R1 = buf address
        MOVEQ   R0,R6                   ; ...R0 = bytes we want
        MOVEQ   LR,PC                   ; ...set link
        LDREQ   PC,[R9,#WinIDEReadPtr]  ; ...(R0,R1,IDE->R0,R1)
                                        ; ...returns here
 [ Debug22

        DLINE   "Update scatter list"
 ]

; Note: The read routine should have enabled IRQs whilst we have the
;       scatter list entry sitting in registers. This should be ok as
;       are supposed to disable interrupts only when writing to scatter
;       list and updating process block.
;       If read, IRQs are disabled now until leaving the IRQ routine.
;       Hence IRQs will be disabled from the final write to the scatter
;       list up to updating the process block as required.

; Now update a few things:
; adjust tmp scatter list entry for data transferred

        ADD     R4,R4,R6                ; bump scatter.address
        SUB     R5,R5,R6                ; decrement scatter.length
        STMIA   R3,{R4,R5}              ; write to tmp scatter entry

; adjust lump size

        LDR     R2,WinIDELumpSize       ; decrement bytes to go
        SUB     R2,R2,R6
        STR     R2,WinIDELumpSize

; adjust overall limit

        LDR     R0,WinIDETransferLimit
 [ Debug21a

        DREG    R0,"WinIDETransferLimit = "
 ]
        SUB     R0,R0,R6
        STR     R0,WinIDETransferLimit
 [ Debug21a

        DREG    R0,"WinIDETransferLimit = "
 ]

; See if this transfer is complete
; R2 = updated lumpsize

        CMPS    R2,#0
        BLE     %FT30                   ; branch if finished lump

 [ Debug22

        DLINE   "More of lump to do"
 ]
; More of this lump to do
; If we've exhausted this scatter list entry, move to next

        CMPS    R5,#0                   ; exhausted?
        BGT     %FT10                   ; branch if not

; Exhausted this scatter list entry - find next good entry

        LDR     R3,WinIDETmpScatterPtr  ; R3 -> scatter list
        ADD     R3,R3,#8                ; step to next entry
05
        LDMIA   R3,{R4,R5}              ; get the entry
 [ FixTBSAddrs
        CMN     R4,#ScatterListNegThresh; address < 0
        ADDCS   R3,R3,R4                ; add it in if so
        BCS     %BT05                   ; and go again
 |
        TEQS    R4,#0                   ; address < 0
        ADDMI   R3,R3,R4                ; add it in if so
        BMI     %BT05                   ; and go again
 ]

; Got a scatter list entry with a proper address.
; No need to check length as that was done when we determined the
; lumpsize for this IDE op and it must be non-zero if lump not
; finished.

        STR     R3,WinIDETmpScatterPtr
        sbaddr  R3,WinIDETmpScatterEntry ; save in tmp scatter entry
        STMIA   R3,{R4,R5}

10
; R2 = remaining lump size
; R3 -> TmpScatterEntry
; R4,R5 = TmpScatterEntry
; Set up blocksize for next sector
; This should be the minimum of the sector size and the size of the first
; entry in the scatter list. Since all except the final entry in the list
; must be a multiple of the sector size, it is ok to use the minimum of
; the sector size and the lump size.

        CMPS    R2,#WinIDEBytesPerSector        ; MIN(wanted, bytespersector)
        MOVHI   R2,#WinIDEBytesPerSector
        STR     R2,WinIDEBlockSize

; If write or format op, move data
; Should never be format because only one sector gets written per track
; and only one track at a time can be formatted.
; R7 = IDE command code
; R8 = status from controller

        TEQS    R7,#IDECmdWriteSecs     ; write?
        TEQNES  R7,#IDECmdWriteSecsExt
        TEQNES  R7,#IDECmdFormatTrk     ; ...or format ?
        BNE     %FT99                   ; return if not

; It's a write (or format)

        TSTS    R8,#IDEStatusDRQ        ; must have DRQ for write
        MOVEQ   R0,#WinIDEErrNoDRQ
        BEQ     %FT85                   ; error if not

 [ Debug22

        DLINE   "It's a write and DRQ is asserted - good"
 ]

; It IS write or format op and we have DRQ
; R3 still -> TmpScatterEntry
; R4,R5 still hold TmpScatterEntry

        MOV     R1,R4                   ; R1 -> buffer
        MOV     R0,R2                   ; R0 = bytes to move

; R0 = length to transfer (up to 512 bytes will be moved)
; R1 -> buffer
; call data write routine

 [ Debug22

        DLINE   "About to do a write"
 ]

        MOV     LR,PC                   ; set link
        LDR     PC,[R9,#WinIDEWritePtr] ; (R0,R1,IDE->R0,R1)
                                        ; returns here

; Do NOT adjust buffer address and lengths as the write may fail
; Note: the data write routine should have enabled IRQs.
;       However, the final write to the scatter list is not done
;       until the NEXT IRQ. Hence IRQs will be disabled from the
;       final write to the scatter list up to updating the process
;       block as required.

; All done for now

        B         %FT99

;****** Never fall through

 [ IDEDMA
20
; We got an interrupt in a DMA command - call ExamineTransfer to
; kick the DMA manager into checking status.

        LDRB    LR,WinIDEDMAStatus              ; Step 1 - check it
        TSTS    LR,#DMAStat_Completed           ; hasn't already completed
        LDRNE   R0,WinIDEDMAResult
        BNE     %FT22

        MOV     R0,#0                           ; Step 2 - if it hasn't
        BL      WinIDEExamineTransfer           ; prod the DMA Manager to
        MOVVC   R0,#0                           ; check again

        LDRB    LR,WinIDEDMAStatus              ; Step 3 - if it still hasn't
        TSTS    LR,#DMAStat_Completed           ; completed, kill it ourselves
        BLEQ    WinIDETerminateTransfer

22      TEQ     R0,#0
 [ {FALSE}
        BEQ     %FT26
        CMP     R0,#256
        BLO     %FT85
        LDR     LR, [R0]
        LDR     R8, =&C36
        TEQ     LR, R8
 ]
        BNE     %FT85

26      LDRB    R8,IDERegStatus                 ; this read clears the IRQ
        TSTS    R8,#IDEStatusErrorBits
        BNE     %FT80

; No error - lump has been transferred through DMA

        MOV     R6, #0
        STR     R6, WinIDELumpSize
        LDR     R6, WinIDESaveLumpSize
        LDR     LR, WinIDETransferLimit
        SUB     LR, LR, R6
        STR     LR, WinIDETransferLimit

; ****** Fall through
 ]

30
; End of lump so must have hit one of
; a) overall limit on transfer
; b) amount in scatter list when op started
; c) WinIDEMaxSectorsPerTransfer sectors
;
; IDE -> IDE controller
; R3 = TmpScatterPtr
; R4 = TmpScatterEntry.addr
; R5 = TmpScatterEntry.len
; R6 = previous block size
; R7 = current op
; R8 = status from controller (= OK - no longer needed)
 [ Debug22

;       DLINE   "E",cc
        DLINE   "End of lump"
 ]

; Update disc address by amount transferred
 [ BigDisc
        MOV     R1,R6                           ; save block size
        LDR     R2,WinIDEDiscAddress            ; get disc address...
        LDR     R6,WinIDESaveLumpSize           ; R6 = amount transferred
 [ Debug22

        DREG    R2,"Disc addr in: "
;       DREG    R3,"Sector offset in: "
        DREG    R6,"Lump size in: "
 ]
        ASSERT  WinIDEBytesPerSector=512        ;
        ADD     R2,R2,R6,LSR #9                 ; R2 = updated disc address
        STR     R2,WinIDEDiscAddress            ;
 [ Debug22

        DREG    R2,"Disc addr out: "
;       DREG    R3,"Sector offset out: "
 ]
 |
        MOV     R1,R6                           ; save block size
        LDR     R2,WinIDEDiscAddress            ; get disc address
        LDR     R6,WinIDESaveLumpSize           ; R6 = amount transferred
        ADD     R2,R2,R6                        ; R2 = updated disc address
        STR     R2,WinIDEDiscAddress            ; save it
 ]

 [ Debug20
        Push    "R1,R2"
        BL      WinIDEPhysAddrToLogical ; (IDE->R1,R2)
        Pull    "R1,R2"

        DREG    R2,"Calc "
 ]

; Update real scatter list with amount transferred
; This is ok even if the scatter list was faked as the first update
; will terminate the updating
; R6 = amount transferred

        LDR     R3,WinIDEScatterPtr     ; R3 -> scatter list at start of op
        BL      WinIDEUpdateScatterList ; (R3,R6->R3-R6,R8)
        MOV     R6,R1                   ; restore R6 = block size

; R2 = disc address of next sector
; R3 -> real scatter list
; R4,R5 = scatter list entry (possibly R5=0)
; R6 = size of previous lump

; Check if hit overall limit
; If no scatter list was provided, limit will be hit at same time as
; fake scatter list is exhausted so no problems

 [ Debug22

;       DLINE    "C",cc
        DLINE   "Consider whether to continue"
 ]
        LDR     R0,WinIDETransferLimit  ; check if hit limit
        CMPS    R0,#0
        MOVLE   R0,#0                   ; if done, set completion code...
        BLE     %FT90                   ; ...and branch

 [ Debug22

;       DLINE   "T",cc
        DREG    R0, "Continuing with transfer limit = "
 ]

; Not hit overall limit

        CMPS    R5,#0                   ; end of scatter entry?
        BGT     %FT40                   ; branch if not

; Exhausted this scatter list entry - find next good entry

        ADD     R3,R3,#8                ; step to next entry
35
        LDMIA   R3,{R4,R5}              ; get the entry
 [ FixTBSAddrs
        CMN     R4,#ScatterListNegThresh; address < 0
        ADDCS   R3,R3,R4                ; add it in if so
        BCS     %BT35                   ; and go again
 |
        TEQS    R4,#0                   ; address < 0
        ADDMI   R3,R3,R4                ; add it in if so
        BMI     %BT35                   ; and go again
 ]

; Got a scatter list entry with a proper address - check length

        TEQS    R5,#0                   ; zero length?
        MOVEQ   R0,#0                   ; if so, set completion code...
        BEQ     %FT90                   ; ...and branch

40
; More to do
; R2 = updated disc address
; R3 -> real scatter list
; R4,R5 hold scatter list entry

        LDR     LR,WinIDEFileCoreOp
        CMP     LR,#WinIDEFileCoreOpFormat

        BLNE    WinIDESetPhysAddress    ; set up for next xfer (R2,IDE->R0)
        BLEQ    WinIDESetPhysAddressCHS

; if ok, start the next transfer

        LDR     R4,WinIDETransferLimit  ; R4 = limit on transfer
 [ Debug21

;       DLINE   "S",cc
        DLINE   "Start transfer..."
 ]
        BL      WinIDEStartTransfer;InIRQ ; start next transfer
 [ Debug21

        DLINE   "Transfer start returned"
 ]
        BVC     %FT99                   ; all done if started ok
        B       %FT90                   ; branch if error

;****** Never fall through

80
; Drive error - decode status
;
; R3 -> TmpScatterPtr
; R4,R5 = TmpScatterEntry
; R7 = IDE command code
; R8 = contents of drive status register
; IDE -> IDE controller
 [ Debug22

        DREG    r8, "Drive error "
 ]

        MOV     R0,R8                   ; decode error
        BL      WinIDEDecodeDriveStatus ; (R0->R0)

; Set R3 -> real scatter list (start point of transfer)

        LDR     R3,WinIDEScatterPtr

; If the command was verify or write, we must adjust the amount remaining
; from the contents of the IDE registers: verify only gets an interrupt at
; the end or after error, not after each sector; write interrupts do not
; indicate whether the previous sector has been written to disc but only
; that the controller is ready to accept more data - the final interrupt
; indicates that all data has been written.
; SaveLumpSize tells us how much we WOULD have updated the transfer by
; if the entire op had succeeded. The sector register says how many sectors
; were not verified/written.

        LDRB    LR,WinIDECommandFlags
        TST     LR,#WinIDECmdFlag_DMA
        BNE     %FT83

        TEQS    R7,#IDECmdVerify        ; if not verify...
        TEQNES  R7,#IDECmdVerifyExt
 [ EngineeringMode
        TEQNES  R7,#IDECmdVerifyEng
 ]
        TEQNES  R7,#IDECmdWriteSecs     ; ...or write...
        TEQNES  R7,#IDECmdWriteSecsExt
        BNE     %FT85                   ; ...branch

83
; Op was verify or write or DMA

; Convert physical address back to logical address
; Do this by reading drive registers as, even though they may be unreliable
; in no error conditions, they *must* be valid in error conditions.

        BL      WinIDEPhysAddrToLogical ; (IDE->R1,R2)
        LDR     R1,WinIDEDiscAddress
        LDR     LR,WinIDESaveLumpSize   ; what we should have done (bytes)
        SUBS    R6,R2,R1                ; R6 = amount done (sectors or bytes)
 [ BigDisc
        ASSERT  WinIDEBytesPerSector = 512
        CMPGTS  LR,R6,LSL #9
 |
        CMPGTS  LR,R6
 ]

; R6 = amount verified/written before the error occurred.
; If >0 &&,<expected update the scatter list entry - this is all that
; needs to be updated as the op is now aborting.
; Otherwise, do NOT update scatter list - controller is misbehaving

        BLGT    WinIDEUpdateScatterList ; (R3,R6->R3-R6,R8)
        B       WinIDEIRQError

85
; Error:
;    a) status wrong
;    b) read but no DRQ
;    c) write but no DRQ

 [ Debug22

        DLINE   "Transfer expected, but DRQ not asserted"
 ]

; Convert physical address back to logical address
; Do this by reading drive registers as, even though they may be unreliable
; in no error conditions, they *must* be valid in error conditions.

        BL      WinIDEPhysAddrToLogical ; (IDE->R1,R2)


WinIDEIRQError
;
; An error has occurred during processing of the IRQ.
; (Also branched to when a command times out.)
; Possibles are
;    a) status wrong
;    b) read but no DRQ
;    c) write but no DRQ
;    d) timeout
;
; R0 = error code
; R2 = disc address of error
; R3 -> real scatter list
; R7 = IDE command code
; IDE -> IDE controller
;
; Read:
;    Must update the scatter list to indicate the amount read before
;    the error occurred.
; Verify:
;    If timeout, IDE registers are probably trashed so report the error
;    as occuring at the start of the verify. If not timeout, we have
;    already sorted out the error address and amount not verified.
; Write and Format:
;    If timeout, we cannot tell how much the drive actually wrote to the
;    disc so must return disc address = disc address at start of op and
;    not update the scatter list. If not timeout, we have already sorted
;    out the error address and updated the scatter list (for write).

 [ Debug22

        DLINE   "IDEIRQError - tidy up"
 ]

        TEQS    R7,#IDECmdReadSecs      ; read?
        TEQNES  R7,#IDECmdReadSecsExt
        LDREQ   R6,WinIDESaveLumpSize   ; if so, R6=intended xfer size
        LDREQ   R4,WinIDELumpSize       ; ...R4=amount not transferred
        SUBEQ   R6,R6,R4                ; ...R6=amount actually transferred
        BLEQ    WinIDEUpdateScatterList ; (R3,R6->R3-R6,R8)

 [ IDEDMA
        BL      WinIDETerminateTransfer
 ]

 [ IDEResetOnError

; Reset the drives to switch the access lights off
; Note: this also enables the interrupt in the drive controller

        BL      WinIDEResetDrives       ; preserves all regs
 ]

90
; Either:
;    a) found entry in scatter list with 0 length field or have hit
;       overall limit on op - we have finished
; or:
;    b) some error has occurred
; R0 = completion code
; R2 = disc address to return
; R3 -> scatter list

; Disable IRQs from IDE
; For podule, assumes that register is write-only and that bits other
; than the enable bit are safe to alter

 [ HAL
        LDRB    R1,[R9,#WinIDEHWType]
        TEQ     R1,#WinIDEHW_Podule
        LDREQ   R4,[R9,#WinIDEIRQPtr]           ; R4-> interrupt mask reg
        MOVEQ   R1,#0
        STREQB  R1,[R4]                         ; write to podule
        BEQ     %FT93
        Push    "R0-R3,R9,R12"
        LDRB    R0,[R9,#WinIDEIRQDevNo]
        sbaddr  R1,HAL_IRQDisable_routine
        MOV     LR,PC
        LDMIA   R1,{R9,PC}
        Pull    "R0-R3,R9,R12"
93
 |
        ADD     R4,R9,#WinIDEIRQPtr     ; R4 -> address of irq mask reg
        ASSERT  WinIDEIRQBits = WinIDEIRQPtr + 4
        LDMIA   R4,{R4,R5}              ; get mask and bits
        LDRB    R1,[R9,#WinIDEHWType]
        SUBS    R1,R1,#WinIDEHW_Podule  ; motherboard? (NE if yes)
        LDRNEB  R1,[R4]                 ; yes, get IOC mask
        BIC     R1,R1,R5                ; clear enable bit
        STRB    R1,[R4]                 ; write to IOC/podule
 ]

; R0 = completion code
; R2 = disc address
; R3 -> scatter list
; Call callback

 [ Debug22

        DLINE   "Finished - call callback"
 ]
        MOV     LR,PC                   ; save link
        LDR     PC,WinIDECallbackPtr    ; branch to callback routine

; Callback returns here

; Clear "in IRQ" flag

        MOV     R0,#0
        STRB    R0,WinIDEIRQFlag

        B       %FT100

99

; Common exit from IRQ routine
; Switches back to mode saved on stack in LR, clears "in irq" flag
; and reenables IRQ in IDE digital output register.

; Clear "in IRQ" flag

        MOV     R0,#0
        STRB    R0,WinIDEIRQFlag

 [ HAL
        LDRB    R1,[R9,#WinIDEHWType]
        TEQ     R1,#WinIDEHW_Podule
        ADDEQ   R4,R9,#WinIDEIRQPtr             ; R4-> address of irq mask reg
        ASSERT  WinIDEIRQBits = WinIDEIRQPtr + 4
        LDMEQIA R4,{R4,R5}                      ; get mask and bits
        STREQB  R5,[R4]                         ; write to podule
        BEQ     %FT101
        Push    "R0-R3,R9,R12"
        LDRB    R0,[R9,#WinIDEIRQDevNo]
        sbaddr  R1,HAL_IRQEnable_routine
        MOV     LR,PC
        LDMIA   R1,{R9,PC}
        Pull    "R0-R3,R9,R12"
101
 |
        ADD     R4,R9,#WinIDEIRQPtr      ; R4 -> address of irq mask reg
        ASSERT  WinIDEIRQBits = WinIDEIRQPtr + 4
        LDMIA   R4,{R4,R5}              ; get mask and bits
        LDRB    R1,[R9,#WinIDEHWType]
        SUBS    R1,R1,#WinIDEHW_Podule  ; motherboard? (NE if yes)
        LDRNEB  R1,[R4]                 ; yes, get IOC mask
        ORR     R1,R1,R5                ; set enable bit
        STRB    R1,[R4]                 ; write to IOC/podule
 ]

100

; Reenable IRQ in IDE controller.
; This happens even when there is nothing further to do as that
; latch is only used to kill interrupts during the IRQ routine. At
; all other times, it stays enabled.

;        MOV     R0,#0                   ; IEN
;        STRB    R0,IDERegDigOutput

 [ Debug22

        DLINE   "End of IRQ - return"
 ]

; Return from interrupt
; First restore SVC regs and switch back to original mode

        Pull    "$WinIDEIRQRegsB,LR"

        RestPSR R0,,c
        NOP

; Now back in original mode

        Pull    "$WinIDEIRQRegsA,PC"

        LTORG

;*********************************************************************

WinIDETimeout   ROUT
;
; Called when a timeout occurs on an IDE data transfer op which would
; normally have been terminated by an IRQ and thus would have been
; handler by WinIDEIRQHandler.
;
; Entry:
;    SB -> static workspace
;    MODE: IRQ or SVC
;    IRQs disabled
;
; Exit:
;    All registers preserved

; Switch to SVC mode as will join main thread of IRQ

        Push    "$WinIDEIRQRegsA,LR"    ; same regs as IRQHandler
        WritePSRc SVC_mode :OR: I_bit,LR,,R0
        NOP

; Now in SVC mode - save main regs

        Push    "$WinIDEIRQRegsB,LR"    ; same regs as IRQHandler

; Set up registers suitable for branching to IRQ code

 [ TwinIDEHardware
        LDR     R9,WinIDECurrentHW
 |
        sbaddr  R9,WinIDEHardware
 ]
 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        ASSERT  WinIDEPtr = 4
        LDMIA   R9,{IDECtrl,IDE}        ; IDE -> IDE hardware
 |
        LDR     IDE,[R9,#WinIDEPtr]
 ]

        LDR     R2,WinIDEDiscAddress    ; R2 = disc address of start of op
        LDRB    R7,WinIDECommandCode    ; R7 = IDE command code

; If it's read, adjust disc address by amount transferred so far
; (if write, cannot be sure where timeout occurred without examining
; the IDE registers which will be invalid).

        TEQS    R7,#IDECmdReadSecs      ; read?
        TEQNES  R7,#IDECmdReadSecsExt
 [ BigDisc
        LDREQ   R3,WinIDESaveLumpSize   ; if so, R3 = size of transfer
        LDREQ   R4,WinIDELumpSize       ; ...R4 = amount left to transfer
        SUBEQ   R3,R3,R4                ; ...R3 = amount transferred
        ASSERT  WinIDEBytesPerSector=512
        ADDEQ   R2,R2,R3,LSR #9         ; ...update R2
 |
        LDREQ   R3,WinIDESaveLumpSize   ; if so, R3 = size of transfer
        LDREQ   R4,WinIDELumpSize       ; ...R4 = amount left to transfer
        SUBEQ   R3,R3,R4                ; ...R3 = amount transferred
        ADDEQ   R2,R2,R3                ; ...update R2
 ]

        LDR     R3,WinIDEScatterPtr     ; R3 -> scatter list
        MOV     R0,#WinIDEErrTimeout    ; R0 = error code
 [ IDEDMA
        LDRB    LR,WinIDECommandFlags
        TST     LR,#WinIDECmdFlag_DMA   ; is it a DMA commond
        BEQ     WinIDEIRQError
        LDRB    LR,WinIDEDMAStatus      ; and has it completed?
        TST     LR,#DMAStat_Completed
        BEQ     WinIDEIRQError
        LDR     LR,WinIDEDMAResult      ; if so, get it's status
        TEQ     LR,#0
        MOVNE   R0,LR
 ]

; R0 = completion code
; R2 = disc address
; R3 -> real scatter list
; R7 = IDE command code
; Branch to IRQ handler which will tidy up and call the callback.

        B       WinIDEIRQError

;*********************************************************************

WinIDEDRQPoll   ROUT
;
; Called every centisecond from TickerV when we're waiting for DRQ for the
; first sector of a write op.
;
; Entry:
;    SB -> static workspace
;    MODE: IRQ or SVC
;    IRQs disabled
;
; Exit:
;    All registers preserved

; Switch to SVC mode as will join main thread of IRQ

        Push    "$WinIDEIRQRegsA,LR"    ; same regs as IRQHandler
        WritePSRc SVC_mode :OR: I_bit,LR,,R0
        NOP

; Now in SVC mode - save main regs

        Push    "$WinIDEIRQRegsB,LR"    ; same regs as IRQHandler

; Set up registers suitable for branching to IRQ code

 [ TwinIDEHardware
        LDR     R9,WinIDECurrentHW
 |
        sbaddr  R9,WinIDEHardware
 ]
 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        ASSERT  WinIDEPtr = 4
        LDMIA   R9,{IDECtrl,IDE}        ; IDE -> IDE hardware
 |
        LDR     IDE,[R9,#WinIDEPtr]
 ]

; Check for timeout
        LDR     R2,WinIDEDRQTimeout
        SUBS    R2,R2,#1
        BEQ     %FT95

; Check for DRQ
        LDRB    R0,IDERegAltStatus
        TST     R0,#IDEStatusDRQ
        STREQ   R2,WinIDEDRQTimeout
        MOVEQ   R2,#1
        BEQ     %FT90

; got DRQ so write data

        LDR     R1,WinIDETmpScatterEntry        ; R1 -> buffer
        LDR     R0,WinIDEBlockSize              ; R0 = max bytes to move

; R0 = length to transfer (up to 512 bytes will be moved)
; R1 -> buffer
; Call data write routine

        MOV     LR,PC                           ; set link
        LDR     PC,[R9,#WinIDEWritePtr]         ; (R0,R1,IDE->R0,R1)
                                                ; returns here

; Restore standard ticker routine
        ADR     R2,WinIDETimeout
        STR     R2,WinTickCallAddress
        
90
        STR     R2,WinTickCount
; First restore SVC regs and switch back to original mode

        Pull    "$WinIDEIRQRegsB,LR"

        RestPSR R0,,c
        NOP

; Now back in original mode

        Pull    "$WinIDEIRQRegsA,PC"

95
        MOV     R0,#WinIDEErrNoDRQ      ; R0 = error code
        LDR     R2,WinIDEDiscAddress    ; R2 = disc address of start of op
        LDR     R3,WinIDEScatterPtr     ; R3 -> scatter list
        LDRB    R7,WinIDECommandCode    ; R7 = IDE command code
        B       WinIDEIRQError

;*********************************************************************

WinIDEUpdateScatterList ROUT
;
; Updates scatter list by the length of a transfer
;
; Entry:
;    R3 -> scatter list
;    R6 = amount transferred
;
; Exit:
;    R3 updated
;    R4,R5 = final scatter list entry
;    R8 undefined
;    All other registers preserved

10
        LDMIA   R3,{R4,R5}              ; get scatter list entry
 [ FixTBSAddrs
        CMN     R4,#ScatterListNegThresh; wrap?
        ADDCS   R3,R3,R4                ; add in if so
        BCS     %BT10                   ; and go again
 |
        TEQS    R4,#0                   ; wrap?
        ADDMI   R3,R3,R4                ; add in if so
        BMI     %BT10                   ; and go again
 ]

; found non-negative scatter list entry

        CMPS    R6,R5                   ; if total > this entry
        MOVCS   R8,R5                   ; ...R8 = this entry
        MOVCC   R8,R6                   ; else R8 = total
        ADD     R4,R4,R8                ; adjust scatter.addr
        SUB     R5,R5,R8                ; adjust scatter.len
        STMIA   R3,{R4,R5}              ; write to scatter list
 [ Debug21

        DREG    R4,"Scatter list addr ="
        DREG    R5,"Scatter list len  ="
 ]
        SUBS    R6,R6,R8                ; adjust total
        ADDGT   R3,R3,#8                ; if more, step to next entry
        BGT     %BT10                   ; ...and go again

        MOV     PC,LR                   ; return

;*********************************************************************

WinIDECallbackFg        ROUT
;
; The callback routine for the foreground part of background ops.
; Called on completion of the transfer.
;
; Entry:
;    R0 = completion code
;    R2 = disc address
;    R3 -> scatter list
;    IDE -> IDE controller
;    SB -> static workspace
;    MODE: SVC
;    IRQs disabled
;
; Exit:
;    R0 undefined

; save completion code, disc address and scatter list pointer for foreground

 [ BigDisc
; sector offset should be valid at this point
 ]

 [ Debug22
        DREG    R0,"CallbackFg: completion code="
 ]
        STRB    R0,WinIDECompletion
        STR     R2,WinIDEDiscAddress
        STR     R3,WinIDEScatterPtr

; cancel timer

        MOV     R0,#0
        STR     R0,WinTickCallAddress
        STR     R0,WinTickCount                 ; speeds up ticker routine

; tell foreground that we've finished

        MOV     R0,#&FF
        STRB    R0,WinIDEOpDone
        MOV     R0,#0
;       STR     R0,WinIDELumpSize
;       STR     R0,WinIDESaveLumpSize
        MOV     PC,LR                           ; and return

;*********************************************************************

WinIDECallbackBg        ROUT
;
; The callback routine for the background part of background ops.
; Called on completion of the transfer.
;
; Entry:
;    R0 = completion code
;    R2 = disc address
;    R3 -> scatter list
;    IDE -> IDE controller
;    SB -> static workspace
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    All registers preserved
;    WinIDEDiscAddress is not updated

        Push    "R0-R5,LR"

 [ BigDisc
; sector offset should be valid at this point
 ]

 [ Debug22
        DREG    R0,"CallbackBg: completion code="
 ]

; Cancel timer

        MOV     R1,#0
        STR     R1,WinTickCallAddress
        STR     R1,WinTickCount         ; speeds up ticker routine

; Call WinIDEAdjustStatus to put completion code in format suitable for
; FileCore

 [ BigDisc
        BL      WinIDEAdjustStatus      ; (R0,R2,R5->R0,R1,R2,R6,V)
 |
        BL      WinIDEAdjustStatus      ; (R0,R2->R0,R2,R5,V)
 ]

; Set process status

        TEQS    R0,#0                   ; error?
        MOVEQ   R1,#0                   ; if not, status = 0
        MOVNE   R1,R3                   ; else status -> scatter entry

; Now update process block
; R0 = process error word
; R1 = process status
; R3 -> scatter list
;
; Find start of scatter list

        MOV     R4,R3                   ; R4 -> scatter list
10
        LDR     R5,[R4,#8]!             ; get next entry
 [ FixTBSAddrs
        CMN     R5,#ScatterListNegThresh; backwards offset?
        BCC     %BT10                   ; branch if not
 |
        TEQS    R5,#0                   ; backwards offset?
        BPL     %BT10                   ; branch if not
 ]

; found negative buffer address - must be offset to start of scatter list
; store process error & status

 [ NewErrors
        BL      ConvertErrorForParent
        LDRB    LR, NewErrorsFlag
        TEQS    LR, #0                  ; new FileCore?
        MOVNE   R1, R1, LSR #2          ; then store ms 30 bits
 ]

        ADD     R4,R4,R5                ; R4 -> top of scatter list
        STMDB   R4,{R0,R1}              ; write process error & status

; Before calling FileCore, unlock the controller as FileCore may call the
; driver low-level entry point from its callback routine

        BL      UnlockIDEController

; Save registers and call FileCore in SVC mode.
; NOTE: despite documentation, it does not preserve R2

        MOV     R1,SB                   ; save static base

        LDR     SB,FileCorePrivate      ; uses our SB
        MOV     LR,PC                   ; set return address
        LDR     PC,[R1,#:INDEX:WinnieCallAfter] ; preserves R0-R1,R3-R11,R13

; Call to FileCore returns here

        MOV     SB,R1                   ; restore static base

        Pull    "R0-R5,PC"

;*********************************************************************

WinIDECallbackBg_LockFailed        ROUT
;
; The callback routine for the background part of background ops.
; Called on completion of the transfer.
;
; Entry:
;    R0 = completion code
;    R2 = disc address
;    R3 -> scatter list
;    IDE -> IDE controller
;    SB -> static workspace
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    All registers and flags preserved
;    WinIDEDiscAddress is not updated

        Push    "R0-R5,LR"

 [ BigDisc
; sector offset should be valid at this point
 ]

; Cancel timer

        MOV     R1,#0
        STR     R1,WinTickCallAddress
        STR     R1,WinTickCount         ; speeds up ticker routine

; Call WinIDEAdjustStatus to put completion code in format suitable for
; FileCore

 [ BigDisc
        BL      WinIDEAdjustStatus      ; (R0,R2,R5->R0,R1,R2,R6,V)
 |
        BL      WinIDEAdjustStatus      ; (R0,R2->R0,R2,R5,V)
 ]

; Set process status

        TEQS    R0,#0                   ; error?
        MOVEQ   R1,#0                   ; if not, status = 0
        MOVNE   R1,R3                   ; else status -> scatter entry

; Now update process block
; R0 = process error word
; R1 = process status
; R3 -> scatter list
;
; Find start of scatter list

        MOV     R4,R3                   ; R4 -> scatter list
10
        LDR     R5,[R4,#8]!             ; get next entry
 [ FixTBSAddrs
        CMN     R5,#ScatterListNegThresh; backwards offset?
        BCC     %BT10                   ; branch if not
 |
        TEQS    R5,#0                   ; backwards offset?
        BPL     %BT10                   ; branch if not
 ]

; found negative buffer address - must be offset to start of scatter list
; store process error & status

 [ NewErrors
        BL      ConvertErrorForParent
        LDRB    LR, NewErrorsFlag
        TEQS    LR, #0                  ; new FileCore?
        MOVNE   R1, R1, LSR #2          ; then store ms 30 bits
 ]

        ADD     R4,R4,R5                ; R4 -> top of scatter list
        STMDB   R4,{R0,R1}              ; write process error & status

; Before calling FileCore, unlock the controller as FileCore may call the
; driver low-level entry point from its callback routine

;        BL      UnlockIDEController

; Save registers and call FileCore in SVC mode.
; NOTE: despite documentation, it does not preserve R2

        MOV     R1,SB                   ; save static base

        LDR     SB,FileCorePrivate      ; uses our SB
        MOV     LR,PC                   ; set return address
        LDR     PC,[R1,#:INDEX:WinnieCallAfter] ; preserves R0-R1,R3-R11,R13

; Call to FileCore returns here

        MOV     SB,R1                   ; restore static base

        Pull    "R0-R5,PC"
;*********************************************************************

WinIDESetPhysAddress    ROUT
;
; Calculates the physical disc address and stores it in the parameter
; block.  LBA addressing will be used if enabled for this drive,
; otherwise CHS will be used (by calling WinSetIDEPhysAddressCHS)
;
; Use of LBA is far faster than CHS because shifts used all over
; the place - no need for divide.
;
; Entry:
;
;    R2 = disc address
;    WinIDEDriveNum valid
;
; Exit:
;    R0 undefined
;    All other registers preserved
;

        Push    "R1,R3,LR"
        SavePSR R3

        LDRB    R1,WinIDEDriveNum       ; get drive number
        sbaddr  LR,WinIDEDriveLBAFlags  ; get addr of flags
        LDRB    R0,[LR,R1]              ; get CHS/LBA flag
        CMP     R0,#0
        BEQ     %FT10                   ; choose CHS/LBA from flag

        BIC     R0,R2,#DiscBits         ; R0 = disc addr minus drive num

 [ BigDisc
        CMPS    R0,#7                   ; are we in early disk address?
        BLO     %FT10                   ; if so, use CHS
 |
        CMPS    R0,#BootEnd             ; are we in early disk address?
        BLO     %FT10                   ; if so, use CHS
 ]

        ; use LBA addressing as drive supports it

 [ BigDisc
 |
        ASSERT  WinIDEBytesPerSector = 512
        MOV     R0,R0,LSR #9            ; LBA number, ie sector number (from disc start)
 ]

        ; bits 0..7 of LBA

        STRB    R0,WinIDEParmLBA0to7

        ; bits 8..15 of LBA

        MOV     R0,R0,LSR #8
        STRB    R0,WinIDEParmLBA8to15

        ; bits 16..23 of LBA

        MOV     R0,R0,LSR #8
        STRB    R0,WinIDEParmLBA16to23

        MOV     R0,R0,LSR #8
 [ BigDisc
        LDRB    LR,WinIDECommandFlags
        TST     LR,#WinIDECmdFlag_48bit
        BEQ     %FT05

        STRB    R0,WinIDEParmLBA24to31
        MOV     R0,#0
        STRB    R0,WinIDEParmLBA32to39
        STRB    R0,WinIDEParmLBA40to47
 ]

        ; now drive, 24..27 of LBA and the LBA flag

05      ORR     R0,R0,#IDEDrvLBA24to27MagicBits         ; magic bits - with LBA flag set
        ORR     R0,R0,R1,LSL #IDEDriveShift             ; insert drive number
        STRB    R0,WinIDEParmDrvLBA24to27               ; and store

        RestPSR R3
        Pull    "R1,R3,PC"

10
        ; use CHS addressing - drive doesn't support LBA
        RestPSR R3
        Pull    "R1,R3,LR"

        ASSERT  . = WinIDESetPhysAddressCHS

;*********************************************************************

WinIDESetPhysAddressCHS    ROUT
;
; Calculates cylinder/head/sector and stores them in parameter block.
;
;
; Entry:
;    R2 = disc address
;    IDE -> IDE controller
;    WinIDEDriveNum, WinIDESecsPerTrk, WinIDEHeads valid
;
; Exit:
;    R0 undefined
;    All other registers preserved
;    WinIDEParms updated

        Push    "R1,R3,LR"
        SavePSR R3

 [ Debug20

        DREG    R2,"WinIDESetPhysAddressCHS "
        ADRL    LR, WinIDEParmSecNumber
        DREG    LR, "WinIDESetPhysAddressCHS: WinIDEParmSecNumber="
        ADRL    LR, WinIDEParmCylLo
        DREG    LR, "WinIDESetPhysAddressCHS: WinIDEParmCylLo="
        ADRL    LR, WinIDEParmCylHi
        DREG    LR, "WinIDESetPhysAddressCHS: WinIDEParmCylHi="
 ]

; convert disc address to physical address

        BIC     R0,R2,#DiscBits         ; R0 = disc address (minus drive num)

 [ BigDisc
 |
        ASSERT  WinIDEBytesPerSector = 512
        MOV     R0,R0,LSR #9            ; R0 = sector number (from disc start)
 ]
        LDRB    R1,WinIDESecsPerTrk
        BL      Divide                  ; R0 div R1 -> R0 remainder R1

; R0 = tracks
; R1 = sector on track from 0

        ADD     R1,R1,#WinIDELowSector  ; adjust sector according to lowest
 [ Debug20

        DREG    R1,"WinIDESetPhysAddressCHS: ParmSecNumber=",cc,Byte
 ]
        STRB    R1,WinIDEParmSecNumber
 [ Debug20

        DLINE   "...set"
 ]

; R0 = tracks

        LDRB    R1,WinIDEHeads          ; get number of heads
        BL      Divide                  ; R0 div R1 -> R0 remainder R1

; R0 = cylinder number from 0
; R1 = head number from 0
; save cylinder parameters

 [ Debug20

        DREG    R0,"WinIDESetPhysAddressCHS: ParmCylLo=",cc,Byte
 ]
        STRB    R0,WinIDEParmCylLo
        MOV     R0,R0,LSR #8
 [ Debug20

        DLINE   "...set"
        DREG    R0,"WinIDESetPhysAddressCHS: ParmCylHi=",cc,Byte
 ]
        STRB    R0,WinIDEParmCylHi
 [ Debug20

        DLINE   "...set"
 ]

; Fall through to WinIDESetDrvHead to work out drive/head parameter
; R1 = head number

        MOV     R0,R1
        RestPSR R3
        Pull    "R1,R3,LR"
        ASSERT  . = WinIDESetDriveAndHead

;*********************************************************************

WinIDESetDriveAndHead   ROUT
;
; Sets up the drive/head parameter byte.
;
; Entry:
;    R0 = head number
;    WinIDEDriveNum = drive number
;
; Exit:
;    R0 undefined
;    All other registers preserved
;    WinIDEParmDrvHead valid

        Push    "LR"

        AND     R0,R0,#&0F                      ; must only be b0..b3
        LDRB    LR,WinIDEDriveNum               ; get drive number
        ORR     R0,R0,LR,LSL #IDEDriveShift     ; put it in place
        ORR     R0,R0,#IDEDrvHeadMagicBits      ; include magic bits
        STRB    R0,WinIDEParmDrvHead

        Pull    "PC"

;*********************************************************************

WinIDESupports48bit   ROUT
;
; Tests whether a drive supports 48-bit addressing
;
; Entry:
;    WinIDEDriveNum = drive number
;
; Exit:
;    R0 undefined
;    EQ if supports 48-bit, NE otherwise

        Push    "LR"

        LDRB    LR,WinIDEDriveNum               ; get drive number
        ADR     R0,WinIDEDeviceNoIdFlags
        LDRB    R0,[LR,R0]                      ; check it had Identify info
        TEQ     R0,#0
        Pull    "PC",NE
        sbaddr  R0,WinIDEDeviceIds
        ADD     R0,R0,LR,LSL #9
        LDR     R0,[R0,#WinIDEIdCommandSets2]   ; check magic "01" marker in word
        AND     LR,R0,#&C000
        TEQ     LR,#&4000
        Pull    "PC",NE
        AND     LR,R0,#IICS2_48bit
        TEQ     LR,#IICS2_48bit
        Pull    "PC"

;*********************************************************************

WinIDECommandDisc      ROUT
;
; Writes parameters and command to the IDE system, assuming that the
; address (drive/cylinder/head/start sector) has already been set up.
; Checks controller not busy, checks drive ready and only then writes
; to the drive.
;
; Entry:
;    R0 = b7..b0 = command
;         b8 => don't wait for DRDY
;         b9 => 48-bit LBA command
;    IDE -> IDE controller
;    WinIDEParms contain parameters for command
;    WinIDEHardware onwards contains details of IDE hardware
;
; Exit:
;    VS => error
;          R0 = error code (controller busy or drive not ready)
;    VC => all ok
;          R0 preserved
;    All other registers preserved

        Push    "LR"
        BL      WinIDECommandDisc_Checks
        BLVC    WinIDECommandDisc_Start
        Pull    "PC"

WinIDECommandDisc_Checks
        Push    "R1,LR"

; check controller not busy

        LDRB    LR,IDERegAltStatus              ; get status
        TSTS    LR,#IDEStatusBSY
 [ Debug21
        BREG    LR, "WinIDECommandDisc: AltStatus="
 ]

; return error if busy

        MOVNE   R0,#WinIDEErrCmdBusy
        SETV    NE                              ; preserves NE
        Pull    "R1,PC",NE

; not busy, select drive

        LDRB    LR,WinIDEParmDrvHead            ; select drive
        STRB    LR,IDERegDrvHead
 [ Debug21
        BREG    LR, "WinIDECommandDisc: Head set to "
 ]

; Wait for other bits in status to become valid

        MOV     R1,R0                           ; save command in R1
        MOV     R0,#1*2                         ; 1/2 us units
        BL      DoMicroDelay
        MOV     R0,R1                           ; put command back in R0

; check drive ready

        LDRB    LR,IDERegAltStatus              ; get status
 [ Debug21
        BREG    LR, "WinIDECommandDisc: AltStatus="
 ]
        TSTS    R0,#WinIDECmdFlag_NoDRDY:SHL:8
        ORRNE   LR,LR,#IDEStatusDRDY
        AND     LR,LR,#IDEStatusBSY :OR: IDEStatusDRDY
        TEQS    LR,#IDEStatusDRDY
        MOVNE   R0,#WinIDEErrCmdNotRdy          ; return error if not ready
        SETV    NE                              ; preserves NE
        Pull    "R1,PC"


WinIDECommandDisc_Start

        Push    "LR"

; drive ready so write parms to it <<<can optimise this bit by aligning parms

        TSTS    R0,#WinIDECmdFlag_48bit:SHL:8
        BEQ     %FT20

        LDRB    LR,WinIDEParmSecCountHigh
 [ Debug20
        BREG    LR,"WinIDECommandDisc: SecCountHigh="
 ]
        STRB    LR,IDERegSecCount

        LDRB    LR,WinIDEParmLBA24to31
 [ Debug20
        BREG    LR,"WinIDECommandDisc: LBA24to31="
 ]
        STRB    LR,IDERegLBALow

        LDRB    LR,WinIDEParmLBA32to39
 [ Debug20
        BREG    LR,"WinIDECommandDisc: LBA32to39="
 ]
        STRB    LR,IDERegLBAMid

        LDRB    LR,WinIDEParmLBA40to47
 [ Debug20
        BREG    LR,"WinIDECommandDisc: LBA40to47="
 ]
        STRB    LR,IDERegLBAHigh

20
        LDRB    LR,WinIDEParmPrecomp
 [ Debug20
        BREG    LR,"WinIDECommandDisc: Precomp="
 ]
        STRB    LR,IDERegFeatures

        LDRB    LR,WinIDEParmSecCount
 [ Debug20
        BREG    LR,"WinIDECommandDisc: SecCount="
 ]
        STRB    LR,IDERegSecCount

        LDRB    LR,WinIDEParmLBA0to7
 [ Debug20
        BREG    LR,"WinIDECommandDisc: LBA0to7="
 ]
        STRB    LR,IDERegLBALow

        LDRB    LR,WinIDEParmLBA8to15
 [ Debug20
        BREG    LR,"WinIDECommandDisc: LBA8to15="
 ]
        STRB    LR,IDERegLBAMid

        LDRB    LR,WinIDEParmLBA16to23
 [ Debug20
        BREG    LR,"WinIDECommandDisc: LBA16to23="
 ]
        STRB    LR,IDERegLBAHigh

        LDRB    LR,WinIDEParmDrvHead
 [ Debug20
        BREG    LR,"WinIDECommandDisc: DrvHead="
 ]
        STRB    LR,IDERegDrvHead

 [ Debug20
        BREG    R0,"WinIDECommandDisc: Command="
 ]
        STRB    R0,IDERegCommand
 [ Debug20

        DLINE   "WinIDECommandDisc: disc commanded successfully"
 ]

        Pull    "PC"                            ; no error

;*********************************************************************

WinIDEDecodeDriveStatus ROUT
;
; Decodes drive status into an error number
;
; Entry:
;    R0 = contents of status register
;    IDE -> IDE controller
;
; Exit:
;    R0 = error code or 0
;    All other registers preserved
;
; There must be a better way to do this!

        TSTS    R0,#IDEStatusBSY        ; drive busy?
        MOVNE   R0,#WinIDEErrBusy       ; if so, return it
        MOVNE   PC,LR

        TSTS    R0,#IDEStatusDF         ; write fault?
        MOVNE   R0,#WinIDEErrWFT        ; if so, return it
        MOVNE   PC,LR

        TSTS    R0,#IDEStatusERR        ; other error?
        MOVEQ   R0,#0                   ; if not, return no error
        MOVEQ   PC,LR

; error given by contents of error register

        LDRB    R0,IDERegError          ; get error reg
        ASSERT  IDEErrorBBK = IDEErrorICRC
        TSTS    R0,#IDEErrorBBK         ; bad block / interface CRC?
        BNE     %FT10                   ; if so, check which

        TSTS    R0,#IDEErrorUNC         ; uncorrected data error?
        MOVNE   R0,#WinIDEErrUNC        ; if so, return it
        MOVNE   PC,LR

        TSTS    R0,#IDEErrorIDNF        ; sector id not found?
        MOVNE   R0,#WinIDEErrIDNF       ; if so, return it
        MOVNE   PC,LR

        TSTS    R0,#IDEErrorABRT        ; command abort?
        MOVNE   R0,#WinIDEErrABRT       ; if so, return it
        MOVNE   PC,LR

        TSTS    R0,#IDEErrorNTK0        ; can't find track 0?
        MOVNE   R0,#WinIDEErrNTK0       ; if so, return it
        MOVNE   PC,LR

        TSTS    R0,#IDEErrorNDAM        ; no data address mark?
        MOVNE   R0,#WinIDEErrNDAM       ; if so, return it

        MOVEQ   R0,#WinIDEErrUnknown    ; else must be unknown error
        MOV     PC,LR

10      LDRB    R0,WinIDECommandFlags   ; check command flags
        TST     R0,#WinIDECmdFlag_DMA   ; to decide whether its ICRC
        MOVNE   R0,#WinIDEErrICRC       ; or BBK
        MOVEQ   R0,#WinIDEErrBBK
        MOV     PC,LR
;*********************************************************************

WinIDEDecodeATAPIStatus ROUT
;
; Decodes drive status into an error number
;
; Entry:
;    R0 = contents of status register
;    IDE -> IDE controller
;
; Exit:
;    R0 = error code or 0
;    All other registers preserved
;
; There must be a better way to do this!

        TSTS    R0,#ATAPIStatusBSY      ; drive busy?
        MOVNE   R0,#WinIDEErrBusy       ; if so, return it
        MOVNE   PC,LR

        TSTS    R0,#ATAPIStatusCHK      ; other error?
        MOVEQ   R0,#0                   ; if not, return no error
        MOVEQ   PC,LR

        TSTS    R0,#IDEStatusDF         ; write fault?
        MOVNE   R0,#WinIDEErrWFT        ; if so, return it
        MOVNE   PC,LR

; error given by contents of error register

        LDRB    R0,IDERegError          ; get error reg
        TSTS    R0,#ATAPIErrorABRT      ; command abort?
        MOVNE   R0,#WinIDEErrABRT       ; if so, return it
        MOVNE   PC,LR

        TSTS    R0,#ATAPIErrorSense:OR:ATAPIErrorEOM:OR:ATAPIErrorILI
        MOVNE   R0,#WinIDEErrPacket     ; miscellaneous Packet error response

        MOVEQ   R0,#WinIDEErrUnknown    ; else must be unknown error
        MOV     PC,LR

;*********************************************************************

WinIDEPhysAddrToLogical ROUT
;
; Calculate logical disc address of current sector from contents
; of IDE registers - does not include this sector.
;
; if CHS mode is in use then
;
; = ((cylinder * heads + head) * sectorspertrk + sector) * sectorsize
;
; else
;
; = LBA * sectorsize
;
; fi
;
; To determine CHS/LBA operation, the routine reads the drive
; select bit from the controller, and uses this to check the
; CHS/LBA mode of the drive.
;
; NOTE: if all is ok
;          the IDE registers contain the address of the last sector
;          transferred, not the next to be transferred which is what we want
;          to return (i.e. need to add 1 sector)
;       if an error occurred
;          the registers contain the address of the sector where the error
;          occurred which IS what we want to return.
;       The caller will have to adjust the address accordingly
;
; Entry:
;    IDE controller registers valid
;    IDE -> controller
;    SB -> static workspace
;
; Exit:
;    R1 undefined
;    R2 = logical disc address (without drive bits)

; first, we decide if current drive is to use CHS or LBA, by
; reading the LBA/CHS bit from the SDH register

        LDRB    R2,IDERegDrvHead        ; get drive/head in R2
        TST     R2,#&40                 ; check LBA bit
        BNE     %FT10                   ; if set, use LBA code

; use CHS...

        LDRB    R2,IDERegCylLo
        LDRB    R1,IDERegCylHi
        ORR     R2,R2,R1,LSL #8         ; R2 = cylinder

        LDRB    R1,WinIDEHeads          ; R1 = heads
        MUL     R2,R1,R2                ; R2 = whole cylinders * trackspercyl
        LDRB    R1,IDERegDrvHead        ; R1 = selected head
        AND     R1,R1,#&0F              ; mask to get head number
        ADD     R2,R2,R1                ; R2 = whole tracks

        LDRB    R1,WinIDESecsPerTrk     ; R1 = sectors on each track
        MUL     R2,R1,R2                ; R2 = sectors on whole tracks
        LDRB    R1,IDERegSecNumber      ; R1 = sector on current track
        ADD     R2,R2,R1                ; R2 = whole sectors

; R2 now contains the sector address indicated by the IDE registers.
; We need to adjust this because the sectors may (will) not start at 0.

        SUB     R2,R2,#WinIDELowSector  ; adjust sector number

; R2 = adjusted sector number - convert to a byte address

 [ BigDisc
 |
        ASSERT  WinIDEBytesPerSector = 512
        MOV     R2,R2,LSL #9
 ]
 [ Debug20

        DREG    R2,"Get "
 ]
        MOV     PC,LR

10
; generate the info based on the LBA addressing mechanism
; we may already have some of the address in R2, bits 24..27

        LDRB    R1,WinIDECommandFlags
        AND     R2,R2,#&0f              ; mask off LBA/DRV/magic bits

; now check whether this is a 48-bit command
        TST     R1,#WinIDECmdFlag_48bit
        BNE     %FT48

15      LDRB    R1,IDERegLBAHigh        ; get bits 16..23
        ORR     R2,R1,R2,LSL #8         ; shove them in
        LDRB    R1,IDERegLBAMid         ; get bits 8 to 15
        ORR     R2,R1,R2,LSL #8         ; shove them in
        LDRB    R1,IDERegLBALow         ; get bits 0 to 7
        ORR     R2,R1,R2,LSL #8         ; shove them in

 [ BigDisc
 |
        ASSERT  WinIDEBytesPerSector = 512
        MOV     R2,R2,LSL #9
 ]

 [ Debug20

        DREG    R2,"Get "
 ]
        MOV     PC,LR

; code fragment to deal with reading 48-bit LBA addresses
48      MOV     R1,#IDEDevCtrlHOB       ; switch to high order bits
        STRB    R1,IDERegDevCtrl
        LDRB    R2,IDERegLBALow         ; get bits 24..31
        MOV     R1,#0
        STRB    R1,IDERegDevCtrl        ; back to low order
        B       %BT15



 [ :LNOT: NewTransferCode

;*********************************************************************

WinIDEInstallTransferCode       ROUT
;
; Installs code to move data to/from the IDE disc in RAM (for speed).
; When the transfer is to be made, WinIDEReadASector or
; WinIDEWriteASector should be called. For entry conditions, see those
; routines.
;
; NOTE: we have to use a different variable to that used by the ST506 driver
;       to record what sort of transfer code is currently in RAM because we
;       HAVE to use MEMC1 code whereas the ST506 driver may use MEMC1A code.
;       We must be sure to invalidate the ST506 driver's variable and it
;       must invalidate ours as and when.
;
; Entry (to this routine):
;    R1 = filecore opcode
;
; Exit:
;    R0 undefined
;    All other registers and flags preserved

; check that this op really does need data transfer code

        AND     R0,R1,#DiscOp_Op_Mask           ; get opcode
        TEQS    R0,#DiscOp_WriteTrk             ; format?
        MOVEQ   R0,#DiscOp_WriteSecs            ; if so, treat as write

        TEQS    R0,#DiscOp_ReadSecs             ; is it read ?
        TEQNES  R0,#DiscOp_WriteSecs            ; if not, is it write ?
        MOVNE   PC,LR                           ; if not needed, return

; this op *does* need transfer code
; <<<can optimise by checking if using our code or podule's

; see what code is currently in RAM

        Push    "LR"

        LDRB    LR,WinIDERAMOp          ; find out what code's installed
        TEQS    R0,LR                   ; the one we want?
        Pull    "PC",EQ                 ; if so, return

; code in RAM not the one we want so copy new code

        Push    "R1-R10"

 [ Debug21
        BREG    R0,"Copying code to RAM for op: "
 ]

; Copy new code into RAM.

        ADDR     R10,LowCodeLocation     ; R10 -> where code will go
        TEQS    R0,#DiscOp_ReadSecs
        baddr   R9,ALowReadCodeStart,EQ ; R9 -> code to copy
        baddr   R9,ALowWriteCodeStart,NE
        ADDEQ   LR,R10,#ALowReadCodeSize ; R10 = start + len
        ADDNE   LR,R10,#ALowWriteCodeSize
 [ Debug21

        DREG    R9,"Code source "
        DREG    r10,"Code destination "
        DREG    LR,"Destination end "
 ]

; copy the code
10
        LDMIA   R9!,{R1-R8}
        STMIA   R10!,{R1-R8}
        CMPS    R10,LR
        BLO     %BT10

; note what we've copied

        STRB    R0,WinIDERAMOp

 [ StrongARM
        ;synchronise with respect to modified code
        MOV     R0,#1                    ;means range specified in R1,R2
        ADDR     R1,LowCodeLocation       ;start virtual address
        SUB     R2,R10,#4                ;end virtual address (inclusive)
        SWI     XOS_SynchroniseCodeAreas ;do the necessary for extant ARM variant
 ]

; invalidate WinnieRamOp so ST506 driver doesn't get confused

        MOV     R0,#&FF
        STRB    R0,WinnieRamOp
 [ Debug21

        DLINE   "Code copied successfully"
 ]

        Pull    "R1-R10,PC"

 ]

;*********************************************************************

WinIDEReadASector       ROUT
 [ :LNOT:NewTransferCode
WinIDEReadASector32
 ]
;
; Reads up to a sector of data from IDE to RAM.
;
; Entry:
;    R0 = length to transfer > 0
;    R1 -> buffer
;    IDE -> IDE controller
;    LR = return address
;    Transfer code has been copied to LowCodeLocation
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    R0 undefined
;    R1 updated
;    All other registers and flags preserved
;    IRQ state preserved but IRQs are enabled during call.

 [ Debug20 :LAND: {FALSE}

        DLINE   "r",cc
 ]
        Push    "R2-R8,R10,LR"

; Enable interrupts to improve latency

        WritePSRc SVC_mode,R8,,LR       ; enable IRQs
        Push    "LR"
 [ Debug22

        DREG    r0, "Read ",cc
        DREG    r1, " bytes to "
 ]

        ASSERT  WinIDEBytesPerSector = 512
        CMPS    R0,#&200                ; whole block?
        BCC     %FT10

; >= &200  bytes to transfer - use RAM-based code

 [ :LNOT: NewTransferCode
; load mask for RAM code - MOV+ORR faster than LDR

        MOV     R10,    #&00FF0000
        ORR     R10,R10,#&0000FF00
 ]

; Read &100 bytes
; Don't need to worry about the R14 used by the transfer code being
; corrupted by an IRQ as we are in SVC mode

 [ NewTransferCode
        MOV     R10,PC                  ; set return address
        B       ReadCode
        MOV     R10,PC
        B       ReadCode
 |
        ADDR    R2,LowCodeLocation
        STR     PC,RomReturn            ; set return address
        MOV     PC,R2                   ; i.e. B LowCodeLocation
        NOP                             ; not executed

; RAM code returns here
; Read another &100 bytes


        ADDR    R2,LowCodeLocation
        STR     PC,RomReturn
        MOV     PC,R2
        NOP                             ; not executed
 ]

; RAM code returns here
; all done
 [ Debug22

        DLINE   "Read completed(1)"
 ]

        Pull    "LR"
        RestPSR LR,,cf
        Pull    "R2-R8,R10,PC"          ; return, restoring IRQ state

;****** Never fall through

10
; Less than one whole sector to read, move it the hard way
; <<< This could be optimised to transfer the first &100 using the RAM code

        ASSERT  WinIDEBytesPerSector = 512
        LDRB    R3,WinIDECommandCode
        TEQ     R3,#IDECmdPacket
        MOVNE   R3,#&200                ; must read whole sector to please HDC
        MOVEQ   R3,R0
20
 [ NewTransferCode
        LDRH    R2,IDERegData           ; get 2 bytes
 |
        LDR     R2,IDERegData           ; get 2 bytes
 ]
        SUBS    R0,R0,#1                ; if wanted...
        STRPLB  R2,[R1],#1              ; ...store LSB
        MOV     R2,R2,LSR #8            ; get other byte
        SUBS    R0,R0,#1                ; if wanted...
        STRPLB  R2,[R1],#1              ; ...store MSB
        SUBS    R3,R3,#2                ; adjust bytes read so far
        BGT     %BT20
 [ Debug22

        DLINE   "Read completed(2)"
 ]

        Pull    "LR"
        RestPSR LR,,cf
        Pull    "R2-R8,R10,PC"          ; return, restoring IRQ state

;---------------------------------------------------------------------

 [ NewTransferCode
WinIDEReadASector32

 [ Debug20 :LAND: {FALSE}

        DLINE   "r",cc
 ]
        Push    "R2-R8,R10,LR"

; Enable interrupts to improve latency

        WritePSRc SVC_mode,R8,,LR       ; enable IRQs
        Push    "LR"
 [ Debug22

        DREG    r0, "Read ",cc
        DREG    r1, " bytes to "
 ]

        ASSERT  WinIDEBytesPerSector = 512
        CMPS    R0,#&200                ; whole block?
        BLO     %FT10

; >= &200  bytes to transfer - use high-speed code

        MOV     R10,PC                  ; set return address
        B       ReadCode32
        MOV     R10,PC
        B       ReadCode32

; all done
 [ Debug22

        DLINE   "Read completed(1)"
 ]

        Pull    "LR"
        RestPSR LR,,cf
        Pull    "R2-R8,R10,PC"          ; return, restoring IRQ state

;****** Never fall through

10
; Less than one whole sector to read, move it the hard way
; <<< This could be optimised to transfer the first &100 using the RAM code

        ASSERT  WinIDEBytesPerSector = 512
        LDRB    R3,WinIDECommandCode
        TEQ     R3,#IDECmdPacket
        MOVNE   R3,#&200                ; must read whole sector to please HDC (keeps NE)
        MOVEQ   R3,R0
20
        CMP     R3,#2
        LDRGT   R2,IDERegData           ; get 2 or 4 bytes
        LDRLEH  R2,IDERegData
        SUBS    R0,R0,#1                ; if wanted...
        STRPLB  R2,[R1],#1              ; ...store LSB
        MOV     R2,R2,LSR #8            ; get next byte
        SUBS    R0,R0,#1                ; if wanted...
        STRPLB  R2,[R1],#1              ; ...store MSB
        MOV     R2,R2,LSR #8            ; get next byte
        SUBS    R0,R0,#1                ; if wanted...
        STRPLB  R2,[R1],#1              ; ...store MSB
        MOV     R2,R2,LSR #8            ; get next byte
        SUBS    R0,R0,#1                ; if wanted...
        STRPLB  R2,[R1],#1              ; ...store MSB
        SUBS    R3,R3,#4                ; adjust bytes read so far
        BGT     %BT20
30
 [ Debug22

        DLINE   "Read completed(2)"
 ]

        Pull    "LR"
        RestPSR LR,,cf
        Pull    "R2-R8,R10,PC"          ; return, restoring IRQ state
 ]

;*********************************************************************

WinIDEWriteASector      ROUT
 [ :LNOT:NewTransferCode
WinIDEWriteASector32
 ]
;
; Writes up to a sector of data from RAM to IDE.
;
; Entry:
;    R0 = length to transfer > 0
;    R1 -> buffer
;    IDE -> IDE controller
;    LR = return address
;    Transfer code has been copied to LowCodeLocation
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    R0 undefined
;    R1 updated
;    All other registers and flags preserved
;    IRQ state preserved but IRQs are enabled during call.

 [ Debug20

        DLINE   "w",cc
 ]

        GBLS    WinIDEWriteRegs
 [ NewTransferCode
WinIDEWriteRegs SETS "R2-R9,R10,IDE"
 |
WinIDEWriteRegs SETS "R2-R9,IDE"
 ]

        Push    "$WinIDEWriteRegs,LR"

; Enable interrupts to improve latency

        WritePSRc SVC_mode,R8,,LR       ; enable IRQs
        Push    "LR"
 [ Debug22

        DREG    r0,"Write ",cc
        DREG    r1," bytes from "
 ]

        ASSERT  WinIDEBytesPerSector = 512
        CMPS    R0,#&200                ; whole block?
        BCC     %FT10

; >= &200  bytes to transfer - use RAM-based code

 [ NewTransferCode
        MOV     R10,PC
        B       WriteCode
        MOV     R10,PC
        B       WriteCode
 |
; Write &100 bytes

        ADDR    R2,LowCodeLocation      ; i.e. BCS LowCodeLocation
        STR     PC,RomReturn            ; set return address
        MOV     PC,R2
        NOP                             ; not executed

; RAM code returns here
; Write another &100 bytes

        ADDR    R2,LowCodeLocation
        STR     PC,RomReturn
        MOV     PC,R2
        NOP                             ; not executed
 ]

; RAM code returns here
; all done
 [ Debug22

        DLINE   "Write completed(1)"
 ]

        Pull    "LR"
        RestPSR LR,,cf
        Pull    "$WinIDEWriteRegs,PC"   ; return, restoring IRQ state

;****** Never fall through

10
; Less than one whole sector to write, move it the hard way
; <<< This could be optimised to transfer the first &100 using the RAM code

        ASSERT  WinIDEBytesPerSector = 512
        LDRB    R3,WinIDECommandCode
        TEQ     R3,#IDECmdPacket
        MOVNE   R3,#&200                ; must write whole sector to please HDC
        MOVEQ   R3,R0
20
        SUBS    R0,R0,#1                ; adjust count. if out of data...
        MOVMI   R2,#0                   ; ...fill sector with 0
        LDRPLB  R2,[R1],#1              ; ...else get data
        SUBS    R0,R0,#1                ; adjust count. if not out of data...
        LDRPLB  R8,[R1],#1              ; ...get data
        ORRPL   R2, R2, R8, LSL #8
 [ NewTransferCode
        STRH    R2,IDERegData           ; write the data
 |
        ORR     R2, R2, R2, LSL #16
        STR     R2,IDERegData           ; write the data
 ]
        SUBS    R3,R3,#2                ; adjust bytes written so far
        BGT     %BT20
 [ Debug22

        DLINE   "Write completed(2)"
 ]

        Pull    "LR"
        RestPSR LR,,cf
        Pull    "$WinIDEWriteRegs,PC"   ; return, restoring IRQ state

;---------------------------------------------------------------------

 [ NewTransferCode
WinIDEWriteASector32

 [ Debug20

        DLINE   "w",cc
 ]

        Push    "$WinIDEWriteRegs,LR"

; Enable interrupts to improve latency

        WritePSRc SVC_mode,R8,,LR       ; enable IRQs
        Push    "LR"
 [ Debug22

        DREG    r0,"Write ",cc
        DREG    r1," bytes from "
 ]

        ASSERT  WinIDEBytesPerSector = 512
        CMPS    R0,#&200                ; whole block?
        BCC     %FT10

; >= &200  bytes to transfer - use high-speed code

        MOV     R10,PC
        B       WriteCode32
        MOV     R10,PC
        B       WriteCode32

; all done
 [ Debug22

        DLINE   "Write completed(1)"
 ]

        Pull    "LR"
        RestPSR LR,,cf
        Pull    "$WinIDEWriteRegs,PC"   ; return, restoring IRQ state

;****** Never fall through

10
; Less than one whole sector to write, move it the hard way
; <<< This could be optimised to transfer the first &100 using the RAM code

        ASSERT  WinIDEBytesPerSector = 512
        LDRB    R3,WinIDECommandCode
        TEQ     R3,#IDECmdPacket
        MOVNE   R3,#&200                ; must write whole sector to please HDC
        MOVEQ   R3,R0
20
        SUBS    R0,R0,#1                ; adjust count. if out of data...
        MOVMI   R2,#0                   ; ...fill sector with 0
        LDRPLB  R2,[R1],#1              ; ...else get data
        SUBS    R0,R0,#1                ; adjust count. if not out of data...
        LDRPLB  R8,[R1],#1              ; ...get data
        ORRPL   R2, R2, R8, LSL #8
        SUBS    R0,R0,#1                ; adjust count. if not out of data...
        LDRPLB  R8,[R1],#1              ; ...get data
        ORRPL   R2, R2, R8, LSL #16
        SUBS    R0,R0,#1                ; adjust count. if not out of data...
        LDRPLB  R8,[R1],#1              ; ...get data
        ORRPL   R2, R2, R8, LSL #24
        CMP     R3,#2
        STRGT   R2,IDERegData           ; write the data (2 or 4 bytes)
        STRLEH  R2,IDERegData
        SUBS    R3,R3,#4                ; adjust bytes written so far
        BGT     %BT20
 [ Debug22

        DLINE   "Write completed(2)"
 ]

        Pull    "LR"
        RestPSR LR,,cf
        Pull    "$WinIDEWriteRegs,PC"   ; return, restoring IRQ state
 ]

;*********************************************************************

WinIDEPowerSetup        ROUT
;
; Entered every second to check whether IDE drives are ready to be
; given their first power control command and issue it if so.
;
; Entry:
;    SB -> static workspace
;    MODE: IRQ or SVC
;
; Exit:
;    All registers and preserved

        Push    "LR"

; Check if we are still active - if not active, we have added callback
; but it has not been called yet.

        LDRB    LR,WinIDEPowerSetupActive
        TEQS    LR,#0                           ; still active?
        Pull    "PC",EQ                         ; return if not

; Check if we have hardware to talk to

        LDRB    LR,WinIDEHardware+WinIDEIRQDevNo
        TEQS    LR,#0                           ; got hardware?
 [ TwinIDEHardware
        LDREQB  LR,WinIDEHardware+SzWinIDEHardware+WinIDEIRQDevNo
        TEQEQS  LR,#0
 ]
        Pull    "PC",EQ                         ; return if not

; There is hardware to talk to.
; Check if a command is in progress and quit if so

        BL      LockIDEController
        Pull    "PC",VS                         ; return if controller busy

; No command in progress

 [ HAL
        Push    "R0-R3,R9,IDECtrl,IDE"
 |
        Push    "R0-R3,R9,IDE"
 ]

; No need to check if any drives configured as this is never
; entered if none configured.

; For each drive, check if drive needs power command

        sbaddr  R0,WinDriveTypes
        sbaddr  R1,WinIDEDriveState             ; R1 -> drive states
        MOV     R3,#0                           ; drive 0
10
        LDRB    R2,[R0,R3]                      ; get physical drive number
        TST     R2,#bit3                        ; IDE drive?
        LDREQB  LR,[R1,R2]                      ; get drive state
        TEQEQS  LR,#WinIDEDriveStateReset       ; still just reset?
11      ADDNE   R3,R3,#1                        ; if not, check next
        TEQNES  R3,#4
        BNE     %BT10                           ; branch if more to do

; Found drive that needs to be done or run out of drives

        TEQS    R3,#4                           ; all done?
        BEQ     %FT90                           ; branch if so

        ADD     R1,R1,R2                        ; R1 -> drive state

; Found drive that needs power command
; R2 = physical drive number
; R1 -> drive state

; Check if controller busy

        sbaddr  R9,WinIDEHardware
 [ TwinIDEHardware
        TST     R2,#2
        ADDNE   R9,R9,#SzWinIDEHardware
        LDRB    LR,[R9,#WinIDEIRQDevNo]         ; double-check we have this hardware
        TEQ     LR,#0
        BNE     %FT12
        CMP     PC,#0                           ; set NE
        B       %BT11
12
 ]
 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        ASSERT  WinIDEPtr = 4
        LDMIA   R9,{IDECtrl,IDE}                ; IDE -> controller
 |
        LDR     IDE,[R9,#WinIDEPtr]
 ]
        LDRB    LR,IDERegAltStatus              ; get status
        TSTS    LR,#IDEStatusBSY                ; busy?
        BLNE    UnlockIDEController
 [ HAL
        Pull    "R0-R3,R9,IDECtrl,IDE,PC",NE    ; quit if so
 |
        Pull    "R0-R3,R9,IDE,PC",NE            ; quit if so
 ]

; Controller not busy - select drive and check for drive ready

        MOV     R0,R2,LSL #IDEDriveShift        ; put drive bit in position
        ORR     R0,R0,#IDEDrvHeadMagicBits      ; include magic bits
        STRB    R0,IDERegDrvHead                ; select drive
        MOV     R0,#1*2                         ; wait for valid status
        BL      DoMicroDelay
        LDRB    LR,IDERegAltStatus              ; get status
        ANDS    LR,LR,#IDEStatusBSY :OR: IDEStatusDRDY
        TEQS    LR,#IDEStatusDRDY               ; ready?
        BLNE    UnlockIDEController
 [ HAL
        Pull    "R0-R3,R9,IDECtrl,IDE,PC",NE    ; quit if not
 |
        Pull    "R0-R3,R9,IDE,PC",NE            ; quit if not
 ]

; Drive selected and not busy - command it

 [ Debug21
        Push    "R3"
        WritePSRc SVC_mode :OR: I_bit,LR,,R3
        NOP
        Push    "LR"
        BREG    R2,"TickIdle "
        Pull    "LR"
        RestPSR R3,,c
        NOP
        Pull    "R3"
 ]
        sbaddr  LR,WinIDEPowerState             ; LR -> power states
        LDRB    LR,[LR,R2]                      ; get value for this drive
        STRB    LR,IDERegSecCount               ; write to controller
        MOV     LR,#IDECmdIdle                  ; get command
        STRB    LR,IDERegCommand                ; start command

; Do not wait for command to complete but finish here
; (nothing we can do if it fails anyway).

        MOV     R0,#WinIDEDriveStateIdled       ; update state
        STRB    R0,[R1]

; No need to check if have done all drives as next time will do so

        BL      UnlockIDEController
 [ HAL
        Pull    "R0-R3,R9,IDECtrl,IDE,PC"       ; return
 |
        Pull    "R0-R3,R9,IDE,PC"               ; return
 ]

;****** Never fall through

90
; All drives done, either by us or in the foreground.
; Set up CallBack to remove CallEvery handler - TDobson says not
; safe to remove it from here.

        ADR     R0,WinIDEKillPowerSetup         ; R0 -> callback routine
        MOV     R1,SB                           ; R1 = value for R12
        SETPSR  SVC_mode :OR: I_bit,LR,,R2      ; switch to SVC mode
        NOP                                     ; prevent contention
        Push    "LR"                            ; save r14_svc
 [ Debug21

        DLINE   "AddCallback"
 ]
        SWI     XOS_AddCallBack

; If AddCallBack succeeded, flag us as not active so don't add
; another callback next time (may get entered again before callback)

        MOVVC   R0,#0
        STRVCB  R0,WinIDEPowerSetupActive

        Pull    "LR"                            ; restore r14_svc
        RestPSR R2,,cf                          ; restore original mode
        NOP                                     ; prevent contention

        BL      UnlockIDEController

 [ HAL
        Pull    "R0-R3,R9,IDECtrl,IDE,PC"       ; return
 |
        Pull    "R0-R3,R9,IDE,PC"               ; return
 ]

;*********************************************************************

WinIDEKillPowerSetup    ROUT
;
; Callback routine to remove WinIDEPowerSetup from CallEvery.
; Also called when module killed.
;
; Entry:
;    SB -> static workspace
;    MODE: SVC
;
; Exit:
;    All registers and flags preserved

        EntryS  "R0-R2"

 [ Debug21

        DLINE   "KillPowerSetup"
 ]
        ADR     R0,WinIDEPowerSetup     ; R0 -> routine to remove
        MOV     R1,SB                   ; R1 = R12 value
        SWI     XOS_RemoveTickerEvent   ; remove the ticker routine

        EXITS

 [ IDEPower
IDEPowerBits  * PortableControl_IDEEnable
;*********************************************************************

WinIDEPowerShutdown     ROUT
;
; Entered every ten seconds to check whether the IDE drive has spun down.
; This ticker is only setup if we are running on a portable. It is safe, though
; pointless, to have it setup on a non portable machine.
;
; Entry:
;    SB -> static workspace
;    MODE: IRQ or SVC
;
; Exit:
;    All registers preserved

        Push    "R0-R1,LR"
;
; Attempt to power-down the drive. WinIDEcontrol does nothing if not on a portable, or
; if the drive is already powered down. If drive is powered up, WinIDEcontrol calls
; Portable_Control to shut down the drive. This issues a service call which we (ADFS)
; receive. The service code asks the drive if it has spun-down, and if so allows the
; service call (a power-down request) to preceed. If the drive is spinning, the service
; call bit mask is adjusted to stop the power-down.
;
; We don't touch the state machine here!. That is done on receipt of
; Service_Portable (reason code PowerUp/PowerDown).
;
        MOV     R0, #0                          ; disable
        BL      WinIDEcontrol                   ; in R0=required state (disabled), out R1=Portable_Flags

        Pull    "R0-R1,PC"

;*********************************************************************

WinIDEKillPowerShutdown    ROUT
;
; Routine to remove WinIDEPowerShutdown from CallEvery.
; Called when module killed.
;
; Entry:
;    SB -> static workspace
;    MODE: SVC
;
; Exit:
;    All registers and flags preserved

        EntryS  "R0-R2"

  [ Debug21
        DLINE   "KillPowerShutdown"
  ]
        ADR     R0,WinIDEPowerShutdown  ; R0 -> routine to remove
        MOV     R1,SB                   ; R1 = R12 value
        SWI     XOS_RemoveTickerEvent   ; remove the ticker routine

        EXITS
 ]

;*********************************************************************

WinIDEPollCommand       ROUT
;
; Start a command and poll for the IRQ that indicates completion.
;
; Entry:
;    R0 = command (and flags)
;    R5 = timeout in centiseconds
;    IDE -> IDE controller
;    SB -> static workspace
;    WinIDEParms valid
;    MODE: SVC
;    IRQ state: unknown
;
; Exit:
;    VS => error
;          R0 = error code
;    VC => no error
;          R0 = 0
;    R5 undefined
;    All other registers preserved
;    IRQ state: preserved but IRQs enabled during call

        Push    "R6-R9,LR"

; Enable interrupts so that the timer works

        WritePSRc SVC_mode,R6,,R8

; Set command flags up
        MOV     LR,#0
        TST     R0,#bit9
        ORRNE   LR,LR,#WinIDECmdFlag_48bit
        STRB    R0,WinIDECommandCode
        STRB    LR,WinIDECommandFlags

; Start the command

        BL      WinIDECommandDisc               ; (R0,IDE->R0,V)
        BVS     %FT90                           ; branch if error

; Set up the counter for timing out the command

        STR     R5,WinTickCount                 ; decremented under IRQ

; IRQ is already enabled in controller.
; Do not enable IRQ in IOC/podule as we will poll for it.

; Wait for interrupt

 [ TwinIDEHardware
        LDR     R9,WinIDECurrentHW
 |
        sbaddr  R9,WinIDEHardware
 ]

 [ HAL
        LDRB    R0,[R9,#WinIDEHWType]
        TEQ     R0,#WinIDEHW_HAL
        BNE     %FT05
02
        Push    "R1-R3,R9,R12"
        LDRB    R0,[R9,#WinIDEIRQDevNo]
        sbaddr  R1,HAL_IRQStatus_routine
        MOV     LR,PC
        LDMIA   R1,{R9,PC}
        Pull    "R1-R3,R9,R12"
        TEQ     R0,#0
        BNE     %FT20

; no IRQ yet - check for timeout

        LDR     R7,WinTickCount                 ; get tick count
        TEQS    R7,#0                           ; done ?
        BNE     %BT02
        BEQ     %FT15
05
 ]
        ADD     R0,R9,#WinIDEPollPtr            ; R0 -> hardware details
        LDMIA   R0,{R5,R6}                      ; get poll addr & bits
10
        LDRB    R0,[R5]                         ; get status
        TSTS    R0,R6                           ; IRQ ?
        BNE     %FT20

; no IRQ yet - check for timeout

        LDR     R7,WinTickCount                 ; get tick count
        TEQS    R7,#0                           ; done ?
        BNE     %BT10

; timeout
15
        MOV     R0,#WinIDEErrTimeout

 [ IDEResetOnError
; reset drives to switch access lights off
; (don't need to do this if got IRQ as drive did respond)

        BL      WinIDEResetDrives               ; preserves flags
 ]
        B       %FT90

20
; got an IRQ, need status

        MOV     R0,#0                           ; if IRQ, stop timer...
        STR     R0,WinTickCount                 ; ...to speed things up

        LDRB    R0,IDERegStatus                 ; ...clear the IRQ...
        BL      WinIDEDecodeDriveStatus         ; ...and sort out status

90
; R0 = completion code

        RestPSR R8,,cf                          ; restore IRQ state
        Pull    "R6-R9,LR"
        B       SetVOnR0                        ; set/clear V


;*********************************************************************

WinIDECheckIRQStatus    ROUT
;
; Checks whether the hard drive is requesting an interrupt (for
; when interrupts are masked out in the controller).
;
; Entry:
;    SB -> static workspace
;    WinIDEHardware onwards contains details of IDE hardware
;
; Exit:
;    R0,R1 corrupted
;    NE if interrupt requested

        Push    "R2,R3,R9,LR"

 [ TwinIDEHardware
        LDR     R9,WinIDECurrentHW
 |
        sbaddr  R9,WinIDEHardware
 ]

 [ HAL
        LDRB    R0,[R9,#WinIDEHWType]
        TEQ     R0,#WinIDEHW_HAL
        BNE     %FT05
02
        Push    "R12"
        LDRB    R0,[R9,#WinIDEIRQDevNo]
        sbaddr  R1,HAL_IRQStatus_routine
        MOV     LR,PC
        LDMIA   R1,{R9,PC}
        Pull    "R12"
        TEQ     R0,#0
        Pull    "R2,R3,R9,PC"
05
 ]
        ADD     R0,R9,#WinIDEPollPtr            ; R0 -> hardware details
        LDMIA   R0,{R2,R3}                      ; get poll addr & bits
10
        LDRB    R0,[R2]                         ; get status
        TSTS    R0,R3                           ; IRQ ?
        Pull    "R2,R3,R9,PC"


;*********************************************************************

 [ IDEResetOnInit :LOR: IDEResetOnError

WinIDEResetDrives       ROUT
;
; Resets the IDE drives and enables interrupts in the controller.
;
; Entry:
;    SB -> static workspace
;    WinIDEHardware onwards contains details of IDE hardware
;
; Exit:
;    All registers and flags preserved

 [ HAL
        Push    "R0,IDECtrl,LR"
 |
        Push    "R0,IDE,LR"
 ]

; Set IDE -> IDE controller

 [ HAL
        LDR     IDECtrl,WinIDEHardware+WinIDECtrlPtr
 |
        LDR     IDE,WinIDEHardware+WinIDEPtr
 ]

; Set SRST bit in digital output register

        MOV     R0,#IDEDevCtrlSRST
        STRB    R0,IDERegDevCtrl

 [ TwinIDEHardware
 [ HAL
        LDR     IDECtrl,WinIDEHardware+SzWinIDEHardware+WinIDECtrlPtr
 |
        LDR     IDE,WinIDEHardware+SzWinIDEHardware+WinIDEPtr
 ]

; Set SRST bit in digital output register

        MOV     R0,#IDEDevCtrlSRST
        STRB    R0,IDERegDevCtrl
 ]

; Now wait for 50us before deasserting SRST.

        MOV     R0,#50*2                ; delay in 1/2 us units
        BL      DoMicroDelay

; Release SRST and enable interrupts in controller

        MOV     R0,#0
        STRB    R0,IDERegDevCtrl

 [ TwinIDEHardware
 [ HAL
        LDR     IDECtrl,WinIDEHardware+WinIDECtrlPtr
 |
        LDR     IDE,WinIDEHardware+WinIDEPtr
 ]
        MOV     R0,#0
        STRB    R0,IDERegDevCtrl
 ]

; Flag that the drives have been reset so they get initialised before use

 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
        ASSERT  WinIDEMaxDrives = 2
 ]
        MOV     R0,#WinIDEDriveStateReset
        STRB    R0,WinIDEDriveState+0
        STRB    R0,WinIDEDriveState+1
 [ TwinIDEHardware
        STRB    R0,WinIDEDriveState+2
        STRB    R0,WinIDEDriveState+3
 ]

 [ HAL
        Pull    "R0,IDECtrl,PC"
 |
        Pull    "R0,IDE,PC"
 ]
 ]

;*********************************************************************

WinIDEWaitReady ROUT
;
; Wait for an IDE drive to become ready
;
; Entry:
;    R0 = drive 0 => master, 1 => slave
;    R5 = timeout in centiseconds
;    SB -> static workspace
;    IRQ state: enabled
;    TickerV has been claimed
;    WinIDEHardware onwards contains details of IDE hardware
;
; Exit:
;    VS => drive not ready
;          R0 = error code
;    VC => drive ready
;          R0 = 0
;    All other registers preserved

 [ HAL
        Push    "R1,R9,IDECtrl,IDE,LR"
 |
        Push    "R1,R9,IDE,LR"
 ]

 [ Debug21

        DLINE   "WinIDEWaitReady"
 ]

; Set up value to select drive

        MOV     R0,R0,LSL #IDEDriveShift        ; put bit in position
        ORR     R1,R0,#IDEDrvHeadMagicBits      ; include magic bits

; Set IDE -> IDE controller

 [ TwinIDEHardware
        LDR     R9, WinIDECurrentHW
 |
        sbaddr  R9, WinIDEHardware
 ]
 [ HAL
        ASSERT  WinIDECtrlPtr = 0
        ASSERT  WinIDEPtr = 4
        LDMIA   R9,{IDECtrl,IDE}
 |
        LDR     IDE,[R9,#WinIDEPtr]
 ]

; Set tick count for timer

        STR     R5,WinTickCount

; Wait for controller to be not busy (or timeout)

        BL      WinIDEWaitNotBusy       ; NE => busy
        SETV    NE
        MOVNE   R0,#WinIDEErrCmdBusy    ; if still busy, return...
 [ HAL
        Pull    "R1,R9,IDECtrl,IDE,PC",NE  ; ...error
 |
        Pull    "R1,R9,IDE,PC",NE       ; ...error
 ]

; Controller not busy - select drive and check if ready

        STRB    R1,IDERegDrvHead

; Wait for other bits in status to become valid

20
        MOV     R0,#1*2                 ; 1/2 us units
        BL      DoMicroDelay
        LDRB    R0,IDERegAltStatus      ; check status
        AND     R0,R0,#IDEStatusBSY :OR: IDEStatusDRDY
        CMPS    R0,#IDEStatusDRDY       ; ready? (CMPs here clear V)
        LDRNE   LR,WinTickCount         ; if not, check for timeout
        CMPNES  LR,#0                   ; expired?
        BNE     %BT20                   ; branch if not

; EQ => drive ready or timeout expired

        EORS    R0,R0,#IDEStatusDRDY    ; EQ => drive ready
        MOVNE   R0,#WinIDEErrCmdNotRdy  ; if not ready...return error
        SETV    NE
 [ HAL
        Pull    "R1,R9,IDECtrl,IDE,PC"
 |
        Pull    "R1,R9,IDE,PC"
 ]

;*********************************************************************

WinIDEWaitNotBusy       ROUT
;
; Waits for the current drive to become not busy or for
; the timeout to expire.
;
; Entry:
 [ HAL
;    IDECtrl -> controller
 |
;    IDE -> controller
 ]
;    IRQ state: enabled
;
; Exit:
;    NE => drive still busy
;    All registers preserved

        Push    "R0,LR"
10
        LDRB    R0,IDERegAltStatus
        TSTS    R0,#IDEStatusBSY        ; busy?
        LDRNE   LR,WinTickCount         ; check for timeout
        TEQNES  LR,#0
        BNE     %BT10

; Drive not busy or timeout has expired

        TSTS    R0,#IDEStatusBSY        ; still busy?
        Pull    "R0,PC"

;*********************************************************************

WinIDECheckEscape       ROUT
;
; If it is allowed during this op, check if escape has been pressed
; and return status accordingly.
;
; Entry:
;    WinIDEFileCoreOp = op passed by FileCore
;
; Exit:
;    VS => escape was enabled and has been pressed
;       R0 = escape error
;    VC => escape not enabled or enabled but not pressed
;       R0 undefined
;    All other registers preserved

; check if escape is allowed during this op

        CLRV
        LDR     R0,WinIDEFileCoreOp             ; get op
        TSTS    R0,#DiscOp_Op_IgnoreEscape_Flag ; escape allowed?
        MOVNE   PC,LR                           ; return if not

; escape is allowed during this op - check if pressed

        LDR     R0,ptr_ESC_Status
        LDRB    R0,[R0]                         ; get escape flag
        TSTS    R0,#EscapeBit                   ; escape?
        MOVEQ   PC,LR                           ; return if not

; escape enabled and pressed

        MOV     R0,#IntEscapeErr                ; FileCore escape error code
        RETURNVS

;*********************************************************************

WinClaimIDEIRQs ROUT
;
; Claim IRQs for IDE hardware
;
; Entry:
;    R9 -> WinIDEHardware block describing IDE hardware
;    SB -> static workspace
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    VS => error
;          R0 = error pointer
;    VC => no error
;          R0 undefined
;    All other registers preserved
;    WinIDEIRQDevNo = device number for claim/release

        Push    "R1-R5,LR"

; disable IRQs

        WritePSRc SVC_mode :OR: I_bit, R0,, R5

; determine whether it's podule or motherboard

        LDRB    R0,[R9,#WinIDEHWType]
        TEQ     R0,#WinIDEHW_Podule

; EQ => podule IDE
; If podule, enable podule IRQs in IOC
; (should really do this AFTER claiming the device vector but IRQs
; are not enabled in the podule yet so all ok - this is same order
; as ST506).

 [ :LNOT:HAL
        MOVEQ   R0,#IOC
        LDREQB  R1,[R0,#IOCIRQMSKB]
        ORREQ   R1,R1,#podule_IRQ_bit
        STREQB  R1,[R0,#IOCIRQMSKB]
 ]

; set R0 = device number

 [ HAL
        LDRB    R0,[R9,#WinIDEHWDevNo]
 |
        MOVNE   R0,#IOMD_IDE_DevNo
        MOVEQ   R0,#Podule_DevNo
 ]

 [ HAL
        BNE     %FT05
        Push    "R0-R3,R9,R12"
        sbaddr  R1, HAL_IRQEnable_routine
        MOV     LR,PC
        LDMIA   R1,{R9,PC}
        Pull    "R0-R3,R9,R12"
        TEQ     R0,R0                           ; set EQ again
05
 ]

; set R1 -> interrupt service routine
;     R2 = value to pass in R12

        baddr   R1,WinIDEIRQHandler
        MOV     R2,SB

; set R3 = address of interrupt status
;     R4 = mask such that LDRB [R3] AND [R4] NE => IRQ

        LDREQ   R3,[R9,#WinIDEPollPtr]
        LDREQ   R4,[R9,#WinIDEPollBits]         ; !!!Wrong - see Fix1
 [ HAL
        MOVNE   R3,#0
        MOVNE   R4,#0
 ]

; claim the vector and store device number

 [ Debug21

        DREG    R0,"ClaimDevice R0-R4: ",cc
        DREG    R1,,cc
        DREG    R2,,cc
        DREG    R3,,cc
        DREG    R4
 ]

        SWI     XOS_ClaimDeviceVector

        MOVVS   R1,#0                           ; 0 if claim failed
        MOVVC   R1,R0                           ; devno otherwise
        STRB    R1,[R9,#WinIDEIRQDevNo]

; restore IRQ state and return

        RestPSR R5,,c

        Pull    "R1-R5,PC"                      ; restore regs


;*********************************************************************

WinReleaseIDEIRQs       ROUT
;
; Release IRQ for the IDE hardware
;
; Entry:
;    R9 -> WinIDEHardware block describing IDE hardware
;    SB -> static workspace
;    WinIDEIRQDevNo = device number for claim/release
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    VS => error
;          R0 = error
;    VC => all ok
;          R0 undefined
;    All other registers preserved

        Push    "R1-R4,LR"

; set up regs as for call to WinClaimIDEIRQs

        LDRB    R0,[R9,#WinIDEIRQDevNo]         ; get dev no for call
        LDRB    R1,[R9,#WinIDEHWType]
        CMP     R0, #0
        Pull    "R1-R4,PC",EQ                   ; return if not claimed (V clear)
        CMPS    R1,#WinIDEHW_Podule             ; check for podule

; vector claimed
; HI => podule, not motherboard

        baddr   R1,WinIDEIRQHandler             ; get handler address
        MOV     R2,SB                           ; and R12 value
        LDREQ   R3,[R9,#WinIDEPollPtr]          ; if podule, get status addr
        LDREQ   R4,[R9,#WinIDEPollBits]
        MOVNE   R3,#0
        MOVNE   R4,#0
        SWI     XOS_ReleaseDeviceVector         ; release device

        MOVVC   R1,#0                           ; flag device not claimed
        STRVCB  R1,[R9,#WinIDEIRQDevNo]

        Pull    "R1-R4,PC"

;*********************************************************************

WinTickerHandler        ROUT
;
; Called from TickerV to implement timers
;
; Entry:
;    SB -> static workspace
;    MODE: IRQ or SVC
;
; Exit:
;    All registers preserved

        Push    "R0,LR"

; check not currently in IRQ routine

        LDRB    R0,WinIDEIRQFlag        ; get flag
        TEQS    R0,#0                   ; in IRQ?
        Pull    "R0,PC",NE              ; NE => yes, so abort

; not in IRQ routine: ok to continue
; decrement tick count

        LDR     R0,WinTickCount
        TEQS    R0,#0                   ; already 0?
        Pull    "R0,PC",EQ              ; return if so

 [ IDEDMA
        Push    "R0,R9"
        LDR     R9,WinIDECurrentHW      ; check if we have a DMA transfer in progress
        LDR     LR,[R9,#WinIDEDMATag]
        CMP     LR,#0
                                        ; if so, take the opportunity to check for
        BLNE    WinIDEExamineTransfer   ; problems - if we get one, then timeout
        Pull    "R0,R9"                 ; immediately
        MOVVS   R0,#1
40
 ]

        SUBS    R0,R0,#1                ; decrement if not...
        STR     R0,WinTickCount         ; ...and save
        Pull    "R0,PC",NE              ; return if count != 0

; count now zero - call routine if necessary

        LDR     R0,WinTickCallAddress
        TEQS    R0,#0
        Pull    "R0,PC",EQ              ; return if address not initialised

; call address HAS been initialised so call it

        MOV     LR,PC                   ; set return address
        MOV     PC,R0                   ; call handler

; handler should return here

        Pull    "R0,PC"

;*********************************************************************

WinClaimTickerV ROUT
;
; Claim TickerV
;
; Entry:
;    SB -> static workspace
;
; Exit:
;    VS => error
;          R0 -> OS error block
;    VC => all ok
;          R0 undefined
;    All other registers preserved
;    WinHaveTickerV updated

        Push    "R1-R2,LR"

; initialise timer call address to prevent accidental call

        MOV     R0,#0
        STR     R0,WinTickCallAddress

; claim the vector

        MOV     R0,#TickerV
        baddr   R1,WinTickerHandler
        MOV     R2,SB
        SWI     XOS_Claim

        MOVVS   R1,#0                   ; if error, not claimed
        MOVVC   R1,#&FF                 ; if error, say claimed
        STRB    R1,WinHaveTickerV

        Pull    "R1-R2,PC"

;*********************************************************************

WinReleaseTickerV       ROUT
;
; Release TickerV if claimed
;
; Entry:
;    SB -> static workspace
;    WinHaveTickerV valid
;
; Exit:
;    VS => error
;          R0 -> OS error block
;    VC => all ok
;          R0 undefined
;    All other registers preserved
;    WinHaveTickerV updated

        Push    "R1-R2,LR"

        LDRB    R0,WinHaveTickerV               ; got TickerV?
        CMPS    R0,#0
        Pull    "R1-R2,PC",EQ                   ; return if not

; have got TickerV - release it

        MOV     R0,#TickerV
        baddr   R1,WinTickerHandler
        MOV     R2,SB
        SWI     XOS_Release

        MOVVC   R1,#0                           ; if ok, flag have not...
        STRVCB  R1,WinHaveTickerV               ; ...got TickerV

        Pull    "R1-R2,PC"

;*********************************************************************

DoMicroDelay    ROUT
;
; Delay a specified number of 1/2 microsecond units.
; Code courtesy of Tim Dobson.
;
; Entry:
;   R0 = number of 1/2 microsecond units to wait
;   MODE: SVC or IRQ
;   IRQ state: undefined
;
; Exit:
;   R0 undefined
;   All other registers preserved

  [ HAL
        Push    "R1-R4,R9,R12,LR"
        SavePSR R4
        MOVS    R0,R0,LSR #1
        ADC     R0,R0,#0
        sbaddr  R1,HAL_CounterDelay_routine
        MOV     LR,PC
        LDMIA   R1,{R9,PC}
        RestPSR R4,,f
        Pull    "R1-R4,R9,R12,PC"
  |
        Push    "R1-R3,LR"
        SavePSR R3

        MOV     R2,#IOC                 ; R2 -> IOC
        STRB    R0,[R2,#Timer0LR]       ; copies counter to output latch
        LDRB    R1,[R2,#Timer0CL]       ; R1 = low output latch

; loop waiting for counter to change (decremented at 2MHz)
10
        STRB    R0,[R2,#Timer0LR]       ; copies counter to output latch
        LDRB    LR,[R2,#Timer0CL]       ; LR = low output latch
        TEQS    R1,LR                   ; has counter changed?
        BEQ     %BT10                   ; else wait for it to change

; counter has changed, decrement our count of ticks

        MOV     R1,LR                   ; update copy of counter
        SUBS    R0,R0,#1                ; decrement ticks
        BNE     %BT10                   ; ...and continue if not done

; delay has expired

        RestPSR R3,,cf
        Pull    "R1-R3,PC"
 ]

;*********************************************************************

LockIDEController       ROUT
;
; Sets flag to lock IDE controller
;
; Entry:
;    IRQ state: undefined
;    MODE: undefined
;
; Exit:
;    VS => already locked
;    VC => now locked
;    All registers preserved

        Push    "R0,LR"

        sbaddr  R0,WinIDECommandActive

; We use LR as stored value to ease debugging; it helps us find
; out who locked it if we need to.

        SWP     LR,LR,[R0]              ; get and set flag

        CMPS    LR,#0                   ; already locked? (clear V)

        SETV    NE                      ; if so, return VS

        Pull    "R0,PC"

;*********************************************************************

UnlockIDEController     ROUT
;
; Clears flag to unlock IDE controller
;
; Entry:
;    IRQ state: undefined
;    MODE: undefined
;
; Exit:
;    All registers and flags preserved

        Push    "LR"

        MOV     LR,#0
        STR     LR,WinIDECommandActive

        Pull    "PC"

;*********************************************************************

 [ IDEDMA

WinIDEPadScatterList    ROUT
;
; Creates a duplicate scatter list, padded to a whole sector
;
; Entry:
;    R0 = direction flags (as per DMA_QueueTransfer)
;    R3 -> scatter list
;    R4 = length
;
; Exit
;    R3 -> (new) scatter list
;    R4 = length rounded up
;    R6 = 1 if padded & any addresses in list not halfword aligned, else 0
;    WinIDEOrigScatterPtr = Entry R3 if padded, else unaltered
;    WinIDECopiedScatterPtr = Exit R3 if padded, else unaltered
;

        ASSERT  WinIDEBytesPerSector = 512
        MOVS    R6,R4,LSL #(32-9)               ; if already aligned
        MOVEQ   PC,LR                           ; exit immediately
 [ Debug21
        DLINE   "WinIDEPadScatterList"
 ]
        Push    "R0-R2,R5,LR"
        MOV     R0,R3
        MOV     LR,R4
05      LDMIA   R0!,{R5,R6}                     ; count the list entries
        SUBS    LR,LR,R6
        BGT     %BT05
        SUB     R0,R0,R3                        ; R0 = length of list
        MOV     R1,R3                           ; R1 -> original list
        ADD     R3,R0,#8                        ; R3 = length of new list
        LDR     R6,WinIDECopiedScatterSize
        LDR     R2,WinIDECopiedScatterList
        SUBS    R3,R3,R6
        BLS     %FT10
        TEQ     R2,#0
        MOVEQ   R0,#ModHandReason_Claim
        MOVNE   R0,#ModHandReason_ExtendBlock
        SWI     XOS_Module                      ; R2 -> new list
        MOVVS   R6,#0
        BVS     %FT99
        STR     R2,WinIDECopiedScatterList
        ADD     R3,R3,R6
        STR     R3,WinIDECopiedScatterSize
 [ Debug21
        DREG    R2,"WinIDECopiedScatterList="
        DREG    R3,"WinIDECopiedScatterSize="
 ]

10      MOV     R0,R4                           ; R0 = length
        MOV     R3,R2                           ; R3 -> new list
        MOV     LR,#0                           ; LR = 0 (addr misalignment check)
20      LDMIA   R1!,{R5,R6}                     ; copy all entries up to last
        CMP     R6,#0
        BEQ     %BT20                           ; skip zero-length entries
        CMP     R6,R0
        STMLTIA R2!,{R5,R6}
        ORRLT   LR,LR,R5
 [ Debug21
        BGE     %FT01
        DREG    R5,"Scatter list addr ="
        DREG    R6,"Scatter list len  ="
01
 ]
        SUBLT   R0,R0,R6
        BLT     %BT20

        ; now (R5,R6) = final entry (R6 >= remaining length in R0)

        MOV     R6,R0                           ; adjust final entry to
        STMIA   R2!,{R5,R6}                     ; match R4 length
        ORR     LR,LR,R5
 [ Debug21
        DREG    R5,"Scatter list addr ="
        DREG    R6,"Scatter list len  ="
 ]

        LDR     R5,[SP]                         ; recover entry R0
        TST     R5,#bit0                        ; EQ=read, NE=write
        sbaddr  R5,WinIDEDMASink,EQ             ; excess reads -> sink
        sbaddr  R5,WinIDEDMAZeroes,NE           ; excess writes as 0

        MOV     R6,#WinIDEBytesPerSector        ; add in padding to make it a multiple
        SUB     R6,R6,#1                        ; of the sector size
        MOV     R0,R4
        ADD     R4,R4,R6                        ; R4 = length rounded up to
        BIC     R4,R4,R6                        ;      a sector
        SUB     R6,R4,R0                        ; R6 = amount of padding
        STMIA   R2!,{R5,R6}                     ; output padding entry
 [ Debug21
        DREG    R5,"Scatter list addr ="
        DREG    R6,"Scatter list len  ="
 ]
        AND     R6,LR,#WinIDEDMAAlignmentMask   ; R6 = halfword misalignment

99      STRVS   R0,[SP]
        Pull    "R0-R2,R5,PC"

;*********************************************************************

WinIDERegisterDMAChannel ROUT
;
; Claim the DMA channel for an interface
;
; Entry:
;    R9 -> WinIDEHardware block describing IDE hardware
;    SB -> static workspace
;    WinIDEDMALC = device number for claim/release
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    VS => error
;          R0 = error
;          WinIDEDMAHandle = -1
;    VC => all ok
;          R0 undefined
;          WinIDEDMAHandle = DMA manager handle for channel
;    WinIDEDMATag = 0
;    All other registers preserved

        Push    "R1-R5,LR"
        MOV     R0, #0
        LDR     R1, [R9,#WinIDEDMALC]
        MOV     R2, #0
        MOV     R3, #WinIDEDMAAlignment
        ADR     R4, WinIDEDMAHandlers
        MOV     R5, SB
        SWI     XDMA_RegisterChannel
        MOVVS   R0, #-1
        STR     R0, [R9,#WinIDEDMAHandle]
 [ Debug25
        DREG    R0, "DMA Handle="
 ]
        MOV     R0, #0
        STR     R0, [R9,#WinIDEDMATag]
        Pull    "R1-R5,PC"

;*********************************************************************

WinIDEDeregisterDMAChannel ROUT
;
; Release the DMA channel for an interface
;
; Entry:
;    R9 -> WinIDEHardware block describing IDE hardware
;    SB -> static workspace
;    WinIDEDMAHandle = DMA manager handle for channel
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    VS => error
;          R0 = error
;    VC => all ok
;          R0 undefined
;    WinIDEDMAHandle = -1
;    All other registers preserved

        Push    "LR"
        LDR     R0, [R9,#WinIDEDMAHandle]
        CMP     R0, #-1
        SWINE   XDMA_DeregisterChannel
        MOV     R0, #-1
        STR     R0, [R9,#WinIDEDMAHandle]
        Pull    "PC"

;*********************************************************************

WinIDEQueueTransfer ROUT
;
; Queue an IDE DMA transfer
;
; Entry:
;    R0 = direction
;    R3 -> scatter list
;    R4 = length
;    R9 -> WinIDEHardware block describing IDE hardware
;    SB -> static workspace
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    R0 = DMA tag (unless error)
;    All other registers preserved

        Push    "R1-R2,LR"
 [ Debug25
        TST     R0,#bit0
        MOVEQ   LR,#"r"
        MOVNE   LR,#"w"
        DREG    LR,"WinIDEQueueTransfer(",cc,Char
        DREG    R3,",",cc
        DREG    R4,",",cc
        DLINE   ")"
 ]
        MOV     R1, R0
        MOV     R0, #0
        BL      WinIDETerminateTransfer
        MOV     LR, #0
        STRB    LR, WinIDEDMAStatus
        MOV     R0, R1
        LDR     R1, [R9,#WinIDEDMAHandle]
        MOV     R2, R9
        SWI     XDMA_QueueTransfer
        STRVC   R0, [R9,#WinIDEDMATag]
        Pull    "R1-R2,PC"

;*********************************************************************

WinIDEExamineTransfer ROUT
;
; Examine the state of the current IDE DMA transfer
;
; Entry:
;    R9 -> WinIDEHardware block describing IDE hardware
;    SB -> static workspace
;    MODE: SVC or IRQ
;    IRQ state: undefined
;
; Exit:
;    R0 = bytes transferred (unless error)
;    All other registers preserved

        Push    "R1,R4,LR"
        MRS     R4, CPSR
        ORR     LR, R4, #3
        MSR     CPSR_c, LR
        Push    "LR"
        MOV     R0, #0
        LDR     R1, [R9,#WinIDEDMATag]
        SWI     XDMA_ExamineTransfer
        Pull    "LR"
        MSR     CPSR_c, R4
        Pull    "R1,R4,PC"

;*********************************************************************

WinIDETerminateTransfer ROUT
;
; Terminate the current IDE DMA transfer (if any)
;
; Entry:
;    R0 = error
;    R9 -> WinIDEHardware block describing IDE hardware
;    SB -> static workspace
;    MODE: SVC
;    IRQ state: undefined
;
; Exit:
;    All registers preserved

        Push    "R0-R1,LR"
 [ Debug25
        DREG    R0,"WinIDETerminateTransfer: "
 ]
        LDR     R1, [R9,#WinIDEDMATag]
        CMP     R1, #0
        SWINE   XDMA_TerminateTransfer
        Pull    "R0-R1,PC"

;*********************************************************************

; Handlers for IDE DMA transfers

; On "Start", issue preliminary checks for drive being ready - this
; is our last chance to back out with an error.

WinIDEDMAStart
        Push    "R0,R9,IDE,IDECtrl,LR"
 [ Debug25
        DLINE   "WinIDEDMAStart"
 ]
        MOV     R9,R11
        ASSERT  WinIDECtrlPtr = 0
        LDMIA   R9,{IDECtrl,IDE}        ; set IDE -> IDE controller
        LDRB    LR,WinIDEDMAStatus
        ORR     LR,LR,#DMAStat_Started
        STRB    LR,WinIDEDMAStatus
        LDRB    LR,WinIDECommandFlags
        LDRB    R0,WinIDECommandCode
        ORR     R0,R0,LR,LSL #8
        BL      WinIDECommandDisc_Checks
        Pull    "R0,R9,IDE,IDECtrl,PC",VC
        ADD     SP,SP,#4
        Pull    "R9,IDE,IDECtrl,PC"

; On "completed", just note the result.
WinIDEDMACompleted      ROUT
        Push    "R0,LR"
 [ Debug25
        DREG    R0,"WinIDEDMACompleted: "
        CMP     R0, #256
        BLO     %FT01
        LDR     LR,[R0]
        DREG    LR,"Error number="
01
 ]
        LDRB    LR,WinIDEDMAStatus
        TST     LR,#DMAStat_Enabled
        ORR     LR,LR,#DMAStat_Completed
        STRB    LR,WinIDEDMAStatus
        BEQ     %FT20
10      STR     R0,WinIDEDMAResult
        MOV     R0,#0
        STR     R0,[R11,#WinIDEDMATag]
        Pull    "R0,PC"

; Completed has been called without Enabled. This means
; the DMA Manager doesn't like us. We fall back to the
; PIO command, if available.
20      LDRB    LR,WinIDECommandCode_PIO
        TEQ     LR,#0
        BEQ     %BT10
        Push    "R9,IDE,IDECtrl"
        MOV     R9,R11
        ASSERT  WinIDECtrlPtr = 0
        LDMIA   R9,{IDECtrl,IDE}        ; set IDE -> IDE controller
        MOV     R0,LR
        STRB    R0,WinIDECommandCode
        LDRB    LR,WinIDECommandFlags
        BIC     LR,LR,#WinIDECmdFlag_DMA
        STRB    LR,WinIDECommandFlags
        ORR     R0,R0,LR,LSL #8
        BL      WinIDECommandDisc_Start
        Pull    "R9,IDE,IDECtrl"
        MOV     R0,#0
        B       %BT10

WinIDEDMADisable
WinIDEDMASync
        MOV     PC, LR

; On "enable", issue the command - the DMA manager is ready with all
; the pages set up, so we know it's okay to go.
WinIDEDMAEnable
        Push    "R0,R9,IDE,IDECtrl,LR"
 [ Debug25
        DLINE   "WinIDEDMAEnable"
 ]
        LDRB    LR,WinIDEDMAStatus
        TST     LR,#DMAStat_Enabled
        BNE     %FT99
        ORR     LR,LR,#DMAStat_Enabled
        STRB    LR,WinIDEDMAStatus
        MOV     R9,R11
        ASSERT  WinIDECtrlPtr = 0
        LDMIA   R9,{IDECtrl,IDE}        ; set IDE -> IDE controller
        LDRB    LR,WinIDECommandFlags
        LDRB    R0,WinIDECommandCode
        ORR     R0,R0,LR,LSL #8
 [ Debug25
        DREG    R0,"Command="
 ]
        BL      WinIDECommandDisc_Start
99
        Pull    "R0,R9,IDE,IDECtrl,PC"
 ]

;*********************************************************************

        END
@


4.13
log
@Replace a couple of magic numbers with constants
Detail:
  s/StaticsIDE - Add definitions for the "IORDY supported" & "No 48bit DMA" flags
  s/Adfs14, s/IDEDetect - Replace a couple of magic numbers with the more descriptive named flags
Admin:
  Tested in RiscPC ROM softload


Version 3.48. Retagged as 'ADFS-3_48'
@
text
@d935 9
a943 7
; Wait for DRQ to become asserted: according to CAM 2.1, this can
; take as long as 700us although Conner drives appear to assert it
; immediately. This loop is inaccurate because the resolution of
; the delay routine is only 0.5us but it is good enough for this.
; NOTE: if this is part of a background op (except for the first part
; which is started in foreground), IRQs are disabled.
; DRIVES THAT TAKE A LONG TIME TO ASSERT DRQ WILL RUIN INTERRUPT LATENCY
d958 1
a958 3
        MOVEQ   R0,#WinIDEErrNoDRQ              ; if so, return error
        SETV    EQ
        Pull    "R1-R6,R8-R9,PC",VS
d985 13
d1863 89
@


4.12
log
@Tabs expanded
Assembler source uses spaces round here in general, follow suit.
Not tagged.
@
text
@d787 1
a787 1
        TST     LR,#bit3
@


4.11
log
@Tidy up pass
ADFS.s:
  Redundant header files trimmed
  Get OsWords and OsBytes
  Switches rationalised
ADFS_SA.a
  Removed ARM810 support
Adfs00.s:
  Unused MEMC flag removed
Adfs05.s/Adfs12.s/Adfs13.s/Adfs14.s/Adfs15.s/Adfs19.s:
  Use defines instead of magic numbers
  Make use of FileCore exported bit fields
Adfs17.s/Adfs18.s/ConstIDE:
  {TRUE} and {FALSE} used with objasm
Adfs20.s
  Use AND of the opmask instead of BIC of all the flags except the opmask
Adfs50.s
  Unused MEMC flag no longer initialised
  Make use of FileCore exported bit fields
  Service call table reordered so the Ursula despatch doesn't incur a branch
  OsByte defines used
Consts:
  Removed those definitions now duplicating FileCore's exports
DebugOpts/Fixes:
  All options brought under one roof
ModHeader:
  Now uses VersionNum directly
Ver/*:
  Redundant switches deleted
  Removed used of 'Version' header


Version 3.45. Tagged as 'ADFS-3_45'
@
text
@d352 2
a353 2
	ASSERT	WinIDEBytesPerSector=512
	MOV	R0,R0,LSR #9		; convert to sectors (assume disc has whole no. of sectors!)
d358 1
a358 1
	SUBS	R0,R0,R2		; (R0,LR)= sectors to end of disc
d362 1
a362 1
	CMP	R0,#&800000		; check to see if >4G bytes (&800000 sectors)
d365 1
a365 1
	DREG	R0,"Length to end of disc :"
d367 4
a370 4
	BHS	%FT23			; > 4G, beyond max possible transfer
	MOV	R0,R0,LSL #9
	CMPS	R0,R4			;
	MOVLO   R4,R0			; ...use it instead
d373 1
a373 1
	DREG	R4,"Transfer length set to :"
d393 1
a393 1
	CMP	R1,#WinIDEFileCoreOpFormat
d395 1
a395 1
        BLEQ	WinIDESetPhysAddressCHS	; (R2->R0)
d452 1
a452 1
	DREG	R4,"WinIDEStartTransfer : Limit at end = "
d513 3
a515 3
	ASSERT	WinIDEBytesPerSector=512
	LDR	R4,WinIDEDiscSize	; size of disc...
	MOV	R4,R4,LSR #9		; ...in sectors
d518 1
a518 1
	SUB	R4,R4,R2		; R4 = sectors to end
d523 1
a523 1
	CMPS    R4,#&800000             ; is this >=4Gbytes...
d532 1
a532 1
	DREG	R4,"Length set to :"
d546 2
a547 2
	LDR	LR,WinIDEFileCoreOp
	CMP	LR,#WinIDEFileCoreOpFormat
d550 1
a550 1
	BLEQ    WinIDESetPhysAddressCHS
d1087 1
a1087 1
	DLINE	"I",cc
d1189 1
a1189 1
	DREG	R0,"WinIDETransferLimit = "
d1195 1
a1195 1
	DREG	R0,"WinIDETransferLimit = "
d1288 1
a1288 1
	DLINE	"About to do a write"
d1368 1
a1368 1
;	DLINE	"E",cc
d1374 3
a1376 3
        MOV     R1,R6                   	; save block size
        LDR     R2,WinIDEDiscAddress    	; get disc address...
        LDR     R6,WinIDESaveLumpSize   	; R6 = amount transferred
d1379 7
a1385 7
	DREG	R2,"Disc addr in: "
;	DREG	R3,"Sector offset in: "
	DREG	R6,"Lump size in: "
 ]
	ASSERT	WinIDEBytesPerSector=512	;
	ADD	R2,R2,R6,LSR #9			; R2 = updated disc address
        STR     R2,WinIDEDiscAddress    	;
d1388 2
a1389 2
	DREG	R2,"Disc addr out: "
;	DREG	R3,"Sector offset out: "
d1392 5
a1396 5
        MOV     R1,R6                   	; save block size
        LDR     R2,WinIDEDiscAddress    	; get disc address
        LDR     R6,WinIDESaveLumpSize   	; R6 = amount transferred
        ADD     R2,R2,R6                	; R2 = updated disc address
        STR     R2,WinIDEDiscAddress    	; save it
d1427 1
a1427 1
;	DLINE    "C",cc
d1437 2
a1438 2
;	DLINE   "T",cc
	DREG	R0, "Continuing with transfer limit = "
d1473 2
a1474 2
	LDR	LR,WinIDEFileCoreOp
	CMP     LR,#WinIDEFileCoreOpFormat
d1477 1
a1477 1
	BLEQ    WinIDESetPhysAddressCHS
d1484 1
a1484 1
;	DLINE	"S",cc
d1695 1
a1695 1
	B	%FT100
d1817 2
a1818 2
	ASSERT	WinIDEBytesPerSector=512
	ADDEQ  	R2,R2,R3,LSR #9         ; ...update R2
d1886 2
a1887 2
 	DREG	R4,"Scatter list addr ="
	DREG	R5,"Scatter list len  ="
d1937 3
a1939 3
	MOV	R0,#0
;	STR	R0,WinIDELumpSize
;	STR	R0,WinIDESaveLumpSize
d2143 1
a2143 1
WinIDESetPhysAddress	ROUT
d2162 1
a2162 1
	Push	"R1,R3,LR"
d2165 5
a2169 5
	LDRB	R1,WinIDEDriveNum	; get drive number
	sbaddr	LR,WinIDEDriveLBAFlags	; get addr of flags
	LDRB	R0,[LR,R1]		; get CHS/LBA flag
	CMP	R0,#0
	BEQ	%FT10			; choose CHS/LBA from flag
d2171 1
a2171 1
	BIC	R0,R2,#DiscBits		; R0 = disc addr minus drive num
d2174 2
a2175 2
	CMPS	R0,#7		        ; are we in early disk address?
	BLO	%FT10			; if so, use CHS
d2177 2
a2178 2
	CMPS	R0,#BootEnd		; are we in early disk address?
	BLO	%FT10			; if so, use CHS
d2181 1
a2181 1
	; use LBA addressing as drive supports it
d2186 1
a2186 1
	MOV	R0,R0,LSR #9		; LBA number, ie sector number (from disc start)
d2189 1
a2189 1
	; bits 0..7 of LBA
d2191 1
a2191 1
	STRB	R0,WinIDEParmLBA0to7
d2193 1
a2193 1
	; bits 8..15 of LBA
d2195 2
a2196 2
	MOV	R0,R0,LSR #8
	STRB	R0,WinIDEParmLBA8to15
d2198 1
a2198 1
	; bits 16..23 of LBA
d2200 2
a2201 2
	MOV	R0,R0,LSR #8
	STRB	R0,WinIDEParmLBA16to23
d2203 1
a2203 1
	MOV	R0,R0,LSR #8
d2215 1
a2215 1
	; now drive, 24..27 of LBA and the LBA flag
d2218 2
a2219 2
	ORR	R0,R0,R1,LSL #IDEDriveShift		; insert drive number
	STRB	R0,WinIDEParmDrvLBA24to27		; and store
d2222 1
a2222 1
	Pull	"R1,R3,PC"
d2225 1
a2225 1
	; use CHS addressing - drive doesn't support LBA
d2227 1
a2227 1
	Pull	"R1,R3,LR"
d2679 3
a2681 3
	LDRB	R2,IDERegDrvHead	; get drive/head in R2
	TST	R2,#&40			; check LBA bit
	BNE	%FT10			; if set, use LBA code
d2723 1
a2723 1
	AND     R2,R2,#&0f		; mask off LBA/DRV/magic bits
d2730 5
a2734 5
	ORR	R2,R1,R2,LSL #8		; shove them in
	LDRB	R1,IDERegLBAMid         ; get bits 8 to 15
	ORR	R2,R1,R2,LSL #8		; shove them in
	LDRB	R1,IDERegLBALow         ; get bits 0 to 7
	ORR	R2,R1,R2,LSL #8		; shove them in
d2738 2
a2739 2
	ASSERT	WinIDEBytesPerSector = 512
	MOV	R2,R2,LSL #9
d4410 2
a4411 2
 	DREG	R5,"Scatter list addr ="
	DREG	R6,"Scatter list len  ="
d4423 2
a4424 2
 	DREG	R5,"Scatter list addr ="
	DREG	R6,"Scatter list len  ="
d4440 2
a4441 2
 	DREG	R5,"Scatter list addr ="
	DREG	R6,"Scatter list len  ="
@


4.10
log
@Update to use some of the exported FileCore headers.
There are still a large number of local copies that should be visited, but this change at least allows it to assemble again FileCore-3_45.
Tungsten and IOMD variants assemble, but others untested.

Version 3.41. Tagged as 'ADFS-3_41'
@
text
@d302 1
a302 1
        TSTS    R1,#ScatterBit
d431 2
a432 2
        TSTS    R1,#ScatterBit          ; was there a scatter list provided?
        LDMEQIA R3,{R3,R4}              ; if no, get faked one
d2784 1
a2784 1
        AND     R0,R1,#OpMask                   ; get opcode
d3945 1
a3945 1
        TSTS    R0,#NoEscape                    ; escape allowed?
@


4.9
log
@Update to work with zero page relocation
Detail:
  s/ADFS, s/Adfs00, s/Adfs50 - Use OS_ReadSysInfo 6 to get ESC_Status location and store it in module workspace
  s/Adfs05 - Updated debug code to use OS_ReadSysInfo 6 to get IRQsema location. Updated CheckEscape to use local ESC_Status pointer, and updated it to only be compiled if it's actually needed
  s/Adfs10, s/Adfs14, s/Adfs15, s/Adfs17 - Use local ESC_Status pointer
Admin:
  Tested (with low processor vectors) in Iyonix ROM softload
  Note that FIQ handlers haven't been updated to support high vectors, since they aren't currently used on any hardware capable of using high vectors


Version 3.40. Tagged as 'ADFS-3_40'
@
text
@d2785 2
a2786 2
        TEQS    R0,#WriteTrkOp                  ; format?
        MOVEQ   R0,#WriteSecsOp                 ; if so, treat as write
d2788 2
a2789 2
        TEQS    R0,#ReadSecsOp                  ; is it read ?
        TEQNES  R0,#WriteSecsOp                 ; if not, is it write ?
d2814 1
a2814 1
        TEQS    R0,#ReadSecsOp
@


4.8
log
@  Reintroduced support for IOMD machines
Detail:
  There was no "Ver" file for Machine=32, and the code for build switch
  settings appropriate for IOMD had not been kept up-to-date with various
  changes to the module which were made to support Tungsten. This version
  provides working IDE support for IOMD HAL builds, although there are
  still some issues with floppy support. Tungsten builds should be
  functionally identical.
Admin:
  Tested on a Risc PC. Joint development effort by Tom Walker and Ben Avison.

Version 3.37. Tagged as 'ADFS-3_37'
@
text
@d3950 2
a3951 2
        MOV     R0,#0                           ; R0 -> low memory
        LDRB    R0,[R0,#ESC_Status]             ; get escape flag
@


4.7
log
@* DMA support completed.
* Selects PIO/DMA/Ultra DMA modes appropriate for each device.
* DMA support added to ADFS_IDEUserOp, but not yet ADFS_ATAPIOp.
* WinIDEMaxSectorsPerTransfer increased to 256.
* Floppy driver reattaches to DMA Manager if it's reinitialised.

Version 3.35. Tagged as 'ADFS-3_35'
@
text
@d2813 1
a2813 1
        ADR     R10,LowCodeLocation     ; R10 -> where code will go
d2840 1
a2840 1
        ADR     R1,LowCodeLocation       ;start virtual address
d2921 1
d2923 1
a2923 1
        ADR     PC,LowCodeLocation      ; i.e. B LowCodeLocation
d2929 2
d2932 1
a2932 1
        ADR     PC,LowCodeLocation
d3123 1
d3125 1
a3125 1
        ADR     PC,LowCodeLocation      ; i.e. BCS LowCodeLocation
d3131 1
d3133 1
a3133 1
        ADR     PC,LowCodeLocation
@


4.6
log
@* ADFS_DiscOp64 and ADFS_ATAPIOp added.
* New FileCore error passing scheme supported.
* PCI floppy support functional.
* 48-bit LBA support added for ADFS_IDEUserOp and accessing beyond the
  first 128GB of a drive - not thoroughly tested.
* IDE autodetection improved

Version 3.34. Tagged as 'ADFS-3_34'
@
text
@d15 1
a15 1
       SUBT    IDE Winchester low level routines -> Adfs14
d252 5
d701 1
d704 1
d715 1
a727 1
        LDRB    R6,WinIDECommandCode            ; get command
d765 72
d842 1
a842 2
        TST     LR,#WinIDECmdFlag_48bit
        ORRNE   R0,R0,#bit9
d853 1
d911 6
d1102 6
d1304 1
a1304 1
        BNE       %FT99
d1308 45
d1380 1
a1380 1
	DREG	R3,"Sector offset in: "
d1389 1
a1389 1
	DREG	R3,"Sector offset out: "
d1527 4
d1540 2
a1541 1
; Op was verify or write
d1543 9
a1551 2
        LDRB    R2,IDERegSecCount       ; get sectors not done
        LDR     R6,WinIDESaveLumpSize   ; and what we SHOULD have done
d1553 4
a1556 1
        SUBS    R6,R6,R2,LSL #9         ; R6 = amount done
d1559 3
a1561 3
; If >0, update the scatter list entry - this is all that needs to be updated
; as the op is now aborting.
; If <=0, do NOT update scatter list - controller is misbehaving
d1564 1
d1625 4
d1794 1
a1794 1
        sbaddr  R9,WinIDEHardware]
d1828 11
d2014 7
d2280 1
a2280 1
        DREG    R1,"WinIDESetPhysAddressCHS: ParmSecNumber=",cc
d2299 1
a2299 1
        DREG    R1,"WinIDESetPhysAddressCHS: ParmCylLo=",cc
d2306 1
a2306 1
        DREG    R1,"WinIDESetPhysAddressCHS: ParmCylHi=",cc
d2401 6
d2444 1
a2444 1
        TSTS    R0,#bit8
d2450 6
a2455 1
        Pull    "R1,PC",NE
d2459 1
a2459 1
        TSTS    R0,#bit9
d2532 1
a2532 1
        Pull    "R1,PC"                         ; no error
d2565 3
a2567 3
        TSTS    R0,#IDEErrorBBK         ; bad block?
        MOVNE   R0,#WinIDEErrBBK        ; if so, return it
        MOVNE   PC,LR
d2591 5
d2727 1
a2727 1
        MOVNE   R2,#0                   ; if so, ignore the drive register
d2729 1
a2729 1
        LDRB    R1,IDERegLBAHigh        ; get bits 16..23
a2735 6
; read extra bits if 48-bit command
        MOVNE   R1,#IDEDevCtrlHOB       ; switch to high order bits
        STRNEB  R1,IDERegDevCtrl
        LDRNEB  R1,IDERegLBALow         ; get bits 24..31
        ORRNE   R2,R2,R1,LSL #24

d2742 4
d2748 9
d3158 3
a3160 4
        SUBS    R0,R0,#1                ; adjust count. if out of data...
        MOVMI   R8,#0                   ; ...fill sector with 0
        LDRPLB  R8,[R1],#1              ; ...else get data
        ORR     R2, R2, R8, LSL #8
d3164 1
a3164 1
        ORR     R2, R2, R2, ASL #16
d3236 12
a3247 13
        SUBS    R0,R0,#1                ; adjust count. if out of data...
        MOVMI   R8,#0                   ; ...fill sector with 0
        LDRPLB  R8,[R1],#1              ; ...else get data
        ORR     R2, R2, R8, LSL #8
        SUBS    R0,R0,#1                ; adjust count. if out of data...
        MOVMI   R8,#0                   ; ...fill sector with 0
        LDRPLB  R8,[R1],#1              ; ...else get data
        ORR     R2, R2, R8, LSL #16
        SUBS    R0,R0,#1                ; adjust count. if out of data...
        MOVMI   R8,#0                   ; ...fill sector with 0
        LDRPLB  R8,[R1],#1              ; ...else get data
        ORR     R2, R2, R8, LSL #24
        STR     R2,IDERegData           ; write the data
d4133 12
d4339 364
@


4.5
log
@32-bit conversion started, Tungsten hard disc support added.
Hard disc functional, but PIO mode only. Don't go near the floppy.

Version 3.33. Not tagged
@
text
@d129 1
a129 1
; Made SetPhysAddress preserve flags and make chouce of
d352 3
d356 1
a356 1
	SUB	R0,R0,R2		; R0= sectors to end of disc
d365 1
a365 1
	MOVCC	R4,R0			; ...use it instead
d722 1
d750 2
d761 5
d839 1
d1041 1
d1054 1
d1169 1
d1392 1
d1397 1
d1467 1
d1656 1
d1753 3
d1801 4
d1938 7
d2029 12
d2043 1
a2043 3
	MOV	R0,R0,LSR #8

	ORR	R0,R0,#IDEDrvLBA24to27MagicBits		; magic bits - with LBA flag set
a2066 1
 [ IDEFixedLowSector
a2067 3
 |
;    WinIDEDriveNum, WinIDESecsPerTrk, WinIDEHeads, WinIDEStartSec valid
 ]
a2102 1
 [ IDEFixedLowSector
a2103 4
 |
        LDRB    LR,WinIDEStartSec       ; adjust sector number...
        ADD     R1,R1,LR                ; ...according to start number
 ]
d2175 30
d2215 1
d2274 28
d2314 1
a2314 1
        LDRB    LR,WinIDEParmSecNumber
d2316 1
a2316 1
        BREG    LR,"WinIDECommandDisc: SecNumber="
d2318 1
a2318 1
        STRB    LR,IDERegSecNumber
d2320 1
a2320 1
        LDRB    LR,WinIDEParmCylLo
d2322 1
a2322 1
        BREG    LR,"WinIDECommandDisc: CylLo="
d2324 1
a2324 1
        STRB    LR,IDERegCylLo
d2326 1
a2326 1
        LDRB    LR,WinIDEParmCylHi
d2328 1
a2328 1
        BREG    LR,"WinIDECommandDisc: CylHi="
d2330 1
a2330 1
        STRB    LR,IDERegCylHi
d2408 41
d2484 1
a2484 1
;    R2 = logical disc address
a2512 1
 [ IDEFixedLowSector
a2513 4
 |
        LDRB    R1,WinIDEStartSec       ; R1 = lowest-numbered sector on track
        SUB     R2,R2,R1
 ]
d2529 2
a2530 2
	; generate the info based on the LBA addressing mechanism
        ; we already have some of the address in R2, bits 24..27
d2532 8
a2539 2
	AND	R2,R2,#&0f		; mask off LBA/DRV/magic bits
	LDRB	R1,IDERegLBA16to23	; get bits 16..23
d2541 1
a2541 1
	LDRB	R1,IDERegLBA8to15	; get bits 8 to 15
d2543 1
a2543 1
	LDRB	R1,IDERegLBA0to7	; get bits 0 to 7
d2545 7
d2558 1
a2558 1
	MOV	PC,LR
d2754 4
a2757 1
        MOV     R3,#&200                ; must read whole sector to please HDC
d2829 4
a2832 1
        MOV     R3,#&200                ; must read whole sector to please HDC
d2834 3
a2836 1
        LDR     R2,IDERegData           ; get 4 bytes
d2850 1
d2953 4
a2956 1
        MOV     R3,#&200                ; must write whole sector to please HDC
d3032 4
a3035 1
        MOV     R3,#&200                ; must write whole sector to please HDC
d3121 1
a3121 1
        LDRB    R2,[R0,R1]                      ; get physical drive number
d3148 1
a3148 1
        BEQ     %FT12
d3215 1
a3215 1
        Pull    "R0-R3,IDECtrl,IDE,PC"          ; return
d3217 1
a3217 1
        Pull    "R0-R3,IDE,PC"                  ; return
d3229 1
a3229 1
        SETPSR  SVC_mode,LR,,R2                 ; switch to SVC mode
d3251 1
a3251 1
        Pull    "R0-R3,IDECtrl,IDE,PC"          ; return
d3253 1
a3253 1
        Pull    "R0-R3,IDE,PC"                  ; return
d3361 1
a3361 1
;          R0 undefined
d3372 7
d3434 1
a3434 1
; timeout, EQ
d3444 1
d3447 1
a3447 2
; EQ => timeout, R0 = ErrTimeout
; NE => got an IRQ, need status
d3449 2
a3450 2
        MOVNE   R0,#0                           ; if IRQ, stop timer...
        STRNE   R0,WinTickCount                 ; ...to speed things up
d3452 2
a3453 2
        LDRNEB  R0,IDERegStatus                 ; ...clear the IRQ...
        BLNE    WinIDEDecodeDriveStatus         ; ...and sort out status
d3462 47
d3540 2
a3541 2
        MOV     R0,#bit2                ; SRST
        STRB    R0,IDERegDigOutput
d3552 2
a3553 2
        MOV     R0,#bit2                ; SRST
        STRB    R0,IDERegDigOutput
d3564 1
a3564 1
        STRB    R0,IDERegDigOutput
d3573 1
a3573 1
        STRB    R0,IDERegDigOutput
d3616 1
a3616 1
;          R0 undefined
d3620 1
a3620 1
        Push    "R0,R1,R9,IDECtrl,IDE,LR"
d3622 1
a3622 1
        Push    "R0,R1,R9,IDE,LR"
a3656 1
        ADDNE   SP,SP,#4
a3666 1
20
d3671 1
d3676 1
a3676 1
        TEQS    R0,#IDEStatusDRDY       ; ready?
d3678 1
a3678 1
        TEQNES  LR,#0                   ; expired?
d3683 3
a3685 9
        CLRV
        TSTS    R0,#IDEStatusDRDY       ; NE => drive ready
 [ HAL
        Pull    "R0,R1,R9,IDECtrl,IDE,PC",NE
 |
        Pull    "R0,R1,R9,IDE,PC",NE
 ]
        MOV     R0,#WinIDEErrCmdNotRdy  ; if not ready...return error
        SETV
d3687 1
a3687 1
        Pull    "R0,R1,R9,IDECtrl,IDE,PC"
d3689 1
a3689 1
        Pull    "R0,R1,R9,IDE,PC"
d4100 1
a4100 3
; disable IRQs

        SETPSR  I_bit,LR,,R0
d4102 2
a4103 1
; lock controller if possible
d4105 1
a4105 4
        LDRB    LR,WinIDECommandActive  ; get flag
        TEQS    LR,#0                   ; unlocked?
        MOVEQ   LR,#1                   ; if so, lock it
        STREQB  LR,WinIDECommandActive
d4107 1
a4107 1
; return status and restore IRQ state
d4109 1
a4109 3
        BICEQ   R0,R0,#V_bit            ; ...and return VC
        ORRNE   R0,R0,#V_bit            ; if already locked, return VS
        RestPSR R0,,cf
d4129 1
a4129 1
        STRB    LR,WinIDECommandActive
@


4.4
log
@  Loading to/saving from top-bit-set addresses should now work.
Detail:
  The problem was in the API definition of the scatter lists used in
  background data transfer. These consist of a sequence of word pairs,
  holding addresses and lengths; any negative (ie top-bit-set) address word
  is defined to mean that the list continues at an location that is offset
  by that amount. To get around this, the check is now made not on whether
  the address word is negative, but on whether it is equal to or greater
  than (less negative than) &FFFF0000. This means that accesses to these
  addresses will still fail, but such addresses should be reserved for
  system use anyway.
Admin:
  Tested briefly.

Version 3.33. Tagged as 'ADFS-3_33'
@
text
@d286 2
a287 2
        TEQS    R4,#0
        BICEQS  PC,LR,#V_bit            ; return (no error) if nothing to do
d319 2
a320 2
        TEQS    R5,#0                   ; null entry?
        BICEQS  PC,LR,#V_bit            ; return (no error) if nothing to do
d404 1
a404 2
        MOV     LR,PC                   ; save current irq state
        TEQP    PC,#SVC_mode            ; enable IRQs
d413 1
a413 1
        TEQP    PC,LR                   ; restore IRQ state
d563 1
a563 2
        Pull    "R4,LR"
        ORRS    PC,LR,#V_bit            ; error
d573 2
a574 2
        Pull    "R4,LR"
        BICS    PC,LR,#V_bit            ; return to caller (status ok)
a673 21
 [ IDEAllowTrackWrap
 |

; See if there is that much data left on track

        LDRB    R4,WinIDESecsPerTrk             ; R4 = secs per track
        LDRB    R2,WinIDEAdrSector              ; R2 = 0..WinIDESecsPerTrk-1
        SUB     R4,R4,R2                        ; NOTE R4 != 0
        ASSERT  WinIDEBytesPerSector = 512
        MOV     R4,R4,LSL #9                    ; convert to bytes

; R1 = bytes we want
; R4 = bytes left on track
; make R1 = MIN(R1,R4)

        CMPS    R4,R1                           ; want less than on track?
        MOVLO   R1,R4                           ; if yes, ask for that much

; R1 = MIN(bytes we want, bytes on track)

 ]
d788 24
a811 1
        ADD     R0,SB,#:INDEX:WinIDEIRQPtr      ; R0-> interrupt mask reg
d814 1
a814 3
        LDR     R2,=DefaultIDE
        TEQS    R2,IDE                          ; motherboard?
        LDREQB  R2,[R0]                         ; yes, get IOC mask
d817 1
d827 3
a829 4
        TEQS    R6,#IDECmdWriteSecs             ; write?
        TEQNES  R6,#IDECmdFormatTrk             ; or format?
        Pull    "R1-R6,R8-R9,LR",NE             ; return if not
        BICNES  PC,LR,#V_bit
d858 1
a858 1
        TEQS    R1,#0                           ; giving up?
d860 2
a861 2
        Pull    "R1-R6,R8-R9,LR",EQ
        ORREQS  PC,LR,#V_bit
d872 6
d879 1
a879 1
        LDR     PC,WinIDEWritePtr               ; (R0,R1,IDE->R0,R1)
d886 2
a887 2
        Pull    "R1-R6,R8-R9,LR"
        BICS    PC,LR,#V_bit
d904 5
a908 1
WinIDEIRQRegsB  SETS    "R0-R8,IDE"
d929 1
a929 2
        MOV     R0,PC                           ; save mode
        TEQP    PC,#SVC_mode :OR: I_bit         ; keep IRQs disabled
d936 15
a956 4
; Set IDE -> IDE controller

        LDR     IDE,WinIDEPtr           ; IDE -> IDE hardware

d963 16
a978 1
        ADD     R4,SB,#:INDEX:WinIDEIRQPtr ; R4 -> address of irq mask reg
d981 3
a983 3
        LDR     R1,=DefaultIDE          ; get address of motherboard IDE
        TEQS    R1,IDE                  ; motherboard?
        LDREQB  R1,[R4]                 ; yes, get IOC mask
d986 1
d1043 1
a1043 1
        LDR     LR, WinIDEReadPtr
d1051 1
a1051 1
        LDREQ   PC,WinIDEReadPtr        ; ...(R0,R1,IDE->R0,R1)
d1186 1
a1186 1
        LDR     PC,WinIDEWritePtr       ; (R0,R1,IDE->R0,R1)
a1220 43
 [ IDETrustDrive

; Update real scatter list with amount transferred
; This is ok even if the scatter list was faked as the first update
; will terminate the updating

        MOV     R2,R6                   ; save block size
        LDR     R6,WinIDESaveLumpSize   ; R6 = amount transferred
        LDR     R3,WinIDEScatterPtr     ; R3 -> scatter list at start of op
        BL      WinIDEUpdateScatterList ; (R3,R6->R3-R6,R8)
        MOV     R6,R2                   ; restore R6 = block size


; R3 -> real scatter list
; R4,R5 = scatter list entry (possibly R5=0)
; R6 = size of previous lump

; Convert physical address back to logical address

        BL      WinIDEPhysAddrToLogical         ; (IDE->R1,R2)

; R2 = disc address of current sector - adjust for data just transferred
; If the op is VERIFY, must add just one sector not the whole blocksize
; which, for verify, is the same as the lumpsize.
; If the op is NOT verify, add the bytes out of this sector that we
; actually wanted (blocksize).

        TEQS    R7,#IDECmdVerify                ; if verify...
  [ EngineeringMode
        TEQNES  R7,#IDECmdVerifyEng
  ]
 [ BigDisc
        ADDEQ	R2,R2,#1			; add 1 sector
	ASSERT	WinIDEBytesPerSector=512	;
	ADDNE	R2,R2,R6,LSR #9			;
 |
        ADDEQ   R2,R2,#WinIDEBytesPerSector     ; ...add 1 sector...
        ADDNE   R2,R2,R6                        ; ...else add blocksize
 ]


 |

a1269 2
 ]

a1407 8
 [ IDETrustDrive

; convert physical address back to logical address

        BL      WinIDEPhysAddrToLogical ; (IDE->R1,R2)

 |

a1412 1
 ]
d1477 16
a1492 1
        ADD     R4,SB,#:INDEX:WinIDEIRQPtr ; R4 -> address of irq mask reg
d1495 3
a1497 3
        LDR     R1,=DefaultIDE          ; get address of motherboard IDE
        TEQS    R1,IDE                  ; motherboard?
        LDREQB  R1,[R4]                 ; yes, get IOC mask
d1500 1
d1534 17
a1550 1
        ADD     R4,SB,#:INDEX:WinIDEIRQPtr ; R4 -> address of irq mask reg
d1553 3
a1555 3
        LDR     R1,=DefaultIDE          ; get address of motherboard IDE
        TEQS    R1,IDE                  ; motherboard?
        LDREQB  R1,[R4]                 ; yes, get IOC mask
d1558 1
d1580 1
a1580 1
        TEQP    PC,R0
d1585 1
a1585 1
        Pull    "$WinIDEIRQRegsA,PC",,^
d1608 1
a1608 2
        MOV     R0,PC                   ; save mode
        TEQP    PC,#SVC_mode :OR: I_bit ; keep IRQs disabled
d1617 13
a1629 1
        LDR     IDE,WinIDEPtr           ; IDE -> IDE hardware
d1676 1
a1676 1
;    All other registers and flags preserved
d1707 1
a1707 1
        MOVS    PC,LR                   ; return
d1751 1
a1751 1
        MOVS    PC,LR                           ; and return
d1770 1
a1770 1
;    All registers and flags preserved
d1842 1
a1842 1
        Pull    "R0-R5,PC",,^
d1933 1
a1933 1
        Pull    "R0-R5,PC",,^
d1955 2
a1956 1
	Push	"R1,LR"
d1967 1
a1967 1
	CMPS	R0,#7
a1981 2
 	ASSERT	IDEAllowTrackWrap

d2004 2
a2005 1
	Pull	"R1,PC",,^
d2009 2
a2010 1
	Pull	"R1,LR"
a2032 4
 [ IDEAllowTrackWrap
 |
;    WinIDEAdrSector = sector number (from 0, not adjusted)
 ]
d2035 2
a2036 1
        Push    "R1,LR"
a2063 4
 [ IDEAllowTrackWrap
 |
        STRB    R1,WinIDEAdrSector      ; save sector number from 0 for calcs
 ]
d2110 2
a2111 1
        Pull    "R1,LR"
d2137 1
a2137 1
        Pull    "PC",,^
d2141 1
a2141 1
WinIDECommandDisc       ROUT
d2149 2
a2150 1
;    R0 = command
d2175 2
a2176 2
        Pull    "R1,LR",NE
        ORRNES  PC,LR,#V_bit
d2199 2
d2204 2
a2205 2
        Pull    "R1,LR",NE
        ORRNES  PC,LR,#V_bit
d2213 1
a2213 1
        STRB    LR,IDERegPrecomp
d2254 1
a2254 2
        Pull    "R1,LR"
        BICS    PC,LR,#V_bit                    ; no error
d2268 1
a2268 1
;    All other registers and flags preserved
d2274 1
a2274 1
        MOVNES  PC,LR
d2276 1
a2276 1
        TSTS    R0,#IDEStatusWFT        ; write fault?
d2278 1
a2278 1
        MOVNES  PC,LR
d2282 1
a2282 1
        MOVEQS  PC,LR
d2289 1
a2289 1
        MOVNES  PC,LR
d2293 1
a2293 1
        MOVNES  PC,LR
d2297 1
a2297 1
        MOVNES  PC,LR
d2301 1
a2301 1
        MOVNES  PC,LR
d2305 1
a2305 1
        MOVNES  PC,LR
d2311 1
a2311 1
        MOVS    PC,LR
a2350 1
;    Flags preserved
d2397 1
a2397 1
        MOVS    PC,LR
d2416 2
a2417 1
	MOVS	PC,LR
d2419 1
d2451 1
a2451 1
        MOVNES  PC,LR                           ; if not needed, return
d2462 1
a2462 1
        Pull    "PC",EQ,^               ; if so, return
a2472 4
; Since this is the same code that the ST506 transfer code uses, it must
; address the IDE discs via the same register.

        ASSERT  IDE = HDC
d2515 3
a2517 1
        Pull    "R1-R10,PC",,^
d2522 3
d2551 2
a2552 1
        TEQP    PC,#SVC_mode            ; enable IRQs
d2564 2
d2570 1
a2570 6

; Make sure that HDC,HDCdataRead accesses the IDE data register
; If not, must save HDC, change it, do xfer, restore HDC

        ASSERT  IDE = HDC
        ASSERT  IDERegData = HDCdataRead
d2576 6
d2592 1
d2601 3
a2603 1
        Pull    "R2-R8,R10,PC",,^       ; return, restoring IRQ state
d2614 3
d2618 1
d2631 78
a2708 1
        Pull    "R2-R8,R10,PC",,^       ; return, restoring IRQ state
d2713 3
d2739 8
a2746 1
        Push    "R2-R9,IDE,LR"
d2750 2
a2751 1
        TEQP    PC,#SVC_mode            ; enable IRQs
d2764 5
a2768 6
; Make sure that HDC,HDCdataWrite accesses the IDE data register

        ASSERT  IDE = HDC

 [ IDERegData = HDCdataWrite
        !       0,"WinIDEWriteASector: can optimise"
a2769 7
   [ HDCdataWrite > IDERegData
        SUB     IDE,IDE,#HDCdataWrite - IDERegData
   |
        ADD     IDE,IDE,#IDERegData - HDCdataWrite
   ]
 ]

d2782 1
d2791 3
a2793 1
        Pull    "R2-R9,IDE,PC",,^       ; return, restoring IRQ state
a2806 3
 [ Top16Write
        MOV     R2,R2,LSL #16           ; (writes are high 16 bits)
 ]
a2809 1
 [ :LNOT: Top16Write
d2811 3
d2815 50
a2864 2
 |
        ORR     R2,R2,R8,LSL #24
d2866 29
d2896 1
a2896 1
        SUBS    R3,R3,#2                ; adjust bytes written so far
d2903 4
a2906 1
        Pull    "R2-R9,IDE,PC",,^       ; return, restoring IRQ state
d2920 1
a2920 1
;    All registers and flags preserved
d2929 1
a2929 1
        Pull    "PC",EQ,^                       ; return if not
d2933 1
a2933 1
        LDRB    LR,WinIDEIRQDevNo
d2935 5
a2939 1
        Pull    "PC",EQ,^                       ; return if not
d2945 1
a2945 1
        Pull    "PC",VS,^                       ; return if controller busy
d2949 5
a2953 1
        Push    "R0-R2,IDE"
d2960 1
a2960 1
        LDRB    R0,WinIDEDrives                 ; R3 = configured drives
d2962 1
a2962 1
        MOV     R2,#0                           ; drive 0
d2964 6
a2969 4
        LDRB    LR,[R1,R2]                      ; get drive state
        TEQS    LR,#WinIDEDriveStateReset       ; still just reset?
        ADDNE   R2,R2,#1                        ; if not, check next
        TEQNES  R2,R0                           ; all done?
d2974 1
a2974 1
        TEQS    R2,R0                           ; all done?
d2980 1
a2980 1
; R2 = drive number
d2985 18
a3002 1
        LDR     IDE,WinIDEPtr                   ; IDE -> controller
d3006 5
a3010 1
        Pull    "R0-R2,IDE,PC",NE,^             ; quit if so
d3023 5
a3027 1
        Pull    "R0-R2,IDE,PC",NE,^             ; quit if not
d3033 1
a3033 2
        MOV     R3,PC
        TEQP    PC,#SVC_mode :OR: I_bit
d3038 1
a3038 1
        TEQP    PC,R3
d3042 1
a3042 1
        ADD     LR,SB,#:INDEX: WinIDEPowerState ; LR -> power states
d3057 5
a3061 1
        Pull    "R0-R2,IDE,PC",,^               ; return
d3072 1
a3072 2
        MOV     R2,PC                           ; save current mode
        TEQP    PC,#SVC_mode :OR: I_bit         ; switch to SVC mode
d3088 1
a3088 1
        TEQP    PC,R2                           ; restore original mode
d3093 5
a3097 1
        Pull    "R0-R2,IDE,PC",,^               ; return
d3113 1
a3113 1
        Push    "R0-R2,LR"
d3123 1
a3123 1
        Pull    "R0-R2,PC",,^
d3140 1
a3140 1
;    All registers and flags preserved
d3157 1
a3157 1
        Pull    "R0-R1,PC",,^
d3173 1
a3173 1
        Push    "R0-R2,LR"
d3182 1
a3182 1
        Pull    "R0-R2,PC",,^
d3192 1
a3192 1
;    R0 = command
d3209 1
a3209 1
        Push    "R6,R7,LR"
d3213 1
a3213 1
        TEQP    PC,#SVC_mode
d3229 29
a3257 1
        ADR     R0,WinIDEPollPtr                ; R0 -> hardware details
d3271 1
a3271 1

d3294 2
a3295 2
        Pull    "R6,R7,LR"
        TEQP    PC,LR                           ; restore IRQ state
d3313 3
d3317 1
d3321 5
a3325 1
        LDR     IDE,WinIDEPtr
d3332 13
d3355 10
d3367 3
d3371 1
d3375 4
d3380 5
a3384 1
        Pull    "R0,IDE,PC",,^
d3408 5
a3412 1
        Push    "R0,R1,IDE,LR"
d3426 12
a3437 1
        LDR     IDE,WinIDEPtr
d3446 8
a3453 3
        Pull    "R0,R1,IDE,LR",NE       ; if still busy, return...
        MOVNE   R0,#WinIDEErrCmdBusy    ; ...error
        ORRNES  PC,LR,#V_bit            ; ...VS
d3473 1
d3475 12
a3486 4
        Pull    "R0,R1,IDE,LR"
        MOVEQ   R0,#WinIDEErrCmdNotRdy  ; if not ready...return error
        ORREQS  PC,LR,#V_bit
        BICS    PC,LR,#V_bit
d3496 3
d3500 1
d3539 1
d3542 1
a3542 1
        BICNES  PC,LR,#V_bit                    ; return if not
d3549 1
a3549 1
        BICEQS  PC,LR,#V_bit                    ; return if not
d3554 1
a3554 1
        ORRS    PC,LR,#V_bit
d3563 1
a3564 1
;    WinIDEHardware onwards describes IDE hardware
d3573 1
a3573 1
;    All other registers and flags preserved
d3576 1
a3576 1
        Push    "R1-R4,LR"
d3580 1
a3580 1
        TEQP    PC,#SVC_mode :OR: I_bit
d3584 2
a3585 3
        LDR     R0,WinIDEPtr                    ; get pointer to IDE
        LDR     R1,=DefaultIDE                  ; check if motherboard
        TEQS    R0,R1
d3587 1
a3587 1
; NE => podule IDE
d3593 6
a3598 4
        MOVNE   R0,#IOC
        LDRNEB  R1,[R0,#IOCIRQMSKB]
        ORRNE   R1,R1,#podule_IRQ_bit
        STRNEB  R1,[R0,#IOCIRQMSKB]
d3602 2
a3603 2
 [ IOMD
        MOVEQ   R0,#IOMD_IDE_DevNo
d3605 13
a3617 1
        MOVEQ   R0,#WinnieIRQ_DevNo
a3618 1
        MOVNE   R0,#Podule_DevNo
d3629 6
a3634 2
        LDRNE   R3,WinIDEPollPtr
        LDRNE   R4,WinIDEPollBits
d3651 3
a3653 1
        STRB    R0,WinIDEIRQDevNo
d3655 1
a3655 1
        Pull    "R1-R4,LR"                      ; restore regs
d3657 1
a3657 1
; restore IRQ state and return
a3658 2
        BICVCS  PC,LR,#V_bit
        ORRS    PC,LR,#V_bit
d3667 1
a3668 1
;    WinIDEHardware onwards describes IDE hardware
d3684 5
a3688 10
        LDRB    R0,WinIDEIRQDevNo               ; get dev no for call
 [ IOMD
        ASSERT  Podule_DevNo > IOMD_IDE_DevNo
        CMPS    R0,#IOMD_IDE_DevNo             ; check for podule
 |
        ASSERT  Podule_DevNo > WinnieIRQ_DevNo
        CMPS    R0,#WinnieIRQ_DevNo             ; check for podule
 ]
        Pull    "R1-R4,LR",CC                   ; return if not claimed
        BICCCS  PC,LR,#V_bit
d3695 4
a3698 2
        LDRHI   R3,WinIDEPollPtr                ; if podule, get status addr
        LDRHI   R4,WinIDEPollBits
d3702 1
a3702 1
        STRVCB  R1,WinIDEIRQDevNo
d3717 1
a3717 1
;    All registers and flags preserved
d3725 1
a3725 1
        Pull    "R0,PC",NE,^            ; NE => yes, so abort
d3732 1
a3732 1
        Pull    "R0,PC",EQ,^            ; return if so
d3736 1
a3736 1
        Pull    "R0,PC",NE,^            ; return if count != 0
d3742 1
a3742 1
        Pull    "R0,PC",EQ,^            ; return if address not initialised
d3751 1
a3751 1
        Pull    "R0,PC",,^
d3811 2
a3812 3
        TEQS    R0,#0
        Pull    "R1-R2,LR",EQ                   ; return if not
        BICEQS  PC,LR,#V_bit
d3842 13
a3854 1
        Push    "R1,R2,LR"
d3875 3
a3877 1
        Pull    "R1,R2,PC",,^
d3894 1
a3894 1
        Push    "LR"
d3898 1
a3898 2
        ORR     LR,LR,#I_bit
        TEQP    PC,LR
d3909 5
a3913 3
        Pull    "LR"
        BICEQS  PC,LR,#V_bit            ; ...and return VC
        ORRNES  PC,LR,#V_bit            ; if already locked, return VS
d3933 1
a3933 1
        Pull    "PC",,^
@


4.3
log
@Version RO_3_71 merged
@
text
@d307 5
d315 1
d486 5
d494 1
d640 5
d648 1
d1081 5
d1089 1
d1311 5
d1319 1
d1656 5
d1664 1
d1786 4
d1792 1
d1877 4
d1883 1
@


4.3.2.1
log
@This version of ADFS implements support for Ursula discs and stuff.

New SWI ADFS_IDEDeviceInfo

ADFS_IDEUserOp, ADFS_ControllerType modified for more drives.

Low level driver modified to use twin controllers.

Auto-detection of devices.  ProbeIDEDevices implemented to find them.

Mapping of devices made flexible to cope with any arrangement of devices.

Code to use ID information instead of boot block numbers not yet active,
needs to be brought up to date with autodetect code, and needs to do the
LBA side of things properly.

*configure IDETimeout added.

This uses CMOS byte 189, which ADFS previously used for approx winnie sizes,
but this is obsolete use.

To do:


Need to remove *configure IDEDiscs!

Need to support fast PIO modes and selection of appropriate mode.
@
text
@d33 1
a33 1
; Fixed incorrect updated of scatter list entry on read error.s
a401 3
 [ Debug20
	DLINE	"waiting for op done"
 ]
a403 28
	Push	"R0, R1"
	MOV	R0, #IOC
	LDR	R1, [R0, #IOCIRQMSKB]
	LDR	R1, [R0, #IOCIRQSTAB]
	LDR	R1, [R0, #IOCIRQREQB]
	LDR	R1, [R0, #IOMD2_INTENBL]
	LDR	R1, [R0, #IOMD2_INTSTA]
	LDR	R1, [R0, #IOMD2_INTREQ]
	Pull	"R0, R1"
 [ Debug20
	Push	"R0, R1"
	MOV	R0, #IOC
;	LDR	R1, [R0, #IOCIRQSTAB]
;	DREG	R1, "   IOCIRQSTAB: "
;	LDR	R1, [R0, #IOCIRQREQB]
;	DREG	R1, "   IOCIRQREQB: "
;	LDR	R1, [R0, #IOCIRQMSKB]
;	DREG	R1, "   IOCIRQMSKB: "
;	ORR	R1, R1, #8
;	STRB	R1, [R0, #IOCIRQMSKB]
	LDR	R1, [R0, #IOMD2_INTSTA]
	DREG	R1, " IOMD2_INTSTA: "
	LDR	R1, [R0, #IOMD2_INTREQ]
	DREG	R1, " IOMD2_INTREQ: "
	LDR	R1, [R0, #IOMD2_INTENBL]
	DREG	R1, "IOMD2_INTENBL: "
	Pull	"R0, R1"
 ]
a792 53
 [ TwinIDEHardware

  [ Debug21
	DLINE	"enable IRQ intially"
  ]

	LDR	R0, WinIDEIRQPtr
	LDR	R2, =DefaultIDE
	TEQS	R2, IDE
	LDREQ	R1, WinIDEIRQBits
 [ Debug21
	BNE	%FT01
	DLINE	"Is primary device"
01
 ]
	BEQ	%FT01

	; not IDE0, could be IDE2
	LDR	R2, =DefaultIDE2
	TEQS	R2, IDE

	BNE	%FT02
	LDR	R1, WinIDEIRQBits2
 [ Debug21
	DLINE	"Is secondary device"
 ]
01
 [ Debug21
	DREG	r1, "mask is:"
 ]
        LDRB    R2,[R0]                 ; yes, get IOMD mask
 [ Debug21
	DREG	r2, "IRQMSKB was: "
 ]
        ORR     R2,R2,R1                ; clear enable bit
        STRB    R2,[R0]                 ; write to IOMD
 [ Debug21
	DREG	r2, "Setting to: "
 ]

 [ Debug21
	DREG	R0, "mask addr: "
	Push	"R0"
	MOV	R0, #IOC
	ADD	R0, R0, #IOCIRQMSKB
	LDRB	R0, [R0]
	DREG	R0, "MSK initially set to: "
	Pull	"R0"
 ]

02

 |
a801 2
 ]

a885 2
WinIDEIRQHandler2
	MOV	r0, r0
a901 4
; [ Debug21
;	MOV	pc, #0
; ]

a910 4
 [ Debug20
	DLINE	"I!",cc
 ]

a926 25
 [ TwinIDEHardware
  [ Debug21
	DLINE	"disable IRQ"
  ]

	LDR	R4, WinIDEIRQPtr
	LDR	R1, =DefaultIDE
	TEQS	R1, IDE
	LDREQ	R5, WinIDEIRQBits
	BEQ	%FT01

	; not IDE0, could be IDE2
	LDR	R1, =DefaultIDE2
	TEQS	R1, IDE

	BNE	%FT02
	LDR	R5, WinIDEIRQBits2
01
        LDRB    R1,[R4]                 ; yes, get IOMD mask
        BIC     R1,R1,R5                ; clear enable bit
        STRB    R1,[R4]                 ; write to IOMD

02

 |
a935 2
 ]

d1233 1
a1233 1
 [ Debug22
a1466 25
 [ TwinIDEHardware
  [ Debug21
	DLINE	"disable IRQ cos of error"
  ]
	LDR	R4, WinIDEIRQPtr
	LDR	R1, =DefaultIDE
	TEQS	R1, IDE
	LDREQ	R5, WinIDEIRQBits
	BEQ	%FT01

	; not IDE0, could be IDE2
	LDR	R1, =DefaultIDE2
	TEQS	R1, IDE

	BNE	%FT02
	LDR	R5, WinIDEIRQBits2
01
        LDRB    R1,[R4]                 ; yes, get IOMD mask
        BIC     R1,R1,R5                ; clear enable bit
        STRB    R1,[R4]                 ; write to IOMD

02

 |

a1475 2
 ]

a1507 28
 [ TwinIDEHardware

  [ Debug21
	DLINE	"re-enable IRQ at end of IRQ handler"
  ]

	LDR	R4, WinIDEIRQPtr
	LDR	R1, =DefaultIDE
	TEQS	R1, IDE
	LDREQ	R5, WinIDEIRQBits
	BEQ	%FT01

	; not IDE0, could be IDE2
	LDR	R1, =DefaultIDE2
	TEQS	R1, IDE

	BNE	%FT02
	LDR	R5, WinIDEIRQBits2
01
        LDRB    R1,[R4]                 ; yes, get IOMD mask
        ORR     R1,R1,R5                ; set enable bit
        STRB    R1,[R4]                 ; write to IOMD

02


 |

a1516 2
 ]

a1886 3
 [ TwinIDEHardware
	LDRB	R1,WinIDEPhysDriveNum	; get drive number
 |
a1887 1
 ]
d1970 1
a1970 1
 [ Debug22
d2006 1
a2006 1
 [ Debug22
d2011 1
a2011 1
 [ Debug22
d2025 1
a2025 1
 [ Debug22
d2031 1
a2031 1
 [ Debug22
d2037 1
a2037 1
 [ Debug22
a2056 3
 [ TwinIDEHardware
;    WinIDEPhysDriveNum = physical drive number
 |
a2057 1
 ]
a2066 4
 [ TwinIDEHardware
        LDRB    LR,WinIDEPhysDriveNum           ; get drive number
	AND	LR, LR, #1			; just the master/slave bit
 |
a2067 1
 ]
a2126 24
 [ AutoDetectIDE

; check drive ready

; for IdentifyDevice, we need DRDY, but for IdentifyPacketDevice, we don't

	TEQS	r0, #IDECmdIdentifyPacket

	MOVEQ	R1, #IDEStatusBSY
	MOVNE	R1, #IDEStatusBSY :OR: IDEStatusDRDY

        LDRB    LR,IDERegAltStatus              ; get status
 [ Debug21
        BREG    LR, "WinIDECommandDisc: AltStatus="
 ]
        AND     LR,LR,R1
	BIC	R1, R1, #IDEStatusBSY
        TEQS    LR,R1
        MOVNE   R0,#WinIDEErrCmdNotRdy          ; return error if not ready
        Pull    "R1,LR",NE
        ORRNES  PC,LR,#V_bit

 |

a2138 2
 ]

d2329 1
a2329 1
;        DREG    R2,"Get "
d2410 1
a2410 1
        ADRL    R10,LowCodeLocation     ; R10 -> where code will go
d2437 1
a2437 1
        ADRL    R1,LowCodeLocation       ;start virtual address
a2508 5
 [ AutoDetectIDE
	ADRL	R2, LowCodeLocation
	STR	PC, RomReturn		; set return address
	MOV	PC, R2			; i.e. B LowCodeLocation
 |
a2510 1
 ]
a2515 5
 [ AutoDetectIDE
	ADRL	R2, LowCodeLocation
	STR	PC, RomReturn		; set return address
	MOV	PC, R2			; i.e. B LowCodeLocation
 |
a2517 1
 ]
a2611 8
 [ AutoDetectIDE

	ADRL	R2, LowCodeLocation
	STR	PC, RomReturn	        ; set return address
	MOV	PC, R2			; i.e. B LowCodeLocation

 |

a2613 3

 ]

a2618 6

 [ AutoDetectIDE
	ADRL	R2, LowCodeLocation
	STR	PC, RomReturn
	MOV	PC, R2
 |
a2620 2

 ]
d2766 1
a2766 2
;        ADD     LR,SB,#:INDEX: WinIDEPowerState ; LR -> power states
	sbaddr	LR, WinIDEPowerState
a2945 7
 [ TwinIDEHardware
	LDRB	R0, WinIDEPhysDriveNum
	LDR	R5, WinIDEPollPtr
	TSTS	R0, #2
	LDREQ	R6, WinIDEPollBits
	LDRNE	R6, WinIDEPollBits2
 |
a2947 1
 ]
a3024 3
 [ TwinIDEHardware
        ASSERT  WinIDEMaxDrives = 4
 |
a3025 2
 ]

a3029 5
 [ TwinIDEHardware
        STRB    R0,WinIDEDriveState+2
        STRB    R0,WinIDEDriveState+3
 ]

a3039 3
 [ TwinIDEHardware
;    R0 = physical drive number
 |
a3040 1
 ]
a3060 16
 [ TwinIDEHardware
	TSTS	R0, #2
	LDREQ	IDE, WinIDEPrimaryPtr
	LDRNE	IDE, WinIDESecondaryPtr
	STR	IDE, WinIDEPtr

; Set up value to select drive
	AND	R0, R0, #1
        MOV     R0,R0,LSL #IDEDriveShift        ; put bit in position
        ORR     R1,R0,#IDEDrvHeadMagicBits      ; include magic bits

 [ Debug21
	DREG	R1, "Drv/head: "
 ]

 |
a3068 1
 ]
a3193 33
 [ TwinIDEHardware

	MOV	R0, #IOMD_IDE_DevNo
	baddr	R1, WinIDEIRQHandler
	MOV	R2, SB

 [ Debug21

        DREG    R0,"ClaimDevice R0-R2: ",cc
        DREG    R1,,cc
        DREG    R2
 ]
        SWI     XOS_ClaimDeviceVector
	MOVVS	R0, #0
	STRB	R0, WinIDEIRQDevNo


	MOV	R0, #33
	baddr	R1, WinIDEIRQHandler2
	MOV	R2, SB

 [ Debug21

        DREG    R0,"ClaimDevice R0-R2: ",cc
        DREG    R1,,cc
        DREG    R2
 ]
        SWI     XOS_ClaimDeviceVector
	MOVVS	R0, #0
	STRB	R0, WinIDEIRQDevNo2

 | ; ELSE (ie NOT TwinIDEHardware

a3248 2
 ] ; ENDIF TwinIDEHardware

a3277 35
 [ TwinIDEHardware
	LDRB	R0, WinIDEIRQDevNo
	TEQS	R0, #0
	BNE	%FT10

        baddr   R1,WinIDEIRQHandler             ; get handler address
        MOV     R2,SB                           ; and R12 value
        LDRHI   R3,WinIDEPollPtr                ; if podule, get status addr
        LDRHI   R4,WinIDEPollBits
        SWI     XOS_ReleaseDeviceVector         ; release device

        MOVVC   R1,#0                           ; flag device not claimed
        STRVCB  R1,WinIDEIRQDevNo

	Pull	"R1-R4,LR"			; if error, return it

10

	LDRB	R0, WinIDEIRQDevNo2
	TEQS	R0, #0
        Pull    "R1-R4,LR",EQ                   ; return if not claimed
        BICEQS  PC,LR,#V_bit

        baddr   R1,WinIDEIRQHandler2             ; get handler address
        MOV     R2,SB                           ; and R12 value
        LDRHI   R3,WinIDEPollPtr                ; if podule, get status addr
        LDRHI   R4,WinIDEPollBits
        SWI     XOS_ReleaseDeviceVector         ; release device

        MOVVC   R1,#0                           ; flag device not claimed
        STRVCB  R1,WinIDEIRQDevNo

	Pull	"R1-R4,PC"			; if error, return it

 |
a3301 1
 ]
@


4.2
log
@Taken from RiscOS 3.70
@
text
@d131 1
a131 1
; BLs instead of branching round code.  
d143 1
a143 1
; 
d290 1
a290 1
	
d320 1
a320 1
	
d358 1
a358 1
	
d376 1
a376 1
	
d386 1
a386 1
	
d391 1
a391 1
	
d470 1
a470 1
	
d500 4
d506 4
d512 1
a512 1
	
d538 1
a538 1
	
d543 1
a543 1
	
d589 1
a589 1
	
d608 1
a608 1
	
d655 1
a655 1
	
d701 1
a701 1
	
d761 1
a761 1
	
d766 1
a766 1
	
d807 1
a807 1
	
d816 1
a816 1
	
d937 1
a937 1
;	
d960 1
a960 1
	
d982 1
a982 1
	
d992 1
a992 1
	
d1002 1
a1002 1
	
d1048 1
a1048 1
	
d1107 1
a1107 1
	
d1123 1
a1123 1
	
d1212 1
a1212 1
	
d1237 1
a1237 1
	
d1313 1
a1313 1
	
d1319 1
a1319 1
	
d1336 1
a1336 1
	
d1385 1
a1385 1
	
d1435 1
a1435 1
	
d1482 1
a1482 1
	
d1528 1
a1528 1
	
d1639 1
a1639 1
	
d1971 1
a1971 1
	
d2007 1
a2007 1
	
d2012 1
a2012 1
	
d2026 1
a2026 1
	
d2032 1
a2032 1
	
d2038 1
a2038 1
	
d2182 1
a2182 1
	
d2328 1
a2328 1
	
d2417 1
a2417 1
	
d2447 1
a2447 1
	
d2475 1
a2475 1
	
d2484 1
a2484 1
	
d2523 1
a2523 1
	
d2547 1
a2547 1
	
d2575 1
a2575 1
	
d2585 1
a2585 1
	
d2626 1
a2626 1
	
d2660 1
a2660 1
	
d2797 1
a2797 1
	
d2833 1
a2833 1
	
d3057 1
a3057 1
	
d3235 1
a3235 1
	
@


4.1
log
@Initial revision
@
text
@d22 1
d141 2
d2426 8
d2833 60
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a2822 60
 [ IDEPower
IDEPowerBits  * PortableControl_IDEEnable
;*********************************************************************

WinIDEPowerShutdown     ROUT
;
; Entered every ten seconds to check whether the IDE drive has spun down.
; This ticker is only setup if we are running on a portable. It is safe, though
; pointless, to have it setup on a non portable machine.
;
; Entry:
;    SB -> static workspace
;    MODE: IRQ or SVC
;
; Exit:
;    All registers and flags preserved

        Push    "R0-R1,LR"
;
; Attempt to power-down the drive. WinIDEcontrol does nothing if not on a portable, or
; if the drive is already powered down. If drive is powered up, WinIDEcontrol calls
; Portable_Control to shut down the drive. This issues a service call which we (ADFS)
; receive. The service code asks the drive if it has spun-down, and if so allows the
; service call (a power-down request) to preceed. If the drive is spinning, the service
; call bit mask is adjusted to stop the power-down.
;
; We don't touch the state machine here!. That is done on receipt of
; Service_Portable (reason code PowerUp/PowerDown).
;
        MOV     R0, #0                          ; disable
        BL      WinIDEcontrol                   ; in R0=required state (disabled), out R1=Portable_Flags

        Pull    "R0-R1,PC",,^

;*********************************************************************

WinIDEKillPowerShutdown    ROUT
;
; Routine to remove WinIDEPowerShutdown from CallEvery.
; Called when module killed.
;
; Entry:
;    SB -> static workspace
;    MODE: SVC
;
; Exit:
;    All registers and flags preserved

        Push    "R0-R2,LR"

  [ Debug21
        DLINE   "KillPowerShutdown"
  ]
        ADR     R0,WinIDEPowerShutdown  ; R0 -> routine to remove
        MOV     R1,SB                   ; R1 = R12 value
        SWI     XOS_RemoveTickerEvent   ; remove the ticker routine

        Pull    "R0-R2,PC",,^
 ]

@


4.1.5.1
log
@Import from SrcFiler
@
text
@a2822 60
 [ IDEPower
IDEPowerBits  * PortableControl_IDEEnable
;*********************************************************************

WinIDEPowerShutdown     ROUT
;
; Entered every ten seconds to check whether the IDE drive has spun down.
; This ticker is only setup if we are running on a portable. It is safe, though
; pointless, to have it setup on a non portable machine.
;
; Entry:
;    SB -> static workspace
;    MODE: IRQ or SVC
;
; Exit:
;    All registers and flags preserved

        Push    "R0-R1,LR"
;
; Attempt to power-down the drive. WinIDEcontrol does nothing if not on a portable, or
; if the drive is already powered down. If drive is powered up, WinIDEcontrol calls
; Portable_Control to shut down the drive. This issues a service call which we (ADFS)
; receive. The service code asks the drive if it has spun-down, and if so allows the
; service call (a power-down request) to preceed. If the drive is spinning, the service
; call bit mask is adjusted to stop the power-down.
;
; We don't touch the state machine here!. That is done on receipt of
; Service_Portable (reason code PowerUp/PowerDown).
;
        MOV     R0, #0                          ; disable
        BL      WinIDEcontrol                   ; in R0=required state (disabled), out R1=Portable_Flags

        Pull    "R0-R1,PC",,^

;*********************************************************************

WinIDEKillPowerShutdown    ROUT
;
; Routine to remove WinIDEPowerShutdown from CallEvery.
; Called when module killed.
;
; Entry:
;    SB -> static workspace
;    MODE: SVC
;
; Exit:
;    All registers and flags preserved

        Push    "R0-R2,LR"

  [ Debug21
        DLINE   "KillPowerShutdown"
  ]
        ADR     R0,WinIDEPowerShutdown  ; R0 -> routine to remove
        MOV     R1,SB                   ; R1 = R12 value
        SWI     XOS_RemoveTickerEvent   ; remove the ticker routine

        Pull    "R0-R2,PC",,^
 ]

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a21 1
; MJS - Mike Stephens
a139 2
; 27-02-96 MJS
; StrongARM changes for modifying code
a2422 8
 [ StrongARM
        ;synchronise with respect to modified code
        MOV     R0,#1                    ;means range specified in R1,R2
        ADR     R1,LowCodeLocation       ;start virtual address
        SUB     R2,R10,#4                ;end virtual address (inclusive)
        SWI     XOS_SynchroniseCodeAreas ;do the necessary for extant ARM variant
 ]

a2821 60

 [ IDEPower
IDEPowerBits  * PortableControl_IDEEnable
;*********************************************************************

WinIDEPowerShutdown     ROUT
;
; Entered every ten seconds to check whether the IDE drive has spun down.
; This ticker is only setup if we are running on a portable. It is safe, though
; pointless, to have it setup on a non portable machine.
;
; Entry:
;    SB -> static workspace
;    MODE: IRQ or SVC
;
; Exit:
;    All registers and flags preserved

        Push    "R0-R1,LR"
;
; Attempt to power-down the drive. WinIDEcontrol does nothing if not on a portable, or
; if the drive is already powered down. If drive is powered up, WinIDEcontrol calls
; Portable_Control to shut down the drive. This issues a service call which we (ADFS)
; receive. The service code asks the drive if it has spun-down, and if so allows the
; service call (a power-down request) to preceed. If the drive is spinning, the service
; call bit mask is adjusted to stop the power-down.
;
; We don't touch the state machine here!. That is done on receipt of
; Service_Portable (reason code PowerUp/PowerDown).
;
        MOV     R0, #0                          ; disable
        BL      WinIDEcontrol                   ; in R0=required state (disabled), out R1=Portable_Flags

        Pull    "R0-R1,PC",,^

;*********************************************************************

WinIDEKillPowerShutdown    ROUT
;
; Routine to remove WinIDEPowerShutdown from CallEvery.
; Called when module killed.
;
; Entry:
;    SB -> static workspace
;    MODE: SVC
;
; Exit:
;    All registers and flags preserved

        Push    "R0-R2,LR"

  [ Debug21
        DLINE   "KillPowerShutdown"
  ]
        ADR     R0,WinIDEPowerShutdown  ; R0 -> routine to remove
        MOV     R1,SB                   ; R1 = R12 value
        SWI     XOS_RemoveTickerEvent   ; remove the ticker routine

        Pull    "R0-R2,PC",,^
 ]
@


4.1.3.2
log
@Version RO_3_71 taken
@
text
@d131 1
a131 1
; BLs instead of branching round code.
d143 1
a143 1
;
d290 1
a290 1

d320 1
a320 1

d358 1
a358 1

d376 1
a376 1

d386 1
a386 1

d391 1
a391 1

d470 1
a470 1

a499 4

; SBP 13 Dec 1996 Fix for ADFSBuffers<>0 on >2G discs

 [ {FALSE}
a501 4
 |
        CMPS    R4,#&400000             ; is this >=2Gbytes...
        MVNHS   R4,#&80000000           ; yes, so R4=2G-1
 ]
d504 1
a504 1

d530 1
a530 1

d535 1
a535 1

d581 1
a581 1

d600 1
a600 1

d647 1
a647 1

d693 1
a693 1

d753 1
a753 1

d758 1
a758 1

d799 1
a799 1

d808 1
a808 1

d929 1
a929 1
;
d952 1
a952 1

d974 1
a974 1

d984 1
a984 1

d994 1
a994 1

d1040 1
a1040 1

d1099 1
a1099 1

d1115 1
a1115 1

d1204 1
a1204 1

d1229 1
a1229 1

d1305 1
a1305 1

d1311 1
a1311 1

d1328 1
a1328 1

d1377 1
a1377 1

d1427 1
a1427 1

d1474 1
a1474 1

d1520 1
a1520 1

d1631 1
a1631 1

d1963 1
a1963 1

d1999 1
a1999 1

d2004 1
a2004 1

d2018 1
a2018 1

d2024 1
a2024 1

d2030 1
a2030 1

d2174 1
a2174 1

d2320 1
a2320 1

d2409 1
a2409 1

d2439 1
a2439 1

d2467 1
a2467 1

d2476 1
a2476 1

d2515 1
a2515 1

d2539 1
a2539 1

d2567 1
a2567 1

d2577 1
a2577 1

d2618 1
a2618 1

d2652 1
a2652 1

d2789 1
a2789 1

d2825 1
a2825 1

d3049 1
a3049 1

d3227 1
a3227 1

@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d131 1
a131 1
; BLs instead of branching round code.
d143 1
a143 1
;
d290 1
a290 1

d320 1
a320 1

d358 1
a358 1

d376 1
a376 1

d386 1
a386 1

d391 1
a391 1

d470 1
a470 1

a499 4

; SBP 13 Dec 1996 Fix for ADFSBuffers<>0 on >2G discs

 [ {FALSE}
a501 4
 |
        CMPS    R4,#&400000             ; is this >=2Gbytes...
        MVNHS   R4,#&80000000           ; yes, so R4=2G-1
 ]
d504 1
a504 1

d530 1
a530 1

d535 1
a535 1

d581 1
a581 1

d600 1
a600 1

d647 1
a647 1

d693 1
a693 1

d753 1
a753 1

d758 1
a758 1

d799 1
a799 1

d808 1
a808 1

d929 1
a929 1
;
d952 1
a952 1

d974 1
a974 1

d984 1
a984 1

d994 1
a994 1

d1040 1
a1040 1

d1099 1
a1099 1

d1115 1
a1115 1

d1204 1
a1204 1

d1229 1
a1229 1

d1305 1
a1305 1

d1311 1
a1311 1

d1328 1
a1328 1

d1377 1
a1377 1

d1427 1
a1427 1

d1474 1
a1474 1

d1520 1
a1520 1

d1631 1
a1631 1

d1963 1
a1963 1

d1999 1
a1999 1

d2004 1
a2004 1

d2018 1
a2018 1

d2024 1
a2024 1

d2030 1
a2030 1

d2174 1
a2174 1

d2320 1
a2320 1

d2409 1
a2409 1

d2439 1
a2439 1

d2467 1
a2467 1

d2476 1
a2476 1

d2515 1
a2515 1

d2539 1
a2539 1

d2567 1
a2567 1

d2577 1
a2577 1

d2618 1
a2618 1

d2652 1
a2652 1

d2789 1
a2789 1

d2825 1
a2825 1

d3049 1
a3049 1

d3227 1
a3227 1

@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

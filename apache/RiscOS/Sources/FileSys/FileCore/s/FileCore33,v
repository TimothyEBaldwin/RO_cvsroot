head	4.13;
access;
symbols
	FileCore-3_75:4.13
	FileCore-3_74:4.13
	FileCore-3_73:4.13
	FileCore-3_72:4.13
	FileCore-3_71:4.13
	FileCore-3_70:4.13
	FileCore-3_69:4.13
	FileCore-3_68:4.13
	FileCore-3_67:4.13
	FileCore-3_66:4.13
	FileCore-3_65:4.13
	FileCore-3_64:4.13
	FileCore-3_63:4.13
	FileCore-3_62:4.13
	FileCore-3_61:4.13
	FileCore-3_60:4.13
	FileCore-3_59:4.13
	FileCore-3_58:4.13
	FileCore-3_57:4.13
	FileCore-3_56:4.13
	FileCore-3_55:4.12
	FileCore-3_54:4.11
	FileCore-3_53:4.11
	FileCore-3_52:4.11
	FileCore-3_51:4.11
	FileCore-3_50:4.11
	FileCore-3_49:4.11
	FileCore-3_48:4.10
	FileCore-3_47:4.10
	FileCore-3_46:4.9
	FileCore-3_45:4.8
	FileCore-3_44:4.7
	FileCore-3_43:4.7
	FileCore-3_42:4.7
	FileCore-3_41:4.7
	FileCore-3_40:4.7
	FileCore-3_39:4.7
	FileCore-3_38:4.7
	FileCore-3_37:4.7
	FileCore-3_36:4.7
	FileCore-3_35:4.7
	FileCore-3_34:4.7
	FileCore-3_33:4.7
	RO_5_07:4.6
	FileCore-3_32:4.6
	FileCore-3_31:4.6
	FileCore-3_30:4.6
	FileCore-3_29:4.6
	FileCore-3_28:4.6
	FileCore-3_25-4_9_2_2:4.6
	FileCore-3_27:4.6
	FileCore-3_26:4.6
	FileCore-3_22-4_6_2_1:4.4
	bavison_FileCore-3_22_dev_bp:4.4
	bavison_FileCore-3_22:4.4.0.2
	FileCore-3_25-4_9_2_1:4.6
	HAL:4.6.0.2
	FileCore-3_25:4.6
	FileCore-3_24:4.6
	FileCore-3_23:4.5
	dellis_autobuild_BaseSW:4.4
	FileCore-3_22:4.4
	Ursula_merge:4.2.2.6
	ROL_merge:4.2.2.6
	FileCore-3_21:4.4
	ROL_Ursula_merge:4.2.2.6
	Ursula_RiscPC_merge:4.2.2.6
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.6
	ROL_FileCore-3_21:4.2.2.6
	ROL_FileCore-3_20:4.2.2.6
	ROL:4.2.2.6.0.4
	ROL_bp:4.2.2.6
	Ursula_RiscPC_bp:4.2.2.6
	FileCore-3_18:4.2.2.6
	FileCore-3_01:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.6
	Ursula_RiscPC:4.2.2.6.0.2
	FileCore-3_00:4.3
	FileCore-2_99:4.3
	aglover_FileCore-3_17:4.2.2.6
	sproven_FileCore-3_16:4.2.2.6
	rthornb_UrsulaBuild-19Aug1998:4.2.2.6
	UrsulaBuild_FinalSoftload:4.2.2.6
	rthornb_UrsulaBuild-12Aug1998:4.2.2.6
	aglover_UrsulaBuild-05Aug1998:4.2.2.6
	rthornb_UrsulaBuild-29Jul1998:4.2.2.6
	rthornb_UrsulaBuild-22Jul1998:4.2.2.6
	rthornb_UrsulaBuild-15Jul1998:4.2.2.6
	rthornb_UrsulaBuild-07Jul1998:4.2.2.6
	rthornb_UrsulaBuild-17Jun1998:4.2.2.6
	rthornb_UrsulaBuild-03Jun1998:4.2.2.6
	rthornb_UrsulaBuild-27May1998:4.2.2.6
	rthornb_UrsulaBuild-21May1998:4.2.2.6
	sproven_FileCore-3_15:4.2.2.6
	sproven_314:4.2.2.6
	rthornb_UrsulaBuild_01May1998:4.2.2.5
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.2.2.5
	sproven_3_11:4.2.2.5
	sproven_3_10:4.2.2.5
	sproven_Ursula_3_09:4.2.2.5
	sproven_3_07:4.2.2.4
	sproven_3_06:4.2.2.4
	sproven_3_05:4.2.2.4
	sproven_3_04:4.2.2.3
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.2.2.3
	sproven_3_02:4.2.2.3
	sproven_3_01:4.2.2.2
	sproven_2_99:4.2.2.1
	sproven_2_98:4.2
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2013.02.24.21.09.15;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	rgJG8ZFRF8o9ruFw;

4.12
date	2013.02.21.16.53.08;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	CCuV2tngKttj75Fw;

4.11
date	2012.03.24.10.51.30;	author jlee;	state Exp;
branches;
next	4.10;
commitid	yHV7AVt5Cxp0R7Yv;

4.10
date	2011.11.25.08.50.22;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	Wvsb4iMJaWIw2HIv;

4.9
date	2011.11.25.08.26.06;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	IoNdwgrOKH29UGIv;

4.8
date	2011.10.14.07.23.51;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	D2Id4aPp4zmuUhDv;

4.7
date	2009.05.17.01.48.31;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2000.10.31.09.32.30;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.09.11.36.56;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.09.21.12.07.17;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.18.44;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.32.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.08.14.13.13.11;	author sproven;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.09.16.14.46.44;	author sproven;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	97.11.17.13.32.29;	author sproven;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	98.01.09.11.45.02;	author sproven;	state Exp;
branches;
next	4.2.2.5;

4.2.2.5
date	98.01.30.17.53.07;	author sproven;	state Exp;
branches;
next	4.2.2.6;

4.2.2.6
date	98.05.07.16.58.10;	author sproven;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.32.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.24.47;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.07;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.00;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >FileCore33
;
; 15 May 1997 SBP: Added Free versions of all the RdLenBits and WrLenBits etc functions.  Modified UnusedId,
;                  NextFree, ChainClaim, ShortenFrag, InitZoneObj.
;
; 19-Sep-1994 SBP: Added BigDisc support to FindFileFragment, MapDiscAdd, MapPtrToDiscAdd, DiscAddToMapPtr
;

        TTL     "New map small routines"

; ===================
; DefFindFileFragment
; ===================

DefFindFileFragment
        MOV     R9, #-1  ;fall through to FindFileFragment

; ================
; FindFileFragment
; ================

;entry
; R2 ind disc address of object start
; R5 offset from start of linked object
; R9 map ptr to a gap or -1

;exit
; R2 file offset disc add
; R4 length left in fragment
; R9 map ptr to gap before frag
; LR fragment start disc add

FindFileFragment
        Push    "R0,R1,R3,R5,R6,R10,R11,LR"
 [ DebugE
        DREG    R2, "FindFileFragment(file add:",cc
        DREG    R5, ", offset:",cc
        DREG    R9, ", gap ptr:",cc
        DLINE   ")"
 ]
        MOV     R3, R2
        BL      InitReadNewFs   ;(R3->R10,R11,LR)

; we move the sector offset from the ind disc addr to file offset - this
; makes finding the fragment simpler


        ANDS    R0, R2, #&FF    ;add any sector offset within frag
        BIC     R2, R2, #&FF
        SUBNE   R0, R0, #1

 [ BigDisc
  [ BigShare
        LDRB    R6, [LR,#DiscRecord_BigMap_ShareSize]     ; get sharing unit
        MOV     R0, R0, LSL R6          ; and multiply sharing stuff up
  ]
        LDRB    R6, [LR,#DiscRecord_Log2SectorSize]
        ADD     R5, R5, R0, LSL R6

        LDRB    R0, [LR,#DiscRecord_Log2bpmb]   ;bytes per map bit
        MOV     R1, R5, LSR R0          ;split offset into multiples of bytes per map bit
        SUB     R5, R5, R1, LSL R0      ;and spare bytes
        BL      FindFragment            ;(R1,R2,R9,R10->R1,R9,R11,LR)

        RSB     R4, R5, LR, LSL R0      ;remaining bytes in fragment
        BL      MapPtrToDiscAdd         ;(R3,R10,R11->R0)
        Push    "R0"                    ;frag start disc address

        MOV     R11,R1
        BL      MapPtrToDiscAdd         ;(R3,R10,R11->R0)
        ADD     R2, R0, R5, LSR R6      ;offset disc address
        Pull    "LR"
 |
        LDRNEB  R1, [LR,#DiscRecord_Log2SectorSize]
        ADDNE   R5, R5, R0, LSL R1

        LDRB    R0, [LR,#DiscRecord_Log2bpmb]   ;bytes per map bit
        MOV     R1, R5, LSR R0          ;split offset into multiples of bytes per map bit
        SUB     R5, R5, R1, LSL R0      ;and spare bytes
        BL      FindFragment            ;(R1,R2,R9,R10->R1,R9,R11,LR)

        RSB     R4, R5, LR, LSL R0      ;remaining bytes in fragment
        BL      MapPtrToDiscAdd         ;(R3,R10,R11->R0)
        Push    "R0"                    ;frag start disc address

        MOV     R11,R1
        BL      MapPtrToDiscAdd         ;(R3,R10,R11->R0)
        ADD     R2, R0, R5              ;offset disc address
        Pull    "LR"

 ]

 [ DebugE
        Push    "R0"
        DREG    R2, "<-FindFileFragment(file add:",cc
        DREG    R4, ", len left:",cc
        DREG    R9, ", gap:",cc
        MOV     R0, LR
        DREG    R0, ", frag:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,R1,R3,R5,R6,R10,R11,PC"


; ===============
; DefFindFragment
; ===============

DefFindFragment
        MOV     R9, #-1         ;fall through to FindFragment

; ============
; FindFragment
; ============

;entry
; R1  offset from start of linked object in map bits
; R2  ind disc address of frag start, bits 0-7 clear
; R9  map ptr to gap, may shortcut search for predecessor gap
; R10 -> map start

;exit
; R1  map ptr to desired offset
; R9  predecessor gap for frag
; R11 map ptr to start of fragment containing offset
; LR  length left in fragment in map bits

FindFragment ROUT
        Push    "R0,R3-R8,LR"
 [ DebugE
        DREG    R1, "FindFragment(offset:",cc
        DREG    R2, ", file add:",cc
        DREG    R9, ", gap:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        MOV     R3, R9
        sbaddr  R0, FragCache
        LDMIA   R0, {R4-R9}
 [ DebugE
        DREG    R4, "old frag - file:",cc
        DREG    R5, ", map:",cc
        DREG    R6, ", disc:"
        DREG    R7, "last frag - file:",cc
        DREG    R8, ", map:",cc
        DREG    R9, ", disc:"
 ]
        CMPS    R1, R7          ;IF  file offset >= last file offset
        CMPHS   R2, R9          ;AND ind disc add = last ind disc add
        MOVEQ   R4, R7          ;start from last entry
        MOVEQ   R5, R8
 [ DebugE
        BNE     %FT01
        DLINE   "start from last frag"
01
 ]
        BEQ     %FT05
        STMIA   R0!,{R7-R9}     ;old last := last, for next time
        CMPS    R1, R4          ;IF  file offset >= old last file offset
        CMPHS   R2, R6          ;AND ind disc add = old last ind disc add
                        ;start from old last entry
 [ DebugE
        BNE     %FT01
        DLINE   "start from old frag"
01
 ]
05
        MOVNE   R4, #0  ;EQ <=> R4 is file ptr, R5 is map ptr to start from

        BIC     R6, R2, #DiscBits
        MOV     R6, R6, LSR #8  ;id
        LDREQB  R0, [R10,#ZoneHead+DiscRecord_Log2SectorSize]  ;find zone to start at
        MOVEQ   R0, R5, LSR R0
        MOVEQ   R0, R0, LSR #3
        MOVNE   R0, R2
        BLNE    IndDiscAddToZone;(R0,R10->R0)
10
        BL      InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        Push    "LR"
        MOVNE   R3, R8
        BNE     %FT20           ;if start from beginning of zone

        CMPS    R8, R3          ;if dummy link gap < pre gap < frag map ptr
        CMPLOS  R3, R5          ;start gap search from pre gap
        MOVHS   R3, R8

        MOV     R11,R3
15
 [ BigMaps
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
 |
        BL      RdLinkBits      ;(R10,R11->R8,Z)
 ]
        ADD     R11,R11,R8
        CMPS    R11,R3          ;WHILE more gaps
        CMPHIS  R5, R11         ;AND fragment after gap
        MOVHI   R3, R11         ;move onto next gap
        BHI     %BT15

        MOV     R9, R11
        MOV     R11,R5

20
        Pull    "R5"
25
 [ BigMaps
        TEQS    R11, R9         ; if gap
        BNE     %FT27

 ; gap
        BL      FreeRdLenLinkBits ; read free link
        MOV     r3,r9           ;  and just update gap before frag
        ADD     r9,r9,r8        ;  and gap after frag
        B       %FT30           ;
27
 ; not gap
        BL      FragRdLenLinkBits ; get the length
 |
        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
        TEQS    R11,R9          ;if gap
        MOVEQ   R3, R9          ; just update gap before frag
        ADDEQ   R9, R9, R8      ; and gap after frag
        BEQ     %FT30
 ]
        TEQS    R8, R6
        BEQ     %FT40           ;if part of this file

30
        ADD     R11,R11,R7
        CMPS    R11,R5
        BLO     %BT25           ;loop while more objects in zone

        ADD     R0, R0, #1      ;otherwise move onto next zone
 [ BigMaps
        LDRB    LR, [R10,#ZoneHead+DiscRecord_NZones]
        LDRB    R11, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     LR, LR, R11, LSL #8     ; R11 returned by InitZoneObj so is free for use here
 |
        LDRB    LR, [R10,#ZoneHead+DiscRecord_NZones]
 ]
        TEQS    R0, LR
        MOVEQ   R0, #0
        TEQS    PC, #0          ;set NE to start from beginning
        B       %BT10

40
        ADD     LR, R4, R7      ;file ptr of end of this fragment
        SUBS    LR, LR, R1      ;map bits after offset in this fragment
        ADDLS   R4, R4, R7      ;add frag len to file offset
        BLS     %BT30
                        ;HI <=> found fragment
        sbaddr  R7, LastFilePtr
        ASSERT  LastMapPtr = LastFilePtr + 4
        ASSERT  LastIndDiscAdd = LastMapPtr + 4
        MOV     R5, R11
        MOV     R6, R2
        STMIA   R7, {R4-R6}     ;must be atomic
        SUB     R1, R1, R4      ;convert offset in file
        ADD     R1, R1, R11     ;to offset in map
        MOV     R9, R3
 [ DebugE
        Push    "R0"
        DREG    R1, "<-FindFileFragment(offset:",cc
        DREG    R9, ", gap:",cc
        DREG    R11, ", frag:",cc
        MOV     R0, LR
        DREG    R0, ", len:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,R3-R8,PC"

; ==========
; LoadNewMap
; ==========

;assumes BadFsMapBit not set

;entry
; R5 -> disc rec
; R6 -> drive rec
; R8 -> map buffer

;exit R0,V

LoadNewMap ROUT
        Push    "R0-R2,R4,R7-R10,LR"
 [ DebugE
        DREG    R5, "LoadNewMap(disc rec:",cc
        DREG    R6, ", drive rec:",cc
        DREG    R8, ", map:",cc
        DLINE   ")"
 ]
 [ BigMaps
        LDRB    R9, [R5, #DiscRecord_NZones]
        LDRB    R7, [R5, #DiscRecord_BigMap_NZones2]
        ADD     R9, R9, R7, LSL #8
 |
        LDRB    R9, [R5,#DiscRecord_NZones]
 ]
        LDRB    R7, [R5,#DiscRecord_Log2SectorSize]
        ADD     R10,R8, R9, LSL R7      ;-> zone flags
05
        MOV     R1, #0                  ;loop to load invalid zones
10
        LDRB    LR, [R10,R1]
        TSTS    LR, #ZoneValid
        ADD     R2, R1, #1
        BNE     %FT30
15
        CMPS    R2, R9
        BHS     %FT20
        LDRB    LR, [R10,R2]
        TSTS    LR, #ZoneValid
        ADDEQ   R2, R2, #1
        BEQ     %BT15
20

        SUB     R4, R2, R1              ;zones to read in
        Push    "R1-R4"
        MOV     R4, R4, LSL R7          ;bytes to read in
        BL      MapDiscAdd              ;(R5,R7,R9->R2)
 [ BigDisc
        ADD     R2, R2, R1
 |
        ADD     R2, R2, R1, LSL R7
 ]
        LDRB    LR, [R5,#DiscFlags]     ;using alternate copy of map ?
        TSTS    LR, #AltMapFlag
 [ BigDisc
        ADDNE   R2, R2, R9
        ADD     R3, R8, R1, LSL R7
 |
        ADDNE   R2, R2, R9, LSL R7
        ADD     R3, R8, R1, LSL R7
 ]
        MOV     R1, #DiscOp_ReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        BL      RetryDiscOp             ;(R1-R4->R0,R2-R4,V)
        Pull    "R1-R4"
        BVS     %FT45

        ADD     R0, R8, R1, LSL R7
        MOV     R1, #1
        MOV     R1, R1, LSL R7
25
        BL      NewCheck                ;(R0,R1->LR,Z)
        BNE     %FT40
        ADD     R0, R0, R1
        SUBS    R4, R4, #1
        BNE     %BT25

30
        MOV     R1, R2
        CMPS    R1, R9
        BLO     %BT10

; HAVING GOT ALL THE ZONES INTO RAM NOW CHECK CHECK BYTES

        ADD     R0, R8, #CrossCheck
        MOV     R1, #1          ;zone length
        MOV     R1, R1, LSL R7
        MOV     R2, #0          ;init cross check
        MOV     R4, R9          ;zone ctr
35
        LDRB    LR, [R0],R1
        EOR     R2, R2, LR
        SUBS    R4, R4, #1
        BGT     %BT35           ;loop while more zones
        CMPS    R2, #&FF
        MOVEQ   R1, #ZoneValid
        BEQ     %FT50
 [ DebugE
        DLINE   "bad cross check"
 ]
40
        MOV     R0, #BadFsMapErr
45
        MOV     R1, #0
50
        SUB     R2, R9, #1
55                              ;loop to set or clear zone valid flags
        LDRB    LR, [R10,R2]
        BIC     LR, LR, #ZoneValid
        ORR     LR, LR, R1
        STRB    LR, [R10,R2]
        SUBS    R2, R2, #1
        BPL     %BT55
        CMPS    R1, #ZoneValid
        BEQ     %FT95                   ;V=0
        LDRB    LR, [R5,#DiscFlags]     ;if failed and not using alternate copy
        TSTS    LR, #AltMapFlag         ;of map then start using it
        ORREQ   LR, LR, #AltMapFlag
        STREQB  LR, [R5,#DiscFlags]
        BEQ     %BT05
 [ DynamicMaps
        LDR     LR, [R6, #DrvsFsMapFlags]
        ORR     LR, LR, #BadFs
        STR     LR, [R6, #DrvsFsMapFlags]
 |
        ORR     R8, R8, #BadFs          ;if both copies bad give up
        STR     R8, [R6,#DrvsFsMap]
 ]
        BL      SetV
95
 [ DebugE
        DLINE   "<-LoadNewMap(",cc
        BVC     %FT01
        DREG    R0, ""
01
        DLINE   ")"
 ]
        STRVS   R0, [SP]
        Pull    "R0-R2,R4,R7-R10,PC"

; ===========================
; MeasureFileAllocSize_GotMap
; ===========================
MeasureFileAllocSize_GotMap ROUT
        Push    "r1,r2,r3,r5,r6,r7,r8,r9,r10,r11,lr"

        MVN     r2, #0          ; map is already loaded
        B       %FT02

; ====================
; MeasureFileAllocSize
; ====================

; entry
; r1 = FcbIndDiscAdd
; r3 = dir indirect disc address
; r4 -> dir entry

; exit
; r0 = alloc size of file in bytes

MeasureFileAllocSize
        Push    "r1,r2,r3,r5,r6,r7,r8,r9,r10,r11,lr"

        MOV     r2, #0          ; we aint got no map
02
        BL      TestMap         ;(R3->Z)
        TSTEQ   r1, #&ff
        BEQ     %FT05           ; branch if new map and not shared

        ; Shared (or old map). Size allocated = sectors occupied
        BL      ReadLen         ;(R3,R4->LR)
        MOV     r0, lr
 [ DebugBs
        DREG    r0, "Shared/Old map unrounded size = "
 ]
 [ BigShare
        BL      RoundUpShare    ;(R0,R3->R0) always < 2G
 |
        BL      RoundUpSector   ;(R0,R3->R0) always < 2G
 ]
        B       %FT95

05
        ; Unshared. Size allocated = fragments occupied
        MOV     r3, r1

        ; r1=Link
        BIC     r1, r1, #DiscBits       ; remove disc number
        MOV     r1, r1, LSR #8          ; remove shared offset

        ; unallocated/bad blocks mean size=0
        CMP     r1, #1
        MOVLS   lr, #0
        BLS     %FT95

        TEQ     r2, #0
        BNE     %FT08           ; map in hand

        BL      BeforeReadFsMap ;(R3->R0,V)
        BVS     %FT95
08
        BL      InitReadNewFs   ;(R3->R10,R11,LR)

        MOV     r0, #0          ; zone
        MOV     r6, #0          ; accumulated file size
        B       %FT60
10
        BL      InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        MOV     R5, LR          ; zone end
15
 [ BigMaps
        TEQ     R11, R9
        BNE     %FT16           ; gap?

        BL      FreeRdLenLinkBits ; gap
        ADD     r9,r11,r8
        B       %ft20

16                              ; not gap
        BL      FragRdLenLinkBits       ; just read the object

 |
        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
        TEQ     R11, R9
        ADDEQ   R9, R11, R8     ; it's a free block
        BEQ     %FT20
 ]
        TEQ     R8, R1          ; One of ours?
        ADDEQ   R6, R6, R7      ; Yes, accumulate the length
20
        ADD     R11, R11, R7    ; next fragment
        CMP     R11, R5         ; end of zone?
        BLO     %BT15

        ADD     r0, r0, #1      ; next zone
60
 [ BigMaps
        LDRB    lr, [R10, #ZoneHead+DiscRecord_NZones]
        LDRB    R11, [R10, #ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     LR, LR, R11, LSL #8     ; R11 returned by InitZoneObj so free for use here
 |
        LDRB    lr, [R10, #ZoneHead+DiscRecord_NZones]
 ]
        CMP     r0, lr
        BLO     %BT10

 [ DebugBs
        DREG    r6, "UnShared bit size="
 ]
        LDRB    lr, [r10, #ZoneHead+DiscRecord_Log2bpmb]
      [ BigFiles
        MOVS    r0, r6, LSL lr          ; convert to bytes in r0
        MOVCS   r0, #RoundedTo4G
      |
        MOV     r0, r6, ASL lr          ; convert to bytes in r0
      ]
        TEQ     r2, #0                  ; was the map already loaded?
        BLEQ    UnlockMap               ; no, so unlock it
95
 [ DebugBs
        BVS     %FT01
        DREG    r0, "Open allocated size="
01
 ]
        Pull    "r1,r2,r3,r5,r6,r7,r8,r9,r10,r11,pc"

; ==========
; MapDiscAdd
; ==========

;entry
; R5  -> disc rec
; R7  log2 sector size
; R9  zones

;exit R2 map disc address

MapDiscAdd ROUT
 [ BigDisc
        Push    "R0,R1,LR"
 |
        Push    "R0,LR"
 ]
        MOV     R0, #8                  ; bits in a byte
        MOV     R0, R0, LSL R7          ; bits in a zone
        LDR     LR, [R5,#DiscRecord_ZoneSpare-2]
        SUB     R0, R0, LR, LSR #16     ; bits used in a zone
        MOVS    LR, R9, LSR #1          ; zone containing map
        MULS    R2, R0, LR
        SUBNE   R2, R2, #Zone0Bits      ; adjust for zone 0 disc record
        LDRB    R0, [R5,#DiscRecord_Log2bpmb]
        LDR     LR, [R5,#DiscRecord_Root]
        AND     LR, LR,#DiscBits
 [ BigDisc
        SUBS    R0,R0,R7                ; get required shift
        RSBMI   R0,R0,#0                ; if negative then reverse.
        ORRMI   R2,LR,R2,LSR R0         ;
        ORRPL   R2,LR,R2,LSL R0         ;
 |
        ORR     R2, LR, R2, LSL R0      ; disc address of map start
 ]
 [ DebugE
        DREG    R2, "Map disc add:"
 ]
 [ BigDisc
        Pull    "R0,R1,PC"
 |
        Pull    "R0,PC"
 ]

; ===================
; InvalidateFragCache
; ===================

InvalidateFragCache
        Push    "LR"
 [ DebugE
        DLINE   "InvalidateFragCache()"
 ]
        MOV     LR, #-1
        STR     LR, LastIndDiscAdd
        STR     LR, OldLastIndDiscAdd
        Pull    "PC"

; ========
; NewCheck
; ========

;entry
; R0 -> start
; R1 length ( must be multiple of 32 )

;exit
; LR check byte, Z=1 <=> good

NewCheck ROUT
        Push    "R1-R9,LR"
 [ DebugE
        DREG    R0, "NewCheck(start:",cc
        DREG    R1, ", len:",cc
        DLINE   ")"
 ]
        MOV     LR, #0
        ADDS    R1, R1, R0              ;C=0
05                              ;loop optimised as winnies may have many zones
        LDMDB   R1!,{R2-R9}
        ADCS    LR, LR, R9
        ADCS    LR, LR, R8
        ADCS    LR, LR, R7
        ADCS    LR, LR, R6
        ADCS    LR, LR, R5
        ADCS    LR, LR, R4
        ADCS    LR, LR, R3
        ADCS    LR, LR, R2
        TEQS    R1, R0          ;preserves C
        BNE     %BT05
        AND     R2, R2, #&FF    ;ignore old sum
        SUB     LR, LR, R2
        EOR     LR, LR, LR, LSR #16
        EOR     LR, LR, LR, LSR #8
        AND     LR, LR, #&FF
        CMPS    R2, LR
 [ DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0,"<-NewCheck(checkbyte:", cc
        BEQ     %FT01
        DLINE   ",NE (bad)", cc
        B       %FT02
01
        DLINE   ",EQ (good)", cc
02
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R1-R9,PC"


; ===========
; SetNewCheck
; ===========

;entry
; R0 -> start
; R1 length

SetNewCheck
        Push    "LR"
 [ DebugE
        DREG    R0, "SetNewCheck(start:",cc
        DREG    R1, ", length:",cc
        DLINE   ")"
 ]
        BL      NewCheck        ;(R0,R1->LR,Z,V)
        STRB    LR, [R0]
        Pull    "PC"


; ============
; RoundUpAlloc
; ============

; round up file length to multiple of allocation size

; entry:
;  R0 file length
;  R3 top 3 bits disc id

; exit:
;  R0 rounded file length

RoundUpAlloc ROUT
 [ Debug5 :LOR: DebugE
        DREG    R0, "RoundUpAlloc(value:",cc
        DREG    R3, ", disc:",cc
        DLINE   ")"
 ]
        Push    "R1,R4,LR"
        SavePSR R4
        BL      ReadAllocSize           ;(R3->LR)
RoundCommon
        SUB     R1, LR, #1
      [ BigFiles
        ADDS    LR, R0, R1
        BIC     R0, LR, R1
        MOVCS   R0, #RoundedTo4G        ;Carry out, so return special marker
      |
        TSTS    R0, R1
        BICNE   R0, R0, R1
        ADDNE   R0, R0, LR
      ]
 [ Debug5 :LOR: DebugE
      [ BigFiles
        BCC     %FT01
        DLINE   "<-RoundCommon(value:4G",cc
        B       %FT02
      ]
01
        DREG    R0, "<-RoundCommon(value:",cc
02
        DLINE   ")"
 ]
        RestPSR R4,,f
        Pull    "R1,R4,PC"


; =============
; RoundUpSector
; =============

; round up file length to multiple of sector size

; entry:
;  R0 file length
;  R3 top 3 bits disc id

; exit:
;  R0 rounded file length

RoundUpSector ROUT
 [ Debug5 :LOR: DebugE
        DREG    R0, "RoundUpSector(value:",cc
        DREG    R3, ", disc:",cc
        DLINE   ")"
 ]
        Push    "R1,R4,LR"
        SavePSR R4

        MOV     LR, R3, LSR #(32-3)
        DiscRecPtr  LR, LR
        LDRB    LR, [LR,#DiscRecord_Log2SectorSize]

        MOV     R1, #1
        MOV     LR, R1, LSL LR
        B       RoundCommon


 [ BigShare

; =============
; RoundUpShare
; =============

; round up file length to multiple of sharing size

; entry:
;  R0 file length
;  R3 top 3 bits disc id

; exit:
;  R0 rounded file length

RoundUpShare ROUT
 [ Debug5 :LOR: DebugE
        DREG    R0, "RoundUpShare(value:",cc
        DREG    R3, ", disc:",cc
        DLINE   ")"
 ]
        Push    "R1,R4,LR"
        SavePSR R4

        MOV     LR, R3, LSR #(32-3)
        DiscRecPtr  LR, LR
        LDRB    R1, [LR,#DiscRecord_Log2SectorSize]
        LDRB    LR, [LR, #DiscRecord_BigMap_ShareSize]
        ADD     LR, R1, LR

        MOV     R1, #1
        MOV     LR, R1, LSL LR
        B       RoundCommon

 ]

; =============
; ReadAllocSize
; =============

; entry R3 top 3 bits disc num
; exit LR allocation size for this disc always a power of 2

ReadAllocSize ROUT
        Push    "R0,R1,LR"
 [ Debug5 :LOR: DebugE
        DREG    R3, "ReadAllocSize(disc:",cc
        DLINE   ")"
 ]
        BL      DiscAddToRec            ;(R3->LR)
        LDRB    R0, [LR,#DiscRecord_Log2SectorSize]    ;max of sector size and map bit size
        LDRB    R1, [LR,#DiscRecord_Log2bpmb]
        CMPS    R1, R0
        MOVHI   R0, R1
        MOV     LR, #1
        MOV     LR, LR, LSL R0
 [ Debug5 :LOR: DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0, "<-ReadAllocSize(alloc size:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,R1,PC"

; =============
; ReadSectorSize
; =============

; entry R3 top 3 bits disc num
; exit LR log2 sector size

ReadSectorSize ROUT
        Push    "R0,LR"
 [ Debug5 :LOR: DebugE
        DREG    R3, "ReadSectorSize(disc:",cc
        DLINE   ")"
 ]
        BL      DiscAddToRec            ;(R3->LR, flags preserved)
        LDRB    LR, [LR,#DiscRecord_Log2SectorSize]    ;max of sector size and map bit size
 [ Debug5 :LOR: DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0, "<-ReadSectorSize(log2 sector size:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,PC"                 ; flags preserved

; ===============
; MapPtrToDiscAdd
; ===============

;entry
; R3  top 3 bits disc
; R10 -> map start
; R11 map ptr

;exit
; R0 disc add

MapPtrToDiscAdd ROUT
 [ BigDisc
        Push    "R10,LR"
 |
        Push    "LR"
 ]
 [ DebugE
        DREG    R3, "MapPtrToDiscAdd(disc:",cc
        DREG    R10, ", map:",cc
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        ADD     LR, LR, #3      ;log2 total bits in zone
        MOV     R0, R11,LSR LR  ;zone
        LDR     LR, [R10,#ZoneHead+DiscRecord_ZoneSpare-2]
        MOV     LR, LR, LSR #16
        MUL     R0, LR, R0
        SUB     R0, R11,R0
        SUB     R0, R0, #Zone0Bits+(ZoneHead*8)
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]

; when we get here, we have the disc address in units map bits.  Just shift
; left by log2bpmb, and if bigdisc also adjust for the sector size

 [ BigDisc
        LDRB    R10,[R10,#ZoneHead+DiscRecord_Log2SectorSize]   ; log2 sector size
        SUBS    LR,LR,R10               ; get overall shift
        RSBMI   LR,LR,#0                ; if -ve shift then convert to +ve shift in other
        MOVMI   R0,R0,LSR LR            ; ...direction
        MOVPL   R0,R0,LSL LR            ; ...otherwise just do it
 |
        MOV     R0, R0, LSL LR          ; easy in comparison!
 ]
        AND     LR, R3, #DiscBits
        ORR     R0, R0, LR

 [ DebugE
        DREG    R0, "<-MapPtrToDiscAdd(disc add:",cc
        DLINE   ")"
 ]

 [ BigDisc
        Pull    "R10,PC"
 |
        Pull    "PC"
 ]


 [ BigDisc

; =================
; MapPtrToZoneStart
; =================

; Purpose:
;
; This function is provided in order to support DoCompMoves
; with BigDisc.

;entry
; R3  top 3 bits disc
; R10 -> map start
; R11 map ptr

;exit
; R0 zone base disc address (sector address)

MapPtrToZoneBase ROUT
        Push    "R10,R11,LR"
 [ DebugE
        DREG    R3, "MapPtrToDiscAdd(disc:",cc
        DREG    R10, ", map:",cc
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        ADD     LR, LR, #3      ;log2 total bits in zone
        MOV     R0, R11,LSR LR  ;zone
        MOV     R11, R0, LSL LR ;map ptr to zone start
        LDR     LR, [R10,#ZoneHead+DiscRecord_ZoneSpare-2]
        MOV     LR, LR, LSR #16
        MUL     R0, LR, R0
        SUB     R0, R11,R0
        SUBS    R0, R0, #Zone0Bits+(ZoneHead*8)
        MOVMI   R0, #0          ;if -ve disc address then must be on first zone
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]

; when we get here, we have the disc address in units map bits.  Just shift
; left by log2bpmb, and if bigdisc also adjust for the sector size

        LDRB    R10,[R10,#ZoneHead+DiscRecord_Log2SectorSize]   ; log2 sector size
        SUBS    LR,LR,R10               ; get overall shift
        RSBMI   LR,LR,#0                ; if -ve shift then convert to +ve shift in other
        MOVMI   R0,R0,LSR LR            ; ...direction
        MOVPL   R0,R0,LSL LR            ; ...otherwise just do it

        AND     LR, R3, #DiscBits
        ORR     R0, R0, LR

 [ DebugE
        DREG    R0, "<-MapPtrToDiscAdd(disc add:",cc
        DLINE   ")"
 ]

        Pull    "R10,R11,PC"

 ]

; ===============
; DiscAddToMapPtr
; ===============

;entry
; R0 disc address
; R10 ->map start
;exit
; R11 offset in map
; LR  zone number

DiscAddToMapPtr ROUT
        Push    "R0,R1,R3,LR"
 [ DebugE
        DREG    R0, "DiscAddToMapPtr(disc add:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        MOV     R3, R0
        BIC     R0, R0, #DiscBits

; could optimise this a bit later...

 [ BigDisc
        LDRB    LR,[R10,#ZoneHead+DiscRecord_Log2SectorSize]    ; get lg2 sector size
        LDRB    R1, [R10,#ZoneHead+DiscRecord_Log2bpmb] ; scale from sectors to map bits...
        SUBS    R1,R1,LR                        ; ...taking account of shift direction
        RSBMI   R1,R1,#0                        ;
        MOVPL   R0,R0,LSR R1                    ;
        MOVMI   R0,R0,LSL R1                    ;

 |
        LDRB    R1, [R10,#ZoneHead+DiscRecord_Log2bpmb]     ;scale from bytes to map bits
        MOV     R0, R0, LSR R1
 ]

        ADD     R0, R0, #Zone0Bits              ;adjust for zone 0
        LDRB    R1, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R3, #8
        MOV     R1, R3, LSL R1                  ;total bits in a zone map
        LDR     R3, [R10,#ZoneHead+DiscRecord_ZoneSpare-2]
        MOV     R3, R3, LSR #16
        SUB     R1, R1, R3                      ;map bits actually used in a zone map
        MOV     R11,R0
        BL      Divide                          ;(R0,R1->R0,R1)
        MOV     LR, R0                          ;zone
        MLA     R11,R3, R0, R11                 ;add zone*spare, for non map bits
        ADD     R11,R11,#ZoneHead*8
 [ DebugE
        Push    "R0"
        DREG    R11, "<-DiscAddToMapPtr(map ptr:",cc
        MOV     R0, LR
        DREG    R0, "zone:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,R1,R3,PC"

; ===================
; ByteDiscAddToMapPtr
; ===================

;entry
; R0 disc address
; R10 ->map start
;exit
; R11 offset in map
; LR  zone number

ByteDiscAddToMapPtr ROUT
        Push    "R0,R1,R3,LR"
 [ DebugE
        DREG    R0, "ByteDiscAddToMapPtr(disc add:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        MOV     R3, R0
        BIC     R0, R0, #DiscBits

        LDRB    R1, [R10,#ZoneHead+DiscRecord_Log2bpmb]     ;scale from bytes to map bits
        MOV     R0, R0, LSR R1

        ADD     R0, R0, #Zone0Bits              ;adjust for zone 0
        LDRB    R1, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R3, #8
        MOV     R1, R3, LSL R1                  ;total bits in a zone map
        LDR     R3, [R10,#ZoneHead+DiscRecord_ZoneSpare-2]
        MOV     R3, R3, LSR #16
        SUB     R1, R1, R3                      ;map bits actually used in a zone map
        MOV     R11,R0
        BL      Divide                          ;(R0,R1->R0,R1)
        MOV     LR, R0                          ;zone
        MLA     R11,R3, R0, R11                 ;add zone*spare, for non map bits
        ADD     R11,R11,#ZoneHead*8
 [ DebugE
        Push    "R0"
        DREG    R11, "<-ByteDiscAddToMapPtr(map ptr:",cc
        MOV     R0, LR
        DREG    R0, "zone:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,R1,R3,PC"

; =================
; CritInitReadNewFs
; =================

; exit
;  R10 -> map start
;  R11    ready for NextFree

CritInitReadNewFs ROUT
        LDR     R10,CritDrvRec
 [ DynamicMaps
        LDR     R10,[R10,#DrvsFsMapAddr]
 |
        LDR     R10,[R10,#DrvsFsMap]
        BIC     R10,R10,#HiFsBits
 ]
        MOV     R11,#FreeLink*8
 [ DebugE
        DREG    R10, "CritInitReadNewFs(map:",cc
        DREG    R11, ",freelink:",cc
        DLINE   ")"
 ]
        MOV     PC,LR                   ; Flags preserved


; =============
; InitReadNewFs
; =============

;entry
; R3  top 3 bits disc

;exit
; R10 -> map start
; R11    ready for NextFree
; LR  -> disc rec

InitReadNewFs ROUT
        Push    "LR"
 [ DebugE
        DREG    R3, "InitReadNewFs(disc:",cc
        DLINE   ")"
 ]
        MOV     LR, R3, LSR #(32-3)       ;disc
        DiscRecPtr  LR,LR
        LDRB    R10,[LR,#DiscsDrv]
        DrvRecPtr  R10,R10
 [ DynamicMaps
        LDR     R10,[R10,#DrvsFsMapAddr]
 |
        LDR     R10,[R10,#DrvsFsMap]
        BIC     R10,R10,#HiFsBits
 ]
        MOV     R11,#FreeLink*8
 [ DebugE
        Push    "R0"
        DREG    R10, "<-InitReadNewFs(map:",cc
        DREG    R11, ", freelink:",cc
        MOV     R0, LR
        DREG    R0, ", disc rec:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "PC"


; ==========
; InitReadFs
; ==========

;entry R3 top 3 bits disc

;exit R9-R11 ready for call of NextFs

InitReadFs ROUT
        Push    "LR"
        BL      TestMap         ;(R3->Z)
        BNE     %FT50
        BL      InitReadNewFs   ;(R3->R10,R11,LR)
        Pull    "PC"

50
        BL      InitReadOldFs   ;(R3->R9-R11)
        Pull    "PC"

; ======
; NextFs
; ======

;entry
; R3 top 3 bits disc
; R9-R11 map position

;exit
; R7 gap length
; R8 gap ind disc add
; R9-R11 map position
; Z=1 if done

NextFs  ROUT
        Push    "R0,LR"
        BL      TestMap         ;(R3->Z)
        BNE     %FT50
        BL      NextFree        ;(R10,R11->R9,R11,Z,C)
        Pull    "R0,PC",EQ
 [ BigMaps
        BL      FreeRdLenBits   ;(R10,R11->R7)
 |
        BL      RdLenBits       ;(R10,R11->R7)
 ]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        MOV     R7, R7, LSL LR  ;convert length from map bits to bytes
        BL      MapPtrToDiscAdd ;(R3,R10,R11->R0)
        MOV     R8, R0
        CMP     PC, #0          ;Z=0
        Pull    "R0,PC"

50
        BL      NextOldFs   ;(R3,R10,R11->R7,R8,R10,R11)
        Pull    "R0,PC"


; ===========
; InitZoneObj
; ===========

;entry
; R0  zone
; R10 -> map start

;exit
; R8  map bit of free link
; R9  map bit of first space (if none offset of free link)
; R11 map bit of first map entry
; LR  map bit of start of junk at end of this zone

InitZoneObj ROUT
        Push    "LR"
        BL      InitZoneFree    ;(R0,R10->R11)
        Push    "R7,R11"
        SavePSR R7
 [ BigMaps
        BL      FreeRdLinkBits  ;(R10,R11->R8)
 |
        BL      RdLinkBits    ;(R10,R11->R8)
 ]
        ADD     R9, R11,R8
        ADD     R11, R11, #(ZoneHead - FreeLink)*8
        LDRB    R8, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     LR, #8
        ADD     LR, R11, LR, LSL R8
        ASSERT  DiscRecord_ZoneSpare :MOD: 4 = 2
        LDR     R8, [R10, #ZoneHead + DiscRecord_ZoneSpare-2]
        SUB     LR, LR, R8, LSR #16
        TEQS    R0, #0
        ADDEQ   R11,R11,#Zone0Bits
; [ DebugE
;        Push    "R0"
;        DREG    R0, "<-InitZoneObj(zone:",cc
;        DREG    R8, ", freelink:",cc
;        DREG    R9, ", first space:",cc
;        DREG    R10, ", map:",cc
;        DREG    R11, ", first entry:",cc
;        MOV     R0, LR
;        DREG    R0, ", limit:",cc
;        DLINE   ")"
;        Pull    "R0"
; ]
        RestPSR R7,,f
        Pull    "R7,R8,PC"


; ============
; InitZoneFree
; ============

; entry:
;       R0 = zone
;       R10 -> map start
;
; exit:
;       R11 set for reading free spaces from zone R0 in map starting at R10

InitZoneFree ROUT
        LDRB    R11,[R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R11,R0, LSL R11
        MOV     R11,R11,LSL #3
        ADD     R11,R11,#FreeLink*8
; [ DebugE
;        DREG    R0, "<-InitZoneFree(zone:",cc
;        DREG    R10, ", map:",cc
;        DREG    R11, ", freelink:",cc
;        DLINE   ")"
; ]
        MOV     PC,LR           ; flags preserved


; ========
; NextFree
; ========

;entry
; R10 -> map start
; R11 map ptr to space

;exit
; Z set <=> exhausted
; C set <=> exhausted or started new zone
; R9  map ptr to predecessor of next space
; R11 map ptr to next space

NextFree ROUT
 [ BigMaps
        Push    "R0,R8,LR"
 |
        Push    "R8,LR"
 ]
 [ DebugE
        DREG    R10, "NextFree(map:",cc
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
 [ BigMaps
        BL      FreeRdLinkBits          ;(R10,R11->R8,Z)
 |
        BL      RdLinkBits              ;(R10,R11->R8,Z)
 ]
        BEQ     %FT10                   ;zone done
        MOV     R9, R11
        ADDS    R11,R11,R8              ;Z=0, C=0
05
 [ DebugE
        DREG    R9, "<-NextFree(prev:",cc
        DREG    R11, ", this:",cc
        BCC     %FT01
        DLINE   ", next zone",cc
01
        BNE     %FT02
        DLINE   ", map end",cc
02
        DLINE   ")"
 ]
 [ BigMaps
        Pull    "R0,R8,PC"
 |
        Pull    "R8,PC"
 ]

10
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        ADD     LR, LR, #3
        MOV     R9, R11,LSR LR          ;zone
        ADD     R9, R9, #1
 [ BigMaps
        LDRB    R8, [R10,#ZoneHead+DiscRecord_NZones]
        LDRB    R0, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     R8, R8, R0, LSL #8
 |
        LDRB    R8, [R10,#ZoneHead+DiscRecord_NZones]
 ]
        CMPS    R8, R9
        BEQ     %BT05                   ;exhausted Z=1, C=1
        MOV     R11,R9, LSL LR
        ADD     R11,R11,#FreeLink*8
 [ BigMaps
        BL      FreeRdLinkBits          ;(R10,R11->R8,Z)
 |
        BL      RdLinkBits              ;(R10,R11->R8,Z)
 ]
        BEQ     %BT10
        MOV     R9, R11
        ADD     R11,R11,R8
        CMPS    PC, #0                  ;Z=0, C=1
        B       %BT05



; ==============
; NextFree_Quick
; ==============

;entry
; R10 -> map start
; R11 map ptr to space

;exit
; C set <=> exhausted or started new zone
; R9  map ptr to predecessor of next space
; R11 map ptr to next space, unless started new zone or exhausted

NextFree_Quick ROUT
 [ BigMaps
        Push    "R0,R8,LR"
 |
        Push    "R8,LR"
 ]
 [ DebugE
        DREG    R10, "NextFree(map:",cc
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
 [ BigMaps
        BL      FreeRdLinkBits              ;(R10,R11->R8,Z)
 |
        BL      RdLinkBits              ;(R10,R11->R8,Z)
 ]
        BEQ     %FT10                   ;zone done
        MOV     R9, R11
        ADDS    R11,R11,R8              ;Z=0, C=0
05
 [ DebugE
        DREG    R9, "<-NextFree(prev:",cc
        DREG    R11, ", this:",cc
        BCC     %FT01
        DLINE   ", next zone",cc
01
        BNE     %FT02
        DLINE   ", map end",cc
02
        DLINE   ")"
 ]
 [ BigMaps
        Pull    "R0,R8,PC"
 |
        Pull    "R8,PC"
 ]

10
        CMPS    PC, #0                  ;Z=0, C=1
        B        %BT05


; =============
; RdLenLinkBits
; =============

;entry
; R10 -> new map start
; R11 bit ptr to map obj
;exit
; R7 len bits
; R8 link bits

 [ BigMaps
FragRdLenLinkBits ROUT
 |
RdLenLinkBits ROUT
 ]
        Push    "R0-R3,LR"
        SavePSR R3
 [ DebugEx
 [ BigMaps
        DREG    R10, "FragRdLenLinkBits(map:",cc
 |
        DREG    R10, "RdLenLinkBits(map:",cc
 ]
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        LDRB    R7, [R10,#ZoneHead+DiscRecord_IdLen]
 [ BigMaps
10
 ]
        ADD     R0, R10,R11,LSR #3
      [ SupportARMv6
        BIC     R0, R0, #3      ;->word containing length start
      ]
        LDMIA   R0!,{R1,R2}
        ANDS    LR, R11, #31
        MOVNE   R1, R1, LSR LR
        RSB     LR, LR, #32
        ORRNE   R1, R1, R2, LSL LR
        MOV     R8, R1, LSR R7
        SUB     R8, R1, R8, LSL R7
        MOV     R7, #1
        SUBS    R1, R1, R8
        BNE     %FT05

        ADD     R7, R7, LR
        SUBS    R1, R2, R8, LSR LR
        BNE     %FT05
00
        LDMIA   R0!,{R1,R2}
        ADD     R7, R7, #32*2
        ORRS    LR, R1, R2
        BEQ     %BT00
        TEQS    R1, #0
        SUBNE   R7, R7, #32
        MOVEQ   R1, R2
        B       %FT05

 [ BigMaps
; =============
; FreeRdLenLinkBits
; =============

;entry
; R10 -> new map start
; R11 bit ptr to map obj (must be a free space)
;exit
; R7 len bits
; R8 link bits

FreeRdLenLinkBits

        Push    "R0-R3,LR"
        SavePSR R3
 [ DebugEx
 [ BigMaps
        DREG    R10, "FreeRdLenLinkBits(map:",cc
 |
        DREG    R10, "RdLenLinkBits(map:",cc
 ]
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        LDRB    R7, [R10,#ZoneHead+DiscRecord_IdLen]
        CMP     r7, #MaxFreeLinkBits
        MOVHI   r7, #MaxFreeLinkBits
        B       %BT10           ; jump to common code
 ]

 [ BigMaps
; =============
; FreeRdLenBits
; =============

;entry
; R10 -> new map start
; R11 bit ptr to map obj (must be free space)
;exit
; R7 len bits

FreeRdLenBits
        Push    "R0-R3,LR"
        SavePSR R3
 [ DebugEx
 [ BigMaps
        DREG    R10, "FreeRdLenBits(map:",cc
 |
        DREG    R10, "RdLenBits(map:",cc
 ]
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
02
        LDRB    R7, [R10,#ZoneHead+DiscRecord_IdLen]
        CMP     r7, #MaxFreeLinkBits
        MOVHI   r7, #MaxFreeLinkBits
        B       %FT03
 ]

; =========
; RdLenBits
; =========

;entry
; R10 -> new map start
; R11 bit ptr to map obj
;exit
; R7 len bits

 [ BigMaps
FragRdLenBits
 |
RdLenBits
 ]
        Push    "R0-R3,LR"
        SavePSR R3
 [ DebugEx
 [ BigMaps
        DREG    R10, "FragRdLenBits(map:",cc
 |
        DREG    R10, "RdLenBits(map:",cc
 ]
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
02
        LDRB    R7, [R10,#ZoneHead+DiscRecord_IdLen]
 [ BigMaps
03
 ]
        ADD     R0, R11, R7
        ANDS    LR, R0, #31
        ADD     R7, R7, #1
        ADD     R0, R10,R0, LSR #3
      [ SupportARMv6
        BIC     R0, R0, #3      ;->word containing length start
      ]
        LDMIA   R0!,{R1,R2}
        MOVNE   R1, R1, LSR LR
        RSB     LR, LR, #32
        ORRS    R1, R1, R2, LSL LR
        BEQ     %FT10
05
        ; R1 is known to be non-zero
        ; Increment R7 by the number of trailing 0 bits in R1
      [ NoARMv5
        MOVS    LR, R1, LSL #16
        ADDEQ   R7, R7, #16
        MOVEQ   R1, R1, LSR #16

        TSTS    R1, #&FF
        ADDEQ   R7, R7, #8
        MOVEQ   R1, R1, LSR #8

        TSTS    R1, #&F
        ADDEQ   R7, R7, #4
        MOVEQ   R1, R1, LSR #4

        TSTS    R1, #&3
        ADDEQ   R7, R7, #2
        MOVEQ   R1, R1, LSR #2

        TSTS    R1, #&1
        ADDEQ   R7, R7, #1
      |
        SUB     LR, R1, #1
        BIC     LR, R1, LR ; identifies the bit position at which the borrow stopped
        CLZ     LR, LR
        ADD     R7, R7, #31
        SUB     R7, R7, LR
      ]
 [ DebugEx
        DREG    R7, "<-RdLenBits(len:", cc
        DLINE   ")"
 ]
        RestPSR R3,,f
        Pull    "R0-R3,PC"

10                              ;long obj
        ADD     R7, R7, LR
        MOVS    R1, R2
        BNE     %BT05
15
        LDMIA   R0!,{R1,R2}
        ADD     R7, R7, #32*2
        ORRS    LR, R1, R2
        BEQ     %BT15
        TEQS    R1, #0
        SUBNE   R7, R7, #32
        MOVEQ   R1, R2
        B       %BT05

 [ BigMaps
; ======================
; FreePrimitiveRdLenBits
; ======================

;entry
; R2 = idlen
; R10 -> new map start
; R11 bit ptr to map obj (must be free space)
;exit
; R7 len bits

PrimitiveFreeRdLenBits
        Push    "R0-R3,LR"
        SavePSR R3
        CMP     r2, #MaxFreeLinkBits
        MOVHI   r7, #MaxFreeLinkBits
        MOVLS   R7, R2
        B       %B02

 ]

; ==================
; PrimitiveRdLenBits
; ==================

;entry
; R2 = idlen
; R10 -> new map start
; R11 bit ptr to map obj
;exit
; R7 len bits
 [ BigMaps
PrimitiveFragRdLenBits
 |
PrimitiveRdLenBits
 ]
        Push    "R0-R3,LR"
        SavePSR R3
        MOV     R7, R2
        B       %B02

 [ BigMaps

; ==============
; FreeRdLinkBits
; ==============

;entry
; R10 -> new map start
; R11 bit ptr to map obj, must be free space
;exit
; R8 link bits, Z set if 0

FreeRdLinkBits ROUT
        Push    "R0,LR"
 [ DebugEx
 [ BigMaps
        DREG    R10, "FreeRdLinkBits(map:",cc
 |
        DREG    R10, "RdLinkBits(map:",cc
 ]
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        ADD     LR, R10,R11,LSR #3
      [ SupportARMv6
        BIC     LR, LR,#3
      ]
        LDMIA   LR, {R8,LR}
        ANDS    R0, R11,#31
        MOVNE   R8, R8, LSR R0
        RSBNE   R0, R0, #32
        ORRNE   R8, R8, LR, LSL R0
        LDRB    LR, [R10,#ZoneHead+DiscRecord_IdLen]
        CMP     LR, #MaxFreeLinkBits
        MOVHI   LR, #MaxFreeLinkBits
        MOV     R0, R8, LSR LR
        SUBS    R8, R8, R0, LSL LR
 [ DebugEx
        DREG    R8, "<-RdLinkBits(link:",cc
        DLINE   ")"
 ]
        Pull    "R0,PC"

 ]

; ==========
; RdLinkBits
; ==========

;entry
; R10 -> new map start
; R11 bit ptr to map obj
;exit
; R8 link bits, Z set if 0
 [ BigMaps
FragRdLinkBits ROUT
 |
RdLinkBits ROUT
 ]
        Push    "R0,LR"
 [ DebugEx
 [ BigMaps
        DREG    R10, "FragRdLinkBits(map:",cc
 |
        DREG    R10, "RdLinkBits(map:",cc
 ]
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        ADD     LR, R10,R11,LSR #3
      [ SupportARMv6
        BIC     LR, LR,#3
      ]
        LDMIA   LR, {R8,LR}
        ANDS    R0, R11,#31
        MOVNE   R8, R8, LSR R0
        RSBNE   R0, R0, #32
        ORRNE   R8, R8, LR, LSL R0
        LDRB    LR, [R10,#ZoneHead+DiscRecord_IdLen]
        MOV     R0, R8, LSR LR
        SUBS    R8, R8, R0, LSL LR
 [ DebugEx
        DREG    R8, "<-RdLinkBits(link:",cc
        DLINE   ")"
 ]
        Pull    "R0,PC"

 [ BigMaps
; =======================
; FreePrimitiveRdLinkBits
; =======================

;entry
; r2 = idlen
; R10 -> new map start
; R11 bit ptr to map obj, must be free space
;exit
; R8 link bits, Z set if 0

PrimitiveFreeRdLinkBits ROUT
        Push    "R0,LR"
 [ DebugEx
        DREG    R2, "PrimitiveRdLinkBits(LinkBits:",cc
        DREG    R10, ", map:",cc
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        ADD     LR, R10,R11,LSR #3
      [ SupportARMv6
        BIC     LR, LR,#3
      ]
        LDMIA   LR, {R8,LR}
        ANDS    R0, R11,#31
        MOVNE   R8, R8, LSR R0
        RSBNE   R0, R0, #32
        ORRNE   R8, R8, LR, LSL R0
        CMP     r2, #MaxFreeLinkBits
        MOVHI   lr, #MaxFreeLinkBits
        MOVLS   lr, r2
        MOV     R0, R8, LSR lr
        SUBS    R8, R8, R0, LSL lr
 [ DebugEx
        DREG    R8, "<-PrimitiveRdLinkBits(link:",cc
        DLINE   ")"
 ]
        Pull    "R0,PC"
 ]


; ===================
; PrimitiveRdLinkBits
; ===================

;entry
; r2 = idlen
; R10 -> new map start
; R11 bit ptr to map obj
;exit
; R8 link bits, Z set if 0

 [ BigMaps
PrimitiveFragRdLinkBits ROUT
 |
PrimitiveRdLinkBits ROUT
 ]
        Push    "R0,LR"
 [ DebugEx
        DREG    R2, "PrimitiveRdLinkBits(LinkBits:",cc
        DREG    R10, ", map:",cc
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        ADD     LR, R10,R11,LSR #3
      [ SupportARMv6
        BIC     LR, LR,#3
      ]
        LDMIA   LR, {R8,LR}
        ANDS    R0, R11,#31
        MOVNE   R8, R8, LSR R0
        RSBNE   R0, R0, #32
        ORRNE   R8, R8, LR, LSL R0
        MOV     R0, R8, LSR R2
        SUBS    R8, R8, R0, LSL R2
 [ DebugEx
        DREG    R8, "<-PrimitiveRdLinkBits(link:",cc
        DLINE   ")"
 ]
        Pull    "R0,PC"


; =========
; WrLenBits
; =========

;R0  len in bits
;R1  map ptr
;R10 -> map start

 [ BigMaps
FragWrLenBits ROUT
 |
WrLenBits ROUT
 ]
        Push    "R0-R6,LR"
        SavePSR R6
 [ DebugE
 [ BigMaps
        DREG    R0, "FragWrLenBits(len:",cc
 |
        DREG    R0, "WrLenBits(len:",cc
 ]
        DREG    R1, ", map ptr:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        BL      MarkZone        ;(R1,R10)
        LDRB    LR, [R10,#ZoneHead+DiscRecord_IdLen]
10
        SUB     R0, R0, LR              ;skip next field
        ADD     R1, R1, LR
        ADD     R2, R10,R1, LSR #3
        BIC     R2, R2, #3              ;word containing start of next field
        AND     R1, R1, #31             ;bit alignment
        RSB     LR, R1, #32
        SUBS    R0, R0, LR
        ADDLS   LR, R0, LR
        LDR     R3, [R2]                ;LR = field width in first word
        MOV     R4, #1
        RSB     R5, R4, R4, LSL LR      ;unshifted bits to clear 2^LR-1
        BIC     R3, R3, R5, LSL R1      ;clear old bits
        ADDLS   R5, R4, R5, LSR #1      ;if end in this word new bits 2^(LR-1)
        ORRLS   R3, R3, R5, LSL R1
        STR     R3, [R2],#4
        BLS     %FT90                   ;done if all in this word

        MOV     R5, #0
05                              ;loop to deal with middle zeroes
        SUBS    R0, R0, #32
        STRHI   R5, [R2],#4
        BHI     %BT05
        ADD     R0, R0, #32             ;R0 = field width in final word
        LDR     R3, [R2]
        RSB     R5, R4, R4, LSL R0      ;bits to clear 2^R0-1
        BIC     R3, R3, R5
        ADD     R5, R4, R5, LSR #1      ;bits to set 2^(R0-1)
        ORR     R3, R3, R5
        STR     R3, [R2]
90
        RestPSR R6,,f
        Pull    "R0-R6,PC"

 [ BigMaps

; =============
; FreeWrLenBits
; =============

;R0  len in bits
;R1  map ptr, must be free space
;R10 -> map start

FreeWrLenBits
        Push    "R0-R6,LR"
        SavePSR R6
 [ DebugE
 [ BigMaps
        DREG    R0, "FreeWrLenBits(len:",cc
 |
        DREG    R0, "WrLenBits(len:",cc
 ]
        DREG    R1, ", map ptr:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        BL      MarkZone        ;(R1,R10)
        LDRB    LR, [R10,#ZoneHead+DiscRecord_IdLen]
        CMP     LR, #MaxFreeLinkBits
        MOVHI   LR, #MaxFreeLinkBits
        B       %bt10
 ]

 [ BigMaps

; ======================
; FreePrimitiveWrLenBits
; ======================

;entry
; R0  next bits
; R1  map ptr, must be free space
; r2  idlen
; R10 -> map start

; As WrLenBits, but doesn't mark the zone
PrimitiveFreeWrLenBits
        Push    "R0-R6,LR"
        SavePSR R6
 [ DebugE
        DREG    R0, "PrimitiveWrLenBits(len:",cc
        DREG    R1, ", map ptr:",cc
        DREG    R2, ", LinkBits:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        CMP     r2, #MaxFreeLinkBits
        MOVHI   LR, #MaxFreeLinkBits
        MOVLS   LR, R2
        B       %BT10

 ]

; ==================
; PrimitiveWrLenBits
; ==================

;entry
; R0  next bits
; R1  map ptr
; r2  idlen
; R10 -> map start

; As WrLenBits, but doesn't mark the zone

 [ BigMaps
PrimitiveFragWrLenBits
 |
PrimitiveWrLenBits
 ]
        Push    "R0-R6,LR"
        SavePSR R6
 [ DebugE
        DREG    R0, "PrimitiveWrLenBits(len:",cc
        DREG    R1, ", map ptr:",cc
        DREG    R2, ", LinkBits:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        MOV     LR, R2
        B       %BT10

; ==========
; WrLinkBits
; ==========

;entry
; R0  next bits
; R1  map ptr
; R10 -> map start

 [ BigMaps
FragWrLinkBits ROUT
 |
WrLinkBits ROUT
 ]
        Push    "R1-R6,LR"
        SavePSR R6
 [ DebugE
  [ BigMaps
        DREG    R0, "FragWrLinkBits(link:",cc
  |
        DREG    R0, "WrLinkBits(link:",cc
  ]
        DREG    R1, ", map ptr:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        BL      MarkZone                ;(R1,R10)

        LDRB    R2, [R10,#ZoneHead+DiscRecord_IdLen]    ;form mask for clearing

10
        ADD     LR, R10, R1, LSR #3
      [ SupportARMv6
        BIC     LR, LR, #3
      ]

        MOV     R3, #1
        RSB     R2, R3, R3, LSL R2

        LDMIA   LR, {R3,R4}             ;64 bits containing old value
        AND     R1, R1, #31
        RSB     R5, R1, #32

        BIC     R3, R3, R2, LSL R1      ;clear old bits
        BIC     R4, R4, R2, LSR R5
        ORR     R3, R3, R0, LSL R1      ;OR in new bits
        ORR     R4, R4, R0, LSR R5

        STMIA   LR, {R3,R4}             ;write back modified 64 bits
        RestPSR R6,,f
        Pull    "R1-R6,PC"

 [ BigMaps

; ==============
; FreeWrLinkBits
; ==============

;entry
; R0  next bits
; R1  map ptr, must be free space
; R10 -> map start

FreeWrLinkBits
        Push    "R1-R6,LR"
        SavePSR R6
 [ DebugE
 [ BigMaps
        DREG    R0, "FreeWrLinkBits(link:",cc
 |
        DREG    R0, "WrLinkBits(link:",cc
 ]
        DREG    R1, ", map ptr:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        BL      MarkZone                ;(R1,R10)

        LDRB    R2, [R10,#ZoneHead+DiscRecord_IdLen]    ;form mask for clearing
        CMP     r2, #MaxFreeLinkBits
        MOVHI   r2, #MaxFreeLinkBits
        B       %BT10
 ]


; ===================
; PrimitiveWrLinkBits
; ===================

;entry
; R0  next bits
; R1  map ptr
; r2  idlen
; R10 -> map start

; As WrLinkBits, but doesn't mark the zone
 [ BigMaps
PrimitiveFragWrLinkBits
 |
PrimitiveWrLinkBits
 ]
        Push    "R1-R6,LR"
        SavePSR R6
 [ DebugE
        DREG    R0, "PrimitiveWrLinkBits(link:",cc
        DREG    R1, ", map ptr:",cc
        DREG    R2, ", idlen:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        B       %BT10

 [ BigMaps
; =======================
; PrimitiveFreeWrLinkBits
; =======================

;entry
; R0  next bits
; R1  map ptr, must be free space
; r2  idlen
; R10 -> map start

; As FreeWrLinkBits, but doesn't mark the zone
PrimitiveFreeWrLinkBits
        Push    "R1-R6,LR"
        SavePSR R6
 [ DebugE
        DREG    R0, "PrimitiveWrLinkBits(link:",cc
        DREG    R1, ", map ptr:",cc
        DREG    R2, ", idlen:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        CMP     r2,#MaxFreeLinkBits
        MOVHI   r2,#MaxFreeLinkBits

        B       %BT10
 ]

; ==========
; WrFreeNext
; ==========

; point R1 at R0, R0 may be 0 marking end
; R10 -> map start

WrFreeNext ROUT
        Push    "R0,R2,LR"
        SavePSR R2
 [ DebugE
        DREG    R0, "WrNextFree(dest ptr:",cc
        DREG    R1, ", source ptr:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        TEQS    R0, #0
        SUBNE   R0, R0, R1
 [ BigMaps
        BL      FreeWrLinkBits      ;(R0,R1,R10)
 |
        BL      WrLinkBits      ;(R0,R1,R10)
 ]
        RestPSR R2,,f
        Pull    "R0,R2,PC"


; ==========
; IdsPerZone
; ==========

;entry R10 -> map start

;exit  R1 = ids per zone

IdsPerZone ROUT
        Push    "R0,LR"
        LDRB    R0, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R1, #8
        MOV     R0, R1, LSL R0          ;bits in a zone
        LDR     R1, [R10,#ZoneHead+DiscRecord_ZoneSpare-2]
        SUB     R0, R0, R1, LSR #16
        LDRB    R1, [R10,#ZoneHead+DiscRecord_IdLen]
        ADD     R1, R1, #1
        BL      Divide
        MOV     R1, R0
 [ DebugE
        DREG    R1, "<-IdsPreZone(ids:",cc
        DREG    R10, ", map:", cc
        DLINE   ")"
 ]
        Pull    "R0,PC"


; ================
; IndDiscAddToZone
; ================

;entry
; R0  ind disc address
; R10 -> map start

;exit R0 = zone

IndDiscAddToZone ROUT
        Push    "R1,R2,LR"
        SavePSR R2
 [ DebugE
        DREG    R0, "IndDiscAddToZone(disc add:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]

; SBP: need to change this code if going to be using large fragment ids

 [ BigMaps
        MOV     R0, R0, LSL #3
        MOV     R0, R0, LSR #3+8      ;just id bits left
 |
        MOV     R0, R0, LSL #8+1
        MOV     R0, R0, LSR #8+1+8      ;just id bits left
 ]

        TEQS    R0, #2                  ; ?? special case for id=2 (defective sectors) ??
        BEQ     %FT50

        BL      IdsPerZone              ;(R10->R1)
        BL      Divide                  ;(R0,R1->R0,R1)
 [ DebugE
        DREG    R0, "<-IndDiscAddToZone(zone:",cc
        DLINE   ")"
 ]
        RestPSR R2,,f
        Pull    "R1,R2,PC"


50
 [ BigMaps
        LDRB    R0, [R10,#ZoneHead+DiscRecord_NZones]
        LDRB    R1, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     R0, R0, R1, LSL #8
 |        
        LDRB    R0, [R10,#ZoneHead+DiscRecord_NZones]
 ]
        MOV     R0, R0, LSR #1          ;the map zone
 [ DebugE
        DREG    R0, "<-IndDiscAddToZone(zone:",cc
        DLINE   ")"
 ]
        RestPSR R2,,f
        Pull    "R1,R2,PC"


; ========
; UnusedId
; ========

;entry
; R0 zone
; R10 -> map start
;exit LR an unused id for that zone

UnusedId ROUT
        Push    "R0-R3,R6-R9,R11,LR"
 [ DebugE
        DREG    R0, "UnusedId(zone:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        BL      InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        MOV     R3, LR          ;start of next zone
        BL      IdsPerZone      ;(R10->R1)
        MUL     R6, R0, R1      ;first id for this zone
        ADD     R2, R6, R1      ;first id in next zone
        MOV     R0, #ScratchSpace
        MOV     R1, R1, LSR #3  ;init bit table of used ids
        ADD     R1, R1, #1
        BL      ZeroRam
        TEQS    R6, #0          ;ids 0,1,2 are reserved
        MOVEQ   LR, #2_00000111
        STREQB  LR, [R0]
        MOV     R1, #1
10                              ;GO THROUGH ZONE NOTING IDS USED

 [ BigMaps
        TEQS    R11,R9          ;is this map obj a gap?
        BEQ     %FT15           ; gap

        ; not gap
        BL      FragRdLinkBits  ;(R11->R8,Z)
        SUBS    LR, R8, R6
        CMPHSS  R2, R8
        ADDHI   R8, R0, LR, LSR #3
        ANDHI   LR, LR, #7
        LDRHIB  R7, [R8]
        ORRHI   R7, R7, R1, LSL LR
        STRHIB  R7, [R8]
        BL      FragRdLenBits   ; length
        ADD     R11,R11,R7
        CMPS    R11,R3
        BLO     %BT10           ;loop while more frags in zone
        B       %FT16

15      ; it was a gap
        BL      FreeRdLinkBits  ;(R11->R8,Z)
        ADD     R9,R9,R8        ;next gap pointer
        BL      FreeRdLenBits   ; length
        ADD     R11,R11,R7
        CMPS    R11,R3
        BLO     %BT10           ;loop while more frags in zone

16      ; re-join here

 |
        BL      RdLinkBits      ;(R11->R8,Z)
        TEQS    R11,R9          ;is this map obj a gap ?
        ADDEQ   R9, R9, R8
        BEQ     %FT15
        SUBS    LR, R8, R6
        CMPHSS  R2, R8
        ADDHI   R8, R0, LR, LSR #3
        ANDHI   LR, LR, #7
        LDRHIB  R7, [R8]
        ORRHI   R7, R7, R1, LSL LR
        STRHIB  R7, [R8]
15
        BL      RdLenBits       ;(R11->R7)
        ADD     R11,R11,R7
        CMPS    R11,R3
        BLO     %BT10           ;loop while more frags in zone
 ]

        SUB     R0, R0, #4
20                              ;FIND FIRST UNUSED ID
        LDR     R7, [R0,#4] !
        CMPS    R7, #-1
        BEQ     %BT20           ;all these ids used
        SUB     LR, R0, #ScratchSpace
        ADD     LR, R6, LR, LSL #3
25
        MOVS    R7, R7, LSR #1
        ADDCS   LR, LR, #1
        BCS     %BT25

 [ DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0, "<-UnusedId(Id:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0-R3,R6-R9,R11,PC"


; ==================
; DefFindIdThenClaim
; ==================

DefFindIdThenClaim
        MOV     R5,#-1

; ===============
; FindIdThenClaim
; ===============

;entry
; R3  top 3 bits disc
; R4  length to claim
; R5  do not use first gap of this size
; R6  predecessor gap of gap to start at
; R10 -> map start

;exit
; R2  ind disc address of obj
; R11 map ptr of obj
; LR number of map bits actually claimed

FindIdThenClaim
        Push    "R0,R7,LR"
        SavePSR R7
 [ DebugE
        DREG    R3, "FindIdThenClaim(disc:",cc
        DREG    R4, ", len:",cc
        DREG    R5, ", miss gap:",cc
        DREG    R6, ", pre gap:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        LDRB    R0, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R0, R6, LSR R0
        MOV     R0, R0, LSR #3  ;zone
        BL      UnusedId        ;(R0,R10->LR)
        AND     R0, R3, #DiscBits
        ORR     R0, R0, LR, LSL #8
        MOV     R2, LR, LSL #8
        BL      ChainClaim      ;(R2,R4-R6,R10->R11)
        MOV     R2, R0
 [ DebugE
        DREG    R2, "<-FindIdThenClaim(disc add:",cc
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        RestPSR R7,,f
        Pull    "R0,R7,PC"


; =============
; DefChainClaim
; =============

DefChainClaim
        MOV     R5,#-1

; ==========
; ChainClaim
; ==========

;entry
; R2  link bits in bits 8-22 [BigMaps bits 8-28]
; R4  length to claim in map bits
; R5  do not use first gap of this size
; R6  predecessor gap of gap to start at
; R10 -> map start

;exit
; R11 map ptr of obj
; LR number of map bits actually claimed

ChainClaim ROUT
 [ DebugE :LOR: DebugEa
        DREG    R2, "ChainClaim(link:",cc
        DREG    R4, ", len:",cc
        DREG    R5, ", miss gap:",cc
        DREG    R6, ", pre gap:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        Push    "R0-R9,R11,LR"
        SavePSR R11
        Push    "R11"

        ; Convert to Id
 [ BigMaps
        MOV     R2, R2, LSL #3
        MOV     R2, R2, LSR #3+8
 |
        MOV     R2, R2, LSL #8+1
        MOV     R2, R2, LSR #8+1+8
 ]

        MOV     R11,R6
        MOV     R3, #0          ;amount claimed so far is 0

        ; Start searching for free space after the gap supplied
        BL      NextFree        ;(R10,R11->R9,R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits       ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
        STR     R11,[sp, #11*4] ;map ptr of obj is first gap found (sp offset OK - used to be 10)
        B       %FT10
05
        BL      NextFree        ;(R10,R11->R9,R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
10
        BCC     %FT15           ;still in same zone

        ; If changed zone then terminate the previous zone's free list
        MOV     R1, R6
        MOV     R0, #0
 [ BigMaps
        BL      FreeWrLinkBits      ;mark end of free chain in previous zone
 |
        BL      WrLinkBits      ;mark end of free chain in previous zone
 ]
        BNE     %FT14           ;not reached end of map

        ; reached end of map so wrap to the map start
        MOV     R11,#FreeLink*8 ;if end start again
        BL      NextFree        ;(R10,R11->R9,R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
14
        MOV     R6, R9          ;re-init last unused gap

15
        TEQS    R7, R5          ;IF this is gap asked not to use
        MOVEQ   R1, R6
        MOVEQ   R0, R11
        BLEQ    WrFreeNext      ;(R0,R1,R10) point last unused gap at it
        MOVEQ   R6, R11         ; re-init last unused gap
        MOVEQ   R5, #-1         ; prevent further matches
        BEQ     %BT05

        MOV     R0, R2
        MOV     R1, R11
        SUBS    R4, R4, R7      ;desired -= gap size
        ADDHI   R3, R3, R7      ;claimed += gap size
        BLS     %FT20           ;if no more gaps needed
        BL      NextFree        ;(R10,R11->R9,R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
        BL      FragWrLinkBits  ;(R0,R1,R10) set fragment link bits
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
        BL      WrLinkBits      ;(R0,R1,R10) set fragment link bits
 ]
        B       %BT10

20
        ; Have now claimed all the whole fragments so lets sort out the last
        ; fragment.
        ADD     R4, R4, R7      ;amount of this last frag needed
 [ BigMaps
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
        BL      FragWrLinkBits  ;(R0,R1,R10) set fragment link bits
 |
        BL      RdLinkBits      ;(R10,R11->R8,Z)
        BL      WrLinkBits      ;(R0,R1,R10) set fragment link bits
 ]
        ADDNE   R8, R11, R8     ;next free in this zone

        ; Sort out how much of the last gap we want to claim
        BL      MinMapObj       ;(R10->LR)
        CMPS    R4, LR          ;round up to min size
        MOVLO   R4, LR
        SUB     R0, R7, R4      ;amount of frag left assuming we claim this size
        CMPS    R0, LR
        MOVLO   R4, R7          ;round up to whole of gap if too little left to split it

        ; LO=>not splitting this gap
        ; HS=>splitting this gap
        ; R3=amount in bits claimed so far
        ; R4=amount of this gap being given over to ChainClaim
        MOVHS   R0, R4          ;if can split put in new length
        MOVHS   R1, R11
 [ BigMaps
        BLHS    FragWrLenBits
 |
        BLHS    WrLenBits
 ]
        MOV     R1, R6          ;point previous gap at correct next
        MOVLO   R0, R8          ;not splitting=>next gap is new next gap
        ADDHS   R0, R11, R4     ;splitting=>2nd half of this gap is new next gap
        BL      WrFreeNext      ;(R0,R1,R10)
        MOVHS   R1, R0          ;if splitting point new fragment at next
        MOVHS   R0, R8
        BLHS    WrFreeNext      ;(R0,R1,R10)
        ADD     LR, R3, R4      ;return amount claimed in LR
 [ DebugE :LOR: DebugEa
        LDR     R11,[SP,#10*4]
        DREG    R11, "<-ChainClaim(map ptr:",cc
        DREG    LR, ",Bits:",cc
        DLINE   ")"
 ]
        Pull    "R11"
        RestPSR R11,,f
        Pull    "R0-R9,R11,PC"


; ===========
; ShortenFrag
; ===========

;entry
; R0  new len in map bits
; R1  old len in map bits
; R2  map bit of frag start
; R3  map bit of start of the gap before frag
; R10 -> map start

ShortenFrag ROUT
        Push    "R0,R1,R4-R8,R11,LR"
 [ DebugE
        DREG    R0, "ShortenFrag(new len:",cc
        DREG    R1, ", old len:",cc
        DREG    R2, ", frag start:",cc
        DREG    R3, ", pre gap:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        MOV     R11,R3
 [ BigMaps
 ; R3 is a gap so we're working in Free spaces
        BL      FreeRdLenBits       ;(R10,R11->R7)
        BL      FreeRdLinkBits      ;(R10,R11->R8,Z)
 |
        BL      RdLenBits       ;(R10,R11->R7)
        BL      RdLinkBits      ;(R10,R11->R8,Z)
 ]
        ADDNE   R8, R3, R8      ;start of post gap
        ADD     R4, R3, R7      ;end of pre gap
        ADD     R5, R2, R0      ;new frag end
        ADD     R6, R2, R1      ;old frag end

        TEQS    R0, #0          ;if fragment not disappearing altogether
        MOVNE   R1, R2          ;set its new length
 [ BigMaps
        BLNE    FragWrLenBits   ;(R0,R1,R10)
 |
        BLNE    WrLenBits       ;(R0,R1,R10)
 ]

        CMPS    R4, R5          ;IF gap joins pre gap
        MOVEQ   R5, R3          ;adjust gap start
        MOVNE   R1, R3          ;ELSE point pre gap at gap
        MOVNE   R0, R5
        BLNE    WrFreeNext      ;(R0,R1,R10)

        TEQS    R6, R8          ;IF gap joins post gap
        BNE     %FT10
        MOV     R11,R8
 [ BigMaps
        BL      FreeRdLenBits   ;(R10,R11->R7)
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
 |
        BL      RdLenBits       ;(R10,R11->R7)
        BL      RdLinkBits      ;(R10,R11->R8,Z)
 ]
        ADDNE   R8, R11,R8      ;adjust post gap
        ADD     R6, R6, R7      ;and gap end
10
        SUB     R0, R6, R5
        MOV     R1, R5
 [ BigMaps
        BL      FreeWrLenBits   ;(R0,R1,R10) set gap length
 |
        BL      WrLenBits       ;(R0,R1,R10) set gap length
 ]
        MOV     R0, R8
        BL      WrFreeNext      ;(R0,R1,R10) and successor

 [ DebugE
        DLINE   "<-ShortenFrag()"
 ]
        Pull    "R0,R1,R4-R8,R11,PC"


; ============
; ReallyShared
; ============

;entry
; R2 ind disc add
; R3 dir
; R4 -> dir entry
; R5 -> dir start, may be fudged as only used to check sharing

;exit EQ <=> file is in shared frag and at least one other obj is sharing frag

;CAN'T READ IN DISC ADD FROM DIR ENTRY AS CLOSE FILE WILL HAVE ALREADY MODIFIED
;THIS IF FILE IS ZERO LENGTH

ReallyShared ROUT
        Push    "R0,R1,R4,LR"
 [ DebugE
        DREG    R2, "ReallyShared(disc add:",cc
        DREG    R3, ", dir:",cc
        DREG    R4, ", entry:",cc
        DREG    R5, ", dir start:",cc
 ]
        MOV     R1, R2, LSR #8
        TSTS    R2, #&FF        ;If not in shared fragment
        TOGPSR  Z_bit,LR
        BNE     %FT95
        TEQS    R1, R3, LSR #8
        BEQ     %FT95           ;sharing with parent dir
        MOV     R0, R4
 [ BigDir
        BL      TestBigDir      ;test for big-dir ness
        BEQ     %FT99
 ]
        ADD     R4, R5, #DirFirstEntry
05
        TEQS    R4, R0
        BEQ     %FT10
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        TEQS    R1, LR, LSR #8
        BEQ     %FT95           ;sharing with file
10
        LDRB    LR, [R4,#NewDirEntrySz] !
        CMPS    LR, #" "+1
        BHS     %BT05           ;loop while more dir entries
                        ;NE if no sharers
95
 [ DebugE
        BEQ     %FT01
        DLINE   "<-ReallyShared(not really sharing)"
        B       %FT02
01
        DLINE   "<-ReallyShared(really sharing)"
02
 ]
        Pull    "R0,R1,R4,PC"

 [ BigDir
99
        BL      GetDirFirstEntry
        SUB     R4, R4, #BigDirEntrySize
        B       %FT10
05
        TEQS    R4, R0
        BEQ     %FT10
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        TEQS    R1, LR, LSR #8
        BEQ     %BT95           ;sharing with file
10
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
        BNE     %BT05           ;loop while more dir entries
        TOGPSR  Z_bit,LR
                        ;NE if no sharers
        B       %BT95
 ]

; ========
; MarkZone
; ========

; mark zone as changed and candidate for compaction

;entry
; R1     map ptr
; R10 -> map start

MarkZone ROUT
        Push    "R0-R1,LR"
 [ DebugE
        DREG    R1, "MarkZone(map ptr:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
 [ BigMaps
        LDRB    R0, [R10,#ZoneHead+DiscRecord_NZones]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     R0, R0, LR, LSL #8
 |
        LDRB    R0, [R10,#ZoneHead+DiscRecord_NZones]
 ]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        ADD     R0, R10,R0,LSL LR        ;-> zone flags
        ADD     LR, LR, #3
        MOV     R1, R1, LSR LR            ;zone
        LDRB    LR, [R0,R1]
        BIC     LR, LR, #ZoneValid :OR: ZoneCompacted
        STRB    LR, [R0,R1]
        Pull    "R0-R1,PC"              ; flags preserved


; ============
; ZoneFlagsPtr
; ============

;entry R10 -> map start
;exit LR -> zone flags table

ZoneFlagsPtr ROUT
        Push    "R0,LR"
 [ BigMaps
        LDRB    R0, [R10,#ZoneHead+DiscRecord_NZones]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     R0, R0, LR, LSL #8
 |
        LDRB    R0, [R10,#ZoneHead+DiscRecord_NZones]
 ]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        ADD     LR, R10,R0, LSL LR        ;-> zone flags
 [ DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0, "<-ZoneFlagsPtr(ptr:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,PC"                 ; flags preserved


; =============
; Log2AllocBits
; =============

; entry R10 -> map start
; exit  LR  log2 # bits in map for an allocation unit

Log2AllocBits ROUT
        Push    "R0,LR"
        LDRB    R0, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        SUBS    R0, R0, LR
        MOVLS   LR, #0
        MOVHI   LR, R0
 [ DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0, "<-Log2AllocBits(log2bits:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,PC"


; =============
; AllocBitWidth
; =============

; entry R10 -> map start
; exit  LR  # bits in map for an allocation unit

AllocBitWidth ROUT
        Push    "R0,LR"
        LDRB    R0, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        SUBS    R0, R0, LR
        MOV     LR, #1
        MOVHI   LR, LR, LSL R0
 [ DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0, "<-AllocBitWidth(bitwidth:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,PC"


; =========
; MinMapObj
; =========

; entry R10 -> map start
; exit  LR  # bits in map for smallest map obj

MinMapObj ROUT
        Push    "R0,R1,LR"
        BL      AllocBitWidth   ;(->LR)
        MOV     R0, LR
        LDRB    R1, [R10,#ZoneHead+DiscRecord_IdLen]
05
        CMPS    LR, R1
        ADDLS   LR, LR, R0
        BLS     %BT05
 [ DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0, "<-MinMapObj(bits:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,R1,PC"

        LTORG
        END
@


4.12
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d430 8
d447 1
a447 1
;
d451 2
a452 2
MeasureFileAllocSize ROUT
        Push    "r1,r3,r5,r6,r7,r8,r9,r10,r11,lr"
d454 3
a456 1
        BL      TestMap
d460 2
a461 2
        ; Shared. Size allocated = sectors occupied
        BL      ReadLen
d467 1
a467 1
        BL      RoundUpShare    ;(r0,r3->r0)
d469 1
a469 1
        BL      RoundUpSector   ;(r0,r3->r0)
d478 2
a479 2
        MOV     r1, r1, ASL #(3)        ; remove disc number
        MOV     r1, r1, LSR #(3+8)      ; remove shared offset
d486 3
d491 1
d527 1
d529 2
a530 89
 [ BigMaps
        Push    "R0"
        LDRB    R0, [R10, #ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     LR, LR, R0, LSL #8
        Pull    "R0"
 ]
        CMP     r0, lr
        BLO     %BT10

 [ DebugBs
        DREG    r6, "UnShared bit size="
 ]
        LDRB    lr, [r10, #ZoneHead+DiscRecord_Log2bpmb]
        MOV     r0, r6, ASL lr  ; convert to bytes in r0

        BL      UnlockMap
95
 [ DebugBs
        BVS     %FT01
        DREG    r0, "Open allocated size="
01
 ]
        Pull    "r1,r3,r5,r6,r7,r8,r9,r10,r11,pc"

; ===========================
; MeasureFileAllocSize_GotMap
; ===========================

; entry
; r1 = FcbIndDiscAdd
; r3 = dir indirect disc address
; r4 -> dir entry
;
; exit
; r0 = alloc size of file in bytes

MeasureFileAllocSize_GotMap ROUT
        Push    "r1,r3,r5,r6,r7,r8,r9,r10,r11,lr"

        BL      TestMap
        TSTEQ   r1, #&ff
        BEQ     %FT05           ; branch if new map and not shared

        ; Shared. Size allocated = sectors occupied
        BL      ReadLen
        MOV     r0, lr
 [ DebugBs
        DREG    r0, "Shared/Old map unrounded size = "
 ]
 [ BigShare
        BL      RoundUpShare    ;(r0,r3->r0)
 |
        BL      RoundUpSector   ;(r0,r3->r0)
 ]
        B       %FT95

05
        ; Unshared. Size allocated = fragments occupied
        MOV     r3, r1

        ; r1=Link
        MOV     r1, r1, ASL #(3)        ; remove disc number
        MOV     r1, r1, LSR #(3+8)      ; remove shared offset

        ; unallocated/bad blocks mean size=0
        CMP     r1, #1
        MOVLS   lr, #0
        BLS     %FT95

        BL      InitReadNewFs   ;(R3->R10,R11,LR)

        MOV     r0, #0          ; zone
        MOV     r6, #0          ; accumulated file size
        B       %FT60
10
        BL      InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        MOV     R5, LR          ; zone end
15
 [ BigMaps
        TEQ     R11, R9
        BNE     %FT16           ; gap?

        BL      FreeRdLenLinkBits ; gap
        ADD     r9,r11,r8
        B       %ft20

16                              ; not gap
        BL      FragRdLenLinkBits       ; just read the object

a531 14
        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
        TEQ     R11, R9
        ADDEQ   R9, R11, R8     ; it's a free block
        BEQ     %FT20
 ]
        TEQ     R8, R1          ; One of ours?
        ADDEQ   R6, R6, R7      ; Yes, accumulate the length
20
        ADD     R11, R11, R7    ; next fragment
        CMP     R11, R5         ; end of zone?
        BLO     %BT15

        ADD     r0, r0, #1      ; next zone
60
a532 5
 [ BigMaps
        Push    "R0"
        LDRB    r0, [R10, #ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     lr, lr, r0, LSL #8
        Pull    "R0"
d541 8
a548 2
        MOV     r0, r6, ASL lr  ; convert to bytes in r0

d555 1
a555 1
        Pull    "r1,r3,r5,r6,r7,r8,r9,r10,r11,pc"
d689 3
a691 3
; =======
; RoundUp
; =======
d702 1
a702 1
RoundUp ROUT
d704 1
a704 1
        DREG    R0, "RoundUp(value:",cc
d710 1
a710 1
        BL      ReadAllocSize
d713 5
d721 1
d723 8
a730 1
        DREG    R0, "<-RoundUp/RoundUpSector(value:",cc
d758 2
a759 1
        MOV     LR, R3, LSR #29
d762 1
d785 1
a785 1
        DREG    R0, "RoundUpSector(value:",cc
d791 2
a792 2
        MOV     LR, R3, LSR #29
        Push    "R2"
d794 1
a794 1
        LDRB    R2, [LR,#DiscRecord_Log2SectorSize]
d796 2
a797 2
        ADD     LR, R2, LR
        Pull    "R2"
d1333 1
a1333 1
        MOV     R9, R11,LSR LR           ;zone
d1335 1
a1336 1
 [ BigMaps
d1339 2
d2493 2
a2494 2
        SUBS    R4, R4, R7
        ADDHI   R3, R3, R7
@


4.11
log
@Fix asasm 2.00 errors
Detail:
  s/BigDirCode, s/FileCore20, s/FileCore33 - Fixed some operators which were missing their end colon
Admin:
  Identical binary under objasm


Version 3.49. Retagged as 'FileCore-3_49'
@
text
@d249 5
a254 5
 [ BigMaps
        Push    "R0"
        LDRB    R0, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     LR, LR, R0, LSL #8
        Pull    "R0"
d1375 1
a1375 1
        BL      FreeRdLinkBits              ;(R10,R11->R8,Z)
d1415 1
a1415 1
        BL      FreeRdLinkBits              ;(R10,R11->R8,Z)
d1423 1
a1423 1
        B        %BT05
d2293 1
a2293 1
50      LDRB    R0, [R10,#ZoneHead+DiscRecord_NZones]
d2295 1
d2298 2
d2301 1
a2301 1
        MOV     R0, R0, LSR #1
d2475 2
a2476 2
; R2  link bits in bits 8-22
; R4  length to claim
d2554 1
a2554 1
        BLEQ    WrFreeNext      ; point last unused gap at it
d2609 1
a2609 1
        BL      WrFreeNext
d2612 1
a2612 1
        BLHS    WrFreeNext
d2797 1
a2798 1
 [ BigMaps
d2801 2
d2823 1
a2824 1
 [ BigMaps
d2827 2
@


4.10
log
@Fold in old fixes.
From 1989, probably safe to keep them. Binary unchanged.

Version 3.47. Tagged as 'FileCore-3_47'
@
text
@d801 1
a801 1
 [ Debug5 :LOR DebugE
@


4.9
log
@Teach FileCore_LayoutStructure and Service_IdentifyDisc how to do 1 zone fixed discs.
From the change logs it was last fixed sometime around FileCore 2.50 era, but has been long broken.
The boot block was in the right place, but was overwritten by the root directory, and the wrong size entry was claimed in the map, amongst other errors.
Free'd up R6 in LayoutFreeSpaceMap to avoid having to keep reevaluating the number of zones - makes it a bit more readable. Corrected inaccurate comments. Checked the code paths for new map with and without boot block, with and without long filenames.
Test app 'Make1Zone' generates a small disc image which can be inspected in a hex editor for correctness.
In the identify code, be more strict about looking for a boot block only on fixed discs since they cannot occur on floppies (saves time, wasn't necessarily wrong).
The concept of a boot block at &C00 only works when 2 copies of the map can be fitted underneath that address, for future 2k and 4k sector sizes these do not fit and it is likely that 1 zone fixed discs are forbidden (a drive with 4k sectors would typically be > 512GB and 1 zone would be ~32MB so spilling into a second zone would waste < 0.01%).
Other minor changes:
* Free command now groups the 'K' with 'bytes' to match OS_ConvertFileSize.
* FileCore20 debug didn't assemble.
* FileCore33 beefed up comments.
* GenSWIs debug didn't assemble.
Tested with a special cut of RAMFS manually loading various 1 zone images into its dynamic area and checking they mount, have a sensible *MAP and *FREE result, can be written to, and don't have broken directories.

Version 3.46. Tagged as 'FileCore-3_46'
@
text
@a537 2
 [ fix_5

a640 1
 ]
@


4.8
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d662 2
a663 2
        MOV     R0, #8
        MOV     R0, R0, LSL R7
d665 2
a666 2
        SUB     R0, R0, LR, LSR #16     ;bits used in a zone
        MOVS    LR, R9, LSR #1          ;zone containing map
d668 1
a668 1
        SUBNE   R2, R2, #Zone0Bits
d965 1
a965 1
; left by lg2bpmb, and if bigdisc also adjust for the sector size
d1031 1
a1031 1
; left by lg2bpmb, and if bigdisc also adjust for the sector size
@


4.7
log
@  Various archiecture-based optimisations
Detail:
  * ARMv6+ builds use unaligned halfword and word loads and stores (unless
    pre-ARMv6 compatibility is required or NoUnaligned is set)
  * In many cases, one unnecessary BIC instruction has been removed from
    pre-ARMv6 builds
  * ARMv5+ builds (so Tungsten and OMAP) make use of CLZ instruction when
    parsing fragment blocks
Admin:
  Built and included in an OMAP3 ROM. But be warned, this has not received
  the rigorous testing normally required of filesystem code, use at your
  own risk.

Version 3.33. Tagged as 'FileCore-3_33'
@
text
@d68 1
a68 1
        LDRB    R6, [LR,#ShareSize]     ; get sharing unit
d71 1
a71 1
        LDRB    R6, [LR,#SectorSize]
d74 1
a74 1
        LDRB    R0, [LR,#BitSize]	;bytes per map bit
d88 1
a88 1
        LDRNEB  R1, [LR,#SectorSize]
d91 1
a91 1
        LDRB    R0, [LR,#BitSize]	;bytes per map bit
d187 1
a187 1
        LDREQB  R0, [R10,#ZoneHead+SectorSize]  ;find zone to start at
d222 2
a223 2
 	TEQS	R11, R9		; if gap
 	BNE	%FT27
d226 4
a229 4
        BL	FreeRdLenLinkBits ; read free link
        MOV	r3,r9		;  and just update gap before frag
        ADD	r9,r9,r8        ;  and gap after frag
        B	%FT30		;
d232 1
a232 1
 	BL	FragRdLenLinkBits ; get the length
d249 1
a249 1
        LDRB    LR, [R10,#ZoneHead+Zones]
d251 4
a254 4
 	Push	"R0"
 	LDRB	R0, [R10,#ZoneHead+Zones2]
 	ADD	LR, LR, R0, LSL #8
 	Pull	"R0"
d310 3
a312 3
        LDRB    R9, [R5, #Zones]
        LDRB	R7, [R5, #Zones2]
        ADD	R9, R9, R7, LSL #8
d314 1
a314 1
        LDRB    R9, [R5,#Zones]
d316 1
a316 1
        LDRB    R7, [R5,#SectorSize]
d352 1
a352 1
        MOV     R1, #ReadSecsOp :OR: NoEscape
d411 3
a413 3
 	LDR	LR, [R6, #DrvsFsMapFlags]
 	ORR	LR, LR, #BadFs
 	STR	LR, [R6, #DrvsFsMapFlags]
d488 2
a489 2
        TEQ	R11, R9
        BNE	%FT16		; gap?
d491 3
a493 3
        BL	FreeRdLenLinkBits ; gap
        ADD	r9,r11,r8
        B	%ft20
d495 2
a496 2
16 				; not gap
	BL	FragRdLenLinkBits	; just read the object
d513 1
a513 1
        LDRB    lr, [R10, #ZoneHead+Zones]
d515 4
a518 4
 	Push	"R0"
 	LDRB	R0, [R10, #ZoneHead+Zones2]
 	ADD	LR, LR, R0, LSL #8
 	Pull	"R0"
d526 1
a526 1
        LDRB    lr, [r10, #ZoneHead+BitSize]
d595 2
a596 2
        TEQ	R11, R9
        BNE	%FT16		; gap?
d598 3
a600 3
        BL	FreeRdLenLinkBits ; gap
        ADD	r9,r11,r8
        B	%ft20
d602 2
a603 2
16 				; not gap
	BL	FragRdLenLinkBits	; just read the object
d620 1
a620 1
        LDRB    lr, [R10, #ZoneHead+Zones]
d622 4
a625 4
 	Push	"R0"
 	LDRB	r0, [R10, #ZoneHead+Zones2]
 	ADD	lr, lr, r0, LSL #8
 	Pull	"R0"
d633 1
a633 1
        LDRB    lr, [r10, #ZoneHead+BitSize]
d658 1
a658 1
	Push    "R0,R1,LR"
d664 1
a664 1
        LDR     LR, [R5,#ZoneSpare-2]
d669 2
a670 2
        LDRB    R0, [R5,#BitSize]
        LDR     LR, [R5,#RootDir]
d673 4
a676 4
	SUBS	R0,R0,R7		; get required shift
	RSBMI	R0,R0,#0		; if negative then reverse.
	ORRMI	R2,LR,R2,LSR R0		;
	ORRPL	R2,LR,R2,LSL R0         ;
d684 1
a684 1
	Pull	"R0,R1,PC"
d835 1
a835 1
        LDRB    LR, [LR,#SectorSize]
d867 2
a868 2
        LDRB    R2, [LR,#SectorSize]
        LDRB    LR, [LR, #ShareSize]
d891 2
a892 2
        LDRB    R0, [LR,#SectorSize]    ;max of sector size and map bit size
        LDRB    R1, [LR,#BitSize]
d920 1
a920 1
        LDRB    LR, [LR,#SectorSize]    ;max of sector size and map bit size
d954 1
a954 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d957 1
a957 1
        LDR     LR, [R10,#ZoneHead+ZoneSpare-2]
d962 1
a962 1
        LDRB    LR, [R10,#ZoneHead+BitSize]
d968 5
a972 5
	LDRB	R10,[R10,#ZoneHead+SectorSize]	; log2 sector size
	SUBS	LR,LR,R10		; get overall shift
	RSBMI	LR,LR,#0		; if -ve shift then convert to +ve shift in other
	MOVMI	R0,R0,LSR LR		; ...direction
	MOVPL	R0,R0,LSL LR		; ...otherwise just do it
d1018 1
a1018 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d1021 2
a1022 2
	MOV	R11, R0, LSL LR ;map ptr to zone start
        LDR     LR, [R10,#ZoneHead+ZoneSpare-2]
d1027 2
a1028 2
	MOVMI   R0, #0		;if -ve disc address then must be on first zone
        LDRB    LR, [R10,#ZoneHead+BitSize]
d1033 5
a1037 5
	LDRB	R10,[R10,#ZoneHead+SectorSize]	; log2 sector size
	SUBS	LR,LR,R10		; get overall shift
	RSBMI	LR,LR,#0		; if -ve shift then convert to +ve shift in other
	MOVMI	R0,R0,LSR LR		; ...direction
	MOVPL	R0,R0,LSL LR		; ...otherwise just do it
d1075 6
a1080 6
	LDRB	LR,[R10,#ZoneHead+SectorSize]	; get lg2 sector size
        LDRB    R1, [R10,#ZoneHead+BitSize]	; scale from sectors to map bits...
	SUBS	R1,R1,LR			; ...taking account of shift direction
	RSBMI	R1,R1,#0                        ;
	MOVPL	R0,R0,LSR R1                    ;
	MOVMI	R0,R0,LSL R1                    ;
d1083 1
a1083 1
        LDRB    R1, [R10,#ZoneHead+BitSize]	;scale from bytes to map bits
d1087 2
a1088 2
        ADD     R0, R0, #Zone0Bits            	;adjust for zone 0
        LDRB    R1, [R10,#ZoneHead+SectorSize]
d1090 2
a1091 2
        MOV     R1, R3, LSL R1                	;total bits in a zone map
        LDR     R3, [R10,#ZoneHead+ZoneSpare-2]
d1093 1
a1093 1
        SUB     R1, R1, R3                    	;map bits actually used in a zone map
d1095 3
a1097 3
        BL      Divide                        	;(R0,R1->R0,R1)
        MOV     LR, R0                        	;zone
        MLA     R11,R3, R0, R11               	;add zone*spare, for non map bits
d1130 1
a1130 1
        LDRB    R1, [R10,#ZoneHead+BitSize]	;scale from bytes to map bits
d1133 2
a1134 2
        ADD     R0, R0, #Zone0Bits            	;adjust for zone 0
        LDRB    R1, [R10,#ZoneHead+SectorSize]
d1136 2
a1137 2
        MOV     R1, R3, LSL R1                	;total bits in a zone map
        LDR     R3, [R10,#ZoneHead+ZoneSpare-2]
d1139 1
a1139 1
        SUB     R1, R1, R3                    	;map bits actually used in a zone map
d1141 3
a1143 3
        BL      Divide                        	;(R0,R1->R0,R1)
        MOV     LR, R0                        	;zone
        MLA     R11,R3, R0, R11               	;add zone*spare, for non map bits
d1265 1
a1265 1
        LDRB    LR, [R10,#ZoneHead+BitSize]
d1297 1
a1297 1
        BL	FreeRdLinkBits  ;(R10,R11->R8)
d1303 1
a1303 1
        LDRB    R8, [R10,#ZoneHead+SectorSize]
d1306 2
a1307 2
        ASSERT  ZoneSpare :MOD: 4 = 2
        LDR     R8, [R10, #ZoneHead + ZoneSpare-2]
d1339 1
a1339 1
        LDRB    R11,[R10,#ZoneHead+SectorSize]
d1368 1
a1368 1
 	Push	"R0,R8,LR"
d1398 1
a1398 1
 	Pull	"R0,R8,PC"
d1404 1
a1404 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d1408 1
a1408 1
        LDRB    R8, [R10,#ZoneHead+Zones]
d1410 2
a1411 2
 	LDRB	R0, [R10,#ZoneHead+Zones2]
 	ADD	R8, R8, R0, LSL #8
d1445 1
a1445 1
 	Push	"R0,R8,LR"
d1475 1
a1475 1
 	Pull	"R0,R8,PC"
d1512 1
a1512 1
        LDRB    R7, [R10,#ZoneHead+LinkBits]
d1569 4
a1572 4
        LDRB    R7, [R10,#ZoneHead+LinkBits]
        CMP	r7, #MaxFreeLinkBits
        MOVHI	r7, #MaxFreeLinkBits
        B	%BT10		; jump to common code
d1599 4
a1602 4
        LDRB    R7, [R10,#ZoneHead+LinkBits]
        CMP	r7, #MaxFreeLinkBits
        MOVHI	r7, #MaxFreeLinkBits
        B	%FT03
d1632 1
a1632 1
        LDRB    R7, [R10,#ZoneHead+LinkBits]
d1704 1
a1704 1
; R2 = LinkBits
d1713 2
a1714 2
        CMP	r2, #MaxFreeLinkBits
        MOVHI	r7, #MaxFreeLinkBits
d1725 1
a1725 1
; R2 = LinkBits
d1772 3
a1774 3
        LDRB    LR, [R10,#ZoneHead+LinkBits]
        CMP	LR, #MaxFreeLinkBits
        MOVHI	LR, #MaxFreeLinkBits
d1818 1
a1818 1
        LDRB    LR, [R10,#ZoneHead+LinkBits]
d1833 1
a1833 1
; r2 = LinkBits
d1856 3
a1858 3
        CMP	r2, #MaxFreeLinkBits
        MOVHI	lr, #MaxFreeLinkBits
        MOVLS	lr, r2
d1874 1
a1874 1
; r2 = LinkBits
d1936 1
a1936 1
        LDRB    LR, [R10,#ZoneHead+LinkBits]
d1995 1
a1995 1
        LDRB    LR, [R10,#ZoneHead+LinkBits]
d2010 1
a2010 1
; r2  LinkBits
d2024 2
a2025 2
        CMP	r2, #MaxFreeLinkBits
        MOVHI	LR, #MaxFreeLinkBits
d2038 1
a2038 1
; r2  LinkBits
d2088 1
a2088 1
        LDRB    R2, [R10,#ZoneHead+LinkBits]    ;form mask for clearing
d2138 1
a2138 1
        LDRB    R2, [R10,#ZoneHead+LinkBits]    ;form mask for clearing
d2152 1
a2152 1
; r2  LinkBits
d2166 1
a2166 1
        DREG    R2, ", LinkBits:",cc
d2180 1
a2180 1
; r2  LinkBits
d2190 1
a2190 1
        DREG    R2, ", LinkBits:",cc
d2195 1
a2195 1
        MOVHI	r2,#MaxFreeLinkBits
d2237 1
a2237 1
        LDRB    R0, [R10,#ZoneHead+SectorSize]
d2240 1
a2240 1
        LDR     R1, [R10,#ZoneHead+ZoneSpare-2]
d2242 1
a2242 1
        LDRB    R1, [R10,#ZoneHead+LinkBits]
d2283 1
a2283 1
        TEQS    R0, #2			; ?? special case for id=2 (defective sectors) ??
d2296 1
a2296 1
50      LDRB    R0, [R10,#ZoneHead+Zones]
d2298 1
a2298 1
        LDRB    R1, [R10,#ZoneHead+Zones2]
d2342 2
a2343 2
	TEQS	R11,R9          ;is this map obj a gap?
	BEQ	%FT15		; gap
d2345 1
a2345 1
	; not gap
d2354 1
a2354 1
	BL	FragRdLenBits	; length
d2358 1
a2358 1
	B	%FT16
d2360 4
a2363 4
15	; it was a gap
	BL	FreeRdLinkBits  ;(R11->R8,Z)
	ADD	R9,R9,R8	;next gap pointer
	BL	FreeRdLenBits	; length
d2368 1
a2368 1
16	; re-join here
d2445 1
a2445 1
        LDRB    R0, [R10,#ZoneHead+SectorSize]
d2522 1
a2522 1
        BLNE	FreeRdLenBits   ;(R10,R11->R7)
d2566 1
a2566 1
        BLNE	FreeRdLenBits   ;(R10,R11->R7)
d2734 2
a2735 2
 	BL	TestBigDir	;test for big-dir ness
 	BEQ	%FT99
d2762 3
a2764 3
 	BL	GetDirFirstEntry
	SUB	R4, R4, #BigDirEntrySize
	B	%FT10
d2772 2
a2773 2
	ADD	R4, R4, #BigDirEntrySize
	BL	BigDirFinished
d2775 1
a2775 1
        TOGPSR	Z_bit,LR
d2777 1
a2777 1
        B	%BT95
d2797 1
a2797 1
        LDRB    R0, [R10,#ZoneHead+Zones]
d2799 2
a2800 2
 	LDRB	LR, [R10,#ZoneHead+Zones2]
 	ADD	R0, R0, LR, LSL #8
d2802 1
a2802 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d2821 1
a2821 1
        LDRB    R0, [R10,#ZoneHead+Zones]
d2823 2
a2824 2
 	LDRB	LR, [R10,#ZoneHead+Zones2]
 	ADD	R0, R0, LR, LSL #8
d2826 1
a2826 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d2847 2
a2848 2
        LDRB    R0, [R10,#ZoneHead+SectorSize]
        LDRB    LR, [R10,#ZoneHead+BitSize]
d2871 2
a2872 2
        LDRB    R0, [R10,#ZoneHead+SectorSize]
        LDRB    LR, [R10,#ZoneHead+BitSize]
d2897 1
a2897 1
        LDRB    R1, [R10,#ZoneHead+LinkBits]
@


4.6
log
@  32-bit fixes
Detail:
  Some stack offsets were wrong - now fixed.
  More PSR preservation added.
Admin:
  26-bit builds of this module still stiff the machine when ADFS is
    used.
  Do not use - except for testing.

Version 3.24. Tagged as 'FileCore-3_24'
@
text
@d1517 1
d1519 1
d1640 1
d1642 1
d1649 3
d1670 7
d1764 1
d1766 1
d1810 1
d1812 1
d1848 1
d1850 1
d1893 1
d1895 1
d2092 1
d2094 1
@


4.5
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@a1292 1
        SavePSR R7
d1295 1
d2493 1
a2493 1
        STR     R11,[sp, #11*4] ;map ptr of obj is first gap found
@


4.4
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@a22 2
 [ NewFs

d117 1
a117 1
        Pull    "R0,R1,R3,R5,R6,R10,R11,PC",,^
a266 1
 [ FileCache
a272 5
 |
        STR     R4, LastFilePtr
        STR     R11,LastMapPtr
        STR     R2, LastIndDiscAdd
 ]
d286 1
a286 1
        Pull    "R0,R3-R8,PC",,^
d684 1
a684 1
	Pull	"R0,R1,PC",,^
d686 1
a686 1
        Pull    "R0,PC",,^
d774 1
a774 1
        Pull    "PC",,^
d796 2
a797 1
        Push    "R1,LR"
d808 2
a809 1
        Pull    "R1,PC",,^
d831 2
a832 1
        Push    "R1,LR"
d862 2
a863 1
        Push    "R1,LR"
d904 1
a904 1
        Pull    "R0,R1,PC",,^
d919 1
a919 1
        BL      DiscAddToRec            ;(R3->LR)
d928 1
a928 1
        Pull    "R0,PC",,^
d985 1
a985 1
        Pull    "R10,PC",,^
d1047 1
a1047 1
        Pull    "R10,R11,PC",,^
d1177 1
a1177 1
        MOVS    PC,LR
d1259 1
d1261 1
a1261 1
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
d1263 1
a1263 1
        BLNE    RdLenBits       ;(R10,R11->R7)
d1265 5
a1269 4
        LDRNEB  LR, [R10,#ZoneHead+BitSize]
        MOVNE   R7, R7, LSL LR  ;convert length from map bits to bytes
        BLNE    MapPtrToDiscAdd ;(R3,R10,R11->R0)
        MOVNE   R8, R0
a1288 1
 [ Module_Version >= 207
a1289 3
 |
; LR  map bit of start of next zone
 ]
d1293 1
d1295 1
a1295 1
        Push    "R11"
a1301 1
 [ Module_Version >= 207
a1308 7
 |
        SUB     R11, R11, #FreeLink*8
        LDRB    R8, [R10,#ZoneHead+SectorSize]
        MOV     LR, #8
        ADD     LR, R11,LR, LSL R8
        ADD     R11,R11,#ZoneHead*8
 ]
d1323 2
a1324 1
        Pull    "R8,PC",,^
d1349 1
a1349 1
        MOVS    PC,LR
d1501 2
a1502 1
        Push    "R0-R2,LR"
d1556 2
a1557 1
        Push    "R0-R2,LR"
d1585 2
a1586 1
        Push    "R0-R2,LR"
d1618 2
a1619 1
        Push    "R0-R2,LR"
d1667 2
a1668 1
        Pull    "R0-R2,PC",,^
d1697 2
a1698 1
        Push    "R0-R2,LR"
a1705 1
 [ Module_Version >= 209
d1721 2
a1722 1
        Push    "R0-R2,LR"
a1724 1
 ]
a1848 1
 [ Module_Version >= 209
a1885 1
 ]
d1901 2
a1902 1
        Push    "R0-R5,LR"
d1931 1
a1931 1
        Pull    "R0-R5,PC",LS,^         ;done if all in this word
d1945 3
a1947 1
        Pull    "R0-R5,PC",,^
d1960 2
a1961 1
        Push    "R0-R5,LR"
d1993 2
a1994 1
        Push    "R0-R5,LR"
d2026 2
a2027 1
        Push    "R0-R5,LR"
d2052 2
a2053 1
        Push    "R1-R5,LR"
d2085 2
a2086 1
        Pull    "R1-R5,PC",,^
d2100 2
a2101 1
        Push    "R1-R5,LR"
d2137 2
a2138 1
        Push    "R1-R5,LR"
d2161 2
a2162 1
        Push    "R1-R5,LR"
d2184 2
a2185 1
        Push    "R0,LR"
d2199 2
a2200 1
        Pull    "R0,PC",,^
d2227 1
a2227 1
        Pull    "R0,PC",,^
d2241 2
a2242 1
        Push    "R1,LR"
d2259 11
d2271 2
a2272 2
        TEQS    R0, #2			; ?? special case for id=2 (defective sectors) ??
        LDREQB  R0, [R10,#ZoneHead+Zones]
d2274 2
a2275 2
 	LDREQB	R1, [R10,#ZoneHead+Zones2]
 	ADDEQ	R0, R0, R1, LSL #8
d2277 1
a2277 3
        MOVEQ   R0, R0, LSR #1
        BLNE    IdsPerZone              ;(R10->R1)
        BLNE    Divide                  ;(R0,R1->R0,R1)
d2282 2
a2283 1
        Pull    "R1,PC",,^
d2384 1
a2384 1
        Pull    "R0-R3,R6-R9,R11,PC",,^
d2411 2
a2412 1
        Push    "R0,LR"
d2435 2
a2436 1
        Pull    "R0,PC",,^
d2471 2
d2493 1
a2493 1
        STR     R11,[sp, #10*4] ;map ptr of obj is first gap found
d2596 3
a2598 1
        Pull    "R0-R9,R11,PC",,^
d2676 1
a2676 1
        Pull    "R0,R1,R4-R8,R11,PC",,^
d2767 1
a2767 1
        Push    "R0,R1,LR"
d2785 1
a2785 1
        Pull    "R0,R1,PC",,^
d2811 1
a2811 1
        Pull    "R0,PC",,^
d2835 1
a2835 1
        Pull    "R0,PC",,^
d2859 1
a2859 1
        Pull    "R0,PC",,^
d2885 1
a2885 3
        Pull    "R0,R1,PC",,^

 ]
@


4.3
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d17 3
d69 1
a69 1
 [ BigShare
d72 1
a72 1
 ]
d74 1
a74 1
        ADDNE   R5, R5, R0, LSL R6
d206 3
d210 1
d223 13
d241 1
d252 6
d317 5
d323 1
d418 5
d425 1
d495 12
d511 1
d522 6
d602 12
d618 1
d629 6
d1169 3
d1174 1
d1206 3
d1211 1
d1263 3
d1267 1
d1301 3
d1305 1
d1379 3
d1383 1
d1389 3
d1393 1
d1409 3
d1413 1
d1421 4
d1429 3
d1433 1
d1441 56
d1508 3
d1512 1
d1515 3
d1519 1
d1524 3
d1553 58
d1622 3
d1626 1
d1629 3
d1633 1
d1639 3
d1691 21
d1723 3
d1727 1
d1733 42
d1785 3
a1787 1

d1789 1
d1792 3
d1796 1
d1816 40
d1868 3
d1872 1
d1896 1
d1905 3
d1909 1
d1912 3
d1916 1
d1955 58
d2024 4
d2029 1
a2040 1

d2050 3
d2054 1
d2057 3
d2061 1
d2089 32
d2132 3
d2136 24
d2168 3
d2172 1
d2191 3
d2195 1
d2246 4
d2252 1
d2257 4
d2301 31
d2348 1
d2456 4
d2462 1
d2469 3
d2473 1
d2478 3
d2482 1
d2489 3
d2493 1
d2499 3
d2503 1
d2522 4
d2528 1
d2535 4
d2541 1
d2558 3
d2562 1
d2602 5
d2609 1
d2617 3
d2621 1
d2632 4
d2638 1
d2644 3
d2648 1
d2651 1
d2688 4
d2715 19
d2753 4
d2777 4
@


4.2
log
@Version Spin_merge taken
@
text
@d1202 1
a1202 1
 [ Version >= 207
d1214 1
a1214 1
 [ Version >= 207
d1442 1
a1442 1
 [ Version >= 209
d1493 1
a1493 1
 [ Version >= 209
@


4.2.2.1
log
@Changes made to FileCore to support allowing idlen more than 15.  This allows
smaller LFAUs on discs.  The changes are not yet complete.  In particular, the
number of disc zones is limited to 255.  Some development testing has been
peformed, and the filing system is generally stable.  Areas which haven't
been fully tested include things like *Defect, FileCore_LayoutStructure,
FileCore_FloppyStructure, and the FileSwitch APIs for reading and examining
a disc's used space.

This version should not be used for any OS Builds with the BigMaps flag set
to true.  It should build as a normal version of FileCore with BigMaps and
BigDirs set to false.
@
text
@a16 3
; 15 May 1997 SBP: Added Free versions of all the RdLenBits and WrLenBits etc functions.  Modified UnusedId,
;                  NextFree, ChainClaim, ShortenFrag, InitZoneObj.
;
a68 14

 [ BigMaps :LAND: {FALSE}               ; this special case is no longer used
	BIC	r6,r2,#DiscBits
 	CMP	r6, #2<<8		; is it object id 2?
 	BNE	%FT10                   ;  no.
 	
 	LDRB	r6, [LR, #LinkBits]	; get the LinkBits
 	CMP	r6, #15			; is it more than 15
 	BLS	%FT10			;  no.
 	
 	LDRB	r6, [LR, #Zones]	; get number of zones
 	ADD	r0, r0, r6, LSL #1	; and add double thid to offset
10
 ]
d71 1
a71 1
        ADD     R5, R5, R0, LSL R6
a202 3
 [ BigMaps
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
 |
a203 1
 ]
a215 13
 [ BigMaps
 	TEQS	R11, R9		; if gap
 	BNE	%FT27
 	
 ; gap
        BL	FreeRdLenLinkBits ; read free link
        MOV	r3,r9		;  and just update gap before frag
        ADD	r9,r9,r8        ;  and gap after frag
        B	%FT30		;
27
 ; not gap
 	BL	FragRdLenLinkBits ; get the length
 |
a220 1
 ]
a455 12
 [ BigMaps
        TEQ	R11, R9
        BNE	%FT16		; gap?
        
        BL	FreeRdLenLinkBits ; gap
        ADD	r9,r11,r8
        B	%ft20
        
16 				; not gap
	BL	FragRdLenLinkBits	; just read the object
	
 |
a459 1
 ]
a543 12
 [ BigMaps
        TEQ	R11, R9
        BNE	%FT16		; gap?
        
        BL	FreeRdLenLinkBits ; gap
        ADD	r9,r11,r8
        B	%ft20
        
16 				; not gap
	BL	FragRdLenLinkBits	; just read the object
	
 |
a547 1
 ]
a1177 3
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
a1178 1
 ]
a1211 3
 [ BigMaps
        BL	FreeRdLinkBits  ;(R10,R11->R8)
 |       
a1212 1
 ]
a1291 3
 [ BigMaps
        BL      FreeRdLinkBits              ;(R10,R11->R8,Z)
 |
a1292 1
 ]
a1319 3
 [ BigMaps
        BL      FreeRdLinkBits              ;(R10,R11->R8,Z)
 |
a1320 1
 ]
a1327 1

a1338 3
 [ BigMaps
FragRdLenLinkBits ROUT
 |
a1339 1
 ]
a1341 3
 [ BigMaps
        DREG    R10, "FragRdLenLinkBits(map:",cc
 |
a1342 1
 ]
a1346 3
 [ BigMaps
10
 ]
a1372 58
 [ BigMaps
; =============
; FreeRdLenLinkBits
; =============

;entry
; R10 -> new map start
; R11 bit ptr to map obj (must be a free space)
;exit
; R7 len bits
; R8 link bits

FreeRdLenLinkBits

        Push    "R0-R2,LR"
 [ DebugEx
 [ BigMaps
        DREG    R10, "FreeRdLenLinkBits(map:",cc
 |
        DREG    R10, "RdLenLinkBits(map:",cc
 ]
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        LDRB    R7, [R10,#ZoneHead+LinkBits]
        CMP	r7, #MaxFreeLinkBits
        MOVHI	r7, #MaxFreeLinkBits
        B	%BT10		; jump to common code
 ]

 [ BigMaps
; =============
; FreeRdLenBits
; =============

;entry
; R10 -> new map start
; R11 bit ptr to map obj (must be free space)
;exit
; R7 len bits

FreeRdLenBits
        Push    "R0-R2,LR"
 [ DebugEx
 [ BigMaps
        DREG    R10, "FreeRdLenBits(map:",cc
 |
        DREG    R10, "RdLenBits(map:",cc
 ]
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
02
        LDRB    R7, [R10,#ZoneHead+LinkBits]
        CMP	r7, #MaxFreeLinkBits
        MOVHI	r7, #MaxFreeLinkBits
        B	%FT03
 ]
a1383 3
 [ BigMaps
FragRdLenBits
 |
a1384 1
 ]
a1386 3
 [ BigMaps
        DREG    R10, "FragRdLenBits(map:",cc
 |
a1387 1
 ]
a1392 3
 [ BigMaps
03
 ]
a1441 21
 [ BigMaps
; ======================
; FreePrimitiveRdLenBits
; ======================

;entry
; R2 = LinkBits
; R10 -> new map start
; R11 bit ptr to map obj (must be free space)
;exit
; R7 len bits

PrimitiveFreeRdLenBits
        Push    "R0-R2,LR"
        CMP	r2, #MaxFreeLinkBits
        MOVHI	r7, #MaxFreeLinkBits
        MOVLS   R7, R2
        B       %B02
 
 ]

a1452 3
 [ BigMaps
PrimitiveFragRdLenBits
 |
a1453 1
 ]
a1458 42
 [ BigMaps

; ==============
; FreeRdLinkBits
; ==============

;entry
; R10 -> new map start
; R11 bit ptr to map obj, must be free space
;exit
; R8 link bits, Z set if 0

FreeRdLinkBits ROUT
        Push    "R0,LR"
 [ DebugEx
 [ BigMaps
        DREG    R10, "FreeRdLinkBits(map:",cc
 |
        DREG    R10, "RdLinkBits(map:",cc
 ]
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        ADD     LR, R10,R11,LSR #3
        BIC     LR, LR,#3
        LDMIA   LR, {R8,LR}
        ANDS    R0, R11,#31
        MOVNE   R8, R8, LSR R0
        RSBNE   R0, R0, #32
        ORRNE   R8, R8, LR, LSL R0
        LDRB    LR, [R10,#ZoneHead+LinkBits]
        CMP	LR, #MaxFreeLinkBits
        MOVHI	LR, #MaxFreeLinkBits
        MOV     R0, R8, LSR LR
        SUBS    R8, R8, R0, LSL LR
 [ DebugEx
        DREG    R8, "<-RdLinkBits(link:",cc
        DLINE   ")"
 ]
        Pull    "R0,PC"
 
 ]
d1469 1
a1469 3
 [ BigMaps
FragRdLinkBits ROUT
 |
a1470 1
 ]
a1472 3
 [ BigMaps
        DREG    R10, "FragRdLinkBits(map:",cc
 |
a1473 1
 ]
a1492 40
 [ BigMaps
; =======================
; FreePrimitiveRdLinkBits
; =======================

;entry
; r2 = LinkBits
; R10 -> new map start
; R11 bit ptr to map obj, must be free space
;exit
; R8 link bits, Z set if 0

PrimitiveFreeRdLinkBits ROUT
        Push    "R0,LR"
 [ DebugEx
        DREG    R2, "PrimitiveRdLinkBits(LinkBits:",cc
        DREG    R10, ", map:",cc
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
        ADD     LR, R10,R11,LSR #3
        BIC     LR, LR,#3
        LDMIA   LR, {R8,LR}
        ANDS    R0, R11,#31
        MOVNE   R8, R8, LSR R0
        RSBNE   R0, R0, #32
        ORRNE   R8, R8, LR, LSL R0
        CMP	r2, #MaxFreeLinkBits
        MOVHI	lr, #MaxFreeLinkBits
        MOVLS	lr, r2
        MOV     R0, R8, LSR lr
        SUBS    R8, R8, R0, LSL lr
 [ DebugEx
        DREG    R8, "<-PrimitiveRdLinkBits(link:",cc
        DLINE   ")"
 ]
        Pull    "R0,PC"
 ]


a1504 3
 [ BigMaps
PrimitiveFragRdLinkBits ROUT
 |
a1505 1
 ]
a1528 1

a1536 3
 [ BigMaps
FragWrLenBits ROUT
 |
a1537 1
 ]
a1539 3
 [ BigMaps
        DREG    R0, "FragWrLenBits(len:",cc
 |
a1540 1
 ]
a1578 58
 [ BigMaps
 
; =============
; FreeWrLenBits
; =============

;R0  len in bits
;R1  map ptr, must be free space
;R10 -> map start

FreeWrLenBits
        Push    "R0-R5,LR"
 [ DebugE
 [ BigMaps
        DREG    R0, "FreeWrLenBits(len:",cc 
 |
        DREG    R0, "WrLenBits(len:",cc
 ]
        DREG    R1, ", map ptr:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        BL      MarkZone        ;(R1,R10)
        LDRB    LR, [R10,#ZoneHead+LinkBits]
        CMP     LR, #MaxFreeLinkBits
        MOVHI   LR, #MaxFreeLinkBits
        B       %bt10
 ]

 [ BigMaps

; ======================
; FreePrimitiveWrLenBits
; ======================

;entry
; R0  next bits
; R1  map ptr, must be free space
; r2  LinkBits
; R10 -> map start

; As WrLenBits, but doesn't mark the zone
PrimitiveFreeWrLenBits
        Push    "R0-R5,LR"
 [ DebugE
        DREG    R0, "PrimitiveWrLenBits(len:",cc
        DREG    R1, ", map ptr:",cc
        DREG    R2, ", LinkBits:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]      
        CMP	r2, #MaxFreeLinkBits
        MOVHI	LR, #MaxFreeLinkBits
        MOVLS   LR, R2
        B       %BT10

 ]

a1589 4

 [ BigMaps
PrimitiveFragWrLenBits
 |
a1590 1
 ]
d1602 1
a1611 3
 [ BigMaps
FragWrLinkBits ROUT
 |
a1612 1
 ]
a1614 3
  [ BigMaps
        DREG    R0, "FragWrLinkBits(link:",cc
  |
a1615 1
  ]
a1642 32
 [ BigMaps

; ==============
; FreeWrLinkBits
; ==============

;entry
; R0  next bits
; R1  map ptr, must be free space
; R10 -> map start

FreeWrLinkBits
        Push    "R1-R5,LR"
 [ DebugE
 [ BigMaps
        DREG    R0, "FreeWrLinkBits(link:",cc
 |
        DREG    R0, "WrLinkBits(link:",cc
 ]
        DREG    R1, ", map ptr:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        BL      MarkZone                ;(R1,R10)

        LDRB    R2, [R10,#ZoneHead+LinkBits]    ;form mask for clearing
        CMP     r2, #MaxFreeLinkBits
        MOVHI   r2, #MaxFreeLinkBits
        B       %BT10
 ]


a1653 3
 [ BigMaps
PrimitiveFragWrLinkBits
 |
a1654 24
 ]
        Push    "R1-R5,LR"
 [ DebugE
        DREG    R0, "PrimitiveWrLinkBits(link:",cc
        DREG    R1, ", map ptr:",cc
        DREG    R2, ", LinkBits:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        B       %BT10

 [ BigMaps
; =======================
; PrimitiveFreeWrLinkBits
; =======================

;entry
; R0  next bits
; R1  map ptr, must be free space
; r2  LinkBits
; R10 -> map start

; As FreeWrLinkBits, but doesn't mark the zone
PrimitiveFreeWrLinkBits
a1662 3
        CMP     r2,#MaxFreeLinkBits
        MOVHI	r2,#MaxFreeLinkBits
        
a1663 1
 ]
a1681 3
 [ BigMaps
        BL      FreeWrLinkBits      ;(R0,R1,R10)
 |
a1682 1
 ]
a1732 4
 [ BigMaps
        MOV     R0, R0, LSL #3
        MOV     R0, R0, LSR #3+8      ;just id bits left
 |
a1734 1
 ]
a1778 31

 [ BigMaps
	TEQS	R11,R9          ;is this map obj a gap?
	BEQ	%FT15		; gap
	
	; not gap
        BL      FragRdLinkBits  ;(R11->R8,Z)
        SUBS    LR, R8, R6
        CMPHSS  R2, R8
        ADDHI   R8, R0, LR, LSR #3
        ANDHI   LR, LR, #7
        LDRHIB  R7, [R8]
        ORRHI   R7, R7, R1, LSL LR
        STRHIB  R7, [R8]
	BL	FragRdLenBits	; length
        ADD     R11,R11,R7
        CMPS    R11,R3
        BLO     %BT10           ;loop while more frags in zone
	B	%FT16
	
15	; it was a gap
	BL	FreeRdLinkBits  ;(R11->R8,Z)
	ADD	R9,R9,R8	;next gap pointer
	BL	FreeRdLenBits	; length
        ADD     R11,R11,R7
        CMPS    R11,R3
        BLO     %BT10           ;loop while more frags in zone

16	; re-join here
	
 |
a1794 1
 ]
a1901 4
 [ BigMaps
        MOV     R2, R2, LSL #3
        MOV     R2, R2, LSR #3+8
 |
a1903 1
 ]
a1909 3
 [ BigMaps
        BLNE    FreeRdLenBits       ;(R10,R11->R7)
 |
a1910 1
 ]
a1914 3
 [ BigMaps
        BLNE	FreeRdLenBits   ;(R10,R11->R7)
 |
a1915 1
 ]
a1921 3
 [ BigMaps
        BL      FreeWrLinkBits      ;mark end of free chain in previous zone
 |
a1922 1
 ]
a1927 3
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
a1928 1
 ]
a1946 4
 [ BigMaps
        BLNE	FreeRdLenBits   ;(R10,R11->R7)
        BL      FragWrLinkBits  ;(R0,R1,R10) set fragment link bits
 |
a1948 1
 ]
a1954 4
 [ BigMaps
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
        BL      FragWrLinkBits  ;(R0,R1,R10) set fragment link bits
 |
a1956 1
 ]
a1972 3
 [ BigMaps
        BLHS    FragWrLenBits
 |
a1973 1
 ]
a2012 5
 [ BigMaps
 ; R3 is a gap so we're working in Free spaces
        BL      FreeRdLenBits       ;(R10,R11->R7)
        BL      FreeRdLinkBits      ;(R10,R11->R8,Z)
 |
a2014 1
 ]
a2021 3
 [ BigMaps
        BLNE    FragWrLenBits   ;(R0,R1,R10)
 |
a2022 1
 ]
a2032 4
 [ BigMaps
        BL      FreeRdLenBits   ;(R10,R11->R7)
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
 |
a2034 1
 ]
a2039 3
 [ BigMaps
        BL      FreeWrLenBits   ;(R0,R1,R10) set gap length
 |
a2040 1
 ]
a2042 1
 
@


4.2.2.2
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@d69 1
a69 1
  [ BigShare
d72 15
a86 1
  ]
a324 5
 [ BigMaps
        LDRB    R9, [R5, #Zones]
        LDRB	R7, [R5, #Zones2]
        ADD	R9, R9, R7, LSL #8
 |
a325 1
 ]
@


4.2.2.3
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@a251 6
 [ BigMaps
 	Push	"R0"
 	LDRB	R0, [R10,#ZoneHead+Zones2]
 	ADD	LR, LR, R0, LSL #8
 	Pull	"R0"
 ]
a509 6
 [ BigMaps
 	Push	"R0"
 	LDRB	R0, [R10, #ZoneHead+Zones2]
 	ADD	LR, LR, R0, LSL #8
 	Pull	"R0"
 ]
a610 6
 [ BigMaps
 	Push	"R0"
 	LDRB	r0, [R10, #ZoneHead+Zones2]
 	ADD	lr, lr, r0, LSL #8
 	Pull	"R0"
 ]
a1346 3
 [ BigMaps
 	Push	"R0,R8,LR"
 |
a1347 1
 ]
a1372 3
 [ BigMaps
 	Pull	"R0,R8,PC"
 |
a1373 1
 ]
a1380 4
 [ BigMaps
 	LDRB	R0, [R10,#ZoneHead+Zones2]
 	ADD	R8, R8, R0, LSL #8
 ]
a2157 4
 [ BigMaps
 	LDREQB	R1, [R10,#ZoneHead+Zones2]
 	ADDEQ	R0, R0, R1, LSL #8
 ]
a2584 4
 [ BigDir
 	BL	TestBigDir	;test for big-dir ness
 	BEQ	%FT99
 ]
a2607 17
 [ BigDir
99
 	BL	GetDirFirstEntry
05
        TEQS    R4, R0
        BEQ     %FT10
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        TEQS    R1, LR, LSR #8
        BEQ     %BT95           ;sharing with file
10
	ADD	R4, R4, #BigDirEntrySize
	BL	BigDirFinished
        BNE     %BT05           ;loop while more dir entries
        TOGPSR	Z_bit,LR
                        ;NE if no sharers
        B	%BT95
 ]
a2626 4
 [ BigMaps
 	LDRB	LR, [R10,#ZoneHead+Zones2]
 	ADD	R0, R0, LR, LSL #8
 ]
a2646 4
 [ BigMaps
 	LDRB	LR, [R10,#ZoneHead+Zones2]
 	ADD	R0, R0, LR, LSL #8
 ]
@


4.2.2.4
log
@Fixed s.BigDirCode (GrowBigDir and ShrinkBigDir) to cope with BitSize<SecSize
and rewrote free space map memory management to place free space maps in
dynamic areas.
@
text
@a417 5
 [ DynamicMaps
 	LDR	LR, [R6, #DrvsFsMapFlags]
 	ORR	LR, LR, #BadFs
 	STR	LR, [R6, #DrvsFsMapFlags]
 |
a419 1
 ]
a1162 3
 [ DynamicMaps
        LDR     R10,[R10,#DrvsFsMapAddr]
 |
a1164 1
 ]
a1195 3
 [ DynamicMaps
        LDR     R10,[R10,#DrvsFsMapAddr]
 |
a1197 1
 ]
@


4.2.2.5
log
@Two bugs fixed:

1) Fixed ReallyShared so that it doesn't omit to check the first
   object in the directory being scanned.

2) Fixed a long-standing ADFSBuffers problem.  This involves the
   UpdateBufState function attempting to attach a buffer as the
   Older or Younger buffer of the previous or next buffer in a
   file respectively.  Unfortunately, if there's only one buffer
   for a file, then it may attempt to attach it to the file
   control block - which is wrong.  Modified UpdateBufState to
   only attempt this when there are more than one objects in
   the chain.  Note:  there still may be problems in certain
   cases; this may need further looking into.

   This problem probably doesn't occur without long file names
   support enabled, because the fcb's contents look different
   then (name field is 10 chars instead of 256) so the problem
   is less likely to occur accidentally.
@
text
@d226 1
a226 1

d498 1
a498 1

d502 1
a502 1

d505 1
a505 1

d605 1
a605 1

d609 1
a609 1

d612 1
a612 1

d1303 1
a1303 1
 |
d1654 1
a1654 1

d1718 1
a1718 1

d1901 1
a1901 1

d1914 1
a1914 1
        DREG    R0, "FreeWrLenBits(len:",cc
d1950 1
a1950 1
 ]
d2115 1
a2115 1

d2250 1
a2250 1

d2265 1
a2265 1

d2275 1
a2275 1

d2596 1
a2596 1

a2662 2
	SUB	R4, R4, #BigDirEntrySize
	B	%FT10
@


4.2.2.6
log
@Found a major inefficiency in the handling of file creation, closing of files
and other uses of the NextFree function.  In the case of file creation, the
problem was particularly bad on large free space maps, as the function was
of order N^2 on the size of the map, when the disc was nearly full.  As the
disc gets fuller, the problem gets worse; with 1400 zones in the map, N^2
is very large indeed.  This resulted in *cdir sometimes taking 1sec.

Now, a new function NextFree_Quick exists which performs similarly to NextFree,
but does not consider free spaces in zones beyond the current zone.  This
can be used by functions which need only examine free spaces in a given zone,
such as is the case in ClaimFreeSpace where it is stepping throigh zones to
find a single gap large enough for the entire file.

For other functions which work on a single zone, the speedup is less dramatic,
of the order N instead of N^2.
@
text
@a1441 55
; ==============
; NextFree_Quick
; ==============

;entry
; R10 -> map start
; R11 map ptr to space

;exit
; C set <=> exhausted or started new zone
; R9  map ptr to predecessor of next space
; R11 map ptr to next space, unless started new zone or exhausted

NextFree_Quick ROUT
 [ BigMaps
 	Push	"R0,R8,LR"
 |
        Push    "R8,LR"
 ]
 [ DebugE
        DREG    R10, "NextFree(map:",cc
        DREG    R11, ", map ptr:",cc
        DLINE   ")"
 ]
 [ BigMaps
        BL      FreeRdLinkBits              ;(R10,R11->R8,Z)
 |
        BL      RdLinkBits              ;(R10,R11->R8,Z)
 ]
        BEQ     %FT10                   ;zone done
        MOV     R9, R11
        ADDS    R11,R11,R8              ;Z=0, C=0
05
 [ DebugE
        DREG    R9, "<-NextFree(prev:",cc
        DREG    R11, ", this:",cc
        BCC     %FT01
        DLINE   ", next zone",cc
01
        BNE     %FT02
        DLINE   ", map end",cc
02
        DLINE   ")"
 ]
 [ BigMaps
 	Pull	"R0,R8,PC"
 |
        Pull    "R8,PC"
 ]

10
        CMPS    PC, #0                  ;Z=0, C=1
        B        %BT05


@


4.1
log
@Initial revision
@
text
@d1036 45
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a1035 45
; ===================
; ByteDiscAddToMapPtr
; ===================

;entry
; R0 disc address
; R10 ->map start
;exit
; R11 offset in map
; LR  zone number

ByteDiscAddToMapPtr ROUT
        Push    "R0,R1,R3,LR"
 [ DebugE
        DREG    R0, "ByteDiscAddToMapPtr(disc add:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        MOV     R3, R0
        BIC     R0, R0, #DiscBits

        LDRB    R1, [R10,#ZoneHead+BitSize]	;scale from bytes to map bits
        MOV     R0, R0, LSR R1

        ADD     R0, R0, #Zone0Bits            	;adjust for zone 0
        LDRB    R1, [R10,#ZoneHead+SectorSize]
        MOV     R3, #8
        MOV     R1, R3, LSL R1                	;total bits in a zone map
        LDR     R3, [R10,#ZoneHead+ZoneSpare-2]
        MOV     R3, R3, LSR #16
        SUB     R1, R1, R3                    	;map bits actually used in a zone map
        MOV     R11,R0
        BL      Divide                        	;(R0,R1->R0,R1)
        MOV     LR, R0                        	;zone
        MLA     R11,R3, R0, R11               	;add zone*spare, for non map bits
        ADD     R11,R11,#ZoneHead*8
 [ DebugE
        Push    "R0"
        DREG    R11, "<-ByteDiscAddToMapPtr(map ptr:",cc
        MOV     R0, LR
        DREG    R0, "zone:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,R1,R3,PC"
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a1035 45
; ===================
; ByteDiscAddToMapPtr
; ===================

;entry
; R0 disc address
; R10 ->map start
;exit
; R11 offset in map
; LR  zone number

ByteDiscAddToMapPtr ROUT
        Push    "R0,R1,R3,LR"
 [ DebugE
        DREG    R0, "ByteDiscAddToMapPtr(disc add:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        MOV     R3, R0
        BIC     R0, R0, #DiscBits

        LDRB    R1, [R10,#ZoneHead+BitSize]	;scale from bytes to map bits
        MOV     R0, R0, LSR R1

        ADD     R0, R0, #Zone0Bits            	;adjust for zone 0
        LDRB    R1, [R10,#ZoneHead+SectorSize]
        MOV     R3, #8
        MOV     R1, R3, LSL R1                	;total bits in a zone map
        LDR     R3, [R10,#ZoneHead+ZoneSpare-2]
        MOV     R3, R3, LSR #16
        SUB     R1, R1, R3                    	;map bits actually used in a zone map
        MOV     R11,R0
        BL      Divide                        	;(R0,R1->R0,R1)
        MOV     LR, R0                        	;zone
        MLA     R11,R3, R0, R11               	;add zone*spare, for non map bits
        ADD     R11,R11,#ZoneHead*8
 [ DebugE
        Push    "R0"
        DREG    R11, "<-ByteDiscAddToMapPtr(map ptr:",cc
        MOV     R0, LR
        DREG    R0, "zone:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,R1,R3,PC"
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a1035 45
; ===================
; ByteDiscAddToMapPtr
; ===================

;entry
; R0 disc address
; R10 ->map start
;exit
; R11 offset in map
; LR  zone number

ByteDiscAddToMapPtr ROUT
        Push    "R0,R1,R3,LR"
 [ DebugE
        DREG    R0, "ByteDiscAddToMapPtr(disc add:",cc
        DREG    R10, ", map:",cc
        DLINE   ")"
 ]
        MOV     R3, R0
        BIC     R0, R0, #DiscBits

        LDRB    R1, [R10,#ZoneHead+BitSize]	;scale from bytes to map bits
        MOV     R0, R0, LSR R1

        ADD     R0, R0, #Zone0Bits            	;adjust for zone 0
        LDRB    R1, [R10,#ZoneHead+SectorSize]
        MOV     R3, #8
        MOV     R1, R3, LSL R1                	;total bits in a zone map
        LDR     R3, [R10,#ZoneHead+ZoneSpare-2]
        MOV     R3, R3, LSR #16
        SUB     R1, R1, R3                    	;map bits actually used in a zone map
        MOV     R11,R0
        BL      Divide                        	;(R0,R1->R0,R1)
        MOV     LR, R0                        	;zone
        MLA     R11,R3, R0, R11               	;add zone*spare, for non map bits
        ADD     R11,R11,#ZoneHead*8
 [ DebugE
        Push    "R0"
        DREG    R11, "<-ByteDiscAddToMapPtr(map ptr:",cc
        MOV     R0, LR
        DREG    R0, "zone:",cc
        DLINE   ")"
        Pull    "R0"
 ]
        Pull    "R0,R1,R3,PC"
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.10;
access;
symbols
	FileCore-3_75:4.10
	FileCore-3_74:4.10
	FileCore-3_73:4.10
	FileCore-3_72:4.10
	FileCore-3_71:4.10
	FileCore-3_70:4.10
	FileCore-3_69:4.10
	FileCore-3_68:4.10
	FileCore-3_67:4.10
	FileCore-3_66:4.10
	FileCore-3_65:4.10
	FileCore-3_64:4.10
	FileCore-3_63:4.10
	FileCore-3_62:4.10
	FileCore-3_61:4.10
	FileCore-3_60:4.10
	FileCore-3_59:4.10
	FileCore-3_58:4.10
	FileCore-3_57:4.10
	FileCore-3_56:4.10
	FileCore-3_55:4.10
	FileCore-3_54:4.9
	FileCore-3_53:4.9
	FileCore-3_52:4.9
	FileCore-3_51:4.9
	FileCore-3_50:4.9
	FileCore-3_49:4.9
	FileCore-3_48:4.9
	FileCore-3_47:4.9
	FileCore-3_46:4.9
	FileCore-3_45:4.9
	FileCore-3_44:4.8
	FileCore-3_43:4.8
	FileCore-3_42:4.8
	FileCore-3_41:4.7
	FileCore-3_40:4.7
	FileCore-3_39:4.7
	FileCore-3_38:4.6
	FileCore-3_37:4.6
	FileCore-3_36:4.6
	FileCore-3_35:4.6
	FileCore-3_34:4.6
	FileCore-3_33:4.6
	RO_5_07:4.5
	FileCore-3_32:4.5
	FileCore-3_31:4.5
	FileCore-3_30:4.5
	FileCore-3_29:4.4
	FileCore-3_28:4.4
	FileCore-3_25-4_9_2_2:4.3.2.1
	FileCore-3_27:4.3
	FileCore-3_26:4.3
	FileCore-3_22-4_6_2_1:4.2
	bavison_FileCore-3_22_dev_bp:4.2
	bavison_FileCore-3_22:4.2.0.2
	FileCore-3_25-4_9_2_1:4.3.2.1
	HAL:4.3.0.2
	FileCore-3_25:4.3
	FileCore-3_24:4.3
	FileCore-3_23:4.3
	dellis_autobuild_BaseSW:4.2
	FileCore-3_22:4.2
	Ursula_merge:4.1.4.5
	ROL_merge:4.1.4.5
	FileCore-3_21:4.2
	ROL_Ursula_merge:4.1.4.5
	Ursula_RiscPC_merge:4.1.4.5
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.5
	ROL_FileCore-3_21:4.1.4.5
	ROL_FileCore-3_20:4.1.4.5
	ROL:4.1.4.5.0.4
	ROL_bp:4.1.4.5
	Ursula_RiscPC_bp:4.1.4.5
	FileCore-3_18:4.1.4.5
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.5
	Ursula_RiscPC:4.1.4.5.0.2
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1.4.5
	sproven_FileCore-3_16:4.1.4.5
	rthornb_UrsulaBuild-19Aug1998:4.1.4.5
	UrsulaBuild_FinalSoftload:4.1.4.5
	rthornb_UrsulaBuild-12Aug1998:4.1.4.5
	aglover_UrsulaBuild-05Aug1998:4.1.4.5
	rthornb_UrsulaBuild-29Jul1998:4.1.4.5
	rthornb_UrsulaBuild-22Jul1998:4.1.4.5
	rthornb_UrsulaBuild-15Jul1998:4.1.4.5
	rthornb_UrsulaBuild-07Jul1998:4.1.4.5
	rthornb_UrsulaBuild-17Jun1998:4.1.4.5
	rthornb_UrsulaBuild-03Jun1998:4.1.4.5
	rthornb_UrsulaBuild-27May1998:4.1.4.5
	rthornb_UrsulaBuild-21May1998:4.1.4.5
	sproven_FileCore-3_15:4.1.4.5
	sproven_314:4.1.4.5
	rthornb_UrsulaBuild_01May1998:4.1.4.5
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.5
	sproven_3_11:4.1.4.5
	sproven_3_10:4.1.4.5
	sproven_Ursula_3_09:4.1.4.5
	sproven_3_07:4.1.4.5
	sproven_3_06:4.1.4.4
	sproven_3_05:4.1.4.4
	sproven_3_04:4.1.4.4
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.3
	sproven_3_02:4.1.4.2
	sproven_3_01:4.1.4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2013.02.21.16.53.06;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	CCuV2tngKttj75Fw;

4.9
date	2011.10.14.07.23.50;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	D2Id4aPp4zmuUhDv;

4.8
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	A9Zxco9ydo9FCOBv;

4.7
date	2011.08.04.20.43.10;	author jlee;	state Exp;
branches;
next	4.6;
commitid	zcIknvqdwARiCeuv;

4.6
date	2009.05.17.01.48.31;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2001.05.14.16.26.35;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2001.05.10.15.10.27;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	2000.05.09.11.36.52;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.16;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2000.11.30.17.04.36;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.32.16;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.15.52;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.16.14.46.40;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.11.17.13.32.21;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.12.01.12.02.59;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	97.12.11.23.21.35;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.01.23.16.41.19;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.33.56;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.30.51;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;> FileCore05

; LEAF ROUTINES

; ======
; ClearV
; ======

ClearV
  [ No32bitCode
        BICS    PC, LR, #V_bit
  |
        Push    "LR"
        CLRPSR  V_bit, LR
        Pull    "PC"
  ]

; ====
; SetV
; ====

SetV
  [ No32bitCode
        ORRS    PC, LR, #V_bit
  |
        Push    "LR"
        SETPSR  V_bit, LR
        Pull    "PC"
  ]

; ========
; SetVOnR0
; ========

SetVOnR0
  [ No32bitCode
        CMPS    R0, #0
        BICEQS  PC, LR, #V_bit
        ORRNES  PC, LR, #V_bit
  |
        Push    "LR"
        MRS     LR, CPSR
        CMPS    R0, #0
        BICEQ   LR, LR, #V_bit
        ORRNE   LR, LR, #V_bit
        MSR     CPSR_f, LR
        Pull    "PC"
  ]


; =============
; PullLinkKeepV
; =============

PullLinkKeepV
        BICVC   LR, LR, #V_bit
        ORRVS   LR, LR, #V_bit
        RestPSR LR,,f
        Pull    "PC"


; ============
; DiscAddToRec
; ============

; entry R3 disc address
; exit LR -> disc rec

DiscAddToRec
        Push    "LR"
        MOV     LR, R3, LSR #(32-3)
        DiscRecPtr  LR,LR
        Pull    "PC"


; ======
; Divide
; ======

; entry: R0=Numerator, R1=Denominator
; exit:  R0=Result, R1=Remainder

Divide  ROUT
        Push    "R2,LR"

        MOV     LR, R1          ;temp = den
        CMPS    LR, R0, LSR #1  ;shift temp left unless it would be > num
10
        MOVLS   LR, LR, LSL #1
        CMPLS   LR, R0, LSR #1
        BLS     %BT10
        MOV     R2, #0          ;init result
20
        CMPS    R0, LR          ;if subtraction possible
        SUBCS   R0, R0, LR      ; do it
        ADC     R2, R2, R2      ;shift bit into result
        MOV     LR, LR, LSR #1  ;move temp right
        CMPS    LR, R1          ;loop if not done
        BHS     %BT20

        MOV     R1, R0          ;mod
        MOV     R0, R2          ;div

        Pull    "R2,PC"


; =========
; BlockMove
; =========

; entry: R0=source start, R1=dest start, R2=length

BlockMove ROUT
 [ Debug9          
        DLINE    ,"source  |dest    |length  - enter BlockMove"
        DREG    R0, " ",cc
        DREG    R1, " ",cc
        DREG    R2, " "
 ]
        Push    "R0-R12,LR"
        SavePSR LR
        Push    "LR"
        TEQS    R2, #0
        BEQ     %FT95
        CMPS    R1, R0
        BHI     %FT50           ;upwards move
05                      ;bytes at a time until source aligned
        TSTNE   R0, #2_11
        LDRNEB  LR, [R0], #1
        STRNEB  LR, [R1], #1
        SUBNES  R2, R2, #1
        BNE     %BT05

        ANDS    LR, R1, #2_11
        BEQ     %FT30           ;same alignment

;downwards mis-aligned move
        SUBS    R2, R2, #9*4    ;enough left to worth being clever ?
        BLO     %FT35           ;if not

        LDR     R3, [R0], #4    ;get a word from source
10
        STRB    R3, [R1], #1    ;put bytes to dest until aligned
        MOV     R3, R3, LSR #8
        TSTS    R1, #2_11
        BNE     %BT10
        MOV     LR, LR, LSL #3  ;# bits left in R3
        RSB     R12,LR, #32     ;# bits free in R3
15
        LDMIA   R0!,{R4-R11}    ;load 8 words
                         ;do 8 word shift, spare bits in R3
        ORR     R3, R3, R4, LSL LR
        MOV     R4, R4, LSR R12

        ORR     R4, R4, R5, LSL LR
        MOV     R5, R5, LSR R12

        ORR     R5, R5, R6, LSL LR
        MOV     R6, R6, LSR R12

        ORR     R6, R6, R7, LSL LR
        MOV     R7, R7, LSR R12

        ORR     R7, R7, R8, LSL LR
        MOV     R8, R8, LSR R12

        ORR     R8, R8, R9, LSL LR
        MOV     R9, R9, LSR R12

        ORR     R9, R9, R10,LSL LR
        MOV     R10,R10,LSR R12

        ORR     R10,R10,R11,LSL LR
        STMIA   R1!,{R3-R10}
        MOV     R3, R11,LSR R12

        SUBS    R2, R2, #8*4
        BPL     %BT15
        ADD     R2, R2, #8*4
20                              ;write out spare bytes from shift
        STRB    R3, [R1], #1
        MOV     R3, R3, LSR #8
        SUBS    LR, LR, #8
        BNE     %BT20
        B       %FT40           ;do any bytes left

;downwards aligned move

25
        LDMIA   R0!, {R3-R11}   ;move 9 aligned words at a time
        STMIA   R1!, {R3-R11}
30
        SUBS    R2, R2, #9*4
        BPL     %BT25
35
        ADD     R2, R2, #9*4
40                      ;move any odd bytes left
        SUBS    R2, R2, #1
        LDRPLB  LR, [R0], #1
        STRPLB  LR, [R1], #1
        BPL     %BT40
 [ Debug9
        mess    ,"leave BlockMove",NL
 ]
        Pull    "LR"
        RestPSR LR,,f
        Pull    "R0-R12,PC"

; upwards move
50
        ADD     R0, R0, R2      ;source end
        ADD     R1, R1, R2      ;dest end
55                      ;bytes at a time until source aligned
        TSTNES  R0, #2_11
        LDRNEB  LR, [R0,#-1]!
        STRNEB  LR, [R1,#-1]!
        SUBNES  R2, R2, #1
        BNE     %BT55

        ANDS    LR, R1, #2_11   ;dest mis-alignment
        BEQ     %FT80           ;same alignment

;upwards mis-aligned move

        SUBS    R2, R2, #9*4    ;enough left to worth being clever ?
        BLO     %FT85           ;if not

        LDR     R11,[R0,#-4]!   ;get a word from source
60
        MOV     R10,R11,LSR #24
        STRB    R10,[R1,#-1]!   ;put bytes to dest until aligned
        MOV     R11,R11,LSL #8
        TSTS    R1, #2_11
        BNE     %BT60
        MOV     LR, LR, LSL #3  ;# bits free in R11
        RSB     R12,LR, #32     ;# bits left in R11
65
        LDMDB   R0!,{R3-R10}    ;load 8 words
                        ;do 8 word shift, spare bits in R11
        ORR     R11,R11,R10,LSR R12
        MOV     R10,R10,LSL LR

        ORR     R10,R10,R9,LSR R12
        MOV     R9, R9, LSL LR

        ORR     R9, R9, R8, LSR R12
        MOV     R8, R8, LSL LR

        ORR     R8, R8, R7, LSR R12
        MOV     R7, R7, LSL LR

        ORR     R7, R7, R6, LSR R12
        MOV     R6, R6, LSL LR

        ORR     R6, R6, R5, LSR R12
        MOV     R5, R5, LSL LR

        ORR     R5, R5, R4,LSR R12
        MOV     R4, R4, LSL LR

        ORR     R4, R4, R3, LSR R12
        STMDB   R1!, {R4-R11}
        MOV     R11, R3, LSL LR

        SUBS    R2, R2, #8*4
        BPL     %BT65
        ADD     R2, R2, #8*4
70                      ;write out spare bytes from shift
        MOV     LR, R11,LSR #24
        STRB    LR, [R1,#-1]!
        MOV     R11,R11,LSL #8
        SUBS    R12,R12,#8
        BNE     %BT70
        B       %FT90           ;do any bytes left

;upwards aligned move
75
        LDMDB   R0!, {R3-R11}   ;move 9 aligned words at a time
        STMDB   R1!, {R3-R11}
80
        SUBS    R2, R2, #9*4
        BPL     %BT75
85
        ADD     R2, R2, #9*4
90                      ;move any odd bytes left
        SUBS    R2, R2,#1
        LDRPLB  LR, [R0,#-1]!
        STRPLB  LR, [R1,#-1]!
        BPL     %BT90
95
 [ Debug9
        mess    ,"leave BlockMove",NL
 ]
        Pull    "LR"
        RestPSR LR,,f
        Pull    "R0-R12,PC"


; ========
; Move256n
; ========

;Quick move when aligned, non overlapping move of length 256n

;entry
; R0=source start
; R1=dest start
; R2=length

;exit R0-R2 updated

Move256n ROUT
        Push    "R3-R11,SB,LR"
        SavePSR LR
        Push    "LR"
10
        LDMIA   R0!, {R3-R11,SB,LR}     ;11*4
        STMIA   R1!, {R3-R11,SB,LR}

        LDMIA   R0!, {R3-R11,SB,LR}     ;22*4
        STMIA   R1!, {R3-R11,SB,LR}

        LDMIA   R0!, {R3-R11,SB,LR}     ;33*4
        STMIA   R1!, {R3-R11,SB,LR}

        LDMIA   R0!, {R3-R11,SB,LR}     ;44*4
        STMIA   R1!, {R3-R11,SB,LR}

        LDMIA   R0!, {R3-R11,SB,LR}     ;55*4
        STMIA   R1!, {R3-R11,SB,LR}

        LDMIA   R0!, {R3-R11}           ;64*4=256
        STMIA   R1!, {R3-R11}

        SUBS    R2, R2, #256
        BGT     %BT10
        Pull    "LR"
        RestPSR LR,,f
        Pull    "R3-R11,SB,PC"



; =======
; ZeroRam
; =======

; Clear a block of RAM to 0

; entry: R0=start, R1=length

ZeroRam ROUT

 [ Debug9
        mess    ,"start   |length  - enter ZeroRam",NL
        DREG    R0
        DREG    R1
        DLINE   " "
 ]

        Push    "R0-R12,LR"
        SavePSR LR
        Push    "LR"
        TEQS    R1, #0
        BEQ     %FT95
        MOV     R2, #0
10                      ;byte at a time until aligned
        TSTS    R0, #2_11
        STRNEB  R2, [R0],#1
        SUBNES  R1, R1, #1
        BNE     %BT10

        SUBS    R1, R1, #16*4   ;enough to be worth being clever
        ADDLO   R1, R1, #16*4
        BLO     %FT40           ; if not
        MOV     R3, #0
        MOV     R4, #0
        MOV     R5, #0

        STMIA   R0!,{R2-R5}     ;good since 256 MOD 12 = 4, 1024 MOD 12 = 4
        LDMDB   R0, {R6-R9}
        LDMDB   R0, {R10-R12,LR}
20
        STMIA   R0!,{R2-R12,LR}
        SUBS    R1, R1, #12*4
        BPL     %BT20
30
        ADD     R1, R1, #12*4
40
        SUBS    R1, R1, #1
        STRPLB  R2, [R0],#1
        BPL     %BT40
95
 [ Debug9
        mess    ,"leave ZeroRam",NL
 ]
        Pull    "LR"
        RestPSR LR,,f
        Pull    "R0-R12,PC"


      [ NoARMv6 :LOR: NoUnaligned
; =====
; Read3
; =====

; Read 3 bytes from unknown alignment

; entry: R0 -> first byte (LO)

; exit:  LR =  24 bit result

Read3   ROUT
        Push    "R0-R2,LR"
        SavePSR R2
      [ SupportARMv6
        BIC     R1,R0,#3
        LDMIA   R1,{R1,LR}
      |
        LDMIA   R0,{R1,LR}
      ]
        ANDS    R0,R0,#3
        MOVNE   R0,R0,LSL #3
        MOVNE   R1,R1,LSR R0
        RSBNE   R0,R0,#32
        ORRNE   R1,R1,LR,LSL R0
        BIC     LR,R1,#&FF000000
        RestPSR R2,,f
        Pull    "R0-R2,PC"


; ========
; ReadWord
; ========

; Load 4 byte word from unknown alignment

; entry: R0 -> first byte (LO)

; exit:  LR =  32 bit result

ReadWord ROUT
        Push    "R0-R2,LR"
        SavePSR R2
        BIC     R1,R0,#3
        LDMIA   R1,{R1,LR}
        ANDS    R0,R0,#3
        MOVNE   R0,R0,LSL #3
        MOVNE   R1,R1,LSR R0
        RSBNE   R0,R0,#32
        ORRNE   R1,R1,LR,LSL R0
        MOV     LR,R1
        RestPSR R2,,f
        Pull    "R0-R2,PC"


; ======
; Write3
; ======

; Write 3 byte number at unknown alignment

; entry: R0 -> first byte (LO), R1=3 bytes to write

Write3  ROUT
        Push    "R0-R3,LR"
        MOV     R2,#3
        B        WriteCommon


; =========
; WriteWord
; =========

; Write 4 byte word at unknown alignment

; entry: R0 -> first byte (LO), R1=byte to write


WriteWord ROUT
        Push    "R0-R3,LR"
        MOV     R2,#4
WriteCommon
        SavePSR R3
WriteCommonLoop
        STRB    R1,[R0],#1
        MOV     R1,R1,ROR #8
        SUBS    R2,R2,#1
        BNE     WriteCommonLoop
        RestPSR R3,,f
        Pull    "R0-R3,PC"
      ] ; NoARMv6 :LOR: NoUnaligned

 [ {FALSE}
; ===========
; CheckEscape
; ===========

; exit: No Escape => Z=0
;          Escape => Z=1, R0=EscapeErr

CheckEscape
        Push    "R1,LR"
        LDR     R1,=ESC_Status
        LDRB    R1,[R1]
        EOR     R1,R1,#EscapeBit
        TSTS    R1,#EscapeBit
        MOVEQ   R0,#IntEscapeErr
        Pull    "R1,PC"
 ]

; ===========
; GetRandomId
; ===========

; entry -

; exit lr = a 'random' Id
GetRandomId ROUT
        Push    "r0-r3,r9,r12,lr"
        ADR     r9, CounterReadWs
        MOV     lr, pc
        LDMIA   r9, {r9, pc}
        MOV     lr, r0
        Pull    "r0-r3,r9,r12,pc"


; ===========
; NewRandomId
; ===========

; entry r0->start of 1K-sector new free space map

NewRandomId
        Push    "r1,lr"
 [ DebugE
        DREG    r0, "<-NewRandomId(",cc
        DLINE   ")"
 ]
        BL      GetRandomId
        STRB    lr, [r0, #ZoneHead+DiscRecord_DiscId+0]
        MOV     lr, lr, LSR #8
        STRB    lr, [r0, #ZoneHead+DiscRecord_DiscId+1]
        MOV     r1, #SzNewFloppyFs
        BL      SetNewCheck             ;(r0,r1)
        Pull    "r1,pc"


; ===========
; OldRandomId
; ===========

; entry R0->start of old free space map

OldRandomId
        Push    "r1-r2,lr"
        BL      GetRandomId
        STRB    lr, [r0, #OldId]
        MOV     lr, lr, LSR #8
        STRB    lr, [r0, #OldId+1]
        MOV     r1, #SzOldFs/2
        ADD     r0, r0, r1
        BL      CheckSum        ;(r0,r1->r2,V)
        STRB    r2, [r0, #Check1-SzOldFs/2]
        Pull    "r1-r2,pc"


; ====
; Sort
; ====

; sort a table of words into ascending order
; R0 start
; R1 end

Sort
        Push    "R2-R6,LR"              ;SHELL SORT TABLE
        SUB     R3,R1,R0                ;table length
        CMPS    R3,#2*4
        BLO     %FT30                   ;only sort if 2 or more entries
        CMPS    R3,#13*4
        MOVLS   R2,#1*4
        MOVHI   R2,#4*4
        CMPS    R3,#40*4
        MOVHI   R2,#13*4
15
        ADD     R3,R0,R2
        MOV     R6,R3
20
        MOV     R4,R3
        LDR     R5,[R3],#4
25
        LDR     LR,[R4,-R2]
        CMPS    LR,R5
        STRHS   LR,[R4],-R2
        CMPHSS  R4,R6
        BHS     %BT25
        STR     R5,[R4]
        CMPS    R3,R1
        BLO     %BT20
        CMPS    R2,#4*4
        MOVEQ   R2,#1*4
        MOVHI   R2,#4*4
        BHS     %BT15
30
        Pull    "R2-R6,PC"

 [ BigMaps
; ========
; SortPair
; ========

; sort a table of double words into ascending order
; R0 start
; R1 end


SortPair
        Push    "R2-R9,LR"              ;SHELL SORT TABLE

 [ DebugX
        DLINE   "Input to SortPair:"
        Push    "R0,R1,R2,R3"

01
        CMP     R0, R1
        BHS     %FT02

        LDMIA   R0!, {R2, R3}
        DREG    R3, " ",cc
        DREG    R2
        B       %BT01
02
        Pull    "R0,R1,R2,R3"
 ]
        SUB     R3,R1,R0                ;table length
        CMPS    R3,#2*8
        BLO     %FT30                   ;only sort if 2 or more entries

        MOV     R2, #1*8                ;value in use
        MOV     R8, #4*8

05
        ADD     LR, R8, R8, LSL #1
        ADD     LR, LR, #8
        CMPS    R3, LR
        MOVHI   R2, R8
        MOVHI   R8, LR
        BHI     %BT05


15
        ADD     R3,R0,R2
        MOV     R6,R3
20
        MOV     R4,R3
        LDMIA   R3!, {R5, R7}
25
        SUB     LR, R4, R2
        LDMIA   LR, {R8, R9}
        CMPS    R9,R7
        CMPEQS  R8,R5
        STMHSIA R4, {R8, R9}
        MOVHS   R4, LR
        CMPHSS  R4,R6
        BHS     %BT25
        STMIA   R4, {R5, R7}
        CMPS    R3,R1
        BLO     %BT20
        MOV     LR, #&2200  ; 1093*8
        ADD     LR, LR, #&28
        CMPS    R2, LR
        MOVHI   R2, LR
        BHI     %BT15
        CMPS    R2,#364*8
        MOVHI   R2,#364*8
        BHI     %BT15
        CMPS    R2,#121*8
        MOVHI   R2,#121*8
        BHI     %BT15
        CMPS    R2,#40*8
        MOVHI   R2,#40*8
        BHI     %BT15
        CMPS    R2,#13*8
        MOVHI   R2,#13*8
        BHI     %BT15
        CMPS    R2,#4*8
        MOVEQ   R2,#1*8
        MOVHI   R2,#4*8
        BHS     %BT15
30
 [ DebugX
        DLINE   "Output from SortPair:"
        Push    "R0,R1,R2,R3"

01
        CMP     R0, R1
        BHS     %FT02

        LDMIA   R0!, {R2, R3}
        DREG    R3, " ",cc
        DREG    R2
        B       %BT01
02
        Pull    "R0,R1,R2,R3"
 ]
        Pull    "R2-R9,PC"

 ]

        LTORG
        END
@


4.9
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d643 2
a644 2
        DREG    R3, "",cc
        DREG    R2, ""
d714 2
a715 2
        DREG    R3, "",cc
        DREG    R2, ""
@


4.8
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d554 1
a554 1
        STRB    lr, [r0, #ZoneHead+DiscId]
d556 1
a556 1
        STRB    lr, [r0, #ZoneHead+DiscId+1]
d635 2
a636 2
 	DLINE	"Input to SortPair:"
 	Push	"R0,R1,R2,R3"
d639 2
a640 2
 	CMP	R0, R1
 	BHS	%FT02
d642 4
a645 4
	LDMIA	R0!, {R2, R3}
	DREG	R3, "",cc
	DREG	R2, ""
	B	%BT01
d647 1
a647 1
 	Pull	"R0,R1,R2,R3"
d653 2
a654 2
	MOV	R2, #1*8		;value in use
	MOV	R8, #4*8
d657 6
a662 6
	ADD	LR, R8, R8, LSL #1
	ADD	LR, LR, #8
	CMPS	R3, LR
	MOVHI	R2, R8
	MOVHI	R8, LR
	BHI	%BT05
d670 1
a670 1
        LDMIA	R3!, {R5, R7}
d672 2
a673 2
	SUB	LR, R4, R2
	LDMIA	LR, {R8, R9}
d675 3
a677 3
        CMPEQS	R8,R5
        STMHSIA	R4, {R8, R9}
        MOVHS	R4, LR
d680 1
a680 1
        STMIA	R4, {R5, R7}
d683 17
a699 17
	MOV	LR, #&2200  ; 1093*8
	ADD	LR, LR, #&28
	CMPS	R2, LR
	MOVHI	R2, LR
	BHI	%BT15
        CMPS	R2,#364*8
        MOVHI	R2,#364*8
        BHI	%BT15
        CMPS	R2,#121*8
        MOVHI	R2,#121*8
        BHI	%BT15
        CMPS	R2,#40*8
        MOVHI	R2,#40*8
        BHI	%BT15
        CMPS	R2,#13*8
        MOVHI	R2,#13*8
        BHI	%BT15
d706 2
a707 2
 	DLINE	"Output from SortPair:"
 	Push	"R0,R1,R2,R3"
d710 2
a711 2
 	CMP	R0, R1
 	BHS	%FT02
d713 4
a716 4
	LDMIA	R0!, {R2, R3}
	DREG	R3, "",cc
	DREG	R2, ""
	B	%BT01
d718 1
a718 1
 	Pull	"R0,R1,R2,R3"
@


4.7
log
@Update to work with zero page relocation
Detail:
  s/FileCore, s/FileCore00, s/InitDieSvc - Try using OS_ReadSysInfo 6 to get IRQsema & CannotReset locations before falling back on legacy values. Store results in module workspace.
  s/FileCore05 - Commented out unused CheckEscape routine to avoid having to update it
  s/FileCore15 - Debugging code updated to use OS_ReadSysInfo 6 to fetch IRQsema ptr. Can't always rely on workspace version since workspace might not be set up yet.
  s/FileCore25, s/FileCore30, s/FileCore80 - Use IRQsema & CannotReset pointers from workspace
Admin:
  Tested on rev A2 BB-xM


Version 3.39. Tagged as 'FileCore-3_39'
@
text
@d128 1
a128 1
 [ Debug9
d130 3
a132 3
        DLINE   R0,\\\\ " ",cc
        DLINE   R1, " ",cc
        DLINE   R2, " "
d369 3
a371 3
        wrhex   R0
        wrhex   R1
        mess    ,NL
@


4.6
log
@  Various archiecture-based optimisations
Detail:
  * ARMv6+ builds use unaligned halfword and word loads and stores (unless
    pre-ARMv6 compatibility is required or NoUnaligned is set)
  * In many cases, one unnecessary BIC instruction has been removed from
    pre-ARMv6 builds
  * ARMv5+ builds (so Tungsten and OMAP) make use of CLZ instruction when
    parsing fragment blocks
Admin:
  Built and included in an OMAP3 ROM. But be warned, this has not received
  the rigorous testing normally required of filesystem code, use at your
  own risk.

Version 3.33. Tagged as 'FileCore-3_33'
@
text
@d507 1
a507 1

d523 1
@


4.5
log
@Fixed some mrs and msr macros for ObjAsm.

Version 3.30. Tagged as 'FileCore-3_30'
@
text
@d415 1
d429 1
d432 3
d505 1
@


4.4
log
@HAL branch changes (to code to read Timer0) merged. Should still assemble
on non-HAL builds.

Version 3.28. Tagged as 'FileCore-3_28'
@
text
@d56 1
a56 1
        mrs    ,LR, CPSR
d60 1
a60 1
        msr    ,CPSR_f, LR
@


4.3
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d526 6
a531 7
        Push    "r0,r1,lr"
        MOV     r0, #IOC
        STRB    r1, [r0, #Timer0LR]
        LDRB    r1, [r0, #Timer0CL]
        LDRB    lr, [r0, #Timer0CH]
        ORR     lr, lr, r1, ASL #8
        Pull    "r0,r1,pc"
@


4.3.2.1
log
@Simple HAL changes to stop it accessing Timer0 directly. Nowhere near
actually accessing other than a RAM disc on a non-IOMD machine.

Version 3.25, 4.9.2.1. Tagged as 'FileCore-3_25-4_9_2_1'
@
text
@d526 7
a532 6
        Push    "r0-r3,r9,r12,lr"
        ADR     r9, CounterReadWs
        MOV     lr, pc
        LDMIA   r9, {r9, pc}
        MOV     lr, r0
        Pull    "r0-r3,r9,r12,pc"
@


4.2
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d24 1
d26 5
d37 1
d39 5
d50 1
d54 9
d70 4
a73 3
        Pull    "LR"
        BICVCS  PC, LR, #V_bit
        ORRVSS  PC, LR, #V_bit
d118 1
a118 1
        Pull    "R2,PC",,^
d130 1
a130 1
        DLINE   R0, " ",cc
d135 2
d138 1
a138 1
        Pull    "R0-R12,PC",EQ,^
d219 3
a221 1
        Pull    "R0-R12,PC",,^
d308 3
a310 1
        Pull    "R0-R12,PC",,^
d328 2
d351 3
a353 1
        Pull    "R3-R11,SB,PC",,^
d375 2
d410 3
a412 1
        Pull    "R0-R12,PC",,^
d426 2
a427 1
        Push    "R0-R1,LR"
d436 2
a437 1
        Pull    "R0-R1,PC",,^
d451 2
a452 1
        Push    "R0-R1,LR"
d461 2
a462 1
        Pull    "R0-R1,PC",,^
d474 1
a474 1
        Push    "R0-R2,LR"
d489 1
a489 1
        Push    "R0-R2,LR"
d492 2
d497 3
a499 2
        BNE     WriteCommon
        Pull    "R0-R2,PC",,^
a533 1
 [ NewFs
d553 1
a553 2
        Pull    "r1,pc",,^
 ]
d572 1
a572 1
        Pull    "r1-r2,pc",,^
d613 1
a613 1
        Pull    "R2-R6,PC",,^
d714 1
a714 1
        Pull    "R2-R9,PC",,^
@


4.1
log
@Initial revision
@
text
@d106 4
a109 5
        mess    ,"source  |dest    |length  - enter BlockMove",NL
        wrhex   R0
        wrhex   R1
        wrhex   R2
        mess    ,NL
d572 103
@


4.1.4.1
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@a573 46
 [ BigMaps
; ========
; SortPair
; ========

; sort a table of double words into ascending order
; R0 start
; R1 end

SortPair
        Push    "R2-R9,LR"              ;SHELL SORT TABLE
        SUB     R3,R1,R0                ;table length
        CMPS    R3,#2*8
        BLO     %FT30                   ;only sort if 2 or more entries
        CMPS    R3,#13*8
        MOVLS   R2,#1*8
        MOVHI   R2,#4*8
        CMPS    R3,#40*8
        MOVHI   R2,#13*8
15
        ADD     R3,R0,R2
        MOV     R6,R3
20
        MOV     R4,R3
        LDMIA	R3!, {R5, R7}
25
	SUB	LR, R4, R2
	LDMIA	LR, {R8, R9}
        CMPS    R9,R7
        CMPEQS	R8,R5
        STMHSIA	R4, {R8, R9}
        MOVHS	R4, LR
        CMPHSS  R4,R6
        BHS     %BT25
        STMIA	R4, {R5, R7}
        CMPS    R3,R1
        BLO     %BT20
        CMPS    R2,#4*8
        MOVEQ   R2,#1*8
        MOVHI   R2,#4*8
        BHS     %BT15
30
        Pull    "R2-R9,PC",,^
        
 ]

@


4.1.4.2
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@d106 5
a110 4
        DLINE    ,"source  |dest    |length  - enter BlockMove"
        DLINE   R0, " ",cc
        DLINE   R1, " ",cc
        DLINE   R2, " "
a582 1

d588 5
a592 13

	MOV	R2, #1*8		;value in use
	MOV	R8, #4*8

05
	ADD	LR, R8, R8, LSL #1	
	ADD	LR, LR, #1
	CMPS	R3, LR
	MOVHI	R2, R8
	MOVHI	R8, LR
	BHI	%BT05


a610 9
        CMPS	R2,#121*8
        MOVHI	R2,#121*8
        BHI	%BT15
        CMPS	R2,#40*8
        MOVHI	R2,#40*8
        BHI	%BT15
        CMPS	R2,#13*8
        MOVHI	R2,#13*8
        BHI	%BT15
@


4.1.4.3
log
@Altered directory format (change backup dir entries to be one word instead
of an entire copy of the entry).  Also reduced size of a directory entry
by one word.  Also fixed a number of small bugs.
@
text
@a584 16

 [ DebugX
 	DLINE	"Input to SortPair:"
 	Push	"R0,R1,R2,R3"

01	
 	CMP	R0, R1
 	BHS	%FT02

	LDMIA	R0!, {R2, R3}
	DREG	R3, "",cc
	DREG	R2, ""
	B	%BT01
02
 	Pull	"R0,R1,R2,R3"
 ]
d594 1
a594 1
	ADD	LR, LR, #8
a632 15
 [ DebugX
 	DLINE	"Output from SortPair:"
 	Push	"R0,R1,R2,R3"

01	
 	CMP	R0, R1
 	BHS	%FT02

	LDMIA	R0!, {R2, R3}
	DREG	R3, "",cc
	DREG	R2, ""
	B	%BT01
02
 	Pull	"R0,R1,R2,R3"
 ]
@


4.1.4.4
log
@Fixed bugs in handling of growing directories, and made the directory
backup entries come back but only be one word long each.
@
text
@d586 1
a586 1
 [ DebugX :LAND: {FALSE}
d649 1
a649 1
 [ DebugX :LAND: {FALSE}
@


4.1.4.5
log
@Fixed:

DoOsFunRenameBigDir to work when renaming a shared file between dirs where
the file ends up as the last object in the target dir.

SanityCheckEDiscRecord to allow idlen>15 when DiscVersion=0

GrowBigDir to round up desired size to a multiple of the disc allocation
size.

Also:

Implemented non-working code to write cache the dir buffer.  WriteCacheDir
compile switch set to FALSE in s.DebugOpts.  Don't set it to TRUE unless
I tell you it's working.

Made SortDir not attempt to sort more than 2047 entries in a dir, to
avoid it overflowing ScratchSpace.

Made SortPair do one extra shell on the sort (makes it more efficient).
@
text
@d586 1
a586 1
 [ DebugX
d590 1
a590 1
01
d609 1
a609 1
	ADD	LR, R8, R8, LSL #1
a634 8
	MOV	LR, #&2200  ; 1093*8
	ADD	LR, LR, #&28
	CMPS	R2, LR
	MOVHI	R2, LR
	BHI	%BT15
        CMPS	R2,#364*8
        MOVHI	R2,#364*8
        BHI	%BT15
d649 1
a649 1
 [ DebugX
d653 1
a653 1
01
d665 1
a665 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

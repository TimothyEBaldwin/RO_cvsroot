head	4.14;
access;
symbols
	FileCore-3_75:4.14
	FileCore-3_74:4.14
	FileCore-3_73:4.14
	FileCore-3_72:4.14
	FileCore-3_71:4.14
	FileCore-3_70:4.14
	FileCore-3_69:4.14
	FileCore-3_68:4.14
	FileCore-3_67:4.14
	FileCore-3_66:4.14
	FileCore-3_65:4.14
	FileCore-3_64:4.14
	FileCore-3_63:4.14
	FileCore-3_62:4.14
	FileCore-3_61:4.14
	FileCore-3_60:4.14
	FileCore-3_59:4.14
	FileCore-3_58:4.14
	FileCore-3_57:4.14
	FileCore-3_56:4.14
	FileCore-3_55:4.14
	FileCore-3_54:4.14
	FileCore-3_53:4.14
	FileCore-3_52:4.14
	FileCore-3_51:4.14
	FileCore-3_50:4.14
	FileCore-3_49:4.13
	FileCore-3_48:4.13
	FileCore-3_47:4.13
	FileCore-3_46:4.13
	FileCore-3_45:4.13
	FileCore-3_44:4.12
	FileCore-3_43:4.12
	FileCore-3_42:4.12
	FileCore-3_41:4.11
	FileCore-3_40:4.10
	FileCore-3_39:4.10
	FileCore-3_38:4.9
	FileCore-3_37:4.9
	FileCore-3_36:4.9
	FileCore-3_35:4.9
	FileCore-3_34:4.9
	FileCore-3_33:4.7
	RO_5_07:4.7
	FileCore-3_32:4.7
	FileCore-3_31:4.7
	FileCore-3_30:4.6
	FileCore-3_29:4.6
	FileCore-3_28:4.5
	FileCore-3_25-4_9_2_2:4.4.2.1
	FileCore-3_27:4.4
	FileCore-3_26:4.4
	FileCore-3_22-4_6_2_1:4.3
	bavison_FileCore-3_22_dev_bp:4.3
	bavison_FileCore-3_22:4.3.0.2
	FileCore-3_25-4_9_2_1:4.4.2.1
	HAL:4.4.0.2
	FileCore-3_25:4.4
	FileCore-3_24:4.4
	FileCore-3_23:4.4
	dellis_autobuild_BaseSW:4.3
	FileCore-3_22:4.3
	Ursula_merge:4.1.4.7
	ROL_merge:4.1.4.7
	FileCore-3_21:4.3
	ROL_Ursula_merge:4.1.4.7
	Ursula_RiscPC_merge:4.1.4.7
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.6
	ROL_FileCore-3_21:4.1.4.7
	ROL_FileCore-3_20:4.1.4.7
	ROL:4.1.4.7.0.4
	ROL_bp:4.1.4.7
	Ursula_RiscPC_bp:4.1.4.7
	FileCore-3_18:4.1.4.7
	FileCore-3_01:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.7
	Ursula_RiscPC:4.1.4.7.0.2
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.1.4.7
	sproven_FileCore-3_16:4.1.4.7
	rthornb_UrsulaBuild-19Aug1998:4.1.4.7
	UrsulaBuild_FinalSoftload:4.1.4.7
	rthornb_UrsulaBuild-12Aug1998:4.1.4.7
	aglover_UrsulaBuild-05Aug1998:4.1.4.7
	rthornb_UrsulaBuild-29Jul1998:4.1.4.7
	rthornb_UrsulaBuild-22Jul1998:4.1.4.7
	rthornb_UrsulaBuild-15Jul1998:4.1.4.7
	rthornb_UrsulaBuild-07Jul1998:4.1.4.7
	rthornb_UrsulaBuild-17Jun1998:4.1.4.7
	rthornb_UrsulaBuild-03Jun1998:4.1.4.7
	rthornb_UrsulaBuild-27May1998:4.1.4.7
	rthornb_UrsulaBuild-21May1998:4.1.4.7
	sproven_FileCore-3_15:4.1.4.7
	sproven_314:4.1.4.7
	rthornb_UrsulaBuild_01May1998:4.1.4.7
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.7
	sproven_3_11:4.1.4.7
	sproven_3_10:4.1.4.7
	sproven_Ursula_3_09:4.1.4.7
	sproven_3_07:4.1.4.6
	sproven_3_06:4.1.4.5
	sproven_3_05:4.1.4.4
	sproven_3_04:4.1.4.3
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.3
	sproven_3_02:4.1.4.2
	sproven_3_01:4.1.4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.14
date	2012.04.14.00.43.17;	author bavison;	state Exp;
branches;
next	4.13;
commitid	xkSKw5i9HVYqOL0w;

4.13
date	2011.10.14.07.23.50;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	D2Id4aPp4zmuUhDv;

4.12
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	A9Zxco9ydo9FCOBv;

4.11
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	PKTDORFkNFRVOmzv;

4.10
date	2011.08.04.20.43.10;	author jlee;	state Exp;
branches;
next	4.9;
commitid	zcIknvqdwARiCeuv;

4.9
date	2009.06.15.23.25.35;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2009.06.11.20.59.30;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2003.04.03.18.33.28;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2001.05.14.14.27.07;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2001.05.10.15.10.27;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	2000.05.09.11.36.52;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.09.21.12.07.12;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.16;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	2000.11.30.17.04.36;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.32.16;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.12.15;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.16.14.46.38;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.11.17.13.32.20;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.12.01.12.02.58;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.01.09.11.44.58;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.01.19.12.26.35;	author sproven;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.01.23.16.41.17;	author sproven;	state Exp;
branches;
next	4.1.4.7;

4.1.4.7
date	98.02.11.16.49.19;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.33.55;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.30.49;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@  Miscellaneous improvements
Detail:
  * Added the ability for a filing system to specify to FileCore that floppy
    discs should be mounted like hard discs, to complement the existing flag
    that specifies the opposite. SDFS requires this. Ideally SCSIFS should
    start using this as well, to encapsulate boot block handling within
    FileCore.
  * Added header definitions so the FileCore and the filing systems can
    negotiate the use of a new MiscOp entry, needed as part of partitioning
    support, especially important for filing systems that use the hardware-
    specific section of the boot block, like ADFS. At present, FileCore
    doesn't do anything different (it still doesn't support partitions) but
    this enables filing systems to be modified in preparation.
  * Removed the only place where FileCore paid any attention to the
    EmptyWorks flag returned by MiscOp 1 - an obscure and not very useful
    edge case not used by any current filing systems.
  * Added 650 lines of documentation for the MiscOp SWI and low-level entry
    to the Doc directory, giving the information you need in order to
    implement a FileCore filing system.
  * Added missing header file definitions for the low-level background DiscOp
    reason code and the hot-plug drive removed flag to MiscOp 7.
  * Removed some RISC OS 2 legacy code whereby FileCore maintained its idea
    of the internal disc address of the CSD @@, PSD \, Library % and URD & for
    each filing system. Since RISC OS 3.00, FileSwitch handles these
    internally and passes canonicalised paths to FileCore, so FileCore's disc
    addresses for these directories remained unset. This allows some
    considerable simplification of FileCore's path parser in particular, but
    also affects other code like that which decides how to expire disc
    records. Also note that FileCore has been unable to generate certain
    errors (like "Can't delete current directory") since RISC OS 3.00 for the
    same reason.
  * Changed loading of the map for FileCore-format discs so that the map is
    loaded into the dynamic area during the Service_IdentifyDisc handler in
    one big DiscOp rather than loading it twice, sector-by-sector, via one
    big sector cache. For one thing, the sector cache is implemented
    inefficiently - O(n^2) - and for another thing, single-sector DiscOps are
    relatively inefficient on many filing systems, especially on SD cards.
    Some example speed-ups measured for mounting discs are:
      SCSIFS,   1GB drive: was 0.62 sec, now 0.40 sec (1.55 x speedup)
      SCSIFS, 256GB drive: was 1.44 sec, now 0.52 sec (2.77 x speedup)
      SDFS,     2GB drive: was 1.25 sec, now 0.14 sec (8.93 x speedup)
Admin:
  Tested on a beagleboard, with SCSIFS and SDFS.

Version 3.50. Tagged as 'FileCore-3_50'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

; >FileCore00

        TTL     "Start of module, workspace allocation"

        AREA    |FileCore$$Code|, CODE, READONLY, PIC

        ENTRY

        ; Module Header
Module_BaseAddr
        DCD     0                               ; no start entry
        DCD     InitEntry - Module_BaseAddr     ; initialisation entry
        DCD     DieEntry - Module_BaseAddr
        DCD     ServiceEntry - Module_BaseAddr
        DCD     Title - Module_BaseAddr
        DCD     HelpString - Module_BaseAddr
        DCD     ComTab - Module_BaseAddr
        DCD     FileCoreSWI_Base
        DCD     SwiEntry - Module_BaseAddr
        DCD     SwiNames - Module_BaseAddr
anull
        DCD     0                               ; no SWI name decoding code
      [ International_Help <> 0
        DCD     message_filename - Module_BaseAddr
      |
        DCD     0
      ]
        DCD     ModFlags - Module_BaseAddr
        ASSERT  {PC} - Module_BaseAddr = 52

Title
        DCB     "FileCore", 0
        ALIGN

HelpString
        DCB     "FileCore", 9
      [ Dev
        DCB     Module_FullVersion, " Development version", 0
      |
        DCB     Module_MajorVersion, " (", Module_Date, ")", 0
      ]
        ALIGN

ModFlags
      [ :LNOT: No32bitCode
        DCD     ModuleFlag_32bit
      |
        DCD     0
      ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data areas & register allocation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SB              RN 12

                ^ 0, SB
PrivateWord     # 4           ; back ptr to private word ;MUST BE FIRST
DefectSpace     # 4           ; workspace relative
ptr_IRQsema     # 4           ; Pointer to kernel IRQsema var
ptr_CannotReset # 4           ; Pointer to kernel CannotReset var

DefGlobals                    ; Globals that get initialised
DefGlobStart    # 0

ReEntrance      # 1           ; bit 0 => dormant
                DCB 1         ; bit 1 => executing first incarnation
                              ; bit 2 => doing MOS call for first incarnation
                              ; bit 3 => executing reentered code
                              ; bit 4 => doing MOS call for reentered code
                              ; bit 6 set => no reentrance
NoReEnterBit    bit 6

LastReEnter     # 1           ; set non zero whenever FileCore entered
                DCB 0
ScatterEntries  # 1           ; # chunks claimed for data move scatter block
                DCB 0
Flags           # 1
                DCB 0
CacheGood       bit 7
TruncateNames   bit 4         ; 0 means truncate, 1 means barf (yup, its the other way round to what's in CMOS)


message_file_open # 4         ; MessageTrans open flag
                DCD 0

 [ :LNOT: RO3Paths
UserRootDir     # 4
                DCD -1
LibDir          # 4
                DCD -1
CurDir          # 4
                DCD -1
BackDir         # 4
                DCD -1
 ]
CritBufDir      # 4           ; use when BufDir itself must be invalid
                DCD -1
BufDir          # 4           ; currently buffered directory
                DCD -1

              [ WriteCacheDir
BufDirDirty     # 4
                DCD 0
BufDirDirtyBit  * 1
ModifiedZones   # 4
                DCD 0
              ]

FirstFcb        # 4           ; link to first file control block
                DCD -1

FragCache       # 0
OldLastFilePtr  # 4
                DCD 0
OldLastMapPtr   # 4
                DCD 0
OldLastIndDiscAdd # 4
                DCD 0
LastFilePtr     # 4
                DCD 0
LastMapPtr      # 4
                DCD 0
LastIndDiscAdd  # 4
                DCD 0


PreferredDisc   # 1           ; Disc to use after canonicalise disc name
                DCB &FF
Interlocks      # 1
                DCB NoOpenFloppy :OR: NoOpenWinnie

WinnieLock      bit 0         ; DONT CHANGE THESE FOUR WHICH USE LSR #30 or LSR #28 TRICK
FloppyLock      bit 1
NoOpenWinnie    bit 2         ; Means: nothing open on winnie, so don't winnie BackgroundOp
NoOpenFloppy    bit 3         ; Means: nothing open on floppy, so don't floppy BackgroundOp
FileCacheLock   bit 4         ; Means: foreground is playing with the filecache, so hands off background!
DirCacheLock    bit 5
TimerLock       bit 6         ; Means: Ticker event is currently processing BackgroundOps

FiqOwnership    # 1
                DCB 0
BackgroundFiqLock # 1         ; set to &FF to stop attempts to claim FIQ
                DCB 0

                              ; One free space map is 'locked' at any time. When a map is locked the disc to
                              ; which it belongs is locked in its drive. The locked map may or not be being
                              ; modified. If being modified ModifyDisc will have the disc number in it,
                              ; otherwise it will be &ff. When no map is being read/modified these
                              ; map-specific values are set to &ff:
LockedDrive     # 1
                DCB &FF
LockedDisc      # 1
                DCB &FF
ModifyDisc      # 1           ; Disc whose map is unsafe due to being modifed or being read whilst disc is attached to drive
                DCB &FF
                # 1           ; Not free for other use
                DCB &FF

UpperCaseTable  # 4
                DCD 0

SzDefGlobals * {PC}-DefGlobals
                ASSERT {VAR} - DefGlobStart = SzDefGlobals

ParentBase      # 4           ; base of parent module
ParentPrivate   # 4           ; ptr to private word of parent module
Floppies        # 1           ; # floppy drives
Winnies         # 1           ; # winnie drives
Drive           # 1           ; default drive
StartUpOptions  # 1

              [ :LNOT: DynamicMaps
WinnieSizes     # 4
FloppySizes     # 4           ; Must follow WinnieSizes for indexing purposes
              ]
FS_Flags        # 3
FS_Id           # 1
FS_Title        # 4           ; FOLLOWING ARE STORED AS ABSOLUTE ADDRESSES
FS_BootText     # 4
FS_LowLevel     # 4
FS_Misc         # 4

DiscOp_ByteAddr # 4

message_file_block # 16       ; block for messagetrans

              [ NewErrors
ConvDiscErr     # 12
              ]

SysHeapStart    # 4

              [ BigDir
Opt1Buffer      # BigDirMaxNameLen + 1
              |
Opt1Buffer      # NameLen + 1
                # 1           ; filler
              ]

                # -CacheRootStart
RootCache       # CacheRootEnd


ScatterPtr      # 4           ;->Scatter block
ScatterAdd      * 0
ScatterLen      * 4

ScatterBlk      # 8

                              ; Critical subroutine management workspace
CriticalDepth   * 2           ; max levels of critical subroutine

CriticalGood1   # 1
                # 3
CriticalSP1     # 4
CriticalStack1  # (CriticalDepth + 1) * 4

CriticalGood2   # 1
                # 3
CriticalSP2     # 4
CriticalStack2  # (CriticalDepth + 1) * 4

CritDrvRec      # 4
CritDiscRec     # 4
CritResult      # 4

BreakAction     # 1
                # 3

MaxFileBuffers          # 1
UnclaimedFileBuffers    # 1
BufHashMask             # 1
WriteDisc               # 1   ; disc in use by put bytes or &FF so that floppy
                              ; write behind can't be unset if may add more
FileBufsStart           # 4     
FileBufsEnd             # 0   ; Same as FloppyProcessBlk
FloppyProcessBlk        # 4     
WinnieProcessBlk        # 4     
BufHash                 # 4     

TickerState     # 4           ; bottom 16 bits period, top 16 bits counter

        ASSERT  YoungerBuf = OlderBuf + 4
ChainRootSz     * 4 + 4       ; older and younger link
BufChainsRoot   * @@-OlderBuf  ; roots of buffer allocation lists
                # 6 * ChainRootSz

DirectError     # 4           ; background error in direct transfer

CounterReadWs   # 4
CounterReadCall # 4

              [ BigDisc
DoCompZoneBase  # 4           ; Workspace for DoCompMoves
              ]

                ; Records
DrvRecs         # SzDrvRec * 8
DiscRecs        # SzDiscRec * 8

                ; Data move scatter list
ScatterMax      * 8           ; max # (address,length) pairs in buffer
ScatterListLen  * ScatterMax * (4 + 4)

ScatterSource   # ScatterMax
ScatterList     # ScatterListLen
ScatterCopy     # ScatterListLen

        ASSERT  :INDEX:{VAR}<&1000

        ASSERT NewDirSize > OldDirSize
DirBufSize      * NewDirSize
              [ BigDir
DirBufferPtr    # 4           ; pointer to dir buffer
DirBufferArea   # 4           ; dynamic area number of dir buffer
DirBufferSize   # 4           ; size of dir buffer
              |
DirBuffer       # DirBufSize
              ]

DirCache        # 0           ; MUST BE LAST

              [ Dev
                ! 0, "BufChainsRoot = " :CC: :STR: :INDEX: BufChainsRoot
                ! 0, "DirCache = " :CC: :STR: :INDEX: DirCache
                ! 0, "DrvRecs = " :CC: :STR: :INDEX: DrvRecs
                ! 0, "DiscRecs = " :CC: :STR: :INDEX: DiscRecs
              ]

        ALIGN
        LTORG
        
        END
@


4.13
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d22 2
d102 1
d111 1
@


4.12
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d18 1
a18 1
        TTL     "Start of module, declarations and workspace allocation"
d21 2
a22 1
        ENTRY
d24 18
a41 20

;Module Header
        & 0                     ;no start entry
        & InitEntry       - Module_BaseAddr ;initialisation entry
        & DieEntry        - Module_BaseAddr
        & ServiceEntry    - Module_BaseAddr
        & Title           - Module_BaseAddr
        & HelpString      - Module_BaseAddr
        & ComTab          - Module_BaseAddr
FileCoreSwiBase * Module_SWISystemBase + FileCoreSWI * Module_SWIChunkSize
        & FileCoreSwiBase
        & SwiEntry        - Module_BaseAddr
        & SwiNames        - Module_BaseAddr
        & 0                     ;no SWI name decoding code
 [ International_Help <> 0
        & message_filename - Module_BaseAddr
 |
        & 0
 ]
        & ModFlags        - Module_BaseAddr
d45 1
a45 1
        =       "FileCore",0
d49 6
a54 7
        =       "FileCore",9
        [ Dev
        =       Module_FullVersion," Development version"
        |
        =       Module_MajorVersion," (",Module_Date,")"
        ]
anull   = 0
d58 1
a58 1
        [ :LNOT: No32bitCode
d60 1
a60 1
        |
d62 1
a62 6
        ]

        LTORG
        GET     Errors.s

; Disc Record
d64 3
a66 693
        ^ 0
;
SectorSize      # 1     ;log2 sector size
SecsPerTrk      # 1
Heads           # 1     ;n-1 for old adfs floppy format
Density         # 1     ;0/1/2/3/4/8 hard/single/double/double+/quad/octal

;only those above & DiscsDrv & Disc Size needed for low level drivers

LinkBits        # 1
BitSize         # 1     ;log2 bytes for each bit in map, 0 for old format
RAskew          # 1     ;track to track sector skew for random access
                        ;file allocation
BootOpt         # 1     ;boot option for this disc

LowSector       # 1     ; Lowest sector number on a track and flags:
                ; Bit     Meaning when set
LowSectorMask   * &3f
                ; 0-5     Lowest numbered sector on a track
SequenceSides   bit 6
                ; 6       Tracks are numbered 0..s-1 on side 0, then s..2s-1 on side 1, etc
DoubleStep      bit 7
                ; 7       Double step

Zones           # 1     ;# zones in map
ZoneSpare       # 2     ;# bits in zones after 0 which are not map bits
        ASSERT  (ZoneSpare :MOD: 4)=2
RootDir         aw 4
DiscSize        aw 4

DiscStruc       # 0     ;above entries (except BootOpt) define disc structure

DiscId          aw 2
DiscName        # 10
DiscRecSig      # 0     ;above entries form signature of disc

DiscType        aw 4    ; FileType of disc: FileType_Data indicates
                        ; that the disc is, as yet, unidentified.
                        ; This may occur as a result of the identification
                        ; process failing, or the identification process
                        ; not yet happening. FileType_Data discs have no
                        ; concept of a unique identifier so drive independance
                        ; when accessing them is not possible.

  [ BigDisc
DiscSize2	aw 4	; top 32bits of the disc size.  This combines with
			; DiscSize to give the full size of the disc.  Note
			; that we may have to move DiscStruc to below here
			; so we can compare structures properly.
   [ BigShare
ShareSize       # 1     ; sharing unit
BigFlag         # 1     ; flag - 0 for small disc, 1 for big
BigFlagBit	* 1	; bit for the big flag

    [ BigMaps
Zones2		# 1	; high byte of number of zones
SharePad	# 1	; padding
    |
SharePad        # 2     ; padding
    ]

    [ BigDir
DiscVersion	# 4	; version number of disc format
RootDirSize	# 4	; size of root dir
    ]
   ]
DiscRecSig2     # 0     ;above entries form signature of disc
  ]
DiscFlags       # 1
FloppyFlag              bit 0
NeedNewIdFlag           bit 1   ; Indicates that when this disc is next updated a new Id aught to be given it too
DiscNotFileCore         bit 2   ; Indicates this isn't a FileCore disc (yet)
DiscNotIdentified       bit 3   ; Indicates this Data disc hasn't been identified as something else yet.
AltMapFlag              bit 5
OldMapFlag              bit 6
OldDirFlag              bit 7   ;set <=> old small dirs


;entries below must be valid even when disc rec is not in use
Priority        # 1     ;0 DISC REC UNUSED
                        ;1 to # floppies -> floppy priority level
                        ;&FF good winnie
DiscsDrv        # 1     ;0-7 => drive in, 8 => not in drive, OR DISC REC UNUSED
DiscUsage       # 1     ;tasks using this disc, if >0 disc cant be forgotten
SzDiscRec       # 0

;default last word of disc record
;DiscFlags      0  FLOPPIES NEED NeedNewIdFlag SET INITIALLY
;Priority       0
;DiscsDrv       8
;DiscUsage      0
DefDiscRecEnd   * &00080000

; Preamble to disc rec for FORMAT
SzFormHdr * 8
        ^ -SzFormHdr
FormSig         # 1     ;signature
FormChar        # 1
HalfSide0Gap1   # 1
HalfSide1Gap1   # 1
Gap3            # 1
Skew            # 1
                # 2     ;unused
        ASSERT @@=0
SzFormDiscRec   * SzDiscRec+SzFormHdr

L_Root          * &200
D_Root          * &400

L_Size          * 640*K
D_Size          * 800*K

NewMapRoot              * &203   ;indirect disc add
NewFloppyRootDiscAdd    * &800   ;physical disc add

;point Rptr to start of disc record Rindex, must preserve flags
        MACRO
$lab    DiscRecPtr $Rptr,$Rindex,$cond
        ASSERT  $Rptr<>SB
        ASSERT  $Rptr<>PC
 [ BigDisc
 [ DebugDR
        Push    "SB,LR, R0"
        MOV     R0, $Rindex
        SavePSR SB
        BICS    LR, R0, #7
        BEQ     %FT01
        DREG    R0, "DiscRecPtr: illegal disc:"
        DREG    PC, "PC:"
01
        RestPSR SB,,f
        Pull    "SB,LR,R0"
 ]
  [ BigShare
   [ BigDir
      ASSERT	SzDiscRec=56
      RSB$cond 	$Rptr, $Rindex, $Rindex, ASL #3 ;*7
      ADD$cond 	$Rptr, SB, $Rptr, ASL #3	 ;7*8=56
   |
	ASSERT	SzDiscRec=48
	ADD$cond $Rptr, $Rindex, $Rindex, ASL #1 ;*3
        ADD$cond $Rptr,SB,$Rptr,ASL #4           ;SB+Rindex*SzDiscRec
   ]
  |
	ASSERT	SzDiscRec=44
   [ $Rptr<>$Rindex
	ADD$cond $Rptr, $Rindex, $Rindex, ASL #1 ;*3
	ADD$cond $Rptr, $Rptr, $Rindex, ASL #3	 ;+*8=*11
	ADD$cond $Rptr, SB, $Rptr, ASL #2	 ;SB+Rindex*SzDiscRec
   |
	Push	"SB"
	ADD$cond SB, $Rindex, $Rindex, ASL #1	 ;*3
	ADD$cond $Rptr, SB, $Rindex, ASL #3	 ;+*8=*11
	Pull	"SB"
	ADD$cond $Rptr, SB, $Rptr, ASL #2	 ;SB+Rindex*SzDiscRec
   ]
  ]
 |
        ASSERT  SzDiscRec=40
        ADD$cond $Rptr,$Rindex,$Rindex,ASL #2   ;*5
        ADD$cond $Rptr,SB,$Rptr,ASL #3          ;SB+Rindex*SzDiscRec
 ]
        MinOps  ADD, ADD, $Rptr, $Rptr, (:INDEX:DiscRecs), $cond
        MEND

; Changes to Disc Record structure also affect
;  InitRdFloppyFs - Adfs20

; Drive Record

        ^ 0
DrvsDisc        # 1
Uncertain       bit 7   ; Contents of disc in drive uncertain - may have a disc record attached, but not certain it's the right one or that it's type is correct
Unknown         bit 6   ; Contents of disc in drive not known (no attached disc record)
Empty           bit 5   ; Disc definitely not in drive
Full            bit 4   ; Disc definitely in drive, but no disc record attached to drive

DrvFlags        # 1     ; Flags about drive
HasDefectList   bit 0   ; Set if drive has a defect list
LastDiscOpWasFormat bit 1 ; Set if the last DiscOp was a format track operation
LockCount       # 1     ; How many times the drive's been locked
PrevFormSectorSize # 1  ; SectorSize in previous format operation
PrevFormSecsPerTrk # 1  ; SecsPerTrk in previous format operation
PrevFormHeads   # 1     ; Heads in previous format operation
PrevFormDensity # 1     ; Density in previous format operation
PrevFormLowSector # 1   ; LowSector in previous format operation
PrevFormDiscSize aw 4   ; DiscSize in previous format operation
 [ BigDisc
PrevFormDiscSize2 aw 4  ; 2nd part of DiscSize in previous format operation
 ]
ChangedSeqNum   aw 4
 [ DynamicMaps
DrvsFsMapAddr	aw 4	;ptr to free space map
DrvsFsMapArea	aw 4	;dynamic area number
DrvsFsMapSize	aw 4	;size of the map
DrvsFsMapFlags	aw 4	;flags for the map
 |
DrvsFsMap aw 4  ;ptr to free space maps
 ]
BadFs   bit 31  ;set if corrupt on disc
EmptyFs bit 30  ;set if FS map buffer empty for old maps
FsMapMaxSize	* 4*1024*1024
 [ DynamicMaps
MemErrorFs bit 29	;set if failed to load FSmap due to errors with dynamic areas
NewHiFsBits     * BadFs :OR: EmptyFs
 |
HiFsBits        * BadFs :OR: EmptyFs
 ]
SzDrvRec        # 0


;point Rptr to start of drive record Rindex, must preserve flags
        MACRO
$lab    DrvRecPtr $Rptr,$Rindex,$cond
        ASSERT  $Rptr<>SB
        ASSERT  $Rptr<>PC

 [ DebugDR
        Push    "SB,LR, R0"
        MOV     R0, $Rindex
        SavePSR SB
        BICS    LR, R0, #7
        BEQ     %FT01
        DREG    R0, "DrvRecPtr: illegal disc:"
        DREG    PC, "PC:"
01
        RestPSR SB,,f
        Pull    "SB,LR,R0"
 ]

 [ DynamicMaps
 	ASSERT	SzDrvRec=36
 	ADD$cond	$Rptr, $Rindex, $Rindex, LSL #3
 	ADD$cond	$Rptr, SB, $Rptr, LSL #2
 |

   [ BigDisc
        ASSERT  SzDrvRec=24
        ADD$cond $Rptr,$Rindex,$Rindex,LSL #1
        ADD$cond $Rptr,SB,$Rptr,LSL#3
   |
        ASSERT  SzDrvRec=20
        ADD$cond $Rptr,$Rindex,$Rindex,LSL #2
        ADD$cond $Rptr,SB,$Rptr,LSL#2
   ]
 ]
        MinOps  ADD, ADD, $Rptr, $Rptr, (:INDEX:DrvRecs), $cond
        MEND


; structure of dir cache obj

                ^ 0
CacheNext       aw 4    ;->next obj, -1 marks end of cache
CachePriority   aw 4    ;0 for free space, -1 marks end of cache
CacheMin        # 0     ;min size for free space

; rest dont apply to free spaces
CacheRootStart  # 0
CacheYounger    aw 4    ;-> next youngest dir
CacheOlder      aw 4    ;-> next oldest dir
CacheRootEnd    # 0

CacheDir        aw 4    ;disc address of dir
CacheBody       # 0


; structure of a sector cache entry

                        ^ 0
SectorCache_Next        aw 4    ; Link to next cached sector, or 0
SectorCache_Address     aw 4    ; disc address of this cached sector
SectorCache_Error       aw 4    ; error encountered when reading this sector
SectorCache_Usage       aw 4    ; Number of times this block's been used
SectorCache_HeaderSize  # 0
SectorCache_Contents    # 0

; DEFECT LIST

; The list consists of words containing the disc address ( in bytes ) of bad
; sectors, the end is marked by a value &200000xx, where &xx forms a check
; byte on the earlier list. The last 64 bytes describe the disc to FileCore.
; Any other bytes may be used as params for the low level drivers

DefectListDiscAdd       * &400+&800
SzDefectList            * &200
DefectEndMark           bit 29
MaxStruc                * 64
        ASSERT  SzDiscRec<=MaxStruc

        ^ 0
                # SzDefectList-MaxStruc-4
ParkDiscAdd     # 4
DefectStruc     # MaxStruc-1
;DefectCheck
                # 1
        ASSERT  @@=SzDefectList


; OLD FS MAP
        ^ 0
FreeStart       # 82*3  ;table of free space start sectors
EndSpaceList    # 0
                # 1     ;reserved
OldName0        # 5     ;              RETRO DEFINITION
OldSize         # 3     ;size in sectors
Check0          # 1     ;checksum on sector 0

FreeLen         # 82*3  ;table of free space lengths
OldName1        # 5     ;              RETRO DEFINITION
OldId           # 2     ;disc id
OldBoot         # 1     ;boot option
FreeEnd         # 1     ;ptr to end of free space list
Check1          # 1     ;checksum on sector 1

        ASSERT  {VAR}=&200

; New map

                ^ 0
ZoneCheck       # 1
FreeLink        # 2     ;15 bit free space start link
CrossCheck      # 1     ;EORing this byte for all zones should yield &FF

DummyLenBit     bit 31  ;always set

ZoneDiscRecSz   * 60    ;reserve additional bytes
                ASSERT ZoneDiscRecSz>=SzDiscRec

ZoneHead        # ZoneDiscRecSz

Zone0Bits       * ZoneDiscRecSz*8

;zones are followed in RAM by table of one byte of flags per zone

ZoneValid       bit 0
ZoneCompacted   bit 1



; Dir entry
                ^ 0
NameLen         * 10
DirObName       # NameLen
DirLoad         # 4
DirExec         # 4
DirLen          # 4
DirIndDiscAdd   # 3
OldDirObSeq     # 1

OldDirEntrySz   * {VAR}
        ASSERT  OldDirEntrySz=26

NewDirAtts      * OldDirObSeq
ReadBit         bit 0
WriteBit        bit 1
IntLockedBit    bit 2   ;the locked bit is held in bit 2 internally
ExtLockedBit    bit 3   ;but is returned in bit 3 externally
DirBit          bit 3
EBit            bit 4   ;6502 ADFS E files are treated as if R
 [ FullAtts             ;extended attributes only for new dirs
Att4            bit 4
PublicReadBit   * Att4
Att5            bit 5
PublicWriteBit  * Att5
Att6            bit 6
Att7            bit 7
NewAtts         * Att4 :OR: Att5 :OR: Att6 :OR: Att7
 |
NewAtts         * 0
 ]
IntDirAttMask   * IntLockedBit :OR: DirBit :OR: NewAtts
IntAttMask      * IntDirAttMask :OR: ReadBit :OR: WriteBit
ExtAttMask      * ReadBit :OR: WriteBit :OR: ExtLockedBit :OR: NewAtts

NewDirEntrySz   * {VAR}


; Directory Start
                ^ 0
StartMasSeq     # 1
StartName       # 4
DirFirstEntry   # 0

; Old Directory End
                ^ 0
                # -1
DirCheckByte    # 0     ;RETRO DEFINITION was reserved

                # -4
EndName         # 0

                # -1
EndMasSeq       # 0

                # -14   ;reserved

DirTitleSz      * 19
                # -DirTitleSz
OldDirTitle     # 0

                # -3
OldDirParent    # 0

                # -NameLen
OldDirName      # 0

                # -1
OldDirLastMark  # 0     ;dummy last entry marker

; New Directory End
                ^ 0
                # -1
        ASSERT  DirCheckByte=@@

                # -4
        ASSERT  EndName=@@

                # -1
        ASSERT  EndMasSeq=@@

                # -NameLen
NewDirName      # 0

                # -DirTitleSz
NewDirTitle     # 0

                # -3
NewDirParent    # 0

                # -1    ;reserved
                # -1    ;reserved

                # -1
NewDirLastMark  # 0     ;dummy last entry marker

OldDirSize      * &500
NewDirSize      * &800

OldDirTabSz     * (OldDirSize-DirFirstEntry+OldDirLastMark)
NewDirTabSz     * (NewDirSize-DirFirstEntry+NewDirLastMark)
                ASSERT  OldDirTabSz :MOD: OldDirEntrySz = 0
                ASSERT  NewDirTabSz :MOD: NewDirEntrySz = 0
OldDirEntries   * OldDirTabSz / OldDirEntrySz
NewDirEntries   * NewDirTabSz / NewDirEntrySz

        ASSERT  OldDirEntries=47
        ASSERT  NewDirEntries=77

 [ BigDir
; SBP: 28 Aug 1997: Added new directory type, known as 'big'

; Big directory header
	^ 0

BigDirStartMasSeq	# 1	; master sequence number
BigDirVersion		# 3	; directory version number
BigDirStartName		# 4	; 'SBPr'
BigDirNameLen		# 4	; Length of the directory's name
BigDirSize		# 4	; Length of the directory
BigDirEntries		# 4	; Number of entries in a directory
BigDirNamesSize		# 4	; number of bytes allocated for names
BigDirParent		# 4	; indirect disc address of parent directory
BigDirName		# 0	; start of the dir name
BigDirHeaderSize	# 0	; size of the header

; Big directory entry

	^ 0

 [ {FALSE}
BigDirEntryName		# 4	; 'DirE'
 ]
BigDirLoad		# 4	; load address of object
BigDirExec		# 4	; exec address of object
BigDirLen		# 4	; length of object
BigDirIndDiscAdd	# 4	; indirect disc address of object
BigDirAtts		# 4	; attributes of object
BigDirObNameLen		# 4	; length of object name
BigDirObNamePtr		# 4	; offset into name heap for name
BigDirEntrySize		# 0	; size of entry


 [ {FALSE}
; Big directory name heap entry

	^ 0

BigDirHeapName		# 4	; 'Name'
BigDirHeapIndDiscAdd	# 4	; copy of indirect disc address
BigDirHeapObName	# 0	; name of file (padded with nulls to word boundary)
BigDirHeapHeaderSize	# 0	; size of the header for a name heap entry
 ]

; Big directory tail

	^ 0
			# -1

BigDirCheckByte		# 0

			# -2	; reserved

			# -1

BigDirEndMasSeq		# 0

			# -4

BigDirEndName		# 0	; 'oven'

BigDirTailSize		* -@@

 [ Dev
 ! 0, "BigDirTailSize = " :CC: :STR: BigDirTailSize
 ]

; other useful definitions for big directories

BigDirMaxNameLen	* 255   ; maximum name length is 255 chars

BigDirMinSize		* 2048
BigDirMaxSize		* 4*1024*1024

 ]


BufSz           RN 4
FileOff         RN 5
DiscAdjust      RN 6
TransferEnd     RN 7
FragEnd         RN 8
Fcb             RN 9
BufOff          RN 10
BufPtr          RN 11

;FILE CACHE BUFFER
                ^ 0

BufFlags        # 4     ;these 4 are in common with extended FCB
NextInFile      # 4
PrevInFile      # 4
BufFileOff      # 4

BufFcb          # 4
OlderBuf        # 4
YoungerBuf      # 4
BufPriority     # 1
                # 3
BufferData      # 1*K   ;data itself

BufScale        * 5
                ASSERT BufferData :SHL: BufScale = 1*K

                ^ 0                     ;priority levels for buffers
EmptyChain      # 1
MonotonicChain  # 1
NormalChain     # 1
AwaitsSeqChain  # 1
ReadAheadChain  # 1
WriteBehindChain # 1

EmptyBuf        bit EmptyChain+2        ;priority level flags
UsedMonotonic   bit MonotonicChain+2
NormalBuf       bit NormalChain+2
AwaitsSeqRead   bit AwaitsSeqChain+2
ReadAhead       bit ReadAheadChain+2
WriteBehind     bit WriteBehindChain+2

AllocFlags      * EmptyBuf :OR: UsedMonotonic :OR: NormalBuf :OR:AwaitsSeqRead :OR: ReadAhead :OR: WriteBehind
                ASSERT AllocFlags=2_11111100


; File Control Block

        ^ 0     ;FCB has header in common with file cache buffer

 ASSERT BufFlags=@@
 #      4
 ASSERT NextInFile=@@
 #      4
 ASSERT PrevInFile=@@
 #      4
 ASSERT BufFileOff=@@
 #      4


FcbNext         aw 4    ;link to next FCB
FcbFlags        # 1
FcbBufSz        # 1
 [ BigDir
	ASSERT	BigDirMaxNameLen<=255
FcbName		# 258	; make sure aligned
 |
FcbName         # 10
 ]
FcbLength       aw 4    ;ASSUME LOWEST BYTE ZERO TO USE AS NAME TERMINATOR
FcbDir          aw 4    ;dir containing file
FcbIndDiscAdd   aw 4
FcbExtent       aw 4
FcbExtHandle    # 4     ;0             => Fcb kept around although file closed
NotHandle       * 32*K  ;1-NotHandle-1 => external handle and access<>R
                        ;>=NotHandle   => ptr to chain of external handles
LastReadEnd     # 4
AccessHWM       # 4
ReadAheadBufs   # 1
DataLostFlag    # 1
                # 1
                # 1
FcbSize         # 0

; Flags
; b0 set <=> file has read access
; b1 set <=> file has write access
; b2 Indicates which controller
FcbFloppyBitNo  * 2
FcbFloppyFlag   bit FcbFloppyBitNo
; b3 set <=> dir
; b4 set <=> EXT needs ensuring
                ASSERT  ReadBit  = bit0
                ASSERT  WriteBit = bit1
                ASSERT  DirBit   = bit3
ExtFlag         bit 4
Monotonic       bit 5   ;set <=> all read access above HWM
SequentialBitNo * 6
Sequential      bit SequentialBitNo     ;set <=> reading sequentially
FcbDiscImage    bit 7   ; set <=> Fcb is disc image

;object in handle chain if can be multiply open

                ^ 0
NextHandleBlk   # 4
HandleBlkFcb    # 4
ExtHandle       # 4
HandleBlkSize   # 0

HandleBlkBit    bit 31  ;bit that marks internal handle as ptr to handle block


;Background process control block
;Both floppies and winnies have values of following

                ^ 0
Process         # 1     ;AMENDED FROM INACTIVE BY RETRYDRIVEOP
Inactive        bit 0
                ASSERT ReadAhead   = bit6
                ASSERT WriteBehind = bit7
ProcessDirect   # 1     ;0/&FF if process includes a direct transfer
ProcessDrive    # 1     ;FILLED IN BY RETRYDRIVEOP
                # 1
ShortProcessBlk # 0     ;when file cache not in use

ProcessEndPtr   # 4
OldLength       # 4
ProcessWriteBehindDrive # 1     ;Must be in same word for atomic write
ProcessWriteBehindDisc # 1
                # 2     ;Not free for other use
ProcessWriteBehindLeft # 4
ProcessStartPtr # 4     ;DO NOT REORDER THESE
ProcessRamAdjust # 4
ProcessStartOff # 4
ProcessEndOff   # 4
ProcessFragEnd  # 4
ProcessFcb      # 4
ProcessError    # 4
ProcessStatus   # 4
Active          bit 31
CanExtend       bit 30
ProcessPairs    # 0

ExtraPairs      * 2



; WORKSPACE ALLOCATION

;
; -----------------------------------------------------------------------------
; | misc. | Dir    | Directory cache : Random access     | winnie and 'floppy'
; | work  | Buffer |                 : file buffer cache | defect
; | space |        |                 :                   | lists
; -----------------------------------------------------------------------------
; ^0                                 ^ FileBufsStart     ^DefectSpace
;

; ALL POINTERS TO WORKSPACE NEEDING TO BE PRESERVED OVER TIDY MUST BE
; WORKSPACE RELATIVE

        ^ 0,SB
PrivateWord     # 4     ;back ptr to private word ;MUST BE FIRST
DefectSpace     # 4     ;workspace relative
ptr_IRQsema     # 4     ;Pointer to kernel IRQsema var
ptr_CannotReset # 4     ;Pointer to kernel CannotReset var
d68 1
d70 5
a74 1
;Globals that get initialised
d76 1
a76 2

DefGlobals
d79 6
a84 7
ReEntrance      # 1     ;bit  5 set => no reentrance
        = 1             ;bits 0-4
; 0 => dormant
; 1 => executing first incarnation
; 2 => doing MOS call for first incarnation
; 3 => executing reentered code
; 4 => doing MOS call for reentered code
d86 5
a90 4
LastReEnter     # 1     ;set non zero whenever FileCore entered
        = 0
ScatterEntries  # 1     ;# chunks claimed for data move scatter block
        = 0
d92 51
a142 51
        = 0
CacheGood      bit 7
TruncateNames  bit 4    ; 0 means truncate, 1 means barf (yup, its the other way round to what's in CMOS)

; MessageTrans open flag
message_file_open       a4 4
        & 0

UserRootDir     a4 4
        & -1
LibDir          a4 4
        & -1
CurDir          a4 4
        & -1
BackDir         a4 4
        & -1
CritBufDir      a4 4    ;use when BufDir itself must be invalid
        & -1
BufDir          a4 4    ;currently buffered directory
        & -1

 [ WriteCacheDir
BufDirDirty	a4 4
	& 0
BufDirDirtyBit * 1
ModifiedZones	a4 4
	& 0
 ]

FirstFcb        a4 4    ;link to first file control block
        & -1

FragCache       a4 0
OldLastFilePtr  a4 4
        & 0
OldLastMapPtr   a4 4
        & 0
OldLastIndDiscAdd a4 4
        & 0
LastFilePtr     a4 4
        & 0
LastMapPtr      a4 4
        & 0
LastIndDiscAdd  a4 4
        & 0


PreferredDisc           # 1     ; Disc to use after canonicalise disc name
                = &ff
Interlocks              # 1
                = NoOpenFloppy :OR: NoOpenWinnie
d144 1
a144 2
;DONT CHANGE THESE TWO MAKES LSR #30 TRICK WORK
WinnieLock      bit 0
d146 3
a148 6

;DONT CHANGE THESE TWO MAKES LSR #28 TRICK WORK
NoOpenWinnie    bit 2   ; Means: nothing open on winnie, so don't winnie BackgroundOp
NoOpenFloppy    bit 3   ; Means: nothing open on floppy, so don't floppy BackgroundOp

FileCacheLock   bit 4   ; Means: foreground is playing with the filecache, so hands off background!
d150 1
a150 21
TimerLock       bit 6   ; Means: Ticker event is currently processing BackgroundOps


FiqOwnership            # 1
                = 0
BackgroundFiqLock       # 1     ;set to &FF to stop attempts to claim FIQ
                = 0

; One free space map is 'locked' at any time. When a map is locked the disc to
; which it belongs is locked in its drive. The locked map may or not be being
; modified. If being modified ModifyDisc will have the disc number in it,
; otherwise it will be &ff. When no map is being read/modified these
; map-specific values are set to &ff:
LockedDrive             # 1     ;Must be in same word for atomic write
                = &FF
LockedDisc              # 1
                = &FF
ModifyDisc              # 1     ; Disc whose map is unsafe due to being modifed or being read whilst disc is attached to drive
                = &FF
                        # 1     ;Not free for other use
                = &FF
d152 18
d171 2
a172 3

UpperCaseTable  a4 4
                & 0
d175 1
a175 3
        ASSERT {VAR}-DefGlobStart=SzDefGlobals

;INFO ON PARENT MODULE
d177 5
a181 5
ParentBase      # 4     ;base of parent module
ParentPrivate   # 4     ;ptr to private word of parent module
Floppies        # 1     ;# floppy drives
Winnies         # 1     ;# winnie drives
Drive           # 1     ;default drive
d184 1
a184 2
 [ :LNOT: DynamicMaps

d186 2
a187 4
FloppySizes     # 4     ; Must follow WinnieSizes for indexing purposes

 ]

d190 1
a190 1
FS_Title        # 4     ;FOLLOWING ARE STORED AS ABSOLUTE ADDRESSES
d197 1
a197 1
message_file_block a4 16 ; block for messagetrans
d199 1
a199 1
 [ NewErrors
d201 1
a201 1
 ]
d205 6
a210 6
 [ BigDir
Opt1Buffer      # BigDirMaxNameLen+1
 |
Opt1Buffer      # NameLen+1
                # 1             ; filler
 ]
d213 1
a213 2
RootCache       a4 CacheRootEnd

a214 3
ScatterPtr      a4 4  ;->Scatter block
ScatterAdd * 0
ScatterLen * 4
d216 3
a218 1
ScatterBlk      a4 8
d220 1
a220 1
;Critical subroutine management workspace
d222 2
a223 1
CriticalDepth   * 2     ;max levels of critical subroutine
d227 2
a228 2
CriticalSP1     a4 4
CriticalStack1  a4 (CriticalDepth+1)*4
d232 2
a233 2
CriticalSP2     a4 4
CriticalStack2  a4 (CriticalDepth+1)*4
d235 2
a236 2
CritDrvRec      a4 4
CritDiscRec     a4 4
d245 35
a279 50
WriteDisc               # 1     ;disc in use by put bytes or &FF so that floppy
                                ;write behind can't be unset if may add more
FileBufsStart           a4 4
FileBufsEnd             a4 0    ;Same as FloppyProcessBlk
FloppyProcessBlk        a4 4
WinnieProcessBlk        a4 4
BufHash                 a4 4

TickerState             # 4     ;bottom 16 bits period, top 16 bits counter


                ASSERT  YoungerBuf = OlderBuf + 4
ChainRootSz     *       2*4              ;older and younger link
BufChainsRoot           * @@-OlderBuf
                        a4 6*ChainRootSz ;roots of buffer allocation lists
 [ Dev
 ! 0, "BufChainsRoot = " :CC: :STR: :INDEX: BufChainsRoot
 ]

DirectError             a4 4    ;background error in direct transfer

CounterReadWs           a4 4
CounterReadCall         a4 4


 [ BigDisc
; Workspace for DoCompMoves

DoCompZoneBase	#	4
 ]


;Records
DrvRecs         a4 SzDrvRec*8
DiscRecs        a4 SzDiscRec*8
 [ Dev
 ! 0, "DrvRecs = " :CC: :STR: :INDEX: DrvRecs
 ]
 [ Dev
 ! 0, "DiscRecs = " :CC: :STR: :INDEX: DiscRecs
 ]

;Data move scatter list
ScatterMax      * 8                     ;max # (address,length) pairs in buffer
ScatterListLen  * ScatterMax*(4+4)

ScatterSource   a4 ScatterMax
ScatterList     a4 ScatterListLen
ScatterCopy     a4 ScatterListLen

d285 16
a300 12
 [ BigDir
DirBufferPtr	# 4	; pointer to dir buffer
DirBufferArea	# 4	; dynamic area number of dir buffer
DirBufferSize	# 4	; size of dir buffer
 |
DirBuffer       a4 DirBufSize
 ]

DirCache        # 0     ;MUST BE LAST
 [ Dev
 ! 0, "DirCache = " :CC: :STR: :INDEX: DirCache
 ]
d304 1
a304 1

@


4.11
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d76 1
a76 1
Density         # 1     ;1/2/4 single double quad
@


4.10
log
@Update to work with zero page relocation
Detail:
  s/FileCore, s/FileCore00, s/InitDieSvc - Try using OS_ReadSysInfo 6 to get IRQsema & CannotReset locations before falling back on legacy values. Store results in module workspace.
  s/FileCore05 - Commented out unused CheckEscape routine to avoid having to update it
  s/FileCore15 - Debugging code updated to use OS_ReadSysInfo 6 to fetch IRQsema ptr. Can't always rely on workspace version since workspace might not be set up yet.
  s/FileCore25, s/FileCore30, s/FileCore80 - Use IRQsema & CannotReset pointers from workspace
Admin:
  Tested on rev A2 BB-xM


Version 3.39. Tagged as 'FileCore-3_39'
@
text
@d46 2
a47 2
        Text    "FileCore"

d52 1
a52 1
        =       DevVersion," DEVELOPMENT VERSION"
@


4.9
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  Many of these are unaligned LDRs where only bits 0-7 of the result are used
  (tested against a bitmask or used as an input to the barrel shifter) but
  they have all been moved to byte operations because they are faster on
  ARMv6 and won't cause false positives if unaligned aborts are enabled.

  s.BigDirCode line 104: not wrong as such, but changed to use aligned LDR
    for speed on ARMv6.
  s.BigDirCode line 1727: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.Commands line 129: STR to an unaligned 1-byte variable. Harmless because
    all overlapping variables are initialised later on.
  s.Commands line 539: LDR of an unaligned 1-byte variable. Only used for
    testing bit 6.
  s.FileCore31 line 1359: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.FileCore32 lines 1483 and 1825: LDR of an unaligned 1-byte variable. Only
    used as input to shifter.
  s.FormSWIs line 1403: bugfix: incorrect load of 16-bit zone_spare field of
    disc record - uses lowsector and nzones fields instead! This is used to
    terminate the search of free space fragments within the allocation bytes
    of the current map block for the one containing a bad block found during
    formatting. Would manifest itself as a "Can't map defect out" error.
  s.GenSWIs lines 1182,1195: bugfix: LDR of 1-byte variables. Effect of this
    was that range-checking of the drive number passed to FileCore_MiscOp 5
    (eject) wasn't performed.
  Added ENTRY directive to permit building of GPA debug listing.
Admin:
  Builds, but untested.

Version 3.34. Tagged as 'FileCore-3_34'
@
text
@d762 3
@


4.8
log
@  GET file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both objasm and asasm.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 3.33. Not tagged
@
text
@d21 1
@


4.7
log
@* Various 32-bit compatibility fixes.
* Can use HAL for FIQ+timer manipulations.
* FileCore_DiscOp64 added (as user API - currently just converted to the
  standard byte or sector DiscOp call to the underlying module). See
  Doc.32bitAPIs for full details.
* New error-passing scheme to modules added (for full 32-bit addressing).
* FileCore_Features added (indicates new error scheme).
* OS_FSControl 49 (read 32-bit free space) now reports sensible clamped
  values for large discs, rather than values modulo 2^32.
* Accessing the end of files near 2GB in size could cause lock-ups in
  background transfers.
* F(+) and G(+) disc formats adjusted to have a little more skew to
  help the rather poor Iyonix floppy controller.

Version 3.31. Tagged as 'FileCore-3_31'
@
text
@d66 1
a66 1
        GET     s.Errors
@


4.6
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 3.29. Tagged as 'FileCore-3_29'
@
text
@d900 6
@


4.5
log
@HAL branch changes (to code to read Timer0) merged. Should still assemble
on non-HAL builds.

Version 3.28. Tagged as 'FileCore-3_28'
@
text
@d20 1
a20 2
        LEADR   Module_LoadAddr
org
a23 1
        ASSERT  {PC}-org=0
d25 6
a30 6
        & InitEntry       - org ;initialisation entry
        & DieEntry        - org
        & ServiceEntry    - org
        & Title           - org
        & HelpString      - org
        & ComTab          - org
d33 2
a34 2
        & SwiEntry        - org
        & SwiNames        - org
d37 1
a37 1
        & message_filename - org
d41 2
a42 2
        & ModFlags        - org
        ASSERT  {PC}-org=52
@


4.4
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d964 3
@


4.4.2.1
log
@Simple HAL changes to stop it accessing Timer0 directly. Nowhere near
actually accessing other than a RAM disc on a non-IOMD machine.

Version 3.25, 4.9.2.1. Tagged as 'FileCore-3_25-4_9_2_1'
@
text
@a963 3
CounterReadWs           a4 4
CounterReadCall         a4 4

@


4.3
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d43 2
a44 1
        ASSERT  {PC}-org=48
d60 7
a80 1
        [ NewFs
d84 1
a84 3
        |               ;file allocation
                # 3
        ]
a86 2
        [ NewFs
 [ Module_Version >= 205
a95 3
 |
                # 1
 ]
a98 3
        |
                # 4
        ]
a144 1
        [ NewFs
a146 3
        |
OldMapFlag              * 0
        ]
a183 1
        [ NewFs
a185 1
        ]
d196 1
a196 1
        MOV     SB, PC
d202 1
a202 2
        TEQP    PC,SB
        MOV     R0,R0
a229 1
 [ Module_Version >= 205
a232 5
 |
        ASSERT  SzDiscRec=36
        ADD$cond $Rptr,$Rindex,$Rindex,ASL #3   ;*9
        ADD$cond $Rptr,SB,$Rptr,ASL #2          ;SB+Rindex*SzDiscRec
 ]
d292 1
a292 1
        MOV     SB, PC
d298 1
a298 2
        TEQP    PC,SB
        MOV     R0,R0
a338 1
 [ Module_Version >= 205
a347 1
 ]
a388 1
        [ NewFs
a409 1
        ]
a597 1
 [ FileCache
a643 1
 ]
d647 1
a647 2
        ^ 0
 [ FileCache    ;FCB has header in common with file cache buffer
a657 1
 ]
a674 1
 [ FileCache
a680 1
 ]
a685 1
 [ FileCache
a688 1
 ]
a694 1
 [ FileCache
a697 2
 ]
 [ Module_Version >= 205
a698 1
 ]
a709 1
 [ FileCache
a725 1
 [ WinniesAsFloppies
a729 1
 ]
a743 1
 ]
a786 9
 [ :LNOT: FileCache
LockedDrive     # 1
        = &FF
FiqOwnership    # 1
        = 0
                # 2
        = 0,0
 ]

a814 1
        [ NewFs
a827 1
        ]
a828 1
        [ FileCache
a867 14
 [ WinniesAsFloppies
 |
FloppyWriteBehindDrive  # 1     ;Must be in same word for atomic write
                = &FF
FloppyWriteBehindDisc   # 1
                = &FF
                        # 2     ;Not free for other use
                = 0,0

FloppyWriteBehindLeft   a4 4
                & Nowt
 ]

       ]
a939 1
 [ FileCache
a962 2

 ]
@


4.2
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d119 1
a119 1
 [ BigDisc
d124 1
a124 1
 [ BigShare
d127 6
d134 9
a142 3
 ]
DiscRecSig2      # 0     ;above entries form signature of disc
 ]
d216 5
d224 1
d279 6
d286 1
d289 5
d295 1
d304 1
a304 2
 [ BigDisc
        ASSERT  SzDrvRec=24
d318 9
d329 1
a329 1
 |
d333 1
d542 76
d687 4
d692 1
d782 1
d850 8
d946 3
d952 2
d965 3
d970 1
d1061 5
d1067 1
@


4.1
log
@Initial revision
@
text
@d54 1
a54 1
        =       version," (",date,")"
d83 1
a83 1
 [ Version >= 205
d222 1
a222 1
 [ Version >= 205
d316 1
a316 1
 [ Version >= 205
d608 1
a608 1
 [ Version >= 205
@


4.1.4.1
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@d119 1
a119 1
  [ BigDisc
d124 1
a124 1
   [ BigShare
a126 5

    [ BigMaps
Zones2		# 1	; high byte of number of zones
SharePad	# 1	; padding
    |
d128 3
a130 9
    ]
    
    [ BigDir
DiscVersion	# 4	; version number of disc format
    ]
 
   ]
DiscRecSig2     # 0     ;above entries form signature of disc
  ]
a203 14
   [ BigDir
    [ $Rptr <> $Rindex
   	ASSERT	SzDiscRec=52
   	ADD$cond $Rptr, $Rindex, $Rindex, ASL #1 ;*3
   	ADD$cond $Rptr, $Rindex, $Rptr, ASL #2   ;3*4+1=13
   	ADD$cond $Rptr, SB, $Rptr, ASL #2
    |
    	Push "SB"
   	ADD$cond SB, $Rindex, $Rindex, ASL #1    ;*3
   	ADD$cond $Rptr, $Rindex, SB, ASL #2      ;3*4+1=13
    	Pull "SB"
    	ADD$cond $Rptr, SB, $Rptr, ASL #2
    ]
   |
a206 1
   ]
a501 54
 [ BigDir
; SBP: 28 Aug 1997: Added new directory type, known as 'big'

; Big directory header
	^ 0

BigDirStartMasSeq	# 1	; master sequence number
BigDirVersion		# 3	; directory version number
BigDirStartName		# 4	; 'SBPr'
BigDirNameLen		# 4	; Length of the directory's name
BigDirSize		# 4	; Length of the directory
BigDirEntries		# 4	; Number of entries in a directory
BigDirNamesSize		# 4	; number of bytes allocated for names
BigDirParent		# 4	; indirect disc address of parent directory
BigDirName		# 0	; start of the dir name
BigDirHeaderSize	# 0	; size of the header

; Big directory entry

	^ 0

BigDirEntryName		# 4	; 'DirE'
BigDirLoad		# 4	; load address of object
BigDirExec		# 4	; exec address of object
BigDirLen		# 4	; length of object
BigDirIndDiscAdd	# 4	; indirect disc address of object
BigDirAtts		# 4	; attributes of object
BigDirObNameLen		# 4	; length of object name
BigDirOnNamePtr		# 4	; offset into name heap for name
BigDirEntrySize		# 0	; size of entry

; Big directory name heap entry

	^ 0

BigDirHeapName		# 4	; 'Name'
BigDirHeapIndDiscAdd	# 4	; copy of indirect disc address
BigDirHeapObName	# 0	; name of file (padded with nulls to word boundary)
BigDirHeadHeaderSize	# 0	; size of the header for a name heap entry

; Big directory tail

	^ 0

BigDirEndName		# 4	; 'oven'
BigDirEndMasSeq		# 1	; to match with BigDirStartMasSeq
BigDirEndReserved	# 2	; reserved, must be 0
BigDirCheckByte		# 1	; check byte on directory

; other useful definitions for big directories

BigDirMaxNameLen	* 255   ; maximum name length is 255 chars

 ]
@


4.1.4.2
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@a136 1
RootDirSize	# 4	; size of root dir
d138 1
d216 12
a227 3
      ASSERT	SzDiscRec=56
      RSB$cond 	$Rptr, $Rindex, $Rindex, ASL #3 ;*7
      ADD$cond 	$Rptr, SB, $Rptr, ASL #3	 ;7*8=56
d556 1
a556 1
BigDirObNamePtr		# 4	; offset into name heap for name
d566 1
a566 1
BigDirHeapHeaderSize	# 0	; size of the header for a name heap entry
a570 15
			# -1
			
BigDirCheckByte		# 0

			# -2	; reserved
			
			# -1
			
BigDirEndMasSeq		# 0

			# -4
			
BigDirEndName		# 0	; 'oven'

BigDirTailSize		* -@@
d572 4
a575 3
 [ Dev
 ! 0, "BigDirTailSize = " :CC: :STR: BigDirTailSize
 ]
a580 3
BigDirMinSize		* 2048
BigDirMaxSize		* 4*1024*1024

a650 4
 [ BigDir
	ASSERT	BigDirMaxNameLen<=258
FcbName		# 258	; make sure aligned
 |
a651 1
 ]
a909 3
 [ BigDir
Opt1Buffer      # BigDirMaxNameLen+1
 |
a911 1
 ]
a1001 5
 [ BigDir
DirBufferPtr	# 4	; pointer to dir buffer
DirBufferArea	# 4	; dynamic area number of dir buffer
DirBufferSize	# 4	; size of dir buffer
 |
a1002 1
 ]
@


4.1.4.3
log
@Altered directory format (change backup dir entries to be one word instead
of an entire copy of the entry).  Also reduced size of a directory entry
by one word.  Also fixed a number of small bugs.
@
text
@a539 1
 [ {FALSE}
a540 1
 ]
a549 2

 [ {FALSE}
a557 1
 ]
@


4.1.4.4
log
@Fixed s.BigDirCode (GrowBigDir and ShrinkBigDir) to cope with BitSize<SecSize
and rewrote free space map memory management to place free space maps in
dynamic areas.
@
text
@a277 6
 [ DynamicMaps
DrvsFsMapAddr	aw 4	;ptr to free space map
DrvsFsMapArea	aw 4	;dynamic area number
DrvsFsMapSize	aw 4	;size of the map
DrvsFsMapFlags	aw 4	;flags for the map
 |
a278 1
 ]
a280 4
FsMapMaxSize	* 4*1024*1024
 [ DynamicMaps
NewHiFsBits     * BadFs :OR: EmptyFs
 |
a281 1
 ]
d290 2
a291 1
 
a304 9

 [ DynamicMaps
 	ASSERT	SzDrvRec=36
 	ADD$cond	$Rptr, $Rindex, $Rindex, LSL #3
 	ADD$cond	$Rptr, SB, $Rptr, LSL #2
 |
 
   [ BigDisc
        ASSERT  SzDrvRec=24
d307 1
a307 1
   |
a310 1
   ]
a757 1
 
a913 3

 [ :LNOT: DynamicMaps

a915 2

 ]
@


4.1.4.5
log
@Now supports formatting of floppies with long file names.
@
text
@a126 1
BigFlagBit	* 1	; bit for the big flag
d194 1
a194 1
 
d686 1
a686 1
	ASSERT	BigDirMaxNameLen<=255
@


4.1.4.6
log
@Fixed:

DoOsFunRenameBigDir to work when renaming a shared file between dirs where
the file ends up as the last object in the target dir.

SanityCheckEDiscRecord to allow idlen>15 when DiscVersion=0

GrowBigDir to round up desired size to a multiple of the disc allocation
size.

Also:

Implemented non-working code to write cache the dir buffer.  WriteCacheDir
compile switch set to FALSE in s.DebugOpts.  Don't set it to TRUE unless
I tell you it's working.

Made SortDir not attempt to sort more than 2047 entries in a dir, to
avoid it overflowing ScratchSpace.

Made SortPair do one extra shell on the sort (makes it more efficient).
@
text
@d135 1
a135 1

d195 1
a195 1

d303 1
a303 1

d323 1
a323 1

d590 1
a590 1

d594 1
a594 1

d596 1
a596 1

d600 1
a600 1

d780 1
a780 1

a847 8

 [ WriteCacheDir
BufDirDirty	a4 4
	& 0
BufDirDirtyBit * 1
ModifiedZones	a4 4
	& 0
 ]
@


4.1.4.7
log
@Binary-chop dir scanning fixed.  (BigLexEqv fixed so that it doesn't
try to compare the dir separator '.' in eg "Default.Thing" with another
object called "Default+" (was breaking binary chop dir search).

Fixed IdentifyDisc (s.Identify); old behaviour left the RootDir field
invalid (the disc bits were an external drive number, instead of an
internal disc number).  This causes problems if the disc fails to mount
due to, for example, memory problems, as the illegal value never gets
fixed (normally, MountDiscOnDrive would end up correcting the problem).
@
text
@a290 1
MemErrorFs bit 29	;set if failed to load FSmap due to errors with dynamic areas
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.15;
access;
symbols
	FileCore-3_75:4.15
	FileCore-3_74:4.15
	FileCore-3_73:4.15
	FileCore-3_72:4.15
	FileCore-3_71:4.15
	FileCore-3_70:4.15
	FileCore-3_69:4.15
	FileCore-3_68:4.15
	FileCore-3_67:4.15
	FileCore-3_66:4.15
	FileCore-3_65:4.15
	FileCore-3_64:4.15
	FileCore-3_63:4.15
	FileCore-3_62:4.14
	FileCore-3_61:4.14
	FileCore-3_60:4.14
	FileCore-3_59:4.14
	FileCore-3_58:4.14
	FileCore-3_57:4.14
	FileCore-3_56:4.14
	FileCore-3_55:4.14
	FileCore-3_54:4.13
	FileCore-3_53:4.12
	FileCore-3_52:4.12
	FileCore-3_51:4.12
	FileCore-3_50:4.12
	FileCore-3_49:4.12
	FileCore-3_48:4.12
	FileCore-3_47:4.12
	FileCore-3_46:4.12
	FileCore-3_45:4.11
	FileCore-3_44:4.10
	FileCore-3_43:4.8
	FileCore-3_42:4.8
	FileCore-3_41:4.8
	FileCore-3_40:4.8
	FileCore-3_39:4.7
	FileCore-3_38:4.7
	FileCore-3_37:4.7
	FileCore-3_36:4.7
	FileCore-3_35:4.7
	FileCore-3_34:4.7
	FileCore-3_33:4.6
	RO_5_07:4.6
	FileCore-3_32:4.6
	FileCore-3_31:4.6
	FileCore-3_30:4.5
	FileCore-3_29:4.5
	FileCore-3_28:4.5
	FileCore-3_25-4_9_2_2:4.4
	FileCore-3_27:4.5
	FileCore-3_26:4.4
	FileCore-3_22-4_6_2_1:4.3
	bavison_FileCore-3_22_dev_bp:4.3
	bavison_FileCore-3_22:4.3.0.2
	FileCore-3_25-4_9_2_1:4.4
	HAL:4.4.0.2
	FileCore-3_25:4.4
	FileCore-3_24:4.4
	FileCore-3_23:4.4
	dellis_autobuild_BaseSW:4.3
	FileCore-3_22:4.3
	Ursula_merge:4.2.2.5
	ROL_merge:4.2.2.5
	FileCore-3_21:4.3
	ROL_Ursula_merge:4.2.2.5
	Ursula_RiscPC_merge:4.2.2.4
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.5
	ROL_FileCore-3_21:4.2.2.5
	ROL_FileCore-3_20:4.2.2.5
	ROL:4.2.2.5.0.2
	ROL_bp:4.2.2.5
	Ursula_RiscPC_bp:4.2.2.4
	FileCore-3_18:4.2.2.5
	FileCore-3_01:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.4
	Ursula_RiscPC:4.2.2.4.0.2
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.2.2.5
	sproven_FileCore-3_16:4.2.2.5
	rthornb_UrsulaBuild-19Aug1998:4.2.2.4
	UrsulaBuild_FinalSoftload:4.2.2.4
	rthornb_UrsulaBuild-12Aug1998:4.2.2.4
	aglover_UrsulaBuild-05Aug1998:4.2.2.4
	rthornb_UrsulaBuild-29Jul1998:4.2.2.4
	rthornb_UrsulaBuild-22Jul1998:4.2.2.4
	rthornb_UrsulaBuild-15Jul1998:4.2.2.4
	rthornb_UrsulaBuild-07Jul1998:4.2.2.4
	rthornb_UrsulaBuild-17Jun1998:4.2.2.4
	rthornb_UrsulaBuild-03Jun1998:4.2.2.4
	rthornb_UrsulaBuild-27May1998:4.2.2.4
	rthornb_UrsulaBuild-21May1998:4.2.2.4
	sproven_FileCore-3_15:4.2.2.4
	sproven_314:4.2.2.4
	rthornb_UrsulaBuild_01May1998:4.2.2.3
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.2.2.3
	sproven_3_11:4.2.2.3
	sproven_3_10:4.2.2.3
	sproven_Ursula_3_09:4.2.2.3
	sproven_3_07:4.2.2.3
	sproven_3_06:4.2.2.3
	sproven_3_05:4.2.2.2
	sproven_3_04:4.2.2.2
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.2.2.2
	sproven_3_02:4.2.2.2
	sproven_3_01:4.2.2.2
	sproven_2_99:4.2.2.1
	sproven_2_98:4.2
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2013.07.20.14.10.03;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	qZtNVkGjzh5uqdYw;

4.14
date	2013.02.21.16.53.08;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	CCuV2tngKttj75Fw;

4.13
date	2012.10.28.08.52.32;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	6n5fY77YU7JEb8qw;

4.12
date	2011.11.25.08.26.06;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	IoNdwgrOKH29UGIv;

4.11
date	2011.10.14.07.23.52;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	D2Id4aPp4zmuUhDv;

4.10
date	2011.10.12.20.26.44;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	nrcVVV9gEnMYi6Dv;

4.9
date	2011.10.12.20.21.50;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	BoinxgqWMKLth6Dv;

4.8
date	2011.09.12.19.45.09;	author bavison;	state Exp;
branches;
next	4.7;
commitid	hf8KRMduNnpH2fzv;

4.7
date	2009.06.15.23.25.35;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2003.04.03.18.33.28;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2001.03.01.13.38.55;	author sforrest;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.11.37.00;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.01.06.13.47.29;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.32.24;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.08.14.13.13.16;	author sproven;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.09.16.14.46.48;	author sproven;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	98.01.19.12.26.41;	author sproven;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	98.05.07.16.58.15;	author sproven;	state Exp;
branches;
next	4.2.2.5;

4.2.2.5
date	98.09.02.16.15.05;	author sproven;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.32.24;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.39.40;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.21;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.13;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.15
log
@Add support for 2k and 4k sector sizes
s/Commands:
Make sure the defect list (via *DEFECT) does a read/modify/write of the boot block on 2k and 4k drives.
The checksum generation code was largely common and although commented to be called as though it was common wasn't actually due to a cut and paste mistake on label 37. Deleted common/uncalled code.
s/DebugOpts; s/FileCore15:
Peripheral changes.
s/FileCore20:
Read in the defect list via an intermediate buffer then copy out into the dynamic area.
s/FileCore70:
Declare the buffer size as 4k to FileSwitch, internally FileCore expresses this in a single byte * 32 so is now at the limit of the range of FcbBufSz.
s/FileCore80:
Perform transfers in the foreground when the sector size exceeds FileCore's 1k buffers. It's not worth bothering.
s/FormSWIs; s/Identify:
Vet and reject attempts to layout invalid zone/sector size combos (see Doc/1Zone).
Doc/MiscOp:
Correct a couple of calculation mistakes.
Doc/1Zone:
New documentation detailing the possible valid combinations of a 1 zone fixed disc, and why for 2k and 4k sectors this is rejected.
Test/BigSectors:
Patch to apply to RAMFS to make it a 4k filing system. Note, the smallest 2 zone RAM disc with 4k sectors is 4052kB, in which case the map is at +3F0000; copy at +3F2000; root directory object at +3F4000.

Version 3.63. Tagged as 'FileCore-3_63'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; MultiFS format specific SWIs supplied by FileCore

; These SWIs are *NOT* considered 'inside' FileCore for the purposes of
; reentrance prohibition.


; entry: r0 = pointer to disc format structure to be filled in
;        r1 = SWI to vet the format
;        r2 = parameter to the vetting SWI
;        r3 = format specifier

; exit:  V, r0=error
;   or:  regs preserved
DoSwiDiscFormat ROUT
        Push    "r0-r11,lr"

        ; Check the specified format is one we know about
        TEQ     r3, #Format_Floppy :OR: Format_L
        TEQNE   r3, #Format_Floppy :OR: Format_D
        TEQNE   r3, #Format_Floppy :OR: Format_E
        TEQNE   r3, #Format_Floppy :OR: Format_F
        TEQNE   r3, #Format_Floppy :OR: Format_G
        MOVNE   r0, #BadParmsErr
        BNE     %FT90

        ; Choose the parameter block for the format specifier
        TEQ     r3, #Format_Floppy :OR: Format_L
        ADREQ   r4, FormatLFloppyPhysParams
        TEQ     r3, #Format_Floppy :OR: Format_D
        ADREQ   r4, FormatDFloppyPhysParams
        TEQ     r3, #Format_Floppy :OR: Format_E
        ADREQ   r4, FormatEFloppyPhysParams
        TEQ     r3, #Format_Floppy :OR: Format_F
        ADREQ   r4, FormatFFloppyPhysParams
        TEQ     r3, #Format_Floppy :OR: Format_G
        ADREQ   r4, FormatGFloppyPhysParams

        ; Fill in the disc format structure
        ASSERT  SzFormatBlock = 16*4
        MOV     lr, r4
        MOV     r11, r0
        LDMIA   lr!, {r5-r8}
        STMIA   r11!, {r5-r8}
        LDMIA   lr!, {r5-r8}
        STMIA   r11!, {r5-r8}
        LDMIA   lr!, {r5-r8}
        STMIA   r11!, {r5-r8}
        LDMIA   lr!, {r5-r8}
        STMIA   r11!, {r5-r8}

        ; Call the vetting SWI
        MOV     r11, r1
        MOV     r1, r2
        BL      CallASwi
        BVS     %FT95

        ; Check the record is still OK

        ; We care about:
        ; sector size
        ; sectors per track
        ; density
        ; options
        ; start sector
        ; tracks to format
        ; The rest is not critical to the operation of this format
        LDR     r1, [r0, #FormatSectorSize]
        LDR     r2, [r4, #FormatSectorSize]
        TEQ     r1, r2
 [ DebugO
 BEQ    %FT01
 DLINE  "Fail at A"
01
 ]
        LDREQB  r1, [r0, #FormatSectorsPerTrk]
        LDREQB  r2, [r4, #FormatSectorsPerTrk]
        TEQEQ   r1, r2
 [ DebugO
 BEQ    %FT01
 DLINE  "Fail at B"
01
 ]
        LDREQB  r1, [r0, #FormatDensity]
        LDREQB  r2, [r4, #FormatDensity]
        TEQEQ   r1, r2
 [ DebugO
 BEQ    %FT01
 DLINE  "Fail at C"
01
 ]
        LDREQB  r1, [r0, #FormatOptions]
        LDREQB  r2, [r4, #FormatOptions]
        EOREQ   lr, r1, r2
        BICEQ   lr, lr, #FormatOptIndexMark
        TEQEQ   lr, #0
 [ DebugO
 BEQ    %FT01
 DLINE  "Fail at D"
01
 ]
        LDREQ   r1, [r0, #FormatTracksToFormat]
        LDREQ   r2, [r4, #FormatTracksToFormat]
        TEQEQ   r1, r2
 [ DebugO
 BEQ    %FT01
 DLINE  "Fail at E"
01
 ]

        ; If any NE then format's not acceptable
        MOVNE   r0, #BadParmsErr
        MOVEQ   r0, #0

        ; return
90
        BL      SetVOnR0
95
        STRVS   r0, [sp]
        Pull    "r0-r11, pc"

FormatLFloppyPhysParams
        DCD     256     ; Sector Size
        DCD     42      ; Gap 1, side 0
        DCD     42      ; Gap 1, side 1
        DCD     57      ; Gap 3
        DCB     16      ; Sectors per track
        DCB     DensityDouble
        DCB     FormatOptSequenceSides
        DCB     0       ; LowSector
        DCB     0       ; Interleave
        DCB     0       ; Side/Side sector skew
        DCB     0       ; Track/Track sector skew
        DCB     &A5     ; Fill value
        DCD     160     ; Tracks to format (2 sides of 80 tracks)
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill

FormatDFloppyPhysParams
FormatEFloppyPhysParams
        DCD     1024    ; Sector Size
        DCD     32+271  ; Gap 1, side 0
        DCD     32+0    ; Gap 1, side 1
        DCD     90      ; Gap 3
        DCB     5       ; Sectors per track
        DCB     DensityDouble
        DCB     FormatOptInterleaveSides
        DCB     0       ; LowSector
        DCB     0       ; Interleave
        DCB     0       ; Side/Side sector skew
        DCB     0       ; Track/Track sector skew
        DCB     &A5     ; Fill value
        DCD     160     ; Tracks to format (2 sides of 80 tracks)
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill

FormatFFloppyPhysParams
        DCD     1024    ; Sector Size
        DCD     50      ; Gap 1, side 0
        DCD     50      ; Gap 1, side 1
        DCD     90      ; Gap 3 - large to allow head switching between sectors and for greater reliability
        DCB     10      ; Sectors per track
        DCB     DensityQuad
        DCB     FormatOptInterleaveSides
        DCB     0       ; LowSector
        DCB     0       ; Interleave
 [ ExtraSkew
        DCB     1       ; Side/Side sector skew - enough for Iyonix controller set-up
        DCB     3       ; Track/Track sector skew - enough for head settle + set-up
 |
        DCB     0       ; Side/Side sector skew
        DCB     2       ; Track/Track sector skew - enough for head settle
 ]
        DCB     &A5     ; Fill value
        DCD     160     ; Tracks to format (2 sides of 80 tracks)
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill

FormatGFloppyPhysParams
        DCD     1024    ; Sector Size
        DCD     50      ; Gap 1, side 0
        DCD     50      ; Gap 1, side 1
        DCD     90      ; Gap 3 - large to allow head switching between sectors and for greater reliability
        DCB     20      ; Sectors per track
        DCB     DensityOctal
        DCB     FormatOptInterleaveSides
        DCB     0       ; LowSector
        DCB     0       ; Interleave
 [ ExtraSkew
        DCB     1       ; Side/Side sector skew - enough for Iyonix controller set-up
        DCB     5       ; Track/Track sector skew - enough for head settle + set-up
 |
        DCB     0       ; Side/Side sector skew
        DCB     4       ; Track/Track sector skew - enough for head settle
 ]
        DCB     &A5     ; Fill value
        DCD     160     ; Tracks to format (2 sides of 80 tracks)
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill
        DCD     0       ; Fill


; ====================
; DoSwiLayoutStructure
; ====================

; entry: R0 = identifier of particular disc structure to lay down
;               (R5 from Service_IdentifyFormat)
;               (pointer to a disc record (in ROM))
;        R1 = Pointer to bad block list
;        R2 = Pointer to nul terminated disc name
;        R3 = FileSwitch file handle of image

; exit:  Error possible, regs preserved

; The disc size filled in on the disc is the size of the
; image file. The disc size in the supplied disc record
; determines the amount of accessible disc (the remainder
; being mapped out as bad blocks).

        ^       0, sp
LayoutDiscRec   #       SzDiscRec
LayoutSz        *       :INDEX:{VAR}

DoSwiLayoutStructure ROUT
        Push    "r0-r11,lr"

 [ DebugO
 MOV    r11, sp
 DREG   r11, "sp in is "
 ]

        SUB     sp, sp, #LayoutSz

        ; Make a copy of the disc record on the stack
        ASSERT  SzDiscRecSig = 8*4
        ADR     r8, LayoutDiscRec

        LDMIA   r0!, {r4-r7}
        STMIA   r8!, {r4-r7}
        LDMIA   r0!, {r4-r7}
        STMIA   r8!, {r4-r7}

 [ BigMaps :LOR: BigDir
        ASSERT  DiscRecord_BigMap_DiscSize2-SzDiscRecSig=4
        ASSERT  SzDiscRecSig2-DiscRecord_BigMap_DiscSize2=4*4

        ; copy extra fields
        ADD     r8, r8, #4
        ADD     r0, r0, #4
        LDMIA   r0!, {r4-r7}
        STMIA   r8!, {r4-r7}
 ]

        ; If density=0 or zones>1 then must have a boot block
        LDRB    lr, LayoutDiscRec + DiscRecord_Density
        RSBS    lr, lr, #1
 [ BigMaps
        LDRLSB  lr, LayoutDiscRec + DiscRecord_NZones
        LDRLSB  r0, LayoutDiscRec + DiscRecord_BigMap_NZones2   ; top byte of zones number
        ADDLS   lr, lr, r0, LSL #8
 |
        LDRLSB  lr, LayoutDiscRec + DiscRecord_NZones
 ]
  [ DebugO
        DREG    lr, "zones from rec: "
  ]

        CMPLS   lr, #1
        ADR     r0, LayoutDiscRec
        BLHI    LayoutBootBlock

 [ DebugO
 BVS    %FT01
 DLINE  "LayoutBootBlock went OK"
01
 ]

        BLVC    LayoutFreeSpaceMap

 [ DebugO
 BVS    %FT01
 DLINE  "LayoutFreeSpaceMap went OK"
01
 ]

        BLVC    LayoutRootDir

 [ DebugO
 BVS    %FT01
 DLINE  "LayoutRootDir went OK"
01
 ]

        ; return
95
        ADD     sp, sp, #LayoutSz
 [ DebugO
 MOV    r11, sp
 DREG   r11, "sp out is "
 ]
        STRVS   r0, [sp]
        Pull    "r0-r11, pc"

        LTORG

; ===============
; LayoutBootBlock
; ===============

; entry: r0 = pointer to disc record
;        r1 = Pointer to bad block list
;        r2 = Pointer to nul terminated disc name
;        r3 = FileSwitch file handle of image

; exit:  Boot block laid out

LayoutBootBlock ROUT
        Push    "r0-r5,lr"

    [ BigSectors
        ; Check the zones and sector size don't result in an invalid combination
      [ BigMaps
        LDRB    r4, [r0, #DiscRecord_NZones]
        LDRB    r14, [r0, #DiscRecord_BigMap_NZones2]
        ADD     r4, r4, r14, LSL #8
      |
        LDRB    r4, [r0, #DiscRecord_NZones]
      ]
        TEQ     r4, #1
        BNE     %FT10                   ; Not the 1 zone case, all combinations valid

        LDRB    r4, [r0, #DiscRecord_Log2SectorSize]
        CMP     r4, #10
        MOVHI   r0, #MapFullErr         ; For 2k and 4k the map overlaps the boot block
        BHI     %FT90
        BCC     %FT10                   ; 256 & 512 are always safe
      [ BigDir
        LDR     r14, [r0, #DiscRecord_BigDir_DiscVersion]
        TEQ     r14, #0
        MOVEQ   r0, #DirFullErr         ; For 1k new dirs the root dir overlaps the boot block
        BEQ     %FT90                   ; while big dirs are OK as the root is in another object
      |
        MOV     r0, #DirFullErr
        B       %FT90
      ]
10
    ]
        ; Somewhere to construct the boot block
        MOV     r4, #ScratchSpace

        ; Zero out the area
        MOV     lr, #0
        ADD     r5, r4, #SzDefectList
10
        STR     lr, [r5, #-4]!
        CMP     r5, r4
        BHI     %BT10

        ; Copy the defect list
        MOV     r5, #0
10
        LDR     lr, [r1, r5]
        STR     lr, [r4, r5]
        CMP     lr, #DefectList_End
        ADDLO   r5, r5, #4
        CMPLO   r5, #SzDefectList - MaxStruc
        BLO     %BT10

 [ BigDisc
        ; if there's a second defect list present, then do it
        LDRB    lr, [r0, #DiscRecord_BigMap_Flags]
        TSTS    lr, #DiscRecord_BigMap_BigFlag
        BEQ     %FT15                   ; no second defect list
12
        LDR     lr, [r1, r5]
        STR     lr, [r4, r5]
        CMP     lr, #DefectList_BigMap_End
        ADDLO   r5, r5, #4
        CMPLO   r5, #SzDefectList - MaxStruc
        BLO     %BT12

15
 ]

        ; Check for too many defects
        CMP     r5, #SzDefectList - MaxStruc
        MOVHS   r0, #TooManyDefectsErr
        BHS     %FT90

        ; Construct defect list check byte
        MOV     r1, #0
        MOV     r5, r4
20
        LDR     lr, [r5], #4
        TSTS    lr, #DefectList_End
        EOREQ   r1, lr, r1, ROR #13
        BEQ     %BT20
        EOR     r1, r1, r1, LSR #16
        EOR     r1, r1, r1, LSR #8
        STRB    r1, [r5, #-4]

 [ BigDisc
        ; check again for presence of the second defect list
        LDRB    lr, [r0, #DiscRecord_BigMap_Flags]
        TSTS    lr, #DiscRecord_BigMap_BigFlag
        BEQ     %FT30                   ; no second defect list

        MOV     r1, #0
        MOV     r5, r4
25
        LDR     lr, [r5], #4
        TSTS    lr, #DefectList_BigMap_End
        EOREQ   r1, lr, r1, ROR #13
        BEQ     %BT25
        EOR     r1, r1, r1, LSR #16
        EOR     r1, r1, r1, LSR #8
        STRB    r1, [r5, #-4]

30
 ]
        ; Copy the disc record fields of relevance
        ASSERT  DiscRecord_Log2SectorSize :MOD: 4 = 0
        ASSERT  DiscRecord_SecsPerTrk = DiscRecord_Log2SectorSize + 1
        ASSERT  DiscRecord_Heads = DiscRecord_SecsPerTrk + 1
        ASSERT  DiscRecord_Density = DiscRecord_Heads + 1
        LDR     lr, [r0, #DiscRecord_Log2SectorSize]
        STR     lr, [r4, #DefectStruc + DiscRecord_Log2SectorSize]
        LDRB    lr, [r0, #DiscRecord_IdLen]
        STRB    lr, [r4, #DefectStruc + DiscRecord_IdLen]
        LDRB    lr, [r0, #DiscRecord_Log2bpmb]
        STRB    lr, [r4, #DefectStruc + DiscRecord_Log2bpmb]
        LDRB    lr, [r0, #DiscRecord_Skew]
        STRB    lr, [r4, #DefectStruc + DiscRecord_Skew]
        ASSERT  DiscRecord_LowSector :MOD: 4 = 0
        ASSERT  DiscRecord_NZones = DiscRecord_LowSector + 1
        ASSERT  DiscRecord_ZoneSpare = DiscRecord_NZones + 1
        LDR     lr, [r0, #DiscRecord_LowSector]
        STR     lr, [r4, #DefectStruc + DiscRecord_LowSector]
        LDR     lr, [r0, #DiscRecord_Root]
 [ DebugL
        DREG    lr, "Setting RootDir to (FormSWIs/LayoutBootBlock): "
 ]
        STR     lr, [r4, #DefectStruc + DiscRecord_Root]

 [ BigDisc
        ; Make sure the DiscSize2 field is zero for people trying to lay out things smaller
        ; than 4GB (and for OS_Args). The accurate size is fixed up in LayoutFreeSpaceMap later.
        MOV     r2, #0
        STR     r2, [r4, #DefectStruc + DiscRecord_BigMap_DiscSize2]

        LDR     lr, [r0, #DiscRecord_BigMap_ShareSize]
        STR     lr, [r4, #DefectStruc + DiscRecord_BigMap_ShareSize]
 ]

 [ BigMaps
        LDR     lr, [r0, #DiscRecord_BigDir_DiscVersion]
        STR     lr, [r4, #DefectStruc + DiscRecord_BigDir_DiscVersion]
 ]

 [ BigDir
        ; we don't copy the RootSize field into the boot block as the boot
        ; block should only be being used to locate the disc record in the map
 ]

        ; Obtain the 'Disc' size
        MOV     r0, #OSArgs_ReadEXT
        MOV     r1, r3
        BL      DoXOS_Args
        BVS     %FT95
        STR     r2, [r4, #DefectStruc + DiscRecord_DiscSize]
 [ DebugO
        DREG    r2, "Disc size in LayoutBootBlock is:"
 ]
        ; Fill in the boot block check byte
        MOV     r0, r4
        MOV     r1, #SzDefectList
        BL      CheckSum
        SUB     r1, r1, #1
        STRB    r2, [r4, r1]

        ; Write the boot block
        MOV     r0, #OSGBPB_WriteAtGiven
        MOV     r1, r3
        MOV     r2, #ScratchSpace
        MOV     r3, #SzDefectList
        MOV     r4, #DefectListDiscAdd
 [ DebugO
 DREG   r0,"OS_GBPB(",cc
 DREG   r1,",",cc
 DREG   r2,",",cc
 DREG   r3,",",cc
 DREG   r4,",",cc
 DLINE  ")"
 ]
        BL      DoXOS_GBPB
        BVS     %FT95

        MOV     r0, #0
90
        BL      SetVOnR0
95
        STRVS   r0, [sp]
        Pull    "r0-r5,pc"

; ==================
; LayoutFreeSpaceMap
; ==================

; entry: r0 = pointer to disc record
;        r1 = Pointer to bad block list
;        r2 = Pointer to nul terminated disc name
;        r3 = FileSwitch file handle of image

; exit:  Free space map laid out

LayoutFreeSpaceMap ROUT
        Push    "r0-r10,lr"

 [ DebugO
 DREG   r0, ">LayoutFreeSpaceMap(",cc
 DREG   r1, ",",cc
 DREG   r2, ",",cc
 DREG   r3, ",",cc
 DLINE  ")"
 ]

        ; r5 = disc record; r6 = nzones
        MOV     r5, r0
 [ BigMaps
        LDRB    r6, [r5, #DiscRecord_NZones]
        LDRB    lr, [r5, #DiscRecord_BigMap_NZones2]
        ORR     r6, r6, lr, LSL #8
 |
        LDRB    r6, [r5, #DiscRecord_NZones]
 ]
        TEQ     r6, #0
        BNE     %FT20

        ; 0 zones - must be old map
 [ DebugO
 DLINE  "Old map"
 ]

        ; Somewhere to construct the free space blocks
        MOV     r4, #ScratchSpace

        ; Zero out the area
        MOV     lr, #0
        ADD     r3, r4, #SzOldFs
10
        STR     lr, [r3, #-4]!
        CMP     r3, r4
        BHI     %BT10

        ; Obtain the 'Disc' size
        MOV     r0, #OSArgs_ReadEXT
        LDR     r1, [sp, #3*4]
        BL      DoXOS_Args
        BVS     %FT95

        ; Store the disc size
        MOV     r2, r2, LSR #8
        ASSERT  OldSize :MOD: 4 = 0
        STR     r2, [r4, #OldSize]

        ; If 1 head and
        ;    double density and
        ;    256 byte sectors and
        ;    lowsector = SequenceSides then must be L format
        LDRB    lr, [r5, #DiscRecord_Heads]
        TEQ     lr, #1
        LDREQB  lr, [r5, #DiscRecord_Density]
        TEQEQ   lr, #DensityDouble
        LDREQB  lr, [r5, #DiscRecord_Log2SectorSize]
        TEQEQ   lr, #8
        LDREQB  lr, [r5, #DiscRecord_LowSector]
        TEQEQ   lr, #DiscRecord_SequenceSides_Flag

        ; Set first free space to be beyond the first directory
        SUBEQ   r2, r2, #(OldDirSize + L_Root) :SHR: 8
        SUBNE   r2, r2, #(NewDirSize + D_Root) :SHR: 8
        ASSERT  FreeLen :MOD: 4 = 0
        STR     r2, [r4, #FreeLen]
        MOVEQ   r2, #(OldDirSize + L_Root) :SHR: 8
        MOVNE   r2, #(NewDirSize + D_Root) :SHR: 8
        BEQ     %FT15

        ASSERT  DefectListDiscAdd = NewDirSize + D_Root

        ; If density == 0 (hard disc) then there's a boot block to leave space for
        LDRB    lr, [r5, #DiscRecord_Density]
        TEQ     lr, #DensityFixedDisc
        ADDEQ   r2, r2, #SzDefectList

15
        ASSERT  FreeStart :MOD: 4 = 0
        STR     r2, [r4, #FreeStart]

        ; Set the free space list end
        MOV     r2, #3
        STRB    r2, [r4, #FreeEnd]

        ; Next copy the name in
        LDR     r2, [sp, #2*4]
        TEQ     r2, #0
        baddr   r2, anull, EQ
        LDRB    lr, [r2, #0]
        TEQ     lr, #0
        STRNEB  lr, [r4, #OldName0+0]
        LDRNEB  lr, [r2, #1]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #OldName1+0]
        LDRNEB  lr, [r2, #2]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #OldName0+1]
        LDRNEB  lr, [r2, #3]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #OldName1+1]
        LDRNEB  lr, [r2, #4]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #OldName0+2]
        LDRNEB  lr, [r2, #5]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #OldName1+2]
        LDRNEB  lr, [r2, #6]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #OldName0+3]
        LDRNEB  lr, [r2, #7]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #OldName1+3]
        LDRNEB  lr, [r2, #8]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #OldName0+4]
        LDRNEB  lr, [r2, #9]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #OldName1+4]

        ; Give it a random Id
        BL      GetRandomId
        STRB    lr, [r4, #OldId]
        MOV     lr, lr, LSR #8
        STRB    lr, [r4, #OldId+1]

        ; Construct the check bytes
        MOV     r0, r4
        MOV     r1, #SzOldFs/2
        BL      CheckSum
        STRB    r2, [r0,#Check0]
        ADD     r0, r0, #SzOldFs/2
        BL      CheckSum
        ASSERT  Check1-Check0=SzOldFs/2
        STRB    r2, [r0,#Check0]

        ; Write the map out
        MOV     r0, #OSGBPB_WriteAtGiven
        LDR     r1, [sp, #3*4]
        MOV     r2, r4
        MOV     r3, #SzOldFs
        MOV     r4, #0
 [ DebugO
 DREG   r0,"OS_GBPB(",cc
 DREG   r1,",",cc
 DREG   r2,",",cc
 DREG   r3,",",cc
 DREG   r4,",",cc
 DLINE  ")"
 ]
        BL      DoXOS_GBPB

        B       %FT95

20
        ; More than 0 zones - new map
 [ DebugO
 DLINE  "New map"
 DREG   r6, "nzones is "
 ]

        ; For each zone
        MOV     r8, #0
30
 [ DebugO
 DREG   r8, "Zone "
 ]
        ; Hold sector size (in bytes) in r9
        MOV     r9, #1
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        MOV     r9, r9, ASL lr
 [ DebugO
 DREG   r9, "Sector size is "
 ]
        ; Clear out the area for this zone's map block
        MOV     r4, #ScratchSpace
        ADD     r3, r4, r9
        MOV     lr, #0
35
        STR     lr, [r3, #-4]!
        CMP     r3, r4
        BHI     %BT35

 [ DebugO
 DLINE  "Scratch cleared"
 ]
        ; Normally map bits start at the zone head
        MOV     r7, #ZoneHead * 8
        CMP     r8, #0
        BNE     %FT40

 [ DebugO
 DLINE  "Zone 0 processing..."
 ]
        ; Except for zone 0 which must carry the disc record so loses some more map bits
        ADD     r7, r7, #Zone0Bits
        ADD     lr, r4, #ZoneHead
        MOV     r0, r5

 [ BigMaps
        ASSERT  SzDiscRecSig2 = 52

        LDMIA   r0!, {r1-r3,r10}
        STMIA   lr!, {r1-r3,r10}
        LDMIA   r0!, {r1-r3,r10}
        STMIA   lr!, {r1-r3,r10}
        LDMIA   r0,  {r0,r1-r3,r10}
        STMIA   lr!, {r0,r1-r3,r10}
 |
        ASSERT  SzDiscRecSig = 32
 [ BigDisc
        LDR     r1, [r0, #DiscRecord_BigMap_DiscSize2]
        STR     r1, [lr, #DiscRecord_BigMap_DiscSize2]
 ]
        LDMIA   r0!, {r1-r3,r10}
        STMIA   lr!, {r1-r3,r10}
        LDMIA   r0!, {r1-r3,r10}
        STMIA   lr!, {r1-r3,r10}
 ]

 [ DebugO
 DLINE  "Copied disc record"
 ]

        ; Fill in the correct disc size
        MOV     r0, #OSArgs_ReadEXT
        LDR     r1, [sp, #3*4]
 [ DebugO
 DREG   r0, "XOS_Args(",cc
 DREG   r1, ",",cc
 DLINE  ")"
 ]
        BL      DoXOS_Args
        BVS     %FT95
 [ DebugO
 DREG   r2, "Disc size is "
 ]
        STR     r2, [r4, #ZoneHead + DiscRecord_DiscSize]
 [ BigDisc
        MOV     r2, #0
        STR     r2, [r4, #ZoneHead + DiscRecord_BigMap_DiscSize2]

        LDR     r2, [r5, #DiscRecord_BigMap_ShareSize]          ; (and BigFlag, Zones2)
        STR     r2, [r4, #ZoneHead+DiscRecord_BigMap_ShareSize]
 ]

 [ BigMaps
        LDR     r2, [r5, #DiscRecord_BigDir_DiscVersion]
        STR     r2, [r4, #ZoneHead+DiscRecord_BigDir_DiscVersion]
 ]

 [ BigDir
        CMP     r2, #0
        MOVNE   r2, #BigDirMinSize              ; if big dirs, then store a 2048 byte dir min size
        STR     r2, [r4, #ZoneHead+DiscRecord_BigDir_RootDirSize]       ; otherwise store zero
 ]

        ; Fill in the disc name
        LDR     r2, [sp, #2*4]
        TEQ     r2, #0
        baddr   r2, anull, EQ
        LDRB    lr, [r2, #0]
        TEQ     lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+0]
        LDRNEB  lr, [r2, #1]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+1]
        LDRNEB  lr, [r2, #2]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+2]
        LDRNEB  lr, [r2, #3]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+3]
        LDRNEB  lr, [r2, #4]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+4]
        LDRNEB  lr, [r2, #5]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+5]
        LDRNEB  lr, [r2, #6]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+6]
        LDRNEB  lr, [r2, #7]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+7]
        LDRNEB  lr, [r2, #8]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+8]
        LDRNEB  lr, [r2, #9]
        TEQNE   lr, #0
        STRNEB  lr, [r4, #ZoneHead+DiscRecord_DiscName+9]

 [ DebugO
 DLINE  "Copied disc name"
 ]

        ; Generate a unique DiscId
        BL      GetRandomId
        STRB    lr, [r4, #ZoneHead+DiscRecord_DiscId+0]
        MOV     lr, lr, LSR #8
        STRB    lr, [r4, #ZoneHead+DiscRecord_DiscId+1]

40
        ; If it's the map zone allocate space for the map and root dir
        TEQ     r8, r6, LSR #1          ; map zone is at nzones/2
        BNE     %FT50

 [ DebugO
 DLINE  "Map zone processing..."
 ]

        ; It's the root dir zone - allocate space for the root dir
        MOV     r10, r4
        LDRB    r2, [r5, #DiscRecord_IdLen]
        MOV     r1, r7
        MOV     r0, #2                  ; Object 2 is map and directory

 [ BigMaps
        BL      PrimitiveFragWrLinkBits
 |
        BL      PrimitiveWrLinkBits     ; (r0,r1,r2,r10->)
 ]

 [ DebugO
 DLINE  "Object 2 written out"
 ]

        ; Calculate map and directory total size (in bytes)
        LDRB    r14, [r5, #DiscRecord_Density]
        ORR     r14, r6, r14, LSL #16
        TEQ     r14, #1

        ; 1 zone, density=0 means has boot block and need to faff with that situation
        MOVEQ   r0, #DefectListDiscAdd + SzDefectList
        SUBEQ   r14, r9, #1
        ADDEQ   r0, r0, r14
        BICEQ   r0, r0, r14             ; round up after boot block to nearest sector

        ; Normal case, more than 1 zone or a floppy disc
        LDRNEB  lr, [r5, #DiscRecord_Log2SectorSize]
        MOVNE   r0, r6, ASL lr          ; Map size (single)
        MOVNE   r0, r0, ASL #1          ; Map size (2 copies)

 [ BigDir
        LDR     lr, [r5, #DiscRecord_Root]      ; check if have big dirs
        MOV     lr, lr, LSR #8          ; isolate fragment id
        TEQS    lr, #2                  ; is it in the map object?
        ASSERT  NewDirSize = BigDirMinSize
        ADDEQ   r0, r0, #NewDirSize     ; if it is, then we account for the root dir with the map
 |
        ADD     r0, r0, #NewDirSize
 ]
        BL      RoundToObjSize          ; (r0,r5)->(r0)
        MOV     r1, r7
        MOV     r10, r4
 [ DebugO
 DREG   r0, "Writing out len bits:"
 ]
 [ BigMaps
        BL      PrimitiveFragWrLenBits
 |
        BL      PrimitiveWrLenBits
 ]
 [ DebugO
 DLINE  "Len bits written out"
 ]

        ; Advance free pointer to beyond the map
        ADD     r7, r7, r0

 [ BigMaps
        ; if the root dir is in an object of its own, then it needs
        ; some space allocating.  the root dir disc address has already
        ; been passed in, mind you; we simply write out an object of
        ; the appropriate size

        LDR     r0, [r5, #DiscRecord_Root]

        MOV     r0, r0, LSR #8          ; isolate fragment id
        TEQS    r0, #2                  ; is it in the map object?
        BEQ     %FT50                   ; yes, already counted above

        MOV     r1, r7

        MOV     r10, r4

        BL      PrimitiveFragWrLinkBits ; write 'em out

        ; then write out the length of the root dir object

        MOV     r0, #BigDirMinSize
        BL      RoundToObjSize          ; (r0, r5)->(r0)

        MOV     r1, r7
        MOV     r10, r4
        BL      PrimitiveFragWrLenBits  ; and the length

        ADD     r7, r7, r0              ; and advance free pointer beyond the root dir
 ]

50
        ; Reserve space for the boot block
        TEQ     r8, #0
        BNE     %FT60                   ; This is not zone 0
        TEQ     r6, #1                  
        BEQ     %FT60                   ; 1-zone fixed discs accounted for the boot block already
                                        ; 1-zone floppies don't have boot blocks
        MOV     r0, #2
        MOV     r1, r7
        LDRB    r2, [r5, #DiscRecord_IdLen]
        MOV     r10, r4
 [ DebugO
 DREG   r1, "Writing out boot block object 2 at "
 ]
 [ BigMaps
        BL      PrimitiveFragWrLinkBits
 |
        BL      PrimitiveWrLinkBits     ; (r0,r1,r2,r10->)
 ]

        ; Calculate boot block size
        MOV     r0, #DefectListDiscAdd + SzDefectList
        BL      RoundToObjSize          ; (r0,r5)->(r0)
        MOV     r1, r7
        MOV     r10, r4
 [ BigMaps
        BL      PrimitiveFragWrLenBits
 |
        BL      PrimitiveWrLenBits
 ]

 [ DebugO
 DREG   r0, "Writing out boot block length of "
 ]

        ; Advance free space ptr
        ADD     r7, r7, r0

60
        ; Write out the free block after the header (+zone0bits+boot block+map)

 [ DebugO
 DREG   r7, "First free fragment at "
 ]

        ; Work out the last bit position in this map block
        ADD     r3, r9, #ZoneHead
        MOV     r3, r3, ASL #3
        ASSERT  DiscRecord_ZoneSpare :MOD: 4 = 2
        LDR     lr, [r5, #DiscRecord_ZoneSpare-2]
        SUB     r3, r3, lr, LSR #16     ; Bit position of first unused bit

 [ DebugO
 DREG   r3, "Zone end at "
 ]

        ; Map out the disc's tail as bad blocks
        LDR     r0, [r5, #DiscRecord_DiscSize]
 [ BigDisc
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]    ; adjust for sector sizing
        MOV     r0, r0, LSR lr
 ]
        SUB     r10, r5, #ZoneHead
        BL      DiscAddToMapPtr         ; (r0,r10->r11,lr)
 [ DebugO
 DREG   r11, "r11: "
 DREG   lr, "lr: "
 DREG   r8, "Compare versus zone:"
 ]
        CMP     lr, r8
        BHI     %FT62

 [ DebugO
 DREG   r11,"Mapping out end of disc at offset:"
 ]

        ; This zone is a candidate for truncation
        MOVLO   r1, r7                  ; Whole of zone needs mapping out
        MOVEQ   r1, r11                 ; End of zone needs mapping out
        MOV     lr, r9, ASL #3
        SUB     lr, lr, #1              ; Sector size  (in bits) -1
        AND     r1, r11, lr             ; Offset within zone of start of bit to map out
        BL      AllocBitWidth           ; (r10->lr)
        SUB     lr, lr, #1
        BIC     r1, r1, lr              ; Align start down to allowable boundary
 [ DebugO
 DREG   r1, "Rounded down map-out position is "
 ]
        BL      MinMapObj               ; (r10->lr)
        SUB     r0, r3, r1              ; Space to chop off at the end
        CMP     r0, lr
        SUBLO   r1, r3, lr              ; Must be at least a MinMapObj
 [ DebugO
 DREG   r1, "After push-down:"
 ]
        SUB     r0, r1, r7              ; Space left for free fragment
        CMP     r0, lr
        MOVLO   r1, r7                  ; Not enough for a free fragment - drop mapped out area to start
 [ DebugO
 DREG   r1, "After free fragment lower-bounding "
 DREG   r3, "Zone end still at "
 ]

        ; Now construct the bad block
        MOV     r0, #1                  ; Id 1 for bad block
        MOV     r10, #ScratchSpace
        LDRB    r2, [r5, #DiscRecord_IdLen]
 [ DebugO
 DREG   r0, "Writing link bits=",cc
 DREG   r1, " at ",cc
 DREG   r2, " idlen=",cc
 DREG   r10, " into space at "
 ]

 [ BigMaps
        BL      PrimitiveFragWrLinkBits
 |
        BL      PrimitiveWrLinkBits     ; (r0,r1,r2,r10->)
 ]

        SUB     r0, r3, r1
 [ DebugO
 DREG   r3, "Zone end still at "
 DREG   r0, "Writing len bits=",cc
 DREG   r1, " at ",cc
 DREG   r2, " idlen=",cc
 DREG   r10, " into space at "
 ]
        MOV     r3, r1                  ; New 'end' of this block

 [ BigMaps
        BL      PrimitiveFragWrLenBits
 |
        BL      PrimitiveWrLenBits
 ]
 [ DebugO
 DREG   r1, "End of disc starts at ",cc
 DREG   r0, " and has length "
 ]

62
        LDRB    r2, [r5, #DiscRecord_IdLen]
        MOV     r1, r7
 [ DebugO
 DREG   r3, "Zone end is "
 ]
        SUBS    r0, r3, r7              ; Length of 0 means no free block
        MOVNE   r10, r4
 [ DebugO
 DREG   r0,"Free block len is "
 DREG   r1
 DREG   r2
 DREG   r10
 ]

 [ BigMaps
        BLNE    PrimitiveFreeWrLenBits
        MOVNE   r0, #0
        BLNE    PrimitiveFreeWrLinkBits
 |
        BLNE    PrimitiveWrLenBits
        MOVNE   r0, #0
        BLNE    PrimitiveWrLinkBits     ; (r0,r1,r2,r10->)
 ]

 [ DebugO
 DLINE  "Free block written out"
 ]

        ; Link it to free chain
        SUBNE   r0, r7, #FreeLink * 8
        MOVEQ   r0, #0
        MOV     r1, #FreeLink * 8
 [ BigMaps
        BL      PrimitiveFreeWrLinkBits
        MOV     r0, #16
        BL      PrimitiveFreeWrLenBits
 |
        BL      PrimitiveWrLinkBits     ; (r0,r1,r2,r10->)
        MOV     r0, #16
        BL      PrimitiveWrLenBits
 ]

 [ DebugO
 DLINE  "Free link written out"
 ]

        ; Map out the defects
        LDR     r3, [sp, #1*4]
 [ BigDisc
        LDRB    r1, [r5, #DiscRecord_Log2SectorSize]   ; sector size in r1
 ]
65
        LDR     r0, [r3], #4
 [ BigDisc
        TST     r0, #DefectList_End
   [ BigMaps
        BNE     %FT70
   |
        BNE     %FT80
   ]
        MOV     r0, r0, LSR r1          ; sector address
 |
        TST     r0, #DefectList_End
        BNE     %FT80
 ]
        BL      MapOutADefect
        BVS     %FT95
        B       %BT65

 [ BigMaps
70
        ; here we do any second defect list processing, if needed
        LDRB    lr, [r5, #DiscRecord_BigMap_Flags]
        TSTS    lr, #DiscRecord_BigMap_BigFlag
        BEQ     %FT80                   ; no second defect list

75
        LDR     r0, [r3], #4
        TST     r0, #DefectList_BigMap_End
        BNE     %FT80                   ; end of second defect list

        BL      MapOutADefect
        BVS     %FT95
        B       %BT75
 ]

80
        ; If it's the last map then cross check=&ff
        ADD     lr, r8, #1
        TEQ     lr, r6
        MOVEQ   lr, #&ff
        STREQB  lr, [r4, #CrossCheck]

        ; evaluate the map's check byte
        MOV     r1, r9
        MOV     r0, r4
        BL      SetNewCheck

 [ DebugO
 DLINE  "Check bytes processed"
 ]
        ; Write out the map block (1st copy)
        MOV     r3, r1
        MOV     r0, #OSGBPB_WriteAtGiven
        LDR     r1, [sp, #3*4]
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]
        MOV     r9, r6                  ; nzones

        BL      MapDiscAdd              ; (R5,R7,R9->R2)
        BIC     r2, r2, #DiscBits
 [ BigDisc
        MOV     r2, r2, LSL r7
 ]
        ADD     r4, r2, r8, ASL r7
        MOV     r2, #ScratchSpace
 [ DebugO
 DREG   r0,"OS_GBPB(",cc
 DREG   r1,",",cc
 DREG   r2,",",cc
 DREG   r3,",",cc
 DREG   r4,",",cc
 DLINE  ")"
 ]
        BL      DoXOS_GBPB
        BVS     %FT95

        ; Write out the map block (2nd copy)
        MOV     lr, #1
        MOV     r3, lr, ASL r7

        BL      MapDiscAdd              ; (R5,R7,R9->R2)
        BIC     r2, r2, #DiscBits
 [ BigDisc
        MOV     r2, r2, LSL r7
 ]
        ADD     r4, r2, r8, ASL r7
        ADD     r4, r4, r9, ASL r7
        MOV     r2, #ScratchSpace
 [ DebugO
 DREG   r0,"OS_GBPB(",cc
 DREG   r1,",",cc
 DREG   r2,",",cc
 DREG   r3,",",cc
 DREG   r4,",",cc
 DLINE  ")"
 ]
        BL      DoXOS_GBPB
        BVS     %FT95

        ; Advance to the next map block
        ADD     r8, r8, #1
 [ DebugO
        DREG    r6, "Zones are: "
 ]
        CMP     r8, r6
        BLO     %BT30

95
        STRVS   r0, [sp]
        Pull    "r0-r10,pc"

; =============
; LayoutRootDir
; =============

; entry: r0 = pointer to disc record
;        r1 = Pointer to bad block list
;        r2 = Pointer to nul terminated disc name
;        r3 = FileSwitch file handle of image

; exit:  Root directory laid out in ScratchSpace

LayoutRootDir ROUT
        Push    "r0-r9,lr"

 [ BigDir
        LDR     lr, [r0, #DiscRecord_BigDir_DiscVersion]
        TEQ     lr, #0
        BNE     %FT40                   ; long file names
 ]

 [ BigMaps
        LDRB    lr, [r0, #DiscRecord_NZones]
        LDRB    r5, [r0, #DiscRecord_BigMap_NZones2]
        ORR     lr, lr, r5, LSL #8
 |
        LDRB    lr, [r0, #DiscRecord_NZones]
 ]
        MOV     r5, r0
        TEQ     LR, #0
        BNE     %FT10

        ; Old map
        LDRB    lr, [r5, #DiscRecord_Heads]
        TEQ     lr, #1
        MOVEQ   r2, #L_Root
        MOVEQ   r3, #OldDirSize
        MOVNE   r2, #D_Root
        MOVNE   r3, #NewDirSize
        MOV     r8, r2, LSR #8          ; Ind. disc address (for parent) = disc address

        B       %FT20

10
        ; New map
        MOV     r3, #NewDirSize
 [ BigMaps
        LDRB    r9, [r5, #DiscRecord_NZones]
        LDRB    r7, [r5, #DiscRecord_BigMap_NZones2]
        ORR     r9, r9, r7, LSL #8
 |
        LDRB    r9, [r5, #DiscRecord_NZones]
 ]
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]

        ; Ignore where the punter said the root directory was, work it out
        ; from geometry as the disc record could be wrong

        BL      MapDiscAdd              ; (R5,R7,R9->R2)
        BIC     r2, r2, #DiscBits
 [ BigDisc
        MOV     r2, r2, LSL r7          ; Convert sector address to byte address
 ]

        LDRB    r14, [r5, #DiscRecord_Density]
        ORR     r14, r9, r14, LSL #16
        TEQ     r14, #1                 ; EQ iff density=0 zones=1

        ADDNE   r2, r2, r9, ASL r7      ; Miss 1st copy of map
        ADDNE   r2, r2, r9, ASL r7      ; Miss 2nd copy of map
        MOVEQ   r14, r14, LSL r7
        SUBEQ   r14, r14, #1            ; For rounding up to nearest sector
        ADDEQ   r2, r14, #DefectListDiscAdd + SzDefectList
        BICEQ   r2, r2, r14

        ; Same again but as an indirect disc address
        MOVNE   r8, r9, LSL #1          ; Miss 1 sector per map zone for each of two maps
        MOVEQ   r8, r2, LSR r7          ; As calculated earlier but in sectors
        ADD     r8, r8, #1              ; Natural numbers
        ORR     r8, r8, #&200           ; Fragment id 2
        
20
        ; r2 = address of root dir
        ; r3 = size of root dir
        ; r8 = Ind. disc address of root dir (for filling into parent field)
 [ DebugO
 DREG   r2, "Location of root dir is "
 DREG   r3, "Size of root dir is "
 ]

        ; Location of dir in RAM
        MOV     r4, #ScratchSpace

        ; Zero out the dir
        ADD     r1, r4, r3
        MOV     r0, #0
30
        STR     r0, [r1, #-4]!
        CMP     r1, r4
        BHI     %BT30

        ; Store HugoNick as appropriate
        LDRB    lr, [r5, #DiscRecord_NZones]
        TEQ     lr, #0
 [ BigMaps
        LDREQB  lr, [r5, #DiscRecord_BigMap_NZones2]    ; check also that Zones2 is 0
        TEQEQ   lr, #0
 ]
        LDREQB  lr, [r5, #DiscRecord_Heads]
        TEQEQ   lr, #1

        ; Toggle the Z bit
        TOGPSR  Z_bit, lr

        MOV     r5, r4
        ADD     r6, r5, r3
        BL      WriteNames      ; Preserves Z

        LDR     r1, [sp, #2*4]  ; Disc name

        ADDEQ   r4, r6, #NewDirName
        ADDNE   r4, r6, #OldDirName
        BL      WriteName       ;enter name (r1,r4)
        ADDEQ   r4, r6, #NewDirTitle
        ADDNE   r4, r6, #OldDirTitle
        BL      WriteName       ;enter title=name (r1,r4)

        ; Parent address
        STREQB  r8, [r6, #NewDirParent]
        STRNEB  r8, [r6, #OldDirParent]
        MOV     r8, r8, LSR #8
        STREQB  r8, [r6, #NewDirParent+1]
        STRNEB  r8, [r6, #OldDirParent+1]
        MOV     r8, r8, LSR #8
        STREQB  r8, [r6, #NewDirParent+2]
        STRNEB  r8, [r6, #OldDirParent+2]

        BL      TestDirCheckByte;(r3,r5,r6->lr)
        STRB    lr, [r6,#DirCheckByte]

        MOV     r0, #OSGBPB_WriteAtGiven
        LDR     r1, [sp, #3*4]
        MOV     r4, r2
        MOV     r2, #ScratchSpace
 [ DebugO
 DREG   r0,"OS_GBPB(",cc
 DREG   r1,",",cc
 DREG   r2,",",cc
 DREG   r3,",",cc
 DREG   r4,",",cc
 DLINE  ")"
 ]
        BL      DoXOS_GBPB

        STRVS   r0, [sp]
        Pull    "r0-r9,pc"

 [ BigDir

; here if Big Dir

40
        MOV     r5, r0

        LDRB    r9, [r5, #DiscRecord_NZones]
        LDRB    lr, [r5, #DiscRecord_BigMap_NZones2]
        ORR     r9, r9, lr, LSL #8              ; total zones
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]

        BL      MapDiscAdd                      ; (R5,R7,R9->R2)
        BIC     r2, r2, #DiscBits

        MOV     r2, r2, LSL r7

        ; now need to work out the offset from the map to the root dir.
        LDRB    r14, [r5, #DiscRecord_Density]
        ORR     r14, r9, r14, LSL #16
        TEQ     r14, #1                         ; EQ iff density=0 zones=1

        MOVNE   r0, r9, LSL r7                  ; size of a single map copy
        MOVNE   r0, r0, LSL #1                  ; size of two copies of map
        MOVEQ   r0, #DefectListDiscAdd + SzDefectList

        BL      RoundToObjSize                  ; (R0,R5 -> R0)

        LDRB    lr, [r5, #DiscRecord_Log2bpmb]

        ADD     r2, r2, r0, LSL lr              ; disc byte address of root dir

        MOV     r3, #BigDirMinSize              ; size of root dir in r3

        MOV     r4, #ScratchSpace               ; use scratch space to build dir

 [ DebugO
 DREG   r2, "Location of root dir is "
 DREG   r3, "Size of root dir is "
 ]

        ; Zero out the dir
        ADD     r1, r4, r3
        MOV     r0, #0
50
        STR     r0, [r1, #-4]!
        CMP     r1, r4
        BHI     %BT50

        ; now construct the directory

        LDR     lr, SBProven2   ; start name
        STR     lr, [r4, #BigDirStartName]

        MOV     lr, #1          ; length of dir name
        STR     lr, [r4, #BigDirNameLen]

        MOV     lr, #BigDirMinSize      ; size of dir
        STR     lr, [r4, #BigDirSize]

        MOV     lr, #0          ; entries
        STR     lr, [r4, #BigDirEntries]

        MOV     lr, #0          ; no names
        STR     lr, [r4, #BigDirNamesSize]

        LDR     lr, [r5, #DiscRecord_Root]      ; ind disc add of root dir
        STR     lr, [r4, #BigDirParent]

        MOV     lr, #'$'        ; dir name
        ADD     lr, lr, #&D00   ; and terminator

        STR     lr, [r4, #BigDirName]

        ; now the tail

        ADD     r6, r4, r3              ; end name
        LDR     lr, SBProven2+4
        STR     lr, [r6, #BigDirEndName]

        ; now the check byte

        MOV     r5, r4
        BL      TestBigDirCheckByte     ; (R5, R6->LR, Z)
        STRB    lr, [r6, #BigDirCheckByte] ; check byte now stored

        MOV     r0, #OSGBPB_WriteAtGiven
        LDR     r1, [sp, #3*4]
        MOV     r4, r2
        MOV     r2, #ScratchSpace
 [ DebugO
 DREG   r0,"OS_GBPB(",cc
 DREG   r1,",",cc
 DREG   r2,",",cc
 DREG   r3,",",cc
 DREG   r4,",",cc
 DLINE  ")"
 ]
        BL      DoXOS_GBPB

        STRVS   r0, [sp]
        Pull    "r0-r9,pc"


SBProven2
 = "SBPr"
 = "oven"

 ]

; ==============
; RoundToObjSize
; ==============

; entry
;       r0 = size (in bytes) of object
;       r5 = pointer to disc record

; exit
;       r0 = size (now in map bits) rounded up to correct object size

RoundToObjSize ROUT
        Push    "r1,lr"

        ; Lower bound to (idlen+1)<<BitSize in size
        LDRB    r1, [r5, #DiscRecord_IdLen]
        ADD     r1, r1, #1
        LDRB    lr, [r5, #DiscRecord_Log2bpmb]
        CMP     r0, r1, ASL lr
        MOVLO   r0, r1, ASL lr
 [ DebugO
        DREG    R0, "Lower bound to min map obj gives "
 ]

        ; Work out AllocSize-1
        LDRB    r1, [r5, #DiscRecord_Log2SectorSize]
        LDRB    lr, [r5, #DiscRecord_Log2bpmb]
        CMP     r1, lr
        MOVLO   r1, lr
        MOV     lr, #1
        MOV     lr, lr, ASL r1
        SUB     lr, lr, #1

        ; Round up to AllocSize
        ADD     r0, r0, lr
        BIC     r0, r0, lr
 [ DebugO
        DREG    R0, "Round up gives "
 ]

        ; Convert to map bits
        LDRB    r1, [r5, #DiscRecord_Log2bpmb]
        MOV     r0, r0, LSR r1
 [ DebugO
        DREG    R0, "Convert to bits gives "
 ]

        Pull    "r1,pc"


; =============
; MapOutADefect
; =============

; entry
;       r0 = disc address of defect
;       r5 -> disc record
;       r8 = zone

; exit
;       error possible

; map block for zone <r8> assumed held in ScratchSpace

; This mapping out does not merge adjacent bad block fragments
MapOutADefect ROUT
        Push    "r0-r11,lr"

        SUB     r10, r5, #ZoneHead
        BL      DiscAddToMapPtr         ;(r0,r10->r11,lr)
        TEQ     lr, r8
        BNE     %FT95                   ; not this zone

        LDRB    r0, [r5, #DiscRecord_Log2SectorSize]
        MOV     lr, #8
        MOV     r0, lr, ASL r0
        SUB     r0, r0, #1
        AND     r6, r11, r0             ; Map ptr :MOD: sector size (in bits)

 [ DebugO
 DREG   r8, "Mapping out defect at zone ",cc
 DREG   r6, " offset "
 ]

        LDRB    r2, [r5, #DiscRecord_IdLen]
        MOV     r10, #ScratchSpace
        MOV     r3, #FreeLink*8         ; FreeLink
        MOV     r11, r3
        MOV     r0, r8
 [ BigMaps
        BL      PrimitiveFreeRdLinkBits ; (r10,r11->r8,Z)
 |
        BL      PrimitiveRdLinkBits     ; (r10,r11->r8,Z)
 ]
        ADD     r4, r3, r8              ; 1st free fragment
        MOV     r11, #ZoneHead * 8
        TEQ     r0, #0
        ADDEQ   r11, r11, #Zone0Bits    ; 1st fragment
        LDRB    r9, [r5, #DiscRecord_Log2SectorSize]
        MOV     lr, #8
        MOV     r9, lr, ASL r9
        ADD     r9, r9, #ZoneHead*8
        ASSERT  DiscRecord_ZoneSpare:MOD:4 = 2
        LDR     lr, [r5, #DiscRecord_ZoneSpare-2]
        SUB     r9, r9, lr, LSR #16     ; End of zone

10
 [ DebugO
 DREG   r11, "P:",cc
 DREG   r4, " F:",cc
 DREG   r3, " PF:"
 ]

 [ BigMaps
        BL      PrimitiveFragRdLenBits
 |
        BL      PrimitiveRdLenBits
 ]
        ADD     LR, R11, R7
        CMP     LR, R6
        BHI     %FT15                   ; Fragment encompasses bad block
        TEQ     R11, R4
        BNE     %FT12


 [ BigMaps
        BL      PrimitiveFreeRdLinkBits ; (r2,r10,r11->r8,Z) Next free fragment
 |
        BL      PrimitiveRdLinkBits     ; (r2,r10,r11->r8,Z) Next free fragment
 ]
        MOV     R3, R4
        ADD     R4, R4, R8

12
        ADD     r11, r11, r7            ; next fragment
        CMP     R11, R9                 ; Ended?
        BLO     %BT10                   ; No

 [ DebugO
 DLINE  "No fragment containing fragment - bad news!"
 ]

        ; Bad block not in zone after all - bad situation
        MOV     r0, #DefectErr
        SETV
        B       %FT95

15
        ; Defect found in a fragment:
        ; R2 - idlen
        ; R3 - previous free fragment
        ; R4 - this (next) free fragment
        ; R5 - ptr to disc record
        ; R6 - Bad block's map ptr
        ; R7 - this fragment's length
        ; R9 - Zone end (bit address)
        ; R10 - ScratchSpace
        ; R11 - fragment start
        ; LR - next fragment start

        TEQ     r11, r4
        BEQ     %FT20

 [ DebugO
 DLINE  "Fragment containing bad block isn't free"
 ]

        ; Fragment encompassing defect not free, but is it already a bad block?
 [ BigMaps
        BL      PrimitiveFragRdLinkBits
 |
        BL      PrimitiveRdLinkBits
 ]
        TEQ     r8, #1
        MOVNE   r0, #DefectErr
        SETV    NE
        B       %FT95

20
        ; Defect found in a free block

        ; Get some useful figures
        SUB     r10, r5, #ZoneHead
        BL      AllocBitWidth           ; (r10->lr)
        SUB     lr, lr, #1
        BIC     r6, r6, lr              ; Start of alloc unit containing defect
        BL      MinMapObj               ; (r10->lr)
        MOV     r1, lr

 [ DebugO
 DREG   r6, "Rounded down bad block location:"
 DREG   r1, "MinMapObj:"
 ]

        ; Push bad block position down if not enough room after it for a whole fragment
        ADD     r1, r11, r7             ; End of fragment containing bad block
        SUB     r0, r1, r6              ; Space after bad block
        CMP     r0, lr
        SUBLO   r6, r1, lr

 [ DebugO
 DREG   r6, "Bad location after push-down:"
 ]

        ; If no room for a fragment before the bad block
        ; move bad block start to start of free area.
        SUB     r0, r6, r11             ; space before bad block
        CMP     r0, lr
        MOVLO   r6, r11
        BLO     %FT30

        ; There is room before the bad block for a free block

 [ DebugO
 DLINE  "There's room before the bad block"
 ]

        ; Check the room after the bad block
        ADD     r0, r11, r7             ; End of free block containing defect
        SUB     r0, r0, r6              ; Space from start of defect fragment to end of free fragment
        SUB     r0, r0, lr              ; Space from end of defect fragment to end of free fragment (>=0 guaranteed)
        CMP     r0, #0
        CMPNE   r0, lr
        BHS     %FT25                   ; no space or enough space already for a fragment - don't move the bad block fragment
        ADD     r0, r0, r6
        SUB     r0, r0, r11             ; Added in space before the fragment
        CMP     r0, lr, ASL #1
        BLO     %FT25                   ; Not enough space for two fragments - don't move the bad block

 [ DebugO
 DLINE  "Bad block shuffle needed to give two free blocks"
 ]

        ; Move the bad fragment down to give room for a free fragment after it
        ADD     r6, r11, r7             ; End of free fragment
        SUB     r6, r6, lr, ASL #1      ; Less two MinMapObjs - one for the free fragment, one for the bad fragment

25
        ; Must detach the free fragment before the bad block fragment
 [ DebugO
 DLINE  "Shortening first free fragment"
 ]
        SUB     r0, r6, r11
        MOV     r1, r11
        MOV     r10, #ScratchSpace
 [ BigMaps
        BL      PrimitiveFreeWrLenBits
 |
        BL      PrimitiveWrLenBits
 ]

        ; Prev free is now this detached thingy
        MOV     r3, r11

        B       %FT40

30
        ; There isn't room before the bad block fragment for a free block

 [ DebugO
 DLINE  "No room for a free fragment before bad block - detaching free fragment from free chain"
 ]

        ; Detach the free block from the free chain
        MOV     r10, #ScratchSpace
 [ BigMaps
        BL      PrimitiveFreeRdLinkBits
 |
        BL      PrimitiveRdLinkBits
 ]
        TEQ     r8, #0
        MOVEQ   r0, #0
        ADDNE   r0, r8, r11
        SUBNE   r0, r0, r3
        MOV     r1, r3
 [ BigMaps
        BL      PrimitiveFreeWrLinkBits
 |
        BL      PrimitiveWrLinkBits     ; (r0,r1,r2,r10->)
 ]

        ; New start of bad block fragment
        MOV     r6, r11


40
        ; Deal with any free fragment after the bad block fragment:
        ; r2 - idlen
        ; r3 - previous free fragment
        ; r5 - ptr to disc record
        ; r6 = MapPtr of fragment containing the bad block (in its right place)
        ; r7 - this fragment's length
        ; r9 - Zone end (bit address)
        ; r11 = start of free fragment out of which the bad block fragment is being carved

        ; Generate the bad block
 [ DebugO
 DLINE  "Writing out bad block Id"
 ]
        MOV     r0, #1                  ; Bad block ID
        MOV     r1, r6
        MOV     r10, #ScratchSpace
 [ BigMaps
        BL      PrimitiveFragWrLinkBits
 |
        BL      PrimitiveWrLinkBits     ; (r0,r1,r2,r10->)
 ]

        ; Now determine its length
        ADD     r4, r11, r7             ; End of free fragment (end of bad block fragment later)
        SUB     r10, r5, #ZoneHead
        BL      MinMapObj               ; (r10->lr)
        ADD     r1, r6, lr              ; End of bad block fragment
        SUB     r0, r4, r1              ; Space after bad fragment left in free fragment
        CMP     r0, lr                  ; enough for a free block?
        BLO     %FT50                   ; No

        ; Enough space for a free fragment after the bad block - create it
 [ DebugO
 DLINE  "Room after bad block for a free fragment - attaching this into the free chain"
 ]

        ; Attach prev->next to this->next
        MOV     r11, r3
        MOV     r10, #ScratchSpace
 [ BigMaps
        BL      PrimitiveFreeRdLinkBits     ; (r2,r10,r11->r8)
 |
        BL      PrimitiveRdLinkBits     ; (r2,r10,r11->r8)
 ]
        TEQ     r8, #0
        MOVEQ   r0, r8
        ADDNE   r0, r8, r11
        SUBNE   r0, r0, r1
 [ BigMaps
        BL      PrimitiveFreeWrLinkBits ; (r0,r1,r2,r10->)
 |
        BL      PrimitiveWrLinkBits     ; (r0,r1,r2,r10->)
 ]
        MOV     r4, r1                  ; Hold end of bad block fragment

        ; Attach this to prev->next
        SUB     r0, r1, r3
        MOV     r1, r3
 [ BigMaps
        BL      PrimitiveFreeWrLinkBits
 |
        BL      PrimitiveWrLinkBits     ; (r0,r1,r2,r10->)
 ]

50
        ; r4 is end of bad block fragment

        ; Write the length of the bad block fragment
 [ DebugO
 DLINE  "Writing out bad block fragment's length"
 ]
        MOV     r10, #ScratchSpace
        SUB     r0, r4, r6
        MOV     r1, r6
 [ BigMaps
        BL      PrimitiveFragWrLenBits
 |
        BL      PrimitiveWrLenBits
 ]

95
        STRVS   r0, [sp]
        Pull    "r0-r11,pc"


; ========
; CallASwi
; ========

; entry: r11 = SWI number
;       other regs parameters to SWI

; exit:  As per SWI

CallASwi ROUT

        Push    "r10,lr"

        ; 'Leave' FileCore out the bottom - but allow reentry (once)
        TEQ     SB, #0
        BLNE    DoExternal
        
        ; OS_CallASWI uses r10 for SWI number, also ensure it's an X SWI
        ORR     r10,r11,#Auto_Error_SWI_bit  
        SWI     XOS_CallASWI

        ; 'Enter' FileCore.
        TEQ     SB, #0
        BLNE    Internal

        Pull    "r10,pc"

        END
@


4.14
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d361 28
@


4.13
log
@Swap out some more constants for symbolic names
* OsBytes
* Application start &8000
* Fixed disc density
* Unused a4 macro deleted
* Redundant 'todo', 'Help, 'Syntax' removed

Version 3.53. Not tagged
@
text
@d298 1
a299 2

 [ BigMaps
d302 2
@


4.12
log
@Teach FileCore_LayoutStructure and Service_IdentifyDisc how to do 1 zone fixed discs.
From the change logs it was last fixed sometime around FileCore 2.50 era, but has been long broken.
The boot block was in the right place, but was overwritten by the root directory, and the wrong size entry was claimed in the map, amongst other errors.
Free'd up R6 in LayoutFreeSpaceMap to avoid having to keep reevaluating the number of zones - makes it a bit more readable. Corrected inaccurate comments. Checked the code paths for new map with and without boot block, with and without long filenames.
Test app 'Make1Zone' generates a small disc image which can be inspected in a hex editor for correctness.
In the identify code, be more strict about looking for a boot block only on fixed discs since they cannot occur on floppies (saves time, wasn't necessarily wrong).
The concept of a boot block at &C00 only works when 2 copies of the map can be fitted underneath that address, for future 2k and 4k sector sizes these do not fit and it is likely that 1 zone fixed discs are forbidden (a drive with 4k sectors would typically be > 512GB and 1 zone would be ~32MB so spilling into a second zone would waste < 0.01%).
Other minor changes:
* Free command now groups the 'K' with 'bytes' to match OS_ConvertFileSize.
* FileCore20 debug didn't assemble.
* FileCore33 beefed up comments.
* GenSWIs debug didn't assemble.
Tested with a special cut of RAMFS manually loading various 1 zone images into its dynamic area and checking they mount, have a sensible *MAP and *FREE result, can be written to, and don't have broken directories.

Version 3.46. Tagged as 'FileCore-3_46'
@
text
@d604 1
a604 1
        TEQ     lr, #0
@


4.11
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d244 1
a244 1
; SoSwiLayoutStructure
d258 1
a258 1
; determins the amount of accessible disc (the remainder
d275 1
a275 1
        ; Make a copy of the disc record
d278 1
a278 4
; [ BigDisc
;        LDR     lr, [r0,#DiscRecord_BigMap_DiscSize2]
;        STR     lr, [r8,#DiscRecord_BigMap_DiscSize2]
; ]
a292 1

d334 1
a334 2
90
        STRVS   r0, [sp, #LayoutSz + 0*4]
d341 1
a341 1

d385 1
a385 4
        BEQ     %FT15                   ; if this big clear, then no need to check flag

        ; here we have a second defect list

a413 1

a415 1

a431 1

a432 1

d453 1
a453 1
        DREG    lr, "Setting RootDir to (FormSWIs, 439): "
d458 2
a459 1
        ; make assumption that disc size can not be more than 4G bytes
d473 2
a474 3

        ; we don't copy the RootSize field into the boot block

d526 1
a526 1
; exit:  Boot block laid out
d539 1
a540 2

        LDRB    lr, [r5, #DiscRecord_NZones]
d542 3
a544 3
        TEQ     lr, #0
        LDREQB  lr, [r5, #DiscRecord_BigMap_NZones2]
        TEQEQ   lr, #0
d546 1
a546 1
        TEQ     lr, #0
d548 1
d688 1
a692 5

 [ DebugO
 DREG   r9, "Sector size is "
 ]

d701 4
a704 2

        ; Clear out the area for the map block
d716 1
a716 2

        ; If it's zone0 copy in the disc record and map bits start at a greater offset
d724 1
a724 1

d726 2
a730 2
        ADD     r6, r4, #ZoneHead
        MOV     r0, r5
d733 1
a733 1
        STMIA   r6!, {r1-r3,r10}
d735 1
a735 1
        STMIA   r6!, {r1-r3,r10}
d737 1
a737 1
        STMIA   r6!, {r0,r1-r3,r10}
a739 2
        ADD     r6, r4, #ZoneHead
        MOV     r0, r5
d742 1
a742 1
        STR     r1, [r6, #DiscRecord_BigMap_DiscSize2]
d745 1
a745 1
        STMIA   r6!, {r1-r3,r10}
d747 1
a747 1
        STMIA   r6!, {r1-r3,r10}
d834 1
a834 10
 [ BigMaps
        Push    "r8"
        LDRB    lr, [r5, #DiscRecord_NZones]
        LDRB    r8, [r5, #DiscRecord_BigMap_NZones2]
        ADD     lr, lr, r8, LSL #8
        Pull    "r8"
 |
        LDRB    lr, [r5, #DiscRecord_NZones]
 ]
        TEQ     r8, lr, LSR #1
d845 1
a845 1
        MOV     r0, #2          ; Object 2 is map and directory
d850 1
a850 1
        BL      PrimitiveWrLinkBits
d858 3
a860 12
 [ BigMaps
        LDRB    r0, [r5, #DiscRecord_NZones]
        LDRB    lr, [r5, #DiscRecord_BigMap_NZones2]
        ADD     r0, r0, lr, LSL #8
        TEQ     r0,#1
 |
        LDRB    r0, [r5, #DiscRecord_NZones]
        TEQ     r0, #1
 ]
        LDREQB  lr, [r5, #DiscRecord_Density]
        TEQEQ   lr, #0
        BNE     %FT45
d863 9
a871 2
        MOV     r0, #DefectListDiscAdd + SzDefectList + NewDirSize
        B       %FT47
a872 4
45
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        MOV     r0, r0, ASL lr          ; Map size (single)
        MOV     r0, r0, ASL #1          ; Map size (2 copies)
d875 1
a875 1
        MOV     lr, lr, LSR #8          ; link bits...
d877 2
a878 1
        ADDEQ   r0, r0, #NewDirSize     ; if it is not, then we place the root dir with the map
a881 2

47
d908 3
a910 3
        MOV     r0, r0, LSR #8          ; linkbits
        TEQS    r0, #2                  ; check if it's in the map object
        BEQ     %FT50                   ; yes, so don't do owt
d931 1
a931 11
        ; Zone 0 boot block processing
 [ BigMaps
        LDRB    lr, [r5, #DiscRecord_NZones]
        TEQ     lr, #1
        LDREQB  lr, [r5, #DiscRecord_BigMap_NZones2]
        TEQEQ   lr, #0
 |
        LDRB    lr, [r5, #DiscRecord_NZones]
        TEQ     lr, #1
 ]
        BEQ     %FT60           ; No boot block handling here on 1-zone discs (floppies or winnies)
d933 4
a936 3
        BNE     %FT60

        ; Write out the boot block object
d947 1
a947 1
        BL      PrimitiveWrLinkBits
d960 1
d1047 1
a1047 1
        BL      PrimitiveWrLinkBits
d1092 1
a1092 1
        BLNE    PrimitiveWrLinkBits
d1108 1
a1108 1
        BL      PrimitiveWrLinkBits
d1159 2
a1160 10
 [ BigMaps
        ; r1 will be corrupted later so we use it...
        LDRB    lr, [r5, #DiscRecord_NZones]
        LDRB    r1, [r5, #DiscRecord_BigMap_NZones2]
        ADD     lr, lr, r1, LSL #8
 |
        LDRB    lr, [r5, #DiscRecord_NZones]
 ]
        SUB     lr, lr, #1
        TEQ     lr, r8
a1171 1

d1177 3
a1179 8
 [ BigMaps
        LDRB    r9, [r5, #DiscRecord_NZones]
        LDRB    lr, [r5, #DiscRecord_BigMap_NZones2]    ; safe to use lr, as it's followed by a BL
        ADD     r9, r9, lr, LSL #8
 |
        LDRB    r9, [r5, #DiscRecord_NZones]
 ]
        BL      MapDiscAdd
d1200 2
a1201 1
        BL      MapDiscAdd
a1221 5
  [ BigMaps
        ; r2 should be available as it's used for the OS_GBPB above
        LDRB    lr, [r5, #DiscRecord_NZones]
        LDRB    r2, [r5, #DiscRecord_BigMap_NZones2]
        ADD     lr, lr, r2, LSL #8
d1223 1
a1223 1
        DREG    lr, "Zones are: "
d1225 1
a1225 4
  |
        LDRB    lr, [r5, #DiscRecord_NZones]
  ]
        CMP     r8, lr
d1232 19
a1250 3
; ==============
; RoundToObjSize
; ==============
d1252 10
a1261 3
; entry
;       r0 = size (in bytes) of object
;       r5 = pointer to disc record
d1263 8
a1270 2
; exit
;       r0 = size (now in map bits) rounded up to correct object size
d1272 1
a1272 2
RoundToObjSize ROUT
        Push    "r1,lr"
d1274 9
a1282 8
        ; Lower bound to (LinkBits+1)<<BitSize in size
        LDRB    r1, [r5, #DiscRecord_IdLen]
        ADD     r1, r1, #1
        LDRB    lr, [r5, #DiscRecord_Log2bpmb]
        CMP     r0, r1, ASL lr
        MOVLO   r0, r1, ASL lr
 [ DebugO
        DREG    R0, "Lower bound to min map obj gives "
d1284 1
d1286 2
a1287 8
        ; Work out AllocSize-1
        LDRB    r1, [r5, #DiscRecord_Log2SectorSize]
        LDRB    lr, [r5, #DiscRecord_Log2bpmb]
        CMP     r1, lr
        MOVLO   r1, lr
        MOV     lr, #1
        MOV     lr, lr, ASL r1
        SUB     lr, lr, #1
d1289 4
a1292 5
        ; Round up to AllocSize
        ADD     r0, r0, lr
        BIC     r0, r0, lr
 [ DebugO
        DREG    R0, "Round up gives "
d1295 21
a1315 3
        ; Convert to map bits
        LDRB    r1, [r5, #DiscRecord_Log2bpmb]
        MOV     r0, r0, LSR r1
d1317 2
a1318 1
        DREG    R0, "Convert to bits gives "
d1321 2
a1322 1
        Pull    "r1,pc"
d1324 7
d1332 9
a1340 3
; =============
; MapOutADefect
; =============
d1342 2
a1343 4
; entry
;       r0 = disc address of defect
;       r5 -> disc record
;       r8 = zone
d1345 3
a1347 2
; exit
;       error possible
d1349 1
a1349 1
; map block for zone <r8> assumed held in ScratchSpace
d1351 6
a1356 3
; This mapping out does not merge adjacent bad block fragments
MapOutADefect ROUT
        Push    "r0-r11,lr"
d1358 9
a1366 4
        SUB     r10, r5, #ZoneHead
        BL      DiscAddToMapPtr         ;(r0,r10->r11,lr)
        TEQ     lr, r8
        BNE     %FT95                   ; not this zone
d1368 2
a1369 5
        LDRB    r0, [r5, #DiscRecord_Log2SectorSize]
        MOV     lr, #8
        MOV     r0, lr, ASL r0
        SUB     r0, r0, #1
        AND     r6, r11, r0             ; Map ptr :MOD: sector size (in bits)
d1371 4
d1376 204
a1579 2
 DREG   r8, "Mapping out defect at zone ",cc
 DREG   r6, " offset "
d1624 1
a1624 1
        BL      PrimitiveFreeRdLinkBits     ; (r2,r10,r11->r8,Z) Next free fragment
d1776 1
a1776 1
        BL      PrimitiveWrLinkBits
d1803 1
a1803 1
        BL      PrimitiveWrLinkBits
d1845 1
a1845 1
        BL      PrimitiveWrLinkBits
a1868 251

; =============
; LayoutRootDir
; =============

; entry: r0 = pointer to disc record
;        r1 = Pointer to bad block list
;        r2 = Pointer to nul terminated disc name
;        r3 = FileSwitch file handle of image

; exit:  Root directory laid out in ScratchSpace

LayoutRootDir ROUT
        Push    "r0-r9,lr"

 [ BigDir
        LDR     lr, [r0, #DiscRecord_BigDir_DiscVersion]
        TEQ     lr, #0
        BNE     %FT40                   ; long file names
 ]

 [ BigMaps
 ; we delay the mov r5, r0 to allow r5 to be used as scratch
        LDRB    r5, [r0, #DiscRecord_BigMap_NZones2]
        LDRB    lr, [r0, #DiscRecord_NZones]
        ADD     lr, lr, r5, LSL #8
        MOV     r5, r0
 |
        MOV     r5, r0
        LDRB    lr, [r5, #DiscRecord_NZones]
 ]
        TEQ     LR, #0
        BNE     %FT10

        ; Old map
        LDRB    lr, [r5, #DiscRecord_Heads]
        TEQ     lr, #1
        MOVEQ   r2, #L_Root
        MOVEQ   r3, #OldDirSize
        MOVNE   r2, #D_Root
        MOVNE   r3, #NewDirSize
        MOV     r8, r2, LSR #8          ; Ind. disc address (for parent) = disc address

        B       %FT20

10
        ; New map
        MOV     r3, #NewDirSize
 [ BigMaps
        LDRB    r9, [r5, #DiscRecord_NZones]
        LDRB    r7, [r5, #DiscRecord_BigMap_NZones2]
        ADD     r9, r9, r7, LSL #8
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]
 |
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]
        LDRB    r9, [r5, #DiscRecord_NZones]
 ]
        BL      MapDiscAdd
        BIC     r2, r2, #DiscBits
 [ BigDisc
        MOV     r2, r2, LSL r7
 ]
        ADD     r2, r2, r9, ASL r7      ; Miss 1st copy of map
        ADD     r2, r2, r9, ASL r7      ; Miss 2nd copy of map
        MOV     r8, r9, ASL #1
        ADD     r8, r8, #1
        ORR     r8, r8, #&200           ; Ind. disc address (for parent) = &2xx where xx=2*zones+1

20
        ; r2 = address of root dir
        ; r3 = size of root dir
        ; r8 = Ind. disc address of root dir (for filling into parent field)
 [ DebugO
 DREG   r2, "Location of root dir is "
 DREG   r3, "Size of root dir is "
 ]

        ; Location of dir in RAM
        MOV     r4, #ScratchSpace

        ; Zero out the dir
        ADD     r1, r4, r3
        MOV     r0, #0
30
        STR     r0, [r1, #-4]!
        CMP     r1, r4
        BHI     %BT30

        ; Store HugoNick as appropriate
        LDRB    lr, [r5, #DiscRecord_NZones]
        TEQ     lr, #0
 [ BigMaps
        LDREQB  lr, [r5, #DiscRecord_BigMap_NZones2]    ; check also that Zones2 is 0
        TEQEQ   lr, #0
 ]
        LDREQB  lr, [r5, #DiscRecord_Heads]
        TEQEQ   lr, #1

        ; Toggle the Z bit
        TOGPSR  Z_bit, lr

        MOV     r5, r4
        ADD     r6, r5, r3
        BL      WriteNames

        LDR     r1, [sp, #2*4]  ; Disc name

        ADDEQ   r4, r6, #NewDirName
        ADDNE   r4, r6, #OldDirName
        BL      WriteName       ;enter name (r1,r4)
        ADDEQ   r4, r6, #NewDirTitle
        ADDNE   r4, r6, #OldDirTitle
        BL      WriteName       ;enter title=name (r1,r4)

        ; Parent address
        STREQB  r8, [r6, #NewDirParent]
        STRNEB  r8, [r6, #OldDirParent]
        MOV     r8, r8, LSR #8
        STREQB  r8, [r6, #NewDirParent+1]
        STRNEB  r8, [r6, #OldDirParent+1]
        MOV     r8, r8, LSR #8
        STREQB  r8, [r6, #NewDirParent+2]
        STRNEB  r8, [r6, #OldDirParent+2]

        BL      TestDirCheckByte;(r3,r5,r6->lr)
        STRB    lr, [r6,#DirCheckByte]

        MOV     r0, #OSGBPB_WriteAtGiven
        LDR     r1, [sp, #3*4]
        MOV     r4, r2
        MOV     r2, #ScratchSpace
 [ DebugO
 DREG   r0,"OS_GBPB(",cc
 DREG   r1,",",cc
 DREG   r2,",",cc
 DREG   r3,",",cc
 DREG   r4,",",cc
 DLINE  ")"
 ]
        BL      DoXOS_GBPB

        STRVS   r0, [sp]
        Pull    "r0-r9,pc"

 [ BigDir

; here if Big Dir

40
        MOV     r5, r0

        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]
        LDRB    r9, [r5, #DiscRecord_NZones]
        LDRB    lr, [r5, #DiscRecord_BigMap_NZones2]
        ADD     r9, r9, lr, LSL #8              ; total zones

        BL      MapDiscAdd                      ; (R5, R7, R9 -> R2)

        BIC     r2, r2, #DiscBits               ; strip off the disc bits

        MOV     r2, r2, LSL r7

        ; now need to work out the offset from the map to the root dir.

        MOV     r0, r9, LSL r7                  ; size of a single map copy
        MOV     r0, r0, LSL #1                  ; size of two copies of map

        BL      RoundToObjSize                  ; (R0,R5 -> R0)

        LDRB    lr, [r5, #DiscRecord_Log2bpmb]

        ADD     r2, r2, r0, LSL lr              ; disc address of root dir

        MOV     r3, #BigDirMinSize              ; size of root dir in r3

        MOV     r4, #ScratchSpace               ; use scratch space to build dir

 [ DebugO
 DREG   r2, "Location of root dir is "
 DREG   r3, "Size of root dir is "
 ]

        ; Zero out the dir
        ADD     r1, r4, r3
        MOV     r0, #0
50
        STR     r0, [r1, #-4]!
        CMP     r1, r4
        BHI     %BT50

        ; now contstruct the directory

        LDR     lr, SBProven2   ; start name
        STR     lr, [r4, #BigDirStartName]

        MOV     lr, #1          ; length of dir name
        STR     lr, [r4, #BigDirNameLen]

        MOV     lr, #BigDirMinSize      ; size of dir
        STR     lr, [r4, #BigDirSize]

        MOV     lr, #0          ; entries
        STR     lr, [r4, #BigDirEntries]

        MOV     lr, #0          ; no names
        STR     lr, [r4, #BigDirNamesSize]

        LDR     lr, [r5, #DiscRecord_Root]      ; ind disc add of root dir
        STR     lr, [r4, #BigDirParent]

        MOV     lr, #'$'        ; dir name
        ADD     lr, lr, #&D00   ;

        STR     lr, [r4, #BigDirName]

        ; now the tail

        ADD     r6, r4, r3              ; end name
        LDR     lr, SBProven2+4
        STR     lr, [r6, #BigDirEndName]

        ; now the check byte

        MOV     r5, r4
        BL      TestBigDirCheckByte     ; (R5, R6->LR, Z)
        STRB    lr, [r6, #BigDirCheckByte] ; check byte now stored

        MOV     r0, #OSGBPB_WriteAtGiven
        LDR     r1, [sp, #3*4]
        MOV     r4, r2
        MOV     r2, #ScratchSpace
 [ DebugO
 DREG   r0,"OS_GBPB(",cc
 DREG   r1,",",cc
 DREG   r2,",",cc
 DREG   r3,",",cc
 DREG   r4,",",cc
 DLINE  ")"
 ]
        BL      DoXOS_GBPB

        STRVS   r0, [sp]
        Pull    "r0-r9,pc"


SBProven2
 = "SBPr"
 = "oven"

 ]

a1878 1
    ;use OS_CallASWI - avoids need for dynamic code
d1885 3
a1887 2

        ORR     r10,r11,#Auto_Error_SWI_bit  ;OS_CallASWI uses r10 for SWI number, also make it an X SWI
@


4.10
log
@Try again with more accurate keyboard use.
Retagged as FileCore-3_44.
@
text
@d108 1
a108 1
        BICEQ   lr, lr, #FormatIndexMark
d115 2
a116 2
        LDREQ   r1, [r0, #TracksToFormat]
        LDREQ   r2, [r4, #TracksToFormat]
d141 2
a142 2
        DCB     Double  ; Density
        DCB     FormatSequenceSides
d166 2
a167 2
        DCB     Double  ; Density
        DCB     FormatInterleaveSides
d190 2
a191 2
        DCB     Quad    ; Density
        DCB     FormatInterleaveSides
d219 2
a220 2
        DCB     Octal   ; Density
        DCB     FormatInterleaveSides
d276 1
a276 1
        ASSERT  DiscRecSig = 8*4
d279 2
a280 2
;        LDR     lr, [r0,#DiscSize2]
;        STR     lr, [r8,#DiscSize2]
d288 2
a289 2
 	ASSERT	DiscSize2-DiscRecSig=4
 	ASSERT	DiscRecSig2-DiscSize2=4*4
d291 5
a295 5
 	; copy extra fields
 	ADD	r8, r8, #4
 	ADD	r0, r0, #4
 	LDMIA	r0!, {r4-r7}
 	STMIA	r8!, {r4-r7}
d300 1
a300 1
        LDRB    lr, LayoutDiscRec + Density
d302 1
a302 1
        LDRLSB  lr, LayoutDiscRec + Zones
d305 2
a306 2
 	LDRLSB	r0, LayoutDiscRec+Zones2	; top byte of zones number
 	ADDLS	lr, lr, r0, LSL #8
d309 1
a309 1
  	DREG	lr, "zones from rec: "
d381 1
a381 1
        CMP     lr, #&20000000
d387 4
a390 4
 	; if there's a second defect list present, then do it
 	LDRB	lr, [r0, #BigFlag]	;
 	TSTS	lr, #BigFlagBit
 	BEQ	%FT15			; if this big clear, then no need to check flag
d392 1
a392 1
 	; here we have a second defect list
d397 1
a397 1
        CMP     lr, #&40000000
d415 1
a415 1
        TSTS    lr, #&20000000
d424 1
a424 1
	; check again for presence of the second defect list
d426 3
a428 3
	LDRB	lr, [r0, #BigFlag]
	TSTS	lr, #BigFlagBit
	BEQ	%FT30			; no second defect list
d430 2
a431 2
	MOV	r1, #0
	MOV	r5, r4
d434 1
a434 1
        TSTS    lr, #&40000000
d446 18
a463 18
        ASSERT  SectorSize :MOD: 4 = 0
        ASSERT  SecsPerTrk = SectorSize + 1
        ASSERT  Heads = SecsPerTrk + 1
        ASSERT  Density = Heads + 1
        LDR     lr, [r0, #SectorSize]
        STR     lr, [r4, #DefectStruc + SectorSize]
        LDRB    lr, [r0, #LinkBits]
        STRB    lr, [r4, #DefectStruc + LinkBits]
        LDRB    lr, [r0, #BitSize]
        STRB    lr, [r4, #DefectStruc + BitSize]
        LDRB    lr, [r0, #RAskew]
        STRB    lr, [r4, #DefectStruc + RAskew]
        ASSERT  LowSector :MOD: 4 = 0
        ASSERT  Zones = LowSector + 1
        ASSERT  ZoneSpare = Zones + 1
        LDR     lr, [r0, #LowSector]
        STR     lr, [r4, #DefectStruc + LowSector]
        LDR     lr, [r0, #RootDir]
d465 1
a465 1
	DREG	lr, "Setting RootDir to (FormSWIs, 439): "
d467 1
a467 1
        STR     lr, [r4, #DefectStruc + RootDir]
d470 3
a472 3
	; make assumption that disc size can not be more than 4G bytes
	MOV	r2, #0
	STR	r2, [r4, #DefectStruc + DiscSize2]
d474 2
a475 2
	LDR	lr, [r0, #ShareSize]
	STR	lr, [r4, #DefectStruc + ShareSize]
d479 2
a480 2
 	LDR	lr, [r0, #DiscVersion]
 	STR	lr, [r4, #DefectStruc + DiscVersion]
d485 1
a485 1
 	; we don't copy the RootSize field into the boot block
d494 1
a494 1
        STR     r2, [r4, #DefectStruc + DiscSize]
d496 1
a496 1
 	DREG	r2, "Disc size in LayoutBootBlock is:"
d553 1
a553 1
        LDRB    lr, [r5, #Zones]
d555 3
a557 3
	TEQ	lr, #0
	LDREQB	lr, [r5, #Zones2]
	TEQEQ	lr, #0
d594 1
a594 1
        LDRB    lr, [r5, #Heads]
d596 3
a598 3
        LDREQB  lr, [r5, #Density]
        TEQEQ   lr, #Double
        LDREQB  lr, [r5, #SectorSize]
d600 2
a601 2
        LDREQB  lr, [r5, #LowSector]
        TEQEQ   lr, #SequenceSides
d615 1
a615 1
        LDRB    lr, [r5, #Density]
d715 1
a715 1
        LDRB    lr, [r5, #SectorSize]
d743 1
a743 1
        ASSERT  DiscRecSig2 = 52
d754 1
a754 1
        ASSERT  DiscRecSig = 32
d758 2
a759 2
        LDR     r1, [r0, #DiscSize2]
        STR     r1, [r6, #DiscSize2]
d784 1
a784 1
        STR     r2, [r4, #ZoneHead + DiscSize]
d786 2
a787 2
	MOV	r2, #0
	STR	r2, [r4, #ZoneHead + DiscSize2]
d789 2
a790 2
	LDR	r2, [r5, #ShareSize]		; (and BigFlag, Zones2)
	STR	r2, [r4, #ZoneHead+ShareSize]
d794 2
a795 2
 	LDR	r2, [r5, #DiscVersion]
 	STR	r2, [r4, #ZoneHead+DiscVersion]
d799 3
a801 3
 	CMP	r2, #0
 	MOVNE	r2, #BigDirMinSize		; if big dirs, then store a 2048 byte dir min size
 	STR	r2, [r4, #ZoneHead+RootDirSize]	; otherwise store zero
d810 1
a810 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+0]
d813 1
a813 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+1]
d816 1
a816 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+2]
d819 1
a819 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+3]
d822 1
a822 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+4]
d825 1
a825 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+5]
d828 1
a828 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+6]
d831 1
a831 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+7]
d834 1
a834 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+8]
d837 1
a837 1
        STRNEB  lr, [r4, #ZoneHead+DiscName+9]
d845 1
a845 1
        STRB    lr, [r4, #ZoneHead+DiscId]
d847 1
a847 1
        STRB    lr, [r4, #ZoneHead+DiscId+1]
d852 5
a856 5
	Push    "r8"
	LDRB	lr, [r5, #Zones]
	LDRB	r8, [r5, #Zones2]
	ADD	lr, lr, r8, LSL #8
	Pull    "r8"
d858 1
a858 1
        LDRB    lr, [r5, #Zones]
d869 1
a869 1
        LDRB    r2, [r5, #LinkBits]
d880 1
a880 1
 DLINE  "LinkBits=2 written out"
d885 4
a888 4
	LDRB	r0, [r5, #Zones]
	LDRB	lr, [r5, #Zones2]
	ADD	r0, r0, lr, LSL #8
	TEQ	r0,#1
d890 1
a890 1
        LDRB    r0, [r5, #Zones]
d893 1
a893 1
	LDREQB	lr, [r5, #Density]
d902 1
a902 1
        LDRB    lr, [r5, #SectorSize]
d906 4
a909 4
 	LDR	lr, [r5, #RootDir]	; check if have big dirs
	MOV	lr, lr, LSR #8		; link bits...
	TEQS	lr, #2			; is it in the map object?
 	ADDEQ	r0, r0, #NewDirSize	; if it is not, then we place the root dir with the map
d934 10
a943 4
 	; if the root dir is in an object of its own, then it needs
 	; some space allocating.  the root dir disc address has already
 	; been passed in, mind you; we simply write out an object of
 	; the appropriate size
d945 1
a945 1
 	LDR	r0, [r5, #RootDir]
d947 1
a947 3
 	MOV	r0, r0, LSR #8		; linkbits
 	TEQS	r0, #2			; check if it's in the map object
 	BEQ	%FT50			; yes, so don't do owt
d949 1
a949 1
 	MOV	r1, r7
d951 1
a951 1
 	MOV	r10, r4
d953 2
a954 1
 	BL	PrimitiveFragWrLinkBits	; write 'em out
d956 3
a958 4
 	; then write out the length of the root dir object

 	MOV	r0, #BigDirMinSize
 	BL	RoundToObjSize		; (r0, r5)->(r0)
d960 1
a960 5
 	MOV	r1, r7
 	MOV	r10, r4
 	BL	PrimitiveFragWrLenBits	; and the length

 	ADD	r7, r7, r0		; and advance free pointer beyond the root dir
d966 1
a966 1
        LDRB    lr, [r5, #Zones]
d968 2
a969 2
        LDREQB	lr, [r5, #Zones2]
        TEQEQ	lr, #0
d971 1
a971 1
        LDRB    lr, [r5, #Zones]
d981 1
a981 1
        LDRB    r2, [r5, #LinkBits]
d1019 2
a1020 2
        ASSERT  ZoneSpare :MOD: 4 = 2
        LDR     lr, [r5, #ZoneSpare-2]
d1028 1
a1028 1
        LDR     r0, [r5, #DiscSize]
d1030 2
a1031 2
	LDRB	lr, [r5, #SectorSize]	; adjust for sector sizing
	MOV	r0, r0, LSR lr
d1077 1
a1077 1
        LDRB    r2, [r5, #LinkBits]
d1081 1
a1081 1
 DREG   r2, " LinkBits=",cc
d1096 1
a1096 1
 DREG   r2, " LinkBits=",cc
d1112 1
a1112 1
        LDRB    r2, [r5, #LinkBits]
d1161 1
a1161 1
        LDRB    r1, [r5, #SectorSize]   ; sector size in r1
d1166 1
a1166 1
        TST     r0, #&20000000
d1168 1
a1168 1
   	BNE	%FT70
d1174 1
a1174 1
        TST     r0, #&20000000
d1183 4
a1186 4
 	; here we do any second defect list processing, if needed
 	LDRB	lr, [r5, #BigFlag]
 	TSTS	lr, #BigFlagBit
 	BEQ	%FT80			; no second defect list
d1189 7
a1195 7
	LDR	r0, [r3], #4
	TST	r0, #&40000000
	BNE	%FT80			; end of second defect list

	BL	MapOutADefect
	BVS	%FT95
	B	%BT75
d1201 4
a1204 4
 	; r1 will be corrupted later so we use it...
 	LDRB	lr, [r5, #Zones]
 	LDRB	r1, [r5, #Zones2]
 	ADD	lr, lr, r1, LSL #8
d1206 1
a1206 1
        LDRB    lr, [r5, #Zones]
d1226 1
a1226 1
        LDRB    r7, [r5, #SectorSize]
d1228 3
a1230 3
        LDRB    r9, [r5, #Zones]
        LDRB	lr, [r5, #Zones2]	; safe to use lr, as it's followed by a BL
        ADD	r9, r9, lr, LSL #8
d1232 1
a1232 1
        LDRB    r9, [r5, #Zones]
d1237 1
a1237 1
	MOV	r2, r2, LSL r7
d1258 1
a1258 1
	MOV	r2, r2, LSL r7
d1277 4
a1280 4
  	; r2 should be available as it's used for the OS_GBPB above
  	LDRB	lr, [r5, #Zones]
  	LDRB	r2, [r5, #Zones2]
  	ADD	lr, lr, r2, LSL #8
d1282 1
a1282 1
	DREG	lr, "Zones are: "
d1285 1
a1285 1
        LDRB    lr, [r5, #Zones]
d1309 1
a1309 1
        LDRB    r1, [r5, #LinkBits]
d1311 1
a1311 1
        LDRB    lr, [r5, #BitSize]
d1319 2
a1320 2
        LDRB    r1, [r5, #SectorSize]
        LDRB    lr, [r5, #BitSize]
d1335 1
a1335 1
        LDRB    r1, [r5, #BitSize]
d1367 1
a1367 1
        LDRB    r0, [r5, #SectorSize]
d1378 1
a1378 1
        LDRB    r2, [r5, #LinkBits]
d1392 1
a1392 1
        LDRB    r9, [r5, #SectorSize]
d1396 2
a1397 2
        ASSERT  ZoneSpare:MOD:4 = 2
        LDR     lr, [r5, #ZoneSpare-2]
d1443 1
a1443 1
        ; R2 - LinkBits
d1581 1
a1581 1
        ; r2 - LinkBits
d1681 3
a1683 3
 	LDR	lr, [r0, #DiscVersion]
 	TEQ	lr, #0
 	BNE	%FT40			; long file names
d1688 4
a1691 4
 	LDRB	r5, [r0, #Zones2]
 	LDRB	lr, [r0, #Zones]
 	ADD	lr, lr, r5, LSL #8
 	MOV	r5, r0
d1694 1
a1694 1
        LDRB    lr, [r5, #Zones]
d1700 1
a1700 1
        LDRB    lr, [r5, #Heads]
d1714 4
a1717 4
        LDRB    r9, [r5, #Zones]
        LDRB	r7, [r5, #Zones2]
        ADD	r9, r9, r7, LSL #8
        LDRB    r7, [r5, #SectorSize]
d1719 2
a1720 2
        LDRB    r7, [r5, #SectorSize]
        LDRB    r9, [r5, #Zones]
d1725 1
a1725 1
	MOV	r2, r2, LSL r7
d1754 1
a1754 1
        LDRB    lr, [r5, #Zones]
d1757 2
a1758 2
 	LDREQB	lr, [r5, #Zones2]	; check also that Zones2 is 0
 	TEQEQ	lr, #0
d1760 1
a1760 1
        LDREQB  lr, [r5, #Heads]
d1814 1
a1814 1
	MOV	r5, r0
d1816 4
a1819 4
	LDRB	r7, [r5, #SectorSize]
	LDRB	r9, [r5, #Zones]
	LDRB	lr, [r5, #Zones2]
	ADD	r9, r9, lr, LSL #8		; total zones
d1821 1
a1821 1
	BL	MapDiscAdd			; (R5, R7, R9 -> R2)
d1823 1
a1823 1
	BIC	r2, r2, #DiscBits		; strip off the disc bits
d1825 1
a1825 1
	MOV	r2, r2, LSL r7
d1827 1
a1827 1
	; now need to work out the offset from the map to the root dir.
d1829 2
a1830 2
	MOV	r0, r9, LSL r7			; size of a single map copy
	MOV	r0, r0, LSL #1			; size of two copies of map
d1832 1
a1832 1
	BL	RoundToObjSize			; (R0,R5 -> R0)
d1834 1
a1834 1
	LDRB	lr, [r5, #BitSize]
d1836 1
a1836 1
	ADD	r2, r2, r0, LSL lr		; disc address of root dir
d1838 1
a1838 1
	MOV	r3, #BigDirMinSize		; size of root dir in r3
d1840 1
a1840 1
	MOV	r4, #ScratchSpace		; use scratch space to build dir
d1855 1
a1855 1
	; now contstruct the directory
d1857 2
a1858 2
	LDR	lr, SBProven2	; start name
	STR	lr, [r4, #BigDirStartName]
d1860 2
a1861 2
	MOV	lr, #1		; length of dir name
	STR	lr, [r4, #BigDirNameLen]
d1863 2
a1864 2
	MOV	lr, #BigDirMinSize	; size of dir
	STR	lr, [r4, #BigDirSize]
d1866 2
a1867 2
	MOV	lr, #0		; entries
	STR	lr, [r4, #BigDirEntries]
d1869 2
a1870 2
	MOV	lr, #0		; no names
	STR	lr, [r4, #BigDirNamesSize]
d1872 2
a1873 2
	LDR	lr, [r5, #RootDir]	; ind disc add of root dir
	STR	lr, [r4, #BigDirParent]
d1875 2
a1876 2
	MOV	lr, #'$'	; dir name
	ADD	lr, lr, #&D00	;
d1878 1
a1878 1
	STR	lr, [r4, #BigDirName]
d1880 1
a1880 1
	; now the tail
d1882 3
a1884 3
	ADD	r6, r4, r3		; end name
	LDR	lr, SBProven2+4
	STR	lr, [r6, #BigDirEndName]
d1886 1
a1886 1
	; now the check byte
d1888 3
a1890 3
	MOV	r5, r4
	BL	TestBigDirCheckByte	; (R5, R6->LR, Z)
	STRB	lr, [r6, #BigDirCheckByte] ; check byte now stored
@


4.9
log
@Fix bug in DetermineDiscType.
When failed to identify, and the last operation was format, the DiscSize2 field was not being copied (instead DiscSize is copied twice).
Fix up some warnings from the assembler.
Tested briefly with a RAM disc, still works.

Version 3.44. Tagged as 'FileCore-3_44'
@
text
@a750 2
        LDMIA   r0!, {r1-r3,r10}
        STMIA   r6!, {r1-r3,r10}
@


4.8
log
@  Fix for alignment exception on ARMv7
Detail:
  The Density field in the disc record is a byte at a non-word-aligned address
  but it was being loaded here with an LDR instruction. There is actually a
  pre-existing bug here, since the code at lines 904-905 would only have been
  executed on earlier CPUs if SectorSize, SecsPerTrk and Heads were all zero
  too. This would correspond to an implausibly small hard disc, so arguably
  this part of the branch should perhaps be removed altogether?
Admin:
  Untested at ROOL.
  Submission from Willi Thei [comments above are my own - BA]

Version 3.40. Tagged as 'FileCore-3_40'
@
text
@d753 2
a754 3
        LDMIA   r0!, {r1}
        STMIA   r6!, {r1}

d854 1
a854 1
	STMFD	r13!, {r8}
d858 1
a858 1
	LDMFD	r13!, {r8}
@


4.7
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  Many of these are unaligned LDRs where only bits 0-7 of the result are used
  (tested against a bitmask or used as an input to the barrel shifter) but
  they have all been moved to byte operations because they are faster on
  ARMv6 and won't cause false positives if unaligned aborts are enabled.

  s.BigDirCode line 104: not wrong as such, but changed to use aligned LDR
    for speed on ARMv6.
  s.BigDirCode line 1727: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.Commands line 129: STR to an unaligned 1-byte variable. Harmless because
    all overlapping variables are initialised later on.
  s.Commands line 539: LDR of an unaligned 1-byte variable. Only used for
    testing bit 6.
  s.FileCore31 line 1359: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.FileCore32 lines 1483 and 1825: LDR of an unaligned 1-byte variable. Only
    used as input to shifter.
  s.FormSWIs line 1403: bugfix: incorrect load of 16-bit zone_spare field of
    disc record - uses lowsector and nzones fields instead! This is used to
    terminate the search of free space fragments within the allocation bytes
    of the current map block for the one containing a bad block found during
    formatting. Would manifest itself as a "Can't map defect out" error.
  s.GenSWIs lines 1182,1195: bugfix: LDR of 1-byte variables. Effect of this
    was that range-checking of the drive number passed to FileCore_MiscOp 5
    (eject) wasn't performed.
  Added ENTRY directive to permit building of GPA debug listing.
Admin:
  Builds, but untested.

Version 3.34. Tagged as 'FileCore-3_34'
@
text
@d896 1
a896 1
        LDREQ   lr, [r5, #Density]
@


4.6
log
@* Various 32-bit compatibility fixes.
* Can use HAL for FIQ+timer manipulations.
* FileCore_DiscOp64 added (as user API - currently just converted to the
  standard byte or sector DiscOp call to the underlying module). See
  Doc.32bitAPIs for full details.
* New error-passing scheme to modules added (for full 32-bit addressing).
* FileCore_Features added (indicates new error scheme).
* OS_FSControl 49 (read 32-bit free space) now reports sensible clamped
  values for large discs, rather than values modulo 2^32.
* Accessing the end of files near 2GB in size could cause lock-ups in
  background transfers.
* F(+) and G(+) disc formats adjusted to have a little more skew to
  help the rather poor Iyonix floppy controller.

Version 3.31. Tagged as 'FileCore-3_31'
@
text
@d1400 1
a1400 1
        LDR     lr, [r5, #ZoneSpare]
@


4.5
log
@
  * Removed dependency on obsolete STB and StrongARM flags.

Detail:

  * No longer reliant on STB flag.  Now both Desktop and Embedded builds
    are the same (which, of course, they should be).

Admin:

  * StripDepnd support moved to MkClean file.

  * The "What'sHere" file has been renamed to "ReadMe", since the existence
    of the single-quote causes problems with some Unix commands (notably
    'xargs').

  * Built and tested in a Lazarus 32-bit build.

Version 3.27. Tagged as 'FileCore-3_27'
@
text
@d194 4
d200 1
d223 4
d229 1
@


4.4
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@a1918 1
  [ StrongARM
a1934 42

  |

        Push    "r0,r1,r11,lr"

        ; 'Leave' FileCore out the bottom - but allow reentry (once)
        TEQ     SB, #0
        BLNE    DoExternal

        ; Construct
        ; SWI <the swi>
        ; MOV pc, r11
        ; on the stack
        SUB     sp, sp, #2*4
        ADR     r0, SwiTemplate
        LDMIA   r0, {r0,r1}
        ORR     r0, r0, r11
        ORR     r0, r0, #Auto_Error_SWI_bit
        STMIA   sp, {r0,r1}

        ; restore r0 and r1
        ADD     r11, sp, #2*4
        LDMIA   r11, {r0,r1}

        ; Call the code of the stack (standard BL sp, but lr is r11 in this case)
        MOV     r11, pc
        MOV     pc, sp

        ; 'Enter' FileCore.
        TEQ     SB, #0
        BLNE    Internal

        ; Drop the instructions on the stack, and r0, r1 in
        ADD     sp, sp, #2*4 + 2*4

        Pull    "r11,pc"

SwiTemplate
        SWI     0
        MOV     pc, r11

 ] ; StrongARM / not StrongARM
@


4.3
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d1334 1
a1334 1
        Pull    "r1,pc",,^
d1757 1
a1757 2
        MOV     lr, pc
        TEQP    lr, #Z_bit
@


4.2
log
@RiscOS 3.70 version used
@
text
@d268 4
a271 4
 [ BigDisc
        LDR     lr, [r0,#DiscSize2]
        STR     lr, [r8,#DiscSize2]
 ]
d277 12
d293 9
d376 19
d412 23
d454 3
d459 20
d485 2
a486 4
 [ BigDisc
	; make assumption that disc size can not be more than 4G bytes
	MOV	r2, #0
	STR	r2, [r4, #DefectStruc + DiscSize2]
a487 1

d544 5
d550 1
d732 15
d758 1
d781 14
d844 7
d852 1
d865 4
d870 1
d877 6
d885 1
d898 6
d905 2
d914 3
d918 1
d926 30
d958 1
d961 6
d979 3
d983 1
d990 3
d994 1
d1077 4
d1082 2
d1093 4
d1098 1
d1118 6
d1127 1
d1137 5
d1145 1
d1160 3
d1164 1
d1174 17
d1193 6
d1200 1
d1220 1
d1222 5
d1269 9
d1279 1
d1376 3
d1380 1
d1399 4
d1404 1
d1410 5
d1416 1
d1455 3
d1459 1
d1532 3
d1536 1
d1552 3
d1556 1
d1562 3
d1566 1
d1589 3
d1593 1
d1612 3
d1616 1
d1621 3
d1625 1
d1631 3
d1635 1
d1647 3
d1651 1
d1672 14
a1686 1

d1688 1
d1706 6
d1714 1
d1749 4
d1802 107
@


4.2.2.1
log
@Changes made to FileCore to support allowing idlen more than 15.  This allows
smaller LFAUs on discs.  The changes are not yet complete.  In particular, the
number of disc zones is limited to 255.  Some development testing has been
peformed, and the filing system is generally stable.  Areas which haven't
been fully tested include things like *Defect, FileCore_LayoutStructure,
FileCore_FloppyStructure, and the FileSwitch APIs for reading and examining
a disc's used space.

This version should not be used for any OS Builds with the BigMaps flag set
to true.  It should build as a normal version of FileCore with BigMaps and
BigDirs set to false.
@
text
@a737 4
 
 [ BigMaps
        BL      PrimitiveFragWrLinkBits
 |
a738 1
 ]
a766 3
 [ BigMaps
        BL      PrimitiveFragWrLenBits
 |
a767 1
 ]
a790 3
 [ BigMaps
        BL      PrimitiveFragWrLinkBits
 |
a791 1
 ]
a797 3
 [ BigMaps
        BL      PrimitiveFragWrLenBits
 |
a798 1
 ]
a880 4
 
 [ BigMaps
        BL      PrimitiveFragWrLinkBits
 |
a881 2
 ]
 
a890 4
 
 [ BigMaps
        BL      PrimitiveFragWrLenBits
 |
a891 1
 ]
a910 6
 
 [ BigMaps
        BLNE    PrimitiveFreeWrLenBits
        MOVNE   r0, #0
        BLNE    PrimitiveFreeWrLinkBits
 |
a913 1
 ]
a922 5
 [ BigMaps
        BL      PrimitiveFreeWrLinkBits
        MOV     r0, #16
        BL      PrimitiveFreeWrLenBits
 |
a925 1
 ]
a1111 3
 [ BigMaps
        BL      PrimitiveFreeRdLinkBits ; (r10,r11->r8,Z)
 |
a1112 1
 ]
a1130 4
 
 [ BigMaps
        BL      PrimitiveFragRdLenBits
 |
a1131 1
 ]
a1136 5


 [ BigMaps
        BL      PrimitiveFragRdLinkBits     ; (r2,r10,r11->r8,Z) Next free fragment
 |
a1137 1
 ]
a1175 3
 [ BigMaps
        BL      PrimitiveFragRdLinkBits
 |
a1176 1
 ]
a1248 3
 [ BigMaps
        BL      PrimitiveFreeWrLenBits
 |
a1249 1
 ]
a1264 3
 [ BigMaps
        BL      PrimitiveFreeRdLinkBits
 |
a1265 1
 ]
a1270 3
 [ BigMaps
        BL      PrimitiveFreeWrLinkBits
 |
a1271 1
 ]
a1293 3
 [ BigMaps
        BL      PrimitiveFragWrLinkBits
 |
a1294 1
 ]
a1312 3
 [ BigMaps
        BL      PrimitiveFreeRdLinkBits     ; (r2,r10,r11->r8)
 |
a1313 1
 ]
a1317 3
 [ BigMaps
        BL      PrimitiveFreeWrLinkBits ; (r0,r1,r2,r10->)
 |
a1318 1
 ]
a1323 3
 [ BigMaps
        BL      PrimitiveFreeWrLinkBits
 |
a1324 1
 ]
a1335 3
 [ BigMaps
        BL      PrimitiveFragWrLenBits
 |
a1336 1
 ]
@


4.2.2.2
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@a460 5
 [ BigMaps
	TEQ	lr, #0
	LDREQB	lr, [r5, #Zones2]
	TEQEQ	lr, #0
 |
a461 1
 ]
a724 7
 [ BigMaps
	STMFD	r13!, {r8}
	LDRB	lr, [r5, #Zones]
	LDRB	r8, [r5, #Zones2]
	ADD	lr, lr, r8, LSL #8
	LDMFD	r13!, {r8}
 |
a725 1
 ]
a749 6
 [ BigMaps
	LDRB	r0, [r5, #Zones]
	LDRB	lr, [r5, #Zones2]
	ADD	r0, r0, lr, LSL #8
	TEQ	r0,#1
 |
a751 1
 ]
a785 6
 [ BigMaps
        LDRB    lr, [r5, #Zones]
        TEQ     lr, #1
        LDREQB	lr, [r5, #Zones2]
        TEQEQ	lr, #0
 |
a787 1
 ]
a992 6
 [ BigMaps
 	; r1 will be corrupted later so we use it...
 	LDRB	lr, [r5, #Zones]
 	LDRB	r1, [r5, #Zones2]
 	ADD	lr, lr, r1, LSL #8
 |
a993 1
 ]
a1012 5
 [ BigMaps
        LDRB    r9, [r5, #Zones]
        LDRB	lr, [r5, #Zones2]	; safe to use lr, as it's followed by a BL
        ADD	r9, r9, lr, LSL #8
 |
a1013 1
 ]
a1055 6
  [ BigMaps
  	; r2 should be available as it's used for the OS_GBPB above
  	LDRB	lr, [r5, #Zones]
  	LDRB	r2, [r5, #Zones2]
  	ADD	lr, lr, r2, LSL #8
  |
a1056 1
  ]
a1448 8
 
 [ BigMaps
 ; we delay the mov r5, r0 to allow r5 to be used as scratch
 	LDRB	r5, [r0, #Zones2]
 	LDRB	lr, [r0, #Zones]
 	ADD	lr, lr, r5, LSL #8
 	MOV	r5, r0
 |
d1450 1
a1451 1
 ]
a1468 6
 [ BigMaps
        LDRB    r9, [r5, #Zones]
        LDRB	r7, [r5, #Zones2]
        ADD	r9, r9, r7, LSL #8
        LDRB    r7, [r5, #SectorSize]
 |
a1470 1
 ]
a1504 4
 [ BigMaps
 	LDREQB	lr, [r5, #Zones2]	; check also that Zones2 is 0
 	TEQEQ	lr, #0
 ]
@


4.2.2.3
log
@Now supports formatting of floppies with long file names.
@
text
@d268 4
a271 4
; [ BigDisc
;        LDR     lr, [r0,#DiscSize2]
;        STR     lr, [r8,#DiscSize2]
; ]
a275 12
 
 [ BigMaps :LOR: BigDir
 	ASSERT	DiscSize2-DiscRecSig=4
 	ASSERT	DiscRecSig2-DiscSize2=4*4
 	
 	; copy extra fields
 	ADD	r8, r8, #4
 	ADD	r0, r0, #4
 	LDMIA	r0!, {r4-r7}
 	STMIA	r8!, {r4-r7}
 
 ]
a280 9
        
 [ BigMaps
 	LDRLSB	r0, LayoutDiscRec+Zones2	; top byte of zones number
 	ADDLS	lr, lr, r0, LSL #8
 ]
  [ DebugO
  	DREG	lr, "zones from rec: "
  ]

a353 19
        
 [ BigDisc
 	; if there's a second defect list present, then do it
 	LDRB	lr, [r0, #BigFlag]	;
 	TSTS	lr, #BigFlagBit
 	BEQ	%FT15			; if this big clear, then no need to check flag
 	
 	; here we have a second defect list
 
12
        LDR     lr, [r1, r5]
        STR     lr, [r4, r5]
        CMP     lr, #&40000000
        ADDLO   r5, r5, #4
        CMPLO   r5, #SzDefectList - MaxStruc
        BLO     %BT12

15
 ]
a371 23

 [ BigDisc
	; check again for presence of the second defect list
	
	LDRB	lr, [r0, #BigFlag]
	TSTS	lr, #BigFlagBit
	BEQ	%FT30			; no second defect list
	
	MOV	r1, #0
	MOV	r5, r4
25
        LDR     lr, [r5], #4
        TSTS    lr, #&40000000
        EOREQ   r1, lr, r1, ROR #13
        BEQ     %BT25
        EOR     r1, r1, r1, LSR #16
        EOR     r1, r1, r1, LSR #8
        STRB    r1, [r5, #-4]

30

 ]

a392 20
 [ BigDisc
	; make assumption that disc size can not be more than 4G bytes
	MOV	r2, #0
	STR	r2, [r4, #DefectStruc + DiscSize2]
	
	LDR	lr, [r0, #ShareSize]
	STR	lr, [r4, #DefectStruc + ShareSize]
 ]
 
 [ BigMaps
 	LDR	lr, [r0, #DiscVersion]
 	STR	lr, [r4, #DefectStruc + DiscVersion]
 ]
 
 [ BigDir
 
 	; we don't copy the RootSize field into the boot block
 
 ]

d399 4
a402 2
 [ DebugO
 	DREG	r2, "Disc size in LayoutBootBlock is:"
d404 1
a648 15
 [ BigMaps
        ASSERT  DiscRecSig2 = 52
        ADD     r6, r4, #ZoneHead
        MOV     r0, r5

        LDMIA   r0!, {r1-r3,r10}
        STMIA   r6!, {r1-r3,r10}
        LDMIA   r0!, {r1-r3,r10}
        STMIA   r6!, {r1-r3,r10}
        LDMIA   r0!, {r1-r3,r10}
        STMIA   r6!, {r1-r3,r10}
        LDMIA   r0!, {r1}
        STMIA   r6!, {r1}

 |
a659 1
 ]
a681 14
	
	LDR	r2, [r5, #ShareSize]		; (and BigFlag, Zones2)
	STR	r2, [r4, #ZoneHead+ShareSize]
 ]
 
 [ BigMaps
 	LDR	r2, [r5, #DiscVersion]
 	STR	r2, [r4, #ZoneHead+DiscVersion]
 ]
 
 [ BigDir
 	CMP	r2, #0
 	MOVNE	r2, #BigDirMinSize		; if big dirs, then store a 2048 byte dir min size
 	STR	r2, [r4, #ZoneHead+RootDirSize]	; otherwise store zero
a784 6
 [ BigDir
 	LDR	lr, [r5, #RootDir]	; check if have big dirs
	MOV	lr, lr, LSR #8		; link bits...
	TEQS	lr, #2			; is it in the map object?
 	ADDEQ	r0, r0, #NewDirSize	; if it is not, then we place the root dir with the map
 |
a785 2
 ]

a803 30
        
 [ BigMaps
 	; if the root dir is in an object of its own, then it needs
 	; some space allocating.  the root dir disc address has already
 	; been passed in, mind you; we simply write out an object of
 	; the appropriate size
 	
 	LDR	r0, [r5, #RootDir]
 	
 	MOV	r0, r0, LSR #8		; linkbits
 	TEQS	r0, #2			; check if it's in the map object
 	BEQ	%FT50			; yes, so don't do owt

 	MOV	r1, r7
 	
 	MOV	r10, r4
 	
 	BL	PrimitiveFragWrLinkBits	; write 'em out
 	
 	; then write out the length of the root dir object
 	
 	MOV	r0, #BigDirMinSize
 	BL	RoundToObjSize		; (r0, r5)->(r0)
 	
 	MOV	r1, r7
 	MOV	r10, r4
 	BL	PrimitiveFragWrLenBits	; and the length
 	
 	ADD	r7, r7, r0		; and advance free pointer beyond the root dir
 ]
a1008 3
   [ BigMaps
   	BNE	%FT70
   |
a1009 1
   ]
a1017 17
 
 [ BigMaps
70
 	; here we do any second defect list processing, if needed
 	LDRB	lr, [r5, #BigFlag]
 	TSTS	lr, #BigFlagBit
 	BEQ	%FT80			; no second defect list
 	
75
	LDR	r0, [r3], #4
	TST	r0, #&40000000
	BNE	%FT80			; end of second defect list
	
	BL	MapOutADefect
	BVS	%FT95
	B	%BT75
 ]
d1238 1
a1238 1
        BL      PrimitiveFreeRdLinkBits     ; (r2,r10,r11->r8,Z) Next free fragment
a1497 6
 [ BigDir
 	LDR	lr, [r0, #DiscVersion]
 	TEQ	lr, #0
 	BNE	%FT40			; long file names
 ]
 
a1620 107

 [ BigDir

; here if Big Dir

40
	MOV	r5, r0
	
	LDRB	r7, [r5, #SectorSize]
	LDRB	r9, [r5, #Zones]
	LDRB	lr, [r5, #Zones2]
	ADD	r9, r9, lr, LSL #8		; total zones
	
	BL	MapDiscAdd			; (R5, R7, R9 -> R2)
	
	BIC	r2, r2, #DiscBits		; strip off the disc bits
	
	MOV	r2, r2, LSL r7
	
	; now need to work out the offset from the map to the root dir.
	
	MOV	r0, r9, LSL r7			; size of a single map copy
	MOV	r0, r0, LSL #1			; size of two copies of map
	
	BL	RoundToObjSize			; (R0,R5 -> R0)
	
	LDRB	lr, [r5, #BitSize]
	
	ADD	r2, r2, r0, LSL lr		; disc address of root dir
	
	MOV	r3, #BigDirMinSize		; size of root dir in r3
	
	MOV	r4, #ScratchSpace		; use scratch space to build dir
	
 [ DebugO
 DREG   r2, "Location of root dir is "
 DREG   r3, "Size of root dir is "
 ]
  	
        ; Zero out the dir
        ADD     r1, r4, r3
        MOV     r0, #0
50
        STR     r0, [r1, #-4]!
        CMP     r1, r4
        BHI     %BT50

	; now contstruct the directory

	LDR	lr, SBProven2	; start name
	STR	lr, [r4, #BigDirStartName]
	
	MOV	lr, #1		; length of dir name
	STR	lr, [r4, #BigDirNameLen]
	
	MOV	lr, #BigDirMinSize	; size of dir
	STR	lr, [r4, #BigDirSize]
	
	MOV	lr, #0		; entries
	STR	lr, [r4, #BigDirEntries]
	
	MOV	lr, #0		; no names
	STR	lr, [r4, #BigDirNamesSize]
	
	LDR	lr, [r5, #RootDir]	; ind disc add of root dir
	STR	lr, [r4, #BigDirParent]
	
	MOV	lr, #'$'	; dir name
	ADD	lr, lr, #&D00	; 
	
	STR	lr, [r4, #BigDirName]
	
	; now the tail
	
	ADD	r6, r4, r3		; end name
	LDR	lr, SBProven2+4
	STR	lr, [r6, #BigDirEndName]	
	
	; now the check byte
	
	MOV	r5, r4
	BL	TestBigDirCheckByte	; (R5, R6->LR, Z)
	STRB	lr, [r6, #BigDirCheckByte] ; check byte now stored
	
        MOV     r0, #OSGBPB_WriteAtGiven
        LDR     r1, [sp, #3*4]
        MOV     r4, r2
        MOV     r2, #ScratchSpace
 [ DebugO
 DREG   r0,"OS_GBPB(",cc
 DREG   r1,",",cc
 DREG   r2,",",cc
 DREG   r3,",",cc
 DREG   r4,",",cc
 DLINE  ")"
 ]
        BL      DoXOS_GBPB

        STRVS   r0, [sp]
        Pull    "r0-r9,pc"
	

SBProven2
 = "SBPr"
 = "oven"
	
 ]
@


4.2.2.4
log
@Found a major inefficiency in the handling of file creation, closing of files
and other uses of the NextFree function.  In the case of file creation, the
problem was particularly bad on large free space maps, as the function was
of order N^2 on the size of the map, when the disc was nearly full.  As the
disc gets fuller, the problem gets worse; with 1400 zones in the map, N^2
is very large indeed.  This resulted in *cdir sometimes taking 1sec.

Now, a new function NextFree_Quick exists which performs similarly to NextFree,
but does not consider free spaces in zones beyond the current zone.  This
can be used by functions which need only examine free spaces in a given zone,
such as is the case in ClaimFreeSpace where it is stepping throigh zones to
find a single gap large enough for the entire file.

For other functions which work on a single zone, the speedup is less dramatic,
of the order N instead of N^2.
@
text
@d276 1
a276 1

d280 1
a280 1

d286 1
a286 1

d293 1
a293 1

d375 1
a375 1

d381 1
a381 1

d383 1
a383 1

d415 1
a415 1

d419 1
a419 1

a453 3
 [ DebugL
	DREG	lr, "Setting RootDir to (FormSWIs, 439): "
 ]
d460 1
a460 1

d464 1
a464 1

d469 1
a469 1

d471 1
a471 1

d473 1
a473 1

d778 1
a778 1

d782 1
a782 1

d787 1
a787 1

d862 1
a862 1

d922 1
a922 1

d928 1
a928 1

d930 1
a930 1

d936 1
a936 1

d938 1
a938 1

d940 1
a940 1

d942 1
a942 1

d945 1
a945 1

d949 1
a949 1

d1074 1
a1074 1

d1080 1
a1080 1

d1090 1
a1090 1

d1115 1
a1115 1

d1170 1
a1170 1

d1177 1
a1177 1

d1182 1
a1182 1

d1393 1
a1393 1

d1666 1
a1666 1

d1672 1
a1672 1

d1803 1
a1803 1

d1808 1
a1808 1

d1810 1
a1810 1

d1812 1
a1812 1

d1814 1
a1814 1

d1816 1
a1816 1

d1819 1
a1819 1

d1821 1
a1821 1

d1823 1
a1823 1

d1825 1
a1825 1

d1827 1
a1827 1

d1829 1
a1829 1

d1834 1
a1834 1

d1847 1
a1847 1

d1850 1
a1850 1

d1853 1
a1853 1

d1856 1
a1856 1

d1859 1
a1859 1

d1862 1
a1862 1

d1864 2
a1865 2
	ADD	lr, lr, #&D00	;

d1867 1
a1867 1

d1869 1
a1869 1

d1872 2
a1873 2
	STR	lr, [r6, #BigDirEndName]

d1875 1
a1875 1

d1879 1
a1879 1

d1896 1
a1896 1

d1901 1
a1901 1

@


4.2.2.5
log
@Fixed bug with zone compaction with idlen>15, in CompactZone.
@
text
@a1273 3
 [ DebugO
	DREG	lr, "Zones are: "
 ]
@


4.1
log
@Initial revision
@
text
@d1473 20
d1530 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a1472 20
  [ StrongARM
    ;use OS_CallASWI - avoids need for dynamic code

        Push    "r10,lr"

        ; 'Leave' FileCore out the bottom - but allow reentry (once)
        TEQ     SB, #0
        BLNE    DoExternal

        ORR     r10,r11,#Auto_Error_SWI_bit  ;OS_CallASWI uses r10 for SWI number, also make it an X SWI
        SWI     XOS_CallASWI

        ; 'Enter' FileCore.
        TEQ     SB, #0
        BLNE    Internal

        Pull    "r10,pc"

  |

a1509 2

 ] ; StrongARM / not StrongARM
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

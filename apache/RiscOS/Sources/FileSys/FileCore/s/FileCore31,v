head	4.13;
access;
symbols
	FileCore-3_75:4.13
	FileCore-3_74:4.12
	FileCore-3_73:4.11
	FileCore-3_72:4.11
	FileCore-3_71:4.10
	FileCore-3_70:4.10
	FileCore-3_69:4.10
	FileCore-3_68:4.10
	FileCore-3_67:4.10
	FileCore-3_66:4.10
	FileCore-3_65:4.10
	FileCore-3_64:4.10
	FileCore-3_63:4.10
	FileCore-3_62:4.10
	FileCore-3_61:4.10
	FileCore-3_60:4.10
	FileCore-3_59:4.10
	FileCore-3_58:4.10
	FileCore-3_57:4.10
	FileCore-3_56:4.9
	FileCore-3_55:4.8
	FileCore-3_54:4.7
	FileCore-3_53:4.7
	FileCore-3_52:4.7
	FileCore-3_51:4.7
	FileCore-3_50:4.7
	FileCore-3_49:4.7
	FileCore-3_48:4.7
	FileCore-3_47:4.7
	FileCore-3_46:4.7
	FileCore-3_45:4.7
	FileCore-3_44:4.6
	FileCore-3_43:4.5
	FileCore-3_42:4.5
	FileCore-3_41:4.4
	FileCore-3_40:4.4
	FileCore-3_39:4.4
	FileCore-3_38:4.4
	FileCore-3_37:4.4
	FileCore-3_36:4.4
	FileCore-3_35:4.4
	FileCore-3_34:4.4
	FileCore-3_33:4.3
	RO_5_07:4.3
	FileCore-3_32:4.3
	FileCore-3_31:4.3
	FileCore-3_30:4.3
	FileCore-3_29:4.3
	FileCore-3_28:4.3
	FileCore-3_25-4_9_2_2:4.3
	FileCore-3_27:4.3
	FileCore-3_26:4.3
	FileCore-3_22-4_6_2_1:4.2
	bavison_FileCore-3_22_dev_bp:4.2
	bavison_FileCore-3_22:4.2.0.2
	FileCore-3_25-4_9_2_1:4.3
	HAL:4.3.0.2
	FileCore-3_25:4.3
	FileCore-3_24:4.3
	FileCore-3_23:4.3
	dellis_autobuild_BaseSW:4.2
	FileCore-3_22:4.2
	Ursula_merge:4.1.4.7
	ROL_merge:4.1.4.7
	FileCore-3_21:4.2
	ROL_Ursula_merge:4.1.4.7
	Ursula_RiscPC_merge:4.1.4.6
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.3
	ROL_FileCore-3_21:4.1.4.7
	ROL_FileCore-3_20:4.1.4.7
	ROL:4.1.4.7.0.2
	ROL_bp:4.1.4.7
	Ursula_RiscPC_bp:4.1.4.6
	FileCore-3_18:4.1.4.7
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.6
	Ursula_RiscPC:4.1.4.6.0.2
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1.4.7
	sproven_FileCore-3_16:4.1.4.7
	rthornb_UrsulaBuild-19Aug1998:4.1.4.6
	UrsulaBuild_FinalSoftload:4.1.4.6
	rthornb_UrsulaBuild-12Aug1998:4.1.4.6
	aglover_UrsulaBuild-05Aug1998:4.1.4.6
	rthornb_UrsulaBuild-29Jul1998:4.1.4.6
	rthornb_UrsulaBuild-22Jul1998:4.1.4.6
	rthornb_UrsulaBuild-15Jul1998:4.1.4.6
	rthornb_UrsulaBuild-07Jul1998:4.1.4.6
	rthornb_UrsulaBuild-17Jun1998:4.1.4.6
	rthornb_UrsulaBuild-03Jun1998:4.1.4.6
	rthornb_UrsulaBuild-27May1998:4.1.4.6
	rthornb_UrsulaBuild-21May1998:4.1.4.6
	sproven_FileCore-3_15:4.1.4.6
	sproven_314:4.1.4.6
	rthornb_UrsulaBuild_01May1998:4.1.4.5
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.5
	sproven_3_11:4.1.4.5
	sproven_3_10:4.1.4.5
	sproven_Ursula_3_09:4.1.4.5
	sproven_3_07:4.1.4.5
	sproven_3_06:4.1.4.4
	sproven_3_05:4.1.4.4
	sproven_3_04:4.1.4.4
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.4
	sproven_3_02:4.1.4.3
	sproven_3_01:4.1.4.2
	sproven_2_99:4.1.4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2017.07.06.14.19.16;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	8jE9i1ldP8DSXaYz;

4.12
date	2017.06.16.11.00.36;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	izYr8Uu33U8FvAVz;

4.11
date	2017.04.09.22.17.12;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	0hBpFTzNopSirUMz;

4.10
date	2013.03.25.20.31.08;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	vCGDXb1zgPQnidJw;

4.9
date	2013.02.24.21.09.15;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	rgJG8ZFRF8o9ruFw;

4.8
date	2013.02.21.16.53.07;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	CCuV2tngKttj75Fw;

4.7
date	2011.10.14.07.23.51;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	D2Id4aPp4zmuUhDv;

4.6
date	2011.10.12.20.21.50;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	BoinxgqWMKLth6Dv;

4.5
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	A9Zxco9ydo9FCOBv;

4.4
date	2009.06.15.23.25.35;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.09.11.36.54;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.23.23;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.08.14.13.13.08;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.09.16.14.46.42;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.11.17.13.32.26;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	97.12.01.12.03.02;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.01.23.16.41.25;	author sproven;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.05.07.16.58.08;	author sproven;	state Exp;
branches;
next	4.1.4.7;

4.1.4.7
date	98.09.02.16.14.58;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.03;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.30.57;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Comments improved
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >FileCore31

; *********************************
; ***  CHANGE LIST AND HISTORY  ***
; *********************************
;
; 16-Jun-94   AMcC  Replaced ScratchSpaceSize with ?ScratchSpace
;
; 08-Sep-94   SBP   Added AMG's fix to NewClaimFree
;
; 28 May 1997 SBP   Changed for IdLen>15


        TTL     "New map allocation"

; ============
; NewClaimFree
; ============

; Find and claim free space for object in a new map disc

; entry
; ...tail called from ClaimFreeSpace with "R0,R1,R4-R11,LR" stacked
; R3 top 3 bits=disc num
; R5 -> dir start Save/Create/Close Only
; R10 size needed ( old size for OpenOutCreate )
; R11 fsfile_Save/fsfile_Create/UnsharedCreate/CloseSmall/CloseContig/RandomAccessCreate/RandomAccessExtend
; LR ->disc rec
; C=1 <=> RandomAccess

NewClaimFree ROUT
 [ DebugE :LOR: DebugEs
        DREG    R3, "NewClaimFree(",cc
        DREG    R5, ",",cc
        DREG    R10, ",",cc
        DREG    R11, ",",cc
        DLINE   ")"
 ]

        MOV     R1, LR                  ;->disc rec
        BCS     NewRandomClaim
        SUBS    R0, R10,#0              ;V=0
        ANDEQ   R2, R3, #DiscBits       ;zero length request
        ORREQ   R2, R2, #1              ;useful to treat 0 length as shared obj
      [ BigFiles
        BEQ     %FT91
      |
        MOVLT   R0, #DiscFullErr
        BLE     %FT93
      ]
        MOV     R9, R0
        BL      RoundUpAlloc            ;(R0,R3->R0)
        LDRB    LR, [R1,#DiscRecord_Log2bpmb]
      [ BigFiles
        TEQ     R0, #RoundedTo4G
        ASSERT  RoundedTo4G = 1
        MOVEQ   R4, R0, ROR LR
        MOVNE   R4, R0, LSR LR
      |
        MOV     R4, R0, LSR LR
      ]

        ASSERT  fsfile_CreateDir=UnsharedCreate
        TEQS    R11,#UnsharedCreate
        BL      CritInitReadNewFs       ;(->R10,R11)
 [ BigMaps
        LDREQB  R0, [R10,#ZoneHead+DiscRecord_NZones]
        LDREQB  LR, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADDEQ   R0, R0, LR, LSL #8
 |
        LDREQB  R0, [R10,#ZoneHead+DiscRecord_NZones]
 ]
        MOVEQ   R0, R0, LSR #1          ;dir search starts from central map zone
        BEQ     %FT09                   ;a dir can't share with existing objects

        BL      AllocBitWidth   ;(R10->LR)
        MOV     R0, LR
        BL      MinMapObj       ;(R10->LR)
        SUB     LR, LR, R0
        CMPS    R4, LR, LSL #1
        BHI     %FT08           ;too big to share a map obj
        Push    "R4"
        BL      SortDir         ;(R3,R5->R8)

;Find smallest suitable space (if any) in shared fragments
;R0 temp                        ;R4 dir offset          ;R8  -> sorted list
;R1 end sector prev obj in frag ;R5 link bits           ;R9  len needed in secs
;R2 best disc address           ;R6 smallest fit        ;R10 -> map start
;R3 dir                         ;R7 log2 sector size    ;R11 sec size - 1

        MOV     R6, #1024*K        ;init smallest fit
        LDRB    R7, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
 [ BigShare
        LDRB    LR, [R10, #ZoneHead+DiscRecord_BigMap_ShareSize]  ; get sharing unit
        ADD     R7, R7, LR                      ; get overall sharing size (sectors*sharing unit)
 ]
        MOV     R11,#1
        RSB     R11,R11,R11,LSL R7
        TSTS    R9, R11
        MOV     R9, R9, LSR R7
        ADDNE   R9, R9, #1      ;sharing blocks needed
02
        MOV     R1, #1          ;init end sector offset of prev obj in frag
04                      ;NOW EXAMINE EACH SHARED OBJ IN DIR IN ORDER
 [ BigMaps; :LAND: {FALSE}
        LDMIA   R8!, {R4, R5}   ; r4 - index into dir
        AND     R0, R5, #&FF    ; r5 - sharing offset
        TEQS    R5, #0
        TEQEQS  R4, #0
        BEQ     %FT06           ;end of list marker found
        MOVS    R5, R5, LSR #9  ;link bits from word 1 bits 9-31
 |
        LDRB    R4, [R8]        ;index in dir
        LDRB    R0, [R8,#1]     ;sharing offset in frag
        LDR     R5, [R8],#4
        TEQS    R5, #0
        BEQ     %FT06           ;end of list marker found
        MOVS    R5, R5, LSR #17 ;link bits from bits 17-31
 ]
        ADDCS   R5, R5, R3, LSR #8
        RSBCC   R5, R5, R3, LSR #8
 [ DebugE :LOR: DebugEs
        DREG    R0, "File sector:",cc
        DREG    R1, ", pre gap sector:",cc
        DREG    R4, ", file index:",cc
        DREG    R5, ", link bits:"
 ]

        TEQS    R4, #0
        BEQ     %FT05           ;any spare shared before dir is map or boot
        SUB     LR, R0, R1      ;gap before frag
        CMPS    R9, LR          ;IF size needed <= gap
        CMPLS   LR, R6          ;AND gap<smallest

        MOVLO   R6, LR          ;THEN note new smallest
        ANDLO   R2, R3, #DiscBits
        ORRLO   R2, R2, R5, LSL #8
        ORRLO   R2, R2, R1
 [ DebugE :LOR: DebugEs
        BHS     %FT01
        DREG    R2, "smaller pre gap in shared frag - ind disc add:",cc
        DREG    R6, ", size:"
01
 ]
05
 [ BigDir
        BL      TestBigDir
        BNE     NewClaimFree_IsNotBigDir

        ASSERT  BigDirEntrySize=28
        RSB     R4, R4, R4, LSL #3
        MOVS    R4, R4, LSL #2

        BNE     NewClaimFree_IsNotDir
        LDR     LR, DirBufferPtr
        LDR     LR, [LR, #BigDirSize]   ; size of dir itself
        B       NewClaimFree_ReJoin
NewClaimFree_IsNotDir
        LDR     LR, DirBufferPtr
        LDR     LR, [LR, #BigDirNameLen]
        ADD     LR, LR, #4
        BIC     LR, LR, #3
        ADD     R4, LR, R4
        LDR     LR, DirBufferPtr
        ADD     LR, LR,#BigDirHeaderSize-BigDirEntrySize
        ADD     R4, R4, LR
        BL      ReadLen                 ;(R3,R4->LR)    R4=0 if dir itself
        B       NewClaimFree_ReJoin                     ; R4 now points at entry

NewClaimFree_IsNotBigDir
        ASSERT  NewDirEntrySz=26
        ADDS    LR, R4, R4, LSL #1      ;R4*3 convert index in dir to ptr
        ADDNE   R4, R4, LR, LSL #2      ;R4*13
        LDRNE   LR, DirBufferPtr
        ADDNE   LR, LR, #DirFirstEntry-NewDirEntrySz
        ADDNE   R4, LR, R4, LSL #1      ;ptr to dir entry
        BL      ReadLen                 ;(R3,R4->LR)    R4=0 if dir itself
NewClaimFree_ReJoin
 |
        ASSERT  NewDirEntrySz=26
        ADDS    LR, R4, R4, LSL #1      ;R4*3 convert index in dir to ptr
        ADDNE   R4, R4, LR, LSL #2      ;R4*13
        sbaddr  LR, (DirBuffer+DirFirstEntry-NewDirEntrySz),NE
        ADDNE   R4, LR, R4, LSL #1      ;ptr to dir entry
 ]
        TSTS    LR, R11
        ADD     R1, R0, LR, LSR R7      ;inc end sector offset past obj
        ADDNE   R1, R1, #1
 [ BigDir
        BICS    LR, R1, #&ff            ;check if it's beyond max sharing limit
        BNE     NewClaimFree_ShareTooLarge
 ]

 [ BigMaps
        LDR     R0, [R8, #-4]           ; from previous record
        LDR     LR, [R8, #4]            ; from next obj
        EOR     LR, R0, LR
        MOVS    LR, LR, LSR #8          ;
        BEQ     %BT04                   ;IF next obj in same frag then loop
 |
        SUB     R0, R8, #4
        LDMIA   R0, {R0,LR}
        EOR     LR, R0, LR
        MOVS    LR, LR, LSR #16
        BEQ     %BT04                   ;IF next obj in same frag then loop
 ]

        MOV     R0, R5, LSL #8          ;ELSE consider gap after obj
        Push    "R2,R5,R9"
        AND     R2, R3, #DiscBits
        ORR     R2, R2, R5, LSL #8      ;ind disc address of shared frag start
        MOV     R5, #0
        BL      DefFindFileFragment     ;(R2,R5->R2,R4,R5,R9,LR)
        Pull    "R2,R5,R9"
        RSB     LR, R1, R4, LSR R7
        ADD     LR, LR, #1              ;since sector offsets start at 1

        CMPS    R9, LR          ;consider gap as before
        CMPLS   LR, R6

        MOVLO   R6, LR
        ANDLO   R2, R3, #DiscBits
        ORRLO   R2, R2, R5, LSL #8
        ORRLO   R2, R2, R1

 [ DebugE :LOR: DebugEs
        BHS     %FT01
        DREG    R2, "smaller post gap in shared frag - ind disc add:",cc
        DREG    R6, ", ind disc add:"
01
 ]
 [ BigDir
NewClaimFree_ShareTooLarge
 ]
        TEQS    R6, #1024*K
        BEQ     %BT02           ;loop if no fit found

06
        Pull    "R4"
        TEQS    R6, #1024*K
 [ DebugE :LOR: DebugEs
        BEQ     %FT01
        DLINE   "space found in shared fragment"
01
 ]
        BNE     %FT91
        ;no shareable space was found, fall through to new claim

 ^ 0,SP
FragZone        # 4
NextZone        # 4
ZonesLeft       # 4
FragScore       # 4
AllocWork1      # 0

08
        LDR     LR, [SP,#ClaimReason]       ;entry reason code
        TEQS    LR, #CloseSmall
        MOVEQ   R0, #DiscFullErr
        BEQ     %FT93
        MOV     R0, R3
        BL      IndDiscAddToZone        ;(R0,R10->R0)
09
        SUB     R1, R0, #1
 [ BigMaps
        LDRB    R7, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        LDRB    R2 ,[R10,#ZoneHead+DiscRecord_NZones]
        ADD     R2, R2, R7, LSL #8
 |
        LDRB    R2 ,[R10,#ZoneHead+DiscRecord_NZones]
 ]
        MOV     R7, #0
        Push    "R0,R1,R2,R7"
        MOV     R1, #-1
        BL      MinMapObj       ;(R10->LR)
        MOV     R8, LR
;R0 zone                R4 size needed in map bits      R8 min map obj
;R1 smallest good gap   R5 total free                   R9-R11 map
;R2 zone free<<9 + gaps R6 predecessor of best gap
;R3 top 3 bits disc     R7 length

        MOV     R5, #0
10
        BL      InitZoneFree    ;(R0,R10->R11)
        MOV     R2,#0
12
        BL      NextFree_Quick  ;(R10,R11->R9, R11,Z,C)
        BCS     %FT14           ;zone done
 [ BigMaps
        BL      FreeRdLenBits   ;(R10,R11->R7)
 |
        BL      RdLenBits       ;(R10,R11->R7)
 ]
        ADD     R5, R5, R7
        ADD     R2, R2, R7,LSL #9
        ADD     R2, R2,#1
        SUBS    LR,R7, R4
        CMPHS   R1, R7
        BLS     %BT12           ;loop unless smallest > gap >= obj size

        CMPS    R7, R8,LSL #1    ;IF gap small enough to share
        TEQS    LR,#0           ;OR exact fit
        CMPHIS  R8,LR           ;OR no waste
 [ DebugE
        BHI     %FT01
        DREG    R7, "better fit - size:",cc
        DREG    R9, ", pre gap:"
01
 ]
        MOVLS   R1, R7           ;note better gap
        MOVLS   R6, R9
        B       %BT12
14
        CMPS    R1, #-1
        ADDNE   SP, SP, #:INDEX:AllocWork1
        BNE     %FT90           ;if found a suitable gap in this zone
        MOV     R7, R2,LSR #9    ;total free in zone
        SUB     R2, R2, R7,LSL #9 ;gaps in zone
        SUBS    R2, R2,#1
        MULGT   R9, R7, R2        ;free in zone * (gaps-1)
        LDRGT   LR,FragScore
        CMPGTS  R9, LR          ;IF this zone has a higher fragmentation score
        BLE     %FT16
        BL      ZoneFlagsPtr    ;(R10->LR)
        LDRB    LR, [LR,R0]
        TSTS    LR, #ZoneCompacted      ;AND not fully compacted
 [ DebugE
        BEQ     %FT01
        DLINE   "Zone Compacted"
01
 ]
 [ DebugE
        DREG    R0, "better zone for compaction - ",cc
        DREG    R9, ","
 ]
        STREQ   R9, FragScore           ;THEN note new zone for compaction
        STREQ   R0, FragZone
16
        LDR     LR, ZonesLeft
        SUBS    LR, LR, #1
        BLE     %FT18
        STR     LR, ZonesLeft
17                                      ;try next zone
        LDR     LR, NextZone
        CMPS    R0, LR
        ADDGE   R0, R0, #1
        SUBLT   R0, R0, #1
        STR     R0, NextZone
        MOV     R0, LR
        CMPS    R0, #-1
 [ BigMaps
        LDRGTB  LR, [R10,#ZoneHead+DiscRecord_NZones]
        LDRGTB  R11, [R10,#ZoneHead+DiscRecord_BigMap_NZones2] 
        ADDGT   LR, LR, R11, LSL #8     ; R11 returned by InitZoneFree so is free for use here
 |
        LDRGTB  LR, [R10,#ZoneHead+DiscRecord_NZones]
 ]
        CMPGTS  LR, R0
        BLE     %BT17           ;if bad zone number
        B       %BT10

18                              ;HERE IF FAILED TO FIND USEFUL GAP IN ANY ZONE
        ASSERT  :INDEX: FragZone   = 0
        ASSERT  :INDEX: FragScore  = 12
        ASSERT  :INDEX: AllocWork1 = 16
        Pull    "R0,R1,R2,LR"

        CMPS    R4, R5           ;IF space needed>total free then full
        ASSERT  fsfile_Create>fsfile_Save
        ASSERT  CloseSmall>fsfile_Create
        ASSERT  CloseContig>fsfile_Create
        LDRLS   R1, [SP,#ClaimReason]
        CMPLS   R1, #fsfile_Create        ;OR if close case
        MOVHI   R0, #DiscFullErr
        BHI     %FT93

 [ DebugE
        DLINE   "no gap big enough for whole file"
 ]

        CMPS    LR, #0          ;V=0
        MOVNE   R1, R4
        BLNE    DefCompactZone  ;(R0,R1,R10->R0,R2,V)
        BVS     %FT95

WasteBit        bit 31
MultiBit        bit 30

        MOV     R11,#FreeLink*8
        BL      Log2AllocBits   ;(->LR)
        MOV     R2, LR

        LDRB    R1, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R5, #8*2
        MOV     R1, R5,LSL R1
        MOV     R1, R1,LSR R2
      [ BigSectors
        CMP     R1, #?ScratchSpace
        MOVLS   R0, #ScratchSpace
        BLS     %FT28           ;table can fit in scratch space

        Push    "R2-R3"
        MOV     R3, R1          ;search for a buffer (not ScratchSpace, of course)
        MOV     R2, R1
        MOV     R0, #(1:SHL:UseSpareScreen) :OR: (1:SHL:UseWimpFree) :OR: \
                     (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap)
        BL      FindBuffer      ;(R0-R3->R0-R3,V)
        MOVVC   R0, R1
        MOVVC   R1, R2
        Pull    "R2-R3"
        BVS     %FT95
28
      |
        ASSERT  ?ScratchSpace>=16*K
        MOV     R0, #ScratchSpace
      ]
        BL      ZeroRam         ;init tables of gap frequencies
        ADD     R1, R0, R1,LSR #1
        MOV     R5, #0  ;init total gaps between ptrs
        MOV     R6, #-1 ;init best fit

;R1 ->gap frequency tables
;R2 log2 alloc unit bit width
;R3 dir
;R4 size needed in bits
;R5 total gap length between map ptrs
;R6 best fit
;R8 min map obj

 ^ 0,SP
AllocDir        # 4
PreBestPtr      # 4
FitType         # 4
PtrDiff         # 4
PreFirstGap     # 4
FirstGap        # 4
LastGap         # 4
LastSize        # 4
FoundBuffer     # 4
AllocWork2      # 0

        Push    "R0"            ;save buffer (for ReturnBuffer)
        Push    "R3,R6-R12"     ;save dir & reserve stack space
        BL      NextFree        ;(R10,R11->R9, R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
        STR     R9, PreFirstGap
        STR     R11,FirstGap
        B       %FT32
30
        BL      NextFree        ;(R10,R11->R9, R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
32
        BEQ     %FT58           ;all tried
        STR     R7, LastSize
        SUBS    R0, R7, R4
        BLO     %FT34           ;gap too small for obj
        CMPNES  R0, R8           ;if not exact fit can rest be made a gap
        ORRLO   R0, R0,#WasteBit
        CMPS    R0, R6
 [ DebugE
        BHS     %FT01
        DREG    R6, "single gap - fit:",cc
        DREG    R9, ", pre:"
01
 ]
        MOVLO   R6, R0
        STRLO   R9, PreBestPtr
34
        TSTS    R6, #WasteBit :OR: MultiBit
        BEQ     %BT30           ;if found single gap fit no waste

        STR     R11,LastGap
        MOV     R0, R7,LSR R2
        LDRB    LR, [R1, R0]    ;inc frequency of gaps of this size
        ADD     LR, LR,#1
        STRB    LR, [R1, R0]
        LDRB    LR, [R1,-R0]    ;inc freq of gaps of this size between map ptrs
        ADD     LR, LR, #1
        STRB    LR, [R1,-R0]
35
        SUB     LR, R4, R5      ;amount needed from this gap
        ADD     R5, R5, R7      ;adjust total gap length between map ptrs
        SUBS    R9, R4, R5
        BHI     %FT42           ;total still too small
        SUBS    R0, R8,LR
        BHI     %FT36           ;min size > amount needed
        SUBS    R0, R5, R4      ;remains of gap
        CMPNES  R0, R8
        ORRLO   R0, R0,#WasteBit
        B       %FT38
36
        CMPS    R7, R8, LSL #1  ;can this gap be split
        SUBLO   R0, R7, LR
        ORR     R0, R0, #WasteBit
38
        ORR     R0, R0, #MultiBit
        CMPS    R0, R6
        MOVLS   R7, #0          ;fit type
        BLLS    %FT50           ;if possibly better fit
40
        SUBS    R7, R5, R4      ;R7 := amount total exceeds required
        MOV     LR, R7, LSR R2
        LDRB    LR, [R1,-LR]
        TEQS    LR, #0          ;IF we are using a gap of size R7
        BLNE    %FT48           ;THEN exact fit without it

        LDR     R11,FirstGap
 [ BigMaps
        BL      FreeRdLenBits   ;(R10,R11->R7)
 |
        BL      RdLenBits       ;(R10,R11->R7)
 ]
        SUB     R5, R5, R7
        MOV     LR, R7, LSR R2
        LDRB    R0, [R1,-LR]    ;dec freq of gaps of this size between map ptrs
        SUB     R0, R0,#1
        STRB    R0, [R1,-LR]
        BL      NextFree        ;(R10,R11->R9, R11,Z,C)
        STR     R9, PreFirstGap
        STR     R11,FirstGap
        LDR     R7, LastSize
        LDR     R11,LastGap
        SUB     R5, R5, R7
        B       %BT35

42                              ;IF R9 short of total
        MOV     R7, R9, LSR R2
        SUB     LR, R1, R7
        LDR     R0, FoundBuffer
        CMPS    LR, R0
        LDRGTB  R0, [R1, R7]
        LDRGTB  LR, [R1,-R7]
        TEQGTS  R0, LR          ;AND unused gap of size R9 exists (GT preserves N=V=0)
        BLGT    %FT46           ;THEN exact fit with it
        B       %BT30

46
        RSB     R7, R9, #0
48
        MOV     R0, #MultiBit
        CMPS    R0, R6
50                                      ;corrupts R0, R3, R7, R9
; R0 measure of fit
; R7 fit type
;  0  just contiguous set of frags
;  +x miss out frag of size x
;  -x also use earlier frag of size x

        LDREQ   R9, FitType     ;if fit is same compare fit type
        CMPEQS  R7, R9
        BLS     %FT54
52
        MOVLO   R6, R0
        LDRLO   R3,PreFirstGap
        ASSERT  :INDEX: PreBestPtr = 4
        ASSERT  :INDEX: FitType    = :INDEX: PreBestPtr +4
        ASSERT  :INDEX: PtrDiff    = :INDEX: FitType +4
        STMLOIB  SP, {R3, R7, R9}
 [ DebugE
        BHS     %FT01
        DREG    R0, "multi fit - fit:",cc
        DREG    R3, ", pre:",cc
        DREG    R7, ", fit type:",cc
        DREG    R9, ", ptr diff:"
01
 ]
        MOV     PC, LR

54
        Push    "R0, R1"
        LDR     R0, FirstGap+(2*4)      ;calc map ptr diff+zone diff*2^24
        LDR     R1, LastGap+(2*4)
        SUB     R9, R1, R0
        LDRB    R3, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        ADD     R3, R3, #3              ;log2 bits in a zone
        MOV     R0, R0, LSR R3
        MOV     R1, R1, LSR R3
        SUB     R0, R1, R0              ;zone diff
        ORR     R9, R9, R0, LSL #24
        LDREQ   R3, PtrDiff+(2*4)
        CMPEQS  R9, R3
        Pull    "R0,R1"
        B       %BT52

58
        LDR     R3, AllocDir
        CMPS    R6 ,#-1
        MOVEQ   R0, #DiscFullErr
        BEQ     %FT88
        CMPS    R6, #MultiBit   ;only try pairs if wasting, crossing zone
        BEQ     %FT69           ;or multiple and fragmenting
        BLO     %FT89
59
 [ DebugE
        DLINE   "considering pairs"
 ]
        MOV     R7, #1
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R0, #8
        MOV     LR, R0, LSL LR  ;bits in zone
        CMPS    R4, LR
        MOVLS   R8, R4
        MOVLS   R5, #0
        MOVHI   R8, LR
        SUBHI   R5, LR, R4
        MOV     R8, R8, LSR R2
        MOV     R5, R5, LSR R2
        ADD     R9,R5,R8        ; fix to prevent infinite loop if can't fit pair
        MOV     R9,R9,LSL R2
        CMP     R4,R9
        BGT     %FT70           ; end of fix
        B       %FT62

;R0 best short gap
;R1 -> freq tables
;R2 log2 alloc unit bit width
;R4 length required
;R5 short gap alloc units
;R6 old fit
;R7 fit*2
;R8 long gap alloc units

60
        LDRB    R9, [R1, R5]
        LDRB    LR, [R1, R8]
        MUL     LR, R9, LR      ;prefer pair with greatest frequency product
        CMPS    R7, LR, LSL #1
        MOVLS   R7, LR, LSL #1
        MOVLS   R0, R5, LSL R2
 [ DebugE
        BHI     %FT01
        DREG    R5, "pair fit - short gap:",cc
        DREG    R8, ", long gap:",cc
        DREG    R7, ", freq:"
01
 ]
62
        ADD     R5, R5, #1
        SUB     R8, R8, #1
        CMPS    R8, R5
        BHI     %BT60

        TEQS    R7, #1
        BEQ     %FT70           ;no pair found

        SUB     R4, R4, R0      ;size of larger
        MOV     R1, #NIL        ;pre smaller gap
        MOV     R6, #NIL        ;pre larger gap
        MOV     R11,#FreeLink*8
64
        BL      NextFree        ;(R10,R11->R9, R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
        BEQ     %FT70           ;amg: give up if we didn't find two suitable lumps
        TEQS    R7, R4           ;size = larger ?
        BNE     %FT66
        MOV     R6, R9
        TEQS    R1,#NIL
        BEQ     %BT64           ;loop if still looking for smaller
        Push    "R0,R1,R4,R6"    ;swap larger and smaller to share code
        Pull    "R4,R6"
        Pull    "R0,R1"
        B       %FT68
66
        TEQS    R7, R0           ;size = smaller ?
        BNE     %BT64
        MOV     R1, R9
        TEQS    R6,#NIL
        BEQ     %BT64           ;loop if still looking for larger
68
        BL      DefFindIdThenClaim ;(R3, R4, R6, R10->R2, R5, R11)
        MOV     R4, R0           ;size 2nd gap
        TEQS    R1, R11          ;was 1st predecessor of 2nd
        MOVNE   R6, R1           ;prev ptr for 2nd
        B       %FT75

69
        LDR     LR, PtrDiff
        CMPS    LR, #1 :SHL: 24
        LDRLO   LR, FitType
        CMPLOS  LR, #1 :SHL: 31
        BHI     %BT59
70
        TSTS    R6, #MultiBit
        BEQ     %FT89
        LDR     R5, FitType
        RSBS    R8, R5, #0
        BLE     %FT76

        SUB     R0, R4, R8        ;if using extra gap of size R8
        LDR     R2, PreBestPtr
        MOV     R11,#FreeLink*8
        B       %FT74

72
        TEQS    R7, R8
        MOVEQ   R6, R9
74
        BL      NextFree        ;(R10,R11->R9, R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
        CMPS    R11,R2
        BLS     %BT72
        MOV     R4, R8
        BL      DefFindIdThenClaim ;(R3,R4,R6,R10->R2,R5,R11,LR)
        MOV     R4, R0
        LDR     R6,PreBestPtr
75
        BL      DefChainClaim   ;(R2,R4-R6,R10->R5,R11,LR)
        B       %FT87

76
        LDR     R6, PreBestPtr
        BL      FindIdThenClaim    ;(R3-R5, R10->R2, R11)

87
        MOV     R0, #0
88
      [ BigSectors
        LDR     LR, FoundBuffer ;if FindBuffer used, free it
        TEQ     LR, #ScratchSpace
        BLNE    ReturnBuffer
      ]
        ADD     SP, SP, #:INDEX:AllocWork2
        B       %FT93

89
        BIC     R6, R6, #WasteBit
        ADD     R1, R4, R6              ;gap length in map bits
        LDR     R6, PreBestPtr
      [ BigSectors
        LDR     LR, FoundBuffer ;if FindBuffer used, free it
        TEQ     LR, #ScratchSpace
        BLNE    ReturnBuffer
      ]
        ADD     SP, SP, #:INDEX:AllocWork2
90
        BL      DefFindIdThenClaim      ;(R3,R4,R6,R10->R2,R5,R11)
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        MOV     R1, R1, LSL LR          ;gap size in bytes
        MOV     R8, R8, LSL LR          ;min map obj in bytes
        LDR     R0, [SP,#ClaimLength]
 [ BigShare
        BL      RoundUpShare            ;(R0,R3->R0) always < 2G
 |
        BL      RoundUpSector           ;(R0,R3->R0) always < 2G
 ]
        SUBS    LR, R1, R0              ;shared obj <=>
        CMPHIS  R8, LR                  ;(0<R1-R0<R8 AND R1<R8*2) OR R0<R8
        RSBHIS  LR, R1, R8, LSL #1
        CMPLSS  R8, R0
        ORRHI   R2, R2, #1              ;note shared obj
91
        MOV     R0, #0
93
        BL      SetVOnR0
95
        STRVS   R0, [SP]
        Pull    "R0,R1,R4-R11,PC"

 [ DebugFx
        MACRO
        CheckTheMap $a,$b
        BL      CheckMapsOK
        BEQ     %FT01
        DREG    $a,$b
01
        MEND

CheckMapsOK ROUT
        Push    "r0-r9,r11,lr"
        MOV     r0, #0
10
        BL      InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        MOV     R5, LR
        MOV     R1, #-1
        MOV     R6, #0          ; not free prev

25
 [ BigMaps
        TEQS    R11,R9          ; if gap
        BEQ     %FT26
        BL      RdLenLinkBits   ; not gap
        B       %FT27

26 ; here if gap
        BL      FreeRdLenLinkBits
 |
        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
        TEQS    R11,R9          ;if gap
        BNE     %FT27
 ]
        TEQ     r6, #0          ; was free prev?
        BNE     %FT40
        MOV     r6, #-1         ; free was prev
        ADD     R9, R9, R8
        B       %FT30

27
        ; Is prev==this?, if yes map is corrupt
        TEQ     R8,R1
        BEQ     %FT40
        MOV     R1,R8
        MOV     r6, #0

30
        ADD     R11, R11, R7
        CMPS    R11, R5
        BLO     %BT25

        ADD     r0, r0, #1
        LDRB    lr, [r10, #ZoneHead + Zones]
        CMP     r0, lr
        BLO     %BT10

        Pull    "r0-r9,r11,pc"

40
        MOVS    r1, #-1
        Pull    "r0-r9,r11,pc"
 ]


NewRandomClaim ROUT

;entry
; R1 disc rec
; R3  dir
; R4  -> dir entry (if R11 = RandomAccessExtend )
; R10 size needed in bytes
; R11 RandomAccessCreate / RandomAccessExtend

;exit
; R2  ind disc add
; R10 actual size


        MOVS    R0, R10
      [ :LNOT: BigFiles
        MOVMI   R0, #DiscFullErr
        BMI     %FT93
      ]
        BL      RoundUpAlloc            ;(R0,R3->R0)
        LDRB    LR, [R1,#DiscRecord_Log2bpmb]
      [ BigFiles
        TEQ     R0, #RoundedTo4G
        ASSERT  RoundedTo4G = 1
        MOVEQ   R8, R0, ROR LR
        MOVNE   R8, R0, LSR LR
      |
        MOV     R8, R0, LSR LR          ; SBP: now have length in map bits
      ]
        Push    "R3,R8"

;TOTAL FREE AND CHOOSE ZONE FOR RandomAccessCreate, REGISTER USE

;R0 temp                R4 zone                 R8  best score
;R1 temp                R5 dir zone             R9  map ptr
;R2 best zone           R6 disc free            R10 map
;R3 zone free           R7 gap length           R11 map ptr

; SBP:  Note, all the sizes used from here on appear to be in map
;       bits; this is A Good Thing.

        BL      CritInitReadNewFs       ;(->R10,R11)
 [ DebugFx
        CheckTheMap r11, "Map bad on entry NewRandomClaim "
 ]
        MOV     R0, R3
        BL      IndDiscAddToZone        ; (R0,R10->R0)
        MOV     R5, R0                  ; zone dir

        MOV     R2, #0  ;  best zone=0
        MOV     R3, #0  ;  zone free=0
        MOV     R4, #0  ;       zone=0
        MOV     R6, #0  ;  disc free=0
        MOV     R8, #0  ; best score=0
05
        BL      NextFree        ;(R10,R11->R9, R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
        BCC     %FT10           ;branch if not zone end

        SavePSR R9              ;save flags
        MOV     R0, R3,LSL #19  ;calc score for this zone
        SUBS    R1, R4, R5
        SUBMI   R1, R5, R4
        ADD     R1, R1,#1
        BL      Divide          ;(ZoneFree *2^19)/( |Zone-DirZone|+1 ) (R0, R1->R0, R1)
        CMPS    R0, R8
        MOVHS   R8, R0          ;note score
        MOVHS   R2, R4          ;and zone if better

        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R4, R11,LSR LR
        MOV     R4, R4, LSR #3  ;zone
        MOV     R3, #0          ;zone free = 0 for next zone
        RestPSR R9,,f           ;restore flags
10
        ADDNE   R3, R3, R7      ;zone free += gap size
        ADDNE   R6, R6, R7      ;disc free += gap size
        BNE     %BT05           ;loop while more gaps

        Pull    "R3, R8"

 [ DebugE
        DREG    R2, "OpenZone:",cc
        DREG    R6, ", DiscFree:",cc
        DREG    R8, ", SizeNeed:"
 ]

; R2  zone for create
; R3  dir (indirect disc addr)
; R6  disc free (map bits)
; R8  size needed (map bits)

        LDRB    R1, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        LDR     LR, [SP,#ClaimReason]
        EORS    R4, LR, #RandomAccessCreate
        BNE     %FT15
; IF create THEN shuffle flag (R4) = FALSE
        BL      BytesPerCylinder        ;(R10->LR)
; SBP: R4=0
        SUB     R1, R4, LR, LSR R1 ; R1:=-(LR>>R1), so R1:=-map bits per cylinder
        MOV     R0, R2
        BL      DefCompactZone  ;(R0,R1,R10->R0,R2,V) do any compaction moves<cylinder
        BVS     %FT95
        MOV     R5, #0          ;old length = 0
        BL      InitZoneFree    ;start claiming from best zone start
        MOV     R1, #0          ;and not joining onto old end
        MOV     R2, #1          ;ind disc add for zero length files
        B       %FT20
15                              ;ELSE extend
        LDR     R4, [SP,#ClaimDirEntry]
        BL      ReadIndDiscAdd  ;(R3, R4->LR)
        MOV     R2, LR
        BL      ReadLen         ;(R3,R4->LR)
        MOV     R0, LR
        BL      RoundUpAlloc    ;(R0,R3->R0)
      [ BigFiles
        TEQ     R0, #RoundedTo4G
        ASSERT  RoundedTo4G = 1
        MOVEQ   R1, R0, ROR R1
        MOVNE   R1, R0, LSR R1
      |
        MOV     R1, R0, LSR R1
      ]
        SUB     R1, R1, #1
        MOV     R5, R1          ;definitely at least this long (in map bits) based on the catalogue entry

; here, we're finding the disc fragment containing the end of the file

        BL      DefFindFragment ;(R1,R2,R10->R1,R9,R11,LR)
        ADD     R5, R5, LR      ;actual allocated length in map bits, including gifted
        CMPS    R8, R5          ;compare wanted size with allocated size
        MOVLO   R8, R5          ;if less, adjust up to allocated size
        ADD     R1, R1, LR      ;R1 points to next map block
        MOV     R0, R11         ;R0 points to this map block

        MOV     R11,R9          ;predecessor gap in R11
        Push    "R11"
        BL      NextFree        ;(R10,R11->R9,R10,R11,Z,C)
        MOVEQ   R11,#FreeLink*8 ;exhausted, back to start of zone
        BLEQ    NextFree        ;(R10,R11->R9,R10,R11,Z,C)
        TEQS    R11,R1
        Pull    "R11"
        MOVNE   R1, #0          ;R1=0->next free block not directly after us

        MOV     R4, #-1        ;shuffling may be necessary
20
        ADD     LR, R5, R6     ;allocated size + total free
        CMPS    R8, LR         ;wanted size > avail size?
        MOVHI   R0, #DiscFullErr  ; obvious, if there is no free space, bomb out
        BHI     %FT93

; if space allocated is sufficient, exit with success

        MOV     R2, LR         ; R2 is appropriate ind disc add
        TEQS    R6, #0
      [ BigFiles
        BNE     %FT22
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        MOVS    R8, R8, LSL LR
        MOVCS   R8, #RoundedTo4G
        STR     R8, [SP,#ClaimLength]
        B       %FT91          ;success!
22
      |
        LDREQB  LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        MOVEQ   R8, R8, LSL LR
        STREQ   R8, [SP,#ClaimLength]
        BEQ     %FT91          
      ]
 [ DebugE
        DREG    R0, "start:",cc
        DREG    R1, ", end:"
 ]

Stacked4        * 2*4
LastFrag4       * 0*4
LastEnd4        * 1*4
        Push    "R0, R1"         ;start and end of last frag if joining possible
        BL      BytesPerCylinder        ;(R10->LR)
        MOV     R1, LR
        LDRB    R0, [R10,#ZoneHead+DiscRecord_Skew]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        ADD     R0, R1, R0,LSL LR         ;bytes in (cylinder + DiscRecord_Skew) sectors

        LDRB    R7, [R10,#ZoneHead+DiscRecord_Log2bpmb]
      [ BigFiles
        MOV     LR, #1
        MOV     LR, LR, ROR R7         ; 4G expressed in map bits
        CMP     R8, LR                 
        MOVCS   R6, #0                 ; if size needed is already 4G, don't bother with RA-AU.
                                       ; This is because ChainClaim works in map bits, but ReturnSpace
                                       ; in bytes, so we must guarantee that any over allocation
                                       ; is all in the same zone so a byte wise loop counter can return
                                       ; all the overallocation in no more than 1 map operation
        BCS     %FT27
      ]
25                             ;LOOP TO FIND ALLOC SIZE FOR RA FILES
        Push    "R0"
        BL      RoundUpAlloc           ;(R0,R3->R0)
        MOV     R9, R0, LSR R7         ;round up and convert to alloc bits
        Pull    "R0"

        ADD     R0, R0, R1             ;add on a cylinder of bytes
        CMPS    R0, #&10000            ;IF <= 64K
        MOVLS   LR, R0, LSR R7
        CMPLSS  LR, R6, LSR #4         ;AND <= total free/16
        BLS     %BT25                  ;try adding some more

        CMPS    R9, R6
        MOVLO   R6, R9                 ;RA-AU mustn't exceed total free though  
27

; R2  max possible size (map bits)
; R3  dir
; R4  shuffle flag
; R5  total already allocated (map bits)
; R6  random access allocation unit (map bits)
; R8  size needed (map bits)
; R11 predecessor of gap to start claiming from (map bits)

 [ DebugE
        DREG    R5, "allocated:",cc
        DREG    R6, ", RA alloc:",cc
        DREG    R11, ", pre gap:"
 ]

Stacked4a       * 2*4
AllocTotal      * 0*4
PreClaim        * 1*4
        Push    "R5,R11"
; determine size to claim
        ADD     R0, R8, R6
        CMPS    R0, R2
        MOVHI   R0, R2
ShuffleBack
30
        BL      NextFree        ;(R10,R11->R9, R10,R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
 [ DebugE
        DREG    R0, "target:",cc
        DREG    R5, ", alloc:",cc
        BEQ     %FT01
        DREG    R7, ", gap len:",cc
        DREG    R11, ", map ptr:",cc
01
        DLINE   ""
 ]
        BCC     %FT35           ;not crossed zone

        MOVEQ   R11,#FreeLink*8
        BLEQ    NextFree        ;(R10,R11->R9, R10,R11,Z,C)
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
        TEQS    R4, #0          ;is shuffling down possible ?
        BNE     ShuffleDown

35
        ADD     R5, R5, R7      ; is the gap big enough?
        CMPS    R5, R0
        BLO     %BT30           ; if no, try next gap.

        SUB     R5, R5, R7
        SUB     R2, R0, R5
        CMPS    R5, R8          ;IF have found size needed already
        CMPHSS  R6, R2, LSL #1  ;AND more than half of extra extension found
        MOVHS   R0, R5          ;don't start fragmenting final gap
        BHS     %FT85

        BL      MinMapObj       ;(R10->LR)
        CMPS    R6, LR
        MOVHS   R9, R6
        MOVLO   R9, LR

        CMPS    R2, R9
        MOVLO   R2, R9
        BL      %FT75           ;check if to use all gap corrupts R0

        LDRB    LR, [R10,#ZoneHead+DiscRecord_Skew]
        TEQS    LR, #0
        BNE     %FT70
 ;Round up to cyl boundary if no RA skew
        ADD     R11,R11,R2
        BL      MapPtrToDiscAdd         ;(R3, R10,R11->R0)
        BIC     R0, R0, #DiscBits
 [ BigDisc
        BL      SectorsPerCylinder        ;(R10->LR)
        MOV     R1, LR
        BL      Divide
        TEQS    R1, #0                  ; R1=sector offset into cylinder
        BEQ     %FT65
        BL      SectorsPerCylinder      ; (R10->LR)
        SUB     R0, LR, R1              ; number of extra sectors
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]   ; back to bytes
        MOV     R0, R0, LSL LR
        BL      RoundUpAlloc            ;(R0, R3->R0) always < 2G
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        ADD     R2, R2, R0,LSR LR       ;new size of block in map bits
65
 |
        BL      BytesPerCylinder        ;(R10->LR)
        MOV     R1, LR
        BL      Divide
        TEQS    R1, #0
        BEQ     %FT65
        BL      BytesPerCylinder        ;(R10->LR)
        SUB     R0, LR, R1
        BL      RoundUpAlloc            ;(R0, R3->R0) always < 2G
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        ADD     R2, R2, R0,LSR LR
65
 ]
70
        ADR     LR,%FT80
75
        ADD     R0, R2, R9
        CMPS    R0, R7
        MOVLS   PC, LR
        MOV     R2, R7
80
        ADD     R0, R5, R2
85
        LDR     LR, [SP,#Stacked4a+Stacked4+ClaimReason]
        TEQS    LR, #RandomAccessCreate
        LDRNE   R4, [SP,#Stacked4a+Stacked4+ClaimDirEntry]
        BLNE    ReadIndDiscAdd          ;(R3, R4->LR)
        MOVNE   R2, LR
        Pull    "R4,R6"                 ;
        SUB     R4, R0, R4

        BLEQ    DefFindIdThenClaim      ;(R3,R4,R6,R10->R2,R5,R11,LR)
        MOVEQ   R0, LR                  ;actual amount allocated
        TEQNES  R4, #0
        BLNE    DefChainClaim           ;(R2,R4,R6,R10->R5,R11,LR)
        SUBNE   R4, LR, R4              ;extra amount we weren't expecting
        ADDNE   R0, R0, R4              ;new length=length desired+extra gifted amount
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
      [ BigFiles
        MOVS    R0, R0, LSL LR
        MOVCS   R0, #RoundedTo4G
      |
        MOV     R0, R0, LSL LR
      ]
        STR     R0, [SP,#Stacked4+ClaimLength]
 [ DebugE :LOR: DebugEa
      [ BigFiles
        TEQ     R0, #RoundedTo4G
        BNE     %FT01
        DLINE   "new length:4G"
        B       %FT02
      ]
01
        DREG    R0, "new length:"
02
 ]
        Pull    "R1, R11"
        TEQNES  R11,#0
 [ BigMaps
        BLNE    FragRdLenBits   ;(R10,R11->R7)
 |
        BLNE    RdLenBits       ;(R10,R11->R7)
 ]
        ADDNE   R0, R11,R7
        SUBNE   R0, R0, R1
 [ BigMaps
        BLNE    FragWrLenBits   ;(R0,R1,R10)
 |
        BLNE    WrLenBits       ;(R0,R1,R10)
 ]
91
        MOV     R0,#0
93
        BL      SetVOnR0
95
ShuffleError
        STRVS   R0,[SP]
 [ DebugFx
        LDR     R11, [sp, #9*4]
        CheckTheMap R11, "NewRandomClaim corrupted:"
 ]
        Pull    "R0,R1,R4-R11,PC"


; +++++++++++
; ShuffleDown
; +++++++++++

ShuffleDown ROUT

Stacked4b       * 3*4
        Push    "R0,R6,R8"
;FIND FIRST GAP AFTER FILE'S START ZONE

        LDR     R4, [SP,#Stacked4b+Stacked4a+Stacked4+ClaimDirEntry]
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        MOV     R2, LR
 [ BigMaps
        MOV     R4, LR, LSL #3
        MOV     R4, R4, LSR #3+8        ;link bits
 |
        MOV     R4, LR, LSL #8+1
        MOV     R4, R4, LSR #8+1+8      ;link bits
 ]
        MOV     R0, LR
        BL      IndDiscAddToZone        ;(R10,R0->R0)
        LDR     R5, [SP,#Stacked4b+AllocTotal]
        MOV     R1, R5          ;actual allocated length in map bits, including gifted
05
        BL      InitZoneObj     ;(R0, R10->R8, R9, R11,LR)
        STR     R8, [SP,#Stacked4b+PreClaim]
        MOV     R6, LR          ;bit position of end of zone
10
        TEQS    R11, R9         ;is R11 at the free offset?
        BEQ     %FT20
 [ BigMaps
        BL      FragRdLenLinkBits ;(R10,R11->R7,R8)
 |
        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
 ]
        TEQS    R8, R4          ;a frag id of interest?
        STREQ   R11,[SP,#Stacked4b+Stacked4a+LastFrag4]
        SUBEQS  R1, R1, R7
        BEQ     %FT15           ;reached end of file without finding any gaps
        ADD     R11,R11,R7      ;walk R11 along by len of that frag
        CMPS    R11,R6
        BLO     %BT10           ;loop while more objects in zone

        ADD     R0, R0,#1
 [ BigMaps
        LDRB    LR,[R10,#ZoneHead+DiscRecord_NZones]
        LDRB    R11,[R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     LR, LR, R11, LSL #8     ; R11 returned by InitZoneObj so is free for use here 
 |
        LDRB    LR,[R10,#ZoneHead+DiscRecord_NZones]
 ]
        CMPS    R0,LR
        MOVHS   R0,#0
        B       %BT05           ;loop for next zone

15
 [ DebugE
        DLINE   "no shuffling needed"
 ]
        ADD     R5,SP,#Stacked4b
        ASSERT  AllocTotal=0
        ASSERT  PreClaim=4
        LDMIA   R5,{R5, R11}
        B        %FT65

20
        SUB     R1, R5, R1      ;offset of gap in file in map bits
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
      [ BigFiles
        MOVS    R5, R1, LSL LR  ;convert offset to bytes, carry = bit 33
        Push    "R1-R4,R11", CS
        BCS     %FT60           ;if it's >= 4G the gap delta subtraction would be CC
      |
        MOV     R5, R1, LSL LR  ;convert to bytes
      ]
        LDR     R8,[SP,#Stacked4b+Stacked4a+Stacked4+ClaimExt]

Stacked4c       * 5*4
IndDiscAdd4c    * 1*4
LinkBits4c      * 3*4
        Push    "R1-R4,R11"
        SUBS    R2, R8, R5      ;gap delta in bytes
        BCC     %FT60
 [ DebugE
        DREG    R1, "shuffle offset (mb):",cc
        DREG    R2, ", gap delta (bytes):",cc
        DREG    R8, ", extent:"
 ]

        MOV     R0, #(1:SHL:UseScratchSpace) :OR: (1:SHL:UseSpareScreen) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: (1:SHL:UseIndOp) :OR: DiscOp_Op_ScatterList_Flag
        MOV     R1, #1
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R1, R1, LSL LR
        MOV     R3, R1
        CMPS    R2, R1
        MOVLO   R2, R1
        BL      FindBuffer      ;(R0-R3->R0-R3,V)
        BVS     %FT95

        MOV     R3, R2          ;buffer length
        MOV     R2, #-1         ;invalid dest ind disc add
        MOV     R6, #0          ;init bytes left from previous dest
        MOV     R9, R11         ;init next gap ptr
        MOV     R7, #0          ;init length last frag
25
        SUB     R4, R8, R5      ;If amount left to move
        CMPS    R4, R3          ;is > buffer length
        MOVHI   R4, R3          ;only move buffer length this time

        Push    "R2-R4"
        MOV     R1, #DiscOp_ReadSecs :OR: DiscOp_Op_ScatterList_Flag :OR: DiscOp_Op_IgnoreEscape_Flag
        LDR     R2, [SP,#3*4+IndDiscAdd4c]
        BL      InitScatter
        sbaddr  R3, ScatterList
        BL      GenIndDiscOp    ;(R1-R5->R0-R5,V)
        Pull    "R2-R4"
        BVS     %FT90

Stacked4d * 3*4
        Push    "R3,R5,R8"
        BL      InitScatter
        sbaddr  R3,ScatterList

        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        ADD     LR, LR ,#3              ;bits in a zone
        MOV     R5, R11,LSR LR          ;zone
        ADD     R5, R5, #1
        MOV     R5, R5, LSL LR          ;start next zone

        LDR     R1, [SP,#Stacked4d+IndDiscAdd4c]
 [ BigMaps
        MOV     R1, R1, LSL #3
        MOV     R1, R1, LSR #3+8      ;link bits
 |
        MOV     R1, R1, LSL #8+1
        MOV     R1, R1, LSR #8+1+8      ;link bits
 ]
30
        CMPS    R6,R4
        BHS     %FT55   ;if this dest can empty buffer
        B       %FT40

35
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        SUB     R0, R11,R7
        MOV     R0, R0, LSR LR
        MOV     R0, R0, LSR #3
        ADD     R0, R0, #1
 [ BigMaps
        LDRB    LR, [R10,#ZoneHead+DiscRecord_NZones]
        LDRB    R11, [R10, #ZoneHead+DiscRecord_BigMap_NZones2] ; R11 safe cos InitZoneObj will hit it
        ADD     LR, LR, R11, LSL #8
 |
        LDRB    LR, [R10,#ZoneHead+DiscRecord_NZones]
 ]
        CMPS    R0, LR
        MOVHSS  R0, #0

        BL      InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        MOV     R5, LR          ;next zone start
        B       %FT45

40
        ADD     R11,R11,R7
        CMPS    R11,R5
        BHS     %BT35
45
 [ BigMaps
        TEQS    R11,R9          ;gap ?
        BLEQ    FreeRdLenLinkBits
        BLNE    FragRdLenLinkBits
 |
        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
        TEQS    R11,R9          ;gap ?
 ]
        ADDEQ   R9, R11,R8      ;if so set next gap
        TEQNES  R8, R1
        BNE     %BT40

        Push    "R3"
        LDR     R3, [SP,#4+Stacked4d+IndDiscAdd4c]
        BL      MapPtrToDiscAdd  ;(R3,R10,R11->R0)
        Pull    "R3"
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        MOV     R8, R7, LSL LR   ;shuffle bytes, always < 2G within a zone

        ADDS    LR, R2, R6      ;V=0
        TEQS    LR, R0
        ADDEQ   R6, R6, R8
        BEQ     %BT30

        Push    "R1,R4"
        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_ScatterList_Flag :OR: DiscOp_Op_IgnoreEscape_Flag
        MOVS    R4, R6
        BLNE    DoDiscOp        ;(R1-R4->R0-R4,V)
        Pull    "R1,R4"
        BVS     %FT85

        SUB     R4, R4, R6
        MOV     R2, R0
        MOV     R6, R8
        B       %BT30           ;loop if this dest wouldn't empty buffer
55
        SUB     R6, R6, R4
        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_ScatterList_Flag :OR: DiscOp_Op_IgnoreEscape_Flag
        CMPS    R4, #0          ;V=0
        BLNE    DoDiscOp        ;(R1-R4->R0-R4,V)
        BVS     %FT85

        Pull    "R3,R5,R8"
        BVS     %FT90

        CMPS    R5, R8
        BLO     %BT25
        BL      ReturnBuffer

60
        Pull    "R1-R4,R9"
        MOV     R6, R1          ;offset of gap in map bits
        LDR     R1, [SP,#Stacked4b+AllocTotal]
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
      [ BigFiles
        MOVS    R0, R6, LSL LR
        MOVCS   R0, #&FFFFFFFF  ;ReturnSpace rounds up internally anyway
        MOVS    R1, R1, LSL LR
        MOVCS   R1, #&FFFFFFFF  ;ReturnSpace rounds up internally anyway
      |
        MOV     R0, R6, LSL LR
        MOV     R1, R1, LSL LR
      ]

        LDR     R4, [SP,#Stacked4b+Stacked4a+Stacked4+ClaimDirEntry]
        LDR     R5, [SP,#Stacked4b+Stacked4a+Stacked4+ClaimDirStart]
        BL      ReturnSpace     ;(R0,R1,R2,R3,R4,R5)

        MOV     R5, R6          ;new allocated length in map bits
        STR     R5, [SP,#Stacked4b+AllocTotal]

        LDR     R11,[SP,#Stacked4b+Stacked4a+LastFrag4]
 [ BigMaps
        BL      FragRdLenBits   ;(R10,R11->R7)
 |
        BL      RdLenBits       ;(R10,R11->R7)
 ]

        ADD     R11,R11,R7

        TEQS    R11,R9          ;does end of last frag join next gap ?
        MOVNE   R11,#0
        STR     R11,[SP,#Stacked4b+Stacked4a+LastEnd4]
        LDR     R11,[SP,#Stacked4b+PreClaim]

65
        Pull    "R0,R6,R8"
 [ DebugFx
        CheckTheMap R11, "NewRandomClaim shuffle down up:"
 ]
        MOV     R4, #0
        B       ShuffleBack

85
        ADD     SP, SP, #Stacked4d
90
        BL      ReturnBuffer
95
        ADD     SP, SP, #Stacked4c+Stacked4b+Stacked4a+Stacked4
        B       ShuffleError


; ================
; BytesPerCylinder
; ================

;entry R10 -> new map

;exit  lr bytes in a cylinder

BytesPerCylinder
        Push    "R0,LR"
        LDRB    R0,[R10,#ZoneHead+DiscRecord_SecsPerTrk]
        LDRB    LR,[R10,#ZoneHead+DiscRecord_Heads]
        MUL     LR,R0,LR                ;sectors per cylinder
        LDRB    R0,[R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     LR,LR,LSL R0            ;convert to bytes
 [ DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0, "BytesPerCylinder:"
        Pull    "R0"
 ]
        Pull    "R0,PC"


; ================
; SectorsPerCylinder
; ================

;entry R10 -> new map

;exit  lr sectors in a cylinder

SectorsPerCylinder
        Push    "R0,LR"
        LDRB    R0,[R10,#ZoneHead+DiscRecord_SecsPerTrk]
        LDRB    LR,[R10,#ZoneHead+DiscRecord_Heads]
        MUL     LR,R0,LR                ;sectors per cylinder

 [ DebugE
        Push    "R0"
        MOV     R0, LR
        DREG    R0, "SectorsPerCylinder:"
        Pull    "R0"
 ]
        Pull    "R0,PC"

  [ BigMaps; :LAND: {FALSE}
; =======
; SortDir
; =======

; form table in scratch space for each object small enough to share a map obj

; with BigMaps, IdLen may be more than 15 bits, so we need more space than a single
; word to store the info.  as the fields must grow with Big dirs also, we make
; each item have two words:

; word 0:       0=>dir itself, else index of obj in dir
;
; word 1:       bits 0-7   are sector offset in shared block
;               bit  8     set if link bits >= link bits for dir
;               bit  9-31  are link bits

; NOTE:  the link bits field is the DIFFERENCE between the current
;        link bits and the dir. link bits.  this is NOT obvious from
;        other comments.

;entry
; R3    disc address of dir
; R5 -> dir start

;exit
; R8 -> table start, table end marked by pair of 0 words

; ALSO NOTE:

; if there's more entries in the dir than can be sorted in ScratchSpace,
; the function will re-run but will only sort on entries near the dir
; in the map; it will keep halfing the distance allowed (in id bits)
; from the directory.

SortDir ROUT                    ;BUILD TABLE
 [ DebugE
        DREG    R3, "SortDir(",cc
        DREG    R5, ",",cc
        DLINE   ")"
 ]
        Push    "R0-R2,R4,R7,R9,R10,LR"

        BL      DiscAddToRec            ;(R3->LR)
        LDRB    LR, [LR, #DiscRecord_IdLen]     ;get idlen
        MOV     R1, #1
        MOV     R10, R1, LSL LR         ;number of possible ids
03
        MOV     R1, #0                  ;init index in dir
        MOV     R8, #ScratchSpace
        ADD     R9, R8, #?ScratchSpace  ; end of scratch space
        MOV     R7, R8
        ANDS    LR, R3, #&FF
        ORRNE   LR, LR, #1 :SHL: 8
        STMNEIA R7!, {R1, LR}           ; store doubleword entry
 [ BigDir
        BL      TestBigDir
        SUBNE   R4, R5, #NewDirEntrySz-DirFirstEntry
        BLEQ    GetDirFirstEntry
        SUBEQ   R4, R4, #BigDirEntrySize
 |
        SUB     R4, R5, #NewDirEntrySz-DirFirstEntry
 ]
        B       %FT10
05
        ADD     R1, R1, #1              ;inc dir index
        BL      ReadIntAtts             ;(R3,R4->LR)
        TSTS    LR, #DirBit
        BNE     %FT10
        BL      ReadIndDiscAdd          ;(R3,R4->LR)

 [ DebugX
        DREG    LR, "Indirect disc address: "
 ]
        BIC     R2, LR, #DiscBits
        TEQS    R2, #1                  ;skip if 0 length
        ANDNES  R2, LR, #&FF            ;or not shared
        BEQ     %FT10
        MOV     LR, LR, LSR #8          ;build entry
        SUBS    LR, LR, R3, LSR #8
        RSBMI   LR, LR, #0              ;offset in idlen
        ORR     LR, R2, LR, LSL #9
        ORRPL   LR, LR, #1 :SHL: 8
        CMPS    LR, R10, LSL #9         ;check for too high
        BHI     %FT10                   ;if too high then back round again
 [ DebugX
        DREG    R1, "Dir index  : "
        DREG    LR, "Other word : "
 ]
        STMIA   R7!, {R1, LR}
        CMP     R7, R9
        MOVEQ   R10, R10, LSR #1        ; half the search range
        BEQ     %BT03                   ; back round with reduced search range
10
 [ BigDir
        BL      TestBigDir
        BNE     %FT01                   ; not a big dir
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
        BNE     %BT05                   ; go round again
        B       %FT02                   ; finished
01
        LDRB    LR, [R4,#NewDirEntrySz]!
        CMPS    LR, #" "
        BHI     %BT05
02
 ]

        MOV     R0, R8
        MOV     R1, R7
        BL      SortPair                ;(R0, R1)
        MOV     LR, #0
        STR     LR, [R7],#4
        STR     LR, [R7],#4
        Pull    "R0-R2,R4,R7,R9,R10,PC"

  |

; if BigMaps is FALSE, then so must BigDir be

        ASSERT  BigDir = {FALSE}

; =======
; SortDir
; =======

; form table in scratch space for each object small enough to share a map obj
; bits 0-7   0=>dir itself, else index of obj in dir
; bits 8-15  are sector offset in shared block
; bit  16    set if link bits >= link bits for dir
; bits 17-31 are link bits

;entry
; R3    disc address of dir
; R5 -> dir start

;exit
; R8 -> table start, table end marked by 0 word

SortDir ROUT                    ;BUILD TABLE
 [ DebugE :LOR: DebugEs
        DREG    R3, "SortDir(",cc
        DREG    R5, ",",cc
        DLINE   ")"
 ]
        Push    "R0-R2,R4,R7,LR"
        MOV     R1, #0                  ;init index in dir
        MOV     R8, #ScratchSpace
        MOV     R7, R8
        ANDS    LR, R3, #&FF
        MOVNE   LR, LR, LSL #8
        ORRNE   LR, LR, #1 :SHL: 16
        STRNE   LR, [R7],#4
        SUB     R4, R5, #NewDirEntrySz-DirFirstEntry
        B       %FT10
05
        ADD     R1, R1, #1              ;inc dir index
        BL      ReadIntAtts             ;(R3,R4->LR)
        TSTS    LR, #DirBit
        BNE     %FT10
        BL      ReadIndDiscAdd          ;(R3,R4->LR)
        BIC     R2, LR, #DiscBits
        TEQS    R2, #1                  ;skip if 0 length
        ANDNES  R2, LR, #&FF            ;or not shared
        BEQ     %FT10
        MOV     LR, LR, LSR #8          ;build entry
        SUBS    LR, LR, R3, LSR #8
        RSBMI   LR, LR, #0
        ORR     LR, R1, LR, LSL #17
        ORRPL   LR, LR, #1 :SHL: 16
        ORR     LR, LR, R2, LSL #8
        STR     LR, [R7],#4
10
        LDRB    LR, [R4,#NewDirEntrySz]!
        CMPS    LR, #" "
        BHI     %BT05

        MOV     R0, R8
        MOV     R1, R7
        BL      Sort            ;(R0, R1)
        MOV     LR, #0
        STR     LR, [R7]
        Pull    "R0-R2,R4,R7,PC"

  ]

        LTORG
        END
@


4.12
log
@Fixes in BigSectors option
Previous testing with RAMFS was limited by the size of RAM disc, and hence complexity of layout, meaning some cases with BigSectors were missed.
FileCore20.s: During mount, when loading the defect list from the boot block at &C00, take care to round down the source sector address to account for it only being aligned up to 1k sectors (but not for 2k and 4k).
FileCore25.s: When loading the head of a BigDir (to find out its actual size) and finding it to be > 2k, skip loading the bit from 2k-4k, since that was already loaded when the head was read in, and reading it a second time offset by 2k fails the head/tail check.
FileCore31.s: When building a table to decide which zones to compact, use FindBuffer() to get some temporary store if too large to fit into ScratchSpace.
Identify.s: Comment updated.
BigDirCode.s: (Unrelated) Fix for bad error pointer being passed back, due to R0 being restored on encountering an error during directory rename.

FSBashed for 300k cycles on Titanium with an assortment of manufacturer drives, capacities, and sector sizes.

Version 3.74. Tagged as 'FileCore-3_74'
@
text
@d125 1
a125 1
        MOVS    R5, R5, LSR #9  ;link bits
d132 1
a132 1
        MOVS    R5, R5, LSR #17 ;link bits
@


4.11
log
@[415] Report dir full when hitting dir size limit
FileCore would allow objects to be added to BigDir extensible directories until eventually failing and leaving an unopenable broken directory behind.
In fact, the on disc directory was sound, but after updating the parent in GrowBigDir it would reload the child into the dir cache with FindDir, FindDir called SanityCheckBigDirHeader which was rejecting BigDir's of exactly 4MB that was created moments earlier.
Now, during the initial attempt grow, a check is made for exceeding BigDirMaxSize before trying to enlarge the dynamic area (while it would be possible to translate the error from maxing out the dynamic area, there could be situations where there genuinely isn't enough memory to enlarge the area) and a more polite "Dir full" error returned.
Tested with an initially empty drive (so the dynamic area must grow) and with one that previously created a maximal directory (dynamic area already large enough).

Also tightened up a couple of places loading byte wide variables using LDR, relying on the modulo 31 properties of LSR/LSL, when we can simply load the value as a byte for the same cost.

Version 3.72. Tagged as 'FileCore-3_72'
@
text
@a406 2
        ASSERT  ?ScratchSpace>=16*K
        MOV     R0, #ScratchSpace
d411 20
d453 1
d456 2
a457 1
        Push    "R3, R6-R12"    ;save dir & reserve 28 bytes stack space
d551 2
a552 1
        CMPS    LR, #ScratchSpace
d747 5
d759 5
@


4.10
log
@Reenable background transfer support when BigFiles is {TRUE}
BigDirCode.s: Retire BigDirFix switch, it wasn't actually a fix, it was more that the directory format was changed early in development, but there's no point keeping support for the prototype any more
FileCore45.s/FileCore25.s/FileCore31.s/FileCore35.s/DebugOpts.s: Retire BigDirFix
Defns.s: Shock addition of some comments
FileCore.s: Manual inclusion of CPU/Arch no longer needed
FileCore70.s: Crucially apply the same 1k dead band to the FileSwitch "write zeros" entry point, since it (along with Get/PutBytes) are the only places file offsets get passed
FileCore80.s: Lots of tedious and subtle boundary cases fixed
InitDieSvc.s: Removed the disabling switch
doc/BigDisc/ADFSBuffer: Detail what the BufFlags mean

Tested on ADFS (the only background-transferring filing system about) with LFAUs of 2k, 4k, 8k, 16k and bashing 65536 iterations.

Version 3.57. Tagged as 'FileCore-3_57'
@
text
@d575 1
a575 1
        LDR     R3, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
@


4.9
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@a163 1
  [ BigDirFix
d167 1
a167 4
  |
        ASSERT  BigDirEntrySize=32
        MOVS    R4, R4, LSL #5          ; if R4=0 then dir itself
  ]
@


4.8
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d30 14
a43 1

a48 1
        DREG    R6, ",",cc
d59 3
d64 1
d66 1
a66 1
        BL      RoundUp                 ;(R0,R3->R0)
d68 6
d75 1
d265 1
a282 1
        LDRB    R2 ,[R10,#ZoneHead+DiscRecord_NZones]
d285 1
d287 2
d354 1
a354 1
        STREQ   R9, FragScore            ;THEN note new zone for compaction
d361 1
a361 1
17                              ;try next zone
d369 5
a374 5
 [ BigMaps
        Push    "R0",GT
        LDRGTB  R0, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADDGT   LR, LR, R0, LSL #8
        Pull    "R0",GT
d745 1
a745 1
        BL      RoundUpShare            ;(R0,R3->R0)
d747 1
a747 1
        BL      RoundUpSector           ;(R0,R3->R0)
d840 1
d843 2
a844 1
        BL      RoundUp                 ;(R0, R3->R0)
d846 6
d853 1
d893 1
a893 1
        BL      Divide  ;(ZoneFree *2^19)/( |Zone-DirZone|+1 ) (R0, R1->R0, R1)
d941 1
a941 1
        BL      ReadLen         ;(R4->LR)
d943 7
a949 1
        BL      RoundUp         ;(R3, R0->R0)
d951 1
d953 1
a953 1
        MOV     R5, R1
d958 1
a958 1
        ADD     R5, R5, LR      ;total allocated length in map bits
d961 2
a962 2
        ADD     R1, R1, LR      ;R1  points to next map block
        MOV     R0, R11         ;R10 points to this map block
d971 1
a971 1
        MOVNE   R1, #0          ;R0=0->next free block not directly after us
d980 1
a980 1
; if space allocated is sufficient, exit with success (via FT91)
d982 1
d984 9
d996 2
a997 3
        BEQ     %FT91          ; R2 is appropriate ind disc add

        MOV     R2, LR
d1014 11
d1027 3
a1029 3
        BL      RoundUp                ;(R0,R3->R0)
        MOV     R9, R0, LSR R7
        Pull    "R0"                   ;round up and convert to alloc bits
d1035 1
a1035 4
        BLS     %BT25                  ;accept this size

        CMPS    R9, R6   ;MAX ALLOC SIZE
        MOVLO   R6, R9
d1037 3
d1119 1
a1119 1
        BIC     R0, R0,#DiscBits
d1130 1
a1130 1
        BL      RoundUp                 ;(R0, R3->R0)
d1142 1
a1142 1
        BL      RoundUp                 ;(R0, R3->R0)
d1170 1
a1170 1
        ADDNE   R0, R0, R4              ;new length=length desired+extra amount
d1172 4
d1177 2
d1180 7
d1188 1
a1189 2
        STR     R0, [SP,#Stacked4+ClaimLength]

d1241 1
a1241 1
        MOV     R1, R5
d1245 1
a1245 1
        MOV     R6, LR
d1247 2
a1248 2
        TEQS    R11, R9
        BEQ     %FT20           ;found a gap
d1250 1
a1250 1
        BL      FragRdLenLinkBits ;(R10,R11-R7,R8)
d1252 1
a1252 1
        BL      RdLenLinkBits   ;(R10,R11-R7,R8)
d1254 1
a1254 1
        TEQS    R8, R4
d1258 1
a1258 1
        ADD     R11,R11,R7
d1263 5
a1268 5
 [ BigMaps
        Push    "R0"
        LDRB    R0,[R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     LR, LR, R0, LSL #8
        Pull    "R0"
d1272 1
a1272 1
        B        %BT05           ;loop for next zone
d1287 5
d1293 1
a1293 1

a1294 4
 [ DebugE
        DREG    R5, "gap offset:",cc
        DREG    R8, ", extent:"
 ]
d1300 7
a1306 2
        SUBS    R2, R8, R5
        BLO     %FT60
d1403 1
a1403 1
        MOV     R8, R7, LSL LR
d1437 2
a1438 1
        MOV     R6, R1
d1440 9
a1448 1
        MOV     R0, R1, LSL LR
a1449 2
        LDR     R1, [SP,#Stacked4b+AllocTotal]
        MOV     R1, R1, LSL LR
@


4.7
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d1287 1
a1288 1
 [ BigMaps
d1291 2
@


4.6
log
@Fix bug in DetermineDiscType.
When failed to identify, and the last operation was format, the DiscSize2 field was not being copied (instead DiscSize is copied twice).
Fix up some warnings from the assembler.
Tested briefly with a RAM disc, still works.

Version 3.44. Tagged as 'FileCore-3_44'
@
text
@d51 1
a51 1
        LDRB    LR, [R1,#BitSize]
d58 3
a60 3
 	LDREQB	R0, [R10,#ZoneHead+Zones]
 	LDREQB	LR, [R10,#ZoneHead+Zones2]
 	ADDEQ	R0, R0, LR, LSL #8
d62 1
a62 1
        LDREQB  R0, [R10,#ZoneHead+Zones]
d83 1
a83 1
        LDRB    R7, [R10,#ZoneHead+SectorSize]
d85 1
a85 1
        LDRB    LR, [R10, #ZoneHead+ShareSize]  ; get sharing unit
d97 6
a102 6
 	LDMIA	R8!, {R4, R5}   ; r4 - index into dir
 	AND	R0, R5, #&FF	; r5 - sharing offset
 	TEQS	R5, #0
 	TEQEQS	R4, #0
 	BEQ	%FT06		;end of list marker found
 	MOVS	R5, R5, LSR #9	;link bits
d138 2
a139 2
 	BL	TestBigDir
 	BNE	NewClaimFree_IsNotBigDir
d142 3
a144 3
  	ASSERT	BigDirEntrySize=28
  	RSB	R4, R4, R4, LSL #3
  	MOVS	R4, R4, LSL #2
d146 2
a147 2
 	ASSERT	BigDirEntrySize=32
 	MOVS	R4, R4, LSL #5		; if R4=0 then dir itself
d149 4
a152 4
 	BNE	NewClaimFree_IsNotDir
 	LDR	LR, DirBufferPtr
 	LDR	LR, [LR, #BigDirSize]	; size of dir itself
 	B	NewClaimFree_ReJoin
d154 8
a161 8
 	LDR	LR, DirBufferPtr
 	LDR	LR, [LR, #BigDirNameLen]
 	ADD	LR, LR, #4
 	BIC	LR, LR, #3
 	ADD	R4, LR, R4
 	LDR	LR, DirBufferPtr
 	ADD	LR, LR,#BigDirHeaderSize-BigDirEntrySize
 	ADD	R4, R4, LR
d163 1
a163 1
 	B	NewClaimFree_ReJoin			; R4 now points at entry
d169 2
a170 2
        LDRNE	LR, DirBufferPtr
        ADDNE	LR, LR, #DirFirstEntry-NewDirEntrySz
d185 2
a186 2
 	BICS	LR, R1, #&ff		;check if it's beyond max sharing limit
 	BNE	NewClaimFree_ShareTooLarge
d190 5
a194 5
 	LDR	R0, [R8, #-4]		; from previous record
 	LDR	LR, [R8, #4]		; from next obj
 	EOR	LR, R0, LR
 	MOVS	LR, LR, LSR #8		;
 	BEQ	%BT04			;IF next obj in same frag then loop
d259 1
a259 1
        LDRB    R2 ,[R10,#ZoneHead+Zones]
d261 2
a262 2
 	LDRB	R7, [R10,#ZoneHead+Zones2]
 	ADD	R2, R2, R7, LSL #8
d343 1
a343 1
        LDRGTB  LR, [R10,#ZoneHead+Zones]
d345 4
a348 4
 	Push	"R0",GT
 	LDRGTB	R0, [R10,#ZoneHead+Zones2]
 	ADDGT	LR, LR, R0, LSL #8
 	Pull	"R0",GT
d387 1
a387 1
        LDRB    R1, [R10,#ZoneHead+SectorSize]
d553 1
a553 1
        LDR     R3, [R10,#ZoneHead+SectorSize]
d577 1
a577 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d587 4
a590 4
	ADD	R9,R5,R8	; fix to prevent infinite loop if can't fit pair
	MOV	R9,R9,LSL R2
	CMP	R4,R9
	BGT	%FT70           ; end of fix
d714 1
a714 1
        LDRB    LR, [R10,#ZoneHead+BitSize]
d756 4
a759 4
        TEQS	R11,R9		; if gap
        BEQ	%FT26
        BL	RdLenLinkBits   ; not gap
        B	%FT27
d762 1
a762 1
	BL	FreeRdLenLinkBits
d817 2
a818 2
        LDRB    LR, [R1,#BitSize]
        MOV     R8, R0, LSR LR		; SBP: now have length in map bits
d828 2
a829 2
; SBP: 	Note, all the sizes used from here on appear to be in map
;	bits; this is A Good Thing.
d836 2
a837 2
        BL      IndDiscAddToZone	; (R0,R10->R0)
        MOV     R5, R0			; zone dir
d839 5
a843 5
        MOV     R2, #0	;  best zone=0
        MOV     R3, #0	;  zone free=0
        MOV     R4, #0	;       zone=0
        MOV     R6, #0	;  disc free=0
        MOV     R8, #0	; best score=0
d863 1
a863 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d886 1
a886 1
        LDRB    R1, [R10,#ZoneHead+BitSize]
d917 2
a918 2
        CMPS    R8, R5		;compare wanted size with allocated size
        MOVLO   R8, R5		;if less, adjust up to allocated size
d920 1
a920 1
        MOV     R0, R11		;R10 points to this map block
d922 1
a922 1
        MOV     R11,R9		;predecessor gap in R11
d941 1
a941 1
        LDREQB  LR, [R10,#ZoneHead+BitSize]
d958 3
a960 3
        LDRB    R0, [R10,#ZoneHead+RAskew]
        LDRB    LR, [R10,#ZoneHead+SectorSize]
        ADD     R0, R1, R0,LSL LR         ;bytes in (cylinder + RAskew) sectors
d962 1
a962 1
        LDRB    R7, [R10,#ZoneHead+BitSize]
d1031 1
a1031 1
        ADD     R5, R5, R7	; is the gap big enough?
d1033 1
a1033 1
        BLO     %BT30		; if no, try next gap.
d1051 1
a1051 1
        LDRB    LR, [R10,#ZoneHead+RAskew]
d1062 2
a1063 2
        TEQS    R1, #0			; R1=sector offset into cylinder
	BEQ	%FT65
d1066 4
a1069 4
	LDRB	LR, [R10,#ZoneHead+SectorSize]	; back to bytes
	MOV	R0, R0, LSL LR
        BL      RoundUp           	;(R0, R3->R0)
        LDRB    LR, [R10,#ZoneHead+BitSize]
d1073 10
a1082 10
        BL	BytesPerCylinder        ;(R10->LR)
        MOV	R1, LR
        BL	Divide
        TEQS	R1, #0
	BEQ	%FT65
        BL	BytesPerCylinder        ;(R10->LR)
        SUB	R0, LR, R1
        BL	RoundUp                 ;(R0, R3->R0)
        LDRB	LR, [R10,#ZoneHead+BitSize]
        ADD	R2, R2, R0,LSR LR
d1100 1
a1100 1
        Pull    "R4,R6"			;
d1109 1
a1109 1
        LDRB    LR, [R10,#ZoneHead+BitSize]
d1126 1
a1126 1
        BLNE	FragWrLenBits   ;(R0,R1,R10)
d1189 1
a1189 1
        LDRB    LR,[R10,#ZoneHead+Zones]
d1191 4
a1194 4
 	Push	"R0"
 	LDRB	R0,[R10,#ZoneHead+Zones2]
 	ADD	LR, LR, R0, LSL #8
 	Pull	"R0"
d1212 1
a1212 1
        LDRB    LR, [R10,#ZoneHead+BitSize]
d1228 1
a1228 1
        MOV     R0, #(1:SHL:UseScratchSpace) :OR: (1:SHL:UseSpareScreen) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: (1:SHL:UseIndOp) :OR: ScatterBit
d1230 1
a1230 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d1249 1
a1249 1
        MOV     R1, #ReadSecsOp :OR: ScatterBit :OR: NoEscape
d1262 1
a1262 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d1282 1
a1282 1
        LDRB    LR, [R10,#ZoneHead+SectorSize]
d1287 1
a1287 1
        LDRB    LR, [R10,#ZoneHead+Zones]
d1289 2
a1290 2
 	LDRB	R11, [R10, #ZoneHead+Zones2]	; R11 safe cos InitZoneObj will hit it
 	ADD	LR, LR, R11, LSL #8
d1306 2
a1307 2
        BLEQ	FreeRdLenLinkBits
        BLNE	FragRdLenLinkBits
d1320 1
a1320 1
        LDRB    LR, [R10,#ZoneHead+BitSize]
d1329 1
a1329 1
        MOV     R1, #WriteSecsOp :OR: ScatterBit :OR: NoEscape
d1341 1
a1341 1
        MOV     R1, #WriteSecsOp :OR: ScatterBit :OR: NoEscape
d1356 1
a1356 1
        LDRB    LR, [R10,#ZoneHead+BitSize]
d1409 2
a1410 2
        LDRB    R0,[R10,#ZoneHead+SecsPerTrk]
        LDRB    LR,[R10,#ZoneHead+Heads]
d1412 1
a1412 1
        LDRB    R0,[R10,#ZoneHead+SectorSize]
d1433 2
a1434 2
        LDRB    R0,[R10,#ZoneHead+SecsPerTrk]
        LDRB    LR,[R10,#ZoneHead+Heads]
d1456 1
a1456 1
; word 0:	0=>dir itself, else index of obj in dir
d1458 3
a1460 3
; word 1:   	bits 0-7   are sector offset in shared block
;            	bit  8     set if link bits >= link bits for dir
;		bit  9-31  are link bits
d1488 4
a1491 4
	BL	DiscAddToRec		;(R3->LR)
	LDRB	LR, [LR, #LinkBits]	;get LinkBits
	MOV	R1, #1
	MOV	R10, R1, LSL LR		;number of possible ids
d1495 1
a1495 1
	ADD	R9, R8, #?ScratchSpace	; end of scratch space
d1499 1
a1499 1
        STMNEIA	R7!, {R1, LR}		; store doubleword entry
d1501 1
a1501 1
 	BL	TestBigDir
d1503 2
a1504 2
        BLEQ	GetDirFirstEntry
        SUBEQ	R4, R4, #BigDirEntrySize
d1517 1
a1517 1
	DREG	LR, "Indirect disc address: "
d1525 1
a1525 1
        RSBMI   LR, LR, #0		;offset in linkbits
d1528 2
a1529 2
	CMPS	LR, R10, LSL #9		;check for too high
	BHI	%FT10			;if too high then back round again
d1531 2
a1532 2
 	DREG	R1, "Dir index  : "
 	DREG	LR, "Other word : "
d1534 4
a1537 4
        STMIA	R7!, {R1, LR}
	CMP	R7, R9
	MOVEQ	R10, R10, LSR #1	; half the search range
	BEQ	%BT03			; back round with reduced search range
d1540 6
a1545 6
 	BL	TestBigDir
 	BNE	%FT01			; not a big dir
 	ADD	R4, R4, #BigDirEntrySize
 	BL	BigDirFinished
 	BNE	%BT05			; go round again
 	B	%FT02			; finished
d1555 1
a1555 1
        BL      SortPair            	;(R0, R1)
d1558 1
a1558 1
        STR	LR, [R7],#4
d1565 1
a1565 1
	ASSERT	BigDir = {FALSE}
@


4.5
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d415 1
a415 1
        Push    "R3, R7-R13"      ;save dir & reserve stack space
@


4.4
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  Many of these are unaligned LDRs where only bits 0-7 of the result are used
  (tested against a bitmask or used as an input to the barrel shifter) but
  they have all been moved to byte operations because they are faster on
  ARMv6 and won't cause false positives if unaligned aborts are enabled.

  s.BigDirCode line 104: not wrong as such, but changed to use aligned LDR
    for speed on ARMv6.
  s.BigDirCode line 1727: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.Commands line 129: STR to an unaligned 1-byte variable. Harmless because
    all overlapping variables are initialised later on.
  s.Commands line 539: LDR of an unaligned 1-byte variable. Only used for
    testing bit 6.
  s.FileCore31 line 1359: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.FileCore32 lines 1483 and 1825: LDR of an unaligned 1-byte variable. Only
    used as input to shifter.
  s.FormSWIs line 1403: bugfix: incorrect load of 16-bit zone_spare field of
    disc record - uses lowsector and nzones fields instead! This is used to
    terminate the search of free space fragments within the allocation bytes
    of the current map block for the one containing a bad block found during
    formatting. Would manifest itself as a "Can't map defect out" error.
  s.GenSWIs lines 1182,1195: bugfix: LDR of 1-byte variables. Effect of this
    was that range-checking of the drive number passed to FileCore_MiscOp 5
    (eject) wasn't performed.
  Added ENTRY directive to permit building of GPA debug listing.
Admin:
  Builds, but untested.

Version 3.34. Tagged as 'FileCore-3_34'
@
text
@d758 1
a758 1
        BL	RdLenLinkBits	; not gap
@


4.3
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d1356 1
a1356 1
        LDR     LR, [R10,#ZoneHead+BitSize]
@


4.2
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@a26 1
 [ NewFs
d546 1
a546 1
        MOVS    PC, LR
d853 1
a853 1
        MOV     R9, PC          ;save flags
d867 1
a867 1
        TEQP    PC, R9          ;restore flags
d1559 1
a1559 1
        Pull    "R0-R2,R4,R7,R9,R10,PC",,^
d1627 1
a1627 1
        Pull    "R0-R2,R4,R7,PC",,^
a1629 2

 ]
@


4.1
log
@Initial revision
@
text
@d25 1
d34 1
a34 1
 [ DebugE
d58 5
d64 1
d83 1
a83 1
        MOV     R6, #8*K        ;init smallest fit
d97 8
d111 1
d114 1
a114 1
 [ DebugE
d131 1
a131 1
 [ DebugE
d138 38
d181 1
a181 1
        BL      ReadLen                 ;(R3,R4->LR)    R4=0 if dir itself
d185 4
d190 7
d202 1
d222 1
a222 1
 [ DebugE
d228 4
a231 1
        TEQS    R6, #8*K
d236 2
a237 2
        TEQS    R6, #8*K
 [ DebugE
d261 4
d280 1
a280 2
        BL      NextFree        ;(R10,R11->R9, R11,Z,C)
        BLNE    RdLenBits       ;(R10,R11->R7)
d282 5
d345 6
d418 3
d422 1
d428 3
d432 1
d489 3
d493 1
d632 3
d636 1
d683 3
d687 1
d756 9
d768 1
d847 3
d851 1
d979 1
d1005 3
d1009 1
d1023 3
d1027 1
d1119 3
d1123 1
d1126 3
d1130 1
d1158 4
d1164 1
d1176 3
d1180 1
d1191 6
d1270 4
d1276 1
d1289 4
d1305 5
d1312 1
d1370 3
d1374 2
d1446 122
d1586 1
a1586 1
 [ DebugE
d1629 2
@


4.1.4.1
log
@Changes made to FileCore to support allowing idlen more than 15.  This allows
smaller LFAUs on discs.  The changes are not yet complete.  In particular, the
number of disc zones is limited to 255.  Some development testing has been
peformed, and the filing system is generally stable.  Areas which haven't
been fully tested include things like *Defect, FileCore_LayoutStructure,
FileCore_FloppyStructure, and the FileSwitch APIs for reading and examining
a disc's used space.

This version should not be used for any OS Builds with the BigMaps flag set
to true.  It should build as a normal version of FileCore with BigMaps and
BigDirs set to false.
@
text
@a24 1
; 28 May 1997 SBP   Changed for IdLen>15
a207 3
 [ BigMaps
        BLNE    FreeRdLenBits       ;(R10,R11->R7)
 |
a208 1
 ]
a334 3
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
a335 1
 ]
a340 3
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
a341 1
 ]
a397 3
 [ BigMaps
        BL      FreeRdLenBits   ;(R10,R11->R7)
 |
a398 1
 ]
a536 3
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
a537 1
 ]
a583 3
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
a584 1
 ]
a652 9
 [ BigMaps
        TEQS	R11,R9		; if gap
        BEQ	%FT26
        BL	RdLenLinkBits	; not gap
        B	%FT27

26 ; here if gap
	BL	FreeRdLenLinkBits
 |
a655 1
 ]
a733 3
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
a734 1
 ]
a886 3
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
a887 1
 ]
a900 3
 [ BigMaps
        BLNE    FreeRdLenBits   ;(R10,R11->R7)
 |
a901 1
 ]
a992 3
 [ BigMaps
        BLNE    FragRdLenBits   ;(R10,R11->R7)
 |
a993 1
 ]
a995 3
 [ BigMaps
        BLNE	FragWrLenBits   ;(R0,R1,R10)
 |
a996 1
 ]
a1023 4
 [ BigMaps
        MOV     R4, LR, LSL #3
        MOV     R4, R4, LSR #3+8        ;link bits
 |
a1025 1
 ]
a1036 3
 [ BigMaps
        BL      FragRdLenLinkBits ;(R10,R11-R7,R8)
 |
a1037 1
 ]
a1120 4
 [ BigMaps
        MOV     R1, R1, LSL #3
        MOV     R1, R1, LSR #3+8      ;link bits
 |
a1122 1
 ]
a1146 5
 [ BigMaps
        TEQS    R11,R9          ;gap ?
        BLEQ	FreeRdLenLinkBits
        BLNE	FragRdLenLinkBits
 |
a1148 1
 ]
a1205 3
 [ BigMaps
        BL      FragRdLenBits   ;(R10,R11->R7)
 |
a1206 2
 ]

@


4.1.4.2
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@d34 1
a34 1
 [ DebugE :LOR: DebugEs
a90 8
 [ BigMaps; :LAND: {FALSE}
 	LDMIA	R8!, {R4, R5}   ; r4 - index into dir
 	AND	R0, R5, #&FF	; r5 - sharing offset
 	TEQS	R5, #0
 	TEQEQS	R4, #0
 	BEQ	%FT06		;end of list marker found
 	MOVS	R5, R5, LSR #9	;link bits
 |
a96 1
 ]
d99 1
a99 1
 [ DebugE :LOR: DebugEs
d116 1
a116 1
 [ DebugE :LOR: DebugEs
a132 7
 [ BigMaps
 	LDR	R0, [R8, #-4]		; from previous record
 	LDR	LR, [R8, #4]		; from next obj
 	EOR	LR, R0, LR
 	MOVS	LR, LR, LSR #8		;
 	BEQ	%BT04			;IF next obj in same frag then loop
 |
a137 1
 ]
d157 1
a157 1
 [ DebugE :LOR: DebugEs
d169 1
a169 1
 [ DebugE :LOR: DebugEs
a1356 75
  [ BigMaps; :LAND: {FALSE}
  
; =======
; SortDir
; =======

; form table in scratch space for each object small enough to share a map obj

; with BigMaps, IdLen may be more than 15 bits, so we need more space than a single
; word to store the info.  as the fields must grow with Big dirs also, we make
; each item have two words:

; word 0:	0=>dir itself, else index of obj in dir
;
; word 1:   	bits 0-7   are sector offset in shared block
;            	bit  8     set if link bits >= link bits for dir
;		bit  9-31  are link bits

; NOTE:  the link bits field is the DIFFERENCE between the current
;        link bits and the dir. link bits.  this is NOT obvious from 
;        other comments.

;entry
; R3    disc address of dir
; R5 -> dir start

;exit
; R8 -> table start, table end marked by pair of 0 words

SortDir ROUT                    ;BUILD TABLE
 [ DebugE
        DREG    R3, "SortDir(",cc
        DREG    R5, ",",cc
        DLINE   ")"
 ]
        Push    "R0-R2,R4,R7,LR"
        MOV     R1, #0                  ;init index in dir
        MOV     R8, #ScratchSpace
        MOV     R7, R8
        ANDS    LR, R3, #&FF
        ORRNE   LR, LR, #1 :SHL: 8
        STMNEIA	R7!, {R1, LR}		; store doubleword entry
        SUB     R4, R5, #NewDirEntrySz-DirFirstEntry
        B       %FT10
05
        ADD     R1, R1, #1              ;inc dir index
        BL      ReadIntAtts             ;(R3,R4->LR)
        TSTS    LR, #DirBit
        BNE     %FT10
        BL      ReadIndDiscAdd          ;(R3,R4->LR)
        BIC     R2, LR, #DiscBits
        TEQS    R2, #1                  ;skip if 0 length
        ANDNES  R2, LR, #&FF            ;or not shared
        BEQ     %FT10
        MOV     LR, LR, LSR #8          ;build entry
        SUBS    LR, LR, R3, LSR #8
        RSBMI   LR, LR, #0
        ORR     LR, R2, LR, LSL #9
        ORRPL   LR, LR, #1 :SHL: 8
        STMIA	R7!, {R1, LR}
10
        LDRB    LR, [R4,#NewDirEntrySz]!
        CMPS    LR, #" "
        BHI     %BT05

        MOV     R0, R8
        MOV     R1, R7
        BL      SortPair            	;(R0, R1)
        MOV     LR, #0
        STR     LR, [R7],#4
        STR	LR, [R7],#4
        Pull    "R0-R2,R4,R7,PC",,^
        
  |

d1375 1
a1375 1
 [ DebugE :LOR: DebugEs
a1417 2
        
  ]
@


4.1.4.3
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@a57 5
 [ BigMaps
 	LDREQB	R0, [R10,#ZoneHead+Zones]
 	LDREQB	LR, [R10,#ZoneHead+Zones2]
 	ADDEQ	R0, R0, LR, LSL #8
 |
a58 1
 ]
a131 23
 [ BigDir
 	BL	TestBigDir
 	BNE	NewClaimFree_IsNotBigDir
 	
 	ASSERT	BigDirEntrySize=32
 	MOVS	R4, R4, LSL #5		; if R4=0 then dir itself
 	BNE	NewClaimFree_IsNotDir
 	LDR	LR, DirBufferPtr
 	LDR	LR, [LR, #BigDirSize]	; size of dir itself
 	B	NewClaimFree_ReJoin
NewClaimFree_IsNotDir
 	LDR	LR, DirBufferPtr
 	LDR	LR, [LR, #BigDirNameLen]
 	ADD	LR, LR, #3		
 	BIC	LR, LR, #3
 	ADD	R4, LR, R4
 	LDR	LR, DirBufferPtr
 	ADD	LR, LR,#BigDirHeaderSize-BigDirEntrySize
 	ADD	R4, R4, LR
        BL      ReadLen                 ;(R3,R4->LR)    R4=0 if dir itself
 	B	NewClaimFree_ReJoin			; R4 now points at entry
 	
NewClaimFree_IsNotBigDir
d135 1
a135 2
        LDRNE	LR, DirBufferPtr
        ADDNE	LR, LR, #DirFirstEntry-NewDirEntrySz
a137 8
NewClaimFree_ReJoin
 |
        ASSERT  NewDirEntrySz=26
        ADDS    LR, R4, R4, LSL #1      ;R4*3 convert index in dir to ptr
        ADDNE   R4, R4, LR, LSL #2      ;R4*13
        sbaddr  LR, (DirBuffer+DirFirstEntry-NewDirEntrySz),NE
        ADDNE   R4, LR, R4, LSL #1      ;ptr to dir entry
 ]
a140 4
 [ BigDir
 	BICS	LR, R1, #&ff		;check if it's beyond max sharing limit
 	BNE	NewClaimFree_ShareTooLarge
 ]
a179 3
 [ BigDir
NewClaimFree_ShareTooLarge
 ]
a209 4
 [ BigMaps
 	LDRB	R7, [R10,#ZoneHead+Zones2]
 	ADD	R2, R2, R7, LSL #8
 ]
a289 6
 [ BigMaps
 	Push	"R0",GT
 	LDRGTB	R0, [R10,#ZoneHead+Zones2]
 	ADDGT	LR, LR, R0, LSL #8
 	Pull	"R0",GT
 ]
a917 1

a1128 6
 [ BigMaps
 	Push	"R0"
 	LDRB	R0,[R10,#ZoneHead+Zones2]
 	ADD	LR, LR, R0, LSL #8
 	Pull	"R0"
 ]
a1220 4
 [ BigMaps
 	LDRB	R11, [R10, #ZoneHead+Zones2]	; R11 safe cos InitZoneObj will hit it
 	ADD	LR, LR, R11, LSL #8
 ]
d1375 1
a1415 6
 [ BigDir
 	BL	TestBigDir
        SUBNE   R4, R5, #NewDirEntrySz-DirFirstEntry
        BLEQ	GetDirFirstEntry
        SUBEQ	R4, R4, #BigDirEntrySize
 |
a1416 1
 ]
a1434 8
 [ BigDir
 	BL	TestBigDir
 	BNE	%FT01			; not a big dir
 	ADD	R4, R4, #BigDirEntrySize
 	BL	BigDirFinished
 	BNE	%BT05			; go round again
 	B	%FT02			; finished
01
a1437 2
02
 ]
d1446 1
a1446 1

a1447 4

; if BigMaps is FALSE, then so must BigDir be

	ASSERT	BigDir = {FALSE}
@


4.1.4.4
log
@Altered directory format (change backup dir entries to be one word instead
of an entire copy of the entry).  Also reduced size of a directory entry
by one word.  Also fixed a number of small bugs.
@
text
@a141 5
  [ BigDirFix
  	ASSERT	BigDirEntrySize=28
  	RSB	R4, R4, R4, LSL #3
  	MOVS	R4, R4, LSL #2
  |
a143 1
  ]
d151 1
a151 1
 	ADD	LR, LR, #4
a1504 4
 [ DebugX
 	DREG	R1, "Dir index  : "
 	DREG	LR, "Other word : "
 ]
@


4.1.4.5
log
@Fixed:

DoOsFunRenameBigDir to work when renaming a shared file between dirs where
the file ends up as the last object in the target dir.

SanityCheckEDiscRecord to allow idlen>15 when DiscVersion=0

GrowBigDir to round up desired size to a multiple of the disc allocation
size.

Also:

Implemented non-working code to write cache the dir buffer.  WriteCacheDir
compile switch set to FALSE in s.DebugOpts.  Don't set it to TRUE unless
I tell you it's working.

Made SortDir not attempt to sort more than 2047 entries in a dir, to
avoid it overflowing ScratchSpace.

Made SortPair do one extra shell on the sort (makes it more efficient).
@
text
@d141 1
a141 1

d165 1
a165 1

d1464 1
a1464 1
;        link bits and the dir. link bits.  this is NOT obvious from
a1473 7
; ALSO NOTE:

; if there's more entries in the dir than can be sorted in ScratchSpace,
; the function will re-run but will only sort on entries near the dir
; in the map; it will keep halfing the distance allowed (in id bits)
; from the directory.

d1480 1
a1480 7
        Push    "R0-R2,R4,R7,R9,R10,LR"

	BL	DiscAddToRec		;(R3->LR)
	LDRB	LR, [LR, #LinkBits]	;get LinkBits
	MOV	R1, #1
	MOV	R10, R1, LSL LR		;number of possible ids
03
a1482 1
	ADD	R9, R8, #?ScratchSpace	; end of scratch space
a1501 4

 [ DebugX
	DREG	LR, "Indirect disc address: "
 ]
d1508 1
a1508 1
        RSBMI   LR, LR, #0		;offset in linkbits
a1510 2
	CMPS	LR, R10, LSL #9		;check for too high
	BHI	%FT10			;if too high then back round again
a1515 3
	CMP	R7, R9
	MOVEQ	R10, R10, LSR #1	; half the search range
	BEQ	%BT03			; back round with reduced search range
d1537 1
a1537 1
        Pull    "R0-R2,R4,R7,R9,R10,PC",,^
d1606 1
a1606 1

@


4.1.4.6
log
@Found a major inefficiency in the handling of file creation, closing of files
and other uses of the NextFree function.  In the case of file creation, the
problem was particularly bad on large free space maps, as the function was
of order N^2 on the size of the map, when the disc was nearly full.  As the
disc gets fuller, the problem gets worse; with 1400 zones in the map, N^2
is very large indeed.  This resulted in *cdir sometimes taking 1sec.

Now, a new function NextFree_Quick exists which performs similarly to NextFree,
but does not consider free spaces in zones beyond the current zone.  This
can be used by functions which need only examine free spaces in a given zone,
such as is the case in ClaimFreeSpace where it is stepping throigh zones to
find a single gap large enough for the entire file.

For other functions which work on a single zone, the speedup is less dramatic,
of the order N instead of N^2.
@
text
@d280 1
a280 2
        BL      NextFree_Quick  ;(R10,R11->R9, R11,Z,C)
        BCS     %FT14           ;zone done
d282 1
a282 1
        BL      FreeRdLenBits   ;(R10,R11->R7)
d284 1
a284 1
        BL      RdLenBits       ;(R10,R11->R7)
d286 1
@


4.1.4.7
log
@Fixed bug with zone compaction with idlen>15, in CompactZone.
@
text
@d83 1
a83 1
        MOV     R6, #1024*K        ;init smallest fit
d231 1
a231 1
        TEQS    R6, #1024*K
d236 1
a236 1
        TEQS    R6, #1024*K
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

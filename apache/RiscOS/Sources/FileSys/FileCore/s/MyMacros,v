head	4.10;
access;
symbols
	FileCore-3_75:4.10
	FileCore-3_74:4.10
	FileCore-3_73:4.10
	FileCore-3_72:4.9
	FileCore-3_71:4.9
	FileCore-3_70:4.9
	FileCore-3_69:4.9
	FileCore-3_68:4.9
	FileCore-3_67:4.9
	FileCore-3_66:4.9
	FileCore-3_65:4.9
	FileCore-3_64:4.9
	FileCore-3_63:4.9
	FileCore-3_62:4.9
	FileCore-3_61:4.9
	FileCore-3_60:4.9
	FileCore-3_59:4.9
	FileCore-3_58:4.9
	FileCore-3_57:4.9
	FileCore-3_56:4.9
	FileCore-3_55:4.9
	FileCore-3_54:4.8
	FileCore-3_53:4.7
	FileCore-3_52:4.7
	FileCore-3_51:4.7
	FileCore-3_50:4.7
	FileCore-3_49:4.7
	FileCore-3_48:4.7
	FileCore-3_47:4.7
	FileCore-3_46:4.7
	FileCore-3_45:4.7
	FileCore-3_44:4.6
	FileCore-3_43:4.6
	FileCore-3_42:4.6
	FileCore-3_41:4.5
	FileCore-3_40:4.4
	FileCore-3_39:4.4
	FileCore-3_38:4.4
	FileCore-3_37:4.4
	FileCore-3_36:4.4
	FileCore-3_35:4.4
	FileCore-3_34:4.4
	FileCore-3_33:4.4
	RO_5_07:4.3
	FileCore-3_32:4.3
	FileCore-3_31:4.3
	FileCore-3_30:4.2
	FileCore-3_29:4.2
	FileCore-3_28:4.2
	FileCore-3_25-4_9_2_2:4.2
	FileCore-3_27:4.2
	FileCore-3_26:4.2
	FileCore-3_22-4_6_2_1:4.1
	bavison_FileCore-3_22_dev_bp:4.1
	bavison_FileCore-3_22:4.1.0.12
	FileCore-3_25-4_9_2_1:4.2
	HAL:4.2.0.2
	FileCore-3_25:4.2
	FileCore-3_24:4.2
	FileCore-3_23:4.2
	dellis_autobuild_BaseSW:4.1
	FileCore-3_22:4.1
	Ursula_merge:4.1
	ROL_merge:4.1
	FileCore-3_21:4.1
	ROL_Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	ROL_FileCore-3_21:4.1
	ROL_FileCore-3_20:4.1
	ROL:4.1.0.10
	ROL_bp:4.1
	Ursula_RiscPC_bp:4.1
	FileCore-3_18:4.1
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1
	sproven_FileCore-3_16:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	sproven_FileCore-3_15:4.1
	sproven_314:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1
	sproven_3_11:4.1
	sproven_3_10:4.1
	sproven_Ursula_3_09:4.1
	sproven_3_07:4.1
	sproven_3_06:4.1
	sproven_3_05:4.1
	sproven_3_04:4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1
	sproven_3_02:4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2017.04.29.08.49.43;	author rool;	state Exp;
branches;
next	4.9;
commitid	Ze6vG68B8T6qkpPz;

4.9
date	2013.02.21.16.53.10;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	CCuV2tngKttj75Fw;

4.8
date	2012.10.28.08.52.32;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	6n5fY77YU7JEb8qw;

4.7
date	2011.10.14.07.23.52;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	D2Id4aPp4zmuUhDv;

4.6
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	A9Zxco9ydo9FCOBv;

4.5
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	PKTDORFkNFRVOmzv;

4.4
date	2009.05.17.01.48.33;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2003.04.03.18.33.29;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.10.30.13.26.35;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.25;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.25;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.41.30;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.21;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Fix to sort dirs correctly when no territory is loaded
Detail:
  FileCore is defined as a case insensitive FS (ie. MyFile can't coexist in the same directory as mYfILE).
  Prior to a territory being selected the BigDir binary chop sort would (via the Internat_UpperCase macro) abandon a directory search once it mismatched, and so would never find !Territory in order to select the territory in the first place.
  Have Internat_UpperCase use ASCII uppercase until that time.
Admin:
  Based on a submission from Colin Granville, with modifications.

Version 3.73. Tagged as 'FileCore-3_73'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >MyMacros


        MACRO
$lab    SemEntry   $action,$pre
$lab
        Push    "R0,R1,SB,LR"
        BL      $pre.Entry$action.Err
        MEND


        MACRO
$lab    MinOps  $firstop, $repeatop, $destreg, $srcreg, $const, $cond
        LCLA    Const
Const   SETA    $const
        LCLA    Rotate
Rotate  SETA    0
        LCLL    First
        LCLA    Bits8
        LCLA    Bit
Bit     SETA    2

        WHILE   Bit<32
         [ ($const :ROR: Bit) < Const
Const    SETA    $const :ROR: Bit
Rotate   SETA    Bit
         ]
Bit     SETA    Bit+2
        WEND

Bit     SETA    0
Bits8   SETA    0
First   SETL    {TRUE}

        WHILE   (Const <> Bits8) :LOR: First
Const   SETA    Const - Bits8

         WHILE   (Const :AND: (2_11 :SHL: Bit) = 0 ) :LAND: Bit<24
Bit      SETA    Bit+2
         WEND

Bits8   SETA    Const :AND: ( &FF :SHL: Bit )

         [ First

          [ "$srcreg"=""
$lab      $firstop.$cond $destreg, #Bits8 :ROL: Rotate
          |
$lab      $firstop.$cond $destreg, $srcreg, #Bits8 :ROL: Rotate
          ]

         |

$lab     $repeatop.$cond $destreg, $destreg, #Bits8 :ROL: Rotate
         ]

First   SETL    {FALSE}
        WEND
        MEND

;put address of $dest in $reg
        MACRO
$lab    myaddr  $reg,$dest,$cond
        ASSERT  $reg<>PC
        ASSERT  ($dest-{PC}-8)<&10000
$lab    ADD$cond $reg,PC,#($dest-{PC}-8) :AND: &FF
        ADD$cond $reg,$reg,#($dest-{PC}-4) :AND: &FF00
        MEND


        GBLA    boff
        MACRO
$lab    baddr   $reg,$dest,$cond
        ASSERT  $reg<>PC
boff    SETA    {PC}+8-($dest)
$lab    MinOps  SUB, SUB, $reg, PC, boff, $cond
        MEND


;put absolute address of $sboff in $reg
        MACRO
$lab    sbaddr  $reg,$sboff,$cond
$lab    MinOps  ADD, ADD, $reg, SB, :INDEX: ($sboff), $cond
        MEND


        MACRO
$lab    aw      $size           ;allocate word aligned
        ASSERT  {VAR} :MOD: 4=0
$lab    #       $size
        MEND


        MACRO
$lab    bit     $bitnum
$lab    *       1 :SHL: ($bitnum)
        MEND


        MACRO
        getSB
        LDR     SB,[SB]
        MEND


;point Rptr to start of disc record Rindex, must preserve flags
        MACRO
$lab    DiscRecPtr $Rptr,$Rindex,$cond
        ASSERT  $Rptr<>SB
        ASSERT  $Rptr<>PC
 [ BigDisc
 [ DebugDR
        Push    "SB,LR, R0"
        MOV     R0, $Rindex
        SavePSR SB
        BICS    LR, R0, #7
        BEQ     %FT01
        DREG    R0, "DiscRecPtr: illegal disc:"
        DREG    PC, "PC:"
01
        RestPSR SB,,f
        Pull    "SB,LR,R0"
 ]
  [ BigShare
   [ BigDir
      ASSERT    SzDiscRec=56
      RSB$cond  $Rptr, $Rindex, $Rindex, ASL #3 ;*7
      ADD$cond  $Rptr, SB, $Rptr, ASL #3         ;7*8=56
   |
        ASSERT  SzDiscRec=48
        ADD$cond $Rptr, $Rindex, $Rindex, ASL #1 ;*3
        ADD$cond $Rptr,SB,$Rptr,ASL #4           ;SB+Rindex*SzDiscRec
   ]
  |
        ASSERT  SzDiscRec=44
   [ $Rptr<>$Rindex
        ADD$cond $Rptr, $Rindex, $Rindex, ASL #1 ;*3
        ADD$cond $Rptr, $Rptr, $Rindex, ASL #3   ;+*8=*11
        ADD$cond $Rptr, SB, $Rptr, ASL #2        ;SB+Rindex*SzDiscRec
   |
        Push    "SB"
        ADD$cond SB, $Rindex, $Rindex, ASL #1    ;*3
        ADD$cond $Rptr, SB, $Rindex, ASL #3      ;+*8=*11
        Pull    "SB"
        ADD$cond $Rptr, SB, $Rptr, ASL #2        ;SB+Rindex*SzDiscRec
   ]
  ]
 |
        ASSERT  SzDiscRec=40
        ADD$cond $Rptr,$Rindex,$Rindex,ASL #2   ;*5
        ADD$cond $Rptr,SB,$Rptr,ASL #3          ;SB+Rindex*SzDiscRec
 ]
        MinOps  ADD, ADD, $Rptr, $Rptr, (:INDEX:DiscRecs), $cond
        MEND


;point Rptr to start of drive record Rindex, must preserve flags
        MACRO
$lab    DrvRecPtr $Rptr,$Rindex,$cond
        ASSERT  $Rptr<>SB
        ASSERT  $Rptr<>PC

 [ DebugDR
        Push    "SB,LR, R0"
        MOV     R0, $Rindex
        SavePSR SB
        BICS    LR, R0, #7
        BEQ     %FT01
        DREG    R0, "DrvRecPtr: illegal disc:"
        DREG    PC, "PC:"
01
        RestPSR SB,,f
        Pull    "SB,LR,R0"
 ]

 [ DynamicMaps
        ASSERT  SzDrvRec=36
        ADD$cond        $Rptr, $Rindex, $Rindex, LSL #3
        ADD$cond        $Rptr, SB, $Rptr, LSL #2
 |

   [ BigDisc
        ASSERT  SzDrvRec=24
        ADD$cond $Rptr,$Rindex,$Rindex,LSL #1
        ADD$cond $Rptr,SB,$Rptr,LSL#3
   |
        ASSERT  SzDrvRec=20
        ADD$cond $Rptr,$Rindex,$Rindex,LSL #2
        ADD$cond $Rptr,SB,$Rptr,LSL#2
   ]
 ]
        MinOps  ADD, ADD, $Rptr, $Rptr, (:INDEX:DrvRecs), $cond
        MEND


        GBLS    CaseConvertReg
        GBLS    CaseConvertType
        MACRO
        Internat_CaseConvertLoad  $UR,$Type
CaseConvertReg SETS    "$UR"
CaseConvertType SETS   "$Type"
        LDR     $UR, $Type.CaseTable
        MEND


        MACRO
        Internat_UpperCase      $Reg, $UR
        ASSERT  $UR = $CaseConvertReg
        ASSERT  CaseConvertType = "Upper"
        CMP     $UR, #BadPtr
        LDRNEB  $Reg, [$UR, $Reg]
        BNE     %FT01
        ASCII_UpperCase $Reg, $UR
        MOV     $UR, #BadPtr ; Restore $UR after use as a temp register
01
        MEND


;FOLLOWING MACROS ONLY FOR DEBUG

        MACRO
        mess    $cond,$text,$newline
      [ "$cond" <> ""
        B$cond  %FT01
        B       %FT02
      ]
01
      [ "$newline"="NL"
        DLINE   $text
      |
        DLINE   $text,cc
      ]
02
        MEND


        MACRO
        regdump $cond
      [ "$cond" <> ""
        B$cond  %FT01
        B       %FT02
      ]
01
        DLINE   " R0       R1       R2       R3       R4       R5       R6       R7"
        DREG    r0, " ",cc
        DREG    r1, " ",cc
        DREG    r2, " ",cc
        DREG    r3, " ",cc
        DREG    r4, " ",cc
        DREG    r5, " ",cc
        DREG    r6, " ",cc
        DREG    r7, " "
        DLINE   " R8       R9       R10      R11      R12      R13"
        DREG    r8, " ",cc
        DREG    r9, " ",cc
        DREG    r11, " ",cc
        DREG    r12, " ",cc
        DREG    r13, " "
02
        MEND

        MACRO
        FileBufs
        Push    "R0-R8"
        mess    ,"Buffer   Flags    Next     Prev     Pri Off  Fcb      Older    Younger",NL
        MOV     R0, R9
00
        LDMIA   R0, {R1-R8}
        EOR     R4, R4, R8, LSL #24
        DREG    R0
        DREG    R1
        DREG    R2
        DREG    R3
        DREG    R4
        DREG    R5
        DREG    R6
        DREG    R7
        DLINE   " "
        MOV     R0, R3
        TSTS    R0, #BadPtrBits
        BNE     %FT01
        TEQS    R0, R9
        BNE     %BT00
01
        Pull    "R0-R8"
        MEND


        MACRO
        DebugError $PrefixStr
        BVC     %FT01
      [ {FALSE} ; Used with internal error numbers all over the place
        Push    "R0"
        LDR     R0, [R0]
        DREG    R0, "$PrefixStr",cc
        LDR     R0, [SP]
        ADD     R0, R0, #4
        DSTRING R0, " = "
        Pull    "R0"
      |
        DREG    R0, "$PrefixStr ="
      ]
01
        MEND


        MACRO
$l      Read3   $cond
$l
      [ NoARMv6 :LOR: NoUnaligned
        BL$cond Read3
      |
        LDR$cond LR, [R0]
        BIC$cond LR, LR, #&FF000000
      ]
        MEND


        MACRO
$l      ReadWord $cond
$l
      [ NoARMv6 :LOR: NoUnaligned
        BL$cond ReadWord
      |
        LDR$cond LR, [R0]
      ]
        MEND


        MACRO
$l      Write3  $cond
$l
      [ NoARMv6 :LOR: NoUnaligned
        BL$cond Write3
      |
        STR$cond.H R1, [R0]
        MOV$cond   R1, R1, ROR #16 ; note that this corrupts R1, unlike the BL
        STR$cond.B R1, [R0, #2]
      ]
        MEND


        MACRO
$l      WriteWord $cond
$l
      [ NoARMv6 :LOR: NoUnaligned
        BL$cond WriteWord
      |
        STR$cond R1,[R0]
      ]
        MEND


        END
@


4.9
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d226 4
@


4.8
log
@Swap out some more constants for symbolic names
* OsBytes
* Application start &8000
* Fixed disc density
* Unused a4 macro deleted
* Redundant 'todo', 'Help, 'Syntax' removed

Version 3.53. Not tagged
@
text
@a119 9
        MACRO
        Align16 $base
        ASSERT  (.-$base) :MOD: 4 = 0
        WHILE   (.-$base) :MOD: 16 <> 0
        MOVNV   R0,R0
        WEND
        MEND


d302 1
d310 3
@


4.7
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@a108 7
$lab    a4      $size           ;allocate word aligned
        ASSERT  (:INDEX: {VAR}) :MOD: 4=0
$lab    #       $size
        MEND


        MACRO
@


4.6
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d136 109
a327 18
Nowt    *       &40000000

        GBLS    CaseConvertReg
        GBLS    CaseConvertType
        MACRO
        Internat_CaseConvertLoad  $UR,$Type
CaseConvertReg SETS    "$UR"
CaseConvertType SETS   "$Type"
        LDR     $UR, $Type.CaseTable
        MEND

        MACRO
        Internat_UpperCase      $Reg, $UR
        ASSERT  $UR = $CaseConvertReg
        ASSERT  CaseConvertType = "Upper"
        TEQ     $UR, #Nowt
        LDRNEB  $Reg, [$UR, $Reg]
        MEND
d340 1
d351 1
d364 1
d375 1
@


4.5
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d19 1
a19 1
$lab    Entry   $action,$pre
d47 1
a47 1
First   SETL    T
d71 1
a71 1
First   SETL    F
d139 12
a150 95
        mess    $cond,$s1,$s2,$s3,$s4,$s5
 [ {TRUE}
        B$cond  %F11
        BAL     %F21
11
        Push    "R0,R1,LR"
        BL      Mess1
        [ (:LNOT: IrqDebug) :LOR: DebugSwitch
        BNE     %FT15           ;skip if IRQ thread or debugging switched off
        ]
        SWI     OS_WriteS
 [ "$s1"="NL"
 = CR,LF
 |
 = "$s1"
 ]
 [ "$s2"=""
 |
  [ "$s2"="NL"
  = CR,LF
  |
  = "$s2"
  ]
  [ "$s3"=""
  |
   [ "$s3"="NL"
   = CR,LF
   |
   = "$s3"
   ]
   [ "$s4"=""
   |
    [ "$s4"="NL"
    = CR,LF
    |
    = "$s4"
    ]
    [ "$s5"=""
    |
     [ "$s5"="NL"
     = CR,LF
     |
     = "$s5"
     ]
    ]
   ]
  ]
 ]
        =       0
        ALIGN
        [ SpoolOff
        BL      SpoolOn
        ]
        Pull    "LR"
15
        RestPSR R0              ;restore PSR
        NOP                     ;delay in case mode change
        Pull    "R0,R1,LR"
21
 ]
        MEND

        MACRO
        wrhex   $reg,$cond
        Push    "R0-R4,LR",$cond
        MOV$cond R2,$reg
        BL$cond PHEX
        Pull    "R0-R4,LR",$cond
        MEND


        MACRO
        Tword   $reg,$cond
        Push    "R0-R4,LR",$cond
        MOV$cond R2,$reg
        BL$cond TubeWrHexWord
        Pull    "R0-R4,LR",$cond
        MEND


        MACRO
$l      SetBorder  $red,$green,$blue,$cond
$l      Push       "R0,R1",$cond
        LDR$cond   R0,=VIDC
        LDR$cond   R1,=&40000000+ $red + $green *16 + $blue *256
        STR$cond   R1,[R0]
        Pull       "R0,R1",$cond
        MEND


        MACRO
$l      Border  $red,$green,$blue,$cond
$l      LDR$cond   R0,=VIDC
        LDR$cond   R1,=&40000000+ $red + $green *16 + $blue *256
        STR$cond   R1,[R0]
d156 1
a156 1
 [ "$cond" <> ""
d159 1
a159 1
 ]
d187 9
a195 9
        wrhex   R0
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        wrhex   R7
        mess    ,NL
d205 1
a205 1
 [ Dev
a217 1
 ]
@


4.4
log
@  Various archiecture-based optimisations
Detail:
  * ARMv6+ builds use unaligned halfword and word loads and stores (unless
    pre-ARMv6 compatibility is required or NoUnaligned is set)
  * In many cases, one unnecessary BIC instruction has been removed from
    pre-ARMv6 builds
  * ARMv5+ builds (so Tungsten and OMAP) make use of CLZ instruction when
    parsing fragment blocks
Admin:
  Built and included in an OMAP3 ROM. But be warned, this has not received
  the rigorous testing normally required of filesystem code, use at your
  own risk.

Version 3.33. Tagged as 'FileCore-3_33'
@
text
@a16 11
        MACRO
$lab    retfiq   $cc
$lab    SUB$cc.S PC, LR, #4
        MEND


        MACRO
        nop
        MOV     R0,R0
        MEND

a101 7
$l      Text    $str
$l      =       "$str",0
        ALIGN
        MEND


        MACRO
d195 1
a195 1
        nop                     ;delay in case mode change
@


4.3
log
@* Various 32-bit compatibility fixes.
* Can use HAL for FIQ+timer manipulations.
* FileCore_DiscOp64 added (as user API - currently just converted to the
  standard byte or sector DiscOp call to the underlying module). See
  Doc.32bitAPIs for full details.
* New error-passing scheme to modules added (for full 32-bit addressing).
* FileCore_Features added (indicates new error scheme).
* OS_FSControl 49 (read 32-bit free space) now reports sensible clamped
  values for large discs, rather than values modulo 2^32.
* Accessing the end of files near 2GB in size could cause lock-ups in
  background transfers.
* F(+) and G(+) disc formats adjusted to have a little more skew to
  help the rather poor Iyonix floppy controller.

Version 3.31. Tagged as 'FileCore-3_31'
@
text
@d340 43
@


4.2
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d212 1
a212 1
        TEQP    PC, R0          ;restore PSR
@


4.1
log
@Initial revision
@
text
@a16 22
        MACRO                           ;set some PSR bits
$lab    setpsr     $bits,$tempreg,$cond
$lab    MOV$cond   $tempreg,#$bits
        ORR$cond   $tempreg,$tempreg,PC
        TEQ$cond.P PC,$tempreg
        MEND


        MACRO                           ;clear some PSR bits
$lab    clrpsr     $bits,$tempreg,$cond
$lab    MVN$cond   $tempreg,#$bits
        TST$cond.P $tempreg,PC
        MEND


        MACRO                           ;toggle some PSR bits
$lab    togpsr     $bits,$tempreg,$cond
$lab    MOV$cond   $tempreg,#$bits
        TEQ$cond.P $tempreg,PC
        MEND


d25 1
a25 1
        MOVNV   R0,R0
d110 1
a110 1
       
d201 1
a201 1
    ] 
d221 1
a221 1
        Push    "R0-R3,LR",$cond
d224 1
a224 1
        Pull    "R0-R3,LR",$cond
d230 1
a230 1
        Push    "R0-R3,LR",$cond
d233 1
a233 1
        Pull    "R0-R3,LR",$cond
d298 1
a298 1
        TSTS    R0, #ARM_CC_Mask
a310 1
        BIC     R0, R0, #ARM_CC_Mask
a313 1
        BIC     R0, R0, #ARM_CC_Mask
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

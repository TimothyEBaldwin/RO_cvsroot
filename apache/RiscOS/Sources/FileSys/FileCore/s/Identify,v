head	4.15;
access;
symbols
	FileCore-3_75:4.15
	FileCore-3_74:4.14
	FileCore-3_73:4.13
	FileCore-3_72:4.13
	FileCore-3_71:4.13
	FileCore-3_70:4.13
	FileCore-3_69:4.13
	FileCore-3_68:4.12
	FileCore-3_67:4.12
	FileCore-3_66:4.12
	FileCore-3_65:4.12
	FileCore-3_64:4.12
	FileCore-3_63:4.12
	FileCore-3_62:4.11
	FileCore-3_61:4.10
	FileCore-3_60:4.10
	FileCore-3_59:4.10
	FileCore-3_58:4.10
	FileCore-3_57:4.10
	FileCore-3_56:4.10
	FileCore-3_55:4.10
	FileCore-3_54:4.9
	FileCore-3_53:4.9
	FileCore-3_52:4.9
	FileCore-3_51:4.9
	FileCore-3_50:4.9
	FileCore-3_49:4.8
	FileCore-3_48:4.8
	FileCore-3_47:4.8
	FileCore-3_46:4.8
	FileCore-3_45:4.7
	FileCore-3_44:4.6
	FileCore-3_43:4.5
	FileCore-3_42:4.5
	FileCore-3_41:4.4
	FileCore-3_40:4.4
	FileCore-3_39:4.4
	FileCore-3_38:4.4
	FileCore-3_37:4.4
	FileCore-3_36:4.4
	FileCore-3_35:4.4
	FileCore-3_34:4.4
	FileCore-3_33:4.4
	RO_5_07:4.4
	FileCore-3_32:4.4
	FileCore-3_31:4.4
	FileCore-3_30:4.3
	FileCore-3_29:4.3
	FileCore-3_28:4.3
	FileCore-3_25-4_9_2_2:4.3
	FileCore-3_27:4.3
	FileCore-3_26:4.3
	FileCore-3_22-4_6_2_1:4.2
	bavison_FileCore-3_22_dev_bp:4.2
	bavison_FileCore-3_22:4.2.0.2
	FileCore-3_25-4_9_2_1:4.3
	HAL:4.3.0.2
	FileCore-3_25:4.3
	FileCore-3_24:4.3
	FileCore-3_23:4.3
	dellis_autobuild_BaseSW:4.2
	FileCore-3_22:4.2
	Ursula_merge:4.1.4.8
	ROL_merge:4.1.4.8
	FileCore-3_21:4.2
	ROL_Ursula_merge:4.1.4.8
	Ursula_RiscPC_merge:4.1.4.8
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.3
	ROL_FileCore-3_21:4.1.4.8
	ROL_FileCore-3_20:4.1.4.8
	ROL:4.1.4.8.0.4
	ROL_bp:4.1.4.8
	Ursula_RiscPC_bp:4.1.4.8
	FileCore-3_18:4.1.4.8
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.8
	Ursula_RiscPC:4.1.4.8.0.2
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1.4.8
	sproven_FileCore-3_16:4.1.4.8
	rthornb_UrsulaBuild-19Aug1998:4.1.4.8
	UrsulaBuild_FinalSoftload:4.1.4.8
	rthornb_UrsulaBuild-12Aug1998:4.1.4.8
	aglover_UrsulaBuild-05Aug1998:4.1.4.8
	rthornb_UrsulaBuild-29Jul1998:4.1.4.8
	rthornb_UrsulaBuild-22Jul1998:4.1.4.8
	rthornb_UrsulaBuild-15Jul1998:4.1.4.8
	rthornb_UrsulaBuild-07Jul1998:4.1.4.8
	rthornb_UrsulaBuild-17Jun1998:4.1.4.8
	rthornb_UrsulaBuild-03Jun1998:4.1.4.8
	rthornb_UrsulaBuild-27May1998:4.1.4.8
	rthornb_UrsulaBuild-21May1998:4.1.4.8
	sproven_FileCore-3_15:4.1.4.8
	sproven_314:4.1.4.7
	rthornb_UrsulaBuild_01May1998:4.1.4.6
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.6
	sproven_3_11:4.1.4.6
	sproven_3_10:4.1.4.6
	sproven_Ursula_3_09:4.1.4.6
	sproven_3_07:4.1.4.5
	sproven_3_06:4.1.4.4
	sproven_3_05:4.1.4.3
	sproven_3_04:4.1.4.3
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.3
	sproven_3_02:4.1.4.3
	sproven_3_01:4.1.4.2
	sproven_2_99:4.1.4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2017.07.06.14.36.57;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	glaSUStjQCVZ3bYz;

4.14
date	2017.06.16.11.00.36;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	izYr8Uu33U8FvAVz;

4.13
date	2016.05.08.16.55.18;	author jlee;	state Exp;
branches;
next	4.12;
commitid	7NNp0vqkWUkusH5z;

4.12
date	2013.07.20.14.10.03;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	qZtNVkGjzh5uqdYw;

4.11
date	2013.07.18.21.04.17;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	Em91CJgLrlPBMZXw;

4.10
date	2013.02.21.16.53.09;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	CCuV2tngKttj75Fw;

4.9
date	2012.04.14.00.43.17;	author bavison;	state Exp;
branches;
next	4.8;
commitid	xkSKw5i9HVYqOL0w;

4.8
date	2011.11.25.08.26.06;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	IoNdwgrOKH29UGIv;

4.7
date	2011.10.14.07.23.52;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	D2Id4aPp4zmuUhDv;

4.6
date	2011.10.12.20.21.50;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	BoinxgqWMKLth6Dv;

4.5
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	A9Zxco9ydo9FCOBv;

4.4
date	2003.04.03.18.33.29;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.10.30.13.26.35;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.09.11.37.01;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.24;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.24;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.41.05;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.08.14.13.13.20;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.09.16.14.46.51;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.11.17.13.32.43;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.01.19.12.26.44;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.01.23.16.41.30;	author sproven;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.02.11.16.49.30;	author sproven;	state Exp;
branches;
next	4.1.4.7;

4.1.4.7
date	98.05.07.16.58.16;	author sproven;	state Exp;
branches;
next	4.1.4.8;

4.1.4.8
date	98.05.08.12.33.07;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.24;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.16;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.15
log
@Increase upper range of idlen to 21 bits
When 'BigMap' support was added drive sizes were such that (see table and discussion in Doc/BigDisc/BigDiscs) an upper maximum of 19 bits for idlen was appropriate. Now that drives of 2^29 sectors are readily available (the limit of 'BigDisc' support) the idlen limit of 19 has meant the minimum object size has grown too. This change uses the remaining 2 indirect disc address bits to get a factor x4 reduction in minimum object size, at the expense of a 4x larger map.

Defns.s: Parameterise idlen for big and small maps. Small's limit remains 15, big's limit raised from 19 to 21.
Identify.s: When mounting, use the parameterised idlen upper limits to decide whether it's a valid disc or not.
FileCore32.s: Adjust the BIC masks to knock out the extra 2 bits when forming the hash of the object id. Fix long standing bug updating the wrong entry in the hash table (due to LSL #2 giving 5x the entry index, rather than 3x).
FileCore15.s: Take care not to shift b20 of idlen into C as a side effect of a flags changing opcode. An audit of FileCore showed this to be the only site where the subsequent condition code(s) depended on C.
Tools/basic/DispMap: Updated to support BigMaps at all, previously it only worked with NewMap discs.

Tested with an assortment of drives with FSBash for 300k cycles of scrambling for idlen = 17, 19, 20 & 21.

Version 3.75. Tagged as 'FileCore-3_75'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >Identify

        TTL     "Identifying FileCore discs"

; change log:

; 15 May 1997: SBP: Changed SanityCheckEDiscRecord to support idlen up to 16.


; ============
; IdentifyDisc (r0,r5->r0,r6)
; ============
;
; Attempt to identify the specified disc
;
;entry
;  r0 = drive number of drive which disc to be identified is in
;  r5 -> disc record of disc to be identified
;
; exit
;  r0 = FileType of disc image (FileType_Data if service call failed)
;  r6 = readsectors cache
;  V not possible
;
IdentifyDisc ROUT
        Push    "r1,r2,r3,r8,r9,lr"

 [ DebugL
        DREG    R0, "Identifying drive ",cc
        DREG    R5, " on record at "
 ]

        ; Ensure an empty read sectors cache
        MOV     r6, #0

        ; If LastDiscOpWasFormat then disc must be a data disc
        DrvRecPtr lr, r0
        LDRB    lr, [lr, #DrvFlags]
        TST     lr, #LastDiscOpWasFormat
        MOVNE   r1, #Service_IdentifyDisc
        BNE     %FT50

        LDR     r9, [r5, #DiscRecord_Root]
        AND     r9, r9, #DiscBits

 [ DebugL
        DREG    r9, "Rootdir internally starts as: "
 ]

        ; Generate an initial root dir address
        MOV     r1, r0, ASL #(32-3)
        EOR     r1, r1, #bit31          ; Convert to external numbering
 [ DebugL
        DREG    r1, "Setting initial root dir address to: "
 ]
        STR     r1, [r5, #DiscRecord_Root]

        MOV     r1, #Service_IdentifyDisc
        MOV     r2, #0                  ; buffer
        MOV     r3, #0                  ; buffer size
        LDR     r8, PrivateWord

        BL      DoXOS_ServiceCall

        ; Fake unserviced service on VS result
        MOVVS   r1, #Service_IdentifyDisc
        CLRV

        LDR     lr, [r5, #DiscRecord_Root]
        BIC     lr, lr, #DiscBits
        ORR     lr, lr, r9
        STR     lr, [r5, #DiscRecord_Root]

 [ DebugL
        DREG    lr, "Restoring internal disc numbering of RootDir: "
 ]

50
        ; If not serviced then disc is just so much random data!
        TEQ     r1, #Service_Serviced
        ; Clear out DiscId and DiscName if mapping to FileType_Data
        MOVNE   r0, #0
        ASSERT  DiscRecord_DiscId :MOD: 4 = 0
        ASSERT  DiscRecord_DiscName = DiscRecord_DiscId+2
        STRNE   r0, [r5, #DiscRecord_DiscId]
        LDRNE   r0, =FileType_Data
        MOVEQ   r0, r2

 [ DebugL
        DREG    R0, "Disc identified as type "
 ]

95
        Pull    "r1,r2,r3,r8,r9,pc"

        LTORG

; ====================
; IdentifyFileCoreDisc
; ====================
;
;entry
;  R1 = Service_IdentifyDisc (&69)
;  r2 = pointer to buffer for text
;  r3 = length of buffer
;  R5 = Pointer to disc record
;  R6 = Sector cache handle
;  R8 = Pointer to FileCore instance private word to use
;
;exit
;If the format has been identified:
;  R1 = Service_Serviced
;  R2 = Filetype number for given disc format.
;  R5 = Pointer to disc record, which has been modified
;  R6 = New sector cache handle
;  R8 unchanged
;Otherwise:
;  R1 = Service_IdentifyDisc
;  R5 = Pointer to disc record, which may have been modified
;  R6 = New sector cache handle
;  R8 unchanged

IdentifyFileCoreDisc ROUT
        Push    "lr"
 [ DebugL
        DLINE   "Identifying a disc"
        DREG    R0, "Rin:",cc
        DREG    R1, ",",cc
        DREG    R2, ",",cc
        DREG    R3, ",",cc
        DREG    R4, ",",cc
        DREG    R5, ",",cc
        DREG    R6, ",",cc
        DREG    R7, ",",cc
        DREG    R8, ",",cc
        DREG    R9, ",",cc
        DREG    R10, ",",cc
        DREG    R11, ",",cc
        MOV     R12, R13
        DREG    R12, ","
 ]
        MOV     r12, r8
 [ DebugL
        DREG    r8, "r8 in is "
        DREG    r12, "Meaning ws is "
        Push    "r0"
        LDRB    r0, ReEntrance
        DREG    r0, "ReEntrance into service call servicing:"
        Pull    "r0"
 ]
        BL      IdentifyFileCoreFloppyDisc
        TEQ     r1, #Service_Serviced
        BLNE    IdentifyFileCoreHardDisc
 [ DebugL
        Push    "r0"
        LDRB    r0, ReEntrance
        DREG    r0, "ReEntrance out of service call servicing:"
        Pull    "r0"
        TEQ     r1, #Service_Serviced
        BNE     %FT01
        DREG    r2, "Service claimed - disc type is "
01
        DREG    R0, "Rot:",cc
        DREG    R1, ",",cc
        DREG    R2, ",",cc
        DREG    R3, ",",cc
        DREG    R4, ",",cc
        DREG    R5, ",",cc
        DREG    R6, ",",cc
        DREG    R7, ",",cc
        DREG    R8, ",",cc
        DREG    R9, ",",cc
        DREG    R10, ",",cc
        DREG    R11, ",",cc
        MOV     R12,R13
        DREG    R12, ","
 ]
        Pull    "pc"

        LTORG

; ==========================
; IdentifyFileCoreFloppyDisc
; ==========================
;entry
;  r1 = Service_IdentifyDisc (&69)
;  r5 = Pointer to disc record
;  r6 = Sector cache handle
;  r8 = Pointer to FileCore instance private word to use
;  r12 = Pointer to FileCore instance private word to use
;
;exit
;If the format has been identified:
;  r1 = Service_Serviced
;  r2 = Filetype number for given disc format.
;  r5 = Pointer to disc record, which has been modified
;  r6 = New sector cache handle
;  r8 unchanged
;  r12 unchanged
;Otherwise:
;  r1 = Service_IdentifyDisc
;  r5 = Pointer to disc record, which may have been modified
;  r6 = New sector cache handle
;  r8 unchanged
;  r12 unchanged

IdentifyFileCoreFloppyDisc ROUT
        Push    "r0,r1,r2,r3,r8,r12,lr"

 [ DebugL
        DLINE   "Identifying a floppy disc"
 ]

        ; Don't even try to identify hard discs as floppy discs.
        LDR     lr, [r5, #DiscRecord_Root]
        TST     lr, #bit31
        BNE     %FT95

        ; Sector numbers must start at 0 on a track
        LDRB    r0, [r5, #DiscRecord_LowSector]
        ASSERT  DiscRecord_LowSector_Shift = 0
        AND     lr, r0, #DiscRecord_LowSector_Mask
        TEQ     lr, #0
 [ DebugL
        BEQ     %FT01
        DLINE   "Failed on sector numbering"
01
 ]
        BNE     %FT95

        ; Must be two heads in reality, and turn off side sequencing and double stepping
        LDRB    r0, [r5, #DiscRecord_LowSector]
        BIC     r0, r0, #DiscRecord_DoubleStep_Flag
        STRB    r0, [r5, #DiscRecord_LowSector]
        BL      EnsureInterleavedSides

        ; Ensure 1(RAMFs) or 2(Others) heads on floppies
        TEQ     r0, #1
        TEQNE   r0, #2
 [ DebugL
        DREG    r0,"Heads="
        BEQ     %FT01
        DLINE   "Failed on number of heads"
01
 ]
        BNE     %FT95

        Push    "R3"
        ; Check if it sanity checks as an E format floppy disc
 [ BigDisc
        MOV     r2, #0  ; sector zero
        MOV     r3, #4  ; byte offset 4
 |
        MOV     r2, #4  ; byte disc address 4
 ]
        BL      SanityCheckEFormat
        Pull    "R3"
        BVS     %FT20

 [ DebugL
        DLINE   "It must be E format!"
 ]

        LDR     r2, [sp, #2*4]
 [ BigDir
        LDR     lr, [r5, #DiscRecord_BigDir_DiscVersion]   ; check if it's EX or FX
        TEQ     lr, #0
        BEQ     %FT15

        LDRB    lr, [r5, #DiscRecord_Density]

        TEQ     lr, #DensityQuad
        baddr   r1, EXFormat_DescribeTag, NE
        baddr   r1, FXFormat_DescribeTag, EQ
        BL      CopyFormatName

        B       %FT85

15
 ]

        LDRB    lr, [r5, #DiscRecord_Density]

        TEQ     lr, #DensityQuad
        baddr   r1, EFormat_DescribeTag, NE
        baddr   r1, FFormat_DescribeTag, EQ
        BL      CopyFormatName

        B       %FT85

20
        ; Turn side sequencing on for FileCore L format floppies
        BL      EnsureSequencedSides

        ; Side sequencing only works with a correct disc size...
        ADD     r0, r0, #1              ; Number of platters
        LDRB    r1, [r5, #DiscRecord_Log2SectorSize]
        MOV     r0, r0, ASL r1          ; Size of a cylinder-sector
        LDRB    r1, [r5, #DiscRecord_SecsPerTrk]
        MUL     r0, r1, r0              ; Size of a cylinder
        MOV     r0, r0, ASL #4          ; *16
        ADD     r0, r0, r0, ASL #2      ; *5   =*80
        STR     r0, [r5, #DiscRecord_DiscSize]
 [ BigDisc
        MOV     r0, #0
        STR     r0, [r5, #DiscRecord_BigMap_DiscSize2]
   [ BigShare
        STR     r0, [r5, #DiscRecord_BigMap_ShareSize]    ; sharing unit always 0 for floppies
   ]
 ]

        ; Check for L format (much more strict about what's OK)
        BL      SanityCheckLFormat
        BVS     %FT30
 [ BigDisc
        LDR     r0, [r5, #DiscRecord_BigMap_DiscSize2]
        MOVS    r0, r0
        BNE     %FT30                           ; can't be L format - far too big!
 ]
        LDR     r0, [r5, #DiscRecord_DiscSize]
        LDR     lr, =L_Size + 4*32*256          ; Allow up to 4 extra tracks worth - beyond that and a frigged format won't work
        CMP     r0, lr

        LDRLS   r2, [sp, #2*4]
        baddr   r1, LFormat_DescribeTag, LS
        BLLS    CopyFormatName

        BLS     %FT85

30
        ; Turn side interleaving on for checking FileCore D format floppies
        BL      EnsureInterleavedSides

        ; Check for D (old map) format disc
        BL      SanityCheckDFormat
        BVS     %FT85
 [ BigDisc
        LDR     r0, [r5, #DiscRecord_BigMap_DiscSize2]
        MOVS    r0, r0
        BNE     %FT75                           ; too big
 ]
        LDR     r0, [r5, #DiscRecord_DiscSize]
        LDR     lr, =D_Size + 4*10*1024         ; Allow up to 4 extra tracks worth - beyond that and a frigged format won't work
        CMP     r0, lr

        LDRLS   r2, [sp, #2*4]
        baddr   r1, DFormat_DescribeTag, LS
        BLLS    CopyFormatName

75
        SETV    HI

85
        BVS     %FT95
 [ DebugL
        DLINE   "Its a floppy!"
 ]
        LDR     r2, =FileType_FileCoreFloppyDisc
        STR     r2, [sp, #2*4]          ; Returned disc type
        MOV     r0, #Service_Serviced
        STR     r0, [sp, #1*4]

95
 [ DebugL
        BVC     %FT01
        DLINE   "Failed to check FileCore floppy disc"
01
 ]
        CLRV
        Pull    "r0,r1,r2,r3,r8,r12,pc"

        LTORG

; ========================
; IdentifyFileCoreHardDisc
; ========================
;entry
;  r1 = Service_IdentifyDisc (&69)
;  r5 = Pointer to disc record
;  r6 = Sector cache handle
;  r8 = Pointer to FileCore instance private word to use
;  r12 = Pointer to FileCore instance private word to use
;
;exit
;If the format has been identified:
;  r1 = Service_Serviced
;  r2 = Filetype number for given disc format.
;  r5 = Pointer to disc record, which has been modified
;  r6 = New sector cache handle
;  r8 unchanged
;  r12 unchanged
;Otherwise:
;  r1 = Service_IdentifyDisc
;  r5 = Pointer to disc record, which may have been modified
;  r6 = New sector cache handle
;  r8 unchanged
;  r12 unchanged

IdentifyFileCoreHardDisc ROUT
        Push    "r0,r2,r3,r4,r5,r7-r12,lr"
 [ DebugL
        DLINE   "Identifying a hard disc"
 ]

        ; Convert disc record to non-sequenced sides
        BL      EnsureInterleavedSides

        BL      SanityCheckBadBlockList
        BVS     %FT90
 [ BigDisc
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]            ; for conversion from byte to sector
        MOV     r3, #DefectListDiscAdd          ; disc addr of boot block...
        MOV     r2, r3, LSR lr                  ; ...in sector form
        SUB     r3, r3, r2, LSL lr              ;
        ADD     r3, r3, #DefectStruc            ; offset of disc record
 |
        LDR     r2, =DefectListDiscAdd + DefectStruc
 ]
        BL      SanityCheckEFormat
        LDRVC   r2, [sp, #1*4]
 [ BigDir
        BVS     %FT01
        LDR     lr, [r5, #DiscRecord_BigDir_DiscVersion]
        TEQS    lr, #0
        baddr   r1, FFormat_DescribeTag, EQ
        baddr   r1, FXFormat_DescribeTag, NE
01
 |
        baddr   r1, FFormat_DescribeTag, VC
 ]
        BLVC    CopyFormatName
        LDRVC   r2, =FileType_FileCoreHardDisc
        BVC     %FT90
        BL      SanityCheckDFormat
        LDRVC   r2, [sp, #1*4]
        baddr   r1, DFormat_DescribeTag, VC
        BLVC    CopyFormatName
        LDRVC   r2, =FileType_FileCoreHardDisc
90
 [ DebugL
        BVC     %FT01
        DLINE   "Failed to check FileCore hard disc"
        B       %FT02
01
        DLINE   "It's a hard disc!"
02
 ]
        STRVC   r2, [sp, #1*4]
        MOVVC   r1, #Service_Serviced
        CLRV
        Pull    "r0,r2,r3,r4,r5,r7-r12,pc"

        LTORG

; ==============
; CopyFormatName
; ==============
;
; entry
;  r1 = pointer to tag
;  r2 = buffer (0 if no buffer)
;  r3 = buffer length
;
; exit
;  flags etc preserved
CopyFormatName ROUT
        Push    "r0-r8,lr"
        SavePSR r8
        TEQ     r2, #0
        BEQ     %FT95

        SUB     sp, sp, #16
        MOV     r0, sp
        ADRL    r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        BVS     %FT90

        MOV     r0, sp
        ADD     lr, sp, #16+1*4
        LDMIA   lr, {r1-r3}
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup

        MOV     r0, sp
        SWI     XMessageTrans_CloseFile

90
        ADD     sp, sp, #16
95
        RestPSR r8,,f
        Pull    "r0-r8,pc"

; =======================
; SanityCheckBadBlockList
; =======================
;
; entry
;  r5 = pointer to disc record
;  r6 = sector cache handle
;  r12 = Pointer to FileCore instance private word to use
;
; exit
;  r6 = new sector cache handle
;  r12 = Unchanged
;  VC if OK
;  VS if bad
;
SanityCheckBadBlockList ROUT
 [ {TRUE}
        CLRV
        MOV     pc,lr
 |
        Push    "r0-r4,r5,r7-r12,lr"
        SUB     sp, sp, #SzDefectList

 [ DebugL
        DLINE   "Sanity checking bad block list"
 ]

 [ BigDisc :LAND: {FALSE}
        LDR     r2, [r5, #DiscRecord_Root]              ; to get drive number
        AND     r2, r2, #DiscBits
        MOV     r3, #DefectListDiscAdd          ; disc addr of defect list
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        ORR     r2, r2, r3, LSR lr              ; actual disc addr to read from
        MOV     r4, r3, LSR lr                  ; sector align disc addr
        SUB     r3, r3, r4, LSL lr              ; extra transfer needed
        ADD     r4, r3, #SzDefectList           ; amount to transfer
        SUB     sp, sp, r3                      ; transfer addr
        Push    "R3"
        MOV     r3, sp
        BL      SWI_SectorDiscOp_CachedReadSectors_Myself
        Pull    "R3"
        ADD     sp, sp, r3
 |
        LDR     r2, [r5, #DiscRecord_Root]
        AND     r2, r2, #DiscBits
        ORR     r2, r2, #DefectListDiscAdd
        MOV     r3, sp
        MOV     r4, #SzDefectList
        BL      SWI_DiscOp_CachedReadSectors_Myself
 ]
 [ DebugL
        BVC     %FT01
        ADD     r1, r0, #4
        DSTRING r1, "Failed on reading:"
01
 ]
        BVS     %FT90

        MOV     r0, sp
        MOV     r1, #SzDefectList
        BL      CheckSum
 [ DebugL
        BVC     %FT01
        DLINE   "Failed on check sum"
01
 ]

90
 [ DebugL
        BVC     %FT01
        DLINE   "Failed to check bad block list"
01
 ]
        ADD     sp, sp, #SzDefectList
        Pull    "r0-r4,r7-r12,pc"
 ]

        LTORG

; ==================
; SanityCheckEFormat
; ==================
;
; entry
 [ BigDisc
;  r2 = disc address of sector containing boot record
;  r3 = offset within sector of boot record (word aligned)
 |
;  r2 = disc address of boot record (without disc number)
 ]
;  r5 = pointer to disc record
;  r6 = sector cache handle
;  r12 = Pointer to FileCore instance private word to use
;
; exit
;   r6 = new sector cache handle
;   r12 = unchanged
;  AND
;   VC: Matches OK
;   VS: Mismatch and r0 does _not_ point to an error
;
SanityCheckEFormat ROUT
        Push    "lr"

 [ DebugL
        DLINE   "Sanity checking E format"
   [ BigDisc
        DREG    r2, "Boot record sector="
        DREG    r3, "Boot record offset="
   ]
 ]

        ; Sanity check disc record vs disc
        BL      SanityCheckEDiscRecord

        ; Read and check map from disc
        BLVC    SanityCheckNewMap

95
 [ DebugL
        BVC     %FT01
        DLINE   "Failed to check E format"
        B       %FT02
01
        DLINE   "E format is the business!"
02
 ]
        Pull    "pc"

        LTORG

; ======================
; SanityCheckEDiscRecord
; ======================
;
; entry
 [ BigDisc
;  r2 = disc address of sector containing boot record
;  r3 = offset within sector of boot record (word aligned)
 |
;  r2 = disc address of boot record (without disc number)
 ]
;  r5 = pointer to disc record
;  r6 = sector cache handle
;  r12 = Pointer to FileCore instance private word to use
;
; exit
;   r6 = new sector cache handle
;   r12 = unchanged
;  AND
;   VC: Matches OK
;   VS: Mismatch and r0 does _not_ point to an error
;
SanityCheckEDiscRecord ROUT
        Push    "r0,r1,r2,r3,r4,r5,r7,r8,r9,r10,r11,r12,lr"
 [ BigDisc
        SUB     sp, sp, #SzDiscRecSig2
        SUB     sp, sp, r3              ; adjust for disc record offset
 |
        SUB     sp, sp, #SzDiscRecSig
 ]

 [ DebugL
        DLINE   "Sanity checking E disc record"
        DREG    r2, "Disc addr ="
        DREG    r3, "Offset ="
        DREG    sp, "SP ="
 ]

        MOV     r1, #DiscOp_CachedReadSecs
        LDR     r14, [r5, #DiscRecord_Root]
        AND     r14, r14, #DiscBits
        ORR     r2, r2, r14

 [ BigDisc
        MOV     r4, #SzDiscRecSig2      ; length we want
        ADD     r4, r4, r3              ; actual transfer length to compensate for offset
        Push    "R3"
        ADD     r3, sp, #4
        BL      SWI_SectorDiscOp_CachedReadSectors_Myself
        Pull    "R3"
        ADD     sp, sp, r3      ; pointer to disc record actual data
 |
        MOV     r3, sp
        MOV     r4, #SzDiscRecSig
        BL      SWI_DiscOp_CachedReadSectors_Myself
 ]

 [ DebugL
        BVC     %FT01
        ADD     r1, r0, #4
        DSTRING r1, "Failed on reading"
01
 ]
        BVS     %FT90

        ; Sanity check disc record vs disc

        ; Check sectorsize, secpertrk, heads and density all match the real values
        ASSERT  DiscRecord_Log2SectorSize :MOD: 4 = 0
        ASSERT  DiscRecord_SecsPerTrk = DiscRecord_Log2SectorSize+1
        ASSERT  DiscRecord_Heads = DiscRecord_SecsPerTrk+1
        ASSERT  DiscRecord_Density = DiscRecord_Heads+1
        LDR     r0, [r5, #DiscRecord_Log2SectorSize]
        LDR     r1, [sp, #DiscRecord_Log2SectorSize]

        ; On floppy discs ignore SecsPerTrk to robustify against copy-protection schemes
        LDR     lr, [r5, #DiscRecord_Root]
        TST     lr, #bit31
        EOR     lr, r0, r1
        BICNE   lr, lr, #&0000ff00
        TEQ     lr, #0

 [ DebugL
        BEQ     %FT01
        DREG    r0,"Failed on mismatched sector sizes etc: Rec=",cc
        DREG    r1, " boot="
01
 ]
        BNE     %FT85

 [ BigMaps
        ; Check idlen <= MaxIdLenBigMap
        LDRB    r0, [sp, #DiscRecord_IdLen]
        CMP     r0, #MaxIdLenBigMap

 [ DebugL
        BLS     %FT01
        DLINE   "Failed on idlen valid for big map"
01
 ]

 |
        ; Check idlen <= MaxIdLenSmlMap
        LDRB    r0, [sp, #DiscRecord_IdLen]
        CMP     r0, #MaxIdLenSmlMap
 [ DebugL
        BLS     %FT01
        DLINE   "Failed on idlen valid for small map"
01
 ]

 ]
        BHI     %FT85
        CMP     r0, #0
 [ DebugL
        BNE     %FT01
        DLINE   "Failed on idlen = 0"
01
 ]
        BEQ     %FT85

        ; Check sufficient link bits for max number of fragments
        LDRB    r0, [sp, #DiscRecord_Log2SectorSize]
        MOV     r1, #8                  ; 8 bits per byte
        MOV     r1, r1, ASL r0          ; bits per sector
        ASSERT  DiscRecord_ZoneSpare :MOD: 4 = 2
        LDR     r0, [sp, #DiscRecord_ZoneSpare - 2]
        SUB     r1, r1, r0, LSR #16     ; map bits per sector
        LDRB    r0, [sp, #DiscRecord_IdLen]
        ADD     r0, r0, #1
        DivRem  r2, r1, r0, lr, norem   ; r2 = max objects per zone
 [ BigMaps
        LDRB    r0, [sp, #DiscRecord_NZones]
        LDRB    r1, [sp, #DiscRecord_BigMap_NZones2]    ; r1 is the target for the MUL below
        ADD     r0, r0, r1, LSL #8
 |
        LDRB    r0, [sp, #DiscRecord_NZones]
 ]
 [ DebugL
        DREG    r0, "zones: "
 ]
        MUL     r1, r2, r0              ; r1 = max objects in map
        LDRB    r0, [sp, #DiscRecord_IdLen]
 [ DebugL
        DREG    r0, "idlen: "
 ]
        MOVS    r14, r1, LSR r0
 [ DebugL
        BEQ     %FT01
        DLINE   "Failed on 2^idlen < Max Total objects"
01
 ]
        BNE     %FT85                   ; If shifting right by idlen leaves a non-0
                                        ; answer, then there aren't enough link bits!

        ; Check sufficient link bits for free space list in a sector
        LDRB    r0, [sp, #DiscRecord_Log2SectorSize]
        ADD     r0, r0, #3              ; 2^3 = 8 = bits per byte
        LDRB    r2, [sp, #DiscRecord_IdLen]

 [ BigMaps
        ; if BigMaps then idlen can be more than MaxFreeLink, so test against
        ; MaxFreeLink (we're being paranoid here, since maximum sector is 4096
        ; bytes, needing 15 link bits)

        CMP     r2, #MaxFreeLinkBits
        MOVHI   r2, #MaxFreeLinkBits
 ]

        CMP     r2, r0
 [ DebugL
        BHS     %FT01
        DLINE   "Failed on idlen < Zone length in bits"
01
 ]
        BLO     %FT85                   ; Definitely not enough

        ; Check DiscRecord_Skew not being silly
        LDRB    r0, [sp, #DiscRecord_Skew]
        LDRB    r2, [sp, #DiscRecord_SecsPerTrk]
        CMP     r0, r2
 [ DebugL
        BLO     %FT01
        DLINE   "Failed on DiscRecord_Skew >= SecsPerTrk"
01
 ]
        BHS     %FT85                   ; skew >= secspertrk is silly!

 [ BigShare
        ; Check RootDir is sensible:
        ; Must be &000002nn where nn=(2*Zones)>>ShareSize+1
 [ BigMaps

        LDRB    r1, [sp, #DiscRecord_IdLen]
        CMP     r1, #MaxIdLenSmlMap
        BHI     %FT10                   ; tests for BigMap

        LDRB    r1, [sp, #DiscRecord_BigDir_DiscVersion]
        TEQS    r1, #0
        BNE     %FT10                   ; don't sanity check rootdir address


 ]

 [ BigMaps
        LDRB    r1, [sp, #DiscRecord_NZones]
        LDRB    r0, [sp, #DiscRecord_BigMap_NZones2]    ; r0 due for corruption later
        ADD     r1, r1, r0,LSL #8
 |
        LDRB    r1, [sp, #DiscRecord_NZones]
 ]
        MOV     r1, r1, ASL #1
        LDRB    r0, [sp, #DiscRecord_BigMap_ShareSize]  ; factor in sharesize
        MOV     lr, #1
        ADD     r1, r1, lr, LSL r0
        SUB     r1, r1, #1
        MOV     r1, r1, LSR r0
        ADD     r1, r1, #1
        ADD     r1, r1, #&200
        LDR     r0, [sp, #DiscRecord_Root]
        TEQ     r0, r1
 |
        ; Check RootDir is sensible: must be &000002nn
        ; where nn = (2*Zones) + 1
 [ BigMaps
        LDRB    r1, [sp, #DiscRecord_NZones]
        LDRB    r0, [sp, #DiscRecord_BigMap_NZones2]    ; r0 due to be corrupted
        ADD     r1, r1, r0, LSL #8
 |
        LDRB    r1, [sp, #DiscRecord_NZones]
 ]
        MOV     r1, r1, ASL #1
        ADD     r1, r1, #1
        ADD     r1, r1, #&200
        LDR     r0, [sp, #DiscRecord_Root]
        TEQ     r0, r1
 ]
 [ DebugL
        BEQ     %FT01
        DREG    r1, "Failed on RootDir != "
01
 ]
        BEQ     %FT10

        ; or, another last ditch attempt if Zones=1 and density=0
        ; where nn = ((bootblock + bootblocksize + (1<<DiscRecord_Log2SectorSize) - 1) >> DiscRecord_Log2SectorSize) + 1
 [ BigMaps
        LDRB    r1, [sp, #DiscRecord_NZones]
        LDRB    r14, [sp, #DiscRecord_BigMap_NZones2]
        ORR     r1, r1, r14, LSL #8
 |
        LDRB    r1, [sp, #DiscRecord_NZones]
 ]
        LDRB    r14, [sp, #DiscRecord_Density]
        ORR     r14, r1, r14, LSL #16
        TEQ     r14, #1                                 ; EQ iff density=0 zones=1
        BNE     %FT85

        MOV     r14, #1
        LDRB    r1, [sp, #DiscRecord_Log2SectorSize]
      [ BigSectors
        CMP     r1, #10                                 ; Can't be 1 zone with 2k or 4k sectors
        BHI     %FT85
      ]
 [ DebugL
        DLINE   "Might be a 1 zone fixed disc"
 ]
        MOV     r14, r14, ASL r1
        SUB     r14, r14, #1
        ADD     r14, r14, #DefectListDiscAdd + SzDefectList
        MOV     r14, r14, LSR r1
        ADD     r14, r14, #1
        ORR     r14, r14, #&200
        TEQ     r0, r14
 [ DebugL
        BEQ     %FT01
        DREG    r14, "Failed on RootDir != "
01
 ]
        BNE     %FT85

10

        ; Check disc size:
        ; Must be > ((Zones-1)*(8<<DiscRecord_Log2SectorSize-ZoneSpare)-Zone0Bits)<<BitSize
 [ {FALSE}
        ; (this check should not be made as may be partitioned for UNIX)
        ; Must be < 512M (due to duff DiscOp interface)
 ]
; check for Big disc on Small filing system
 [ BigDisc
        LDRB    r1, [sp, #DiscRecord_BigMap_Flags]      ; check if its a big disc
        TSTS    r1, #DiscRecord_BigMap_BigFlag
        BEQ     %FT01
        LDR     r1, [r12]
        LDR     r1, [r1,#:INDEX:FS_Flags]
        TST     r1, #CreateFlag_BigDiscSupport
        BEQ     %FT85                   ; small filing system, big disc

01      ; not big or big on big filing system
 ]
        MOV     r0, #8
        LDRB    r1, [sp, #DiscRecord_Log2SectorSize]
        MOV     r0, r0, ASL r1
        ASSERT  DiscRecord_ZoneSpare :MOD: 4 = 2
        LDR     r1, [sp, #DiscRecord_ZoneSpare - 2]
        SUB     r0, r0, r1, LSR #16
 [ BigMaps
        LDRB    r1, [sp, #DiscRecord_NZones]
        LDRB    lr, [sp, #DiscRecord_BigMap_NZones2]    ; lr is safe to use
        ADD     r1, r1, lr, LSL #8
 |
        LDRB    r1, [sp, #DiscRecord_NZones]
 ]
        SUB     r1, r1, #1
        MUL     r0, r1, r0
        SUB     r0, r0, #Zone0Bits
        LDRB    r1, [sp, #DiscRecord_Log2bpmb]
 [ BigDisc
; first, get the comparison size in sectors
        LDRB    lr, [sp, #DiscRecord_Log2SectorSize]
        SUBS    r1, r1, lr
        MOVPL   r0, r0, LSL r1
        RSBMI   r0, r0, #0
        MOVMI   r0, r0, LSR r1
; then the disc size in sectors
        LDR     r1, [sp, #DiscRecord_DiscSize]
        MOV     r1, r1, LSR lr
        LDR     r2, [sp, #DiscRecord_BigMap_DiscSize2]
 [ DebugL

        DREG    r2, "Discsize2 was "
 ]
        RSB     lr, lr, #32
        ORR     r1, r1, r2, LSL lr      ; now full DiscSize in sectors in r1
        CMP     r1, r0
 |
        MOV     r0, r0, ASL r1
        LDR     r1, [sp, #DiscRecord_DiscSize]
        CMP     r1, r0
 ]
 [ DebugL
        BGT     %FT01
        DREG    r0, "Failed on Disc Size (signed)<= "
01
 ]
        BLE     %FT85
 [ {FALSE}
        ; Don't check for upper limit - its OK to be bigger
        CMP     r1, #512*1024*1024
 [ DebugL
        BLO     %FT01
        DLINE   "Failed on Disc Size > 512M"
01
 ]
        BHS     %FT85
 ]

        ; All checked out - this disc record is cool!
        ; Copy the info into the r5 disc record
        ; Those fields which must be left to later are:
        ; DiscId
        ; DiscName
        ; BootOpt       (Although the byte which would be the BootOption is copied)
        ASSERT  DiscRecord_IdLen :MOD: 4 = 0
        ASSERT  DiscRecord_Log2bpmb = DiscRecord_IdLen+1
        ASSERT  DiscRecord_Skew = DiscRecord_Log2bpmb+1
        ASSERT  DiscRecord_BootOpt = DiscRecord_Skew+1
        LDR     r0, [sp, #DiscRecord_IdLen]
        STR     r0, [r5, #DiscRecord_IdLen]
        LDRB    r0, [sp, #DiscRecord_NZones]
        STRB    r0, [r5, #DiscRecord_NZones]
 [ BigMaps
        LDRB    r0, [sp, #DiscRecord_BigMap_NZones2]
        STRB    r0, [r5, #DiscRecord_BigMap_NZones2]
 ]
        LDRB    r0, [sp, #DiscRecord_ZoneSpare]
        STRB    r0, [r5, #DiscRecord_ZoneSpare]
        LDRB    r0, [sp, #DiscRecord_ZoneSpare+1]
        STRB    r0, [r5, #DiscRecord_ZoneSpare+1]
        LDR     r0, [sp, #DiscRecord_Root]
        LDR     r1, [r5, #DiscRecord_Root]
        AND     r1, r1, #DiscBits
        ORR     r0, r0, r1
 [ DebugL
        DREG    r1, "DiscBits from disc record are: "
        DREG    r0, "Setting RootDir to: (Identify, 968) "
 ]
        STR     r0, [r5, #DiscRecord_Root]
        LDR     r0, [sp, #DiscRecord_DiscSize]
        STR     r0, [r5, #DiscRecord_DiscSize]
 [ BigDisc
        LDR     r0, [sp, #DiscRecord_BigMap_DiscSize2]
        STR     r0, [r5, #DiscRecord_BigMap_DiscSize2]
   [ BigShare
        LDR     r0, [sp, #DiscRecord_BigMap_ShareSize]
        STR     r0, [r5, #DiscRecord_BigMap_ShareSize]
   ]
 ]
 [ BigDir
        LDR     r0, [sp, #DiscRecord_BigDir_DiscVersion]
        STR     r0, [r5, #DiscRecord_BigDir_DiscVersion]
        LDR     r0, [sp, #DiscRecord_BigDir_RootDirSize]
        STR     r0, [r5, #DiscRecord_BigDir_RootDirSize]
 ]
        CLRV
        B       %FT90

85
        SETV
90
 [ DebugL
        BVC     %FT01
        DLINE   "Failed to check E disc record"
01
 ]
 [ BigDisc
        ADD     sp, sp, #SzDiscRecSig2
 |
        ADD     sp, sp, #SzDiscRecSig
 ]
95
        Pull    "r0,r1,r2,r3,r4,r5,r7,r8,r9,r10,r11,r12,pc"

        LTORG

; =================
; SanityCheckNewMap
; =================
;
; entry
;  r5 -> disc record (with data from disc signature filled in)
;  r6 = cache handle
;  r12 = Pointer to FileCore instance private word to use
;
; on exit
;  r5 unchanged
;  r6 = new cache handle
;  r12 = unchanged
;  VC => Map checked OK
;  VS => Map duff
;
SanityCheckNewMap ROUT
        Push    "r0-r5,r7-r10,lr"

 [ DebugL
        DLINE   "Sanity checking new map"
 ]

 [ ReadMapDuringIdentify
        ASSERT  BigMaps
        ASSERT  BigDisc
        
        ; Prior to issuing Service_IdentifyDisc, the top bits in the root directory
        ; disc address in the disc record are tweaked to contain the drive number
        ; containing the disc being identified (external numbering is used)
        Push    "r12"
        LDR     r1, [r5, #DiscRecord_Root]
        EOR     r1, r1, #bit31
        MOV     r1, r1, LSR #(32-3)
        LDR     r12, [r12]
        DrvRecPtr r4, r1
        BL      AdjustFsSpace
        Pull    "r12"
        BVS     %FT95

        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]
        LDRB    r9, [r5, #DiscRecord_NZones]
        LDRB    lr, [r5, #DiscRecord_BigMap_NZones2]
        ADD     r9, r9, lr, LSL #8
        BL      MapDiscAdd      ;(R5,R7,R9->R2)
        Push    "r2"
        
        MOV     r1, #1
        MOV     r1, r1, LSL r7
        LDR     r7, [r4, #DrvsFsMapAddr]
        MOV     r8, #0

        ; Register usage:
        ; r1 = map block length = sector size, in bytes
        ; r2 = disc address of map which we are testing
        ; r3 -> start / end of copy of map in dynamic area
        ; r4 = map length in bytes / -> sector in dynamic area which we are testing
        ; r5 -> disc record
        ; r7 -> base of map dynamic area
        ; r8 = sector offset to copy of map which we are testing
        ; r9 = number of sectors in map = number of zones on disc
        ; r10 = CrossCheck accumulator
        ; r12 -> FileCore instance private word
        ; [sp] -> disc address of first copy of the map
        
10      ; Next copy of the map
        MOV     r3, r7
        MUL     r4, r9, r1
        MOV     r10, #0
        BL      SWI_SectorDiscOp_ReadSectors_Myself ;(R2-R5,R12->R2-R4,V)
        BVS     %FT30
        MOV     r4, r7

20      ; Next map block in this copy of the map
        ; Make a simple test on the free link
        LDRB    r0, [r4, #FreeLink+1]
        TST     r0, #&80
        BEQ     %FT30
        
        ; Test map block against ZoneCheck byte
        MOV     r0, r4
        BL      NewCheck        ;(R0,R1->LR,Z)
        BNE     %FT30
        
        ; Do this sector's contribution to the cross check
        LDRB    r0, [r4, #CrossCheck]
        EOR     r10, r10, r0
        
        ; Advance to the next sector of the map
        ADD     r4, r4, r1
        CMP     r4, r3
        BLO     %B20
        
        ; Check the cross check
        TEQ     r10, #&ff
        BEQ     %F40

30      ; A failure has happened
        ; If not on first copy of map, then map is bad, so give up!
        TEQ     r8, #0
        ADDNE   sp, sp, #4  ; skip disc address on stack
        SUBNE   sp, sp, r1
        BNE     %FT85
        
        ; Try the second map copy
        MOV     r8, r9
        B       %B10

40      ; Map cross-checks OK
        ; Store r8 after the map, so in ReadFsMap, we know where it came from
        ; This will be valid memory, because the zone flags are normally stored there
        STR    r8, [r3]
        ; Now prepare for the rest of the routine - it expects
        ;   r5 -> disc record
        ;   r7 = disc address of the first copy of the map
        ;   r8 = sector offset to copy of the map in use
        ;   sp is adjusted to allocate a buffer of the size of 1 sector
        Pull    "r7"
        SUB     sp, sp, r1
 
 | ; ReadMapDuringIdentify

        LDRB    r4, [r5, #DiscRecord_Log2SectorSize]
        MOV     lr, #1
        SUB     sp, sp, lr, ASL r4

 [ BigMaps
        LDRB    r9, [r5, #DiscRecord_NZones]
        LDRB    r7, [r5, #DiscRecord_BigMap_NZones2]
        ADD     r9, r9, r7, LSL #8
 |
        LDRB    r9, [r5, #DiscRecord_NZones]
 ]
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]

        BL      MapDiscAdd
        MOV     r7, r2

        ; Offset to start of map block (chooses between the two map copies)
        MOV     r8, #0

10
        ; Sector offset within map copy
        MOV     r9, #0

        ; Current EOR of cross checks
        MOV     r10, #0

20
        ; Read a sector
        ADD     r2, r7, r8
        LDRB    r4, [r5, #DiscRecord_Log2SectorSize]
 [ BigDisc
        ADD     r2, r2, r9
 |
        ADD     r2, r2, r9, ASL r4
 ]
        MOV     r3, sp
        MOV     lr, #1
        MOV     r4, lr, ASL r4
 [ BigDisc
        BL      SWI_SectorDiscOp_CachedReadSectors_Myself
 |
        BL      SWI_DiscOp_CachedReadSectors_Myself
 ]
 [ DebugL
        BVC     %FT01
        ADD     r1, r0, #4
        DSTRING r1, "(Read failed:"
01
 ]
        BVS     %FT30

        ; Make a simple test on the free link
        LDRB    r0, [sp, #FreeLink+1]
        TST     r0, #&80
 [ DebugL
        BNE     %FT01
        DLINE   "(Top bit of free link is clear)"
01
 ]
        BEQ     %FT30

        ; Check it
        MOV     r0, sp
        LDRB    r1, [r5, #DiscRecord_Log2SectorSize]
        MOV     lr, #1
        MOV     r1, lr, ASL r1
        BL      NewCheck
 [ DebugL
        BEQ     %FT01
        DLINE   "(NewCheck failed)"
01
 ]
        BNE     %FT30

        ; Construct the cross check
        LDRB    r0, [sp, #CrossCheck]
        EOR     r10, r10, r0

        ; Advance to the next sector of the map
        ADD     r9, r9, #1
 [ BigMaps
        LDRB    r0, [r5, #DiscRecord_NZones]
        LDRB    r2, [r5, #DiscRecord_BigMap_NZones2]    ; r2 should be ok here
        ADD     r0, r0, r2, LSL #8
 |
        LDRB    r0, [r5, #DiscRecord_NZones]
 ]
        CMP     r9, r0
        BLO     %BT20

        ; Check the cross check
        TEQ     r10, #&ff
 [ DebugL
        BEQ     %FT01
        DREG    r10, "(Cross check failed):"
01
 ]
        BEQ     %FT40

30
        ; A failure has happened

        ; If not on first copy of map, then map is bad, so give up!
        TEQ     r8, #0
 [ DebugL
        BEQ     %FT01
        DLINE   "Failed on both map copies"
01
 ]
        BNE     %FT85

        ; Try on the second map copy
 [ BigMaps
        LDRB    r8, [r5, #DiscRecord_NZones]
        LDRB    r0, [r5, #DiscRecord_BigMap_NZones2]
        ADD     r8, r8, r0, LSL #8
 |
        LDRB    r8, [r5, #DiscRecord_NZones]
 ]
        LDRB    r0, [r5, #DiscRecord_Log2SectorSize]
 [ BigDisc
 |
        MOV     r8, r8, ASL r0
 ]

        B       %BT10

40
        ; Map cross-checks OK

 ] ; ReadMapDuringIdentify

        ; Check the disc record in the first map sector against
        ; the disc's disc record.

        ADD     r2, r7, r8
        LDRB    r4, [r5, #DiscRecord_Log2SectorSize]

        MOV     r3, sp
        MOV     lr, #1
        MOV     r4, lr, ASL r4
 [ BigDisc
        BL      SWI_SectorDiscOp_CachedReadSectors_Myself
 |
        BL      SWI_DiscOp_CachedReadSectors_Myself
 ]
 [ DebugL
        BVC     %FT01
        ADD     r1, r0, #4
        DSTRING r1, "Failed on reread of 1st map block"
01
 ]
        BVS     %FT90

        ; Cross check the boot disc record with the map 1st sector
        ; disc record. Those fields which should match are:
        ; sector size
        ; sectors per track
        ; heads
        ; density
        ; fragment id length
        ; bytes per map bit
        ; skew
        ; lowsector
        ; zones
        ; zone spare
        ; root directory
        ; disc size
        ; Those fields which don't match are:
        ; boot option
        ; disc id
        ; disc name
        ADD     r4, sp, #ZoneHead
        MOV     r14, r5

        ASSERT  DiscRecord_Log2SectorSize=0
        ASSERT  DiscRecord_SecsPerTrk=1
        ASSERT  DiscRecord_Heads=2
        ASSERT  DiscRecord_Density=3
        ASSERT  DiscRecord_IdLen=4
        ASSERT  DiscRecord_Log2bpmb=5
        ASSERT  DiscRecord_Skew=6
        ASSERT  DiscRecord_BootOpt=7
        LDMIA   r4!, {r0-r1}
        LDMIA   r14!, {r2-r3}
        TEQ     r0, r2
 [ DebugL
        BEQ     %FT01
        DREG    r0,"DHSS:",cc
        DREG    r2,"!="
01
 ]
        EOR     r0, r1, r3
        BICS    r0, r0, #&ff000000      ; Boot option missing from boot record (pervy eh?)
 [ DebugL
        BEQ     %FT01
        DREG    r1,"BRBL:",cc
        DREG    r3,"!="
01
 ]

        ASSERT  DiscRecord_LowSector=8
        ASSERT  DiscRecord_NZones=9
        ASSERT  DiscRecord_ZoneSpare=10
        ASSERT  DiscRecord_Root=12
        LDMEQIA r4!, {r0-r1}
        LDMEQIA r14!, {r2-r3}
        TEQEQ   r0, r2
 [ DebugL
        BEQ     %FT01
        DLINE   ".",cc
01
 ]
        BICEQ   r3, r3, #DiscBits       ; Test root dir modulo disc number
        TEQEQ   r1, r3
 [ DebugL
        BEQ     %FT01
        DLINE   ".",cc
01
 ]

        ASSERT  DiscRecord_DiscSize=16
 [ BigDisc
        ASSERT  DiscRecord_BigMap_DiscSize2=36
 ]
        LDREQ   r0, [r4], #4
        LDREQ   r2, [r14], #4
        TEQEQ   r0, r2
 [ BigDisc
   [ BigShare
        ASSERT  DiscRecord_BigMap_ShareSize=40
        ADDEQ   r4,r4,#DiscRecord_BigMap_DiscSize2-DiscRecord_DiscSize-4
        ADDEQ   r14,r14,#DiscRecord_BigMap_DiscSize2-DiscRecord_DiscSize-4
        LDMEQIA r4!, {r0-r1}
        LDMEQIA r14!, {r2-r3}
        TEQEQ   r0, r2
        TEQEQ   r1, r3
   |
        ADDEQ   r4,r4,#DiscRecord_BigMap_DiscSize2-DiscSize-4
        ADDEQ   r14,r14,#DiscRecord_BigMap_DiscSize2-DiscSize-4
        LDREQ   r0, [r4], #4
        LDREQ   r2, [r14], #4
        TEQEQ   r0, r2
   ]
 ]
 [ DebugL
        BEQ     %FT01
        DLINE   ".",cc
01
 ]
 [ DebugL
        BEQ     %FT01
        DLINE   "Failed on disc record cross-check"
01
 ]
        BNE     %FT85

        ; All hunky-dory, copy over DiscId, Boot Option and Disc Name
        ASSERT  DiscRecord_DiscId :MOD: 4 = 0
        ASSERT  DiscRecord_DiscName = DiscRecord_DiscId+2
        LDR     r0, [sp, #ZoneHead + DiscRecord_DiscId]
        STR     r0, [r5, #DiscRecord_DiscId]
        LDR     r0, [sp, #ZoneHead + DiscRecord_DiscId+4]
        STR     r0, [r5, #DiscRecord_DiscId+4]
        LDR     r0, [sp, #ZoneHead + DiscRecord_DiscId+8]
        STR     r0, [r5, #DiscRecord_DiscId+8]
        LDRB    r0, [sp, #ZoneHead + DiscRecord_BootOpt]
        STRB    r0, [r5, #DiscRecord_BootOpt]
        B       %FT90

85
        SETV
90
 [ DebugL
        BVC     %FT01
        DLINE   "Failed to check new map"
01
 ]
        LDRB    r4, [r5, #DiscRecord_Log2SectorSize]
        MOV     lr, #1
        ADD     sp, sp, lr, ASL r4
95
        Pull    "r0-r5,r7-r10,pc"

        LTORG

; ==================
; SanityCheckLFormat
; ==================
;
; entry
;  r5 = pointer to disc record
;  r6 = sector cache handle
;  r12 = Pointer to FileCore instance private word to use
;
; exit
;   r6 = new sector cache handle
;   r12 = unchanged
;  AND
;   VC: Matches OK
;   VS: Mismatch and r0 does _not_ point to an error
;
SanityCheckLFormat ROUT
        Push    "r0,lr"
 [ DebugL
        DLINE   "Sanity checking L format"
 ]

        ; Must be lowsector=0, 2 heads, 15x256 byte sectors, and double density
        LDRB    r0, [r5, #DiscRecord_LowSector]
        ASSERT  DiscRecord_LowSector_Shift = 0
        AND     r0, r0, #DiscRecord_LowSector_Mask
        TEQ     r0, #0
        BNE     %FT90
        BL      EnsureSequencedSides
        TEQ     r0, #1
 [ DebugL
        BEQ     %FT01
        DREG    r0,"Heads="
01
 ]
        BNE     %FT90
        LDRB    r0, [r5, #DiscRecord_SecsPerTrk]
        TEQ     r0, #16
 [ DebugL
        BEQ     %FT01
        DREG    r0,"SecsPerTrk="
01
 ]
        BNE     %FT90
        LDRB    r0, [r5, #DiscRecord_Log2SectorSize]
        TEQ     r0, #8
 [ DebugL
        BEQ     %FT01
        DREG    r0,"Log2SectorSize="
01
 ]
        BNE     %FT90
        LDRB    r0, [r5, #DiscRecord_Density]
        TEQ     r0, #DensityDouble
 [ DebugL
        BEQ     %FT01
        DREG    r0,"Density="
01
 ]
        BNE     %FT90

 [ BigDisc
        ; Fake a disc size for sequence sides
        MOV     r0, #640*1024
        STR     r0, [r5, #DiscRecord_DiscSize]

        ; Upper word of disc size
        MOV     r0, #0
        STR     r0, [r5, #DiscRecord_BigMap_DiscSize2]
        ; r0 is already 0 for SanityCheckOldMap
 |
        ; Fake a disc size for sequence sides
        MOV     r0, #640*1024
        STR     r0, [r5, #DiscRecord_DiscSize]

        ; Read and check map from disc
        MOV     r0, #0
 ]
        BL      SanityCheckOldMap
 [ DebugL
        BVC     %FT01
        DLINE   "OldMapBroken"
01
 ]
        BVC     %FT95

90
        SETV
95
 [ DebugL
        BVC     %FT01
        DLINE   "Failed to check L format"
        B       %FT02
01
        DLINE   "L format is the business!"
02
 ]
        Pull    "r0,pc"

        LTORG

; ==================
; SanityCheckDFormat
; ==================
;
; entry
;  r5 = pointer to disc record
;  r6 = sector cache handle
;  r12 = Pointer to FileCore instance private word to use
;
; exit
;   r6 = new sector cache handle
;   r12 = unchanged
;  AND
;   VC: Matches OK
;   VS: Mismatch and r0 does _not_ point to an error
;
SanityCheckDFormat ROUT
        Push    "lr"
 [ DebugL
        DLINE   "Sanity checking D format"
 ]

        ; Read and check map from disc
        MOV     r0, #1
        BL      SanityCheckOldMap

95
 [ DebugL
        BVC     %FT01
        DLINE   "Failed to check D format"
        B       %FT02
01
        DLINE   "D format is the business!"
02
 ]
        Pull    "pc"

        LTORG

; =================
; SanityCheckOldMap
; =================
;
; entry
;  r0 =flags:
;       if <> 0 'Directories are large (77 entries)' and at D_Root
;  r5 -> disc record (with data from disc signature filled in)
;  r6 = cache handle
;  r12 = Pointer to FileCore instance private word to use
;
; on exit
;  r5 unchanged
;  r6 = new cache handle
;  r12 = unchanged
;  VC => Map checked OK and disc name and size copied to disc record
;  VS => Map duff
;
SanityCheckOldMap ROUT
        Push    "r0-r4,r7,lr"
        SUB     sp, sp, #SzOldFs

 [ DebugL
        DLINE   "Sanity checking old map"
 ]

        LDR     r7, [r5, #DiscRecord_Root]
        AND     r7, r7, #DiscBits

        ; Read the 1st map copy
        MOV     r2, r7
        MOV     r3, sp
        MOV     r4, #SzOldFs
        BL      SWI_DiscOp_CachedReadSectors_Myself

 [ DebugL
        DLINE   "Point A"
        BVC     %FT01
        ADD     r1, r0, #4
        DSTRING r1, "Failed on read map (1st copy):"
01
 ]
        BVS     %FT90

        MOV     r0, sp
        MOV     r1, #SzOldFs/2
        BL      CheckSum
 [ DebugL
        DLINE   "Point B"
        BVC     %FT01
        DLINE   "Failed on check sum, 1st half"
01
 ]
        BVS     %FT90

        ; CheckSum 2nd section of old map
        ADD     r0, sp, #SzOldFs/2
        MOV     r1, #SzOldFs/2
        BL      CheckSum
 [ DebugL
        DLINE   "Point D"
        BVC     %FT01
        DLINE   "Failed on check sum, 2nd half"
01
 ]
        BVS     %FT90

        ; CheckSum clean - sanity check free space list

        ; r0 = pointer into free list
        ; r1 = end of previous free block (starts at end of root dir) (in 256-bytes)
        ; r3 = disc size (in 256-bytes)
        ; r4 = Number of free space entries to go
        ADD     r0, sp, #FreeStart
        LDR     lr, [sp, #SzOldFs]
        TEQ     lr, #0
        MOVEQ   r1, #L_Root + OldDirSize
        MOVNE   r1, #D_Root + NewDirSize
        MOV     r1, r1, LSR #8
        SUB     r1, r1, #1
        ASSERT  (OldSize :MOD: 4) = 0
        LDR     r3, [sp, #OldSize]
        BIC     r3, r3, #&ff000000      ; r3 = disc size/256
        CMP     r3, #8+2                ; 2*256 for map, 8*256 for large (new) directory
        SETV    LO
 [ DebugL
        BVC     %FT01
        DREG    r3, "Disc size too small:"
01
 ]
        BVS     %FT90

        LDRB    r4, [sp, #FreeEnd]
        B       %FT20

10
        ; Construct Start
        LDRB    r2, [r0, #0]
        LDRB    lr, [r0, #1]
        ORR     r2, r2, lr, ASL #8
        LDRB    lr, [r0, #2]
        ORR     r2, r2, lr, ASL #16

        ; If Start <= previous end then bad map
        CMP     r2, r1
 [ DebugL
        BHI     %FT01
        DREG    r2, "Failed on Start(",cc
        DREG    r1, ")<=Previous end(",cc
        DLINE   ")"
01
 ]
        SETV    LS
        BVS     %FT90

        ; Construct End
        ADD     r0, r0, #FreeLen - FreeStart
        LDRB    lr, [r0, #0]
        ADD     r1, r1, lr
        LDRB    lr, [r0, #1]
        ADD     r1, r1, lr, ASL #8
        LDRB    lr, [r0, #2]
        ADD     r1, r1, lr, ASL #16
        ADD     r0, r0, #FreeStart - FreeLen + 3

        ; If End>DiscSize then puke
        CMP     r1, r3
 [ DebugL
        BLS     %FT01
        DREG    r1, "Failed on End(",cc
        DREG    r3, ")>Disc size(",cc
        DLINE   ")"
01
 ]
        SETV    HI
        BVS     %FT90

20
        ; Count down to the end
        SUBS    r4, r4, #3
        BHI     %BT10

        ; Copy OldBoot to BootOpt
        LDRB    r0, [sp, #OldBoot]
        STRB    r0, [r5, #DiscRecord_BootOpt]

        ; Copy the OldId to DiscId
        LDRB    r0, [sp, #OldId+0]
        STRB    r0, [r5, #DiscRecord_DiscId+0]
        LDRB    r0, [sp, #OldId+1]
        STRB    r0, [r5, #DiscRecord_DiscId+1]

        ; Copy the name to the disc record
        LDRB    r0, [sp, #OldName0+0]
        STRB    r0, [r5, #DiscRecord_DiscName+0]
        LDRB    r0, [sp, #OldName1+0]
        STRB    r0, [r5, #DiscRecord_DiscName+1]
        LDRB    r0, [sp, #OldName0+1]
        STRB    r0, [r5, #DiscRecord_DiscName+2]
        LDRB    r0, [sp, #OldName1+1]
        STRB    r0, [r5, #DiscRecord_DiscName+3]
        LDRB    r0, [sp, #OldName0+2]
        STRB    r0, [r5, #DiscRecord_DiscName+4]
        LDRB    r0, [sp, #OldName1+2]
        STRB    r0, [r5, #DiscRecord_DiscName+5]
        LDRB    r0, [sp, #OldName0+3]
        STRB    r0, [r5, #DiscRecord_DiscName+6]
        LDRB    r0, [sp, #OldName1+3]
        STRB    r0, [r5, #DiscRecord_DiscName+7]
        LDRB    r0, [sp, #OldName0+4]
        STRB    r0, [r5, #DiscRecord_DiscName+8]
        LDRB    r0, [sp, #OldName1+4]
        STRB    r0, [r5, #DiscRecord_DiscName+9]

        ; Copy disc size to disc record
        MOV     r3, r3, ASL #8
        STR     r3, [r5, #DiscRecord_DiscSize]
 [ BigDisc
        MOV     r3, #0
        STR     r3, [r5, #DiscRecord_BigMap_DiscSize2]
 ]

90
 [ DebugL
        BVC     %FT01
        DLINE   "Failed to check old map"
        B       %FT02
01
        DLINE   "Old map is the business!"
02
 ]
        ADD     sp, sp, #SzOldFs
95
        Pull    "r0-r4,r7,pc"

        LTORG

; ====================
; EnsureSequencedSides
; ====================
;
; In
;    R5 = pointer to disc record
; Out
;    R0 = number of heads (adjusted for sequence sides)
;    R5 = pointer to sequence sided disc record
;
EnsureSequencedSides ROUT
        LDRB    r0, [r5, #DiscRecord_LowSector]
        TST     r0, #DiscRecord_SequenceSides_Flag
        ORR     r0, r0, #DiscRecord_SequenceSides_Flag
        STRB    r0, [r5, #DiscRecord_LowSector]
        LDRB    r0, [r5, #DiscRecord_Heads]
        SUBEQ   r0, r0, #1
        STREQB  r0, [r5, #DiscRecord_Heads]
        MOV     pc, lr

; ======================
; EnsureInterleavedSides
; ======================
;
; In
;    R5 = pointer to disc record
; Out
;    R0 = number of heads (adjusted for interleaved sides)
;    R5 = pointer to sequence sided disc record
;
EnsureInterleavedSides ROUT
        LDRB    r0, [r5, #DiscRecord_LowSector]
        TST     r0, #DiscRecord_SequenceSides_Flag
        BIC     r0, r0, #DiscRecord_SequenceSides_Flag
        STRB    r0, [r5, #DiscRecord_LowSector]
        LDRB    r0, [r5, #DiscRecord_Heads]
        ADDNE   r0, r0, #1
        STRNEB  r0, [r5, #DiscRecord_Heads]
        MOV     pc, lr

; ===================================
; SWI_DiscOp_CachedReadSectors_Myself
; ===================================
;
; In
;       r2-r4 DiscOp parameters
;       r5 = disc record
;       r6 = cache
;       r12 = private workspace pointer
;
; Out
;       r12 = unchanged
;       results of DiscOp
;
SWI_DiscOp_CachedReadSectors_Myself ROUT
        Push    "r1,r7-r12,lr"
 [ Debug2 :LOR: Debug2D
        DREG    r1, "DiscOpMyself(",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DLINE   ")"
 ]
        MOV     r11, sp
        MOV     r1, r2, LSR #(32-3)
        BIC     r2, r2, #DiscBits
        MOV     lr, #0
        Push    "r1,r2,lr"
        MOV     r8, r12
        MOV     r2, sp
        MOV     r1, #DiscOp_CachedReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        SWI     XFileCore_DiscOp64
 [ DebugL
        BVC     %FT01
        ADD     r0, r0, #4
        DSTRING r0, "Cached read sector error:"
        SUB     r0, r0, #4
01
 ]
        LDMIA   r2, {r2, lr}
        BIC     lr, lr, #DiscBits
        ORR     r2, lr, r2, LSL #(32-3)
        MOV     sp, r11
        Pull    "r1,r7-r12,pc"

; =========================================
; SWI_SectorDiscOp_CachedReadSectors_Myself
; =========================================
;
; In
;       r2-r4 DiscOp parameters
;       r5 = disc record
;       r6 = cache
;       r12 = private workspace pointer
;
; Out
;       r12 = unchanged
;       results of DiscOp
;

SWI_SectorDiscOp_CachedReadSectors_Myself ROUT
        Push    "r1,r7-r12,lr"
 [ Debug2 :LOR: Debug2D
        DREG    r1, "SectorDiscOpMyself(",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DLINE   ")"
 ]
        MOV     r11, sp
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        MOV     r1, r2, LSR #(32-3)
        BIC     r2, r2, #DiscBits
        RSB     r8, lr, #32
        MOV     r7, r2, LSL lr
        MOV     lr, r2, LSR r8
        Push    "r1,r7,lr"
        MOV     r8, r12
        MOV     r2, sp
        MOV     r1, #DiscOp_CachedReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        SWI     XFileCore_DiscOp64
 [ DebugL
        BVC     %FT01
        ADD     r0, r0, #4
        DSTRING r0, "Cached read sector error:"
        SUB     r0, r0, #4
01
 ]
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        LDMIA   r2, {r1, r2, r7}
        RSB     r8, lr, #32
        MOV     r2, r2, LSR lr
        ORR     r2, r2, r7, LSL r8
        BIC     r2, r2, #DiscBits
        ORR     r2, r2, r1, LSL #(32-3)
        MOV     sp, r11
        Pull    "r1,r7-r12,pc"

 [ ReadMapDuringIdentify
; ===================================
; SWI_SectorDiscOp_ReadSectors_Myself
; ===================================
;
; In
;       r2-r4 DiscOp parameters
;       r5 = disc record
;       r12 = private workspace pointer
;
; Out
;       r12 = unchanged
;       results of DiscOp
;

SWI_SectorDiscOp_ReadSectors_Myself ROUT
        Push    "r1,r7-r12,lr"
 [ Debug2 :LOR: Debug2D
        DREG    r1, "SectorDiscOpMyself(",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DLINE   ")"
 ]
        MOV     r11, sp
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        MOV     r1, r2, LSR #(32-3)
        BIC     r2, r2, #DiscBits
        RSB     r8, lr, #32
        MOV     r7, r2, LSL lr
        MOV     lr, r2, LSR r8
        Push    "r1,r7,lr"
        MOV     r8, r12
        MOV     r2, sp
        MOV     r1, #DiscOp_ReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        SWI     XFileCore_DiscOp64
 [ DebugL
        BVC     %FT01
        ADD     r0, r0, #4
        DSTRING r0, "Read sector error:"
        SUB     r0, r0, #4
01
 ]
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        LDMIA   r2, {r1, r2, r7}
        RSB     r8, lr, #32
        MOV     r2, r2, LSR lr
        ORR     r2, r2, r7, LSL r8
        BIC     r2, r2, #DiscBits
        ORR     r2, r2, r1, LSL #(32-3)
        MOV     sp, r11
        Pull    "r1,r7-r12,pc"
 ]

        END
@


4.14
log
@Fixes in BigSectors option
Previous testing with RAMFS was limited by the size of RAM disc, and hence complexity of layout, meaning some cases with BigSectors were missed.
FileCore20.s: During mount, when loading the defect list from the boot block at &C00, take care to round down the source sector address to account for it only being aligned up to 1k sectors (but not for 2k and 4k).
FileCore25.s: When loading the head of a BigDir (to find out its actual size) and finding it to be > 2k, skip loading the bit from 2k-4k, since that was already loaded when the head was read in, and reading it a second time offset by 2k fails the head/tail check.
FileCore31.s: When building a table to decide which zones to compact, use FindBuffer() to get some temporary store if too large to fit into ScratchSpace.
Identify.s: Comment updated.
BigDirCode.s: (Unrelated) Fix for bad error pointer being passed back, due to R0 being restored on encountering an error during directory rename.

FSBashed for 300k cycles on Titanium with an assortment of manufacturer drives, capacities, and sector sizes.

Version 3.74. Tagged as 'FileCore-3_74'
@
text
@d733 1
a733 1
        ; Check 0 < idlen < 20
d735 1
a735 1
        CMP     r0, #19
d739 1
a739 1
        DLINE   "Failed on idlen >= 20"
d744 1
a744 1
        ; Check 0 < idlen < 16
d746 1
a746 1
        CMP     r0, #15
d749 1
a749 1
        DLINE   "Failed on idlen >= 16"
d836 2
a837 2
        CMP     r1, #15
        BHI     %FT10
@


4.13
log
@Avoid unnecessary remainder calculations
Detail:
  s/BigDirCode, s/Identify - Avoid unnecessary remainder calculation in DivRem macro
Admin:
  Tested on Cortex-A15


Version 3.69. Tagged as 'FileCore-3_69'
@
text
@d804 2
a805 2
        ; MaxFreeLink (we're being paranoid here, since maximum sector is 1024
        ; bytes, needing 13 link bits)
@


4.12
log
@Add support for 2k and 4k sector sizes
s/Commands:
Make sure the defect list (via *DEFECT) does a read/modify/write of the boot block on 2k and 4k drives.
The checksum generation code was largely common and although commented to be called as though it was common wasn't actually due to a cut and paste mistake on label 37. Deleted common/uncalled code.
s/DebugOpts; s/FileCore15:
Peripheral changes.
s/FileCore20:
Read in the defect list via an intermediate buffer then copy out into the dynamic area.
s/FileCore70:
Declare the buffer size as 4k to FileSwitch, internally FileCore expresses this in a single byte * 32 so is now at the limit of the range of FcbBufSz.
s/FileCore80:
Perform transfers in the foreground when the sector size exceeds FileCore's 1k buffers. It's not worth bothering.
s/FormSWIs; s/Identify:
Vet and reject attempts to layout invalid zone/sector size combos (see Doc/1Zone).
Doc/MiscOp:
Correct a couple of calculation mistakes.
Doc/1Zone:
New documentation detailing the possible valid combinations of a 1 zone fixed disc, and why for 2k and 4k sectors this is rejected.
Test/BigSectors:
Patch to apply to RAMFS to make it a 4k filing system. Note, the smallest 2 zone RAM disc with 4k sectors is 4052kB, in which case the map is at +3F0000; copy at +3F2000; root directory object at +3F4000.

Version 3.63. Tagged as 'FileCore-3_63'
@
text
@d772 1
a772 1
        DivRem  r2, r1, r0, lr          ; r2 = max objects per zone
@


4.11
log
@Minor tidy ups
Service call table made unconditional.
Typo in Hdr:FileCore corrected.
Comments improved, and other misc housekeeping.

Version 3.62. Tagged as 'FileCore-3_62'
@
text
@d900 6
a908 2
        MOV     r14, #1
        LDRB    r1, [sp, #DiscRecord_Log2SectorSize]
@


4.10
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d914 1
a914 1
        DREG    r1, "Failed on RootDir != "
@


4.9
log
@  Miscellaneous improvements
Detail:
  * Added the ability for a filing system to specify to FileCore that floppy
    discs should be mounted like hard discs, to complement the existing flag
    that specifies the opposite. SDFS requires this. Ideally SCSIFS should
    start using this as well, to encapsulate boot block handling within
    FileCore.
  * Added header definitions so the FileCore and the filing systems can
    negotiate the use of a new MiscOp entry, needed as part of partitioning
    support, especially important for filing systems that use the hardware-
    specific section of the boot block, like ADFS. At present, FileCore
    doesn't do anything different (it still doesn't support partitions) but
    this enables filing systems to be modified in preparation.
  * Removed the only place where FileCore paid any attention to the
    EmptyWorks flag returned by MiscOp 1 - an obscure and not very useful
    edge case not used by any current filing systems.
  * Added 650 lines of documentation for the MiscOp SWI and low-level entry
    to the Doc directory, giving the information you need in order to
    implement a FileCore filing system.
  * Added missing header file definitions for the low-level background DiscOp
    reason code and the hot-plug drive removed flag to MiscOp 7.
  * Removed some RISC OS 2 legacy code whereby FileCore maintained its idea
    of the internal disc address of the CSD @@, PSD \, Library % and URD & for
    each filing system. Since RISC OS 3.00, FileSwitch handles these
    internally and passes canonicalised paths to FileCore, so FileCore's disc
    addresses for these directories remained unset. This allows some
    considerable simplification of FileCore's path parser in particular, but
    also affects other code like that which decides how to expire disc
    records. Also note that FileCore has been unable to generate certain
    errors (like "Can't delete current directory") since RISC OS 3.00 for the
    same reason.
  * Changed loading of the map for FileCore-format discs so that the map is
    loaded into the dynamic area during the Service_IdentifyDisc handler in
    one big DiscOp rather than loading it twice, sector-by-sector, via one
    big sector cache. For one thing, the sector cache is implemented
    inefficiently - O(n^2) - and for another thing, single-sector DiscOps are
    relatively inefficient on many filing systems, especially on SD cards.
    Some example speed-ups measured for mounting discs are:
      SCSIFS,   1GB drive: was 0.62 sec, now 0.40 sec (1.55 x speedup)
      SCSIFS, 256GB drive: was 1.44 sec, now 0.52 sec (2.77 x speedup)
      SDFS,     2GB drive: was 1.25 sec, now 0.14 sec (8.93 x speedup)
Admin:
  Tested on a beagleboard, with SCSIFS and SDFS.

Version 3.50. Tagged as 'FileCore-3_50'
@
text
@d1097 1
a1097 1
        MOV     r1, r1, LSR #32-3
d1873 1
a1873 1
        MOV     r1, r2, LSR #29
d1890 1
a1890 1
        ORR     r2, lr, r2, LSL #29
d1920 1
a1920 1
        MOV     r1, r2, LSR #29
d1943 1
a1943 1
        ORR     r2, r2, r1, LSL #29
d1973 1
a1973 1
        MOV     r1, r2, LSR #29
d1996 1
a1996 1
        ORR     r2, r2, r1, LSL #29
@


4.8
log
@Teach FileCore_LayoutStructure and Service_IdentifyDisc how to do 1 zone fixed discs.
From the change logs it was last fixed sometime around FileCore 2.50 era, but has been long broken.
The boot block was in the right place, but was overwritten by the root directory, and the wrong size entry was claimed in the map, amongst other errors.
Free'd up R6 in LayoutFreeSpaceMap to avoid having to keep reevaluating the number of zones - makes it a bit more readable. Corrected inaccurate comments. Checked the code paths for new map with and without boot block, with and without long filenames.
Test app 'Make1Zone' generates a small disc image which can be inspected in a hex editor for correctness.
In the identify code, be more strict about looking for a boot block only on fixed discs since they cannot occur on floppies (saves time, wasn't necessarily wrong).
The concept of a boot block at &C00 only works when 2 copies of the map can be fitted underneath that address, for future 2k and 4k sector sizes these do not fit and it is likely that 1 zone fixed discs are forbidden (a drive with 4k sectors would typically be > 512GB and 1 zone would be ~32MB so spilling into a second zone would waste < 0.01%).
Other minor changes:
* Free command now groups the 'K' with 'bytes' to match OS_ConvertFileSize.
* FileCore20 debug didn't assemble.
* FileCore33 beefed up comments.
* GenSWIs debug didn't assemble.
Tested with a special cut of RAMFS manually loading various 1 zone images into its dynamic area and checking they mount, have a sensible *MAP and *FREE result, can be written to, and don't have broken directories.

Version 3.46. Tagged as 'FileCore-3_46'
@
text
@d1087 99
d1316 1
d1894 3
a1896 3
; ===================================
; SWI_DiscOp_CachedReadSectors_Myself
; ===================================
d1947 54
@


4.7
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d21 1
a21 1
; 15 May 1997: SBP: Changed SanityCheckEDiscRecord to support LinkBits up to 16.
d156 1
a156 1
       MOV     r12, r8
d758 1
a758 1
        DLINE   "Failed on LinkBits = 0"
d791 1
a791 1
        DLINE   "Failed on 2^LinkBits < Max Total objects"
d803 1
a803 1
        ; if BigMaps then idlen can be more than MaxFreeLink, so test agains
d854 1
a854 1
        LDRB    r0, [sp, #DiscRecord_BigMap_ShareSize]    ; factor in sharesize
d864 2
a865 2
        ; Check RootDir is sensible:
        ; Must be &000002nn where nn=2*Zones+1
d886 7
a892 1
        ; or, if Zones == 1, then &000002nn where nn = (&e00 + 1<<DiscRecord_Log2SectorSize - 1)>>DiscRecord_Log2SectorSize + 1
a893 4
        TEQ     r1, #1
 [ BigMaps
        LDREQB  r1, [sp, #DiscRecord_BigMap_NZones2]
        TEQEQ   r1, #0          ; have to also check that Zones2 is 0
d895 3
d900 3
d906 1
a907 1
        SUB     r14, r14, #1
a1094 1
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]
a1095 1
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]
d1098 2
d1199 1
a1200 1
 [ BigMaps
d1203 2
@


4.6
log
@Fix bug in DetermineDiscType.
When failed to identify, and the last operation was format, the DiscSize2 field was not being copied (instead DiscSize is copied twice).
Fix up some warnings from the assembler.
Tested briefly with a RAM disc, still works.

Version 3.44. Tagged as 'FileCore-3_44'
@
text
@d57 2
a58 2
	LDR	r9, [r5, #RootDir]
	AND	r9, r9, #DiscBits
d61 1
a61 1
	DREG	r9, "Rootdir internally starts as: "
d68 1
a68 1
	DREG	r1, "Setting initial root dir address to: "
d70 1
a70 1
        STR     r1, [r5, #RootDir]
d83 4
a86 4
	LDR	lr, [r5, #RootDir]
	BIC	lr, lr, #DiscBits
	ORR	lr, lr, r9
	STR	lr, [r5, #RootDir]
d89 1
a89 1
	DREG	lr, "Restoring internal disc numbering of RootDir: "
d97 3
a99 3
        ASSERT  DiscId :MOD: 4 = 0
        ASSERT  DiscName = DiscId+2
        STRNE   r0, [r5, #DiscId]
d229 1
a229 1
        LDR     lr, [r5, #RootDir]
d234 3
a236 2
        LDRB    r0, [r5, #LowSector]
        AND     lr, r0, #LowSectorMask
d246 3
a248 3
        LDRB    r0, [r5, #LowSector]
        BIC     r0, r0, #DoubleStep
        STRB    r0, [r5, #LowSector]
d265 2
a266 2
        MOV     r2, #0	; sector zero
	MOV	r3, #4	; byte offset 4
d268 1
a268 1
        MOV     r2, #4	; byte disc address 4
d275 1
a275 1
	DLINE	"It must be E format!"
d280 3
a282 3
 	LDR	lr, [r5, #DiscVersion]   ; check if it's EX or FX
 	TEQ	lr, #0
 	BEQ	%FT15
d284 1
a284 1
        LDRB    lr, [r5, #Density]
d286 1
a286 1
        TEQ     lr, #Quad
d291 1
a291 1
	B	%FT85
d296 1
a296 1
        LDRB    lr, [r5, #Density]
d298 1
a298 1
        TEQ     lr, #Quad
d311 1
a311 1
        LDRB    r1, [r5, #SectorSize]
d313 1
a313 1
        LDRB    r1, [r5, #SecsPerTrk]
d317 1
a317 1
        STR     r0, [r5, #DiscSize]
d319 2
a320 2
	MOV	r0, #0
	STR	r0, [r5, #DiscSize2]
d322 1
a322 1
        STR     r0, [r5, #ShareSize]    ; sharing unit always 0 for floppies
d330 3
a332 3
	LDR	r0, [r5, #DiscSize2]
	MOVS	r0, r0
	BNE	%FT30				; can't be L format - far too big!
d334 1
a334 1
        LDR     r0, [r5, #DiscSize]
d352 3
a354 3
	LDR	r0, [r5, #DiscSize2]
	MOVS	r0, r0
	BNE	%FT75				; too big
d356 1
a356 1
        LDR     r0, [r5, #DiscSize]
d425 5
a429 5
	LDRB	lr, [r5, #SectorSize]		; for conversion from byte to sector
	MOV	r3, #DefectListDiscAdd		; disc addr of boot block...
	MOV	r2, r3, LSR lr			; ...in sector form
	SUB	r3, r3, r2, LSL lr		;
	ADD	r3, r3, #DefectStruc		; offset of disc record
d436 5
a440 5
	BVS	%FT01
	LDR	lr, [r5, #DiscVersion]
	TEQS	lr, #0
	baddr	r1, FFormat_DescribeTag, EQ
	baddr	r1, FXFormat_DescribeTag, NE
d528 2
a529 2
	CLRV
	MOV	pc,lr
d539 1
a539 1
        LDR     r2, [r5, #RootDir]		; to get drive number
d541 9
a549 9
	MOV	r3, #DefectListDiscAdd		; disc addr of defect list
	LDRB	lr, [r5, #SectorSize]
        ORR     r2, r2, r3, LSR lr		; actual disc addr to read from
	MOV	r4, r3, LSR lr			; sector align disc addr
	SUB	r3, r3, r4, LSL lr		; extra transfer needed
	ADD	r4, r3, #SzDefectList		; amount to transfer
        SUB	sp, sp, r3			; transfer addr
	Push	"R3"
	MOV	r3, sp
d551 2
a552 2
	Pull	"R3"
	ADD	sp, sp, r3
d554 1
a554 1
        LDR     r2, [r5, #RootDir]
d618 2
a619 2
	DREG	r2, "Boot record sector="
	DREG	r3, "Boot record offset="
d667 2
a668 2
        SUB     sp, sp, #DiscRecSig2
	SUB	sp, sp, r3		; adjust for disc record offset
d670 1
a670 1
        SUB     sp, sp, #DiscRecSig
d675 3
a677 3
	DREG	r2, "Disc addr ="
	DREG	r3, "Offset ="
	DREG	sp, "SP ="
d680 2
a681 2
        MOV     r1, #CachedReadSecsOp
        LDR     r14, [r5, #RootDir]
d686 3
a688 3
        MOV     r4, #DiscRecSig2	; length we want
	ADD	r4, r4, r3		; actual transfer length to compensate for offset
	Push	"R3"
d691 2
a692 2
	Pull	"R3"
	ADD	sp, sp, r3	; pointer to disc record actual data
d695 1
a695 1
        MOV     r4, #DiscRecSig
d710 6
a715 6
        ASSERT  (SectorSize :MOD: 4) = 0
        ASSERT  SecsPerTrk = SectorSize+1
        ASSERT  Heads = SecsPerTrk+1
        ASSERT  Density = Heads+1
        LDR     r0, [r5, #SectorSize]
        LDR     r1, [sp, #SectorSize]
d718 1
a718 1
        LDR     lr, [r5, #RootDir]
d733 2
a734 2
        ; Check 0 < LinkBits < 17
        LDRB	r0, [sp, #LinkBits]
d739 1
a739 1
        DLINE   "Failed on LinkBits >= 20"
d744 2
a745 2
        ; Check 0 < LinkBits < 16
        LDRB    r0, [sp, #LinkBits]
d749 1
a749 1
        DLINE   "Failed on LinkBits >= 16"
d764 1
a764 1
        LDRB    r0, [sp, #SectorSize]
d767 2
a768 2
        ASSERT  (ZoneSpare :MOD: 4)=2
        LDR     r0, [sp, #ZoneSpare - 2]
d770 1
a770 1
        LDRB    r0, [sp, #LinkBits]
d774 3
a776 3
        LDRB    r0, [sp, #Zones]
        LDRB	r1, [sp, #Zones2]	; r1 is the target for the MUL below
        ADD	r0, r0, r1, LSL #8
d778 1
a778 1
        LDRB    r0, [sp, #Zones]
d781 1
a781 1
 	DREG	r0, "zones: "
d784 1
a784 1
        LDRB    r0, [sp, #LinkBits]
d786 1
a786 1
 	DREG	r0, "linkbits: "
d794 1
a794 1
        BNE     %FT85                   ; If shifting right by linkbits leaves a non-0
d798 1
a798 1
        LDRB    r0, [sp, #SectorSize]
d800 1
a800 1
        LDRB    r2, [sp, #LinkBits]
d803 1
a803 1
        ; if BigMaps then LinkBits can be more than MaxFreeLink, so test agains
d807 2
a808 2
        CMP	r2, #MaxFreeLinkBits
        MOVHI	r2, #MaxFreeLinkBits
d814 1
a814 1
        DLINE   "Failed on LinkBits < Zone length in bits"
d819 3
a821 3
        ; Check RAskew not being silly
        LDRB    r0, [sp, #RAskew]
        LDRB    r2, [sp, #SecsPerTrk]
d825 1
a825 1
        DLINE   "Failed on RASkew >= SecsPerTrk"
d835 7
a841 7
 	LDRB	r1, [sp, #LinkBits]
 	CMP	r1, #15
 	BHI	%FT10

        LDRB	r1, [sp, #DiscVersion]
	TEQS	r1, #0
        BNE	%FT10			; don't sanity check rootdir address
d847 3
a849 3
 	LDRB	r1, [sp, #Zones]
 	LDRB	r0, [sp, #Zones2]	; r0 due for corruption later
 	ADD	r1, r1, r0,LSL #8
d851 1
a851 1
        LDRB    r1, [sp, #Zones]
d854 1
a854 1
        LDRB    r0, [sp, #ShareSize]    ; factor in sharesize
d861 1
a861 1
        LDR     r0, [sp, #RootDir]
d867 3
a869 3
        LDRB    r1, [sp, #Zones]
        LDRB	r0, [sp, #Zones2]	; r0 due to be corrupted
        ADD	r1, r1, r0, LSL #8
d871 1
a871 1
        LDRB    r1, [sp, #Zones]
d876 1
a876 1
        LDR     r0, [sp, #RootDir]
d886 2
a887 2
        ; or, if Zones == 1, then &000002nn where nn = (&e00 + 1<<SectorSize - 1)>>SectorSize + 1
        LDRB    r1, [sp, #Zones]
d890 2
a891 2
 	LDREQB	r1, [sp, #Zones2]
 	TEQEQ	r1, #0		; have to also check that Zones2 is 0
d896 1
a896 1
        LDRB    r1, [sp, #SectorSize]
d914 1
a914 1
        ; Must be > ((Zones-1)*(8<<SectorSize-ZoneSpare)-Zone0Bits)<<BitSize
d921 2
a922 2
        LDRB    r1, [sp, #BigFlag]      ; check if its a big disc
	TSTS	r1, #BigFlagBit
d926 1
a926 1
        TST     r1, #BigDiscSupport
d932 1
a932 1
        LDRB    r1, [sp, #SectorSize]
d934 2
a935 2
        ASSERT  (ZoneSpare :MOD: 4)=2
        LDR     r1, [sp, #ZoneSpare - 2]
d938 3
a940 3
	LDRB	r1, [sp, #Zones]
	LDRB	lr, [sp, #Zones2]	; lr is safe to use
	ADD	r1, r1, lr, LSL #8
d942 1
a942 1
        LDRB    r1, [sp, #Zones]
d947 1
a947 1
        LDRB    r1, [sp, #BitSize]
d950 2
a951 2
	LDRB	lr, [sp, #SectorSize]
	SUBS	r1, r1, lr
d953 1
a953 1
	RSBMI	r0, r0, #0
d956 3
a958 3
	LDR	r1, [sp, #DiscSize]
	MOV	r1, r1, LSR lr
	LDR	r2, [sp, #DiscSize2]
d961 1
a961 1
	DREG	r2, "Discsize2 was "
d963 3
a965 3
	RSB	lr, lr, #32
	ORR	r1, r1, r2, LSL lr	; now full DiscSize in sectors in r1
	CMP	r1, r0
d968 1
a968 1
        LDR     r1, [sp, #DiscSize]
d994 8
a1001 8
        ASSERT  (LinkBits :MOD: 4)=0
        ASSERT  BitSize = LinkBits+1
        ASSERT  RAskew = BitSize+1
        ASSERT  BootOpt = RAskew+1
        LDR     r0, [sp, #LinkBits]
        STR     r0, [r5, #LinkBits]
        LDRB    r0, [sp, #Zones]
        STRB    r0, [r5, #Zones]
d1003 2
a1004 2
 	LDRB	r0, [sp, #Zones2]
 	STRB	r0, [r5, #Zones2]
d1006 6
a1011 6
        LDRB    r0, [sp, #ZoneSpare]
        STRB    r0, [r5, #ZoneSpare]
        LDRB    r0, [sp, #ZoneSpare+1]
        STRB    r0, [r5, #ZoneSpare+1]
        LDR     r0, [sp, #RootDir]
        LDR     r1, [r5, #RootDir]
d1015 2
a1016 2
	DREG	r1, "DiscBits from disc record are: "
	DREG	r0, "Setting RootDir to: (Identify, 968) "
d1018 3
a1020 3
        STR     r0, [r5, #RootDir]
        LDR     r0, [sp, #DiscSize]
        STR     r0, [r5, #DiscSize]
d1022 2
a1023 2
        LDR     r0, [sp, #DiscSize2]
        STR     r0, [r5, #DiscSize2]
d1025 2
a1026 2
        LDR     r0, [sp, #ShareSize]
        STR     r0, [r5, #ShareSize]
d1030 4
a1033 4
 	LDR	r0, [sp, #DiscVersion]
 	STR	r0, [r5, #DiscVersion]
 	LDR	r0, [sp, #RootDirSize]
 	STR	r0, [r5, #RootDirSize]
d1047 1
a1047 1
        ADD     sp, sp, #DiscRecSig2
d1049 1
a1049 1
        ADD     sp, sp, #DiscRecSig
d1079 1
a1079 1
        LDRB    r4, [r5, #SectorSize]
d1084 4
a1087 4
        LDRB    r9, [r5, #Zones]
        LDRB	r7, [r5, #Zones2]
        ADD	r9, r9, r7, LSL #8
        LDRB    r7, [r5, #SectorSize]
d1089 2
a1090 2
        LDRB    r7, [r5, #SectorSize]
        LDRB    r9, [r5, #Zones]
d1108 1
a1108 1
        LDRB    r4, [r5, #SectorSize]
d1142 1
a1142 1
        LDRB    r1, [r5, #SectorSize]
d1160 3
a1162 3
        LDRB    r0, [r5, #Zones]
        LDRB	r2, [r5, #Zones2]	; r2 should be ok here
        ADD	r0, r0, r2, LSL #8
d1164 1
a1164 1
        LDRB    r0, [r5, #Zones]
d1191 1
a1191 1
        LDRB    r8, [r5, #Zones]
d1193 2
a1194 2
 	LDRB	r0, [r5, #Zones2]
 	ADD	r8, r8, r0, LSL #8
d1196 1
a1196 1
        LDRB    r0, [r5, #SectorSize]
d1212 1
a1212 1
        LDRB    r4, [r5, #SectorSize]
d1238 1
a1238 1
        ; RASkew
d1251 8
a1258 10
	LDRB	r0,[r4,#Zones]		; this is spurious!

        ASSERT  SectorSize=0
        ASSERT  SecsPerTrk=1
        ASSERT  Heads=2
        ASSERT  Density=3
        ASSERT  LinkBits=4
        ASSERT  BitSize=5
        ASSERT  RAskew=6
        ASSERT  BootOpt=7
d1277 4
a1280 4
        ASSERT  LowSector=8
        ASSERT  Zones=9
        ASSERT  ZoneSpare=10
        ASSERT  RootDir=12
d1297 1
a1297 1
        ASSERT  DiscSize=16
d1299 1
a1299 1
	ASSERT	DiscSize2=36
d1306 3
a1308 3
        ASSERT  ShareSize=40
	ADDEQ	r4,r4,#DiscSize2-DiscSize-4
	ADDEQ	r14,r14,#DiscSize2-DiscSize-4
d1314 2
a1315 2
	ADDEQ	r4,r4,#DiscSize2-DiscSize-4
	ADDEQ	r14,r14,#DiscSize2-DiscSize-4
d1334 10
a1343 10
        ASSERT  (DiscId :MOD: 4) = 0
        ASSERT  DiscName = DiscId+2
        LDR     r0, [sp, #ZoneHead + DiscId]
        STR     r0, [r5, #DiscId]
        LDR     r0, [sp, #ZoneHead + DiscId+4]
        STR     r0, [r5, #DiscId+4]
        LDR     r0, [sp, #ZoneHead + DiscId+8]
        STR     r0, [r5, #DiscId+8]
        LDRB    r0, [sp, #ZoneHead + BootOpt]
        STRB    r0, [r5, #BootOpt]
d1354 1
a1354 1
        LDRB    r4, [r5, #SectorSize]
d1385 3
a1387 2
        LDRB    r0, [r5, #LowSector]
        AND     r0, r0, #LowSectorMask
d1398 1
a1398 1
        LDRB    r0, [r5, #SecsPerTrk]
d1406 1
a1406 1
        LDRB    r0, [r5, #SectorSize]
d1410 1
a1410 1
        DREG    r0,"SectorSize="
d1414 2
a1415 2
        LDRB    r0, [r5, #Density]
        TEQ     r0, #Double
d1426 1
a1426 1
        STR     r0, [r5, #DiscSize]
d1430 2
a1431 2
	STR	r0, [r5, #DiscSize2]
	; r0 is already 0 for SanityCheckOldMap
d1435 1
a1435 1
        STR     r0, [r5, #DiscSize]
d1528 1
a1528 1
        LDR     r7, [r5, #RootDir]
d1646 1
a1646 1
        STRB    r0, [r5, #BootOpt]
d1649 2
a1650 2
        LDRB    r0, [sp, #OldId]
        STRB    r0, [r5, #DiscId]
d1652 1
a1652 1
        STRB    r0, [r5, #DiscId+1]
d1656 1
a1656 1
        STRB    r0, [r5, #DiscName+0]
d1658 1
a1658 1
        STRB    r0, [r5, #DiscName+1]
d1660 1
a1660 1
        STRB    r0, [r5, #DiscName+2]
d1662 1
a1662 1
        STRB    r0, [r5, #DiscName+3]
d1664 1
a1664 1
        STRB    r0, [r5, #DiscName+4]
d1666 1
a1666 1
        STRB    r0, [r5, #DiscName+5]
d1668 1
a1668 1
        STRB    r0, [r5, #DiscName+6]
d1670 1
a1670 1
        STRB    r0, [r5, #DiscName+7]
d1672 1
a1672 1
        STRB    r0, [r5, #DiscName+8]
d1674 1
a1674 1
        STRB    r0, [r5, #DiscName+9]
d1678 1
a1678 1
        STR     r3, [r5, #DiscSize]
d1680 2
a1681 2
	MOV	r3, #0
	STR	r3, [r5, #DiscSize2]
d1710 5
a1714 5
        LDRB    r0, [r5, #LowSector]
        TST     r0, #SequenceSides
        ORR     r0, r0, #SequenceSides
        STRB    r0, [r5, #LowSector]
        LDRB    r0, [r5, #Heads]
d1716 1
a1716 1
        STREQB  r0, [r5, #Heads]
d1730 5
a1734 5
        LDRB    r0, [r5, #LowSector]
        TST     r0, #SequenceSides
        BIC     r0, r0, #SequenceSides
        STRB    r0, [r5, #LowSector]
        LDRB    r0, [r5, #Heads]
d1736 1
a1736 1
        STRNEB  r0, [r5, #Heads]
d1769 1
a1769 1
        MOV     r1, #CachedReadSecsOp :OR: 1:SHL:6      ; Ignore escape
d1809 1
a1809 1
        LDRB    lr, [r5, #SectorSize]
d1818 1
a1818 1
        MOV     r1, #CachedReadSecsOp :OR: 1:SHL:6      ; Ignore escape
d1827 1
a1827 1
        LDRB    lr, [r5, #SectorSize]
@


4.5
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d1302 2
a1303 2
        LDMEQIA r4!, {r0}
        LDMEQIA r14!, {r2}
d1317 2
a1318 2
        LDMEQIA r4!, {r0}
        LDMEQIA r14!, {r2}
@


4.4
log
@* Various 32-bit compatibility fixes.
* Can use HAL for FIQ+timer manipulations.
* FileCore_DiscOp64 added (as user API - currently just converted to the
  standard byte or sector DiscOp call to the underlying module). See
  Doc.32bitAPIs for full details.
* New error-passing scheme to modules added (for full 32-bit addressing).
* FileCore_Features added (indicates new error scheme).
* OS_FSControl 49 (read 32-bit free space) now reports sensible clamped
  values for large discs, rather than values modulo 2^32.
* Accessing the end of files near 2GB in size could cause lock-ups in
  background transfers.
* F(+) and G(+) disc formats adjusted to have a little more skew to
  help the rather poor Iyonix floppy controller.

Version 3.31. Tagged as 'FileCore-3_31'
@
text
@d595 2
a596 1
;  r2 = disc address of boot record
d598 1
a598 1
;  r2 = disc address of boot record
d989 1
a989 1
        ; Those fiedls which must be left to later are:
@


4.3
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d1762 4
d1767 1
d1769 1
a1769 2
        ORR     r1, r1, r5, ASL #6
        SWI     XFileCore_DiscOp
d1777 4
d1808 7
d1816 1
d1818 1
a1818 2
        ORR     r1, r1, r5, ASL #6
        SWI     XFileCore_SectorDiscOp
d1826 8
@


4.2
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d480 2
a481 1
        Push    "r0-r7,lr"
d483 1
a483 1
        Pull    "r0-r7,pc",EQ,^
d506 3
a508 1
        Pull    "r0-r7,pc",,^
d526 4
a529 2
	SETV
	MOVS	pc,lr
d585 1
@


4.1
log
@Initial revision
@
text
@d19 5
d40 1
a40 1
        Push    "r1,r2,r3,r8,lr"
d57 7
d67 3
d83 9
d108 1
a108 1
        Pull    "r1,r2,r3,r8,pc"
d278 17
d296 1
d434 8
d443 1
d724 12
d744 2
d765 5
d771 4
d777 3
d793 10
d825 18
d844 1
d858 1
d860 5
d881 4
d914 1
a914 1
        MOVS    r1, r1
d929 5
d935 1
d994 4
d1006 4
d1021 6
d1075 6
d1083 1
d1151 1
d1153 5
d1184 4
d1243 1
a1243 1
	LDRB	r0,[r4,#Zones]
@


4.1.4.1
log
@Changes made to FileCore to support allowing idlen more than 15.  This allows
smaller LFAUs on discs.  The changes are not yet complete.  In particular, the
number of disc zones is limited to 255.  Some development testing has been
peformed, and the filing system is generally stable.  Areas which haven't
been fully tested include things like *Defect, FileCore_LayoutStructure,
FileCore_FloppyStructure, and the FileSwitch APIs for reading and examining
a disc's used space.

This version should not be used for any OS Builds with the BigMaps flag set
to true.  It should build as a normal version of FileCore with BigMaps and
BigDirs set to false.
@
text
@a18 5
; change log:

; 15 May 1997: SBP: Changed SanityCheckEDiscRecord to support LinkBits up to 16.


a672 12
 [ BigMaps
        ; Check 0 < LinkBits < 17
        LDRB	r0, [sp, #LinkBits]
        CMP     r0, #16
        
 [ DebugL
        BLS     %FT01
        DLINE   "Failed on LinkBits >= 17"
01
 ]
 
 |
a680 2
 
 ]
a715 10
        
 [ BigMaps
        ; if BigMaps then LinkBits can be more than MaxFreeLink, so test agains
        ; MaxFreeLink (we're being paranoid here, since maximum sector is 1024
        ; bytes, needing 13 link bits)
        
        CMP	r2, #MaxFreeLinkBits
        MOVHI	r2, #MaxFreeLinkBits
 ]
 
a737 6
 [ BigMaps
        LDRB	r1, [sp, #LinkBits]
        CMP	r1, #15
        BGT	%FT10			; don't sanity check rootdir address
  ]
        
@


4.1.4.2
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@a718 5
 [ BigMaps
        LDRB    r0, [sp, #Zones]
        LDRB	r1, [sp, #Zones2]	; r1 is the target for the MUL below
        ADD	r0, r0, r1, LSL #8
 |
a719 1
 ]
d771 2
a772 7
 ]
 
 [ BigMaps
 	LDRB	r1, [sp, #Zones]
 	LDRB	r0, [sp, #Zones2]	; r0 due for corruption later
 	ADD	r1, r1, r0,LSL #8
 |
a773 1
 ]
a786 5
 [ BigMaps
        LDRB    r1, [sp, #Zones]
        LDRB	r0, [sp, #Zones2]	; r0 due to be corrupted
        ADD	r1, r1, r0, LSL #8
 |
a787 1
 ]
a803 4
 [ BigMaps
 	LDREQB	r1, [sp, #Zones2]
 	TEQEQ	r1, #0		; have to also check that Zones2 is 0
 ]
a847 5
 [ BigMaps
	LDRB	r1, [sp, #Zones]
	LDRB	lr, [sp, #Zones2]	; lr is safe to use
	ADD	r1, r1, lr, LSL #8
 |
a848 1
 ]
a906 4
 [ BigMaps
 	LDRB	r0, [sp, #Zones2]
 	STRB	r0, [r5, #Zones2]
 ]
a973 6
 [ BigMaps
        LDRB    r9, [r5, #Zones]
        LDRB	r7, [r5, #Zones2]
        ADD	r9, r9, r7, LSL #8
        LDRB    r7, [r5, #SectorSize]
 |
a975 1
 ]
a1042 5
 [ BigMaps
        LDRB    r0, [r5, #Zones]
        LDRB	r2, [r5, #Zones2]	; r2 should be ok here
        ADD	r0, r0, r2, LSL #8
 |
a1043 1
 ]
a1069 4
 [ BigMaps
 	LDRB	r0, [r5, #Zones2]
 	ADD	r8, r8, r0, LSL #8
 ]
d1125 1
a1125 1
	LDRB	r0,[r4,#Zones]		; this is spurious!
@


4.1.4.3
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@d681 1
a681 1
        CMP     r0, #19
d685 1
a685 1
        DLINE   "Failed on LinkBits >= 20"
a956 6
 ]
 [ BigDir
 	LDR	r0, [sp, #DiscVersion]
 	STR	r0, [r5, #DiscVersion]
 	LDR	r0, [sp, #RootDirSize]
 	STR	r0, [r5, #RootDirSize]
@


4.1.4.4
log
@Now supports formatting of floppies with long file names.
@
text
@a258 5
 [ BigDir
 	LDR	lr, [r5, #DiscVersion]   ; check if it's EX or FX
 	TEQ	lr, #0
 	BEQ	%FT15
 	
a259 13
 
        TEQ     lr, #Quad
        baddr   r1, EXFormat_DescribeTag, NE
        baddr   r1, FXFormat_DescribeTag, EQ
        BL      CopyFormatName

	B	%FT85

15
 ]

        LDRB    lr, [r5, #Density]
 
a725 3
 [ DebugL
 	DREG	r0, "zones: "
 ]
a727 3
 [ DebugL
 	DREG	r0, "linkbits: "
 ]
d774 3
a776 5
        LDRB	r1, [sp, #DiscVersion]
	TEQS	r1, #0
        BNE	%FT10			; don't sanity check rootdir address
        
      
d855 1
a855 1
	TSTS	r1, #BigFlagBit
@


4.1.4.5
log
@Fixed:

DoOsFunRenameBigDir to work when renaming a shared file between dirs where
the file ends up as the last object in the target dir.

SanityCheckEDiscRecord to allow idlen>15 when DiscVersion=0

GrowBigDir to round up desired size to a multiple of the disc allocation
size.

Also:

Implemented non-working code to write cache the dir buffer.  WriteCacheDir
compile switch set to FALSE in s.DebugOpts.  Don't set it to TRUE unless
I tell you it's working.

Made SortDir not attempt to sort more than 2047 entries in a dir, to
avoid it overflowing ScratchSpace.

Made SortPair do one extra shell on the sort (makes it more efficient).
@
text
@a797 5
 
 	LDRB	r1, [sp, #LinkBits]
 	CMP	r1, #15
 	BHI	%FT10
 
@


4.1.4.6
log
@Binary-chop dir scanning fixed.  (BigLexEqv fixed so that it doesn't
try to compare the dir separator '.' in eg "Default.Thing" with another
object called "Default+" (was breaking binary chop dir search).

Fixed IdentifyDisc (s.Identify); old behaviour left the RootDir field
invalid (the disc bits were an external drive number, instead of an
internal disc number).  This causes problems if the disc fails to mount
due to, for example, memory problems, as the illegal value never gets
fixed (normally, MountDiscOnDrive would end up correcting the problem).
@
text
@d40 1
a40 1
        Push    "r1,r2,r3,r8,r9,lr"
a56 3
	LDR	r9, [r5, #RootDir]
	AND	r9, r9, #DiscBits

a59 3
 [ DebugL
	DREG	r1, "Setting initial root dir address to: "
 ]
a72 9
	LDR	lr, [r5, #RootDir]
	BIC	lr, lr, #DiscBits
	ORR	lr, lr, r9
	STR	lr, [r5, #RootDir]

 [ DebugL
	DLINE	"Restoring internal disc numbering of RootDir: "
 ]

d89 1
a89 1
        Pull    "r1,r2,r3,r8,r9,pc"
d263 1
a263 1

d265 1
a265 1

d277 1
a277 1

d700 1
a700 1

d706 1
a706 1

d716 1
a716 1

d765 1
a765 1

d770 1
a770 1

d774 1
a774 1

d798 1
a798 1

d802 1
a802 1

d806 2
a807 2


d809 1
a809 1

a977 4
 [ DebugL
	DREG	r1, "DiscBits from disc record are: "
	DREG	r0, "Setting RootDir to: (Identify, 968) "
 ]
@


4.1.4.7
log
@Found a major inefficiency in the handling of file creation, closing of files
and other uses of the NextFree function.  In the case of file creation, the
problem was particularly bad on large free space maps, as the function was
of order N^2 on the size of the map, when the disc was nearly full.  As the
disc gets fuller, the problem gets worse; with 1400 zones in the map, N^2
is very large indeed.  This resulted in *cdir sometimes taking 1sec.

Now, a new function NextFree_Quick exists which performs similarly to NextFree,
but does not consider free spaces in zones beyond the current zone.  This
can be used by functions which need only examine free spaces in a given zone,
such as is the case in ClaimFreeSpace where it is stepping throigh zones to
find a single gap large enough for the entire file.

For other functions which work on a single zone, the speedup is less dramatic,
of the order N instead of N^2.
@
text
@a59 4
 [ DebugL
	DREG	r9, "Rootdir internally starts as: "
 ]

d85 1
a85 1
	DREG	lr, "Restoring internal disc numbering of RootDir: "
@


4.1.4.8
log
@Altered s.Identify; wasn't correctly returning a string describing the disc
format for F+ discs.

Altered s.Commands; *map now correctly reports big directories and a big
free space map.
@
text
@a433 8
 [ BigDir
	BVS	%FT01
	LDR	lr, [r5, #DiscVersion]
	TEQS	lr, #0
	baddr	r1, FFormat_DescribeTag, EQ
	baddr	r1, FXFormat_DescribeTag, NE
01
 |
a434 1
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

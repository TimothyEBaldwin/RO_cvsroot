head	4.18;
access;
symbols
	FileCore-3_75:4.18
	FileCore-3_74:4.18
	FileCore-3_73:4.18
	FileCore-3_72:4.18
	FileCore-3_71:4.18
	FileCore-3_70:4.18
	FileCore-3_69:4.18
	FileCore-3_68:4.18
	FileCore-3_67:4.18
	FileCore-3_66:4.18
	FileCore-3_65:4.18
	FileCore-3_64:4.18
	FileCore-3_63:4.18
	FileCore-3_62:4.18
	FileCore-3_61:4.17
	FileCore-3_60:4.17
	FileCore-3_59:4.17
	FileCore-3_58:4.17
	FileCore-3_57:4.17
	FileCore-3_56:4.17
	FileCore-3_55:4.16
	FileCore-3_54:4.15
	FileCore-3_53:4.14
	FileCore-3_52:4.14
	FileCore-3_51:4.14
	FileCore-3_50:4.14
	FileCore-3_49:4.13
	FileCore-3_48:4.13
	FileCore-3_47:4.13
	FileCore-3_46:4.13
	FileCore-3_45:4.12
	FileCore-3_44:4.11
	FileCore-3_43:4.11
	FileCore-3_42:4.11
	FileCore-3_41:4.11
	FileCore-3_40:4.10
	FileCore-3_39:4.10
	FileCore-3_38:4.10
	FileCore-3_37:4.10
	FileCore-3_36:4.10
	FileCore-3_35:4.10
	FileCore-3_34:4.10
	FileCore-3_33:4.9
	RO_5_07:4.8
	FileCore-3_32:4.8
	FileCore-3_31:4.8
	FileCore-3_30:4.7
	FileCore-3_29:4.6
	FileCore-3_28:4.6
	FileCore-3_25-4_9_2_2:4.6
	FileCore-3_27:4.6
	FileCore-3_26:4.6
	FileCore-3_22-4_6_2_1:4.4
	bavison_FileCore-3_22_dev_bp:4.4
	bavison_FileCore-3_22:4.4.0.2
	FileCore-3_25-4_9_2_1:4.6
	HAL:4.6.0.2
	FileCore-3_25:4.6
	FileCore-3_24:4.5
	FileCore-3_23:4.5
	dellis_autobuild_BaseSW:4.4
	FileCore-3_22:4.4
	Ursula_merge:4.2.2.5
	ROL_merge:4.2.2.5
	FileCore-3_21:4.4
	ROL_Ursula_merge:4.2.2.5
	Ursula_RiscPC_merge:4.2.2.4
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.7
	ROL_FileCore-3_21:4.2.2.5
	ROL_FileCore-3_20:4.2.2.5
	ROL:4.2.2.5.0.2
	ROL_bp:4.2.2.5
	Ursula_RiscPC_bp:4.2.2.4
	FileCore-3_18:4.2.2.5
	FileCore-3_01:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.4
	Ursula_RiscPC:4.2.2.4.0.2
	FileCore-3_00:4.3
	FileCore-2_99:4.3
	aglover_FileCore-3_17:4.2.2.5
	sproven_FileCore-3_16:4.2.2.4
	rthornb_UrsulaBuild-19Aug1998:4.2.2.4
	UrsulaBuild_FinalSoftload:4.2.2.4
	rthornb_UrsulaBuild-12Aug1998:4.2.2.4
	aglover_UrsulaBuild-05Aug1998:4.2.2.4
	rthornb_UrsulaBuild-29Jul1998:4.2.2.4
	rthornb_UrsulaBuild-22Jul1998:4.2.2.4
	rthornb_UrsulaBuild-15Jul1998:4.2.2.4
	rthornb_UrsulaBuild-07Jul1998:4.2.2.4
	rthornb_UrsulaBuild-17Jun1998:4.2.2.4
	rthornb_UrsulaBuild-03Jun1998:4.2.2.4
	rthornb_UrsulaBuild-27May1998:4.2.2.4
	rthornb_UrsulaBuild-21May1998:4.2.2.4
	sproven_FileCore-3_15:4.2.2.4
	sproven_314:4.2.2.4
	rthornb_UrsulaBuild_01May1998:4.2.2.4
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.2.2.4
	sproven_3_11:4.2.2.4
	sproven_3_10:4.2.2.4
	sproven_Ursula_3_09:4.2.2.4
	sproven_3_07:4.2.2.3
	sproven_3_06:4.2.2.3
	sproven_3_05:4.2.2.3
	sproven_3_04:4.2.2.3
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.2.2.3
	sproven_3_02:4.2.2.3
	sproven_3_01:4.2.2.2
	sproven_2_99:4.2.2.1
	sproven_2_98:4.2
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.18
date	2013.07.18.21.04.17;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	Em91CJgLrlPBMZXw;

4.17
date	2013.02.24.21.09.15;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	rgJG8ZFRF8o9ruFw;

4.16
date	2013.02.21.16.53.08;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	CCuV2tngKttj75Fw;

4.15
date	2012.10.28.08.52.32;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	6n5fY77YU7JEb8qw;

4.14
date	2012.04.14.00.43.17;	author bavison;	state Exp;
branches;
next	4.13;
commitid	xkSKw5i9HVYqOL0w;

4.13
date	2011.11.25.08.26.06;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	IoNdwgrOKH29UGIv;

4.12
date	2011.10.14.07.23.52;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	D2Id4aPp4zmuUhDv;

4.11
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	PKTDORFkNFRVOmzv;

4.10
date	2009.06.15.23.25.35;	author bavison;	state Exp;
branches;
next	4.9;

4.9
date	2009.05.17.01.48.32;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2003.04.03.18.33.28;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2001.05.14.16.26.36;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2000.10.31.17.05.06;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.30.13.26.35;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.09.11.37.01;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.09.21.12.07.28;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.18.40;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.32.24;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.08.14.13.13.19;	author sproven;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.09.16.14.46.50;	author sproven;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	97.11.17.13.32.42;	author sproven;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	98.02.11.16.49.28;	author sproven;	state Exp;
branches;
next	4.2.2.5;

4.2.2.5
date	98.09.09.08.37.20;	author aglover;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.32.24;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.40.42;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.22;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.15;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.18
log
@Minor tidy ups
Service call table made unconditional.
Typo in Hdr:FileCore corrected.
Comments improved, and other misc housekeeping.

Version 3.62. Tagged as 'FileCore-3_62'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >GenSWIs
;
; **************
; Change History
; **************
;
; 08-Sep-1994 SBP Improved commenting DoSwiCreate

        TTL     "General SWI routines"

        LTORG

; entry: R1=disc op
;        R2=disc address
;
; exit: VC->can do operation on this disc, R0 corrupt
;       VS->operation not permitted, R0 error

EnsureFSLock64 ROUT
        Push    "r1,r2,lr"
        LDRB    r2, [r2, #0]
        AND     r1, r1, #DiscOp_Op_Mask         ; get actual operation being done
; check this operation against list of write ops
        TEQ     r1, #DiscOp_WriteSecs
        TEQNE   r1, #DiscOp_WriteTrk
        BEQ     %FT04
        CLRV
        Pull    "r1, r2, pc"

EnsureFSLock
        Push    "r1,r2,lr"
        AND     r1, r1, #DiscOp_Op_Mask         ; get actual operation being done
; check this operation against list of write ops
        TEQ     r1, #DiscOp_WriteSecs
        TEQNE   r1, #DiscOp_WriteTrk
        BEQ     %FT01
        CLRV
        Pull    "r1, r2, pc"

; here when a write operation - check lock status
01
        MOV     r2, r2, LSR #(32-3)     ; get drive number
04      CMP     r2, #4
        Pull    "r1,r2,pc",LO           ; not hard disc - ignore

        SWI     Auto_Error_SWI_bit :OR: &44781 ; get the lock status
        BVC     %FT02
 [ :LNOT:NewErrors
        ORR     R0, R0, #ExternalErrorBit
 ]
        Pull    "r1,r2,pc"              ; if error then return it
02
; now check if FS is locked
        CMP     r0, #2
        BEQ     %FT03
        CLRV
 [ :LNOT:NewErrors
        ORR     R0,R0,#ExternalErrorBit
 ]
        Pull    "r1,r2,pc"              ; not locked

03
        LDRB    r0, FS_Id               ; get FSnumber
        CMP     r0, r1                  ; are they the same
        MOVEQ   r0, #FSLockedErr
        MOVNE   r0, #0
        BL      SetVOnR0
        Pull    "r1,r2,pc"


; Construct disc record from disc format structure
; entry: r4 -> format structure
; exit:  sp lowered by unknown amount
;        r5 -> disc record (contained in claimed stack)
;        other registers preserved

MakeDiscRecFromFormatStructure ROUT

        Push    "r1,r2,r3,lr"

 [ BigDisc
        SUB     sp, sp, #SzDiscRecSig2
 |
        SUB     sp, sp, #SzDiscRecSig
 ]
        LDR     lr, [r4, #DoFormatSectorSize]
        MOV     r3, #0
11
        MOVS    lr, lr, LSR #1
        ADDNE   r3, r3, #1
        BNE     %BT11
 [ DebugL :LOR: Debug2D
        DREG    r3, "SS=",cc
 ]
        STRB    r3, [sp, #DiscRecord_Log2SectorSize]
        LDRB    r3, [r4, #DoFormatSectorsPerTrk]
 [ DebugL :LOR: Debug2D
        DREG    r3, " SPT=",cc
 ]
        STRB    r3, [sp, #DiscRecord_SecsPerTrk]
        LDRB    r3, [r4, #DoFormatOptions]
        AND     r3, r3, #FormatOptSidesMask
        TEQ     r3, #FormatOptInterleaveSides
        MOVEQ   r3, #2
        MOVNE   r3, #1
 [ DebugL :LOR: Debug2D
        DREG    r3, " H=",cc
 ]
        STRB    r3, [sp, #DiscRecord_Heads]
        LDRB    r3, [r4, #DoFormatDensity]
 [ DebugL :LOR: Debug2D
        DREG    r3, " D=",cc
 ]
        STRB    r3, [sp, #DiscRecord_Density]
        MOV     r3, #0
        ASSERT  DiscRecord_IdLen :MOD: 4 = 0
        ASSERT  DiscRecord_Log2bpmb = DiscRecord_IdLen+1
        ASSERT  DiscRecord_Skew = DiscRecord_Log2bpmb+1
        ASSERT  DiscRecord_BootOpt = DiscRecord_Skew+1
        STR     r3, [sp, #DiscRecord_IdLen]

        MOV     r2, #&100
        LDRB    r3, [sp, #DiscRecord_SecsPerTrk]
        ADD     lr, r4, #DoFormatSectorList+2
12
        LDRB    r1, [lr], #4
        CMP     r1, r2
        MOVLO   r2, r1
        SUBS    r3, r3, #1
        BHI     %BT12

        LDRB    r3, [r4, #DoFormatOptions]
        AND     lr, r3, #FormatOptSidesMask
        TEQ     lr, #FormatOptInterleaveSides
        ORRNE   r2, r2, #DiscRecord_SequenceSides_Flag
        TST     r3, #FormatOptDoubleStep
        ORRNE   r2, r2, #DiscRecord_DoubleStep_Flag
 [ DebugL :LOR: Debug2D
        DREG    r2, " LS=",cc
 ]
        STRB    r2, [sp, #DiscRecord_LowSector]
        MOV     r1, #0
        STRB    r1, [sp, #DiscRecord_NZones]
 [ BigMaps
        STRB    r1, [sp, #DiscRecord_BigMap_NZones2]
 ]
        STRB    r1, [sp, #DiscRecord_ZoneSpare]
        STRB    r1, [sp, #DiscRecord_ZoneSpare+1]
 [ DebugL :LOR: Debug2D
        DREG    r1, "Setting RootDir to "
 ]
        STR     r1, [sp, #DiscRecord_Root]
        LDR     r1, [r4, #DoFormatCylindersPerDrive]

 [ BigDisc
; generate both parts of DiscSize
        LDRB    lr, [sp, #DiscRecord_SecsPerTrk]
        MUL     r1, lr, r1
        LDRB    lr, [sp, #DiscRecord_Log2SectorSize]
        ADD     lr, lr, #1
        RSB     r2, lr, #32
        MOV     r2, r1, LSR r2
        MOV     r1, r1, LSL lr
 [ DebugL :LOR: Debug2D
        DREG    r1, " DS1="
        DREG    r2, " DS2="
 ]
        STR     r2, [sp, #DiscRecord_BigMap_DiscSize2]
        STR     r1, [sp, #DiscRecord_DiscSize]
 |
        LDRB    lr, [sp, #DiscRecord_Log2SectorSize]
        ADD     lr, lr, #1
        MOV     r1, r1, ASL lr
        LDRB    lr, [sp, #DiscRecord_SecsPerTrk]
        MUL     r1, lr, r1
 [ DebugL :LOR: Debug2D
        DREG    r1, " DS="
 ]
        STR     r1, [sp, #DiscRecord_DiscSize]
 ]

        MOV     r1, #0
        STR     r1, [sp, #DiscRecord_DiscId]
        STR     r1, [sp, #DiscRecord_DiscName+2]
        STR     r1, [sp, #DiscRecord_DiscName+6]

        MOV     r5, sp

 [ BigDisc
        ADD     lr, sp, #SzDiscRecSig2
 |
        ADD     lr, sp, #SzDiscRecSig
 ]
        LDMIA   lr, {r1,r2,r3,pc}


DoSwiDiscOp ROUT
        Push    "r1,r5,r11,lr"
 [ Debug2 :LOR: Debug2D
        DREG    r1, "DiscOp(",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DLINE   ")"
 ]
 [ BigDisc
        BL      EnsureFSLock            ; check that we can actually do this
        Pull    "r1,r5,r11,pc",VS       ; if v set then return with error
 ]
        MOV     r11, sp
        EOR     R2, R2, #bit31          ; Convert to internal drive numbering

        ASSERT  SzDiscRec :MOD: 4 = 0
        MOVS    R5, R1, LSR #8
        MOVNE   R5, R5, LSL #2

        AND     R1, R1, #&FF            ; Remove any embarrasing bits from the op

        BNE     %FT20                   ;if disc rec supplied by caller

10
        ; Disc record not supplied by the user

        AND     lr, r1, #DiscOp_Op_Mask
        TEQ     lr, #DiscOp_WriteTrk
        TEQEQ   r3, #0
        BNE     %FT15

        BL      MakeDiscRecFromFormatStructure
        B       %FT30

15
        ; We must identify the disc to supply a disc record
        Push    "R1-R3"
        MOV     R1, R2, LSR #(32-3)     ;drive
        BL      WhatDisc                ;(R1->R0-R3,V)
        MOV     R5, R3
        Pull    "R1-R3"

        ; If error from WhatDisc then disc unreadable
        BVS     %FT95

        ; If disc record is internal, then the defect
        ; list _Definitely_ does not prefixing it
        BIC     R1, R1, #DiscOp_Op_AltDefectList_Flag
        B       %FT30

20
        ; For the situation when a disc record is supplied we do a PollChange
        ; here so that our idea of when the disc has changed doesn't get corrupted
        ; by a head step clearing the (physical) drive's 'disc has changed' line.
        MOV     R0, R2, LSR #(32-3)
        BL      PollChange

30
 [ BigDisc
        Push    "R3,R4"
        LDRB    R3,[R5,#DiscRecord_Log2SectorSize]      ; get sector size
        AND     R4,R2,#DiscBits
        BIC     R2,R2,#DiscBits
        ORR     R2,R4,R2,LSR R3         ; sector addr

        Pull    "R3,R4"
 [ DebugL :LOR: Debug2D
        DREG    r1, "DriveOp(",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DLINE   ")"
 ]
        BL      RetryDriveOp            ;
;       LDR     LR,DiscOp_ByteAddr      ; get end addr
        Push    "R3"
 [ DebugL :LOR: Debug2D
        DREG    R2, "Original address : "
 ]
        LDRB    R3,[R5,#DiscRecord_Log2SectorSize]
        BIC     LR,R2,#DiscBits
        AND     R2,R2,#DiscBits
        ORR     R2,R2,LR,LSL R3
 [ DebugL :LOR: Debug2D
        DREG    R3, "Log2SectorSize : "
        DREG    R2, "Result address : "
 ]
        Pull    "R3"
 |
        BL      RetryDriveOp            ;(R1-R6->R0,R2-R4,R6,V)
 ]

        MOVVC   R0, #0
95
        EOR     R2, R2, #bit31          ; Convert back to external drive numbering
        MOV     sp, r11
        Pull    "r1,r5,r11,PC"


DoSwiSectorDiscOp ROUT
        Push    "r1,r5,r11,lr"
 [ Debug2 :LOR: Debug2D
        DREG    r1, "SectorDiscOp(",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DLINE   ")"
 ]
 [ BigDisc
        BL      EnsureFSLock            ; check that we can actually do this; if V set
                                        ; then return with error
        Pull    "r1,r5,r11,pc",VS
 ]
        MOV     r11, sp
        EOR     R2, R2, #bit31          ; Convert to internal drive numbering

        ASSERT  SzDiscRec :MOD: 4 = 0
        MOVS    R5, R1, LSR #8
        MOVNE   R5, R5, LSL #2

        AND     R1, R1, #&FF            ; Remove any embarasing bits from the op

        BNE     %FT20                   ;if disc rec supplied by caller

10
        ; Disc record not supplied by the user

        AND     lr, r1, #DiscOp_Op_Mask
        TEQ     lr, #DiscOp_WriteTrk
        TEQEQ   r3, #0
        BNE     %FT15

        BL      MakeDiscRecFromFormatStructure
        B       %FT30

15
        ; We must identify the disc to supply a disc record
        Push    "R1-R3"
        MOV     R1, R2, LSR #(32-3)     ;drive
        BL      WhatDisc                ;(R1->R0-R3,V)
        MOV     R5, R3
        Pull    "R1-R3"

        ; If error from WhatDisc then disc unreadable
        BVS     %FT95

        ; If disc record is internal, then the defect
        ; list _Definitely_ does not prefixing it
        BIC     R1, R1, #DiscOp_Op_AltDefectList_Flag
        B       %FT30

20
        ; For the situation when a disc record is supplied we do a PollChange
        ; here so that our idea of when the disc has changed doesn't get corrupted
        ; by a head step clearing the (physical) drive's 'disc has changed' line.
        MOV     R0, R2, LSR #(32-3)
        BL      PollChange

30
        BL      RetryDriveOp            ;(R1-R6->R0,R2-R4,R6,V)

        MOVVC   R0, #0
95
        EOR     R2, R2, #bit31          ; Convert back to external drive numbering
        MOV     sp, r11
        Pull    "r1,r5,r11,PC"


DoSwiDiscOp64 ROUT
        Push    "r1,r2,r5,r11,lr"
DO64_R2Offset * 4
 [ Debug2 :LOR: Debug2D
        DREG    r1, "DiscOp(",cc
        LDRB    lr, [r2, #ExtendedDiscAddress_DriveNumber]
        DREG    lr, ",:",cc,Byte
        LDR     lr, [r2, #ExtendedDiscAddress_LowWord]
        DREG    lr, "/",cc
        LDR     lr, [r2, #ExtendedDiscAddress_HighWord]
        DREG    lr,    ,cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DREG    r5, ",",cc
        DLINE   ")"
 ]
        LDRB    LR, [R2, #ExtendedDiscAddress_DriveNumber]

        MOV     r11, sp

        CMP     LR, #8
        BHS     DO64_BadDrive

 [ BigDisc
        BL      EnsureFSLock64          ; check that we can actually do this
        Pull    "r1,r2,r5,r11,pc",VS    ; if v set then return with error
 ]

        AND     R1, R1, #&FF            ; Remove any embarrasing bits from the op

        TEQ     R5, #0
        BNE     %FT20                   ;if disc rec supplied by caller

10
        ; Disc record not supplied by the user

        AND     lr, r1, #DiscOp_Op_Mask
        TEQ     lr, #DiscOp_WriteTrk
        TEQEQ   r3, #0
        BNE     %FT15

        BL      MakeDiscRecFromFormatStructure
        B       %FT30

15
        ; We must identify the disc to supply a disc record
        LDRB    LR, [R2, #ExtendedDiscAddress_DriveNumber]
        Push    "R1-R3"
        EOR     R1, LR, #bit2           ;convert to internal numbering
        BL      WhatDisc                ;(R1->R0-R3,V)
        MOV     R5, R3
        Pull    "R1-R3"

        ; If error from WhatDisc then disc unreadable
        BVS     %FT95

        ; If disc record is internal, then the defect
        ; list _Definitely_ does not prefixing it
        BIC     R1, R1, #DiscOp_Op_AltDefectList_Flag
        B       %FT30

20
        ; For the situation when a disc record is supplied we do a PollChange
        ; here so that our idea of when the disc has changed doesn't get corrupted
        ; by a head step clearing the (physical) drive's 'disc has changed' line.
        LDRB    R0, [R2, #ExtendedDiscAddress_DriveNumber]
        EOR     R0, R0, #bit2           ;convert to internal numbering
        BL      PollChange

30
 [ BigDisc
        Push    "R1,R3"
        LDRB    R3,[R5,#DiscRecord_Log2SectorSize]      ; get sector size
        LDMIB   R2,{R1,LR}              ; turn 64-bit byte address + drive into packed
        LDRB    R2,[R2,#ExtendedDiscAddress_DriveNumber]
        RSB     R0,R3,#32
        MOV     R1,R1,LSR R3
        ORR     R1,R1,LR,LSL R0
        MOVS    LR,LR,LSR R3            ; ensure no overflow
        TSTEQ   R1,#DiscBits
        BNE     DO64_Overflow
        ORR     R2,R1,R2,LSL #(32-3)    ; sector addr
        EOR     R2, R2, #bit31          ; Convert to internal drive numbering

 [ DebugL :LOR: Debug2D
        DREG    R2, "Original address : "
        DREG    R3, "Log2SectorSize : "
 ]

        Pull    "R1,R3"
 [ DebugL :LOR: Debug2D
        DREG    r1, "DriveOp(",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DLINE   ")"
 ]
        BL      RetryDriveOp            ;
;       LDR     LR,DiscOp_ByteAddr      ; get end addr
        LDRB    R5,[R5,#DiscRecord_Log2SectorSize]
        LDR     R1,[SP, #DO64_R2Offset]
        BIC     R2,R2,#DiscBits
        RSB     LR,R5,#32
        MOV     LR,R2,LSR LR
        MOV     R2,R2,LSL R5
        STMIB   R1,{R2,LR}
 [ DebugL :LOR: Debug2D
        DREG    LR, "Result address : ",cc
        DREG    R2
 ]
 |
        LDRB    R0, [R2,#0]
        LDMIB   R2, {R2, LR}
        TST     R2, #DiscBits
        TEQEQ   LR, #0
        BNE     DO64_Overflow
        ORR     R2, R2, R0, LSL #(32-3)
        EOR     R2, R2, #bit31          ; Convert to internal drive numbering
        BL      RetryDriveOp            ;(R1-R6->R0,R2-R4,R6,V)
        LDR     LR, [sp, #DO64_R2Offset]
        BIC     R2, R2, #DiscBits
        STR     R2, [LR, #4]
 ]

        MOVVC   R0, #0
95
        MOV     sp, r11
        Pull    "r1,r2,r5,r11,PC"

DO64_BadDrive
        MOV     R0, #BadDriveErr
        BL      SetV
        B       %BT95

DO64_Overflow
        MOV     R0, #BadParmsErr
        BL      SetV
        B       %BT95


; ***************************************************************************
;
; SWI FileCore_Create, after a few centuries, arrives here.
;
; SBP:  This routine is simply a veneer, which puts the arguments for
;       FileCore_Create onto the stack, and then initialises a new
;       instantiation of filecore with the name 'FileCore%FSname'.
;       The address of the arguments is passed onto the new instantiation
;       as a string, ie the string passed to OS_Module is, for example,
;
;       'FileCore%ADFS <hex number>'

Dummy ROUT
00
 = "FileCore"
01
 = "%"
        ALIGN
DoSwiCreate
        TEQS    R0, #0          ;return if just dummy call to check Filecore's  existence
        MOVEQ   PC, LR
        Push    "R0-R6,LR"
        MOV     R6, SP          ;to restore stack at end
        MOV     R3, SP          ;to convert to hex string

        LDR     R4, [R0,#Create_Title]
        ADD     R4, R4, R1      ;name start
        MOV     R1, SP          ;to point to last byte of string built

        MOV     R5, #0          ;put string terminator
        BL      %FT99           ;R1,R5,SP->R1,SP
05                      ;put hex string for ptr to stacked regs
        AND     R5, R3, #&F
        CMPS    R5, #10
        ADDHS   R5, R5, #"A"-10
        ADDLO   R5, R5, #"0"
        BL      %FT99
        MOVS    R3, R3, LSR #4
        BNE     %BT05

        MOV     R5, #" "        ;put space separator
        BL      %FT99

        MOV     R3, R4
10                      ;find fs name end
        LDRB    R5, [R3],#1
        CMPS    R5, #" "
        BHI     %BT10

        SUB     R3, R3, #1
15                      ;copy fs name
        CMPS    R3, R4
        BLS     %FT18
        LDRB    R5, [R3,#-1] !
        BL      %FT99
        B       %BT15

18
        baddr   R3, %B00        ;copy FileCore%
        baddr   R4, %B01
20
        LDRB    R5, [R4],#-1
        BL      %FT99
        CMPS    R4, R3
        BHS     %BT20

        MOV     R0, #ModHandReason_NewIncarnation
        BL      OnlyXOS_Module
 [ Debug2
        DebugError "Create filecore instantiation: "
 ]
        MOVVC   R0, #ModHandReason_LookupName
        BLVC    OnlyXOS_Module
        LDRVC   R0, [R4,# :INDEX: PrivateWord]

        ADD     SP, R6, #4*4    ;return workspace
        ADRL    R1, FloppyOpDone
        ADRL    R2, WinnieOpDone
        ADR     R3, ParentFiqRelease
        Pull    "R4-R6,PC"

; SBP: I added the comments here because I found the code hard to follow.
;      Next time, it'll be easier :*)

; Entry:
;      R1: address of last pushed byte
;      R5: byte to store
;      SP: stack pointer, word aligned just below R1
;
; Exit:
;      R1 dropped 1 byte, points to stored value
;      SP updated to keep it at highest word boundary at or below R1

99
        TSTS    R1, #3                  ; are we going to cross a word boundary?
        SUBEQ   SP, SP, #4              ; yes, so drag SP down to next boundary
        STRB    R5, [R1,#-1] !          ; store byte and drop ptr
        MOV     PC, LR                  ; byebye



; <<<<<<<<<<<<<<<<
; ParentFiqRelease
; <<<<<<<<<<<<<<<<

ParentFiqRelease
        Push    "LR"
        getSB
 [ DebugI
        DLINE   " R1 ",cc
 ]
        BL      ReleaseFiq
        Pull    "PC"



DoSwiDrives ROUT
        LDRB    R0, Drive
        EOR     R0, R0, #4
        LDRB    R1, Floppies
        LDRB    R2, Winnies
        MOV     PC, LR


DoSwiFreeSpace ROUT
;entry R0 -> disc spec
;exit  R0 = total free space
;      R1 = largest obj that can be created
        Push    "r2,r3,r11,LR"

        MOV     r11, sp

        MOV     r1, r0
        BL      strlen
        MOV     r2, r3
        LDR     r1, FS_Title
        BL      strlen
        ADD     r3, r3, r2
        ADD     r3, r3, #2 + 1 + 3      ; 2 for ::, one for terminator, 3 for round-up
        BIC     r3, r3, #3

        SUB     sp, sp, r3
        MOV     r2, r1                  ; FS_Title
        MOV     r1, sp
        BL      strcpy
        BL      strlen
        ADD     r1, r1, r3
        MOV     lr, #":"
        STRB    lr, [r1], #1            ; ::
        STRB    lr, [r1], #1
        MOV     r2, r0
        LDRB    lr, [r2]                ; disc specifier (excluding : prefix)
        TEQ     lr, #":"
        ADDEQ   r2, r2, #1
        BL      strcpy

        MOV     r0, #FSControl_ReadFreeSpace
        MOV     r1, sp
 [ Debug2
        DSTRING r1, "FSControl_ReadFreeSpace(",cc
        DLINE   ")"
 ]
        BL      DoXOS_FSControl

        MOV     sp, r11

95
        Pull    "r2,r3,r11,PC"

 [ BigDisc

DoSwiFreeSpace64 ROUT
;entry R0 -> disc spec
;exit  R0 = total free space
;      R1 = largest obj that can be created
        Push    "r3,r4,r11,LR"

        MOV     r11, sp

        MOV     r1, r0
        BL      strlen
        MOV     r2, r3
        LDR     r1, FS_Title
        BL      strlen
        ADD     r3, r3, r2
        ADD     r3, r3, #2 + 1 + 3      ; 2 for ::, one for terminator, 3 for round-up
        BIC     r3, r3, #3

        SUB     sp, sp, r3
        MOV     r2, r1                  ; FS_Title
        MOV     r1, sp
        BL      strcpy
        BL      strlen
        ADD     r1, r1, r3
        MOV     lr, #":"
        STRB    lr, [r1], #1            ; ::
        STRB    lr, [r1], #1
        MOV     r2, r0
        LDRB    lr, [r2]                ; disc specifier (excluding : prefix)
        TEQ     lr, #":"
        ADDEQ   r2, r2, #1
        BL      strcpy

        MOV     r0, #FSControl_ReadFreeSpace64
        MOV     r1, sp
 [ Debug2
        DSTRING r1, "FSControl_ReadFreeSpace64(",cc
        DLINE   ")"
 ]
        BL      DoXOS_FSControl

        MOV     sp, r11

95
        Pull    "r3,r4,r11,PC"
 ]

DoSwiFloppyStructure ROUT
;entry
; R0 -> buffer
; R1 -> DiscRec
; R2    OldMapFlag, OldDirFlag set if appropriate
; R3 -> defect list
;exit
; R0, V set if error
; R3    structure size

        Push    "R0-R11,LR"
 [ Debug2
        DREG    R0, "", cc
        DREG    R1, ", ", cc
        DREG    R2, " ", cc
        DLINE   ">DoSwiFloppyStructure"
 ]
        LDMIA   SP, {R3,R4,R8,R9}
        CMPS    R8, #OldMapFlag
        MOVLO   R1, #SzNewFloppyFs*2    ;E
        MOVEQ   R1, #1*K                ;D
        MOVHI   R1, #SzOldFs            ;L
        BL      ZeroRam                 ;(R0,R1)
        ADD     R5, R3, R1
        BLO     %FT40           ;new map

;BUILD OLD MAP
 [ Debug2
        DLINE    "build old map"
 ]
        ADDEQ   LR, R1, #NewDirSize
        ADDHI   LR, R1, #OldDirSize
        STR     LR, [SP, #3*4]          ;exit R3
        ASSERT  FreeStart :MOD: 4 = 0
        MOV     LR, LR, LSR #8
        STR     LR, [R0, #FreeStart]
        LDR     R2, [R4, #DiscRecord_DiscSize]
        MOV     R2, R2, LSR #8
        ASSERT  OldSize :MOD: 4 =0
        STR     R2, [R0, #OldSize]
        SUB     LR, R2, LR
        ASSERT  FreeLen :MOD: 4 = 0
        STR     LR, [R0, #FreeLen]
        LDRB    LR, [R4, #DiscRecord_BootOpt]
        STRB    LR, [R0, #OldBoot]
        MOV     LR, #3
        STRB    LR, [R0, #FreeEnd]

        ADD     R1, R4, #DiscRecord_DiscName
        ADD     R2, R0, #OldName0
        MOV     R6, #NameLen
20
        LDRB    LR, [R1], #1
        STRB    LR, [R2], #OldName1-OldName0
        LDRB    LR, [R1], #1
        STRB    LR, [R2], #1-(OldName1-OldName0)
        SUBS    R6, R6, #2
        BNE     %BT20

        MOV     R1, #SzOldFs/2
        BL      CheckSum                ;(R0,R1->R2,V)
        STRB    R2, [R0, #Check0]
        BL      OldRandomId             ;(R0)
        B       %FT60

30                              ;(R4-R5,R8-R10->R7,R9)
        Push    "R0,R11,LR"
        LDR     R0, [R9]                ;get next defect
        CMPS    R0, #bit29              ;special case end marker to end of zone
        BLO     %FT35
        CLRV
        MOV     R7, R2
        Pull    "R0,R11,PC"             ;amg MED-03799  7th October 1994
                                        ;don't hang around if this is the end marker
                                        ;because the tests below eventually forget!
35
 [ BigDisc
        Push    "R1"
        LDRB    R1,[R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R0, R0, LSR R1
        Pull    "R1"
 ]
        BL      DiscAddToMapPtr         ;(R0,R10->R11,LR)
        BIC     R7, R11,R5
        ADD     R9, R9, #4              ;advance in defect list if not end
        SUBS    R11,R8, R7
        CMPNES  R11,R4                  ;if defect too close to end of zone
        SUBLT   R7, R8, R4              ;then adjust
        SUBS    R11,R2, R7
        CMPNES  R11,R4
        SUBLO   R7, R2, R4
        CLRV
        Pull    "R0,R11,PC"

;BUILD NEW MAP
40
 [ Debug2
        DLINE    "build new map"
 ]
        ADD     LR, R1, #NewDirSize
        STR     LR, [SP, #3*4]          ;exit R3
        ADD     R1, R0, #ZoneHead       ;copy structure from disc rec
        MOV     R0, R4
        MOV     R2, #SzDiscRecSig
        BL      BlockMove               ;(R0-R2)

        SUB     R10,R1, #ZoneHead       ;First 4 bytes, free link etc
        MOV     LR, #1 :SHL: (FreeLink*8+15)
        ORR     LR, LR, #&FF :SHL: (CrossCheck*8)
        STR     LR, [R10]

 [ BigDisc
        MOV     R0, #((SzNewFloppyFs * 2) + NewDirSize)
        Push    "R1"
        LDRB    R1, [R10,#ZoneHead+DiscRecord_Log2SectorSize]   ; get the sector size
        MOV     R0, R0, LSR R1
        Pull    "R1"
 |
        MOV     R0, #(SzNewFloppyFs * 2) + NewDirSize
 ]
        BL      DiscAddToMapPtr         ;(R0,R10->R11,LR)

        MOV     R1, #(ZoneHead + ZoneDiscRecSz) * 8     ;entry for maps and root
        MOV     R0, #2
 [ BigMaps
        BL      FragWrLinkBits          ;(R0,R1,R10)
 |
        BL      WrLinkBits              ;(R0,R1,R10)
 ]
        SUB     R0, R11,R1
        Push    "R4,R5,R8"
        BL      MinMapObj               ;(R10->LR)
        CMPS    R0, LR
        MOVLO   R0, LR
        ADDLO   R11,R1, LR
 [ BigMaps
        BL      FragWrLenBits           ;(R0,R1,R10)
 |
        BL      WrLenBits               ;(R0,R1,R10)
 ]

        MOV     R3, R11                 ;init free start

        LDR     R0, [R4, #DiscRecord_DiscSize]

        SUB     R0, R0, #1
 [ BigDisc
        BL      ByteDiscAddToMapPtr     ;(R0,R10->R11,LR) (to fix RAMFS discs coming out truncated)
 |
        BL      DiscAddToMapPtr         ;(R0,R10->R11,LR)
 ]

        ADD     R2, R11,#1              ;disc end map ptr

        BL      AllocBitWidth           ;(R10->LR)
        SUB     R5, LR, #1
        BIC     R2, R2, R5
        BL      MinMapObj               ;(R10->LR)
        MOV     R4, LR
        MOV     R6, #FreeLink*8         ;init previous gap
        LDRB    R8, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     LR, #8
        MOV     R8, LR, LSL R8          ;bits in a sector
        BL      %BT30                   ;(R4-R5,R8-R10->R7,R9)
        SUBS    R11,R7, R3
        MOVMI   R0, #DefectErr
        ADDMI   SP, SP, #(3+1)*4
        BLMI    SetV
        Pull    "R1-R11,PC",MI
        CMPS    R11,R4                  ;if defect too close to free start
        MOVLO   R7, R3                  ;then adjust
42
        SUBS    R0, R7, R3              ;IF there is some free space
        MOVHI   R1, R3                  ;THEN
 [ BigMaps
        BLHI    FragWrLenBits           ; set its length (R0,R1,R10)
 |
        BLHI    WrLenBits               ; set its length (R0,R1,R10)
 ]
        MOVHI   R1, R6                  ; point previous free space at it
        SUBHI   R0, R3, R6
 [ BigMaps
        BLHI    FragWrLinkBits          ; (R0,R1,R10)
 |
        BLHI    WrLinkBits              ; (R0,R1,R10)
 ]
        MOVHI   R6, R3                  ; update previous free space

        MOV     R1, R7                  ;defect start map ptr
        CMPS    R7, R8
        BHS     %FT50
        ADD     R3, R7, R4              ;defect end map ptr
44
        SUB     LR, R2, R3
        CMPS    LR, R4
        MOVLT   R3, R8
        BLT     %FT48

46
        BL      %BT30                   ;(R4-R5,R8-R10->R7,R9)
        SUBS    LR, R7, R3
        BLO     %BT46
        CMPS    LR, R4
        ADDLO   R3, R7, R5
        ADDLO   R3, R3, #1
        BLO     %BT44

48
        SUB     R0, R3, R1
 [ BigMaps
        BL      FragWrLenBits           ;(R0,R1,R10)
 |
        BL      WrLenBits               ;(R0,R1,R10)
 ]
        MOV     R0, #1
 [ BigMaps
        BL      FragWrLinkBits          ;(R0,R1,R10)
 |
        BL      WrLinkBits              ;(R0,R1,R10)
 ]

        SUB     LR, R3, R2
        CMPS    LR, R4
        SUBGE   R0, R2, R1
        CMPGES  R0, R4
 [ BigMaps
        BLGE    FragWrLenBits           ;(R0,R1,R10)
 |
        BLGE    WrLenBits               ;(R0,R1,R10)
 ]
        MOVGE   R1, R2
        MOVGE   R0, #1
 [ BigMaps
        BLGE    FragWrLinkBits          ;(R0,R1,R10)
 |
        BLGE    WrLinkBits              ;(R0,R1,R10)
 ]

        CMPS    R3, R8
        BLO     %BT42
50
        Pull    "R4,R5,R8"

        MOV     R0, R10
        BL      NewRandomId             ;(R0)
        MOV     R2, #SzNewFloppyFs
        ADD     R1, R0, R2
        ASSERT  SzNewFloppyFs :MOD: 256 = 0
        BL      Move256n                ;(R0-R2->R0-R2)

;BUILD ROOT DIRECTORY
60
 [ Debug2
        DLINE    "build $"
 ]
        LDR     R2, [R4, #DiscRecord_Root]
        TSTS    R8, #OldMapFlag
        MOVNE   R2, R2, LSR #8

        MOV     R0, R5
        TSTS    R8, #OldDirFlag
        MOVEQ   R1, #NewDirSize
        MOVNE   R1, #OldDirSize
        BL      ZeroRam
        ADD     R6, R5, R1
        ADDNE   R7, R6, #OldDirLastMark+1       ;dir tail
        ADDEQ   R7, R6, #NewDirLastMark+1
        MOV     LR, #0
        STRB    LR, [R5]                ;zero byte corrupted by calls to MarkZone

        MOV     R0, #"$"
        STREQB  R0, [R6,#NewDirName]
        STREQB  R0, [R6,#NewDirTitle]
        STRNEB  R0, [R6,#OldDirName]
        STRNEB  R0, [R6,#OldDirTitle]
        ADDEQ   R0, R6, #NewDirParent
        ADDNE   R0, R6, #OldDirParent
        MOV     R1, R2
        Write3                                  ;(R0,R1)

        TSTS    R8, #OldMapFlag
        BL      WriteNames      ;(R5,R6,Z)

        BL      FormDirCheckByte                ;(R5-R7->LR,Z)
        STRB    LR, [R6,#DirCheckByte]

        CLRV
        Pull    "R0-R11,PC"

DoSwiDescribeDisc ROUT
;entry R0 -> disc spec
;      R1 -> 64 byte buffer to fill in with disc record
        Push    "R0-R9,LR"

        ; LookUp the disc name to get a disc address and record
        MOV     R1, R0
        MOV     R2, #MustBeDisc
        BL      FullLookUp      ;(R1,R2->R0-R6,V)
        BVS     %FT90

        ; Zero the disc record
        LDR     R0, [SP,#4]
        MOV     R1, #64
        BL      ZeroRam

        ; Get source and destination disc record addresses
        BL      DiscAddToRec    ;(R3->LR)
        LDR     R0, [SP,#4]

        ; Pick up the main body of the disc record
        ASSERT  SzDiscRecSig=8*4
        LDMIA   LR, {R2-R9}

        ; Correct the RootDir to be an external drive address
        ASSERT  DiscRecord_Root = 3*4
        BIC     R5, R5, #DiscBits
        LDRB    R1, [LR, #DiscsDrv]
        ORR     R5, R5, R1, ASL #(32-3)
        EOR     R5, R5, #bit31

        ; Plonk the contents of the disc record (corrected)
        STMIA   R0, {R2-R9}

        ; And the disc type
        LDR     R1, [LR, #DiscRecord_DiscType]
        ASSERT  DiscRecord_DiscType = SzDiscRecSig
        STR     R1, [R0, #DiscRecord_DiscType]

 [ BigDisc
        ; and the DiscSize2 field
        LDR     R1, [LR, #DiscRecord_BigMap_DiscSize2]
        STR     R1, [R0, #DiscRecord_BigMap_DiscSize2]
 ]
 [ BigShare
        LDR     R1, [LR, #DiscRecord_BigMap_ShareSize]
        STR     R1, [R0, #DiscRecord_BigMap_ShareSize]
 ]
 [ BigDir
        ;amg v3.17. Return DiscVersion and RootDirSize as per spec
        LDR     R1, [LR, #DiscRecord_BigDir_DiscVersion]
        STR     R1, [R0, #DiscRecord_BigDir_DiscVersion]
        LDR     R1, [LR, #DiscRecord_BigDir_RootDirSize]
        STR     R1, [R0, #DiscRecord_BigDir_RootDirSize]
 ]
90
        STRVS   R0, [SP]
        Pull    "R0-R9,PC"

DoSwiDiscardReadSectorsCache ROUT
        Push    "r0-r2,r6,LR"
        MOV     r0, #ModHandReason_Free
10
        MOVS    r2, r6
        Pull    "r0-r2,r6,PC",EQ
        LDR     r6, [r6, #SectorCache_Next]
        SWI     XOS_Module
        BVC     %BT10
        STR     r0, [sp]
        Pull    "r0-r2,r6,PC"

DoSwiMiscOp ROUT
        Push    "lr"
 [ BigDisc
        TEQS    R0,#MiscOp_ReadInfo
        BEQ     %FT01
 ]
        CMP     r0, #MiscOp_FirstUnknown
        MOVHS   r0, #BadParmsErr
        SETV    HS
        EORVC   r1, r1, #4
        BLVC    CheckDriveNumber
        BVS     %FT90
 [ BigDisc
01
 ]
        JumpAddress LR, %F10, forward
        ADD     PC, PC, R0, LSL #2
        NOP
05
        B       DoSwiMiscOp_Mount
        B       DoSwiMiscOp_PollChanged
        B       DoSwiMiscOp_LockDrive
        B       DoSwiMiscOp_UnlockDrive
        B       DoSwiMiscOp_PollPeriod
        B       DoSwiMiscOp_Eject
        B       DoSwiMiscOp_Info
 [ DriveStatus
        B       DoSwiMiscOp_DriveStatus
 ]
10

90
        Pull    "pc"

DoSwiMiscOp_Mount
        Push    "r0,r6,lr"
        MOV     r0, #DensityFixedDisc
        STRB    r0, [r5, #DiscRecord_Density]
        TST     r1, #4
        LDREQ   r0, WinnieProcessBlk
        MOVEQ   r6, #WinnieLock
        LDRNE   r0, FloppyProcessBlk
        MOVNE   r6, #FloppyLock
        BL      Mount
        STRVS   r0, [sp]
        Pull    "r0,r6,pc"
DoSwiMiscOp_PollChanged
        Push    "lr"
        BL      LowPollChange
        Pull    "pc"
DoSwiMiscOp_LockDrive
        Push    "lr"
        BL      LockDrive
        Pull    "pc"
DoSwiMiscOp_UnlockDrive
        Push    "lr"
        BL      UnlockDrive
        Pull    "pc"
DoSwiMiscOp_PollPeriod
        Push    "lr"
        BL      Parent_Misc
        Pull    "pc"
 [ DriveStatus
DoSwiMiscOp_DriveStatus
        Push    "lr"
        LDR     lr, FS_Flags
        TSTS    lr, #CreateFlag_DriveStatusWorks
        MOVEQ   r2, #0
        BLNE    Parent_Misc
        Pull    "pc"
 ]

; OSS Only eject if drive claims to support it and drive exists.

DoSwiMiscOp_Eject
        Push    "lr"
        LDR     lr, FS_Flags
        CMP     r1, #4
        BLO     eject_winnies

        CLRV
        TST     lr, #CreateFlag_FloppyEjects
        Pull    "pc", EQ
        LDRB    lr, Floppies
        ADD     lr, lr, #3
        B       eject_common

; simply point R0 at the appropriate information

DoSwiMiscOp_Info
        ADR     R0,FS_Flags
        MOV     pc,lr

eject_winnies
        TST     lr, #CreateFlag_FixedDiscEjects
        Pull    "pc", EQ
        LDRB    lr, Winnies
        SUB     lr, lr, #1              ; May become -1 at this point so:

eject_common
        CMP     r1, lr
        BLLE    Parent_Misc             ; Needs to be signed.
        Pull    "pc"

DoSwiFeatures
 [ NewErrors
        MOV     R0, #Feature_NewErrors
 |
        MOV     R0, #0
 ]
        ORR     R0, R0, #Feature_FloppyDiscsCanMountLikeFixed
        MOV     PC, LR

 [ VduTrap
DebugVduTrap
        Push    "R2"
        LDR     R2, [R12]
        SUB     LR, R2, R12
        CMPS    LR, #(1024-4)*K
        ADDHS   R2, R12,#4
        STRB    R0, [R2], #1
        STR     R2, [R12]
        MOV     R2, #0
        MRS     R2, CPSR
        TST     R2, #2_11100
        Pull    "R2,PC",NE
        Pull    "R2,PC",,^

DoDebugTrapVdu ROUT
        Push    "R0-R2,LR"
        MOV     R2, #16*M
        ADD     R2, R2, #4*K
        ADD     R1, R2, #4
        STR     R1, [R2]

        MOV     R0, #WrchV
        baddr   R1, DebugVduTrap
        SWI     XOS_Claim               ;(R0,R1->R0,V)
        Pull    "R0-R2,PC"

DoDebugUntrapVdu ROUT
        Push    "R0-R2,LR"
        MOV     R0, #WrchV
        baddr   R1, DebugVduTrap
        MOV     R2, #16*M
        ADD     R2, R2, #4*K
        SWI     XOS_Release             ;(R0,R1->R0,V)
        Pull    "R0-R2,PC"

 ]

; >>>>>>>>
; SwiEntry
; >>>>>>>>

SwiEntry ROUT
 [ Debug2
        DLINE   "FileCore SWI entry"
        regdump
 ]
        Push    "R0,R1,R12,LR"

        ; Check SWI range before doing other checks
        CMPS    R11,#FirstUnusedSwi
        BHS     BadSwi

        ; Check for r8-based SWIs with non-0 r8 and if so then use r8 instead of r12
        TEQ     r11, #FileCore_DiscOp - FileCoreSWI_Base
        TEQNE   r11, #FileCore_FreeSpace - FileCoreSWI_Base
        TEQNE   r11, #FileCore_FreeSpace64 - FileCoreSWI_Base
        TEQNE   r11, #FileCore_Drives - FileCoreSWI_Base
        TEQNE   r11, #FileCore_DescribeDisc - FileCoreSWI_Base
        TEQNE   r11, #FileCore_MiscOp - FileCoreSWI_Base
        TEQNE   r11, #FileCore_SectorDiscOp - FileCoreSWI_Base
        TEQNE   r11, #FileCore_DiscOp64 - FileCoreSWI_Base 
        ; Toggle Z bit to give NE if an r8-based SWI...
        TOGPSR  Z_bit, lr
        TEQNE   r8, #0
        MOVNE   r12, r8

        LDR     r0, [r12]
        TEQS    r0, #0
        MOVEQ   SB, r0
        Pull    "R0,R1",EQ
        BLNE    LightEntryFlagErr            ;leaves SB,LR stacked
        JumpAddress LR, %F10, forward
        ADD     PC, PC, R11,LSL #2
        NOP
05
        B       DoSwiDiscOp
        B       DoSwiCreate
        B       DoSwiDrives
        B       DoSwiFreeSpace

        B       DoSwiFloppyStructure
        B       DoSwiDescribeDisc
        B       DoSwiDiscardReadSectorsCache
        B       DoSwiDiscFormat
        B       DoSwiLayoutStructure
        B       DoSwiMiscOp
 [ BigDisc
        B       DoSwiSectorDiscOp
        B       DoSwiFreeSpace64
        B       DoSwiDiscOp64
        B       DoSwiFeatures
 ]
 [ VduTrap
        B       DoDebugTrapVdu
        B       DoDebugUntrapVdu
 ]

FirstUnusedSwi  * (.-%BT05)/4
10
        BLVS    FindErrBlock    ;(R0->R0,V)
        TEQS    SB, #0
        BLNE    FileCoreExit
 [ Debug2
        DLINE   "FileCore SWI exit"
        regdump
 ]
 [ Debug2
        DebugError "FileCore SWI error "
 ]
        Pull    "SB"
        SavePSR lr
        B       PullLinkKeepV

BadSwi
        Push    "r2,r4-r7"

        ; This exceedingly tedious piece of code is forced upon
        ; us as we don't always have a workspace

        ; Open the message file - return this error if this fails
        SUB     sp, sp, #16
        MOV     r0, sp
        ADRL    r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        BVS     %FT50

        ; Lookup the error - who cares what comes back!
        ADR     r0, ErrorBlock_ModuleBadSWI
        MOV     r1, sp
        MOV     r2, #0
        ADRL    r4, Title
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup

        ; Save the lookup error and close the message file
        MOV     r1, r0
        MOV     r0, sp
        SWI     XMessageTrans_CloseFile
        MOV     r0, r1
        SETV
50
        ADD     sp, sp, #16
        Pull    "r2,r4-r7"
        STR     r0, [sp]
        Pull    "R0,R1,R12,PC"

        MakeInternatErrorBlock ModuleBadSWI,,BadSWI

SwiNames ROUT
 = "FileCore",0
 = "DiscOp",0
 = "Create",0
 = "Drives",0
 = "FreeSpace",0
 = "FloppyStructure",0
 = "DescribeDisc",0
 = "DiscardReadSectorsCache", 0
 = "DiscFormat", 0
 = "LayoutStructure", 0
 = "MiscOp", 0
 = "SectorDiscOp", 0
 = "FreeSpace64", 0
 = "DiscOp64", 0
 = "Features", 0
 [ VduTrap
 = "TrapVdu",0
 = "UntrapVdu",0
 ]
 = 0
        ALIGN

        END
@


4.17
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@d453 2
a454 2
        LDMIB   R2,{R1,LR}              ; turn 64-bit byte address + drive
        LDRB    R2,[R2,#0]              ; into packed
@


4.16
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d314 1
a314 1
        DREG    r1, "SectorOp(",cc
d1374 1
a1374 1
 = "SectorOp", 0
@


4.15
log
@Swap out some more constants for symbolic names
* OsBytes
* Application start &8000
* Fixed disc density
* Unused a4 macro deleted
* Redundant 'todo', 'Help, 'Syntax' removed

Version 3.53. Not tagged
@
text
@d56 1
a56 1
        MOV     r2, r2, LSR #29         ; get drive number
d588 1
a588 1
 [ Debug
d1317 1
a1317 1
 [ Debug
@


4.14
log
@  Miscellaneous improvements
Detail:
  * Added the ability for a filing system to specify to FileCore that floppy
    discs should be mounted like hard discs, to complement the existing flag
    that specifies the opposite. SDFS requires this. Ideally SCSIFS should
    start using this as well, to encapsulate boot block handling within
    FileCore.
  * Added header definitions so the FileCore and the filing systems can
    negotiate the use of a new MiscOp entry, needed as part of partitioning
    support, especially important for filing systems that use the hardware-
    specific section of the boot block, like ADFS. At present, FileCore
    doesn't do anything different (it still doesn't support partitions) but
    this enables filing systems to be modified in preparation.
  * Removed the only place where FileCore paid any attention to the
    EmptyWorks flag returned by MiscOp 1 - an obscure and not very useful
    edge case not used by any current filing systems.
  * Added 650 lines of documentation for the MiscOp SWI and low-level entry
    to the Doc directory, giving the information you need in order to
    implement a FileCore filing system.
  * Added missing header file definitions for the low-level background DiscOp
    reason code and the hot-plug drive removed flag to MiscOp 7.
  * Removed some RISC OS 2 legacy code whereby FileCore maintained its idea
    of the internal disc address of the CSD @@, PSD \, Library % and URD & for
    each filing system. Since RISC OS 3.00, FileSwitch handles these
    internally and passes canonicalised paths to FileCore, so FileCore's disc
    addresses for these directories remained unset. This allows some
    considerable simplification of FileCore's path parser in particular, but
    also affects other code like that which decides how to expire disc
    records. Also note that FileCore has been unable to generate certain
    errors (like "Can't delete current directory") since RISC OS 3.00 for the
    same reason.
  * Changed loading of the map for FileCore-format discs so that the map is
    loaded into the dynamic area during the Service_IdentifyDisc handler in
    one big DiscOp rather than loading it twice, sector-by-sector, via one
    big sector cache. For one thing, the sector cache is implemented
    inefficiently - O(n^2) - and for another thing, single-sector DiscOps are
    relatively inefficient on many filing systems, especially on SD cards.
    Some example speed-ups measured for mounting discs are:
      SCSIFS,   1GB drive: was 0.62 sec, now 0.40 sec (1.55 x speedup)
      SCSIFS, 256GB drive: was 1.44 sec, now 0.52 sec (2.77 x speedup)
      SDFS,     2GB drive: was 1.25 sec, now 0.14 sec (8.93 x speedup)
Admin:
  Tested on a beagleboard, with SCSIFS and SDFS.

Version 3.50. Tagged as 'FileCore-3_50'
@
text
@d60 1
a60 1
        SWI     &44781+(1:SHL:17)       ; get the lock status
d1133 1
a1133 1
        MOV     r0, #0
@


4.13
log
@Teach FileCore_LayoutStructure and Service_IdentifyDisc how to do 1 zone fixed discs.
From the change logs it was last fixed sometime around FileCore 2.50 era, but has been long broken.
The boot block was in the right place, but was overwritten by the root directory, and the wrong size entry was claimed in the map, amongst other errors.
Free'd up R6 in LayoutFreeSpaceMap to avoid having to keep reevaluating the number of zones - makes it a bit more readable. Corrected inaccurate comments. Checked the code paths for new map with and without boot block, with and without long filenames.
Test app 'Make1Zone' generates a small disc image which can be inspected in a hex editor for correctness.
In the identify code, be more strict about looking for a boot block only on fixed discs since they cannot occur on floppies (saves time, wasn't necessarily wrong).
The concept of a boot block at &C00 only works when 2 copies of the map can be fitted underneath that address, for future 2k and 4k sector sizes these do not fit and it is likely that 1 zone fixed discs are forbidden (a drive with 4k sectors would typically be > 512GB and 1 zone would be ~32MB so spilling into a second zone would waste < 0.01%).
Other minor changes:
* Free command now groups the 'K' with 'bytes' to match OS_ConvertFileSize.
* FileCore20 debug didn't assemble.
* FileCore33 beefed up comments.
* GenSWIs debug didn't assemble.
Tested with a special cut of RAMFS manually loading various 1 zone images into its dynamic area and checking they mount, have a sensible *MAP and *FREE result, can be written to, and don't have broken directories.

Version 3.46. Tagged as 'FileCore-3_46'
@
text
@d1207 1
@


4.12
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d464 5
a480 4
 [ DebugL :LOR: Debug2D
        DREG    R2, "Original address : "
        DREG    R3, "Log2SectorSize : "
 ]
@


4.11
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d36 1
a36 1
        AND     r1, r1, #OpMask         ; get actual operation being done
d38 2
a39 2
        TEQ     r1, #WriteSecsOp
        TEQNE   r1, #WriteTrkOp
d46 1
a46 1
        AND     r1, r1, #OpMask         ; get actual operation being done
d48 2
a49 2
        TEQ     r1, #WriteSecsOp
        TEQNE   r1, #WriteTrkOp
d58 1
a58 1
	Pull	"r1,r2,pc",LO		; not hard disc - ignore
d68 1
a68 1
        CMP	r0, #2
d74 1
a74 1
	Pull	"r1,r2,pc"		; not locked
d77 6
a82 6
	LDRB	r0, FS_Id		; get FSnumber
	CMP	r0, r1			; are they the same
	MOVEQ	r0, #FSLockedErr
	MOVNE	r0, #0
	BL	SetVOnR0
	Pull	"r1,r2,pc"
d96 1
a96 1
        SUB     sp, sp, #DiscRecSig2
d98 1
a98 1
        SUB     sp, sp, #DiscRecSig
d109 1
a109 1
        STRB    r3, [sp, #SectorSize]
d114 1
a114 1
        STRB    r3, [sp, #SecsPerTrk]
d116 2
a117 2
        AND     r3, r3, #FormatSequenceSides
        TEQ     r3, #FormatInterleaveSides
d123 1
a123 1
        STRB    r3, [sp, #Heads]
d128 1
a128 1
        STRB    r3, [sp, #Density]
d130 5
a134 5
        ASSERT  LinkBits :MOD: 4 = 0
        ASSERT  BitSize = LinkBits+1
        ASSERT  RAskew = BitSize+1
        ASSERT  BootOpt = RAskew+1
        STR     r3, [sp, #LinkBits]
d137 1
a137 1
        LDRB    r3, [sp, #SecsPerTrk]
d147 5
a151 5
        AND     lr, r3, #FormatSequenceSides
        TEQ     lr, #FormatInterleaveSides
        ORRNE   r2, r2, #SequenceSides
        TST     r3, #FormatDoubleStep
        ORRNE   r2, r2, #DoubleStep
d155 1
a155 1
        STRB    r2, [sp, #LowSector]
d157 1
a157 1
        STRB    r1, [sp, #Zones]
d159 1
a159 1
 	STRB	r1, [sp, #Zones2]
d161 2
a162 2
        STRB    r1, [sp, #ZoneSpare]
        STRB    r1, [sp, #ZoneSpare+1]
d164 1
a164 1
	DREG	r1, "Setting RootDir to "
d166 1
a166 1
        STR     r1, [sp, #RootDir]
d171 1
a171 1
        LDRB    lr, [sp, #SecsPerTrk]
d173 1
a173 1
        LDRB    lr, [sp, #SectorSize]
d175 2
a176 2
	RSB	r2, lr, #32
	MOV	r2, r1, LSR r2
d182 2
a183 2
	STR	r2, [sp, #DiscSize2]
        STR     r1, [sp, #DiscSize]
d185 1
a185 1
        LDRB    lr, [sp, #SectorSize]
d188 1
a188 1
        LDRB    lr, [sp, #SecsPerTrk]
d193 1
a193 1
        STR     r1, [sp, #DiscSize]
d197 3
a199 3
        STR     r1, [sp, #DiscId]
        STR     r1, [sp, #DiscName+2]
        STR     r1, [sp, #DiscName+6]
d204 1
a204 1
        ADD     lr, sp, #DiscRecSig2
d206 1
a206 1
        ADD     lr, sp, #DiscRecSig
d231 1
a231 1
        AND     R1, R1, #&FF            ; Remove any embarasing bits from the op
d238 2
a239 2
        AND     lr, r1, #OpMask
        TEQ     lr, #WriteTrkOp
d259 1
a259 1
        BIC     R1, R1, #AltDefectBit
d271 5
a275 5
	Push	"R3,R4"
	LDRB	R3,[R5,#SectorSize]	; get sector size
	AND	R4,R2,#DiscBits
	BIC	R2,R2,#DiscBits
	ORR	R2,R4,R2,LSR R3		; sector addr
d277 1
a277 1
	Pull	"R3,R4"
d285 3
a287 3
	BL	RetryDriveOp		;
;	LDR	LR,DiscOp_ByteAddr	; get end addr
	Push	"R3"
d289 1
a289 1
	DREG	R2, "Original address : "
d291 4
a294 4
	LDRB	R3,[R5,#SectorSize]
	BIC	LR,R2,#DiscBits
	AND	R2,R2,#DiscBits
	ORR	R2,R2,LR,LSL R3
d296 2
a297 2
 	DREG	R3, "Sectorsize : "
	DREG	R2, "Result address : "
d299 1
a299 1
	Pull	"R3"
d339 2
a340 2
        AND     lr, r1, #OpMask
        TEQ     lr, #WriteTrkOp
d360 1
a360 1
        BIC     R1, R1, #AltDefectBit
d385 1
a385 1
        LDRB    lr, [r2, #0]
d387 1
a387 1
        LDR     lr, [r2, #4]
d389 1
a389 1
        LDR     lr, [r2, #8]
d396 1
a396 1
        LDRB    LR, [R2, #0]
d408 1
a408 1
        AND     R1, R1, #&FF            ; Remove any embarasing bits from the op
d416 2
a417 2
        AND     lr, r1, #OpMask
        TEQ     lr, #WriteTrkOp
d426 1
a426 1
        LDRB    LR, [R2, #0]            ;drive
d438 1
a438 1
        BIC     R1, R1, #AltDefectBit
d445 1
a445 1
        LDRB    R0, [R2, #0]
d451 2
a452 2
	Push	"R1,R3"
	LDRB	R3,[R5,#SectorSize]	; get sector size
d464 1
a464 1
	Pull	"R1,R3"
d472 3
a474 3
	BL	RetryDriveOp		;
;	LDR	LR,DiscOp_ByteAddr	; get end addr
	LDRB	R5,[R5,#SectorSize]
d477 2
a478 2
	DREG	R2, "Original address : "
 	DREG	R3, "Sectorsize : "
d486 1
a486 1
	DREG	LR, "Result address : ",cc
d588 1
a588 1
	DebugError "Create filecore instantiation: "
d613 3
a615 3
        TSTS    R1, #3			; are we going to cross a word boundary?
        SUBEQ   SP, SP, #4		; yes, so drag SP down to next boundary
        STRB    R5, [R1,#-1] !		; store byte and drop ptr
d749 2
a750 2
	DREG	R1, ", ", cc
	DREG	R2, " ", cc
d772 1
a772 1
        LDR     R2, [R4, #DiscSize]
d779 1
a779 1
        LDRB    LR, [R4, #BootOpt]
d784 1
a784 1
        ADD     R1, R4, #DiscName
d813 4
a816 4
	Push	"R1"
	LDRB	R1,[R10,#ZoneHead+SectorSize]
	MOV	R0, R0, LSR R1
	Pull	"R1"
d839 1
a839 1
        MOV     R2, #DiscRecSig
d849 4
a852 4
	Push	"R1"
	LDRB	R1, [R10,#ZoneHead+SectorSize]	; get the sector size
	MOV	R0, R0, LSR R1
	Pull	"R1"
d879 1
a879 1
        LDR     R0, [R4, #DiscSize]
d883 1
a883 1
	BL	ByteDiscAddToMapPtr	;(R0,R10->R11,LR) (to fix RAMFS discs coming out truncated)
d896 1
a896 1
        LDRB    R8, [R10,#ZoneHead+SectorSize]
d991 1
a991 1
        LDR     R2, [R4, #RootDir]
d1046 1
a1046 1
        ASSERT  DiscRecSig=8*4
d1050 1
a1050 1
        ASSERT  RootDir = 3*4
d1060 3
a1062 3
        LDR     R1, [LR, #DiscType]
        ASSERT  DiscType = DiscRecSig
        STR     R1, [R0, #DiscType]
d1066 2
a1067 2
        LDR     R1, [LR, #DiscSize2]
        STR     R1, [R0, #DiscSize2]
d1070 2
a1071 2
        LDR     R1, [LR, #ShareSize]
        STR     R1, [R0, #ShareSize]
d1075 4
a1078 4
        LDR     R1, [LR, #DiscVersion]
        STR     R1, [R0, #DiscVersion]
        LDR     R1, [LR, #RootDirSize]
        STR     R1, [R0, #RootDirSize]
d1099 2
a1100 2
	TEQS	R0,#Misc_ReadInfo
	BEQ	%FT01
d1102 1
a1102 1
        CMP     r0, #Misc_Unused
d1121 1
a1121 1
	B	DoSwiMiscOp_Info
d1133 1
a1133 1
        STRB    r0, [r5, #Density]
d1162 1
a1162 1
        TSTS    lr, #DriveStatusWorks
d1177 1
a1177 1
        TST     lr, #FloppyEjects
d1186 2
a1187 2
	ADR	R0,FS_Flags
	MOV	pc,lr
d1190 1
a1190 1
        TST     lr, #WinnieEjects
d1262 8
a1269 8
        TEQ     r11, #FileCore_DiscOp - FileCoreSwiBase
        TEQNE   r11, #FileCore_FreeSpace - FileCoreSwiBase
        TEQNE   r11, #FileCore_FreeSpace64 - FileCoreSwiBase
        TEQNE   r11, #FileCore_Drives - FileCoreSwiBase
        TEQNE   r11, #FileCore_DescribeDisc - FileCoreSwiBase
        TEQNE   r11, #FileCore_MiscOp - FileCoreSwiBase
        TEQNE   r11, #FileCore_SectorDiscOp - FileCoreSwiBase
        TEQNE   r11, #FileCore_DiscOp64 - FileCoreSwiBase
d1296 2
a1297 2
	B	DoSwiSectorDiscOp
	B	DoSwiFreeSpace64
@


4.10
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  Many of these are unaligned LDRs where only bits 0-7 of the result are used
  (tested against a bitmask or used as an input to the barrel shifter) but
  they have all been moved to byte operations because they are faster on
  ARMv6 and won't cause false positives if unaligned aborts are enabled.

  s.BigDirCode line 104: not wrong as such, but changed to use aligned LDR
    for speed on ARMv6.
  s.BigDirCode line 1727: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.Commands line 129: STR to an unaligned 1-byte variable. Harmless because
    all overlapping variables are initialised later on.
  s.Commands line 539: LDR of an unaligned 1-byte variable. Only used for
    testing bit 6.
  s.FileCore31 line 1359: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.FileCore32 lines 1483 and 1825: LDR of an unaligned 1-byte variable. Only
    used as input to shifter.
  s.FormSWIs line 1403: bugfix: incorrect load of 16-bit zone_spare field of
    disc record - uses lowsector and nzones fields instead! This is used to
    terminate the search of free space fragments within the allocation bytes
    of the current map block for the one containing a bad block found during
    formatting. Would manifest itself as a "Can't map defect out" error.
  s.GenSWIs lines 1182,1195: bugfix: LDR of 1-byte variables. Effect of this
    was that range-checking of the drive number passed to FileCore_MiscOp 5
    (eject) wasn't performed.
  Added ENTRY directive to permit building of GPA debug listing.
Admin:
  Builds, but untested.

Version 3.34. Tagged as 'FileCore-3_34'
@
text
@d1256 1
a1256 3
 [ MOS_Version <= 120
        CLRPSR  I_bit,LR        ;re-enable interrupts
 ]
@


4.9
log
@  Various archiecture-based optimisations
Detail:
  * ARMv6+ builds use unaligned halfword and word loads and stores (unless
    pre-ARMv6 compatibility is required or NoUnaligned is set)
  * In many cases, one unnecessary BIC instruction has been removed from
    pre-ARMv6 builds
  * ARMv5+ builds (so Tungsten and OMAP) make use of CLZ instruction when
    parsing fragment blocks
Admin:
  Built and included in an OMAP3 ROM. But be warned, this has not received
  the rigorous testing normally required of filesystem code, use at your
  own risk.

Version 3.33. Tagged as 'FileCore-3_33'
@
text
@d1179 1
a1179 1
        LDR     lr, Floppies
d1192 1
a1192 1
        LDR     lr, Winnies
@


4.8
log
@* Various 32-bit compatibility fixes.
* Can use HAL for FIQ+timer manipulations.
* FileCore_DiscOp64 added (as user API - currently just converted to the
  standard byte or sector DiscOp call to the underlying module). See
  Doc.32bitAPIs for full details.
* New error-passing scheme to modules added (for full 32-bit addressing).
* FileCore_Features added (indicates new error scheme).
* OS_FSControl 49 (read 32-bit free space) now reports sensible clamped
  values for large discs, rather than values modulo 2^32.
* Accessing the end of files near 2GB in size could cause lock-ups in
  background transfers.
* F(+) and G(+) disc formats adjusted to have a little more skew to
  help the rather poor Iyonix floppy controller.

Version 3.31. Tagged as 'FileCore-3_31'
@
text
@d1014 1
a1014 1
        BL      Write3                          ;(R0,R1)
@


4.7
log
@Fixed some mrs and msr macros for ObjAsm.

Version 3.30. Tagged as 'FileCore-3_30'
@
text
@d33 12
a44 1
EnsureFSLock ROUT
d57 1
a57 2
        CMP	r2, #4
	MOV	r0,r0
d62 3
a64 1
        ORR     R0, R0, #1<<30
d71 3
a73 1
        ORR     R0,R0,#1<<30
a83 19
DoSwiDiscOp ROUT
        Push    "r1,r5,r11,lr"
 [ Debug2 :LOR: Debug2D
        DREG    r1, "DiscOp(",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DLINE   ")"
 ]
 [ BigDisc
        BL      EnsureFSLock            ; check that we can actually do this
        Pull    "r1,r5,r11,pc",VS       ; if v set then return with error
 ]
        MOV     r11, sp
        EOR     R2, R2, #bit31          ; Convert to internal drive numbering

        ASSERT  SzDiscRec :MOD: 4 = 0
        MOVS    R5, R1, LSR #8
        MOVNE   R5, R5, LSL #2
d85 5
a89 1
        AND     R1, R1, #&FF            ; Remove any embarasing bits from the op
d91 1
a91 1
        BNE     %FT20                   ;if disc rec supplied by caller
d93 1
a93 2
10
        ; Disc record not supplied by the user
a94 8
        AND     lr, r1, #OpMask
        TEQ     lr, #WriteTrkOp
        TEQEQ   r3, #0
        BNE     %FT15

        Push    "r1,r2,r3"

        ; Construct disc record from disc format structure
d164 1
a164 1
	DREG	r1, "Setting RootDir to (GenSWIs, 160) "
d171 1
a171 2
	Push	"R2"
        LDRB    lr, [sp, #4+SecsPerTrk]
d173 1
a173 1
        LDRB    lr, [sp, #4+SectorSize]
d177 1
a177 1
        MOV     r1, r1, ASL lr
d182 2
a183 3
	STR	r2, [sp, #4+DiscSize2]
        STR     r1, [sp, #4+DiscSize]
	Pull	"R2"
d208 36
a243 1
        LDMIA   lr, {r1,r2,r3}
d344 25
a368 1
        Push    "r1,r2,r3"
d370 25
a394 5
        ; Construct disc record from disc format structure
 [ BigDisc
        SUB     sp, sp, #DiscRecSig2
 |
        SUB     sp, sp, #DiscRecSig
d396 3
a398 35
        LDR     lr, [r4, #DoFormatSectorSize]
        MOV     r3, #0
11
        MOVS    lr, lr, LSR #1
        ADDNE   r3, r3, #1
        BNE     %BT11
 [ DebugL :LOR: Debug2D
        DREG    r3, "SS=",cc
 ]
        STRB    r3, [sp, #SectorSize]
        LDRB    r3, [r4, #DoFormatSectorsPerTrk]
 [ DebugL :LOR: Debug2D
        DREG    r3, " SPT=",cc
 ]
        STRB    r3, [sp, #SecsPerTrk]
        LDRB    r3, [r4, #DoFormatOptions]
        AND     r3, r3, #FormatSequenceSides
        TEQ     r3, #FormatInterleaveSides
        MOVEQ   r3, #2
        MOVNE   r3, #1
 [ DebugL :LOR: Debug2D
        DREG    r3, " H=",cc
 ]
        STRB    r3, [sp, #Heads]
        LDRB    r3, [r4, #DoFormatDensity]
 [ DebugL :LOR: Debug2D
        DREG    r3, " D=",cc
 ]
        STRB    r3, [sp, #Density]
        MOV     r3, #0
        ASSERT  LinkBits :MOD: 4 = 0
        ASSERT  BitSize = LinkBits+1
        ASSERT  RAskew = BitSize+1
        ASSERT  BootOpt = RAskew+1
        STR     r3, [sp, #LinkBits]
d400 2
a401 9
        MOV     r2, #&100
        LDRB    r3, [sp, #SecsPerTrk]
        ADD     lr, r4, #DoFormatSectorList+2
12
        LDRB    r1, [lr], #4
        CMP     r1, r2
        MOVLO   r2, r1
        SUBS    r3, r3, #1
        BHI     %BT12
a402 22
        LDRB    r3, [r4, #DoFormatOptions]
        AND     lr, r3, #FormatSequenceSides
        TEQ     lr, #FormatInterleaveSides
        ORRNE   r2, r2, #SequenceSides
        TST     r3, #FormatDoubleStep
        ORRNE   r2, r2, #DoubleStep
 [ DebugL :LOR: Debug2D
        DREG    r2, " LS=",cc
 ]
        STRB    r2, [sp, #LowSector]
        MOV     r1, #0
        STRB    r1, [sp, #Zones]
 [ BigMaps
 	STRB	r1, [sp, #Zones2]
 ]
        STRB    r1, [sp, #ZoneSpare]
        STRB    r1, [sp, #ZoneSpare+1]
 [ DebugL :LOR: Debug2D
	DREG	r1, "Setting RootDir to: (GenSWIs, 379) "
 ]
        STR     r1, [sp, #RootDir]
        LDR     r1, [r4, #DoFormatCylindersPerDrive]
d404 2
a405 10
        LDRB    lr, [sp, #SecsPerTrk]
        MUL     r1, lr, r1
        LDRB    lr, [sp, #SectorSize]
        ADD     lr, lr, #1
	RSB	r2, lr, #32
	MOV	r2, r1, LSR r2
        MOV     r1, r1, ASL lr
 [ DebugL :LOR: Debug2D
        DREG    r1, " DS1="
        DREG    r1, " DS2="
a406 17
        STR     r1, [sp, #DiscSize]
        STR     r2, [sp, #DiscSize2]
 |
        LDRB    lr, [sp, #SectorSize]
        ADD     lr, lr, #1
        MOV     r1, r1, ASL lr
        LDRB    lr, [sp, #SecsPerTrk]
        MUL     r1, lr, r1
 [ DebugL :LOR: Debug2D
        DREG    r1, " DS="
 ]
        STR     r1, [sp, #DiscSize]
 ]
        MOV     r1, #0
        STR     r1, [sp, #DiscId]
        STR     r1, [sp, #DiscName+2]
        STR     r1, [sp, #DiscName+6]
d408 12
a419 1
        MOV     r5, sp
d421 1
a421 6
 [ BigDisc
        ADD     lr, sp, #DiscRecSig2
 |
        ADD     lr, sp, #DiscRecSig
 ]
        LDMIA   lr, {r1,r2,r3}
d426 1
d428 1
a428 1
        MOV     R1, R2, LSR #(32-3)     ;drive
d445 2
a446 1
        MOV     R0, R2, LSR #(32-3)
d450 47
d498 4
a504 1
        EOR     R2, R2, #bit31          ; Convert back to external drive numbering
d506 13
a518 1
        Pull    "r1,r5,r11,PC"
d625 1
a625 2
        Push    "R0,LR"
        SavePSR R0
d631 1
a631 2
        RestPSR R0,,f
        Pull    "R0,PC"
d1098 4
a1104 4
 [ BigDisc
	CMPS	R0,#Misc_ReadInfo
	BEQ	%FT01
 ]
d1200 7
d1271 1
d1300 2
d1376 2
@


4.6
log
@  More 32-bit fixes.
Detail:
  Flag preservation added to 7 routines that require it.  Docs.32-bit
    updated to remove the names of the functions that have been made
    to preserve flags again.
Admin:
  This version needs more testing, but at least this version does not
    appear to stiff the machine, corrupt discs, go bang under light
    testing with ADFS and RAMFS.
  26-bit and 32-bit builds slightly tested.
  Do not use in products - Do use in test builds.

Version 3.25. Tagged as 'FileCore-3_25'
@
text
@d1162 1
a1162 1
        mrs    ,R2, CPSR
@


4.5
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d1262 1
@


4.4
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d488 1
a488 1
        MOVEQS  PC, LR
d520 4
a523 3
        LDRHIB  R5, [R3,#-1] !
        BLHI    %FT99
        BHI     %BT15
d525 1
a543 1
 [ FileCache
a546 1
 ]
d565 1
a565 1
        MOVS    PC, LR                  ; byebye
a567 1
 [ FileCache
d574 2
a575 1
        Push    "LR"
d581 2
a582 1
        Pull    "PC",,^
a583 7
 ]

 [ FileCache
 |
DoNulSwi ROUT
        MOVS    PC,LR
 ]
d591 1
a591 1
        MOVS    PC, LR
d756 4
a759 2
        MOVHS   R7, R2
        Pull    "R0,R11,PC",HS,^        ;amg MED-03799  7th October 1994
d762 1
d769 3
a771 3
        BLLO    DiscAddToMapPtr         ;(R0,R10->R11,LR)
        BICLO   R7, R11,R5
        ADDLO   R9, R9, #4              ;advance in defect list if not end
d778 2
a779 1
        Pull    "R0,R11,PC",,^
d973 2
a974 1
        Pull    "R0-R11,PC",,^
a999 1
 [ Module_Version >= 205
a1005 1
 ]
a1009 1
 [ Module_Version >= 205
a1013 1
 ]
d1062 1
a1062 1
        MOV     LR, PC
d1064 1
a1064 1
        B       %FT10
d1127 1
d1129 1
a1129 1
        Pull    "pc", EQ, ^
d1138 1
a1138 1
	MOVS	pc,lr
d1142 1
a1142 1
        Pull    "pc", EQ, ^
d1161 4
d1216 1
a1216 2
        MOV     lr, pc
        TEQP    lr, #Z_bit
d1225 1
a1225 1
        MOV     LR, PC
d1227 1
a1227 1
        B       %FT10
a1233 1
 [ FileCache
a1234 3
 |
        B       DoNulSwi
 ]
a1307 1
 [ FileCache
a1308 3
 |
 = "NOP",0
 ]
@


4.3
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d168 3
d173 3
d387 3
d392 3
d535 1
a535 2
        wrhex   R0, VS
        mess    VS, "Create filecore instantiation error",NL
d813 3
d817 1
d824 3
d828 1
d863 3
d867 1
d870 3
d874 1
d898 3
d902 1
d904 3
d908 1
d914 3
d918 1
d921 3
d925 1
d1029 7
a1035 1

@


4.2
log
@Version Spin_merge taken
@
text
@d958 1
a958 1
 [ Version >= 205
d970 1
a970 1
 [ Version >= 205
@


4.2.2.1
log
@Changes made to FileCore to support allowing idlen more than 15.  This allows
smaller LFAUs on discs.  The changes are not yet complete.  In particular, the
number of disc zones is limited to 255.  Some development testing has been
peformed, and the filing system is generally stable.  Areas which haven't
been fully tested include things like *Defect, FileCore_LayoutStructure,
FileCore_FloppyStructure, and the FileSwitch APIs for reading and examining
a disc's used space.

This version should not be used for any OS Builds with the BigMaps flag set
to true.  It should build as a normal version of FileCore with BigMaps and
BigDirs set to false.
@
text
@a801 3
 [ BigMaps
        BL      FragWrLinkBits          ;(R0,R1,R10)
 |
a802 1
 ]
a808 3
 [ BigMaps
        BL      FragWrLenBits           ;(R0,R1,R10)
 |
a809 1
 ]
a843 3
 [ BigMaps
        BLHI    FragWrLenBits           ; set its length (R0,R1,R10)
 |
a844 1
 ]
a846 3
 [ BigMaps
        BLHI    FragWrLinkBits          ; (R0,R1,R10)
 |
a847 1
 ]
a870 3
 [ BigMaps
        BL      FragWrLenBits           ;(R0,R1,R10)
 |
a871 1
 ]
a872 3
 [ BigMaps
        BL      FragWrLinkBits          ;(R0,R1,R10)
 |
a873 1
 ]
a878 3
 [ BigMaps
        BLGE    FragWrLenBits           ;(R0,R1,R10) 
 |
a879 1
 ]
a881 3
 [ BigMaps
        BLGE    FragWrLinkBits          ;(R0,R1,R10)
 |
a882 1
 ]
@


4.2.2.2
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@a167 3
 [ BigMaps
 	STRB	r1, [sp, #Zones2]
 ]
a380 3
 [ BigMaps
 	STRB	r1, [sp, #Zones2]
 ]
@


4.2.2.3
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@d529 2
a530 1
	DebugError "Create filecore instantiation: "
@


4.2.2.4
log
@Binary-chop dir scanning fixed.  (BigLexEqv fixed so that it doesn't
try to compare the dir separator '.' in eg "Default.Thing" with another
object called "Default+" (was breaking binary chop dir search).

Fixed IdentifyDisc (s.Identify); old behaviour left the RootDir field
invalid (the disc bits were an external drive number, instead of an
internal disc number).  This causes problems if the disc fails to mount
due to, for example, memory problems, as the illegal value never gets
fixed (normally, MountDiscOnDrive would end up correcting the problem).
@
text
@a172 3
 [ DebugL :LOR: Debug2D
	DREG	r1, "Setting RootDir to (GenSWIs, 160) "
 ]
a388 3
 [ DebugL :LOR: Debug2D
	DREG	r1, "Setting RootDir to: (GenSWIs, 379) "
 ]
d909 1
a909 1
        BLGE    FragWrLenBits           ;(R0,R1,R10)
@


4.2.2.5
log
@Version 3.17 for Ursula. SWI DescribeDisc now reports the DiscVersion
and RootDirSize parameters for the disc.

Tagged as aglover_FileCore-3_17.

 -
@
text
@d1029 1
a1029 7
 [ BigDir
        ;amg v3.17. Return DiscVersion and RootDirSize as per spec
        LDR     R1, [LR, #DiscVersion]
        STR     R1, [R0, #DiscVersion]
        LDR     R1, [LR, #RootDirSize]
        STR     R1, [R0, #RootDirSize]
 ]
@


4.1
log
@Initial revision
@
text
@d47 1
a47 1
	CLRV
d49 1
a49 1
	
d694 4
a697 4
        wrhex   R0
        wrhex   R1
        wrhex   R2
        mess    ,">DoSwiFloppyStructure",NL
d710 1
a710 1
        mess    ,"build old map",NL
d775 1
a775 1
        mess    ,"build new map",NL
d812 4
d817 1
a817 8
	LDR	R0, [R4, #DiscSize]
	Push	"R1"
	LDRB	R1, [R10, #ZoneHead+SectorSize]
	MOV	R0, R0, LSR R1
	RSB	R1, R1, #32
	LDR	LR, [R4, #DiscSize2]
	ORR	R0, R0, LR, LSL R1
	Pull	"R1"
d819 1
a819 1
        LDR     R0, [R4, #DiscSize]
d821 1
a821 2
        SUB     R0, R0, #1
        BL      DiscAddToMapPtr         ;(R0,R10->R11,LR)
d823 1
d899 1
a899 1
        mess    ,"build $",NL
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d47 1
a47 1
	MOV	r0,r0
d49 1
a49 1

d694 4
a697 4
        DREG    R0, "", cc
	DREG	R1, ", ", cc
	DREG	R2, " ", cc
        DLINE   ">DoSwiFloppyStructure"
d710 1
a710 1
        DLINE    "build old map"
d775 1
a775 1
        DLINE    "build new map"
d812 10
a821 1

d823 1
a823 1

a824 3
 [ BigDisc
	BL	ByteDiscAddToMapPtr	;(R0,R10->R11,LR) (to fix RAMFS discs coming out truncated)
 |
a825 2
 ]

a826 1

d902 1
a902 1
        DLINE    "build $"
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d47 1
a47 1
	MOV	r0,r0
d49 1
a49 1

d694 4
a697 4
        DREG    R0, "", cc
	DREG	R1, ", ", cc
	DREG	R2, " ", cc
        DLINE   ">DoSwiFloppyStructure"
d710 1
a710 1
        DLINE    "build old map"
d775 1
a775 1
        DLINE    "build new map"
d812 10
a821 1

d823 1
a823 1

a824 3
 [ BigDisc
	BL	ByteDiscAddToMapPtr	;(R0,R10->R11,LR) (to fix RAMFS discs coming out truncated)
 |
a825 2
 ]

a826 1

d902 1
a902 1
        DLINE    "build $"
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d47 1
a47 1
	MOV	r0,r0
d49 1
a49 1

d694 4
a697 4
        DREG    R0, "", cc
	DREG	R1, ", ", cc
	DREG	R2, " ", cc
        DLINE   ">DoSwiFloppyStructure"
d710 1
a710 1
        DLINE    "build old map"
d775 1
a775 1
        DLINE    "build new map"
d812 10
a821 1

d823 1
a823 1

a824 3
 [ BigDisc
	BL	ByteDiscAddToMapPtr	;(R0,R10->R11,LR) (to fix RAMFS discs coming out truncated)
 |
a825 2
 ]

a826 1

d902 1
a902 1
        DLINE    "build $"
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

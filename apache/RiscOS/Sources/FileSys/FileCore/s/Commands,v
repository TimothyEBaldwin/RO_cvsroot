head	4.21;
access;
symbols
	FileCore-3_75:4.21
	FileCore-3_74:4.21
	FileCore-3_73:4.21
	FileCore-3_72:4.21
	FileCore-3_71:4.20
	FileCore-3_70:4.19
	FileCore-3_69:4.19
	FileCore-3_68:4.19
	FileCore-3_67:4.19
	FileCore-3_66:4.19
	FileCore-3_65:4.19
	FileCore-3_64:4.19
	FileCore-3_63:4.19
	FileCore-3_62:4.17
	FileCore-3_61:4.17
	FileCore-3_60:4.16
	FileCore-3_59:4.16
	FileCore-3_58:4.16
	FileCore-3_57:4.16
	FileCore-3_56:4.16
	FileCore-3_55:4.15
	FileCore-3_54:4.15
	FileCore-3_53:4.14
	FileCore-3_52:4.14
	FileCore-3_51:4.14
	FileCore-3_50:4.14
	FileCore-3_49:4.13
	FileCore-3_48:4.13
	FileCore-3_47:4.12
	FileCore-3_46:4.11
	FileCore-3_45:4.11
	FileCore-3_44:4.10
	FileCore-3_43:4.10
	FileCore-3_42:4.10
	FileCore-3_41:4.9
	FileCore-3_40:4.7
	FileCore-3_39:4.7
	FileCore-3_38:4.7
	FileCore-3_37:4.7
	FileCore-3_36:4.7
	FileCore-3_35:4.7
	FileCore-3_34:4.7
	FileCore-3_33:4.6
	RO_5_07:4.6
	FileCore-3_32:4.6
	FileCore-3_31:4.6
	FileCore-3_30:4.5
	FileCore-3_29:4.5
	FileCore-3_28:4.4
	FileCore-3_25-4_9_2_2:4.4
	FileCore-3_27:4.4
	FileCore-3_26:4.4
	FileCore-3_22-4_6_2_1:4.3
	bavison_FileCore-3_22_dev_bp:4.3
	bavison_FileCore-3_22:4.3.0.2
	FileCore-3_25-4_9_2_1:4.4
	HAL:4.4.0.2
	FileCore-3_25:4.4
	FileCore-3_24:4.4
	FileCore-3_23:4.4
	dellis_autobuild_BaseSW:4.3
	FileCore-3_22:4.3
	Ursula_merge:4.1.4.8
	ROL_merge:4.1.4.8
	FileCore-3_21:4.3
	ROL_Ursula_merge:4.1.4.8
	Ursula_RiscPC_merge:4.1.4.7
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.5
	ROL_FileCore-3_21:4.1.4.8
	ROL_FileCore-3_20:4.1.4.8
	ROL:4.1.4.8.0.2
	ROL_bp:4.1.4.8
	Ursula_RiscPC_bp:4.1.4.7
	FileCore-3_18:4.1.4.8
	FileCore-3_01:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.7
	Ursula_RiscPC:4.1.4.7.0.2
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.1.4.8
	sproven_FileCore-3_16:4.1.4.8
	rthornb_UrsulaBuild-19Aug1998:4.1.4.7
	UrsulaBuild_FinalSoftload:4.1.4.7
	rthornb_UrsulaBuild-12Aug1998:4.1.4.7
	aglover_UrsulaBuild-05Aug1998:4.1.4.7
	rthornb_UrsulaBuild-29Jul1998:4.1.4.7
	rthornb_UrsulaBuild-22Jul1998:4.1.4.7
	rthornb_UrsulaBuild-15Jul1998:4.1.4.7
	rthornb_UrsulaBuild-07Jul1998:4.1.4.7
	rthornb_UrsulaBuild-17Jun1998:4.1.4.7
	rthornb_UrsulaBuild-03Jun1998:4.1.4.7
	rthornb_UrsulaBuild-27May1998:4.1.4.7
	rthornb_UrsulaBuild-21May1998:4.1.4.7
	sproven_FileCore-3_15:4.1.4.7
	sproven_314:4.1.4.6
	rthornb_UrsulaBuild_01May1998:4.1.4.6
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.6
	sproven_3_11:4.1.4.6
	sproven_3_10:4.1.4.6
	sproven_Ursula_3_09:4.1.4.6
	sproven_3_07:4.1.4.6
	sproven_3_06:4.1.4.6
	sproven_3_05:4.1.4.5
	sproven_3_04:4.1.4.4
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.3
	sproven_3_02:4.1.4.3
	sproven_3_01:4.1.4.2
	sproven_2_99:4.1.4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.21
date	2017.04.09.22.17.12;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	0hBpFTzNopSirUMz;

4.20
date	2016.12.16.20.35.56;	author rsprowson;	state Exp;
branches;
next	4.19;
commitid	oFQm0vPIJ4zKxfyz;

4.19
date	2013.07.20.14.10.01;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	qZtNVkGjzh5uqdYw;

4.18
date	2013.07.20.13.50.27;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	juzhxIfz9aZzjdYw;

4.17
date	2013.06.19.08.35.37;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	8jRrRJAECsDyzcUw;

4.16
date	2013.02.24.21.09.15;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	rgJG8ZFRF8o9ruFw;

4.15
date	2012.10.28.08.52.31;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	6n5fY77YU7JEb8qw;

4.14
date	2012.04.14.00.43.17;	author bavison;	state Exp;
branches;
next	4.13;
commitid	xkSKw5i9HVYqOL0w;

4.13
date	2012.01.07.16.37.09;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	YI8ftYE07fC1fgOv;

4.12
date	2011.11.25.08.50.21;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	Wvsb4iMJaWIw2HIv;

4.11
date	2011.10.14.07.23.50;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	D2Id4aPp4zmuUhDv;

4.10
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	A9Zxco9ydo9FCOBv;

4.9
date	2011.09.13.19.23.28;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	ihD4ZDAv3emgTmzv;

4.8
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	PKTDORFkNFRVOmzv;

4.7
date	2009.06.15.23.25.35;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2003.04.03.18.33.28;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2001.05.14.14.27.07;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.11.36.50;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.09.21.12.07.10;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.14;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.14;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.03.34;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.08.14.13.13.02;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.09.16.14.46.35;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.11.17.13.32.16;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	97.12.11.23.21.32;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.01.09.11.44.55;	author sproven;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.01.19.12.26.31;	author sproven;	state Exp;
branches;
next	4.1.4.7;

4.1.4.7
date	98.05.08.12.33.02;	author sproven;	state Exp;
branches;
next	4.1.4.8;

4.1.4.8
date	98.09.02.16.14.47;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.33.48;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.30.42;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.21
log
@[415] Report dir full when hitting dir size limit
FileCore would allow objects to be added to BigDir extensible directories until eventually failing and leaving an unopenable broken directory behind.
In fact, the on disc directory was sound, but after updating the parent in GrowBigDir it would reload the child into the dir cache with FindDir, FindDir called SanityCheckBigDirHeader which was rejecting BigDir's of exactly 4MB that was created moments earlier.
Now, during the initial attempt grow, a check is made for exceeding BigDirMaxSize before trying to enlarge the dynamic area (while it would be possible to translate the error from maxing out the dynamic area, there could be situations where there genuinely isn't enough memory to enlarge the area) and a more polite "Dir full" error returned.
Tested with an initially empty drive (so the dynamic area must grow) and with one that previously created a maximal directory (dynamic area already large enough).

Also tightened up a couple of places loading byte wide variables using LDR, relying on the modulo 31 properties of LSR/LSL, when we can simply load the value as a byte for the same cost.

Version 3.72. Tagged as 'FileCore-3_72'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;>Commands

; change log (added by SBP 14 May 1997)
;
; 14 May 1997: SBP: Incorporated old fix for *verify to work when verifying >2G discs (DoVerify)
; 19 Aug 1997: SBP: Changes for big free space maps.
; 13 Sep 2011: RPS: Fix *DEFECT aborting when object occupies defect address

        TTL    "Command handling"


ComTab                     ;      v-- GSTrans flags
        Command Backup,    4, 2, &F00 :OR: FS_Command_Flag :OR: International_Help
        Command Bye,       0, 0, &000 :OR: FS_Command_Flag :OR: International_Help
        Command CheckMap,  1, 0, &100 :OR: FS_Command_Flag :OR: International_Help
        Command Compact,   1, 0, &100 :OR: FS_Command_Flag :OR: International_Help
        Command Defect,    2, 2, &300 :OR: FS_Command_Flag :OR: International_Help
        Command Dismount,  1, 0, &100 :OR: FS_Command_Flag :OR: International_Help
        Command Drive,     1, 1, &100 :OR: FS_Command_Flag :OR: International_Help
        Command Free,      1, 0, &100 :OR: FS_Command_Flag :OR: International_Help
        Command Map,       1, 0, &100 :OR: FS_Command_Flag :OR: International_Help
        Command Mount,     1, 0, &100 :OR: FS_Command_Flag :OR: International_Help
        Command NameDisc,  2, 2, &300 :OR: FS_Command_Flag :OR: International_Help
        Command NameDisk,  2, 2, &300 :OR: FS_Command_Flag :OR: International_Help
        Command Verify,    1, 0, &100 :OR: FS_Command_Flag :OR: International_Help
        DCB     0
        ALIGN

; ----- FILING SYSTEM STAR COMMANDS -----

VerifyRetries   * 5

         ^ 0    ; Backup temporary workspace
SrcDrv          # 1
SrcDrvChar      # 1
DestDrv         # 1
DestDrvChar     # 1

SameDrive       # 1
BufOpt          # 1
FirstTime       # 1
                # 1

FSColonColon    # 4
DrvPlace        # 4
TotalSectors    # 4
UsedMap         # 4
ReadSectors     # 4 ; Where we're up to
AmountRead      # 4 ; How much was read this time round
WriteSectors    # 4 ; Where we're up to
BufferGotten    # 4 ; How much buffer we've got

 [ BigDisc
SrcDiscRec      # SzDiscRecSig2
 |
SrcDiscRec      # SzDiscRecSig
 ]
BackupWork      # 0


; >>>>>>>>
;  Backup
; >>>>>>>>

BC0     DCB     "BC0",0
BC1     DCB     "BC1",0
BC2     DCB     "BC2",0
 [ {FALSE}
 ; 'Same disc' error now redundent
BC3     DCB     "BC3",0
 ]
        ALIGN

Backup_Code ROUT
        SemEntry  Flag,Light    ;leaves SB,LR stacked
        Push    "R7-R11"

        SUB     sp, sp, #BackupWork

        MOV     r11, sp

        ; Clear out BufOpt to prevent unwanted return by OS_Exit
        MOV     lr, #0
        STRB    lr, [r11, #BufOpt]

        ; Parse source drive
        MOV     r1, r0
        BL      SkipSpaces      ;(R1->R0,R1,C)
        TEQS    r0, #DiscSpecChar
        ADDEQ   r1, r1, #1
        LDRB    lr, [r1]
        STRB    lr, [r11, #SrcDrvChar]
        BL      ParseDrive      ;(R1->R0,R1,V) source drive
        BVS     BackupErrorExit
        ADD     r1, r1, #1
        STRB    r0, [r11, #SrcDrv]
        MOV     r6, r0

        ; Parse dest drive
        BL      SkipSpaces
        TEQS    r0, #DiscSpecChar
        ADDEQ   r1, r1, #1
        LDRB    lr, [r1]
        STRB    lr, [r11, #DestDrvChar]
        BL      ParseDrive      ;(R1->R0,R1,V) dest drive
        BVS     BackupErrorExit
        ADD     r1, r1, #1
        STRB    r0, [r11, #DestDrv]

        ; Ensure neither drive is a winnie
        ANDS    lr, r0, r6
        TSTS    lr, #4
        MOVEQ   r0, #BadDriveErr ;can't do winnies
        SETV    EQ
        BVS     BackupErrorExit

        ; Note down whether the drives are the same or not
        EORS    r8, r0, r6
        STRB    r8, [r11, #SameDrive]

        ; Work out which buffers we're permitting ourselves (process Q option)
        MOVEQ   r8, #(1:SHL:UseDirSpace) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: DiscOp_Op_ScatterList_Flag
        MOVNE   r8, #(1:SHL:UseScratchSpace) :OR: (1:SHL:UseSpareScreen) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: DiscOp_Op_ScatterList_Flag
        BL      SkipSpaces      ;(R1->R0,R1,C)
        TEQS    r0, #"Q"
        TEQNES  r0, #"q"
        ORREQ   r8, r8, #(1:SHL:UseApplicArea)
        ADDEQ   r1, r1, #1        ;if Q skip it
        STRB    r8, [r11, #BufOpt]

        ; Process Y option and Confirm if not present
        BL      SkipSpaces      ;(R1->R0,R1,C)
        CMPS    r0, #"Y"
        CMPNES  r0, #"y"
        BLNE    Confirm         ;(->R0,Z,V)
        BNE     BackupErrorExit

        ; Parameters now read and understood

        ; Construct <FS>::<Drv>\n
        LDR     r1, FS_Title
        BL      strlen
        ADD     r0, r3, #4+3            ; ::<drv>\n + round-up
        BIC     r0, r0, #3
        SUB     sp, sp, r0
        STR     sp, [r11, #FSColonColon]
        MOV     r2, r1
        MOV     r1, sp
        BL      strcpy
        ADD     r1, r1, r3
        MOV     r0, #":"
        STRB    r0, [r1], #1
        STRB    r0, [r1], #1
        STR     r1, [r11, #DrvPlace]
        MOV     r0, #0
        STRB    r0, [r1, #1]

        ; repeat

        MOV     r0, #1
        STRB    r0, [r11, #FirstTime]
        MOV     r0, #0
        STR     r0, [r11, #ReadSectors]
        STR     r0, [r11, #WriteSectors]

        ; {source reading part}
        ;   If source=dest:
        ;     If first time round:
        ;       Prompt user to write-protect source disc
        ;     Prompt for source disc
        ;     Wait for user key response
        ;   {source disc now in source drive}
        ;   If first time round
        ;     read file parameters for source disc
        ;     allocate space map for source disc
        ;     read space map for source disc
        ;     take a copy of the disc record for the source disc
        ;     Claim memory for transfer
        ;   read in source disc next part

        ; {dest writing part}
        ;   If source=dest
        ;     Prompt user for dest disc
        ;     Wait for user key response
        ;   {dest disc now in dest drive}
        ;   If first time round
        ;     read dest defect list
        ;     If defect list not empty
        ;       complain dest has defects
        ;     read disc record for dest disc
        ;     If dest disc record <> source disc record enough
        ;       complain source and dest don't match
        ;     Dismount dest disc
        ;   {dest disc acceptable}
        ;   Write out dest disc next part

        ; until no more to read

BackupMainLoop
        ; If first time (0<r0) OR not finished (read<total) then do another step
        LDRB    r0, [r11, #FirstTime]
        RSBS    r0, r0, #0

        LDRHS   r0, [r11, #ReadSectors]
        LDRHS   r1, [r11, #TotalSectors]
        CMPHS   r0, r1
        BHS     BackupDone

        LDRB    lr, [r11, #SameDrive]
        TEQ     lr, #0
        BNE     BackupNoPromptSource

        ; Prompt for source disc

        LDRB    lr, [r11, #FirstTime]
        TEQ     lr, #0
        baddr   r0, BC0, NE             ; PLEASE WRITE PROTECT SOURCE DISC
        BLNE    message_gswrite0
        baddr   r3, BC1, VC             ; Insert source disc in drive %0 then press SPACE bar
        LDRVCB  r0, [r11, #SrcDrvChar]
        BLVC    BackupPromptDisc
        BVS     BackupErrorExit

BackupNoPromptSource
        LDRB    lr, [r11, #FirstTime]
        TEQ     lr, #0
        BEQ     BackupScatterListPresent

        ; Read file parameters for source disc
        LDRB    r1, [r11, #SrcDrv]

 [ DebugQ
        DREG    r1, "Initial look at drive "
 ]

        BL      WhatDisc
        BVS     BackupErrorExit

 [ DebugQ
        DLINE   "Drive OK"
 ]

        ; take a copy of the disc record for the source disc
        LDMIA   r3, {r0-r2,r4-r8}
        ADD     lr, r11, #SrcDiscRec
        STMIA   lr, {r0-r2,r4-r8}
 [ BigDisc ; SBP: Thu 15th December 1994 - walked through, looks OK
        LDR     r0, [r3,#DiscRecord_BigMap_DiscSize2]
        STR     r0, [lr,#DiscRecord_BigMap_DiscSize2]

        ; Size/Log2SectorSize (rounding up) = total sectors
; bottom 32 bits
        LDR     r0, [r3, #DiscRecord_DiscSize]
        LDRB    lr, [r3, #DiscRecord_Log2SectorSize]
        MOV     r0, r0, LSR lr
        Push    "R1"
; top 32 bits
        LDR     r1, [r3, #DiscRecord_BigMap_DiscSize2]
        RSB     lr, lr, #32
        ORR     r0, r0, r1, LSL lr      ; combine them
        Pull    "R1"
        STR     r0, [r11, #TotalSectors]
 |
        ; Size/DiscRecord_Log2SectorSize (rounding up) = total sectors
        LDR     r0, [r3, #DiscRecord_DiscSize]
        LDRB    lr, [r3, #DiscRecord_Log2SectorSize]
        MOV     r0, r0, LSR lr
        STR     r0, [r11, #TotalSectors]
 ]

        ; Work out how many words of stack space will be needed
        ADD     r0, r0, #31
        BIC     r0, r0, #31

        ; allocate space map for source disc
        SUB     sp, sp, r0, LSR #3
        STR     sp, [r11, #UsedMap]

        ; Read space map for source disc
        MOV     r5, r0, LSR #3
        LDRB    r0, [r11, #SrcDrvChar]
        LDR     lr, [r11, #DrvPlace]
        STRB    r0, [lr]
        MOV     r0, #FSControl_UsedSpaceMap
        LDR     r1, [r11, #FSColonColon]
        MOV     r2, sp
        BL      DoXOS_FSControl
        BVS     BackupErrorExit

        ; Claim memory for transfer
        LDRB    r0, [r11, #BufOpt]      ; options
        MOV     r1, #1024               ; min. = Largest sector size
 [ BigDisc; SBP: Thu 15th December 1994 - walked through, looks OK
        ; make sure don't ask for silly amount of memory
        LDR     r2, [r11, #SrcDiscRec + DiscRecord_BigMap_DiscSize2]      ; get top 32bits of disc size
        CMP     r2, #0
        LDRLS   r2, [r11, #SrcDiscRec + DiscRecord_DiscSize]              ; get low 32bits
        CMPLS   r2, #2048*1024
        MOVHI   r2, #2048*1024          ; limit max size
 |
        LDR     r2, [r11, #SrcDiscRec + DiscRecord_DiscSize] ; max
 ]
        MOV     r3, #1024               ; granularity
        BL      FindBuffer              ; (r0-r3,r0-r3,V)
        BVS     BackupErrorExit
        LDRB    lr, [r11, #SrcDiscRec + DiscRecord_Log2SectorSize]
        MOV     r2, r2, LSR lr
        STR     r2, [r11, #BufferGotten] ; in sectors

BackupScatterListPresent
        ;   Read in source disc next part
        LDRB    r4, [r11, #SrcDrv]
        MOV     r0, #DiscOp_ReadSecs
        LDR     r1, [r11, #UsedMap]
        LDR     r2, [r11, #ReadSectors]
 [ BigDisc; SBP: Thu 15th December 1994 - changed to use r5 as temp reg
          ; (r5 gets corrupted just below anyway)
; number of sectors to transfer
        LDR     r3, [r11, #SrcDiscRec + DiscRecord_DiscSize]
        LDRB    lr, [r11, #SrcDiscRec + DiscRecord_Log2SectorSize]
        MOV     r3, r3, LSR lr
        LDR     r5, [r11, #SrcDiscRec + DiscRecord_BigMap_DiscSize2]
        RSB     lr, lr, #32
        ORR     r3, r3, r5, LSL lr
 |
        LDR     r3, [r11, #SrcDiscRec + DiscRecord_DiscSize]
        LDRB    lr, [r11, #SrcDiscRec + DiscRecord_Log2SectorSize]
        MOV     r3, r3, LSR lr
 ]

        LDR     lr, [r11, #BufferGotten]
        CMP     r3, lr
        MOVHI   r3, lr
        ADD     r5, r11, #SrcDiscRec
 [ DebugQ
        DREG    r11, "r11 into BackupReadWriteSections is "
 ]
        BL      BackupReadWriteSections
 [ DebugQ
        DREG    r11, "r11 out of BackupReadWriteSections is "
 ]
        BVS     BackupErrorExit
        STR     r2, [r11, #ReadSectors]
        STR     r3, [r11, #AmountRead]

BackupPromptDestDisc
        ; Prompt for Dest if same drive
        LDRB    lr, [r11, #SameDrive]
        TEQ     lr, #0
        baddr   r3, BC2, EQ             ; Insert destination disc in drive %0 then press SPACE bar
        LDREQB  r0, [r11, #DestDrvChar]
 [ DebugQ
        BNE     %FT01
        DLINE   "About to prompt for destination"
01
 ]
        BLEQ    BackupPromptDisc
 [ DebugQ
        DLINE   "Dest in drive"
 ]
        BVS     BackupErrorExit

        LDRB    lr, [r11, #FirstTime]
        TEQ     lr, #0
        BEQ     BackupDestChecked

        ;     Read dest defect list
        LDR     lr, [r11, #DrvPlace]
        LDRB    r0, [r11, #DestDrvChar]
        STRB    r0, [lr]
        SUB     sp, sp, #512
        MOV     r0, #FSControl_DefectList
        LDR     r1, [r11, #FSColonColon]
        MOV     r2, sp
        MOV     r5, #512
        BL      DoXOS_FSControl
        BVS     BackupErrorExit

        ;     If defect list not empty
        LDR     r0, [sp]
        TST     r0, #DiscBits
        ;       complain dest has defects
        MOVEQ   r0, #DestDefectsErr
        SETV    EQ
        BVS     BackupErrorExit

        ADD     sp, sp, #512

        ;     Read disc record for dest disc
        LDRB    lr, [r11, #DestDrv]
        DrvRecPtr lr, lr
        LDRB    lr, [lr, #DrvsDisc]
        DiscRecPtr lr, lr

        ;     If dest disc same complain about same-discness
        ADD     r0, r11, #SrcDiscRec

 [ {FALSE}
 ; 'Same disc' checks now redundent and undesirable.

        ;     If dest disc record <> source disc record enough
        LDMIA   r0!, {r1-r4}
        LDMIA   lr!, {r6-r9}
        TEQ     r1, r6
        TEQEQ   r2, r7
        TEQEQ   r3, r8
        TEQEQ   r4, r9
        LDMEQIA r0, {r1-r4}
        LDMEQIA lr, {r6-r9}
        TEQEQ   r1, r6
        TEQEQ   r2, r7
        TEQEQ   r3, r8
        TEQEQ   r4, r9
        ;       complain source and dest don't match
        BNE     BackupDiscsDifferent

        baddr   r0, BC3
        BL      message_gswrite0
        BVS     BackupErrorExit
        B       BackupPromptDestDisc

BackupDiscsDifferent
        ; Check discs enough alike to work
        SUB     lr, lr, #4*4
        SUB     r0, r0, #4*4
 ]

        LDRB    r1, [lr, #DiscRecord_Log2SectorSize]
        LDRB    r2, [r0, #DiscRecord_Log2SectorSize]
        TEQ     r1, r2
        LDREQB  r1, [lr, #DiscRecord_SecsPerTrk]
        LDREQB  r2, [r0, #DiscRecord_SecsPerTrk]
        TEQEQ   r1, r2
        LDREQB  r1, [lr, #DiscRecord_Density]
        LDREQB  r2, [r0, #DiscRecord_Density]
        TEQEQ   r1, r2
        LDREQB  r1, [lr, #DiscRecord_LowSector]
        LDREQB  r2, [r0, #DiscRecord_LowSector]
        BICEQ   r1, r1, #DiscRecord_SequenceSides_Flag
        BICEQ   r2, r2, #DiscRecord_SequenceSides_Flag
        TEQEQ   r1, r2
        MOVNE   r0, #SizeErr
        SETV    NE
        BVS     BackupErrorExit

        ;     Dismount dest disc
        LDRB    r1, [r11, #DestDrv]
        DrvRecPtr r1, r1
        LDRB    r1, [r1, #DrvsDisc]
        BL      ActiveDismountDisc
        BVS     BackupErrorExit

BackupDestChecked

        ;   Write out dest disc next part
        LDRB    r4, [r11, #DestDrv]
        MOV     r0, #DiscOp_WriteSecs
        LDR     r1, [r11, #UsedMap]
        LDR     r2, [r11, #WriteSectors]
        LDR     r3, [r11, #AmountRead]
        ADD     r5, r11, #SrcDiscRec
        BL      BackupReadWriteSections
        BVS     BackupErrorExit
        STR     r2, [r11, #WriteSectors]

        ; Note the next loop isn't first time
        MOV     lr, #0
        STRB    lr, [r11, #FirstTime]

        B       BackupMainLoop

BackupDone
        ; Stamp the dest image now
        LDRB    r0, [r11, #DestDrvChar]
        LDR     lr, [r11, #DrvPlace]
        STRB    r0, [lr]
        MOV     r0, #FSControl_StampImage
        LDR     r1, [r11, #FSColonColon]
        MOV     r2, #1
        BL      DoXOS_FSControl
        BVS     BackupErrorExit

BackupErrorExit
 [ DebugQ
        ADD     r0, r0, #4
        DSTRING r0, "Error:"
        SUB     r0, r0, #4
 ]
        ; Free claimed resources
        BL      ReturnBuffer
        LDRB    lr, [r11, #BufOpt]
        TST     lr, #1 :SHL: UseApplicArea
        BNE     QuickBack

        BLVS    FindErrBlock
        MOV     sp, r11
        ADD     sp, sp, #BackupWork
        BL      FileCoreExit
        Pull    "r7-r11,SB,pc"

QuickBack
        BVC     %FT99
        BL      FindErrBlock    ;(R0->R0,V)
        BL      FileCoreExit
        SWI     OS_GenerateError
99
        LDR     R1, ABEX
        MOV     R2, #0
        BL      FileCoreExit
        SWI     OS_Exit

ABEX    = "ABEX"

; BackupPromptDisc
;
; In
;   r0 = drive number (ASCII char)
;   r3 = message token
;
; Out
;   r0 trashed
;   disc prompted for and response received
;
BackupPromptDisc ROUT
        Push    "r0-r4,lr"              ; r0 (drive char) gets nul-terminated for free

        MOV     r0, r3
        MOV     r4, sp
        BL      message_gswrite01
        BVS     %FT95

        ; wait for a space
10
        BL      FlushAndReadChar
        BVS     %FT95
        TEQS    R0, #" "
        BNE     %BT10

95
        STRVS   r0, [sp]
        Pull    "r0-r4,pc"

; BackupReadWriteSections
;
; In
;   r0 = op (DiscOp_ReadSecs/DiscOp_WriteSecs)
;   r1 = pointer to used space map
;   r2 = position so far (in sectors)
;   r3 = RAM limit (in sectors)
;   r4 = drive
;   r5 = disc record to use
;
; Out
;   R0, V error possible
;   r2 updated
;   r3 = amount transfered
;
BackupReadWriteSections ROUT
        Push    "r0-r11,lr"

 [ DebugQ
        DREG    r0, ">BackupReadWriteSections(",cc
        DREG    r1, ",",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DREG    r5, ",",cc
        DLINE   ")"
        DREG    sp, "SP at start="
 ]

        BL      InitScatter
        sbaddr  r11, ScatterList

        MOV     r10, #0
        MOV     r9, r0
        MOV     r8, r4

 [ BigDisc; SBP: Thu 15th December 1994 - walked thru, push/pull r7 not needed
; get number of sectors on disc
        LDR     r6, [r5, #DiscRecord_DiscSize]
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        MOV     r6, r6, LSR lr
        LDR     r7, [r5,#DiscRecord_BigMap_DiscSize2]
        RSB     lr, lr, #32
        ORR     r6, r6, r7, LSL lr
 |
        LDR     r6, [r5, #DiscRecord_DiscSize]
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        MOV     r6, r6, LSR lr
 ]

        ; r1 - the map
        ; r2 - position so far
        ; r3 - RAM limit (sectors)
        ; r5 - the disc record
        ; r6 - the disc size (in sectors)
        ; r8 - drive
        ; r9 - the op
        ; r10 - amount transfered
        ; r11 - scatter rover

BackupFindAnotherSection
        MOV     lr, #1
BackupFindAnotherSectionLoop
        CMP     r2, r6
        BHS     BackupSectionsExhausted

        LDRB    r0, [r1, r2, LSR #3]
 [ DebugQ :LAND: {FALSE}
        DREG    r0, ">",cc
 ]
        AND     r4, r2, #7
        ADD     r2, r2, #1
        TST     r0, lr, ASL r4
        BEQ     BackupFindAnotherSectionLoop

        SUB     r7, r2, #1              ; Start of section

        ; End where RAM or disc ends, whichever is lower
        ADD     r9, r7, r3
        CMP     r6, r9
        MOVLO   r9, r6

        ; Check if room for this section
        CMP     r2, r9
        SUBHI   r2, r2, #1
        BHI     BackupSectionsExhausted

BackupFindSectionEnd
        CMP     r2, r9
        BHS     BackupSectionExhausted

        LDRB    r0, [r1, r2, LSR #3]
 [ DebugQ
        DREG    r0, "<",cc
 ]
        AND     r4, r2, #7
        ADD     r2, r2, #1
        TST     r0, lr, ASL r4
        BNE     BackupFindSectionEnd

BackupSectionExhausted
        ; Section end found - construct operation
        SUB     lr, r2, r7
        SUB     r3, r3, lr
        ADD     r10, r10, lr

        Push    "r0-r4"
        LDR     r9, [sp, #5*4 + 0*4]    ; r0 in
        ORR     r1, r9, #DiscOp_Op_ScatterList_Flag
        SUB     r4, r2, r7
        MOV     r2, r7
        MOV     r3, r11
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        MOV     r4, r4, ASL lr
 [ BigDisc;SBP: Thu 15th December 1994 - walked thru, OK
 |
        MOV     r2, r2, ASL lr
 ]
        ORR     r2, r2, r8, ASL #(32-3)
 [ DebugQ
        DREG    r4, "Transfer length "
        DLINE   "Scatter list",cc
        Push    "r0-r2,r4"
        MOV     r2, r3
01
        LDMIA   r2!, {r0,r1}
        DREG    r0," (",cc
        DREG    r1,",",cc
        DLINE   ")",cc
        SUBS    r4, r4, r1
        STR     lr, [r0]
        SUB     r1, r1, #4
        STR     lr, [r0, r1]
        BGT     %BT01
        DLINE
        Pull    "r0-r2,r4"
 ]
 [ DebugQ
        DREG    r1, "Transfer:",cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DREG    r5, ","
 ]
        BL      RetryDriveOp
        MOV     r11, r3
        STRVS   r0, [sp]
        Pull    "r0-r4"

        BVC     BackupFindAnotherSection

BackupSectionsExhausted
        STR     r2, [sp, #2*4]
        STR     r10, [sp, #3*4]
        STRVS   r0, [sp]

 [ DebugQ
        DREG    r1, "Advance:"
        DREG    r10, "Transfer:"
        DREG    sp, "SP at end="
 ]

        Pull    "r0-r11,pc"


; >>>>>
;  Bye
; >>>>>

Bye_Code ROUT
        SemEntry  Flag,Dormant  ;leaves SB,LR stacked
        BL      DoOsFunShutDown ;(->R0,V)
        BLVS    FindErrBlock    ;(R0->R0,V)
        BL      FileCoreExit
        Pull    "SB,PC"


; >>>>>>>>>>
;  CheckMap
; >>>>>>>>>>

CMC0    DCB     "CMC0",0
CMC1    DCB     "CMC1",0
CMC2    DCB     "CMC2",0
CMC3    DCB     "CMC3",0
        ALIGN

CheckMap_Code ROUT
        SemEntry   Flag,Dormant         ;leaves SB,LR stacked
        Push    "R7-R11"
        TEQS    R1, #0
        BLEQ    IdentifyCurrentDisc     ;(->R0,R3,V) if disc param missing
        BLEQ    DiscAddToRec            ;(R3->LR)
        LDREQ   R3, [LR, #DiscRecord_Root]
        MOVNE   R1, R0
        MOVNE   R2, #MustBeDisc
        BLNE    FullLookUp      ;(R1,R2->R0-R6,V)
        BVS     %FT80

        ; Reject non-FileCore discs
        BL      DiscMustBeFileCore      ;(R3->V,R0)
        BVS     %FT80

        BL      TestMap         ;(R3->Z)
        BEQ     %FT05

        baddr   r0, CMC0        ; Old Map
        BL      message_gswrite0
        B       %FT80

05
        MOV     R1, #8
        BL      CloseAllByDisc  ;(R1->R0,V)
        BVS     %FT80
        BL      DiscAddToRec    ;(R3->LR)
        MOV     R6, LR
        LDRB    LR, [R6, #DiscsDrv]
        CMPS    LR, #8
        BHS     %FT15
                        ;IF we have a map in RAM invalidate it
        DrvRecPtr  R7, LR
 [ DynamicMaps
        LDR     R10,[R7,#DrvsFsMapAddr]
 |
        LDR     R10,[R7, #DrvsFsMap]
        BIC     R10,R10,#HiFsBits
 ]

 [ BigMaps
        LDRB    LR, [R6, #DiscRecord_BigMap_NZones2]
        LDRB    R8, [R6, #DiscRecord_NZones]
        ADD     R8, R8, LR, LSL #8
 |
        LDRB    R8, [R6, #DiscRecord_NZones]
 ]
        LDRB    LR, [R6, #DiscRecord_Log2SectorSize]

        ADD     R9, R10,R8, LSL LR
        MOV     LR, #0
10                      ;loop to clear zone flags
        STRB    LR, [R9], #1
        SUBS    R8, R8, #1
        BPL     %BT10
        LDRB    LR, [R6, #DiscFlags]
        BIC     LR, LR, #AltMapFlag
        STRB    LR, [R6, #DiscFlags]
 [ DynamicMaps
        MOV     LR, #0          ; clear map flags
        STR     R0, [R7, #DrvsFsMapFlags]
 |
        STR     R10,[R7, #DrvsFsMap]
 ]
15
        BL      BeforeReadFsMap ;(R3->R0,V)
        BVS     %FT80           ;can't recover new map if both copies broken

        MOV     R0, #"$"
        BL      DoXOS_WriteC
        BVS     %FT70

20                      ;RECURSE DOWN ENTRY POINT
        BL      FindDir         ;(R3->R0,R5,R6,V)
        BVS     %FT70
 [ BigDir
        BL      GetDirFirstEntry        ; (R3,R5->R4)
        BL      TestBigDir              ; (R3->LR,Z)
        SUBNE   R4, R4, #NewDirEntrySz  ; small dir
        SUBEQ   R4, R4, #BigDirEntrySize; big dir
 |
        SUB     R4, R5, #NewDirEntrySz-DirFirstEntry
 ]
        B       %FT35

25
        MOV     R0, #"."
        BL      DoXOS_WriteC
        BLVC    TermCommon      ;(R3,R4,R5->R10)
        BVS     %FT70

        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        MOV     R2, LR
        BL      ReadIntAtts     ;(R3,R4->LR)
        TSTS    LR, #DirBit
        MOVNE   R3, R2
        BNE     %BT20           ;recurse down if dir
30
        ; need to treat big dirs as a special case
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        MOV     R1, LR
        BL      ReadIntAtts     ;check if it's a dir
        TSTS    LR, #DirBit     ;is it a dir?
        BICNE   R1, R1, #&ff    ;yes then need to pretend isn't for reading size

        ; Next 'delete' the file from the map by returning all its fragments
        ; so that having recursed through the whole tree the map should be
        ; empty except for the map/boot block/root dir. If it isn't
        ; then the map is inconsistent with the directory tree.

        BL      MeasureFileAllocSize_GotMap ;(R1,R3,R4->R0)
      [ BigFiles
        TEQ     R0, #RoundedTo4G
        MOVEQ   R1, #&FFFFFFFF  ;ReturnWholeSpace rounds up internally anyway
        MOVNE   R1, R0
      |
        MOVS    R1, R0
      ]
 [ BigDir
        BL      TestBigDir
        BNE     %FT01

        Push    "R6"
        MOV     R6, R4
        BL      ReturnWholeSpaceNotFudged ;(R1-R6->R0)
        Pull    "R6"
        B       %FT02
01
        Push    "R5"
        SUB     R5, R4, #DirFirstEntry
        BL      ReturnWholeSpace        ;(R1-R5->R0)
        Pull    "R5"
02
 |
        Push    "R5"
        SUB     R5, R4, #DirFirstEntry
        BL      ReturnWholeSpace        ;(R1-R5->R0)
        Pull    "R5"
 ]

        MOV     R10,#DeleteChar
        BL      UnTermCommon    ;(R3,R4,R5,R10)
        MOV     R0, #DeleteChar
        BL      DoXOS_WriteC
        BVS     %FT70

35
 [ BigDir
        BL      TestBigDir      ; (R3->LR,Z)
        BNE     %FT37           ; not big dir

        ; big dir
        ADD     R4, R4, #BigDirEntrySize        ; go to next entry
        BL      BigDirFinished  ; (R4,R5->Z)
        BNE     %BT25           ; more to do
        B       %FT38           ; finished
37
        ; not big dir
        LDRB    LR, [R4, #NewDirEntrySz] !
        CMPS    LR, #" "
        BHI     %BT25
38
 |
        LDRB    LR, [R4, #NewDirEntrySz] !
        CMPS    LR, #" "
        BHI     %BT25
 ]

        MOV     R7, R3
        BL      ToParent                ;(R3,R6->R3)
        CMPS    R3, R7
        BEQ     %FT45                   ;V=0 end when back to root if no match found

        BL      FindDir                 ;(R3->R0,R5,R6,V)
        BVS     %FT70

        BL      AgeDir                  ;(R7)
 [ BigDir
        BL      GetDirFirstEntry        ; (R3,R5->R4)
        BL      TestBigDir              ; (R3->LR,Z)
        SUBNE   R4, R4, #NewDirEntrySz
        SUBEQ   R4, R4, #BigDirEntrySize
 |
        SUB     R4, R5, #NewDirEntrySz-DirFirstEntry
 ]
40
 [ BigDir
        BL      TestBigDir
        ADDEQ   R4, R4, #BigDirEntrySize
        ADDNE   R4, R4, #NewDirEntrySz
 |
        LDRB    LR, [R4, #NewDirEntrySz] !
 ]
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        TEQS    LR, R7
        BNE     %BT40
        MOV     R2, R7
        B       %BT30

45
        MOV     R0, #DeleteChar
        BL      DoXOS_WriteC
        BVS     %FT70
        BL      CritInitReadNewFs       ;(->R10,R11)
        BL      DiscAddToRec            ;(R3->LR)

        MOV     R5, LR
 [ BigMaps
        LDRB    R0, [R5, #DiscRecord_NZones]
        LDRB    LR, [R5, #DiscRecord_BigMap_NZones2]
        ADD     R0, R0, LR, LSL #8
 |
        LDRB    R0, [R5, #DiscRecord_NZones]
 ]
        B       %FT65

50
        baddr   r0, CMC1        ; Map inconsistent with directory tree
        BL      message_gswrite0
        B       %FT70

55
        ; For each zone look what remains in the map after
        ; all the file/dir fragments are gone

        BL      InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        MOV     R1, LR
60
 [ BigMaps
        CMPS    R9,R11          ;gap?
        BNE     %FT62           ; not gap

; gap
        BL      FreeRdLenLinkBits ;(R10,R11->R7,R8)
        ADD     R9, R11, R8
        ADD     R11, R11,R7     ; advance to next free chain entry
        CMPS    R11,R1          ; end of alloc bits in this zone?
        BLO     %BT60
        B       %FT65

62
; not gap
        BL      FragRdLenLinkBits ;(R10,R11->R7,R8)
        BIC     lr, r3, #DiscBits
        CMP     R8, lr, LSR #8  ; is this the root dir?
        BEQ     %FT63           ; it's root dir

        CMP     R8, #2          ; is it the map/boot block fragment?
        BLS     %FT63           ; it is so ok

        ; here if broken map

 [ DebugO
 DREG   r8, "Fragment ID hanging around:"
 DREG   r7, "BitLength:"
 DREG   r0, "In zone:"
 DREG   r11, "At bit offset:"
 DREG   r9, "Next free fragment at bit offset:"
 ]
        B       %BT50

63
        ADD     R11,R11,R7
        CMPS    R11,R1
        BLO     %BT60
        B       %FT65

 |

        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
        CMPS    R9, R11
        ADDEQ   R9, R11,R8
        CMPNES  R8, #2
 [ DebugO
 BLS    %FT01
 DREG   r8, "Fragment ID hanging around:"
 DREG   r7, "BitLength:"
 DREG   r0, "In zone:"
 DREG   r11, "At bit offset:"
 DREG   r9, "Next free fragment at bit offset:"
01
 ]
        BHI     %BT50
        ADD     R11,R11,R7
        CMPS    R11,R1
        BLO     %BT60
 ]

65
        SUBS    R0, R0, #1
        BPL     %BT55
        BL      UnlockMap
        BL      BeforeReadFsMap ;(R3->R0,V)
        BVS     %FT70
        LDRB    LR, [R5, #DiscFlags]
        TSTS    LR, #AltMapFlag
        baddr   R0, CMC3,EQ             ; Map good
        baddr   R0, CMC2,NE             ; One copy of the map is corrupt. Overwrite it with the good copy (Y/N) ?
        BL      message_gswrite0
        BVS     %FT70
        LDRB    LR, [R5, #DiscFlags]
        TSTS    LR, #AltMapFlag
        BEQ     %FT70

        BL      TerseConfirm    ;(V->Z,V)
        BVS     %FT70
        BNE     %FT70
        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_IgnoreEscape_Flag
 [ BigMaps
        LDRB    R7, [R5, #DiscRecord_BigMap_NZones2]
        LDRB    R9, [R5, #DiscRecord_NZones]
        ADD     R9, R9, R7, LSL #8
 |
        LDRB    R9, [R5, #DiscRecord_NZones]
 ]
        LDRB    R7, [R5, #DiscRecord_Log2SectorSize]
        BL      MapDiscAdd              ;(R5,R7,R9->R2)
        MOV     R3, R10
        MOV     R4, R9, LSL R7
        BL      RetryDiscOp     ;(R1-R4->R0,R2-R4,V)
        LDRVC   LR, [R5, #DiscFlags]
        BICVC   LR, LR, #AltMapFlag
        STRVC   LR, [R5, #DiscFlags]
70
        BL      UnlockMap
80
        BLVS    FindErrBlock    ;(R0->R0,V)
        BL      FileCoreExit
        Pull    "R7-R11,SB,PC"


; >>>>>>>>>
;  Compact
; >>>>>>>>>

Compact_Code
        SemEntry  Flag,Dormant          ;leaves SB,LR stacked
        Push    "R7-R11"
        TEQS    R1, #0
        MOV     R1, R0
        BLEQ    IdentifyCurrentDisc     ;(->R0,R3,V) if disc param missing
        MOVNE   R2, #MustBeDisc
        BLNE    FullLookUp              ;(R1,R2->R0-R6,C,V)
        BLVC    BeforeAlterFsMap        ;(R3->R0,V)
        BVS     %FT99

        BL      DiscWriteBehindWait             ;(R3)
        ; Check for drive type based on drive number, not disc number
        MOV     LR, R3, LSR #(32-3)
        DiscRecPtr  LR, LR
        LDRB    LR, [LR, #DiscFlags]
        TST     LR, #FloppyFlag
        LDRB    LR, Interlocks
        Push    "LR"
        LDREQ   R0, WinnieProcessBlk
        LDRNE   R0, FloppyProcessBlk
        BL      ClaimController         ;(R0)
        BL      TestMap         ;(R3->Z)
        BL      DiscAddToRec    ;(R3->LR)
        BNE     %FT03

        ; new map case
 [ BigMaps
        LDRB    R0, [LR, #DiscRecord_NZones]
        LDRB    LR, [LR, #DiscRecord_BigMap_NZones2]
        ADD     R0, R0, LR, LSL #8
 |
        LDRB    R0, [LR,#DiscRecord_NZones]
 ]
        BL      CritInitReadNewFs       ;(->R10,R11)
        SUB     R0, R0, #1
01
        MOV     R1, #8*K
        BL      DefCompactZone          ;(R0,R1,R10->R0,R2,V)
        BVS     %FT02
        SUBS    R0, R0, #1
        BPL     %BT01
02
        BL      UnlockMap
        B       %FT98
03
        ; old map case
         ^ 0
LenListPtr      # 4
LenList         # 0
        ASSERT  NewDirEntries>=OldDirEntries
        SUB     SP, SP, #(NewDirEntries+1)*4+LenList    ;space to sort lengths

        LDR     R3, [LR,#DiscRecord_Root]
        MOV     R7, R3

05
;RECURSE DOWN COMES BACK TO HERE
; R7 disc address of parent dir
; R3 disc address of sub dir to enter

        BL      GetDir          ;(R3->R0,R5,R6,V)
        BVS     %FT95

        Push    "R3"
        BL      ToParent        ;(R3,R6->R3)
        TEQS    R7, R3
        BLNE    InvalidateBufDir
        MOVNE   R3, R7
        BLNE    WriteParent     ;(R3,R6) ensure parent ptr ok for return later
        Pull    "R3"

 [ NewDirEntrySz=OldDirEntrySz   ;init ptr to last sub dir Compacted
        SUB     R6,R5,#NewDirEntrySz-DirFirstEntry
 |
        BL      TestDir      ;(R3->LR)
        SUBEQ   R6, R5, #NewDirEntrySz-DirFirstEntry
        SUBNE   R6, R5, #OldDirEntrySz-DirFirstEntry
 ]
10
        ADD     R1, SP, #LenList        ;init ptr to sort buffer
 [ NewDirEntrySz=OldDirEntrySz
        SUB     R4, R5, #NewDirEntrySz-DirFirstEntry
 |
        BL      TestDir      ;(R3->LR)
        MOVEQ   R11,#NewDirEntrySz
        MOVNE   R11,#OldDirEntrySz
        ADD     R4, R5, #DirFirstEntry
        SUB     R4, R4, R11
 ]
        MOV     R7, #0          ;init dir index
        B       %FT20

15
        CMPS    R6, R4          ;dont consider moving dirs already scanned as
        BLO     %FT16           ;parent ptrs to it would not be updated
        BL      ReadIntAtts
        TSTS    LR, #DirBit
        BNE     %FT18
16      BL      ReadLen         ;(R3,R4->LR)
        MOVS    R0, LR          ;ignore zero length files
        BLNE    RoundUpAlloc    ;(R0,R3->R0) always < 2G old map
        STRNE   R0, [R1]        ;note length
        STRNEB  R7, [R1],#4     ;bottom byte = dir index
18
        ADD     R7, R7, #1
20
 [ NewDirEntrySz=OldDirEntrySz
        LDRB    LR, [R4,#NewDirEntrySz] !
 |
        LDRB    LR, [R4,R11] !
 ]
        CMPS    LR, #" "
        BHI     %BT15

        MOV     LR, #0
        STR     LR, [R1]
        ADD     R0, SP, #LenList
        BL      Sort            ;(R0,R1)
        B       %FT50

25
        STR     R0, [SP,#LenListPtr]
        BIC     R1, LR, #&FF    ;rounded length
        AND     R4, LR, #&FF    ;dir index
 [ NewDirEntrySz=OldDirEntrySz
        ASSERT  NewDirEntrySz=26
        ADD     LR, R4, R4, LSL #1 ;*3
        ADD     R4, R4, LR, LSL #2 ;*13
        ADD     R4, R5, R4, LSL #1
 |
 ?
 ]
        ADD     R4, R4, #DirFirstEntry
        BL      InitReadOldFs   ;(R3->R9,R10,R11)
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        MOV     R2, LR
        ADD     R0, R1, R2      ;end of file's reserved space
        MOV     R9, #-1         ;init smallest gap bigger than file
30
        BL      NextOldFs       ;(R3,R10,R11->R7,R8,R10,R11,Z)
        BEQ     %FT48           ;files exhausted
        CMPS    R8, R0
        BHS     %FT35           ;gap is after object
        CMPS    R7, R9
        MOVLO   R9, R7
        ADD     LR, R8, R7      ;end of gap
        CMPS    LR, R2
        BEQ     %FT40
        BNE     %BT30

35                  ;if gap joins end of file is there a better gap for file
        ADDEQ   LR, R1, R7      ;(file+gap) length
        CMPEQS  R9, LR
        BHS     %FT48
40                      ;here if file worth moving
        BL      ReturnWholeSpace;(R1,R2,R3->R0,V)
 [ Dev
        mess    VS, "*** ReturnWholeSpace GAVE ERROR TO *Compact ***",NL
 ]
        MOV     R8, R2
        MOV     R10,R1          ;size
        MOV     R11,#fsfile_Create
        BL      ClaimFreeSpace  ;(R3,R10,R11->R0,R2,V)
 [ Dev
        mess    VS,"*** ClaimFreeSpace GAVE ERROR TO *Compact ***",NL
 ]
        Push    "R2-R4"
        MOV     R0, #(1:SHL:UseScratchSpace) :OR: (1:SHL:UseSpareScreen) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: DiscOp_Op_ScatterList_Flag
        MOV     R3, R1          ;size
        MOV     R1, R8          ;source
        BL      MoveData        ;(R0-R3->R0-R3,V)
        Pull    "R2-R4"
        BVS     %FT95
        MOV     R0, R2
        BL      WriteIndDiscAdd ;(R0,R3,R4)

        sbaddr  LR, FirstFcb-FcbNext
        B       %FT42
41                              ;deal with relocating open files
        LDR     R0, [LR,#FcbIndDiscAdd]
        TEQS    R0, R8
        STREQ   R2, [LR,#FcbIndDiscAdd]
        LDR     R0, [LR,#FcbDir]
        TEQS    R0, R8
        STREQ   R2, [LR,#FcbDir]
42
        LDR     LR, [LR,#FcbNext];get next FCB
        TST     LR, #BadPtrBits
        BEQ     %BT41

        BL      ReadIntAtts     ;(R3,R4->LR)
        TSTS    LR, #DirBit
        BEQ     %FT48           ;skip if file

      [ :LNOT: RO3Paths
        ASSERT  LibDir=UserRootDir+4    ;deal with side effects of moving dir
        ASSERT  CurDir=LibDir+4
        ASSERT  BackDir=CurDir+4
        sbaddr  R0, UserRootDir
        ADD     R1, R0, #BackDir-UserRootDir
43
        LDR     LR, [R0],#4
        TEQS    LR, R8
        STREQ   R2, [R0,#-4]
        CMPS    R0, R1
        BLS     %BT43
      ]

        sbaddr  R0, RootCache
        MOV     R1, R0
        B       %FT45
44
        LDR     LR, [R0,#CacheDir]
        TEQS    LR, R8
        STREQ   R2, [R0,#CacheDir]
45
        LDR     R0, [R0,#CacheOlder]
        ADD     R0, SB, R0
        TEQS    R0, R1
        BNE     %BT44

48
        LDR     R0, [SP,#LenListPtr]
50
        LDR     LR, [R0],#4     ;get next entry from sorted length table
        TEQS    LR, #0
        BNE     %BT25

        LDR     LR, BufDir      ;avoid unnecessary writing of map
        CMPS    LR, #-1         ;for new floppy ids
        BL      ClearV
        BLEQ    WriteDirThenFsMap       ;(->R0,V)
        BVS     %FT95
                                ;SEARCH FOR NEXT SUB DIR
 [ NewDirEntrySz=OldDirEntrySz
55
        LDRB    LR, [R6,#NewDirEntrySz] !
 |
        BL      TestDir
        MOVEQ   R0, #NewDirEntrySz
        MOVNE   R0, #OldDirEntrySz
55
        LDRB    LR, [R6,R0] !
 ]
        CMPS    LR, #" "
        BLS     %FT60           ;no more sub dirs
        MOV     R4, R6
        BL      ReadIntAtts     ;(R3,R4->LR)
        TSTS    LR, #DirBit
        BEQ     %BT55           ;loop if file

        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        MOV     R7, R3
        MOV     R3, LR
        B       %BT05           ;recurse down dir

60                              ;dir done, return to parent
        MOV     R7, R3
        BL      TestDir
        ADDEQ   R6, R5, #NewDirSize
        ADDNE   R6, R5, #OldDirSize
        BL      ToParent        ;(R3,R6->R3)
        EORS    R0, R3, R7
        BEQ     %FT90           ;if dir = parent then must be $ so done
        BL      GetDir          ;(R3->R0,R5,R6,V)
        BVS     %FT95
        BL      AgeDir          ;(R7)
 [ NewDirEntrySz=OldDirEntrySz   ;init ptr to last sub dir Compacted
        SUB     R4, R5, #NewDirEntrySz-DirFirstEntry
 |
 ?
 ]

65
 [ NewDirEntrySz=OldDirEntrySz   ;init ptr to last sub dir Compacted
        LDRB    LR, [R4,#NewDirEntrySz] !
 |
 ?
 ]
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        TEQS    LR, R7
        BNE     %BT65
        MOV     R6, R4
        B       %BT10

90
        BL      SetVOnR0
95
        BL      UnlockMap
        ADD     SP, SP, #LenList+(NewDirEntries+1)*4    ;return temp space
98
        Pull    "LR"
        STRB    LR, Interlocks
99
        BLVS    FindErrBlock    ;(R0->R0,V)
        BL      FileCoreExit
        Pull    "R7-R11,SB,PC"


; ======
; AgeDir
; ======

;entry R7 ind disc address of dir to age

AgeDir
        Push    "R0-R3,R11,LR"
        MOV     R3, R7
        BL      TryCache        ;(R3->R11,V)
        BVS     %FT90
        BL      LockDirCache
        BL      RemoveCacheDir  ;(R11)
                                        ;LINK DIR AS OLDEST
        MOV     R0, #:INDEX:RootCache
        ADD     R1, SB, R0
        LDR     R2, [R1,#CacheYounger]
        ADD     R3, SB, R2
        BL      InvalidateDirCache
        SUB     LR, R11, SB
        STR     R0, [R11,#CacheOlder]
        STR     R2, [R11,#CacheYounger]
        STR     LR, [R1, #CacheYounger]
        STR     LR, [R3, #CacheOlder]
        STR     R11,[R11,#CachePriority]        ;restore non zero priority
        BL      ValidateDirCache

        BL      UnlockDirCache
90
        STRVS   R0, [sp]
        Pull    "R0-R3,R11,PC"


; >>>>>>>>
;  Defect
; >>>>>>>>

DC0     DCB     "DC0",0
DC1     DCB     "DC1",0
        ALIGN

Defect_Code
        SemEntry   Flag,Dormant ;leaves SB,LR stacked
        Push    "R7-R11"
        MOV     R1, R0
        MOV     R2, #MustBeDisc
        BL      FullLookUp      ;(R1,R2->R0-R6,V)

        BLVC    DiscMustBeFileCore      ;(R3->V,R0)
        BVS     %FT81

        Push    "r1"
        MOV     r1, r3, LSR #(32-3)
        BL      CloseAllByDisc          ;(R1->R0,V)
        Pull    "r1"
        BLVC    BeforeAlterFsMap        ;(R3->R0,V)
        BLVC    SkipSpaces
        BLVC    CritInitReadNewFs       ;(->R10,R11)

 [ BigDisc
        ; SBP: XOS_ReadUnsigned will only work if defect is within 4G.  Need to
        ;      do >32bit number handling for big discs.  Also need to watch for
        ;      above loading of DiscSize.
        MOV     r0, r1                  ; pointer to disc addr string
        BL      ReadHex64               ; (r0->r1,r2)

        ; check for sector alignment - ie shift right by sectorsize
        ; then shift left should not change ls word.
        LDRB    LR,[R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R0, R1, LSR LR
        MOV     R0, R0, LSL LR
        CMP     R1, R0
        BEQ     %FT01
        MOV     R0, #BadParmsErr        ; Bad Parameter (how user friendly!)
        BL      SetV
        B       %FT78

01
        ; check that disc address is on the disc
        LDR     LR, [R10, #ZoneHead+DiscRecord_DiscSize]
        SUBS    R0, R1, LR
        LDR     LR, [R10, #ZoneHead+DiscRecord_BigMap_DiscSize2]
        SBCS    R0, R2, LR
        BMI     %FT02                   ; if -ve then OK

        MOV     R0, #BadParmsErr
        BL      SetV
        B       %FT78
02
        LDRB    LR, [R10, #ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R0, R1, LSR LR
        RSB     LR, LR, #32
        ORR     R0, R0, R2, LSL LR
 |
        MOVVC   r0, #16                 ; base 16
        ORRVC   r0, r0, #bit31 :OR: bit29 ; terminated and within range
        LDRVC   r2, [r10, #ZoneHead+DiscSize] ; bound above by DiscSize-1
        SUBVC   r2, r2, #1
        BLVC    OnlyXOS_ReadUnsigned      ;(R0-R2->R0-R2,V)
        BVS     %FT78

        ; Check also on a sector boundary
        MOV     R0, R2
        LDRB    R1, [R10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     LR, R0, LSR R1
        TEQS    R0, LR, LSL R1          ;check disc address at sector boundary
        MOVNE   R0, #BadParmsErr
        BLNE    SetV
        BVS     %FT78
 ]
        BL      DoDefectMapOut
        BVC     %FT78

        ; Don't summarise problem on old map discs
        BL      TestMap                 ;(R3->Z)
        BNE     %FT78

        ; Start summarising the problem
        CMPS    R8, #2                  ;V=0
        MOVEQ   R0, #DefectErr
        BLEQ    SetV

 [ DebugQ
        DREG    r3, "Entering dir tree scan on root ",cc
        DREG    r2, " and defect "
 ]
        MOVVC   R0, #"$"
        BLVC    DoXOS_WriteC
        BVS     %FT78

        MOV     R9, #0                  ;clear found flag
        MOV     R11,R2                  ;defect disc add

54      ; >> RECURSE DOWN ENTRY POINT
        BL      FindDir                 ;(R3->R0,R5,R6,V)
        BVS     %FT78
 [ BigDir
        BL      GetDirFirstEntry        ; (R3,R5->R4)
        BL      TestBigDir              ; (R3->LR,Z)
        SUBNE   R4, R4, #NewDirEntrySz  ; small dir
        SUBEQ   R4, R4, #BigDirEntrySize; big dir
 |
        SUB     R4, R5, #NewDirEntrySz-DirFirstEntry
 ]
        B       %FT72

57
        BL      ReadIntAtts             ;(R3,R4->LR)
        ANDS    R7, LR, #DirBit
        BEQ     %FT60
        TEQS    R9, #0
        BNE     %FT72

        MOV     R0, #"."
        BL      DoXOS_WriteC
        BLVC    TermCommon              ;(R3,R4,R5->R10) print out directory object
        BVS     %FT78

60
        BL      ReadIndDiscAdd          ;(R3,R4->LR)
        MOV     R1, LR
        BIC     R0, LR, #DiscBits
        TEQS    R8, R0, LSR #8
        BNE     %FT69

        CMPS    R7, #0                  ;V=0
        BNE     %FT61
        MOV     R0, #"."
        BL      DoXOS_WriteC
        BVS     %FT78
        BL      TermCommon              ;(R3,R4,R5->R10) print out filename
61
        Push    "R4,R5"
        BL      ReadLen                 ;(R3,R4->LR)
        MOV     R0, LR
        MOV     R5, #0
        MOV     R9, #-1                 ;init pre gap map ptr, also match found flag
63
        MOV     R2, R1
        BL      FindFileFragment        ;(R2,R5,R9->R2,R4,R9,LR)
        CMPS    R4, R0
        MOVHI   R4, R0
        BIC     R2, R2, #DiscBits
        ADD     LR, R2, R4
        SUBS    R2, R11, R2
        CMPHS   LR, R11
        BHI     %FT66                   ;defect inside this object
        ADD     R5, R5, R4
        SUBS    R0, R0, R4
        BHI     %BT63

        Pull    "R4,R5"
        baddr   r0, DC0                 ;  must be moved
        BL      message_gswrite0
        BVC     %FT69
        BVS     %FT78

66
        ADD     R0, R5, R2
        Pull    "R4,R5"

        SUB     SP, SP, #12
        MOV     R1, SP
        MOV     R2, #12
        BL      OnlyXOS_ConvertHex8     ;(R0-R2->R0-R2)
67
        LDRB    LR, [R0], #1
        CMPS    LR, #"0"+1
        CMPLOS  R0, R1
        BLO     %BT67
        SUB     R0, R0, #1
        MOV     r4, r0
        baddr   r0, DC1                 ;  has defect at offset %0
        BL      message_gswrite01
        ADD     SP, SP, #12
        BVS     %FT78
        CMPS    R7, #0
        BNE     %FT78                   ;V=0 don't try to enter dir with defect

69
        TEQS    R7, #DirBit             ; if it's a directory
        TEQEQS  R9, #0                  ; and no match found...
        MOVEQ   R3, R1
        BEQ     %BT54
        ; THEN RECURSE DOWN >>

72
 [ BigDir
        BL      TestBigDir              ; (R3->LR,Z)
        BNE     %FT01                   ; not big dir

        ; big dir
        ADD     R4, R4, #BigDirEntrySize        ; go to next entry
        BL      BigDirFinished          ; (R4,R5->Z)
        BNE     %BT57                   ; more to do
        B       %FT02                   ; finished
01
        ; not big dir
        LDRB    LR, [R4, #NewDirEntrySz] !
        CMPS    LR, #" "
        BHI     %BT57
02
 |
        LDRB    LR, [R4, #NewDirEntrySz] !
        CMPS    LR, #" "
        BHI     %BT57
 ]

        TEQS    R9, #0
        BNE     %FT78                   ;V=0 don't return to parent once match found

        MOV     R7, R3
        BL      ToParent                ;(R3,R6->R3)
        CMPS    R3, R7
        BEQ     %FT78                   ;V=0 end when back to root if no match found

        BL      FindDir                 ;(R3->R0,R5,R6,V)
        BVS     %FT78

        BL      AgeDir                  ;(R7)
 [ BigDir
        BL      GetDirFirstEntry        ; (R3,R5->R4)
        BL      TestBigDir              ; (R3->LR,Z)
        SUBNE   R4, R4, #NewDirEntrySz
        SUBEQ   R4, R4, #BigDirEntrySize
 |
        SUB     R4, R5, #NewDirEntrySz-DirFirstEntry
 ]
75
 [ BigDir
        BL      TestBigDir              ; (R3->LR,Z)
        ADDEQ   R4, R4, #BigDirEntrySize
        ADDNE   R4, R4, #NewDirEntrySz
 |
        LDRB    LR, [R4, #NewDirEntrySz] !
 ]
        BL      ReadIndDiscAdd          ;(R3,R4->LR)
        TEQS    LR, R7
        BNE     %BT75
        MOV     R10,#DeleteChar
        BL      UnTermCommon            ;(R3,R4,R5,R10)
        MOV     R0, #DeleteChar
        BL      DoXOS_WriteC
        BVC     %BT72

78
        BL      UnlockMap
81
        BLVS    FindErrBlock            ;(R0->R0,V)
        BL      FileCoreExit
        Pull    "R7-R11,SB,PC"

        
TermCommon
        ; Print out a name from a dir
        MOV     R10,#0
UnTermCommon
        ; Unprint a name from a dir
        ; Entry  R4 = pointer to entry within the directory
        ; BigDir R3 = disc address
        ;        R5 = directory start
        ; Exit   R10 corrupted for 'TermCommon'
        Push    "R0,R2,R11,LR"
 [ BigDir
        BL      TestBigDir      ;(R3->LR,Z)
        BNE     %FT47           ; when not a big dir use simpler code
        
        LDR     R11, [R4, #BigDirObNameLen]
        BL      GetBigDirName   ; (R4,R5->LR) get the name ptr
        MOV     R2, LR
45
        LDRB    LR, [R2], #1
        MOVS    R0, R10
        MOVEQ   R0, LR

        BL      DoXOS_WriteC
        ADDVS   SP, SP, #4*4
        BVS     %BT78
        SUBS    R11,R11,#1
        BHI     %BT45
        Pull    "R0,R2,R11,PC"
47
 ]
        ADD     R2, R4, #DirObName
        MOV     R11,#NameLen
48
        LDRB    LR, [R2], #1
        MOVS    R0, R10
        MOVEQ   R0, LR
        CMPS    LR, #DeleteChar
        CMPNES  LR, #" "
        Pull    "R0,R2,R11,PC",LS

        BL      DoXOS_WriteC
        ADDVS   SP, SP, #4*4
        BVS     %BT78
        SUBS    R11,R11,#1
        BHI     %BT48
        Pull    "R0,R2,R11,PC"

; ==============
; DoDefectMapOut
; ==============

; entry:
;       r0 = disc address to be mapped out
;       r3 = top 3 bits disc number
;       Map for disc must be BeforeAlterFsMapped

; exit:
;       V, r0=error possible
;       r8 = extra info on error (in particular the obj Id containing the defect)

DoDefectMapOut ROUT
        Push    "R0-R11,LR"

 [ DebugQ
        DREG    r0,"DoDefectMapOut(",cc
        DREG    r3,",",cc
        DLINE   ")"
 ]

        ; Can't map out defects on old maps - tough
        BL      TestMap         ;(R3->Z)
        MOVNE   R0, #DefectErr
        BLNE    SetV
 [ DebugQ
        BVC     %FT01
        DLINE   "Wrong sort of map"
01
 ]
        BVS     %FT81

        ; Get the parameters for this map
        BL      CritInitReadNewFs       ;(->R10,R11)

        ; Find the map ptr and zone for the defect
        LDR     r0, [sp, #0*4]
        BL      DiscAddToMapPtr         ;(R0,R10->R11,LR)
        MOV     R1, R11
        MOV     R0, LR

        ; Start wandering through that zone
        BL      InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        MOV     R5, LR
        TEQS    R9, R8
        MOVEQ   R9, #0
        MOV     R0, #bit31      ;rogue previous fragment
        B       %FT12

06
        TEQS    R11,R9
        BNE     %FT09
 [ BigMaps
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
 |
        BL      RdLinkBits      ;(R10,R11->R8,Z)
 ]
        MOVEQ   R9, #0
        ADDNE   R9, R11,R8
        MOV     R8, R11
09
        MOV     R0, R11
        MOV     R11,R4
12
 [ BigMaps
        TEQS    R11,R9          ;is it a gap?
        BLEQ    FreeRdLenBits   ; yes (R10,R11->R7)
        BLNE    FragRdLenBits   ; no  (R10,R11->R7)
 |
        BL      RdLenBits       ;(R10,R11->R7)
 ]
        ADD     R4, R11,R7
        CMPS    R4, R1
        BLS     %BT06           ;loop if not reached defect fragment

        TEQS    R11,R9
        BNE     %FT51           ;defect not in a free space

        Push    "R8,R9"
 [ BigMaps
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
 |
        BL      RdLinkBits      ;(R10,R11->R8,Z)
 ]
        MOVEQ   R9, #0
        ADDNE   R9, R11,R8
        STR     R9, [SP, #4]
        MOV     R3, R11
        BL      AllocBitWidth   ;(R10->LR)
        MOV     R9, LR
        SUB     LR, LR, #1
        BIC     R1, R1, LR      ;round defect down to start of allocation unit
        ADD     R6, R1, R9      ;earliest possible defect end
        BL      MinMapObj       ;(R10->LR)
        MOV     R2, LR

        ; Registers here:
        ; R0 = previous fragment start - top bit set if none
        ; R1 = Defect start at allocation unit boundary
        ; R2 = MinMapObj
        ; R3 = Start of free object bad block was found in
        ; R4 = Start of fragment after free fragment containing bad block
        ; R5 = end of fragment list
        ; R6 = Earliest end of defect object (based on allocation width)

15
 [ DebugQ
        DREG    r1,"Trying defect from ",cc
        DREG    r6," to "
 ]
        SUB     LR, R1, R3      ; Space before defect
        CMPS    LR, R2
        BHS     %FT18           ; Branch if enough gap before defect for a whole object

        ; Not enough room before defect to fit an object
        MOV     R1, R3
        MOVS    R11,R0
 [ BigMaps
        BLPL    FragRdLenLinkBits ;(R10,R11->R7,R8)
 |
        BLPL    RdLenLinkBits   ;(R10,R11->R7,R8)
 ]
        TEQPLS  R8, #1
        MOVEQ   R1, R0          ; EQ if previous object is a bad block object, ie
                                ; if there's no room for free space before the defect
                                ; and the previous object is a bad block then stretch
                                ; that to cover the defect

18
        SUB     LR, R4, R6      ; Space after defect
        CMPS    LR, R2
        BHS     %FT21           ; Branch if there's still room for another fragment

        ; There isn't room after the defect for an object and there's an object after
        ; the free fragment containing the defect
        MOV     R6, R4
        MOV     R11,R4

        ; Branch if there's not another fragment after this free fragment
        CMP     R4, R5
        BHS     %FT21

        ; If there is another fragment, is it a bad block fragment?
 [ BigMaps
        BL      FragRdLenLinkBits ;(R10,R11->R7,R8)
 |
        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
 ]
        TEQS    R8, #1
        ADDEQ   R6, R4, R7      ; Object after defect is a bad block - stretch it down over the defect

21
        ; Now check defect fragment is big enough
        SUB     LR, R6, R1
        CMPS    LR, R2
        BHS     %FT24

        ; Defect fragment isn't big enough, so stretch defect
        ; fragment up if possible, else stretch it down and try again...
        CMPS    R6, R4
        ADDLO   R6, R6, R9
        SUBHS   R1, R1, R9
        B       %BT15

24
        Pull    "R8,R9"

        ; Write the defect fragment
        MOV     R0, #1
 [ BigMaps
        BL      FragWrLinkBits  ;(R0,R1,R10)
 |
        BL      WrLinkBits      ;(R0,R1,R10)
 ]
        SUB     R0, R6, R1
 [ DebugQ
        DREG    R0, "Writing defect block length of "
 ]
 [ BigMaps
        BL      FragWrLenBits   ;(R0,R1,R10)
 |
        BL      WrLenBits       ;(R0,R1,R10)
 ]

        ; next free fragment
        SUBS    R7, R1, R3
        MOV     R1, R8
        MOVHI   R0, R3
 [ DebugQ
        BLS     %FT01
        DREG    R0, "(a)Writing freelink to ",cc
        DREG    R1, " at "
01
 ]
        BLHI    WrFreeNext      ;(R0,R1,R10)
        MOVHI   R0, R7
        MOVHI   R1, R3
 [ DebugQ
        BLS     %FT01
        DREG    R0, "(b)Writing length of ",cc
        DREG    R1, " at "
01
 ]
 [ BigMaps
        BLHI    FreeWrLenBits   ;(R0,R1,R10)
 |
        BLHI    WrLenBits       ;(R0,R1,R10)
 ]

        ; previous free fragment
        CMPS    R4, R6
        MOVHI   R0, R6
 [ DebugQ
        BLS     %FT01
        DREG    R0, "(c)Writing freelink to ",cc
        DREG    R1, " at "
01
 ]
        BLHI    WrFreeNext      ;(R0,R1,R10)
        SUBHI   R0, R4, R6
        MOVHI   R1, R6
 [ DebugQ
        BLS     %FT01
        DREG    R0, "(d)Writing length of ",cc
        DREG    R1, " at "
01
 ]
 [ BigMaps
        BLHI    FreeWrLenBits   ;(R0,R1,R10)
 |
        BLHI    WrLenBits       ;(R0,R1,R10)
 ]

        ; previous previous free fragment
        MOV     R0, R9
 [ DebugQ
        DREG    R0, "(e)Writing freelink to ",cc
        DREG    R1, " at "
 ]
        BL      WrFreeNext      ;(R0,R1,R10)

        ; Write the whole lot out
 [ DebugQ
        DLINE   "Writing out the FsMap"
 ]
        BL      WriteFsMap      ;(->R0,V)
 [ DebugQ
        DLINE   "FsMap now written out"
 ]
        BVS     %FT78

27
        ; Now update the bad block list (if present)

        ; Pick up bad block's address
        LDR     r2, [sp, #0*4]          ; r0in

        ; Base presence of defect list on presence of defect list
        LDR     r3, [sp, #3*4]
        MOV     LR, R3, LSR #(32-3)
        DiscRecPtr LR, LR
        LDRB    LR, [LR, #DiscsDrv]
        DrvRecPtr LR, LR
        LDRB    LR, [LR, #DrvFlags]
        TST     LR, #HasDefectList
        BEQ     %FT78                   ; No defect list - sad

 [ BigDisc ;SBP: Thu 15th December 1994 - walked thru, looks OK
        BL      UpdateBadBlockList      ; UpdateBadBlockList now sep. routine
        B       %FT78
51
        ; Defect found in non-free block - has it already been mapped out?
 [ BigMaps
        BL      FragRdLinkBits  ;(R10,R11->R8,Z)
 |
        BL      RdLinkBits      ;(R10,R11->R8,Z)
 ]
        TEQS    R8, #1
        BEQ     %BT27           ; Yes, already mapped out

 [ DebugQ
        DLINE   "Not in free space"
 ]

        MOV     r0, #DefectErr
        BL      SetV
        STR     r8, [sp, #8*4]
78
81
 [ DebugQ
        DLINE   "Defect map-out attempt complete"
 ]
        STRVS   r0, [sp, #0*4]
        Pull    "R0-R11,PC"

 | ; BigDisc

 [ DebugQ
        DLINE   "Updating the bad block list"
 ]

        MOV     LR, R3, LSR #(32-3)
        DiscRecPtr LR, LR
        LDRB    LR, [LR, #DiscsDrv]
        LDR     R0, DefectSpace
        ADD     R0, SB, R0
        ASSERT  SzDefectList = 1 :SHL: 9
        ADD     R0, R0, LR, LSL #9

        SUB     R1, R0, #4
30
        LDR     LR, [R1, #4]!
        CMPS    LR, R2
        BLO     %BT30

 [ DebugQ
        BNE     %FT01
        DLINE   "Defect already in list"
01
 ]
        BEQ     %FT78           ;defect already in list

        MOV     R4, R1
33
        TSTS    LR, #DiscBits
        LDREQ   LR, [R4, #4]!
        BEQ     %BT33

        LDR     LR, [R4, #4]!
        TEQS    LR, #0
 [ DebugQ
        BEQ     %FT01
        DLINE   "Defect list full"
01
 ]
        BNE     %FT78           ;defect list full

36
        LDR     LR, [R4, #-4]!  ;move up defect list
        STR     LR, [R4, #4]
        CMPS    R4, R1
        BHI     %BT36
        STR     R2, [R1]

        MOV     R4, R0
        MOV     R1, #0
39
        LDR     LR, [R4], #4
        TSTS    LR, #DiscBits
        EOREQ   R1, LR, R1, ROR #13
        BEQ     %BT39
        EOR     R1, R1, R1, LSR #16
        EOR     R1, R1, R1, LSR #8
        STRB    R1, [R4, #-4]

        MOV     R1, #SzDefectList
        BL      CheckSum        ;(R0,R1->R0-R2,V)
        SUB     R1, R1, #1
        STRB    R2, [R0, R1]
        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        AND     R2, R3, #DiscBits
        ASSERT  :LNOT: BigSectors
        ADD     R2, R2, #DefectListDiscAdd
        MOV     R3, R0
        MOV     R4, #SzDefectList
        BL      DoDiscOp        ;(R1-R4->R0,R2-R4,V)
 [ DebugQ
        DLINE   "Bad block list now written out"
 ]
        B       %FT78

51
        ; Defect found in non-free block - has it already been mapped out?
        BL      RdLinkBits      ;(R10,R11->R8,Z)
        TEQS    R8, #1
        BEQ     %BT27           ; Yes, already mapped out

 [ DebugQ
        DLINE   "Not in free space"
 ]

        MOV     r0, #DefectErr
        BL      SetV
        STR     r8, [sp, #8*4]

78

81
 [ DebugQ
        DLINE   "Defect map-out attempt complete"
 ]
        STRVS   r0, [sp, #0*4]
        Pull    "R0-R11,PC"

 ] ; BigDisc

 [ BigDisc

; ==================
; UpdateBadBlockList
; ==================

; entry:
;       r2 = disc address to be mapped out
;       r3 = top 3 bits disc number
;       Map for disc must be BeforeAlterFsMapped

; exit:
;       V, r0=error possible

UpdateBadBlockList ROUT

 [ DebugQ
        DLINE   "Updating the bad block list"
 ]

 ; keep disc record pointer in R5

        MOV     LR, R3, LSR #(32-3)
        DiscRecPtr R5, LR
        LDRB    LR, [R5, #DiscsDrv]
        LDR     R0, DefectSpace
        ADD     R0, SB, R0
        ASSERT  SzDefectList = 1 :SHL: 9
        ADD     R0, R0, LR, LSL #9

        MOV     R4, #DefectList_End
        LDRB    LR, [R5, #DiscRecord_Log2SectorSize]   ; get sector size
        MOV     R4, R4, LSR LR
        CMP     R2, R4                  ; is the defect in the first or second list?
        BHS     %FT50                   ; in second defect list

; in first list.  shift left to get byte address

        MOV     R2, R2, LSL LR

        SUB     R1, R0, #4
30
        LDR     LR, [R1, #4]!
        CMPS    LR, R2
        BLO     %BT30

 [ DebugQ
        BNE     %FT01
        DLINE   "Defect already in list"
01
 ]
        BEQ     %FT81           ;defect already in list

        MOV     R4, R1
33
        TSTS    LR, #DiscBits
        LDREQ   LR, [R4, #4]!
        BEQ     %BT33

; found end of first list - is there a second list?

        ; use BigFlag field for test
        LDRB    LR, [R5,#DiscRecord_BigMap_Flags]
        TSTS    LR, #DiscRecord_BigMap_BigFlag
        BNE     %FT40

; no second defect list, use normal code

35
        LDR     LR, [R4, #4]!
        TEQS    LR, #0
 [ DebugQ
        BEQ     %FT01
        DLINE   "Defect list full"
01
 ]
        BNE     %FT81           ;defect list full

36
        LDR     LR, [R4, #-4]!  ;move up defect list
        STR     LR, [R4, #4]
        CMPS    R4, R1
        BHI     %BT36
        STR     R2, [R1]        ; Insert

        MOV     R4, R0
        MOV     R1, #0
        B       %FT59           ; Checksum it and write it out

40
; second defect list present.  Have to find its end too, and bump it up if need be

        MOV     R6, R4
        LDR     LR, [R6, #4]!
43
        TSTS    LR, #DiscBits
        LDREQ   LR, [R6, #4]!
        BEQ     %BT43

45
        LDR     LR, [R6, #4]!
        TEQS    LR, #0
 [ DebugQ
        BEQ     %FT01
        DLINE   "Defect list full"
01
 ]
        BNE     %FT81           ;defect list full

46
        LDR     LR, [R6, #-4]!  ;move up defect list
        STR     LR, [R6, #4]
        CMPS    R6, R1
        BHI     %BT46
        STR     R2, [R1]        ; Insert

        MOV     R4, R0
        MOV     R1, #0
        B       %FT59           ; Checksum it and write it out
50
; here the defect is in the second defect list.  Move to this list,
; and use similar code to that above to adjust the list.

        ; for safety, check if second defect list actually present
        ; if not there then do nothing.  (Could be unix disc)
        LDRB    LR, [R5, #DiscRecord_BigMap_Flags]
        CLRV    ; this is not an error condition
        TSTS    LR, #DiscRecord_BigMap_BigFlag
        BEQ     %FT81

; first, find end of the first defect list

        MOV     R6, R0
51
        LDR     LR, [R6], #4
        TSTS    LR, #DiscBits
        BEQ     %BT51

; R6 now points to start of 2nd defect list

        SUB     R1, R6, #4
52
        LDR     LR, [R1, #4]!
        CMPS    LR, R2
        BLO     %BT52

 [ DebugQ
        BNE     %FT01
        DLINE   "Defect already in list"
01
 ]
        BEQ     %FT81           ;defect already in list

        MOV     R4, R1
53
        TSTS    LR, #DiscBits
        LDREQ   LR, [R4, #4]!
        BEQ     %BT53

        LDR     LR, [R4, #4]!
        TEQS    LR, #0
 [ DebugQ
        BEQ     %FT01
        DLINE   "Defect list full"
01
 ]
        BNE     %FT81           ;defect list full

56
        LDR     LR, [R4, #-4]!  ;move up defect list
        STR     LR, [R4, #4]
        CMPS    R4, R1
        BHI     %BT56
        STR     R2, [R1]        ; Insert

        MOV     R4, R6
        MOV     R1, #0
59
        LDR     LR, [R4], #4
        TSTS    LR, #DiscBits
        EOREQ   R1, LR, R1, ROR #13
        BEQ     %BT59
        EOR     R1, R1, R1, LSR #16
        EOR     R1, R1, R1, LSR #8
        STRB    R1, [R4, #-4]

        MOV     R1, #SzDefectList
        BL      CheckSum        ;(R0,R1->R0-R2,V)
        SUB     R1, R1, #1
        STRB    R2, [R0, R1]

; generate disc address (sector address)
        LDRB    R1, [R5, #DiscRecord_Log2SectorSize]
        MOV     LR, #DefectListDiscAdd
        AND     R2, R3, #DiscBits
        ADD     R2, R2, LR, LSR R1

      [ BigSectors
        ; The defect list might not be on a sector boundary anymore
        ASSERT  (DefectListDiscAdd :MOD: 1024) = 0
        CMP     R1, #10
        MOVLS   R3, R0                  ; Go direct
        MOVLS   R4, #SzDefectList
        BLS     %FT78
 [ DebugQ
        DLINE   "Having to read/modify/write defect list"
 ]
        Push    "R0-R2"
        ASSERT  ?ScratchSpace >= SzDefectList
        MOV     R3, #ScratchSpace
        ASSERT  SzDefectList <= 1:SHL:11
        MOV     R4, #1
        MOV     R4, R4, LSL R1
        MOV     R1, #DiscOp_ReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        BL      DoDiscOp        ;(R1-R4->R0,R2-R4,V)
        ADDVS   sp, sp, #3*4
        BVS     %FT81

        LDMIA   sp, {R0-R1}             ; R0 := src R1 := Log2SectorSize
        MOV     R14, #DefectListDiscAdd
        MOV     R2, R14, LSR R1
        SUB     R1, R14, R2, LSL R1     ; defect list addr MOD sector size
        ADD     R1, R1, #ScratchSpace   ; dest
        MOV     R2, #SzDefectList       ; len
        ASSERT  (SzDefectList :MOD: 256) = 0
        BL      Move256n                ; (R0-R2->R0-R2)
        Pull    "R0-R2"
        MOV     R3, #ScratchSpace
        MOV     R4, #1
        MOV     R4, R4, LSL R1          ; ...and write back
78
      |
        MOV     R3, R0
        MOV     R4, #SzDefectList
      ]
        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        BL      DoDiscOp        ;(R1-R4->R0,R2-R4,V)
 [ DebugQ
        DLINE   "Bad block list now written out"
 ]
81
 [ DebugQ
        DLINE   "Defect map-out attempt complete"
 ]
        STRVS   r0, [sp, #0*4]
        Pull    "R0-R11,PC"
 ]

; >>>>>>>>>>
;  Dismount
; >>>>>>>>>>

Dismount_Code ROUT
        SemEntry  Flag,Dormant          ;leaves SB,LR stacked
        Push    "R0"
 [ DebugL
 DSTRING r0, "Dismount on "
 ]
        TEQS    R1, #0
        BNE     %FT20

        BL      IdentifyCurrentDisc     ;(->R0,R3,V) If no param dismount current disc
10
        MOVVC   R1, R3, LSR #(32-3)
        BLVC    ActiveDismountDisc      ;(R1->R0,V)
        B       %FT95

20
        MOV     R1, R0                  ;string ptr
        MOV     R2, #MustBeDisc
        BLNE    FullLookUp              ;(R1,R2->R0-R6,V)
        BVC     %BT10                   ;If disc name parsed ok then dismount it

        TEQS    R0, #AmbigDiscErr
        BNE     %FT50

        MOV     R2, #0          ;clear error flag
        MOV     R3, #0
        sbaddr  R4, DiscRecs+DiscRecord_DiscName
30
        LDRB    LR, [R4,#Priority - DiscRecord_DiscName]
        TEQS    LR, #0
        BEQ     %FT40           ;unused disc rec
        BL      TestDir         ;(R3->LR,Z)
        MOVEQ   R5, #&FF        ;set up bit 7 chars mask
        MOVNE   R5, #&7F
        BL      LexEqv          ;(R1,R4,R5->LO/EQ/HI)
        BNE     %FT40           ;mismatch

        Push    "R1"
        MOV     R1, R3, LSR #(32-3)
        BL      ActiveDismountDisc ;(R1->R0,V)
        MOVVS   R2, R0
        Pull    "R1"

40
        ADD     R4, R4, #SzDiscRec
        ADDS    R3, R3, #1 :SHL: (32-3) ;inc disc num bits
        BCC     %BT30                   ;loop for next disc rec

        B       %FT60

50
        MOV     R2, R0
        LDR     R1, [SP]
        BL      ParseDrive              ;(R1->R0,V)
        BLVC    DriveContentsUnknown    ;(R0)
60
        MOV     R0, R2
        BL      SetVOnR0
95
        BL      FileCoreExit
        BLVS    FindErrBlock            ;(R0->R0,V)
        Pull    "R1,SB,PC"


; ====================
; DriveContentsUnknown
; ====================

; force Drive contents unknown
;
; entry r0 = drive

DriveContentsUnknown
        Push    "r0,lr"
 [ Debug4 :LOR: DebugL
        DREG    r0, "DriveContentsUnknown(",cc
        DLINE   ")"
 ]
        BL      UnlinkByDrive   ;(R0)
        DrvRecPtr r0, r0
        MOV     lr, #Uncertain :OR: Unknown
        STRB    lr, [r0, #DrvsDisc]
        LDRB    lr, [r0, #DrvFlags]
        BIC     lr, lr, #LastDiscOpWasFormat
        STRB    lr, [r0, #DrvFlags]
 [ DebugL
        DLINE   "LastDiscOpWasFormat clear (C)"
 ]
        Pull    "r0,pc"


; ==================
; ActiveDismountDisc
; ==================

; entry R1 = disc
; exit If error V set, R0 error

; As DismountDisc, but this dismount is triggered by the user actively dismounting
; rather than the dismount happening behind the user's back. The main difference
; being that ActiveDismountDisc sends a Service_DismountDisc.

ActiveDismountDisc ROUT
        Push    "r1,r2,r3,r11,lr"
        MOV     r11,sp

        ; Calculate length needed for a suitable stack frame and grab that
        LDR     r1, FS_Title
        BL      strlen
        ADD     r3, r3, #2+NameLen+1+3  ; 2 for ::, NameLen for disc title, 1 for terminator, 3 for round-up
        BIC     r3, r3, #3
        SUB     sp, sp, r3

        ; Copy FS_Title
        MOV     r2, sp
10
        LDRB    lr, [r1], #1
        CMP     lr, #" "
        STRHIB  lr, [r2], #1
        BHI     %BT10

        ; Copy ::
        MOV     lr, #":"
        STRB    lr, [r2], #1
        STRB    lr, [r2], #1

        ; Generate disc name or drive number as appropriate
        LDR     r1, [r11, #0*4]
        DiscRecPtr r3, r1
        ADD     r3, r3, #DiscRecord_DiscName
        LDRB    lr, [r3], #1
        CMP     lr, #" "
        BLS     %FT30

        MOV     r1, #NameLen

20
        STRB    lr, [r2], #1
        LDRB    lr, [r3], #1
        CMP     lr, #" "
        SUBHIS  r1, r1, #1
        BHI     %BT20

        B       %FT40

30
        LDRB    lr, [r3, #DiscsDrv - DiscRecord_DiscName - 1]
        EOR     lr, lr, #4              ; Convert to external numbering
        ADD     lr, lr, #"0"
        STRB    lr, [r2], #1

40
        ; Terminate the string
        MOV     lr, #0
        STRB    lr, [r2], #1

        ; Do the service
        MOV     r1, #Service_DiscDismounted
        MOV     r2, sp
 [ DebugL
        DREG    r1, "Issuing service ",cc
        DSTRING r2, " with r2="
 ]
        BL      DoXOS_ServiceCall
        LDRVC   r1, [r11, #0*4]         ; r1 in
        BLVC    DismountDisc

        MOV     sp, r11
        Pull    "r1,r2,r3,r11,pc"

; ============
; DismountDisc
; ============

; entry R1 = disc
; exit If error V set, R0 result

DismountDisc
        Push    "R0-R7,LR"

        ; Hold the disc in R6
        MOV     R6, R1

        ; Check disc in use
        DiscRecPtr  LR, R6
        LDRB    R0, [LR,#Priority]
        TEQS    R0, #0
        BEQ     %FT95

        MOV     R5, #0          ; error accumulator

        BL      CloseAllByDisc  ;(R1->R0,V)
        MOVVS   R5, R0

  [ DebugL
        DREG    R6, "Dismounting disc "
  ]
        ; Test for defect list presence properly
        DiscRecPtr  LR, R6
        LDRB    R7, [LR, #DiscsDrv]
  [ DebugL
        DREG    R7, "  = drive "
  ]
        ; If not attached to a drive skip drive specific sequence
        TEQ     R7, #8
        BEQ     %FT50

        DrvRecPtr  R2, R7

  [ DynamicMaps

        ; get rid of any free space map area

        Push    "R0-R8"
        MOV     R0, #2
        LDR     R1, [R2, #DrvsFsMapArea]
        BL      OnlyXOS_DynamicArea
        BVS     %FT01                           ; if error, then do nothing

        MOV     R0, R1
        RSB     R1, R2, #0                      ; amount to change size by
        BL      OnlyXOS_ChangeDynamicArea       ; do the change
01
        Pull    "R0-R8"

        MOV     LR, #0
        STR     LR, [R2, #DrvsFsMapSize]        ; mark the size as zero
  ]

        ; Clear the LastDiscOpWasFormat flag
        LDRB    LR, [R2, #DrvFlags]
        BIC     LR, LR, #LastDiscOpWasFormat
        STRB    LR, [R2, #DrvFlags]
 [ DebugL
        DLINE   "LastDiscOpWasFormat clear (D)"
 ]

        ; Park disc if has defect list, and is a hard disc
        TST     LR, #HasDefectList
        BEQ     %FT04                   ; no parking needed
        DiscRecPtr LR, R6               ; get disc record ptr
        LDRB    R0, [LR, #DiscRecord_Density]      ; is it a hard disc
        TEQ     R0, #DensityFixedDisc
        BNE     %FT04                   ; if not, don't park it

        MOV     R1, #DiscOp_Seek :OR: DiscOp_Op_IgnoreEscape_Flag;if winnie seek to park address given
        LDR     R2, DefectSpace         ;in defect Map
        ADD     R2, SB, R2
        ASSERT  SzDefectList = (1 :SHL: 9)
        ADD     R2, R2, R7, LSL #9
        LDR     R2, [R2,#ParkDiscAdd]

 [ BigDisc
        DiscRecPtr LR,R6
        LDR     R0, [LR, #DiscRecord_BigMap_DiscSize2]    ; get discsize2
        MOVS    R0, R0                  ; is it small (discsize < 2^29 bytes?)
        LDREQ   R0, [LR, #DiscRecord_DiscSize]
        TSTEQS  R0, #DiscBits           ; if so then ParkDiscAdd is in bytes
        LDREQB  LR, [LR,#DiscRecord_Log2SectorSize]    ; so shift it down to a sector address
        MOVEQ   R2, R2, LSR LR          ; else it's in sectors, leave it alone
        ORR     R2, R2, R6, LSL #(32-3)
  [ DebugL
        DREG    R2, "Parking at address "
  ]
        BL      DoDiscOp                ;(R1-R4->R0-R4)
04
 |
        ORR     R2, R2, R6, LSL #(32-3)
  [ DebugL
        DREG    R2, "Parking at address "
  ]
        BL      DoDiscOp                ;(R1-R4->R0-R4)
 ]

04      MOVVS   R5, R0

50
        MOV     R0, R6
        BL      FreeDiscRec     ;(R0)

        MOV     R0, R5
95
        BL      SetVOnR0
        STRVS   R0, [SP]
        Pull    "R0-R7,PC"


; >>>>>>>
;  Drive
; >>>>>>>

Drive_Code ROUT
        SemEntry   Flag,Dormant ;leaves SB,LR stacked
        MOV     R1, R0          ;string ptr
        BL      ParseAnyDrive   ;(R1->R0,Z,C,V)
        STRVCB  R0, Drive
        BLVS    FindErrBlock    ;(R0->R0,V)
        BL      FileCoreExit
        Pull    "SB,PC"


; =======
; Confirm
; =======

; exit V=1 <=> error
; Z=1 <=> confirmed

TerseConfirm ROUT       ;entry V=0
        Push    "R0,LR"
        B       %FT10

ConfirmText
        =       "AreYouSure",0
        ALIGN

Confirm                 ;entry V don't care
        Push    "R0,LR"
        ADR     r0, ConfirmText
        BL      message_gswrite0
10
        MOVVC   r0, #OsByte_FlushInputBuffer
        MOVVC   r1, #1
        SWIVC   XOS_Byte
        SWIVC   XOS_Confirm
        BLVC    ConvertEscapeToError

        SavePSR r1
        SWIVC   XOS_WriteC
        SWIVC   XOS_NewLine

        ORRVS   r1, r1, #V_bit
        BICVS   r1, r1, #Z_bit  ; NE on error
        RestPSR r1,,f
        STRVS   R0, [SP]
        Pull    "R0,PC"


; ================
; FlushAndReadChar
; ================

;In:
;Out: r0 = char read or VS and r0=error (includes escapes)
FlushAndReadChar ROUT
        Push    "R1,R2,LR"
        MOV     R0, #OsByte_FlushInputBuffer
        MOV     R1, #1
        BL      OnlyXOS_Byte
        BLVC    DoXOS_ReadC
        BLVC    ConvertEscapeToError
        Pull    "R1,R2,PC"

; ====================
; ConvertEscapeToError
; ====================

; In: VC and C=escape was pressed
; Out: r0=escape error is CS in

ConvertEscapeToError ROUT
        MOVCC   pc, lr
        Push    "r1,r2,lr"

        ; Acknowledge the escape
        MOV     r0, #OsByte_AcknowledgeEscape
        BL      OnlyXOS_Byte

        ; Convert to error
        MOVVC   r0, #ExtEscapeErr
        SETV

        Pull    "r1,r2,pc"


; >>>>>>
;  Free
; >>>>>>

FC0     DCB     "FC0",0
FC1     DCB     "FC1",0
FCK0    DCB     "FCK0",0
FCK1    DCB     "FCK1",0
        ALIGN

Free_Code ROUT
        SemEntry   Flag, Dormant        ;leaves SB,LR stacked

        MOV     r5, sp

        MOV     r1, r0
        BL      strlen
        MOV     r2, r3
        LDR     r1, FS_Title
        BL      strlen
        ADD     r3, r3, r2
        ADD     r3, r3, #2 + 1 + 3      ; 2 for ::, one for terminator, 3 for round-up
        BIC     r3, r3, #3

        SUB     sp, sp, r3
        MOV     r2, r1                  ; FS_Title
        MOV     r1, sp
        BL      strcpy
        BL      strlen
        ADD     r1, r1, r3
        MOV     lr, #":"
        STRB    lr, [r1], #1            ; :

        LDRB    lr, [r0]                ; 2nd : if disc specifier present
        CMP     lr, #' '
        MOVHI   lr, #':'
        STRHIB  lr, [r1], #1

        MOV     r2, r0
        LDRB    lr, [r2]                ; disc specifier (excluding : prefix)
        TEQ     lr, #":"
        ADDEQ   r2, r2, #1
        BL      strcpy

        MOV     r1, sp

 [ BigDisc
        MOV     r6, r0                  ; keep copy of command tail ptr
        MOV     r0, #FSControl_ReadFreeSpace64  ; get the full free space info
  [ DebugQ
        DSTRING r1, "ReadFreeSpace on "
  ]
        BL      DoXOS_FSControl
        BVC     %FT01   ; if no error then do not try the other FSControl

; here, we have a FS which doesn't support FSControl_ReadFreeSpace64 - try
; FSControl_ReadFreeSpace

        MOV     r0, #FSControl_ReadFreeSpace
        MOV     r1, sp                  ; restore FS name
        MOV     r2, r6                  ; restore command tail
        BL      DoXOS_FSControl

; now munge results
        MOV     r4, #0                  ; high 32 0
        MOV     r3, r2                  ; low 32
        MOV     r2, r1                  ; max object size
        MOV     r1, #0                  ; high 32 0

01
  [ DebugQ
        DREG    r0, "FreeSpace is (",cc
        DREG    r1,,cc
        DREG    r2, ",",cc
        DREG    r3, ",",cc
        DREG    r4, ",",cc
        DLINE   ")"
  ]

 |
        MOV     r0, #FSControl_ReadFreeSpace
  [ DebugQ
        DSTRING r1, "ReadFreeSpace on "
  ]
        BL      DoXOS_FSControl
  [ DebugQ
        DREG    r0, "FreeSpace is (",cc
        DREG    R1, ",",cc
        DREG    R2, ",",cc
        DLINE   ")"
  ]

 ]

        MOV     sp, r5

        BVS     %FT80

 [ BigDisc
; first, determine whether big or not.  By big here we mean >4G
        CMPS    r4, #0
        MOV     r7, r4
        BEQ     %FT50

; big disc
        SUBS    r2, r3, r0
        SBC     r3, r4, r1
; now r0,r1=free space and r2,r3=used space
        baddr   r5, FCK0
        BL      %FT90
        MOVVC   r0, r2
        MOVVC   r1, r3
        baddr   r5, FCK1, VC
        BLVC    %FT90
        B       %FT80
50
; small disc
        SUB     r3, r3, r0
        baddr   r5, FC0
        BL      %FT90
        MOVVC   r0, r3
        MOVVC   r1, #0
        baddr   r5, FC1, VC
        BLVC    %FT90
 |
        SUB     r3, r2, r0
        baddr   r5, FC0
        BL      %FT90
        MOVVC   r0, r3
        baddr   r5, FC1, VC
        BLVC    %FT90
 ]

80
        BLVS    FindErrBlock            ;(R0->R0,V)
        BL      FileCoreExit
        Pull    "SB,PC"

 [ BigDisc
; entry r0,r1=number to subst Hex16 into %0 and right justified formatted 4byte cardinal into %1 (Kbytes)
;      r7!=0 implies big disc
;        ==0 implies small disc
;       r5 = tag
; exit  r1,r4-r6 trashed
 |
; entry r0=number to subst Hex8 into %0 and right justified formatted 4byte cardinal into %1
;       r5 = tag
; exit  r1-r2,r4-r6 trashed
 ]
90
 [ BigDisc
        Push    "r0,r2,lr"
        SUB     sp, sp, #52                             ; Make a frame to do the conversions into
 |
        Push    "r0,lr"
        SUB     sp, sp, #28                             ; Make a frame to do the conversions into
 ]

        ; Convert into Hex and Decimal
        MOV     r4, r0
 [ BigDisc
; do hex number of bytes; do M.S. word first then tack on L.S. word
        MOV     r6, r1
        MOVS    r7, r7
        BEQ     %FT10
        MOV     r0, r1
        ADD     r1, sp, #16
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        BVS     %FT99
        MOV     r0, r4
        ADD     r1, sp, #24
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        B       %FT20
10
        MOV     r0, r4
        ADD     r1, sp, #16
        MOV     r2, #12
        SWI     XOS_ConvertHex8

20
 |
        ADD     r1, sp, #16
        MOV     r2, #12
        SWI     XOS_ConvertHex8
 ]

 [ BigDisc
        ; first generate number of Kbytes in r0
        BVS     %FT99           ; skip code that may corrupt VS state if already VS
        MOVS    r7, r7          ; check for big/small
        MOVEQ   r0, r4          ; if small then L.S only
        MOVNE   r0, r4, LSR #10 ; else shift right by 10 and combine
        ORRNE   r0, r0, r6, LSL #22 ; with L.S. word shifted
; now have either number of bytes or number of Kbytes as appropriate in r0

        MOV     r1, sp
        MOV     r2, #16
        BL      ConvertFormattedCardinal4
        BVS     %FT99
 |
        MOVVC   r0, r4
        MOVVC   r1, sp
        MOVVC   r2, #16
        BLVC    ConvertFormattedCardinal4
        BVS     %FT99
 ]

 [ DebugQ
        DLINE   "Conversions performed successfully"
 ]

        ; Copy decimal to end of buffer
92
        LDRB    lr, [r1], #-1
        STRB    lr, [r1, r2]
        CMP     r1, r0
        BHS     %BT92

 [ DebugQ
        DLINE   "Copied to end of buffer"
 ]

        ; Pad before with spaces
        MOV     lr, #" "
95
        SUBS    r2, r2, #1
        STRHIB  lr, [r1, r2]
        BHI     %BT95

 [ DebugQ
        DLINE   "Padded"
 ]

        MOV     r0, r5
        ADD     r4, sp, #16
        ADD     r5, sp, #2      ; Right justify into a 11-2=9 width field (11 = 12-1 for the terminator)
        BL      message_gswrite02

99
 [ BigDisc
        ADD     sp, sp, #52
        STRVS   r0, [sp]
        Pull    "r0,r2,pc"
 |
        ADD     sp, sp, #28
        STRVS   r0, [sp]
        Pull    "r0,pc"
 ]

ConvertFormattedCardinal4 ROUT
        ;       R0 is the value to convert
        ;       R1 is the buffer to convert into
        ;       R2 is the buffer size
        ;       Returns
        ;       R0 entry value of R1
        ;       R1 pointer to terminating zero
        ;       R2 size remaining in buffer, R2'=R2-(R1'-R0')

FormatFrameSize * 16

        Push    "r1, r2, r3, r4-r9, lr"                 ; R3 only there to make frame right
        DEC     sp, FormatFrameSize                     ; Frame for doing the conversion into
        MOV     r2, #FormatFrameSize - 1
FakeErrorCDATBufferOverflow
        MOV     r1, sp
        SWI     XOS_ConvertCardinal4
        SUBVC   r4, r1, r0                              ; Calculate the number of digits returned
        MOVVC   r0, #-1                                 ; Current territory
        MOVVC   r1, #1                                  ; Thousands separator
        SWIVC   XTerritory_ReadSymbols
        MOVVC   r5, r0                                  ; Save pointer
        MOVVC   r0, #-1                                 ; Current territory
        MOVVC   r1, #2                                  ; Character grouping
        SWIVC   XTerritory_ReadSymbols
        BVS     ExitConvertFormatted
        MOV     r6, r0                                  ; Save pointer
        SUB     r7, r5, #1                              ; Measure the separator string
SeparatorCountLoop
        LDRB    r0, [ r7, #1 ]!
        TEQ     r0, #0
        BNE     SeparatorCountLoop
        SUB     r7, r7, r5                              ; Compute the length
        ; Work out how long the result will be
        MOV     r8, r4                                  ; Length of result
        MOV     r9, r6                                  ; Grouping format pointer
        MOV     r2, #0                                  ; Current group size
        MOV     r1, #0                                  ; Distance along the source
FormatCountLoop
        LDRB    r14, [ r9 ]
        TEQ     r14, #0
        MOVNE   r2, r14                                 ; Use this grouping
        ADDNE   r9, r9, #1                              ; Ready for the next grouping
        TEQ     r2, #0                                  ; Don't do anything if format defective
        BEQ     FormatCountDone
        ADD     r1, r1, r2
        CMP     r1, r4                                  ; Would this group put us beyond the string?
        ADDLT   r8, r8, r7                              ; Add the separator length to the string
        BLT     FormatCountLoop
FormatCountDone
        ADD     r14, sp, #FormatFrameSize               ; Entry R1
        LDMIA   r14, { r1, r2 }
        SUB     r2, r2, r8
        CMP     r2, #1                                  ; Allow for the terminating zero
        MOVMI   r2, #1                                  ; Make a buffer that is too small
        MOVMI   r0, #100                                ; For this result
        BMI     FakeErrorCDATBufferOverflow
        ADD     r1, r1, r8
        ADD     r14, sp, #FormatFrameSize + 4           ; Exit R1
        STMIA   r14, { r1, r2 }
        ADD     r4, sp, r4                              ; Trailing zero of converted source string
        MOV     r2, #0                                  ; Current group size
        STRB    r0, [ r1 ], #-1                         ; Put the terminator on the destination
FormatCopyLoop
        LDRB    r14, [ r6 ]
        TEQ     r14, #0
        MOVNE   r2, r14                                 ; Use this grouping
        ADDNE   r6, r6, #1                              ; Ready for the next grouping
        TEQ     r2, #0                                  ; Don't do anything if format defective
        MOVEQ   r2, #-1
        MOV     r9, r2                                  ; R2 is the number of chars to copy across
CharacterCopyLoop
        LDRB    r14, [ r4, #-1 ]!
        STRB    r14, [ r1 ], #-1
        TEQ     r4, sp                                  ; Have we reached the last character?
        BEQ     FinishConvertFormatted
        SUBS    r9, r9, #1
        BNE     CharacterCopyLoop
        MOVS    r0, r7                                  ; Length of the separator
        BEQ     CharacterCopyLoop                       ; No separator to copy
SeparatorCopyLoop
        SUBS    r0, r0, #1
        LDRB    r14, [ r5, r0 ]
        STRB    r14, [ r1 ], #-1
        BNE     SeparatorCopyLoop
        B       FormatCopyLoop                          ; Start back again

FinishConvertFormatted
        CLRV
ExitConvertFormatted
        INC     sp, FormatFrameSize
        STRVS   r0, [ sp, #0 ]
        Pull    "r0, r1, r2, r4-r9, pc"


; >>>>>
;  Map
; >>>>>

MC0     DCB     "MC0",0
MC1     DCB     "MC1",0
MC2     DCB     "MC2",0
MC3     DCB     "MC3",0
MC4     DCB     "MC4",0
MC5     DCB     "MC5",0
MC6     DCB     "MC6",0
        ALIGN

Map_Code ROUT
        SemEntry   Flag,Dormant ;leaves SB,LR stacked
        Push    "R7-R11"
 [ BigDisc
        SUB     SP, SP, #40     ;string buffer
 |
        SUB     SP, SP, #20     ;string buffer
 ]
        CMPS    R1, #0          ;V=0
        BLEQ    IdentifyCurrentDisc     ;(->R0,R3,V)
        BVS     %FT95
        BEQ     %FT05
        MOV     R1, R0
        MOV     R2, #MustBeDisc
        BL      FullLookUp              ;(R1,R2->R0-R6,C,V)
        BVS     %FT95
05
        BL      DiscMustBeFileCore      ;(R3->V,R0)
        BVS     %FT95
        BL      DiscAddToRec            ;(R3->LR)
 [ BigDir
        LDR     r2, [LR, #DiscRecord_BigDir_DiscVersion]
        TEQS    r2, #0
        MOVEQ   r0, #0
        MOVNE   r0, #1          ; bit 0 is big dirs flag
        LDRB    r2, [LR, #DiscRecord_IdLen]
        CMPS    r2, #15
        ORRHI   r0, r0, #2
; r0 = 0 - not a new filecore disc
; r0 = 1 - big dirs, small map
; r0 = 2 - big map, small dirs, this case is only valid for IdLen=16
; r0 = 3 - big map, big dirs
        TEQS    r0, #1
        baddr   r0, MC4, EQ     ;(   start,  length) new map, big directories
        BEQ     %FT07
        TEQS    r0, #2
        baddr   r0, MC5, EQ     ;(   start,  length) big map, new directories
        BEQ     %FT07
        TEQS    r0, #3
        baddr   r0, MC6, EQ     ;(   start,  length) big map, big directories
        BEQ     %FT07
 ]
        LDRB    r2, [LR, #DiscFlags]
        TSTS    r2, #OldMapFlag
        BNE     %FT06
        TST     r2, #OldDirFlag
        baddr   r0, MC3, EQ     ;(   start,  length) new map, new directories
        baddr   r0, MC2, NE     ;(   start,  length) new map, old directories
        B       %FT07
06
        TST     r2, #OldDirFlag
        baddr   r0, MC1, EQ     ;(   start,  length) old map, new directories
        baddr   r0, MC0, NE     ;(   start,  length) old map, old directories
07
        BL      message_gswrite0

 [ BigDisc
; find the disc record
        BL      DiscAddToRec            ;(R3->LR) get the disc record
        LDR     R2, [LR, #DiscRecord_BigMap_DiscSize2]    ;
        MOVS    R2, R2
        MOVNE   R0, #28                 ;field width (Big Disc)
        MOVEQ   R0, #20                 ;field width (Small Disc)
        MOV     R2, #0
 |
        MOV     R2, #0
        MOV     R0, #20                 ;field width
 ]
        BL      ScreenFormat            ;(R0->R9-R11)
        ADD     R10,R10,#1              ;separating space
        BL      %FT99
        MOV     LR, #1
        STRB    LR, LastReEnter
10
        BL      BeforeReadFsMap         ;(R3->R0,V)
        BVS     %FT95
        LDRB    LR, LastReEnter
        TEQS    LR, #0
        MOVNE   LR, #0
        STRNEB  LR, LastReEnter
        BLNE    InitReadFs              ;(R3->R9-R11)
15
        BL      NextFs                  ;(R3,R9-R11->R7-R11,Z)
        BIC     R8, R8, #DiscBits
        BLEQ    UnlockMap
        BEQ     %FT20
        CMPS    R8, R2
        BLS     %BT15
        BL      UnlockMap
        MOV     R2, R8
        MOV     R1, R7
        MOV     R7, SP
        MOV     LR, #"("
        STRB    LR, [R7],#1
        MOV     R0, R8

 [ BigDisc ; SBP: Thu 15th December 1994 - walked thru, doesn't seem
; to support >4G discs.  Changed to support them.
        Push    "R1,R2"
        BL      DiscAddToRec            ;(R3->LR)
        LDRB    R1, [LR, #DiscFlags]
        TSTS    R1, #OldMapFlag
        BNE     %FT18                   ; old map, indirect disc addresses are in bytes already
        LDR     R1, [LR, #DiscRecord_BigMap_DiscSize2]
        MOVS    R1, R1
        LDRB    LR, [LR, #DiscRecord_Log2SectorSize]
        MOVEQ   R0, R0, LSL LR
        BEQ     %FT18                   ; small disc
        MOV     R1, R0,LSL LR
        RSB     LR, LR, #32
        MOVS    R0, R0, LSR LR
        BEQ     %FT16                   ; don't print number - pad spaces
        BL      PutHex2
        MOV     R0, R1
        BL      PutHexWord
        B       %FT19

; here when low address on big disc - pad with 8 spaces
16
        MOV     R0, #8
        MOV     LR, #' '
17
        STRB    LR, [R7],#1
        SUBS    R0, R0, #1
        BNE     %BT17
        MOV     R0, R1
18
        BL      PutHex2
; here when finished address and want to do length
19
        Pull    "R1,R2"
 |
        BL      PutHex2         ;(R0,R7->R7)
 ]
        MOV     R0, #","
        STRB    R0, [R7],#1
        MOV     R0, R1
        BL      PutHex2         ;(R0,R7->R7)
        MOV     LR, #")"
        STRB    LR, [R7],#1
        MOV     LR, #0
        STRB    LR, [R7],#1
        MOV     R7 ,SP
        BL      WriteString     ;(R7->R0,V)
        BL      %FT99
        BLVC    NextField       ;(R9-R11->R0,R11,V)
        BL      %FT99
        BVS     %FT95
        B       %BT10

20
        CMPS    R4, R6          ;V=0
        BLNE    DoXOS_NewLine   ;(->R0,V)
95
        BLVS    FindErrBlock    ;(R0->R0,V)
 [ BigDisc
        ADD     SP, SP, #40
 |
        ADD     SP, SP, #20
 ]
        BL      FileCoreExit
        Pull    "R7-R11,SB,PC"

99                      ;swap R4-R6 with R9-R11
        Push    "R4-R6,R9-R11,LR"
        Pull    "R9-R11"
        Pull    "R4-R6,PC"


RootText
 =       RootChar,0
        ALIGN

; >>>>>>>
;  Mount
; >>>>>>>

Mount_Code ROUT
        Push    "lr"
        MOV     r6, sp          ; Initial SP
 [ DebugQ
        DREG    r6, "r6 start "
 ]

        ; Convert no parameter to *mount <drive>
        TEQ     r1, #0
        LDREQ   r12, [r12]
        LDREQB  lr, Drive
        ASSERT  ("0" :AND: 7)=0
        EOREQ   lr, lr, #"0" :EOR: 4
        Push    "lr", EQ
        MOVEQ   r0, sp

        MOV     r1, r0

        ; Calculate the length required
        MOV     r2, #?RootLibText + 1 + 3   ; includes 0 terminator, 1 for . and 3 for rounding up
        MOV     r0, r1
10
        LDRB    lr, [r0], #1
        CMP     lr, #" "
        TEQHI   lr, #DeleteChar
        ADDHI   r2, r2, #1
        BHI     %BT10

        ; Ensure enough space for the : prefix
        LDRB    lr, [r1]
        TEQ     lr, #":"
        ADDNE   r2, r2, #1

        BIC     r2, r2, #3
        SUB     sp, sp, r2

        MOV     r2, sp


        ; :<disc>

        MOVNE   lr, #":"
        STRNEB  lr, [r2], #1

        MOV     r0, r1
20
        LDRB    lr, [r0], #1
        CMP     lr, #" "
        TEQHI   lr, #DeleteChar
        STRHIB  lr, [r2], #1
        BHI     %BT20

        ; .
        MOV     lr, #"."
        STRB    lr, [r2], #1

        ; Save position for later
        MOV     r3, r2

        ; $\0
        MOV     lr, #"$"
        STRB    lr, [r2], #1
        MOV     lr, #0
        STRB    lr, [r2], #1

        ; *Dir :<disc>.$
        MOV     r0, #FSControl_Dir
        MOV     r1, sp
 [ DebugQ
        DSTRING r1, "*Dir "
 ]
        SWI     XOS_FSControl
        BVS     %FT90

        baddr   r0, RootLibText
        MOV     r2, r3
30
        LDRB    lr, [r0], #1
        STRB    lr, [r2], #1
        TEQ     lr, #0
        BNE     %BT30

        ; Junk errors returned from these calls...

        ; *Lib :<disc>.$
        MOV     r0, #FSControl_Lib
        MOV     r1, sp
 [ DebugQ
        DSTRING r1, "*Lib "
 ]
        SWI     XOS_FSControl

        ; *NoURD
        MOV     r0, #FSControl_NoURD
 [ DebugQ
        DLINE   "*NoURD"
 ]
        SWI     XOS_FSControl

        CLRV

90
 [ DebugQ
        DREG    r6, "r6 end "
 ]
        MOV     sp, r6
        Pull    "pc"


; >>>>>>>>>>
;  NameDisc
; >>>>>>>>>>

NameDisc_Code ROUT
NameDisk_Code
        Push    "r0-r4,lr"

        MOV     r4, sp

        ; Find length of 1st string
        MOV     r3, #0
        MOV     r1, r0
10
        LDRB    lr, [r1], #1
        CMP     lr, #" "
        ADDHS   r3, r3, #1
        BHS     %BT10

        ; Skip to 1st non-space
20
        LDRB    lr, [r1], #1
        TEQ     lr, #" "
        BEQ     %BT20

        SUB     r1, r1, #1

        ; Add length of 2nd string
30
        LDRB    lr, [r1], #1
        CMP     lr, #" "
        ADDHI   r3, r3, #1
        BHI     %BT30

        ; Add enough for an extra :, \0 terminators and 3 for the round-up
        ADD     r3, r3, #1+1+1+3
        BIC     r3, r3, #3
        SUB     sp, sp, r3

        ; Copy the 1st string, adding a : if there isn't one already
        MOV     r2, sp
        LDRB    lr, [r0]
        TEQ     lr, #":"
        MOVNE   lr, #":"
        STRNEB  lr, [r2], #1

40
        LDRB    lr, [r0], #1
        CMP     lr, #" "
        STRHIB  lr, [r2], #1
        BHI     %BT40
        MOV     lr, #0
        STRB    lr, [r2], #1

        MOV     r1, r2

        ; Copy the 2nd string

        ; Skip to 1st non-space
60
        LDRB    lr, [r0], #1
        TEQ     lr, #" "
        BEQ     %BT60

        SUB     r0, r0, #1

70
        LDRB    lr, [r0], #1
        CMP     lr, #" "
        STRHIB  lr, [r1], #1
        BHI     %BT70
        MOV     lr, #0
        STRB    lr, [r1], #1


        ; Do the FSControl

        MOV     r0, #FSControl_NameDisc
        MOV     r1, sp

 [ DebugQ
        DREG    r0, "OS_FSControl(",cc
        DSTRING r1, ",",cc
        DSTRING r2, ",",cc
        DLINE   ")"
 ]
        SWI     XOS_FSControl

        MOV     sp, r4
        STRVS   r0, [sp]
        Pull    "r0-r4,pc"

VerifyStr
 = "VC0",0      ;Verifying ...
VerOk
 = "VC1",0      ;Verified OK
VerRetries
 = "VC2",0      ;Verified with retries
VerBad
 = "VC3",0      ;Verify failed
        ALIGN

; >>>>>>>>
;  Verify
; >>>>>>>>

Verify_Code ROUT
        SemEntry  Flag,Dormant          ;leaves SB,LR stacked
        Push    "R7-R11"

        TEQS    R1, #0
        BLEQ    IdentifyCurrentDisc     ;(->R0,R3,V)
        MOVNE   R2, #MustBeDisc
        MOVNE   R1, R0
        BLNE    FullLookUp      ;(R1,R2->R0-R6,V)
        baddr   R0, VerifyStr,VC
        BLVC    message_gswrite0
        MOVVC   R1, #DiscOp_Restore
        AND     R2, R3, #DiscBits
        BLVC    DoDiscOp        ;(R1-R4->R0,R2-R4,V)
        BVS     %FT85

        MOV     R1, #DiscOp_Verify
        MOV     R6, #0          ;clear error flag

;        BL      DiscMustBeFileCore      ; check if not filecore disc.

;        BVS     %FT70
        BL      TestMap         ;(R3->Z)
        BNE     %FT50

        ; Verify new map
        BL      BeforeReadFsMap ;(R3->R0,V)
        BVS     %FT85
        BL      CritInitReadNewFs       ;(->R10,R11)

        SUBS    R0, R0, R0      ;init zone = 0, Z=0, C=1, HS
        B       %FT30

10
        ADD     R11,R11,R7
20
        CMPS    R11,R5
        ADDHS   R0, R0, #1
30
 [ DebugQ
        DREG    R0, "Verify zone "
 ]
        BLHS    InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        MOVHS   R5, LR
 [ BigMaps
        LDRHSB  LR, [R10,#ZoneHead+DiscRecord_NZones]
        LDRHSB  R9, [R10,#ZoneHead+DiscRecord_BigMap_NZones2]
        ADDHS   LR, LR, R9, LSL #8
 |
        LDRHSB  LR, [R10,#ZoneHead+DiscRecord_NZones]
 ]
        CMPHSS  R0, LR
        MOVHS   R7, #0
        BHS     %FT40

; SBP: 06 Feb 1997: ***** Fix to prevent silly long transfers on large discs during *verify (-ve numbers problem!)
 [ {TRUE}
        MOV     r9,r0
        BL      MapPtrToDiscAdd
        SUB     r4,r0,r2
        LDRB    lr,[r10,#ZoneHead+DiscRecord_Log2SectorSize]
        MOV     r4,r4,LSL lr
        MOV     r0,r9
        CMP     r4,#1024*1024*1024
        MOV     r7,#0
        MOV     r8,#1
        BHS     %ft40
 ]
; SBP: 06 Feb 1997: ***** End of fix

 [ BigMaps
        BL      FragRdLenLinkBits ;(R10,R11->R7,R8)     ***************** nasty - fix it properly later
 |
        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
 ]
        TEQS    R8, #1
        BNE     %BT10           ; Not a bad block

40
        ; Verify to 'here'
        MOV     R9, R0
        BL      MapPtrToDiscAdd ;(R3,R10,R11->R0)
        ADD     R11,R11,R7

 [ BigDisc ;SBP: Thu 15th December 1994 - walked thru, looks OK
        SUBS    R4, R0, R2      ;length to verify
        LDRB    LR, [R10, #ZoneHead+DiscRecord_Log2SectorSize]
        MOV     R4, R4, LSL LR  ;get transfer length in bytes
        BLHI    %FT90           ;verify this chunk
 |
        SUBS    R4, R0, R2      ;length to verify
        BLHI    %FT90           ;verify this chunk
 ]

        ; If bad block is last in zone skip ZoneSpare into next zone
        CMP     R11, R5
        ASSERT  DiscRecord_ZoneSpare :MOD: 4 = 2
        LDRHS   LR, [R10, #ZoneHead + DiscRecord_ZoneSpare - 2]
        ADDHS   R11, R5, LR, LSR #16            ; Offset from R5 just in case R11 overhangs into the ZoneSpare

        BL      MapPtrToDiscAdd ;(R3,R10,R11->R0) disc add after defect
        MOV     R2, R0
        MOV     R0, R9
        TEQS    R8, #1
        BEQ     %BT20

        CMPS    R6, #1
        baddr   R0, VerOk, LO
        baddr   R0, VerRetries, EQ
        baddr   R0, VerBad, HI
        BL      message_gswrite0
        ALIGN

        B       %FT80

50
        BL      SizeLessDefects         ;(R3->LR)
        MOV     R4, LR
        BL      %FT90
60
        CMPS    R6, #1
        baddr   R0, VerOk, LO
        baddr   R0, VerRetries, EQ
        baddr   R0, VerBad, HI
        BL      message_gswrite0
        ALIGN

        B       %FT85

80
;        DLINE   "DoVerify: Calling UnlockMap"
        BL      UnlockMap
;        DLINE   "DoVerify: Done UnlockMap"
85
        BLVS    FindErrBlock            ;(R0->R0,V)
        BL      FileCoreExit
        Pull    "R7-R11,SB,PC"

90
        Push    "R0,R3,R5,R7-R9,LR"
 [ DebugQ
        DREG    R1, "Verify chunk:",cc
        DREG    R2, ",",cc
        DREG    R4, ","
 ]
        BL      DiscAddToRec    ;(R3->LR)
        MOV     R5, LR
        MOV     R9, #-1
92
        MOV     R3, #0
        BL      DoDiscOp        ;(R1-R4->R0-R4,V)
        BVC     %FT99
 [ NewErrors
        BICS    LR, R0, #&FF
        TSTNES  R0, #NewDiscErrorBit
        BEQ     %FT99
 |
        TSTS    R0, #DiscErrorBit
        BEQ     %FT99
 ]
        Push    "R1,R2"
        MOV     R1, #DiscOp_Restore
        BL      DoDiscOp        ;(R1-R4->R0-R4,V)
        Pull    "R1,R2"
        BVS     %FT99
        TEQS    R2, R9
        BEQ     %FT96

        ORR     R6, R6, #1
        MOV     R8, #VerifyRetries
        MOV     R9, R2
        BL      DoXOS_NewLine   ;(->R0,V)
        BICVC   R0, R2, #DiscBits
 [ BigDisc ;SBP: Thu 15th December 1994 Walked thru, push/pull of R1 not
; needed - use R3 instead
        LDRVCB  LR, [R5,#DiscRecord_Log2SectorSize]
        MOVVC   R3, R0, LSL LR  ;bottom 32 bits of addr
        RSBVC   LR, LR, #32     ;shift to get top 32 bits of addr
        MOVVC   R0, R0, LSR LR  ;top 32 bits
        BLVC    WrHex           ;(R0->R0,V) - do top 32 bits of number
        MOVVC   R0,R3           ; - do bottom 32 bits
 ]
        BLVC    WrHex           ;(R0->R0,V)
        BLVC    DoSpace         ;(->R0,V)
94
        MOVVC   R0, #"?"
        BLVC    DoXOS_WriteC    ;(R0->R0,V)
        BVS     %FT99
        B       %BT92

96
        SUBS    R8, R8, #1
        BNE     %BT94           ;V=0

        ORR     R6, R6, #2
        MOV     R8, #VerifyRetries
        BL      FindErrBlock    ;(R0->R0,V)
        ADD     R7, R0, #4      ;also set error flag
        MOV     R0, #CR
        BL      DoXOS_WriteC    ;(R0->R0,V)
        BLVC    WriteString     ;(R7->R0,V)
        BVS     %FT99

        LDRB    LR, [R5,#DiscRecord_Log2SectorSize]
        MOV     R0, #1
 [ BigDisc ; SBP: Thu 15th December 1994 - walked thru, looks OK
        ADD     R2, R2, R0
        SUBS    R4, R4, R0, LSL LR      ;also V=0
 |
        ADD     R2, R2, R0, LSL LR
        SUBS    R4, R4, R0, LSL LR      ;also V=0
 ]
        BGT     %BT92
99
        Pull    "R0,R3,R5,R7-R9,PC",VC
        ADD     SP, SP, #7*4
        B       %BT80

        LTORG
        END
@


4.20
log
@Fix for nonsense sector offsets (and abort) with *Map of old map disc
For new map discs NextFs returns the address of the map zone in R10, which was being used to lookup entries in the disc record. However, for old map discs R10 is a multiple-of-3 offset into the free space map. This was aborting on the 2nd call due to an unaligned LDR at line 3205.
Even on platforms that permit unaligned loads the printed results were wrong because the disc address for an old map disc is in bytes but the value printed out was shifted up by Log2SectorSize. A DD floppy disc could have free space fragments starting at 7M - nonsense.
Fixed by checking the DiscFlags and only reading from the map zone/sector shifting for new map.
Tested with an ADFS-L floppy disc.

Version 3.71. Tagged as 'FileCore-3_71'
@
text
@d3555 1
a3555 1
        LDR     lr,[r10,#ZoneHead+DiscRecord_Log2SectorSize]
@


4.19
log
@Add support for 2k and 4k sector sizes
s/Commands:
Make sure the defect list (via *DEFECT) does a read/modify/write of the boot block on 2k and 4k drives.
The checksum generation code was largely common and although commented to be called as though it was common wasn't actually due to a cut and paste mistake on label 37. Deleted common/uncalled code.
s/DebugOpts; s/FileCore15:
Peripheral changes.
s/FileCore20:
Read in the defect list via an intermediate buffer then copy out into the dynamic area.
s/FileCore70:
Declare the buffer size as 4k to FileSwitch, internally FileCore expresses this in a single byte * 32 so is now at the limit of the range of FcbBufSz.
s/FileCore80:
Perform transfers in the foreground when the sector size exceeds FileCore's 1k buffers. It's not worth bothering.
s/FormSWIs; s/Identify:
Vet and reject attempts to layout invalid zone/sector size combos (see Doc/1Zone).
Doc/MiscOp:
Correct a couple of calculation mistakes.
Doc/1Zone:
New documentation detailing the possible valid combinations of a 1 zone fixed disc, and why for 2k and 4k sectors this is rejected.
Test/BigSectors:
Patch to apply to RAMFS to make it a 4k filing system. Note, the smallest 2 zone RAM disc with 4k sectors is 4052kB, in which case the map is at +3F0000; copy at +3F2000; root directory object at +3F4000.

Version 3.63. Tagged as 'FileCore-3_63'
@
text
@d3134 1
a3134 1
; r0 = 3 - bit map, big dirs
d3202 5
a3206 1
        LDR     R1, [R10, #ZoneHead+DiscRecord_BigMap_DiscSize2]    ; discsize2 field
d3208 2
a3210 1
        LDRB    LR,[R10,#ZoneHead+DiscRecord_Log2SectorSize]   ; sector size
a3228 4
        BL      PutHex2
        B       %FT19

; here when small disc
a3229 2
        LDRB    LR,[R10,#ZoneHead+DiscRecord_Log2SectorSize]   ; sector size
        MOV     R0, R0, LSL LR
@


4.18
log
@Always UseBigFlag
Conditional now set in stone.
Not tagged.
@
text
@d2016 1
a2016 1
 |
d2082 1
d2200 1
a2200 1
        STR     R2, [R1]
a2201 1
37
d2204 1
a2204 28
39
        LDR     LR, [R4], #4
        TSTS    LR, #DiscBits
        EOREQ   R1, LR, R1, ROR #13
        BEQ     %BT39
        EOR     R1, R1, R1, LSR #16
        EOR     R1, R1, R1, LSR #8
        STRB    R1, [R4, #-4]

        MOV     R1, #SzDefectList
        BL      CheckSum        ;(R0,R1->R0-R2,V)
        SUB     R1, R1, #1
        STRB    R2, [R0, R1]

; generate disc address
        LDRB    R1, [R5, #DiscRecord_Log2SectorSize]
        MOV     LR, #DefectListDiscAdd
        AND     R2, R3, #DiscBits
        ADD     R2, R2, LR, LSR R1

        MOV     R3, R0
        MOV     R4, #SzDefectList
        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        BL      DoDiscOp        ;(R1-R4->R0,R2-R4,V)
 [ DebugQ
        DLINE   "Bad block list now written out"
 ]
        B       %FT81
a2206 1

d2231 1
a2231 3
        STR     R2, [R1]

        B       %BT37           ;use original code to checksum list
d2233 3
d2238 1
a2238 2
; and use similar code to that above to adjust the list, then
; jump back to 37 again to checksum.
d2290 1
a2290 1
        STR     R2, [R1]
d2298 1
a2298 1
        BEQ     %BT39
d2314 35
d2351 1
a2356 1
        B       %FT81
@


4.17
log
@Fix for stuck in loop doing background transfers to floppies
FileCore80.s: The check for whether write behind could proceed only succeeded for fixed discs ('winnie'), but failed for floppies. So, on trying to flush to close the file being written you'd get stuck in a loop trying to write the buffers.
Commands.s: Magic number swapped for defect list marker

Tested with fsbash, and a simple BASIC program writing 128x1K to a floppy.

Version 3.61. Tagged as 'FileCore-3_61'
@
text
@a2176 1
 [ UseBigFlag
a2180 9
 |
        ; use size of disc for test
        LDR     LR, [R5, #DiscRecord_BigMap_DiscSize2]
        CMPS    LR, #0
        BNE     %FT40
        LDR     LR, [R5, #DiscRecord_DiscSize]
        TSTS    LR, #DiscBits
        BNE     %FT40
 ]
a2267 1
 [ UseBigFlag
a2273 1
 ]
@


4.16
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@d2146 1
a2146 1
        MOV     R4, #512*1024*1024      ; 512 meg
@


4.15
log
@Swap out some more constants for symbolic names
* OsBytes
* Application start &8000
* Fixed disc density
* Unused a4 macro deleted
* Redundant 'todo', 'Help, 'Syntax' removed

Version 3.53. Not tagged
@
text
@a24 2
FsCom   bit     (31-24)
IntHelp *       (International_Help:SHR:24)
d26 15
a40 4
        MACRO
        ComEntry  $Com,$MinArgs,$MaxArgs,$GsTransBits,$HiBits
        ASSERT  $MinArgs<=$MaxArgs
Com$Com DCB     "$Com",0
a41 8
        DCD     Do$Com          - Module_BaseAddr
 =       $MinArgs
 =       $GsTransBits
 =       $MaxArgs
 =       $HiBits
        DCD     Syn$Com         - Module_BaseAddr
        DCD     Help$Com        - Module_BaseAddr
        MEND
d43 1
d45 1
a45 30
        MACRO
        Config  $Com
        DCB     "$Com",0
        ALIGN
        DCD     Con$Com         - Module_BaseAddr
        DCD     1 :SHL: 30
        DCD     0
        DCD     ConHelp$Com     - Module_BaseAddr
        MEND

ComTab                                          ;general star commands
                                         ;filing system star commands
        ComEntry  Backup,        2,4,&F,FsCom:OR:IntHelp
        ComEntry  Bye,           0,0,0,FsCom:OR:IntHelp
        ComEntry  CheckMap,      0,1,1,FsCom:OR:IntHelp
        ComEntry  Compact,       0,1,1,FsCom:OR:IntHelp
        ComEntry  Defect,        2,2,3,FsCom:OR:IntHelp
        ComEntry  Dismount,      0,1,1,FsCom:OR:IntHelp
        ComEntry  Drive,         1,1,1,FsCom:OR:IntHelp
        ComEntry  Free,          0,1,1,FsCom:OR:IntHelp
        ComEntry  Map,           0,1,1,FsCom:OR:IntHelp
        ComEntry  Mount,         0,1,1,FsCom:OR:IntHelp
        ComEntry  NameDisc,      2,2,3,FsCom:OR:IntHelp
        ComEntry  NameDisk,      2,2,3,FsCom:OR:IntHelp
        ComEntry  Verify,        0,1,1,FsCom:OR:IntHelp
                                         ;status/configure options
        =       0
        ALIGN

; ----- FILING SYSTEM STAR COMMANDS -----
d76 1
a76 1
; DoBackup
d88 1
a88 1
DoBackup ROUT
d310 3
a312 5
        MOVS    r2, r2
        MOVNE   r2, #2048*1024          ; limit max size
        BNE     BackupNotGigantic
        LDR     r2, [r11, #SrcDiscRec + DiscRecord_DiscSize] ; max
        CMP     r2, #2048*1024
a313 1
BackupNotGigantic
d315 1
a315 1
        LDR     r2, [r11, #SrcDiscRec + DiscSize] ; max
d723 1
a723 1
; DoBye
d726 1
a726 1
DoBye   ROUT
d735 1
a735 1
; DoCheckMap
d744 1
a744 1
DoCheckMap
a788 1
        LDRB    LR, [R6, #DiscRecord_Log2SectorSize]
a789 1
        LDRB    LR, [R6, #DiscRecord_Log2SectorSize]
d792 1
d849 6
d856 5
d862 1
a876 1

d951 1
a952 1
        MOV     R5, LR
a956 1
        MOV     R5, LR
d967 3
d980 2
a981 2
        ADD     R11, R11,R7
        CMPS    R11,R1
a1056 1
        LDRB    r7, [R5, #DiscRecord_Log2SectorSize]
a1057 1
        LDRB    R7, [R5, #DiscRecord_Log2SectorSize]
d1060 1
d1077 1
a1077 1
; DoCompact
d1080 1
a1080 1
DoCompact
d1106 1
d1114 1
a1114 1
        BL      CritInitReadNewFs        ;(->R10,R11)
d1118 1
a1118 1
        BL      DefCompactZone  ;(R0,R1,R10->R0,R2,V)
d1126 1
a1126 1

d1180 2
a1181 2
        MOVS    R0, LR
        BLNE    RoundUp         ;(R0,R3->R0) ignore zero length files
d1414 1
a1414 1
; DoDefect
d1421 1
a1421 1
DoDefect
d1428 1
a1428 1
        BLVC    DiscMustBeFileCore
d1494 1
a1494 1
        BL      TestMap
d1553 1
a1553 1
        BL      ReadLen                 ;(R4->LR)
d2371 1
a2371 1
; DoDismount
d2374 1
a2374 1
DoDismount ROUT
d2662 1
a2662 1
; DoDrive
d2665 1
a2665 1
DoDrive ROUT
d2750 1
a2750 1
; DoFree
d2759 1
a2759 1
DoFree ROUT
d2821 1
a2821 1
        DREG    r1, "",cc
d2824 1
a2824 1
        DREG    r4, "",cc
d3096 1
a3096 1
; DoMap
d3108 1
a3108 1
DoMap ROUT
d3166 1
a3166 1
        BL      DiscAddToRec            ; get the disc record
d3283 1
a3283 1
; DoMount
d3286 1
a3286 1
DoMount ROUT
d3396 1
a3396 1
; DoNameDisc
d3399 2
a3400 2
DoNameDisc ROUT
DoNameDisk
d3498 1
a3498 1
; DoVerify
d3501 1
a3501 1
DoVerify ROUT
@


4.14
log
@  Miscellaneous improvements
Detail:
  * Added the ability for a filing system to specify to FileCore that floppy
    discs should be mounted like hard discs, to complement the existing flag
    that specifies the opposite. SDFS requires this. Ideally SCSIFS should
    start using this as well, to encapsulate boot block handling within
    FileCore.
  * Added header definitions so the FileCore and the filing systems can
    negotiate the use of a new MiscOp entry, needed as part of partitioning
    support, especially important for filing systems that use the hardware-
    specific section of the boot block, like ADFS. At present, FileCore
    doesn't do anything different (it still doesn't support partitions) but
    this enables filing systems to be modified in preparation.
  * Removed the only place where FileCore paid any attention to the
    EmptyWorks flag returned by MiscOp 1 - an obscure and not very useful
    edge case not used by any current filing systems.
  * Added 650 lines of documentation for the MiscOp SWI and low-level entry
    to the Doc directory, giving the information you need in order to
    implement a FileCore filing system.
  * Added missing header file definitions for the low-level background DiscOp
    reason code and the hot-plug drive removed flag to MiscOp 7.
  * Removed some RISC OS 2 legacy code whereby FileCore maintained its idea
    of the internal disc address of the CSD @@, PSD \, Library % and URD & for
    each filing system. Since RISC OS 3.00, FileSwitch handles these
    internally and passes canonicalised paths to FileCore, so FileCore's disc
    addresses for these directories remained unset. This allows some
    considerable simplification of FileCore's path parser in particular, but
    also affects other code like that which decides how to expire disc
    records. Also note that FileCore has been unable to generate certain
    errors (like "Can't delete current directory") since RISC OS 3.00 for the
    same reason.
  * Changed loading of the map for FileCore-format discs so that the map is
    loaded into the dynamic area during the Service_IdentifyDisc handler in
    one big DiscOp rather than loading it twice, sector-by-sector, via one
    big sector cache. For one thing, the sector cache is implemented
    inefficiently - O(n^2) - and for another thing, single-sector DiscOps are
    relatively inefficient on many filing systems, especially on SD cards.
    Some example speed-ups measured for mounting discs are:
      SCSIFS,   1GB drive: was 0.62 sec, now 0.40 sec (1.55 x speedup)
      SCSIFS, 256GB drive: was 1.44 sec, now 0.52 sec (2.77 x speedup)
      SDFS,     2GB drive: was 1.25 sec, now 0.14 sec (8.93 x speedup)
Admin:
  Tested on a beagleboard, with SCSIFS and SDFS.

Version 3.50. Tagged as 'FileCore-3_50'
@
text
@d2634 1
a2634 1
        TEQ     R0, #0
d2713 1
a2713 1
        MOVVC   r0, #15
d2738 1
a2738 1
        MOV     R0, #15
d2757 1
a2757 1
        MOV     r0, #OsbyteAckEscape
@


4.13
log
@Fix abort on unaligned LDR of DiscRecord_ZoneSpare.
Looks like a typo because there's a valid ASSERT above, and an LSR#16 below.

Version 3.48. Tagged as 'FileCore-3_48'
@
text
@d1293 1
d1305 1
@


4.12
log
@Fold in old fixes.
From 1989, probably safe to keep them. Binary unchanged.

Version 3.47. Tagged as 'FileCore-3_47'
@
text
@d3614 1
a3614 1
        LDRHS   LR, [R10, #ZoneHead + DiscRecord_ZoneSpare]
@


4.11
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d874 1
a874 2
 [ fix_5
 ; need to treat big dirs as a special case
a881 4
 |
        BL      ReadLen         ;(R4->LR)
        MOVS    R1, LR
 ]
@


4.10
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d95 1
a95 1
SrcDiscRec      # DiscRecSig2
d97 1
a97 1
SrcDiscRec      # DiscRecSig
d163 2
a164 2
        MOVEQ   r8, #(1:SHL:UseDirSpace) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: ScatterBit
        MOVNE   r8, #(1:SHL:UseScratchSpace) :OR: (1:SHL:UseSpareScreen) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: ScatterBit
d289 2
a290 2
        LDR     r0, [r3,#DiscSize2]
        STR     r0, [lr,#DiscSize2]
d292 1
a292 1
        ; Size/SectorSize (rounding up) = total sectors
d294 2
a295 2
        LDR     r0, [r3, #DiscSize]
        LDRB    lr, [r3, #SectorSize]
d299 1
a299 1
        LDR     r1, [r3, #DiscSize2]
d305 3
a307 3
        ; Size/SectorSize (rounding up) = total sectors
        LDR     r0, [r3, #DiscSize]
        LDRB    lr, [r3, #SectorSize]
d336 1
a336 1
        LDR     r2, [r11, #SrcDiscRec + DiscSize2]      ; get top 32bits of disc size
d340 1
a340 1
        LDR     r2, [r11, #SrcDiscRec + DiscSize] ; max
d350 1
a350 1
        LDRB    lr, [r11, #SrcDiscRec + SectorSize]
d357 1
a357 1
        MOV     r0, #ReadSecsOp
d363 2
a364 2
        LDR     r3, [r11, #SrcDiscRec + DiscSize]
        LDRB    lr, [r11, #SrcDiscRec + SectorSize]
d366 1
a366 1
        LDR     r5, [r11, #SrcDiscRec + DiscSize2]
d370 2
a371 2
        LDR     r3, [r11, #SrcDiscRec + DiscSize]
        LDRB    lr, [r11, #SrcDiscRec + SectorSize]
d472 2
a473 2
        LDRB    r1, [lr, #SectorSize]
        LDRB    r2, [r0, #SectorSize]
d475 2
a476 2
        LDREQB  r1, [lr, #SecsPerTrk]
        LDREQB  r2, [r0, #SecsPerTrk]
d478 2
a479 2
        LDREQB  r1, [lr, #Density]
        LDREQB  r2, [r0, #Density]
d481 4
a484 4
        LDREQB  r1, [lr, #LowSector]
        LDREQB  r2, [r0, #LowSector]
        BICEQ   r1, r1, #SequenceSides
        BICEQ   r2, r2, #SequenceSides
d501 1
a501 1
        MOV     r0, #WriteSecsOp
d590 1
a590 1
;   r0 = op (ReadSecsOp/WriteSecsOp)
d625 2
a626 2
        LDR     r6, [r5, #DiscSize]
        LDRB    lr, [r5, #SectorSize]
d628 1
a628 1
        LDR     r7, [r5,#DiscSize2]
d632 2
a633 2
        LDR     r6, [r5, #DiscSize]
        LDRB    lr, [r5, #SectorSize]
d695 1
a695 1
        ORR     r1, r9, #ScatterBit
d699 1
a699 1
        LDRB    lr, [r5, #SectorSize]
d780 1
a780 1
        LDREQ   R3, [LR, #RootDir]
d816 2
a817 2
        LDRB    LR, [R6, #Zones2]
        LDRB    R8, [R6, #Zones]
d819 1
a819 1
        LDRB    LR, [R6, #SectorSize]
d821 2
a822 2
        LDRB    LR, [R6, #SectorSize]
        LDRB    R8, [R6, #Zones]
d978 2
a979 2
        LDRB    R0, [R5, #Zones]
        LDRB    LR, [R5, #Zones2]
d983 1
a983 1
        LDRB    R0, [R5, #Zones]
d1075 1
a1075 1
        MOV     R1, #WriteSecsOp :OR: NoEscape
d1077 2
a1078 2
        LDRB    R7, [R5, #Zones2]
        LDRB    R9, [R5, #Zones]
d1080 1
a1080 1
        LDRB    r7, [R5, #SectorSize]
d1082 2
a1083 2
        LDRB    R7, [R5, #SectorSize]
        LDRB    R9, [R5, #Zones]
d1131 2
a1132 2
        LDRB    R0, [LR, #Zones]
        LDRB    LR, [LR, #Zones2]
d1135 1
a1135 1
        LDRB    R0, [LR,#Zones]
d1156 1
a1156 1
        LDR     R3, [LR,#RootDir]
d1271 1
a1271 1
        MOV     R0, #(1:SHL:UseScratchSpace) :OR: (1:SHL:UseSpareScreen) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: ScatterBit
d1469 1
a1469 1
        LDRB    LR,[R10,#ZoneHead+SectorSize]
d1480 1
a1480 1
        LDR     LR, [R10, #ZoneHead+DiscSize]
d1482 1
a1482 1
        LDR     LR, [R10, #ZoneHead+DiscSize2]
d1490 1
a1490 1
        LDRB    LR, [R10, #ZoneHead+SectorSize]
d1504 1
a1504 1
        LDRB    R1, [R10,#ZoneHead+SectorSize]
d2101 1
a2101 1
        MOV     R1, #WriteSecsOp :OR: NoEscape
d2168 1
a2168 1
        LDRB    LR, [R5, #SectorSize]   ; get sector size
d2200 2
a2201 2
        LDRB    LR, [R5,#BigFlag]
        TSTS    LR, #BigFlagBit
d2205 1
a2205 1
        LDR     LR, [R5, #DiscSize2]
d2208 1
a2208 1
        LDR     LR, [R5, #DiscSize]
d2250 1
a2250 1
        LDRB    R1, [R5, #SectorSize]
d2257 1
a2257 1
        MOV     R1, #WriteSecsOp :OR: NoEscape
d2302 1
a2302 1
        LDRB    LR, [R5, #BigFlag]
d2304 1
a2304 1
        TSTS    LR, #BigFlagBit
d2370 1
a2370 1
        LDRB    R1, [R5, #SectorSize]
d2377 1
a2377 1
        MOV     R1, #WriteSecsOp :OR: NoEscape
d2421 1
a2421 1
        sbaddr  R4, DiscRecs+DiscName
d2423 1
a2423 1
        LDRB    LR, [R4,#Priority-DiscName]
d2524 1
a2524 1
        ADD     r3, r3, #DiscName
d2541 1
a2541 1
        LDRB    lr, [r3, #DiscsDrv - DiscName - 1]
d2636 1
a2636 1
        LDRB    R0, [LR, #Density]      ; is it a hard disc
d2640 1
a2640 1
        MOV     R1, #SeekOp :OR: NoEscape;if winnie seek to park address given
d2649 1
a2649 1
        LDR     R0, [LR, #DiscSize2]    ; get discsize2
d2651 1
a2651 1
        LDREQ   R0, [LR, #DiscSize]
d2653 1
a2653 1
        LDREQB  LR, [LR,#SectorSize]    ; so shift it down to a sector address
d3150 1
a3150 1
        LDR     r2, [LR, #DiscVersion]
d3154 1
a3154 1
        LDRB    r2, [LR, #LinkBits]
d3188 1
a3188 1
        LDR     R2, [LR, #DiscSize2]    ;
d3228 1
a3228 1
        LDR     R1, [R10, #ZoneHead+DiscSize2]    ; discsize2 field
d3231 1
a3231 1
        LDRB    LR,[R10,#ZoneHead+SectorSize]   ; sector size
d3255 1
a3255 1
        LDRB    LR,[R10,#ZoneHead+SectorSize]   ; sector size
d3533 1
a3533 1
        MOVVC   R1, #RestoreOp
d3538 1
a3538 1
        MOV     R1, #VerifyOp
d3567 2
a3568 2
        LDRHSB  LR, [R10,#ZoneHead+Zones]
        LDRHSB  R9, [R10,#ZoneHead+Zones2]
d3571 1
a3571 1
        LDRHSB  LR, [R10,#ZoneHead+Zones]
d3582 1
a3582 1
        LDR     lr,[r10,#ZoneHead+SectorSize]
d3608 1
a3608 1
        LDRB    LR, [R10, #ZoneHead+SectorSize]
d3618 2
a3619 2
        ASSERT  ZoneSpare :MOD: 4 = 2
        LDRHS   LR, [R10, #ZoneHead + ZoneSpare]
d3683 1
a3683 1
        MOV     R1, #RestoreOp
d3697 1
a3697 1
        LDRVCB  LR, [R5,#SectorSize]
d3725 1
a3725 1
        LDRB    LR, [R5,#SectorSize]
@


4.9
log
@Fix *DEFECT crashing when an object occupies the defect disc address.
R5 was being reused as the loop exit instead of R9.
Synced code with *CHECKMAP a bit since they have the same heritage.
Untangle the spaghetti around TermCommon and UnTermCommon.
In the module init, skip a store when the flags don't change.
Tested with a RAM disc filled with autogenerated nested directories and a loop blindly trying to defect everything - works fine now. Ticket #114.

Version 3.41. Tagged as 'FileCore-3_41'
@
text
@d116 1
a116 1
        Entry   Flag,Light     ;leaves SB,LR stacked
d757 1
a757 1
        Entry   Flag,Dormant  ;leaves SB,LR stacked
d775 1
a775 1
        Entry   Flag,Dormant  ;leaves SB,LR stacked
d1105 1
a1105 1
        Entry  Flag,Dormant  ;leaves SB,LR stacked
d1443 1
a1443 1
        Entry   Flag,Dormant  ;leaves SB,LR stacked
d2396 1
a2396 1
        Entry  Flag,Dormant         ;leaves SB,LR stacked
d2687 1
a2687 1
        Entry   Flag,Dormant    ;leaves SB,LR stacked
d2781 1
a2781 1
        Entry   Flag, Dormant    ;leaves SB,LR stacked
d3130 1
a3130 1
        Entry   Flag,Dormant     ;leaves SB,LR stacked
d3523 1
a3523 1
        Entry  Flag,Dormant     ;leaves SB,LR stacked
d3578 1
a3578 1
 [ T
@


4.8
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d21 1
d864 1
a866 2
        BL      TermCommon      ;(R3,R4,R5->R10)

a875 4
  [ {FALSE}
        BL      TestBigDir
        BEQ     %FT01
  ]
a882 3
  [ {FALSE}
01
  ]
a930 1

d1460 4
a1463 8
 [ BigDisc; SBP: Thu 15th December 1994, walked thru and commented.  Found
; that the check for disc address being on disc was incorrect and fixed.
; (was comparing disc addr as sector address against disc size as byte
; address)

; SBP: XOS_ReadUnisgned will only work if defect is within 4G.  Need to
;      do >32bit number handling for big discs.  Also need to watch for
;      above loading of DiscSize.
d1519 1
a1519 52
        B       %FT51


TermCommon
42
        MOV     R10,#0
UnTermCommon
45
        Push    "R0,R2,R11,LR"  ;Print out a name from a dir (R3,R4,R10)
 [ BigDir
        BL      TestBigDir      ;(R3->LR,Z)
        BEQ     BigTermCommon   ;
 ]
        ADD     R2, R4, #DirObName
        MOV     R11,#NameLen
48
        LDRB    LR, [R2], #1
        MOVS    R0, R10
        MOVEQ   R0, LR
        CMPS    LR, #DeleteChar
        CMPNES  LR, #" "
        BLS     %FT485
        BL      DoXOS_WriteC
        ADDVS   SP, SP, #4*4
        BVS     %FT78
        SUBS    R11,R11,#1
        BHI     %BT48
485
        Pull    "R0,R2,R11,PC"

 [ BigDir
BigTermCommon
        LDR     R11, [R4, #BigDirObNameLen]
        BL      GetBigDirName   ; (R4, R5 -> LR) get the name ptr
        MOV     R2, LR

49
        LDRB    LR, [R2], #1
        MOVS    R0, R10
        MOVEQ   R0, LR
        BL      DoXOS_WriteC
        ADDVS   SP, SP, #4*4
        BVS     %FT78
        SUBS    R11,R11,#1
        BHI     %BT49
        Pull    "R0,R2,R11,PC"

 ]

51

        CMPS    R8, #2          ;V=0
a1526 1

d1534 1
a1534 1
54                      ;RECURSE DOWN ENTRY POINT
d1540 1
a1541 1
        SUBNE   R4, R4, #NewDirEntrySz  ; small dir
d1553 1
d1556 1
a1556 1
        BLVC    %BT42           ;(R3,R4->R10)
d1560 1
a1560 2
        MOV     R5, R9
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
d1571 1
a1571 1
        BL      %BT42           ;(R3,R4->R10) print out filename
d1621 2
a1622 2
        TEQS    R7, #DirBit     ;IF  DIR
        TEQEQS  R5, #0          ;AND NO MATCH BEFORE THIS DIR
d1624 2
a1625 1
        BEQ     %BT54           ;THEN RECURSE DOWN
d1633 2
a1634 1
        BL      BigDirFinished          ; (R3,R4,R5->Z)
d1664 1
a1665 1
        SUBNE   R4, R4, #NewDirEntrySz
d1681 1
a1681 1
        BL      %BT45           ;(R3,R4,R10)
d1693 48
@


4.7
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  Many of these are unaligned LDRs where only bits 0-7 of the result are used
  (tested against a bitmask or used as an input to the barrel shifter) but
  they have all been moved to byte operations because they are faster on
  ARMv6 and won't cause false positives if unaligned aborts are enabled.

  s.BigDirCode line 104: not wrong as such, but changed to use aligned LDR
    for speed on ARMv6.
  s.BigDirCode line 1727: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.Commands line 129: STR to an unaligned 1-byte variable. Harmless because
    all overlapping variables are initialised later on.
  s.Commands line 539: LDR of an unaligned 1-byte variable. Only used for
    testing bit 6.
  s.FileCore31 line 1359: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.FileCore32 lines 1483 and 1825: LDR of an unaligned 1-byte variable. Only
    used as input to shifter.
  s.FormSWIs line 1403: bugfix: incorrect load of 16-bit zone_spare field of
    disc record - uses lowsector and nzones fields instead! This is used to
    terminate the search of free space fragments within the allocation bytes
    of the current map block for the one containing a bad block found during
    formatting. Would manifest itself as a "Can't map defect out" error.
  s.GenSWIs lines 1182,1195: bugfix: LDR of 1-byte variables. Effect of this
    was that range-checking of the drive number passed to FileCore_MiscOp 5
    (eject) wasn't performed.
  Added ENTRY directive to permit building of GPA debug listing.
Admin:
  Builds, but untested.

Version 3.34. Tagged as 'FileCore-3_34'
@
text
@a19 1
;
d22 1
a22 2
 TTL    "Command handling"

d68 1
a68 1
 =       0
d73 1
a73 1
         ^ 0     ;Backup temporary workspace
d115 1
a115 1
        Entry  Flag,Light     ;leaves SB,LR stacked
d288 2
a289 2
	LDR	r0, [r3,#DiscSize2]
	STR	r0, [lr,#DiscSize2]
d296 1
a296 1
	Push	"R1"
d298 4
a301 4
	LDR	r1, [r3, #DiscSize2]
	RSB	lr, lr, #32
	ORR	r0, r0, r1, LSL lr 	; combine them
	Pull	"R1"
d334 5
a338 5
	; make sure don't ask for silly amount of memory
	LDR	r2, [r11, #SrcDiscRec + DiscSize2]	; get top 32bits of disc size
	MOVS	r2, r2
	MOVNE	r2, #2048*1024		; limit max size
	BNE	BackupNotGigantic
d340 2
a341 2
	CMP	r2, #2048*1024
	MOVHI	r2, #2048*1024		; limit max size
d365 3
a367 3
	LDR	r5, [r11, #SrcDiscRec + DiscSize2]
	RSB	lr, lr, #32
	ORR	r3, r3, r5, LSL lr
d627 3
a629 3
	LDR	r7, [r5,#DiscSize2]
	RSB	lr, lr, #32
	ORR	r6, r6, r7, LSL lr
d808 1
a808 1
 	LDR	R10,[R7,#DrvsFsMapAddr]
d815 4
a818 4
        LDRB	LR, [R6, #Zones2]
        LDRB	R8, [R6, #Zones]
        ADD	R8, R8, LR, LSL #8
        LDRB	LR, [R6, #SectorSize]
d834 2
a835 2
 	MOV	LR, #0		; clear map flags
 	STR	R0, [R7, #DrvsFsMapFlags]
d851 4
a854 4
	BL	GetDirFirstEntry		; (R3,R5 -> R4)
	BL	TestBigDir			; (R3 -> LR, Z)
	SUBNE	R4, R4, #NewDirEntrySz		; small dir
	SUBEQ	R4, R4, #BigDirEntrySize	; big dir
d877 2
a878 2
	BL	TestBigDir
	BEQ	%FT01
d882 3
a884 3
 	BL	ReadIntAtts	;check if it's a dir
 	TSTS	LR, #DirBit	;is it a dir?
 	BICNE	R1, R1, #&ff	;yes then need to pretend isn't for reading size
d895 2
a896 2
 	BL	TestBigDir
 	BNE	%FT01
d898 5
a902 5
 	Push	"R6"
 	MOV	R6, R4
 	BL	ReturnWholeSpaceNotFudged ;(R1-R6->R0)
 	Pull	"R6"
	B	%FT02
d925 2
a926 2
 	BL	TestBigDir	; check if big dir or not
 	BNE	%FT37		; not big dir
d928 5
a932 5
; here if big dir
	ADD	R4, R4, #BigDirEntrySize	; go to next entry
	BL	BigDirFinished	; (R4,R5->Z)
	BNE	%BT25		; more to do
	B	%FT38		; finished
d934 1
a934 1

d947 1
a947 1
        BL      ToParent        ;(R3,R6->R3)
d949 1
a949 1
        BEQ     %FT45           ;V=0 end when back to root if no match found
d951 1
a951 1
        BL      FindDir         ;(R3->R0,R5,R6,V)
d954 1
a954 1
        BL      AgeDir          ;(R7)
d956 4
a959 4
 	BL	GetDirFirstEntry
 	BL	TestBigDir	;(R3->LR,Z)
 	SUBNE	R4, R4, #NewDirEntrySz
 	SUBEQ	R4, R4, #BigDirEntrySize
d965 3
a967 3
 	BL	TestBigDir
 	ADDEQ	R4, R4, #BigDirEntrySize
 	ADDNE	R4, R4, #NewDirEntrySz
d985 4
a988 4
	MOV	R5, LR
	LDRB	R0, [R5, #Zones]
	LDRB	LR, [R5, #Zones2]
	ADD	R0, R0, LR, LSL #8
d1005 2
a1006 2
        CMPS	R9,R11		;gap?
        BNE	%FT62		; not gap
d1009 3
a1011 3
	BL	FreeRdLenLinkBits ;(R10,R11->R7,R8)
	ADD	R9, R11, R8
	ADD	R11, R11,R7
d1014 1
a1014 1
	B	%FT65
d1018 2
a1019 2
        BL	FragRdLenLinkBits ;(R10,R11->R7,R8)
        BIC	lr, r3, #DiscBits
d1023 2
a1024 2
        CMP     R8, #2		; is it the map/boot block fragment?
        BLS	%FT63		; it is so ok
d1085 4
a1088 4
	LDRB	R7, [R5, #Zones2]
	LDRB	R9, [R5, #Zones]
	ADD	R9, R9, R7, LSL #8
	LDRB	r7, [R5, #SectorSize]
d1139 3
a1141 3
 	LDRB	R0, [LR, #Zones]
 	LDRB	LR, [LR, #Zones2]
 	ADD	R0, R0, LR, LSL #8
d1476 21
a1496 2
	MOV	r0, r1                  ; pointer to disc addr string
	BL	ReadHex64               ; (r0->r1,r2)
d1498 3
a1500 22
; check for sector alignment - ie shift right by sectorsize
; then shift left should not change ls word.
	LDRB	LR,[R10,#ZoneHead+SectorSize]
	MOV	R0, R1, LSR LR
	MOV	R0, R0, LSL LR
	CMP	R1, R0
	BEQ	%FT01
	MOV	R0, #BadParmsErr        ; Bad Parameter (how user friendly!)
	BL	SetV
	B	%FT78

01
; check that disc address is on the disc
	LDR	LR, [R10, #ZoneHead+DiscSize]
	SUBS	R0, R1, LR
	LDR	LR, [R10, #ZoneHead+DiscSize2]
	SBCS	R0, R2, LR
	BMI	%FT02                   ; if -ve then OK

	MOV	R0, #BadParmsErr
	BL	SetV
	B	%FT78
d1503 3
a1505 3
	MOV	R0, R1, LSR LR
	RSB	LR, LR, #32
	ORR	R0, R0, R2, LSL LR
d1541 2
a1542 2
 	BL	TestBigDir	;(R3->LR,Z)
 	BEQ	BigTermCommon	;
d1563 3
a1565 3
	LDR	R11, [R4, #BigDirObNameLen]
	BL	GetBigDirName	; (R4, R5 -> LR) get the name ptr
	MOV	R2, LR
d1595 2
a1596 2
        MOV     R9, #0          ;clear found flag
        MOV     R11,R2          ;defect disc add
d1599 1
a1599 1
        BL      FindDir         ;(R3->R0,R5,R6,V)
d1602 4
a1605 4
 	BL	GetDirFirstEntry
 	BL	TestBigDir
 	SUBEQ	R4, R4, #BigDirEntrySize
 	SUBNE	R4, R4, #NewDirEntrySz
d1612 1
a1612 1
        BL      ReadIntAtts     ;(R3,R4->LR)
d1630 1
a1630 1
        CMPS    R7, #0          ;V=0
d1638 1
a1638 1
        BL      ReadLen         ;(R4->LR)
d1641 1
a1641 1
        MOV     R9, #-1         ;init pre gap map ptr, also match found flag
d1649 1
a1649 1
        SUBS    R2, R11,R2
d1651 1
a1651 1
        BHI     %FT66           ;defect inside file
d1657 1
a1657 1
        baddr   r0, DC0         ;  must be moved
d1677 1
a1677 1
        baddr   r0, DC1         ;  has defect at offset %0
d1682 1
a1682 1
        BNE     %FT78           ;V=0 don't try to enter dir with defect
d1692 2
a1693 2
 	BL	TestBigDir	; (R3->LR,Z)
 	BNE	%FT01
d1695 4
a1698 4
; big dir
	BL	BigDirFinished	; (R3,R4,R5->Z)
	BNE	%BT57
	B	%FT02
d1700 1
a1700 1
; not big dir
d1712 1
a1712 1
        BNE     %FT78           ;V=0 don't return to parent once match found
d1715 1
a1715 1
        BL      ToParent        ;(R3,R6->R3)
d1717 1
a1717 1
        BEQ     %FT78           ;V=0 end when back to root if no match found
d1719 1
a1719 1
        BL      FindDir         ;(R3->R0,R5,R6,V)
d1722 1
a1722 1
        BL      AgeDir          ;(R7)
d1724 4
a1727 4
 	BL	GetDirFirstEntry	; (r3, r5 -> r4)
 	BL	TestBigDir		; (r3 -> LR, Z)
 	SUBEQ	R4, R4, #BigDirEntrySize
 	SUBNE	R4, R4, #NewDirEntrySz
d1733 3
a1735 3
 	BL	TestBigDir	; (R3->LR, Z)
 	ADDEQ	R4, R4, #BigDirEntrySize
 	ADDNE	R4, R4, #NewDirEntrySz
d1739 1
a1739 1
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
d1751 1
a1751 1
        BLVS    FindErrBlock    ;(R0->R0,V)
d1821 3
a1823 3
 	TEQS	R11,R9		;is it a gap?
 	BLEQ	FreeRdLenBits	; yes (R10,R11->R7)
 	BLNE	FragRdLenBits	; no  (R10,R11->R7)
d2024 2
a2025 2
	BL      UpdateBadBlockList      ; UpdateBadBlockList now sep. routine
	B	%FT78
d2181 5
a2185 5
	MOV	R4, #512*1024*1024	; 512 meg
	LDRB	LR, [R5, #SectorSize]	; get sector size
	MOV	R4, R4, LSR LR
	CMP	R2, R4			; is the defect in the first or second list?
	BHS	%FT50			; in second defect list
d2189 1
a2189 1
	MOV	R2, R2, LSL LR
d2219 6
a2224 6
	LDR	LR, [R5, #DiscSize2]
	CMPS	LR, #0
	BNE	%FT40
	LDR	LR, [R5, #DiscSize]
	TSTS	LR, #DiscBits
	BNE	%FT40
d2264 2
a2265 2
	LDRB	R1, [R5, #SectorSize]
	MOV	LR, #DefectListDiscAdd
d2283 1
a2283 1
	LDR	LR, [R6, #4]!
d2306 1
a2306 1
	B	%BT37		;use original code to checksum list
d2317 3
a2319 3
	CLRV	; this is not an error condition
        TSTS	LR, #BigFlagBit
	BEQ	%FT81
d2324 1
a2324 1
	MOV	R6, R0
d2326 3
a2328 3
	LDR	LR, [R6], #4
	TSTS	LR, #DiscBits
	BEQ	%BT51
d2384 2
a2385 2
	LDRB	R1, [R5, #SectorSize]
	MOV	LR, #DefectListDiscAdd
d2590 1
a2590 1
        MOV     R6,R1
d2593 3
a2595 3
        DiscRecPtr  LR,R6
        LDRB    R0,[LR,#Priority]
        TEQS    R0,#0
d2598 1
a2598 1
        MOV     R5,#0           ; error accumulator
d2601 1
a2601 1
        MOVVS   R5,R0
d2620 1
a2620 1
  	; get rid of any free space map area
d2622 9
a2630 9
  	Push	"R0-R8"
	MOV	R0, #2
	LDR	R1, [R2, #DrvsFsMapArea]
	BL	OnlyXOS_DynamicArea
	BVS	%FT01				; if error, then do nothing

	MOV	R0, R1
	RSB	R1, R2, #0			; amount to change size by
	BL	OnlyXOS_ChangeDynamicArea	; do the change
d2632 1
a2632 1
  	Pull	"R0-R8"
d2634 2
a2635 2
  	MOV	LR, #0
  	STR	LR, [R2, #DrvsFsMapSize]	; mark the size as zero
d2662 4
a2665 4
	DiscRecPtr LR,R6
	LDR	R0, [LR, #DiscSize2]    ; get discsize2
	MOVS	R0, R0                  ; is it small (discsize < 2^29 bytes?)
	LDREQ	R0, [LR, #DiscSize]
d2667 2
a2668 2
	LDREQB	LR, [LR,#SectorSize]    ; so shift it down to a sector address
	MOVEQ	R2, R2, LSR LR          ; else it's in sectors, leave it alone
d2721 3
a2723 1
ConfirmText Text "AreYouSure"
a2729 1
 [ MOS_Version > 120
a2734 3
 |
        BLVC    FlushAndReadChar
 ]
d2848 4
a2851 4
        MOV	r4, #0			; high 32 0
	MOV	r3, r2			; low 32
	MOV	r2, r1			; max object size
	MOV	r1, #0			; high 32 0
d2893 5
a2897 5
        BL	%FT90
	MOVVC	r0, r2
	MOVVC	r1, r3
	baddr	r5, FCK1, VC
	BLVC	%FT90
d3164 7
a3170 7
	LDR	r2, [LR, #DiscVersion]
	TEQS	r2, #0
	MOVEQ	r0, #0
	MOVNE	r0, #1		; bit 0 is big dirs flag
	LDRB	r2, [LR, #LinkBits]
	CMPS	r2, #15
	ORRHI	r0, r0, #2
d3175 9
a3183 9
	TEQS	r0, #1
	baddr	r0, MC4, EQ	;(   start,  length) new map, big directories
	BEQ	%FT07
	TEQS	r0, #2
	baddr	r0, MC5, EQ	;(   start,  length) big map, new directories
	BEQ	%FT07
	TEQS	r0, #3
	baddr	r0, MC6, EQ	;(   start,  length) big map, big directories
	BEQ	%FT07
d3237 1
a3237 1
	MOV	R0, R8
d3241 1
a3241 1
	Push	"R1,R2"
d3245 2
a3246 2
	LDRB	LR,[R10,#ZoneHead+SectorSize]	; sector size
	MOV	R1, R0,LSL LR
d3250 1
a3250 1
	BL	PutHex2
d3269 1
a3269 1
	LDRB	LR,[R10,#ZoneHead+SectorSize]	; sector size
d3274 1
a3274 1
	Pull	"R1,R2"
d3596 2
a3597 2
        LDR	lr,[r10,#ZoneHead+SectorSize]
        MOV	r4,r4,LSL lr
d3600 3
a3602 3
        MOV	r7,#0
        MOV	r8,#1
        BHS	%ft40
d3607 1
a3607 1
        BL	FragRdLenLinkBits ;(R10,R11->R7,R8)     ***************** nasty - fix it properly later
d3622 2
a3623 2
	LDRB	LR, [R10, #ZoneHead+SectorSize]
	MOV	R4, R4, LSL LR	;get transfer length in bytes
d3711 4
a3714 4
	LDRVCB  LR, [R5,#SectorSize]
	MOVVC   R3, R0, LSL LR  ;bottom 32 bits of addr
	RSBVC   LR, LR, #32     ;shift to get top 32 bits of addr
	MOVVC   R0, R0, LSR LR  ;top 32 bits
d3716 1
a3716 1
	MOVVC	R0,R3           ; - do bottom 32 bits
@


4.6
log
@* Various 32-bit compatibility fixes.
* Can use HAL for FIQ+timer manipulations.
* FileCore_DiscOp64 added (as user API - currently just converted to the
  standard byte or sector DiscOp call to the underlying module). See
  Doc.32bitAPIs for full details.
* New error-passing scheme to modules added (for full 32-bit addressing).
* FileCore_Features added (indicates new error scheme).
* OS_FSControl 49 (read 32-bit free space) now reports sensible clamped
  values for large discs, rather than values modulo 2^32.
* Accessing the end of files near 2GB in size could cause lock-ups in
  background transfers.
* F(+) and G(+) disc formats adjusted to have a little more skew to
  help the rather poor Iyonix floppy controller.

Version 3.31. Tagged as 'FileCore-3_31'
@
text
@d126 1
a126 1
        STR     lr, [r11, #BufOpt]
d536 1
a536 1
        LDR     lr, [r11, #BufOpt]
@


4.5
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 3.29. Tagged as 'FileCore-3_29'
@
text
@d1554 2
a1555 1
        BLHI    DoXOS_WriteC
d1558 1
a1558 1
        SUBHIS  R11,R11,#1
d1560 1
d1633 3
a1635 2
        MOVEQ   R0, #"."
        BLEQ    DoXOS_WriteC
d1637 2
a1638 1
        BLEQ    %BT42           ;(R3,R4->R10) print out filename
d2648 1
a2648 1
        ; Park disc if has defect list
d2650 9
a2658 3
        MOVNE   R1, #SeekOp :OR: NoEscape;if winnie seek to park address given
        LDRNE   R2, DefectSpace         ;in defect Map
        ADDNE   R2, SB, R2
d2660 2
a2661 2
        ADDNE   R2, R2, R7, LSL #9
        LDRNE   R2, [R2,#ParkDiscAdd]
d2664 1
a2664 2
	BEQ	%FT04                   ; no parking needed
	DiscRecPtr LR,R6                ; get disc record ptr
d2666 1
a2666 1
	MOVS	R0, R0                  ; is it big?
d2668 3
a2670 3
        TSTEQS  R0, #DiscBits           ; if so then dismount
	LDREQB	LR, [LR,#SectorSize]
	MOVEQ	R2, R2, LSR LR
a2672 1
        BEQ     %FT01
a2673 1
01
d2678 1
a2678 1
        ORRNE   R2, R2, R6, LSL #(32-3)
a2679 1
        BEQ     %FT01
a2680 1
01
d2682 1
a2682 1
        BLNE    DoDiscOp                ;(R1-R4->R0-R4)
d2685 1
a2685 1
        MOVVS   R5, R0
d3692 5
d3699 1
d3712 1
d3715 7
a3721 12
	BVS	%FT95
        BIC     R0, R2, #DiscBits
	LDRB	LR, [R5,#SectorSize]
	MOV	R3, R0, LSL LR	;bottom 32 bits of addr
	RSB	LR, LR, #32	;shift to get top 32 bits of addr
	MOV	R0, R0, LSR LR	;top 32 bits
        BL      WrHex           ;(R0->R0,V) - do top 32 bits of number
	MOVVC	R0,R3		; - do bottom 32 bits
	BLVC	WrHex		;
        BLVC    DoSpace         ;(->R0,V)
 |
        BICVC   R0, R2, #DiscBits
a3723 1
 ]
a3726 3
 [ BigDisc
95
 ]
@


4.4
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d34 1
a34 1
        DCD     Do$Com          - org
d39 2
a40 2
        DCD     Syn$Com         - org
        DCD     Help$Com        - org
d48 1
a48 1
        DCD     Con$Com         - org
d51 1
a51 1
        DCD     ConHelp$Com     - org
@


4.3
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@a786 1
 [ Module_Version >= 205
a789 1
 ]
a1020 1
 [ BigMaps
a1039 13
 |
	CMP     R8, #2
 [ DebugO
 BLS    %FT01
 DREG   r8, "Fragment ID hanging around:"
 DREG   r7, "BitLength:"
 DREG   r0, "In zone:"
 DREG   r11, "At bit offset:"
 DREG   r9, "Next free fragment at bit offset:"
01
 ]
        BHI     %BT50
 ]
d1078 2
a1123 1
 [ FileCache
a1124 1
  [ WinniesAsFloppies
a1125 4
  |
        BL      FloppyDiscWriteBehindWait       ;(R3)
  ]
  [ Module_Version >= 205
a1134 8
  |
        LDRB    LR, Winnies
        CMPS    LR, R3, LSR #29
        LDRB    LR, Interlocks
        Push    "LR"
        LDRLO   R0, WinnieProcessBlk
        LDRHS   R0, FloppyProcessBlk
  ]
a1135 2
 ]
 [ NewFs
a1159 5
 |

        BL      DiscAddToRec    ;(R3->LR)
 ]

d1208 5
a1212 4
        BLHS    ReadIntAtts     ;parent ptrs to it would not be updated
        TSTHSS  LR, #DirBit
        BHI     %FT18
        BL      ReadLen         ;(R3,R4->LR)
d1301 1
a1301 1
        TSTS    LR, #ARM_CC_Mask     ;no more FCBs return NE
a1402 1
 [ FileCache
a1404 1
 ]
a1421 1
 [ FileCache
a1422 1
 ]
a1437 1
 [ FileCache
a1438 1
 ]
a1458 1
 [ Module_Version >= 212
a1534 248
 |
        BVS     %FT81


  [ Module_Version >= 205
        BL      DiscMustBeFileCore ;(R3->V,R0)
        BVS     %FT81
  ]
        BL      TestMap         ;(R3->Z)
        MOVNE   R0, #DefectErr
        BLNE    SetV
        Push    "R1"
        MOVVC   R1, #8
        BLVC    CloseAllByDisc  ;(R1->R0,V)
        Pull    "R1"
        BLVC    BeforeAlterFsMap        ;(R3->R0,V)
        BVS     %FT81

        BL      SkipSpaces              ;(R1->R0,R1,C)
        BL      CritInitReadNewFs       ;(->R10,R11)
        MOV     R0, #16
        ORR     R0, R0, #bit31 :OR: bit29
        LDR     R2, [R10,#ZoneHead+DiscSize]
        SUB     R2, R2, #1
        BL      OnlyXOS_ReadUnsigned      ;(R0-R2->R0-R2,V)
        BVS     %FT78
        MOV     R0, R2
        LDRB    R1, [R10,#ZoneHead+SectorSize]
        MOV     LR, R0, LSR R1
        TEQS    R0, LR, LSL R1          ;check disc address at sector boundary
        MOVNE   R0, #BadParmsErr
        BLNE    SetV
        BNE     %FT78
        Push    "R0,R3"

        BL      DiscAddToMapPtr         ;(R0,R10->R11,LR)
        MOV     R1, R11
        MOV     R0, LR

        BL      InitZoneObj     ;(R0,R10->R8,R9,R11,LR)
        MOV     R5, LR
        TEQS    R9, R8
        MOVEQ   R9, #0
        MOV     R0, #bit31      ;rogue previous fragment
        B       %FT12

06
        TEQS    R11,R9
        BNE     %FT09
        BL      RdLinkBits      ;(R10,R11->R8,Z)
        MOVEQ   R9, #0
        ADDNE   R9, R11,R8
        MOV     R8, R11
09
        MOV     R0, R11
        MOV     R11,R4
12
        BL      RdLenBits       ;(R10,R11->R7)
        ADD     R4, R11,R7
        CMPS    R4, R1
        BLS     %BT06           ;loop if not reached defect fragment

        TEQS    R11,R9
        BNE     %FT51           ;defect not in a free space

        Push    "R8,R9"
        BL      RdLinkBits      ;(R10,R11->R8,Z)
        MOVEQ   R9, #0
        ADDNE   R9, R11,R8
        STR     R9, [SP, #4]
        MOV     R3, R11
        BL      AllocBitWidth   ;(R10->LR)
        MOV     R9, LR
        SUB     LR, LR, #1
        BIC     R1, R1, LR      ;round defect down to start of allocation unit
        ADD     R6, R1, R9      ;earliest possible defect end
        BL      MinMapObj       ;(R10->LR)
        MOV     R2, LR

        ; Registers here:
        ; R0 = previous fragment start - top bit set if none
        ; R1 = Defect start at allocation unit boundary
        ; R2 = MinMapObj
        ; R3 = Start of free object bad block was found in
        ; R4 = Start of fragment after free fragment containing bad block
        ; R5 = end of fragment list
        ; R6 = Earliest end of defect object (based on allocation width)

15
        SUB     LR, R1, R3      ; Space before defect
        CMPS    LR, R2
        BHS     %FT18           ; Branch if enough gap before defect for a whole object

        ; Not enough room before defect to fit an object
        MOV     R1, R3
        MOVS    R11,R0
        BLPL    RdLenLinkBits   ;(R10,R11->R7,R8)
        TEQPLS  R8, #1
        MOVEQ   R1, R0          ; EQ if previous object is a bad block object, ie
                                ; if there's no room for free space before the defect
                                ; and the previous object is a bad block then stretch
                                ; that to cover the defect

18
        SUB     LR, R4, R6      ; Space after defect
        CMPS    LR, R2
        CMPLOS  R4, R5
        BHS     %FT21           ; Branch if either there's room for an object after the defect
                                ; or there isn't an object after the free fragment containing the defect

        ; There isn't room after the defect for an object and there's an object after
        ; the free fragment containing the defect
        MOV     R6, R4
        MOV     R11,R4
        BL      RdLenLinkBits   ;(R10,R11->R7,R8)
        TEQS    R8, #1
        ADDEQ   R6, R4, R7      ; Object after defect is a bad block - stretch it down over the defect

21
        ; Now check defect fragment is big enough
        SUB     LR, R6, R1
        CMPS    LR, R2
        BHS     %FT24

        ; Defect fragment isn't big enough, so stretch defect
        ; fragment up if possible, else stretch it down and try again...
        CMPS    R6, R4
        ADDLO   R6, R6, R9
        SUBHS   R1, R1, R9
        B       %BT15

24
        Pull    "R8,R9"

        ; Write the defect fragment
        MOV     R0, #1
        BL      WrLinkBits      ;(R0,R1,R10)
        SUB     R0, R6, R1
        BL      WrLenBits       ;(R0,R1,R10)

        ; next free fragment
        SUBS    R7, R1, R3
        MOV     R1, R8
        MOVHI   R0, R3
        BLHI    WrFreeNext      ;(R0,R1,R10)
        MOVHI   R0, R7
        MOVHI   R1, R3
        BLHI    WrLenBits       ;(R0,R1,R10)

        ; previous free fragment
        CMPS    R4, R6
        MOVHI   R0, R6
        BLHI    WrFreeNext      ;(R0,R1,R10)
        SUBHI   R0, R4, R6
        MOVHI   R1, R6
        BLHI    WrLenBits       ;(R0,R1,R10)

        ; previous previous free fragment
        MOV     R0, R9
        BL      WrFreeNext      ;(R0,R1,R10)

        ; Write the whole lot out
        Pull    "R2,R3"
        BL      WriteFsMap      ;(->R0,V)
        BVS     %FT78

27
        ; Now update the bad block list (if present)

 [ Module_Version >= 205
        ; Base presence of defect list on presence of defect list
        ; (These checks _ASSUME_ disc is in a drive)
        MOV     LR, R3, LSR #(32-3)
        DiscRecPtr LR, LR
        LDRB    LR, [LR, #DiscsDrv]
        DrvRecPtr LR, LR
        LDRB    LR, [LR, #DrvFlags]
        TST     LR, #HasDefectList
        BEQ     %FT78

        MOV     LR, R3, LSR #(32-3)
        DiscRecPtr LR, LR
        LDRB    LR, [LR, #DiscsDrv]
 |
  [ fix_1
  ! 0,"fix 1"
        LDRB    LR, Winnies
  |
        LDR     LR, Winnies
  ]
        CMPS    LR, R3, LSR #29
        BLS     %FT78           ;no defect list to update if floppy, V=0

        MOV     LR, R3, LSR #29
 ]
        LDR     R0, DefectSpace
        ADD     R0, SB, R0
        ASSERT  SzDefectList = 1 :SHL: 9
        ADD     R0, R0, LR, LSL #9

        SUB     R1, R0, #4
30
        LDR     LR, [R1, #4]!
        CMPS    LR, R2
        BLO     %BT30
        BEQ     %FT78           ;defect already in list

        MOV     R4, R1
33
        TSTS    LR, #DiscBits
        LDREQ   LR, [R4, #4]!
        BEQ     %BT33

        LDR     LR, [R4, #4]!
        TEQS    LR, #0
        BNE     %FT78           ;defect list full

36
        LDR     LR, [R4, #-4]!  ;move up defect list
        STR     LR, [R4, #4]
        CMPS    R4, R1
        BHI     %BT36
        STR     R2, [R1]

        MOV     R4, R0
        MOV     R1, #0
39
        LDR     LR, [R4], #4
        TSTS    LR, #DiscBits
        EOREQ   R1, LR, R1, ROR #13
        BEQ     %BT39
        EOR     R1, R1, R1, LSR #16
        EOR     R1, R1, R1, LSR #8
        STRB    R1, [R4, #-4]

        MOV     R1, #SzDefectList
        BL      CheckSum        ;(R0,R1->R0-R2,V)
        SUB     R1, R1, #1
        STRB    R2, [R0, R1]
        MOV     R1, #WriteSecsOp :OR: NoEscape
        AND     R2, R3, #DiscBits
        ADD     R2, R2, #DefectListDiscAdd
        MOV     R3, R0
        MOV     R4, #SzDefectList
        BL      DoDiscOp        ;(R1-R4->R0,R2-R4,V)
        B       %FT78
 ]

d1559 1
a1559 1
        Pull    "R0,R2,R11,PC",,^
d1576 1
a1576 1
        Pull    "R0,R2,R11,PC",,^
a1580 7
 [ Module_Version >= 212
 |
        Pull    "R2,R3"
        BL      RdLinkBits      ;(R10,R11->R8,Z)
        TEQS    R8, #1
        BEQ     %BT27
 ]
a1752 1
 [ Module_Version >= 212
a2148 2
 ] ; Version>=212

d2495 1
a2495 1
        Pull    "r0,pc",,^
a2584 1
 [ Module_Version >= 205
a2585 3
 |
        Push    "R0-R6,LR"
 ]
a2600 1
 [ Module_Version >= 205
a2679 13
 |
        LDRB    LR, Winnies
        CMPS    R1, LR           ;also V=0

        MOVCC   R1, #SeekOp :OR: NoEscape;if winnie seek to park address given
        LDRCC   R2, DefectSpace         ;in defect Map
        ADDCC   R2, SB, R2
        ASSERT  SzDefectList=&200
        ADDCC   R2, R2, R6,LSL #9
        LDRCC   R2, [R2,#ParkDiscAdd]
        ORRCC   R2, R2, R6,LSL #(32-3)
        BLCC    DoDiscOp                ;(R1-R4->R0-R4)
 ]
a2689 1
 [ Module_Version >= 205
a2690 3
 |
        Pull    "R0-R6,PC"
 ]
d2735 1
a2735 1
        MOV     r1, pc
d2741 1
a2741 1
        TEQP    pc, r1
a3158 1
 [ Module_Version >= 205
a3160 1
 ]
a3221 1
 [ NewFs
a3222 3
 |
        BLNE    InitReadOldFs           ;(R3->R9-R11)
 ]
a3223 1
 [ NewFs
a3224 3
 |
        BL      NextOldFs               ;(R3,R10,R11->R7,R8,R11,Z)
 ]
a3556 1
 [ NewFs
d3580 3
a3582 3
 	LDRHSB	LR, [R10,#ZoneHead+Zones]
 	LDRHSB	R9, [R10,#ZoneHead+Zones2]
 	ADDHS	LR, LR, R9, LSL #8
a3650 1
 ]
@


4.2
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d17 6
d811 3
d816 8
d826 2
d837 4
d842 1
d854 6
d861 1
d868 2
a869 1
        BL      TermCommon      ;(R3,R4->R10)
d879 5
d886 3
d891 3
d898 10
d913 8
d922 1
a922 1
        BL      UnTermCommon    ;(R3,R4,R10)
d928 11
d943 7
d959 6
d966 1
d968 5
d974 1
d987 7
d996 1
d1008 55
d1080 2
d1100 6
d1108 1
d1170 5
d1176 1
d1831 4
d1850 19
d1897 6
d1904 1
d1985 10
d1998 6
d2017 6
d2024 1
d2026 5
d2032 1
d2103 3
d2107 1
d2115 5
d2121 1
d2130 3
d2134 1
d2168 3
d2172 1
d2194 3
d2198 1
d2220 3
d2224 1
d2229 3
d2233 1
d2254 3
d2258 1
d2278 3
d2282 1
d2323 3
d2327 1
d2512 1
a2512 1
        TSTS    LR, #1
a2613 1
        TSTS	LR, #1
d2615 1
d2920 20
d3458 3
d3485 22
d3869 1
d3911 5
d3917 1
d3922 18
d3941 1
@


4.1
log
@Initial revision
@
text
@d781 1
a781 1
 [ Version >= 205
d981 1
a981 1
  [ Version >= 205
d1329 1
a1329 1
 [ Version >= 212
d1410 1
a1410 1
  [ Version >= 205
d1575 1
a1575 1
 [ Version >= 205
d1677 1
a1677 1
 [ Version >= 212
d1820 1
a1820 1
 [ Version >= 212
d2240 1
a2240 1
        LDRB    LR, [R5,#BigFlag]       
d2613 1
a2613 1
 [ Version >= 205
d2633 1
a2633 1
 [ Version >= 205
d2673 1
a2673 1
	LDREQB	LR, [LR,#SectorSize]    
d2716 1
a2716 1
 [ Version >= 205
d2993 1
a2993 1
        
d3186 1
a3186 1
 [ Version >= 205
d3567 1
a3567 1
        
d3692 1
a3692 1
 [ BigDisc ;SBP: Thu 15th December 1994 Walked thru, push/pull of R1 not 
@


4.1.4.1
log
@Changes made to FileCore to support allowing idlen more than 15.  This allows
smaller LFAUs on discs.  The changes are not yet complete.  In particular, the
number of disc zones is limited to 255.  Some development testing has been
peformed, and the filing system is generally stable.  Areas which haven't
been fully tested include things like *Defect, FileCore_LayoutStructure,
FileCore_FloppyStructure, and the FileSwitch APIs for reading and examining
a disc's used space.

This version should not be used for any OS Builds with the BigMaps flag set
to true.  It should build as a normal version of FileCore with BigMaps and
BigDirs set to false.
@
text
@a16 4
; change log (added by SBP 14 May 1997)
;
; 14 May 1997: SBP: Incorporated old fix for *verify to work when verifying >2G discs (DoVerify)

a896 3
; [ BigMaps
;        BIC	r3,r3,#DiscBits
; ]
a907 55
 [ BigMaps
        CMPS	R9,R11		;gap?
        BNE	%FT62		; not gap

; gap
	BL	FreeRdLenLinkBits ;(R10,R11->R7,R8)
	ADD	R9, R11, R8
	ADD	R11, R11,R7
        CMPS    R11,R1
        BLO     %BT60
	B	%FT65	

62
; not gap
        BL	FragRdLenLinkBits ;(R10,R11->R7,R8)
 [ BigMaps
        BIC	lr, r3, #DiscBits
        CMP     R8, lr, LSR #8  ; is this the root dir?
        BEQ     %FT63           ; it's root dir
        
        CMP     R8, #2		; is it the map/boot block fragment?
        BLS	%FT63		; it is so ok
        
        ; here if broken map
        
 [ DebugO
 DREG   r8, "Fragment ID hanging around:"
 DREG   r7, "BitLength:"
 DREG   r0, "In zone:"
 DREG   r11, "At bit offset:"
 DREG   r9, "Next free fragment at bit offset:"
 ]
        B       %BT50

63
 |
	CMP     R8, #2
 [ DebugO
 BLS    %FT01
 DREG   r8, "Fragment ID hanging around:"
 DREG   r7, "BitLength:"
 DREG   r0, "In zone:"
 DREG   r11, "At bit offset:"
 DREG   r9, "Next free fragment at bit offset:"
01
 ]
        BHI     %BT50
 ]
        ADD     R11,R11,R7
        CMPS    R11,R1
        BLO     %BT60
        B       %FT65
	
 |
 
a924 2
 ]

a1873 3
 [ BigMaps
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
 |
a1874 1
 ]
a1881 5
 [ BigMaps
 	TEQS	R11,R9		;is it a gap?
 	BLEQ	FreeRdLenBits	; yes (R10,R11->R7)
 	BLNE	FragRdLenBits	; no  (R10,R11->R7)
 |
a1882 1
 ]
a1890 3
 [ BigMaps
        BL      FreeRdLinkBits  ;(R10,R11->R8,Z)
 |
a1891 1
 ]
a1924 3
 [ BigMaps
        BLPL    FragRdLenLinkBits ;(R10,R11->R7,R8)
 |
a1925 1
 ]
a1946 3
 [ BigMaps
        BL      FragRdLenLinkBits ;(R10,R11->R7,R8)
 |
a1947 1
 ]
a1968 3
 [ BigMaps
        BL      FragWrLinkBits  ;(R0,R1,R10)
 |
a1969 1
 ]
a1973 3
 [ BigMaps
        BL      FragWrLenBits   ;(R0,R1,R10)
 |
a1974 1
 ]
a1994 3
 [ BigMaps
        BLHI    FreeWrLenBits   ;(R0,R1,R10)
 |
a1995 1
 ]
a2014 3
 [ BigMaps
        BLHI    FreeWrLenBits   ;(R0,R1,R10)
 |
a2015 1
 ]
a2055 3
 [ BigMaps
        BL      FragRdLinkBits  ;(R10,R11->R8,Z)
 |
a2056 1
 ]
a3552 1
        
a3598 18
; SBP: 06 Feb 1997: ***** Fix to prevent silly long transfers on large discs during *verify (-ve numbers problem!)
 [ T
        MOV     r9,r0
        BL      MapPtrToDiscAdd
        SUB     r4,r0,r2
        LDR	lr,[r10,#ZoneHead+SectorSize]
        MOV	r4,r4,LSL lr
        MOV     r0,r9
        CMP     r4,#1024*1024*1024
        MOV	r7,#0
        MOV	r8,#1
        BHS	%ft40
 ]
; SBP: 06 Feb 1997: ***** End of fix

 [ BigMaps
        BL	FragRdLenLinkBits ;(R10,R11->R7,R8)     ***************** nasty - fix it properly later
 |
a3599 1
 ]
@


4.1.4.2
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@a19 2
;
; 19 Aug 1997: SBP: Changes for big free space maps.
a810 7
        
 [ BigMaps
        LDRB	LR, [R6, #Zones2]
        LDRB	R8, [R6, #Zones]
        ADD	R8, R8, LR, LSL #8
        LDRB	LR, [R6, #SectorSize]
 |
a812 2
 ]

a898 7

 [ BigMaps
	MOV	R5, LR
	LDRB	R0, [R5, #Zones]
	LDRB	LR, [R5, #Zones2]
	ADD	R0, R0, LR, LSL #8
 |
d901 3
a903 1
 ]
a1006 6
 [ BigMaps
	LDRB	R7, [R5, #Zones2]
	LDRB	R9, [R5, #Zones]
	ADD	R9, R9, R7, LSL #8
	LDRB	r7, [R5, #SectorSize]
 |
a1008 1
 ]
a1069 5
 [ BigMaps
 	LDRB	R0, [LR, #Zones]
 	LDRB	LR, [LR, #Zones2]
 	ADD	R0, R0, LR, LSL #8
 |
a1070 1
 ]
@


4.1.4.3
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@a844 6
 [ BigDir
	BL	GetDirFirstEntry		; (R3,R5 -> R4)
	BL	TestBigDir			; (R3 -> LR, Z)
	SUBNE	R4, R4, #NewDirEntrySz		; small dir
	SUBEQ	R4, R4, #BigDirEntrySize	; big dir
 |
a845 1
 ]
d852 1
a852 2
 
        BL      TermCommon      ;(R3,R4,R5->R10)
a869 17
 [ BigDir
 	BL	TestBigDir
 	BNE	%FT01
 
 	Push	"R6"
 	MOV	R6, R4
 	BL	ReturnWholeSpaceNotFudged ;(R1-R6->R0)
 	Pull	"R6"
	B	%FT02
01
        Push    "R5"
        SUB     R5, R4, #DirFirstEntry
        BL      ReturnWholeSpace        ;(R1-R5->R0)
        Pull    "R5"

02
 |
a873 1
 ]
d876 1
a876 1
        BL      UnTermCommon    ;(R3,R4,R5,R10)
a881 11
 [ BigDir
 	BL	TestBigDir	; check if big dir or not
 	BNE	%FT37		; not big dir

; here if big dir
	ADD	R4, R4, #BigDirEntrySize	; go to next entry
	BL	BigDirFinished	; (R4,R5->Z)
	BNE	%BT25		; more to do
	B	%FT38		; finished
37

a884 7
	
38
 |
        LDRB    LR, [R4, #NewDirEntrySz] !
        CMPS    LR, #" "
        BHI     %BT25
 ]
a894 6
 [ BigDir
 	BL	GetDirFirstEntry
 	BL	TestBigDir	;(R3->LR,Z)
 	SUBNE	R4, R4, #NewDirEntrySz
 	SUBEQ	R4, R4, #BigDirEntrySize
 |
a895 1
 ]
a896 5
 [ BigDir
 	BL	TestBigDir
 	ADDEQ	R4, R4, #BigDirEntrySize
 	ADDNE	R4, R4, #NewDirEntrySz
 |
a897 1
 ]
a1753 4
 [ BigDir
 	BL	TestBigDir	;(R3->LR,Z)
 	BEQ	BigTermCommon	;
 ]
a1768 19
 [ BigDir
BigTermCommon
	LDR	R11, [R4, #BigDirObNameLen]
	BL	GetBigDirName	; (R4, R5 -> LR) get the name ptr
	MOV	R2, LR

49
        LDRB    LR, [R2], #1
        MOVS    R0, R10
        MOVEQ   R0, LR
        BL      DoXOS_WriteC
        ADDVS   SP, SP, #4*4
        BVS     %FT78
        SUBS    R11,R11,#1
        BHI     %BT49
        Pull    "R0,R2,R11,PC",,^

 ]

a1796 6
 [ BigDir
 	BL	GetDirFirstEntry
 	BL	TestBigDir
 	SUBEQ	R4, R4, #BigDirEntrySize
 	SUBNE	R4, R4, #NewDirEntrySz
 |
a1797 1
 ]
a1877 10
 [ BigDir
 	BL	TestBigDir	; (R3->LR,Z)
 	BNE	%FT01

; big dir
	BL	BigDirFinished	; (R3,R4,R5->Z)
	BNE	%BT57
	B	%FT02
01
; not big dir
a1880 6
02
 |
        LDRB    LR, [R4, #NewDirEntrySz] !
        CMPS    LR, #" "
        BHI     %BT57
 ]
a1893 6
 [ BigDir
 	BL	GetDirFirstEntry	; (r3, r5 -> r4)
 	BL	TestBigDir		; (r3 -> LR, Z)
 	SUBEQ	R4, R4, #BigDirEntrySize
 	SUBNE	R4, R4, #NewDirEntrySz
 |
a1894 1
 ]
a1895 5
 [ BigDir
 	BL	TestBigDir	; (R3->LR, Z)
 	ADDEQ	R4, R4, #BigDirEntrySize
 	ADDNE	R4, R4, #NewDirEntrySz
 |
a1896 1
 ]
a3729 5
 [ BigMaps
 	LDRHSB	LR, [R10,#ZoneHead+Zones]
 	LDRHSB	R9, [R10,#ZoneHead+Zones2]
 	ADDHS	LR, LR, R9, LSL #8
 |
a3730 1
 ]
@


4.1.4.4
log
@Fixed bugs in handling of growing directories, and made the directory
backup entries come back but only be one word long each.
@
text
@a869 1
 ; need to treat big dirs as a special case
a871 3
 	BL	ReadIntAtts	;check if it's a dir
 	TSTS	LR, #DirBit	;is it a dir?
 	BICNE	R1, R1, #&ff	;yes then need to pretend isn't for reading size
@


4.1.4.5
log
@Fixed s.BigDirCode (GrowBigDir and ShrinkBigDir) to cope with BitSize<SecSize
and rewrote free space map memory management to place free space maps in
dynamic areas.
@
text
@a810 3
 [ DynamicMaps
 	LDR	R10,[R7,#DrvsFsMapAddr]
 |
d813 1
a813 2
 ]

a832 4
 [ DynamicMaps
 	MOV	LR, #0		; clear map flags
 	STR	R0, [R7, #DrvsFsMapFlags]
 |
a833 1
 ]
a2902 20
  
  [ DynamicMaps
  
  	; get rid of any free space map area
  
  	Push	"R0-R8"
	MOV	R0, #2
	LDR	R1, [R2, #DrvsFsMapArea]
	BL	OnlyXOS_DynamicArea
	BVS	%FT01				; if error, then do nothing
	
	MOV	R0, R1
	RSB	R1, R2, #0			; amount to change size by
	BL	OnlyXOS_ChangeDynamicArea	; do the change
01
  	Pull	"R0-R8"
  	
  	MOV	LR, #0
  	STR	LR, [R2, #DrvsFsMapSize]	; mark the size as zero
  ]
@


4.1.4.6
log
@Now supports formatting of floppies with long file names.
@
text
@d2505 1
a2505 1
        TSTS    LR, #BigFlagBit
d2607 1
a2608 1
        TSTS	LR, #BigFlagBit
@


4.1.4.7
log
@Altered s.Identify; wasn't correctly returning a string describing the disc
format for F+ discs.

Altered s.Commands; *map now correctly reports big directories and a big
free space map.
@
text
@d868 1
a868 1

d894 1
a894 1

d935 1
a935 1

d1011 1
a1011 1
	B	%FT65
d1020 1
a1020 1

d1023 1
a1023 1

d1025 1
a1025 1

d1053 1
a1053 1

d1055 1
a1055 1

d2504 1
a2504 1
        LDRB    LR, [R5,#BigFlag]
d2912 1
a2912 1

d2914 1
a2914 1

d2916 1
a2916 1

d2922 1
a2922 1

d2928 1
a2928 1

d2957 1
a2957 1
	LDREQB	LR, [LR,#SectorSize]
d3277 1
a3277 1

a3450 3
MC4     DCB     "MC4",0
MC5     DCB     "MC5",0
MC6     DCB     "MC6",0
a3474 22
 [ BigDir
	LDR	r2, [LR, #DiscVersion]
	TEQS	r2, #0
	MOVEQ	r0, #0
	MOVNE	r0, #1		; bit 0 is big dirs flag
	LDRB	r2, [LR, #LinkBits]
	CMPS	r2, #15
	ORRHI	r0, r0, #2
; r0 = 0 - not a new filecore disc
; r0 = 1 - big dirs, small map
; r0 = 2 - big map, small dirs, this case is only valid for IdLen=16
; r0 = 3 - bit map, big dirs
	TEQS	r0, #1
	baddr	r0, MC4, EQ	;(   start,  length) new map, big directories
	BEQ	%FT07
	TEQS	r0, #2
	baddr	r0, MC5, EQ	;(   start,  length) big map, new directories
	BEQ	%FT07
	TEQS	r0, #3
	baddr	r0, MC6, EQ	;(   start,  length) big map, big directories
	BEQ	%FT07
 ]
d3837 1
a3837 1

d3852 1
a3852 1

d4002 1
a4002 1
 [ BigDisc ;SBP: Thu 15th December 1994 Walked thru, push/pull of R1 not
@


4.1.4.8
log
@Fixed bug with zone compaction with idlen>15, in CompactZone.
@
text
@a879 4
  [ {FALSE}
	BL	TestBigDir
	BEQ	%FT01
  ]
a886 3
  [ {FALSE}
01
  ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

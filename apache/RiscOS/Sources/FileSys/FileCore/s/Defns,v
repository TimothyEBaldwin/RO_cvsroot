head	4.14;
access;
symbols
	FileCore-3_75:4.14
	FileCore-3_74:4.13
	FileCore-3_73:4.13
	FileCore-3_72:4.13
	FileCore-3_71:4.13
	FileCore-3_70:4.13
	FileCore-3_69:4.13
	FileCore-3_68:4.13
	FileCore-3_67:4.13
	FileCore-3_66:4.13
	FileCore-3_65:4.13
	FileCore-3_64:4.13
	FileCore-3_63:4.12
	FileCore-3_62:4.12
	FileCore-3_61:4.11
	FileCore-3_60:4.11
	FileCore-3_59:4.11
	FileCore-3_58:4.11
	FileCore-3_57:4.11
	FileCore-3_56:4.10
	FileCore-3_55:4.9
	FileCore-3_54:4.9
	FileCore-3_53:4.8
	FileCore-3_52:4.8
	FileCore-3_51:4.8
	FileCore-3_50:4.8
	FileCore-3_49:4.7
	FileCore-3_48:4.7
	FileCore-3_47:4.7
	FileCore-3_46:4.7
	FileCore-3_45:4.6
	FileCore-3_44:4.5
	FileCore-3_43:4.5
	FileCore-3_42:4.5
	FileCore-3_41:4.4
	FileCore-3_40:4.3
	FileCore-3_39:4.3
	FileCore-3_38:4.3
	FileCore-3_37:4.3
	FileCore-3_36:4.3
	FileCore-3_35:4.3
	FileCore-3_34:4.3
	FileCore-3_33:4.3
	RO_5_07:4.3
	FileCore-3_32:4.3
	FileCore-3_31:4.3
	FileCore-3_30:4.3
	FileCore-3_29:4.3
	FileCore-3_28:4.3
	FileCore-3_25-4_9_2_2:4.3
	FileCore-3_27:4.3
	FileCore-3_26:4.3
	FileCore-3_22-4_6_2_1:4.2
	bavison_FileCore-3_22_dev_bp:4.2
	bavison_FileCore-3_22:4.2.0.2
	FileCore-3_25-4_9_2_1:4.3
	HAL:4.3.0.2
	FileCore-3_25:4.3
	FileCore-3_24:4.3
	FileCore-3_23:4.3
	dellis_autobuild_BaseSW:4.2
	FileCore-3_22:4.2
	Ursula_merge:4.1.4.1
	ROL_merge:4.1.4.1
	FileCore-3_21:4.2
	ROL_Ursula_merge:4.1.4.1
	Ursula_RiscPC_merge:4.1.4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.3
	ROL_FileCore-3_21:4.1.4.1
	ROL_FileCore-3_20:4.1.4.1
	ROL:4.1.4.1.0.4
	ROL_bp:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	FileCore-3_18:4.1.4.1
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1.4.1
	sproven_FileCore-3_16:4.1.4.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	sproven_FileCore-3_15:4.1.4.1
	sproven_314:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.1
	sproven_3_11:4.1.4.1
	sproven_3_10:4.1.4.1
	sproven_Ursula_3_09:4.1.4.1
	sproven_3_07:4.1.4.1
	sproven_3_06:4.1.4.1
	sproven_3_05:4.1.4.1
	sproven_3_04:4.1.4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.1
	sproven_3_02:4.1.4.1
	sproven_3_01:4.1.4.1
	sproven_2_99:4.1.4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.14
date	2017.07.06.14.36.57;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	glaSUStjQCVZ3bYz;

4.13
date	2014.11.02.17.25.24;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	afoCgwcyXTmkoDWx;

4.12
date	2013.07.18.21.04.17;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	Em91CJgLrlPBMZXw;

4.11
date	2013.03.25.20.31.07;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	vCGDXb1zgPQnidJw;

4.10
date	2013.02.24.21.09.15;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	rgJG8ZFRF8o9ruFw;

4.9
date	2012.10.28.08.52.31;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	6n5fY77YU7JEb8qw;

4.8
date	2012.04.14.00.43.17;	author bavison;	state Exp;
branches;
next	4.7;
commitid	xkSKw5i9HVYqOL0w;

4.7
date	2011.11.25.08.26.06;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	IoNdwgrOKH29UGIv;

4.6
date	2011.10.14.07.23.50;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	D2Id4aPp4zmuUhDv;

4.5
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	A9Zxco9ydo9FCOBv;

4.4
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	PKTDORFkNFRVOmzv;

4.3
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.09.11.36.51;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.15;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.15;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.09.36;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.08.14.13.13.05;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.33.51;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.30.46;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Increase upper range of idlen to 21 bits
When 'BigMap' support was added drive sizes were such that (see table and discussion in Doc/BigDisc/BigDiscs) an upper maximum of 19 bits for idlen was appropriate. Now that drives of 2^29 sectors are readily available (the limit of 'BigDisc' support) the idlen limit of 19 has meant the minimum object size has grown too. This change uses the remaining 2 indirect disc address bits to get a factor x4 reduction in minimum object size, at the expense of a 4x larger map.

Defns.s: Parameterise idlen for big and small maps. Small's limit remains 15, big's limit raised from 19 to 21.
Identify.s: When mounting, use the parameterised idlen upper limits to decide whether it's a valid disc or not.
FileCore32.s: Adjust the BIC masks to knock out the extra 2 bits when forming the hash of the object id. Fix long standing bug updating the wrong entry in the hash table (due to LSL #2 giving 5x the entry index, rather than 3x).
FileCore15.s: Take care not to shift b20 of idlen into C as a side effect of a flags changing opcode. An audit of FileCore showed this to be the only site where the subsequent condition code(s) depended on C.
Tools/basic/DispMap: Updated to support BigMaps at all, previously it only worked with NewMap discs.

Tested with an assortment of drives with FSBash for 300k cycles of scrambling for idlen = 17, 19, 20 & 21.

Version 3.75. Tagged as 'FileCore-3_75'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >Defns

        TTL     "Definition of internal structures and constants"

bit0    bit 0
bit1    bit 1
bit2    bit 2
bit3    bit 3
bit4    bit 4
bit5    bit 5
bit6    bit 6
bit7    bit 7
bit8    bit 8
bit9    bit 9
bit10   bit 10
bit11   bit 11
bit12   bit 12
bit13   bit 13
bit14   bit 14
bit15   bit 15
bit16   bit 16
bit17   bit 17
bit18   bit 18
bit19   bit 19
bit20   bit 20
bit21   bit 21
bit22   bit 22
bit23   bit 23
bit24   bit 24
bit25   bit 25
bit26   bit 26
bit27   bit 27
bit28   bit 28
bit29   bit 29
bit30   bit 30
bit31   bit 31

; misc definitions

LF              * 10
CR              * 13
DeleteChar      * 127
K               * 1024
M               * K*K
DiscBits        * 2_111 :SHL: (32-3)    ;In all disc addresses

; internal SaveCreate reason codes

FirstUnknown_fsfile     *       fsfile_ReadBlockSize+1  ;load mapped internally to this
FirstUnknown_fsargs     *       fsargs_ImageStampIs+1
 [ BigDisc
FirstUnknown_fsfunc     *       fsfunc_AddDefect64+1
 |
FirstUnknown_fsfunc     *       fsfunc_DirIs+1
 ]

UnsharedCreate          *       fsfile_CreateDir

CloseSmall              *       FirstUnknown_fsfile+1
CloseContig             *       FirstUnknown_fsfile+2
RandomAccessCreate      *       FirstUnknown_fsfile+3
RandomAccessExtend      *       FirstUnknown_fsfile+4
        ASSERT RandomAccessExtend <= fsfile_Load

; flag bit in ESC_Status

EscapeBit       bit 6           ; escape if this bit set in ESC_Status

; reason codes for SWI OS_ClaimScreenMemory

                        ^ 0
ReleaseSpareScreen      # 1
ClaimSpareScreen        # 1

; bad pointer indicator bits (used for list ends etc)

BadPtr          *       &FFFFFFFF
BadPtrBits      *       &00000003

 [ BigFiles
RoundedTo4G     * 1             ; Return value from RoundUp[Alloc|Sector|Share] when the result equals 2^32.
                                ; Since no LFAU/sector/share is of size 1 byte this can never be returned
                                ; normally, fits in a register so the function prototype remains the
                                ; same, and is an ARM immediate constant to boot!
 ]

;
; FileCore disc record
                ^ 0
DiscRecordExternal # SzDiscRecSig2 ; Per public header file
DiscFlags          # 1
FloppyFlag              bit 0
NeedNewIdFlag           bit 1   ; Indicates that when this disc is next updated a new Id ought to be given it too
DiscNotFileCore         bit 2   ; Indicates this isn't a FileCore disc (yet)
DiscNotIdentified       bit 3   ; Indicates this Data disc hasn't been identified as something else yet.
AltMapFlag              bit 5
OldMapFlag              bit 6
OldDirFlag              bit 7   ;set <=> old small dirs
        ASSERT  FloppyStructure_Force_OldDir = OldDirFlag
        ASSERT  FloppyStructure_Force_OldMap = OldMapFlag

;entries below must be valid even when disc rec is not in use
Priority           # 1     ;0 DISC REC UNUSED
                           ;1 to # floppies -> floppy priority level
                           ;&FF good winnie
DiscsDrv           # 1     ;0-7 => drive in, 8 => not in drive, OR DISC REC UNUSED
DiscUsage          # 1     ;tasks using this disc, if >0 disc cant be forgotten
SzDiscRec          # 0

DefDiscRecEnd   * &00080000  ;default last word of disc record

; Preamble to disc rec for FORMAT
SzFormHdr * 8
        ^ -SzFormHdr
FormSig         # 1     ;signature
FormChar        # 1
HalfSide0Gap1   # 1
HalfSide1Gap1   # 1
Gap3            # 1
Skew            # 1
                # 2     ;unused
        ASSERT @@=0
SzFormDiscRec   * SzDiscRec+SzFormHdr

L_Root          * &200
D_Root          * &400

L_Size          * 640*K
D_Size          * 800*K

SzOldFs         * &200
SzNewFloppyFs   * &400

NewMapRoot              * &203   ;indirect disc add
NewFloppyRootDiscAdd    * &800   ;physical disc add

; Drive Record

        ^ 0
DrvsDisc        # 1
Uncertain       bit 7   ; Contents of disc in drive uncertain - may have a disc record attached, but not certain it's the right one or that it's type is correct
Unknown         bit 6   ; Contents of disc in drive not known (no attached disc record)
Empty           bit 5   ; Disc definitely not in drive
Full            bit 4   ; Disc definitely in drive, but no disc record attached to drive
                        ; bits 0-2 contains the disc record number for disc believed to be in this drive 

DrvFlags        # 1     ; Flags about drive
HasDefectList   bit 0   ; Set if drive has a defect list
LastDiscOpWasFormat bit 1 ; Set if the last DiscOp was a format track operation
LockCount       # 1     ; How many times the drive's been locked
PrevFormSectorSize # 1  ; SectorSize in previous format operation
PrevFormSecsPerTrk # 1  ; SecsPerTrk in previous format operation
PrevFormHeads   # 1     ; Heads in previous format operation
PrevFormDensity # 1     ; Density in previous format operation
PrevFormLowSector # 1   ; LowSector in previous format operation
PrevFormDiscSize aw 4   ; DiscSize in previous format operation
 [ BigDisc
PrevFormDiscSize2 aw 4  ; 2nd part of DiscSize in previous format operation
 ]
ChangedSeqNum   aw 4
 [ DynamicMaps
DrvsFsMapAddr   aw 4    ;ptr to free space map
DrvsFsMapArea   aw 4    ;dynamic area number
DrvsFsMapSize   aw 4    ;size of the map
DrvsFsMapFlags  aw 4    ;flags for the map
 |
DrvsFsMap aw 4  ;ptr to free space maps
 ]
BadFs   bit 31  ;set if corrupt on disc
EmptyFs bit 30  ;set if FS map buffer empty for old maps
FsMapMaxObjects * 1:SHL:MaxIdLenBigMap
FsMapMinObjBits * MaxIdLenBigMap+1
FsMapZoneSpareBits * 64*8192 ; a lavish ZoneSpare and NZones value
                             ; only relevant in the maximal map case
FsMapMaxBits    * (FsMapMinObjBits * FsMapMaxObjects) + FsMapZoneSpareBits
FsMapMaxSize    * FsMapMaxBits:SHR:3
 [ DynamicMaps
MemErrorFs bit 29       ;set if failed to load FSmap due to errors with dynamic areas
NewHiFsBits     * BadFs :OR: EmptyFs
 |
HiFsBits        * BadFs :OR: EmptyFs
 ]
SzDrvRec        # 0

                    
; structure of dir cache obj

                ^ 0
CacheNext       aw 4    ;->next obj, -1 marks end of cache
CachePriority   aw 4    ;0 for free space, -1 marks end of cache
CacheMin        # 0     ;min size for free space

; rest dont apply to free spaces
CacheRootStart  # 0
CacheYounger    aw 4    ;-> next youngest dir
CacheOlder      aw 4    ;-> next oldest dir
CacheRootEnd    # 0

CacheDir        aw 4    ;disc address of dir
CacheBody       # 0


; structure of a sector cache entry

                        ^ 0
SectorCache_Next        aw 4    ; Link to next cached sector, or 0
SectorCache_Address     aw 4    ; disc address of this cached sector
SectorCache_Error       aw 4    ; error encountered when reading this sector
SectorCache_Usage       aw 4    ; Number of times this block's been used
SectorCache_HeaderSize  # 0
SectorCache_Contents    # 0

; DEFECT LIST

; The list consists of words containing the disc address ( in bytes ) of bad
; sectors, the end is marked by a value &200000xx, where &xx forms a check
; byte on the earlier list. The last 64 bytes describe the disc to FileCore.
; Any other bytes may be used as params for the low level drivers

DefectListDiscAdd       * &400+&800
SzDefectList            * &200
MaxStruc                * 64
        ASSERT  SzDiscRecSig2<=MaxStruc

        ^ 0
                # SzDefectList-4-MaxStruc
ParkDiscAdd     # 4
DefectStruc     # MaxStruc
        ASSERT  @@=SzDefectList


; OLD FS MAP
        ^ 0
FreeStart       # 82*3  ;table of free space start sectors
EndSpaceList    # 0
                # 1     ;reserved
OldName0        # 5     ;              RETRO DEFINITION
OldSize         # 3     ;size in sectors
Check0          # 1     ;checksum on sector 0

FreeLen         # 82*3  ;table of free space lengths
OldName1        # 5     ;              RETRO DEFINITION
OldId           # 2     ;disc id
OldBoot         # 1     ;boot option
FreeEnd         # 1     ;ptr to end of free space list
Check1          # 1     ;checksum on sector 1

        ASSERT  {VAR}=&200

; New map

MaxFreeLinkBits * 15    ; Though 'BigMaps' extend this limit
MaxIdLenSmlMap  * 15
MaxIdLenBigMap  * 21

ZoneDiscRecSz   * 60    ;reserve additional bytes
Zone0Bits       * ZoneDiscRecSz*8
                ASSERT ZoneDiscRecSz >= SzDiscRec

                ^ 0
ZoneCheck       # 1
FreeLink        # 2     ;15 bit free space start link
CrossCheck      # 1     ;EORing this byte for all zones should yield &FF
ZoneHead        # ZoneDiscRecSz

;zones are followed in RAM by table of one byte of flags per zone

ZoneValid       bit 0
ZoneCompacted   bit 1



; Dir entry
                ^ 0
NameLen         * 10
DirObName       # NameLen
DirLoad         # 4
DirExec         # 4
DirLen          # 4
DirIndDiscAdd   # 3
OldDirObSeq     # 1

OldDirEntrySz   * {VAR}
        ASSERT  OldDirEntrySz=26

NewDirAtts      * OldDirObSeq
ReadBit         bit 0
WriteBit        bit 1
IntLockedBit    bit 2   ;the locked bit is held in bit 2 internally
ExtLockedBit    bit 3   ;but is returned in bit 3 externally
DirBit          bit 3
EBit            bit 4   ;6502 ADFS E files are treated as if R
 [ FullAtts             ;extended attributes only for new dirs
PublicReadBit   bit 4
PublicWriteBit  bit 5
ResvdAttBit6    bit 6
ResvdAttBit7    bit 7
NewAtts         * PublicReadBit :OR: PublicWriteBit :OR: ResvdAttBit6 :OR: ResvdAttBit7
 |
NewAtts         * 0
 ]
IntDirAttMask   * IntLockedBit :OR: DirBit :OR: NewAtts
IntAttMask      * IntDirAttMask :OR: ReadBit :OR: WriteBit
ExtAttMask      * ReadBit :OR: WriteBit :OR: ExtLockedBit :OR: NewAtts

NewDirEntrySz   * {VAR}


; Directory Start
                ^ 0
StartMasSeq     # 1
StartName       # 4
DirFirstEntry   # 0

; Old Directory End
                ^ 0
                # -1
DirCheckByte    # 0     ;RETROSPECTIVE DEFINITION (was reserved)

                # -4
EndName         # 0

                # -1
EndMasSeq       # 0

                # -14   ;reserved

DirTitleSz      * 19
                # -DirTitleSz
OldDirTitle     # 0

                # -3
OldDirParent    # 0

                # -NameLen
OldDirName      # 0

                # -1
OldDirLastMark  # 0     ;dummy last entry marker

; New Directory End
                ^ 0
                # -1
        ASSERT  DirCheckByte=@@

                # -4
        ASSERT  EndName=@@

                # -1
        ASSERT  EndMasSeq=@@

                # -NameLen
NewDirName      # 0

                # -DirTitleSz
NewDirTitle     # 0

                # -3
NewDirParent    # 0

                # -1    ;reserved
                # -1    ;reserved

                # -1
NewDirLastMark  # 0     ;dummy last entry marker

OldDirSize      * &500
NewDirSize      * &800

OldDirTabSz     * (OldDirSize-DirFirstEntry+OldDirLastMark)
NewDirTabSz     * (NewDirSize-DirFirstEntry+NewDirLastMark)
                ASSERT  OldDirTabSz :MOD: OldDirEntrySz = 0
                ASSERT  NewDirTabSz :MOD: NewDirEntrySz = 0
OldDirEntries   * OldDirTabSz / OldDirEntrySz
NewDirEntries   * NewDirTabSz / NewDirEntrySz

        ASSERT  OldDirEntries=47
        ASSERT  NewDirEntries=77

 [ BigDir
; SBP: 28 Aug 1997: Added new directory type, known as 'big'

; Big directory header
        ^ 0

BigDirStartMasSeq       # 1     ; master sequence number
BigDirVersion           # 3     ; directory version number
BigDirStartName         # 4     ; 'SBPr'
BigDirNameLen           # 4     ; Length of the directory's name
BigDirSize              # 4     ; Length of the directory
BigDirEntries           # 4     ; Number of entries in a directory
BigDirNamesSize         # 4     ; number of bytes allocated for names
BigDirParent            # 4     ; indirect disc address of parent directory
BigDirName              # 0     ; start of the dir name
BigDirHeaderSize        # 0     ; size of the header

; Big directory entry

        ^ 0

BigDirLoad              # 4     ; load address of object
BigDirExec              # 4     ; exec address of object
BigDirLen               # 4     ; length of object
BigDirIndDiscAdd        # 4     ; indirect disc address of object
BigDirAtts              # 4     ; attributes of object
BigDirObNameLen         # 4     ; length of object name
BigDirObNamePtr         # 4     ; offset into name heap for name
BigDirEntrySize         # 0     ; size of entry

; Big directory tail

        ^ 0
                        # -1
BigDirCheckByte         # 0
                        # -2    ; reserved
                        # -1
BigDirEndMasSeq         # 0
                        # -4
BigDirEndName           # 0     ; 'oven'

BigDirTailSize          * -@@

 [ Dev
 ! 0, "BigDirTailSize = " :CC: :STR: BigDirTailSize
 ]

; other useful definitions for big directories

BigDirMaxNameLen        * 255   ; maximum name length is 255 chars
BigDirMinSize           * &800
BigDirMaxSize           * 4*1024*1024

 ]


BufSz           RN 4
FileOff         RN 5    ; 0 to 4G-FileSwitch buffer
DiscAdjust      RN 6
TransferEnd     RN 7    ; 0-4G inclusive, FileSwitch buffer multiples
FragEnd         RN 8    ; 0-4G inclusive, FileSwitch buffer multiples
Fcb             RN 9
BufOff          RN 10
BufPtr          RN 11

;FILE CACHE BUFFER
                ^ 0

BufFlags        # 4     ; { these 4 are 
NextInFile      # 4     ; { in common with
PrevInFile      # 4     ; { with the
BufFileOff      # 4     ; { extended file control block

BufFcb          # 4
OlderBuf        # 4
YoungerBuf      # 4
BufPriority     # 1
                # 3
BufferData      # 1*K   ;data itself

BufScale        * 5
                ASSERT BufferData :SHL: BufScale = 1*K

                ^ 0                     ;priority levels for buffers
EmptyChain      # 1
MonotonicChain  # 1
NormalChain     # 1
AwaitsSeqChain  # 1
ReadAheadChain  # 1
WriteBehindChain # 1

EmptyBuf        bit EmptyChain+2        ;priority level flags
UsedMonotonic   bit MonotonicChain+2
NormalBuf       bit NormalChain+2
AwaitsSeqRead   bit AwaitsSeqChain+2
ReadAhead       bit ReadAheadChain+2
WriteBehind     bit WriteBehindChain+2

AllBufFlags     * EmptyBuf :OR: UsedMonotonic :OR: NormalBuf :OR:AwaitsSeqRead :OR: ReadAhead :OR: WriteBehind
                ASSERT AllBufFlags=2_11111100


; File Control Block

                ^ 0     ;FCB has header in common with file cache buffer

        ASSERT  BufFlags=@@
                # 4
        ASSERT  NextInFile=@@
                # 4
        ASSERT  PrevInFile=@@
                # 4
        ASSERT  BufFileOff=@@
                # 4

FcbNext         # 4     ;link to next FCB
FcbFlags        # 1
FcbBufSz        # 1     ;file cache buffer size in bytes >> BufScale, so 32=1024, 16=512, 8=256
 [ BigDir
        ASSERT  BigDirMaxNameLen<=255
FcbName         # 258   ; keep overall alignment the same
 |
FcbName         # 10    ;ASSUME LOWEST BYTE OF LENGTH IS ZERO! (to use as name terminator)
      [ BigFiles
        ! 1,    "FcbAllocLen not always LSB=0"
      ]
 ]
        ASSERT  {VAR}:MOD:4 = 0
FcbAllocLen     # 4     ;allocated length (typically FcbExtent rounded up to nearest LFAU)
FcbDir          # 4     ;dir containing file
FcbIndDiscAdd   # 4 
FcbExtent       # 4     ;file length in bytes
FcbExtHandle    # 4     ;0               => Fcb kept around although file closed
NotHandle       * 32*K  ;1...NotHandle-1 => external handle and access<>R
                        ;>=NotHandle     => ptr to chain of external handles
FcbLastReadEnd  # 4     ;0-4G inclusive, FileSwitch buffer multiples
FcbAccessHWM    # 4     ;for deciding if accesses are monotonic or not
FcbRdAheadBufs  # 1
FcbDataLostFlag # 1
                # 2     ;pad
FcbSize         # 0

; FcbFlags
; b0 set <=> file has read access
; b1 set <=> file has write access
; b2 Indicates which controller
; b3 set <=> dir
; b4 set <=> EXT needs ensuring
                ASSERT  ReadBit  = bit0
                ASSERT  WriteBit = bit1
FcbFloppyFlag   bit 2
                ASSERT  DirBit   = bit3
ExtFlag         bit 4
Monotonic       bit 5   ;set <=> all read access above HWM
Sequential      bit 6   ;set <=> reading sequentially
FcbDiscImage    bit 7   ;set <=> Fcb is disc image

;object in handle chain if can be multiply open

                ^ 0
NextHandleBlk   # 4
HandleBlkFcb    # 4
ExtHandle       # 4
HandleBlkSize   # 0

HandleBlkBit    bit 31  ;bit that marks internal handle as ptr to handle block


;Background process control block
;Both floppies and winnies have values of following

                ^ 0
Process         # 1     ;AMENDED FROM INACTIVE BY RETRYDRIVEOP
Inactive        bit 0
                ASSERT ReadAhead   = bit6
                ASSERT WriteBehind = bit7
ProcessDirect   # 1     ;&FF if process includes a direct transfer, 0 if not
ProcessDrive    # 1     ;FILLED IN BY RETRYDRIVEOP
                # 1
ShortProcessBlk # 0     ;when file cache not in use

ProcessEndPtr   # 4             ;Last scatterlist pair
ProcessOldLength # 4
ProcessWriteBehindDrive # 1     ;Must be in same word for atomic write
ProcessWriteBehindDisc # 1
                # 2             ;Not free for other use
ProcessWriteBehindLeft # 4
ProcessStartPtr # 4             ; DO NOT REORDER THESE
ProcessRamAdjust # 4            ; |  RAM target address for direct transfers, else disc adjust
ProcessStartOff # 4             ; |  0 to 4G-FileSwitch buffer
ProcessEndOff   # 4             ; |  0-4G inclusive, FileSwitch buffer multiples
ProcessFragEnd  # 4             ; |  0-4G inclusive, FileSwitch buffer multiples
ProcessFcb      # 4             ; |  Pointer to the corresponding file control block for this process
ProcessError    # 4             ; |  -8 from scatter list
ProcessStatus   # 4             ; |  -4 from scatter list
Active          bit 31          ; |
CanExtend       bit 30          ; |
ProcessPairs    # 0             ; v  scatter list (address,length) pairs

ExtraPairs      * 2

        END
@


4.13
log
@Regroup some debug, comment corrections
Switch 'DebugM' now used exclusively for the read cached sectors disc op, and DebugMt for multifs extensions.
Various spelling mistakes corrected in passing.
Same (non debug) binary, retagged as FileCore-3_64.
@
text
@d185 6
a190 1
FsMapMaxSize    * 4*1024*1024
d267 2
@


4.12
log
@Minor tidy ups
Service call table made unconditional.
Typo in Hdr:FileCore corrected.
Comments improved, and other misc housekeeping.

Version 3.62. Tagged as 'FileCore-3_62'
@
text
@d159 1
@


4.11
log
@Reenable background transfer support when BigFiles is {TRUE}
BigDirCode.s: Retire BigDirFix switch, it wasn't actually a fix, it was more that the directory format was changed early in development, but there's no point keeping support for the prototype any more
FileCore45.s/FileCore25.s/FileCore31.s/FileCore35.s/DebugOpts.s: Retire BigDirFix
Defns.s: Shock addition of some comments
FileCore.s: Manual inclusion of CPU/Arch no longer needed
FileCore70.s: Crucially apply the same 1k dead band to the FileSwitch "write zeros" entry point, since it (along with Get/PutBytes) are the only places file offsets get passed
FileCore80.s: Lots of tedious and subtle boundary cases fixed
InitDieSvc.s: Removed the disabling switch
doc/BigDisc/ADFSBuffer: Detail what the BufFlags mean

Tested on ADFS (the only background-transferring filing system about) with LFAUs of 2k, 4k, 8k, 16k and bashing 65536 iterations.

Version 3.57. Tagged as 'FileCore-3_57'
@
text
@a229 1
DefectEndMark           bit 29
d231 1
a231 1
        ASSERT  SzDiscRec<=MaxStruc
d234 1
a234 1
                # SzDefectList-MaxStruc-4
d236 1
a236 3
DefectStruc     # MaxStruc-1
;DefectCheck
                # 1
@


4.10
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@a409 3
 [ :LNOT: BigDirFix
BigDirEntryName         # 4     ; 'DirE'
 ]
d457 4
a460 4
BufFlags        # 4     ;these 4 are in common with extended FCB
NextInFile      # 4
PrevInFile      # 4
BufFileOff      # 4
d487 2
a488 2
AllocFlags      * EmptyBuf :OR: UsedMonotonic :OR: NormalBuf :OR:AwaitsSeqRead :OR: ReadAhead :OR: WriteBehind
                ASSERT AllocFlags=2_11111100
d506 1
a506 1
FcbBufSz        # 1
@


4.9
log
@Swap out some more constants for symbolic names
* OsBytes
* Application start &8000
* Fixed disc density
* Unused a4 macro deleted
* Redundant 'todo', 'Help, 'Syntax' removed

Version 3.53. Not tagged
@
text
@d52 4
a55 2
LF      * 10
CR      * 13
d57 2
a58 7

K       * 1024
M       * K*K

SzOldFs         * &200
SzNewFloppyFs   * &400

a59 1
VerifyRetries   * 5
d61 1
a61 3
EscapeBit       bit 6           ; escape if this bit set in ESC_Status

; load/exec file types
a72 1
; internal SaveCreate reason codes
d79 5
a83 1
; reason codes for SWI ClaimScreenMemory
a88 4
; definition of size of maximum free link

MaxFreeLinkBits *       15

d94 7
d145 2
d263 2
d303 5
a307 7
Att4            bit 4
PublicReadBit   * Att4
Att5            bit 5
PublicWriteBit  * Att5
Att6            bit 6
Att7            bit 7
NewAtts         * Att4 :OR: Att5 :OR: Att6 :OR: Att7
d327 1
a327 1
DirCheckByte    # 0     ;RETRO DEFINITION was reserved
d410 1
a410 1
 [ {FALSE}
a421 12

 [ {FALSE}
; Big directory name heap entry

        ^ 0

BigDirHeapName          # 4     ; 'Name'
BigDirHeapIndDiscAdd    # 4     ; copy of indirect disc address
BigDirHeapObName        # 0     ; name of file (padded with nulls to word boundary)
BigDirHeapHeaderSize    # 0     ; size of the header for a name heap entry
 ]

a425 1

a426 1

a427 1

a428 1

a429 1

a430 1

a441 1

d449 1
a449 1
FileOff         RN 5
d451 2
a452 2
TransferEnd     RN 7
FragEnd         RN 8
d496 1
a496 10
        ^ 0     ;FCB has header in common with file cache buffer

 ASSERT BufFlags=@@
 #      4
 ASSERT NextInFile=@@
 #      4
 ASSERT PrevInFile=@@
 #      4
 ASSERT BufFileOff=@@
 #      4
d498 8
d507 1
a507 1
FcbNext         aw 4    ;link to next FCB
d512 1
a512 1
FcbName         # 258   ; make sure aligned
d514 4
a517 1
FcbName         # 10
d519 13
a531 13
FcbLength       aw 4    ;ASSUME LOWEST BYTE ZERO TO USE AS NAME TERMINATOR
FcbDir          aw 4    ;dir containing file
FcbIndDiscAdd   aw 4
FcbExtent       aw 4
FcbExtHandle    # 4     ;0             => Fcb kept around although file closed
NotHandle       * 32*K  ;1-NotHandle-1 => external handle and access<>R
                        ;>=NotHandle   => ptr to chain of external handles
LastReadEnd     # 4
AccessHWM       # 4
ReadAheadBufs   # 1
DataLostFlag    # 1
                # 1
                # 1
d534 1
a534 1
; Flags
a537 2
FcbFloppyBitNo  * 2
FcbFloppyFlag   bit FcbFloppyBitNo
d542 1
d546 2
a547 3
SequentialBitNo * 6
Sequential      bit SequentialBitNo     ;set <=> reading sequentially
FcbDiscImage    bit 7   ; set <=> Fcb is disc image
d568 1
a568 1
ProcessDirect   # 1     ;0/&FF if process includes a direct transfer
d573 2
a574 2
ProcessEndPtr   # 4
OldLength       # 4
d577 1
a577 1
                # 2     ;Not free for other use
d579 11
a589 11
ProcessStartPtr # 4     ;DO NOT REORDER THESE
ProcessRamAdjust # 4
ProcessStartOff # 4
ProcessEndOff   # 4
ProcessFragEnd  # 4
ProcessFcb      # 4
ProcessError    # 4
ProcessStatus   # 4
Active          bit 31
CanExtend       bit 30
ProcessPairs    # 0
@


4.8
log
@  Miscellaneous improvements
Detail:
  * Added the ability for a filing system to specify to FileCore that floppy
    discs should be mounted like hard discs, to complement the existing flag
    that specifies the opposite. SDFS requires this. Ideally SCSIFS should
    start using this as well, to encapsulate boot block handling within
    FileCore.
  * Added header definitions so the FileCore and the filing systems can
    negotiate the use of a new MiscOp entry, needed as part of partitioning
    support, especially important for filing systems that use the hardware-
    specific section of the boot block, like ADFS. At present, FileCore
    doesn't do anything different (it still doesn't support partitions) but
    this enables filing systems to be modified in preparation.
  * Removed the only place where FileCore paid any attention to the
    EmptyWorks flag returned by MiscOp 1 - an obscure and not very useful
    edge case not used by any current filing systems.
  * Added 650 lines of documentation for the MiscOp SWI and low-level entry
    to the Doc directory, giving the information you need in order to
    implement a FileCore filing system.
  * Added missing header file definitions for the low-level background DiscOp
    reason code and the hot-plug drive removed flag to MiscOp 7.
  * Removed some RISC OS 2 legacy code whereby FileCore maintained its idea
    of the internal disc address of the CSD @@, PSD \, Library % and URD & for
    each filing system. Since RISC OS 3.00, FileSwitch handles these
    internally and passes canonicalised paths to FileCore, so FileCore's disc
    addresses for these directories remained unset. This allows some
    considerable simplification of FileCore's path parser in particular, but
    also affects other code like that which decides how to expire disc
    records. Also note that FileCore has been unable to generate certain
    errors (like "Can't delete current directory") since RISC OS 3.00 for the
    same reason.
  * Changed loading of the map for FileCore-format discs so that the map is
    loaded into the dynamic area during the Service_IdentifyDisc handler in
    one big DiscOp rather than loading it twice, sector-by-sector, via one
    big sector cache. For one thing, the sector cache is implemented
    inefficiently - O(n^2) - and for another thing, single-sector DiscOps are
    relatively inefficient on many filing systems, especially on SD cards.
    Some example speed-ups measured for mounting discs are:
      SCSIFS,   1GB drive: was 0.62 sec, now 0.40 sec (1.55 x speedup)
      SCSIFS, 256GB drive: was 1.44 sec, now 0.52 sec (2.77 x speedup)
      SDFS,     2GB drive: was 1.25 sec, now 0.14 sec (8.93 x speedup)
Admin:
  Tested on a beagleboard, with SCSIFS and SDFS.

Version 3.50. Tagged as 'FileCore-3_50'
@
text
@a66 7
; osbyte numbers

OsbyteAckEscape         * &7E
OsbyteReadVdu           * &A0
OsbyteReadResetType     * &FD
OsbyteBreakAction       * &F7

a85 8
; VDU workspace
 [ {TRUE}
WindowWidth     * &100
 |
LeftColumn      * 8
RightColumn     * &A
 ]

a91 2
ApplicStart     * 32*K

@


4.7
log
@Teach FileCore_LayoutStructure and Service_IdentifyDisc how to do 1 zone fixed discs.
From the change logs it was last fixed sometime around FileCore 2.50 era, but has been long broken.
The boot block was in the right place, but was overwritten by the root directory, and the wrong size entry was claimed in the map, amongst other errors.
Free'd up R6 in LayoutFreeSpaceMap to avoid having to keep reevaluating the number of zones - makes it a bit more readable. Corrected inaccurate comments. Checked the code paths for new map with and without boot block, with and without long filenames.
Test app 'Make1Zone' generates a small disc image which can be inspected in a hex editor for correctness.
In the identify code, be more strict about looking for a boot block only on fixed discs since they cannot occur on floppies (saves time, wasn't necessarily wrong).
The concept of a boot block at &C00 only works when 2 copies of the map can be fitted underneath that address, for future 2k and 4k sector sizes these do not fit and it is likely that 1 zone fixed discs are forbidden (a drive with 4k sectors would typically be > 512GB and 1 zone would be ~32MB so spilling into a second zone would waste < 0.01%).
Other minor changes:
* Free command now groups the 'K' with 'bytes' to match OS_ConvertFileSize.
* FileCore20 debug didn't assemble.
* FileCore33 beefed up comments.
* GenSWIs debug didn't assemble.
Tested with a special cut of RAMFS manually loading various 1 zone images into its dynamic area and checking they mount, have a sensible *MAP and *FREE result, can be written to, and don't have broken directories.

Version 3.46. Tagged as 'FileCore-3_46'
@
text
@a61 2
DiscOp_Op_BackgroundOp_Flag * 1:SHL:8     ;internal use only

@


4.6
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d280 4
a287 6

DummyLenBit     bit 31  ;always set

ZoneDiscRecSz   * 60    ;reserve additional bytes
                ASSERT ZoneDiscRecSz>=SzDiscRec

a289 2
Zone0Bits       * ZoneDiscRecSz*8

d478 1
a478 1
BigDirMinSize           * 2048
@


4.5
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d17 1
a17 21
        TTL     "Definition of constants"

; change log:

; 15 May 1997: SBP: Added MaxFreeLinkBits (15)

EscapeBit       bit 6           ;escape if this bit set in ESC_Status

MaxWinnies       * 2

Single          * 1
Double          * 2
Quad            * 4
Octal           * 8

K       * 1024
M       * K*K

;Register allocation

SB      RN 12
d56 3
d62 1
a62 9
        ASSERT EscapeBit=&40
AltDefectBit    bit 4   ;use alternative defect map, winnies only
ScatterBit      bit 5
NoEscape        bit 6
NoTimeOut       bit 7
BackgroundBitNo * 8
BackgroundOp    bit BackgroundBitNo     ;internal use only
Atomic          * NoEscape :OR: NoTimeOut
OpMask          * 2_1111 ;ops 0-15
d67 2
d113 1
a113 1
MaxFreeLinkBits	*	15
d120 513
@


4.4
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d119 1
a119 1
 [ T
@


4.3
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@a78 24
;Disc Operation Reason Codes

;Param4Op       * VerifyOp
;VerifyOp        * 0
;ReadSecsOp      * 1
;WriteSecsOp     * 2
;
;Param3Op       * 3
;ReadTrkOp       * 3
;WriteTrkOp      * 4
;
;Param2Op       * 5
;SeekOp          * 5
;
;RestoreOp       * 6
;StepInOp        * 7     ;floppy only
;StepOutOp       * 8     ;floppy only
;
; [ Version >= 205
;CachedReadSecsOp * 9
; ]
;
;SpecifyOp       * 15    ;winnie only

a97 3
; osword numbers

OswordReadClock * 14
a100 2
DataType        * &FFFFFD00

d111 1
a111 1
;internal SaveCreate reason codes
d118 1
a118 1
; Vdu workspace
@


4.2
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@a76 1
        [ NewFs
a77 1
        ]
a107 1
 [ FileCache
a109 1
 ]
d166 5
@


4.1
log
@Initial revision
@
text
@d19 3
d166 4
@


4.1.4.1
log
@Changes made to FileCore to support allowing idlen more than 15.  This allows
smaller LFAUs on discs.  The changes are not yet complete.  In particular, the
number of disc zones is limited to 255.  Some development testing has been
peformed, and the filing system is generally stable.  Areas which haven't
been fully tested include things like *Defect, FileCore_LayoutStructure,
FileCore_FloppyStructure, and the FileSwitch APIs for reading and examining
a disc's used space.

This version should not be used for any OS Builds with the BigMaps flag set
to true.  It should build as a normal version of FileCore with BigMaps and
BigDirs set to false.
@
text
@a18 3
; change log:

; 15 May 1997: SBP: Added MaxFreeLinkBits (15)
a162 4

; definition of size of maximum free link

MaxFreeLinkBits	*	15
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

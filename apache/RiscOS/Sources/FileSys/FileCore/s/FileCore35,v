head	4.14;
access;
symbols
	FileCore-3_75:4.14
	FileCore-3_74:4.14
	FileCore-3_73:4.14
	FileCore-3_72:4.14
	FileCore-3_71:4.14
	FileCore-3_70:4.14
	FileCore-3_69:4.14
	FileCore-3_68:4.14
	FileCore-3_67:4.14
	FileCore-3_66:4.14
	FileCore-3_65:4.14
	FileCore-3_64:4.14
	FileCore-3_63:4.14
	FileCore-3_62:4.14
	FileCore-3_61:4.13
	FileCore-3_60:4.13
	FileCore-3_59:4.13
	FileCore-3_58:4.13
	FileCore-3_57:4.13
	FileCore-3_56:4.12
	FileCore-3_55:4.11
	FileCore-3_54:4.10
	FileCore-3_53:4.10
	FileCore-3_52:4.10
	FileCore-3_51:4.10
	FileCore-3_50:4.10
	FileCore-3_49:4.10
	FileCore-3_48:4.10
	FileCore-3_47:4.10
	FileCore-3_46:4.9
	FileCore-3_45:4.9
	FileCore-3_44:4.8
	FileCore-3_43:4.8
	FileCore-3_42:4.8
	FileCore-3_41:4.7
	FileCore-3_40:4.6
	FileCore-3_39:4.6
	FileCore-3_38:4.6
	FileCore-3_37:4.6
	FileCore-3_36:4.6
	FileCore-3_35:4.6
	FileCore-3_34:4.6
	FileCore-3_33:4.6
	RO_5_07:4.5
	FileCore-3_32:4.5
	FileCore-3_31:4.5
	FileCore-3_30:4.5
	FileCore-3_29:4.4
	FileCore-3_28:4.4
	FileCore-3_25-4_9_2_2:4.4
	FileCore-3_27:4.4
	FileCore-3_26:4.4
	FileCore-3_22-4_6_2_1:4.3
	bavison_FileCore-3_22_dev_bp:4.3
	bavison_FileCore-3_22:4.3.0.2
	FileCore-3_25-4_9_2_1:4.4
	HAL:4.4.0.2
	FileCore-3_25:4.4
	FileCore-3_24:4.4
	FileCore-3_23:4.4
	dellis_autobuild_BaseSW:4.3
	FileCore-3_22:4.3
	Ursula_merge:4.1.4.6
	ROL_merge:4.1.4.6
	FileCore-3_21:4.3
	ROL_Ursula_merge:4.1.4.6
	Ursula_RiscPC_merge:4.1.4.6
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.5
	ROL_FileCore-3_21:4.1.4.6
	ROL_FileCore-3_20:4.1.4.6
	ROL:4.1.4.6.0.4
	ROL_bp:4.1.4.6
	Ursula_RiscPC_bp:4.1.4.6
	FileCore-3_18:4.1.4.6
	FileCore-3_01:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.6
	Ursula_RiscPC:4.1.4.6.0.2
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.1.4.6
	sproven_FileCore-3_16:4.1.4.6
	rthornb_UrsulaBuild-19Aug1998:4.1.4.6
	UrsulaBuild_FinalSoftload:4.1.4.6
	rthornb_UrsulaBuild-12Aug1998:4.1.4.6
	aglover_UrsulaBuild-05Aug1998:4.1.4.6
	rthornb_UrsulaBuild-29Jul1998:4.1.4.6
	rthornb_UrsulaBuild-22Jul1998:4.1.4.6
	rthornb_UrsulaBuild-15Jul1998:4.1.4.6
	rthornb_UrsulaBuild-07Jul1998:4.1.4.6
	rthornb_UrsulaBuild-17Jun1998:4.1.4.6
	rthornb_UrsulaBuild-03Jun1998:4.1.4.6
	rthornb_UrsulaBuild-27May1998:4.1.4.6
	rthornb_UrsulaBuild-21May1998:4.1.4.6
	sproven_FileCore-3_15:4.1.4.6
	sproven_314:4.1.4.6
	rthornb_UrsulaBuild_01May1998:4.1.4.6
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.6
	sproven_3_11:4.1.4.6
	sproven_3_10:4.1.4.6
	sproven_Ursula_3_09:4.1.4.5
	sproven_3_07:4.1.4.5
	sproven_3_06:4.1.4.4
	sproven_3_05:4.1.4.4
	sproven_3_04:4.1.4.3
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.3
	sproven_3_02:4.1.4.2
	sproven_3_01:4.1.4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.14
date	2013.07.18.21.04.17;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	Em91CJgLrlPBMZXw;

4.13
date	2013.03.25.20.31.08;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	vCGDXb1zgPQnidJw;

4.12
date	2013.02.24.21.09.15;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	rgJG8ZFRF8o9ruFw;

4.11
date	2013.02.21.16.53.08;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	CCuV2tngKttj75Fw;

4.10
date	2011.11.25.08.50.22;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	Wvsb4iMJaWIw2HIv;

4.9
date	2011.10.14.07.23.51;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	D2Id4aPp4zmuUhDv;

4.8
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	A9Zxco9ydo9FCOBv;

4.7
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	PKTDORFkNFRVOmzv;

4.6
date	2009.05.17.01.48.31;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2001.05.14.16.26.35;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.11.36.56;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.09.21.12.07.19;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.25.54;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.16.14.46.45;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.11.17.13.32.31;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.12.01.12.03.04;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.01.09.11.45.03;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.01.23.16.41.27;	author sproven;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.02.17.14.59.41;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.08;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.02;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Minor tidy ups
Service call table made unconditional.
Typo in Hdr:FileCore corrected.
Comments improved, and other misc housekeeping.

Version 3.62. Tagged as 'FileCore-3_62'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;>FileCore35

        TTL     "FileCore35 - Free space map operations"

; ===============
; BeforeReadFsMap
; ===============

; This routine ensures that
;  1) that we have a valid free space map in RAM
;  2) that disc is locked in

; entry: R3 top 3 bits disc num
; exit:  If error V set, R0 result

BeforeReadFsMap ROUT
        Push    "R0-R2,R4-R8,LR"
 [ DebugN
        DLINE   "Enter BeforeReadFsMap(",cc
 ]
        MOVS    R7, #-1
        B       %FT05

; ================
; BeforeAlterFsMap
; ================

; This routine ensures that
;  1) we have found the drive for the relevant disc
;  2) that the disc is locked in
;  3) that we have a valid free space map in RAM
;  4) that ptrs to the disc & drv recs are in CritDiscRec & CritDrvRec

; 1), 2) ensure that
;  a) that the contents will not go uncertain causing WhatDisc to reload FS map
;  b) that the in use light remains on so the user knows not to remove disc

; entry: R3 top 3 bits disc num
; exit:  If error V set, R0 result code

BeforeAlterFsMap
        Push    "R0-R2,R4-R8,LR"
 [ DebugN
        DLINE   "Enter BeforeAlterFsMap(",cc
 ]
        MOVS    R7, #0
05
 [ DebugN
        DREG    R3,,cc
        DLINE   ")"
 ]
        ; Obtain disc and drive numbers, then check for Floppy
        MOV     R2, R3, LSR #(32-3)
        DiscRecPtr  R5, R2
        LDRB    LR, [R5, #DiscFlags]
        TST     LR, #DiscNotFileCore
        CMPNE   R7, #-1                 ; Only reject if AlterFsMap
        MOVNE   R0, #DiscNotFileCoreErr
 [ {TRUE}                               ; is this the cause of our problems?
        BEQ     %FT01
        BL      SetVOnR0
        B       %FT99
01
 |
        BNE     %FT94
 ]
        LDRB    R1, [R5, #DiscsDrv]
        LDRB    LR, [R5, #DiscFlags]
        TST     LR, #FloppyFlag
   [ DebugN
        DLINE   "Locking map into drive"
   ]
        BL      DiscWriteBehindWait     ;(R3)
        LDRB    R4, Interlocks
        ORREQ   LR, R4, #WinnieLock
        ORRNE   LR, R4, #FloppyLock
        STRB    LR, Interlocks

        LDREQ   LR, WinnieProcessBlk
        LDRNE   LR, FloppyProcessBlk

        ; If no buffers,then no write-behind and fake up disc appropriately
        LDRB    R1, MaxFileBuffers
        TEQ     R1, #0
        LDRNEB  LR, [LR, #ProcessWriteBehindDrive]
        MOVEQ   LR, #&FF

        ; If write behind disc lock this disc, else just pick up our drive
        TEQS    LR, #&FF
        LDRNEB  R1, [R5, #DiscsDrv]
        BLEQ    LockDisc        ;(R3->R0,R1,V)
        STRVSB  R4, Interlocks
        BVS     %FT99

   [ DebugN
        DREG    R2, "Disc ",cc
        DREG    R1, " now assumed locked into drive "
   ]
        ; Winnie and floppy rejoin here with:
        ; R1 = drive
        ; EQ if floppy, otherwise NE
        ASSERT  :INDEX: LockedDrive :MOD: 4 = 0
        ASSERT  LockedDisc-LockedDrive=1
        ASSERT  ModifyDisc-LockedDisc=1
        MOV     R2, R3, LSR #(32-3)     ;disc
        ORR     LR, R1, R2, LSL #8      ;OR in locked disc
        ORR     LR, LR, R2, LSL #16     ;OR in modify disc
        STR     LR, LockedDrive
        STRB    R4, Interlocks
        STR     R5, CritDiscRec

        ; No map to read if on a non-FileCore disc
        LDRB    LR, [R5, #DiscFlags]
        TST     LR, #DiscNotFileCore
        BNE     %FT90

        DrvRecPtr  R6,R1
        STR     R6, CritDrvRec
 [ DynamicMaps
        LDR     LR, [R6,#DrvsFsMapFlags]
        TSTS    LR, #BadFs
        MOVNE   R0, #BadFsMapErr
        BNE     %FT94
        LDR     R8, [R6, #DrvsFsMapAddr]
 |
        LDR     R8, [R6,#DrvsFsMap]
        TSTS    R8, #BadFs
        MOVNE   R0, #BadFsMapErr
        BNE     %FT94
 ]
        BL      TestMap         ;(R3->Z)
        BNE     %FT10
        BL      LoadNewMap      ;(R5,R6,R8->R0,V)
        BVS     %FT95
        TEQS    R7, #0
        BNE     %FT90

 [ BigMaps
        LDRB    R2, [R5, #DiscRecord_NZones]                ;IF about to alter new map
        LDRB    R0, [R5, #DiscRecord_BigMap_NZones2]
        ADD     R2, R2, R0, LSL #8
 |
        LDRB    R2, [R5, #DiscRecord_NZones]                ;IF about to alter new map
 ]
        MOV     R0, R8
        LDRB    R1, [R5, #DiscRecord_Log2SectorSize]
        MOV     LR, #1
        MOV     R1, LR, LSL R1
09
        BL      NewCheck        ;(R0,R1->Z)      THEN checksum each zone
 [ DynamicMaps
        LDRNE   LR, [R6, #DrvsFsMapFlags]
        ORRNE   LR, LR, #BadFs
        STRNE   LR, [R6,#DrvsFsMapFlags]
 |
        ORRNE   R8, R8, #BadFs
        STRNE   R8, [R6,#DrvsFsMap]
 ]
        MOVNE   R0, #BadFsMapErr
        BNE     %FT94
        SUBS    R2, R2, #1
        BNE     %BT09
        LDRB    R0, [R5, #DiscFlags]            ;AND moan if only one good copy
        ANDS    R0, R0, #AltMapFlag
        MOVNE   R0, #OneBadFsMapErr
        B       %FT94

10
 [ DynamicMaps
        LDR     LR, [R6, #DrvsFsMapFlags]
        TSTS    LR, #EmptyFs
 |
        TSTS    R8, #EmptyFs
 ]
        BNE     %FT80
        CMPS    R7, #0
        BNE     %FT90

        Push    "R3"
        MOV     R3, R5          ;disc rec
        MOV     R4, R6          ;drv rec
        BL      CheckFsMap      ;(R3,R4->R0,V)
        Pull    "R3"
 [ DynamicMaps
        LDR     LR, [R6, #DrvsFsMapFlags]
        ORRVS   LR, LR, #BadFs
        STRVS   LR, [R6,#DrvsFsMapFlags]
 |
        ORRVS   LR, R8, #BadFs
        STRVS   LR, [R6,#DrvsFsMap]
 ]
        B       %FT95

80
;need to load FS map
        MOV     R1, #DiscOp_ReadSecs
        AND     R2, R3, #DiscBits       ;old Fs maps at 0
        Push    "R3"
 [ DynamicMaps
        MOV     R3, R8
 |
        BIC     R3, R8, #HiFsBits
 ]
        MOV     R4, #SzOldFs
        BL      RetryDiscOp             ;(R1-R4->R0-R4)
        MOVVC   R3, R5                  ;disc rec
        MOVVC   R4, R6                  ;drv rec
        BLVC    CheckFsMap              ;(R3,R4->R0,V)
        Pull    "R3"
  [ DynamicMaps
        LDRVC   LR, [R6, #DrvsFsMapFlags]
        BICVC   LR, LR, #NewHiFsBits
        STRVC   LR, [R6, #DrvsFsMapFlags]
  |
        BICVC   LR, R8, #HiFsBits
        STRVC   LR, [R6,#DrvsFsMap]
  ]
        BVS     %FT95
90
        TEQS    R7, #0
        STRNEB  R7, ModifyDisc
        MOVS    R0, #0
94
        BL      SetVOnR0
95
        BLVS    UnlockMap
99
 [ DebugN
        DLINE   "leave Before(Read/Alter)FsMap", cc
        BVC     %FT01
        DREG    R0," rc=(",cc
        DLINE   ")",cc
01
        DLINE   ""
 ]
        STRVS   R0, [SP]
        Pull    "R0-R2,R4-R8,PC"


; =========
; UnlockMap
; =========

UnlockMap ROUT

        Push    "R0-R3,LR"
        SavePSR R3
        LDRB    R1, LockedDrive
 [ DebugDR
        DREG    LR,"UnlockMap called from:"
        DREG    R1,"Drive number is:"
        Push    "R0"
        ADRL    R0, Module_BaseAddr
        DREG    R0, "Module base is:"
        Pull    "R0"
 ]
        TST     R1, #bit2

        ; lock up the controller
        LDRB    R2, Interlocks
        ORREQ   LR, R2, #WinnieLock
        ORRNE   LR, R2, #FloppyLock
        STRB    LR, Interlocks

        ; Unlock locked drive if no write behind disc on that controller
        LDREQ   LR, WinnieProcessBlk
        LDRNE   LR, FloppyProcessBlk

        ; If no write behind fake write behind disc to &FF
        LDRB    R0, MaxFileBuffers
        TEQ     R0, #0
        LDRNEB  LR, [LR, #ProcessWriteBehindDrive]
        MOVEQ   LR, #&FF

        TEQ     LR, #&FF
        BICEQS  LR, R1, #7      ; check that drive valid
        BLEQ    UnlockDrive

        ; clear out the locked disc details
        ASSERT  (:INDEX: LockedDrive) :MOD: 4 = 0       ;word write to be atomic
        ASSERT  LockedDisc - LockedDrive = 1
        ASSERT  ModifyDisc - LockedDisc = 1
        MOV     R0, #-1
        STR     R0, LockedDrive

        ; unlock the controller
        STRB    R2, Interlocks          ;restore interlocks
        RestPSR R3,,f
        Pull    "R0-R3,PC"


; ===========
; EnsureNewId
; ===========

; The very first write to a floppy after it has been recognised must be to
; alter the disc id in case it is also currently known in another machine

; entry: R3 disc id in top 3 bits

; exit:  If error V set, R0 result code

EnsureNewId ROUT
 [ Debug5 :LOR: DebugE
        DREG    R3, "EnsureNewId(",cc
        DLINE   ")"
 ]
        Push    "R0-R2,R11,LR"

        CLRV

        BL      DiscAddToRec            ;(R3->LR)
        LDRB    R0, [LR,#DiscFlags]
 [ DebugL
        DREG    R0, "DiscFlags picked up are "
 ]

        ; Check if new Id needed
        TST     R0, #NeedNewIdFlag
        BEQ     %FT99

        TST     R0, #DiscNotFileCore
        BNE     %FT50

        ; Stamp FileCore disc

        LDRB    R11,LockedDrive
 [ DebugL
        DREG    R11, "LockedDrive is "
 ]
        TEQS    R11,#&FF                ;are we already in a FS map routine
        BNE     %FT10
        BL      BeforeAlterFsMap        ;(R3->R0,V)
        BVS     %FT99
10
 [ DebugL
        DLINE   "So, writing out the map.."
 ]
        BL      WriteFsMap              ;(->R0,V)
        LDRB    LR, LockedDrive
        TEQS    LR, R11
        BLNE    UnlockMap
        B       %FT99

50
        ; Stamp non-filecore disc
        MOV     r1, #FSControl_StampImage_Now
        ADD     r2, lr, #DiscRecord_DiscName
        BL      StampImage

99
        STRVS   R0, [SP]
        Pull    "R0-R2,R11,PC"


; ===============
; PrelimFreeCheck
; ===============

; checks that after deleting old obj there will be room for new obj

;entry:
; R3 = ind disc address of dir
; R4 ->entry for old obj
; R5 ->dir start
; R6 ->dir end
; R10= size required

;exit:
;IF error V set, R0 result
;      ELSE C=1 => can use old obj space for new
;      R2 = old obj ind disc add if R0=0 and C=1, else corrupt


PrelimFreeCheck ROUT
 [ Debug5 :LOR: DebugE
        DREG    R10, "PrelimFreeCheck(",cc
        DLINE   ")"
 ]
        Push    "R0,R1,R3-R4,R7-R11,LR"
        BL      ReadLen         ;(R3,R4->LR)
        MOV     R0, LR
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        MOV     R2, LR

        AND     LR, R2, #&FF
        CMPS    LR, #1                          ;C=1 <=> shared or zero length
        BHI     %FT40                           ;don't reuse shared if not at frag start
        BLCC    TestMap         ;(R3->Z)
        BNE     %FT50           ;old map
        BLCC    RoundUpAlloc    ;(R0,R3->R0)
        BLCS    RoundUpSector   ;(R0,R3->R0)
        MOV     R4, R0                          ;R4 := deletion candidate len
        MOV     R0, R10                         ;R0 := required len
        BLCC    RoundUpAlloc    ;(R0,R3->R0)
        BLCS    RoundUpSector   ;(R0,R3->R0)
      [ BigFiles
        TEQS    R0, R4          ;exactly equal test also works when RoundedTo4G
      |
        TEQS    R0, R4
      ]
  [ No32bitCode
        TEQNEP  PC, #SVC_mode   ;if not same rounded size return C=0, V=0. Preserves Z
  |
        MSRNE   CPSR_f, #0      ;if not same rounded size return C=0, V=0. Preserves Z
  ]
        Pull    "R0,R1,R3-R4,R7-R11,PC",NE
        Pull    "R0,R1,R3-R4,R7-R11,PC",CS      ;C=1,V=0 same size and shared or 0 len

        Push    "R2,R5"
        MOV     R5, #0
        BL      DefFindFileFragment     ;(R2,R5->R2,R4,R9,LR)
        Pull    "R2,R5"         ;If contiguous will reuse same space
        CMPS    R4, R0          ;C=1 <=> contiguous, (first frag >= total), V=0
        Pull    "R0,R1,R3-R4,R7-R11,PC"

40      ADDS    R0, R0, #0      ;C=0, V=0
        Pull    "R0,R1,R3-R4,R7-R11,PC"
50
        ; Old map case
        BL      RoundUpAlloc    ;(R0,R3->R0) always < 2G old map
        MOV     R4, R0          ;old disc space
        MOV     R0, R10
        BL      RoundUpAlloc    ;(R0,R3->R0) always < 2G old map
        MOV     R1, R0          ;new disc space
;if new obj <= old obj then certainly will be space for new object
        CMPS    R1, R4          ;compare new space with old disc space
        MOVLS   R0, #0
        BLS     %FT95           ;if branch C=1 <=> same, ie can reuse old space

        MOV     R0, R4          ;will total free space+old space
        BL      InitReadOldFs   ;(R3->R9-R11)
        B       %FT85
80
        ADD     LR, R8, R7
        TEQS    R2, LR          ;IF space immediately before old obj
        MOVEQ   R2, R8          ;include space in old obj

        ADDNE   LR, R2, R4      ;IF space immediately after old obj
        TEQNES  R8, LR          ;include space in old obj

        ADDEQ   R4, R4, R7

        CMPS    R1, R7          ;compare space needed with this space
        BLS     %FT90           ;found a big enough space
85
        BL      NextOldFs       ;(R10,R11->R7,R8,R10,R11,Z)
        ADDNE   R0, R0, R7
        BNE     %BT80           ;loop until no more spaces

        CMPS    R1, R4          ;If no one space alone is big enough is old obj plus
                        ;spaces either side big enough
90
        MOVLSS  R0, #0,2        ;if success also set C=0
        BLS     %FT95
        CMPS    R1, R0          ;If cant find space is it > old obj + total space
        MOVLS   R0, #CompactReqErr
        MOVHI   R0, #DiscFullErr
95
; IF V=0 THEN C=1 <=> can reuse old space
        BL      SetVOnR0
 [ Debug5 :LOR: DebugE
        DLINE   "<-PrelimFreeCheck(",cc
        BVC     %FT01
        DREG    R0,,cc
01
        DLINE   ")"
 ]
        STRVS   R0, [SP]
        Pull    "R0,R1,R3-R4,R7-R11,PC"



; ==============
; ClaimFreeSpace
; ==============

; Find and claim free space for object

; entry
; R0 old extent   RandomAccessExtend Only
; R3 top 3 bits=disc num
; R4 -> dir entry RandomAccessExtend Only
; R5 -> dir start Save/Create/Close Only
; R10 size needed ( old size for OpenOutCreate )
; R11 fsfile_Save/fsfile_Create/UnsharedCreate/CloseSmall/CloseContig/RandomAccessCreate/RandomAccessExtend

;exit:
; IF error V set, R0 result
; ELSE
;  R2  ind disc address for file
;  R10 unchanged except for RandomAccess when it is length claimed

ClaimFreeSpace ROUT
 [ Debug5
        DREG    R10, "ClaimFreeSpace(",cc
        DREG    R11, ",",cc
        DLINE   ")"
 ]
         ^ 0
ClaimExt        # 4     ;R0
                # 4     ;R1
ClaimDirEntry   # 4     ;R4
ClaimDirStart   # 4     ;R5
                # 4     ;R6
                # 4     ;R7
                # 4     ;R8
                # 4     ;R9
ClaimLength     # 4     ;R10
ClaimReason     # 4     ;R11

        Push    "R0,R1,R4-R11,LR"
        ASSERT  RandomAccessCreate>fsfile_Save
        ASSERT  RandomAccessCreate>fsfile_Create
        ASSERT  RandomAccessCreate>UnsharedCreate
        ASSERT  RandomAccessCreate>CloseSmall
        ASSERT  RandomAccessCreate>CloseContig
        ASSERT  RandomAccessExtend>RandomAccessCreate

        CMPS    R11,#RandomAccessCreate ;C=1 <=> RandomAccess
        BL      TestMap                 ;(R3->Z) preserves C
        BEQ     NewClaimFree

        MOVS    R0, R10                 ;old map - quick exit for silly claims > 2G
        MOVMI   R0, #DiscFullErr        
        BMI     %FT95

        MOV     R4, #-1                 ;initialise best fit so far to rogue
        BCC     %FT20

        BL      RoundUpAlloc            ;(R0,R3->R0) always < 2G old map
        MOV     R1, R0
        BIC     LR, R1, #&00FF
        BIC     LR, LR, #&FF00
        ADD     LR, LR, #&10000         ;next 64K boundary after file size
        STR     LR, [SP,#ClaimLength]   ;overwrite stacked R10
        BL      InitReadOldFs           ;(R3->R9-R11)
        B       %FT10
05
        CMPS    R7, R1
        BLO     %FT10           ;too small
        LDR     LR, [SP,#ClaimLength]
        SUBS    LR, R7, LR
        RSBMI   LR, LR, #0      ;difference between gap size and 64K boundary
        CMPS    LR, R4          ;IF best so far note
        MOVLO   R4, LR          ;  goodness of fit
        MOVLO   R6, R7          ;  length
        MOVLO   R2, R8          ;  disc address
        SUBLO   R0, R10,#3      ;  position in map
        ADDLO   R5, R11,#3
10
        BL      NextOldFs       ;(R10-R11->R7,R8,R10,R11,Z)
        BNE     %BT05           ;loop while more free spaces
        CMPS    R4, #-1
        BNE     %FT12           ;space found
        TEQS    R1, #0
        STREQ   R1, [SP,#ClaimLength]
        BEQ     %FT20
        BL      TotalFree       ;(R3->R0)
        CMPS    R1, R0
        MOVHI   R0, #DiscFullErr ;no free space at all
        MOVLS   R0, #CompactReqErr
        B        %FT95
12
        LDR     R1, [SP,#ClaimLength]
        CMPS    R1, R6
        SUBCC   R6, R6, R1
        MOVCS   R1, R6
        STRCS   R1, [SP,#ClaimLength]
        MOVCSS  R6, #0  ;EQ <=> using whole gap
                ;R1 is length to use, R6 length unused
        BCC     %FT92
        MOV     R10,R0          ;restore position in FS map
        MOV     R11,R5
        B       %FT87

20
        ANDEQ   R2, R3, #DiscBits ;zero length request
        BEQ     %FT95
        BL      RoundUpAlloc    ;(R0,R3->R0) always < 2G old map
        MOV     R1, R0

        MOV     R5, #0          ;will total space
        BL      InitReadOldFs   ;(R3->R9-R11)
        B       %FT90
85
        CMPS    R1, R7          ;compare space needed with this space

;if an exact match
        MOVEQ   R2, R8
        SUBEQ   R10,R10,#3
        ADDEQ   R11,R11,#3
87
        BLEQ    RemoveOldFsEntry        ;(R3,R9,R10,R11)
        MOVEQ   R0, #0
        BEQ     %FT95

        CMPLOS  R7, R4          ;IF space needed < this space < best so far
        MOVLO   R4, R7          ;best length   := this length
        MOVLO   R2, R8          ;best disc add := this disc add
        SUBLO   R0, R10,#3      ;note position in FS map
        SUBLO   R6, R7, R1      ;and remaining space
90
        BL      NextOldFs       ;(R10,R11->R7,R8,R10,R11,Z)
        ADDNE   R5, R5, R7      ;add to total space
        BNE     %BT85           ;loop until no more spaces
        CMPS    R4, #-1         ;EQ <=> no space found
92
;if inexact match reduce free space
        BEQ     %FT93
        MOV     R10,R0
        MOV     R7, R6
        ADD     R8, R2, R1
        BL      WriteOldFsEntry ;(R3,R7,R8,R10)
        MOV     R0, #0
        B       %FT95

;if failed to find space compare space needed with total space
93      CMPS    R1, R5
        MOVLS   R0, #CompactReqErr
        MOVHI   R0, #DiscFullErr
95
        BL      SetVOnR0
        STRVS   R0, [SP]
 [ Debug5
        Pull    "R0,R1,R4-R10"
        DLINE   ""
        DREG    R2, "<-ClaimFreeSpace(Ind disc:",cc
        DREG    R10, ",length:",cc
        BVC     %FT01
        DREG    R0, ",Result:",cc
01
        DLINE   ")"
        Pull    "R11,PC"
 |
        Pull    "R0,R1,R4-R11,PC"
 ]


; ================
; ReturnWholeSpace
; ================

; As ReturnSpace but new length=0

ReturnWholeSpace
        MOV     R0, #0  ;fall through into ReturnSpace

; ===========
; ReturnSpace
; ===========

; entry:
;  R0 new file length in bytes
;  R1 old file length in bytes
;  R2 Ind Disc address of file
;  R3 dir ind disc add
;  R4 -> dir entry
;  R5 -> dir start, may be fudged only used to check sharing

; exit: IF error V set, R0 result

ReturnSpace ROUT
 [ Debug5 :LOR: DebugX
        DLINE   "new len :old len :ind disc:dir     :DirEntry:DirStart enter ReturnSpace"
        DREG   R0," ",cc
        DREG   R1," ",cc
        DREG   R2," ",cc
        DREG   R3," ",cc
        DREG   R4," ",cc
        DREG   R5," "
 ]
        Push    "R0-R4,R6-R11,LR"
        BL      RoundUpAlloc    ;(R0,R3->R0)
        MOV     R6, R0
        MOV     R0, R1
        BL      RoundUpAlloc    ;(R0,R3->R0)
      [ BigFiles
        TEQ     R6, #RoundedTo4G
        MOVEQ   R7, #&FFFFFFFF
        MOVNE   R7, R6
        TEQ     R0, #RoundedTo4G
        MOVEQ   R1, #&FFFFFFFF
        MOVNE   R1, R0

        SUBS    LR, R1, R7
      |
        SUBS    R1, R0, R6      ;length of returned space
      ]
        BLS     %FT90           ;nothing to return

        BL      TestMap         ;(R3->Z)
        BNE     %FT70           ;if old map

        TSTS    R2, #&FF
        BEQ     %FT15           ;not shared obj

        TEQS    R6, #0
        BNE     %FT90           ;IF not returning whole obj then done

        BL      ReallyShared    ;(R2-R5->Z)
        BEQ     %FT90           ;IF frag shared then done
        BIC     R2, R2, #&FF
15

        BL      CritInitReadNewFs   ;(->R10,R11)
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
      [ BigFiles
        TEQ     R6, #RoundedTo4G
        ASSERT  RoundedTo4G = 1
        MOVEQ   R6, R6, ROR LR
        MOVNE   R6, R6, LSR LR  ;new length in map bits
        TEQ     R0, #RoundedTo4G
        MOVEQ   R7, R0, ROR LR
        MOVNE   R7, R0, LSR LR  ;old length in map bits
      |
        MOV     R6, R6, LSR LR  ;new length in map bits
        MOV     R7, R0, LSR LR  ;old length in map bits
      ]
        MOV     R9, #-1         ;don't know about pre gaps yet
20
        MOV     R1, R6
        BL      FindFragment    ;(R1,R2,R9,R10->R1,R9,R11,LR)
        SUB     R0, R1, R11     ;new length
        ADD     R1, R0, LR      ;old length = new length + length returning
        Push    "R2"
        MOV     R2, R11
        SUB     R7, R7, LR      ;decrement length left, may go -ve due to having overallocated a frag
                                ;within a zone (to prevent stranding bits < idlen at the end)
        MOV     R3, R9
        BL      ShortenFrag     ;(R0-R3,R10)
        Pull    "R2"
        CMPS    R6, R7          ;loop until whole file returned
        BLT     %BT20           ;LT rather than LO as R7 may be -ve
        BL      InvalidateFragCache
        B       %FT90
70
        ; Old map case
        ADD     R6, R2, R6      ;start of returned space
        ADD     R0, R2, R0      ;end of returned space
        BL      InitReadOldFs   ;(R3->R9-R11)
        MOV     R4, R9          ;init ptr to first space after returned space
75
        BL      NextOldFs       ;(R10,R11->R7,R8,R10,R11,Z)
        BNE     %FT80
;returned space does not join any existing spaces
        SUB     R0, R10,R9
        CMPS    R0, #EndSpaceList
        MOVHS   R0, #MapFullErr
        BHS     %FT95
        MOV     R7, R1
        MOV     R8, R6

        BL      InvalidateFsMap ;(R3)
        ADD     R0, R0, #3
        STRB    R0, [R9,#FreeEnd]

        MOV     R0, R4          ;move up disc addresses of later spaces
        ADD     R1, R4, #3
        SUBS    R2, R10,R4
        BL      BlockMove

        ADD     R0, R0, #SzOldFs/2      ;also move up later space lengths
        ADD     R1, R1, #SzOldFs/2
        BL      BlockMove

        MOV     R10,R4          ;put returned space entry in gap just made
        BL      WriteOldFsEntry ;(R3,R7,R8,R10)
        B       %FT90
80
        CMPS    R8, R6          ;IF this space is before returned space
        MOVLS   R4, R10         ;THEN set next space as first space after
        TEQS    R8, R0          ;does this space join end of returned space
        MOVEQ   R8, R6
        ADDEQ   R7, R1, R7
        BEQ     %FT85

        ADD     LR, R8, R7      ;does this space join start of returned space
        TEQS    LR, R6
        BNE     %BT75
        MOV     R6, R8          ;if so does next space join end of returned space
        ADD     R1, R7, R1
        BL      NextOldFs       ;(R10,R11->R7,R8,R10,R11,Z)
        BEQ     %FT83           ;no next space
        SUB     R10,R10,#3
        ADD     R11,R11,#3
        TEQS    R8, R0
        ADDEQ   R1, R1, R7
        BLEQ    RemoveOldFsEntry        ;(R3,R9-R11)
83
        MOV     R8, R6
        MOV     R7, R1
85
        SUB     R10,R10,#3
        BL      WriteOldFsEntry ;(R3,R7,R8,R10)
90
        MOV     R0, #0
95
        BL      SetVOnR0
 [ Debug5 :LOR: DebugX
        BVC     %FT96
        DREG   R0," ",cc
96
        DLINE "leave ReturnSpace"
 ]
        STRVS   R0, [SP]
        Pull    "R0-R4,R6-R11,PC"


; ==================
; RemoveDirEntryOnly
; ==================

; as RemoveDirEntry but dont return space, always succeeds

RemoveDirEntryOnly ROUT
 [ Debug5
        DREG    R3, "", cc
        DREG    R4, " ", cc
        DREG    R5, " ", cc
        DREG    R6, " ", cc
        DLINE   "enter RemoveDirEntryOnly"
 ]
        Push    "R0-R2,LR"
        B       %FT10

; ==============
; RemoveDirEntry
; ==============

; Remove a directory entry, and the space associated with it. Used
; for example when deleting a file (renaming across directories would use
; function RemoveDirEntryOnly to keep the data in tact).

; entry:
;  R3 ind disc address of dir
;  R4 -> dir entry
;  R5 -> dir start
;  R6 -> dir end

; exit: IF error V set, R0 result

RemoveDirEntry
 [ Debug5
        DREG    R4, " ",cc
        DLINE   "enter RemoveDirEntry"
 ]
        Push    "R0-R2,LR"
        ;return space to map
        BL      ReadIndDiscAdd          ;(R3,R4->LR)
        MOV     R1, LR
        BL      MeasureFileAllocSize_GotMap ;(R1,R3,R4->R0)
      [ BigFiles
        TEQ     R0, #RoundedTo4G
        MOVEQ   R1, #&FFFFFFFF          ;ReturnWholeSpace rounds up internally anyway
        MOVNE   R1, R0
      |
        MOV     R1, R0
      ]
        BL      ReadIndDiscAdd          ;(R3,R4->LR)
        MOV     R2, LR
        BL      ReturnWholeSpace        ;(R1-R5->R0)
        BVS     %FT95
10
 [ BigDir
        BL      TestBigDir
        BNE     %FT90
        Push    "R7"

        BL      InvalidateBufDir
        ; if it's a big dir, we do two moves - first before bit, then the after

 [ DebugX
        LDR     LR, [R5, #BigDirEntries]
        DREG    LR, "entries:"
 ]

        BL      GetBigDirName           ; (R4,R5->LR)
        LDR     R7, [R4, #BigDirObNameLen]      ; length of name
        ADD     R7, R7, LR
        ADD     R7, R7, #4
        BIC     R7, R7, #3              ; bit after name
        ADD     R0, R4, #BigDirEntrySize; source
        MOV     R1, R4                  ;
        SUBS    R2, LR, R0              ; size of move

 [ DebugX
        DLINE   "first move:"
        DREG    R0, "source:"
        DREG    R1, "  dest:"
        DREG    R2, "  size:"
 ]
        BLNE    BlockMove               ; moved down first part

        MOV     R0, R7                  ; source of move
        ADD     R1, R1, R2              ; dest of move
        LDR     LR, [R5, #BigDirEntries]
        LDR     R2, [R5, #BigDirNamesSize]
        ADD     R2, R2, #BigDirHeaderSize

        ASSERT  BigDirEntrySize=28
        RSB     LR, LR, LR, LSL #3
        ADD     R2, R2, LR, LSL #2

        LDR     LR, [R5, #BigDirNameLen]
        ADD     R2, R2, LR
        ADD     R2, R2, #4
        BIC     R2, R2, #3
        ADD     R2, R2, R5

        SUBS    R2, R2, R0              ; now length

 [ DebugX
        DLINE   "second move:"
        DREG    R0, "source:"
        DREG    R1, "  dest:"
        DREG    R2, "  size:"
 ]
        BLNE    BlockMove

        LDR     LR, [R5, #BigDirEntries]
        SUB     LR, LR, #1
        STR     LR, [R5, #BigDirEntries]

 [ DebugX
        DREG    LR, "Entries now:"
 ]

        LDR     LR, [R5, #BigDirNamesSize]
        SUB     R1, R0, R1
        SUB     R1, R1, #BigDirEntrySize
        SUB     LR, LR, R1
        STR     LR, [R5, #BigDirNamesSize]

  [ DebugX
        DREG    R1, "names reduced by:"
  ]
        Push    "R4"
12
        BL      BigDirFinished
        BEQ     %FT15
        LDR     LR, [R4, #BigDirObNamePtr]
        SUB     LR, LR, R1
        STR     LR, [R4, #BigDirObNamePtr]
        ADD     R4, R4, #BigDirEntrySize
        B       %BT12

15
        Pull    "R4"
20
        Pull    "R7"
        MOV     R0, #0
        B       %FT95
90
 ]
        ; not a big directory - move down following entries
        SUB     R2, R4, R5
        BL      InvalidateBufDir
        BL      TestDir        ;(R3->LR,Z)
        RSBEQ   R2, R2, #(NewDirEntrySz*(NewDirEntries-1)+DirFirstEntry+1) :AND: &FF00
        ADDEQ   R2, R2, #(NewDirEntrySz*(NewDirEntries-1)+DirFirstEntry+1) :AND: &FF
        RSBNE   R2, R2, #(OldDirEntrySz*(OldDirEntries-1)+DirFirstEntry+1) :AND: &FF00
        ADDNE   R2, R2, #(OldDirEntrySz*(OldDirEntries-1)+DirFirstEntry+1) :AND: &FF
 [ NewDirEntrySz=OldDirEntrySz
        ADD     R0, R4, #NewDirEntrySz
 |
        ADDEQ   R0, R4, #NewDirEntrySz
        ADDNE   R0, R4, #OldDirEntrySz
 ]
        MOV     R1, R4
        BL      BlockMove
        MOV     R0, #0
95
        BL      SetVOnR0
99
        STRVS   R0, [SP]
 [ Debug5
        BVC     %FT01
        DREG    R0, " ",cc
01
        DLINE   "leave RemoveDirEntry(Only)"
 ]
        Pull    "R0-R2,PC"


; =========
; TotalFree
; =========

; Find total free space on disc

; entry:  R3 top 3 bits disc num

; exit:   R0=total free

TotalFree ROUT
        Push    "R7-R11,LR"
        MOV     R0,#0
        BL      InitReadFs              ;(R3->R9-R11)
10
        BL      NextFs                  ;(R3,R9-R11->R7-R11,Z)
        ADDNE   R0, R0, R7
        BNE     %BT10
        Pull    "R7-R11,PC"


; ===============
; SizeLessDefects
; ===============

; entry R3 top 3 bits disc bits

; exit LR disc size in bytes excluding defects

SizeLessDefects ROUT
        Push    "R0-R2,R6,LR"
        SavePSR R6

        ; Get the disc size
        MOV     R2, R3, LSR #(32-3)       ;disc
 [ DebugL
        DREG    R2, "SizeLessDefects(",cc
 ]
        DiscRecPtr  R1, R2
        LDR     LR, [R1, #DiscRecord_DiscSize]

        ; skip defect correction on NewMap discs
        LDRB    R0, [R1, #DiscFlags]
        TST     R0, #OldMapFlag
        BEQ     %FT20

        ; Get the drive
        LDRB    R0, [R1, #DiscsDrv]

        ; Don't correct for defects on DefectList-less discs
        DrvRecPtr  R2, R0
        LDRB    R2, [R2, #DrvFlags]
        TST     R2, #HasDefectList
        BEQ     %FT20

        ; Find the defect list and remove defects*1<<Log2SectorSize bytes from disc size
        LDR     R2, DefectSpace
        ADD     R2, SB, R2
        ASSERT  SzDefectList = (1 :SHL: 9)
        ADD     R2, R2, R0, LSL #9
        LDRB    R1, [R1, #DiscRecord_Log2SectorSize]
        MOV     R0, #1
        MOV     R1, R0, LSL R1
10
        LDR     R0, [R2],#4
        RSBS    R0, R0, #1 :SHL: 29
        SUBHI   LR, LR, R1
        BHI     %BT10
20
 [ DebugL
        MOV     R0, LR
        DREG    R0, ")="
 ]
        RestPSR R6,,f
        Pull    "R0-R2,R6,PC"

 [ BigDisc

; =================
; SizeLessDefects64
; =================

; entry R3 top 3 bits disc bits

; exit LR bottom 32 bits disc size in bytes
;      R0 top 32 bits disc size in bytes

SizeLessDefects64 ROUT
        Push    "R1-R2,R6,LR"
        SavePSR R6

        ; Get the disc size
        MOV     R2, R3, LSR #(32-3)       ;disc
 [ DebugL
        DREG    R2, "SizeLessDefects64(",cc
 ]
        DiscRecPtr  R1, R2
        LDR     LR, [R1, #DiscRecord_DiscSize]

        ; skip defect correction on NewMap discs
        LDRB    R0, [R1, #DiscFlags]
        TST     R0, #OldMapFlag
        LDREQ   R0, [R1, #DiscRecord_BigMap_DiscSize2]
        BEQ     %FT20

        ; Get the drive
        LDRB    R0, [R1, #DiscsDrv]

        ; Don't correct for defects on DefectList-less discs
        DrvRecPtr  R2, R0
        LDRB    R2, [R2, #DrvFlags]
        TST     R2, #HasDefectList
        MOVEQ   R0, #0
        BEQ     %FT20

        ; Find the defect list and remove defects*1<<Log2SectorSize bytes from disc size
        LDR     R2, DefectSpace
        ADD     R2, SB, R2
        ASSERT  SzDefectList = (1 :SHL: 9)
        ADD     R2, R2, R0, LSL #9
        LDRB    R1, [R1, #DiscRecord_Log2SectorSize]
        MOV     R0, #1
        MOV     R1, R0, LSL R1
10
        LDR     R0, [R2],#4
        RSBS    R0, R0, #1 :SHL: 29
        SUBHI   LR, LR, R1
        BHI     %BT10
        MOV     R0,#0
20
 [ DebugL
        DREG    R0, ")=", cc
        DREG    LR
 ]
        RestPSR R6,,f
        Pull    "R1-R2,R6,PC"

 ]

; =============
; InitReadOldFs
; =============

; prepare to read entries from old format FS map, ( assumes already in RAM )

; entry: R3 top 3 bits disc id

; exit:  R9,R10 -> first free space disc address entry
;        R11    =  number of free spaces * 3, MAY BE ZERO

InitReadOldFs
        MOV     R9, R3, LSR #(32-3)
        DiscRecPtr  R9,R9
        LDRB    R9, [R9,#DiscsDrv]
        DrvRecPtr  R9,R9
 [ DynamicMaps
        LDR     R9, [R9, #DrvsFsMapAddr]
 |
        LDR     R9, [R9,#DrvsFsMap]
        BIC     R9, R9, #HiFsBits ;for multiple map ops, eg extend by move
 ]
        MOV     R10,R9
        LDRB    R11,[R9,#FreeEnd]
 [ Debug5
        DREG    R3
        DREG    R9
        DREG    R10
        DREG    R11
        mess    ,"InitReadOldFs",NL
 ]
        MOV     PC,LR           ; Flags preserved


; =========
; NextOldFs
; =========

; read next free space from old format fs map

; entry:
;  R3  -> top 3 bits disc id
;  R10 -> free space disc address entry
;  R11 =  # free spaces left * 3

; exit:
;  IF no more spaces Z=1
;  ELSE
;   Z=0
;   R7 = length of free space
;   R8 = disc address of next space
;   R10  inc 3
;   R11  dec 3

NextOldFs
        Push    "R0,LR"
 [ Debug5
        DREG    R3
        DREG    R10
        DREG    R11
        mess    ,"enter NextOldFs",NL
 ]
        TEQS    R11,#0
        MOVNE   R0, R10
        Read3   NE
        ANDNE   R0, R3, #2_111 :SHL: (32-3)
        ORRNE   R8, R0, LR, LSL #8
        ADDNE   R0, R10,#SzOldFs / 2
        Read3   NE
        MOVNE   R7, LR, LSL #8
        ADDNE   R10,R10,#3
        SUBNE   R11,R11,#3
 [ Debug5
        DREG    R7, NE
        DREG    R8, NE
        mess    NE, "Next free space",NL
        mess    EQ, "No more free spaces",NL
 ]
        Pull    "R0,PC"


; ================
; RemoveOldFsEntry
; ================

; entry:
;  R3  -> top 3 bits disc id
;  R9  -> fs map
;  R10 -> free space disc address entry
;  R11 =  # free spaces after and including this entry

RemoveOldFsEntry
 [ Debug5
        mess    ,"RemoveOldFsEntry",NL
 ]
        Push    "R0-R2,R4,LR"
        SavePSR R4
        BL      InvalidateFsMap         ;(R3)
;move down rest of free space disc address entries
        ADD     R0, R10,#3
        MOV     R1, R10
        SUB     R2, R11,#3
        BL      BlockMove
;move down rest of free space length entries
        ADD     R1, R10,#SzOldFs/2
        ADD     R0, R1, #3
        BL      BlockMove
;update end of free space ptr
        LDRB    R2, [R9,#FreeEnd]
        SUBS    R2, R2, #3
        STRB    R2, [R9,#FreeEnd]
        RestPSR R4,,f
        Pull    "R0-R2,R4,PC"


; ===============
; WriteOldFsEntry
; ===============

; this does not create a new entry, just overwrites previous entry

; entry:
;  R3  top 3 bits disc id
;  R7  length
;  R8  disc address
;  R10 -> entry

WriteOldFsEntry
 [ Debug5
        DREG    R7
        DREG    R8
        mess    ,"Write old free space",NL
 ]
        Push    "R0,R1,LR"
        BL      InvalidateFsMap                 ;(R3)
        MOV     R0,R10
        BIC     R1,R8,#DiscBits
        MOV     R1,R1,LSR #8
        Write3
        ADD     R0,R10,#SzOldFs/2
 [ Dev
        TSTS    R7,#DiscBits
        mess    NE,"writing silly length to map",NL
 ]
        MOV     R1,R7,LSR #8
        Write3
        Pull    "R0,R1,PC"


; ===================
; UpdateFsMapCheckSum
; ===================

UpdateFsMapCheckSum
        Push    "R0-R2,LR"
        LDR     LR, CritDrvRec
 [ DynamicMaps
        LDR     R0, [LR,#DrvsFsMapAddr]
 |
        LDR     R0, [LR,#DrvsFsMap]
        BIC     R0, R0, #HiFsBits
 ]
        MOV     R1, #SzOldFs/2
        BL      CheckSum
        STRB    R2, [R0,#Check0]
        ADD     R0, R0, #SzOldFs/2
        BL      CheckSum
        ASSERT  Check1-Check0=SzOldFs/2
        STRB    R2, [R0,#Check0]
        Pull    "R0-R2,PC"


; ==========
; WriteFsMap
; ==========

WriteFsMap ROUT
 [ Debug5
        DLINE   "WriteFsMap"
 ]
        Push    "R0-R11,LR"
        BL      DisableBreak
        BL      CriticalWriteFsMap
        BL      RestoreBreak
        STRVS   R0,[SP]
        Pull    "R0-R11,PC"


; =================
; WriteDirThenFsMap
; =================

WriteDirThenFsMap ROUT
 [ Debug5
        DLINE   "WriteDirThenFsMap"
 ]
        Push    "R0-R11,LR"
        BL      DisableBreak
        BL      CriticalWriteDirThenFsMap
        BL      RestoreBreak
        STRVS   R0,[SP]
        Pull    "R0-R11,PC"


; =================
; WriteFsMapThenDir
; =================

WriteFsMapThenDir ROUT
 [ Debug5 ;:LOR: DebugXr
        DLINE   "WriteFsMapThenDir"
 ]
        Push    "R0-R11,LR"
        BL      DisableBreak
        BL      CriticalWriteFsMapThenDir
        BL      RestoreBreak
        STRVS   R0,[SP]
 [ DebugXr :LAND: {FALSE}
        DebugError "Error in WriteFsMapThenDir "
 ]
        Pull    "R0-R11,PC"

 [ WriteCacheDir
; ======================
; WriteFsMapThenMaybeDir
; ======================

WriteFsMapThenMaybeDir ROUT
 [ Debug5
        DLINE   "WriteFsMapThenMaybeDir"
 ]
        Push    "R0-R11,LR"
        BL      DisableBreak
        BL      CriticalWriteFsMapThenMaybeDir
        BL      RestoreBreak
        STRVS   R0,[SP]
        Pull    "R0-R11,PC"
 ]

; ===============
; InvalidateFsMap
; ===============

; Entry: R3 top 3 bits disc id

InvalidateFsMap
        Push    "R3,LR"
 [ Debug5
        DREG    R3
        mess    ,InvalidateFsMap,NL
 ]
        BL      DiscAddToRec    ;(R3->LR)
        LDRB    LR,[LR,#DiscsDrv]
        DrvRecPtr  LR,LR
 [ DynamicMaps
        LDR     R3,[LR,#DrvsFsMapFlags]
        ORR     R3,R3,#EmptyFs
        STR     R3,[LR,#DrvsFsMapFlags]
 |
        LDR     R3,[LR,#DrvsFsMap]
        ORR     R3,R3,#EmptyFs
        STR     R3,[LR,#DrvsFsMap]
 ]
        Pull    "R3,PC"                 ; Flags Preserved


; ============
; MakeDirEntry
; ============

; Fill in details of file in RAM copy of dir

; entry:
;  R0  atts
;  R1  -> name
;  R2  ind disc add of file
;  R3  ind disc add of dir
;  R4  -> entry
;  R5  -> dir start
;  R7  load address
;  R8  exec address
;  R10 length

MakeDirEntry
        Push    "R0,R9,R11,LR"
        SavePSR R9
 [ BigDir
        BL      TestBigDir
        BEQ     %FT50
 ]
        LDRB    R11,[R4]
        BL      WriteName       ;(R1,R4)
        BL      IncObjSeqNum    ;(R3-R5)
        BL      SetIntAtts      ;(R0,R3,R4)
 [ NewDirEntrySz=OldDirEntrySz
        ADD     R0, R4, #NewDirEntrySz
 |
        BL      TestDir         ;(R3->LR,Z)
        ADDEQ   R0, R4, #NewDirEntrySz
        ADDNE   R0, R4, #OldDirEntrySz
 ]
        TEQS    R11,#0          ;if this was last entry
        MOVEQ   LR, #0          ;make next entry last entry
        STREQB  LR, [R0]
        MOV     R0, R2
        BL      WriteIndDiscAdd ;(R0,R3,R4)
        MOV     R0, R7
        BL      WriteLoad       ;(R0,R3,R4)
        MOV     R0, R8
        BL      WriteExec       ;(R0,R4)
        MOV     R0, R10
        BL      WriteLen        ;(R0,R3,R4)

        RestPSR R9,,f
        Pull    "R0,R9,R11,PC"

 [ BigDir
50
        BL      WriteBigName    ;(R1,R4,R5)
        BL      SetIntAtts      ;(R0,R3,R4)
        MOV     R0, R2
        BL      WriteIndDiscAdd ;(R0,R3,R4)
        MOV     R0, R7
        BL      WriteLoad       ;(R0,R3,R4)
        MOV     R0, R8
        BL      WriteExec       ;(R0,R3,R4)
        MOV     R0, R10
        BL      WriteLen        ;(R0,R3,R4)
        RestPSR R9,,f
        Pull    "R0,R9,R11,PC"
 ]

; =========
; WriteName
; =========

; copy file name string to dir entry

; entry:
;  R1 -> name
;  R4 -> entry

WriteName ROUT
        Push    "R0-R2,R4,R5,LR"
        SavePSR R5
        ASSERT  DirObName=0
        MOV     R2, #NameLen
10
        BL      ThisChar        ;(R1->R0,C)
        ADD     R1, R1, #1
        MOVCS   R0, #CR         ;if terminator
        STRB    R0, [R4],#1
        BCS     %FT90
        SUBS    R2, R2, #1
        BNE     %BT10
90
        RestPSR R5,,f
        Pull    "R0-R2,R4,R5,PC"


; ================
; InvalidateBufDir
; ================

InvalidateBufDir
        Push    "R0,LR"
        SavePSR R0
        LDR     LR, BufDir
        CMPS    LR, #-1
        STRNE   LR, CritBufDir
        MOV     LR, #-1
        STRNE   LR, BufDir
        RestPSR R0,,f
        Pull    "R0,PC"


; ==============
; ValidateBufDir
; ==============

ValidateBufDir
        Push    "LR"
 [ Debug6
        DLINE    "ValidateBufDir"
 ]
        LDR     LR, CritBufDir
        CMPS    LR, #-1
        STRNE   LR, BufDir
        MOV     LR, #-1
        STRNE   LR, CritBufDir

 [ WriteCacheDir
        MOV     LR, #0
        STR     LR, BufDirDirty
 ]
        ADDS    R0,R0,#0                ; clear V
        Pull    "PC"


; ===================
; IdentifyCurrentDisc
; ===================

;exit NZC preserved
; IF error V set, R0 result
; R3 top 3 bits disc num

; Method:
; Find out from FileSwitch the full path of '$' which will be CSD-based

CSD_Path        DCB     "$",0
        ALIGN

IdentifyCurrentDisc ROUT
        Push    "R0-R7,LR"
        SavePSR R7

        MOV     r0, #FSControl_CanonicalisePath
        ADR     r1, CSD_Path
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #0
        MOV     r5, #0
        BL      DoXOS_FSControl
        BVS     %FT90

        ; Round overflow up to whole word
        RSB     r5, r5, #3 + 1          ; + 1 for the terminator
        BIC     r5, r5, #3

 [ DebugQ
        DREG    r5, "Buffer space needed:"
 ]

        ; Get the buffer space off the stack
        MOV     r6, r5
        SUB     sp, sp, r5

        MOV     r2, sp

        BL      DoXOS_FSControl
        BVS     %FT85

        ; syntax *is* <fs>[#<special>]::<disc>.<other stuff>
        MOV     r0, #":"
        MOV     r1, sp
 [ DebugQ
        DSTRING r1,"String returned by FileSwitch is "
 ]
10
        LDRB    r14, [r1], #1
        TEQ     r14, #":"
        BNE     %BT10

        ; Skip the second :
        ADD     r1, r1, #1
        MOV     r2, r1

        ; Terminate at the next .
20
        LDRB    r14, [r1, #1]!
        TEQ     r14, #"."
        BNE     %BT20

        MOV     r14, #0
        STRB    r14, [r1]

        MOV     r1, r2

 [ DebugQ
        DSTRING r1, "Disc name used is "
 ]
        MOV     r2, #0
        BL      FindDiscByName
        ADD     sp, sp, r6
        STRVC   r3, [sp, #3*4]
        B       %FT90

85
        ADD     sp, sp, r6

90
        STRVS   R0, [SP]
        MOV     lr, r7
        Pull    "r0-r7"
        B       PullLinkKeepV

        LTORG

; ==========================
; IdentifyDiscInCurrentDrive
; ==========================

;exit NZC preserved
; IF error V set, R0 result
; R3 top 3 bits disc num

; Method:
; Find out from FileSwitch the full path of the CSD

IdentifyDiscInCurrentDrive ROUT
        Push    "r0-r2, r4, lr"
        SavePSR r4
        LDRB    r1, Drive
        BL      WhatDisc        ;(r1->r0-r3,V)
        MOVVC   r3, r2, LSL #(32-3)
        STRVS   r0, [sp, #0*4]
        MOV     lr, r4
        Pull    "r0-r2, r4"
        B       PullLinkKeepV

        LTORG
        END
@


4.13
log
@Reenable background transfer support when BigFiles is {TRUE}
BigDirCode.s: Retire BigDirFix switch, it wasn't actually a fix, it was more that the directory format was changed early in development, but there's no point keeping support for the prototype any more
FileCore45.s/FileCore25.s/FileCore31.s/FileCore35.s/DebugOpts.s: Retire BigDirFix
Defns.s: Shock addition of some comments
FileCore.s: Manual inclusion of CPU/Arch no longer needed
FileCore70.s: Crucially apply the same 1k dead band to the FileSwitch "write zeros" entry point, since it (along with Get/PutBytes) are the only places file offsets get passed
FileCore80.s: Lots of tedious and subtle boundary cases fixed
InitDieSvc.s: Removed the disabling switch
doc/BigDisc/ADFSBuffer: Detail what the BufFlags mean

Tested on ADFS (the only background-transferring filing system about) with LFAUs of 2k, 4k, 8k, 16k and bashing 65536 iterations.

Version 3.57. Tagged as 'FileCore-3_57'
@
text
@d1094 1
a1094 1
        DREG    R2, "SizeLessDefects(",cc
d1131 2
a1132 2
        MOV     R1, LR
        DREG    R1, ")="
@


4.12
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@d914 1
a914 1
 [ BigDirFix
d918 1
a918 4
 |
        ASSERT  BigDirEntrySize=32      ;
        ADD     R2, R2, LR, LSL #5      ; entries
 ]
@


4.11
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d402 2
a403 2
        BHI     %FT40                           ;dont reuse shared if not at frag start
        BLCC    TestMap
d405 1
a405 1
        BLCC    RoundUp         ;(R0,R3->R0)
d407 3
a409 3
        MOV     R4, R0
        MOV     R0, R10
        BLCC    RoundUp         ;(R0,R3->R0)
d411 3
d415 1
d434 2
a435 2

        BL      RoundUp         ;(R0,R3->R0)
d438 1
a438 1
        BL      RoundUp         ;(R0,R3->R0)
d534 2
a535 2
        CMPS    R11,#RandomAccessCreate  ;C=1 <=> RandomAccess
        BL      TestMap         ;(R3->LR,Z) preserves C
d537 3
a539 2
        MOVS    R0, R10
        MOVMI   R0, #DiscFullErr
d542 1
a542 1
        MOV     R4, #-1         ;initialise best fit so far to rogue
d545 1
a545 1
        BL      RoundUp         ;(R0,R3->R0)
d594 1
a594 1
        BL      RoundUp         ;(R0,R3->R0)
d688 1
a688 1
        BL      RoundUp         ;(R0,R3->R0)
d691 11
a701 1
        BL      RoundUp
d703 1
d711 1
d714 1
d721 13
a733 3
        LDRB    R7, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        MOV     R6, R6, LSR R7  ;new length in map bits
        MOV     R7, R0, LSR R7  ;old length in map bits
d742 2
a743 1
        SUB     R7, R7, LR      ;decrement length left, may go -ve
d867 5
d873 2
a874 1
        BL      ReadIndDiscAdd
a966 1

@


4.10
log
@Fold in old fixes.
From 1989, probably safe to keep them. Binary unchanged.

Version 3.47. Tagged as 'FileCore-3_47'
@
text
@d63 1
a63 1
        DREG    R3, "",cc
d119 1
a119 1
        MOV     R2, R3, LSR #29         ;disc
d145 1
a145 1
        BL      TestMap
d152 1
a153 1
 [ BigMaps
d156 2
d475 1
a475 1
        DREG    R0, "",cc
d491 1
a491 1
; R0 old extent   RandomAccessExtendOnly
d493 1
a493 1
; R4 -> dir entry RandomAccessExtendOnly
d663 2
a664 2
;  R0 new file length
;  R1 old file length
d723 1
a723 1

d816 4
d834 2
a835 2
;return space to map
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
d939 1
a939 1
;move down following entries
d1419 1
a1419 1
        BL      WriteLen        ;(R0,R4)
@


4.9
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@a828 1
 [ fix_5
a832 4
 |
        BL      ReadLen
        MOV     R1, LR
 ]
@


4.8
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d138 1
a138 1
        LDR	R8, [R6, #DrvsFsMapAddr]
d152 1
a152 1
        LDRB    R2, [R5, #Zones]                ;IF about to alter new map
d154 2
a155 2
        LDRB	R0, [R5, #Zones2]
        ADD	R2, R2, R0, LSL #8
d158 1
a158 1
        LDRB    R1, [R5, #SectorSize]
d164 1
a164 1
 	LDRNE	LR, [R6, #DrvsFsMapFlags]
d182 2
a183 2
 	LDR	LR, [R6, #DrvsFsMapFlags]
 	TSTS	LR, #EmptyFs
d197 1
a197 1
 	LDR	LR, [R6, #DrvsFsMapFlags]
d208 1
a208 1
        MOV     R1, #ReadSecsOp
d212 1
a212 1
 	MOV	R3, R8
d223 3
a225 3
  	LDRVC	LR, [R6, #DrvsFsMapFlags]
  	BICVC	LR, LR, #NewHiFsBits
  	STRVC	LR, [R6, #DrvsFsMapFlags]
d360 1
a360 1
        ADD     r2, lr, #DiscName
d701 1
a701 1
        LDRB    R7, [R10,#ZoneHead+BitSize]
d784 1
a784 1
	BVC	%FT96
d844 3
a846 3
 	BL	TestBigDir
 	BNE	%FT90
 	Push	"R7"
d848 2
a849 2
 	BL	InvalidateBufDir
 	; if it's a big dir, we do two moves - first before bit, then the after
d852 2
a853 2
 	LDR	LR, [R5, #BigDirEntries]
 	DREG	LR, "entries:"
d856 8
a863 8
 	BL	GetBigDirName		; (R4,R5->LR)
 	LDR	R7, [R4, #BigDirObNameLen]	; length of name
 	ADD	R7, R7, LR
 	ADD	R7, R7, #4
 	BIC	R7, R7, #3		; bit after name
 	ADD	R0, R4, #BigDirEntrySize; source
 	MOV	R1, R4			;
 	SUBS	R2, LR, R0		; size of move
d866 12
a877 12
  	DLINE	"first move:"
  	DREG	R0, "source:"
  	DREG	R1, "  dest:"
  	DREG	R2, "  size:"
 ]
 	BLNE	BlockMove		; moved down first part

 	MOV	R0, R7			; source of move
 	ADD	R1, R1, R2		; dest of move
 	LDR	LR, [R5, #BigDirEntries]
 	LDR     R2, [R5, #BigDirNamesSize]
 	ADD     R2, R2, #BigDirHeaderSize
d879 3
a881 3
 	ASSERT	BigDirEntrySize=28
 	RSB	LR, LR, LR, LSL #3
 	ADD	R2, R2, LR, LSL #2
d883 2
a884 2
 	ASSERT	BigDirEntrySize=32	;
 	ADD     R2, R2, LR, LSL #5	; entries
d886 5
a890 5
 	LDR	LR, [R5, #BigDirNameLen]
 	ADD	R2, R2, LR
 	ADD	R2, R2, #4
 	BIC	R2, R2, #3
 	ADD	R2, R2, R5
d892 1
a892 1
 	SUBS	R2, R2, R0		; now length
d895 10
a904 10
  	DLINE	"second move:"
  	DREG	R0, "source:"
  	DREG	R1, "  dest:"
  	DREG	R2, "  size:"
 ]
 	BLNE	BlockMove

 	LDR	LR, [R5, #BigDirEntries]
 	SUB	LR, LR, #1
 	STR	LR, [R5, #BigDirEntries]
d907 1
a907 1
 	DREG	LR, "Entries now:"
d910 5
a914 5
 	LDR	LR, [R5, #BigDirNamesSize]
 	SUB	R1, R0, R1
 	SUB	R1, R1, #BigDirEntrySize
 	SUB	LR, LR, R1
 	STR	LR, [R5, #BigDirNamesSize]
d917 1
a917 1
  	DREG	R1, "names reduced by:"
d919 1
a919 1
  	Push	"R4"
d921 7
a927 7
	BL	BigDirFinished
	BEQ	%FT15
	LDR	LR, [R4, #BigDirObNamePtr]
	SUB	LR, LR, R1
	STR	LR, [R4, #BigDirObNamePtr]
	ADD	R4, R4, #BigDirEntrySize
	B	%BT12
d930 1
a930 1
	Pull	"R4"
d933 3
a935 3
 	Pull	"R7"
 	MOV	R0, #0
 	B	%FT95
d960 1
a960 1
 	BVC	%FT01
d1007 1
a1007 1
        LDR     LR, [R1, #DiscSize]
d1023 1
a1023 1
        ; Find the defect list and remove defects*SectorSize bytes from disc size
d1028 1
a1028 1
        LDRB    R1, [R1, #SectorSize]
d1065 1
a1065 1
        LDR     LR, [R1, #DiscSize]
d1070 1
a1070 1
	LDREQ	R0, [R1, #DiscSize2]
d1083 1
a1083 1
        ; Find the defect list and remove defects*SectorSize bytes from disc size
d1088 1
a1088 1
        LDRB    R1, [R1, #SectorSize]
d1096 1
a1096 1
	MOV	R0,#0
d1124 1
a1124 1
 	LDR	R9, [R9, #DrvsFsMapAddr]
d1285 1
a1285 1
        DLINE	"WriteFsMap"
d1325 1
a1325 1
	DebugError "Error in WriteFsMapThenDir "
d1394 2
a1395 2
 	BL	TestBigDir
 	BEQ	%FT50
d1425 10
a1434 10
	BL	WriteBigName	;(R1,R4,R5)
	BL	SetIntAtts	;(R0,R3,R4)
	MOV	R0, R2
	BL	WriteIndDiscAdd	;(R0,R3,R4)
	MOV	R0, R7
	BL	WriteLoad	;(R0,R3,R4)
	MOV	R0, R8
	BL	WriteExec	;(R0,R3,R4)
	MOV	R0, R10
	BL	WriteLen	;(R0,R3,R4)
d1499 2
a1500 2
	MOV	LR, #0
	STR	LR, BufDirDirty
@


4.7
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d73 1
a73 1
 [ T    ; is this the cause of our problems?
d1132 4
a1135 4
        wrhex   R3
        wrhex   R9
        wrhex   R10
        wrhex   R11
d1164 3
a1166 3
        wrhex   R3
        wrhex   R10
        wrhex   R11
d1180 2
a1181 2
        wrhex   R7, NE
        wrhex   R8, NE
d1236 2
a1237 2
        wrhex   R7
        wrhex   R8
d1355 1
a1355 1
        wrhex   R3
@


4.6
log
@  Various archiecture-based optimisations
Detail:
  * ARMv6+ builds use unaligned halfword and word loads and stores (unless
    pre-ARMv6 compatibility is required or NoUnaligned is set)
  * In many cases, one unnecessary BIC instruction has been removed from
    pre-ARMv6 builds
  * ARMv5+ builds (so Tungsten and OMAP) make use of CLZ instruction when
    parsing fragment blocks
Admin:
  Built and included in an OMAP3 ROM. But be warned, this has not received
  the rigorous testing normally required of filesystem code, use at your
  own risk.

Version 3.33. Tagged as 'FileCore-3_33'
@
text
@d17 1
a17 1
        TTL     "Adfs35 - Free space map operations"
@


4.5
log
@Fixed some mrs and msr macros for ObjAsm.

Version 3.30. Tagged as 'FileCore-3_30'
@
text
@d1171 1
a1171 1
        BLNE    Read3
d1175 1
a1175 1
        BLNE    Read3
d1245 1
a1245 1
        BL      Write3
d1252 1
a1252 1
        BL      Write3
@


4.4
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d413 1
a413 1
        msr NE, CPSR_f, #0      ;if not same rounded size return C=0, V=0. Preserves Z
@


4.3
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@a18 21
 [ :LNOT: FileCache

; ===============
; TestDiscPresent
; ===============

;entry R3 top 3 bits disc
;exit if not present V set, R0 result

TestDiscPresent
        Push    "R0-R4,LR"
        MOV     R1, #VerifyOp
        AND     R2, R3, #DiscBits
        MOV     R3, #0
        MOV     R4, #0
        BL      DoDiscOp        ;(R1-R4->R0-R4)
        STRVS   R0, [SP]
        Pull    "R0-R4,PC"

 ]

a65 2
 [ FileCache
  [ WinniesAsFloppies
a124 22
  |
   ; :LNOT: WinniesAsFloppies
        LDRB    R2, Winnies
        MOV     R1, R3, LSR #29
        DiscRecPtr  R5, R1
        CMPS    R1, R2
        BLO     %FT08           ;winnie NE
   [ DebugN
        DLINE   "Pre-processing of floppy"
   ]
        BL      FloppyDiscWriteBehindWait       ;(R3)
        LDRB    R4, Interlocks
        ORR     LR, R4, #FloppyLock
        STRB    LR, Interlocks

        LDRB    LR, FloppyWriteBehindDrive
        TEQS    LR, #&FF
        LDRNEB  R1, [R5, #DiscsDrv]
        BLEQ    LockDisc        ;(R3->R0,R1,V)
        STRVSB  R4, Interlocks
        BVS     %FT99
        TEQS    R0, R0          ;set EQ
a125 34
08
   [ DebugN
        DREG    R2, "Disc ",cc
        DREG    R1, " now assumed locked into drive "
   ]
        ; Winnie and floppy rejoin here with:
        ; R1 = drive
        ; EQ if floppy, otherwise NE
        ASSERT  :INDEX: LockedDrive :MOD: 4 = 0
        ASSERT  LockedDisc-LockedDrive=1
        ASSERT  ModifyDisc-LockedDisc=1
        MOV     R2, R3, LSR #29         ;disc
        ORR     LR, R1, R2, LSL #8      ;OR in locked disc
        ORR     LR, LR, R2, LSL #16     ;OR in modify disc
        STR     LR, LockedDrive
        STREQB  R4, Interlocks
        STR     R5, CritDiscRec
  ]
 |
 ; :LNOT: FileCache
        MOV     R2, R3, LSR #(32-3)     ;disc num
        DiscRecPtr  R5,R2
        STR     R5, CritDiscRec
        LDRB    R0, [R5,#DiscsDrv]
        CMPS    R0, #4                  ;V=0
        BLHS    TestDiscPresent         ;(R3->R0,V)
        BVS     %FT99
        MOV     R0, #Misc_LockDrive
        LDRB    R1, [R5,#DiscsDrv]
        STRB    R1, LockedDrive
        CMPS    R1, #4
        BLHS    Parent_Misc             ;(R0,R1) lock floppies
 ]
 [ Module_Version >= 205
a129 1
 ]
a144 1
 [ NewFs
a180 1
 ]
a231 1
 [ FileCache
a233 1
 ]
a256 1
 [ FileCache
d258 2
a259 1
        Push    "R0-R2,LR"
a268 1
 [ WinniesAsFloppies
d300 2
a301 29
 |
        CMPS    R1, #4
        BLO     %FT10                   ;no need to unlock winnies

        LDRB    R2, Interlocks
        ORR     LR, R2, #FloppyLock
        STRB    LR, Interlocks

        LDRB    LR, FloppyWriteBehindDrive
        TEQS    LR, #&FF

 [ Module_Version >= 205
        BLEQ    UnlockDrive
 |
        MOVEQ   R0, #Misc_UnlockDrive
        BLEQ    Parent_Misc
 ]
        TEQS    R0, R0                  ;set EQ
10
        ASSERT  (:INDEX: LockedDrive) :MOD: 4 = 0       ;word write to be atomic
        ASSERT  LockedDisc - LockedDrive = 1
        ASSERT  ModifyDisc - LockedDisc = 1
        MOV     R0, #-1
        STR     R0, LockedDrive
        STREQB  R2, Interlocks          ;restore interlocks if floppy
 ]
        Pull    "R0-R2,PC",,^

 |
a302 12
        Push    "R0,R1,LR"
        LDRB    R1, LockedDrive
        CMPS    R1, #4
        BLO     %FT10                   ;no need to unlock winnies
        MOV     R0, #Misc_UnlockDrive
        BL      Parent_Misc
10
        MOV     R0, #&FF
        STRB    R0, LockedDrive
        Pull    "R0,R1,PC",,^

 ]
a303 1
 [ WinniesAsFloppies
a306 5
 |
; =================
; EnsureNewFloppyId
; =================
 ]
a314 1
 [ WinniesAsFloppies
a315 3
 |
EnsureNewFloppyId ROUT
 ]
a316 1
  [ WinniesAsFloppies
a318 4
  |
        wrhex   R3
        mess    ,"EnsureNewFloppyId",NL
  ]
a397 1
 [ FileCache
d400 1
a400 2
        Pull    "R0,R1,R3-R4,R7-R11,LR",HI      ;dont reuse shared if not at frag start
        BICHIS  PC, LR, #C_bit :OR: V_bit
d410 1
d412 3
d425 2
a427 1
 ]
a488 1
 [ NewFs
a489 1
 ]
a490 1
 [ NewFs
a492 1
 ]
a528 1
 [ NewFs
a530 1
 ]
d617 7
a623 6
        MOVNE   R10,R0
        MOVNE   R7, R6
        ADDNE   R8, R2, R1
        BLNE    WriteOldFsEntry ;(R3,R7,R8,R10)
        MOVNE   R0, #0
        BNE     %FT95
d626 1
a626 1
        CMPS    R1, R5
a664 1
 [ NewFs
a666 1
 ]
a687 1
 [ NewFs
a720 1
 ]
a792 19
 [ :LNOT: NewFs

; =============
; ReadAllocSize
; =============

; entry R3 top 3 bits disc num
; exit  LR allocation size for this disc

ReadAllocSize
        Push    "R0,LR"
        BL      DiscAddToRec    ;(R3->LR)
        LDRB    LR, [LR,#SectorSize]
        MOV     R0, #1
        MOV     LR, R0, LSL LR
        Pull    "R0,PC",,^

 ]

a967 36
 [ :LNOT: NewFs

; =======
; RoundUp
; =======

; round up file length to next multiple of sector length

; entry:
;  R0 file length
;  R3 top 3 bits disc id

; exit:
;  R0 rounded file length

RoundUp
 [ Debug5
        wrhex   R0
 ]
        Push    "R1,LR"
        BL      DiscAddToRec    ;(R3->LR)
        LDRB    LR, [LR,#SectorSize]
        MOV     R1, #1
        MOV     LR, R1, LSL LR  ;sec size in bytes
        SUB     R1, LR, #1
        TSTS    R0, R1
        BICNE   R0, R0, R1
        ADDNE   R0, R0, LR
 [ Debug5
        wrhex   R0
        mess    ,"RoundUp",NL
 ]
        Pull    "R1,PC",,^

 ]

a980 1
 [ NewFs
a981 3
 |
        BL      InitReadOldFs           ;(R3->R9-R11)
 ]
a982 1
 [ NewFs
a983 3
 |
        BL      NextOldFs               ;(R3,R10,R11->R7,R8,R11,Z)
 ]
d986 1
a986 1
        Pull    "R7-R11,PC",,^
d998 2
a999 2
 [ Module_Version >= 205
        Push    "R0-R2,LR"
d1041 2
a1042 26
        Pull    "R0-R2,PC",,^
 |
        Push    "R0-R2,LR"
        MOV     R0, R3, LSR #(32-3)       ;disc
        DiscRecPtr  R1,R0
        LDRB    R2, Winnies
        CMPS    R2, R0                   ;only defect list for winnies
 [ NewFs
        LDRHIB  LR, [R1,#DiscFlags]
        TSTHIS  LR, #OldMapFlag
 ]
        LDR     LR, [R1,#DiscSize]
        LDRHI   R2, DefectSpace
        ADDHI   R2, SB, R2
        ASSERT  SzDefectList=&200
        ADDHI   R2, R2, R0, LSL #9
        LDRHIB  R1, [R1,#SectorSize]
        MOVHI   R0, #1
        MOVHI   R1, R0, LSL R1
10
        LDRHI   R0, [R2],#4
        RSBHIS  R0, R0, #1 :SHL: 29
        SUBHI   LR, LR, R1
        BHI     %BT10
        Pull    "R0-R2,PC",,^
 ]
d1056 2
a1057 2
 [ Module_Version >= 205
        Push    "R1-R2,LR"
d1102 2
a1103 26
        Pull    "R1-R2,PC",,^
 |
        Push    "R0-R2,LR"
        MOV     R0, R3, LSR #(32-3)       ;disc
        DiscRecPtr  R1,R0
        LDRB    R2, Winnies
        CMPS    R2, R0                   ;only defect list for winnies
 [ NewFs
        LDRHIB  LR, [R1,#DiscFlags]
        TSTHIS  LR, #OldMapFlag
 ]
        LDR     LR, [R1,#DiscSize]
        LDRHI   R2, DefectSpace
        ADDHI   R2, SB, R2
        ASSERT  SzDefectList=&200
        ADDHI   R2, R2, R0, LSL #9
        LDRHIB  R1, [R1,#SectorSize]
        MOVHI   R0, #1
        MOVHI   R1, R0, LSL R1
10
        LDRHI   R0, [R2],#4
        RSBHIS  R0, R0, #1 :SHL: 29
        SUBHI   LR, LR, R1
        BHI     %BT10
        Pull    "R0-R2,PC",,^
 ]
d1138 1
a1138 1
        MOVS    PC,LR
d1202 2
a1203 1
        Push    "R0-R2,LR"
d1218 2
a1219 1
        Pull    "R0-R2,PC",,^
d1253 1
a1253 1
        Pull    "R0,R1,PC",,^
d1276 1
a1276 1
        Pull    "R0-R2,PC",,^
d1370 1
a1370 1
        Pull    "R3,PC",,^
d1391 2
a1392 1
        Push    "R0,R11,LR"
a1413 1
 [ Module_Version >= 205
a1414 3
 |
        BL      WriteLoad       ;(R0,R4)
 ]
d1420 2
a1421 1
        Pull    "R0,R11,PC",,^
d1435 2
a1436 1
        Pull    "R0,R11,PC",,^
d1450 2
a1451 1
        Push    "R0-R2,R4,LR"
d1463 2
a1464 1
        Pull    "R0-R2,R4,PC",,^
d1472 2
a1473 1
        Push    "LR"
d1479 2
a1480 1
        Pull    "PC",,^
d1502 2
a1503 1
        Pull    "PC",,^
d1521 2
a1522 1
        Push    "R0-R6,LR"
d1526 1
a1526 1
        MOV     r2, #ARM_CC_Mask                ; Just in case
d1590 2
a1591 1
        Pull    "r0-r6"
d1608 2
a1609 1
        Push    "r0-r2, lr"
d1614 2
a1615 1
        Pull    "r0-r2"
@


4.2
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d213 7
d224 1
d234 4
d244 5
d251 1
d263 4
d268 1
d278 5
d285 1
d293 3
d297 1
d304 5
d311 1
d814 1
a814 1
 [ Debug5
d928 1
a928 1
 [ Debug5
d965 5
a969 5
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        mess    ,"enter RemoveDirEntryOnly",NL
d988 2
a989 2
        wrhex   R4
        mess    ,"enter RemoveDirEntry",NL
d1007 95
a1115 1

d1124 4
a1127 2
        wrhex   R0, VS
        mess    ,"leave RemoveDirEntry(Only)",NL
d1379 3
d1384 1
d1517 3
d1522 1
d1539 1
a1539 1
        mess    ,"WriteFsMap",NL
d1555 1
a1555 1
        mess    ,"WriteDirThenFsMap",NL
d1570 2
a1571 2
 [ Debug5
        mess    ,"WriteFsMapThenDir",NL
d1578 3
d1583 16
d1615 5
d1623 1
d1646 4
d1679 14
d1748 5
@


4.1
log
@Initial revision
@
text
@d204 1
a204 1
 [ Version >= 205
d357 1
a357 1
 [ Version >= 205
d1071 1
a1071 1
 [ Version >= 205
d1153 1
a1153 1
 [ Version >= 205
d1495 1
a1495 1
 [ Version >= 205
@


4.1.4.1
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@a225 4
 [ BigMaps
        LDRB	R0, [R5, #Zones2]
        ADD	R2, R2, R0, LSL #8
 ]
@


4.1.4.2
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@d779 1
a779 1
 [ Debug5 :LOR: DebugX
d893 1
a893 1
 [ Debug5 :LOR: DebugX
a971 86
 [ BigDir
 	BL	TestBigDir
 	BNE	%FT90
 	Push	"R7"
 	
 	BL	InvalidateBufDir
 	; if it's a big dir, we do two moves - first before bit, then the after
 	
 [ DebugX
 	LDR	LR, [R5, #BigDirEntries]
 	DREG	LR, "entries:"
 ]
 	
 	BL	GetBigDirName		; (R4,R5->LR)
 	LDR	R7, [R4, #BigDirObNameLen]	; length of name
 	ADD	R7, R7, LR
 	ADD	R7, R7, #3
 	BIC	R7, R7, #3		; bit after name
 	SUB	LR, LR, #BigDirHeapObName
 	ADD	R0, R4, #BigDirEntrySize; source
 	MOV	R1, R4			;
 	SUBS	R2, LR, R0		; size of move
 	
 [ DebugX
  	DLINE	"first move:"
  	DREG	R0, "source:"
  	DREG	R1, "  dest:"
  	DREG	R2, "  size:"
 ]
 	BLNE	BlockMove		; moved down first part
 	
 	MOV	R0, R7			; source of move
 	ADD	R1, R1, R2		; dest of move
 	LDR	LR, [R5, #BigDirEntries]
 	LDR     R2, [R5, #BigDirNamesSize]
 	ADD     R2, R2, #BigDirHeaderSize
 	ASSERT	BigDirEntrySize=32	; 
 	ADD     R2, R2, LR, LSL #5	; entries
 	LDR	LR, [R5, #BigDirNameLen]
 	ADD	R2, R2, LR
 	ADD	R2, R2, #3
 	BIC	R2, R2, #3
 	ADD	R2, R2, R5
 	
 	SUBS	R2, R2, R0		; now length
 	
 [ DebugX
  	DLINE	"second move:"
  	DREG	R0, "source:"
  	DREG	R1, "  dest:"
  	DREG	R2, "  size:"
 ]
 	BLNE	BlockMove
 	
 	LDR	LR, [R5, #BigDirEntries]
 	SUB	LR, LR, #1
 	STR	LR, [R5, #BigDirEntries]
 
 [ DebugX
 	DREG	LR, "Entries now:"
 ]
 	
 	LDR	LR, [R5, #BigDirNamesSize]
 	SUB	R1, R0, R1
 	SUB	R1, R1, #BigDirEntrySize
 	SUB	LR, LR, R1
 	STR	LR, [R5, #BigDirNamesSize]
 
  [ DebugX
  	DREG	R1, "names reduced by:"
  ]
10
	BL	BigDirFinished
	BEQ	%FT20
	LDR	LR, [R4, #BigDirObNamePtr]
	SUB	LR, LR, R1
	STR	LR, [R4, #BigDirObNamePtr]
	ADD	R4, R4, #BigDirEntrySize
	B	%BT10
	
20
 	Pull	"R7"
 	MOV	R0, #0
 	B	%FT95
90
 ]
d986 1
d1400 1
a1400 1
        DLINE	"WriteFsMap"
d1416 1
a1416 1
        DLINE   "WriteDirThenFsMap"
d1432 1
a1432 1
        DLINE   "WriteFsMapThenDir"
a1481 4
 [ BigDir
 	BL	TestBigDir
 	BEQ	%FT50
 ]
a1510 14
 [ BigDir
50
	BL	WriteBigName	;(R1,R4,R5)
	BL	SetIntAtts	;(R0,R3,R4)
	MOV	R0, R2
	BL	WriteIndDiscAdd	;(R0,R3,R4)
	MOV	R0, R7
	BL	WriteLoad	;(R0,R3,R4)
	MOV	R0, R8
	BL	WriteExec	;(R0,R3,R4)
	MOV	R0, R10
	BL	WriteLen	;(R0,R3,R4)
        Pull    "R0,R11,PC",,^
 ]
@


4.1.4.3
log
@Altered directory format (change backup dir entries to be one word instead
of an entire copy of the entry).  Also reduced size of a directory entry
by one word.  Also fixed a number of small bugs.
@
text
@d930 5
a934 5
        DREG    R3, "", cc
        DREG    R4, " ", cc
        DREG    R5, " ", cc
        DREG    R6, " ", cc
        DLINE   "enter RemoveDirEntryOnly"
d953 2
a954 2
        DREG    R4, " ",cc
        DLINE   "enter RemoveDirEntry"
d988 1
a988 1
 	ADD	R7, R7, #4
d990 1
a1007 5
 [ BigDirFix
 	ASSERT	BigDirEntrySize=28
 	RSB	LR, LR, LR, LSL #3
 	ADD	R2, R2, LR, LSL #2
 |
a1009 1
 ]
d1012 1
a1012 1
 	ADD	R2, R2, #4
d1043 1
a1043 2
  	Push	"R4"
12
d1045 1
a1045 1
	BEQ	%FT15
d1050 1
a1050 4
	B	%BT12

15
	Pull	"R4"
d1080 2
a1081 4
 	BVC	%FT01
        DREG    R0, " ",cc
01
        DLINE   "leave RemoveDirEntry(Only)"
@


4.1.4.4
log
@Fixed s.BigDirCode (GrowBigDir and ShrinkBigDir) to cope with BitSize<SecSize
and rewrote free space map memory management to place free space maps in
dynamic areas.
@
text
@a212 7
 [ DynamicMaps
        LDR     LR, [R6,#DrvsFsMapFlags]
        TSTS    LR, #BadFs
        MOVNE   R0, #BadFsMapErr
        BNE     %FT94
        LDR	R8, [R6, #DrvsFsMapAddr]
 |
a216 1
 ]
a235 5
 [ DynamicMaps
 	LDRNE	LR, [R6, #DrvsFsMapFlags]
        ORRNE   LR, LR, #BadFs
        STRNE   LR, [R6,#DrvsFsMapFlags]
 |
a237 1
 ]
a248 4
 [ DynamicMaps
 	LDR	LR, [R6, #DrvsFsMapFlags]
 	TSTS	LR, #EmptyFs
 |
a249 1
 ]
a258 5
 [ DynamicMaps
 	LDR	LR, [R6, #DrvsFsMapFlags]
        ORRVS   LR, LR, #BadFs
        STRVS   LR, [R6,#DrvsFsMapFlags]
 |
a260 1
 ]
a267 3
 [ DynamicMaps
 	MOV	R3, R8
 |
a268 1
 ]
a274 5
  [ DynamicMaps
  	LDRVC	LR, [R6, #DrvsFsMapFlags]
  	BICVC	LR, LR, #NewHiFsBits
  	STRVC	LR, [R6, #DrvsFsMapFlags]
  |
a276 1
  ]
a1343 3
 [ DynamicMaps
 	LDR	R9, [R9, #DrvsFsMapAddr]
 |
a1345 1
 ]
a1477 3
 [ DynamicMaps
        LDR     R0, [LR,#DrvsFsMapAddr]
 |
a1479 1
 ]
a1552 5
 [ DynamicMaps
        LDR     R3,[LR,#DrvsFsMapFlags]
        ORR     R3,R3,#EmptyFs
        STR     R3,[LR,#DrvsFsMapFlags]
 |
a1555 1
 ]
@


4.1.4.5
log
@Fixed:

DoOsFunRenameBigDir to work when renaming a shared file between dirs where
the file ends up as the last object in the target dir.

SanityCheckEDiscRecord to allow idlen>15 when DiscVersion=0

GrowBigDir to round up desired size to a multiple of the disc allocation
size.

Also:

Implemented non-working code to write cache the dir buffer.  WriteCacheDir
compile switch set to FALSE in s.DebugOpts.  Don't set it to TRUE unless
I tell you it's working.

Made SortDir not attempt to sort more than 2047 entries in a dir, to
avoid it overflowing ScratchSpace.

Made SortPair do one extra shell on the sort (makes it more efficient).
@
text
@d1011 1
a1011 1

d1014 1
a1014 1

d1019 1
a1019 1

d1028 1
a1028 1

d1036 1
a1036 1

d1047 1
a1047 1
 	ASSERT	BigDirEntrySize=32	;
d1055 1
a1055 1

d1057 1
a1057 1

d1065 1
a1065 1

d1069 1
a1069 1

d1073 1
a1073 1

d1079 1
a1079 1

d1095 1
a1095 1

a1579 16
 [ WriteCacheDir
; ======================
; WriteFsMapThenMaybeDir
; ======================

WriteFsMapThenMaybeDir ROUT
 [ Debug5
        DLINE   "WriteFsMapThenMaybeDir"
 ]
        Push    "R0-R11,LR"
        BL      DisableBreak
        BL      CriticalWriteFsMapThenMaybeDir
        BL      RestoreBreak
        STRVS   R0,[SP]
        Pull    "R0-R11,PC"
 ]
a1728 5

 [ WriteCacheDir
	MOV	LR, #0
	STR	LR, BufDirDirty
 ]
@


4.1.4.6
log
@Fixed 4 bugs in DoOsFunRenameBigDir involving renameing of objects
between dirs with long filenames.

Fixed bug in OsFunResolveWildcard on long filenames.
@
text
@d1570 1
a1570 1
 [ Debug5 ;:LOR: DebugXr
a1577 3
 [ DebugXr :LAND: {FALSE}
	DebugError "Error in WriteFsMapThenDir "
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

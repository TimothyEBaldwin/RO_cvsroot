head	4.14;
access;
symbols
	FileCore-3_75:4.14
	FileCore-3_74:4.13
	FileCore-3_73:4.12
	FileCore-3_72:4.12
	FileCore-3_71:4.11
	FileCore-3_70:4.11
	FileCore-3_69:4.11
	FileCore-3_68:4.10
	FileCore-3_67:4.10
	FileCore-3_66:4.10
	FileCore-3_65:4.9
	FileCore-3_64:4.9
	FileCore-3_63:4.9
	FileCore-3_62:4.9
	FileCore-3_61:4.9
	FileCore-3_60:4.9
	FileCore-3_59:4.9
	FileCore-3_58:4.9
	FileCore-3_57:4.9
	FileCore-3_56:4.8
	FileCore-3_55:4.7
	FileCore-3_54:4.6
	FileCore-3_53:4.6
	FileCore-3_52:4.6
	FileCore-3_51:4.6
	FileCore-3_50:4.6
	FileCore-3_49:4.6
	FileCore-3_48:4.5
	FileCore-3_47:4.5
	FileCore-3_46:4.5
	FileCore-3_45:4.5
	FileCore-3_44:4.4
	FileCore-3_43:4.4
	FileCore-3_42:4.4
	FileCore-3_41:4.3
	FileCore-3_40:4.3
	FileCore-3_39:4.3
	FileCore-3_38:4.3
	FileCore-3_37:4.3
	FileCore-3_36:4.3
	FileCore-3_35:4.3
	FileCore-3_34:4.3
	FileCore-3_33:4.2
	RO_5_07:4.2
	FileCore-3_32:4.2
	FileCore-3_31:4.2
	FileCore-3_30:4.2
	FileCore-3_29:4.2
	FileCore-3_28:4.2
	FileCore-3_25-4_9_2_2:4.2
	FileCore-3_27:4.2
	FileCore-3_26:4.2
	FileCore-3_22-4_6_2_1:4.1
	bavison_FileCore-3_22_dev_bp:4.1
	bavison_FileCore-3_22:4.1.0.2
	FileCore-3_25-4_9_2_1:4.2
	HAL:4.2.0.2
	FileCore-3_25:4.2
	FileCore-3_24:4.2
	FileCore-3_23:4.2
	dellis_autobuild_BaseSW:4.1
	FileCore-3_22:4.1
	dcotton_autobuild_BaseSW:4.2
	Ursula_merge:1.1.2.14
	ROL_merge:1.1.2.13.2.1
	FileCore-3_21:4.1
	ROL_Ursula_merge:1.1.2.13.2.1
	Ursula_RiscPC_merge:1.1.2.12
	ROL_FileCore-3_21:1.1.2.13.2.1
	ROL_FileCore-3_20:1.1.2.13.2.1
	ROL:1.1.2.13.0.2
	ROL_bp:1.1.2.13
	Ursula_RiscPC_bp:1.1.2.12
	FileCore-3_18:1.1.2.13
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.2.12
	Ursula_RiscPC:1.1.2.12.0.2
	aglover_FileCore-3_17:1.1.2.13
	sproven_FileCore-3_16:1.1.2.13
	rthornb_UrsulaBuild-19Aug1998:1.1.2.12
	UrsulaBuild_FinalSoftload:1.1.2.12
	rthornb_UrsulaBuild-12Aug1998:1.1.2.12
	aglover_UrsulaBuild-05Aug1998:1.1.2.12
	rthornb_UrsulaBuild-29Jul1998:1.1.2.12
	rthornb_UrsulaBuild-22Jul1998:1.1.2.12
	rthornb_UrsulaBuild-15Jul1998:1.1.2.12
	rthornb_UrsulaBuild-07Jul1998:1.1.2.12
	rthornb_UrsulaBuild-17Jun1998:1.1.2.12
	rthornb_UrsulaBuild-03Jun1998:1.1.2.12
	rthornb_UrsulaBuild-27May1998:1.1.2.12
	rthornb_UrsulaBuild-21May1998:1.1.2.12
	sproven_FileCore-3_15:1.1.2.12
	sproven_314:1.1.2.12
	rthornb_UrsulaBuild_01May1998:1.1.2.11
	sproven_313:1.1.2.11
	sproven_3_11:1.1.2.10
	sproven_3_10:1.1.2.10
	sproven_Ursula_3_09:1.1.2.9
	sproven_3_07:1.1.2.7
	sproven_3_06:1.1.2.6
	sproven_3_05:1.1.2.5
	sproven_3_04:1.1.2.4
	sproven_3_03:1.1.2.3
	sproven_3_02:1.1.2.2
	sproven_3_01:1.1.2.1
	Ursula:1.1.0.2;
locks; strict;
comment	@# @;


4.14
date	2017.07.06.14.19.16;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	8jE9i1ldP8DSXaYz;

4.13
date	2017.06.16.11.00.36;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	izYr8Uu33U8FvAVz;

4.12
date	2017.04.09.22.17.12;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	0hBpFTzNopSirUMz;

4.11
date	2016.05.08.16.55.17;	author jlee;	state Exp;
branches;
next	4.10;
commitid	7NNp0vqkWUkusH5z;

4.10
date	2015.03.28.20.30.47;	author jlee;	state Exp;
branches;
next	4.9;
commitid	zES7Bir23rCvJpfy;

4.9
date	2013.03.25.20.31.06;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	vCGDXb1zgPQnidJw;

4.8
date	2013.02.24.21.09.14;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	rgJG8ZFRF8o9ruFw;

4.7
date	2013.02.21.16.53.05;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	CCuV2tngKttj75Fw;

4.6
date	2012.03.24.10.51.29;	author jlee;	state Exp;
branches;
next	4.5;
commitid	yHV7AVt5Cxp0R7Yv;

4.5
date	2011.10.14.07.23.50;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	D2Id4aPp4zmuUhDv;

4.4
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	A9Zxco9ydo9FCOBv;

4.3
date	2009.06.15.23.25.34;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	2000.05.09.11.36.48;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	97.09.16.14.46.32;	author sproven;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	97.09.16.14.46.33;	author sproven;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.11.17.13.32.14;	author sproven;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	97.12.01.12.02.55;	author sproven;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	97.12.11.23.21.31;	author sproven;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	98.01.09.11.44.53;	author sproven;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	98.01.19.12.26.29;	author sproven;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	98.01.23.16.41.14;	author sproven;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	98.01.30.17.53.03;	author sproven;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	98.02.11.16.49.08;	author sproven;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	98.02.17.14.59.35;	author sproven;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	98.04.16.15.26.31;	author sproven;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	98.05.07.16.58.04;	author sproven;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	98.09.02.16.14.44;	author sproven;	state Exp;
branches
	1.1.2.13.2.1;
next	1.1.2.14;

1.1.2.14
date	2000.05.09.10.55.17;	author sbrodie;	state Exp;
branches;
next	;

1.1.2.13.2.1
date	99.08.24.12.41.15;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Comments improved
@
text
@; Copyright 1997 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; BigDirCode

        TTL     "Big directory support code"
 [ BigDir

; ==========
; TestBigDir
; ==========

; test for long filenames on this disc

; entry: R3=disc address

; exit  Z=1 <=> big directories, C,V preserved, LR->disc rec

TestBigDir ROUT
        Push    "R0,LR"
        BL      DiscAddToRec            ;(R3->LR)
        LDRB    R0, [LR,#DiscRecord_BigDir_DiscVersion]
        TEQS    R0, #1
 [ DebugX :LAND: {FALSE}
        BNE     %FT01
        DLINE   " big dir ",cc
        B       %FT02
01
        DLINE   " not big dir ",cc
02
 ]
        Pull    "R0,PC"

; =======================
; SanityCheckBigDirHeader
; =======================

; checks that a big directory's header is acceptable.

; used by FindDir to ensure that a directory seems ok-ish
; before going any further, to avoid nasty crash-type
; situations caused by stupid values appearing.

; checks:

; 1) that BigDirStartName is correct
; 2) that BigDirVersion is 0
; 3) that the size of the directory is a multiple of NewDirSize

; any other checks are left until the entire directory is read

; entry:

;   R5 points to the directory's header

; exit:

;   if error, R0 result, V set

SBProven
 = "SBPr"
 = "oven"


SanityCheckBigDirHeader ROUT
        Push    "R0,R1,LR"

 [ DebugX
        DLINE   ">SanityCheckBigDirHeader"
 ]

 [ DebugXd
        ADD     lr, r5, #BigDirName
        DSTRING lr, "sanity check; name: "
 ]

        LDR     r1, SBProven                    ; get "SBPr"
        LDR     lr, [r5, #BigDirStartName]      ; and get StartName from Dir
        TEQS    r1,lr                           ; is it broke?
 [ DebugX
        BEQ     %FT01
        DLINE   "Failed at BigDirStartMasSeq"
01
 ]
        BNE     %FT95

        ASSERT  (BigDirVersion:MOD:4)=1
        LDR     lr, [r5, #BigDirVersion-1]
        BICS    lr, lr, #255

 [ DebugX
        BEQ     %FT01
        DLINE   "Failed at BigDirVersion"
01
 ]
        BNE     %FT95

        LDR     lr, [r5, #BigDirSize]
        MOVS    r1, lr, LSL #21         ; bottom 11 bits must be clear

 [ DebugX
        BEQ     %FT01
        DLINE   "Failed at BigDirSize not multiple of 2048"
01
 ]
        BNE     %FT95

        ASSERT  BigDirMaxSize = 1:SHL:22
        SUB     r1, lr, #1              ; can be equal to BigDirMaxSize though
        MOVS    r1, r1, LSR #22

 [ DebugX
        BEQ     %FT01
        DLINE   "Failed at BigDirSize too large (or zero)"
01
 ]

95
        MOVNE   R0, #BrokenDirErr
        MOVEQ   R0, #0
        BL      SetVOnR0
        STRVS   R0, [SP]
 [ DebugX
        DLINE   "<SanityCheckBigDirHeader"
 ]
        Pull    "R0,R1,PC"

; ===========
; CheckBigDir
; ===========

; Check dir is well formed

; entry: R3=dir disc add, R5->dir start, R6->dir end, R10 0 -> don't check the check
; bytes, R10=1-> do check it

; exit:  IF error V set, R0 result

CheckBigDir ROUT
        Push    "R0,R1,R10,R11,LR"
 [ DebugX
        DLINE   ">CheckBigDir"
 ]

 [ DebugX
        LDR     R1, [R5, #BigDirNameLen]
        DREG    R1, "dir's name length is:"
 ]

        baddr   R1, SBProven
        LDMIA   R1, {R1, R11}

        LDR     LR, [R5, #BigDirStartName]

        TEQS    LR, R1                          ; is the StartName Ok?

 [ DebugX
        BEQ     %FT01
        DLINE   "Failed at SBPr"
01
 ]
        LDREQB  R0, [R5,#BigDirStartMasSeq]
        LDREQB  LR, [R6,#BigDirEndMasSeq]
        TEQS    R0, LR

 [ DebugX
        BEQ     %FT01
        DLINE   "Failed at sequences"
01
 ]
        LDREQ   LR, [R6, #BigDirEndName]
        TEQEQS  LR, R11

 [ DebugX
        BEQ     %FT01
        DLINE   "Failed at endname"
        DREG    LR, "End name read was:"
01
 ]
        MOV     R0, #0
        BNE     %FT90

        MOVS    R10,R10                 ;quick flag
        BLNE    TestDirCheckByte        ;(R3,R5,R6->LR,Z)

90
        BEQ     %FT95
 [ DebugX
        DLINE   "Big dir broken"
 ]
        MOV     R0, #BrokenDirErr
        LDR     LR, BufDir
        TEQS    LR, R3
        BLEQ    InvalidateBufDir
        BEQ     %FT95
        BL      TryCache                ;(R3->R11,V)
        BLVC    InvalidateDirCache      ;if a dir in cache is broken, scrap whole cache
95
        BL      SetVOnR0
        STRVS   R0, [SP]

 [ DebugX
        DLINE   "<CheckBigDir"
 ]
        Pull    "R0,R1,R10,R11,PC"

; ===================
; TestBigDirCheckByte
; ===================

; entry
;  R3 ind disc add of dir
;  R5 -> dir start
;  R6 -> dir end

; exit
;  LR check byte
;  Z  set if matches existing byte

TestBigDirCheckByte     ROUT
        Push    "R0-R2,R5,R7,LR"

 [ DebugX
        DLINE   ">TestBigDirCheckByte"
        DREG    R5, "dir at:"
 ]

; first, work out the size of the first area to accumulate

        MOV     R2,#0   ; zero the acc.

        LDR     R0, [R5, #BigDirNameLen]

        ADD     R0, R0, #4
        BIC     R0, R0, #3                      ; name len

        LDR     R1, [R5, #BigDirEntries]        ; number of entries

        ASSERT  BigDirEntrySize=28
        RSB     R1, R1, R1, LSL #3              ; *7
        ADD     R0, R0, R1, LSL #2              ; 7*4=28

        LDR     R1, [R5,#BigDirNamesSize]       ; size of the heap of names

        ADD     R0, R0, R1

        ADD     R0, R0, #BigDirHeaderSize

 [ DebugX
        DREG    R0, "bytes to check:"
 ]

        ADD     R0, R0, R5                      ; now R0 points to first word after names

10
        LDR     LR, [R5], #4
        EOR     R2, LR, R2, ROR #13
        TEQS    R5, R0
        BNE     %BT10

; now the tail
        ADD     R5, R6, #BigDirEndName
        LDR     LR, [R5], #4
        EOR     R2, LR, R2, ROR #13
        SUB     R0, R6, #1

        ASSERT  BigDirCheckByte=-1

20
        LDRB    LR, [R5], #1
        EOR     R2, LR, R2, ROR #13
        TEQS    R5, R0
        BNE     %BT20

        EOR     R2, R2, R2, LSR #16     ;reduce to 8 bits
        EOR     R2, R2, R2, LSR #8
        AND     R2, R2, #&FF

        LDRB    LR, [R6,#BigDirCheckByte]
        TEQS    R2, LR
 [ DebugX
        DREG    LR, "check byte"
        DREG    R2, "value:"
 ]
        MOV     LR, R2

 [ DebugX
        DLINE   "<TestBigDirCheckByte"
 ]

        Pull    "R0-R2,R5,R7,PC"

; =================
; ReadBigDirEntries
; =================

; entry:

; R3 indirect disc addr of dir
; R5 pointer to big dir
; R7 buffer ptr
; R8 number of names to transfer
; R9 offset in dir
; R10 buffer end
; R11 fsfunc reason code

; exit:

; R5=number of names transferred
; R9=new offset

; all other regs may be corrupted except R12, R13

; while running;

; R4=pointer to current entry

ReadBigDirEntries       ROUT
        Push    "R0,R1,R2,R9,lr"
 [ DebugX
        DLINE   ">ReadBigDirEntries"
 ]
        LDR     r1, [r5, #BigDirEntries]        ; get the number of entries in the dir
 [ DebugX
        DREG    r1, "dir entries:"
        DREG    r9, "index value:"
 ]
        CMP     r9, r1                  ; check if offset too large
        MOVHS   r9, #-1
        MOVHS   R5, #0
        BHS     %FT95                   ; nothing transferred

; this still to be implemented!

; common set-up code

        BL      GetDirFirstEntry        ; (R3,R5->R4)

        ASSERT  BigDirEntrySize=28
        RSB     LR, R9, R9, LSL #3      ; *7
        ADD     R4, R4, LR, LSL #2      ; 7*4=28

        TEQS    R11, #fsfunc_ReadDirEntriesInfo
        BEQ     %FT20

        TEQS    R11, #fsfunc_ReadDirEntries
        BEQ     %FT40

        TEQS    R11, #fsfunc_CatalogObjects
        BEQ     %FT60

        B       %FT95

20
        ADD     R7, R7, #3      ; word align it
        BIC     R7, R7, #3
        SUB     LR, R10, R7
        LDR     R0, [R4, #BigDirObNameLen]
 [ DebugX
        DREG    R0, "name length:"
 ]
        ADD     R0, R0, #&15+3
        BIC     R0, R0, #3
        CMPS    R0, LR                  ; space for entry?
 [ DebugX
        DREG    LR, "space in buffer:"
        DREG    R0, "space for entry:"
        BLS     %FT01
        DLINE   "Buffer overflowed"
01
 ]
        BHI     %FT25                   ; no space!

; have space for entry
        BL      ReadIntAtts     ;(R3,R4->LR)
        TSTS    LR, #DirBit
        MOVEQ   R0, #1
        MOVNE   R0, #2
        BL      ReadLoad        ;(R3,R4->LR)
        STR     LR, [R7],#4
        BL      ReadExec        ;(R4->LR)
        STR     LR, [R7],#4
        BL      ReadLen         ;(R3,R4->LR)
        STR     LR, [R7],#4
        BL      ReadExtAtts     ;(R3,R4->LR)
        STR     LR, [R7],#4
        STR     R0, [R7],#4     ;atts

        LDR     R6, [R4, #BigDirObNameLen]
        Push    "R4"
        BL      GetBigDirName   ;(R5,R6->LR)
        MOV     R4, LR
 [ DebugX :LOR: DebugXd
        DSTRING R4, "name:"
 ]
        BL      PutStringToBuf  ;write the string to the buffer
        Pull    "R4"
        BLCC    Put0ToBuf

        BCS     %FT25           ; buffer full

        ADD     R9, R9, #1
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
        BEQ     %FT30

        SUBS    R8, R8, #1
        BGT     %BT20

; finished count of entries to extract, but not finished dir

25
; here when buffer full or nothing left to do
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUB     R5, R9, R8              ; number of names transferred
        B       %FT95                   ; and exit

30
; end of dir
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUBS    R5, R9, R8              ; number of names transferred
        MOVEQ   R9, #-1                 ; finished
        B       %FT95                   ; and exit

40
        SUB     LR, R10, R7
        LDR     R0, [R4, #BigDirObNameLen]
        ADD     R0, R0, #1
        CMPS    R0, LR                  ; space for entry?
 [ DebugX
        BLS     %FT01
        DLINE   "Buffer overflowed"
01
 ]
        BHI     %FT45                   ; no space!

        LDR     R6, [R4, #BigDirObNameLen]
        Push    "R4"
        BL      GetBigDirName   ;(R5,R6->LR)
        MOV     R4, LR
 [ DebugX :LOR: DebugXd
        DSTRING R4, "name:"
 ]
        BL      PutStringToBuf  ;write the string to the buffer
        Pull    "R4"
        BLCC    Put0ToBuf

        BCS     %FT45           ; buffer full

        ADD     R9, R9, #1
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
        BEQ     %FT50

        SUBS    R8, R8, #1
        BGT     %BT40

; finished count of entries to extract, but not finished dir

45
; here when buffer full or nothing left to do
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUB     R5, R9, R8              ; number of names transferred
        B       %FT95                   ; and exit

50
; end of dir
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUBS    R5, R9, R8              ; number of names transferred
        MOVEQ   R9, #-1                 ; finished
        B       %FT95                   ; and exit


60 ; CatalogObjects
        ADD     R7, R7, #3      ; word align it
        BIC     R7, R7, #3
        SUB     LR, R10, R7
        LDR     R0, [R4, #BigDirObNameLen]
 [ DebugX
        DREG    R0, "name length:"
 ]
        ADD     R0, R0, #&1E+3
        BIC     R0, R0, #3
        CMPS    R0, LR                  ; space for entry?
 [ DebugX
        DREG    LR, "space in buffer:"
        DREG    R0, "space for entry:"
        BLS     %FT01
        DLINE   "Buffer overflowed"
01
 ]
        BHI     %FT65                   ; no space!

; have space for entry
        BL      ReadIntAtts     ;(R3,R4->LR)
        TSTS    LR, #DirBit
        MOVEQ   R0, #1
        MOVNE   R0, #2
        BL      ReadLoad        ;(R3,R4->LR)
        STR     LR, [R7],#4
        CMNS    LR, #1 :SHL: 20 ;C=1 <=> stamped
        ANDCS   R1, LR, #&FF
        MOVCC   R1, #0
        BL      ReadExec        ;(R4->LR)
        MOVCS   R2, LR
        MOVCC   R2, #0
        STR     LR, [R7],#4
        BL      ReadLen         ;(R3,R4->LR)
        STR     LR, [R7],#4
        BL      ReadExtAtts     ;(R3,R4->LR)
        STR     LR, [R7],#4
        STR     R0, [R7],#4     ;atts
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        BIC     LR, LR, #DiscBits
        STR     LR, [R7], #4
        STR     R2, [R7], #4
        STRB    R1, [R7], #1

        LDR     R6, [R4, #BigDirObNameLen]
        Push    "R4"
        BL      GetBigDirName   ;(R5,R6->LR)
        MOV     R4, LR
 [ DebugX :LOR: DebugXd
        DSTRING R4, "name:"
 ]
        BL      PutStringToBuf  ;write the string to the buffer
        Pull    "R4"
        BLCC    Put0ToBuf

        BCS     %FT65           ; buffer full

        ADD     R9, R9, #1
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
        BEQ     %FT70

        SUBS    R8, R8, #1
        BGT     %BT60

; finished count of entries to extract, but not finished dir

65
; here when buffer full or nothing left to do
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUB     R5, R9, R8              ; number of names transferred
        B       %FT95                   ; and exit

70
; end of dir
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUBS    R5, R9, R8              ; number of names transferred
        MOVEQ   R9, #-1                 ; finished
        B       %FT95                   ; and exit


95
        STR     r9, [sp,#3*4]
 [ DebugX
        DLINE   "<ReadBigDirEntries"
 ]
        Pull    "r0,r1,r2,r9,pc"


; ==============
; BigDirFinished
; ==============

; entry:

; R5=pointer to dir
; R4=dir entry ptr

; exit:

; EQ if entry is beyond end of entries, LR=entries in dir

BigDirFinished ROUT
        Push    "R4,R6,LR"
 [ DebugX :LAND: {FALSE}
        DLINE   ">BigDirFinished"
        DREG    R5, "dir at:"
        DREG    R4, "entry at:"
 ]
        LDR     R6, [R5, #BigDirNameLen]
        ADD     R6, R6, #4
        BIC     R6, R6, #3

        LDR     LR, [R5, #BigDirEntries]

        ASSERT  BigDirEntrySize=28
        ADD     R6, R6, LR, LSL #5      ; *32
        SUB     R6, R6, LR, LSL #2      ; *(32-4)=*28

        ADD     R6, R6, R5
        ADD     R6, R6, #BigDirHeaderSize       ; now points to header

 [ DebugX
        DREG    R6, "end of entries:"
 ]
        CMPS    R4, R6
        MOVHI   R4, R6
        TEQS    R4, R6

        Pull    "R4,R6,PC"

; =============
; GetBigDirName
; =============

; entry: R5=dir start, R4=pointer to entry

; exit: LR=pointer to name (NOT header)

; if entry is after end of entries, returns pointer to what would
; be name after name heap

GetBigDirName ROUT
        Push    "R5,R6,R7,R8,LR"
        SavePSR R8

        BL      BigDirFinished                  ; is it finished
        LDREQ   R7, [R5, #BigDirNamesSize]      ; size of names heap

        LDR     LR, [R5, #BigDirNameLen]
        LDR     R6, [R5, #BigDirEntries]
        ADD     LR, LR, #4
        BIC     LR, LR, #3
        ADD     R5, R5, LR
        ADD     R5, R5, #BigDirHeaderSize

; R5 now points at entries

        ASSERT  BigDirEntrySize=28
        RSB     LR, R6, R6, LSL #3
        ADD     R6, R5, LR, LSL #2

        LDRNE   R5, [R4, #BigDirObNamePtr]      ; offset into name heap
        ADDNE   LR, R5, R6
        ADDEQ   LR, R7, R6                      ; end of name heap

; [ DebugXd
;       DREG    LR, "name ptr:"
; ]

        RestPSR R8,,f
        Pull    "R5,R6,R7,R8,PC"

; =================
; ReadBigDirIntAtts
; =================

; entry: R3=disc address of dir
;        R4=index of entry in dir
;        R5=start of dir

; exit:  LR=atts

ReadBigDirIntAtts ROUT
        Push    "LR"

        LDRB    LR, [R4, #BigDirAtts]           ; read the bottom 8 bits of atts

 [ DebugX
        DREG    LR, " ", cc
        DLINE   "=Big Atts"
 ]
        TSTS    LR, #DirBit
 [ FullAtts
        ASSERT  IntAttMask = &FF
 |
        ANDEQ   LR, LR, #IntAttMask
 ]
        ANDNE   LR, LR, #IntDirAttMask

        Pull    "PC"

 [ BinaryChop
; =========
; WildCheck
; =========

; check if wild card spec term has any wild cards

; entry:
;  R1   -> term, terminated by control codes, delete, space or delimiter

; exit:  EQ -> is wild card
;        NE -> no wild card

WildCheck ROUT
 [ DebugXb
        DREG    r1, "WildCheck(wild=",cc
        DLINE   ")"
 ]

        Push    "R0, R1, LR"

        SUB     R1, R1, #1      ; get to just before term (NextChar skips one)
10
        BL      NextChar        ; get next wild character
        BCS     %FT20
        TEQS    R0, #DelimChar
        BEQ     %FT20

        TEQS    R0, #OneWildChar        ; is this a wildcard?
        TEQNES  R0, #MultiWildChar
        BNE     %BT10

; here when found a wild ard
 [ DebugXb
        DLINE   "wildcard found"
 ]
        Pull    "R0, R1, PC"

20
; here when reched end; need to exit NE
        MOVS    R0, #1

 [ DebugXb
        DLINE   "no wildcard"
 ]

        Pull    "R0, R1, PC"
 ]


; ============
; LookUpBigDir
; ============

; look up wild card spec term in dir

; entry:
;  R1   -> term, terminated by control codes ,delete ,space or delimiter
;  R2   name restriction bits, only 'must be file' and 'must be dir' apply
;  R3   disc address of dir
;  R4   -> entry in dir to start at (or following entry if C=1)
;  R5   pointer to start of dir

; exit:

; IF found R4=index of entry in dir, Z=1 <=> file, C=0
; ELSE     R4->next alphabetical entry, C=1

LookUpBigDir    ROUT
 [ DebugX
        DREG    r1,"LookUpBigDir(wild=",cc
        DREG    r2,",restrict=",cc
        DREG    r3,",dir=",cc
        DREG    r4,",index ",cc
        DREG    r5,",dir start ",cc
        DLINE   ")",cc
 ]
        Push    "r7,LR"

        SUBCC   r4,r4,#BigDirEntrySize  ; caller asked to start at this entry
        MOV     R7, #0

 [ BinaryChop
        BL      WildCheck               ; is it wildcarded?
        BNE     %FT99                   ; no!
 ]
10
        ADD     r4,r4,#BigDirEntrySize
        BL      BigDirFinished          ; (R4,R5->eq->dir finished)
        BNE     %FT11

        ; end of dir
        TEQ     r7, #0
        MOVNE   r4, r7
        SEC
        B       %FT90                   ; carry already set

11
        Push    "R4,R5,R6"
        LDR     R6, [R4, #BigDirObNameLen]
        BL      GetBigDirName           ; get the name's address (in LR)
        MOV     R4, LR
        MOV     r5, #&ff                ; mask is ff
        BL      BigLexEqv               ; (R1,R4,R5->LO/EQ/HI)
        Pull    "R4,R5,R6"

        BCC     %BT10                   ;if mismatch and name<wild try next
        BEQ     %FT15                   ;EQ=>match

12
        ;mismatch and name >wild done
        TEQ     r7, #0                  ; doesn't affect C
        MOVEQ   r7, r4
        BCS     %BT10

        ; completion in the not found case

        MOV     r4, r7
        SEC                             ; set carry (not found)
        B       %FT90

15
        ; Match, but...
        BL      ReadBigDirIntAtts       ; read the attributes

;LR=Atts
        TSTS    LR, #DirBit
        BNE     %FT20                   ; found a dir
;found a file

        TSTS    R2, #MustBeDir
        BNE     %BT10
;fall through next few instructions as EQ
20
        TSTNES  R2, #MustBeFile
        BNE     %BT10

        TSTS    LR, #DirBit :SHL: 2,2 ;restore Z=1 <=> file, C=0
90
 [ Debug6
        DREG    r4,"->(entry=",cc
        BCC     %FT01
        DLINE   ",not found)"
        B       %FT02
01
        BNE     %FT01
        DLINE   " file ",cc
01
        DLINE   ",found)"
02
 ]
95
        Pull    "R7,PC"

 [ BinaryChop
99
; name was not wildcarded; we can binary chop it!

; register allocation.

; r8 = offset of entry of interest
; r9 = number of entries in range being considered
; r4 = ptr to current entry being examined
; r5 = start of dir

        Push    "r8, r9"

        ADD     r4, r4, #BigDirEntrySize

; first, work out offset of r4 in dir
        MOV     r8, r4                          ; R4 = size of an entry
        BL      GetDirFirstEntry                ; (R3,R5->R4)

        SUB     lr, r8, r4                      ; offset in bytes between start entry and thing

        MOV     r9, #BigDirEntrySize            ; size of a dir entry

 [ DebugX
        DREG    r8, "r8 : "
        DREG    lr, "lr : "
        DREG    r9, "r9 : "
        DREG    r4, "r4 : "
 ]

        DivRem  r8, lr, r9, r4, norem           ; r8 = offset into dir

 [ DebugXb
        DREG    r8, "init offset: "
 ]

        LDR     r9, [r5, #BigDirEntries]        ; number of entries in the dir
        SUB     r9, r9, r8                      ; difference

 [ DebugXb
        DREG    r9, "init range: "
 ]

        CMPS    r9, #0
        BNE     %FT05

        ; not found

        BL      GetDirFirstEntry                ; (R3,R5->R4)
        ASSERT  BigDirEntrySize=28

        RSB     R8, R8, R8, LSL #3              ; *7
        ADD     R4, R4, R8, LSL #2              ; 7*4=28

        SEC

        Pull    "r8, r9"

        B       %BT90

05

; here we have to check the middle item in the

;       ADD     lr, r9, #1
 [ DebugXb
        DREG    r8, "start: "
        DREG    r9, "len: "
 ]
        ADD     r8, r8, r9, LSR #1              ; r8 <- offset of entry to look into

        BL      GetDirFirstEntry                ; (R3,R5->R4)
        ASSERT  BigDirEntrySize=28

        RSB     LR, R8, R8, LSL #3              ; *7
        ADD     R4, R4, LR, LSL #2              ; 7*4=28

; now R4->entry of interest

        Push    "R4,R5,R6"
        LDR     R6, [R4, #BigDirObNameLen]
        BL      GetBigDirName           ; get the name's address (in LR)
        MOV     R4, LR
        MOV     r5, #&ff                ; mask is ff
        BL      BigLexEqv               ; (R1,R4,R5->LO/EQ/HI)
        Pull    "R4,R5,R6"

        BEQ     %FT80                   ; name=wild

        BCC     %FT20                   ; name<wild

        CMPS    r9, #1
        BEQ     %FT75

; name>wild.  range becomes below r8
 [ DebugXb
        DLINE   "name>wild"
 ]
        SUB     r8, r8, r9, LSR #1
        MOV     r9, r9, LSR #1
        B       %BT05

20
 [ DebugXb
        DLINE   "name<wild"
 ]
        CMPS    r9, #1
        BEQ     %FT70
; name<wild.  range becomes above r8
        ADD     r8, r8, #1
        SUB     r9, r9, #1
        MOVS    r9, r9, LSR #1
        BNE     %BT05                   ; if it's zero then it's not found


70
        ; not found
        ADD     R4, R4, #BigDirEntrySize
75
        SEC
        Pull    "R8, R9"
        B       %BT90


80
        ; Match, but...
 [ DebugXb
        DLINE   "Match, but..."
 ]
        BL      ReadBigDirIntAtts       ; read the attributes

;LR=Atts
        TSTS    LR, #DirBit
        BNE     %FT85                   ; found a dir
;found a file

        TSTS    R2, #MustBeDir
        BNE     %BT70
;fall through next few instructions as EQ
85
        TSTNES  R2, #MustBeFile
        BNE     %BT70

        TSTS    LR, #DirBit :SHL: 2,2 ;restore Z=1 <=> file, C=0

        Pull    "R8, R9"

        B       %BT90


 ]

; ================
; GetDirFirstEntry
; ================

; entry:

; R3 = dir ind disc address
; R5 = dir start

; exit:

; R4 points to first entry

GetDirFirstEntry ROUT
        Push    "R6,LR"
        SavePSR R6

        BL      TestBigDir

        BNE     %FT01                           ; not a big dir

        LDR     LR, [R5, #BigDirNameLen]
        ADD     LR, LR, #4
        BIC     LR, LR, #3

        ADD     R4, R5, LR
        ADD     R4, R4, #BigDirHeaderSize

        RestPSR R6,,f
        Pull    "R6,PC"
01
        ADD     R4,R5,#DirFirstEntry            ; not a big dir
        RestPSR R6,,f
        Pull    "R6,PC"

; ============
; NextDirEntry
; ============

; entry:

; R3=ind disc add
; R4->dir entry

; exit: r4->next dir entry

NextDirEntry ROUT
        Push    "LR"

        BL      TestBigDir
        ADDEQ   R4, R4, #BigDirEntrySize
        ASSERT  NewDirEntrySz=OldDirEntrySz
        ADDNE   R4,R4,#NewDirEntrySz

        Pull    "PC"

; ===============
; BigDirFreeSpace
; ===============

; entry:

; R5 -> dir start

; exit:

; LR number of bytes of unused space in the directory (always a word multiple)

BigDirFreeSpace ROUT
        Push    "R0,LR"

 [ DebugX
        DLINE   ">BigDirFreeSpace"
 ]
        LDR     R0, [R5, #BigDirSize]           ; size of the directory
        SUB     R0, R0, #BigDirHeaderSize + BigDirTailSize
        LDR     LR, [R5, #BigDirEntries]

        ASSERT  BigDirEntrySize=28
  [ BigDirFullBackup
        RSB     LR, LR, LR, LSL #3              ; *7
        SUB     R0, R0, LR, LSL #3              ; *7*8=56
  |
        SUB     R0, R0, LR, LSL #5              ; *(28+4)
  ]

        LDR     LR, [R5, #BigDirNameLen]        ; length of dir name
        ADD     LR, LR, #4
        BIC     LR, LR, #3
        SUB     R0, R0, LR

        LDR     LR, [R5, #BigDirNamesSize]      ; size of the names heap
        SUB     LR, R0, LR                      ; now LR is the number of free bytes in the dir

 [ DebugX
        DREG    LR, "<BigDirFreeSpace"
 ]
        Pull    "R0, PC"

; ============
; IsBigDirFull
; ============

; entry:

; R1 -> last term of name
; R3 top 3 bits disc id
; R5 -> dir start

; exit:
;   IF full, V set, R0 result

; number of bytes free in a big dir is:

; size of dir - (header size + tail size) - (size for all entries) - size of name heap

IsBigDirFull ROUT
        Push    "R0,R1,R2,R6,LR"

        BL      BigDirFreeSpace                 ; (R5->LR)
        MOV     R6, LR
        ; now get the number of bytes needed for the new entry:

        MOV     R2, R1                          ; keep start of term

        BL      SkipTerm                        ; (R1->R0,R1)

        SUB     R0, R1, R2                      ; length of term

        ADD     R0, R0, #4
        BIC     R0, R0, #3

 [ BigDirFullBackup
        ADD     R0, R0, #BigDirEntrySize*2
 |
        ADD     R0, R0, #BigDirEntrySize
        ADD     R0, R0, #4
 ]

 [ DebugX
        DREG    R0, "size needed:"
        DREG    R6, "size available:"
 ]
        CMPS    R0, R6
        MOVHI   R0, #DirFullErr
        MOVLS   R0, #0
        BL      SetVOnR0
        STRVS   R0, [SP]

        Pull    "R0,R1,R2,R6,PC"

; ===============
; MakeBigDirSpace
; ===============

; make space for a new entry in RAM copy of a directory
; ASSUMES DIR IS NOT FULL can check this with IsDirFull

; entry:

;  R1->term
;  R3 ind disc address
;  R4 -> entry
;  R5 -> dir start
;  R6 -> dir end

MakeBigDirSpace ROUT
        Push    "R0-R11,LR"
        SavePSR R11

 [ DebugX
;       BL      DumpBigDir
 ]

        MOV     R2, R1
        BL      SkipTerm                ; (R1->R0,R1)
        SUB     R8, R1, R2              ; R8 = term length
        ADD     R6, R8, #4
        BIC     R6, R6, #3              ; R6 = extra required in name heap

; now we can find the entry in the name heap, and bump everything up

        BL      GetBigDirName           ; (R4,R5->LR)

; LR = name heap entry
        MOV     R0, LR                  ; source for block move
        ADD     R1, R0, R6
        ADD     R1, R1, #BigDirEntrySize ; dest for block move

; length for move
        LDR     R2, [R5, #BigDirNameLen];length of dir name
        ADD     R2, R2, #4+BigDirHeaderSize
        BIC     R2, R2, #3
        LDR     LR, [R5, #BigDirEntries]

        ASSERT  BigDirEntrySize=28
        RSB     LR, LR, LR, LSL #3      ; *7
        ADD     R2, R2, LR, LSL #2      ; *7*4=28

        LDR     LR, [R5, #BigDirNamesSize] ; size of the heap of names

        ADD     R2, R2, LR              ; word after name heap
        ADD     R2, R2, R5

        SUB     R2, R2, R0              ; length of move

 [ DebugX
        DLINE   "Moving upper section of names"
        DREG    R0, "source="
        DREG    R1, "  dest="
        DREG    R2, "   len="
 ]

        BL      BlockMove               ; do the block move

        ADD     R7, R0, #BigDirEntrySize

        MOV     R0, R7
        MOV     R1, R6
        BL      ZeroRam                 ; zero rest of the entry

; R7 now points to start of new name heap entry

        MOV     R0, R4
        ADD     R1, R4, #BigDirEntrySize
        SUB     R2, R7, R1              ; amount to move

 [ DebugX
        DLINE   "Moving entries and lower section of names"
        DREG    R0, "source="
        DREG    R1, "  dest="
        DREG    R2, "   len="
 ]

        BL      BlockMove

; now update dir header fields
        LDR     LR, [R5, #BigDirEntries]        ; number of entries
        ADD     LR, LR, #1
        STR     LR, [R5, #BigDirEntries]        ; new number of entries

        LDR     LR, [R5, #BigDirNamesSize]      ; size of names heap
        ADD     LR, LR, R6
        STR     LR, [R5, #BigDirNamesSize]      ; new number of entries

; finally, generate new offsets into the name heap

        ADD     R4, R4, #BigDirEntrySize

        BL      BigDirFinished                  ; (R4, R5->C)

; C=0->can use next entry
; C=1->next entry not there, so use size of heap take R6
        LDRNE   LR, [R4, #BigDirObNamePtr]
        LDREQ   LR, [R5, #BigDirNamesSize]
        SUBEQ   LR, LR, R6

        STR     LR, [R4, #BigDirObNamePtr-BigDirEntrySize]      ; copy it
;
 [ DebugX
        DREG    R8, "storing name len of:"
 ]
        STR     R8, [R4, #BigDirObNameLen-BigDirEntrySize]      ; and set the name length

; now, bump all the other name indexes up by R6

        BEQ     %FT95                                           ; if Z=1 then finished

10
        LDR     LR, [R4, #BigDirObNamePtr]
        ADD     LR, LR, R6                      ; new pointer
        STR     LR, [R4, #BigDirObNamePtr]
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished                  ; (R4, R5->C)
        BNE     %BT10
 [ DebugX
;       BL      DumpBigDir
 ]
95
        RestPSR R11,,f
        Pull    "R0-R11,PC"                             ; if C=1 then finished

 [ DebugX

; r5-dir start

DumpBigDir ROUT
        Push    "R5,R11,LR"                             ; save regs
        DLINE   "Directory dump:"

        LDR     R11, [R5, #BigDirSize]                  ; size of dir
10
        LDR     LR, [R5], #4                            ; get a word
        DREG    LR, " ",cc                              ; dump it
        AND     LR, R11, #4*7                           ; is it end of line
        CMPS    LR, #4*7
        BEQ     %FT01
        DLINE   " "
01
        SUBS    R11, R11, #4
        BGT     %BT10

        Pull    "R5,R11,PC"
 ]

; ============
; WriteBigName
; ============

; copy file name string to dir entry

; entry:
;  R1 -> name
;  R4 -> entry
;  R5 -> dir start

WriteBigName ROUT
        Push    "R0-R2,R4,LR"
 [ DebugXd
        DSTRING R1, "WriteBigName : "
 ]
        LDR     R2, [R4, #BigDirObNameLen]
        ADD     R2, R2, #3
        BIC     R2, R2, #3      ; up to word boundary
        BL      GetBigDirName   ; (R4,R5->LR)
        MOV     R4, LR
10
        BL      ThisChar        ;(R1->R0,C)
        ADD     R1, R1, #1
        MOVCS   R0, #CR         ;if terminator
        STRB    R0, [R4],#1
        BCS     %FT90
        B       %BT10
90
        Pull    "R0-R2,R4,PC"


; ===============
; WriteBigDirName
; ===============

; copy dir name string into big dir

; entry:
; R1->name
; R5->dir

WriteBigDirName ROUT
        Push    "R0-R2,R4,R6,LR"
 [ DebugXd
        DSTRING R1, "WriteBigDirName : "
 ]
        MOV     R6, #0
        ADD     R4, R5, #BigDirHeaderSize
10
        BL      ThisChar        ;(R1->R0,C)
        ADD     R1, R1, #1
        MOVCS   R0, #CR         ;if terminator
        ADDCC   R6, R6, #1
        STRB    R0, [R4],#1
        BCS     %FT90
        B       %BT10
90
        STR     R6, [R5, #BigDirNameLen]
        Pull    "R0-R2,R4,R6,PC"

; ================
; WriteBigDirNames
; ================

; entry: R5->start of dir
;        R6->end

WriteBigDirNames ROUT
        Push    "R11,LR"

        ADRL    R11, SBProven
        LDMIA   R11, {R11, LR}
        STR     R11, [R5, #BigDirStartName]
        STR     LR, [R6, #BigDirEndName]

        Pull    "R11,PC"

; =============
; TryGrowDirBuf
; =============

; entry R4 required size of dir buf

; exit

; if error, VS and R0->error

TryGrowDirBuf ROUT
        Push    "R0-R8,LR"      ; stuff
 [ DebugX
        DREG    R4,"entry TryGrowDirBuf - need: "
 ]
        ; because DA size may be rounded up to a page, we read the real size here
        MOV     R0, #2                  ; read area size
        LDR     R1, DirBufferArea       ; area addr
        BL      OnlyXOS_DynamicArea     ; do the SWI call
        BVS     %FT95

        STR     R2, DirBufferSize       ; if it's already small enough then we're OK

        LDR     R4, [SP, #4*4]          ; get back the size needed

        CMP     R4, R2                  ; do we need more space
        BLS     %FT94                   ; no

        MOV     R0, R1                  ; area number to R0
        SUB     R1, R4, R2              ; amount needed
        BL      OnlyXOS_ChangeDynamicArea
        BVS     %FT95

        ADD     R2, R2, R1              ; number of bytes added to area
        STR     R2, DirBufferSize       ; etc
94
        CLRV                            ; clear the V flag
95
        STRVS   R0, [SP]                ; if V set then store the error
 [ DebugX
        DLINE   "Exit TryGrowDirBuf"
 ]
        Pull    "R0-R8,PC"      ; other stuff

; ==========
; GrowBigDir
; ==========

; entry:

; R3  =  dir ind disc address
; R5  -> dir start
; R6  -> dir end

; dir is in DirBuffer


GrowBigDir ROUT
        Push    "R0-R11,LR"
 [ DebugX :LOR: DebugXg
        DLINE   "entering GrowBigDir"
        DREG    R3, "dir "
        DREG    R5, "at  "
 ]
; first of all, ensure have enough memory for dir of required size
        SUB     R4, R6, R5              ; current dir size
        ADD     R4, R4, #BigDirMinSize  ; add a bit to it
        CMP     R4, #BigDirMaxSize      ; clear V
        MOVHI   R0, #DirFullErr
        BLHI    SetV
        BLVC    TryGrowDirBuf
        BVS     %FT99

; loop back to here when need to move more files
10
        LDR     R3, [SP, #3*4]
        LDR     R6, [SP, #6*4]
        LDR     R5, [SP, #5*4]
        SUB     R4, R6, R5
        ADD     R4, R4, #BigDirMinSize  ; size required
        BL      DiscAddToRec            ;(R3->LR) get disc record
        LDRB    R7, [LR, #DiscRecord_Log2SectorSize]   ; sector size
        LDRB    LR, [LR, #DiscRecord_BigMap_ShareSize]    ; share size
        ADD     R7, R7, LR
        MOV     R11, #1
        RSB     R11, R11,R11,LSL R7
        TSTS    R4, R11
        MOV     R9, R4, LSR R7
        ADDNE   R9, R9, #1              ; sharing blocks needed for dir

 [ DebugXg
        DREG    R9, "dir needs ",cc
        DLINE   " sharing blocks"
 ]

        BL      BeforeAlterFsMap        ; (R3->R0,V)
        BVS     %FT99

        BL      CritInitReadNewFs       ; (->R10,R11)

        BL      SortDir                 ; (R3,R5->R8)

15
        LDMIA   R8!, {R4, R5}           ; get table entry
 [ DebugXg
        DREG    R5," table entry: ",cc
        DREG    R4,""
 ]
        AND     R0, R5, #&FF    ; r5 - sharing offset
        TEQS    R5, #0
        TEQEQS  R4, #0
        BEQ     %FT25           ;end of list marker found
        MOVS    R5, R5, LSR #9  ;link bits from word 1 bits 9-31
        ADDCS   R5, R5, R3, LSR #8
        RSBCC   R5, R5, R3, LSR #8
 [ DebugXg
        DREG    R0, "File sector:",cc
        DREG    R4, ", file index:",cc
        DREG    R5, ", link bits:"
 ]

        TEQS    R4, #0          ;is it the dir itself?
        BEQ     %FT20

        TEQS    R5, R3, LSR #8  ;is it the same object as the dir
        BNE     %FT25           ;note: this is a termination case due to the sorting of the dir

        CMPS    R0, #1          ;is the sharing offset 1?
        BEQ     %FT20

        CMPS    R0, R9          ;is it in the way?
        BHI     %FT20           ; no

        ; an object is in the way
 [ DebugXg
        DREG    R0,"offset in the way:"
 ]
        SUB     LR, r0, #1
        MOV     R7, LR, LSL R7          ; dummy dir size for ClaimFreeSpace
        ; find the offending dir entry

        ASSERT  BigDirEntrySize=28
        RSB     R4, R4, R4, LSL #3      ; *7
        MOV     R4, R4, LSL #2          ; *4*7=28

        LDR     LR, DirBufferPtr
        LDR     LR, [LR, #BigDirNameLen]
        ADD     LR, LR, #4
        BIC     LR, LR, #3
        ADD     R4, LR, R4
        LDR     LR, DirBufferPtr
        ADD     LR, LR,#BigDirHeaderSize-BigDirEntrySize
        ADD     R4, R4, LR

  [ DebugXg
        BL      ReadIndDiscAdd          ; (R4->LR)
        DREG    LR, "Ind disc add of entry:"
  ]
        BL      ReadLen                 ; (R3,R4->LR)
        MOV     R10, LR                 ; length to claim
        MOV     R11,#fsfile_Save        ; reason code to ClaimFreeSpace
        LDR     R5, [SP, #5*4]          ; get the dir
        ADD     R7, R7, R10             ; increase dummy length
        STR     R7, [R5, #BigDirSize]   ; fake dir size (MUST restore later - see below)
 [ DebugXg
        DREG    R7, "dummy size:"
 ]
        BL      ClaimFreeSpace          ; claim space for object
  [ DebugXg
        BVC     %FT01
        DLINE   "ClaimFreeSpace failed"
01
  ]
        LDR     R6, [SP, #6*4]          ;
        SUB     R6, R6, R5
        STR     R6, [R5, #BigDirSize]   ; restore dir's original size MUST do this
        BVS     %FT96


; loop among Fcbs until we find that matches.  if it does, then we
; then have to adjust it

        BL      ReadIndDiscAdd

        sbaddr  r1, FirstFcb-FcbNext
        B       %FT02
01
        LDR     r8, [r1, #FcbIndDiscAdd]
 [ DebugXg
        DREG    r8, "File in chain:"
 ]

        CMP     r8, lr
        BNE     %FT02
 [ DebugXg
        DLINE   "matches file we're interested in"
 ]
        BL      Flush           ;flush the file of interest
        B       %FT03
02
        LDR     r1, [r1,#FcbNext];get next FCB
        CMPS    r1, #-1
        BNE     %BT01           ;
03

        Push    "R1,R3,R4"
        BL      ReadIndDiscAdd
        MOV     R1, LR
        MOV     R3, R10
        BL      DefaultMoveData         ; move the data
        Pull    "R1,R3,R4"
        BVS     %FT96                   ; argh

        MOV     R0, R2
        BL      WriteIndDiscAdd ; update the dir
        BL      WriteFsMapThenDir       ; write the stuff out
        BVS     %FT96           ; err, this would be BAD

        ; now if we found a matching Fcb, update its ind disc address

        CMP     R1, #-1
        STRNE   R2, [R1, #FcbIndDiscAdd]

        BL      UnlockMap       ; unlock the map
        B       %BT10           ; and try going round the loop again

20
        B       %BT15           ; round the loop again

25      ; SortDir didn't find any objects which clash.  do the grow operation, checking
        ; it won't grow beyond MinMapObj

        BIC     R1, R3, #&ff                    ; pretend to be unshared
        BL      MeasureFileAllocSize_GotMap     ; (R1,R3,R4->R0) always < 2G - dir object only
 [ DebugXg
        DREG    R0, "space allocated to dir:"
 ]

        LDR     R5, [SP, #5*4]  ; get the dir addr again
        LDR     R7, [R5, #BigDirSize] ; size of dir at present
        ADD     R7, R7, #BigDirMinSize
        CMPS    R7, R0
        BLS     %FT58

        ; here we don't have any shared objects getting in the way, but we
        ; don't have enough space allocated (how convenient).

        ; we call ClaimFreeSpace with RandomAccessExtend reason code to
        ; get things sorted out.  but we cheat.  because, y see, we don't
        ; want to have to get the parent dir in just yet, with all that
        ; copying around of data, so I'm gonna build a dummy dir entry
        ; on the stack.  cunning, eh no?

        ; we also then return most of the space anyway, cos RandomAccessExtend
        ; has a tendency to allocate far too much space

        Push    "R3,R4,R6,R7"

        SUB     SP, SP, #BigDirEntrySize        ; space for an entry
        MOV     R4, SP
        MOV     R6, R3                  ; keep addy around
        BL      ToParent                ; get parent addy
        BIC     R6, R6, #DiscBits       ; knock off DiscBits
        BIC     R6, R6, #&ff            ; and pretend unshared
        STR     R6, [R4, #BigDirIndDiscAdd]
        SUB     LR, R7, #BigDirMinSize  ; current size
        STR     LR, [R4, #BigDirLen]

        ; only need IndDiscAdd and Len to be valid in the dummy entry.

 [ {FALSE}
        ADD     R7, R7, #262144         ; 64K allocation?
        MOV     R10, R7
 |
        MOV     R10, R7                 ; size wanted
 ]
        MOV     R0, LR                  ; old extent
        MOV     R11, #RandomAccessExtend
        BL      ClaimFreeSpace          ; (R0,R3,R4,R5,R10,R11->R0,R2,R10,V)
        BVS     %FT55

        MOV     R0, R10

        Push    "R0,R2,R4,R5,R8,R10"

        MOV     R0, R7

        BL      CritInitReadNewFs       ; (->R10, R11)

        BL      RoundUpAlloc            ; (R0,R3->R0) always < 2G - dir object only

        BL      DiscAddToRec            ; (R3->LR)

        LDRB    R8, [LR, #DiscRecord_Log2bpmb]      ; convert units to map bits
        MOV     R1, R0, LSR R8          ;

 ; *********************************************************************************************

 ; 04 Dec 1997 SBP - copied fixed code to shorten object back to reasonable length from
 ;                   ShrinkBigDir routine, and made it fit :-)



 [ {TRUE}

        BL      DefFindFragment                 ; (R1, R2, R10 -> R1, R9, R11, LR)

 [ DebugXg
        DREG    R1, "map ptr : "
        DREG    R11, "frag at : "
        DREG    LR,  "remains : "
        DREG    R0, "new len : "
 ]

        ; R1  - map ptr to desired offset
        ; R11 - map ptr to fragment start
        ; LR  - number of bits left in fragment
        ; R0  - size to set length to
        ; R9  - pre gap

; first check that length to start of frag is OK

        SUBS    R1, R1, R11                     ; offset into frag
 [ DebugXg
        BNE     %FT01
        DLINE   "Frag disappearing entirely"
01
 ]
        BEQ     %FT40                           ; fragment disappearing entirely

        Push    "LR"

        BL      MinMapObj                       ; (R10->LR)

        MOV     R8, LR                          ; keep it around

        Pull    "LR"

        CMP     R1, R8                          ; is it too close to start of frag
        BGE     %FT30

 [ DebugXg
        DLINE   "frag would be too short - adjusting length"
 ]

; if fragment is going to be too short then
        SUB     R8, R8, R1                      ; need this many extra bits
        ADD     R1, R1, R11
        ADD     R1, R1, R8

        LDRB    R2, [R10, #ZoneHead+DiscRecord_Log2bpmb]    ; size of a map bit

        ADD     R0, R0, R8, LSL R2              ; new file size
        SUB     LR, LR, R8                      ; number of bits left in fragment


30 ; here when new fragment length long enough

        LDRB    R8, [R10, #ZoneHead+DiscRecord_IdLen]   ; get idlen again
        ADD     R8, R8, #1
        CMPS    LR, R8

        BGE     %FT40                           ; shortening by more than idlen+1, so safe

 [ DebugXg
        DREG    LR, "shortening by:"
 ]

        MOV     R2, LR                          ; keep number of bits around

; here when shortening by less than idlen+1.  check that object followed by a gap

        Push    "R7"
        BL      FragRdLenBits                   ; (R10->R11,R7)
        ADD     R8, R11, R7                     ; next object
        Pull    "R7"
        MOV     R11, R9
        BL      NextFree_Quick                  ; (R10,R11->R9,R11)
        BCS     %FT35                           ; exhausted, so no gap
        CMPS    R11, R8                         ; is it a gap
        BEQ     %FT40

35
 [ DebugXg
        DLINE   "can't shorten"
 ]

        LDRB    R8, [R10, #ZoneHead+DiscRecord_Log2bpmb]
        ADD     R0, R0, R2, LSL R8              ; new length

40 ; here when new length is OK
        Pull    "R1,R2,R4,R5,R8,R10"

 [ DebugXg
        DREG    R0, "new length is:"
        DREG    R1, "old length is:"
 ]

        BL      ReturnSpace                     ; return allocated space

 ; *********************************************************************************************

 |

        BL      DefFindFragment         ; (R1,R2,R10->R1,R9,R11,LR)
        SUBS    R1,R1,R11               ; R1 = offset in map bits into fragment
 [ DebugXg
        DREG    R1, "offset into fragment:"
 ]
        BEQ     %FT52                   ; no change needed as offset at frag start - removing frag entirely
        LDRB    R9, [R10, #ZoneHead+DiscRecord_IdLen]
 [ DebugXg
        DREG    R9, "IdLen:"
 ]
        ADD     R9, R9, #1
        CMP     R1, R9
        BHS     %FT52                   ; no change needed as offset is more than idlen+1 into frag

 [ DebugXg
        DREG    R7,"too short:"
 ]
        ; here if offset less than needed
        SUB     R1, R9, R1              ; offset to add to R7
        LDRB    R9, [R10, #ZoneHead+DiscRecord_Log2bpmb]
        ADD     R7, R7, R1, LSL R9      ; add it

 [ DebugXg
        DREG    R1, "amount to increase by:"
        DREG    R9, "BitSize: "
        DREG    R7, "changing to: "
 ]

52
        Pull    "R2,R4,R5,R8,R10"

        ; now try to return excess space
        MOV     R0, R7                  ; new length
        MOV     R1, R10                 ; allocated length
        BL      ReturnSpace             ; return the space

 ]


 ; *********************************************************************************************




55
        ADD     SP, SP, #BigDirEntrySize
        Pull    "R3,R4,R6,R7"

        BVS     %FT96                   ; if error

        BL      WriteFsMap              ; write out the FsMap.  extra space allocated after dir.

58
        ; here we have enough space in the object
        ; and there's no shared objects in the way
        ; so let's do it.  first alter the dir

 [ DebugXg
        DLINE   "can grow dir... doing so"
 ]

        BL      InvalidateBufDir        ; going to trash dir
        STR     R7, [R5, #BigDirSize]
        SUB     R0, R6, #BigDirTailSize
        ADD     R1, R0, #BigDirMinSize
        MOV     R2, #BigDirTailSize
        BL      BlockMove

 [ DebugXg
        DLINE   "Writing dir"
        LDR     LR, [R5, #BigDirParent]
        DREG    LR, "parent is:"
 ]
        BL      WriteDir        ;write out the dir
        BVS     %FT96

 [ DebugXg
        DLINE   "Getting parent"
        DREG    R3, "R3: "
        DREG    R5, "R5: "
 ]
        MOV     R8, R3          ;keep ind disc add around
        BL      ToParent        ;(R3,R5->R3)
 [ DebugXg
        DREG    R3, "Parent: "
 ]
        CMPS    R8, R3          ;is it the root dir
        BNE     %FT55

 [ DebugXg
        DLINE   "It's the root dir - updating the FS map"
 ]
        BL      DiscAddToRec    ;(R3->LR) get disc record

        STR     R7, [LR, #DiscRecord_BigDir_RootDirSize]          ; store the root dir size in the disc record

        LDR     r10, CritDrvRec

 [ DynamicMaps
        LDR     r10, [r10, #DrvsFsMapAddr]
 |
        LDR     r10, [r10, #DrvsFsMap]
        BIC     r10, r10, #HiFsBits
 ]

        MOV     r1, #(ZoneHead*8)+Zone0Bits
        BL      MarkZone                ;(r1,r10)

        STR     R7, [R10, #ZoneHead+DiscRecord_BigDir_RootDirSize]

        BL      WriteFsMap
        BVS     %FT96
        B       %FT80

55

        BL      GetDir          ; get the parent dir into dirbuf

        BL      GetDirFirstEntry        ; get first entry in dir

        BL      InvalidateBufDir
        MOV     R0, R7          ; length to write out
60
        BL      BigDirFinished ;(R4,R5->Z)
        BEQ     %FT70
        BL      ReadIndDiscAdd  ; get ind disc add
        CMPS    LR, R8          ; is it our object
        BEQ     %FT75
        ADD     R4, R4, #BigDirEntrySize
        B       %BT60

75
        BL      WriteLen        ;(R0,R3,R4) write the length

70
        BL      WriteDir        ; write the dir
        BVS     %FT96           ; error!

80
        MOV     R3, R8          ; get the original dir back into the dir buffer
        BL      GetDir
        STRVC   R5, [SP, #4*5]
        STRVC   R6, [SP, #4*6]
        MOVVC   R0, #0
96
        BL      UnlockMap
        BL      SetVOnR0
99
        STRVS   R0, [SP]
 [ DebugXg
        DLINE   "exiting GrowBigDir"
        BVC     %FT01
        DREG    R0, "error:"
01
 ]
        Pull    "R0-R11,PC"


; ===============
; CanBigDirShrink
; ===============

; entry:

; R5-> big dir in dir buffer
; R3   dir in disc add

CanBigDirShrink ROUT
        Push    "R0,LR"
 [ DebugX :LOR: DebugXg
        DLINE   ">CanBigDirShrink"
 ]

        BL      BigDirFreeSpace                 ; (R5->LR)
        MOV     R0, LR
 [ DebugX :LOR: DebugXg
        DREG    R0, "free space:"
 ]

        MOV     LR, #BigDirMinSize
        SUB     LR, LR, #1
        BICS    R0, R0, LR                      ; clear bottom bits
        MOVNE   R0, #-1                         ; -1 if non-0
        MVNS    R0, R0                          ; Z=1 if can shrink
 [ DebugX :LOR: DebugXg
        BNE     %FT01
        DLINE   "can shrink"
01
        DLINE   "<CanBigDirShrink"
 ]
        Pull    "R0,PC"


; ============
; ShrinkBigDir
; ============

; entry:

; R3=dir ind disc add
; R5->dir (in dir buffer)

; disc has already been BeforeAlterFsMapped

; exit: if error then R0->error block and V set

ShrinkBigDir ROUT
        Push    "R0-R11,LR"

 [ DebugX :LOR: DebugXg
        DLINE   ">ShrinkBigDir"
 ]

        BL      BigDirFreeSpace                 ; (R5->LR)
        ASSERT  BigDirMinSize=2048

        MOV     R8, LR, LSR #11
        MOV     R8, R8, LSL #11                 ; number of bytes to shrink dir by

        BL      InvalidateBufDir                ; going to alter BufDir

        LDR     R7, [R5, #BigDirSize]           ; current size of dir
        ADD     R0, R5, R7
        SUB     R0, R0, #BigDirTailSize         ; source for move
        SUB     R1, R0, R8                      ; dest for move
        MOV     R2, #BigDirTailSize             ; size of tail
        BL      BlockMove                       ; do the move

        SUB     R7, R7, R8                      ; new size of dir
        STR     R7, [R5, #BigDirSize]

        BL      BigDirHasSharedObjects          ; is it sharing with anything?
        BEQ     %FT50                           ; yes, sharing

        BL      CritInitReadNewFs               ; (->R10,R11)

        BIC     R1, R3, #&ff
        BL      MeasureFileAllocSize_GotMap     ; (R1,R3,R4->R0) always < 2G dir object only
        Push    "R0"

        BL      RoundUpAlloc                    ; (R0,R3->R0) always < 2G - dir object only

        LDRB    LR, [R10, #ZoneHead+DiscRecord_Log2bpmb]
        MOV     R1, R0, LSR LR                  ; number of map bits needed for object

        BIC     R2, R3, #&ff

        BL      DefFindFragment                 ; (R1, R2, R10 -> R1, R9, R11, LR)

        ; R1  - map ptr to desired offset
        ; R11 - map ptr to fragment start
        ; LR  - number of bits left in fragment
        ; R0  - size to set length to
        ; R9  - pre gap

; first check that length to start of frag is OK

        SUBS    R1, R1, R11                     ; offset into frag
        BEQ     %FT40                           ; fragment disappearing entirely

        Push    "LR"

        BL      MinMapObj                       ; (R10->LR)
        MOV     R8, LR

        Pull    "LR"

        CMP     R1, R8                          ; is it too close to start of frag
        BGE     %FT30

 [ DebugX :LOR: DebugXg
        DLINE   "frag would be too short - adjusting length"
 ]

; if fragment is going to be too short then
        SUB     R8, R8, R1                      ; need this many extra bits
        ADD     R1, R1, R11
        ADD     R1, R1, R8

        LDRB    R2, [R10, #ZoneHead+DiscRecord_Log2bpmb]    ; size of a map bit

        ADD     R0, R0, R8, LSL R2              ; new file size
        SUB     LR, LR, R8                      ; number of bits left in fragment


30 ; here when new fragment length long enough

        LDRB    R8, [R10, #ZoneHead+DiscRecord_IdLen]   ; get idlen again
        ADD     R8, R8, #1
        CMPS    LR, R8

        BGE     %FT40                           ; shortening by more than idlen+1, so safe

 [ DebugX :LOR: DebugXg
        DREG    LR, "shortening by:"
 ]

        MOV     R2, LR                          ; keep number of bits around

; here when shortening by less than idlen+1.  check that object followed by a gap

        Push    "R7"
        BL      FragRdLenBits                   ; (R10->R11,R7)
        ADD     R8, R11, R7                     ; next object
        Pull    "R7"
        MOV     R11, R9
        BL      NextFree_Quick                  ; (R10,R11->R9,R11,Z,C)
        BCS     %FT35
        CMPS    R11, R8                         ; is it a gap
        BEQ     %FT40

35
 [ DebugX :LOR: DebugXg
        DLINE   "can't shorten"
 ]

        LDRB    R8, [R10, #ZoneHead+DiscRecord_Log2bpmb]
        ADD     R0, R0, R2, LSL R8              ; new length

40 ; here when new length is OK
        Pull    "R1"

 [ DebugX :LOR: DebugXg
        DREG    R0, "new length is:"
        DREG    R1, "old length is:"
 ]

        BIC     R2,R3,#&ff
        BL      ReturnSpace                     ; return allocated space

        BL      WriteDirThenFsMap
        BVS     %FT95
        B       %FT60

50      ; sharing so just write the dir
        BL      WriteDir
        BVS     %FT95

60
        ; now sort out the parent
        MOV     R2, R3                          ; keep ind disc add around
        BL      ToParent                        ; (R3, R5->R3)
        CMPS    R2, R3                          ; is it the root dir
        BNE     %FT70                           ; not root dir

        ; alter the size in the disc record

        BL      DiscAddToRec    ;(R3->LR) get disc record

        STR     R7, [LR, #DiscRecord_BigDir_RootDirSize]          ; store the root dir size in the disc record

        LDR     r10, CritDrvRec
 [ DynamicMaps
        LDR     r10, [r10, #DrvsFsMapAddr]
 |
        LDR     r10, [r10, #DrvsFsMap]
        BIC     r10, r10, #HiFsBits
 ]

        MOV     r1, #(ZoneHead*8)+Zone0Bits
        BL      MarkZone                ;(r1,r10)

        STR     R7, [R10, #ZoneHead+DiscRecord_BigDir_RootDirSize]

        BL      WriteFsMap
        B       %FT95

70
        BL      GetDir
        BVS     %FT95                           ; can't get the dir!
        BL      GetDirFirstEntry                ; (R3, R5->R4)

80
        BL      BigDirFinished                  ; (R4,R5->Z)
        BEQ     %FT95
        BL      ReadIndDiscAdd                  ; (R3,R4->LR)
        TEQ     R2,LR
        BEQ     %FT85
        ADD     R4, R4, #BigDirEntrySize
        B       %BT80

85
        ; found dir entry, write updated length
        MOV     R0, R7
        BL      WriteLen                        ;(R0,R3,R4)
        BL      WriteDir

95
        STRVS   R0, [SP]
 [ DebugX :LOR: DebugXg
        DLINE   "<ShrinkBigDir"
 ]

        Pull    "R0-R11,PC"

; ======================
; BigDirHasSharedObjects
; ======================

; tests if a big dir contains shared object
;
; entry - R3 = dir ind disc add
;         R5-> dir

; exit:   Z=1<=>dir shares space with file(s)

BigDirHasSharedObjects ROUT
        Push    "R1,R4, LR"

        BL      GetDirFirstEntry        ; (R3, R5->R4)
        MOV     R1, R3, LSR #8

10
        BL      BigDirFinished          ; (R5, R4 -> Z)
        BEQ     %FT90
        BL      ReadIndDiscAdd          ; (R3, R4 -> LR)
        TEQS    R1, LR, LSR #8  ; is it in the same disc object?
 [ DebugX
        BNE     %FT01
        DLINE   "dir shares with child"
01
 ]
        Pull    "R1, R4, PC",EQ
        ADD     R4, R4, #BigDirEntrySize
        B       %BT10

90      ; run out of dir
        MOVS    R1, #1          ; Z=0
 [ DebugX
        DLINE   "dir does not share with child"
 ]

        Pull    "R1,R4, PC"


; ===================
; DoOsFunRenameBigDir
; ===================

; This function does OsFunRename for big dirs.  After initial work
; done by DoOsFunRename, this function is called.  We have a separate
; special function because there is extra complexity involved in
; doing the rename.

; entry:

; R2 -> new name
; R3 source dir ind disc add
; R4 entry in dir
; R5 -> dir start
; R6 -> first byte after dir

; exit if error, R0 = error, V set

DoOsFunRenameBigDir ROUT
        Push    "R1-R11, LR"
 [ DebugX :LOR: DebugXr
        DLINE   ">DoOsFunRenameBigDir"
        DREG    r3, "source dir ind disc add: "
 ]

; this bit same as for DoOsFunRename

        MOV     R7, R3
        SUB     R8, R4, R5
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        MOV     R9, LR
 [ DebugXr
        DREG    r9, "Ind disc add of object being moved: "
 ]
        BL      ReadIntAtts     ;(R3,R4->LR)
        MOV     R11,LR
        BL      ReadLen         ;(R3,R4->LR)
        MOV     R10,LR
        MOV     R2, R9
        BL      ReallyShared    ;(R2-R5->Z)
        ORREQ   R11,R11,#1 :SHL: 31
        BL      IncUsage        ;(R3)

; need stack for dir entry, and ptr to new final component and new final component length
        SUB     SP, SP, #BigDirEntrySize+4+4
        MOV     R0, R4
        MOV     R1, SP
        MOV     R2, #BigDirEntrySize
        BL      BlockMove       ; (R0-R2)

; now look up new name
        LDR     R1, [SP,#BigDirEntrySize+4+4+4] ;new name string
        AND     R2, R3, #DiscBits
        ORR     R2, R2, #MustBeRefDisc
        ORR     R2, R2, #DirToBuffer :OR: NotLastUp :OR: NotLastWild :OR: NotNulName
        BL      FullLookUp      ;(R1,R2->R0-R6,C,V)
        BVS     %FT05
        TEQS    R7, R3          ;if new obj already exists is it old obj
 [ DebugXr
        DREG    R3, "Dest ind dir: "
 ]
        SUB     LR, R4, R5
        TEQEQS  LR, R8
        BEQ     %FT07
        MOVNE   R0, #ExistsErr

05
        TEQS    R0, #NotFoundErr
        BNE     %FT85
        BL      ThisChar        ;(R1->R0,C)
        MOVCC   R0, #NotFoundErr
        BCC     %FT85           ;not terminator => not last term

07
        ; No need to explicitly ensure a new Id as this will be handled by WriteDir
        ; or writing the FSMap out.

        LDR     R0, [SP,#BigDirEntrySize+4+4+4];string start
        BL      TermStart       ;backtrack to start of last term (R0,R1->R1)

 [ DebugX :LOR: DebugXr
        DSTRING R1, "New final component:"
 ]

        STR     R1, [SP,#BigDirEntrySize]    ;final component new name

        ADD     R8, R8, R5      ;convert old entry offset to ptr
        TEQS    R3, R7
        BNE     %FT20           ;not in same dir

        ; if renaming a directory, then before we can do anything else, we'll
        ; need to ensure that there's space

        LDR     R2, [SP, #BigDirObNameLen]; get the old name length
 [ DebugX :LOR: DebugXr
        DREG    R2, "From allocated name length: "
 ]
        ADD     R2, R2, #4
        BIC     R2, R2, #3              ; allocated length

 [ DebugX :LOR: DebugXr
        DREG    R2, "Old allocated name length:"
 ]

        BL      SkipTerm                ;(R1->R0,R1)
        LDR     LR, [SP, #BigDirEntrySize]
 [ DebugX :LOR: DebugXr
        DSTRING LR, "and: "
 ]
        SUB     R1, R1, LR              ;new name length
        STR     R1, [SP, #BigDirEntrySize+4]    ; store new name length
        ADD     R1, R1, #4
        BIC     R1, R1, #3              ;new required allocated length
 [ DebugX :LOR: DebugXr
        DREG    R1, "New required:"
 ]

        SUBS    R1, R1, R2              ;extra required
 [ DebugX :LOR: DebugXr
        DREG    R1, "Extra required for name:"
 ]
        BLE     %FT09                   ;no extra needed

        TSTS    R11, #DirBit
        BEQ     %FT08                   ;if not moving a dir then no need to thingy

        Push    "R1,R3"
        MOV     R3, R9
        BL      MaybeGrowBigDirForName  ;(R1,R3->R0,R1,V)
        STR     R1, [SP, #BigDirLen+2*4]
        Pull    "R1,R3"
        BVS     %FT90

        BL      GetDir                  ; get the parent dir back
        BVS     %FT90                   ; if error then error it is


08
 [ DebugX :LOR: DebugXr
        DLINE   "Considering growing dir"
 ]
        BL      BigDirFreeSpace         ; (R5->LR)
        CMPS    LR, R1
        BLLO    GrowBigDir              ; (R3,R5,R6->R0, LR)
        BVS     %FT90                   ;

        ; because dir entry may have been altered, take a copy
        MOV     R0, R8
        MOV     R1, SP
        MOV     R2, #BigDirEntrySize
        BL      BlockMove               ;(R0,R1,R2)

09 ; here child and parent have grown as much as is required

; as case for big dirs is much harder to work out, we don't beat around the bush
        BL      InvalidateBufDir        ; going to write this dir out
        Push    "R4"
        MOV     R4, R8                  ; dir entry being removed
        BL      RemoveDirEntryOnly      ; remove just the dir entry, not allocated space
        Pull    "R4"
        CMPS    R4, R8
        SUBHI   R4, R4, #BigDirEntrySize        ; bump down ptr if needs it

   ; now make space for the term
        LDR     R1, [SP, #BigDirEntrySize] ; size of dir entry
        BL      MakeBigDirSpace         ; make space for entry

   ; now copy entry excluding bits we don't want
        MOV     R0, SP
        MOV     R1, R4
        MOV     R2, #BigDirObNameLen
        BL      BlockMove               ; copy entry

   ; finally, the name
        LDR     R1, [SP, #BigDirEntrySize]
        BL      WriteBigName            ; write the name
        BL      WriteDir
        BVS     %FT90

        BL      CanBigDirShrink
        BLEQ    ShrinkBigDir
        BVS     %FT90

   ; now, go back to the child, and update its name
        MOV     R1, R3
        BL      %FT10
        BVS     %FT90

        B       %FT80

10
; subroutine:
; job: write new name into child (and also parent dir if need be)

; R1  new parent dir
; R2  new name length
; R9  dir to rename
; R11 attributes
        Push    "R0,R1,R2,R3,R4,R6,R7,LR"
        TSTS    R11,#DirBit
        BEQ     %FT14
        MOV     R3, R9          ;child dir
        LDR     R4, [SP,#8*4+BigDirEntrySize] ;final component new name
        BL      GetDir          ;(R3->R0,R5,R6,V)
        BVS     %FT14
        BL      InvalidateBufDir
        MOV     R3, R1
        BL      WriteParent     ;(R3,R5,R6)
        LDR     R7, [R5, #BigDirNameLen]
        LDR     R6, [SP, #8*4+BigDirEntrySize+4]
        STR     R6, [R5, #BigDirNameLen]
 [ DebugX :LOR: DebugXr
        DREG    R6, "new dir name length is:"
        DREG    R7, "old dir name length is:"
 ]
        ADD     R6, R6, #4
        BIC     R6, R6, #3
        ADD     R7, R7, #4
        BIC     R7, R7, #3
        LDR     R2, [R5, #BigDirEntries]
        LDR     LR, [R5, #BigDirNamesSize]

        ASSERT  BigDirEntrySize=28
        RSB     R2, R2, R2, LSL #3      ; *7
        ADD     R2, LR, R2, LSL #2      ; *7*4=*28

        ADD     R0, R5, #BigDirHeaderSize
        ADD     R0, R0, R7
        ADD     R1, R5, #BigDirHeaderSize
        ADD     R1, R1, R6
 [ DebugX :LOR: DebugXr
        DREG    R0, "src:"
        DREG    R1, "dst:"
        DREG    R2, "len:"
 ]
        BL      BlockMove               ; (R0, R1, R2)
        MOV     R1, R6
        ADD     R0, R5, #BigDirName
        BL      ZeroRam                 ; (R0, R1)
 [ DebugX :LOR: DebugXr
        DREG    R0, "zer:"
        DREG    R1, "len:"
 ]
        LDR     R6, [R5, #BigDirNameLen]
        ADD     R7, R5, #BigDirName
        BL      PutMaskedString ;(R3,R4,R6,R7->R7)
        BL      WriteDir        ;(->R0,V)
        BVS     %FT14

        BL      CanBigDirShrink
        BLEQ    ShrinkBigDir
14
        STRVS   R0, [SP]
        Pull    "R0,R1,R2,R3,R4,R6,R7,PC"


15
; Subroutine:
;
; Job: Fill in and write out new parent dir
;
        Push    "R1,LR"
 [ DebugXr
        DLINE   "filling in and writing out new parent dir"
 ]
        LDR     R1, [SP,#2*4+BigDirEntrySize]  ;new name final component
        BL      WriteBigName       ;(R1,R4)
        ADD     R0, SP, #8      ;move copy of old dir entry back into new place
        MOV     R1, R4
        MOV     R2, #BigDirObNameLen
        BL      BlockMove       ;(R0-R2)
        AND     R0, R11,#IntAttMask
        BL      SetIntAtts      ;(R0,R3,R4) only needed for old format
        BL      IncObjSeqNum    ;(R3-R5)
 [ DebugXr
        LDR     lr, [r5, #BigDirEntries]
        DREG    lr, "entries: "
 ]
        BL      WriteDir        ;(->R0,V)
        Pull    "R1,PC"

20 ; here when not in same dir

 [ DebugX :LOR: DebugXr
        DLINE   "renaming across (big) dirs"
 ]

        TSTS    R11,#DirBit
        BEQ     %FT35

; If we're here then we're renaming a directory into a different directory
;
; Check not doing a duff rename

 [ DebugXr
        DLINE   "check for duff rename"
 ]

        MOV     R1, R3         ;if renaming dir walk up new path pathname
 [ DebugXr
        DREG    R3, "start from: "
        DREG    r9, "renaming: "
 ]
25
        BL      DiscAddToRec   ;(R3->LR)
        LDR     R0, [LR,#DiscRecord_Root]
        TEQS    R3, R0          ;if meet root dir
        TEQNES  R3, R7          ;or old parent dir
        BEQ     %FT30           ;then ok
 [ DebugXr
        DREG    R3, "compare ",cc
        DREG    R9, "with "
 ]
        TEQS    R3, R9          ;but if meet dir to rename
        MOVEQ   R0, #BadRenameErr;then moan
        BEQ     %FT85
        BL      ToParent        ;(R3,R6->R3)
 [ DebugXr
        DREG    R3, "parent is:"
 ]
        BL      FindDir         ;(R3->R0,R5,R6,V)
        BVS     %FT90
        B       %BT25
30
 [ DebugXr
        DLINE   "rename OK"
 ]
        MOV     R3, R1          ;retreive new parent dir
        BL      GetDir          ;(R3->R0,R5,R6,V)
 [ DebugXr
        DREG    R3, "retrieving new parent dir: "

 ]
        BVS     %FT90
35
; If we're here then we're renaming something into a different directory
; and its safe to do so (ie duff directory renames have been checked for)

        ; check to see if we need to grow the new parent

        LDR     R1, [SP, #BigDirEntrySize]
        BL      IsBigDirFull
        BLVS    GrowBigDir      ; need to grow new parent
        BVS     %FT90           ; can't grow it

; here have grown new parent dir.  may also need to grow child if it's a dir

        ; if renaming a directory, then before we can do anything else, we'll
        ; need to ensure that there's space

        LDR     R2, [SP, #BigDirObNameLen]; get the old name length
        ADD     R2, R2, #4
        BIC     R2, R2, #3              ; allocated length

 [ DebugX :LOR: DebugXr
        DREG    R2, "Old allocated name length:"
        DSTRING  R1, "Start with name:"
 ]

        BL      SkipTerm                ;(R1->R0,R1)
        LDR     LR, [SP, #BigDirEntrySize]
        SUB     R1, R1, LR              ;new name length
        STR     R1, [SP, #BigDirEntrySize+4]    ; store new name length
        ADD     R1, R1, #4
        BIC     R1, R1, #3              ;new required allocated length
 [ DebugX :LOR: DebugXr
        DREG    R1, "New required:"
 ]

        SUBS    R1, R1, R2              ;extra required
 [ DebugX :LOR: DebugXr
        DREG    R1, "Extra required for name:"
 ]
        BLE     %FT38                   ;no extra needed

        TSTS    R11, #DirBit
        BEQ     %FT38           ; not a dir, so don't bother

        Push    "R3"
        MOV     R3, R9
        BL      MaybeGrowBigDirForName  ;(R1,R3->R0,R1,V)
        Pull    "R3"
        BVS     %FT90

        BL      GetDir                  ; get the parent dir back
        BVS     %FT90                   ; if error then error it is

        ; dir's length may have changed, so update our copy of the entry
        STR     R1, [SP, #BigDirLen]

 [ DebugX :LOR: DebugXr
        DREG    R1, "Updated length is..."
 ]

38
; here, if child is a dir, then it's as big as needs be
        TSTS    R11,#1 :SHL: 31
        BEQ     %FT40

 [ DebugXr
        DLINE   "renaming of shared object"
 ]

; If we're here then object being renamed is shared with something else. This
; means we've got to claim new space in the destination directory for it and copy
; the renamee across.

        BL      BeforeAlterFsMap
        BVS     %FT90
        Push    "R3,R4,R11"
        MOV     R11,#fsfile_Create
        BL      ClaimFreeSpace  ;(R3-R6,R10,R11->R0,R2,V)
        MOV     R6, R2

        MOVVC   R1, R9
        MOVVC   R3, R10
        BLVC    DefaultMoveData ;(R1-R3->R0-R4,V)
 [ DebugXr
        DebugError "Error after DefaultMoveData: "
 ]
        Pull    "R3,R4,R11"

        LDRVC   R1, [SP, #BigDirEntrySize]      ; get term again
        BLVC    MakeBigDirSpace    ;(R3-R6)

        LDRVC   R1, [SP,#BigDirEntrySize] ;new name final component
        BLVC    WriteBigName            ;(R1,R4,R5)
        MOVVC   R0, SP                  ;move copy of old dir entry back into new place
        MOVVC   R1, R4
        MOVVC   R2, #BigDirObNameLen
        BLVC    BlockMove               ;(R0-R2)
        MOVVC   R0, R6                          ;adjust ind disc add to new value
        BLVC    WriteIndDiscAdd ;(R0,R3,R4)

      BL      InvalidateBufDir

 [ DebugXr
        DLINE   "about to write target dir"
        LDR     lr, [r5, #BigDirEntries]
        DREG    lr, "entries: "
        DREG    r3, "In disc add in R3:"
        BVC     %FT01
        DLINE   "V set before WriteFsMapThenDir!"
01
 ]

        BLVC    WriteFsMapThenDir       ;(->R0,V)
 [ DebugXr
        DebugError "error when writing fsmap then dir: "
 ]
        BL      UnlockMap
        B       %FT45

40
 [ DebugXr
        DLINE   "renaming of unshared object"
 ]
        LDR     R1, [SP, #BigDirEntrySize]      ; get term again
        BL      MakeBigDirSpace    ;(R3-R6)
        BL      %BT15
45
; Renaming object between directories and its already been placed in the
; destination.

 [ DebugXr
        DLINE   "object now in destination dir"
 ]

        MOVVC   R1,R3
        MOVVC   R3, R7          ;old parent dir
        BLVC    GetDir          ;(R3->R0,R5,R6,V)
        MOVVC   R4, R8
        BLVC    RemoveDirEntryOnly      ;(R3-R6->R0,V) always succeeds
        BLVC    WriteDir        ;(->R0,V)
        BVS     %FT90
        BL      CanBigDirShrink
        BLEQ    ShrinkBigDir
        BLVC    %BT10
        B       %FT90


80
        MOV     R0, #0
85
        BL      SetVOnR0
90
        ADD     SP, SP, #BigDirEntrySize+4+4   ;return dir entry buffer
        MOVVC   R0, #0
        STRVC   R0, [SP,#0]     ;zero return R1 to indicate success
        MOV     R3, R7
        BL      DecUsage        ;(R3)

 [ DebugX :LOR: DebugXr
        DLINE   "<DoOsFunRenameBigDir"
 ]
        Pull    "R1-R11,PC"

; ======================
; MaybeGrowBigDirForName
; ======================

; entry:

; R1 number of extra bytes required (word multiple)
; R3 ind disc add of dir to grow (isn't in dir buffer)

; exit:

;   either:

;     directory has been grown, R1 = new size of directory

;   or:

;     directory grow failed, R0 -> error block, V set

MaybeGrowBigDirForName ROUT
        Push    "R0,R2-R11, LR"

 [ DebugX
        DLINE   ">MaybeGrowBigDirForName"
 ]

        BL      GetDir          ; (R3->R5, R6->R0, V)
        BVS     %FT95

        BL      BigDirFreeSpace ; (R5->LR)
        CMP     R1, LR
        BLO     %FT90

        BL      GrowBigDir      ; (R3, R5, R6->R0, V)
        BVS     %FT95

90
        MOV     R0, #0
95
        BL      SetVOnR0
        STRVS   R0, [SP]
        LDRVC   R1, [R5, #BigDirSize]   ; return new size of dir
 [ DebugX
        BVC     %FT01
        DREG    R1, "New dir size: "
01
        DebugError      "Error from MaybeGrowBigDirForName: "
        DLINE   "<MaybeGrowBigDirForName"
 ]
        Pull    "R0,R2-R11, PC"


; =====================
; ReallySharedNotFudged
; =====================

;entry
; R2 ind disc add
; R3 dir
; R4 -> dir entry
; R5 -> dir start, MUST NOT BE FUDGED
; R6 -> dir entry to start at

;exit EQ <=> file is in shared frag and at least one other obj is sharing frag

;CAN'T READ IN DISC ADD FROM DIR ENTRY AS CLOSE FILE WILL HAVE ALREADY MODIFIED
;THIS IF FILE IS ZERO LENGTH

ReallySharedNotFudged ROUT
        Push    "R0,R1,R4,LR"
 [ DebugE
        DREG    R2, "ReallySharedNotFudged(disc add:",cc
        DREG    R3, ", dir:",cc
        DREG    R4, ", entry:",cc
        DREG    R5, ", dir start:",cc
        DREG    R6, ", start entry:"
 ]
        MOV     R1, R2, LSR #8
        TSTS    R2, #&FF        ;If not in shared fragment
        TOGPSR  Z_bit,LR
        BNE     %FT95
        TEQS    R1, R3, LSR #8
        BEQ     %FT95           ;sharing with parent dir
        MOV     R0, R4

        SUB     R4, R6, #BigDirEntrySize          ;get first dir entry to start at
        B       %FT10
05
        TEQS    R4, R0
        BEQ     %FT10
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        TEQS    R1, LR, LSR #8
        BEQ     %FT95           ;sharing with file
10
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
        BNE     %BT05           ;loop while more dir entries
        TOGPSR  Z_bit,LR
                        ;NE if no sharers
95
 [ DebugE
        BEQ     %FT01
        DLINE   "<-ReallyShared(not really sharing)"
        B       %FT02
01
        DLINE   "<-ReallyShared(really sharing)"
02
 ]
        Pull    "R0,R1,R4,PC"

; =========================
; ReturnWholeSpaceNotFudged
; =========================

; As ReturnSpaceNotFudged but new length=0

ReturnWholeSpaceNotFudged
        MOV     R0, #0          ; fall through to ReturnSpaceNotFudged

; ====================
; ReturnSpaceNotFudged
; ====================

; this function acts like ReturnSpace, but avoids the nasty fudge
; of the start of directory to ReallyShared (which is a bit nasty)

; it can only be used for Big dirs.  it must be

; entry:
;  R0 new file length
;  R1 old file length
;  R2 Ind Disc address of file
;  R3 dir ind disc add
;  R4 -> dir entry
;  R5 -> dir start, MUST NOT BE FUDGED
;  r6 -> dir entry to start search at for ReallySharedNotFudged

; exit: IF error V set, R0 result


ReturnSpaceNotFudged ROUT
 [ Debug5 :LOR: DebugX
        DLINE   "new len :old len :ind disc:dir     :DirEntry:DirStart enter ReturnSpaceNotFudged"
        DREG   R0," ",cc
        DREG   R1," ",cc
        DREG   R2," ",cc
        DREG   R3," ",cc
        DREG   R4," ",cc
        DREG   R5," ",cc
        DREG   R6," "
 ]
        Push    "R0-R4,R6-R11,LR"
        BL      RoundUpAlloc    ;(R0,R3->R0)
        MOV     R6, R0
        MOV     R0, R1
        BL      RoundUpAlloc    ;(R0,R3->R0)
      [ BigFiles
        TEQ     R6, #RoundedTo4G
        MOVEQ   R7, #&FFFFFFFF
        MOVNE   R7, R6
        TEQ     R0, #RoundedTo4G
        MOVEQ   R1, #&FFFFFFFF
        MOVNE   R1, R0

        SUBS    LR, R1, R7
      |
        SUBS    R1, R0, R6      ;length of returned space
      ]
        BLS     %FT90           ;nothing to return

        TSTS    R2, #&FF
        BEQ     %FT15           ;not shared obj

        TEQS    R6, #0
        BNE     %FT90           ;IF not returning whole obj then done

        Push    "R6"
        LDR     R6, [SP, #6*4]           ;recover entry R4
        BL      ReallySharedNotFudged    ;(R2-R6->Z)
        Pull    "R6"
        BEQ     %FT90           ;IF frag shared then done

        BIC     R2, R2, #&FF
15
        BL      CritInitReadNewFs   ;(->R10,R11)
        LDRB    LR, [R10,#ZoneHead+DiscRecord_Log2bpmb]
      [ BigFiles
        TEQ     R6, #RoundedTo4G
        ASSERT  RoundedTo4G = 1
        MOVEQ   R6, R6, ROR LR
        MOVNE   R6, R6, LSR LR  ;new length in map bits
        TEQ     R0, #RoundedTo4G
        MOVEQ   R7, R0, ROR LR
        MOVNE   R7, R0, LSR LR  ;old length in map bits
      |
        MOV     R6, R6, LSR LR  ;new length in map bits
        MOV     R7, R0, LSR LR  ;old length in map bits
      ]
        MOV     R9, #-1         ;don't know about pre gaps yet
20
        MOV     R1, R6
        BL      FindFragment    ;(R1,R2,R9,R10->R1,R9,R11,LR)
        SUB     R0, R1, R11     ;new length
        ADD     R1, R0, LR      ;old length = new length + length returning
        Push    "R2"
        MOV     R2, R11
        SUB     R7, R7, LR      ;decrement length left, may go -ve
        MOV     R3, R9
        BL      ShortenFrag     ;(R0-R3,R10)
        Pull    "R2"
        CMPS    R6, R7          ;loop until whole file returned
        BLT     %BT20           ;LT rather than LO as R7 may be -ve
        BL      InvalidateFragCache
90
        MOV     R0, #0
95
        BL      SetVOnR0
 [ Debug5 :LOR: DebugX
        BVC     %FT96
        DREG   R0," ",cc
96
        DLINE "leave ReturnSpaceNotFudged"
 ]
        STRVS   R0, [SP]
        Pull    "R0-R4,R6-R11,PC"


 [ :LNOT: BigDirFullBackup

; ================
; BigDirBackupMove
; ================

; construct the backup entries

; entry:

; r0 - source addr
; r1 - dest addr
; r2 - number of bytes (word multiple)

BigDirBackupMove ROUT
        Push    "R0-R2,LR"

        CMP     R2, #0
        BEQ     %FT95

        ADD     R0, R0, #BigDirIndDiscAdd

10
        LDR     LR, [R0], #BigDirEntrySize
        SUBS    R2, R2, #4
        STR     LR, [R1], #4
        BNE     %BT10
95
        Pull    "R0-R2,PC"
 ]

 ] ; BigDir

        LTORG
        END
@


4.13
log
@Fixes in BigSectors option
Previous testing with RAMFS was limited by the size of RAM disc, and hence complexity of layout, meaning some cases with BigSectors were missed.
FileCore20.s: During mount, when loading the defect list from the boot block at &C00, take care to round down the source sector address to account for it only being aligned up to 1k sectors (but not for 2k and 4k).
FileCore25.s: When loading the head of a BigDir (to find out its actual size) and finding it to be > 2k, skip loading the bit from 2k-4k, since that was already loaded when the head was read in, and reading it a second time offset by 2k fails the head/tail check.
FileCore31.s: When building a table to decide which zones to compact, use FindBuffer() to get some temporary store if too large to fit into ScratchSpace.
Identify.s: Comment updated.
BigDirCode.s: (Unrelated) Fix for bad error pointer being passed back, due to R0 being restored on encountering an error during directory rename.

FSBashed for 300k cycles on Titanium with an assortment of manufacturer drives, capacities, and sector sizes.

Version 3.74. Tagged as 'FileCore-3_74'
@
text
@d1489 1
a1489 1
        MOVS    R5, R5, LSR #9  ;link bits
@


4.12
log
@[415] Report dir full when hitting dir size limit
FileCore would allow objects to be added to BigDir extensible directories until eventually failing and leaving an unopenable broken directory behind.
In fact, the on disc directory was sound, but after updating the parent in GrowBigDir it would reload the child into the dir cache with FindDir, FindDir called SanityCheckBigDirHeader which was rejecting BigDir's of exactly 4MB that was created moments earlier.
Now, during the initial attempt grow, a check is made for exceeding BigDirMaxSize before trying to enlarge the dynamic area (while it would be possible to translate the error from maxing out the dynamic area, there could be situations where there genuinely isn't enough memory to enlarge the area) and a more polite "Dir full" error returned.
Tested with an initially empty drive (so the dynamic area must grow) and with one that previously created a maximal directory (dynamic area already large enough).

Also tightened up a couple of places loading byte wide variables using LDR, relying on the modulo 31 properties of LSR/LSL, when we can simply load the value as a byte for the same cost.

Version 3.72. Tagged as 'FileCore-3_72'
@
text
@d2469 1
@


4.11
log
@Avoid unnecessary remainder calculations
Detail:
  s/BigDirCode, s/Identify - Avoid unnecessary remainder calculation in DivRem macro
Admin:
  Tested on Cortex-A15


Version 3.69. Tagged as 'FileCore-3_69'
@
text
@d119 3
a121 1
        MOVS    r1, lr, LSR #22
d125 1
a125 1
        DLINE   "Failed at BigDirSize too large"
d1444 4
a1447 1
        BL      TryGrowDirBuf
d1458 2
a1459 2
        LDR     R7, [LR, #DiscRecord_Log2SectorSize]   ; sector size
        LDR     LR, [LR, #DiscRecord_BigMap_ShareSize]    ; share size
@


4.10
log
@Fix stack imbalance in big directory error handling
Detail:
  s/BigDirCode - Fix stack imbalance in GrowBigDir when DefaultMoveData returns an error
Admin:
  Tested on Raspberry Pi


Version 3.66. Tagged as 'FileCore-3_66'
@
text
@d870 1
a870 1
        DivRem  r8, lr, r9, r4                  ; r8 = offset into dir
@


4.9
log
@Reenable background transfer support when BigFiles is {TRUE}
BigDirCode.s: Retire BigDirFix switch, it wasn't actually a fix, it was more that the directory format was changed early in development, but there's no point keeping support for the prototype any more
FileCore45.s/FileCore25.s/FileCore31.s/FileCore35.s/DebugOpts.s: Retire BigDirFix
Defns.s: Shock addition of some comments
FileCore.s: Manual inclusion of CPU/Arch no longer needed
FileCore70.s: Crucially apply the same 1k dead band to the FileSwitch "write zeros" entry point, since it (along with Get/PutBytes) are the only places file offsets get passed
FileCore80.s: Lots of tedious and subtle boundary cases fixed
InitDieSvc.s: Removed the disabling switch
doc/BigDisc/ADFSBuffer: Detail what the BufFlags mean

Tested on ADFS (the only background-transferring filing system about) with LFAUs of 2k, 4k, 8k, 16k and bashing 65536 iterations.

Version 3.57. Tagged as 'FileCore-3_57'
@
text
@d1582 1
a1583 1
        Pull    "R1,R3,R4"
@


4.8
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@a247 1
 [ BigDirFix
a248 1

a250 5
 |
        ASSERT  BigDirEntrySize=32

        ADD     R0, R0, R1, LSL #5              ; 32 bytes per entry
 ]
a347 1
 [ BigDirFix
a350 4
 |
        ASSERT  BigDirEntrySize=32
        ADD     R4, R4, R9, LSL #5      ; pointer to current entry
 ]
a598 1
 [ BigDirFix
a601 4
 |
        ASSERT  BigDirEntrySize=32
        ADD     R6, R6, LR, LSL #5
 ]
a641 1
 [ BigDirFix
a644 5
 |
        ASSERT  BigDirEntrySize=32

        ADD     R6, R5, R6, LSL #5              ; name heap
 ]
a668 1
        ADD     LR, LR, R4, LSL #5              ; entry
a1069 1
 [ BigDirFix
d1075 1
a1075 9
        SUB     R0, R0, LR, LSL #5              ; *32
  ]
 |
        ASSERT  BigDirEntrySize=32
  [ BigDirFullBackup
        SUB     R0, R0, LR, LSL #6              ; TWO copies of entries
  |
        SUB     R0, R0, LR, LSL #5
        SUB     R0, R0, LR, LSL #2              ; *36
a1076 1
 ]
a1186 1
 [ BigDirFix
d1190 1
a1190 4
 |
        ASSERT  BigDirEntrySize=32
        ADD     R2, R2, LR, LSL #5
 ]
a1236 5
 [ :LNOT: BigDirFix
        LDR     LR, DirE
        STR     LR, [R4, #BigDirEntryName]      ; give the entry a DirE
 ]

a1512 1
 [ BigDirFix
d1516 1
a1516 4
 |
        ASSERT  BigDirEntrySize=32
        MOV     R4, R4, LSL #5          ; will never be dir itself
 ]
a1932 6
; =====================================================================

 [ :LNOT: BigDirFix
DirE
 = "DirE"
 ]
a2433 1
 [ BigDirFix
d2437 1
a2437 4
 |
        ASSERT  BigDirEntrySize=32
        ADD     R2, LR, R2, LSL #5
 ]
a2848 1
        Push    "R0-R4,R6-R11,LR"
d2859 1
@


4.7
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d1651 2
a1652 2
        BIC     R1, R3, #&ff            ; pretend to be unshared
        BL      MeasureFileAllocSize_GotMap             ; allocated size
d1708 1
a1708 1
        BL      RoundUp                 ; round to allocation unit
d2066 1
a2066 2
        BL      MeasureFileAllocSize_GotMap     ; (r1->r0)

d2069 1
a2069 6
        BL      ReadAllocSize                   ; (R3->LR)
        SUB     LR, LR, #1                      ; alloc size -1
        ADD     R1, R7, LR
        BIC     R1, R1, LR                      ; size rounded up

        MOV     R0, R1                          ; R0 = rounded up size wanted
d2072 1
a2072 1
        MOV     R1, R1, LSR LR                  ; number of map bits needed for object
a2874 3

 [ {FALSE}

d2879 1
a2879 118
; this function acts like ReturnWholeSpace, but avoids the nasty fudge
; of the start of directory to ReallyShared (which is a bit nasty)

; it also doesn't need the old length of the file; this avoids the need
; to call MeasureFileAllocSize

; it can only be used for Big dirs.  it must be

; entry:

;  R2 Ind Disc address of file
;  R3 dir ind disc add
;  R4 -> dir entry
;  R5 -> dir start, MUST NOT BE FUDGED
;  r6 -> dir entry to start search at for ReallySharedNotFudged

; exit: IF error V set, R0 result

; register allocation


ReturnWholeSpaceNotFudged
 [ Debug5 :LOR: DebugX
        DLINE   "new len :old len :ind disc:dir     :DirEntry:DirStart enter ReturnWholeSpaceNotFudged"
        DREG   R0," ",cc
        DREG   R1," ",cc
        DREG   R2," ",cc
        DREG   R3," ",cc
        DREG   R4," ",cc
        DREG   R5," ",cc
        DREG   R6," "
 ]
        Push    "R0-R4,R6-R11,LR"

        TSTS    R2, #&FF
        BEQ     %FT15           ;not shared obj
        TEQS    R6, #0
        BNE     %FT90           ;IF not returning whole obj then done
        Push    "R6"
        LDR     R6, [SP, #6*4]
        BL      ReallySharedNotFudged    ;(R2-R6->Z)
        Pull    "R6"
        BEQ     %FT90           ;IF frag shared then done
        BIC     R2, R2, #&FF

        BIC     R2, R2, #DiscBits
        MOV     R2, R2, LSR #8  ; idlen

15
        BL      CritInitReadNewFs   ;(->R10,R11)

        MOV     r0, #0          ;start from zone zero
        LDRB    r1, [R10, #ZoneHead+DiscRecord_NZones]
        LDRB    lr, [R10, #ZoneHead+DiscRecord_BigMap_NZones2]
        ADD     r1, r1, lr, LSL #8      ; number of zones in map

17
        BL      InitZoneObj     ; (R0, R10 -> R8, R9, R11, LR) prepare to work on this zone
        MOV     R3, R8          ;pre gap
        MOV     R6, LR          ;end of zone

20
        CMPS    R11, R6
        BHS     %FT50           ;end of zone
        TEQS    R9, R11
        BNE     %FT30           ;not gap

; gap
        BL      FreeRdLenLinkBits       ; (R10, R11 -> R7, R8)
        MOV     R3, R9                  ; update prev gap
        ADD     R9, R9, R8              ; update gap
        ADD     R11, R11, R7            ; and ptr

        B       %BT20

30
; not gap.  check if this is something we want to shorten
        BL      FragRdLenLinkBits       ; get frag length and bits
        TEQS    R8, R2
        ADDNE   r11, r11, r7
        BNE     %BT20                   ; if not match then don't bother shortening the frag

        Push    "R0-R2"
        MOV     r0, #0
        MOV     r1, r7
        MOV     r2, r11
        BL      ShortenFrag             ;(R0-R3,R10)
        Pull    "R0-R2"

        B       %BT17                   ;back round in this zone for more!



50
        ; end of this zone
        ADD     r0, r0, #1              ; advance to next zone
        TEQS    r0, r1                  ; run out of zones?
        BNE     %BT17                   ; no, back round zone

        BL      InvalidateFragCache

90
        MOV     R0, #0
95
        BL      SetVOnR0
 [ Debug5 :LOR: DebugX
        BVC     %FT96
        DREG   R0," ",cc
96
        DLINE "leave ReturnSpaceNotFudged"
 ]
        STRVS   R0, [SP]
        Pull    "R0-R4,R6-R11,PC"

 |
; =========================
; ReturnWholeSpaceNotFudged
; =========================
a2883 2
 ]

d2906 1
d2917 1
a2917 2
        Push    "R0-R4,R6-R11,LR"
        BL      RoundUp         ;(R0,R3->R0)
d2920 11
a2930 1
        BL      RoundUp
d2932 1
a2934 1

d2937 1
d2940 1
a2948 1

d2950 13
a2962 3
        LDRB    R7, [R10,#ZoneHead+DiscRecord_Log2bpmb]
        MOV     R6, R6, LSR R7  ;new length in map bits
        MOV     R7, R0, LSR R7  ;old length in map bits
@


4.6
log
@Fix asasm 2.00 errors
Detail:
  s/BigDirCode, s/FileCore20, s/FileCore33 - Fixed some operators which were missing their end colon
Admin:
  Identical binary under objasm


Version 3.49. Retagged as 'FileCore-3_49'
@
text
@d89 1
a89 1
        LDR     lr, [r5, #BigDirStartName]      ; and get StarName from Dir
d1495 1
a1495 1
        BL      DiscAddToRec            ; get disc record
d1577 1
a1577 1
        BL      ReadLen                 ; (R4->LR)
d1915 1
a1915 1
        BL      DiscAddToRec    ; get disc record
d1955 1
a1955 1
        BL      WriteLen        ; write the length
d2182 1
a2182 1
        BL      DiscAddToRec    ; get disc record
d2219 1
a2219 1
        BL      WriteLen
d2307 1
a2307 1
        BL      ReadLen         ;(R4->LR)
d3058 1
a3058 1
        LDR     R6, [SP, #6*4]
d3062 1
a3063 1

a3084 1

@


4.5
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d2291 1
a2291 1
 [ DebugX :LOR DebugXr
@


4.4
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d33 1
a33 1
        LDRB    R0, [LR,#DiscVersion]
d84 2
a85 2
	ADD	lr, r5, #BigDirName
	DSTRING	lr, "sanity check; name: "
d243 1
a243 1
 	ADD	R0, R0, #4
d674 1
a674 1
;	DREG	LR, "name ptr:"
d725 2
a726 2
	DREG	r1, "WildCheck(wild=",cc
	DLINE	")"
d729 1
a729 1
	Push	"R0, R1, LR"
d731 1
a731 1
	SUB	R1, R1, #1	; get to just before term (NextChar skips one)
d733 8
a740 8
	BL	NextChar	; get next wild character
	BCS	%FT20
	TEQS	R0, #DelimChar
	BEQ	%FT20

	TEQS	R0, #OneWildChar	; is this a wildcard?
	TEQNES	R0, #MultiWildChar
        BNE	%BT10
d744 1
a744 1
	DLINE	"wildcard found"
d746 1
a746 1
	Pull	"R0, R1, PC"
d750 1
a750 1
	MOVS	R0, #1
d753 1
a753 1
	DLINE	"no wildcard"
d756 1
a756 1
	Pull	"R0, R1, PC"
d793 2
a794 2
	BL	WildCheck		; is it wildcarded?
	BNE	%FT99			; no!
d875 1
a875 1
	Push	"r8, r9"
d877 1
a877 1
	ADD	r4, r4, #BigDirEntrySize
d880 2
a881 2
	MOV	r8, r4				; R4 = size of an entry
	BL	GetDirFirstEntry		; (R3,R5->R4)
d883 1
a883 1
	SUB	lr, r8, r4			; offset in bytes between start entry and thing
d885 1
a885 1
	MOV	r9, #BigDirEntrySize		; size of a dir entry
d888 4
a891 4
	DREG	r8, "r8 : "
	DREG	lr, "lr : "
	DREG	r9, "r9 : "
	DREG	r4, "r4 : "
d894 1
a894 1
	DivRem	r8, lr, r9, r4			; r8 = offset into dir
d897 1
a897 1
	DREG	r8, "init offset: "
d900 2
a901 2
	LDR	r9, [r5, #BigDirEntries]	; number of entries in the dir
	SUB	r9, r9, r8			; difference
d904 1
a904 1
	DREG	r9, "init range: "
d907 2
a908 2
	CMPS	r9, #0
	BNE	%FT05
d910 1
a910 1
	; not found
d912 2
a913 2
	BL	GetDirFirstEntry		; (R3,R5->R4)
	ASSERT	BigDirEntrySize=28
d918 1
a918 1
	SEC
d920 1
a920 1
	Pull	"r8, r9"
d922 1
a922 1
	B	%BT90
d928 1
a928 1
;	ADD	lr, r9, #1
d930 2
a931 2
	DREG	r8, "start: "
	DREG	r9, "len: "
d933 1
a933 1
	ADD	r8, r8, r9, LSR #1		; r8 <- offset of entry to look into
d935 2
a936 2
	BL	GetDirFirstEntry		; (R3,R5->R4)
	ASSERT	BigDirEntrySize=28
d951 1
a951 1
	BEQ	%FT80			; name=wild
d953 1
a953 1
	BCC	%FT20			; name<wild
d955 2
a956 2
	CMPS	r9, #1
	BEQ	%FT75
d960 1
a960 1
	DLINE	"name>wild"
d962 3
a964 3
	SUB	r8, r8, r9, LSR #1
	MOV	r9, r9, LSR #1
	B	%BT05
d968 1
a968 1
	DLINE	"name<wild"
d970 2
a971 2
	CMPS	r9, #1
	BEQ	%FT70
d973 4
a976 4
	ADD	r8, r8, #1
	SUB	r9, r9, #1
	MOVS	r9, r9, LSR #1
	BNE	%BT05			; if it's zero then it's not found
d980 2
a981 2
	; not found
	ADD	R4, R4, #BigDirEntrySize
d983 3
a985 3
	SEC
	Pull	"R8, R9"
	B	%BT90
d991 1
a991 1
	DLINE	"Match, but..."
d1009 1
a1009 1
	Pull	"R8, R9"
d1011 1
a1011 1
	B	%BT90
d1108 1
a1108 1
        SUB	R0, R0, LR, LSL #2		; *36
d1162 1
a1162 1
        ADD	R0, R0, #4
d1354 1
a1354 1
	DSTRING	R1, "WriteBigName : "
d1385 1
a1385 1
	DSTRING	R1, "WriteBigDirName : "
d1387 1
a1387 1
        MOV	R6, #0
d1393 1
a1393 1
        ADDCC	R6, R6, #1
d1398 1
a1398 1
	STR	R6, [R5, #BigDirNameLen]
d1496 2
a1497 2
        LDR     R7, [LR, #SectorSize]   ; sector size
        LDR     LR, [LR, #ShareSize]    ; share size
d1540 1
a1540 1
        BNE     %FT25		;note: this is a termination case due to the sorting of the dir
d1601 1
a1601 1
	BL	ReadIndDiscAdd
d1611 1
a1611 1
	CMP	r8, lr
d1616 1
a1616 1
 	BL	Flush		;flush the file of interest
d1639 2
a1640 2
        CMP	R1, #-1
        STRNE	R2, [R1, #FcbIndDiscAdd]
d1690 2
a1691 2
	ADD	R7, R7, #262144		; 64K allocation?
	MOV	R10, R7
d1700 1
a1700 1
        MOV	R0, R10
d1704 1
a1704 1
        MOV	R0, R7
d1706 1
a1706 1
        BL	CritInitReadNewFs	; (->R10, R11)
d1708 1
a1708 1
	BL	RoundUp			; round to allocation unit
d1712 1
a1712 1
        LDRB    R8, [LR, #BitSize]      ; convert units to map bits
d1727 4
a1730 4
 	DREG	R1, "map ptr : "
 	DREG    R11, "frag at : "
 	DREG    LR,  "remains : "
 	DREG	R0, "new len : "
d1743 2
a1744 2
 	BNE	%FT01
 	DLINE	"Frag disappearing entirely"
d1749 1
a1749 1
        Push	"LR"
d1751 1
a1751 1
	BL	MinMapObj			; (R10->LR)
d1753 1
a1753 1
	MOV	R8, LR				; keep it around
d1755 1
a1755 1
	Pull	"LR"
d1769 1
a1769 1
        LDRB    R2, [R10, #ZoneHead+BitSize]    ; size of a map bit
d1777 1
a1777 1
        LDRB    R8, [R10, #ZoneHead+LinkBits]   ; get LinkBits again
d1781 1
a1781 1
        BGE     %FT40                           ; shortening by more than LinkBits+1, so safe
d1789 1
a1789 1
; here when shortening by less than LinkBits+1.  check that object followed by a gap
d1797 1
a1797 1
	BCS	%FT35				; exhausted, so no gap
d1806 1
a1806 1
        LDRB    R8, [R10, #ZoneHead+BitSize]
d1829 1
a1829 1
        LDRB    R9, [R10, #ZoneHead+LinkBits]
d1831 1
a1831 1
        DREG    R9, "LinkBits:"
d1842 1
a1842 1
        LDRB    R9, [R10, #ZoneHead+BitSize]
d1917 1
a1917 1
        STR     R7, [LR, #RootDirSize]          ; store the root dir size in the disc record
d1931 1
a1931 1
        STR     R7, [R10, #ZoneHead+RootDirSize]
d2077 1
a2077 1
        LDRB    LR, [R10, #ZoneHead+BitSize]
d2095 1
a2095 1
        Push	"LR"
d2097 2
a2098 2
	BL	MinMapObj			; (R10->LR)
	MOV	R8, LR
d2100 1
a2100 1
	Pull	"LR"
d2114 1
a2114 1
        LDRB    R2, [R10, #ZoneHead+BitSize]    ; size of a map bit
d2122 1
a2122 1
        LDRB    R8, [R10, #ZoneHead+LinkBits]   ; get LinkBits again
d2126 1
a2126 1
        BGE     %FT40                           ; shortening by more than LinkBits+1, so safe
d2134 1
a2134 1
; here when shortening by less than LinkBits+1.  check that object followed by a gap
d2142 1
a2142 1
	BCS	%FT35
d2151 1
a2151 1
        LDRB    R8, [R10, #ZoneHead+BitSize]
d2184 1
a2184 1
        STR     R7, [LR, #RootDirSize]          ; store the root dir size in the disc record
d2188 1
a2188 1
 	LDR	r10, [r10, #DrvsFsMapAddr]
d2197 1
a2197 1
        STR     R7, [R10, #ZoneHead+RootDirSize]
d2293 1
a2293 1
	DREG	r3, "source dir ind disc add: "
d2303 1
a2303 1
	DREG	r9, "Ind disc add of object being moved: "
d2330 1
a2330 1
	DREG	R3, "Dest ind dir: "
d2366 1
a2366 1
 	DREG	R2, "From allocated name length: "
d2378 1
a2378 1
 	DSTRING	LR, "and: "
d2402 1
a2402 1
	BVS	%FT90
d2537 1
a2537 1
	DLINE	"filling in and writing out new parent dir"
d2549 2
a2550 2
	LDR	lr, [r5, #BigDirEntries]
	DREG	lr, "entries: "
d2569 1
a2569 1
	DLINE	"check for duff rename"
d2574 2
a2575 2
	DREG	R3, "start from: "
	DREG	r9, "renaming: "
d2579 1
a2579 1
        LDR     R0, [LR,#RootDir]
d2584 2
a2585 2
	DREG	R3, "compare ",cc
	DREG	R9, "with "
d2592 1
a2592 1
	DREG	R3, "parent is:"
d2599 1
a2599 1
	DLINE	"rename OK"
d2604 1
a2604 1
	DREG	R3, "retrieving new parent dir: "
d2665 1
a2665 1
	DREG	R1, "Updated length is..."
d2674 1
a2674 1
	DLINE	"renaming of shared object"
d2692 1
a2692 1
	DebugError "Error after DefaultMoveData: "
d2711 6
a2716 6
	DLINE	"about to write target dir"
	LDR	lr, [r5, #BigDirEntries]
	DREG	lr, "entries: "
	DREG	r3, "In disc add in R3:"
	BVC	%FT01
	DLINE	"V set before WriteFsMapThenDir!"
d2722 1
a2722 1
	DebugError "error when writing fsmap then dir: "
d2729 1
a2729 1
	DLINE	"renaming of unshared object"
d2731 1
a2731 1
	LDR	R1, [SP, #BigDirEntrySize]	; get term again
d2739 1
a2739 1
	DLINE	"object now in destination dir"
d2742 1
a2742 1
	MOVVC	R1,R3
d2812 1
a2812 1
	LDRVC	R1, [R5, #BigDirSize]	; return new size of dir
d2814 2
a2815 2
	BVC	%FT01
	DREG	R1, "New dir size: "
d2817 1
a2817 1
	DebugError	"Error from MaybeGrowBigDirForName: "
d2857 1
a2857 1
	B	%FT10
d2933 2
a2934 2
	BIC	R2, R2, #DiscBits
	MOV	R2, R2, LSR #8	; linkbits
d2939 4
a2942 4
	MOV	r0, #0		;start from zone zero
	LDRB	r1, [R10, #ZoneHead+Zones]
	LDRB	lr, [R10, #ZoneHead+Zones2]
	ADD	r1, r1, lr, LSL #8	; number of zones in map
d2945 3
a2947 3
	BL	InitZoneObj	; (R0, R10 -> R8, R9, R11, LR) prepare to work on this zone
        MOV	R3, R8		;pre gap
	MOV	R6, LR		;end of zone
d2950 4
a2953 4
	CMPS	R11, R6
	BHS	%FT50		;end of zone
	TEQS	R9, R11
	BNE	%FT30		;not gap
d2956 4
a2959 4
	BL	FreeRdLenLinkBits    	; (R10, R11 -> R7, R8)
	MOV	R3, R9		     	; update prev gap
	ADD	R9, R9, R8	     	; update gap
	ADD	R11, R11, R7		; and ptr
d2961 1
a2961 1
	B	%BT20
d2965 11
a2975 11
	BL	FragRdLenLinkBits	; get frag length and bits
	TEQS	R8, R2
	ADDNE	r11, r11, r7
	BNE	%BT20			; if not match then don't bother shortening the frag

	Push	"R0-R2"
	MOV	r0, #0
	MOV	r1, r7
	MOV	r2, r11
        BL      ShortenFrag     	;(R0-R3,R10)
	Pull	"R0-R2"
d2977 1
a2977 1
	B	%BT17			;back round in this zone for more!
d2982 4
a2985 4
	; end of this zone
	ADD	r0, r0, #1		; advance to next zone
	TEQS	r0, r1			; run out of zones?
	BNE	%BT17			; no, back round zone
d3067 1
a3067 1
        LDRB    R7, [R10,#ZoneHead+BitSize]
d3115 1
a3115 1
	Push	"R0-R2,LR"
d3117 2
a3118 2
	CMP     R2, #0
	BEQ     %FT95
d3120 1
a3120 1
	ADD	R0, R0, #BigDirIndDiscAdd
d3123 4
a3126 4
	LDR	LR, [R0], #BigDirEntrySize
	SUBS	R2, R2, #4
	STR	LR, [R1], #4
	BNE     %BT10
d3128 1
a3128 1
	Pull	"R0-R2,PC"
@


4.3
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  Many of these are unaligned LDRs where only bits 0-7 of the result are used
  (tested against a bitmask or used as an input to the barrel shifter) but
  they have all been moved to byte operations because they are faster on
  ARMv6 and won't cause false positives if unaligned aborts are enabled.

  s.BigDirCode line 104: not wrong as such, but changed to use aligned LDR
    for speed on ARMv6.
  s.BigDirCode line 1727: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.Commands line 129: STR to an unaligned 1-byte variable. Harmless because
    all overlapping variables are initialised later on.
  s.Commands line 539: LDR of an unaligned 1-byte variable. Only used for
    testing bit 6.
  s.FileCore31 line 1359: LDR of an unaligned 1-byte variable. Only used as
    input to shifter.
  s.FileCore32 lines 1483 and 1825: LDR of an unaligned 1-byte variable. Only
    used as input to shifter.
  s.FormSWIs line 1403: bugfix: incorrect load of 16-bit zone_spare field of
    disc record - uses lowsector and nzones fields instead! This is used to
    terminate the search of free space fragments within the allocation bytes
    of the current map block for the one containing a bad block found during
    formatting. Would manifest itself as a "Can't map defect out" error.
  s.GenSWIs lines 1182,1195: bugfix: LDR of 1-byte variables. Effect of this
    was that range-checking of the drive number passed to FileCore_MiscOp 5
    (eject) wasn't performed.
  Added ENTRY directive to permit building of GPA debug listing.
Admin:
  Builds, but untested.

Version 3.34. Tagged as 'FileCore-3_34'
@
text
@a19 3
	GBLL	MBFix
MBFix	SETL	T

a1600 1
 [ MBFix
d1602 1
a1602 1
 ]
d1611 1
a1611 5
 [ MBFix
	CMP	r8,lr
 |
        CMPS    R8, r1
 ]
a1639 1
 [ MBFix
a1640 3
 |
        STREQ	R2, [R1, #FcbIndDiscAdd]
 ]
d1689 1
a1689 1
 [ F
@


4.2
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d101 3
a103 2
        LDR     lr, [r5, #BigDirVersion]
        MOVS    lr, lr, LSL #8
d1724 1
a1724 1
        LDR     R8, [LR, #BitSize]      ; convert units to map bits
@


4.1
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d584 1
a584 1
        Pull    "r0,r1,r2,r9,pc",,^
d646 2
a647 1
        Push    "R5,R6,R7,LR"
d679 2
a680 1
        Pull    "R5,R6,R7,PC",,^
d710 1
a710 1
        Pull    "PC",,^
d1032 2
a1033 1
        Push    "LR"
d1046 2
a1047 1
        Pull    "PC",,^
d1050 2
a1051 1
        Pull    "PC",,^
d1072 1
a1072 1
        Pull    "PC",,^
d1125 1
a1125 1
        Pull    "R0, PC",,^
d1196 1
d1303 1
a1303 1
        Pull    "R0-R11,PC",EQ,^                                ; if Z=1 then finished
d1315 3
a1317 1
        Pull    "R0-R11,PC",,^                          ; if C=1 then finished
d1339 1
a1339 1
        Pull    "R5,R11,PC",,^
d1371 1
a1371 1
        Pull    "R0-R2,R4,PC",,^
d1401 1
a1401 1
        Pull    "R0-R2,R4,R6,PC",,^
d1418 1
a1418 1
        Pull    "R11,PC",,^
a2317 1
 [ NewFs
a2322 1
 ]
a2555 1
 [ NewFs
a2556 3
 |
        MOV     R0, R11         ;old atts
 ]
d2707 1
a2707 1
	LDRVC	R1, [SP, #BigDirEntrySize]	; get term again
d2719 1
a2719 1
	BL	InvalidateBufDir
d3139 1
a3139 1
	Pull	"R0-R2,PC",,^
@


1.1
log
@file BigDirCode was initially added on branch Ursula.
@
text
@d1 3143
@


1.1.2.1
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@a0 47
; Copyright 1997 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; BigDirCode

	TTL	"Big directory support code"
 [ BigDir

; ==========
; TestBigDir
; ==========

; test for long filenames on this disc

; entry: R3=disc address

; exit  Z=1 <=> big directories, C,V preserved, LR->disc rec

TestBigDir ROUT
        Push    "R0,LR"
        BL      DiscAddToRec            ;(R3->LR)
        LDRB    R0, [LR,#DiscVersion]
        TEQS    R0, #1
 [ DebugX
        BNE     %FT01
        DLINE   "big dir"
        B       %FT02
01
        DLINE   "not big dir"
02
 ]
        Pull    "R0,PC"

 ]
	LTORG
	END
@


1.1.2.2
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@d35 1
a35 1
 [ DebugX :LAND: {FALSE}
d37 1
a37 1
        DLINE   " big dir ",cc
d40 1
a40 1
        DLINE   " not big dir ",cc
a44 653
; =======================
; SanityCheckBigDirHeader
; =======================

; checks that a big directory's header is acceptable.

; used by FindDir to ensure that a directory seems ok-ish
; before going any further, to avoid nasty crash-type
; situations caused by stupid values appearing.

; checks:

; 1) that BigDirStartName is correct
; 2) that BigDirVersion is 0
; 3) that the size of the directory is a multiple of NewDirSize

; any other checks are left until the entire directory is read

; entry:

;   R5 points to the directory's header

; exit:

;   if error, R0 result, V set

SBProven
 = "SBPr"
 = "oven"

Name
 = "Name"


SanityCheckBigDirHeader	ROUT
	Push	"R0,R1,LR"
	
 [ DebugX
 	DLINE   ">SanityCheckBigDirHeader"
 ]
	
	LDR	r1, SBProven			; get "SBPr"
	LDR	lr, [r5, #BigDirStartName]	; and get StarName from Dir
	TEQS    r1,lr                           ; is it broke?
 [ DebugX
 	BEQ	%FT01
 	DLINE	"Failed at BigDirStartMasSeq"
01
 ]
	BNE     %FT95
	
	LDR	lr, [r5, #BigDirVersion]
	MOVS	lr, lr, LSL #8

 [ DebugX
 	BEQ	%FT01
 	DLINE	"Failed at BigDirVersion"
01
 ]
	BNE     %FT95

	LDR	lr, [r5, #BigDirSize]
	MOVS	r1, lr, LSL #21		; bottom 11 bits must be clear
	
 [ DebugX
 	BEQ	%FT01
 	DLINE	"Failed at BigDirSize not multiple of 2048"
01
 ]
	BNE     %FT95

	MOVS	r1, lr, LSR #22

 [ DebugX
 	BEQ	%FT01
 	DLINE	"Failed at BigDirSize too large"
01
 ]

95
	MOVNE	R0, #BrokenDirErr
	MOVEQ	R0, #0
	BL	SetVOnR0
	STRVS	R0, [SP]
 [ DebugX
 	DLINE	"<SanityCheckBigDirHeader"
 ]
	Pull	"R0,R1,PC"

; ===========
; CheckBigDir
; ===========

; Check dir is well formed

; entry: R3=dir disc add, R5->dir start, R6->dir end, R10 0 -> don't check the check
; bytes, R10=1-> do check it

; exit:  IF error V set, R0 result

CheckBigDir ROUT
	Push	"R0,R1,R10,R11,LR"
 [ DebugX
 	DLINE	">CheckBigDir"
 ]
 
 [ DebugX
 	LDR	R1, [R5, #BigDirNameLen]
 	DREG	R1, "dir's name length is:"
 ]
 	
 	baddr	R1, SBProven
 	LDMIA	R1, {R1, R11}
 	
 	LDR	LR, [R5, #BigDirStartName]
 	
 	TEQS	LR, R1				; is the StartName Ok?
 
 [ DebugX
 	BEQ	%FT01
 	DLINE	"Failed at SBPr"
01
 ]
 	LDREQB	R0, [R5,#BigDirStartMasSeq]
 	LDREQB	LR, [R6,#BigDirEndMasSeq]
 	TEQS	R0, LR
 	
 [ DebugX
 	BEQ	%FT01
 	DLINE	"Failed at sequences"
01
 ]
 	LDREQ	LR, [R6, #BigDirEndName]
 	TEQEQS	LR, R11
 
 [ DebugX
 	BEQ	%FT01
 	DLINE	"Failed at endname"
 	DREG	LR, "End name read was:"
01
 ]
 	MOV	R0, #0
 	BNE	%FT90
 	
        MOVS    R10,R10                 ;quick flag
        BLNE    TestDirCheckByte        ;(R3,R5,R6->LR,Z)
 
90
        BEQ     %FT95
 [ DebugX
 	DLINE	"Big dir broken"
 ]
        MOV     R0, #BrokenDirErr
        LDR     LR, BufDir
        TEQS    LR, R3
        BLEQ    InvalidateBufDir
        BEQ     %FT95
        BL      TryCache                ;(R3->R11,V)
        BLVC    InvalidateDirCache      ;if a dir in cache is broken, scrap whole cache
95
        BL      SetVOnR0
        STRVS   R0, [SP]
 
 [ DebugX
 	DLINE	"<CheckBigDir"
 ]
 	Pull	"R0,R1,R10,R11,PC"

; ===================
; TestBigDirCheckByte
; ===================

; entry
;  R3 ind disc add of dir
;  R5 -> dir start
;  R6 -> dir end

; exit
;  LR check byte
;  Z  set if matches existing byte

TestBigDirCheckByte	ROUT
	Push	"R0-R2,R5,R7,LR"

 [ DebugX
 	DLINE	">TestBigDirCheckByte"
 	DREG	R5, "dir at:"
 ]

; first, work out the size of the first area to accumulate

	MOV	R2,#0	; zero the acc.
	
	LDR	R0, [R5, #BigDirNameLen]
	
	ADD	R0, R0, #3
	BIC	R0, R0, #3			; name len
	
	LDR	R1, [R5, #BigDirEntries]	; number of entries
	
	ASSERT	BigDirEntrySize=32
	
	ADD	R0, R0, R1, LSL #5		; 32 bytes per entry
	
	LDR	R1, [R5,#BigDirNamesSize]	; size of the heap of names
	
	ADD	R0, R0, R1
	
	ADD	R0, R0, #BigDirHeaderSize
	
 [ DebugX
 	DREG	R0, "bytes to check:"
 ]
	
	ADD	R0, R0, R5			; now R0 points to first word after names

10
	LDR	LR, [R5], #4
	EOR	R2, LR, R2, ROR #13
	TEQS	R5, R0
	BNE	%BT10

; now the tail
	ADD	R5, R6, #BigDirEndName
	LDR	LR, [R5], #4
	EOR	R2, LR, R2, ROR #13
	SUB	R0, R6, #1
	
	ASSERT	BigDirCheckByte=-1
	
20
	LDRB	LR, [R5], #1
	EOR	R2, LR, R2, ROR #13
	TEQS	R5, R0
	BNE	%BT20
	
        EOR     R2, R2, R2, LSR #16     ;reduce to 8 bits
        EOR     R2, R2, R2, LSR #8
        AND     R2, R2, #&FF
        
        LDRB	LR, [R6,#BigDirCheckByte]
        TEQS	R2, LR
 [ DebugX
 	DREG	LR, "check byte"
 	DREG	R2, "value:"
 ]
        MOV	LR, R2
		
 [ DebugX
 	DLINE	"<TestBigDirCheckByte"
 ]
 
 	Pull	"R0-R2,R5,R7,PC"

; ================= 
; ReadBigDirEntries
; =================

; entry:

; R3 indirect disc addr of dir
; R5 pointer to big dir
; R7 buffer ptr
; R8 number of names to transfer
; R9 offset in dir
; R10 buffer end
; R11 fsfunc reason code

; exit:

; R5=number of names transferred
; R9=new offset

; all other regs may be corrupted except R12, R13

; while running;

; R4=pointer to current entry

ReadBigDirEntries	ROUT
	Push	"R0,R1,R2,R9,lr"
 [ DebugX
 	DLINE	">ReadBigDirEntries"
 ]
	LDR	r1, [r5, #BigDirEntries]	; get the number of entries in the dir
 [ DebugX
 	DREG	r1, "dir entries:"
 	DREG	r9, "index value:"
 ]
	CMP	r9, r1			; check if offset too large
	MOVHS	r9, #-1
	MOVHS	R5, #0
	BHS	%FT95			; nothing transferred

; this still to be implemented!

; common set-up code

	BL	GetDirFirstEntry	; (R3,R5->R4)
	
	ASSERT	BigDirEntrySize=32
	ADD	R4, R4, R9, LSL #5	; pointer to current entry

	TEQS	R11, #fsfunc_ReadDirEntriesInfo
	BEQ	%FT20
	
	TEQS	R11, #fsfunc_ReadDirEntries
	BEQ	%FT40
	
	TEQS	R11, #fsfunc_CatalogObjects
	BEQ	%FT60
	
	B	%FT95

20
	ADD	R7, R7, #3	; word align it
	BIC	R7, R7, #3
	SUB	LR, R10, R7
	LDR	R0, [R4, #BigDirObNameLen]
 [ DebugX
 	DREG	R0, "name length:"
 ]
	ADD	R0, R0, #&15+3
	BIC	R0, R0, #3
	CMPS	R0, LR			; space for entry?
 [ DebugX
 	DREG	LR, "space in buffer:"
 	DREG	R0, "space for entry:"
 	BLS	%FT01
 	DLINE	"Buffer overflowed"
01
 ]
	BHI	%FT25			; no space!
	
; have space for entry	
        BL      ReadIntAtts     ;(R3,R4->LR)
        TSTS    LR, #DirBit
        MOVEQ   R0, #1
        MOVNE   R0, #2
        BL      ReadLoad        ;(R3,R4->LR)
        STR     LR, [R7],#4
        BL      ReadExec        ;(R4->LR)
        STR     LR, [R7],#4
        BL      ReadLen         ;(R3,R4->LR)
        STR     LR, [R7],#4
        BL      ReadExtAtts     ;(R3,R4->LR)
        STR     LR, [R7],#4
        STR     R0, [R7],#4     ;atts

	LDR	R6, [R4, #BigDirObNameLen]
	Push	"R4"
	BL	GetBigDirName	;(R5,R6->LR)
	MOV	R4, LR
 [ DebugX
 	DSTRING	R4, "name:"
 ]
	BL	PutStringToBuf	;write the string to the buffer
	Pull	"R4"
	BLCC	Put0ToBuf
	
	BCS	%FT25		; buffer full
	
	ADD	R9, R9, #1
	ADD	R4, R4, #BigDirEntrySize
	BL	BigDirFinished
	BEQ	%FT30
	
	SUBS	R8, R8, #1
	BGT	%BT20

; finished count of entries to extract, but not finished dir

25
; here when buffer full or nothing left to do
	LDR	R8, [sp, #3*4]		; old offset in dir
	SUB	R5, R9, R8		; number of names transferred
	B	%FT95			; and exit
	
30
; end of dir
	LDR	R8, [sp, #3*4]		; old offset in dir
	SUB	R5, R9, R8		; number of names transferred
	MOV	R9, #-1			; finished
	B	%FT95			; and exit

40
	SUB	LR, R10, R7
	LDR	R0, [R4, #BigDirObNameLen]
	ADD	R0, R0, #1
	CMPS	R0, LR			; space for entry?
 [ DebugX
 	BLS	%FT01
 	DLINE	"Buffer overflowed"
01
 ]
	BHI	%FT45			; no space!
	
	LDR	R6, [R4, #BigDirObNameLen]
	Push	"R4"
	BL	GetBigDirName	;(R5,R6->LR)
	MOV	R4, LR
 [ DebugX
 	DSTRING	R4, "name:"
 ]
	BL	PutStringToBuf	;write the string to the buffer
	Pull	"R4"
	BLCC	Put0ToBuf
	
	BCS	%FT45		; buffer full
	
	ADD	R9, R9, #1
	ADD	R4, R4, #BigDirEntrySize
	BL	BigDirFinished
	BEQ	%FT50
	
	SUBS	R8, R8, #1
	BGT	%BT40

; finished count of entries to extract, but not finished dir

45
; here when buffer full or nothing left to do
	LDR	R8, [sp, #3*4]		; old offset in dir
	SUB	R5, R9, R8		; number of names transferred
	B	%FT95			; and exit
	
50
; end of dir
	LDR	R8, [sp, #3*4]		; old offset in dir
	SUB	R5, R9, R8		; number of names transferred
	MOV	R9, #-1			; finished
	B	%FT95			; and exit


60 ; CatalogObjects
	ADD	R7, R7, #3	; word align it
	BIC	R7, R7, #3
	SUB	LR, R10, R7
	LDR	R0, [R4, #BigDirObNameLen]
 [ DebugX
 	DREG	R0, "name length:"
 ]
	ADD	R0, R0, #&1E+3
	BIC	R0, R0, #3
	CMPS	R0, LR			; space for entry?
 [ DebugX
 	DREG	LR, "space in buffer:"
 	DREG	R0, "space for entry:"
 	BLS	%FT01
 	DLINE	"Buffer overflowed"
01
 ]
	BHI	%FT65			; no space!
	
; have space for entry	
        BL      ReadIntAtts     ;(R3,R4->LR)
        TSTS    LR, #DirBit
        MOVEQ   R0, #1
        MOVNE   R0, #2
        BL      ReadLoad        ;(R3,R4->LR)
        STR     LR, [R7],#4
        CMNS    LR, #1 :SHL: 20 ;C=1 <=> stamped
        ANDCS   R1, LR, #&FF
        MOVCC   R1, #0
        BL      ReadExec        ;(R4->LR)
        MOVCS   R2, LR
        MOVCC   R2, #0
        STR     LR, [R7],#4
        BL      ReadLen         ;(R3,R4->LR)
        STR     LR, [R7],#4
        BL      ReadExtAtts     ;(R3,R4->LR)
        STR     LR, [R7],#4
        STR     R0, [R7],#4     ;atts
        BL	ReadIndDiscAdd	;(R3,R4->LR)
        BIC	LR, LR, #DiscBits
        STR	LR, [R7], #4
        STR	R2, [R7], #4
        STRB	R1, [R7], #1

	LDR	R6, [R4, #BigDirObNameLen]
	Push	"R4"
	BL	GetBigDirName	;(R5,R6->LR)
	MOV	R4, LR
 [ DebugX
 	DSTRING	R4, "name:"
 ]
	BL	PutStringToBuf	;write the string to the buffer
	Pull	"R4"
	BLCC	Put0ToBuf
	
	BCS	%FT65		; buffer full
	
	ADD	R9, R9, #1
	ADD	R4, R4, #BigDirEntrySize
	BL	BigDirFinished
	BEQ	%FT70
	
	SUBS	R8, R8, #1
	BGT	%BT60

; finished count of entries to extract, but not finished dir

65
; here when buffer full or nothing left to do
	LDR	R8, [sp, #3*4]		; old offset in dir
	SUB	R5, R9, R8		; number of names transferred
	B	%FT95			; and exit
	
70
; end of dir
	LDR	R8, [sp, #3*4]		; old offset in dir
	SUB	R5, R9, R8		; number of names transferred
	MOV	R9, #-1			; finished
	B	%FT95			; and exit
	

95
	STR	r9, [sp,#3*4]
 [ DebugX
 	DLINE	"<ReadBigDirEntries"
 ]
 	Pull	"r0,r1,r2,r9,pc",,^


; ==============
; BigDirFinished
; ==============

; entry:

; R5=pointer to dir
; R4=dir entry ptr

; exit:

; CS if entry is beyond end of entries, LR=entries in dir

BigDirFinished ROUT
	Push	"R4,LR"
 [ DebugX
 	DLINE	">BigDirFinished"
 	DREG	R5, "dir at:"
 	DREG	R4, "entry at:"
 ]
	LDR	LR, [R5, #BigDirNameLen]
	ADD	LR, LR, #3
	BIC	LR, LR, #3
	SUB	R4, R4, LR
	SUB	R4, R4, R5
	SUB	R4, R4, #BigDirHeaderSize
	MOV	R4, R4, LSR #5
	LDR	LR, [R5, #BigDirEntries]
 [ DebugX
 	DREG	R4, "  entry:"
 	DREG	LR, "entries:"
 ]
	CMPS	R4, LR
	MOVHI	R4, LR
	TEQS    R4, LR
	Pull	"R4,PC"

; =============
; GetBigDirName
; =============

; entry: R5=dir start, R4=pointer to entry

; exit: LR=pointer to name (NOT header)

; if entry is after end of entries, returns pointer to what would
; be name after name heap

GetBigDirName ROUT
	Push	"R5,R6,R7,LR"
	
	BL	BigDirFinished			; is it finished
	LDREQ	R7, [R5, #BigDirNamesSize]	; size of names heap
	
	LDR	LR, [R5, #BigDirNameLen]
	LDR	R6, [R5, #BigDirEntries]
	ADD	LR, LR, #3
	BIC	LR, LR, #3
	ADD	R5, R5, LR
	ADD	R5, R5, #BigDirHeaderSize
	
; R5 now points at entries
	ASSERT	BigDirEntrySize=32
	
	ADD	R6, R5, R6, LSL #5		; name heap
	
	LDRNE	R5, [R4, #BigDirObNamePtr]	; offset into name heap
	ADDNE	LR, R5, R6
	ADDEQ	LR, R7, R6			; end of name heap
	ADD	LR, LR, #8			; pointer to name
	
	Pull	"R5,R6,R7,PC",,^

; =================
; ReadBigDirIntAtts
; =================

; entry: R3=disc address of dir
;        R4=index of entry in dir
;        R5=start of dir

; exit:  LR=atts

ReadBigDirIntAtts ROUT
	Push	"LR"
	ADD	LR, LR, R4, LSL #5		; entry

	LDRB	LR, [R4, #BigDirAtts]		; read the bottom 8 bits of atts

 [ DebugX
 	DREG	LR, " ", cc
 	DLINE	"=Big Atts"
 ]
        TSTS    LR, #DirBit
 [ FullAtts
        ASSERT  IntAttMask = &FF
 |
        ANDEQ   LR, LR, #IntAttMask
 ]
        ANDNE   LR, LR, #IntDirAttMask
		
	Pull	"PC",,^

; ============
; LookUpBigDir
; ============

; look up wild card spec term in dir

; entry:
;  R1   -> term, terminated by control codes ,delete ,space or delimiter
;  R2   name restriction bits, only 'must be file' and 'must be dir' apply
;  R3   disc address of dir
;  R4   -> entry in dir to start at (or following entry if C=1)
;  R5   pointer to start of dir

; exit:

; IF found R4=index of entry in dir, Z=1 <=> file, C=0
; ELSE     R4->next alphabetical entry, C=1

LookUpBigDir	ROUT
 [ DebugX
        DREG    r1,"LookUpBigDir(wild=",cc
        DREG    r2,",restrict=",cc
        DREG    r3,",dir=",cc
        DREG    r4,",index ",cc
        DREG	r5,",dir start ",cc
        DLINE   ")",cc
a45 1685
        Push	"r7,LR"
        
	SUBCC	r4,r4,#BigDirEntrySize	; caller asked to start at this entry
	MOV	R7, #0
10
	ADD	r4,r4,#BigDirEntrySize
	BL	BigDirFinished		; (R4,R5->eq->dir finished)
	BNE     %FT11

	; end of dir
	TEQ	r7, #0
	MOVNE	r4, r7
	SEC
	B	%FT90			; carry already set
	
11
	Push	"R4,R5,R6"
 	LDR	R6, [R4, #BigDirObNameLen]
	BL	GetBigDirName		; get the name's address (in LR)
	MOV	R4, LR
	MOV	r5, #&ff		; mask is ff
	BL	BigLexEqv		; (R1,R4,R5->LO/EQ/HI)
	Pull	"R4,R5,R6"
	
	BCC	%BT10			;if mismatch and name<wild try next
	BEQ	%FT15			;EQ=>match

12
	;mismatch and name >wild done
	TEQ	r7, #0			; doesn't affect C
	MOVEQ	r7, r4
	BCS	%BT10			
	
	; completion in the not found case
	
	MOV	r4, r7
	SEC				; set carry (not found)
	B	%FT90

15
	; Match, but...
	BL	ReadBigDirIntAtts	; read the attributes

;LR=Atts
	TSTS	LR, #DirBit
	BNE	%FT20			; found a dir
;found a file
	
        TSTS    R2, #MustBeDir
        BNE     %BT10
;fall through next few instructions as EQ
20
        TSTNES  R2, #MustBeFile
        BNE     %BT10

        TSTS    LR, #DirBit :SHL: 2,2 ;restore Z=1 <=> file, C=0
90
 [ Debug6
        DREG    r4,"->(entry=",cc
        BCC     %FT01
        DLINE   ",not found)"
        B       %FT02
01
	BNE	%FT01
	DLINE	" file ",cc
01
        DLINE   ",found)"
02
 ]
95
	Pull	"R7,PC"

; ================
; GetDirFirstEntry
; ================

; entry:

; R3 = dir ind disc address
; R5 = dir start

; exit:

; R4 points to first entry

GetDirFirstEntry ROUT
	Push	"LR"

	BL	TestBigDir
	
	BNE	%FT01				; not a big dir
	
	LDR	LR, [R5, #BigDirNameLen]
	ADD	LR, LR, #3
	BIC	LR, LR, #3
	
	ADD	R4, R5, LR
	ADD	R4, R4, #BigDirHeaderSize
	
	Pull	"PC",,^
01
	ADD	R4,R5,#DirFirstEntry		; not a big dir
	Pull	"PC",,^

; ============
; NextDirEntry
; ============

; entry:

; R3=ind disc add
; R4->dir entry

; exit: r4->next dir entry

NextDirEntry ROUT
	Push	"LR"
	
	BL	TestBigDir
	ADDEQ	R4, R4, #BigDirEntrySize
	ASSERT  NewDirEntrySz=OldDirEntrySz
	ADDNE	R4,R4,#NewDirEntrySz
	
	Pull	"PC",,^

; ===============
; BigDirFreeSpace
; ===============

; entry:

; R5 -> dir start

; exit:

; LR number of bytes of unused space in the directory (always a word multiple)

BigDirFreeSpace ROUT 
	Push	"R0,LR"

 [ DebugX
 	DLINE	">BigDirFreeSpace"
 ]
	LDR	R0, [R5, #BigDirSize]		; size of the directory
	SUB	R0, R0, #BigDirHeaderSize + BigDirTailSize
	LDR	LR, [R5, #BigDirEntries]
	
	ASSERT	BigDirEntrySize=32
	
	SUB	R0, R0, LR, LSL #6		; TWO copies of entries
	LDR	LR, [R5, #BigDirNameLen]	; length of dir name
	ADD 	LR, LR, #3
	BIC	LR, LR, #3
	SUB	R0, R0, LR
	
	LDR	LR, [R5, #BigDirNamesSize]	; size of the names heap
	SUB	LR, R0, LR			; now LR is the number of free bytes in the dir

 [ DebugX
 	DREG	LR, "<BigDirFreeSpace"
 ]
	Pull	"R0, PC",,^

; ============
; IsBigDirFull
; ============

; entry: 

; R1 -> last term of name
; R3 top 3 bits disc id
; R5 -> dir start

; exit:
;   IF full, V set, R0 result

; number of bytes free in a big dir is:

; size of dir - (header size + tail size) - (size for all entries) - size of name heap

IsBigDirFull ROUT
	Push	"R0,R1,R2,R6,LR"
	
	BL	BigDirFreeSpace			; (R5->LR)
	MOV	R6, LR	
	; now get the number of bytes needed for the new entry:
	
	MOV	R2, R1				; keep start of term
	
	BL	SkipTerm			; (R1->R0,R1)
	
	SUB	R0, R1, R2			; length of term
	
	ADD	R0, R0, #3
	BIC	R0, R0, #3
	
	ADD	R0, R0, #BigDirEntrySize*2+BigDirHeapHeaderSize
	
 [ DebugX
 	DREG	R0, "size needed:"
 	DREG	R6, "size available:"
 ]
 	CMPS	R0, R6
 	MOVHI	R0, #DirFullErr
 	MOVLS	R0, #0
 	BL	SetVOnR0
 	STRVS	R0, [SP]
	
	Pull	"R0,R1,R2,R6,PC"

; ===============
; MakeBigDirSpace
; ===============

; make space for a new entry in RAM copy of a directory
; ASSUMES DIR IS NOT FULL can check this with IsDirFull

; entry:

;  R1->term
;  R3 ind disc address
;  R4 -> entry
;  R5 -> dir start
;  R6 -> dir end

MakeBigDirSpace ROUT
	Push	"R0-R11,LR"

 [ DebugX
; 	BL	DumpBigDir
 ]
	
	MOV	R2, R1
	BL	SkipTerm		; (R1->R0,R1)
	SUB	R8, R1, R2		; R8 = term length
	ADD	R6, R8, #3+BigDirHeapHeaderSize		; size of header for name
	BIC	R6, R6, #3		; R6 = extra required in name heap
	
; now we can find the entry in the name heap, and bump everything up

	BL	GetBigDirName		; (R4,R5->LR)
	
	SUB	LR, LR, #BigDirHeapHeaderSize

; LR = name heap entry
	MOV	R0, LR			; source for block move
	ADD	R1, R0, R6
	ADD	R1, R1, #BigDirEntrySize ; dest for block move

; length for move
	LDR	R2, [R5, #BigDirNameLen];length of dir name
	ADD	R2, R2, #3+BigDirHeaderSize
	BIC	R2, R2, #3
	LDR	LR, [R5, #BigDirEntries]
	ASSERT	BigDirEntrySize=32
	ADD	R2, R2, LR, LSL #5
	LDR	LR, [R5, #BigDirNamesSize] ; size of the heap of names
	
	ADD	R2, R2, LR		; word after name heap
	ADD	R2, R2, R5
	
	SUB	R2, R2, R0		; length of move

 [ DebugX
 	DLINE	"Moving upper section of names"
 	DREG	R0, "source="
 	DREG	R1, "  dest="
 	DREG	R2, "   len="
 ]

	BL	BlockMove		; do the block move

; ensure that the 'name' field is filled in

	ADRL	LR, Name		; get the name
	LDR	LR, [LR]
	
	ADD	R7, R0, #BigDirEntrySize
	
	STR	LR, [R7,#BigDirHeapObName]	; and store it
	ADD	R0, R7, #4
	SUB	R1, R6, #4
	BL	ZeroRam			; zero rest of the entry
	

; R7 now points to start of new name heap entry

	MOV	R0, R4
	ADD	R1, R4, #BigDirEntrySize
	SUB	R2, R7, R1		; amount to move

 [ DebugX
 	DLINE	"Moving entries and lower section of names"
 	DREG	R0, "source="
 	DREG	R1, "  dest="
 	DREG	R2, "   len="
 ]
 
 	BL	BlockMove
 	
; now update dir header fields
	LDR	LR, [R5, #BigDirEntries]	; number of entries
	ADD	LR, LR, #1
	STR	LR, [R5, #BigDirEntries]	; new number of entries

	LDR	LR, [R5, #BigDirNamesSize]	; size of names heap
	ADD	LR, LR, R6
	STR	LR, [R5, #BigDirNamesSize]	; new number of entries

	LDR	LR, DirE
	STR	LR, [R4, #BigDirEntryName]	; give the entry a DirE
	
; finally, generate new offsets into the name heap

	ADD	R4, R4, #BigDirEntrySize
	
	BL	BigDirFinished			; (R4, R5->C)

; C=0->can use next entry
; C=1->next entry not there, so use size of heap take R6
	LDRNE	LR, [R4, #BigDirObNamePtr] 
	LDREQ	LR, [R5, #BigDirNamesSize]
	SUBEQ	LR, LR, R6
	
	STR	LR, [R4, #BigDirObNamePtr-BigDirEntrySize]	; copy it
; 
 [ DebugX
 	DREG	R8, "storing name len of:"
 ]
	STR	R8, [R4, #BigDirObNameLen-BigDirEntrySize]	; and set the name length
	
; now, bump all the other name indexes up by R6

	Pull	"R0-R11,PC",EQ,^				; if Z=1 then finished

10
	LDR	LR, [R4, #BigDirObNamePtr]
	ADD	LR, LR, R6			; new pointer
	STR	LR, [R4, #BigDirObNamePtr]
	ADD	R4, R4, #BigDirEntrySize
	BL	BigDirFinished			; (R4, R5->C)
	BNE	%BT10
 [ DebugX
; 	BL	DumpBigDir
 ]
	Pull	"R0-R11,PC",,^				; if C=1 then finished

 [ DebugX

; r5-dir start

DumpBigDir ROUT
	Push	"R5,R11,LR"				; save regs
	DLINE	"Directory dump:"
	
	LDR	R11, [R5, #BigDirSize]			; size of dir
10
	LDR	LR, [R5], #4				; get a word
	DREG	LR, " ",cc				; dump it
	AND	LR, R11, #4*7				; is it end of line
	CMPS	LR, #4*7
	BEQ	%FT01
	DLINE	" "
01
	SUBS	R11, R11, #4
	BGT	%BT10

	Pull	"R5,R11,PC",,^
 ]

; ============
; WriteBigName
; ============

; copy file name string to dir entry

; entry:
;  R1 -> name
;  R4 -> entry
;  R5 -> dir start

WriteBigName ROUT
	Push	"R0-R2,R4,LR"
	LDR	R2, [R4, #BigDirObNameLen]
	ADD	R2, R2, #3
	BIC	R2, R2, #3	; up to word boundary
	BL	GetBigDirName	; (R4,R5->LR)
	MOV	R4, LR
10
        BL      ThisChar        ;(R1->R0,C)
        ADD     R1, R1, #1
        MOVCS   R0, #CR         ;if terminator
        STRB    R0, [R4],#1
        BCS     %FT90
        SUBS    R2, R2, #1
        BNE     %BT10
90
        Pull    "R0-R2,R4,PC",,^


; ===============
; WriteBigDirName
; ===============

; copy dir name string into big dir

; entry:
; R1->name
; R5->dir

WriteBigDirName ROUT
	Push	"R0-R2,R4,LR"
	ADD	R4, R5, #BigDirHeaderSize
10
        BL      ThisChar        ;(R1->R0,C)
        ADD     R1, R1, #1
        MOVCS   R0, #CR         ;if terminator
        BCS     %FT90
        STRB    R0, [R4],#1
        B       %BT10
90
	LDR	R2, [SP, #4]
	SUB	R2, R1, R2	;length of name
	ADD	LR, R2, #1
	ANDS	LR, LR, #3
	STRNEB	R0, [R4, #1]	;if space, put a CR in
	STR	R2, [R5, #BigDirNameLen]
        Pull    "R0-R2,R4,PC",,^

; ================
; WriteBigDirNames
; ================

; entry: R5->start of dir
;        R6->end

WriteBigDirNames ROUT
	Push	"R11,LR"
	
	ADRL	R11, SBProven
	LDMIA	R11, {R11, LR}
	STR	R11, [R5, #BigDirStartName]
	STR	LR, [R6, #BigDirEndName]
	
	Pull	"R11,PC",,^

; =============
; TryGrowDirBuf
; =============

; entry R4 required size of dir buf

; exit

; if error, VS and R0->error

TryGrowDirBuf ROUT
	Push	"R0-R8,LR"	; stuff
 [ DebugX
 	DREG	R4,"entry TryGrowDirBuf - need: "
 ]
 	; because DA size may be rounded up to a page, we read the real size here
 	MOV	R0, #2			; read area size
 	LDR	R1, DirBufferArea	; area addr
 	BL	OnlyXOS_DynamicArea	; do the SWI call
 	BVS	%FT95
 	
 	STR	R2, DirBufferSize	; if it's already small enough then we're OK
 	
 	LDR	R4, [SP, #4*4]		; get back the size needed
 	
 	CMP	R4, R2			; do we need more space
 	BLS	%FT94			; no
 	
 	MOV	R0, R1			; area number to R0
 	SUB	R1, R4, R2		; amount needed
 	BL	OnlyXOS_ChangeDynamicArea
 	BVS	%FT95
 	
 	ADD	R2, R2, R1		; number of bytes added to area
 	STR	R2, DirBufferSize	; etc
94
	CLRV				; clear the V flag
95
	STRVS	R0, [SP]		; if V set then store the error
 [ DebugX
 	DLINE	"Exit TryGrowDirBuf"
 ]
	Pull	"R0-R8,PC"	; other stuff

; ==========
; GrowBigDir
; ==========

; entry:

; R3  =  dir ind disc address
; R5  -> dir start
; R6  -> dir end

; dir is in DirBuffer


GrowBigDir ROUT
	Push	"R0-R11,LR"
 [ DebugX
 	DLINE	"entering GrowBigDir"
 	DREG	R3, "dir "
 	DREG	R5, "at  "
 ]
; first of all, ensure have enough memory for dir of required size
	SUB	R4, R6, R5		; current dir size
	ADD	R4, R4, #BigDirMinSize	; add a bit to it
	BL	TryGrowDirBuf
	BVS	%FT99
	
; loop back to here when need to move more files
10
	LDR	R3, [SP, #3*4]
	LDR	R6, [SP, #6*4]
	LDR	R5, [SP, #5*4]
	SUB	R4, R6, R5
	ADD	R4, R4, #BigDirMinSize	; size required
	BL	DiscAddToRec		; get disc record
	LDR	R7, [LR, #SectorSize]	; sector size
	LDR	LR, [LR, #ShareSize]	; share size
	ADD	R7, R7, LR
	MOV	R11, #1
	RSB	R11, R11,R11,LSL R7
	TSTS	R4, R11
	MOV	R9, R4, LSR R7
	ADDNE	R9, R9, #1		; sharing blocks needed for dir

 [ DebugX
 	DREG	R9, "dir needs ",cc
 	DLINE	" sharing blocks"
 ]

	BL	BeforeAlterFsMap	; (R3->R0,V)
	BVS	%FT99
	
	BL	CritInitReadNewFs	; (->R10,R11)
	
	BL	SortDir			; (R3,R5->R8)

20
	LDMIA	R8!, {R4, R5}		; get table entry
 	AND	R0, R5, #&FF	; r5 - sharing offset
 	TEQS	R5, #0
 	TEQEQS	R4, #0
 	BEQ	%FT50		;end of list marker found
 	MOVS	R5, R5, LSR #9	;link bits
        ADDCS   R5, R5, R3, LSR #8
        RSBCC   R5, R5, R3, LSR #8
 [ DebugX
        DREG    R0, "File sector:",cc
        DREG    R4, ", file index:",cc
        DREG    R5, ", link bits:"
 ]

	TEQS	R4, #0		;is it the dir itself?
	BEQ	%FT30
	
	TEQS	R5, R3, LSR #8	;is it the same object as the dir
	BNE	%FT50
	
	CMPS	R0, #1		;is the sharing offset 1?
	BEQ	%FT30

	CMPS	R0, R9		;is it in the way?
	BHI	%FT30		; no
	
	; an object is in the way
 [ DebugX
 	DREG	R0,"offset in the way:"
 ]
 	SUB	LR, r0, #1
 	MOV	R7, LR, LSL R7		; dummy dir size for ClaimFreeSpace
 	; find the offending dir entry
 	
 	ASSERT	BigDirEntrySize=32
 	MOV	R4, R4, LSL #5		; will never be dir itself
 	LDR	LR, DirBufferPtr
 	LDR	LR, [LR, #BigDirNameLen]
 	ADD	LR, LR, #3		
 	BIC	LR, LR, #3
 	ADD	R4, LR, R4
 	LDR	LR, DirBufferPtr
 	ADD	LR, LR,#BigDirHeaderSize-BigDirEntrySize
 	ADD	R4, R4, LR
 
  [ DebugX
 	BL	ReadIndDiscAdd		; (R4->LR)
	DREG	LR, "Ind disc add of entry:" 	
  ]
 	BL	ReadLen			; (R4->LR)
 	MOV	R10, LR			; length to claim
 	MOV	R11,#fsfile_Save	; reason code to ClaimFreeSpace
 	LDR	R5, [SP, #5*4]		; get the dir
 	ADD	R7, R7, R10		; increase dummy length
 	STR	R7, [R5, #BigDirSize]	; fake dir size (MUST restore later - see below)
 [ DebugX
 	DREG	R7, "dummy size:"
 ]
 	BL	ClaimFreeSpace		; claim space for object
  [ DebugX
  	BVC	%FT01
  	DLINE	"ClaimFreeSpace failed"
01
  ]
  	LDR	R6, [SP, #6*4]		;
  	SUB	R6, R6, R5
  	STR	R6, [R5, #BigDirSize]	; restore dir's original size MUST do this
 	BVS	%FT96
 	
  	BL	ReadIndDiscAdd
  	MOV	R1, LR
  [ DebugX
  	DREG	R2, "Ind disc add of new:"
  	DREG	R1, "and of old:"
  ]
  	
  	Push	"R3,R4"
  	MOV	R3, R10
  	BL	DefaultMoveData		; move the data
  	BVS	%FT96			; argh
  	Pull	"R3,R4"
 	
        sbaddr  lr, FirstFcb-FcbNext
        B       %FT02
01
        LDR     r8, [lr, #FcbIndDiscAdd]
 [ DebugX
        DREG    r8, "File in chain:"
 ]
        CMPS	R8, R1
        BNE	%FT02
 [ DebugX
        DLINE	"matches file we're interested in"
 ]
 	STR	R2, [lr, #FcbIndDiscAdd]
 	B	%FT03
02
        LDR     lr, [lr,#FcbNext];get next FCB
        CMPS    lr, #-1
        BNE     %BT01           ;file matches no FCB so not open, return EQ
03
 
 	MOV	R0, R2
 	BL	WriteIndDiscAdd	; update the dir
 	BL	WriteFsMapThenDir	; write the stuff out
 	BVS	%FT96		; err, this would be BAD
 	
 	BL	UnlockMap	; unlock the map
 	B	%BT10		; and try going round the loop again

30
	B	%BT20		; round the loop again

50	; SortDir didn't find any objects which clash.  do the grow operation, checking
	; it won't grow beyond MinMapObj
	
	BIC	R1, R3, #&ff		; pretend to be unshared
	BL	MeasureFileAllocSize_GotMap		; allocated size
 [ DebugX
 	DREG	R0, "space allocated to dir:"
 ]
	
	LDR	R5, [SP, #5*4]	; get the dir addr again
	LDR	R7, [R5, #BigDirSize] ; size of dir at present
	ADD	R7, R7, #BigDirMinSize
	CMPS	R7, R0
	BLS	%FT58
	
	; here we don't have any shared objects getting in the way, but we
	; don't have enough space allocated (how convenient).
	
	; we call ClaimFreeSpace with RandomAccessExtend reason code to
	; get things sorted out.  but we cheat.  because, y see, we don't
	; want to have to get the parent dir in just yet, with all that
	; copying around of data, so I'm gonna build a dummy dir entry
	; on the stack.  cunning, eh no?
	
	; we also then return most of the space anyway, cos RandomAccessExtend
	; has a tendency to allocate far too much space
	
	Push	"R3,R4,R6,R7"
	
	SUB	SP, SP, #BigDirEntrySize	; space for an entry
	MOV	R4, SP
	MOV	R6, R3			; keep addy around
	BL	ToParent		; get parent addy
	BIC	R6, R6, #DiscBits	; knock off DiscBits
	BIC	R6, R6, #&ff		; and pretend unshared
	STR	R6, [R4, #BigDirIndDiscAdd]
	SUB	LR, R7, #BigDirMinSize	; current size
	STR	LR, [R4, #BigDirLen]
	
	; only need IndDiscAdd and Len to be valid in the dummy entry.
	
	MOV	R10, R7			; size wanted
	MOV	R0, LR			; old extent
	MOV	R11, #RandomAccessExtend
	BL	ClaimFreeSpace		; (R0,R3,R4,R5,R10,R11->R0,R2,R10,V)
	BVS	%FT55
	
	Push	"R2,R4,R5,R8,R10"
	BL	RoundUp			; (R0,R3->R0)
	BL	DiscAddToRec		; (R3->LR)
	LDR	R8, [LR, #BitSize]	; convert units to map bits
	MOV	R1, R7, LSR R8		; length after rounding up
	BL	CritInitReadNewFs	; (->R10,R11)
	BL	DefFindFragment		; (R1,R2,R10->R1,R9,R11,LR)
	SUBS	R1,R1,R11		; R1 = offset in map bits into fragment
 [ DebugX
 	DREG	R1, "offset into fragment:"
 ]
	BEQ	%FT52			; no change needed as offset at frag start - removing frag entirely
	LDRB	R9, [R10, #ZoneHead+LinkBits]
 [ DebugX
 	DREG	R9, "LinkBits:"
 ]
	ADD	R9, R9, #1
	CMP	R1, R9
	BHS	%FT52			; no change needed as offset is more than idlen+1 into frag

 [ DebugX
 	DREG	R7,"too short:"
 ]
	; here if offset less than needed
	SUB	R1, R9, R1		; offset to add to R7
	LDRB	R9, [R10, #ZoneHead+BitSize]
	ADD	R7, R7, R1, LSL R9	; add it

 [ DebugX
 	DREG	R1, "amount to increase by:"
 	DREG	R9, "BitSize: "
 	DREG	R7, "changing to: "
 ]

52
	Pull	"R2,R4,R5,R8,R10"
	
	; now try to return excess space
	MOV	R0, R7			; new length
	MOV	R1, R10			; allocated length
	BL	ReturnSpace		; return the space
	
55
	ADD	SP, SP, #BigDirEntrySize
	Pull	"R3,R4,R6,R7"
	
	BVS	%FT96			; if error
	
	BL	WriteFsMap		; write out the FsMap.  extra space allocated after dir.
	
58
	; here we have enough space in the object
	; and there's no shared objects in the way
	; so let's do it.  first alter the dir

 [ DebugX
 	DLINE	"can grow dir... doing so"
 ]
	
	BL	InvalidateBufDir	; going to trash dir
	STR	R7, [R5, #BigDirSize]
	SUB	R0, R6, #BigDirTailSize
	ADD	R1, R0, #BigDirMinSize
	MOV	R2, #BigDirTailSize
	BL	BlockMove
	
 [ DebugX
 	DLINE	"Writing dir"
 	LDR	LR, [R5, #BigDirParent]
 	DREG	LR, "parent is:"
 ]
	BL	WriteDir	;write out the dir
	BVS	%FT96

 [ DebugX
 	DLINE	"Getting parent"
 	DREG	R3, "R3: "
 	DREG	R5, "R5: "
 ]
 	MOV	R8, R3		;keep ind disc add around
	BL	ToParent	;(R3,R5->R3)
 [ DebugX
 	DREG	R3, "Parent: "
 ]
	CMPS	R8, R3		;is it the root dir
	BNE	%FT55

 [ DebugX
 	DLINE	"It's the root dir - updating the FS map"
 ]
 	BL	DiscAddToRec	; get disc record

	STR	R7, [LR, #RootDirSize]		; store the root dir size in the disc record

        LDR     r10, CritDrvRec
        LDR     r10, [r10, #DrvsFsMap]
        BIC     r10, r10, #HiFsBits

        MOV     r1, #(ZoneHead*8)+Zone0Bits
        BL      MarkZone                ;(r1,r10)
        
        STR	R7, [R10, #ZoneHead+RootDirSize]

	BL	WriteFsMap
	BVS	%FT96
	B	%FT80
	
55
	
	BL	GetDir		; get the parent dir into dirbuf
	
	BL	GetDirFirstEntry	; get first entry in dir
	
	BL	InvalidateBufDir
	MOV	R0, R7		; length to write out
60
	BL	BigDirFinished ;(R4,R5->Z)
	BEQ	%FT70
	BL	ReadIndDiscAdd	; get ind disc add
	CMPS	LR, R8		; is it our object
	BEQ	%FT75
	ADD	R4, R4, #BigDirEntrySize
	B	%BT60

75
	BL	WriteLen	; write the length

70
	BL	WriteDir	; write the dir
	BVS	%FT96		; error!

80
	MOV	R3, R8		; get the original dir back into the dir buffer
	BL	GetDir	
	STRVC	R5, [SP, #4*5]
	STRVC	R6, [SP, #4*6]
	MOVVC	R0, #0
96
	BL	UnlockMap
	BL	SetVOnR0
99
	STRVS	R0, [SP]
 [ DebugX
 	DLINE	"exiting GrowBigDir"
 	BVC	%FT01
 	DREG	R0, "error:"
01
 ]
	Pull	"R0-R11,PC"

; =====================================================================

DirE
 = "DirE"

; ===============
; CanBigDirShrink
; =============== 

; entry:

; R5-> big dir in dir buffer
; R3   dir in disc add

CanBigDirShrink ROUT
	Push	"R0,LR"
 [ DebugX
 	DLINE	">CanBigDirShrink"
 ]

	BL	BigDirFreeSpace			; (R5->LR)
	MOV	R0, LR
 [ DebugX
 	DREG	R0, "free space:"
 ]
	
	MOV	LR, #BigDirMinSize
	SUB	LR, LR, #1
	BICS	R0, R0, LR			; clear bottom bits
	MOVNE	R0, #-1				; -1 if non-0
	MVNS	R0, R0				; Z=1 if can shrink
 [ DebugX
 	BNE	%FT01
 	DLINE	"can shrink"
01
 	DLINE	"<CanBigDirShrink"
 ]
	Pull	"R0,PC"


; ============
; ShrinkBigDir
; ============

; entry:

; R3=dir ind disc add
; R5->dir (in dir buffer)

; disc has already been BeforeAlterFsMapped

; exit: if error then R0->error block and V set

ShrinkBigDir ROUT
	Push	"R0-R11,LR"

 [ DebugX
 	DLINE	">ShrinkBigDir"
 ]

	BL	BigDirFreeSpace			; (R5->LR)	
	ASSERT	BigDirMinSize=2048
	
	MOV	R8, LR, LSR #11
	MOV	R8, R8, LSL #11			; number of bytes to shrink dir by
	
	BL	InvalidateBufDir		; going to alter BufDir

	LDR	R7, [R5, #BigDirSize]		; current size of dir
	ADD	R0, R5, R7
	SUB	R0, R0, #BigDirTailSize		; source for move
	SUB	R1, R0, R8			; dest for move
	MOV	R2, #BigDirTailSize		; size of tail
	BL	BlockMove                       ; do the move
	
	SUB	R7, R7, R8			; new size of dir
	STR	R7, [R5, #BigDirSize]

	BL	BigDirHasSharedObjects		; is it sharing with anything?
	BEQ	%FT50				; yes, sharing
	
	BL	CritInitReadNewFs		; (->R10,R11)
	
	BIC	R1, R3, #&ff
	BL	MeasureFileAllocSize_GotMap	; (r1->r0)

	BL	ReadAllocSize			; (R3->LR)
	SUB	LR, LR, #1			; alloc size -1
	ADD	R1, R7, LR
	BIC	R1, R1, LR			; size rounded up
	
	LDRB	LR, [R10, #ZoneHead+BitSize]
	MOV	R1, R1, LSR LR			; number of map bits needed for object
	
	BIC	R2, R3, #&ff
	
	BL	DefFindFragment			; (R1, R2, R10 -> R1, R9, R11, LR)
	
	; R1  - map ptr to desired offset
	; R11 - map ptr to fragment start
	SUB	R11, R1, R11			; offset from start of frag
	LDRB	LR, [R10, #ZoneHead+LinkBits]
	ADD	LR, LR, #1
	CMPS	R11, LR
	SUBLT	R11, LR, R11			; number of bits to change by
	LDRLTB	LR, [R10, #ZoneHead+BitSize]
	MOV	R1, R0
	ADDLT	R0, R7, R11, LSL LR		; adjust file offset
	MOVHS	R0, R7
	BL	ReturnSpace			; return allocated space
	
	BL	WriteDirThenFsMap
	BVS	%FT95
	B	%FT60

50	; sharing so just write the dir
	BL	WriteDir
	BVS	%FT95

60
	; now sort out the parent
	MOV	R2, R3				; keep ind disc add around
	BL	ToParent			; (R3, R5->R3)
	CMPS	R2, R3				; is it the root dir
	BNE	%FT70				; not root dir
	
	; alter the size in the disc record
	
 	BL	DiscAddToRec	; get disc record

	STR	R7, [LR, #RootDirSize]		; store the root dir size in the disc record

        LDR     r10, CritDrvRec
        LDR     r10, [r10, #DrvsFsMap]
        BIC     r10, r10, #HiFsBits

        MOV     r1, #(ZoneHead*8)+Zone0Bits
        BL      MarkZone                ;(r1,r10)
        
        STR	R7, [R10, #ZoneHead+RootDirSize]

	BL	WriteFsMap
	B	%FT95
	
70
	BL	GetDir
	BVS	%FT95				; can't get the dir!
	BL	GetDirFirstEntry		; (R3, R5->R4)

80
	BL	BigDirFinished			; (R4,R5->Z)
	BEQ	%FT95
	BL	ReadIndDiscAdd			; (R3,R4->LR)
	TEQ	R2,LR
	BEQ	%FT85
	ADD	R4, R4, #BigDirEntrySize
	B	%BT80
	
85
	; found dir entry, write updated length
	MOV	R0, R7
	BL	WriteLen
	BL	WriteDir

95
	STRVS	R0, [SP]
 [ DebugX
 	DLINE	"<ShrinkBigDir"
 ]

	Pull	"R0-R11,PC"

; ======================
; BigDirHasSharedObjects
; ======================

; tests if a big dir contains shared object
;
; entry - R3 = dir ind disc add
;         R5-> dir

; exit:   Z=1<=>dir shares space with file(s)

BigDirHasSharedObjects ROUT
	Push	"R1,R4, LR"

	BL	GetDirFirstEntry	; (R3, R5->R4)
	MOV	R1, R3, LSR #8

10
	BL	BigDirFinished		; (R5, R4 -> Z)
	BEQ	%FT90
	BL	ReadIndDiscAdd		; (R3, R4 -> LR)
	TEQS	R1, LR, LSR #8	; is it in the same disc object?
 [ DebugX
 	BNE	%FT01
 	DLINE	"dir shares with child"
01
 ]
	Pull	"R1, R4, PC",EQ
	ADD	R4, R4, #BigDirEntrySize
	B	%BT10
	
90	; run out of dir
	MOVS	R1, #1		; Z=0
 [ DebugX
 	DLINE	"dir does not share with child"
 ]
	
	Pull	"R1,R4, PC"


; ===================
; DoOsFunRenameBigDir
; ===================

; This function does OsFunRename for big dirs.  After initial work
; done by DoOsFunRename, this function is called.  We have a separate
; special function because there is extra complexity involved in
; doing the rename.

; entry:

; R2 -> new name
; R3 source dir ind disc add
; R4 entry in dir
; R5 -> dir start
; R6 -> first byte after dir

; exit if error, R0 = error, V set

DoOsFunRenameBigDir ROUT
	Push	"R1-R11, LR"
 [ DebugX
 	DLINE	">DoOsFunRenameBigDir"
 ]

; this bit same as for DoOsFunRename
	
        MOV     R7, R3
        SUB     R8, R4, R5
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        MOV     R9, LR
        BL      ReadIntAtts     ;(R3,R4->LR)
        MOV     R11,LR
 [ NewFs
        BL      ReadLen         ;(R4->LR)
        MOV     R10,LR
        MOV     R2, R9
        BL      ReallyShared    ;(R2-R5->Z)
        ORREQ   R11,R11,#1 :SHL: 31
 ]
        BL      IncUsage        ;(R3)

; need stack for dir entry, and ptr to new final component and new final component length
	SUB	SP, SP, #BigDirEntrySize+4+4
	MOV	R0, R4
	MOV	R1, SP
	MOV	R2, #BigDirEntrySize
	BL	BlockMove	; (R0-R2)

; now look up new name
        LDR     R1, [SP,#BigDirEntrySize+4+4+4] ;new name string
        AND     R2, R3, #DiscBits
        ORR     R2, R2, #MustBeRefDisc
        ORR     R2, R2, #DirToBuffer :OR: NotLastUp :OR: NotLastWild :OR: NotNulName
        BL      FullLookUp      ;(R1,R2->R0-R6,C,V)
        BVS     %FT05
        TEQS    R7, R3          ;if new obj already exists is it old obj
        SUB     LR, R4, R5
        TEQEQS  LR, R8
        BEQ     %FT07
        MOVNE   R0, #ExistsErr

05
        TEQS    R0, #NotFoundErr
        BNE     %FT85
        BL      ThisChar        ;(R1->R0,C)
        MOVCC   R0, #NotFoundErr
        BCC     %FT85           ;not terminator => not last term
        
07
        ; No need to explicitly ensure a new Id as this will be handled by WriteDir
        ; or writing the FSMap out.

        LDR     R0, [SP,#BigDirEntrySize+4+4+4];string start
        BL      TermStart       ;backtrack to start of last term (R0,R1->R1)
        
 [ DebugX
 	DSTRING	R1, "New final component:"
 ]

        STR     R1, [SP,#BigDirEntrySize]    ;final component new name

        ADD     R8, R8, R5      ;convert old entry offset to ptr
        TEQS    R3, R7
        BNE     %FT20           ;not in same dir
	
	; if renaming a directory, then before we can do anything else, we'll
	; need to ensure that there's space
	
	LDR	R2, [SP, #BigDirObNameLen]; get the old name length
	ADD	R2, R2, #3
	BIC	R2, R2, #3		; allocated length

 [ DebugX
 	DREG	R2, "Old allocated name length:"
 ]
	
	BL	SkipTerm		;(R1->R0,R1)
	LDR	LR, [SP, #BigDirEntrySize]
	SUB	R1, R1, LR		;new name length
	STR	R1, [SP, #BigDirEntrySize+4]	; store new name length
	ADD	R1, R1, #3
	BIC	R1, R1, #3		;new required allocated length
 [ DebugX
 	DREG	R1, "New required:"
 ]
	
	SUBS	R1, R1, R2		;extra required
 [ DebugX
 	DREG	R1, "Extra required for name:"
 ]
	BLE	%FT09			;no extra needed

	TSTS	R11, #DirBit
	BEQ	%FT08			;if not moving a dir then no need to thingy

	Push	"R3"
	MOV	R3, R9
	BL	MaybeGrowBigDirForName	;(R1,R3->R0,V)
	Pull	"R3"
	BVS	%FT90
	
	BL	GetDir			; get the parent dir back
	BVS	%FT90			; if error then error it is
	
	; dir's length may have changed, so update our copy of the entry
	LDR	LR, [R8, #BigDirSize]
	STR	LR, [SP, #BigDirSize]

08
 [ DebugX
 	DLINE	"Considering growing dir"
 ]
	BL	BigDirFreeSpace		; (R5->LR)
	CMPS	LR, R1
	BLLO	GrowBigDir		; (R3,R5,R6->R0, LR)
	BVS     %FT90                   ;

	; because dir entry may have been altered, take a copy
	MOV	R0, R8
	MOV	R1, SP
	MOV	R2, #BigDirEntrySize
	BL	BlockMove		;(R0,R1,R2)

09 ; here child and parent have grown as much as is required

; as case for big dirs is much harder to work out, we don't beat around the bush
	BL	InvalidateBufDir	; going to write this dir out
	Push	"R4"
	MOV	R4, R8			; dir entry being removed
	BL	RemoveDirEntryOnly	; remove just the dir entry, not allocated space
	Pull	"R4"
	CMPS	R4, R8
	SUBHI	R4, R4, #BigDirEntrySize	; bump down ptr if needs it
	
   ; now make space for the term
   	LDR	R1, [SP, #BigDirEntrySize] ; size of dir entry
   	BL	MakeBigDirSpace		; make space for entry
   	
   ; now copy entry excluding bits we don't want
   	MOV	R0, SP
   	MOV	R1, R4
   	MOV	R2, #BigDirObNameLen
   	BL	BlockMove		; copy entry
   	
   ; finally, the name
   	LDR	R1, [SP, #BigDirEntrySize]
   	BL	WriteBigName		; write the name
   	BL	WriteDir
   	BVS	%FT90
   	
   	BL	CanBigDirShrink
   	BLEQ	ShrinkBigDir
   	BVS	%FT90
   	
   ; now, go back to the child, and update its name
   	MOV	R1, R3
   	BL	%FT10
   	BVS	%FT90
   	
   	B	%FT80

10
; subroutine:
; job: write new name into child (and also parent dir if need be)

; R1  new parent dir
; R2  new name length
; R9  dir to rename
; R11 attributes
        Push    "R0,R1,R2,R3,R4,R6,R7,LR"
        TSTS    R11,#DirBit
        BEQ     %FT14
        MOV	R3, R9		;child dir
        LDR     R4, [SP,#8*4+BigDirEntrySize] ;final component new name
        BL      GetDir          ;(R3->R0,R5,R6,V)
        BVS	%FT14
        BL      InvalidateBufDir
        MOV     R3, R1
        BL      WriteParent     ;(R3,R5,R6)
	LDR  	R7, [R5, #BigDirNameLen]
	LDR	R6, [SP, #8*4+BigDirEntrySize+4]
	STR	R6, [R5, #BigDirNameLen]
 [ DebugX
 	DREG	R6, "new dir name length is:"
 	DREG	R7, "old dir name length is:"
 ]
	ADD	R6, R6, #3
	BIC	R6, R6, #3
	ADD	R7, R7, #3
	BIC	R7, R7, #3
	LDR	R2, [R5, #BigDirEntries]
	LDR	LR, [R5, #BigDirNamesSize]
	ASSERT	BigDirEntrySize=32
	ADD	R2, LR, R2, LSL #5
	ADD	R0, R5, #BigDirHeaderSize
	ADD	R0, R0, R7
	ADD	R1, R5, #BigDirHeaderSize
	ADD	R1, R1, R6
 [ DebugX
 	DREG	R0, "src:"
 	DREG	R1, "dst:"
 	DREG	R2, "len:"
 ]
	BL	BlockMove		; (R0, R1, R2)
	MOV	R1, R6
	ADD	R0, R5, #BigDirName
	BL	ZeroRam			; (R0, R1)
 [ DebugX
 	DREG	R0, "zer:"
 	DREG	R1, "len:"
 ]
	LDR	R6, [R5, #BigDirNameLen]
	ADD  	R7, R5, #BigDirName
        BL      PutMaskedString ;(R3,R4,R6,R7->R7)
        BL      WriteDir        ;(->R0,V)
	BVS	%FT14
	
	BL	CanBigDirShrink
	BLEQ	ShrinkBigDir
14
        Pull    "R0,R1,R2,R3,R4,R6,R7,PC"


15
; Subroutine:
;
; Job: Fill in and write out new parent dir
;
        Push    "R1,LR"
        LDR     R1, [SP,#2*4+BigDirEntrySize]  ;new name final component
        BL      WriteBigName       ;(R1,R4)
        ADD     R0, SP, #8      ;move copy of old dir entry back into new place
	MOV	R1, R4
	MOV	R2, #BigDirObNameLen
        BL      BlockMove       ;(R0-R2)
 [ NewFs
        AND     R0, R11,#IntAttMask
 |
        MOV     R0, R11         ;old atts
 ]
        BL      SetIntAtts      ;(R0,R3,R4) only needed for old format
        BL      IncObjSeqNum    ;(R3-R5)
        BL      WriteDir        ;(->R0,V)
        Pull    "R1,PC"

20 ; here when not in same dir

 [ DebugX
 	DLINE	"renaming across (big) dirs"
 ]

        TSTS    R11,#DirBit
        BEQ     %FT35

; If we're here then we're renaming a directory into a different directory
;
; Check not doing a duff rename

        MOV     R1, R3         ;if renaming dir walk up new path pathname
25
        BL      DiscAddToRec   ;(R3->LR)
        LDR     R0, [LR,#RootDir]
        TEQS    R3, R0          ;if meet root dir
        TEQNES  R3, R7          ;or old parent dir
        BEQ     %FT30           ;then ok
        TEQS    R3, R9          ;but if meet dir to rename
        MOVEQ   R0, #BadRenameErr;then moan
        BEQ     %FT85
        BL      ToParent        ;(R3,R6->R3)
        BL      FindDir         ;(R3->R0,R5,R6,V)
        BVS     %FT90
        B       %BT25
30
        MOV     R3, R1          ;retreive new parent dir
        BL      GetDir          ;(R3->R0,R5,R6,V)
        BVS     %FT90
35
; If we're here then we're renaming something into a different directory
; and its safe to do so (ie duff directory renames have been checked for)

	; check to see if we need to grow the new parent
	
	LDR	R1, [SP, #BigDirEntrySize]
	BL	IsBigDirFull
	BLVS	GrowBigDir	; need to grow new parent
	BVS	%FT90		; can't grow it
	
; here have grown new parent dir.  may also need to grow child if it's a dir

	; if renaming a directory, then before we can do anything else, we'll
	; need to ensure that there's space
	
	LDR	R2, [SP, #BigDirObNameLen]; get the old name length
	ADD	R2, R2, #3
	BIC	R2, R2, #3		; allocated length

 [ DebugX
 	DREG	R2, "Old allocated name length:"
 ]
	
	BL	SkipTerm		;(R1->R0,R1)
	LDR	LR, [SP, #BigDirEntrySize]
	SUB	R1, R1, LR		;new name length
	STR	R1, [SP, #BigDirEntrySize+4]	; store new name length
	ADD	R1, R1, #3
	BIC	R1, R1, #3		;new required allocated length
 [ DebugX
 	DREG	R1, "New required:"
 ]
	
	SUBS	R1, R1, R2		;extra required
 [ DebugX
 	DREG	R1, "Extra required for name:"
 ]
	BLE	%FT38			;no extra needed

	TSTS	R11, #DirBit
	BNE	%FT38		; not a dir, so don't bother

	Push	"R3"
	MOV	R3, R9
	BL	MaybeGrowBigDirForName	;(R1,R3->R0,V)
	Pull	"R3"
	BVS	%FT90
	
	BL	GetDir			; get the parent dir back
	BVS	%FT90			; if error then error it is
	
	; dir's length may have changed, so update our copy of the entry
	LDR	LR, [R8, #BigDirSize]
	STR	LR, [SP, #BigDirSize]

38
; here, if child is a dir, then it's as big as needs be

        BL      MakeBigDirSpace    ;(R3-R6)
        TSTS    R11,#1 :SHL: 31
        BEQ     %FT40

; If we're here then object being renamed is shared with something else. This
; means we've got to claim new space in the destination directory for it and copy
; the renamee across.

        BL      BeforeAlterFsMap
        BVS     %FT90
        Push    "R3,R4,R11"
        MOV     R11,#fsfile_Create
        BL      ClaimFreeSpace  ;(R3-R6,R10,R11->R0,R2,V)
        MOV     R6, R2

        MOVVC   R1, R9
        MOVVC   R3, R10
        BLVC    DefaultMoveData ;(R1-R3->R0-R4,V)
        Pull    "R3,R4,R11"

        LDRVC   R1, [SP,#BigDirEntrySize] ;new name final component
        BLVC    WriteBigName            ;(R1,R4,R5)
        MOVVC   R0, SP                  ;move copy of old dir entry back into new place
        MOVVC   R1, R4
        MOVVC   R2, #BigDirObNameLen
        BLVC    BlockMove               ;(R0-R2)
        MOVVC   R0, R6                          ;adjust ind disc add to new value
        BLVC    WriteIndDiscAdd ;(R0,R3,R4)

        BLVC    WriteFsMapThenDir       ;(->R0,V)
        BL      UnlockMap
        B       %FT45

40
        BL      %BT15
45
; Renaming object between directories and its already been placed in the
; destination.

        MOVVC   R3, R7          ;old parent dir
        BLVC    GetDir          ;(R3->R0,R5,R6,V)
        MOVVC   R4, R8
        BLVC    RemoveDirEntryOnly      ;(R3-R6->R0,V) always succeeds
        BLVC    WriteDir        ;(->R0,V)
        BVS	%FT90
        BL	CanBigDirShrink
        BLEQ	ShrinkBigDir
        BLVC    %BT10
        B       %FT90
	

80
	MOV	R0, #0
85
        BL      SetVOnR0
90
        ADD     SP, SP, #BigDirEntrySize+4+4   ;return dir entry buffer
        MOVVC   R0, #0
        STRVC   R0, [SP,#0]     ;zero return R1 to indicate success
        MOV     R3, R7
        BL      DecUsage        ;(R3)

 [ DebugX
 	DLINE	"<DoOsFunRenameBigDir"
 ]
        Pull    "R1-R11,PC"

; ======================
; MaybeGrowBigDirForName
; ======================

; entry:

; R1 number of extra bytes required (word multiple)
; R3 ind disc add of dir to grow (isn't in dir buffer)

MaybeGrowBigDirForName ROUT
	Push	"R0-R11, LR"

 [ DebugX
 	DLINE	">MaybeGrowBigDirForName"
 ]

	BL	GetDir		; (R3->R5, R6->R0, V)
        BVS	%FT95
        
        BL	BigDirFreeSpace	; (R5->LR)
        CMP	R1, LR
        BLO	%FT90

	BL	GrowBigDir	; (R3, R5, R6->R0, V)
	BVS	%FT95
	
90
	MOV	R0, #0	
95
	BL	SetVOnR0
	STRVS	R0, [SP]
 [ DebugX
 	DLINE	"<MaybeGrowBigDirForName"
 ]
	Pull	"R0-R11, PC"


; =====================
; ReallySharedNotFudged
; =====================

;entry
; R2 ind disc add
; R3 dir
; R4 -> dir entry
; R5 -> dir start, MUST NOT BE FUDGED
; R6 -> dir entry to start at

;exit EQ <=> file is in shared frag and at least one other obj is sharing frag

;CAN'T READ IN DISC ADD FROM DIR ENTRY AS CLOSE FILE WILL HAVE ALREADY MODIFIED
;THIS IF FILE IS ZERO LENGTH

ReallySharedNotFudged ROUT
        Push    "R0,R1,R4,LR"
 [ DebugE
        DREG    R2, "ReallySharedNotFudged(disc add:",cc
        DREG    R3, ", dir:",cc
        DREG    R4, ", entry:",cc
        DREG    R5, ", dir start:",cc
        DREG	R6, ", start entry:"
 ]
        MOV     R1, R2, LSR #8
        TSTS    R2, #&FF        ;If not in shared fragment
        TOGPSR  Z_bit,LR
        BNE     %FT95
        TEQS    R1, R3, LSR #8
        BEQ     %FT95           ;sharing with parent dir
        MOV     R0, R4

	MOV	R4, R6		;get first dir entry to start at
05
        TEQS    R4, R0
        BEQ     %FT10
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        TEQS    R1, LR, LSR #8
        BEQ     %FT95           ;sharing with file
10
	ADD	R4, R4, #BigDirEntrySize
	BL	BigDirFinished
        BNE     %BT05           ;loop while more dir entries
        TOGPSR	Z_bit,LR
                        ;NE if no sharers
95
 [ DebugE
        BEQ     %FT01
        DLINE   "<-ReallyShared(not really sharing)"
        B       %FT02
01
        DLINE   "<-ReallyShared(really sharing)"
02
 ]
        Pull    "R0,R1,R4,PC"



; =========================
; ReturnWholeSpaceNotFudged
; =========================

ReturnWholeSpaceNotFudged
	MOV	R0, #0		; fall through to ReturnSpaceNotFudged

; ====================
; ReturnSpaceNotFudged
; ====================

; this function acts like ReturnSpace, but avoids the nasty fudge
; of the start of directory to ReallyShared (which is a bit nasty)

; it can only be used for Big dirs.  it must be 

; entry:
;  R0 new file length
;  R1 old file length
;  R2 Ind Disc address of file
;  R3 dir ind disc add
;  R4 -> dir entry
;  R5 -> dir start, MUST NOT BE FUDGED
;  r6 -> dir entry to start search at for ReallySharedNotFudged

; exit: IF error V set, R0 result


ReturnSpaceNotFudged ROUT
 [ Debug5 :LOR: DebugX
        DLINE   "new len :old len :ind disc:dir     :DirEntry:DirStart enter ReturnSpaceNotFudged"
        DREG   R0," ",cc
        DREG   R1," ",cc
        DREG   R2," ",cc
        DREG   R3," ",cc
        DREG   R4," ",cc
        DREG   R5," ",cc
        DREG   R6," "
 ]
        Push    "R0-R4,R6-R11,LR"
        BL      RoundUp         ;(R0,R3->R0)
        MOV     R6, R0
        MOV     R0, R1
        BL      RoundUp
        SUBS    R1, R0, R6      ;length of returned space
        BLS     %FT90           ;nothing to return


        TSTS    R2, #&FF
        BEQ     %FT15           ;not shared obj
        TEQS    R6, #0
        BNE     %FT90           ;IF not returning whole obj then done
        Push	"R6"
        LDR	R6, [SP, #6*4]
        BL      ReallySharedNotFudged    ;(R2-R6->Z)
        Pull	"R6"
        BEQ     %FT90           ;IF frag shared then done
        BIC     R2, R2, #&FF

15

        BL      CritInitReadNewFs   ;(->R10,R11)
        LDRB    R7, [R10,#ZoneHead+BitSize]
        MOV     R6, R6, LSR R7  ;new length in map bits
        MOV     R7, R0, LSR R7  ;old length in map bits
        MOV     R9, #-1         ;don't know about pre gaps yet
20
        MOV     R1, R6
        BL      FindFragment    ;(R1,R2,R9,R10->R1,R9,R11,LR)
        SUB     R0, R1, R11     ;new length
        ADD     R1, R0, LR      ;old length = new length + length returning
        Push    "R2"
        MOV     R2, R11
        SUB     R7, R7, LR      ;decrement length left, may go -ve
        MOV     R3, R9
        BL      ShortenFrag     ;(R0-R3,R10)
        Pull    "R2"
        CMPS    R6, R7          ;loop until whole file returned
        BLT     %BT20           ;LT rather than LO as R7 may be -ve
        BL      InvalidateFragCache

90
        MOV     R0, #0
95
        BL      SetVOnR0
 [ Debug5 :LOR: DebugX
	BVC	%FT96
        DREG   R0," ",cc
96
        DLINE "leave ReturnSpaceNotFudged"
 ]
        STRVS   R0, [SP]
        Pull    "R0-R4,R6-R11,PC"



 ] ; BigDir

@


1.1.2.3
log
@Altered directory format (change backup dir entries to be one word instead
of an entire copy of the entry).  Also reduced size of a directory entry
by one word.  Also fixed a number of small bugs.
@
text
@d17 1
a17 1
        TTL     "Big directory support code"
d79 3
a81 3
SanityCheckBigDirHeader ROUT
        Push    "R0,R1,LR"
        
d83 1
a83 1
        DLINE   ">SanityCheckBigDirHeader"
d85 4
a88 4
        
        LDR     r1, SBProven                    ; get "SBPr"
        LDR     lr, [r5, #BigDirStartName]      ; and get StarName from Dir
        TEQS    r1,lr                           ; is it broke?
d90 2
a91 2
        BEQ     %FT01
        DLINE   "Failed at BigDirStartMasSeq"
d94 4
a97 4
        BNE     %FT95
        
        LDR     lr, [r5, #BigDirVersion]
        MOVS    lr, lr, LSL #8
d100 2
a101 2
        BEQ     %FT01
        DLINE   "Failed at BigDirVersion"
d104 1
a104 1
        BNE     %FT95
d106 3
a108 3
        LDR     lr, [r5, #BigDirSize]
        MOVS    r1, lr, LSL #21         ; bottom 11 bits must be clear
        
d110 2
a111 2
        BEQ     %FT01
        DLINE   "Failed at BigDirSize not multiple of 2048"
d114 1
a114 1
        BNE     %FT95
d116 1
a116 1
        MOVS    r1, lr, LSR #22
d119 2
a120 2
        BEQ     %FT01
        DLINE   "Failed at BigDirSize too large"
d125 4
a128 4
        MOVNE   R0, #BrokenDirErr
        MOVEQ   R0, #0
        BL      SetVOnR0
        STRVS   R0, [SP]
d130 1
a130 1
        DLINE   "<SanityCheckBigDirHeader"
d132 1
a132 1
        Pull    "R0,R1,PC"
d146 1
a146 1
        Push    "R0,R1,R10,R11,LR"
d148 1
a148 1
        DLINE   ">CheckBigDir"
d152 2
a153 2
        LDR     R1, [R5, #BigDirNameLen]
        DREG    R1, "dir's name length is:"
d155 7
a161 7
        
        baddr   R1, SBProven
        LDMIA   R1, {R1, R11}
        
        LDR     LR, [R5, #BigDirStartName]
        
        TEQS    LR, R1                          ; is the StartName Ok?
d164 2
a165 2
        BEQ     %FT01
        DLINE   "Failed at SBPr"
d168 4
a171 4
        LDREQB  R0, [R5,#BigDirStartMasSeq]
        LDREQB  LR, [R6,#BigDirEndMasSeq]
        TEQS    R0, LR
        
d173 2
a174 2
        BEQ     %FT01
        DLINE   "Failed at sequences"
d177 2
a178 2
        LDREQ   LR, [R6, #BigDirEndName]
        TEQEQS  LR, R11
d181 3
a183 3
        BEQ     %FT01
        DLINE   "Failed at endname"
        DREG    LR, "End name read was:"
d186 3
a188 3
        MOV     R0, #0
        BNE     %FT90
        
d195 1
a195 1
        DLINE   "Big dir broken"
d209 1
a209 1
        DLINE   "<CheckBigDir"
d211 1
a211 1
        Pull    "R0,R1,R10,R11,PC"
d226 2
a227 2
TestBigDirCheckByte     ROUT
        Push    "R0-R2,R5,R7,LR"
d230 2
a231 2
        DLINE   ">TestBigDirCheckByte"
        DREG    R5, "dir at:"
d236 19
a254 26
        MOV     R2,#0   ; zero the acc.
        
        LDR     R0, [R5, #BigDirNameLen]
 
 	ADD	R0, R0, #4
        BIC     R0, R0, #3                      ; name len
        
        LDR     R1, [R5, #BigDirEntries]        ; number of entries

 [ BigDirFix
        ASSERT  BigDirEntrySize=28
 
        RSB     R1, R1, R1, LSL #3              ; *7
        ADD     R0, R0, R1, LSL #2              ; 7*4=28
 |
        ASSERT  BigDirEntrySize=32
        
        ADD     R0, R0, R1, LSL #5              ; 32 bytes per entry
 ]
        
        LDR     R1, [R5,#BigDirNamesSize]       ; size of the heap of names
        
        ADD     R0, R0, R1
        
        ADD     R0, R0, #BigDirHeaderSize
        
d256 1
a256 1
        DREG    R0, "bytes to check:"
d258 2
a259 2
        
        ADD     R0, R0, R5                      ; now R0 points to first word after names
d262 4
a265 4
        LDR     LR, [R5], #4
        EOR     R2, LR, R2, ROR #13
        TEQS    R5, R0
        BNE     %BT10
d268 7
a274 7
        ADD     R5, R6, #BigDirEndName
        LDR     LR, [R5], #4
        EOR     R2, LR, R2, ROR #13
        SUB     R0, R6, #1
        
        ASSERT  BigDirCheckByte=-1
        
d276 5
a280 5
        LDRB    LR, [R5], #1
        EOR     R2, LR, R2, ROR #13
        TEQS    R5, R0
        BNE     %BT20
        
d285 2
a286 2
        LDRB    LR, [R6,#BigDirCheckByte]
        TEQS    R2, LR
d288 2
a289 2
        DREG    LR, "check byte"
        DREG    R2, "value:"
d291 2
a292 2
        MOV     LR, R2
                
d294 1
a294 1
        DLINE   "<TestBigDirCheckByte"
d297 1
a297 1
        Pull    "R0-R2,R5,R7,PC"
d324 2
a325 2
ReadBigDirEntries       ROUT
        Push    "R0,R1,R2,R9,lr"
d327 1
a327 1
        DLINE   ">ReadBigDirEntries"
d329 1
a329 1
        LDR     r1, [r5, #BigDirEntries]        ; get the number of entries in the dir
d331 2
a332 2
        DREG    r1, "dir entries:"
        DREG    r9, "index value:"
d334 4
a337 4
        CMP     r9, r1                  ; check if offset too large
        MOVHS   r9, #-1
        MOVHS   R5, #0
        BHS     %FT95                   ; nothing transferred
d343 4
a346 10
        BL      GetDirFirstEntry        ; (R3,R5->R4)
        
 [ BigDirFix
        ASSERT  BigDirEntrySize=28
        RSB     LR, R9, R9, LSL #3      ; *7
        ADD     R4, R4, LR, LSL #2      ; 7*4=28
 |
        ASSERT  BigDirEntrySize=32
        ADD     R4, R4, R9, LSL #5      ; pointer to current entry
 ]
d348 10
a357 10
        TEQS    R11, #fsfunc_ReadDirEntriesInfo
        BEQ     %FT20
        
        TEQS    R11, #fsfunc_ReadDirEntries
        BEQ     %FT40
        
        TEQS    R11, #fsfunc_CatalogObjects
        BEQ     %FT60
        
        B       %FT95
d360 4
a363 4
        ADD     R7, R7, #3      ; word align it
        BIC     R7, R7, #3
        SUB     LR, R10, R7
        LDR     R0, [R4, #BigDirObNameLen]
d365 1
a365 1
        DREG    R0, "name length:"
d367 3
a369 3
        ADD     R0, R0, #&15+3
        BIC     R0, R0, #3
        CMPS    R0, LR                  ; space for entry?
d371 4
a374 4
        DREG    LR, "space in buffer:"
        DREG    R0, "space for entry:"
        BLS     %FT01
        DLINE   "Buffer overflowed"
d377 3
a379 3
        BHI     %FT25                   ; no space!
        
; have space for entry  
d394 20
a413 20
        LDR     R6, [R4, #BigDirObNameLen]
        Push    "R4"
        BL      GetBigDirName   ;(R5,R6->LR)
        MOV     R4, LR
 [ DebugX
        DSTRING R4, "name:"
 ]
        BL      PutStringToBuf  ;write the string to the buffer
        Pull    "R4"
        BLCC    Put0ToBuf
        
        BCS     %FT25           ; buffer full
        
        ADD     R9, R9, #1
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
        BEQ     %FT30
        
        SUBS    R8, R8, #1
        BGT     %BT20
d419 4
a422 4
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUB     R5, R9, R8              ; number of names transferred
        B       %FT95                   ; and exit
        
d425 4
a428 4
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUB     R5, R9, R8              ; number of names transferred
        MOV     R9, #-1                 ; finished
        B       %FT95                   ; and exit
d431 4
a434 4
        SUB     LR, R10, R7
        LDR     R0, [R4, #BigDirObNameLen]
        ADD     R0, R0, #1
        CMPS    R0, LR                  ; space for entry?
d436 2
a437 2
        BLS     %FT01
        DLINE   "Buffer overflowed"
d440 22
a461 22
        BHI     %FT45                   ; no space!
        
        LDR     R6, [R4, #BigDirObNameLen]
        Push    "R4"
        BL      GetBigDirName   ;(R5,R6->LR)
        MOV     R4, LR
 [ DebugX
        DSTRING R4, "name:"
 ]
        BL      PutStringToBuf  ;write the string to the buffer
        Pull    "R4"
        BLCC    Put0ToBuf
        
        BCS     %FT45           ; buffer full
        
        ADD     R9, R9, #1
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
        BEQ     %FT50
        
        SUBS    R8, R8, #1
        BGT     %BT40
d467 4
a470 4
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUB     R5, R9, R8              ; number of names transferred
        B       %FT95                   ; and exit
        
d473 4
a476 4
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUB     R5, R9, R8              ; number of names transferred
        MOV     R9, #-1                 ; finished
        B       %FT95                   ; and exit
d480 4
a483 4
        ADD     R7, R7, #3      ; word align it
        BIC     R7, R7, #3
        SUB     LR, R10, R7
        LDR     R0, [R4, #BigDirObNameLen]
d485 1
a485 1
        DREG    R0, "name length:"
d487 3
a489 3
        ADD     R0, R0, #&1E+3
        BIC     R0, R0, #3
        CMPS    R0, LR                  ; space for entry?
d491 4
a494 4
        DREG    LR, "space in buffer:"
        DREG    R0, "space for entry:"
        BLS     %FT01
        DLINE   "Buffer overflowed"
d497 3
a499 3
        BHI     %FT65                   ; no space!
        
; have space for entry  
d518 26
a543 26
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
        BIC     LR, LR, #DiscBits
        STR     LR, [R7], #4
        STR     R2, [R7], #4
        STRB    R1, [R7], #1

        LDR     R6, [R4, #BigDirObNameLen]
        Push    "R4"
        BL      GetBigDirName   ;(R5,R6->LR)
        MOV     R4, LR
 [ DebugX
        DSTRING R4, "name:"
 ]
        BL      PutStringToBuf  ;write the string to the buffer
        Pull    "R4"
        BLCC    Put0ToBuf
        
        BCS     %FT65           ; buffer full
        
        ADD     R9, R9, #1
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
        BEQ     %FT70
        
        SUBS    R8, R8, #1
        BGT     %BT60
d549 4
a552 4
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUB     R5, R9, R8              ; number of names transferred
        B       %FT95                   ; and exit
        
d555 5
a559 5
        LDR     R8, [sp, #3*4]          ; old offset in dir
        SUB     R5, R9, R8              ; number of names transferred
        MOV     R9, #-1                 ; finished
        B       %FT95                   ; and exit
        
d562 1
a562 1
        STR     r9, [sp,#3*4]
d564 1
a564 1
        DLINE   "<ReadBigDirEntries"
d566 1
a566 1
        Pull    "r0,r1,r2,r9,pc",,^
d580 1
a580 1
; EQ if entry is beyond end of entries, LR=entries in dir
d583 1
a583 1
        Push    "R4,R6,LR"
d585 20
a604 30
        DLINE   ">BigDirFinished"
        DREG    R5, "dir at:"
        DREG    R4, "entry at:"
 ]
        LDR     R6, [R5, #BigDirNameLen]
        ADD     R6, R6, #4
        BIC     R6, R6, #3

        LDR     LR, [R5, #BigDirEntries]

 [ BigDirFix
        ASSERT  BigDirEntrySize=28
        ADD     R6, R6, LR, LSL #5      ; *32
        SUB     R6, R6, LR, LSL #2      ; *(32-4)=*28
 |
        ASSERT  BigDirEntrySize=32
        ADD     R6, R6, LR, LSL #5
 ]

        ADD     R6, R6, R5
        ADD     R6, R6, #BigDirHeaderSize       ; now points to header

 [ DebugX
        DREG    R6, "end of entries:"
 ]
        CMPS    R4, R6
        MOVHI   R4, R6
        TEQS    R4, R6
 
        Pull    "R4,R6,PC"
d618 12
a629 12
        Push    "R5,R6,R7,LR"
        
        BL      BigDirFinished                  ; is it finished
        LDREQ   R7, [R5, #BigDirNamesSize]      ; size of names heap
        
        LDR     LR, [R5, #BigDirNameLen]
        LDR     R6, [R5, #BigDirEntries]
        ADD     LR, LR, #4
        BIC     LR, LR, #3
        ADD     R5, R5, LR
        ADD     R5, R5, #BigDirHeaderSize
        
d631 10
a640 16

 [ BigDirFix
        ASSERT  BigDirEntrySize=28
        RSB     LR, R6, R6, LSL #3
        ADD     R6, R5, LR, LSL #2
 |
        ASSERT  BigDirEntrySize=32
        
        ADD     R6, R5, R6, LSL #5              ; name heap
 ]
        
        LDRNE   R5, [R4, #BigDirObNamePtr]      ; offset into name heap
        ADDNE   LR, R5, R6
        ADDEQ   LR, R7, R6                      ; end of name heap
        
        Pull    "R5,R6,R7,PC",,^
d653 2
a654 2
        Push    "LR"
        ADD     LR, LR, R4, LSL #5              ; entry
d656 1
a656 1
        LDRB    LR, [R4, #BigDirAtts]           ; read the bottom 8 bits of atts
d659 2
a660 2
        DREG    LR, " ", cc
        DLINE   "=Big Atts"
d669 2
a670 2
                
        Pull    "PC",,^
d690 1
a690 1
LookUpBigDir    ROUT
d696 1
a696 1
        DREG    r5,",dir start ",cc
d699 1
a699 1
        Push    "r7,LR"
d701 2
a702 2
        SUBCC   r4,r4,#BigDirEntrySize  ; caller asked to start at this entry
        MOV     R7, #0
d704 10
a713 10
        ADD     r4,r4,#BigDirEntrySize
        BL      BigDirFinished          ; (R4,R5->eq->dir finished)
        BNE     %FT11

        ; end of dir
        TEQ     r7, #0
        MOVNE   r4, r7
        SEC
        B       %FT90                   ; carry already set
        
d715 10
a724 10
        Push    "R4,R5,R6"
        LDR     R6, [R4, #BigDirObNameLen]
        BL      GetBigDirName           ; get the name's address (in LR)
        MOV     R4, LR
        MOV     r5, #&ff                ; mask is ff
        BL      BigLexEqv               ; (R1,R4,R5->LO/EQ/HI)
        Pull    "R4,R5,R6"
        
        BCC     %BT10                   ;if mismatch and name<wild try next
        BEQ     %FT15                   ;EQ=>match
d727 10
a736 10
        ;mismatch and name >wild done
        TEQ     r7, #0                  ; doesn't affect C
        MOVEQ   r7, r4
        BCS     %BT10                   
        
        ; completion in the not found case
        
        MOV     r4, r7
        SEC                             ; set carry (not found)
        B       %FT90
d739 2
a740 2
        ; Match, but...
        BL      ReadBigDirIntAtts       ; read the attributes
d743 2
a744 2
        TSTS    LR, #DirBit
        BNE     %FT20                   ; found a dir
d746 1
a746 1
        
d762 2
a763 2
        BNE     %FT01
        DLINE   " file ",cc
d769 1
a769 1
        Pull    "R7,PC"
d785 1
a785 1
        Push    "LR"
d787 12
a798 12
        BL      TestBigDir
        
        BNE     %FT01                           ; not a big dir
        
        LDR     LR, [R5, #BigDirNameLen]
        ADD     LR, LR, #4
        BIC     LR, LR, #3
        
        ADD     R4, R5, LR
        ADD     R4, R4, #BigDirHeaderSize
        
        Pull    "PC",,^
d800 2
a801 2
        ADD     R4,R5,#DirFirstEntry            ; not a big dir
        Pull    "PC",,^
d815 8
a822 8
        Push    "LR"
        
        BL      TestBigDir
        ADDEQ   R4, R4, #BigDirEntrySize
        ASSERT  NewDirEntrySz=OldDirEntrySz
        ADDNE   R4,R4,#NewDirEntrySz
        
        Pull    "PC",,^
d837 1
a837 1
        Push    "R0,LR"
d840 1
a840 1
        DLINE   ">BigDirFreeSpace"
d842 14
a855 29
        LDR     R0, [R5, #BigDirSize]           ; size of the directory
        SUB     R0, R0, #BigDirHeaderSize + BigDirTailSize
        LDR     LR, [R5, #BigDirEntries]
        
 [ BigDirFix
        ASSERT  BigDirEntrySize=28
  [ BigDirFullBackup
        RSB     LR, LR, LR, LSL #3              ; *7
        SUB     R0, R0, LR, LSL #3              ; *7*8=56
  |
        SUB     R0, R0, LR, LSL #5              ; *32
  ]
 |
        ASSERT  BigDirEntrySize=32
  [ BigDirFullBackup
        SUB     R0, R0, LR, LSL #6              ; TWO copies of entries
  |
        SUB     R0, R0, LR, LSL #5
        SUB	R0, R0, LR, LSL #2		; *36
  ]
 ]
 
        LDR     LR, [R5, #BigDirNameLen]        ; length of dir name
        ADD     LR, LR, #4
        BIC     LR, LR, #3
        SUB     R0, R0, LR
        
        LDR     LR, [R5, #BigDirNamesSize]      ; size of the names heap
        SUB     LR, R0, LR                      ; now LR is the number of free bytes in the dir
d858 1
a858 1
        DREG    LR, "<BigDirFreeSpace"
d860 1
a860 1
        Pull    "R0, PC",,^
d880 17
a896 22
        Push    "R0,R1,R2,R6,LR"

        BL      BigDirFreeSpace                 ; (R5->LR)
        MOV     R6, LR  
        ; now get the number of bytes needed for the new entry:

        MOV     R2, R1                          ; keep start of term

        BL      SkipTerm                        ; (R1->R0,R1)

        SUB     R0, R1, R2                      ; length of term

        ADD     R0, R0, #4
        BIC     R0, R0, #3

 [ BigDirFullBackup
        ADD     R0, R0, #BigDirEntrySize*2
 |
        ADD     R0, R0, #BigDirEntrySize
        ADD	R0, R0, #4
 ]

d898 2
a899 2
        DREG    R0, "size needed:"
        DREG    R6, "size available:"
d901 7
a907 7
        CMPS    R0, R6
        MOVHI   R0, #DirFullErr
        MOVLS   R0, #0
        BL      SetVOnR0
        STRVS   R0, [SP]

        Pull    "R0,R1,R2,R6,PC"
d925 1
a925 1
        Push    "R0-R11,LR"
d928 1
a928 1
;       BL      DumpBigDir
d930 7
a936 7
        
        MOV     R2, R1
        BL      SkipTerm                ; (R1->R0,R1)
        SUB     R8, R1, R2              ; R8 = term length
        ADD     R6, R8, #4
        BIC     R6, R6, #3              ; R6 = extra required in name heap
        
d939 4
a942 2
        BL      GetBigDirName           ; (R4,R5->LR)
        
d944 3
a946 3
        MOV     R0, LR                  ; source for block move
        ADD     R1, R0, R6
        ADD     R1, R1, #BigDirEntrySize ; dest for block move
d949 12
a960 19
        LDR     R2, [R5, #BigDirNameLen];length of dir name
        ADD     R2, R2, #4+BigDirHeaderSize
        BIC     R2, R2, #3
        LDR     LR, [R5, #BigDirEntries]

 [ BigDirFix
        ASSERT  BigDirEntrySize=28
        RSB     LR, LR, LR, LSL #3      ; *7
        ADD     R2, R2, LR, LSL #2      ; *7*4=28
 |
        ASSERT  BigDirEntrySize=32
        ADD     R2, R2, LR, LSL #5
 ]
        LDR     LR, [R5, #BigDirNamesSize] ; size of the heap of names
        
        ADD     R2, R2, LR              ; word after name heap
        ADD     R2, R2, R5
        
        SUB     R2, R2, R0              ; length of move
d963 4
a966 4
        DLINE   "Moving upper section of names"
        DREG    R0, "source="
        DREG    R1, "  dest="
        DREG    R2, "   len="
d969 1
a969 1
        BL      BlockMove               ; do the block move
d971 12
a982 5
        ADD     R7, R0, #BigDirEntrySize
        
        MOV     R0, R7
        MOV     R1, R6
        BL      ZeroRam                 ; zero rest of the entry
d986 3
a988 3
        MOV     R0, R4
        ADD     R1, R4, #BigDirEntrySize
        SUB     R2, R7, R1              ; amount to move
d991 4
a994 4
        DLINE   "Moving entries and lower section of names"
        DREG    R0, "source="
        DREG    R1, "  dest="
        DREG    R2, "   len="
d997 2
a998 2
        BL      BlockMove
        
d1000 11
a1010 13
        LDR     LR, [R5, #BigDirEntries]        ; number of entries
        ADD     LR, LR, #1
        STR     LR, [R5, #BigDirEntries]        ; new number of entries

        LDR     LR, [R5, #BigDirNamesSize]      ; size of names heap
        ADD     LR, LR, R6
        STR     LR, [R5, #BigDirNamesSize]      ; new number of entries

 [ :LNOT: BigDirFix
        LDR     LR, DirE
        STR     LR, [R4, #BigDirEntryName]      ; give the entry a DirE
 ]
        
d1013 3
a1015 3
        ADD     R4, R4, #BigDirEntrySize
        
        BL      BigDirFinished                  ; (R4, R5->C)
d1019 5
a1023 5
        LDRNE   LR, [R4, #BigDirObNamePtr] 
        LDREQ   LR, [R5, #BigDirNamesSize]
        SUBEQ   LR, LR, R6
        
        STR     LR, [R4, #BigDirObNamePtr-BigDirEntrySize]      ; copy it
d1026 1
a1026 1
        DREG    R8, "storing name len of:"
d1028 2
a1029 2
        STR     R8, [R4, #BigDirObNameLen-BigDirEntrySize]      ; and set the name length
        
d1032 1
a1032 1
        Pull    "R0-R11,PC",EQ,^                                ; if Z=1 then finished
d1035 6
a1040 6
        LDR     LR, [R4, #BigDirObNamePtr]
        ADD     LR, LR, R6                      ; new pointer
        STR     LR, [R4, #BigDirObNamePtr]
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished                  ; (R4, R5->C)
        BNE     %BT10
d1042 1
a1042 1
;       BL      DumpBigDir
d1044 1
a1044 1
        Pull    "R0-R11,PC",,^                          ; if C=1 then finished
d1051 4
a1054 4
        Push    "R5,R11,LR"                             ; save regs
        DLINE   "Directory dump:"
        
        LDR     R11, [R5, #BigDirSize]                  ; size of dir
d1056 6
a1061 6
        LDR     LR, [R5], #4                            ; get a word
        DREG    LR, " ",cc                              ; dump it
        AND     LR, R11, #4*7                           ; is it end of line
        CMPS    LR, #4*7
        BEQ     %FT01
        DLINE   " "
d1063 2
a1064 2
        SUBS    R11, R11, #4
        BGT     %BT10
d1066 1
a1066 1
        Pull    "R5,R11,PC",,^
d1081 6
a1086 6
        Push    "R0-R2,R4,LR"
        LDR     R2, [R4, #BigDirObNameLen]
        ADD     R2, R2, #3
        BIC     R2, R2, #3      ; up to word boundary
        BL      GetBigDirName   ; (R4,R5->LR)
        MOV     R4, LR
d1093 2
a1094 1
        B       %BT10
d1110 2
a1111 2
        Push    "R0-R2,R4,LR"
        ADD     R4, R5, #BigDirHeaderSize
d1116 1
a1117 1
        BCS     %FT90
d1120 6
d1136 8
a1143 8
        Push    "R11,LR"
        
        ADRL    R11, SBProven
        LDMIA   R11, {R11, LR}
        STR     R11, [R5, #BigDirStartName]
        STR     LR, [R6, #BigDirEndName]
        
        Pull    "R11,PC",,^
d1156 1
a1156 1
        Push    "R0-R8,LR"      ; stuff
d1158 1
a1158 1
        DREG    R4,"entry TryGrowDirBuf - need: "
d1160 20
a1179 20
        ; because DA size may be rounded up to a page, we read the real size here
        MOV     R0, #2                  ; read area size
        LDR     R1, DirBufferArea       ; area addr
        BL      OnlyXOS_DynamicArea     ; do the SWI call
        BVS     %FT95
        
        STR     R2, DirBufferSize       ; if it's already small enough then we're OK
        
        LDR     R4, [SP, #4*4]          ; get back the size needed
        
        CMP     R4, R2                  ; do we need more space
        BLS     %FT94                   ; no
        
        MOV     R0, R1                  ; area number to R0
        SUB     R1, R4, R2              ; amount needed
        BL      OnlyXOS_ChangeDynamicArea
        BVS     %FT95
        
        ADD     R2, R2, R1              ; number of bytes added to area
        STR     R2, DirBufferSize       ; etc
d1181 1
a1181 1
        CLRV                            ; clear the V flag
d1183 1
a1183 1
        STRVS   R0, [SP]                ; if V set then store the error
d1185 1
a1185 1
        DLINE   "Exit TryGrowDirBuf"
d1187 1
a1187 1
        Pull    "R0-R8,PC"      ; other stuff
d1203 1
a1203 1
        Push    "R0-R11,LR"
d1205 3
a1207 3
        DLINE   "entering GrowBigDir"
        DREG    R3, "dir "
        DREG    R5, "at  "
d1210 5
a1214 5
        SUB     R4, R6, R5              ; current dir size
        ADD     R4, R4, #BigDirMinSize  ; add a bit to it
        BL      TryGrowDirBuf
        BVS     %FT99
        
d1217 14
a1230 14
        LDR     R3, [SP, #3*4]
        LDR     R6, [SP, #6*4]
        LDR     R5, [SP, #5*4]
        SUB     R4, R6, R5
        ADD     R4, R4, #BigDirMinSize  ; size required
        BL      DiscAddToRec            ; get disc record
        LDR     R7, [LR, #SectorSize]   ; sector size
        LDR     LR, [LR, #ShareSize]    ; share size
        ADD     R7, R7, LR
        MOV     R11, #1
        RSB     R11, R11,R11,LSL R7
        TSTS    R4, R11
        MOV     R9, R4, LSR R7
        ADDNE   R9, R9, #1              ; sharing blocks needed for dir
d1233 2
a1234 2
        DREG    R9, "dir needs ",cc
        DLINE   " sharing blocks"
d1237 6
a1242 6
        BL      BeforeAlterFsMap        ; (R3->R0,V)
        BVS     %FT99
        
        BL      CritInitReadNewFs       ; (->R10,R11)
        
        BL      SortDir                 ; (R3,R5->R8)
d1245 6
a1250 10
        LDMIA   R8!, {R4, R5}           ; get table entry
 [ DebugX
        DREG    R5," table entry: ",cc
        DREG    R4,""
 ]
        AND     R0, R5, #&FF    ; r5 - sharing offset
        TEQS    R5, #0
        TEQEQS  R4, #0
        BEQ     %FT50           ;end of list marker found
        MOVS    R5, R5, LSR #9  ;link bits
d1259 8
a1266 8
        TEQS    R4, #0          ;is it the dir itself?
        BEQ     %FT30
        
        TEQS    R5, R3, LSR #8  ;is it the same object as the dir
        BNE     %FT50
        
        CMPS    R0, #1          ;is the sharing offset 1?
        BEQ     %FT30
d1268 4
a1271 4
        CMPS    R0, R9          ;is it in the way?
        BHI     %FT30           ; no
        
        ; an object is in the way
d1273 1
a1273 13
        DREG    R0,"offset in the way:"
 ]
        SUB     LR, r0, #1
        MOV     R7, LR, LSL R7          ; dummy dir size for ClaimFreeSpace
        ; find the offending dir entry
        
 [ BigDirFix
        ASSERT  BigDirEntrySize=28
        RSB     R4, R4, R4, LSL #3      ; *7
        MOV     R4, R4, LSL #2          ; *4*7=28
 |
        ASSERT  BigDirEntrySize=32
        MOV     R4, R4, LSL #5          ; will never be dir itself
d1275 14
a1288 8
        LDR     LR, DirBufferPtr
        LDR     LR, [LR, #BigDirNameLen]
        ADD     LR, LR, #4
        BIC     LR, LR, #3
        ADD     R4, LR, R4
        LDR     LR, DirBufferPtr
        ADD     LR, LR,#BigDirHeaderSize-BigDirEntrySize
        ADD     R4, R4, LR
d1291 2
a1292 2
        BL      ReadIndDiscAdd          ; (R4->LR)
        DREG    LR, "Ind disc add of entry:"    
d1294 6
a1299 6
        BL      ReadLen                 ; (R4->LR)
        MOV     R10, LR                 ; length to claim
        MOV     R11,#fsfile_Save        ; reason code to ClaimFreeSpace
        LDR     R5, [SP, #5*4]          ; get the dir
        ADD     R7, R7, R10             ; increase dummy length
        STR     R7, [R5, #BigDirSize]   ; fake dir size (MUST restore later - see below)
d1301 1
a1301 1
        DREG    R7, "dummy size:"
d1303 1
a1303 1
        BL      ClaimFreeSpace          ; claim space for object
d1305 2
a1306 2
        BVC     %FT01
        DLINE   "ClaimFreeSpace failed"
d1309 7
a1315 7
        LDR     R6, [SP, #6*4]          ;
        SUB     R6, R6, R5
        STR     R6, [R5, #BigDirSize]   ; restore dir's original size MUST do this
        BVS     %FT96
        
        BL      ReadIndDiscAdd
        MOV     R1, LR
d1317 2
a1318 2
        DREG    R2, "Ind disc add of new:"
        DREG    R1, "and of old:"
d1320 7
a1326 7
        
        Push    "R3,R4"
        MOV     R3, R10
        BL      DefaultMoveData         ; move the data
        BVS     %FT96                   ; argh
        Pull    "R3,R4"
        
d1334 2
a1335 2
        CMPS    R8, R1
        BNE     %FT02
d1337 1
a1337 1
        DLINE   "matches file we're interested in"
d1339 2
a1340 2
        STR     R2, [lr, #FcbIndDiscAdd]
        B       %FT03
d1347 7
a1353 7
        MOV     R0, R2
        BL      WriteIndDiscAdd ; update the dir
        BL      WriteFsMapThenDir       ; write the stuff out
        BVS     %FT96           ; err, this would be BAD
        
        BL      UnlockMap       ; unlock the map
        B       %BT10           ; and try going round the loop again
d1356 1
a1356 1
        B       %BT20           ; round the loop again
d1358 5
a1362 5
50      ; SortDir didn't find any objects which clash.  do the grow operation, checking
        ; it won't grow beyond MinMapObj
        
        BIC     R1, R3, #&ff            ; pretend to be unshared
        BL      MeasureFileAllocSize_GotMap             ; allocated size
d1364 1
a1364 1
        DREG    R0, "space allocated to dir:"
d1366 47
a1412 47
        
        LDR     R5, [SP, #5*4]  ; get the dir addr again
        LDR     R7, [R5, #BigDirSize] ; size of dir at present
        ADD     R7, R7, #BigDirMinSize
        CMPS    R7, R0
        BLS     %FT58
        
        ; here we don't have any shared objects getting in the way, but we
        ; don't have enough space allocated (how convenient).
        
        ; we call ClaimFreeSpace with RandomAccessExtend reason code to
        ; get things sorted out.  but we cheat.  because, y see, we don't
        ; want to have to get the parent dir in just yet, with all that
        ; copying around of data, so I'm gonna build a dummy dir entry
        ; on the stack.  cunning, eh no?
        
        ; we also then return most of the space anyway, cos RandomAccessExtend
        ; has a tendency to allocate far too much space
        
        Push    "R3,R4,R6,R7"
        
        SUB     SP, SP, #BigDirEntrySize        ; space for an entry
        MOV     R4, SP
        MOV     R6, R3                  ; keep addy around
        BL      ToParent                ; get parent addy
        BIC     R6, R6, #DiscBits       ; knock off DiscBits
        BIC     R6, R6, #&ff            ; and pretend unshared
        STR     R6, [R4, #BigDirIndDiscAdd]
        SUB     LR, R7, #BigDirMinSize  ; current size
        STR     LR, [R4, #BigDirLen]
        
        ; only need IndDiscAdd and Len to be valid in the dummy entry.
        
        MOV     R10, R7                 ; size wanted
        MOV     R0, LR                  ; old extent
        MOV     R11, #RandomAccessExtend
        BL      ClaimFreeSpace          ; (R0,R3,R4,R5,R10,R11->R0,R2,R10,V)
        BVS     %FT55
        
        Push    "R2,R4,R5,R8,R10"
        BL      RoundUp                 ; (R0,R3->R0)
        BL      DiscAddToRec            ; (R3->LR)
        LDR     R8, [LR, #BitSize]      ; convert units to map bits
        MOV     R1, R7, LSR R8          ; length after rounding up
        BL      CritInitReadNewFs       ; (->R10,R11)
        BL      DefFindFragment         ; (R1,R2,R10->R1,R9,R11,LR)
        SUBS    R1,R1,R11               ; R1 = offset in map bits into fragment
d1414 1
a1414 1
        DREG    R1, "offset into fragment:"
d1416 2
a1417 2
        BEQ     %FT52                   ; no change needed as offset at frag start - removing frag entirely
        LDRB    R9, [R10, #ZoneHead+LinkBits]
d1419 1
a1419 1
        DREG    R9, "LinkBits:"
d1421 3
a1423 3
        ADD     R9, R9, #1
        CMP     R1, R9
        BHS     %FT52                   ; no change needed as offset is more than idlen+1 into frag
d1426 1
a1426 1
        DREG    R7,"too short:"
d1428 4
a1431 4
        ; here if offset less than needed
        SUB     R1, R9, R1              ; offset to add to R7
        LDRB    R9, [R10, #ZoneHead+BitSize]
        ADD     R7, R7, R1, LSL R9      ; add it
d1434 3
a1436 3
        DREG    R1, "amount to increase by:"
        DREG    R9, "BitSize: "
        DREG    R7, "changing to: "
d1440 7
a1446 7
        Pull    "R2,R4,R5,R8,R10"
        
        ; now try to return excess space
        MOV     R0, R7                  ; new length
        MOV     R1, R10                 ; allocated length
        BL      ReturnSpace             ; return the space
        
d1448 7
a1454 7
        ADD     SP, SP, #BigDirEntrySize
        Pull    "R3,R4,R6,R7"
        
        BVS     %FT96                   ; if error
        
        BL      WriteFsMap              ; write out the FsMap.  extra space allocated after dir.
        
d1456 3
a1458 3
        ; here we have enough space in the object
        ; and there's no shared objects in the way
        ; so let's do it.  first alter the dir
d1461 1
a1461 1
        DLINE   "can grow dir... doing so"
d1463 8
a1470 8
        
        BL      InvalidateBufDir        ; going to trash dir
        STR     R7, [R5, #BigDirSize]
        SUB     R0, R6, #BigDirTailSize
        ADD     R1, R0, #BigDirMinSize
        MOV     R2, #BigDirTailSize
        BL      BlockMove
        
d1472 3
a1474 3
        DLINE   "Writing dir"
        LDR     LR, [R5, #BigDirParent]
        DREG    LR, "parent is:"
d1476 2
a1477 2
        BL      WriteDir        ;write out the dir
        BVS     %FT96
d1480 3
a1482 3
        DLINE   "Getting parent"
        DREG    R3, "R3: "
        DREG    R5, "R5: "
d1484 2
a1485 2
        MOV     R8, R3          ;keep ind disc add around
        BL      ToParent        ;(R3,R5->R3)
d1487 1
a1487 1
        DREG    R3, "Parent: "
d1489 2
a1490 2
        CMPS    R8, R3          ;is it the root dir
        BNE     %FT55
d1493 1
a1493 1
        DLINE   "It's the root dir - updating the FS map"
d1495 1
a1495 1
        BL      DiscAddToRec    ; get disc record
d1497 1
a1497 1
        STR     R7, [LR, #RootDirSize]          ; store the root dir size in the disc record
d1506 1
a1506 1
        STR     R7, [R10, #ZoneHead+RootDirSize]
d1508 4
a1511 4
        BL      WriteFsMap
        BVS     %FT96
        B       %FT80
        
d1513 7
a1519 7
        
        BL      GetDir          ; get the parent dir into dirbuf
        
        BL      GetDirFirstEntry        ; get first entry in dir
        
        BL      InvalidateBufDir
        MOV     R0, R7          ; length to write out
d1521 7
a1527 7
        BL      BigDirFinished ;(R4,R5->Z)
        BEQ     %FT70
        BL      ReadIndDiscAdd  ; get ind disc add
        CMPS    LR, R8          ; is it our object
        BEQ     %FT75
        ADD     R4, R4, #BigDirEntrySize
        B       %BT60
d1530 1
a1530 1
        BL      WriteLen        ; write the length
d1533 2
a1534 2
        BL      WriteDir        ; write the dir
        BVS     %FT96           ; error!
d1537 5
a1541 5
        MOV     R3, R8          ; get the original dir back into the dir buffer
        BL      GetDir  
        STRVC   R5, [SP, #4*5]
        STRVC   R6, [SP, #4*6]
        MOVVC   R0, #0
d1543 2
a1544 2
        BL      UnlockMap
        BL      SetVOnR0
d1546 1
a1546 1
        STRVS   R0, [SP]
d1548 3
a1550 3
        DLINE   "exiting GrowBigDir"
        BVC     %FT01
        DREG    R0, "error:"
d1553 1
a1553 1
        Pull    "R0-R11,PC"
a1556 1
 [ :LNOT: BigDirFix
a1558 1
 ]
d1570 1
a1570 1
        Push    "R0,LR"
d1572 1
a1572 1
        DLINE   ">CanBigDirShrink"
d1575 2
a1576 2
        BL      BigDirFreeSpace                 ; (R5->LR)
        MOV     R0, LR
d1578 1
a1578 1
        DREG    R0, "free space:"
d1580 6
a1585 6
        
        MOV     LR, #BigDirMinSize
        SUB     LR, LR, #1
        BICS    R0, R0, LR                      ; clear bottom bits
        MOVNE   R0, #-1                         ; -1 if non-0
        MVNS    R0, R0                          ; Z=1 if can shrink
d1587 2
a1588 2
        BNE     %FT01
        DLINE   "can shrink"
d1590 1
a1590 1
        DLINE   "<CanBigDirShrink"
d1592 1
a1592 1
        Pull    "R0,PC"
d1609 1
a1609 1
        Push    "R0-R11,LR"
d1612 1
a1612 1
        DLINE   ">ShrinkBigDir"
d1615 7
a1621 7
        BL      BigDirFreeSpace                 ; (R5->LR)      
        ASSERT  BigDirMinSize=2048
        
        MOV     R8, LR, LSR #11
        MOV     R8, R8, LSL #11                 ; number of bytes to shrink dir by
        
        BL      InvalidateBufDir                ; going to alter BufDir
d1623 9
a1631 9
        LDR     R7, [R5, #BigDirSize]           ; current size of dir
        ADD     R0, R5, R7
        SUB     R0, R0, #BigDirTailSize         ; source for move
        SUB     R1, R0, R8                      ; dest for move
        MOV     R2, #BigDirTailSize             ; size of tail
        BL      BlockMove                       ; do the move
        
        SUB     R7, R7, R8                      ; new size of dir
        STR     R7, [R5, #BigDirSize]
d1633 7
a1639 9
        BL      BigDirHasSharedObjects          ; is it sharing with anything?
        BEQ     %FT50                           ; yes, sharing
        
        BL      CritInitReadNewFs               ; (->R10,R11)
        
        BIC     R1, R3, #&ff
        BL      MeasureFileAllocSize_GotMap     ; (r1->r0)
        
        Push    "R0"
d1641 32
a1672 96
        BL      ReadAllocSize                   ; (R3->LR)
        SUB     LR, LR, #1                      ; alloc size -1
        ADD     R1, R7, LR
        BIC     R1, R1, LR                      ; size rounded up
        
        MOV     R0, R1                          ; R0 = rounded up size wanted
        
        LDRB    LR, [R10, #ZoneHead+BitSize]
        MOV     R1, R1, LSR LR                  ; number of map bits needed for object
        
        BIC     R2, R3, #&ff
        
        BL      DefFindFragment                 ; (R1, R2, R10 -> R1, R9, R11, LR)
        
        ; R1  - map ptr to desired offset
        ; R11 - map ptr to fragment start
        ; LR  - number of bits left in fragment
        ; R0  - size to set length to
        ; R9  - pre gap

; first check that length to start of frag is OK

        SUBS    R1, R1, R11                     ; offset into frag
        BEQ     %FT40                           ; fragment disappearing entirely
        
        LDRB    R8, [R10, #ZoneHead+LinkBits]
        ADD     R8, R8, #1
        
        CMP     R1, R8                          ; is it too close to start of frag
        BGE     %FT30
        
 [ DebugX
        DLINE   "frag would be too short - adjusting length"
 ]
        
; if fragment is going to be too short then
        SUB     R8, R8, R1                      ; need this many extra bits
        ADD     R1, R1, R11
        ADD     R1, R1, R8
        
        LDRB    R2, [R10, #ZoneHead+BitSize]    ; size of a map bit
        
        ADD     R0, R0, R8, LSL R2              ; new file size
        SUB     LR, LR, R8                      ; number of bits left in fragment
        

30 ; here when new fragment length long enough

        LDRB    R8, [R10, #ZoneHead+LinkBits]   ; get LinkBits again
        ADD     R8, R8, #1
        CMPS    LR, R8
        
        BGE     %FT40                           ; shortening by more than LinkBits+1, so safe

 [ DebugX
        DREG    LR, "shortening by:"
 ]
        
        MOV     R2, LR                          ; keep number of bits around
        
; here when shortening by less than LinkBits+1.  check that object followed by a gap

        Push    "R7"
        BL      FragRdLenBits                   ; (R10->R11,R7)
        ADD     R8, R11, R7                     ; next object
        Pull    "R7"
        MOV     R11, R9
        BL      NextFree                        ; (R10,R11->R9,R11)
        CMPS    R11, R8                         ; is it a gap
        BEQ     %FT40

 [ DebugX
        DLINE   "can't shorten"
 ]
        
        LDRB    R8, [R10, #ZoneHead+BitSize]
        ADD     R0, R0, R2, LSL R8              ; new length

40 ; here when new length is OK
        Pull    "R1"
        
 [ DebugX
        DREG    R0, "new length is:"
        DREG    R1, "old length is:"
 ]

        BIC     R2,R3,#&ff
        BL      ReturnSpace                     ; return allocated space
        
        BL      WriteDirThenFsMap
        BVS     %FT95
        B       %FT60

50      ; sharing so just write the dir
        BL      WriteDir
        BVS     %FT95
d1675 9
a1683 9
        ; now sort out the parent
        MOV     R2, R3                          ; keep ind disc add around
        BL      ToParent                        ; (R3, R5->R3)
        CMPS    R2, R3                          ; is it the root dir
        BNE     %FT70                           ; not root dir
        
        ; alter the size in the disc record
        
        BL      DiscAddToRec    ; get disc record
d1685 1
a1685 1
        STR     R7, [LR, #RootDirSize]          ; store the root dir size in the disc record
d1694 1
a1694 1
        STR     R7, [R10, #ZoneHead+RootDirSize]
d1696 3
a1698 3
        BL      WriteFsMap
        B       %FT95
        
d1700 3
a1702 3
        BL      GetDir
        BVS     %FT95                           ; can't get the dir!
        BL      GetDirFirstEntry                ; (R3, R5->R4)
d1705 8
a1712 8
        BL      BigDirFinished                  ; (R4,R5->Z)
        BEQ     %FT95
        BL      ReadIndDiscAdd                  ; (R3,R4->LR)
        TEQ     R2,LR
        BEQ     %FT85
        ADD     R4, R4, #BigDirEntrySize
        B       %BT80
        
d1714 4
a1717 4
        ; found dir entry, write updated length
        MOV     R0, R7
        BL      WriteLen
        BL      WriteDir
d1720 1
a1720 1
        STRVS   R0, [SP]
d1722 1
a1722 1
        DLINE   "<ShrinkBigDir"
d1725 1
a1725 1
        Pull    "R0-R11,PC"
d1739 1
a1739 1
        Push    "R1,R4, LR"
d1741 2
a1742 2
        BL      GetDirFirstEntry        ; (R3, R5->R4)
        MOV     R1, R3, LSR #8
d1745 7
a1751 7
        BL      BigDirFinished          ; (R5, R4 -> Z)
        BEQ     %FT90
        BL      ReadIndDiscAdd          ; (R3, R4 -> LR)
        TEQS    R1, LR, LSR #8  ; is it in the same disc object?
 [ DebugX
        BNE     %FT01
        DLINE   "dir shares with child"
d1754 6
a1759 6
        Pull    "R1, R4, PC",EQ
        ADD     R4, R4, #BigDirEntrySize
        B       %BT10
        
90      ; run out of dir
        MOVS    R1, #1          ; Z=0
d1761 1
a1761 1
        DLINE   "dir does not share with child"
d1763 2
a1764 2
        
        Pull    "R1,R4, PC"
d1787 1
a1787 1
        Push    "R1-R11, LR"
d1789 1
a1789 1
        DLINE   ">DoOsFunRenameBigDir"
d1793 1
a1793 1
        
d1810 5
a1814 5
        SUB     SP, SP, #BigDirEntrySize+4+4
        MOV     R0, R4
        MOV     R1, SP
        MOV     R2, #BigDirEntrySize
        BL      BlockMove       ; (R0-R2)
d1844 1
a1844 1
        DSTRING R1, "New final component:"
d1852 7
a1858 7
        
        ; if renaming a directory, then before we can do anything else, we'll
        ; need to ensure that there's space
        
        LDR     R2, [SP, #BigDirObNameLen]; get the old name length
        ADD     R2, R2, #4
        BIC     R2, R2, #3              ; allocated length
d1861 1
a1861 1
        DREG    R2, "Old allocated name length:"
d1863 7
a1869 7
        
        BL      SkipTerm                ;(R1->R0,R1)
        LDR     LR, [SP, #BigDirEntrySize]
        SUB     R1, R1, LR              ;new name length
        STR     R1, [SP, #BigDirEntrySize+4]    ; store new name length
        ADD     R1, R1, #4
        BIC     R1, R1, #3              ;new required allocated length
d1871 1
a1871 1
        DREG    R1, "New required:"
d1873 2
a1874 2
        
        SUBS    R1, R1, R2              ;extra required
d1876 1
a1876 1
        DREG    R1, "Extra required for name:"
d1878 1
a1878 1
        BLE     %FT09                   ;no extra needed
d1880 2
a1881 2
        TSTS    R11, #DirBit
        BEQ     %FT08                   ;if not moving a dir then no need to thingy
d1883 12
a1894 12
        Push    "R3"
        MOV     R3, R9
        BL      MaybeGrowBigDirForName  ;(R1,R3->R0,V)
        Pull    "R3"
        BVS     %FT90
        
        BL      GetDir                  ; get the parent dir back
        BVS     %FT90                   ; if error then error it is
        
        ; dir's length may have changed, so update our copy of the entry
        LDR     LR, [R8, #BigDirSize]
        STR     LR, [SP, #BigDirSize]
d1898 1
a1898 1
        DLINE   "Considering growing dir"
d1900 10
a1909 10
        BL      BigDirFreeSpace         ; (R5->LR)
        CMPS    LR, R1
        BLLO    GrowBigDir              ; (R3,R5,R6->R0, LR)
        BVS     %FT90                   ;

        ; because dir entry may have been altered, take a copy
        MOV     R0, R8
        MOV     R1, SP
        MOV     R2, #BigDirEntrySize
        BL      BlockMove               ;(R0,R1,R2)
d1914 8
a1921 8
        BL      InvalidateBufDir        ; going to write this dir out
        Push    "R4"
        MOV     R4, R8                  ; dir entry being removed
        BL      RemoveDirEntryOnly      ; remove just the dir entry, not allocated space
        Pull    "R4"
        CMPS    R4, R8
        SUBHI   R4, R4, #BigDirEntrySize        ; bump down ptr if needs it
        
d1923 3
a1925 3
        LDR     R1, [SP, #BigDirEntrySize] ; size of dir entry
        BL      MakeBigDirSpace         ; make space for entry
        
d1927 5
a1931 5
        MOV     R0, SP
        MOV     R1, R4
        MOV     R2, #BigDirObNameLen
        BL      BlockMove               ; copy entry
        
d1933 9
a1941 9
        LDR     R1, [SP, #BigDirEntrySize]
        BL      WriteBigName            ; write the name
        BL      WriteDir
        BVS     %FT90
        
        BL      CanBigDirShrink
        BLEQ    ShrinkBigDir
        BVS     %FT90
        
d1943 5
a1947 5
        MOV     R1, R3
        BL      %FT10
        BVS     %FT90
        
        B       %FT80
d1960 1
a1960 1
        MOV     R3, R9          ;child dir
d1963 1
a1963 1
        BVS     %FT14
d1967 28
a1994 35
        LDR     R7, [R5, #BigDirNameLen]
        LDR     R6, [SP, #8*4+BigDirEntrySize+4]
        STR     R6, [R5, #BigDirNameLen]
 [ DebugX
        DREG    R6, "new dir name length is:"
        DREG    R7, "old dir name length is:"
 ]
        ADD     R6, R6, #4
        BIC     R6, R6, #3
        ADD     R7, R7, #4
        BIC     R7, R7, #3
        LDR     R2, [R5, #BigDirEntries]
        LDR     LR, [R5, #BigDirNamesSize]

 [ BigDirFix
        ASSERT  BigDirEntrySize=28
        RSB     R2, R2, R2, LSL #3      ; *7
        ADD     R2, LR, R2, LSL #2      ; *7*4=*28
 |
        ASSERT  BigDirEntrySize=32
        ADD     R2, LR, R2, LSL #5
 ]
        ADD     R0, R5, #BigDirHeaderSize
        ADD     R0, R0, R7
        ADD     R1, R5, #BigDirHeaderSize
        ADD     R1, R1, R6
 [ DebugX
        DREG    R0, "src:"
        DREG    R1, "dst:"
        DREG    R2, "len:"
 ]
        BL      BlockMove               ; (R0, R1, R2)
        MOV     R1, R6
        ADD     R0, R5, #BigDirName
        BL      ZeroRam                 ; (R0, R1)
d1996 2
a1997 2
        DREG    R0, "zer:"
        DREG    R1, "len:"
d1999 2
a2000 2
        LDR     R6, [R5, #BigDirNameLen]
        ADD     R7, R5, #BigDirName
d2003 4
a2006 4
        BVS     %FT14
        
        BL      CanBigDirShrink
        BLEQ    ShrinkBigDir
d2020 2
a2021 2
        MOV     R1, R4
        MOV     R2, #BigDirObNameLen
d2036 1
a2036 1
        DLINE   "renaming across (big) dirs"
d2068 7
a2074 7
        ; check to see if we need to grow the new parent
        
        LDR     R1, [SP, #BigDirEntrySize]
        BL      IsBigDirFull
        BLVS    GrowBigDir      ; need to grow new parent
        BVS     %FT90           ; can't grow it
        
d2077 6
a2082 6
        ; if renaming a directory, then before we can do anything else, we'll
        ; need to ensure that there's space
        
        LDR     R2, [SP, #BigDirObNameLen]; get the old name length
        ADD     R2, R2, #4
        BIC     R2, R2, #3              ; allocated length
d2085 1
a2085 1
        DREG    R2, "Old allocated name length:"
d2087 7
a2093 7
        
        BL      SkipTerm                ;(R1->R0,R1)
        LDR     LR, [SP, #BigDirEntrySize]
        SUB     R1, R1, LR              ;new name length
        STR     R1, [SP, #BigDirEntrySize+4]    ; store new name length
        ADD     R1, R1, #3
        BIC     R1, R1, #3              ;new required allocated length
d2095 1
a2095 1
        DREG    R1, "New required:"
d2097 2
a2098 2
        
        SUBS    R1, R1, R2              ;extra required
d2100 1
a2100 1
        DREG    R1, "Extra required for name:"
d2102 1
a2102 1
        BLE     %FT38                   ;no extra needed
d2104 2
a2105 2
        TSTS    R11, #DirBit
        BNE     %FT38           ; not a dir, so don't bother
d2107 12
a2118 12
        Push    "R3"
        MOV     R3, R9
        BL      MaybeGrowBigDirForName  ;(R1,R3->R0,V)
        Pull    "R3"
        BVS     %FT90
        
        BL      GetDir                  ; get the parent dir back
        BVS     %FT90                   ; if error then error it is
        
        ; dir's length may have changed, so update our copy of the entry
        LDR     LR, [R8, #BigDirSize]
        STR     LR, [SP, #BigDirSize]
d2167 3
a2169 3
        BVS     %FT90
        BL      CanBigDirShrink
        BLEQ    ShrinkBigDir
d2172 1
a2172 1
        
d2175 1
a2175 1
        MOV     R0, #0
d2186 1
a2186 1
        DLINE   "<DoOsFunRenameBigDir"
d2200 1
a2200 1
        Push    "R0-R11, LR"
d2203 1
a2203 1
        DLINE   ">MaybeGrowBigDirForName"
d2206 2
a2207 2
        BL      GetDir          ; (R3->R5, R6->R0, V)
        BVS     %FT95
d2209 3
a2211 3
        BL      BigDirFreeSpace ; (R5->LR)
        CMP     R1, LR
        BLO     %FT90
d2213 3
a2215 3
        BL      GrowBigDir      ; (R3, R5, R6->R0, V)
        BVS     %FT95
        
d2217 1
a2217 1
        MOV     R0, #0  
d2219 2
a2220 2
        BL      SetVOnR0
        STRVS   R0, [SP]
d2222 1
a2222 1
        DLINE   "<MaybeGrowBigDirForName"
d2224 1
a2224 1
        Pull    "R0-R11, PC"
d2250 1
a2250 1
        DREG    R6, ", start entry:"
d2260 1
a2260 1
        MOV     R4, R6          ;get first dir entry to start at
d2268 2
a2269 2
        ADD     R4, R4, #BigDirEntrySize
        BL      BigDirFinished
d2271 1
a2271 1
        TOGPSR  Z_bit,LR
d2291 1
a2291 1
        MOV     R0, #0          ; fall through to ReturnSpaceNotFudged
d2338 2
a2339 2
        Push    "R6"
        LDR     R6, [SP, #6*4]
d2341 1
a2341 1
        Pull    "R6"
d2372 1
a2372 1
        BVC     %FT96
a2380 30
 [ :LNOT: BigDirFullBackup

; ================
; BigDirBackupMove
; ================

; construct the backup entries

; entry:

; r0 - source addr
; r1 - dest addr
; r2 - number of bytes (word multiple)

BigDirBackupMove ROUT
	Push	"R0-R2,LR"

	CMP     R2, #0
	BEQ     %FT95
	
	ADD	R0, R0, #BigDirIndDiscAdd
	
10
	LDR	LR, [R0], #BigDirEntrySize
	SUBS	R2, R2, #4
	STR	LR, [R1], #4
	BNE     %BT10
95
	Pull	"R0-R2,PC",,^
 ]
d2384 2
a2385 2
        LTORG
        END
@


1.1.2.4
log
@Fixed bugs in handling of growing directories, and made the directory
backup entries come back but only be one word long each.
@
text
@d1158 1
a1158 2
        Push    "R0-R2,R4,R6,LR"
        MOV	R6, #0
a1163 1
        ADDCC	R6, R6, #1
d1168 1
a1168 2
	STR	R6, [R5, #BigDirNameLen]
        Pull    "R0-R2,R4,R6,PC",,^
d1246 1
a1246 1
 [ DebugX :LOR: DebugXg
d1274 1
a1274 1
 [ DebugXg
d1286 1
a1286 1
15
d1288 1
a1288 1
 [ DebugXg
d1295 1
a1295 1
        BEQ     %FT25           ;end of list marker found
d1299 1
a1299 1
 [ DebugXg
d1306 1
a1306 1
        BEQ     %FT20
d1309 1
a1309 1
        BNE     %FT25		;note: this is a termination case due to the sorting of the dir
d1312 1
a1312 1
        BEQ     %FT20
d1315 1
a1315 1
        BHI     %FT20           ; no
d1318 1
a1318 1
 [ DebugXg
d1342 1
a1342 1
  [ DebugXg
d1352 1
a1352 1
 [ DebugXg
d1356 1
a1356 1
  [ DebugXg
d1366 12
a1377 3

; loop among Fcbs until we find that matches.  if it does, then we
; then have to 
d1379 1
a1379 1
        sbaddr  r1, FirstFcb-FcbNext
d1382 2
a1383 2
        LDR     r8, [r1, #FcbIndDiscAdd]
 [ DebugXg
d1388 1
a1388 1
 [ DebugXg
d1391 1
a1391 1
 	BL	Flush		;flush the file of interest
d1394 3
a1396 3
        LDR     r1, [r1,#FcbNext];get next FCB
        CMPS    r1, #-1
        BNE     %BT01           ;
d1398 1
a1398 9

        Push    "R1,R3,R4"
        BL      ReadIndDiscAdd
        MOV     R1, LR        
        MOV     R3, R10
        BL      DefaultMoveData         ; move the data
        BVS     %FT96                   ; argh
        Pull    "R1,R3,R4"

a1403 5
        ; now if we found a matching Fcb, update its ind disc address
        
        CMPS	R1, #-1
        STREQ	R2, [R1, #FcbIndDiscAdd]
        
d1407 2
a1408 2
20
        B       %BT15           ; round the loop again
d1410 1
a1410 1
25      ; SortDir didn't find any objects which clash.  do the grow operation, checking
d1415 1
a1415 1
 [ DebugXg
d1457 2
a1458 8
        MOV	R0, R10
        
        Push    "R0,R2,R4,R5,R8,R10"
        
        MOV	R0, R7
        
        BL	CritInitReadNewFs	; (->R10, R11)
        
d1461 2
a1462 103
        MOV     R1, R0, LSR R8          ; 
 
 ; *********************************************************************************************
 
 ; 04 Dec 1997 SBP - copied fixed code to shorten object back to reasonable length from 
 ;                   ShrinkBigDir routine, and made it fit :-)
 
 
 
 [ {TRUE}
 
        BL      DefFindFragment                 ; (R1, R2, R10 -> R1, R9, R11, LR)
        
 [ DebugXg
 	DREG	R1, "map ptr : "
 	DREG    R11, "frag at : "
 	DREG    LR,  "remains : "
 	DREG	R0, "new len : "
 ]
        
        ; R1  - map ptr to desired offset
        ; R11 - map ptr to fragment start
        ; LR  - number of bits left in fragment
        ; R0  - size to set length to
        ; R9  - pre gap

; first check that length to start of frag is OK

        SUBS    R1, R1, R11                     ; offset into frag
 [ DebugXg
 	BNE	%FT01
 	DLINE	"Frag disappearing entirely"
01
 ]
        BEQ     %FT40                           ; fragment disappearing entirely
        
        LDRB    R8, [R10, #ZoneHead+LinkBits]
        ADD     R8, R8, #1
        
        CMP     R1, R8                          ; is it too close to start of frag
        BGE     %FT30
        
 [ DebugXg
        DLINE   "frag would be too short - adjusting length"
 ]
        
; if fragment is going to be too short then
        SUB     R8, R8, R1                      ; need this many extra bits
        ADD     R1, R1, R11
        ADD     R1, R1, R8
        
        LDRB    R2, [R10, #ZoneHead+BitSize]    ; size of a map bit
        
        ADD     R0, R0, R8, LSL R2              ; new file size
        SUB     LR, LR, R8                      ; number of bits left in fragment
        

30 ; here when new fragment length long enough

        LDRB    R8, [R10, #ZoneHead+LinkBits]   ; get LinkBits again
        ADD     R8, R8, #1
        CMPS    LR, R8
        
        BGE     %FT40                           ; shortening by more than LinkBits+1, so safe

 [ DebugXg
        DREG    LR, "shortening by:"
 ]
        
        MOV     R2, LR                          ; keep number of bits around
        
; here when shortening by less than LinkBits+1.  check that object followed by a gap

        Push    "R7"
        BL      FragRdLenBits                   ; (R10->R11,R7)
        ADD     R8, R11, R7                     ; next object
        Pull    "R7"
        MOV     R11, R9
        BL      NextFree                        ; (R10,R11->R9,R11)
        CMPS    R11, R8                         ; is it a gap
        BEQ     %FT40

 [ DebugXg
        DLINE   "can't shorten"
 ]
        
        LDRB    R8, [R10, #ZoneHead+BitSize]
        ADD     R0, R0, R2, LSL R8              ; new length

40 ; here when new length is OK
        Pull    "R1,R2,R4,R5,R8,R10"
        
 [ DebugXg
        DREG    R0, "new length is:"
        DREG    R1, "old length is:"
 ]

        BL      ReturnSpace                     ; return allocated space
        
 ; *********************************************************************************************
 
 |
 
d1465 1
a1465 1
 [ DebugXg
d1470 1
a1470 1
 [ DebugXg
d1477 1
a1477 1
 [ DebugXg
d1485 1
a1485 1
 [ DebugXg
d1498 1
a1498 9

 ]
 
 
 ; *********************************************************************************************
 
 
 

d1512 1
a1512 1
 [ DebugXg
d1523 1
a1523 1
 [ DebugXg
d1531 1
a1531 1
 [ DebugXg
d1538 1
a1538 1
 [ DebugXg
d1544 1
a1544 1
 [ DebugXg
d1599 1
a1599 1
 [ DebugXg
@


1.1.2.5
log
@Fixed s.BigDirCode (GrowBigDir and ShrinkBigDir) to cope with BitSize<SecSize
and rewrote free space map memory management to place free space maps in
dynamic areas.
@
text
@d1510 2
a1511 7
        Push	"LR"
        
	BL	MinMapObj			; (R10->LR)
	
	MOV	R8, LR				; keep it around
	
	Pull	"LR"
a1673 4
 
 [ DynamicMaps
        LDR     r10, [r10, #DrvsFsMapAddr]
 |
a1675 1
 ]
d1844 2
a1845 6
        Push	"LR"
        
	BL	MinMapObj			; (R10->LR)
	MOV	R8, LR
	
	Pull	"LR"
a1929 3
 [ DynamicMaps
 	LDR	r10, [r10, #DrvsFsMapAddr]
 |
a1931 1
 ]
@


1.1.2.6
log
@Now supports formatting of floppies with long file names.
@
text
@d75 3
a2116 3
 [ DebugX
 	DREG	R2, "From allocated name length: "
 ]
d2123 1
a2123 1

a2125 3
 [ DebugX
 	DSTRING	LR, "and: "
 ]
d2153 2
a2154 2
        LDR     LR, [R8, #BigDirLen]
        STR     LR, [SP, #BigDirLen]
a2352 1
        DSTRING  R1, "Start with name:"
d2359 1
a2359 1
        ADD     R1, R1, #4
d2384 2
a2385 2
        LDR     LR, [R8, #BigDirLen]
        STR     LR, [SP, #BigDirLen]
d2389 1
a2389 1
	LDR	R1, [SP, #BigDirEntrySize]	; get term again
@


1.1.2.7
log
@Fixed:

DoOsFunRenameBigDir to work when renaming a shared file between dirs where
the file ends up as the last object in the target dir.

SanityCheckEDiscRecord to allow idlen>15 when DiscVersion=0

GrowBigDir to round up desired size to a multiple of the disc allocation
size.

Also:

Implemented non-working code to write cache the dir buffer.  WriteCacheDir
compile switch set to FALSE in s.DebugOpts.  Don't set it to TRUE unless
I tell you it's working.

Made SortDir not attempt to sort more than 2047 entries in a dir, to
avoid it overflowing ScratchSpace.

Made SortPair do one extra shell on the sort (makes it more efficient).
@
text
@d78 1
a78 1

d82 1
a82 1

d92 1
a92 1

d105 1
a105 1

d147 1
a147 1

d152 1
a152 1

d155 1
a155 1

d157 1
a157 1

d159 1
a159 1

d168 1
a168 1

d176 1
a176 1

d185 1
a185 1

d188 1
a188 1

d204 1
a204 1

d234 1
a234 1

d236 1
a236 1

d239 1
a239 1

d244 1
a244 1

d249 1
a249 1

d252 1
a252 1

d254 1
a254 1

d256 1
a256 1

d258 1
a258 1

d262 1
a262 1

d276 1
a276 1

d278 1
a278 1

d284 1
a284 1

d288 1
a288 1

d296 1
a296 1

d300 1
a300 1

d303 1
a303 1
; =================
d348 1
a348 1

d360 1
a360 1

d363 1
a363 1

d366 1
a366 1

d388 2
a389 2

; have space for entry
d414 1
a414 1

d416 1
a416 1

d421 1
a421 1

d432 1
a432 1

d451 1
a451 1

d462 1
a462 1

d464 1
a464 1

d469 1
a469 1

d480 1
a480 1

d508 2
a509 2

; have space for entry
d544 1
a544 1

d546 1
a546 1

d551 1
a551 1

d562 1
a562 1

d569 1
a569 1

d623 1
a623 1

d639 1
a639 1

d642 1
a642 1

d649 1
a649 1

d658 1
a658 1

d661 1
a661 1

d665 1
a665 1

d695 1
a695 1

d726 1
a726 1

d739 1
a739 1

d748 1
a748 1

d756 2
a757 2
        BCS     %BT10

d759 1
a759 1

d772 1
a772 1

d814 1
a814 1

d816 1
a816 1

d820 1
a820 1

d823 1
a823 1

d842 1
a842 1

d847 1
a847 1

d862 1
a862 1
BigDirFreeSpace ROUT
d871 1
a871 1

d889 1
a889 1

d894 1
a894 1

d907 1
a907 1
; entry:
d924 1
a924 1
        MOV     R6, LR
d976 1
a976 1

d982 1
a982 1

d986 1
a986 1

d1007 1
a1007 1

d1010 1
a1010 1

d1023 1
a1023 1

d1040 1
a1040 1

d1042 1
a1042 1

d1056 1
a1056 1

d1060 1
a1060 1

d1065 1
a1065 1
        LDRNE   LR, [R4, #BigDirObNamePtr]
d1068 1
a1068 1

d1070 1
a1070 1
;
d1075 1
a1075 1

d1099 1
a1099 1

d1179 1
a1179 1

d1184 1
a1184 1

d1207 1
a1207 1

d1209 1
a1209 1

d1211 1
a1211 1

d1214 1
a1214 1

d1219 1
a1219 1

d1256 1
a1256 1

d1281 1
a1281 1

d1283 1
a1283 1

d1307 1
a1307 1

d1310 1
a1310 1

d1316 1
a1316 1

d1324 1
a1324 1

d1341 1
a1341 1

d1344 1
a1344 1
        DREG    LR, "Ind disc add of entry:"
d1365 1
a1365 1

d1368 2
a1369 2
; then have to adjust it

d1392 1
a1392 1
        MOV     R1, LR
d1402 1
a1402 1

d1404 1
a1404 1

d1407 1
a1407 1

d1416 1
a1416 1

d1422 1
a1422 1

d1428 1
a1428 1

d1431 1
a1431 1

d1437 1
a1437 1

d1440 1
a1440 1

d1442 1
a1442 1

d1452 1
a1452 1

d1454 1
a1454 5

 [ F
	ADD	R7, R7, #262144		; 64K allocation?
	MOV	R10, R7
 |
a1455 1
 ]
d1460 1
a1460 1

d1462 1
a1462 1

d1464 1
a1464 1

d1466 1
a1466 1

d1468 1
a1468 3

	BL	RoundUp			; round to allocation unit

a1469 1

d1471 2
a1472 2
        MOV     R1, R0, LSR R8          ;

d1474 2
a1475 2

 ; 04 Dec 1997 SBP - copied fixed code to shorten object back to reasonable length from
d1477 3
a1479 3



d1481 1
a1481 1

d1483 1
a1483 1

d1490 1
a1490 1

d1506 1
a1506 1

d1508 1
a1508 1

d1510 1
a1510 1

d1512 1
a1512 1

d1514 1
a1514 1

d1517 1
a1517 1

d1521 1
a1521 1

d1526 1
a1526 1

d1528 1
a1528 1

d1531 1
a1531 1

d1538 1
a1538 1

d1544 1
a1544 1

d1546 1
a1546 1

d1561 1
a1561 1

d1567 1
a1567 1

d1574 1
a1574 1

d1576 1
a1576 1

d1578 1
a1578 1

d1609 1
a1609 1

d1616 2
a1617 2


d1619 3
a1621 3



d1626 1
a1626 1

d1628 1
a1628 1

d1630 1
a1630 1

d1639 1
a1639 1

d1646 1
a1646 1

d1676 1
a1676 1

d1686 1
a1686 1

d1692 1
a1692 1

d1694 1
a1694 1

d1696 1
a1696 1

d1698 1
a1698 1

d1719 1
a1719 1
        BL      GetDir
d1745 1
a1745 1
; ===============
d1763 1
a1763 1

d1798 1
a1798 1
        BL      BigDirFreeSpace                 ; (R5->LR)
d1800 1
a1800 1

d1803 1
a1803 1

d1812 1
a1812 1

d1818 1
a1818 1

d1820 1
a1820 1

d1823 1
a1823 1

d1830 1
a1830 1

d1832 1
a1832 1

d1835 1
a1835 1

d1837 1
a1837 1

d1839 1
a1839 1

d1850 1
a1850 1

d1852 1
a1852 1

d1855 1
a1855 1

d1857 1
a1857 1

d1860 1
a1860 1

d1864 1
a1864 1

d1869 1
a1869 1

d1871 1
a1871 1

d1874 1
a1874 1

d1881 1
a1881 1

d1887 1
a1887 1

d1889 1
a1889 1

d1904 1
a1904 1

d1910 1
a1910 1

d1918 1
a1918 1

d1933 1
a1933 1

d1935 1
a1935 1

d1950 1
a1950 1

d1955 1
a1955 1

d1969 1
a1969 1

d2014 1
a2014 1

d2020 1
a2020 1

d2050 1
a2050 1

d2092 1
a2092 1

d2099 1
a2099 1

d2109 1
a2109 1

d2112 1
a2112 1

d2136 1
a2136 1

d2151 1
a2151 1

d2154 1
a2154 1

d2184 1
a2184 1

d2188 1
a2188 1

d2194 1
a2194 1

d2200 1
a2200 1

d2204 1
a2204 1

d2209 1
a2209 1

d2274 1
a2274 1

d2339 1
a2339 1

d2344 1
a2344 1

d2349 1
a2349 1

d2358 1
a2358 1

d2368 1
a2368 1

d2383 1
a2383 1

d2386 1
a2386 1

d2393 2
a2397 1

a2413 3
	LDRVC	R1, [SP, #BigDirEntrySize]	; get term again
        BLVC    MakeBigDirSpace    ;(R3-R6)

a2427 2
	LDR	R1, [SP, #BigDirEntrySize]	; get term again
        BL      MakeBigDirSpace    ;(R3-R6)
d2443 1
a2443 1

d2479 1
a2479 1

d2486 1
a2486 1

d2488 1
a2488 1
        MOV     R0, #0
d2571 1
a2571 1
; it can only be used for Big dirs.  it must be
d2671 1
a2671 1

d2673 1
a2673 1

@


1.1.2.8
log
@Two bugs fixed:

1) Fixed ReallyShared so that it doesn't omit to check the first
   object in the directory being scanned.

2) Fixed a long-standing ADFSBuffers problem.  This involves the
   UpdateBufState function attempting to attach a buffer as the
   Older or Younger buffer of the previous or next buffer in a
   file respectively.  Unfortunately, if there's only one buffer
   for a file, then it may attempt to attach it to the file
   control block - which is wrong.  Modified UpdateBufState to
   only attempt this when there are more than one objects in
   the chain.  Note:  there still may be problems in certain
   cases; this may need further looking into.

   This problem probably doesn't occur without long file names
   support enabled, because the fcb's contents look different
   then (name field is 10 chars instead of 256) so the problem
   is less likely to occur accidentally.
@
text
@a697 50
 [ BinaryChop
; =========
; WildCheck
; =========

; check if wild card spec term has any wild cards

; entry:
;  R1   -> term, terminated by control codes, delete, space or delimiter

; exit:  EQ -> is wild card
;        NE -> no wild card

WildCheck ROUT
 [ DebugXb
	DREG	r1, "WildCheck(wild=",cc
	DLINE	")"
 ]

	Push	"R0, R1, LR"

	SUB	R1, R1, #1	; get to just before term (NextChar skips one)
10
	BL	NextChar	; get next wild character
	BCS	%FT20
	TEQS	R0, #DelimChar
	BEQ	%FT20

	TEQS	R0, #OneWildChar	; is this a wildcard?
	TEQNES	R0, #MultiWildChar
        BNE	%BT10

; here when found a wild ard
 [ DebugXb
	DLINE	"wildcard found"
 ]
	Pull	"R0, R1, PC"

20
; here when reched end; need to exit NE
	MOVS	R0, #1

 [ DebugXb
	DLINE	"no wildcard"
 ]

	Pull	"R0, R1, PC"
 ]


a728 5

 [ BinaryChop
	BL	WildCheck		; is it wildcarded?
	BNE	%FT99			; no!
 ]
a796 143
 [ BinaryChop
99
; name was not wildcarded; we can binary chop it!

; register allocation.

; r8 = offset of entry of interest
; r9 = number of entries in range being considered
; r4 = ptr to current entry being examined
; r5 = start of dir

	Push	"r8, r9"

	ADD	r4, r4, #BigDirEntrySize

; first, work out offset of r4 in dir
	MOV	r8, r4				; R4 = size of an entry
	BL	GetDirFirstEntry		; (R3,R5->R4)

	SUB	lr, r8, r4			; offset in bytes between start entry and thing

	MOV	r9, #BigDirEntrySize		; size of a dir entry

 [ DebugX
	DREG	r8, "r8 : "
	DREG	lr, "lr : "
	DREG	r9, "r9 : "
	DREG	r4, "r4 : "
 ]

	DivRem	r8, lr, r9, r4			; r8 = offset into dir

 [ DebugXb
	DREG	r8, "init offset: "
 ]

	LDR	r9, [r5, #BigDirEntries]	; number of entries in the dir
	SUB	r9, r9, r8			; difference

 [ DebugXb
	DREG	r9, "init range: "
 ]

	CMPS	r9, #0
	BNE	%FT05

	; not found

	BL	GetDirFirstEntry		; (R3,R5->R4)
	ASSERT	BigDirEntrySize=28

        RSB     R8, R8, R8, LSL #3              ; *7
        ADD     R4, R4, R8, LSL #2              ; 7*4=28

	SEC

	Pull	"r8, r9"

	B	%BT90

05

; here we have to check the middle item in the

;	ADD	lr, r9, #1
 [ DebugXb
	DREG	r8, "start: "
	DREG	r9, "len: "
 ]
	ADD	r8, r8, r9, LSR #1		; r8 <- offset of entry to look into

	BL	GetDirFirstEntry		; (R3,R5->R4)
	ASSERT	BigDirEntrySize=28

        RSB     LR, R8, R8, LSL #3              ; *7
        ADD     R4, R4, LR, LSL #2              ; 7*4=28

; now R4->entry of interest

        Push    "R4,R5,R6"
        LDR     R6, [R4, #BigDirObNameLen]
        BL      GetBigDirName           ; get the name's address (in LR)
        MOV     R4, LR
        MOV     r5, #&ff                ; mask is ff
        BL      BigLexEqv               ; (R1,R4,R5->LO/EQ/HI)
        Pull    "R4,R5,R6"

	BEQ	%FT80			; name=wild

	BCC	%FT20			; name<wild

	CMPS	r9, #1
	BEQ	%FT75

; name>wild.  range becomes below r8
	SUB	r8, r8, r9, LSR #1
	MOV	r9, r9, LSR #1
	B	%BT05

20
	CMPS	r9, #1
	BEQ	%FT70
; name<wild.  range becomes above r8
	ADD	r8, r8, #1
	SUB	r9, r9, #1
	MOVS	r9, r9, LSR #1
	BNE	%BT05			; if it's zero then it's not found


70
	; not found
	ADD	R4, R4, #BigDirEntrySize
75
	SEC
	Pull	"R8, R9"
	B	%BT90


80
        ; Match, but...
        BL      ReadBigDirIntAtts       ; read the attributes

;LR=Atts
        TSTS    LR, #DirBit
        BNE     %FT85                   ; found a dir
;found a file

        TSTS    R2, #MustBeDir
        BNE     %BT70
;fall through next few instructions as EQ
85
        TSTNES  R2, #MustBeFile
        BNE     %BT70

        TSTS    LR, #DirBit :SHL: 2,2 ;restore Z=1 <=> file, C=0

	Pull	"R8, R9"

	B	%BT90


 ]

d2543 1
a2543 2
        SUB     R4, R6, #BigDirEntrySize          ;get first dir entry to start at
	B	%FT10
@


1.1.2.9
log
@Binary-chop dir scanning fixed.  (BigLexEqv fixed so that it doesn't
try to compare the dir separator '.' in eg "Default.Thing" with another
object called "Default+" (was breaking binary chop dir search).

Fixed IdentifyDisc (s.Identify); old behaviour left the RootDir field
invalid (the disc bits were an external drive number, instead of an
internal disc number).  This causes problems if the disc fails to mount
due to, for example, memory problems, as the illegal value never gets
fixed (normally, MountDiscOnDrive would end up correcting the problem).
@
text
@d436 2
a437 2
        SUBS    R5, R9, R8              ; number of names transferred
        MOVEQ   R9, #-1                 ; finished
d484 2
a485 2
        SUBS    R5, R9, R8              ; number of names transferred
        MOVEQ   R9, #-1                 ; finished
d566 2
a567 2
        SUBS    R5, R9, R8              ; number of names transferred
        MOVEQ   R9, #-1                 ; finished
a946 3
 [ DebugXb
	DLINE	"name>wild"
 ]
a951 3
 [ DebugXb
	DLINE	"name<wild"
 ]
a971 3
 [ DebugXb
	DLINE	"Match, but..."
 ]
@


1.1.2.10
log
@Fixed 4 bugs in DoOsFunRenameBigDir involving renameing of objects
between dirs with long filenames.

Fixed bug in OsFunResolveWildcard on long filenames.
@
text
@d594 1
a594 1
 [ DebugX :LAND: {FALSE}
d1969 1
a1969 1
 [ DebugX :LOR: DebugXg
d1975 1
a1975 1
 [ DebugX :LOR: DebugXg
d1984 1
a1984 1
 [ DebugX :LOR: DebugXg
d2009 1
a2009 1
 [ DebugX :LOR: DebugXg
d2076 1
a2076 1
 [ DebugX :LOR: DebugXg
d2099 1
a2099 1
 [ DebugX :LOR: DebugXg
d2116 1
a2116 1
 [ DebugX :LOR: DebugXg
d2126 1
a2126 1
 [ DebugX :LOR: DebugXg
d2193 1
a2193 1
 [ DebugX :LOR: DebugXg
d2260 1
a2260 1
 [ DebugX :LOR DebugXr
a2261 1
	DREG	r3, "source dir ind disc add: "
a2269 3
 [ DebugXr
	DREG	r9, "Ind disc add of object being moved: "
 ]
a2295 3
 [ DebugXr
	DREG	R3, "Dest ind dir: "
 ]
d2315 1
a2315 1
 [ DebugX :LOR: DebugXr
d2329 1
a2329 1
 [ DebugX :LOR: DebugXr
d2335 1
a2335 1
 [ DebugX :LOR: DebugXr
d2341 1
a2341 1
 [ DebugX :LOR: DebugXr
d2348 1
a2348 1
 [ DebugX :LOR: DebugXr
d2353 1
a2353 1
 [ DebugX :LOR: DebugXr
d2361 1
a2361 1
        Push    "R1,R3"
d2363 3
a2365 4
        BL      MaybeGrowBigDirForName  ;(R1,R3->R0,R1,V)
        STR     R1, [SP, #BigDirLen+2*4]
        Pull    "R1,R3"
	BVS	%FT90
d2370 3
d2375 1
a2375 1
 [ DebugX :LOR: DebugXr
d2448 1
a2448 1
 [ DebugX :LOR: DebugXr
d2471 1
a2471 1
 [ DebugX :LOR: DebugXr
d2480 1
a2480 1
 [ DebugX :LOR: DebugXr
a2501 3
 [ DebugXr
	DLINE	"filling in and writing out new parent dir"
 ]
a2514 4
 [ DebugXr
	LDR	lr, [r5, #BigDirEntries]
	DREG	lr, "entries: "
 ]
d2520 1
a2520 1
 [ DebugX :LOR: DebugXr
a2530 4
 [ DebugXr
	DLINE	"check for duff rename"
 ]

a2531 4
 [ DebugXr
	DREG	R3, "start from: "
	DREG	r9, "renaming: "
 ]
a2537 4
 [ DebugXr
	DREG	R3, "compare ",cc
	DREG	R9, "with "
 ]
a2541 3
 [ DebugXr
	DREG	R3, "parent is:"
 ]
a2545 3
 [ DebugXr
	DLINE	"rename OK"
 ]
a2547 4
 [ DebugXr
	DREG	R3, "retrieving new parent dir: "

 ]
d2569 1
a2569 1
 [ DebugX :LOR: DebugXr
d2580 1
a2580 1
 [ DebugX :LOR: DebugXr
d2585 1
a2585 1
 [ DebugX :LOR: DebugXr
d2591 1
a2591 1
        BEQ     %FT38           ; not a dir, so don't bother
d2595 1
a2595 1
        BL      MaybeGrowBigDirForName  ;(R1,R3->R0,R1,V)
d2603 2
a2604 5
        STR     R1, [SP, #BigDirLen]

 [ DebugX :LOR: DebugXr
	DREG	R1, "Updated length is..."
 ]
a2610 3
 [ DebugXr
	DLINE	"renaming of shared object"
 ]
a2625 3
 [ DebugXr
	DebugError "Error after DefaultMoveData: "
 ]
a2639 12
	BL	InvalidateBufDir

 [ DebugXr
	DLINE	"about to write target dir"
	LDR	lr, [r5, #BigDirEntries]
	DREG	lr, "entries: "
	DREG	r3, "In disc add in R3:"
	BVC	%FT01
	DLINE	"V set before WriteFsMapThenDir!"
01
 ]

a2640 3
 [ DebugXr
	DebugError "error when writing fsmap then dir: "
 ]
a2644 3
 [ DebugXr
	DLINE	"renaming of unshared object"
 ]
a2651 5
 [ DebugXr
	DLINE	"object now in destination dir"
 ]

	MOVVC	R1,R3
d2675 1
a2675 1
 [ DebugX :LOR: DebugXr
a2688 10
; exit:

;   either:

;     directory has been grown, R1 = new size of directory

;   or:

;     directory grow failed, R0 -> error block, V set

d2690 1
a2690 1
        Push    "R0,R2-R11, LR"
a2710 1
	LDRVC	R1, [R5, #BigDirSize]	; return new size of dir
a2711 4
	BVC	%FT01
	DREG	R1, "New dir size: "
01
	DebugError	"Error from MaybeGrowBigDirForName: "
d2714 1
a2714 1
        Pull    "R0,R2-R11, PC"
@


1.1.2.11
log
@Now uses new Ursula service call mechanism.
@
text
@a82 5
 [ DebugXd
	ADD	lr, r5, #BigDirName
	DSTRING	lr, "sanity check; name: "
 ]

d408 1
a408 1
 [ DebugX :LOR: DebugXd
d456 1
a456 1
 [ DebugX :LOR: DebugXd
d538 1
a538 1
 [ DebugX :LOR: DebugXd
a665 4
; [ DebugXd
;	DREG	LR, "name ptr:"
; ]

a1334 3
 [ DebugXd
	DSTRING	R1, "WriteBigName : "
 ]
a1362 3
 [ DebugXd
	DSTRING	R1, "WriteBigDirName : "
 ]
@


1.1.2.12
log
@Found a major inefficiency in the handling of file creation, closing of files
and other uses of the NextFree function.  In the case of file creation, the
problem was particularly bad on large free space maps, as the function was
of order N^2 on the size of the map, when the disc was nearly full.  As the
disc gets fuller, the problem gets worse; with 1400 zones in the map, N^2
is very large indeed.  This resulted in *cdir sometimes taking 1sec.

Now, a new function NextFree_Quick exists which performs similarly to NextFree,
but does not consider free spaces in zones beyond the current zone.  This
can be used by functions which need only examine free spaces in a given zone,
such as is the case in ClaimFreeSpace where it is stepping throigh zones to
find a single gap large enough for the entire file.

For other functions which work on a single zone, the speedup is less dramatic,
of the order N instead of N^2.
@
text
@d1784 1
a1784 2
        BL      NextFree_Quick                  ; (R10,R11->R9,R11)
	BCS	%FT35				; exhausted, so no gap
a1787 1
35
d2127 1
a2127 2
        BL      NextFree_Quick                  ; (R10,R11->R9,R11,Z,C)
	BCS	%FT35
a2130 1
35
@


1.1.2.13
log
@Fixed bug with zone compaction with idlen>15, in CompactZone.
@
text
@a2875 1
 [ {FALSE}
a2880 119
; this function acts like ReturnWholeSpace, but avoids the nasty fudge
; of the start of directory to ReallyShared (which is a bit nasty)

; it also doesn't need the old length of the file; this avoids the need
; to call MeasureFileAllocSize

; it can only be used for Big dirs.  it must be

; entry:

;  R2 Ind Disc address of file
;  R3 dir ind disc add
;  R4 -> dir entry
;  R5 -> dir start, MUST NOT BE FUDGED
;  r6 -> dir entry to start search at for ReallySharedNotFudged

; exit: IF error V set, R0 result

; register allocation


ReturnWholeSpaceNotFudged
 [ Debug5 :LOR: DebugX
        DLINE   "new len :old len :ind disc:dir     :DirEntry:DirStart enter ReturnWholeSpaceNotFudged"
        DREG   R0," ",cc
        DREG   R1," ",cc
        DREG   R2," ",cc
        DREG   R3," ",cc
        DREG   R4," ",cc
        DREG   R5," ",cc
        DREG   R6," "
 ]
        Push    "R0-R4,R6-R11,LR"

        TSTS    R2, #&FF
        BEQ     %FT15           ;not shared obj
        TEQS    R6, #0
        BNE     %FT90           ;IF not returning whole obj then done
        Push    "R6"
        LDR     R6, [SP, #6*4]
        BL      ReallySharedNotFudged    ;(R2-R6->Z)
        Pull    "R6"
        BEQ     %FT90           ;IF frag shared then done
        BIC     R2, R2, #&FF

	BIC	R2, R2, #DiscBits
	MOV	R2, R2, LSR #8	; linkbits

15
        BL      CritInitReadNewFs   ;(->R10,R11)

	MOV	r0, #0		;start from zone zero
	LDRB	r1, [R10, #ZoneHead+Zones]
	LDRB	lr, [R10, #ZoneHead+Zones2]
	ADD	r1, r1, lr, LSL #8	; number of zones in map

17
	BL	InitZoneObj	; (R0, R10 -> R8, R9, R11, LR) prepare to work on this zone
        MOV	R3, R8		;pre gap
	MOV	R6, LR		;end of zone

20
	CMPS	R11, R6
	BHS	%FT50		;end of zone
	TEQS	R9, R11
	BNE	%FT30		;not gap

; gap
	BL	FreeRdLenLinkBits    	; (R10, R11 -> R7, R8)
	MOV	R3, R9		     	; update prev gap
	ADD	R9, R9, R8	     	; update gap
	ADD	R11, R11, R7		; and ptr

	B	%BT20

30
; not gap.  check if this is something we want to shorten
	BL	FragRdLenLinkBits	; get frag length and bits
	TEQS	R8, R2
	ADDNE	r11, r11, r7
	BNE	%BT20			; if not match then don't bother shortening the frag

	Push	"R0-R2"
	MOV	r0, #0
	MOV	r1, r7
	MOV	r2, r11
        BL      ShortenFrag     	;(R0-R3,R10)
	Pull	"R0-R2"

	B	%BT17			;back round in this zone for more!



50
	; end of this zone
	ADD	r0, r0, #1		; advance to next zone
	TEQS	r0, r1			; run out of zones?
	BNE	%BT17			; no, back round zone

        BL      InvalidateFragCache

90
        MOV     R0, #0
95
        BL      SetVOnR0
 [ Debug5 :LOR: DebugX
        BVC     %FT96
        DREG   R0," ",cc
96
        DLINE "leave ReturnSpaceNotFudged"
 ]
        STRVS   R0, [SP]
        Pull    "R0-R4,R6-R11,PC"

 |
; =========================
; ReturnWholeSpaceNotFudged
; =========================

a2882 2

 ]
@


1.1.2.14
log
@  Merge of ROL branch to the Ursula branch.
Admin:
  Lots of bugfixes - see ROL branch logs for details.
@
text
@a19 3
	GBLL	MBFix
MBFix	SETL	T

a1591 3
 [ MBFix
	BL	ReadIndDiscAdd
 ]
d1599 1
a1599 6

 [ MBFix
	CMP	r8,lr
 |
        CMPS    R8, r1
 ]
d1627 1
a1627 4
        CMP	R1, #-1
 [ MBFix
        STRNE	R2, [R1, #FcbIndDiscAdd]
 |
a1628 1
 ]
@


1.1.2.13.2.1
log
@  Import of RISC OS Ltd version of FileCore.
Admin:
  These sources are imported for interest only and must NOT be merged
    without wide prior consultation.

Tagged as ROL_FileCore-3_20
@
text
@a19 3
	GBLL	MBFix
MBFix	SETL	T

a1591 3
 [ MBFix
	BL	ReadIndDiscAdd
 ]
d1599 1
a1599 6

 [ MBFix
	CMP	r8,lr
 |
        CMPS    R8, r1
 ]
d1627 1
a1627 4
        CMP	R1, #-1
 [ MBFix
        STRNE	R2, [R1, #FcbIndDiscAdd]
 |
a1628 1
 ]
@

head	4.18;
access;
symbols
	FileCore-3_75:4.18
	FileCore-3_74:4.18
	FileCore-3_73:4.18
	FileCore-3_72:4.18
	FileCore-3_71:4.18
	FileCore-3_70:4.18
	FileCore-3_69:4.17
	FileCore-3_68:4.17
	FileCore-3_67:4.16
	FileCore-3_66:4.15
	FileCore-3_65:4.15
	FileCore-3_64:4.15
	FileCore-3_63:4.13
	FileCore-3_62:4.13
	FileCore-3_61:4.13
	FileCore-3_60:4.13
	FileCore-3_59:4.13
	FileCore-3_58:4.13
	FileCore-3_57:4.13
	FileCore-3_56:4.13
	FileCore-3_55:4.12
	FileCore-3_54:4.11
	FileCore-3_53:4.10
	FileCore-3_52:4.10
	FileCore-3_51:4.10
	FileCore-3_50:4.10
	FileCore-3_49:4.10
	FileCore-3_48:4.10
	FileCore-3_47:4.10
	FileCore-3_46:4.10
	FileCore-3_45:4.10
	FileCore-3_44:4.9
	FileCore-3_43:4.9
	FileCore-3_42:4.9
	FileCore-3_41:4.8
	FileCore-3_40:4.7
	FileCore-3_39:4.7
	FileCore-3_38:4.6
	FileCore-3_37:4.6
	FileCore-3_36:4.6
	FileCore-3_35:4.6
	FileCore-3_34:4.6
	FileCore-3_33:4.6
	RO_5_07:4.6
	FileCore-3_32:4.6
	FileCore-3_31:4.6
	FileCore-3_30:4.5
	FileCore-3_29:4.5
	FileCore-3_28:4.5
	FileCore-3_25-4_9_2_2:4.5
	FileCore-3_27:4.5
	FileCore-3_26:4.5
	FileCore-3_22-4_6_2_1:4.3
	bavison_FileCore-3_22_dev_bp:4.3
	bavison_FileCore-3_22:4.3.0.2
	FileCore-3_25-4_9_2_1:4.5
	HAL:4.5.0.2
	FileCore-3_25:4.5
	FileCore-3_24:4.5
	FileCore-3_23:4.4
	dellis_autobuild_BaseSW:4.3
	FileCore-3_22:4.3
	Ursula_merge:4.2.2.2
	ROL_merge:4.2.2.2
	FileCore-3_21:4.3
	ROL_Ursula_merge:4.2.2.2
	Ursula_RiscPC_merge:4.2.2.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.5
	ROL_FileCore-3_21:4.2.2.2
	ROL_FileCore-3_20:4.2.2.2
	ROL:4.2.2.2.0.4
	ROL_bp:4.2.2.2
	Ursula_RiscPC_bp:4.2.2.2
	FileCore-3_18:4.2.2.2
	FileCore-3_01:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.2
	Ursula_RiscPC:4.2.2.2.0.2
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.2.2.2
	sproven_FileCore-3_16:4.2.2.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.2
	UrsulaBuild_FinalSoftload:4.2.2.2
	rthornb_UrsulaBuild-12Aug1998:4.2.2.2
	aglover_UrsulaBuild-05Aug1998:4.2.2.2
	rthornb_UrsulaBuild-29Jul1998:4.2.2.2
	rthornb_UrsulaBuild-22Jul1998:4.2.2.2
	rthornb_UrsulaBuild-15Jul1998:4.2.2.2
	rthornb_UrsulaBuild-07Jul1998:4.2.2.2
	rthornb_UrsulaBuild-17Jun1998:4.2.2.2
	rthornb_UrsulaBuild-03Jun1998:4.2.2.2
	rthornb_UrsulaBuild-27May1998:4.2.2.2
	rthornb_UrsulaBuild-21May1998:4.2.2.2
	sproven_FileCore-3_15:4.2.2.2
	sproven_314:4.2.2.2
	rthornb_UrsulaBuild_01May1998:4.2.2.2
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.2.2.2
	sproven_3_11:4.2.2.2
	sproven_3_10:4.2.2.2
	sproven_Ursula_3_09:4.2.2.2
	sproven_3_07:4.2.2.2
	sproven_3_06:4.2.2.2
	sproven_3_05:4.2.2.2
	sproven_3_04:4.2.2.2
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.2.2.2
	sproven_3_02:4.2.2.2
	sproven_3_01:4.2.2.1
	sproven_2_99:4.2.2.1
	sproven_2_98:4.2
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.18
date	2016.07.24.10.55.13;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	CCTrYcRnnZTvZyfz;

4.17
date	2015.10.28.21.13.07;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	qv1t5E2AqM2y5VGy;

4.16
date	2015.10.02.00.25.09;	author jlee;	state Exp;
branches;
next	4.15;
commitid	aP9CFLSrSFje1tDy;

4.15
date	2014.11.02.17.25.24;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	afoCgwcyXTmkoDWx;

4.14
date	2014.07.14.10.17.10;	author bavison;	state Exp;
branches;
next	4.13;
commitid	F4g0Km5lRubbBkIx;

4.13
date	2013.02.24.21.09.15;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	rgJG8ZFRF8o9ruFw;

4.12
date	2013.02.21.16.53.07;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	CCuV2tngKttj75Fw;

4.11
date	2012.10.28.08.52.32;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	6n5fY77YU7JEb8qw;

4.10
date	2011.10.14.07.23.51;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	D2Id4aPp4zmuUhDv;

4.9
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	A9Zxco9ydo9FCOBv;

4.8
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	PKTDORFkNFRVOmzv;

4.7
date	2011.08.04.20.43.10;	author jlee;	state Exp;
branches;
next	4.6;
commitid	zcIknvqdwARiCeuv;

4.6
date	2003.04.03.18.33.28;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.31.09.32.30;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.11.36.54;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.18.43;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.32.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.08.14.13.13.07;	author sproven;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.11.17.13.32.25;	author sproven;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.32.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.22.39;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.02;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.30.56;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.18
log
@Build fix
Module_Title->Module_TitleStr from Kernel-5_54.

Version 3.70. Tagged as 'FileCore-3_70'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >FileCore30

        TTL     "Useful Routines"

; *********************************
; ***  CHANGE LIST AND HISTORY  ***
; *********************************
;
; 16-Jun-94   AMcC  Replaced ScratchSpaceSize with ?ScratchSpace
;

UseScratchSpace * 0     ;these are bit numbers
UseSpareScreen  * 1
UseWimpFree     * 2
UseRmaHeap      * 3
UseSysHeap      * 4

        ASSERT  DiscOp_Op_ScatterList_Flag=1 :SHL: 5

UseApplicArea   * 6

UseIndOp        * 7     ;set this bit if to use file start and offset
                        ;rather than physical disc address
UseDirSpace     * 8

;must have all files closed to use dir space as it includes file buffers

; ===============
; DefaultMoveData
; ===============

; MoveData using all possible RAM, and indirect disc addresses, from start

DefaultMoveData
        MOV     R0, #(1:SHL:UseScratchSpace) :OR: (1:SHL:UseSpareScreen) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: (1:SHL:UseIndOp) :OR: DiscOp_Op_ScatterList_Flag
        MOV     R4, #0   ;fall into MoveData

; ========
; MoveData
; ========

;entry
; R0 data move option bits, must have scatter bit set
; R1 source
; R2 dest
; R3 length
; R4 start offset if UseIndOp

;exit
; R0 IF error V set, R0 result
; R1 incremented by amount transferred if not UseIndOp
; R2 incremented by amount transferred if not UseIndOp
; R3 decremented by amount transferred
; R4 incremented by amount transferred if UseIndOp

MoveData
        Push    "R0-R11,LR"
 [ DebugD
        mess    ,"options |source  |dest    |length  |offset - enter MoveData",NL
        DREG    R0
        DREG    R1
        DREG    R2
        DREG    R3
        DREG    R4
        mess    ,,NL
 ]
        LDMIA   SP, {R6-R10}

        MOV     R3, R7
        BL      IncUsage        ;stops disc searching forgetting other disc
        BL      ReadAllocSize   ;(R3->LR) chunks must be multiple of larger alloc. size
        MOV     R1, LR
        MOV     R3, R8
        BL      IncUsage        ;(R3)
        BL      ReadAllocSize   ;(R3->LR)
        CMPS    R1, LR
        MOVHS   R3, R1
        MOVLO   R3, LR
        MOV     R1, R3
        CMPS    R9, R3
        MOVHS   R2, R9
        MOVLO   R2, R3
        BL      FindBuffer      ;(R0-R3->R0-R2,V)
        Push    "R1,R2"
        BVS     %FT95
10
        LDMIA   SP, {R3,R4}     ;scatter ptr, buffer length
        CMPS    R4, R9
        MOVHI   R4, R9
        MOV     R11,R4

        TSTS    R6, #1 :SHL: UseIndOp
        MOVNE   R5, R10
        Push    "R3-R5"
        MOV     R1, #DiscOp_ReadSecs :OR: DiscOp_Op_ScatterList_Flag :OR: DiscOp_Op_IgnoreEscape_Flag
        MOV     R2, R7
        BL      InitScatter
        BLNE    GenIndDiscOp    ;(R1-R5->R0,R3-R5,V)
        BLEQ    DoDiscOp        ;(R1-R4->R0,R2-R4,V)
        Pull    "R3-R5"
        BVS     %FT90

        TSTS    R6, #1 :SHL: UseIndOp
        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_ScatterList_Flag :OR: DiscOp_Op_IgnoreEscape_Flag
        MOV     R2, R8
        BL      InitScatter
        BLNE    GenIndDiscOp    ;(R1-R5->R0,R3-R5,V)
        BLEQ    DoDiscOp        ;(R1-R4->R0,R2-R4,V)

        SUB     R11,R11,R4      ;amount transferred
 [ BigDisc
        MOVEQ   R3, R7          ; for ReadSectorSize
        BLEQ    ReadSectorSize  ; get sector size
        ADDEQ   R7, R7, R11, LSR LR
        ADDEQ   R8, R8, R11, LSR LR
        SUB     R9, R9, R11
        ADDNE   R10,R10,R11
 |
        ADDEQ   R7, R7, R11
        ADDEQ   R8, R8, R11
        SUB     R9, R9, R11
        ADDNE   R10,R10,R11
 ]
        BVS     %FT90
        TEQS    R9, #0          ;any left ?
        BNE     %BT10
90
        BL      ReturnBuffer
95
        ADD     SP, SP, #2*4      ;balance stack
        MOV     R3, R7
        BL      DecUsage
        MOV     R3, R8
        BL      DecUsage
        STMIB   SP, {R7-R10}
 [ DebugD
        mess    ,"source  |dest    |length  |offset  |result - leave MoveData",NL
        DREG    R1
        DREG    R2
        DREG    R3
        DREG    R4
        DREG    R0,VS
        mess    ,,NL
 ]
        STRVS   R0, [SP]
        Pull    "R0-R11,PC"


; ===========
; InitScatter
; ===========

; init scatter list from copy

InitScatter
        Push    "R0-R3,LR"
        SavePSR R3
        sbaddr  R1, ScatterList
        ADD     R0, R1, #ScatterCopy-ScatterList
        MOV     R2, #ScatterListLen
        BL      BlockMove
        RestPSR R3,,f
        Pull    "R0-R3,PC"

; =========
; ReadHex64
; =========

; Routine to convert a hex string to a 64bit cardinal value.
;
; entry
;    R0 - pointer to string to convert
;
; exit
;    R1 - ls word of value
;    R2 - ms word of value

; The routine uses OS_ReadUnsigned to read the two words
; of the value.  As the length of the number is not
; known when generating the value, the routine must
; perform some adjustment of the value to generate the
; appropriate information.

ReadHex64 ROUT
        Push    "R3,R4,LR"
        MOV     R1, #0
        MOV     R2, #0
        MOV     R4, #0

10
        LDRB    R3,[R0],#1
        CMP     R3,#'a'
        SUBHS   R3, R3, #32

        CMP     R3,#'0'
        RSBHSS  LR,R3,#'F'
        BLT     %FT90           ; not any sort of digit

        CMP     R3,#'9'
        SUBLE   R3, R3, #'0'
        BLE     %FT30           ; a number

        SUBS    R3,R3,#'A'
        RSBHSS  LR,R3,#'F'-'A'
        ADD     R3,R3,#10
        BLT     %FT90           ; not A-F

30
        MOV     R2, R2, LSL #4
        ADD     R2, R2, R1, LSR #28
        ADD     R1, R3, R1, LSL #4
        B       %BT10

90
 [ DebugQ
        DREG    R1, "L.S. word"
        DREG    R2, "M.S. word"
 ]
        Pull    "R3,R4,PC"

; ==========
; FindBuffer
; ==========

; find some RAM to use as buffer

; entry
;  R0 data move option bits
;  R1 min length MUST BE NON ZERO
;  R2 max length
;  R3 all chunks must be multiple of this length, which is a power of 2

; exit
; IF error V set, R0 result
; ELSE
;  R0 ?
;  R1 start RAM address or ptr to scatter list if scatter requested
;  R2 length claimed
;  R3 ?

FindBuffer ROUT
        Push    "R0-R3,R4-R11,LR"
 [ DebugD
        mess    ,"options |min buf |max buf |blk size - FindBuffer",NL
        DREG    R0, " ", cc
        DREG    R1, " ", cc
        DREG    R2, " ", cc
        DREG    R3, " "
 ]
        BL      ReturnBuffer    ;return any chunks still claimed
        Pull    "R4-R7"

        LDR     LR, FS_Flags
        TSTS    LR, #CreateFlag_NoBigBuf
        ANDNE   R4, R4, #DiscOp_Op_ScatterList_Flag :OR: (1 :SHL: UseScratchSpace)

        SUB     R7, R7, #1      ;make a mask

        CMP     R6, #1*K*M      
        MOVHI   R6, #1*K*M      ;clamp at 1G RAM claim
        ADDLS   R6, R6, R7
        BICLS   R6, R6, R7      ;or round up to nearest chunk multiple

        MOV     R8, #0          ;init chunk ctr
        MOV     R9, #0          ;init total length
00
        MOV     R11,#0          ;init max length this pass

        TSTS    R4, #1 :SHL: UseScratchSpace
        MOVNE   R0, #UseScratchSpace
        MOVNE   R2, #?ScratchSpace
        BLNE    %FT90

        TSTS    R4, #1 :SHL: UseSpareScreen
        BEQ     %FT05
        MOV     R0, #ClaimSpareScreen
        MOV     R1, #&ffffffff          ;force claim fail in order to read free
        BL      OnlyXOS_ClaimScreenMemory      ;(R0,R1->R1,R2,C)
        MOV     R0, #UseSpareScreen
        MOV     R2, R1
        BL      %FT90

05
        TSTS    R4, #1 :SHL: UseWimpFree
        BEQ     %FT07
        MOV     R0, #1
        MOV     R1, #&ffffffff          ; Much too much to get claimed
        BL      OnlyXWimp_ClaimFreeMemory
        BVS     %FT07                   ;no wimp
        CMPS    R1, #0
        BEQ     %FT07                   ;already claimed/none available
        MOV     R0, #UseWimpFree
        MOV     R2, R1
        BL      %FT90

07
        TSTS    R4, #1 :SHL: UseRmaHeap
        BEQ     %FT10
        MOV     R0, #ModHandReason_RMADesc
        BL      OnlyXOS_Module          ;(R0->R0,R2,R3,V)
        BVS     %FT10
        SUBS    r2, r2, #2048
        MOVGT   R0, #UseRmaHeap
        BLGT    %FT90

10
        TSTS    R4, #1 :SHL: UseSysHeap
        BEQ     %FT15
        MOV     R0, #HeapReason_Desc
        BL      OnlySysXOS_Heap         ;(R0->R0,R2,R3,V)
        BVS     %FT15
        SUBS    r2, r2, #2048
        MOVGT   r0, #UseSysHeap
        BLGT    %FT90

15
        TSTS    R4, #1 :SHL: UseApplicArea
        BLNE    OnlyXOS_GetEnv
        MOVNE   R0, #UseApplicArea
        SUBNE   R2, R1, #AppSpaceStart
        BLNE    %FT90

        TSTS    R4, #1 :SHL: UseDirSpace
        MOVNE   R0, #UseDirSpace
        LDRNE   R2, FileBufsStart
        SUBNE   R2, R2, SB
 [ BigDir
        SUBNE   R2, R2, #(:INDEX:DirCache) :AND: :NOT: 255
        SUBNE   R2, R2, #(:INDEX:DirCache) :AND: 255
 |
        SUBNE   R2, R2, #:INDEX:DirBuffer
 ]
        BLNE    %FT90

        ; With modern kernels not supporting free pool locking, our original
        ; tactic of just claiming free space without actively growing DAs isn't
        ; going to work, because we no longer have the free pool to fall back on
        ; as a source of 'infinite' free memory.
        ; So if we've failed to find enough free space, and claiming from the
        ; RMA is allowed, try growing the RMA to be large enough and then give
        ; it another chance.
        CMP     R11, R5                 ;failed to get min length
        CMPLO   R9, #1                  ;and haven't claimed any yet
        BHS     %FT17
        TST     R4, #1 :SHL: UseRmaHeap ;and RMA available
        BEQ     %FT17
        ; Try and limit max claim to 1MB so that we don't completely empty the
        ; free pool. I.e. claim max(min(1MB,max_length),min_length)
        CMP     R6, #1 :SHL: 20
        MOVHS   R1, #1 :SHL: 20
        MOVLO   R1, R6
        CMP     R1, R5
        MOVLO   R1, R5
        ; Round up to size multiple
        ADD     R1, R1, R7
        BIC     R1, R1, R7
        ; Add safety net to ensure background claimants have a little bit of
        ; free memory to work with
        ADD     R1, R1, #4096
        ; Grow dynamic area (will probably leave us with more space than we
        ; need, but will avoid us claiming all the spare heap space and causing
        ; issues for background claimants)
        MOV     R0, #1
 [ DebugD
        DREG    R1, "trying to grow RMA by "
 ]
        SWI     XOS_ChangeDynamicArea
 [ DebugD
        DREG    R1, "managed to grow RMA by "
 ]
        ; Check RMA again if any grow was performed
        CMP     R1, #0
        BEQ     %FT17
        MOV     R0, #ModHandReason_RMADesc
        BL      OnlyXOS_Module          ;(R0->R0,R2,R3,V)
        BVS     %FT17
        SUBS    r2, r2, #2048
        MOVGT   R0, #UseRmaHeap
        BLGT    %FT90

17
        TSTS    R4, #DiscOp_Op_ScatterList_Flag
        BEQ     %FT20
        TEQS    R11,#0                  ;scatter case, claim any
        BEQ     %FT18
        BL      %FT45
        TEQS    R8,#ScatterMax
        BNE     %BT00                   ;loop until no more or list full
18      CMPS    R9, R5
        BLO     %FT35                   ;if failed to get min
        BL      InitScatter
        sbaddr  R1,ScatterList
        B       %FT25

20
        CMPS    R11,R5
        BLO     %FT40
        BL      %FT45
25
        MOV     R0, #0
        MOV     R2, R9
        B       %FT42

35
        BL      ReturnBuffer
40
        MOV     R0, #BufferErr
42
        BL      SetVOnR0
 [ DebugD
        mess    ,"options |buffer  |length  - leave FindBuffer",NL
        DREG    R0
        DREG    R1
        DREG    R2
        mess    ,,NL
 ]
        Pull    "R4-R11,PC"

Sink
        Pull    "PC"

45                                      ;CLAIM CHUNK
 [ DebugD
        DREG    R10
        DREG    R11
        mess    ,"Claim Chunk",NL
 ]
        MOV     R2,R11
        Push    "LR"
        CMPS    R10,#UseScratchSpace
        LDREQ   R1, =ScratchSpace
        BICEQ   R4, R4, #1 :SHL: UseScratchSpace  ;cant use it again

        CMPS    R10,#UseSpareScreen
        BNE     %FT50
        MOV     R0, #ClaimSpareScreen
        MOV     R1, R11
        BL      OnlyXOS_ClaimScreenMemory       ;(R0,R1->R1,R2,C)
        ADDCS   SP, SP, #4
        BCS     %BT00                   ;unexpected space claim failure
        MOV     R0, #WrchV
        baddr   R1, Sink
        BL      OnlyXOS_Claim           ;(R0,R1->R0,V) ignore errors
        MOV     R1, R2
        BIC     R4, R4, #1 :SHL: UseSpareScreen

50
        CMPS    R10,#UseWimpFree
        BNE     %FT52
        MOV     R0, #1
        MOV     R1, R11
        BL      OnlyXWimp_ClaimFreeMemory
        BIC     R4, R4, #1 :SHL: UseWimpFree
        MOV     R1, R2
52

        MOV     R3, R11
        CMPS    R10,#UseRmaHeap
        BNE     %FT55
        MOV     R0, #ModHandReason_Claim
        BL      OnlyXOS_Module
        B       %FT60

55
        CMPS    R10,#UseSysHeap
        BNE     %FT65
        MOV     R0, #HeapReason_Get
        BL      OnlySysXOS_Heap         ;(R0,R3->R0,R2,V)
60
        ADDVS   SP, SP, #4
        BVS     %BT00                   ;unexpected space claim failure
        MOV     R1, R2
65
        CMPS    R10,#UseApplicArea
        BNE     %FT70

        MOV     R0, #FSControl_StartApplication ; Start parent module up as application
        baddr   R1, anull               ; command tail
        LDR     R2, ParentBase          ; CAO pointer
        LDR     R3, [R2, #Module_TitleStr] ; command name
        BL      OnlyXOS_FSControl
        MOV     R1, #AppSpaceStart
        BIC     R4, R4, #1 :SHL: UseApplicArea

70
        CMPS    R10,#UseDirSpace
        BLEQ    LockDirCache
        BLEQ    InvalidateBufDir
        BLEQ    InvalidateDirCache
 [ BigDir
        sbaddr  R1, DirCache,EQ
 |
        sbaddr  R1, DirBuffer,EQ
 ]
        BICEQ   R4, R4, #1 :SHL: UseDirSpace

        MOV     R2, R11
        sbaddr  R3, ScatterSource
        STRB    R10,[R3,R8]
        ADD     R3, R3, #ScatterCopy-ScatterSource
        ADD     R3, R3, R8, LSL #3
 [ DebugD
        DREG    R1
        DREG    R2
        mess    ,"add len",NL
 ]
        STMIA   R3, {R1,R2}             ;save (address,length) pair
        ADD     R8, R8, #1
        ADD     R9, R9, R2
        STRB    R8, ScatterEntries

        Pull    "PC"

;  R0 chunk source
;  R2 chunk length
;  R4 option bits
;  R5 min length
;  R6 max length
;  R7 bits to clear to round length
;  R8 chunk ctr
;  R9 total length claimed
;  R10 source of max length chunk
;  R11 max length this pass

90                      ;FIND BIGGEST SOURCE
        SUB     R3, R6, R9      ;max amount still needed
        CMPS    R2, R3          ;if this chunk bigger than that
        MOVGT   R2, R3          ;reduce it
        BIC     R2, R2, R7      ;ensure multiple of correct length
        CMPS    R2, R11         ;IF bigger than largest this pass
        MOVGT   R11,R2          ; alter largest this pass
        MOVGT   R10,R0          ; note source
        MOV     PC, LR


; ============
; ReturnBuffer
; ============

; return chunks claimed from spare screen and system heap to form buffer

ReturnBuffer ROUT
        Push    "R0-R5,LR"
        SavePSR R5
        MOV     R0, #WrchV              ;release WrchV from sink even if not
        baddr   R1, Sink                ;claimed
        BL      OnlyXOS_Release         ;(R0,R1->R0,V) ignore errors
        LDRB    R4, ScatterEntries
        B        %FT10
05
        sbaddr  R0, ScatterCopy
        LDR     R2, [R0,R4,LSL #3]       ;->chunk
        SUB     R0, R0, #ScatterCopy-ScatterSource
        LDRB    R1, [R0,R4]

 [ DebugD
        DREG    R1
        DREG    R2
        mess    ,"return chunk",NL
 ]

        CMPS    R1, #UseSpareScreen
        MOVEQ   R0, #ReleaseSpareScreen
        BLEQ    OnlyXOS_ClaimScreenMemory

        CMPS    R1, #UseWimpFree
        MOVEQ   R0, #0
        BLEQ    OnlyXWimp_ClaimFreeMemory

        CMPS    R1, #UseRmaHeap
        MOVEQ   R0, #ModHandReason_Free
        BLEQ    OnlyXOS_Module          ;(R0,R2->R0,V)
 [ Dev
        mess    VS,"bad RMA return",NL
 ]
        CMPS    R1, #UseSysHeap
        MOVEQ   R0, #HeapReason_Free
        BLEQ    OnlySysXOS_Heap         ;(R2->R0,V)
 [ Dev
        mess    VS,"bad sys heap return",NL
 ]
        CMPS    R1, #UseDirSpace
        BLEQ    UnlockDirCache
        STRB    R4, ScatterEntries
10
        SUBS    R4, R4, #1
        BPL     %BT05
        RestPSR R5,,f
        Pull    "R0-R5,PC"


; ======
; UpCall
; ======

;common code for UpCall_MediaNotPresent and UpCall_MediaNotKnown
;OSS Now tells driver to eject the preffered drive, if the driver claims
;to support any ejects. This works even when auto insert detecting because
;FileCore always examines the disc and calls UpCall() only if the disc is
;not found, so we are in no danger of ejecting the new disc.

;entry
; R0    UpCall reason code
; R1 -> disc name (possibly not terminated if max length)
; R4    iteration counter

;exit   C=1 <=> upcall claimed
; R2,R3 corrupt
; R4    incremented

disc DCB "disc",0
        ALIGN
        ^ 0,sp
UpCall_NameBuffer       # NameLen+1
UpCall_MediaTypeBuffer  # 30
UpCall_FrameSize * :INDEX:@@ + 3 :AND: :NOT: 3

UpCall
        Push    "r0,r1,r5,r6,lr"
 [ DebugU
        DREG    r0,"UpCall(",cc
        DSTRING r1,",",cc
        DREG    r4,",",cc
        DLINE   ")"
 ]
        SUB     sp, sp, #UpCall_FrameSize
        MOV     r0, #MiscOp_PollPeriod
        BL      Parent_Misc     ;(R0->R5,R6)
 [ DebugU
        DREG    r5, "PollPeriod = "
 ]
        CMPS    r5, #1
        BCC     %FT90           ;C=0 <=> r5=0, not worth doing upcall eg RAMFS

        ; Copy disc name to name buffer
        ADR     r2, UpCall_NameBuffer
        ADD     lr, r1, #NameLen
20
        CMPS    r1, lr
        LDRNEB  r0, [r1], #1
        CMPNES  r0, #DeleteChar
        CMPNES  r0, #DelimChar
        CMPNES  r0, #" "
        STRHIB  r0, [r2], #1
        BHI     %BT20

        MOV     r0, #0
        STRB    r0, [r2]

        ; Historically, FileCore ignored the media type string. ADFS and SCSIFS
        ; provided it (at least as far back as CVS goes) but didn't
        ; internationalise it. RAMFS doesn't provide it (but it specifies a
        ; zero timeout so we don't get this far). Let's be paranoid and check
        ; that it looks like a valid string, and if it's the string "disc" then
        ; assume it's not internationalised and look it up in FileCore's messages.
        RSBS    lr, r6, #&8000 ; low number means probably invalid
        MOVCC   r0, r6
        ADDCC   r1, r6, #99
        SWICC   XOS_ValidateAddress
        BCS     %FT30
        baddr   r2, disc
27      LDRB    r3, [r0], #1
        LDRB    lr, [r2], #1
        TEQ     r3, lr
        BNE     %FT28 ; string isn't "disc"
        TEQ     lr, #0
        BNE     %BT27
        B       %FT30 ; string is "disc", so internationalise it
28      MOV     r0, r6
29      LDRB    lr, [r0], #1
        TEQ     lr, #0
        BEQ     %FT40 ; found a null terminator, assume string at r6 is OK
        TEQ     lr, #&7F
        CMPNE   lr, #&1F
        BLS     %FT30 ; found other non-printing character, assume duff
        CMP     r0, r1
        BLS     %BT29
        ; No terminator found in first 100 bytes, assume duff so drop through
        
30      ; Generate media type string
        baddr   r0, disc
        ADR     r2, UpCall_MediaTypeBuffer
        MOV     r3, #?UpCall_MediaTypeBuffer
        BL      message_lookup_to_buffer
        BVS     %FT90
        ADR     r6, UpCall_MediaTypeBuffer
40

; OSS Tell driver to eject the preferred drive, if it supports ejects.
; Supported registers for the MiscOp are:
; r0 = Misc_Eject
; r1 = &80000000 (top bit set means preferred drive)
; r4 = iteration count (to allow driver to ignore some eg. only expel
;      on first call, only expel every 10 if fast polling etc.)
; r5 = minimum timeout period in centisceonds (to allow drive to work out
;      if expelling is sensible)

        LDR     lr, FS_Flags
        TST     lr, #CreateFlag_FloppyEjects :OR: CreateFlag_FixedDiscEjects
        BEQ     %FT50

        MOV     r0, #MiscOp_Eject
        MOV     r1, #((1 :SHL: 31) :EOR: 4)
        BL      Parent_Misc
50
        LDRB    r0, [sp, #UpCall_FrameSize + 0*4]
        LDRB    r1, FS_Id
        MOV     r2, sp
        MOV     r3, #-1         ;invalid device no
 [ DebugU
        DREG    r0,"OnlyXOS_UpCall(",cc
        DREG    r1,",",cc
        DSTRING r2,",",cc
        DREG    r3,",",cc
        DREG    r4,",",cc
        DREG    r5,",",cc
        DSTRING r6,",",cc
        DLINE   ")"
 ]
        BL      OnlyXOS_UpCall
 [ DebugU
        DLINE   "UpCall returned"
 ]
        ADD     r4, r4, #1
        RSBS    lr, r0, #0      ;C=1 <=> r0=0, upcall claimed

90
        ADD     sp, sp, #UpCall_FrameSize
        Pull    "r0,r1,r5,r6,pc"


; ========
; IncUsage
; ========

; R3 top 3 bits disc

IncUsage
        Push    "R0,LR"
        BL      DiscAddToRec    ;(R3->LR)
        LDRB    R0,[LR,#DiscUsage]
        ADD     R0,R0,#1
        STRB    R0,[LR,#DiscUsage]
        Pull    "R0,PC"


; ========
; DecUsage
; ========

; R3 top 3 bits disc

DecUsage
        Push    "R0,R1,LR"
        SavePSR R1
        BL      DiscAddToRec    ;(R3->LR)
        LDRB    R0,[LR,#DiscUsage]
        SUBS    R0,R0,#1
        STRPLB  R0,[LR,#DiscUsage]
        RestPSR R1,,f
        Pull    "R0,R1,PC"


; ============
; ReadTimeDate
; ============

; exit R7,R8 are load & exec addresses for data type with date&time stamp

ReadTimeDate
        Push    "R0,R1,LR"
        MOV     R0,#OsWord_ReadRealTimeClock
        SUB     SP,SP,#8        ;space for param block
        MOV     R1,SP
        MOV     LR,#3
        STRB    LR,[R1]
        BL      OnlyXOS_Word
        LDRVC   R8,[R1]
        LDRVCB  R7,[R1,#4]
        MOVVS   R8,#-1
        MOVVS   R7,#&FF
        LDR     LR,=Data_LoadAddr
        ORR     R7,R7,LR
        ADDS    SP,SP,#8        ; clear V
 [ Debug9
        DREG    R7
        DREG    R8
        mess    ,"date stamp",NL
 ]
        Pull    "R0,R1,PC"


; ============
; FindErrBlock
; ============

; entry: R0=internal error code
; exit:  R0->error block, V=1 OTHER FLAGS PRESERVED

FindErrBlock ROUT
        Push    "R1-R3,LR"
        SavePSR R3
 [ NewErrors
        ASSERT  BigDisc
        CMP     R0, #256
        BHS     %FT45
 |
        TSTS    R0, #ExternalErrorBit
        BICNE   R0, R0, #ExternalErrorBit
 [ BigDisc
        BNE     %FT45
 |
        BNE     %FT50
 ]
        TSTS    R0, #DiscErrorBit
        BNE     %FT40
 ]
 [ Debug3
        DLINE   "FindErrBlock: In error table bit"
 ]
        AND     LR, R0, #&FF
        TEQS    LR, #IntEscapeErr
        BNE     %FT05
        MOV     R0, #OsByte_AcknowledgeEscape ;If error was escape then acknowledge
        BL      DoXOS_Byte              ;(R0-R2->R0-R2,V)
        MOV     LR, #ExtEscapeErr       ;ignore any secondary error
05
        baddr   R0, ErrorTable
10
        LDRB    R1, [R0]
        TEQS    R1, LR
        BEQ     %FT30   ;match found
20
        LDR     R1, [R0,#4] !   ;mismatch so skip rest of entry
        BIC     R2, R1, #&FF
        ASSERT  (FileCoreModuleNum :AND: &FF)<32
        TEQS    R2, #FileCoreModuleNum :SHL: 8
        BNE     %BT20
        TEQS    R1, #FileCoreModuleNum :SHL: 8
        BNE     %BT10           ;loop if more entries

30
        ; Copy the error and fix up the FS number in the error number
        BIC     r1, r1, #&ff00
        ORR     r1, r1, #(FileCoreModuleNum :SHL: 8) :AND: &ffff0000
        LDRB    lr, FS_Id
        ORR     r1, r1, lr, ASL #8
        BL      copy_error
        B       %FT50

 [ :LNOT: NewErrors
40                              ;Form disc err string
        Push    "r0,r4-r6"
 [ Debug3
        DLINE   "FindErrBlock: 40"
 ]
        SUB     sp, sp, #20

        CLRV    ; to ensure we catch out errors

        ; Drive number
        MOV     r0, r0, LSR #(24-3)     ; drive number (external)
        AND     r0, r0, #7
        MOV     r1, sp
        MOV     r2, #4
        BL      OnlyXOS_ConvertCardinal4

        ; Disc error number
        LDRVC   r0, [sp, #20]
        MOVVC   r0, r0, LSR #24
        ANDVC   r0, r0, #MaxDiscErr
        ADDVC   r1, sp, #4
        MOVVC   r2, #4
        BLVC    OnlyXOS_ConvertHex2

        ; Address
        LDRVC   r0, [sp, #20]
        MOVVC   r0, r0, ASL #8
        BICVC   r0, r0, #DiscBits
        ADDVC   r1, sp, #8
        MOVVC   r2, #12
        BLVC    OnlyXOS_ConvertHex8

        ; Stitch it all together
        baddr   r0, DiscErrBlk, VC
        LDRVC   r1, [r0]
        BICVC   r1, r1, #&ff00
        LDRVCB  lr, FS_Id
        ORRVC   r1, r1, lr, ASL #8
        BICVC   r1, r1, #&ff000000
        LDRVC   lr, [sp, #20]
        ANDVC   lr, lr, #MaxDiscErr :SHL: 24
        ORRVC   r1, r1, lr
        ADDVC   r4, sp, #4
        MOVVC   r5, sp
        ADDVC   r6, sp, #8
        BLVC    copy_error3             ; VS always out of this

        ; apparent unbalanced stack pull is correct
        ADD     sp, sp, #24
        Pull    "r4-r6"
 ] ; :LNOT:NewErrors

 [ BigDisc
        B       %FT50
45
 [ Debug3
        DLINE   "FindErrBlock: 45"
 ]
 [ NewErrors
        TSTS    R0,#NewDiscErrorBit
 |
        TSTS    R0,#DiscErrorBit
 ]
        BEQ     %FT50
 [ NewErrors
        BIC     R0,R0,#NewDiscErrorBit
 |
        BIC     R0,R0,#DiscErrorBit
 ]
; here if using an extended process error block
        Push    "r0,r4-r6"
        SUB     sp, sp, #40

        CLRV    ; to ensure we catch out errors

        ; Drive number
 [ NewErrors
        LDRB    r0, [r0,#0]
 |
        LDR     r0, [r0,#4]
        MOV     r0, r0, LSR #(32-3)     ; drive number (external)
 ]
        MOV     r1, sp
        MOV     r2, #4
        BL      OnlyXOS_ConvertCardinal4

        ; Disc error number
        LDRVC   r0, [sp, #40]
 [ NewErrors
        LDRVCB  r0, [r0, #1]
 |
        LDRVC   r0, [r0]
 ]
        ANDVC   r0, r0, #MaxDiscErr
        ADDVC   r1, sp, #4
        MOVVC   r2, #4
        BLVC    OnlyXOS_ConvertHex2
        BVS     %FT47

        ; Address
        LDR     r0, [sp, #40]
 [ NewErrors
        LDR     r5, [r0, #4]
        LDR     r0, [r0, #8]
 |
        LDR     r1, [r0, #4]
        MOV     r0, r1, LSR #(32-3)     ; drive bits

        EOR     r0,r0,#4                ; external to internal
        DrvRecPtr lr,r0
        LDRB    lr, [lr,#DrvsDisc]
        AND     lr, lr, #7
        DiscRecPtr lr, lr


        LDRB    r4, [lr, #DiscRecord_Log2SectorSize]
        RSB     r6, r4, #32
        BIC     r5, r1, #DiscBits
        MOV     r0, r5, LSR r6
 ]
        MOV     r6, r0                  ; remember upper word
        ADD     r1, sp, #8
        MOV     r2, #12
        BL      OnlyXOS_ConvertHex8
        BVS     %FT47

 [ NewErrors
        MOV     r0, r5
 |
        MOV     r0, r5, LSL r4
 ]
        ADD     r1, sp, #16
        MOV     r2, #12
        BL      OnlyXOS_ConvertHex8
        BVS     %FT47

        ; Stitch it all together
        baddr   r0, DiscErrBlk, VC
        LDR     r1, [r0]
        BIC     r1, r1, #&ff00
        LDRB    lr, FS_Id
        ORR     r1, r1, lr, ASL #8
        BIC     r1, r1, #&ff000000
        LDR     lr, [sp, #40]
 [ NewErrors
        LDRB    lr, [lr, #1]
 |
        LDRB    lr, [lr, #0]
 ]
        ORR     r1, r1, lr, LSL #24
        ADD     r4, sp, #4
        MOV     r5, sp
        TEQ     r6, #0                  ; print 8 or 16 digits
        ADDNE   r6, sp, #8
        ADDEQ   r6, sp, #16
        BL      copy_error3             ; VS always out of this

        ; apparent unbalanced stack pull is correct
47      ADD     sp, sp, #44
        Pull    "r4-r6"
 ]

50
        ORR     R3, R3, #V_bit
        RestPSR R3,,f
        Pull    "R1-R3,PC"

; =====
; WrHex
; =====

; write R0 as 8 digit hex number

; exit IF error V set, R0 result

WrHex   ROUT
        Push    "R7,LR"
        SUB     SP, SP, #12
        MOV     R7, SP
        BL      PutHexWord
        MOV     LR, #0
        STRB    LR, [R7],#1
        MOV     R7, SP
        BL      WriteString     ;(R7->R0,V)
        ADD     SP, SP, #12
        Pull    "R7,PC"


; =====
; WrDec
; =====

; write a space followed by a zero supressed decimal number

; entry R0 number

; exit if error V set, R0 result

 [ {FALSE}
WrDec   ROUT
        Push    "R0,R1,LR"
        MOV     R1,#10
        BL      Divide  ;(R0,R1->R0,R1)
        TEQS    R0,#0
        BEQ     %FT10
        BL      WrDec   ;(R0->R0,V)
        B       %FT20
10
        BL      DoSpace ;(->R0,V)
20
        ADDVC   R0,R1,#"0"
        BLVC    DoXOS_WriteC    ;(R0->R0,V)
95
        STRVS   R0,[SP]
        Pull    "R0,R1,PC"

 |


WrDecWidth10 ROUT
        Push    "R0-R4,LR"
        MOV     R2,#" "
        B        WrDecCommon

WrDec   ROUT
        Push    "R0-R4,LR"
        BL      DoSpace
        BVS     %FT99
        LDR     R0,[SP]
        MOV     R2,#0
WrDecCommon
        MOV     R4,SP
        MOV     R3,#10
10
        MOV     R1,#10
        BL      Divide
        Push    "R1"
        SUBS    R3,R3,#1
        BNE     %BT10
20
        Pull    "R0"
        TEQS    SP,R4
        MOVEQ   R2,#"0"
        TEQS    R0,#0
        MOVNE   R2,#"0"
        ADDNE   R0,R0,R2
        MOVEQS  R0,R2
        BLNE    DoXOS_WriteC    ;(R0->R0,V)
        BVS     %FT95
        TEQS    SP,R4
        BNE     %BT20
95
        MOV     SP,R4
99
        STRVS   R0,[SP]
        Pull    "R0-R4,PC"

 ]


; ----- ENTRY CHECKING ROUTINES -----

; Almost all entry points must check whether FileCore is willing to be entered and
; if not whether to
;  0) just return
;  1) flag error       - return V set, R0->Error Block

; this is done by putting at each entry point
;       Push    "R0,R1,SB,LR"
;       BL      [Dormant]Entry(NoErr/FlagErr)

; Dormant indicates that the entry point will only accept entries if FileCore
; is dormant ie no reentrancy

; these routines also point SB at the static base

; there should be a BL FileCoreExit at the end of the routine and any calls to
; external MOS routines should be prefixed by 'BL [Do/Only]External' and
; followed by 'BL Internal'

; OK, but what does this give us:
; i) entrance prohibited from IRQ mode
; ii) entrance prohibited whilst 'inside' FileCore, except in a controlled
;      fashion.
; iii) 0 or 1 level of re-entrance. That is, depending on which form or Entry
;      FileCore will permit itself to reentered not at all or one time only.
; iv) under no circumstances will FileCore permit itself to be entered more
;      than twice (one original call and one reentrance).
;
; Translating the above into algorithms:
; NoErr means return to the caller (of FileCore) without setting an error.
; FlagErr means return to the caller with a 'FileCore in use' error.
; Dormant means only permit entry at this point if FileCore is threaded 0 times.
; no Dormant means permit entry to FileCore if FileCore is threaded 0 or 1 times.
;
; Why the need to 'BL [Do/Only]External'? These inform the Entry checking system that
; FileCore is going outside under its own control. This is necessary to avoid FileCore
; in use again. OnlyExternal prohibits any further FileCore reentrance until Internal
; has been called. DoExternal does not explicitly perform the same prohibition (but
; FileCore may not be reentereable as it's exceeded its threading count).
;
; LightEntryFlagErr is used when re-entrancy isn't a problem if there's a:
;       Locked disc
;       Interlock set
;
; Internals of the reentrance system:
; It holds a count. The count must be even to allow reentrance. An odd count indicates
; that FileCore has been reentered out of control. If the count is 2 or more
; DormantEntry is prohibited (FileCore isn't dormant). If the count is 4 or more all
; forms of entry are prohibited. bit6 is set in the count to prohibit reentry via
; calls FileCore makes to the rest of the system (set by BL OnlyExternal).


; *******************  NOTE  *******************

; All the above is a complete load of rubbish because I got so hacked off
; with re-entrancy problems I enabled *vast* numbers of reentrancy levels,
; whatever the type of call.  (JRoach)





EntryNoErr ROUT
        MOV     R0, #2_01000001
        B       %FT10

EntryFlagErr
        MOV     R0, #2_11000001
        B       %FT10

DormantEntryNoErr
        MOV     R0, #2_01000001
        B       %FT10

DormantEntryFlagErr
        MOV     R0, #2_11000001
        B       %FT10

LightEntryFlagErr
        MOV     R0, #2_11000001
        getSB
        TEQ     R0, R0          ; To set EQ
        B       %FT20

10
        getSB

        ; IF haven't got a locked drive
        LDRB    R1, LockedDrive
        TEQS    R1, #&FF                ;no reentrance while a drive locked
 [ DebugR
        DREG    R1, "L="
 ]

        ; AND not interesting interlocks set (those other than noopenwinnie or noopenfloppy)
        LDREQB  R1, Interlocks
        TSTEQS  R1, #&FF :EOR: NoOpenFloppy :EOR: NoOpenWinnie
 [ DebugR
        DREG    R1, "I="
 ]

20
        ; AND aren't entered from IRQ mode
        LDREQ   R1, ptr_IRQsema
        LDREQ   R1, [R1]
 [ DebugR
        DREG    R1, "S="
 ]
        TEQS    R1, #0                  ;colludes with locked drive check to give NE if got a locked drive

        ; AND none of the reentrance bits we're interested in are set
        LDREQB  R1, ReEntrance
        ASSERT  NoReEnterBit = 1 :SHL: 6
 [ DebugR
        DREG    R1, "R="
 ]
        TSTEQS  R1, R0

        ; THEN increment ReEntrance and return, everything being hunky-dory
        ADDEQ   R1, R1, #1
        STREQB  R1, ReEntrance
        STREQB  R1, LastReEnter
        Pull    "R0,R1",EQ
        MOVEQ   PC,LR

        ;ELSE we're re-entering too much...

        ;Construct error if been requested to and return to caller
        CMPS    R0, R0, LSR #8    ;V=0
;C=0 => just return
;C=1 => flag error, V set R0->error block
        MOVCS   R0, #InUseErr
        BLCS    FindErrBlock            ;(R0->R0,V)
        STRVS   R0, [SP]
        Pull    "R0-R1,SB,PC"


; ============
; FileCoreExit
; ============

; for use in conjuction with the entry routines above

FileCoreExit ROUT
        Push    "R0,LR"
        SavePSR R0
        LDRB    LR, ReEntrance
        SUBS    LR, LR, #1
        STRPLB  LR, ReEntrance
 [ Dev
        BNE     %FT01
        LDR     LR, ptr_CannotReset
        LDRB    LR, [LR]
        TEQS    LR, #0
        DREG    LR, NE
        mess    NE, "CannotReset",NL
        MOVNE   PC, #0
01
 ]
        RestPSR R0,,f
        Pull    "R0,PC"


; ==========
; DoExternal
; ==========

;prefixes external call

DoExternal ROUT
        Push    "LR"
        TEQ     SB, #0
        LDRNEB  LR, ReEntrance
        ADDNE   LR, LR, #1
        STRNEB  LR, ReEntrance
        Pull    "PC"

; ============
; OnlyExternal
; ============

;as DoExternal but forbids re-entrance

OnlyExternal ROUT
        Push    "LR"
        TEQ     SB, #0
        LDRNEB  LR, ReEntrance
        ADDNE   LR, LR, #1
        ORRNE   LR, LR, #NoReEnterBit
        STRNEB  LR, ReEntrance
        Pull    "PC"

; ========
; Internal
; ========

; should follow any MOS call preceeded by 'BL [Do/Only]External'
; assumes V set flags error

Internal ROUT
        Push    "R1,LR"
        SavePSR R1
 [ :LNOT:NewErrors
        ORRVS   R0, R0, #ExternalErrorBit
 ]
        CMP     SB, #0
        BEQ     %FT95
        LDRB    LR, ReEntrance
        BIC     LR, LR, #NoReEnterBit
        SUBS    LR, LR ,#1
        STRPLB  LR, ReEntrance
95
        RestPSR R1,,f
        Pull    "R1,PC"


; ==================
; InternalFromParent
; ==================

InternalFromParent
        Push    "R1,LR"
        SavePSR R1
        LDRB    LR, ReEntrance
        BIC     LR, LR, #NoReEnterBit
        SUBS    LR, LR ,#1
        STRPLB  LR, ReEntrance
        RestPSR R1,,f
 [ NewErrors
        Pull    "R1,PC",VC
; Error occurred - let's convert (if necessary) from old scheme to new.
        LDR     LR, FS_Flags
        TSTS    LR, #CreateFlag_NewErrorSupport
        BNE     %FT95                           ; Child returns new style errors
        TSTS    R0, #DiscErrorBit
        BNE     %FT50
        TSTS    R0, #ExternalErrorBit
        BICNE   R0, R0, #ExternalErrorBit
        ANDEQ   R0, R0, #&FF
        B       %FT95
50
        Push    "R2-R4"
        TSTS    R0, #ExternalErrorBit
        BNE     %FT60                           ; get R2 = disc error<<8 + drive number
        AND     R2, R0, #MaxDiscErr:SHL:24      ;     R4 = byte address (low)
        MOV     R3, R0, LSR #21                 ;     LR = byte address (high)
        AND     R3, R3, #7
        ORR     R2, R3, R2, LSR #16
        MOV     R4, R0, LSL #8
        BIC     R4, R4, #DiscBits
        MOV     LR, #0
        B       %FT70
        ; indirect (sector) error version
60      BIC     R0, R0, #ExternalErrorBit+DiscErrorBit
        LDRB    R2, [R0, #0]
        LDR     R4, [R0, #4]
        MOV     R3, R4, LSR #(32-3)
        ORR     R2, R3, R2, LSL #8
        BIC     R4, R4, #DiscBits
        EOR     LR, R3, #4
        DrvRecPtr LR, LR
        LDRB    LR, [LR, #DrvsDisc]
        AND     LR, LR, #7
        DiscRecPtr LR, LR
        LDRB    R3, [LR, #DiscRecord_Log2SectorSize]
        RSB     R0, R3, #32
        MOV     LR, R4, LSR R0
        MOV     R4, R4, LSL R3
70
        ADR     R0, ConvDiscErr
        STMIA   R0, {R2, R4, LR}                ; Fabricated new style error
        ORR     R0, R0, #NewDiscErrorBit
        Pull    "R2-R4"
95
        RestPSR R1,,f
 ]
        Pull    "R1,PC"


; ===========
; Parent_Misc
; ===========
;
; Call MiscEntry of child filing system
;
; In
;  r0=op
;  r1=drive number (internal)
;  Other parameters to MiscEntry
; Out
;  r1 unchanged

Parent_Misc ROUT
        Push    "R11,LR"
 [ Debug1
        DREG    R0, "", cc
        DREG    R1, " ", cc
        DREG    R2, " ", cc
        DREG    R3, " ", cc
        DREG    R4, " ", cc
        DREG    R5, " ", cc
        DLINE   ">Parent_Misc"
 ]
        EOR     R1, R1, #4      ;convert to external drive numbering
        MOV     R11, SB
        BL      OnlyExternal
        LDR     SB, ParentPrivate
        MOV     LR, PC
        LDR     PC, [R11,#:INDEX:FS_Misc]
        MOV     SB, R11
        BL      InternalFromParent
        EOR     R1, R1, #4      ;convert to internal drive numbering
 [ Debug1
        DREG    R0, "", cc
        DREG    R1, " ", cc
        DREG    R2, " ", cc
        DREG    R3, " ", cc
        DREG    R4, " ", cc
        DREG    R5, " ", cc
        DLINE   "<Parent_Misc"
 ]
        Pull    "R11,PC"


; ============
; DoXOS_WriteS
; ============

; as WriteS but with re-entrance checking

DoXOS_WriteS   ROUT
        Push    "R0-R2,LR"
        RSB     R0, PC, PC              ; remove any PSR flags from LR
        SUB     R0, LR, R0
        MOV     R1, R0
05
        LDRB    R2, [R1],#1
        TEQS    R2, #0
        BNE     %BT05
        TSTS    R1, #3
        BICNE   R1, R1, #3
        ADDNE   R1, R1, #4
        STR     R1, [SP,#12]
        BL      DoExternal
        BL      DoXOS_Write0
        BL      Internal
        STRVS   R0, [SP]
        Pull    "R0-R2,PC"


DoSpace ROUT
        MOV     R0, #" "        ;(->R0,V)

DoXOS_WriteC            ;(R0->R0,V)
        Push    "LR"
        BL      DoExternal
        SWI     XOS_WriteC
InternalCommon
        BL      Internal
        Pull    "PC"


DoXOS_Write0 ROUT       ;(R0->R0,V)
        Push    "LR"
        BL      DoExternal
        SWI     XOS_Write0
        B       InternalCommon

DoXOS_WriteN ROUT
        Push    "LR"
        BL      DoExternal
        SWI     XOS_WriteN
        B       InternalCommon

DoXOS_NewLine ROUT      ;(->R0,V)
        Push    "LR"
        BL      DoExternal
        SWI     XOS_NewLine
        B       InternalCommon


DoXOS_CLI ROUT          ;(->R0,V)
        Push    "LR"
        BL      DoExternal
        SWI     XOS_CLI
        B       InternalCommon


DoXOS_ReadC ROUT
        Push    "LR"
        BL      DoExternal
        SWI     XOS_ReadC
        B       InternalCommon


OnlyXOS_Byte ROUT
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_Byte
        B       InternalCommon

DoXOS_Byte ROUT
        Push    "LR"
        BL      DoExternal
        SWI     XOS_Byte
        B       InternalCommon

DoXOS_ServiceCall ROUT
        Push    "LR"
        BL      DoExternal
        SWI     XOS_ServiceCall
        B       InternalCommon

DoXOS_Args ROUT
        Push    "LR"
        TEQ     SB, #0
        BLNE    DoExternal
        SWI     XOS_Args
InternalSBChkCommon
        TEQ     SB, #0
        BLNE    Internal
        Pull    "PC"

DoXOS_GBPB ROUT
        Push    "LR"
        TEQ     SB, #0
        BLNE    DoExternal
        SWI     XOS_GBPB
        B       InternalSBChkCommon

DoXMessageTrans_ErrorLookup ROUT
        Push    "LR"
        BL      DoExternal
        SWI     XMessageTrans_ErrorLookup
        B       InternalCommon

DoXMessageTrans_GSLookup ROUT
        Push    "LR"
        BL      DoExternal
        SWI     XMessageTrans_GSLookup
        B       InternalCommon

DoXMessageTrans_OpenFile ROUT
        Push    "LR"
        BL      DoExternal
        SWI     XMessageTrans_OpenFile
        B       InternalCommon

OnlyXOS_Claim ROUT      ;(R0,R1->R0,V)
        Push    "R2,LR"
        MOV     R2,SB
        BL      OnlyExternal
        SWI     XOS_Claim
InternalCommonR2
        BL      Internal
        Pull    "R2,PC"


OnlyXOS_Release ROUT    ;(R0,R1->R0,V)
        Push    "R2,LR"
        MOV     R2,SB
        BL      OnlyExternal
        SWI     XOS_Release
        B       InternalCommonR2

DoXOS_FSControl ROUT
        Push    "LR"
        BL      DoExternal
        SWI     XOS_FSControl
        B       InternalCommon

OnlyXOS_FSControl ROUT
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_FSControl
        B       InternalCommon


DoXOS_OsFind             ;(R0,R1->R0,V)
        Push    "LR"
        BL      DoExternal
        SWI     XOS_Find
        B       InternalCommon


OnlySysXOS_Heap                 ;(R0,R2,R3->R0-R3,V)
        Push    "R1,LR"
        BL      OnlyExternal
        LDR     R1,SysHeapStart
        SWI     XOS_Heap
        BL      Internal
        Pull    "R1,PC"


OnlyXOS_Module
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_Module
        B       InternalCommon


OnlyXOS_ClaimScreenMemory       ;(R0-R2->R1,R2,C)
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_ClaimScreenMemory   ;assume no errors
        B       InternalCommon


OnlyXOS_Word
        Push    "R10,LR"
        SavePSR R10
        BL      OnlyExternal
        SWI     XOS_Word
InternalCommonHat
        BL      Internal
        RestPSR R10,,f
        Pull    "R10,PC"


OnlyXOS_GetEnv
        Push    "R10,LR"
        SavePSR R10
        BL      OnlyExternal
        SWI     XOS_GetEnv
        MOVVS   R2,#AppSpaceStart
        B       InternalCommonHat


OnlyXOS_ConvertDateAndTime      ;(R0-R3->R0-R2)
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_ConvertDateAndTime
        B       InternalCommon


OnlyXOS_ConvertStandardDateAndTime      ;(R0-R2->R0-R2)
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_ConvertStandardDateAndTime
        B       InternalCommon


OnlyXOS_UpCall
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_UpCall
        B       InternalCommon


OnlyXOS_ReadVduVariables
        Push    "R10,LR"
        SavePSR R10
        BL      OnlyExternal
        SWI     XOS_ReadVduVariables
        B       InternalCommonHat


DoXOS_Confirm
        Push    "LR"
        BL      DoExternal
        SWI     XOS_Confirm
        B       InternalCommon


OnlyXOS_ConvertFixedFileSize
        Push    "R10,LR"
        SavePSR R10
        BL      OnlyExternal
        SWI     XOS_ConvertFixedFileSize
        B       InternalCommonHat


OnlyXOS_ReadUnsigned
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_ReadUnsigned
        B       InternalCommon


OnlyXOS_ConvertHex8
        Push    "R10,LR"
        SavePSR R10
        BL      OnlyExternal
        SWI     XOS_ConvertHex8
        B       InternalCommonHat

OnlyXOS_ConvertHex2
        Push    "R10,LR"
        SavePSR R10
        BL      OnlyExternal
        SWI     XOS_ConvertHex2
        B       InternalCommonHat

OnlyXOS_ConvertCardinal4
        Push    "R10,LR"
        SavePSR R10
        BL      OnlyExternal
        SWI     XOS_ConvertCardinal4
        B       InternalCommonHat

OnlyXWimp_ClaimFreeMemory
        Push    "LR"
        BL      OnlyExternal
        SWI     XWimp_ClaimFreeMemory
        B       InternalCommon

 [ BigDir
OnlyXOS_DynamicArea
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_DynamicArea
        B       InternalCommon

OnlyXOS_ChangeDynamicArea
        Push    "LR"
        BL      OnlyExternal
        SWI     XOS_ChangeDynamicArea
        B       InternalCommon
 ]

        LTORG
        END
@


4.17
log
@Refactor unaligned STM in old style error return
Don't rely on an STM with either of the bottom 2 bits set to store on a word aligned boundary any more.
Fixes abort when an old style error is reported to FileCore on ARMv7.
Spotted by Jon Abbott, ref https://www.riscosopen.org/forum/forums/4/topics/3682

Version 3.68. Tagged as 'FileCore-3_68'
@
text
@d494 1
a494 1
        LDR     R3, [R2, #Module_Title] ; command name
@


4.16
log
@Try harder when looking for buffer space
Detail:
  s/FileCore30 - Update FindBuffer so that if it failed to find enough spare memory for the buffer (and the RMA is allowed) it will try and grow the RMA dynamic area (current code just aims to use the spare heap space without expanding the DA).
Admin:
  Tested on Raspberry Pi
  Fixes "No room for buffer" error being generated in some situations, following the removal of Wimp_ClaimFreeMemory/free pool locking


Version 3.67. Tagged as 'FileCore-3_67'
@
text
@d1360 1
a1360 2
        BNE     %FT95
        Pull    "R1,PC",NE
d1396 3
a1398 3
        ASSERT  NewDiscErrorBit < bit2          ; STM ignores bits 0 and 1 :)
        ADR     R0, ConvDiscErr+NewDiscErrorBit
        STMIA   R0, {R2, R4, LR}
@


4.15
log
@Regroup some debug, comment corrections
Switch 'DebugM' now used exclusively for the read cached sectors disc op, and DebugMt for multifs extensions.
Various spelling mistakes corrected in passing.
Same (non debug) binary, retagged as FileCore-3_64.
@
text
@d349 47
@


4.14
log
@  Support the Raspberry Pi model B+
Detail:
  There's some questionable code in DoSwi[Sector]DiscOp[64] where it calls
  PollChange in an apparent attempt to support the ADFS floppy state machine.
  In the no-card-detect SDFS case, we can detect from a card's state whether
  it has been changed or not; to be able to signal this to software that
  cares about such things, we increment the sequence number late in the
  process. The downside is that when the card *has* changed, two consecutive
  PollChanged calls will differ from the steady state: the first because
  MaybeChanged is signalled, the second because the sequence number
  mismatches. DetermineDiscType didn't handle this gracefully, ending up
  pointing off the internal array of disc records, resulting in a string of
  gibberish when canonicalising a drive-based file spec. Fixed by having
  DetermineDiscType double-check that the drive is not empty.

  Fixed UpCall_MediaNotPresent and UpCall_MediaNotKnown to actually use the
  media type string from MiscOp 4. For example, you'll now see "Please insert
  card 'RISCOSpi'" being generated by the Wimp under SDFS.

  Improved documentation of MiscOps 4 and 5.

Admin:
  Already in use in RC12a.

Version 3.64. Tagged as 'FileCore-3_64'
@
text
@d619 1
a619 1
        ; internationalise it. RAMFS doesn't provide it (bit it specifies a
@


4.13
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@d617 31
a647 1
        ; Generate media type string
d653 2
a676 1
        ADR     r6, UpCall_MediaTypeBuffer
@


4.12
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d85 1
a85 1
        BL      ReadAllocSize   ;chunks must be multiple of larger alloc. size
d271 7
a277 4
        SUBS    R7, R7, #1
        TSTS    R6, R7
        BICNE   R6, R6, R7
        ADDNE   R6, R6, R3
d291 1
a291 1
        MOV     R1, #-1                 ;force claim fail in order to read free
@


4.11
log
@Swap out some more constants for symbolic names
* OsBytes
* Application start &8000
* Fixed disc density
* Unused a4 macro deleted
* Redundant 'todo', 'Help, 'Syntax' removed

Version 3.53. Not tagged
@
text
@d79 1
a79 8
        mess    ,NL
 ]
 [ BigDisc
 [ Debug
        DLINE   "********** MoveData **************"
 ]
;01
;       B       %BT01
d157 1
a157 1
        mess    ,NL
d229 1
a229 1
 [ Debug
d259 4
a262 5
        DREG    R0
        DREG    R1
        DREG    R2
        DREG    R3
        mess    ,NL
d379 1
a379 1
        mess    ,NL
d891 1
a891 1
        MOV     r0, r1, LSR #29         ; drive bits
d893 1
a893 1
        EOR     r0,r0,#4
d1303 1
a1303 1
        MOV     R3, R4, LSR #29
a1536 3
 [ Debug
        DebugError "XOS_Heap on system heap error:"
 ]
a1544 3
 [ Debug
        DebugError "XOS_Module error:"
 ]
@


4.10
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d339 1
a339 1
        SUBNE   R2, R1, #ApplicStart
d454 1
a454 1
        MOV     R1, #ApplicStart
d765 1
a765 1
        MOV     R0, #OsbyteAckEscape    ;If error was escape then acknowledge
d1585 1
a1585 1
        MOVVS   R2,#ApplicStart
@


4.9
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d32 1
a32 1
        ASSERT  ScatterBit=1 :SHL: 5
d49 1
a49 1
        MOV     R0, #(1:SHL:UseScratchSpace) :OR: (1:SHL:UseSpareScreen) :OR: (1:SHL:UseWimpFree) :OR: (1:SHL:UseRmaHeap) :OR: (1:SHL:UseSysHeap) :OR: (1:SHL:UseIndOp) :OR: ScatterBit
d83 1
a83 1
	DLINE	"********** MoveData **************"
d86 1
a86 1
;	B	%BT01
d116 1
a116 1
        MOV     R1, #ReadSecsOp :OR: ScatterBit :OR: NoEscape
d125 1
a125 1
        MOV     R1, #WriteSecsOp :OR: ScatterBit :OR: NoEscape
d133 2
a134 2
	MOVEQ	R3, R7		; for ReadSectorSize
	BLEQ	ReadSectorSize	; get sector size
d206 4
a209 4
	Push	"R3,R4,LR"
	MOV	R1, #0
	MOV	R2, #0
	MOV	R4, #0
d212 16
a227 16
	LDRB	R3,[R0],#1
	CMP     R3,#'a'
	SUBHS	R3, R3, #32

	CMP	R3,#'0'
	RSBHSS	LR,R3,#'F'
	BLT	%FT90		; not any sort of digit

	CMP	R3,#'9'
	SUBLE	R3, R3, #'0'
	BLE	%FT30		; a number

	SUBS	R3,R3,#'A'
	RSBHSS	LR,R3,#'F'-'A'
	ADD	R3,R3,#10
	BLT	%FT90		; not A-F
d230 4
a233 4
	MOV	R2, R2, LSL #4
	ADD	R2, R2, R1, LSR #28
	ADD	R1, R3, R1, LSL #4
	B	%BT10
d237 2
a238 2
	DREG	R1, "L.S. word"
	DREG	R2, "M.S. word"
d240 1
a240 1
	Pull	"R3,R4,PC"
d276 2
a277 2
        TSTS    LR, #NoBigBuf
        ANDNE   R4, R4, #ScatterBit :OR: (1 :SHL: UseScratchSpace)
d348 1
a348 1
        SUBNE	R2, R2, #(:INDEX:DirCache) :AND: 255
d350 1
a350 1
 	SUBNE	R2, R2, #:INDEX:DirBuffer
d354 1
a354 1
        TSTS    R4, #ScatterBit
d599 1
a599 1
        MOV     r0, #Misc_PollPeriod
d639 1
a639 1
        TST     lr, #(WinnieEjects :OR: FloppyEjects)
d642 1
a642 1
        MOV     r0, #Misc_Eject
d754 1
a754 1
	BNE	%FT50
d760 1
a760 1
	DLINE	"FindErrBlock: In error table bit"
d796 1
a796 1
	DLINE	"FindErrBlock: 40"
d846 1
a846 1
	B	%FT50
d849 1
a849 1
	DLINE	"FindErrBlock: 45"
d854 1
a854 1
	TSTS	R0,#DiscErrorBit
d856 1
a856 1
	BEQ	%FT50
d858 1
a858 1
	BIC	R0,R0,#NewDiscErrorBit
d860 1
a860 1
	BIC	R0,R0,#DiscErrorBit
d872 1
a872 1
	LDR	r0, [r0,#4]
d884 1
a884 1
	LDRVC	r0, [r0]
d890 1
a890 1
	BVS	%FT47
d898 2
a899 2
	LDR	r1, [r0, #4]
	MOV	r0, r1, LSR #29		; drive bits
d901 4
a904 4
	EOR	r0,r0,#4
	DrvRecPtr lr,r0
	LDRB	lr, [lr,#DrvsDisc]
	AND	lr, lr, #7
d908 4
a911 4
	LDRB	r4, [lr, #SectorSize]
	RSB	r6, r4, #32
	BIC	r5, r1, #DiscBits
	MOV	r0, r5, LSR r6
d917 1
a917 1
	BVS	%FT47
d922 1
a922 1
	MOV	r0, r5, LSL r4
d924 3
a926 3
	ADD	r1, sp, #16
	MOV	r2, #12
	BL	OnlyXOS_ConvertHex8
d1286 1
a1286 1
        TSTS    LR, #NewErrorSupport
d1319 1
a1319 1
        LDRB    R3, [LR, #SectorSize]
d1669 4
a1672 4
	Push	"LR"
	BL	OnlyExternal
	SWI	XOS_DynamicArea
	B	InternalCommon
d1675 4
a1678 4
	Push	"LR"
	BL	OnlyExternal
	SWI	XOS_ChangeDynamicArea
	B	InternalCommon
@


4.8
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d74 5
a78 5
        wrhex   R0
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
d159 5
a163 5
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
        wrhex   R0,VS
d266 4
a269 4
        wrhex   R0
        wrhex   R1
        wrhex   R2
        wrhex   R3
d384 3
a386 3
        wrhex   R0
        wrhex   R1
        wrhex   R2
d396 2
a397 2
        wrhex   R10
        wrhex   R11
d475 2
a476 2
        wrhex   R1
        wrhex   R2
d529 2
a530 2
        wrhex   R1
        wrhex   R2
d727 2
a728 2
        wrhex   R7
        wrhex   R8
a959 30

 [ F
; =========
; HexString
; =========

; form hex string in RAM

; entry:
;  R0 the number
;  R1 # nibbles
;  R2 ->dest

HexString ROUT
        Push    "R1-R2,LR"
        SUB     R1, R1, #1
        MOV     R1, R1, LSL #2
10
        MOV     LR, R0, LSR R1
        AND     LR, LR, #&F
        CMPS    LR, #10
        ADDLO   LR, LR, #"0"
        ADDHS   LR, LR, #"A"-10
        STRB    LR, [R2],#1
        SUBS    R1, R1, #4
        BPL     %BT10
        Pull    "R1-R2,PC"
 ]


d991 1
a991 1
 [ F
d1208 1
a1208 1
        wrhex   LR, NE
@


4.7
log
@Update to work with zero page relocation
Detail:
  s/FileCore, s/FileCore00, s/InitDieSvc - Try using OS_ReadSysInfo 6 to get IRQsema & CannotReset locations before falling back on legacy values. Store results in module workspace.
  s/FileCore05 - Commented out unused CheckEscape routine to avoid having to update it
  s/FileCore15 - Debugging code updated to use OS_ReadSysInfo 6 to fetch IRQsema ptr. Can't always rely on workspace version since workspace might not be set up yet.
  s/FileCore25, s/FileCore30, s/FileCore80 - Use IRQsema & CannotReset pointers from workspace
Admin:
  Tested on rev A2 BB-xM


Version 3.39. Tagged as 'FileCore-3_39'
@
text
@d713 1
a713 1
        MOV     R0,#OswordReadClock
d723 1
a723 1
        LDR     LR,=DataType
a1185 1
 [ MOS_Version > 120
a1192 1
 ]
@


4.6
log
@* Various 32-bit compatibility fixes.
* Can use HAL for FIQ+timer manipulations.
* FileCore_DiscOp64 added (as user API - currently just converted to the
  standard byte or sector DiscOp call to the underlying module). See
  Doc.32bitAPIs for full details.
* New error-passing scheme to modules added (for full 32-bit addressing).
* FileCore_Features added (indicates new error scheme).
* OS_FSControl 49 (read 32-bit free space) now reports sensible clamped
  values for large discs, rather than values modulo 2^32.
* Accessing the end of files near 2GB in size could cause lock-ups in
  background transfers.
* F(+) and G(+) disc formats adjusted to have a little more skew to
  help the rather poor Iyonix floppy controller.

Version 3.31. Tagged as 'FileCore-3_31'
@
text
@d1188 1
a1188 1
        MOVEQ   R1, #IRQsema
d1237 2
a1238 2
        MOV     LR, #0
        LDRB    LR, [LR, #CannotReset]
@


4.5
log
@  32-bit fixes
Detail:
  Some stack offsets were wrong - now fixed.
  More PSR preservation added.
Admin:
  26-bit builds of this module still stiff the machine when ADFS is
    used.
  Do not use - except for testing.

Version 3.24. Tagged as 'FileCore-3_24'
@
text
@d744 5
d758 1
d792 1
d843 1
d851 3
d855 1
d857 3
d861 1
d869 3
d874 1
a874 1
        AND     r0, r0, #7
d881 3
d885 1
d890 1
a891 1
	BVS	%FT46
d894 4
d912 2
d917 1
d919 3
a921 1
	BVS	%FT46
d923 1
d927 1
a928 1
46
d931 9
a939 7
        LDRVC   r1, [r0]
        BICVC   r1, r1, #&ff00
        LDRVCB  lr, FS_Id
        ORRVC   r1, r1, lr, ASL #8
        BICVC   r1, r1, #&ff000000
        LDRVC   lr, [sp, #40]
;        ANDVC   lr, lr, #MaxDiscErr :SHL: 24
d941 8
a948 5
        ORRVC   r1, r1, lr, LSL #24
        ADDVC   r4, sp, #4
        MOVVC   r5, sp
        ADDVC   r6, sp, #8
        BLVC    copy_error3             ; VS always out of this
d951 1
a951 1
        ADD     sp, sp, #44
d1288 1
d1290 1
d1307 2
a1308 2
        Push    "R0,LR"
        SavePSR R0
d1313 51
a1363 2
        RestPSR R0,,f
        Pull    "R0,PC"
d1575 1
a1575 1
        LDR     R1,=SysHeapStart
@


4.4
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d1330 2
a1331 3
        SUB     R0, LR, PC              ; remove any PSR flags from LR
        ADD     R0, PC, R0
        SUB     R0, R0, #4
@


4.3
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@a39 1
 [ FileCache
a40 1
 ]
d177 2
a178 1
        Push    "R0-R2,LR"
d183 2
a184 1
        Pull    "R0-R2,PC",,^
d240 1
a240 1
	Pull	"R3,R4,PC",,^
a343 1
 [ FileCache
a345 3
 |
        LDRNE   R2, MapSpace
 ]
d357 3
a359 2
        BLNE    %FT45
        TEQNES  R8,#ScatterMax
d361 1
a361 1
        CMPS    R9, R5
a458 1
 [ FileCache
a459 1
 ]
d484 1
a484 1
        Pull    "PC",,^
d505 1
a505 1
        MOVS    PC, LR
d515 2
a516 1
        Push    "R0-R4,LR"
a553 1
 [ FileCache
a555 1
 ]
d560 2
a561 1
        Pull    "R0-R4,PC",,^
d685 1
a685 1
        Pull    "R0,PC",,^
d695 2
a696 1
        Push    "R0,LR"
d701 2
a702 1
        Pull    "R0,PC",,^
d725 1
a725 1
        ADD     SP,SP,#8
d731 1
a731 1
        Pull    "R0,R1,PC",,^
d742 2
a743 1
        Push    "R1,R2,LR"
d879 1
a879 1
        
d918 3
a920 3
        Pull    "R1,R2,LR"
        ORR     LR, LR, #V_bit
        MOVS    PC, LR
d923 1
d948 2
a949 1
        Pull    "R1-R2,PC",,^
a1139 1
 [ FileCache
a1145 1
 ]
d1171 1
a1171 1
        MOVEQS  PC,LR
d1192 2
a1193 1
        Push    "LR"
d1198 1
a1198 1
        Pull    "PC",NE,^
d1205 1
d1207 2
a1208 1
        Pull    "PC",,^
d1223 1
a1223 1
        Pull    "PC",,^
d1238 1
a1238 1
        Pull    "PC",,^
d1248 2
a1249 1
        Push    "LR"
d1252 1
a1252 1
        Pull    "PC",EQ,^
d1257 3
a1259 1
        Pull    "PC",,^
d1267 2
a1268 1
        Push    "LR"
d1273 2
a1274 1
        Pull    "PC",,^
d1330 3
a1332 1
        BIC     R0, LR, #ARM_CC_Mask
d1341 1
a1341 3
        AND     LR, LR, #ARM_CC_Mask
        ORR     LR, R1, LR
        STR     LR, [SP,#12]
d1514 2
a1515 1
        Push    "LR"
d1520 2
a1521 1
        Pull    "PC",,^
d1525 2
a1526 1
        Push    "LR"
d1555 2
a1556 1
        Push    "LR"
d1570 2
a1571 1
        Push    "LR"
d1585 2
a1586 1
        Push    "LR"
d1592 2
a1593 1
        Push    "LR"
d1599 2
a1600 1
        Push    "LR"
@


4.2
log
@Version Spin_merge taken
@
text
@d350 6
a355 1
        SUBNE   R2, R2, #:INDEX:DirBuffer
d467 3
d471 1
d1286 1
a1286 1
 [ Debug;1
d1304 1
a1304 1
 [ Debug;1
d1596 14
@


4.2.2.1
log
@Changes made to FileCore to support allowing idlen more than 15.  This allows
smaller LFAUs on discs.  The changes are not yet complete.  In particular, the
number of disc zones is limited to 255.  Some development testing has been
peformed, and the filing system is generally stable.  Areas which haven't
been fully tested include things like *Defect, FileCore_LayoutStructure,
FileCore_FloppyStructure, and the FileSwitch APIs for reading and examining
a disc's used space.

This version should not be used for any OS Builds with the BigMaps flag set
to true.  It should build as a normal version of FileCore with BigMaps and
BigDirs set to false.
@
text
@d1277 1
a1277 1
 [ Debug1
d1295 1
a1295 1
 [ Debug1
@


4.2.2.2
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@d350 1
a350 6
 [ BigDir
        SUBNE   R2, R2, #(:INDEX:DirCache) :AND: :NOT: 255
        SUBNE	R2, R2, #(:INDEX:DirCache) :AND: 255
 |
 	SUBNE	R2, R2, #:INDEX:DirBuffer
 ]
a461 3
 [ BigDir
        sbaddr  R1, DirCache,EQ
 |
a462 1
 ]
a1586 14

 [ BigDir
OnlyXOS_DynamicArea
	Push	"LR"
	BL	OnlyExternal
	SWI	XOS_DynamicArea
	B	InternalCommon

OnlyXOS_ChangeDynamicArea
	Push	"LR"
	BL	OnlyExternal
	SWI	XOS_ChangeDynamicArea
	B	InternalCommon
 ]
@


4.1
log
@Initial revision
@
text
@d896 4
a899 3
        LDRVC   lr, [sp, #20]
        ANDVC   lr, lr, #MaxDiscErr :SHL: 24
        ORRVC   r1, r1, lr
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d896 3
a898 4
        LDRVC   lr, [sp, #40]
;        ANDVC   lr, lr, #MaxDiscErr :SHL: 24
        LDRB    lr, [lr, #0]
        ORRVC   r1, r1, lr, LSL #24
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d896 3
a898 4
        LDRVC   lr, [sp, #40]
;        ANDVC   lr, lr, #MaxDiscErr :SHL: 24
        LDRB    lr, [lr, #0]
        ORRVC   r1, r1, lr, LSL #24
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d896 3
a898 4
        LDRVC   lr, [sp, #40]
;        ANDVC   lr, lr, #MaxDiscErr :SHL: 24
        LDRB    lr, [lr, #0]
        ORRVC   r1, r1, lr, LSL #24
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

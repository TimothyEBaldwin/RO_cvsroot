head	4.14;
access;
symbols
	FileCore-3_75:4.14
	FileCore-3_74:4.14
	FileCore-3_73:4.14
	FileCore-3_72:4.14
	FileCore-3_71:4.14
	FileCore-3_70:4.14
	FileCore-3_69:4.14
	FileCore-3_68:4.14
	FileCore-3_67:4.14
	FileCore-3_66:4.14
	FileCore-3_65:4.14
	FileCore-3_64:4.14
	FileCore-3_63:4.14
	FileCore-3_62:4.14
	FileCore-3_61:4.14
	FileCore-3_60:4.14
	FileCore-3_59:4.14
	FileCore-3_58:4.14
	FileCore-3_57:4.14
	FileCore-3_56:4.14
	FileCore-3_55:4.14
	FileCore-3_54:4.13
	FileCore-3_53:4.13
	FileCore-3_52:4.12
	FileCore-3_51:4.12
	FileCore-3_50:4.12
	FileCore-3_49:4.11
	FileCore-3_48:4.11
	FileCore-3_47:4.11
	FileCore-3_46:4.11
	FileCore-3_45:4.11
	FileCore-3_44:4.10
	FileCore-3_43:4.10
	FileCore-3_42:4.9
	FileCore-3_41:4.8
	FileCore-3_40:4.8
	FileCore-3_39:4.8
	FileCore-3_38:4.8
	FileCore-3_37:4.8
	FileCore-3_36:4.8
	FileCore-3_35:4.8
	FileCore-3_34:4.8
	FileCore-3_33:4.8
	RO_5_07:4.7
	FileCore-3_32:4.7
	FileCore-3_31:4.7
	FileCore-3_30:4.7
	FileCore-3_29:4.7
	FileCore-3_28:4.6
	FileCore-3_25-4_9_2_2:4.6
	FileCore-3_27:4.6
	FileCore-3_26:4.6
	FileCore-3_22-4_6_2_1:4.4
	bavison_FileCore-3_22_dev_bp:4.4
	bavison_FileCore-3_22:4.4.0.2
	FileCore-3_25-4_9_2_1:4.6
	HAL:4.6.0.2
	FileCore-3_25:4.6
	FileCore-3_24:4.5
	FileCore-3_23:4.5
	dellis_autobuild_BaseSW:4.4
	FileCore-3_22:4.4
	Ursula_merge:4.1.4.8
	ROL_merge:4.1.4.7.4.1
	FileCore-3_21:4.3
	ROL_Ursula_merge:4.1.4.7.4.1
	Ursula_RiscPC_merge:4.1.4.7
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.7
	ROL_FileCore-3_21:4.1.4.7.4.1
	ROL_FileCore-3_20:4.1.4.7.4.1
	ROL:4.1.4.7.0.4
	ROL_bp:4.1.4.7
	Ursula_RiscPC_bp:4.1.4.7
	FileCore-3_18:4.1.4.7
	FileCore-3_01:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.7
	Ursula_RiscPC:4.1.4.7.0.2
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.1.4.7
	sproven_FileCore-3_16:4.1.4.7
	rthornb_UrsulaBuild-19Aug1998:4.1.4.7
	UrsulaBuild_FinalSoftload:4.1.4.7
	rthornb_UrsulaBuild-12Aug1998:4.1.4.7
	aglover_UrsulaBuild-05Aug1998:4.1.4.7
	rthornb_UrsulaBuild-29Jul1998:4.1.4.7
	rthornb_UrsulaBuild-22Jul1998:4.1.4.7
	rthornb_UrsulaBuild-15Jul1998:4.1.4.7
	rthornb_UrsulaBuild-07Jul1998:4.1.4.7
	rthornb_UrsulaBuild-17Jun1998:4.1.4.7
	rthornb_UrsulaBuild-03Jun1998:4.1.4.7
	rthornb_UrsulaBuild-27May1998:4.1.4.7
	rthornb_UrsulaBuild-21May1998:4.1.4.7
	sproven_FileCore-3_15:4.1.4.7
	sproven_314:4.1.4.7
	rthornb_UrsulaBuild_01May1998:4.1.4.7
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.7
	sproven_3_11:4.1.4.6
	sproven_3_10:4.1.4.5
	sproven_Ursula_3_09:4.1.4.4
	sproven_3_07:4.1.4.3
	sproven_3_06:4.1.4.3
	sproven_3_05:4.1.4.2
	sproven_3_04:4.1.4.2
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.2
	sproven_3_02:4.1.4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.14
date	2013.02.21.16.53.08;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	CCuV2tngKttj75Fw;

4.13
date	2012.10.21.16.45.31;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	FoJ3R0fb1IiW1hpw;

4.12
date	2012.04.14.00.43.17;	author bavison;	state Exp;
branches;
next	4.11;
commitid	xkSKw5i9HVYqOL0w;

4.11
date	2011.10.14.07.23.51;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	D2Id4aPp4zmuUhDv;

4.10
date	2011.10.02.20.28.12;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	uhh7MIROZ5lBDOBv;

4.9
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	A9Zxco9ydo9FCOBv;

4.8
date	2009.05.17.01.48.31;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2001.05.14.14.27.08;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2000.10.31.17.05.06;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.10.09.53.21;	author sforrest;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.11.36.57;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.09.21.12.07.20;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.26.03;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.11.17.13.32.33;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.12.01.12.03.06;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.01.19.12.26.38;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.02.11.16.49.23;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.02.17.14.59.43;	author sproven;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.03.18.11.09.29;	author sproven;	state Exp;
branches;
next	4.1.4.7;

4.1.4.7
date	98.04.16.15.26.34;	author sproven;	state Exp;
branches
	4.1.4.7.4.1;
next	4.1.4.8;

4.1.4.8
date	2000.05.09.10.55.19;	author sbrodie;	state Exp;
branches;
next	;

4.1.4.7.4.1
date	99.08.24.12.41.19;	author sbrodie;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.10;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.03;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >FileCore40

        TTL     "Filename and Directory operations"

; Name restriction bits

NotBit7Chars    bit 0   ;unlike others this does not generate error but sets C
                 ;MUST BE LSB
MustBeFile      bit 1   ;name must refer to file
MustBeDir       bit 2   ;name must refer to dir
NotNulName      bit 3
NotLastWild     bit 4   ;last term of name must not have wild cards
NotLastUp       bit 5   ;last term of name must not be ^
DirItself       bit 6   ;get the dir itself rather than the parent
DirToBuffer     bit 7   ;dir must be in buffer not cache
MustBeDisc      bit 8   ;name must be disc spec
LibRelBitNo * 9
LibRel          bit LibRelBitNo  ;default library relative rather CSD relative
NotDrvNum       bit 10  ;any reference to disc must be by name

MustBeRefDisc   * &10000000     ;name must be on ref disc (eg ensuring rename destination on same disc as rename source)

; special filename components

RootChar        * "$"
UserRootChar    * "&"
LibChar         * "%"
CsdChar         * "@@"
BackChar        * "\\"

UpChar          * "^"

DiscSpecChar    * ":"
DelimChar       * "."

OneWildChar     * "#"
MultiWildChar   * "*"

SpecialChars
;chars that cannot appear in filename and are not wild cards
;the delimiter does not appear in this list but is tested separately

; special dir chars
 =       RootChar
 =       UserRootChar
 =       LibChar
 =       CsdChar
 =       BackChar

 =       UpChar

NDirChars       = {PC}-SpecialChars

; other special chars
 =       DiscSpecChar

 =       """"
 =       "|"
; =       ","   taken out for 1.06


NBadChars       = {PC}-SpecialChars

UserRootText             ;nul names (if allowed) will be replaced by this
 = UserRootChar,0
        ALIGN


; =========
; CheckPath
; =========

; Check pathname is valid

; entry: R1 = ptr to string
;        R2 = name restriction bits

; exit:
; If error V set, R0 result
; ELSE C=1 if bit 7 set chars used

CheckPath
 [ Debug6 :LOR: DebugXd ;:LOR: DebugXr
        DSTRING R1, "checkpath( ",cc
        DREG    R2, ",",cc
        DLINE   ")"
 ]

        Push    "R0,R1,R3-R7,LR"
        baddr   R3, SpecialChars
        MOV     R4, SP          ;save SP for aborts
        MOV     R5, #MustBeFile ;will set bits on possible restrictions
10
        BL      SkipSpaces
        BCC     %FT20           ;not null name
        TSTS    R2, #NotNulName ;are we allowing nul names
        BNE     BadPath
        baddr   R1, UserRootText ;if so replace null by user root
        STR     R1, [SP,#4]
        B       %BT10
20
        TEQS    R0, #DiscSpecChar
        BEQ     %FT25
;if we are only looking for a disc spec allow disc spec char to be missing
        ASSERT  MustBeDisc=&100
        TSTS    R2, #MustBeDisc  ;C=0
        BEQ     %FT35
; Z=0, C=0
25
        BLEQ    NextChar
        BCS     BadPath         ;nul disc spec => bad name

        BL      ParseDrive
        BEQ     %FT70           ;Reject bad drive chars
        BHI     %FT30           ;Not drive number
        TSTS    R2, #NotDrvNum
        MOVNE   R0, #BadNameErr
        BNE     %FT70

30
        BL      ThisChar
        BL      CheckName
;if returns to here have parsed ':<disc spec>.'
        TSTS    R2, #MustBeDisc
        BNE     BadPath
;pass optional '$.'
        TEQS    R0, #RootChar   ;N=0
        BNE     %FT60
        BEQ     %FT50

35                              ;look for special dir chars
        MOV     R6, #(NDirChars-SpecialChars)-1
40
        LDRB    LR, [R3,R6]
        TEQS    R0, LR
        BEQ     %FT50           ;Valid dir char, N=0
        SUBS    R6, R6, #1
        BPL     %BT40
; if we fall through here we have not found leading disc spec or dir char, N=1

50
        ORRPL   R5, R5, #MustBeFile
        BLPL    CheckDelim
60
; remaining terms must be wildcarded name or UpChar
; starting new term so forget about last term
        BIC     R5, R5, #MustBeFile :OR: NotLastWild :OR: NotLastUp

        TEQS    R0, #UpChar                             ;is it UpChar
        ORREQ   R5, R5, #MustBeFile :OR: NotLastUp      ;if so refers to dir
        JumpAddress LR, %B60
        BEQ     CheckDelim
        BNE     CheckName       ;this will not return if term is terminated
        ; will return to 60

BadPath
        MOV     R0, #BadNameErr
        B       %FT70
PathChecked
;calculate return code
        ANDS    R6, R2, R5      ;mask to relevant restrictions
        MOV     R0, #0
        TSTS    R6, #NotLastWild
        MOVNE   R0, #WildCardsErr
        TSTS    R6, #NotLastUp
        MOVNE   R0, #BadUpErr
        TSTS    R6, #MustBeFile
        MOVNE   R0, #TypesErr
70
        ASSERT  NotBit7Chars=1
        MOVS    R5, R5, LSR #1  ;C=1 <=> bit 7 set chars used
        MOV     SP, R4
        BL      SetVOnR0
        STRVS   R0, [SP]
 [ Debug6
        DLINE   "string  |restrict|result - leaving checkpath"
        DREG    R1, " ",cc
        DREG    R2, " ",cc
        DREG    R0, " "
        BCC     %FT01
        DLINE   "bit 7 set chars used"
01
 ]
        Pull    "R0,R1,R3-R7,PC"


; =========
; CheckName     ONLY FOR USE WITHIN CHECKPATH
; =========

; Checks for a well formed name of legal chars & wild cards in pathname
; if bad aborts CheckPath with bad name error
; if good and terminated CheckPath done
; if good and delimited returns

; entry: R0=first char, R1 -> first char

; exit:  R1 -> first char after delimiter, R0=that char

CheckName ROUT
        Push    "LR"
        TEQS    R0, #DelimChar
        TEQNES  R0, #" "
        BEQ     BadPath         ;dont allow nul names

        TEQS    R0, #"-"        ;check for -&<disc add.> special case
        LDREQB  LR, [R1, #1]
        TEQEQS  LR, #"&"
        BEQ     %FT80

 [ :LNOT: FixTruncateOnBigDiscs
        LDRB    R6, Flags
        TST     R6, #TruncateNames
        MOVNE   R6, #NameLen    ;max length (barf)
        MOVEQ   R6, #&7fffffff  ;not a limit really (who cares!)
 ]
10
        MOV     R7, #(NBadChars-SpecialChars)-1
20                              ;check against table of illegal chars
        LDRB    LR, [R3,R7]
        TEQS    R0, LR
        BEQ     BadPath
        SUBS    R7, R7, #1
        BPL     %BT20
        TEQS    R0, #OneWildChar
        TEQNES  R0, #MultiWildChar
        ORREQ   R5, R5, #NotLastWild    ;note if wild card was used

        ASSERT  NotBit7Chars=1
        ORR     R5, R5, R0, LSR #7      ;note if bit 7 set char used

 [ :LNOT: FixTruncateOnBigDiscs
        CMPS    R0, #MultiWildChar
        SUBNES  R6, R6, #1
        BMI     BadPath         ;term too long
 ]
        BL      NextChar
        BCS     PathChecked
        TEQS    R0, #DelimChar
        BNE     %BT10
        B       CheckDelimCommon

80
        MOV     R0, #bit29
        ADD     R1, R1, #1
        Push    "R2"
        SUB     R2, R0, #1
        BL      OnlyXOS_ReadUnsigned
        Pull    "R2"
        BVS     BadPath
        ORR     R5, R5, #MustBeFile
        BL      ThisChar
        B       CheckDelim2


; ----------
; CheckDelim    ONLY FOR USE WITHIN CHECKPATH
; ----------

; have just read last char of term
;  IF   next char is terminator then CheckPath done
;  ELSE must find delimiter followed by valid char

CheckDelim ROUT
        Push    "LR"
        BL      NextChar
CheckDelim2
        BCS     PathChecked
        CMPS    R0, #DelimChar
        BNE     BadPath         ;if char after dir char it must be delimiter
CheckDelimCommon
        BL      NextChar
        BCS     BadPath         ;can't end with delimiter
        Pull    "PC"

; ==========
; SkipSpaces
; ==========

; entry: R1 -> string
; exit:  R1 -> first non space char, R0=that char
;        C=1 <=> terminator

SkipSpaces ROUT
        LDRB    R0, [R1], #1
        TEQS    R0, #" "
        BEQ     SkipSpaces
        SUB     R1, R1, #1
;FALL THROUGH TO THIS CHAR


; ========
; ThisChar
; ========

; entry: R1 -> current char
; exit:  R1 -> current char, R0=that char
;        C=1 <=> terminator

ThisChar
        SUB     R1, R1, #1
;FALL THROUGH TO NEXTCHAR


; ========
; NextChar
; ========

; entry: R1 -> current char
; exit:  R1 -> next char, R0=that char
;        C=1 <=> terminator

NextChar
        LDRB    R0, [R1,#1] !
        Push    "LR"
        CMPS    R0, #DeleteChar
        RSBNES  LR, R0, #" "
        Pull    "PC"

      [ RO3Paths ; these used to live inside code we've switched out
RootLibText     =       RootChar,".Library",0
CsdText         =       CsdChar,0
      ]

; ==========
; FullLookUp
; ==========

; Parse a path name

; entry:
;  R1 -> string
;  R2 name restriction bits

; exit:
; IF error V set, R0 result
;  R1    -> terminating char of last term IF success
;        -> terminating char of problem term IF not found
;  R2    preserved
;  R3    disc address of directory contained in (or dir itself if requested)
;  R4    -> entry in dir or next alphabetically if not found
;  R5    -> dir start
;  R6    -> first byte after dir
; IF no error (R0=0) C=1 <=> dir

; if the object is a root dir R3=(disc address of dir itself) and R4=0


FullLookUp ROUT
 [ Debug6
        DLINE   "string   restrict - entering FullLookUp"
        DREG    R1, "  ",cc
        DREG    R2, "  "
 ]

        Push    "R0,R7,R8,LR"
        BL      CheckPath
        SavePSR R6
        AND     R6, R6, #C_bit  ; R6<>0 <=> bit 7 set chars used
        BVS     %FT95

      [ :LNOT: RO3Paths
        LDR     R3, CurDir      ;Current directory is default
      ]
        MOV     R4, #0
        BL      SkipSpaces

        TEQS    R0, #DiscSpecChar
      [ :LNOT: RO3Paths
        BEQ     %FT03
        TSTS    R2, #MustBeDisc
        BEQ     %FT05           ;if path doesn't start with disc spec
03
      ]
        ; :<disc> or MustBeDisc

        ; advance to start of disc name
        BLEQ    NextChar

        ; Find it
        BL      FindDiscByName
        BVS     %FT95           ;error in parsing disc

        ; Skip past [.[$]]
        BL      Bit7Disc        ;if bit 7 set chars used must be new format
        BL      ThisChar
        BLCC    NextChar        ; skip delimiter
        TEQS    R0, #RootChar
        BLEQ    NextChar        ; skip $
      [ :LNOT: RO3Paths  ; since RO3, FileSwitch canonicalises everything so we only need the start-with-disc case above
        B       %FT25

05                               ;handle special dir chars
        TEQS    R0, #RootChar
        BNE     %FT15

        ; Path starts $
10
        CMPS    R3, #-1         ;if dir set get root of that disc
        MOVNE   R3, R3, LSR #(32-3)
        DiscRecPtr  R3,R3,NE
        LDRNE   R3, [R3,#DiscRecord_Root]
        B       %FT24

15
        TEQS    R0, #UserRootChar
        BNE     %FT20

        ; Path starts &

        ; use & or use $ of @@'s disc if & not set
        LDR     R3, UserRootDir
        CMPS    R3, #-1         ;if & unset use $
        LDREQ   R3, CurDir
        BEQ     %BT10
        B       %FT24

UrdLibText      =       UserRootChar,".Library",0
RootLibText     =       RootChar,".Library",0
CsdText         =       CsdChar,0
        ALIGN

20
        ; if @@ use current dir (which is already in R3)
        TEQS    R0, #CsdChar
        BEQ     %FT24          ;R3 already CSD

        ; If \ use BackDir, defaulting to $ of default drive
        TEQS    R0, #BackChar
        LDREQ   R3, BackDir
        BEQ     %FT24

; library must be last of special dir chars to be tested

        CMPS    R0, #LibChar
        ADDEQ   R1, R1, #1        ;skip Lib Char
        MOVNES  LR, R2, LSR #LibRelBitNo+1
        BCC     %FT25           ; Branch if not % and default isn't relative to library

        MOV     R7, R1           ;save string ptr
        LDR     R3, LibDir
        CMPS    R3, #-1
        BNE     %FT23           ; Branch if library set

; if lib unset, use first of   &.Library, $.Library or @@   that exist as a
; temporary library
        baddr   R1, UrdLibText
        BL      %FT22
        baddr   R1, RootLibText
        BL      %FT22
        baddr   R1, CsdText
        BL      %FT22
; KJB 000524 - routine 22 used to preserve flags if it returned.
; This means V would be clear here from the equal CMP above.
        CLRV
        B       %FT95           ;if all 3 failed
22
        Push    "R2,R4,R6,LR"
        MOV     R2, #DirItself :OR: MustBeDir
        BL      FullLookUp
        Pull    "R2,R4,R6,LR"
        BVC     %FT23
        TEQS    R0, #NotFoundErr
        MOVEQ   PC, LR          ;if cant find try next
        B        %FT95
23
        SUB     R1, R7, #1        ;restore string ptr and adjust for NextChar
24
        BL      NextChar
25
        CMPS    R3, #-1
        BNE     %FT30
;if dir unset use root on default drive

        Push    "R1-R2"
        LDRB    R1, Drive
        BL      WhatDisc        ;get info on disc in this drive
; R2=disc num
; R3=disc rec ptr
        LDR     R3, [R3,#DiscRecord_Root]
        Pull    "R1-R2"
        BVS     %FT95           ;error
30
      ] ;  endif  :LNOT: RO3Paths
        ; We now have:
        ; r3 = root dir of path (may be $, &, %, \, @@ or $ of default drive)
        BL      Bit7Disc        ;if bit 7 set chars used must be new format

        ; Check that MustBeRefDisc is satisfied if necessary
        TSTS    R2, #MustBeRefDisc      ;IF insisting on ref disc
        EORNE   LR, R2, R3
        TSTNES  LR, #DiscBits           ;AND it isnt
        MOVNE   R0, #NotRefDiscErr      ;THEN error
        BNE     %FT90

        BL      ThisChar
        BCS     %FT60           ;path done C=1 for dir

        ; Skip the . separator if there
        TEQS    R0, #DelimChar
        BLEQ    NextChar

        ; Generate NotFoundErr if trying to enter non-FileCore disc
        BL      DiscAddToRec            ;(R3->LR)
        LDRB    LR, [LR, #DiscFlags]
        TST     LR, #DiscNotFileCore
        MOVNE   R0, #NotFoundErr
        BNE     %FT77

; just wildcard or ^ terms
35
        BL      FindDir ;(R3->R0,R5,R6)
        BVS     %FT95  ;error in getting dir
      [ RO3Paths
        B       %FT45
      |
        BL      ThisChar
        TEQS    R0, #UpChar
        BNE     %FT45
        MOV     R4, #0
        BL      ToParent
; R3=disc address of parent
        BL      NextChar
      ]
40
        BL      ThisChar
        BCS     %FT60  ;last term C=1 for dir
        BL      NextChar        ;read first char of next term
        B       %BT35           ;loop for next term

42
        Push    "R0,R2"
        MOV     R0, #0
        ADD     R1, R1, #1
        BL      OnlyXOS_ReadUnsigned    ;can't give error as already checked
        AND     R3, R3, #DiscBits
        ORR     R3, R3, R2
        Pull    "R0,R2"
        MOV     R4, #0
        B       %BT40

45
        TEQS    R0, #"-"
        LDREQB  LR, [R1, #1]
        TEQEQS  LR, #"&"
        BEQ     %BT42

 [ BigDir
        BL      GetDirFirstEntry
 |
        ADD     R4, R5, #DirFirstEntry
 ]
        MOV     R7, R1          ;save term ptr

;if this is not last term it must be dir
        BL      SkipTerm
        Push    "R0,R1,R2"
        TEQS    R0, #DelimChar
        MOVEQ   R2, #MustBeDir  ;If not last term only accept dirs     *A*
 [ BigDir
        BL      TestBigDir
        BNE     %FT01


        ADDS    R1, R7, #0
        BL      LookUpBigDir
        B       %FT02
01
 [ FixTruncateOnBigDiscs
        BL      %FT99           ; check the name length
 ]
        ADDS    R1, R7, #0
        BL      LookUp
02
 |
        ADDS    R1, R7, #0      ;restore term start ptr and C=0
        BL      LookUp
 ]
        Pull    "R0,R1,R2"

        MOVCS   R0, #NotFoundErr
        BCS     %FT77
        BEQ     %FT60           ;found a file

        TEQS    R0, #DelimChar
        BLEQ    ReadIndDiscAdd  ;(R3,R4->LR) enter if a dir and not last term
        MOVEQ   R3, LR
        BEQ     %BT40
        CMPS    R0, #0          ;set C=1 for dir

60     ;path parsed C=1 <=> dir

        ; Cancel C (dir) flag if DiscNotFileCore
        BLCS    DiscAddToRec    ;(R3->LR)
        LDRCSB  LR, [LR, #DiscFlags]
        TSTCS   LR, #DiscNotFileCore
        MOVHIS  LR, LR, ASL #1  ; Clear carry if CS and NE

        MOV     R8, R8, RRX     ;save C flag
        ASSERT  DirItself<&100  ;not to corrupt C

        TSTS    R2, #DirItself
        BNE     %FT65           ;want dir itself

; want parent dir
        TEQS    R4, #0
        BNE     %FT75           ;have already got parent
        BL      DiscAddToRec    ;(R3->LR)
        LDR     LR, [LR,#DiscRecord_Root]
        TEQS    R3, LR
        MOVEQ   r0, #0
        BEQ     %FT80           ;dont try to get parent of root

        BL      FindDir         ;get dir itself (R3->R0,R5,R6,V)
        BVS     %FT95
        MOV     R7, R3
        BL      ToParent        ;now get parent
        BL      FindDir         ;(R3->R0,R5,R6,V)
        BVS     %FT95
        ADD     R4, R5, #DirFirstEntry
63
 [ BigDir
        BL      TestBigDir              ;(R3->Z)
        BNE     %FT02
        BL      BigDirFinished          ;(R4,R5->Z)
        BEQ     %FT75
        BL      ReadIndDiscAdd
        TEQS    LR, R7                  ; check if OK
        BEQ     %FT75                   ; match
        ADD     R4, R4, #BigDirEntrySize

        B       %BT63
02
        LDRB    LR, [R4]
        CMPS    LR, #" "
        BLCS    ReadIndDiscAdd          ;(R3,R4->LR)
        TEQS    LR, R7                  ;preserves C
        ASSERT  NewDirEntrySz=OldDirEntrySz
        ADDHI   R4, R4, #NewDirEntrySz  ;HI <=> ~Z AND C
        BHI     %BT63                   ;if mismatch loop if more entries
        B       %FT75
 |
        LDRB    LR, [R4]
        CMPS    LR, #" "
        BLCS    ReadIndDiscAdd          ;(R3,R4->LR)
        TEQS    LR, R7                  ;preserves C
        ASSERT  NewDirEntrySz=OldDirEntrySz
        ADDHI   R4, R4, #NewDirEntrySz  ;HI <=> ~Z AND C
        BHI     %BT63                   ;if mismatch loop if more entries
        B       %FT75
 ]

65
; want the dir itself
        TEQS    R4, #0
        BLNE    ReadIndDiscAdd  ;(R3,R4->LR)
        MOVNE   R3, LR
        BL      FindDir         ;(R3->R0,R5,R6,V)
        BVS     %FT95
75
        MOV     R0, #0
77                              ;not found joins here
        TSTS    R2, #DirToBuffer
        BEQ     %FT80
        TEQS    R4, #0
        SUBNE   R4, R4, R5
        BL      GetDir          ;(R3->R0,R5,R6)
        ADDNE   R4, R4, R5
        BVS     %FT95
80
        CMPS    R8, #bit31      ;RRX'd into top bit earlier, so C=1 <=> dir
90
        BL      SetVOnR0
95
        STRVS   R0, [SP]
 [ Debug6
        DREG    R1, " ", cc
        DREG    R2, " ", cc
        DREG    R3, " ", cc
        DREG    R4, " ", cc
        DREG    R5, " ", cc
        DREG    R6, " ", cc
        DLINE   "leave FullLookUp "
        BVC     %FT01
        DREG    R0, " "
01
  [ DebugC
  BL    SanityCheckDirCache
  ]
 ]

        Pull    "R0,R7,R8,PC"

 [ FixTruncateOnBigDiscs
99      ; check name length
        ; r7 = ptr to name
        ; if name is invalid then set r0 to error ptr,
        ; Pull r0-r2 and jump to 95
        Push    "r0,r7,lr"

        LDRB    R0, Flags
        TST     R0, #TruncateNames
        Pull    "r0,r7,pc",EQ

        MOV     lr,r7
00      LDRB    r0,[r7],#1
        TEQ     r0,#127
        TEQNE   r0,#'.'
        BEQ     %FT01
        CMP     r0,#' '
        BGT     %BT00
01      SUB     r0,r7,lr
        CMP     r0,#NameLen+1
        Pull    "r0,r7,pc",LE

        Pull    "r0,r7,lr"
        Pull    "r0,r1,r2"
        MOV     r0,#BadNameErr
        BL      SetVOnR0
        B       %BT95
 ]

Bit7Disc                                ;Only new format discs can have bit 7
        MOV     R0, LR                  ;set chars in pathname
        BL      TestDir
        TSTNES  R6, #C_bit
        MOVEQ   PC, R0
        MOV     R0, #BadNameErr
        B        %BT90

; ========
; ToParent
; ========

; Looks up disc address of parent

; entry: R3=disc address of dir,  R6 -> byte after dir
; exit:  R3=disc address of parent

 [ BigDir
; if it's a big dir, then r5->dir
 ]

ToParent ROUT
 [ Debug6
        DREG    R3, " ", cc
        DLINE   " dir / parent dir "
 ]
        Push    "R0,LR"

 [ BigDir
        BL      TestBigDir
        ANDEQ   LR, R3, #DiscBits
        LDREQ   R3, [R5,#BigDirParent]
        BICEQ   R3, R3, #DiscBits
        ORREQ   R3, R3, LR
        BEQ     %FT90
 ]

        BL      TestDir      ;(R3->LR,Z)
        AND     R3, R3, #DiscBits ;remember disc num bits
        ADDEQ   R0, R6, #NewDirParent
        ADDNE   R0, R6, #OldDirParent
        BL      TestMap         ;(R3->LR)
        Read3                   ;load disc address of parent non aligned
        ORREQ   R3, R3, LR
        ORRNE   R3, R3, LR, LSL #8
90
 [ Debug6
        DREG    R3, " "
 ]
        Pull    "R0,PC"


; ==============
; FindDiscByName
; ==============

; Parse a disc name, the name must already have been checked by CheckPath

; entry:
;  R1->name
;  R2 lookup options, only MustBeRefDisc relevant (top 3 bits RefDisc if applicable)

; exit:
; IF error V set, R0 result
;  R0 result code
;  R1 incremented beyond successful parsing
;  R2 preserved
;  R3 disc address of root directory

FindDiscByName
 [ Debug6f
        DSTRING R1,">FindDiscByName(",cc
        DREG    R2,",",cc
        DLINE   ")"
 ]
        Push    "R0,R2,R4-R7,LR"
; [ DebugC
; BL     SanityCheckDirCache
; ]

        ; Check for drive number
        BL      ParseDrive
        BEQ     %FT95   ; single drive char, but not a valid drive number
        BVS     %FT05   ; not a single drive char

; It's a drive number

        ADD     R1, R1, #1      ;skip drive char
 [ Debug6f
        DREG    R0,,cc
        DLINE   "= drive | string = ",cc
        DSTRING R1
 ]

        TSTS    R2, #MustBeRefDisc
        BEQ     %FT03

; It's a drive number and must be the same as the RefDisc - separate
; from other cases to avoid unnecessary disc examinations

        MOV     R3, R2, LSR #(32-3)     ;ref disc
        DiscRecPtr  R4,R3
        LDRB    R4, [R4,#DiscsDrv]      ;IF
        RSBS    LR, R4, #7              ;    ( ref disc thought to be in drive
        Push    "R0",CS
        MOVCS   R0, R4
        BLCS    PollChange      ;(R0->LR)
        Pull    "R0",CS
        RSBCSS  LR, LR, #7              ;    AND this is certain
        TEQS    R0, R4                  ;    AND it isnt this drive )
        BHI     %FT02
                                ;  OR
        BL      PollChange      ;(R0->LR)
        MOV     R4, LR
        RSBS    LR, R4, #&7F            ;    ( drive contents certain
        TEQS    R3, R4                  ;    AND isnt ref disc )
02
        MOVHI   R0, #NotRefDiscErr      ;THEN error
        BHI     %FT95

03
; It's a drive number and may be any drive (MustBeRefDisc is clear)

 [ Debug6f
        DLINE   "It's a drive number, going to WhatDisc the drive"
 ]

        ; WhatDisc the specified drive
        Push    "R1"
        MOV     R1, R0
        BL      WhatDisc                ;(R1->R0-R3,V)
        LDRVC   R3, [R3,#DiscRecord_Root]
        Pull    "R1"
        STRVS   R0, [SP]
; [ DebugC
; BL     SanityCheckDirCache
; ]
        Pull    "R0,R2,R4-R7,PC"

05
; It's not a drive number, is it name of known disc?

        ; Try the preferred disc first
        LDRB    lr, PreferredDisc
        TEQ     lr, #&ff
        BEQ     %FT07                   ; no preferred disc

        DiscRecPtr r6,lr
        MOV     r3, lr, ASL #(32-3)

        LDRB    lr, [r6, #Priority]
        TEQ     lr, #0
        BEQ     %FT07                   ; disc unused now

        ADD     r4, r6, #DiscRecord_DiscName
        BL      TestDir
        MOVEQ   r5, #&ff
        MOVNE   r5, #&7f
        BL      LexEqv
        LDREQ   r6, [r6, #DiscRecord_Root]
        BEQ     %FT17

07
        MOV     R3, #0
        sbaddr  R4, DiscRecs+DiscRecord_DiscName

        ; These bits are used to indicate which sort of root directory
        ; has been found:
        ; bit28 clear: a directory has been found
        MOV     r6, #bit28
10
        LDRB    LR, [R4,#Priority - DiscRecord_DiscName]
        TEQS    LR, #0
        BEQ     %FT15           ;unused disc rec
        BL      TestDir         ;(R3->LR,Z)
        MOVEQ   R5, #&FF        ;set up bit 7 chars mask
        MOVNE   R5, #&7F
 [ Debug6f
        DSTRING r1, "LexEqv(",cc
        DSTRING r4, ",",cc
        DREG    r5, ",",cc
        DLINE   ")"
 ]
        BL      LexEqv          ;(R1,R4,R5->LO/EQ/HI)
        BNE     %FT15           ;mismatch
 [ Debug6f
        DLINE   "Matched!"
 ]

        ; Test for disc already found
        TST     R6, #bit28
        MOVEQ   R0, #AmbigDiscErr       ; more than one disc matched
        BEQ     %FT95

        LDR     r6, [r4, #DiscRecord_Root - DiscRecord_DiscName]

15
 [ Debug6f
        DREG    r6, "Match flags:"
 ]
        ADD     R4, R4, #SzDiscRec
        ADDS    R3, R3, #1 :SHL: (32-3) ;inc disc num bits
        BCC     %BT10                   ;loop for next disc rec

        TST     R6, #bit28
        BNE     %FT20                   ; no discs matched

17
;matched exactly one disc name
        BL      SkipTerm
        MOV     R3, R6
        BL      ClearV
 [ Debug6f
        DREG    R3,"root dir="
 ]
; [ DebugC
; BL     SanityCheckDirCache
; ]
        Pull    "R0,R2,R4-R7,PC"

20
; Disc name not found amoungst known discs
        ; If only allowing files on ref disc, and name didn't match
        ; any disc (in particular the ref disc) then error
        TSTS    R2, #MustBeRefDisc
        MOVNE   R0, #NotRefDiscErr
        BNE     %FT95
; [ DebugC
; BL     SanityCheckDirCache
; ]

23
        MOV     R4, #0  ;init upcall ctr
24
;identify drives whose contents are uncertain
; R7 = drive being considered (from 0 to Floppies+4-1 inclusive)
        MOV     R7, #0
        B       %FT35
25
        ; Test for drive valid
        MOVS    LR, R7, LSR #3  ;C=0 <=> winnie num
        LDRCCB  R0, Winnies
        SBCCCS  LR, R0, R7      ;C=1 <=> valid drv num
        BCC     %FT30

 [ Debug6f
        DREG    R7, "Checking disc "
 ]

        ; Check for disc change
        MOV     R0, R7
        BL      PollChange      ;(R0->LR)

 [ Debug6f
        DLINE   "Poll change returned"
 ]

        ; Test for certainty of drive contents
        TSTS    LR, #Uncertain
        BEQ     %FT30

        ; Drive contents uncertain - find out what's in it
        Push    "R1"
        MOV     R1, R7
        BL      WhatDisc
 [ Debug6f
        DLINE   "WhatDisc returned"
 ]
        Pull    "R1"            ;If successfully examined disc
        BVS     %FT30

        ; Disc identified - check disc name
        Push    "R4"
        ADD     R4, R3, #DiscRecord_DiscName
        LDR     R3, [R3,#DiscRecord_Root]
        BL      TestDir
        MOVEQ   R5, #&FF        ;set up bit 7 chars mask
        MOVNE   R5, #&7F
 [ Debug6f
        DSTRING r1, "LexEqv(",cc
        DSTRING r4, ",",cc
        DREG    r5, ",",cc
        DLINE   ")"
 ]
        BL      LexEqv          ;(R1,R4,R5->LO/EQ/HI)
        Pull    "R4"
 [ Debug6f
        DLINE   "LexEqv returned"
 ]
        BNE     %FT30
        BL      SkipTerm        ;move R1 past term if match
        MOV     R2, #0          ;success code
        B       %FT40           ;if matched then dont need to look any further

30
 [ Debug6f
        DLINE   "Disc mismatch...move to next disc"
 ]
        ; Disc mismatch, error or contents certain - move to next disc
        ADD     R7, R7, #1

35
        ; Stop when reached end of disc list
        LDRB    LR, Floppies    ;drive ctr
        ADD     LR, LR, #4
        CMPS    R7, LR
        BLO     %BT25

 [ Debug6f
        DLINE   "Run out of discs...UpCall_MediaNotKnown"
 ]
        ; Run out of discs to check - ask user for disc
        MOV     R0, #UpCall_MediaNotKnown
        BL      UpCall          ;(R0,R1,R4->R2-R4,C)
 [ Debug6f
        DLINE   "MediaNotKnown returned"
 ]
        BCS     %BT24           ;try again if upcall claimed

        ; User rejected it - give error
        MOV     R2, #DiscNotFoundErr

40
 [ Debug6f
        DLINE   "Answer known....MediaSearchEnd"
 ]
        ; Answer known - finish MediaSearch if necessary
        TEQS    R4, #0
        MOVNE   R0, #UpCall_MediaSearchEnd
        BLNE    OnlyXOS_UpCall
        MOV     R0, R2

 [ Debug6f
        DREG    R3,"<FindDiscByName(",cc
        DLINE   ")"
        DebugError "    FindDiscByName error"
 ]

95                              ;error exit
        BL      SetVOnR0
        STRVS   R0, [SP]
 ;[ DebugC
 ;BL     SanityCheckDirCache
 ;]
        Pull    "R0,R2,R4-R7,PC"

; ========
; SkipTerm
; ========

; entry: R1->term start

; exit:  R0 terminator or delimiter, R1 incremented past term

SkipTerm  ROUT
        Push    "R2,LR"
        SavePSR r2
10
        BL      NextChar
        TEQS    R0,#DelimChar
        BEQ     %FT20
        BCC     %BT10
20
        RestPSR r2,,f
        Pull    "R2,PC"

; =========
; TermStart
; =========

; entry:
;  R0->string start
;  R1->char after term

; exit:  R1->first char of term, must preserve C,V

TermStart ROUT
        Push    "R2,LR"
        SavePSR R2
10
        CMPS    R1, R0
        LDRHIB  LR, [R1,#-1]
        TEQHIS  LR, #DelimChar
        SUBHI   R1, R1, #1
        BHI     %BT10
        RestPSR r2,,f
        Pull    "R2,PC"


; =============
; ParseAnyDrive
; =============

; as ParseDrive but
;  a) doesn't check if drive is allowed by configure
;  b) doesn't map 0-3 to 4-7 if no winnies configured

ParseAnyDrive ROUT
        Push    "R1,R2,R3,LR"
        MOV     R3,#0
        B       ParseDriveCommon

; ==========
; ParseDrive
; ==========

; Entry: R1-> string
; Exit:  R0 drive number if success else BadDriveErr
;    LO  C=0, Z=0, V=0 => 1 char string and good drive
;    EQ  C=1, Z=1, V=1 => 1 char string but invalid
;    HI  C=1, Z=0, V=1 => not 1 char string

; Good drive numbers are:
; 0-7
; A-H
; a-h

ParseDrive ROUT
        Push    "R1,R2,R3,LR"
 [ Debug6
        DREG    R1, " ", cc
        DLINE   ">ParseDrive"
 ]
        MOV     R3, #1
ParseDriveCommon
        BL      ThisChar
        BCS     %FT10           ;reject nul string
        MOV     R2, R0          ;save drive char
        BL      NextChar        ;check terminated
        TEQS    R0, #DelimChar
        MOVEQS  R0, #2, 2       ;Delim => C=1  ie treat as terminator
        BCS     %FT20           ;is terminated
10
        CMPS    SP, #0           ;not drive string set HI
        B        %FT40

20
        CMPS    R2, #"a"
        SUBHS   R2, R2, #"a"-"A"        ; 'a'-'h' -> 'A'-'H'
        CMPS    R2, #"A"
        SUBHS   R2, R2, #"A"-"0"        ; 'A'-'H' -> '0'-'7'
        SUBS    R2, R2, #"0"            ; '0'-'7' ->  0 - 7
        RSBCSS  LR, R2, #7
        BLO     %FT30                   ; not drive char

        EOR     R2, R2, #4              ; convert to internal numbering

        ; Skip check if don't want it
        CMPS    R3, #1
        BLO     %FT40           ;V=0

        ; Check drive number versus known drives
        TSTS    R2, #4
        LDREQB  R0, Winnies
        LDRNEB  R0, Floppies
        ADDNE   R0, R0, #4
        CMPS    R2, R0
        BLO     %FT40           ;drive is present LO, V=0
30
        CMPS    R0, R0          ;bad drive char set EQ

40
        MOVLO   R0, R2
        MOVHS   R0, #BadDriveErr
        BLHS    SetV
 [ Debug6
        DREG    R0, " ", cc
        DLINE   "<ParseDrive"
 ]
        Pull    "R1,R2,R3,PC"


; ======
; LookUp
; ======

; look up wild card spec term in dir

; entry:
;  R1   -> term, terminated by control codes ,delete ,space or delimiter
;  R2   name restriction bits, only 'must be file' and 'must be dir' apply
;  R3   disc address of dir
;  R4   entry in dir to start at (or following entry if C=1)

; exit:
; IF found R4->entry in dir, Z=1 <=> file, C=0
; ELSE     R4->next alphabetical entry, C=1

LookUp  ROUT
 [ Debug6
        DREG    r1,"LookUp(wild=",cc
        DREG    r2,",restrict=",cc
        DREG    r3,",dir=",cc
        DREG    r4,",at ",cc
        DLINE   ")",cc
 ]

        Push    "R5-R7,LR"
        BL      TestDir           ;preserves C
        MOVEQ   R5, #&FF
        MOVNE   R5, #&7F                ;old format dirs cant have bit 7 set chars
 [ NewDirEntrySz=OldDirEntrySz
        SUBCC   R4, R4, #NewDirEntrySz  ;caller asked to start at this entry
 |
        MOVEQ   R6, #NewDirEntrySz
        MOVNE   R6, #OldDirEntrySz
        SUBCC   R4, R4, R6              ;caller asked to start at this entry
 ]

        MOV     r7, #0

 [ NewDirEntrySz=OldDirEntrySz
10
        ADD     R4, R4, #NewDirEntrySz
 |
10
        ADD     R4, R4, R6
 ]
        LDRB    LR, [R4]
        CMP     LR, #" "+1              ;LO (CC) <=> no more names in dir, 0 mark found
        BLO     %FT12

        BL      LexEqv                  ;(R1,R4,R5->LO/EQ/HI)
        BCC     %BT10                   ;if mismatch and name < wild try next
        BEQ     %FT15                   ;EQ=>match

12
        ;mismatch and name > wild done
        TEQ     r7, #0                  ; doesn't affect C
        MOVEQ   r7, r4
        BCS     %BT10

        ; Completion in the not found case
        MOV     r4, r7
        SEC                             ; Set carry (not found)
        B       %FT90

15
        ; Match, but...
        BL      ReadIntAtts
;LR = Atts
        TSTS    LR, #DirBit
        BNE     %FT20                ;found a dir
;found a file
        TSTS    R2, #MustBeDir
        BNE     %BT10
;fall through next few instructions as EQ
20
        TSTNES  R2, #MustBeFile
        BNE     %BT10

        TSTS    LR, #DirBit :SHL: 2,2 ;restore Z=1 <=> file, C=0
90
 [ Debug6
        DREG    r4,"->(loc=",cc
        BCC     %FT01
        DLINE   ",not found)"
        B       %FT02
01
        DLINE   ",found)"
02
 ]
        Pull    "R5-R7,PC"

 [ BigDir
; =========
; BigLexEqv
; =========

; compare wild card spec term with name (usually in dir)

; entry:
;  R1 -> term, terminated by control codes ,delete ,space or delimiter
;  R4 -> name

;  R5 =  bit mask for name chars
;  R6 =  length of name

; exit:
;  name < wild spec   C=0, Z=0, V=0
;  name = wild spec   C=1, Z=1, V=0
;  name > wild spec   C=1, Z=0, V=0

BigLexEqv
 [ DebugX
        DLINE   "wild     name     mask - enter BigLexEqv"
        DREG    R1,,cc
        DREG    R4," ",cc
        DREG    R5," "
 ]

        Push    "R0,R1,R4,R6-R11,LR"

        ; NULL name is equivalent to "" (for root object on a disc)
        TEQ     R4, #0
        baddr   R4, anull, EQ

        ADD     R6, R4, R6              ;Max Name end ptr

        MOV     R7, #0                  ;wild backtrack ptr, R8 will be name backtrack
        MOV     R10,#0                  ;clear # used flag

        SUB     R1, R1, #1
10
        BL      NextChar
        MOVCS   R0, #0           ;replace terminators by 0, for name<wild check
        TEQS    R0, #DelimChar
        MOVEQ   R0, #0          ; delimiters must be replaced by 0 too
        CMPS    R0, #MultiWildChar
        BEQ     %FT30
        BL      %FT50           ;R9=next name char
        Internat_CaseConvertLoad LR,Upper
        Internat_UpperCase  R0,LR
        CMPS    R0, #OneWildChar ;match ?
        MOVEQ   R10,#-1         ;note if # used
        CMPNES  R0, R9          ;match ?
        BEQ     %BT10           ;loop on match
        MOV     R4, R8          ;back track name
        MOVS    R1, R7          ;back track wild, and test if * used
        BNE     %FT30           ;if it was restart from backtrack
20
; not match, but was name < wild

; if wild cards force name < wild to continue dir search

        RSBS    LR, R7, #1      ; * used => C=0
        RSBCSS  LR, R10,#1      ; # used => C=0
        CMPCSS  R9, R0
 [ DebugX
        BHI     %FT01
        DLINE   "name<wild"
01
        BLO     %FT01
        DLINE   "name>wild"
01
 ]
        Pull    "R0,R1,R4,R6-R11,PC"

30
        MOV     R7, R1          ;Wild backtrack ptr -> wild card
        BL      NextChar        ;Next wild
        MOVCS   R0, #0          ;replace terminators by 0, for wild<name check
        TEQS    R0, #DelimChar
        MOVEQ   R0, #0          ;delimiters must be replaced by 0 too
        CMPS    R0, #MultiWildChar
        BEQ     %BT30           ;deal with **
        Internat_CaseConvertLoad LR,Upper
        Internat_UpperCase  R0,LR
40
        BL      %FT50           ;R9=next name char
        CMPS    R0, #OneWildChar ;match ?
        MOVEQ   R10,#-1         ;note if # used
        CMPNES  R0, R9          ;match ?
        BNE     %BT40
        MOV     R8, R4          ;name backtrack ptr -> char after match
        B       %BT10           ;loop

50
;get name char
        LDRB    R9, [R4],#1
        AND     R9, R9, R5      ;maybe mask out bit 7
        Internat_CaseConvertLoad R11,Upper
        Internat_UpperCase  R9,R11
        TEQS    R9, #DelimChar
        MOVEQ   R9, #0
        CMPS    R9, #" "+1      ;name terminated by control code ?
        MOVLO   R9, #0          ;replace terminators by 0, for wild<name check
        CMPHS   R6, R4          ;name terminated by length ?
        MOVHS   PC, LR          ;name not terminated
        MOVLO   R9, #0          ;terminator of 0 if name terminated

;name terminated, has wildcard ?
        CMPS    R0, #DelimChar
        CMPNE   R0, #0
        BLNE    ThisChar
        BCS     %FT60           ;match

        LDR     lr, [sp, #2*4]
        SUB     lr, r4, lr
        CMP     lr, #BigDirMaxNameLen
        BLO     %BT20           ;mismatch if not reached max name length

        ; Check if Truncate is configured
        LDRB    lr, Flags
        TST     lr, #TruncateNames
        BNE     %BT20           ;mismatch if barf on truncate names

        ; Now check if wildcard has terminated based on length
        LDR     lr, [sp, #1*4]  ; R1 in
        SUB     lr, r1, lr
        CMP     lr, #BigDirMaxNameLen
        BLO     %BT20           ; finished short of BigDirMaxNameLen

        ; Drop through to match situation
60
        CMPS    R0, R0          ;set equal C=1,Z=1
 [ DebugX
        DLINE   "name=wild"
 ]
        Pull    "R0,R1,R4,R6-R11,PC"

 ]

; ======
; LexEqv
; ======

; compare wild card spec term with name (usually in dir)

; entry:
;  R1 -> term, terminated by control codes ,delete ,space or delimiter
;  R4 -> name

;  R5 =  bit mask for name chars

; exit:
;  name < wild spec   C=0, Z=0, V=0
;  name = wild spec   C=1, Z=1, V=0
;  name > wild spec   C=1, Z=0, V=0

LexEqv
 [ Debug6  :LAND: {FALSE}
        mess    ,"wild     name     mask - enter LexEqv",NL
        DREG    R1
        DREG    R4
        DREG    R5
 ]

        Push    "R0,R1,R4,R6-R11,LR"

        ; NULL name is equivalent to "" (for root object on a disc)
        TEQ     R4, #0
        baddr   R4, anull, EQ

        ADD     R6, R4, #NameLen        ;Max Name end ptr

        MOV     R7, #0                  ;wild backtrack ptr, R8 will be name backtrack
        MOV     R10,#0                  ;clear # used flag

        SUB     R1, R1, #1
10
        BL      NextChar
        MOVCS   R0, #0           ;replace terminators by 0, for name<wild check
        CMPS    R0, #MultiWildChar
        BEQ     %FT30
        BL      %FT50           ;R9=next name char
        Internat_CaseConvertLoad LR,Upper
        Internat_UpperCase  R0,LR
        CMPS    R0, #OneWildChar ;match ?
        MOVEQ   R10,#-1         ;note if # used
        CMPNES  R0, R9          ;match ?
        BEQ     %BT10           ;loop on match
        MOV     R4, R8          ;back track name
        MOVS    R1, R7          ;back track wild, and test if * used
        BNE     %FT30           ;if it was restart from backtrack
20
; not match, but was name < wild

; if wild cards force name < wild to continue dir search

        RSBS    LR, R7, #1      ; * used => C=0
        RSBCSS  LR, R10,#1      ; # used => C=0
        CMPCSS  R9, R0
 [ Debug6 :LAND: {FALSE}
        mess    LO,"name<wild",NL
        mess    HI,"name>wild",NL
 ]
        Pull    "R0,R1,R4,R6-R11,PC"

30
        MOV     R7, R1          ;Wild backtrack ptr -> wild card
        BL      NextChar        ;Next wild
        MOVCS   R0, #0          ;replace terminators by 0, for wild<name check
        CMPS    R0, #MultiWildChar
        BEQ     %BT30           ;deal with **
        Internat_CaseConvertLoad LR,Upper
        Internat_UpperCase  R0,LR
40
        BL      %FT50           ;R9=next name char
        CMPS    R0, #OneWildChar ;match ?
        MOVEQ   R10,#-1         ;note if # used
        CMPNES  R0, R9          ;match ?
        BNE     %BT40
        MOV     R8, R4          ;name backtrack ptr -> char after match
        B       %BT10           ;loop

50
;get name char
        LDRB    R9, [R4],#1
        AND     R9, R9, R5      ;maybe mask out bit 7
        Internat_CaseConvertLoad R11,Upper
        Internat_UpperCase  R9,R11
        CMPS    R9, #" "+1      ;name terminated by control code ?
        MOVLO   R9, #0          ;replace terminators by 0, for wild<name check
        CMPHS   R6, R4          ;name terminated by length ?
        MOVHS   PC, LR          ;name not terminated
;name terminated, has wildcard ?
        CMPS    R0, #DelimChar
        BLNE    ThisChar
        BCS     %FT60           ;match

        ; Check if Truncate is configured
        LDRB    lr, Flags
        TST     lr, #TruncateNames
        BNE     %BT20           ;mismatch if barf on truncate names

        ; Now check if wildcard has terminated based on length
        LDR     lr, [sp, #1*4]  ; R1 in
        SUB     lr, r1, lr
        CMP     lr, #NameLen
        BLO     %BT20           ; finished short of NameLen

        ; Drop through to match situation
60
        CMPS    R0, R0          ;set equal C=1,Z=1
 [ Debug6 :LAND: {FALSE}
        mess    ,"name=wild",NL
 ]
        Pull    "R0,R1,R4,R6-R11,PC"


; ========
; ReadLoad
; ========

; read load address from directory entry

; entry: R3    dir disc address
;        R4 -> entry

; exit:  LR = load address

ReadLoad ROUT
        Push    "R0,LR"
 [ BigDir
        BL      TestBigDir
        BEQ     %FT10
 ]
        TEQS    R4, #0
        ; For root object set load for type of disc
        ; Use EOR in case types extend in the future
        BLEQ    DiscAddToRec            ;(R3->LR)
        LDREQ   LR, [LR, #DiscRecord_DiscType]
        MOV     LR, LR, LSL #8
        EOREQ   LR, LR, #&ff000000
        EOREQ   LR, LR, #&00f00000
        ADDNE   R0, R4, #DirLoad
        ReadWord NE
 [ Debug6
        DREG    LR, " ", cc
        DLINE   "= load add"
 ]
        Pull    "R0,PC"

 [ BigDir
10
        TEQS    R4, #0
        ; For root object set load for type of disc
        ; Use EOR in case types extend in the future
        BLEQ    DiscAddToRec            ;(R3->LR)
        LDREQ   LR, [LR, #DiscRecord_DiscType]
        MOV     LR, LR, LSL #8
        EOREQ   LR, LR, #&ff000000
        EOREQ   LR, LR, #&00f00000
        LDRNE   LR, [R4, #BigDirLoad]
 [ Debug6
        DREG    LR, " ", cc
        DLINE   "= load add"
 ]
        Pull    "R0,PC"
 ]

; ========
; ReadExec
; ========

; read exec address from directory entry

; entry: R4 ->entry

; exit:  LR = exec address, C and V preserved.

ReadExec ROUT
        Push    "R0,LR"
 [ BigDir
        BL      TestBigDir
        BEQ     %FT10
 ]
        TEQS    R4, #0
        MOVEQ   LR, #0
        ADDNE   R0, R4, #DirExec
        ReadWord NE
 [ Debug6
        DREG    LR, " ", cc
        DLINE   "= exec add"
 ]
        Pull    "R0,PC"

 [ BigDir
10
        TEQS    R4, #0
        MOVEQ   LR, #0
        LDRNE   LR, [R4, #BigDirExec]
  [ Debug6
        DREG    LR, " ", cc
        DLINE   "= exec add"
  ]
        Pull    "R0,PC"
 ]

; =======
; ReadLen
; =======

; read length from directory entry

; entry: R3    dir disc address
;        R4 -> entry

; exit:  LR = length

ReadLen
        Push    "R0,LR"
        ; For most cases read length from dir
  [ BigDir
        ; check if is big dirs
        BL      TestBigDir
        BNE     %FT05
        ; big dirs

        TEQS    R4, #0
        LDREQ   LR, [LR, #DiscRecord_BigDir_RootDirSize]
        LDRNE   LR, [R4, #BigDirLen]
   [ Debug6
        BEQ     %FT01
        DREG    LR, " ", cc
        DLINE   "= file len, from big dir"
01
   ]
        Pull    "R0,PC",NE

        ; big dir, but root object.  read root length from disc record
        BL      DiscAddToRec    ;(R3->LR)

        LDRB    R0, [LR, #DiscFlags]
        TST     R0, #DiscNotFileCore

        ; Contents of non-filecore disc
        LDRNE   LR, [LR, #DiscRecord_DiscSize]
  [ Debug6
        BEQ     %FT01
        DREG    LR, " ", cc
        DLINE   "= file len, from DiscSize"
01
  ]
        Pull    "R0,PC",NE

        LDR     LR, [LR, #DiscRecord_BigDir_RootDirSize]
  [ Debug6
        DREG    LR, " ",cc
        DLINE   "= file len, from RootDirSize"
  ]
        Pull    "R0,PC"

05
        ; not big dirs
        TEQS    R4, #0
        ADDNE   R0, R4, #DirLen
        ReadWord NE
   [ Debug6
        BEQ     %FT01
        DREG    LR, " ", cc
        DLINE   "= file len, from DirLen"
01
   ]
        Pull    "R0,PC",NE


        ; For root object need special processing
        BL      DiscAddToRec    ;(R3->LR)
        LDRB    R0, [LR, #DiscFlags]
        TST     R0, #DiscNotFileCore

        ; Contents of non-filecore disc
        LDRNE   LR, [LR, #DiscRecord_DiscSize]
  [ Debug6
        BEQ     %FT01
        DREG    LR, " ", cc
        DLINE   "= file len, from DiscSize"
01
  ]
        Pull    "R0,PC",NE

        ; Root dir, FileCore disc
        BL      TestDir
        MOVEQ   LR, #NewDirSize
        MOVNE   LR, #OldDirSize

  [ Debug6
        DREG    LR, " ", cc
        DLINE   "= file len, from New/OldDirSize"
  ]
 |
        BL      TestDir
        MOVEQ   LR, #NewDirSize
        MOVNE   LR, #OldDirSize
        TEQS    R4, #0
        ADDNE   R0, R4, #DirLen
        ReadWord NE
 ]
 [ Debug6
        DREG    LR, " ", cc
        DLINE   "= file len"
 ]
        Pull    "R0,PC"


; ==============
; ReadIndDiscAdd
; ==============

; read indirect disc address from directory entry

; entry: R3    dir disc address
;        R4 -> entry

; exit:  LR = indirect disc address

ReadIndDiscAdd
        Push    "R0,R7,LR"
        SavePSR R7
        TEQ     R4, #0

        ; Root object - disc add is dir disc add
        MOVEQ   LR, R3
  [ Debug6
        BNE     %FT01
        DREG    R3, "Disc add = "
01
  ]
        BEQ     %FT90

  [ BigDir
        BL      TestBigDir
        BNE     %FT01

        LDR     LR, [R4, #BigDirIndDiscAdd]

        B       %FT02
01
        BL      TestMap                 ;(R3->Z)
        ADD     R0, R4, #DirIndDiscAdd
        Read3
        MOVNE   LR, LR, LSL #8
02
  |
        BL      TestMap                 ;(R3->Z)
        ADD     R0, R4, #DirIndDiscAdd
        Read3
        MOVNE   LR, LR, LSL #8
  ]
        BIC     LR, LR, #2_111 :SHL: (32-3)     ;only to be safe for corrupt dirs
        AND     R0, R3, #2_111 :SHL: (32-3)     ;copy disc num bits
        ORR     LR, LR, R0
 [ Debug6
        DREG    LR, " ", cc
        DLINE   "= disc add"
 ]
90
        RestPSR R7,,f
        Pull    "R0,R7,PC"


; ===========
; ReadIntAtts
; ===========

; read attributes from directory entry in internal format

; entry: R3 = disc address of dir
;        R4 ->entry

 [ FullAtts
; exit:  LR has attributes, bits 7-0 7654DLWR
 |
; exit:  LR has attributes, bits 3-0     DLWR
 ]

ReadIntAtts ROUT
        Push    "R0-R1,LR"
        TEQS    R4, #0                           ;root ?
        BNE     %FT05

        ; processing of a root object
        BL      DiscAddToRec                  ;(R3->LR)
        LDRB    LR, [LR, #DiscFlags]
        TST     LR, #DiscNotFileCore
        MOVNE   LR, #ReadBit :OR: WriteBit    ; non-filecore root = disc image
        MOVEQ   LR, #DirBit :OR: IntLockedBit ; filecore root
        Pull    "R0-R1,PC"
05
 [ BigDir
        BL      TestBigDir
        LDREQB  LR, [R4, #BigDirAtts]
        BEQ     %FT20
 ]
        BL      TestDir              ;EQ <=> New format
        LDREQB  LR, [R4,#NewDirAtts]
 [ Debug6
        BNE     %FT01
        DREG    LR, " ", cc
        DLINE   "= New Atts"
01
 ]
        BEQ     %FT20
;here if old format
        MOV     R1, #4          ;att offsets ctr 01234 RWLDE
        MOV     LR, #0
10
        LDRB    R0, [R4,R1]
        MOVS    R0, R0, LSR #8  ;C=Attribute bit
        ADC     LR, LR, LR      ;shift previous bits left 1 and add in this bit
        SUBS    R1, R1, #1
        BPL     %BT10

        TSTS    LR, #EBit       ;give old E files read access
        BIC     LR, LR, #EBit
        ORRNE   LR, LR, #ReadBit
 [ Debug6
        DREG    LR, " ", cc
        DLINE   "= Old Atts"
 ]
20
        TSTS    LR, #DirBit
 [ FullAtts
        ASSERT  IntAttMask = &FF
 |
        ANDEQ   LR, LR, #IntAttMask
 ]
        ANDNE   LR, LR, #IntDirAttMask
95
        Pull    "R0-R1,PC"


; ===========
; ReadExtAtts
; ===========

; read attributes from directory entry in external format

; entry: R3 = disc address of dir
;        R4 ->entry

 [ FullAtts
; exit:  LR has attributes,  bits 7-0 7654L0WR
 |
; exit:  LR has attributes,  bits 7-0 L0WRL0WR
 ]

ReadExtAtts ROUT
        Push    "LR"
        BL      ReadIntAtts     ;(R3,R4->LR)
        ASSERT  ReadBit=1
        ASSERT  WriteBit=2
        ASSERT  IntLockedBit=4
        BIC     LR, LR, #DirBit
        ASSERT  ExtLockedBit=IntLockedBit :SHL: 1  ;move locked bit
        ADD     LR, LR, #IntLockedBit
        BIC     LR, LR, #IntLockedBit
 [ :LNOT: FullAtts
        ORR     LR, LR, LR, LSL #4      ;repeat bottom nibble in next nibble
 ]
        Pull    "PC"

; =========
; WriteLoad
; =========

; Write Load address of directory entry

; entry: R0=Load Address
;        R3= dir indirect disc address
;        R4->dir entry

WriteLoad ROUT
 [ Debug6
        DLINE   "Load add|dir ptr - enter WriteLoad"
        DREG    R0, " ", cc
        DREG    R4, " "
 ]
        Push    "R0-R1,LR"
 [ BigDir
        BL      TestBigDir              ;(R3->Z)
        BEQ     %FT10
 ]
        BL      ReadLoad                ;(R3,R4->LR)
        TEQS    R0,LR                   ;nothing to do if unchanged
        BLNE    InvalidateBufDir
        MOVNE   R1,R0
        ADDNE   R0,R4,#DirLoad
        WriteWord NE
        Pull    "R0-R1,PC"

 [ BigDir
10
        BL      ReadLoad                ;(R3,R4->LR)
        TEQS    R0,LR                   ;nothing to do if changed
        BLNE    InvalidateBufDir
        STRNE   R0, [R4, #BigDirLoad]
        Pull    "R0-R1,PC"
 ]

; =========
; WriteExec
; =========

; Write Exec address of directory entry

; entry: R0=Exec Address, R4->dir entry

WriteExec ROUT
 [ Debug6
        DLINE   "Exec add|dir ptr - enter WriteExec"
        DREG    R0, " ", cc
        DREG    R4, " "
 ]
        Push    "R0-R1,LR"
 [ BigDir
        BL      TestBigDir
        BEQ     %FT10
 ]
        BL      ReadExec                ;(R4->LR)
        TEQS    R0,LR                   ;nothing to do if unchanged
        BLNE    InvalidateBufDir
        MOVNE   R1,R0
        ADDNE   R0,R4,#DirExec
        WriteWord NE
        Pull    "R0-R1,PC"

 [ BigDir
10
        BL      ReadExec                ;(R4->LR)
        TEQS    R0,LR                   ;nothing to do if unchanged
        BLNE    InvalidateBufDir
        STRNE   R0, [R4, #BigDirExec]
        Pull    "R0-R1,PC"
 ]

; ========
; WriteLen
; ========

; Write file length to directory entry

; entry: R0=length
;        R3= dir indirect disc address
;        R4->dir entry

WriteLen ROUT
 [ Debug6
        DLINE   "Length  |dir ptr - enter WriteLen"
        DREG    R0, " ", cc
        DREG    R4, " "
 ]
        Push    "R0-R1,LR"
 [ BigDir
        BL      TestBigDir
        BEQ     %FT10
 ]
        BL      ReadLen                 ;(R3,R4->LR)
        TEQS    R0,LR                   ;nothing to do if unchanged
        BLNE    InvalidateBufDir
        MOVNE   R1,R0
        ADDNE   R0,R4,#DirLen
        WriteWord NE
        Pull    "R0-R1,PC"

 [ BigDir
10
        BL      ReadLen                 ;(R3,R4->LR)
        TEQS    R0,LR                   ;nothing to do if unchanged
        BLNE    InvalidateBufDir
        STRNE   R0, [R4, #BigDirLen]
        Pull    "R0-R1,PC"
 ]

; ===============
; WriteIndDiscAdd
; ===============

; Write file disc address to directory entry

; entry:
;  R0=disc address
;  R4->dir entry

 [ BigDir
;  R5->dir start (only if dir is big)
 ]

WriteIndDiscAdd ROUT
 [ Debug6
        DLINE   "Disc add|dir ptr - enter WriteDiscAdd"
        DREG    R0, " ", cc
        DREG    R4, " "
 ]
        Push    "R0-R1,LR"
        BL      ReadIndDiscAdd          ;(R4->LR)
        TEQS    R0,LR                   ;nothing to do if unchanged
        BEQ     %FT95
        BL      InvalidateBufDir
        BIC     R1,R0,#DiscBits
 [ BigDir
        BL      TestBigDir
        STREQ   R1, [R4, #BigDirIndDiscAdd]
        BEQ     %FT95
 ]
        BL      TestMap                 ;(R3->Z)
        MOVNE   R1,R1,LSR #8
        ADD     R0,R4,#DirIndDiscAdd
        Write3
95
        CLRV
        Pull    "R0-R1,PC"


; ============
; WriteExtAtts
; ============

; entry: R0=atts, R3=dir disc address, R4->dir entry

; write attributes from external format to dir entry

WriteExtAtts ROUT
        Push    "R0,LR"
;first convert to internal format
        AND     R0, R0, #ExtAttMask
        ASSERT  ExtLockedBit=IntLockedBit :SHL: 1
        TSTS    R0, #ExtLockedBit
        EORNE   R0, R0, #ExtLockedBit :EOR: IntLockedBit
        BL      WriteIntAtts    ;(R0,R3,R4)
        Pull    "R0,PC"


; ============
; WriteIntAtts
; ============

; write attributes from internal format to dir entry

; entry: R0=atts, R3=dir disc address, R4->dir entry

WriteIntAtts ROUT
 [ Debug6
        DLINE   "Atts    |dir add |dir ptr - enter WriteIntAtts"
        DREG    R0, " ", cc
        DREG    R3, " ", cc
        DREG    R4, " "
 ]
        Push    "R0-R2,R4,LR"
        BL      ReadIntAtts     ;(R3,R4->LR) read old atts
        TSTS    LR, #DirBit
        BICNE   R1, LR, #IntLockedBit :OR: NewAtts :OR: ReadBit :OR: WriteBit
        ANDNE   R0, R0, #IntLockedBit :OR: NewAtts
        ORRNE   R0, R1, R0
        ANDEQ   R0, R0, #IntAttMask :EOR: DirBit
        TEQS    R0, LR
        Pull    "R0-R2,R4,PC",EQ        ;no change
SetAttsCommon
        BL      InvalidateBufDir
 [ BigDir
        BL      TestBigDir
        STREQB  R0, [R4,#BigDirAtts]    ; write atts
        Pull    "R0-R2,R4,PC",EQ
 ]
        BL      TestDir
        STREQB  R0, [R4,#NewDirAtts]
;fall through rest if new format (EQ)
 [ FullAtts
        BICNE   R0, R0, #NewAtts        ;can't give full atts to old dir
 ]
        MOVNE   R1, #5
10
        LDRNEB  R2, [R4]                ;get byte from dir
        BICNE   R2, R2, #&80            ;clear old att bit
        ORRNE   R2, R2, R0, LSL #7      ;or in new bit
        MOVNE   R0, R0, LSR #1          ;shift new atts for next bit
        STRNEB  R2, [R4],#1             ;write back modified
        SUBNES  R1, R1, #1              ;loop until done
        BNE     %BT10
        Pull    "R0-R2,R4,PC"

; ==========
; SetIntAtts
; ==========

; write attributes from internal format to dir entry IGNORING PREVIOUS VALUE

; entry: R0=atts, R3=dir disc address, R4->dir entry

SetIntAtts ROUT
 [ Debug6
        DLINE   "Atts    |dir add |dir ptr - enter SetIntAtts"
        DREG    R0, " ", cc
        DREG    R3, " ", cc
        DREG    R4, " "
 ]
        Push    "R0-R2,R4,LR"
        B        SetAttsCommon


; ===========
; WriteParent
; ===========

; entry
;  R3 parent disc address
 [ BigDir
; if dir is big, then R5->dir start
 ]
;  R6 -> dir end

WriteParent
 [ Debug6
        DREG    R3, " ", cc
        DREG    R6, " ", cc
        DLINE   " WriteParent"
 ]
        Push    "R0,R1,LR"
 [ BigDir
        BL      TestBigDir
        BICEQ   R1, R3, #DiscBits
        STREQ   R1, [R5, #BigDirParent]
        Pull    "R0,R1,PC",EQ
 ]
        BL      TestDir      ;(R3->LR,Z)
        ADDEQ   R0, R6, #NewDirParent
        ADDNE   R0, R6, #OldDirParent
        BIC     R1, R3, #DiscBits
        BL      TestMap         ;(R3->Z)
        MOVNE   R1, R1, LSR #8
        Write3                  ;Parent dir disc address (R0,R1)
        Pull    "R0,R1,PC"      ; (C, V preserved)


; =======
; TestDir
; =======

; test old/new format

; entry: R3=disc address

; exit  Z=1 <=> new, C,V preserved, LR->disc rec

TestDir ROUT
        Push    "R0,LR"
        BL      DiscAddToRec            ;(R3->LR)
        LDRB    R0, [LR,#DiscFlags]
        ASSERT  OldDirFlag<&100      ;to preserve C
        TSTS    R0, #OldDirFlag
 [ Debug6 :LAND: {FALSE}
        BNE     %FT01
        DLINE   "new dir"
        B       %FT02
01
        DLINE   "old dir"
02
 ]
        Pull    "R0,PC"


; =======
; TestMap
; =======

; test old/new format

; entry: R3=disc address

; exit  Z=1 <=> new, C,V preserved, LR->disc rec

TestMap ROUT
        Push    "R0,LR"
        BL      DiscAddToRec            ;(R3->LR)
        LDRB    R0, [LR,#DiscFlags]
        ASSERT  OldMapFlag<&100      ;to preserve C
        TSTS    R0, #OldMapFlag
 [ DebugE
        BNE     %FT01
        DLINE   "test new map"
        B       %FT02
01
        DLINE   "test old map"
02
 ]
        Pull    "R0,PC"



HugoNick
 = "Hugo"
 = "Nick"


; ========
; CheckDir
; ========

; Check dir is well formed

; entry: R3=dir disc add, R5->dir start, R6->dir end

; exit:  IF error V set, R0 result

CheckDir ROUT
 [ Debug6; :LAND: {FALSE}
        DLINE    ,"dir add |dir beg |dir end - enter CheckDir"
        DREG    R3, " ",cc
        DREG    R5, " ",cc
        DREG    R6, " "
 ]
        Push    "R0,R1,R10,R11,LR"
        MOV     R10,#1
CheckDirCommon
 [ BigDir
        BL      TestBigDir              ; is it a big directory?
        BNE     %FT01
        BL      CheckBigDir             ;(R3,R5,R6,R10->R0,V)
        MOVVC   R0,#0
        B       %FT95
01      ; not a big dir
 ]
        ADD     R0, R5, #StartName      ;Check start string
        ReadWord                        ;(R0->LR)
        baddr   R1, HugoNick
        LDMIA   R1, {R1,R11}
        TEQS    LR, R1
        MOVNE   R1, R11
        TEQNES  LR, R11

 [ Debug6; :LAND: {FALSE}
        BEQ     %FT01
        DLINE   "Failed at HugoNick"
01
 ]

        LDREQB  R0, [R5,#StartMasSeq]   ;Check master sequence numbers match
        LDREQB  LR, [R6,#EndMasSeq]
        TEQS    R0, LR

 [ Debug6; :LAND: {FALSE}
        BEQ     %FT01
        DLINE   "Failed at sequences"
01
 ]

        ADDEQ   R0, R6, #EndName        ;Check end string
        ReadWord EQ                     ;(R0->LR)
        TEQEQS  LR, R1
 [ Debug6; :LAND: {FALSE}
        BEQ     %FT01
        DLINE   "Failed at EndName"
01
 ]
        BNE     %FT90

        MOVS    R10,R10                 ;quick flag
        BLNE    TestDirCheckByte        ;(R3,R5,R6->LR,Z)
        BNE     %FT90

        BL      TestDir                 ;(R3->LR,Z)
        LDREQB  R0, [R6,#NewDirLastMark]
        LDRNEB  R0, [R6,#OldDirLastMark]
        TEQS    R0, #0
 [ Debug6; :LAND: {FALSE}
        BEQ     %FT01
        DLINE   "Failed at LastMark"
01
 ]
90
        BEQ     %FT95
        MOV     R0, #BrokenDirErr
        LDR     LR, BufDir
        TEQS    LR, R3
        BLEQ    InvalidateBufDir
        BEQ     %FT95
        BL      TryCache                ;(R3->R11,V)
        BLVC    InvalidateDirCache      ;if a dir in cache is broken, scrap whole cache
95
        BL      SetVOnR0
        STRVS   R0, [SP]
 [ Debug6; :LAND: {FALSE}
        DLINE   "dir add |dir beg |dir end |result - leave CheckDir"
        DREG    R3, " ",cc
        DREG    R5, " ",cc
        DREG    R6, " ",cc
        BVC     %FT01
        DREG    R0," "
01
 ]
        Pull    "R0,R1,R10,R11,PC"



; =============
; QuickCheckDir
; =============

; Check dir is well formed, excluding check byte

; entry: R3=dir disc add, R5->dir start, R6->dir end

; exit:  IF error V set, R0 result

QuickCheckDir ROUT
 [ Debug6
        DLINE   "dir add |dir beg |dir end - enter CheckDir"
        DREG    R3, " ", cc
        DREG    R5, " ", cc
        DREG    R6, " "
 ]
        Push    "R0,R1,R10,R11,LR"
        MOV     R10,#0
        B       CheckDirCommon

; ============
; IncDirSeqNum
; ============

; Increment dir master seqence number, also invalidates dir buffer

; entry:
;  R5 -> dir start
;  R6 -> dir end

 [ BigDir
; R3 - dir ind disc add
 ]

IncDirSeqNum
 [ BigDir
        Push    "LR"
        BL      TestBigDir
        BEQ     %FT01
        BL      InvalidateBufDir
        BL      NextDirSeqNum           ;(R5->LR)
        STRB    LR,[R5,#StartMasSeq]
        STRB    LR,[R6,#EndMasSeq]
        Pull    "PC"
01
        BL      InvalidateBufDir
        BL      NextDirSeqNum           ;(R5->LR)
        STRB    LR,[R5,#BigDirStartMasSeq]
        STRB    LR,[R6,#BigDirEndMasSeq]
        Pull    "PC"
 |
        Push    "LR"
        BL      InvalidateBufDir
        BL      NextDirSeqNum           ;(R5->LR)
        STRB    LR,[R5,#StartMasSeq]
        STRB    LR,[R6,#EndMasSeq]
        Pull    "PC"
 ]


; ============
; IncObjSeqNum
; ============

; Increment old format object seqence number, also invalidates dir buffer

; entry:
;  R3 = dir ind disc address
;  R4 -> dir entry
;  R5 -> dir start

IncObjSeqNum
        Push    "LR"
        BL      TestDir              ;(R3->LR,Z)
        Pull    "PC",EQ
        BL      InvalidateBufDir
        BL      NextDirSeqNum           ;(R5->LR)
        STRB    LR,[R4,#OldDirObSeq]
        Pull    "PC"


; =============
; NextDirSeqNum
; =============

; calculate next BCD dir sequence number

; entry: R5 -> dir start

; exit: LR = next dir seq num

NextDirSeqNum
        Push    "R0,LR"
 [ BigDir
        ASSERT  BigDirStartMasSeq=StartMasSeq
 ]
        LDRB    LR,[R5,#StartMasSeq]    ;get old master sequence number
        ADD     LR,LR,#1                ;increment in bcd
        CMPS    LR,#&9A
        MOVHS   LR,#0
        AND     R0,LR,#&F
        CMPS    R0,#&A
        ADDHS   LR,LR,#&10-10
        Pull    "R0,PC"


; =========
; IsDirFull
; =========

; only works on dirs in buffer, not in cache

; entry:
;  R3 top 3 bits disc id
;  R5 -> dir start
;  R6 -> dir end

; exit:
;  IF full V set, R0 result

IsDirFull ROUT
        Push    "R0,LR"
        BL      EndDirEntries       ;(R3,R5,R6->R0)
        BL      TestDir          ;(R3->LR,Z)
        ADDEQ   R0,R0,#-NewDirLastMark
        ADDNE   R0,R0,#-OldDirLastMark
        CMPS    R0,R6
        MOVHS   R0,#DirFullErr
        MOVLO   R0,#0
        BL      SetVOnR0
        STRVS   R0,[SP]
 [ Debug6
        BVC     %FT01
        DLINE   "Dir full"
        B       %FT02
01
        DLINE    "Dir not full"
02
 ]
        Pull    "R0,PC"

; ============
; MakeDirSpace
; ============

; make space for a new entry in RAM copy of a directory
; ASSUMES DIR IS NOT FULL can check this with IsDirFull

; entry:

 [ BigDir
;  R1 IF DIR IS BIG, R1->term
 ]

;  R3 ind disc address
;  R4 -> entry
;  R5 -> dir start
;  R6 -> dir end

; exit: must preserve flags

MakeDirSpace ROUT
 [ NewDirEntrySz=OldDirEntrySz
        Push    "R0-R2,LR"
        SavePSR LR
        Push    lr
 [ BigDir
        BL      TestBigDir
        BNE     %FT00
        BL      MakeBigDirSpace ;different code for when a big dir.
        B       %FT05
00
 ]
        SUBS    R0, R4, #NewDirEntrySz
10                              ;search for end of entries
        LDRB    LR, [R0,#NewDirEntrySz] !
        TEQS    LR, #0
        BNE     %BT10
        STRB    LR, [R0,#NewDirEntrySz] ;will mark end of extended entry list
        ADD     R1, R4, #NewDirEntrySz  ;dest
        SUBS    R2, R0, R4      ;len
        MOVNE   R0, R4          ;source
        BLNE    BlockMove       ;dont bother to do zero length move
05
        Pull    r0
        RestPSR r0,,f
        Pull    "R0-R2,PC"

 |

        Push    "R0-R2,LR"
        SavePSR LR
        Push    lr
        BL      TestDir
        MOVEQ   R2, #NewDirEntrySz
        MOVNE   R2, #OldDirEntrySz
        SUBS    R0, R4, R2
10                              ;search for end of entries
        LDRB    LR, [R0,R2] !
        TEQS    LR, #0
        BNE     %BT10
        STRB    LR, [R0,R2]     ;will mark end of extended entry list
        ADD     R1, R4, R2      ;dest
        SUBS    R2, R0, R4      ;len
        MOVNE   R0, R4          ;source
        BLNE    BlockMove       ;dont bother to do zero length move
        Pull    r0
        RestPSR r0,,f
        Pull    "R0-R2,PC"

 ]


; ========
; WriteDir
; ========

; Write out dir in dir buffer to disc

; entry: DirBuf invalid ie &FFFFFFFF
;        ind disc address of dir in CritDirBuf

; exit:  IF error V set, R0 result

WriteDir
 [ Debug6 ;:LOR: DebugXr
        DLINE   "enter WriteDir"
 ]
        Push    "R0-R11,LR"
        LDR     r3, BufDir
        CMP     r3, #-1
        LDREQ   r3, CritBufDir
        BLEQ    EnsureNewId             ;(R3->R0,V)
        BL      DisableBreak
        BLVC    CriticalWriteDir        ;CRITICAL CODE MAY CORRUPT R1-R11
        BL      RestoreBreak
        STRVS   R0,[SP]
        Pull    "R0-R11,PC"
 [ Debug6 ;:LOR: DebugXr
        DREG    R0," ",cc
        DLINE   "leave WriteDir"
 ]

        LTORG
        END
@


4.13
log
@Fix abort mounting old map discs
The massive speedup in FileCore 3.50 by not loading the map sector wise (twice) on mounting meant that the code path to resize the dynamic area for the map had changed.
So, with DynamicMaps = {TRUE} mounting an old map disc would try to load the map into a zero size area (the area had an allocated address but was 0 bytes long).
Aside: reading a new map disc first, then swapping to an old map disc would mask the problem since the dynamic area is only shrunk on an active dismount.


Version 3.53. Tagged as 'FileCore-3_53'
@
text
@d518 1
a518 1
        BL      DiscAddToRec
d608 1
a608 1
        BLCS    DiscAddToRec
d885 1
a885 1
        MOV     r3, lr, ASL #32-3
d1323 1
a1323 1
        DREG    R1,"",cc
d1578 1
a1578 1
        BLEQ    DiscAddToRec
d1596 1
a1596 1
        BLEQ    DiscAddToRec
d1716 1
a1716 1
        BL      DiscAddToRec
d1831 1
a1831 1
        BL      DiscAddToRec
d1991 3
a1993 1
; entry: R0=length, R4->dir entry
d2006 1
a2006 1
        BL      ReadLen                 ;(R4->LR)
d2016 1
a2016 1
        BL      ReadLen                 ;(R4->LR)
@


4.12
log
@  Miscellaneous improvements
Detail:
  * Added the ability for a filing system to specify to FileCore that floppy
    discs should be mounted like hard discs, to complement the existing flag
    that specifies the opposite. SDFS requires this. Ideally SCSIFS should
    start using this as well, to encapsulate boot block handling within
    FileCore.
  * Added header definitions so the FileCore and the filing systems can
    negotiate the use of a new MiscOp entry, needed as part of partitioning
    support, especially important for filing systems that use the hardware-
    specific section of the boot block, like ADFS. At present, FileCore
    doesn't do anything different (it still doesn't support partitions) but
    this enables filing systems to be modified in preparation.
  * Removed the only place where FileCore paid any attention to the
    EmptyWorks flag returned by MiscOp 1 - an obscure and not very useful
    edge case not used by any current filing systems.
  * Added 650 lines of documentation for the MiscOp SWI and low-level entry
    to the Doc directory, giving the information you need in order to
    implement a FileCore filing system.
  * Added missing header file definitions for the low-level background DiscOp
    reason code and the hot-plug drive removed flag to MiscOp 7.
  * Removed some RISC OS 2 legacy code whereby FileCore maintained its idea
    of the internal disc address of the CSD @@, PSD \, Library % and URD & for
    each filing system. Since RISC OS 3.00, FileSwitch handles these
    internally and passes canonicalised paths to FileCore, so FileCore's disc
    addresses for these directories remained unset. This allows some
    considerable simplification of FileCore's path parser in particular, but
    also affects other code like that which decides how to expire disc
    records. Also note that FileCore has been unable to generate certain
    errors (like "Can't delete current directory") since RISC OS 3.00 for the
    same reason.
  * Changed loading of the map for FileCore-format discs so that the map is
    loaded into the dynamic area during the Service_IdentifyDisc handler in
    one big DiscOp rather than loading it twice, sector-by-sector, via one
    big sector cache. For one thing, the sector cache is implemented
    inefficiently - O(n^2) - and for another thing, single-sector DiscOps are
    relatively inefficient on many filing systems, especially on SD cards.
    Some example speed-ups measured for mounting discs are:
      SCSIFS,   1GB drive: was 0.62 sec, now 0.40 sec (1.55 x speedup)
      SCSIFS, 256GB drive: was 1.44 sec, now 0.52 sec (2.77 x speedup)
      SDFS,     2GB drive: was 1.25 sec, now 0.14 sec (8.93 x speedup)
Admin:
  Tested on a beagleboard, with SCSIFS and SDFS.

Version 3.50. Tagged as 'FileCore-3_50'
@
text
@d2226 1
a2226 1
        DLINE   "new map"
d2229 1
a2229 1
        DLINE   "old map"
@


4.11
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d334 5
d376 1
d378 1
d383 1
d388 1
d404 1
d498 1
d528 3
d538 1
@


4.10
log
@Suspicious PC fiddling exorcised.
R8 was being used to remember the C bit, by copying from the PC. Swapped to use RRX instead.

Version 3.43. Tagged as 'FileCore-3_43'
@
text
@d406 1
a406 1
        LDRNE   R3, [R3,#RootDir]
d484 1
a484 1
        LDR     R3, [R3,#RootDir]
d548 1
a548 1
 	BL	GetDirFirstEntry
d560 2
a561 2
 	BL	TestBigDir
 	BNE	%FT01
d564 3
a566 3
 	ADDS	R1, R7, #0
 	BL	LookUpBigDir
 	B	%FT02
d569 1
a569 1
	BL	%FT99		; check the name length
d571 2
a572 2
	ADDS	R1, R7, #0
	BL	LookUp
d608 1
a608 1
        LDR     LR, [LR,#RootDir]
d622 8
a629 8
 	BL	TestBigDir		;(R3->Z)
 	BNE	%FT02
 	BL	BigDirFinished		;(R4,R5->Z)
	BEQ	%FT75
	BL	ReadIndDiscAdd
	TEQS	LR, R7			; check if OK
	BEQ	%FT75			; match
	ADD	R4, R4, #BigDirEntrySize
d631 1
a631 1
 	B	%BT63
d694 5
a698 5
99	; check name length
	; r7 = ptr to name
	; if name is invalid then set r0 to error ptr,
	; Pull r0-r2 and jump to 95
	Push	"r0,r7,lr"
d700 1
a700 1
	LDRB    R0, Flags
d702 1
a702 1
	Pull	"r0,r7,pc",EQ
d704 16
a719 16
	MOV	lr,r7
00	LDRB	r0,[r7],#1
	TEQ	r0,#127
	TEQNE	r0,#'.'
	BEQ	%FT01
	CMP	r0,#' '
	BGT	%BT00
01	SUB	r0,r7,lr
	CMP	r0,#NameLen+1
	Pull	"r0,r7,pc",LE

	Pull	"r0,r7,lr"
	Pull	"r0,r1,r2"
	MOV	r0,#BadNameErr
	BL	SetVOnR0
	B	%BT95
d751 6
a756 6
 	BL	TestBigDir
 	ANDEQ	LR, R3, #DiscBits
 	LDREQ	R3, [R5,#BigDirParent]
	BICEQ	R3, R3, #DiscBits
 	ORREQ	R3, R3, LR
 	BEQ	%FT90
d846 1
a846 1
	DLINE	"It's a drive number, going to WhatDisc the drive"
d853 1
a853 1
        LDRVC   R3, [R3,#RootDir]
d876 1
a876 1
        ADD     r4, r6, #DiscName
d881 1
a881 1
        LDREQ   r6, [r6, #RootDir]
d886 1
a886 1
        sbaddr  R4, DiscRecs+DiscName
d893 1
a893 1
        LDRB    LR, [R4,#Priority-DiscName]
d916 1
a916 1
        LDR     r6, [r4, #RootDir - DiscName]
d995 2
a996 2
        ADD     R4, R3, #DiscName
        LDR     R3, [R3,#RootDir]
d1319 1
a1319 1
        ADD     R6, R4, R6		;Max Name end ptr
d1328 2
a1329 2
	TEQS	R0, #DelimChar
	MOVEQ	R0, #0		; delimiters must be replaced by 0 too
d1351 2
a1352 2
 	BHI	%FT01
 	DLINE	"name<wild"
d1354 2
a1355 2
 	BLO	%FT01
 	DLINE	"name>wild"
d1364 2
a1365 2
	TEQS	R0, #DelimChar
	MOVEQ	R0, #0		;delimiters must be replaced by 0 too
d1385 2
a1386 2
	TEQS	R9, #DelimChar
	MOVEQ	R9, #0
d1391 1
a1391 1
        MOVLO	R9, #0		;terminator of 0 if name terminated
d1395 1
a1395 1
	CMPNE	R0, #0
d1399 4
a1402 4
	LDR	lr, [sp, #2*4]
	SUB	lr, r4, lr
	CMP	lr, #BigDirMaxNameLen
	BLO	%BT20		;mismatch if not reached max name length
d1557 2
a1558 2
 	BL	TestBigDir
 	BEQ	%FT10
d1564 1
a1564 1
        LDREQ   LR, [LR, #DiscType]
d1582 1
a1582 1
        LDREQ   LR, [LR, #DiscType]
d1586 1
a1586 1
        LDRNE	LR, [R4, #BigDirLoad]
d1607 2
a1608 2
 	BL	TestBigDir
 	BEQ	%FT10
d1624 1
a1624 1
	LDRNE	LR, [R4, #BigDirExec]
d1647 8
a1654 8
  	; check if is big dirs
  	BL	TestBigDir
  	BNE	%FT05
  	; big dirs

  	TEQS	R4, #0
  	LDREQ	LR, [LR, #RootDirSize]
  	LDRNE	LR, [R4, #BigDirLen]
d1663 2
a1664 2
	; big dir, but root object.  read root length from disc record
  	BL	DiscAddToRec	;(R3->LR)
d1670 1
a1670 1
        LDRNE   LR, [LR, #DiscSize]
d1679 1
a1679 1
  	LDR	LR, [LR, #RootDirSize]
d1681 2
a1682 2
  	DREG	LR, " ",cc
  	DLINE	"= file len, from RootDirSize"
d1684 1
a1684 1
  	Pull	"R0,PC"
d1687 1
a1687 1
	; not big dirs
d1706 1
a1706 1
        LDRNE   LR, [LR, #DiscSize]
d1765 2
a1766 2
  	BL	TestBigDir
  	BNE	%FT01
d1768 1
a1768 1
  	LDR	LR, [R4, #BigDirIndDiscAdd]
d1770 1
a1770 1
  	B	%FT02
d1824 3
a1826 3
 	BL	TestBigDir
 	LDREQB	LR, [R4, #BigDirAtts]
 	BEQ	%FT20
d1914 2
a1915 2
 	BL	TestBigDir		;(R3->Z)
 	BEQ	%FT10
d1927 5
a1931 5
 	BL	ReadLoad		;(R3,R4->LR)
 	TEQS	R0,LR			;nothing to do if changed
 	BLNE	InvalidateBufDir
 	STRNE	R0, [R4, #BigDirLoad]
 	Pull	"R0-R1,PC"
d1950 2
a1951 2
 	BL	TestBigDir
 	BEQ	%FT10
d1966 2
a1967 2
	STRNE	R0, [R4, #BigDirExec]
	Pull    "R0-R1,PC"
d1986 2
a1987 2
 	BL	TestBigDir
 	BEQ	%FT10
d2002 1
a2002 1
	STRNE	R0, [R4, #BigDirLen]
d2033 3
a2035 3
 	BL	TestBigDir
 	STREQ	R1, [R4, #BigDirIndDiscAdd]
 	BEQ	%FT95
d2092 3
a2094 3
 	BL	TestBigDir
	STREQB	R0, [R4,#BigDirAtts]	; write atts
        Pull	"R0-R2,R4,PC",EQ
d2151 4
a2154 4
 	BL	TestBigDir
	BICEQ	R1, R3, #DiscBits
 	STREQ	R1, [R5, #BigDirParent]
 	Pull	"R0,R1,PC",EQ
d2247 6
a2252 6
 	BL	TestBigDir		; is it a big directory?
 	BNE	%FT01
 	BL	CheckBigDir		;(R3,R5,R6,R10->R0,V)
 	MOVVC	R0,#0
 	B	%FT95
01	; not a big dir
d2364 2
a2365 2
        BL	TestBigDir
        BEQ	%FT01
d2421 1
a2421 1
 	ASSERT	BigDirStartMasSeq=StartMasSeq
d2494 1
a2494 1
        BL	TestBigDir
@


4.9
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d598 1
a598 1
        MOV     R8, PC          ;save C flag
d670 1
a670 1
        MOV     R8, R8, LSR #C_bit_number+1   ;C=1 <=> dir
@


4.8
log
@  Various archiecture-based optimisations
Detail:
  * ARMv6+ builds use unaligned halfword and word loads and stores (unless
    pre-ARMv6 compatibility is required or NoUnaligned is set)
  * In many cases, one unnecessary BIC instruction has been removed from
    pre-ARMv6 builds
  * ARMv5+ builds (so Tungsten and OMAP) make use of CLZ instruction when
    parsing fragment blocks
Admin:
  Built and included in an OMAP3 ROM. But be warned, this has not received
  the rigorous testing normally required of filesystem code, use at your
  own risk.

Version 3.33. Tagged as 'FileCore-3_33'
@
text
@a18 3
			GBLL	FixTruncateOnBigDiscs
FixTruncateOnBigDiscs	SETL	T

d1445 3
a1447 3
        wrhex   R1
        wrhex   R4
        wrhex   R5
@


4.7
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 3.29. Tagged as 'FileCore-3_29'
@
text
@d767 1
a767 1
        BL      Read3           ;load disc address of parent non aligned
d1572 1
a1572 1
        BLNE    ReadWord
d1616 1
a1616 1
        BLNE    ReadWord
d1693 1
a1693 1
        BLNE    ReadWord
d1733 1
a1733 1
        BLNE    ReadWord
d1777 1
a1777 1
        BL      Read3
d1783 1
a1783 1
        BL      Read3
d1925 1
a1925 1
        BLNE    WriteWord
d1961 1
a1961 1
        BLNE    WriteWord
d1997 1
a1997 1
        BLNE    WriteWord
d2043 1
a2043 1
        BL      Write3
d2165 1
a2165 1
        BL      Write3          ;Parent dir disc address (R0,R1)
d2258 1
a2258 1
        BL      ReadWord                ;(R0->LR)
d2282 1
a2282 1
        BLEQ    ReadWord                ;(R0->LR)
@


4.6
log
@  More 32-bit fixes.
Detail:
  Flag preservation added to 7 routines that require it.  Docs.32-bit
    updated to remove the names of the functions that have been made
    to preserve flags again.
Admin:
  This version needs more testing, but at least this version does not
    appear to stiff the machine, corrupt discs, go bang under light
    testing with ADFS and RAMFS.
  26-bit and 32-bit builds slightly tested.
  Do not use in products - Do use in test builds.

Version 3.25. Tagged as 'FileCore-3_25'
@
text
@d46 1
a46 1
BackChar        * "\"
@


4.5
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d1080 2
a1081 1
        Push    "LR"
d1088 2
a1089 1
        Pull    "PC"
d1099 1
a1099 1
; exit:  R1->first char of term
d1102 2
a1103 1
        Push    "LR"
d1110 2
a1111 1
        Pull    "PC"
d1605 1
a1605 1
; exit:  LR = exec address
d2489 2
d2494 2
d2498 4
a2501 2
        Pull    "R0-R2,LR",EQ
        BEQ     MakeBigDirSpace ;different code for when a big dir.
d2513 3
a2515 1
        CLRV
d2521 2
d2536 2
a2537 1
        CLRV
@


4.4
log
@
  * Failed to assemble on Lazarus build due to missing symbol.

Detail:

  * The latest merge appeared to have missed one of the "Module_Version"
    symbol changes.  It failed to assemble:

      s.FileCore40: Serious error  Undefined symbol

    "Version" changed to "Module_Version" to correct this, in line with
    the other related changes.

Admin:

  * Untested; to be built into next Lazarus development build.

Version 3.22. Tagged as 'FileCore-3_22'
@
text
@d168 4
a171 3
        BLEQ    CheckDelim
        BLNE    CheckName       ;this will not return if term is terminated
        B       %BT60
d291 1
a291 1
        Pull    "PC",,^
d370 1
a370 1
        MOV     R6, PC
d460 3
d471 1
a471 1
        MOVEQS  PC, LR          ;if cant find try next
d617 4
a620 3
        MOVVC   R7, R3
        BLVC    ToParent        ;now get parent
        BLVC    FindDir         ;(R3->R0,R5,R6,V)
d729 1
a729 1
        MOVEQS  PC, R0
a765 1
 [ NewFs
a769 4
 |
        BL      Read3           ;load disc address of parent non aligned
        ORR     R3, R3, LR, LSL #8
 ]
d774 1
a774 1
        Pull    "R0,PC",,^
d1014 4
a1017 3
        BLEQ    SkipTerm        ;move R1 past term if match
        MOVEQ   R2, #0          ;success code
        BEQ     %FT40           ;if matched then dont need to look any further
d1087 1
a1087 1
        Pull    "PC",,^
d1107 1
a1107 1
        Pull    "PC",,^
a1313 1
 [ Module_Version >= 205
a1316 1
 ]
d1389 1
a1389 1
        MOVHSS  PC, LR          ;name not terminated
a1450 1
 [ Module_Version >= 205
a1453 1
 ]
d1516 1
a1516 1
        MOVHSS  PC, LR          ;name not terminated
a1547 1
 [ Module_Version >= 205
a1549 3
 |
; entry: R4 ->entry
 ]
a1559 1
 [ Module_Version >= 205
a1566 3
 |
        MOVEQ   LR, #0
 ]
d1573 1
a1573 1
        Pull    "R0,PC",,^
d1590 1
a1590 1
        Pull    "R0,PC",,^
d1617 1
a1617 1
        Pull    "R0,PC",,^
d1628 1
a1628 1
        Pull    "R0,PC",,^
a1643 1
 [ Module_Version >= 205
d1660 1
a1660 1
        Pull    "R0,PC",NE,^
d1676 1
a1676 1
        Pull    "R0,PC",NE,^
d1683 1
a1683 1
  	Pull	"R0,PC",,^
d1696 1
a1696 4
        Pull    "R0,PC",NE,^


  |
a1698 12
        TEQS    R4, #0
        ADDNE   R0, R4, #DirLen
        BLNE    ReadWord
   [ Debug6
        BEQ     %FT01
        DREG    LR, " ", cc
        DLINE   "= file len"
01
   ]
        Pull    "R0,PC",NE,^
  ]

d1712 1
a1712 1
        Pull    "R0,PC",NE,^
d1735 1
a1735 1
        Pull    "R0,PC",,^
d1750 2
a1751 2
        Push    "R0,LR"
 [ Module_Version >= 205
d1761 1
a1761 1
        Pull    "R0,PC",EQ,^
a1762 2
 ]
 [ NewFs
a1781 5
 |
        ADD     R0, R4, #DirIndDiscAdd-1
        BL      ReadWord
        BIC     LR, LR, #&FF
 ]
d1789 3
a1791 1
        Pull    "R0,PC",,^
a1811 1
 [ Module_Version >= 205
d1820 1
a1820 1
        Pull    "R0-R1,PC",,^
a1821 4
 |
        MOVEQ   LR, #DirBit :OR: IntLockedBit
        Pull    "R0-R1,PC",EQ,^
 ]
d1862 1
a1862 1
        Pull    "R0-R1,PC",,^
d1893 1
a1893 1
        Pull    "PC",,^
a1900 1
 [ Module_Version >= 205
a1903 3
 |
; entry: R0=Load Address, R4->dir entry
 ]
a1915 1
 [ Module_Version >= 205
a1916 3
 |
        BL      ReadLoad                ;(R4->LR)
 ]
d1922 1
a1922 1
        Pull    "R0-R1,PC",,^
d1930 1
a1930 1
 	Pull	"R0-R1,PC",,^
d1958 1
a1958 1
        Pull    "R0-R1,PC",,^
d1966 1
a1966 1
	Pull    "R0-R1,PC",,^
d1994 1
a1994 1
        Pull    "R0-R1,PC",,^
d2002 1
a2002 1
        Pull    "R0-R1,PC",,^
a2035 1
 [ NewFs
a2037 3
 |
        MOV     R1,R1,LSR #8
 ]
d2041 2
a2042 1
        Pull    "R0-R1,PC",,^
d2061 1
a2061 1
        Pull    "R0,PC",,^
d2087 1
a2087 1
        Pull    "R0-R2,R4,PC",EQ,^      ;no change
d2093 1
a2093 1
        Pull	"R0-R2,R4,PC",EQ,^
d2110 1
a2110 1
        Pull    "R0-R2,R4,PC",,^
d2153 1
a2153 1
 	Pull	"R0,R1,PC",EQ,^
a2158 1
 [ NewFs
a2160 3
 |
        MOV     R1, R1, LSR #8
 ]
d2162 1
a2162 1
        Pull    "R0,R1,PC",,^
a2190 1
 [ NewFs
a2217 1
 ]
d2369 1
a2369 1
        Pull    "PC",,^
d2375 1
a2375 1
        Pull    "PC",,^
d2382 1
a2382 1
        Pull    "PC",,^
d2400 5
a2404 4
        BLNE    InvalidateBufDir
        BLNE    NextDirSeqNum           ;(R5->LR)
        STRNEB  LR,[R4,#OldDirObSeq]
        Pull    "PC",,^
d2429 1
a2429 1
        Pull    "R0,PC",,^
d2490 2
a2491 2
        BLEQ	MakeBigDirSpace	;different code for when a big dir.  may corrupt R0-R2
        Pull	"R0-R2,PC",EQ,^
d2503 2
a2504 1
        Pull    "R0-R2,PC",,^
d2522 2
a2523 1
        Pull    "R0-R2,PC",,^
@


4.3
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d1313 1
a1313 1
 [ Version >= 205
@


4.2
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d19 3
d100 1
a100 1
 [ Debug6
d227 1
d232 1
d247 2
d252 1
d546 3
d550 1
d558 16
d576 1
d619 21
d648 1
d691 29
d737 4
d747 10
d770 1
d848 4
d1284 140
d1434 1
d1443 1
a1443 1
 [ Debug6 :LAND: {FALSE}
d1459 1
d1562 4
d1586 17
d1616 4
d1630 11
d1657 42
d1702 16
a1717 1
  [ Debug6
d1722 2
a1724 1
        Pull    "R0,PC",NE,^
d1736 1
a1736 1
        DLINE   "= file len"
d1745 5
d1792 14
d1810 1
d1859 5
d1953 4
d1969 8
d1993 4
d2005 8
d2029 4
d2041 8
d2060 4
d2076 5
d2138 5
a2159 1

d2185 3
d2197 6
d2278 1
d2299 8
d2410 4
d2415 1
d2417 2
d2424 14
d2472 3
d2528 5
d2541 5
d2591 1
a2591 1
 [ Debug6
d2604 1
a2604 1
 [ Debug6
@


4.1
log
@Initial revision
@
text
@d1212 1
a1212 1
 [ Version >= 205
d1310 1
a1310 1
 [ Version >= 205
d1322 1
a1322 1
 [ Version >= 205
d1378 1
a1378 1
 [ Version >= 205
d1438 1
a1438 1
 [ Version >= 205
d1489 1
a1489 1
 [ Version >= 205
d1578 1
a1578 1
 [ Version >= 205
d1593 1
a1593 1
 [ Version >= 205
d1882 1
a1882 1
        baddr   R1, HugoNick    
@


4.1.4.1
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@a537 3
 [ BigDir
 	BL	GetDirFirstEntry
 |
a538 1
 ]
a545 12
 [ BigDir
 	BL	TestBigDir
 	BNE	%FT01
 	
 	ADDS	R1, R7, #0
 	BL	LookUpBigDir
 	B	%FT02
01
	ADDS	R1, R7, #0
	BL	LookUp
02
 |
a547 1
 ]
a574 3
 [ DebugX
 	DLINE	"want parent dir"
 ]
a589 21
 [ BigDir
 	BL	TestBigDir		;(R3->Z)
 	BNE	%FT02
 	BL	BigDirFinished		;(R4,R5->Z)
	BEQ	%FT75
	BL	ReadIndDiscAdd
	TEQS	LR, R7			; check if OK
	BEQ	%FT75			; match
	ADD	R4, R4, #BigDirEntrySize
	
 	B	%BT63
02
        LDRB    LR, [R4]
        CMPS    LR, #" "
        BLCS    ReadIndDiscAdd          ;(R3,R4->LR)
        TEQS    LR, R7                  ;preserves C
        ASSERT  NewDirEntrySz=OldDirEntrySz
        ADDHI   R4, R4, #NewDirEntrySz  ;HI <=> ~Z AND C
        BHI     %BT63                   ;if mismatch loop if more entries
        B       %FT75
 |
a597 1
 ]
a656 4
 [ BigDir
; if it's a big dir, then r5->dir
 ]

a662 9
 
 [ BigDir
 	BL	TestBigDir
 	ANDEQ	LR, R3, #DiscBits
 	LDREQ	R3, [R5,#BigDirParent]
 	ORREQ	R3, R3, LR
 	BEQ	%FT90
 ]
        
a675 1
90
a1184 129
 [ BigDir
; =========
; BigLexEqv
; =========

; compare wild card spec term with name (usually in dir)

; entry:
;  R1 -> term, terminated by control codes ,delete ,space or delimiter
;  R4 -> name

;  R5 =  bit mask for name chars
;  R6 =  length of name

; exit:
;  name < wild spec   C=0, Z=0, V=0
;  name = wild spec   C=1, Z=1, V=0
;  name > wild spec   C=1, Z=0, V=0

BigLexEqv
 [ Debug6  :LAND: {FALSE}
        mess    ,"wild     name     mask - enter BigLexEqv",NL
        wrhex   R1
        wrhex   R4
        wrhex   R5
 ]

        Push    "R0,R1,R4,R6-R11,LR"

 [ Version >= 205
        ; NULL name is equivalent to "" (for root object on a disc)
        TEQ     R4, #0
        baddr   R4, anull, EQ
 ]

        ADD     R6, R4, R6		;Max Name end ptr

        MOV     R7, #0                  ;wild backtrack ptr, R8 will be name backtrack
        MOV     R10,#0                  ;clear # used flag

        SUB     R1, R1, #1
10
        BL      NextChar
        MOVCS   R0, #0           ;replace terminators by 0, for name<wild check
        CMPS    R0, #MultiWildChar
        BEQ     %FT30
        BL      %FT50           ;R9=next name char
        Internat_CaseConvertLoad LR,Upper
        Internat_UpperCase  R0,LR
        CMPS    R0, #OneWildChar ;match ?
        MOVEQ   R10,#-1         ;note if # used
        CMPNES  R0, R9          ;match ?
        BEQ     %BT10           ;loop on match
        MOV     R4, R8          ;back track name
        MOVS    R1, R7          ;back track wild, and test if * used
        BNE     %FT30           ;if it was restart from backtrack
20
; not match, but was name < wild

; if wild cards force name < wild to continue dir search

        RSBS    LR, R7, #1      ; * used => C=0
        RSBCSS  LR, R10,#1      ; # used => C=0
        CMPCSS  R9, R0
 [ Debug6 :LAND: {FALSE}
        mess    LO,"name<wild",NL
        mess    HI,"name>wild",NL
 ]
        Pull    "R0,R1,R4,R6-R11,PC"

30
        MOV     R7, R1          ;Wild backtrack ptr -> wild card
        BL      NextChar        ;Next wild
        MOVCS   R0, #0          ;replace terminators by 0, for wild<name check
        CMPS    R0, #MultiWildChar
        BEQ     %BT30           ;deal with **
        Internat_CaseConvertLoad LR,Upper
        Internat_UpperCase  R0,LR
40
        BL      %FT50           ;R9=next name char
        CMPS    R0, #OneWildChar ;match ?
        MOVEQ   R10,#-1         ;note if # used
        CMPNES  R0, R9          ;match ?
        BNE     %BT40
        MOV     R8, R4          ;name backtrack ptr -> char after match
        B       %BT10           ;loop

50
;get name char
        LDRB    R9, [R4],#1
        AND     R9, R9, R5      ;maybe mask out bit 7
        Internat_CaseConvertLoad R11,Upper
        Internat_UpperCase  R9,R11
        CMPS    R9, #" "+1      ;name terminated by control code ?
        MOVLO   R9, #0          ;replace terminators by 0, for wild<name check
        CMPHS   R6, R4          ;name terminated by length ?
        MOVHSS  PC, LR          ;name not terminated
        MOVLO	R9, #0		;terminator of 0 if name terminated
        
;name terminated, has wildcard ?
        CMPS    R0, #DelimChar
        BLNE    ThisChar
        BCS     %FT60           ;match

	LDR	lr, [sp, #2*4]
	SUB	lr, r4, lr
	CMP	lr, #BigDirMaxNameLen
	BLO	%BT20		;mismatch if not reached max name length
	
        ; Check if Truncate is configured
        LDRB    lr, Flags
        TST     lr, #TruncateNames
        BNE     %BT20           ;mismatch if barf on truncate names

        ; Now check if wildcard has terminated based on length
        LDR     lr, [sp, #1*4]  ; R1 in
        SUB     lr, r1, lr
        CMP     lr, #BigDirMaxNameLen
        BLO     %BT20           ; finished short of BigDirMaxNameLen

        ; Drop through to match situation
60
        CMPS    R0, R0          ;set equal C=1,Z=1
 [ Debug6 :LAND: {FALSE}
        mess    ,"name=wild",NL
 ]
        Pull    "R0,R1,R4,R6-R11,PC"

 ]
a1194 1

d1203 1
a1203 1
 [ Debug6  :LAND: {FALSE}
a1218 1

a1320 4
 [ BigDir
 	BL	TestBigDir
 	BEQ	%FT10
 ]
a1340 17
 [ BigDir
10
        TEQS    R4, #0
        ; For root object set load for type of disc
        ; Use EOR in case types extend in the future
        BLEQ    DiscAddToRec
        LDREQ   LR, [LR, #DiscType]
        MOV     LR, LR, LSL #8
        EOREQ   LR, LR, #&ff000000
        EOREQ   LR, LR, #&00f00000
        LDRNE	LR, [R4, #BigDirLoad]
 [ Debug6
        DREG    LR, " ", cc
        DLINE   "= load add"
 ]
        Pull    "R0,PC",,^
 ]
a1353 4
 [ BigDir
 	BL	TestBigDir
 	BEQ	%FT10
 ]
a1363 11
 [ BigDir
10
        TEQS    R4, #0
        MOVEQ   LR, #0
	LDRNE	LR, [R4, #BigDirExec]
  [ Debug6
        DREG    LR, " ", cc
        DLINE   "= exec add"
  ]
        Pull    "R0,PC",,^
 ]
a1379 28
  [ BigDir
  	; check if is big dirs
  	BL	TestBigDir
  	BNE	%FT05
  	; big dirs
  	
  	TEQS	R4, #0
  	LDREQ	LR, [LR, #RootDirSize]
  	LDRNE	LR, [R4, #BigDirLen]
   [ Debug6
        BEQ     %FT01
        DREG    LR, " ", cc
        DLINE   "= file len"
01
   ]
        Pull    "R0,PC",NE,^

	; big dir, but root object.  read root length from disc record  	
  	BL	DiscAddToRec	;(R3->LR)
  	LDR	LR, [LR, #RootDirSize]
  [ Debug6
  	DREG	LR, " ",cc
  	DLINE	"= file len"
  ]
  	Pull	"R0,PC",,^
  	
05
	; not big dirs
d1383 1
a1383 1
   [ Debug6
d1388 1
a1388 16
   ]
        Pull    "R0,PC",NE,^
        
        
  |
  
  
        TEQS    R4, #0
        ADDNE   R0, R4, #DirLen
        BLNE    ReadWord
   [ Debug6
        BEQ     %FT01
        DREG    LR, " ", cc
        DLINE   "= file len"
01
   ]
a1389 1
  ]
a1451 8
  [ BigDir
  	BL	TestBigDir
  	BNE	%FT01
  	
  	LDR	LR, [R4, #BigDirIndDiscAdd]
  	
  	B	%FT02
01
a1455 7
02
  |
        BL      TestMap                 ;(R3->Z)
        ADD     R0, R4, #DirIndDiscAdd
        BL      Read3
        MOVNE   LR, LR, LSL #8
  ]
a1503 5
 [ BigDir
 	BL	TestBigDir
 	LDREQB	LR, [R4, #BigDirAtts]
 	BEQ	%FT20
 ]
a1592 4
 [ BigDir
 	BL	TestBigDir		;(R3->Z)
 	BEQ	%FT10
 ]
a1604 8
 [ BigDir
10
 	BL	ReadLoad		;(R3,R4->LR)
 	TEQS	R0,LR			;nothing to do if changed
 	BLNE	InvalidateBufDir
 	STRNE	R0, [R4, #BigDirLoad]
 	Pull	"R0-R1,PC",,^
 ]
a1620 4
 [ BigDir
 	BL	TestBigDir
 	BEQ	%FT10
 ]
a1628 8
 [ BigDir
10
        BL      ReadExec                ;(R4->LR)
        TEQS    R0,LR                   ;nothing to do if unchanged
        BLNE    InvalidateBufDir
	STRNE	R0, [R4, #BigDirExec]
	Pull    "R0-R1,PC",,^	
 ]
a1644 4
 [ BigDir
 	BL	TestBigDir
 	BEQ	%FT10
 ]
a1652 8
 [ BigDir
10
        BL      ReadLen                 ;(R4->LR)
        TEQS    R0,LR                   ;nothing to do if unchanged
        BLNE    InvalidateBufDir
	STRNE	R0, [R4, #BigDirLen]
        Pull    "R0-R1,PC",,^
 ]
a1663 4
 [ BigDir
;  R5->dir start (only if dir is big)
 ]

a1675 7
 [ BigDir
 	BL	TestBigDir
 	STREQ	R1, [R4, #BigDirIndDiscAdd]
 	BLEQ	GetBigDirName		;(R4,R5->LR)
 	STREQ	R4, [LR, #-BigDirHeapObName+BigDirHeapIndDiscAdd]
 	BEQ	%FT95
 ]
a1732 5
 [ BigDir
 	BL	TestBigDir
	STREQB	R0, [R4,#BigDirAtts]	; write atts
        Pull	"R0-R2,R4,PC",EQ,^
 ]
d1750 1
a1775 3
 [ BigDir
; if dir is big, then R5->dir start
 ]
a1784 5
 [ BigDir
 	BL	TestBigDir
 	STREQ	R3, [R5, #BigDirParent]
 	Pull	"R0,R1,PC",EQ,^
 ]
a1859 1

a1879 8
 [ BigDir
 	BL	TestBigDir		; is it a big directory?
 	BNE	%FT01
 	BL	CheckBigDir		;(R3,R5,R6,R10->R0,V)
 	MOVVC	R0,#0
 	B	%FT95
01	; not a big dir
 ]
a1982 4
 [ BigDir
; R3 - dir ind disc add
 ]

a1983 1
 [ BigDir
a1984 2
        BL	TestBigDir
        BEQ	%FT01
a1989 14
01
        BL      InvalidateBufDir
        BL      NextDirSeqNum           ;(R5->LR)
        STRB    LR,[R5,#BigDirStartMasSeq]
        STRB    LR,[R6,#BigDirEndMasSeq]
        Pull    "PC",,^
 |
        Push    "LR"
        BL      InvalidateBufDir
        BL      NextDirSeqNum           ;(R5->LR)
        STRB    LR,[R5,#StartMasSeq]
        STRB    LR,[R6,#EndMasSeq]
        Pull    "PC",,^
 ]
a2023 3
 [ BigDir
 	ASSERT	BigDirStartMasSeq=StartMasSeq
 ]
a2076 5

 [ BigDir
;  R1 IF DIR IS BIG, R1->term
 ]

a2084 5
 [ BigDir
        BL	TestBigDir
        BLEQ	MakeBigDirSpace	;different code for when a big dir.  may corrupt R0-R2
        Pull	"R0-R2,PC",EQ,^
 ]
@


4.1.4.2
log
@Altered directory format (change backup dir entries to be one word instead
of an entire copy of the entry).  Also reduced size of a directory entry
by one word.  Also fixed a number of small bugs.
@
text
@d1261 5
a1265 5
 [ Debug6
        DLINE   "wild     name     mask - enter BigLexEqv"
        DREG    R1,"",cc
        DREG    R4," ",cc
        DREG    R5," "
d1305 3
a1307 7
 [ Debug6
 	BHI	%FT01
 	DLINE	"name<wild"
01
 	BLO	%FT01
 	DLINE	"name>wild"
01
d1364 2
a1365 2
 [ Debug6
        DLINE   "name=wild"
d2006 2
@


4.1.4.3
log
@Now supports formatting of floppies with long file names.
@
text
@d1619 1
a1619 1
        DLINE   "= file len, from big dir"
a1625 14
  	
        LDRB    R0, [LR, #DiscFlags]
        TST     R0, #DiscNotFileCore

        ; Contents of non-filecore disc
        LDRNE   LR, [LR, #DiscSize]
  [ Debug6
        BEQ     %FT01
        DREG    LR, " ", cc
        DLINE   "= file len, from DiscSize"
01
  ]
        Pull    "R0,PC",NE,^
  	
d1629 1
a1629 1
  	DLINE	"= file len, from RootDirSize"
d1641 1
a1641 1
        DLINE   "= file len, from DirLen"
d1672 1
a1672 1
        DLINE   "= file len, from DiscSize"
a1680 5

  [ Debug6
        DREG    LR, " ", cc
        DLINE   "= file len, from New/OldDirSize"
  ]
@


4.1.4.4
log
@Binary-chop dir scanning fixed.  (BigLexEqv fixed so that it doesn't
try to compare the dir separator '.' in eg "Default.Thing" with another
object called "Default+" (was breaking binary chop dir search).

Fixed IdentifyDisc (s.Identify); old behaviour left the RootDir field
invalid (the disc bits were an external drive number, instead of an
internal disc number).  This causes problems if the disc fails to mount
due to, for example, memory problems, as the illegal value never gets
fixed (normally, MountDiscOnDrive would end up correcting the problem).
@
text
@d553 1
a553 1

d619 1
a619 1

d709 1
a709 1

d717 1
a717 1

a808 4
 [ Debug6f
	DLINE	"It's a drive number, going to WhatDisc the drive"
 ]

a1284 2
	TEQS	R0, #DelimChar
	MOVEQ	R0, #0		; delimiters must be replaced by 0 too
a1318 2
	TEQS	R0, #DelimChar
	MOVEQ	R0, #0		;delimiters must be replaced by 0 too
a1337 2
	TEQS	R9, #DelimChar
	MOVEQ	R9, #0
d1343 1
a1343 1

a1345 1
	CMPNE	R0, #0
d1353 1
a1353 1

d1612 1
a1612 1

d1624 1
a1624 1
	; big dir, but root object.  read root length from disc record
d1626 1
a1626 1

d1639 1
a1639 1

d1646 1
a1646 1

d1659 2
a1660 2


d1662 2
a1663 2


d1745 1
a1745 1

d1747 1
a1747 1

d1961 1
a1961 1
	Pull    "R0-R1,PC",,^
d2258 1
a2258 1
        baddr   R1, HugoNick
@


4.1.4.5
log
@Fixed 4 bugs in DoOsFunRenameBigDir involving renameing of objects
between dirs with long filenames.

Fixed bug in OsFunResolveWildcard on long filenames.
@
text
@d97 1
a97 1
 [ Debug6 ;:LOR: DebugXr
d2551 1
a2551 1
 [ Debug6 ;:LOR: DebugXr
d2564 1
a2564 1
 [ Debug6 ;:LOR: DebugXr
@


4.1.4.6
log
@Fixed parent directory handling for big dirs (was filling in the Disc part
of the field, which should be left as 0000s because the value of the disc
changes over time).

Further fix for ADFSBuffers (illegal pointer accessing) as it was found that
the previous fix wasn't good enough.  New fix appears to work where previous
failed.
@
text
@a713 1
	BICEQ	R3, R3, #DiscBits
d2160 1
a2160 2
	BICEQ	R1, R3, #DiscBits
 	STREQ	R1, [R5, #BigDirParent]
@


4.1.4.7
log
@Now uses new Ursula service call mechanism.
@
text
@d97 1
a97 1
 [ Debug6 :LOR: DebugXd ;:LOR: DebugXr
d592 3
d1266 1
a1266 1
 [ DebugX
d1312 1
a1312 1
 [ DebugX
d1380 1
a1380 1
 [ DebugX
@


4.1.4.8
log
@  Merge of ROL branch to the Ursula branch.
Admin:
  Lots of bugfixes - see ROL branch logs for details.
@
text
@a18 3
			GBLL	FixTruncateOnBigDiscs
FixTruncateOnBigDiscs	SETL	T

a223 1
 [ :LNOT: FixTruncateOnBigDiscs
a227 1
 ]
a241 2

 [ :LNOT: FixTruncateOnBigDiscs
a244 1
 ]
a553 1

a557 3
 [ FixTruncateOnBigDiscs
	BL	%FT99		; check the name length
 ]
a677 29

 [ FixTruncateOnBigDiscs
99	; check name length
	; r7 = ptr to name
	; if name is invalid then set r0 to error ptr,
	; Pull r0-r2 and jump to 95
	Push	"r0,r7,lr"

	LDRB    R0, Flags
        TST     R0, #TruncateNames
	Pull	"r0,r7,pc",EQ

	MOV	lr,r7
00	LDRB	r0,[r7],#1
	TEQ	r0,#127
	TEQNE	r0,#'.'
	BEQ	%FT01
	CMP	r0,#' '
	BGT	%BT00
01	SUB	r0,r7,lr
	CMP	r0,#NameLen+1
	Pull	"r0,r7,pc",LE

	Pull	"r0,r7,lr"
	Pull	"r0,r1,r2"
	MOV	r0,#BadNameErr
	BL	SetVOnR0
	B	%BT95
 ]
@


4.1.4.7.4.1
log
@  Import of RISC OS Ltd version of FileCore.
Admin:
  These sources are imported for interest only and must NOT be merged
    without wide prior consultation.

Tagged as ROL_FileCore-3_20
@
text
@a18 3
			GBLL	FixTruncateOnBigDiscs
FixTruncateOnBigDiscs	SETL	T

a223 1
 [ :LNOT: FixTruncateOnBigDiscs
a227 1
 ]
a241 2

 [ :LNOT: FixTruncateOnBigDiscs
a244 1
 ]
a553 1

a557 3
 [ FixTruncateOnBigDiscs
	BL	%FT99		; check the name length
 ]
a677 29

 [ FixTruncateOnBigDiscs
99	; check name length
	; r7 = ptr to name
	; if name is invalid then set r0 to error ptr,
	; Pull r0-r2 and jump to 95
	Push	"r0,r7,lr"

	LDRB    R0, Flags
        TST     R0, #TruncateNames
	Pull	"r0,r7,pc",EQ

	MOV	lr,r7
00	LDRB	r0,[r7],#1
	TEQ	r0,#127
	TEQNE	r0,#'.'
	BEQ	%FT01
	CMP	r0,#' '
	BGT	%BT00
01	SUB	r0,r7,lr
	CMP	r0,#NameLen+1
	Pull	"r0,r7,pc",LE

	Pull	"r0,r7,lr"
	Pull	"r0,r1,r2"
	MOV	r0,#BadNameErr
	BL	SetVOnR0
	B	%BT95
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

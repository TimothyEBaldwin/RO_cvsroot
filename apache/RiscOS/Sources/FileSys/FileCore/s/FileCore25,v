head	4.13;
access;
symbols
	FileCore-3_75:4.13
	FileCore-3_74:4.13
	FileCore-3_73:4.12
	FileCore-3_72:4.12
	FileCore-3_71:4.12
	FileCore-3_70:4.12
	FileCore-3_69:4.12
	FileCore-3_68:4.12
	FileCore-3_67:4.12
	FileCore-3_66:4.12
	FileCore-3_65:4.12
	FileCore-3_64:4.12
	FileCore-3_63:4.12
	FileCore-3_62:4.12
	FileCore-3_61:4.12
	FileCore-3_60:4.12
	FileCore-3_59:4.12
	FileCore-3_58:4.12
	FileCore-3_57:4.12
	FileCore-3_56:4.11
	FileCore-3_55:4.11
	FileCore-3_54:4.10
	FileCore-3_53:4.10
	FileCore-3_52:4.10
	FileCore-3_51:4.10
	FileCore-3_50:4.10
	FileCore-3_49:4.10
	FileCore-3_48:4.10
	FileCore-3_47:4.10
	FileCore-3_46:4.10
	FileCore-3_45:4.10
	FileCore-3_44:4.9
	FileCore-3_43:4.9
	FileCore-3_42:4.9
	FileCore-3_41:4.8
	FileCore-3_40:4.8
	FileCore-3_39:4.8
	FileCore-3_38:4.7
	FileCore-3_37:4.7
	FileCore-3_36:4.7
	FileCore-3_35:4.7
	FileCore-3_34:4.7
	FileCore-3_33:4.7
	RO_5_07:4.7
	FileCore-3_32:4.7
	FileCore-3_31:4.6
	FileCore-3_30:4.6
	FileCore-3_29:4.6
	FileCore-3_28:4.6
	FileCore-3_25-4_9_2_2:4.6
	FileCore-3_27:4.6
	FileCore-3_26:4.6
	FileCore-3_22-4_6_2_1:4.3
	bavison_FileCore-3_22_dev_bp:4.3
	bavison_FileCore-3_22:4.3.0.2
	FileCore-3_25-4_9_2_1:4.6
	HAL:4.6.0.2
	FileCore-3_25:4.6
	FileCore-3_24:4.5
	FileCore-3_23:4.4
	dellis_autobuild_BaseSW:4.3
	FileCore-3_22:4.3
	Ursula_merge:4.1.4.5
	ROL_merge:4.1.4.5
	FileCore-3_21:4.3
	ROL_Ursula_merge:4.1.4.5
	Ursula_RiscPC_merge:4.1.4.5
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.6
	ROL_FileCore-3_21:4.1.4.5
	ROL_FileCore-3_20:4.1.4.5
	ROL:4.1.4.5.0.4
	ROL_bp:4.1.4.5
	Ursula_RiscPC_bp:4.1.4.5
	FileCore-3_18:4.1.4.5
	FileCore-3_01:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.5
	Ursula_RiscPC:4.1.4.5.0.2
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.1.4.5
	sproven_FileCore-3_16:4.1.4.5
	rthornb_UrsulaBuild-19Aug1998:4.1.4.5
	UrsulaBuild_FinalSoftload:4.1.4.5
	rthornb_UrsulaBuild-12Aug1998:4.1.4.5
	aglover_UrsulaBuild-05Aug1998:4.1.4.5
	rthornb_UrsulaBuild-29Jul1998:4.1.4.5
	rthornb_UrsulaBuild-22Jul1998:4.1.4.5
	rthornb_UrsulaBuild-15Jul1998:4.1.4.5
	rthornb_UrsulaBuild-07Jul1998:4.1.4.5
	rthornb_UrsulaBuild-17Jun1998:4.1.4.5
	rthornb_UrsulaBuild-03Jun1998:4.1.4.5
	rthornb_UrsulaBuild-27May1998:4.1.4.5
	rthornb_UrsulaBuild-21May1998:4.1.4.5
	sproven_FileCore-3_15:4.1.4.5
	sproven_314:4.1.4.5
	rthornb_UrsulaBuild_01May1998:4.1.4.5
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.5
	sproven_3_11:4.1.4.5
	sproven_3_10:4.1.4.5
	sproven_Ursula_3_09:4.1.4.4
	sproven_3_07:4.1.4.4
	sproven_3_06:4.1.4.3
	sproven_3_05:4.1.4.2
	sproven_3_04:4.1.4.2
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.2
	sproven_3_02:4.1.4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2017.06.16.11.00.36;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	izYr8Uu33U8FvAVz;

4.12
date	2013.03.25.20.31.08;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	vCGDXb1zgPQnidJw;

4.11
date	2013.02.21.16.53.07;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	CCuV2tngKttj75Fw;

4.10
date	2011.10.14.07.23.50;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	D2Id4aPp4zmuUhDv;

4.9
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	A9Zxco9ydo9FCOBv;

4.8
date	2011.08.04.20.43.10;	author jlee;	state Exp;
branches;
next	4.7;
commitid	zcIknvqdwARiCeuv;

4.7
date	2003.08.08.09.42.49;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2000.10.31.17.05.06;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.31.09.32.30;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.11.36.53;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.09.21.12.07.16;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.22.37;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.11.17.13.32.24;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.12.01.12.03.01;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.01.19.12.26.36;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.01.23.16.41.22;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.02.17.14.59.39;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.01;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.30.55;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Fixes in BigSectors option
Previous testing with RAMFS was limited by the size of RAM disc, and hence complexity of layout, meaning some cases with BigSectors were missed.
FileCore20.s: During mount, when loading the defect list from the boot block at &C00, take care to round down the source sector address to account for it only being aligned up to 1k sectors (but not for 2k and 4k).
FileCore25.s: When loading the head of a BigDir (to find out its actual size) and finding it to be > 2k, skip loading the bit from 2k-4k, since that was already loaded when the head was read in, and reading it a second time offset by 2k fails the head/tail check.
FileCore31.s: When building a table to decide which zones to compact, use FindBuffer() to get some temporary store if too large to fit into ScratchSpace.
Identify.s: Comment updated.
BigDirCode.s: (Unrelated) Fix for bad error pointer being passed back, due to R0 being restored on encountering an error during directory rename.

FSBashed for 300k cycles on Titanium with an assortment of manufacturer drives, capacities, and sector sizes.

Version 3.74. Tagged as 'FileCore-3_74'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >FileCore25

; ======
; GetDir
; ======

; gets directory into directory buffer ALLOWS ESCAPE AND TIMEOUT

; entry: R3 disc address of dir

; exit:  IF error V set, R0 result
;        R5 -> dir buffer, R6 -> byte after dir

GetDir
        Push    "R0-R4,R7-R11,LR"
 [ Debug6 :LOR: DebugXr
        DREG    R3, "GetDir "
 ]
        MOV     R10,#0  ;FindDir/GetDir Flag
        B       FindDirCommon


; =======
; FindDir
; =======

; given disc address of dir returns ptr to RAM copy, in dir buffer or cache
; ALLOWS ESCAPE AND TIMEOUT

; Calling FindDir will give parameters for the directory, unexpanded, in the cache
; if it was in the cache.

; entry: R3 disc address of dir

; exit:  IF error V set, R0 result
;        R5 -> dir, R6 -> byte after dir

FindDir ROUT
        Push    "R0-R4,R7-R11,LR"
 [ Debug6
        DREG    R3,"FindDir "
 ]
        MOV     R10,#1  ;FindDir/GetDir Flag

FindDirCommon
        SavePSR LR
        Push    "LR"
 [ DebugC
 BL     SanityCheckDirCache
 ]
        ; If disc isn't FileCore complain bitterly
        BL      DiscMustBeFileCore      ;(R3->V,R0)
        BVS     %FT95

 [ BigDir
        BL      TestBigDir              ; is it a big dir
        BNE     %FT01                   ; no, it's small
        MOV     R4, #0                  ; if it's a big dir, set r4 to 0 here to indicate that it's a variable size
        MOV     R9, #BigDirTailSize     ; size of big dir's tail
        B       %FT02                   ; skip the new/old dir test
01
        ; small dir
 ]
        ; Determine dir type (old/new) and set parameters in R4(size) and R9(DirLastMark)
        BL      TestDir    ;(R3->LR,Z)
        MOVEQ   R4, #NewDirSize
        MOVEQ   R9, #-NewDirLastMark
        MOVNE   R4, #OldDirSize
        MOVNE   R9, #-OldDirLastMark

        ; Set up R5(start) and R6(end) for DirBuffer
 [ BigDir
02
        ; if the dir is big then the value of r4 is 0, and r6 is the same
        ; as r5
        LDR     R5, DirBufferPtr
 |
        sbaddr  R5, DirBuffer
 ]
        ADD     R6, R4, R5

 [ Debug6 :LAND: :LNOT: BigDir          ; if BigDir then values not valid yet
        DREG    R5, "DirBuffer start, end:",cc
        DREG    R6, ","
 ]

 [ Debug6 :LAND: BigDir
        CMP     r4, #0
        BNE     %FT01

        DREG    R5, "DirBuffer start (end not known yet):"

        B       %FT02
01
        DREG    R5, "DirBuffer start, end:",cc
        DREG    R6, ","
02
 ]

 [ BigDir
        ; If BufDir matches, then if it's a big dir, set up r6
        LDR     LR, [SB,#:INDEX:BufDir]
        CMPS    R3,LR

        BNE     %FT03           ; dir doesn't match

        ; check for big dir
        CMP     r4, #0          ; r4 is 0 if it's a big dir as we don't know the size, yet
        BNE     %FT90           ; r4 is not 0, so we know it's a small dir - nothing else to do

        LDR     LR, [r5,#BigDirSize]
        ADD     R6, R5, LR

 [ Debug6
        DREG    R6, "DirBuffer end:"
 ]

        B       %FT90           ; dir is in DirBuffer

03      ; no match
 |
        ; If BufDir matches then no further work to do
        LDR     LR, [SB,#:INDEX:BufDir]
        CMPS    R3, LR
        BEQ     %FT90           ;V=0
 ]

        ; Different operation on find/get dir
        MOVS    R10,R10
        BEQ     %FT05           ;if GetDir

        ; FindDir - if found in cache set up parameters for dir in the cache,
        ; otherwise drop through to the getdir case
        BL      TryCache        ;(R3->R11,V)
        ADDVC   R5, R11,#CacheBody
        LDRVC   R6, [R11,#CacheNext]
        ADDVC   R6, SB, R6
        BVC     %FT90           ;If FindDir and in cache

05
 [ WriteCacheDir
        CLRV
 ]
        ; GetDir or failed to FindDir in cache - cache the dir in dirbuf, keeping
        ; directory R3 around.
        BL      TryCacheDirBuf  ;(R3)

 [ WriteCacheDir
        BVS     %FT95           ;if failed to dump cached dir
 ]

        ; Different operation on find/get dir
        MOVS    R10,R10
        BNE     %FT65           ;FindDir

        ; GetDir
        ; if we find the dir in the cache
        BL      TryCache        ;(R3->R11,V)
        BVS     %FT65           ;not cached

        ; COPY DIR BODY
        ADD     R0, R11,#CacheBody
        MOV     R1, R5
        LDR     R8, [R11,#CacheNext]
        ADD     R8, SB, R8
        SUB     R7, R8, R0      ;size cached dir
        SUB     R2, R7, R9      ;size cached dir excluding tail
        BL      BlockMove       ;(R0,R1,R2)

 [ BigDir
        ; R4 needs set up
        CMP     R4, #0
        BNE     %FT01
        LDR     r4, [R5, #BigDirSize]   ; size of the big dir...
        ADD     R6, R5, R4
  [ Debug6
        DREG    r4, "From cached big dir, size is:"
  ]
01
 ]

        ; FILL MIDDLE WITH ZEROES
        ADD     R0, R1, R2
        SUB     R1, R4, R7      ;amount less than full size
        BL      ZeroRam         ;(R0,R1)

        ; COPY DIR TAIL
        SUB     R0, R8, R9
        SUB     R1, R6, R9
        MOV     R2, R9
        BL      BlockMove       ;(R0,R1,R2)

        ; Remove the directory from the cache
        BL      LockDirCache
        BL      RemoveCacheDir  ;(R11) remove cache copy first
        BL      ValidateDirCache
        BL      UnlockDirCache
        B       %FT85

65
        ; Failed to find directory we want in the cache so
        ; read dir to buffer at R5
        MOV     R7, R3          ;save dir disc address
        MOV     R8, R5          ;save dir buffer ptr

  [ BigDir
        ; if it's big dir, then things get a lil' harder

        CMP     R4, #0
        BNE     %FT70

        MOV     R4, #BigDirMinSize      ; get the first 2048 bytes

        ADD     r6,r4,r5                ; end

  [ Debug6
        DREG    r5, "Going to read first part of dir to start, end:",cc
        DREG    r6, ","
  ]
        ; it's a big dir.  method is to read the first 2048 bytes,
        ; then read the rest

        MOV     R1, #DiscOp_ReadSecs ;ALLOW ESCAPE AND TIMEOUT
        MOV     R2, R3
        MOV     R3, R5
        MOV     R5, #0          ;start from the beginning
        BL      GenIndDiscOp    ;(R1-R4->R0,R3-R5,V)
        BVS     %FT95

        ; have first part of dir in DirBuf

        ; now check a few things

        MOV     R5, R8
        BL      SanityCheckBigDirHeader         ; (R5->R0,V)
        BVS     %FT95                           ; broken dir!

 [ DebugX
        DLINE   "Dir was OK"
 ]

        ; now we can try reading the rest

        LDR     r4, [r5,#BigDirSize]            ; size of dir

        LDR     LR, DirBufferSize               ; check the current size of DirBuf
        CMP     R4, LR
        BLS     %FT66                           ; dir buf is too small

        BL      TryGrowDirBuf                   ; (R4->R0,V)
        BVS     %FT95                           ; couldn't grow it

66

        MOV     r5, #BigDirMinSize              ; start offset
      [ BigSectors
        MOV     lr, r7, LSR #(32-3)
        DiscRecPtr lr, lr
        LDRB    lr, [lr, #DiscRecord_Log2SectorSize]
        MOV     r5, r5, LSR lr
        MOV     r5, r5, LSL lr                  ; round down to nearest sector for DiscOp
        MOV     r3, r3, LSR lr
        MOV     r3, r3, LSL lr                  ; round dir buf offset similarly
      ]
        SUBS    r4, r4, r5                      ; amount of data to read


        BEQ     %FT67                           ; nothing more to read

 [ Debug6
        DREG    r5, "Going to read remainder of dir to start, end:",cc
        DREG    r6, ","
 ]

        BL      GenIndDiscOp                    ; read the rest of dir

67
        MOV     R5, R8
        MOV     R3, R7          ;restore dir disc add
        LDR     r4, [r5, #BigDirSize]
        ADD     r6, r5, r4

        B       %FT80
70
  ]

 [ Debug6
        DREG    R5, "Going to read dir to start, end:",cc
        DREG    R6, ","
 ]

        MOV     R1, #DiscOp_ReadSecs ;ALLOW ESCAPE AND TIMEOUT
        MOV     R2, R3
        MOV     R3, R5
        BL      IndDiscOp       ;(R1-R4->R0,R3-R5,V)
        BVS     %FT95
        MOV     R5, R8
        MOV     R3, R7          ;restore dir disc add

 [ BigDir
80
 ]

 [ Debug6
        DREG    R5, "After read DirBuffer start, end:",cc
        DREG    R6, ","
 ]

 [ BigDir
        BL      TestBigDir
        BEQ     %FT85
 ]
        BL      TestDir              ;(R3->LR,Z)
        BEQ     %FT85                   ;if new format
        BL      TestDirCheckByte        ;(R3,R5,R6->LR,Z)
        STRB    LR, [R6,#DirCheckByte]  ;set check byte if old format
85
        STR     R3, BufDir      ;validate dir buffer
90
 [ Debug6
        DREG    R5, "Checking dir: DirBuffer start, end:",cc
        DREG    R6, ","
 ]
        BL      CheckDir        ;check well formed (R3,R5,R6->R0,V)
95
        STRVS   R0, [SP, #4]    ;overwrite stacked R0
 [ Debug6
        DLINE   "start   |end     |result - leaving FindDir/GetDir"
        DREG    R5,,cc
        DREG    R6,,cc
        BVC     %FT01
        DREG    R0,,cc
01
        DLINE   ""
 ]
 [ DebugC
 BL     SanityCheckDirCache
 ]
        Pull    "R14"
        Pull    "R0-R4,R7-R11"
        B        PullLinkKeepV


; ========
; TryCache
; ========

; see if dir is in cache

; entry R3 = ind disc address of dir

; exit V=0 if found
;  R11 -> cache obj

TryCache ROUT
        Push    "R0,R1,LR"
 [ DebugC
        DREG    R3, "TryCache:"
 ]
        BL      LockDirCache
        BL      CheckDirCache
        sbaddr  R11,RootCache
        MOV     R1, R11
10
        LDR     R11,[R11,#CacheOlder]
        ADD     R11,SB,R11
        TEQS    R11,R1
        BEQ     %FT20
        LDR     LR, [R11,#CacheDir]
        CMPS    LR, R3
        BNE     %BT10
                                 ;FOUND NOW MAKE YOUNGEST V=0
        BL      RemoveCacheDir          ;(R11)
        BL      ValidateDirCache
        BL      InsertCacheDir          ;(R11)

 [ DebugXm
        LDR     R0, FileBufsStart
        CMPS    R11, R0
        BLO     %FT01

        DREG     R0, "FileBufsStart: "
        DREG    R11, "Cache entry  : "
01
 ]
        B       %FT25
20
        BL      SetV
25
        BL      UnlockDirCache
 [ DebugC
        DREG    R3,,cc
        DREG    R11,,cc
        BVS     %FT01
        DLINE   "TryCache succeeded"
        B       %FT02
01
        DLINE   "Trycache failed"
02
 ]
        Pull    "R0,R1,PC"

 [ DebugC
; ===================
; SanityCheckDirCache
; ===================

; entry: nothing

; exit: info about trashed dirs in the cache displayed

SanityCheckDirCache ROUT
        Push    "r0-r12,LR"
        SavePSR r2
        Push    "r2"

        DLINE   "Sanity checking DirCache"

        MOV     r2, #0


        sbaddr  R11,RootCache
        MOV     R1, R11
10
        LDR     R11,[R11,#CacheOlder]
        ADD     R11,SB,R11
        TEQS    R11,R1
        BEQ     %FT20
        LDR     r3, [R11,#CacheDir]
 [ BigDir
        BL      TestBigDir
        BLNE    TestDir    ;(R3->LR,Z)
 |
        BL      TestDir    ;(R3->LR,Z)
 ]
        ADD     r5, r11, #CacheBody
        LDR     r6, [r11, #CacheNext]
        ADD     r6, r6, SB
        BL      CheckDir
        BVC     %BT10

        DREG    r3, "Cached dir is trashed: ",cc
        DREG    r5, " at ",cc
        DREG    r6, " to "

        ADD     r2, r2, #1

        BNE     %BT10

20
        ; Finished the cache
        TEQ     r2, #0
        BNE     %FT30
        DLINE   "DirCache clean"
        B       %FT40
30
        DREG    r2, "Total trashed dirs:"
40
        Pull    r2
        RestPSR r2,,f
        Pull    "r0-r12,pc"
 ]

 [ {FALSE}

; ===========
; CacheDirBuf
; ===========

; cache the dir in the buffer
; leaves dir buffer empty

CacheDirBuf ROUT
        Push    "R3,LR"
        MOV     R3, #-1         ;invalid dir address
        BL      TryCacheDirBuf
        Pull    "R3,PC"

 ]

; ==============
; TryCacheDirBuf
; ==============

; cache the dir in the buffer if it would not involve losing dir R3 from cache
; leaves dir buffer empty

TryCacheDirBuf ROUT
        Push    "R0-R11,LR"
        MOV     R7, R3          ;favoured directory
        LDR     R3, BufDir
 [ DebugC
        DREG    R3, "TryCacheDirBuf ",cc
        DREG    R7
 ]
        CMPS    R3, #-1
        BEQ     %FT95           ;buffer empty

 [ WriteCacheDir
; check if the dir buffer is dirty
        LDR     LR, BufDirDirty
        TSTS    LR, #BufDirDirtyBit
        BEQ     %FT01

  [ DebugCW
        DREG    R3, "Writing buffered dir "
  ]
        BL      WriteDir        ;if the buf dir is cached, sort it

        MOV     LR, #0
        STR     LR, BufDirDirty

        BVC     %FT01

        STR     R0, [SP]
        Pull    "R0-R11,PC"     ;error exit when writing bufdir
01
 ]

        BL      LockDirCache
 [ BigDir
        BL      TestBigDir
        BNE     %FT05

        LDR     R5, DirBufferPtr

        LDR     R4, [R5, #BigDirSize]
        ADD     R6, R4, R5
        MOV     R9, #BigDirTailSize
        B       %FT06

05      ; here if not a big dir
        BL      TestDir      ;(R3->LR,Z)
        MOVEQ   R4, #NewDirSize
        MOVEQ   R9, #-NewDirLastMark
        MOVNE   R4, #OldDirSize
        MOVNE   R9, #-OldDirLastMark
        LDR     R5, DirBufferPtr
        ADD     R6, R4, R5
06
 |
        BL      TestDir      ;(R3->LR,Z)
        MOVEQ   R4, #NewDirSize
        MOVEQ   R9, #-NewDirLastMark
        MOVNE   R4, #OldDirSize
        MOVNE   R9, #-OldDirLastMark
        sbaddr  R5, DirBuffer
        ADD     R6, R4, R5
 ]
 [ DebugC
        BL      CheckDir        ;(R3,R5,R6->R0,V)
        BVC     %FT01           ;don't cache bad dirs
 DLINE  "Dir trashed"
 CLRV
01
 ]
        BL      CheckDirCache
                         ;FIND END OF DIR CONTENTS, SO SIZE NEEDED KNOWN
 [ BigDir
        BL      TestBigDir
        BNE     %FT07

        ; big dir

        LDR     R8, [R5, #BigDirNameLen]
        ADD     R8, R8, #4+BigDirHeaderSize     ; header, name and tail
        BIC     R8, R8, #3
        LDR     LR, [R5, #BigDirEntries]

        ASSERT  BigDirEntrySize=28
        RSB     LR, LR, LR, LSL #3      ; *7
        ADD     R8, R8, LR, LSL #2      ; *7*4=28

        LDR     LR, [R5, #BigDirNamesSize]
        ADD     R8, R8, LR                      ; size for dir body
        ADD     R8, R8, #3
        BIC     R8, R8, #3
        ADD     R4, R8, R9
; [ DebugXm
;       DREG    R4, "dir size: "
; ]
        B       %FT08

07
        ; not big dir
        BL      EndDirEntries   ;(R3,R5,R6->R0)
        SUB     R8, R0, R5      ;size for dir body
        ADD     R4, R8, R9      ;add size for dir tail
        ANDS    LR, R4, #3      ;ensure length is whole number of words
        RSBNE   LR, LR, #4
        ADDNE   R4, R4, LR

08
 |
        BL      EndDirEntries   ;(R3,R5,R6->R0)
        SUB     R8, R0, R5      ;size for dir body
        ADD     R4, R8, R9      ;add size for dir tail
        ANDS    LR, R4, #3      ;ensure length is whole number of words
        RSBNE   LR, LR, #4
        ADDNE   R4, R4, LR
 ]
        ADD     R4, R4, #CacheBody;add cache overhead
        Push    "R8,R9"
                         ;LOOK FOR SMALLEST SPACE BIG ENOUGH
10
 [ DebugC
        DREG    R4, "Size needed in cache "
 ]
        MOV     R9, #-1         ;rogue smallest length big enough
        sbaddr  R11,DirCache
15
        LDR     LR, [R11,#CachePriority]
        TEQS    LR, #0
        BNE     %FT25           ;not a free space
        MOV     R10,R11
20                              ;spaces are rejoined when searching for
        LDR     R10,[R10,#CacheNext]    ;a space, not when space returned
        ADD     R10,SB, R10
        LDR     LR, [R10,#CachePriority]
        TEQS    LR, #0
        BEQ     %BT20           ;another space

        SUB     LR, R10,SB
        STR     LR, [R11,#CacheNext]
        SUB     R10,R10,R11
        SUBS    LR, R10,R4
 [ DebugC
        DREG    R11,"size=",cc
        DREG    R10," size=",cc
        DREG    LR," extra="
 ]
 [ DebugC
;        BNE     %FT01
;        DLINE   "exact cache fit"
 ]
        BEQ     %FT65           ;exact match
        CMPHSS  LR, #CacheMin
        CMPHSS  R9, R10
        MOVHS   R9, R10         ;if best so far note length
        MOVHS   R8, R11         ;and position
25
        LDR     R11,[R11,#CacheNext]
        ADDS    R11,SB, R11
        BPL     %BT15           ;loop until all objects examined

        CMPS    R9, #-1
        BNE     %FT60           ;gap big enough found

 [ DebugC
        DLINE   "need to free space in cache"
 ]

                        ;HERE CONSIDER RETURNING SPACE FROM FILE CACHE
        LDRB    R9, Interlocks
        ORR     LR, R9, #FileCacheLock
        STRB    LR, Interlocks

        ASSERT  FileBufsEnd = FileBufsStart + 4
        sbaddr  R11,FileBufsStart
        LDMIA   R11,{R11,LR}
        CMPS    R11,LR
        BHS     %FT29           ;no space allocated to file cache

        BL      LessValid
        LDRB    LR, [R11,#BufPriority]
        TEQS    LR, #0
        BEQ     %FT26                   ;first buffer is empty
        LDR     LR, [R11,#BufFcb]
        LDR     LR, [LR, #FcbExtHandle]
        TEQS    LR, #0
        BNE     %FT28                   ;first buffer is allocated to open file
        BL      UnlinkFileChain         ;(R11)
26
        BL      UnlinkAllocChain        ;(R11)
        ADD     R10,R11,#1*K+BufferData
        STR     R10,FileBufsStart
        LDRB    LR, UnclaimedFileBuffers
        ADD     LR, LR, #1
        STRB    LR, UnclaimedFileBuffers
        MOV     LR, #bit31
        MOV     R8, #bit31
        STMDB   R10!,{R8,LR}
        SUB     R8, R10,SB
        MOV     LR, #0
        STMDB   R11,{R8,LR}
28
        BL      MoreValid
29
        STRB    R9, Interlocks

 [ DebugC
        DLINE   "assign priorities to cache dirs ...",cc
 ]

        sbaddr  R11,RootCache   ;assign priority values to all cached dirs
        MOV     R10,R11
        MOV     R9, #1 :SHL: 31 ;high priority value for favoured dir
        MOVS    LR, #0
        B       %FT35
30
        ADD     LR, LR, #1
        LDR     R8, [R11,#CacheDir]
        TEQS    R8, R7
        STREQ   R9, [R11,#CachePriority]
        STRNE   LR, [R11,#CachePriority]
35
        LDR     R11,[R11,#CacheYounger]
        ADD     R11,SB, R11
        TEQS    R11,R10                 ;loop until back to root
        BNE     %BT30
 [ DebugC
        DLINE   " done"
 ]
                 ;now find desired space with min loss of priority
        sbaddr  R10,DirCache    ;start ptr
        MOV     R11,R10         ;end ptr
        MOV     R8, #-1         ;init min loss of priority
        MOV     R9, #0          ;init priority loss
40                                      ;increase end ptr until space required
        LDR     LR, [R11,#CachePriority]
        ADD     R9, R9, LR              ;total up priority cost
        LDR     R11,[R11,#CacheNext]
        ADDS    R11,SB, R11
        BMI     %FT50                   ;all options checked
        SUB     R1, R11,R10
 [ DebugC
        DREG    R10,"start=",cc
        DREG    R11," end=",cc
        DREG    R1," size=",cc
 ]
        SUBS    R1, R1, R4
 [ DebugC
        DREG    R1, " extra="
 ]
        CMPGTS  R1, #CacheMin
        BLT     %BT40
45                                      ;increase start ptr while enough space
        LDR     LR, [R10,#CacheNext]
        ADD     LR, SB, LR
 [ DebugC
        DREG    LR, "end=",cc
 ]
        SUB     LR, LR, R10
        SUBS    R1, R1, LR
 [ DebugC
        DREG    LR, " size=",cc
        DREG    R1, " extra="
 ]
        CMPGTS  R1, #CacheMin
        LDRGE   R2, [R10,#CachePriority] ;decrease priority cost accordingly
        SUBGE   R9, R9, R2
        ADDGE   R10,R10,LR
        BGE     %BT45

        CMPS    R9, R8          ;if priority cost is lower than best so far
        MOVLO   R8, R9          ;note cost
        MOVLO   R0, R10         ;and position
 [ DebugC
        DREG    R8, "best=",cc
        DREG    R9," fit=",cc
        DREG    R10," start=",cc
        DREG    R11," end="
 ]
        B       %BT40

50                      ;HERE WHEN ALL SPACE MAKING OPTIONS TRIED
        CMPS    R8, #1 :SHL: 31 ;IF caching dir in buffer would force uncaching
        Pull    "R8,R9",HS      ;of favoured dir, or no room
        BHS     %FT90           ;THEN dont cache it
        MOV     R11,R0
55                                      ;uncache chosen dirs
        LDR     LR, [R11,#CachePriority]
        TEQS    LR, #0
        BLNE    RemoveCacheDir          ;(R11)
        BLNE    ValidateDirCache
        LDR     R11,[R11,#CacheNext]
        ADD     R11,SB,R11
        SUB     LR, R11,R0
        SUBS    LR, LR, R4
        CMPGTS  LR, #CacheMin
        BLT     %BT55
 [ DebugC
        DLINE   "try again now cache space freed"
 ]
        B       %BT10           ;now try again, will succeed as enough now free

60                              ;HERE IF SPACE BIGGER THAN REQUIRED FOUND
        MOV     R11,R8
        ADD     R10,R11,R4              ;start of extra part
        LDR     LR, [R11,#CacheNext]    ;set up extra part as new obj
        STR     LR, [R10,#CacheNext]
        MOV     LR, #0
        STR     LR, [R10,#CachePriority]
        SUB     LR, R10,SB
        STR     LR, [R11,#CacheNext]    ;and amend desired part
65                              ;EXACT SPACE REJOINS HERE
        Pull    "R8,R9"
        MOV     R0, R5
        ADD     R1, R11,#CacheBody
 [ BigDir
        BL      TestBigDir              ; is it a big dir
        MOVEQ   R2, R8
        ADDNE   R2, R8, #1
 |
        ADD     R2, R8, #1              ;copy dir body and terminating zero
 ]
 [ DebugXm
        ADD     R1, R1, R2
        LDR     LR, FileBufsStart
        CMPS    R1, LR
        BLE     %FT01

        DREG    R1, "end of copy after FileBufsStart: "
01
        SUB     R1, R1, R2
 ]

        BL      BlockMove               ;(R0,R1,R2)

        SUB     R0, R6, R9              ;copy dir tail to cache
        ADD     R1, R11,R4
        SUB     R1, R1, R9
        MOV     R2, R9
 [ DebugXm
        ADD     R1, R1, R2
        LDR     LR, FileBufsStart
        CMPS    R1, LR
        BLE     %FT01

        DREG    R1, "end of copy after FileBufsStart: "
01
        SUB     R1, R1, R2
 ]

        BL      BlockMove

        BL      InvalidateBufDir        ;to avoid possibility of same dir in
        STR     R3, [R11,#CacheDir]     ;buffer and cache, buffer must be
        BL      InsertCacheDir          ;invalidated first
90
        BL      UnlockDirCache
        BL      InvalidateBufDir
95
 [ DebugC
 BL     SanityCheckDirCache
 ]
        CLRV
        Pull    "R0-R11,PC"


; =============
; CheckDirCache
; =============

; If cache validity flag is clear reinitialise cache
; dir cache must be locked

CheckDirCache ROUT
        Push    "R0-R1,LR"
        LDRB    LR, Flags
        ANDS    LR, LR, #CacheGood
        BNE     %FT95
 [ DebugC
        DLINE   "Reinitialise cache"
 ]
        MOV     R0, #:INDEX:RootCache   ;init root of dual linked list
        STR     R0, RootCache+CacheYounger
        STR     R0, RootCache+CacheOlder
        sbaddr  R0, DirCache            ;create single free space obj
        STR     LR, [R0,#CachePriority] ;LR=0
        LDR     R1, FileBufsStart
        SUB     R1, R1, #CacheMin       ;->rogue end obj
        SUB     LR, R1, SB
        STR     LR, [R0,#CacheNext]
        MOV     LR, #1 :SHL: 31         ;create rogue end of cache obj
        STR     LR, [R1,#CacheNext]
        STR     LR, [R1,#CachePriority]
        BL      ValidateDirCache
95
        Pull    "R0-R1,PC"


; ==============
; RemoveCacheDir
; ==============

; entry R11 -> cache entry
; leaves dir cache invalid

RemoveCacheDir ROUT
        Push    "R0-R3,LR"
        SavePSR R3
 [ DebugC
        LDR     R0,[R11,#CacheDir]
        DREG    R0, "RemoveCacheDir ",cc
        DREG    R11
 ]
        LDR     R0, [R11,#CacheYounger]
        ADD     R1, SB, R0
        LDR     R2, [R11,#CacheOlder]
        BL      InvalidateDirCache
        ADD     LR, SB, R2
        STR     R0, [LR,#CacheYounger]
        STR     R2, [R1,#CacheOlder]
        MOV     LR, #0
        STR     LR, [R11,#CachePriority]
        RestPSR R3,,f
        Pull    "R0-R3,PC"



; ==============
; InsertCacheDir
; ==============

; entry R11 -> cache entry

InsertCacheDir ROUT
        Push    "R0-R3,LR"
        SavePSR r0
        Push    r0
 [ DebugC
        LDR     R0, [R11,#CacheDir]
        DREG    R0,"InsertCacheDir ",cc
        DREG    R11
 ]
        MOV     R0, #:INDEX:RootCache
        ADD     R1, SB, R0
        LDR     R2, [R1,#CacheOlder]
        ADD     R3, SB, R2
        BL      InvalidateDirCache
        SUB     LR, R11, SB
        STR     R0, [R11,#CacheYounger]
        STR     R2, [R11,#CacheOlder]
        STR     LR, [R1,#CacheOlder]
        STR     LR, [R3,#CacheYounger]
        STR     R11,[R11,#CachePriority];restore non zero priority
        BL      ValidateDirCache
        Pull    R0
        RestPSR R0,,f
        Pull    "R0-R3,PC"


; ===========
; UnCacheDisc
; ===========

; Remove all directories of given disc from cache

; entry: R0 = disc rec num

UnCacheDisc ROUT
 [ DebugC
        DREG    R0,"UnCacheDisc"
 ]
        Push    "R0,R1,R11,LR"
        LDRB    LR, Flags               ;don't re init cache as used by buffer
        TSTS    LR, #CacheGood          ;for single drive backup
        BEQ     %FT95
        MOV     R0, R0, LSL #(32-3)
        sbaddr  R11,RootCache
        MOV     R1, R11
        B       %FT20
10
        LDR     LR, [R11,#CacheDir]
        EOR     LR, LR, R0
        ANDS    LR, LR, #DiscBits
        BLEQ    RemoveCacheDir  ;(R11)
        BLEQ    ValidateDirCache
20
        LDR     R11,[R11,#CacheOlder]
        ADD     R11,SB,R11
        TEQS    R11,R1
        BNE     %BT10
95
        Pull    "R0,R1,R11,PC"

; ==================
; InvalidateDirCache
; ==================

InvalidateDirCache ROUT
        Push    "LR"
        LDRB    LR, Flags
        BIC     LR, LR, #CacheGood
        STRB    LR, Flags
        Pull    "PC"


; ================
; ValidateDirCache
; ================

ValidateDirCache ROUT
        Push    "LR"
        LDRB    LR, Flags
        ORR     LR, LR, #CacheGood
        STRB    LR, Flags
        Pull    "PC"


; ============
; LockDirCache
; ============

LockDirCache
        Push    "LR"
 [ DebugC :LOR: DebugG
        DLINE   "LockDirCache"
 ]
        LDRB    LR, Interlocks
        ORR     LR, LR, #DirCacheLock
        STRB    LR, Interlocks
        Pull    "PC"


; ==============
; UnlockDirCache
; ==============

UnlockDirCache
        Push    "LR"
 [ DebugC :LOR: DebugG
        DLINE   "UnlockDirCache"
 ]
        LDRB    LR, Interlocks
        BIC     LR, LR, #DirCacheLock
        STRB    LR, Interlocks
        Pull    "PC"


; ===============
; ExtendFileCache
; ===============

;entry FileCache must be claimed
;exit If could extend FileCache by one buffer NE and R11 -> buffer

ExtendFileCache
        Push    "R0-R4,R8,R10,LR"
 [ DebugXm
;       DLINE   "ExtendFileCache"

 ]
        WritePSRc I_bit :OR: SVC_mode, R0       ;disable IRQ
        LDRB    R0, Interlocks
        EOR     R0, R0, #DirCacheLock
        TSTS    R0, #DirCacheLock
        LDRNEB  LR, Flags
        TSTNES  LR, #CacheGood
 [ No32bitCode
        TEQEQP  PC, #Z_bit :OR: SVC_mode        ;if EQ reenable IRQ maintaining Z=1
 |
        CLRPSR  I_bit, LR, EQ
 ]
        BEQ     %FT55
        STRB    R0, Interlocks  ;lock dir cache
        WritePSRc SVC_mode, R8  ;reenable IRQ
        LDR     R8, FileBufsStart
        SUB     R8, R8, #1*K
        SUB     R8, R8, #BufferData+CacheMin
 [ DebugC :LOR: DebugG
        DLINE   ">ExtendFileCache - lock dir cache"
        DREG    R8, "new LWM="
 ]
00
;LOOP TO FIND LAST DIR IN CACHE
        sbaddr  R11,RootCache
        MOV     R10,R11
        MOV     R0, R11
05
        LDR     R11,[R11,#CacheYounger]
        ADD     R11,SB, R11
        CMPS    R11,R0
        MOVHI   R0, R11
        TEQS    R11,R10
        BNE     %BT05

        TEQS    R0, R10
        sbaddr  R10,DirCache, EQ
        LDRNE   R10,[R0,#CacheNext]
        ADDNE   R10,SB, R10
        SUBS    LR, R8, R10
        CMPGTS  LR, #CacheMin
 [ DebugC :LOR: DebugG
        BLT     %FT01
        DREG    R10,"no obstructing dir "
        B       %FT02
01
        DREG    R0, "dir must be moved for extension ",cc
        DREG    R10
02
 ]
        BGE     %FT45

10
        LDRB    LR, ReEntrance  ;cant be done if foregound threaded in
        TEQS    LR, #0
        LDRNE   LR, ptr_IRQsema
        LDRNE   LR, [LR]        ;and entering from background
        TEQNES  LR, #0
        TOGPSR  Z_bit, LR
        BEQ     %FT50

        SUB     R2, R10,R0              ;dir size
 [ DebugC :LOR: DebugG
        DREG    R2,"dir size "
 ]

;LOOP TO FIND SMALLEST GAP SUITABLE TO MOVE DIR TO
        MOV     R3, #bit30      ;large +ve
        sbaddr  R11,DirCache
        B       %FT20

15
        LDR     R11,[R11,#CacheNext]
        ADDS    R11,SB, R11
        BMI     %FT30           ;dummy end obj
20
        LDR     LR, [R11,#CachePriority]
        TEQS    LR, #0
        BNE     %BT15           ;not a free space
        MOV     R10,R11
25
        LDR     R11,[R11,#CacheNext]
        ADD     R11,SB, R11
        LDR     LR, [R11,#CachePriority]
        TEQS    LR, #0
        BEQ     %BT25           ;another space

        SUB     LR, R11,SB
        STR     LR, [R10,#CacheNext]

        SUB     R4, R11,R10     ;gap length
        SUBS    LR, R4, R2
        CMPGTS  LR, #CacheMin
        CMPGES  R3, R4
        BLT     %BT20           ;gap wrong size

        SUBS    LR, R8, R11     ;If gap does not overlap extension
        CMPGTS  LR, #CacheMin
        MOVGE   R1, R10         ; note position
        MOVGE   R3, R4          ; note size
        B       %BT20

30
        TEQS    R3, #bit30
 [ DebugC :LOR: DebugG
        BEQ     %FT01
        DREG    R1,"gap big enough found ",cc
        DREG    R3
01
 ]
        BNE     %FT40

        sbaddr  R11,RootCache
        MOV     R10,R11
        MOV     R0, R11
35
        LDR     R11,[R11,#CacheYounger]
        ADD     R11,SB,R11

        LDR     R1, [R11,#CacheNext]
        ADD     R1, SB, R1
        SUB     R3, R1, R11     ;dir length
        SUBS    LR, R3, R2
        CMPGTS  LR, #CacheMin
38
        BLGE    RemoveCacheDir  ;(R11) leaves dir cache invalid
        BGE     %BT05

        CMPS    R11,R0
        MOVHI   R0, R11
        B       %BT35

40
        BL      InvalidateDirCache
        LDR     R11,[R1,#CacheNext]
        BL      BlockMove       ;(R0-R2) copy to new position
        ADD     R4, R1, R2      ;new dir end
        SUB     LR, R4, SB
        STR     LR, [R1,#CacheNext]
        TEQS    R2, R3
        ASSERT  CacheNext=0
        ASSERT  CachePriority=CacheNext+4
        MOV     LR, #0
        STMNEIA  R4,{R11,LR}                    ;gap header if spare fragment
        STR     LR, [R0,#CachePriority]         ;mark dir block free
        LDR     R0, [R1,#CacheYounger]          ;adjust links
        ADD     R0, SB, R0
        LDR     R2, [R1,#CacheOlder]
        ADD     R2, SB, R2
        SUB     R1, R1, SB
        STR     R1, [R0,#CacheOlder]
        STR     R1, [R2,#CacheYounger]
        BL      ValidateDirCache
        B       %BT00

45
        BL      InvalidateDirCache
        SUB     LR, R8, SB              ;adjust length of final gap
        STR     LR, [R10,#CacheNext]
        ASSERT  CacheNext=0                     ;build new dummy end
        ASSERT  CachePriority=CacheNext+4
        MOV     R11,#bit31
        MOVS    LR, #bit31                      ;also set NE
        STMIA   R8!,{R11,LR}
        STR     R8, FileBufsStart               ;update start
        MOV     R11,R8

50
        BL      ValidateDirCache
        BL      UnlockDirCache
55
 [ DebugC :LOR: DebugG
        BNE     %FT01
        DLINE   "extend failed"
        LDRB    LR, Flags
        DREG    LR, "Flags=",cc,Byte
        LDRB    LR, Interlocks
        DREG    LR, " Interlocks=",,Byte
        B       %FT02
01
        DREG    R11,,cc
02
        DLINE   "<ExtendFileCache"
 ]
        Pull    "R0-R4,R8,R10,PC"


; ================
; FormDirCheckByte
; ================

; entry
;  R5 -> dir start
;  R6 -> dir end
;  R7 -> dir tail

; exit  LR check byte, flags corrupt

FormDirCheckByte ROUT
        Push    "R0-R2,R5,R7,LR"
        ADD     R0, R5, #DirFirstEntry
        B       %FT05

; ================
; TestDirCheckByte
; ================

; entry
;  R3 ind disc add of dir
;  R5 -> dir start
;  R6 -> dir end

; exit
;  LR check byte
;  Z  clear if matches existing byte

TestDirCheckByte
        Push    "R0-R2,R5,R7,LR"
 [ BigDir
        BL      TestBigDir
        BNE     %FT01

        ; it's a big dir - call TestBigDirCheckByte
        BL      TestBigDirCheckByte
        B       %FT95
01
 ]
        BL      EndDirEntries                   ;(R3,R5,R6->R0)
        BL      TestDir                         ;(R3->LR,Z)
        ADDEQ   R7, R6, #NewDirLastMark+1       ;dir tail
        ADDNE   R7, R6, #OldDirLastMark+1
05
        BIC     R1, R0, #3
        MOV     R2, #0
10                              ;whole words before end of entries
        LDR     LR, [R5],#4
        EOR     R2, LR, R2,ROR #13
        TEQS    R5, R1
        BNE     %BT10
20                              ;odd bytes before end of entries
        LDRNEB  LR, [R5], #1            ;not first pass through loop
        EORNE   R2, LR, R2,ROR #13
        TEQS    R5, R0
        BNE     %BT20

        MOV     R5, R7
30                              ;odd bytes before at start of tail
        TSTS    R5, #3
        LDRNEB  LR, [R5],#1
        EORNE   R2, LR, R2, ROR #13
        BNE     %BT30

        ASSERT  DirCheckByte=-1         ;dont include last word as it contains
        SUB     R1, R6, #4              ;the check byte
40                              ;whole words in tail
        LDR     LR, [R5],#4
        EOR     R2, LR, R2,ROR #13
        TEQS    R5, R1
        BNE     %BT40

        EOR     R2, R2, R2, LSR #16     ;reduce to 8 bits
        EOR     R2, R2, R2, LSR #8
        AND     R2, R2, #&FF

        LDRB    LR, [R6,#DirCheckByte]  ;compare with old check byte
        TEQS    R2, LR
        MOV     LR, R2

 [ BigDir
95
 ]
        Pull    "R0-R2,R5,R7,PC"


; =============
; EndDirEntries
; =============

; Find the end of the list of entries in a dir

; entry
;  R3 ind disc add of dir
;  R5 -> dir start
;  R6 -> dir end

; exit
;  R0 -> first empty entry

EndDirEntries ROUT
 [ NewDirEntrySz=OldDirEntrySz
        Push    "R2,LR"
        BL      TestDir                 ;(R3->LR,Z)
        ADDEQ   R2, R6, #NewDirLastMark
        ADDNE   R2, R6, #OldDirLastMark
        ADD     R0, R5, #DirFirstEntry
        SUB     R0, R0, #NewDirEntrySz
10                              ;loop examining entries
        LDRB    LR, [R0,#NewDirEntrySz] !
        CMPS    LR, #0                  ;until null entry
        CMPNES  R0, R2                  ;or exhausted
        BLO     %BT10
        MOVHI   R0, R2
        Pull    "R2,PC"
 |
        Push    "R1-R2,LR"
        BL      TestDir                 ;(R3->LR,Z)
        MOVEQ   R1, #NewDirEntrySz
        MOVNE   R1, #OldDirEntrySz
        ADDEQ   R2, R6, #NewDirLastMark
        ADDNE   R2, R6, #OldDirLastMark
        ADD     R0, R5, #DirFirstEntry
        SUB     R0, R0, R1
10                              ;loop examining entries
        LDRB    LR, [R0,R1] !
        CMPS    LR, #0                  ;until null entry
        CMPNES  R0, R2                  ;or exhausted
        BLO     %BT10
        MOVHI   R0, R2
        Pull    "R1-R2,PC"
 ]

        LTORG
        END
@


4.12
log
@Reenable background transfer support when BigFiles is {TRUE}
BigDirCode.s: Retire BigDirFix switch, it wasn't actually a fix, it was more that the directory format was changed early in development, but there's no point keeping support for the prototype any more
FileCore45.s/FileCore25.s/FileCore31.s/FileCore35.s/DebugOpts.s: Retire BigDirFix
Defns.s: Shock addition of some comments
FileCore.s: Manual inclusion of CPU/Arch no longer needed
FileCore70.s: Crucially apply the same 1k dead band to the FileSwitch "write zeros" entry point, since it (along with Get/PutBytes) are the only places file offsets get passed
FileCore80.s: Lots of tedious and subtle boundary cases fixed
InitDieSvc.s: Removed the disabling switch
doc/BigDisc/ADFSBuffer: Detail what the BufFlags mean

Tested on ADFS (the only background-transferring filing system about) with LFAUs of 2k, 4k, 8k, 16k and bashing 65536 iterations.

Version 3.57. Tagged as 'FileCore-3_57'
@
text
@a219 12
 [ Debug6
  [ BigDir
        CMP     R4, #0
        BEQ     %FT01
  ]
        DREG    R5, "Going to read dir to start, end:",cc
        DREG    R6, ","
  [ BigDir
01
  ]
 ]

d226 1
a226 1
        MOV     R4, #NewDirSize         ; get the first 2048 bytes
d269 10
a278 1
        MOV     r5, #NewDirSize                 ; start offset
d301 5
@


4.11
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@a581 1
 [ BigDirFix
d585 1
a585 4
 |
        ASSERT  BigDirEntrySize=32
        ADD     R8, R8, LR, LSL #5
 ]
@


4.10
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d65 1
a65 1
        ; If disc isn't FileCore comlain bitterly
@


4.9
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d70 5
a74 5
 	BL	TestBigDir		; is it a big dir
 	BNE	%FT01			; no, it's small
 	MOV	R4, #0			; if it's a big dir, set r4 to 0 here to indicate that it's a variable size
 	MOV	R9, #BigDirTailSize	; size of big dir's tail
 	B	%FT02			; skip the new/old dir test
d76 1
a76 1
	; small dir
d88 3
a90 3
 	; if the dir is big then the value of r4 is 0, and r6 is the same
 	; as r5
 	LDR	R5, DirBufferPtr
d96 1
a96 1
 [ Debug6 :LAND: :LNOT: BigDir		; if BigDir then values not valid yet
d102 2
a103 2
 	CMP	r4, #0
 	BNE	%FT01
d105 1
a105 1
 	DREG	R5, "DirBuffer start (end not known yet):"
d107 1
a107 1
 	B	%FT02
d115 5
a119 9
 	; If BufDir matches, then if it's a big dir, set up r6
 	LDR	LR, [SB,#:INDEX:BufDir]
 	CMPS	R3,LR

 	BNE	%FT03		; dir doesn't match

 	; check for big dir
 	CMP	r4, #0		; r4 is 0 if it's a big dir as we don't know the size, yet
 	BNE	%FT90		; r4 is not 0, so we know it's a small dir - nothing else to do
d121 6
a126 2
 	LDR	LR, [r5,#BigDirSize]
 	ADD	R6, R5, LR
d129 1
a129 1
 	DREG	R6, "DirBuffer end:"
d132 1
a132 1
 	B	%FT90		; dir is in DirBuffer
d134 1
a134 1
03	; no match
d156 1
a156 1
	CLRV
d163 1
a163 1
	BVS	%FT95		;if failed to dump cached dir
d185 5
a189 5
 	; R4 needs set up
 	CMP	R4, #0
 	BNE	%FT01
 	LDR	r4, [R5, #BigDirSize]	; size of the big dir...
 	ADD	R6, R5, R4
d191 1
a191 1
  	DREG	r4, "From cached big dir, size is:"
d222 2
a223 2
  	CMP	R4, #0
  	BEQ	%FT01
d233 1
a233 1
  	; if it's big dir, then things get a lil' harder
d235 2
a236 2
  	CMP	R4, #0
  	BNE	%FT70
d238 1
a238 1
  	MOV	R4, #NewDirSize		; get the first 2048 bytes
d240 1
a240 1
	ADD	r6,r4,r5		; end
d243 2
a244 2
  	DREG	r5, "Going to read first part of dir to start, end:",cc
  	DREG	r6, ","
d246 2
a247 2
  	; it's a big dir.  method is to read the first 2048 bytes,
  	; then read the rest
d249 1
a249 1
        MOV     R1, #ReadSecsOp ;ALLOW ESCAPE AND TIMEOUT
d252 1
a252 1
        MOV	R5, #0		;start from the beginning
d258 1
a258 1
 	; now check a few things
d260 3
a262 3
 	MOV	R5, R8
 	BL	SanityCheckBigDirHeader		; (R5->R0,V)
 	BVS	%FT95				; broken dir!
d265 1
a265 1
 	DLINE	"Dir was OK"
d268 1
a268 1
 	; now we can try reading the rest
d270 1
a270 1
 	LDR	r4, [r5,#BigDirSize]		; size of dir
d272 3
a274 3
	LDR	LR, DirBufferSize		; check the current size of DirBuf
	CMP	R4, LR
	BLS	%FT66				; dir buf is too small
d276 2
a277 2
 	BL	TryGrowDirBuf			; (R4->R0,V)
 	BVS	%FT95				; couldn't grow it
d281 2
a282 2
 	MOV	r5, #NewDirSize			; start offset
 	SUBS	r4, r4, r5			; amount of data to read
d285 1
a285 1
 	BEQ	%FT67				; nothing more to read
d288 2
a289 2
 	DREG	r5, "Going to read remainder of dir to start, end:",cc
 	DREG	r6, ","
d292 1
a292 1
	BL	GenIndDiscOp			; read the rest of dir
d297 2
a298 2
        LDR	r4, [r5, #BigDirSize]
        ADD	r6, r5, r4
d300 1
a300 1
	B	%FT80
d304 1
a304 1
        MOV     R1, #ReadSecsOp ;ALLOW ESCAPE AND TIMEOUT
d322 2
a323 2
 	BL	TestBigDir
 	BEQ	%FT85
d390 3
a392 3
 	LDR	R0, FileBufsStart
 	CMPS	R11, R0
 	BLO	%FT01
d394 2
a395 2
 	DREG	 R0, "FileBufsStart: "
 	DREG	R11, "Cache entry  : "
d443 1
a443 1
 	BL	TestBigDir
d513 3
a515 3
	LDR	LR, BufDirDirty
	TSTS	LR, #BufDirDirtyBit
	BEQ	%FT01
d518 1
a518 1
	DREG	R3, "Writing buffered dir "
d520 1
a520 1
	BL	WriteDir	;if the buf dir is cached, sort it
d522 2
a523 2
	MOV	LR, #0
	STR	LR, BufDirDirty
d525 1
a525 1
	BVC	%FT01
d527 2
a528 2
	STR	R0, [SP]
	Pull	"R0-R11,PC"	;error exit when writing bufdir
d534 2
a535 2
 	BL	TestBigDir
 	BNE	%FT05
d537 1
a537 1
 	LDR	R5, DirBufferPtr
d539 4
a542 4
 	LDR	R4, [R5, #BigDirSize]
 	ADD	R6, R4, R5
 	MOV	R9, #BigDirTailSize
 	B	%FT06
d544 1
a544 1
05	; here if not a big dir
d550 1
a550 1
        LDR 	R5, DirBufferPtr
d572 2
a573 2
 	BL	TestBigDir
 	BNE	%FT07
d575 1
a575 1
 	; big dir
d577 4
a580 4
 	LDR	R8, [R5, #BigDirNameLen]
 	ADD	R8, R8, #4+BigDirHeaderSize	; header, name and tail
 	BIC	R8, R8, #3
 	LDR	LR, [R5, #BigDirEntries]
d583 3
a585 3
 	ASSERT	BigDirEntrySize=28
 	RSB	LR, LR, LR, LSL #3	; *7
 	ADD	R8, R8, LR, LSL #2	; *7*4=28
d587 2
a588 2
 	ASSERT	BigDirEntrySize=32
 	ADD	R8, R8, LR, LSL #5
d590 5
a594 5
 	LDR	LR, [R5, #BigDirNamesSize]
 	ADD	R8, R8, LR			; size for dir body
 	ADD	R8, R8, #3
 	BIC	R8, R8, #3
 	ADD	R4, R8, R9
d596 1
a596 1
; 	DREG	R4, "dir size: "
d598 1
a598 1
 	B	%FT08
d601 1
a601 1
	; not big dir
d817 3
a819 3
 	BL	TestBigDir		; is it a big dir
 	MOVEQ	R2, R8
 	ADDNE	R2, R8, #1
d824 4
a827 4
 	ADD	R1, R1, R2
 	LDR	LR, FileBufsStart
 	CMPS	R1, LR
 	BLE	%FT01
d829 1
a829 1
 	DREG	R1, "end of copy after FileBufsStart: "
d831 1
a831 1
	SUB	R1, R1, R2
d841 4
a844 4
 	ADD	R1, R1, R2
 	LDR	LR, FileBufsStart
 	CMPS	R1, LR
 	BLE	%FT01
d846 1
a846 1
 	DREG	R1, "end of copy after FileBufsStart: "
d848 1
a848 1
	SUB	R1, R1, R2
d1058 1
a1058 1
; 	DLINE	"ExtendFileCache"
d1279 2
a1280 2
 	BL	TestBigDir
 	BNE	%FT01
d1282 3
a1284 3
 	; it's a big dir - call TestBigDirCheckByte
 	BL	TestBigDirCheckByte
 	B	%FT95
@


4.8
log
@Update to work with zero page relocation
Detail:
  s/FileCore, s/FileCore00, s/InitDieSvc - Try using OS_ReadSysInfo 6 to get IRQsema & CannotReset locations before falling back on legacy values. Store results in module workspace.
  s/FileCore05 - Commented out unused CheckEscape routine to avoid having to update it
  s/FileCore15 - Debugging code updated to use OS_ReadSysInfo 6 to fetch IRQsema ptr. Can't always rely on workspace version since workspace might not be set up yet.
  s/FileCore25, s/FileCore30, s/FileCore80 - Use IRQsema & CannotReset pointers from workspace
Admin:
  Tested on rev A2 BB-xM


Version 3.39. Tagged as 'FileCore-3_39'
@
text
@d476 1
a476 1
 [ F
@


4.7
log
@Skip "Disc drive empty" error on shutdown - if the drive's empty there's
not much you can do about it.
Dir cache flushing fixed.

Version 3.32. Tagged as 'FileCore-3_32'
@
text
@d1115 1
a1115 1
        MOVNE   LR, #IRQsema
@


4.6
log
@  More 32-bit fixes.
Detail:
  Flag preservation added to 7 routines that require it.  Docs.32-bit
    updated to remove the names of the functions that have been made
    to preserve flags again.
Admin:
  This version needs more testing, but at least this version does not
    appear to stiff the machine, corrupt discs, go bang under light
    testing with ADFS and RAMFS.
  26-bit and 32-bit builds slightly tested.
  Do not use in products - Do use in test builds.

Version 3.25. Tagged as 'FileCore-3_25'
@
text
@d1234 4
@


4.5
log
@  32-bit fixes
Detail:
  Some stack offsets were wrong - now fixed.
  More PSR preservation added.
Admin:
  26-bit builds of this module still stiff the machine when ADFS is
    used.
  Do not use - except for testing.

Version 3.24. Tagged as 'FileCore-3_24'
@
text
@d936 2
d955 2
@


4.4
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d338 1
a338 1
        STRVS   R0, [SP]
@


4.3
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d60 2
a64 1
 [ Module_Version >= 205
a67 1
 ]
a207 1
 [ FileCache
a208 1
 ]
a210 1
 [ FileCache
a211 1
 ]
d351 1
a371 1
 [ FileCache
a372 1
 ]
a401 1
 [ FileCache
a402 1
 ]
d425 3
a427 1
        Push    "r0-r12,lr"
d471 3
a473 1
        Pull    "r0-r12,pc",,^
d489 1
a489 1
        Pull    "R3,PC",,^
a531 1
 [ FileCache
a532 1
 ]
d669 1
a669 1
 [ FileCache            ;HERE CONSIDER RETURNING SPACE FROM FILE CACHE
a705 1
 ]
a856 1
 [ FileCache
a857 1
 ]
d863 2
a864 1
        Pull    "R0-R11,PC",,^
a871 1
 [ FileCache
a872 1
 ]
a886 1
 [ FileCache
a887 4
 |
        LDR     R1, MapSpace
        ADD     R1, SB, R1
 ]
d896 1
a896 1
        Pull    "R0-R1,PC",,^
d907 2
a908 1
        Push    "R0-R2,LR"
d923 3
a925 1
        Pull    "R0-R2,PC",,^
d953 1
a953 1
        Pull    "R0-R3,PC",,^
d988 1
a988 1
        Pull    "R0,R1,R11,PC",,^
a1012 1
 [ FileCache
d1026 1
a1026 1
        Pull    "PC",,^
d1041 1
a1041 1
        Pull    "PC",,^
d1057 1
a1057 1
        TEQP    PC, #I_bit :OR: SVC_mode        ;disable IRQ
d1063 1
d1065 3
d1070 1
a1070 1
        TEQP    PC, #SVC_mode   ;reenable IRQ
a1236 1
 ]
d1354 1
a1354 1
        Pull    "R2,PC",,^
d1370 1
a1370 1
        Pull    "R1-R2,PC",,^
@


4.2
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d30 1
a30 1
 [ Debug6
d68 10
d86 6
d93 1
d96 1
a96 1
 [ Debug6
d101 35
d140 1
d155 3
d162 4
d184 12
d225 4
d231 3
d236 72
d316 4
d325 4
d393 10
d447 4
d452 1
d513 22
d538 21
d566 1
d576 40
d622 1
d822 5
d828 12
d846 11
d1065 4
d1279 9
d1329 3
@


4.1
log
@Initial revision
@
text
@d63 1
a63 1
 [ Version >= 205
@


4.1.4.1
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@a67 10
 
 [ BigDir
 	BL	TestBigDir		; is it a big dir
 	BNE	%FT01			; no, it's small
 	MOV	R4, #0			; if it's a big dir, set r4 to 0 here to indicate that it's a variable size
 	MOV	R9, #BigDirTailSize	; size of big dir's tail
 	B	%FT02			; skip the new/old dir test
01
	; small dir
 ]
a75 6
 [ BigDir
02
 	; if the dir is big then the value of r4 is 0, and r6 is the same
 	; as r5
 	LDR	R5, DirBufferPtr
 |
a76 1
 ]
d79 1
a79 13
 [ Debug6 :LAND: :LNOT: BigDir		; if BigDir then values not valid yet
        DREG    R5, "DirBuffer start, end:",cc
        DREG    R6, ","
 ]
 
 [ Debug6 :LAND: BigDir
 	CMP	r4, #0
 	BNE	%FT01
 	
 	DREG	R5, "DirBuffer start (end not known yet):"
 	
 	B	%FT02
01
a81 1
02
a83 22
 [ BigDir
 	; If BufDir matches, then if it's a big dir, set up r6
 	LDR	LR, [SB,#:INDEX:BufDir]
 	CMPS	R3,LR
 	
 	BNE	%FT03		; dir doesn't match

 	; check for big dir
 	CMP	r4, #0		; r4 is 0 if it's a big dir as we don't know the size, yet
 	BNE	%FT90		; r4 is not 0, so we know it's a small dir - nothing else to do
 	
 	LDR	LR, [r5,#BigDirSize]
 	ADD	R6, R5, LR
 	
 [ Debug6
 	DREG	R6, "DirBuffer end:"
 ]
 
 	B	%FT90		; dir is in DirBuffer
 	
03	; no match
 |
a87 1
 ]
a122 12
        
 [ BigDir
 	; R4 needs set up
 	CMP	R4, #0
 	BNE	%FT01
 	LDR	r4, [R5, #BigDirSize]	; size of the big dir...
 	ADD	R6, R5, R4
  [ Debug6
  	DREG	r4, "From cached big dir, size is:"
  ]
01
 ]
a152 4
  [ BigDir
  	CMP	R4, #0
  	BEQ	%FT01
  ]
a154 63
  [ BigDir
01
  ]
 ]
 
  [ BigDir
  	; if it's big dir, then things get a lil' harder
  	
  	CMP	R4, #0
  	BNE	%FT70
  	
  	MOV	R4, #NewDirSize		; get the first 2048 bytes

	ADD	r6,r4,r5		; end  	
  
  [ Debug6
  	DREG	r5, "Going to read first part of dir to start, end:",cc
  	DREG	r6, ","
  ]
  	; it's a big dir.  method is to read the first 2048 bytes,
  	; then read the rest
  	
        MOV     R1, #ReadSecsOp ;ALLOW ESCAPE AND TIMEOUT
        MOV     R2, R3
        MOV     R3, R5
        MOV	R5, #0		;start from the beginning
        BL      GenIndDiscOp    ;(R1-R4->R0,R3-R5,V)
        BVS     %FT95
        
        ; have first part of dir in DirBuf

 	; now check a few things 
 	
 	MOV	R5, R8
 	BL	SanityCheckBigDirHeader		; (R5->R0,V)
 	BVS	%FT95				; broken dir!
 	
 [ DebugX
 	DLINE	"Dir was OK"
 ]
 	
 	; now we can try reading the rest
 	
 	LDR	r4, [r5,#BigDirSize]		; size of dir

	LDR	LR, DirBufferSize		; check the current size of DirBuf
	CMP	R4, LR
	BLS	%FT66				; dir buf is too small
	
 	BL	TryGrowDirBuf			; (R4->R0,V)
 	BVS	%FT95				; couldn't grow it
 	
66
 	
 	MOV	r5, #NewDirSize			; start offset
 	SUBS	r4, r4, r5			; amount of data to read
 	
  	
 	BEQ	%FT67				; nothing more to read
 
 [ Debug6
 	DREG	r5, "Going to read remainder of dir to start, end:",cc
 	DREG	r6, ","
a156 12
	BL	GenIndDiscOp			; read the rest of dir

67
        MOV     R5, R8
        MOV     R3, R7          ;restore dir disc add  	
        LDR	r4, [r5, #BigDirSize]
        ADD	r6, r5, r4

	B	%FT80
70
  ]

a164 4
 [ BigDir
80
 ]

a169 4
 [ BigDir
 	BL	TestBigDir
 	BEQ	%FT85
 ]
a277 4
 [ BigDir
 	BL	TestBigDir
        BLNE    TestDir    ;(R3->LR,Z)
 |
a278 1
 ]
a341 19
 [ BigDir
 	BL	TestBigDir
 	BNE	%FT05
 	
 	LDR	R4, [R5, #BigDirSize]
 	ADD	R6, R4, R5
 	MOV	R9, #BigDirTailSize
 	B	%FT06
 	
05	; here if not a big dir
        BL      TestDir      ;(R3->LR,Z)
        MOVEQ   R4, #NewDirSize
        MOVEQ   R9, #-NewDirLastMark
        MOVNE   R4, #OldDirSize
        MOVNE   R9, #-OldDirLastMark
        LDR 	R5, DirBufferPtr
        ADD     R6, R4, R5
06
 |
a348 1
 ]
a357 19
 [ BigDir
 	BL	TestBigDir
 	BNE	%FT07
 	
 	; big dir
 	
 	LDR	R8, [R5, #BigDirNameLen]
 	ADD	R8, R8, #3+BigDirHeaderSize	; header, name and tail
 	BIC	R8, R8, #3
 	LDR	LR, [R5, #BigDirEntries]
 	ASSERT	BigDirEntrySize=32
 	ADD	R8, R8, LR, LSL #5
 	LDR	LR, [R5, #BigDirNamesSize]
 	ADD	R8, R8, LR			; size for dir body
 	ADD	R4, R8, R9
 	B	%FT08
 	
07
	; not big dir
a363 10
	
08
 |
        BL      EndDirEntries   ;(R3,R5,R6->R0)
        SUB     R8, R0, R5      ;size for dir body
        ADD     R4, R8, R9      ;add size for dir tail
        ANDS    LR, R4, #3      ;ensure length is whole number of words
        RSBNE   LR, LR, #4
        ADDNE   R4, R4, LR
 ]
a562 5
 [ BigDir
 	BL	TestBigDir		; is it a big dir
 	MOVEQ	R2, R8
 	ADDNE	R2, R8, #1
 |
a563 1
 ]
a987 9
 [ BigDir
 	BL	TestBigDir
 	BNE	%FT01
 	
 	; it's a big dir - call TestBigDirCheckByte
 	BL	TestBigDirCheckByte
 	B	%FT95
01
 ]
a1028 3
 [ BigDir
95
 ]
@


4.1.4.2
log
@Altered directory format (change backup dir entries to be one word instead
of an entire copy of the entry).  Also reduced size of a directory entry
by one word.  Also fixed a number of small bugs.
@
text
@d542 1
a542 1
 	ADD	R8, R8, #4+BigDirHeaderSize	; header, name and tail
a544 6
 
 [ BigDirFix
 	ASSERT	BigDirEntrySize=28
 	RSB	LR, LR, LR, LSL #3	; *7
 	ADD	R8, R8, LR, LSL #2	; *7*4=28
 |
a546 1
 ]
@


4.1.4.3
log
@Now supports formatting of floppies with long file names.
@
text
@a385 10

 [ DebugXm
 	LDR	R0, FileBufsStart
 	CMPS	R11, R0
 	BLO	%FT01
 	
 	DREG	 R0, "FileBufsStart: "
 	DREG	R11, "Cache entry  : "
01
 ]
a502 2
 	LDR	R5, DirBufferPtr
 	
a555 2
 	ADD	R8, R8, #3
 	BIC	R8, R8, #3
a556 3
; [ DebugXm
; 	DREG	R4, "dir size: "
; ]
a782 11
 [ DebugXm
 	ADD	R1, R1, R2
 	LDR	LR, FileBufsStart
 	CMPS	R1, LR
 	BLE	%FT01
 	
 	DREG	R1, "end of copy after FileBufsStart: "
01
	SUB	R1, R1, R2
 ]

a788 11
 [ DebugXm
 	ADD	R1, R1, R2
 	LDR	LR, FileBufsStart
 	CMPS	R1, LR
 	BLE	%FT01
 	
 	DREG	R1, "end of copy after FileBufsStart: "
01
	SUB	R1, R1, R2
 ]

a996 4
 [ DebugXm
; 	DLINE	"ExtendFileCache"

 ]
@


4.1.4.4
log
@Fixed:

DoOsFunRenameBigDir to work when renaming a shared file between dirs where
the file ends up as the last object in the target dir.

SanityCheckEDiscRecord to allow idlen>15 when DiscVersion=0

GrowBigDir to round up desired size to a multiple of the disc allocation
size.

Also:

Implemented non-working code to write cache the dir buffer.  WriteCacheDir
compile switch set to FALSE in s.DebugOpts.  Don't set it to TRUE unless
I tell you it's working.

Made SortDir not attempt to sort more than 2047 entries in a dir, to
avoid it overflowing ScratchSpace.

Made SortPair do one extra shell on the sort (makes it more efficient).
@
text
@d68 1
a68 1

d100 1
a100 1

d104 1
a104 1

d106 1
a106 1

d118 1
a118 1

d124 1
a124 1

d127 1
a127 1

d131 1
a131 1

d133 1
a133 1

a154 3
 [ WriteCacheDir
	CLRV
 ]
a158 4
 [ WriteCacheDir
	BVS	%FT95		;if failed to dump cached dir
 ]

d176 1
a176 1

d228 1
a228 1

d231 1
a231 1

d234 1
a234 1

d237 2
a238 2
	ADD	r6,r4,r5		; end

d245 1
a245 1

d252 1
a252 1

d255 2
a256 2
 	; now check a few things

d260 1
a260 1

d264 1
a264 1

d266 1
a266 1

d272 1
a272 1

d275 1
a275 1

d277 1
a277 1

d280 2
a281 2


d283 1
a283 1

d293 1
a293 1
        MOV     R3, R7          ;restore dir disc add
d391 1
a391 1

a505 22

 [ WriteCacheDir
; check if the dir buffer is dirty
	LDR	LR, BufDirDirty
	TSTS	LR, #BufDirDirtyBit
	BEQ	%FT01

  [ DebugCW
	DREG	R3, "Writing buffered dir "
  ]
	BL	WriteDir	;if the buf dir is cached, sort it

	MOV	LR, #0
	STR	LR, BufDirDirty

	BVC	%FT01

	STR	R0, [SP]
	Pull	"R0-R11,PC"	;error exit when writing bufdir
01
 ]

d512 1
a512 1

d514 1
a514 1

d519 1
a519 1

d550 1
a550 1

d552 1
a552 1

d557 1
a557 1

d575 1
a575 1

d584 1
a584 1

d805 1
a805 1

d822 1
a822 1

d1253 1
a1253 1

@


4.1.4.5
log
@Fixed 4 bugs in DoOsFunRenameBigDir involving renameing of objects
between dirs with long filenames.

Fixed bug in OsFunResolveWildcard on long filenames.
@
text
@d30 1
a30 1
 [ Debug6 :LOR: DebugXr
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

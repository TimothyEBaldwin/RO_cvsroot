head	4.20;
access;
symbols
	FileCore-3_75:4.20
	FileCore-3_74:4.19
	FileCore-3_73:4.19
	FileCore-3_72:4.19
	FileCore-3_71:4.19
	FileCore-3_70:4.19
	FileCore-3_69:4.19
	FileCore-3_68:4.19
	FileCore-3_67:4.19
	FileCore-3_66:4.19
	FileCore-3_65:4.19
	FileCore-3_64:4.19
	FileCore-3_63:4.18
	FileCore-3_62:4.17
	FileCore-3_61:4.16
	FileCore-3_60:4.16
	FileCore-3_59:4.16
	FileCore-3_58:4.16
	FileCore-3_57:4.16
	FileCore-3_56:4.16
	FileCore-3_55:4.16
	FileCore-3_54:4.15
	FileCore-3_53:4.14
	FileCore-3_52:4.14
	FileCore-3_51:4.14
	FileCore-3_50:4.14
	FileCore-3_49:4.14
	FileCore-3_48:4.14
	FileCore-3_47:4.14
	FileCore-3_46:4.13
	FileCore-3_45:4.13
	FileCore-3_44:4.12
	FileCore-3_43:4.12
	FileCore-3_42:4.12
	FileCore-3_41:4.11
	FileCore-3_40:4.10
	FileCore-3_39:4.10
	FileCore-3_38:4.9
	FileCore-3_37:4.9
	FileCore-3_36:4.9
	FileCore-3_35:4.9
	FileCore-3_34:4.9
	FileCore-3_33:4.9
	RO_5_07:4.9
	FileCore-3_32:4.9
	FileCore-3_31:4.8
	FileCore-3_30:4.7
	FileCore-3_29:4.6
	FileCore-3_28:4.6
	FileCore-3_25-4_9_2_2:4.4.2.2
	FileCore-3_27:4.5
	FileCore-3_26:4.5
	FileCore-3_22-4_6_2_1:4.2.2.1
	bavison_FileCore-3_22_dev_bp:4.2
	bavison_FileCore-3_22:4.2.0.2
	FileCore-3_25-4_9_2_1:4.4.2.1
	HAL:4.4.0.2
	FileCore-3_25:4.4
	FileCore-3_24:4.4
	FileCore-3_23:4.3
	dellis_autobuild_BaseSW:4.2
	FileCore-3_22:4.2
	Ursula_merge:4.1
	ROL_merge:4.1
	FileCore-3_21:4.2
	ROL_Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.7
	ROL_FileCore-3_21:4.1
	ROL_FileCore-3_20:4.1
	ROL:4.1.0.10
	ROL_bp:4.1
	Ursula_RiscPC_bp:4.1
	FileCore-3_18:4.1
	FileCore-3_01:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.1
	sproven_FileCore-3_16:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	sproven_FileCore-3_15:4.1
	sproven_314:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1
	sproven_3_11:4.1
	sproven_3_10:4.1
	sproven_Ursula_3_09:4.1
	sproven_3_07:4.1
	sproven_3_06:4.1
	sproven_3_05:4.1
	sproven_3_04:4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1
	sproven_3_02:4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.20
date	2017.07.06.14.36.57;	author rsprowson;	state Exp;
branches;
next	4.19;
commitid	glaSUStjQCVZ3bYz;

4.19
date	2014.11.02.17.25.24;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	afoCgwcyXTmkoDWx;

4.18
date	2013.07.20.14.10.02;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	qZtNVkGjzh5uqdYw;

4.17
date	2013.07.18.21.04.17;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	Em91CJgLrlPBMZXw;

4.16
date	2013.02.21.16.53.06;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	CCuV2tngKttj75Fw;

4.15
date	2012.10.28.08.52.32;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	6n5fY77YU7JEb8qw;

4.14
date	2011.11.25.08.50.22;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	Wvsb4iMJaWIw2HIv;

4.13
date	2011.10.14.07.23.50;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	D2Id4aPp4zmuUhDv;

4.12
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	A9Zxco9ydo9FCOBv;

4.11
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	PKTDORFkNFRVOmzv;

4.10
date	2011.08.04.20.43.10;	author jlee;	state Exp;
branches;
next	4.9;
commitid	zcIknvqdwARiCeuv;

4.9
date	2003.08.08.09.42.49;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2003.04.03.18.33.28;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2001.05.14.16.26.35;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2001.05.10.15.10.27;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2000.12.07.17.25.28;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.31.09.32.30;	author sbrodie;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.09.21.12.07.13;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.32.16;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	2000.11.30.17.04.36;	author kbracey;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2001.05.10.15.04.37;	author kbracey;	state Exp;
branches;
next	;

4.2.2.1
date	2000.12.07.17.11.14;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.32.16;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.17.17;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.33.57;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.30.52;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.20
log
@Increase upper range of idlen to 21 bits
When 'BigMap' support was added drive sizes were such that (see table and discussion in Doc/BigDisc/BigDiscs) an upper maximum of 19 bits for idlen was appropriate. Now that drives of 2^29 sectors are readily available (the limit of 'BigDisc' support) the idlen limit of 19 has meant the minimum object size has grown too. This change uses the remaining 2 indirect disc address bits to get a factor x4 reduction in minimum object size, at the expense of a 4x larger map.

Defns.s: Parameterise idlen for big and small maps. Small's limit remains 15, big's limit raised from 19 to 21.
Identify.s: When mounting, use the parameterised idlen upper limits to decide whether it's a valid disc or not.
FileCore32.s: Adjust the BIC masks to knock out the extra 2 bits when forming the hash of the object id. Fix long standing bug updating the wrong entry in the hash table (due to LSL #2 giving 5x the entry index, rather than 3x).
FileCore15.s: Take care not to shift b20 of idlen into C as a side effect of a flags changing opcode. An audit of FileCore showed this to be the only site where the subsequent condition code(s) depended on C.
Tools/basic/DispMap: Updated to support BigMaps at all, previously it only worked with NewMap discs.

Tested with an assortment of drives with FSBash for 300k cycles of scrambling for idlen = 17, 19, 20 & 21.

Version 3.75. Tagged as 'FileCore-3_75'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >FileCore15

; *********************************
; ***  CHANGE LIST AND HISTORY  ***
; *********************************
;
; 16-Jun-94   AMcC  Replaced ScratchSpaceSize with ?ScratchSpace
;
; 09-Dec-94   SBP   Made discop call to parent for small FSs check
;                   for disc address overflow and give BadParmsErr
;                   if address to big.

 [ Dev

        ; Ugly but necessary because debug macros can get called before
        ; workspace is set up
        ; Exits NE if IRQsema <> 0
        MACRO
        CheckIRQsema
        Push    "r0-r2,lr"
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_IRQsema
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        LDREQ   r2, =Legacy_IRQsema
        LDR     r2, [r2]
        TEQ     r2, #0
        Pull    "r0-r2,lr"        
        MEND
        
PHEX
        SavePSR R4
 [ DebugSwitch
        MOV     R3, #0
        LDR     R3, [R3,#&FFC]
        TEQS    R3, #0
        BNE     PHEXIT1
 ]
 [ :LNOT: IrqDebug
        CheckIRQsema
        BNE     PHEXIT1         ;return if IRQ thread
 ]
        MOV     R3, LR
 [ No32bitCode
        ASSERT  SVC_mode=3
        ORR     R0, LR, #SVC_mode :OR: I_bit
        TEQP    PC, R0          ;go to SVC mode preserving flags
        NOP
 |
        MRS     R0, CPSR
        ORR     R0, R0, #SVC26_mode :OR: I32_bit
        MSR     CPSR_c, R0
 ]
        Push    "LR"
 [ SpoolOff
        BL      SpoolOff
 ]
        MOV     R1, #32-4
PHLOOP
        MOV     R0, R2, LSR R1
        AND     R0, R0, #&F
        CMPS    R0, #10
        ADDCC   R0, R0, #"0"
        ADDCS   R0, R0, #"A"-10
        SWI     OS_WriteC
        SUBS    R1, R1, #4
        BPL     PHLOOP
        MOV     R0, #" "
        SWI     OS_WriteC
 [ SpoolOff
        BL      SpoolOn
 ]
        Pull    "LR"
        RestPSR R4,,cf
        MOV     PC, R3
PHEXIT1
        RestPSR R4,,f
        MOV     PC, LR

 [ SpoolOff
SpoolOff
        Push    "R0-R3,LR"
        SavePSR R3
        MOV     R0, #OsByte_SpecifyOutputStream
        MOV     R1, #&10
        MOV     R2, #&EF
        SWI     OS_Byte
        RestPSR R3,,f
        Pull    "R0-R3,PC"

SpoolOn
        Push    "R0-R3,LR"
        SavePSR R3
        MOV     R0, #OsByte_SpecifyOutputStream
        MOV     R1, #0
        MOV     R2, #&EF
        SWI     OS_Byte
        RestPSR R3,,f
        Pull    "R0-R3,PC"
 ]

 [ ExceptionTrap
Exception
        B       ThroughZero
        B       Undefined
        NOP                     ;dont trap SWI vector
        B       PrefetchAbort
        B       DataAbort
        B       AddressException

ThroughZero
  [ No32bitCode
        TEQP    PC, #F_bit :OR: I_bit :OR: SVC_mode
        NOP
  |
        MSR     CPSR_c, #F32_bit :OR: I32_bit :OR: SVC32_mode
  ]
        STR     R13,[R0,-R0]
        MOV     R13,#ScratchSpace+?ScratchSpace
        STMDB   R13!,{R0-R14}
        LDR     R14,[R0,-R0]
        STR     R14,[R13,#13*4]
        MOV     R14,#IOC
        ASSERT  IOC :MOD: &100 = 0
        STRB    R14,[R14,#IOCFIQMSK]
        STRB    R14,[R14,#IOCIRQMSKA]
        STRB    R14,[R14,#IOCIRQMSKB]
        mess    ,"Through zero",NL
        B       ExceptionCommon

Undefined
  [ No32bitCode
        TEQP    PC, #F_bit :OR: I_bit :OR: SVC_mode
        NOP
  |
        MSR     CPSR_c, #F32_bit :OR: I32_bit :OR: UND32_mode
  ]
        STR     R13,[R0,-R0]
        MOV     R13,#ScratchSpace+?ScratchSpace
        STMDB   R13!,{R0-R14}
        LDR     R14,[R0,-R0]
        STR     R14,[R13,#13*4]
        MOV     R14,#IOC
        ASSERT  IOC :MOD: &100 = 0
        STRB    R14,[R14,#IOCFIQMSK]
        STRB    R14,[R14,#IOCIRQMSKA]
        STRB    R14,[R14,#IOCIRQMSKB]
        mess    ,"Undefined instruction",NL
        B       ExceptionCommon

PrefetchAbort
  [ No32bitCode
        TEQP    PC, #F_bit :OR: I_bit :OR: SVC_mode
        NOP
  |
        MSR     CPSR_c, #F32_bit :OR: I32_bit :OR: ABT32_mode
  ]
        STR     R13,[R0,-R0]
        MOV     R13,#ScratchSpace+?ScratchSpace
        STMDB   R13!,{R0-R14}
        LDR     R14,[R0,-R0]
        STR     R14,[R13,#13*4]
        MOV     R14,#IOC
        ASSERT  IOC :MOD: &100 = 0
        STRB    R14,[R14,#IOCFIQMSK]
        STRB    R14,[R14,#IOCIRQMSKA]
        STRB    R14,[R14,#IOCIRQMSKB]
        mess    ,"Prefetch Abort",NL
        B       ExceptionCommon

DataAbort
  [ No32bitCode
        TEQP    PC, #F_bit :OR: I_bit :OR: SVC_mode
        NOP
  |
        MSR     CPSR_c, #F32_bit :OR: I32_bit :OR: ABT32_mode
  ]
        STR     R13,[R0,-R0]
        MOV     R13,#ScratchSpace+?ScratchSpace
        STMDB   R13!,{R0-R14}
        LDR     R14,[R0,-R0]
        STR     R14,[R13,#13*4]
        MOV     R14,#IOC
        ASSERT  IOC :MOD: &100 = 0
        STRB    R14,[R14,#IOCFIQMSK]
        STRB    R14,[R14,#IOCIRQMSKA]
        STRB    R14,[R14,#IOCIRQMSKB]
        mess    ,"Data Abort",NL
        B       ExceptionCommon

AddressException
  [ No32bitCode
        TEQP    PC, #F_bit :OR: I_bit :OR: SVC_mode
        NOP
  |
        MSR     CPSR_c, #F32_bit :OR: I32_bit :OR: ABT32_mode
  ]
        STR     R13,[R0,-R0]
        MOV     R13,#ScratchSpace+?ScratchSpace
        STMDB   R13!,{R0-R14}
        LDR     R14,[R0,-R0]
        STR     R14,[R13,#13*4]
        MOV     R14,#IOC
        ASSERT  IOC :MOD: &100 = 0
        STRB    R14,[R14,#IOCFIQMSK]
        STRB    R14,[R14,#IOCIRQMSKA]
        STRB    R14,[R14,#IOCIRQMSKB]
        mess    ,"Address Exception",NL

ExceptionCommon
        mess    ,"R0       R1       R2       R3       R4       R5       R6       R7",NL
        DREG    R0
        DREG    R1
        DREG    R2
        DREG    R3
        DREG    R4
        DREG    R5
        DREG    R6
        DREG    R7
        mess    ,"R8       R9       R10      R11      R12      R13      R14",NL
        DREG    R8
        DREG    R9
        DREG    R10
        DREG    R11
        DREG    R12
        LDR     LR, [R0,-R0]
        DREG    LR
        LDR     LR, [R13,#14*4]
        DREG    LR

        DREG    R13

        mess    ,,NL
        Push    "r0-r2"
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_IRQsema
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        LDREQ   r2, =Legacy_IRQsema
        LDR     lr, [r2]
        Pull    "r0-r2"
        DREG    LR
        mess    ,"IRQsema",NL
EHANG
        BAL  EHANG

 ]

Mess1                   ;R0,R1,LR stacked
        SavePSR R0              ;save PSR
        MOV     R1, LR          ;save link
 [ DebugSwitch
        MOV     LR, #0
        LDR     LR, [LR, #&FFC]
        TEQS    LR, #0
        SavePSR LR
        TSTS    LR, #Z_bit      ;toggle Z
        MOVNE   PC, R1
 ]
 [ :LNOT: IrqDebug
        CheckIRQsema
        MOVNE   PC, R1          ;skip if IRQ thread, return NE
 ]

        BIC     LR, R0, #3
 [ No32bitCode
        ORR     LR, LR, #SVC_mode :OR: Z_bit :OR: I_bit
        TEQP    PC, LR          ;go to supervisor mode, preserve FI, set EQ
        NOP                     ;delay for mode change
 |
        ORR     LR, LR, #SVC26_mode :OR: I32_bit
        ORR     LR, LR, #Z_bit
        MSR     CPSR_cf, LR
 ]
        Push    "LR"
 [ SpoolOff
        BL      SpoolOff
 ]

        MOV     PC, R1

TubeWrHexWord ROUT
        SavePSR R4
        MOV     R3, LR
        MOV     R1, #32-4
05
        MOV     R0, R2, LSR R1
        AND     R0, R0, #&F
        CMPS    R0, #10
        ADDCC   R0, R0, #"0"
        ADDCS   R0, R0, #"A"-10
        BL      TubeChar        ;(R0)
        SUBS    R1, R1, #4
        BPL     %BT05
        MOV     R0, #" "
        BL      TubeChar        ;(R0)
        RestPSR R4,,f
        MOV     PC, R3

           ^ 0, R1
R1_status  # 4
R1_data    # 4
TubeAddress * &3344000

TubeChar ROUT
        Push    "R1,LR"
        LDR     R1, =TubeAddress
10
        LDRB    LR, R1_status
        TSTS    LR, #&40
        BEQ     %BT10
        STRB    R0, R1_data
        Pull    "R1,PC"
        LTORG
 ]


; =========
; IndDiscOp
; =========

; as GenIndDiscOp, but known to start at beginning of file

IndDiscOp
        MOV     R5,#0
;fall into GenIndDiscOp

; ============
; GenIndDiscOp
; ============

; read/write bytes from/to disc
; this should be used for all file operations, so that they may be stored
; non-contiguously

; entry:
;  R1 = disc op
;  R2 = ind disc address of file
;  R3 = RAM start
;  R4 = length
;  R5 = start offset in file

; exit: flags except V preserved
; IF error V set, R0 = result
;  R3,R5 incremented by amount transferred
;  R4    decremented by amount transferred

GenIndDiscOp
 [ Debug8

        DLINE   "disc op |disc add|RAM ptr |length  |File ptr - enter GenIndDiscOp"
        DREG    R1," ",cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," ",cc
        DREG    R5," "
 ]

        Push    "R1,R2,R6-R9,LR"
        SavePSR LR
        Push    "LR"
        MOV     R6, R3                  ;save RAM ptr
        MOV     R3, R2
        BL      TestMap                 ;(R3->Z)
        BEQ     %FT50                   ;if new map

        ; For old map disc address is (ind disc address of file + offset)
        ; this remains true on 'big' discs, but we have to squash the disc
        ; address into a sector address

 [ BigDisc
        MOV     R3,R6                   ; restore RAM ptr

; if we have an old map disc, the indirect disc addr is simply the
; byte address of the file.  Simply shift to sector address.

        MOV     R6,R2,LSR #(32-3)       ; get drive bits
        DiscRecPtr R7,R6                ; get disc record
        LDRB    R7,[R7,#DiscRecord_Log2SectorSize]      ; get the sector size
        BIC     R2,R2,#DiscBits         ; disc address bits
        MOV     R2,R2,LSR R7            ; change to sector address
        ADD     R2,R2,R5, LSR R7        ; disc address to start at
        ORR     R2,R2,R6,LSL #(32-3)    ; drive number back in

        MOV     R6,R4                   ; length

        BL      DoDiscOp                ;(R1-R4->R0-R4,V)

        SUB     R6, R6, R4              ;amount transferred
        ADD     R5, R5, R6              ;increment start offset
        B       %FT95
 |
        MOV     R3, R6                  ;restore RAM ptr
        ADD     R2, R2, R5              ;disc address to start at.
        MOV     R6, R4
        BL      DoDiscOp                ;(R1-R4->R0-R4,V)

        SUB     R6, R6, R4              ;amount transferred
        ADD     R5, R5, R6              ;increment start offset
        B       %FT95
 ]

50
        ; For new map disc address isn't ind disc address - have to go via map
        LDRB    R8, LockedDrive
        CMPS    R8, #8          ;V=0
        BHS     %FT52

        ; There's a locked disc, check its ours
        LDRB    lr, LockedDisc
 [ DebugL
        Push    "r0"
        MOV     r0, lr
        DREG    r0,"Locked disc is ",cc
        DREG    r3," disc address is "
        Pull    "r0"
 ]
        AND     r3, r3, #DiscBits       ;with IdLen=21 be careful to not set C during TEQ
        TEQ     lr, r3, LSR #(32-3)
        BEQ     %FT52

        ; Generate error and restore RAM ptr
        MOV     r0, #InUseErr
        BL      SetV
        MOV     r3, r6
        B       %FT95

52
        BLHS    BeforeReadFsMap ;(R3->R0,V)
        MOV     R3, R6          ;restore RAM ptr
        BVS     %FT95
        MOV     R9, #-1         ;init pre gap unknown
        MOVS    R7, R4          ;amount left to do
        BEQ     %FT90
55
        LDR     R2, [SP,#8]     ; Ind disc address
        BL      FindFileFragment;(R2,R5,R9->R2,R4,R9,LR)
        CMPS    R4, R7          ;(R4 is the amount left in the fragment)
        BICLS   R1, R1, #DiscOp_Op_BackgroundOp_Flag
        MOVHI   R4, R7          ;min (amount left to do,amount left in chunk)
        MOV     R6, R4
        BL      DoDiscOp        ;(R1-R4->R0-R4,V)
        SUB     R6, R6, R4      ;amount transferred
        ADD     R5, R5, R6      ;increment start offset
        SUB     R7, R7, R6      ;decrement amount left
        EOR     R6, R1, #DiscOp_Op_BackgroundOp_Flag
        LDR     R1, [SP, #4]
        AND     R6, R1, R6
        BLVS    %FT97
        BVS     %FT90
        TEQS    R7, #0
        BNE     %BT55           ;loop until error or done
                                ;IF op is background op
        TSTS    R6, #DiscOp_Op_BackgroundOp_Flag       ;AND last sub op not background
        BEQ     %FT90                   ;THEN need to do backround part if any
        WritePSRc I_bit :OR: SVC_mode, R6
        LDMIA   R3, {R6,R7}
      [ FixTBSAddrs
        CMN     R6, #ScatterListNegThresh
        ADDCS   R3, R3, R6
        LDMCSIA R3, {R6,R7}
      |
        TEQS    R6, #0
        ADDMI   R3, R3, R6
        LDMMIIA R3, {R6,R7}
      ]
        TEQS    R7, #0          ;is background part zero length ?
        BLEQ    %FT99           ;V=0, R7=0
        WritePSRc SVC_mode, LR, NE
        BLNE    DoDiscOp        ;(R1-R4->R0-R4,V) preserves Z
        WritePSRc SVC_mode, LR
90
        LDRB    LR, LockedDrive
        TEQS    LR, R8
        BLNE    UnlockMap
95
        Pull    "LR"
        Pull    "R1,R2,R6-R9"
  [ Debug8

        DLINE   "disc op |disc add|RAM ptr |remains |file ptr|result - leave GenIndDiscOp"
        DREG    R1," ",cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," ",cc
        DREG    R5," ",cc
        DREG    R0," "
  ]

        B       PullLinkKeepV

97
        ; Nothing to do if not background op
        TSTS    R6, #DiscOp_Op_BackgroundOp_Flag               ; preserves V
        MOVEQ   PC, LR
99
        ; Background op - update process block
        Push    "R10,LR"
        SavePSR R10

        ; Test for Winnie/Floppy disc now has to test drive number not disc number
        ; which is what should have been done anyway
        MOV     R9, R2, LSR #(32-3)
        DiscRecPtr R9, R9
        LDRB    R9, [R9, #DiscFlags]
        TST     R9, #FloppyFlag
        LDREQ   R9, WinnieProcessBlk
        LDRNE   R9, FloppyProcessBlk
        ASSERT  DiscOp_ReadSecs=1
        ASSERT  DiscOp_WriteSecs=2
        TSTS    R1, #DiscOp_WriteSecs
        MOVNE   LR, #WriteBehind
        MOVEQ   LR, #ReadAhead
 [ DebugP
        DREG    r9, "Process ",cc
        Push    "r0"
        MOV     r0, lr
        DREG    r0, " going active with "
        Pull    "r0"
 ]
        STRB    LR, [R9, #Process]
        TSTS    R10, #V_bit
        STREQ   R7, [R9, #ProcessStatus]        ; R7=0
        ADDNE   R9, R9, #ProcessError
        ASSERT  ProcessStatus = ProcessError + 4
 [ NewErrors
        BEQ     %FT9901
        LDR     LR, FS_Flags                    ; fudge process status
        TST     LR, #CreateFlag_NewErrorSupport ; to new scheme if module uses it
        MOVNE   R3, R3, LSR #2
        STMIA   R9, {R0,R3}
        MOVNE   R3, R3, LSL #2
9901
 |
        STMNEIA R9, {R0,R3}
 ]
        RestPSR R10,,f
        Pull    "R10,PC"


; ========
; DoDiscOp
; ========

; As RetryDiscOp except
;  a) first ensures correct disc is present
;  b) disc must be specified by disc address, not by disc rec ptr in disc op

; entry: R1 disc op
;        R2 disc address
;        R3 RAM start
;        R4 length

; exit: flags except V preserved
; IF error V set, R0 result
;        R2,R3 incremented
;        R4 decremented

DoDiscOp ROUT
 [ Debug3

        DLINE   "disc op  disc add start    length - enter DoDiscOp"
        DREG    R1,,cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," "
 ]
        Push    "LR"
        SavePSR LR
        Push    "R0-R3,LR"
        MOV     R3, R2
        BL      FindDisc        ;(R3->R0,R1,V)
        STRVS   R0, [SP]        ;SP still points there

        Pull    "R0-R3"         ;restore disc op params
        BLVC    RetryDiscOp     ;(R1-R4->R0-R4,V) do the disc op

 [ Debug3

        DLINE   "disc op  disc add start    length - leave DoDiscOp"
        DREG    R1,,cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," "
 ]

        Pull    "LR"
        B       PullLinkKeepV

; ===========
; RetryDiscOp
; ===========

; Do a disc operation with retries

; On entry:           On Exit
;  R0                  IF error V set, R0 result
;  R1 = DiscOp 0-&FF
;  R2 = Disc Address   End Disc Address         TOP 3 BITS R2 = DISC
;  R3 = RAM start      Ram End
;  R4 = Length         Untransferred

RetryDiscOp ROUT
        Push    "R0,R1,R5,R6,LR"
 [ Debug3
        DLINE   "RetryDiscOp"
 ]
        MOV     R6, R2, LSR #(32-3)     ;save disc bits
        DiscRecPtr  R5,R6
        LDRB    LR, [R5,#DiscsDrv]
        BIC     R2, R2, #DiscBits       ;replace disc bits by drive bits
        ORR     R2, R2, LR, LSL #(32-3)
        BL      RetryDriveOp
        BIC     R2, R2, #DiscBits
        ORR     R2, R2, R6, LSL #(32-3)
        MOVVC   R0, R6
        BLVC    UpdatePriority
        STRVS   R0, [SP]
        Pull    "R0,R1,R5,R6,PC"

; ============
; RetryDriveOp
; ============

; Do a disc operation with retries

; On entry:           On Exit
;  R0                  IF error V set, R0 result
;  R1 = DiscOp 0-&FF
;  R2 = Disc Address   End Disc Address         TOP 3 BITS INTERNAL DRIVE NUMBER
;  R3 = RAM start      Ram End
;  R4 = Length         Untransferred
;  R5 ->disc rec
;  R6 ->sector cache   extended sector cache

; Remove all version and other conditionals from this operation
; Store in the drive record details of the last format operation

RetryDriveOp ROUT
        Push    "R0,R6-R8,LR"
 [ Debug3

        DLINE   "disc op  disc add start    length   disc rec  cache    >RetryDriveOp"
        DREG    R1," ",cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," ",cc
        DREG    R5," ",cc
        DREG    R6

        TSTS    R1, #DiscOp_Op_ScatterList_Flag         ; check for scatter list
        BEQ     %FT01                   ; if not, skip code to handle it...
        Push    "r4,R5,r6,r7,lr"

        MOV     LR, R4                  ; take copy of length to count down thru scatter list
 [ BigDisc
        LDRB    R4,[R5,#DiscRecord_Log2SectorSize]      ; get sector size
 ]
        MOV     R0, R3                  ; take copy of scatter list ptr
        MOV     R5, R2                  ; take copy of disc start addr to build end addr

00
        LDMIA   R0!,{R6,R7}             ; get a scatter list entry
        CMPS    R7, LR                  ; if scatter list entry length greater than transfer length...
        MOVHI   R7, LR                  ; ...make it same size
        DREG    R5," ",cc
        DREG    R6," ",cc
        DREG    R7,,cc

        DLINE   " disc ram len"
 [ BigDisc
        ADD     R5, R5, R7,LSR R4       ; adjust end disc address (sectors)
 |
        ADD     R5, R5, R7              ; adjust end disc address (bytes)
 ]
        SUBS    LR, LR, R7              ; count down length and if still more left...
        BNE     %BT00                   ; ...back to start of loop
        Pull    "r4,R5,r6,r7,lr"
01
 ]

        LDRB    R8, Interlocks

        ; Check the drive number
        MOV     r7, r1
        MOV     r1, r2, LSR #(32-3)
        BL      CheckDriveNumber
        BVS     %FT95
        DrvRecPtr r0, r1
        MOV     r1, r7

        ; Process handling of previous format details
        AND     lr, r1, #DiscOp_Op_Mask
        TEQ     lr, #DiscOp_Verify                   ; Verify doesn't affect LastDiscOpWasFormat
        BEQ     %FT40
        TEQ     lr, #DiscOp_WriteTrk
        LDRB    lr, [r0, #DrvFlags]
        BICNE   lr, lr, #LastDiscOpWasFormat
        STRB    lr, [r0, #DrvFlags]
        BNE     %FT40

        ; Dismount the disc attached to the drive
        Push    "r0,r1"
        LDRB    r1, [r0, #DrvsDisc]
        BIC     r1, r1, #Uncertain
        CMP     r1, #7
        BLLS    ActiveDismountDisc
        Pull    "r0,r1"
        CLRV

        LDRB    lr, [r0, #DrvFlags]
        ORR     lr, lr, #LastDiscOpWasFormat
        STRB    lr, [r0, #DrvFlags]

        ; Disc record specifies information for WriteTrkOp
        LDRB    lr, [r5, #DiscRecord_Log2SectorSize]
        STRB    lr, [r0, #PrevFormSectorSize]
        LDRB    lr, [r5, #DiscRecord_SecsPerTrk]
        STRB    lr, [r0, #PrevFormSecsPerTrk]
        LDRB    lr, [r5, #DiscRecord_Heads]
        STRB    lr, [r0, #PrevFormHeads]
        LDRB    lr, [r5, #DiscRecord_Density]
        STRB    lr, [r0, #PrevFormDensity]
        LDRB    lr, [r5, #DiscRecord_LowSector]
        STRB    lr, [r0, #PrevFormLowSector]
        LDR     lr, [r5, #DiscRecord_DiscSize]
        STR     lr, [r0, #PrevFormDiscSize]
 [ BigDisc
        LDR     lr, [r5, #DiscRecord_BigMap_DiscSize2]
        STR     lr, [r0, #PrevFormDiscSize2]
 ]

40

        ; Check for cached read sectors and escape if so
        AND     LR, R1, #DiscOp_Op_Mask
        TEQ     LR, #DiscOp_CachedReadSecs
        BEQ     DoCachedReadSecs

        ; C=Background bit set
        ; Load r0 with relevant process block
        MOV     R7, R1
        AND     R1, R1, #DiscOp_Op_BackgroundOp_Flag
        CMP     R1, #1      ;C=1 <=> BackgroundOp
        MOV     R1, R2, LSR #(32-3)
        TSTS    R1, #4
        LDRNE   R0, FloppyProcessBlk
        LDREQ   R0, WinnieProcessBlk
        BCC     %FT50

        ; If doing background stuff (C set), then set process to
        ; read ahead or write behind as appropriate and store the
        ; drive. RetryDriveOp with background set only gets called
        ; when a process is finished and the lower level driver is idle
        ; so forcing the process to read/write is not a problem.
        ASSERT  DiscOp_ReadSecs=1
        ASSERT  DiscOp_WriteSecs=2
        TSTS    R7, #DiscOp_WriteSecs
        MOVNE   LR, #WriteBehind
        MOVEQ   LR, #ReadAhead
        STRB    R1, [R0, #ProcessDrive]
 [ DebugP
        DREG    r0, "Process ",cc
        Push    "r0"
        MOV     r0, lr
        DREG    r0, " going active with "
        Pull    "r0"
 ]
        STRB    LR, [R0, #Process]
        MOV     R1, R7
        ; Addresses generated by FileCore (background) are safe (probably)
        B       %FT60

50
        ; If doing foreground stuff then:

        ; If doing a transfer op and transfering 0 bytes then finished now
        AND     LR, R7, #DiscOp_Op_Mask
        CMP     LR, #DiscOp_WriteSecs
        CMPLS   R4, #0
        BEQ     %FT99

        ; if on floppy wait for the write-behind to finish.
        TST     r1, #4
        BLNE    DriveWriteBehindWait

        ; Lock the relevant controller from having more background stuff lumped
        ; onto it
        ORRNE   LR, R8, #FloppyLock
        ORREQ   LR, R8, #WinnieLock
        STRB    LR, Interlocks

        ; Wait for the controller to become free
        BL      WaitForControllerFree   ;(R0)
        AND     LR, R7, #DiscOp_Op_Mask

        MOV     R1, R7

        ; Check length/end of read track or write track
        TEQ     lr, #DiscOp_ReadTrk
        TEQNE   lr, #DiscOp_WriteTrk
        BNE     %FT60

        ; Check track start is within the disc
        BIC     R6, R2, #DiscBits
        LDR     LR, [R5,#DiscRecord_DiscSize]

 [ BigDisc

        Push    "R6,R7"                 ; convert disc size to sectors
        LDRB    R6,[R5,#DiscRecord_Log2SectorSize]
        MOV     LR, LR, LSR R6
        LDR     R7, [R5,#DiscRecord_BigMap_DiscSize2]
        RSB     R6, R6, #32
        ORR     LR, LR, R7, LSL R6
        Pull    "R6,R7"

        CMPS    R6, LR                  ;reject beyond disc end
        MOVHI   R0, #BadParmsErr
        BHI     %FT95
 |
        CMPS    R6, LR                  ;reject beyond disc end
        MOVHI   R0, #BadParmsErr
        BHI     %FT95
 ]

60
        ; Determine the location of the defect list:
        ; if AltDefectList then On the end of the disc record
        ; else if HasDefectList then In DefectSpace
        ; else Use DummyDefectList
        TST     R1, #DiscOp_Op_AltDefectList_Flag
        ADDNE   R6, R5, #MaxStruc
        BNE     %FT70
        MOV     LR, R2, LSR #(32-3)
        DrvRecPtr LR, LR
        LDRB    LR, [LR, #DrvFlags]
        TST     LR, #HasDefectList
        MOVEQ   R6, #NIL                ; Bad address to indicate 'no defect list'
        BEQ     %FT80
        LDRNE   LR, DefectSpace
        ADDNE   LR, SB, LR
        ASSERT  SzDefectList=(1 :SHL: 9)
        MOVNE   R6, R2, LSR #(32-3)
        ADDNE   R6, LR, R6, LSL #9      ;->defect list for this drive
70
        ; Defect list pointed at by R6 - check it
        MOV     R7, #0
        MOV     R0, R6
75
        LDR     LR, [R0],#4
        CMPS    LR, #DefectList_End
        EORCC   R7, LR, R7, ROR #13
        BCC     %BT75
        EOR     R7, R7, R7, LSR #16
        EOR     R7, R7, R7, LSR #8
        EOR     R7, R7, LR
        ANDS    R7, R7, #&FF
        MOVNE   R0, #BadDefectListErr
        BNE     %F95

80

        ; Test for whether Fiq is needed
        TSTS    R2, #bit31
        MOVEQ   R0, #CreateFlag_FixedDiscNeedsFIQ
        MOVNE   R0, #CreateFlag_FloppyNeedsFIQ
        LDR     LR, FS_Flags
        TST     LR, R0

 [ DebugI
        BEQ     %FT01

        DLINE   " C1 ",cc
01
 ]
        ; Claim Fiq if it's needed
        BLNE    ClaimFiq
        EOR     R2, R2, #bit31          ;convert to external drive numbering
        MOV     R7, SB                  ;save static base
        BL      OnlyExternal
        LDR     SB, ParentPrivate
 [ Debug3; :LOR: DebugI :LOR: DebugBA :LOR: Debug3L

        DLINE   "D",cc
        DREG    r0,"Regs into child:",cc
        DREG    r1,,cc
        DREG    r2,,cc
        DREG    r3,,cc
        DREG    r4,,cc
        DREG    r5
 ]
 [ BigDisc
; determine whether FileSystem supports BigDisc
        LDR     LR, [R7,#:INDEX:FS_Flags]       ; get the flags for filing system
        TST     LR, #CreateFlag_BigDiscSupport  ; does this FS use big addrs?
        BNE     %FT10                           ; skip code to adjust addrs

 [ Debug3
        DLINE   "Doing address conversion"
 ]

; convert disc addr to a byte addr

        Push    "R3,R6"

        LDRB    R6, [R5,#DiscRecord_Log2SectorSize]             ; sector size
        AND     LR, R2, #DiscBits               ; drive in LR
        BIC     R2, R2, #DiscBits               ; disc offset (sector) in R2
        MOV     R3, R2, LSL R6                  ; convert to byte addr
        CMP     R2, R3, LSR R6                  ; check for disc addr overflow
        TSTEQ   R3, #DiscBits                   ; check for >512M
        ORREQ   R2, R3, LR                      ; recombine with drive no
        Pull    "R3,R6"
        MOVNE   R0,#BadParmsErr                 ; error
        BNE     %FT95

 [ Debug3 :LOR: DebugI :LOR: DebugBA :LOR: Debug3L
        DREG    r0,"Actual regs into child:",cc
        DREG    r1,,cc
        DREG    r2,,cc
        DREG    r3,,cc
        DREG    r4,,cc
        DREG    r5
 ]
        MOV     LR, PC                          ; set up link for return to MOV SB,R7
        LDR     PC, [R7,#:INDEX:FS_LowLevel]    ; do the low level op

        LDRB    R6, [R5, #DiscRecord_Log2SectorSize]            ; get sector size
        AND     LR, R2, #DiscBits               ; disc bits in LR
        BIC     R2, R2, #DiscBits               ; offset in R2
        MOV     R2, R2, LSR R6                  ; back to sectors
        ORR     R2, R2, LR                      ; put drive back in

        B       %FT20                           ;

10
; do the operation without conversion of addresses
 [ Debug3
        DLINE   "No address conversion"
 ]
        MOV     LR, PC                          ; set up link for return to MOV SB,R7
        LDR     PC, [R7,#:INDEX:FS_LowLevel]    ; do the low level op

20

 |
        MOV     LR, PC                  ;set up link for return to MOV SB,R7
        LDR     PC, [R7,#:INDEX:FS_LowLevel] ; do the low level op
 ]
 [ Debug3; :LOR: DebugBA :LOR: Debug3L

        DLINE   "d",cc
        DREG    r0,"Regs out of child:",cc
        DREG    r1,,cc
        DREG    r2,,cc
        DREG    r3,,cc
        DREG    r4,,cc
        DREG    r5
 ]
        MOV     SB, R7
        BL      InternalFromParent
        EOR     R2, R2, #bit31          ;convert to internal drive numbering
 [ Debug3

        DLINE   "disc op  disc add start    length   disc rec  cache    >RetryDriveOp"
        DREG    R1," ",cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," ",cc
        DREG    R5," ",cc
        DREG    R6
 ]
        BVC     %FT99
95
        BL      SetVOnR0
        STRVS   R0, [SP]
99
        STRB    R8, Interlocks          ;restore entry interlocks
        Pull    "R0,R6-R8,PC"

; These emergency values are for the case where these fields are 0
      [ BigSectors
Emergency_SectorSize * 12
      |
Emergency_SectorSize * 10
      ]
Emergency_Heads * 1
Emergency_SecsPerTrk * 1

; ================
; DoCachedReadSecs
; ================

; Perform a read of a number of sectors, via a cache.  When using BigDisc,
; will only work with sector aligned addresses.  Otherwise works with
; non-aligned addresses, though the PRM defines it not to work non-aligned.

DoCachedReadSecs ROUT
        ; R7 = Amount left
        MOV     R7, R4
        LDRB    R8, [R5, #DiscRecord_Log2SectorSize]
        TEQ     R8, #0
        MOVEQ   R8, #Emergency_SectorSize
10
 [ BigDisc
        ; calculate length to transfer upper bounded by next
        ; sector boundary.
        MOV     LR, #1
        MOV     LR, LR, ASL R8          ; length of single sector
        CMP     R7, LR
        MOVHS   R4, LR
        MOVLO   R4, R7
 |
        ; Calculate length to transfer upper bounded by
        ; the next sector boundary
        MOV     LR, R2, LSR R8
        ADD     LR, LR, #1
        RSB     LR, R2, LR, ASL R8      ; start of next sector - start of Tx in this sector
        CMP     R7, LR
        MOVHS   R4, LR
        MOVLO   R4, R7
 ]

        ; Remove that from the amount left and do the readsector
        SUB     R7, R7, R4
        BL      DoCachedReadSector
        BVS     %FT20

        ; If there's more go around for another go
        TEQ     R7, #0
        BNE     %BT10

20
        ; All done, let's return
        ADD     R4, R7, R4
        STRVS   R0, [SP]
        STR     R6, [SP, #1*4]
        Pull    "R0,R6-R8,PC"

; ------------------
; DoCachedReadSector
; ------------------
;
; On entry:           On Exit
;  R0                  IF error V set, R0 result
;  R1 = Op with flags
;  R2 = Disc Address   End Disc Address         TOP 3 BITS DRIVE
;  R3 = RAM start      Ram End
;  R4 = Length         Untransferred
;  R5 ->disc rec
;  R6 ->sector cache   extended sector cache
;
; Note that the transfer must be within one sector.
;
; As above, when we're using BigDisc, the addresses have
; to be sector aligned as the addrs are now sector addrs
; instead of byte addrs.

 [ BigDisc

; sector addressed version of DoCachedReadSector

DoCachedReadSector ROUT
        Push    "r0-r1,r7-r11,LR"
 [ DebugM
        DREG    r1,"CacheReadSector(",cc
        DREG    r2,",",cc
        DREG    r3,",",cc
        DREG    r4,",",cc
        DREG    r5,",",cc
        DREG    r6,",",cc
 ]

        ; Convert from disc address to cache disc address
        ; which involves extracting side, track information and
        ; putting it back together as a disc address assuming
        ; one particular encoding.

        ; Extract the sector offset within a track

        ; R9 = SectorsPerTrack
        LDRB    R9, [R5, #DiscRecord_SecsPerTrk]
        TEQ     R9, #0
        MOVEQ   R9, #Emergency_SecsPerTrk

 [ DebugM
        DREG    r9, "Secs per trk="
 ]

        ; R7 = Track (in user's track space)
        ; R8 = Offset into track
        BIC     R8, R2, #DiscBits
 [ DebugM
        DREG    r9, "Sector per track into DivRem = "
 ]
        DivRem  R7, R8, R9, LR

        LDRB    LR, [R5, #DiscRecord_LowSector]
        TST     LR, #DiscRecord_SequenceSides_Flag
        BEQ     %FT05

        ; Split the track into cylinder and side if sides are sequenced in user's space

        ; R10 = cylinders per disc
        LDRB    LR, [R5, #DiscRecord_Heads]
        TEQ     LR, #0
        MOVEQ   LR, #Emergency_Heads
        ADD     LR, LR, #1              ; Adjust due to sequenced sides
        MUL     R9, LR, R9              ; sectors per cylinder
        LDR     R11, [R5, #DiscRecord_DiscSize]
        LDR     LR, [R5, #DiscRecord_Log2SectorSize]
        TEQ     LR, #0
        MOVEQ   LR, #Emergency_SectorSize
 [ BigDisc
        MOV     R11, R11, LSR LR        ; sectors per disc
        RSB     LR, LR, #32
        Push    "R12"
        LDR     R12, [R5, #DiscRecord_BigMap_DiscSize2]
        ORR     R11, R11, R12, LSL LR
        Pull    "R12"
 ]

 [ DebugM
        DREG    r9, "DiscSize/sectors per cylinder into DivRem = "
 ]
        DivRem  R10, R11, R9, LR

        ; R9 = side
        ; R7 = cylinder
 [ DebugM
        DREG    r10, "Cylinders into DivRem = "
 ]
        DivRem  R9, R7, R10, LR

        B       %FT10
05
        ; split the track into cylinder and side if the sides are interleaved in user's space

        ; R9 = side (remainder after division by #sides (= #Heads)
        ; R7 = cylinder
        MOV     R9, R7
        LDRB    R10, [R5, #DiscRecord_Heads]
        TEQ     R10, #0
        MOVEQ   R10, #Emergency_Heads
 [ DebugM
        DREG    r10, "Heads to DivRem = "
 ]
        DivRem  R7, R9, R10, LR


10
        ; R7 = cylinder# in user's space
        ; R8 = Offset into track
        ; R9 = side

        ; Double the cylinder number if the user's asked for double step
        LDRB    LR, [R5, #DiscRecord_LowSector]
        TST     LR, #DiscRecord_DoubleStep_Flag
        MOVNE   r7, r7, ASL #1

        ; R7 = cylinder number in real, internal, space
        ; R8 = Offset into track
        ; R9 = Track's side

        ; Combine the above into an internal sector number, which is a normal
        ; disc address assuming:
        ; *  Interleaved sides
        ; *  Single stepping
        LDRB    R10, [R5, #DiscRecord_Heads]
        TEQ     R10, #0
        MOVEQ   R10, #Emergency_Heads
        LDRB    LR, [R5, #DiscRecord_LowSector]
        TST     LR, #DiscRecord_SequenceSides_Flag
        ADDNE   R10, R10, #1
        MLA     R7, R10, R7, R9
        LDRB    R9, [R5, #DiscRecord_SecsPerTrk]
        TEQ     R9, #0
        MOVEQ   R9, #Emergency_SecsPerTrk
        MUL     R7, R9, R7
        LDRB    R9, [R5, #DiscRecord_Log2SectorSize]
        TEQ     R9, #0
        MOVEQ   R9, #Emergency_SectorSize

        ADD     R7, R7, R8
        AND     LR, R2, #DiscBits
        ORR     R7, R7, LR

        ; R7 = Disc address of start of sector (internal disc addressing)
        ; R8 = Used to be Offset into sector of start of transfer, now nothing
 [ DebugM
        DREG    r7, "ISector is ",cc
 ]

        ; Scan the cache for the required sector
        MOV     R9, R6
        B       %FT20

15
        LDR     R10, [R9, #SectorCache_Address]
        TEQ     R10, R7
        BEQ     %FT45
        LDR     R9, [R9, #SectorCache_Next]
20
        TEQ     R9, #0
        BNE     %BT15

        ; We've run out of sector cache, so let's get the sector off
        ; disc into the sector cache (if possible)
        Push    "r2,r3"
        MOV     R3, #1
        LDRB    LR, [R5, #DiscRecord_Log2SectorSize]
        TEQ     LR, #0
        MOVEQ   LR, #Emergency_SectorSize
        MOV     R3, R3, ASL LR
        ADD     R3, R3, #SectorCache_HeaderSize
        MOV     R0, #ModHandReason_Claim
        BL      OnlyXOS_Module
        Pull    "r2, r3", VS
        BVS     %FT25

        ; Link the new block into the cache chain
        STR     R6, [R2, #SectorCache_Next]
        MOV     R6, R2

        ; Pass the address of the new cache block forward for reading into
        MOV     R9, R2
        Pull    "r2, r3"
        B       %FT40

25
        ; Claim didn't work - check for any sector cache and use some if there is
        CLRV
        MOV     R0, #0          ; pointer to candidate
        MOV     R1, #&ffffffff  ; rank of candidate (lots)
        MOV     R9, R6
        B       %FT35

30
        ; Record this if it's used less than candidate
        LDR     R8, [R9, #SectorCache_Usage]
        CMP     R8, R1
        MOVLO   R0, R9
        MOVLO   R1, R8

        ; Move to next
        LDR     R9, [R9, #SectorCache_Next]

35
        ; Check if list's run out
        TEQ     R9, #0
        BNE     %BT30

        ; Lists's run out - check for candidate
        MOVS    R9, R0
        BEQ     %FT50

40
        ; R2 = disc address to ultimately read from
        ; R3 = RAM destination for read
        ; R4 = Length of transfer
        ; R5 = Disc record^
        ; R6 = Cache chain^
        ; R7 = Internal disc address of sector start
        ; R9 -> block in sector cache to fill in
 [ DebugM
        DREG    r2, "ESector ",cc
        DREG    r7, ", ISector ",cc
        DREG    r3, ", RAM ",cc
        DREG    r4, ", Len ",cc
        DREG    r5, ", rec ",cc
        DREG    r6, ", cache ",cc
        DREG    r9, ", cacheblock "
 ]

        ; Read a sector to cache block at R9
        Push    "R3, R4"
        LDRB    LR, [R5, #DiscRecord_Log2SectorSize]
        TEQ     LR, #0
        MOVEQ   LR, #Emergency_SectorSize
        MOV     R4, #1
        MOV     R4, R4, ASL LR
        MOV     R8, R2
        ADD     R3, R9, #SectorCache_Contents
        LDRB    R1, [sp, #1*4 + 2*4]
        AND     R1, R1, #DiscOp_Op_AltDefectList_Flag :OR: DiscOp_Op_Atomic_Flag
        ORR     R1, R1, #DiscOp_ReadSecs
        BL      RetryDriveOp
        Pull    "R3,R4"
        MOVVC   R0, #0
        STR     R0, [R9, #SectorCache_Error]
        MOV     R0, #0
        STR     R0, [R9, #SectorCache_Usage]
        STR     R7, [R9, #SectorCache_Address]

        ; Restore the real disc address
        MOV     R2, R8

        CLRV

45
        ; R2 = disc address to ultimately read from
        ; R3 = RAM destination for read
        ; R4 = Length of transfer
        ; R5 = Disc record^
        ; R6 = Cache chain^
        ; R9 -> block in sector cache which is filled in

        ; Found the sector, and its cache address is in R9
        LDR     R0, [R9, #SectorCache_Error]
        TEQ     R0, #0
        BNE     %FT90

        ; Found sector and it's error free, so let's copy it
        Push    "R2"
        LDR     R0, [R9, #SectorCache_Usage]
        ADD     R0, R0, #1
        STR     R0, [R9, #SectorCache_Usage]
        ADD     R0, R9, #SectorCache_Contents
        MOV     R1, R3
        MOV     R2, R4
 [ DebugM
        DREG    R3, "RAM dest "
        DREG    R4, "Transfer length "

 ]
        BL      BlockMove
        Pull    "R2"
        LDRB    LR, [R5,#DiscRecord_Log2SectorSize]
        TEQ     LR, #0
        MOVEQ   LR,#Emergency_SectorSize
        ADD     R2, R2, R4, LSR LR
        ADD     R3, R3, R4
        MOV     R4, #0
        B       %FT95

50
        ; R2 = disc address to ultimately read from
        ; R3 = RAM destination for read
        ; R4 = Length of transfer
        ; R5 = Disc record^
        ; R6 = Cache chain^

        ; No available cache entry to use -
        ; Read to stack, then copy to user's memory

        ; Get DiscOp together before drop stack pointer
        LDR     R1, [sp, #1*4]
        AND     R1, R1, #DiscOp_Op_AltDefectList_Flag :OR: DiscOp_Op_Atomic_Flag
        ORR     R1, R1, #DiscOp_ReadSecs

        ; Get a stack frame one sector big
        MOV     LR, #1
        LDRB    R10, [R5, #DiscRecord_Log2SectorSize]
        TEQ     R10, #0
        MOVEQ   R10, #Emergency_SectorSize
        MOV     R10, LR, ASL R10
        SUB     SP, SP, R10

        ; R8 = RAM destination of transfer
        ; R9 = length of transfer
        MOV     R8, R3
        MOV     R9, R4

        ; Read sector to stack frame
        MOV     R3, SP
        MOV     R4, R10
 [ DebugM

        DREG    r1, "RetryDriveOpNoRMA(",cc
        DREG    r2,",",cc
        DREG    r3,",",cc
        DREG    r4,",",cc
        DREG    r5,",",cc
        DLINE   ")"
 ]
        BL      RetryDriveOp
 [ DebugM
        BVC     %FT01
        DREG    r0, "Gives error:"
01
 ]
        BVS     %FT60

        ; Copy part of frame of interest to RAM
        MOV     R0, SP
        MOV     R1, R8
        Push    "r2"
        MOV     R2, R9
        BL      BlockMove
        Pull    "R2"

        ADD     R3, R8, R9      ; construct RAM end
        MOV     R4, #0          ; bytes left

60
        ; Lose stack frame
        ADD     SP, SP, R10

        B       %FT95

90
        BL      SetV
95
        STRVS   R0, [SP]
 [ DebugM

        DREG    r2,")->(",cc
        DREG    r3,",",cc
        DREG    r4,",",cc
        DREG    r5,",",cc
        DREG    r6,",",cc
        BVC     %FT01
        DREG    r0,",VS:",cc
        B       %FT02
01
        DLINE   ",VC",cc
02
        DLINE   ")"
 ]
        Pull    "R0-R1,R7-R11,PC"



; end of sector addressed version


 |


; OLD VERSION OF DoCachedReadSector - byte addressing


DoCachedReadSector ROUT
        Push    "r0-r1,r7-r11,LR"
 [ DebugM
        DREG    r1,"CacheReadSector(",cc
        DREG    r2,",",cc
        DREG    r3,",",cc
        DREG    r4,",",cc
        DREG    r5,",",cc
        DREG    r6,",",cc
 ]

        ; Convert from disc address to cache disc address
        ; which involves extracting side, track information and
        ; putting it back together as a disc address assuming
        ; one particular encoding.

        ; Extract the byte offset within a track

        ; R9 = BytesPerTrack
        LDRB    LR, [R5, #DiscRecord_Log2SectorSize]
        TEQ     LR, #0
        MOVEQ   LR, #Emergency_SectorSize
        LDRB    R7, [R5, #DiscRecord_SecsPerTrk]
        TEQ     R7, #0
        MOVEQ   R7, #Emergency_SecsPerTrk
        MOV     R9, R7, ASL LR
 [ DebugM
        DREG    r7, "Secs per trk="
        MOV     r7, lr
        DREG    r7, "Sector size="
        DREG    r9, "Bytes per trk ="
 ]

        ; R7 = Track (in user's track space)
        ; R8 = Offset into track
        BIC     R8, R2, #DiscBits
 [ DebugM
        DREG    r9, "Bytes per track into DivRem = "
 ]
        DivRem  R7, R8, R9, LR

        LDRB    LR, [R5, #DiscRecord_LowSector]
        TST     LR, #DiscRecord_SequenceSides_Flag
        BEQ     %FT05

        ; Split the track into cylinder and side if sides are sequenced in user's space

        ; R10 = cylinders per disc
        LDRB    LR, [R5, #DiscRecord_Heads]
        TEQ     LR, #0
        MOVEQ   LR, #Emergency_Heads
        ADD     LR, LR, #1              ; Adjust due to sequenced sides
        MUL     R9, LR, R9              ; bytes per cylinder
        LDR     R11, [R5, #DiscRecord_DiscSize]
 [ DebugM
        DREG    r9, "DiscSize/bytes per cylinder into DivRem = "
 ]
        DivRem  R10, R11, R9, LR

        ; R9 = side
        ; R7 = cylinder
 [ DebugM
        DREG    r10, "Cylinders into DivRem = "
 ]
        DivRem  R9, R7, R10, LR

        B       %FT10
05
        ; split the track into cylinder and side if the sides are interleaved in user's space

        ; R9 = side (remainder after division by #sides (= #Heads)
        ; R7 = cylinder
        MOV     R9, R7
        LDRB    R10, [R5, #DiscRecord_Heads]
        TEQ     R10, #0
        MOVEQ   R10, #Emergency_Heads
 [ DebugM
        DREG    r10, "Heads to DivRem = "
 ]
        DivRem  R7, R9, R10, LR


10
        ; R7 = cylinder# in user's space
        ; R8 = Offset into track
        ; R9 = side

        ; Double the cylinder number if the user's asked for double step
        LDRB    LR, [R5, #DiscRecord_LowSector]
        TST     LR, #DoubleStep
        MOVNE   r7, r7, ASL #1

        ; R7 = cylinder number in real, internal, space
        ; R8 = Offset into track
        ; R9 = Track's side

        ; Combine the above into an internal sector number, which is a normal
        ; disc address assuming:
        ; *  Interleaved sides
        ; *  Single stepping
        LDRB    R10, [R5, #DiscRecord_Heads]
        TEQ     R10, #0
        MOVEQ   R10, #Emergency_Heads
        LDRB    LR, [R5, #DiscRecord_LowSector]
        TST     LR, #DiscRecord_SequenceSides_Flag
        ADDNE   R10, R10, #1
        MLA     R7, R10, R7, R9
        LDRB    R9, [R5, #DiscRecord_SecsPerTrk]
        TEQ     R9, #0
        MOVEQ   R9, #Emergency_SecsPerTrk
        MUL     R7, R9, R7
        LDRB    R9, [R5, #DiscRecord_Log2SectorSize]
        TEQ     R9, #0
        MOVEQ   R9, #Emergency_SectorSize
        ADD     R7, R7, R8, LSR R9
        MOV     R7, R7, ASL R9
        RSB     R9, R9, #32
        MOV     R8, R8, ASL R9
        MOV     R8, R8, LSR R9
        AND     LR, R2, #DiscBits
        ORR     R7, R7, LR

        ; R7 = Disc address of start of sector (internal disc addressing)
        ; R8 = Offset into sector of start of transfer
 [ DebugM
        DREG    r7, "ISector is ",cc
        DREG    r8, ", byte offset is "
 ]

        ; Scan the cache for the required sector
        MOV     R9, R6
        B       %FT20

15
        LDR     R10, [R9, #SectorCache_Address]
        TEQ     R10, R7
        BEQ     %FT45
        LDR     R9, [R9, #SectorCache_Next]
20
        TEQ     R9, #0
        BNE     %BT15

        ; We've run out of sector cache, so let's get the sector off
        ; disc into the sector cache (if possible)
        Push    "r2,r3"
        MOV     R3, #1
        LDRB    LR, [R5, #DiscRecord_Log2SectorSize]
        TEQ     LR, #0
        MOVEQ   LR, #Emergency_SectorSize
        MOV     R3, R3, ASL LR
        ADD     R3, R3, #SectorCache_HeaderSize
        MOV     R0, #ModHandReason_Claim
        BL      OnlyXOS_Module
        Pull    "r2, r3", VS
        BVS     %FT25

        ; Link the new block into the cache chain
        STR     R6, [R2, #SectorCache_Next]
        MOV     R6, R2

        ; Pass the address of the new cache block forward for reading into
        MOV     R9, R2
        Pull    "r2, r3"
        B       %FT40

25
        ; Claim didn't work - check for any sector cache and use some if there is
        CLRV
        MOV     R0, #0          ; pointer to candidate
        MOV     R1, #&ffffffff  ; rank of candidate (lots)
        MOV     R9, R6
        B       %FT35

30
        ; Record this if it's used less than candidate
        LDR     R8, [R9, #SectorCache_Usage]
        CMP     R8, R1
        MOVLO   R0, R9
        MOVLO   R1, R8

        ; Move to next
        LDR     R9, [R9, #SectorCache_Next]

35
        ; Check if list's run out
        TEQ     R9, #0
        BNE     %BT30

        ; Lists's run out - check for candidate
        MOVS    R9, R0
        BEQ     %FT50

40
        ; R2 = disc address to ultimately read from
        ; R3 = RAM destination for read
        ; R4 = Length of transfer
        ; R5 = Disc record^
        ; R6 = Cache chain^
        ; R7 = Internal disc address of sector start
        ; R9 -> block in sector cache to fill in
 [ DebugM
        DREG    r2, "ESector ",cc
        DREG    r7, ", ISector ",cc
        DREG    r3, ", RAM ",cc
        DREG    r4, ", Len ",cc
        DREG    r5, ", rec ",cc
        DREG    r6, ", cache ",cc
        DREG    r9, ", cacheblock "
 ]

        ; Read a sector to cache block at R9
        Push    "R3, R4"
        LDRB    LR, [R5, #DiscRecord_Log2SectorSize]
        TEQ     LR, #0
        MOVEQ   LR, #Emergency_SectorSize
        MOV     R4, #1
        MOV     R4, R4, ASL LR
        MOV     R8, R2
        MOV     R2, R2, LSR LR
        MOV     R2, R2, ASL LR
        ADD     R3, R9, #SectorCache_Contents
        LDRB    R1, [sp, #1*4 + 2*4]
        AND     R1, R1, #DiscOp_Op_AltDefectList_Flag :OR: DiscOp_Op_Atomic_Flag
        ORR     R1, R1, #DiscOp_ReadSecs
        BL      RetryDriveOp
        Pull    "R3,R4"
        MOVVC   R0, #0
        STR     R0, [R9, #SectorCache_Error]
        MOV     R0, #0
        STR     R0, [R9, #SectorCache_Usage]
        STR     R7, [R9, #SectorCache_Address]

        ; Restore the real disc address
        MOV     R2, R8

        ; Get the offset into the block into R8
        LDRB    LR, [R5, #DiscRecord_Log2SectorSize]
        TEQ     LR, #0
        MOVEQ   LR, #Emergency_SectorSize
        MOV     R8, R8, LSR LR
        MOV     R8, R8, ASL LR
        BIC     R8, R2, R8

        CLRV

45
        ; R2 = disc address to ultimately read from
        ; R3 = RAM destination for read
        ; R4 = Length of transfer
        ; R5 = Disc record^
        ; R6 = Cache chain^
        ; R8 = Offset into sector to start transfer from
        ; R9 -> block in sector cache which is filled in

        ; Found the sector, and its cache address is in R9
        LDR     R0, [R9, #SectorCache_Error]
        TEQ     R0, #0
        BNE     %FT90

        ; Found sector and it's error free, so let's copy it
        Push    "R2"
        LDR     R0, [R9, #SectorCache_Usage]
        ADD     R0, R0, #1
        STR     R0, [R9, #SectorCache_Usage]
        ADD     R0, R9, #SectorCache_Contents
        ADD     R0, R0, R8
        MOV     R1, R3
        MOV     R2, R4
        BL      BlockMove
        Pull    "R2"
        ADD     R2, R2, R4
        ADD     R3, R3, R4
        MOV     R4, #0
        B       %FT95

50
        ; R2 = disc address to ultimately read from
        ; R3 = RAM destination for read
        ; R4 = Length of transfer
        ; R5 = Disc record^
        ; R6 = Cache chain^

        ; No available cache entry to use -
        ; Read to stack, then copy to user's memory

        ; Get DiscOp together before drop stack pointer
        LDR     R1, [sp, #1*4]
        AND     R1, R1, #DiscOp_Op_AltDefectList_Flag :OR: DiscOp_Op_Atomic_Flag
        ORR     R1, R1, #DiscOp_ReadSecs

        ; Get a stack frame one sector big
        MOV     LR, #1
        LDRB    R10, [R5, #DiscRecord_Log2SectorSize]
        TEQ     R10, #0
        MOVEQ   R10, #Emergency_SectorSize
        MOV     R10, LR, ASL R10
        SUB     SP, SP, R10

        ; R7 = offset into stack frame of transfer
        ; R8 = RAM destination of transfer
        ; R9 = length of transfer
        SUB     LR, R10, #1
        AND     R7, R2, LR
        MOV     R8, R3
        MOV     R9, R4

        ; Read sector to stack frame
        BIC     R2, R2, LR
        MOV     R3, SP
        MOV     R4, R10
 [ DebugM

        DREG    r1, "RetryDriveOpNoRMA(",cc
        DREG    r2,",",cc
        DREG    r3,",",cc
        DREG    r4,",",cc
        DREG    r5,",",cc
        DLINE   ")"
 ]
        BL      RetryDriveOp
 [ DebugM
        BVC     %FT01
        DREG    r0, "Gives error:"
01
 ]
        BVS     %FT60

        ; Copy part of frame of interest to RAM
        ADD     R0, SP, R7
        MOV     R1, R8
        Push    "r2"
        MOV     R2, R9
        BL      BlockMove
        Pull    "R2"
        SUB     R2, R2, R10     ; Original start of sector
        ADD     R2, R2, R7      ; +offset into sector
        ADD     R2, R2, R9      ; +bytes transfered
        ADD     R3, R8, R9      ; construct RAM end
        MOV     R4, #0          ; bytes left

60
        ; Lose stack frame
        ADD     SP, SP, R10

        B       %FT95

90
        BL      SetV
95
        STRVS   R0, [SP]
 [ DebugM

        DREG    r2,")->(",cc
        DREG    r3,",",cc
        DREG    r4,",",cc
        DREG    r5,",",cc
        DREG    r6,",",cc
        BVC     %FT01
        DREG    r0,",VS:",cc
        B       %FT02
01
        DLINE   ",VC",cc
02
        DLINE   ")"
 ]
        Pull    "R0-R1,R7-R11,PC"

 ]

; ==============
; GetDriveStatus
; ==============

; used to read low-level status info that cannot
; be read using something such as PollChange
; because PollChange cannot be called from
; background

; entry:
;
; R1=(internal) drive number
;
; exit:
;
; R2=drive status
; LR=0 <-> status not supported

GetDriveStatus ROUT
        Push    "R0,LR"
        LDR     LR, FS_Flags                    ; get status flags & check supported
        ANDS    LR, LR, #CreateFlag_DriveStatusWorks
 [ DebugDL
        BNE     %FT01
        DLINE   "GetDriveStatus: Not supported"
01
 ]
        Pull    "R0,PC", EQ                     ; not supported - LR will be 0
        MOV     R0, #MiscOp_DriveStatus         ; do the miscop
        BL      Parent_Misc
        STRVS   R0, [SP]                        ; if error then return it
        MOV     LR, #1
        Pull    "R0, PC"

; ========
; ClaimFiq
; ========

ClaimFiq ROUT
 [ Debug3

        DLINE   "ClaimFiq"
 ]
        Push    "R0-R3,LR"

        WritePSRc I_bit :OR: SVC_mode, R2,, R3  ;disable IRQ to prevent re-entrance (old PSR in R3)
        LDRB    R2, FiqOwnership
        TEQS    R2, #0
        BNE     %FT90                   ;already claimed

        WritePSRc SVC_mode, R1          ;can re-enable IRQs as cannot get background
        MOV     R1, #Service_ClaimFIQ   ;release unless at least one claim
        SWI     XOS_ServiceCall         ;(R1)
 [ HAL
        Push    "R2,R3,R8,R9"
        MOV     R8, #0
        MOV     R9, #EntryNo_HAL_FIQDisableAll
        SWI     XOS_Hardware
        Pull    "R2,R3,R8,R9"
 |
        MOV     R1, #IOC
        ASSERT  IOC    :MOD: 256 = 0
        MOV     LR, #0
        STRB    LR, [R1,#IOCFIQMSK]     ;Disable all FIQs
 ]
90
        ADD     R2, R2, #1
        STRB    R2, FiqOwnership
 [ DebugI
        DREG    R2,,cc
 ]
 [ Debug3

        DLINE   "FIQ claimed"
 ]
        RestPSR R3,,cf
        Pull    "R0-R3,PC"

; ==========
; ReleaseFiq
; ==========

ReleaseFiq ROUT
 [ Debug3

        DLINE   "*ReleaseFiq"
 ]
        Push    "R0-R3,LR"
        WritePSRc I_bit :OR: SVC_mode, R2,, R3  ;disable IRQ to prevent re-entrance (old PSR in R3)
        LDRB    R2, FiqOwnership
        SUBS    R2, R2, #1
        STRB    R2, FiqOwnership
        BNE     %FT90

        WritePSRc SVC_mode, R1          ;can reenable IRQs as background claim can't
 [ HAL
        Push    "R3,R8,R9"
        MOV     R8, #0
        MOV     R9, #EntryNo_HAL_FIQDisableAll
        SWI     XOS_Hardware
        Pull    "R3,R8,R9"
 |
        MOV     R1, #IOC                ;succeed until after release
        STRB    R2, [R1,#IOCFIQMSK]     ;Disable all FIQs
 ]
        MOV     R1, #Service_ReleaseFIQ
        SWI     XOS_ServiceCall         ;(R1)
90
 [ DebugI
        DREG    R2,,cc
 ]
 [ Debug3

        DLINE   "FIQ Released"
 ]
        RestPSR R3,,cf
        Pull    "R0-R3,PC"


; ==================
; BackgroundClaimFiq
; ==================

;Exit EQ <=> succeeded

BackgroundClaimFiq ROUT
 [ Debug3 :LOR: DebugG

        DLINE   "BackgroundClaimFiq"
 ]
        Push    "R0-R3,LR"
        LDRB    LR, BackgroundFiqLock
        TEQS    LR, #0
        Pull    "R0-R3,PC",NE

        WritePSRc I_bit :OR: SVC_mode, R2,, R3    ;disable IRQ to prevent re-entrance
        LDRB    R2, FiqOwnership
        TEQS    R2, #0
        BNE     %FT90                   ;already claimed

        LDR     R1, ptr_IRQsema
        LDR     R1, [R1]
        TEQS    R1, #0
        MOVEQ   R1, #Service_ClaimFIQ
        MOVNE   R1, #Service_ClaimFIQinBackground
        SWI     XOS_ServiceCall         ;(R1)
        TEQS    R1, #0
        TEQNES  R1, #Service_ClaimFIQ
        BICNE   R3, R3, #Z_bit
        BNE     %FT99                   ;if claim failed return NE

 [ HAL
        Push    "R2,R3,R8,R9"
        MOV     R8, #0
        MOV     R9, #EntryNo_HAL_FIQDisableAll
        SWI     XOS_Hardware
        Pull    "R2,R3,R8,R9"
 |
        MOV     R1, #IOC
        MOV     LR, #0
        STRB    LR, [R1,#IOCFIQMSK]    ;Disable all FIQs
 ]
90
        ADD     R2, R2, #1
        STRB    R2, FiqOwnership
 [ DebugI

        DLINE   " C0 ",cc
        DREG    R2,,cc
 ]
 [ Debug3 :LOR: DebugG

        DLINE   "FIQ claimed"
 ]
        ORR     R3, R3, #Z_bit          ;if claim succeeded return EQ
99
        RestPSR R3,,cf
        Pull    "R0-R3,PC"


        LTORG

InitialiseHardware
 [ HAL
        Push    "R0,R1,R8,R9,LR"
        MOV     R8, #1
        MOV     R9, #EntryNo_HAL_CounterRead
        SWI     XOS_Hardware
        ADRVS   R0, My_CounterReadCall
        STR     R0, CounterReadCall
        STR     R1, CounterReadWs
        Pull    "R0,R1,R8,R9,PC"
 |
        ADR     R0, My_CounterReadCall
        STR     R0, CounterReadCall
        MOV     PC, LR
 ]

My_CounterReadCall
        MOV     ip, lr
        MOV     r0, #IOC
        STRB    r1, [r0, #Timer0LR]
        LDRB    r1, [r0, #Timer0CL]
        LDRB    lr, [r0, #Timer0CH]
        ORR     lr, lr, r1, ASL #8
        MOV     pc, ip

        END
@


4.19
log
@Regroup some debug, comment corrections
Switch 'DebugM' now used exclusively for the read cached sectors disc op, and DebugMt for multifs extensions.
Various spelling mistakes corrected in passing.
Same (non debug) binary, retagged as FileCore-3_64.
@
text
@d436 1
@


4.18
log
@Add support for 2k and 4k sector sizes
s/Commands:
Make sure the defect list (via *DEFECT) does a read/modify/write of the boot block on 2k and 4k drives.
The checksum generation code was largely common and although commented to be called as though it was common wasn't actually due to a cut and paste mistake on label 37. Deleted common/uncalled code.
s/DebugOpts; s/FileCore15:
Peripheral changes.
s/FileCore20:
Read in the defect list via an intermediate buffer then copy out into the dynamic area.
s/FileCore70:
Declare the buffer size as 4k to FileSwitch, internally FileCore expresses this in a single byte * 32 so is now at the limit of the range of FcbBufSz.
s/FileCore80:
Perform transfers in the foreground when the sector size exceeds FileCore's 1k buffers. It's not worth bothering.
s/FormSWIs; s/Identify:
Vet and reject attempts to layout invalid zone/sector size combos (see Doc/1Zone).
Doc/MiscOp:
Correct a couple of calculation mistakes.
Doc/1Zone:
New documentation detailing the possible valid combinations of a 1 zone fixed disc, and why for 2k and 4k sectors this is rejected.
Test/BigSectors:
Patch to apply to RAMFS to make it a 4k filing system. Note, the smallest 2 zone RAM disc with 4k sectors is 4052kB, in which case the map is at +3F0000; copy at +3F2000; root directory object at +3F4000.

Version 3.63. Tagged as 'FileCore-3_63'
@
text
@d1083 1
a1083 1
 [ DebugMt
d1120 1
a1120 1
        ; Split the track into cylander and side if sides are sequenced in user's space
d1155 1
a1155 1
        ; split the track into cylander and side if the sides are interleaved in user's space
d1414 1
a1414 1
        ; Loose stack frame
d1423 1
a1423 1
 [ DebugMt
d1453 1
a1453 1
 [ DebugMt
d1496 1
a1496 1
        ; Split the track into cylander and side if sides are sequenced in user's space
d1519 1
a1519 1
        ; split the track into cylander and side if the sides are interleaved in user's space
d1792 1
a1792 1
        ; Loose stack frame
d1801 1
a1801 1
 [ DebugMt
@


4.17
log
@Minor tidy ups
Service call table made unconditional.
Typo in Hdr:FileCore corrected.
Comments improved, and other misc housekeeping.

Version 3.62. Tagged as 'FileCore-3_62'
@
text
@d1000 3
d1004 1
@


4.16
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d869 1
a869 1
        CMPS    LR, #DefectEndMark
@


4.15
log
@Swap out some more constants for symbolic names
* OsBytes
* Application start &8000
* Fixed disc density
* Unused a4 macro deleted
* Redundant 'todo', 'Help, 'Syntax' removed

Version 3.53. Not tagged
@
text
@d249 1
a249 1
        mess    ,NL
@


4.14
log
@Fold in old fixes.
From 1989, probably safe to keep them. Binary unchanged.

Version 3.47. Tagged as 'FileCore-3_47'
@
text
@d100 1
a100 1
        MOV     R0, #3
d110 1
a110 1
        MOV     R0, #3
@


4.13
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d701 1
a701 1
        ; Check the drive number - this covers fix_2 completely
@


4.12
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d370 5
a374 5
        DREG   R1," ",cc
        DREG   R2," ",cc
        DREG   R3," ",cc
        DREG   R4," ",cc
        DREG   R5," "
d380 1
a380 1
        MOV     R6, R3			;save RAM ptr
d382 2
a383 2
        BL      TestMap			;(R3->Z)
        BEQ     %FT50			;if new map
d386 2
a387 2
	; this remains true on 'big' discs, but we have to squash the disc
	; address into a sector address
d390 1
a390 1
	MOV	R3,R6			; restore RAM ptr
d395 7
a401 7
        MOV	R6,R2,LSR #(32-3)	; get drive bits
	DiscRecPtr R7,R6		; get disc record
	LDRB	R7,[R7,#SectorSize]	; get the sector size
	BIC	R2,R2,#DiscBits		; disc address bits
	MOV	R2,R2,LSR R7		; change to sector address
	ADD	R2,R2,R5, LSR R7	; disc address to start at
	ORR	R2,R2,R6,LSL #(32-3)	; drive number back in
d403 1
a403 1
	MOV	R6,R4			; length
d407 2
a408 2
        SUB     R6, R6, R4		;amount transferred
        ADD     R5, R5, R6		;increment start offset
d411 2
a412 2
        MOV     R3, R6			;restore RAM ptr
        ADD     R2, R2, R5		;disc address to start at.
d414 1
a414 1
        BL      DoDiscOp		;(R1-R4->R0-R4,V)
d416 2
a417 2
        SUB     R6, R6, R4		;amount transferred
        ADD     R5, R5, R6		;increment start offset
d455 2
a456 2
        CMPS    R4, R7		;(R4 is the amount left in the fragment)
        BICLS   R1, R1, #BackgroundOp
d463 1
a463 1
        EOR     R6, R1, #BackgroundOp
d471 1
a471 1
        TSTS    R6, #BackgroundOp       ;AND last sub op not background
d499 6
a504 6
        DREG   R1," ",cc
        DREG   R2," ",cc
        DREG   R3," ",cc
        DREG   R4," ",cc
        DREG   R5," ",cc
        DREG   R0," "
d511 1
a511 1
        TSTS    R6, #BackgroundOp               ; preserves V
d526 3
a528 3
        ASSERT  ReadSecsOp=1
        ASSERT  WriteSecsOp=2
        TSTS    R1, #WriteSecsOp
d546 1
a546 1
        TST     LR, #NewErrorSupport            ; to new scheme if module uses it
d623 1
a623 1
	DLINE	"RetryDiscOp"
d668 2
a669 2
        TSTS    R1, #ScatterBit		; check for scatter list
        BEQ     %FT01			; if not, skip code to handle it...
d672 1
a672 1
        MOV     LR, R4			; take copy of length to count down thru scatter list
d674 1
a674 1
	LDRB	R4,[R5,#SectorSize]	; get sector size
d676 1
a676 1
        MOV     R0, R3			; take copy of scatter list ptr
d680 1
a680 1
        LDMIA   R0!,{R6,R7}		; get a scatter list entry
d682 1
a682 1
        MOVHI   R7, LR			; ...make it same size
d693 2
a694 2
        SUBS    LR, LR, R7		; count down length and if still more left...
        BNE     %BT00			; ...back to start of loop
d710 2
a711 2
        AND     lr, r1, #OpMask
        TEQ     lr, #VerifyOp                   ; Verify doesn't affect LastDiscOpWasFormat
d713 1
a713 1
        TEQ     lr, #WriteTrkOp
d733 1
a733 1
        LDRB    lr, [r5, #SectorSize]
d735 1
a735 1
        LDRB    lr, [r5, #SecsPerTrk]
d737 1
a737 1
        LDRB    lr, [r5, #Heads]
d739 1
a739 1
        LDRB    lr, [r5, #Density]
d741 1
a741 1
        LDRB    lr, [r5, #LowSector]
d743 1
a743 1
        LDR     lr, [r5, #DiscSize]
d746 1
a746 1
        LDR     lr, [r5, #DiscSize2]
d753 2
a754 2
        AND     LR, R1, #OpMask
        TEQ     LR, #CachedReadSecsOp
a758 1
        TEQS    R1, R1, LSR #BackgroundBitNo + 1        ;C=1 <=> BackgroundOp
d760 2
d773 3
a775 3
        ASSERT  ReadSecsOp=1
        ASSERT  WriteSecsOp=2
        TSTS    R7, #WriteSecsOp
d795 2
a796 2
        AND     LR, R7, #OpMask
        CMP     LR, #WriteSecsOp
d812 1
a812 1
        AND     LR, R7, #OpMask
d817 2
a818 2
        TEQ     lr, #ReadTrkOp
        TEQNE   lr, #WriteTrkOp
d823 1
a823 1
        LDR     LR, [R5,#DiscSize]
d827 4
a830 4
	Push	"R6,R7"			; convert disc size to sectors
	LDRB	R6,[R5,#SectorSize]
	MOV	LR, LR, LSR R6
	LDR	R7, [R5,#DiscSize2]
d833 1
a833 1
	Pull	"R6,R7"
d846 1
a846 1
        ; if AltDefectBit then On the end of the disc record
d849 1
a849 1
        TST     R1, #AltDefectBit
d883 2
a884 2
        MOVEQ   R0, #WinnieNeedsFiq
        MOVNE   R0, #FloppyNeedsFiq
d912 3
a914 3
	LDR	LR, [R7,#:INDEX:FS_Flags]	; get the flags for filing system
	TST	LR, #BigDiscSupport		; does this FS use big addrs?
	BNE	%FT10				; skip code to adjust addrs
d922 1
a922 1
	Push	"R3,R6"
d924 4
a927 4
	LDRB	R6, [R5,#SectorSize]		; sector size
	AND	LR, R2, #DiscBits		; drive in LR
	BIC	R2, R2, #DiscBits		; disc offset (sector) in R2
	MOV	R3, R2, LSL R6			; convert to byte addr
d930 4
a933 4
	ORREQ	R2, R3, LR			; recombine with drive no
	Pull	"R3,R6"
        MOVNE	R0,#BadParmsErr			; error
	BNE	%FT95
d943 2
a944 2
        MOV     LR, PC                  	; set up link for return to MOV SB,R7
        LDR     PC, [R7,#:INDEX:FS_LowLevel] 	; do the low level op
d946 5
a950 5
	LDRB	R6, [R5, #SectorSize]		; get sector size
	AND	LR, R2, #DiscBits		; disc bits in LR
	BIC	R2, R2, #DiscBits		; offset in R2
	MOV	R2, R2, LSR R6			; back to sectors
	ORR	R2, R2, LR  			; put drive back in
d952 1
a952 1
	B	%FT20				;
d959 2
a960 2
	MOV	LR, PC				; set up link for return to MOV SB,R7
        LDR     PC, [R7,#:INDEX:FS_LowLevel]	; do the low level op
d1015 1
a1015 1
        LDRB    R8, [R5, #SectorSize]
d1020 4
a1023 4
	; calculate length to transfer upper bounded by next
	; sector boundary.
	MOV	LR, #1
        MOV     LR, LR, ASL R8		; length of single sector
d1096 1
a1096 1
        LDRB    R9, [R5, #SecsPerTrk]
d1112 2
a1113 2
        LDRB    LR, [R5, #LowSector]
        TST     LR, #SequenceSides
d1119 1
a1119 1
        LDRB    LR, [R5, #Heads]
d1124 4
a1127 4
        LDR     R11, [R5, #DiscSize]
	LDR	LR, [R5, #SectorSize]
	TEQ	LR, #0
	MOVEQ	LR, #Emergency_SectorSize
d1129 6
a1134 6
	MOV	R11, R11, LSR LR	; sectors per disc
	RSB	LR, LR, #32
	Push	"R12"
	LDR	R12, [R5, #DiscSize2]
	ORR	R11, R11, R12, LSL LR
	Pull	"R12"
d1156 1
a1156 1
        LDRB    R10, [R5, #Heads]
d1171 2
a1172 2
        LDRB    LR, [R5, #LowSector]
        TST     LR, #DoubleStep
d1183 1
a1183 1
        LDRB    R10, [R5, #Heads]
d1186 2
a1187 2
        LDRB    LR, [R5, #LowSector]
        TST     LR, #SequenceSides
d1190 1
a1190 1
        LDRB    R9, [R5, #SecsPerTrk]
d1194 1
a1194 1
        LDRB    R9, [R5, #SectorSize]
d1225 1
a1225 1
        LDRB    LR, [R5, #SectorSize]
d1291 1
a1291 1
        LDRB    LR, [R5, #SectorSize]
d1299 2
a1300 2
        AND     R1, R1, #AltDefectBit :OR: NoEscape :OR: NoTimeOut
        ORR     R1, R1, #ReadSecsOp
d1336 2
a1337 2
	DREG	R3, "RAM dest "
	DREG	R4, "Transfer length "
d1342 3
a1344 3
	LDRB	LR, [R5,#SectorSize]
	TEQ	LR, #0
	MOVEQ	LR,#Emergency_SectorSize
d1362 2
a1363 2
        AND     R1, R1, #AltDefectBit :OR: NoEscape :OR: NoTimeOut
        ORR     R1, R1, #ReadSecsOp
d1367 1
a1367 1
        LDRB    R10, [R5, #SectorSize]
d1466 1
a1466 1
        LDRB    LR, [R5, #SectorSize]
d1469 1
a1469 1
        LDRB    R7, [R5, #SecsPerTrk]
d1488 2
a1489 2
        LDRB    LR, [R5, #LowSector]
        TST     LR, #SequenceSides
d1495 1
a1495 1
        LDRB    LR, [R5, #Heads]
d1500 1
a1500 1
        LDR     R11, [R5, #DiscSize]
d1520 1
a1520 1
        LDRB    R10, [R5, #Heads]
d1535 1
a1535 1
        LDRB    LR, [R5, #LowSector]
d1547 1
a1547 1
        LDRB    R10, [R5, #Heads]
d1550 2
a1551 2
        LDRB    LR, [R5, #LowSector]
        TST     LR, #SequenceSides
d1554 1
a1554 1
        LDRB    R9, [R5, #SecsPerTrk]
d1558 1
a1558 1
        LDRB    R9, [R5, #SectorSize]
d1593 1
a1593 1
        LDRB    LR, [R5, #SectorSize]
d1659 1
a1659 1
        LDRB    LR, [R5, #SectorSize]
d1669 2
a1670 2
        AND     R1, R1, #AltDefectBit :OR: NoEscape :OR: NoTimeOut
        ORR     R1, R1, #ReadSecsOp
d1683 1
a1683 1
        LDRB    LR, [R5, #SectorSize]
d1734 2
a1735 2
        AND     R1, R1, #AltDefectBit :OR: NoEscape :OR: NoTimeOut
        ORR     R1, R1, #ReadSecsOp
d1739 1
a1739 1
        LDRB    R10, [R5, #SectorSize]
d1836 2
a1837 2
        LDR     LR, FS_Flags                    ; get status flags
        ANDS    LR, LR, #DriveStatusWorks       ; check for status supported
d1844 1
a1844 1
        MOV     R0, #Misc_DriveStatus           ; do the miscop
@


4.11
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d228 14
a241 14
        wrhex   R0
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        wrhex   R7
        mess    ,NL,"R8       R9       R10      R11      R12      R13      R14",NL
        wrhex   R8
        wrhex   R9
        wrhex   R10
        wrhex   R11
        wrhex   R12
d243 1
a243 1
        wrhex   LR
d245 1
a245 1
        wrhex   LR
d247 1
a247 1
        wrhex   R13
d260 1
a260 1
        wrhex   LR
@


4.10
log
@Update to work with zero page relocation
Detail:
  s/FileCore, s/FileCore00, s/InitDieSvc - Try using OS_ReadSysInfo 6 to get IRQsema & CannotReset locations before falling back on legacy values. Store results in module workspace.
  s/FileCore05 - Commented out unused CheckEscape routine to avoid having to update it
  s/FileCore15 - Debugging code updated to use OS_ReadSysInfo 6 to fetch IRQsema ptr. Can't always rely on workspace version since workspace might not be set up yet.
  s/FileCore25, s/FileCore30, s/FileCore80 - Use IRQsema & CannotReset pointers from workspace
Admin:
  Tested on rev A2 BB-xM


Version 3.39. Tagged as 'FileCore-3_39'
@
text
@d64 1
a64 1
        nop
d122 1
a122 1
        nop                     ;dont trap SWI vector
d130 1
a130 1
        nop
d150 1
a150 1
        nop
d170 1
a170 1
        nop
d190 1
a190 1
        nop
d210 1
a210 1
        nop
d287 1
a287 1
        nop                     ;delay for mode change
@


4.9
log
@Skip "Disc drive empty" error on shutdown - if the drive's empty there's
not much you can do about it.
Dir cache flushing fixed.

Version 3.32. Tagged as 'FileCore-3_32'
@
text
@d28 19
d56 1
a56 3
        MOV     R3, #IRQsema
        LDR     R3, [R3]
        TEQS    R3, #0
d250 10
a259 2
        MOV     LR, #IRQsema
        LDR     LR, [LR]
d279 1
a279 3
        MOV     LR, #IRQsema
        LDR     LR, [LR]
        TEQS    LR, #0
d1955 1
a1955 1
        MOV     R1, #IRQsema
@


4.8
log
@* Various 32-bit compatibility fixes.
* Can use HAL for FIQ+timer manipulations.
* FileCore_DiscOp64 added (as user API - currently just converted to the
  standard byte or sector DiscOp call to the underlying module). See
  Doc.32bitAPIs for full details.
* New error-passing scheme to modules added (for full 32-bit addressing).
* FileCore_Features added (indicates new error scheme).
* OS_FSControl 49 (read 32-bit free space) now reports sensible clamped
  values for large discs, rather than values modulo 2^32.
* Accessing the end of files near 2GB in size could cause lock-ups in
  background transfers.
* F(+) and G(+) disc formats adjusted to have a little more skew to
  help the rather poor Iyonix floppy controller.

Version 3.31. Tagged as 'FileCore-3_31'
@
text
@d266 2
a267 1
        ORR     LR, LR, #SVC26_mode :OR: Z_bit :OR: I32_bit
@


4.7
log
@Fixed some mrs and msr macros for ObjAsm.

Version 3.30. Tagged as 'FileCore-3_30'
@
text
@d516 1
a516 1
        STREQ   R7, [R9, #ProcessStatus]
d519 9
d529 1
d979 3
a981 3
; =================
; DoChachedReadSecs
; =================
d1844 7
d1855 1
d1886 7
d1895 1
d1942 7
d1952 1
@


4.6
log
@HAL branch changes (to code to read Timer0) merged. Should still assemble
on non-HAL builds.

Version 3.28. Tagged as 'FileCore-3_28'
@
text
@d49 1
a49 1
        mrs    ,R0, CPSR
d51 1
a51 1
        msr    ,CPSR_c, R0
d115 1
a115 1
        msr    ,CPSR_c, #F32_bit :OR: I32_bit :OR: SVC32_mode
d135 1
a135 1
        msr    ,CPSR_c, #F32_bit :OR: I32_bit :OR: UND32_mode
d155 1
a155 1
        msr    ,CPSR_c, #F32_bit :OR: I32_bit :OR: ABT32_mode
d175 1
a175 1
        msr    ,CPSR_c, #F32_bit :OR: I32_bit :OR: ABT32_mode
d195 1
a195 1
        msr    ,CPSR_c, #F32_bit :OR: I32_bit :OR: ABT32_mode
d267 1
a267 1
        msr    ,CPSR_cf, LR
@


4.5
log
@  Re-applied fixes from FileCore-3_22-4_6_2_1 to the trunk.
Detail:
  Scatter list wrap condition updated to allow top-bit-set memory accesses.
Admin:
  Not tested - any issues related to the 32-bit conversion have not been
  addressed. I'd suggest that you use the branched version mentioned above,
  except in test builds.

Version 3.26. Tagged as 'FileCore-3_26'
@
text
@d1939 25
@


4.4
log
@  32-bit fixes
Detail:
  Some stack offsets were wrong - now fixed.
  More PSR preservation added.
Admin:
  26-bit builds of this module still stiff the machine when ADFS is
    used.
  Do not use - except for testing.

Version 3.24. Tagged as 'FileCore-3_24'
@
text
@d451 5
d459 1
@


4.4.2.1
log
@Simple HAL changes to stop it accessing Timer0 directly. Nowhere near
actually accessing other than a RAM disc on a non-IOMD machine.

Version 3.25, 4.9.2.1. Tagged as 'FileCore-3_25-4_9_2_1'
@
text
@a1932 19
InitialiseHardware
        Push    "R0,R1,R8,R9,LR"
        MOV     R8, #1
        MOV     R9, #EntryNo_HAL_CounterRead
        SWI     XOS_Hardware
        ADRVS   R0, My_CounterReadCall
        STR     R0, CounterReadCall
        STR     R1, CounterReadWs
        Pull    "R0,R1,R8,R9,PC"

My_CounterReadCall
        MOV     ip, lr
        MOV     r0, #IOC
        STRB    r1, [r0, #Timer0LR]
        LDRB    r1, [r0, #Timer0CL]
        LDRB    lr, [r0, #Timer0CH]
        ORR     lr, lr, r1, ASL #8
        MOV     pc, ip

@


4.4.2.2
log
@HAL changes conditionalised, so it should be possible to move it onto the
trunk.

Version 3.25, 4.9.2.2. Tagged as 'FileCore-3_25-4_9_2_2'
@
text
@a1933 1
 [ HAL
a1941 5
 |
        ADR     R0, My_CounterReadCall
        STR     R0, CounterReadCall
        MOV     PC, LR
 ]
@


4.3
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d550 1
a550 1
        STRVS   R0, [SP, #4]
@


4.2
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d29 1
d34 1
a34 1
        MOVEQS  PC, LR
d40 1
a40 1
        MOVNES  PC, LR          ;return if IRQ thread
d43 1
d48 5
d73 5
a77 1
        MOVS    PC, R3
d81 2
a82 1
        Push    "R0-R2,LR"
d87 2
a88 1
        Pull    "R0-R2,PC",,^
d91 2
a92 1
        Push    "R0-R2,LR"
d97 2
a98 1
        Pull    "R0-R2,PC",,^
d111 1
d114 3
d131 1
d134 3
d151 1
d154 3
d171 1
d174 3
d191 1
d194 3
d243 1
a243 1
        MOV     R0, PC          ;save PSR
d249 1
a249 1
        MOV     LR, PC
d261 1
d265 4
d277 1
d291 2
a292 1
        MOVS    PC, R3
d307 1
a307 1
        Pull    "R1,PC",,^
a352 2
 [ NewFs
  [ FileCache
d354 2
a355 3
  |
        Push    "R2,R6-R9,LR"
  ]
d429 1
a429 5
  [ FileCache
        LDR     R2, [SP,#4]     ; Ind disc address
  |
        LDR     R2, [SP]	; what is this?
  ]
a431 1
  [ FileCache
a432 1
  ]
a438 1
 [ FileCache
d440 1
a440 1
        LDR     R1, [SP]
a442 1
 ]
d446 1
a446 1
 [ FileCache                    ;IF op is background op
d449 1
a449 1
        TEQP    PC, #I_bit :OR: SVC_mode
d456 1
a456 1
        TEQNEP  PC, #SVC_mode
d458 1
a458 2
        TEQP    PC, #SVC_mode
 ]
d464 1
a464 1
  [ FileCache
a465 3
  |
        Pull    "R2,R6-R9"
  ]
a478 1
 [ FileCache
d481 2
a482 2
        TSTS    R6, #BackgroundOp
        MOVEQS  PC, LR
d485 3
a487 2
        Push    "LR"
 [ Module_Version >= 205
a495 6
 |
        LDRB    R9, Winnies
        CMPS    R9, R2, LSR #(32-3)
        LDRHI   R9, WinnieProcessBlk
        LDRLS   R9, FloppyProcessBlk
 ]
d509 1
a509 2
        Pull    "LR"
        TSTS    LR, #V_bit
d514 2
a515 25
        MOVS    PC, LR
 ]

 |

        Push    "R2,R6,LR"
        ADD     R2, R2, R5      ;disc address to start at
        MOV     R6, R4
        BL      DoDiscOp        ;(R1-R4->R0-R4,V)
        SUB     R6, R6, R4      ;amount transferred
        ADD     R5, R5, R6      ;increment start offset
  [ Debug8

        DLINE   "disc op |disc add|RAM ptr |remains |file ptr|result - leave GenIndDiscOp"
        DREG   R1," ",cc
        DREG   R2," ",cc
        DREG   R3," ",cc
        DREG   R4," ",cc
        DREG   R5," ",cc
        DREG   R0," "
  ]
        Pull    "R2,R6"
        B        PullLinkKeepV

 ]
d545 2
a546 1
 [ FileCache
d550 1
a550 56
        STRVS   R0, [SP]

 |

        Push    "R0-R7,LR"
        MOV     R5, R2, LSR #(32-3)	; get disc address
        DiscRecPtr  R6, R5		; and disc record from it
        LDRB    LR, [R6,#DiscUsage]	; get usage count of disc
        ADD     LR, LR, #1              ;   and increase it so disc cant be forgotten by FindDiscRec
        STRB    LR, [R6,#DiscUsage]     ;
        MOV     R4, #0
00
;IF we think disc is in drive
        LDRB    R1, [R6,#DiscsDrv]
        CMPS    R1, #8                  ;V=0

;AND certain of drive contents
        MOVCC   R0, R1
        BLCC    PollChange              ;(R0->LR)
        CMPCCS  LR, #8
                                ;V=0
;THEN no need to search for disc
 [ Debug4
        BCS     %FT01

        DLINE   "certain where disc is"
01
 ]
        BCC     %FT60
; uncertain (must be floppy)

;first consider old drive
        LDRB    R1, [R6,#DiscsDrv]      ;may have been altered by PollChange
        CMPS    R1, #8          ;if disc is probably still in drive, try it first
 [ Debug4

        DLINE   "disc probably not in drive"
 ]
        BCS     %FT05
        BL      WhatDisc        ;(R1->R0-R2,R3,V)
        BVS     %FT05
        CMPS    R2, R5          ;also V=0
        BEQ     %FT60           ;disc is still in that drive
05

        MOV     R7, #-1         ;must be at least one floppy if here
        LDRB    R0, Floppies    ;identify uncertain drives
        ADD     R0, R0, #4
15
        SUB     R0, R0, #1
        CMPS    R0, R1
        BLNE    PollChange      ;(R0->LR)
        RSBNES  LR, LR, #7
        ADC     R7, R7, R7      ;bit 0 set <=> certain
        CMPS    R0, #4
        BHI     %BT15
a551 41
;now check other drives in turn
 [ Debug4

        DREG    r7,"need to check drives in turn ",cc
        DLINE   " uncertain bits"
 ]
        MOV     R1, #4
20
        MOVS    R7, R7, ASR #1
        BCS     %FT40
        BL      WhatDisc        ;(R1->R0-R3,V)
        BVS     %FT40
                        ;If successfully examined disc
        TEQS    R2, R5          ;and it was the one we wanted
        BEQ     %FT60           ;then dont need to look any further

40
        ADD     R1, R1, #1
        CMPS    R7, #-1
        BNE     %BT20           ;loop until all uncertain drives tried

        MOV     R0, #UpCall_MediaNotPresent
        ADD     R1, R6, #DiscName
        BL      UpCall          ;(R0,R1,R4->R2-R4,C)
        BCS     %BT00           ;try again if upcall claimed
        MOV     R0, #DiscNotPresentErr
        BL      SetV
60
; V=1 <=> disc not found
        STRVS   R0, [SP]
        TEQS    R4, #0
        MOV     R4, PC
        MOVNE   R0, #UpCall_MediaSearchEnd
        BLNE    OnlyXOS_UpCall
        TEQP    PC, R4
        LDRB    LR, [R6,#DiscUsage]
        SUB     LR, LR, #1        ;protection from FreeDiscRec off
        STRB    LR, [R6,#DiscUsage]
 ]

 [ FileCache
a552 3
 |
        Pull    "R0-R4"         ;restore disc op params
 ]
d564 1
a564 3
 [ :LNOT: FileCache
        Pull    "R5-R7"
 ]
a612 1
 [ Module_Version >= 209
a614 1
 ]
d1818 3
a1820 2
        Push    "R0-R2,LR"
        TEQP    PC, #I_bit :OR: SVC_mode        ;disable IRQ to prevent re-entrance
d1825 1
a1825 1
        TEQP    PC, #SVC_mode           ;can re-enable IRQs as cannot get background
d1842 2
a1843 1
        Pull    "R0-R2,PC",,^
d1854 2
a1855 2
        Push    "R0-R2,LR"
        TEQP    PC, #I_bit :OR: SVC_mode        ;disable IRQ to prevent re-entrance
d1861 1
a1861 1
        TEQP    PC, #SVC_mode           ;can reenable IRQs as background claim can't
d1874 2
a1875 1
        Pull    "R0-R2,PC",,^
a1876 1
 [ FileCache
d1889 1
a1889 1
        Push    "R0-R2,LR"
d1892 1
a1892 1
        Pull    "R0-R2,PC",NE
d1894 1
a1894 1
        TEQP    PC, #I_bit :OR: SVC_mode        ;disable IRQ to prevent re-entrance
d1907 2
a1908 2
        Pull    "R0-R2,LR",NE
        BICNES  PC, LR, #Z_bit          ;if claim failed return NE
d1925 4
a1928 2
        Pull    "R0-R2,LR"
        ORRS    PC, LR, #Z_bit          ;if claim succeeded return EQ
a1929 1
 ]
@


4.2.2.1
log
@  Fixes to allow loading to/saving from top-bit-set addresses.
Detail:
  Updated to use the new conditions for wrapping around scatter lists, as
  first used in ADFS 3.33, viz that the address word is >= &FFFF0000, rather
  than just being negative.
Admin:
  Tested briefly - at least the one reproducable data abort that I had is now
  fixed.

Version 3.22, 4.6.2.1. Tagged as 'FileCore-3_22-4_6_2_1'
@
text
@a419 5
      [ FixTBSAddrs
        CMN     R6, #ScatterListNegThresh
        ADDCS   R3, R3, R6
        LDMCSIA R3, {R6,R7}
      |
a422 1
      ]
@


4.1
log
@Initial revision
@
text
@d302 1
a302 1
	
d440 1
a440 1
	
d460 1
a460 1
 [ Version >= 205
d506 1
a506 1
	
d541 1
a541 1
	
d576 1
a576 1
	
d587 1
a587 1
	
d611 1
a611 1
	
d657 1
a657 1
	
d716 1
a716 1
 [ Version >= 209
d724 1
a724 1
	
d751 1
a751 1
	
d954 1
a954 1
	
d965 1
a965 1
	
d1033 1
a1033 1
	
d1046 1
a1046 1
	
d1402 1
a1402 1
	
d1446 1
a1446 1
	
d1484 1
a1484 1
	
d1822 1
a1822 1
	
d1862 1
a1862 1
	
d1886 1
a1886 1
; because PollChange cannot be called from 
d1909 1
a1909 1
        BL      Parent_Misc                     
d1920 1
a1920 1
	
d1943 1
a1943 1
	
d1954 1
a1954 1
	
d1974 1
a1974 1
	
d1989 1
a1989 1
	
d2020 1
a2020 1
	
d2025 1
a2025 1
	
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

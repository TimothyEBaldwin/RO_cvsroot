head	4.15;
access;
symbols
	FileCore-3_75:4.15
	FileCore-3_74:4.15
	FileCore-3_73:4.15
	FileCore-3_72:4.15
	FileCore-3_71:4.14
	FileCore-3_70:4.14
	FileCore-3_69:4.14
	FileCore-3_68:4.14
	FileCore-3_67:4.14
	FileCore-3_66:4.14
	FileCore-3_65:4.14
	FileCore-3_64:4.14
	FileCore-3_63:4.14
	FileCore-3_62:4.14
	FileCore-3_61:4.14
	FileCore-3_60:4.14
	FileCore-3_59:4.14
	FileCore-3_58:4.14
	FileCore-3_57:4.14
	FileCore-3_56:4.13
	FileCore-3_55:4.13
	FileCore-3_54:4.12
	FileCore-3_53:4.11
	FileCore-3_52:4.11
	FileCore-3_51:4.11
	FileCore-3_50:4.11
	FileCore-3_49:4.10
	FileCore-3_48:4.10
	FileCore-3_47:4.10
	FileCore-3_46:4.10
	FileCore-3_45:4.10
	FileCore-3_44:4.9
	FileCore-3_43:4.8
	FileCore-3_42:4.8
	FileCore-3_41:4.7
	FileCore-3_40:4.6
	FileCore-3_39:4.6
	FileCore-3_38:4.6
	FileCore-3_37:4.6
	FileCore-3_36:4.6
	FileCore-3_35:4.6
	FileCore-3_34:4.6
	FileCore-3_33:4.6
	RO_5_07:4.5
	FileCore-3_32:4.5
	FileCore-3_31:4.5
	FileCore-3_30:4.5
	FileCore-3_29:4.5
	FileCore-3_28:4.5
	FileCore-3_25-4_9_2_2:4.5
	FileCore-3_27:4.5
	FileCore-3_26:4.5
	FileCore-3_22-4_6_2_1:4.3
	bavison_FileCore-3_22_dev_bp:4.3
	bavison_FileCore-3_22:4.3.0.2
	FileCore-3_25-4_9_2_1:4.5
	HAL:4.5.0.2
	FileCore-3_25:4.5
	FileCore-3_24:4.4
	FileCore-3_23:4.4
	dellis_autobuild_BaseSW:4.3
	FileCore-3_22:4.3
	Ursula_merge:4.1.4.7
	ROL_merge:4.1.4.7
	FileCore-3_21:4.3
	ROL_Ursula_merge:4.1.4.7
	Ursula_RiscPC_merge:4.1.4.7
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.5
	ROL_FileCore-3_21:4.1.4.7
	ROL_FileCore-3_20:4.1.4.7
	ROL:4.1.4.7.0.4
	ROL_bp:4.1.4.7
	Ursula_RiscPC_bp:4.1.4.7
	FileCore-3_18:4.1.4.7
	FileCore-3_01:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.7
	Ursula_RiscPC:4.1.4.7.0.2
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.1.4.7
	sproven_FileCore-3_16:4.1.4.7
	rthornb_UrsulaBuild-19Aug1998:4.1.4.7
	UrsulaBuild_FinalSoftload:4.1.4.7
	rthornb_UrsulaBuild-12Aug1998:4.1.4.7
	aglover_UrsulaBuild-05Aug1998:4.1.4.7
	rthornb_UrsulaBuild-29Jul1998:4.1.4.7
	rthornb_UrsulaBuild-22Jul1998:4.1.4.7
	rthornb_UrsulaBuild-15Jul1998:4.1.4.7
	rthornb_UrsulaBuild-07Jul1998:4.1.4.7
	rthornb_UrsulaBuild-17Jun1998:4.1.4.7
	rthornb_UrsulaBuild-03Jun1998:4.1.4.7
	rthornb_UrsulaBuild-27May1998:4.1.4.7
	rthornb_UrsulaBuild-21May1998:4.1.4.7
	sproven_FileCore-3_15:4.1.4.7
	sproven_314:4.1.4.7
	rthornb_UrsulaBuild_01May1998:4.1.4.7
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.7
	sproven_3_11:4.1.4.6
	sproven_3_10:4.1.4.6
	sproven_Ursula_3_09:4.1.4.5
	sproven_3_07:4.1.4.5
	sproven_3_06:4.1.4.4
	sproven_3_05:4.1.4.4
	sproven_3_04:4.1.4.3
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.3
	sproven_3_02:4.1.4.2
	sproven_3_01:4.1.4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2017.04.09.22.17.12;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	0hBpFTzNopSirUMz;

4.14
date	2013.03.25.20.31.08;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	vCGDXb1zgPQnidJw;

4.13
date	2013.02.21.16.53.08;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	CCuV2tngKttj75Fw;

4.12
date	2012.10.28.08.52.32;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	6n5fY77YU7JEb8qw;

4.11
date	2012.04.14.00.43.17;	author bavison;	state Exp;
branches;
next	4.10;
commitid	xkSKw5i9HVYqOL0w;

4.10
date	2011.10.14.07.23.51;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	D2Id4aPp4zmuUhDv;

4.9
date	2011.10.12.20.21.50;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	BoinxgqWMKLth6Dv;

4.8
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	A9Zxco9ydo9FCOBv;

4.7
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	PKTDORFkNFRVOmzv;

4.6
date	2009.05.17.01.48.32;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.31.17.05.06;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.11.36.57;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.09.21.12.07.21;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.19;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.19;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.31.58;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.16.14.46.47;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.11.17.13.32.35;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.12.01.12.03.07;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.01.09.11.45.04;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.01.23.16.41.29;	author sproven;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.02.17.14.59.44;	author sproven;	state Exp;
branches;
next	4.1.4.7;

4.1.4.7
date	98.04.16.15.26.36;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.12;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.05;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.15
log
@[415] Report dir full when hitting dir size limit
FileCore would allow objects to be added to BigDir extensible directories until eventually failing and leaving an unopenable broken directory behind.
In fact, the on disc directory was sound, but after updating the parent in GrowBigDir it would reload the child into the dir cache with FindDir, FindDir called SanityCheckBigDirHeader which was rejecting BigDir's of exactly 4MB that was created moments earlier.
Now, during the initial attempt grow, a check is made for exceeding BigDirMaxSize before trying to enlarge the dynamic area (while it would be possible to translate the error from maxing out the dynamic area, there could be situations where there genuinely isn't enough memory to enlarge the area) and a more polite "Dir full" error returned.
Tested with an initially empty drive (so the dynamic area must grow) and with one that previously created a maximal directory (dynamic area already large enough).

Also tightened up a couple of places loading byte wide variables using LDR, relying on the modulo 31 properties of LSR/LSL, when we can simply load the value as a byte for the same cost.

Version 3.72. Tagged as 'FileCore-3_72'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;>FileCore45

        TTL     "FileCore45 - OsFile"

;Each entry in OsFile table is 32 bits as below
; bits 0-7   restrictions for FullLookUp, NotNulName assumed for all
; bits 14-15 not found action
;  00 => just return R0=0
;  01 => generate not found error
;  10 => not found error only if not final term of path otherwise enter routine
; bits 16-31 offset of code

MayExist        * 0
MustExist       * 1 :SHL: 14
SpecialNotFound * 1 :SHL: 15

NotFoundBits * MustExist :OR: SpecialNotFound

 MACRO
        OsFileEntry  $Name,$Restrict,$NF
       [ "$Name"="Load"
        ASSERT  .-OsFileTable=FirstUnknown_fsfile*4
       |
        ASSERT  .-OsFileTable=fsfile_$Name*4
       ]
        ASSERT  (DoOsFile$Name-OsFileJump-8)<1 :SHL: 16
        ASSERT  $Restrict<&100                          ;for use of AND &FF
 &       ((DoOsFile$Name-OsFileJump-8):SHL:16) :OR: $Restrict :OR: NotNulName :OR: $NF
 MEND

OsFileTable
        OsFileEntry  Save,NotLastWild :OR: NotLastUp :OR: DirToBuffer,SpecialNotFound
        OsFileEntry  WriteInfo,DirToBuffer,MayExist
        OsFileEntry  WriteLoad,DirToBuffer,MayExist
        OsFileEntry  WriteExec,DirToBuffer,MayExist
        OsFileEntry  WriteAttr,DirToBuffer,MayExist
        OsFileEntry  ReadInfo,0,MayExist
        OsFileEntry  Delete,NotLastWild :OR: NotLastUp :OR: DirToBuffer,MayExist
        OsFileEntry  Create,NotLastWild :OR: NotLastUp :OR: DirToBuffer,SpecialNotFound
        OsFileEntry  CreateDir,NotLastWild :OR: NotLastUp :OR: DirToBuffer,SpecialNotFound
        OsFileEntry  ReadInfoNoLen,0,MayExist
        OsFileEntry  ReadBlockSize,MustBeFile,MustExist
;
        OsFileEntry  Load,MustBeFile,MustExist

; >>>>>>>>>>>
; OsFileEntry
; >>>>>>>>>>>

OsFileEntry
        ; 'safe' (read only) OSFiles
        TEQ     r0, #fsfile_Load
        BEQ     %FT10
        TEQ     r0, #fsfile_ReadInfo
        BEQ     %FT15
        SemEntry  Flag,Dormant  ;leaves SB,LR stacked
        B       %FT20
10
        SemEntry  Flag          ;leaves SB,LR stacked
        B       %FT20
15
        SemEntry  Flag,Light    ;leaves SB,LR stacked
20
        MOV     R6,R0
        BL      MyOsFile
        MOVVC   R0,R6
        sbaddr  R6,Opt1Buffer,VC
        BLVS    FindErrBlock    ; (R0->R0,V)
        BL      FileCoreExit
        Pull    "SB,PC"


; ========
; MyOsFile
; ========

; registers as MOS OsFile with R0 moved to R6 to free R0 for result code

; entry:
;  R1 name ptr
;  R2 load address
;  R3 exec address
;  R4 length ( start for save/create )
;  R5 atts   ( end for save/create )
;  R6 reason code

; exit:
; IF error V set, R0 result
; ELSE R0 ?
;  R1-R5 file atts if successful
;  R6 file type if successful or not found allowed

MyOsFile ROUT
 [ Debug7
        DLINE   "name     load     exec     len/beg  atts/end reason   - entering MyOsFile"
        DREG    R1,,cc
        DREG    R2,,cc
        DREG    R3,,cc
        DREG    R4,,cc
        DREG    R5,,cc
        DREG    R6
 ]

        Push    "R1,R6,R7-R11,LR" ;R6 is dummy for file type

        AND     R6, R6, #&FF
        CMPS    R6, #FirstUnknown_fsfile   ;valid CSD relative ?
        RSBCSS  LR, R6, #fsfile_Load-1
        MOVCS   R0, #BadParmsErr
        BCS     %FT95                   ;bad reason code
        TEQS    R6, #fsfile_Load
        MOVEQ   R6, #FirstUnknown_fsfile

        Push    "R2-R6"
        Pull    "R7-R11"

        baddr   LR, OsFileTable
        LDR     LR, [LR,R6,LSL #2]

        AND     R2, LR, #&FF
        Push    "LR"
        BL      FullLookUp      ;(R1,R2->R0-R6,C,V)
        BVS     %FT10
        MOVCC   R2, #1
        MOVCS   R2, #2          ;file type=1/2 for file/dir
        STR     R2, [SP,#8]     ;put file type in return register set
        B       %FT20
10
        MOV     R2, #0          ;not found file type
        STR     R2, [SP,#8]     ;put file type in return register set
        LDR     LR, [SP]
        TEQS    R0, #NotFoundErr
        BNE     %FT85
        ANDS    LR, LR, #NotFoundBits
        MOVEQ   R0,#0
        TEQS    LR, #SpecialNotFound
        BNE     %FT85
;must be special not found action
        BL      ThisChar        ;(R1->R0,C)
        MOVCC   R0, #NotFoundErr ;not terminator => not last term
        BCC     %FT85
20
        LDR     R0, [SP,#4]     ;string start
        BL      TermStart       ;backtrack to start of last term (R0,R1->R1)
        ASSERT  OldDirEntrySz<=32
        ASSERT  NewDirEntrySz<=32
 [ BigDir
        BL      TestBigDir
        BNE     %FT30

        TEQS    R2,#0
        Push    "R4, R6, R7"
        MOVEQ   R4, R1
        TEQNE   R4, #0
        LDRNE   R6, [R4, #BigDirObNameLen]
        MOVEQ   R6, #BigDirMaxNameLen
        BLNE    GetBigDirName
        MOVNE   R4, LR
        B       %FT40

30
        TEQS    R2, #0          ;Z=1 <=> not found

        Push    "R4,R6,R7"      ;save name for *OPT 1
        MOVEQ   R4, R1
        MOV     R6, #NameLen
40
        sbaddr  R7, Opt1Buffer
        BL      PutMaskedString ;(R3,R4,R6,R7)
        MOV     LR, #0
        STRB    LR, [R7]
        Pull    "R4,R6,R7"
 |
        TEQS    R2, #0          ;Z=1 <=> not found

        Push    "R4,R6,R7"      ;save name for *OPT 1
        MOVEQ   R4, R1
        MOV     R6, #NameLen
        sbaddr  R7, Opt1Buffer
        BL      PutMaskedString ;(R3,R4,R6,R7)
        MOV     LR, #0
        STRB    LR, [R7]
        Pull    "R4,R6,R7"
 ]

        Pull    "LR"
 [ BigDir
        ASSERT  NewDirEntrySz<=32
        ASSERT  BigDirEntrySize<=32
        SUB     SP, SP, #32
 |
        ASSERT  NewDirEntrySz<=28
        SUB     SP, SP, #28     ;space for copy of dir entry for delete
 ]

OsFileJump
        ADD     PC, PC, LR, LSR #16     ;branch to routine

;enter OsFile routine

; results of parsing name
;  R2    file type, Z=1<=>not found, C=1 <=> dir
;  R3    dir ind disc address
;  R4 -> dir entry (next if not found)
;  R5 -> dir start
;  R6 -> dir end

; OsFile params
;  R1 -> name ( last term of path )
;  R7    load
;  R8    exec
;  R9    length / start
;  R10   atts / end
;  R11   reason code

OsFileBack              ;R0,V result, R3=dir disc address, R4->dir entry
        BVS     %FT80
        BL      ReadLoad        ;(R3,R4->LR)
        MOV     R2, LR
OsFileBack2
        BVS     %FT80
        BL      ReadExtAtts     ;(R3,R4->LR)
        MOV     R10,LR
        BL      ReadExec        ;(R4->LR)
        MOV     R11,LR
        BL      ReadLen         ;(R3,R4->LR)
        MOV     R4, LR
        MOV     R3, R11
        MOV     R5, R10
        MOV     R0, #0
80
 [ BigDir
        ADD     SP, SP, #32-4   ;reclaim space for copy of dir entry
 |
        ADD     SP, SP, #28-4   ;reclaim space for copy of dir entry
 ]
85
        ADD     SP, SP, #4
95
        BL      SetVOnR0
 [ Debug7
        Pull    "R1,R6"
        DLINE   "name     load     exec     length   atts     ftype    result - leave MyOsFile"
        DREG    R1,,cc
        DREG    R2,,cc
        DREG    R3,,cc
        DREG    R4,,cc
        DREG    R5,,cc
        DREG    R6,,cc
        BVC     %FT01
        DREG    R0,,cc
01
        DLINE   ""
        Pull    "R7-R11,PC"
 |
        Pull    "R1,R6,R7-R11,PC"
 ]


DoOsFileSave ROUT
DoOsFileCreate
        BL      SaveCreate      ;(R1-R11,Z,C->R0,V)
        B       OsFileBack

; ============
; LockedOrOpen
; ============

; entry
;  R3 dir
;  R4 -> dir entry

 [ BigDir
; if big dir, R5->dir
 ]

; exit NCZ preserved, IF error V set, R0 error
; Any buffers on file discarded if not open.

LockedOrOpen ROUT
        Push    "R8,R9,R12,LR"  ;R12 is a dummy place for the CPSR
        SavePSR r8
        STR     r8, [sp, #2*4]
        LDR     r8, [sp]
        BL      ReadIntAtts     ;(R3,R4->LR)
        TSTS    LR, #IntLockedBit
        MOVNE   R0, #LockedErr
        BNE     %FT10
        BL      OpenCheck       ;(R3,R4->R0,R8,R9,LR,Z)
        BEQ     %FT10
        LDR     LR, [R9, #FcbExtHandle]
        TEQS    LR, #0
        BNE     %FT10
        BL      FreeFcb         ;(R8,R9->R0,V)
        MOV     R0, #0
10
        BL      SetVOnR0
        Pull    "R8,R9,LR"      ; LR is the CPSR for PullLinkKeepV
        B       PullLinkKeepV


DoOsFileWriteInfo  ROUT
DoOsFileWriteLoad
DoOsFileWriteExec
DoOsFileWriteAttr
        CMPS    R4, #0
        BEQ     %FT90

        ASSERT  fsfile_WriteInfo<fsfile_WriteLoad
        ASSERT  fsfile_WriteLoad<fsfile_WriteExec
        ASSERT  fsfile_WriteExec<fsfile_WriteAttr

        CMPS    R11,#fsfile_WriteLoad
        MOVLS   R0, R7
        BLLS    WriteLoad               ;(R0,R3,R4) IF WriteInfo OR WriteLoad
        TEQS    R11,#fsfile_WriteInfo
        TEQNES  R11,#fsfile_WriteExec
        MOVEQ   R0, R8
        BLEQ    WriteExec               ;(R0,R4) IF WriteInfo OR WriteExec
        TEQS    R11,#fsfile_WriteInfo
        TEQNES  R11,#fsfile_WriteAttr
        MOVEQ   R0, R10
        BLEQ    WriteExtAtts            ;(R0,R4) IF WriteInfo OR WriteAttr
        LDR     LR, BufDir
        CMPS    LR, #-1                 ;If buffer still valid => no change
        BLNE    ClearV
        BNE     %FT80
        BL      IncObjSeqNum            ;(R3-R5)
        BL      WriteDir        ; will revalidate DirBuf if success (->R0,V)
                                ; Ensures new Id if necessary
80
        B       OsFileBack

90
        ; Setting the attributes of the root object
        ; Assume can't set any of the attributes, but can ensure
        ; a new Id.
        BL      DiscAddToRec            ; (R3->LR)
        LDRB    r0, [lr, #DiscFlags]
        ORR     r0, r0, #NeedNewIdFlag
        STRB    r0, [lr, #DiscFlags]
        BL      EnsureNewId
        B       OsFileBack



DoOsFileReadInfoNoLen
DoOsFileReadInfo
        BL      ClearV
        B       OsFileBack

DoOsFileReadBlockSize
        BL      ReadAllocSize   ;(R3->LR)
        MOV     r2, lr
        B       OsFileBack2

DoOsFileDelete
;check various restrictions

        BL      LockedOrOpen
        BVS     %FT99           ;refuse to delete open files

        TEQS    R2, #2          ;file type=2 <=> trying to delete directory
        BNE     %FT10
        BL      ReadIndDiscAdd  ;(R3,R4->LR)
      [ :LNOT: RO3Paths
        LDR     R0, UserRootDir
        TEQS    R0, LR
        MOVEQ   R0, #CantDelUrdErr
        BEQ     %FT95
        LDR     R0, LibDir
        TEQS    R0, LR
        MOVEQ   R0, #CantDelLibErr
        BEQ     %FT95
        LDR     R0, CurDir
        TEQS    R0, LR
        MOVEQ   R0, #CantDelCsdErr
        BEQ     %FT95
        LDR     R1, BackDir     ;IF deleting PSD  THEN  PSD := CSD
        TEQS    R1, LR
        STREQ   R0, BackDir
      ]
        Push    "R3"
        MOV     R3, LR
        BL      GetDir          ;(R3->R0,R5,R6,V)
        Pull    "R3"
        BVS     %FT99
 [ BigDir
        BL      TestBigDir
        LDREQ   LR, [R5, #BigDirEntries]
        LDRNEB  LR, [R5, #DirFirstEntry]
 |
        LDRB    LR, [R5,#DirFirstEntry]
 ]
        TEQS    LR, #0
        MOVNE   R0, #DirNotEmptyErr
        BNE     %FT95
        BL      InvalidateBufDir ;so that dir about to delete wont be cached
        BL      GetDir          ;(R3->R0,R5,R6,V)
        BVS     %FT99
10
        MOV     R0, R4          ;make copy of dir entry
        MOV     R1, SP          ;space has already been reserved
 [ BigDir
        ASSERT  NewDirEntrySz>=OldDirEntrySz
        ASSERT  BigDirEntrySize>=NewDirEntrySz
        MOV     R2, #BigDirEntrySize
 |
        ASSERT  NewDirEntrySz>=OldDirEntrySz
        MOV     R2, #NewDirEntrySz
 ]
        BL      BlockMove       ;(R0-R2)

        BL      BeforeAlterFsMap ;(R3->R0,V)
        BLVC    RemoveDirEntry  ;(R3-R5->R0,V)
        BLVC    WriteDirThenFsMap ;(->R0,V)
        MOV     R4, SP          ;-> copy of dir entry
 [ BigDir
        BVS     %FT90
        ; should try to shrink the dir (with potential returning of space too)
        BL      TestBigDir      ;(R3->LR,Z)
        BLEQ    CanBigDirShrink ;(R3,R5->Z)
        BLEQ    ShrinkBigDir    ;(R3,R5)
90
 ]
        BL      UnlockMap
        B       %FT99
95
        BL      SetVOnR0
99
        B       OsFileBack

; ==========
; WriteNames
; ==========

;entry
; EQ <=> new map
; R5 dir start
; R6 dir end

WriteNames
        Push    "R0,R1,LR"
        SavePSR r1
        Push    r1
        LDREQ   R1, ="N" :OR: ("i" :SHL:8) :OR: ("c" :SHL:16) :OR: ("k" :SHL:24) ;Nick
        LDRNE   R1, ="H" :OR: ("u" :SHL:8) :OR: ("g" :SHL:16) :OR: ("o" :SHL:24) ;Hugo
        ADD     R0, R5, #StartName
        WriteWord               ;(R0,R1)
        ADD     R0, R6, #EndName
        WriteWord
        Pull    r1
        RestPSR r1,,f
        Pull    "R0,R1,PC"


DoOsFileCreateDir ROUT
        BEQ     %FT05           ;not found
        MOVCC   R0, #TypesErr   ;if obj already exists only moan if was file
        MOVCS   R0, #0
        BL      SetVOnR0
        B       %FT99

05
 [ BigDir
        BL      TestBigDir
        BNE     %FT90           ; not big dir

 ; it's a big dir
        BL      IsBigDirFull            ; (R1,R3,R5,R6->R0,V)
        BLVS    GrowBigDir              ; try to grow the directory
        BVS     %FT99                   ; don't yet know how to grow big dirs!
        BL      BeforeAlterFsMap        ; (R3->R0,V)
        BVS     %FT99
        MOV     R10, #BigDirMinSize     ; minimum size of a big dir
        BL      ClaimFreeSpace          ; (R3,R10->R0,R2,V)
        BVS     %FT95                   ; couldn't claim free space
        BL      TryCacheDirBuf          ; (R3) we'll create dir in the dir buffer
 [ WriteCacheDir
        BVS     %FT95
 ]
        Push    "R1-R4"
        MOV     R0, R5
        MOV     R1, R10
        BL      ZeroRam                 ; (R0,R1)  zero contents of dir
        ADD     R6, R5, R1              ; -> buf end
        BL      WriteBigDirNames        ; write big dir names
        BL      WriteParent             ; (R3,R5,R6)
        LDR     R1, [SP]
        BL      WriteBigDirName         ;
        STR     R10, [R5, #BigDirSize]
        BL      TestDirCheckByte
        STRB    LR, [R6, #BigDirCheckByte]
        B       %FT92

90
 ]
        BL      IsDirFull       ;(R3,R5,R6->R0,V)
        BLVC    BeforeAlterFsMap;(R3->R0,V)
        BVS     %FT99
        BL      TestDir         ;(R3->LR,Z)
        MOVEQ   R10,#NewDirSize
        MOVNE   R10,#OldDirSize
        BL      ClaimFreeSpace  ;(R3,R10->R0,R2,V)
        BVS     %FT95
        BL      TryCacheDirBuf  ;(R3) will create dir in dir buffer
 [ WriteCacheDir
        BVS     %FT95
 ]
        Push    "R1-R4"
        MOV     R0, R5
        MOV     R1, R10
        BL      ZeroRam         ;(R0,R1)
        ADD     R6, R5, R1      ;->buf end
        BL      TestMap         ;(R3->Z)
        BL      WriteNames      ;(R5,R6,Z)
        BL      WriteParent     ;(R3,R6)
        LDR     R1, [SP]        ;->Name
        BL      TestDir         ;(R3->LR,Z)
        ADDEQ   R4, R6, #NewDirName
        ADDNE   R4, R6, #OldDirName
        BL      WriteName       ;enter name (R1,R4)
        ADDEQ   R4, R6, #NewDirTitle
        ADDNE   R4, R6, #OldDirTitle
        BL      WriteName       ;enter title=name (R1,R4)
        BL      TestDirCheckByte;(R3,R5,R6->LR)
        STRB    LR, [R6,#DirCheckByte]

 [ BigDir
92
 ]
        MOV     R1, #DiscOp_WriteSecs
        MOV     R3, R5
        MOV     R4, R10
        BL      IndDiscOp       ;write out new dir (R1-R4->R0-R5,V)
        Pull    "R1-R4"

        STRVC   R2, BufDir
        BLVC    TryCacheDirBuf  ;(R3)

        BLVC    GetDir          ;get back parent dir (R3->R0,R5,R6,V)
        BLVC    MakeDirSpace    ;(R3-R6)
        MOVVC   R0, #DirBit     ;default creation atts D
        BLVC    MakeDirEntry    ;(R0-R8,R10)
        BLVC    WriteFsMapThenDir ;(->R0,V)
95
        BL      UnlockMap
99
        B       OsFileBack


DoOsFileLoad ROUT
        BL      ReadIntAtts             ;check read access (R3,R4->LR)
        TSTS    LR, #ReadBit
        MOVEQ   R0, #AccessErr
        BEQ     %FT95
        Push    "R3,R4"                 ;save ptr to dir entry
        MOV     R1, #DiscOp_ReadSecs         ;ALLOW ESCAPE AND TIMEOUT
        BL      ReadIndDiscAdd          ;(R3,R4->LR)
        MOV     R2, LR
        Push    "R8"
        BL      OpenCheck               ;(R3,R4,R5->R0,R8,R9,Z)
        Pull    "R8"
        LDRNE   LR, [R9, #FcbExtHandle]
        TEQNES  LR, #0
        LDRNEB  LR, [R9,#FcbFlags]
        TSTNES  LR, #WriteBit           ;refuse to load files open for update
        ADDNE   SP, SP, #2*4
        BNE     %FT95
        TSTS    R8, #&FF        ;bottom byte of exec <> 0 => use file load address
        BEQ     %FT50
        BL      ReadLoad                ;(R3,R4->LR)
        MOV     R7, LR
50      BL      ReadLen                 ;(R3,R4->LR)
        MOV     R4, LR
        MOV     R3, R7
        BL      IndDiscOp               ;(R1-R4->R0,R3-R5,V)
        Pull    "R3,R4"
        B       %FT99
95
        BL      SetVOnR0
99
        B       OsFileBack



; ==========
; SaveCreate
; ==========

; Common object creation code for save, create, openout, copy

; entry
;  Z=0 <=> obj of this name already exists, if so C=1 <=> Dir
;  R1  -> last term of name
;  R3  =  dir ind disc address, IN DIR BUFFER ON ENTRY
;  R4  -> entry in dir
;  R5  -> dir start
;  R6  -> dir end
;  R7  =  load address
;  R8  =  exec address
;  R9  =  RAM start
;  R10 =  RAM end
;  R11 =  reason code, real or dummy OsFile

; exit
;  R0  =  result code

SaveCreate ROUT
        Push    "R1-R11,LR"
 [ Debug7
 DREG   r11, "SaveCreate(",cc
 DLINE  ")"
 ]
        SUB     R10,R10,R9      ;convert end to length
        BNE     %FT10           ;object of this name already exists
 [ BigDir
        BL      TestBigDir      ;test if it's a bigdir
        BNE     %FT01
        BL      IsBigDirFull    ;(R1,R3,R5->R0,V)
        BLVS    GrowBigDir      ;try to grow the directory if no space
        B       %FT02
01
        BL      IsDirFull       ;(R3,R5,R6->R0,V)
02
 |
        BL      IsDirFull       ;(R3,R5,R6->R0,V)
 ]
        BLVC    BeforeAlterFsMap      ;(R3)
        BVS     %FT99
        B       %FT20
10
;file already exists check various restrictions
        MOVCS   R0, #TypesErr    ;cant create file if dir of same name exists
 [ DebugX
        BCC     %FT01
        DLINE   "it's a dir, or so I'm told!"
01
 ]
        BLCS    SetV
        BCS     %FT99
        BL      LockedOrOpen    ;refuse to overwrite open files
        BLVC    BeforeAlterFsMap;(R3->R0,V)
        BVS     %FT99

 [ Debug7
 DLINE  "Object already exists"
 ]
;To avoid reloading of FS map and dir after failure of space claim, check if
;enough space will be available after deleting old object

        BL      PrelimFreeCheck ;(R3-R6,R10->R0,R2,C,V)
        BVS     %FT95
        BCS     %FT30           ;no change in disc space allocated needed
15
;        BL      EnsureNewFloppyId       ;(R3->R0,V)
        BLVC    RemoveDirEntry  ;(R3-R5->R0,V)
;        BLVC    WriteDirThenFsMap ;(->R0,V)
        BVS     %FT95
20
        BL      ClaimFreeSpace  ;(R3,R10,R11->R0,R2,R10,V)
        BVS     %FT95
        BL      MakeDirSpace    ;(R3-R6)
;        MOVS    R0,#0,2         ;C=0
30
 [ Debug7
 DLINE  "Making a new DirEntry"
 ]
;C=1 if reusing same space
        MOV     R0,#WriteBit :OR: ReadBit
        BL      MakeDirEntry    ;(R0-R8,R10)
        ASSERT  fsfile_Save<&100 ;to preserve C
        TEQS    R11,#fsfile_Save ;only write file if save
        BNE     %FT40
        Push    "R1-R5"
        MOV     R1,#DiscOp_WriteSecs
;        ORRCS   R1,R1,#DiscOp_Op_IgnoreEscape_Flag ;if reusing same space
        MOV     R3, R9
        MOVS    R4, R10
        BLNE    IndDiscOp       ;(R1-R4->R0-R5) only if non zero length
        Pull    "R1-R5"
        BVS     %FT95
40
 [ WriteCacheDir
        BL      WriteFsMapThenMaybeDir   ; (->R0,V)
 |
        BL      WriteFsMapThenDir ;(->R0,V)
 ]
95
        BL      UnlockMap
99
 [ Debug7
 DLINE  "SaveCreate done"
 ]
        Pull    "R1-R11,PC"


; <<< CRITICAL CODE MAINTAINANCE ROUTINES >>>

; -----------------
; StartCriticalCode
; -----------------

;starts a section of critical code, by setting up a new level on the two copy
;resume address stacks

; corrupts R7-R10

;critical code should start
;       MOV     R11,LR                  ;note parents return & resume address
;       BL      StartCritical

        MACRO
        StartCritical
        MOV     R11,LR
        BL      StartCritical
        MEND


;ONLY FOR USE WITHIN SUBROUTINES CONFORMING TO CRITICAL CODE STRUCTURE

StartCritical
        MOV     R7, #&FF                ;invalid code
        MOV     R8, #0                  ;valid code
        LDR     R9, CriticalSP1
        LDR     R10,CriticalSP2

        STRB    R7, CriticalGood1       ;invalidate 1st copy
        STR     LR, [R9,#4] !           ;stack callers resume address
        STR     R9, CriticalSP1         ;save new stack pointer
        STR     R11,[R9,#-4]            ;update callers parent resume address
        STRB    R8, CriticalGood1       ;validate 1st copy

        STRB    R7, CriticalGood2       ;invalidate 2nd copy
        STR     LR, [R10,#4] !          ;stack callers resume address
        STR     R10,CriticalSP2         ;save new stack pointer
        STR     R11,[R10,#-4]           ;update callers parent resume address
        STRB    R8, CriticalGood2       ;validate 2nd copy

        MOV     PC,LR                   ;flags preserved


; -----------------
; SetResumeCritical
; -----------------

;set critical code resume at this subroutine level to be callers return address

;ONLY FOR USE WITHIN SUBROUTINES CONFORMING TO CRITICAL CODE STRUCTURE

;corrupts R7-R10

SetResumeCritical
        MOV     R7, #&FF                ;invalid code
        MOV     R8, #0                  ;valid code
        LDR     R9, CriticalSP1
        LDR     R10,CriticalSP2

        STRB    R7, CriticalGood1       ;invalidate 1st copy
        STR     LR, [R9]                ;update resume at this level
        STRB    R8, CriticalGood1       ;validate 1st copy

        STRB    R7, CriticalGood2       ;invalidate 2nd copy
        STR     LR, [R10]               ;update resume at this level
        STRB    R8, CriticalGood2       ;validate 2nd copy

        MOV     PC,LR                   ;flags preserved


; ============
; ExitCritical
; ============

;leave a piece of critical code

;ONLY FOR USE WITHIN SUBROUTINES CONFORMING TO CRITICAL CODE STRUCTURE

;corrupts R7-R10

ExitCritical
        MOV     R7, #&FF                ;invalid code
        MOV     R8, #0                  ;valid code
        LDR     R9, CriticalSP1
        LDR     R10,CriticalSP2

        STRB    R7, CriticalGood1       ;invalidate 1st copy
        SUB     R9, R9, #4              ;retract resume stack
        STR     R9, CriticalSP1
        STRB    R8, CriticalGood1       ;validate 1st copy

        STRB    R7, CriticalGood2       ;invalidate 2nd copy
        SUB     R10,R10,#4              ;retract resume stack
        STR     R10,CriticalSP2
        STRB    R8, CriticalGood2       ;validate 2nd copy

        LDR     PC, [R9]


; ============
; DisableBreak
; ============

DisableBreak
        Push    "R0-R3,LR"
        SavePSR R3
 [ Debugb
        DREG    lr, "Break off from ",cc
 ]
        MOV     R0, #OsByte_RW_BreakAction
        MOV     R1, #4_2222
        MOV     R2, #0
        BL      OnlyXOS_Byte
 [ Debugb
        DREG    r1, " - old action "
 ]
        STRB    R1, BreakAction
        RestPSR R3,,f
        Pull    "R0-R3,PC"


; ============
; RestoreBreak
; ============

RestoreBreak
        Push    "R0-R3,LR"
        SavePSR R3
        MOV     R0, #OsByte_RW_BreakAction
        LDRB    R1, BreakAction
 [ Debugb
        DREG    lr, "Break on from ",cc
        DREG    r1, " - restoring action "
 ]
        MOV     R2, #0
        BL      OnlyXOS_Byte
        RestPSR R3,,f
        Pull    "R0-R3,PC"


; <<< THE CRITICAL ROUTINES >>>

; Unlike other routines in this module only the contents of registers which
; return results are defined after calls to these routines

; ------------------
; CriticalWriteFsMap
; ------------------

; entry: disc rec in CritDiscRec
;        drv  rec in CritDrvRec

; exit: result code in CritResult (and R0)

CriticalWriteFsMap ROUT
        StartCritical
 [ DebugXr :LAND: {FALSE}
        DLINE   "CriticalWriteFsMap"
 ]
        LDR     R5, CritDiscRec
        LDR     R6, CritDrvRec
        LDR     R3, [R5,#DiscRecord_Root]
        LDRB    R0, [R5,#DiscFlags]
        ASSERT  NeedNewIdFlag = 1 :SHL: 1
        MOVS    R0, R0, LSR #1+1        ;C set <=> need new id
        BL      TestMap                 ;(R3->Z) preserves Z
        BNE     %FT70

;HERE IF WRITING NEW MAP
 [ DynamicMaps
        LDR     R10,[R6,#DrvsFsMapAddr]
 |
        LDR     R10,[R6,#DrvsFsMap]
 ]
        MOVCS   R1, #(ZoneHead*8)+Zone0Bits
        BLCS    MarkZone
        LDRCSB  R0, [R10,#ZoneHead+DiscRecord_DiscId+0]      ;change id if needed
        ADDCS   R0, R0, #1
        STRCSB  R0, [R10,#ZoneHead+DiscRecord_DiscId+0]
        CMPCSS  R0, #&100
        LDRCSB  R0, [R10,#ZoneHead+DiscRecord_DiscId+1]
        ADDCS   R0, R0, #1
        STRCSB  R0, [R10,#ZoneHead+DiscRecord_DiscId+1]

 [ BigMaps
        LDRB    R9, [R5,#DiscRecord_NZones]
        LDRB    R7, [R5,#DiscRecord_BigMap_NZones2]
        ADD     R9, R9, R7, LSL #8
 |
        LDRB    R9, [R5,#DiscRecord_NZones]
 ]
        LDRB    R7, [R5,#DiscRecord_Log2SectorSize]
        MOV     R1, #1
        MOV     R1, R1, LSL R7          ;sector size
        ADD     R8, R10,R9, LSL R7      ;-> zone flags
        MOV     R3, #-1                 ;init first modified zone
        MOV     R4, #-2                 ;init last modified zone

        MOV     R0, #0
05
        LDRB    LR, [R8,R0]
        TSTS    LR, #ZoneValid
        BNE     %FT10
        CMPS    R3, #-1
        MOVEQ   R3, R0
        MOV     R4, R0
10
        ADD     R0, R0, #1
        CMPS    R0, R9
        BLO     %BT05
        CMPS    R3, R4

 [ WriteCacheDir
        ; if no zones modified, store 0 in ModifiedZones
        MOVGT   R0, #0
        MOVLE   R0, #1
        STR     R0, ModifiedZones       ; number of modified zones
  [ DebugCW
        DREG    R0, "zones modified flag : "
  ]
 ]

        BGT     %FT93           ;if no zones modified

        ADDLT   R3, R10,R3, LSL R7      ;if more than one zone modified
        ADDLT   R4, R10,R4, LSL R7      ;then alter cross check bytes
        LDRLTB  R0, [R4,#CrossCheck]
        LDRLTB  LR, [R3,#CrossCheck]
        EORLT   R0, R0, LR
        ADDLT   LR, LR, #1
        EORLT   R0, R0, LR
        STRLTB  LR, [R3,#CrossCheck]
        STRLTB  R0, [R4,#CrossCheck]

        MOV     R2, #0
15
        MOV     R3, #bit31      ;init offset to start writing to
        MOV     R4, #bit30
20
        SUBS    R11,R2, R9      ;C=0 <=> first copy
        MOVMI   R11,R2

        LDRB    LR, [R8,R11]
        TSTS    LR, #ZoneValid   ;preserves C
        BNE     %FT30
        ADDCC   R0, R10,R11,LSL R7
        BLCC    SetNewCheck     ;(R0,R1) need to write zone if modified

        ADD     R4, R1, R2, LSL R7      ;  note end
        TEQS    R3, #bit31
        MOVEQ   R3, R2, LSL R7          ;  and start if none already
30
        SUB     LR, R2, R4, LSR R7
        ADD     R2, R2, #1
        CMPS    R3, #0
        LDRGEB  R0, [R5,#DiscRecord_SecsPerTrk]
        CMPGES  LR, R0
        CMPLTS  R2, R9, LSL #1
        BLT     %BT20

        TEQS    R3, #bit31
        BEQ     %FT35
        Push    "R1,R2,R8"
        BL      MapDiscAdd              ;(R5,R7,R9->R2)
 [ BigDisc
        ADD     R2, R2, R3, LSR R7      ;disc add to start writing at
 |
        ADD     R2, R2, R3              ;disc add to start writing at
 ]

        SUBS    LR, R4, R9, LSL R7      ;length(s) to write
        RSBHIS  R8, R3, R9, LSL R7
        SUBLS   R8, R4, R3

        SUB     R4, R4, R3              ;total amount to write
        SUBS    R3, R3, R9, LSL R7      ;ensure start offset in first copy
        ADDMI   R3, R3, R9, LSL R7

        ADD     R0, R10,R3              ;where to start in map
 [ DebugE
        Push    "r0"
        DREG    R0, "(add:",cc
        DREG    R8, ", len:",cc
        DREG    R10, ") (add:",cc
        MOV     r0, lr
        DREG    r0, ", len:",cc
        DLINE   ")"
        Pull    "r0"
 ]
        Push    "R0,R8,R10,LR"   ;stack scatter list (add,len)[,(add,len)]
        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_IgnoreEscape_Flag :OR: DiscOp_Op_ScatterList_Flag
        MOV     R3, SP
        BL      RetryDiscOp     ;(R1-R4->R0,R2-R4,V)
        ADD     SP, SP, #4*4
        Pull    "R1,R2,R8"
        BVS     %FT95

        CMPS    R2, R9, LSL #1    ;loop until both copies done
        BLT     %BT15

35
        SUBS    R9, R9, #1
        LDRPLB  LR, [R8,R9]
        ORRPL   LR, LR, #ZoneValid
        STRPLB  LR, [R8,R9]
        BPL     %BT35

        LDRB    R1, [R10,#ZoneHead+DiscRecord_DiscId+0]      ;copy new disc id to disc rec
        LDRB    R2, [R10,#ZoneHead+DiscRecord_DiscId+1]
        B       %FT90


70      ;HERE IF WRITING OLD MAP

        BLCS    InvalidateFsMap         ;(R3)

; C=1 <=> need to update disc id

        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_Atomic_Flag
        LDR     R2, [R5,#DiscRecord_Root]       ;old map at 0
        AND     R2, R2, #DiscBits
 [ DynamicMaps
        LDR     R7, [R6,#DrvsFsMapFlags] ;RAM add
        LDR     R3, [R6,#DrvsFsMapAddr]
 |
        LDR     R7, [R6,#DrvsFsMap]
        BIC     R3, R7, #HiFsBits       ;RAM add
 ]
        MOV     R8, R3
        LDRCSB  R0, [R8,#OldId+0]         ;change id if needed
        ADDCS   R0, R0, #1
        STRCSB  R0, [R8,#OldId+0]
        CMPCSS  R0, #&100
        LDRCSB  R0, [R8,#OldId+1]
        ADDCS   R0, R0, #1
        STRCSB  R0, [R8,#OldId+1]
        ANDS    R0, R7, #EmptyFs        ;already ensured
        BLEQ    ClearV
        BEQ     %FT95

        BL      UpdateFsMapCheckSum

        MOV     R4, #SzOldFs
        BL      RetryDiscOp             ;(R1-R4->R0-R4,V)
        BVS     %FT95

 [ DynamicMaps
        STR     R8, [R6,#DrvsFsMapAddr]
        MOV     LR, #0
        STR     LR, [R6,#DrvsFsMapFlags]
 |
        STR     R8, [R6,#DrvsFsMap]
 ]
        LDRB    R1, [R8,#OldId+0]          ;copy new disc id to disc rec
        LDRB    R2, [R8,#OldId+1]
90
        STRB    R1, [R5,#DiscRecord_DiscId+0]
        STRB    R2, [R5,#DiscRecord_DiscId+1]
        LDRB    LR, [R5,#DiscFlags]
        BIC     LR, LR, #NeedNewIdFlag :OR: AltMapFlag
        STRB    LR, [R5,#DiscFlags]
93
        MOV     R0, #0
95
        STR     R0, CritResult
 [ DebugXr :LAND: {FALSE}
        DREG    R0, "out of CriticalWriteFsMap: "
        DLINE   "<CriticalWriteFsMap"
 ]
        BL      ExitCritical

; ----------------
; CriticalWriteDir
; ----------------

; entry: ind disc address to write dir buffer to in CritBufDir

; exit: result code in CritResult (and R0)

CriticalWriteDir ROUT
        StartCritical
 [ DebugXr :LAND: {FALSE}
        DLINE   ">CriticalWriteDir"
 ]
        LDR     R0, BufDir
        CMPS    R0, #-1
        MOVNE   R0, #0
        BLNE    ClearV
        BNE     %FT95           ;already ensured
        LDR     R3, CritBufDir
 [ BigDir
        LDR     R5, DirBufferPtr
        BL      TestBigDir
        BEQ     %FT99
 |
        sbaddr  R5, DirBuffer
 ]
 [ DebugXr :LAND: {FALSE}
        DLINE   "small dir"
 ]
        BL      TestDir      ;(R3->LR,Z)
        MOVEQ   R9, #NewDirSize
        MOVNE   R9, #OldDirSize
 [ NewDirEntrySz=OldDirEntrySz
 |
        MOVEQ   R8, #NewDirEntrySz
        MOVNE   R8, #OldDirEntrySz
 ]
        ADD     R6, R5, R9
        ADDEQ   R7 ,R6, #NewDirLastMark
        ADDNE   R1, R6, #OldDirLastMark
        BL      IncDirSeqNum    ;increment master sequence number (R5,R6)
        BL      QuickCheckDir   ;(R5,R6->R0,V) all except check byte
        BVS     %FT95           ;Dont write out corrupt dirs

        BL      EndDirEntries   ;(R3,R5,R6->R0)
        MOV     R4,R0

        BL      TestDir         ;(R3->LR,Z)
        BNE     %FT10

;to make disc scavenging easier repeat as many entries as possible at dir end
;for new format

        SUB     LR, R7, #NewDirEntrySz
        SUBS    LR, LR, R4      ;LR=space for repeating dir entries
        ADD     R0, R5, #DirFirstEntry
        SUBHIS  R2, R4, R0      ;R2=length of file list
        MOVLS   R2, #0          ;no space or no files

        CMPS    LR, R2
        MOVLO   R2, LR          ;amount to move = min (space,file list length)
        SUBS    R1, R7, R2      ;dest start
        BL      BlockMove       ;(R0-R2)
10
        MOV     R0, R4           ;clear out any rubbish in dir
        SUBS    R1, R1, R4
        BLHI    ZeroRam         ;(R0,R1)
        BL      TestDirCheckByte;(R3,R5,R6->LR)
        STRB    LR, [R6,#DirCheckByte]

 [ BigDir
90      ; big dir code re-joins here
 ]
        MOV     R1, #DiscOp_WriteSecs :OR: DiscOp_Op_Atomic_Flag
        MOV     R2, R3          ;disc add
 [ DebugXr :LAND: {FALSE}
        DREG    r2, "Ind disc add of write dir: "
 ]
        MOV     R3, R5          ;RAM add
        MOV     R4, R9          ;length
        BL      IndDiscOp       ;(R1-R4->R0,R3-R5)
        BLVC    ValidateBufDir
        MOVVC   R0,#0
95
        STR     R0, CritResult
 [ DebugXr :LAND: {FALSE}
        DREG    R0, "Result:"
        DLINE   "<CriticalWriteDir"
 ]
        BL      ExitCritical

 [ BigDir
99
        ; code for big dirs is different
 [ DebugXr :LAND: {FALSE}
        DLINE   "big dir"
 ]
 [ DebugXd
        ADD     LR, R5, #BigDirName
        DSTRING LR, "write dir; name: "
 ]
        LDR     R9, [R5, #BigDirSize]
        ADD     R6, R5, R9
        BL      IncDirSeqNum    ; increment the master sequence numbers
        BL      QuickCheckDir   ; (R3,R5,R6->R0,V)
        BVS     %BT95           ;don't write out corrupt dirs

; to make disc scavenging easier, repeat entries (but not name heap data)
; at dir end.  unlike new format, this format stores a copy of ALL entries

        BL      GetDirFirstEntry;(R3,R5->R4)
        MOV     R0, R4          ; source for move
        LDR     R2, [R5, #BigDirEntries]

 [ BigDirFullBackup
        ASSERT  BigDirEntrySize=28
        RSB     R2, R2, R2, LSL #3
        MOVS    R2, R2, LSL #2

        SUB     R1, R6, R2
        SUB     R1, R1, #BigDirTailSize ; dest for move
        BLNE    BlockMove       ;
 |
        LDR     R2, [R5, #BigDirEntries]
        MOV     R2, R2, LSL #2
        SUB     R1, R6, R2
        SUB     R1, R1, #BigDirTailSize
        BL      BigDirBackupMove        ; (R0, R1, R2)
 ]

; now clear out any garbage in middle of dir
        LDR     R2, [R5, #BigDirEntries]

 [ DebugXr :LAND: {FALSE}
        DREG    R2, "crit entries: "
        ADD     LR, R2, #BigDirName
        DSTRING LR, "crit dir name: "
 ]

        ASSERT  BigDirEntrySize=28
        RSB     R2, R2, R2, LSL #3      ;
        ADD     R0, R0, R2, LSL #2      ; word after entries

        LDR     R2, [R5, #BigDirNamesSize] ; size of name space
        ADD     R0, R0, R2
        SUB     R1, R1, R0              ; length to zero
        BL      ZeroRam         ; and it's zero'd

        BL      TestBigDirCheckByte
        STRB    LR, [R6, #BigDirCheckByte]

        B       %BT90           ; re-join main thread
 ]

; -------------------------
; CriticalWriteDirThenFsMap
; -------------------------

CriticalWriteDirThenFsMap ROUT
        StartCritical
        BL      CriticalWriteDir
        LDR     R0, CritResult
        BL      SetVOnR0
        BLVC    CriticalWriteFsMap
        LDRVC   R0, CritResult
        BLVC    SetVOnR0
95
        BL      ExitCritical


 [ WriteCacheDir
; ------------------------------
; CriticalWriteFsMapThenMaybeDir
; ------------------------------

CriticalWriteFsMapThenMaybeDir ROUT
        StartCritical
        BL      CriticalWriteFsMap
        LDR     R0, CritResult
        BL      SetVOnR0
        BVS     %FT95
        MOV     R0, #BufDirDirtyBit
        STR     R0, BufDirDirty         ; mark BufDir as dirty for now
        LDR     R0, ModifiedZones
        TEQS    R0, #0
        BEQ     %FT95
        MOV     R0, #0
        STR     R0, BufDirDirty
        BL      CriticalWriteDir
        LDR     R0, CritResult
        BL      SetVOnR0
95
        BL      ExitCritical
 ]

; -------------------------
; CriticalWriteFsMapThenDir
; -------------------------

CriticalWriteFsMapThenDir ROUT
        StartCritical
        BL      CriticalWriteFsMap
        LDR     R0, CritResult
        BL      SetVOnR0
 [ DebugXr :LAND: {FALSE}
        DebugError "Error from CriticalWriteFsMap: "
 ]
        BLVC    CriticalWriteDir
        LDRVC   R0, CritResult
        BLVC    SetVOnR0
95
        BL      ExitCritical

        LTORG
        END
@


4.14
log
@Reenable background transfer support when BigFiles is {TRUE}
BigDirCode.s: Retire BigDirFix switch, it wasn't actually a fix, it was more that the directory format was changed early in development, but there's no point keeping support for the prototype any more
FileCore45.s/FileCore25.s/FileCore31.s/FileCore35.s/DebugOpts.s: Retire BigDirFix
Defns.s: Shock addition of some comments
FileCore.s: Manual inclusion of CPU/Arch no longer needed
FileCore70.s: Crucially apply the same 1k dead band to the FileSwitch "write zeros" entry point, since it (along with Get/PutBytes) are the only places file offsets get passed
FileCore80.s: Lots of tedious and subtle boundary cases fixed
InitDieSvc.s: Removed the disabling switch
doc/BigDisc/ADFSBuffer: Detail what the BufFlags mean

Tested on ADFS (the only background-transferring filing system about) with LFAUs of 2k, 4k, 8k, 16k and bashing 65536 iterations.

Version 3.57. Tagged as 'FileCore-3_57'
@
text
@d489 1
a489 1
        MOV     R10, #NewDirSize        ; minimum size of a big dir is NewDirSize
d635 1
a635 2
        BVC     %FT02           ;dir has space
        BL      GrowBigDir      ;try to grow the directory
@


4.13
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@a1200 1
  [ BigDirFix
d1204 1
a1204 4
  |
        ASSERT  BigDirEntrySize=32
        MOVS    R2, R2, LSL #5  ;length for move
  ]
a1224 1
 [ BigDirFix
d1228 1
a1228 4
 |
        ASSERT  BigDirEntrySize=32
        ADD     R0, R0, R2, LSL #5      ; word after entries
 ]
@


4.12
log
@Swap out some more constants for symbolic names
* OsBytes
* Application start &8000
* Fixed disc density
* Unused a4 macro deleted
* Redundant 'todo', 'Help, 'Syntax' removed

Version 3.53. Not tagged
@
text
@d260 1
a260 1
;        DREG    R3,,cc
d672 1
a672 1
        BLVC    RemoveDirEntry  ;(R3,R4,R5->R0,V)
d899 1
a900 1
 [ BigMaps
d903 2
@


4.11
log
@  Miscellaneous improvements
Detail:
  * Added the ability for a filing system to specify to FileCore that floppy
    discs should be mounted like hard discs, to complement the existing flag
    that specifies the opposite. SDFS requires this. Ideally SCSIFS should
    start using this as well, to encapsulate boot block handling within
    FileCore.
  * Added header definitions so the FileCore and the filing systems can
    negotiate the use of a new MiscOp entry, needed as part of partitioning
    support, especially important for filing systems that use the hardware-
    specific section of the boot block, like ADFS. At present, FileCore
    doesn't do anything different (it still doesn't support partitions) but
    this enables filing systems to be modified in preparation.
  * Removed the only place where FileCore paid any attention to the
    EmptyWorks flag returned by MiscOp 1 - an obscure and not very useful
    edge case not used by any current filing systems.
  * Added 650 lines of documentation for the MiscOp SWI and low-level entry
    to the Doc directory, giving the information you need in order to
    implement a FileCore filing system.
  * Added missing header file definitions for the low-level background DiscOp
    reason code and the hot-plug drive removed flag to MiscOp 7.
  * Removed some RISC OS 2 legacy code whereby FileCore maintained its idea
    of the internal disc address of the CSD @@, PSD \, Library % and URD & for
    each filing system. Since RISC OS 3.00, FileSwitch handles these
    internally and passes canonicalised paths to FileCore, so FileCore's disc
    addresses for these directories remained unset. This allows some
    considerable simplification of FileCore's path parser in particular, but
    also affects other code like that which decides how to expire disc
    records. Also note that FileCore has been unable to generate certain
    errors (like "Can't delete current directory") since RISC OS 3.00 for the
    same reason.
  * Changed loading of the map for FileCore-format discs so that the map is
    loaded into the dynamic area during the Service_IdentifyDisc handler in
    one big DiscOp rather than loading it twice, sector-by-sector, via one
    big sector cache. For one thing, the sector cache is implemented
    inefficiently - O(n^2) - and for another thing, single-sector DiscOps are
    relatively inefficient on many filing systems, especially on SD cards.
    Some example speed-ups measured for mounting discs are:
      SCSIFS,   1GB drive: was 0.62 sec, now 0.40 sec (1.55 x speedup)
      SCSIFS, 256GB drive: was 1.44 sec, now 0.52 sec (2.77 x speedup)
      SDFS,     2GB drive: was 1.25 sec, now 0.14 sec (8.93 x speedup)
Admin:
  Tested on a beagleboard, with SCSIFS and SDFS.

Version 3.50. Tagged as 'FileCore-3_50'
@
text
@d824 1
a824 1
        MOV     R0, #OsbyteBreakAction
d843 1
a843 1
        MOV     R0, #OsbyteBreakAction
@


4.10
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d260 1
a260 1
;        DREG   R3,,cc
d380 1
d396 1
@


4.9
log
@Fix bug in DetermineDiscType.
When failed to identify, and the last operation was format, the DiscSize2 field was not being copied (instead DiscSize is copied twice).
Fix up some warnings from the assembler.
Tested briefly with a RAM disc, still works.

Version 3.44. Tagged as 'FileCore-3_44'
@
text
@d162 2
a163 2
 	BL	TestBigDir
 	BNE	%FT30
d165 9
a173 9
 	TEQS	R2,#0
 	Push	"R4, R6, R7"
 	MOVEQ	R4, R1
 	TEQNE	R4, #0
 	LDRNE	R6, [R4, #BigDirObNameLen]
 	MOVEQ	R6, #BigDirMaxNameLen
 	BLNE	GetBigDirName
 	MOVNE	R4, LR
 	B	%FT40
d202 3
a204 3
 	ASSERT	NewDirEntrySz<=32
 	ASSERT	BigDirEntrySize<=32
 	SUB	SP, SP, #32
d401 3
a403 3
 	BL	TestBigDir
 	LDREQ	LR, [R5, #BigDirEntries]
 	LDRNEB	LR, [R5, #DirFirstEntry]
d418 1
a418 1
        ASSERT	BigDirEntrySize>=NewDirEntrySz
d431 5
a435 5
 	BVS	%FT90
 	; should try to shrink the dir (with potential returning of space too)
 	BL	TestBigDir	;(R3->LR,Z)
	BLEQ	CanBigDirShrink	;(R3,R5->Z)
	BLEQ	ShrinkBigDir	;(R3,R5)
d478 2
a479 2
 	BL	TestBigDir
 	BNE	%FT90		; not big dir
d482 9
a490 9
 	BL	IsBigDirFull		; (R1,R3,R5,R6->R0,V)
 	BLVS	GrowBigDir		; try to grow the directory
 	BVS	%FT99			; don't yet know how to grow big dirs!
 	BL	BeforeAlterFsMap	; (R3->R0,V)
 	BVS	%FT99
 	MOV	R10, #NewDirSize	; minimum size of a big dir is NewDirSize
 	BL	ClaimFreeSpace		; (R3,R10->R0,R2,V)
 	BVS	%FT95			; couldn't claim free space
 	BL	TryCacheDirBuf		; (R3) we'll create dir in the dir buffer
d492 1
a492 1
	BVS	%FT95
d494 13
a506 13
 	Push	"R1-R4"
 	MOV	R0, R5
 	MOV	R1, R10
 	BL	ZeroRam			; (R0,R1)  zero contents of dir
 	ADD	R6, R5, R1		; -> buf end
 	BL	WriteBigDirNames	; write big dir names
	BL	WriteParent		; (R3,R5,R6)
	LDR	R1, [SP]
	BL	WriteBigDirName		;
	STR	R10, [R5, #BigDirSize]
	BL	TestDirCheckByte
	STRB	LR, [R6, #BigDirCheckByte]
 	B	%FT92
d520 1
a520 1
	BVS	%FT95
d544 1
a544 1
        MOV     R1, #WriteSecsOp
d570 1
a570 1
        MOV     R1, #ReadSecsOp         ;ALLOW ESCAPE AND TIMEOUT
d630 6
a635 6
 	BL	TestBigDir	;test if it's a bigdir
 	BNE	%FT01
	BL	IsBigDirFull	;(R1,R3,R5->R0,V)
	BVC	%FT02		;dir has space
	BL	GrowBigDir	;try to grow the directory
	B	%FT02
d637 1
a637 1
	BL	IsDirFull	;(R3,R5,R6->R0,V)
d649 2
a650 2
 	BCC	%FT01
 	DLINE	"it's a dir, or so I'm told!"
d689 2
a690 2
        MOV     R1,#WriteSecsOp
;        ORRCS   R1,R1,#NoEscape ;if reusing same space
d698 1
a698 1
	BL	WriteFsMapThenMaybeDir   ; (->R0,V)
d870 1
a870 1
	DLINE	"CriticalWriteFsMap"
d874 1
a874 1
        LDR     R3, [R5,#RootDir]
d889 1
a889 1
        LDRCSB  R0, [R10,#ZoneHead+DiscId]      ;change id if needed
d891 1
a891 1
        STRCSB  R0, [R10,#ZoneHead+DiscId]
d893 1
a893 1
        LDRCSB  R0, [R10,#ZoneHead+DiscId+1]
d895 1
a895 1
        STRCSB  R0, [R10,#ZoneHead+DiscId+1]
d897 1
a897 1
        LDRB    R9, [R5,#Zones]
d899 2
a900 2
 	LDRB	R7, [R5,#Zones2]
 	ADD	R9, R9, R7, LSL #8
d902 1
a902 1
        LDRB    R7, [R5,#SectorSize]
d924 4
a927 4
	; if no zones modified, store 0 in ModifiedZones
	MOVGT	R0, #0
	MOVLE	R0, #1
	STR	R0, ModifiedZones	; number of modified zones
d929 1
a929 1
	DREG	R0, "zones modified flag : "
d966 1
a966 1
        LDRGEB  R0, [R5,#SecsPerTrk]
d1001 1
a1001 1
        MOV     R1, #WriteSecsOp :OR: NoEscape :OR: ScatterBit
d1018 2
a1019 2
        LDRB    R1, [R10,#ZoneHead+DiscId]      ;copy new disc id to disc rec
        LDRB    R2, [R10,#ZoneHead+DiscId+1]
d1029 2
a1030 2
        MOV     R1, #WriteSecsOp :OR: Atomic
        LDR     R2, [R5,#RootDir]       ;old map at 0
d1034 1
a1034 1
        LDR	R3, [R6,#DrvsFsMapAddr]
d1040 1
a1040 1
        LDRCSB  R0, [R8,#OldId]         ;change id if needed
d1042 1
a1042 1
        STRCSB  R0, [R8,#OldId]
d1059 2
a1060 2
        MOV	LR, #0
        STR	LR, [R6,#DrvsFsMapFlags]
d1064 1
a1064 1
        LDRB    R1, [R8,#OldId]          ;copy new disc id to disc rec
d1067 2
a1068 2
        STRB    R1, [R5,#DiscId]
        STRB    R2, [R5,#DiscId+1]
d1077 2
a1078 2
	DREG	R0, "out of CriticalWriteFsMap: "
	DLINE	"<CriticalWriteFsMap"
d1093 1
a1093 1
	DLINE	">CriticalWriteDir"
d1102 3
a1104 3
 	LDR	R5, DirBufferPtr
 	BL	TestBigDir
 	BEQ	%FT99
d1109 1
a1109 1
	DLINE	"small dir"
d1153 1
a1153 1
90	; big dir code re-joins here
d1155 1
a1155 1
        MOV     R1, #WriteSecsOp:OR: Atomic
d1158 1
a1158 1
	DREG	r2, "Ind disc add of write dir: "
d1168 2
a1169 2
	DREG	R0, "Result:"
	DLINE	"<CriticalWriteDir"
d1175 1
a1175 1
 	; code for big dirs is different
d1177 1
a1177 1
	DLINE	"big dir"
d1180 2
a1181 2
	ADD	LR, R5, #BigDirName
	DSTRING	LR, "write dir; name: "
d1183 5
a1187 5
 	LDR	R9, [R5, #BigDirSize]
 	ADD	R6, R5, R9
 	BL	IncDirSeqNum	; increment the master sequence numbers
 	BL	QuickCheckDir   ; (R3,R5,R6->R0,V)
 	BVS	%BT95		;don't write out corrupt dirs
d1192 3
a1194 3
	BL	GetDirFirstEntry;(R3,R5->R4)
	MOV	R0, R4		; source for move
	LDR	R2, [R5, #BigDirEntries]
d1198 3
a1200 3
  	ASSERT	BigDirEntrySize=28
  	RSB	R2, R2, R2, LSL #3
 	MOVS	R2, R2, LSL #2
d1202 2
a1203 2
	ASSERT	BigDirEntrySize=32
	MOVS	R2, R2, LSL #5	;length for move
d1205 3
a1207 3
	SUB	R1, R6, R2
	SUB	R1, R1, #BigDirTailSize	; dest for move
	BLNE	BlockMove	;
d1209 5
a1213 5
 	LDR	R2, [R5, #BigDirEntries]
 	MOV	R2, R2, LSL #2
 	SUB	R1, R6, R2
 	SUB	R1, R1, #BigDirTailSize
	BL	BigDirBackupMove	; (R0, R1, R2)
d1217 1
a1217 1
	LDR	R2, [R5, #BigDirEntries]
d1220 3
a1222 3
	DREG	R2, "crit entries: "
	ADD	LR, R2, #BigDirName
	DSTRING	LR, "crit dir name: "
d1226 3
a1228 3
 	ASSERT	BigDirEntrySize=28
 	RSB	R2, R2, R2, LSL #3	;
 	ADD	R0, R0, R2, LSL #2	; word after entries
d1230 2
a1231 2
 	ASSERT	BigDirEntrySize=32
	ADD	R0, R0, R2, LSL #5	; word after entries
d1233 4
a1236 4
	LDR	R2, [R5, #BigDirNamesSize] ; size of name space
	ADD	R0, R0, R2
	SUB	R1, R1, R0		; length to zero
	BL	ZeroRam		; and it's zero'd
d1238 2
a1239 2
	BL	TestBigDirCheckByte
	STRB	LR, [R6, #BigDirCheckByte]
d1241 1
a1241 1
	B	%BT90		; re-join main thread
d1270 8
a1277 8
	BVS	%FT95
	MOV	R0, #BufDirDirtyBit
	STR	R0, BufDirDirty		; mark BufDir as dirty for now
	LDR	R0, ModifiedZones
	TEQS	R0, #0
	BEQ	%FT95
	MOV	R0, #0
	STR	R0, BufDirDirty
d1295 1
a1295 1
	DebugError "Error from CriticalWriteFsMap: "
@


4.8
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d809 1
a809 1
        LDMDA   R9,{PC}
@


4.7
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d70 1
a70 1
        Entry   Flag,Dormant    ;leaves SB,LR stacked
d73 1
a73 1
        Entry   Flag            ;leaves SB,LR stacked
d76 1
a76 1
        Entry   Flag,Light      ;leaves SB,LR stacked
@


4.6
log
@  Various archiecture-based optimisations
Detail:
  * ARMv6+ builds use unaligned halfword and word loads and stores (unless
    pre-ARMv6 compatibility is required or NoUnaligned is set)
  * In many cases, one unnecessary BIC instruction has been removed from
    pre-ARMv6 builds
  * ARMv5+ builds (so Tungsten and OMAP) make use of CLZ instruction when
    parsing fragment blocks
Admin:
  Built and included in an OMAP3 ROM. But be warned, this has not received
  the rigorous testing normally required of filesystem code, use at your
  own risk.

Version 3.33. Tagged as 'FileCore-3_33'
@
text
@d17 1
a17 1
        TTL     "Adfs45 - OsFile"
@


4.5
log
@  More 32-bit fixes.
Detail:
  Flag preservation added to 7 routines that require it.  Docs.32-bit
    updated to remove the names of the functions that have been made
    to preserve flags again.
Admin:
  This version needs more testing, but at least this version does not
    appear to stiff the machine, corrupt discs, go bang under light
    testing with ADFS and RAMFS.
  26-bit and 32-bit builds slightly tested.
  Do not use in products - Do use in test builds.

Version 3.25. Tagged as 'FileCore-3_25'
@
text
@d461 1
a461 1
        BL      WriteWord       ;(R0,R1)
d463 1
a463 1
        BL      WriteWord
@


4.4
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d295 4
a298 1
        Push    "R8,R9,LR"
d312 1
a312 1
        Pull    "R8,R9"
d456 2
d464 2
@


4.3
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d211 1
a211 3
        MOV     R0, PC
        ADD     LR, R0, LR, LSR #16     ;branch to routine
        MOV     PC, LR
a231 1
 [ Module_Version >= 205
a232 3
 |
        BL      ReadLoad        ;(R4->LR)
 ]
d321 2
a322 2
        ASSERT  fsfile_WriteInfo<fsfile_WriteExec
        ASSERT  fsfile_WriteInfo<fsfile_WriteAttr
d324 1
a324 2
        CMPS    R11,#fsfile_WriteInfo+1     ;C=0 <=> WriteInfo
        TEQS    R11,#fsfile_WriteLoad
d327 8
a334 6
        TEQS    R11,#fsfile_WriteExec
        MOVLS   R0, R8
        BLLS    WriteExec               ;(R0,R4) IF WriteInfo OR WriteExec
        TEQS    R11,#fsfile_WriteAttr
        MOVLS   R0, R10
        BLLS    WriteExtAtts            ;(R0,R4) IF WriteInfo OR WriteAttr
d459 1
a459 1
        Pull    "R0,R1,PC",,^
d576 4
a579 7
 [ Module_Version >= 205
        BLNE    ReadLoad                ;(R3,R4->LR)
 |
        BLNE    ReadLoad                ;(R4->LR)
 ]
        MOVNE   R7, LR
        BL      ReadLen                 ;(R3,R4->LR)
d746 1
a746 1
        MOVS    PC,LR
d773 1
a773 1
        MOVS    PC,LR
d810 2
a811 1
        Push    "R0-R2,LR"
d823 2
a824 1
        Pull    "R0-R2,PC",,^
d832 2
a833 1
        Push    "R0-R2,LR"
d842 2
a843 1
        Pull    "R0-R2,PC",,^
a870 1
 [ NewFs
a1016 1
 ]
a1062 1
 [ NewFs
a1063 3
 |
        BIC     LR, LR, #NeedNewIdFlag
 ]
@


4.2
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d161 27
d198 1
d201 5
d208 1
d252 3
d256 1
d293 4
d402 5
d408 1
d418 5
d425 1
d432 8
d475 33
d517 3
d539 3
d572 1
a572 1
        BL      OpenCheck               ;(R3,R4->R0,R8,R9,Z)
d630 11
d642 1
d649 5
d698 3
d702 1
d866 3
d880 3
d884 1
d896 4
d920 11
d1031 4
d1037 1
d1056 5
d1062 1
d1079 4
d1095 3
d1104 5
d1110 4
d1155 3
d1160 3
d1170 4
d1176 70
d1263 25
d1297 3
@


4.1
log
@Initial revision
@
text
@d200 1
a200 1
 [ Version >= 205
d480 1
a480 1
 [ Version >= 205
@


4.1.4.1
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@a766 4
 [ BigMaps
 	LDRB	R7, [R5,#Zones2]
 	ADD	R9, R9, R7, LSL #8
 ]
@


4.1.4.2
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@a160 27
 [ BigDir
 	BL	TestBigDir
 	BNE	%FT30
 
 	TEQS	R2,#0
 	Push	"R4, R6, R7"
 	MOVEQ	R4, R1
 	TEQNE	R4, #0
 	LDRNE	R6, [R4, #BigDirObNameLen]
 	MOVEQ	R6, #BigDirMaxNameLen
 	BLNE	GetBigDirName
 	MOVNE	R4, LR
 	B	%FT40
 	
30
        TEQS    R2, #0          ;Z=1 <=> not found

        Push    "R4,R6,R7"      ;save name for *OPT 1
        MOVEQ   R4, R1
        MOV     R6, #NameLen
40
        sbaddr  R7, Opt1Buffer
        BL      PutMaskedString ;(R3,R4,R6,R7)
        MOV     LR, #0
        STRB    LR, [R7]
        Pull    "R4,R6,R7"
 |
a170 1
 ]
a172 5
 [ BigDir
 	ASSERT	NewDirEntrySz<=32
 	ASSERT	BigDirEntrySize<=32
 	SUB	SP, SP, #32
 |
a174 1
 ]
a217 3
 [ BigDir
        ADD     SP, SP, #32-4   ;reclaim space for copy of dir entry
 |
a218 1
 ]
a254 4
 [ BigDir
; if big dir, R5->dir
 ]

a359 5
 [ BigDir
 	BL	TestBigDir
 	LDREQ	LR, [R5, #BigDirEntries]
 	LDRNEB	LR, [R5, #DirFirstEntry]
 |
a360 1
 ]
a369 5
 [ BigDir
        ASSERT  NewDirEntrySz>=OldDirEntrySz
        ASSERT	BigDirEntrySize>=NewDirEntrySz
        MOV     R2, #BigDirEntrySize
 | 
a371 1
 ]
a377 8
 [ BigDir
 	BVS	%FT90
 	; should try to shrink the dir (with potential returning of space too)
 	BL	TestBigDir	;(R3->LR,Z)
	BLEQ	CanBigDirShrink	;(R3,R5->Z)
	BLEQ	ShrinkBigDir	;(R3,R5)
90
 ]
a412 30
 [ BigDir
 	BL	TestBigDir
 	BNE	%FT90		; not big dir
 	
 ; it's a big dir
 	BL	IsBigDirFull		; (R1,R3,R5,R6->R0,V)
 	BLVS	GrowBigDir		; try to grow the directory
 	BVS	%FT99			; don't yet know how to grow big dirs!
 	BL	BeforeAlterFsMap	; (R3->R0,V)
 	BVS	%FT99		
 	MOV	R10, #NewDirSize	; minimum size of a big dir is NewDirSize
 	BL	ClaimFreeSpace		; (R3,R10->R0,R2,V)
 	BVS	%FT95			; couldn't claim free space
 	BL	TryCacheDirBuf		; (R3) we'll create dir in the dir buffer
 	Push	"R1-R4"
 	MOV	R0, R5
 	MOV	R1, R10
 	BL	ZeroRam			; (R0,R1)  zero contents of dir
 	ADD	R6, R5, R1		; -> buf end
 	BL	WriteBigDirNames	; write big dir names
	BL	WriteParent		; (R3,R5,R6)
	LDR	R1, [SP]
	BL	WriteBigDirName		;
	STR	R10, [R5, #BigDirSize]
	BL	TestDirCheckByte
	STRB	LR, [R6, #BigDirCheckByte]
 	B	%FT92
 	
90
 ]
a440 3
 [ BigDir
92
 ]
d471 1
a471 1
        BL      OpenCheck               ;(R3,R4,R5->R0,R8,R9,Z)
a528 11
 [ BigDir
 	BL	TestBigDir	;test if it's a bigdir
 	BNE	%FT01
	BL	IsBigDirFull	;(R1,R3,R5->R0,V)
	BVC	%FT02		;dir has space
	BL	GrowBigDir	;try to grow the directory
	B	%FT02
01
	BL	IsDirFull	;(R3,R5,R6->R0,V)
02
 |
a529 1
 ]
a535 5
 [ DebugX
 	BCC	%FT01
 	DLINE	"it's a dir, or so I'm told!"
01
 ]
a945 5
 [ BigDir
 	LDR	R5, DirBufferPtr
 	BL	TestBigDir
 	BEQ	%FT99
 |
a946 1
 ]
a987 3
 [ BigDir
90	; big dir code re-joins here
 ]
a998 34
 [ BigDir
99
 	; code for big dirs is different
 	LDR	R9, [R5, #BigDirSize]
 	ADD	R6, R5, R9
 	BL	IncDirSeqNum	; increment the master sequence numbers
 	BL	QuickCheckDir   ; (R3,R5,R6->R0,V)
 	BVS	%BT95		;don't write out corrupt dirs
 	
; to make disc scavenging easier, repeat entries (but not name heap data)
; at dir end.  unlike new format, this format stores a copy of ALL entries

	BL	GetDirFirstEntry;(R3,R5->R4)
	MOV	R0, R4		; source for move
	LDR	R2, [R5, #BigDirEntries]
	ASSERT	BigDirEntrySize=32
	MOV	R2, R2, LSL #5	;length for move
	SUB	R1, R6, R2
	SUBS	R1, R1, #BigDirTailSize	; dest for move
	BLNE	BlockMove	;
	
; now clear out any garbage in middle of dir
	LDR	R2, [R5, #BigDirEntries]
	ADD	R0, R0, R2, LSL #5	; word after entries
	LDR	R2, [R5, #BigDirNamesSize] ; size of name space
	ADD	R0, R0, R2
	SUB	R1, R1, R0		; length to zero
	BL	ZeroRam		; and it's zero'd
	
	BL	TestBigDirCheckByte
	STRB	LR, [R6, #BigDirCheckByte]
	
	B	%BT90		; re-join main thread
 ]
@


4.1.4.3
log
@Altered directory format (change backup dir entries to be one word instead
of an entire copy of the entry).  Also reduced size of a directory entry
by one word.  Also fixed a number of small bugs.
@
text
@a1134 7

 [ BigDirFullBackup
  [ BigDirFix
  	ASSERT	BigDirEntrySize=28
  	RSB	R2, R2, R2, LSL #3
 	MOVS	R2, R2, LSL #2
  |
d1136 1
a1136 2
	MOVS	R2, R2, LSL #5	;length for move
  ]
d1138 1
a1138 1
	SUB	R1, R1, #BigDirTailSize	; dest for move
d1140 1
a1140 8
 |
 	LDR	R2, [R5, #BigDirEntries]
 	MOV	R2, R2, LSL #2
 	SUB	R1, R6, R2
 	SUB	R1, R1, #BigDirTailSize
	BL	BigDirBackupMove	; (R0, R1, R2)
 ]

a1142 7

 [ BigDirFix
 	ASSERT	BigDirEntrySize=28
 	RSB	R2, R2, R2, LSL #3	;
 	ADD	R0, R0, R2, LSL #2	; word after entries
 |
 	ASSERT	BigDirEntrySize=32
a1143 1
 ]
@


4.1.4.4
log
@Fixed s.BigDirCode (GrowBigDir and ShrinkBigDir) to cope with BitSize<SecSize
and rewrote free space map memory management to place free space maps in
dynamic areas.
@
text
@a866 3
 [ DynamicMaps
        LDR     R10,[R6,#DrvsFsMapAddr]
 |
a867 1
 ]
a1002 4
 [ DynamicMaps
        LDR     R7, [R6,#DrvsFsMapFlags] ;RAM add
        LDR	R3, [R6,#DrvsFsMapAddr]
 |
a1004 1
 ]
a1022 5
 [ DynamicMaps
        STR     R8, [R6,#DrvsFsMapAddr]
        MOV	LR, #0
        STR	LR, [R6,#DrvsFsMapFlags]
 |
a1023 1
 ]
@


4.1.4.5
log
@Fixed:

DoOsFunRenameBigDir to work when renaming a shared file between dirs where
the file ends up as the last object in the target dir.

SanityCheckEDiscRecord to allow idlen>15 when DiscVersion=0

GrowBigDir to round up desired size to a multiple of the disc allocation
size.

Also:

Implemented non-working code to write cache the dir buffer.  WriteCacheDir
compile switch set to FALSE in s.DebugOpts.  Don't set it to TRUE unless
I tell you it's working.

Made SortDir not attempt to sort more than 2047 entries in a dir, to
avoid it overflowing ScratchSpace.

Made SortPair do one extra shell on the sort (makes it more efficient).
@
text
@d164 1
a164 1

d174 1
a174 1

d422 1
a422 1
 |
d478 1
a478 1

d484 1
a484 1
 	BVS	%FT99
a488 3
 [ WriteCacheDir
	BVS	%FT95
 ]
d502 1
a502 1

a513 3
 [ WriteCacheDir
	BVS	%FT95
 ]
a691 3
 [ WriteCacheDir
	BL	WriteFsMapThenMaybeDir   ; (->R0,V)
 |
a692 1
 ]
a906 11

 [ WriteCacheDir
	; if no zones modified, store 0 in ModifiedZones
	MOVGT	R0, #0
	MOVLE	R0, #1
	STR	R0, ModifiedZones	; number of modified zones
  [ DebugCW
	DREG	R0, "zones modified flag : "
  ]
 ]

d1143 1
a1143 1

d1186 1
a1186 1

d1189 1
a1189 1

a1207 25

 [ WriteCacheDir
; ------------------------------
; CriticalWriteFsMapThenMaybeDir
; ------------------------------

CriticalWriteFsMapThenMaybeDir ROUT
        StartCritical
        BL      CriticalWriteFsMap
        LDR     R0, CritResult
        BL      SetVOnR0
	BVS	%FT95
	MOV	R0, #BufDirDirtyBit
	STR	R0, BufDirDirty		; mark BufDir as dirty for now
	LDR	R0, ModifiedZones
	TEQS	R0, #0
	BEQ	%FT95
	MOV	R0, #0
	STR	R0, BufDirDirty
        BL      CriticalWriteDir
        LDR     R0, CritResult
        BL      SetVOnR0
95
        BL      ExitCritical
 ]
@


4.1.4.6
log
@Fixed 4 bugs in DoOsFunRenameBigDir involving renameing of objects
between dirs with long filenames.

Fixed bug in OsFunResolveWildcard on long filenames.
@
text
@a865 3
 [ DebugXr :LAND: {FALSE}
	DLINE	"CriticalWriteFsMap"
 ]
a1075 4
 [ DebugXr :LAND: {FALSE}
	DREG	R0, "out of CriticalWriteFsMap: "
	DLINE	"<CriticalWriteFsMap"
 ]
a1087 3
 [ DebugXr :LAND: {FALSE}
	DLINE	">CriticalWriteDir"
 ]
a1100 3
 [ DebugXr :LAND: {FALSE}
	DLINE	"small dir"
 ]
a1146 3
 [ DebugXr :LAND: {FALSE}
	DREG	r2, "Ind disc add of write dir: "
 ]
a1153 4
 [ DebugXr :LAND: {FALSE}
	DREG	R0, "Result:"
	DLINE	"<CriticalWriteDir"
 ]
a1158 3
 [ DebugXr :LAND: {FALSE}
	DLINE	"big dir"
 ]
a1194 6
 [ DebugXr :LAND: {FALSE}
	DREG	R2, "crit entries: "
	ADD	LR, R2, #BigDirName
	DSTRING	LR, "crit dir name: "
 ]

a1263 3
 [ DebugXr :LAND: {FALSE}
	DebugError "Error from CriticalWriteFsMap: "
 ]
@


4.1.4.7
log
@Now uses new Ursula service call mechanism.
@
text
@a1181 4
 [ DebugXd
	ADD	LR, R5, #BigDirName
	DSTRING	LR, "write dir; name: "
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

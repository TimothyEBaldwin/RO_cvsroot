head	4.24;
access;
symbols
	FileCore-3_75:4.24
	FileCore-3_74:4.23
	FileCore-3_73:4.23
	FileCore-3_72:4.23
	FileCore-3_71:4.23
	FileCore-3_70:4.23
	FileCore-3_69:4.22
	FileCore-3_68:4.22
	FileCore-3_67:4.22
	FileCore-3_66:4.22
	FileCore-3_65:4.22
	FileCore-3_64:4.22
	FileCore-3_63:4.22
	FileCore-3_62:4.22
	FileCore-3_61:4.21
	FileCore-3_60:4.21
	FileCore-3_59:4.21
	FileCore-3_58:4.21
	FileCore-3_57:4.21
	FileCore-3_56:4.20
	FileCore-3_55:4.19
	FileCore-3_54:4.18
	FileCore-3_53:4.17
	FileCore-3_52:4.17
	FileCore-3_51:4.17
	FileCore-3_50:4.17
	FileCore-3_49:4.17
	FileCore-3_48:4.17
	FileCore-3_47:4.17
	FileCore-3_46:4.16
	FileCore-3_45:4.16
	FileCore-3_44:4.15
	FileCore-3_43:4.15
	FileCore-3_42:4.15
	FileCore-3_41:4.14
	FileCore-3_40:4.12
	FileCore-3_39:4.12
	FileCore-3_38:4.11
	FileCore-3_37:4.10
	FileCore-3_36:4.10
	FileCore-3_35:4.10
	FileCore-3_34:4.10
	FileCore-3_33:4.10
	RO_5_07:4.10
	FileCore-3_32:4.10
	FileCore-3_31:4.9
	FileCore-3_30:4.8
	FileCore-3_29:4.8
	FileCore-3_28:4.7
	FileCore-3_25-4_9_2_2:4.6.2.1
	FileCore-3_27:4.6
	FileCore-3_26:4.6
	FileCore-3_22-4_6_2_1:4.4
	bavison_FileCore-3_22_dev_bp:4.4
	bavison_FileCore-3_22:4.4.0.2
	FileCore-3_25-4_9_2_1:4.6.2.1
	HAL:4.6.0.2
	FileCore-3_25:4.6
	FileCore-3_24:4.6
	FileCore-3_23:4.5
	dellis_autobuild_BaseSW:4.4
	FileCore-3_22:4.4
	Ursula_merge:4.1.4.5
	ROL_merge:4.1.4.5
	FileCore-3_21:4.4
	ROL_Ursula_merge:4.1.4.5
	Ursula_RiscPC_merge:4.1.4.5
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.8
	ROL_FileCore-3_21:4.1.4.5
	ROL_FileCore-3_20:4.1.4.5
	ROL:4.1.4.5.0.4
	ROL_bp:4.1.4.5
	Ursula_RiscPC_bp:4.1.4.5
	FileCore-3_18:4.1.4.5
	FileCore-3_01:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.5
	Ursula_RiscPC:4.1.4.5.0.2
	FileCore-3_00:4.2
	FileCore-2_99:4.2
	aglover_FileCore-3_17:4.1.4.5
	sproven_FileCore-3_16:4.1.4.5
	rthornb_UrsulaBuild-19Aug1998:4.1.4.5
	UrsulaBuild_FinalSoftload:4.1.4.5
	rthornb_UrsulaBuild-12Aug1998:4.1.4.5
	aglover_UrsulaBuild-05Aug1998:4.1.4.5
	rthornb_UrsulaBuild-29Jul1998:4.1.4.5
	rthornb_UrsulaBuild-22Jul1998:4.1.4.5
	rthornb_UrsulaBuild-15Jul1998:4.1.4.5
	rthornb_UrsulaBuild-07Jul1998:4.1.4.5
	rthornb_UrsulaBuild-17Jun1998:4.1.4.5
	rthornb_UrsulaBuild-03Jun1998:4.1.4.5
	rthornb_UrsulaBuild-27May1998:4.1.4.5
	rthornb_UrsulaBuild-21May1998:4.1.4.5
	sproven_FileCore-3_15:4.1.4.5
	sproven_314:4.1.4.5
	rthornb_UrsulaBuild_01May1998:4.1.4.5
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1.4.5
	sproven_3_11:4.1.4.4
	sproven_3_10:4.1.4.4
	sproven_Ursula_3_09:4.1.4.4
	sproven_3_07:4.1.4.3
	sproven_3_06:4.1.4.3
	sproven_3_05:4.1.4.2
	sproven_3_04:4.1.4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1.4.1
	sproven_3_02:4.1.4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.24
date	2017.07.06.14.19.16;	author rsprowson;	state Exp;
branches;
next	4.23;
commitid	8jE9i1ldP8DSXaYz;

4.23
date	2016.07.24.10.55.13;	author rsprowson;	state Exp;
branches;
next	4.22;
commitid	CCTrYcRnnZTvZyfz;

4.22
date	2013.07.18.21.04.17;	author rsprowson;	state Exp;
branches;
next	4.21;
commitid	Em91CJgLrlPBMZXw;

4.21
date	2013.03.25.20.31.08;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	vCGDXb1zgPQnidJw;

4.20
date	2013.02.24.21.09.16;	author rsprowson;	state Exp;
branches;
next	4.19;
commitid	rgJG8ZFRF8o9ruFw;

4.19
date	2013.02.21.16.53.10;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	CCuV2tngKttj75Fw;

4.18
date	2012.10.28.08.52.32;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	6n5fY77YU7JEb8qw;

4.17
date	2011.11.25.08.50.23;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	Wvsb4iMJaWIw2HIv;

4.16
date	2011.10.14.07.23.52;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	D2Id4aPp4zmuUhDv;

4.15
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	A9Zxco9ydo9FCOBv;

4.14
date	2011.09.13.19.23.28;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	ihD4ZDAv3emgTmzv;

4.13
date	2011.09.13.19.13.15;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	PKTDORFkNFRVOmzv;

4.12
date	2011.08.04.20.43.10;	author jlee;	state Exp;
branches;
next	4.11;
commitid	zcIknvqdwARiCeuv;

4.11
date	2011.03.14.23.31.32;	author srevill;	state Exp;
branches;
next	4.10;
commitid	gTwa18MLJQi39Sbv;

4.10
date	2003.08.08.09.42.50;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	2003.04.03.18.33.29;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2001.05.14.14.27.08;	author sbrodie;	state Exp;
branches;
next	4.7;

4.7
date	2001.05.10.15.10.28;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2000.10.31.09.32.31;	author sbrodie;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2000.10.30.13.26.35;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.09.11.37.02;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.08.05.10.32.13;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.09.21.12.07.29;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.25;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2000.11.30.17.04.36;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.32.25;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.41.16;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.11.17.13.32.45;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.01.09.11.45.10;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.01.19.12.26.46;	author sproven;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.02.11.16.49.32;	author sproven;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.04.16.15.26.38;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.25;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.18;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.24
log
@Comments improved
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;>InitDieSvc

 TTL    "Initialisation, finalisation and service call handling"

; >>>>>>>>>
; InitEntry
; >>>>>>>>>

DirBufferName
        = "DirBuffer:%0 Dir Buffer",0
        ALIGN

MapArea = "MapArea:%0 Map (Drive %1)",0
        ALIGN

InitEntry ROUT          ; NO REENTRANCY CHECK NEEDED
        Push    "R7-R11,LR"

        ; Macro to disallow rip-off RAM loaded version (te he ;-)
        ChkKernelVersion

        ; Check if we're the base incarnation and return if we are
        CMPS    R11, #&3000000
        RSBLOS  LR, R11, #0
        BHS     %FT70

        ; Parameter is ascii string number which is address of
        ; parameter block higher up the stack which we passed
        ; to ourselves.
        MOV     R0, #16
        MOV     R1, R10
        SWI     XOS_ReadUnsigned
        BVS     %FT99
        MOV     R9, R2          ;ptr to stacked parameters

        ; Don't know what this faff's about
        MOV     R10,#1          ;init flag

        ; Save pointer to private word in r11 for use later
        MOV     R11, R12

        ; Pick up contents of parameter block
        LDMIA   R9, {R0-R6}
 [ Debug1
        DLINE   "Parameters read from supplied block:",cc
        DREG    R0,,cc
        DREG    R1," ",cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," ",cc
        DREG    R5," ",cc
        DREG    R6," "
 ]
        ; Split out Floppies and Winnies
        ASSERT  DriveConfig_FloppyCount_Shift = 0
        AND     R7, R3, #DriveConfig_FloppyCount_Mask   ;floppies
        MOV     R8, R3, LSR #DriveConfig_FixedDiscCount_Shift
        AND     R8, R8, #DriveConfig_FixedDiscCount_Mask; winnies
                
        ; Lower bound the DirCache size
        CMPS    R4, #CacheMin
        MOVLO   R4, #CacheMin

        ; Evaluate:
        ; r1 = buffer space needed
        ; r2 = process block size
        MOVS    R1, R5, LSL #10 ;using file cache ?
        MOVEQ   R2, #ShortProcessBlk
        BEQ     %FT02           ;no file cache

        ADD     R1, R1, R5, LSL #(10-BufScale)  ;length of file buffers

        MOV     R2, #ProcessPairs+(ExtraPairs+1)*8
 [ {TRUE}
 ; if scatter entry extension disabled number of entries = buffers*4+extrapairs
        ADD     R2, R2, R5, LSL #3 + 2          ;length of process block
 |
        ADD     R2, R2, R5, LSL #3              ;length of process block
 ]

02
        ; Start accumulating in r3 the space needed:
        ; r3=buffer space + 1*process block(for the floppy)
        ADD     R3, R1, R2

        ; Add a process block for the Winnie(s) if needed
        TEQS    R8, #0          ;do we need winnie process block ?
        ADDNE   R3, R3, R2      ;total file cache space

        ; Add enough for the stuff below the DirCache
        MinOps  ADD, ADD, R3, R3, (:INDEX:DirCache)

        ; calc buffer hash table size and add it on (it's first power of 2 gt filecache buffer count)
        MOV     R0, #1
03
        CMPS    R0, R5
        MOVLO   R0, R0, LSL #1
        BLO     %BT03
        ADD     R3, R3, R0, LSL #2

        ;add space for Dir Cache
        ADD     R3, R3, R4

        ;add space for defect maps for all drives, +(4+floppies)*512
        ASSERT  SzDefectList = (1 :SHL: 9)
        ADD     R3, R3, #4 :SHL: 9              ; winnie defect maps
        ADD     R3, R3, R7, LSL #9              ; + floppy defect maps

        Push    "R0-R2"                 ;save file cache lengths

        ; Allocate the main workspace
        MOV     R0, #ModHandReason_Claim
        SWI     XOS_Module              ;claim workspace
        MOV     SB, R2

        ADDVS   SP, SP, #3*4
        BVS     %FT95
        Pull    "R0-R2"


        ; Attach main workspace to private word
        STR     SB, [R11]
        STR     R11, PrivateWord

        Push    "r0-r2"
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_IRQsema
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        LDREQ   r2, =Legacy_IRQsema
        STR     r2, ptr_IRQsema
        MOV     r0, #6
        MOV     r2, #OSRSI6_CannotReset
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        LDREQ   r2, =Legacy_CannotReset
        STR     r2, ptr_CannotReset
        Pull    "r0-r2"

        sbaddr  R3, DirCache
 [ Debug1
        DREG    SB, "Static base:"
        DREG    R3, "Dir cache:"
 ]

        ; Skip the DirCache, now at file cache
        ADD     R3, R3, R4

 [ Debug1
        DREG    R3, "File cache low limit:"
 ]

        ; Skip file buffers
        ADD     R3, R3, R1

        ; Mark where the file buffers start at the moment
        STR     R3, FileBufsStart

        ; Mark where the file buffers end (also where the floppy process block is)
 [ Debug1
        DREG    R3, "Floppy process block:"
 ]
        STR     R3, FileBufsEnd
        ASSERT  FloppyProcessBlk=FileBufsEnd

        ; Initialise the floppy process block to be inactive
        MOV     R4, #Inactive
 [ DebugP
        DREG    r3, "Process ",cc
        DREG    r4, " going inactive with "
 ]
        STRB    R4, [R3,#Process]
        TEQ     R5, #0
        MOVNE   LR, #0
        STRNE   LR, [R3, #ProcessWriteBehindLeft]
        ASSERT  ProcessWriteBehindDrive :MOD: 4 = 0
        ASSERT  ProcessWriteBehindDisc = ProcessWriteBehindDrive + 1
        MOVNE   LR, #-1
        STRNE   LR, [R3,#ProcessWriteBehindDrive]

        ; Set up the Winnie process block (BadPtr used as 'bad process block' indicator')
        ; and initialise it to inactive if there're winnies present
        ADD     R3, R3, R2
        TEQS    R8, #0
        MOVNE   LR, R3
        MOVEQ   LR, #BadPtr
        STR     LR, WinnieProcessBlk
 [ Debug1
        Push    "R3"
        MOV     R3, LR
        DREG    R3, "Winnie process block:"
        Pull    "R3"
 ]
 [ DebugP
        DREG    r3, "Process ",cc
        DREG    r4, " going inactive with "
 ]
        STRNEB  R4, [R3,#Process]

        TEQNE   R5, #0
        MOVNE   LR, #0
        STRNE   LR, [R3,#ProcessWriteBehindLeft]
        ASSERT  ProcessWriteBehindDrive :MOD: 4 = 0
        ASSERT  ProcessWriteBehindDisc = ProcessWriteBehindDrive + 1
        MOVNE   LR, #-1
        STRNE   LR, [R3,#ProcessWriteBehindDrive]

        TEQ     r8, #0
        ADDNE   R3, R3, R2


        STRB    R5, MaxFileBuffers
        STRB    R5, UnclaimedFileBuffers

        ; Set up cache buffers and cache hash table
 [ Debug1
        DREG    R3, "Buffer hash table:"
 ]
        STR     R3, BufHash

        ; hash table
        SUB     R0, R0, #1
        STRB    R0, BufHashMask

        ADRL    LR, DummyBuf            ;initialise buffer hash table
05
        STR     LR, [R3], #4
        SUBS    R0, R0, #1
        BPL     %BT05

        ; cache buffers
        sbaddr  R0, BufChainsRoot
        MOV     R1, #6
08
        STR     R0, [R0,#YoungerBuf]
        STR     R0, [R0,#OlderBuf]
        ADD     R0, R0, #ChainRootSz
        SUBS    R1, R1, #1
        BNE     %BT08

        LDMIA   R9, {R0-R2,R4}
        ASSERT  ParentPrivate=ParentBase+4
        ASSERT  Floppies=ParentPrivate+4
        ASSERT  Winnies=Floppies+1
        ASSERT  Drive=Winnies+1
        ASSERT  StartUpOptions=Drive+1

 [ DynamicMaps

        ; with dynamic free space maps, we ignore WinnieSizes.  The maps
        ; are only allocated as and when they're needed.

        ADD     LR, SB, #:INDEX:ParentBase
        EOR     R4, R4, #4 :SHL: DriveConfig_DefaultDrive_Shift ;convert to internal drive numbering
        STMIA   LR, {R1,R2,R4}

 |
        ASSERT  WinnieSizes=StartUpOptions+1
        ADD     LR, SB, #:INDEX:ParentBase
        EOR     R4, R4, #4 :SHL: DriveConfig_DefaultDrive_Shift ;convert to internal drive numbering
        STMIA   LR, {R1,R2,R4,R6}
   [ Debug1
        DREG    R6, "Winnie sizes:"
   ]
        ; Set floppy sizes to sizes needed for extant E format floppies
        LDR     LR, =(SzNewFloppyFs/256) * &01010101
        MOV     R2, R7, ASL #3  ; Floppies*8
        RSB     R2, R2, #32     ; 32 - Floppies*8
        MOV     LR, LR, LSR R2  ; Ensures top bytes which correspond to non-existing drives get zeroed
        STR     LR, FloppySizes

 ] ; DynamicMaps

        ASSERT  SzCreateDesc = 5*4
        LDMIA   R0, {R0,R2,R4,R5,LR}    ;copy FS descriptor block from parent
        ASSERT  Create_Title=1*4        ;convert parent module offsets to absolute
        ADD     R2, R2, R1
        ASSERT  Create_BootText=2*4
        ADD     R4, R4, R1
        ASSERT  Create_LowLevel=3*4
        ADD     R5, R5, R1
        ASSERT  Create_Misc=4*4
        ADD     LR, LR, R1

        sbaddr  R1, FS_Flags
        STMIA   R1, {R0,R2,R4,R5,LR}
 [ Debug1
        DREG    R0, "Init block:",cc
        DREG    R2, " ",cc
        DREG    R4, " ",cc
        DREG    R5, " ",cc
        MOV     R0, LR
        DREG    R0, " "
 ]

;initialise hardware-specific bits
        BL      InitialiseHardware

;check location of System Heap
        MOV     R0, #0
        SWI     XOS_ReadDynamicArea
        LDRVS   R0, =&01C02000
        STR     R0, SysHeapStart

;initialise critical subroutine workspace
        sbaddr  R0, CriticalStack1
        STR     R0, CriticalSP1
        sbaddr  R0, CriticalStack2
        STR     R0, CriticalSP2

;initialise most Globals
        baddr   R0, DefGlobals
        sbaddr  R1, DefGlobStart
        MOV     R2, #SzDefGlobals
        BL      BlockMove
        BL      InvalidateFragCache

; reset the directory cache
        BL      LockDirCache
        BL      InvalidateDirCache
        BL      CheckDirCache
        BL      UnlockDirCache

;initialise Drive & disc records, ptrs to Free space Maps and defect lists
        sbaddr  R4, DrvRecs
        sbaddr  R5, DiscRecs
        ASSERT  SzDefectList=&200

        MOV     R2, #0          ;ctr
        ADD     R7, R7, #4      ;first non existent floppy Drive
10
        ; Disc record initialisation
        ASSERT  (DiscFlags :MOD: 4)=0
        ASSERT  Priority = DiscFlags+1
        ASSERT  DiscsDrv = Priority+1
        ASSERT  DiscUsage = DiscsDrv+1
        MOV     LR, #DefDiscRecEnd
        STR     LR, [R5,#DiscFlags]

        ; Initialise drive record
        MOV     LR, #Uncertain :OR: Unknown
        STRB    LR, [R4,#DrvsDisc]
        MOV     LR, #0
        STRB    LR, [R4, #DrvFlags]
        STRB    LR, [R4, #LockCount]
        STR     LR, [R4,#ChangedSeqNum]

 [ DynamicMaps
        STR     LR, [R4, #DrvsFsMapAddr]
        STR     LR, [R4, #DrvsFsMapFlags]
        STR     LR, [R4, #DrvsFsMapSize]
 ]

        ; Save R2 and R3 over need for them
        Push    "R2, R3"

        ; Check that this drive exists - store a 0 for non-existant drives
        TST     R2, #4
        MOVEQ   LR, R8
        MOVNE   LR, R7
        CMP     R2, LR
        MOVHS   r2, #0
        BHS     %FT15

 [ DynamicMaps

        ; if we're using dynamic areas for the free space maps, then the
        ; map for each configured drive is created as a dynamic area

        SUB     SP, SP, #256+4

        Push    "R2-R5"

        ADRL    R0, MapArea

        EOR     LR, R2, #4
        ADD     LR, LR, #'0'
        STR     LR, [SP, #256+4*4]
        ADD     R2, SP, #4*4
        MOV     R3, #256
        LDR     R4, FS_Title
        ADD     R5, SP, #256+4*4
        BL      message_lookup_to_buffer02      ; do the message lookup
        Pull    "R2-R5"

        ; now null terminated string at SP (or V set)

;       BVC     %FT14                   ; if no error, then message block is OK
;
;       MOV     LR, SP
;       ADRL    R3, MapAreaDefault
;13
;       LDRB    r0, [r3], #1
;       TEQS    r0, #0
;       STRNEB  r0, [lr], #1
;       BNE     %BT13
;
;       ; now insert the drive number
;       EOR     r3, r2, #4
;       ADD     r3, r3, #'0'
;       STRB    r3, [lr], #1
;       STRB    r0, [lr], #1            ; and the terminator

14
 [ Debug1
        DSTRING sp, "Dynamic name: "
 ]

        Push    "R1,R2,R4-R8"

        MOV     R0, #0                  ; create
        MOV     R1, #-1                 ; don't care about the number
        MOV     R2, #0                  ; initial size of area
        MOV     R3, #-1                 ; don't care about the base
        MOV     R4, #1+(1<<7)           ; USR mode can't write, and not draggable
        MOV     R5, #FsMapMaxSize       ; max size of area
        MOV     R6, #0                  ; no handler
        MOV     R7, #0                  ; no workspace for handler
        ADD     R8, SP, #7*4            ; name pointer

        BL      OnlyXOS_DynamicArea     ; do the dynamic area thing
        MOVVC   R0, R1                  ; dynamic area number
        MOVVS   R0, #0
        Pull    "R1,R2,R4-R8"

        ADD     SP, SP, #256+4
 [ Debug1
        DREG    R3, "Dynamic area base: "
        DREG    R0, "Dynamic area num : "
 ]
        STR     R3, [R4, #DrvsFsMapAddr]; store the dynamic area base ptr
        STR     R0, [R4, #DrvsFsMapArea]; area number
        MOV     R0, #0                  ;
        STR     R0, [R4, #DrvsFsMapSize]; allocated size

15
        Pull    "R2,R3"
 |

        ; Get size byte, skip allocation if size is 0
        ASSERT  FloppySizes = WinnieSizes+4
        sbaddr  LR, WinnieSizes
        LDRB    R2, [LR, R2]
        ADDS    R3, R2, R2, ASL #8
        BEQ     %FT15

        ; Claim the block, mapping fails to no block
        MOV     R0, #ModHandReason_Claim
   [ Debug1
        DREG    R3, "Claiming map block of size "
   ]
        BL      OnlyXOS_Module
        MOVVS   R2, #0
   [ Debug1
        DebugError "Claim error on maps:"
   ]

15
        ; Save the block's address, restore R2 and R3 and set Winnie/Floppy Size to 0 if no block
        STR     R2, [R4, #DrvsFsMap]
        MOVS    R0, R2

        Pull    "R2, R3"

        ; If stored a 0, set Winnie/FloppySize to 0
        sbaddr  LR, WinnieSizes,EQ
        STREQB  R0, [LR,R2]

 ] ; DynamicMaps

20
        ; Map allocation done for this drive

        ; Move to next disc and drive
        ADD     R4, R4, #SzDrvRec
        ADD     R5, R5, #SzDiscRec
        ADD     R2, R2, #1
        CMPS    R2, #8
        BLO     %BT10

 ; here we allocate the dir buffer

 [ BigDir
        ASSERT  BigDirMinSize>=NewDirSize
        ASSERT  BigDirMinSize>=OldDirSize
        ; have to create a dynamic area.  call it 'FileCore DirBuffer'
        Push    "R0-R8"

        MOV     R0, #0
        STR     R0, DirBufferPtr
        STR     R0, DirBufferArea

        SUB     SP, SP, #256            ; buffer for message lookup

        ADRL    R0, DirBufferName       ; get the message ptr
        MOV     R2, SP
        MOV     R3, #256
        LDR     R4, FS_Title            ; name of filing system
        BL      message_lookup_to_buffer01      ; do the message lookup
        BVC     %FT01

        ADD     SP, SP, #256
        STR     R0, [SP]
        Pull    "R0-R8"
        B       %FT85
01

        MOV     R0, #0                  ; create
        MOV     R1, #-1                 ; don't care about the number
        MOV     R2, #BigDirMinSize      ; initial size of area
        STR     R2, DirBufferSize       ; store the size
        MOV     R3, #-1                 ; don't care about the base
        MOV     R4, #1+(1<<7)           ; USR mode can't write, and not draggable
        MOV     R5, #BigDirMaxSize      ; max size of area
        MOV     R6, #0                  ; no handler
        MOV     R7, #0                  ; no workspace for handler
        MOV     R8, SP                  ; name for dir buffer
        BL      OnlyXOS_DynamicArea     ; try to create the area
        ADD     SP, SP, #256            ; free buffer
 [ Debug1
        DebugError "Dynamic area creation:"
 ]
        BVC     %FT01
        STR     R0, [SP]
        Pull    "R0-R8"
        B       %FT85
01
 [ Debug1
        DREG    R1, "DirBufferArea: "
        DREG    R3, "DirBufferPtr : "
 ]
        STR     R1, DirBufferArea
        STR     R3, DirBufferPtr
        Pull    "R0-R8"
 ]

        ; Set up DefectSpace
        SUB     R3, R3, SB
        STR     R3, DefectSpace

        ; Read the Truncate CMOS bit and toggle its sense when we store it
        MOV     r0, #OsByte_ReadCMOS
        MOV     r1, #FileSwitchCMOS
        SWI     XOS_Byte
        BVS     %FT85
        TST     r2, #FileSwitchTruncateNamesCMOSBit
        LDRB    lr, Flags
        ORREQ   lr, lr, #TruncateNames
        STREQB  lr, Flags
 [ Debug1
        DREG    r2, "FileSwitchCMOS="
        MOV     r2, lr
        DREG    r2, "Flags="
 ]

        BL      ReadCaseTables

        ; Declare ourselves
        BL      DeclareFS       ;(R11->R0,V)
 [ Debug1
        DebugError "Declare error:"
 ]
        BVS     %FT85           ; Middle of Die code
        BL      FileCoreExit
 [ ExceptionTrap
        baddr   LR, Exception-8
        MOV     LR, LR, LSR #2
        ORR     LR, LR, #&EA000000
        MOV     R1, #0
        STR     LR, [R1]
        STR     LR, [R1,#4]
        STR     LR, [R1,#&C]
        STR     LR, [R1,#&10]
        STR     LR, [R1,#&14]
 ]
70
        CLRV
        Pull    "R7-R11,PC"

        LTORG

; >>>>>>>>
; DieEntry
; >>>>>>>>

DieEntry
        getSB
        TEQS    SB, #0
        MOVEQ   PC, LR                  ;if base incarnation
        Push    "R7-R11,LR"
 [ Debug1
        DLINE   "FileCore DieEntry"
 ]
        MOV     LR, #1
        STRB    LR, ReEntrance
        MOV     R10,#0
        MOV     R1, #8
        BL      CloseAllByDisc          ;close all files for this incarnation
        MOVVS   R9, R0
 [ Debug
        DebugError "CloseAll Error:"
 ]
        ; UnDeclare FS from FileSwitch
        MOV     R0, #FSControl_RemoveFS
        LDR     R1, FS_Title
        BL      OnlyXOS_FSControl
 [ Debug
        DebugError "Error from RemoveFS:"
 ]
85
        ; Reentry point from init routine above on failure to register FS with FileSwitch
        MOVVS   R9, R0

 [ Debug1
        DLINE   "FileCore killing parent"
 ]

        ; Delete the parent of this incarnation (eg ADFS)
        LDR     R1, ParentBase
        LDR     R0, [R1,#Module_TitleStr]
        ADD     R1, R1, R0
        MOV     R0, #ModHandReason_Delete
        SWI     XOS_Module

 [ Debug
        DebugError "killing (filecore's) parent error: "
 ]

 [ BigDir
        ; free the dynamic area for the dir buffer
        MOV     R0, #1
        LDR     R1, DirBufferArea
        TEQS    R1, #0
 [ Debug1
        BEQ     %FT01
        DREG    R1, "Removing DirBufferArea: "
01
 ]

        SWI     XOS_DynamicArea

 [ Debug1
        DLINE   "Removed DirBufferArea"
 ]
 [ Debug
        DebugError "Error from removing dir buffer area: "
 ]
 ]

        MOV     R4, #8          ; return all map spaces
        B       %FT94
93
        DrvRecPtr  R2,R4
  [ DynamicMaps
        MOV     R0, #1
        LDR     R1, [R2, #DrvsFsMapArea]
        TEQS    R1, #0
 [ Debug1
        BEQ     %FT01
        DREG    R1, "removing dynamic map: "
01
 ]
        BLNE    OnlyXOS_DynamicArea     ; ditch the dynamic area
   [ Debug
        DebugError "Error from removing disc map area: "
   ]
  |
        LDR     R2, [R2,#DrvsFsMap]
        BICS    R2, R2, #HiFsBits
        MOVNE   R0, #ModHandReason_Free
        BLNE    OnlyXOS_Module  ;ignore errors
  ]
94
        SUBS    R4, R4, #1
        BPL     %BT93

        BL      FileCoreExit

        ; Release message file
        LDR     R0, message_file_open
        TEQ     R0, #0
        ADRNE   R0, message_file_block
        SWINE   XMessageTrans_CloseFile ; Ignore error from this

        MOV     R0, #ModHandReason_Free
        MOV     R2, SB
        SWI     XOS_Module          ;Free workspace
 [ Debug
        DebugError "Heap error:"
 ]
95
 [ Debug
        BVC     %FT01
        DREG    R10, "Error - ",cc
        DREG    R0, "..."
01
 ]

 [ NewErrors
        MOVVS   R9, R0
 |
        ORRVS   R9, R0, #ExternalErrorBit
 ]
        MOVS    R0, R9
        MOVNES  R10,R10         ;only error on init
        BEQ     %BT70

        BL      FindErrBlock    ;(R0->R0,V)
99
 [ Debug
        DebugError "FileCore init error:"
 ]
 [ Debug1
        DLINE   "Exit from Filecore DieEntry"
 ]
        Pull    "R7-R11,PC"

FSHdr
        DCD     OpenFileEntry  - Module_BaseAddr
        DCD     GetBytesEntry  - Module_BaseAddr
        DCD     PutBytesEntry  - Module_BaseAddr
        DCD     OsArgsEntry    - Module_BaseAddr
        DCD     CloseFileEntry - Module_BaseAddr
        DCD     OsFileEntry    - Module_BaseAddr
        DCD     fsinfo_flushnotify :OR: fsinfo_multifsextensions :OR: fsinfo_dontuseload :OR: fsinfo_extrainfo
        DCD     OsFunEntry     - Module_BaseAddr
        DCD     0               ; FS_extra info flags

; =========
; DeclareFS
; =========

; Entry R11 ptr to private word

DeclareFS ROUT
        Push    "r0-r10,lr"
        SUB     sp, sp, #FS_size

        MOV     r0, sp
        baddr   r1, Module_BaseAddr
        baddr   r2, FSHdr

        ASSERT  FS_name=0*4
        ASSERT  FS_startuptext=1*4
        LDR     r3, FS_Title
        SUB     r3, r3, r1
        LDR     r4, FS_BootText
        SUB     r4, r4, r1
        STMIA   r0!, {r3,r4}

        ASSERT  FS_open=2*4
        ASSERT  FS_get=3*4
        ASSERT  FS_put=4*4
        ASSERT  FS_args=5*4
        ASSERT  FS_close=6*4
        ASSERT  FS_file=7*4
        LDMIA   r2!, {r3-r8}
        STMIA   r0!, {r3-r8}

        ASSERT  FS_info = 8*4
        ASSERT  FS_func=9*4
        ASSERT  FS_gbpb=10*4
        ASSERT  FS_extra=11*4
        LDMIA   r2!, {r3,r4,r6}
        LDRB    lr, FS_Id
        ORR     r3, r3, lr
        MOV     r5, #0                          ;no FS_gbpb entry
        STMIA   r0!, {r3,r4,r5,r6}

        MOV     r0, #FSControl_AddFS            ;declare as filing system
        SUB     r2, sp, r1
        MOV     r3, r11
        BL      OnlyXOS_FSControl
 [ Debug1
        DebugError "Error on declaring FileCore:"
 ]

        MOVVC   r0, #FSControl_AddSecondaryFS
        LDRVC   r1, FS_Title
        LDRVC   r2, ParentBase
        LDRVC   r3, ParentPrivate
        BLVC    OnlyXOS_FSControl
 [ Debug1
        DebugError "Error after declaring secondary FS:"
 ]
        ADD     sp, sp, #FS_size
        STRVS   r0, [sp]
        Pull    "r0-r10,pc"

ReadCaseTables ROUT
        Push    "lr"
        MOV     r0, #-1
        SWI     XTerritory_UpperCaseTable
        MOVVS   r0, #BadPtr
        STR     r0, UpperCaseTable
        Pull    "pc"

; >>>>>>>>>>>>
; ServiceEntry
; >>>>>>>>>>>>
        ASSERT  Service_ClaimFIQ < Service_Memory
        ASSERT  Service_Memory < Service_Reset
        ASSERT  Service_Reset < Service_FSRedeclare
        ASSERT  Service_FSRedeclare < Service_IdentifyDisc
        ASSERT  Service_IdentifyDisc < Service_EnumerateFormats
        ASSERT  Service_EnumerateFormats < Service_IdentifyFormat
        ASSERT  Service_IdentifyFormat < Service_DisplayFormatHelp
        ASSERT  Service_DisplayFormatHelp < Service_TerritoryStarted 
ServiceTable
        &       0       ; flags word
        &       ServiceEntry2   - Module_BaseAddr

        &       Service_ClaimFIQ
        &       Service_Memory
        &       Service_Reset
        &       Service_FSRedeclare
        &       Service_IdentifyDisc
        &       Service_EnumerateFormats
        &       Service_IdentifyFormat
        &       Service_DisplayFormatHelp
        &       Service_TerritoryStarted
        &       0       ; terminator

        &       ServiceTable    - Module_BaseAddr
ServiceEntry ROUT
        MOV     r0, r0
        ; Rapid service rejection
        TEQ     r1, #Service_ClaimFIQ
        TEQNE   r1, #Service_Memory
        TEQNE   r1, #Service_FSRedeclare
        TEQNE   r1, #Service_Reset
        TEQNE   r1, #Service_IdentifyDisc
        TEQNE   r1, #Service_EnumerateFormats
        TEQNE   r1, #Service_IdentifyFormat
        TEQNE   r1, #Service_DisplayFormatHelp
        TEQNE   r1, #Service_TerritoryStarted
        MOVNE   pc, lr
ServiceEntry2
        ; Service entry and check for base invocation of FileCore
        Push    "R0-R2,R11,R12,LR"      ;need entry R12 stacked for FSRedeclare
        getSB
        TEQ     SB, #0
        BEQ     DoService_WithoutSB

        ; Switch amoungst the recognised services
        TEQ     r1, #Service_ClaimFIQ
        BEQ     DoService_ClaimFIQ
        TEQ     r1, #Service_Memory
        BEQ     DoService_Memory
        TEQ     r1, #Service_FSRedeclare
        BEQ     DoService_FSRedeclare
        TEQ     r1, #Service_Reset
        BEQ     DoService_Reset
        TEQ     r1, #Service_TerritoryStarted
        BEQ     DoService_TerritoryStarted
        B       DoService_PassedOn


DoService_Reset
        LDRB    R0, Interlocks
        BIC     R0, R0, #&FF :EOR: NoOpenFloppy :EOR: NoOpenWinnie
        STRB    R0, Interlocks
        LDRB    LR, MaxFileBuffers      ;IF drivers can run in background
        TEQS    LR, #0
        BEQ     %FT11

        LDR     R0, FloppyProcessBlk
        BL      %FT95

        LDR     R0, WinnieProcessBlk
        TSTS    R0, #BadPtrBits
        BLEQ    %FT95

        LDR     LR, FirstFcb
        TSTS    LR, #BadPtrBits         ;AND at least one file open
        MOVEQ   R0, #TickerV
        ADREQL  R1, TickerEntry
        MOVEQ   R2, SB                  ;restart scheduler
        SWIEQ   XOS_Claim               ;(R0,R1->R0,V)
11

        LDRB    LR, ReEntrance
        TEQS    LR, #0
        BEQ     %FT90                   ;no aborted activity
        MOV     LR, #1
        STRB    LR, ReEntrance

        BL      ReturnBuffer            ;return chunks claimed for data move

        MOV     R0, #7
55                              ;make disc <-> drive mapping consistent
        DiscRecPtr  R1,R0
        MOV     LR, #0
        STRB    LR, [R1,#DiscUsage]
        LDRB    R1, [R1,#DiscsDrv]
        CMPS    R1, #8
        BHS     %FT60
        DrvRecPtr  R1,R1
        LDRB    R1, [R1,#DrvsDisc]
        BIC     R1, R1, #Uncertain
        TEQS    R1, R0
        BLNE    UnlinkByDisc
60
        DrvRecPtr  R1,R0
        LDRB    R1, [R1,#DrvsDisc]
        BIC     R1, R1, #Uncertain
        CMPS    R1, #8
        BHS     %FT65
        DiscRecPtr  R1,R1
        LDRB    R1, [R1,#DiscsDrv]
        TEQS    R1, R0
        BLNE    UnlinkByDrive
65
        SUBS    R0, R0, #1
        BPL     %BT55
85
        BL      FileCoreExit
90
        B       DoService_PassedOn

95                           ;routine to tidy up background transfer on reset
        LDRB    R1, [R0, #Process]
        TSTS    R1, #ReadAhead :OR: WriteBehind
        LDRNE   R1, [R0, #ProcessStatus]
        TSTNES  R1, #Active
        MOVNE   R1, #DataLostErr
        STRNE   R1, [R0, #ProcessError]
 [ NewErrors
        BEQ     %FT96
        LDR     R1, FS_Flags
        TSTS    R1, #CreateFlag_NewErrorSupport
        LDR     R1, [R0, #ProcessStartPtr]
        MOVNE   R1, R1, LSR #2
        STR     R1, [R0, #ProcessStatus]
96
 |
        LDRNE   R1, [R0, #ProcessStartPtr]
        STRNE   R1, [R0, #ProcessStatus]
 ]
        MOV     PC, LR



DoService_ClaimFIQ
        MOV     LR, #&FF
        STRB    LR, BackgroundFiqLock
        WritePSRc SVC_mode,LR,,R0       ;enable IRQs
02                              ;wait until finished with FIQ
        LDRB    LR, FiqOwnership
        TEQS    LR, #0
        BNE     %BT02
        STRB    LR, BackgroundFiqLock
        RestPSR R0,,cf
        B       DoService_PassedOn


DoService_Memory
        LDRB    R0, ScatterEntries
06
        SUBS    R0, R0, #1
        BMI     DoService_PassedOn
        sbaddr  R1, ScatterSource
        LDRB    R1, [R1,R0]
        TEQS    R1, #UseApplicArea
        BNE     %BT06
        B       DoService_Claimed


DoService_FSRedeclare
        LDR     R11,[SP,#4*4]   ;entry R12 -> private word
        BL      DeclareFS       ;(R11->R0,V)
        B       DoService_PassedOn

DoService_TerritoryStarted
        BL      ReadCaseTables
        B       DoService_PassedOn

DoService_IdentifyDisc
        ; Identify our own disc
        B       IdentifyFileCoreDisc

DoService_WithoutSB
        ; Pass around services for the base incarnation

        ; Pull regs not corrupted by non-SB services
        Pull    "r0-r2,r11"

        ; Construct return address to pass on service call location
        JumpAddress lr, DoService_PassedOnWithoutSB, forward

        ; Branch off to relevant service handler routine
        TEQ     r1, #Service_EnumerateFormats
        BEQ     FileCoreService_EnumerateFormats
        TEQ     r1, #Service_IdentifyFormat
        BEQ     FileCoreService_IdentifyFormat
        TEQ     r1, #Service_DisplayFormatHelp
        BEQ     FileCoreService_DisplayFormatHelp
        TEQ     r1, #Service_IdentifyDisc
        BEQ     DoService_IdentifyDisc

DoService_PassedOnWithoutSB
        Pull    "R12,PC"
DoService_PassedOn
        Pull    "R0-R2,R11,R12,PC"
DoService_Claimed
        Pull    "R0"
        MOV     R1, #0
        ADD     SP, SP, #4
        Pull    "R2,R11,R12,PC"

        END
@


4.23
log
@Build fix
Module_Title->Module_TitleStr from Kernel-5_54.

Version 3.70. Tagged as 'FileCore-3_70'
@
text
@d385 1
a385 2
        ; map for each configured drive is created as a dynamic area, with
        ; a maximum size of 4096K
@


4.22
log
@Minor tidy ups
Service call table made unconditional.
Typo in Hdr:FileCore corrected.
Comments improved, and other misc housekeeping.

Version 3.62. Tagged as 'FileCore-3_62'
@
text
@d638 1
a638 1
        LDR     R0, [R1,#Module_Title]
@


4.21
log
@Reenable background transfer support when BigFiles is {TRUE}
BigDirCode.s: Retire BigDirFix switch, it wasn't actually a fix, it was more that the directory format was changed early in development, but there's no point keeping support for the prototype any more
FileCore45.s/FileCore25.s/FileCore31.s/FileCore35.s/DebugOpts.s: Retire BigDirFix
Defns.s: Shock addition of some comments
FileCore.s: Manual inclusion of CPU/Arch no longer needed
FileCore70.s: Crucially apply the same 1k dead band to the FileSwitch "write zeros" entry point, since it (along with Get/PutBytes) are the only places file offsets get passed
FileCore80.s: Lots of tedious and subtle boundary cases fixed
InitDieSvc.s: Removed the disabling switch
doc/BigDisc/ADFSBuffer: Detail what the BufFlags mean

Tested on ADFS (the only background-transferring filing system about) with LFAUs of 2k, 4k, 8k, 16k and bashing 65536 iterations.

Version 3.57. Tagged as 'FileCore-3_57'
@
text
@d819 8
a826 3

 [ ServicePolice

d840 1
a840 2

        &       0
a842 1
 ]
d844 1
a845 3
 [ ServicePolice
        MOV     r0, r0
 ]
a855 1
 [ ServicePolice
a856 1
 ]
@


4.20
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@a67 5
      [ BigFiles
        ! 0,    "BigFiles disabled background transfers"
        MOV     R5, #0
      ]
      
@


4.19
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d68 5
@


4.18
log
@Swap out some more constants for symbolic names
* OsBytes
* Application start &8000
* Fixed disc density
* Unused a4 macro deleted
* Redundant 'todo', 'Help, 'Syntax' removed

Version 3.53. Not tagged
@
text
@d60 1
a60 1
        DREG    R0,"",cc
d616 1
a616 1
        BL      CloseAllByDisc          ;close all ADFS files
d745 1
a745 1
        DCD     0                       ; FSExtra info
d785 1
a785 1
        MOV     r5, #0
@


4.17
log
@Fold in old fixes.
From 1989, probably safe to keep them. Binary unchanged.

Version 3.47. Tagged as 'FileCore-3_47'
@
text
@d560 1
a560 1
        MOV     r0, #ReadCMOS
@


4.16
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@a883 1
 [ fix_4
d888 1
a889 7
 |
        BNE     %FT11

        LDRB    R0, FloppyProcessBlk
        BL      %FT95
        LDRB    R0, WinnieProcessBlk
 ]
@


4.15
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d24 2
a25 2
	= "DirBuffer:%0 Dir Buffer",0
	ALIGN
d28 1
a28 1
	ALIGN
d69 5
a73 3
        AND     R7, R3, #&FF            ;floppies
        LDRB    R8, [R9,#4*3+1]         ;winnies

d267 2
a268 2
 	; with dynamic free space maps, we ignore WinnieSizes.  The maps
 	; are only allocated as and when they're needed.
d271 1
a271 1
        EOR     R4, R4, #4 :SHL: 16     ;convert configured drive to internal drive numbering
d277 1
a277 1
        EOR     R4, R4, #4 :SHL: 16     ;convert configured drive to internal drive numbering
d291 1
a291 1
        ASSERT  Create_Size = 5*4
d366 3
a368 3
 	STR	LR, [R4, #DrvsFsMapAddr]
 	STR	LR, [R4, #DrvsFsMapFlags]
 	STR	LR, [R4, #DrvsFsMapSize]
d384 3
a386 3
 	; if we're using dynamic areas for the free space maps, then the
 	; map for each configured drive is created as a dynamic area, with
 	; a maximum size of 4096K
d388 1
a388 1
 	SUB	SP, SP, #256+4
d390 1
a390 1
 	Push	"R2-R5"
d392 1
a392 1
 	ADRL	R0, MapArea
d394 9
a402 9
 	EOR	LR, R2, #4
 	ADD	LR, LR, #'0'
 	STR	LR, [SP, #256+4*4]
	ADD	R2, SP, #4*4
	MOV	R3, #256
	LDR	R4, FS_Title
	ADD	R5, SP, #256+4*4
	BL	message_lookup_to_buffer02	; do the message lookup
 	Pull	"R2-R5"
d404 1
a404 1
 	; now null terminated string at SP (or V set)
d406 1
a406 1
;	BVC	%FT14			; if no error, then message block is OK
d408 2
a409 2
;	MOV	LR, SP
;	ADRL	R3, MapAreaDefault
d411 4
a414 4
;	LDRB	r0, [r3], #1
;	TEQS	r0, #0
;	STRNEB	r0, [lr], #1
;	BNE	%BT13
d416 5
a420 5
;	; now insert the drive number
;	EOR	r3, r2, #4
;	ADD	r3, r3, #'0'
;	STRB	r3, [lr], #1
;	STRB	r0, [lr], #1		; and the terminator
d424 1
a424 1
 	DSTRING	sp, "Dynamic name: "
d427 1
a427 1
 	Push	"R1,R2,R4-R8"
d429 24
a452 24
 	MOV	R0, #0			; create
 	MOV	R1, #-1			; don't care about the number
 	MOV	R2, #0			; initial size of area
 	MOV	R3, #-1			; don't care about the base
 	MOV	R4, #1+(1<<7)		; USR mode can't write, and not draggable
 	MOV	R5, #FsMapMaxSize	; max size of area
 	MOV	R6, #0			; no handler
 	MOV	R7, #0			; no workspace for handler
	ADD	R8, SP, #7*4		; name pointer

	BL	OnlyXOS_DynamicArea	; do the dynamic area thing
	MOVVC	R0, R1			; dynamic area number
	MOVVS	R0, #0
 	Pull	"R1,R2,R4-R8"

	ADD	SP, SP, #256+4
 [ Debug1
 	DREG	R3, "Dynamic area base: "
 	DREG	R0, "Dynamic area num : "
 ]
	STR	R3, [R4, #DrvsFsMapAddr]; store the dynamic area base ptr
	STR	R0, [R4, #DrvsFsMapArea]; area number
	MOV	R0, #0			;
	STR	R0, [R4, #DrvsFsMapSize]; allocated size
d455 1
a455 1
	Pull	"R2,R3"
d502 22
a523 22
 	ASSERT	BigDirMinSize>=NewDirSize
 	ASSERT	BigDirMinSize>=OldDirSize
 	; have to create a dynamic area.  call it 'FileCore DirBuffer'
 	Push	"R0-R8"

 	MOV	R0, #0
 	STR	R0, DirBufferPtr
 	STR	R0, DirBufferArea

 	SUB	SP, SP, #256		; buffer for message lookup

 	ADRL	R0, DirBufferName	; get the message ptr
 	MOV	R2, SP
 	MOV	R3, #256
 	LDR	R4, FS_Title		; name of filing system
 	BL	message_lookup_to_buffer01	; do the message lookup
 	BVC	%FT01

 	ADD	SP, SP, #256
 	STR	R0, [SP]
 	Pull	"R0-R8"
 	B	%FT85
d526 19
a544 19
 	MOV	R0, #0			; create
 	MOV	R1, #-1			; don't care about the number
 	MOV	R2, #BigDirMinSize	; initial size of area
 	STR	R2, DirBufferSize	; store the size
 	MOV	R3, #-1			; don't care about the base
 	MOV	R4, #1+(1<<7)		; USR mode can't write, and not draggable
 	MOV	R5, #BigDirMaxSize	; max size of area
 	MOV	R6, #0			; no handler
 	MOV	R7, #0			; no workspace for handler
 	MOV	R8, SP			; name for dir buffer
 	BL	OnlyXOS_DynamicArea	; try to create the area
 	ADD	SP, SP, #256		; free buffer
 [ Debug1
 	DebugError "Dynamic area creation:"
 ]
 	BVC	%FT01
 	STR	R0, [SP]
 	Pull	"R0-R8"
 	B	%FT85
d547 2
a548 2
	DREG	R1, "DirBufferArea: "
	DREG	R3, "DirBufferPtr : "
d550 3
a552 3
	STR     R1, DirBufferArea
	STR     R3, DirBufferPtr
	Pull	"R0-R8"
d559 1
a559 1
        ; Read the Truncate CMOS bit and toggle its sence when we store it
d610 1
a610 1
	DLINE	"FileCore DieEntry"
d633 1
a633 1
	DLINE	"FileCore killing parent"
d644 1
a644 1
	DebugError "killing (filecore's) parent error: "
d648 4
a651 4
	; free the dynamic area for the dir buffer
	MOV	R0, #1
	LDR	R1, DirBufferArea
	TEQS	R1, #0
d653 2
a654 2
	BEQ	%FT01
	DREG	R1, "Removing DirBufferArea: "
d658 1
a658 1
	SWI	XOS_DynamicArea
d661 1
a661 1
	DLINE	"Removed DirBufferArea"
d664 1
a664 1
	DebugError "Error from removing dir buffer area: "
d673 3
a675 3
  	MOV	R0, #1
  	LDR	R1, [R2, #DrvsFsMapArea]
  	TEQS	R1, #0
d677 2
a678 2
	BEQ	%FT01
	DREG	R1, "removing dynamic map: "
d681 1
a681 1
  	BLNE	OnlyXOS_DynamicArea	; ditch the dynamic area
d683 1
a683 1
	DebugError "Error from removing disc map area: "
d732 1
a732 1
	DLINE	"Exit from Filecore DieEntry"
d812 1
a812 1
        MOVVS   r0, #Nowt
d823 2
a824 2
	&	0	; flags word
	&	ServiceEntry2	- Module_BaseAddr
d826 9
a834 9
	&	Service_ClaimFIQ
	&	Service_Memory
	&	Service_Reset
	&	Service_FSRedeclare
	&	Service_IdentifyDisc
	&	Service_EnumerateFormats
	&	Service_IdentifyFormat
	&	Service_DisplayFormatHelp
	&	Service_TerritoryStarted
d836 1
a836 1
	&	0
d838 1
a838 1
	&	ServiceTable	- Module_BaseAddr
d843 1
a843 1
	MOV	r0, r0
d957 1
a957 1
        TSTS    R1, #NewErrorSupport
@


4.14
log
@Fix *DEFECT crashing when an object occupies the defect disc address.
R5 was being reused as the loop exit instead of R9.
Synced code with *CHECKMAP a bit since they have the same heritage.
Untangle the spaghetti around TermCommon and UnTermCommon.
In the module init, skip a store when the flags don't change.
Tested with a RAM disc filled with autogenerated nested directories and a loop blindly trying to defect everything - works fine now. Ticket #114.

Version 3.41. Tagged as 'FileCore-3_41'
@
text
@a939 4

 [ F
will need to finish of critical routines (write FS Map and dir etc)
 ]
@


4.13
log
@Delete s.AsmHdr, s.DevVersion, Version, s.ModHand
Delete Doc.!ReadMe, update Doc.!Implement
Collapse dead switches.
s.MyMacros:
 Remove 'nop' macro, use NOP.
s.Defns:
 Some definitions taken from global headers.
s.Commands:
 Indentation and function calling parameter comments reviewed.

Still produces the same binary as 3.40.
@
text
@d565 1
a565 1
        STRB    lr, Flags
@


4.12
log
@Update to work with zero page relocation
Detail:
  s/FileCore, s/FileCore00, s/InitDieSvc - Try using OS_ReadSysInfo 6 to get IRQsema & CannotReset locations before falling back on legacy values. Store results in module workspace.
  s/FileCore05 - Commented out unused CheckEscape routine to avoid having to update it
  s/FileCore15 - Debugging code updated to use OS_ReadSysInfo 6 to fetch IRQsema ptr. Can't always rely on workspace version since workspace might not be set up yet.
  s/FileCore25, s/FileCore30, s/FileCore80 - Use IRQsema & CannotReset pointers from workspace
Admin:
  Tested on rev A2 BB-xM


Version 3.39. Tagged as 'FileCore-3_39'
@
text
@a115 4
 [ F
        ADD	R3, R3, #32*1024	; add a K
 ]

a163 13
 [ F
 [ DebugXm
 	DREG	R3, "end of dir cache: "
 ]
 	Push	"R0,R1"
 	MOV	R0, R3
 	MOV	R1, #32*1024
 	BL	ZeroRam
 	Pull	"R0,R1"
  	ADD	R3, R3, #32*1024

 ]

@


4.11
log
@Fixed some code which could have unpredictable behaviour on 26 bit ARMs.

Version 3.38. Tagged as 'FileCore-3_38'
@
text
@d141 18
@


4.10
log
@Skip "Disc drive empty" error on shutdown - if the drive's empty there's
not much you can do about it.
Dir cache flushing fixed.

Version 3.32. Tagged as 'FileCore-3_32'
@
text
@d980 1
a980 1
        RestPSR R0,,c
@


4.9
log
@* Various 32-bit compatibility fixes.
* Can use HAL for FIQ+timer manipulations.
* FileCore_DiscOp64 added (as user API - currently just converted to the
  standard byte or sector DiscOp call to the underlying module). See
  Doc.32bitAPIs for full details.
* New error-passing scheme to modules added (for full 32-bit addressing).
* FileCore_Features added (indicates new error scheme).
* OS_FSControl 49 (read 32-bit free space) now reports sensible clamped
  values for large discs, rather than values modulo 2^32.
* Accessing the end of files near 2GB in size could cause lock-ups in
  background transfers.
* F(+) and G(+) disc formats adjusted to have a little more skew to
  help the rather poor Iyonix floppy controller.

Version 3.31. Tagged as 'FileCore-3_31'
@
text
@d332 6
@


4.8
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 3.29. Tagged as 'FileCore-3_29'
@
text
@d313 6
d708 3
d712 1
d949 9
d960 1
@


4.7
log
@HAL branch changes (to code to read Timer0) merged. Should still assemble
on non-HAL builds.

Version 3.28. Tagged as 'FileCore-3_28'
@
text
@d718 6
a723 6
        DCD     OpenFileEntry  - org
        DCD     GetBytesEntry  - org
        DCD     PutBytesEntry  - org
        DCD     OsArgsEntry    - org
        DCD     CloseFileEntry - org
        DCD     OsFileEntry    - org
d725 1
a725 1
        DCD     OsFunEntry     - org
d739 1
a739 1
        baddr   r1, org
d805 1
a805 1
	&	ServiceEntry2	- org
d819 1
a819 1
	&	ServiceTable	- org
@


4.6
log
@  32-bit fixes
Detail:
  Some stack offsets were wrong - now fixed.
  More PSR preservation added.
Admin:
  26-bit builds of this module still stiff the machine when ADFS is
    used.
  Do not use - except for testing.

Version 3.24. Tagged as 'FileCore-3_24'
@
text
@d311 1
a311 1
;        BL      InitialiseHardware
@


4.6.2.1
log
@Simple HAL changes to stop it accessing Timer0 directly. Nowhere near
actually accessing other than a RAM disc on a non-IOMD machine.

Version 3.25, 4.9.2.1. Tagged as 'FileCore-3_25-4_9_2_1'
@
text
@d311 1
a311 1
        BL      InitialiseHardware
@


4.5
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d311 1
a311 1
        BL      InitialiseHardware
@


4.4
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d39 1
a39 1
        Pull    "R7-R11,PC",HS,^
d195 1
a195 1
        ; Set up the Winnie process block (ARM_CC_Mask used as 'bad process block' indicator')
d200 1
a200 1
        MOVEQ   LR, #ARM_CC_Mask
d310 3
a323 1
 [ NewFs
a324 1
 ]
d579 3
a581 1
        Pull    "R7-R11,PC",,^
d592 1
a592 1
        MOVEQS  PC, LR                  ;if base incarnation
a652 2
 [ NewFs
  [ Module_Version >= 205
a653 3
  |
        LDRB    R4, Winnies     ;return winnie map spaces
  ]
a678 1
 ]
d705 1
a705 1
        Pull    "R7-R11,PC",EQ,^
d795 1
a795 1
        Pull    "pc",,^
d835 1
a835 1
        MOVNES  pc, lr
a845 1
 [ FileCache
a847 1
 ]
a859 1
 [ FileCache
d878 1
a878 1
        TSTS    R0, #ARM_CC_Mask
d882 1
a882 1
        TSTS    LR, #ARM_CC_Mask            ;AND at least one file open
a887 23
 ]

 [ Module_Version < 205
        MOV     R0, #OsbyteReadResetType
        MOV     R1, #0
        MOV     R2, #-1
        SWI     XOS_Byte
        TEQS    R1,#0
        BEQ     %FT50           ;soft reset

        MOV     LR, #1                  ;DIR/NODIR on hard reset or power on
        STRB    LR, ReEntrance
        LDRB    LR, StartUpOptions
        TSTS    LR, #NoDirBit
        BNE     %FT50
        myaddr  R1, RootText
        BL      DoOsFunDir              ;(R1->R0,V)
        baddr   R1, RootLibText,VC      ;if Dir set ok try to set Lib
        BLVC    UseRootLibIfUnset       ;(R1->R0,V)
        B       %FT85

50
 ]
d941 1
a941 1
        MOVS    PC, LR
a944 1
 [ FileCache
d948 1
a948 1
        TEQP    PC, #SVC_mode           ;enable IRQs
d954 1
a955 1
 ]
d990 1
a990 4
        ADR     r12, DoService_PassedOnWithoutSB ; r12 free - no SB, remember?
        MOV     lr, pc
        AND     lr, lr, #ARM_CC_Mask
        ORR     lr, lr, r12             ; Get mode and flags too
d1003 1
a1003 1
        Pull    "R12,PC",,^
d1005 1
a1005 1
        Pull    "R0-R2,R11,R12,PC",,^
d1007 4
a1010 1
        Pull    "R0-R2,R11,R12,LR,PC",,^
@


4.3
log
@Service call table change only merged in from Ursula branch.

Version 3.01. Tagged as 'FileCore-3_01'
@
text
@d23 7
d116 4
d136 1
d150 13
d261 11
d276 1
a276 1
 [ Debug1
d278 1
a278 1
 ]
d286 2
d349 6
d366 76
d451 1
a451 1
 [ Debug1
d453 1
a453 1
 ]
d456 1
a456 1
 [ Debug1
d458 1
a458 1
 ]
d471 2
d483 56
d591 3
d614 4
d625 25
d659 14
d677 1
d714 3
@


4.2
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d576 20
d598 3
d611 3
a613 1

@


4.1
log
@Initial revision
@
text
@d441 1
a441 1
  [ Version >= 205
d643 1
a643 1
 [ Version < 205
@


4.1.4.1
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@a22 4
DirBufferName
	= "FileCore Dir Buffer",0
	ALIGN

a123 38
        
 [ BigDir
 	ASSERT	BigDirMinSize>=NewDirSize
 	ASSERT	BigDirMinSize>=OldDirSize
 	; have to create a dynamic area.  call it 'FileCore DirBuffer'
 	Push	"R0-R8"
 	MOV	R0, #0			; create
 	MOV	R1, #-1			; don't care about the number
 	MOV	R2, #BigDirMinSize	; initial size of area
 	STR	R2, DirBufferSize	; store the size
 	MOV	R3, #-1			; don't care about the base
 	MOV	R4, #1+(1<<7)		; USR mode can't write, and not draggable
 	MOV	R5, #BigDirMaxSize	; max size of area
 	MOV	R6, #0			; no handler
 	MOV	R7, #0			; no workspace for handler
 	ADR	R8, DirBufferName	; name for dir buffer
 	SWI	XOS_DynamicArea		; try to create the area
 [ Debug1
 	DebugError "Dynamic area creation:"
 ]
 	BVC	%FT01
 	ADD	SP, SP, #9*4
 	MOV	R9, R0
        MOV     R0, #ModHandReason_Free
        MOV     R2, SB
        SWI     XOS_Module          ;Free workspace
       	MOV	R0, R9
       	BL	SetVOnR0
 	B	%FT95
01
 [ Debug1
 	DREG	R1, "DirBufferArea: "
 	DREG	R3, "DirBufferPtr : "
 ]
 	STR     R1, DirBufferArea
 	STR     R3, DirBufferPtr
 	Pull	"R0-R8"
 ]
d128 1
a128 1
 
a459 9
 [ BigDir
	; free the dynamic area for the dir buffer
	MOV	R0, #1
	LDR	R1, DirBufferArea
	SWI	XOS_DynamicArea 	
 
DieEntry_DynamicFail
	ORRVS	R9, R0, #ExternalErrorBit
 ]
@


4.1.4.2
log
@Fixed s.BigDirCode (GrowBigDir and ShrinkBigDir) to cope with BitSize<SecSize
and rewrote free space map memory management to place free space maps in
dynamic areas.
@
text
@d24 1
a24 4
	= "DirBuffer:%0 Dir Buffer",0
	ALIGN

MapArea = "MapArea:%0 Map (Drive %1)",0
d129 37
d271 1
a271 1
 
a277 11
 
 [ DynamicMaps
 
 	; with dynamic free space maps, we ignore WinnieSizes.  The maps
 	; are only allocated as and when they're needed.
 
        ADD     LR, SB, #:INDEX:ParentBase
        EOR     R4, R4, #4 :SHL: 16     ;convert configured drive to internal drive numbering
        STMIA   LR, {R1,R2,R4}

 |
d282 1
a282 1
   [ Debug1
d284 1
a284 1
   ]
a291 2
 ] ; DynamicMaps

a351 6
        
 [ DynamicMaps
 	STR	LR, [R4, #DrvsFsMapAddr]
 	STR	LR, [R4, #DrvsFsMapFlags]
 	STR	LR, [R4, #DrvsFsMapSize]
 ]
a362 76
        
 [ DynamicMaps
 
 	; if we're using dynamic areas for the free space maps, then the
 	; map for each configured drive is created as a dynamic area, with
 	; a maximum size of 4096K
 	
 	SUB	SP, SP, #256+4
 	
 	Push	"R2-R5"
 	
 	ADRL	R0, MapArea
 	
 	EOR	LR, R2, #4
 	ADD	LR, LR, #'0'
 	STR	LR, [SP, #256+4*4]
	ADD	R2, SP, #4*4
	MOV	R3, #256
	LDR	R4, FS_Title
	ADD	R5, SP, #256+4*4
	BL	message_lookup_to_buffer02	; do the message lookup
 	Pull	"R2-R5"
 	
 	; now null terminated string at SP (or V set)
 	
;	BVC	%FT14			; if no error, then message block is OK
;	
;	MOV	LR, SP
;	ADRL	R3, MapAreaDefault
;13
;	LDRB	r0, [r3], #1
;	TEQS	r0, #0
;	STRNEB	r0, [lr], #1
;	BNE	%BT13
;	
;	; now insert the drive number
;	EOR	r3, r2, #4
;	ADD	r3, r3, #'0'
;	STRB	r3, [lr], #1
;	STRB	r0, [lr], #1		; and the terminator
	
14
 [ Debug1
 	DSTRING	sp, "Dynamic name: "
 ]

 	Push	"R1,R2,R4-R8"
 	
 	MOV	R0, #0			; create
 	MOV	R1, #-1			; don't care about the number
 	MOV	R2, #0			; initial size of area
 	MOV	R3, #-1			; don't care about the base
 	MOV	R4, #1+(1<<7)		; USR mode can't write, and not draggable
 	MOV	R5, #FsMapMaxSize	; max size of area
 	MOV	R6, #0			; no handler
 	MOV	R7, #0			; no workspace for handler
	ADD	R8, SP, #7*4		; name pointer

	BL	OnlyXOS_DynamicArea	; do the dynamic area thing
	MOVVC	R0, R1			; dynamic area number
	MOVVS	R0, #0
 	Pull	"R1,R2,R4-R8"

	ADD	SP, SP, #256+4
 [ Debug1
 	DREG	R3, "Dynamic area base: "
 	DREG	R0, "Dynamic area num : "
 ]
	STR	R3, [R4, #DrvsFsMapAddr]; store the dynamic area base ptr
	STR	R0, [R4, #DrvsFsMapArea]; area number
	MOV	R0, #0			; 
	STR	R0, [R4, #DrvsFsMapSize]; allocated size

15
	Pull	"R2,R3"
 |
d373 1
a373 1
   [ Debug1
d375 1
a375 1
   ]
d378 1
a378 1
   [ Debug1
d380 1
a380 1
   ]
a391 2
        
 ] ; DynamicMaps
d402 1
a402 57
 
 ; here we allocate the dir buffer
 
 [ BigDir
 	ASSERT	BigDirMinSize>=NewDirSize
 	ASSERT	BigDirMinSize>=OldDirSize
 	; have to create a dynamic area.  call it 'FileCore DirBuffer'
 	Push	"R0-R8"
 	
 	MOV	R0, #0
 	STR	R0, DirBufferPtr
 	STR	R0, DirBufferArea
 	
 	SUB	SP, SP, #256		; buffer for message lookup
 	
 	ADRL	R0, DirBufferName	; get the message ptr
 	MOV	R2, SP
 	MOV	R3, #256
 	LDR	R4, FS_Title		; name of filing system
 	BL	message_lookup_to_buffer01	; do the message lookup
 	BVC	%FT01
 	
 	ADD	SP, SP, #256
 	STR	R0, [SP]
 	Pull	"R0-R8"
 	B	%FT85
01
 	
 	MOV	R0, #0			; create
 	MOV	R1, #-1			; don't care about the number
 	MOV	R2, #BigDirMinSize	; initial size of area
 	STR	R2, DirBufferSize	; store the size
 	MOV	R3, #-1			; don't care about the base
 	MOV	R4, #1+(1<<7)		; USR mode can't write, and not draggable
 	MOV	R5, #BigDirMaxSize	; max size of area
 	MOV	R6, #0			; no handler
 	MOV	R7, #0			; no workspace for handler
 	MOV	R8, SP			; name for dir buffer
 	BL	OnlyXOS_DynamicArea	; try to create the area
 	ADD	SP, SP, #256		; free buffer
 [ Debug1
 	DebugError "Dynamic area creation:"
 ]
 	BVC	%FT01
 	STR	R0, [SP]
 	Pull	"R0-R8"
 	B	%FT85
01
 [ Debug1
	DREG	R1, "DirBufferArea: "
	DREG	R3, "DirBufferPtr : "
 ]
	STR     R1, DirBufferArea
	STR     R3, DirBufferPtr
	Pull	"R0-R8"
 ]
 	
a481 8
 [ BigDir
	; free the dynamic area for the dir buffer
	MOV	R0, #1
	LDR	R1, DirBufferArea
	TEQS	R1, #0
	BLNE	OnlyXOS_DynamicArea 	
 ]

a490 6
  [ DynamicMaps
  	MOV	R0, #1
  	LDR	R1, [R2, #DrvsFsMapArea]
  	TEQS	R1, #0
  	BLNE	OnlyXOS_DynamicArea	; ditch the dynamic area
  |
a494 1
  ]
d502 9
@


4.1.4.3
log
@Now supports formatting of floppies with long file names.
@
text
@a114 4
 
 [ F
        ADD	R3, R3, #32*1024	; add a K
 ]
a144 13
        
 [ F
 [ DebugXm
 	DREG	R3, "end of dir cache: "
 ]
 	Push	"R0,R1"
 	MOV	R0, R3
 	MOV	R1, #32*1024
 	BL	ZeroRam
 	Pull	"R0,R1"
  	ADD	R3, R3, #32*1024

 ]
@


4.1.4.4
log
@Binary-chop dir scanning fixed.  (BigLexEqv fixed so that it doesn't
try to compare the dir separator '.' in eg "Default.Thing" with another
object called "Default+" (was breaking binary chop dir search).

Fixed IdentifyDisc (s.Identify); old behaviour left the RootDir field
invalid (the disc bits were an external drive number, instead of an
internal disc number).  This causes problems if the disc fails to mount
due to, for example, memory problems, as the illegal value never gets
fixed (normally, MountDiscOnDrive would end up correcting the problem).
@
text
@d115 1
a115 1

d135 1
a135 1

d140 1
a140 1

d149 1
a149 1

d254 1
a254 1

d261 1
a261 1

d263 1
a263 1

d266 1
a266 1

d348 1
a348 1

d365 1
a365 1

d367 1
a367 1

d371 1
a371 1

d373 1
a373 1

d375 1
a375 1

d377 1
a377 1

d387 1
a387 1

d389 1
a389 1

d391 1
a391 1
;
d399 1
a399 1
;
d405 1
a405 1

d412 1
a412 1

d435 1
a435 1
	MOV	R0, #0			;
d470 1
a470 1

d482 1
a482 1

d484 1
a484 1

d490 1
a490 1

d494 1
a494 1

d496 1
a496 1

d503 1
a503 1

d509 1
a509 1

d538 1
a538 1

a590 3
 [ Debug1
	DLINE	"FileCore DieEntry"
 ]
a610 4
 [ Debug1
	DLINE	"FileCore killing parent"
 ]

a617 4
 [ Debug
	DebugError "killing (filecore's) parent error: "
 ]

d623 1
a623 14
 [ Debug1
	BEQ	%FT01
	DREG	R1, "Removing DirBufferArea: "
01
 ]

	SWI	XOS_DynamicArea

 [ Debug1
	DLINE	"Removed DirBufferArea"
 ]
 [ Debug
	DebugError "Error from removing dir buffer area: "
 ]
a638 5
 [ Debug1
	BEQ	%FT01
	DREG	R1, "removing dynamic map: "
01
 ]
a639 3
   [ Debug
	DebugError "Error from removing disc map area: "
   ]
a681 3
 ]
 [ Debug1
	DLINE	"Exit from Filecore DieEntry"
@


4.1.4.5
log
@Now uses new Ursula service call mechanism.
@
text
@a803 20
 [ ServicePolice

ServiceTable
	&	0	; flags word
	&	ServiceEntry2	- org

	&	Service_ClaimFIQ
	&	Service_Memory
	&	Service_Reset
	&	Service_FSRedeclare
	&	Service_IdentifyDisc
	&	Service_EnumerateFormats
	&	Service_IdentifyFormat
	&	Service_DisplayFormatHelp
	&	Service_TerritoryStarted

	&	0

	&	ServiceTable	- org
 ]
a805 3
 [ ServicePolice
	MOV	r0, r0
 ]
d816 1
a816 3
 [ ServicePolice
ServiceEntry2
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

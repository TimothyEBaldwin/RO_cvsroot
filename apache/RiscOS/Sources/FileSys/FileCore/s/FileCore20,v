head	4.22;
access;
symbols
	FileCore-3_75:4.22
	FileCore-3_74:4.22
	FileCore-3_73:4.21
	FileCore-3_72:4.21
	FileCore-3_71:4.21
	FileCore-3_70:4.21
	FileCore-3_69:4.21
	FileCore-3_68:4.21
	FileCore-3_67:4.21
	FileCore-3_66:4.21
	FileCore-3_65:4.21
	FileCore-3_64:4.19
	FileCore-3_63:4.18
	FileCore-3_62:4.17
	FileCore-3_61:4.16
	FileCore-3_60:4.16
	FileCore-3_59:4.16
	FileCore-3_58:4.16
	FileCore-3_57:4.16
	FileCore-3_56:4.16
	FileCore-3_55:4.15
	FileCore-3_54:4.14
	FileCore-3_53:4.14
	FileCore-3_52:4.13
	FileCore-3_51:4.13
	FileCore-3_50:4.13
	FileCore-3_49:4.12
	FileCore-3_48:4.11
	FileCore-3_47:4.11
	FileCore-3_46:4.11
	FileCore-3_45:4.10
	FileCore-3_44:4.9
	FileCore-3_43:4.8
	FileCore-3_42:4.8
	FileCore-3_41:4.7
	FileCore-3_40:4.7
	FileCore-3_39:4.7
	FileCore-3_38:4.7
	FileCore-3_37:4.7
	FileCore-3_36:4.7
	FileCore-3_35:4.6
	FileCore-3_34:4.6
	FileCore-3_33:4.6
	RO_5_07:4.6
	FileCore-3_32:4.6
	FileCore-3_31:4.6
	FileCore-3_30:4.6
	FileCore-3_29:4.6
	FileCore-3_28:4.6
	FileCore-3_25-4_9_2_2:4.6
	FileCore-3_27:4.6
	FileCore-3_26:4.6
	FileCore-3_22-4_6_2_1:4.4
	bavison_FileCore-3_22_dev_bp:4.4
	bavison_FileCore-3_22:4.4.0.2
	FileCore-3_25-4_9_2_1:4.6
	HAL:4.6.0.2
	FileCore-3_25:4.6
	FileCore-3_24:4.5
	FileCore-3_23:4.5
	dellis_autobuild_BaseSW:4.4
	FileCore-3_22:4.4
	Ursula_merge:4.2.2.5
	ROL_merge:4.2.2.5
	FileCore-3_21:4.4
	ROL_Ursula_merge:4.2.2.5
	Ursula_RiscPC_merge:4.2.2.5
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.6
	ROL_FileCore-3_21:4.2.2.5
	ROL_FileCore-3_20:4.2.2.5
	ROL:4.2.2.5.0.4
	ROL_bp:4.2.2.5
	Ursula_RiscPC_bp:4.2.2.5
	FileCore-3_18:4.2.2.5
	FileCore-3_01:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.5
	Ursula_RiscPC:4.2.2.5.0.2
	FileCore-3_00:4.3
	FileCore-2_99:4.3
	aglover_FileCore-3_17:4.2.2.5
	sproven_FileCore-3_16:4.2.2.5
	rthornb_UrsulaBuild-19Aug1998:4.2.2.5
	UrsulaBuild_FinalSoftload:4.2.2.5
	rthornb_UrsulaBuild-12Aug1998:4.2.2.5
	aglover_UrsulaBuild-05Aug1998:4.2.2.5
	rthornb_UrsulaBuild-29Jul1998:4.2.2.5
	rthornb_UrsulaBuild-22Jul1998:4.2.2.5
	rthornb_UrsulaBuild-15Jul1998:4.2.2.5
	rthornb_UrsulaBuild-07Jul1998:4.2.2.5
	rthornb_UrsulaBuild-17Jun1998:4.2.2.5
	rthornb_UrsulaBuild-03Jun1998:4.2.2.5
	rthornb_UrsulaBuild-27May1998:4.2.2.5
	rthornb_UrsulaBuild-21May1998:4.2.2.5
	sproven_FileCore-3_15:4.2.2.5
	sproven_314:4.2.2.5
	rthornb_UrsulaBuild_01May1998:4.2.2.4
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.2.2.4
	sproven_3_11:4.2.2.4
	sproven_3_10:4.2.2.4
	sproven_Ursula_3_09:4.2.2.4
	sproven_3_07:4.2.2.3
	sproven_3_06:4.2.2.3
	sproven_3_05:4.2.2.3
	sproven_3_04:4.2.2.2
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.2.2.2
	sproven_3_02:4.2.2.2
	sproven_3_01:4.2.2.1
	sproven_2_99:4.2
	sproven_2_98:4.2
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.22
date	2017.06.16.11.00.36;	author rsprowson;	state Exp;
branches;
next	4.21;
commitid	izYr8Uu33U8FvAVz;

4.21
date	2015.02.03.12.40.08;	author bavison;	state Exp;
branches;
next	4.20;
commitid	1XQKJoa9wNpJOy8y;

4.20
date	2015.02.02.15.19.45;	author bavison;	state Exp;
branches;
next	4.19;
commitid	GC6RWzDQ9CNqKr8y;

4.19
date	2014.07.14.10.17.10;	author bavison;	state Exp;
branches;
next	4.18;
commitid	F4g0Km5lRubbBkIx;

4.18
date	2013.07.20.14.10.02;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	qZtNVkGjzh5uqdYw;

4.17
date	2013.07.18.21.04.17;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	Em91CJgLrlPBMZXw;

4.16
date	2013.02.24.21.09.15;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	rgJG8ZFRF8o9ruFw;

4.15
date	2013.02.21.16.53.06;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	CCuV2tngKttj75Fw;

4.14
date	2012.10.21.16.45.31;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	FoJ3R0fb1IiW1hpw;

4.13
date	2012.04.14.00.43.17;	author bavison;	state Exp;
branches;
next	4.12;
commitid	xkSKw5i9HVYqOL0w;

4.12
date	2012.03.24.10.51.30;	author jlee;	state Exp;
branches;
next	4.11;
commitid	yHV7AVt5Cxp0R7Yv;

4.11
date	2011.11.25.08.26.06;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	IoNdwgrOKH29UGIv;

4.10
date	2011.10.14.07.23.50;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	D2Id4aPp4zmuUhDv;

4.9
date	2011.10.12.20.21.50;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	BoinxgqWMKLth6Dv;

4.8
date	2011.10.02.20.25.33;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	A9Zxco9ydo9FCOBv;

4.7
date	2009.11.14.21.18.51;	author jlee;	state Exp;
branches;
next	4.6;

4.6
date	2000.10.31.17.05.06;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.30.13.26.34;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.09.11.36.53;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.09.21.12.07.14;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.18.42;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.32.16;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.09.16.14.46.41;	author sproven;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.11.17.13.32.22;	author sproven;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	98.01.09.11.45.00;	author sproven;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	98.02.11.16.49.20;	author sproven;	state Exp;
branches;
next	4.2.2.5;

4.2.2.5
date	98.05.07.16.58.07;	author sproven;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.32.16;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.18.50;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.33.59;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.30.53;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.22
log
@Fixes in BigSectors option
Previous testing with RAMFS was limited by the size of RAM disc, and hence complexity of layout, meaning some cases with BigSectors were missed.
FileCore20.s: During mount, when loading the defect list from the boot block at &C00, take care to round down the source sector address to account for it only being aligned up to 1k sectors (but not for 2k and 4k).
FileCore25.s: When loading the head of a BigDir (to find out its actual size) and finding it to be > 2k, skip loading the bit from 2k-4k, since that was already loaded when the head was read in, and reading it a second time offset by 2k fails the head/tail check.
FileCore31.s: When building a table to decide which zones to compact, use FindBuffer() to get some temporary store if too large to fit into ScratchSpace.
Identify.s: Comment updated.
BigDirCode.s: (Unrelated) Fix for bad error pointer being passed back, due to R0 being restored on encountering an error during directory rename.

FSBashed for 300k cycles on Titanium with an assortment of manufacturer drives, capacities, and sector sizes.

Version 3.74. Tagged as 'FileCore-3_74'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >FileCore20

        TTL     "Operations involving disc <-> drive mapping"

; SBP: 19 Aug 1997: Changed to be aware of the Zones2 field.

; Remove conditional assemblies from this file


; ========
; WhatDisc
; ========

; Return the disc record for a given drive
; Create a new record if unknown

; entry: R1 = drive number
; exit:
; IF error V set, R0 result
; ELSE
;        R1 = drive number
;        R2 = disc number
;        R3 = disc rec ptr
;
; Algorithm:
; discstate = PollChange( drive )
; if ( Uncertain:discstate )
;   determine uncertain disc( drive )
; else if ( Empty:discstate )
;   return DriveEmptyErr
; else if ( Bad:discstate )
;   disc bad, return drive error associated with drive
; else
;   disc good, return disc rec associated with drive

WhatDisc ROUT
        Push    "r0,r4,r5,r6,lr"

 [ Debug4 :LOR: DebugL

        DREG    R1, "<WhatDisc(Drv=",cc
        DLINE   ")"
 ]

        BL      CheckDriveNumber
        BVS     %FT80
05
        ; Test the disc's presence in the drive
        MOV     r0, r1
        BL      PollChange      ;(R0->LR)

        ; Get to the drive record
        DrvRecPtr r4,r1

        ; Start with no error
        MOV     r0, #0

        TSTS    lr, #Uncertain
        BEQ     %FT10

        ;Uncertain
 [ DebugL

        DLINE   "Having to mount and determine.."
 ]
        BL      MountDiscOnDrive                ; (r1,r4->V+r0,r1,r2,r4,r5,r6)
        BVS     %FT80
        BL      DetermineDiscType               ; (r1,r2,r4,r5,r6->V+r0,r2,r5,r6)
        MOVVC   r3, r5
        MOVVC   r0, #0
        B       %FT80

10
        ; Disc not uncertain, but...

        ; It might be empty...
        TSTS    lr, #Empty
        MOVNE   r0, #DriveEmptyErr
        BNE     %FT80

        ; or, just possibly, it might be good...
        MOV     r2, lr
        DiscRecPtr r3, r2               ; It's good return the disc record


        ; If disc hasn't been identified and we're interested in that....
        LDR     lr, [r3, #DiscFlags]
        TST     lr, #DiscNotIdentified
        BEQ     %FT80

 [ DebugL

        DLINE   "Having to determine..."
 ]
        BL      DetermineDiscType
        MOVVC   r3, r5
        MOVVC   r0, #0

80
        BL      SetVOnR0
 [ Debug4 :LOR: DebugL

        LDR     lr, [r3, #DiscRecord_Root]
        DREG    lr, "RootDir on Exit WhatDisc is: "

        DREG    R1, "<WhatDisc(Drv=",cc
        DREG    R2, ",Dsc=",cc
        DREG    R3, ",Rec=",cc
        DLINE   ")"
        DebugError "     WhatDisc error"
 ]
        BVS     %FT90
        ; DetermineDiscType can cause the disc and drive records to become
        ; unlinked due to the PollChanged within the DiscOps used to load the
        ; boot block - this was designed to support ADFS floppies, but interacts
        ; badly in particular with SDFS for removable drives with no disc detect
        ; (e.g. Raspberry Pi B+). If this happens, loop round and try again.
        LDRB    r0, [r3, #DiscsDrv]
        TEQ     r0, #8
        BEQ     %BT05
        Pull    "r0,r4,r5,r6,pc"

90      ADD     sp, sp, #4
        Pull    "r4,r5,r6,pc"

; ================
; CheckDriveNumber
; ================
;
; Entry
;   r1 = internal drive number
; Exit
;   V, r0=error

CheckDriveNumber ROUT
        Push    "lr"
        CMP     r1, #4
        LDRLOB  lr, Winnies
        LDRHSB  lr, Floppies
        ADDHS   lr, lr, #4
        CMP     r1, lr
 [ Debug4
        BLO     %FT01
        DREG    r1, "Bad drive specified:"
01
 ]
        MOVHS   r0, #BadDriveErr
        SETV    HS
        Pull    "pc"

        LTORG

; =================
; DetermineDiscType (r1,r2,r4,r5,r6->V+r0,r2,r5,r6)
; =================

; Given that the drive doesn't know what type of disc is in it
; determine what it is. The disc is assumed mounted and certain.

; Entry:
;   r1 = drive number
;   r2 = disc number
;   r4 ->drive record
;   r5 ->disc record
;   r6 = read sectors cache
;
; Exit:
;   V and r0=error is possible
;   r2 = new disc number
;   r5 ->new disc record
;   r6 = read sectors cache discarded
;
; Algorithm:
;
; identify the disc (return error, keep cache)
; Search the disc records for a matching disc (not the same as the one we've got)
; if ( not found )
;   Fill in filetype in disc record
;   use the disc record we were allocated
; else if ( found )
;   detach allocated disc from this drive
;   free allocated disc
;   detach found disc from original drive
;   attach found disc to this drive
;   use found disc record
; If ( identity==FileCore_FloppyDisc or FileCore_HardDisc )
;   StartupFileCoreDisc
; else
;   StartupNonFileCoreDisc

DetermineDiscType ROUT
        Push    "r0,r1,r3,r4,r7,r11,lr"

 [ DebugL

        DLINE   "Determining disc type"
 ]

        MOV     r0, r1
        LDRB    r7, [r4, #DrvFlags]
        BL      IdentifyDisc            ; (r0,r5->r0,r6)
        STR     r0, [r5, #DiscRecord_DiscType]

        ; Disc now identified
        LDRB    lr, [r5, #DiscFlags]
        BIC     lr, lr, #DiscNotIdentified
        STRB    lr, [r5, #DiscFlags]

        ; If disc is data then don't attempt to match against other discs
        LDR     lr, =FileType_Data
        TEQ     r0, lr
        BNE     %FT02

        ; Disc failed to identify, so, if last disc op was format before
        ; identification then use those parameters
        TST     r7, #LastDiscOpWasFormat
        LDRNEB  lr, [r4, #PrevFormSectorSize]
        STRNEB  lr, [r5, #DiscRecord_Log2SectorSize]
        LDRNEB  lr, [r4, #PrevFormSecsPerTrk]
        STRNEB  lr, [r5, #DiscRecord_SecsPerTrk]
        LDRNEB  lr, [r4, #PrevFormHeads]
        STRNEB  lr, [r5, #DiscRecord_Heads]
        LDRNEB  lr, [r4, #PrevFormDensity]
        STRNEB  lr, [r5, #DiscRecord_Density]
        LDRNEB  lr, [r4, #PrevFormLowSector]
        STRNEB  lr, [r5, #DiscRecord_LowSector]
        LDRNE   lr, [r4, #PrevFormDiscSize]
        STRNE   lr, [r5, #DiscRecord_DiscSize]
 [ BigDisc
        LDRNE   lr, [r4, #PrevFormDiscSize2]
        STRNE   lr, [r5, #DiscRecord_BigMap_DiscSize2]
 ]

 [ DebugLm
        DLINE   "Blanking out disc name"
 ]

        ; Blank out the disc name
        MOV     lr, #0
        ASSERT  ?DiscRecord_DiscName = 10
        ASSERT  DiscRecord_DiscName :MOD: 4 = 2
        STRB    lr, [r5, #DiscRecord_DiscName+0]
        STRB    lr, [r5, #DiscRecord_DiscName+1]
        STR     lr, [r5, #DiscRecord_DiscName+2]
        STR     lr, [r5, #DiscRecord_DiscName+6]

        B       %FT60
02

 [ DebugLm

        Push    "r0"
        LDR     r0, [r5, #DiscRecord_DiscType]
        DREG    r0, "Disc identified...Type=",cc
        ASSERT  DiscRecord_DiscId :MOD: 4 = 0
        LDR     r0, [r5, #DiscRecord_DiscId]
        MOV     r0, r0, ASL #16
        MOV     r0, r0, LSR #16
        DREG    r0, " DiscId=",cc
        ADD     r0, r5, #DiscRecord_DiscName
        DSTRING r0, " name=",cc
        LDR     r0, [r5, #DiscRecord_DiscSize]
        DREG    r0, " DiscSize="
        DLINE   "trying to match against other records..."
        Pull    "r0"
 ]
 [ DebugLi
        Push    "r0"
        DREG    r2, "Mount: Id on Disc ",cc
        LDR     r0, [r5, #DiscRecord_DiscId]
        MOV     r0, r0, ASL #16
        MOV     r0, r0, LSR #16
        DREG    r0, " is "
        Pull    "r0"
 ]

        ; Find for a matching disc in the disc records array starting at
        ; the old disc record
        MOV     r7, #1
        B       %FT10

05
        ; Move to next disc record
        ADD     r7, r7, #1
        CMP     r7, #8
        BHS     %FT60

10
        EOR     r3, r7, r2
 [ DebugLm
        DREG    R3, "Matching against record ",cc
 ]
        DiscRecPtr r3, r3
 [ DebugLm
        DREG    R3, " at "
 ]
        LDRB    lr, [r3, #Priority]
        TEQ     lr, #0
 [ DebugLm

        BNE     %FT01
        DLINE   "Record empty"
01
 ]
        BEQ     %BT05           ; Disc record empty

        ; Compare the disc record. The fields which must match are:
        ; DiscType
        ; Log2SectorSize
        ; SecsPerTrk
        ; Heads
        ; Density
        ; LowSector
        ; DiscSize
 [ BigDisc
        ; DiscSize2
 ]
        ; DiscId
        ; DiscName
        LDR     r0, [r3, #DiscRecord_DiscType]
        LDR     lr, [r5, #DiscRecord_DiscType]
        TEQ     r0, lr
        ASSERT  (DiscRecord_Log2SectorSize :MOD: 4) = 0
        ASSERT  DiscRecord_SecsPerTrk = DiscRecord_Log2SectorSize+1
        ASSERT  DiscRecord_Heads = DiscRecord_SecsPerTrk+1
        ASSERT  DiscRecord_Density = DiscRecord_Heads+1
        LDREQB  r0, [r3, #DiscRecord_Log2SectorSize]
        LDREQB  lr, [r5, #DiscRecord_Log2SectorSize]
        TEQEQ   r0, lr
        LDREQB  r0, [r3, #DiscRecord_LowSector]
        LDREQB  lr, [r5, #DiscRecord_LowSector]
        TEQEQ   r0, lr

        LDREQ   r0, [r3, #DiscRecord_DiscSize]
        LDREQ   lr, [r5, #DiscRecord_DiscSize]
        TEQEQ   r0, lr
 [ BigDisc
        LDREQ   r0, [r3, #DiscRecord_BigMap_DiscSize2]
        LDREQ   lr, [r5, #DiscRecord_BigMap_DiscSize2]
        TEQEQ   r0, lr
 ]
        ASSERT  (DiscRecord_DiscId :MOD: 4) = 0
        LDREQ   r0, [r3, #DiscRecord_DiscId]
        LDREQ   lr, [r5, #DiscRecord_DiscId]
        EOREQ   r0, r0, lr
        MOVEQS  r0, r0, ASL #16
 [ DebugLm

        BEQ     %FT01
        DLINE   "Not a match - type, sectsize, lowsector, discsize, discsize2, discid"
01
 ]
        BNE     %BT05

        ; Check the disc name matches
        MOV     r11, #?DiscRecord_DiscName
        ADD     r3, r3, #DiscRecord_DiscName + ?DiscRecord_DiscName
        ADD     r5, r5, #DiscRecord_DiscName + ?DiscRecord_DiscName
11
        LDRB    lr, [r3, -r11]
        CMP     lr, #" "
        TEQHI   lr, #DeleteChar
        MOVLS   lr, #0
        LDRB    r0, [r5, -r11]
        CMP     r0, #" "
        TEQHI   r0, #DeleteChar
        MOVLS   r0, #0
        MOVLS   r11, #1         ; To terminate early
        TEQ     r0, lr
 [ DebugLm
        DREG    r0, "ChMatch:",cc
        MOV     r0, lr
        DREG    r0, "=?"
 ]
        BNE     %FT12
        SUBS    r11, r11, #1
        BNE     %BT11
12
        SUB     r3, r3, #DiscRecord_DiscName + ?DiscRecord_DiscName
        SUB     r5, r5, #DiscRecord_DiscName + ?DiscRecord_DiscName
 [ DebugLm

        BEQ     %FT01
        DLINE   "Not a match - discname"
01
 ]
        BNE     %BT05
 [ DebugLm

        DLINE   "It's a match"
 ]

        ; Disc found amoungst known discs

        ; Detach allocated disc from drive and free it
        MOV     r0, r2
        BL      FreeDiscRec

        ; Construct parameters for original disc
        EOR     r2, r7, r2      ; number
        MOV     r5, r3          ; record

        ; Detach found disc from its original drive
        MOV     r0, r2
        BL      UnlinkByDisc

        ; Adjust FloppyFlag in old record to match new drive
        ; Also set NeedNewIdFlag so that if this disc has just been seen
        ; by another machine and we now update it the sequence number gets
        ; updated too so that other machine doesn't get confused as to which
        ; disc is changed or not changed.
        LDRB    r0, [r5, #DiscFlags]
 [ DebugL
        DREG    r0, "DiscFlags in DetermineDiscType are "
 ]
        TST     r1, #4
        BICEQ   r0, r0, #FloppyFlag
        ORRNE   r0, r0, #FloppyFlag
        ORR     r0, r0, #NeedNewIdFlag
 [ DebugL
        DREG    r0, "DiscFlags set to "
 ]
        STRB    r0, [r5, #DiscFlags]

        ; Adjust FcbFloppyFlag in Fcbs attached to old disc to match new drive
        LDR     r11, FirstFcb
        B       %FT25

15
        ; Reject if attached to a different disc
        LDR     r0, [r11, #FcbIndDiscAdd]
        TEQ     r2, r0, LSR #(32-3)
        BNE     %FT20

 [ DebugL
        LDR     r0, [r11, #FcbExtHandle]
        DREG    r0, "Adjusting disc type of file "
 ]

        ; Adjust FcbFlags to match
        LDRB    r0, [r11, #FcbFlags]
        TST     r1, #4
        BICEQ   r0, r0, #FcbFloppyFlag
        ORRNE   r0, r0, #FcbFloppyFlag
        STRB    r0, [r11, #FcbFlags]

20
        ; Next Fcb
        LDR     r11, [r11, #FcbNext]
25
        ; Test for end of Fcb list
        CMP     r11, #-1
        BNE     %BT15

        ; attach found disc to this drive
        STRB    r2, [r4, #DrvsDisc]
        STRB    r1, [r5, #DiscsDrv]

  [ DebugL
        DREG    r1, "************************ DiscsDrv set to ",cc
        DLINE   " in DetermineDiscType *****************************"
  ]

        ; Make sure it isn't discarded too soon!
        MOV     r0, r2
        BL      UpdatePriority

        ; If this is a non-FileCore disc poke all clients that they should
        ; update discid on update
        LDRB    r0, [r5, #DiscFlags]
        TST     r0, #DiscNotFileCore
        BEQ     %FT60

        ; Construct full path to root to do FSControl_StampImage

        Push    "r1,r2"

        MOV     r1, #FSControl_StampImage_NextUpdate
        ADD     r2, r5, #DiscRecord_DiscName
        BL      StampImage

        Pull    "r1,r2"

        ; Ignore any error at this point
        CLRV

        ; Drop through to startup disc

60
        ; Found, and have filled in a disc record for this disc
        ;
        ; Register at this moment are:
        ; r1 = drive number
        ; r2 = disc number
        ; r4 ->drive record
        ; r5 ->disc record
        ; r6 = read sectors cache

 [ DebugL

        DLINE   "Starting up disc..."
 ]

        LDR     r0, [r5, #DiscRecord_DiscType]
        LDR     lr, =FileType_FileCoreFloppyDisc
        TEQ     r0, lr
        LDRNE   lr, =FileType_FileCoreHardDisc
        TEQNE   r0, lr
        BNE     %FT70

        ; It's a FileCore disc
        BL      StartupFileCoreDisc
        B       %FT80

70
        BL      StartupNonFileCoreDisc

80
        ; Disc started (maybe): if error then disc is just so much random data
        ; An error shouldn't occur as the disc wouldn't have identified correctly
 [ DebugL
        BVC     %FT01
        DREG    r0, "Mapping to FileType_Data due to error:"
01
 ]
        LDRVS   r1, =FileType_Data
        STRVS   r1, [r5, #DiscRecord_DiscType]
        BVS     %FT90

        ; Disc in drive is now certain
        ; However, there is a possibility that PollChange calls during disc
        ; startup may have delinked the disc and drive, so make sure it's still
        ; valid before we mark the drive as certain
        LDRB    r1, [r4, #DrvsDisc]
        TST     r1, #Unknown :OR: Empty :OR: Full
        BICEQ   r1, r1, #Uncertain
        STREQB  r1, [r4, #DrvsDisc]

        ; If disc remained unidentified then check read sectors cache for errors
        ; If we find an error then use that
        LDR     r1, [r5, #DiscRecord_DiscType]
        LDR     lr, =FileType_Data
        TEQ     lr, r1
        BNE     %FT90
        MOV     r1, r6
        B       %FT87
85
        LDR     r0, [r1, #SectorCache_Error]
        TEQ     r0, #0
 [ DebugL
        BEQ     %FT01
        DREG    r0, "Error found is "
01
 ]
        BLNE    SetV
        BVS     %FT90
        LDR     r1, [r1, #SectorCache_Next]
87
        TEQ     r1, #0
        BNE     %BT85

90
        STRVS   r0, [sp]

        ; Save V state over discard of readsectors cache (don't care if it fails)
        SavePSR r7
        BL      DoSwiDiscardReadSectorsCache
        RestPSR r7,,f

 [ DebugL
        DREG    R5, "Disc rec ptr now: "
 ]

        Pull    "r0,r1,r3,r4,r7,r11,pc"

        LTORG

; ==========
; StampImage
; ==========

; entry
;  r1 = type of stamp image
;  r2 = disc name of image

; exit
;  error possible
StampImage ROUT
        Push    "r0-r4,lr"

        MOV     r4, r1

        ; Construct full path to root to do FSControl_StampImage

        LDR     r1, FS_Title
        BL      strlen
        ADD     r3, r3, #?DiscRecord_DiscName + 2 + 1 + 3  ; <FS>::<DiscName>
        BIC     r3, r3, #3
        SUB     sp, sp, r3

        ; <FS>
        MOV     r0, sp
30
        LDRB    lr, [r1], #1
        STRB    lr, [r0], #1
        TEQ     lr, #0
        BNE     %BT30

        ; ::
        MOV     lr, #":"
        STRB    lr, [r0, #-1]
        STRB    lr, [r0], #1

        ; <DiscName>
        MOV     r1, #?DiscRecord_DiscName
35
        LDRB    lr, [r2], #1
        CMP     lr, #" "
        TEQHI   lr, #DeleteChar
        MOVLS   lr, #0
        MOVLS   r1, #1
        STRB    lr, [r0], #1
        SUBS    r1, r1, #1
        BNE     %BT35

        MOV     lr, #0
        STRB    lr, [r0], #1

        MOV     r0, #FSControl_StampImage
        MOV     r1, sp
        MOV     r2, r4
 [ DebugLi

        DSTRING r1, "FSControl_StampImage(",cc
        DREG    r2, ",",cc
        DLINE   ")"
 ]
        BL      DoXOS_FSControl

        ADD     sp, sp, r3
        STRVS   r0, [sp]
        Pull    "r0-r4,pc"



; ================
; MountDiscOnDrive (r1,r4->V+r0,r1,r2,r4,r5,r6)
; ================
;
; entry
;   r1 = drive number
;   r4 ->drive record
;
; exit
;   V, r0=error is possible
;   r1 = drive number
;   r2 = disc number
;   r4 ->drive record
;   r5 ->disc record
;   r6 = read sectors cache handle
;
; This routine mounts the disc in the given drive as a FileType_Data
; disc which is DiscNotFileCore. The drive's contents are assumed to be
; Uncertain. If the disc Mounts OK and a disc record is found for it,
; then the record will be filled in and attached to the drive.
;
; Algorithm:
; Get the old attached disc record's density
; Mark the FSMap as empty (for old map disc handling)
; Unlink the old disc from this drive
; Unlink defect list from drive
; Allocate a new disc record
; Store the density in the new record
; Set the drive to 'No defect list'
; Mount the disc
; Set the disc type to FileType_Data
; Set the disc to DiscNotFileCore and set FloppyFlag if appropriate
; Attach the record to the drive

MountDiscOnDrive ROUT
        Push    "r0,r3,r8,lr"

 [ DebugL
        DREG    r1, "Mounting ",cc
        DREG    r4, " on record "
 ]

        ; Get density of disc currently (but not for much longer) attached to drive
        LDRB    r8, [r4, #DrvsDisc]
        BIC     r8, r8, #Uncertain
        CMP     r8, #8
        MOVHS   r8, #0                  ; Start at Density=0 if no valid disc previously attached
        BHS     %FT10

 [ DebugL
        DREG    r8, "Old disc attached to drive:"
 ]

        ; Had a disc record attached
        DiscRecPtr lr, r8
        LDRB    r8, [lr, #DiscRecord_Density]      ; Density of disc last in this drive

        ; Mark FsMap for old map disc as Empty
        LDRB    r0, [lr, #DiscFlags]
 [ DebugL
        DREG    r0, "Old disc flags are "
 ]
        TST     r0, #DiscNotFileCore
        LDREQB  r0, [lr, #DiscRecord_NZones]
        TEQEQ   r0, #0
 [ BigMaps
        LDREQB  r0, [lr, #DiscRecord_BigMap_NZones2]
        TEQEQ   r0, #0
 ]
 [ DynamicMaps
        LDREQ   r0, [r4, #DrvsFsMapFlags]
        ORREQ   r0, r0, #EmptyFs
        STREQ   r0, [r4, #DrvsFsMapFlags]
 |
        LDREQ   r0, [r4, #DrvsFsMap]
        ORREQ   r0, r0, #EmptyFs
        STREQ   r0, [r4, #DrvsFsMap]
 ]


        ; Unlink the old disc from this drive
        MOV     r0, r1
        BL      UnlinkByDrive

10
 [ DebugL
        DREG    r8, "Going to use initial density "
 ]

        ; Find a disc record
        BL      FindDiscRec
        BVS     %FT90
        MOV     r5, r3

 [ DebugL
        DREG    r2, "Found disc record ",cc
        DREG    r5, " at "
 ]

        ; Clear out fields which would cause problems if not cleared out:
        ; IdLen, Log2bpmb, Skew, BootOpt, Zones, ZoneSpare, DiscId, DiscName
        MOV     lr, #0
        ASSERT  DiscRecord_IdLen :MOD: 4 = 0
        ASSERT  DiscRecord_Log2bpmb = DiscRecord_IdLen + 1
        ASSERT  DiscRecord_Skew = DiscRecord_Log2bpmb + 1
        ASSERT  DiscRecord_BootOpt = DiscRecord_Skew + 1
        STR     lr, [r5, #DiscRecord_IdLen]

        STRB    lr, [r5, #DiscRecord_NZones]
 [ BigMaps
        STRB    lr, [r5, #DiscRecord_BigMap_NZones2]
 ]
        STRB    lr, [r5, #DiscRecord_ZoneSpare]
        STRB    lr, [r5, #DiscRecord_ZoneSpare+1]

        ASSERT  DiscRecord_DiscId :MOD: 4 = 0
        ASSERT  DiscRecord_DiscName = DiscRecord_DiscId + 2
        STR     lr, [r5, #DiscRecord_DiscId]
 [ BigDisc
        ; DiscSize2
        STR     lr, [r5,#DiscRecord_BigMap_DiscSize2]
 [ BigShare
        ; ShareSize
        STR     lr, [r5,#DiscRecord_BigMap_ShareSize]
 ]
 ]


        ; Set up a sensible pre-guess at the RootDir
 [ DebugL
        DREG    r2, "Setting RootDir from "
 ]
        MOV     lr, r2, ASL #(32-3)
        STR     lr, [r5, #DiscRecord_Root]

        ; Fill in old density
        STRB    r8, [r5, #DiscRecord_Density]

        ; Mark drive as having no defect list
        LDRB    r0, [r4, #DrvFlags]
        BIC     r0, r0, #HasDefectList
        STRB    r0, [r4, #DrvFlags]

; as a hack to try to get floppies to mount - set DiscSize2 to 0

        ; Mount the disc
        Push    "r2,r4"
        MOVS    r2, r1, ASL #(32-3)
        EOR     r2, r2, #bit31          ; Convert to external drive numbering
        MOV     r3, #BadPtr             ; Bad address just in case the driver gets frisky
        MOV     r4, #0
        LDRPL   r0, WinnieProcessBlk
        MOVPL   r6, #WinnieLock
        LDRMI   r0, FloppyProcessBlk
        MOVMI   r6, #FloppyLock
        BL      Mount
        Pull    "r2,r4"
        BVS     %FT90

        ; Set disc record to data
        ; And attach disc and drive together
 [ DebugL
        LDR     r0, [r5, #DiscRecord_Log2SectorSize]
        DREG    r0, "Mounted OK - parameters from mount are:"
 ]
        MOV     r0, #DiscNotFileCore
        TST     r1, #bit2
        ORRNE   r0, r0, #FloppyFlag
        ORR     r0, r0, #DiscNotIdentified
 [ DebugL
        DREG    r0, "DiscFlags set to "
 ]
        STRB    r0, [r5, #DiscFlags]
        LDR     r0, =FileType_Data
        STR     r0, [r5, #DiscRecord_DiscType]
        MOV     r0, #0
        STRB    r0, [r5, #Priority]
        STRB    r0, [r5, #DiscUsage]
        STRB    r1, [r5, #DiscsDrv]
 [ DebugL
        DREG    r1, "************************* DiscsDrv set to",cc
        DLINE   " in MountDiscOnDrive *************************"
        DREG    r2, "DrvsDisc set to "
 ]
        STRB    r2, [r4, #DrvsDisc]
        ASSERT  DiscRecord_DiscName = DiscRecord_DiscId + 2
        STR     r0, [r5, #DiscRecord_DiscId]
        STR     r0, [r5, #DiscRecord_DiscName+2]
        STR     r0, [r5, #DiscRecord_DiscName+6]

 [ BigDir
        LDR     lr, [r5, #DiscRecord_Root]
        BIC     lr, lr, #DiscBits
        ORR     lr, lr, r2, LSL #(32-3)
        STR     lr, [r5, #DiscRecord_Root]
 ]

        ; Make sure this disc is thought to be used
        MOV     r0, r2
        BL      UpdatePriority

90
        STRVS   r0, [sp]
        Pull    "r0,r3,r8,pc"

; ===================
; StartupFileCoreDisc
; ===================

; Entry
;   r1 = drive number
;   r2 = disc number
;   r4 ->drive record
;   r5 ->disc record
;   r6 = read sectors cache
;
; Exit
;   r6 = new read sectors cache
;
; This routine initialises the DriveRec given that the disc is a FileCore disc
;

StartupFileCoreDisc ROUT
        Push    "r0-r5,r7-r11,lr"

 [ DebugL

        DLINE   "Starting up filecore disc"
        DREG    r1, "Drive=", cc
        DREG    r4, " at "
        DREG    r2, "Disc=",cc
        DREG    r5, " at "
        DREG    r6, "Cache = "

        LDRB    r11, [r5, #DiscFlags]
        DREG    r11, "Disc flags are "
 ]

        BL      ReadDefectList
 [ DebugL
        LDRB    r11, [r5, #DiscFlags]
        DREG    r11, "Disc flags are "
 ]


 [ :LNOT: ReadMapDuringIdentify
        BLVC    AdjustFsSpace
 [ DebugL
        LDRB    r11, [r5, #DiscFlags]
        DREG    r11, "Disc flags are "
 ]
 ]

        BLVC    ReadFsMap
        BVS     %FT90

        ; Make sure disc is FileCore
        LDRB    r11, [r5, #DiscFlags]
        TST     r11, #DiscNotFileCore
        BIC     r11, r11, #DiscNotFileCore
        ORRNE   r11, r11, #NeedNewIdFlag        ; Set NeedNewId if it is a fresh FileCore disc
 [ DebugL
        DREG    r11, "DiscFlags set to "
 ]
        STRB    r11, [r5, #DiscFlags]

90
        STRVS   r0, [sp]
 [ DebugL

        DLINE   "Starting of FileCore disc done"
        BVC     %FT01
        DREG    r0, "Error produced:"
01
 ]
        Pull    "r0-r5,r7-r11,pc"

; ==============
; ReadDefectList
; ==============

; Entry
;   r1 = drive number
;   r4 ->drive record
;   r5 ->disc record
;   r6 = read sectors cache
;
; Exit
;   V, r0=error is possible
;   r6 = new read sectors cache

; Reads DefectList, sets HasDefectList
; Copies Zones, ZoneSpare, BitSize to disc record

ReadDefectList ROUT
        Push    "r0-r4,r11,lr"

        LDR     lr, =FileType_FileCoreHardDisc
        LDR     r0, [r5, #DiscRecord_DiscType]
        TEQ     r0, lr
        BNE     %FT20

 [ DebugL

        DLINE   "It's a winnie...read defect list"
 ]

        ; It's a FileCore hard disc, read the bad block list
        MOV     r4, #SzDefectList
        LDR     r3, DefectSpace
        ADD     r3, r3, SB
        ASSERT  SzDefectList = (1 :SHL: 9)
        ADD     r3, r3, r1, ASL #9
      [ BigSectors
        ; For 2k and 4k sector sizes the defect list isn't on a sector boundary
        ; any more, so read via an intermediate buffer
        LDRB    r2, [r5, #DiscRecord_Log2SectorSize]
        ASSERT  (DefectListDiscAdd :MOD: 1024) = 0
        CMP     r2, #10
        ASSERT  ?ScratchSpace >= SzDefectList
        MOVHI   r3, #ScratchSpace
        ASSERT  SzDefectList <= 1:SHL:11
        MOVHI   r4, #1
        MOVHI   r4, r4, LSL r2
      ]
        MOV     r2, r1, ASL #(32-3)     ; Top 3 drive bits
        MOV     r1, #DiscOp_CachedReadSecs
 [ BigDisc
        Push    "R10,R11"
        LDRB    r11, [r5, #DiscRecord_Log2SectorSize]
        MOV     r10,#DefectListDiscAdd
        ORR     r2,r2,r10,LSR r11       ; Offset in sectors
        Pull    "R10,R11"
 |
        ORR     r2, r2, #DefectListDiscAdd
 ]
        BL      RetryDriveOp
        BVS     %FT90                   ; Bog it, defect list didn't read


        ; Assume defect list is OK as it must have been checked in identifying the disc

        ; Restore r1,r2 and r4 (and r3 too, but don't care about that)
        LDMIB   sp, {r1-r4}

        ; Flag against the drive that it has a bad block list
        LDRB    r0, [r4, #DrvFlags]
        ORR     r0, r0, #HasDefectList
        STRB    r0, [r4, #DrvFlags]

        ; Get address of disc record in bad block area
        LDR     r3, DefectSpace
        ADD     r3, r3, SB
        ASSERT  SzDefectList = (1 :SHL: 9)
        ADD     r3, r3, r1, ASL #9

      [ BigSectors
        LDRB    r0, [r5, #DiscRecord_Log2SectorSize]
        CMP     r0, #10
        BLS     %FT10                   ; Was directly loaded

        MOV     r14, #DefectListDiscAdd
        MOV     r1, r14, LSR r0
        SUB     r0, r14, r1, LSL r0     ; R0 := defect list addr MOD sector size
        ADD     r0, r0, #ScratchSpace   ; src
        MOV     r1, r3                  ; dest
        MOV     r2, #SzDefectList       ; len
        ASSERT  (SzDefectList :MOD: 256) = 0
        BL      Move256n                ; (R0-R2->R0-R2)
10
      ]
        ADD     r3, r3, #DefectStruc

        ; Copy zones to our disc record
        LDRB    r0, [r3, #DiscRecord_NZones]
        STRB    r0, [r5, #DiscRecord_NZones]
 [ BigMaps
        LDRB    r0, [r3, #DiscRecord_BigMap_NZones2]
        STRB    r0, [r5, #DiscRecord_BigMap_NZones2]
 ]

        ; If zones <> 0, then copy ZoneSpare and Log2bpmb too for E format
        TEQ     r0, #0
        LDRNEB  r0, [r3, #DiscRecord_ZoneSpare]
        STRNEB  r0, [r5, #DiscRecord_ZoneSpare]
        LDRNEB  r0, [r3, #DiscRecord_ZoneSpare+1]
        STRNEB  r0, [r5, #DiscRecord_ZoneSpare+1]
        LDRNEB  r0, [r3, #DiscRecord_Log2bpmb]
        STRNEB  r0, [r5, #DiscRecord_Log2bpmb]

 [ DebugL

        DLINE   "Defect list has read OK"
 ]
        B       %FT80

20
 [ DebugL

        DLINE   "It's a floppy...no defect list to read"
 ]

        ; It's a FileCore floppy disc, read sector 0 byte 2 to test bit 7 of it
        SUB     sp, sp, #4
        MOV     r3, sp                  ; read to the stack
        MOV     r4, #4                  ; 4 bytes to read
        MOV     r2, r1, ASL #(32-3)
        MOV     r1, #DiscOp_CachedReadSecs
        BL      RetryDriveOp
        LDRB    r0, [sp,#FreeLink + 1]
        ADD     sp, sp, #4

        ; Restore r1,r2 and r4 (and r3 too, but don't care about that)
        LDMIB   sp, {r1-r4}

        BVS     %FT30                   ; Byte 2 didn't read, but it is a floppy, assume it's an E floppy

        TST     r0, #bit7               ; Check for FreeLink end bit
        BNE     %FT30

        ; It's a D or L format disc
        MOV     r0, #0
        STRB    r0, [r5, #DiscRecord_NZones]
 [ BigMaps
        STRB    r0, [r5, #DiscRecord_BigMap_NZones2]
 ]
        B       %FT40

30
        CLRV    ; To make sure V from RetryDriveOp above doesn't cause problems

        ; It's an E format disc - frig up some values which work to read the map
        MOV     r0, #1
        STRB    r0, [r5, #DiscRecord_NZones]
        MOV     r0, #0
 [ BigMaps
        STRB    r0, [r5, #DiscRecord_BigMap_NZones2]
 ]
        STRB    r0, [r5, #DiscRecord_ZoneSpare]
        STRB    r0, [r5, #DiscRecord_ZoneSpare+1]
        STRB    r0, [r5, #DiscRecord_Log2bpmb]

40
        ; It's a floppy - clear hasdefectlist and set need new id and floppy flag
        LDRB    r0, [r4, #DrvFlags]
        BIC     r0, r0, #HasDefectList
        STRB    r0, [r4, #DrvFlags]

80
        ; DefectList read OK

90
        STRVS   r0, [sp]
        Pull    "r0-r4,r11,pc"

; =============
; AdjustFsSpace
; =============

; Entry
;   r1 = drive number
;   r4 ->drive record
;   r5 ->disc record
;
; Exit
;   V, r0=error possible

; For the given disc adjust the FsSpace to be enough for the FsMap of an
; assumed FileCore disc.

AdjustFsSpace ROUT
        Push    "r0,r2,r3,r7-r10,lr"

        ; Work out the map's size
 [ BigMaps
        LDRB    r9, [r5, #DiscRecord_NZones]
        LDRB    r7, [r5, #DiscRecord_BigMap_NZones2]
        ADD     r9, r9, r7, LSL #8
 |
        LDRB    r9, [r5, #DiscRecord_NZones]
 ]
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]
        MOVS    r8, r9, LSL r7
        MOVEQ   r8, #SzOldFs

 [ DynamicMaps
        LDR     lr, [r4, #DrvsFsMapSize]; get size of the free space map
        TEQS    r8, lr                  ; is space allocated for map right size ?
 |
        ; Get the map space for this drive and test the required
        ; map space against it
        ASSERT  FloppySizes = WinnieSizes+4
        sbaddr  r10, WinnieSizes
        ADD     r10, r10, r1
        LDRB    lr, [r10]

        TEQS    r8, lr, LSL #8          ;is space claimed for map right size ?
 ]

 [ DebugL

        BNE     %FT01
        DLINE   "Stored map size and disc map size match"
        B       %FT02
01
        DLINE   "Stored and disc map map sizes differ"
        DREG    r8, "Disc:", cc
        MOV     r2, lr
        DREG    r2, " and map is:"
02
 ]
        ; Pick up the old map block, and skip replacing it if it's the right size
 [ DynamicMaps
        LDR     r2, [r4, #DrvsFsMapAddr]
 |
        LDR     r2, [r4, #DrvsFsMap]
        BIC     r2, r2, #HiFsBits
 ]
        BEQ     %FT20

        ; Must change stored map for something a different size

 [ DynamicMaps

        ; find the actual allocated size

        Push    "R1, R3-r8"

        MOV     R0, #2
        LDR     R1, [R4, #DrvsFsMapArea]
        BL      OnlyXOS_DynamicArea             ; get the dynamic area size in bytes


        Pull    "R1, R3-R8"

        LDRVS   lr, [r4, #DrvsFsMapFlags]       ; set the 'map memory error' bit
        ORRVS   lr, lr, #MemErrorFs             ;
        STRVSB  lr, [r4, #DrvsFsMapFlags]

        BVS     %FT90
        ; work out the size the area must grow or shrink by

        ADD     r3, r8, r8, LSR #8              ; new size of wotsit

        Push    "R1"

        SUB     R1, R3, R2                      ; amount to change size by
 [ DebugL
        DREG    R1, "Area size to change by: "
 ]
        LDR     R0, [R4, #DrvsFsMapArea]        ; area number
        BL      OnlyXOS_ChangeDynamicArea

 [ DebugL
        BVC     %FT01
        DebugError      "AdjustFsSpace - OS_ChangeDynamicarea error "
01
 ]

        LDR     lr, [r4, #DrvsFsMapFlags]       ; set/clear the 'map memory error' bit
        ORRVS   lr, lr, #MemErrorFs             ;
        BICVC   lr, lr, #MemErrorFs             ;
        STR     lr, [r4, #DrvsFsMapFlags]       ;

        Pull    "R1"

        BVS     %FT90                           ; error!

        ; here, new space allocation is correct, so we're cool

        STR     r8, [R4, #DrvsFsMapSize]                ; store the new size

20
        TEQ     r9, #0
        MOVEQ   lr, #EmptyFs
        MOVNE   lr, #0
        STR     lr, [r4, #DrvsFsMapFlags]               ; store new flags0

 | ; ELSE              (NOT Dynamic maps!)

        ; Cancel storage before freeing it - saves embarasment on Reset
        MOV     lr, #0
        STRB    lr, [r10]


        ; Free the storage
        MOV     r3, #0
        STR     r3, [r4, #DrvsFsMap]    ; Clear out to stop attempt to Free if problems
        TEQ     r2, #0
        MOVNE   r0, #ModHandReason_Free
        BLNE    OnlyXOS_Module  ;return old map buffer
 [ DebugL

        BVC     %FT01
        DLINE   "Discard map free error"
01
 ]
        ; 2 options here, soldier on using a broken heap, or:
        BVS     %FT90

        ; Claim enough for the zones, and one byte per zone
        ; (This assumes sectors size >= 256 bytes)
        ADD     r3, r8, r8, LSR #8      ;size needed
        MOV     r0, #ModHandReason_Claim
 [ DebugL
        DREG    r3, "Claim ",cc
        DREG    r8, " for map of size "
 ]
        BL      OnlyXOS_Module  ;claim workspace
 [ DebugL

        BVC     %FT01
        DLINE   "Map claim failed"
        B       %FT02
01
        DREG    r2, "Map claimed is at "
02
 ]
        BVS     %FT90           ; Bog it, didn't get space for the map!

20
        ; Flag old map as EmptyFs and attach memory to drive record
        TEQ     r9, #0
        ORREQ   r2, r2, #EmptyFs
        STR     r2, [r4, #DrvsFsMap]

        ; Record the map size we've now got, do this late
        ; as we wouldn't want to try using a duff map after Reset
        MOV     lr, r8, LSR #8
        STRB    lr, [r10]

 ] ;ENDIF DynamicMaps

90
        STRVS   r0, [sp]
        Pull    "r0,r2,r3,r7-r10,pc"

; =========
; ReadFsMap
; =========

; Entry
;   r1 = drive number
;   r2 = disc number
;   r4 ->drive record
;   r5 ->disc record
;   r6 = read sectors cache
;
; Exit
;   V, r0=error possible
;   r6 = new read sectors cache

; Read the right sort of FsMap for the disc. Assumes the FsMap is OK if it reads as
; it has already been checked by the identification process. These fields are set if
; necessary:IdLen, Log2bpmb, Skew, BootOpt, ZoneSpare, RootDir. These flags are adjusted:
; OldDirFlag, OldMapFlag, AltMapFlag, EmptyFs.

ReadFsMap ROUT
        Push    "r0-r4,r7,r9,r11,lr"

        ; Adjust DiscFlags in r11
        LDRB    r11, [r5, #DiscFlags]
 [ DebugL
        DREG    r11, "DiscFlags in ReadFsMap are "
 ]

 [ BigMaps
        LDRB    r7, [r5, #DiscRecord_BigMap_NZones2]
        LDRB    r9, [r5, #DiscRecord_NZones]
        ADD     r9, r9, r7, LSL #8
 |
        LDRB    r9, [r5, #DiscRecord_NZones]
 ]
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]

        ; Determine old/new-ness of map by number of zones recorded
        TEQ     r9, #0
        BNE     %FT30

        ; Old map
 [ DebugL

        DLINE   "old map"
 ]

        ; Ensure there's enough space to load an old map
        BL      AdjustFsSpace           ; (R1,R4,R5->R0,V)
 [ DynamicMaps
        LDR     r3, [r4, #DrvsFsMapAddr]
 |
        LDR     r3, [r4, #DrvsFsMap]
        BIC     r3, r3, #HiFsBits
 ]

        ; Read map
        MOV     r4, #SzOldFs
        MOV     r2, r1, ASL #(32-3)
        MOV     r1, #DiscOp_CachedReadSecs
        BL      RetryDriveOp
        BVS     %FT90                   ; Bog it, map didn't read

        ; Restore r1,r2 and r4 (and r3 too, but don't care about that)
        LDMIB   sp, {r1-r4}

 [ DynamicMaps
        ; Map is now in
        LDR     r3, [r4, #DrvsFsMapFlags]
        BIC     r3, r3, #NewHiFsBits
        STR     r3, [r4, #DrvsFsMapFlags]
        LDR     r3, [r4, #DrvsFsMapAddr]
 |
        ; Map is now in
        LDR     r3, [r4, #DrvsFsMap]
        BIC     r3, r3, #HiFsBits
        STR     r3, [r4, #DrvsFsMap]
 ]

        ; Set OldMapFlag, OldDirFlag and AltMapFlag as appropriate:
        ; OldMapFlag set
        ; AltMapFlag clear
        ; OldDirFlag set only if Floppy, 256 bytes sectors and 16 sectors per track
        LDR     lr, [r5, #DiscRecord_DiscType]
 [ BigDisc
        LDR     r0, FileType_FileCoreFloppyDiscStore
        B       %FT01
FileType_FileCoreFloppyDiscStore
        DCD     FileType_FileCoreFloppyDisc

01
 |
        LDR     r0, =FileType_FileCoreFloppyDisc
 ]
        TEQ     lr, r0
        TEQEQ   r7, #8          ; 256 byte sectors
        LDREQB  lr, [r5, #DiscRecord_SecsPerTrk]
        TEQEQ   lr, #16         ; 16 sectors per track
 [ DebugL
        DREG    r11, "Adjusting DiscFlags from "
 ]
        ORREQ   r11, r11, #OldDirFlag
        BICNE   r11, r11, #OldDirFlag
        ORR     r11, r11, #OldMapFlag
        BIC     r11, r11, #AltMapFlag

        ; Set RootDir:
        ; Location &200 (L_Root) on old dir discs, &400 (D_Root) on new dir discs
        MOVEQ   r0, #L_Root
        MOVNE   r0, #D_Root
        ORR     r0, r0, r2, ASL #(32-3)
 [ DebugL
        DREG    r0, "Setting RootDir to (FileCore20, 1394) "
 ]
        STR     r0, [r5, #DiscRecord_Root]

        ; Zap these fields to 0:
        ASSERT  DiscRecord_IdLen :MOD: 4 = 0
        ASSERT  DiscRecord_Log2bpmb=DiscRecord_IdLen+1
        ASSERT  DiscRecord_Skew=DiscRecord_Log2bpmb+1
        ASSERT  DiscRecord_BootOpt=DiscRecord_Skew+1
        ASSERT  DiscRecord_NZones=9
        ASSERT  DiscRecord_ZoneSpare=10
        ; IdLen is critical because it determins the buffer size used for open files
        MOV     r0, #0
        STR     r0, [r5, #DiscRecord_IdLen]
        STRB    r0, [r5, #DiscRecord_ZoneSpare+0]
        STRB    r0, [r5, #DiscRecord_ZoneSpare+2]

        ; Set BootOpt from map
 [ DynamicMaps
        LDR     r0, [r4, #DrvsFsMapAddr]
 |
        LDR     r0, [r4, #DrvsFsMap]
        BIC     r0, r0, #HiFsBits
 ]
        LDRB    r0, [r0, #OldBoot]
        STRB    r0, [r5, #DiscRecord_BootOpt]

        B       %FT80

30
        ; New map
 [ DebugL

        DLINE   "new map"
 ]

 [ ReadMapDuringIdentify ; map is already in dynamic area in this case
        ASSERT  BigDisc
        ASSERT  DynamicMaps
        
        ; Read the flag that tells us which copy of the map was loaded
        LDR     lr, [r4, #DrvsFsMapAddr]
        ADD     lr, lr, r9, LSL r7      ; Zones<<Log2SectorSize
        LDR     lr, [lr]
        TEQ     lr, #0
        BICEQ   r11, r11, #AltMapFlag
        ORRNE   r11, r11, #AltMapFlag
 
 |
        ; Initialise the zone flags in the map to not valid
        MOV     r0, #0
        BL      SetAllZoneFlags

        BL      MapDiscAdd
        BIC     r2, r2, #DiscBits
        ORR     r2, r2, r1, ASL #(32-3)
        MOV     r1, #DiscOp_CachedReadSecs
 [ DynamicMaps
        LDR     r3, [r4, #DrvsFsMapAddr]
 |
        LDR     r3, [r4, #DrvsFsMap]
 ]
        MOV     r4, r9, ASL r7          ; Zones<<Log2SectorSize
        BL      RetryDriveOp

        ; Restore r1,r2 and r4 (and r3 too, but don't care about that)
        LDMIB   sp, {r1-r4}

        BICVC   r11, r11, #AltMapFlag
        BVC     %FT40                   ; 1st Map copy read OK

        BL      MapDiscAdd
 [ BigDisc
        ADD     r2, r2, r9              ; MapDiscAdd + Zones<<DiscRecord_Log2SectorSize
 |
        ADD     r2, r2, r9, ASL r7      ; MapDiscAdd + Zones<<DiscRecord_Log2SectorSize
 ]
        BIC     r2, r2, #DiscBits
        ORR     r2, r2, r1, ASL #(32-3)
        MOV     r1, #DiscOp_CachedReadSecs
 [ DynamicMaps
        LDR     r3, [r4, #DrvsFsMapAddr]
 |
        LDR     r3, [r4, #DrvsFsMap]
 ]
        MOV     r4, r9, ASL r7          ; Zones<<Log2SectorSize
        BL      RetryDriveOp
        BVS     %FT90                   ; 2nd map copy failed to read

        ; Restore r1,r2 and r4 (and r3 too, but don't care about that)
        LDMIB   sp, {r1-r4}

        ORR     r11, r11, #AltMapFlag

40
 ] ; ReadMapDuringIdentify

        ; Common DiscFlag settings on E disc
        BIC     r11, r11, #OldMapFlag :OR: OldDirFlag

        ; Validate the zones in memory
        MOV     r0, #ZoneValid
        BL      SetAllZoneFlags

        ; Copy fields from the disc record in the map to the disc record that gets used:
        ; SecsPerTrk (This overides copy-protection-scheme confused value).
        ; IdLen, Log2bpmb, Skew, BootOpt, ZoneSpare, RootDir
        ; and adjust RootDir to have the disc number in its disc bits
 [ DynamicMaps
        LDR     r0, [r4, #DrvsFsMapAddr]
 |
        LDR     r0, [r4, #DrvsFsMap]
 ]
        ADD     r0, r0, #ZoneHead
        LDRB    lr, [r0, #DiscRecord_SecsPerTrk]
        STRB    lr, [r5, #DiscRecord_SecsPerTrk]
        ASSERT  (DiscRecord_IdLen :MOD: 4) = 0
        ASSERT  DiscRecord_Log2bpmb = DiscRecord_IdLen+1
        ASSERT  DiscRecord_Skew = DiscRecord_Log2bpmb+1
        ASSERT  DiscRecord_BootOpt = DiscRecord_Skew+1
        LDR     lr, [r0, #DiscRecord_IdLen]
        STR     lr, [r5, #DiscRecord_IdLen]
        LDRB    lr, [r0, #DiscRecord_ZoneSpare]
        STRB    lr, [r5, #DiscRecord_ZoneSpare]
        LDRB    lr, [r0, #DiscRecord_ZoneSpare+1]
        STRB    lr, [r5, #DiscRecord_ZoneSpare+1]
        LDR     r0, [r0, #DiscRecord_Root]
        BIC     r0, r0, #DiscBits
        ORR     r0, r0, r2, ASL #(32-3)
 [ DebugL
        DREG    r0, "Setting RootDir to (FileCore20, 1509) "
 ]
        STR     r0, [r5, #DiscRecord_Root]

80
 [ DebugL
        DREG    r11, "DiscFlags set to "
 ]
        STRB    r11, [r5, #DiscFlags]
90
        STRVS   r0, [sp]
        Pull    "r0-r4,r7,r9,r11,pc"

; ===============
; SetAllZoneFlags
; ===============

; Entry
;   r0 = Zone flags to set
;   r4 ->drive record
;   r7 = Log2SectorSize
;   r9 = zones
;
; This sets all the zone flags for a given map to the given value

SetAllZoneFlags ROUT
        Push    "r1,lr"
 [ DynamicMaps
        LDR     r1, [r4, #DrvsFsMapAddr]
 |
        LDR     r1, [r4, #DrvsFsMap]
 ]
        ADD     r1, r1, r9, ASL r7
        MOV     lr, r9
10
        SUBS    lr, lr, #1
        STRPLB  r0, [r1], #1
        BPL     %BT10

        Pull    "r1,pc"

; ======================
; StartupNonFileCoreDisc
; ======================

; Entry
;   r1 = drive number
;   r2 = disc number
;   r4 ->drive record
;   r5 ->disc record
;   r6 = read sectors cache
;
; Exit
;   V possible with r0=error
;   r6 = new read sectors cache
;
; This routine initialises the DiscRec given that the disc is not a FileCore disc
;
; Algorithm:
;   Free any associated map block

StartupNonFileCoreDisc ROUT
        Push    "r0-r3,r8,lr"

 [ DebugL

        DLINE   "Starting up non-filecore disc"
 ]

 [ DynamicMaps

        ; with the maps stored in a dynamic area, we don't delete the dynamic area,
        ; but instead just pretend it's not there

        MOV     R1, #0                  ; set the allocated size to zero,
        STR     R1, [R4, #DrvsFsMapSize]        ; so that if we have problems, we assume no map allocated

        LDR     R1, [R4, #DrvsFsMapArea]
        MOV     R0, #2

        Push    "R3-R8"

        BL      OnlyXOS_DynamicArea     ; get the dynamic area's info (only needs r2, ie the size)

        BVS     %FT80                   ; got the size

        Pull    "R3-R8"

        ; now shrink it back to zero

        MOV     R0, R1                  ; dynamic area number in R0
        RSB     R1, R2, #0              ; shrinking...

        BL      OnlyXOS_ChangeDynamicArea       ; shrink it

        BVS     %FT80                   ; shrink
 |

        ; Free any map area associated with this drive
        ASSERT  FloppySizes = WinnieSizes+4
        sbaddr  r8, WinnieSizes
        ADD     r8, r8, r1
        LDRB    lr, [r8]
        TEQ     lr, #0
        BEQ     %FT20

        ; Cancel the storage size first (for Reset proofing)
        MOV     lr, #0
        STRB    lr, [r8]

        ; Free the storage (clearing FsMap ptr before free to avoid retrying failed free)
        LDR     r2, [r4, #DrvsFsMap]
        MOV     r3, #0
        STR     r3, [r4, #DrvsFsMap]
        BICS    r2, r2, #HiFsBits
        MOVNE   r0, #ModHandReason_Free
        BLNE    OnlyXOS_Module

 ]

        BVS     %FT80

20
        ; Zero out:
        ; IdLen, Log2bpmb, Skew, BootOpt, Zones, ZoneSpare
        MOV     lr, #0
        ASSERT  DiscRecord_IdLen :MOD: 4 = 0
        ASSERT  DiscRecord_Log2bpmb = DiscRecord_IdLen + 1
        ASSERT  DiscRecord_Skew = DiscRecord_Log2bpmb + 1
        ASSERT  DiscRecord_BootOpt = DiscRecord_Skew + 1
        STR     lr, [r5, #DiscRecord_IdLen]
        STRB    lr, [r5, #DiscRecord_NZones]
 [ BigMaps
        STRB    lr, [r5, #DiscRecord_BigMap_NZones2]
 ]
        STRB    lr, [r5, #DiscRecord_ZoneSpare]
        STRB    lr, [r5, #DiscRecord_ZoneSpare+1]

        ; Set up RootDir to be start of disc
        LDR     lr, [sp, #2*4]
        MOV     lr, lr, ASL #(32-3)
 [ DebugL
        Push    "r5"
        MOV     r5, lr
        DREG    r5, "Setting RootDir to (FileCore20, 1653) "
        Pull    "r5"
 ]
        STR     lr, [r5, #DiscRecord_Root]

        ; NewDir to get LexEqv to work porperly (bit7 chars)
        ; OldMap to get IndDiscOps to work
        LDRB    lr, [r5, #DiscFlags]
        BIC     lr, lr, #OldDirFlag
        ORR     lr, lr, #OldMapFlag
        STRB    lr, [r5, #DiscFlags]

80
        STRVS   r0, [sp]
 [ DebugL

        DLINE   "Finished starting up non-filecore disc"
 ]
        Pull    "r0-r3,r8,pc"


; SBP:  for mount, disc address must be in byte form as we don't
;       know the sector size of the disc.

; =====
; Mount
; =====

;entry
; R0 -> controller process block
; R1 drive (internal drive numbering)
; R2 disc address (external drive numbering)
; R3 RAM address
; R4 length
; R5 disc rec to fill in (floppy)
; R6 controller lock bits

;exit
; ok    R0 corrupt
; error R0,V

Mount
 [ DebugL

        DREG    R0, "", cc
        DREG    R1, " ",cc
        DREG    R2, " ",cc
        DREG    R3, " ",cc
        DREG    R4, " ",cc
        DREG    R5, " ",cc
        DREG    R6, " ",cc
        DLINE   ">Mount"
 ]
        Push    "R7,R8,LR"

        ; If LastDiscOpWasFormat fill in the values stored from that in the disc record
        DrvRecPtr r7, r1
        LDRB    r8, [r7, #DrvFlags]
        TST     r8, #LastDiscOpWasFormat
        BEQ     %FT05

        LDRB    r8, [r7, #PrevFormSectorSize]
        STRB    r8, [r5, #DiscRecord_Log2SectorSize]
        LDRB    r8, [r7, #PrevFormSecsPerTrk]
        STRB    r8, [r5, #DiscRecord_SecsPerTrk]
        LDRB    r8, [r7, #PrevFormHeads]
        STRB    r8, [r5, #DiscRecord_Heads]
        LDRB    r8, [r7, #PrevFormDensity]
        STRB    r8, [r5, #DiscRecord_Density]
        LDRB    r8, [r7, #PrevFormLowSector]
        STRB    r8, [r5, #DiscRecord_LowSector]
        LDR     r8, [r7, #PrevFormDiscSize]
        STR     r8, [r5, #DiscRecord_DiscSize]
 [ BigDisc
        LDR     r8, [r7, #PrevFormDiscSize2]
        STR     r8, [r5, #DiscRecord_BigMap_DiscSize2]
 ]
        Pull    "r7,r8,pc"

05
        BL      DriveWriteBehindWait            ;(R1)
        LDR     R7, FS_Flags
        ANDS    R7, R7, R6
 [ DebugI
        BEQ     %FT01

        DLINE   " C2 ",cc
01
 ]
        BLNE    ClaimFiq

        LDRB    R8, Interlocks
        ORR     LR, R8, R6
        STRB    LR, Interlocks
        BL      WaitForControllerFree           ;(R0)

        ; For Pre-MultiFS filing systems assume LowSector is 0
        MOV     r0, #0
        STRB    r0, [r5, #DiscRecord_LowSector]

        ; Mount non-mounting winnies by reading defect list to scratch space.
        ; Need the defect list for heads/sectorsize/secspertrk/density/lowsector/DiscSize
        ; from boot block.
      [ {TRUE} ; Support floppies on filing systems that can only mount via boot block
        LDR     lr, FS_Flags
        TST     r1, #bit2
        TSTEQ   lr, #CreateFlag_FixedDiscsMountLikeFloppy
        BEQ     %FT09
        TST     r1, #bit2
        TSTNE   lr, #CreateFlag_FloppyDiscsMountLikeFixed
        BEQ     %FT10
09
      |
        TST     r1, #bit2
        LDREQ   lr, FS_Flags
        TSTEQ   lr, #CreateFlag_FixedDiscsMountLikeFloppy
        BNE     %FT10
      ]

      [ BigSectors
DefectListDiscAligned * (DefectListDiscAdd:SHR:12):SHL:12 ; Round DLDA down to nearest whole sector
      |
DefectListDiscAligned * (DefectListDiscAdd:SHR:10):SHL:10 ; Round DLDA down to nearest whole sector
      ]
        MOV     r2, #DefectListDiscAligned
        ORR     r2, r2, r1, ASL #(32-3)
        EOR     r2, r2, #bit31
        MOV     r3, #ScratchSpace
        LDR     r4, =DefectListDiscAdd - DefectListDiscAligned + SzDefectList
10

 [ DebugL

        DLINE   ">MiscMount"
 ]
        MOV     R0, #MiscOp_Mount
        BL      Parent_Misc
 [ DebugL

        DLINE   "<MiscMount"
 ]

        BVS     %FT20

        ; For non-mounting winnies verify the defect list and copy/generate fields
        ; as appropriate.
      [ {TRUE} ; Support floppies on filing systems that can only mount via boot block
        LDR     lr, FS_Flags
        TST     r1, #bit2
        TSTEQ   lr, #CreateFlag_FixedDiscsMountLikeFloppy
        BEQ     %FT12
        TST     r1, #bit2
        TSTNE   lr, #CreateFlag_FloppyDiscsMountLikeFixed
        BEQ     %FT20
12
      |
        TST     r1, #bit2
        LDREQ   lr, FS_Flags
        TSTEQ   lr, #CreateFlag_FixedDiscsMountLikeFloppy
        BNE     %FT20
      ]

        Push    "r0,r1"
        MOV     r0, #ScratchSpace
        ADD     r0, r0, #DefectListDiscAdd - DefectListDiscAligned
        MOV     r1, #SzDefectList
        BL      CheckSum
        BVS     %FT15

        ; Pick up heads/sectorsize/secspertrk/density/lowsector/DiscSize from read block
        MOV     r4, #ScratchSpace
        ADD     r4, r4, #DefectListDiscAdd - DefectListDiscAligned
        ADD     r4, r4, #DefectStruc

        ; Density <= DensityOctal
        LDRB    lr, [r4, #DiscRecord_Density]
        CMP     lr, #DensityOctal
        BHI     %FT15
        STRB    lr, [r5, #DiscRecord_Density]

        ; Heads > 0
        LDRB    lr, [r4, #DiscRecord_Heads]
        TEQ     lr, #0
        BEQ     %FT15
        STRB    lr, [r5, #DiscRecord_Heads]

        ; SecsPerTrk > 0
        LDRB    lr, [r4, #DiscRecord_SecsPerTrk]
        TEQ     lr, #0
        BEQ     %FT15
        STRB    lr, [r5, #DiscRecord_SecsPerTrk]

        ; 256 <= SectorSize <= upper limit
        LDRB    lr, [r4, #DiscRecord_Log2SectorSize]
        CMP     lr, #8
        BLO     %FT15
      [ BigSectors
        CMP     lr, #12         ; upper limit 4k
      |
        CMP     lr, #10         ; upper limit 1k
      ]
        BHI     %FT15
        STRB    lr, [r5, #DiscRecord_Log2SectorSize]

        LDRB    lr, [r4, #DiscRecord_LowSector]
        STRB    lr, [r5, #DiscRecord_LowSector]
        LDR     lr, [r4, #DiscRecord_DiscSize]
        STR     lr, [r5, #DiscRecord_DiscSize]
 [ BigDisc
        LDR     lr, [r4, #DiscRecord_BigMap_DiscSize2]
 [ DebugL
        DREG    lr, "Miscmount discsize 2 "
 ]
        STR     lr, [r5, #DiscRecord_BigMap_DiscSize2]
 ]
        B       %FT19

15
        CLRV

        ; Defect list bad - reject it and fill in some values that'll work
 [ {TRUE}
        MOV     lr, #&10000
        ORR     lr, lr, #&100
        ORR     lr, lr, #&09
 |
        LDR     lr, =&0001010a  ; density=0, heads=1, sides=1, sectorsize=1024
 ]
        STR     lr, [r5]
        MOV     lr, #0
        STRB    lr, [r5, #DiscRecord_LowSector]
        MOV     lr, #640*1024   ; 640K disc
        STR     lr, [r5, #DiscRecord_DiscSize]
 [ BigDisc
        MOV     lr, #0
        STR     lr, [r5, #DiscRecord_BigMap_DiscSize2]
 ]

19
        Pull    "r0,r1"

20

        STRB    R8, Interlocks
        TEQS    R7, #0
 [ DebugI

        BEQ     %FT01
        DLINE   " R2 ",cc
01
 ]
        BLNE    ReleaseFiq
 [ DebugL

        BVS     %FT01
        DLINE   "         ",cc
        B       %FT02
01
        DREG    R0, "", cc
02
        DREG    R1, " ",cc
        DREG    R2, " ",cc
        DREG    R3, " ",cc
        DREG    R4, " ",cc
        DREG    R5, " ",cc
        DREG    R6, " ",cc
        DLINE   "<Mount"
 ]
        Pull    "R7,R8,PC"

; ==========
; PollChange
; ==========

; Examine and act on disc changed signal for floppy drive
; CAN ONLY BE CALLED FROM FOREGROUND

; entry R0 = drive
; exit  LR = Drive's Disc

PollChange ROUT
        Push    "R0-R7,LR"
        SavePSR R7
 [ Debug4
        DREG    R0, "Pollchange on "
 ]
        DrvRecPtr  R4,R0
        LDRB    R1, LockedDrive ;MAKE CERTAIN NO MAP RELOADING WHILE ALTERING MAP
        TEQS    R0, R1
        BEQ     %FT90
        MOV     R1, R0
        BL      DriveWriteBehindWait            ;(R1)
        LDRB    R6, Interlocks
 [ {TRUE}
        TST     R0, #bit2
 ]
        ORREQ   LR, R6, #WinnieLock
        ORRNE   LR, R6, #FloppyLock
        STRB    LR, Interlocks                  ;ensure controller claimed
        LDREQ   R0, WinnieProcessBlk
        LDRNE   R0, FloppyProcessBlk

        LDRB    LR, [R0,#Process]
        TSTS    LR, #Inactive           ;If background floppy op
        LDREQB  LR, [R0, #ProcessDrive]
        TEQEQS  LR, R1                  ;     on same disc then assume not changed
        BEQ     %FT85
        BL      WaitForControllerFree   ;(R0) else if on other disc let it finish

        LDR     R2, [R4,#ChangedSeqNum]
        BL      LowPollChange   ;(R1-R2->R1-R3)
        MOV     R0, R1
        LDRB    R1, [R4,#DrvsDisc]
        TSTS    R3, #MiscOp_PollChanged_NotChanged_Flag
        BNE     %FT10

        ; If disc not same as last disc then clear LastDiscOpWasFormat
        TST     R3, #MiscOp_PollChanged_Changed_Flag :OR: MiscOp_PollChanged_Empty_Flag
        LDRNEB  LR, [R4, #DrvFlags]
        BICNE   LR, LR, #LastDiscOpWasFormat
        STRNEB  LR, [R4, #DrvFlags]

 [ DebugL

        BEQ     %FT01
        DLINE   "LastDiscOpWasFormat clear (B)"
01
 ]

        ; Don't mess with NeedNewIdFlag. WhatDisc will set it if needs, which is
        ; when a new, not previously known disc gets inserted and started up. IE
        ; if a disc which has already been seen is inserted then NeedNewId WILL NOT
        ; be set. This is working upon the pricipal that the NewId mechanism is working OK.

        ; If drive might have changed then disc is uncertain
        TSTS    R3, #MiscOp_PollChanged_MaybeChanged_Flag
        ORRNE   R1, R1, #Uncertain

        ; If drive has changed or is empty then unlink the disc from the drive
        TSTS    R3, #MiscOp_PollChanged_Changed_Flag :OR: MiscOp_PollChanged_Empty_Flag
        BLNE    UnlinkByDrive    ;(R0)

        ; If drive empty then return disc Empty
        TSTS    R3, #MiscOp_PollChanged_Empty_Flag
        MOVNE   R1, #Empty

        ; If disc might have changed and drive has changed
        TSTS    R3, #MiscOp_PollChanged_Changed_Flag
        B       %FT20

10
        ; Processing for NotChanged discs:

        ; If the drive's last DiscOp was format and the disc isn't locked
        ; into the drive then the disc is uncertain
        LDRB    LR, [R4, #DrvFlags]
        TSTS    LR, #LastDiscOpWasFormat
        BEQ     %FT15
        LDRB    LR, [R4, #LockCount]
        TEQ     LR, #0
        ORREQ   R1, R1, #Uncertain

15
      [ {TRUE}
        ; Rationale for this change:
        ; * it's impossible to get here unless the FS reported Changed, so there's
        ;   no point in testing for the NotChanged or MaybeChanged cases
        ; * the Unknown flag implies the Uncertain flag, and FileCore already treats
        ;   Unknown:OR:Uncertain drives identically to Full:OR:Uncertain ones
        ; * for the existing drive state to be Empty implies that in an earlier poll
        ;   the FS returned the Empty flag. No existing FS does this without the
        ;   EmptyWorks flag as well, and EmptyWorks is a sticky flag, so it must
        ;   still be set. Logically, this makes sense too. So removing this check
        ;   removes the only place where FileCore examines the EmptyWorks flag,
        ;   simplifying the API.
        TSTS    R1, #Empty
      |
        ; If disc hasn't changed and the drive was unknown or empty and empty works on this drive
        ; and one of notchanged, maybechanged and changed are set
        TSTS    R1, #Unknown :OR: Empty
        TSTNES  R3, #MiscOp_PollChanged_EmptyWorks_Flag
        TSTNES  R3, #MiscOp_PollChanged_NotChanged_Flag :OR: MiscOp_PollChanged_MaybeChanged_Flag :OR: MiscOp_PollChanged_Changed_Flag
      ]
20
        ; then mark the disc as full and uncertain
        MOVNE   R1, #Full :OR: Uncertain
        STRB    R1, [R4,#DrvsDisc]
        STR     R2, [R4,#ChangedSeqNum]

85
        STRB    R6, Interlocks
90
        LDRB    LR, [R4,#DrvsDisc]
        RestPSR R7,,f
        Pull    "R0-R7,PC"

; =============
; LowPollChange
; =============

; entry: R1 = drive (internal numbering)
;        R2 = sequence number

; exit:  V, R0 = error possible
;        R2 = new sequence number
;        R3 = result flags

LowPollChange ROUT
        Push    "r0,lr"

        ; Check the drive number
        TST     r1, #bit2
        LDRNEB  lr, Floppies
        ADDNE   lr, lr, #4
        LDREQB  lr, Winnies
        CMP     r1, lr

        ; If bad drive then fake up empty and changed working and the drive is empty
        MOVHS   r3, #MiscOp_PollChanged_Empty_Flag :OR: MiscOp_PollChanged_EmptyWorks_Flag :OR: MiscOp_PollChanged_ChangedWorks_Flag
        Pull    "r0,pc",HS

        ; Check if the drive is locked - if it is then return Drv_NotChanged
        DrvRecPtr R0, R1
        LDRB    LR, [R0, #LockCount]
        TEQ     LR, #0
        MOVNE   R3, #MiscOp_PollChanged_NotChanged_Flag
        Pull    "R0,PC", NE

        MOV     r0, #MiscOp_PollChanged

        ; If Winnie and it doesn't poll change then frig a suitable value
        ; Else (floppy or winnie which poll changes) do poll change
        TST     r1, #bit2
        ASSERT  :INDEX: FS_Flags :MOD: 4 = 0
        LDREQ   lr, FS_Flags
        TSTEQ   lr, #CreateFlag_FixedDiscPollChangeSupport
        MOVEQ   r3, #MiscOp_PollChanged_NotChanged_Flag :OR: MiscOp_PollChanged_EmptyWorks_Flag :OR: MiscOp_PollChanged_ChangedWorks_Flag
        BLNE    Parent_Misc     ;(R0-R2->R1-R3)

        STRVS   r0, [sp]
        Pull    "r0,pc"

; ===========
; FindDiscRec
; ===========

; entry: R1 = Drive to find rec for
; exit:
; IF error V set, R0 result
; ELSE
;        R1 = drive
;        R2 = free Disc Record number
;        R3 = record ptr

FindDiscRec ROUT
        Push    "R1,R4-R8,LR"

05

 [ Debug4
        DREG    R1, "Find disc rec for drive "
 ]

        ; Winnies are now treated like floppies which don't happen to get removed

        ; Start at the first disc record
        MOV     R4, #0
        MOV     R6, #&100       ;lowest priority so far
;search loop
10
        ; Get to this record
        DiscRecPtr  R5,R4

        ; If in use don't use it
        LDRB    R7, [R5,#DiscUsage]
        TEQS    R7, #0
        BNE     %FT40                   ;dont forget discs in use

        LDRB    lr, LockedDisc
        TEQ     lr, r4
        BEQ     %FT40                   ;dont forget the locked disc

        ; Get the priority: priority += 8 if the disc is in a drive
        LDRB    R7, [R5,#Priority]
        CMPS    R7, #0                  ;0 <=> Unassigned
        LDRNEB  R8, [R5,#DiscsDrv]
        CMPNES  R8, #8
        ADDLO   R7, R7, #8              ;Higher priority for discs in a drive

      [ RO3Paths
;Dont forget discs holding CritBufDir or BufDir
        LDR     R0, CritBufDir
        CMPS    R0, #-1
        BEQ     %FT30
        CMPS    R4, R0, LSR #(32-3)
        BEQ     %FT40            ;holds an important dir
30
        LDR     R0, BufDir
        CMPS    R0, #-1
        BEQ     %FT30
        CMPS    R4, R0, LSR #(32-3)
        BEQ     %FT40            ;holds an important dir
30
      |
;Dont forget discs holding UserRootDir, LibDir, CurDir, BackDir, or Bufdir
        MOV     R8, #:INDEX:UserRootDir
        ASSERT  LibDir=UserRootDir+4
        ASSERT  CurDir=LibDir+4
        ASSERT  BackDir=CurDir+4
        ASSERT  CritBufDir=BackDir+4
        ASSERT  BufDir=CritBufDir+4
20
        LDR     R0, [SB,R8]
        CMPS    R0, #-1
        BEQ     %FT30
        CMPS    R4, R0, LSR #(32-3)
        BEQ     %FT40            ;holds an important dir
30
        ADD     R8, R8, #4
        CMPS    R8, #:INDEX:BufDir
        BLS     %BT20
      ]

        ;dont forget floppies with open files
        MOV     R0, R4
        BL      HasDiscOpenFiles        ;(R0->Z)
        BEQ     %FT40

        ; If lowest priority so far, then note record number, record pointer and its priority
        CMPS    R7, R6
        MOVLS   R2, R4          ; note rec num
        MOVLS   R3, R5          ; note rec ptr
        MOVLS   R6, R7          ; adjust lowest priority
40
        ; Move to next record
        ADD     R4, R4, #1
        TEQS    R4, #8
        BNE     %BT10

; R6 = lowest priority found
;       0 => empty disc rec
; 1 to &F => reclaimable
;    &100 => none available
 [ Debug4
        DREG    R6, "Lowest priority was = ",cc
        DREG    r2, " disc number "
 ]
        MOVS    R6, R6, LSL #(32-8)
        BCS     %FT70           ;all present disc records needed
        BEQ     %FT50

        ; Disc record not empty, so clear it out before using it.
        MOV     R1, R2
        BL      CloseAllByDisc  ;just to discard any FCBs for objects on this disc (closed, but hanging around)
        MOV     R0, R2
        BL      FreeDiscRec

50
        MOV     R0, #0          ;No error
60
        BL      SetVOnR0
 [ Debug4

        DLINE   "Result   Disc     Disc Rec - Leave FindDiscRec"
        DREG    R0,,cc
        DREG    R2," ",cc
        DREG    R3," "
 ]
        Pull    "R1,R4-R8,PC"

70
 [ Debug4

        DLINE   "All record used - attempt to close files"
 ]
        ; All disc records in use.
        ; Try to close any partitions
        MOV     r8, sp

        ; Calculate length needed for a suitable stack frame and grab that
        LDR     r1, FS_Title
        BL      strlen
        ADD     r3, r3, #2+NameLen+1+3  ; 2 for ::, NameLen for disc title, 1 for terminator, 3 for round-up
        BIC     r3, r3, #3
        SUB     sp, sp, r3

        ; Copy FS_Title
        MOV     r2, sp
75
        LDRB    lr, [r1], #1
        CMP     lr, #" "
        STRHIB  lr, [r2], #1
        BHI     %BT75

        ; Copy ::
        MOV     lr, #":"
        STRB    lr, [r2], #1
        STRB    lr, [r2], #1

        ; r3 = number of files closed in this pass
        ; r4 = disc number
        MOV     r3, #0
        MOV     r4, #0

77
        DiscRecPtr r5, r4

        MOV     r1, #NameLen
        MOV     r0, r2
        ADD     r5, r5, #DiscRecord_DiscName

80
        LDRB    lr, [r5], #1
        CMP     lr, #" "                ; SMC: don't want trailing space on disc name
        STRHIB  lr, [r0], #1
        SUBHIS  r1, r1, #1
        BHI     %BT80
        MOV     lr, #0
        STRB    lr, [r0]

        MOV     r5, r2

        ; Do the service call
        MOV     r1, #Service_CloseFile
        MOV     r2, sp
 [ Debug4
        DSTRING r2, "Attempt close "
 ]
        BL      DoXOS_ServiceCall
        BVS     %FT90

        MOV     r2, r5

85
        ; Advance to the next disc
        ADD     r4, r4, #1
        CMP     r4, #7
        BLS     %BT77

90
        ; unwind the stack
        MOV     sp, r8
 [ Debug4
        DREG    r3, "Files closed="
 ]

        ; If nothing was closed give up
        CMP     r3, #0
        MOVEQ   r0, #TooManyDiscsErr
        BEQ     %BT60

        ; If no problem go back for another go
        LDRVC   r1, [sp]
        BVC     %BT05

        B       %BT60

; ===========
; FreeDiscRec
; ===========

; entry: R0 = disc rec num
; exit:  R0 unchanged

FreeDiscRec ROUT
        Push    "R1,LR"

 [ Debug4

 DREG   r0, "FreeDiscRec(",cc
 DLINE  ")"
 ]

      [ RO3Paths
;Invalidate CritBufDir or BufDir if on this disc
        LDR     LR, CritBufDir
        CMPS    R0, LR, LSR #(32-3)
        MOVEQ   LR, #-1
        STREQ   LR, CritBufDir
        
        LDR     LR, BufDir
        CMPS    R0, LR, LSR #(32-3)
        MOVEQ   LR, #-1
        STREQ   LR, BufDir
      |
;Invalidate UserRootDir,LibDir, CurDir, BackDir, or  Bufdir if on this disc
        MOV     R1, #:INDEX:UserRootDir
        ASSERT  LibDir=UserRootDir+4
        ASSERT  CurDir=LibDir+4
        ASSERT  BackDir=CurDir+4
        ASSERT  BufDir=BackDir+8
10
        LDR     LR, [SB,R1]
        CMPS    R0, LR, LSR #(32-3)
        MOVEQ   LR, #-1
        STREQ   LR, [SB,R1]
        ADD     R1, R1, #4
        CMPS    R1, #:INDEX:BufDir
        BLS     %BT10
      ]

        BL      InvalidateFragCache
        BL      UnCacheDisc
        BL      UnlinkByDisc
        BL      UpdatePriority  ;so that when set to 0 below highest is removed
        DiscRecPtr  R1,R0
        MOV     LR,#DefDiscRecEnd       ;unnassigned record defaults
        ASSERT  SzDiscRec :MOD: 4 = 0
        ASSERT  DiscFlags=SzDiscRec-4
        ASSERT  Priority=SzDiscRec-3
        ASSERT  DiscsDrv=SzDiscRec-2
        ASSERT  DiscUsage=SzDiscRec-1
        STR     LR, [R1,#SzDiscRec-4]

        Pull    "R1,PC"

; ==============
; UpdatePriority
; ==============

;decrement priority of higher priority floppy discs by 1 and set priority of
;this floppy disc to (# of other discs in use) + 1

; entry: R0 = disc rec num

UpdatePriority ROUT
        Push    "R1-R5,LR"
        ; Winnies get treated just like floppies - but they don't happen to ever be removed
        MOV     R4, #0
        DiscRecPtr  R1, R0
        LDRB    R2, [R1,#Priority]
        MOV     R3, #1                  ;discs in use ctr
10
        DiscRecPtr  R5,R4               ;Rec ptr
        CMPS    R0, R4                  ;IF not same disc rec
        LDRNEB  LR, [R5,#Priority]
        CMPNES  LR, #0                  ; IF other disc rec in use
        ADDNE   R3, R3, #1              ;  count a disc rec in use
        TEQNES  R2, #0                  ;  IF this disc rec in use
        CMPNES  LR, R2                  ;   IF other disc rec had higher priority
        SUBHI   LR, LR, #1              ;    dec priority of other disc rec
        STRHIB  LR, [R5,#Priority]
        ADD     R4, R4, #1
        CMPS    R4, #8              ; (V cleared)
        BLO     %BT10               ;loop until all disc recs done
        STRB    R3, [R1,#Priority]  ;set priority of this disc rec
90
        Pull    "R1-R5,PC"


; =============
; UnlinkByDrive
; =============

; breaks link between drive & disc

; entry: R0 = drive

UnlinkByDrive ROUT

 [ Debug4

        DREG    R0, "Unlink drive ",cc
        DLINE   " from disc",cc
 ]
        Push    "R1-R2,LR"
        DrvRecPtr  R1,R0
        LDRB    R2, [R1,#DrvsDisc]
        BIC     R2, R2,#Uncertain
        DiscRecPtr  LR,R2

; Entry: R2 Disc/Drive attached to Drive/Disc being unlinked
;        R1-R2,LR pushed
;        R1 DrvRecPtr
;        LR DiscRecPtr
UnlinkCommon
 [ Debug4
        DREG    R2
 ]
        CMPS    R2,#8
        Pull    "R1-R2,PC",HS
  [ Debug4
        DREG    R1,"DrvRec:",cc
        MOV     R2, LR
        DREG    R2," DiscRec:"
  ]
        Push    "R0"

        ; Unlink the disc
        LDRB    R0, [R1, #DrvsDisc]     ;Pick up DrvsDisc to possibly dismount it later
        BIC     R0, R0,#Uncertain       ; Disc may be uncertain
        MOV     R2, #Uncertain :OR: Unknown
        STRB    R2, [R1, #DrvsDisc]     ;drive contents unknown and uncertain
        MOV     R2, #8
        STRB    R2, [LR, #DiscsDrv]     ;disc in unknown drive

 [ DebugL
        DLINE   "************** Setting DiscsDrv to 8 in UnlinkCommon *************"
 ]

        ; If unlinked a Data disc, then dismount it (and ignore any error back)
        LDR     R2, [LR, #DiscRecord_DiscType]
        LDR     LR, =FileType_Data
        TEQ     LR, R2
        MOVEQ   R1, R0
        BLEQ    DismountDisc

        CLRV
        Pull    "R0-R2,PC"


; ============
; UnlinkByDisc
; ============

; breaks link between drive & disc

; entry: R0 = disc

UnlinkByDisc
 [ Debug4

        DREG    R0, "Unlink disc ",cc
        DLINE   " from drive",cc
 ]
        Push    "R1-R2,LR"
        DiscRecPtr  LR,R0
        LDRB    R2,[LR,#DiscsDrv]
        DrvRecPtr  R1,R2
        B       UnlinkCommon

; =========
; LockDrive
; =========

; entry: R1 = drive
;
; Exit: V, R0=error possible

LockDrive ROUT
        Push    "R0,LR"

        ; Filter out non-poll-change winnies
        TST     R1, #bit2
        ASSERT  :INDEX: FS_Flags :MOD: 4 = 0
        LDREQ   lr, FS_Flags
        TSTEQ   lr, #CreateFlag_FixedDiscPollChangeSupport
        BEQ     %F50

        ; Count up the drive lock count
        DrvRecPtr R0, R1
        LDRB    LR, [R0, #LockCount]
        TEQ     LR, #0
        ADD     LR, LR, #1
        STRB    LR, [R0, #LockCount]
        BNE     %F50

        MOV     R0, #MiscOp_LockDrive
        BL      Parent_Misc

50
        STRVS   R0, [SP]
        Pull    "R0,PC"

; ===========
; UnlockDrive
; ===========

; entry: R1 = drive
;
; Exit: V, R0=error possible

UnlockDrive ROUT
        Push    "R0,LR"

        ; Filter out non-poll-change winnies
        TST     R1, #bit2
        ASSERT  :INDEX: FS_Flags :MOD: 4 = 0
        LDREQ   lr, FS_Flags
        TSTEQ   lr, #CreateFlag_FixedDiscPollChangeSupport
        BEQ     %F50

        ; Count down the drive lock count

        DrvRecPtr R0, R1
        LDRB    LR, [R0, #LockCount]
        SUB     LR, LR, #1
        TEQ     LR, #0
        STRB    LR, [R0, #LockCount]
        BNE     %F50

        MOV     R0, #MiscOp_UnlockDrive
        BL      Parent_Misc

50
        STRVS   R0, [SP]
        Pull    "R0,PC"

; ==================
; DiscMustBeFileCore
; ==================

; entry: R3 = top 3 bits disc num

; exit: VC or VS and R0=error

DiscMustBeFileCore ROUT
        Push    "lr"
        BL      DiscAddToRec    ;(R3->LR)
        LDRB    lr, [lr, #DiscFlags]
        TST     lr, #DiscNotFileCore
        MOVNE   r0, #DiscNotFileCoreErr
        BLNE    SetV
        BLEQ    ClearV
        Pull    "pc"

; ==========
; CheckFsMap
; ==========

; Check consistency of free space map

; entry: R3->disc rec, R4->drv rec
; exit:  IF error V set, R0 result

CheckFsMap ROUT

 [ Debug5
        mess    ,"Checking FS map ",NL
 ]
        Push    "R1-R3,R7-R11,LR"
 [ DynamicMaps
        LDR     R0, [R4,#DrvsFsMapAddr]
 |
        LDR     R0, [R4,#DrvsFsMap]
        BIC     R0, R0, #HiFsBits
 ]
        MOV     R9, R0
        MOV     R1, #SzOldFs / 2
        BL      CheckSum        ;(R0,R1->R2,Z)
        ADDEQ   R0, R0, R1
        BLEQ    CheckSum
        BNE     %FT95
                        ;now check space entries are reasonable
        MOV     R10, R9         ;R9-R11 as InitReadOldFs
        LDRB    R11, [R9,#FreeEnd]

        MOV     R3, #0          ;pretend disc 0 to get disc bits clear
        MOV     R0, #0          ;init end of previous space
10
        BL      NextOldFs       ;(R3,R10,R11->R7,R8,R10,R11,Z)
        BEQ     %FT95           ;all spaces checked
        ORR     LR, R7, R8
        CMPS    LR, #DiscBits   ;bad if these bits set
        CMPLOS  R0, R8          ;or end of prev space >= start of this space
        ADDLO   R0, R8, R7
        BLO     %BT10
        MOVS    SP, SP          ;set NE if bad
95

;Z=1 <=> good map
 [ DynamicMaps
        LDRNE   R2, [R4,#DrvsFsMapFlags]
        ORRNE   R2, R2, #BadFs
        STRNE   R2, [R4,#DrvsFsMapFlags]
 |
        LDRNE   R2, [R4,#DrvsFsMap]
        ORRNE   R2, R2, #BadFs
        STRNE   R2, [R4,#DrvsFsMap]
 ]
 [ Debug5
        mess    NE,"BAD MAP",NL
 ]

        MOVEQ   R0, #0
        MOVNE   R0, #BadFsMapErr
        BL      SetVOnR0
        Pull    "R1-R3,R7-R11,PC"


; ========
; CheckSum
; ========

; Check consistency of block under checksum, last byte of block is check byte

; entry: R0=start, R1=block length
; exit:  R0,R1 preserved, R2=checksum, V=0 <=> good

CheckSum ROUT

 [ Debug9
        DLINE    ,"start    length - entering checksum";,NL
        DREG   R0," ",cc
        DREG   R1," ",cc
 ]

        Push    "R1,R3,LR"
        ADDS    LR, R0, R1      ;->end+1      C=0
        SUB     R1, LR, #1      ;->check byte
        MOV     R2, #0
        B        %FT20
10
        LDRB    R3, [R1,#-1] !  ;get next byte
        ADC     R2, R2, R3      ;add into checksum
        MOVS    R2, R2, LSL #24 ;bit 8 = carry
        MOV     R2, R2, LSR #24
20
        TEQS    R0, R1
        BNE     %BT10           ;loop until done
        LDRB    R3, [LR,#-1]

        CMPS    R2, R3          ;check sum = old check byte ?
        BLNE    SetV
 [ Debug9
        DREG    R2,"Checksum="
        BVC     %FT21
        DLINE   "Bad sum"
21
 ]
        Pull    "R1,R3,PC"

        LTORG
        END
@


4.21
log
@  Correct merging errors
Detail:
  A couple of lines of dead code and an unaligned word load that should have
  been a byte load crept into the last commit. This worked fine when
  softloaded with exceptions off but not so well in a ROM...
Admin:
  Now tested in a ROM build.

Retagged as 'FileCore-3_65'
@
text
@d779 1
d782 1
d1803 6
a1808 1
        MOV     r2, #DefectListDiscAdd
d1812 1
a1812 1
        MOV     r4, #SzDefectList
d1848 1
d1855 1
d1876 1
a1876 1
        ; 256 <= SectorSize <= 1024
d1880 5
a1884 1
        CMP     lr, #10
@


4.20
log
@  Fix abort affecting Raspberry Pi B+ and Raspberry Pi 2
Detail:
  These two boards don't have functional card detect lines on their microSD
  slots, so follow a different code path from most other RISC OS platforms.
  There was an issue when you accessed an object (other than the root
  directory) for which it (if it was a directory) or any of its parent
  directories were not in the directory cache, and it is specified by
  reference to disc name rather than drive number, and where the disc is not
  currently in a drive (or it's in a drive but hasn't been mounted since it
  was inserted). The additional PollChange inserted by DiscOp with a
  specified boot block (as used to identify the disc format when scanning
  drives to see if the disc in each drive has changed) which was intended to
  support some ADFS floppy drives had the side-effect with SDFS-type
  card-detect-less change detection (which has to wait until at least one
  DiscOp has been issued before it can tell if the card has changed) that
  FileCore's disc and drive records became unlinked part-way through the
  FullLookup routine. In later subroutines, this meant we ended up
  misidentifying the controller to which the disc was attached, and because
  SDFS didn't (until recently) have any hard discs, the hard disc controller
  was uninitialised, resulting in a data abort. This is fixed by making
  WhatDisc check for whether the disc record it's about to return has been
  delinked from the drive record, and repeat the process if so. Also removed
  some dead code (an alternate entry to WhatDiscCommon) while I was at it.
Admin:
  Tested on Raspberry Pi B+ and 2.

Version 3.65. Tagged as 'FileCore-3_65'
@
text
@d132 1
a132 1
        LDR     r0, [r3, #DiscsDrv]
a139 3
        STRVS   r0, [sp]
        Pull    "r0,r4,r5,r6,pc"

@


4.19
log
@  Support the Raspberry Pi model B+
Detail:
  There's some questionable code in DoSwi[Sector]DiscOp[64] where it calls
  PollChange in an apparent attempt to support the ADFS floppy state machine.
  In the no-card-detect SDFS case, we can detect from a card's state whether
  it has been changed or not; to be able to signal this to software that
  cares about such things, we increment the sequence number late in the
  process. The downside is that when the card *has* changed, two consecutive
  PollChanged calls will differ from the steady state: the first because
  MaybeChanged is signalled, the second because the sequence number
  mismatches. DetermineDiscType didn't handle this gracefully, ending up
  pointing off the internal array of disc records, resulting in a string of
  gibberish when canonicalising a drive-based file spec. Fixed by having
  DetermineDiscType double-check that the drive is not empty.

  Fixed UpCall_MediaNotPresent and UpCall_MediaNotKnown to actually use the
  media type string from MiscOp 4. For example, you'll now see "Please insert
  card 'RISCOSpi'" being generated by the Wimp under SDFS.

  Improved documentation of MiscOps 4 and 5.

Admin:
  Already in use in RC12a.

Version 3.64. Tagged as 'FileCore-3_64'
@
text
@d51 1
a51 8
        Push    "r0,r4,r5,r6,r10,lr"
        MOV     r10, #1
        B       WhatDiscCommon

WhatDiscType
        Push    "r0,r4,r5,r6,r10,lr"
        MOV     r10, #0
        ; Drop through to WhatDiscCommon
a52 1
WhatDiscCommon
d55 1
a55 2
        DREG    R1, "<WhatDiscCommon(Drv=",cc
        DREG    R10, ",Opt=",cc
d61 1
a61 1

d82 1
a82 2
        TEQ     r10, #0
        BLNE    DetermineDiscType               ; (r1,r2,r4,r5,r6->V+r0,r2,r5,r6)
d101 2
a102 3
        TEQ     r10, #0
        LDRNE   lr, [r3, #DiscFlags]
        TSTNE   lr, #DiscNotIdentified
d126 14
d141 1
a141 1
        Pull    "r0,r4,r5,r6,r10,pc"
@


4.18
log
@Add support for 2k and 4k sector sizes
s/Commands:
Make sure the defect list (via *DEFECT) does a read/modify/write of the boot block on 2k and 4k drives.
The checksum generation code was largely common and although commented to be called as though it was common wasn't actually due to a cut and paste mistake on label 37. Deleted common/uncalled code.
s/DebugOpts; s/FileCore15:
Peripheral changes.
s/FileCore20:
Read in the defect list via an intermediate buffer then copy out into the dynamic area.
s/FileCore70:
Declare the buffer size as 4k to FileSwitch, internally FileCore expresses this in a single byte * 32 so is now at the limit of the range of FcbBufSz.
s/FileCore80:
Perform transfers in the foreground when the sector size exceeds FileCore's 1k buffers. It's not worth bothering.
s/FormSWIs; s/Identify:
Vet and reject attempts to layout invalid zone/sector size combos (see Doc/1Zone).
Doc/MiscOp:
Correct a couple of calculation mistakes.
Doc/1Zone:
New documentation detailing the possible valid combinations of a 1 zone fixed disc, and why for 2k and 4k sectors this is rejected.
Test/BigSectors:
Patch to apply to RAMFS to make it a 4k filing system. Note, the smallest 2 zone RAM disc with 4k sectors is 4052kB, in which case the map is at +3F0000; copy at +3F2000; root directory object at +3F4000.

Version 3.63. Tagged as 'FileCore-3_63'
@
text
@d542 1
d545 7
a551 3
        LDRVCB  r1, [r4, #DrvsDisc]
        BICVC   r1, r1, #Uncertain
        STRVCB  r1, [r4, #DrvsDisc]
a554 1
        BVS     %FT90
@


4.17
log
@Minor tidy ups
Service call table made unconditional.
Typo in Hdr:FileCore corrected.
Comments improved, and other misc housekeeping.

Version 3.62. Tagged as 'FileCore-3_62'
@
text
@d428 1
a428 1
        DREG    r0, "DiscFlags picked up to be "
d962 1
d967 13
a979 2
        MOV     r4, #SzDefectList
        MOV     r2, r1, ASL #(32-3)
d983 1
a983 1
        LDRB    r11, [r5, #DiscRecord_Log2SectorSize]           ; get sector size
d985 1
a985 1
        ORR     r2,r2,r10,LSR r11
d993 1
d1009 16
d1035 1
a1035 1
        ; If zones <> 0, then copy ZoneSpare and BitSize too for E format
d1056 1
a1056 2
 [ BigDisc
        ; It's a FileCore floppy disc, read byte 2 to test bit 7 of it
d1063 1
a1063 1
        LDRB    r0, [sp,#2]
a1064 12
 |
        ; It's a FileCore floppy disc, read byte 2 to test bit 7 of it
        SUB     sp, sp, #4
        MOV     r3, sp                  ; read to the stack
        MOV     r4, #1                  ; 1 byte to read
        MOV     r2, r1, ASL #(32-3)
        ADD     r2, r2, #2              ; byte 2
        MOV     r1, #DiscOp_CachedReadSecs
        BL      RetryDriveOp
        LDRB    r0, [sp]
        ADD     sp, sp, #4
 ]
d1069 1
a1069 1
        BVS     %FT30                   ; Byte 2 didn't read, but it is a floppy, hence it must be an E floppy
d1071 1
a1071 2
        ; Might be E format
        TST     r0, #bit7
d1317 1
a1317 1
        DREG    r11, "DiscFlags picked up to be "
@


4.16
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@d269 1
a269 1
        ASSERT  DiscId :MOD: 4 = 0
d276 1
a276 1
        LDR     r0, [r5, #DiscSize]
@


4.15
log
@Comment clarifications and tidy up
Lots of missing function entry/exit register comments added/corrected.
Drive number extraction all now (32-3) to help see where changes are needed in future for more drives.
Removed redundant Tools/basic/BASH (see Test/BASH).
InitDieSvc/BigDirCode/DebugOpts/FileCore25: Comments
FileCore05: Use of DREG with no preceding text
FileCore15: Use of 'mess' with too few arguments
FileCore20: Fetching of NZones made consistent, 3 bit drive number made consistent
FileCore30/FileCore32: Simplify debug switches, driver number extraction, comments
FileCore31: Fetching of NZones made consistent
FileCore40/FileCore33/FileCore35: NZones, function arguments commented
FileCore45: Function arguments commented, debug reinstated
FileCore70/FileCore60: Function arguments commented, drive number extraction
FormSWIs: NZones
Identify/GenSWIs: Drive number extraction, debug tidy
MyMacros: Unused Align16 removed. Hacked DebugError macro to not try loading from internal error numbers all the time, which are often not aligned, or not in sensible memory places

Relatively few code changes, no expected issues.


Version 3.55. Tagged as 'FileCore-3_55'
@
text
@d2560 1
a2560 3
        SavePSR lr
        Push    "lr"
        BL      DiscAddToRec
d2565 2
a2566 2
        Pull    lr ; actually the CPSR for PullLinkKeepV
        B       PullLinkKeepV
@


4.14
log
@Fix abort mounting old map discs
The massive speedup in FileCore 3.50 by not loading the map sector wise (twice) on mounting meant that the code path to resize the dynamic area for the map had changed.
So, with DynamicMaps = {TRUE} mounting an old map disc would try to load the map into a zero size area (the area had an allocated address but was 0 bytes long).
Aside: reading a new map disc first, then swapping to an old map disc would mask the problem since the dynamic area is only shrunk on an active dismount.


Version 3.53. Tagged as 'FileCore-3_53'
@
text
@a157 1

d786 1
a786 1
        MOV     lr, r2, ASL #32-3
d1113 1
a1114 1
 [ BigMaps
d1117 2
a1308 2
        ; Determine old/new-ness of map by number of zones recorded
        LDRB    r7, [r5, #DiscRecord_Log2SectorSize]
d1310 2
a1311 1
        ; Keep DiscRecord_Log2SectorSize in r7
a1314 2
        LDRB    r9, [r5, #DiscRecord_NZones]
 ]
d1387 1
a1387 1
        ORR     r0, r0, r2, ASL #32-3
d1444 1
a1444 1
        ORR     r2, r2, r1, ASL #32-3
d1467 1
a1467 1
        ORR     r2, r2, r1, ASL #32-3
d1517 1
a1517 1
        ORR     r0, r0, r2, ASL #32-3
d1659 1
a1659 1
        MOV     lr, lr, ASL #32-3
d1783 1
a1783 1
        ORR     r2, r2, r1, ASL #32-3
d2216 1
a2216 1
        DREG    R0,"",cc
@


4.13
log
@  Miscellaneous improvements
Detail:
  * Added the ability for a filing system to specify to FileCore that floppy
    discs should be mounted like hard discs, to complement the existing flag
    that specifies the opposite. SDFS requires this. Ideally SCSIFS should
    start using this as well, to encapsulate boot block handling within
    FileCore.
  * Added header definitions so the FileCore and the filing systems can
    negotiate the use of a new MiscOp entry, needed as part of partitioning
    support, especially important for filing systems that use the hardware-
    specific section of the boot block, like ADFS. At present, FileCore
    doesn't do anything different (it still doesn't support partitions) but
    this enables filing systems to be modified in preparation.
  * Removed the only place where FileCore paid any attention to the
    EmptyWorks flag returned by MiscOp 1 - an obscure and not very useful
    edge case not used by any current filing systems.
  * Added 650 lines of documentation for the MiscOp SWI and low-level entry
    to the Doc directory, giving the information you need in order to
    implement a FileCore filing system.
  * Added missing header file definitions for the low-level background DiscOp
    reason code and the hot-plug drive removed flag to MiscOp 7.
  * Removed some RISC OS 2 legacy code whereby FileCore maintained its idea
    of the internal disc address of the CSD @@, PSD \, Library % and URD & for
    each filing system. Since RISC OS 3.00, FileSwitch handles these
    internally and passes canonicalised paths to FileCore, so FileCore's disc
    addresses for these directories remained unset. This allows some
    considerable simplification of FileCore's path parser in particular, but
    also affects other code like that which decides how to expire disc
    records. Also note that FileCore has been unable to generate certain
    errors (like "Can't delete current directory") since RISC OS 3.00 for the
    same reason.
  * Changed loading of the map for FileCore-format discs so that the map is
    loaded into the dynamic area during the Service_IdentifyDisc handler in
    one big DiscOp rather than loading it twice, sector-by-sector, via one
    big sector cache. For one thing, the sector cache is implemented
    inefficiently - O(n^2) - and for another thing, single-sector DiscOps are
    relatively inefficient on many filing systems, especially on SD cards.
    Some example speed-ups measured for mounting discs are:
      SCSIFS,   1GB drive: was 0.62 sec, now 0.40 sec (1.55 x speedup)
      SCSIFS, 256GB drive: was 1.44 sec, now 0.52 sec (2.77 x speedup)
      SDFS,     2GB drive: was 1.25 sec, now 0.14 sec (8.93 x speedup)
Admin:
  Tested on a beagleboard, with SCSIFS and SDFS.

Version 3.50. Tagged as 'FileCore-3_50'
@
text
@d1326 2
a1327 1
        ; Read map
d1334 2
@


4.12
log
@Fix asasm 2.00 errors
Detail:
  s/BigDirCode, s/FileCore20, s/FileCore33 - Fixed some operators which were missing their end colon
Admin:
  Identical binary under objasm


Version 3.49. Retagged as 'FileCore-3_49'
@
text
@d900 1
d906 1
d1424 13
d1483 2
d1765 10
d1779 1
d1803 10
d1817 1
d2014 14
d2033 1
d2140 15
d2172 1
d2324 12
d2350 1
@


4.11
log
@Teach FileCore_LayoutStructure and Service_IdentifyDisc how to do 1 zone fixed discs.
From the change logs it was last fixed sometime around FileCore 2.50 era, but has been long broken.
The boot block was in the right place, but was overwritten by the root directory, and the wrong size entry was claimed in the map, amongst other errors.
Free'd up R6 in LayoutFreeSpaceMap to avoid having to keep reevaluating the number of zones - makes it a bit more readable. Corrected inaccurate comments. Checked the code paths for new map with and without boot block, with and without long filenames.
Test app 'Make1Zone' generates a small disc image which can be inspected in a hex editor for correctness.
In the identify code, be more strict about looking for a boot block only on fixed discs since they cannot occur on floppies (saves time, wasn't necessarily wrong).
The concept of a boot block at &C00 only works when 2 copies of the map can be fitted underneath that address, for future 2k and 4k sector sizes these do not fit and it is likely that 1 zone fixed discs are forbidden (a drive with 4k sectors would typically be > 512GB and 1 zone would be ~32MB so spilling into a second zone would waste < 0.01%).
Other minor changes:
* Free command now groups the 'K' with 'bytes' to match OS_ConvertFileSize.
* FileCore20 debug didn't assemble.
* FileCore33 beefed up comments.
* GenSWIs debug didn't assemble.
Tested with a special cut of RAMFS manually loading various 1 zone images into its dynamic area and checking they mount, have a sensible *MAP and *FREE result, can be written to, and don't have broken directories.

Version 3.46. Tagged as 'FileCore-3_46'
@
text
@d338 1
a338 1
        ASSERT  (DiscRecord_Log2SectorSize :MOD 4) = 0
@


4.10
log
@Revise exports in "hdr.FileCore".
Now, for each SWI call there is a definition of any pertinent structures it asks for and definitions of any bitfields within those flags. This avoids the need for clients to endlessly redefine these locally (in practice it looks like sections of FileCore were simply copy and pasted into clients RAMFS/SCSIFS/ADFS). Delete private definitions.
This binary was carefully checked to be identical since so many locations were changed.
Then, the following additional changes:
* InitDieSvc line 74, the floppy config is extracted using a mask and shift rather than reaching up the stack
* Identify lin 1254, the superfluous instruction marked as such deleted
* FileCore15 line 762 recoded the check for background op to not need the bit number defined any more
* FileCore00 moved the label 'anull' to be word aligned guaranteed
The duff pointer marker ('nowt' = &40000000) is no longer used to mark territory translation tables as invalid as that address is now quite reasonable. -1 is used instead.

Version 3.45. Tagged as 'FileCore-3_45'
@
text
@d128 1
a128 1
        LDR     lr, [r3, #RootDir]
@


4.9
log
@Fix bug in DetermineDiscType.
When failed to identify, and the last operation was format, the DiscSize2 field was not being copied (instead DiscSize is copied twice).
Fix up some warnings from the assembler.
Tested briefly with a RAM disc, still works.

Version 3.44. Tagged as 'FileCore-3_44'
@
text
@d128 2
a129 2
	LDR	lr, [r3, #RootDir]
	DREG	lr, "RootDir on Exit WhatDisc is: "
d217 1
a217 1
        STR     r0, [r5, #DiscType]
d233 1
a233 1
        STRNEB  lr, [r5, #SectorSize]
d235 1
a235 1
        STRNEB  lr, [r5, #SecsPerTrk]
d237 1
a237 1
        STRNEB  lr, [r5, #Heads]
d239 1
a239 1
        STRNEB  lr, [r5, #Density]
d241 1
a241 1
        STRNEB  lr, [r5, #LowSector]
d243 1
a243 1
        STRNE   lr, [r5, #DiscSize]
d246 1
a246 1
        STRNE   lr, [r5, #DiscSize2]
d250 1
a250 1
	DLINE	"Blanking out disc name"
d255 6
a260 6
        ASSERT  ?DiscName = 10
        ASSERT  :INDEX: DiscName :MOD: 4 = 2
        STRB    lr, [r5, #DiscName]
        STRB    lr, [r5, #DiscName+1]
        STR     lr, [r5, #DiscName+2]
        STR     lr, [r5, #DiscName+6]
d268 1
a268 1
        LDR     r0, [r5, #DiscType]
d271 1
a271 1
        LDR     r0, [r5, #DiscId]
d275 1
a275 1
        ADD     r0, r5, #DiscName
d285 1
a285 1
        LDR     r0, [r5, #DiscId]
d323 2
a324 2
        ; Type
        ; SectorSize
d331 1
a331 1
	; DiscSize2
d334 3
a336 3
        ; Name
        LDR     r0, [r3, #DiscType]
        LDR     lr, [r5, #DiscType]
d338 6
a343 6
        ASSERT  (SectorSize :MOD 4) = 0
        ASSERT  SecsPerTrk = SectorSize+1
        ASSERT  Heads = SecsPerTrk+1
        ASSERT  Density = Heads+1
        LDREQB  r0, [r3, #SectorSize]
        LDREQB  lr, [r5, #SectorSize]
d345 2
a346 2
        LDREQB  r0, [r3, #LowSector]
        LDREQB  lr, [r5, #LowSector]
d349 2
a350 2
        LDREQ   r0, [r3, #DiscSize]
        LDREQ   lr, [r5, #DiscSize]
d353 2
a354 2
        LDREQ   r0, [r3, #DiscSize2]
        LDREQ   lr, [r5, #DiscSize2]
d357 3
a359 3
        ASSERT  (DiscId :MOD: 4) = 0
        LDREQ   r0, [r3, #DiscId]
        LDREQ   lr, [r5, #DiscId]
d371 3
a373 3
        MOV     r11, #?DiscName
        ADD     r3, r3, #DiscName + ?DiscName
        ADD     r5, r5, #DiscName + ?DiscName
d394 2
a395 2
        SUB     r3, r3, #DiscName + ?DiscName
        SUB     r5, r5, #DiscName + ?DiscName
d475 2
a476 2
	DREG	r1, "************************ DiscsDrv set to ",cc
	DLINE	" in DetermineDiscType *****************************"
d494 1
a494 1
        ADD     r2, r5, #DiscName
d519 1
a519 1
        LDR     r0, [r5, #DiscType]
d542 1
a542 1
        STRVS   r1, [r5, #DiscType]
d552 1
a552 1
        LDR     r1, [r5, #DiscType]
d582 1
a582 1
	DREG	R5, "Disc rec ptr now: "
d608 1
a608 1
        ADD     r3, r3, #?DiscName + 2 + 1 + 3  ; <FS>::<DiscName>
d626 1
a626 1
        MOV     r1, #?DiscName
d712 1
a712 1
        LDRB    r8, [lr, #Density]      ; Density of disc last in this drive
d720 1
a720 1
        LDREQB  r0, [lr, #Zones]
d723 2
a724 2
	LDREQB	r0, [lr, #Zones2]
	TEQEQ	r0, #0
d757 1
a757 1
        ; LinkBits, BitSize, RAskew, BootOpt, Zones, ZoneSpare, DiscId, DiscName
d759 5
a763 5
        ASSERT  LinkBits :MOD: 4 = 0
        ASSERT  BitSize = LinkBits + 1
        ASSERT  RAskew = BitSize + 1
        ASSERT  BootOpt = RAskew + 1
        STR     lr, [r5, #LinkBits]
d765 1
a765 1
        STRB    lr, [r5, #Zones]
d767 1
a767 1
        STRB	lr, [r5, #Zones2]
d769 2
a770 2
        STRB    lr, [r5, #ZoneSpare]
        STRB    lr, [r5, #ZoneSpare+1]
d772 3
a774 3
        ASSERT  DiscId :MOD: 4 = 0
        ASSERT  DiscName = DiscId + 2
        STR     lr, [r5, #DiscId]
d776 1
a776 1
	STR	lr, [r5,#DiscSize2]
d778 1
a778 1
        STR     lr, [r5,#ShareSize]
d788 1
a788 1
        STR     lr, [r5, #RootDir]
d791 1
a791 1
        STRB    r8, [r5, #Density]
d817 1
a817 1
        LDR     r0, [r5, #SectorSize]
d829 1
a829 1
        STR     r0, [r5, #DiscType]
d835 2
a836 2
	DREG	r1, "************************* DiscsDrv set to",cc
	DLINE   " in MountDiscOnDrive *************************"
d840 4
a843 4
        ASSERT  DiscName = DiscId+2
        STR     r0, [r5, #DiscId]
        STR     r0, [r5, #DiscName+2]
        STR     r0, [r5, #DiscName+6]
d846 4
a849 4
	LDR	lr, [r5, #RootDir]
	BIC	lr, lr, #DiscBits
	ORR	lr, lr, r2, LSL #(32-3)
	STR	lr, [r5, #RootDir]
d951 1
a951 1
        LDR     r0, [r5, #DiscType]
d967 1
a967 1
        MOV     r1, #CachedReadSecsOp
d969 5
a973 5
	Push	"R10,R11"
	LDRB	r11, [r5, #SectorSize]		; get sector size
	MOV	r10,#DefectListDiscAdd
	ORR	r2,r2,r10,LSR r11
	Pull	"R10,R11"
d998 2
a999 2
        LDRB    r0, [r3, #Zones]
        STRB    r0, [r5, #Zones]
d1001 2
a1002 2
	LDRB	r0, [r3, #Zones2]
	STRB	r0, [r5, #Zones2]
d1007 6
a1012 6
        LDRNEB  r0, [r3, #ZoneSpare]
        STRNEB  r0, [r5, #ZoneSpare]
        LDRNEB  r0, [r3, #ZoneSpare+1]
        STRNEB  r0, [r5, #ZoneSpare+1]
        LDRNEB  r0, [r3, #BitSize]
        STRNEB  r0, [r5, #BitSize]
d1032 1
a1032 1
        MOV     r1, #CachedReadSecsOp
d1043 1
a1043 1
        MOV     r1, #CachedReadSecsOp
d1060 1
a1060 1
        STRB    r0, [r5, #Zones]
d1062 1
a1062 1
 	STRB	r0, [r5, #Zones2]
d1071 1
a1071 1
        STRB    r0, [r5, #Zones]
d1074 1
a1074 1
        STRB	r0, [r5, #Zones2]
d1076 3
a1078 3
        STRB    r0, [r5, #ZoneSpare]
        STRB    r0, [r5, #ZoneSpare+1]
        STRB    r0, [r5, #BitSize]
d1112 1
a1112 1
        LDRB    r9, [r5, #Zones]
d1114 2
a1115 2
 	LDRB	r7, [r5, #Zones2]
 	ADD	r9, r9, r7, LSL #8
d1117 1
a1117 1
        LDRB    r7, [r5, #SectorSize]
d1122 2
a1123 2
 	LDR	lr, [r4, #DrvsFsMapSize]; get size of the free space map
 	TEQS	r8, lr			; is space allocated for map right size ?
d1160 1
a1160 1
 	; find the actual allocated size
d1162 1
a1162 1
 	Push	"R1, R3-r8"
d1164 3
a1166 3
 	MOV	R0, #2
 	LDR	R1, [R4, #DrvsFsMapArea]
 	BL	OnlyXOS_DynamicArea		; get the dynamic area size in bytes
d1169 1
a1169 1
 	Pull	"R1, R3-R8"
d1171 3
a1173 3
	LDRVS	lr, [r4, #DrvsFsMapFlags]	; set the 'map memory error' bit
	ORRVS	lr, lr, #MemErrorFs		;
	STRVSB	lr, [r4, #DrvsFsMapFlags]
d1175 2
a1176 2
 	BVS	%FT90
 	; work out the size the area must grow or shrink by
d1178 1
a1178 1
 	ADD	r3, r8, r8, LSR #8		; new size of wotsit
d1180 1
a1180 1
 	Push	"R1"
d1182 1
a1182 1
 	SUB	R1, R3, R2			; amount to change size by
d1184 1
a1184 1
	DREG	R1, "Area size to change by: "
d1186 2
a1187 2
 	LDR	R0, [R4, #DrvsFsMapArea]	; area number
 	BL	OnlyXOS_ChangeDynamicArea
d1190 2
a1191 2
	BVC	%FT01
	DebugError	"AdjustFsSpace - OS_ChangeDynamicarea error "
d1195 4
a1198 4
	LDR	lr, [r4, #DrvsFsMapFlags]	; set/clear the 'map memory error' bit
	ORRVS	lr, lr, #MemErrorFs		;
	BICVC	lr, lr, #MemErrorFs		;
	STR	lr, [r4, #DrvsFsMapFlags]	;
d1200 1
a1200 1
 	Pull	"R1"
d1202 1
a1202 1
 	BVS	%FT90				; error!
d1204 1
a1204 1
 	; here, new space allocation is correct, so we're cool
d1206 1
a1206 1
 	STR	r8, [R4, #DrvsFsMapSize]		; store the new size
d1209 4
a1212 4
 	TEQ	r9, #0
 	MOVEQ	lr, #EmptyFs
 	MOVNE	lr, #0
 	STR	lr, [r4, #DrvsFsMapFlags]		; store new flags0
d1290 1
a1290 1
; necessary:LinkBits, BitSize, RASkew, BootOpt, ZoneSpare, RootDir. These flags are adjusted:
d1303 5
a1307 5
	LDRB	r7, [r5, #Zones2]
	LDRB	r9, [r5, #Zones]
	ADD	r9, r9, r7, LSL #8
	; Determine old/new-ness of map by number of zones recorded
	LDRB	r7, [r5, #SectorSize]
d1309 2
a1310 2
        ; Keep SectorSize in r7
        LDRB    r7, [r5, #SectorSize]
d1313 1
a1313 1
        LDRB    r9, [r5, #Zones]
d1333 1
a1333 1
        MOV     r1, #CachedReadSecsOp
d1345 1
a1345 1
        LDR	r3, [r4, #DrvsFsMapAddr]
d1357 1
a1357 1
        LDR     lr, [r5, #DiscType]
d1360 1
a1360 1
	B	%FT01
d1362 1
a1362 1
	DCD	FileType_FileCoreFloppyDisc
d1370 1
a1370 1
        LDREQB  lr, [r5, #SecsPerTrk]
d1388 1
a1388 1
        STR     r0, [r5, #RootDir]
d1391 7
a1397 7
        ASSERT  LinkBits :MOD: 4 = 0
        ASSERT  BitSize=LinkBits+1
        ASSERT  RAskew=BitSize+1
        ASSERT  BootOpt=RAskew+1
        ASSERT  Zones=9
        ASSERT  ZoneSpare=10
        ; LinkBits is critical because it determins the buffer size used for open files
d1399 3
a1401 3
        STR     r0, [r5, #LinkBits]
        STRB    r0, [r5, #ZoneSpare+0]
        STRB    r0, [r5, #ZoneSpare+2]
d1411 1
a1411 1
        STRB    r0, [r5, #BootOpt]
d1429 1
a1429 1
        MOV     r1, #CachedReadSecsOp
d1435 1
a1435 1
        MOV     r4, r9, ASL r7          ; Zones<<SectorSize
d1446 1
a1446 1
        ADD     r2, r2, r9		; MapDiscAdd + Zones<<SectorSize
d1448 1
a1448 1
        ADD     r2, r2, r9, ASL r7	; MapDiscAdd + Zones<<SectorSize
d1452 1
a1452 1
        MOV     r1, #CachedReadSecsOp
d1458 1
a1458 1
        MOV     r4, r9, ASL r7          ; Zones<<SectorSize
d1477 1
a1477 1
        ; LinkBits, BitSize, RASkew, BootOpt, ZoneSpare, RootDir
d1485 13
a1497 13
        LDRB    lr, [r0, #SecsPerTrk]
        STRB    lr, [r5, #SecsPerTrk]
        ASSERT  (LinkBits :MOD: 4) = 0
        ASSERT  BitSize = LinkBits+1
        ASSERT  RAskew = BitSize+1
        ASSERT  BootOpt = RAskew+1
        LDR     lr, [r0, #LinkBits]
        STR     lr, [r5, #LinkBits]
        LDRB    lr, [r0, #ZoneSpare]
        STRB    lr, [r5, #ZoneSpare]
        LDRB    lr, [r0, #ZoneSpare+1]
        STRB    lr, [r5, #ZoneSpare+1]
        LDR     r0, [r0, #RootDir]
d1503 1
a1503 1
        STR     r0, [r5, #RootDir]
d1521 1
a1521 1
;   r7 = SectorSize
d1572 2
a1573 2
 	; with the maps stored in a dynamic area, we don't delete the dynamic area,
 	; but instead just pretend it's not there
d1575 2
a1576 2
 	MOV	R1, #0			; set the allocated size to zero,
 	STR	R1, [R4, #DrvsFsMapSize]	; so that if we have problems, we assume no map allocated
d1578 2
a1579 2
 	LDR	R1, [R4, #DrvsFsMapArea]
 	MOV	R0, #2
d1581 1
a1581 1
 	Push	"R3-R8"
d1583 1
a1583 1
 	BL	OnlyXOS_DynamicArea	; get the dynamic area's info (only needs r2, ie the size)
d1585 1
a1585 1
 	BVS	%FT80			; got the size
d1587 1
a1587 1
 	Pull	"R3-R8"
d1589 1
a1589 1
 	; now shrink it back to zero
d1591 2
a1592 2
 	MOV	R0, R1			; dynamic area number in R0
 	RSB	R1, R2, #0		; shrinking...
d1594 1
a1594 1
 	BL	OnlyXOS_ChangeDynamicArea	; shrink it
d1596 1
a1596 1
 	BVS	%FT80			; shrink
d1625 1
a1625 1
        ; LinkBits, BitSize, RAskew, BootOpt, Zones, ZoneSpare
d1627 6
a1632 6
        ASSERT  LinkBits :MOD: 4 = 0
        ASSERT  BitSize = LinkBits + 1
        ASSERT  RAskew = BitSize + 1
        ASSERT  BootOpt = RAskew + 1
        STR     lr, [r5, #LinkBits]
        STRB    lr, [r5, #Zones]
d1634 1
a1634 1
 	STRB	lr, [r5, #Zones2]
d1636 2
a1637 2
        STRB    lr, [r5, #ZoneSpare]
        STRB    lr, [r5, #ZoneSpare+1]
d1648 1
a1648 1
        STR     lr, [r5, #RootDir]
d1667 1
a1667 1
;	know the sector size of the disc.
d1707 1
a1707 1
        STRB    r8, [r5, #SectorSize]
d1709 1
a1709 1
        STRB    r8, [r5, #SecsPerTrk]
d1711 1
a1711 1
        STRB    r8, [r5, #Heads]
d1713 1
a1713 1
        STRB    r8, [r5, #Density]
d1715 1
a1715 1
        STRB    r8, [r5, #LowSector]
d1717 1
a1717 1
        STR     r8, [r5, #DiscSize]
d1720 1
a1720 1
        STR     r8, [r5, #DiscSize2]
d1743 1
a1743 1
        STRB    r0, [r5, #LowSector]
d1750 1
a1750 1
        TSTEQ   lr, #WinnieMounts
d1764 1
a1764 1
        MOV     R0, #Misc_Mount
d1777 1
a1777 1
        TSTEQ   lr, #WinnieMounts
d1790 3
a1792 3
        ; Density <= Octal
        LDRB    lr, [r4, #Density]
        CMP     lr, #Octal
d1794 1
a1794 1
        STRB    lr, [r5, #Density]
d1797 1
a1797 1
        LDRB    lr, [r4, #Heads]
d1800 1
a1800 1
        STRB    lr, [r5, #Heads]
d1803 1
a1803 1
        LDRB    lr, [r4, #SecsPerTrk]
d1806 1
a1806 1
        STRB    lr, [r5, #SecsPerTrk]
d1809 1
a1809 1
        LDRB    lr, [r4, #SectorSize]
d1814 1
a1814 1
        STRB    lr, [r5, #SectorSize]
d1816 4
a1819 4
        LDRB    lr, [r4, #LowSector]
        STRB    lr, [r5, #LowSector]
        LDR     lr, [r4, #DiscSize]
        STR     lr, [r5, #DiscSize]
d1821 1
a1821 1
        LDR     lr, [r4, #DiscSize2]
d1823 1
a1823 1
	DREG	lr, "Miscmount discsize 2 "
d1825 1
a1825 1
        STR     lr, [r5, #DiscSize2]
d1842 1
a1842 1
        STRB    lr, [r5, #LowSector]
d1844 1
a1844 1
        STR     lr, [r5, #DiscSize]
d1846 2
a1847 2
	MOV	lr, #0
	STR	lr, [r5, #DiscSize2]
d1925 1
a1925 1
        TSTS    R3, #Drv_NotChanged
d1929 1
a1929 1
        TST     R3, #Drv_Changed :OR: Drv_Empty
d1947 1
a1947 1
        TSTS    R3, #Drv_MaybeChanged
d1951 1
a1951 1
        TSTS    R3, #Drv_Changed :OR: Drv_Empty
d1955 1
a1955 1
        TSTS    R3, #Drv_Empty
d1959 1
a1959 1
        TSTS    R3, #Drv_Changed
d1978 2
a1979 2
        TSTNES  R3, #Drv_EmptyWorks
        TSTNES  R3, #Drv_NotChanged :OR: Drv_MaybeChanged :OR: Drv_Changed
d2015 1
a2015 1
        MOVHS   r3, #Drv_Empty :OR: Drv_EmptyWorks :OR: Drv_ChangedWorks
d2022 1
a2022 1
        MOVNE   R3, #Drv_NotChanged
d2025 1
a2025 1
        MOV     r0, #Misc_PollChanged
d2032 2
a2033 2
        TSTEQ   lr, #WinniePollChanges
        MOVEQ   r3, #Drv_NotChanged :OR: Drv_EmptyWorks :OR: Drv_ChangedWorks
d2190 1
a2190 1
        ADD     r5, r5, #DiscName
d2365 1
a2365 1
	DLINE	"************** Setting DiscsDrv to 8 in UnlinkCommon *************"
d2369 1
a2369 1
        LDR     R2, [LR, #DiscType]
d2414 1
a2414 1
        TSTEQ   lr, #WinniePollChanges
d2425 1
a2425 1
        MOV     R0, #Misc_LockDrive
d2447 1
a2447 1
        TSTEQ   lr, #WinniePollChanges
d2459 1
a2459 1
        MOV     R0, #Misc_UnlockDrive
d2586 2
a2587 2
	BVC	%FT21
	DLINE	"Bad sum"
@


4.8
log
@Make debug versions assemble again.
Entry macro renamed as SemEntry to avoid conflict with Hdr:Proc.
Other macro bit rot fixed up.
Tidy up switches.
DebugFx switch is the only one that doesn't work.
Non debug binary same as 3.41.

Version 3.42. Tagged as 'FileCore-3_42'
@
text
@d245 2
a246 2
        LDRNE   lr, [r4, #PrevFormDiscSize]
        STRNE   lr, [r5, #DiscSize]
@


4.7
log
@Fix erroneous unaligned load in FileCore
Detail:
  FindDiscRec was erroneously using LDR to load DiscsDrv when it should have used LDRB. Apart from the potential for disc record priorities to be incorrectly evaluated, this was also causing an abort when alignment exceptions were turned on.
Admin:
  Tested on rev C2 beagleboard. FAT formatted USB drives now seem to work OK.


Version 3.36. Tagged as 'FileCore-3_36'
@
text
@d1833 1
a1833 1
 [ T
a1836 1
;        LDR     lr, =&00010109  ; density=0, heads=1, sides=1, sectorsize=512
@


4.6
log
@  More 32-bit fixes.
Detail:
  Flag preservation added to 7 routines that require it.  Docs.32-bit
    updated to remove the names of the functions that have been made
    to preserve flags again.
Admin:
  This version needs more testing, but at least this version does not
    appear to stiff the machine, corrupt discs, go bang under light
    testing with ADFS and RAMFS.
  26-bit and 32-bit builds slightly tested.
  Do not use in products - Do use in test builds.

Version 3.25. Tagged as 'FileCore-3_25'
@
text
@d2083 1
a2083 1
        LDRNE   R8, [R5,#DiscsDrv]
@


4.5
log
@32-bit compatible. Some known issues remaining - don't use, except for
testing.

Version 3.23. Tagged as 'FileCore-3_23'
@
text
@d2477 2
d2484 1
@


4.4
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@a20 1
 [ Module_Version >= 209
a21 1
 ]
d577 1
a577 1
        MOV     r7, pc
d579 1
a579 1
        TEQP    pc, r7
d804 1
a804 1
        MOV     r3, #ARM_CC_Mask        ; Bad address just in case the driver gets frisky
a1673 1
 [ FileCache
a1674 1
 ]
d1894 2
a1895 1
        Push    "R0-R6,LR"
d1991 2
a1992 1
        Pull    "R0-R6,PC",,^
d2283 1
a2283 1
        Pull    "R1,PC",,^
d2312 1
a2312 1
        CMPS    R4, #8
d2316 1
a2316 1
        Pull    "R1-R5,PC",,^
d2349 1
a2349 1
        Pull    "R1-R2,PC",HS,^
d2376 2
a2377 1
        Pull    "R0-R2,PC",,^
@


4.3
log
@Spinner branch merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.
StrongARM flag now set to :LNOT:STB

Version 2.99. Tagged as 'FileCore-2_99'
@
text
@d19 2
d130 3
d251 4
d476 5
d583 4
d724 9
d736 1
d768 3
d837 2
d847 7
d1002 4
d1063 3
d1075 3
d1115 4
d1123 4
d1135 2
d1150 3
d1155 1
d1160 58
d1222 1
d1269 2
d1304 7
d1316 1
d1327 3
d1332 1
d1342 7
d1353 1
d1388 1
a1388 1
        DREG    r0, "Setting RootDir to "
d1406 3
d1411 1
d1432 3
d1436 1
d1455 3
d1459 1
d1481 3
d1485 1
d1503 1
a1503 1
        DREG    r0, "Setting RootDir to "
d1530 3
d1534 1
d1572 29
d1621 2
d1635 3
d1647 1
a1647 1
        DREG    r5, "Setting RootDir to "
d2367 4
d2500 3
d2505 1
d2530 5
d2538 1
d2561 1
a2561 1
        DLINE    ,"start    length - entering checksum",NL
@


4.2
log
@Version Spin_merge taken
@
text
@d19 1
a19 1
 [ Version >= 209
d62 1
a62 1
	
d86 1
a86 1
	
d117 1
a117 1
	
d127 1
a127 1
	
d155 1
a155 1
	
d207 1
a207 1
	
d259 1
a259 1
	
d308 1
a308 1
	
d356 1
a356 1
	
d390 1
a390 1
	
d397 1
a397 1
	
d503 1
a503 1
	
d628 1
a628 1
	
d843 1
a843 1
	
d884 1
a884 1
	
d918 1
a918 1
	
d973 1
a973 1
	
d980 1
a980 1
	
d1078 1
a1078 1
	
d1107 1
a1107 1
	
d1125 1
a1125 1
	
d1189 1
a1189 1
	
d1271 1
a1271 1
	
d1403 1
a1403 1
	
d1463 1
a1463 1
	
d1493 1
a1493 1
	
d1535 1
a1535 1
	
d1566 1
a1566 1
	
d1572 1
a1572 1
	
d1664 1
a1664 1
	
d1671 1
a1671 1
	
d1740 1
a1740 1
	
d1947 1
a1947 1
	
d1957 1
a1957 1
	
d2053 1
a2053 1
	
d2133 1
a2133 1
	
d2188 1
a2188 1
	
@


4.2.2.1
log
@Fixed a bug with NewClaimFree (and its use of SortDir) which caused problems
with 16 bit object ids.  Now copes with long ids correctly.

Started on bits of code for the long file names work.
@
text
@a18 2
; SBP: 19 Aug 1997: Changed to be aware of the Zones2 field.

a705 4
 [ BigMaps
	LDREQB	r0, [lr, #Zones2]
	TEQEQ	r0, #0
 ]
a739 3
 [ BigMaps
        STRB	lr, [r5, #Zones2]
 ]
a961 4
 [ BigMaps
	LDRB	r0, [r3, #Zones2]
	STRB	r0, [r5, #Zones2]
 ]
a1018 3
 [ BigMaps
 	STRB	r0, [r5, #Zones2]
 ]
a1027 3
 [ BigMaps
        STRB	r0, [r5, #Zones2]
 ]
a1064 4
 [ BigMaps
 	LDRB	r7, [r5, #Zones2]
 	ADD	r9, r9, r7, LSL #8
 ]
a1178 7
 [ BigMaps
	LDRB	r7, [r5, #Zones2]
	LDRB	r9, [r5, #Zones]
	ADD	r9, r9, r7, LSL #8
	; Determine old/new-ness of map by number of zones recorded
	LDRB	r7, [r5, #SectorSize]
 |
a1183 1
 ]
a1438 3
 [ BigMaps
 	STRB	lr, [r5, #Zones2]
 ]
@


4.2.2.2
log
@Long file names changes nearly completed.

Only FileCore_LayoutStructure and FileCore_FloppyStructure remain to
updated for long file names.
@
text
@d2382 1
a2382 1
        DLINE    ,"start    length - entering checksum";,NL
@


4.2.2.3
log
@Fixed s.BigDirCode (GrowBigDir and ShrinkBigDir) to cope with BitSize<SecSize
and rewrote free space map memory management to place free space maps in
dynamic areas.
@
text
@a711 5
 [ DynamicMaps
        LDREQ   r0, [r4, #DrvsFsMapFlags]
        ORREQ   r0, r0, #EmptyFs
        STREQ   r0, [r4, #DrvsFsMapFlags]
 |
a714 1
 ]
d1091 1
a1091 5
 
 [ DynamicMaps
 	LDR	lr, [r4, #DrvsFsMapSize]; get size of the free space map
 	TEQS	r8, lr			; is space allocated for map right size ?
 |
a1099 2
 ]
 
a1112 3
 [ DynamicMaps
        LDR     r2, [r4, #DrvsFsMapAddr]
 |
a1114 1
 ]
a1118 40
 [ DynamicMaps
 
 	; find the actual allocated size
 	
 	Push	"R1, R3-r8"
 	
 	MOV	R0, #2
 	LDR	R1, [R4, #DrvsFsMapArea]
 	BL	OnlyXOS_DynamicArea		; get the dynamic area size in bytes
 	
 	
 	Pull	"R1, R3-R8"
 	
 	BVS	%FT90
 	; work out the size the area must grow or shrink by
 	
 	ADD	r3, r8, r8, LSR #8		; new size of wotsit
 	
 	Push	"R1"
 	
 	SUB	R1, R3, R2			; amount to change size by
 	LDR	R0, [R4, #DrvsFsMapArea]	; area number
 	BL	OnlyXOS_ChangeDynamicArea
 	
 	Pull	"R1"
 	
 	BVS	%FT90				; error!
 	
 	; here, new space allocation is correct, so we're cool
 
 	STR	r8, [R4, #DrvsFsMapSize]		; store the new size
 
20
 	TEQ	r9, #0
 	MOVEQ	lr, #EmptyFs
 	MOVNE	lr, #0
 	STR	lr, [r4, #DrvsFsMapFlags]		; store new flags0
 
 | ; ELSE              (NOT Dynamic maps!)
 
a1121 1
 
a1168 2
 ] ;ENDIF DynamicMaps
 
a1224 3
 [ DynamicMaps
        LDR     r3, [r4, #DrvsFsMapAddr]
 |
a1226 1
 ]
a1235 7
 [ DynamicMaps
        ; Map is now in
        LDR     r3, [r4, #DrvsFsMapFlags]
        BIC     r3, r3, #NewHiFsBits
        STR     r3, [r4, #DrvsFsMapFlags]
        LDR	r3, [r4, #DrvsFsMapAddr]
 |
a1239 1
 ]
a1291 3
 [ DynamicMaps
        LDR     r0, [r4, #DrvsFsMapAddr]
 |
a1293 1
 ]
a1313 3
 [ DynamicMaps
        LDR     r3, [r4, #DrvsFsMapAddr]
 |
a1314 1
 ]
a1332 3
 [ DynamicMaps
        LDR     r3, [r4, #DrvsFsMapAddr]
 |
a1333 1
 ]
a1354 3
 [ DynamicMaps
        LDR     r0, [r4, #DrvsFsMapAddr]
 |
a1355 1
 ]
a1399 3
 [ DynamicMaps
        LDR     r1, [r4, #DrvsFsMapAddr]
 |
a1400 1
 ]
a1436 29
 
 [ DynamicMaps
 
 	; with the maps stored in a dynamic area, we don't delete the dynamic area,
 	; but instead just pretend it's not there
 	
 	MOV	R1, #0			; set the allocated size to zero,
 	STR	R1, [R4, #DrvsFsMapSize]	; so that if we have problems, we assume no map allocated
 	
 	LDR	R1, [R4, #DrvsFsMapArea]
 	MOV	R0, #2
 	
 	Push	"R3-R8"
 	
 	BL	OnlyXOS_DynamicArea	; get the dynamic area's info (only needs r2, ie the size)
 	
 	BVS	%FT80			; got the size
 	
 	Pull	"R3-R8"
 	
 	; now shrink it back to zero
 	
 	MOV	R0, R1			; dynamic area number in R0
 	RSB	R1, R2, #0		; shrinking...
 	
 	BL	OnlyXOS_ChangeDynamicArea	; shrink it
 	
 	BVS	%FT80			; shrink
 |
a1456 2
        
 ]
a2330 3
 [ DynamicMaps
        LDR     R0, [R4,#DrvsFsMapAddr]
 |
a2332 1
 ]
a2356 5
 [ DynamicMaps
        LDRNE   R2, [R4,#DrvsFsMapFlags]
        ORRNE   R2, R2, #BadFs
        STRNE   R2, [R4,#DrvsFsMapFlags]
 |
a2359 1
 ]
@


4.2.2.4
log
@Binary-chop dir scanning fixed.  (BigLexEqv fixed so that it doesn't
try to compare the dir separator '.' in eg "Default.Thing" with another
object called "Default+" (was breaking binary chop dir search).

Fixed IdentifyDisc (s.Identify); old behaviour left the RootDir field
invalid (the disc bits were an external drive number, instead of an
internal disc number).  This causes problems if the disc fails to mount
due to, for example, memory problems, as the illegal value never gets
fixed (normally, MountDiscOnDrive would end up correcting the problem).
@
text
@d64 1
a64 1

d88 1
a88 1

d119 1
a119 1

d129 1
a129 4

	LDR	lr, [r5, #RootDir]
	DREG	lr, "RootDir on Exit WhatDisc is: "

d157 1
a157 1

d209 1
a209 1

a247 4
 [ DebugLm
	DLINE	"Blanking out disc name"
 ]

d261 1
a261 1

d310 1
a310 1

d358 1
a358 1

d392 1
a392 1

d399 1
a399 1

a468 5
  [ DebugL
	DREG	r1, "************************ DiscsDrv set to ",cc
	DLINE	" in DetermineDiscType *****************************"
  ]

d505 1
a505 1

d630 1
a630 1

a820 2
	DREG	r1, "************************* DiscsDrv set to",cc
	DLINE   " in MountDiscOnDrive *************************"
d858 1
a858 1

d899 1
a899 1

d933 1
a933 1

d992 1
a992 1

d999 1
a999 1

d1097 1
a1097 1

d1111 1
a1111 1

d1113 1
a1113 1

d1136 1
a1136 1

d1138 1
a1138 1

d1140 1
a1140 1

d1144 2
a1145 2


d1147 1
a1147 5

	LDRVS	lr, [r4, #DrvsFsMapFlags]	; set the 'map memory error' bit
	ORRVS	lr, lr, #MemErrorFs		;
	STRVSB	lr, [r4, #DrvsFsMapFlags]

d1150 1
a1150 1

d1152 1
a1152 1

d1154 1
a1154 1

a1155 3
 [ DebugL
	DREG	R1, "Area size to change by: "
 ]
d1158 1
a1158 12

 [ DebugL
	BVC	%FT01
	DebugError	"AdjustFsSpace - OS_ChangeDynamicarea error "
01
 ]

	LDR	lr, [r4, #DrvsFsMapFlags]	; set/clear the 'map memory error' bit
	ORRVS	lr, lr, #MemErrorFs		;
	BICVC	lr, lr, #MemErrorFs		;
	STR	lr, [r4, #DrvsFsMapFlags]	;

d1160 1
a1160 1

d1162 1
a1162 1

d1164 1
a1164 1

d1166 1
a1166 1

d1172 1
a1172 1

d1174 1
a1174 1

d1178 1
a1178 1

d1187 1
a1187 1

d1205 1
a1205 1

d1227 1
a1227 1

d1279 1
a1279 1

d1345 1
a1345 1
        DREG    r0, "Setting RootDir to (FileCore20, 1394) "
d1377 1
a1377 1

d1460 1
a1460 1
        DREG    r0, "Setting RootDir to (FileCore20, 1509) "
d1525 1
a1525 1

d1528 1
a1528 1

d1530 1
a1530 1

d1533 1
a1533 1

d1536 1
a1536 1

d1539 1
a1539 1

d1541 1
a1541 1

d1543 1
a1543 1

d1545 1
a1545 1

d1547 1
a1547 1

d1549 1
a1549 1

d1552 1
a1552 1

d1554 1
a1554 1

d1577 1
a1577 1

d1604 1
a1604 1
        DREG    r5, "Setting RootDir to (FileCore20, 1653) "
d1619 1
a1619 1

d1649 1
a1649 1

d1691 1
a1691 1

d1722 1
a1722 1

d1728 1
a1728 1

d1820 1
a1820 1

d1827 1
a1827 1

d1896 1
a1896 1

d2103 1
a2103 1

d2113 1
a2113 1

d2209 1
a2209 1

d2289 1
a2289 1

a2323 4
 [ DebugL
	DLINE	"************** Setting DiscsDrv to 8 in UnlinkCommon *************"
 ]

d2344 1
a2344 1

@


4.2.2.5
log
@Found a major inefficiency in the handling of file creation, closing of files
and other uses of the NextFree function.  In the case of file creation, the
problem was particularly bad on large free space maps, as the function was
of order N^2 on the size of the map, when the disc was nearly full.  As the
disc gets fuller, the problem gets worse; with 1400 zones in the map, N^2
is very large indeed.  This resulted in *cdir sometimes taking 1sec.

Now, a new function NextFree_Quick exists which performs similarly to NextFree,
but does not consider free spaces in zones beyond the current zone.  This
can be used by functions which need only examine free spaces in a given zone,
such as is the case in ClaimFreeSpace where it is stepping throigh zones to
find a single gap large enough for the entire file.

For other functions which work on a single zone, the speedup is less dramatic,
of the order N instead of N^2.
@
text
@d130 1
a130 1
	LDR	lr, [r3, #RootDir]
a582 4
 [ DebugL
	DREG	R5, "Disc rec ptr now: "
 ]

a841 7

 [ BigDir
	LDR	lr, [r5, #RootDir]
	BIC	lr, lr, #DiscBits
	ORR	lr, lr, r2, LSL #(32-3)
	STR	lr, [r5, #RootDir]
 ]
@


4.1
log
@Initial revision
@
text
@d746 7
a769 5

 [ BigDisc
	MOV	lr, #0
	STR	lr, [r5,#DiscSize2]
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a745 7
 [ BigDisc
	STR	lr, [r5,#DiscSize2]
 [ BigShare
        STR     lr, [r5,#ShareSize]
 ]
 ]

d763 5
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a745 7
 [ BigDisc
	STR	lr, [r5,#DiscSize2]
 [ BigShare
        STR     lr, [r5,#ShareSize]
 ]
 ]

d763 5
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a745 7
 [ BigDisc
	STR	lr, [r5,#DiscSize2]
 [ BigShare
        STR     lr, [r5,#ShareSize]
 ]
 ]

d763 5
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

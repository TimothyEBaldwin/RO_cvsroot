head	4.2;
access;
symbols
	FileCore-3_75:4.2
	FileCore-3_74:4.2
	FileCore-3_73:4.2
	FileCore-3_72:4.2
	FileCore-3_71:4.2
	FileCore-3_70:4.2
	FileCore-3_69:4.2
	FileCore-3_68:4.2
	FileCore-3_67:4.2
	FileCore-3_66:4.2
	FileCore-3_65:4.2
	FileCore-3_64:4.2
	FileCore-3_63:4.2
	FileCore-3_62:4.2
	FileCore-3_61:4.2
	FileCore-3_60:4.2
	FileCore-3_59:4.2
	FileCore-3_58:4.2
	FileCore-3_57:4.2
	FileCore-3_56:4.2
	FileCore-3_55:4.1
	FileCore-3_54:4.1
	FileCore-3_53:4.1
	FileCore-3_52:4.1
	FileCore-3_51:4.1
	FileCore-3_50:4.1
	FileCore-3_49:4.1
	FileCore-3_48:4.1
	FileCore-3_47:4.1
	FileCore-3_46:4.1
	FileCore-3_45:4.1
	FileCore-3_44:4.1
	FileCore-3_43:4.1
	FileCore-3_42:4.1
	FileCore-3_41:4.1
	FileCore-3_40:4.1
	FileCore-3_39:4.1
	FileCore-3_38:4.1
	FileCore-3_37:4.1
	FileCore-3_36:4.1
	FileCore-3_35:4.1
	FileCore-3_34:4.1
	FileCore-3_33:4.1
	RO_5_07:4.1
	FileCore-3_32:4.1
	FileCore-3_31:4.1
	FileCore-3_30:4.1
	FileCore-3_29:4.1
	FileCore-3_28:4.1
	FileCore-3_25-4_9_2_2:4.1
	FileCore-3_27:4.1
	FileCore-3_26:4.1
	FileCore-3_22-4_6_2_1:4.1
	bavison_FileCore-3_22_dev_bp:4.1
	bavison_FileCore-3_22:4.1.0.14
	FileCore-3_25-4_9_2_1:4.1
	HAL:4.1.0.12
	FileCore-3_25:4.1
	FileCore-3_24:4.1
	FileCore-3_23:4.1
	dellis_autobuild_BaseSW:4.1
	FileCore-3_22:4.1
	Ursula_merge:4.1
	ROL_merge:4.1
	FileCore-3_21:4.1
	ROL_Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	ROL_FileCore-3_21:4.1
	ROL_FileCore-3_20:4.1
	ROL:4.1.0.10
	ROL_bp:4.1
	Ursula_RiscPC_bp:4.1
	FileCore-3_18:4.1
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1
	sproven_FileCore-3_16:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	sproven_FileCore-3_15:4.1
	sproven_314:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1
	sproven_3_11:4.1
	sproven_3_10:4.1
	sproven_Ursula_3_09:4.1
	sproven_3_07:4.1
	sproven_3_06:4.1
	sproven_3_05:4.1
	sproven_3_04:4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1
	sproven_3_02:4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	2013.02.24.21.09.03;	author rsprowson;	state Exp;
branches;
next	4.1;
commitid	rgJG8ZFRF8o9ruFw;

4.1
date	96.11.05.09.32.29;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.29;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.42.25;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.52;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.41;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "tester.h"
#include "logger.h"

void os_file0( char *name, int load, int exec, unsigned int length )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        unsigned int i;

        logprintf( "os_file 0( \"%s\", %x, %x, %u ) ", name, load, exec, length );

        for ( i = 0;
              i < length;
              i++ )
        {
                random_data_area[ i ] = myrand() & 0xff;
                random_write_result[ i ] = myrand() & 0xff;
        }

        r.r[0] = 0;
        r.r[1] = (int)name;
        r.r[2] = load;
        r.r[3] = exec;
        r.r[4] = (int)random_data_area;
        r.r[5] = (int)random_data_area + length;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_FSAccessViolation:
                case Error_DirectoryFull:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3f );

                check_catalogue_info( name, 0, load, exec, length, 0, 0xe );

                r.r[0] = 16;
                r.r[1] = (int)name;
                r.r[2] = (int)random_write_result;
                r.r[3] = 0;

                err = _kernel_swi( OS_File, &r, &r );

                if ( err )
                {
                        pout_error( err );
                        logprintf( "when reloading saved memory " );
                }
                else
                {
                        if ( memcmp( random_data_area, random_write_result, length ) != 0 )
                        {
                                problems++;
                                logprintf( "data read back not same as data saved " );
                        }
                }
        }

        logprintf( "\n" );
}

void os_file1( char *name, int load, int exec, int attributes )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_file 1( \"%s\", %x, %x, %x ) ", name, load, exec, attributes );

        r.r[0] = 1;
        r.r[1] = (int)name;
        r.r[2] = load;
        r.r[3] = exec;
        r.r[5] = attributes;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_FSAccessViolation:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3f );

                check_catalogue_info( name, 0, load, exec, 0, attributes, 0x16 );
        }

        logprintf( "\n" );
}

void os_file2( char *name, int load )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_file 2( \"%s\", %x ) ", name, load );

        r.r[0] = 2;
        r.r[1] = (int)name;
        r.r[2] = load;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_FSAccessViolation:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x7 );

                check_catalogue_info( name, 0, load, 0, 0, 0, 0x2 );
        }

        logprintf( "\n" );
}

void os_file3( char *name, int exec )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_file 3( \"%s\", %x ) ", name, exec );

        r.r[0] = 3;
        r.r[1] = (int)name;
        r.r[3] = exec;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_FSAccessViolation:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0xb );

                check_catalogue_info( name, 0, 0, exec, 0, 0, 0x4 );
        }

        logprintf( "\n" );
}

void os_file4( char *name, int attributes )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_file 4( \"%s\", %x ) ", name, attributes );

        r.r[0] = 4;
        r.r[1] = (int)name;
        r.r[5] = attributes;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
                pout_error( err );
        else
        {
                check_regs_unchanged( &r, &newr, 0x23 );

                check_catalogue_info( name, 0, 0, 0, 0, attributes, 0x10 );
        }

        logprintf( "\n" );
}

void os_file6( char *name )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs oldr;
        int directory_not_empty = No;

        logprintf( "os_file 6( \"%s\" ) ", name );

        r.r[0] = 17;
        r.r[1] = (int)name;

        _kernel_swi( OS_File, &r, &oldr );

        if ( oldr.r[0] == 2 )
        {
                char buff[ 500 ];

                r.r[0] = 9;
                r.r[1] = (int)name;
                r.r[2] = (int)buff;
                r.r[3] = sizeof(buff);
                r.r[4] = 0;
                r.r[5] = sizeof(buff);
                r.r[6] = (int)"*";

                err = _kernel_swi( OS_GBPB, &r, &r );

                if ( !err && r.r[3] > 0 )
                        directory_not_empty = Yes;
        }

        r.r[0] = 6;
        r.r[1] = (int)name;

        err = _kernel_swi( OS_File, &r, &r );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_DirNotEmpty:
                        /* error if directory was empty */
                        if ( !directory_not_empty )
                                pout_error( err );
                        break;

                case Error_Locked:
                        /* error if object wasn't locked */
                        if ( (oldr.r[5] & 0x08) == 0 )
                                pout_error( err );
                        break;

                case Error_FSAccessViolation:
                case Error_CantDeleteCurrent:
                case Error_CantDeleteLibrary:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                if ( oldr.r[5] & 0x08 )
                {
                        problems++;
                        logprintf( "object was locked and was deleted " );
                }
                if ( oldr.r[0] != r.r[0] )
                {
                        problems++;
                        logprintf( "object type changed " );
                }
                if ( oldr.r[2] != r.r[2] )
                {
                        problems++;
                        logprintf( "load address changed " );
                }
                if ( oldr.r[3] != r.r[3] )
                {
                        problems++;
                        logprintf( "exec address changed " );
                }
                if ( oldr.r[4] != r.r[4] )
                {
                        problems++;
                        logprintf( "length changed " );
                }
                if ( oldr.r[5] != r.r[5] )
                {
                        problems++;
                        logprintf( "attributes changed " );
                }
                if ( directory_not_empty )
                {
                        problems++;
                        logprintf( "directory wasn't empty but was deleted " );
                }

                r.r[0] = 17;
                r.r[1] = (int)name;

                err = _kernel_swi( OS_File, &r, &r );

                if ( err )
                {
                        pout_error( err );
                        logprintf( "while trying to find the object again " );
                }
                else if ( r.r[0] != 0 )
                {
                        problems++;
                        logprintf( "object present after deletion " );
                }
        }

        logprintf( "\n" );
}

void os_file7( char *name, int load, int exec, unsigned int start, unsigned int end )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_file 7( \"%s\", %x, %x, %x, %x ) ", name, load, exec, start, end );

        r.r[0] = 7;
        r.r[1] = (int)name;
        r.r[2] = load;
        r.r[3] = exec;
        r.r[4] = (int)start;
        r.r[5] = (int)end;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_TypesDontMatch:
                case Error_FSAccessViolation:
                case Error_DirectoryFull:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3f );
                check_catalogue_info( name, 1, load, exec, end - start, 0, 0xf );
        }

        logprintf( "\n" );
}

void os_file8( char *name, int ents )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_file 8( \"%s\", %d ) ", name, ents );

        r.r[0] = 8;
        r.r[1] = (int)name;
        r.r[4] = ents;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_TypesDontMatch:
                case Error_FSAccessViolation:
                case Error_DirectoryFull:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x13 );
                check_catalogue_info( name, 2, 0, 0, 0, 0, 0x1 );
        }

        logprintf( "\n" );
}

void os_file9( char *name )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_file 9( \"%s\" ) ", name );

        r.r[0] = 9;
        r.r[1] = (int)name;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                if ( (err->errnum & FileError_Mask) != Error_FSAccessViolation )
                        pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );
        }

        logprintf( "\n" );
}

void os_file10( char *name, int type, unsigned int length )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        unsigned int i;

        logprintf( "os_file 10( \"%s\", %x, %u ) ", name, type, length );

        for ( i = 0;
              i < length;
              i++ )
        {
                random_data_area[ i ] = myrand() & 0xff;
                random_write_result[ i ] = myrand() & 0xff;
        }

        r.r[0] = 10;
        r.r[1] = (int)name;
        r.r[2] = type;
        r.r[4] = (int)random_data_area;
        r.r[5] = (int)random_data_area + length;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_FSAccessViolation:
                case Error_DirectoryFull:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x37 );

                check_catalogue_info( name, 0, type<<8, 0, length, 0, 0x28 );

                r.r[0] = 16;
                r.r[1] = (int)name;
                r.r[2] = (int)random_write_result;
                r.r[3] = 0;

                err = _kernel_swi( OS_File, &r, &r );

                if ( err )
                {
                        pout_error( err );
                        logprintf( "when reloading saved memory " );
                }
                else
                {
                        if ( memcmp( random_data_area, random_write_result, length ) != 0 )
                        {
                                problems++;
                                logprintf( "data read back not same as data saved " );
                        }
                }
        }

        logprintf( "\n" );
}

void os_file11( char *name, int type, unsigned int start, unsigned int end )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_file 11( \"%s\", %x, %x, %x ) ", name, type, start, end );

        r.r[0] = 11;
        r.r[1] = (int)name;
        r.r[2] = type;
        r.r[4] = start;
        r.r[5] = end;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_TypesDontMatch:
                case Error_FSAccessViolation:
                case Error_DirectoryFull:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x37 );
                check_catalogue_info( name, 1, type<<8, 0, end - start, 0, 0x29 );
        }

        logprintf( "\n" );
}

void os_file16( char *name )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs oldr;

        logprintf( "os_file 16( \"%s\" ) ", name );

        r.r[0] = 17;
        r.r[1] = (int)name;

        err = _kernel_swi( OS_File, &r, &oldr );

        if ( err )
        {
                pout_error( err );
                logprintf( "while getting attributes before loading\n" );
                return;
        }

#if BigFiles
        if ( (unsigned int)oldr.r[4] > RandomDataAmount )
        {
                logprintf( "too big to load\n" );
                return;
        }
#endif

        r.r[0] = 16;
        r.r[1] = (int)name;
        r.r[2] = (int)random_write_result;
        r.r[3] = 0;

        err = _kernel_swi( OS_File, &r, &r );

        if ( err )
        {
                if ( (err->errnum & FileError_Mask) == Error_FSAccessViolation ||
                        err->errnum == Error_AccessViolation )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        else
        {
                check_regs_unchanged( &oldr, &r, 0x3f );
        }

        logprintf( "\n" );
}

void os_file17( char *name )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;

        logprintf( "os_file 17( \"%s\" ) ", name );

        r.r[0] = 17;
        r.r[1] = (int)name;

        err = _kernel_swi( OS_File, &r, &r );

        if ( err )
                pout_error( err );
        else
        {
        }

        logprintf( "\n" );
}

void os_file18( char *name, int type )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_file 18( \"%s\", %x ) ", name, type );

        r.r[0] = 18;
        r.r[1] = (int)name;
        r.r[2] = type;

        err = _kernel_swi( OS_File, &r, &newr );

        if ( err )
        {
                switch( err->errnum & FileError_Mask )
                {
                case Error_FSAccessViolation:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3f );

                check_catalogue_info( name, 0, type<<8, 0, 0, 0, 0x20 );
        }

        logprintf( "\n" );
}
@


4.1
log
@Initial revision
@
text
@d22 1
a22 1
void os_file0( char *name, int load, int exec, int length )
d27 1
a27 1
        int i;
d29 1
a29 1
        logprintf( "os_file 0( \"%s\", %x, %x, %d ) ", name, load, exec, length );
d32 2
a33 2
                i < length;
                i++ )
d72 1
a72 1
                err = _kernel_swi( XOS_Bit | OS_File, &r, &r );
d240 1
a240 1
        _kernel_swi( XOS_Bit | OS_File, &r, &oldr );
d249 1
a249 1
                r.r[3] = 500;
d251 1
a251 1
                r.r[5] = 500;
d254 1
a254 1
                err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &r );
d263 1
a263 1
        err = _kernel_swi( XOS_Bit | OS_File, &r, &r );
d332 1
a332 1
                err = _kernel_swi( XOS_Bit | OS_File, &r, &r );
d349 1
a349 1
void os_file7( char *name, int load, int exec, int start, int end )
d361 2
a362 2
        r.r[4] = start;
        r.r[5] = end;
d364 1
a364 1
        err = _kernel_swi( XOS_Bit | OS_File, &r, &newr );
d401 1
a401 1
        err = _kernel_swi( XOS_Bit | OS_File, &r, &newr );
d452 1
a452 1
void os_file10( char *name, int type, int length )
d457 1
a457 1
        int i;
d459 1
a459 1
        logprintf( "os_file 10( \"%s\", %x, %d ) ", name, type, length );
d462 2
a463 2
                i < length;
                i++ )
d501 1
a501 1
                err = _kernel_swi( XOS_Bit | OS_File, &r, &r );
d521 1
a521 1
void os_file11( char *name, int type, int start, int end )
d535 1
a535 1
        err = _kernel_swi( XOS_Bit | OS_File, &r, &newr );
d571 1
a571 1
        err = _kernel_swi( XOS_Bit | OS_File, &r, &oldr );
d580 8
d593 1
a593 1
        err = _kernel_swi( XOS_Bit | OS_File, &r, &r );
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

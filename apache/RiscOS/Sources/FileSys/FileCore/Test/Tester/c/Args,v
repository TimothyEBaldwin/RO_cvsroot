head	4.2;
access;
symbols
	FileCore-3_75:4.2
	FileCore-3_74:4.2
	FileCore-3_73:4.2
	FileCore-3_72:4.2
	FileCore-3_71:4.2
	FileCore-3_70:4.2
	FileCore-3_69:4.2
	FileCore-3_68:4.2
	FileCore-3_67:4.2
	FileCore-3_66:4.2
	FileCore-3_65:4.2
	FileCore-3_64:4.2
	FileCore-3_63:4.2
	FileCore-3_62:4.2
	FileCore-3_61:4.2
	FileCore-3_60:4.2
	FileCore-3_59:4.2
	FileCore-3_58:4.2
	FileCore-3_57:4.2
	FileCore-3_56:4.2
	FileCore-3_55:4.1
	FileCore-3_54:4.1
	FileCore-3_53:4.1
	FileCore-3_52:4.1
	FileCore-3_51:4.1
	FileCore-3_50:4.1
	FileCore-3_49:4.1
	FileCore-3_48:4.1
	FileCore-3_47:4.1
	FileCore-3_46:4.1
	FileCore-3_45:4.1
	FileCore-3_44:4.1
	FileCore-3_43:4.1
	FileCore-3_42:4.1
	FileCore-3_41:4.1
	FileCore-3_40:4.1
	FileCore-3_39:4.1
	FileCore-3_38:4.1
	FileCore-3_37:4.1
	FileCore-3_36:4.1
	FileCore-3_35:4.1
	FileCore-3_34:4.1
	FileCore-3_33:4.1
	RO_5_07:4.1
	FileCore-3_32:4.1
	FileCore-3_31:4.1
	FileCore-3_30:4.1
	FileCore-3_29:4.1
	FileCore-3_28:4.1
	FileCore-3_25-4_9_2_2:4.1
	FileCore-3_27:4.1
	FileCore-3_26:4.1
	FileCore-3_22-4_6_2_1:4.1
	bavison_FileCore-3_22_dev_bp:4.1
	bavison_FileCore-3_22:4.1.0.14
	FileCore-3_25-4_9_2_1:4.1
	HAL:4.1.0.12
	FileCore-3_25:4.1
	FileCore-3_24:4.1
	FileCore-3_23:4.1
	dellis_autobuild_BaseSW:4.1
	FileCore-3_22:4.1
	Ursula_merge:4.1
	ROL_merge:4.1
	FileCore-3_21:4.1
	ROL_Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	ROL_FileCore-3_21:4.1
	ROL_FileCore-3_20:4.1
	ROL:4.1.0.10
	ROL_bp:4.1
	Ursula_RiscPC_bp:4.1
	FileCore-3_18:4.1
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1
	sproven_FileCore-3_16:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	sproven_FileCore-3_15:4.1
	sproven_314:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1
	sproven_3_11:4.1
	sproven_3_10:4.1
	sproven_Ursula_3_09:4.1
	sproven_3_07:4.1
	sproven_3_06:4.1
	sproven_3_05:4.1
	sproven_3_04:4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1
	sproven_3_02:4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	2013.02.24.21.09.03;	author rsprowson;	state Exp;
branches;
next	4.1;
commitid	rgJG8ZFRF8o9ruFw;

4.1
date	96.11.05.09.32.28;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.28;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.42.19;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.49;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.38;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include "kernel.h"
#include "swis.h"
#include "tester.h"
#include "logger.h"

void os_args0( int *file )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_args 0( %d ) ", *file );

        r.r[0] = 0;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );

                r.r[0] = 2;
                r.r[1] = *file;
                err = _kernel_swi( OS_Args, &r, &r );

                if ( err )
                {
                        pout_error( err );
                        logprintf( "while getting extent of file " );
                }
                else
                {
                        if ( (unsigned int)r.r[2] < (unsigned int)newr.r[2] )
                        {
                                problems++;
                                logprintf( "sequential file pointer beyond file extent " );
                        }
                }
        }

        logprintf( "\n" );
}

void os_args1( int *file, unsigned int pointer )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        unsigned int old_extent;
        unsigned int i;

        logprintf( "os_args 1( %d, %u ) ", *file, pointer );

        r.r[0] = 2;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading file extent\n" );
                return;
        }

        old_extent = (unsigned int)r.r[2];

        r.r[0] = 1;
        r.r[1] = *file;
        r.r[2] = (int)pointer;

        err = _kernel_swi( OS_Args, &r, &newr );

        if ( err )
        {
                if ( err->errnum == Error_OutsideFile && pointer > old_extent )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x7 );

                r.r[0] = 0;
                r.r[1] = *file;

                err = _kernel_swi( OS_Args, &r, &r );

                if ( err )
                {
                        pout_error( err );
                        logprintf( "while reading new sequential file pointer " );
                }
                else if ( pointer != (unsigned int)newr.r[2] )
                {
                        problems++;
                        logprintf( "new sequential file pointer not same as set one " );
                }
                else if ( pointer > old_extent )
                {
                        r.r[0] = 2;
                        r.r[1] = *file;

                        err = _kernel_swi( OS_Args, &r, &r );

                        if ( err )
                        {
                                pout_error( err );
                                logprintf( "while reading new file extent\n" );
                                return;
                        }

                        if ( r.r[2] != pointer )
                        {
                                problems++;
                                logprintf( "new extended file size isn't same as new pointer\n" );
                                return;
                        }

                        r.r[0] = 1;
                        r.r[1] = *file;
                        r.r[2] = (int)old_extent;

                        err = _kernel_swi( OS_Args, &r, &r );

                        if ( err )
                        {
                                pout_error( err );
                                logprintf( "while moving pointer to check for zero extension\n" );
                        }

                        for ( i = old_extent;
                              i < pointer;
                              i++ )
                        {
                                r.r[1] = *file;

                                err = _kernel_swi( OS_BGet, &r, &r );

                                if ( err )
                                {
                                        if ( err->errnum == Error_NotOpenForReading )
                                        {
                                                /* do nothing */
                                        }
                                        else
                                        {
                                                pout_error( err );
                                                logprintf( "while checking zero extention of file\n" );
                                        }

                                        return;
                                }

                                if ( r.r[0] != 0 )
                                {
                                        problems++;
                                        logprintf( "zero extention isn't all zeros\n" );
                                        return;
                                }
                        }
                }
        }

        logprintf( "\n" );
}

void os_args2( int *file )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_args 2( %d ) ", *file );

        r.r[0] = 2;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );

                r.r[0] = 0;
                r.r[1] = *file;
                err = _kernel_swi( OS_Args, &r, &r );

                if ( err )
                {
                        pout_error( err );
                        logprintf( "while getting sequential file pointer of file " );
                }
                else
                {
                        if ( (unsigned int)r.r[2] > (unsigned int)newr.r[2] )
                        {
                                problems++;
                                logprintf( "sequential file pointer beyond file extent " );
                        }
                }
        }

        logprintf( "\n" );
}

void os_args3( int *file, unsigned int extent )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        unsigned int old_pointer;
        unsigned int old_extent;
        unsigned int i;

        logprintf( "os_args 3( %d, %u ) ", *file, extent );

        r.r[0] = 0;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading file's sequential pointer\n" );
                return;
        }

        old_pointer = (unsigned int)r.r[2];

        r.r[0] = 2;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading file's extent\n" );
                return;
        }

        old_extent = (unsigned int)r.r[2];

        r.r[0] = 3;
        r.r[1] = *file;
        r.r[2] = (int)extent;

        err = _kernel_swi( OS_Args, &r, &newr );

        if ( err )
        {
                if ( err->errnum != Error_NotOpenForUpdate )
                        pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x7 );

                r.r[0] = 2;
                r.r[1] = *file;

                err = _kernel_swi( OS_Args, &r, &r );

                if ( err )
                {
                        pout_error( err );
                        logprintf( "while reading new extent " );
                }
                else if ( extent != (unsigned int)newr.r[2] )
                {
                        problems++;
                        logprintf( "new extent not same as set one " );
                }
                else if ( extent < old_pointer )
                {
                        r.r[0] = 0;
                        r.r[1] = *file;

                        err = _kernel_swi( OS_Args, &r, &r );

                        if ( err )
                        {
                                pout_error( err );
                                logprintf( "while reading new sequential file pointer\n" );
                                return;
                        }

                        if ( r.r[2] != extent )
                        {
                                problems++;
                                logprintf( "new pointer not dropped to extent\n" );
                                return;
                        }
                }
                else if ( extent > old_extent )
                {
                        r.r[0] = 1;
                        r.r[1] = *file;
                        r.r[2] = (int)old_extent;

                        err = _kernel_swi( OS_Args, &r, &r );

                        if ( err )
                        {
                                pout_error( err );
                                logprintf( "while moving pointer to check for zero extension\n" );
                        }
                        for ( i = old_extent;
                              i < extent;
                              i++ )
                        {
                                r.r[1] = *file;

                                err = _kernel_swi( OS_BGet, &r, &r );

                                if ( err )
                                {
                                        if ( err->errnum == Error_NotOpenForReading )
                                        {
                                                /* do nothing */
                                        }
                                        else
                                        {
                                                pout_error( err );
                                                logprintf( "while checking zero extention of file\n" );
                                        }
                                        return;
                                }

                                if ( r.r[0] != 0 )
                                {
                                        problems++;
                                        logprintf( "zero extention isn't all zeros\n" );
                                        return;
                                }
                        }
                }
        }

        logprintf( "\n" );
}

void os_args4( int *file )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_args 4( %d ) ", *file );

        r.r[0] = 4;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );
        }

        logprintf( "\n" );
}

void os_args5( int *file )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_args 5( %d ) ", *file );

        r.r[0] = 5;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );
        }

        logprintf( "\n" );
}

void os_args6( int *file, unsigned int ensure )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_args 6( %d, %u ) ", *file, ensure );

        r.r[0] = 6;
        r.r[1] = *file;
        r.r[2] = (int)ensure;

        err = _kernel_swi( OS_Args, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );
        }

        logprintf( "\n" );
}

void os_args255( int *file )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_args 255( %d ) ", *file );

        r.r[0] = 255;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x7 );
        }

        logprintf( "\n" );
}
@


4.1
log
@Initial revision
@
text
@d32 1
a32 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &newr );
d44 1
a44 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d53 1
a53 1
                        if ( r.r[2] < newr.r[2] )
a57 5
                        else if ( newr.r[2] < 0 )
                        {
                                problems++;
                                logprintf( "sequential file pointer negative " );
                        }
d64 1
a64 1
void os_args1( int *file, int pointer )
d69 2
a70 2
        int old_extent;
        int i;
d72 1
a72 1
        logprintf( "os_args 1( %d, %d ) ", *file, pointer );
d77 1
a77 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d86 1
a86 1
        old_extent = r.r[2];
d90 1
a90 1
        r.r[2] = pointer;
d92 1
a92 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &newr );
d112 1
a112 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d119 1
a119 1
                else if ( pointer != newr.r[2] )
d129 1
a129 1
                        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d147 1
a147 1
                        r.r[2] = old_extent;
d149 1
a149 1
                        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d158 2
a159 2
                                i < pointer;
                                i++ )
d163 1
a163 1
                                err = _kernel_swi( XOS_Bit | OS_BGet, &r, &r );
d204 1
a204 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &newr );
d216 1
a216 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d225 1
a225 1
                        if ( r.r[2] > newr.r[2] )
a229 5
                        else if ( newr.r[2] < 0 )
                        {
                                problems++;
                                logprintf( "extent negative " );
                        }
d236 1
a236 1
void os_args3( int *file, int extent )
d241 3
a243 3
        int old_pointer;
        int old_extent;
        int i;
d245 1
a245 1
        logprintf( "os_args 3( %d, %d ) ", *file, extent );
d250 1
a250 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d259 1
a259 1
        old_pointer = r.r[2];
d264 1
a264 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d273 1
a273 1
        old_extent = r.r[2];
d277 1
a277 1
        r.r[2] = extent;
d279 1
a279 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &newr );
d293 1
a293 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d300 1
a300 1
                else if ( extent != newr.r[2] )
d310 1
a310 1
                        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d330 1
a330 1
                        r.r[2] = old_extent;
d332 1
a332 1
                        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d340 2
a341 2
                                i < extent;
                                i++ )
d345 1
a345 1
                                err = _kernel_swi( XOS_Bit | OS_BGet, &r, &r );
d385 1
a385 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &newr );
d410 1
a410 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &newr );
d424 1
a424 1
void os_args6( int *file, int ensure )
d430 1
a430 1
        logprintf( "os_args 6( %d, %d ) ", *file, ensure );
d434 1
a434 1
        r.r[2] = ensure;
d436 1
a436 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &newr );
d461 1
a461 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &newr );
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

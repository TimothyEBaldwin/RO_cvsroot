head	4.2;
access;
symbols
	FileCore-3_75:4.2
	FileCore-3_74:4.2
	FileCore-3_73:4.2
	FileCore-3_72:4.2
	FileCore-3_71:4.2
	FileCore-3_70:4.2
	FileCore-3_69:4.2
	FileCore-3_68:4.2
	FileCore-3_67:4.2
	FileCore-3_66:4.2
	FileCore-3_65:4.2
	FileCore-3_64:4.2
	FileCore-3_63:4.2
	FileCore-3_62:4.2
	FileCore-3_61:4.2
	FileCore-3_60:4.2
	FileCore-3_59:4.2
	FileCore-3_58:4.2
	FileCore-3_57:4.2
	FileCore-3_56:4.2
	FileCore-3_55:4.1
	FileCore-3_54:4.1
	FileCore-3_53:4.1
	FileCore-3_52:4.1
	FileCore-3_51:4.1
	FileCore-3_50:4.1
	FileCore-3_49:4.1
	FileCore-3_48:4.1
	FileCore-3_47:4.1
	FileCore-3_46:4.1
	FileCore-3_45:4.1
	FileCore-3_44:4.1
	FileCore-3_43:4.1
	FileCore-3_42:4.1
	FileCore-3_41:4.1
	FileCore-3_40:4.1
	FileCore-3_39:4.1
	FileCore-3_38:4.1
	FileCore-3_37:4.1
	FileCore-3_36:4.1
	FileCore-3_35:4.1
	FileCore-3_34:4.1
	FileCore-3_33:4.1
	RO_5_07:4.1
	FileCore-3_32:4.1
	FileCore-3_31:4.1
	FileCore-3_30:4.1
	FileCore-3_29:4.1
	FileCore-3_28:4.1
	FileCore-3_25-4_9_2_2:4.1
	FileCore-3_27:4.1
	FileCore-3_26:4.1
	FileCore-3_22-4_6_2_1:4.1
	bavison_FileCore-3_22_dev_bp:4.1
	bavison_FileCore-3_22:4.1.0.14
	FileCore-3_25-4_9_2_1:4.1
	HAL:4.1.0.12
	FileCore-3_25:4.1
	FileCore-3_24:4.1
	FileCore-3_23:4.1
	dellis_autobuild_BaseSW:4.1
	FileCore-3_22:4.1
	Ursula_merge:4.1
	ROL_merge:4.1
	FileCore-3_21:4.1
	ROL_Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	ROL_FileCore-3_21:4.1
	ROL_FileCore-3_20:4.1
	ROL:4.1.0.10
	ROL_bp:4.1
	Ursula_RiscPC_bp:4.1
	FileCore-3_18:4.1
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1
	sproven_FileCore-3_16:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	sproven_FileCore-3_15:4.1
	sproven_314:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1
	sproven_3_11:4.1
	sproven_3_10:4.1
	sproven_Ursula_3_09:4.1
	sproven_3_07:4.1
	sproven_3_06:4.1
	sproven_3_05:4.1
	sproven_3_04:4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1
	sproven_3_02:4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	2013.02.24.21.09.03;	author rsprowson;	state Exp;
branches;
next	4.1;
commitid	rgJG8ZFRF8o9ruFw;

4.1
date	96.11.05.09.32.29;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.29;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.42.32;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.56;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.44;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "Tester.h"
#include "logger.h"


void os_gbpb2( int *file, unsigned int size )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        unsigned int old_sfp;
        unsigned int old_extent;
        unsigned int i;
        unsigned int new_sfp;
        unsigned int new_extent;

        logprintf( "os_gbpb 2( %d, %u ) ", *file, size );

        for ( i = 0;
              i < size;
              i++ )
        {
                random_data_area[ i ] = myrand() & 0xff;
                random_write_result[ i ] = myrand() & 0xff;
        }

        r.r[0] = 0;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading sequential file pointer at start\n" );
                return;
        }

        old_sfp = (int)r.r[2];

        r.r[0] = 2;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading extent at start\n" );
                return;
        }

        old_extent = (int)r.r[2];

        r.r[0] = 2;
        r.r[1] = *file;
        r.r[2] = (int)random_data_area;
        r.r[3] = (int)size;

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                if ( err->errnum == Error_NotOpenForUpdate )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );

                if ( newr.r[3] != 0 )
                {
                        problems++;
                        logprintf( "R3 not returned as 0:is %u ", newr.r[3] );
                }
                if ( newr.r[2] != (int)random_data_area + size )
                {
                        problems++;
                        logprintf( "address past last byte not returned in R2:is %x ", newr.r[2] );
                }
                new_sfp = (unsigned int)newr.r[4];
                if ( old_sfp + size - newr.r[3] != new_sfp )
                {
                        problems++;
                        logprintf( "new sequential file pointer not passed back in R4:is %u ", new_sfp );
                }
                r.r[0] = 0;
                r.r[1] = *file;
                err = _kernel_swi( OS_Args, &r, &r );
                if ( err )
                {
                        pout_error( err );
                        logprintf( "while reading sequential file pointer after operation " );
                }
                else if ( (unsigned int)r.r[2] != new_sfp )
                {
                        problems++;
                        logprintf( "read-back sequential file pointer not equal to new sequential file pointer returned:is %d ", r.r[2] );
                }

                new_extent = old_extent;
                if ( new_sfp > new_extent )
                        new_extent = new_sfp;

                r.r[0] = 2;
                r.r[1] = *file;
                err = _kernel_swi( OS_Args, &r, &r );
                if ( err )
                {
                        pout_error( err );
                        logprintf( "while reading new extent " );
                }
                else if ( (unsigned int)r.r[2] != new_extent )
                {
                        problems++;
                        logprintf( "read-back extent not correct:is %u ", r.r[2] );
                }

                r.r[0] = 3;
                r.r[1] = *file;
                r.r[2] = (int)random_write_result;
                r.r[3] = (int)size;
                r.r[4] = (int)old_sfp;

                err = _kernel_swi( OS_GBPB, &r, &r );

                if ( err )
                {
                        if ( err->errnum == Error_NotOpenForReading )
                        {
                                /* do nothing */
                        }
                        else
                        {
                                pout_error( err );
                                logprintf( "while reading back written data " );
                        }
                }
                else if ( memcmp( random_data_area, random_write_result, new_sfp - old_sfp ) != 0 )
                {
                        problems++;
                        logprintf( "data did not read back as written " );
                }
        }

        logprintf( "\n" );
}

void os_gbpb1( int *file, unsigned int size, unsigned int location )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        unsigned int old_extent;
        unsigned int i;
        unsigned int new_sfp;
        unsigned int new_extent;

        logprintf( "os_gbpb 1( %d, %u, %u ) ", *file, size, location );

        for ( i = 0;
              i < size;
              i++ )
        {
                random_data_area[ i ] = myrand() & 0xff;
                random_write_result[ i ] = myrand() & 0xff;
        }

        r.r[0] = 2;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading extent at start\n" );
                return;
        }

        old_extent = (unsigned int)r.r[2];

        r.r[0] = 1;
        r.r[1] = *file;
        r.r[2] = (int)random_data_area;
        r.r[3] = (int)size;
        r.r[4] = (int)location;

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                if ( err->errnum == Error_NotOpenForUpdate )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );

                if ( newr.r[3] != 0 )
                {
                        problems++;
                        logprintf( "R3 not returned as 0:is %u ", newr.r[3] );
                }
                if ( newr.r[2] != (int)random_data_area + size )
                {
                        problems++;
                        logprintf( "address past last byte not returned in R2:is %x ", newr.r[2] );
                }
                new_sfp = (unsigned int)newr.r[4];
                if ( location + size - newr.r[3] != new_sfp )
                {
                        problems++;
                        logprintf( "new sequential file pointer not passed back in R4:is %u ", new_sfp );
                }
                r.r[0] = 0;
                r.r[1] = *file;
                err = _kernel_swi( OS_Args, &r, &r );
                if ( err )
                {
                        pout_error( err );
                        logprintf( "while reading sequential file pointer after operation " );
                }
                else if ( r.r[2] != new_sfp )
                {
                        problems++;
                        logprintf( "read-back sequential file pointer not equal to new sequential file pointer returned:is %d ", r.r[2] );
                }

                new_extent = old_extent;
                if ( new_sfp > new_extent )
                        new_extent = new_sfp;

                r.r[0] = 2;
                r.r[1] = *file;
                err = _kernel_swi( OS_Args, &r, &r );
                if ( err )
                {
                        pout_error( err );
                        logprintf( "while reading new extent " );
                }
                else if ( (unsigned int)r.r[2] != new_extent )
                {
                        problems++;
                        logprintf( "read-back extent not correct:is %u ", r.r[2] );
                }

                r.r[0] = 3;
                r.r[1] = *file;
                r.r[2] = (int)random_write_result;
                r.r[3] = (int)size;
                r.r[4] = (int)location;

                err = _kernel_swi( OS_GBPB, &r, &r );

                if ( err )
                {
                        if ( err->errnum == Error_NotOpenForReading )
                        {
                                /* do nothing */
                        }
                        else
                        {
                                pout_error( err );
                                logprintf( "while reading back written data " );
                        }
                }
                else if ( memcmp( random_data_area, random_write_result, new_sfp - location ) != 0 )
                {
                        problems++;
                        logprintf( "data did not read back as written " );
                }

                if ( location > old_extent )
                {
                        r.r[0] = 3;
                        r.r[1] = *file;
                        r.r[2] = (int)random_write_result;
                        r.r[3] = (int)(location - old_extent);
                        r.r[4] = (int)old_extent;

                        err = _kernel_swi( OS_GBPB, &r, &r );

                        if ( err )
                        {
                                if ( err->errnum == Error_NotOpenForReading )
                                {
                                        /* do nothing */
                                }
                                else
                                {
                                        pout_error( err );
                                        logprintf( "while reading back zero-extention of file " );
                                }
                        }
                        else
                        {
                                for ( i = 0;
                                      i < location - old_extent;
                                      i++ )
                                {
                                        if ( random_write_result[ i ] != 0 )
                                        {
                                                problems++;
                                                logprintf( "zero extention of file is non-zero " );
                                                break;
                                        }
                                }
                        }
                }                
        }

        logprintf( "\n" );
}

void os_gbpb4( int *file, unsigned int size )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        unsigned int old_sfp;
        unsigned int old_extent;
        unsigned int new_sfp;
        unsigned int transfer_bytes;

        logprintf( "os_gbpb 4( %d, %u ) ", *file, size );

        r.r[0] = 0;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading sequential file pointer at start\n" );
                return;
        }

        old_sfp = (unsigned int)r.r[2];

        r.r[0] = 2;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading extent at start\n" );
                return;
        }

        old_extent = (unsigned int)r.r[2];

        r.r[0] = 4;
        r.r[1] = *file;
        r.r[2] = (int)random_data_area;
        r.r[3] = (int)size;

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                if ( err->errnum == Error_NotOpenForReading )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );

                transfer_bytes = size;
                if ( old_sfp + transfer_bytes > old_extent )
                {
                        transfer_bytes = old_extent - old_sfp;
                }

                if ( (unsigned int)newr.r[3] != size - transfer_bytes )
                {
                        problems++;
                        logprintf( "Bytes transferred not possible transfer size:is %u ", newr.r[3] );
                }
                if ( newr.r[2] != (int)random_data_area + transfer_bytes )
                {
                        problems++;
                        logprintf( "address past last byte not returned in R2:is %x ", newr.r[2] );
                }
                new_sfp = (unsigned int)newr.r[4];
                if ( old_sfp + size - newr.r[3] != new_sfp && old_sfp < old_extent && size > 0 )
                {
                        problems++;
                        logprintf( "new sequential file pointer not passed back in R4:is %u ", newr.r[4] );
                }
                r.r[0] = 0;
                r.r[1] = *file;
                err = _kernel_swi( OS_Args, &r, &r );
                if ( err )
                {
                        pout_error( err );
                        logprintf( "while reading sequential file pointer after operation " );
                }
                else if ( (unsigned int)r.r[2] != new_sfp && old_sfp < old_extent && size > 0 )
                {
                        problems++;
                        logprintf( "read-back sequential file pointer not equal to new sequential file pointer returned:is %d ", r.r[2] );
                }

                r.r[0] = 2;
                r.r[1] = *file;
                err = _kernel_swi( OS_Args, &r, &r );
                if ( err )
                {
                        pout_error( err );
                        logprintf( "while reading new extent " );
                }
                else if ( (unsigned int)r.r[2] != old_extent )
                {
                        problems++;
                        logprintf( "extent has changed:is %u ", r.r[2] );
                }
        }

        logprintf( "\n" );
}

void os_gbpb3( int *file, unsigned int size, unsigned int location )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        unsigned int old_extent;
        unsigned int old_sfp;
        unsigned int new_sfp;
        unsigned int transfer_bytes;

        logprintf( "os_gbpb 3( %d, %u, %u ) ", *file, size, location );

        r.r[0] = 0;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading sequential file pointer at start\n" );
                return;
        }

        old_sfp = (unsigned int)r.r[2];

        r.r[0] = 2;
        r.r[1] = *file;

        err = _kernel_swi( OS_Args, &r, &r );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading extent at start\n" );
                return;
        }

        old_extent = (unsigned int)r.r[2];

        r.r[0] = 3;
        r.r[1] = *file;
        r.r[2] = (int)random_data_area;
        r.r[3] = (int)size;
        r.r[4] = (int)location;

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                if ( err->errnum == Error_NotOpenForReading )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );

                if ( location >= old_extent )
                {
                        if ( newr.r[2] != (int)random_data_area )
                        {
                                problems++;
                                logprintf( "data destination pointer has been advanced when not bytes should have been transfered:is %x ", newr.r[2] );
                        }
                        if ( (unsigned int)newr.r[3] != size )
                        {
                                problems++;
                                logprintf( "location to transfer from is beyond end of file and the number of bytes not transfered is not equal to the requested transfer size: is %u ", r.r[3] );
                        }

                        r.r[0] = 0;
                        r.r[1] = *file;
                        err = _kernel_swi( OS_Args, &r, &r );
                        if ( err )
                        {
                                pout_error( err );
                                logprintf( "while reading sequential file pointer after operation " );
                        }
                        else if ( old_sfp != (unsigned int)r.r[2] )
                        {
                                problems++;
                                logprintf( "sequential file pointer has changed:is %d ", r.r[2] );
                        }
                }
                else
                {
                        transfer_bytes = size;
                        if ( location + transfer_bytes > old_extent )
                        {
                                transfer_bytes = old_extent - location;
                        }

                        if ( (unsigned int)newr.r[3] != size - transfer_bytes )
                        {
                                problems++;
                                logprintf( "Bytes transferred not possible transfer size:is %u ", newr.r[3] );
                        }
                        if ( newr.r[2] != (int)random_data_area + transfer_bytes )
                        {
                                problems++;
                                logprintf( "address past last byte not returned in R2:is %d ", newr.r[2] );
                        }
                        new_sfp = (unsigned int)newr.r[4];
                        if ( location + size - newr.r[3] != new_sfp && transfer_bytes > 0 )
                        {
                                problems++;
                                logprintf( "new sequential file pointer not passed back in R4:is %u ", newr.r[4] );
                        }
                        r.r[0] = 0;
                        r.r[1] = *file;
                        err = _kernel_swi( OS_Args, &r, &r );
                        if ( err )
                        {
                                pout_error( err );
                                logprintf( "while reading sequential file pointer after operation " );
                        }
                        else if ( (unsigned int)r.r[2] != new_sfp && transfer_bytes > 0 )
                        {
                                problems++;
                                logprintf( "read-back sequential file pointer not equal to new sequential file pointer returned:is %d ", r.r[2] );
                        }
                }

                r.r[0] = 2;
                r.r[1] = *file;
                err = _kernel_swi( OS_Args, &r, &r );
                if ( err )
                {
                        pout_error( err );
                        logprintf( "while reading new extent " );
                }
                else if ( (unsigned int)r.r[2] != old_extent )
                {
                        problems++;
                        logprintf( "extent has changed:is %u ", r.r[2] );
                }
        }

        logprintf( "\n" );
}


void os_gbpb5( void )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_gbpb 5() " );

        r.r[0] = 5;
        r.r[2] = (int)random_data_area;

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x5 );
        }

        logprintf( "\n" );
}


void os_gbpb6( void )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_gbpb 6() " );

        r.r[0] = 6;
        r.r[2] = (int)random_data_area;

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x5 );

                if ( random_data_area[0] != '\0' )
                {
                        problems++;
                        logprintf( "first byte isn't zero:is %d ", random_data_area[0] );
                }

                if ( random_data_area[ 2 + random_data_area[1] ] != 0 &&
                        random_data_area[ 2 + random_data_area[1] ] != 0xff )
                {
                        problems++;
                        logprintf( "privilege bytes isn't 0 or &ff:is %d ", random_data_area[ 2 + random_data_area[1] ] );
                }
        }

        logprintf( "\n" );
}


void os_gbpb7( void )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_gbpb 7() " );

        r.r[0] = 7;
        r.r[2] = (int)random_data_area;

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x5 );

                if ( random_data_area[0] != '\0' )
                {
                        problems++;
                        logprintf( "first byte isn't zero:is %d ", random_data_area[0] );
                }

                if ( random_data_area[ 2 + random_data_area[1] ] != 0 &&
                        random_data_area[ 2 + random_data_area[1] ] != 0xff )
                {
                        problems++;
                        logprintf( "privilege bytes isn't 0 or &ff:is %d ", random_data_area[ 2 + random_data_area[1] ] );
                }
        }

        logprintf( "\n" );
}


void os_gbpb8( int number )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_gbpb 8( %d ) ", number );

        r.r[0] = 8;
        r.r[2] = (int)random_data_area;
        r.r[3] = number;
        r.r[4] = 0;

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                if ( (err->errnum & FileError_Mask) == Error_DoesNotExist ||
                        err->errnum == Error_FSDoesNotExist )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x5 );
        }

        logprintf( "\n" );
}

void os_gbpb9( char *name, int number )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_gbpb 10( %s, %d ) ", name, number );

        r.r[0] = 9;
        r.r[1] = (int)name;
        r.r[2] = (int)random_data_area;
        r.r[3] = number;
        r.r[4] = 0;
        r.r[5] = sizeof(random_data_area);
        r.r[6] = (int)"*";

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x67 );
        }

        logprintf( "\n" );
}

void os_gbpb10( char *name, int number )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_gbpb 10( %s, %d ) ", name, number );

        r.r[0] = 10;
        r.r[1] = (int)name;
        r.r[2] = (int)random_data_area;
        r.r[3] = number;
        r.r[4] = 0;
        r.r[5] = sizeof(random_data_area);
        r.r[6] = (int)"*";

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x67 );
        }

        logprintf( "\n" );
}

void os_gbpb11( char *name, int number )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_gbpb 11( %s, %d ) ", name, number );

        r.r[0] = 11;
        r.r[1] = (int)name;
        r.r[2] = (int)random_data_area;
        r.r[3] = number;
        r.r[4] = 0;
        r.r[5] = sizeof(random_data_area);
        r.r[6] = (int)"*";

        err = _kernel_swi( OS_GBPB, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x67 );
        }

        logprintf( "\n" );
}
@


4.1
log
@Initial revision
@
text
@d23 1
a23 1
void os_gbpb2( int *file, int size )
d28 5
a32 5
        int old_sfp;
        int old_extent;
        int i;
        int new_sfp;
        int new_extent;
d34 1
a34 1
        logprintf( "os_gbpb 2( %d, %d ) ", *file, size );
d37 2
a38 2
                i < size;
                i++ )
d47 1
a47 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d56 1
a56 1
        old_sfp = r.r[2];
d61 1
a61 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d70 1
a70 1
        old_extent = r.r[2];
d75 1
a75 1
        r.r[3] = size;
d77 1
a77 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d97 1
a97 1
                        logprintf( "R3 not returned as 0:is %d ", newr.r[3] );
d102 1
a102 1
                        logprintf( "address past last byte not returned in R2:is %d ", newr.r[2] );
d104 1
a104 1
                new_sfp = newr.r[4];
d108 1
a108 1
                        logprintf( "new sequential file pointer not passed back in R4:is %d ", new_sfp );
d112 1
a112 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d118 1
a118 1
                else if ( r.r[2] != new_sfp )
d130 1
a130 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d136 1
a136 1
                else if ( r.r[2] != new_extent )
d139 1
a139 1
                        logprintf( "read-back extent not correct:is %d ", r.r[2] );
d145 2
a146 2
                r.r[3] = size;
                r.r[4] = old_sfp;
d148 1
a148 1
                err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &r );
d172 1
a172 1
void os_gbpb1( int *file, int size, int location )
d177 4
a180 4
        int old_extent;
        int i;
        int new_sfp;
        int new_extent;
d182 1
a182 1
        logprintf( "os_gbpb 1( %d, %d, %d ) ", *file, size, location );
d185 2
a186 2
                i < size;
                i++ )
d195 1
a195 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d204 1
a204 1
        old_extent = r.r[2];
d209 2
a210 2
        r.r[3] = size;
        r.r[4] = location;
d212 1
a212 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d232 1
a232 1
                        logprintf( "R3 not returned as 0:is %d ", newr.r[3] );
d237 1
a237 1
                        logprintf( "address past last byte not returned in R2:is %d ", newr.r[2] );
d239 1
a239 1
                new_sfp = newr.r[4];
d243 1
a243 1
                        logprintf( "new sequential file pointer not passed back in R4:is %d ", new_sfp );
d247 1
a247 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d265 1
a265 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d271 1
a271 1
                else if ( r.r[2] != new_extent )
d274 1
a274 1
                        logprintf( "read-back extent not correct:is %d ", r.r[2] );
d280 2
a281 2
                r.r[3] = size;
                r.r[4] = location;
d283 1
a283 1
                err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &r );
d308 2
a309 2
                        r.r[3] = location - old_extent;
                        r.r[4] = old_extent;
d311 1
a311 1
                        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &r );
d328 2
a329 2
                                        i < location - old_extent;
                                        i++ )
d345 1
a345 1
void os_gbpb4( int *file, int size )
d350 4
a353 4
        int old_sfp;
        int old_extent;
        int new_sfp;
        int transfer_bytes;
d355 1
a355 1
        logprintf( "os_gbpb 4( %d, %d ) ", *file, size );
d360 1
a360 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d369 1
a369 1
        old_sfp = r.r[2];
d374 1
a374 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d383 1
a383 1
        old_extent = r.r[2];
d388 1
a388 1
        r.r[3] = size;
d390 1
a390 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d413 1
a413 1
                if ( newr.r[3] != size - transfer_bytes )
d416 1
a416 1
                        logprintf( "Bytes transferes not possible transfer size:is %d ", newr.r[3] );
d421 1
a421 1
                        logprintf( "address past last byte not returned in R2:is %d ", newr.r[2] );
d423 1
a423 1
                new_sfp = newr.r[4];
d427 1
a427 1
                        logprintf( "new sequential file pointer not passed back in R4:is %d ", newr.r[4] );
d431 1
a431 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d437 1
a437 1
                else if ( r.r[2] != new_sfp && old_sfp < old_extent && size > 0 )
d445 1
a445 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d451 1
a451 1
                else if ( r.r[2] != old_extent )
d454 1
a454 1
                        logprintf( "extent has changed:is %d ", r.r[2] );
d461 1
a461 1
void os_gbpb3( int *file, int size, int location )
d466 4
a469 4
        int old_extent;
        int old_sfp;
        int new_sfp;
        int transfer_bytes;
d471 1
a471 1
        logprintf( "os_gbpb 3( %d, %d, %d ) ", *file, size, location );
d476 1
a476 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d485 1
a485 1
        old_sfp = r.r[2];
d490 1
a490 1
        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d499 1
a499 1
        old_extent = r.r[2];
d504 2
a505 2
        r.r[3] = size;
        r.r[4] = location;
d507 1
a507 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d529 1
a529 1
                                logprintf( "data destination pointer has been advanced when not bytes should have been transfered:is %d ", newr.r[2] );
d531 1
a531 1
                        if ( newr.r[3] != size )
d534 1
a534 1
                                logprintf( "location to transfer from is beyond end of file and the number of bytes not transfered is not equal to the requested transfer size: is %d ", r.r[3] );
d539 1
a539 1
                        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d545 1
a545 1
                        else if ( old_sfp != r.r[2] )
d559 1
a559 1
                        if ( newr.r[3] != size - transfer_bytes )
d562 1
a562 1
                                logprintf( "Bytes transferes not possible transfer size:is %d ", newr.r[3] );
d569 1
a569 1
                        new_sfp = newr.r[4];
d573 1
a573 1
                                logprintf( "new sequential file pointer not passed back in R4:is %d ", newr.r[4] );
d577 1
a577 1
                        err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d583 1
a583 1
                        else if ( r.r[2] != new_sfp && transfer_bytes > 0 )
d592 1
a592 1
                err = _kernel_swi( XOS_Bit | OS_Args, &r, &r );
d598 1
a598 1
                else if ( r.r[2] != old_extent )
d601 1
a601 1
                        logprintf( "extent has changed:is %d ", r.r[2] );
d620 1
a620 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d646 1
a646 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d685 1
a685 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d726 1
a726 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d761 1
a761 1
        r.r[5] = 50000;
d764 1
a764 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d791 1
a791 1
        r.r[5] = 50000;
d794 1
a794 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
d821 1
a821 1
        r.r[5] = 50000;
d824 1
a824 1
        err = _kernel_swi( XOS_Bit | OS_GBPB, &r, &newr );
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

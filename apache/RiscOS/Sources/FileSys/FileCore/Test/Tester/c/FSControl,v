head	4.2;
access;
symbols
	FileCore-3_75:4.2
	FileCore-3_74:4.2
	FileCore-3_73:4.2
	FileCore-3_72:4.2
	FileCore-3_71:4.2
	FileCore-3_70:4.2
	FileCore-3_69:4.2
	FileCore-3_68:4.2
	FileCore-3_67:4.2
	FileCore-3_66:4.2
	FileCore-3_65:4.2
	FileCore-3_64:4.2
	FileCore-3_63:4.2
	FileCore-3_62:4.2
	FileCore-3_61:4.2
	FileCore-3_60:4.2
	FileCore-3_59:4.2
	FileCore-3_58:4.2
	FileCore-3_57:4.2
	FileCore-3_56:4.2
	FileCore-3_55:4.1
	FileCore-3_54:4.1
	FileCore-3_53:4.1
	FileCore-3_52:4.1
	FileCore-3_51:4.1
	FileCore-3_50:4.1
	FileCore-3_49:4.1
	FileCore-3_48:4.1
	FileCore-3_47:4.1
	FileCore-3_46:4.1
	FileCore-3_45:4.1
	FileCore-3_44:4.1
	FileCore-3_43:4.1
	FileCore-3_42:4.1
	FileCore-3_41:4.1
	FileCore-3_40:4.1
	FileCore-3_39:4.1
	FileCore-3_38:4.1
	FileCore-3_37:4.1
	FileCore-3_36:4.1
	FileCore-3_35:4.1
	FileCore-3_34:4.1
	FileCore-3_33:4.1
	RO_5_07:4.1
	FileCore-3_32:4.1
	FileCore-3_31:4.1
	FileCore-3_30:4.1
	FileCore-3_29:4.1
	FileCore-3_28:4.1
	FileCore-3_25-4_9_2_2:4.1
	FileCore-3_27:4.1
	FileCore-3_26:4.1
	FileCore-3_22-4_6_2_1:4.1
	bavison_FileCore-3_22_dev_bp:4.1
	bavison_FileCore-3_22:4.1.0.14
	FileCore-3_25-4_9_2_1:4.1
	HAL:4.1.0.12
	FileCore-3_25:4.1
	FileCore-3_24:4.1
	FileCore-3_23:4.1
	dellis_autobuild_BaseSW:4.1
	FileCore-3_22:4.1
	Ursula_merge:4.1
	ROL_merge:4.1
	FileCore-3_21:4.1
	ROL_Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	ROL_FileCore-3_21:4.1
	ROL_FileCore-3_20:4.1
	ROL:4.1.0.10
	ROL_bp:4.1
	Ursula_RiscPC_bp:4.1
	FileCore-3_18:4.1
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1
	sproven_FileCore-3_16:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	sproven_FileCore-3_15:4.1
	sproven_314:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1
	sproven_3_11:4.1
	sproven_3_10:4.1
	sproven_Ursula_3_09:4.1
	sproven_3_07:4.1
	sproven_3_06:4.1
	sproven_3_05:4.1
	sproven_3_04:4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1
	sproven_3_02:4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	2013.02.24.21.09.03;	author rsprowson;	state Exp;
branches;
next	4.1;
commitid	rgJG8ZFRF8o9ruFw;

4.1
date	96.11.05.09.32.29;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.29;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.42.30;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.34.55;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.43;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include "kernel.h"
#include "swis.h"
#include "tester.h"
#include "logger.h"

void os_fscontrol0( char *name )
{
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        _kernel_oserror *err;

        logprintf( "os_fscontrol 0( \"%s\" ) ", name );

        r.r[0] = 0;
        r.r[1] = (int)name;

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );

                logprintf( "\nCatalogue of current directory:\n" );

                r.r[0] = 5;
                r.r[1] = (int)"";
                err = _kernel_swi( OS_FSControl, &r, &r );
                if ( err )
                {
                        pout_error( err );
                        logprintf( "while trying to catalogue current directory\n" );
                        return;
                }

                logprintf( "Catalogue of \"%s\":\n", name );

                r.r[0] = 5;
                r.r[1] = (int)name;

                err = _kernel_swi( OS_FSControl, &r, &r );

                if ( err )
                {
                        pout_error( err );
                        logprintf( "while trying to catalogue directory by name" );
                }
        }

        logprintf( "\n" );
}

void os_fscontrol1( char *name )
{
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        _kernel_oserror *err;

        logprintf( "os_fscontrol 1( \"%s\" ) ", name );

        r.r[0] = 1;
        r.r[1] = (int)name;

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x3 );

                logprintf( "\nCatalogue of library directory:\n" );

                r.r[0] = 5;
                r.r[1] = (int)"%";
                err = _kernel_swi( OS_FSControl, &r, &r );
                if ( err )
                {
                        pout_error( err );
                        logprintf( "while trying to catalogue library directory\n" );
                        return;
                }

                logprintf( "Catalogue of \"%s\":\n", name );

                r.r[0] = 5;
                r.r[1] = (int)name;

                err = _kernel_swi( OS_FSControl, &r, &r );

                if ( err )
                {
                        pout_error( err );
                        logprintf( "while trying to catalogue directory by name" );
                }
        }

        logprintf( "\n" );
}

void os_fscontrol5( char *name )
{
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        _kernel_oserror *err;

        logprintf( "os_fscontrol 5( \"%s\" ) ", name );

        r.r[0] = 5;
        r.r[1] = (int)name;

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                if ( err->errnum == Error_NotFound )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        logprintf( "\n" );
}

void os_fscontrol6( char *name )
{
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        _kernel_oserror *err;

        logprintf( "os_fscontrol 6( \"%s\" ) ", name );

        r.r[0] = 6;
        r.r[1] = (int)name;

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                if ( err->errnum == Error_NotFound )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        logprintf( "\n" );
}

void os_fscontrol7( void )
{
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        _kernel_oserror *err;

        logprintf( "os_fscontrol 7() " );

        r.r[0] = 7;
        r.r[1] = (int)"";

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                if ( err->errnum == ErrorNumber_NFS_directory_unset ||
                        err->errnum == Error_NotFound )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        logprintf( "\n" );
}

void os_fscontrol8( void )
{
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        _kernel_oserror *err;

        logprintf( "os_fscontrol 8() " );

        r.r[0] = 8;
        r.r[1] = (int)"";

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                if ( err->errnum == ErrorNumber_NFS_directory_unset ||
                        err->errnum == Error_NotFound )
                {
                        /* do nothing */
                }
                else
                {
                        pout_error( err );
                }
        }
        logprintf( "\n" );
}

void os_fscontrol9( char *file )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_fscontrol 9( \"%s\" ) ", file );

        r.r[0] = 9;
        r.r[1] = (int)file;

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x1 );
        }

        logprintf( "\n" );
}

void os_fscontrol24( char *file, char *opts )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_fscontrol 24( \"%s\", \"%s\" ) ", file, opts );

        r.r[0] = 24;
        r.r[1] = (int)file;
        r.r[2] = (int)opts;

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                switch ( err->errnum & FileError_Mask )
                {
                case Error_FSAccessViolation:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x7 );
        }

        logprintf( "\n" );
}

void os_fscontrol25( char *from, char *to )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;
        _kernel_swi_regs oldattrs;

        logprintf( "os_fscontrol 25( \"%s\", \"%s\" ) ", from, to );

        r.r[0] = 17;
        r.r[1] = (int)from;

        err = _kernel_swi( OS_File, &r, &oldattrs );

        if ( err )
        {
                pout_error( err );
                logprintf( "while reading old attributes of object\n" );

                return;
        }

        r.r[0] = 25;
        r.r[1] = (int)from;
        r.r[2] = (int)to;

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                switch ( err->errnum & FileError_Mask )
                {
                case Error_FSLocked:
                case Error_BadRENAME:
                case Error_Locked:
                case Error_FileOpen:
                case Error_FSAccessViolation:
                case Error_DirectoryFull:
                case Error_NotSameDisc:
                        break;

                default:
                        pout_error( err );
                        break;
                }
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x7 );

                r.r[0] = 17;
                r.r[1] = (int)from;

                err = _kernel_swi( OS_File, &r, &r );

                if ( (!err && r.r[0] != 0) ||
                        (err && err->errnum != Error_NotFound) )
                {
                        problems++;
                        logprintf( "renameing from still exists " );
                }

                r.r[0] = 17;
                r.r[1] = (int)to;

                err = _kernel_swi( OS_File, &r, &r );

                if ( err || (!err && r.r[0] == 0) )
                {
                        problems++;
                        logprintf( "renaming to doesn't exist " );
                }
                else
                {
                        if ( r.r[2] != oldattrs.r[2] )
                        {
                                problems++;
                                logprintf( "load address changed (%#010x to %#010x) ", oldattrs.r[2], r.r[2] );
                        }
                        if ( r.r[3] != oldattrs.r[3] )
                        {
                                problems++;
                                logprintf( "execute address changed (%#010x to %#010x) ", oldattrs.r[3], r.r[3] );
                        }
                        if ( r.r[4] != oldattrs.r[4] )
                        {
                                problems++;
                                logprintf( "length changed (%u to %u) ", oldattrs.r[4], r.r[4] );
                        }
                        if ( r.r[5] != oldattrs.r[5] )
                        {
                                problems++;
                                logprintf( "attributes changed (%#010x to %#010x) ", oldattrs.r[5], r.r[5] );
                        }
                }
        }

        logprintf( "\n" );
}

void os_fscontrol32( char *file )
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        _kernel_swi_regs newr;

        logprintf( "os_fscontrol 32( \"%s\" ) ", file );

        r.r[0] = 32;
        r.r[1] = (int)file;

        err = _kernel_swi( OS_FSControl, &r, &newr );

        if ( err )
        {
                pout_error( err );
        }
        else
        {
                check_regs_unchanged( &r, &newr, 0x1 );
        }

        logprintf( "\n" );
}
@


4.1
log
@Initial revision
@
text
@d32 1
a32 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
d46 1
a46 1
                err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &r );
d59 1
a59 1
                err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &r );
d82 1
a82 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
d96 1
a96 1
                err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &r );
d109 1
a109 1
                err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &r );
d132 1
a132 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
d159 1
a159 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
d186 1
a186 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
d214 1
a214 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
d242 1
a242 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
d268 1
a268 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
d302 1
a302 1
        err = _kernel_swi( XOS_Bit | OS_File, &r, &oldattrs );
d316 1
a316 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
d343 1
a343 1
                err = _kernel_swi( XOS_Bit | OS_File, &r, &r );
d355 1
a355 1
                err = _kernel_swi( XOS_Bit | OS_File, &r, &r );
d360 1
a360 1
                        logprintf( "renameing to doesn't exist " );
d377 1
a377 1
                                logprintf( "length changed (%d to %d) ", oldattrs.r[4], r.r[4] );
d401 1
a401 1
        err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &newr );
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

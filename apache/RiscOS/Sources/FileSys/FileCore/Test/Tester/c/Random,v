head	4.4;
access;
symbols
	FileCore-3_75:4.4
	FileCore-3_74:4.4
	FileCore-3_73:4.4
	FileCore-3_72:4.4
	FileCore-3_71:4.4
	FileCore-3_70:4.4
	FileCore-3_69:4.4
	FileCore-3_68:4.4
	FileCore-3_67:4.4
	FileCore-3_66:4.4
	FileCore-3_65:4.4
	FileCore-3_64:4.4
	FileCore-3_63:4.3
	FileCore-3_62:4.3
	FileCore-3_61:4.3
	FileCore-3_60:4.3
	FileCore-3_59:4.3
	FileCore-3_58:4.3
	FileCore-3_57:4.3
	FileCore-3_56:4.3
	FileCore-3_55:4.2
	FileCore-3_54:4.2
	FileCore-3_53:4.2
	FileCore-3_52:4.2
	FileCore-3_51:4.2
	FileCore-3_50:4.2
	FileCore-3_49:4.2
	FileCore-3_48:4.2
	FileCore-3_47:4.2
	FileCore-3_46:4.2
	FileCore-3_45:4.2
	FileCore-3_44:4.2
	FileCore-3_43:4.2
	FileCore-3_42:4.2
	FileCore-3_41:4.2
	FileCore-3_40:4.2
	FileCore-3_39:4.2
	FileCore-3_38:4.2
	FileCore-3_37:4.2
	FileCore-3_36:4.2
	FileCore-3_35:4.2
	FileCore-3_34:4.2
	FileCore-3_33:4.2
	RO_5_07:4.2
	FileCore-3_32:4.2
	FileCore-3_31:4.2
	FileCore-3_30:4.2
	FileCore-3_29:4.2
	FileCore-3_28:4.2
	FileCore-3_25-4_9_2_2:4.2
	FileCore-3_27:4.2
	FileCore-3_26:4.2
	FileCore-3_22-4_6_2_1:4.2
	bavison_FileCore-3_22_dev_bp:4.2
	bavison_FileCore-3_22:4.2.0.4
	FileCore-3_25-4_9_2_1:4.2
	HAL:4.2.0.2
	FileCore-3_25:4.2
	FileCore-3_24:4.2
	FileCore-3_23:4.2
	dellis_autobuild_BaseSW:4.2
	FileCore-3_22:4.2
	Ursula_merge:4.1.4.1
	ROL_merge:4.1.10.1
	FileCore-3_21:4.2
	ROL_Ursula_merge:4.1.10.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	ROL_FileCore-3_21:4.1.10.1
	ROL_FileCore-3_20:4.1.10.1
	ROL:4.1.0.10
	ROL_bp:4.1
	Ursula_RiscPC_bp:4.1
	FileCore-3_18:4.1
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1
	sproven_FileCore-3_16:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	sproven_FileCore-3_15:4.1
	sproven_314:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1
	sproven_3_11:4.1
	sproven_3_10:4.1
	sproven_Ursula_3_09:4.1
	sproven_3_07:4.1
	sproven_3_06:4.1
	sproven_3_05:4.1
	sproven_3_04:4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1
	sproven_3_02:4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2014.08.29.18.36.23;	author jlee;	state Exp;
branches;
next	4.3;
commitid	hZOslhvPTouNShOx;

4.3
date	2013.02.24.21.09.03;	author rsprowson;	state Exp;
branches;
next	4.2;
commitid	rgJG8ZFRF8o9ruFw;

4.2
date	2000.05.09.11.36.47;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.30;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1
	4.1.10.1;
next	;

4.1.1.1
date	96.11.05.09.32.30;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.42.39;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	2000.05.09.10.55.17;	author sbrodie;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.35.01;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.31.47;	author nturton;	state Exp;
branches;
next	;

4.1.10.1
date	99.08.24.12.41.13;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Fix off-by-one error in FSBash
Detail:
  Test/Tester/c/Random - Fix random_path_root() reading off the end of the array when myrand() returns its max value
Admin:
  Tested on BB-xM with high processor vectors


Version 3.64. Retagged as 'FileCore-3_64'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "Tester.h"
#include "logger.h"
#include "mymalloc.h"

OpenFile open_files[ NumberOfOpenFiles ];
static int memory_budget = 0;

#define RANDOM_NAME_LENGTH 50
#define RANDOM_DIR_SIZE 256

static char validchars[] =
{
"zxcvbnm,as"
"dfghjkl;]q"
"wertyuiop["
"_123456789"
"0-`ZXCVBNM"
"ASDFGHJKL+"
"}QWERTYUIO"
"P{!?'()=~" };

int myrand( void )
{
        return rand() & 0xfff;
}

static int exists( char *name )
{
        _kernel_swi_regs r;

        r.r[0] = 17;
        r.r[1] = (int)name;

        if ( _kernel_swi( OS_File, &r, &r ))
                return 0;
        else
                return r.r[0] != 0;
}

char *random_filename( void )
{
        int i;
        int len = 1 + (myrand() * RANDOM_NAME_LENGTH) / 0x1000;
        char *res = mymalloc( len + 1 );

        for ( i = 0;
              i < len;
              i++ )
                res[i] = validchars[ (myrand() * 79) / 0x1000 ];

        res[len] = '\0';

        return res;
}

int random_attributes( void )
{
        return rand() & 0x3b;
}

static char *random_path_root( void )
{
        return path_roots[ myrand() * number_of_paths / 0x1000 ];
}

/*
        Find a random specific object in a directory
        If x_type is 0 then any object matches
*/
static char *random_x_in_directory( char *in_dir, int x_type )
{
        char *tt;
        char dirbuffer[ 5000 ];
        _kernel_swi_regs r;
        char *rover;
        int countdown;
        int entsleft;
        int totthings;
        int i;

        r.r[0] = 10;
        r.r[1] = (int)in_dir;
        r.r[2] = (int)dirbuffer;
        r.r[3] = sizeof(dirbuffer);
        r.r[4] = 0;
        r.r[5] = sizeof(dirbuffer);
        r.r[6] = (int)"*";

        if ( _kernel_swi( OS_GBPB, &r, &r ) )
        {
                return NULL;
        }

        entsleft = r.r[3];

        /*
                Count how many things of the given type we've got
        */
        rover = dirbuffer;
        totthings = 0;
        for ( i = 0; i < entsleft; i++ )
        {
                if ( x_type == 0 || *(int *)&rover[16] == x_type )
                        totthings++;

                /*
                        Step onto the next entry
                */
                rover += 20 + strlen( &rover[ 20 ] ) + 1;
                rover = (char *)((((int)rover + 3) / 4) * 4);
        }

        /*
                If none there return NULL
        */
        if ( totthings == 0 )
                return NULL;

        /*
                Choose which one we're gooing to return
        */
        countdown = (totthings * myrand()) / 0x1000;

        /*
                Find it
        */
        rover = dirbuffer;
        for ( i = 0; i < entsleft; i++ )
        {
                if ( (x_type == 0 || *(int *)&rover[16] == x_type) && countdown-- == 0 )
                {
                        tt = mymalloc( strlen( &rover[20] )+1 );
                        strcpy( tt, &rover[20] );
                        return tt;
                }

                /*
                        Step onto the next entry
                */
                rover += 20 + strlen( &rover[ 20 ] ) + 1;
                rover = (char *)((((int)rover + 3) / 4) * 4);
        }

        /*
                If we're here, then we've got problems!
        */
        return NULL;
}

/*
        Find a random directory from those that exist
*/
char *random_directory( void )
{
        char *rpr;
        char *ac;
        char *randleaf;
        char *tm;
        _kernel_swi_regs r;

        /*
                Start the ball rolling
        */
        rpr = random_path_root();
        ac = mymalloc( strlen( rpr ) + 1 );
        strcpy( ac, rpr );

        if ( !exists( ac ) )
        {
                /*
                        *CDIR the directory
                */
                r.r[0] = 8;
                if ( _kernel_swi( OS_File, &r, &r ) )
                {
                        free( ac );
                        return NULL;
                }
        }


        while( myrand() > nest_probability )
        {
                randleaf = random_x_in_directory( ac, 2 );

                if ( !randleaf )
                        return ac;

                /*
                        tack the new dir onto the end of ac
                */
                tm = mymalloc( strlen( ac ) + 1 + strlen( randleaf ) + 1 );
                sprintf( tm, "%s.%s", ac, randleaf );
                myfree( ac );
                myfree( randleaf );
                ac = tm;
        }

        return ac;
}

static char *random_x( int x_type )
{
        char *ac = random_directory();
        char *tm;
        char *randleaf;

        if ( !ac )
                return NULL;

        randleaf = random_x_in_directory( ac, x_type );
        if ( randleaf == NULL )
        {
                myfree( ac );
                return NULL;
        }

        tm = mymalloc( strlen( ac ) + 1 + strlen( randleaf ) + 1 );
        sprintf( tm, "%s.%s", ac, randleaf );
        myfree( ac );
        myfree( randleaf );

        return tm;
}

char *random_file( void )
{
        return random_x( 1 );
}

char *random_object( void )
{
        return random_x( 0 );
}

char *new_random_path( void )
{
        char *tm = random_directory();
        char *tm2;
        char *name;

        if ( tm == NULL )
        {
                /*
                        re-create the root directory (oops!)
                */
                os_file8( random_path_root(), 0 );
                return new_random_path();
        }

        tm2 = random_filename();

        name = mymalloc( strlen( tm ) + 1 + strlen( tm2 ) + 1 );

        sprintf( name, "%s.%s", tm, tm2 );

        myfree( tm );
        myfree( tm2 );

        if ( exists( name ))
        {
                myfree( name );
                return new_random_path();
        }

        return name;
}

OpenFile *random_open( void )
{
        int open_file_number = (myrand() * NumberOfOpenFiles) / 0x1000;

        return &open_files[ open_file_number ];
}

void close_open( OpenFile *f )
{
        _kernel_swi_regs r;

        r.r[0] = 0;
        r.r[1] = f->file;

        _kernel_swi( OS_Find, &r, &r );

        f->file = 0;
        memory_budget -= strlen( f->name ) + 1;
        myfree( f->name );
}

int *random_closed( void )
{
        OpenFile *f = random_open();

        if ( f->file != 0 )
        {
                close_open( f );
        }

        return &f->file;
}

void ensure_closed( char *name )
{
        int i;
        char *leafend = strrchr( name, '.' );
        char *test_leafend;

        if ( leafend == NULL )
                leafend = name;

        for ( i = 0;
              i < NumberOfOpenFiles;
              i++ )
        {
                if ( open_files[ i ].file )
                {
                        test_leafend = strrchr( open_files[ i ].name, '.' );
                        if ( test_leafend == NULL )
                                test_leafend = open_files[ i ].name;

                        if ( strcmp( leafend, test_leafend ) == 0 )
                        {
                                close_open( &open_files[ i ] );
                        }
                }
        }
}

int *random_open_file( void )
{
        OpenFile *f = random_open();

        if ( f->file == 0 )
        {
                _kernel_swi_regs r;
                _kernel_oserror *err;

                f->name = random_file();

                if ( !f->name )
                        return NULL;

                ensure_closed( f->name );

                r.r[0] = 0xcf;
                r.r[1] = (int)f->name;

                err = _kernel_swi( OS_Find, &r, &r );

                if ( !err )
                {
                        f->file = r.r[0];
                        logprintf( "\nFile %d is \"%s\"\n", f->file, f->name );
                }
                else
                {
                        logprintf( "%s failed to open due to %s (%#x)\n", f->name, err->errmess, err->errnum );
                        myfree( f->name );
                        return NULL;
                }

                memory_budget += strlen( f->name ) + 1;
        }

        return &f->file;
}

char *random_closed_file( void )
{
        char *name;

        name = random_file();

        if ( name )
        {
                ensure_closed( name );
        }

        return name;
}

char *random_closed_object( void )
{
        char *name;

        name = random_object();

        if ( name )
        {
                ensure_closed( name );
        }

        return name;
}

char *random_attribs( void )
{
        char *result = mymalloc( 20 );
        int ctrl = myrand();

        result[0] = '\0';

        if ( result )
        {
                if ( ctrl & 1 )
                {
                        strcat( result, "l" );
                }
                if ( ctrl & 2 )
                {
                        strcat( result, "r" );
                }
                if ( ctrl & 4 )
                {
                        strcat( result, "w" );
                }
                if ( ctrl & 8 )
                {
                        strcat( result, "/" );
                        if ( ctrl & 16 )
                        {
                                strcat( result, "r" );
                        }
                        if ( ctrl & 32 )
                        {
                                strcat( result, "w" );
                        }
                }
        }

        return result;
}
@


4.3
log
@Extend upper permissable file size to 4GB-1
Tested for ~200,000 cycles in various configurations with FSBash, with no integrity problems, nor bad maps. However, background transfers (currently only used by ADFS) is still being endurance tested, hence is currently disabled.
Users should note that they can create big files without needing to reformat their drives, however if reverting to an older copy of FileCore the files must not be opened, loaded, or deleted (it's fine to view the directory, just don't expect old FileCore to know how to parse such long fragment runs).
Current versions of DiscKnight (1.49) do not understand long fragment runs.

FSBash
------
* Reviewed and expunged various signed comparisons of file pointers in the existing tests
* Added new tests for big files which attempt to aggrevate all the usual problems passing over and up to important boundaries
* Makefile recreated from fragments
* Some compiler warning squashed

Docs
----
* Some notes added for big file support

Misc
----
Commands: swapped to using Command macro
HelpText: labels renamed to help Command macro
GenSWIs: text table name for SectorDiscOp ammended to match exported header and corresponding secondary module names (ADFS_SectorDiscOp et al). The usefulness of calling the base instantiation of FileCore_SectorDiscOp is minimal, especially from BASIC.
Messages: message for attempting to check an old map disc made less terse
hdr/FileCore: typo

Version 3.56. Tagged as 'FileCore-3_56'
@
text
@d82 1
a82 1
        return path_roots[ myrand() * number_of_paths / 0xfff ];
@


4.2
log
@  Merge of Ursula branch to the trunk.
Detail:
  This module represents the latest version of FileCore incorporating
    both the Ursula changes and the ROL changes as we have them to date.
  Changes from ROL-FileCore-3_21 are basically the stripping of trailling
    spaces and the change of Version to Module_Version in the conditionals.
    No other changes.
Admin:
  ROL branch tagged ROL_merge
  Ursula branch tagged Ursula_merge.
  Untested, but essentially the same as ROL-FileCore-3_21, so no problems
    expected.

Version 3.21. Tagged as 'FileCore-3_21'
@
text
@d25 1
a25 1
int memory_budget = 0;
d46 1
a46 1
int exists( char *name )
d53 1
a53 1
        if ( _kernel_swi( XOS_Bit | OS_File, &r, &r ))
d66 2
a67 2
                i < len;
                i++ )
d80 1
a80 1
char *random_path_root( void )
d89 1
a89 1
char *random_x_in_directory( char *in_dir, int x_type )
d103 1
a103 1
        r.r[3] = 5000;
d105 1
a105 1
        r.r[5] = 5000;
d108 1
a108 1
        if ( _kernel_swi( XOS_Bit | OS_GBPB, &r, &r ) )
d193 1
a193 1
                if ( _kernel_swi( XOS_Bit | OS_File, &r, &r ) )
d221 1
a221 1
char *random_x( int x_type )
d302 1
a302 1
        _kernel_swi( XOS_Bit | OS_Find, &r, &r );
d331 2
a332 2
                i < NumberOfOpenFiles;
                i++ )
d367 1
a367 1
                err = _kernel_swi( XOS_Bit | OS_Find, &r, &r );
@


4.1
log
@Initial revision
@
text
@d27 3
d62 1
a62 1
        int len = 1 + (myrand() * 10) / 0x1000;
@


4.1.4.1
log
@  Merge of ROL branch to the Ursula branch.
Admin:
  Lots of bugfixes - see ROL branch logs for details.
@
text
@a26 3
#define RANDOM_NAME_LENGTH 50
#define RANDOM_DIR_SIZE 256

d59 1
a59 1
        int len = 1 + (myrand() * RANDOM_NAME_LENGTH) / 0x1000;
@


4.1.10.1
log
@  Import of RISC OS Ltd version of FileCore.
Admin:
  These sources are imported for interest only and must NOT be merged
    without wide prior consultation.

Tagged as ROL_FileCore-3_20
@
text
@a26 3
#define RANDOM_NAME_LENGTH 50
#define RANDOM_DIR_SIZE 256

d59 1
a59 1
        int len = 1 + (myrand() * RANDOM_NAME_LENGTH) / 0x1000;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

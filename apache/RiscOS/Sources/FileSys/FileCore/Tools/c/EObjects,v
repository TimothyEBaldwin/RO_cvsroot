head	4.1;
access;
symbols
	FileCore-3_75:4.1
	FileCore-3_74:4.1
	FileCore-3_73:4.1
	FileCore-3_72:4.1
	FileCore-3_71:4.1
	FileCore-3_70:4.1
	FileCore-3_69:4.1
	FileCore-3_68:4.1
	FileCore-3_67:4.1
	FileCore-3_66:4.1
	FileCore-3_65:4.1
	FileCore-3_64:4.1
	FileCore-3_63:4.1
	FileCore-3_62:4.1
	FileCore-3_61:4.1
	FileCore-3_60:4.1
	FileCore-3_59:4.1
	FileCore-3_58:4.1
	FileCore-3_57:4.1
	FileCore-3_56:4.1
	FileCore-3_55:4.1
	FileCore-3_54:4.1
	FileCore-3_53:4.1
	FileCore-3_52:4.1
	FileCore-3_51:4.1
	FileCore-3_50:4.1
	FileCore-3_49:4.1
	FileCore-3_48:4.1
	FileCore-3_47:4.1
	FileCore-3_46:4.1
	FileCore-3_45:4.1
	FileCore-3_44:4.1
	FileCore-3_43:4.1
	FileCore-3_42:4.1
	FileCore-3_41:4.1
	FileCore-3_40:4.1
	FileCore-3_39:4.1
	FileCore-3_38:4.1
	FileCore-3_37:4.1
	FileCore-3_36:4.1
	FileCore-3_35:4.1
	FileCore-3_34:4.1
	FileCore-3_33:4.1
	RO_5_07:4.1
	FileCore-3_32:4.1
	FileCore-3_31:4.1
	FileCore-3_30:4.1
	FileCore-3_29:4.1
	FileCore-3_28:4.1
	FileCore-3_25-4_9_2_2:4.1
	FileCore-3_27:4.1
	FileCore-3_26:4.1
	FileCore-3_22-4_6_2_1:4.1
	bavison_FileCore-3_22_dev_bp:4.1
	bavison_FileCore-3_22:4.1.0.14
	FileCore-3_25-4_9_2_1:4.1
	HAL:4.1.0.12
	FileCore-3_25:4.1
	FileCore-3_24:4.1
	FileCore-3_23:4.1
	dellis_autobuild_BaseSW:4.1
	FileCore-3_22:4.1
	Ursula_merge:4.1
	ROL_merge:4.1
	FileCore-3_21:4.1
	ROL_Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	ROL_FileCore-3_21:4.1
	ROL_FileCore-3_20:4.1
	ROL:4.1.0.10
	ROL_bp:4.1
	Ursula_RiscPC_bp:4.1
	FileCore-3_18:4.1
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1
	sproven_FileCore-3_16:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	sproven_FileCore-3_15:4.1
	sproven_314:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1
	sproven_3_11:4.1
	sproven_3_10:4.1
	sproven_Ursula_3_09:4.1
	sproven_3_07:4.1
	sproven_3_06:4.1
	sproven_3_05:4.1
	sproven_3_04:4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1
	sproven_3_02:4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.1
date	96.11.05.09.32.35;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.35;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.47.19;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.35.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.32.11;	author nturton;	state Exp;
branches;
next	;


desc
@@



4.1
log
@Initial revision
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
        Routines to access E format disc objects
*/

#include <stdio.h>
#include <stdlib.h>
#include "typedefs.h"
#include "DiscOps.h"
#include "EObjects.h"
#include "EMaps.h"

typedef struct find_frag_info
{
        unsigned int frid_to_find;
        unsigned int found_frag_start;
        unsigned int found_frag_length;
        unsigned int bits_left_to_skip;
        unsigned int orig_bit_offset;
}       find_frag_info;


static YesNoAnswer check_for_one_we_want
(
        find_frag_info *param,
        disc_record const * const discrec,
        unsigned int zone,
        unsigned int fragment_id,
        unsigned int bit_offset,
        unsigned int bit_length
)
{
        zone = zone;

        if ( fragment_id == param->frid_to_find )
        {
                /*
                        Fragment of required object
                */
                if ( param->bits_left_to_skip >= bit_length )
                {
                        /*
                                Havn't reached required position yet
                        */
                        param->bits_left_to_skip -= bit_length;
                }
                else
                {
                        /*
                                This fragment contains required postion
                        */
                        param->found_frag_start = bit_offset;
                        param->found_frag_length = bit_length;

                        return Yes;
                }
        }

        return No;
}

static void didnt_find_fragment
(
        find_frag_info *param
)
{
        printf( "Total disaster: Object %d, offset %d not found\n", param->frid_to_find, param->orig_bit_offset );

        exit(0);
}

void find_fragment
(
        unsigned int * const found_frag_start,
        unsigned int * const found_frag_length,
        unsigned int * const offset_in_frag,
        disc_record const * const discrec,
        void const * const map,
        indirect_disc_address const fragment_to_find,
        unsigned int const bit_offset_in_object
)
{
        find_frag_info search_param;

        search_param.frid_to_find = fragment_to_find.fragment_id;
        search_param.bits_left_to_skip = bit_offset_in_object;
        search_param.orig_bit_offset = bit_offset_in_object;

        do_zone_walk( indirect_disc_address_to_zone( discrec, fragment_to_find ),
                NULL, NULL,
                NULL, NULL,
                (alloced_function)check_for_one_we_want, &search_param,
                NULL, NULL,
                (all_done_function)didnt_find_fragment, &search_param,
                discrec, map );

        *found_frag_start = search_param.found_frag_start;
        *found_frag_length = search_param.found_frag_length;
        *offset_in_frag = search_param.bits_left_to_skip;

        return;
}

void find_file_fragment
(
        direct_disc_address * const where,
        unsigned int * const bytes_left_in_fragment,
        disc_record const * const discrec,
        void const * const map,
        indirect_disc_address const object_to_find,
        unsigned int const byte_offset_in_object
)
{
        unsigned int bit_offset;
        unsigned int correction;
        unsigned int found_frag_start;
        unsigned int found_frag_length;
        unsigned int offset_in_frag;

        /*
                Correction to offset into object is sector offset converted to bytes
        */
        if ( object_to_find.sector_offset )
                correction = (object_to_find.sector_offset-1) << discrec->log2_sector_size;
        else
                correction = 0;

        /*
                bit offset into object is byte offset plus correction divided down
        */
        correction += byte_offset_in_object;
        bit_offset = correction >> discrec->log2_bytes_per_map_bit;

        /*
                Correction to resultant disc address is remainder of division
        */
        correction -= bit_offset << discrec->log2_bytes_per_map_bit;

        /*
                Find the relevant fragment
        */
        find_fragment( &found_frag_start, &found_frag_length, &offset_in_frag,
                        discrec, map, object_to_find, bit_offset );

        /*
                Convert bit offset to disc address and add correction
        */
        *where = map_bit_offset_to_disc_address( discrec, found_frag_start+offset_in_frag );
        where->byte_offset += correction;

        /*
                Evaluate bytes left in fragment
        */
        *bytes_left_in_fragment = ((found_frag_length - offset_in_frag)<<discrec->log2_bytes_per_map_bit) - correction;
}

_kernel_oserror *read_object_bytes
(
        void ** const to_where,
        indirect_disc_address const what,
        unsigned int * const from_where,
        unsigned int * const how_much_left,
        disc_record const * const discrec,
        void const * const map
)
{
        direct_disc_address where_on_disc;
        unsigned int bytes_left_in_fragment;
        unsigned int desired_transfer_size;
        unsigned int amount_left;
        _kernel_oserror *err = NULL;

        while( !err && *how_much_left > 0 )
        {
                find_file_fragment( &where_on_disc, &bytes_left_in_fragment, discrec, map, what, *from_where );

                if ( bytes_left_in_fragment > *how_much_left )
                {
                        desired_transfer_size = *how_much_left;
                }
                else
                {
                        desired_transfer_size = bytes_left_in_fragment;
                }

                amount_left = desired_transfer_size;

                err = adfs_discop_read( to_where, discrec, &where_on_disc, &amount_left );

                /*
                        Update rovers.
                */
                *how_much_left -= desired_transfer_size - amount_left;
                *from_where += desired_transfer_size - amount_left;
                *to_where = (void *)((int)*to_where + desired_transfer_size - amount_left);
        }

        return err;
}

_kernel_oserror *write_object_bytes
(
        void ** const to_where,
        indirect_disc_address const what,
        unsigned int * const from_where,
        unsigned int * const how_much_left,
        disc_record const * const discrec,
        void const * const map
)
{
        direct_disc_address where_on_disc;
        unsigned int bytes_left_in_fragment;
        unsigned int desired_transfer_size;
        unsigned int amount_left;
        _kernel_oserror *err = NULL;

        while( !err && *how_much_left > 0 )
        {
                find_file_fragment( &where_on_disc, &bytes_left_in_fragment, discrec, map, what, *from_where );

                if ( bytes_left_in_fragment > *how_much_left )
                {
                        desired_transfer_size = *how_much_left;
                }
                else
                {
                        desired_transfer_size = bytes_left_in_fragment;
                }

                amount_left = desired_transfer_size;

                err = adfs_discop_write( to_where, discrec, &where_on_disc, &amount_left );

                /*
                        Update rovers.
                */
                *how_much_left -= desired_transfer_size - amount_left;
                *from_where += desired_transfer_size - amount_left;
                *to_where = (void *)((int)*to_where + desired_transfer_size - amount_left);
        }

        return err;
}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

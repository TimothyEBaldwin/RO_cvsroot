head	4.1;
access;
symbols
	FileCore-3_75:4.1
	FileCore-3_74:4.1
	FileCore-3_73:4.1
	FileCore-3_72:4.1
	FileCore-3_71:4.1
	FileCore-3_70:4.1
	FileCore-3_69:4.1
	FileCore-3_68:4.1
	FileCore-3_67:4.1
	FileCore-3_66:4.1
	FileCore-3_65:4.1
	FileCore-3_64:4.1
	FileCore-3_63:4.1
	FileCore-3_62:4.1
	FileCore-3_61:4.1
	FileCore-3_60:4.1
	FileCore-3_59:4.1
	FileCore-3_58:4.1
	FileCore-3_57:4.1
	FileCore-3_56:4.1
	FileCore-3_55:4.1
	FileCore-3_54:4.1
	FileCore-3_53:4.1
	FileCore-3_52:4.1
	FileCore-3_51:4.1
	FileCore-3_50:4.1
	FileCore-3_49:4.1
	FileCore-3_48:4.1
	FileCore-3_47:4.1
	FileCore-3_46:4.1
	FileCore-3_45:4.1
	FileCore-3_44:4.1
	FileCore-3_43:4.1
	FileCore-3_42:4.1
	FileCore-3_41:4.1
	FileCore-3_40:4.1
	FileCore-3_39:4.1
	FileCore-3_38:4.1
	FileCore-3_37:4.1
	FileCore-3_36:4.1
	FileCore-3_35:4.1
	FileCore-3_34:4.1
	FileCore-3_33:4.1
	RO_5_07:4.1
	FileCore-3_32:4.1
	FileCore-3_31:4.1
	FileCore-3_30:4.1
	FileCore-3_29:4.1
	FileCore-3_28:4.1
	FileCore-3_25-4_9_2_2:4.1
	FileCore-3_27:4.1
	FileCore-3_26:4.1
	FileCore-3_22-4_6_2_1:4.1
	bavison_FileCore-3_22_dev_bp:4.1
	bavison_FileCore-3_22:4.1.0.14
	FileCore-3_25-4_9_2_1:4.1
	HAL:4.1.0.12
	FileCore-3_25:4.1
	FileCore-3_24:4.1
	FileCore-3_23:4.1
	dellis_autobuild_BaseSW:4.1
	FileCore-3_22:4.1
	Ursula_merge:4.1
	ROL_merge:4.1
	FileCore-3_21:4.1
	ROL_Ursula_merge:4.1
	Ursula_RiscPC_merge:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	ROL_FileCore-3_21:4.1
	ROL_FileCore-3_20:4.1
	ROL:4.1.0.10
	ROL_bp:4.1
	Ursula_RiscPC_bp:4.1
	FileCore-3_18:4.1
	FileCore-3_01:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	FileCore-3_00:4.1
	FileCore-2_99:4.1
	aglover_FileCore-3_17:4.1
	sproven_FileCore-3_16:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	sproven_FileCore-3_15:4.1
	sproven_314:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_313:4.1
	sproven_3_11:4.1
	sproven_3_10:4.1
	sproven_Ursula_3_09:4.1
	sproven_3_07:4.1
	sproven_3_06:4.1
	sproven_3_05:4.1
	sproven_3_04:4.1
	Spinner_RCA116:4.1.7.1
	sproven_3_03:4.1
	sproven_3_02:4.1
	sproven_3_01:4.1
	sproven_2_99:4.1
	sproven_2_98:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.1
date	96.11.05.09.32.35;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.35;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.47.25;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.35.30;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.32.12;	author nturton;	state Exp;
branches;
next	;


desc
@@



4.1
log
@Initial revision
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
        Main for FixADisc
*/

#include <stdio.h>
#include <stdlib.h>
#include "typedefs.h"
#include "EMaps.h"
#include "EObjects.h"
#include "Dirs.h"
#include "Displays.h"
#include "kernel.h"
#include "swis.h"
#include "discops.h"

int main( int argc, char **argv )
{
        int disc;
        char disc_identifier[ 20 ];
        disc_record discrec;
        void *map;
/*
REDUNDENT:
        unsigned int zone;
*/
        int print_free_space = No;
        int print_disc_record = No;
        int print_whole_map = No;
        int print_bad_areas = No;
/*
REDUNDENT:
        int check_map_checkbytes = No;
*/
        int i;
        _kernel_oserror *err;

        /*
                Determine options
        */
        if ( argc == 2 )
        {
                for ( i = 0; argv[1][i]; i++ )
                {
                        switch ( argv[1][i] )
                        {
                        case 'f':
                        case 'F':
                                print_free_space = Yes;
                                break;

                        case 'r':
                        case 'R':
                                print_disc_record = Yes;
                                break;

                        case 'm':
                        case 'M':
                                print_whole_map = Yes;
                                break;

                        case 'b':
                        case 'B':
                                print_bad_areas = Yes;
                                break;

/*
REDUNDENT:
                        case 'c':
                        case 'C':
                                check_map_checkbytes = Yes;
                                break;
*/

                        case 'a':
                        case 'A':
                                discop_to_use = ADFS_DiscOp;
                                break;

                        case 's':
                        case 'S':
                                discop_to_use = SCSIFS_DiscOp;
                                break;

                        default:
                                break;
                        }
                }
        }
        else
        {
                printf( "%s <options>\n", argv[0] );
                printf( "where options is a string of:\n" );
                printf( "f - print free space map\n" );
                printf( "r - print disc record\n" );
                printf( "m - print whole map\n" );
                printf( "b - print bad areas of disc\n" );
/*
REDUNDENT:
                printf( "c - check map check bytes\n" );
*/
                printf( "a - check ADFS discs\n" );
                printf( "s - check SCSIFS discs\n" );
                printf( "This program, like all irritating thrown together programs\n" );
                printf( "falls short of expectations by not actually fixing your disc\n" );
                printf( "but, it does tell you in excrutiating detail exactly what's wrong!\n" );
                exit(0);
        }

        /*
                For each disc
        */
        for ( disc = 0; disc < 8; disc++ )
        {
                /*
                        Construct identifier string
                */
                sprintf( disc_identifier, ":%d", disc );

                /*
                        Get the disc record for this disc - skip if didn't get it
                */
                if ( (err=read_disc_record( disc_identifier, &discrec ))!=NULL )
                {
                        printf( ":%d skipped due to a %s error\n", disc, err->errmess );
                        continue;
                }

                /*
                        Frig the disc number because FileCore gives us such a useless value.
                */
                discrec.root_directory.direct.disc_number = disc;

                printf( "Disc %s\n", disc_identifier );

                /*
                        If displaying the disc record then do so
                */
                if ( print_disc_record )
                        display_disc_record( &discrec );

                /*
                        Read (and fix) the disc's map
                */
                read_map( &map, &discrec );

/*
                if ( disc == 0 || disc != 0 )
                {
                        unsigned char root_directory[ 0x800 ];
                        void *root_directoryp = root_directory;
                        unsigned int from_where = 0;
                        unsigned int quantity = 0x800;
                        int i,j;

                        if ( read_object_bytes( &root_directoryp, *(indirect_disc_address *)&discrec.root_directory, &from_where, &quantity, &discrec, map ) )
                        {
                                printf( "Reading root directory failed\n" );
                        }
                        else
                        {
                                printf( "Root directory now read\n" );
                                for ( i = 0; i < 0x800; i+=16 )
                                {
                                        printf( "% 8X  ", i );
                                        for ( j = 0; j < 16; j++ )
                                        {
                                                printf( " %02X", root_directory[i+j] );
                                        }

                                        printf( "  " );
                                        for ( j = 0; j < 16; j++ )
                                        {
                                                if ( root_directory[i+j] >= ' ' && root_directory[i+j] <= '~' )
                                                {
                                                        printf( "%c", root_directory[i+j] );
                                                }
                                                else
                                                {
                                                        printf( "." );
                                                }
                                        }

                                        printf( "\n" );
                                }
                        }

                        recurse_directory_display( "$", discrec.root_directory.indirect, &discrec, map );
                }
*/

                /*
                        1st stage directory tree wander.
                        This stage:
                        *  Identifies objects
                        *  Fixes directories
                        *  Counts references to objects
                        *  (should) Reattaches detached objects
                        *  Warns about under usages and over usages
                */
                accum_and_display_directory_stats( &discrec, map );

/*
REDUNDENT:
                if ( check_map_checkbytes )
                {
                        for ( zone = 0; zone < discrec.zones_in_map; zone++ )
                        {
                                printf( "Zone %d ", zone );

                                if ( check_zone_valid( map, &discrec, zone ) )
                                {
                                        printf( "good\n" );
                                }
                                else
                                {
                                        printf( "bad\n" );
                                }
                        }

                        if ( crosscheck_map_valid( map, &discrec ) )
                        {
                                printf( "Whole map self consistent\n" );
                        }
                        else
                        {
                                printf( "Whole map inconsistent with self\n" );
                        }
                }
*/

                if ( print_free_space )
                        display_map_as_map( map, &discrec );

                if ( print_whole_map )
                        display_map_completly( map, &discrec );

                if ( print_bad_areas )
                        display_map_bad_blocks( map, &discrec );

                free( map );
        }

        return 0;
}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

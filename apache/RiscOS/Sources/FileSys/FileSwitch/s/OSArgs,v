head	4.8;
access;
symbols
	FileSwitch-2_87:4.8
	FileSwitch-2_86:4.8
	FileSwitch-2_85:4.8
	FileSwitch-2_84:4.8
	FileSwitch-2_83:4.8
	FileSwitch-2_82:4.8
	FileSwitch-2_81:4.8
	FileSwitch-2_80:4.8
	FileSwitch-2_79:4.8
	FileSwitch-2_78:4.7
	FileSwitch-2_77:4.7
	FileSwitch-2_76:4.7
	FileSwitch-2_75:4.7
	FileSwitch-2_74:4.6
	FileSwitch-2_73:4.6
	FileSwitch-2_72:4.6
	FileSwitch-2_71:4.5
	FileSwitch-2_70:4.5
	FileSwitch-2_69:4.5
	FileSwitch-2_68:4.3
	FileSwitch-2_67:4.3
	RO_5_07:4.3
	FileSwitch-2_66:4.3
	FileSwitch-2_65:4.3
	FileSwitch-2_64:4.3
	FileSwitch-2_63:4.3
	FileSwitch-2_62:4.3
	FileSwitch-2_61:4.3
	FileSwitch-2_60:4.3
	FileSwitch-2_59:4.3
	FileSwitch-2_58:4.3
	FileSwitch-2_57:4.3
	FileSwitch-2_56:4.3
	FileSwitch-2_55:4.2
	FileSwitch-2_54:4.2
	FileSwitch-2_53:4.2
	dellis_autobuild_BaseSW:4.2
	FileSwitch-2_52:4.2
	FileSwitch-2_51:4.2
	ROLtd-4_02:4.2
	FileSwitch-2_45:4.2
	Ursula_merge:4.2
	FileSwitch-2_50:4.2
	sbrodie_sedwards_16Mar2000:4.2
	FileSwitch-2_41:4.2
	dcotton_Spin_merge:4.1.7.1
	FileSwitch-2_40:4.2
	dcotton_autobuild_BaseSW:4.3
	FileSwitch-2_39:4.2
	FileSwitch-2_43:4.2
	Ursula_FileSwitch-2_42:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_FileSwitch-2_29:4.1.7.1
	FileSwitch-2_38:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_241:4.2
	sproven_2_40:4.2
	sproven_2_38:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2012.11.19.22.00.58;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	xoecFXfSjeTeQ1tw;

4.7
date	2012.02.20.08.14.26;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	ylegcWjjKuNQ2STv;

4.6
date	2011.11.27.11.59.31;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	SMknibmDFieq1YIv;

4.5
date	2011.10.16.12.02.03;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	aIoHKFo0smPUnzDv;

4.4
date	2011.10.16.11.29.42;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	MacYcSTahAyWczDv;

4.3
date	2001.04.04.12.17.23;	author dellis;	state Exp;
branches;
next	4.2;

4.2
date	97.01.14.17.11.52;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.50;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.50;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.52.05;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.36.59;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.33.33;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Tabs expanded in IOCtl OS_Arg
Not tagged.
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    > Sources.OSArgs

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; +                                                                           +
; +                           A R G S   S W I                                 +
; +                                                                           +
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; ArgsEntry. Vectored SWI level entry
; =========
;
; Special and normal OS_Args entry point

; In:  r0 = &00, r1b =      &00: Read FS number to r0
;                      &01..&FF: Read PTR of file to r2

;      r0 = &01, r1b =      &00: Read command tail; not done - use OS_GetEnv
;                      &01..&FF: Set PTR of file from r2
;                                  r2 preserved

;      r0 = &02, r1b =      &00: Read NFS version number; not done
;                      &01..&FF: Read extent of file to r2

;      r0 = &03, r1b = &01..&FF: Set extent of file from r2 (r1b = 0 invalid)
;                                  r2 preserved

;      r0 = &04, r1b = &01..&FF: Read size of file to r2    (r1b = 0 invalid)

;      r0 = &05, r1b = &01..&FF: Check EOF on file          (r1b = 0 invalid)
;                                  r2 = 0 -> ~EOF, r2 = -1 -> EOF

;      r0 = &06, r1b = &01..&FF: Ensure file size from r2   (r1b = 0 invalid)
;                                  r2 := new allocated size (>= r2in)

;      r0 = &FE, r1b = &01..&FF: Read info on file to r0,r2 (r1b = 0 invalid)
;                                  r0 := scb status, r2 := fscb info

;      r0 = &FF, r1b =      &00: Flush all files on temp fs call
;                      &01..&FF: Flush file call


ArgsEntry ROUT

 [ debugosargsentry
 DREG r0,"OS_Args ",cc
 DREG r1,", handle/parm ",cc
 DREG r2,", data "
 ]
        AND     r14, r0, #&FF           ; r0b = &FF -> Flushing op
        TEQ     r14, #&FF
        BEQ     FlushingArgsEntry

        TST     r1, #&FF                ; Is it ReadFS number (r0b=0, r1b=0) ?
        TEQEQ   r14, #&00
        BEQ     ReadFSArgsEntry

; .............................................................................
; Bash the given file

; In    r0  = OS_Args action
;       r1b = FileSwitch handle
;       r2  = data

; Out   VC: ok, r0 updated / preserved according to r0in
;               r1 preserved
;               r2 updated / preserved according to r0in
;       VS: fail, handle appended to error

FileArgsEntry NewSwiEntry "r0-r1, scb, $streaminfo"

        AND     r1, r1, #&FF            ; r1b is file handle
        ADR     r14, streamtable
        LDR     scb, [r14, r1, LSL #2]  ; Get scb^

        ReadStreamInfo

10 ; Reentry point for below

        TEQ     r0, #OSArgs_ReadInfo    ; Common to buffered/unbuffered files
        BEQ     FileArgs_ReadInfo       ; >>>a186<<< harder than I thought

        TEQ     r0, #OSArgs_ReadPath
        BEQ     FileArgs_ReadPath

        TEQ     r0, #OSArgs_ImageStampIs
        BEQ     FileArgs_ImageStampIs

        TEQ     r0, #OSArgs_IOCtl
        BEQ     FileArgs_IOCtl

        CMP     r0, #OSArgs_EnsureSize  ; Largest low one we know about
        BHI     %FA99                   ; [duff rc]

        TEQ     r0, #OSArgs_SetPTR      ; Reset EOF state if writing these
        TEQNE   r0, #OSArgs_SetEXT
        BICEQ   status, status, #scb_EOF_pending

        ; Done in 2 TSTs due to spread of bits - won't fit in one immediate constant
        TST     status, #scb_unbuffered :OR: scb_directory :OR: scb_unallocated
 [ {FALSE}
        ; SMC: The following buffered stream calls simply return current values
        ; so there is no need to check for re-entrancy here.
        ;
        TSTEQ   status, #scb_critical
 ]
        BNE     FileArgs_StrangeBitsSet ; [strange bits set]

; *************************** Buffered stream *********************************

        TEQ     r0, #OSArgs_ReadPTR     ; Read PTR of buffered file
        MOVEQ   r2, fileptr
        BEQ     FileArgsExit ; SwiExit

        TEQ     r0, #OSArgs_ReadEXT     ; Read EXT of buffered file
        MOVEQ   r2, extent
        BEQ     FileArgsExit ; SwiExit

        TEQ     r0, #OSArgs_ReadSize    ; Read allocated size of buffered file
        LDREQ   r2, scb_allocsize
        BEQ     FileArgsExit ; SwiExit

        TEQ     r0, #OSArgs_EOFCheck    ; Check EOF on buffered file
        BNE     %FT30

        ; EOFCheck
        TEQ     fileptr, extent
        MOV     r2, #0                  ;  0 -> ~EOF
        MOVEQ   r2, #-1                 ; -1 -> EOF

 [ :LNOT: appendhandle
95
 ]

FileArgsExit
 [ debugosargs
 DREG r2,"OS_Args returns "
 ]
        SwiExit


FileArgs_ReadInfo
        STR     status, [fp, #4*0]      ; Resultis r0 and r2
        TST     status, #scb_unallocated ; >>>a186<<< stop causing exceptions
        MOVNE   r2, #0
        LDREQ   r14, scb_fscb
        LDREQ   r2, [r14, #fscb_info]
        B       FileArgsExit ; SwiExit

        ; Read file's path
FileArgs_ReadPath
        TST     status, #scb_unallocated
        BNE     %FA92
        Push    "r2,fscb"
        LDR     r1, scb_path
        LDR     r6, scb_special
        LDR     fscb, scb_fscb
        LDR     r3, [fp, #4*4]
        BL      int_ConstructFullPath
        STR     r3, [fp, #4*4]
        Pull    "r2,fscb"
        B       FileArgsExit

FileArgs_IOCtl
        TST     status, #scb_unallocated
        BNE     %FA92
        Push    "r0-r1, fscb"
        LDR     fscb, scb_fscb
        LDR     r0, [fscb, #fscb_extra]
        TST     r0, #fsextra_IOCtl

        MOVNE   r0, #fsargs_IOCtl
        BLNE    CallFSArgs
        Pull    "r0-r1, fscb"
        B       FileArgsExit ; SwiExit


FileArgs_ImageStampIs
 [ debugosargsstamp
        DREG    r1, "ImageStampIs on file ",cc
        DREG    r2, " is "
 ]
        TST     status, #scb_unallocated
        BNE     %FA92
        LDR     r0, scb_fscb
        LDR     r0, [r0, #fscb_info]
        TST     r0, #fsinfo_multifsextensions

        ; r2 may be trashed by lower level
        Push    "r2"
        MOVNE   r0, #fsargs_ImageStampIs
        BLNE    CallFSArgs
        Pull    "r2"

        B       FileArgsExit


30 ; Write fileptr of buffered file ?

        CMP     r0, #OSArgs_SetPTR
        BNE     %FT60

 [ debugosargs
 DREG r2,"Setting PTR to "
 ]
        EOR     r14, r2, extent         ; Moving PTR to same buffer as EOF ?
        BICS    r14, r14, bufmask
        BLEQ    InvalidateBGetCache     ; Ensures we don't read off EOF

        CMP     r2, extent              ; Trying to move off EOF ?
        BHI     %FT40
        CLRV                            ; May set V with files > 2G
        MOV     fileptr, r2             ; Merely update fileptr, status
        B       %FT50
40
        TST     status, #scb_write      ; Can we write to the file ?
        BEQ     %FA98                   ; 'Outside file' if not

        BL      ExtendFileWithZeroes    ; No longer updates extent as well
        MOVVC   extent, r2
        MOVVC   fileptr, extent

50      STMVCIA scb, {status, fileptr, extent} ; Update info exit
        ASSERT  :INDEX: scb_status = 0


 [ appendhandle
95      BLVS    AppendHandleToError     ; For all errors in OSArgs
 ]
        B       FileArgsExit ; SwiExit


60 ; Write extent of buffered file ?

        TEQ     r0, #OSArgs_SetEXT
        BNE     %FT70

        TST     status, #scb_write      ; Can't write if no permission
        BEQ     %FT96                   ; Even if doing EXT#h = EXT#h

        BL      InvalidateBGetCache     ; May be shrinking file so PTR in the
                                        ; same buffer as EOF

        CMP     r2, extent
        BLO     %FT65                   ; [shrinking file]

        BLNE    ExtendFileWithZeroes    ; [growing file, or staying same]
        MOVVC   extent, r2
        B       %BA50                   ; Update info exit


65      CMP     r2, fileptr             ; Dragging eof over old fileptr ?
        MOVLO   fileptr, r2             ; fileptr := extent if so

        MOV     r0, r2                  ; Start point in file
        MOV     r1, #&FFFFFFFF          ; End point in file
        BL      DiscardBuffersBetween   ; Discard all info fully spanned by
        MOVVC   extent, r2              ; new, shorter, extent and something big
        B       %BA50                   ; Update info exit



70 ; Ensure file space allocation ok ?

        TEQ     r0, #OSArgs_EnsureSize
        BNE     %FA99

        BL      EnsureFileSize
        B       FileArgsExit ; SwiExit


FileArgs_StrangeBitsSet ; Complicated OSArgs - some flags set

        TST     status, #scb_unallocated        ; Not a stream ?
        BNE     %FT92

        TST     status, #scb_critical           ; Return - done nothing to file
        EXIT    NE

        TST     status, #scb_directory          ; Can't do anything to a dir.
        BNE     %FT94

; *************************** Unbuffered stream *******************************

        TEQ     r0, #OSArgs_EnsureSize  ; Convert to low level op
        MOVEQ   r0, #fsargs_EnsureSize

        Push    r2                      ; Preserve r2 for some ops
        BL      CallFSArgs
        Pull    r14
        BVS     %BT95

        TEQ     r0, #OSArgs_SetPTR      ; Only these two ops preserve r2
        TEQNE   r0, #OSArgs_SetEXT
        MOVEQ   r2, r14                 ; Preserve r2 if not result from call
        STREQ   status, scb_status      ; Only thing that needs updating
                                        ; as we don't keep local fileptr,extent
 [ debugosargs
 DREG r2,"OS_Args (ub) returns "
 ]
        B       FileArgsExit ; SwiExit


92      BL      SetErrorChannel
        B       %BT95

94      BL      SetErrorStreamIsDirectory
        B       %BT95

96      BL      SetErrorNotOpenForUpdate
        B       %BT95

98      addr    r0, ErrorBlock_OutsideFile
        BL      CopyError
        B       %BT95


; Unknown rc for OS_Args

99      CMP     r0, #&FF                ; Silly bits set ?
        ANDHI   r0, r0, #&FF            ; r0b is reason code
        BHI     %BT10                   ; Reenter

        addr    r0, ErrorBlock_BadOSArgsReason
        BL      CopyError
        B       %BT95

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; ReadFSArgsEntry
; ===============
;
; Entry for the wally part of OS_Args (r0b=0, r1b=0)

; Return Filing System number that is being used at the moment; ie. tempfs

; Out   r0 = temp fs number

ReadFSArgsEntry NewSwiEntry
        BL      ReadTempFS
        BVS     %FT10
        TEQ     r0, #Nowt
        LDRNEB  r0, [r0, #fscb_info]
        MOVEQ   r0, #fsnumber_none
 [ debugosargs
 DREG r0,"OS_Args (ReadFS) returns "
 ]
10
        SwiExit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; FlushingArgsEntry
; =================
;
; Flush file(s) on the current Filing System to media

; In    r0b = &FF
;       r1b =            0 : Flush all files on the temp Filing System
;             1..MaxHandle : Flush file of given handle

; Out   VC: ok, all regs preserved
;       VS: fail

FlushingArgsEntry NewSwiEntry "r0-r1, scb, fscb, $streaminfo"

        ANDS    r1, r1, #&FF            ; r1b is handle
        BEQ     %FT30

; Flush a single file. Allow flushing of directories to not yield errors

        BL      FindValidStream
        BVS     %FT15

        ReadStreamInfo
        BL      FlushStream
15
 [ appendhandle
        BLVS    AppendHandleToError
 ]

20      SwiExit



30 ; Flush all files on temp Filing System. NB. There is no 'flush everywhere'

        BL      ReadTempFS
        BVS     %BA20
        MOV     fscb, r0
        MOV     r1, #MaxHandle          ; Loop over handles in stream table

50      BL      FindStream              ; Get scb^ for this handle, VClear
        BEQ     %FT90

        LDR     r14, scb_fscb           ; Is handle on this Filing System ?
        TEQ     r14, fscb
        BNE     %FT90

        ReadStreamInfo
        BL      FlushStream
 [ appendhandle
        BLVS    AppendHandleToError     ; globalerror picked up at SwiExit
 ]

90      SUBS    r1, r1, #1              ; Last valid handle = 1
        BNE     %BT50                   ; VClear from SUBS

        B       %BA20 ; SwiExit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        LTORG

        END
@


4.7
log
@Fix bug in OS_Args R0=R1=0 when no temporary filing system is selected.
Was returning internal value 'Nowt' instead of zero.
This bug seems to have appeared in FileSwitch 1.70 in RISC OS 3.00 and as such for backwards compatibility the value 0 and the value 0x40000000 should be taken to mean 'none'.

Version 2.75. Tagged as 'FileSwitch-2_75'
@
text
@d103 1
a103 1
        BEQ	FileArgs_IOCtl
d180 1
a180 1
	Push	"r0-r1, fscb"
d182 2
a183 2
	LDR	r0, [fscb, #fscb_extra]
	TST	r0, #fsextra_IOCtl
d185 3
a187 3
        MOVNE	r0, #fsargs_IOCtl
        BLNE	CallFSArgs
	Pull	"r0-r1, fscb"
@


4.6
log
@assert -> ASSERT.
Collapse old switches.
Remove 'Version' GBLA.
*COUNT summary now says "total 1234 bytes" not "1234 bytes" to match *COPY
Empty *COUNT syntax message corrected.
Binary identical to last version (messages different clearly).

Version 2.72. Tagged as 'FileSwitch-2_72'
@
text
@d357 1
@


4.5
log
@Put back a debug line, deleted in error.
Retagged as FileSwitch-2_69.
@
text
@d237 1
a237 1
 assert :INDEX: scb_status = 0
@


4.4
log
@Fix OS_Args 1 and OS_GBPB 3/4 for files > 2G.
In OS_Args 1 a compare was followed by a conditional store, but with files > 2G some circumstances end up with VS so the store wasn't taken.
In OS_GBPB 3/4 the assessment of how much could be done was based on adding the current fileptr to the request but not respecting the carry out. Reordered the equation to get this calculation right.
Changed a signed compare of a byte variable to use unsigned so auditing of signed condition codes is clearer.
Corrected spelling of 'openning'.
Fix copy_srchandle and copy_dsthandle to not assume handles fit in 1 byte.
Tested on a variety of contrived file sizes at the boundaries of 2G and 4G.

Version 2.69. Tagged as 'FileSwitch-2_69'
@
text
@d216 3
@


4.3
log
@  Fixed some data aborts on OS_Args calls

Detail:
  OS_Args 8 and 9 (ImageStampIS and IOCtl) didn't check that the file handle
passed to them was legitimate and hence would cause data aborts as they tried
to access non existant structures.

Admin:
  Not tested.  Two lines of assembler copied into each function to test
whether the file handle is valid from other similar calls.

Version 2.56. Tagged as 'FileSwitch-2_56'
@
text
@a215 3
 [ debugosargs
 DREG r2,"Setting PTR to "
 ]
d221 5
a225 3
        MOVLS   fileptr, r2             ; Merely update fileptr, status
        BLS     %FT50

a232 1

@


4.2
log
@Module merged
@
text
@d178 2
d196 2
@


4.1
log
@Initial revision
@
text
@d102 3
d177 12
a277 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a101 3
        TEQ     r0, #OSArgs_IOCtl
        BEQ	FileArgs_IOCtl

a173 12
FileArgs_IOCtl
	Push	"r0-r1, fscb"
        LDR     fscb, scb_fscb
	LDR	r0, [fscb, #fscb_extra]
	TST	r0, #fsextra_IOCtl

        MOVNE	r0, #fsargs_IOCtl
        BLNE	CallFSArgs
	Pull	"r0-r1, fscb"
        B       FileArgsExit ; SwiExit


d263 1
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a101 3
        TEQ     r0, #OSArgs_IOCtl
        BEQ	FileArgs_IOCtl

a173 12
FileArgs_IOCtl
	Push	"r0-r1, fscb"
        LDR     fscb, scb_fscb
	LDR	r0, [fscb, #fscb_extra]
	TST	r0, #fsextra_IOCtl

        MOVNE	r0, #fsargs_IOCtl
        BLNE	CallFSArgs
	Pull	"r0-r1, fscb"
        B       FileArgsExit ; SwiExit


d263 1
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.6;
access;
symbols
	FileSwitch-2_87:4.6
	FileSwitch-2_86:4.6
	FileSwitch-2_85:4.6
	FileSwitch-2_84:4.6
	FileSwitch-2_83:4.6
	FileSwitch-2_82:4.6
	FileSwitch-2_81:4.6
	FileSwitch-2_80:4.6
	FileSwitch-2_79:4.6
	FileSwitch-2_78:4.6
	FileSwitch-2_77:4.6
	FileSwitch-2_76:4.6
	FileSwitch-2_75:4.6
	FileSwitch-2_74:4.6
	FileSwitch-2_73:4.6
	FileSwitch-2_72:4.6
	FileSwitch-2_71:4.5
	FileSwitch-2_70:4.4
	FileSwitch-2_69:4.4
	FileSwitch-2_68:4.4
	FileSwitch-2_67:4.4
	RO_5_07:4.4
	FileSwitch-2_66:4.4
	FileSwitch-2_65:4.4
	FileSwitch-2_64:4.4
	FileSwitch-2_63:4.4
	FileSwitch-2_62:4.4
	FileSwitch-2_61:4.4
	FileSwitch-2_60:4.4
	FileSwitch-2_59:4.4
	FileSwitch-2_58:4.4
	FileSwitch-2_57:4.4
	FileSwitch-2_56:4.3
	FileSwitch-2_55:4.3
	FileSwitch-2_54:4.3
	FileSwitch-2_53:4.3
	dellis_autobuild_BaseSW:4.3
	FileSwitch-2_52:4.3
	FileSwitch-2_51:4.2
	ROLtd-4_02:4.2
	FileSwitch-2_45:4.2
	Ursula_merge:4.2
	FileSwitch-2_50:4.2
	sbrodie_sedwards_16Mar2000:4.2
	FileSwitch-2_41:4.2
	dcotton_Spin_merge:4.1.7.1
	FileSwitch-2_40:4.2
	dcotton_autobuild_BaseSW:4.4
	FileSwitch-2_39:4.2
	FileSwitch-2_43:4.2
	Ursula_FileSwitch-2_42:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_FileSwitch-2_29:4.1.7.1
	FileSwitch-2_38:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_241:4.2
	sproven_2_40:4.2
	sproven_2_38:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2011.11.27.11.59.31;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	SMknibmDFieq1YIv;

4.5
date	2011.11.27.11.56.26;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	K4NCQAqLgaBl0YIv;

4.4
date	2001.04.17.11.29.47;	author dcotton;	state Exp;
branches;
next	4.3;

4.3
date	2000.03.20.15.57.45;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.14.17.11.53;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.50;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.50;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.52.08;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.37.00;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.33.34;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@assert -> ASSERT.
Collapse old switches.
Remove 'Version' GBLA.
*COUNT summary now says "total 1234 bytes" not "1234 bytes" to match *COPY
Empty *COUNT syntax message corrected.
Binary identical to last version (messages different clearly).

Version 2.72. Tagged as 'FileSwitch-2_72'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    > Sources.OSBGetBPut - BGet, BPut

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; +                                                                           +
; +                         B G E T   S W I                                   +
; +                                                                           +
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; BGetEntry. Vectored SWI level entry
; =========
;
; Get a byte from the given file. Optimised for speed in the buffered case

; In    r1b = file handle

; NB. Neither the BGet or BPut caches are guaranteed to work if a file handle
;     of DeadHandle is passed in as that is the handle used to invalidate the
;     cache: if it matches this, it then assumes the cached scb^ is valid ...

DeadHandle * &DEAD2300 ; LSB can't be valid handle

; Out   VC: ok, r0 = char
;       VS: fail, handle given with error

BGetEntry ROUT ; Make do without a frame in cache section

 [ debugosbgetentry
 DREG r1,"OSBGet: handle "
 ]

Proc_RegList SETS "scb, bcb, $streaminfo, fp"
Proc_LocalStack SETA localframesize

        ASSERT  bcb = r8
        ASSERT  scb > r8
        Push    "r8, scb, fp"                   ; Note the nastiness

        ASSERT  :INDEX: BGet_shiftedbase = 0
        ASSERT  :INDEX: BGet_bufferdata = 4
        ASSERT  :INDEX: BGet_scb        = 8
        ASSERT  :INDEX: BGet_shift      = 12
        ASSERT  :INDEX: BGet_handle     = 16
        LDMIA   wp, {r0, r8, scb, fp, r14}      ; Get cached data
 [ No26bitCode
        TEQ     r14, r1                         ; BGet on cached handle ?
        LDREQ   r14, scb_fileptr                ; Check fileptr in that buffer
        TEQEQ   r0, r14, LSR fp
        LDREQB  r0, [r8, r14]                   ; Get byte from buffer
        ADDEQ   r14, r14, #1
        STREQ   r14, scb_fileptr                ; Increment fileptr
        CLRPSR  V_bit + C_bit + I_bit, r14, EQ  ; Whew ! Allow IRQ here
        Pull    "r8, scb, fp, pc", EQ           ; Destack all, and punter lr
10
 |
        TEQ     r14, r1                         ; BGet on cached handle ?
        LDREQ   r14, scb_fileptr                ; Check fileptr in that buffer
        TEQEQ   r0, r14, LSR fp
        LDREQB  r0, [r8, r14]                   ; Get byte from buffer
        ADDEQ   r14, r14, #1
        STREQ   r14, scb_fileptr                ; Increment fileptr
        Pull    "r8, scb, fp, lr", EQ           ; Destack all, and punter lr
        BICEQS  pc, lr, #V_bit + C_bit + I_bit  ; Whew ! Allow IRQ here
 ]


 [ debugosbgetcache
 DLINE "BGet cache miss"
 ]
        Push    "status, fileptr, extent, bufmask"
                                                ; So we can reload $streaminfo
        InitialiseFrame

        AND     bcb, r1, #&FF           ; r1b is file handle
        ADR     r14, streamtable
        LDR     scb, [r14, bcb, LSL #2] ; Get scb^

        ReadStreamInfo bcb              ; bcb invalid for unbuffered streams,
                                        ; but who cares ?

        EOR     r14, status, #scb_read  ; Must be set
        TST     r14, #scb_read :OR: scb_directory :OR: scb_unbuffered :OR: scb_EOF_pending :OR: scb_unallocated
        TSTEQ   r14, #scb_critical
        BNE     %FT85                   ; Any of these set ?

; Buffered BGet. Don't bother to get valid buffer if at EOF !
 [ debugosbgetcache
 DLINE "Valid BGet buffered file"
 ]

        CMP     fileptr, extent         ; Reading at EOF ? CSet if true
        BEQ     %FT90                   ; NB. Order of checks !

        CMP     bcb, #Nowt              ; No buffer present ?
        BEQ     %FT50

        BIC     r0, fileptr, bufmask    ; Where buffer base needs to be
        LDR     r14, bcb_bufferbase
        CMP     r14, r0
        BNE     %FT50

        SUB     r14, r14, #:INDEX: bcb_bufferdata ; Form offset into bcb
                                        ; if in the correct buffer
 [ debugosbgetcache
 DLINE "BGet: have correct buffer"
 ]

40      SUB     r14, fileptr, r14
        LDRB    r0, [bcb, r14]          ; Get a byte from buffer%offset
        ADD     fileptr, fileptr, #1
        STR     fileptr, scb_fileptr    ; Update stream fileptr

 [ True ; Set up cache data
        BIC     r14, fileptr, bufmask   ; Cache if not now in end sector
        BIC     r4, extent, bufmask
        CMP     r4, r14
        ASSERT  fileptr = r4 ; Not needed anymore
 [ debugosbgetcache
 BEQ %FT66
 DLINE "Setting up BGet cache"
 B %FT67
66
 DLINE "In end sector: not doing BGet cache"
67
 ]
        STRNE   r1, BGet_handle         ; Cache the file data to use next time
        STRNE   scb, BGet_scb

        LDRNE   r14, scb_shift
        STRNE   r14, BGet_shift
        LDRNE   bcb, scb_bcb            ; Get real bcb^
        LDRNE   r4, bcb_bufferbase      ; Need real bcb^ so we can load this
        MOVNE   r14, r4, LSR r14        ; bufferbase >> shift
        STRNE   r14, BGet_shiftedbase
        ADDNE   r14, bcb, #:INDEX: bcb_bufferdata
        SUBNE   r14, r14, r4            ; bcb^ +offset +(fileptr -basefileptr)
        STRNE   r14, BGet_bufferdata    ; Add fileptr to this to get data addr
 ]

 [ debugosbget
 BNE %FT00
 DREG r0,"OSBGet: got ",cc,Byte
 DREG r1,", handle "
00
 ]

45      ADD     sp, sp, #localframesize
 [ No26bitCode
        CLRPSR  V_bit + C_bit + I_bit, r14      ; Allow an interrupt here
        Pull    "$Proc_RegList, pc"             ; Destack all, and punter pc
 |
        Pull    "$Proc_RegList, lr"             ; Destack all, and punter lr
        BICS    pc, lr, #V_bit + C_bit + I_bit  ; Allow an interrupt here
 ]


; End of simple BGet case. Now for the boring stuff
; .............................................................................

50 ; Not got the right buffer. Get it and try again !

        BL      InvalidateBGetCache

        BL      FindFileBuffer          ; May as well still be general
        BNE     %FT55

        BL      GetFileBuffer
        BVS     %FA99

55      LDR     r14, bcb_dataoffset     ; Form offset into bcb
        B       %BT40



90 ; fileptr = extent. Set EOF error flag, return CSet

        BL      InvalidateBGetCache

91      LDR     r0, =EOF_char
        ORR     status, status, #scb_EOF_pending ; Next read will cause EOFerr
        STR     status, scb_status
 [ debugosbget
 DLINE "EOF detected"
 ]
        ADD     sp, sp, #localframesize
 [ No26bitCode
        SCPSR   C_bit, I_bit+V_bit, r14 ; Set C, clear I+V, to allow an IRQ
        Pull    "$Proc_RegList, pc"     ; Destack all, and punter pc
 |
        Pull    "$Proc_RegList, lr"     ; Destack all, and punter lr
        BIC     lr, lr, #V_bit + I_bit  ; Allow IRQ real soon now
        ORRS    pc, lr, #C_bit
 ]



85 ; Complicated BGet - some flags set, so check 'em

 [ debugosbget
 DLINE "Complicated BGet"
 ]
        TST     status, #scb_unallocated ; Not a stream ?
        BNE     %FT92

        TST     status, #scb_critical   ; Return NULL
 [ debugosbget
 BEQ %FT00
 DLINE "scb_critical set"
00
 ]
        MOVNE   r0, #0
        BNE     %BA45                   ; Exit sets CClear

        TST     status, #scb_directory  ; Can't read from directory
        BNE     %FT94

        TST     status, #scb_read       ; Can't read if no permission
        BEQ     %FT96

        TST     status, #scb_EOF_pending ; Already read EOF on this handle ?
        BNE     %FA98                   ; Give error if so

; Must have branched because unbuffered then

        BL      CallFSBGet              ; Get single byte from file
        BVS     %FA99
        BCC     %BA45                   ; Exit sets CClear
        B       %BT91                   ; Returning EOF exit


98      addr    r0, ErrorBlock_EndOfFile
        BL      CopyError

 [ appendhandle
99      BL      AppendHandleToError      ; For all errors in BGet
        SwiExit
 |
99      SwiExit
 ]

92      BL      SetErrorChannel
        B       %BA99

94      BL      SetErrorStreamIsDirectory
        B       %BA99

96      BL      SetErrorNotOpenForReading
        B       %BA99

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; +                                                                           +
; +                         B P U T   S W I                                   +
; +                                                                           +
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; BPutEntry. Vectored SWI level entry
; =========
;
; Put a byte to the given file

; In    r0b = byte, r1b = file handle

; Out   VC: ok, all registers preserved
;       VS: fail, handle given with error

BPutEntry ROUT ; Make do without a frame in cache section

Proc_RegList    SETS "$streaminfo, r7, bcb, scb, fp" ; When we have frame set
Proc_LocalStack SETA localframesize

 [ debugosbputentry
 DREG r0,"OSBPut: byte ",cc
 DREG r1,", handle ",cc
 DREG sp,", sp = ",cc
 LDR lr, [sp]
 DREG lr,", stacked lr = "
 ]

; r7 used as temp anyway in BPut, so it's free to abuse here !
        ASSERT  bcb = r8
        ASSERT  scb > r8
        Push    "r7, bcb, scb, fp"              ; Note the nastiness

;       BPut_shiftedbase                        ; r7
        ASSERT  BPut_bufferdata = BPut_shiftedbase + 4  ; r8
        ASSERT  BPut_scb        = BPut_shiftedbase + 8  ; scb
        ASSERT  BPut_shift      = BPut_shiftedbase + 12 ; fp
        ASSERT  BPut_handle     = BPut_shiftedbase + 16 ; r14
        ADR     r14, BPut_shiftedbase           ; Can't be as nasty as BGet
        LDMIA   r14, {r7, r8, scb, fp, r14}     ; Get cached data
        TEQ     r14, r1                         ; BPut on cached handle ?
        LDREQ   r14, scb_fileptr                ; Check fileptr in that buffer
        TEQEQ   r7, r14, LSR fp
        STREQB  r0, [r8, r14]                   ; Put byte to buffer
        ADDEQ   r14, r14, #1
        STREQ   r14, scb_fileptr                ; Increment fileptr
 [ No26bitCode
        CLRPSR  V_bit + I_bit, r14, EQ          ; Whew ! Allow IRQ here
        Pull    "r7, bcb, scb, fp, pc", EQ      ; Destack all, and punter lr
 |
        Pull    "r7, bcb, scb, fp, lr", EQ      ; Destack all, and punter lr
        BICEQS  pc, lr, #V_bit + I_bit          ; Whew ! Allow IRQ here
 ]

; No need to set modified flag as that will have been done by the BPut that
; set up the BPut cache

 [ debugosbgetcache
 DLINE "BPut Cache miss"
 ]

        Push    "status, fileptr, extent, bufmask"
                                                ; So we can reload $streaminfo
        InitialiseFrame

        AND     bcb, r1, #&FF           ; r1b is file handle
        ADR     r14, streamtable
        LDR     scb, [r14, bcb, LSL #2] ; Get scb^

        ReadStreamInfo bcb              ; bcb invalid for unbuffered streams,
                                        ; but who cares ?

10      EOR     r14, status, #scb_write :OR: scb_modified ; reenter from below
                                        ; Must be set/normally set
        TST     r14, #scb_write :OR: scb_modified :OR: scb_directory :OR: scb_unbuffered :OR: scb_unallocated :OR: scb_EOF_pending
        TSTEQ   r14, #scb_critical
        BNE     %FT85                   ; Any of these set ?

; Buffered BPut

        CMP     bcb, #Nowt              ; No buffer present ?
        BEQ     %FT60

        BIC     r7, fileptr, bufmask    ; Where buffer base needs to be
        LDR     r14, bcb_bufferbase     ; Think of a register, any register ...
        CMP     r14, r7
        BNE     %FT60                   ; Wrong buffer ?

        SUB     r14, r14, #:INDEX: bcb_bufferdata ; Form offset into buffer

40      SUB     r14, fileptr, r14
        STRB    r0, [bcb, r14]          ; Put the byte at buffer%offset
        ADD     fileptr, fileptr, #1    ; Increment file pointer

 [ debugosbput
   DREG status, "New file status = ",cc
   DREG fileptr,", fileptr = "
 ]
        ASSERT  :INDEX:scb_status = 0
        ASSERT  :INDEX:scb_fileptr= 4
        ASSERT  status < fileptr
        STMIA   scb, {status, fileptr}  ; These two always get updated

 [ True ; Always set up cache data! This is reeeeely dangerous
  [ debugosbputcache
 DLINE "Setting up BPut cache"
  ]
        STR     r1, BPut_handle         ; Cache the file data to use next time
        STR     scb, BPut_scb

        LDR     r14, scb_shift
        STR     r14, BPut_shift
        LDR     bcb, scb_bcb            ; Put real bcb^
        LDR     r4, bcb_bufferbase      ; Need real bcb^ so we can load this
        MOV     r14, r4, LSR r14        ; bufferbase >> shift
        STR     r14, BPut_shiftedbase
        ADD     r14, bcb, #:INDEX: bcb_bufferdata
        SUB     r14, r14, r4            ; bcb^ +offset +(fileptr -basefileptr)
        STR     r14, BPut_bufferdata    ; Add fileptr to this to get data addr
 ]

        LDRB    r14, bcb_status         ; Buffer modified
        ORR     r14, r14, #bcb_modified
        STRB    r14, bcb_status

 [ False ; no need to bother now, as checks needed for cache version
        CMP     fileptr, extent         ; Writing past current eof ?
        STRHI   fileptr, scb_extent     ; Write new file extent if so
 ]

 [ No26bitCode
45      ADDS    sp, sp, #localframesize ; VClear
        Pull    "$Proc_RegList, pc"     ; No need to SwiExit as no error
 |
45      ADD     sp, sp, #localframesize
        Pull    "$Proc_RegList, pc",,^  ; No need to SwiExit as no error
 ]


; End of simple BPut case. Now for the boring stuff
; .............................................................................

60      BL      InvalidateBGetCache

        BL      EnsureBufferValidForWrite ; Get bcb^ valid for this fileptr
        LDRVC   r14, bcb_dataoffset     ; Form offset into bcb
        BVC     %BT40                   ; And try again
        B       %FA99


85 ; Complicated BPut - some flags set (or clear), so check 'em

 [ debugosbput
 DLINE "Complicated BPut"
 ]
        TST     status, #scb_unallocated ; Not a stream ?
        BNE     %FT92

        TST     status, #scb_critical   ; Trash the char !
 [ debugosbput
 BEQ %FT00
 DLINE "scb_critical set"
00
 ]
        BNE     %BT45                   ; quick exit

        TST     status, #scb_modified   ; Set modified if not already
 [ debugosbput
 BNE %FT00
 DLINE "Not previously modified; retry after setting"
00
 ]
        ORREQ   status, status, #scb_modified ; NB. Don't do this to UnallocStr
        BEQ     %BT10                   ; And try again

        TST     status, #scb_EOF_pending ; Clear EOF if set
 [ debugosbput
 BEQ %FT00
 DLINE "EOF was set; retry after clearing"
00
 ]
        BICNE   status, status, #scb_EOF_pending ; NB. Don't do this to Unalloc
        BNE     %BT10                   ; And try again

        TST     status, #scb_directory  ; Can't write to directory
        BNE     %FT94

        TST     status, #scb_write      ; Can't write if no permission
        BEQ     %FT96

; Must have branched because unbuffered then

        BL      CallFSBPut              ; Send single byte to file
        STRVC   status, scb_status      ; and exit, writing status if ok

 [ appendhandle
95      SwiExit


99      BL      AppendHandleToError     ; For all errors in BPut
        B       %BA95 ; SwiExit
 |
99      SwiExit
 ]


92      BL      SetErrorChannel
        B       %BA99

94      BL      SetErrorStreamIsDirectory
        B       %BA99

96      BL      SetErrorNotOpenForUpdate
        B       %BA99

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; InvalidateBGetBPutCache
; =======================

; Invalidate cache(s) if handle corresponds

; In    scb^ valid
;
; Preserves C,V. Corrupts N,Z

InvalidateBGetCache ROUT

        Push    "r1, lr"
 [ debugosbget
 DLINE "Invalidate BGet and/or BPut cache"
 ]
        LDRB    r1, scb_exthandle

        LDR     r14, BPut_handle ; As quick as reasonably possible if neither
        TEQ     r14, r1
        BEQ     %FA50           ; Need to kill BPut cache
        LDR     r14, BGet_handle
        TEQ     r14, r1
        Pull    "r1, pc",NE     ; No more to kill


; Only BGet cache to kill if drop thru to here; BPut cache already killed if
; we're branching back to label 20


20      ADR     r1, BGet_shiftedbase

        ASSERT  :INDEX: BGet_shiftedbase = 0 ; Don't have to fart around with expr's

30      LDR     r14, =DeadHandle
        STR     r14, [r1, #:INDEX: BGet_handle] ; Invalidate handle
 [ False ; This is totally unnecessary given invalid handle
        MOV     r14, #-1
        STR     r14, [r1, #:INDEX: BGet_shiftedbase] ; Will give NE on TEQ
        MOV     r14, #32
        STR     r14, [r1, #:INDEX: BGet_shift] ; fileptr shifted out of skull
        addr    r14, UnallocatedStream
        STR     r14, [r1, #:INDEX: BGet_scb]
 ]
        Pull    "r1, pc"                ; Return, either to caller, or below

50      Push    "r1, r2"
        STR     pc, [sp, #4]            ; Make routine return to .+8 or .+12
        B       %FT52
        NOP                             ; for PC+8
        LDR     r14, BGet_handle        ; r1 preserved over call
        TEQ     r14, r1
        Pull    "r1, pc",NE             ; No more to kill

        B       %BT20

52      ADR     r1, BPut_shiftedbase
        B       %BT30

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Ensure both caches invalid

Init_InvalidateBGetCache Entry "r1"

        LDR     r14, =DeadHandle
        STR     r14, BGet_handle        ; Invalidate handles
        STR     r14, BPut_handle
        MOV     r14, #-1
        STR     r14, BGet_shiftedbase   ; Will give NE on TEQ
        STR     r14, BPut_shiftedbase
 [ False ; No need to initialise this as -1 shiftedbase must always give NE
        MOV     r14, #32
        STR     r14, BGet_shift         ; fileptr shifted out of skull
        STR     r14, BPut_shift
 ]
        addr    r14, UnallocatedStream
        STR     r14, BGet_scb
        STR     r14, BPut_scb
        EXIT                            ; We haven't touched flags

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        LTORG

        END
@


4.5
log
@Fixed up a deprecated push (in OSBgetBput), untangled two STM single reg (in OSFile).
Delete unused 'KernelFSW'.
HighFSI
 Retire some crusty definitions
 Reserve OS_FSControl reason codes used by ROL

Version 2.71. Tagged as 'FileSwitch-2_71'
@
text
@d48 2
a49 2
 assert bcb = r8
 assert scb > r8
d52 5
a56 5
 assert :INDEX: BGet_shiftedbase = 0
 assert :INDEX: BGet_bufferdata = 4
 assert :INDEX: BGet_scb        = 8
 assert :INDEX: BGet_shift      = 12
 assert :INDEX: BGet_handle     = 16
d130 1
a130 1
 assert fileptr = r4 ; Not needed anymore
d293 2
a294 2
 assert bcb = r8
 assert scb > r8
d298 4
a301 4
 assert BPut_bufferdata = BPut_shiftedbase + 4  ; r8
 assert BPut_scb        = BPut_shiftedbase + 8  ; scb
 assert BPut_shift      = BPut_shiftedbase + 12 ; fp
 assert BPut_handle     = BPut_shiftedbase + 16 ; r14
d512 1
a512 1
 assert :INDEX: BGet_shiftedbase = 0 ; Don't have to fart around with expr's
@


4.4
log
@    Altered to use shared makefiles and ObjAsm.

Detail:
    As above. No other changes.

Admin:
    Tested in a Lazarus build.

Version 2.57. Tagged as 'FileSwitch-2_57'
@
text
@d526 2
a527 2
 [ {TRUE} ;StrongARM stores PC+8 instead of PC+12 - make either work
50      Push    "r1, pc"                ; Make routine return to .+8 or .+12
a529 1
;
a537 11
 |
50      Push    "r1, pc"                ; Make routine return to .+12
        ADR     r1, BPut_shiftedbase    ; Order means we don't need NOP
        B       %BT30

        LDR     r14, BGet_handle        ; r1 preserved over call
        TEQ     r14, r1
        Pull    "r1, pc",NE             ; No more to kill

        B       %BT20
 ]
@


4.3
log
@  32-bit compatible.
Admin:
  Tested on a 32-bit system; untested on 26-bit, and merge with Ursula branch
  untested.

Version 2.52. Tagged as 'FileSwitch-2_52'
@
text
@d554 1
a554 1
Init_InvalidateBGetCache ENTRY "r1"
@


4.2
log
@Module merged
@
text
@a38 2
 [ :LNOT: AssemblingArthur ; BGet cache section in kernel now, so watch out ...

d58 11
d77 1
a86 9
 | ; cache in kernel

BGetEntry NewSwiEntry "scb, bcb, $streaminfo"

 [ debugosbgetentry
 DREG r1,"OSBGet: handle "
 ]
 ]

d161 4
d167 1
d199 4
d206 1
a278 2
 [ :LNOT: AssemblingArthur ; BGet cache section in kernel now, so watch out ...

d310 4
d316 1
a328 11
 | ; cache in kernel

BPutEntry NewSwiEntry "r7, scb, bcb, $streaminfo"

 [ debugosbputentry
 DREG r0,"OSBPut: byte ",cc
 DREG r1,", handle ",cc
 ]
        SUB     wp, wp, #:INDEX: BPut_shiftedbase ; Gosh, we are SO nasty !
 ]

d394 4
d400 1
d487 2
d499 1
a499 1
        CMP     r14, r1
d502 2
a503 2
        CMP     r14, r1
        Pull    "r1, pc",NE,^   ; No more to kill
d524 1
a524 1
        Pull    "r1, pc",,^             ; Return, either to caller, or below
d532 2
a533 2
        CMP     r14, r1
        Pull    "r1, pc",NE,^           ; No more to kill
d545 2
a546 2
        CMP     r14, r1
        Pull    "r1, pc",NE,^           ; No more to kill
d570 1
a570 1
        EXITS
@


4.1
log
@Initial revision
@
text
@d516 8
d525 5
d539 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a515 8
 [ {TRUE} ;StrongARM stores PC+8 instead of PC+12 - make either work
50      Push    "r1, pc"                ; Make routine return to .+8 or .+12
        B       %FT52
        NOP                             ; for PC+8
;
        LDR     r14, BGet_handle        ; r1 preserved over call
        CMP     r14, r1
        Pull    "r1, pc",NE,^           ; No more to kill
a516 5
        B       %BT20

52      ADR     r1, BPut_shiftedbase
        B       %BT30
 |
a525 1
 ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

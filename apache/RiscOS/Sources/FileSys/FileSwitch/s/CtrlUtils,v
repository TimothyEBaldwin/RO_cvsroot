head	4.8;
access;
symbols
	FileSwitch-2_87:4.8
	FileSwitch-2_86:4.8
	FileSwitch-2_85:4.8
	FileSwitch-2_84:4.8
	FileSwitch-2_83:4.7
	FileSwitch-2_82:4.5
	FileSwitch-2_81:4.5
	FileSwitch-2_80:4.5
	FileSwitch-2_79:4.5
	FileSwitch-2_78:4.5
	FileSwitch-2_77:4.5
	FileSwitch-2_76:4.5
	FileSwitch-2_75:4.5
	FileSwitch-2_74:4.5
	FileSwitch-2_73:4.5
	FileSwitch-2_72:4.5
	FileSwitch-2_71:4.5
	FileSwitch-2_70:4.4
	FileSwitch-2_69:4.4
	FileSwitch-2_68:4.4
	FileSwitch-2_67:4.3
	RO_5_07:4.3
	FileSwitch-2_66:4.3
	FileSwitch-2_65:4.3
	FileSwitch-2_64:4.3
	FileSwitch-2_63:4.3
	FileSwitch-2_62:4.3
	FileSwitch-2_61:4.3
	FileSwitch-2_60:4.3
	FileSwitch-2_59:4.3
	FileSwitch-2_58:4.3
	FileSwitch-2_57:4.3
	FileSwitch-2_56:4.2
	FileSwitch-2_55:4.2
	FileSwitch-2_54:4.2
	FileSwitch-2_53:4.2
	dellis_autobuild_BaseSW:4.2
	FileSwitch-2_52:4.2
	FileSwitch-2_51:4.2
	ROLtd-4_02:4.1.4.3
	FileSwitch-2_45:4.1.4.3
	Ursula_merge:4.1.4.3
	FileSwitch-2_50:4.2
	sbrodie_sedwards_16Mar2000:4.1
	FileSwitch-2_41:4.1
	dcotton_Spin_merge:4.1.7.1
	FileSwitch-2_40:4.1
	dcotton_autobuild_BaseSW:4.3
	FileSwitch-2_39:4.1
	FileSwitch-2_43:4.1.4.3
	Ursula_FileSwitch-2_42:4.1.4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.3
	Ursula_RiscPC:4.1.4.3.0.2
	nicke_FileSwitch-2_29:4.1.7.1
	FileSwitch-2_38:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.3
	UrsulaBuild_FinalSoftload:4.1.4.3
	rthornb_UrsulaBuild-12Aug1998:4.1.4.3
	aglover_UrsulaBuild-05Aug1998:4.1.4.3
	rthornb_UrsulaBuild-29Jul1998:4.1.4.3
	rthornb_UrsulaBuild-22Jul1998:4.1.4.3
	rthornb_UrsulaBuild-15Jul1998:4.1.4.3
	rthornb_UrsulaBuild-07Jul1998:4.1.4.3
	rthornb_UrsulaBuild-17Jun1998:4.1.4.3
	rthornb_UrsulaBuild-03Jun1998:4.1.4.3
	rthornb_UrsulaBuild-27May1998:4.1.4.3
	rthornb_UrsulaBuild-21May1998:4.1.4.3
	rthornb_UrsulaBuild_01May1998:4.1.4.3
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	sproven_241:4.1.4.3
	sproven_2_40:4.1.4.3
	sproven_2_38:4.1.4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2016.05.08.16.56.46;	author jlee;	state Exp;
branches;
next	4.7;
commitid	zhv5KtXcvPVZsH5z;

4.7
date	2015.01.16.00.29.45;	author jlee;	state Exp;
branches;
next	4.6;
commitid	PLSp6MQXUxH0nb6y;

4.6
date	2014.11.11.20.28.14;	author jlee;	state Exp;
branches;
next	4.5;
commitid	NZkC5gAmQsqF7OXx;

4.5
date	2011.11.27.11.56.25;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	K4NCQAqLgaBl0YIv;

4.4
date	2011.08.04.21.27.55;	author jlee;	state Exp;
branches;
next	4.3;
commitid	IhtTEsao98YEReuv;

4.3
date	2001.04.17.11.29.45;	author dcotton;	state Exp;
branches;
next	4.2;

4.2
date	2000.03.20.14.30.46;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.45;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.45;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.50.13;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.03.27.10.46.11;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.03.27.12.42.49;	author mstphens;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.04.07.11.09.49;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.36.31;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.33.08;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Avoid unnecessary remainder calculations
Detail:
  s/CtrlUtils, s/OSGBPB - Avoid unnecessary remainder calculations in DivRem macro
Admin:
  Tested on Cortex-A15


Version 2.84. Tagged as 'FileSwitch-2_84'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    > Sources.CtrlUtils

; FSControl utilities:

; Facilities for constructing full paths
; Facilities for doing catalogues/examines/infos and *accesses
; Facilities for starting up catalogues etc.

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_ConstructFullPathWithoutFSAndSpecial
;
; In    r1 -> tail for directory
;       r2 -> buffer to construct path into
;       r3 = size of buffer
;       r6 = scb^/special field^
;       fscb^
;
; Out
;       r2 advanced to end of string in buffer
;       r3 reduced by length of string inserted, will be sent
;               negative to correct value for full string
;       r4 = special field^ for root fs
;       r5 = root fscb^
;
int_ConstructFullPathWithoutFSAndSpecial Entry
        TEQ     fscb, #Nowt
        BEQ     %FT10
        LDRB    r14, [fscb, #fscb_info]
        TEQ     r14, #0
        BNE     %FT10
        Push    "r1,r6,fscb"
        LDR     fscb, [r6, #:INDEX:scb_fscb]
        LDR     r1, [r6, #:INDEX:scb_path]
        LDR     r6, [r6, #:INDEX:scb_special]
        BL      int_ConstructFullPathWithoutFSAndSpecial
        LDR     r1, [sp]
        LDRB    r1, [r1]
        TEQ     r1, #0
        ADRNE   r1, %FT90                       ; . between path elements, only if next piece of path is non-""
        BLNE    %FT50
        Pull    "r1,r6,fscb"
        BL      %FT50                           ; <path>
        EXIT
10
        ; Got to a real filing system - construct the starting gubbins
        MOV     r4, r6
        MOV     r5, fscb
        CMP     r1, #0
        BLNE    %FT50                           ; <path>
        EXIT

50      ; Secure copy a string into the buffer - always accumulate the length, but
        ; not necessarily copy the string
        Push    "lr"
        RSB     r3, r3, #0
        BL      strlen_accumulate
        RSBS    r3, r3, #0
        Swap    r1, r2, GT
        BLGT    strcpy_advance
        Swap    r1, r2, GT
        Pull    "pc"

90
        DCB     ".", 0
        ALIGN
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_ConstructPathWithoutFS
;
; In    r1 -> tail for directory
;       r2 -> buffer to construct path into
;       r3 = size of buffer
;       r6 = scb^/special field^
;       fscb^
;
; Out   r2 advanced to end of string in buffer
;       r3 reduced by length of string inserted, will be sent
;               negative to correct value for full string
;       r4 = special field^ for root fs
;       r5 = root fscb^
;
int_ConstructPathWithoutFS Entry "r1,r2,r3"

        ; Get to root FS and special
        MOV     r3, #0
        BL      int_ConstructFullPathWithoutFSAndSpecial

        LDMIB   sp, {r2,r3}

        ; #<special>:
        TEQ     r4, #NULL
        TEQNE   r4, #Nowt
        ADRNE   r1, %FT80
        BLNE    %FT50
        MOVNE   r1, r4
        BLNE    %FT50
        ADRNE   r1, %FT85
        BLNE    %FT50

        ; <rest of path>
        LDR     r1, [sp]
        BL      int_ConstructFullPathWithoutFSAndSpecial

        ; Store the return values
        STMIB   sp, {r2,r3}

        EXIT

50      ; Secure copy a string into the buffer - always accumulate the length, but
        ; not necessarily copy the string
        Push    "lr"
        RSB     r3, r3, #0
        BL      strlen_accumulate
        RSBS    r3, r3, #0
        Swap    r1, r2, GT
        BLGT    strcpy_advance
        Swap    r1, r2, GT
        Pull    "pc"

80
        DCB     "#", 0
85
        DCB     ":", 0
        ALIGN

;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_ConstructFullPath
;
; In    r1 -> tail for directory
;       r2 -> buffer to construct path into
;       r3 = size of buffer
;       r6 = scb^/special field^
;       fscb^
;
; Out   r2 advanced to end of string in buffer
;       r3 reduced by length of string inserted, will be sent
;               negative to correct value for full string
;
int_ConstructFullPath Entry "r1,r2,r3,r4,r5"

        ; Get to root FS and special
        MOV     r3, #0
        BL      int_ConstructPathWithoutFS

        LDMIB   sp, {r2,r3}

        TEQ     r5, #Nowt
        BEQ     %FT10

        ; <fs>
        ADD     r1, r5, #fscb_name
        BL      %FT50

10
        ; : (if no special)
        TEQ     r4, #NULL
        TEQNE   r4, #Nowt
        ADREQ   r1, %FT85
        BLEQ    %FT50

        ; <rest of path>
        LDR     r1, [sp]
        BL      int_ConstructPathWithoutFS

        ; Store the return values
        STMIB   sp, {r2,r3}

        EXIT

50      ; Secure copy a string into the buffer - always accumulate the length, but
        ; not necessarily copy the string
        Push    "lr"
        RSB     r3, r3, #0
        BL      strlen_accumulate
        RSBS    r3, r3, #0
        Swap    r1, r2, GT
        BLGT    strcpy_advance
        Swap    r1, r2, GT
        Pull    "pc"

80
        DCB     "#", 0
85
        DCB     ":", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_ConstructFullPathWithError
;
; In    r1 -> tail for directory
;       r2 -> buffer to construct path into
;       r3 = size of buffer
;       r6 = scb^/special field^
;       fscb^
;
; Out   r2 advanced to end of string in buffer
;       r3 reduced by length of string inserted, will be sent
;               negative to correct value for full string
;       Buffer overflow error generated if r3<0 at the end
;
int_ConstructFullPathWithError Entry
        BL      int_ConstructFullPath
        CMP     r3, #0
        addr    r0, ErrorBlock_BuffOverflow, LT
        BLLT    CopyError
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_ConstructFullPathOnStack
;
; In    r1 -> tail
;       r6 = scb/special
;       fscb^
;
; Out
;       stack dropped by enough and hole filled in with path
;
int_ConstructFullPathOnStack Entry "r2,r3,r7"
        MOV     r7, sp
        MOV     r2, #ARM_CC_Mask
        MOV     r3, #0
        BL      int_ConstructFullPath
        RSB     r3, r3, #3+1            ; 3 for round-up, 1 for \0-terminator
        BIC     r3, r3, #3
        SUB     sp, sp, r3
        MOV     r2, sp
        BL      int_ConstructFullPath
        LDMIA   r7, {$Proc_RegList,pc}

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_CatExTitle
;
; In    r1 -> tail for directory
;       r6 = scb^/special field^
;       fscb^ set
;
MaxFilenameSpace * StaticName_length
int_CatExTitle Entry "r0-r5,fscb"
 [ debugcontrol
 DSTRING r1, "CatExTitle tail is "
 DREG r6, "scb^/special field^ is "
 DREG fscb, "fscb is "
 ]
        MOV     r5, sp
        BL      int_ConstructFullPathOnStack

        BL      faff_boot_option_startup_given
        BLVC    int_ReadBootOptionGiven
        MOVVS   sp, r5
        BVS     %FT95

        AND     r2, r2, #3
        TEQ     r2, #0
        ADREQ   r0, dirdotspace0
        TEQ     r2, #1
        ADREQ   r0, dirdotspace1
        TEQ     r2, #2
        ADREQ   r0, dirdotspace2
        TEQ     r2, #3
        ADREQ   r0, dirdotspace3

        MOV     r4, sp
        BL      message_write01
        MOV     sp, r5
        BVS     %FT95

        BL      XOS_NewLine_CopyError

        ; Convert to the root non-MultiFS
        BLVC    fscbscbTofscb
        MOVVC   fscb, r2

 [ debugcontrol
 DREG fscb, "Root fscb is "
 ]

        ; Current directory
        ADRVC   r0, csdspace
        ADRVC   r1, csdspaceu
        MOVVC   r2, #Dir_Current
        BLVC    DisplayDirectoryPath
        BLVC    XOS_NewLine_CopyError

        ; Current directory
        ADRVC   r0, libdotspace
        ADRVC   r1, libdotspaceu
        MOVVC   r2, #Dir_Library
        BLVC    DisplayDirectoryPath
        BLVC    XOS_NewLine_CopyError

        ; User root directory
        ADRVC   r0, urdspace
        ADRVC   r1, urdspaceu
        MOVVC   r2, #Dir_UserRoot
        BLVC    DisplayDirectoryPath
        BLVC    XOS_NewLine_CopyError

        EXIT

90
        ; Not enough stack for cat title
        addr    r0, ErrorBlock_NotEnoughStackForFSEntry
        BL      CopyError
        EXIT

95
        BL      CopyErrorExternal
        EXIT


dirdotspace0    DCB     "DDS0", 0
dirdotspace1    DCB     "DDS1", 0
dirdotspace2    DCB     "DDS2", 0
dirdotspace3    DCB     "DDS3", 0
csdspace        DCB     "CSDS", 0
csdspaceu       DCB     "CSDSU", 0
libdotspace     DCB     "LDS", 0
libdotspaceu    DCB     "LDSU", 0
urdspace        DCB     "URDS", 0
urdspaceu       DCB     "URDSU", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_CatExBody
;
; In    r0 = 0 for Cat, 1 for Ex, 2 for FileInfo
;       r1 -> path tail to supply to fs
;       r2 -> Wildcard to match names to
;       r6 = special field/scb^
;       fscb^
;
; Out   Directory catalogued

 [ CatExLong

; When long file names are in use, we vary the width of columns according to
; the length of the longest filename.  We also adjust the width for the length
; of the file name; we scan the directory twice.  The first time, we simply
; look at the length of the longest name.

CatExMinWidth   *       12              ; minimum amount to allocate for a name (8+'/'+3)

 ]

CatSpaceAdjustForNFS * -36
 [ CatExLong
CatSpace * 320
CatStringSpace * 400
 |
CatSpace * 280
CatStringSpace * 100
 ]

CatExBodyFrame  RN 9
        ^       0, CatExBodyFrame
CatExBody_EntryCount    # 4
CatExBody_ScreenWidth   # 4
CatExBody_LPos          # 4
CatExBody_PreGap        # 4
CatExBody_ItemsLeft     # 4
CatExBody_EntryRover    # 4
 [ CatExLong
CatExBody_EntryWidth    # 4     ; the width, in characters, of the longest filename to be displayed
 ]
CatExBody_FrameSize * :INDEX: @@
CatExBody_CatExType     # 4     ; R0In
CatExBody_PathTail      # 4     ; R1In
CatExBody_WildCard      # 4     ; R2In
CatExBody_R3In          # 4
CatExBody_R4In          # 4
CatExBody_R5In          # 4
CatExBody_Special       # 4     ; R6In
CatExBody_R7In          # 4
CatExBody_R8In          # 4
CatExBody_R9In          # 4

CatExBody_WindBlock
        DCD     VduExt_WindowWidth
        DCD     -1

 [ CatExLong
CatExMaxWidthStr        = "FileSwitch$$NameWidth",0
        ALIGN
 ]

 [ CatExLong
int_CatExBody Entry "r0-r9", CatExBody_FrameSize
 |
int_CatExBody Entry "r0-r9", CatExBody_FrameSize
 ]
        MOV     CatExBodyFrame, sp
        SUB     sp, sp, #CatSpace + CatStringSpace

 [ debugcontrol
        DREG    r0, "int_CatExBody rc",cc
        DSTRING r1, " on ",cc
        DSTRING r2, " with wildcard "
 ]

        MOV     lr, #0
        STR     lr, CatExBody_EntryCount
        STR     lr, CatExBody_LPos
        STR     lr, CatExBody_PreGap

 [ CatExLong
        STR     lr, CatExBody_EntryWidth        ; store the initial maximum width of an entry
 ]
        ADR     r0, CatExBody_WindBlock
        ADR     r1, CatExBody_ScreenWidth
        SWI     XOS_ReadVduVariables
        BVS     %FT80

 [ CatExLong

; *** Here we scan the dir entries, to find the longest name.  Boring, but someone
;     has to do it.

        MOV     r4, #0          ; we don't need to use the stack frame so much here
05
        ; Read another set of directory entries
        MOV     r0, #fsfunc_ReadDirEntriesInfo
        LDR     r1, CatExBody_PathTail
        ADD     r2, sp, #CatStringSpace
        MOV     r3, #CatSpace + CatSpaceAdjustForNFS
        MOV     r5, #CatSpace + CatSpaceAdjustForNFS
        LDR     r6, CatExBody_Special

 [ debugcontrol
 DSTRING r1,"ReadDirEntriesInfo(",cc
 DREG r2,",",cc
 DREG r3,",",cc
 DREG r4,",",cc
 DREG r5,",",cc
 DREG r6,",",cc
 DLINE ")"
 ]
        BL      CallFSFunc_Given
 [ debugcontrol
 DREG r3,"...->(",cc
 DREG r4,",",cc
 DLINE ")"
 ]

        BVS     %FT85

        ; Where no items read?
        TEQ     r3, #0
        BEQ     %FT07

        MOV     r5, r3                          ; r5 used to count down entries in buffer

        ADD     r1, sp, #CatStringSpace         ; point r1 at the buffer

        LDR     r2, CatExBody_EntryWidth        ; width of an entry

        ADD     r1, r1, #&14                    ; point at string
06
        ; deal with another entry

        BL      strlen                          ; (r1->r3) get length of the string

        CMP     r3, r2                          ; is this name longer than the longest?
        MOVHI   r2, r3                          ; if so, then set new longest

        ADD     r1, r1, r3                      ; ptr to next entry
        ADD     r1, r1, #3+1+&14                ; and terminator and round to word, then onto string
        BIC     r1, r1, #3

        SUBS    r5, r5, #1                      ;

        BNE     %BT06                           ; if not then back round loop

        STR     r2, CatExBody_EntryWidth        ; store (maybe updated) width of entry

        CMP     r4, #-1                         ; go to the next stage
        BEQ     %FT08

        B       %BT05                           ; do some more entries

07
        ; No items read

        ; Was it the end?
        CMP     r4, #-1
        BEQ     %FT08                           ; if it was the end, then we can go to the next stage

        ; Wasn't end, so must be buffer overflow
        addr    r0, ErrorBlock_BuffOverflow
        BL      CopyError
        B       %FT85


08
        ; the next stage

        ; find out if there's a system variable with the entry width

        SUB     sp, sp, #16
        MOV     r2, #15
        MOV     r1, sp
        MOV     r3, #0
        MOV     r4, #3                          ; we want to convert it to a string (so that Macros will be sorted)

        ADR     r0, CatExMaxWidthStr            ; variable name

        SWI     XOS_ReadVarVal                  ; get the variable back

 [ debugcontrol
        DREG    r1, "ptr: "
 ]

        MOVVS   r2, #255                        ; maximum limit
        BVS     %FT09                           ; variable not found or too long - ignore it

        CMPS    r4, #1

        LDREQ   r2, [sp]
        BEQ     %FT09


        ; convert its value

        MOV     r0, #0                          ; terminate the string
        STRB    r0, [sp, r2]                    ;

        MOV     r0, #10+(1<<30)                 ; base 10, restrict range 0-255
        MOV     r1, sp

 [ debugcontrol
        DSTRING r1, "string: "
 ]

        SWI     XOS_ReadUnsigned                ; get the value

 [ debugcontrol
        DREG    r2, "converted to: "
 ]

        MOVVS   r2, #255

09      ; here, r2 should contain the max width, or zero
        ADD     sp, sp, #16

        CMPS    r2, #255
        MOVHI   r2, #255

        MOVS    r2, r2
        MOVMI   r2, #12

 [ debugcontrol
        DREG    r2, "init width: "
 ]


        LDR     r3, CatExBody_EntryWidth        ; get the width

        ; now compare screen with and entry width

        LDR     r0, CatExBody_ScreenWidth       ; width of screen

        LDR     r14, CatExBody_CatExType

        TEQ     r14, #0
        SUBEQ   r0, r0, #21-12
        TEQ     r14, #1
        SUBEQ   r0, r0, #63-12
        TEQ     r14, #2
        SUBEQ   r0, r0, #68-12

 [ debugcontrol
        DREG    r0, "width available from screen "

 ]
;       MOV     lr, #&6000
;       STMIA   lr, {r0,r2,r3}

        CMPS    r3, r0
        MOVGT   r3, r0

        CMPS    r3, r2                          ; set the min width
        MOVGT   r3, r2

        CMPS    r3, #CatExMinWidth              ; and if it's <12, make it 12
        MOVLT   r3, #CatExMinWidth

        STR     r3, CatExBody_EntryWidth        ; and now we have a width!

;       STR     r3, [lr, #12]

 [ debugcontrol
 DREG r3, "CatExBody_EntryWidth: "
 ]

        ; now that we've worked out the width, we do the whole thing
        ; again.  we should really optimise for the case where there's
        ; only one batch!

 ]

	MOV	r4, #0
	STR	r4, CatExBody_EntryCount

10
        ; Read another set of directory entries
        MOV     r0, #fsfunc_ReadDirEntriesInfo
        LDR     r1, CatExBody_PathTail
        ADD     r2, sp, #CatStringSpace
        MOV     r3, #CatSpace + CatSpaceAdjustForNFS
        LDR     r4, CatExBody_EntryCount
        MOV     r5, #CatSpace + CatSpaceAdjustForNFS
        LDR     r6, CatExBody_Special
 [ debugcontrol
 DSTRING r1,"ReadDirEntriesInfo(",cc
 DREG r2,",",cc
 DREG r3,",",cc
 DREG r4,",",cc
 DREG r5,",",cc
 DREG r6,",",cc
 DLINE ")"
 ]
        BL      CallFSFunc_Given
 [ debugcontrol
 DREG r3,"...->(",cc
 DREG r4,",",cc
 DLINE ")"
 ]
        BVS     %FT85

        STR     r4, CatExBody_EntryCount
        STR     r3, CatExBody_ItemsLeft

        ; Where no items read?
        TEQ     r3, #0
        BEQ     %FT75


        ADD     r1, sp, #CatStringSpace
20
        ; Fill the buffer on the stack

        ; pick out load, execute, length, Attributes, objecttype, advancing r1 to the object name
        LDMIA   r1!, {r2,r3,r4,r5,r6}
        STR     r1, CatExBody_EntryRover

        ; Is it a match?
        MOV     r0, r2
        LDR     r2, CatExBody_WildCard
        BL      WildMatch
        MOV     r2, r0
        BNE     %FT33

        LDR     r8, CatExBody_CatExType         ; r0 as passed in
        TEQ     r8, #2
        BNE     %FT25
        LDR     lr, [fscb, #fscb_info]
        TST     lr, #fsinfo_fileinfo
        BEQ     %FT25

        ; Filing system gets given FileInfo
        MOV     r7, sp
        BL      strlen
        MOV     r0, r1
        LDR     r1, CatExBody_PathTail
        BL      strlen_accumulate
        ADD     r3, r3, #1+1+3
        BIC     r3, r3, #3
        SUB     sp, sp, r3
        MOV     r2, r1
        MOV     r1, sp
        BL      strcpy_advance
        MOV     r2, #"."
        STRB    r2, [r1], #1
        MOV     r2, r0
        BL      strcpy_advance
        MOV     r0, #fsfunc_FileInfo
        MOV     r1, sp
        LDR     r6, CatExBody_Special
 [ debugcontrol
        DREG    r0, "Use filing system:",cc
        DSTRING r1,",",cc
        DSTRING r6,","
 ]
        BL      CallFSFunc_Given
        MOV     sp, r7
        BVS     %FT85
        B       %FT33

25
        MOV     r0, r6                          ; objecttype
        MOV     r6, sp                          ; Buffer start
        ADD     r7, r6, #CatStringSpace         ; Buffer end

        BL      AdjustObjectTypeReMultiFS
 [ CatExLong
        Push    "r10"
        LDR     r10, CatExBody_EntryWidth       ; get the width of the entry
  [ debugcontrol
        DREG    r10, "Width being used: "
  ]
 ]
        BL      int_CatExItem
 [ CatExLong
        Pull    "R10"
 ]
        BVS     %FT80

        ; Get width of string to output
        MOV     r1, sp
        BL      strlen

        ; Column width in r0
        LDR     r14, CatExBody_CatExType

 [ CatExLong
        LDR     r0, CatExBody_EntryWidth
        TEQ     r14, #0
        ADDEQ   r0, r0, #21-12
        TEQ     r14, #1
        ADDEQ   r0, r0, #63-12
        TEQ     r14, #2
        ADDEQ   r0, r0, #68-12
 |
        TEQ     r14, #0
        MOVEQ   r0, #21                 ; Cat column width
        TEQ     r14, #1
        MOVEQ   r0, #63                 ; Ex column width
        TEQ     r14, #2
        MOVEQ   r0, #68                 ; FileInfo column width
 ]

        ; r6{Spacing going to be needed} =
        ;       ((r7{position across line} + r8{at end of entry} + r0{column width} - 1)/r0{column width})*r0{column width} - r7{position across line}
        LDR     r7, CatExBody_LPos
        LDR     r8, CatExBody_PreGap
        ADD     r6, r7, r8
        ADD     r6, r6, r0
        SUB     r6, r6, #1
        DivRem  r5, r6, r0, r14, norem
        MUL     r6, r0, r5
        SUB     r6, r6, r7

        ; r5{new position if printed on this line} = r6{spacing} + r3{width} + r7{current position}
        ADD     r5, r6, r3
        ADD     r5, r5, r7

        ; If following a name and overflow a line, then do a line feed
        TEQ     r8, #0
        LDR     lr, CatExBody_ScreenWidth
        CMPNE   r5, lr
        BLS     %FT30
        SWI     XOS_NewLine
        BVS     %FT80
        MOV     r7, #0  ; position
        MOV     r8, #0  ; after an entry
        MOV     r6, #0  ; spacing

30
        ; position += spacing + width
        ADD     r7, r7, r6
        ADD     r7, r7, r3

        ; Spew out the spacing
        BL      SpewSpaces

        ; Display the item
        MOVVC   r0, sp
        SWIVC   XOS_Write0
        BVS     %FT80

        ; At end of item indicator (is inter-item gap)
        MOV     r8, #1

        STR     r7, CatExBody_LPos
        STR     r8, CatExBody_PreGap

33
        ; Advance to the next item (skip over the name and round up to a word)
        LDR     r1, CatExBody_EntryRover
        ADD     r3, r1, #1 + 3          ; 1 for the nul terminator, 3 for the rounding
        BL      strlen_accumulate
        BIC     r1, r3, #3

        ; Any more items in this batch?
        LDR     r3, CatExBody_ItemsLeft
        SUBS    r3, r3, #1
        STR     r3, CatExBody_ItemsLeft
        BNE     %BT20

        LDR     r4, CatExBody_EntryCount
        CMP     r4, #-1
        BNE     %BT10

50
        ; Successful completion of the body - tidy up the display

        ; If not at start of line, get to the start of line
        LDR     r8, CatExBody_PreGap
        TEQ     r8, #0
        SWINE   XOS_NewLine
        BVS     %FT80

        B       %FT85

75
        ; No items read

        ; Was it the end?
        LDR     r4, CatExBody_EntryCount
        CMP     r4, #-1
        BEQ     %BT50

        ; Wasn't end, so must be buffer overflow
        addr    r0, ErrorBlock_BuffOverflow
        BL      CopyError
        B       %FT85

80
        ; External error - copy it
        BL      CopyErrorExternal

85
        MOV     sp, CatExBodyFrame
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; SpewSpaces
;
; In    r6 = number of spaces to spew
;
; Out   spaces spewed (r0, VS error return mechanism)
;
SpewSpaces Entry "r6"
        B       %FT20
10
        SWI     XOS_WriteI+space
        EXIT    VS
20
        SUBS    r6, r6, #1
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_CatExItem
;
; In    r0 = object type
;       r1 ->name
;       r2 = load address
;       r3 = execute address
;       r4 = length
;       r5 = attributes
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;       r8 = number of control string:
;               0 - CatFormat
;               1 - ExFormat
;               2 - FileInfoFormat

 [ CatExLong
;       r10 = width of a filename field
 ]
;
; Out   r0, VS error return mechanism

CatFormat       DCB "Cat",0
ExFormat        DCB "Ex",0
FileInfoFormat  DCB "FileInfo",0
        ALIGN

 [ CatExLong
int_CatExItem Entry     "r0-r9"
 |
int_CatExItem Entry     "r0-r9"
 ]
        TEQ     r8, #0
        ADREQ   r0, CatFormat
        TEQ     r8, #1
        ADREQ   r0, ExFormat
        TEQ     r8, #2
        ADREQ   r0, FileInfoFormat
        BL      message_lookup
        BVS     %FT40

        MOV     r8, r0
        LDR     r0, [sp, #Proc_LocalStack + 0*4]

        LDRB    r9, [r8], #1
        CMP     r9, #" "
        BHI     %FT20
        B       %FT30

10
        ; Space between items
        MOV     r0, #space
        BL      int_StuffByteIntoBuffer

20
 [ debugcontrol
        DREG    r9, "Stuffing a number "
 ]

        ; Place the text of this item into the buffer
        LDR     r0, [sp, #Proc_LocalStack + 0*4]        ; r0 in
        TEQ     r9, #"0"
        BLEQ    int_StuffFilenameIntoBuffer
        TEQ     r9, #"1"
        BLEQ    int_StuffAttsIntoBuffer
        TEQ     r9, #"2"
        BLEQ    int_StuffLoadExecIntoBuffer
        TEQ     r9, #"3"
        BLEQ    int_StuffFileSizeIntoBuffer
        TEQ     r9, #"4"
        BLEQ    int_StuffExactLoadExecIntoBuffer
        TEQ     r9, #"5"
        BLEQ    int_StuffExactFileSizeIntoBuffer

        BVS     %FT40

        ; Advance to next item
        LDRB    r9, [r8], #1
        CMP     r9, #space
        BHI     %BT10

30
        ; Terminate the buffer
        MOV     r0, #0
        BL      int_StuffByteIntoBuffer

40
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffFilenameIntoBuffer
;
; In    r1 ->name
;       r6 = buffer
;       r7 = buffer end (beyond end of usable buffer space)

 [ CatExLong
;       r10 = width of field
 ]
;
; Out   r6 advanced or error (r0,VS errors)
;
int_StuffFilenameIntoBuffer Entry "r3"
 [ CatExLong
  [ debugcontrol
	DREG	r10, "stuffing width: "
  ]
        MOV     r3, r10
        BL      int_StuffRPaddedMaybeTruncatedStringIntoBuffer
 |
        MOV     r3, #12
        BL      int_StuffRPaddedStringIntoBuffer
 ]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffAttsIntoBuffer
;
; In    r0 = object type
;       r5 = attributes
;       r6 = buffer
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
int_StuffAttsIntoBuffer Entry "r0,r3", 8
        MOV     r3, sp

        ; D
        TST     r0, #object_directory
        MOVNE   r0, #"D"
        STRNEB  r0, [r3], #1

        ; L
        TST     r5, #locked_attribute
        MOVNE   r0, #"L"
        STRNEB  r0, [r3], #1

        ; W
        TST     r5, #write_attribute
        MOVNE   r0, #"W"
        STRNEB  r0, [r3], #1

        ; R/
        TST     r5, #read_attribute
        MOVNE   r0, #"R"
        STRNEB  r0, [r3], #1
        MOV     r0, #"/"
        STRB    r0, [r3], #1

        ; W
        TST     r5, #public_write_attribute
        MOVNE   r0, #"W"
        STRNEB  r0, [r3], #1

        ; R
        TST     r5, #public_read_attribute
        MOVNE   r0, #"R"
        STRNEB  r0, [r3], #1

        MOV     r0, #0
        STRB    r0, [r3], #1

        MOV     r3, #7
        MOV     r1, sp
        BL      int_StuffRPaddedStringIntoBuffer

        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffLoadExecIntoBuffer
;
; In    r0 = object type
;       r2 = load address
;       r3 = execute address
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
ExDateFormat DCB "ExDt",0
ExLoadExecFormat DCB "ExLdEx",0
        ALIGN

int_StuffLoadExecIntoBuffer Entry "r4,r5"
        ADR     r4, ExDateFormat
        ADR     r5, ExLoadExecFormat
        BL      int_GenStuffLoadExecIntoBuffer
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffExactLoadExecIntoBuffer
;
; In    r0 = object type
;       r2 = load address
;       r3 = execute address
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
FileInfoDateFormat DCB "FileInDt",0
FileInfoLoadExecFormat DCB "FileInLdEx",0
        ALIGN

int_StuffExactLoadExecIntoBuffer Entry "r4,r5"
        ADR     r4, FileInfoDateFormat
        ADR     r5, FileInfoLoadExecFormat
        BL      int_GenStuffLoadExecIntoBuffer
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_GenStuffLoadExecIntoBuffer
;
; In    r0 = object type
;       r2 = load address
;       r3 = execute address
;       r4 = tag of date format
;       r5 = tag of load+exec format
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
DirText DCB "Dr",0
        ALIGN

int_GenStuffLoadExecIntoBuffer Entry "r0-r4",24

        ; Is it a directory?
        TST     r0, #object_directory
        BEQ     %FT10

        ; It's a directory - output "Directory"
        ADR     r0, DirText
        BL      message_lookup
        MOVVC   r1, r0
        B       %FT20

10
        ; Handling of files
        BL      IsFileTyped
        addr    r1, anull, NE   ; No text in the type field if untyped
        BNE     %FT20

        ; It's typed - display type then date
        BL      ExtractFileType
        BL      DecodeFileType
        BVS     %FT90

        STMVCIA sp, {r2,r3}
        MOVVC   r1, #0
        STRVCB  r1, [sp, #8]
        MOVVC   r1, sp

20
        ; Copy the type to the type field
        MOVVC   r3, #9
        BLVC    int_StuffRPaddedStringIntoBuffer
        MOVVC   r0, #space
        BLVC    int_StuffByteIntoBuffer
        BVS     %FT90

        LDR     r2, [sp, #Proc_LocalStack + 2*4]
        LDR     r3, [sp, #Proc_LocalStack + 3*4]
        BL      IsFileTyped
        BNE     %FT40

        ; Display the date. Reverse order of words to correct byte ordering of date
        STR     r3, [sp, #0*4]
        STR     r2, [sp, #1*4]

        MOV     r0, r4
        BL      message_lookup
        BVS     %FT90

 [ debugcontrol
        DSTRING r0,"Looked up date format OK:"
 ]

        ; faff faff faff: copy the string to be nul-terminated
        MOV     r1, r0
        BL      strlen
        ADD     r4, r3, #1 + 3
        BIC     r4, r4, #3
        SUB     sp, sp, r4
        MOV     r2, r1
        MOV     r1, sp
        BL      strcpy          ; nul terminates

        MOV     r3, r1
        ADD     r0, sp, r4
        MOV     r1, r6
        SUB     r2, r7, r6
        SWI     XOS_ConvertDateAndTime
        ADD     sp, sp, r4
        MOVVC   r6, r1

        B       %FT90

40
        ; It's untyped - display as hex

        ; Convert the hex numbers into text
        MOV     r0, r2
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        MOVVC   r0, r3
        ADDVC   r1, sp, #12
        MOVVC   r2, #12
        SWIVC   XOS_ConvertHex8

        ; Now stuff the buffer with the hex numbers
        MOVVC   r0, r5
        MOVVC   r1, r6
        SUBVC   r2, r7, r6
        MOVVC   r4, sp
        ADDVC   r5, sp, #12
        BLVC    message_lookup22_into_buffer
        MOVVC   r6, r1

90
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffFileSizeIntoBuffer
;
; In    r4 = length
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
int_StuffFileSizeIntoBuffer Entry "r0-r2"
        MOV     r0, r4
        MOV     r1, r6
        SUB     r2, r7, r6
        SWI     XOS_ConvertFixedFileSize
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        MOVVC   r6, r1
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffExactFileSizeIntoBuffer
;
; In    r4 = length
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
int_StuffExactFileSizeIntoBuffer Entry "r0-r2"
        MOV     r0, r4
        MOV     r1, r6
        SUB     r2, r7, r6
        SWI     XOS_ConvertHex8
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        MOVVC   r6, r1
        EXIT

 [ {FALSE}
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffLPaddedStringIntoBuffer
;
; In    r1 ->name
;       r3 = required width
;       r6 = buffer
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
; Stuffs the name into the buffer padded to width
;
int_StuffLPaddedStringIntoBuffer Entry "r3"
        BL      strlen_accumulate
        RSBS    r3, r3, #0
        MOVLO   r3, #0
        BL      int_StuffSpacesIntoBuffer
        EXIT    VS
        BL      int_StuffStringIntoBuffer
        EXIT
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffRPaddedStringIntoBuffer
;
; In    r1 ->name
;       r3 = required width
;       r6 = buffer
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
; Stuffs the name into the buffer padded to width
;
int_StuffRPaddedStringIntoBuffer Entry "r3"
        RSB     r3, r3, #0
        BL      strlen_accumulate
        BL      int_StuffStringIntoBuffer
        EXIT    VS
        RSBS    r3, r3, #0
        MOVHI   r3, #0
        BL      int_StuffSpacesIntoBuffer
        EXIT

 [ CatExLong
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffRPaddedMaybeTruncatedStringIntoBuffer
;
; In    r1 ->name
;       r3 = required width
;       r6 = buffer
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
; Stuffs the name into the buffer padded to width.  If the string's
; longer than the buffer width, it truncates it.
;
int_StuffRPaddedMaybeTruncatedStringIntoBuffer Entry "r3,r4"
        MOV     r4, r3
        BL      strlen                  ; string length in R3
        CMP     r3, r4
        BHI     %FT10
        SUB     r3, r3, r4
        BL      int_StuffStringIntoBuffer
        EXIT    VS
        RSBS    r3, r3, #0
        MOVHI   r3, #0
        BL      int_StuffSpacesIntoBuffer
        EXIT

10
        MOV     r3, r4
        BL      int_StuffRTruncatedStringIntoBuffer
        EXIT
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffSpacesIntoBuffer
;
; In    r1 ->name
;       r3 = required number of spaces
;       r6 = buffer
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
; Stuffs the given number of spaces into the buffer
;
int_StuffSpacesIntoBuffer Entry "r0,r3"
        MOV     r0, #space
        B       %FT20
10
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT    VS
20
        SUBS    r3, r3, #1
        BGE     %BT10           ; Signed
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffStringIntoBuffer
;
; In    r1 = string (ctrl char terminated)
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced by string length, or error (r0,VS)
;       terminator not placed into buffer
;
int_StuffStringIntoBuffer Entry "r0,r1"
        B       %FT20
10
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT    VS
20
        LDRB    r0, [r1], #1
        CMP     r0, #space-1
        TEQHI   r0, #delete
        BHI     %BT10
        EXIT

 [ CatExLong
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffRTruncatedStringIntoBuffer
;
; In    r1 = string (ctrl char terminated)
;       r3 = number of characters to print (including '...')
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced by string length, or error (r0,VS)
;       terminator not placed into buffer
;
int_StuffRTruncatedStringIntoBuffer Entry "r0,r1,r3"
        SUB     r3, r3, #3
        B       %FT20
10
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT    VS
20
        SUBS    r3, r3, #1
        BMI     %FT30
        LDRB    r0, [r1], #1
        CMP     r0, #space-1
        TEQHI   r0, #delete
        BHI     %BT10
        EXIT

30 ; just termination to deal with
        MOV     r0, #'.'
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT    VS
        MOV     r0, #'.'
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT    VS
        MOV     r0, #'.'
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT

 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffByteIntoBuffer
;
; In    r0 = byte
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced by 1, or error (r0,VS)
;
int_StuffByteIntoBuffer Entry "r0"
        CMP     r6, r7
        STRLOB  r0, [r6], #1
        EXIT    LO
        addr    r0, ErrorBlock_BuffOverflow
        BL      copy_error
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Process_WildPathnameMustExist
;
; In    r1 -> Wildcarded pathname
;
; Out   r0 = object type of 1st of the objects
;       r1 -> Pathtail for object or directory for enumeration as appropriate
;       r2 = load address of the 1st of the objects
;       r3 = execute address of the 1st of the objects
;       r4 = length of the 1st of the objects
;       r5 = attributes of the 1st of the objects
;       r6 = scb^/special field^
;       r7 = NULL or wildcard for enumeration
;       fscb^
;
; PassedFilename, FullFilename and SpecialField are the relevant locations
; for the various parts after processing.
;
; Will generate an error if the object doesn't exist
;
Process_WildPathnameMustExist Entry
        BL      Process_WildPathname
        EXIT    VS
        TEQ     r0, #object_nothing
        EXIT    NE
        LDR     r1, PassedFilename
        BL      SetMagicPlainNotFound
        BL      JunkFileStrings
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Process_WildPathname
;
; In    r1 -> Wildcarded pathname
;
; Out   r0 = object type of 1st of the objects
;       r1 -> Pathtail for object or directory for enumeration as appropriate
;       r2 = load address of the 1st of the objects
;       r3 = execute address of the 1st of the objects
;       r4 = length of the 1st of the objects
;       r5 = attributes of the 1st of the objects
;       r6 = scb^/special field^
;       r7 = NULL or wildcard for enumeration
;       fscb^
;
; PassedFilename, FullFilename and SpecialField are the relevant locations
; for the various parts after processing.
;
Process_WildPathname ALTENTRY

        ADR     r0, PassedFilename
        MOV     r2, #NULL
        addr    r3, anull
        ADR     r4, FullFilename
        MOV     r5, #0
        ADR     r6, SpecialField
        BL      TopPath_DoBusinessToPath
        EXIT    VS

        ; Reject case with no filing system
        TEQ     fscb, #Nowt
        LDREQ   r1, PassedFilename
        BLEQ    SetMagicPlainNotFound
        BLVS    JunkFileStrings
        EXIT    VS

        ; Is it an absolute directory?
        Push    "r0,r3"
        BL      strlen
        SUB     r3, r3, #1
        LDRB    r0, [r1, r3]
        BL      IsAbsolute
        Pull    "r0,r3"
        BEQ     %FT70

        ; It's a non-absolute, check the source leaf for wildness

        LDR     r7, PassedFilename
 [ debugutil
        DSTRING r7, "PassedFilename = "
 ]
        Push    "r1,r3"
        MOV     r1, r7
        BL      strlen
        ADD     r8, r7, r3
        Pull    "r1,r3"

10
        LDRB    r14, [r8], #-1
        TEQ     r14, #"*"
        TEQNE   r14, #"#"
        BEQ     %FT30
        TEQ     r14, #"."
        TEQNE   r14, #":"       ; blah:blah or blah::blah, neither of which are wildcards
        BEQ     %FT70
        CMP     r8, r7
        BHS     %BT10
        B       %FT70

20
        ; A wildcard char has been found, continue and see whether it's a leaf name
        ; or just a wierd disc name.
        LDRB    r14, [r8], #-1
        TEQ     r14, #"."
        BEQ     %FT40
        TEQ     r14, #":"
        BNE     %FT30
        CMP     r8, r7
        BLO     %FT70           ; It's just :<wierd disc name>
        LDRB    r14, [r8]
        TEQ     r14, #":"
        BEQ     %FT70           ; It's <thing>::<wierd disc name>
        MOV     r14, #":"
        B       %FT40           ; It's <thing>:<wildcard>
30
        CMP     r8, r7
        BHS     %BT20
40
        ; Confirmed wildleaf found with r8 before string or before preceding . or :
        TEQ     r14, #"."
        TEQNE   r14, #":"
        ADDEQ   r7, r8, #2
        ADDNE   r7, r8, #1

        ; Chop off the leaf from the path tail
        BL      strlen
        ADD     r8, r1, r3
50
        LDRB    r14, [r8, #-1]!
        TEQ     r14, #"."
        MOVEQ   r14, #0
        STREQB  r14, [r8]
        EXIT    EQ
        CMP     r8, r1
        BHI     %BT50

        ; If haven't come to a ., but have come to start of string
        ; then must be tail for MultiFS, so chop it there.
        MOV     r14, #0
        STRB    r14, [r8]
        EXIT

70
        ; It's an absolute or non-wildcard, so
        ; let's do it singularly
        MOV     r7, #NULL
        EXIT

        END
@


4.7
log
@Escape some dollars
Detail:
  s/CtrlUtils, s/DirStore, s/FSCtrl2, s/FSPath, s/FileSwBody, s/SysVars - Escape some dollars contained in strings to avoid warnings from objasm
Admin:
  Resulting binary unchanged


Version 2.83. Retagged as 'FileSwitch-2_83'
@
text
@d760 1
a760 1
        DivRem  r5, r6, r0, r14
@


4.6
log
@Fix buffer overflow in *cat when dealing with long paths. Fix spurious errors when examining files with certain load addresses
Detail:
  s/CtrlUtils - Increase MaxFilenameSpace (used to reserve stack space for *cat directory path) from 400 bytes to StaticName_length (i.e. 1K)
  s/FileTypes - Avoid IsFileTyped erroneously returning with V set if r2 is within a certain range (e.g. &7ff00000). Now all exits go via code that ensures V is clear.
Admin:
  Tested on Raspberry Pi


Version 2.83. Tagged as 'FileSwitch-2_83'
@
text
@d404 1
a404 1
CatExMaxWidthStr        = "FileSwitch$NameWidth",0
@


4.5
log
@Fixed up a deprecated push (in OSBgetBput), untangled two STM single reg (in OSFile).
Delete unused 'KernelFSW'.
HighFSI
 Retire some crusty definitions
 Reserve OS_FSControl reason codes used by ROL

Version 2.71. Tagged as 'FileSwitch-2_71'
@
text
@d258 1
a258 1
MaxFilenameSpace * 400
@


4.4
log
@Update to work with zero page relocation
Detail:
  s/FileSwBody, s/FileSwHdr - Try getting DomainId pointer via OS_ReadSysInfo 6 before falling back on legacy address. Store result in workspace for speedy lookup.
  s/FSCommon - Use workspace DomainId pointer
  s/CtrlUtils - Update int_ConstructFullPathWithoutFSAndSpecial to not attempt to append the contents of null string pointers.
  s/FSControl - Update AppendStringIfNotNull to ignore null pointers
  s/LowLevel - Update CallFSFile_Given to not try copying from null special field strings
Admin:
  Tested on rev A2 BB-xM.
  AFAIK the null pointer bugs are all FileSwitch bugs and not bugs in whatever called FileSwitch, although I may be wrong. Not entirely sure how some of the code managed to read strings from null pointers without creating garbage filenames as a result!


Version 2.68. Tagged as 'FileSwitch-2_68'
@
text
@a355 4
        GBLL    CatExLong
CatExLong       SETL    {TRUE}          ; if this is set to TRUE, then *cat, *ex, etc, will attempt
                                        ; to make the display look better with long filenames

@


4.3
log
@    Altered to use shared makefiles and ObjAsm.

Detail:
    As above. No other changes.

Admin:
    Tested in a Lazarus build.

Version 2.57. Tagged as 'FileSwitch-2_57'
@
text
@d63 2
a64 1
        BL      %FT50                           ; <path>
@


4.2
log
@  Ursula branch merged.
Detail:
  Full merge of Ursula branch. Path length limited to 256 if a compile-time
  check says SVCSTK is still &01C02000.

  Fix to bug introduced in RISC OS 3.70 - any errors returned by FSEntry_File
  255 were ignored.
  Some changes from RISC OS Ltd still to come.
Admin:
  Untested.

Version 2.50. Tagged as 'FileSwitch-2_50'
@
text
@d40 1
a40 1
int_ConstructFullPathWithoutFSAndSpecial ENTRY
d97 1
a97 1
int_ConstructPathWithoutFS ENTRY "r1,r2,r3"
d156 1
a156 1
int_ConstructFullPath ENTRY "r1,r2,r3,r4,r5"
d219 1
a219 1
int_ConstructFullPathWithError ENTRY
d237 1
a237 1
int_ConstructFullPathOnStack ENTRY "r2,r3,r7"
d258 1
a258 1
int_CatExTitle ENTRY "r0-r5,fscb"
d412 1
a412 1
int_CatExBody ENTRY "r0-r9", CatExBody_FrameSize
d414 1
a414 1
int_CatExBody ENTRY "r0-r9", CatExBody_FrameSize
d858 1
a858 1
SpewSpaces ENTRY "r6"
d897 1
a897 1
int_CatExItem ENTRY     "r0-r9"
d899 1
a899 1
int_CatExItem ENTRY     "r0-r9"
d973 1
a973 1
int_StuffFilenameIntoBuffer ENTRY "r3"
d997 1
a997 1
int_StuffAttsIntoBuffer ENTRY "r0,r3", 8
d1058 1
a1058 1
int_StuffLoadExecIntoBuffer ENTRY "r4,r5"
d1080 1
a1080 1
int_StuffExactLoadExecIntoBuffer ENTRY "r4,r5"
d1103 1
a1103 1
int_GenStuffLoadExecIntoBuffer ENTRY "r0-r4",24
d1212 1
a1212 1
int_StuffFileSizeIntoBuffer ENTRY "r0-r2"
d1231 1
a1231 1
int_StuffExactFileSizeIntoBuffer ENTRY "r0-r2"
d1254 1
a1254 1
int_StuffLPaddedStringIntoBuffer ENTRY "r3"
d1277 1
a1277 1
int_StuffRPaddedStringIntoBuffer ENTRY "r3"
d1302 1
a1302 1
int_StuffRPaddedMaybeTruncatedStringIntoBuffer ENTRY "r3,r4"
d1334 1
a1334 1
int_StuffSpacesIntoBuffer ENTRY "r0,r3"
d1357 1
a1357 1
int_StuffStringIntoBuffer ENTRY "r0,r1"
d1383 1
a1383 1
int_StuffRTruncatedStringIntoBuffer ENTRY "r0,r1,r3"
d1425 1
a1425 1
int_StuffByteIntoBuffer ENTRY "r0"
d1455 1
a1455 1
Process_WildPathnameMustExist ENTRY
@


4.1
log
@Initial revision
@
text
@d354 21
a375 1
CatSpaceAdjustForNFS * -36
d377 1
d387 3
d406 8
d415 1
d429 4
d438 190
d661 1
d719 7
d727 3
d738 10
d754 1
d884 4
d896 1
d898 3
d966 4
d974 7
d983 1
d1287 34
d1370 44
@


4.1.4.1
log
@Modified to add truncation of long file names in *cat, *info, *fileinfo
*ex and *lex.
@
text
@a353 16

	GBLL	CatExLong
CatExLong	SETL	{TRUE}		; if this is set to TRUE, then *cat, *ex, etc, will attempt
					; to make the display look better with long filenames

 [ CatExLong

; When long file names are in use, we vary the width of columns according to
; the length of the longest filename.  We also adjust the width for the length
; of the file name; we scan the directory twice.  The first time, we simply
; look at the length of the longest name.

CatExMinWidth	*	12		; minimum amount to allocate for a name (8+'/'+3)

 ]

a365 3
 [ CatExLong
CatExBody_EntryWidth	# 4	; the width, in characters, of the longest filename to be displayed
 ]
a381 8
 [ CatExLong
CatExMaxWidthStr	= "FileSwitch$NameWidth",0
	ALIGN
 ]

 [ CatExLong
int_CatExBody ENTRY "r0-r9", CatExBody_FrameSize
 |
a382 1
 ]
a395 4

 [ CatExLong
	STR	lr, CatExBody_EntryWidth	; store the initial maximum width of an entry
 ]
a400 187
 [ CatExLong

; *** Here we scan the dir entries, to find the longest name.  Boring, but someone
;     has to do it.

	MOV	r4, #0		; we don't need to use the stack frame so much here
05
	; Read another set of directory entries
        MOV     r0, #fsfunc_ReadDirEntriesInfo
        LDR     r1, CatExBody_PathTail
        ADD     r2, sp, #CatStringSpace
        MOV     r3, #CatSpace + CatSpaceAdjustForNFS
        MOV     r5, #CatSpace + CatSpaceAdjustForNFS
        LDR     r6, CatExBody_Special

 [ debugcontrol
 DSTRING r1,"ReadDirEntriesInfo(",cc
 DREG r2,",",cc
 DREG r3,",",cc
 DREG r4,",",cc
 DREG r5,",",cc
 DREG r6,",",cc
 DLINE ")"
 ]
        BL      CallFSFunc_Given
 [ debugcontrol
 DREG r3,"...->(",cc
 DREG r4,",",cc
 DLINE ")"
 ]

        BVS     %FT85

        ; Where no items read?
        TEQ     r3, #0
        BEQ     %FT07

	MOV	r5, r3				; r5 used to count down entries in buffer

	ADD	r1, sp, #CatStringSpace		; point r1 at the buffer

	LDR	r2, CatExBody_EntryWidth	; width of an entry

	ADD	r1, r1, #&14			; point at string
06
	; deal with another entry

	BL	strlen				; (r1->r3) get length of the string

	CMP	r3, r2				; is this name longer than the longest?
	MOVHI	r2, r3				; if so, then set new longest

	ADD	r1, r1, r3			; ptr to next entry
	ADD	r1, r1, #3+1+&14		; and terminator and round to word, then onto string
	BIC	r1, r1, #3

	SUBS	r5, r5, #1			;

	BNE	%BT06				; if not then back round loop

	STR	r2, CatExBody_EntryWidth	; store (maybe updated) width of entry

	CMP	r4, #-1				; go to the next stage
	BEQ	%FT08

	B	%BT05				; do some more entries

07
        ; No items read

        ; Was it the end?
        CMP     r4, #-1
        BEQ     %FT08				; if it was the end, then we can go to the next stage

        ; Wasn't end, so must be buffer overflow
        addr    r0, ErrorBlock_BuffOverflow
        BL      CopyError
        B       %FT85


08
	; the next stage

	; find out if there's a system variable with the entry width

	SUB	sp, sp, #16
	MOV	r2, #15
	MOV	r1, sp
	MOV	r3, #0
	MOV	r4, #3	 			; we want to convert it to a string (so that Macros will be sorted)

	ADR	r0, CatExMaxWidthStr		; variable name

	SWI	XOS_ReadVarVal			; get the variable back

 [ debugcontrol
	DREG	r1, "ptr: "
 ]

	MOVVS	r2, #255			; maximum limit
	BVS	%FT09				; variable not found or too long - ignore it

	CMPS	r4, #1

	LDREQ	r2, [sp]
	BEQ	%FT09


	; convert its value

	MOV	r0, #0	   			; terminate the string
	STRB	r0, [sp, r2]			;

	MOV	r0, #10+(1<<30)			; base 10, restrict range 0-255
	MOV	r1, sp

 [ debugcontrol
	DSTRING r1, "string: "
 ]

	SWI	XOS_ReadUnsigned		; get the value

 [ debugcontrol
	DREG	r2, "converted to: "
 ]

	MOVVS	r2, #255

09	; here, r2 should contain the max width, or zero
	ADD	sp, sp, #16

	CMPS	r2, #255
	MOVHI	r2, #255

	MOVS	r2, r2
	MOVMI	r2, #12

 [ debugcontrol
	DREG	r2, "init width: "
 ]


	LDR	r3, CatExBody_EntryWidth	; get the width

	; now compare screen with and entry width

	LDR	r0, CatExBody_ScreenWidth	; width of screen

        LDR     r14, CatExBody_CatExType

	TEQ	r14, #0
	SUBEQ	r0, r0, #21-12
	TEQ	r14, #1
	SUBEQ	r0, r0, #63-12
	TEQ	r14, #2
	SUBEQ	r0, r0, #68-12

 [ debugcontrol
	DREG	r0, "width available from screen "

 ]
;	MOV	lr, #&6000
;	STMIA	lr, {r0,r2,r3}

	CMPS	r3, r0
	MOVGT	r3, r0

	CMPS	r3, r2	      			; set the min width
	MOVGT	r3, r2

	CMPS	r3, #CatExMinWidth		; and if it's <12, make it 12
	MOVLT	r3, #CatExMinWidth

	STR	r3, CatExBody_EntryWidth	; and now we have a width!

;	STR	r3, [lr, #12]

 [ debugcontrol
 DREG r3, "CatExBody_EntryWidth: "
 ]

	; now that we've worked out the width, we do the whole thing
	; again.  we should really optimise for the case where there's
	; only one batch!

 ]

a433 1

a490 7
 [ CatExLong
	Push	"r10"
	LDR	r10, CatExBody_EntryWidth	; get the width of the entry
  [ debugcontrol
	DREG	r10, "Width being used: "
  ]
 ]
a491 3
 [ CatExLong
	Pull	"R10"
 ]
a499 10

 [ CatExLong
	LDR	r0, CatExBody_EntryWidth
	TEQ	r14, #0
	ADDEQ	r0, r0, #21-12
	TEQ	r14, #1
	ADDEQ	r0, r0, #63-12
	TEQ	r14, #2
	ADDEQ	r0, r0, #68-12
 |
a505 1
 ]
a634 4

 [ CatExLong
;	r9 = width of a filename field
 ]
a642 3
 [ CatExLong
int_CatExItem ENTRY     "r0-r9"
 |
a643 1
 ]
a708 4

 [ CatExLong
; 	r10 = width of field
 ]
a712 4
 [ CatExLong
	MOV	r3, r10
        BL      int_StuffRPaddedMaybeTruncatedStringIntoBuffer
 |
a714 1
 ]
a1017 34
 [ CatExLong
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffRPaddedMaybeTruncatedStringIntoBuffer
;
; In    r1 ->name
;       r3 = required width
;       r6 = buffer
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced or error (r0,VS errors)
;
; Stuffs the name into the buffer padded to width.  If the string's
; longer than the buffer width, it truncates it.
;
int_StuffRPaddedMaybeTruncatedStringIntoBuffer ENTRY "r3,r4"
	MOV	r4, r3
        BL      strlen			; string length in R3
	CMP	r3, r4
	BHI	%FT10
	SUB	r3, r3, r4
        BL      int_StuffStringIntoBuffer
        EXIT    VS
        RSBS    r3, r3, #0
        MOVHI   r3, #0
        BL      int_StuffSpacesIntoBuffer
        EXIT

10
	MOV	r3, r4
	BL	int_StuffRTruncatedStringIntoBuffer
	EXIT
 ]

a1066 44
 [ CatExLong
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; int_StuffRTruncatedStringIntoBuffer
;
; In    r1 = string (ctrl char terminated)
;	r3 = number of characters to print (including '...')
;       r6 = Buffer start
;       r7 = buffer end (beyond end of usable buffer space)
;
; Out   r6 advanced by string length, or error (r0,VS)
;       terminator not placed into buffer
;
int_StuffRTruncatedStringIntoBuffer ENTRY "r0,r1,r3"
	SUB	r3, r3, #3
        B       %FT20
10
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT    VS
20
	SUBS	r3, r3, #1
	BMI	%FT30
        LDRB    r0, [r1], #1
        CMP     r0, #space-1
        TEQHI   r0, #delete
        BHI     %BT10
        EXIT

30 ; just termination to deal with
	MOV	r0, #'.'
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT	VS
	MOV	r0, #'.'
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT	VS
	MOV	r0, #'.'
        BL      int_StuffByteIntoBuffer
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        EXIT

 ]
@


4.1.4.2
log
@add code to use pre-allocated blocks rather than stressing SysHeap
  (speed up - see MercifulToSysHeap)
update service handler to Ursula format
@
text
@d355 3
a357 3
        GBLL    CatExLong
CatExLong       SETL    {TRUE}          ; if this is set to TRUE, then *cat, *ex, etc, will attempt
                                        ; to make the display look better with long filenames
d366 1
a366 1
CatExMinWidth   *       12              ; minimum amount to allocate for a name (8+'/'+3)
d370 1
a371 5
 [ CatExLong
CatSpace * 320
CatStringSpace * 400
 |
CatSpace * 280
a372 1
 ]
d383 1
a383 1
CatExBody_EntryWidth    # 4     ; the width, in characters, of the longest filename to be displayed
d402 2
a403 2
CatExMaxWidthStr        = "FileSwitch$NameWidth",0
        ALIGN
d426 1
a426 1
        STR     lr, CatExBody_EntryWidth        ; store the initial maximum width of an entry
d438 1
a438 1
        MOV     r4, #0          ; we don't need to use the stack frame so much here
d440 1
a440 1
        ; Read another set of directory entries
d470 1
a470 1
        MOV     r5, r3                          ; r5 used to count down entries in buffer
d472 1
a472 1
        ADD     r1, sp, #CatStringSpace         ; point r1 at the buffer
d474 1
a474 1
        LDR     r2, CatExBody_EntryWidth        ; width of an entry
d476 1
a476 1
        ADD     r1, r1, #&14                    ; point at string
d478 1
a478 1
        ; deal with another entry
d480 1
a480 1
        BL      strlen                          ; (r1->r3) get length of the string
d482 2
a483 2
        CMP     r3, r2                          ; is this name longer than the longest?
        MOVHI   r2, r3                          ; if so, then set new longest
d485 3
a487 3
        ADD     r1, r1, r3                      ; ptr to next entry
        ADD     r1, r1, #3+1+&14                ; and terminator and round to word, then onto string
        BIC     r1, r1, #3
d489 1
a489 1
        SUBS    r5, r5, #1                      ;
d491 1
a491 1
        BNE     %BT06                           ; if not then back round loop
d493 1
a493 1
        STR     r2, CatExBody_EntryWidth        ; store (maybe updated) width of entry
d495 2
a496 2
        CMP     r4, #-1                         ; go to the next stage
        BEQ     %FT08
d498 1
a498 1
        B       %BT05                           ; do some more entries
d505 1
a505 1
        BEQ     %FT08                           ; if it was the end, then we can go to the next stage
d514 1
a514 1
        ; the next stage
d516 1
a516 1
        ; find out if there's a system variable with the entry width
d518 5
a522 5
        SUB     sp, sp, #16
        MOV     r2, #15
        MOV     r1, sp
        MOV     r3, #0
        MOV     r4, #3                          ; we want to convert it to a string (so that Macros will be sorted)
d524 1
a524 1
        ADR     r0, CatExMaxWidthStr            ; variable name
d526 1
a526 1
        SWI     XOS_ReadVarVal                  ; get the variable back
d529 1
a529 1
        DREG    r1, "ptr: "
d532 2
a533 2
        MOVVS   r2, #255                        ; maximum limit
        BVS     %FT09                           ; variable not found or too long - ignore it
d535 1
a535 1
        CMPS    r4, #1
d537 2
a538 2
        LDREQ   r2, [sp]
        BEQ     %FT09
d541 1
a541 1
        ; convert its value
d543 2
a544 2
        MOV     r0, #0                          ; terminate the string
        STRB    r0, [sp, r2]                    ;
d546 2
a547 2
        MOV     r0, #10+(1<<30)                 ; base 10, restrict range 0-255
        MOV     r1, sp
d550 1
a550 1
        DSTRING r1, "string: "
d553 1
a553 1
        SWI     XOS_ReadUnsigned                ; get the value
d556 1
a556 1
        DREG    r2, "converted to: "
d559 1
a559 1
        MOVVS   r2, #255
d561 2
a562 2
09      ; here, r2 should contain the max width, or zero
        ADD     sp, sp, #16
d564 2
a565 2
        CMPS    r2, #255
        MOVHI   r2, #255
d567 2
a568 2
        MOVS    r2, r2
        MOVMI   r2, #12
d571 1
a571 1
        DREG    r2, "init width: "
d575 1
a575 1
        LDR     r3, CatExBody_EntryWidth        ; get the width
d577 1
a577 1
        ; now compare screen with and entry width
d579 1
a579 1
        LDR     r0, CatExBody_ScreenWidth       ; width of screen
d583 6
a588 6
        TEQ     r14, #0
        SUBEQ   r0, r0, #21-12
        TEQ     r14, #1
        SUBEQ   r0, r0, #63-12
        TEQ     r14, #2
        SUBEQ   r0, r0, #68-12
d591 1
a591 1
        DREG    r0, "width available from screen "
d594 2
a595 2
;       MOV     lr, #&6000
;       STMIA   lr, {r0,r2,r3}
d597 2
a598 2
        CMPS    r3, r0
        MOVGT   r3, r0
d600 2
a601 2
        CMPS    r3, r2                          ; set the min width
        MOVGT   r3, r2
d603 2
a604 2
        CMPS    r3, #CatExMinWidth              ; and if it's <12, make it 12
        MOVLT   r3, #CatExMinWidth
d606 1
a606 1
        STR     r3, CatExBody_EntryWidth        ; and now we have a width!
d608 1
a608 1
;       STR     r3, [lr, #12]
d614 3
a616 3
        ; now that we've worked out the width, we do the whole thing
        ; again.  we should really optimise for the case where there's
        ; only one batch!
d712 2
a713 2
        Push    "r10"
        LDR     r10, CatExBody_EntryWidth       ; get the width of the entry
d715 1
a715 1
        DREG    r10, "Width being used: "
d720 1
a720 1
        Pull    "R10"
d732 7
a738 7
        LDR     r0, CatExBody_EntryWidth
        TEQ     r14, #0
        ADDEQ   r0, r0, #21-12
        TEQ     r14, #1
        ADDEQ   r0, r0, #63-12
        TEQ     r14, #2
        ADDEQ   r0, r0, #68-12
d878 1
a878 1
;       r9 = width of a filename field
d960 1
a960 1
;       r10 = width of field
d967 1
a967 1
        MOV     r3, r10
d1292 5
a1296 5
        MOV     r4, r3
        BL      strlen                  ; string length in R3
        CMP     r3, r4
        BHI     %FT10
        SUB     r3, r3, r4
d1305 3
a1307 3
        MOV     r3, r4
        BL      int_StuffRTruncatedStringIntoBuffer
        EXIT
d1365 1
a1365 1
;       r3 = number of characters to print (including '...')
d1373 1
a1373 1
        SUB     r3, r3, #3
d1380 2
a1381 2
        SUBS    r3, r3, #1
        BMI     %FT30
d1389 1
a1389 1
        MOV     r0, #'.'
d1392 2
a1393 2
        EXIT    VS
        MOV     r0, #'.'
d1396 2
a1397 2
        EXIT    VS
        MOV     r0, #'.'
@


4.1.4.3
log
@Fixed bug whereby *info <filename> (where the filename is not wildcarded)
gives the error "buffer overflow".  Error also fixed for *fileinfo.
@
text
@a624 3
	MOV	r4, #0
	STR	r4, CatExBody_EntryCount

d883 1
a883 1
;       r10 = width of a filename field
a971 3
  [ debugcontrol
	DREG	r10, "stuffing width: "
  ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

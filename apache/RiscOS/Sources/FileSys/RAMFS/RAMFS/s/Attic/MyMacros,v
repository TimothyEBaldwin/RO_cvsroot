head	4.4;
access;
symbols
	RAMFS-2_23:4.3
	RAMFS-2_22:4.3
	RAMFS-2_21:4.3
	RO_5_07:4.3
	RAMFS-2_20:4.3
	RAMFS-2_19a:4.3
	RAMFS-2_19:4.3
	RAMFS-2_18:4.3
	RAMFS-2_17:4.3
	RAMFS-2_16:4.3
	RAMFS-2_15:4.3
	dellis_autobuild_BaseSW:4.2
	Ursula_merge:4.1.4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.3
	nturton_RAMFS-2_11:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	nicke_RAMFS_2_11:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	sproven_RAMFS-2_14:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	sproven_Ursula_2_12:4.1.4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2011.10.14.07.52.39;	author rsprowson;	state dead;
branches;
next	4.3;
commitid	CFv2fFukGmKq4iDv;

4.3
date	2000.11.24.10.59.22;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.30.10.13.08;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.33.47;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.33.47;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.02.07;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.02.11.18.51.51;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.40.42;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.37.06;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Simplify.
Change to use exports from FileCore-3_45.
Delete local copies, which then collapsed the whole module in on itself - RAMFS should really be the simplest of clients, but was built up from a lot of spare body parts. This simplification removes a lot of files.
Delete s.TokHelpSrc - this is autogenerated and was erroneously checked in a few years ago.
Delete unused Help and Syntax.
Try to get the use of BigDir/BigDisc/BigMap more correct.
Tested against FileCore-3_45 and still works.

Version 2.24. Tagged as 'RAMFS-2_24'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >MyMacros

        MACRO
        Border  $r,$g,$b,$cond
        Push    "R0,R1",$cond
        LDR$cond R0, =VIDC
        MOV$cond R1, #bit30
        ORR$cond R1, R1, #$g * 16 + $r
        ORR$cond R1, R1, #$b * 256
        STR$cond R1, [R0]
        Pull    "R0,R1",$cond
        MEND


        MACRO
        nop
        MOV     R0,R0
        MEND


;do an operation with 16 bit width const as an 8 bit width if possible
        MACRO
$lab    Try8    $op,$dreg,$sreg,$const
        LCLA    bit
        LCLA    bits8
        WHILE   ($const:MOD:(1:SHL:(bit+2))=0) :LAND: bit<24
bit     SETA    bit+2
        WEND
        ASSERT  $const :SHR: bit < &10000
bits8   SETA    $const :AND: ( &FF :SHL: bit )
$lab    $op     $dreg,$sreg,#bits8
        [ $const<>bits8
bits8   SETA    $const :AND: ( &FF :SHL: ( bit+8 ) )
        $op     $dreg,$dreg,#bits8
        ]
        MEND


;put address of $dest in $reg
        MACRO
$lab    myaddr  $reg,$dest,$cond
        ASSERT  $reg<>PC
        ASSERT  ($dest-{PC}-8)<&10000
$lab    ADD$cond $reg,PC,#($dest-{PC}-8) :AND: &FF
        ADD$cond $reg,$reg,#($dest-{PC}-4) :AND: &FF00
        MEND


        GBLA    boff
        MACRO
$lab    baddr   $reg,$dest,$cond
        ASSERT  $reg<>PC
boff    SETA    {PC}+8-($dest)
        ASSERT  boff<&10000
$lab    Try8    SUB$cond,$reg,PC,(boff)
        MEND


;put absolute address of $sboff in $reg
        MACRO
$lab    sbaddr  $reg,$sboff,$cond
$lab    Try8    ADD$cond,$reg,SB,(:INDEX:$sboff)
        MEND


        MACRO
$l      Text    $str
$l      =       "$str",0
        ALIGN
        MEND


        MACRO
$lab    aw      $size           ;allocate word aligned
        ASSERT  {VAR} :MOD: 4=0
$lab    #       $size
        MEND


        MACRO
$lab    a4      $size           ;allocate word aligned register relative
        ASSERT  (:INDEX: {VAR}) :MOD: 4=0
$lab    #       $size
        MEND


        MACRO
$lab    bit     $bitnum
$lab    *       1 :SHL: $bitnum
        MEND


        MACRO
        getSB
        LDR     SB, [SB]
        MEND


        MACRO
        Align16 $base
        ASSERT  (.-$base) :MOD: 4 = 0
        WHILE   (.-$base) :MOD: 16 <> 0
        MOV     R0, R0
        WEND
        MEND


;FOLLOWING MACROS ONLY FOR DEBUG


        MACRO
        mess    $cond,$s1,$s2,$s3,$s4,$s5
 [ {FALSE}
        B$cond  %F11
        BAL     %F21
11
        Push    "R0,R1,LR"
        BL      Mess1

        [ :LNOT: IrqDebug
        BNE     %FT15           ;skip if IRQ thread
        ]

        SWI     OS_WriteS
 [ "$s1"="NL"
 = CR,LF
 |
 = "$s1"
 ]
 [ "$s2"=""
 |
  [ "$s2"="NL"
  = CR,LF
  |
  = "$s2"
  ]
  [ "$s3"=""
  |
   [ "$s3"="NL"
   = CR,LF
   |
   = "$s3"
   ]
   [ "$s4"=""
   |
    [ "$s4"="NL"
    = CR,LF
    |
    = "$s4"
    ]
    [ "$s5"=""
    |
     [ "$s5"="NL"
     = CR,LF
     |
     = "$s5"
     ]
    ]
   ]
  ]
 ]
        =       0
        ALIGN
        [ SpoolOff
        BL      SpoolOn
        ]
        Pull    "LR"
15
        RestPSR R0              ;restore PSR
        nop                     ;delay in case mode change
        Pull    "R0,R1,LR"
21
 ]
        MEND

        MACRO
        wrhex   $reg,$cond
        Push    "R0-R3,LR",$cond
        MOV$cond R2,$reg
        BL$cond PHEX
        Pull    "R0-R3,LR",$cond
        MEND


        MACRO
$l      SetBorder  $reg1,$reg2,$red,$green,$blue,$cond
$l      LDR$cond   $reg1,=VIDC
        LDR$cond   $reg2,=&40000000+ $red + $green *16 + $blue *256
        STR$cond   $reg2,[$reg1]
        MEND


        MACRO
        regdump
        mess    ,"R0       R1       R2       R3       R4       R5       R6       R7",NL
        wrhex   R0
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        wrhex   R7
        mess    ,NL,"R8       R9       R10      R11      R12      R13      R14      R15",NL
        wrhex   R8
        wrhex   R9
        wrhex   R10
        wrhex   R11
        wrhex   R12
        wrhex   R13
        wrhex   R14
        wrhex   R15
        mess    ,NL
        MEND

        END
@


4.3
log
@Made 32-bit compatible.

Tested and running on a development board.

Version 2.15. Tagged as RAMFS-2_15.
@
text
@@


4.2
log
@Ursula branch merged
@
text
@a28 28
        MACRO                           ;set some PSR bits
$lab    setpsr     $bits,$tempreg,$cond
$lab    MOV$cond   $tempreg,#$bits
        ORR$cond   $tempreg,$tempreg,PC
        TEQ$cond.P PC,$tempreg
        MEND


        MACRO                           ;clear some PSR bits
$lab    clrpsr     $bits,$tempreg,$cond
$lab    MVN$cond   $tempreg,#$bits
        TST$cond.P $tempreg,PC
        MEND


        MACRO                           ;toggle some PSR bits
$lab    togpsr     $bits,$tempreg,$cond
$lab    MOV$cond   $tempreg,#$bits
        TEQ$cond.P $tempreg,PC
        MEND


        MACRO
$lab    retfiq   $cc
$lab    SUB$cc.S PC, LR, #4
        MEND


d31 1
a31 1
        MOVNV   R0,R0
d117 1
a117 1
        MOVNV   R0, R0
d183 1
a183 1
        TEQP    PC, R0          ;restore PSR
@


4.1
log
@Initial revision
@
text
@d106 1
a106 1
       
d152 1
d155 1
a155 1
 [ {TRUE}
d200 1
a200 1
    ] 
@


4.1.4.1
log
@Modified to take advantage of new FileCore (long filenames).  Previously,
RAMFS used FileCore_FloppyStructure, which can only lay out single-zone
E-format discs.  This meant that with a 16M RAM disc, you have a 4096
byte LFAU (cf harddiscs, where the LFAU would not reach this until the
disc size reached 1G byte).

Modified to use FileCore_LayoutStructure (supports long file names, and
multiple disc zones).  Result:  LFAU on a 16M byte RAM disc is now only
256 bytes, which saves alot of space.  RAMFS makes a choice about the
parameters to pass to LayoutStructure, limiting the number of zones to
16 (this can easily be changed).  It chooses the smallest LFAU possible
given this constraint, with a minimum of 256 bytes.

Also checks FileCore version; on FileCore 2.98 or earlier, long file
names are turned off, so it will work on older versions, and still give
the benifit of smaller LFAUs.

As a further optimisation, RAMFS will now ask for a 64K byte directory
cache to be allocated.  This seems to improve performance, especially
with large directories on long file names.

problems:

Due to a Kernel problem with re-entrancy on OS_ChangeDynamicArea, when
running the new filecore, any attempt to shrink the RAM disc will result
in the kernel generating (not returning) the error SWI &6d656d not known.

This completely stuffs the system, as RAMFS has failed to re-init
properly, and any attempts to call OS_ChangeDynamicArea will fail
because the re-entrancy semaphore will be set.

This needs a Kernel Fix (clearing the re-entrancy flag *before* calling
PostShrink instead of after).  Implications of this need to be considered.

Also, this problem might occur on old FileCore if the RMA is full when
RAMFS is re-initialised, and the number of zones in the free space map
increases when the disc gets smaller.

To do:

Ownership of the RAMFS dynamic area should move to RAMFS, since it makes
it easier for RAMFS to be efficient (re-initing RAMFS every time  the size
of the DA changes is not pretty).

RAMFS dynamic area should be made cacheable on SA.

Now that RAMFS supports large RAM discs better (upto 256 megs is feasible)
the maximum size of the RAM disc should be increased.  To avoid the problem
of soaking up all of the virtual address space, however, the initial max
size of the dynamic area should be the same as present, and if there's any
need to grow it, it should be destroyed and re-created.

Need to determine a 'good' choicde of the dir cache size.

Consider changing to 512 or 256 byte sector size?  Would increase space
efficiency in shared objects.
@
text
@d106 1
a106 1

a151 1

d154 1
a154 1
 [ {FALSE}
d199 1
a199 1
    ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

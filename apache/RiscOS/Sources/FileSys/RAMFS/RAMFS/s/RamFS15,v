head	4.8;
access;
symbols
	RAMFS-2_32:4.8
	RAMFS-2_31:4.8
	RAMFS-2_30:4.6
	RAMFS-2_29:4.6
	RAMFS-2_28:4.6
	RAMFS-2_27:4.6
	RAMFS-2_26:4.5
	RAMFS-2_25:4.5
	RAMFS-2_24:4.4
	RAMFS-2_23:4.3
	RAMFS-2_22:4.3
	RAMFS-2_21:4.3
	RO_5_07:4.3
	RAMFS-2_20:4.3
	RAMFS-2_19a:4.3
	RAMFS-2_19:4.3
	RAMFS-2_18:4.3
	RAMFS-2_17:4.3
	RAMFS-2_16:4.3
	RAMFS-2_15:4.3
	dellis_autobuild_BaseSW:4.2
	Ursula_merge:4.1.4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.3
	nturton_RAMFS-2_11:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.2
	Ursula_RiscPC:4.1.4.2.0.2
	nicke_RAMFS_2_11:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.2
	UrsulaBuild_FinalSoftload:4.1.4.2
	rthornb_UrsulaBuild-12Aug1998:4.1.4.2
	aglover_UrsulaBuild-05Aug1998:4.1.4.2
	rthornb_UrsulaBuild-29Jul1998:4.1.4.2
	rthornb_UrsulaBuild-22Jul1998:4.1.4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.2
	rthornb_UrsulaBuild-07Jul1998:4.1.4.2
	rthornb_UrsulaBuild-17Jun1998:4.1.4.2
	rthornb_UrsulaBuild-03Jun1998:4.1.4.2
	rthornb_UrsulaBuild-27May1998:4.1.4.2
	rthornb_UrsulaBuild-21May1998:4.1.4.2
	sproven_RAMFS-2_14:4.1.4.2
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	sproven_Ursula_2_12:4.1.4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2015.08.31.20.43.05;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	Efjx1ZgfDmosMszy;

4.7
date	2015.08.31.19.38.36;	author jlee;	state Exp;
branches;
next	4.6;
commitid	ikAT0kJgqtiHqszy;

4.6
date	2012.03.19.01.03.53;	author bavison;	state Exp;
branches;
next	4.5;
commitid	1Az1q9lTYiVmLqXv;

4.5
date	2011.10.25.21.39.09;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	bGmj4p92Z9z5iMEv;

4.4
date	2011.10.14.07.52.39;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	CFv2fFukGmKq4iDv;

4.3
date	2000.11.24.10.59.22;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.30.10.13.08;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.33.48;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.33.48;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.02.15;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.02.11.18.51.57;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.05.19.16.40.15;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.40.46;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.37.12;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Use FileCore terminology for clarity
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >RamFS15

        TTL     "FileCore low level operations"

; LowLevelEntry
; -------------
; Called by FileCore to do primitives
; Entry: R1 = subreason
;        R2 = disc address, top 3 bits drive
;        R3 = RAM ptr
;        R4 = length
;        R5 = pointer to disc record
;        R6 = pointer to defect list
; Exit : R12= private word
;        Others subreason dependant
LowLevelEntry ROUT
        LDR     SB, [SB]
        Push    "R0, R1, R5, R6, LR"
      [ Debug3
        DREG    R1,",",cc
        DREG    R2,",",cc
        DREG    R3,",",cc
        DREG    R4,",",cc
        DREG    R5,",",cc
        DREG    R6," ",cc
        DLINE   "*>LowLevel"
      ]

      [ PMP
        MOV     R5, #0
        LDR     LR, BufferSize
      |
        ASSERT  :INDEX: BufferStart = 0
        ASSERT  :INDEX: BufferSize = 4
        LDMIA   SB, {R5, LR}
      ]

        ASSERT  MyMaxSupportedDrive = 0         ; No need to BIC out the drive bits in R2
      [ BigDisc2
        MOV     R2, R2, LSL #MyLog2SectorSize
      ]
        ADDS    R6, R2, R4                      ; end disc add
        SUBNE   R6, R6, #1
        CMPCCS  R6, LR

        ANDCC   LR, R1, #DiscOp_Op_Mask         ; Only Disc Op bits
        CMPCCS  LR, #MyMaxSupportedDiscOp
        MOVCS   R0, #BadParmsErr
        BCS     %FT90

        TEQS    R4, #0
        BEQ     %FT90

        TSTS    R1, #DiscOp_Op_ScatterList_Flag
        ADDEQ   R0, SB, #:INDEX: ScatterPair
        STMEQIA R0, {R3, R4}
        MOVEQ   R3, R0

        ASSERT  DiscOp_ReadSecs > DiscOp_Verify
        ASSERT  DiscOp_WriteSecs > DiscOp_ReadSecs
        CMPS    LR, #DiscOp_ReadSecs
        BEQ     Read
        BLO     Verify
        ; Fall through
Write
        ADD     R1, R5, R2
10
        LDMIA   R3, {R0, R6}
        CMPS    R6, R4
        MOVLS   R2, R6
        MOVHI   R2, R4
        BL      BlockWrite                      ; (R0-R2)
        BVS     %FT95
        ADD     R0, R0, R2
        ADD     R1, R1, R2
        SUBS    R6, R6, R2
        STMIA   R3, {R0, R6}
        ADDEQ   R3, R3, #4*2
        SUBS    R4, R4, R2
        BNE     %BT10
        SUB     R2, R1, R5
        B       %FT40

Verify
        MOV     R5, R2
20
        LDMIA   R3, {R1, R6}
        CMPS    R6, R4
        MOVLS   R2, R6
        MOVHI   R2, R4
        ADD     R5, R5, R2
        ADD     R1, R1, R2
        SUBS    R6, R6, R2
        STMIA   R3, {R1, R6}
        ADDEQ   R3, R3, #4*2
        SUBS    R4, R4, R2
        BNE     %BT20
        MOV     R2, R5

Read
        ADD     R0, R5, R2
30
        LDMIA   R3, {R1, R6}
        CMPS    R6, R4
        MOVLS   R2, R6
        MOVHI   R2, R4
        BL      BlockRead                       ; (R0-R2)
        BVS     %FT95
        ADD     R0, R0, R2
        ADD     R1, R1, R2
        SUBS    R6, R6, R2
        STMIA   R3, {R1, R6}
        ADDEQ   R3, R3, #4*2
        SUBS    R4, R4, R2
        BNE     %BT30
        SUB     R2, R0, R5
40
        LDR     R1, [SP, #4]
        TSTS    R1, #DiscOp_Op_ScatterList_Flag
        LDREQ   R3, ScatterPair
        MOV     R4, #0
90
        CLRV
95
      [ BigDisc2
        MOV     R2, R2, LSR #MyLog2SectorSize
      ]
        STRVS   R0, [SP]
      [ Debug3
        BVC     %FT01
        DREG    R0," ",cc
01
        BVS     %FT01
        DLINE   "         ",cc
01
        DREG    R1," ",cc
        DREG    R2," ",cc
        DREG    R3," ",cc
        DREG    R4," ",cc
        DLINE   "*<LowLevel"
      ]
        Pull    "R0, R1, R5, R6, PC"

        MACRO
        Misc    $str
        ASSERT  MiscOp_$str=(.-MiscTable) :SHR: 2
        B       Do$str
        MEND

; MiscEntry
; ---------
; Called by FileCore to do misc operations
; Entry: R0 = subreason
;        R1 = drive
;        Others dependant on call
; Exit : R12= private word
;        Others subreason dependant
MiscEntry ROUT
      [ Debug4
        DREG    R0,", ",cc
        DREG    R1,", ",cc
        DREG    R2,", ",cc
        DREG    R3,", ",cc
        DREG    R4,", ",cc
        DREG    R5," ",cc
        DLINE   "*>Misc"
      ]
        Push    "LR"
        LDR     SB, [SB]
        CMPS    R0, #MiscOp_FirstUnknown
        BLO     %FT10
        MOV     R0, #BadParmsErr
        SETV    
        B       %FT90
10
        MOV     LR, PC
        ADD     PC, PC, R0, LSL #2
        B       %FT90
MiscTable
        Misc    Mount
        Misc    PollChanged
        Misc    LockDrive
        Misc    UnlockDrive
        Misc    PollPeriod

90
      [ Debug4
        DREG    R0, ", ",cc
        DREG    R1, ", ",cc
        DREG    R2, ", ",cc
        DREG    R3, ", ",cc
        DREG    R4, ", ",cc
        DREG    R5, " ",cc
        DLINE   "<*Misc"
      ]
        Pull    "PC"

; DoMount
; -------
; Misc op 0
; Entry: R1 = drive
;        R2 = disc address (in bytes)
;        R3 = pointer to buffer
;        R4 = length to read into buffer
;        R5 = pointer to disc record to populate (for floppies)
;        R12= private word
DoMount ROUT
        Push    "R0-R2, LR"

        SWI     XOS_ReadRAMFsLimits             ; (->R0,R1)
        SUB     R1, R1, R0                      ; RAM disc size
        STR     R0, BufferStart
        STR     R1, BufferSize

      [ BigDisc2
        MOV     R2, R2, LSL #MyLog2SectorSize
      ]

        MOV     R1, R3
        ASSERT  MyMaxSupportedDrive = 0         ; No need to BIC out the drive bits in R2
      [ PMP
        MOV     R0, R2
      |
        ADD     R0, R0, R2
      ]
        MOV     R2, R4
        BL      BlockRead                       ; (R0,R1,R2)
        BVS     %FT90

      [ BigDisc
        ; when we have big discs, we have a problem - the disc size
        ; field hasn't been filled in.  we copy SkeletonDiscRec instead
        ADR     R0, SkeletonDiscRec
        MOV     R1, R5
        MOV     R2, #SzDiscRecSig2
        BL      BlockMove                       ; (R0,R1,R2)
        BVS     %FT90
        LDR     r0, BufferSize
        STR     r0, [r5, #DiscRecord_DiscSize]
      [ BigDisc2
        ; Ensure the big disc flag is set correctly
        CMP     r0, #512<<20
        LDRB    r0, [r5, #DiscRecord_BigMap_Flags]
        BICLS   r0, r0, #DiscRecord_BigMap_BigFlag
        ORRHI   r0, r0, #DiscRecord_BigMap_BigFlag
        STRB    r0, [r5, #DiscRecord_BigMap_Flags]
      ]   
      |
        ; copy from the record in the map
      [ PMP
        MOV     R0, #ZoneHead
      |
        LDR     R0, BufferStart
        ADD     R0, R0, #ZoneHead
      ]
        MOV     R1, R5
        MOV     R2, #DiscRecSig
        BL      BlockRead
        BVS     %FT90
      ]

        CLRV
90
        STRVS   R0, [SP]
        Pull    "R0-R2, PC"

; DoPollChanged
; -------
; Misc op 1
; Entry: R1 = drive
;        R2 = sequence number
;        R12= private word
; Exit : R2 = sequence number
;        R3 = flags
DoPollChanged
        MOV     R3, #MiscOp_PollChanged_NotChanged_Flag :OR: MiscOp_PollChanged_EmptyWorks_Flag :OR: MiscOp_PollChanged_ChangedWorks_Flag
        ; Fall through
        
; DoLockDrive/DoUnlockDrive
; -------------------------
; Misc op 2/3
; Entry: R1 = drive
;        R12= private word
DoLockDrive
DoUnlockDrive
        MOV     PC, LR

; DoLockDrive/DoUnlockDrive
; -------------------------
; Misc op 4
; Entry: R1 = drive
;        R12= private word
; Exit : R5 = minimum poll period in cs
;        R6 = media type string (unused)
DoPollPeriod
        MOV     R5, #0
        MOV     PC, LR

        END
@


4.7
log
@Add support for the RAMFS dynamic area potentially being a PMP
Detail:
  s/Defns - Add PMP switch to switch between PMP-compatible code and old code. Add BigDisc2 switch to enable my (non-functional) support for RAM discs > 512MB. Fix broken debug switches (Hdr:Proc already gets included somewhere), and add PMP debug switch.
  s/RamFS05 - Replace generic BlockMove function with BlockRead/BlockWrite functions which map in pages on demand, using a basic LRU cache to reduce page table thrashing.
  s/RamFS15 - Updated to use BlockRead/BlockWrite functions, and BigDisc2 support
  s/RamFS50 - BigDisc2 code. PMP-related initialisation.
Admin:
  Tested on Pandaboard, with and without PMP dynamic area
  Note that due to nonfunctional support for RAM discs >512MB, the resize handler in the kernel currently places a 512MB limit on the DA.


Version 2.31. Tagged as 'RAMFS-2_31'
@
text
@d54 1
a54 1
        MOV     R2, R2, LSL #MyMySecSizel2b
d140 1
a140 1
        MOV     R2, R2, LSR #MyMySecSizel2b
d230 1
a230 1
        MOV     R2, R2, LSL #MyMySecSizel2b
@


4.6
log
@  Reworked error code
Detail:
  Now uses Hdr:FileCoreErr rather than containing its own definitions of the
  low-level FileCore error numbers. Autogenerates and exports a new header,
  Hdr:RAMFSErr, and a C version of the same, containing error definitions
  within the RAMFS error block, derived from the error offsets from
  Hdr:FileCoreErr.
Admin:
  No changes to the binary.

Version 2.27. Tagged as 'RAMFS-2_27'
@
text
@d43 4
d50 1
d53 3
d86 2
a87 1
        BL      BlockMove                       ; (R0-R2)
d121 2
a122 1
        BL      BlockMove                       ; (R0-R2)
d139 3
d229 4
d235 3
d239 1
d241 2
a242 1
        BL      BlockMove                       ; (R0,R1,R2)
d251 1
d254 8
d264 3
d269 1
d272 2
a273 1
        BL      BlockMove
d277 2
d281 1
a281 1
; DoMount
@


4.5
log
@Put back as drive 0.
Some unrelated bug tracing had got checked in, was declaring itself as a harddisc and appearing as drive 4.

Version 2.25. Tagged as 'RAMFS-2_25'
@
text
@d54 1
a54 1
        MOVCS   R0, #ErrorNumber_BadParms
d173 1
a173 1
        MOV     R0, #ErrorNumber_BadParms
@


4.4
log
@Simplify.
Change to use exports from FileCore-3_45.
Delete local copies, which then collapsed the whole module in on itself - RAMFS should really be the simplest of clients, but was built up from a lot of spare body parts. This simplification removes a lot of files.
Delete s.TokHelpSrc - this is autogenerated and was erroneously checked in a few years ago.
Delete unused Help and Syntax.
Try to get the use of BigDir/BigDisc/BigMap more correct.
Tested against FileCore-3_45 and still works.

Version 2.24. Tagged as 'RAMFS-2_24'
@
text
@d54 3
a56 5
        BCC     %FT05
        MOV     R0, #ErrorNumber_BadParms
        SETV
        B       %FT95
05
@


4.3
log
@Made 32-bit compatible.

Tested and running on a development board.

Version 2.15. Tagged as RAMFS-2_15.
@
text
@d17 1
a17 1
 LTORG
a18 1
; =============
d20 10
a29 11
; =============

;entry
; R1  reason
; R2  disc address top 3 bits drive
; R3  RAM ptr
; R4  length
; R5  -> disc rec
; R6  -> defect list
; R12 -> private word

d31 44
a74 42
 getSB
 Push    "R0,R1,R5,R6,LR"     ;changing this affects mount Adfs20
 [ Debug3
 DREG  R1,",",cc
 DREG  R2,",",cc
 DREG  R3,",",cc
 DREG  R4,",",cc
 DREG  R5,",",cc
 DREG  R6," ",cc
 DLINE "*>LowLevel"
 ]


 ASSERT :INDEX: BufferStart = 0
 ASSERT :INDEX: BufferSize = 4
 LDMIA  SB, {R5,LR}

 ADDS   R6, R2, R4      ;end disc add
 SUBNE  R6, R6, #1
 CMPCCS R6, LR

 ANDCC  LR, R1, #OpMask ;Only Disc Op bits
 CMPCCS LR, #UnusedOp
 MOVCS  R0, #BadParmsErr
 BCS    %FT95

 TEQS   R4, #0
 BEQ    %FT90

 TSTS   R1, #ScatterBit
 ADDEQ  R0, SB, #:INDEX: ScatterPair
 STMEQIA R0, {R3,R4}
 MOVEQ  R3, R0

 ASSERT ReadSecsOp>VerifyOp
 ASSERT WriteSecsOp>ReadSecsOp
 CMPS   LR, #ReadSecsOp
 BEQ    Read
 BLO    Verify

;Write
 ADD    R1, R5, R2
d76 14
a89 14
 LDMIA  R3, {R0,R6}
 CMPS   R6, R4
 MOVLS  R2, R6
 MOVHI  R2, R4
 BL     BlockMove       ;(R0-R2)
 ADD    R0, R0, R2
 ADD    R1, R1, R2
 SUBS   R6, R6, R2
 STMIA  R3, {R0,R6}
 ADDEQ  R3, R3, #4*2
 SUBS   R4, R4, R2
 BNE    %BT10
 SUB    R2, R1, R5
 B      %FT40
d92 1
a92 1
 MOV    R5, R2
d94 12
a105 12
 LDMIA  R3, {R1,R6}
 CMPS   R6, R4
 MOVLS  R2, R6
 MOVHI  R2, R4
 ADD    R5, R5, R2
 ADD    R1, R1, R2
 SUBS   R6, R6, R2
 STMIA  R3, {R1,R6}
 ADDEQ  R3, R3, #4*2
 SUBS   R4, R4, R2
 BNE    %BT20
 MOV    R2, R5
d108 1
a108 1
 ADD    R0, R5, R2
d110 13
a122 13
 LDMIA  R3, {R1,R6}
 CMPS   R6, R4
 MOVLS  R2, R6
 MOVHI  R2, R4
 BL     BlockMove       ;(R0-R2)
 ADD    R0, R0, R2
 ADD    R1, R1, R2
 SUBS   R6, R6, R2
 STMIA  R3, {R1,R6}
 ADDEQ  R3, R3, #4*2
 SUBS   R4, R4, R2
 BNE    %BT30
 SUB    R2, R0, R5
d124 4
a127 4
 LDR    R1, [SP, #4]
 TSTS   R1, #ScatterBit
 LDREQ  R3, ScatterPair
 MOV    R4, #0
d129 1
a129 1
 BL     ClearV
d131 4
a134 4
 STRVS  R0, [SP]
 [ Debug3
	BVC	%FT01
 DREG  R0," ",cc
d136 2
a137 2
	BVS	%FT01
 DLINE  "         ",cc
d139 13
a151 16
 DREG   R1," ",cc
 DREG   R2," ",cc
 DREG   R3," ",cc
 DREG   R4," ",cc
 DLINE  "*<LowLevel"
 ]
 Pull   "R0,R1,R5,R6,PC"




 MACRO
 Misc   $str
 ASSERT Misc_$str=(.-MiscTable) :SHR: 2
 B      Do$str
 MEND
a152 1
; =========
d154 7
a160 2
; =========

d162 16
a177 16
 [ Debug4
 DREG   R0,", ",cc
 DREG   R1,", ",cc
 DREG   R2,", ",cc
 DREG   R3,", ",cc
 DREG   R4,", ",cc
 DREG   R5," ",cc
 DLINE  "*>Misc"
 ]
 Push   "LR"
 getSB
 CMPS   R0, #Misc_Unused
 BLO    %FT10
 MOV    R0, #BadParmsErr
 BL     SetV
 B      %FT90
d179 3
a181 3
 MOV    LR, PC
 ADD    PC, PC, R0, LSL #2
 B      %FT90
d183 5
a187 5
 Misc   Mount
 Misc   PollChanged
 Misc   LockDrive
 Misc   UnlockDrive
 Misc   PollPeriod
d190 10
a199 11
 [ Debug4
 DREG	R0, ", ",cc
 DREG	R1, ", ",cc
 DREG	R2, ", ",cc
 DREG	R3, ", ",cc
 DREG	R4, ", ",cc
 DREG	R5, " ",cc
 DLINE	"<*Misc"
 ]
 Pull   "PC"

a200 1
; =======
d202 8
a209 11
; =======

;entry
; R1 drive
; R2 disc address
; R3 -> buffer
; R4 length
; R5 -> disc rec to fill in for floppies

;exit R0,V internal error

d211 1
a211 1
 Push   "R0-R2,LR"
d213 28
a240 35
  [ BigDir
 Push 	"R0, R1"
 SWI    XOS_ReadRAMFsLimits     ;(->R0,R1)
 SUB    R1, R1, R0              ;RAM disc size
 STR	R0, BufferStart
 STR	R1, BufferSize
 Pull	"R0, R1"
  ]


 LDR    R0, BufferStart
 MOV    R1, R3
 ADD    R0, R0, R2
 MOV    R2, R4
 BL     BlockMove

 [ BigDir
; when we have big discs, we have a problem - the disc size
; field hasn't been filled in.  we copy SkeletonDiscRec instead
 ADR	R0, SkeletonDiscRec
 MOV    R1, R5
 MOV    R2, #DiscRecSig2
 BL     BlockMove
 LDR	r0, BufferSize
 STR	r0, [r5, #DiscSize]
 |
 LDR    R0, BufferStart
 ADD    R0, R0, #ZoneHead
 MOV    R1, R5
 MOV    R2, #DiscRecSig
 BL     BlockMove
 ]

 CLRV
 Pull   "R0-R2,PC"
d242 2
d245 8
d254 8
a261 1
 MOV    R3, #Drv_NotChanged :OR: Drv_EmptyWorks :OR: Drv_ChangedWorks
d264 1
a264 1
 MOV    PC, LR
d266 7
d274 2
a275 2
 MOV    R5, #0
 MOV    PC, LR
@


4.2
log
@Ursula branch merged
@
text
@a227 1
 ADDS   R0, R0, R2      ;V=0
d229 1
d250 1
d258 1
a258 1
 MOVS   PC, LR
d262 1
a262 1
 MOVS   PC, LR
@


4.1
log
@Initial revision
@
text
@d36 7
a42 7
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 wrhex  R6
 mess   ,"*>LowLevel",NL
d45 1
d133 11
a143 7
 wrhex  R0,VS
 mess   VC,"         "
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 mess   ,"*<LowLevel",NL
d162 7
a168 7
 wrhex  R0
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 mess   ,"*>Misc",NL
d190 7
a196 8
 wrhex  R0
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 mess   ,"*<Misc"
 mess   ,NL
d217 10
d233 10
d248 1
@


4.1.4.1
log
@Modified to take advantage of new FileCore (long filenames).  Previously,
RAMFS used FileCore_FloppyStructure, which can only lay out single-zone
E-format discs.  This meant that with a 16M RAM disc, you have a 4096
byte LFAU (cf harddiscs, where the LFAU would not reach this until the
disc size reached 1G byte).

Modified to use FileCore_LayoutStructure (supports long file names, and
multiple disc zones).  Result:  LFAU on a 16M byte RAM disc is now only
256 bytes, which saves alot of space.  RAMFS makes a choice about the
parameters to pass to LayoutStructure, limiting the number of zones to
16 (this can easily be changed).  It chooses the smallest LFAU possible
given this constraint, with a minimum of 256 bytes.

Also checks FileCore version; on FileCore 2.98 or earlier, long file
names are turned off, so it will work on older versions, and still give
the benifit of smaller LFAUs.

As a further optimisation, RAMFS will now ask for a 64K byte directory
cache to be allocated.  This seems to improve performance, especially
with large directories on long file names.

problems:

Due to a Kernel problem with re-entrancy on OS_ChangeDynamicArea, when
running the new filecore, any attempt to shrink the RAM disc will result
in the kernel generating (not returning) the error SWI &6d656d not known.

This completely stuffs the system, as RAMFS has failed to re-init
properly, and any attempts to call OS_ChangeDynamicArea will fail
because the re-entrancy semaphore will be set.

This needs a Kernel Fix (clearing the re-entrancy flag *before* calling
PostShrink instead of after).  Implications of this need to be considered.

Also, this problem might occur on old FileCore if the RMA is full when
RAMFS is re-initialised, and the number of zones in the free space map
increases when the disc gets smaller.

To do:

Ownership of the RAMFS dynamic area should move to RAMFS, since it makes
it easier for RAMFS to be efficient (re-initing RAMFS every time  the size
of the DA changes is not pretty).

RAMFS dynamic area should be made cacheable on SA.

Now that RAMFS supports large RAM discs better (upto 256 megs is feasible)
the maximum size of the RAM disc should be increased.  To avoid the problem
of soaking up all of the virtual address space, however, the initial max
size of the dynamic area should be the same as present, and if there's any
need to grow it, it should be destroyed and re-created.

Need to determine a 'good' choicde of the dir cache size.

Consider changing to 512 or 256 byte sector size?  Would increase space
efficiency in shared objects.
@
text
@d36 7
a42 7
 DREG  R1,",",cc
 DREG  R2,",",cc
 DREG  R3,",",cc
 DREG  R4,",",cc
 DREG  R5,",",cc
 DREG  R6," ",cc
 DLINE "*>LowLevel"
d132 7
a138 11
	BVC	%FT01
 DREG  R0," ",cc
01
	BVS	%FT01
 DLINE  "         ",cc
01
 DREG   R1," ",cc
 DREG   R2," ",cc
 DREG   R3," ",cc
 DREG   R4," ",cc
 DLINE  "*<LowLevel"
d157 7
a163 7
 DREG   R0,", ",cc
 DREG   R1,", ",cc
 DREG   R2,", ",cc
 DREG   R3,", ",cc
 DREG   R4,", ",cc
 DREG   R5," ",cc
 DLINE  "*>Misc"
d185 8
a192 7
 DREG	R0, ", ",cc
 DREG	R1, ", ",cc
 DREG	R2, ", ",cc
 DREG	R3, ", ",cc
 DREG	R4, ", ",cc
 DREG	R5, " ",cc
 DLINE	"<*Misc"
a218 10
 [ BigDir
; when we have big discs, we have a problem - the disc size
; field hasn't been filled in.  we copy SkeletonDiscRec instead
 ADR	R0, SkeletonDiscRec
 MOV    R1, R5
 MOV    R2, #DiscRecSig2
 BL     BlockMove
 LDR	r0, BufferSize
 STR	r0, [r5, #DiscSize]
 |
a223 1
 ]
@


4.1.4.2
log
@RAMFS doesn't initialise the RAM disc any more, and relies on the kernel
doing so.
@
text
@a44 1

a214 10

  [ BigDir
 Push 	"R0, R1"
 SWI    XOS_ReadRAMFsLimits     ;(->R0,R1)
 SUB    R1, R1, R0              ;RAM disc size
 STR	R0, BufferStart
 STR	R1, BufferSize
 Pull	"R0, R1"
  ]

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

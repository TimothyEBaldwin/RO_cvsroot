head	4.18;
access;
symbols
	RAMFS-2_32:4.18
	RAMFS-2_31:4.17
	RAMFS-2_30:4.15
	RAMFS-2_29:4.14
	RAMFS-2_28:4.13
	RAMFS-2_27:4.12
	RAMFS-2_26:4.11
	RAMFS-2_25:4.10
	RAMFS-2_24:4.9
	RAMFS-2_23:4.8
	RAMFS-2_22:4.7
	RAMFS-2_21:4.7
	RO_5_07:4.7
	RAMFS-2_20:4.7
	RAMFS-2_19a:4.6
	RAMFS-2_19:4.6
	RAMFS-2_18:4.5
	RAMFS-2_17:4.4
	RAMFS-2_16:4.4
	RAMFS-2_15:4.3
	dellis_autobuild_BaseSW:4.2
	Ursula_merge:4.1.4.3
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.4
	nturton_RAMFS-2_11:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.3
	Ursula_RiscPC:4.1.4.3.0.2
	nicke_RAMFS_2_11:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.3
	UrsulaBuild_FinalSoftload:4.1.4.3
	rthornb_UrsulaBuild-12Aug1998:4.1.4.3
	aglover_UrsulaBuild-05Aug1998:4.1.4.3
	rthornb_UrsulaBuild-29Jul1998:4.1.4.3
	rthornb_UrsulaBuild-22Jul1998:4.1.4.3
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.3
	rthornb_UrsulaBuild-07Jul1998:4.1.4.3
	rthornb_UrsulaBuild-17Jun1998:4.1.4.3
	rthornb_UrsulaBuild-03Jun1998:4.1.4.3
	rthornb_UrsulaBuild-27May1998:4.1.4.3
	rthornb_UrsulaBuild-21May1998:4.1.4.3
	sproven_RAMFS-2_14:4.1.4.3
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	sproven_Ursula_2_12:4.1.4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.18
date	2016.05.08.16.59.22;	author jlee;	state Exp;
branches;
next	4.17;
commitid	iTfL4CoXupvTtH5z;

4.17
date	2015.08.31.20.43.05;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	Efjx1ZgfDmosMszy;

4.16
date	2015.08.31.19.38.36;	author jlee;	state Exp;
branches;
next	4.15;
commitid	ikAT0kJgqtiHqszy;

4.15
date	2014.08.18.20.47.16;	author jballance;	state Exp;
branches;
next	4.14;
commitid	K6tY7Qb4PQyBXSMx;

4.14
date	2013.07.13.17.09.19;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	wehm6L2Nv2UYDkXw;

4.13
date	2012.03.21.01.39.16;	author bavison;	state Exp;
branches;
next	4.12;
commitid	543BMnsxAAjwTGXv;

4.12
date	2012.03.19.08.13.08;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	3mmZWaAeMZvs8tXv;

4.11
date	2011.11.20.15.47.05;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	1hJBclyNJUbrv5Iv;

4.10
date	2011.10.25.21.39.09;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	bGmj4p92Z9z5iMEv;

4.9
date	2011.10.14.07.52.40;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	CFv2fFukGmKq4iDv;

4.8
date	2011.10.02.18.02.23;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	uYOa1JZHMXVzPNBv;

4.7
date	2004.06.21.10.12.39;	author mhobbs;	state Exp;
branches;
next	4.6;

4.6
date	2003.04.03.19.00.22;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.22.22.00.01;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2001.05.14.14.43.44;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.11.24.10.59.22;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.30.10.13.08;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.33.48;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.33.48;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.02.18;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.02.11.18.51.59;	author sproven;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.05.19.16.40.16;	author sproven;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.05.21.15.08.39;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.40.47;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.37.13;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.18
log
@Avoid unnecessary remainder calculations
Detail:
  s/RamFS50 - Avoid unnecessary remainder calculation in DivRem macro
Admin:
  Tested on Cortex-A15


Version 2.32. Tagged as 'RAMFS-2_32'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >RamFS50

        TTL     "Initialisation and FS star commands"
; SecPerTrack needs to be larger than 1 to prevent track count
; exceeding its max and 'blowing' part of RAMFSFiler

SkeletonDiscRec         ; fields marked * need filling in
        DCB     MyLog2SectorSize ; Log2SectorSize
        DCB     128     ; SecPerTrk (this is a RAM disc)
        DCB     1       ; Heads
        DCB     DensitySingle  ; Density
        DCB     0       ; * IdLen
        DCB     0       ; * Log2bpmb
        DCB     0       ; Skew
        DCB     0       ; BootOpt
        DCB     0       ; LowSector
        DCB     0       ; * NZones
        DCW     0       ; * ZoneSpare
        DCD     0       ; * Root
        DCD     0       ; * DiscSize
        DCW     0       ; DiscId
        DCB     "RamDisc0",0,0 ; DiscName (padded to 10 bytes)
        DCD     0       ; DiscType
        DCD     0       ; DiscSize2
        DCB     0       ; ShareSize
        DCB     0       ; Flags
      [ BigDir
        DCB     0       ; NZones2
        DCB     0       ; Reserved
        DCD     1       ; DiscVersion
        DCD     BigDirMinSize  ; RootDirSize
      |
        DCB     0       ; NZones2
        DCB     0       ; Reserved
        DCD     0       ; DiscVersion
        DCD     0       ; RootDirSize
      ]
        ASSERT  {PC} - SkeletonDiscRec = SzDiscRecSig2

FullTitle
        DCB     "FileCore%RAM", 0

RAMdiscName
        DCB     "RAM::RamDisc0",0

RamFSString     = "RAM",0
        ALIGN

FSCreateBlock
      [ BigDisc2
        DCB     CreateFlag_NoBigBuf, (CreateFlag_NewErrorSupport + CreateFlag_BigDiscSupport):SHR:8, 0
      |
        DCB     CreateFlag_NoBigBuf, CreateFlag_NewErrorSupport:SHR:8, 0
      ]
        DCB     fsnumber_ramfs
        DCD     RamFSString     - Module_BaseAddr
        DCD     RamFSBootText   - Module_BaseAddr
        DCD     LowLevelEntry   - Module_BaseAddr
        DCD     MiscEntry       - Module_BaseAddr

EmptyDefectList
        DCD     DefectList_End
      [ BigDisc2
        DCD     DefectList_BigMap_End
      ]

InitRAMDisc ROUT
        Push    "R0-R11, LR"
        ADRL    r0, RAMDisc_DismountStr
        SWI     XOS_CLI

        SWI     XOS_ReadRAMFsLimits             ; (->R0,R1)

        SUBS    r6, r1, r0
        BEQ     %FT85

        MOV     r1, #MyMinSupportedDriveSize:SHR:2
        MOV     r2, #0
10
        STR     r2, [r0], #4                    ; Wipe out where the disc record will go
        SUBS    r1, r1, #4
        BNE     %BT10

        SUB     sp, sp, #SzDiscRecSig2

        ADRL    R0, SkeletonDiscRec             ; source

        MOV     R1, SP                          ; dest
        MOV     R2, #SzDiscRecSig2              ; length

20
        LDR     R3, [R0], #4
        STR     R3, [R1], #4
        SUBS    R2, R2, #4
        BNE     %BT20

        STR     R6, [SP, #DiscRecord_DiscSize]  ; store away the size

        MOV     r5, SP
        BL      InitDiscRec                     ; fill in the disc record fields which need calculation

        MOV     r1, #DiscOp_WriteTrk
        SUB     sp, sp, #SzExtendedDiscAddress
        MOV     r2, sp
        ASSERT  MyMaxSupportedDrive = 0
        ASSERT  SzExtendedDiscAddress = 12
        MOV     r0, #0
        MOV     r3, #0
        MOV     r4, #0
        STMIA   r2, {r0,r3,r4}                  ; byte address 0 on drive 0
        MOV     r3, #0
        MOV     r4, #1:SHL:MyLog2SectorSize
        LDR     r8, FileCorePrivate
        SWI     XFileCore_DiscOp64
        ADD     sp, sp, #SzExtendedDiscAddress
        BVC     %FT30
        LDR     lr, [r0, #0]
        TEQ     lr, #ErrorNumber_ModuleBadSWI
        BNE     %FT75

        ORR     r1, r1, r5, LSL #6              ; point to alternative record in r1
        ASSERT  MyMaxSupportedDrive = 0
        MOV     r2, #0                          ; byte address 0 on drive 0
        SWI     XFileCore_DiscOp

        BVS     %FT75

30      MOV     r0, #open_update :OR: open_nopath :OR: open_nodir :OR: open_mustopen
        ADRL    r1, RAMDisc_RAMdiscName         ; name ptr
        SWI     XOS_Find                        ; find it

        BVS     %FT75                           ; failed to do so

        MOV     R3, R0

        MOV     r0, sp
        ADRL    r1, EmptyDefectList             ; no bad block list
        ADRL    r2, RAMDisc_JustDiscName        ; disc name

        SWI     XFileCore_LayoutStructure

        MOV     r0, #0
        MOV     r1, r3
        SWI     XOS_Find

        ADRL    r0, RAMDisc_DismountStr
        SWI     XOS_CLI

75
        ADD     sp, sp, #SzDiscRecSig2

85
        STRVS   r0, [sp]
        Pull    "R0-R11, PC"


RAMDisc_JustDiscName
        DCB     "RamDisc0",0
        ALIGN
RAMDisc_RAMdiscName
        DCB     "RAM::0",0
        ALIGN
RAMDisc_DismountStr
        DCB     "RAM:Dismount :0",0
RAMDisc_MountStr
        DCB     "RAM:mount :0",0
        ALIGN

; InitDiscRec
; -----------
; This routine generates the values in the disc record to suit the
; chosen size of the RAM disc.  We need to work out the values, and
; place them in a disc record
; Entry: R5 = pointer to disc record
; Exit : Disc record updated
InitDiscRec     ROUT
        Push    "R0-R11, LR"

        ; internal register allocation:
        ; r0 = current bitsize
        ; r1 = current zonespare
        ; r2 = current zones
        ; r3 = current idlen
        ; r4 = map allocation bits required to cover disc
        ; r5 = disc record
        ; r6 = number of bits in a zone
        ; r7 = number of allocation bits in the map
        ; r8 = ids per zone
Min_IdLen       *       MyLog2SectorSize + 3 ; min allowed idlen = log2(bits in a sector)
      [ BigMaps
Max_IdLen       *       19      ; max allowed idlen
      |
Max_IdLen       *       15      ; max allowed idlen
      ]
Min_Log2bpmb    *       7       ; min allowed bytes per map bit
Max_Log2bpmb    *       12      ; max allowed bytes per map bit
Min_ZoneSpare   *       32      ; min allowed zonespare
Max_ZoneSpare   *       64      ; max allowed zonespare
Min_Zones       *       1       ; min allowed zones
Max_Zones       *       16      ; max allowed zones

        MOV     r0, #Min_Log2bpmb                ; init log2bpmb

10      ; loop on log2bpmb
        LDR     r4, [r5, #DiscRecord_DiscSize]
        MOV     r4, r4, LSR r0                  ; map bits for disc

        MOV     r1, #Min_ZoneSpare              ; init ZoneSpare
20      ; loop on zonespare

        LDR     lr, [r5, #DiscRecord_Log2SectorSize]
        MOV     r6, #8
        MOV     r6, r6, LSL lr                  ; bits in a zone
        SUB     r6, r6, r1                      ; minus sparebits

        ; choose number of zones to suit

        MOV     r2, #Min_Zones                  ; minimum of one zone
      [ Min_Zones > 1
        MUL     r7, r6, r2
        SUB     r7, r7, #Zone0Bits              ; bits in zone 0
      |
        SUB     r7, r6, #Zone0Bits              ; bits in zone 0
      ]
30      ; loop for zones
        CMP     r7, r4                          ; do we have enough allocation bits yet?
        BHS     %FT35                           ; if we do, then accept this number of zones

        ADD     r7, r7, r6                      ; more map bits
        ADD     r2, r2, #1                      ; and another zone
        CMPS    r2, #Max_Zones
        BLS     %BT30                           ; still ok

        ; here when too many zones; try a higher Log2bpmb
        B       %FT80

35
        ; now we have to choose idlen.  we want idlen to be
        ; the smallest it can be for the disc.

        MOV     r3, #Min_IdLen                  ; minimum value of idlen

40      ; loop for IdLen

        Push    "R0, R1, R2"
        MOV     r0, r6                          ; allocation bits in a zone
        ADD     r1, r3, #1                      ; idlen+1
        DivRem  r8, r0, r1, r2, norem
        Pull    "R0, R1, R2"

        ; check that IdLen is enough for total possible ids
        MOV     r9, #1                          ; work out 1<<idlen
        MOV     r9, r9, LSL r3                  ;

        MUL     lr, r8, r2                      ; total ids needed
        CMPS    lr, r9                          ; idlen too small?
        BHI     %FT60                           ; yes!

        ; we're nearly there.  now work out if the last zone
        ; can be handled correctly.

        SUBS    lr, r7, r4
        BEQ     %FT50

        CMPS    lr, r3                          ; must be at least idlen+1 bits
        BLE     %FT60

        ; check also that we're not too close to the start of the zone

        SUB     lr, r7, r6                      ; get the start of the zone

        SUB     lr, r4, lr                      ; lr = bits available in last zone
        CMPS    lr, r3
        BLE     %FT60

        ; if the last zone is the map zone (ie nzones <= 2), check it's
        ; big enough to hold 2 copies of the map + the root directory
        CMP     r2, #2
        BGT     %FT50

        LDR     r10, [r5, #DiscRecord_Log2SectorSize]
        MOV     r9, #2
        MOV     r10, r9, LSL r10
        MUL     r10, r2, r10                    ; r10 = 2 * map size (in disc bytes)
        MOV     r11, #1
        RSB     r11, r11, r11, LSL r0           ; r11 = LFAU-1 (in disc bytes), for rounding up
        LDR     r9, [r5, #DiscRecord_BigDir_DiscVersion]
        TEQ     r9, #0
        ADDEQ   r10, r10, #NewDirSize           ; short filename: add dir size to map
        BEQ     %FT45

        ; long filename case - root directory is separate object in map zone
        ADD     r9, r11, #BigDirMinSize
        MOV     r9, r9, LSR r0                  ; r9 = directory size (in map bits)
        CMPS    r9, r3
        ADDLE   r9, r3, #1                      ; ensure at least idlen+1
        SUBS    lr, lr, r9
        BLT     %FT60
        ; fall through to consider map object

45      ADD     r10, r10, r11
        MOV     r10, r10, LSR r0                ; r10 = map (+dir) size (in map bits)
        CMPS    r10, r3
        ADDLE   r10, r3, #1                     ; ensure at least idlen+1
        CMPS    lr, r10
        BLT     %FT60

50      ; we've found a result - fill in the disc record!

        STRB    r3,[r5, #DiscRecord_IdLen]      ; => set idlen

        MOV     r1, r1, LSL #16
        ORR     r1, r1, r2, LSL #8
        STR     r1, [r5, #DiscRecord_ZoneSpare - 2]  ; => set ZoneSpare and NZones

        STRB    r0, [r5, #DiscRecord_Log2bpmb]  ; => set Log2bpmb

        LDR     lr, [r5, #DiscRecord_BigDir_DiscVersion]
        TEQ     lr, #1                          ; do we have long filenames?
        BNE     %FT01

        ; the root dir's ID is the first available ID in the middle
        ; zone of the map

        MOVS    r2, r2, LSR #1                  ; zones/2

        MULNE   lr, r2, r8                      ; *idsperzone
        MOVEQ   lr, #3                          ; if if zones/2=0, then only one zone, so the id is 3 (0,1,2 reserved)

        MOV     lr, lr, LSL #8                  ; construct full indirect disc address
        ORR     lr, lr, #1                      ; with sharing offset of 1

        B       %FT02
01
        ; not long filenames
        ; root dir is &2nn where nn is ((zones<<1)+1)

        MOV     lr, r2, LSL #1
        ADD     lr, lr, #1
        ADD     lr, lr, #&200
02
        STR     lr, [r5, #DiscRecord_Root]      ; => set Root

        ; other fields in the disc record are fixed-value
        B       %FT90

60      ; NEXT IdLen
        ADD     r3, r3, #1
        CMPS    r3, #Max_IdLen
        BLS     %BT40

70      ; NEXT ZoneSpare
        ADD     r1, r1, #1
        CMPS    r1, #Max_ZoneSpare
        BLS     %BT20

80      ; NEXT Log2bpmb
        ADD     r0, r0, #1
        CMPS    r0, #Max_Log2bpmb               ; is it too much?
        BLS     %BT10                           ; back around

90
      [ BigDisc2
        ; Ensure the big disc flag is set correctly
        LDR     r4, [r5, #DiscRecord_DiscSize]
        CMP     r4, #512<<20
        LDRB    r4, [r5, #DiscRecord_BigMap_Flags]
        BICLS   r4, r4, #DiscRecord_BigMap_BigFlag
        ORRHI   r4, r4, #DiscRecord_BigMap_BigFlag
        STRB    r4, [r5, #DiscRecord_BigMap_Flags]
      ]   
        Pull    "R0-R11, PC"

; InitEntry
; ---------
; Module initialisation
InitEntry ROUT
        Push    "R0-R11, SB, LR"

      [ Debug3
        DLINE   "RAMFS Init"
      ]

        SWI     XOS_ReadRAMFsLimits             ; (->R0,R1)
        SUB     R6, R1, R0                      ; RAM disc size
        Push    "R0"

        MOV     R9, #0                          ; error flag
        MOV     R10, #1                         ; init error reporting control flag
        MOV     R11, SB

        MOV     R0, #ModHandReason_Claim
        MOV     R3, #:INDEX: WorkSize
        SWI     XOS_Module                      ; claim workspace

        Pull    "R4"                            ; -> RAM disc start
        BVS     %FT95
        MOV     SB, R2

        ; OSS Flag that the message file is closed.
        MOV     r0, #0
        STR     r0, message_file_open
 [ PMP
        STR     r0, LRUCache
 ]

        CMPS    R6, #MyMinSupportedDriveSize    ; Only initialise if at least this must RAM
        BCC     %FT60

        ASSERT  :INDEX: BufferStart=0
        ASSERT  :INDEX: BufferSize=4
        STMIA   SB, {R4,R6}

        STR     R11, MyPrivate

        STR     SB, [R11]

 [ PMP
        ; Check if PMP is in use
        MOV     r0, #24
        MOV     r1, #ChangeDyn_RamFS
        SWI     XOS_DynamicArea
        BVS     %FT17
        TST     r4, #1:SHL:20
        BEQ     %FT17
        ; PMP enabled - store details and init the LRU cache
        MOV     r5, r5, LSR #12
        STR     r4, PageFlags                   ; These are the full DA flags rather than just the page flags, but the kernel will mask them down as necessary
        STR     r5, PMPSize
        MOV     r0, #ModHandReason_Claim
        MOV     r3, r5, LSL #3
        SWI     XOS_Module
        BVS     %FT85
        STR     r2, LRUCache
        ; Init LRU cache
        SUB     r0, r5, #1                      ; DA logical page index
        MOV     r1, #-1                         ; No physical page mapped there
10
        STMIA   r2!, {r0, r1}
        SUBS    r0, r0, #1
        BGE     %BT10
        ; Unmap anything which is already there, to ensure state matches cache
        MOV     r0, #0
        MOV     r2, #-1
        MOV     r4, #0
        Push    "r0,r2,r3"
        MOV     r0, #22
15
        MOV     r2, sp
        MOV     r3, #1
        SWI     XOS_DynamicArea
        BVS     %FT16
        ADD     r4, r4, #1
        CMP     r4, r5
        STRLT   r4, [sp]
        BLT     %BT15
16
        ADD     sp, sp, #12
17
 ]

        ADR     R0, FSCreateBlock
        ADRL    R1, Module_BaseAddr
        LDR     r2, MyPrivate
      [ BigDir
        ASSERT  MyMaxSupportedDrive = 0
        MOV     R3, #1                          ; 1 floppy, 0 fixed disc, default drive 0, dir
        MOV     R4, #65536                      ; dir cache size
      |
        ASSERT  MyMaxSupportedDrive = 0
        MOV     R3, #1                          ; 1 floppy, 0 fixed discs, default drive 0, dir
        MOV     R4, #0                          ; dir cache size
      ]
        MOV     R5, #0                          ; File cache buffers
        MOV     R6, #0                          ; fixed disc sizes
        SWI     XFileCore_Create                ; (R0-R6->R0-R2,V)
        BVS     %FT85                           ; Filecore_Create failed

        STR     R0, FileCorePrivate

        BL      InitRAMDisc                     ; just in case the Kernel hasn't done it

        CLRV
        Pull    "R0-R11, SB, PC"

60
        ; OSS Error handling code for "Ram Disc too small"
        ADR     R0, ErrSizeTooSmall
        MOV     R1, #0                          ; No %0
        BL      copy_error_one                  ; Always sets the V bit
        B       %FT85

ErrSizeTooSmall
        DCD     ErrorNumber_RAMDiscTooSmall
        DCB     "SizeErr", 0
        ALIGN

; InitEntry
; ---------
; Module finalisation
DieEntry
        Push    "R0-R11, SB, LR"

      [ Debug3
        DLINE   "RAMFS Die"
      ]
        LDR     SB, [SB]
        MOV     R9, #0                          ; error flag
        MOV     R10, #0                         ; die error reporting control flag

        ; Dismount the disk so filer windows close
        MOV     R1, #Service_DiscDismounted
        ADRL    R2, RAMdiscName                 ; Disc to dismount
        SWI     XOS_ServiceCall                 ; Dismount RAM

      [ Debug3
        DLINE   "Killing FileCore%RAM parent"
      ]

        MOV     R0, #ModHandReason_Delete
        ADRL    R1, FullTitle
        SWI     XOS_Module
      [ Debug3
        DLINE   "Killed parent"
      ]

85
        ; OSS Close the Messages file if it is open, and then flag it as closed.
        ; OK so even if it is closed I flag it as closed, but this is hardly speed
        ; critical code.
        MOVVS   r9, r0                          ; Hang onto any earlier error
        LDR     r0, message_file_open
        TEQ     r0, #0
        ADRNE   r0, message_file_block
        SWINE   XMessageTrans_CloseFile
        MOV     r0, #0
        STR     r0, message_file_open

      [ PMP
        MOV     R0, #ModHandReason_Free
        LDR     R2, LRUCache
        TEQ     R2, #0
        SWINE   XOS_Module
      ]

        MOV     R0, #ModHandReason_Free
        MOV     R2, SB
        SWI     XOS_Module                      ; Free workspace
      [ Dev
        BVC     %FT87
        DREG    R0, "Heap error "
87
      ]
95
        MOVVS   R9, R0
      [ Dev
        BVC     %FT97
        DREG    R9, "Error ",cc
        DREG    R10, " flag ="
97
      ]

        ADDS    R0, R9, #0                      ; clear V
        MOVNES  R10, R10                        ; only error on init
        Pull    "R0-R11, SB, PC",EQ

        SETV
        ADD     SP, SP, #4
        Pull    "R1-R11, SB, PC"


; InitEntry
; ---------
; Module SWI despatch
SwiEntry ROUT
        Push    "SB, LR"
        CLRPSR  I_bit, LR                       ; re-enable interrupts
        LDR     SB, [SB]
        CMPS    R11, #(SwiTableEnd - SwiTableStart) / 4
        BHS     SwiUnknown
        MOV     LR, PC
        ADD     PC, PC, R11,LSL #2
        B       %FT10
SwiTableStart
        B       DoSwiRetryDiscOp
        B       SwiUnknown
        B       DoSwiDrives
        B       DoSwiFreeSpace
        B       SwiUnknown
        B       DoSwiDescribeDisc
        B       DoSwiRetryDiscOp64
SwiTableEnd

SwiUnknown
        ; Bad SWI
        Push    "r1"
        ADRL    r0, ErrorBlock_ModuleBadSWI
        ADRL    r1, RamFSTitle
        BL      copy_error_one
        Pull    "r1"
10
        Pull    "SB, PC"

DoSwiRetryDiscOp ROUT
        Push    "R8, LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_DiscOp
        Pull    "R8, PC"

DoSwiRetryDiscOp64 ROUT
        Push    "R8, LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_DiscOp64
        Pull    "R8, PC"

DoSwiDrives ROUT
        Push    "R8, LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_Drives
        Pull    "R8, PC"

DoSwiFreeSpace ROUT
        Push    "R8, LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_FreeSpace
        Pull    "R8, PC"

DoSwiDescribeDisc ROUT
        Push    "R8, LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_DescribeDisc
        Pull    "R8, PC"


        MakeInternatErrorBlock  ModuleBadSWI,,BadSWI

SwiNames ROUT
        =  "RamFS",0
        =  "DiscOp",0
        =  "NOP",0
        =  "Drives",0
        =  "FreeSpace",0
        =  "NOP",0
        =  "DescribeDisc",0
        =  "DiscOp64",0
        =  0
        ALIGN

        MACRO
        ComEntry  $Com,$MinArgs,$MaxArgs,$GsTransBits,$HiBits
        ASSERT  $MinArgs<=$MaxArgs
Com$Com DCB     "$Com",0
        ALIGN
        DCD     Do$Com - Module_BaseAddr
        DCB     $MinArgs
        DCB     $GsTransBits
        DCB     $MaxArgs
        DCB     $HiBits
        DCD     Syn$Com - Module_BaseAddr
        DCD     Help$Com - Module_BaseAddr
        MEND

ComTab                                          ; general star commands
        ComEntry  Ram, 0, 0, 0, International_Help:SHR:24

        DCB     0
        ALIGN

; DoRam
; ---------
; Somebody typed *RAM
DoRam
        Push    "LR"
        MOV     R0, #FSControl_SelectFS
        ADRL    R1, RamFSString
        SWI     XOS_FSControl
        Pull    "PC"

        END
@


4.17
log
@Use FileCore terminology for clarity
@
text
@d262 1
a262 1
        DivRem  r8, r0, r1, r2
@


4.16
log
@Add support for the RAMFS dynamic area potentially being a PMP
Detail:
  s/Defns - Add PMP switch to switch between PMP-compatible code and old code. Add BigDisc2 switch to enable my (non-functional) support for RAM discs > 512MB. Fix broken debug switches (Hdr:Proc already gets included somewhere), and add PMP debug switch.
  s/RamFS05 - Replace generic BlockMove function with BlockRead/BlockWrite functions which map in pages on demand, using a basic LRU cache to reduce page table thrashing.
  s/RamFS15 - Updated to use BlockRead/BlockWrite functions, and BigDisc2 support
  s/RamFS50 - BigDisc2 code. PMP-related initialisation.
Admin:
  Tested on Pandaboard, with and without PMP dynamic area
  Note that due to nonfunctional support for RAM discs >512MB, the resize handler in the kernel currently places a 512MB limit on the DA.


Version 2.31. Tagged as 'RAMFS-2_31'
@
text
@d22 1
a22 1
        DCB     MyMySecSizel2b ; Log2SectorSize
d126 1
a126 1
        MOV     r4, #(1<<MyMySecSizel2b)
d203 1
a203 1
Min_IdLen       *      MyMySecSizel2b+3    ; min allowed idlen = log2 sectorsize+3
@


4.15
log
@Adjust RAMFS to permit larger RAM disc formatting
Detail:
Increased the number of sectors per track in the disc record in s.RamFS50
This prevents the track count getting too large and causing an abort in
RAMFSFiler.
Admin:
tested in iyo
JB


Version 2.30. Tagged as 'RAMFS-2_30'
@
text
@a17 4

        GBLA    MySecSizel2b
MyMySecSizel2b  *       10       ; 9 = 512, 10 = 1024
; n.b. 512 byte sector has max disc size approx 256MB. 1025 max is 512MB
d64 3
d68 1
d77 3
d377 9
d417 3
d432 44
d535 1
a535 1
        ADR     R1, FullTitle
d553 7
@


4.14
log
@Adapt to work when Min_Zones is not 1
The code assumed Min_Zones was 1, despite offering a variable suggesting it could be changed arbitrarily. It now can be.
Removed the unnecessary duplicate empty defect list.

Version 2.29. Tagged as 'RAMFS-2_29'
@
text
@d19 6
d26 2
a27 2
        DCB     10      ; Log2SectorSize
        DCB     1       ; SecPerTrk (this is a RAM disc, after all)
d123 1
a123 1
        MOV     r4, #1024
d200 1
a200 1
Min_IdLen       *       10+3    ; min allowed idlen (with 1024 byte zones)
d239 1
a239 1
                                                
d242 1
a242 1
        CMPS    r2, #Max_Zones                  
d331 1
a331 1
        BNE     %FT01                   
@


4.13
log
@  No longer mounts RamDisc0 on startup
Detail:
  This is inconsistent behaviour compared to other FileCore filing systems.
  RAMFS was effectively behaving as though *Configure Dir had been used
  (on RISC OS 2) but since RISC OS 3, all other FileCore filing systems
  have behaved as though *Configure NoDir had been used. Since RAMFS only
  supports one drive, the only difference users are likely to notice is in
  the output of *Cat before *Dir is issued.
Admin:
  Tested using a softload on an OMAP3 machine.

Version 2.28. Tagged as 'RAMFS-2_28'
@
text
@d142 1
a142 1
        ADRL    r1, RAMDisc_EmptyBBList         ; no bad block list
a161 2
RAMDisc_EmptyBBList
        DCD     -1
d188 1
a188 1
        ; r3 = current LinkBits
d194 1
a194 1
Min_IdLen       *       13      ; min allowed idlen (with 1024 byte zones)
d224 4
d229 1
a229 1

d246 1
a246 1
        MOV     r3, #Min_IdLen               ; minimum value of idlen
d248 1
a248 1
40      ; loop for LinkBits
d256 1
a256 1
        ; check that idlen is enough for total possible ids
@


4.12
log
@Change to use centrally assigned error number.
Same binary, retagged as RAMFS-2_27.
@
text
@a153 3
        ADRL    r0, RAMDisc_MountStr
        SWI     XOS_CLI

@


4.11
log
@Declare as a floppy not a fixed disc.
In the (dusty) PRM 2-204 it states that the disc record can be used to specify the size of your media and "this is how RamFS is able to be larger than an ordinary floppy disc", which ties in with it being drive 0 since drives 0-3 are floppies.
This doesn't fix FileCore's poor handling of 1 zone fixed discs, but does make RamFS work for sizes < 964k again.
The zero init of the first zone now no longer unconditionally clears 16k, since the check on RAM area size is 8k.
Recompiled test tool 'm1time'.

Version 2.26. Tagged as 'RAMFS-2_26'
@
text
@d444 1
a444 1
        DCD     ErrorNumber_SizeTooSmall
@


4.10
log
@Put back as drive 0.
Some unrelated bug tracing had got checked in, was declaring itself as a harddisc and appearing as drive 4.

Version 2.25. Tagged as 'RAMFS-2_25'
@
text
@d23 1
a23 1
        DCB     0       ; Density
d43 1
a43 1
        DCD     2048    ; RootDirSize
d77 1
a77 1
        SWI     XOS_ReadRAMFsLimits              ; (->R0,R1)
d82 1
a82 1
        MOV     r1, #4096
d85 1
a85 1
        STR     r2, [r0], #4
d401 2
a402 2
        CMPS    R6, #8*1024                     ; Only initialise if at least 8K of RAM disc
        BCC     %FT60                           ; OSS Moved error handler code out of line - flags problem
a591 2
FsCom   * 1 :SHL: (31-24)

@


4.9
log
@Simplify.
Change to use exports from FileCore-3_45.
Delete local copies, which then collapsed the whole module in on itself - RAMFS should really be the simplest of clients, but was built up from a lot of spare body parts. This simplification removes a lot of files.
Delete s.TokHelpSrc - this is autogenerated and was erroneously checked in a few years ago.
Delete unused Help and Syntax.
Try to get the use of BigDir/BigDisc/BigMap more correct.
Tested against FileCore-3_45 and still works.

Version 2.24. Tagged as 'RAMFS-2_24'
@
text
@d417 1
a417 1
        MOV     R3, #1:SHL:8                    ; 0 floppy, 1 fixed disc, default drive 0, dir
@


4.8
log
@Tidy up.
Get FS_Control reasons from header file rather than local definitions,
Delete lots of FileCore internal stuff from local definitions.
Adjust the 'BigDir' switch use, it's still not quite right as it's being used to select things unrelated to big directories.
Functionally the same as 2.22, tested briefly.

Version 2.23. Tagged as 'RAMFS-2_23'
@
text
@d17 1
a17 1
 TTL    "Initialisation and FS star commands"
d20 10
a29 10
        DCB     10      ; sector size 2^10
        DCB     1       ; sectors per track (this is a RAM disc, after all)
        DCB     1       ; heads
        DCB     0       ; density
        DCB     0       ; * LinkBits
        DCB     0       ; * BitSize
        DCB     0       ; skew
        DCB     0       ; boot option
        DCB     0       ; lowsector
        DCB     0       ; * nzones
d31 1
a31 1
        DCD     0       ; * RootDir
d33 2
a34 2
        DCW     0       ; disc cycle id
        DCB     "RamDisc0",0,0 ; disc name (10 bytes)
d38 3
a40 3
        DCB     0       ; BigFlag
   [ BigDir
        DCB     0       ; Zones2
d43 3
a45 3
        DCD     2048    ; RootSize
   |
        DCB     0       ; Zones2
d48 3
a50 3
        DCD     0       ; RootSize
   ]
        ASSERT  .-SkeletonDiscRec = DiscRecSig2
d53 1
a53 1
        Text    "FileCore%RAM"
d62 2
a63 2
        DCB     NoBigBuf, NewErrorSupport:SHR:8, 0
        DCB     RamFSId
d70 1
a70 1
        DCD     bit29
d73 1
a73 1
        Push    "R0-R11,LR"
d77 1
a77 1
        SWI     XOS_ReadRAMFsLimits     ;(->R0,R1)
d89 1
a89 1
        SUB     sp, sp, #DiscRecSig2
d91 1
a91 1
        ADRL    R0, SkeletonDiscRec     ; source
d93 2
a94 2
        MOV     R1, SP                  ; dest
        MOV     R2, #DiscRecSig2        ; length
d102 1
a102 1
        STR     R6, [SP, #DiscSize]     ;store away the size
d105 1
a105 1
        BL      InitDiscRec             ; fill in the disc record fields which need calculation
d107 2
a108 2
        MOV     r1, #WriteTrkOp
        SUB     sp, sp, #12
d110 2
d115 1
a115 1
        STMIA   r2, {r0,r3,r4}
d120 1
a120 1
        ADD     sp, sp, #12
d126 3
a128 2
        ORR     r1, r1, r5, LSL #6              ; map back to combined disc address in r1
        MOV     r2, #0
d158 1
a158 1
        ADD     sp, sp, #DiscRecSig2
d162 1
a162 1
        Pull    "R0-R11,PC"
a178 1
; >>>>>>>>>>>
d180 2
a181 3
; >>>>>>>>>>>

; this routine generates the values in the disc record to suit the
d184 4
d189 18
a206 14
; in:
;
;    r5 -> disc record

; out:
;
;   disc record fields filled in: LinkBits, BitSize, nzones, ZoneSpare, RootDir

; here's some definitions used by this routine:

Min_LinkBits    *       13      ; minimum allowed LinkBits (with 1024 byte zones)
Max_LinkBits    *       19      ; maximum allowed LinkBits (unlikely!)
Min_BitSize     *       7       ; minimum allowed bitsize
Max_BitSize     *       12      ; max allowed bitsize
d212 1
a212 12
; internal register allocation:

; r5 -> disc record

; r0 = current bitsize
; r1 = current zonespare
; r2 = current zones
; r3 = current LinkBits
; r4 = map allocation bits required to cover disc
; r6 = number of bits in a zone
; r7 = number of allocation bits in the map
; r8 = ids per zone
d214 3
d218 1
a218 10
InitDiscRec     ROUT
        Push    "R0-R11,LR"

        MOV     r0, #Min_BitSize        ; init BitSize

10      ; loop on BitSize
        LDR     r4, [r5, #DiscSize]
        MOV     r4, r4, LSR r0          ; map bits for disc

        MOV     r1, #Min_ZoneSpare      ; init ZoneSpare
d221 1
a221 1
        LDR     lr, [r5, #SectorSize]
d223 2
a224 2
        MOV     r6, r6, LSL lr          ; bits in a zone
        SUB     r6, r6, r1              ; minus sparebits
d228 2
a229 2
        MOV     r2, #Min_Zones          ; minimum of one zone
        SUB     r7, r6, #Zone0Bits      ; bits in zone 0
d232 7
a238 9
        CMP     r7, r4                  ; do we have enough allocation bits yet?
        BHS     %FT35                   ; if we do, then accept this number of zones

        ADD     r7, r7, r6              ; more map bits
        ADD     r2, r2, #1              ; and another zone
        CMPS    r2, #Max_Zones
        BLS     %BT30                   ; still ok

        ; here when too many zones; try a higher BitSize
d240 1
d244 1
a244 1
        ; now we have to choose LinkBits.  we want LinkBits to be
d247 1
a247 1
        MOV     r3, #Min_LinkBits       ; minimum value of LinkBits
d252 2
a253 2
        MOV     r0, r6                  ; allocation bits in a zone
        ADD     r1, r3, #1              ; LinkBits+1
d257 7
a263 7
        ; check that LinkBits is enough for total possible ids
        MOV     r9, #1                  ; work out 1<<LinkBits
        MOV     r9, r9, LSL r3          ;

        MUL     lr, r8, r2              ; total ids needed
        CMPS    lr, r9                  ; LinkBits too small?
        BHI     %FT60                   ; yes!
d271 1
a271 1
        CMPS    lr, r3                  ; must be at least LinkBits+1 bits
d276 1
a276 1
        SUB     lr, r7, r6              ; get the start of the zone
d278 1
a278 1
        SUB     lr, r4, lr              ; lr = bits available in last zone
d287 1
a287 1
        LDR     r10, [r5, #SectorSize]
d290 1
a290 1
        MUL     r10, r2, r10            ; r10 = 2 * map size (in disc bytes)
d292 2
a293 2
        RSB     r11, r11, r11, LSL r0   ; r11 = LFAU-1 (in disc bytes), for rounding up
        LDR     r9, [r5, #DiscVersion]
d295 1
a295 1
        ADDEQ   r10, r10, #NewDirSize   ; short filename: add dir size to map
d300 1
a300 1
        MOV     r9, r9, LSR r0          ; r9 = directory size (in map bits)
d302 1
a302 1
        ADDLE   r9, r3, #1              ; ensure at least LinkBits+1
d308 1
a308 1
        MOV     r10, r10, LSR r0        ; r10 = map (+dir) size (in map bits)
d310 1
a310 1
        ADDLE   r10, r3, #1             ; ensure at least LinkBits+1
d316 1
a316 1
        STRB    r3,[r5, #LinkBits]      ; => set LinkBits
d320 1
a320 1
        STR     r1, [r5, #ZoneSpare-2]  ; => set ZoneSpare and nzones
d322 1
a322 1
        STRB    r0, [r5, #BitSize]      ; => set BitSize
d324 2
a325 2
        LDR     lr, [r5, #DiscVersion]
        TEQ     lr, #1                  ; do we have long filenames?
d331 1
a331 1
        MOVS    r2, r2, LSR #1          ; zones/2
d333 2
a334 2
        MULNE   lr, r2, r8              ; *idsperzone
        MOVEQ   lr, #3                  ; if if zones/2=0, then only one zone, so the id is 3 (0,1,2 reserved)
d336 2
a337 2
        MOV     lr, lr, LSL #8          ; construct full indirect disc address
        ORR     lr, lr, #1              ; with sharing offset of 1
d348 1
a348 1
        STR     lr, [r5, #RootDir]      ; => set RootDir
d350 1
d353 1
a353 3
; other fields in the disc record are fixed-value

60      ; NEXT LinkBits
d355 1
a355 1
        CMPS    r3, #Max_LinkBits
d358 1
a358 1
70      ; NEXT zonespare
d363 1
a363 1
80      ; NEXT BitSize
d365 2
a366 2
        CMPS    r0, #Max_BitSize        ; is it too much?
        BLS     %BT10                   ; back around
d369 1
a369 1
        Pull    "R0-R11,PC"
a370 1
; >>>>>>>>>
d372 2
a373 3
; >>>>>>>>>


d375 1
a375 1
        Push    "R0-R11,SB,LR"
d377 1
a377 1
 [ Debug3
d379 1
a379 1
 ]
d381 3
d385 3
a387 14
        SWI     XOS_ReadRAMFsLimits     ;(->R0,R1)
        SUB     R6, R1, R0              ;RAM disc size

 [ BigDir
        Push    "R0"
 |
        ADRL    LR, SkeletonDiscRec
        LDMIA   LR, {R2,R5,R7-R9}
        Push    "R0,R2-R9"
 ]

        MOV     R9, #0                  ;error flag
        MOV     R10,#1                  ;init flag
        MOV     R11,R12
d391 3
a393 2
        SWI     XOS_Module              ;claim workspace
        Pull    "R4"                    ;-> RAM disc start
d397 1
a397 2
; OSS Flag that the message file is closed.

d401 2
a402 2
        CMPS    R6, #8*K                ;Only initialise if at least 8K of RAM disc
        BCC     %FT60                   ; OSS Moved error handle code out of line - flags problem
a403 1
 [ BigDir
d412 2
a413 2
        baddr   R0, FSCreateBlock
        baddr   R1, Module_BaseAddr
d415 13
a427 6
        MOV     R3, #1                  ;1 floppy, 0 winnies, default drive 0, dir
        MOV     R4, #65536              ;dir cache size
        MOV     R5, #0                  ;File cache buffers
        MOV     R6, #0                  ;winnie sizes
        SWI     XFileCore_Create      ;(R0-R6->R0-R2,V)
        BVS     %FT85                   ; filecore_create failed
d431 1
a431 44
        BL      InitRAMDisc             ; just in case the Kernel hasn't done it

 |
        MOV     R0, #7
05
        MOV     R1, R6, LSR R0
        RSBS    R1, R1, #(SzNewFloppyFs - ZoneHead - ZoneDiscRecSz)*8
        CMPHIS  R1, #16
        ADDLO   R0, R0, #1
        BLO     %BT05
        ADD     R1, R1, #ZoneHead*8
        MOV     R1, R1, LSL #16
        ORR     R1, R1, #1 :SHL: 8      ;or in zones
        STR     R1, [SP, #ZoneSpare-2]
        CMPS    R0, #8
        MOV     R0, R0, LSL #8
        ORRLS   R0, R0, #15
        ORRHI   R0, R0, #13
        STR     R0, [SP, #LinkBits]     ;also BitSize, RA skew, BootOpt

        ASSERT  :INDEX: BufferStart=0
        ASSERT  :INDEX: BufferSize=4
        STMIA   SB, {R4,R6}
        MOV     R0, R4
        MOV     R1, SP
        MOV     R2, #0
        baddr   R3, EmptyDefectList
        SWI     XFileCore_FloppyStructure     ;(R0-R3->R0,V)

        baddr   R0, FSCreateBlock,VC
        baddr   R1, Module_BaseAddr,VC
        MOVVC   R2, R11
        MOVVC   R3, #1                  ;1 floppy, 0 winnies, default drive 0, dir
        MOVVC   R4, #0                  ;dir cache size
        MOVVC   R5, #0                  ;File cache buffers
        MOVVC   R6, #0                  ;winnie sizes
        SWIVC   XFileCore_Create      ;(R0-R6->R0-R2,V)
        BVS     %FT85
        STR     R0, FileCorePrivate

        STR     SB, [R11]
        ADD     SP, SP, #DiscRecSig

 ]
d434 1
a434 3
        Pull    "R0-R11,SB,PC"

; OSS Error handling code for "Ram Disc too small"
d437 4
a440 3
        baddr   R0, SizeErrErrBlk
        MOV     r1, #0                  ; No %0
        BL      copy_error_one          ; Always sets the V bit
d443 4
a446 6
 LTORG

; >>>>>>>>
; DieEntry
; >>>>>>>>

d448 3
d452 1
a452 1
        Push    "R0-R11,SB,LR"
d454 1
a454 1
 [ Debug3
d456 4
a459 8
 ]
 [ BigDir
 |
        SUB     SP, SP, #DiscRecSig
 ]
        getSB

; Dismount the disk so filer windows close
d461 1
d466 3
a468 9
        MOV     R10,#0
 [ BigDir
75
        MOVVS   R9, R0                          ; hang on to any earlier error
 ]

 [ Debug3
        DLINE   "Killing parent"
 ]
d471 1
a471 1
        baddr   R1, FullTitle
d473 3
a475 4
 [ Debug3
        DLINE   "killed parent"
        DebugError      "Kill filecore: "
 ]
d478 3
a480 5

; OSS Close the Messages file if it is open, and then flag it as closed.
; OK so even if it is closed I flag it as closed, but this is hardly speed
; critical code.

d491 6
a496 5
        SWI     XOS_Module          ;Free workspace
 [ Dev
        wrhex   R0, VS
        mess    VS,"Heap error",NL
 ]
d499 10
a508 13
 [ Dev
        wrhex   R10,VS
        wrhex   R0, VS
        mess    VS,"Error",NL
 ]

 [ BigDir
 |
        ADD     SP, SP, #DiscRecSig
 ]
        ADDS    R0, R9, #0      ;clear V
        MOVNES  R10,R10         ;only error on init
        Pull    "R0-R11,SB,PC",EQ
d510 1
a510 1
        BL      SetV
d512 1
a512 1
        Pull    "R1-R11,SB,PC"
d515 21
a535 1
 [ F
d537 9
a545 14
; >>>>>>>>>>>>
; ServiceEntry
; >>>>>>>>>>>>

ServiceEntry ROUT
        Push    "R0-R3,R5,SB,LR"
 getSB

        TEQS    R1, #Service_Reset
        BNE     %FT90

90
        Pull    "R0-R3,R5,SB,PC"
 ]
d548 1
a548 1
        Push    "R8,LR"
d551 1
a551 1
        Pull    "R8,PC"
d554 1
a554 1
        Push    "R8,LR"
d557 1
a557 1
        Pull    "R8,PC"
d560 1
a560 1
        Push    "R8,LR"
d563 1
a563 1
        Pull    "R8,PC"
d566 1
a566 1
        Push    "R8,LR"
d569 1
a569 1
        Pull    "R8,PC"
d572 1
a572 1
        Push    "R8,LR"
d575 1
a575 1
        Pull    "R8,PC"
a576 34
; >>>>>>>>
; SwiEntry
; >>>>>>>>

SwiEntry ROUT
        Push    "SB,LR"
        CLRPSR  I_bit, LR        ;re-enable interrupts
        getSB
        CMPS    R11,#FirstUnusedSwi
        BHS     BadSwi
        MOV     LR, PC
        ADD     PC, PC, R11,LSL #2
        B       %FT10
05
        B       DoSwiRetryDiscOp
        B       BadSwi
        B       DoSwiDrives
        B       DoSwiFreeSpace

        B       BadSwi
        B       DoSwiDescribeDisc
        B       DoSwiRetryDiscOp64

FirstUnusedSwi  * (.-%BT05)/4
10
        Pull    "SB,PC"
BadSwi
        ;  Bad SWI
        Push    r1
        ADRL    r0, ErrorBlock_ModuleBadSWI
        baddr   r1, RamFSTitle
        BL      copy_error_one
        Pull    r1
        B       %BT10
d592 1
a592 1
FsCom   bit     (31-24)
d594 1
a594 1
 MACRO
d598 9
a606 9
 ALIGN
        DCD     Do$Com          - Module_BaseAddr
        =       $MinArgs
        =       $GsTransBits
        =       $MaxArgs
        =       $HiBits
        DCD     Syn$Com         - Module_BaseAddr
        DCD     Help$Com        - Module_BaseAddr
 MEND
d608 2
a609 2
ComTab                                          ;general star commands
        ComEntry  Ram,           0,0,0,International_Help:SHR:24
d611 2
a612 2
        =       0
 ALIGN
a613 1
; >>>>>
d615 2
a616 2
; >>>>>

d620 1
a620 1
        baddr   R1, RamFSString
a623 1

@


4.7
log
@  Added boot option to disc record and help text
Detail:
  Files modified: s.RamFS50
  Files added: s.TokHelpSrc
Admin:
  Updated from Kev's machine by Mike H.

Version 2.20. Tagged as 'RAMFS-2_20'
@
text
@d19 12
a30 15
 [ BigDir

; the disc record here will be much more complete
SkeletonDiscRec         ;fields marked * need filling in
        =       10      ; sector size 2^10
        =       1       ; sectors per track (this is a RAM disc, after all)
        =       1       ; heads
        =       0       ; density
        =       0       ; * LinkBits
        =       0       ; * BitSize
        =       0       ; skew
        =       0       ; boot option
        =       0       ; lowsector
        =       0       ; * nzones
        =       0,0     ; * ZoneSpare
d33 2
a34 1
        DCD     0,0,0   ; disc cycle id (2 bytes) + disc name (10 bytes)
d37 5
a41 1
        DCD     0       ; ShareSize,BigFlag,Zones2,Reserved
d44 6
a49 1

a50 24
 |

SkeletonDiscRec ;those marked * need filling in
        =  10   ;  sector size 2^10     R2
        =  1    ;  sectors per track
        =  1    ;  heads
        =  0    ;  density

;        * link bits            R3
;        * bit size
;  0       RA skew
;  0       boot opt

; = 0                            R4
; = 1      zones
; = 0,0  * zone spare

        &  &203 ;  root dir             R5
; & 0      disc size            R6

        =  0,0  ;* id                   R7-R9
        =  "RamDisc0",0,0
        ASSERT  .-SkeletonDiscRec = DiscRecSig - 3*4
 ]
d59 1
a59 1
 ALIGN
d62 6
a67 6
        =       NoBigBuf,NewErrorSupport:SHR:8,0
        =       RamFSId
        &       RamFSString     - Module_BaseAddr
        &       RamFSBootText   - Module_BaseAddr
        &       LowLevelEntry   - Module_BaseAddr
        &       MiscEntry       - Module_BaseAddr
d70 1
a70 2
        &       bit29

a71 1
 [ BigDir
a107 1
;       ORR     r1, r1, r5, LSL #6
d124 1
a124 1
        ORR     r1, r1, r5, LSL #6
d130 3
a132 3
30      MOV     r0, #&CF
        ADRL    r1, RAMDisc_RAMdiscName        ; name ptr
        SWI     XOS_Find                ; find it
d134 1
a134 1
        BVS     %FT75                   ; failed to do so
d190 1
a190 1
;   disc record fields filled in: LinkBits, zones, zonespare, bitsize and rootdir
d256 1
a256 1
        MOV     r3, #Min_LinkBits               ; minimum value of LinkBits
d325 1
a325 1
        ; first, store the things we know about
a326 1
        STRB    r3,[r5, #LinkBits]
d329 1
d331 1
a331 3
        STR     r1, [r5, #ZoneSpare-2]

        STRB    r0, [r5, #BitSize]
d334 2
a335 6

        MOVS    lr, lr

        BEQ     %FT01                   ; do we have long filenames?

        ; here when long filenames
a339 1

a348 1

d350 1
a350 2
        ; here when not long filenames

a355 1

d357 1
a357 3

        STR     lr, [r5, #RootDir]      ; root dir disc addr

a372 1

a380 2
 ]

d710 1
a710 1
        MOV     R0, #FscSelectFs
@


4.6
log
@* Fix to format choosing algorithm to ensure final zone has enough space for
  the map & root directory, if they're in the final zone. A 964K RAM disc
  used to crash FileCore because this check wasn't performed.
* Supports new FileCore error scheme.

Version 2.19. Tagged as 'RAMFS-2_19'
@
text
@d30 1
d36 1
a36 1
        DCD     0,0,0   ; disc cycle id + disc name
d210 1
a210 1
;   disc record fields filled in: zones, zonespare, LinkBits and bitsize
@


4.5
log
@Changed to offer RAMFS_DiscOp64 too.

Version 2.18. Tagged as 'RAMFS-2_18'
@
text
@d22 19
a40 19
SkeletonDiscRec		;fields marked * need filling in
	=  	10	; sector size 2^10
	=  	1	; sectors per track (this is a RAM disc, after all)
	=  	1	; heads
	=  	0	; density
	=  	0	; * LinkBits
	=  	0	; * BitSize
	=  	0	; skew
	=  	0	; lowsector
	=  	0	; * nzones
	=  	0,0	; * ZoneSpare
	DCD 	0	; * RootDir
	DCD 	0	; * DiscSize
	DCD 	0,0,0	; disc cycle id + disc name
	DCD 	0	; DiscType
	DCD 	0	; DiscSize2
	DCD 	0	; ShareSize,BigFlag,Zones2,Reserved
	DCD 	1   	; DiscVersion
	DCD 	2048 	; RootSize
d42 1
a42 1
	ASSERT	.-SkeletonDiscRec = DiscRecSig2
d78 1
a78 1
        =       NoBigBuf,0,0
d91 3
a93 3
	Push	"R0-R11,LR"
	ADRL	r0, RAMDisc_DismountStr
	SWI	XOS_CLI
d97 2
a98 2
	SUBS	r6, r1, r0
	BEQ	%FT85
d100 2
a101 2
	MOV	r1, #4096
	MOV	r2, #0
d103 3
a105 3
	STR	r2, [r0], #4
	SUBS	r1, r1, #4
	BNE	%BT10
d107 1
a107 1
	SUB	sp, sp, #DiscRecSig2
d109 1
a109 1
	ADRL	R0, SkeletonDiscRec	; source
d111 2
a112 2
	MOV	R1, SP			; dest
	MOV	R2, #DiscRecSig2	; length
d115 4
a118 4
	LDR	R3, [R0], #4
	STR	R3, [R1], #4
	SUBS	R2, R2, #4
	BNE	%BT20
d120 1
a120 1
	STR	R6, [SP, #DiscSize]	;store away the size
d122 2
a123 2
	MOV	r5, SP
	BL	InitDiscRec		; fill in the disc record fields which need calculation
d125 2
a126 2
	MOV	r1, #WriteTrkOp
;	ORR	r1, r1, r5, LSL #6
d133 4
a136 4
	MOV	r3, #0
	MOV	r4, #1024
	LDR	r8, FileCorePrivate
	SWI	XFileCore_DiscOp64
d147 1
a147 1
	BVS	%FT75
d149 3
a151 3
30      MOV	r0, #&CF
	ADRL	r1, RAMDisc_RAMdisc0Name	; name ptr
	SWI	XOS_Find		; find it
d153 1
a153 1
	BVS	%FT75			; failed to do so
d155 1
a155 1
	MOV	R3, R0
d157 3
a159 3
	MOV	r0, sp
	ADRL	r1, RAMDisc_EmptyBBList		; no bad block list
	ADRL	r2, RAMDisc_JustDiscName	; disc name
d161 1
a161 1
	SWI	XFileCore_LayoutStructure
d163 3
a165 3
	MOV	r0, #0
	MOV	r1, r3
	SWI	XOS_Find
d167 2
a168 2
	ADRL	r0, RAMDisc_DismountStr
	SWI	XOS_CLI
d170 2
a171 2
	ADRL	r0, RAMDisc_MountStr
	SWI	XOS_CLI
d174 1
a174 1
	ADD	sp, sp, #DiscRecSig2
d177 2
a178 2
	STRVS	r0, [sp]
	Pull	"R0-R11,PC"
d182 1
a182 1
	DCD	-1
d184 3
a186 3
	DCB	"RamDisc0",0
	ALIGN
RAMDisc_RAMdisc0Name
d190 1
a190 1
	DCB	"RAM:Dismount :0",0
d192 2
a193 2
	DCB	"RAM:mount :0",0
	ALIGN
d213 8
a220 8
Min_LinkBits	*	13	; minimum allowed LinkBits (with 1024 byte zones)
Max_LinkBits	*	19	; maximum allowed LinkBits (unlikely!)
Min_BitSize	*	7	; minimum allowed bitsize
Max_BitSize	*	12	; max allowed bitsize
Min_ZoneSpare	*	32	; min allowed zonespare
Max_ZoneSpare	*	64	; max allowed zonespare
Min_Zones	*	1	; min allowed zones
Max_Zones	*	16	; max allowed zones
d236 2
a237 2
InitDiscRec	ROUT
	Push	"R0-R11,LR"
d239 1
a239 1
	MOV	r0, #Min_BitSize	; init BitSize
d241 3
a243 3
10	; loop on BitSize
	LDR	r4, [r5, #DiscSize]
	MOV	r4, r4, LSR r0		; map bits for disc
d245 2
a246 2
	MOV	r1, #Min_ZoneSpare	; init ZoneSpare
20	; loop on zonespare
d248 4
a251 4
	LDR	lr, [r5, #SectorSize]
	MOV	r6, #8
	MOV	r6, r6, LSL lr		; bits in a zone
	SUB	r6, r6, r1		; minus sparebits
d253 1
a253 1
	; choose number of zones to suit
d255 2
a256 2
	MOV	r2, #Min_Zones		; minimum of one zone
	SUB	r7, r6, #Zone0Bits	; bits in zone 0
d258 3
a260 3
30	; loop for zones
	CMP	r7, r4			; do we have enough allocation bits yet?
	BHS	%FT35			; if we do, then accept this number of zones
d262 4
a265 4
	ADD	r7, r7, r6		; more map bits
	ADD	r2, r2, #1		; and another zone
	CMPS	r2, #Max_Zones
	BLS	%BT30			; still ok
d267 1
a267 1
	; here when too many zones; try a higher BitSize
d269 1
a269 1
	B	%FT80
d272 12
a283 2
	; now we have to choose LinkBits.  we want LinkBits to be
	; the smallest it can be for the disc.
d285 3
a287 1
	MOV	r3, #Min_LinkBits		; minimum value of LinkBits
d289 3
a291 1
40	; loop for LinkBits
d293 2
a294 5
	Push	"R0, R1, R2"
	MOV	r0, r6			; allocation bits in a zone
	ADD	r1, r3, #1		; LinkBits+1
	DivRem	r8, r0, r1, r2
	Pull	"R0, R1, R2"
d296 2
a297 3
	; check that LinkBits is enough for total possible ids
	MOV	r9, #1			; work out 1<<LinkBits
	MOV	r9, r9, LSL r3		;
d299 2
a300 3
	MUL	lr, r8, r2		; total ids needed
	CMPS	lr, r9			; LinkBits too small?
	BHI	%FT60			; yes!
d302 1
a302 2
	; we're nearly there.  now work out if the last zone
	; can be handled correctly.
d304 1
a304 2
	SUBS	lr, r7, r4
	BEQ	%FT50
d306 3
a308 2
	CMPS	lr, r3			; must be at least LinkBits+1 bits
	BLE	%FT60
d310 4
a313 1
	; check also that we're not too close to the start of the zone
d315 10
a324 1
	SUB	lr, r7, r6		; get the start of the zone
d326 8
a333 3
	SUB	lr, r4, lr		;
	CMPS	lr, r3
	BLE	%FT60
d335 6
d342 1
a342 1
50	; we've found a result - fill in the disc record!
d344 1
a344 1
	; first, store the things we know about
d346 3
a348 3
	STRB	r3,[r5, #LinkBits]
	MOV	r1, r1, LSL #16
	ORR	r1, r1, r2, LSL #8
d350 1
a350 1
	STR	r1, [r5, #ZoneSpare-2]
d352 1
a352 1
	STRB	r0, [r5, #BitSize]
d354 1
a354 1
	LDR	lr, [r5, #DiscVersion]
d356 1
a356 1
	MOVS	lr, lr
d358 1
a358 1
	BEQ	%FT01			; do we have long filenames?
d360 1
a360 1
	; here when long filenames
d362 2
a363 2
	; the root dir's ID is the first available ID in the middle
	; zone of the map
d366 1
a366 1
	MOVS	r2, r2, LSR #1		; zones/2
d368 2
a369 2
	MULNE	lr, r2, r8		; *idsperzone
	MOVEQ	lr, #3			; if if zones/2=0, then only one zone, so the id is 3 (0,1,2 reserved)
d371 2
a372 2
	MOV	lr, lr, LSL #8		; construct full indirect disc address
	ORR	lr, lr, #1		; with sharing offset of 1
d374 1
a374 1
	B	%FT02
d377 1
a377 1
	; here when not long filenames
d379 1
a379 1
	; root dir is &2nn where nn is ((zones<<1)+1)
d381 3
a383 3
	MOV	lr, r2, LSL #1
	ADD	lr, lr, #1
	ADD	lr, lr, #&200
d387 1
a387 1
	STR	lr, [r5, #RootDir]	; root dir disc addr
d390 1
a390 1
	B	%FT90
d394 9
a402 9
60	; NEXT LinkBits
	ADD	r3, r3, #1
	CMPS	r3, #Max_LinkBits
	BLS	%BT40

70	; NEXT zonespare
	ADD	r1, r1, #1
	CMPS	r1, #Max_ZoneSpare
	BLS	%BT20
d405 4
a408 4
80	; NEXT BitSize
	ADD	r0, r0, #1
	CMPS	r0, #Max_BitSize	; is it too much?
	BLS	%BT10			; back around
d411 1
a411 1
	Pull	"R0-R11,PC"
d424 1
a424 1
	DLINE	"RAMFS Init"
d432 1
a432 1
	Push	"R0"
d463 1
a463 1
	STR	R11, MyPrivate
d469 7
a475 7
        LDR	r2, MyPrivate
        MOV	R3, #1                  ;1 floppy, 0 winnies, default drive 0, dir
        MOV	R4, #65536              ;dir cache size
        MOV	R5, #0                  ;File cache buffers
        MOV	R6, #0                  ;winnie sizes
        SWI	XFileCore_Create      ;(R0-R6->R0-R2,V)
        BVS     %FT85			; filecore_create failed
d479 1
a479 1
	BL	InitRAMDisc		; just in case the Kernel hasn't done it
d546 1
a546 1
	DLINE	"RAMFS Die"
d563 1
a563 1
  	MOVVS	R9, R0				; hang on to any earlier error
d567 1
a567 1
	DLINE	"Killing parent"
d574 2
a575 2
	DLINE	"killed parent"
	DebugError	"Kill filecore: "
@


4.4
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 2.16. Tagged as 'RAMFS-2_16'
@
text
@d126 7
a132 2
	ORR	r1, r1, r5, LSL #6
	MOV	r2, #0
d136 10
a145 1
	SWI	XFileCore_DiscOp
d149 1
a149 1
	MOV	r0, #&CF
d612 6
d657 1
d681 1
@


4.3
log
@Made 32-bit compatible.

Tested and running on a development board.

Version 2.15. Tagged as RAMFS-2_15.
@
text
@d80 4
a83 4
        &       RamFSString     - org
        &       RamFSBootText   - org
        &       LowLevelEntry   - org
        &       MiscEntry       - org
d423 1
a423 1
        baddr   R1, org
d464 1
a464 1
        baddr   R1, org,VC
d670 1
a670 1
        DCD     Do$Com          - org
d675 2
a676 2
        DCD     Syn$Com         - org
        DCD     Help$Com        - org
@


4.2
log
@Ursula branch merged
@
text
@d366 1
a366 1
	Pull	"R0-R11,PC",,^
d479 2
a480 1
        Pull    "R0-R11,SB,PC",,^
d566 1
a566 1
        MOVS    R0, R9
d568 1
a568 1
        Pull    "R0-R11,SB,PC",EQ,^
d589 1
a589 1
        Pull    "R0-R3,R5,SB,PC",,^
@


4.1
log
@Initial revision
@
text
@d19 26
d66 7
d88 282
d374 1
d378 4
a381 2
        baddr   LR, SkeletonDiscRec
        LDMIA   LR, {R2,R5,R7-R9}
d385 6
d392 1
d413 24
d475 3
a478 1
        ADD     SP, SP, #DiscRecSig
a480 1

a490 7
FullTitle
        Text    "FileCore%RAM"

RAMdiscName
        DCB     "RAM::RamDisc0",0
        ALIGN

d495 2
a496 1
DieEntry 
d498 6
d505 1
d511 1
a511 1
        ADR     R2, RAMdiscName                 ; Disc to dismount
d515 9
d527 5
d561 2
d564 1
d573 1
d643 1
a643 1
        ADR     r0, ErrorBlock_ModuleBadSWI
d694 1
@


4.1.4.1
log
@Modified to take advantage of new FileCore (long filenames).  Previously,
RAMFS used FileCore_FloppyStructure, which can only lay out single-zone
E-format discs.  This meant that with a 16M RAM disc, you have a 4096
byte LFAU (cf harddiscs, where the LFAU would not reach this until the
disc size reached 1G byte).

Modified to use FileCore_LayoutStructure (supports long file names, and
multiple disc zones).  Result:  LFAU on a 16M byte RAM disc is now only
256 bytes, which saves alot of space.  RAMFS makes a choice about the
parameters to pass to LayoutStructure, limiting the number of zones to
16 (this can easily be changed).  It chooses the smallest LFAU possible
given this constraint, with a minimum of 256 bytes.

Also checks FileCore version; on FileCore 2.98 or earlier, long file
names are turned off, so it will work on older versions, and still give
the benifit of smaller LFAUs.

As a further optimisation, RAMFS will now ask for a 64K byte directory
cache to be allocated.  This seems to improve performance, especially
with large directories on long file names.

problems:

Due to a Kernel problem with re-entrancy on OS_ChangeDynamicArea, when
running the new filecore, any attempt to shrink the RAM disc will result
in the kernel generating (not returning) the error SWI &6d656d not known.

This completely stuffs the system, as RAMFS has failed to re-init
properly, and any attempts to call OS_ChangeDynamicArea will fail
because the re-entrancy semaphore will be set.

This needs a Kernel Fix (clearing the re-entrancy flag *before* calling
PostShrink instead of after).  Implications of this need to be considered.

Also, this problem might occur on old FileCore if the RMA is full when
RAMFS is re-initialised, and the number of zones in the free space map
increases when the disc gets smaller.

To do:

Ownership of the RAMFS dynamic area should move to RAMFS, since it makes
it easier for RAMFS to be efficient (re-initing RAMFS every time  the size
of the DA changes is not pretty).

RAMFS dynamic area should be made cacheable on SA.

Now that RAMFS supports large RAM discs better (upto 256 megs is feasible)
the maximum size of the RAM disc should be increased.  To avoid the problem
of soaking up all of the virtual address space, however, the initial max
size of the dynamic area should be the same as present, and if there's any
need to grow it, it should be destroyed and re-created.

Need to determine a 'good' choicde of the dir cache size.

Consider changing to 512 or 256 byte sector size?  Would increase space
efficiency in shared objects.
@
text
@a18 50
 [ BigDir
; the disc record here will be much more complete
SkeletonDiscRec		;fields marked * need filling in
	=  	10	; sector size 2^10
	=  	1	; sectors per track (this is a RAM disc, after all)
	=  	1	; heads
	=  	0	; density
	=  	0	; * LinkBits
	=  	0	; * BitSize
	=  	0	; skew
	=  	0	; lowsector
	=  	0	; * nzones
	=  	0,0	; * ZoneSpare
	DCD 	0	; * RootDir
	DCD 	0	; * DiscSize
	DCD 	0,0,0	; disc cycle id + disc name
	DCD 	0	; DiscType
	DCD 	0	; DiscSize2
	DCD 	0	; ShareSize,BigFlag,Zones2,Reserved
	DCD 	1   	; DiscVersion
	DCD 	2048 	; RootSize

	ASSERT	.-SkeletonDiscRec = DiscRecSig2

; the disc record here will be much more complete
SkeletonDiscRecOld		;fields marked * need filling in
	=  	10	; sector size 2^10
	=  	1	; sectors per track (this is a RAM disc, after all)
	=  	1	; heads
	=  	0	; density
	=  	0	; * LinkBits
	=  	0	; * BitSize
	=  	0	; skew
	=  	0	; lowsector
	=  	0	; * nzones
	=  	0,0	; * ZoneSpare
	DCD 	0	; * RootDir
	DCD 	0	; * DiscSize
	DCD 	0,0,0	; disc cycle id + disc name
	DCD 	0	; DiscType
	DCD 	0	; DiscSize2
	DCD 	0	; ShareSize,BigFlag,Zones2,Reserved
	DCD 	0   	; DiscVersion
	DCD 	0 	; RootSize

	ASSERT	.-SkeletonDiscRecOld = DiscRecSig2

OldFileCoreVersion	DCD	298
 |

a39 1
 ]
d62 1
a62 5
 [ Debug3
	DLINE	"RAMFS Init"
 ]

        ADRL    LR, SkeletonDiscRec
a66 4
 [ BigDir
	SUB	SP, SP, #DiscRecSig2
	Push	"R0"
 |
a67 1
 ]
a79 3



a87 82
 [ BigDir
        ASSERT  :INDEX: BufferStart=0
        ASSERT  :INDEX: BufferSize=4
        STMIA   SB, {R4,R6}

	STR	R11, MyPrivate

	LDR	R0, BufferStart
	MOV	R1, #1024
	BL	ZeroRam

	ADD	r0, r0, #&C00
	BL	ZeroRam

        STR     SB, [R11]

        baddr   R0, FSCreateBlock
        baddr   R1, org
        LDR	r2, MyPrivate
        MOV	R3, #1                  ;1 floppy, 0 winnies, default drive 0, dir
        MOV	R4, #65536              ;dir cache size
        MOV	R5, #0                  ;File cache buffers
        MOV	R6, #0                  ;winnie sizes
        SWI	XFileCore_Create      ;(R0-R6->R0-R2,V)
        BVS     %FT85			; filecore_create failed

        STR     R0, FileCorePrivate

	BL	FileCoreVersion		; check the filecore version
	LDR	lr, OldFileCoreVersion	; and see if things are ok
	CMPS	r0, lr			;

	BHI	%FT01

	ADRL	r0, SkeletonDiscRecOld
  	B	%FT02
01
	ADRL	R0, SkeletonDiscRec	; source
02

	MOV	R1, SP			; dest
	MOV	R2, #DiscRecSig2	; length
	BL	BlockMove		; (R0, R1, R2)
	LDR	R6, BufferSize
	STR	R6, [SP, #DiscSize]	;store away the size

	MOV	r5, SP
	BL	InitDiscRec		; fill in the disc record fields which need calculation

	MOV	r1, #WriteTrkOp
	ORR	r1, r1, r5, LSL #6
	MOV	r2, #0
	LDR	r3, BufferStart
	MOV	r4, #1024
	LDR	r8, FileCorePrivate
	SWI	XFileCore_DiscOp

	BVS	%FT75

	MOV	r0, #&CF
	ADRL	r1, RAMdisc0Name	; name ptr
	SWI	XOS_Find		; find it

	BVS	%FT75			; failed to do so

	MOV	R3, R0

	MOV	r0, sp
	ADRL	r1, EmptyBBList		; no bad block list
	ADRL	r2, JustDiscName	; disc name

	SWI	XFileCore_LayoutStructure

	BVS	%FT75	  		; if failed to init the disc

; finally, dismount the disc
	ADRL	r0, DismountStr
	SWI	XOS_CLI

	BVS	%FT75
  	ADD	SP, SP, #DiscRecSig2
 |
d126 1
a127 3

 ]

a147 19
 [ BigDir
EmptyBBList
	DCD	-1
JustDiscName
	DCB	"RamDisc0",0
	ALIGN
RAMdisc0Name
        DCB     "RAM::0",0
        ALIGN
DismountStr
	DCB	"RAM:Dismount :0",0
	ALIGN
 ]

 [ BigDir

 ]


d152 1
a152 1
DieEntry
a153 7

 [ Debug3
	DLINE	"RAMFS Die"
 ]
 [ BigDir
	SUB	SP, SP, #DiscRecSig2
 |
a154 1
 ]
d160 1
a160 1
        ADRL    R2, RAMdiscName                 ; Disc to dismount
a163 9
 [ BigDir
75
  	MOVVS	R9, R0				; hang on to any earlier error
 ]

 [ Debug3
	DLINE	"Killing parent"
 ]

a166 5
 [ Debug3
	DLINE	"killed parent"
	DebugError	"Kill filecore: "
 ]

a195 3
 [ BigDir
	ADD	SP, SP, #DiscRecSig2
 |
a196 1
 ]
a204 192

 [ BigDir

; >>>>>>>>>>>
; InitDiscRec
; >>>>>>>>>>>

; this routine generates the values in the disc record to suit the
; chosen size of the RAM disc.  We need to work out the values, and
; place them in a disc record

; in:
;
;    r5 -> disc record

; out:
;
;   disc record fields filled in: zones, zonespare, LinkBits and bitsize

; here's some definitions used by this routine:

Min_LinkBits	*	13	; minimum allowed LinkBits (with 1024 byte zones)
Max_LinkBits	*	19	; maximum allowed LinkBits (unlikely!)
Min_BitSize	*	7	; minimum allowed bitsize
Max_BitSize	*	12	; max allowed bitsize
Min_ZoneSpare	*	32	; min allowed zonespare
Max_ZoneSpare	*	64	; max allowed zonespare
Min_Zones	*	1	; min allowed zones
Max_Zones	*	16	; max allowed zones

; internal register allocation:

; r5 -> disc record

; r0 = current bitsize
; r1 = current zonespare
; r2 = current zones
; r3 = current LinkBits
; r4 = map allocation bits required to cover disc
; r6 = number of bits in a zone
; r7 = number of allocation bits in the map
; r8 = ids per zone


InitDiscRec	ROUT
	Push	"R0-R11,LR"

	MOV	r0, #Min_BitSize	; init BitSize

10	; loop on BitSize
	LDR	r4, [r5, #DiscSize]
	MOV	r4, r4, LSR r0		; map bits for disc

	MOV	r1, #Min_ZoneSpare	; init ZoneSpare
20	; loop on zonespare

	LDR	lr, [r5, #SectorSize]
	MOV	r6, #8
	MOV	r6, r6, LSL lr		; bits in a zone
	SUB	r6, r6, r1		; minus sparebits

	; choose number of zones to suit

	MOV	r2, #Min_Zones		; minimum of one zone
	SUB	r7, r6, #Zone0Bits	; bits in zone 0

30	; loop for zones
	CMP	r7, r4			; do we have enough allocation bits yet?
	BHS	%FT35			; if we do, then accept this number of zones

	ADD	r7, r7, r6		; more map bits
	ADD	r2, r2, #1		; and another zone
	CMPS	r2, #Max_Zones
	BLS	%BT30			; still ok

	; here when too many zones; try a higher BitSize

	B	%FT80

35
	; now we have to choose LinkBits.  we want LinkBits to be
	; the smallest it can be for the disc.

	MOV	r3, #Min_LinkBits		; minimum value of LinkBits

40	; loop for LinkBits

	Push	"R0, R1"
	MOV	r0, r6			; allocation bits in a zone
	ADD	r1, r3, #1		; LinkBits+1
	BL	Divide			; (R0,R1->R0,R1)
	MOV	r8, r0			; r8 = ids per zone
	Pull	"R0, R1"

	; check that LinkBits is enough for total possible ids
	MOV	r9, #1			; work out 1<<LinkBits
	MOV	r9, r9, LSL r3		;

	MUL	lr, r8, r2		; total ids needed
	CMPS	lr, r9			; LinkBits too small?
	BHI	%FT60			; yes!

	; we're nearly there.  now work out if the last zone
	; can be handled correctly.

	SUBS	lr, r7, r4
	BEQ	%FT50

	CMPS	lr, r3			; must be at least LinkBits+1 bits
	BLE	%FT60

	; check also that we're not too close to the start of the zone

	SUB	lr, r7, r6		; get the start of the zone

	SUB	lr, r4, lr		;
	CMPS	lr, r3
	BLE	%FT60


50	; we've found a result - fill in the disc record!

	; first, store the things we know about

	STRB	r3,[r5, #LinkBits]
	MOV	r1, r1, LSL #16
	ORR	r1, r1, r2, LSL #8

	STR	r1, [r5, #ZoneSpare-2]

	STRB	r0, [r5, #BitSize]

	LDR	lr, [r5, #DiscVersion]

	TEQS	lr, lr

	BEQ	%FT01			; do we have long filenames?

	; here when long filenames

	; the root dir's ID is the first available ID in the middle
	; zone of the map


	MOVS	r2, r2, LSR #1		; zones/2

	MULNE	lr, r2, r8		; *idsperzone
	MOVEQ	lr, #3			; if if zones/2=0, then only one zone, so the id is 3 (0,1,2 reserved)

	MOV	lr, lr, LSL #8		; construct full indirect disc address
	ORR	lr, lr, #1		; with sharing offset of 1

01
	; here when not long filenames

	; root dir is &2nn where nn is ((zones<<1)+1)

	MOV	lr, r2, LSL #1
	ADD	lr, lr, #1
	ADD	lr, lr, #&200

02

	STR	lr, [r5, #RootDir]	; root dir disc addr


	B	%FT90

; other fields in the disc record are fixed-value

60	; NEXT LinkBits
	ADD	r3, r3, #1
	CMPS	r3, #Max_LinkBits
	BLS	%BT40

70	; NEXT zonespare
	ADD	r1, r1, #1
	CMPS	r1, #Max_ZoneSpare
	BLS	%BT20


80	; NEXT BitSize
	ADD	r0, r0, #1
	CMPS	r0, #Max_BitSize	; is it too much?
	BLS	%BT10			; back around

90
	Pull	"R0-R11,PC",,^


 ]

d274 1
a274 1
        ADRL    r0, ErrorBlock_ModuleBadSWI
a324 66

 [ BigDir
; >>>>>>>>>>>>>>>
; FileCoreVersion
; <<<<<<<<<<<<<<<

; this function returns 100* the version number of FileCore, in r0, or
; zero if it's not found

; entry: nothing

; exit:
;	R0=100* filecore version or 0 if it's not found

FileCoreTitle
	DCB	"FileCore",0
	ALIGN

FileCoreVersion ROUT
	Push	"R1-R5,LR"

	MOV	r0, #ModHandReason_LookupName
	ADR	r1, FileCoreTitle

	SWI	XOS_Module	; r3=module code

	MOVVS	R0, #0
	BVS	%FT95

	LDR	lr, [r3, #&14]

	ADD	r3, r3, lr

10
	LDRB	lr, [r3], #1
	TEQS	lr, #'.'
	BEQ	%FT20

	TEQS	lr, #0		; not end of string
	BNE	%BT10

	MOV	r0, #0
	B	%FT95

20	; found '.'

	LDRB	r1, [r3, #-2]	; first digit
	SUB	r1, r1, #'0'

	MOV	lr, #100
	MUL	r0, r1, lr	; 100*first

	LDRB	r1, [r3, #0]	; first part of next bit
	SUB	r1, r1, #'0'
	MOV	lr, #10
	MLA	r0, r1, lr, r0	; second

	LDRB	r1, [r3, #1]
	SUB	r1, r1, #'0'

	ADD	r0, r0, r1
	B	%FT95

95
	Pull	"R1-R5,PC",,^
 ]
@


4.1.4.2
log
@RAMFS doesn't initialise the RAM disc any more, and relies on the kernel
doing so.
@
text
@a19 1

d42 25
a91 6
FullTitle
        Text    "FileCore%RAM"

RAMdiscName
        DCB     "RAM::RamDisc0",0

a105 2


a109 1

d117 2
a121 1

d123 1
a125 2
        ADRL    LR, SkeletonDiscRec
        LDMIA   LR, {R2,R5,R7-R9}
d140 3
d158 7
d179 53
d277 1
d288 26
a317 1

d325 1
d385 1
d398 191
d710 65
@


4.1.4.3
log
@Made it re-format the RAM disc on init.
@
text
@a88 280
 [ BigDir
InitRAMDisc ROUT
	Push	"R0-R11,LR"
	ADRL	r0, RAMDisc_DismountStr
	SWI	XOS_CLI

        SWI     XOS_ReadRAMFsLimits     ;(->R0,R1)

	SUBS	r6, r1, r0
	BEQ	%FT85

	MOV	r1, #4096
	MOV	r2, #0
10
	STR	r2, [r0], #4
	SUBS	r1, r1, #4
	BNE	%BT10

	SUB	sp, sp, #DiscRecSig2

	ADRL	R0, SkeletonDiscRec	; source

	MOV	R1, SP			; dest
	MOV	R2, #DiscRecSig2	; length

20
	LDR	R3, [R0], #4
	STR	R3, [R1], #4
	SUBS	R2, R2, #4
	BNE	%BT20

	STR	R6, [SP, #DiscSize]	;store away the size

	MOV	r5, SP
	BL	InitDiscRec		; fill in the disc record fields which need calculation

	MOV	r1, #WriteTrkOp
	ORR	r1, r1, r5, LSL #6
	MOV	r2, #0
	MOV	r3, #0
	MOV	r4, #1024
	LDR	r8, FileCorePrivate
	SWI	XFileCore_DiscOp

	BVS	%FT75

	MOV	r0, #&CF
	ADRL	r1, RAMDisc_RAMdisc0Name	; name ptr
	SWI	XOS_Find		; find it

	BVS	%FT75			; failed to do so

	MOV	R3, R0

	MOV	r0, sp
	ADRL	r1, RAMDisc_EmptyBBList		; no bad block list
	ADRL	r2, RAMDisc_JustDiscName	; disc name

	SWI	XFileCore_LayoutStructure

	MOV	r0, #0
	MOV	r1, r3
	SWI	XOS_Find

	ADRL	r0, RAMDisc_DismountStr
	SWI	XOS_CLI

	ADRL	r0, RAMDisc_MountStr
	SWI	XOS_CLI

75
	ADD	sp, sp, #DiscRecSig2

85
	STRVS	r0, [sp]
	Pull	"R0-R11,PC"


RAMDisc_EmptyBBList
	DCD	-1
RAMDisc_JustDiscName
	DCB	"RamDisc0",0
	ALIGN
RAMDisc_RAMdisc0Name
        DCB     "RAM::0",0
        ALIGN
RAMDisc_DismountStr
	DCB	"RAM:Dismount :0",0
RAMDisc_MountStr
	DCB	"RAM:mount :0",0
	ALIGN

; >>>>>>>>>>>
; InitDiscRec
; >>>>>>>>>>>

; this routine generates the values in the disc record to suit the
; chosen size of the RAM disc.  We need to work out the values, and
; place them in a disc record

; in:
;
;    r5 -> disc record

; out:
;
;   disc record fields filled in: zones, zonespare, LinkBits and bitsize

; here's some definitions used by this routine:

Min_LinkBits	*	13	; minimum allowed LinkBits (with 1024 byte zones)
Max_LinkBits	*	19	; maximum allowed LinkBits (unlikely!)
Min_BitSize	*	7	; minimum allowed bitsize
Max_BitSize	*	12	; max allowed bitsize
Min_ZoneSpare	*	32	; min allowed zonespare
Max_ZoneSpare	*	64	; max allowed zonespare
Min_Zones	*	1	; min allowed zones
Max_Zones	*	16	; max allowed zones

; internal register allocation:

; r5 -> disc record

; r0 = current bitsize
; r1 = current zonespare
; r2 = current zones
; r3 = current LinkBits
; r4 = map allocation bits required to cover disc
; r6 = number of bits in a zone
; r7 = number of allocation bits in the map
; r8 = ids per zone


InitDiscRec	ROUT
	Push	"R0-R11,LR"

	MOV	r0, #Min_BitSize	; init BitSize

10	; loop on BitSize
	LDR	r4, [r5, #DiscSize]
	MOV	r4, r4, LSR r0		; map bits for disc

	MOV	r1, #Min_ZoneSpare	; init ZoneSpare
20	; loop on zonespare

	LDR	lr, [r5, #SectorSize]
	MOV	r6, #8
	MOV	r6, r6, LSL lr		; bits in a zone
	SUB	r6, r6, r1		; minus sparebits

	; choose number of zones to suit

	MOV	r2, #Min_Zones		; minimum of one zone
	SUB	r7, r6, #Zone0Bits	; bits in zone 0

30	; loop for zones
	CMP	r7, r4			; do we have enough allocation bits yet?
	BHS	%FT35			; if we do, then accept this number of zones

	ADD	r7, r7, r6		; more map bits
	ADD	r2, r2, #1		; and another zone
	CMPS	r2, #Max_Zones
	BLS	%BT30			; still ok

	; here when too many zones; try a higher BitSize

	B	%FT80

35
	; now we have to choose LinkBits.  we want LinkBits to be
	; the smallest it can be for the disc.

	MOV	r3, #Min_LinkBits		; minimum value of LinkBits

40	; loop for LinkBits

	Push	"R0, R1, R2"
	MOV	r0, r6			; allocation bits in a zone
	ADD	r1, r3, #1		; LinkBits+1
	DivRem	r8, r0, r1, r2
	Pull	"R0, R1, R2"

	; check that LinkBits is enough for total possible ids
	MOV	r9, #1			; work out 1<<LinkBits
	MOV	r9, r9, LSL r3		;

	MUL	lr, r8, r2		; total ids needed
	CMPS	lr, r9			; LinkBits too small?
	BHI	%FT60			; yes!

	; we're nearly there.  now work out if the last zone
	; can be handled correctly.

	SUBS	lr, r7, r4
	BEQ	%FT50

	CMPS	lr, r3			; must be at least LinkBits+1 bits
	BLE	%FT60

	; check also that we're not too close to the start of the zone

	SUB	lr, r7, r6		; get the start of the zone

	SUB	lr, r4, lr		;
	CMPS	lr, r3
	BLE	%FT60


50	; we've found a result - fill in the disc record!

	; first, store the things we know about

	STRB	r3,[r5, #LinkBits]
	MOV	r1, r1, LSL #16
	ORR	r1, r1, r2, LSL #8

	STR	r1, [r5, #ZoneSpare-2]

	STRB	r0, [r5, #BitSize]

	LDR	lr, [r5, #DiscVersion]

	MOVS	lr, lr

	BEQ	%FT01			; do we have long filenames?

	; here when long filenames

	; the root dir's ID is the first available ID in the middle
	; zone of the map


	MOVS	r2, r2, LSR #1		; zones/2

	MULNE	lr, r2, r8		; *idsperzone
	MOVEQ	lr, #3			; if if zones/2=0, then only one zone, so the id is 3 (0,1,2 reserved)

	MOV	lr, lr, LSL #8		; construct full indirect disc address
	ORR	lr, lr, #1		; with sharing offset of 1

	B	%FT02

01
	; here when not long filenames

	; root dir is &2nn where nn is ((zones<<1)+1)

	MOV	lr, r2, LSL #1
	ADD	lr, lr, #1
	ADD	lr, lr, #&200

02

	STR	lr, [r5, #RootDir]	; root dir disc addr


	B	%FT90

; other fields in the disc record are fixed-value

60	; NEXT LinkBits
	ADD	r3, r3, #1
	CMPS	r3, #Max_LinkBits
	BLS	%BT40

70	; NEXT zonespare
	ADD	r1, r1, #1
	CMPS	r1, #Max_ZoneSpare
	BLS	%BT20


80	; NEXT BitSize
	ADD	r0, r0, #1
	CMPS	r0, #Max_BitSize	; is it too much?
	BLS	%BT10			; back around

90
	Pull	"R0-R11,PC",,^

 ]
a152 2

	BL	InitRAMDisc		; just in case the Kernel hasn't done it
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

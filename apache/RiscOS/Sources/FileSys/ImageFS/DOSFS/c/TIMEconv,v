head	4.13;
access;
symbols
	DOSFS-1_14:4.13
	DOSFS-1_13:4.13
	DOSFS-1_12:4.13
	DOSFS-1_11:4.13
	DOSFS-1_10:4.13
	DOSFS-1_09:4.13
	DOSFS-1_08:4.12
	DOSFS-1_07:4.12
	DOSFS-1_06:4.11
	DOSFS-1_05:4.11
	DOSFS-1_04:4.11
	DOSFS-1_03:4.11
	DOSFS-1_02:4.11
	DOSFS-1_01:4.11
	DOSFS-1_00:4.10
	DOSFS-0_99:4.10
	DOSFS-0_98:4.10
	DOSFS-0_97:4.9
	DOSFS-0_96:4.9
	DOSFS-0_95:4.8
	DOSFS-0_94:4.8
	DOSFS-0_93:4.8
	DOSFS-0_92:4.8
	DOSFS-0_91:4.8
	DOSFS-0_90:4.8
	DOSFS-0_89:4.7
	DOSFS-0_88:4.7
	DOSFS-0_87:4.7
	DOSFS-0_86:4.6
	DOSFS-0_85:4.6
	DOSFS-0_84:4.6
	DOSFS-0_83:4.6
	DOSFS-0_82:4.6
	DOSFS-0_81:4.6
	DOSFS-0_80:4.6
	DOSFS-0_79:4.6
	RO_5_07:4.6
	DOSFS-0_78:4.6
	DOSFS-0_77:4.6
	DOSFS-0_76:4.6
	DOSFS-0_75:4.6
	DOSFS-0_74:4.6
	DOSFS-0_73:4.5
	DOSFS-0_72:4.5
	DOSFS-0_71:4.5
	DOSFS-0_70:4.5
	DOSFS-0_69:4.4
	DOSFS-0_68:4.3
	DOSFS-0_67:4.2
	DOSFS-0_66:4.1
	DOSFS-0_65:4.1
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	DOSFS-0_64:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_DOSFS_0_63:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2016.03.18.21.44.19;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	tMFs57eIOarfHaZy;

4.12
date	2014.06.25.20.13.35;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	E7yWETwfWvNEvWFx;

4.11
date	2013.01.13.18.57.33;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	IcVKoGKFReBN35Aw;

4.10
date	2013.01.13.18.49.43;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	fjzSOoRRnhA815Aw;

4.9
date	2012.12.07.14.20.17;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	jnwtWy3St1iqIivw;

4.8
date	2012.06.10.13.25.16;	author bavison;	state Exp;
branches;
next	4.7;
commitid	tzPLCsjFs2keca8w;

4.7
date	2009.06.11.21.01.27;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2003.05.23.17.21.16;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.08.10.09.01;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2002.09.22.11.30.06;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2002.05.03.15.31.26;	author rsprowso;	state Exp;
branches;
next	4.2;

4.2
date	2002.03.15.13.05.08;	author rsprowso;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.33.02;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.33.02;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.54.46;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.37.35;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.34.05;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Fix a few potential memory leaks
Some of the long filenames handling added in DOSFS-0_79 (DOSFSops.c revision 4.10) introduced extra points to return in the face of error, but didn't free memory allocated earlier in the function.
Add missing free()'s.
From a tip off from Dominic Plunkett in http://www.riscosopen.org/forum/forums/4/topics/3990#posts-51013

Version 1.09. Tagged as 'DOSFS-1_09'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*> c.TIMEconv <*/
/*---------------------------------------------------------------------------*/
/* RISC OS time conversion functions                        (c) 1988 JGSmith */
/*---------------------------------------------------------------------------*/

#include <stdint.h>
#include <stdlib.h>
#include <time.h>
#include "kernel.h"
#include "swis.h"
#include "DebugLib/DebugLib.h"
#include "Global/FileTypes.h"
#include "Global/OSWords.h"

#include "DOSFS.h"
#include "TIMEconv.h"
#include "MsgTrans.h"
#include "ADFSshape.h"

/*---------------------------------------------------------------------------*/

static void addoffset(word value,word *lo4bytes,word *hi1byte)
{
 word old_lo4bytes = *lo4bytes ;

 *lo4bytes += value ;

 if (*lo4bytes < old_lo4bytes) /* then a carry must have occured */
  *hi1byte += 1 ;

 return ;
}

/*---------------------------------------------------------------------------*/

static void addleapday(word *lo4bytes,word *hi1byte,word yearLO,word yearHI)
{
 word value = ticksday ;

 if ((yearLO & 0x03) == 0) /* multiple of 4 */
  {
   if (yearLO != 0)        /* multiple of 100 */
    {
     addoffset(value,lo4bytes,hi1byte) ;
     return ;
    }

   if ((yearHI & 0x03) == 0) /* multiple of 400 */
    {
     addoffset(value,lo4bytes,hi1byte) ;
     return ;
    }
  }

 return ;
}

/*---------------------------------------------------------------------------*/
/* I hate having constants in the source... but the  pre-processor will not
 * be able to generate this one
 */
#define to1970 INT64_C(0x336E996A00)
#define to1980 INT64_C(0x3AC7524200)

/*---------------------------------------------------------------------------*/

static int BCDto5byte(BCDtime *intime,time5byte *outtime)
{
 byte standardmonthlens[12] = {
                               31, /* Jan */
                               28, /* Feb */
                               31, /* Mar */
                               30, /* Apr */
                               31, /* May */
                               30, /* Jun */
                               31, /* Jul */
                               31, /* Aug */
                               30, /* Sep */
                               31, /* Oct */
                               30, /* Nov */
                               31, /* Dec */
                              } ;
 word standardmonths[13] ; /* accumulative total of csec offsets for months
                             * calculated at run-time (month 13 should be
                             * identical to the "ticksyear" definition)
                             */
 int    yHI = (intime->year / 100) ;
 int    yLO = (intime->year % 100) ;
 int    months = (intime->month) ;
 int    days = (intime->day) ;
 int    hours = (intime->hour) ;
 int    mins = (intime->minutes) ;
 int    secs = (intime->seconds) ;
 int    csecs = (intime->centiseconds) ;
 word *centiseconds = &(outtime->lo) ;
 word *hibyte = &(outtime->hi) ;

 word value = 0 ; /* temporary store for centisecond increment */
 int   loop ;

 *centiseconds = csecs ;
 *hibyte = 0 ;

 for (loop = 1; (loop < 13); loop++)
  {
   standardmonths[loop - 1] = value ;
   value += (standardmonthlens[loop - 1] * ticksday) ;
  }
 standardmonths[loop - 1] = value ;

 if (standardmonths[loop - 1] != ticksyear)
  {
   dprintf(("", "fatal run-time error: year centi-second total mismatch\n"));
   return(-1) ;
  }

 if (yHI < 19)
  {
   dprintf(("", "BCDto5byte: year less than 1900 (invalid)\n"));
   return(-1) ;
  }

 if (months >= 3) /* have we passed leap day in this year */
  addleapday(centiseconds,hibyte,yLO,yHI) ; /* add day if leap year */

 while (yHI >= 19)   /* don't go earlier than 1900 */
  {
   if (--yLO < 0)
    {
     yLO = 99 ;
     yHI-- ;
    }

   if (yHI >= 19)   /* don't go earlier than 1900 */
    {
     addleapday(centiseconds,hibyte,yLO,yHI) ; /* add day if leap */
     addoffset(ticksyear,centiseconds,hibyte) ;      /* add standard year */
    }
  }

 /* deal with months */
 addoffset(standardmonths[months - 1],centiseconds,hibyte) ;

 /* deal with days */
 if (days != 0)
  while (--days != 0)
   addoffset(ticksday,centiseconds,hibyte) ;

 /* deal with hours */
 while (--hours >= 0)
  addoffset(tickshour,centiseconds,hibyte) ;

 /* deal with minutes */
 while (--mins >= 0)
  addoffset(ticksmin,centiseconds,hibyte) ;

 /* deal with seconds */
 while (--secs >= 0)
  addoffset(tickssec,centiseconds,hibyte) ;

#ifdef TIMEWORK
 dprintf(("", "BCDto5byte: &%02x%08x\n",*hibyte,*centiseconds));
#endif

 return(0) ;
}

static int convert5bytetoBCD(time5byte *intime,BCDtime *outtime)
{
 /* convert the 5byte centisecond time from 00:00:00 1 Jan 1900 into BCD */
 /* NOTE: this can be done by calculating the centi-second time from
  *       00:00:00 1 Jan 1970 (i.e. the UNIX representation) and using the
  *       library function "struct tm *gmtime(time_t *timer)" to convert
  *       to a BCD form...
  *
  *       "00:00:00 1 Jan 1900" -> "00:00:00 1 Jan 1970" = &336E996A00
  */
 time_t     since1970 ;
 struct tm *unixtime ;
 int64_t   delta ;
 int64_t   quotient ;

#ifdef TIMEWORK
 dprintf(("", "convert5bytetoBCD: now  &%02x%08x\n",intime->hi,intime->lo));
 dprintf(("", "convert5bytetoBCD: 1970 &%010"PRIx64"\n",to1970));
#endif

 /* calculate centi-second difference (limit it at "00:00:00 1 Jan 1970"
  * to ensure it can be represented as a DOS time) */
 delta = ((int64_t) intime->hi << 32) + intime->lo - to1970 ;
 if (delta < to1980 - to1970)
   delta = to1980 - to1970;

#ifdef TIMEWORK
 dprintf(("", "convert5bytetoBCD: delta &%010"PRIx64"\n",delta));
#endif

 /* the UNIX time is only a 32bit seconds (as opposed to 40bit centi-seconds)
  * quantity
  */
 /* Make sure we always round up. */
 quotient = (delta + (tickssec - 1)) / tickssec;

#ifdef TIMEWORK
 dprintf(("", "convert5bytetoBCD: delta (as secs) &%08x\n",(time_t) quotient));
#endif

 /* this gives us the number of seconds since 00:00:00 1 Jan 1970 */

 since1970 = (time_t) quotient ; /* largest possible for the moment */

 unixtime = gmtime(&since1970) ;

 /* transfer the data from the library structure */
 outtime->year = unixtime->tm_year + 1900 ;
 outtime->month = unixtime->tm_mon + 1 ;
 outtime->day = unixtime->tm_mday;
 outtime->hour = unixtime->tm_hour ;
 outtime->minutes = unixtime->tm_min ;
 outtime->seconds = unixtime->tm_sec ;
 outtime->centiseconds = 0 ;

 /* completed successfully */
 return(0) ;
}

/*---------------------------------------------------------------------------*/
/* time and date conversions:
 *  MSDOStoRISCOS     : convert MSDOS date & time to RISC OS date/time
 *  MSDOStoSTRING     : convert MSDOS date & time to RISC OS style string (unused)
 *  RISCOStoTIME      : convert RISC OS date/time to MSDOS TIME
 *  RISCOStoDATE      : convert RISC OS date/time to MSDOS DATE
 */

void MSDOStoRISCOS(word MStime,word MSdate,time5byte *outtime)
{
 /* this generates RISC OS style LOAD and EXEC addresses containing the
  * given MSDOS time/date
  * The RISC OS file type is set to "DOS"
  *
  * load address: = &FFFtttdd
  * exec address: = &dddddddd
  * dddddddddd is the (5byte) centisecond time from 00:00:00 on 1st Jan 1900
  *
  * if an invalid time is given, then the default time (above) is returned
  */
 BCDtime otime ;

 otime.year = (((MSdate & year_mask) >> year_shift) + 1980) ;
 otime.month = ((MSdate & mon_mask) >> mon_shift) ;
 otime.day = ((MSdate & day_mask) >> day_shift) ;
 otime.hour = ((MStime & hour_mask) >> hour_shift) ;
 otime.minutes = ((MStime & min_mask) >> min_shift) ;
 otime.seconds = (((MStime & sec_mask) >> sec_shift) * 2) ;
 otime.centiseconds = 0 ;

 if ((BCDto5byte(&otime,outtime) < 0) || (MStime==0 && MSdate==0))
  {
  outtime->hi = ((ADFStimestamp | 0x00) & ~ADFStypemask) ;
  outtime->lo = 0x00000000 ;
  }
 else
  outtime->hi = ((ADFStimestamp | (outtime->hi & 0xFF)) & ~ADFStypemask) ;

 /* and add in the DOS file-type identifier */
 outtime->hi |= (FileType_MSDOS << ADFStypeshift) ;

 return ;
}

/*---------------------------------------------------------------------------*/
#if 0 /* not used at the moment */
char *MSDOStoSTRING(word MSDOStime,word MSDOSdate)
{
 /* convert time/date to standard time string */
 time5byte         ROStime ;
 char             *buffer ;
 _kernel_swi_regs  reglist ;
 _kernel_oserror  *rerror ;

 /* The function prototype could be changed to allow the buffer to be
  * passed into the function. Thus saving the overhead of calling malloc
  * and free for each use of MSDOStoSTRING. At the moment however there is
  * only one user of this function.
  */

 if ((buffer = malloc(MaxString)) == NULL)
  return(NULL) ;

 MSDOStoRISCOS(MSDOStime,MSDOSdate,&ROStime) ;

 reglist.r[0] = (word)&ROStime ;
 reglist.r[1] = (word)buffer ;
 reglist.r[2] = (MaxString - 1) ;
 if ((rerror = _kernel_swi(OS_ConvertStandardDateAndTime,&reglist,&reglist)) != NULL)
 {
  free(buffer) ;
  return(NULL) ;
 }

 return(buffer) ;
}
#endif
/*---------------------------------------------------------------------------*/

word RISCOStoTIME(time5byte *ROStime)
{
 /* convert RISC OS 5 byte time/date into the 16bit MSDOS time */
 word   DOStime ;
 BCDtime fulltime ;

 convert5bytetoBCD(ROStime,&fulltime) ;

 /* NOTE: this rounds the seconds up to the next 2second boundary (not down) */
 DOStime = ((fulltime.hour << hour_shift) & hour_mask) | ((fulltime.minutes << min_shift) & min_mask) | ((((fulltime.seconds + 1) >> 1) << sec_shift) & sec_mask) ;

 return(DOStime) ;
}

/*---------------------------------------------------------------------------*/

word RISCOStoDATE(time5byte *ROStime)
{
 /* convert RISC OS 5 byte time/date into the 16bit MSDOS date */
 word   DOSdate ;
 BCDtime fulltime ;

 convert5bytetoBCD(ROStime,&fulltime) ;

 DOSdate = (((fulltime.year - 1980) << year_shift) & year_mask) | ((fulltime.month << mon_shift) & mon_mask) | ((fulltime.day << day_shift) & day_mask) ;

 return(DOSdate) ;
}

/*---------------------------------------------------------------------------*/
/* return RISC OS centi-second time (based at 1 Jan 1900, UTC) */

time5byte *get_RISCOS_TIME(time5byte *timebuff)
{
 time5byte        *newTIME ;
 _kernel_swi_regs  reglist ;

 newTIME = ((timebuff == NULL) ? (time5byte *)malloc(sizeof(time5byte)) : timebuff) ;

 /* specify the format we wish to read the clock in */
 newTIME->lo = OWReadRTC_5ByteInt ;

 reglist.r[0] = OsWord_ReadRealTimeClock ;
 reglist.r[1] = (word)newTIME ;

 _kernel_swi(OS_Word,&reglist,&reglist) ;

 /* remove any extra bytes */
 newTIME->hi = (newTIME->hi & 0xFF) ;

 return(newTIME) ;
}

/*---------------------------------------------------------------------------*/
/*> c.TIMEconv <*/
@


4.12
log
@Change last couple of uses of trace macros to use DebugLib
This town ain't big enough for the two of us.

Version 1.07. Tagged as 'DOSFS-1_07'
@
text
@d310 2
d313 1
@


4.11
log
@Add missing message, use central allocations for DOSFS' FS number
Missing 'Stack full' error message added (German translation needed).
Use DOSFS FS number from headers.
Tested with floppy disc (FAT12), 1GB image file (FAT16) and 4GB image file (FAT32) with no issues seen.

Version 1.01. Tagged as 'DOSFS-1_01'
@
text
@d25 1
a31 1
#include "DOSshape.h"
a32 1
#include "debug.h"
d127 1
a127 1
   tracef0("fatal run-time error: year centi-second total mismatch\n") ;
d133 1
a133 1
   tracef0("BCDto5byte: year less than 1900 (invalid)\n") ;
d176 1
a176 1
 tracef2("BCDto5byte: &%02x%08x\n",*hibyte,*centiseconds) ;
d198 2
a199 2
 tracef2("convert5bytetoBCD: now  &%02x%08x\n",intime->hi,intime->lo) ;
 tracef2("convert5bytetoBCD: 1970 &%010"PRIx64"\n",to1970) ;
d209 1
a209 1
 tracef2("convert5bytetoBCD: delta &%010"PRIx64"\n",delta) ;
d219 1
a219 1
 tracef1("convert5bytetoBCD: delta (as secs) &%08x\n",(time_t) quotient) ;
@


4.10
log
@Rationalise some defines
Many magic numbers changed to exported defines.
Eliminated unused "BOOTblock.h" (was just nesting 1 include file).
Moved non ASCII definitions out of "ASCII.h" then found the remainder weren't used => eliminated.

Version 0.98. Tagged as 'DOSFS-0_98'
@
text
@d358 1
a358 1
 newTIME->lo = clock_5byte ;
@


4.9
log
@Source file subdivision
The sources to DOSFS had become rather jumbled and monolithic
* Split FileSwitch interface out into seperate ops source files.
* Combined international error lookup with MsgTrans code.
* Split utility functions into 'Helpers.c' along with wildcard matching functions.
* Moved DOS naming functions into, erm, 'DOSnaming.c'.
Also
* Makefile tweaked to remove 'symbols' on clean.
* Obsolete 'Help' and 'Syntax' placed in attic.

RAM, debug, and ROM targets built. RAM target tested with a DOS floppy disc.

Version 0.96. Tagged as 'DOSFS-0_96'
@
text
@d25 2
d28 1
a28 1
#include "debug.h"
d33 1
d281 1
a281 1
 outtime->hi |= (DOStype << ADFStypeshift) ;
d360 1
a360 1
 reglist.r[0] = OSWORD_readclock ;
@


4.8
log
@  Fixed timestamping
Detail:
  Renamed function "localTIME" to "get_RISCOS_TIME" since it has nothing to do
  with local time. This function used to call the C library function
  localtime(), but until recently the C library was non-conformant to the
  C standard, and simply produced a year/month/day/hour/minute/second breakdown
  as UTC. When this was fixed (RISC_OSLib 5.68) it changed DOSFS's behaviour;
  it was first detected because the reverse operation is implemented locally
  within DOSFS, so a read-modify-write of file attributes leads to the
  modification time being skewed by an amount equal to the difference between
  UTC and local time. Arguments can be made either to treat the on-disc time as
  local time (for compatibility with Windows and Mac OS) or as UTC (for
  compatibility with Linux or older RISC OS systems); I have opted to return
  behaviour to UTC. Also placed a lower limit on dates of the earliest date
  supported by FAT (1980), so for example if your system clock is set to 1970,
  as it will be if there is no RTC and NetTime is not operational, then you
  don't end up creating dates in the far future due to underflow.
Admin:
  Tested on a beagleboard

Version 0.90. Tagged as 'DOSFS-0_90'
@
text
@a19 1
#include <stdio.h>
a21 4
#include <stddef.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
a22 1
#include <signal.h>
d28 1
a28 2
#include "FSerrors.h"
#include "DOSFSctl.h"
@


4.7
log
@  #include file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both Norcroft and GCC.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 0.86. Not tagged
@
text
@d82 1
d86 1
a86 1
int BCDto5byte(BCDtime *intime,time5byte *outtime)
d187 1
a187 1
int convert5bytetoBCD(time5byte *intime,BCDtime *outtime)
d192 1
a192 1
  *       library function "struct tm *localtime(time_t *timer)" to convert
d207 2
a208 2
 /* calculate centi-second difference (This code assumes that the current
  * time is later than "00:00:00 1 Jan 1970" */
d210 2
d231 1
a231 1
 unixtime = localtime(&since1970) ;
d352 1
a352 1
/* return RISC OS centi-second time */
d354 1
a354 1
time5byte *localTIME(time5byte *timebuff)
@


4.6
log
@Rewrote Service_IdentifyDisc partly because it was an unreadable mess but
mainly so it can handle fixed discs too - this will be useful for DOS
format USB mass storage.
Also it will have a go at interpreting the partition table on fixed discs.
Tweak to filetyping logic (again!).

Version 0.74. Tagged as 'DOSFS-0_74'
@
text
@d32 6
a37 6
#include "h.debug"
#include "h.TIMEconv"
#include "h.FSerrors"
#include "h.DOSFSctl"
#include "h.DOSshape"
#include "h.ADFSshape"
@


4.5
log
@Missed an ORRNES while 32 bitting,corrected.
Unused MSDOStoSTRING #if'd out to save a massive 112 bytes!
Corrected tracef1 in map_file_rostype which was printing out the
debugging before the variable got assigned.
Conditionally uses FileCore_DiscOp64 now,if available when the module
starts.
Eliminated some local 64 bit time handling code in favour of using that
already in the compiler (thanks to Kevin).
Now requires a compile time switch PCMCIA=<TRUE | FALSE> which leaves in
or takes out the PCMCIA card support.

Version 0.70. Tagged as 'DOSFS-0_70'
@
text
@d288 1
a288 1
#if 0
@


4.4
log
@Deleted some dead variables and switches.
Eliminated MOVS and R14 fiddling to achieve 32 bit compatibility
RISCOS Ltd made 3 changes in their sources
 - ensure disc titles don't contain rogue characters (added)
 - files with time,date,and reserved fields of zero appears as DEADDEAD
   which is silly since Winodws uses this to mark a file unstamped which
   isn't quite the same thing! (not added)
 - syslog debugging support (not added)

Version 0.69. Tagged as 'DOSFS-0_69'
@
text
@d21 1
d81 1
a81 2
#define to1970_hi (0x33)
#define to1970_lo (0x6E996A00)
d198 2
a199 6
 word      arg1[2] ;
 word      arg2[2] ;
 word     *result ;
 word      divisor[2] ;
 word     *dividend;
 word     *quotient ;
d203 1
a203 1
 tracef2("convert5bytetoBCD: 1970 &%02x%08x\n",to1970_hi,to1970_lo) ;
d208 1
a208 5
 arg1[0] = intime->lo ;
 arg1[1] = intime->hi ;
 arg2[0] = to1970_lo ;
 arg2[1] = to1970_hi ;
 result = library_double_subtraction(arg1,arg2) ;
d211 1
a211 1
 tracef2("convert5bytetoBCD: delta &%02x%08x\n",result[1],result[0]) ;
d218 1
a218 6
 arg2[0] = tickssec - 1;
 arg2[1] = 0;
 dividend = library_double_addition(result, arg2);
 divisor[0] = tickssec ;
 divisor[1] = 0 ;        /* assumes "tickssec" is a 32bit quantity */
 quotient = library_double_udivide(divisor,dividend) ;
d221 1
a221 1
 tracef1("convert5bytetoBCD: delta (as secs) &%08x\n",quotient[0]) ;
d226 1
a226 1
 since1970 = quotient[0] ; /* largest possible for the moment */
d246 1
a246 1
 *  MSDOStoSTRING     : convert MSDOS date & time to RISC OS style string
d288 1
a288 1

d316 1
a316 1

@


4.3
log
@Jump instruction in the boot sector of Atari discs now correct.
Dates on machines not running Win95FS no longer stuck at 1900 (got
broken in 0.67 by a missing && somewhere).

Version 0.68. Tagged as 'DOSFS-0_68'
@
text
@a201 1
#if 1 /* SMC_FIX */
a202 3
#else
 word      dividend[2] ;
#endif
a224 1
#if 1 /* SMC_FIX */
a228 4
#else
 dividend[0] = result[0] ;
 dividend[1] = result[1] ;
#endif
@


4.2
log
@Unstamped files (marked by DOS with a time and date of 0x0000) will now
return 01-Jan-1900 rather than very late at night on 31-Dec-1979.
Can now set the RISC OS type to 0x000 (previously this would then have been
stamped as 0xFE4 since 0x000 was used as a magic 'no filetype found' marker.
Will now try to use MimeMap if no 'dosmap'ping was found,in this way dosmap
overrides MimeMap for DOSFS - if neither offer a match,0xFE4 is used.
Updated messages to reflect this.
Discs formatted under DOSFS will now set the OEM vendor id to "DOSFS   ".

Version 0.67. Tagged as 'DOSFS-0_67'
@
text
@d295 1
a295 1
 if ((BCDto5byte(&otime,outtime) < 0) || (MStime==MSdate==0))
@


4.1
log
@Initial revision
@
text
@d277 1
a277 1
  * The RISC OS file type is set to "DOStype"
d295 1
a295 1
 if (BCDto5byte(&otime,outtime) < 0)
d297 2
a298 2
   outtime->hi = ((ADFStimestamp | 0x00) & ~ADFStypemask) ;
   outtime->lo = 0x00000000 ;
d304 1
a304 1
 outtime->hi |= (DOStype << 8) ;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

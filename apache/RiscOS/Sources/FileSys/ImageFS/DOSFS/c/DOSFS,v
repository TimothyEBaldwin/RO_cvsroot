head	4.31;
access;
symbols
	DOSFS-1_14:4.31
	DOSFS-1_13:4.31
	DOSFS-1_12:4.31
	DOSFS-1_11:4.30
	DOSFS-1_10:4.29
	DOSFS-1_09:4.28
	DOSFS-1_08:4.28
	DOSFS-1_07:4.26
	DOSFS-1_06:4.25
	DOSFS-1_05:4.25
	DOSFS-1_04:4.25
	DOSFS-1_03:4.24
	DOSFS-1_02:4.23
	DOSFS-1_01:4.23
	DOSFS-1_00:4.23
	DOSFS-0_99:4.22
	DOSFS-0_98:4.21
	DOSFS-0_97:4.20
	DOSFS-0_96:4.20
	DOSFS-0_95:4.19
	DOSFS-0_94:4.19
	DOSFS-0_93:4.18
	DOSFS-0_92:4.17
	DOSFS-0_91:4.17
	DOSFS-0_90:4.17
	DOSFS-0_89:4.16
	DOSFS-0_88:4.16
	DOSFS-0_87:4.16
	DOSFS-0_86:4.15
	DOSFS-0_85:4.15
	DOSFS-0_84:4.15
	DOSFS-0_83:4.15
	DOSFS-0_82:4.14
	DOSFS-0_81:4.14
	DOSFS-0_80:4.14
	DOSFS-0_79:4.14
	RO_5_07:4.13
	DOSFS-0_78:4.13
	DOSFS-0_77:4.12
	DOSFS-0_76:4.11
	DOSFS-0_75:4.10
	DOSFS-0_74:4.9
	DOSFS-0_73:4.8
	DOSFS-0_72:4.8
	DOSFS-0_71:4.8
	DOSFS-0_70:4.7
	DOSFS-0_69:4.6
	DOSFS-0_68:4.5
	DOSFS-0_67:4.4
	DOSFS-0_66:4.3
	DOSFS-0_65:4.2
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	DOSFS-0_64:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.2
	Ursula_RiscPC:4.1.4.2.0.2
	nicke_DOSFS_0_63:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.2
	UrsulaBuild_FinalSoftload:4.1.4.2
	rthornb_UrsulaBuild-12Aug1998:4.1.4.2
	aglover_UrsulaBuild-05Aug1998:4.1.4.2
	rthornb_UrsulaBuild-29Jul1998:4.1.4.2
	rthornb_UrsulaBuild-22Jul1998:4.1.4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.2
	rthornb_UrsulaBuild-07Jul1998:4.1.4.2
	rthornb_UrsulaBuild-17Jun1998:4.1.4.2
	rthornb_UrsulaBuild-03Jun1998:4.1.4.2
	rthornb_UrsulaBuild-27May1998:4.1.4.2
	rthornb_UrsulaBuild-21May1998:4.1.4.2
	rthornb_UrsulaBuild_01May1998:4.1.4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.31
date	2018.02.19.00.06.05;	author jlee;	state Exp;
branches;
next	4.30;
commitid	ic65jLota7NRUorA;

4.30
date	2017.12.17.09.29.25;	author rsprowson;	state Exp;
branches;
next	4.29;
commitid	38CSk47LemUE5ejA;

4.29
date	2017.11.21.21.34.08;	author rsprowson;	state Exp;
branches;
next	4.28;
commitid	jPD29OqViOM7WWfA;

4.28
date	2014.11.02.17.53.53;	author rsprowson;	state Exp;
branches;
next	4.27;
commitid	jLG2K2peqo1FyDWx;

4.27
date	2014.11.02.17.32.04;	author rsprowson;	state Exp;
branches;
next	4.26;
commitid	gnoBKmTqLNOZqDWx;

4.26
date	2014.06.25.20.13.35;	author rsprowson;	state Exp;
branches;
next	4.25;
commitid	E7yWETwfWvNEvWFx;

4.25
date	2014.05.31.17.21.03;	author rsprowson;	state Exp;
branches;
next	4.24;
commitid	7CKbqkXT93CimICx;

4.24
date	2014.05.22.09.50.05;	author rsprowson;	state Exp;
branches;
next	4.23;
commitid	J18R8TiBgxsw9wBx;

4.23
date	2013.01.13.18.55.01;	author rsprowson;	state Exp;
branches;
next	4.22;
commitid	3lYJMhP8ONWX25Aw;

4.22
date	2013.01.13.18.52.34;	author rsprowson;	state Exp;
branches;
next	4.21;
commitid	oq0uLRDtA5Y625Aw;

4.21
date	2013.01.13.18.49.43;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	fjzSOoRRnhA815Aw;

4.20
date	2012.12.07.14.20.15;	author rsprowson;	state Exp;
branches;
next	4.19;
commitid	jnwtWy3St1iqIivw;

4.19
date	2012.08.06.22.54.15;	author bavison;	state Exp;
branches;
next	4.18;
commitid	zQpkXhOxPHjTvxfw;

4.18
date	2012.07.23.16.02.11;	author bavison;	state Exp;
branches;
next	4.17;
commitid	qSAM3nuJ4CArGHdw;

4.17
date	2012.06.10.13.25.15;	author bavison;	state Exp;
branches;
next	4.16;
commitid	tzPLCsjFs2keca8w;

4.16
date	2009.06.11.21.01.26;	author bavison;	state Exp;
branches;
next	4.15;

4.15
date	2004.10.29.01.22.35;	author jballance;	state Exp;
branches;
next	4.14;

4.14
date	2004.09.30.21.59.06;	author jballance;	state Exp;
branches;
next	4.13;

4.13
date	2003.07.25.14.29.06;	author rsprowson;	state Exp;
branches;
next	4.12;

4.12
date	2003.06.26.11.44.24;	author rsprowson;	state Exp;
branches;
next	4.11;

4.11
date	2003.06.13.17.25.28;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2003.06.06.17.23.25;	author rsprowson;	state Exp;
branches;
next	4.9;

4.9
date	2003.05.23.17.21.16;	author rsprowson;	state Exp;
branches;
next	4.8;

4.8
date	2002.12.10.21.01.37;	author rsprowson;	state Exp;
branches;
next	4.7;

4.7
date	2002.11.08.10.09.01;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2002.09.22.11.30.06;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2002.05.03.15.31.26;	author rsprowso;	state Exp;
branches;
next	4.4;

4.4
date	2002.03.15.13.05.07;	author rsprowso;	state Exp;
branches;
next	4.3;

4.3
date	2001.08.17.11.29.06;	author rsprowso;	state Exp;
branches;
next	4.2;

4.2
date	98.11.25.12.52.51;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.32.57;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.32.57;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.54.06;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.06.19.08.35.59;	author kbracey;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.04.14.12.49.52;	author rthornb;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.37.24;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.33.54;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.31
log
@Reject overly-large discs, and other invalid things
Detail:
  c/Accessors, h/Accessors, Makefile - Added some simple 'image accessor' routines to abstract over accessing the underlying disc/image file. These accept 64bit disc addresses and will check to make sure any size limits imposed by the lower-level API are adhered to (512MB limit for FileCore_DiscOp, or extent of image file for OS_GBPB)
  h/MsgTrans, Resources/Germany/Messages, Resources/UK/Messages - Add a couple of new error messages
  h/Helpers - Add a couple of macros to simplify reading 16/32bit values that are split into multiple bytes in struct definitions. Change writeWORD & loadWORD to accept void* instead of char* so they can be used with other types like 'byte'
  h/DOSshape - Add '0' suffix to some struct members so they can be used with new READ_0123 macro
  h/ADFSshape - Make sure put_doublestep is safe to use with bools
  c/DOSdirs - Remove pointless malloc of small temporary array
  c/DOSclusters - Use new READ_ macros in max_sector()
  c/DOSFS - Use new READ_ macros so code is less painful to read. Use new image accessor system to get rid of some boilerplate for reading from the disc (+ extra error checks). Change 32bit values to 64bit where it looks like it's necessary, and use bools in place of a couple of 0/1 ints. Reject any discs which are too big for the 32bit fields in the ADFS disc record.
  c/OpsFunc - Update DOSFS_image_open in ways similar to the code in c/DOSFS, making use of READ_, image accessor, 64bit values, and adding extra error checks.
Admin:
  Tested with assorted large & small image files & SD cards on a BB-xM, and some DOS/Atari floppy discs on a RiscPC
  FAT partitions larger than 4GB (or which extend past the 4GB FileSwitch limit) are now rejected, as are image files which have been truncated
  A future improvement could be to lift the disc/partition identification code out of c/DOSFS and c/OpsFunc and unify it, since both files contain fairly similar code
  German messages are in need of translation


Version 1.12. Tagged as 'DOSFS-1_12'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*> c.DOSFS <*/
/*-------------------------------------------------------------------------*/
/* DOSFS (image filing system module)           Copyright (c) 1990 JGSmith */
/*-------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <inttypes.h>
#include "kernel.h"
#include "swis.h"
#include "DebugLib/DebugLib.h"
#include "AsmUtils/rminfo.h"
#include "Global/CMOS.h"
#include "Global/OsBytes.h"
#include "Global/FileTypes.h"
#include "Global/Keyboard.h"
#include "Global/Variables.h"
#include "Global/Services.h"
#include "Interface/HighFSI.h"

#undef DOSFS_DiscFormat
#undef DOSFS_LayoutStructure

#include "DOSFS.h"
#include "TIMEconv.h"
#include "Helpers.h"
#include "Ops.h"
#include "MsgTrans.h"
#include "ADFSshape.h"
#include "DOSclusters.h"
#include "DOSnaming.h"
#include "DOSshape.h"
#include "DOSdirs.h"
#include "MultiFS.h"
#include "Statics.h"
#include "DOSFShdr.h"
#include "Accessors.h"

/*-------------------------------------------------------------------------*/
/* global (static) variables used within the module */

FILEhand    *FILE_list = NULL ;           /* Open file handle list */
mapentry    *maplist = NULL ;             /* DOS/RISC OS filetype mapping chain */
int         discopswi = FileCore_DiscOp;  /* Choice of whether we attempt a DiscOp64 or just DiscOp */
int         module_flags = 0 ;            /* Global flags */

/* The following are used for parameter returns to the RISC OS world. They
 * are provided as static structures to ensure they are not de-allocated
 * when we leave the C world (since normal variables are allocated from the
 * stack).
 */
FS_open_block fblock ;
FS_datestamp  tstamp ;
FS_cat_entry  fcat ;
FS_dir_block  dblock ;
FS_free_space fspace ;

/* These are used to create the MessageTrans tokens for the format menu
 * and help text.
 */
#define FORMAT_FMT     "FMT%d"
#define HELP_FMT       "FMTH%d"

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Register our filing system with RISC OS */

static _kernel_oserror *declare_FS(void *privateword)
{
 _kernel_swi_regs rset ;
 _kernel_oserror *err;
 word             infoblock[9] ; /* nasty constant */

 /* Read the CMOS RAM truncate bit state */
 rset.r[0] = OsByte_ReadCMOS;
 rset.r[1] = FileSwitchCMOS;
 if ((err = _kernel_swi(OS_Byte, &rset, &rset)) != NULL)
  return err;
 if (rset.r[2] & FileSwitchTruncateNamesCMOSBit) {
  dprintf(("","File names will be truncated.\n"));
  module_flags |= TRUNCATE_NAMES;
 } else {
  dprintf(("","Long file names will generate an error.\n"));
  module_flags &= ~TRUNCATE_NAMES;
 }

 /* register our module as an image filing system */
 /* "OS_FSControl" reason 35 */
 infoblock[0] = (word)0x00000000 ; /* bit27 is only significant flag */
 infoblock[1] = (word)FileType_MSDOSDisc ;
 infoblock[2] = ((word)DOSFS_Open     - (word)Image_RO_Base) ;
 infoblock[3] = ((word)DOSFS_GetBytes - (word)Image_RO_Base) ;
 infoblock[4] = ((word)DOSFS_PutBytes - (word)Image_RO_Base) ;
 infoblock[5] = ((word)DOSFS_Args     - (word)Image_RO_Base) ;
 infoblock[6] = ((word)DOSFS_Close    - (word)Image_RO_Base) ;
 infoblock[7] = ((word)DOSFS_File     - (word)Image_RO_Base) ;
 infoblock[8] = ((word)DOSFS_Func     - (word)Image_RO_Base) ;

 rset.r[0] = FSControl_RegisterImageFS;
 rset.r[1] = (word)Image_RO_Base ;
 rset.r[2] = ((word)infoblock - (word)Image_RO_Base) ;
 rset.r[3] = (word)privateword ;

 return(_kernel_swi(OS_FSControl,&rset,&rset)) ;
}

/*-------------------------------------------------------------------------*/
/* select_FS:
 * Select "DOSFS" as the current filing system.
 */
static _kernel_oserror *select_FS(void)
{
 _kernel_swi_regs rset ;

 rset.r[0] = FSControl_SelectFS ;               /* operation */
 rset.r[1] = (unsigned int)Module_Title ;       /* filing system name */
 return(_kernel_swi(OS_FSControl,&rset,&rset)) ;
}

/*-------------------------------------------------------------------------*/

static _kernel_oserror *FSSWI_DiscFormat(_kernel_swi_regs *rset,void *privateword)
{
 /* in:  r0 = pointer to disc format structure to be filled in
  *      r1 = vetting SWI (normally "ADFS_VetFormat")
  *      r2 = r1 parameter to the vetting SWI
  *      r3 = format specifier
  * out: r0 = pointer to disc format specification structure (updated)
  */
 _kernel_swi_regs  urset ;
 _kernel_oserror  *rerror = NULL ;
 format_spec      *fspec ;

 dprintf(("","DOSFS: FSSWI_DiscFormat: r0 = &%08X, r1 = &%08X, r2 = &%08X, r3 = &%08X\n",
             rset->r[0],rset->r[1],rset->r[2],rset->r[3]));

 /* see "format_spec" structure in "MultiFS.h" */
 /* place the desired disk format specification into the referenced structure */
 fspec = &(DOS_formatinfo[DOS_formats[rset->r[3]].findex]) ;
 dprintf(("","DOSFS: FSSWI_DiscFormat: found format_spec &%08X\n",(word)fspec)) ;
 (void)memmove((void *)rset->r[0],fspec,sizeof(format_spec)) ;

 dprintf(("","DOSFS: FSSWI_DiscFormat: fspec->secsize  = %d\n",fspec->secsize)) ;
 dprintf(("","DOSFS: FSSWI_DiscFormat: fspec->secstrk  = %d\n",fspec->secstrk)) ;
 dprintf(("","DOSFS: FSSWI_DiscFormat: fspec->density  = %d\n",fspec->density)) ;
 dprintf(("","DOSFS: FSSWI_DiscFormat: fspec->options  = &%02X\n",fspec->options)) ;
 dprintf(("","DOSFS: FSSWI_DiscFormat: fspec->startsec = %d\n",fspec->startsec)) ;
 dprintf(("","DOSFS: FSSWI_DiscFormat: fspec->tracks   = %d\n",fspec->tracks)) ;

 /* "VetFormat" SWI call:
  * in:  r0 = pointer to required format structure
  *      r1 = VetFormat parameter (r2 passed to "DiscFormat")
  * out: registers preserved (but structure possibly upgraded)
  */
 urset.r[0] = rset->r[0] ; /* copy of disc format structure */
 urset.r[1] = rset->r[2] ; /* parameter for the VetFormat call */
 if ((rerror = _kernel_swi(rset->r[1],&urset,&urset)) == NULL)
  {
   /* Re-check that the structure is still acceptable to us:
    *  Fields that cannot change:
    *     fspec->secsize  fspec->secstrk  fspec->density  fspec->options  fspec->startsec  fspec->tracks
    *
    * Fields that can possibly be changed:
    *     fspec->gap1side0  fspec->gap1side1  fspec->gap3
    * Some research is needed here to discover what values are acceptable
    * to standard MS-DOS machines.
    *
    * Fields that are acceptable to change:
    *     fspec->secileave  fspec->sideskew  fspec->trackskew  fspec->fillvalue
    */
   format_spec *rfspec = (format_spec *)urset.r[0] ;
   if ((rfspec->secsize != fspec->secsize) || (rfspec->secstrk != fspec->secstrk) || (rfspec->density != fspec->density) || (rfspec->options != fspec->options) || (rfspec->startsec != fspec->startsec) || (rfspec->tracks != fspec->tracks))
    rerror = global_error(err_badformat) ; /* changes unacceptable to us */
  }

 return(rerror) ;
 UNUSED(privateword) ;
}

static int testforbpb(ADFS_drecord *dr,char *sector,bool floppy,
                      int *numFATs,uint64_t *FATsize,int *magic,int *ROOTsize,
                      bool *Atari,bool *dblstep,int *numRESVD,word *volumeid)
{
 DOS_bootsector  *bblock = (DOS_bootsector *)sector;
 int discSize, noSides;

 /* Can only make sketchy test for a valid boot block, later test should fail */
 /* if the boot block is not really valid */
#ifdef NONFLOPPIES
 if (sector_size(bblock) == DOSsecsize)
#else
 if (sector_size(bblock) == DOSsecsize || bblock->BOOT_num_fats == 2)
#endif
    {
    /* Get number of sectors and number of sectors per track from BOOT block. */
    word maxsector = max_sector(bblock);
    word notracks = READ_LOHI(bblock->BOOT_secstrack);

    if (notracks == 0) return 1;

    notracks = maxsector / notracks; /* Calculate number of tracks from BOOT block. */
    uint64_t bbsize = ((uint64_t) maxsector) * DOSsecsize; /* Calculate disc size from BOOT block. */
 
    /* Calculate disc size too using disc record info. */
    discSize = (secspertrk(dr) * bytespersec(dr) * notracks) ;

    dprintf(("","DOSFS: testforbpb: discSize = &%08X\n",discSize)) ;
    dprintf(("","DOSFS: testforbpb: check size = &%016" PRIX64 "\n",bbsize)) ;

#ifdef NONFLOPPIES
    /* Now have to cope with solid state media with bits of first track "missing" */
    /* but if it's not a floppy we can't be sure of the real size */
    if (((bbsize < (((uint64_t) discSize) + (((uint64_t) secspertrk(dr))*bytespersec(dr)))) && (bbsize >= discSize)) || !floppy)
#else
    /* Validate the calculated size matches the discsize filecore has guessed */
    /* but if it's not a floppy we can't be sure of the real size*/
    if ((bbsize == discSize) || !floppy)
#endif
       {
       noSides = bblock->BOOT_heads;
       if (noSides > 0)
          {
          /* It's a DOS disc so claim it as one of ours and set up the disc record info. */
          if (bbsize > UINT32_MAX)
          {
            dprintf(("","DOSFS: testforbpb: disc too big\n"));
            return 1;
          }
          *magic = bblock->BOOT_magic;
          *ROOTsize = (READ_LOHI(bblock->BOOT_root_dir) * sizeof(DOS_direntry)) ;
          *FATsize = ((uint64_t) READ_LOHI(bblock->BOOT_FAT_size)) * DOSsecsize;
          *numFATs = bblock->BOOT_num_fats;
          *Atari = (bblock->BOOT_JMP[0] == 0); /* No JMP means Atari */
          *numRESVD = READ_LOHI(bblock->BOOT_reserved) ;
          *dblstep = ((notracks / noSides) == 40);
          if (bblock->BOOT_extra.fat12.sig_rec == 0x29)
             {
             /* There's an extended boot record,note the volume id */
             *volumeid = READ_0123(bblock->BOOT_extra.fat12.volid);
             }
          else if (bblock->BOOT_extra.fat32.BootSig == 0x29)
             {
             /* There's an extended FAT32 boot record,note the volume id */
             *volumeid = READ_0123(bblock->BOOT_extra.fat32.VolID);
             /* use correct ROOTsize */
             if (0 == *ROOTsize)
                *ROOTsize = cluster_size(bblock);
             /* .. and also correct FAT size */
             if (0 == *FATsize)
                {
                *FATsize = ((uint64_t) READ_0123(bblock->BOOT_extra.fat32.FAT_sz)) * DOSsecsize;
                }
             }
          discsize(dr) = (word) bbsize; /* Use bbsize incase FileCore was guessing discSize */
          heads(dr) = noSides;
          if (!floppy) secspertrk(dr) = READ_LOHI(bblock->BOOT_secstrack);
          return 0;
          }
       }
    }
    
 dprintf(("","DOSFS: testforbpb: FileCore and BOOT BLOCK disc sizes differ\n"));
 return 1;
}

static int testforpartition(ADFS_drecord *dr,char *sector,uint64_t *winioffset,
                            int *numFATs,uint64_t *FATsize,int *magic,int *ROOTsize,
                            bool *Atari,bool *dblstep,int *numRESVD,word *volumeid,
                            struct image_accessor *a)
{
 DOS_bootsector  *bblock = (DOS_bootsector *)sector;
 _kernel_oserror *rerror = NULL ; 
 byte  *pentry ;         /* partition description pointer */
 word   winisize = 0 ;   /* media size (sectors) */
 int    index;
 
 /* This may be a partition on a fixed disc though, so let's have a look */
 if (READ_LOHI(bblock->BOOT_extra.fat12.BOOT_signature) != DOS_PARTITION_signature)
    return 1;

 /* If there's a bootable partition,take that in preference to any other */
 for (index=0; index < 4; index++)
     {
     pentry = (byte *)&(bblock->BOOT_extra.fat12.partitions[index*sizeof(partition_entry)]);
     if (pentry[0] == bootable) break;
     }
 if (index == 4)
    {
    /* Try non bootable partitions whose start sector != 0 */
    for (index=0; index < 4; index++)
        {
        pentry = (byte *)&(bblock->BOOT_extra.fat12.partitions[index*sizeof(partition_entry)]);
        if (pentry[2] != 0) break;
        }
    }

 if (index == 4) return 1;

 /* Got a vaguely valid partition,go with it */
 *winioffset = ((uint64_t) loadWORD(pentry+8)) * DOSsecsize;
 winisize = loadWORD(pentry+12);
 dprintf(("","DOSFS: testforpartition: Found partition at winioffset = &%016" PRIX64 "\n",*winioffset));

 dprintf(("","DOSFS: testforpartition: reading sector from &%016" PRIX64 "\n",dr->dr_rootSIN + *winioffset));
 if ((rerror = image_readwrite(*winioffset,
                               sizeof(DOS_bootsector),
                               bblock,
                               ACC_READ+ACC_USE_CACHE,
                               a)) == NULL)
    {
    word fatsize, rootsize, bbsize = max_sector(bblock);

    rootsize = READ_LOHI(bblock->BOOT_root_dir) * sizeof(DOS_direntry);
    if (rootsize == 0)
       {
       /* Adjust to at least 1 cluster */
       rootsize = cluster_size(bblock); 
       }

    fatsize = READ_LOHI(bblock->BOOT_FAT_size); 
    if (fatsize == 0)
       {
       /* Try the FAT32 declaration instead */
       fatsize = READ_0123(bblock->BOOT_extra.fat32.FAT_sz);
       }

    if (bblock->BOOT_extra.fat12.sig_rec == 0x29)
       {
       /* There's an extended boot record,note the volume id */
       *volumeid = READ_0123(bblock->BOOT_extra.fat12.volid);
       }
    if (bblock->BOOT_extra.fat32.BootSig == 0x29)
       {
       /* There's an extended FAT32 boot record,note the volume id */
       *volumeid = READ_0123(bblock->BOOT_extra.fat32.VolID);
       }

    /* A few more sector sanity checks */
    dprintf(("","DOSFS: testforpartition: bbsize=%08X, winisize=%08X, fatsize=%08X sectors\n", bbsize, winisize, fatsize));
    if (bbsize == 0) return 1; /* Bad start */
    if (bbsize > winisize) return 1; /* Image is bigger than the partition table has set aside. */
    if (fatsize > bbsize) return 1; /* FAT is somehow bigger than the entire image. */
    if ((rootsize / DOSsecsize) > bbsize) return 1; /* Root directory takes more sectors than the entire image. */
    uint64_t discsz = *winioffset + ((uint64_t) bbsize)*DOSsecsize;
    if (discsz > UINT32_MAX)
    {
       dprintf(("","DOSFS: disc too big for 32bit discsize\n"));
       return 1; 
    }

    /* It's a DOS disc so claim it as one of ours and set up the disc record info. */
    *magic = bblock->BOOT_magic;
    *ROOTsize = rootsize;
    *FATsize = ((uint64_t) fatsize) * DOSsecsize;
    *numFATs = bblock->BOOT_num_fats;
    *Atari = false; /* Never Atari */
    *numRESVD = READ_LOHI(bblock->BOOT_reserved) ;
    *dblstep = false; /* Never double step */
    discsize(dr) = discsz; /* Update discsize, in case FileCore was guessing the size */
    heads(dr) = 0; /* It's a harddisc */
    secspertrk(dr) = READ_LOHI(bblock->BOOT_secstrack);    
     
    dprintf(("","DOSFS: testforpartition magic=%02X root=%x fat=%" PRIx64 " (x%d copies) resvd=%d\n",(int)*magic,(int)*ROOTsize,*FATsize,(int)*numFATs,(int)*numRESVD));
    return 0;
    }
    
 return 1;
}

static int testfor160360k(ADFS_drecord *dr,char *sector,bool floppy,
                          int *numFATs,uint64_t *FATsize,int *magic,int *ROOTsize,
                          bool *Atari,bool *dblstep,int *numRESVD)
{
 /* If we have not claimed the disc then it could still be valid only if it is a 320K or
  * 160K format, both of which have 8 sectors per track (these old formats need not have a
  * valid boot block)
  */
 if (secspertrk(dr) != 8)
    {
    dprintf(("","DOSFS: testfor160360k: not 320K or 160K format 8 sectors per track\n"));
    return 1;
    }
 /* Defaults for 320K and 160K formats */
 *magic = 0;
 /* ROOTsize could be 112 or 64 entries,we'll find out later by inspecting the FAT */
 *FATsize = DOSsecsize;
 *numFATs = 2;
 *Atari = false;
 *numRESVD = 1;
 *dblstep = true;
 /* discsize(dr) = guessed from FAT entry later */
 /* heads(dr) = guessed from FAT entry later */
 /* secspertrk() = no BPB so don't know,but it must be a floppy so don't care either */

 UNUSED(floppy);
 UNUSED(sector);
 UNUSED(ROOTsize);
 return 0;
}

static void validatedosformat(ADFS_drecord *dr,_kernel_swi_regs *rset)
{
 /* In response to Service_IdentifyDisc this will have a few goes at working */
 /* out if this will pass as a DOS disc image. Note that exactly which test  */
 /* is performed depends on whether it's a harddisc or a floppy disc         */

 _kernel_oserror *rerror = NULL ; 
 char *sector,*sectorblock;
 byte *name;
 DOS_bootsector  *bblock;
 bool  dblstep;
 int   numFATs;
 uint64_t FATsize; /* bytes */
 int   numRESVD, ROOTsize;
 int   magic = 0;
 bool  Atari = false;
 int   discID = 0;
 char *buf = 0;
 int   bufsz = 0;
 uint64_t winioffset = 0; /* bytes */
 word  volumeid = 0;
 bool  floppy = !((log2secsize(dr) == 0) || (dr->dr_floppy_density == 0) || (secspertrk(dr) == 0) || (heads(dr) == 0));
 int   loop, step;

 dprintf(("","DOSFS: validatedosformat: treating as a %s disc\n",floppy ? "floppy" : "fixed"));
 /* If it is a floppy then insist on a few floppyesque parameters */
 if (floppy && ((log2secsize(dr) != log2DOSsecsize) || (tracklow(dr) != 1) || (trackskew(dr) != 0)))
    {
    dprintf(("","DOSFS: validatedosformat: floppy fails even basic DOS parameters\n"));
    return;
    }
    
 /* Get some memory to load a sector */
 sector = (char *)malloc(DOSsecsize) ;
 if (sector == NULL)
    {
    dprintf(("","DOSFS: validatedosformat: failed to get memory\n"));
    return;
    }
 bblock = (DOS_bootsector *)sector;

 /* Sector 1, track 0 should always be readable regardless of the specific DOS format */
 image_accessor_disc a = new_image_accessor_disc(dr,rset->r[6],rset->r[8]);

 dprintf(("","DOSFS: validatedosformat: reading sector from &%08X\n",dr->dr_rootSIN));
 /* Try a read of the disc */
 if ((rerror = image_readwrite(0,sizeof(DOS_bootsector),bblock,ACC_READ+ACC_USE_CACHE,&a.a)) != NULL)
    {
    free(sector);
    dprintf(("","DOSFS: validatedosformat: failed to read 0th sector\n"));
    return;
    }

 dprintf(("","DOSFS: validatedosformat: sector read OK\n"));
 /* See if the sector read contains a BPB */
 if (testforbpb(dr,sector,floppy,&numFATs,&FATsize,&magic,&ROOTsize,
                &Atari,&dblstep,&numRESVD,&volumeid))
    {
    /* Crusty 160 & 360k floppies don't need one */
    if (!floppy || testfor160360k(dr,sector,floppy,&numFATs,&FATsize,&magic,&ROOTsize,
                                  &Atari,&dblstep,&numRESVD))
       {
       /* Last ditch attempt scanning for partitions on harddiscs */
       if (floppy || testforpartition(dr,sector,&winioffset,&numFATs,&FATsize,&magic,&ROOTsize,
                                      &Atari,&dblstep,&numRESVD,&volumeid,&a.a))
          {
          free(sector);
          dprintf(("","DOSFS: validatedosformat: shame,not a DOS disc\n"));
          return;
          }
       }
    }

 /* Update the disc record with what we know now */
 put_doublestep(dr, dblstep);
 put_sequence(dr, 0);

 /* Read the FAT.  This will be used to identify a 320K or 160K format if necessary and
  * also to calculate a disc ID to pass back to FileCore.
  */
 dprintf(("","DOSFS: validatedosformat: reading FAT\n"));
 sectorblock = ((FATsize < (1<<30)) ? realloc(sector,(size_t) FATsize) : NULL);
 if (sectorblock == NULL)
    {
    step = DOSsecsize; /* Low on memory,so FAT is read one sector at a time */
    }
 else
    {
    sector = sectorblock;
    step = (int) FATsize;    /* Enough memory to load the whole FAT at once */
    }

 for (uint64_t index = 0; index < FATsize; index += step)
     {
     if ((rerror = image_readwrite(index + ((uint64_t) numRESVD) * DOSsecsize + winioffset,
                                   step,
                                   sector,
                                   ACC_READ + (floppy ? ACC_USE_CACHE : 0),
                                   &a.a)) == NULL)
        {
        /* Check the first byte of the FAT for the 320K or 160K media type. */
        if ((*sector == 0xFE) && (magic==0) && (index==0))
           {
           magic = 0xFE;
           ROOTsize = 64 * sizeof(DOS_direntry);
           discsize(dr) = 0x28000;
           heads(dr) = 1;
           }
        if ((*sector == 0xFF) && (magic==0) && (index==0))
           {
           magic = 0xFF;
           ROOTsize = 112 * sizeof(DOS_direntry);
           discsize(dr) = 0x50000;
           heads(dr) = 2;
           }
        }
     /* We're certain it's a DOS disc so calculate a disc ID from the FAT contents */
     for (loop = 0; loop < step; loop++)
         discID += sector[loop] ;
     }

 /* In all circumstances we'd have deduced the magic number by now */
 if (magic == 0)
    {
    free(sector);
    dprintf(("","DOSFS: validatedosformat: don't know the magic number by any method\n"));
    return;
    }
    
 /* Claim the service and fill in the disc record.    */
 /* Get the default disc name from the Messages file. */
 dprintf(("","DOSFS: validatedosformat: accepted disc type &%02X\n",magic));
 dprintf(("","DOSFS: validatedosformat: cycleID was 0x%x\n", discID));
 dprintf(("","DOSFS: validatedosformat: discsize was 0x%x\n", discsize(dr)));

 /* Lookup default disc name. */
 if ((rerror = msgtrans_lookup("DEFDNM", &buf, &bufsz, 0, 0, 0, 0)) != NULL)
    {
    buf = rerror->errmess;
    bufsz = strlen(buf);
    }
 if (bufsz > 9) bufsz = 9;
 strncpy((char *)(dr->dr_discname), buf, bufsz);
 dr->dr_discname[bufsz] = '\0';

 /* A volume id is better than the default */
 if (volumeid != 0) sprintf((char*)(dr->dr_discname),"%04X-%04X",(volumeid >> 16) & 0xFFFF,volumeid & 0xFFFF);
 
 /* Try to find a volume label on the disc. */
 for (loop = 0; loop < ROOTsize; loop+= DOSsecsize)
     {
     if ((rerror = image_readwrite((numFATs * FATsize) + loop + ((uint64_t) numRESVD) * DOSsecsize + winioffset,
                                   DOSsecsize,
                                   sector,
                                   ACC_READ + (floppy ? ACC_USE_CACHE : 0),
                                   &a.a)) == NULL)
        {
        DOS_direntry *dentry;
        
        int index = 0;
        if ((dentry = findDIRtype((byte)FILE_win95,(byte)FILE_volume,(DOS_direntry *)sector,DOSsecsize,&index)) != NULL)
           {
           char label[discnamesize];

           dprintf(("","DOSFS: validatedosformat: volume label found\n") );
           index = 0;

           /* Copy to our name limit, replacing invalid characters along the way */
           for (name = &dentry->FILE_status; isalnum(*name) && (index < (discnamesize-1)); name++)
           {
             label[index] = mapchar(*name,DOSmapping,ROmapping);
             index++;
           }
           label[index] = '\0'; /* Terminate */
           if (strlen(label) < 2)
           {
             dprintf(("","DOSFS: validatedosformat: volume \"%s\" too short, ignored\n",label));
           }
           else
           {
             strcpy((char *)dr->dr_discname, label);
           }
           break; /* End search */
           }
        }
     }
 dprintf(("","DOSFS: validatedosformat: volume \"%s\" (id=%08x)\n",(char *)dr->dr_discname,volumeid));

#ifndef PRE218
 /* Write format name into buffer. */
 if (rset->r[2] != 0)
    {
    char token[8];
    for (loop = 0; DOS_formats[loop].magic_ID != 0; loop++)
        {
        if (magic == DOS_formats[loop].magic_ID)
           {
           /* If type is &F9 then we need more tests. */
           if (magic == 0xF9)
              {
              if (Atari && strcmp(DOS_formats[loop].idtext, "Atari/M"))
                 continue;
              if (FATsize != ((uint64_t) DOS_formats[loop].secsFAT) * DOSsecsize)
                 continue;
              }
           break;
           }
        }
    sprintf(token, FORMAT_FMT, loop + 1);
    buf = (char *)rset->r[2];
    bufsz = rset->r[3];
    if ((rerror = msgtrans_lookup(token, &buf, &bufsz, 0, 0, 0, 0)) != NULL)
       {
       bufsz = strlen(rerror->errmess);
       strncpy(buf, rerror->errmess, bufsz);
       }
    buf[bufsz] = '\0';
    dprintf(("","DOSFS: validatedosformat: format name = \"%s\"\n", buf));
    }
#endif

 /* Claim the service and fill in the disc record. */
 rset->r[1] = Service_Serviced;
 put_discID(dr, discID);     /* Still pointed to by R5 */
 rset->r[2] = FileType_MSDOSDisc ;    /* filetype to be associated with the disc image */
 rset->r[6] = a.sector_cache_handle ;   /* sector cache handle returned from "FileCore_DiscOp{64}" */
 return;
}

/*-------------------------------------------------------------------------*/
/* NOTE: This code currently only deals with floppy structures             */

static _kernel_oserror *FSSWI_LayoutStructure(_kernel_swi_regs *rset,void *privateword)
{
 /* in:  r0 = disc structure identifier (r5 from "Service_IdentifyFormat")
  *      r1 = pointer to -1 terminated list of bad blocks
  *      r2 = pointer to NULL terminated disc name
  *      r3 = file handle of system image
  * out:
  */
 _kernel_swi_regs  reglist ;
 _kernel_oserror  *rerror = NULL ;
  char *sector = NULL;

 dprintf(("", "DOSFS: FSSWI_LayoutStructure: r0 = &%08X, r1 = &%08X, r2 = &%08X, r3 = &%08X\n",rset->r[0],rset->r[1],rset->r[2],rset->r[3]));

 /* Bounds check */
 if (rset->r[0] > 8) {
     rerror = global_error(err_badformat);
     return(rerror);    /* Quit! */
 }

 /* Place default BOOT BLOCK (shape defined by r0 on entry) */
 if ((sector = (char *)malloc(DOSsecsize)) != NULL)
  {
   DOS_bootsector *dbsector = (DOS_bootsector *)sector; /* BOOT BLOCK for image */
   int findex = DOS_formats[rset->r[0]].findex ;
   int maxsect = (DOS_formatinfo[findex].secstrk * DOS_formatinfo[findex].tracks) ;

   dprintf(("","Findex = %d\n", findex));

   *dbsector = *(default_dbsector) ; /* copy the structure across */
   /* write format specific information (dictated by entry r0 parameter) */
   dbsector->BOOT_secalloc = DOS_formats[rset->r[0]].secsclus;
   dbsector->BOOT_root_dir = DOS_formats[rset->r[0]].rootsize;
   /* dbsector->BOOT_root_dirHI = 0x00; */
   dbsector->BOOT_max_sect = ((maxsect >> 0) & 0xFF) ;
   dbsector->BOOT_max_sectHI = ((maxsect >> 8) & 0xFF) ;
   dbsector->BOOT_magic = DOS_formats[rset->r[0]].magic_ID ;
   dbsector->BOOT_secstrack = ((DOS_formatinfo[findex].secstrk >> 0) & 0xFF) ;
   dbsector->BOOT_secstrackHI = ((DOS_formatinfo[findex].secstrk >> 8) & 0xFF) ;
   dbsector->BOOT_FAT_size = DOS_formats[rset->r[0]].secsFAT;
   /* dbsector->BOOT_FAT_sizeHI = 0x00; */
   switch (DOS_formatinfo[findex].options & sideinfomask) {
    case o_alternate:
    case o_sequence:
     dbsector->BOOT_heads = 2;
     break;
    default:
     dbsector->BOOT_heads = 1;
   }

   /* Special code for Atari formats */
   if ((strcmp(DOS_formats[rset->r[0]].idtext,"Atari/M") == 0) || (strcmp(DOS_formats[rset->r[0]].idtext,"Atari/N") == 0))
    {
     /* Atari formats have no jmp instruction in the boot block,and a 24bit volume serial number in the OEM id */
     dbsector->BOOT_JMP[0] =  dbsector->BOOT_JMP[1] = dbsector->BOOT_JMP[2] = 0;
     dbsector->BOOT_OEM[5] = (rand() & 0xFF) ;
     dbsector->BOOT_OEM[6] = (rand() & 0xFF) ;
     dbsector->BOOT_OEM[7] = (rand() & 0xFF) ;
    }

   /* write the BOOT BLOCK into the image */
   reglist.r[0] = OSGBPB_WriteAtGiven ;    /* write operation */
   reglist.r[1] = rset->r[3] ;             /* FileSwitch handle */
   reglist.r[2] = (word)dbsector ;         /* data address */
   reglist.r[3] = DOSsecsize ;             /* amount of data */
   reglist.r[4] = 0x00000000 ;             /* destination image offset */
   reglist.r[5] = NULL ;
   reglist.r[6] = NULL ;
   if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) == NULL)
    {
     int   FATsize = (dbsector->BOOT_FAT_size|(dbsector->BOOT_FAT_sizeHI<<8));
     int   numFATs = dbsector->BOOT_num_fats;
     word  ROOTsize = ((dbsector->BOOT_root_dir | (dbsector->BOOT_root_dirHI << 8)) * sizeof(DOS_direntry)) / DOSsecsize;
     word offset = ((DOS_FAT_sector - 1) * DOSsecsize) ;
     int  loop ; /* general index counter */

     for (loop = 0; loop < DOSsecsize; loop++)
      sector[loop] = '\0' ; /* zero sector buffer */
     /* Can no longer take data from dbsector. */

     /* Create FATs */
     while (numFATs--) {
      sector[0] = DOS_formats[rset->r[0]].magic_ID ;
      sector[1] = 0xFF ;
      sector[2] = 0xFF ;
      for (loop = 0; loop < FATsize; loop++) {
       reglist.r[0] = OSGBPB_WriteAtGiven ;    /* write operation */
       reglist.r[1] = rset->r[3] ;             /* FileSwitch handle */
       reglist.r[2] = (word)sector ;           /* data address */
       reglist.r[3] = DOSsecsize ;             /* amount of data */
       reglist.r[4] = offset ;                 /* destination image offset */
       reglist.r[5] = NULL ;
       reglist.r[6] = NULL ;
       if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) != NULL)
        break ; /* out of the FAT writing loop */
       offset += DOSsecsize ;
       if (loop)
        continue;
       sector[0] = sector[1] = sector[2] = 0;
      }
     }

     if (rerror == NULL) {
      DOS_direntry *dentry = (DOS_direntry *)sector ;
      time5byte     formTIME ;

      get_RISCOS_TIME(&formTIME) ;

      /* place the default disc name into the first slot */
      put_FILE_time(dentry->FILE_time,dentry->FILE_timeHI,RISCOStoTIME(&formTIME)) ;
      put_FILE_date(dentry->FILE_date,dentry->FILE_dateHI,RISCOStoDATE(&formTIME)) ;

      /* Copy title into block,pad with spaces (not nulls),and mark as a volume title */

      memset((char *)&(dentry->FILE_status),32,namsize+extsize);
      memcpy((char *)&(dentry->FILE_status),(char *)rset->r[2],strlen((char *)rset->r[2]));
      dentry->FILE_attribute = (FILE_volume | FILE_archive) ;

      /* Write the root directory. */
      for (loop = 0; loop < ROOTsize; loop++) {
       int i;
       reglist.r[0] = OSGBPB_WriteAtGiven ; /* write operation */
       reglist.r[1] = rset->r[3] ;          /* FileSwitch handle */
       reglist.r[2] = (word)sector ;        /* data address */
       reglist.r[3] = DOSsecsize ;          /* amount of data */
       reglist.r[4] = offset ;              /* destination image offset */
       reglist.r[5] = NULL ;
       reglist.r[6] = NULL ;
       if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) != NULL)
        break;
       offset += DOSsecsize;
       if (loop)
        continue;
       for (i = 0; i < sizeof(DOS_direntry); i++)
        sector[i] = 0;
      }
     }
    }
   free(sector) ;
  }
 else
  rerror = global_errorT(err_heapexhausted, tok_heapexhausted, 0, 0) ;

 return(rerror) ;
 UNUSED(privateword) ;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Vector through to the relevant SWI handler */
_kernel_oserror *fs_swi(int swi_no,_kernel_swi_regs *rset,void *privateword)
{
 switch(swi_no + DOSFS_00)
  {
   case DOSFS_DiscFormat :
             return(FSSWI_DiscFormat(rset,privateword)) ;
             break ;

   case DOSFS_LayoutStructure :
             return(FSSWI_LayoutStructure(rset,privateword)) ;
             break ;

   default : /* unknown */
             dprintf(("","DOSFS: return unknown SWI (%d) error\n",swi_no) );
             return global_errorT(err_badswi, tok_badswi, "DOSFS", 0);
             break ;
  }

 return(NULL) ;
}

/*-------------------------------------------------------------------------*/
/* Provide handlers for the services we intercept */

void fs_service(int service_number,_kernel_swi_regs *rset,void *privateword)
{
 /* Note: We should NOT perform any IO from these functions */
 switch (service_number)
  {
   case 0x11 : /* Service_Memory */
               /* if (rset->r[2] == module base addr) then claim this call */
               if (rset->r[2] == Image_RO_Base)
                {
                 dprintf(("","DOSFS: Service_Memory (0x11): matched\n")) ;
                 rset->r[1] = Service_Serviced ; /* claim this service */
                }
               break ;

   case 0x12 : /* Service_StartUpFS */
               select_FS() ;
               break ;

   case 0x27 : /* Service_Reset */
               dprintf(("","DOSFS: Service_Reset: called\n")) ;
               break ;

   case 0x40 : /* Service_FSRedeclare */
               declare_FS(privateword) ;
               break ;

   case 0x5C : /* Service_WimpSaveDesktop */
               dprintf(("","DOSFS: Service_WimpSaveDesktop: called\n")) ;
               dprintf(("","DOSFS: WimpSaveDesktop: r0 = &%08X\n",rset->r[0])) ;
               dprintf(("","DOSFS: WimpSaveDesktop: r1 = &%08X\n",rset->r[1])) ;
               dprintf(("","DOSFS: WimpSaveDesktop: r2 = &%08X\n",rset->r[2])) ;
               /* r0 = 0x00 */
               /* r1 = 0x5C - Service_WimpSaveDesktop */
               /* r2 = FileSwitch file handle */
               {
                _kernel_oserror  *rerror = NULL ;
                _kernel_swi_regs  reglist ;
                mapentry         *cptr = maplist ;
                char             *tbuff ;

                tbuff = (char *)malloc(strlen("DOSMap DOS FFF\n") + 1) ;
                /* we do not do anything if we failed to alloc memory */
                if (tbuff != NULL)
                 {
                  for (; (cptr != NULL); cptr = cptr->next)
                   {
                    int loop ;
                    sprintf(tbuff,"DOSMap ") ;
                    for (loop = 0; (loop < 7); loop++)
                     {
                      char cchr = (*(char*)(cptr->dosext + (loop ))) ;
                      cchr = (((cchr > ' ') && (cchr != 0x7F)) ? cchr : ' ') ;
                      sprintf(&tbuff[strlen(tbuff)],"%c",cchr) ;
                     }
                    sprintf(&tbuff[strlen(tbuff)]," %03X\n",cptr->ROtype) ;
                    reglist.r[0] = OSGBPB_WriteAtPTR ; /* write operation */
                    reglist.r[1] = rset->r[2] ; /* FileSwitch handle */
                    reglist.r[2] = (word)tbuff ; /* data address */
                    reglist.r[3] = strlen(tbuff) ; /* amount of data */
                    reglist.r[4] = NULL ; /* destination image offset */
                    reglist.r[5] = NULL ;
                    reglist.r[6] = NULL ;
                    if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) != NULL)
                     {
                      rset->r[0] = (word)rerror ; /* pointer to error block */
                      rset->r[1] = Service_Serviced ;
                      break ; /* out of for loop */
                     }
                   }
                  free(tbuff) ;
                 }
               }
               break ;
#ifndef ROM
   case 0x60 : /* Service_ResourceFSStarting */
               (*(void (*)(void *, void *, void *, void *))rset->r[2])(dosfs_msgarea(), 0, 0, (void *)rset->r[3]);
               break;
#endif
   case 0x69 : /* Service_IdentifyDisc */
               /* in:   r1 = Service_IdentifyDisc */
               /*       r2 = Pointer to buffer for format name */
               /*       r3 = Length of format name buffer */
               /*       r5 = pointer to disc record */
               /*       r6 = sector cache handle */
               /*       r8 = pointer to filecore instance private word */
               /* out:  r1 = Service_Serviced (NULL) */
               /*       r2 = filetype number for given disc format */
               /*       r5 = pointer to disc record (possibly updated) */
               /*       r6 = new sector cache handle */
               /*       r8 = preserved */
               dprintf(("", "DOSFS: Service_IdentifyDisc: r5 = &%08X, r6 = &%08X, r8 = &%08X\n",
                            rset->r[5],rset->r[6],rset->r[8]));
               {
                ADFS_drecord *dr = (ADFS_drecord *)rset->r[5] ;

                dprintf(("","DOSFS: Service_IdentifyDisc: log2secsize(dr) = %d\n",log2secsize(dr))) ;
                dprintf(("","DOSFS: Service_IdentifyDisc: secspertrk(dr) = %d\n",secspertrk(dr))) ;
                dprintf(("","DOSFS: Service_IdentifyDisc: heads(dr) = %d\n",heads(dr)));
                dprintf(("","DOSFS: Service_IdentifyDisc: dr->dr_floppy_density = %d\n",dr->dr_floppy_density)) ;
                dprintf(("","DOSFS: Service_IdentifyDisc: discsize(dr) = &%X\n",discsize(dr)));
                dprintf(("","DOSFS: Service_IdentifyDisc: doublestep(dr) = %d\n",doublestep(dr)));
                dprintf(("","DOSFS: Service_IdentifyDisc: sequence(dr) = %d\n",sequence(dr)));
                dprintf(("","DOSFS: Service_IdentifyDisc: tracklow(dr) = %d\n",tracklow(dr)) );
                dprintf(("","DOSFS: Service_IdentifyDisc: trackskew(dr) = %d\n",trackskew(dr)) );
                dprintf(("","DOSFS: Service_IdentifyDisc: disctype(dr) = &%03X\n",disctype(dr)) );
                dprintf(("","DOSFS: Service_IdentifyDisc: bigflag = &%X\n",dr->dr_bigflag) );

                validatedosformat(dr, rset);
                dprintf(("","DOSFS: Service_IdentifyDisc: exit with r1 = &%X\n",rset->r[1]));
               }
               break ;

   case 0x6A : /* Service_EnumerateFormats */
               /* in:   r0 = 0 */
               /*       r1 = Service_EnumerateFormats */
               /* out:  r0 = pointer to linked list of format specifications (as RMA blocks) */
               /*       r1 = preserved */
               {
                format_info **next ;
                int          loop ;

                dprintf(("","DOSFS: Service_EnumerateFormats: called\n") );

                /* set next to point to the next place to store a format_info pointer */
                next = (format_info **)&(rset->r[2]);
                while (*next != NULL)
                 next = &((*next)->link);

                /* see "format_info" structure in "MultiFS.h" */
                for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                 if (DOS_formats[loop].idtext != NULL && DOS_formats[loop].in_menu) /* we support this format */
                  {
                   format_info *finfo = (format_info *)_kernel_RMAalloc(sizeof(format_info)) ;
                   char        *menu_text = 0;
                   char        *help_text = 0;
                   int         menusz;
                   int         helpsz;
                   _kernel_oserror *err;
                   char        token[8];

                   if (finfo == NULL)
                     continue;

                   /* get the text from the Messages file - to be safe do the copying here in case */
                   /* message trans uses the same buffer for both calls */
                   sprintf(token, FORMAT_FMT, loop + 1);
                   if ((err = msgtrans_lookup(token, &menu_text, &menusz, 0, 0, 0, 0)) != NULL) {
                     menu_text = err->errmess;
                     menusz = strlen(menu_text);
                   }
                   finfo->menu_text = _kernel_RMAalloc(menusz + 1) ;
                   if (finfo->menu_text != NULL) {
                     strncpy(finfo->menu_text, menu_text, menusz);
                     ((char *)(finfo->menu_text))[menusz] = '\0';
                     sprintf(token, HELP_FMT, loop + 1);
                     if ((err = msgtrans_lookup(token, &help_text, &helpsz, 0, 0, 0, 0)) != NULL) {
                       help_text = err->errmess;
                       helpsz = strlen(help_text);
                     }
                     finfo->help_text = _kernel_RMAalloc(helpsz + 1) ;
                     if (finfo->help_text != NULL) {
                       strncpy(finfo->help_text, help_text, helpsz);
                       ((char *)(finfo->help_text))[helpsz] = '\0';
                       finfo->link = NULL ; /* no next block at the moment */
                       finfo->format_SWI = DOSFS_DiscFormat ;
                       finfo->format_r0 = loop ;
                       finfo->layout_SWI = DOSFS_LayoutStructure ;
                       finfo->layout_r0 = loop ;
                       finfo->flags = EnumFormats_HasFormatParam;
                       finfo->format_desc = DOS_formats[loop].idtext;

                       /* add this description onto the end of the list */
                       *next = finfo;
                       next = &(finfo->link);
                     } else {
                       free(finfo->menu_text);
                       free(finfo);
                     }
                   } else {
                    free(finfo);
                   }
                  }
               }
               break ;

   case 0x6B : /* Service_IdentifyFormat */
               /* in:   r0 = ptr to NULL terminated ASCII format identifier
                *       r1 = Service_IdentifyFormat
                * out:  r0 = preserved
                *       r1 = Service_Serviced (NULL)
                *       r2 = SWI number to call to obtain "DOSFS_DiscFormat"
                *       r3 = r3 parameter to be used for "DOSFS_DiscFormat" SWI
                *       r4 = SWI number to call to obtain "DOSFS_LayoutStructure"
                *       r5 = r0 parameter to be used for "DOSFS_LayoutStructure" SWI
                */
               {
                int loop ;

                dprintf(("","DOSFS: Service_IdentifyFormat: r0 = \"%s\"\n",(char *)(rset->r[0]))) ;

                /* I use my wild-card compare function since it automatically deals with
                 * case equality, where "strcmp" does not.
                 */
                for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                 if (DOS_formats[loop].idtext != NULL)
                  if (wild_card_compare((char *)rset->r[0],DOS_formats[loop].idtext,ROwcmult,ROwcsing))
                   break ;

                if (DOS_formats[loop].magic_ID != 0x00)
                 {
                  dprintf(("","DOSFS: Service_IdentifyFormat: %s\n",DOS_formats[loop].idtext)) ;

                  rset->r[1] = Service_Serviced ;
                  rset->r[2] = DOSFS_DiscFormat ;       /* our format SWI */
                  rset->r[3] = loop ;                   /* "DOS_formats" table index */
                  rset->r[4] = DOSFS_LayoutStructure ;  /* our layout SWI */
                  rset->r[5] = loop ;                   /* "DOS_formats" table index */
                 }
               }
               break ;

   case 0x6C : /* Service_DisplayFormatHelp */
               /* in:   r0 = &00
                *       r1 = Service_HelpFormat
                * out:  NO ERROR : preserved
                *       ERROR    : r0 = pointer to error block
                *                  r1 = Service_Serviced
                *
                * This should list the formats it will respond to in
                * "Service_IdentifyFormat". The listing should be performed
                * using "OS_WriteC", "OS_Write0" or "OS_WriteS".
                */
               dprintf(("","DOSFS: Service_FormatHelp: called\n") );
               {
                int            loop ;
                for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                 if (DOS_formats[loop].idtext != NULL)
                  {
                   _kernel_swi_regs  urset ;
                   _kernel_oserror  *rerror ;
                   char        *buf = 0;
                   int         bufsz = 0;
                   char        token[8];

                   /* get the text from the Messages file */
                   sprintf(token, HELP_FMT, loop + 1);
                   if ((rerror = msgtrans_lookup(token, &buf, &bufsz, 0, 0, 0, 0)) != NULL) 
                    {
                     buf = rerror->errmess;
                     bufsz = strlen(rerror->errmess);
                    }
                   urset.r[0] = (word)buf;
                   urset.r[1] = bufsz;
                   rerror = _kernel_swi(OS_WriteN, &urset, &urset);

                   if (rerror == NULL)
                    rerror = _kernel_swi(OS_NewLine,&urset,&urset) ;

                   if (rerror != NULL)
                    {
                     rset->r[0] = (word)rerror ; /* pointer to standard error block */
                     rset->r[1] = Service_Serviced ;
                     return ;
                    }
                  }
               }
               break ;

   default   : /* unknown - do nothing */
               break ;
  }

 return ;
}

/*-------------------------------------------------------------------------*/

_kernel_oserror *fs_commands(const char *argv,int argc,int command,void *privateword)
{
 _kernel_swi_regs  rset ;
 _kernel_oserror  *rerror = NULL ;

 switch (command)
  {
   case CMD_DOSMap :
             {
              int         loop ;
              char        dosext[8] = {0,0,0,0,0,0,0,0} ; /* DOS extension */
              word        ROtype = 0x000 ;      /* RISC OS filetype */
              mapentry   *cptr ;
              const char *tptr ;
              char *buf = NULL;
              int bufsz = 0;

              dprintf(("","fs_command: DOSMap\n") );
              /* arg0 (optional) : DOS extension */
              /* arg1 (optional) : RISC OS filetype */
              /* If "arg0" is NOT present then we display the current mappings.
               * If "arg1" is NOT present the mapping for the given DOS
               * extension will be removed.
               */

              if (argc == 0) /* display current mappings if no parameters */
               {
                if ((cptr = maplist) == NULL)
                {
                 if ( (rerror = msgtrans_lookup("NOMAP", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                 {
                  buf = rerror->errmess;
                  bufsz = strlen( buf );
                 }
                 fwrite( buf, 1, bufsz, stdout );
                 putchar( '\n' );
                }
                else
                 {
                  int exttab, texttab, typetab, linelen;
                  buf = NULL;
                  if ( (rerror = msgtrans_lookup("DOSExt", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                  {
                   buf = rerror->errmess;
                   bufsz = strlen( buf );
                  }
                  fwrite( buf, 1, bufsz, stdout );
                  exttab = (bufsz-3)/2;
                  texttab = bufsz-exttab-1;
                  buf = NULL;
                  if ( (rerror = msgtrans_lookup("ROType", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                  {
                   buf = rerror->errmess;
                   bufsz = strlen( buf );
                  }
                  printf( "  " );
                  fwrite( buf, 1, bufsz, stdout );
                  putchar( '\n' );
                  if ( bufsz < 12 ) bufsz = 12;
                  typetab = bufsz-11;
                  linelen = exttab+3+texttab+bufsz;
                  for ( loop=linelen; loop--; ) putchar( '-' );
                  putchar('\n');

                  for (; (cptr != NULL); cptr = cptr->next)
                   {
                    for ( loop=exttab; loop--; ) putchar( ' ' );

                    for (loop = 0; (loop < 7); loop++)
                     {
                      char cchr = (*(char*)(cptr->dosext + (loop))) ;
                      putchar( (((cchr > ' ') && (cchr != 0x7F)) ? cchr : ' ') );
                     }

                    for ( loop=texttab; loop--; ) putchar( ' ' );

                    rset.r[0] = FSControl_ReadFileType ;
                    rset.r[2] = (word)cptr->ROtype ;
                    if ((rerror = _kernel_swi(OS_FSControl,&rset,&rset)) != NULL)
                     {
                      /* Just print spaces if unknown (or error returned) */
                      rset.r[2] = 0x20202020 ;
                      rset.r[3] = 0x20202020 ;
                     }

                    for (loop = 0; (loop < 4); loop++)
                     printf("%c",(char)((rset.r[2] >> (loop * 8)) & 0xFF)) ;
                    for (loop = 0; (loop < 4); loop++)
                     printf("%c",(char)((rset.r[3] >> (loop * 8)) & 0xFF)) ;

                    for ( loop=typetab; loop--; ) putchar( ' ' );
                    printf("%03X\n",cptr->ROtype) ;
                   }
                  for ( loop=linelen; loop--; ) putchar( '-' );
                  putchar( '\n' );
                 }
               }
              else
               {
                /* convert the DOS extension given to upper-case */
                for (loop=0; (argv[loop] && (argv[loop] != ' ')); loop++)
                 {
                  int c = toupper(argv[loop]);
                  if (validchar(valchars,c))
                   dosext[loop] = c  ;
                  else
                   {
                    rerror = global_error(err_invalidchar) ;
                    break ; /* from the "for" loop */
                   }
                 }

                if (!rerror) /* no error defined yet */
                 {
                  if (loop > 3)
                   rerror = global_error(err_toolong) ;
                  else
                   {
                    if (argc == 1)
                     {
                      mapentry *last = maplist ;
                      /* release this mapping */
                      for (cptr = last; (cptr != NULL); cptr = last->next)
                       if (strcmp(dosext, cptr->dosext)==0)
                        {
                         dprintf(("","DOSMap: entry found\n")) ;
                         /* release this mapping */
                         if (cptr == maplist)
                          maplist = cptr->next ;   /* new root mapping */
                         else
                          last->next = cptr->next ;/* step over this mapping */
                         free(cptr) ;              /* release this mapping */
                         break ;                   /* and exit the for loop */
                        }
                       else
                        last = cptr ;              /* remember this entry */
                     }
                    else
                     {
                      for (; (argv[loop] && (argv[loop] == ' ')); loop++) ;
                      /* convert the RISC OS filetype given to a 12bit number */
                      tptr = &argv[loop] ;
                      for (loop = 0; (tptr[loop]); loop++)
                       if (validchar("0123456789ABCDEFabcdef",tptr[loop]))
                        {
                         int cval ;
                         if (tptr[loop] > '9')
                          cval = (toupper(tptr[loop]) - ('A' - 10)) ;
                         else
                          cval = tptr[loop] ;
                         cval = cval - '0' ;
                         ROtype = (ROtype | (cval << (loop * 8))) ;
                        }
                       else
                        {
                         loop = 0 ;
                         break ;
                        }

                      if (loop == 0)
                       {
                        rset.r[0] = FSControl_FileTypeFromString ;
                        rset.r[1] = (word)tptr ;
                        if ((rerror = _kernel_swi(OS_FSControl,&rset,&rset)) == NULL)
                         ROtype = rset.r[2] ;
                       }
                      if (rerror == NULL)
                       {
                        /* check if the DOS extension exists */
                        for (cptr = maplist; (cptr != NULL); cptr = cptr->next)
                         if (strcmp(dosext, cptr->dosext)==0)
                          {
                           dprintf(("","DOSMap: resetting %s to &%03X\n",dosext,ROtype));
                           cptr->ROtype = ROtype ;   /* replace mapping */
                           break ;                   /* and exit the for loop */
                          }

                        if (cptr == NULL)
                         {
                          mapentry *newmapping ;
                          if ((newmapping = (mapentry *)calloc(sizeof(mapentry),1)) == NULL)
                           rerror = global_errorT(err_heapexhausted, tok_heapexhausted, 0, 0) ;
                          else
                           {
                            /* insert the mapping into the list */
                            dprintf(("","DOSMap: newmapping %s to &%03X\n",dosext,ROtype) );
                            newmapping->next = maplist ;
                            strcpy(newmapping->dosext, dosext) ;
                            newmapping->ROtype = ROtype ;
                            maplist = newmapping ;
                           }
                         }
                       }
                     }
                   }
                 }
               }
             }
             break ;

   case CMD_CopyBoot :
             {
              int             loop ;
              char           *cptr ; /* used during arg processing */
              int             srcdrive = -1 ;
              int             destdrive = -1 ;
              DOS_bootsector *srcblock = NULL ;
              DOS_bootsector *destblock = NULL ;
              int             nfloppies = 0 ;
              char            tmpcmd[256] ;     /* simple hack-around original code which modified command line */

              dprintf(("","fs_command: CopyBoot\n")) ;

              rerror = _kernel_swi(ADFS_Drives,&rset,&rset) ;
              if (rerror == NULL)
               {
                nfloppies = rset.r[1] ;

                /* arg0 : source drive */
                /* arg1 : destination drive */

                /* step upto first */
                for (; (*argv && (*argv == ' ')); argv++) ;
                strncpy(tmpcmd, argv, 255); tmpcmd[255] = '\0';
                cptr = strtok(tmpcmd," \t") ; /* first argument */
                if (cptr != NULL)
                 srcdrive = atoi(cptr) ;
                cptr = strtok(NULL," \t") ; /* second argument */
                if (cptr != NULL)
                 destdrive = atoi(cptr) ;

                if (((srcdrive < 0) || (srcdrive >= nfloppies)) || ((destdrive < 0) || (destdrive >= nfloppies)))
                 {
                  /* Bad drive specifier given (not a valid floppy drive) */
                  rerror = global_error(err_baddrive) ;
                 }
                else
                 {
                  dprintf(("","CopyBoot: src %d dest %d\n",srcdrive,destdrive)) ;

                  srcblock = (DOS_bootsector *)malloc(sizeof(DOS_bootsector)) ;
                  destblock = (DOS_bootsector *)malloc(sizeof(DOS_bootsector)) ;
                  if ((srcblock == NULL) || (destblock == NULL))
                   {
                    if (srcblock != NULL)
                     free(srcblock) ;
                    rerror = global_errorT(err_heapexhausted, tok_heapexhausted, 0, 0) ;
                   }
                  else
                   {
                    char                 tmpstr[8];
                    int                  fhand = 0 ; /* open file handle */

                    /* Load the BOOT BLOCK from the source drive */
                    sprintf(tmpstr,"adfs::%d",srcdrive) ;
                    rset.r[0] = open_read | open_default;
                    rset.r[1] = (int)tmpstr;
                    rerror = _kernel_swi(OS_Find, &rset, &rset);
                    fhand = rset.r[0];
                    if (rerror != NULL || fhand == 0)
                     {
                      dprintf(("","CMD_CopyBoot: failed to open source image\n") );
                      rerror = global_errorT(err_objectnotfound,tok_objectnotfound,tmpstr,0) ;
                     }
                    else
                     {
                      /* read the BOOT BLOCK from the image */
                      rset.r[0] = OSGBPB_ReadFromGiven;
                      rset.r[1] = fhand;
                      rset.r[2] = (int)srcblock;
                      rset.r[3] = sizeof(DOS_bootsector);
                      rset.r[4] = 0x00000000;
                      rerror = _kernel_swi(OS_GBPB, &rset, &rset);
                      if (rerror != NULL || rset.r[3] != 0)
                        rerror = global_error(err_readfailed) ;

                      /* close the image file */
                      rset.r[0] = 0;
                      rset.r[1] = fhand;
                      _kernel_swi(OS_Find, &rset, &rset);
                      if (rerror == NULL)
                       {
                        dprintf(("","CMD_CopyBoot: source secsize = %d\n", READ_LOHI(srcblock->BOOT_secsize)));
                        dprintf(("","CMD_CopyBoot: source secalloc = %d\n", srcblock->BOOT_secalloc));
                        dprintf(("","CMD_CopyBoot: source reserved = %d\n", READ_LOHI(srcblock->BOOT_reserved)));
                        dprintf(("","CMD_CopyBoot: source num_fats = %d\n", srcblock->BOOT_num_fats));
                        dprintf(("","CMD_CopyBoot: source root size = %d\n", READ_LOHI(srcblock->BOOT_root_dir)));
                        dprintf(("","CMD_CopyBoot: source max_sect = %d\n", READ_LOHI(srcblock->BOOT_max_sect)));
                        dprintf(("","CMD_CopyBoot: source magic = &%02X\n", srcblock->BOOT_magic));
                        dprintf(("","CMD_CopyBoot: source FAT_size = %d\n", READ_LOHI(srcblock->BOOT_FAT_size)));
                        dprintf(("","CMD_CopyBoot: source secstrack = %d\n", READ_LOHI(srcblock->BOOT_secstrack)));
                        dprintf(("","CMD_CopyBoot: source heads = %d\n", READ_LOHI(srcblock->BOOT_heads)));
                        dprintf(("","CMD_CopyBoot: source hidden = %d\n", READ_0123(srcblock->hidden)));

                        if (rerror == NULL)
                         {
                          /* If the source drive and destination drive are the
                           * same then prompt for the disc to be changed.
                           */
                          if (srcdrive == destdrive)
                           {
                            char *buf = NULL;
                            int bufsz;
                            if ( (rerror = msgtrans_lookup("Prompt1", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                            {
                             buf = rerror->errmess;
                             bufsz = strlen( buf );
                            }
                            fwrite( buf, 1, bufsz, stdout );
                            /* We need to take account of ESCAPE here */
                            rset.r[0] = OsByte_ScanKeyboardFrom16;
                            do
                            {
                              rerror = _kernel_swi(OS_Byte,&rset,&rset) ;
                            } while ((rerror == NULL) && (rset.r[1] != KeyScan_Space) && (rset.r[1] != KeyScan_Escape)) ;
                            putchar( '\n' );
                            if (rerror != NULL)
                             rerror = global_error(err_keyboardread);
                            else if (rset.r[1] == KeyScan_Escape) {
                             dprintf(("","CMD_CopyBoot: Escape\n")) ;
                             _gerror.errnum = 17 ; /* NASTY CONSTANT */
                             buf = _gerror.errmess;
                             bufsz = 252;
                             if ( (rerror = msgtrans_lookup("Escape", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                             {
                              _gerror.errnum = rerror->errnum;
                              strcpy( _gerror.errmess, rerror->errmess );
                             }
                            }
                           }

                          if (rerror == NULL)
                           {
                            /* Load the BOOT BLOCK from the destination drive */
                            sprintf(tmpstr,"adfs::%d",destdrive) ;
                            rset.r[0] = open_write | open_read | open_default;
                            rset.r[1] = (int)tmpstr;
                            rerror = _kernel_swi(OS_Find, &rset, &rset);
                            fhand = rset.r[0];
                            if (rerror != NULL || fhand == 0)
                             {
                              dprintf(("","CMD_CopyBoot: failed to open dest image\n")) ;
                              rerror = global_errorT(err_objectnotfound,tok_objectnotfound,tmpstr,0) ;
                             }
                            else
                             {
                              /* read the BOOT BLOCK from the image */
                              rset.r[0] = OSGBPB_ReadFromGiven;
                              rset.r[1] = fhand;
                              rset.r[2] = (int)destblock;
                              rset.r[3] = sizeof(DOS_bootsector);
                              rset.r[4] = 0x00000000;
                              rerror = _kernel_swi(OS_GBPB, &rset, &rset);
                              if (rerror != NULL || rset.r[3] != 0)
                                rerror = global_error(err_readfailed) ;
                              else
                               {
                                if (rerror == NULL)
                                 {
                                  /* Copy the 3byte JMP, OEM information and
                                   * boot code from the source to the destination buffer,
                                   * zero the hidden sectors and 32b sector count (it's
                                   * a floppy!), and ensure a boot signature is present.
                                   */
                                  for (loop = 0; (loop < 3); loop++)
                                   destblock->BOOT_JMP[loop] = srcblock->BOOT_JMP[loop] ;

                                  for (loop = 0; (loop < 8); loop++)
                                   destblock->BOOT_OEM[loop] = srcblock->BOOT_OEM[loop] ;

                                  memcpy(&destblock->BOOT_extra.fat12,
                                         &srcblock->BOOT_extra.fat12,
                                         sizeof(srcblock->BOOT_extra.fat12)) ;

                                  destblock->hidden0 = destblock->hidden1 =
                                  destblock->hidden2 = destblock->hidden3 = 0; /* Floppy */
                                  destblock->big_sect0 = destblock->big_sect1 =
                                  destblock->big_sect2 = destblock->big_sect3 = 0; /* Floppy */

                                  destblock->BOOT_extra.fat12.BOOT_signature = 0x55 ;
                                  destblock->BOOT_extra.fat12.BOOT_signatureHI = 0xAA ;

                                  /* Save the BOOT BLOCK back to the destination drive */
                                  rset.r[0] = OSGBPB_WriteAtGiven;
                                  rset.r[1] = fhand;
                                  rset.r[2] = (int)destblock;
                                  rset.r[3] = sizeof(DOS_bootsector);
                                  rset.r[4] = 0x00000000;
                                  if (_kernel_swi(OS_GBPB, &rset, &rset) != NULL)
                                    rerror = global_error(err_writefailed) ;
                                 }
                               }
                              /* close the image file */
                              rset.r[0] = 0;
                              rset.r[1] = fhand;
                              _kernel_swi(OS_Find, &rset, &rset);
                             }
                           }
                         }
                       }
                     }
                    free(srcblock) ;
                    free(destblock) ;
                   }
                 }
               }
             }
             break ;

   default : /* unknown */
             break ;
  }

 return(rerror) ;
 UNUSED(argv) ;
 UNUSED(argc) ;
 UNUSED(privateword) ;
}

/*-------------------------------------------------------------------------*/

_kernel_oserror *shutdown_fs(int fatal, int podule, void *pw)
{
 _kernel_swi_regs rset ;
 mapentry *cptr ;

 dprintf(("","DOSFS: shutdown_fs called\n")) ;

 /* JRS 26/3/92: free all DOS name mappings */
 while (maplist != NULL)
 {
   cptr = maplist;
   maplist = maplist->next;
   free(cptr) ;
 }

 /* Deregister our image type (ignoring errors) */
 rset.r[0] = FSControl_DeRegisterImageFS;
 rset.r[1] = FileType_MSDOSDisc ;  /* image type we provide support for */
 (void)_kernel_swi(OS_FSControl,&rset,&rset) ;

 /* Close messages file, remove from ResourceFS if RAM loaded */
 msgtrans_closefile();
#ifndef ROM
 _swix(ResourceFS_DeregisterFiles, _IN(0), dosfs_msgarea());
#endif

 UNUSED(fatal);
 UNUSED(podule);
 UNUSED(pw);
 return NULL;
}

/*-------------------------------------------------------------------------*/

_kernel_oserror *init_fs(const char *cmd_tail,int podule_base,void *privateword)
{
 _kernel_oserror  *syserr ;
 _kernel_swi_regs r;

  /* set up debugging */
  debug_initialise ("DOSFS", "", 0);
//  debug_set_device(DEBUGIT_OUTPUT);
//  debug_set_device(HAL_OUTPUT);
  debug_set_device(PRINTF_OUTPUT);
  debug_set_unbuffered_files (TRUE);
  debug_set_stamp_debug (TRUE);

 dprintf(("","DOSFS: init_fs: entered\n"));
 _syserr = &_gerror ;              /* reference the static global error area */

#ifndef ROM
 /* Register the messages for RAM based modules */
 r.r[0] = (int)dosfs_msgarea();
 syserr = _kernel_swi(ResourceFS_RegisterFiles, &r, &r);
 if (syserr != NULL) return syserr;
 dprintf(("","DOSFS: messages registered\n"));
#endif

 if ((syserr = declare_FS(privateword)) != NULL)
  dprintf(("","DOSFS: init_fs: &%08X \"%s\"\n",syserr->errnum,syserr->errmess)) ;

 r.r[0] = (int)"File$Type_FC8";
 r.r[1] = (int)"DOSDisc";
 r.r[2] = 7;
 r.r[3] = 0;
 r.r[4] = VarType_String;
 /* Ignore error here, if setting the variable fails then "fc8" will be used. */
 (void)_kernel_swi(OS_SetVarVal, &r, &r);

 r.r[0] = (int)"File$Type_FE4";
 r.r[1] = (int)"DOS";
 r.r[2] = 3;
 r.r[3] = 0;
 r.r[4] = VarType_String;
 /* Ignore error here, if setting the variable fails then "fc4" will be used. */
 (void)_kernel_swi(OS_SetVarVal, &r, &r);

 r.r[1] = (int)"FileCore_DiscOp64";
 if (_kernel_swi(OS_SWINumberFromString, &r, &r)==NULL) discopswi = r.r[0];
 
 dprintf(("","DOSFS: init_fs: exiting\n") );
 return(0) ;
 UNUSED(podule_base) ;
 UNUSED(cmd_tail) ;
}

/*-------------------------------------------------------------------------*/
/*> EOF c.DOSFS <*/
@


4.30
log
@No longer offer PCMCIA SRAM card as a format option
Untangle the PCMCIATRUE misnomer - what it really meant was "offer PCMCIA card as an option for *Format AND allow non floppy geometries".
Nothing has shipped with PCCardFS since October 1994, so stop offering it as a possible *Format.
However, we do rely on the non floppy geometries for things like SD cards and USB sticks, so retain that with a new switch (permanently enabled) called NONFLOPPIES.

Tested with a Pi SD card and a 4GB USB stick.

Version 1.11. Tagged as 'DOSFS-1_11'
@
text
@d25 1
d54 1
d199 2
a200 2
                      int *numFATs,int *FATsize,int *magic,int *ROOTsize,
                      int *Atari,int *dblstep,int *numRESVD,word *volumeid)
d214 2
a215 2
    int bbsize = max_sector(bblock);
    int notracks = (bblock->BOOT_secstrackHI << 8) | bblock->BOOT_secstrack;
d219 2
a220 2
    notracks = bbsize / notracks; /* Calculate number of tracks from BOOT block. */
    bbsize = bbsize * DOSsecsize; /* Calculate disc size from BOOT block. */
d226 1
a226 1
    dprintf(("","DOSFS: testforbpb: check size = &%08X\n",bbsize)) ;
d231 1
a231 1
    if (((bbsize < (discSize + (secspertrk(dr)*bytespersec(dr)))) && (bbsize >= discSize)) || !floppy)
d242 5
d248 2
a249 2
          *ROOTsize = ((bblock->BOOT_root_dir | (bblock->BOOT_root_dirHI << 8)) * sizeof(DOS_direntry)) ;
          *FATsize = (bblock->BOOT_FAT_size | (bblock->BOOT_FAT_sizeHI << 8)) * DOSsecsize;
d252 1
a252 1
          *numRESVD = (bblock->BOOT_reserved | (bblock->BOOT_reservedHI << 8)) ;
d257 1
a257 2
             *volumeid = (bblock->BOOT_extra.fat12.volid | (bblock->BOOT_extra.fat12.volid1 << 8) | 
                         (bblock->BOOT_extra.fat12.volid2 << 16) | (bblock->BOOT_extra.fat12.volid3 << 24));
d262 1
a262 2
             *volumeid = (bblock->BOOT_extra.fat32.VolID0 | (bblock->BOOT_extra.fat32.VolID1 << 8) |
                         (bblock->BOOT_extra.fat32.VolID2 << 16) | (bblock->BOOT_extra.fat32.VolID3 << 24));
d269 1
a269 2
                *FATsize = (bblock->BOOT_extra.fat32.FAT_sz0 | (bblock->BOOT_extra.fat32.FAT_sz1<<8) |
                           (bblock->BOOT_extra.fat32.FAT_sz2<<16) | (bblock->BOOT_extra.fat32.FAT_sz3<<24)) * DOSsecsize;
d272 1
a272 1
          discsize(dr) = bbsize; /* Use bbsize incase FileCore was guessing discSize */
d274 1
a274 1
          if (!floppy) secspertrk(dr) = (bblock->BOOT_secstrackHI << 8) | bblock->BOOT_secstrack;
d284 4
a287 3
static int testforpartition(ADFS_drecord *dr,char *sector,_kernel_swi_regs *rset,word *winioffset,
                            int *numFATs,int *FATsize,int *magic,int *ROOTsize,
                            int *Atari,int *dblstep,int *numRESVD,word *volumeid)
a289 2
 _kernel_swi_regs urset ;
 FS_discop64      opblock;
d292 1
a292 1
 word   winisize = 0 ;   /* media size */
d296 1
a296 1
 if (((bblock->BOOT_extra.fat12.BOOT_signature) | (bblock->BOOT_extra.fat12.BOOT_signatureHI << 8)) != DOS_PARTITION_signature)
d318 10
a327 24
 *winioffset = ((pentry[8] | (pentry[9] << 8) | (pentry[10] << 16) | (pentry[11] << 24)) * DOSsecsize);
 winisize = (pentry[12] | (pentry[13] << 8) | (pentry[14] << 16) | (pentry[15] << 24));
 dprintf(("","DOSFS: testforpartition: Found partition at winioffset = &%08X\n",*winioffset));

 urset.r[3] = (word)bblock ;                        /* BOOT block buffer */
 urset.r[4] = sizeof(DOS_bootsector) ;              /* size of the buffer */
 urset.r[6] = rset->r[6] ;                          /* entry sector cache handle */
 urset.r[8] = rset->r[8] ;                          /* entry FileCore private word pointer */
 if (discopswi==FileCore_DiscOp)
    {
    urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
    urset.r[2] = (dr->dr_rootSIN & 0xE0000000) + *winioffset;      /* disc address */
    }
 else
    {
    opblock.drivenumber   = (dr->dr_rootSIN & 0xE0000000) >> 29;
    opblock.byteaddresslo = *winioffset;
    opblock.byteaddresshi = 0;
    urset.r[1] = (9 | (4 << 4));
    urset.r[2] = (int)&opblock;
    urset.r[5] = (int)dr;
    }
 dprintf(("","DOSFS: testforpartition: reading sector from &%08X\n",dr->dr_rootSIN + *winioffset));
 if ((rerror = _kernel_swi(discopswi,&urset,&urset)) == NULL)
d331 1
a331 1
    rootsize = ((bblock->BOOT_root_dir | (bblock->BOOT_root_dirHI << 8)) * sizeof(DOS_direntry)) ;
d338 1
a338 1
    fatsize = (bblock->BOOT_FAT_size | (bblock->BOOT_FAT_sizeHI << 8)); 
d342 1
a342 2
       fatsize = (bblock->BOOT_extra.fat32.FAT_sz0 | (bblock->BOOT_extra.fat32.FAT_sz1<<8) |
                 (bblock->BOOT_extra.fat32.FAT_sz2<<16) | (bblock->BOOT_extra.fat32.FAT_sz3<<24));
d348 1
a348 2
       *volumeid = (bblock->BOOT_extra.fat12.volid | (bblock->BOOT_extra.fat12.volid1 << 8) | 
                   (bblock->BOOT_extra.fat12.volid2 << 16) | (bblock->BOOT_extra.fat12.volid3 << 24));
d353 1
a353 2
       *volumeid = (bblock->BOOT_extra.fat32.VolID0 | (bblock->BOOT_extra.fat32.VolID1 << 8) |
                   (bblock->BOOT_extra.fat32.VolID2 << 16) | (bblock->BOOT_extra.fat32.VolID3 << 24));
d357 1
a357 1
    dprintf(("","DOSFS: testforpartition: bbsize=%u, winisize=%u, fatsize=%u sectors\n", bbsize, winisize, fatsize));
d362 6
d372 1
a372 1
    *FATsize = fatsize * DOSsecsize;
d374 4
a377 4
    *Atari = 0; /* Never Atari */
    *numRESVD = (bblock->BOOT_reserved | (bblock->BOOT_reservedHI << 8)) ;
    *dblstep = 0; /* Never double step */
    discsize(dr) = bbsize * DOSsecsize; /* Use bbsize incase FileCore was guessing discsize */
d379 1
a379 1
    secspertrk(dr) = (bblock->BOOT_secstrackHI << 8) | bblock->BOOT_secstrack;    
d381 1
a381 1
    dprintf(("","DOSFS: testforpartition magic=%02X root=%x fat=%x (x%d copies) resvd=%d\n",(int)*magic,(int)*ROOTsize,(int)*FATsize,(int)*numFATs,(int)*numRESVD));
d389 2
a390 2
                          int *numFATs,int *FATsize,int *magic,int *ROOTsize,
                          int *Atari,int *dblstep,int *numRESVD)
d406 1
a406 1
 *Atari = 0;
d408 1
a408 1
 *dblstep = 1;
a424 1
 _kernel_swi_regs urset ;
d429 4
a432 2
 FS_discop64      opblock;
 int   dblstep, numFATs, FATsize, numRESVD, ROOTsize;
d434 1
a434 1
 int   Atari = 0;
d438 2
a439 1
 word  winioffset = 0, volumeid = 0;
d441 1
a441 1
 int   loop, index, step;
d461 2
a462 37
 /* Use FileCore_DiscOp 9 (option bits 2_01x0) and the alternative disc record we have */
 /* FileCore_DiscOp{64} */
 /*      in:     r1 = bits0-3    reason code 9 */
 /*                   bits4-7    option bits */
 /*                   bits8-31   bits2-25 of pointer to alternative disc record */
 /*                  {bits 8-31 reserved} */
 /*              r2 = disc address {pointer to block containing the 64 bit disc address} */
 /*              r3 = pointer to buffer */
 /*              r4 = length (bytes) */
 /*             {r5 = address of alternate disc record} */
 /*              r6 = sector cache handle */
 /*              r8 = pointer to FileCore instance private word */
 /*      out:    r1 = preserved */
 /*              r2 = disc address of next byte to be transferred */
 /*              r3 = pointer to next buffer location to be transferred */
 /*              r4 = number of bytes NOT transferred */
 /*              r6 = new sector cache handle */
 /*              r8 = preserved */

 urset.r[3] = (word)bblock ;                        /* BOOT block buffer */
 urset.r[4] = sizeof(DOS_bootsector) ;              /* size of the buffer */
 urset.r[6] = rset->r[6] ;                          /* entry sector cache handle */
 urset.r[8] = rset->r[8] ;                          /* entry FileCore private word pointer */
 if (discopswi==FileCore_DiscOp)
    {
    urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ; /* read cached here */
    urset.r[2] = dr->dr_rootSIN & 0xE0000000 ;            /* disc address */
    }
 else
    {
    opblock.drivenumber   = (dr->dr_rootSIN & 0xE0000000) >> 29;
    opblock.byteaddresslo = 0;
    opblock.byteaddresshi = 0;
    urset.r[1] = (9 | (4 << 4));
    urset.r[2] = (int)&opblock;
    urset.r[5] = (int)dr;
    }
d465 1
a465 1
 if ((rerror = _kernel_swi(discopswi,&urset,&urset)) != NULL)
d482 2
a483 2
       if (floppy || testforpartition(dr,sector,rset,&winioffset,&numFATs,&FATsize,&magic,&ROOTsize,
                                      &Atari,&dblstep,&numRESVD,&volumeid))
d500 1
a500 1
 sectorblock = realloc(sector,FATsize);
d508 1
a508 1
    step = FATsize;    /* Enough memory to load the whole FAT at once */
d511 1
a511 1
 for (index = 0; index < FATsize; index += step)
d513 5
a517 18
     urset.r[3] = (word)sector ;
     urset.r[4] = step ;
     /* sector cache handle and FileCore private word pointer preserved from above call */

     if (discopswi==FileCore_DiscOp)
        {
        urset.r[1] = ((floppy ? 9 : 1) | (4 << 4) | (((int)dr >> 2) << 8)) ;
        urset.r[2] = (index + numRESVD * DOSsecsize + winioffset) | (dr->dr_rootSIN & 0xE0000000); /* disc address */
        }
     else
        {
        /* rely on r2 being preserved,and the drive number in the block */
        opblock.byteaddresslo = index + numRESVD * DOSsecsize + winioffset;
        opblock.byteaddresshi = 0;
        urset.r[1] = ((floppy ? 9 : 1) | (4 << 4)); /* Read uncached for fixed discs */
        urset.r[5] = (int)dr;
        }
     if ((rerror = _kernel_swi(discopswi,&urset,&urset)) == NULL)
d552 1
d570 5
a574 16
     urset.r[3] = (word)sector ;
     urset.r[4] = DOSsecsize ;
     if (discopswi==FileCore_DiscOp)
        {
        /* sector cache handle and FileCore private word pointer preserved from above call */
        urset.r[1] = ((floppy ? 9 : 1) | (4 << 4) | (((int)dr >> 2) << 8)) ;
        urset.r[2] = ((numFATs * FATsize) + loop + numRESVD * DOSsecsize + winioffset) | (dr->dr_rootSIN & 0xE0000000) ; /* disc address */
        }
     else
        {
        /* rely on r1 and r2 being preserved,and the drive number in the block*/
        opblock.byteaddresslo = (numFATs * FATsize) + loop + numRESVD * DOSsecsize + winioffset;
        opblock.byteaddresshi = 0;
        urset.r[5] = (int)dr;
        }
     if ((rerror = _kernel_swi(discopswi,&urset,&urset)) == NULL)
d578 1
a578 1
        index = 0;
d621 1
a621 1
              if (FATsize != DOS_formats[loop].secsFAT * DOSsecsize)
d644 1
a644 1
 rset->r[6] = urset.r[6] ;   /* sector cache handle returned from "FileCore_DiscOp{64}" */
d931 1
d1385 1
a1385 3
                        int bbsize = (srcblock->BOOT_secsize | (srcblock->BOOT_secsizeHI << 8)) ;
                        dprintf(("","CMD_CopyBoot: source secsize = %d\n", (srcblock->BOOT_secsizeHI << 8)
                                | srcblock->BOOT_secsize));
d1387 1
a1387 2
                        dprintf(("","CMD_CopyBoot: source reserved = %d\n", (srcblock->BOOT_reservedHI << 8)
                                | srcblock->BOOT_reserved));
d1389 2
a1390 4
                        dprintf(("","CMD_CopyBoot: source root size = %d\n", (srcblock->BOOT_root_dirHI << 8)
                                | srcblock->BOOT_root_dir));
                        dprintf(("","CMD_CopyBoot: source max_sect = %d\n", (srcblock->BOOT_max_sectHI << 8)
                                | srcblock->BOOT_max_sect));
d1392 4
a1395 8
                        dprintf(("","CMD_CopyBoot: source FAT_size = %d\n", (srcblock->BOOT_FAT_sizeHI << 8)
                                | srcblock->BOOT_FAT_size));
                        dprintf(("","CMD_CopyBoot: source secstrack = %d\n", (srcblock->BOOT_secstrackHI << 8)
                                | srcblock->BOOT_secstrack));
                        dprintf(("","CMD_CopyBoot: source heads = %d\n", (srcblock->BOOT_headsHI << 8)
                                | srcblock->BOOT_heads));
                        dprintf(("","CMD_CopyBoot: source hidden = %d\n", (srcblock->hidden1 << 8)
                                | srcblock->hidden));
a1459 1
                                bbsize = (destblock->BOOT_secsize | (destblock->BOOT_secsizeHI << 8)) ;
d1477 1
a1477 1
                                  destblock->hidden  = destblock->hidden1 =
d1479 1
a1479 1
                                  destblock->big_sect  = destblock->big_sect1 =
@


4.29
log
@Allow mounting discs with 1 letter names, and 2x buffer overrun fixes
DOSFS would prefer to use the disc title from the volume name entry in the root directory, even if this reduced to 1 letter, which would then lead to "Disc drive not known" errors. Since the disc couldn't be mounted it couldn't be renamed either, requiring a trip to a PC to do so.
Now, if the cleaned up name is < 2 characters long, ignore it and use the one based on the volumeid, and if that doesn't exist, use the default one ("Untitled") from the Messages file.
In OpsFunc.c used memset() in place of a byte set loop.

Ref https://www.riscosopen.org/forum/forums/4/topics/9503
DOSFS.c, line 621: remove the excess NULL so the sprintf fits into the 10 byte buffer, not 11.
DOSFS.c, line 1556: restore the original intent for *CopyBoot in light of the structure/union reorg DOSshape.h revision 4.7 in DOSFS-0_79. Previously the boot code was copied in its entirity as an opaque blob, but the loop was left unchanged, overrunning the sector buffer.

A useful example of the extent of the boot code is given in
  http://thestarman.pcministry.com/asm/mbr/DOS50FDB.htm
which shows the code uses up every last byte of the sector.

Tested with a disc called "R", which can now be mounted. A floppy with no name and no volume id, and one with no name and a volume id.

Version 1.10. Tagged as 'DOSFS-1_10'
@
text
@d205 1
a205 1
#ifdef PCMCIATRUE
d226 2
a227 2
#ifdef PCMCIATRUE
    /* Now have to cope with PCMCIA cards with bits of first track "missing" */
d713 1
a713 3
/* NOTE: This code currently only deals with floppy structures and         */
/* optionally PCMCIA (arbitrary sector-multiple size structures) through   */
/* the addition of r4 as a parameter                                       */
a720 1
  *      r4 = size of partiton if r0 = PCMCIA
d729 2
a730 3
#ifdef PCMCIATRUE
 /* Should be a multiple of sectors big for PCMCIA */
 if((rset->r[0] == 9) && ((rset->r[4] % DOSsecsize) != 0)) { 
a733 1
#endif
a764 11
#ifdef PCMCIATRUE
   /* Special code for PCMCIA format */
   if(rset->r[0] == 9) {
       /* We need to change the max_sect and secsFAT settings */
        maxsect = rset->r[4] / DOSsecsize; /* Should be an integer result */
        dbsector->BOOT_max_sect = ((maxsect >> 0) & 0xFF) ;
        dbsector->BOOT_max_sectHI = ((maxsect >> 8) & 0xFF) ;
        dbsector->BOOT_FAT_size = ((maxsect * 2) + (DOSsecsize / 2))/ DOSsecsize; /* Rounded up */
   }
#endif

@


4.28
log
@Fixes to stop DOSFS erroneously claiming partitions that aren't valid
In particular with ADFS, attempting to format an ATA drive purchased from a PC box shifter would often lead to the machine hanging on startup meaning you can't get as far as running !HForm. Further analysis showed that the problem was caused by DOSFS latching onto the PC partition table and attempting to claim the Service_IdentifyDisc. This would then be followed by trying to load the FAT via FileCore in situations where the FAT to load were bigger than the disc size represented by the disc record FileCore has attached to the disc.

This primarily concerns things with partition tables (like a fixed disc).
Things got off to a bad start, some inaccurate keyboard mashing meant the definition for DOS_bootsector added up to 520 bytes, and this was loaded into a malloc'd 512 byte buffer.
The representation of the disc size (bbsize) was being kept in a signed integer, so the single (rather weak) test of checking the boot block declared size (bbsize) being greater than the partition declared size (winisize) would always be accepted for partitions > 2GB.
Additionally, the bbsize was multiplied by DOSsecsize and performed as a byte compare rather than a sector compare, leading to overflow.
Invariably this check would pass (either due to the sign bit being set, or overflow) and DOSFS would claim the service and go ahead and try to read in an unfeasibly large FAT.

DOSFS is now much more strict about checking
* be sure bbsize can fit in the partition by comparing as unsigned number of sectors, convert to bytes later
* be sure bbsize is non zero
* be sure the FAT isn't bigger than bbsize
* be sure the root directory isn't bigger than bbsize
only then claim the service.

DOSshape.h:
Correct the size of the DOS_bootsector back to 512 bytes.
ADFSshape.h:
Remove unused grubby FileCore constants, especially as we're not likely to encounter any 256B/sector drives!
Add the extra disc record fields to get us up to 'BigDisc' in FileCore parlance.
DOSFS.c:
If the rootsize is zero, have a go at using the FAT32 ones instead. Previously this logic only triggered if the FAT32 extended signature was present, but that signature is for the fields that follow it - the FAT size preceeds.
Only update the return variables if we're confident we're going to claim the service.
Remove dead variable 'notracks'.

Tested on a sample of 4 ATA drives > 10GB from different vendors previously used in PCs. All 4 used to hang when installed, now they do not.

Version 1.08. Tagged as 'DOSFS-1_08'
@
text
@d618 1
a618 1
 if (volumeid != 0) sprintf((char*)(dr->dr_discname),"%04X-%04X\0",(volumeid >> 16) & 0xFFFF,volumeid & 0xFFFF);
d645 2
d648 14
a661 5
           memmove((void *)&(dr->dr_discname[0]),(void *)&(dentry->FILE_status),(discnamesize - 1)) ;
           /* Replace invalid characters in disc name */
           dprintf(("","DOSFS: dr->dr_discname = %p\n",dr->dr_discname));
           dprintf(("","DOSFS: dr->dr_discname+9 = %p\n",dr->dr_discname+9));
           for (name=dr->dr_discname+9; name>=dr->dr_discname; name--)
d663 1
a663 8
            dprintf(("","DOSFS: in loop: *name = %c\n",*name));
            if(isalnum(*name))
            {
             name++;
             *name = NULL;
             name = dr->dr_discname;
             dprintf(("","DOSFS: ok\n"));
            }
a664 6
           dprintf(("","DOSFS: dr->dr_discname = %p\n",dr->dr_discname));
           for (name=dr->dr_discname; *name; name++)
               {
               *name=mapchar(*name,DOSmapping,ROmapping);
               }
           dprintf(("","DOSFS: validatedosformat: volume \"%s\"\n",(char *)dr->dr_discname)) ;
d669 2
a670 1
      
d1552 3
a1554 2
                                   * 480bytes of boot code from the source to the
                                   * destination buffer.
d1562 11
a1572 2
                                  for (loop = 0; (loop < 480); loop++)
                                   destblock->BOOT_extra.fat12.code[loop] = srcblock->BOOT_extra.fat12.code[loop] ;
@


4.27
log
@Used Service_Serviced instead of 0, use FileType_MSDOSDisc instead of FC8
Not tagged.
@
text
@d340 16
a355 2
    int bbsize = max_sector(bblock);
    int notracks = (bblock->BOOT_secstrackHI << 8) | bblock->BOOT_secstrack;
a356 12
    dprintf(("","DOSFS: testforpartition: read sector OK\n"));
    bbsize = bbsize * DOSsecsize; /* Calculate disc size from BOOT block. */
    if (bbsize > (winisize*DOSsecsize)) return 1;
       
    /* It's a DOS disc so claim it as one of ours and set up the disc record info. */
    *magic = bblock->BOOT_magic;
    *ROOTsize = ((bblock->BOOT_root_dir | (bblock->BOOT_root_dirHI << 8)) * sizeof(DOS_direntry)) ;
    *FATsize = (bblock->BOOT_FAT_size | (bblock->BOOT_FAT_sizeHI << 8)) * DOSsecsize;
    *numFATs = bblock->BOOT_num_fats;
    *Atari = 0; /* Never Atari */
    *numRESVD = (bblock->BOOT_reserved | (bblock->BOOT_reservedHI << 8)) ;
    *dblstep = 0; /* Never double step */
d363 1
a363 1
    else if (bblock->BOOT_extra.fat32.BootSig == 0x29)
a367 11
       /* use correct ROOTsize */
       if (0 == *ROOTsize)
          {
          *ROOTsize = cluster_size(bblock);
          }
       /* .. and also correct FAT size */
       if (0 == *FATsize)
          {
          *FATsize = (bblock->BOOT_extra.fat32.FAT_sz0 | (bblock->BOOT_extra.fat32.FAT_sz1<<8) |
                     (bblock->BOOT_extra.fat32.FAT_sz2<<16) | (bblock->BOOT_extra.fat32.FAT_sz3<<24)) * DOSsecsize;
          }
d369 17
a385 1
    discsize(dr) = bbsize; /* Use bbsize incase FileCore was guessing discSize */
a387 1
    UNUSED(notracks);
d389 1
a389 1
    dprintf(("","DOSFS: testforpartition %d %x %x %d %d %x\n",(int)*magic,(int)*ROOTsize,(int)*FATsize,(int)*numFATs,(int)*numRESVD,bbsize));
d1011 1
a1011 1
                dprintf(("","DOSFS: Service_IdentifyDisc: dr->dr_drive = &%08X\n",dr->dr_drive));
@


4.26
log
@Change last couple of uses of trace macros to use DebugLib
This town ain't big enough for the two of us.

Version 1.07. Tagged as 'DOSFS-1_07'
@
text
@d31 1
d33 2
a35 1
#include "Global/Variables.h"
a54 4

#define imagetype (0xFC8) /* as allocated by Acorn : "DOSDisc" */

/*-------------------------------------------------------------------------*/
d106 1
a106 1
 infoblock[1] = (word)imagetype ;
d700 1
a700 1
 rset->r[1] = 0x00 ;         /* Service_Serviced (claimed) */
d702 1
a702 1
 rset->r[2] = imagetype ;    /* filetype to be associated with the disc image */
d911 1
a911 1
                 rset->r[1] = 0x00000000 ; /* claim this service */
d966 1
a966 1
                      rset->r[1] = 0x00 ; /* Service_Claimed */
d1112 1
a1112 1
                  rset->r[1] = 0x00 ;                   /* Service_Serviced (claimed) */
d1161 1
a1161 1
                     rset->r[1] = 0x00 ;         /* Service_Serviced */
d1615 1
a1615 1
 rset.r[1] = (word)imagetype ;  /* image type we provide support for */
@


4.25
log
@Don't subscribe to service calls you do nothing with
0x42 and 0x68 removed from service call table and service call handler.

Version 1.04. Tagged as 'DOSFS-1_04'
@
text
@a50 1
#include "debug.h"
d152 2
a153 1
 tracef4("DOSFS: FSSWI_DiscFormat: r0 = &%08X, r1 = &%08X, r2 = &%08X, r3 = &%08X\n",rset->r[0],rset->r[1],rset->r[2],rset->r[3]) ;
d727 1
a727 1
 tracef4("DOSFS: FSSWI_LayoutStructure: r0 = &%08X, r1 = &%08X, r2 = &%08X, r3 = &%08X\n",rset->r[0],rset->r[1],rset->r[2],rset->r[3]) ;
d993 2
a994 1
               tracef3("DOSFS: Service_IdentifyDisc: r5 = &%08X, r6 = &%08X, r8 = &%08X\n",rset->r[5],rset->r[6],rset->r[8]) ;
a1625 3
 show_mem_trace();
 trace_off();

@


4.24
log
@Fix a few null pointer dereferences in dprintf() statements
DOSdirs.c: be more careful about %s of NULL pointers
DOSFS.c: don't waste time strcmp() of PCMCIA format name when you can compare by index

Debug version built, less oflaoflaolfa now.

Version 1.03. Tagged as 'DOSFS-1_03'
@
text
@a928 3
   case 0x42 : /* Service_LookupFileType */
               break ;

a980 3
   case 0x68 : /* Service_CloseFile */
               break ;

@


4.23
log
@Allow RAM builds with messages in, fix for saving to images > 2G
RAM build include messages.
Removed atexit() handler, in favour of finalisation-code option in CMHG file.
Changed cluster rounding in saveFILE() to deal with extents > 2G.

Version 1.00. Tagged as 'DOSFS-1_00'
@
text
@d730 2
a731 1
 if(((rset->r[4] % DOSsecsize) != 0) && (rset->r[0] == 9)) { /* Should be a multiple of sectors big for PCMCIA */
d769 1
a769 1
   if((strcmp(DOS_formats[rset->r[0]].idtext,"PCMCIA") == 0)) {
@


4.22
log
@Add some comments (!) and reindent FileSwitch interface
OpsGetPut
  DOSFS_put_bytes no longer passes an unnecessary dummy argument.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFind
  Suggested buffer to FileSwitch is now 1x512 sector (rather than 256).
  Note - nothing seems to use the cluster buffering code in DOSFS,
indeed nothing ever malloc()s a buffer.
  Check at line 237 of OpFind would never be true since FILE_subdir is
not 1, fixed.
  Return an error if the handle to close is invalid.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFile
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFunc
  A failure to find a slot to set the disc title now reports "Dir full"
not "Disc full"
  Reindented.
  Doxygen comments added to FileSwitch layer.

Version 0.99. Tagged as 'DOSFS-0_99'
@
text
@d978 5
a982 1

d1604 1
a1604 1
static void shutdown_fs(void)
d1613 1
a1613 1
   {
d1617 1
a1617 1
   }
d1619 1
a1619 1
 /* OS_FSControl with image type */
a1621 2

 /* ignore any errors */
d1624 1
a1624 1
 /* Close Messages file. */
d1626 3
d1632 5
a1636 1
 return ;
d1648 1
a1648 1
  debug_set_device(DEBUGIT_OUTPUT);
d1650 1
a1650 1
//  debug_set_device(PRINTF_OUTPUT);
d1657 8
a1667 3
 if (atexit(shutdown_fs) != 0)
  dprintf(("","DOSFS: init_fs: failed to add shutdown function\n")) ;

@


4.21
log
@Rationalise some defines
Many magic numbers changed to exported defines.
Eliminated unused "BOOTblock.h" (was just nesting 1 include file).
Moved non ASCII definitions out of "ASCII.h" then found the remainder weren't used => eliminated.

Version 0.98. Tagged as 'DOSFS-0_98'
@
text
@d29 3
d33 1
a62 1
#if 1 /* SMC_TRUNCATE */
a63 1
#endif
a89 1
#if 1 /* SMC_TRUNCATE */
a90 1
#endif
a92 1
#if 1 /* SMC_TRUNCATE */
d94 1
a94 3
#define FileSwitchCMOS 0x1C
#define FileSwitchTruncateNamesCMOSBit 0x01
 rset.r[0] = 161;    /* Reason code "ReadCMOS" */
a104 1
#endif
d118 1
a118 1
 rset.r[0] = 35 ; /* reason code "FSControl_AddImage" */
d1434 1
a1434 1
                    rset.r[0] = 0x40;
a1435 1
                    rset.r[2] = 0;
d1446 1
a1446 1
                      rset.r[0] = 3;
d1498 1
a1498 1
                            rset.r[0] = 122;
d1500 1
a1500 1
                             {
d1502 1
a1502 1
                             } while ((rerror == NULL) && (rset.r[1] != 98) && (rset.r[1] != 112)) ;
d1506 1
a1506 1
                            else if (rset.r[1] == 112) {
d1523 1
a1523 1
                            rset.r[0] = 0xC0;
a1524 1
                            rset.r[2] = 0;
d1535 1
a1535 1
                              rset.r[0] = 3;
d1562 1
a1562 1
                                  rset.r[0] = 1;
d1615 2
a1616 2
 /* OS_FSControl 36 with image type */
 rset.r[0] = 36 ;               /* reason code "FSControl_RemoveImage"  */
d1658 1
a1658 1
 r.r[4] = 0;
d1666 1
a1666 1
 r.r[4] = 0;
@


4.20
log
@Source file subdivision
The sources to DOSFS had become rather jumbled and monolithic
* Split FileSwitch interface out into seperate ops source files.
* Combined international error lookup with MsgTrans code.
* Split utility functions into 'Helpers.c' along with wildcard matching functions.
* Moved DOS naming functions into, erm, 'DOSnaming.c'.
Also
* Makefile tweaked to remove 'symbols' on clean.
* Obsolete 'Help' and 'Syntax' placed in attic.

RAM, debug, and ROM targets built. RAM target tested with a DOS floppy disc.

Version 0.96. Tagged as 'DOSFS-0_96'
@
text
@d29 1
a34 1
#include "ASCII.h"
a43 1
#include "BOOTblock.h"
a72 1
char          tline[MaxString] = {0} ; /* static filename return area */
d792 1
a792 1
   reglist.r[0] = osgbpb_wptr ;            /* write operation */
d817 1
a817 1
       reglist.r[0] = osgbpb_wptr ;            /* write operation */
d852 5
a856 5
       reglist.r[0] = osgbpb_wptr ;   /* write operation */
       reglist.r[1] = rset->r[3] ;    /* FileSwitch handle */
       reglist.r[2] = (word)sector ;  /* data address */
       reglist.r[3] = DOSsecsize ;    /* amount of data */
       reglist.r[4] = offset ;        /* destination image offset */
d964 1
a964 1
                    reglist.r[0] = osgbpb_write ; /* write operation */
@


4.19
log
@  Fix setting disc name for DOS discs
Admin:
  Changes received from Willi Theiss

Version 0.94. Tagged as 'DOSFS-0_94'
@
text
@d24 1
a26 1
#include "ctype.h"
d28 1
d33 1
d35 4
a38 4
#include "DOSFS.h"
#include "DOSFSctl.h"
#include "debug.h"
#include "DOSFShdr.h"
d40 2
d43 2
a44 4
#include "FSerrors.h"
#include "DOSmapping.h"
#include "DOSnaming.h"
#include "DOSFSops.h"
a45 4
#include "wcompare.h"
#include "BOOTblock.h"  /* for the default BOOT BLOCK structure */
#include "TIMEconv.h"   /* for format time-stamping */
#include "MsgTrans.h"
d47 2
d116 7
a122 7
 infoblock[2] = ((word)DOSFS_Open     - (word)moduleBase) ;
 infoblock[3] = ((word)DOSFS_GetBytes - (word)moduleBase) ;
 infoblock[4] = ((word)DOSFS_PutBytes - (word)moduleBase) ;
 infoblock[5] = ((word)DOSFS_Args     - (word)moduleBase) ;
 infoblock[6] = ((word)DOSFS_Close    - (word)moduleBase) ;
 infoblock[7] = ((word)DOSFS_File     - (word)moduleBase) ;
 infoblock[8] = ((word)DOSFS_Func     - (word)moduleBase) ;
d125 2
a126 2
 rset.r[1] = (word)moduleBase ;
 rset.r[2] = ((word)infoblock - (word)moduleBase) ;
d141 1
a141 1
 rset.r[1] = (unsigned int)moduleName() ;       /* filing system name */
d220 1
a220 1
    int bbsize = DOSFS_max_sect(bblock);
d348 1
a348 1
    int bbsize = DOSFS_max_sect(bblock);
d915 1
a915 1
               if (rset->r[2] == (int)moduleBase)
@


4.18
log
@  Now creates a disc name from FAT32-formatted media
Admin:
  Changes received from Willi Theiss

Version 0.93. Tagged as 'DOSFS-0_93'
@
text
@d27 1
a27 1
#include "debuglib/debuglib.h"
d45 1
a45 1
#include "BOOTBLOCK.h"  /* for the default BOOT BLOCK structure */
d266 9
d374 11
d391 1
a391 2
    tracef6("DOSFS: testforpartition %d %x %x %d %d %x\n",
             (int)*magic,(int)*ROOTsize,(int)*FATsize,(int)*numFATs,(int)*numRESVD,bbsize);
d563 1
a563 1
        urset.r[2] = (index + DOSsecsize + winioffset) | (dr->dr_rootSIN & 0xE0000000); /* disc address */
d568 1
a568 1
        opblock.byteaddresslo = index + DOSsecsize + winioffset;
d631 1
a631 1
        urset.r[2] = ((numFATs * FATsize) + loop + DOSsecsize + winioffset) | (dr->dr_rootSIN & 0xE0000000) ; /* disc address */
d636 1
a636 1
        opblock.byteaddresslo = (numFATs * FATsize) + loop + DOSsecsize + winioffset;
d1648 1
@


4.17
log
@  Fixed timestamping
Detail:
  Renamed function "localTIME" to "get_RISCOS_TIME" since it has nothing to do
  with local time. This function used to call the C library function
  localtime(), but until recently the C library was non-conformant to the
  C standard, and simply produced a year/month/day/hour/minute/second breakdown
  as UTC. When this was fixed (RISC_OSLib 5.68) it changed DOSFS's behaviour;
  it was first detected because the reverse operation is implemented locally
  within DOSFS, so a read-modify-write of file attributes leads to the
  modification time being skewed by an amount equal to the difference between
  UTC and local time. Arguments can be made either to treat the on-disc time as
  local time (for compatibility with Windows and Mac OS) or as UTC (for
  compatibility with Linux or older RISC OS systems); I have opted to return
  behaviour to UTC. Also placed a lower limit on dates of the earliest date
  supported by FAT (1980), so for example if your system clock is set to 1970,
  as it will be if there is no RTC and NetTime is not operational, then you
  don't end up creating dates in the far future due to underflow.
Admin:
  Tested on a beagleboard

Version 0.90. Tagged as 'DOSFS-0_90'
@
text
@d261 6
d360 6
@


4.16
log
@  #include file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both Norcroft and GCC.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 0.86. Not tagged
@
text
@d808 1
a808 1
      localTIME(&formTIME) ;
@


4.15
log
@       repair DOSMap display/output prior to rom inclusion
Detail:
       the DOSMap command had a couple of *8 multipliers which
       thus wrongly indexed dos extent info in printout.
Admin:
       long file name dosfs beta tested in the field .. appears fit
       for purpose.. Also tested at castle
       castle added IP


Version 0.83. Tagged as 'DOSFS-0_83'
@
text
@d32 17
a48 17
#include "h.ASCII"
#include "h.DOSFS"
#include "h.DOSFSctl"
#include "h.debug"
#include "h.DOSFShdr"
#include "h.ADFSshape"
#include "h.DOSshape"
#include "h.FSerrors"
#include "h.DOSmapping"
#include "h.DOSnaming"
#include "h.DOSFSops"
#include "h.MultiFS"
#include "h.wcompare"
#include "h.BOOTBLOCK"  /* for the default BOOT BLOCK structure */
#include "h.TIMEconv"   /* for format time-stamping */
#include "h.MsgTrans"
#include "h.Statics"
d161 1
a161 1
 /* see "format_spec" structure in "h.MultiFS" */
d1005 1
a1005 1
                /* see "format_info" structure in "h.MultiFS" */
@


4.14
log
@   Update of DOSFS to handle Long File Names and FAT32 (up to 2GB)
Detail:
   Extend DOSFS to correctly recognise FAT32 DOS images and to
   use the Long File Name extensions. NOTE that there is still
   a 2gb size limit imposed by the max filecore image file
   size limitiations. NOTE also that as yet there is no support for
   UTF encoding of file names.
Admin:
   Tested at castle and with beta testers.
   Modifications are castle and castle assigned IP (from CJB)


Version 0.79. Tagged as 'DOSFS-0_79'
@
text
@d930 1
a930 1
                      char cchr = (*(char*)(cptr->dosext + (loop * 8))) ;
d1224 1
a1224 1
                      char cchr = (*(char*)(cptr->dosext + (loop * 8))) ;
d1334 1
a1334 1
                          if ((newmapping = (mapentry *)malloc(sizeof(mapentry))) == NULL)
@


4.13
log
@When a disc has no title but does have the extended boot sig and the
volumeid is non zero then the disc title will be set to %04X-%04X of
the volumeid instead of "Untitled" which should cut down on ambiguous
disc names a bit.

Version 0.78. Tagged as 'DOSFS-0_78'
@
text
@d27 1
d104 1
a104 1
  tracef0("File names will be truncated.\n");
d107 1
a107 1
  tracef0("Long file names will generate an error.\n");
d164 1
a164 1
 tracef1("DOSFS: FSSWI_DiscFormat: found format_spec &%08X\n",(word)fspec) ;
d167 6
a172 6
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->secsize  = %d\n",fspec->secsize) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->secstrk  = %d\n",fspec->secstrk) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->density  = %d\n",fspec->density) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->options  = &%02X\n",fspec->options) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->startsec = %d\n",fspec->startsec) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->tracks   = %d\n",fspec->tracks) ;
d231 2
a232 2
    tracef1("DOSFS: testforbpb: discSize = &%08X\n",discSize) ;
    tracef1("DOSFS: testforbpb: check size = &%08X\n",bbsize) ;
d255 1
a255 1
          if (bblock->BOOT_extra.wini.sig_rec == 0x29)
d258 2
a259 2
             *volumeid = (bblock->BOOT_extra.wini.volid | (bblock->BOOT_extra.wini.volid1 << 8) | 
                         (bblock->BOOT_extra.wini.volid2 << 16) | (bblock->BOOT_extra.wini.volid3 << 24));
d269 1
a269 1
 tracef0("DOSFS: testforbpb: FileCore and BOOT BLOCK disc sizes differ\n");
d286 1
a286 1
 if (((bblock->BOOT_extra.wini.BOOT_signature) | (bblock->BOOT_extra.wini.BOOT_signatureHI << 8)) != DOS_PARTITION_signature)
d292 1
a292 1
     pentry = (byte *)&(bblock->BOOT_extra.wini.partitions[index*sizeof(partition_entry)]);
d300 1
a300 1
        pentry = (byte *)&(bblock->BOOT_extra.wini.partitions[index*sizeof(partition_entry)]);
d310 1
a310 1
 tracef1("DOSFS: testforpartition: Found partition at winioffset = &%08X\n",*winioffset);
d330 1
a330 1
 tracef1("DOSFS: testforpartition: reading sector from &%08X\n",dr->dr_rootSIN + *winioffset);
d336 1
a336 1
    tracef0("DOSFS: testforpartition: read sector OK\n");
d348 1
a348 1
    if (bblock->BOOT_extra.wini.sig_rec == 0x29)
d351 2
a352 2
       *volumeid = (bblock->BOOT_extra.wini.volid | (bblock->BOOT_extra.wini.volid1 << 8) | 
                   (bblock->BOOT_extra.wini.volid2 << 16) | (bblock->BOOT_extra.wini.volid3 << 24));
d377 1
a377 1
    tracef0("DOSFS: testfor160360k: not 320K or 160K format 8 sectors per track\n");
d420 1
a420 1
 tracef1("DOSFS: validatedosformat: treating as a %s disc\n",floppy ? "floppy" : "fixed");
d424 1
a424 1
    tracef0("DOSFS: validatedosformat: floppy fails even basic DOS parameters\n");
d432 1
a432 1
    tracef0("DOSFS: validatedosformat: failed to get memory\n");
d475 1
a475 1
 tracef1("DOSFS: validatedosformat: reading sector from &%08X\n",dr->dr_rootSIN);
d480 1
a480 1
    tracef0("DOSFS: validatedosformat: failed to read 0th sector\n");
d484 1
a484 1
 tracef0("DOSFS: validatedosformat: sector read OK\n");
d498 1
a498 1
          tracef0("DOSFS: validatedosformat: shame,not a DOS disc\n");
d511 1
a511 1
 tracef0("DOSFS: validatedosformat: reading FAT\n");
d569 1
a569 1
    tracef0("DOSFS: validatedosformat: don't know the magic number by any method\n");
d575 2
a576 2
 tracef1("DOSFS: validatedosformat: accepted disc type &%02X\n",magic);
 tracef1("DOSFS: validatedosformat: cycleID was 0x%x\n", discID);
d616 1
a616 1
           tracef0("DOSFS: validatedosformat: volume label found\n") ;
d619 14
d637 1
a637 1
           tracef1("DOSFS: validatedosformat: volume \"%s\"\n",(char *)dr->dr_discname) ;
d672 1
a672 1
    tracef1("DOSFS: validatedosformat: format name = \"%s\"\n", buf);
d718 1
a718 1
   tracef1("Findex = %d\n", findex);
d811 2
a812 2
      put_FILE_time(dentry,RISCOStoTIME(&formTIME)) ;
      put_FILE_date(dentry,RISCOStoDATE(&formTIME)) ;
d866 1
a866 1
             tracef1("DOSFS: return unknown SWI (%d) error\n",swi_no) ;
d886 1
a886 1
                 tracef0("DOSFS: Service_Memory (0x11): matched\n") ;
d896 1
a896 1
               tracef0("DOSFS: Service_Reset: called\n") ;
d907 4
a910 4
               tracef0("DOSFS: Service_WimpSaveDesktop: called\n") ;
               tracef1("DOSFS: WimpSaveDesktop: r0 = &%08X\n",rset->r[0]) ;
               tracef1("DOSFS: WimpSaveDesktop: r1 = &%08X\n",rset->r[1]) ;
               tracef1("DOSFS: WimpSaveDesktop: r2 = &%08X\n",rset->r[2]) ;
d928 1
a928 1
                    for (loop = 0; (loop < 3); loop++)
d930 1
a930 1
                      char cchr = ((cptr->dosext >> (loop * 8)) & 0xFF) ;
d973 10
a982 10
                tracef1("DOSFS: Service_IdentifyDisc: log2secsize(dr) = %d\n",log2secsize(dr)) ;
                tracef1("DOSFS: Service_IdentifyDisc: secspertrk(dr) = %d\n",secspertrk(dr)) ;
                tracef1("DOSFS: Service_IdentifyDisc: heads(dr) = %d\n",heads(dr));
                tracef1("DOSFS: Service_IdentifyDisc: dr->dr_floppy_density = %d\n",dr->dr_floppy_density) ;
                tracef1("DOSFS: Service_IdentifyDisc: discsize(dr) = &%X\n",discsize(dr));
                tracef1("DOSFS: Service_IdentifyDisc: doublestep(dr) = %d\n",doublestep(dr));
                tracef1("DOSFS: Service_IdentifyDisc: sequence(dr) = %d\n",sequence(dr));
                tracef1("DOSFS: Service_IdentifyDisc: tracklow(dr) = %d\n",tracklow(dr)) ;
                tracef1("DOSFS: Service_IdentifyDisc: trackskew(dr) = %d\n",trackskew(dr)) ;
                tracef1("DOSFS: Service_IdentifyDisc: dr->dr_drive = &%08X\n",dr->dr_drive);
d985 1
a985 1
                tracef1("DOSFS: Service_IdentifyDisc: exit with r1 = &%X\n",rset->r[1]);
d998 1
a998 1
                tracef0("DOSFS: Service_EnumerateFormats: called\n") ;
d1075 1
a1075 1
                tracef1("DOSFS: Service_IdentifyFormat: r0 = \"%s\"\n",(char *)(rset->r[0])) ;
d1087 1
a1087 1
                  tracef1("DOSFS: Service_IdentifyFormat: %s\n",DOS_formats[loop].idtext) ;
d1109 1
a1109 1
               tracef0("DOSFS: Service_FormatHelp: called\n") ;
d1164 1
a1164 1
              word        dosext = 0x00000000 ; /* DOS extension */
d1171 1
a1171 1
              tracef0("fs_command: DOSMap\n") ;
d1222 1
a1222 1
                    for (loop = 0; (loop < 3); loop++)
d1224 1
a1224 1
                      char cchr = ((cptr->dosext >> (loop * 8)) & 0xFF) ;
d1258 1
a1258 1
                   dosext = (dosext | (c << (loop * 8))) ;
d1277 1
a1277 1
                       if (dosext == cptr->dosext)
d1279 1
a1279 1
                         tracef0("DOSMap: entry found\n") ;
d1324 1
a1324 1
                         if (dosext == cptr->dosext)
d1326 1
a1326 1
                           tracef2("DOSMap: resetting &%08X to &%03X\n",dosext,ROtype);
d1339 1
a1339 1
                            tracef2("DOSMap: newmapping &%08X to &%03X\n",dosext,ROtype) ;
d1341 1
a1341 1
                            newmapping->dosext = dosext ;
d1365 1
a1365 1
              tracef0("fs_command: CopyBoot\n") ;
d1392 1
a1392 1
                  tracef2("CopyBoot: src %d dest %d\n",srcdrive,destdrive) ;
d1416 1
a1416 1
                      tracef0("CMD_CopyBoot: failed to open source image\n") ;
d1438 19
a1456 19
                        tracef1("CMD_CopyBoot: source secsize = %d\n", (srcblock->BOOT_secsizeHI << 8)
                                | srcblock->BOOT_secsize);
                        tracef1("CMD_CopyBoot: source secalloc = %d\n", srcblock->BOOT_secalloc);
                        tracef1("CMD_CopyBoot: source reserved = %d\n", (srcblock->BOOT_reservedHI << 8)
                                | srcblock->BOOT_reserved);
                        tracef1("CMD_CopyBoot: source num_fats = %d\n", srcblock->BOOT_num_fats);
                        tracef1("CMD_CopyBoot: source root size = %d\n", (srcblock->BOOT_root_dirHI << 8)
                                | srcblock->BOOT_root_dir);
                        tracef1("CMD_CopyBoot: source max_sect = %d\n", (srcblock->BOOT_max_sectHI << 8)
                                | srcblock->BOOT_max_sect);
                        tracef1("CMD_CopyBoot: source magic = &%02X\n", srcblock->BOOT_magic);
                        tracef1("CMD_CopyBoot: source FAT_size = %d\n", (srcblock->BOOT_FAT_sizeHI << 8)
                                | srcblock->BOOT_FAT_size);
                        tracef1("CMD_CopyBoot: source secstrack = %d\n", (srcblock->BOOT_secstrackHI << 8)
                                | srcblock->BOOT_secstrack);
                        tracef1("CMD_CopyBoot: source heads = %d\n", (srcblock->BOOT_headsHI << 8)
                                | srcblock->BOOT_heads);
                        tracef1("CMD_CopyBoot: source hidden = %d\n", (srcblock->BOOT_extra.floppy.hiddenHI << 8)
                                | srcblock->BOOT_extra.floppy.hidden);
d1483 1
a1483 1
                             tracef0("CMD_CopyBoot: Escape\n") ;
d1506 1
a1506 1
                              tracef0("CMD_CopyBoot: failed to open dest image\n") ;
d1536 1
a1536 1
                                   destblock->BOOT_extra.floppy.code[loop] = srcblock->BOOT_extra.floppy.code[loop] ;
d1582 1
a1582 1
 tracef0("DOSFS: shutdown_fs called\n") ;
d1614 6
a1619 1
 tracef0("DOSFS: init_fs: entered\n") ;
d1621 1
d1625 1
a1625 1
  tracef2("DOSFS: init_fs: &%08X \"%s\"\n",syserr->errnum,syserr->errmess) ;
d1628 1
a1628 1
  tracef0("DOSFS: init_fs: failed to add shutdown function\n") ;
d1649 1
a1649 1
 tracef0("DOSFS: init_fs: exiting\n") ;
@


4.12
log
@Change to the policy of loading the FAT inside Service_Identify disc.
Now,for fixed discs,we read uncached as much as possible into as big a
lump of RMA as possible.
Reduced mounting a 128M flash keyring from 21s to 1.5s!

Version 0.77. Tagged as 'DOSFS-0_77'
@
text
@d204 2
a205 1
                      int *numFATs,int *FATsize,int *magic,int *ROOTsize,int *Atari,int *dblstep,int *numRESVD)
d254 6
d273 2
a274 1
                            int *numFATs,int *FATsize,int *magic,int *ROOTsize,int *Atari,int *dblstep,int *numRESVD)
d347 6
d367 2
a368 1
                          int *numFATs,int *FATsize,int *magic,int *ROOTsize,int *Atari,int *dblstep,int *numRESVD)
d415 1
a415 1
 word  winioffset = 0;
d485 2
a486 1
 if (testforbpb(dr,sector,floppy,&numFATs,&FATsize,&magic,&ROOTsize,&Atari,&dblstep,&numRESVD))
d489 2
a490 1
    if (!floppy || testfor160360k(dr,sector,floppy,&numFATs,&FATsize,&magic,&ROOTsize,&Atari,&dblstep,&numRESVD))
d493 2
a494 1
       if (floppy || testforpartition(dr,sector,rset,&winioffset,&numFATs,&FATsize,&magic,&ROOTsize,&Atari,&dblstep,&numRESVD))
d587 3
@


4.11
log
@For non floppies passed to Service_IdentifyDisc the disc record is
updated to the correct number of sectors per track.This was causing
exceptionally slow backups from the filer as it dribbled one sector
at a time.

Version 0.76. Tagged as 'DOSFS-0_76'
@
text
@d390 1
a390 1
 char *sector;
d402 1
a402 1
 int   loop, index;
d447 2
a448 2
    urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
    urset.r[2] = dr->dr_rootSIN & 0xE0000000 ;      /* disc address */
d493 12
a504 1
 for (index = 0; index < FATsize; index += DOSsecsize)
d507 1
a507 1
     urset.r[4] = DOSsecsize ;
d512 1
a512 1
        urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
d517 1
a517 1
        /* rely on r1 and r2 being preserved,and the drive number in the block */
d520 1
d526 1
a526 1
        if ((*sector == 0xFE) && (magic==0))
d533 1
a533 1
        if ((*sector == 0xFF) && (magic==0))
d542 2
a543 2
     for (loop = 0; loop < DOSsecsize; loop++)
     discID += sector[loop] ;
d545 1
a545 1
 
d553 1
a553 1

d577 1
a577 1
        urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
d1604 1
a1604 1
 r.r[1] = (int)"FileCore_DiscOp64\0";
@


4.10
log
@Fix to cycle ID calculation inside Service_IdentifyDisc,this was
causing lots of "Ambiguous disc name"s

Version 0.75. Tagged as 'DOSFS-0_75'
@
text
@d255 1
d341 1
d343 1
a343 1

d348 1
a348 1
 
d374 1
@


4.9
log
@Rewrote Service_IdentifyDisc partly because it was an unreadable mess but
mainly so it can handle fixed discs too - this will be useful for DOS
format USB mass storage.
Also it will have a go at interpreting the partition table on fixed discs.
Tweak to filetyping logic (again!).

Version 0.74. Tagged as 'DOSFS-0_74'
@
text
@d526 3
d530 1
a530 1

a538 4
 /* We're certain it's a DOS disc so calculate a disc ID from the FAT contents */
 for (loop = 0; loop < DOSsecsize; loop++)
     discID += sector[loop] ;

d542 1
@


4.8
log
@Made sure on return from global_error the V bit gets set,fixes bug in
finding the free space on a floppy (since freespace64 is tried first but
which led to the pointer to the error message being returned as the
freespace rather than the caller trying again another way).
Correction to missing \ in the makefile,meant you could only compile
it once having checked it out.
Fixed a pointer in the DiscOp64 support added,this caused DOSFS to go
pop when you asked it to vet a format.

Version 0.71. Tagged as 'DOSFS-0_71'
@
text
@d23 1
d46 1
a46 3
#if 1 /* SMC_FIX_RO_5593 */
  #include "h.MsgTrans"
#endif
d203 430
d634 3
a636 3
/* NOTE: This code currently only deals with floppy structures             */
/* Updated to support PCMCIA (arbitrary sector-multiple size structures)   */
/* by WT, 27-May-94 - note the addition of r4 as a parameter               */
d653 1
d658 1
d920 1
a920 1
                ADFS_drecord    *dr = (ADFS_drecord *)rset->r[5] ;
a921 4
                /* Check the sector size and lowest numbered sector for DOS format */
                /* NOTE: If any of the above fields are zero then we are probably on a hard disc, so ignore
                 *       the fields and continue.
                 */
d933 2
a934 309
                if ((log2secsize(dr) == log2DOSsecsize || log2secsize(dr) == 0)
                    && tracklow(dr) == 1 && trackskew(dr) == 0)
                 {
                  char             *sector = (char *)malloc(DOSsecsize) ;

                  if (sector != NULL)
                   {
                    _kernel_swi_regs  urset ;
                    _kernel_oserror  *rerror = NULL ;
                    DOS_bootsector   *bblock = (DOS_bootsector *)sector;
                    FS_discop64      opblock;
                    int claimed = 0;
                    int discSize, noSides, dblstep, numFATs, FATsize, numRESVD, ROOTsize, magic;
                    int discID = 0;
                    int Atari = 0;
                    int index;

                    /* Sector 1, track 0 should always be readable regardless of the specific DOS format */
                    /* Use FileCore_DiscOp 9 (option bits 2_01x0) and the alternative disc record we have */
                    /* FileCore_DiscOp{64}
                     *      in:     r1 = bits0-3    reason code 9
                     *                   bits4-7    option bits
                     *                   bits8-31   bits2-25 of pointer to alternative disc record
                     *                  {bits 8-31 reserved}
                     *              r2 = disc address {pointer to block containing the 64 bit disc address}
                     *              r3 = pointer to buffer
                     *              r4 = length (bytes)
                     *             {r5 = address of alternate disc record}
                     *              r6 = sector cache handle
                     *              r8 = pointer to FileCore instance private word
                     *      out:    r1 = preserved
                     *              r2 = disc address of next byte to be transferred
                     *              r3 = pointer to next buffer location to be transferred
                     *              r4 = number of bytes NOT transferred
                     *              r6 = new sector cache handle
                     *              r8 = preserved
                     */

                    urset.r[3] = (word)bblock ;                        /* BOOT block buffer */
                    urset.r[4] = sizeof(DOS_bootsector) ;              /* size of the buffer */
                    urset.r[6] = rset->r[6] ;                          /* entry sector cache handle */
                    urset.r[8] = rset->r[8] ;                          /* entry FileCore private word pointer */
                    if (discopswi==FileCore_DiscOp)
                       {
                       urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
                       urset.r[2] = dr->dr_rootSIN & 0xE0000000 ;      /* disc address */
                       }
                    else
                       {
                       opblock.drivenumber   = (dr->dr_rootSIN & 0xE0000000) >> 29;
                       opblock.byteaddresslo = 0;
                       opblock.byteaddresshi = 0;
                       urset.r[1] = (9 | (4 << 4));
                       urset.r[2] = (int)&opblock;
                       urset.r[5] = (int)dr;
                       }
                    tracef1("DOSFS: Service_IdentifyDisc: reading sector from &%08X\n",urset.r[2]);
                    if ((rerror = _kernel_swi(discopswi,&urset,&urset)) == NULL)
                     {
                      tracef0("DOSFS: Service_IdentifyDisc: sector read\n");
                      /* Can only make sketchy test for a valid boot block, later test should fail
                       * if the boot block is not valid.
                       */
#ifdef PCMCIATRUE
                      if (sector_size(bblock) == DOSsecsize)
#else
                      if (sector_size(bblock) == DOSsecsize || bblock->BOOT_num_fats == 2)
#endif
                       {
                        /* Get number of sectors and number of sectors per track from BOOT block. */
                        int bbsize = DOSFS_max_sect(bblock);
                        int notracks = (bblock->BOOT_secstrackHI << 8) | bblock->BOOT_secstrack;

                        if (notracks > 0) {
                          notracks = bbsize / notracks; /* Calculate number of tracks from BOOT block. */
                          bbsize = bbsize * DOSsecsize; /* Calculate disc size from BOOT block. */

                          /* Calculate disc size to using disc record info. */
                          discSize = (secspertrk(dr) * bytespersec(dr) * notracks) ;

                          tracef1("DOSFS: Service_IdentifyDisc: discSize = &%08X\n",discSize) ;
                          tracef1("DOSFS: Service_IdentifyDisc: check size = &%08X\n",bbsize) ;

#ifdef PCMCIATRUE
                          /* Now have to cope with PCMCIA cards with bits of first track "missing" */
                          if ((bbsize < (discSize + (secspertrk(dr)*bytespersec(dr)))) && (bbsize >= discSize))
#else
                          /* validation : (bbsize == discSize) */
                          if (bbsize == discSize)
#endif
                           {
                            noSides = bblock->BOOT_heads;
                            if (noSides > 0)
                             {
                              /* It's a DOS disc so claim it as one of ours and set up the disc record info. */
                              magic = bblock->BOOT_magic;
                              numFATs = bblock->BOOT_num_fats;
                              FATsize = (bblock->BOOT_FAT_size | (bblock->BOOT_FAT_sizeHI << 8)) * DOSsecsize;
                              numRESVD = (bblock->BOOT_reserved | (bblock->BOOT_reservedHI << 8)) ;
                              ROOTsize = ((bblock->BOOT_root_dir | (bblock->BOOT_root_dirHI << 8)) * sizeof(DOS_direntry)) ;
                              /* If this is an Atari disc then it has no jmp instruction. */
                              Atari = (bblock->BOOT_JMP[0] == 0);
                              dblstep = ((notracks / noSides) == 40);
                              discsize(dr) = discSize;
                              heads(dr) = noSides;
                              claimed = 1;
                             }
                            else
                             {
                              tracef0("DOSFS: Service_IdentifyDisc: Invalid boot block, BOOT_heads = 0\n");
                             }
                           }
                          else
                           {
                            tracef0("DOSFS: Service_IdentifyDisc: FileCore and BOOT BLOCK disc sizes differ\n") ;
                           }
                         }
                        else
                         {
                          tracef0("DOSFS: Service_IdentifyDisc: Invalid boot block, BOOT_secstrack = 0\n");
                         }
                       }
                      else
                       {
                        tracef0("DOSFS: Service_IdentifyDisc: Invalid boot block (could be 320K or 160K)\n");
                       }
                     }
                    else
                     {
                      tracef2("DOSFS: Service_IdentifyDisc: &%08X \"%s\"\n",rerror->errnum,rerror->errmess) ;
                     }

                    /* If we have not claimed the disc then it could still be valid only if it is a 320K or
                     * 160K format, both of which have 8 sectors per track (these old formats need not have a
                     * valid boot block).
                     */
                    if (!claimed) {
                     if (secspertrk(dr) != 8) {
                      tracef0("DOSFS: Service_IdentifyDisc: invalid boot block and not 320K or 160K format\n");
                      free(sector);
                      break;    /* break switch */
                     }
                     /* Defaults for 320K and 160K formats. */
                     dblstep = 1;
                     numFATs = 2;
                     FATsize = DOSsecsize;
                     numRESVD = 1;
                     /* ROOTsize could be 112 or 64 (* sizeof(DOS_direntry)). */
                     /* noSides could be 1 or 2. */
                    }
                    put_doublestep(dr, dblstep);
                    put_sequence(dr, 0);

                    /* Read the FAT.  This will be used to identify a 320K or 160K format if necessary and
                     * also to calculate a disc ID to pass back to FileCore.
                     */
                    tracef0("DOSFS: Service_IdentifyDisc: reading FAT\n");
                    for (index = 0; index < FATsize; index += DOSsecsize) {

                    urset.r[3] = (word)sector ;
                    urset.r[4] = DOSsecsize ;
                    /* sector cache handle and FileCore private word pointer preserved from above call */

                    if (discopswi==FileCore_DiscOp)
                       {
                       urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
                       urset.r[2] = (index + DOSsecsize) | (dr->dr_rootSIN & 0xE0000000); /* disc address */                                       }
                    else
                       {
                       /* rely on r1 and r2 being preserved,and the drive number in the block */
                       opblock.byteaddresslo = index + DOSsecsize;
                       opblock.byteaddresshi = 0;
                       urset.r[5] = (int)dr;
                       }
                     if ((rerror = _kernel_swi(discopswi,&urset,&urset)) == NULL) {
                      if (!claimed) {
                       /* Check the first byte of the FAT for the 320K or 160K media type. */
                       magic = *sector;
                       if (magic == 0xFE) {
                        claimed = 1;
                        ROOTsize = 64 * sizeof(DOS_direntry);
                        noSides = 1;
                        discSize = 0x28000;
                       } else if (magic == 0xFF) {
                        claimed = 1;
                        ROOTsize = 112 * sizeof(DOS_direntry);
                        noSides = 2;
                        discSize = 0x50000;
                       }
                       discsize(dr) = discSize;
                       heads(dr) = noSides;
                      }

                      /* If this is a DOS disc then calculate a disc ID from the FAT contents. */
                      if (claimed) {
                       int loop;
                       for (loop = 0; loop < DOSsecsize; loop++)
                        discID += sector[loop] ;
                      } else
                       break;
                     } else {
                      tracef1("DOSFS: Service_IdentifyDisc: %s\n",rerror->errmess);
                      break;
                     }
                    }

                    if (claimed) {
                     /* The disc is definitely DOS so we can claim the service and fill in the disc record. */
                     /* Get the default disc name from the Messages file. */
                     char *buf = 0;
                     int bufsz = 0;

                     tracef1("DOSFS: Service_IdentifyDisc: accepted disc type &%02X\n",magic);

                     /* Lookup default disc name. */
                     if ((rerror = msgtrans_lookup("DEFDNM", &buf, &bufsz, 0, 0, 0, 0)) != NULL) {
                      buf = rerror->errmess;
                      bufsz = strlen(buf);
                     }
                     if (bufsz > 9)
                      bufsz = 9;
                     strncpy((char *)(dr->dr_discname), buf, bufsz);
                     dr->dr_discname[bufsz] = '\0';

                     /* Try to find a volume label on the disc. */
                     for (index = 0; index < ROOTsize; index += DOSsecsize) {
                     urset.r[3] = (word)sector ;
                     urset.r[4] = DOSsecsize ;
                     if (discopswi==FileCore_DiscOp)
                        {
                        /* sector cache handle and FileCore private word pointer preserved from above call */
                        urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
                        urset.r[2] = ((numFATs * FATsize) + index + DOSsecsize) | (dr->dr_rootSIN & 0xE0000000) ; /* disc address */
                        }
                     else
                        {
                        /* rely on r1 and r2 being preserved,and the drive number in the block*/
                        opblock.byteaddresslo = (numFATs * FATsize) + index + DOSsecsize;
                        opblock.byteaddresshi = 0;
                        urset.r[5] = (int)dr;
                        }

                      if ((rerror = _kernel_swi(discopswi,&urset,&urset)) == NULL) {
                       int i = 0;
                       DOS_direntry *dentry;

                       if ((dentry = findDIRtype((byte)FILE_win95,(byte)FILE_volume,(DOS_direntry *)sector,DOSsecsize,&i)) != NULL) {
                        tracef0("DOSFS: Service_IdentifyDisc: volume label found\n") ;
                        memmove((void *)&(dr->dr_discname[0]),(void *)&(dentry->FILE_status),(discnamesize - 1)) ;

                        /* Replace invalid characters in disc name */
                        {
                        byte *name;
                        for (name=dr->dr_discname; *name; name++)
                            {
                            *name=mapchar(*name,DOSmapping,ROmapping);
                            }
                        }
                        tracef1("DOSFS: Service_IdentifyDisc: volume \"%s\"\n",(char *)dr->dr_discname) ;
                        break;
                       }
                      }
                     }
#ifndef PRE218
                     /* Write format name into buffer. */
                     if (rset->r[2] != 0) {
                      char token[8];
                      for (index = 0; DOS_formats[index].magic_ID != 0; index++)
                       if (magic == DOS_formats[index].magic_ID)
                          {
                          /* If type is &F9 then we need more tests. */
                          if (magic == 0xF9)
                             {
                             if (Atari && strcmp(DOS_formats[index].idtext, "Atari/M"))
                                continue;
                             if (FATsize != DOS_formats[index].secsFAT * DOSsecsize)
                                continue;
                             }
                          break;
                          }
                      sprintf(token, FORMAT_FMT, index + 1);
                      buf = (char *)rset->r[2];
                      bufsz = rset->r[3];
                      if ((rerror = msgtrans_lookup(token, &buf, &bufsz, 0, 0, 0, 0)) != NULL)
                         {
                         bufsz = strlen(rerror->errmess);
                         strncpy(buf, rerror->errmess, bufsz);
                         }
                      buf[bufsz] = '\0';
                      tracef1("Service_IdentifyDisc: format name = \"%s\"\n", buf);
                     }
#endif
                     /* Claim the service and fill in the disc record. */
                     rset->r[1] = 0x00 ;         /* Service_Serviced (claimed) */
                     put_discID(dr, discID);
                     tracef3("DOSFS: Service_IdentifyDisc: heads = %d, dblstep = %d, discID = &%04X\n",
                             noSides, dblstep, discID);
                     rset->r[2] = imagetype ;    /* filetype to be associated with the disc image */
                     rset->r[6] = urset.r[6] ;   /* sector cache handle returned from "FileCore_DiscOp" */
                    } else {
                     tracef0("DOSFS: Service_IdentifyDisc: not a DOS disc\n");
                    }
                    free(sector);
                   }
                  else
                   {
                    tracef0("DOSFS: Service_IdentifyDisc: failed to malloc sector buffer\n") ;
                   }
                 }
a1204 1
#if 1 /* SMC_FIX_RO_8015 */
a1207 4
#else
                  if (validchar(valchars,argv[loop]))
                   dosext = (dosext | (toupper(argv[loop]) << (loop * 8))) ;
#endif
a1547 1
#if 1 /* SMC_FIX_RO_5593 */
a1549 1
#endif
@


4.7
log
@Missed an ORRNES while 32 bitting,corrected.
Unused MSDOStoSTRING #if'd out to save a massive 112 bytes!
Corrected tracef1 in map_file_rostype which was printing out the
debugging before the variable got assigned.
Conditionally uses FileCore_DiscOp64 now,if available when the module
starts.
Eliminated some local 64 bit time handling code in favour of using that
already in the compiler (thanks to Kevin).
Now requires a compile time switch PCMCIA=<TRUE | FALSE> which leaves in
or takes out the PCMCIA card support.

Version 0.70. Tagged as 'DOSFS-0_70'
@
text
@d516 1
a516 1
                    FS_discop64      *opblock;
d525 1
a525 1
                    /* FileCore_DiscOp
d529 2
a530 1
                     *              r2 = disc address
d533 1
d555 3
a557 3
                       opblock->drivenumber   = (dr->dr_rootSIN & 0xE0000000) >> 29;
                       opblock->byteaddresslo = 0;
                       opblock->byteaddresshi = 0;
d559 1
a559 1
                       urset.r[2] = (int)opblock;
d676 2
a677 2
                       opblock->byteaddresslo = index + DOSsecsize;
                       opblock->byteaddresshi = 0;
d736 1
a736 1
                        /* sector cache handle and FileCore private word pointer preserved from above call */                        
d743 2
a744 2
                        opblock->byteaddresslo = (numFATs * FATsize) + index + DOSsecsize;
                        opblock->byteaddresshi = 0;
@


4.6
log
@Deleted some dead variables and switches.
Eliminated MOVS and R14 fiddling to achieve 32 bit compatibility
RISCOS Ltd made 3 changes in their sources
 - ensure disc titles don't contain rogue characters (added)
 - files with time,date,and reserved fields of zero appears as DEADDEAD
   which is silly since Winodws uses this to mark a file unstamped which
   isn't quite the same thing! (not added)
 - syslog debugging support (not added)

Version 0.69. Tagged as 'DOSFS-0_69'
@
text
@d48 1
a48 3
#if 1 /* SMC_REDUCE_RMA */
  #include "h.Statics"
#endif
d57 3
a59 1
mapentry *maplist = NULL ;      /* DOS/RISC OS filetype mapping chain */
d61 1
a61 1
int module_flags = 0 ;          /* Global flags */
a75 93
/*-------------------------------------------------------------------------*/

FILEhand *FILE_list = NULL ;  /* open file handle list */

#if 0 /* SMC_REDUCE_RMA */
/***************************************************************************/
/* The following arrays are now defined in s.Statics                       */
/***************************************************************************/
/*-------------------------------------------------------------------------*/
/* DOS logical disc types: */

/* This information used by "DiscFormat" */
/* Table describes PHYSICAL formats supported */
format_spec DOS_formatinfo[] = {
#if 1 /* SMC_NEW_FORMATS */
/* -- MSDOS Q 1.44M double sided, 80 tracks, 18 sectors */
  {DOSsecsize,50,50,22,18,Hdensity,               (o_indexmark | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- MSDOS/Atari M 720K double sided, 80 tracks, 9 sectors */
  {DOSsecsize,50,50,22, 9,Ddensity,               (o_indexmark | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- MSDOS H 1.2M double sided, 80 tracks, 15 sectors */
  {DOSsecsize,50,50,22,15,Hdensity,               (o_indexmark | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- MSDOS N 360K double sided, 40 tracks, 9 sectors */
  {DOSsecsize,50,50,22, 9,Ddensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- MSDOS P 180K single sided, 40 tracks, 9 sectors */
  {DOSsecsize,50,50,22, 9,Ddensity,(o_indexmark | o_doublestep | o_side1only),1,1,0,0,0x4E, 40,0,0,0,0,0,0,0,0,0},
/* -- MSDOS T 320K double sided, 40 tracks, 8 sectors */
  {DOSsecsize,50,50,22, 8,Ddensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- MSDOS U 160K single sided, 40 tracks, 8 sectors */
  {DOSsecsize,50,50,22, 8,Ddensity,(o_indexmark | o_doublestep | o_side1only),1,1,0,0,0x4E, 40,0,0,0,0,0,0,0,0,0},
/* -- Atari N 360K single sided, 80 tracks, 9 sectors */
  {DOSsecsize,50,50,22, 9,Ddensity,               (o_indexmark | o_side1only),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- Terminator */
  {         0, 0, 0, 0, 0,       0,                                         0,0,0,0,0,0x00,  0,0,0,0,0,0,0,0,0,0}
#else
/* -- single sided 80track/9sectors MS-DOS and Atari -- */
{DOSsecsize,50,50,22, 9,Ddensity,               (o_indexmark | o_side1only),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- double sided 80track/9sectors MS-DOS and Atari -- */
{DOSsecsize,50,50,22, 9,Ddensity,               (o_indexmark | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- single sided 40track/9sectors MS-DOS -- */
{DOSsecsize,50,50,22, 9,Ddensity,(o_indexmark | o_doublestep | o_side1only),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- double sided 40track/9sectors MS-DOS -- */
{DOSsecsize,50,50,22, 9,Ddensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- single sided 40track/8sectors MS-DOS -- */
{DOSsecsize,50,50,22, 8,Ddensity,(o_indexmark | o_doublestep | o_side1only),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- double sided 40track/8sectors MS-DOS -- */
{DOSsecsize,50,50,22, 8,Ddensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- double sided 80track/18sectors MS-DOS -- */
{DOSsecsize,50,50,22,18,Hdensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- structure terminator -- */
{         0, 0, 0, 0,0,     0,                                            0,0,0,0,0,0x00, 0,0,0,0,0,0,0,0,0,0},
#endif
                            } ;

/* we need a mapping of MAGIC numbers to physical formats */
/* This is nasty since we use ABSOLUTE indices into the above table */
#if 1 /* SMC_FIX_RO_5593 */
DOSdiscinfo DOS_formats[] = {
#if 1 /* SMC_NEW_FORMATS */
             {0xF0, 1, 0, "DOS/Q", "FMT1", "FMTH1"},
             {0xF9, 1, 1, "DOS/M", "FMT2", "FMTH2"},
             {0xF9, 1, 2, "DOS/H", "FMT3", "FMTH3"},
             {0xFD, 1, 3, "DOS/N", "FMT4", "FMTH4"},
             {0xFC, 0, 4, "DOS/P", "FMT5", "FMTH5"},
             {0xFF, 0, 5, "DOS/T", "FMT6", "FMTH6"},
             {0xFE, 0, 6, "DOS/U", "FMT7", "FMTH7"},
             {0xF9, 1, 1, "Atari/M", "FMT8", "FMTH8"},
             {0xF8, 1, 7, "Atari/N", "FMT9", "FMTH9"},
             {0x00, 0, 0, NULL, NULL, NULL}
#else
             {0xFB, 0, "N", "FMT1", "FMTH1"},
             {0xF8, 0, "B", "FMT2", "FMTH2"},
             {0xF9, 1, "M", "FMT3", "FMTH3"},
             {0xF9, 1, "A", "FMT4", "FMTH4"},
             {0xF0, 6, "Q", "FMT5", "FMTH5"},
             {0x00, 0, NULL, NULL, NULL},
#endif
                            } ;
#else
DOSdiscinfo DOS_formats[] = {
             {0xFB,0,"N"," 360K, MS-DOS 3.20 upwards (SS)"},
             {0xF8,0,"B"," 360K, Atari (SS)"},
             {0xF9,1,"M"," 720K, MS-DOS 3.20 upwards (DS)"},
             {0xF9,1,"A"," 720K, Atari (DS)"}, /* same physical format as above */
             {0xF0,6,"Q","1440K, MS-DOS 3.20 upwards (DS)"},
             {0xFC,2,  0," 180K, MS-DOS (SS)"},
             {0xFD,3,  0," 360K, MS-DOS (DS)"},
             {0xFE,4,  0," 160K, MS-DOS (SS)"},
             {0xFF,5,  0," 320K, MS-DOS (DS)"},
             {0x00,  0,NULL},
                            } ;
#endif

#else /* SMC_REDUCE_RMA */
a80 1
#endif /* SMC_REDUCE_RMA */
d207 1
a207 2
/* by WT, 27-5-94    */
/* note the addition of r4 as a parameter */
d215 1
a215 1
  *      r4 = size of partiton if r0 = pcmcia
d224 1
a224 1
 if(((rset->r[4] % DOSsecsize) != 0) && (rset->r[0] == 9)) { /* Should be a multiple of sectors big for pcmcia*/
d259 1
a259 1
#if 1 /* PCMCIA */
d514 1
a514 1
                    _kernel_oserror *rerror = NULL ;
d516 1
a541 2
                    urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
                    urset.r[2] = dr->dr_rootSIN & 0xE0000000 ;         /* disc address */
d546 14
d561 1
a561 1
                    if ((rerror = _kernel_swi(FileCore_DiscOp,&urset,&urset)) == NULL)
d567 1
a567 1
#if 1 /* PCMCIA */
d587 1
a587 1
#if 1 /* PCMCIA */
a661 5
                     urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
                     urset.r[2] = (index + DOSsecsize) | (dr->dr_rootSIN & 0xE0000000); /* disc address */
                     urset.r[3] = (word)sector ;
                     urset.r[4] = DOSsecsize ;
                     /* sector cache handle and FileCore private word pointer preserved from above call */
d663 16
a678 1
                     if ((rerror = _kernel_swi(FileCore_DiscOp,&urset,&urset)) == NULL) {
d730 15
a744 5
                      urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
                      urset.r[2] = ((numFATs * FATsize) + index + DOSsecsize) | (dr->dr_rootSIN & 0xE0000000) ; /* disc address */
                      urset.r[3] = (word)sector ;
                      urset.r[4] = DOSsecsize ;
                      /* sector cache handle and FileCore private word pointer preserved from above call */
d746 1
a746 1
                      if ((rerror = _kernel_swi(FileCore_DiscOp,&urset,&urset)) == NULL) {
d772 12
a783 10
                       if (magic == DOS_formats[index].magic_ID) {
                        /* If type is &F9 then we need more tests. */
                        if (magic == 0xF9) {
                         if (Atari && strcmp(DOS_formats[index].idtext, "Atari/M"))
                          continue;
                         if (FATsize != DOS_formats[index].secsFAT * DOSsecsize)
                          continue;
                        }
                        break;
                       }
d787 5
a791 4
                      if ((rerror = msgtrans_lookup(token, &buf, &bufsz, 0, 0, 0, 0)) != NULL) {
                       bufsz = strlen(rerror->errmess);
                       strncpy(buf, rerror->errmess, bufsz);
                      }
d938 1
a938 1
                int               loop ;
a943 1
#if 1 /* SMC_FIX_RO_5593 */
a946 1
#endif
a947 1
#if 1 /* SMC_FIX_RO_5593 */
d950 5
a954 4
                   if ((rerror = msgtrans_lookup(token, &buf, &bufsz, 0, 0, 0, 0)) != NULL) {
                    buf = rerror->errmess;
                    bufsz = strlen(rerror->errmess);
                   }
a957 18
#else
                   /* nasty way of doing this, but let's get it working first */
                   /* (since printf may be re-directed, etc.) */
                   urset.r[0] = (word)DOS_formats[loop].idtext ;
                   rerror = _kernel_swi(OS_Write0,&urset,&urset) ;

                   if (rerror == NULL)
                    {
                     urset.r[0] = (word)" - " ;
                     rerror = _kernel_swi(OS_Write0,&urset,&urset) ;
                    }

                   if (rerror == NULL)
                    {
                     urset.r[0] = (word)DOS_formats[loop].description ;
                     rerror = _kernel_swi(OS_Write0,&urset,&urset) ;
                    }
#endif
d1474 3
@


4.5
log
@Jump instruction in the boot sector of Atari discs now correct.
Dates on machines not running Win95FS no longer stuck at 1900 (got
broken in 0.67 by a missing && somewhere).

Version 0.68. Tagged as 'DOSFS-0_68'
@
text
@d17 1
a17 1
/* DOSFS (MultiFS support module)               Copyright (c) 1990 JGSmith */
a26 1
#if 1 /* SMC_FIX */
a28 1
#endif
d206 1
a206 1
 /* register our module as a MultiFS filing system support */
d815 9
a823 3
#if 0 /* SMC 03-08-94: This terminates past the discname space (currently unused so was OK but no need to do it anyway). */
                        dr->dr_discname[discnamesize - 1] = nul ; /* ensure terminating NUL */
#endif
a1314 1
#if 1 /* SMC_FIX */
a1315 3
#else
                    char                 tmpstr[4] ; /* temporary "short" string */
#endif
a1318 1
#if 1 /* SMC_FIX */
a1319 3
#else
                    sprintf(tmpstr,":%d",srcdrive) ;
#endif
a1342 1
#if 1 /* SMC_FIX */
a1345 4
#else
                      _kernel_osfind(0x40,(char *)fhand) ;
#endif

a1348 11
#if 0 /* SMC_FIX */
                        for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                         if (DOS_formats[loop].magic_ID == srcblock->BOOT_magic)
                          break ;

                        if ((DOS_formats[loop].magic_ID == 0x00) || (bbsize != DOSsecsize))
                         {
                          tracef0("CMD_CopyBoot: logical disc format not recognised\n") ;
                          rerror = global_error(err_badbootblock) ;
                         }
#endif
a1408 1
#if 1 /* SMC_FIX */
a1409 3
#else
                            sprintf(tmpstr,":%d",destdrive) ;
#endif
a1433 11
#if 0 /* SMC_FIX */
                                for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                                 if (DOS_formats[loop].magic_ID == destblock->BOOT_magic)
                                  break ;

                                if ((DOS_formats[loop].magic_ID == 0x00) || (bbsize != DOSsecsize))
                                 {
                                  tracef0("CMD_CopyBoot: logical disc format not recognised\n") ;
                                  rerror = global_error(err_badbootblock) ;
                                 }
#endif
a1459 1
#if 1 /* SMC_FIX */
a1462 3
#else
                              _kernel_osfind(0x40,(char *)fhand) ;
#endif
@


4.4
log
@Unstamped files (marked by DOS with a time and date of 0x0000) will now
return 01-Jan-1900 rather than very late at night on 31-Dec-1979.
Can now set the RISC OS type to 0x000 (previously this would then have been
stamped as 0xFE4 since 0x000 was used as a magic 'no filetype found' marker.
Will now try to use MimeMap if no 'dosmap'ping was found,in this way dosmap
overrides MimeMap for DOSFS - if neither offer a match,0xFE4 is used.
Updated messages to reflect this.
Discs formatted under DOSFS will now set the OEM vendor id to "DOSFS   ".

Version 0.67. Tagged as 'DOSFS-0_67'
@
text
@d370 3
a372 4
     /* Atari formats have no jump instruction in the boot block */
     sprintf((char *)dbsector->BOOT_JMP,"\0\0NNNNNN") ; /* NULL terminated */
     /* Atari formats have a 24bit volume serial number */
     dbsector->BOOT_OEM[5] = (rand() & 0xFF) ;  /* replace NULL */
@


4.3
log
@Will now recognise the disc title of discs containing Win95 long filenames.
Formatting now pads disc titles with spaces rather than NULs.

Version 0.66. Not tagged
@
text
@d56 1
a56 1
#define imagetype (0xFC8) /* as allocated by Acorn : "MSDOSDSC" */
@


4.2
log
@Changed to use srccommit.
Updated for Link 5.07 and CMHG 5.16. Fixed to not overwrite command tail.
Changed to use LocalRes$Path.
German resources imported.

Version 0.64. Tagged as 'DOSFS-0_64'
@
text
@d183 1
a183 1
static _kernel_oserror *declare_FS(void *private)
d223 1
a223 1
 rset.r[3] = (word)private ;
d243 1
a243 1
static _kernel_oserror *FSSWI_DiscFormat(_kernel_swi_regs *rset,void *private)
d297 1
a297 1
 UNUSED(private) ;
d306 1
a306 1
static _kernel_oserror *FSSWI_LayoutStructure(_kernel_swi_regs *rset,void *private)
d430 4
a433 13
      /* Deal with the case when no name has been given */
      if (rset->r[2] == NULL) {
       /* Nasty bit of sprintf to create a default disc name of the
        * form HHMMYYMMDD (hours/minutes/year/month/day).
        */
       sprintf((char *)&dentry->FILE_status,"%02d%02d%02d%02d%02d ",((get_FILE_time(dentry) & hour_mask) >> hour_shift),((get_FILE_time(dentry) & min_mask) >> min_shift),((((get_FILE_date(dentry) & year_mask) >> year_shift) + 1980) % 100),((get_FILE_date(dentry) & mon_mask) >> mon_shift),((get_FILE_date(dentry) & day_mask) >> day_shift)) ;
      } else
       strncpy((char *)&(dentry->FILE_status),(char *)rset->r[2],(namsize + extsize)) ;

      /* Either of the above sprintf's will have over-written the
       * attribute flags with their terminating NULL. Since we are a
       * fresh format this should not lose any information.
       */
d462 1
a462 1
 UNUSED(private) ;
d469 1
a469 1
_kernel_oserror *fs_swi(int swi_no,_kernel_swi_regs *rset,void *private)
d474 1
a474 1
             return(FSSWI_DiscFormat(rset,private)) ;
d478 1
a478 1
             return(FSSWI_LayoutStructure(rset,private)) ;
d493 1
a493 1
void fs_service(int service_number,_kernel_swi_regs *rset,void *private)
d516 1
a516 1
               declare_FS(private) ;
d815 1
a815 1
                       if ((dentry = findDIRtype((byte)FILE_volume,(DOS_direntry *)sector,DOSsecsize,&i)) != NULL) {
d1057 1
a1057 1
_kernel_oserror *fs_commands(const char *argv,int argc,int command,void *private)
d1523 1
a1523 1
 UNUSED(private) ;
d1562 1
a1562 1
_kernel_oserror *init_fs(const char *cmd_tail,int podule_base,void *private)
d1571 1
a1571 1
 if ((syserr = declare_FS(private)) != NULL)
@


4.1
log
@Initial revision
@
text
@d277 1
a277 1
 if ((rerror = _kernel_swi((XOS_Bit | rset->r[1]),&urset,&urset)) == NULL)
d655 1
a655 1
                    if ((rerror = _kernel_swi((XOS_Bit | FileCore_DiscOp),&urset,&urset)) == NULL)
d762 1
a762 1
                     if ((rerror = _kernel_swi((XOS_Bit | FileCore_DiscOp),&urset,&urset)) == NULL) {
d820 1
a820 1
                      if ((rerror = _kernel_swi((XOS_Bit | FileCore_DiscOp),&urset,&urset)) == NULL) {
d1024 1
a1024 1
                   rerror = _kernel_swi((XOS_Bit | OS_WriteN), &urset, &urset);
d1029 1
a1029 1
                   rerror = _kernel_swi((XOS_Bit | OS_Write0),&urset,&urset) ;
d1034 1
a1034 1
                     rerror = _kernel_swi((XOS_Bit | OS_Write0),&urset,&urset) ;
d1040 1
a1040 1
                     rerror = _kernel_swi((XOS_Bit | OS_Write0),&urset,&urset) ;
d1045 1
a1045 1
                    rerror = _kernel_swi((XOS_Bit | OS_NewLine),&urset,&urset) ;
d1066 1
a1066 1
_kernel_oserror *fs_commands(char *argv,int argc,int command,void *private)
d1075 5
a1079 5
              int       loop ;
              word      dosext = 0x00000000 ; /* DOS extension */
              word      ROtype = 0x000 ;      /* RISC OS filetype */
              mapentry *cptr ;
              char     *tptr ;
d1144 1
a1144 1
                    if ((rerror = _kernel_swi((XOS_Bit | OS_FSControl),&rset,&rset)) != NULL)
d1234 1
a1234 1
                        if ((rerror = _kernel_swi((XOS_Bit | OS_FSControl),&rset,&rset)) == NULL)
d1280 1
d1284 1
a1284 1
              rerror = _kernel_swi((XOS_Bit | ADFS_Drives),&rset,&rset) ;
d1294 2
a1295 1
                cptr = strtok(argv," \t") ; /* first argument */
d1571 1
a1571 1
int init_fs(char *cmd_tail,int podule_base,void *private)
@


4.1.4.1
log
@Return type of init_fs corrected
@
text
@d1569 1
a1569 1
_kernel_oserror *init_fs(char *cmd_tail,int podule_base,void *private)
@


4.1.4.2
log
@Fixed fs_commands () and init_fs () to work with cmhg 5.18.
@
text
@d97 1
a97 1
./* -- MSDOS H 1.2M double sided, 80 tracks, 15 sectors */
d1066 1
a1066 1
_kernel_oserror *fs_commands(const char *argvptr,int argc,int command,void *private)
a1067 4
 /* 14 Apr 1998 RLT: Bodge fix to prevent error with CMHG generated hdr */
 char *argv = (char *) argvptr;
 /* end of bodge */

d1569 1
a1569 1
_kernel_oserror *init_fs(const char *cmd_tail,int podule_base,void *private)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.12;
access;
symbols
	DOSFS-1_14:4.12
	DOSFS-1_13:4.12
	DOSFS-1_12:4.12
	DOSFS-1_11:4.12
	DOSFS-1_10:4.12
	DOSFS-1_09:4.12
	DOSFS-1_08:4.12
	DOSFS-1_07:4.12
	DOSFS-1_06:4.11
	DOSFS-1_05:4.10
	DOSFS-1_04:4.8
	DOSFS-1_03:4.7
	DOSFS-1_02:4.7
	DOSFS-1_01:4.7
	DOSFS-1_00:4.7
	DOSFS-0_99:4.7
	DOSFS-0_98:4.6
	DOSFS-0_97:4.5
	DOSFS-0_96:4.5
	DOSFS-0_95:4.4
	DOSFS-0_94:4.4
	DOSFS-0_93:4.4
	DOSFS-0_92:4.4
	DOSFS-0_91:4.4
	DOSFS-0_90:4.4
	DOSFS-0_89:4.4
	DOSFS-0_88:4.4
	DOSFS-0_87:4.4
	DOSFS-0_86:4.3
	DOSFS-0_85:4.3
	DOSFS-0_84:4.3
	DOSFS-0_83:4.3
	DOSFS-0_82:4.3
	DOSFS-0_81:4.3
	DOSFS-0_80:4.3
	DOSFS-0_79:4.3
	RO_5_07:4.2
	DOSFS-0_78:4.2
	DOSFS-0_77:4.2
	DOSFS-0_76:4.2
	DOSFS-0_75:4.2
	DOSFS-0_74:4.2
	DOSFS-0_73:4.2
	DOSFS-0_72:4.2
	DOSFS-0_71:4.2
	DOSFS-0_70:4.2
	DOSFS-0_69:4.2
	DOSFS-0_68:4.1
	DOSFS-0_67:4.1
	DOSFS-0_66:4.1
	DOSFS-0_65:4.1
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	DOSFS-0_64:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_DOSFS_0_63:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.12
date	2014.06.25.20.13.35;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	E7yWETwfWvNEvWFx;

4.11
date	2014.06.25.19.37.20;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	gFu51vOmpefejWFx;

4.10
date	2014.06.24.07.42.37;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	HOlrghCdI349nKFx;

4.9
date	2014.06.24.07.34.37;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	yjODkHAzwcqhlKFx;

4.8
date	2014.05.31.17.18.22;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	9C7sPVBMelsWkICx;

4.7
date	2013.01.13.18.52.34;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	oq0uLRDtA5Y625Aw;

4.6
date	2013.01.13.18.49.43;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	fjzSOoRRnhA815Aw;

4.5
date	2012.12.07.14.20.16;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	jnwtWy3St1iqIivw;

4.4
date	2009.06.11.21.01.27;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2004.09.30.21.59.06;	author jballance;	state Exp;
branches;
next	4.2;

4.2
date	2002.09.22.11.30.06;	author rsprowson;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.33.02;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.33.02;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.54.30;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.37.31;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.34.00;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Change last couple of uses of trace macros to use DebugLib
This town ain't big enough for the two of us.

Version 1.07. Tagged as 'DOSFS-1_07'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*> c.DOSnaming <*/
/*---------------------------------------------------------------------------*/
/* MSDOS to RISCOS name conversion                Copyright (c) 1989 JGSmith */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <ctype.h>
#include "kernel.h"
#include "DebugLib/DebugLib.h"

#include "DOSFS.h"
#include "TIMEconv.h"
#include "ADFSshape.h"
#include "Helpers.h"
#include "MsgTrans.h"
#include "DOSnaming.h"
#include "DOSshape.h"
#include "DOSdirs.h"

/*!
 * \brief  Validate that the given character appears in the string
 * \param  string Table to use
 * \param  init Character to check if it is in it
 * \return -1 if the character is in the table
 */
int validchar(char *string, char init)
{
  while (*string != '\0')
  {
    if (*string == init)
      return -1;
    string++;
  }

  return 0;
}

/*!
 * \brief  Map certain characters between filing systems
 * \param  char Character to map
 * \param  fromlist Input table
 * \param  tolist Output table
 * \return Remapped character
 */
char mapchar(char cchr, char *fromlist, char *tolist)
{
  while (*fromlist != '\0')
  {
    if (cchr == *fromlist)
      return *tolist;
    fromlist++;
    tolist++;
  }
  return cchr;
}

/*!
 * \brief  Return the character position of the passed character (or 0 if none)
 * \param  text String to search
 * \param  marker fromlist Input table
 * \param  tolist Output table
 * \return Remapped character
 */
static int chr_pos(char *text, char marker)
{
// int index;
//
// for (index = 0; (text[index] != '\0'); index++)
//  if (text[index] == marker)
//   return(index) ;
  char *index = strrchr(text, marker);
  return (index ? (int)(index - text) : 0);
}

/*!
 * \brief  Return a string containing the text before the given character
 * \param  newptr Pointer to storage for the substring
 * \param  text String to use
 * \param  marker Character to split at
 * \param  npad Terminate with 0 if zero
 * \return The new string
 */
char *before(char *newptr, char *text, char marker, int npad)
{
  int cpos = chr_pos(text, marker);
  if (cpos == 0)
    cpos = strlen(text);
 
  strncpy(newptr, text, cpos);
  if (npad == 0)
    newptr[cpos] = '\0';
 
  return newptr;
}

/*!
 * \brief  Return a string containing the text after the given character
 * \param  newptr Pointer to storage for the substring
 * \param  text String to use
 * \param  marker Character to split at
 * \param  npad Terminate with 0 if zero
 * \return The new string
 */
char *after(char *newptr, char *text, char marker, int npad)
{
  int cpos = chr_pos(text, marker);

  if (cpos != 0)
  {
    if (npad == 0)
      strcpy(newptr, &text[cpos + 1]);
    else
      strncpy(newptr, &(text[cpos + 1]), 4);
  }
  else
  {
    if (npad == 0)
      strcpy(newptr, "");
  }

  return (newptr);
}

/* RISC OS name:
 *      [$.]<path>
 * RISC OS path:
 *      <filename (max. 10 chars)>[.<path element>]
 *
 * DOS name:
 *      [\]<path>
 * DOS path:
 *      <filename (max. 8 chars)>[.<extension (max. 3 chars)>[\<path element>]
 */

/*!
 * \brief  Check that the given DOS names are identical
 * \param  wcname Compare name, possibly including wild cards
 * \param  fname File name
 * \return TRUE when there is a match
 */
int namematch(char *wcname,char *fname)
{
  char string1[257];
  char string2[257];
 
  /* Code assumes characters upto (and including) "file_sep" will always fit
   * in RISC OS names.
   */
  before(string1, fname, file_sep, 0);
  before(string2, wcname, file_sep, 0);
  if (wild_card_compare(string1, string2, DOSwcmult, DOSwcsing) == TRUE)
  {
    /* "string1" is the full (non-wildcarded) filename we have matched with */
    /* "string2" is the original (wildcarded) filename we were given on entry */
    after(string1, fname, file_sep, 0);
    after(string2, wcname, file_sep, 0);
 
    if (wild_card_compare(string1, string2, DOSwcmult, DOSwcsing) == TRUE)
      return TRUE;
  }
 
  return FALSE;
}

/*!
 * \brief  Translate a standard RISC OS name into a MS-DOS one
 * \param  source The RISC OS name
 * \param  dest Buffer to receive the DOS one
 * \return Destination buffer pointer
 */
char *convertRISCOStoDOS(char *source, char *dest)
{
  char *csptr = source;
  char *cdptr = dest;
  int   loop;
  int   filesepseen = FALSE; /* if we have seen the file seperator */
  char *cptr;      /* string pointer */
  char  lchr;      /* last character seen */
  int   point = 0; /* position where file extension started */
 
  if ((source == NULL) || (*source == '\0'))
  {
    dprintf(("", "DOSFS: convertRISCOStoDOS: NULL name\n"));
    *dest = '\0';
    return dest;
  }
 
  dprintf(("","DOSFS: convertRISCOStoDOS: \"%s\"", source));
 
  lchr = '\0'; /* no last character */
  cptr = csptr;
  do
  {
    /* Ensure that "/" characters do not appear at the start or end of the name
     * and that "//" sequences are trapped.
     */
    if ((*cptr == '/' && (lchr == '\0' || lchr == *cptr || lchr == '.')) ||
        ((lchr == '/') && ((*cptr == '\0') || (*cptr == '.')))
       )
      return_error1(char *, err_invalidname, source);
 
    lchr = *cptr++; /* remember this character */
  } while (lchr);
 
  if (*csptr == '$')             /* ROOT directory specifier */
  {
    csptr++;
    if (*csptr == '.')           /* RISC OS directory seperator */
    {
      *cdptr++ = dir_sep;        /* MSDOS directory seperator */
      csptr++;
    }
    else
      if (*csptr == '\0')
        *cdptr++ = dir_sep;
      else
        *cdptr++ = '$';
  }
 
  for (loop = 0;;)       /* convert the remainder of the pathname */
  {
    if (*csptr == '\0')  /* end of the source pathname */
    {
      *cdptr = '\0';     /* terminate the destination pathname */
      break;
    }
 
    switch (*csptr)
    {
      case '.':
        /* RISC OS to directory seperator */
        *cdptr++ = dir_sep;
        csptr++;
        loop = 0;
        filesepseen = FALSE; /* for this leafname */
        break;
 
      case '/':
        /* convert to file seperator */
        if (filesepseen)
          return_error1(char *, err_invalidname, source);
        *cdptr++ = file_sep;
        csptr++;
        loop++;
        point = loop;
        filesepseen = TRUE;
        break;
 
      default:
        /* perform standard name mapping */
        if (filesepseen)
        {
          char c = *csptr++;
          /* should never need to truncate the extension */
//        if ((loop - point) >= extsize)
//          return_error1(char *, err_invalidname, source);
//        if (islower(c))
//          c = toupper(c);
          *cdptr++ = mapchar(c, ROmapping, DOSmapping);
        }
        else
        {
          char c = *csptr;
//        if (islower(c))
//          c = toupper(c);
          *cdptr++ = mapchar(c, ROmapping, DOSmapping);
          csptr++;      /* step over this DOS character */
        }
        loop++;
        break;
    }
  }
 
  dprintf(("", " converted to \"%s\"\n", dest));
 
  for (cptr = dest; *cptr; cptr++)
    if (!validchar(valchars, *cptr))
      return_error1(char *, err_invalidname, source);
 
  return dest;
}

/*!
 * \brief  Convert a dir entry into a DOS short filename
 * \param  dentry The dir entry to consider
 * \param  name Buffer to receive the name, at least 8+1+3+1 long
 * \return Name buffer pointer
 */
char *buildFILEname(DOS_direntry * dentry,char *name)
{
  char *cptr = (char *)&(dentry->FILE_status);
  int   index;
  int   loop;

  dprintf(("", "buildFILEname: dentry:%p\n", dentry));
 
  /* "dentry" should contain a valid filename */
  /* copy prefix characters (or upto a space) into the filename buffer */
  for (index=0; ((cptr[index] > ' ') && (index < namsize)); index++)
    name[index] = cptr[index];
 
  /* copy suffix characters (or upto a space) into the filename buffer */
  for (loop=0; ((dentry->FILE_extension[loop] > ' ') && (loop < extsize)); loop++)
  {
    if (loop == 0) /* the first character of the extension */
      name[index++] = file_sep; /* then place in the file_seperator */
    name[index++] = dentry->FILE_extension[loop];
  }
 
  /* terminate the name */
  name[index] = '\0';
  dprintf(("", "buildFILEname: got:%s\n", name));
 
  return name;
}

/*!
 * \brief  Calculates the LFN checksum of an 11 bytes DOS filename
 * \param  filename The filename to use
 * \return The checksum
 */
byte lfnchecksum(const char *filename)
{
  byte checksum = 0;
  byte lsb;
  int  i;

  for (i = 0; i < 11; i++)
  {
    lsb = (checksum & 0x1); /* Save the lsb */
    checksum = checksum >> 1; /* Shift the byte */
    lsb = lsb << 7; /* Turn saved lsb into msb */
    checksum |= lsb;
    checksum += filename[i];
  }
 
  return checksum;
}

/*!
 * \brief  Shorten part of a DOS filename
 * \param  longfname The part of filename to start with (ie. base name, or extension)
 * \param  buff Pointer to a buffer for the short result
 * \param  limit Maximum number of characters to output
 * \return TRUE if copying was not an identity transform
 */
static int shorten_part(const char *longfname, char *buff, size_t limit)
{
  size_t i, j;
  int    identity = TRUE;

  for (i = 0, j = 0; j < limit; i++)
  {
    if ((longfname[i] == '.') || (longfname[i] == '\0'))
    {
      /* Reached the end of the base name */
      break;
    }
    if (strchr("+,;=[]", longfname[i]) != NULL)
    {
      /* Substitute forbidden short name characters */
      buff[j++] = '_';
      identity = FALSE;
      continue;
    }
    if (longfname[i] == ' ')
    {
      /* Swallow spaces */
      identity = FALSE;
      continue;
    }
    buff[j++] = toupper(longfname[i]);
  }
  buff[j] = '\0';

  return !identity;
}

int shorten_lfn(char *longfname, char *shortname, DIR_info *cdir)
{
  size_t i;
  int    retval, nondot, tilde;
  char  *extension;
  char   basebuff[8+1];
  char   extbuff[1+3+1];
  char   compbuff[8+1+3+1];

  /* Build the base name up to 8 long starting at the first non dot */
  for (i = 0; longfname[i] == '.'; i++)
  {
  }
  nondot = i;
  tilde = shorten_part(&longfname[i], basebuff, 8);
 
  /* Locate the outermost extension and truncate to 3 letters */
  extension = strrchr(longfname, '.');
  if ((extension == NULL) || (&extension[1] == &longfname[nondot]))
  {
    /* No extension, or found dot was at the start before the base name */
    extension = ".";
  }
  shorten_part(&extension[1], &extbuff[1], 3);
  extbuff[0] = '.';
  dprintf(("", "shorten_lfn '%s' => base '%s' & ext '%s'\n", longfname, basebuff, extbuff));

  /* If a tilde was needed, inject it */
  if (tilde)
  {
    int  index, length;
    char fmt[] = "%0.?s~%u%s";

    if (strlen(basebuff) <= 2)
    {
      /* Bit short, add a few digits */
      sprintf(compbuff, "%04X", time(NULL));
      strcat(basebuff, compbuff);
    }
    length = MIN(strlen(basebuff), 6);
    fmt[3] = '0' + length;
    for (i = 1; i <= 99; i++)
    {
      if ((i == 10) && (length == 6)) fmt[3]--; /* Budge an extra digit */
      sprintf(compbuff, fmt, basebuff, i, extbuff);
      index = 0;
      if (findDIRentry(compbuff, cdir, cdir->dir_size, &index) == NULL)
      {
        /* No match, so we can use that tilde suffix */
        break;
      }
    }
    dprintf(("", "            tilde needed, clear to use '%s'\n", compbuff));
  }
  else
  {
    strcpy(compbuff, basebuff);
    strcat(compbuff, extbuff);
    dprintf(("", "            composite '%s'\n", compbuff));
  }

  /* See if the short candidate is the same as the long one */
  retval = strcmp(longfname, compbuff);
  if (retval == 0)
  {
    dprintf(("", "            long will do as short\n"));
  }

  /* Rejig the short name into its dotless form ready to put into a dir entry */
  *strchr(compbuff, '.') = '\0';
  sprintf(shortname, "%-8.8s%-3s", compbuff, &extbuff[1]);
  dprintf(("", "            dir entry '%s'\n", shortname));

  return retval;
}

/*!
 * \brief  Build an array of long filename entries from its name and short name
 * \param  lfn Allocated array of dir entries
 * \param  numreq Number of dir entries allocated
 * \param  leafname The long name to encode
 * \param  shortname The short name to encode
 */
void MakeLFNEntries(DOS_direntry * lfn[],int numreq,char* leafname,char* shortname)
{
  int lfnnum, i;
  DOS_lfnentry *lfnentry;
  int charnum = 0;
  int nullreached = 0;
  
  for (i = (numreq - 2), lfnnum = 0; i >= 0; i--, lfnnum++)
  {
    /* Create the long file name structures */
    lfnentry = (DOS_lfnentry *)lfn[i];
    lfnentry->FILE_Ordinal = ((lfnnum & 0x3F) + 1);
    if (i == 0) lfnentry->FILE_Ordinal |= 0x40; /* Last entry */
    lfnentry->FILE_attribute = FILE_win95;
    lfnentry->reserved1 = lfnentry->reserved2 = lfnentry->reserved3 = 0; 

    /* Weave the name */
    lfnentry->FILE_uchar0_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar0    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar1_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar1    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar2_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar2    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar3_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar3    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar4_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar4    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar5_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar5    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar6_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar6    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar7_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar7    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar8_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar8    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar9_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar9    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar10_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar10    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar11_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar11    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;
    lfnentry->FILE_uchar12_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar12    = (nullreached)?0xFF:leafname[charnum];
    if (leafname[charnum] == '\0') nullreached = 1;
    charnum++;

    lfnentry->FILE_checksum = lfnchecksum(shortname);
  }
}

/*!
 * \brief  Translate a standard RISC OS name into an extended DOS one
 * \param  source The RISC OS name
 * \param  dest Buffer to receive the DOS one
 * \return Destination buffer pointer
 */
char *convertRISCOStoLFN(char *source, char *dest)
{
  char *csptr = source;
  char *cdptr = dest;
  int   loop;
  int   filesepseen = FALSE; /* if we have seen the file seperator */
  char *cptr;      /* string pointer */
  char  lchr;      /* last character seen */
  int   point = 0; /* position where file extension started */
 
  if ((source == NULL) || (*source == '\0'))
  {
    dprintf(("", "DOSFS: convertRISCOStoLFN: NULL name\n"));
    *dest = '\0';
    return dest;
  }
 
  dprintf(("", "DOSFS: convertRISCOStoLFN: \"%s\"",source));
 
  lchr = '\0'; /* no last character */
  cptr = csptr;
  do
  {
    /* Ensure that "/" characters do not appear at the start or end of the name
     * and that "//" sequences are trapped.
     */
//   if ((*cptr == '/' && (lchr == '\0' || lchr == *cptr || lchr == '.')) ||
//       ((lchr == '/') && ((*cptr == '\0') || (*cptr == '.')))
//      )
//     return_error1(char *,err_invalidname,source) ;
 
    lchr = *cptr++; /* remember this character */
  } while (lchr);
 
  if (*csptr == '$')             /* ROOT directory specifier */
  {
    csptr++;
    if (*csptr == '.')           /* RISC OS directory seperator */
    {
      *cdptr++ = dir_sep;        /* MSDOS directory seperator */
      csptr++;
    }
    else
      if (*csptr == '\0')
        *cdptr++ = dir_sep;
      else
        *cdptr++ = '$';
  }
 
  for (loop = 0;;)       /* convert the remainder of the pathname */
  {
    if (*csptr == '\0')  /* end of the source pathname */
    {
      *cdptr = '\0';     /* terminate the destination pathname */
      break;
    }
 
    switch (*csptr)
    {
      case '.':
        /* RISC OS to directory seperator */
        *cdptr++ = dir_sep;
        csptr++;
        loop = 0;
        filesepseen = FALSE; /* for this leafname */
        break;
 
      case '/':
        /* convert to file seperator */
//      if (filesepseen)
//        return_error1(char *, err_invalidname, source);
        *cdptr++ = file_sep;
        csptr++;
        loop++;
        point = loop;
//      filesepseen = TRUE;
        break;
 
      default:
        /* perform standard name mapping */
//      if (filesepseen)
//      {
//        char c = *csptr++;
        /* should never need to truncate the extension */
//        if ((loop - point) >= extsize)
//         return_error1(char *, err_invalidname, source);
//        if (islower(c))
//         c = toupper(c);
//        *cdptr++ = mapchar(c, ROmapping, DOSmapping);
//      }
//      else
//      {
        if (loop < 255)    /* characters left */
        {
          char c = *csptr;
//        if (islower(c))
//          c = toupper(c);
          *cdptr++ = mapchar(c, ROmapping, DOSmapping);
        }
        else
        {
          if (!(module_flags & TRUNCATE_NAMES))
            return_errorT(char *, err_nametoolong, tok_nametoolong, source, "255");
        }
        csptr++;      /* step over this DOS character */
//      }
      loop++;
      break;
     }
  }
 
  dprintf(("", " converted to \"%s\"\n", dest));
 
// for (cptr = dest; *cptr; cptr++)
//   if (!validchar(valchars,*cptr))
//     return_error1(char *, err_invalidname, source);
 
  return dest;
}

/*!
 * \brief  Translate an extended DOS name into a RISC OS one
 * \param  source The DOS name
 * \param  dest Buffer to receive the RISC OS one
 * \return Destination buffer pointer
 */
char *convertDOStoRISCOS(char *source, char *dest)
{
  char *csptr = source;
  char *cdptr = dest;
  int   loop;
 
  dprintf(("", "DOSFS: convertDOStoRISCOS: \"%s\" ",source));
 
  if (*csptr == dir_sep)
    *cdptr++ = '$';
 
  for (loop = 0;;)
  {
    if (*csptr =='\0')   /* end of the source pathname */
    {
      *cdptr = '\0';     /* terminate filename */
      break;             /* the for loop */
    }
 
    switch (*csptr)
    {
      case file_sep:
        /* convert the character to "/" */
        *cdptr++ = '/';
        csptr++;
        loop++;
        break;
 
      case dir_sep:
        /* convert to RISC OS directory seperator */
        *cdptr++ = '.';
        loop = 0;
        csptr++;
        break;
 
      default:
        /* perform standard name mapping */
        /* we never truncate here, it's up to the outside world */
        *cdptr++ = mapchar(*csptr, DOSmapping, ROmapping);
        csptr++;
        loop++;
        break;
    }
  }
 
  dprintf(("", "converted to \"%s\"\n", dest));
  return dest;
}
@


4.11
log
@Revise filename shortening rules
The rules DOSFS used to create the short name version of a long filename were quite wide of the recommendations from Microsoft. This causes problems in particular with bootloaders that are a little more simplistic and use the short name form, only to find "BOOTCODE.BIN" has been replaced by "BOOTCO~1.BIN" by DOSFS.
Also, the long filename entried created for new long filenames left the reserved fields unset. Some of these seem to have special meanings to Windows which faults them ("extended attribute handle invalid") when running chkdsk.

DOSnaming.c: replaced the shorten_lfn function, sprinkled in a few token consts, set the reserved fields in long file names to 0
DOSclusters.c/OpsFunc.c/OpsFile.c: remove shorttemp[14] no longer needed, simplify sprintf/memcpy/memcpy into a single sprintf
DOSFS.h: familiar MIN/MAX maxros added

Tested in isolation in harness "test/shorten" and comparing floppy discs generated with "test/shortgen" from Windows and DOSFS.
Fixes ticket #313.

Version 1.06. Tagged as 'DOSFS-1_06'
@
text
@a35 1
#include "debug.h"
@


4.10
log
@Hypothetical C syntax swapped for reality
Nice though it would be to be able to use logical or to test multiple characters at once, that expression simply evaluates to "TRUE" in the real world, so the substitution for underscore never worked when shortening filenames.
The function still doesn't follow Microsoft's rules (see ticket #313) yet.
@
text
@d22 2
d340 1
a340 1
byte lfnchecksum(char *filename)
d359 12
a370 18
 * \brief  Formulate a DOS short filename from a long one
 * \param  longfname The filename to start with
 * \param  shortname Pointer to a buffer for the short result
 * \param  shortnamebuff A temporary buffer
 * \param  cdir The current working directory, used to check for duplicates of the shortened name
 * \return Zero if the short name ends up being the same as the long one
 */
int shorten_lfn(char * longfname, char * shortname, char * shortnamebuff, DIR_info * cdir)
{
  // char * longfname : pointer to a null terminated file name
  // char * shortnamebuff : pointer to a 13 byte buffer to store newly created short file name
  // DIR_info * cdir : pointer the dir info structure for the target directory
  int i, j, o, retval, dotseen=0;
  char * extension,c;
  /* check if already a valid short file name */
  memset(shortnamebuff,' ',12);shortnamebuff[12]=0;
  dprintf(("","shorten_lfn: start with -%s-\n",longfname));
  for(i=0,j=0;(i<=12)&&(j<=12);i++,j++)
d372 1
a372 2
    c=longfname[i];                      
    if(c=='.')
d374 2
a375 9
      if(!dotseen)
      {
        dotseen=i+1;
        while(j<8)
        {
         shortnamebuff[j++]=' ';  // spacefill to 8 
        }
      }
      if(i>8) break; // too many chars
d377 6
a382 5
  dprintf(("","shorten_lfn: check -%x-%c- toupper(c) -%c-\n",c,c,toupper(c)));
    if(c && ((c=='.')||((c==toupper(c)) && (c!=' '))))
    { /* copy over */
      shortnamebuff[j]=c;
  dprintf(("","shorten_lfn: copied -%c-\n",c));
d384 1
a384 1
    else
d386 3
a388 8
      dprintf(("","shorten_lfn: %d %d %d\n",c,strlen(shortnamebuff),strlen(longfname)));
      if(!c && /*strlen(shortnamebuff)==strlen(longfname) && */((!dotseen && (i<9)) || dotseen))
      { /* end of string .. and identical */
        dprintf(("","shorten_lfn: its a valid DOS SFN\n"));
        retval= 0;
        goto slnfn1;
      }
      break;
d390 19
d410 2
d413 35
a447 101
 
 
  memset(shortnamebuff,'_',8);
  memset(&shortnamebuff[8],' ',4);
  shortnamebuff[12]=NULL;
  for(i=0,o=0;o<6;i++)
  {
   if(longfname[i]==NULL)
   {
    o=6;
    continue;
   }
   if(longfname[i]==' ') continue;
   if(longfname[i]=='.')
   {
    if( &(longfname[i]) == strrchr(longfname,'.') )
    {//If we are currently at the last 'dot' terminator in the filename...
     o=6;      //Ensuring we
     continue; //Drop out of the loop
    }else
    {
     i++;
     continue;
    }
   }
   if(strchr("+,;=[]", longfname[i]) != NULL)
   {
    shortnamebuff[o] = '_';
   }else
   {
    shortnamebuff[o] = toupper(longfname[i]);
   }
   o++;
  }
 
  dprintf(("","shorten_lfn: strchr(longfname,'.') = %p, c='%c'\n",strchr(longfname,'.'),*strchr(longfname,'.')));
  //We now have collected the first 6 characters of the short file name.
  if(extension=strrchr(longfname,'.'), extension != NULL) //There is a dot extension
  {//char * 'extension' points to the dot extension
   for(i=0,o=8;o<12;i++)
   {
    if(extension[i]==NULL)
    {
     o=12; //Break out of loop
     continue;
    }
    if(extension[i]==' ') continue;
    if(strchr("+,;=[]", extension[i]) != NULL)
    {
     shortnamebuff[o] = '_';
    }else
    {
     shortnamebuff[o] = toupper(extension[i]);
    }
    o++;
   }
  }
  shortnamebuff[6]='~';
  shortnamebuff[7]='1';
  shortnamebuff[12]=0;
  if(shortnamebuff[9]==' ') shortnamebuff[8]='\0';
 
  dprintf(("","Here file name is '%s'\n",shortnamebuff));
 
  DOS_direntry * fentry;
  int index;
 
  for(i=1;i<99;i++)
  {
   shortnamebuff[7]='0'+(i%10);
   if((i / 10) > 0)
   {
    shortnamebuff[6]='0'+(i/10);
    shortnamebuff[5]='~';
   }
   index=0;
   fentry=findDIRentry(shortnamebuff,cdir,cdir->dir_size,&index);
   if(fentry==NULL)
   {
    i=99;
    continue;
   }
  }
 
 
  dprintf(("","shorten_lfn: Started with lfn \"%s\"\n",longfname));
  dprintf(("","shorten_lfn: Created short name \"%s\", char[8]= %x, char[9]= %x, char[10]= %x, char[11]= %x, char[12]= %x, char[13]= %x\n",shortnamebuff,shortnamebuff[8],shortnamebuff[9],shortnamebuff[10],shortnamebuff[11],shortnamebuff[12],shortnamebuff[13]));
  retval=1;
 slnfn1: 
   memset(shortname,' ',11);
   memcpy(shortname,shortnamebuff,8);
   memcpy(&shortname[8],&shortnamebuff[9],3);
   if(shortnamebuff[8]=='.') i=8;
   else i=0;
   for(;i<11;i++)
   {
    if(shortnamebuff[i] == ' ')
    {
     shortnamebuff[i]=0;
     i=11;
     continue;
d449 21
a469 1
   }
d494 1
@


4.9
log
@Added some doxygen comments
Also corrected various confusions about NULL (a pointer) and the ASCII character 0.
Reindented consistently.

Version 1.05. Tagged as 'DOSFS-1_05'
@
text
@d433 1
a433 1
   if(longfname[i] == ('+' || ',' || ';' || '=' || '[' || ']' || '.'))
d455 1
a455 1
    if(extension[i] == ('+' || ',' || ';' || '=' || '[' || ']'))
@


4.8
log
@Use a few defines, correct error text
Magic E5 and 0F's swapped for preexisting defines.
Name too long error (when truncate CMOS is off) erroneously said 8 characters was the name limit despite the loop counter check being 255 characters.
Not tagged.
@
text
@d36 7
a42 4
/*---------------------------------------------------------------------------*/
/* validate that the given character appears in the string */

int validchar(char *string,char init)
d44 1
a44 3
//  if (init >= 128) return -1;    /* Allow top bit set characters */

  while (*string != NULL)
d54 8
a61 4
/*---------------------------------------------------------------------------*/
/* Map certain characters between filing systems */

char mapchar(char cchr,char *fromlist,char *tolist)
d63 1
a63 1
  while (*fromlist != NULL)
d73 8
a80 3
/*-------------------------------------------------------------------------*/

static int chr_pos(char *text,char marker)
d82 1
a82 1
// int index ;
d84 1
a84 2
// /* return the character position of the passed character (or 0 if none) */
// for (index = 0; (text[index] != NULL); index++)
d87 2
a88 2
 char * index =strrchr(text,marker); 
 return(index?(int)(index-text):NULL) ;
d91 9
a99 4
/*-------------------------------------------------------------------------*/
/* return a string containing the text before the given character */

char *before(char *newptr,char *text,char marker,int npad)
d101 9
a109 9
 int cpos = chr_pos(text,marker) ;
 if (cpos == 0)
  cpos = strlen(text) ;

 strncpy(newptr,text,cpos) ;
 if (npad == 0)
  newptr[cpos] = NULL ;

 return(newptr) ;
d112 9
a120 6
/*-------------------------------------------------------------------------*/
/* return a string containing the text after the last occurrence of */
/* the given character */
/* used to extract the DOS file extent info */

char *after(char *newptr,char *text,char marker,int npad)
d122 1
a122 1
 int cpos = chr_pos(text,marker) ;
d124 8
a131 2

 if (cpos != 0)
d133 2
a134 5
//   int len = strlen(text) ;
   if (npad == 0)
    strcpy(newptr,&text[cpos + 1]) ;
   else
    strncpy(newptr,&(text[cpos + 1]),4) ;
a135 3
 else
  if (npad == 0)
   strcpy(newptr,"") ;
d137 1
a137 1
 return(newptr) ;
a149 6
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* Check that the given DOS names are identical */
d151 6
d159 27
a185 27
 char string1[257];
 char string2[257] ;

 /* Code assumes characters upto (and including) "file_sep" will always fit
  * in RISC OS names.
  */
 before(string1,fname,file_sep,0) ;
 before(string2,wcname,file_sep,0) ;
 if (wild_card_compare(string1,string2,DOSwcmult,DOSwcsing) == TRUE)
  {
   /* "string1" is the full (non-wildcarded) filename we have matched with */
   /* "string2" is the original (wildcarded) filename we were given on entry */

   after(string1,fname,file_sep,0) ;
   after(string2,wcname,file_sep,0) ;

   if (wild_card_compare(string1,string2,DOSwcmult,DOSwcsing) == TRUE)
    return(TRUE) ;
  }

 return(FALSE) ;
}

/*---------------------------------------------------------------------------*/
/* convertRISCOStoDOS:
 * translate a standard RISC OS name into a MS-DOS one.
 * **** we should really include code to check the "dest" buffer limits ****
d187 1
a187 1
char *convertRISCOStoDOS(char *source,char *dest)
d189 33
a221 9
 char      *csptr = source ;
 char      *cdptr = dest ;
 int        loop ;
 int        filesepseen = FALSE ; /* if we have seen the file seperator */
 char      *cptr ;      /* string pointer */
 char       lchr ;      /* last character seen */
 int        point = 0 ; /* position where file extension started */

 if ((source == NULL) || (*source == NULL))
d223 2
a224 23
   dprintf(("","DOSFS: convertRISCOStoDOS: NULL name\n")) ;
   *dest = NULL ;
   return(dest) ;
  }

 dprintf(("","DOSFS: convertRISCOStoDOS: \"%s\"",source)) ;

 lchr = '\0' ; /* no last character */
 cptr = csptr;
 do {
   /* Ensure that "/" characters do not appear at the start or end of the name
    * and that "//" sequences are trapped.
    */
   if ((*cptr == '/' && (lchr == '\0' || lchr == *cptr || lchr == '.')) || ((lchr == '/') && ((*cptr == '\0') || (*cptr == '.'))))
    return_error1(char *,err_invalidname,source) ;

   lchr = *cptr++ ; /* remember this character */
 } while (lchr);

 if (*csptr == '$')             /* ROOT directory specifier */
  {
   csptr++ ;
   if (*csptr == '.')           /* RISC OS directory seperator */
d226 2
a227 2
     *cdptr++ = dir_sep ;       /* MSDOS directory seperator */
     csptr++ ;
a228 3
   else
    if (*csptr == NULL)
     *cdptr++ = dir_sep ;
d230 4
a233 1
     *cdptr++ = '$' ;
d235 2
a236 2

 for (loop = 0;;)       /* convert the remainder of the pathname */
d238 1
a238 1
   if (*csptr == NULL)  /* end of the source pathname */
d240 2
a241 2
     *cdptr = NULL ;    /* terminate the destination pathname */
     break ;
d243 2
a244 2

   switch (*csptr)
d246 41
a286 38
     case '.' : /* RISC OS to directory seperator */
                *cdptr++ = dir_sep ;
                csptr++ ;
                loop = 0 ;
                filesepseen = FALSE ; /* for this leafname */
                break ;

     case '/' : /* convert to file seperator */
                if (filesepseen)
                 return_error1(char *,err_invalidname,source);
                *cdptr++ = file_sep ;
                csptr++ ;
                loop++ ;
                point = loop ;
                filesepseen = TRUE ;
                break ;

     default  : /* perform standard name mapping */
                if (filesepseen)
                 {
                  char c = *csptr++;
                  /* should never need to truncate the extension */
//                  if ((loop - point) >= extsize)
//                   return_error1(char *,err_invalidname,source) ;
//                  if (islower(c))
//                   c = toupper(c);
                  *cdptr++ = mapchar(c,ROmapping,DOSmapping) ;
                 }
                else
                 {          
                  char c = *csptr;
//                  if (islower(c))
//                   c = toupper(c) ;
                  *cdptr++ = mapchar(c,ROmapping,DOSmapping) ;
                  csptr++ ;      /* step over this DOS character */
                 }
                loop++ ;
                break ;
d289 8
a296 8

 dprintf((""," converted to \"%s\"\n",dest)) ;

 for (cptr = dest; *cptr; cptr++)
  if (!validchar(valchars,*cptr))
   return_error1(char *,err_invalidname,source);

 return(dest) ;
d299 6
a304 3

/*---------------------------------------------------------------------------*/

d307 68
a374 96
 char *cptr = (char *)&(dentry->FILE_status);
 int   index ;
 int   loop ;
 dprintf(("","buildFILEname: dentry:%p\n",dentry));

 /* "dentry" should contain a valid filename */
 /* copy prefix characters (or upto a space) into the filename buffer */
 for (index=0; ((cptr[index] > ' ') && (index < namsize)); index++)
  name[index] = cptr[index] ;

 /* copy suffix characters (or upto a space) into the filename buffer */
 for (loop=0; ((dentry->FILE_extension[loop] > ' ') && (loop < extsize)); loop++)
  {
   if (loop == 0) /* the first character of the extension */
    name[index++] = file_sep ; /* then place in the file_seperator */
   name[index++] = dentry->FILE_extension[loop] ;
  }

 /* terminate the name */
 name[index] = NULL ;
 dprintf(("","buildFILEname: got:%s\n",name));

 return(name) ;
}

//Calculates the LFN checksum of an 11 bytes dos filename
byte lfnchecksum(char * filename)
{
 byte checksum=0;
 byte lsb;
 int i;
 for(i=0;i<11;i++)
 {
  lsb = (checksum&0x1); //Save the lsb
  checksum = checksum >> 1; // Shift the byte
  lsb = lsb << 7; // Turn saved lsb into msb
  checksum |= lsb;
  checksum += filename[i];
 }

 return checksum;
}

/* returns NULL if short and long names are identical, else NZ */
int  shorten_lfn(char * longfname, char * shortname, char * shortnamebuff, DIR_info * cdir)
{
 // char * longfname : pointer to a null terminated file name
 // char * shortnamebuff : pointer to a 13 byte buffer to store newly created short file name
 // DIR_info * cdir : pointer the dir info structure for the target directory
 int i, j, o, retval, dotseen=0;
 char * extension,c;
 /* check if already a valid short file name */
 memset(shortnamebuff,' ',12);shortnamebuff[12]=0;
 dprintf(("","shorten_lfn: start with -%s-\n",longfname));
 for(i=0,j=0;(i<=12)&&(j<=12);i++,j++)
 {
   c=longfname[i];                      
   if(c=='.')
   {
     if(!dotseen)
     {
       dotseen=i+1;
       while(j<8)
       {
        shortnamebuff[j++]=' ';  // spacefill to 8 
       }
     }
     if(i>8) break ; // too many chars
   }
 dprintf(("","shorten_lfn: check -%x-%c- toupper(c) -%c-\n",c,c,toupper(c)));
   if(c && ((c=='.')||((c==toupper(c)) && (c!=' '))))
   { /* copy over */
     shortnamebuff[j]=c;
 dprintf(("","shorten_lfn: copied -%c-\n",c));
   }
   else
   {
     dprintf(("","shorten_lfn: %d %d %d\n",c,strlen(shortnamebuff),strlen(longfname)));
     if(!c && /*strlen(shortnamebuff)==strlen(longfname) && */((!dotseen && (i<9)) || dotseen))
     { /* end of string .. and identical */
       dprintf(("","shorten_lfn: its a valid DOS SFN\n"));
       retval= 0;
       goto slnfn1;
     }
     break;
   }
 }



 memset(shortnamebuff,'_',8);
 memset(&shortnamebuff[8],' ',4);
 shortnamebuff[12]=NULL;
 for(i=0,o=0;o<6;i++)
 {
  if(longfname[i]==NULL)
d376 30
a405 2
   o=6;
   continue;
d407 7
a413 2
  if(longfname[i]==' ') continue;
  if(longfname[i]=='.')
d415 1
a415 5
   if( &(longfname[i]) == strrchr(longfname,'.') )
   {//If we are currently at the last 'dot' terminator in the filename...
    o=6;      //Ensuring we
    continue; //Drop out of the loop
   }else
d417 1
a417 1
    i++;
d420 2
a421 18
  }
  if(longfname[i] == ('+' || ',' || ';' || '=' || '[' || ']' || '.'))
  {
   shortnamebuff[o] = '_';
  }else
  {
   shortnamebuff[o] = toupper(longfname[i]);
  }
  o++;
 }

 dprintf(("","shorten_lfn: strchr(longfname,'.') = %p, c='%c'\n",strchr(longfname,'.'),*strchr(longfname,'.')));
 //We now have collected the first 6 characters of the short file name.
 if(extension=strrchr(longfname,'.'), extension != NULL) //There is a dot extension
 {//char * 'extension' points to the dot extension
  for(i=0,o=8;o<12;i++)
  {
   if(extension[i]==NULL)
d423 9
a431 2
    o=12; //Break out of loop
    continue;
d433 1
a433 2
   if(extension[i]==' ') continue;
   if(extension[i] == ('+' || ',' || ';' || '=' || '[' || ']'))
d438 1
a438 1
    shortnamebuff[o] = toupper(extension[i]);
d442 34
a475 39
 }
 shortnamebuff[6]='~';
 shortnamebuff[7]='1';
 shortnamebuff[12]=0;
 if(shortnamebuff[9]==' ') shortnamebuff[8]='\0';

 dprintf(("","Here file name is '%s'\n",shortnamebuff));

 DOS_direntry * fentry;
 int index;

 for(i=1;i<99;i++)
 {
  shortnamebuff[7]='0'+(i%10);
  if((i / 10) > 0)
  {
   shortnamebuff[6]='0'+(i/10);
   shortnamebuff[5]='~';
  }
  index=0;
  fentry=findDIRentry(shortnamebuff,cdir,cdir->dir_size,&index);
  if(fentry==NULL)
  {
   i=99;
   continue;
  }
 }


 dprintf(("","shorten_lfn: Started with lfn \"%s\"\n",longfname));
 dprintf(("","shorten_lfn: Created short name \"%s\", char[8]= %x, char[9]= %x, char[10]= %x, char[11]= %x, char[12]= %x, char[13]= %x\n",shortnamebuff,shortnamebuff[8],shortnamebuff[9],shortnamebuff[10],shortnamebuff[11],shortnamebuff[12],shortnamebuff[13]));
 retval=1;
slnfn1: 
  memset(shortname,' ',11);
  memcpy(shortname,shortnamebuff,8);
  memcpy(&shortname[8],&shortnamebuff[9],3);
  if(shortnamebuff[8]=='.') i=8;
  else i=0;
  for(;i<11;i++)
d477 9
a485 1
   if(shortnamebuff[i] == ' ')
d487 1
a487 2
    shortnamebuff[i]=0;
    i=11;
d491 21
a511 1
 return retval;
d514 7
d523 11
a533 9
   int lfnnum,i;
   DOS_lfnentry * lfnentry;
   int charnum=0;
   int nullreached=0;
   for(i=(numreq-2),lfnnum=0;i>=0;i--,lfnnum++)
   {//create the long file name structures
    lfnentry = (DOS_lfnentry*)lfn[i];
    lfnentry->FILE_Ordinal =  ((lfnnum&0x3F)+1);
    if(i==0) lfnentry->FILE_Ordinal |= 0x40; // Last entry 
d535 2
d539 1
a539 1
    if(leafname[charnum]==NULL) nullreached=1;
d543 1
a543 1
    if(leafname[charnum]==NULL) nullreached=1;
d547 1
a547 1
    if(leafname[charnum]==NULL) nullreached=1;
d551 1
a551 1
    if(leafname[charnum]==NULL) nullreached=1;
d555 1
a555 1
    if(leafname[charnum]==NULL) nullreached=1;
d559 1
a559 1
    if(leafname[charnum]==NULL) nullreached=1;
d563 1
a563 1
    if(leafname[charnum]==NULL) nullreached=1;
d567 1
a567 1
    if(leafname[charnum]==NULL) nullreached=1;
d571 1
a571 1
    if(leafname[charnum]==NULL) nullreached=1;
d575 1
a575 1
    if(leafname[charnum]==NULL) nullreached=1;
d579 1
a579 1
    if(leafname[charnum]==NULL) nullreached=1;
d583 1
a583 1
    if(leafname[charnum]==NULL) nullreached=1;
d587 1
a587 1
    if(leafname[charnum]==NULL) nullreached=1;
d589 1
d591 1
a591 1
   }
d594 5
a598 4

/*---------------------------------------------------------------------------*/
/* convertRISCOStoLFN:
 * translate a standard RISC OS name into an extended DOS one.
d600 1
a600 1
char *convertRISCOStoLFN(char *source,char *dest)
d602 33
a634 9
 char      *csptr = source ;
 char      *cdptr = dest ;
 int        loop ;
 int        filesepseen = FALSE ; /* if we have seen the file seperator */
 char      *cptr ;      /* string pointer */
 char       lchr ;      /* last character seen */
 int        point = 0 ; /* position where file extension started */

 if ((source == NULL) || (*source == NULL))
d636 2
a637 23
   dprintf(("","DOSFS: convertRISCOStoLFN: NULL name\n")) ;
   *dest = NULL ;
   return(dest) ;
  }

 dprintf(("","DOSFS: convertRISCOStoLFN: \"%s\"",source)) ;

 lchr = '\0' ; /* no last character */
 cptr = csptr;
 do {
   /* Ensure that "/" characters do not appear at the start or end of the name
    * and that "//" sequences are trapped.
    */
//   if ((*cptr == '/' && (lchr == '\0' || lchr == *cptr || lchr == '.')) || ((lchr == '/') && ((*cptr == '\0') || (*cptr == '.'))))
//    return_error1(char *,err_invalidname,source) ;

   lchr = *cptr++ ; /* remember this character */
 } while (lchr);

 if (*csptr == '$')             /* ROOT directory specifier */
  {
   csptr++ ;
   if (*csptr == '.')           /* RISC OS directory seperator */
d639 2
a640 2
     *cdptr++ = dir_sep ;       /* MSDOS directory seperator */
     csptr++ ;
a641 3
   else
    if (*csptr == NULL)
     *cdptr++ = dir_sep ;
d643 4
a646 1
     *cdptr++ = '$' ;
d648 2
a649 2

 for (loop = 0;;)       /* convert the remainder of the pathname */
d651 1
a651 1
   if (*csptr == NULL)  /* end of the source pathname */
d653 2
a654 52
     *cdptr = NULL ;    /* terminate the destination pathname */
     break ;
    }

   switch (*csptr)
    {
     case '.' : /* RISC OS to directory seperator */
                *cdptr++ = dir_sep ;
                csptr++ ;
                loop = 0 ;
                filesepseen = FALSE ; /* for this leafname */
                break ;

     case '/' : /* convert to file seperator */
//                if (filesepseen)
//                 return_error1(char *,err_invalidname,source);
                *cdptr++ = file_sep ;
                csptr++ ;
                loop++ ;
                point = loop ;
//                filesepseen = TRUE ;
                break ;

     default  : /* perform standard name mapping */
//                if (filesepseen)
//                 {
//                  char c = *csptr++;
                  /* should never need to truncate the extension */
//                  if ((loop - point) >= extsize)
//                   return_error1(char *,err_invalidname,source) ;
//                  if (islower(c))
//                   c = toupper(c);
//                  *cdptr++ = mapchar(c,ROmapping,DOSmapping) ;
//                 }
//                else
//                 {
                  if (loop < 255)    /* characters left */
                   {
                    char c = *csptr;
//                    if (islower(c))
//                     c = toupper(c) ;
                    *cdptr++ = mapchar(c,ROmapping,DOSmapping) ;
                   }
                  else
                   {
                    if (!(module_flags & TRUNCATE_NAMES))
                     return_errorT(char *, err_nametoolong, tok_nametoolong, source, "255");
                   }
                  csptr++ ;      /* step over this DOS character */
//                 }
                loop++ ;
                break ;
d656 53
d710 3
a712 3

 dprintf((""," converted to \"%s\"\n",dest)) ;

d714 4
a717 4
//  if (!validchar(valchars,*cptr))
//   return_error1(char *,err_invalidname,source);

 return(dest) ;
d720 5
a724 3

/*-------------------------------------------------------------------------*/
/* convertDOStoRISCOS:
d726 1
a726 1
char *convertDOStoRISCOS(char *source,char *dest)
d728 10
a737 10
 char *csptr = source ;
 char *cdptr = dest ;
 int   loop ;

 dprintf(("","DOSFS: convertDOStoRISCOS: \"%s\" ",source)) ;

 if (*csptr == dir_sep)
  *cdptr++ = '$' ;

 for (loop = 0;;)
d739 1
a739 1
   if (*csptr == NULL)  /* end of the source pathname */
d741 2
a742 2
     *cdptr = NULL ;    /* terminate filename */
     break ;            /* the for loop */
d744 2
a745 2

   switch (*csptr)
d747 21
a767 18
     case file_sep : /* convert the character to "/" */
                     *cdptr++ = '/' ;
                     csptr++ ;
                     loop++ ;
                     break ;

     case dir_sep  : /* convert to RISC OS directory seperator */
                     *cdptr++ = '.' ;
                     loop = 0 ;
                     csptr++ ;
                     break ;

     default       : /* perform standard name mapping */
                     /* we never truncate here, it's up to the outside world */
                     *cdptr++ = mapchar(*csptr,DOSmapping,ROmapping) ;
                     csptr++ ;
                     loop++ ;
                     break ;
d770 3
a772 3

 dprintf(("","converted to \"%s\"\n",dest)) ;
 return(dest) ;
a773 3

/*---------------------------------------------------------------------------*/
/*> EOF c.DOSnaming <*/
@


4.7
log
@Add some comments (!) and reindent FileSwitch interface
OpsGetPut
  DOSFS_put_bytes no longer passes an unnecessary dummy argument.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFind
  Suggested buffer to FileSwitch is now 1x512 sector (rather than 256).
  Note - nothing seems to use the cluster buffering code in DOSFS,
indeed nothing ever malloc()s a buffer.
  Check at line 237 of OpFind would never be true since FILE_subdir is
not 1, fixed.
  Return an error if the handle to close is invalid.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFile
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFunc
  A failure to find a slot to set the disc title now reports "Dir full"
not "Disc full"
  Reindented.
  Doxygen comments added to FileSwitch layer.

Version 0.99. Tagged as 'DOSFS-0_99'
@
text
@d486 1
a486 1
    lfnentry->FILE_attribute = 0x0F;
d644 1
a644 1
                     return_errorT(char *, err_nametoolong, tok_nametoolong, source, namsizestr);
@


4.6
log
@Rationalise some defines
Many magic numbers changed to exported defines.
Eliminated unused "BOOTblock.h" (was just nesting 1 include file).
Moved non ASCII definitions out of "ASCII.h" then found the remainder weren't used => eliminated.

Version 0.98. Tagged as 'DOSFS-0_98'
@
text
@a640 1
#if 1 /* SMC_TRUNCATE */
a645 1
#endif
@


4.5
log
@Source file subdivision
The sources to DOSFS had become rather jumbled and monolithic
* Split FileSwitch interface out into seperate ops source files.
* Combined international error lookup with MsgTrans code.
* Split utility functions into 'Helpers.c' along with wildcard matching functions.
* Moved DOS naming functions into, erm, 'DOSnaming.c'.
Also
* Makefile tweaked to remove 'symbols' on clean.
* Obsolete 'Help' and 'Syntax' placed in attic.

RAM, debug, and ROM targets built. RAM target tested with a DOS floppy disc.

Version 0.96. Tagged as 'DOSFS-0_96'
@
text
@d22 1
a26 1
#include "ASCII.h"
@


4.4
log
@  #include file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both Norcroft and GCC.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 0.86. Not tagged
@
text
@a18 11
/* RISC OS name:
 *      [$.]<path>
 * RISC OS path:
 *      <filename (max. 10 chars)>[.<path element>]
 *
 * DOS name:
 *      [\]<path>
 * DOS path:
 *      <filename (max. 8 chars)>[.<extension (max. 3 chars)>[\<path element>]
 */
/*---------------------------------------------------------------------------*/
a19 1
#include <stdio.h>
a20 2
#include <stddef.h>
#include <stdarg.h>
d22 2
a23 4
#include <ctype.h>
#include <time.h>
#include <signal.h>
#include "debuglib/debuglib.h"
d25 1
a25 1
#include "kernel.h"
d27 1
a27 1
#include "debug.h"
d29 3
d33 2
a34 7
#include "TIMEconv.h"
#include "DOSnaming.h"
#include "wcompare.h"
#include "FSerrors.h"
#if 1 /* SMC_TRUNCATE */
 #include "DOSFS.h"
#endif
d123 12
d278 267
@


4.3
log
@   Update of DOSFS to handle Long File Names and FAT32 (up to 2GB)
Detail:
   Extend DOSFS to correctly recognise FAT32 DOS images and to
   use the Long File Name extensions. NOTE that there is still
   a 2gb size limit imposed by the max filecore image file
   size limitiations. NOTE also that as yet there is no support for
   UTF encoding of file names.
Admin:
   Tested at castle and with beta testers.
   Modifications are castle and castle assigned IP (from CJB)


Version 0.79. Tagged as 'DOSFS-0_79'
@
text
@d42 8
a49 8
#include "h.ASCII"
#include "h.debug"
#include "h.ADFSshape"
#include "h.DOSshape"
#include "h.TIMEconv"
#include "h.DOSnaming"
#include "h.wcompare"
#include "h.FSerrors"
d51 1
a51 1
 #include "h.DOSFS"
@


4.2
log
@Deleted some dead variables and switches.
Eliminated MOVS and R14 fiddling to achieve 32 bit compatibility
RISCOS Ltd made 3 changes in their sources
 - ensure disc titles don't contain rogue characters (added)
 - files with time,date,and reserved fields of zero appears as DEADDEAD
   which is silly since Winodws uses this to mark a file unstamped which
   isn't quite the same thing! (not added)
 - syslog debugging support (not added)

Version 0.69. Tagged as 'DOSFS-0_69'
@
text
@d39 1
d59 1
a59 1
  if (init >= 128) return -1;    /* Allow top bit set characters */
d90 8
a97 8
 int index ;

 /* return the character position of the passed character (or 0 if none) */
 for (index = 0; (text[index] != NULL); index++)
  if (text[index] == marker)
   return(index) ;

 return(0) ;
d117 3
a119 1
/* return a string containing the text after the given character */
d125 1
d128 1
a128 1
   int len = strlen(text) ;
d132 1
a132 1
    strncpy(newptr,&(text[cpos + 1]),(len - (cpos + 1))) ;
d148 2
a149 2
 char string1[DOSnamesize] ;
 char string2[DOSnamesize] ;
d188 1
a188 1
   tracef0("DOSFS: convertRISCOStoDOS: NULL name\n") ;
d193 1
a193 1
 tracef1("DOSFS: convertRISCOStoDOS: \"%s\"",source) ;
d254 4
a257 4
                  if ((loop - point) >= extsize)
                   return_error1(char *,err_invalidname,source) ;
                  if (islower(c))
                   c = toupper(c);
d261 113
a373 2
                 {
                  if (loop < RISCOStruncate)    /* characters left */
d376 2
a377 2
                    if (islower(c))
                     c = toupper(c) ;
d388 1
a388 1
                 }
d394 1
a394 1
 tracef1(" converted to \"%s\"\n",dest) ;
d396 3
a398 3
 for (cptr = dest; *cptr; cptr++)
  if (!validchar(valchars,*cptr))
   return_error1(char *,err_invalidname,source);
d403 1
d413 1
a413 1
 tracef1("DOSFS: convertDOStoRISCOS: \"%s\" ",source) ;
d449 1
a449 1
 tracef1("converted to \"%s\"\n",dest) ;
@


4.1
log
@Initial revision
@
text
@d73 1
a73 1
static char mapchar(char cchr,char *fromlist,char *tolist)
a155 10
#if 0 /* SMC_FIX */
   if (strpbrk(wcname,string1) == NULL)
    {
     tracef0("namematch: no extension present\n") ;
     if (strpbrk(fname,string1) != NULL)
      return(FALSE) ; /* extension present in full filename */
     else
      return(TRUE) ; /* no extension present - filenames matched */
    }
#endif
a158 6

#if 0 /* SMC_FIX */
   /* deal with truncated DOS names on RISC OS */
   string2[strlen(string2) + 1] = '\0' ;
   string2[strlen(string2)] = wcmult ;
#endif
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

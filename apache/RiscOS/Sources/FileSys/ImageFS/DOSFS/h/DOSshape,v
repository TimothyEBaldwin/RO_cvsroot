head	4.12;
access;
symbols
	DOSFS-1_14:4.12
	DOSFS-1_13:4.12
	DOSFS-1_12:4.12
	DOSFS-1_11:4.11
	DOSFS-1_10:4.11
	DOSFS-1_09:4.11
	DOSFS-1_08:4.11
	DOSFS-1_07:4.10
	DOSFS-1_06:4.10
	DOSFS-1_05:4.9
	DOSFS-1_04:4.9
	DOSFS-1_03:4.9
	DOSFS-1_02:4.9
	DOSFS-1_01:4.9
	DOSFS-1_00:4.9
	DOSFS-0_99:4.9
	DOSFS-0_98:4.8
	DOSFS-0_97:4.7
	DOSFS-0_96:4.7
	DOSFS-0_95:4.7
	DOSFS-0_94:4.7
	DOSFS-0_93:4.7
	DOSFS-0_92:4.7
	DOSFS-0_91:4.7
	DOSFS-0_90:4.7
	DOSFS-0_89:4.7
	DOSFS-0_88:4.7
	DOSFS-0_87:4.7
	DOSFS-0_86:4.7
	DOSFS-0_85:4.7
	DOSFS-0_84:4.7
	DOSFS-0_83:4.7
	DOSFS-0_82:4.7
	DOSFS-0_81:4.7
	DOSFS-0_80:4.7
	DOSFS-0_79:4.7
	RO_5_07:4.6
	DOSFS-0_78:4.6
	DOSFS-0_77:4.5
	DOSFS-0_76:4.5
	DOSFS-0_75:4.5
	DOSFS-0_74:4.5
	DOSFS-0_73:4.4
	DOSFS-0_72:4.4
	DOSFS-0_71:4.3
	DOSFS-0_70:4.3
	DOSFS-0_69:4.2
	DOSFS-0_68:4.2
	DOSFS-0_67:4.2
	DOSFS-0_66:4.2
	DOSFS-0_65:4.1
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	DOSFS-0_64:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_DOSFS_0_63:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.12
date	2018.02.19.00.06.08;	author jlee;	state Exp;
branches;
next	4.11;
commitid	ic65jLota7NRUorA;

4.11
date	2014.11.02.17.53.56;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	jLG2K2peqo1FyDWx;

4.10
date	2014.06.25.19.37.23;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	gFu51vOmpefejWFx;

4.9
date	2013.01.13.18.52.37;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	oq0uLRDtA5Y625Aw;

4.8
date	2013.01.13.18.49.47;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	fjzSOoRRnhA815Aw;

4.7
date	2004.09.30.21.59.07;	author jballance;	state Exp;
branches;
next	4.6;

4.6
date	2003.07.25.14.29.07;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2003.05.23.17.21.16;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2003.01.31.10.50.58;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.08.10.09.01;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.16.16.00.44;	author rsprowso;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.33.06;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.33.06;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.55.27;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.37.51;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.34.19;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Reject overly-large discs, and other invalid things
Detail:
  c/Accessors, h/Accessors, Makefile - Added some simple 'image accessor' routines to abstract over accessing the underlying disc/image file. These accept 64bit disc addresses and will check to make sure any size limits imposed by the lower-level API are adhered to (512MB limit for FileCore_DiscOp, or extent of image file for OS_GBPB)
  h/MsgTrans, Resources/Germany/Messages, Resources/UK/Messages - Add a couple of new error messages
  h/Helpers - Add a couple of macros to simplify reading 16/32bit values that are split into multiple bytes in struct definitions. Change writeWORD & loadWORD to accept void* instead of char* so they can be used with other types like 'byte'
  h/DOSshape - Add '0' suffix to some struct members so they can be used with new READ_0123 macro
  h/ADFSshape - Make sure put_doublestep is safe to use with bools
  c/DOSdirs - Remove pointless malloc of small temporary array
  c/DOSclusters - Use new READ_ macros in max_sector()
  c/DOSFS - Use new READ_ macros so code is less painful to read. Use new image accessor system to get rid of some boilerplate for reading from the disc (+ extra error checks). Change 32bit values to 64bit where it looks like it's necessary, and use bools in place of a couple of 0/1 ints. Reject any discs which are too big for the 32bit fields in the ADFS disc record.
  c/OpsFunc - Update DOSFS_image_open in ways similar to the code in c/DOSFS, making use of READ_, image accessor, 64bit values, and adding extra error checks.
Admin:
  Tested with assorted large & small image files & SD cards on a BB-xM, and some DOS/Atari floppy discs on a RiscPC
  FAT partitions larger than 4GB (or which extend past the 4GB FileSwitch limit) are now rejected, as are image files which have been truncated
  A future improvement could be to lift the disc/partition identification code out of c/DOSFS and c/OpsFunc and unify it, since both files contain fairly similar code
  German messages are in need of translation


Version 1.12. Tagged as 'DOSFS-1_12'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*> h.DOSshape <*/
/*---------------------------------------------------------------------------*/
/* MS-DOS and ATARI DOS floppy disc formats       Copyright (c) 1988 JGSmith */
/*                                                                           */
/* NOTE: due to the way the ARM C compiler generates shorts (i.e. word       */
/*       aligned), to generate the correct byte-aligned structures we will   */
/*       either use bit-fields or split the short into a LO and HI byte      */
/*       pair, depending on the exact requirements                           */
/*---------------------------------------------------------------------------*/

#ifndef __h_DOSshape
#define __h_DOSshape

/*---------------------------------------------------------------------------*/

#define log2DOSsecsize  (9)     /* fixed in MSDOS */
#define DOSsecsize      (1 << log2DOSsecsize)

#define file_sep        ('.')   /* standard MSDOS file seperator */
#define dir_sep         ('\\')  /* standard MSDOS directory seperator */
#define dir_sep_string  "\\"
#define eco_dir_sep     ('/')   /* MSDOS extension identifier under RISC OS */

/* valid DOS filename characters (NOTE: lower case treated as upper) */
#define valchars       "*?ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.\\~`!@@#$%^&()_-{}' "

/* The following define a two way mapping between characters valid in DOS names but not
 * in RISC OS names and characters valid in RISC OS names but not DOS names.  Note that
 * '#' (RISC OS single character wild card) maps to the DOS equivalent '?'.
 */
#define DOSmapping     "#?&@@%$^ "
#define ROmapping      "?#+=;<> "

#define namsize (8)             /* maximum size of a filename */
#define extsize (3)             /* maximum size of a filename extension */
#define spare1  (8)            /* number of free bytes in a directory entry */

/* size of a standard MSDOS name (including seperator and NULL terminator) */
#define DOSnamesize (namsize + 1 + extsize + 1)

/*---------------------------------------------------------------------------*/
/* directory description */

typedef struct {
                byte FILE_status ;             /* first char OR status */
                byte FILE_name[namsize - 1] ;  /* remainder of filename */
                byte FILE_extension[extsize] ; /* standard MSDOS extension */
                byte FILE_attribute ;          /* attribute byte */
                byte FILE_reserved[spare1] ;   /* reserved space (NULL) */
                byte FILE_clust32;             /* Top 1/2 word of cluster num */
                byte FILE_clust32HI;           /*  ^^  Only in FAT32  ^^  */
                byte FILE_time ;               /* time created/updated */
                byte FILE_timeHI ;
                byte FILE_date ;               /* date created/updated */
                byte FILE_dateHI ;
                byte FILE_cluster ;            /* first file cluster */
                byte FILE_clusterHI ;
                word FILE_size ;               /* size of file in bytes */
               } DOS_direntry ;

typedef struct {
                byte FILE_status ;             /* first char OR status */
                byte FILE_name[namsize - 1] ;  /* remainder of filename */
                byte FILE_extension[extsize] ; /* standard MSDOS extension */
                byte FILE_attribute ;          /* attribute byte */
                byte FILE_NTRes;
                byte FILE_CrtTimeTenth;
                byte FILE_CrtTime;
                byte FILE_CrtTimeHi;
                byte FILE_CrtDate;
                byte FILE_CrtDateHi;
                byte FILE_LstAccDate;
                byte FILE_LstAccDateHi;
                byte FILE_HiCluster;
                byte FILE_HiClusterHi;
                byte FILE_time ;               /* time created/updated */
                byte FILE_timeHI ;
                byte FILE_date ;               /* date created/updated */
                byte FILE_dateHI ;
                byte FILE_cluster ;            /* first file cluster */
                byte FILE_clusterHI ;
                word FILE_size ;               /* size of file in bytes */
               } DOS_newdirentry ;
/* MACROs to interpret the above byte pairs */
#define get_FILE_time(d)    ((d)->FILE_time | ((d)->FILE_timeHI << 8))
#define get_FILE_date(d)    ((d)->FILE_date | ((d)->FILE_dateHI << 8))
#define get_FILE_cluster(d,i) ((((d)->FILE_cluster) | ((d)->FILE_clusterHI << 8) | ((d)->FILE_clust32 << 16) | ((d)->FILE_clust32HI << 24)) & FAT_entry_mask(i) )   
                            

#define put_FILE_time(d,d2,v)    {                                              \
                               (d) = ((v) & 0xFF) ;               \
                               (d2) = (((v) >> 8) & 0xFF) ;      \
                              }
#define put_FILE_date(d,d2,v)    {                                              \
                               (d) = ((v) & 0xFF) ;               \
                               (d2) = (((v) >> 8) & 0xFF) ;      \
                              }
#define put_FILE_cluster(d,v,i) {                                            \
                               (d)->FILE_cluster = ((v) & 0xFF) ;            \
                               (d)->FILE_clusterHI = (((v) >> 8) & 0xFF);    \
                               if(i->disc_FATentry == 32) {                  \
                               (d)->FILE_clust32 = (((v) >> 16) & 0xFF);     \
                               (d)->FILE_clust32HI = (((v) >> 24) & 0xFF);}  \
                              }

/*---------------------------------------------------------------------------*/

typedef struct {
	byte FILE_Ordinal; // Ordinal field
	byte FILE_uchar0;  // Unicode chars...
	byte FILE_uchar0_hi;
	byte FILE_uchar1;
	byte FILE_uchar1_hi;
	byte FILE_uchar2;
	byte FILE_uchar2_hi;
	byte FILE_uchar3;
	byte FILE_uchar3_hi;
	byte FILE_uchar4;
	byte FILE_uchar4_hi; 
	byte FILE_attribute; // attribute byte
	byte reserved1;
	byte FILE_checksum; // Checksum of 8.3 filename of owner entry
	byte FILE_uchar5;  // Unicode chars...
	byte FILE_uchar5_hi;
	byte FILE_uchar6;
	byte FILE_uchar6_hi;
	byte FILE_uchar7;
	byte FILE_uchar7_hi;
	byte FILE_uchar8;
	byte FILE_uchar8_hi;
	byte FILE_uchar9;
	byte FILE_uchar9_hi;
	byte FILE_uchar10;
	byte FILE_uchar10_hi;
	byte reserved2;
	byte reserved3;
	byte FILE_uchar11;  // Unicode chars...
	byte FILE_uchar11_hi;
	byte FILE_uchar12; 
	byte FILE_uchar12_hi;
} DOS_lfnentry;



/* bytes 0 and 1 in the spare bytes are used to store the RISC OS filetype */
/* (This usage does NOT clash with DRDOS 5.0 or MSDOS 3.21) */
#define get_FILE_ROStype(d)     (                                            \
                                 (((d)->FILE_reserved[0]) << 0) |            \
                                 (((d)->FILE_reserved[1] & 0x0F) << 8)       \
                                )

/* when putting the type,if zero set the top 4 bits to aid filetype deduction later */
#define put_FILE_ROStype(d,v)   {                                             \
                                 (d)->FILE_reserved[0] = ((v >>  0) & 0xFF) ; \
                                 (d)->FILE_reserved[1] = ((v >>  8) & 0x0F) ; \
                                 if (v == 0) (d)->FILE_reserved[1] = 0xF0   ; \
                                }

#define erase_ROStype(d)        {                                             \
                                 (d)->FILE_reserved[0] = 0x00 ;               \
                                 (d)->FILE_reserved[1] = 0x00 ;               \
                                }

/*---------------------------------------------------------------------------*/
/* status byte "FILE_status" */
#define FILE_lastentry (0x00) /* never been used (end of directory) */
#define FILE_deleted   (0xE5) /* replaces first character of filename */
#define FILE_directory ('.')  /* directory entry (0x2E) */

/* attribute byte "FILE_attribute" */
#define FILE_readonly (1 << 0) /* open for output generates error */
#define FILE_hidden   (1 << 1) /* file excluded from directory searches */
#define FILE_system   (1 << 2) /* file excluded from directory searches */
#define FILE_volume   (1 << 3) /* (filename + extension) is disc label */
#define FILE_win95    0xF      /* bits used to mark Windows 95 long filename */
#define FILE_subdir   (1 << 4) /* sub-directory (excluded from dir. searches */
#define FILE_archive  (1 << 5) /* file has been updated */

/* time format (bits = hhhhhmmmmmmsssss) */
#define hour_shift (11)
#define min_shift  (5)
#define sec_shift  (0)
#define hour_mask  (0xF800) /* 0..23 */
#define min_mask   (0x07E0) /* 0..59 */
#define sec_mask   (0x001F) /* 0..29 (seconds/2) */

/* date format (bits = yyyyyyymmmmddddd) */
#define year_shift (9)
#define mon_shift  (5)
#define day_shift  (0)
#define year_mask  (0xFE00) /* 0..119 (1980 - 2099) */
#define mon_mask   (0x01E0) /* 1..12 */
#define day_mask   (0x001F) /* 1..31 */

#define MSDOSbaseyear (1980)

/*---------------------------------------------------------------------------*/
/* MS-DOS winchester disc partition table */

typedef struct {
                byte boot_ind ;       /* is this the boot partition */
                byte start_head ;     /* partition start head */
                byte start_sec ;      /* partition start sector */
                byte start_cyl ;      /* partition start cylinder */
                byte sys_ind ;        /* system identifier */
                byte end_head ;       /* partition end head */
                byte end_sec ;        /* partition end sector */
                byte end_cyl ;        /* partition end cylinder */
                byte disc_rel_b0 ;    /* sectors from start of disk (lo) */
                byte disc_rel_b1 ;    /* sectors from start of disk (lo) */
                byte disc_rel_b2 ;    /* sectors from start of disk (hi) */
                byte disc_rel_b3 ;    /* sectors from start of disk (hi) */
                byte part_len_b0 ;    /* partition length in sectors (lo) */
                byte part_len_b1 ;    /* partition length in sectors (lo) */
                byte part_len_b2 ;    /* partition length in sectors (hi) */
                byte part_len_b3 ;    /* partition length in sectors (hi) */
               } partition_entry ;

/*---------------------------------------------------------------------------*/
/* MS-DOS boot sector information */

#define DOS_BOOT_sector      (1)               /* always sector 1 track 0 */
#define DOS_FAT_sector       (2)               /* always sector 2 track 0 */
#define DOS_PARTITION_sector (DOS_BOOT_sector) /* always sec 1 cyl 0 head 0 */
#define DOS_PARTITION_signature (0xAA55)

typedef struct {
                byte BOOT_JMP[3] ;       /* JMP (&EA &xxxx) or (&EB &xx &90) */
                byte BOOT_OEM[8] ;       /* OEM identity */
                byte BOOT_secsize ;      /* sector size in bytes */
                byte BOOT_secsizeHI ;
                byte BOOT_secalloc ;     /* sectors per allocation */
                byte BOOT_reserved ;     /* number of reserved sectors */
                byte BOOT_reservedHI ;
                byte BOOT_num_fats ;     /* number of FATs */
                byte BOOT_root_dir ;     /* number of dir entries in root */
                byte BOOT_root_dirHI ;
                byte BOOT_max_sect ;     /* maximum sector number */
                byte BOOT_max_sectHI ;
                byte BOOT_magic ;        /* media descriptor byte */
                byte BOOT_FAT_size ;     /* FAT size in sectors */
                byte BOOT_FAT_sizeHI ;
                byte BOOT_secstrack ;    /* sectors per track */
                byte BOOT_secstrackHI ;
                byte BOOT_heads ;        /* number of heads */
                byte BOOT_headsHI ;
                byte hidden0 ;        /* number of hidden sectors */
                byte hidden1 ;
                byte hidden2 ;
                byte hidden3 ;
                byte big_sect0 ;      /* number of sectors for >32Mb partitions */
                byte big_sect1 ;
                byte big_sect2 ;
                byte big_sect3 ;
                union {                  /* must be on a word boundary */
                        struct {//This interpretation is used for fat12 and fat16 BPB's
                                byte driveno ;       /* drive number */
                                byte unused ;
                                byte sig_rec ;       /* extended boot record signature (0x29) */
                                byte volid0 ;        /* 32 bit volume id */
                                byte volid1 ;
                                byte volid2 ;
                                byte volid3 ;
                                byte vol_label[11] ;
                                byte resl[8] ;       /* actually "FATnn   ", where nn=12/16 */
                                byte code[384] ;
                                byte partitions[4*sizeof(partition_entry)] ;
                                byte BOOT_signature ;    /* identifier 0x55 */
                                byte BOOT_signatureHI ;  /* identifier 0xAA */
                        } fat12 ;
                        struct {//This is used only on fat32 BPB's
                                byte FAT_sz0;
                                byte FAT_sz1;
                                byte FAT_sz2;
                                byte FAT_sz3;
                                byte ext_flags;
                                byte ext_flagsHI;
                                byte FSver;
                                byte FSverHI;
                                byte RootClus0;
                                byte RootClus1;
                                byte RootClus2;
                                byte RootClus3;
                                byte FS_Info;
                                byte FS_InfoHI;
                                byte BKBootSector;
                                byte BKBootSectorHI;
                                byte Reserved0;
                                byte Reserved1;
                                byte Reserved2;
                                byte Reserved3;
                                byte Reserved4;
                                byte Reserved5;
                                byte Reserved6;
                                byte Reserved7;
                                byte Reserved8;
                                byte Reserved9;
                                byte Reserved10;
                                byte Reserved11;
                                byte DrvNum;
                                byte Reserved12;
                                byte BootSig;
                                byte VolID0;
                                byte VolID1;
                                byte VolID2;
                                byte VolID3;
                                char VolLab[11];
                                char FSType[8]; //Will be "FAT32   "
                                char code[420]; //x86 Boot Code
                                byte BOOT_signature ;    /* identifier 0x55 */
                                byte BOOT_signatureHI ;  /* identifier 0xAA */
                        } fat32 ; 
               } BOOT_extra ;
              } DOS_bootsector ;

/*---------------------------------------------------------------------------*/

/* read the sector size from the BOOT BLOCK */
#define sector_size(bb)  (((bb)->BOOT_secsizeHI << 8) | ((bb)->BOOT_secsize))

/* calculate the size (in bytes) of a cluster */
#define cluster_size(bb) ((bb)->BOOT_secalloc * sector_size(bb))

/* Due to the way the NorCroft compiler word-aligns structure starts, we
 * will initially describe the winchester partition table as a collection
 * of characters.
 */
typedef struct {
                /* boot code */
                byte OS_code[0x01BE] ;
                /* partition 0 */
                byte p0_boot_ind ;    /* is this the boot partition */
                byte p0_start_head ;  /* partition start head */
                byte p0_start_sec ;   /* partition start sector */
                byte p0_start_cyl ;   /* partition start cylinder */
                byte p0_sys_ind ;     /* system identifier */
                byte p0_end_head ;    /* partition end head */
                byte p0_end_sec ;     /* partition end sector */
                byte p0_end_cyl ;     /* partition end cylinder */
                byte p0_disc_rel_b0 ; /* sectors from start of disk (lo) */
                byte p0_disc_rel_b1 ; /* sectors from start of disk (lo) */
                byte p0_disc_rel_b2 ; /* sectors from start of disk (hi) */
                byte p0_disc_rel_b3 ; /* sectors from start of disk (hi) */
                byte p0_part_len_b0 ; /* partition length in sectors (lo) */
                byte p0_part_len_b1 ; /* partition length in sectors (lo) */
                byte p0_part_len_b2 ; /* partition length in sectors (hi) */
                byte p0_part_len_b3 ; /* partition length in sectors (hi) */
                /* partition 1 */
                byte p1_boot_ind ;    /* is this the boot partition */
                byte p1_start_head ;  /* partition start head */
                byte p1_start_sec ;   /* partition start sector */
                byte p1_start_cyl ;   /* partition start cylinder */
                byte p1_sys_ind ;     /* system identifier */
                byte p1_end_head ;    /* partition end head */
                byte p1_end_sec ;     /* partition end sector */
                byte p1_end_cyl ;     /* partition end cylinder */
                byte p1_disc_rel_b0 ; /* sectors from start of disk (lo) */
                byte p1_disc_rel_b1 ; /* sectors from start of disk (lo) */
                byte p1_disc_rel_b2 ; /* sectors from start of disk (hi) */
                byte p1_disc_rel_b3 ; /* sectors from start of disk (hi) */
                byte p1_part_len_b0 ; /* partition length in sectors (lo) */
                byte p1_part_len_b1 ; /* partition length in sectors (lo) */
                byte p1_part_len_b2 ; /* partition length in sectors (hi) */
                byte p1_part_len_b3 ; /* partition length in sectors (hi) */
                /* partition 2 */
                byte p2_boot_ind ;    /* is this the boot partition */
                byte p2_start_head ;  /* partition start head */
                byte p2_start_sec ;   /* partition start sector */
                byte p2_start_cyl ;   /* partition start cylinder */
                byte p2_sys_ind ;     /* system identifier */
                byte p2_end_head ;    /* partition end head */
                byte p2_end_sec ;     /* partition end sector */
                byte p2_end_cyl ;     /* partition end cylinder */
                byte p2_disc_rel_b0 ; /* sectors from start of disk (lo) */
                byte p2_disc_rel_b1 ; /* sectors from start of disk (lo) */
                byte p2_disc_rel_b2 ; /* sectors from start of disk (hi) */
                byte p2_disc_rel_b3 ; /* sectors from start of disk (hi) */
                byte p2_part_len_b0 ; /* partition length in sectors (lo) */
                byte p2_part_len_b1 ; /* partition length in sectors (lo) */
                byte p2_part_len_b2 ; /* partition length in sectors (hi) */
                byte p2_part_len_b3 ; /* partition length in sectors (hi) */
                /* partition 3 */
                byte p3_boot_ind ;    /* is this the boot partition */
                byte p3_start_head ;  /* partition start head */
                byte p3_start_sec ;   /* partition start sector */
                byte p3_start_cyl ;   /* partition start cylinder */
                byte p3_sys_ind ;     /* system identifier */
                byte p3_end_head ;    /* partition end head */
                byte p3_end_sec ;     /* partition end sector */
                byte p3_end_cyl ;     /* partition end cylinder */
                byte p3_disc_rel_b0 ; /* sectors from start of disk (lo) */
                byte p3_disc_rel_b1 ; /* sectors from start of disk (lo) */
                byte p3_disc_rel_b2 ; /* sectors from start of disk (hi) */
                byte p3_disc_rel_b3 ; /* sectors from start of disk (hi) */
                byte p3_part_len_b0 ; /* partition length in sectors (lo) */
                byte p3_part_len_b1 ; /* partition length in sectors (lo) */
                byte p3_part_len_b2 ; /* partition length in sectors (hi) */
                byte p3_part_len_b3 ; /* partition length in sectors (hi) */
                /* signature */
                byte signature_lo ;   /* should always be "0x55" */
                byte signature_hi ;   /* should always be "0xAA" */
               } DOS_partition ;

/* static winchester shape */
#define wini_sectors    (17)    /* number of sectors per track (head) */
#define wini_heads      (4)     /* number of heads per cylinder */

/* "boot_ind" values: */
#define bootable        (0x80)  /* This is the bootstrapped partition */

/* "sys_ind" values: */
#define not_allocated   (0x00)  /* unknown - partition not used */
#define partition_DOS   (0x01)  /* partition is a MS-DOS filesystem */
#define partition_DR    (0x03)  /* partition is a DR-DOS filesystem */
#define partition_NCR   (0x04)  /* partition is a NCR PRI-DOS filesystem */

/* Note: The partitions can appear in any order (i.e. the standard PC
 *       formatter usually utilises partition entry 3 first)
 */

/* Convert a winchester cylinder/head/sector into a sector number */
#define WiniSector(cyl,head,sec)        (                                     \
                                         ((sec) - 1) +                        \
                                         ((head) * wini_sectors) +            \
                                         ((cyl) * (wini_heads*wini_sectors))  \
                                        )

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* DOS FAT sector(s) */

/* Length of FAT entries */
#define short_FAT_entry_len     (12)
#define long_FAT_entry_len      (16)

#define FAT_entry_mask(dd)      ((1 << (dd)->disc_FATentry) - 1)

/* The following structure is purely for information. None of the fields
 * will be accessed, and the actual structure is only ever used as a
 * reference to a correct FAT structure.
 */
typedef struct {
                byte FAT_magic ;         /* disc identity byte */
                byte FAT_spare[2] ;      /* 0xFFFF - dummy FAT entries */
                byte FAT_info[1] ;       /* start of FAT information */
               } fFAT_sector ;           /* floppy FAT sector */

/* first allocatable cluster */
#define CLUSTER_first(dd)       ((0x0002) & FAT_entry_mask(dd))

/* unused cluster */
#define CLUSTER_unused(dd)      ((0x0000) & FAT_entry_mask(dd))

/* >= marks end of file */
#define CLUSTER_end(dd)         ((0x0fffFFF8) & FAT_entry_mask(dd))

/* marks end of file (as written) */
#define CLUSTER_rend(dd)        ((0x0fffFFFF) & FAT_entry_mask(dd))

/* bad cluster if NOT part of file chain */
#define CLUSTER_bad(dd)         ((0x0fffFFF7) & FAT_entry_mask(dd))

/* >= are reserved */
#define CLUSTER_resvd(dd)       ((0x0fffFFF0) & FAT_entry_mask(dd))

/* the FAT immediately follows the boot sector on the disc
 * (2nd actual sector in the first track)
 *
 * two copies of the FAT are written (the second immdiately after the
 * first)
 *
 * to convert a cluster number to a logical sector address
 * sector = ((cluster - CLUSTER_first) * (sectors per cluster)) + data
 * ----------------------------------
 * | BOOT record                    |
 * ----------------------------------
 * | 1st FAT (variable size)        |
 * ----------------------------------
 * | 2nd FAT (variable size)        |
 * ----------------------------------
 * | ROOT directory (variable size) |
 * ----------------------------------
 * | data area                      |
 * |                                |
 *
 * cluster number to FAT data address:
 *  {
 *   bitaddress = (FAT_entry_len * current_cluster)
 *   byteaddress = (((bitaddress & 0xFFFFFFF8) >> 3) + FAT_base_address)
 *   shift = (bitaddress & 0x00000007)
 *   LOAD WORD AT byteaddress
 *   next_cluster = ((datavalue >> shift) & FAT_entry_mask)
 *  }
 *
 * MSDOS cluster to MSDOS sector:
 *  sector = ((cluster - CLUSTER_first) * secs_per_cluster) + data_start_sector
 *
 * NOTE: when converting MSDOS addresses to ADFS addresses
 *       number of sectors per track is MSDOS sectors
 *       NO sectors 0s exist under MSDOS (add 1 sector per track up disc)
 *       addr = (sector * secsize) + (((sector - 1) / secstrk) * secsize)
 *
 * DOS cluster mapping:
 * the first 2 FAT entries contain disc structure information
 * (bytes 1 and 2 always contain &FFFF)
 * byte 0 is the disc type byte:
 *   FF      DS 8 sectors/40 tracks 320K
 *   FE      SS 8 sectors/40 tracks 160K
 *   FD      DS 9 sectors/40 tracks 360K
 *   FC      SS 9 sectors/40 tracks 180K
 *   FB      SS 9 sectors/80 tracks 360K
 *   FA      ???
 *   F9      DS 9 sectors/80 tracks 720K (Atari and MSDOS 3.2)
 *   F8      SS 9 sectors/80 tracks 360K (Atari) or IBM fixed disk
 *
 * the third FAT entry begins the mapping of the data area (cluster 002)
 *
 * cluster entries point to the NEXT cluster in the file (the first cluster
 * pointer being kept in the directory entry)
 *
 * clusters &FF8 -> &FFF mark the last cluster of a file
 * cluster values &FF0 -> &FF7 are reserved clusters
 */

#define MSDOStoADFS(sec,size,strk) ((sec * size) + (((sec - 1) / strk) * size))

/* convert logical MSDOS sector number to track/sector pairs */
#define MSDOStrack(sector,dr)  ((sector - 1) / (secspertrk(dr) - 1))
#define MSDOSsector(sector,dr) (((sector - 1) % (secspertrk(dr) - 1)) + 1)

/*---------------------------------------------------------------------------*/

#define RISCOSnamesize  (10)            /* built into a lot of RISC OS */
#define RISCOStruncate  (namsize)       /* truncate RISC OS names to this */

/*---------------------------------------------------------------------------*/
/* DOS discs have a different disc name size from RISC OS. However, we may
 * be forced to truncate the DOS name to tie into the RISC OS world.
 */

#define discnamesize    (RISCOSnamesize + 1) /* includes terminating NUL */

/*---------------------------------------------------------------------------*/
/* This structure completely describes a DOS disc */

typedef struct DOSdisc {
                struct DOSdisc *disc_next ;           /* next "DOSdisc" entry */
                word            disc_fhand ;          /* FileSwitch handle */
                word            disc_RESVDsec;      /* Number of reserved sectors*/
                word            disc_ROOTsize ;       /* ROOT dir size in secs */
                word            disc_startsec ;       /* start sector of data */
                word            disc_winioffset ;     /* offset to winipartition */
                word            disc_FATentries ;     /* number of FAT entries */
                word            disc_secsize;         /* Sector size in bytes */

                word            disc_FATsize ;        /* byte size of FAT */
                word            disc_FATsecs ;        /* sector size of FAT */
                word            disc_freeclusters ;   /* number of free clusters */
                word            disc_FATentry ;       /* num bits in FAT entry */
                word            disc_RootCluster;     /* FAT32 root cluster */
                DOS_bootsector  disc_boot ;           /* boot sector */
                word            disc_flags ;
#define                          disc_UPDATEID        0x00000001
#define                          disc_CHANGED         0x00000002
                word            disc_FATmodified ;    /* FAT information updated */
                fFAT_sector     disc_FAT ;            /* FAT sectors */
                       } DOSdisc ;

/* NOTE: the actual structure size will be
 *         size = (sizeof(DOSdisc) + ((disc_FATsize) - sizeof(FAT_sector))
 */

#define secsalloc(d) ((d)->disc_boot.BOOT_secalloc)

/*---------------------------------------------------------------------------*/
/* This structure defines an internal file handle (opened onto an image) */

typedef struct FILEhand {
              struct FILEhand *next ;           /* next file handle */
              DOSdisc         *ihand ;          /* image handle */
              char            *fname ;          /* full pathname of object */
              word             opentype ;       /* type of open operation */
              word             loadaddr ;       /* current load address */
              word             execaddr ;       /* current exec address */
              int              startCLUSTER ;   /* CLUSTER where file starts */
              int              currentCLUSTER ; /* CLUSTER in "filebuff" */
              word             filelen ;        /* length of file in bytes */
              word             indexptr ;       /* byte index into file */
              int              modified ;       /* buffer modified flag */
              char            *filebuff ;       /* data buffer */
                        } FILEhand ;

/*---------------------------------------------------------------------------*/
/* Directory structure */

typedef struct DIRin {
                 DOSdisc        *ihand ;           /* image file handle */
                 char           *dir_name ;        /* directory path name */
                 int             dir_root ;        /* directory is ROOT DIR */
                 word            dir_sector ;      /* SIN of DIR on disc */
                 word            dir_size ;        /* size of DIR in bytes */
                 word            dir_parentsec ;   /* SIN of parent DIR */
                 word            dir_parentindex ; /* index into parent */
                 word            dir_parentsize ;  /* size of parent DIR */
                 word            dir_flags ;
#define                           dir_MODIFIED     0x00000001
#define                           dir_LOCKED       0x00000002
                 int             dir_entryoffset;  /* Current extra Length of lfnp array */
                 char           *lfnp[1];
                 DOS_direntry    dir_entries[1] ;  /* DIR entries */
                     } DIR_info ;

/* The above structure relies on a directory NOT being moved and the index
 * into the parent directory staying constant. The only problem that needs
 * to be considered is updating the "DIR_info" structure when a parent
 * directory rename occurs (since this may move the path of the parent dir).
 */

#define set_dir_flags(dir, flags)       (dir)->dir_flags |= (flags)
#define unset_dir_flags(dir, flags)     (dir)->dir_flags &= ~(flags)
#define dir_flag_is_set(dir, flag)      ((dir)->dir_flags & (flag))

/*---------------------------------------------------------------------------*/

typedef struct FS_open_block {
                              word      information ; /* file information */
                              FILEhand *inhand ;      /* internal handle */
                              word      buffsize ;    /* buffer size */
                              word      fileext ;     /* extent */
                              word      falloc ;      /* current allocation */
                             } FS_open_block ;

/*---------------------------------------------------------------------------*/

typedef struct FS_datestamp {
                             word loadaddr ;          /* load address */
                             word execaddr ;          /* exec address */
                            } FS_datestamp ;

/*---------------------------------------------------------------------------*/

typedef struct FS_cat_entry {
                             word type ;              /* object type */
                             word loadaddr ;          /* load address */
                             word execaddr ;          /* exec address */
                             word filelen ;           /* object length */
                             word fileattr ;          /* file attributes */
                            } FS_cat_entry ;

/*---------------------------------------------------------------------------*/

typedef struct FS_dir_block {
                             word objects_read ;      /* records read */
                             int  next_offset ;       /* next offset */
                            } FS_dir_block ;

/*---------------------------------------------------------------------------*/

typedef struct FS_entry_info {
                              word loadaddr ;
                              word execaddr ;
                              word flength ;
                              word attributes ;
                              word type ;
                              char fname[1] ;         /* NULL terminated filename */
                             } FS_entry_info ;

/*---------------------------------------------------------------------------*/

typedef struct FS_free_space {
                              word freespace ;
                              word largestobject ;
                              word discsize ;
                             } FS_free_space ;

/*---------------------------------------------------------------------------*/

typedef struct FS_discop64   {
                              word drivenumber ;      /* bits 0-7: drive number; bits 8-31: reserved, must be zero */
                              word byteaddresslo ;    /* byte address (low word) */
                              word byteaddresshi ;    /* byte address (high word) */
                             } FS_discop64 ;

/*---------------------------------------------------------------------------*/

/* JRS: 4/3/92 THIS IS ALL TOO AWFULL!
 * THESE BITS SHOULDN'T BE USED BY DOSFS
 * They are used by NetFS to store the modification date
 */

/* Private attribute flags (when mapped to the RISC OS world)
 * as defined by the "FSdependant" mask
 */
#define objecthidden  (1 << 8)
#define objectsystem  (1 << 9)
#define objectupdated (1 << 10)

/* JRS: only if these other bits are zero should they be used to store the DOS attributes */
#define NetFSattributebits    (0XFFFFFF00)
#define extraDOSattributebits (0X00000700)

/* All the other bits are currently undefined, but they could possibly be used
 * to contain the left over filename characters if the name is converted to a
 * RISC OS 10 character model (ie. non-EcoLink style naming is used).
 *
JRS: NO, PLEASE DON'T!
 *
 * This would allow the recovery of the full DOS filename if the object
 * was ever copied back to the DOS disc.
 *
 * (This relies on ADFS not updating the top 24bits of the attributes field)
JRS: WHO SAID THIS IS ONLY USED BY ADFS?
 */
/*---------------------------------------------------------------------------*/

#endif /* __h_DOSshape */

/*---------------------------------------------------------------------------*/
/*> EOF h.DOSshape <*/
@


4.11
log
@Fixes to stop DOSFS erroneously claiming partitions that aren't valid
In particular with ADFS, attempting to format an ATA drive purchased from a PC box shifter would often lead to the machine hanging on startup meaning you can't get as far as running !HForm. Further analysis showed that the problem was caused by DOSFS latching onto the PC partition table and attempting to claim the Service_IdentifyDisc. This would then be followed by trying to load the FAT via FileCore in situations where the FAT to load were bigger than the disc size represented by the disc record FileCore has attached to the disc.

This primarily concerns things with partition tables (like a fixed disc).
Things got off to a bad start, some inaccurate keyboard mashing meant the definition for DOS_bootsector added up to 520 bytes, and this was loaded into a malloc'd 512 byte buffer.
The representation of the disc size (bbsize) was being kept in a signed integer, so the single (rather weak) test of checking the boot block declared size (bbsize) being greater than the partition declared size (winisize) would always be accepted for partitions > 2GB.
Additionally, the bbsize was multiplied by DOSsecsize and performed as a byte compare rather than a sector compare, leading to overflow.
Invariably this check would pass (either due to the sign bit being set, or overflow) and DOSFS would claim the service and go ahead and try to read in an unfeasibly large FAT.

DOSFS is now much more strict about checking
* be sure bbsize can fit in the partition by comparing as unsigned number of sectors, convert to bytes later
* be sure bbsize is non zero
* be sure the FAT isn't bigger than bbsize
* be sure the root directory isn't bigger than bbsize
only then claim the service.

DOSshape.h:
Correct the size of the DOS_bootsector back to 512 bytes.
ADFSshape.h:
Remove unused grubby FileCore constants, especially as we're not likely to encounter any 256B/sector drives!
Add the extra disc record fields to get us up to 'BigDisc' in FileCore parlance.
DOSFS.c:
If the rootsize is zero, have a go at using the FAT32 ones instead. Previously this logic only triggered if the FAT32 extended signature was present, but that signature is for the fields that follow it - the FAT size preceeds.
Only update the return variables if we're confident we're going to claim the service.
Remove dead variable 'notracks'.

Tested on a sample of 4 ATA drives > 10GB from different vendors previously used in PCs. All 4 used to hang when installed, now they do not.

Version 1.08. Tagged as 'DOSFS-1_08'
@
text
@d261 1
a261 1
                byte hidden ;        /* number of hidden sectors */
d265 1
a265 1
                byte big_sect ;      /* number of sectors for >32Mb partitions */
d274 1
a274 1
                                byte volid ;         /* 32 bit volume id */
@


4.10
log
@Revise filename shortening rules
The rules DOSFS used to create the short name version of a long filename were quite wide of the recommendations from Microsoft. This causes problems in particular with bootloaders that are a little more simplistic and use the short name form, only to find "BOOTCODE.BIN" has been replaced by "BOOTCO~1.BIN" by DOSFS.
Also, the long filename entried created for new long filenames left the reserved fields unset. Some of these seem to have special meanings to Windows which faults them ("extended attribute handle invalid") when running chkdsk.

DOSnaming.c: replaced the shorten_lfn function, sprinkled in a few token consts, set the reserved fields in long file names to 0
DOSclusters.c/OpsFunc.c/OpsFile.c: remove shorttemp[14] no longer needed, simplify sprintf/memcpy/memcpy into a single sprintf
DOSFS.h: familiar MIN/MAX maxros added

Tested in isolation in harness "test/shorten" and comparing floppy discs generated with "test/shortgen" from Windows and DOSFS.
Fixes ticket #313.

Version 1.06. Tagged as 'DOSFS-1_06'
@
text
@d254 1
a254 1
                byte BOOT_magic ;        /* disc identity byte */
d271 1
a271 1
                                 byte driveno ;       /* drive number */
d323 1
a323 1
                                char code[428]; //x86 Boot Code
@


4.9
log
@Add some comments (!) and reindent FileSwitch interface
OpsGetPut
  DOSFS_put_bytes no longer passes an unnecessary dummy argument.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFind
  Suggested buffer to FileSwitch is now 1x512 sector (rather than 256).
  Note - nothing seems to use the cluster buffering code in DOSFS,
indeed nothing ever malloc()s a buffer.
  Check at line 237 of OpFind would never be true since FILE_subdir is
not 1, fixed.
  Return an error if the handle to close is invalid.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFile
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFunc
  A failure to find a slot to set the disc title now reports "Dir full"
not "Disc full"
  Reindented.
  Doxygen comments added to FileSwitch layer.

Version 0.99. Tagged as 'DOSFS-0_99'
@
text
@a48 1
#define namsizestr "8"
d135 1
a135 1
	byte reserved;
@


4.8
log
@Rationalise some defines
Many magic numbers changed to exported defines.
Eliminated unused "BOOTblock.h" (was just nesting 1 include file).
Moved non ASCII definitions out of "ASCII.h" then found the remainder weren't used => eliminated.

Version 0.98. Tagged as 'DOSFS-0_98'
@
text
@d624 1
a624 1
                 int             dir_entryoffset; //Current extra Length of lfnp array
@


4.7
log
@   Update of DOSFS to handle Long File Names and FAT32 (up to 2GB)
Detail:
   Extend DOSFS to correctly recognise FAT32 DOS images and to
   use the Long File Name extensions. NOTE that there is still
   a 2gb size limit imposed by the max filecore image file
   size limitiations. NOTE also that as yet there is no support for
   UTF encoding of file names.
Admin:
   Tested at castle and with beta testers.
   Modifications are castle and castle assigned IP (from CJB)


Version 0.79. Tagged as 'DOSFS-0_79'
@
text
@a29 4
#include "ASCII.h"

/*---------------------------------------------------------------------------*/

a55 4
/* Acorn allocated filetypes */
#define DOStype         (0xFE4) /* RISC OS DOS filetype */
#define ATARItype       (0xFE3) /* RISC OS Atari filetype */

a447 5
/* This is the point at which we change from "short" FAT entries (floppies)
 * to "long" FAT entries (winchesters).
 */
#define FAT_change              (4087)

@


4.6
log
@When a disc has no title but does have the extended boot sig and the
volumeid is non zero then the disc title will be set to %04X-%04X of
the volumeid instead of "Untitled" which should cut down on ambiguous
disc names a bit.

Version 0.78. Tagged as 'DOSFS-0_78'
@
text
@d43 1
a43 1
#define valchars       "*?ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.\\~`!@@#$%^&()_-{}'"
d49 2
a50 2
#define DOSmapping     "#?&@@%$^"
#define ROmapping      "?#+=;<>"
d55 1
a55 1
#define spare1  (10)            /* number of free bytes in a directory entry */
d73 2
d84 23
d110 2
a111 1
#define get_FILE_cluster(d) ((d)->FILE_cluster | ((d)->FILE_clusterHI << 8))
d113 3
a115 3
#define put_FILE_time(d,v)    {                                              \
                               (d)->FILE_time = ((v) & 0xFF) ;               \
                               (d)->FILE_timeHI = (((v) >> 8) & 0xFF) ;      \
d117 3
a119 3
#define put_FILE_date(d,v)    {                                              \
                               (d)->FILE_date = ((v) & 0xFF) ;               \
                               (d)->FILE_dateHI = (((v) >> 8) & 0xFF) ;      \
d121 1
a121 1
#define put_FILE_cluster(d,v) {                                              \
d123 4
a126 1
                               (d)->FILE_clusterHI = (((v) >> 8) & 0xFF) ;   \
d131 37
d270 8
d279 2
a280 17
                        struct {
                                byte hidden ;
                                byte hiddenHI ;
                                byte code[480] ;
                                byte BOOT_signature ;    /* identifier 0x55 */
                                byte BOOT_signatureHI ;  /* identifier 0xAA */
                        } floppy ;
                        struct {
                                byte hidden ;        /* number of hidden sectors */
                                byte hidden1 ;
                                byte hidden2 ;
                                byte hidden3 ;
                                byte big_sect ;      /* number of sectors for >32Mb partitions */
                                byte big_sect1 ;
                                byte big_sect2 ;
                                byte big_sect3 ;
                                byte driveno ;       /* drive number */
d293 43
a335 1
                        } wini ;
d484 1
a484 1
#define CLUSTER_end(dd)         ((0xFFF8) & FAT_entry_mask(dd))
d487 1
a487 1
#define CLUSTER_rend(dd)        ((0xFFFF) & FAT_entry_mask(dd))
d490 1
a490 1
#define CLUSTER_bad(dd)         ((0xFFF7) & FAT_entry_mask(dd))
d493 1
a493 1
#define CLUSTER_resvd(dd)       ((0xFFF0) & FAT_entry_mask(dd))
d578 1
d583 2
d586 1
d589 1
d637 2
@


4.5
log
@Rewrote Service_IdentifyDisc partly because it was an unreadable mess but
mainly so it can handle fixed discs too - this will be useful for DOS
format USB mass storage.
Also it will have a go at interpreting the partition table on fixed discs.
Tweak to filetyping logic (again!).

Version 0.74. Tagged as 'DOSFS-0_74'
@
text
@d223 1
a223 1
                                byte sig_rec ;       /* external boot signature record (x29) */
@


4.4
log
@Looks like Win2k is zeroing the reserved fields where the RISC OS filetype
is stored leading to directory viewers full of type &000 files.
To combat this the ROS filetype is only used when the creation date is
zero (as DOSFS always clears this when writing a file).
Also,when a settype is performed DOSFS will zero it (this isn't a problem
for DOSFS 0.6x because you could never have a filetype of zero anyway!)

Version 0.72. Tagged as 'DOSFS-0_72'
@
text
@a38 1
#if 1 /* SMC_DIR_CACHE */
a39 2
#endif

d109 1
a109 3
/* when putting the type,clear the Windows creation date field so we can */
/* more reliably spot filetype &000 on discs tinkered with by Win2k */
/* As a side effect Win98 seems to think the file was created in 1601! */
d113 1
a113 4
                                 (d)->FILE_reserved[2] = 0 ;                  \
                                 (d)->FILE_reserved[3] = 0 ;                  \
                                 (d)->FILE_reserved[4] = 0 ;                  \
                                 (d)->FILE_reserved[5] = 0 ;                  \
d182 1
d209 2
d232 2
d235 2
a236 4
                } BOOT_extra ;
                byte BOOT_signature ;    /* identifier 0x55 */
                byte BOOT_signatureHI ;  /* identifier 0xAA */
               } DOS_bootsector ;
a520 1
#if 1 /* SMC_DIR_CACHE */
a521 1
#endif
@


4.3
log
@Missed an ORRNES while 32 bitting,corrected.
Unused MSDOStoSTRING #if'd out to save a massive 112 bytes!
Corrected tracef1 in map_file_rostype which was printing out the
debugging before the variable got assigned.
Conditionally uses FileCore_DiscOp64 now,if available when the module
starts.
Eliminated some local 64 bit time handling code in favour of using that
already in the compiler (thanks to Kevin).
Now requires a compile time switch PCMCIA=<TRUE | FALSE> which leaves in
or takes out the PCMCIA card support.

Version 0.70. Tagged as 'DOSFS-0_70'
@
text
@d112 3
d118 4
@


4.2
log
@Will now recognise the disc title of discs containing Win95 long filenames.
Formatting now pads disc titles with spaces rather than NULs.

Version 0.66. Tagged as 'DOSFS-0_66'
@
text
@d34 1
a34 1
#define log2DOSsecsize  (9)                    /* fixed in MSDOS */
d586 1
a586 1
                              char fname[1] ;   /* NULL terminated filename */
d598 9
@


4.1
log
@Initial revision
@
text
@d133 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

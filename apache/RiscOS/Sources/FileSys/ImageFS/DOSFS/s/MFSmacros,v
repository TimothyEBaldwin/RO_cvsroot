head	4.6;
access;
symbols
	DOSFS-1_14:4.6
	DOSFS-1_13:4.6
	DOSFS-1_12:4.6
	DOSFS-1_11:4.6
	DOSFS-1_10:4.6
	DOSFS-1_09:4.6
	DOSFS-1_08:4.6
	DOSFS-1_07:4.6
	DOSFS-1_06:4.6
	DOSFS-1_05:4.6
	DOSFS-1_04:4.6
	DOSFS-1_03:4.6
	DOSFS-1_02:4.6
	DOSFS-1_01:4.6
	DOSFS-1_00:4.6
	DOSFS-0_99:4.6
	DOSFS-0_98:4.5
	DOSFS-0_97:4.5
	DOSFS-0_96:4.4
	DOSFS-0_95:4.4
	DOSFS-0_94:4.3
	DOSFS-0_93:4.3
	DOSFS-0_92:4.3
	DOSFS-0_91:4.3
	DOSFS-0_90:4.3
	DOSFS-0_89:4.3
	DOSFS-0_88:4.2
	DOSFS-0_87:4.2
	DOSFS-0_86:4.2
	DOSFS-0_85:4.2
	DOSFS-0_84:4.2
	DOSFS-0_83:4.2
	DOSFS-0_82:4.2
	DOSFS-0_81:4.2
	DOSFS-0_80:4.2
	DOSFS-0_79:4.2
	RO_5_07:4.2
	DOSFS-0_78:4.2
	DOSFS-0_77:4.2
	DOSFS-0_76:4.2
	DOSFS-0_75:4.2
	DOSFS-0_74:4.2
	DOSFS-0_73:4.2
	DOSFS-0_72:4.2
	DOSFS-0_71:4.2
	DOSFS-0_70:4.2
	DOSFS-0_69:4.2
	DOSFS-0_68:4.1
	DOSFS-0_67:4.1
	DOSFS-0_66:4.1
	DOSFS-0_65:4.1
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	DOSFS-0_64:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_DOSFS_0_63:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2013.01.13.18.52.40;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	oq0uLRDtA5Y625Aw;

4.5
date	2012.12.07.14.26.03;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	vz81mkusjqgpKivw;

4.4
date	2012.09.02.13.29.02;	author bavison;	state Exp;
branches;
next	4.3;
commitid	7d95TmqsXKS9wXiw;

4.3
date	2012.04.14.20.47.46;	author rsprowson;	state Exp;
branches;
next	4.2;
commitid	JIilnwocc1uGtS0w;

4.2
date	2002.09.22.11.30.07;	author rsprowson;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.33.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.33.10;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.56.00;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.38.03;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.34.31;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Add some comments (!) and reindent FileSwitch interface
OpsGetPut
  DOSFS_put_bytes no longer passes an unnecessary dummy argument.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFind
  Suggested buffer to FileSwitch is now 1x512 sector (rather than 256).
  Note - nothing seems to use the cluster buffering code in DOSFS,
indeed nothing ever malloc()s a buffer.
  Check at line 237 of OpFind would never be true since FILE_subdir is
not 1, fixed.
  Return an error if the handle to close is invalid.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFile
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFunc
  A failure to find a slot to set the disc title now reports "Dir full"
not "Disc full"
  Reindented.
  Doxygen comments added to FileSwitch layer.

Version 0.99. Tagged as 'DOSFS-0_99'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     MACRO definitions required for DOSFS > s.MFSmacros
        ; -------------------------------------------------------------------
        ; Generate a suitable bit mask manifest.
        MACRO
$label  bit     $shift
$label  *       (1 :SHL: $shift)
        MEND

        ; -------------------------------------------------------------------
        ; Call the given C routine (returns with V set if (a1 == -1) return).
        ; r12 = private word pointer.
        ; a1,a2,a3,a4,av,v1,v2,v3 available as parameters.
        ; Requires the label "not_enough_stack" to be defined for the
        ; filing system.
        ; The location "sl_offset" should contain the label "_Lib$Reloc$Off".
        ; The location "_errptr" should contain the label "_syserr".
free_stack      *       &00000400       ; 1K minimum stack size
        MACRO
$label  Ccall   $address,$pushnumber,$pushstack
$label
        Push    "sl,fp,lr"              ; preserve entry state
        [ :LNOT: No32bitCode
        MRS     lr,CPSR
        Push    "lr"
        ]
        MOV     sl,sp,LSR #20           ; sl = MByte boundary below sp
        MOV     sl,sl,LSL #20           ; sl = real stack limit
        SUB     fp,sp,sl                ; fp = number of free bytes
        CMP     fp,#free_stack          ; minimum size of stack
        BCC     DOS_not_enough_stack    ; and complain to the user
        LDMIA   sl,{v4,v5}              ; stack-frame description
        LDR     r12,[r12]               ; load private word contents
        LDMIB   r12,{r11,r12}           ; load stack-frame description
        STMIA   sl,{r11,r12}            ; and store at stack-limit
        ADRL    lr,sl_offset
        LDR     lr,[lr,#&00]            ; size of stack overflow buffer
        ADD     sl,sl,lr                ; add on stack overflow buffer
        MOV     fp,#&00000000           ; no frame-pointer
        ; stack items if the user has requested so
        [       ("$pushnumber" <> "")
        [       ("$pushstack" <> "") :LAND: ($pushnumber <> 0)
        Push    "$pushstack"
        ]
        ]
        BL      $address
        ; junk stack items if the user pushed any
        [       ("$pushnumber" <> "")
        [       ("$pushstack" <> "") :LAND: ($pushnumber <> 0)
        ADD     sp,sp,#($pushnumber * 4)
        ]
        ]
        ADRL    lr,sl_offset
        LDR     lr,[lr,#&00]            ; stack overflow buffer
        CMP     r0,#&FFFFFFFF           ; (-1) == error state
        ADREQL  r0,|_errptr|
        LDREQ   r0,[r0,#&00]            ; offset in static data area
        SUBEQ   lr,sl,lr
        LDREQ   fp,[lr,#&04]            ; reference our static data
        ADDEQ   r0,fp,r0                ; reference the pointer
        LDREQ   r0,[r0,#&00]            ; and load the pointer
        ; this code must NOT affect the Z bit
        ADRL    lr,sl_offset
        LDR     lr,[lr,#&00]            ; stack overflow buffer
        SUB     sl,sl,lr                ; recover true stack-limit
        STMIA   sl,{v4,v5}              ; and restore stack-limit contents

        [ :LNOT: No32bitCode
        Pull    "lr"
        ORREQ   lr,lr,#V_bit
        MSR     CPSR_cxsf,lr
        Pull    "sl,fp,lr"              ; recover entry state
        |
        Pull    "sl,fp,lr"              ; recover entry state
        SETV    EQ
        CLRV    NE                      ; exit with V reflecting error state
        ]
        MEND

        ; -------------------------------------------------------------------
        ; Place in register $a the maximum or minimum value of register $a
        ; and register $b.

        MACRO
$label  max     $a,$b
$label
        CMP     $a,$b
        MOVLT   $a,$b
        MEND

        MACRO
$label  min     $a,$b
$label
        CMP     $a,$b
        MOVGT   $a,$b
        MEND

        ; -------------------------------------------------------------------
        ; Allocate a fixed amount of object space, and place the given text
        ; into it.

        MACRO
$label  FixDCB  $n,$string
        ASSERT  ((:LEN: "$string") < $n)        ; complain if string too long
$label  =       "$string"                       ; place string into memory
        %       ($n - (:LEN: "$string"))        ; and zero the remainder
        MEND

        END
@


4.5
log
@Makefile recreated from fragments
Replaced 'lk' register name with 'lr', now APCS is not set to -none.
Inverted the sense of the conditional in CMHG file, following the more common ROM predefine use (eg. the Toolbox).
Removed obsolete NoFAT32 obey files - the switch remains but there's little point omitting that now (since the switch actually leaves most of the code in anyway).
Tested in IOMD ROM build (export, resources, ROM phases) mounting a DOS floppy and 1GB image file.

Version 0.97. Tagged as 'DOSFS-0_97'
@
text
@a16 23
        ; The "ERRBLK" constructs a RISC OS style error block. The error
        ; number is taken from the variable "next_errnum". This is
        ; automatically updated ready for the next error definition.
        ; We are allocated (as a filing system) a maximum of 256 error
        ; numbers by RISC OS.
        ;
        ; next error number to be allocated
                GBLA    next_errnum
next_errnum     SETA    &00000000

        MACRO
$label  ERRBLK  $text
$label
num_$label      *       next_errnum     ; internal error number
        &       (num_$label :OR: (&00010000 :OR: (fs_number :SHL: 8)))
        =       "$text", 0
        ALIGN

next_errnum     SETA    (next_errnum + &00000001)
        ASSERT  (next_errnum < &0100)  ; error number limit
        MEND

        ; -------------------------------------------------------------------
d60 1
a60 1
        ; recover stack items if the user pushed any
@


4.4
log
@  Fixed support for certain sized DOS discs
Detail:
  In the code which determined the bitmask to apply to cluster numbers, the
  calculation of the number of clusters in the data area (which is the
  deciding factor between FAT12, FAT16 and FAT32) contained an operator
  precedence error in the calculation of the root directory size. The result
  was that if the disc size was within approx 8 MB of the FAT type threshold
  then the wrong mask was selected. (For clusters of 4*512 bytes, the FAT12/16
  threshold is about 8 MB, so discs between 8 and 16 MB would fail.)
  Also:
  * Fixed the module base address and offsets registered with FileSwitch -
    previously the static data relocation offset was incorrectly applied.
    FileSwitch didn't actually care as long as they added up to the right
    address, but it was still wrong.
  * 32-bitting was incorrectly done using the No26bitCode switch rather than
    the No32bitCode switch, meaning that softloadable builds of this module
    were not 32-bit compatible. Softloadable builds now work on anything from
    RISC OS 3.5 onwards.
Admin:
  Tested on Raspberry Pi and Iyonix.

Version 0.95. Tagged as 'DOSFS-0_95'
@
text
@d32 1
a32 1
        =       "$text",null
d58 1
a58 1
        Push    "sl,fp,lk"              ; preserve entry state
d60 2
a61 2
        MRS     lk,CPSR
        Push    "lk"
d72 3
a74 3
        ADRL    lk,sl_offset
        LDR     lk,[lk,#&00]            ; size of stack overflow buffer
        ADD     sl,sl,lk                ; add on stack overflow buffer
d89 2
a90 2
        ADRL    lk,sl_offset
        LDR     lk,[lk,#&00]            ; stack overflow buffer
d94 2
a95 2
        SUBEQ   lk,sl,lk
        LDREQ   fp,[lk,#&04]            ; reference our static data
d99 3
a101 3
        ADRL    lk,sl_offset
        LDR     lk,[lk,#&00]            ; stack overflow buffer
        SUB     sl,sl,lk                ; recover true stack-limit
d105 4
a108 4
        Pull    "lk"
        ORREQ   lk,lk,#Vbit
        MSR     CPSR_cxsf,lk
        Pull    "sl,fp,lk"              ; recover entry state
d110 1
a110 1
        Pull    "sl,fp,lk"              ; recover entry state
@


4.3
log
@Trim out some local definitions, use header files instead
Use Push/Pull macros for stack operations.
Unix-ify path names in assembler files.

Version 0.89. Tagged as 'DOSFS-0_89'
@
text
@d59 1
a59 1
        [ No26bitCode
d104 1
a104 1
        [ No26bitCode
@


4.2
log
@Deleted some dead variables and switches.
Eliminated MOVS and R14 fiddling to achieve 32 bit compatibility
RISCOS Ltd made 3 changes in their sources
 - ensure disc titles don't contain rogue characters (added)
 - files with time,date,and reserved fields of zero appears as DEADDEAD
   which is silly since Winodws uses this to mark a file unstamped which
   isn't quite the same thing! (not added)
 - syslog debugging support (not added)

Version 0.69. Tagged as 'DOSFS-0_69'
@
text
@d58 1
a58 1
        STMFD   sp!,{sl,fp,lk}          ; preserve entry state
d61 1
a61 1
        STMFD   sp!,{lk}
d79 1
a79 1
        STMFD   sp!,{$pushstack}
d105 1
a105 1
        LDMFD   sp!,{lk}
d108 1
a108 1
        LDMFD   sp!,{sl,fp,lk}          ; recover entry state
d110 1
a110 1
        LDMFD   sp!,{sl,fp,lk}          ; recover entry state
@


4.1
log
@Initial revision
@
text
@d15 1
a15 1
        TTL     MACRO definitions required for MultiFS > s.MFSmacros
d59 4
a66 1
        LDMCCFD sp!,{sl,fp,lk}          ; recover entry registers
d98 1
a98 1
        ; -- This code should NOT update the PSR ----------------------------
d103 7
d111 3
a113 8
        ; -------------------------------------------------------------------
        BEQ     %FT00                   ; error    = V set
        ; no error = V clear
        CLRV
        B       %FT01
00      ; error = V set
        SETV
01      ; exit with V reflecting error state
a144 1
        ; -------------------------------------------------------------------
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

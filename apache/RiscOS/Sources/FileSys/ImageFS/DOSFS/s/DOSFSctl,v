head	4.11;
access;
symbols
	DOSFS-1_14:4.11
	DOSFS-1_13:4.11
	DOSFS-1_12:4.11
	DOSFS-1_11:4.11
	DOSFS-1_10:4.11
	DOSFS-1_09:4.11
	DOSFS-1_08:4.11
	DOSFS-1_07:4.11
	DOSFS-1_06:4.11
	DOSFS-1_05:4.11
	DOSFS-1_04:4.11
	DOSFS-1_03:4.11
	DOSFS-1_02:4.11
	DOSFS-1_01:4.11
	DOSFS-1_00:4.10
	DOSFS-0_99:4.10
	DOSFS-0_98:4.9
	DOSFS-0_97:4.9
	DOSFS-0_96:4.8
	DOSFS-0_95:4.7
	DOSFS-0_94:4.6
	DOSFS-0_93:4.6
	DOSFS-0_92:4.6
	DOSFS-0_91:4.6
	DOSFS-0_90:4.6
	DOSFS-0_89:4.6
	DOSFS-0_88:4.5
	DOSFS-0_87:4.5
	DOSFS-0_86:4.5
	DOSFS-0_85:4.4
	DOSFS-0_84:4.4
	DOSFS-0_83:4.4
	DOSFS-0_82:4.4
	DOSFS-0_81:4.4
	DOSFS-0_80:4.4
	DOSFS-0_79:4.4
	RO_5_07:4.4
	DOSFS-0_78:4.4
	DOSFS-0_77:4.4
	DOSFS-0_76:4.4
	DOSFS-0_75:4.4
	DOSFS-0_74:4.4
	DOSFS-0_73:4.4
	DOSFS-0_72:4.4
	DOSFS-0_71:4.4
	DOSFS-0_70:4.3
	DOSFS-0_69:4.2
	DOSFS-0_68:4.1
	DOSFS-0_67:4.1
	DOSFS-0_66:4.1
	DOSFS-0_65:4.1
	dellis_autobuild_BaseSW:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	DOSFS-0_64:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.8.1
	Ursula_RiscPC:4.1.0.8
	nicke_DOSFS_0_63:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	2013.01.13.18.57.38;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	IcVKoGKFReBN35Aw;

4.10
date	2013.01.13.18.52.40;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	oq0uLRDtA5Y625Aw;

4.9
date	2012.12.07.14.26.03;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	vz81mkusjqgpKivw;

4.8
date	2012.12.07.14.20.24;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	jnwtWy3St1iqIivw;

4.7
date	2012.09.02.13.29.01;	author bavison;	state Exp;
branches;
next	4.6;
commitid	7d95TmqsXKS9wXiw;

4.6
date	2012.04.14.20.47.46;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	JIilnwocc1uGtS0w;

4.5
date	2009.05.17.01.51.47;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.12.10.21.01.38;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.08.10.09.02;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2002.09.22.11.30.07;	author rsprowson;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.33.09;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.8.1;
next	;

4.1.1.1
date	96.11.05.09.33.09;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.00.55.51;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.38.01;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.34.29;	author nturton;	state Exp;
branches;
next	;

4.1.8.1
date	98.11.20.20.08.15;	author aglover;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Add missing message, use central allocations for DOSFS' FS number
Missing 'Stack full' error message added (German translation needed).
Use DOSFS FS number from headers.
Tested with floppy disc (FAT12), 1GB image file (FAT16) and 4GB image file (FAT32) with no issues seen.

Version 1.01. Tagged as 'DOSFS-1_01'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     DOSFS C Support functions               > s.DOSFSctl
        ; -------------------------------------------------------------------
        ; Copyright (c) 1990, JGSmith
        ; -------------------------------------------------------------------

        AREA    |DOSFS_Support|,CODE,READONLY

        ; -------------------------------------------------------------------
        ; Use internal RMA alloc code
                GBLL    RMAalloc
RMAalloc        SETL    {TRUE}

        IMPORT  |raise|
        IMPORT  |_Lib$Reloc$Off|
        IMPORT  |_syserr|

        EXPORT  |writeWORD|
        EXPORT  |loadWORD|

        ; The following functions seem to have prototypes in <kernel.h>, but
        ; do not appear in the Stubs for SharedCLibrary 3.66.
        [       RMAalloc
        EXPORT  |_kernel_RMAalloc|
        EXPORT  |_kernel_RMAextend|
        EXPORT  |_kernel_RMAfree|
        ]

        ; FileSwitch interface functions
        EXPORT  |DOSFS_Open|
        EXPORT  |DOSFS_GetBytes|
        EXPORT  |DOSFS_PutBytes|
        EXPORT  |DOSFS_Args|
        EXPORT  |DOSFS_Close|
        EXPORT  |DOSFS_File|
        EXPORT  |DOSFS_Func|

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:HostFS
        GET     Hdr:Debug
        GET     hdr:NdrDebug
        GET     Hdr:DDVMacros
        GET     Hdr:APCS.<APCS>
        GET     Hdr:CPU.Arch
        GET     MFSmacros.s

      [ :LNOT: No32bitCode :LAND: :LNOT: No26bitCode :LAND: NoARMv3
        !       1, "Disc build variant currently not suitable for ARMv2 targets"
      ]

        ; -------------------------------------------------------------------
        ; Select level of debugging
                GBLL    hostvdu
hostvdu         SETL    {FALSE}         ; TUBE debugging output
debug           SETL    {FALSE}
open            SETD    {FALSE}
bget            SETD    {FALSE}
bput            SETD    {FALSE}
close           SETD    {FALSE}
args            SETD    {FALSE}
file            SETD    {FALSE}
func            SETD    {FALSE}

      [ debug
        InsertNDRDebugRoutines
      ]

        ; -------------------------------------------------------------------
        ; Errors
err_badparargs  *       &00
err_badparfile  *       &01
err_badparfunc  *       &02
err_nostack     *       &15
err_notsupported *      &A5

        ; -------------------------------------------------------------------
        ; Misc constants
spare_word      *       &2053474A               ; "JGS "

        ; -------------------------------------------------------------------
        ; Private (assembler) data
sl_offset       &       |_Lib$Reloc$Off|        ; stack overflow buffer size
|_errptr|       &       |_syserr|               ; pointer to error block
        LTORG

        ; -------------------------------------------------------------------
        ; Filing System interface:

        IMPORT  |DOSFS_open_file|      ; open a file
        IMPORT  |DOSFS_get_bytes|      ; read bytes from an open file
        IMPORT  |DOSFS_put_bytes|      ; write bytes to an open file
        IMPORT  |DOSFS_close_file|     ; close an open file

        IMPORT  |DOSFS_write_extent|   ; write file extent
        IMPORT  |DOSFS_alloc|          ; read size allocated to file
        IMPORT  |DOSFS_flush|          ; flush file buffer
        IMPORT  |DOSFS_ensure|         ; ensure file size
        IMPORT  |DOSFS_write_zeros|    ; write zeros to file
        IMPORT  |DOSFS_read_datestamp| ; read load/exec addresses of open file

        IMPORT  |DOSFS_save_file|      ; save a complete file image
        IMPORT  |DOSFS_read_cat|       ; read catalogue information
        IMPORT  |DOSFS_write_cat|      ; write catalogue information
        IMPORT  |DOSFS_delete|         ; delete object
        IMPORT  |DOSFS_create|         ; create file
        IMPORT  |DOSFS_create_dir|     ; create directory
        IMPORT  |DOSFS_read_block_size| ; return natural block size for image

        IMPORT  |DOSFS_rename|            ; rename object
        IMPORT  |DOSFS_read_dir|          ; read directory entries
        IMPORT  |DOSFS_read_dir_info|     ; read directory entries and info
        IMPORT  |DOSFS_image_open|        ; notification of image file open
        IMPORT  |DOSFS_image_close|       ; notification of image file close
        IMPORT  |DOSFS_defect_list|       ; generate defect list for image
        IMPORT  |DOSFS_add_defect|        ; add a defect into the list
        IMPORT  |DOSFS_read_boot_option|  ; read boot option
        IMPORT  |DOSFS_write_boot_option| ; write boot option
        IMPORT  |DOSFS_used_space_map|    ; generate space map
        IMPORT  |DOSFS_read_free_space|   ; return free space information
        IMPORT  |DOSFS_namedisc|          ; namedisc
        IMPORT  |DOSFS_stampimage|        ; update the image identity
        IMPORT  |DOSFS_objectatoffset|    ; return name of object at offset

        IMPORT  |global_error|            ; generate error message from number

        ; -------------------------------------------------------------------

DOSFS_Open
        ;Debug   open,"DOSFS_Open",r0,r1,r6
                        ; a1 == r0      type of open to perform
                        ; a2 == r1      pointer to NULL terminated filename
        MOV     a3,r6   ; a3 == r6      image handle for this file

        Ccall   |DOSFS_open_file|
        [ :LNOT: No32bitCode
        LDMVCIA r0,{r0-r4}              ; r0 = pointer to information block
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit             ; error -> r0 = ptr to error block
        LDMIA   r0,{r0-r4}              ; r0 = pointer to information block as below
        BICS    pc,lr,#V_bit
        ]
        ; r0 == file information word
        ; r1 == filing system handle (0 = "not found")
        ; r2 == buffer size (0 if file is unbuffered, 2^n (n = 6..10))
        ; r3 == file extent (buffered files only)
        ; r4 == current file allocation (in buffer size multiples)

        ; -------------------------------------------------------------------

DOSFS_GetBytes
        ;Debug   bget,"DOSFS_GetBytes",r1,r2,r3,r4
        MOV     a1,r1           ; r1 = filing system handle
        MOV     a2,r2           ; r2 = memory address for data
        MOV     a3,r3           ; r3 = number of bytes to transfer
        MOV     a4,r4           ; r4 = file offset (PTR#)
        Ccall   |DOSFS_get_bytes|
        ; r0 = byte read if unbuffered
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

        ; -------------------------------------------------------------------

DOSFS_PutBytes
        ;Debug   bput,"DOSFS_PutBytes",r1,r2,r3,r4
        MOV     a1,r1           ; r1 = filing system handle
        MOV     a2,r2           ; r2 = memory address of data
        MOV     a3,r3           ; r3 = number of bytes to transfer
        MOV     a4,r4           ; r4 = file offset (PTR#)
        Ccall   |DOSFS_put_bytes|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

        ; -------------------------------------------------------------------

DOSFS_Close
        ;Debug   close,"DOSFS_Close",r1,r2,r3
        MOV     a1,r1           ; r1 = filing system handle
        MOV     a2,r2           ; r2 = new load address for file
        MOV     a3,r3           ; r3 = new exec address for file
        Ccall   |DOSFS_close_file|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

        ; -------------------------------------------------------------------

DOSFS_Args
        ;Debug   args,"DOSFS_Args",r0
        ; r0 reason code:
        ; &03 = write file extent (|DOSFS_write_extent|)
        ;       in:     r1 = filing system handle
        ;               r2 = new file extent
        ;       out:    no conditions
        ;
        ; &04 = read size allocated to file (|DOSFS_alloc|)
        ;       in:     r1 = filing system handle
        ;       out:    r2 = size allocated to file by filing system
        ;
        ; &06 = flush file buffer (|DOSFS_flush|)
        ;       in:     r1 = filing system handle
        ;       out:    r2 = load address of file (or 0)
        ;               r3 = exec address of file (or 0)
        ;
        ; &07 = ensure file size (|DOSFS_ensure|)
        ;       in:     r1 = filing system handle
        ;               r2 = size of file to ensure
        ;       out:    r2 = size of file actually ensured
        ;
        ; &08 = write zeroes to file (|DOS_write_zeros|)
        ;       in:     r1 = file handle
        ;               r2 = file address to write zeros at
        ;               r3 = number of zeros to write
        ;
        ; &09 = read load/exec addresses (|DOS_read_datestamp|)
        ;       in:     r1 = file handle
        ;       out:    r2 = load address of file
        ;               r3 = execute address of file
        ;
        CMP     r0,#args_table_entries
        BGT     DOS_args_badparameter
        ADD     pc,pc,r0,LSL #2
        &       spare_word                      ; DO NOT REMOVE OR ADD CODE
args_table_start
        B       DOS_notsupported                ; 00 / 0
        B       DOS_notsupported                ; 01 / 1
        B       DOS_notsupported                ; 02 / 2
        B       |call_DOSFS_write_extent|       ; 03 / 3
        B       |call_DOSFS_alloc|              ; 04 / 4
        B       DOS_notsupported                ; 05 / 5
        B       |call_DOSFS_flush|              ; 06 / 6
        B       |call_DOSFS_ensure|             ; 07 / 7
        B       |call_DOSFS_write_zeros|        ; 08 / 8
        B       |call_DOSFS_read_datestamp|     ; 09 / 9
args_table_end
args_table_entries      *       ((args_table_end - args_table_start) / 4)

DOS_args_badparameter
        MOV     a1,#err_badparargs
        Ccall   |global_error|
        [ :LNOT: No32bitCode
        MSR     CPSR_f,#V_bit            ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lr
        |
        ORRS    pc,lr,#V_bit
        ]

|call_DOSFS_write_extent|
        MOV     a1,r1                   ; filing system handle
        MOV     a2,r2                   ; new file extent
        Ccall   |DOSFS_write_extent|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_alloc|
        MOV     a1,r1                   ; filing system handle
        Ccall   |DOSFS_alloc|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_flush|
        MOV     a1,r1                   ; filing system handle
        Ccall   |DOSFS_flush|
        [ :LNOT: No32bitCode
        LDMVCIA r0,{r2,r3}
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        LDMIA   r0,{r2,r3}
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_ensure|
        MOV     a1,r1                   ; filing system handle
        MOV     a2,r2                   ; size to ensure
        Ccall   |DOSFS_ensure|
        [ :LNOT: No32bitCode
        MOVVC   r2,a1                   ; actual size ensured
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        MOV     r2,a1                   ; actual size ensured
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_write_zeros|
        MOV     a1,r1                   ; filing system handle
        MOV     a2,r2                   ; offset within file
        MOV     a3,r3                   ; number of zeros to write
        Ccall   |DOSFS_write_zeros|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_read_datestamp|
        MOV     a1,r1                   ; filing system handle
        Ccall   |DOSFS_read_datestamp|
        [ :LNOT: No32bitCode
        LDMVCIA r0,{r2,r3}
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        LDMIA   r0,{r2,r3}
        BICS    pc,lr,#V_bit
        ]

        ; -------------------------------------------------------------------

DOSFS_File
        ;Debug   file,"DOSFS_File",r0
        ; r0 reason code:
        ;
        ; &00 = save file (|DOSFS_save_file|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r2 = load address of file
        ;               r3 = exec address of file
        ;               r4 = start address in memory of data
        ;               r5 = end address in memory (plus one)
        ;               r6 = filing system image handle
        ;       out:    r6 = pointer to leafname (*OPT 1 n printing)
        ;
        ; &01 = write catalogue information (|DOSFS_write_cat|)
        ;       in:     r1 = pointer to NULL terminated wildcarded filename
        ;               r2 = load address to associate with file
        ;               r3 = exec address to associate with file
        ;               r5 = attributes to associate with file
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &05 = read catalogue information (|DOSFS_read_cat|)
        ;       in:     r1 = pointer to NULL terminated wildcarded filename
        ;               r6 = filing system image handle
        ;       out:    r0 = object type
        ;               r2 = load address
        ;               r3 = exec address
        ;               r4 = file length
        ;               r5 = file attributes
        ;
        ; &06 = delete object (|DOSFS_delete|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r6 = filing system image handle
        ;       out:    r0 = object type
        ;               r2 = load address
        ;               r3 = exec address
        ;               r4 = file length
        ;               r5 = file attributes
        ;
        ; &07 = create file (|DOSFS_create|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r2 = load address to associate with file
        ;               r3 = exec address to associate with file
        ;               r4 = length
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &08 = create directory (|DOSFS_create_dir|)
        ;       in:     r1 = pointer to NULL terminated directory name
        ;               r2 = load address (new feature)
        ;               r3 = exec address (new feature)
        ;               r4 = number of entries (0 for default)
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &0A = read block size (|DOSFS_read_block_size|)
        ;       in:     r1 = pointer to NULL terminated file name
        ;               r6 = filing system image handle
        ;       out:    r2 = natural block size of the file in bytes
        ;
        CMP     r0,#file_table_entries
        BGT     DOS_file_badparameter
        ADD     pc,pc,r0,LSL #2
        &       spare_word              ; DO NOT REMOVE OR ADD CODE
file_table_start
        B       |call_DOSFS_save_file|          ; 00 / 0
        B       |call_DOSFS_write_cat|          ; 01 / 1
        B       DOS_notsupported                ; 02 / 2
        B       DOS_notsupported                ; 03 / 3
        B       DOS_notsupported                ; 04 / 4
        B       |call_DOSFS_read_cat|           ; 05 / 5
        B       |call_DOSFS_delete|             ; 06 / 6
        B       |call_DOSFS_create|             ; 07 / 7
        B       |call_DOSFS_create_dir|         ; 08 / 8
        B       DOS_notsupported                ; 09 / 9
        B       |call_DOSFS_read_block_size|    ; 0A / 10
file_table_end
file_table_entries      *       ((file_table_end - file_table_start) / 4)

DOS_file_badparameter
        MOV     a1,#err_badparfile
        Ccall   |global_error|
        [ :LNOT: No32bitCode
        MSR     CPSR_f,#V_bit            ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lr
        |
        ORRS    pc,lr,#V_bit
        ]

|call_DOSFS_save_file|
        MOV     a1,r1                      ; filename
        MOV     a2,r2                      ; load address
        MOV     a3,r3                      ; exec address
        MOV     a4,r4                      ; start address
        Ccall   |DOSFS_save_file|,2,r5-r6  ; end addr and filing system ihand
        [ :LNOT: No32bitCode
        MOVVC   r6,a1                      ; "*OPT 1 n" leafname
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        MOV     r6,a1                      ; "*OPT 1 n" leafname
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_write_cat|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; load address
        MOV     a3,r3                   ; exec address
        MOV     a4,r5                   ; attributes
        Ccall   |DOSFS_write_cat|,1,r6  ; filing system image handle
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_read_cat|
        MOV     a1,r1                   ; filename
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_read_cat|
        [ :LNOT: No32bitCode
        ; r0 = pointer to structure containing return information
        LDMVCIA r0,{r0,r2-r5}           ; r6 should be preserved
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r0,r2-r5}           ; r6 should be preserved
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_delete|
        MOV     a1,r1                   ; filename
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_delete|
        [ :LNOT: No32bitCode
        ; r0 = pointer to structure containing return information
        LDMVCIA r0,{r0,r2-r5}
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r0,r2-r5}
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_create|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; load address
        MOV     a3,r3                   ; exec address
        MOV     a4,r4                   ; start address
        Ccall   |DOSFS_create|,2,r5-r6  ; end addr and filing system ihand
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_create_dir|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; r2 = load address
        MOV     a3,r3                   ; r3 = exec address
        MOV     a4,r4                   ; number of entries
        Ccall   |DOSFS_create_dir|,1,r6 ; r6 = filing system image handle
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_read_block_size|
        MOV     a1,r1                   ; filename
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_read_block_size|
        [ :LNOT: No32bitCode
        MOVVC   r2,r0                   ; block size
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        MOV     r2,r0                   ; block size
        BICS    pc,lr,#V_bit
        ]

        ; -------------------------------------------------------------------

DOSFS_Func
        ;Debug   func,"DOSFS_Func",r0
        ; r0 reason code:
        ;
        ; &08 = rename object (|DOSFS_rename|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r2 = pointer to NULL terminated NEW filename
        ;               r6 = filing system image handle
        ;       out:    r1 = rename completion state
        ;
        ; &0E = read directory entries (|DOSFS_read_dir|)
        ;       in:     r1 = pointer to NULL terminated wildcarded dirname
        ;               r2 = data destination memory address
        ;               r3 = number of objects to read
        ;               r4 = offset of first object within directory
        ;               r5 = buffer length
        ;               r6 = filing system image handle
        ;       out:    r3 = number of objects read
        ;               r4 = offset of next item in directory (-1 if end)
        ;
        ; &0F = read directory entries and info. (|DOSFS_read_dir_info|)
        ;       in:     r1 = pointer to NULL terminated wildcarded dirname
        ;               r2 = data destination memory address
        ;               r3 = number of objects to read
        ;               r4 = offset of first object within directory
        ;               r5 = buffer length
        ;               r6 = filing system image handle
        ;       out:    r3 = number of records read
        ;               r4 = offset of next item in directory (-1 if end)
        ;
        ; &15 = notification of new image file (|DOSFS_image_open|)
        ;       in:     r1 = FileSwitch handle for file
        ;               r2 = buffer size for file (0 not known)
        ;       out:    r1 = filing system image handle
        ;
        ; &16 = notification of image file being closed (|DOSFS_image_close|)
        ;       in:     r1 = filing system image handle
        ;       out:    no conditions
        ;
        ; &19 = fill buffer with defect information (|DOSFS_defect_list|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r2 = start of buffer in memory
        ;               r5 = buffer length
        ;               r6 = filing system image handle
        ;       out: no conditions
        ;
        ; &1A = add a defect into the image mapping (|DOSFS_add_defect|)
        ;       in:     r1 = ptr to NULL terminated filename in ROOT dir.
        ;               r2 = byte offset to start of defect
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &1B = read boot option (|DOSFS_read_boot_option|)
        ;       in:     r1 = pointer to NULL terminated name of object on
        ;                    thing whose boot option is to be read
        ;               r6 = filing system image handle
        ;       out:    r2 = boot option (as defined in *OPT 4,n)
        ;
        ; &1C = write boot option (|DOSFS_write_boot_option|)
        ;       in:     r1 = pointer to NULL terminated name of object on
        ;                    thing whose boot option is to be written
        ;               r2 = new boot option (as defined in *OPT 4,n)
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &1D = construct used space map (|DOSFS_used_space_map|)
        ;       in:     r2 = buffer for map (pre-filled with 0s)
        ;               r5 = size of buffer
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &1E = read free space (|DOSFS_read_free_space|)
        ;       in:     r6 = filing system image handle
        ;       out:    r0 = free space
        ;               r1 = size of biggest object that can be created
        ;               r2 = size of disc (image)
        ;
        ; &1F = name disc (|DOSFS_namedisc|)
        ;       in:     r2 = pointer to NULL terminated disc name
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &20 = update image identity (DOSFS_stampimage)
        ;       in:     r2 = stamp control information
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &21 = return object identity (DOSFS_objectatoffset)
        ;       in:     r2 = byte offset into image file
        ;               r3 = pointer to buffer to receive object name
        ;               r4 = buffer length
        ;               r6 = filing system image handle
        ;       out:    r2 = type of object found
        ;
        CMP     r0,#func_table_entries
        BGT     DOS_func_badparameter
        ADD     pc,pc,r0,LSL #2
        &       spare_word                      ; DO NOT REMOVE OR ADD CODE
func_table_start
        B       DOS_notsupported                ; 00 / 0
        B       DOS_notsupported                ; 01 / 1
        B       DOS_notsupported                ; 02 / 2
        B       DOS_notsupported                ; 03 / 3
        B       DOS_notsupported                ; 04 / 4
        B       DOS_notsupported                ; 05 / 5
        B       DOS_notsupported                ; 06 / 6
        B       DOS_notsupported                ; 07 / 7
        B       |call_DOSFS_rename|             ; 08 / 8
        B       DOS_notsupported                ; 09 / 9
        B       DOS_notsupported                ; 0A / 10
        B       DOS_notsupported                ; 0B / 11
        B       DOS_notsupported                ; 0C / 12
        B       DOS_notsupported                ; 0D / 13
        B       |call_DOSFS_read_dir|           ; 0E / 14
        B       |call_DOSFS_read_dir_info|      ; 0F / 15
        B       DOS_notsupported                ; 10 / 16
        B       DOS_notsupported                ; 11 / 17
        B       DOS_notsupported                ; 12 / 18
        B       DOS_notsupported                ; 13 / 19
        B       DOS_notsupported                ; 14 / 20
        B       |call_DOSFS_image_open|         ; 15 / 21
        B       |call_DOSFS_image_close|        ; 16 / 22
        B       DOS_notsupported                ; 17 / 23
        B       DOS_notsupported                ; 18 / 24
        B       |call_DOSFS_defect_list|        ; 19 / 25
        B       |call_DOSFS_add_defect|         ; 1A / 26
        B       |call_DOSFS_read_boot_option|   ; 1B / 27
        B       |call_DOSFS_write_boot_option|  ; 1C / 28
        B       |call_DOSFS_used_space_map|     ; 1D / 29
        B       |call_DOSFS_read_free_space|    ; 1E / 30
        B       |call_DOSFS_namedisc|           ; 1F / 31
        B       |call_DOSFS_stampimage|         ; 20 / 32
        B       |call_DOSFS_objectatoffset|     ; 21 / 33
func_table_end
func_table_entries      *       ((func_table_end - func_table_start) / 4)

DOS_func_badparameter
        MOV     r0,#err_badparfunc
        Ccall   |global_error|
        [ :LNOT: No32bitCode
        MSR     CPSR_f,#V_bit            ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lr
        |
        ORRS    pc,lr,#V_bit
        ]

|call_DOSFS_rename|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; new filename
        MOV     a3,r6                   ; filing system image handle
        Ccall   |DOSFS_rename|
        [ :LNOT: No32bitCode
        MOVVC   r1,r0
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        MOV     r1,r0                   ; state
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_read_dir|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; data destination
        MOV     a3,r3                   ; number of objects
        MOV     a4,r4                   ; object offset
        Ccall   |DOSFS_read_dir|,2,r5-r6
        [ :LNOT: No32bitCode
        ; r0 = pointer to structure containing return information
        LDMVCIA r0,{r3-r4}
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r3-r4}
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_read_dir_info|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; data destination
        MOV     a3,r3                   ; number of objects
        MOV     a4,r4                   ; object offset
        Ccall   |DOSFS_read_dir_info|,2,r5-r6
        [ :LNOT: No32bitCode
        LDMVCIA r0,{r3-r4}
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r3-r4}
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_image_open|
        MOV     a1,r1                   ; FileSwitch file handle
        MOV     a2,r2                   ; buffer size
        Ccall   |DOSFS_image_open|
        [ :LNOT: No32bitCode
        MOVVC   r1,r0
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit             ; error return
        ; r0 = filing system image handle
        MOV     r1,r0
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_image_close|
        MOV     a1,r1                   ; filing system image handle
        Ccall   |DOSFS_image_close|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_defect_list|
        MOV     a1,r1                   ; pointer to filename
        MOV     a2,r2                   ; buffer address
        MOV     a3,r5                   ; buffer length
        MOV     a4,r6                   ; filing system image handle
        Ccall   |DOSFS_defect_list|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_add_defect|
        MOV     a1,r1                   ; pointer to filename
        MOV     a2,r2                   ; defect address
        MOV     a3,r6                   ; filing system image handle
        Ccall   |DOSFS_add_defect|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_read_boot_option|
        MOV     a1,r1                   ; filename
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_read_boot_option|
        [ :LNOT: No32bitCode
        MOVVC   r2,r0                   ; boot option
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        MOV     r2,r0                   ; boot option
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_write_boot_option|
        MOV     a1,r1                   ; pointer to filename
        MOV     a2,r2                   ; new boot option
        MOV     a3,r6                   ; filing system image handle
        Ccall   |DOSFS_write_boot_option|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_used_space_map|
        MOV     a1,r2                   ; buffer start address
        MOV     a2,r5                   ; buffer size
        MOV     a3,r6                   ; filing system image handle
        Ccall   |DOSFS_used_space_map|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_read_free_space|
        MOV     a1,r6                   ; filing system image handle
        Ccall   |DOSFS_read_free_space|
        [ :LNOT: No32bitCode
        ; r0 = pointer to structure containing return information
        LDMVCIA r0,{r0,r1,r2}
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r0,r1,r2}
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_namedisc|
        MOV     a1,r2                   ; NULL terminated discname
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_namedisc|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_stampimage|
        MOV     a1,r2                   ; identity update control information
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_stampimage|
        [ :LNOT: No32bitCode
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        BICS    pc,lr,#V_bit
        ]

|call_DOSFS_objectatoffset|
        MOV     a1,r2                   ; byte offset into image
        MOV     a2,r3                   ; object name buffer
        MOV     a3,r4                   ; buffer length
        MOV     a4,r6                   ; filing system image handle
        Ccall   |DOSFS_objectatoffset|
        [ :LNOT: No32bitCode
        MOVVC   r2,r0                   ; object type at entry offset
        MOV     pc,lr
        |
        ORRVSS  pc,lr,#V_bit
        MOV     r2,r0                   ; object type at entry offset
        BICS    pc,lr,#V_bit
        ]

        ; -------------------------------------------------------------------
        ; Called when an unrecognised reason code is presented
DOS_notsupported
        ; There should be no stacked state at this point
        MOV     a1,#err_notsupported
        Ccall   |global_error|
        [ :LNOT: No32bitCode
        MSR     CPSR_f,#V_bit            ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lr
        |
        ORRS    pc,lr,#V_bit
        ]

        ; Called when a "Ccall" will fail due to insufficient stack.
DOS_not_enough_stack
        [ :LNOT: No32bitCode
        Pull    "lr"
        MSR     CPSR_cxsf,lr
        ] 
        Pull    "sl,fp,lr"     ; recover entry registers
        MOV     a1, #err_nostack ; There should be no stacked state at this point
        Ccall   |global_error| ; now,just for fun,we'll call Ccall again
        [ :LNOT: No32bitCode
        MSR     CPSR_f,#V_bit   ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lr
        |
        ORRS    pc,lr,#V_bit
        ]

        ; -------------------------------------------------------------------
        ; Provide a simple function to write a WORD to a non-aligned address
|writeWORD|
        ; in:   r0 = byte aligned address
        ;       r1 = 32bit value to be written
    [ NoARMv6 :LOR: NoUnaligned
        ANDS    r2,r0,#&03      ; r2 = byte index
        STREQ   r1,[r0,#&00]    ; word-aligned (perform write)
        Return  ,LinkNotStacked,EQ ; and exit quickly

        ; non-word aligned data
        FunctionEntry "r4,r5,r6"
      [ SupportARMv6
        BIC     r0,r0,#&03      ; r0 = base word index
      ]
        LDMIA   r0,{r4,r5}      ; load the two words our word lives in
        MOV     r2,r2,LSL #3    ; r2 = r2 * 8
        RSB     r3,r2,#32       ; r3 = 32 - r2
        MOV     r4,r4,LSL r3    ; clear the top-bits
        MOV     r6,r1,LSL r2    ; shift up the lo-bits
        ORR     r4,r6,r4,LSR r3 ; re-build the lo-word
        MOV     r5,r5,LSR r2    ; clear the lo-bits
        MOV     r6,r1,LSR r3    ; shift down the top-bits
        ORR     r5,r6,r5,LSL r2 ; re-build the hi-word
        STMIA   r0,{r4,r5}      ; store modified words
        Return  "r4,r5,r6"
    |
        STR     r1,[r0,#&00]    ; ARMv6+ can do unaligned writes
        Return  ,LinkNotStacked ; and exit quickly
    ]

        ; -------------------------------------------------------------------
        ; Provide a simple function to load a WORD from a non-aligned address
|loadWORD|
        ; in:   r0 = byte aligned address
    [ NoARMv6 :LOR: NoUnaligned
        ANDS    r2,r0,#&03      ; r2 = byte index
        LDREQ   r0,[r0,#&00]    ; word-aligned (perform read)
        Return  ,LinkNotStacked,EQ ; and exit quickly
        ; non-word aligned data
        FunctionEntry "r4"
      [ SupportARMv6
        BIC     r0,r0,#&03      ; r0 = base word index
      ]
        LDMIA   r0,{r3,r4}      ; load the two words our word lives in
        MOV     r2,r2,LSL #3    ; r2 = r2 * 8        ; shift amount
        RSB     r1,r2,#32       ; r1 = 32 - r2       ; opposite shift amount
        MOV     r0,r3,LSR r2    ; shift down lo-bits from lo-word
        ORR     r0,r0,r4,LSL r1 ; shift up hi-bits from hi-word
        Return  "r4"
    |
        LDR     r0,[r0,#&00]    ; ARMv6+ can do unaligned loads
        Return  ,LinkNotStacked ; and exit quickly
    ]

        ; -------------------------------------------------------------------
        ; A handful of RMA alloc bits
     [  RMAalloc
|_kernel_RMAalloc|
        MOVS    r3,a1
        Return  ,LinkNotStacked,EQ      ; exit quickly if NULL length
        MOV     ip,lr
        MOV     r0,#ModHandReason_Claim
        SWI     XOS_Module
        MOVVS   a1,#&0000000            ; return NULL if failed to alloc
        MOVVC   a1,r2                   ; otherwise base address
        Return  ,LinkNotStacked,,ip

        ; -------------------------------------------------------------------

|_kernel_RMAextend|
        CMP     a1,#&00000000
        MOVEQ   a1,a2                   ; NULL pointer, so act as realloc()
        BEQ     |_kernel_RMAalloc|      ; perform an allocation
        CMP     a2,#&00000000
        BEQ     |_kernel_RMAfree|       ; if size is zero, then perform free()
        MOV     ip,lr
        LDR     r3,[a1,#-4]             ; get length word preceding base
        SUB     r3,r3,a2                ; subtract new length (giving delta)
        MOV     r2,a1                   ; the current base address
        MOV     r0,#ModHandReason_ExtendBlock
        SWI     XOS_Module
        MOVVS   a1,#&0000000            ; NULL returned if extend failed
        MOVVC   a1,r2                   ; otherwise base address returned
        Return  ,LinkNotStacked,,ip

        ; -------------------------------------------------------------------

|_kernel_RMAfree|
        MOV     ip,lr
        MOVS    r2,a1                   ; base address of allocated memory
        MOVNE   r0,#ModHandReason_Free
        SWINE   XOS_Module              ; if not NULL then release memory
        MOV     a1,#&00000000           ; and the address is now NULL
        Return  ,LinkNotStacked,,ip
     ]

        LTORG

        END
@


4.10
log
@Add some comments (!) and reindent FileSwitch interface
OpsGetPut
  DOSFS_put_bytes no longer passes an unnecessary dummy argument.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFind
  Suggested buffer to FileSwitch is now 1x512 sector (rather than 256).
  Note - nothing seems to use the cluster buffering code in DOSFS,
indeed nothing ever malloc()s a buffer.
  Check at line 237 of OpFind would never be true since FILE_subdir is
not 1, fixed.
  Return an error if the handle to close is invalid.
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFile
  Reindented.
  Doxygen comments added to FileSwitch layer.
OpsFunc
  A failure to find a slot to set the disc title now reports "Dir full"
not "Disc full"
  Reindented.
  Doxygen comments added to FileSwitch layer.

Version 0.99. Tagged as 'DOSFS-0_99'
@
text
@d86 5
a90 5
notsupported    *       &D8
nostack         *       &A5
badparargs      *       &00
badparfile      *       &01
badparfunc      *       &02
a95 3
                GBLA    fs_number
fs_number       SETA    0                       ; undefined filing system

d266 1
a266 1
        MOV     a1,#badparargs
d427 1
a427 1
        MOV     a1,#badparfile
d672 1
a672 1
        MOV     r0,#badparfunc
d869 1
a869 1
        MOV     a1,#notsupported
d885 1
a885 1
        MOV     a1,#nostack    ; There should be no stacked state at this point
@


4.9
log
@Makefile recreated from fragments
Replaced 'lk' register name with 'lr', now APCS is not set to -none.
Inverted the sense of the conditional in CMHG file, following the more common ROM predefine use (eg. the Toolbox).
Removed obsolete NoFAT32 obey files - the switch remains but there's little point omitting that now (since the switch actually leaves most of the code in anyway).
Tested in IOMD ROM build (export, resources, ROM phases) mounting a DOS floppy and 1GB image file.

Version 0.97. Tagged as 'DOSFS-0_97'
@
text
@a28 1
        IMPORT  |Image$$RO$$Base|
a188 1
        MOV     r7,r0           ; preserve the byte to be written
d193 1
a193 1
        Ccall   |DOSFS_put_bytes|,1,r7
@


4.8
log
@Source file subdivision
The sources to DOSFS had become rather jumbled and monolithic
* Split FileSwitch interface out into seperate ops source files.
* Combined international error lookup with MsgTrans code.
* Split utility functions into 'Helpers.c' along with wildcard matching functions.
* Moved DOS naming functions into, erm, 'DOSnaming.c'.
Also
* Makefile tweaked to remove 'symbols' on clean.
* Obsolete 'Help' and 'Syntax' placed in attic.

RAM, debug, and ROM targets built. RAM target tested with a DOS floppy disc.

Version 0.96. Tagged as 'DOSFS-0_96'
@
text
@d71 9
a79 9
hostvdu         SETL    false           ; TUBE debugging output
debug           SETL    false
open            SETD    false
bget            SETD    false
bput            SETD    false
close           SETD    false
args            SETD    false
file            SETD    false
func            SETD    false
d81 1
a81 1
        [ debug
d83 1
a83 29
        ]

        ; -------------------------------------------------------------------
        ; Standard C register definitions
a1      RN      0
a2      RN      1
a3      RN      2
a4      RN      3
av      RN      4
v1      RN      5
v2      RN      6
v3      RN      7
v4      RN      8
v5      RN      9
lk      RN      14

        ; -------------------------------------------------------------------
        ; Standard floating point register definitions
f0      FN      0
f1      FN      1

        ; -------------------------------------------------------------------
        ; ARM processor flags
Nbit    bit     31
Zbit    bit     30
Cbit    bit     29
Vbit    bit     28
Ibit    bit     27
Fbit    bit     26
a95 1
null            *       &00
d157 1
a157 1
        MOV     pc,lk
d159 1
a159 1
        ORRVSS  pc,lk,#Vbit             ; error -> r0 = ptr to error block
d161 1
a161 1
        BICS    pc,lk,#Vbit
d180 1
a180 1
        MOV     pc,lk
d182 2
a183 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d197 1
a197 1
        MOV     pc,lk
d199 2
a200 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d212 1
a212 1
        MOV     pc,lk
d214 2
a215 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d274 2
a275 2
        MSR     CPSR_f,#Vbit            ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lk
d277 1
a277 1
        ORRS    pc,lk,#Vbit
d285 1
a285 1
        MOV     pc,lk
d287 2
a288 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d295 1
a295 1
        MOV     pc,lk
d297 2
a298 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d306 1
a306 1
        MOV     pc,lk
d308 1
a308 1
        ORRVSS  pc,lk,#Vbit
d310 1
a310 1
        BICS    pc,lk,#Vbit
d319 1
a319 1
        MOV     pc,lk
d321 1
a321 1
        ORRVSS  pc,lk,#Vbit
d323 1
a323 1
        BICS    pc,lk,#Vbit
d332 1
a332 1
        MOV     pc,lk
d334 2
a335 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d343 1
a343 1
        MOV     pc,lk
d345 1
a345 1
        ORRVSS  pc,lk,#Vbit
d347 1
a347 1
        BICS    pc,lk,#Vbit
d435 2
a436 2
        MSR     CPSR_f,#Vbit            ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lk
d438 1
a438 1
        ORRS    pc,lk,#Vbit
d449 1
a449 1
        MOV     pc,lk
d451 1
a451 1
        ORRVSS  pc,lk,#Vbit
d453 1
a453 1
        BICS    pc,lk,#Vbit
d463 1
a463 1
        MOV     pc,lk
d465 2
a466 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d476 1
a476 1
        MOV     pc,lk
d478 1
a478 1
        ORRVSS  pc,lk,#Vbit
d481 1
a481 1
        BICS    pc,lk,#Vbit
d491 1
a491 1
        MOV     pc,lk
d493 1
a493 1
        ORRVSS  pc,lk,#Vbit
d496 1
a496 1
        BICS    pc,lk,#Vbit
d506 1
a506 1
        MOV     pc,lk
d508 2
a509 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d519 1
a519 1
        MOV     pc,lk
d521 2
a522 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d531 1
a531 1
        MOV     pc,lk
d533 1
a533 1
        ORRVSS  pc,lk,#Vbit
d535 1
a535 1
        BICS    pc,lk,#Vbit
d680 2
a681 2
        MSR     CPSR_f,#Vbit            ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lk
d683 1
a683 1
        ORRS    pc,lk,#Vbit
d693 1
a693 1
        MOV     pc,lk
d695 1
a695 1
        ORRVSS  pc,lk,#Vbit
d697 1
a697 1
        BICS    pc,lk,#Vbit
d709 1
a709 1
        MOV     pc,lk
d711 1
a711 1
        ORRVSS  pc,lk,#Vbit
d714 1
a714 1
        BICS    pc,lk,#Vbit
d725 1
a725 1
        MOV     pc,lk
d727 1
a727 1
        ORRVSS  pc,lk,#Vbit
d730 1
a730 1
        BICS    pc,lk,#Vbit
d739 1
a739 1
        MOV     pc,lk
d741 1
a741 1
        ORRVSS  pc,lk,#Vbit             ; error return
d744 1
a744 1
        BICS    pc,lk,#Vbit
d751 1
a751 1
        MOV     pc,lk
d753 2
a754 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d764 1
a764 1
        MOV     pc,lk
d766 2
a767 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d776 1
a776 1
        MOV     pc,lk
d778 2
a779 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d788 1
a788 1
        MOV     pc,lk
d790 1
a790 1
        ORRVSS  pc,lk,#Vbit
d792 1
a792 1
        BICS    pc,lk,#Vbit
d801 1
a801 1
        MOV     pc,lk
d803 2
a804 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d813 1
a813 1
        MOV     pc,lk
d815 2
a816 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d825 1
a825 1
        MOV     pc,lk
d827 1
a827 1
        ORRVSS  pc,lk,#Vbit
d830 1
a830 1
        BICS    pc,lk,#Vbit
d838 1
a838 1
        MOV     pc,lk
d840 2
a841 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d849 1
a849 1
        MOV     pc,lk
d851 2
a852 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
d863 1
a863 1
        MOV     pc,lk
d865 1
a865 1
        ORRVSS  pc,lk,#Vbit
d867 1
a867 1
        BICS    pc,lk,#Vbit
d877 2
a878 2
        MSR     CPSR_f,#Vbit            ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lk
d880 1
a880 1
        ORRS    pc,lk,#Vbit
d886 2
a887 2
        Pull    "lk"
        MSR     CPSR_cxsf,lk
d889 1
a889 1
        Pull    "sl,fp,lk"     ; recover entry registers
d893 2
a894 2
        MSR     CPSR_f,#Vbit   ; global_error doesn't return -1,hence Ccall doesn't set V for us
        MOV     pc,lk
d896 1
a896 1
        ORRS    pc,lk,#Vbit
d960 1
a960 1
        MOV     ip,lk
d975 1
a975 1
        MOV     ip,lk
d988 1
a988 1
        MOV     ip,lk
@


4.7
log
@  Fixed support for certain sized DOS discs
Detail:
  In the code which determined the bitmask to apply to cluster numbers, the
  calculation of the number of clusters in the data area (which is the
  deciding factor between FAT12, FAT16 and FAT32) contained an operator
  precedence error in the calculation of the root directory size. The result
  was that if the disc size was within approx 8 MB of the FAT type threshold
  then the wrong mask was selected. (For clusters of 4*512 bytes, the FAT12/16
  threshold is about 8 MB, so discs between 8 and 16 MB would fail.)
  Also:
  * Fixed the module base address and offsets registered with FileSwitch -
    previously the static data relocation offset was incorrectly applied.
    FileSwitch didn't actually care as long as they added up to the right
    address, but it was still wrong.
  * 32-bitting was incorrectly done using the No26bitCode switch rather than
    the No32bitCode switch, meaning that softloadable builds of this module
    were not 32-bit compatible. Softloadable builds now work on anything from
    RISC OS 3.5 onwards.
Admin:
  Tested on Raspberry Pi and Iyonix.

Version 0.95. Tagged as 'DOSFS-0_95'
@
text
@a31 2
        EXPORT  |moduleName|
        EXPORT  |moduleBase|
a132 13
|moduleBase|    &       |Image$$RO$$Base|       ; module base address


        ; -------------------------------------------------------------------
        ; char *moduleName(void)
        ; Return the name of our module to the caller.
moduleName
        ADR     a1,module_name
        MOV     pc,link
module_name
        =       "DOSFS",null                    ; module name
        ALIGN

@


4.6
log
@Trim out some local definitions, use header files instead
Use Push/Pull macros for stack operations.
Unix-ify path names in assembler files.

Version 0.89. Tagged as 'DOSFS-0_89'
@
text
@d66 4
d199 1
a199 1
        [ No26bitCode
d223 1
a223 1
        [ No26bitCode
d240 1
a240 1
        [ No26bitCode
d255 1
a255 1
        [ No26bitCode
d317 1
a317 1
        [ No26bitCode
d328 1
a328 1
        [ No26bitCode
d338 1
a338 1
        [ No26bitCode
d348 1
a348 1
        [ No26bitCode
d361 1
a361 1
        [ No26bitCode
d375 1
a375 1
        [ No26bitCode
d385 1
a385 1
        [ No26bitCode
d478 1
a478 1
        [ No26bitCode
d491 1
a491 1
        [ No26bitCode
d506 1
a506 1
        [ No26bitCode
d517 1
a517 1
        [ No26bitCode
d532 1
a532 1
        [ No26bitCode
d549 1
a549 1
        [ No26bitCode
d562 1
a562 1
        [ No26bitCode
d573 1
a573 1
        [ No26bitCode
d723 1
a723 1
        [ No26bitCode
d735 1
a735 1
        [ No26bitCode
d750 1
a750 1
        [ No26bitCode
d767 1
a767 1
        [ No26bitCode
d781 1
a781 1
        [ No26bitCode
d794 1
a794 1
        [ No26bitCode
d807 1
a807 1
        [ No26bitCode
d819 1
a819 1
        [ No26bitCode
d830 1
a830 1
        [ No26bitCode
d844 1
a844 1
        [ No26bitCode
d856 1
a856 1
        [ No26bitCode
d866 1
a866 1
        [ No26bitCode
d881 1
a881 1
        [ No26bitCode
d892 1
a892 1
        [ No26bitCode
d905 1
a905 1
        [ No26bitCode
d920 1
a920 1
        [ No26bitCode
d929 1
a929 1
        [ No26bitCode
d936 1
a936 1
        [ No26bitCode
@


4.5
log
@  Architecture-based optimisation
Detail:
  Unaligned word loads and stores have been optimised if only pre-ARMv6 or
  if only ARM6+ arachitectures need be supported.
Admin:
  Builds but untested

Version 0.86. Tagged as 'DOSFS-0_86'
@
text
@d54 11
a64 12
        GET     "Hdr:listopts"
        GET     "Hdr:macros"
        GET     "Hdr:system"
        GET     "Hdr:modhand"
        GET     "Hdr:wimp"
        GET     "Hdr:hostfs"
        GET     "Hdr:Debug"
        GET     "hdr:NDRDebug"
        GET     "Hdr:DDVMacros"
        GET     "Hdr:APCS.<APCS>"
        GET     "Hdr:CPU.Arch"
        GET     "s.MFSmacros"
d926 1
a926 1
        LDMFD   sp!,{lk}
d929 1
a929 1
        LDMFD sp!,{sl,fp,lk}   ; recover entry registers
@


4.4
log
@Made sure on return from global_error the V bit gets set,fixes bug in
finding the free space on a floppy (since freespace64 is tried first but
which led to the pointer to the error message being returned as the
freespace rather than the caller trying again another way).
Correction to missing \ in the makefile,meant you could only compile
it once having checked it out.
Fixed a pointer in the DiscOp64 support added,this caused DOSFS to go
pop when you asked it to vet a format.

Version 0.71. Tagged as 'DOSFS-0_71'
@
text
@d64 1
d945 1
d952 1
d954 1
d966 4
d975 1
d981 1
d983 1
d990 4
@


4.3
log
@Missed an ORRNES while 32 bitting,corrected.
Unused MSDOStoSTRING #if'd out to save a massive 112 bytes!
Corrected tracef1 in map_file_rostype which was printing out the
debugging before the variable got assigned.
Conditionally uses FileCore_DiscOp64 now,if available when the module
starts.
Eliminated some local 64 bit time handling code in favour of using that
already in the compiler (thanks to Kevin).
Now requires a compile time switch PCMCIA=<TRUE | FALSE> which leaves in
or takes out the PCMCIA card support.

Version 0.70. Tagged as 'DOSFS-0_70'
@
text
@d314 1
d475 1
d720 1
d917 1
d926 3
a928 3
        LDMFD sp!,{lk}
        MSR   CPSR_cxsf,lk
        ]
d933 1
@


4.2
log
@Deleted some dead variables and switches.
Eliminated MOVS and R14 fiddling to achieve 32 bit compatibility
RISCOS Ltd made 3 changes in their sources
 - ensure disc titles don't contain rogue characters (added)
 - files with time,date,and reserved fields of zero appears as DEADDEAD
   which is silly since Winodws uses this to mark a file unstamped which
   isn't quite the same thing! (not added)
 - syslog debugging support (not added)

Version 0.69. Tagged as 'DOSFS-0_69'
@
text
@d25 1
a25 1
RMAalloc        SETL    {TRUE} 
a35 3
        EXPORT  |library_double_udivide|
        EXPORT  |library_double_subtraction|
        EXPORT  |library_double_addition|
d63 1
d154 4
a157 4
        IMPORT  |DOSFS_write_extent|   ; write file extent 
        IMPORT  |DOSFS_alloc|          ; read size allocated to file 
        IMPORT  |DOSFS_flush|          ; flush file buffer 
        IMPORT  |DOSFS_ensure|         ; ensure file size 
d163 4
a166 4
        IMPORT  |DOSFS_write_cat|      ; write catalogue information 
        IMPORT  |DOSFS_delete|         ; delete object 
        IMPORT  |DOSFS_create|         ; create file 
        IMPORT  |DOSFS_create_dir|     ; create directory 
d169 2
a170 2
        IMPORT  |DOSFS_rename|            ; rename object 
        IMPORT  |DOSFS_read_dir|          ; read directory entries 
a938 3
        [ No26bitCode
        MRS     r3,CPSR
        ]
a939 7
        [ No26bitCode
        BNE     %FT10
        STR     r1,[r0,#&00]    ; word-aligned (perform write)
        MSR     CPSR_cxsf,r3
        MOV     pc,lk
10
        |
d941 1
a941 2
        MOVEQS  pc,lk           ; and exit quickly
        ]
d944 1
a944 5
        [ No26bitCode
        STMFD   sp!,{r3,r4,r5,r6,lk}
        |
        STMFD   sp!,{r4,r5,r6,lk}
        ]
d956 1
a956 7
        [ No26bitCode
        LDMFD   sp!,{r3,r4,r5,r6,lk}
        MSR     CPSR_cxsf,r3
        MOV     pc,lk
        |
        LDMFD   sp!,{r4,r5,r6,pc}^
        ]
a961 3
        [ No26bitCode
        MRS     r3,CPSR
        ]
a962 7
        [ No26bitCode
        BNE     %FT10
        LDR     r0,[r0,#&00]    ; word-aligned (perform read)
        MSR     CPSR_cxsf,r3
        MOV     pc,lk
10
        |
d964 1
a964 2
        MOVEQS  pc,lk           ; and exit quickly
        ]
d966 1
a966 5
        [ No26bitCode
        STMFD   sp!,{r3,r4,lk}
        |
        STMFD   sp!,{r4,lk}
        ]
d973 1
a973 271
        [ No26bitCode
        LDMFD   sp!,{r3,r4,lk}
        MSR     CPSR_cxsf,r3
        MOV     pc,lk
        |
        LDMFD   sp!,{r4,pc}^
        ]

        ; -------------------------------------------------------------------
        ; Perform 64bit integer arithmetic.

        ; Internal long remainder function
|x$double_lremainder|
        ; in:   a1 = divisor lo
        ;       a2 = divisor hi
        ;       a3 = dividend lo
        ;       a4 = dividend hi
        ; out:  a1 = quotient lo
        ;       a2 = quotient hi
        ;       a3 = remainder lo
        ;       a4 = remainder hi
        ;
        ; temporary internal usage
        ;       av = shift counter lo
        ;       v1 = shift counter hi
        ;       v2 = quotient lo
        ;       v3 = quotient hi

dvslo   RN      a1
dvshi   RN      a2
dvdlo   RN      a3
dvdhi   RN      a4
scntlo  RN      av
scnthi  RN      v1
quotlo  RN      v2
quothi  RN      v3

        STMFD   sp!,{av-v3,lk}
        [ No26bitCode
        MRS     av,CPSR
        Push    av
        ]
        TEQ     dvslo,dvshi       ; Z set if identical
        CMPEQS  dvslo,#&00000000  ; and check for being zero
        BEQ     dividebyzero

        MOV     scntlo,#&00000001 ; shift counter lo
        MOV     scnthi,#&00000000 ; shift counter hi
double_urem1
        CMPS    dvshi,#&80000000  ; check for divisor overflow, loword unused
        BLCC    comparison1       ; set C if divisor >= dividend
        BLCC    left_shift1       ; (divisor << 1) preserving C
        BLCC    left_shift2       ; (shift counter << 1) preserving C
        BCC     double_urem1      ; and do it again

        ; divisor has overflowed (or is bigger than dividend)
        MOV     quotlo,#&00000000 ; destination quotient lo
        MOV     quothi,#&00000000 ; destination quotient hi
double_urem2
        BL      comparison2     ; check dividend relation to divisor
        BLCS    subtraction1    ; if >= then dividend = dividend - divisor
        BLCS    addition1       ; and quotient += shift counter

        BL      right_shift1    ; divide shift counter by 2 (updating Z)
        BLNE    right_shift2    ; and if <> 0 then divide divisor by 2
        BNE     double_urem2    ; and go around again

        MOV     a1,quotlo       ; and copy the quotient into the return regs
        MOV     a2,quothi

        [ No26bitCode
        Pull    av
        MSR     CPSR_cxsf,av
        LDMFD   sp!,{av-v3,pc}
        |
        LDMFD   sp!,{av-v3,lk}
        MOVS    pc,lk           ; preserve state
        ]

comparison1
        ; we know C is clear at entry
        ; set C if divisor >= dividend
        CMPS    dvshi,dvdhi
        MOVCC   pc,lk           ; C clear (a2;a1 smaller)
        ORRNES  pc,lk,#Cbit     ; C set (a2;a1 bigger)
        ; at this point dvshi == dvdhi
        CMPS    dvslo,dvdlo     ; and return with this C state
        MOV     pc,lk           ; return this state

comparison2
        ; set C if dividend >= divisor
        CMPS    dvdhi,dvshi
        MOVCC   pc,lk
        ORRNES  pc,lk,#Cbit
        ; at this point dvshi == dvdhi
        CMPS    dvdlo,dvslo     ; and return with this C state
        MOV     pc,lk           ; return this state

left_shift1
        ; (divisor << 1) preserving C
        [ No26bitCode
        Push    lr
        MRS     lr,CPSR
        ]
        MOVS    dvslo,dvslo,ASL #1 ; (dvslo << 1) generating overflow in C
        MOV     dvshi,dvshi,ASL #1 ; (dvshi << 1)
        ADC     dvshi,dvshi,#0     ; and deal with overflow
        [ No26bitCode
        MSR     CPSR_cxsf,lr
        Pull    pc
        |
        MOVS    pc,lk              ; return preserving state
        ]

left_shift2
        ; (shift counter << 1) preserving C
        [ No26bitCode
        Push    lr
        MRS     lr,CPSR
        ]
        MOVS    scntlo,scntlo,ASL #1 ; (scntlo << 1) generating overflow in C
        MOV     scnthi,scnthi,ASL #1 ; (scnthi << 1)
        ADC     scnthi,scnthi,#0     ; and deal with overflow
        [ No26bitCode
        MSR     CPSR_cxsf,lr
        Pull    pc
        |
        MOVS    pc,lk              ; return preserving state
        ]

subtraction1
        ; dividend = dividend - divisor
        [ No26bitCode
        Push    lr
        MRS     lr,CPSR
        ]
        SUBS    dvdlo,dvdlo,dvslo
        SBC     dvdhi,dvdhi,dvshi ; include any carry that occured
        [ No26bitCode
        MSR     CPSR_cxsf,lr
        Pull    pc
        |
        MOVS    pc,lk              ; return preserving state
        ]

addition1
        ; quotient += shift counter
        [ No26bitCode
        Push    lr
        MRS     lr,CPSR
        ]
        ADDS    quotlo,quotlo,scntlo
        ADC     quothi,quothi,scnthi ; include any carry that occured
        [ No26bitCode
        MSR     CPSR_cxsf,lr
        Pull    pc
        |
        MOVS    pc,lk              ; return preserving state
        ]

right_shift1
        ; divide shift counter by 2 (return Z=1 if zero)
        MOVS    scnthi,scnthi,LSR #1 ; shift down hi
        MOV     scntlo,scntlo,RRX    ; shift in C in lo

        TEQ     scnthi,scntlo        ; Z set if identical
        CMPEQS  scnthi,#&00000000
        MOV     pc,lk                ; Z set if both zero

right_shift2
        ; divide divisor by 2
        [ No26bitCode
        Push    lr
        MRS     lr,CPSR
        ]
        MOVS    dvshi,dvshi,LSR #1 ; shift down hi
        MOV     dvslo,dvslo,RRX    ; shift in C in lo
        [ No26bitCode
        MSR     CPSR_cxsf,lr
        Pull    pc
        |
        MOVS    pc,lk              ; return preserving state
        ]

        ; -------------------------------------------------------------------
        ; Double unsigned division.
        ; in:   a1 = pointer to 64bit unsigned int divisor
        ;       a2 = pointer to 64bit unsigned int dividend
        ; out:  a1 = pointer to 64bit quotient
|library_double_udivide|
        STMFD   sp!,{a2,a3,a4,av,v1,v2,v3,v4,ip,lk}
        [ No26bitCode
        MRS     lk,CPSR
        Push    lk
        ]
        MOV     v4,a1            ; remember return data point
        LDMIA   a2,{dvdlo,dvdhi} ; load dividend in a4;a3
        LDMIA   v4,{dvslo,dvshi} ; load divisor in a2;a1
        BL      |x$double_lremainder|
        ; quotient in a2;a1
        STMIA   v4,{a1,a2}
        MOV     a1,v4            ; and return pointer to block
        [ No26bitCode
        Pull    lk
        MSR     CPSR_cxsf,lk
        LDMFD   sp!,{a2,a3,a4,av,v1,v2,v3,v4,ip,pc}
        |
        LDMFD   sp!,{a2,a3,a4,av,v1,v2,v3,v4,ip,lk}
        MOVS    pc,lk            ; return preserving state
        ]

        ; -------------------------------------------------------------------
        ; Double subtraction.
        ; in:   a1 = pointer to 64bit unsigned int "arg1"
        ;       a2 = pointer to 64bit unsigned int "arg2"
        ; out:  a1 = pointer to 64bit unsigned int "arg1 - arg2"
|library_double_subtraction|
        STMFD   sp!,{a2,a3,a4,av,lk}
        [ No26bitCode
        MRS     lk,CPSR
        ]
        MOV     av,a1
        LDMIA   a2,{a3,a4}
        LDMIA   av,{a1,a2}

        SUBS    a1,a1,a3
        SBC     a2,a2,a4        ; include any carry that occured

        STMIA   av,{a1,a2}
        MOV     a1,av           ; and return pointer to block
        [ No26bitCode
        MSR     CPSR_cxsf,lk
        LDMFD   sp!,{a2,a3,a4,av,pc}
        |
        LDMFD   sp!,{a2,a3,a4,av,lk}
        MOVS    pc,lk           ; return preserving state
        ]

        ; -------------------------------------------------------------------
        ; Double addition.
        ; in:   a1 = pointer to 64bit unsigned int "arg1"
        ;       a2 = pointer to 64bit unsigned int "arg2"
        ; out:  a1 = pointer to 64bit unsigned int "arg1 + arg2"
|library_double_addition|
        STMFD   sp!,{a2,a3,a4,av,lk}
        [ No26bitCode
        MRS     lk,CPSR
        ]
        MOV     av,a1
        LDMIA   a2,{a3,a4}
        LDMIA   av,{a1,a2}

        ADDS    a1,a1,a3
        ADC     a2,a2,a4

        STMIA   av,{a1,a2}
        MOV     a1,av
        [ No26bitCode
        MSR     CPSR_cxsf,lk
        LDMFD   sp!,{a2,a3,a4,av,pc}
        |
        LDMFD   sp!,{a2,a3,a4,av,lk}
        MOVS    pc,lk           ; return preserving state
        ]

        ; -------------------------------------------------------------------
        ; Division by zero generated by one of our extensions. This relies
        ; on knowledge of the C library ("raise" and exception numbers).
dividebyzero
        MOV     a1,#2                   ; arithmetic exception
        B       |raise|
a978 1
        STMFD   sp!,{lk}
d980 4
a983 7
        [ No26bitCode
        LDMEQFD sp!,{pc}                ; exit quickly is NULL length
        |
        LDMEQFD sp!,{pc}^               ; exit quickly is NULL length
        ]
        MOVNE   r0,#ModHandReason_Claim
        SWINE   OS_Module
d986 1
a986 5
        [ No26bitCode
        LDMEQFD sp!,{pc}
        |
        LDMEQFD sp!,{pc}^
        ]
d996 1
a996 1
        STMFD   sp!,{lk}
d1001 1
a1001 1
        SWI     OS_Module
d1004 1
a1004 5
        [ No26bitCode
        LDMEQFD sp!,{pc}
        |
        LDMEQFD sp!,{pc}^
        ]
d1009 1
a1009 1
        STMFD   sp!,{lk}
d1012 1
a1012 1
        SWINE   OS_Module               ; if not NULL then release memory
d1014 1
a1014 5
        [ No26bitCode
        LDMEQFD sp!,{pc}
        |
        LDMEQFD sp!,{pc}^
        ]
@


4.1
log
@Initial revision
@
text
@d23 1
a23 6

                GBLL    newcode
newcode         SETL    {TRUE}          ; calls not detailed in JRoach docs

        ; -------------------------------------------------------------------

d25 1
a25 3
RMAalloc        SETL    {TRUE}          ; include RMA allocation routines

        ; -------------------------------------------------------------------
d42 1
a42 1
        [       (RMAalloc)
d46 1
a46 1
        ]       ; EOF (RMAalloc)
a56 2
        ; -------------------------------------------------------------------

a59 1
;        GET     "Hdr:File"
d63 2
a64 1
        GET     "Hdr:NdrDebug"
d69 1
a69 1

d71 1
a71 1

a72 2
hostvdu         SETL    false           ; TUBE debugging output

d80 4
a83 1
tmp             SETD    false
d86 1
a86 2

        ; standard C register definitions
a96 4

;sl      RN      10
;fp      RN      11
;ip      RN      12
d99 2
a100 1
        ; standard floating point register definitions
a105 1

a112 17
NegativeBit     *       Nbit
ZeroBit         *       Zbit
CarryBit        *       Cbit
OverflowBit     *       Vbit
FiqBit          *       Fbit
IrqBit          *       Ibit
SVCmode         *       &00000003

bit31   bit     31
bit30   bit     30
bit29   bit     29

null            *       &00
lf              *       &0A
cr              *       &0D
space           *       " "

d122 3
a124 2

spare_word         *    &2053474A                       ; "JGS "
d127 1
a127 1
fs_number       SETA    0               ; undefined filing system
d130 1
a130 2
        ; private (assembler) data

a134 7
module_name
        =       "DOSFS",null                    ; module name
        [       {FALSE} ; not required
DOS_module_selected
        =       "MultiFS DOS support",null      ; module banner
        ]       ; EOF {boolean}
        ALIGN
a136 2
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
d140 5
a144 4
        ADRL    a1,module_name
        MOVS    pc,link

        ; -------------------------------------------------------------------
a159 1
        [       (newcode)
a160 1
        ]       ; EOF (newcode)
d187 1
a188 1
        ; RISC OS Filing System interface:
d191 1
a191 1
        Debug   open,"DOSFS_Open",r0,r1,r6
d197 4
d202 3
a204 1
        LDMIA   r0,{r0-r4}              ; r0 = pointer to information block
a209 1
        BICS    pc,lk,#Vbit
d214 1
a214 1
        Debug   bget,"DOSFS_GetBytes",r1,r2,r3,r4
d221 3
d226 1
d231 1
a231 1
        Debug   bput,"DOSFS_PutBytes",r1,r2,r3,r4
d238 3
d243 1
d248 1
a248 1
        Debug   close,"DOSFS_Close",r1,r2,r3
d253 3
d258 1
d263 1
a263 1
        Debug   args,"DOSFS_Args",r0
a283 1
        [       (newcode)
a287 1
        ]       ; EOF (newcode)
a306 1
        [       (newcode)
a307 3
        |
        B       DOS_notsupported                ; 08 / 8
        ]       ; EOF (newcode)
d315 3
d319 1
d325 3
d330 1
d335 3
d340 1
d345 4
d352 1
d358 4
d365 1
a366 1
        [       (newcode)
d372 3
d377 1
a377 1
        ]       ; EOF (newcode)
d382 4
d389 1
d394 1
a394 1
        Debug   file,"DOSFS_File",r0
d475 3
d479 1
d487 4
d494 1
d502 3
d507 1
d513 5
d522 1
d528 5
d537 1
a539 1
        [       {TRUE}  ; documentation seems to be wrong
d545 2
a546 2
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
a547 5
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; load address
        MOV     a3,r3                   ; exec address
        MOV     a4,r4                   ; length
        Ccall   |DOSFS_create|,1,r6     ; filing system image handle
d550 1
a550 1
        ]       ; EOF {boolean}
d558 3
d563 1
d569 4
d576 1
d581 1
a581 1
        Debug   func,"DOSFS_Func",r0
d719 3
d723 1
d730 4
d737 1
d745 5
d754 1
d762 4
d770 1
d776 4
d784 1
d789 3
d794 1
d802 3
d807 1
d814 3
d819 1
d825 4
d832 1
d839 3
d844 1
d851 3
d856 1
d861 5
d870 1
d876 3
d881 1
d887 3
d892 1
d900 4
d907 1
d915 3
d919 1
d923 10
a932 3
        ; There should be no stacked state at this point
        MOV     a1,#nostack
        Ccall   |global_error|
d934 1
a936 2
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
d941 3
d945 7
d954 2
d957 3
d961 1
a961 1

d973 5
a977 1

d979 1
d985 3
d989 7
d998 1
d1000 3
d1004 1
a1004 1

d1011 5
a1015 1

d1017 1
a1019 2
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
d1049 4
a1052 1

d1081 5
d1088 1
d1095 1
a1095 1
        ORRNES  pc,lk,#CarryBit ; C set (a2;a1 bigger)
d1104 1
a1104 1
        ORRNES  pc,lk,#CarryBit
d1111 4
d1118 4
d1123 1
d1127 4
d1134 6
a1139 1
        MOVS    pc,lk                ; return preserving state
d1143 4
d1149 6
a1154 1
        MOVS    pc,lk             ; preserve state
d1158 4
d1164 6
a1169 1
        MOVS    pc,lk                ; preserve state
d1182 4
d1188 6
a1193 1
        MOVS    pc,lk              ; preserve state
d1202 4
d1212 6
a1217 1
        MOV     a1,v4           ; and return pointer to block
d1219 2
a1220 1
        MOVS    pc,lk
d1229 3
d1241 4
d1246 2
a1247 1
        MOVS    pc,lk
d1256 3
d1268 4
d1273 2
a1274 1
        MOVS    pc,lk
d1280 1
a1280 1
        MOV     a1,#2           ; arithmetic exception
d1284 2
a1285 4
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------

        [       (RMAalloc)
d1289 3
d1293 1
d1298 5
a1302 1
        LDMFD   sp!,{pc}^
d1320 5
a1324 1
        LDMFD   sp!,{pc}^
d1334 6
a1339 12
        LDMFD   sp!,{pc}^
        ]       ; EOF (RMAalloc)

        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------

 [ debug
        InsertNDRDebugRoutines
 ]

        ; -------------------------------------------------------------------
a1342 1
        ; -------------------------------------------------------------------
@


4.1.8.1
log
@Makefile edits and various plumbing to make the darn thing build
@
text
@d75 1
a75 1
        GET     s.MFSmacros
d194 4
a197 4
        IMPORT  |DOSFS_write_extent|   ; write file extent
        IMPORT  |DOSFS_alloc|          ; read size allocated to file
        IMPORT  |DOSFS_flush|          ; flush file buffer
        IMPORT  |DOSFS_ensure|         ; ensure file size
d205 4
a208 4
        IMPORT  |DOSFS_write_cat|      ; write catalogue information
        IMPORT  |DOSFS_delete|         ; delete object
        IMPORT  |DOSFS_create|         ; create file
        IMPORT  |DOSFS_create_dir|     ; create directory
d211 2
a212 2
        IMPORT  |DOSFS_rename|            ; rename object
        IMPORT  |DOSFS_read_dir|          ; read directory entries
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

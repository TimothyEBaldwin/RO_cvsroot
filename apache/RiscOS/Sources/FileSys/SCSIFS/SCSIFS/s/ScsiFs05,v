head	4.17;
access;
symbols
	SCSIFS-1_35:4.17
	SCSIFS-1_34:4.17
	SCSIFS-1_33:4.17
	SCSIFS-1_32:4.16
	SCSIFS-1_31:4.15
	SCSIFS-1_30:4.14
	SCSIFS-1_29:4.12
	SCSIFS-1_28:4.11
	SCSIFS-1_27:4.9
	SCSIFS-1_26:4.8
	SCSIFS-1_25:4.8
	SCSIFS-1_24:4.7
	SCSIFS-1_23:4.7
	SCSIFS-1_22:4.6
	SCSIFS-1_21:4.6
	SCSIFS-1_20:4.5
	SCSIFS-1_19:4.5
	SCSIFS-1_18:4.4
	SCSIFS-1_17:4.4
	SCSIFS-1_16:4.4
	SCSIFS-1_15:4.3
	SCSIFS-1_14:4.3
	SCSIFS-1_13:4.3
	SCSIFS-1_12:4.3
	RO_5_07:4.2
	SCSIFS-1_11:4.2
	dellis_autobuild_BaseSW:4.1
	SCSIFS-0_25:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SCSIFS-0_25:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	RCA:4.1.0.2
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.17
date	2018.07.13.22.53.48;	author jballance;	state Exp;
branches;
next	4.16;
commitid	aFrQNZfF8zc8R1KA;

4.16
date	2017.09.09.20.44.51;	author jlee;	state Exp;
branches;
next	4.15;
commitid	fVsl5HJYpQ5I0z6A;

4.15
date	2017.09.09.20.36.36;	author jlee;	state Exp;
branches;
next	4.14;
commitid	R0KtP8j50xURXy6A;

4.14
date	2017.09.09.20.30.01;	author jlee;	state Exp;
branches;
next	4.13;
commitid	bB8BD6OBVuZBVy6A;

4.13
date	2017.09.09.20.23.53;	author jlee;	state Exp;
branches;
next	4.12;
commitid	urDJ2k0Cof4xTy6A;

4.12
date	2016.11.28.21.31.27;	author jballance;	state Exp;
branches;
next	4.11;
commitid	TW8MDzs0EPmFqWvz;

4.11
date	2013.10.06.13.49.20;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	8D9mMcKPmGAXNe8x;

4.10
date	2013.10.06.13.28.24;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	y16pwkkQv9juGe8x;

4.9
date	2013.08.23.07.00.55;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	7jw3CbjLYaGwXx2x;

4.8
date	2012.03.21.01.59.37;	author bavison;	state Exp;
branches;
next	4.7;
commitid	Ds1Q6pzW6vPu0HXv;

4.7
date	2011.11.27.17.55.40;	author jlee;	state Exp;
branches;
next	4.6;
commitid	0EKpaWv5jXTFZZIv;

4.6
date	2011.08.04.21.38.57;	author jlee;	state Exp;
branches;
next	4.5;
commitid	13IK5nkWJrWrVeuv;

4.5
date	2011.01.12.22.53.40;	author jlee;	state Exp;
branches;
next	4.4;

4.4
date	2005.06.27.15.41.11;	author jballance;	state Exp;
branches;
next	4.3;

4.3
date	2005.01.31.13.37.39;	author jballance;	state Exp;
branches;
next	4.2;

4.2
date	2003.05.23.13.05.38;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.34.12;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.34.12;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.04.54;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.42.09;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.38.28;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.17
log
@  Altered interaction with PartMan. PartMan now tells SCSIFS when it can
  attempt to mount a newly connected disc.
Detail:
  In order to be certain that the partition table has been fully analysed
  before SCSIFS attempts to mount a newly connected disc, if Partman is
  detected, SCSIFS waits for a service call from PartMan before it attempts
  to mount any partitions on the disc. If PartMan interaction is not compiled,
  in, or PartMan is not detected, SCSIFS behaviour is unaltered.
Admin:
 tested on iMx6

Version 1.33. Tagged as 'SCSIFS-1_33'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;>ScsiFs05

    [ Dev

        ; Ugly but necessary because debug macros can get called before
        ; workspace is set up
        ; Exits NE if IRQsema <> 0
        MACRO
        CheckIRQsema
        Push    "r0-r2,lr"
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_IRQsema
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        LDREQ   r2, =Legacy_IRQsema
        LDR     r2, [r2]
        TEQ     r2, #0
        Pull    "r0-r2,lr"
        MEND

PHEX
        SavePSR R4
      [ :LNOT: IrqDebug
        CheckIRQsema
        BNE     PHEXIT1                 ; return if IRQ thread
      ]
        MOV     R3, LR
        ; Switch to SVC mode, preserving flags (+ disabling IRQs?)
      [ No32bitCode
        SetMode SVC_mode, R0
      |
        SetModeSEI SVC32_mode, R0
      ]
        Push    "LR"
      [ SpoolOff
        BL      SpoolOff
      ]
        MOV     R1, #32-4
PHLOOP
        MOV     R0, R2, LSR R1
        AND     R0, R0, #&F
        CMPS    R0, #10
        ADDCC   R0, R0, #"0"
        ADDCS   R0, R0, #"A"-10
        SWI     OS_WriteC
        SUBS    R1, R1, #4
        BPL     PHLOOP
        MOV     R0, #" "
        SWI     OS_WriteC
      [ SpoolOff
        BL      SpoolOn
      ]
        Pull    "LR"
        RestPSR R4,,cf
        MOV     PC, R3
PHEXIT1
        RestPSR R4,,f
        MOV     PC, LR


      [ SpoolOff
SpoolOff
        Push    "R0-R3,LR"
        SavePSR R3
        MOV     R0, #OsByte_SpecifyOutputStream
        MOV     R1, #&10
        MOV     R2, #&EF
        SWI     OS_Byte
        RestPSR R3,,f
        Pull    "R0-R3,PC"

SpoolOn
        Push    "R0-R3,LR"
        SavePSR R3
        MOV     R0, #OsByte_SpecifyOutputStream
        MOV     R1, #0
        MOV     R2, #&EF
        SWI     OS_Byte
        RestPSR R3,,f
        Pull    "R0-R3,PC"
      ]

Mess1                   ;R0,R1,LR stacked
        SavePSR R0                      ; save PSR
        MOV     R1, LR                  ; save link
      [ :LNOT: IrqDebug
        CheckIRQsema
        MOVNE   PC, R1                  ; skip if IRQ thread, return NE
      ]
        BIC     LR, R0, #3
      [ No32bitCode
        ORR     LR, LR, #SVC_mode :OR: Z_bit
        TEQP    PC, LR                  ; go to supervisor mode, preserve FI, set EQ
        MOV     R0, R0                  ; delay for mode change
      |
        ORR     LR, R0, #Z_bit
        ORR     LR, LR, #SVC26_mode :OR: I32_bit
        MSR     CPSR_cf, LR
      ]
        Push    "LR"
      [ SpoolOff
        BL      SpoolOff
      ]
        MOV     PC, R1

      [ {FALSE}
TubeWrHexWord ROUT
        SavePSR R4
        MOV     R3, LR
        MOV     R1, #32-4
05
        MOV     R0, R2, LSR R1
        AND     R0, R0, #&F
        CMPS    R0, #10
        ADDCC   R0, R0, #"0"
        ADDCS   R0, R0, #"A"-10
        BL      TubeChar                ; (R0)
        SUBS    R1, R1, #4
        BPL     %BT05
        MOV     R0, #" "
        BL      TubeChar                ; (R0)
        RestPSR R4,,f
        MOV     PC, R3

        ^       0, R1
R1_status  # 4
R1_data    # 4
TubeAddress * &3340000 + (0*&4000)      ;podule 0

TubeChar ROUT
        Push    "R1,LR"
        LDR     R1, =TubeAddress
10
        LDRB    LR, R1_status
        TSTS    LR, #&40
        BEQ     %BT10
        STRB    R0, R1_data
        Pull    "R1,PC"
      ]
    ]

; ====
; SetV
; ====

SetV
      [ No32bitCode
        ORRS    PC, LR, #V_bit
      |
        Push    "LR"
        SETPSR  V_bit, LR
        Pull    "PC"
      ]


; ========
; SetVOnR0
; ========

SetVOnR0
      [ No32bitCode
        CMPS    R0, #0
        BICEQS  PC, LR, #V_bit
        ORRNES  PC, LR, #V_bit
      |
        Push    "LR"
        MRS     LR, CPSR
        CMPS    R0, #0
        BICEQ   LR, LR, #V_bit
        ORRNE   LR, LR, #V_bit
        MSR     CPSR_f, LR
        Pull    "PC"
      ]


; =============
; ReadCMOSflags
; =============

;read the CMOS byte containing number of drives, default drive & dir/no dir bit

; exit R0,V result
;  R2 = full byte
;  R3 = number of removable media drives (floppies)
;  R4 = number of fixed media drives (winnies)
;  R5 = default drive
ReadCMOSflags ROUT
        Push    "R1,LR"
        MOV     R0, #OsByte_ReadCMOS
        MOV     R1, #CMOSflags
        SWI     XOS_Byte                ; (R0-R2->R0-R2,V)
        MOVVS   R2, #2_01000001         ; default NoDir, one drive
        BVS     %FT95
        MOV     R3, R2, LSR #6
        AND     R4, R2, #2_00000111
        CMPS    R4, #4
        MOVHI   R4, #1
        AND     R5, R2, #2_00111000
        MOV     R5, R5, LSR #3
95
        MOV     R3, #4
        MOV     R4, #4
        Pull    "R1,PC"


; ============
; ReadFileCMOS
; ============

; exit R0,V result
;  R5 = extra file buffers in K

ReadFileCMOS ROUT
        Push    "R1,R2,R4,LR"
        MOV     R0, #OsByte_ReadCMOS
        MOV     R1, #FileCMOS
        SWI     XOS_Byte                ; (R0-R2->R0-R2,V)
        MOVVC   R5, R2
        TEQS    R5, #1
        BNE     %FT10
        BL      DefaultCacheSize        ; ->R4
        MOV     R5, R4, LSR #10
10
        MOVVS   R5, #0
        Pull    "R1,R2,R4,PC"


; ===========
; ReadDirCMOS
; ===========

; exit R0,V result
;  R4 = dir cache size in bytes

ReadDirCMOS
        Push    "R1,R2,LR"
        MOV     R0, #OsByte_ReadCMOS
        MOV     R1, #DirCMOS
        SWI     XOS_Byte                ; (R0-R2->R0-R2,V)
        MOVVS   R2, #0
        MOVS    R4, R2, LSL #10
        BLEQ    DefaultCacheSize        ; ->R4
        Pull    "R1,R2,PC"


; ================
; DefaultCacheSize
; ================

; exit R4 default size

DefaultCacheSize ROUT
        Push    "R0-R3,R5-R7,LR"
        MOV     R0, #0
        MOV     R1, #0
        MOV     R2, #0
        MOV     R3, #0
        Push    "R0-R3"
        Pull    "R4-R7"                 ; R0-R7 now zero
        SWI     XOS_SetEnv              ; returns RAM size in R2
        MOV     R4, R2, LSR #8
        CMPS    R4, #255*1024
        MOVHI   R4, #255*1024
        CLRV
        Pull    "R0-R3,R5-R7,PC"


; ==========
; SkipSpaces
; ==========

; entry R1 -> char
; exit
;  R0 char
;  R1 -> char after first non space char
;  C set <=> terminator

SkipSpaces ROUT
        Push    "LR"
10
        LDRB    R0, [R1], #1
        TEQS    R0, #" "
        BEQ     %BT10
        CMPS    R0, #DeleteChar
        RSBNES  LR, R0, #" "-1
        Pull    "PC"


; =============
; ParseAnyDrive
; =============

;doesn't check if drive is allowed by configure

ParseAnyDrive ROUT
        Push    "LR"

; Entry: R1-> string
; Exit:  R1-> first char after
;  good => R0 drive number, V=0
;  bad  => R0 -> error, V=1

        BL      SkipSpaces              ; (R1->R0,R1,C)
        BCS     %FT10                   ; reject nul string
        LDRB    LR, [R1]
        CMPS    LR, #DeleteChar
        RSBNES  LR, LR, #" "            ; check terminated
        BCC     %FT10                   ; not terminated

        CMPS    R0, #"a"
        SUBHS   R0, R0, #"a"-"A"
        CMPS    R0, #"A"
        SUBHS   R0, R0, #"A"-"0"
        SUBS    R0, R0, #"0"
        RSBCSS  LR, R0, #7
        Pull    "PC",CS
10
        ADRL    R0, ErrorBlock_SCSIFSBadDrive
        BL      CopyError
        Pull    "PC"


; =====
; WrDec
; =====

; write a space followed by a zero supressed decimal number

; entry R0 number

; exit if error V set, R0 result

WrDec   ROUT
        Push    "R0-R2,LR"
        MOV     R2, #4                  ; Temporary buffer size
        SUB     SP, SP, R2
        MOV     R1, SP
        SWI     XOS_ConvertCardinal1
        SWIVC   XOS_WriteI+' '
        SWIVC   XOS_Write0
        ADD     SP, SP, #4
        STRVS   R0,[SP]
        Pull    "R0-R2,PC"

; In:
;  R1 = SCSI device ID
; Out:
;  R1 = FileCore drive number, or MaxDriveNo if not found
MapDevToDrv ROUT
        Push    "R2,R3,LR"
        MOV     R2, #0
01
        mapDrvToDevLo R3, R2
        TEQ     R3, R1
        ADDNE   R2, R2, #1
        TEQNE   R2, #MaxDriveNo
        BNE     %BT01
        MOV     R1, R2
        Pull    "R2,R3,PC"

; In:

; In:
;  R0 = device ID
;  R2 = device ID mask      (we scan all devices with ID AND R2 = R0)
;  R3 = configured number of removable media drives
;  R4 = configured number of fixed media drives
; Out:
;  R3 = actual number of removable media drives (<= entry R3)
;  R4 = actual number of fixed media drives     (<= entry R4)
;  Drive -> Device mappings filled in
ScanDrives2
        Push    "R0-R2,R5-R8,LR"
        SUB     SP, SP, #36
      [ Debug7
        wrhex   R0
        wrhex   R2
        wrhex   R3
        wrhex   R4
        mess    ,">ScanDrives",NL
      ]
        MOV     R1, #0
        MOV     R5, #0
        MOV     R6, #0
ScanLoop
        TEQ     R3, R5
        TEQEQ   R4, R6
        BEQ     ScanFinished

        LDR     LR, [SP, #36+0*4]       ; check we fall within the mask
        LDR     R8, [SP, #36+2*4]
        AND     R8, R1, R8
        TEQ     R8, LR
        BNE     ScanNext

      [ AllowPartitions
        LDRB    R8, allowdupID
        TEQ     R8, #0
        MOVNE   R8, #0
        STRNEB  R8,allowdupID
        BNE     BypassCheck             ; partitions reuse same scsi drive
      ]
        MOV     R8, R1                  ; check we've not already
        BL      MapDevToDrv             ; spotted this drive
        TEQ     R1, #MaxDriveNo
        MOV     R1, R8
        BNE     ScanNext
      [ AllowPartitions
BypassCheck
      ]

        ; I don't use SCSI_Initialise 2 as it will report errors from
        ; the READ CAPACITY command (likely at start-up). Instead,
        ; do just an INQUIRY command manually.
      [ Debug7
        wrhex   R1
        mess    ,"Inquiry",NL
      ]
        Push    "R0-R5"
        ORR     R0, R1, #CTL_TXREAD
        MOV     R1, #6
        ADR     R2, CDB_Inquiry
        ADD     R3, SP, #6*4
        MOV     R4, #36
        MOV     R5, #100
        MOV     R8, R12
        SWI     XSCSI_Op
        TEQ     R4, #0
        Pull    "R0-R5"
        BVS     ScanNextDev
        BNE     ScanNextDev
ScanCheck
        LDRB    LR, [SP, #0]
      [ Debug7
        wrhex   LR
        mess    ,"Type",NL
      ]
        TEQ     LR, #DevDirectAccess
        TEQNE   LR, #DevOpticalMemory
        BNE     ScanNext
        LDRB    LR, [SP, #1]
        TST     LR, #&80                ; Removable bit
        BNE     AddRemovable
AddFixed
      [ Debug7
        wrhex   R6
        mess    ,"Adding fixed",NL
      ]
        MOV     R0, #4
        BL      MapInDevice
        ADDNE   R6, R6, #1
        B       ScanNext
AddRemovable
      [ Debug7
        wrhex   R5
        mess    ,"Adding removable",NL
      ]
        MOV     R0, #0
        BL      MapInDevice
        ADDNE   R5, R5, #1
ScanNext
      [ PartitionManager
        Push    "R2"
        MOV     R2, #1
        SWI     XPartMan_MorePartitions
        TEQ     R2, #0                  ; SWI returns 0 if more partitions to mount
        MOVEQ   r2, #1
        STREQB  R2, allowdupID
        Pull    "R2"                    ; SWI returns 1 if no more, or error if swi not there
        BEQ     ScanLoop
      ]
        ADD     R1, R1, #&20            ; move to next LUN
        TST     R1, #&100
        BEQ     ScanLoop
ScanNextDev
        AND     R1, R1, #&1F
        ADD     R1, R1, #1              ; move to next device/card
        TST     R1, #&20
        BEQ     ScanLoop

        MOV     R3, R5
        MOV     R4, R6
ScanFinished
        ADD     SP, SP, #36
      [ Debug7
        wrhex   R3
        wrhex   R4
        mess    ,"<ScanDrives",NL
      ]
        Pull    "R0-R2,R5-R8,PC"

ScanDrives
        Push    "R0,R2,LR"
        MOV     R0,#0
        MOV     R2,#0
        BL      ScanDrives2
        Pull    "R0,R2,PC"

CDB_Inquiry
        DCB     &12                     ; INQUIRY
        DCB     0
        DCB     0
        DCB     0
        DCB     36
        DCB     0
        ALIGN


; check if this drive is 'disabled'. A drive is 'disabled' if its
; inquiry string from offset 8 to offset 31 inclusive matches one
; in file Choices:SCSIFS.Hide
;   otherwise it is allowed.
; in : R1=driveID
; out: EQ if not allowed, else NE
CheckDriveAllowed ROUT
        Push    "R0-R5,R8,LR"
      [ Debug7
        wrhex   R1
        mess    ,"MapInDrive",NL
      ]
        ORR     R0, R1, #CTL_TXREAD
        MOV     R1, #6
        ADR     R2, CDB_Inquiry
        SUB     SP, SP, #36 + 44
        MOV     R3, SP
        MOV     R4, #36
        MOV     R5, #100
        MOV     R8, R12
        SWI     XSCSI_Op
        BVS     CDANotAllowed           ; wont allow drive if error
        TEQ     R4, #0
        BNE     CDANotAllowed           ; wont allow if no full enquiry response
        Push    "R3"

        MOV     R0, #&4f                ; 4f open R/O no path, error if a dir or not exist
        ADRL    R1, ChoicesHide
        SWI     XOS_Find                ; look for our choices.Hide file
        ADDVS   SP, SP, #4              ; junk stacked R3
        BVS     CDAAllowed              ; choices didnt open

        MOV     R1, R0                  ; file handle

lp0     MOV     R0, #4                  ; use current pointer
        LDR     R2, [SP]                ; buffer space after enquiry data
        MOV     R3, #1                  ; first byte
        SWI     XOS_GBPB                ; read first byte
        TEQ     R3,#0                   ; all read?
        BNE     goteof                  ; incomplete line .. file end reached
        LDR     R5, [SP]                ; buffer space after enquiry data
        LDRB    R5, [R5]
        TEQ     R5, #'|'                ; a comment line?
        BNE     lp1
lp2     MOV     R0, #4                  ; use current pointer
        LDR     R2, [SP]                ; buffer space after enquiry data
        MOV     R3, #1                  ; first byte
        SWI     XOS_GBPB                ; read first byte
        TEQ     R3,#0                   ; all read?
        BNE     goteof                  ; incomplete line .. file end reached
        LDR     R5, [SP]                ; buffer space after enquiry data
        LDRB    R5, [R5]
        TEQ     R5, #10                 ; end line?
        BNE     lp2                     ; no.. go there
        B       lp0                     ; back for next line
lp1     MOV     R0, #4                  ; use current pointer
        MOV     R3, #8 + 16 + 4         ; rest of enquiry data + 1 linefeed
        SWI     XOS_GBPB                ; read first line
        TEQ     R3,#0                   ; all read?
        BNE     goteof                  ; incomplete line .. file end reached
        SUB     R2, R2, #5              ; point to last word of enq data read
        LDR     R4, [SP]                ; buffer space after enquiry data
        SUB     R4, R4, #4              ; last word of this enq data

      [ Debug7
        wrhex   R2
        wrhex   R4
        mess    ,"MapInDrive",NL
      ]

        MOV     R5, #8 + 16 + 4

cmpr    LDR     R0, [R2], #-4           ; compare strings
        LDR     R3, [R4], #-4
        TEQ     R0, R3
        BNE     lp0                     ; not a match.. try next
        SUBS    R5, R5, #4
        BGT     cmpr                    ; loop
        ; match found
        MOV     R0, #0
        SWI     XOS_Find                ; close the file again
        ADD     SP, SP, #4              ; junk stacked R3
        B       CDANotAllowed

goteof  MOV     R0, #0
        SWI     XOS_Find                ; close the file again
        ADD     SP, SP, #4              ; junk stacked R3

CDAAllowed
        ADD     SP, SP, #36 + 44
        TEQ     PC, #0
        Pull    "R0-R5,R8,PC"           ; exit NE.. allowed

CDANotAllowed
        ADD     SP, SP, #36 + 44
        TEQ     R0, R0
        Pull    "R0-R5,R8,PC"           ; exit EQ.. not allowed

ChoicesHide
        DCB     "Choices:SCSIFS.Hide",0
        ALIGN



; In: R0 = 0 or 4 (indicating drive number range)
;     R1 = device number
; Out: NE if found a slot
MapInDevice
        Push    "R0,R1,R3,R5,LR"
        BL      CheckDriveAllowed
        Pull    "R0,R1,R3,R5,PC",EQ        ; Exit (with EQ)
10
        DrvRecPtr R5,R0
        mapDrvToDevLo R3,R0,R5
        CMP     R3, #-1
        BNE     %FT60
        STDevNo R1,R5, LR
        MOV     R1, R0
        MOV     R0, #UpCall_DriveAdded
        BL      UpcallDrive             ; issue an upcall
        MOV     R0, R1
        TEQ     PC,#0
        Pull    "R0,R1,R3,R5,PC"        ; Exit (with NE)

60      ADD     R0, R0, #1
        TST     R0, #3
        BNE     %BT10
        Pull    "R0,R1,R3,R5,PC"        ; Exit (with EQ)

      [ PartitionManager
; In: R0 = device number
;     R2 = device number mask
ServiceMorePartitions
        getSB
        
        Push    "R0-R3,LR"
        B       DA1
      ]

ServiceAttachDetach
        getSB
        ASSERT  Service_SCSIAttached:AND:1 = 0
        ASSERT  Service_SCSIDetached:AND:1 = 1
        TST     R1, #1
        BEQ     DoAttached
        BNE     DoDetached

        ^       0
ACBD_DevID      #       4
ACBD_DevIDMask  #       4
ACBD_SB         #       4
AttachedCBDataSz # 0

; In: R0 = device number
;     R2 = device number mask
; Note the parameters (in an allocated block) to deal with on a callback
DoAttached      ROUT
        Push    "R0-R3,LR"
      [ PartitionManager
        MOV     R1, #-1
        ; swi returns VS if not there
        SWI     XPartMan_MorePartitions
        ; if there then scan will be triggered by partition manager
        Pull    "R0-R3,PC",VC
      ]
DA1
        LDRB    R0, Dieing
        TEQ     R0, #0
        Pull    "R0-R3,PC",NE

        MOV     R0, #ModHandReason_Claim
        MOV     R3, #AttachedCBDataSz
        SWI     XOS_Module
        Pull    "R0-R3,PC",VS
        LDR     R0, [SP, #0]
        LDR     LR, [SP, #8]
        STR     R0, [R2, #ACBD_DevID]
        STR     LR, [R2, #ACBD_DevIDMask]
        STR     SB, [R2, #ACBD_SB]
        LDRB    R0, AttCBCount
        ADD     R0, R0,#1
        CMP     R0, #&100
        MOVGE   R0, #&ff
        STRB    R0, AttCBCount
        ADR     R0, DoAttachedCallback
        MOV     R1, R2
        SWI     XOS_AddCallBack
        Pull    "R0-R3,PC"

DoAttachedCallback  ROUT
        Push    "R0,R2,R3,R4,LR"
        Push    "R12"
        LDR     R0,[R12, #ACBD_DevID]
        LDR     R2,[R12, #ACBD_DevIDMask]
        LDR     SB,[R12, #ACBD_SB]
        LDRB    LR, Dieing
        TEQ     LR, #0
        BNE     %ft1                       ; no point in attaching if dieing
        MOV     R3,#4
        MOV     R4,#4
        BL      ScanDrives2
1
        Pull    "R2"
        LDRB    R0, AttCBCount
        SUBS    R0,R0,#1
        STRGEB  R0, AttCBCount
        MOV     R0,#ModHandReason_Free
        SWI     XOS_Module
        Pull    "R0,R2,R3,R4,PC"

; In: R0 = device number
;     R2 = device number mask
; Note the parameters (in an allocated block) to deal with on a callback
DoDetached
        Push    "R0-R2,LR"
        LDRB    R0, Dieing
        TEQ     R0, #0
        Pull    "R0-R2,PC",NE
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #AttachedCBDataSz
        SWI     XOS_Module
        Pull    "R0-R2,PC",VS
        LDR     R0, [SP, #0]
        LDR     LR, [SP, #8]
        STR     R0, [R2, #ACBD_DevID]
        STR     LR, [R2, #ACBD_DevIDMask]
        STR     SB, [R2, #ACBD_SB]
        LDRB    R0, DetCBCount
        ADD     R0,R0,#1
        CMP     R0, #&100
        MOVGE   R0, #&ff
        STRB    R0, DetCBCount
        ADR     R0, DoDetachedCallback
        MOV     R1, R2
        SWI     XOS_AddCallBack
        Pull    "R0-R2,PC"

; In: R0 = device number
;     R2 = device number mask
DoDetachedCallback
        Push    "R0-R5,LR"
        Push    "R12"
        LDR     R0,[R12, #ACBD_DevID]
        LDR     R2,[R12, #ACBD_DevIDMask]
        LDR     SB,[R12, #ACBD_SB]
        LDRB    LR, Dieing
        TEQ     LR, #0
        BNE     %ft90                      ; no point in attaching if dieing
        MOV     R1,#&FF                 ; loop over all device numbers
10      AND     LR,R1,R2
        TEQ     LR,R0                   ; if the device number fits the mask
        BNE     %FT80
        MOV     R3,#MaxDriveNo-1        ; then loop over all drives
20
        DrvRecPtr R5,R3
        mapDrvToDevLo LR,R3,R5
        TEQ     LR,R1                   ; if this drive maps to the device
        BNE     %FT70                   ; unmap it

        BL      DetachDevice

70      SUBS    R3,R3,#1
        BPL     %BT20

80      SUBS    R1,R1,#1
        BPL     %BT10
90
        LDRB    R0, DetCBCount
        SUBS    R0,R0,#1
        STRGEB  R0, DetCBCount
        MOV     R0,#ModHandReason_Free
        Pull    "R2"
        SWI     XOS_Module
        Pull    "R0-R5,PC"

; In:
; R1 = SCSI device ID
; R3 = FileCore drive number
; R5 -> drive record
DetachDevice
        Entry   "R0,R1,R4,R5,R8"
        MOV     LR,#-1                  ; clear the device field
        STDevNo LR,R5, R4
        LDRB    LR, [R5,#DrvFlags]
        ORR     LR, LR, #LostUnitAtn
        STRB    LR, [R5,#DrvFlags]
        sbaddr  R5, BlockSizes
        MOV     LR, #0                  ; blank the block size
        STRB    LR, [R5, R3]
        MOV     R0, #2                  ; release it (just in case)
        MOV     R8, R12
        SWI     XSCSI_Reserve
        MOV     R0, #UpCall_DriveRemoved
        MOV     R1, R3
        BL      UpcallDrive             ; issue an upcall
        EXIT


; In: R0 = upcall number
;     R1 = drive number
UpcallDrive
        Push    "R0-R2,LR"
        ADR     R2, SCSIPath_Template   ; issue an upcall (drive removed)
        LDMIA   R2, {R2, LR}
        Push    "R2, LR"
        ADD     R2, R1, #"0"
        STRB    R2, [SP, #6]
        MOV     R1, SP
        SWI     XOS_UpCall
        ADDS    SP, SP, #8              ; clear V
        Pull    "R0-R2,PC"

SCSIPath_Template
        DCB     "SCSI::n",0             ; 2 words

        LNK     ScsiFs15.s
@


4.16
log
@Make 'Hide' file feature more useful when SCSIFS in ROM
Detail:
  s/ScsiFs05, s/ScsiFs50 - Listen out for Service_BootChoicesVarsSet and use it as a trigger to check for any devices which should be hidden by the Hide file. This ensures that devices which are detected prior to the boot sequence starting will get Hide-processed
Admin:
  Tested on Raspberry Pi
  Partially resolves ticket #309 (there's still the problem that a multi-card reader could use up all available drive numbers during ROM init, preventing the boot drive from mounting)


Version 1.32. Tagged as 'SCSIFS-1_32'
@
text
@d654 10
d682 9
a690 1
        Push    "R0-R2,LR"
d693 1
a693 1
        Pull    "R0-R2,PC",NE
d698 1
a698 1
        Pull    "R0-R2,PC",VS
d712 1
a712 1
        Pull    "R0-R2,PC"
a725 1
        MOV     R0,#ModHandReason_Free
@


4.15
log
@Minor improvements
Detail:
  hdr/mymacros, s/ScsiFs05 - Remove some unused 26bit-only macros. Use REV instruction in RevBytes macro when possible. Replace most manual PSR manipulation with common macros.
  s/Hdr_fst, s/ScsiFs15 - Use Portable_Idle within 1s wait loop, to avoid thrashing the CPU
Admin:
  Tested on Raspberry Pi


Version 1.31. Tagged as 'SCSIFS-1_31'
@
text
@d767 22
a796 1
        Push    "R0,R1,R8"
d803 1
a803 4
        Pull    "R0,R1,R8"

70      SUBS    R3,R3,#1
        BPL     %BT20
a804 10
80      SUBS    R1,R1,#1
        BPL     %BT10
90
        LDRB    R0, DetCBCount
        SUBS    R0,R0,#1
        STRGEB  R0, DetCBCount
        MOV     R0,#ModHandReason_Free
        Pull    "R2"
        SWI     XOS_Module
        Pull    "R0-R5,PC"
@


4.14
log
@Strip some old code and options
Detail:
  Since we only really care about the RISC OS 5 version of this module, there are various old switches stretching back 20+ years which can be removed to make the sources a bit easier on the eye:
  * OpticalMemorySupport (-> {TRUE})
  * IgnoreRecoveredError (-> {TRUE})
  * FloppySupport (-> {TRUE})
  * MediaLocking (-> {TRUE})
  * BigDisc (-> {TRUE})
  * AutoDetect (-> {TRUE})
  * HotPlug (-> {TRUE})
  Files changed:
  HelpText, hdr/mymacros, s/Fixes, s/Hdr_fst, s/ScsiFs00, s/ScsiFs05, s/ScsiFs15, s/ScsiFs20, s/ScsiFs50
Admin:
  Resulting binary unchanged (for default options, at least)


Version 1.29. Not tagged
@
text
@d44 1
d46 1
a46 4
        ASSERT  SVC_mode=3
        ORR     R0, LR, #SVC_mode
        TEQP    PC, R0                  ; go to SVC mode preserving flags
        nop
d48 1
a48 3
        MRS     R0, CPSR
        ORR     R0, R0, #SVC26_mode :OR: I32_bit
        MSR     CPSR_c, R0
d110 1
a110 1
        nop                             ; delay for mode change
d112 1
a112 1
        ORR     LR, LR, #Z_bit
@


4.13
log
@Tidy things up a bit
Detail:
  s/ScsiFs00, ScsiFs05, ScsiFs15, ScsiFs20, ScsiFs50 - Add comments for some of the different IDs which are used. Add MaxDriveNo constant, and make use of it where appropriate. Make BlockSizes non-braindead.
Admin:
  Cosmetic changes only, binary unchanged.


Version 1.29. Not tagged
@
text
@a203 3
;  R4 = number of drives
;  R5 = default drive
      [ FloppySupport
d206 1
a206 1
      ]
a213 1
      [ FloppySupport
a214 1
      ]
a219 6
      [ FloppySupport
      |
        CMPS    R5, R4
        MOVHS   R5, #0
        ADD     R5, R5, #4
      ]
a220 1
      [ HotPlug
a222 1
      ]
a224 28
    [ :LNOT: BigDisc
; ===============
; ReadMapSizeCMOS
; ===============

; exit R0,V if error, R6 map size bytes

ReadMapSizeCMOS ROUT
        Push    "R1-R3,LR"
        MOV     R0, #OsByte_ReadCMOS
        MOV     R3, #3*8
        MOV     R6, #0
10
        MOV     R1, #MapSizeCMOS
        ADD     R1, R1, R3, LSR #3
        SWI     XOS_Byte                ; (R0-R2->R0-R2,V)
        BVS     %FT95
        ORR     R6, R6, R2, LSL R3
        SUBS    R3, R3, #8
        BPL     %BT10
      [ Debug2
        wrhex   R6
        mess    ,"MAP SIZES",NL
      ]
95
        Pull    "R1-R3,PC"
    ]

a319 1
      [ FloppySupport
a320 3
      |
;  good => R0 drive number-4, V=0
      ]
a333 1
      [ FloppySupport
a335 4
      |
        SUBS    R0, R0, #"4"
        RSBCSS  LR, R0, #3
      ]
a364 1
    [ AutoDetect
a415 1
      [ HotPlug
a430 1
      ]
a458 1
      [ OpticalMemorySupport
a459 1
      ]
a460 1
      [ FloppySupport
a463 1
      ]
a468 1
      [ HotPlug
a471 9
      |
        CMP     R6, R4
        BHS     ScanNext
        ADD     LR, R6, #4
        DrvRecPtr R0, LR
        STDevNo R1,R0, LR
        ADD     R6, R6, #1
      ]
      [ FloppySupport
a477 1
      [ HotPlug
a480 8
      |
        CMP     R5, R3
        BHS     ScanNext
        DrvRecPtr R0, R5
        STDevNo R1,R0, LR
        ADD     R5, R5, #1
      ]
      ]
a526 5
    ] ; AutoDetect

    [ HotPlug

      [ {TRUE}
a629 3
      ]


a817 1
    ] ; HotPlug
@


4.12
log
@  Small changes to enable interaction with PartMan module
Detail:
  Changes are compile time enabled with the compile time option
  PartitionManager set TRUE
Admin:


Version 1.29. Tagged as 'SCSIFS-1_29'
@
text
@d416 4
d427 1
a427 1
        TEQNE   R2, #8
d477 1
a477 1
        TEQ     R1, #8
d848 1
a848 1
        MOV     R3,#7                   ; then loop over all drives
d860 1
a860 1
        sbaddr  R5, BlockSizes-4
@


4.11
log
@Internationalised
In addition
 - simplify WrDec to just use OS_ConvertCardinal1 hence not need a division routine
 - change the Hide check to at least use Choices: correctly, if you must
 - macros Text and baddr eliminated

Tested in an OMAP3 ROM build.

Version 1.28. Tagged as 'SCSIFS-1_28'
@
text
@d464 7
d476 3
d554 10
@


4.10
log
@Sources lined up to be more readable
One pass through AsmTidy, then a manual inspection.
Builds binary identical version. No tagged.
@
text
@a195 31
; ======
; Divide
; ======

; entry: R0=Numerator, R1=Denominator
; exit:  R0=Result, R1=Remainder

Divide  ROUT
        Push    "R2,LR"

        MOV     LR, R1                  ; temp = den
        CMPS    LR, R0, LSR #1          ; shift temp left unless it would be > num
10
        MOVLS   LR, LR, LSL #1
        CMPLS   LR, R0, LSR #1
        BLS     %BT10
        MOV     R2, #0                  ; init result
20
        CMPS    R0, LR                  ; if subtraction possible
        SUBCS   R0, R0, LR              ; do it
        ADC     R2, R2, R2              ; shift bit into result
        MOV     LR, LR, LSR #1          ; move temp right
        CMPS    LR, R1                  ; loop if not done
        BHS     %BT20

        MOV     R1, R0                  ; mod
        MOV     R0, R2                  ; div

        Pull    "R2,PC"


d388 2
a389 2
        baddr   R0, BadDriveErrBlk
        BL      SetV
d404 8
a411 14
        Push    "R0,R1,LR"
        MOV     R1, #10
        BL      Divide                  ; (R0,R1->R0,R1)
        TEQS    R0, #0
        BEQ     %FT10
        BL      WrDec                   ; (R0->R0,V)
        B       %FT20
10
        MOV     R0, #" "
        SWI     XOS_WriteC              ; (R0->R0,V)
20
        ADDVC   R0,R1,#"0"
        SWIVC   XOS_WriteC              ; (R0->R0,V)
95
d413 1
a413 1
        Pull    "R0,R1,PC"
d588 1
a588 1
; in file Boot:Choices.SCSIFS.Hide
d611 2
a612 11
        ADR     R0, BootPath
        MOV     R1, R3
        MOV     r2, #-1
        MOV     R3, #0
        MOV     R4, #0
        SWI     XOS_ReadVarVal          ; does it exist?
        TEQ     R2, #0
        Pull    "R3", EQ                ; no
        BEQ     CDAAllowed
; the Boot: path exists.. look for our choices.Hide file
        MOV     R0, #&4f                ; 4f open R/O no path
d614 4
a617 4
        SWI     XOS_Find
        ; choices didnt open
        Pull    "R3", VS                ; no
        BVS     CDAAllowed
d667 1
a667 1
        Pull    "R3"
d672 1
a672 1
        Pull    "R3"
a683 2
BootPath
        DCB     "Boot$Path",0
d685 1
a685 1
        DCB     "Boot:Choices.SCSIFS.Hide",0
@


4.9
log
@Minor cleanups
* Upcall and OsByte symbols used from central headers
* T and F swapped for ObjAsm built in variables
* Deleted some unused CPU and hardware definitions
* Put unused files in the attic
Tested briefly, still worked.

Version 1.27. Tagged as 'SCSIFS-1_27'
@
text
@d17 1
a17 1
 [ Dev
d34 1
a34 1
        Pull    "r0-r2,lr"        
d38 21
a58 21
 SavePSR R4
 [ :LNOT: IrqDebug
 CheckIRQsema
 BNE    PHEXIT1         ;return if IRQ thread
 ]
 MOV    R3, LR
 [ No32bitCode
 ASSERT SVC_mode=3
 ORR    R0, LR, #SVC_mode
 TEQP   PC, R0          ;go to SVC mode preserving flags
 nop
 |
 MRS R0, CPSR
 ORR R0, R0, #SVC26_mode :OR: I32_bit
 MSR CPSR_c, R0
 ]
 Push   "LR"
 [ SpoolOff
 BL     SpoolOff
 ]
 MOV    R1, #32-4
d60 16
a75 16
 MOV    R0, R2, LSR R1
 AND    R0, R0, #&F
 CMPS   R0, #10
 ADDCC  R0, R0, #"0"
 ADDCS  R0, R0, #"A"-10
 SWI    OS_WriteC
 SUBS   R1, R1, #4
 BPL    PHLOOP
 MOV    R0, #" "
 SWI    OS_WriteC
 [ SpoolOff
 BL     SpoolOn
 ]
 Pull   "LR"
 RestPSR R4,,cf
 MOV    PC, R3
d77 2
a78 2
 RestPSR R4,,f
 MOV    PC, LR
d81 1
a81 1
 [ SpoolOff
d83 8
a90 8
 Push   "R0-R3,LR"
 SavePSR R3
 MOV    R0, #OsByte_SpecifyOutputStream
 MOV    R1, #&10
 MOV    R2, #&EF
 SWI    OS_Byte
 RestPSR R3,,f
 Pull   "R0-R3,PC"
d93 9
a101 9
 Push   "R0-R3,LR"
 SavePSR R3
 MOV    R0, #OsByte_SpecifyOutputStream
 MOV    R1, #0
 MOV    R2, #&EF
 SWI    OS_Byte
 RestPSR R3,,f
 Pull   "R0-R3,PC"
 ]
d104 21
a124 21
 SavePSR R0             ;save PSR
 MOV    R1, LR          ;save link
 [ :LNOT: IrqDebug
 CheckIRQsema
 MOVNE  PC, R1          ;skip if IRQ thread, return NE
 ]
 BIC    LR, R0, #3
 [ No32bitCode
 ORR    LR, LR, #SVC_mode :OR: Z_bit
 TEQP   PC, LR          ;go to supervisor mode, preserve FI, set EQ
 nop                    ;delay for mode change
 |
 ORR    LR, LR, #Z_bit
 ORR    LR, LR, #SVC26_mode :OR: I32_bit
 MSR    CPSR_cf, LR
 ]
 Push    "LR"
 [ SpoolOff
 BL      SpoolOff
 ]
 MOV    PC, R1
d126 1
a126 1
 [ {FALSE}
d128 3
a130 3
 SavePSR R4
 MOV    R3, LR
 MOV    R1, #32-4
d132 12
a143 12
 MOV    R0, R2, LSR R1
 AND    R0, R0, #&F
 CMPS   R0, #10
 ADDCC  R0, R0, #"0"
 ADDCS  R0, R0, #"A"-10
 BL     TubeChar        ;(R0)
 SUBS   R1, R1, #4
 BPL    %BT05
 MOV    R0, #" "
 BL     TubeChar        ;(R0)
 RestPSR R4,,f
 MOV    PC, R3
d145 1
a145 1
           ^ 0, R1
d151 2
a152 2
 Push   "R1,LR"
 LDR    R1, =TubeAddress
d154 7
a160 7
 LDRB   LR, R1_status
 TSTS   LR, #&40
 BEQ    %BT10
 STRB   R0, R1_data
 Pull   "R1,PC"
 ]
 ]
d167 7
a173 7
  [ No32bitCode
 ORRS   PC, LR, #V_bit
  |
 Push   "LR"
 SETPSR V_bit, LR
 Pull   "PC"
  ]
d181 13
a193 13
  [ No32bitCode
 CMPS   R0, #0
 BICEQS PC, LR, #V_bit
 ORRNES PC, LR, #V_bit
  |
 Push   "LR"
 MRS    LR, CPSR
 CMPS   R0, #0
 BICEQ  LR, LR, #V_bit
 ORRNE  LR, LR, #V_bit
 MSR    CPSR_f, LR
 Pull   "PC"
  ]
d204 1
a204 1
 Push   "R2,LR"
d206 2
a207 2
 MOV    LR, R1          ;temp = den
 CMPS   LR, R0, LSR #1  ;shift temp left unless it would be > num
d209 4
a212 4
 MOVLS  LR, LR, LSL #1
 CMPLS  LR, R0, LSR #1
 BLS    %BT10
 MOV    R2, #0          ;init result
d214 6
a219 6
 CMPS   R0, LR          ;if subtraction possible
 SUBCS  R0, R0, LR      ; do it
 ADC    R2, R2, R2      ;shift bit into result
 MOV    LR, LR, LSR #1  ;move temp right
 CMPS   LR, R1          ;loop if not done
 BHS    %BT20
d221 2
a222 2
 MOV    R1, R0          ;mod
 MOV    R0, R2          ;div
d224 1
a224 1
 Pull   "R2,PC"
d237 1
a237 1
 [ FloppySupport
d240 1
a240 1
 ]
d242 20
a261 20
 Push   "R1,LR"
 MOV    R0, #OsByte_ReadCMOS
 MOV    R1, #CMOSflags
 SWI    XOS_Byte                ;(R0-R2->R0-R2,V)
 MOVVS  R2, #2_01000001         ;default NoDir, one drive
 BVS    %FT95
 [ FloppySupport
 MOV    R3, R2, LSR #6
 ]
 AND    R4, R2, #2_00000111
 CMPS   R4, #4
 MOVHI  R4, #1
 AND    R5, R2, #2_00111000
 MOV    R5, R5, LSR #3
 [ FloppySupport
 |
 CMPS   R5, R4
 MOVHS  R5, #0
 ADD    R5, R5, #4
 ]
d263 5
a267 5
 [ HotPlug
 MOV    R3, #4
 MOV    R4, #4
 ]
 Pull   "R1,PC"
d269 1
a269 1
 [ :LNOT: BigDisc
d277 4
a280 4
 Push   "R1-R3,LR"
 MOV    R0, #OsByte_ReadCMOS
 MOV    R3, #3*8
 MOV    R6, #0
d282 11
a292 11
 MOV    R1, #MapSizeCMOS
 ADD    R1, R1, R3, LSR #3
 SWI    XOS_Byte        ;(R0-R2->R0-R2,V)
 BVS    %FT95
 ORR    R6, R6, R2, LSL R3
 SUBS   R3, R3, #8
 BPL    %BT10
 [ Debug2
 wrhex  R6
 mess   ,"MAP SIZES",NL
 ]
d294 2
a295 2
 Pull   "R1-R3,PC"
 ]
d306 9
a314 9
 Push   "R1,R2,R4,LR"
 MOV    R0, #OsByte_ReadCMOS
 MOV    R1, #FileCMOS
 SWI    XOS_Byte        ;(R0-R2->R0-R2,V)
 MOVVC  R5, R2
 TEQS   R5, #1
 BNE    %FT10
 BL     DefaultCacheSize   ;->R4
 MOV    R5, R4, LSR #10
d316 2
a317 2
 MOVVS  R5, #0
 Pull   "R1,R2,R4,PC"
d328 8
a335 8
 Push   "R1,R2,LR"
 MOV    R0, #OsByte_ReadCMOS
 MOV    R1, #DirCMOS
 SWI    XOS_Byte        ;(R0-R2->R0-R2,V)
 MOVVS  R2, #0
 MOVS   R4, R2, LSL #10
 BLEQ   DefaultCacheSize   ;->R4
 Pull   "R1,R2,PC"
d345 13
a357 13
 Push   "R0-R3,R5-R7,LR"
 MOV    R0, #0
 MOV    R1, #0
 MOV    R2, #0
 MOV    R3, #0
 Push   "R0-R3"
 Pull   "R4-R7"         ;R0-R7 now zero
 SWI    XOS_SetEnv      ;returns RAM size in R2
 MOV    R4, R2, LSR #8
 CMPS   R4, #255*1024
 MOVHI  R4, #255*1024
 CLRV
 Pull   "R0-R3,R5-R7,PC"
d371 1
a371 1
 Push   "LR"
d373 6
a378 6
 LDRB   R0, [R1], #1
 TEQS   R0, #" "
 BEQ    %BT10
 CMPS   R0, #DeleteChar
 RSBNES LR, R0, #" "-1
 Pull   "PC"
d388 1
a388 1
 Push   "LR"
d392 1
a392 1
 [ FloppySupport
d394 1
a394 1
 |
d396 1
a396 1
 ]
d399 19
a417 19
 BL     SkipSpaces      ;(R1->R0,R1,C)
 BCS    %FT10           ;reject nul string
 LDRB   LR, [R1]
 CMPS   LR, #DeleteChar
 RSBNES LR, LR, #" "    ;check terminated
 BCC    %FT10           ;not terminated

 CMPS   R0, #"a"
 SUBHS  R0, R0, #"a"-"A"
 CMPS   R0, #"A"
 SUBHS  R0, R0, #"A"-"0"
 [ FloppySupport
 SUBS   R0, R0, #"0"
 RSBCSS LR, R0, #7
 |
 SUBS   R0, R0, #"4"
 RSBCSS LR, R0, #3
 ]
 Pull   "PC",CS
d419 3
a421 3
 baddr  R0, BadDriveErrBlk
 BL     SetV
 Pull   "PC"
d435 7
a441 7
 Push   "R0,R1,LR"
 MOV    R1, #10
 BL     Divide          ;(R0,R1->R0,R1)
 TEQS   R0, #0
 BEQ    %FT10
 BL     WrDec           ;(R0->R0,V)
 B      %FT20
d443 2
a444 2
 MOV    R0, #" "
 SWI    XOS_WriteC      ;(R0->R0,V)
d446 2
a447 2
 ADDVC  R0,R1,#"0"
 SWIVC  XOS_WriteC      ;(R0->R0,V)
d449 2
a450 2
 STRVS  R0,[SP]
 Pull   "R0,R1,PC"
d452 1
a452 1
 [ AutoDetect
d454 2
a455 2
 Push   "R2,R3,LR"
 MOV    R2, #0
d457 7
a463 7
 mapDrvToDevLo R3, R2
 TEQ    R3, R1
 ADDNE  R2, R2, #1
 TEQNE  R2, #8
 BNE    %BT01
 MOV    R1, R2
 Pull   "R2,R3,PC"
d478 2
a479 2
        SUB     StkPtr, StkPtr, #36
 [ Debug7
d485 1
a485 1
 ]
d494 2
a495 2
        LDR     LR, [StkPtr, #36+0*4]           ; check we fall within the mask
        LDR     R8, [StkPtr, #36+2*4]
d500 3
a502 3
 [ HotPlug
        MOV     R8, R1                          ; check we've not already
        BL      MapDevToDrv                     ; spotted this drive
d506 1
a506 1
 ]
d511 1
a511 1
 [ Debug7
d514 1
a514 1
 ]
d519 1
a519 1
        ADD     R3, StkPtr, #6*4
d529 2
a530 2
        LDRB    LR, [StkPtr, #0]
 [ Debug7
d533 1
a533 1
 ]
d540 1
a540 1
        LDRB    LR, [StkPtr, #1]
d545 1
a545 1
 [ Debug7
d548 2
a549 2
 ]
 [ HotPlug
d553 1
a553 1
 |
d560 1
a560 1
 ]
d564 1
a564 1
 [ Debug7
d567 2
a568 2
 ]
 [ HotPlug
d572 1
a572 1
 |
d578 1
a578 1
 ]
d593 2
a594 2
        ADD     StkPtr, StkPtr, #36
 [ Debug7
d598 1
a598 1
 ]
d609 1
a609 1
        DCB     &12     ; INQUIRY
d616 1
a616 1
 ]
d618 1
a618 1
 [ HotPlug
d620 1
a620 1
 [ {TRUE}
d631 1
a631 1
 [ Debug7
d634 1
a634 1
 ]
d638 2
a639 2
        SUB     StkPtr, StkPtr, #36 + 44
        MOV     R3, StkPtr
d655 1
a655 1
        Pull    "R3", EQ             ; no
d660 2
a661 2
        SWI     XOS_Find        
                                        ; choices didnt open
d667 1
a667 1
        LDR     R2, [StkPtr]            ; buffer space after enquiry data
d672 1
a672 1
        LDR     R5, [StkPtr]            ; buffer space after enquiry data
d677 1
a677 1
        LDR     R2, [StkPtr]            ; buffer space after enquiry data
d682 1
a682 1
        LDR     R5, [StkPtr]            ; buffer space after enquiry data
d693 1
a693 1
        LDR     R4, [StkPtr]            ; buffer space after enquiry data
d696 1
a696 1
 [ Debug7
d700 1
a700 1
 ]
d710 1
a710 1
                                        ; match found
d721 2
a722 2
        ADD     StkPtr, StkPtr, #36 + 44
        TEQ     PC, #0        
d726 2
a727 2
        ADD     StkPtr, StkPtr, #36 + 44
        TEQ     R0, R0        
d731 1
a731 1
        =       "Boot$Path",0
d733 1
a733 1
        =       "Boot:Choices.SCSIFS.Hide",0        
d735 1
a735 1
 ]
d774 1
a774 1
                ^       0
d788 1
a788 1
        
d793 2
a794 2
        LDR     R0, [StkPtr, #0]
        LDR     LR, [StkPtr, #8]
d817 2
a818 2
        MOV     R3,#4                      
        MOV     R4,#4                      
d842 2
a843 2
        LDR     R0, [StkPtr, #0]
        LDR     LR, [StkPtr, #8]
d918 2
a919 2
        STRB    R2, [StkPtr, #6]
        MOV     R1, StkPtr
d921 1
a921 1
        ADDS    StkPtr, StkPtr, #8      ; clear V
d925 2
a926 2
        =       "SCSI::n",0             ; 2 words
 ]
d928 1
a928 1
 LNK    s.ScsiFs15
@


4.8
log
@  Support for FileCore API relaxations
Detail:
  * Previously, SCSIFS always set the "No directory state" startup option
    bit in FileCore_Create, even though from the PRM's description of the
    *Configure Dir/NoDir options, it should have been setting it according
    to the shared bit in CMOS byte &0B. However, since RISC OS 3.00, FileCore
    has not done anything with this information, so I'm retiring the bit.
  * No longer passes hard disc map sizes in R6 to FileCore_Create. This means
    it no longer reads them from CMOS, and nor does it update the CMOS when
    discs are mounted. This is safe because FileCore hasn't actually used
    these values since RISC OS 4.00. For consistency with ADFS (which stopped
    using its equivalent CMOS at RISC OS 5.00) the code is switched out via
    the BigDisc switch. This means we can free up a whole 4 bytes of CMOS!
Admin:
  Tested briefly via a softload on an OMAP3 machine.

Version 1.25. Tagged as 'SCSIFS-1_25'
@
text
@d85 1
a85 1
 MOV    R0, #3
d95 1
a95 1
 MOV    R0, #3
d126 1
a126 1
 [ F
d243 1
a243 1
 MOV    R0, #OsbyteReadCMOS
d278 1
a278 1
 MOV    R0, #OsbyteReadCMOS
d307 1
a307 1
 MOV    R0, #OsbyteReadCMOS
d329 1
a329 1
 MOV    R0, #OsbyteReadCMOS
d755 1
a755 1
        MOV     R0, #Upcall_DriveAdded
d891 1
a891 1
        MOV     R0, #Upcall_DriveRemoved
@


4.7
log
@Don't issue INQUIRY with only 5 bytes of response data
Detail:
  s/ScsiFs05 - Change ScanDrives2 to request 36 bytes of INQUIRY response data instead of just 5.
  This fixes an issue where some dodgy devices weren't responding to the inquiry command at all. Also CheckDriveAllowed will cause the module to ignore any drive that isn't capable of returning 36 bytes of inquiry data, so this change shouldn't cause previously working drives to suddenly stop working.
Admin:
  Tested in softload form on Iyonix.
  TS-H552 DVD-RW no longer causes hang/softlock when connected.


Version 1.23. Tagged as 'SCSIFS-1_23'
@
text
@d269 1
d295 1
@


4.6
log
@Update to work with zero page relocation
Detail:
  s/DevVersion, s/ScsiFs05 - Update debugging code to use OS_ReadSysInfo 6 to get IRQsema ptr
Admin:
  Tested on rev A2 BB-xM


Version 1.21. Tagged as 'SCSIFS-1_21'
@
text
@d476 1
a476 1
        SUB     StkPtr, StkPtr, #16
d492 2
a493 2
        LDR     LR, [StkPtr, #16+0*4]           ; check we fall within the mask
        LDR     R8, [StkPtr, #16+2*4]
d518 1
a518 1
        MOV     R4, #5
d591 1
a591 1
        ADD     StkPtr, StkPtr, #16
d611 1
a611 1
        DCB     5
a619 9
CDB_Inquiryfull
        DCB     &12     ; INQUIRY
        DCB     0
        DCB     0
        DCB     0
        DCB     36
        DCB     0
        ALIGN

d635 1
a635 1
        ADR     R2, CDB_Inquiryfull
@


4.5
log
@Fix XferMaxLen64K code to perform multiple SCSI_Ops instead of relying on the caller to retry the operation until all the data has been transferred
Detail:
  s/ScsiFs15 - Instead of relying on undocumented FileCore behaviour to ensure that long transfers are performed properly, SCSIFS now splits the transfer into chunks and loops internally until all the data has been transferred. This ensures the SCSIFS_DiscOp SWI works as expected.
  s/ScsiFs05 - Swap and ADR for ADRL, seems to be needed when enabling debug code.
Admin:
  Tested as a module softload on an Iyonix.
  Fixes issue with DiscKnight complaining that perfectly good discs contain thousands of errors.


Version 1.19. Tagged as 'SCSIFS-1_19'
@
text
@d18 19
d40 1
a40 3
 MOV    R3, #IRQsema
 LDR    R3, [R3]
 TEQS   R3, #0
d107 1
a107 3
 MOV    LR, #IRQsema
 LDR    LR, [LR]
 TEQS   LR, #0
@


4.4
log
@ 	Updated SCSIFS with a mechanism to ignore HotPlug SCSI drives
   	that are not required.
Detail:
	Typically USB card readers contain several readers as different LUNs.
	Usually a user is not interested in all readers and some can safely
	be ignored. There is now a mechanism in SCSIFS to remember this.
	(otherwise readers can occupy all the available icons, making it
	impossible for a user to add other devices e.g. 'pens'.)
	A new file, Boot:Choices.SCSIFS.Hide, is used to store data on
	sub-devices for which no SCSIFS 'drive' is desired. This data
	is the 8 byte Vendor + 16 byte Product + 4 byte Revision fields
	(concatenated and LF terminated) returned by the SCSI Inquiry command.
	If a device/LUN's inquiry completely mateches a file entry, no
	SCSIFS drive will be created. A simple App will be created to manage
	this file in due course.
Admin:  TESTED AT Castle.. due for beta release.


Version 1.16. Tagged as 'SCSIFS-1_16'
@
text
@d651 1
a651 1
        ADR     R1, ChoicesHide
@


4.3
log
@          fixed a memory leak /unstable callback removal in scsifs.
          Added in detect needed for dosfs partitions.. didnt seem to make it
          into cvs in 1.11.
          Added SWI_SCSIFSPartitions and Service_SCSIMounting to permit external
          partition manger to provide partition handling

Detail:

Admin:    tested at castle.. castle added IP


Version 1.12. Tagged as 'SCSIFS-1_12'
@
text
@d602 131
d738 2
@


4.2
log
@* Activated "floppy" (removable) support.
* Added big disc support.
* Added new error reporting scheme.
* Added autoconfiguration, and new SCSIdriver hotplugging.
* Added eject functionality (currently disabled due to issues with some USB
  devices).
* 32-bit compatible.

Version 1.11. Tagged as 'SCSIFS-1_11'
@
text
@d642 1
a642 1
DoAttached
d644 4
d657 5
d667 1
a667 1
DoAttachedCallback
d673 5
a677 2
        MOV     R3,#4
        MOV     R4,#4
d680 1
d682 4
d694 3
d706 5
d724 3
d760 4
@


4.1
log
@Initial revision
@
text
@d19 1
d24 1
a24 1
 MOVNES PC, LR          ;return if IRQ thread
d27 1
d32 5
d57 5
a61 1
 MOVS   PC, R3
d66 2
a67 1
 Push   "R0-R2,LR"
d72 2
a73 1
 Pull   "R0-R2,PC",,^
d76 2
a77 1
 Push   "R0-R2,LR"
d82 2
a83 1
 Pull   "R0-R2,PC",,^
d87 1
a87 1
 MOV    R0, PC          ;save PSR
d96 1
d100 5
d111 1
d113 1
d127 2
a128 1
 MOVS   PC, R3
d143 2
a144 1
 Pull   "R1,PC",,^
d152 1
d154 5
d166 1
d170 9
d209 1
a209 1
 Pull   "R2,PC",,^
d248 4
d278 1
a278 1
 Pull   "R1-R3,PC",,^
d295 4
a298 2
 BLEQ   DefaultCacheSize   ;->R4
 MOVEQ  R5, R4, LSR #10
d339 2
a340 1
 Pull   "R0-R3,R5-R7,PC",,^
d435 319
d755 1
a755 1
 LNK    s.ScsiFs15 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

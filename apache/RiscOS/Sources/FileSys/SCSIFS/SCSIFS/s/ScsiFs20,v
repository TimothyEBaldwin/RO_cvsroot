head	4.13;
access;
symbols
	SCSIFS-1_35:4.13
	SCSIFS-1_34:4.13
	SCSIFS-1_33:4.13
	SCSIFS-1_32:4.13
	SCSIFS-1_31:4.13
	SCSIFS-1_30:4.13
	SCSIFS-1_29:4.10
	SCSIFS-1_28:4.9
	SCSIFS-1_27:4.7
	SCSIFS-1_26:4.7
	SCSIFS-1_25:4.7
	SCSIFS-1_24:4.6
	SCSIFS-1_23:4.6
	SCSIFS-1_22:4.6
	SCSIFS-1_21:4.5
	SCSIFS-1_20:4.5
	SCSIFS-1_19:4.5
	SCSIFS-1_18:4.5
	SCSIFS-1_17:4.5
	SCSIFS-1_16:4.5
	SCSIFS-1_15:4.5
	SCSIFS-1_14:4.3
	SCSIFS-1_13:4.3
	SCSIFS-1_12:4.3
	RO_5_07:4.2
	SCSIFS-1_11:4.2
	dellis_autobuild_BaseSW:4.1
	SCSIFS-0_25:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SCSIFS-0_25:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	RCA:4.1.0.2
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2017.09.09.20.32.59;	author jlee;	state Exp;
branches;
next	4.12;
commitid	GQZ9pR34fQ5EWy6A;

4.12
date	2017.09.09.20.30.02;	author jlee;	state Exp;
branches;
next	4.11;
commitid	bB8BD6OBVuZBVy6A;

4.11
date	2017.09.09.20.23.53;	author jlee;	state Exp;
branches;
next	4.10;
commitid	urDJ2k0Cof4xTy6A;

4.10
date	2016.11.28.21.31.27;	author jballance;	state Exp;
branches;
next	4.9;
commitid	TW8MDzs0EPmFqWvz;

4.9
date	2013.10.06.13.49.20;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	8D9mMcKPmGAXNe8x;

4.8
date	2013.10.06.13.28.24;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	y16pwkkQv9juGe8x;

4.7
date	2012.04.13.23.40.25;	author bavison;	state Exp;
branches;
next	4.6;
commitid	03WlS5gEaKPUsL0w;

4.6
date	2011.10.14.07.28.20;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	EhWGDLE3kx67WhDv;

4.5
date	2005.04.28.15.29.40;	author jballance;	state Exp;
branches;
next	4.4;

4.4
date	2005.03.05.02.00.15;	author jballance;	state Exp;
branches;
next	4.3;

4.3
date	2005.01.31.13.37.39;	author jballance;	state Exp;
branches;
next	4.2;

4.2
date	2003.05.23.13.05.38;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.34.14;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.34.14;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.04.59;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.42.12;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.38.30;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Fix memory corruption when encountering a floppy-type device with SCSI ID >= 4
Detail:
  s/ScsiFs20 - Fix UnlockMedia to perform the correct translation between SCSI ID and FileCore drive number
Admin:
  Tested on Raspberry Pi
  Fixes issue reported on forums when many drives connected:
  https://www.riscosopen.org/forum/forums/4/topics/3831


Version 1.30. Tagged as 'SCSIFS-1_30'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;>ScsiFs20

        MACRO
        Misc    $str
        ASSERT  MiscOp_$str=(.-MiscTable) :SHR: 2
        B       Do$str
        MEND


; =========
; MiscEntry
; =========

MiscEntry ROUT
      [ Debug4
        wrhex   R0
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        mess    ,"*>Misc",NL
      ]
        Push    "LR"
        getSB
        CMPS    R0, #MiscOp_DriveStatus
        BHI     %FT95

        MOV     LR, PC
        ADD     PC, PC, R0, LSL #2
        B       %FT90
MiscTable
        Misc    Mount
        Misc    PollChanged
        Misc    LockDrive
        Misc    UnlockDrive
        Misc    PollPeriod
        Misc    Eject
        B       %FT95
        Misc    DriveStatus
90
      [ Debug4
        wrhex   R0
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        mess    ,"*<Misc"
        mess    ,NL
      ]
        Pull    "PC"

95
        MOV     R0, #BadParmsErr
        BL      SetV
        B       %BT90

; =======
; DoMount
; =======

;entry
; R1 drive
; R2 disc address
; R3 -> buffer
; R4 length
; ( R5 -> disc rec to fill in for floppies )

;exit R0,V internal error

DoMount ROUT
        Push    "R1-R4,R6-R8,LR"
        BL      Misc_CheckDrivePresent
        Pull    "R1-R4,R6-R8,PC",VS
        MOV     R8, #0
        LDR     LR, FCFeatures
        TST     LR, #FC_Big
        BEQ     %FT05
; fudgery - Mount gets passed a byte address; we need to convert to the
; sector/block address that LowLevelOp expects.
        sbaddr  R7, BlockSizes          ; if not examined drive yet

        LDRB    R8, [R7,R2, LSR #(32-3)]
        CMPS    R8, #0                  ; V=0
        BLEQ    Examine                 ; (R2,R7->R0,R8,V) then do it now
        Pull    "R1-R4,R6-R8,PC",VS
05
      [ AllowPartitions
        Push    "R0, R1,R2,R3"
        MOV     R2, R2, LSR #(32-3)     ; disc number requested
        DrvRecPtr R1, R2
        LDRB    R3, [R1, #:INDEX:DevNo]
        LDR     R1, =Service_SCSIMounting
        SWI     OS_ServiceCall          ; announce our intentions
        Pull    "R0,R1,R2,R3"
      ]
        TSTS    R2, #bit31
        BEQ     %FT20                   ; Floppy
;read in the boot block as requested, will probably trigger Examine
10
        AND     LR, R2, #DiscBits
        BIC     R2, R2, #DiscBits
        ORR     R2, LR, R2, LSR R8
        MOV     R6, #NIL                ; no defect list - empty for SCSI discs anyway
        MOV     R1, #DiscOp_ReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        CMP     R4, #0
        BLNE    LowLevelOp              ; (R1-R6->R0-R4,V)
      [ Debug4
        mess    ,"Mount, finished"
        mess    ,NL
      ]
95
        Pull    "R1-R4,R6-R8,PC"


20
;Read from DefectListDiscAdd &C00, size SzDefectList &200
;
;
      [ Debug4
        mess    ,"Mount-floppy, reading bootblock"
        mess    ,NL
      ]
        AND     R2, R2, #DiscBits
        MOV     R4, #DefectListDiscAdd
        ORR     R2, R2, R4, LSR R8
        MOV     R3, #ScratchSpace
        MOV     R4, #SzDefectList
        MOV     R1, #DiscOp_ReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag
        MOV     R6, #NIL                ; no defect list - empty for SCSI discs anyway
        BL      LowLevelOp              ; (R1-R6->R0-R4,V)
        BVS     %BT95
        LDRB    R4, [R7,R2, LSR #(32-3)]
;check defect list
        MOV     R0, #ScratchSpace
        MOV     R1, #SzDefectList
        BL      CheckSum                ; (R0,R1->R0-R2,V)
        ;MOVVS  R0,#BadDefectListErr
        ;B      %FT30
        BVS     %FT30

;read disc structure from defect list
        MOV     R2, #ScratchSpace
        ADD     R2, R2, #SzDefectList-MaxStruc

        LDRB    LR, [r2, #3]            ; check possible other type of disc image
        CMP     LR, #8
        BHI     %ft30
        LDRB    LR, [r2, #2]
        TEQ     LR, #0
        BEQ     %ft30
        LDRB    LR, [r2, #1]
        TEQ     LR, #8
        BEQ     %ft30
        LDRB    LR, [r2, #0]
        TEQ     LR, R8
        BNE     %ft30

        LDR     R0, [SP]                ; recover drive number
        LDMIA   R2,{R1-R4,LR}
        ASSERT  RootDir=3*4
        ORR     R4, R4, R0, LSL #(32-3)
        STMIA   R5, {R1-R4,LR}
        B       %FT40
30
        ; Not a FileCore boot block - create a semi-fake disc record to get
        ; us off the ground for non-FileCore discs
        STRB    R8, [R5, #SectorSize]
        MOV     R0, #1
        STRB    R0, [R5, #Heads]
        STRB    R0, [R5, #SecsPerTrk]
        STRB    R0, [R5, #LowSector]
        MOV     R0, #0
        STRB    R0, [R5, #Density]
        ;STR    R0, [R5, #DiscSize2]
        MOV     R0, #640*1024
        STR     R0, [R5, #DiscSize]

40

      [ Debug4
        mess    ,"Mount-floppy, reading map"
        mess    ,NL
      ]

        LDMFD   SP, {R1-R4}
        B       %BT10

Misc_CheckDrivePresent
        Push    "LR"
        mapDrvToDevLo LR,R1
        CMP     LR,#-1
        Pull    "PC",NE
        MOV     R0, #BadDriveErr
        BL      SetV
        Pull    "PC"

; ========
; CheckSum
; ========

; Check consistency of block under checksum, last byte of block is check byte

; entry: R0=start, R1=block length
; exit:  R0,R1 preserved, R2=checksum, V=0 <=> good

CheckSum ROUT
        Push    "R1,R3,LR"
        ADDS    LR, R0, R1              ; ->end+1      C=0
        SUB     R1, LR, #1              ; ->check byte
        MOV     R2, #0
        B       %FT20
10
        LDRB    R3, [R1,#-1] !          ; get next byte
        ADC     R2, R2, R3              ; add into checksum
        MOVS    R2, R2, LSL #24         ; bit 8 = carry
        MOV     R2, R2, LSR #24
20
        TEQS    R0, R1
        BNE     %BT10                   ; loop until done
        LDRB    R3, [LR,#-1]

        CMPS    R2, R3                  ; check sum = old check byte ?
        BLNE    SetV
        Pull    "R1,R3,PC"

; =======
; Examine
; =======

;do any initialisation required for drive including reading block size

;entry
; R2 FileCore drive number in top 3 bits
; R7 -> BlockSizes

;exit
; R0, V set if error
; R8 log to base 2 of block size, also stored in correct entry in BlockSizes

Examine
        Push    "R0,R9,LR"
;
; Issue SCSI_Initialise (R0=DetermineDevice) which returns device type
; and block size.
;
; The device type must be 0 (Direct-access) and the block size 256,512 or 1024.
; FileCore can handle block sizes of 256,512 or 1024 bytes.
;
      [ Debug3
        mess    , "Examine - doing DetermineDevice", NL
      ]

        Push    "R1,R2"
        SUB     SP,SP,#16
        MOV     R0,#2                           ; DetermineDevice
        MOV     R1,R2,LSR #(32-3)
        mapDrvToDevLo R1,R1                    ; map drive onto devices
      [ Ejecting
        BL      LoadMedia
      ]
        MOV     R2,SP
      [ RetryIfBusy
        MOV     R9,#60                  ; Retry on timeout for 60 seconds
78
        Push    "R0-R2"                 ; Stack incase we retry
        SWI     XSCSI_Initialise
        ADDVC   SP,SP,#12               ; Command OK, ditch stacked R0-R2
        BVC     %FT79
        BL      CheckRetry
        Pull    "R0-R2",VC              ; Retry with stacked R0-R2
        BVC     %BT78
        ADDVS   SP,SP,#28               ; Balance stack, before
        Pull    "R1,R2",VS
        BVS     %FT95                   ; reporting error
79
      |
        SWI     XSCSI_Initialise
        ADDVS   SP,SP,#16               ; Balance stack, before
        Pull    "R1,R2",VS
        BVS     %FT95                   ; reporting error
      ]
        LDRB    R0,[SP,#0]              ; Device type
        CMP     R0,#DevDirectAccess     ;
        CMPNE   R0,#DevOpticalMemory
        BNE     %FT96                   ; Error - 'Not a winnie'

        LDR     R0,[SP,#12]             ; Block (sector) size
        CMP     R0,#256
        CMPNE   R0,#512
        CMPNE   R0,#1024
        BNE     %FT97                   ; Error - Not 256/512/1024 byte sectors

        ADD     SP,SP,#16               ; Finished with stacked data

        LDR     R2,[SP,#4]              ; Get drive number back
        Push    "R0,R3"
        MOV     R2,R2,LSR #(32-3)
        BL      ReserveDevice
        STRVS   R0, [SP]
        Pull    "R0,R3"
        Pull    "R1,R2"

        BVS     %FT95


;assuming R0 has block size = 2^n , the following code will convert it to the
;log to base two ie n as needed elsewhere

        MOV     R8, #0
80
        MOVS    R0, R0, LSR #1
        ADDNE   R8, R8, #1
        BNE     %BT80
        STRB    R8, [R7, R2, LSR #(32-3)]       ; save result in BlockSize table

95                                      ;error exit
        LDRVS   LR, FCFeatures
        TSTVS   LR, #FC_NewErrors
        ORREQ   R0, R0, #ExternalErrorBit
        STRVS   R0, [SP]
        Pull    "R0,R9,PC"


96                              ;Return error - NotWinnie
        ADD     SP,SP,#16
        Pull    "R1,R2"
        ADRL    R0, ErrorBlock_SCSIFSBadSCSIType
        BL      CopyError
        B       %BT95

97                              ;Return error - BadBlockSize
        ADD     SP,SP,#16
        Pull    "R1,R2"
        ADRL    R0, ErrorBlock_SCSIFSSectorSizeNotSupported
        BL      CopyError
        B       %BT95


; ===========
; DoLockDrive
; ===========

;entry
; R1 drive 0..3
;
; Only called for a floppy drive

DoLockDrive
        Push    "R1,R2,LR"
        SavePSR R2
        mapDrvToDevLo R1, R1
        BL      LockMedia
        RestPSR R2,,f
        Pull    "R1,R2,PC"


; =============
; DoUnlockDrive
; =============

;entry
; R1 drive 0..3
;
; Only called for a floppy drive

DoUnlockDrive
        Push    "R1,R2,LR"
        SavePSR R2
        mapDrvToDevLo R1, R1
        BL      UnLockMedia
        RestPSR R2,,f
        Pull    "R1,R2,PC"


DiscString
        DCB     "disc",0
        ALIGN


; ============
; DoPollPeriod
; ============

;entry
; R1 drive (floppy only??)

;exit
; R5 minimum polling period (in centi-seconds), or -1 if disc changed doesn't work
; R6 -> media type string eg 'disc'

DoPollPeriod
        Push    "LR"
        MOV     R5, #PollPeriod
        ADR     R6, DiscString
        Pull    "PC"

; =======
; DoEject
; =======

;entry
; R1 drive 0..7, or bit 31 set indicating our choice (searching for media)
; R4 = iteration count (if bit 31)
; R5 = timeout period (if bit 31)
;

DoEject
      [ Ejecting
        Push    "R1,R2,LR"
        SavePSR R2
        TST     R1, #bit31
        BEQ     %FT10
; media search case
        TEQ     R4, #0                  ; only eject on iteration 0
        BNE     %FT95
        MOV     R1, #0                  ; if not specified, eject SCSI::0
10
        mapDrvToDevLo R1, R1
        BL      EjectMedia
95
        RestPSR R2,,f
        Pull    "R1,R2,PC"
      |
        MOV     PC, LR
      ]

; =============
; DoDriveStatus
; =============

;entry
; R1 drive 0..7
DoDriveStatus
        CMP     R1, #MaxDriveNo
        MOVHS   R2, #2
        MOVHS   PC, LR
        mapDrvToDevLo R2, R1
        CMP     R2, #-1
        MOVEQ   R2, #2
        MOVNE   R2, #0
        MOV     PC, LR

;
; On entry
;   R1 = Scsi deviceID
;
DoDismount
        Push    "R0-R5,LR"

        ASSERT  (Dismount_end - Dismount_start) = 16
        ADR     R2, Dismount_start
        LDMIA   R2, {R2,R3,R4,R5}       ; Copy string onto stack (known to be 16 bytes)
        STMDB   SP!,{R2,R3,R4,R5}       ; 
        mapDevToDrvLo R1, R1            ; map device onto drives
        ADD     R0, R1, #"0"
        STRB    R0, [SP,#14]            ; position pf 'x' in dismount string below
        MOV     R0, SP
        SWI     XOS_CLI

      [ AllowPartitions
        MOV     R2, #0
        ADD     LR, SB, R1, LSL #2      ; disc number to word address
        STR     R2, [LR, #:INDEX:PartitionBaseAdd-:INDEX:SCSIFSWorkBase] ; reset
      ]

        ADD     SP, SP, #(Dismount_end - Dismount_start)

        sbaddr  R2, BlockSizes          ; Zero the BlockSize table entry, to force
        MOVVC   R0, #0                  ; an Examine and re-initialise of the
        STRVCB  R0, [R2,R1]             ; ScsiDriver on next ScsiFs access
        mapDrvToDevLo R1, R1            ; map drive onto device
        MOVVC   R0, #2                  ; RC for ReleaseDevice
        MOVVC   R8, R12                 ; Access Key
        SWIVC   XSCSI_Reserve

        STRVS   R0, [SP]
        Pull    "R0-R5,PC"


Dismount_start
        DCB     "SCSI:DISMOUNT x", 0
Dismount_end



;
; On entry
;   R1 = Scsi deviceID
;   R2 = Drive number
;
ReserveDevice ROUT
        Push    "R2,LR"
        MOV     R0, #0                  ; RC for ClaimDevice
        ADR     R2, DoDismount          ; Adr } Used by ScsiDriver to request us to
        MOV     R3, R12                 ; R12 } Dismount & ReleaseDevice
        MOV     R8, R12                 ; Good value for the access key
        SWI     XSCSI_Reserve
        BVS     %FT95

        LDR     R3, [SP]
        MOV     R0, #4                  ; RC for ControlErrors
        TST     R3, #4
        MOVEQ   R2, #1                  ; Floppy - Auto Request-Sense, Return Unit-Attention
        MOVNE   R2, #2                  ; Winnie - Auto Request-Sense, Ignore Unit-Attention
        SWI     XSCSI_Control
        TST     R3, #4
        BLNE    LockMedia               ; Lock winnies in place
95
        Pull    "R2,PC"


;
; On entry
;   R1 = Scsi deviceID
;
LockMedia
      [ Debug3
        mess    , "Locking media", NL
      ]
        Push    "R0-R6,R8,LR"
        SavePSR R6
        ADR     R2, CDB_LockMedia
LocMed_10
        AND     R0, R1, #&FF            ; DeviceID
        MOV     R1, #6                  ; CDB length
        MOV     R3, #0
        MOV     R4, #0
        MOV     R5, #0
        MOV     R8, R12                 ; AccessKey
        DoSCSIOp
        BIC     R6, R6, #V_bit
        RestPSR R6,,f
        Pull    "R0-R6,R8,PC"


;
; On entry
;   R1 = Scsi deviceID
;
UnLockMedia
      [ Debug3
        mess    , "Unlocking media", NL
      ]
        Push    "R0-R6,R8,LR"
        SavePSR R6
        ADR     R2, CDB_UnLockMedia
UnLocMed_10
        mapDevToDrvLo R1, R1
        sbaddr  R5, BlockSizes
        MOV     R4, #0
        STRB    R4, [R5,R1]

        B       LocMed_10

      [ Ejecting
;
; On entry
;   R1 = Scsi deviceID
;
EjectMedia
      [ Debug3
        mess    , "Ejecting media", NL
      ]
        Push    "R0-R6,R8,LR"
        SavePSR R6
        ADR     R2, CDB_EjectMedia
        B       UnLocMed_10

;
; On entry
;   R1 = Scsi deviceID
;
LoadMedia
      [ Debug3
        mess    , "Loading media", NL
      ]
        Push    "R0-R6,R8,LR"
        SavePSR R6
        ADR     R2, CDB_LoadMedia
        B       UnLocMed_10
      ]

CDB_LockMedia
        DCB     &1E                     ; PREVENT/ALLOW MEDIA REMOVAL
        DCB     0                       ; LUN & reserved
        DCB     0
        DCB     0
        DCB     1                       ; Reserved=0 (b7..b1), Prevent removal=1 (b0)
        DCB     0                       ; Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
        ALIGN                           ; Flag=0 (b1),Link=0 (b0)

CDB_UnLockMedia
        DCB     &1E                     ; PREVENT/ALLOW MEDIA REMOVAL
        DCB     0                       ; LUN & reserved
        DCB     0
        DCB     0
        DCB     0                       ; Reserved=0 (b7..b1), Prevent removal=0 (b0)
        DCB     0                       ; Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
        ALIGN                           ; Flag=0 (b1),Link=0 (b0)

      [ Ejecting
CDB_LoadMedia
        DCB     &1B                     ; START/STOP UNIT
        DCB     0                       ; LUN & immediate
        DCB     0
        DCB     0
        DCB     3                       ; Power=0 (b7..b4), Reserved=0 (b3..b2), Load/Eject=1 (b1),
        DCB     0                       ; Start=1 (b0)
        ALIGN

CDB_EjectMedia
        DCB     &1B                     ; START/STOP UNIT
        DCB     1                       ; LUN & immediate
        DCB     0
        DCB     0
        DCB     2                       ; Power=0 (b7..b4), Reserved=0 (b3..b2), Load/Eject=1 (b1),
        DCB     0                       ; Start=0 (b0)
        ALIGN
      ]

        LNK     TokHelpSrc.s
@


4.12
log
@Strip some old code and options
Detail:
  Since we only really care about the RISC OS 5 version of this module, there are various old switches stretching back 20+ years which can be removed to make the sources a bit easier on the eye:
  * OpticalMemorySupport (-> {TRUE})
  * IgnoreRecoveredError (-> {TRUE})
  * FloppySupport (-> {TRUE})
  * MediaLocking (-> {TRUE})
  * BigDisc (-> {TRUE})
  * AutoDetect (-> {TRUE})
  * HotPlug (-> {TRUE})
  Files changed:
  HelpText, hdr/mymacros, s/Fixes, s/Hdr_fst, s/ScsiFs00, s/ScsiFs05, s/ScsiFs15, s/ScsiFs20, s/ScsiFs50
Admin:
  Resulting binary unchanged (for default options, at least)


Version 1.29. Not tagged
@
text
@d564 2
a565 2
        AND     R1, R1, #&FF            ; Incase any high order bits are set
        sbaddr  R5, BlockSizes+4        ; BUG - assumes non-AutoDetect drive mapping in use
@


4.11
log
@Tidy things up a bit
Detail:
  s/ScsiFs00, ScsiFs05, ScsiFs15, ScsiFs20, ScsiFs50 - Add comments for some of the different IDs which are used. Add MaxDriveNo constant, and make use of it where appropriate. Make BlockSizes non-braindead.
Admin:
  Cosmetic changes only, binary unchanged.


Version 1.29. Not tagged
@
text
@a47 1
      [ FloppySupport
a52 7
      |
        B       %FT95
        B       %FT95
        B       %FT95
        B       %FT95
        B       %FT95
      ]
a87 1
      [ HotPlug
a89 2
      ]
      [ BigDisc
a102 1
      ]
a111 1
      [ FloppySupport
a113 1
      ]
a115 1
      [ BigDisc
a118 1
      ]
a130 1
    [ FloppySupport
a139 1
      [ BigDisc
a141 3
      |
        ORR     R2, R2, #DefectListDiscAdd
      ]
a203 1
      [ HotPlug
a211 1
      ]
a240 1
    ]
a299 1
      [ OpticalMemorySupport
a300 1
      ]
a353 1
    [ FloppySupport
a442 2
    ]

a452 1
      [ HotPlug
a456 3
      |
        MOV     R2, #0
      ]
a513 1
    [ FloppySupport
a521 1
      [ MediaLocking
a523 9
      ]
    |
        MOVVC   R0, #4                  ; RC for ControlErrors
        MOVVC   R2, #2                  ; Auto Request-Sense, Ignore Unit-Attention
        SWIVC   XSCSI_Control
      [ MediaLocking
        BLVC    LockMedia
      ]
    ]
a527 1
    [ MediaLocking
a635 1
    ]
@


4.10
log
@  Small changes to enable interaction with PartMan module
Detail:
  Changes are compile time enabled with the compile time option
  PartitionManager set TRUE
Admin:


Version 1.29. Tagged as 'SCSIFS-1_29'
@
text
@d107 1
a107 1
        sbaddr  R7, BlockSizes-4        ; if not examined drive yet
d273 2
a274 2
; R2 drive (4 to 7) in top 3 bits
; R7 -> BlockSizes-4 (see ScsiFs15)
d479 1
a479 1
        CMP     R1, #8
d517 1
a517 1
        sbaddr  R2, BlockSizes-4        ; Zero the BlockSize table entry, to force
d610 1
a610 1
        sbaddr  R5, BlockSizes
@


4.9
log
@Internationalised
In addition
 - simplify WrDec to just use OS_ConvertCardinal1 hence not need a division routine
 - change the Hide check to at least use Choices: correctly, if you must
 - macros Text and baddr eliminated

Tested in an OMAP3 ROM build.

Version 1.28. Tagged as 'SCSIFS-1_28'
@
text
@d116 1
a116 1
        Push    "R0, R1,R2"
d118 2
d122 1
a122 1
        Pull    "R0,R1,R2"
d502 1
a502 1
        STMDB   SP!,{R2,R3,R4,R5}       ; 
@


4.8
log
@Sources lined up to be more readable
One pass through AsmTidy, then a manual inspection.
Builds binary identical version. No tagged.
@
text
@d367 2
a368 2
        ADR     R0,err_NotWinnie
        BL      SetV
d374 2
a375 2
        ADR     R0,err_BadBlockSize
        BL      SetV
a377 11
err_NotWinnie
        DCD     42                         ; >>>>Proper number
        DCB     "Bad SCSI device type",0
        ALIGN

err_BadBlockSize
        DCD     43                         ; >>>>Proper number
        DCB     "Bad block size, must be 256/512/1024",0
        ALIGN


d435 1
a435 1
        baddr   R6, DiscString
@


4.7
log
@  Minor change in line with cleanup to FileCore
Detail:
  Removed confusingly-named DefectStruc symbol (actually the offset into
  the boot block where the disc record is held) - was only used in one place
Admin:
  No code change - retagged as SCSIFS-1_25

Version 1.25. Not tagged
@
text
@d17 5
a21 5
 MACRO
 Misc   $str
 ASSERT MiscOp_$str=(.-MiscTable) :SHR: 2
 B      Do$str
 MEND
d29 17
a45 17
 [ Debug4
 wrhex  R0
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 mess   ,"*>Misc",NL
 ]
 Push   "LR"
 getSB
 CMPS   R0, #MiscOp_DriveStatus
 BHI    %FT95

 MOV    LR, PC
 ADD    PC, PC, R0, LSL #2
 B      %FT90
d47 16
a62 16
 Misc   Mount
 [ FloppySupport
 Misc   PollChanged
 Misc   LockDrive
 Misc   UnlockDrive
 Misc   PollPeriod
 Misc   Eject
 |
 B      %FT95
 B      %FT95
 B      %FT95
 B      %FT95
 B      %FT95
 ]
 B      %FT95
 Misc   DriveStatus
d64 11
a74 11
 [ Debug4
 wrhex  R0
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 mess   ,"*<Misc"
 mess   ,NL
 ]
 Pull   "PC"
d77 3
a79 3
 MOV    R0, #BadParmsErr
 BL     SetV
 B      %BT90
d95 10
a104 10
 Push   "R1-R4,R6-R8,LR"
 [ HotPlug
 BL     Misc_CheckDrivePresent
 Pull   "R1-R4,R6-R8,PC",VS
 ]
 [ BigDisc
 MOV    R8, #0
 LDR    LR, FCFeatures
 TST    LR, #FC_Big
 BEQ    %FT05
d107 1
a107 1
 sbaddr R7, BlockSizes-4        ;if not examined drive yet
d109 4
a112 4
 LDRB   R8, [R7,R2, LSR #(32-3)]
 CMPS   R8, #0                  ;V=0
 BLEQ   Examine                 ;(R2,R7->R0,R8,V) then do it now
 Pull   "R1-R4,R6-R8,PC",VS
d114 12
a125 12
 ]
 [ AllowPartitions
 Push   "R0, R1,R2"
 MOV    R2, R2, LSR #(32-3)     ; disc number requested
 LDR    R1, =Service_SCSIMounting
 SWI    OS_ServiceCall          ; announce our intentions
 Pull   "R0,R1,R2"
 ]
 [ FloppySupport
 TSTS   R2, #bit31
 BEQ    %FT20                   ;Floppy
 ]
d128 13
a140 13
 [ BigDisc
 AND    LR, R2, #DiscBits
 BIC    R2, R2, #DiscBits
 ORR    R2, LR, R2, LSR R8
 ]
 MOV    R6, #NIL                ;no defect list - empty for SCSI discs anyway
 MOV    R1, #DiscOp_ReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag
 CMP    R4, #0
 BLNE   LowLevelOp              ;(R1-R6->R0-R4,V)
 [ Debug4
 mess   ,"Mount, finished"
 mess   ,NL
 ]
d142 1
a142 1
 Pull   "R1-R4,R6-R8,PC"
d145 1
a145 1
 [ FloppySupport
d150 18
a167 18
 [ Debug4
 mess   ,"Mount-floppy, reading bootblock"
 mess   ,NL
 ]
 AND    R2, R2, #DiscBits
 [ BigDisc
 MOV    R4, #DefectListDiscAdd
 ORR    R2, R2, R4, LSR R8
 |
 ORR    R2, R2, #DefectListDiscAdd
 ]
 MOV    R3, #ScratchSpace
 MOV    R4, #SzDefectList
 MOV    R1, #DiscOp_ReadSecs :OR: DiscOp_Op_IgnoreEscape_Flag
 MOV    R6, #NIL                ;no defect list - empty for SCSI discs anyway
 BL     LowLevelOp              ;(R1-R6->R0-R4,V)
 BVS    %BT95
 LDRB   R4, [R7,R2, LSR #(32-3)]
d169 6
a174 6
 MOV    R0, #ScratchSpace
 MOV    R1, #SzDefectList
 BL     CheckSum                ;(R0,R1->R0-R2,V)
 ;MOVVS  R0,#BadDefectListErr
 ;B      %FT30
 BVS    %FT30
d177 22
a198 22
 MOV    R2, #ScratchSpace
 ADD    R2, R2, #SzDefectList-MaxStruc
 
 LDRB   LR, [r2, #3]            ; check possible other type of disc image
 CMP    LR, #8
 BHI    %ft30
 LDRB   LR, [r2, #2]
 TEQ    LR, #0
 BEQ    %ft30
 LDRB   LR, [r2, #1]
 TEQ    LR, #8
 BEQ    %ft30
 LDRB   LR, [r2, #0]
 TEQ    LR, R8
 BNE    %ft30

 LDR    R0, [SP]                ;recover drive number
 LDMIA  R2,{R1-R4,LR}
 ASSERT RootDir=3*4
 ORR    R4, R4, R0, LSL #(32-3)
 STMIA  R5, {R1-R4,LR}
 B      %FT40
d200 12
a211 12
 ; Not a FileCore boot block - create a semi-fake disc record to get
 ; us off the ground for non-FileCore discs
 STRB   R8, [R5, #SectorSize]
 MOV    R0, #1
 STRB   R0, [R5, #Heads]
 STRB   R0, [R5, #SecsPerTrk]
 STRB   R0, [R5, #LowSector]
 MOV    R0, #0
 STRB   R0, [R5, #Density]
 ;STR    R0, [R5, #DiscSize2]
 MOV    R0, #640*1024
 STR    R0, [R5, #DiscSize]
d215 4
a218 4
 [ Debug4
 mess   ,"Mount-floppy, reading map"
 mess   ,NL
 ]
d220 2
a221 2
 LDMFD  SP, {R1-R4}
 B      %BT10
d223 1
a223 1
 [ HotPlug
d225 8
a232 8
 Push   "LR"
 mapDrvToDevLo LR,R1
 CMP    LR,#-1
 Pull   "PC",NE
 MOV    R0, #BadDriveErr
 BL     SetV
 Pull   "PC"
 ]
d245 2
a246 2
        ADDS    LR, R0, R1      ;->end+1      C=0
        SUB     R1, LR, #1      ;->check byte
d248 1
a248 1
        B        %FT20
d250 3
a252 3
        LDRB    R3, [R1,#-1] !  ;get next byte
        ADC     R2, R2, R3      ;add into checksum
        MOVS    R2, R2, LSL #24 ;bit 8 = carry
d256 1
a256 1
        BNE     %BT10           ;loop until done
d259 1
a259 1
        CMPS    R2, R3          ;check sum = old check byte ?
d262 1
a262 1
 ]
d279 1
a279 1
 Push   "R0,R9,LR"
d287 15
a301 15
 [ Debug3
 mess   , "Examine - doing DetermineDevice", NL
 ]

 Push   "R1,R2"
 SUB    StkPtr,StkPtr,#16
 MOV    R0,#2                           ;DetermineDevice
 MOV    R1,R2,LSR #(32-3)
 mapDrvToDevLo R1,R1                    ;map drive onto devices
 [ Ejecting
 BL     LoadMedia
 ]
 MOV    R2,StkPtr
 [ RetryIfBusy
 MOV    R9,#60                          ;Retry on timeout for 60 seconds
d303 10
a312 10
 Push   "R0-R2"                         ;Stack incase we retry
 SWI    XSCSI_Initialise
 ADDVC  StkPtr,StkPtr,#12               ;Command OK, ditch stacked R0-R2
 BVC    %FT79
 BL     CheckRetry
 Pull   "R0-R2",VC                      ;Retry with stacked R0-R2
 BVC    %BT78
 ADDVS  StkPtr,StkPtr,#28               ;Balance stack, before
 Pull   "R1,R2",VS
 BVS    %FT95                           ; reporting error
d314 28
a341 28
 |
 SWI    XSCSI_Initialise
 ADDVS  StkPtr,StkPtr,#16               ;Balance stack, before
 Pull   "R1,R2",VS
 BVS    %FT95                           ; reporting error
 ]
 LDRB   R0,[StkPtr,#0]                  ;Device type
 CMP    R0,#DevDirectAccess             ;
 [ OpticalMemorySupport
 CMPNE  R0,#DevOpticalMemory
 ]
 BNE    %FT96                           ;Error - 'Not a winnie'

 LDR    R0,[StkPtr,#12]                 ;Block (sector) size
 CMP    R0,#256
 CMPNE  R0,#512
 CMPNE  R0,#1024
 BNE    %FT97                           ;Error - Not 256/512/1024 byte sectors

 ADD    StkPtr,StkPtr,#16               ;Finished with stacked data

 LDR    R2,[StkPtr,#4]                  ;Get drive number back
 Push   "R0,R3"
 MOV    R2,R2,LSR #(32-3)
 BL     ReserveDevice
 STRVS  R0, [SP]
 Pull   "R0,R3"
 Pull   "R1,R2"
d343 1
a343 1
 BVS    %FT95
d349 1
a349 1
 MOV    R8, #0
d351 4
a354 4
 MOVS   R0, R0, LSR #1
 ADDNE  R8, R8, #1
 BNE    %BT80
 STRB   R8, [R7, R2, LSR #(32-3)]       ;save result in BlockSize table
d357 5
a361 5
 LDRVS  LR, FCFeatures
 TSTVS  LR, #FC_NewErrors
 ORREQ  R0, R0, #ExternalErrorBit
 STRVS  R0, [SP]
 Pull   "R0,R9,PC"
d365 5
a369 5
 ADD    StkPtr,StkPtr,#16
 Pull   "R1,R2"
 ADR    R0,err_NotWinnie
 BL     SetV
 B      %BT95
d372 5
a376 5
 ADD    StkPtr,StkPtr,#16
 Pull   "R1,R2"
 ADR    R0,err_BadBlockSize
 BL     SetV
 B      %BT95
d379 3
a381 3
 DCD 42                         ;>>>>Proper number
 DCB "Bad SCSI device type",0
 ALIGN
d384 3
a386 3
 DCD 43                         ;>>>>Proper number
 DCB "Bad block size, must be 256/512/1024",0
 ALIGN
d389 1
a389 1
 [ FloppySupport
d401 6
a406 6
 Push   "R1,R2,LR"
 SavePSR R2
 mapDrvToDevLo R1, R1
 BL     LockMedia
 RestPSR R2,,f
 Pull   "R1,R2,PC"
d419 6
a424 6
 Push   "R1,R2,LR"
 SavePSR R2
 mapDrvToDevLo R1, R1
 BL     UnLockMedia
 RestPSR R2,,f
 Pull   "R1,R2,PC"
d428 2
a429 2
 = "disc",0
 ALIGN
d444 4
a447 4
 Push   "LR"
 MOV    R5, #PollPeriod
 baddr  R6, DiscString
 Pull   "PC"
d460 5
a464 5
 [ Ejecting
 Push   "R1,R2,LR"
 SavePSR R2
 TST    R1, #bit31
 BEQ    %FT10
d466 3
a468 3
 TEQ    R4, #0                  ; only eject on iteration 0
 BNE    %FT95
 MOV    R1, #0                  ; if not specified, eject SCSI::0
d470 2
a471 2
 mapDrvToDevLo R1, R1
 BL     EjectMedia
d473 5
a477 5
 RestPSR R2,,f
 Pull   "R1,R2,PC"
 |
 MOV    PC, LR
 ]
d479 1
a479 1
 ]
d488 12
a499 12
 CMP    R1, #8
 MOVHS  R2, #2
 MOVHS  PC, LR
 [ HotPlug
 mapDrvToDevLo R2, R1
 CMP    R2, #-1
 MOVEQ  R2, #2
 MOVNE  R2, #0
 |
 MOV    R2, #0
 ]
 MOV    PC, LR
d506 11
a516 1
 Push   "R0-R5,LR"
d518 15
a532 25
 ASSERT (Dismount_end - Dismount_start) = 16
 ADR    R2, Dismount_start
 LDMIA  R2, {R2,R3,R4,R5}       ;Copy string onto stack (known to be 16 bytes)
 STMDB  SP!,{R2,R3,R4,R5}       ;
 mapDevToDrvLo R1, R1           ;map device onto drives
 ADD    R0, R1, #"0"
 STRB   R0, [SP,#14]            ; position pf 'x' in dismount string below
 MOV    R0, SP
 SWI    XOS_CLI

 [ AllowPartitions
 MOV    R2, #0
 ADD    LR, SB, R1, LSL #2      ; disc number to word address
 STR    R2, [LR, #:INDEX:PartitionBaseAdd-:INDEX:SCSIFSWorkBase] ; reset
 ]
 
 ADD    SP, SP, #(Dismount_end - Dismount_start)

 sbaddr R2, BlockSizes-4        ;Zero the BlockSize table entry, to force
 MOVVC  R0, #0                  ; an Examine and re-initialise of the
 STRVCB R0, [R2,R1]             ; ScsiDriver on next ScsiFs access
 mapDrvToDevLo R1, R1           ;map drive onto device
 MOVVC  R0, #2                  ;RC for ReleaseDevice
 MOVVC  R8, R12                 ;Access Key
 SWIVC  XSCSI_Reserve
d534 2
a535 2
 STRVS  R0, [SP]
 Pull   "R0-R5,PC"
d539 1
a539 1
 DCB    "SCSI:DISMOUNT x", 0
d550 27
a576 27
 Push   "R2,LR"
 MOV    R0, #0                  ;RC for ClaimDevice
 ADR    R2, DoDismount          ;Adr } Used by ScsiDriver to request us to
 MOV    R3, R12                 ;R12 } Dismount & ReleaseDevice
 MOV    R8, R12                 ;Good value for the access key
 SWI    XSCSI_Reserve
 [ FloppySupport
 BVS    %FT95

 LDR    R3, [StkPtr]
 MOV    R0, #4                  ;RC for ControlErrors
 TST    R3, #4
 MOVEQ  R2, #1                  ;Floppy - Auto Request-Sense, Return Unit-Attention
 MOVNE  R2, #2                  ;Winnie - Auto Request-Sense, Ignore Unit-Attention
 SWI    XSCSI_Control
 [ MediaLocking
 TST    R3, #4
 BLNE   LockMedia               ;Lock winnies in place
 ]
 |
 MOVVC  R0, #4                  ;RC for ControlErrors
 MOVVC  R2, #2                  ;Auto Request-Sense, Ignore Unit-Attention
 SWIVC  XSCSI_Control
 [ MediaLocking
 BLVC LockMedia
 ]
 ]
d578 1
a578 1
 Pull   "R2,PC"
d581 1
a581 1
 [ MediaLocking
d587 6
a592 6
 [ Debug3
 mess   , "Locking media", NL
 ]
 Push   "R0-R6,R8,LR"
 SavePSR R6
 ADR    R2, CDB_LockMedia
d594 10
a603 10
 AND    R0, R1, #&FF    ;DeviceID
 MOV    R1, #6          ;CDB length
 MOV    R3, #0
 MOV    R4, #0
 MOV    R5, #0
 MOV    R8, R12         ;AccessKey
 DoSCSIOp
 BIC    R6, R6, #V_bit
 RestPSR R6,,f
 Pull   "R0-R6,R8,PC"
d611 6
a616 6
 [ Debug3
 mess   , "Unlocking media", NL
 ]
 Push   "R0-R6,R8,LR"
 SavePSR R6
 ADR    R2, CDB_UnLockMedia
d618 4
a621 4
 AND    R1, R1, #&FF            ;Incase any high order bits are set
 sbaddr  R5, BlockSizes
 MOV    R4, #0
 STRB   R4, [R5,R1]
d623 1
a623 1
 B      LocMed_10
d625 1
a625 1
 [ Ejecting
d631 7
a637 7
 [ Debug3
 mess   , "Ejecting media", NL
 ]
 Push   "R0-R6,R8,LR"
 SavePSR R6
 ADR    R2, CDB_EjectMedia
 B      UnLocMed_10
d644 8
a651 8
 [ Debug3
 mess   , "Loading media", NL
 ]
 Push   "R0-R6,R8,LR"
 SavePSR R6
 ADR    R2, CDB_LoadMedia
 B      UnLocMed_10
 ]
d654 7
a660 7
 DCB    &1E             ;PREVENT/ALLOW MEDIA REMOVAL
 DCB    0               ;LUN & reserved
 DCB    0
 DCB    0
 DCB    1               ;Reserved=0 (b7..b1), Prevent removal=1 (b0)
 DCB    0               ;Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
 ALIGN                  ; Flag=0 (b1),Link=0 (b0)
d663 7
a669 7
 DCB    &1E             ;PREVENT/ALLOW MEDIA REMOVAL
 DCB    0               ;LUN & reserved
 DCB    0
 DCB    0
 DCB    0               ;Reserved=0 (b7..b1), Prevent removal=0 (b0)
 DCB    0               ;Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
 ALIGN                  ; Flag=0 (b1),Link=0 (b0)
d671 1
a671 1
 [ Ejecting
d673 7
a679 7
 DCB    &1B             ;START/STOP UNIT
 DCB    0               ;LUN & immediate
 DCB    0
 DCB    0
 DCB    3               ;Power=0 (b7..b4), Reserved=0 (b3..b2), Load/Eject=1 (b1),
 DCB    0               ; Start=1 (b0)
 ALIGN
d682 9
a690 9
 DCB    &1B             ;START/STOP UNIT
 DCB    1               ;LUN & immediate
 DCB    0
 DCB    0
 DCB    2               ;Power=0 (b7..b4), Reserved=0 (b3..b2), Load/Eject=1 (b1),
 DCB    0               ; Start=0 (b0)
 ALIGN
 ]
 ]
d692 1
a692 1
 LNK    s.TokHelpSrc
@


4.6
log
@Update to use some of the exported FileCore headers.
There are still a large number of local copies that should be visited, but this change at least allows it to assemble again FileCore-3_45.

Version 1.22. Tagged as 'SCSIFS-1_22'
@
text
@d178 1
a178 1
 ADD    R2, R2, #DefectStruc
@


4.5
log
@	small number of changes to correctly work with scatterlists such
	used by filecore format discs.
Detail: these should have been committed as part of the mods of 5th March
	though it appears the something was missed as recent checkouts didn't
	contain all the mods.
Admin:  castle added IP


Version 1.15. Tagged as 'SCSIFS-1_15'
@
text
@d19 1
a19 1
 ASSERT Misc_$str=(.-MiscTable) :SHR: 2
d40 1
a40 1
 CMPS   R0, #Misc_DriveStatus
d134 1
a134 1
 MOV    R1, #ReadSecsOp :OR: NoEscape
d163 1
a163 1
 MOV    R1, #ReadSecsOp :OR: NoEscape
@


4.4
log
@	Added note on SCSIFS_Partitions swi.
	Committing correct files this time.
        previous version, 1.14 failed to include these

Detail:
Admin:  castle added IP. to be beta tested


Version 1.14. Tagged as 'SCSIFS-1_14'
@
text
@a114 18
; [ T
; mov    R0, #5                  ; return total free space
; SWI    XOS_Module
; BVS    %ft11                   ; failed to read size
; CMP    R3, #1024*1024           ; at least 128k free?
; BGT    %ft11                   ; yes
;                                ; no
; RSB    R2, R3, #1024*1024       ; extra we need
; MOV    R1, R2
; MOV    R0, #1                  ; RMA space
; SWI    XOS_ChangeDynamicArea   ; try to change it
; CMP    R1, R2
; BGE    %ft11
; Pull   "R1-R4,R6-R8,PC"
;                        
;11
; LDMFD  R13, {R1-R3}            ; copy back regs
; ]
@


4.3
log
@          fixed a memory leak /unstable callback removal in scsifs.
          Added in detect needed for dosfs partitions.. didnt seem to make it
          into cvs in 1.11.
          Added SWI_SCSIFSPartitions and Service_SCSIMounting to permit external
          partition manger to provide partition handling

Detail:

Admin:    tested at castle.. castle added IP


Version 1.12. Tagged as 'SCSIFS-1_12'
@
text
@d115 25
@


4.2
log
@* Activated "floppy" (removable) support.
* Added big disc support.
* Added new error reporting scheme.
* Added autoconfiguration, and new SCSIdriver hotplugging.
* Added eject functionality (currently disabled due to issues with some USB
  devices).
* 32-bit compatible.

Version 1.11. Tagged as 'SCSIFS-1_11'
@
text
@d172 14
d507 1
a507 1
 STRB   R0, [SP,#14]
d510 7
@


4.1
log
@Initial revision
@
text
@d40 3
a42 7
 [ FloppySupport
 CMPS   R0, #Misc_Unused
 BLO    %FT10
 MOV    R0, #BadParmsErr
 BL     SetV
 B      %FT90
10
d48 1
d53 1
d55 5
a59 6
 TEQS   R0, #Misc_Mount
 MOVNE  R0, #BadParmsErr
 BLNE   SetV
 BNE    %FT90

 BL     DoMount
d61 2
d74 6
a79 3
 Pull   "LR"
 BICVCS PC, LR, #V_bit
 ORRVSS PC, LR, #V_bit
d95 20
a114 1
 Push   "R1-R4,R6,LR"
d120 6
a125 1

d128 8
a135 2
 BL     LowLevelOp              ;(R1-R6->R0-R4,V)
 Pull   "R1-R4,R6,PC"
d148 4
d153 2
a154 1
;>>>Assume buffer in R3 is big enough
d159 2
a160 1
 BVS    %FT95
d162 6
a167 5
;LDR    R0, [SP, #8]            ;Recover buffer address
;MOV    R1, #SzDefectList
;BL     CheckSum                ;(R0,R1->R0-R2,V)
;MOVVS  R0,BadDefectListErr  ;>>>twiddle external bit?
;BVS    %FT95
d170 1
a170 1
 LDMIA  SP, {R0,R1,R2}          ;Recover drive no, disc address, buffer address
d172 1
d177 16
d199 2
a200 3
;read the free space map (old map)
;read in the boot block as requested, will probably trigger Examine
 LDMIA  SP, {R1-R4}
d202 9
a210 6
 MOV    R6, #NIL                ;no defect list - empty for SCSI discs anyway
 MOV    R1, #ReadSecsOp :OR: NoEscape
 BL     LowLevelOp              ;(R1-R6->R0-R4,V)
 [ Debug4
 mess   ,"Mount-floppy, finished"
 mess   ,NL
d212 29
a240 2
95
 Pull   "R1-R4,R6,PC"
d249 1
a249 1
;entry 
d275 3
d314 1
d316 1
d336 3
a338 1
 ORRVS  R0, R0, #ExternalErrorBit
d380 2
a381 1
 Push   "R1,LR"
d384 2
a385 1
 Pull   "R1,PC",,^
d398 2
a399 1
 Push   "R1,LR"
d402 2
a403 1
 Pull   "R1,PC",,^
d426 5
a430 1
 Pull   "PC",,^
d432 45
d478 1
d483 1
a483 1
; 
d499 1
a499 1
 MOVVC  R0, #0                  ; an Examine and re-initialise of the 
d519 2
a520 1
; 
d522 1
a522 1
 Push   LR
d531 1
d533 3
a535 3
 TST    R1, #4
 MOVNE  R2, #1                  ;Floppy - Auto Request-Sense, Return Unit-Attention
 MOVEQ  R2, #2                  ;Winnie - Auto Request-Sense, Ignore Unit-Attention
d538 2
a539 2
 TST    R1, #4
 BLEQ   LockMedia               ;Lock winnies in place
d550 1
a550 1
 Pull   PC
d557 1
a557 1
; 
d562 2
a563 1
 Push   "R0-R5,R8,LR"
d572 4
a575 3
 SWI    XSCSI_Op
 Pull   "R0-R5,R8,LR"
 BICS   PC, LR, #V_bit
d581 1
a581 1
; 
d586 4
a589 1
 Push   "R0-R5,R8,LR"
a590 1
 [ Remap
a591 3
 |
 sbaddr  R5, BlockSizes-4
 ]
a594 1
 ADR    R2, CDB_UnLockMedia
d597 27
d642 20
d664 1
a664 1
 LNK    TokenHelp
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

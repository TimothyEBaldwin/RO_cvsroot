head	4.17;
access;
symbols
	SCSIFS-1_35:4.17
	SCSIFS-1_34:4.17
	SCSIFS-1_33:4.17
	SCSIFS-1_32:4.17
	SCSIFS-1_31:4.17
	SCSIFS-1_30:4.16
	SCSIFS-1_29:4.14
	SCSIFS-1_28:4.14
	SCSIFS-1_27:4.13
	SCSIFS-1_26:4.12
	SCSIFS-1_25:4.11
	SCSIFS-1_24:4.10
	SCSIFS-1_23:4.10
	SCSIFS-1_22:4.10
	SCSIFS-1_21:4.9
	SCSIFS-1_20:4.9
	SCSIFS-1_19:4.8
	SCSIFS-1_18:4.7
	SCSIFS-1_17:4.6
	SCSIFS-1_16:4.6
	SCSIFS-1_15:4.6
	SCSIFS-1_14:4.4
	SCSIFS-1_13:4.4
	SCSIFS-1_12:4.3
	RO_5_07:4.2
	SCSIFS-1_11:4.2
	dellis_autobuild_BaseSW:4.1
	SCSIFS-0_25:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SCSIFS-0_25:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	RCA:4.1.0.2
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.17
date	2017.09.09.20.36.36;	author jlee;	state Exp;
branches;
next	4.16;
commitid	R0KtP8j50xURXy6A;

4.16
date	2017.09.09.20.30.02;	author jlee;	state Exp;
branches;
next	4.15;
commitid	bB8BD6OBVuZBVy6A;

4.15
date	2017.09.09.20.23.53;	author jlee;	state Exp;
branches;
next	4.14;
commitid	urDJ2k0Cof4xTy6A;

4.14
date	2013.10.06.13.28.24;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	y16pwkkQv9juGe8x;

4.13
date	2013.08.23.07.00.55;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	7jw3CbjLYaGwXx2x;

4.12
date	2012.06.26.20.32.55;	author jlee;	state Exp;
branches;
next	4.11;
commitid	vuxe05m9OBG73gaw;

4.11
date	2012.03.21.01.59.37;	author bavison;	state Exp;
branches;
next	4.10;
commitid	Ds1Q6pzW6vPu0HXv;

4.10
date	2011.10.14.07.28.20;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	EhWGDLE3kx67WhDv;

4.9
date	2011.01.27.21.54.56;	author jlee;	state Exp;
branches;
next	4.8;

4.8
date	2011.01.12.22.53.40;	author jlee;	state Exp;
branches;
next	4.7;

4.7
date	2010.12.15.21.10.02;	author jlee;	state Exp;
branches;
next	4.6;

4.6
date	2005.04.28.15.29.40;	author jballance;	state Exp;
branches;
next	4.5;

4.5
date	2005.03.05.02.00.15;	author jballance;	state Exp;
branches;
next	4.4;

4.4
date	2005.02.01.01.22.01;	author jballance;	state Exp;
branches;
next	4.3;

4.3
date	2005.01.31.13.37.39;	author jballance;	state Exp;
branches;
next	4.2;

4.2
date	2003.05.23.13.05.38;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.34.12;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.34.12;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.04.56;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.42.11;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.38.29;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.17
log
@Minor improvements
Detail:
  hdr/mymacros, s/ScsiFs05 - Remove some unused 26bit-only macros. Use REV instruction in RevBytes macro when possible. Replace most manual PSR manipulation with common macros.
  s/Hdr_fst, s/ScsiFs15 - Use Portable_Idle within 1s wait loop, to avoid thrashing the CPU
Admin:
  Tested on Raspberry Pi


Version 1.31. Tagged as 'SCSIFS-1_31'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;>ScsiFs15

        LTORG

; =============
; LowLevelEntry
; =============

;entry
; R1  reason
; R2  disc address top 3 bits drive
; R3  RAM ptr
; R4  length
; R5  -> disc record
; R6  -> defect list or NIL during Mount
; R12 -> private word

LowLevelEntry ROUT      ;entry point for FileCore
        getSB
LowLevelOp              ;internal entry point
        Push    "R0-R8,R9,LR"
LowLevelOp2             ;another internal entry point
      [ Debug3
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        mess    ,"*>LowLevel",NL
      ]

      [ Debug3
        mess    , "LowLevelEntry/LowLevelOp - "
      ]

        MOV     LR,R2,LSR #(32-3)
        DrvRecPtr LR,LR
        mapDrvToDevLo LR,LR,LR
        CMP     LR,#-1
        BEQ     BadDrive

        CMPS    R4, #0                  ; IF 0 length
        BICEQ   R7, R1, #NoTimeOut :OR: NoEscape :OR: ScatterBit :OR: AltDefectBit
        ASSERT  DiscOp_Verify < DiscOp_ReadTrk
        ASSERT  DiscOp_ReadSecs < DiscOp_ReadTrk
        ASSERT  DiscOp_WriteSecs < DiscOp_ReadTrk
        CMPEQS  R7, #DiscOp_ReadTrk     ; AND verify, read/write secs, not background
        Pull    "R0-R8,R9,PC",LO        ; THEN nothing to do

        sbaddr  R7, BlockSizes          ; if not examined drive yet

        LDRB    R8, [R7,R2, LSR #(32-3)]
        CMPS    R8, #0                  ; V=0
        BLEQ    Examine                 ; (R2,R7->R0,R8,V) then do it now
        BVS     LowError

        LDR     R7, FCFeatures
        ANDS    R5, R1, #OpMask
        CMPS    R5, #DiscOp_Restore+1        ; moan if bad reason code
; LDRCCB R0, Winnies
;>>> RSBCCS R0, R0, R2, LSR #29     ;     or if bad drive
;>>>what about highest floppy number?
        BCS     BadParameters

        MOV     R0, R2, LSR #29


        mapDrvToDevLo R0, R0            ; map drive onto device
        AND     LR, R1, #ScatterBit :OR: NoEscape :OR: NoTimeOut :OR: BackgroundOp
        ORR     R0, R0, LR, LSL #CTL_cnvt
        ASSERT  DiscOp_StepIn > DiscOp_Restore
        ASSERT  DiscOp_StepOut > DiscOp_Restore
        ASSERT  DiscOp_CachedReadSecs > DiscOp_Restore
        ASSERT  DiscOp_Specify > DiscOp_Restore
        CMPS    R5, #DiscOp_Restore
        BHS     %FT20
        ;convert byte disc address to block address
        BIC     LR, R2, #DiscBits
        TST     R7, #FC_Big
        MOVNE   R7, LR
        BNE     %FT20
        MOV     R7, LR, LSR R8          ; block number
        TEQS    LR, R7, LSL R8
        BNE     BadParameters

20
      [ AllowPartitions
        MOV     LR, R2, LSR #(32-3)     ; disc number
        ADD     LR, SB, LR, LSL #2      ; to word address
        LDR     LR, [LR, #:INDEX:PartitionBaseAdd-:INDEX:SCSIFSWorkBase]
        ADD     R7, R7, LR              ; offset by base sector offset
      ]
        ADD     PC, PC, R5, LSL #2      ; dispatch on reason
        NOP

        B       VerifyCase
        B       ReadSecsCase
        B       WriteSecsCase
        B       ReadTrackCase           ; may be read ids ?
        B       WriteTrackCase          ; whatever needed for formatting
        B       SeekCase
        B       RestoreCase

VerifyCase
      [ Debug3
        mess    , "Verify", NL
      ]
        MOV     R1, #&2F                ; VERIFY command
        B       OpCommon

ReadSecsCase
      [ Debug3
        mess    , "ReadSectors", NL
      ]
        ORR     R0, R0, #CTL_TXREAD
        MOV     R1, #&28                ; READ extended command
        B       OpCommon

WriteSecsCase
      [ Debug3
        mess    , "WriteSectors", NL
      ]
        ORR     R0, R0, #CTL_TXWRITE
        MOV     R1, #&2A                ; WRITE extended command
        B       OpCommon

ReadTrackCase
      [ Debug3
        mess    , "ReadTrack !!NOT SUPPORTED - NOP !!", NL
      ]
        B       DoNOP

WriteTrackCase
      [ Debug3
        mess    , "WriteTrack !!NOT SUPPORTED - NOP!!", NL
      ]
        B       DoNOP

SeekCase
        MOV     R1, R0
        BL      UnLockMedia
    [ SeekIsNOP
      [ Debug3
        mess    , "Seek !!NOT SUPPORTED - NOP !!", NL
      ]
        B       DoNOP
    |
      [ Debug3
        mess    , "Seek", NL
      ]
        MOV     R1, #&2B                ; SEEK command
        MOV     R4, #0                  ; Ensure cdb[7]..cdb[8] are zero
        B       OpCommon
    ]

RestoreCase
      [ Debug3
        mess    , "Restore !!NOT SUPPORTED - NOP !!", NL
      ]
        B       DoNOP

;
; Build a SCSI CDB and the registers needed for the SWI SCSI_Op
; on the stack
;
; On entry
;   R0  composite of deviceID & flags (remapping already applied)
;   R1  bytes 0..1 of required CDB
;   R2  disc address top 3 bits drive
;   R3  RAM ptr
;   R4  length
;   R7  disc address expressed as block number
;   R8  Log2BlockSize
;
; The UseSpecialScatterBlk switch when ON means that the Driver is not relied upon
; to source data for sector writes.  This is done by expanding a single RAMBlk
; write into a ScatterBlock write, where the first entry in the scatter list is
; the original write, and the second is a section of RAM (starting at address 0)
; large enough to make the total transfer precisely equal to the size of the
; transfer indicated in the CDB.  The total size of the transfer (R4) is also
; adjusted appropriately.
;

OpCommon
        MOV     R5, #0                  ; Default timeout
      [ UseSpecialScatterBlk
        STR     R5, ScatterFlag         ; Default: dont use scatter method
      ]
        SUB     SP,SP,#12               ; Largest CBD is 12 bytes

        MOV     R2,SP                   ; ->CDB built on stack
        Push    "R2,R3,R4,R9"

        RevBytes R7, R5,R6              ; Change sex of disc block address

;
; The given Xfer length is in bytes, the CDB needs length in blocks, if the
; byte length is not a whole number of blocks, round up the CDB block count
; and rely on SCSIdriver sinking/sourcing the excess.
; NOTE: this note only applies if the UseSpecialScatterBlk switch is OFF
;
        MOV     R5, R4, LSR R8          ; Xfer length in blocks (was in bytes)
        TEQ     R4, R5, LSL R8
        ADDNE   R5, R5, #1              ; Inc if Xfer length not a whole number
    [ UseSpecialScatterBlk
        BEQ     DontNeedScatBlk         ; If the length was a whole number fine ...

        AND     R9, R0, #CTL_TXWRITE :OR: CTL_TXREAD
        CMP     R9, #CTL_TXWRITE
        BNE     DontNeedScatBlk         ; If we arent writing fine ...
        TST     R0, #CTL_SCATTER
      [ Debug3                        ; Oh dear already using a scatter pointer ...
        BEQ     NotAppropriate1
        SWI     OS_WriteS               ; So we cant make things easy for the Driver
        DCB     "Having to save a nasty block slowly, as scatter list already used"
        SWI     OS_NewLine
NotAppropriate1
      ]
        BNE     DontNeedScatBlk

        RSB     R9, R4, R5, LSL R8      ; Get required dummy block length
        CMP     R9, #?PaddingBlock      ; Too big?
        BHS     DontNeedScatBlk         ; Let driver deal with it

      [ Debug3
        SWI     OS_WriteS
        DCB     "Tranferring to a scatter block ..."
        SWI     OS_NewLine
      ]

        Push    "R5"
        MOV     R9, #1                             ; Note that the scatterblock is required
        STR     R9, ScatterFlag
        ORR     R0, R0, #CTL_SCATTER               ; Save the transfer to a Scatter pointer
        ADR     R9, WriteScatBlk
        STR     R3, [R9, #0]
        STR     R4, [R9, #4]
        ADR     LR, PaddingBlock
        STR     LR, [R9, #8]

        ;Take   the rounded up no. of blocks
        MOV     R5, R5, LSL R8                     ; Convert this into bytes
        STR     R5, ScatterData                    ; Save this new Total Length
        SUB     R5, R5, R4                         ; And take off the original length
        STR     R5, [R9, #12]                      ; This is the length of the dummy block
        Pull    "R5"

DontNeedScatBlk
    ]

    [ CheckXferLen
;
; Block count fields in CDB's are 16 bit, ie max 65535.
;
; If the byte count given by filecore, converted to a block count exceeds this,
; put 65535 in the CDB.
;
; XferLenMax255 switch introduced for test purposes .. some devices found
;   that won't do more than 256 blocks at a time safely (JB 20050131)
;
; Now renamed & repurposed for limiting the max length to 64K, as that seems
; to be the limit which most OS's use for USB mass storage transfers (and
; potentially all other I/O transfers, but my main interest is finding a fix
; for all the shoddy USB devices) (JL 20101214)
      [ XferLenMax64K
        MOV     R3,#65536
        MOV     R3,R3,LSR R8
        CMP     R3,R5
        MOVLO   R5,R3
        CMP     R5,#65536               ; Just in case we have a device with a block size of 1
        SUBEQ   R5,R5,#1
      |
        CMP     R5,#&10000
        MOVHS   R5,#&FF00
        ORRHS   R5,R5,#&00FF
      ]
    ]

        MOV     R3,R5,LSR #8
        MOV     R3,R3,LSL #24                      ; MSB in CDB[7] {R3 bits 24..31}
        AND     R6,R5,#&FF                         ; LSB in CDB[8] {R4 bits  0..7 }

        ORR     R1,R1,R7,LSL #16                   ; Add sex changed block address
        ORR     R3,R3,R7,LSR #16                   ; to CDB

        STMIA   R2,{R1,R3,R6}                    ; Copy 12bytes of CDB onto stack

;R0,R1
;R2,R3,R4,R9 stacked
;R5 must be remade 0

        MOV     R1,#10
        Pull    "R2,R3,R4,R9"

      [ UseSpecialScatterBlk
        LDR     R6, ScatterFlag                    ; Are we using the special ScatterBlock ?
        CMP     R6, #0
        ADRNE   R3, WriteScatBlk                 ; Yes ! Better make RAMptr point to it,
        LDRNE   R4, ScatterData                  ; and use the rounded up total length
      ]

; If we're transferring less than what was requested, clamp R4 so that
; SCSI drivers won't get confused by the CDB saying one thing but R4 saying
; something else
; But remember how much we clamped by, so that we can return the correct unread
; amount to FileCore
        SUBS    R6,R4,R5,LSL R8
        SUBGT   R4,R4,R6
        MOVLT   R6,#0
        Push    "R6,R8"

        MOV     R5, #0

        TSTS    R0, #CTL_BACKGROUND
        LDRNE   R6, WinnieCallAfter     ; Callback address
        LDRNE   R7, FileCorePrivate     ; & wsptr (if needed)

        MOV     R8, R12                 ; AccessKey

    [ RetryIfBusy
        MOV     R9,#60                  ; Retry on timeout for 60 seconds
30
        Push    "R0-R4"                 ; Stack incase we need to retry
        DoSCSIOp
        BLVS    CheckRecovered          ; If error is 'Recovered error' clear
        ; V and pretend it never happened
        BVC     %FT35                   ; OK, so ditch stacked R0-R4 and continue
        BL      CheckRetry
        Pull    "R0-R4",VC              ; Retry with stacked R0-R4
        BVC     %BT30
35
        LDR     LR, FCFeatures
        ADD     SP,SP,#5*4              ; Ditch stacked R0-R4 before reporting error
    |
        DoSCSIOp
        BLVS    CheckRecovered          ; If error is 'Recovered error' clear
        ; V and pretend it never happened
        LDR     LR, FCFeatures
    ]

; Adjust R4 by our stacked R6
        Pull    "R6"
        ADD     R4,R4,R6

        TST     LR, #FC_NewErrors
        ORREQ   R0, R0, #ExternalErrorBit
        MOVVC   R0, #0
        LDR     R8, [SP], #16           ; Pull blocksize & discard stacked CBD
        LDMIB   SP, {R1-R2,R6-R7}

      [ UseSpecialScatterBlk
; If we used the temp scatter block then we need to restore the correct R3
; value and 'forget' the extra bytes that we transferred
        LDR     R9, ScatterFlag
        TEQ     R9, #0
        BEQ     %FT10
        LDR     R9, ScatterData         ; Get adjusted length
        SUB     R9, R9, R7              ; Calculate the amount of padding we used
        SUB     R4, R4, R9              ; Forget the padding
        TEQ     R4, #0                  ; Preserve V
        MOVMI   R4, #0                  ; Clamp R4 if we managed to transfer everything we were originally asked to
        SUB     R3, R7, R4              ; Get amount transferred
        ADD     R3, R6, R3              ; And calculate the correct value of R3 to return
10
      ]

        SUB     R7, R7, R4                      ; Amount Xfered
        TST     LR, #FC_Big
        ADDNE   R2, R2, R7, LSR R8              ; Inc. disc address by amount transfered
        ADDEQ   R2, R2, R7                      ; Inc. disc address by amount transfered
        STMIA   SP, {R0,R1-R2,R3-R4}

    [ XferLenMax64K
;
; For file read/write operations, FileCore will automatically call us again to
; transfer any data which we didn't transfer due to our 64K xfer limit.
;
; HOWEVER this behaviour seems to simply be a side-effect of the implementation,
; not something that we should be relying upon. Plus if you call SCSIFS_DiscOp
; (or FileCore_DiscOp) directly then the FileCore won't automatically repeat
; the operation, leading to confusion when calls complete without error but
; without all the data having been transferred.
;
; So implement our own loop to make sure that the user really does get all the
; data that he was after.
;
        BVS     %FT10
        TEQ     R4,#0
        BEQ     %FT10
        AND     LR, R1, #OpMask
        TEQ     LR, #1                  ; Read sectors
        TEQNE   LR, #2                  ; Write sectors
      [ Debug3
        mess    EQ,"Looping back round to transfer rest of data",NL
      ]
        ADDEQ   R5,R13,#5*4
        LDMEQIA R5,{R5-R6}              ; Recover disc record, defect list
        BEQ     LowLevelOp2
10
    ]

LowError
        STRVS   R0, [SP]
      [ Debug3
        wrhex   R0,VS
        mess    VC,"         "
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
        mess    ,"*<LowLevel",NL,NL
      ]
DoNOP
        Pull    "R0-R8,R9,PC"

BadParameters
        MOV     R0, #BadParmsErr
        BL      SetV
        B       LowError

BadDrive
        MOV     R0, #BadDriveErr
        BL      SetV
        B       LowError

;
; CheckRecovered
; ==============
; On entry
;   R0 -> error & VS
;
; Clear V_bit if the error is RecoveredError
;
CheckRecovered
        Push    "R0,R1"
        LDR     R0,[R0]                         ; Error number
        LDR     R1,=ErrorNumber_SCSI_RecoveredError
        TEQ     R0,R1                           ; If RecoveredError (V preserved)
        Pull    "R0,R1"
        CMPEQ   R0,#0                           ; pretend it never happened (clear V)
        MOV     PC,LR                           ; else keep the error

;
; CheckRetry
; ==========
;
; On entry
;   R0 -> error
;
; On exit
;   VC means retry
;   VS means report error
;
CheckRetry
        Push    "R0,R1,LR"
        SETV
        LDR     R0,[R0]                         ; Error number
        LDR     R1,=ErrorNumber_SCSI_Busy
        TEQ     R0,R1                           ; If NOT("Target status - busy" or
        LDRNE   R1,=ErrorNumber_SCSI_CC_NotReady
        TEQNE   R0,R1                           ;       "Target error - Not ready"
        LDRNE   R1,=ErrorNumber_SCSI_Timeout
        TEQNE   R0,R1                           ;       "Timeout"
        LDRNE   R1,=ErrorNumber_SCSI_Died
        TEQNE   R0,R1                           ;       "Unexpected disconnection"
                                                ;       )
        Pull    "R0,R1,PC",NE                   ; return indicating report error

        TEQ     R9,#0                           ; Retry counter hit zero
        Pull    "R0,R1,PC",EQ                   ; return indicating report error
;
; Counter is non-zero
;
        SUB     R9,R9,#1
        BL      WaitOneSecond
        CMP     R0,#0
        Pull    "R0,R1,PC",AL                   ; Return indicating do-a-retry


;
; WaitOneSecond (give or take a bit)
; =============
;
WaitOneSecond
        Push    "R0,R1,LR"
        SWI     XOS_ReadMonotonicTime
        ADD     R1,R0,#100
Wait_10
        SWI     XPortable_Idle
        SWI     XOS_ReadMonotonicTime
        CMP     R0,R1
        BLO     Wait_10
        Pull    "R0,R1,PC",AL


; =============
; DoPollChanged
; =============

;entry
; R1 drive 0-3
; R2 sequence number

;exit
; R2 new sequence number
; R3 status bits
;   b0 not changed
;   b1 maybe changed
;   b2 changed
;   b3 empty
;   b6 empty works
;   b7 changed works

DoPollChanged ROUT
        Push    "R0,R1,R4-R9,LR"
      [ Debug4
        mess    ,"*Enter PollChanged",NL
      ]
; MOV    R3, #Drv_NotChanged
; Pull   "R0,R1,R4-R9,PC"

; address drive record

        DrvRecPtr R4,R1
        LDRB    R5, [R4,#DrvFlags]
        LDR     R6, [R4,#DrvSequenceNum]

        BIC     R0, R5, #LostUnitAtn
        STRB    R0, [R4,#DrvFlags]

        TST     R1, #4
        BEQ     %FT05
        ; Hard drive case - only for hotplugging, really.
        mapDrvToDevLo LR, R1, R4
        CMP     LR, #-1
        MOVEQ   R3, #MiscOp_PollChanged_Empty_Flag
        BEQ     %FT04
        TSTS    R5, #LostUnitAtn
        TEQEQS  R2, R6
        MOVEQ   R3, #MiscOp_PollChanged_NotChanged_Flag
        MOVNE   R3, #MiscOp_PollChanged_Changed_Flag
04
        TST     R3, #MiscOp_PollChanged_NotChanged_Flag
        ADDEQ   R2, R6, #1
        STREQ   R2, [R4,#DrvSequenceNum]
        ORR     R3, R3, #MiscOp_PollChanged_ChangedWorks_Flag :OR: MiscOp_PollChanged_EmptyWorks_Flag
        Pull    "R0,R1,R4-R9,PC"


05
        ; Floppy drive case
        BL      TestUnitReady
        BLNE    TestUnitReady           ; try once more to be sure
; ORRNE  R0, R5, #LostUnitAtn
; STRNEB R0, [R4,#DrvFlags]
        TSTEQS  R5, #LostUnitAtn
        BNE     %FT10

08
;here if not changed
        MOV     R3, #MiscOp_PollChanged_Changed_Flag+MiscOp_PollChanged_Ready_Flag
        TEQS    R2, R6
        MOVEQ   R3, #MiscOp_PollChanged_NotChanged_Flag+MiscOp_PollChanged_Ready_Flag
        MOV     R2, R6                   ; Returned as the new drive sequence number
        B       %FT20

;
10
        ADD     R2, R6, #1
        STR     R2, [R4,#DrvSequenceNum]
        BL      TestUnitReady
        BLNE    TestUnitReady           ; try once more to be sure
        ORRNE   R0, R5, #LostUnitAtn
        STRNEB  R0, [R4,#DrvFlags]

;18
        MOVEQ   R3, #MiscOp_PollChanged_Changed_Flag+MiscOp_PollChanged_Ready_Flag
        MOVNE   R3, #MiscOp_PollChanged_Empty_Flag
20

      [ Debug4
        ASSERT  Drv_Empty   > Drv_Changed
        ASSERT  Drv_Changed > Drv_NotChanged
        AND     R0, R3, #Drv_Empty+Drv_Changed+Drv_NotChanged
        CMP     R0, #Drv_Changed
        mess    LT,"Not Changed",NL
        mess    EQ,"*Changed"   ,NL
        mess    GT,"*Empty"     ,NL
      ]
        ORR     R3, R3, #MiscOp_PollChanged_ChangedWorks_Flag :OR: MiscOp_PollChanged_EmptyWorks_Flag :OR: MiscOp_PollChanged_ReadyWorks_Flag
        Pull    "R0,R1,R4-R9,PC"

;
; This issues ControlErrors, if device not reserved or reserved by us, this
; should succeed. If reserved by another user it will fail.
; It is left in the state that floppies require.
;
TestUnitReady
95
        Push    "R0-R6,R8,LR"
        SavePSR R6
      [ Debug4
        mess    , "TestUnitReady"
      ]
        mapDrvToDevLo R1, R1
        MOV     R0, #4                  ; RC for ControlErrors
        MOV     R2, #1                  ; Auto Request-Sense, Return Unit-Attention
        MOV     R8, R12
        SWI     XSCSI_Control

        MOVVC   R0, R1
        ADRVC   R2, CDB_TestUnitReady

        MOVVC   R1, #6                  ; CDB len
        MOVVC   R3, #0                  ; 
        MOVVC   R4, #0
        MOVVC   R5, #0
        MOVVC   R8, R12                 ; AccessKey
        SWIVC   XSCSI_Op
      [ Debug4
        mess    VC,"*Ready",NL
        mess    VS,"*Not Ready ("
        LDRVS   LR,[R0]
        wrhex   LR,VS
        mess    VS,")",NL
      ]
        ORRVC   R6, R6, #Z_bit
        BICVS   R6, R6, #Z_bit
        RestPSR R6,,f
        Pull    "R0-R6,R8,PC"

CDB_TestUnitReady
        DCB     &00                     ; TEST UNIT READY
        DCB     0                       ; LUN & reserved
        DCB     0                       ; Reserved
        DCB     0                       ; Reserved
        DCB     0                       ; Reserved
        DCB     0                       ; Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
        ALIGN

;
; SCSIOp_HandlingAtn
; ==================
;
; On entry
;   R0-R8 as for SWI XSCSI_Op
;
; On exit
;   As SWI XSCSI_Op
;
SCSIOp_HandlingAtn
        Push    "R0-R4,R9,LR"           ; Remember entry registers corrupted by SCSI_Op
        SWI     XSCSI_Op                ; Issue the operation
        ADDVC   SP,SP,#5*4      ; If no error, then return
        Pull    "R9,PC",VC
        LDR     LR,[R0]                 ; Was it a "Unit attention" error?
        LDR     R9,=ErrorNumber_SCSI_CC_UnitAttention
        TEQ     LR,R9
        ADDNE   SP,SP,#5*4      ; If not, return the error
        Pull    "R9,PC",NE

        LDRB    R2,[SP,#0]              ; R2 = SCSI device of operation
        MOV     R1,#MaxDriveNo-1        ; loop over 8 drives
05
        mapDrvToDevLo R0,R1
        TEQ     R0,R2                   ; were we talking to this drive's device?
        BNE     %FT10
        DrvRecPtr R4,R1                 ; if so, set the drive's LostUnitAtn flag
        LDRB    LR, [R4,#DrvFlags]
        ORR     LR, LR, #LostUnitAtn
        STRB    LR, [R4,#DrvFlags]
10
        SUBS    R1, R1, #1              ; keep going down to drive 0
        BPL     %BT05
        Pull    "R0-R4"                 ; restore entry registers
        SWI     XSCSI_Op                ; retry the operation
        Pull    "R9,PC"

        LNK     ScsiFs20.s
@


4.16
log
@Strip some old code and options
Detail:
  Since we only really care about the RISC OS 5 version of this module, there are various old switches stretching back 20+ years which can be removed to make the sources a bit easier on the eye:
  * OpticalMemorySupport (-> {TRUE})
  * IgnoreRecoveredError (-> {TRUE})
  * FloppySupport (-> {TRUE})
  * MediaLocking (-> {TRUE})
  * BigDisc (-> {TRUE})
  * AutoDetect (-> {TRUE})
  * HotPlug (-> {TRUE})
  Files changed:
  HelpText, hdr/mymacros, s/Fixes, s/Hdr_fst, s/ScsiFs00, s/ScsiFs05, s/ScsiFs15, s/ScsiFs20, s/ScsiFs50
Admin:
  Resulting binary unchanged (for default options, at least)


Version 1.29. Not tagged
@
text
@d504 1
@


4.15
log
@Tidy things up a bit
Detail:
  s/ScsiFs00, ScsiFs05, ScsiFs15, ScsiFs20, ScsiFs50 - Add comments for some of the different IDs which are used. Add MaxDriveNo constant, and make use of it where appropriate. Make BlockSizes non-braindead.
Admin:
  Cosmetic changes only, binary unchanged.


Version 1.29. Not tagged
@
text
@a50 1
      [ HotPlug
a55 1
      ]
a64 20
    [ :LNOT: BigDisc
      [ FloppySupport
        TST     R2, #bit31
        BEQ     %FT10
      ]
        TEQS    R6, #NIL
        BEQ     %FT10                   ; if mount

        LDRB    R7, [R5,#Zones]         ; Here we check that the winnie map size held in
        LDRB    R8, [R5,#SectorSize]    ; CMOS is up to date
        MOV     R8, R7, LSL R8
        MOVS    R8, R8, LSR #8
        MOVEQ   R8, #2
        sbaddr  R7, MapSizes-4          ; N.B. R2 LSR #(32-3) gives winnie drive number 4..7
        LDRB    LR, [R7,R2, LSR #(32-3)]
        TEQS    LR, R8
        BLNE    UpdateMapSize           ; (R2,R7,R8) if not we update it

10
    ]
a71 1
      [ BigDisc
a72 1
      ]
a76 1
      [ FloppySupport
a77 1
      ]
a93 1
      [ BigDisc
a96 1
      ]
a154 1
      [ MediaLocking
a156 1
      ]
a324 1
      [ BigDisc
a325 3
      |
        Push    "R6"
      ]
a339 1
      [ IgnoreRecoveredError
a341 1
      ]
a350 1
      [ IgnoreRecoveredError
a352 1
      ]
a362 1
      [ BigDisc
a363 3
      |
        ADD     SP,SP,#12               ; Discard the stacked CBD
      ]
a382 1
      [ BigDisc
a385 3
      |
        ADD     R2, R2, R7                      ; Inc. disc address by amount transfered
      ]
a435 1
      [ HotPlug
a439 1
      ]
a440 18
    [ :LNOT: BigDisc
UpdateMapSize
        Push    "R0-R2,LR"
        STRB    R8, [R7,R2, LSR #(32-3)]
        MOV     R0, #OsByte_WriteCMOS
        MOV     R1, R2, LSR #(32-3)
      [ Debug2
        wrhex   R1
        wrhex   R8
        mess    ,"oldsize drive newsize",NL
      ]
        ADD     R1, R1, #MapSizeCMOS-4
        MOV     R2, R8
        SWI     XOS_Byte                ; (R0-R2->R0-R2,V)
        Pull    "R0-R2,PC"
    ]

      [ IgnoreRecoveredError
a456 1
      ]
a509 1
    [ FloppySupport
a691 1
    ]
@


4.14
log
@Sources lined up to be more readable
One pass through AsmTidy, then a manual inspection.
Builds binary identical version. No tagged.
@
text
@d87 1
a87 1
        sbaddr  R7, BlockSizes-4        ; if not examined drive yet
d745 1
a745 1
        MOV     R1,#7                   ; loop over 8 drives
@


4.13
log
@Minor cleanups
* Upcall and OsByte symbols used from central headers
* T and F swapped for ObjAsm built in variables
* Deleted some unused CPU and hardware definitions
* Put unused files in the attic
Tested briefly, still worked.

Version 1.27. Tagged as 'SCSIFS-1_27'
@
text
@d17 1
a17 1
 LTORG
d33 1
a33 1
 getSB
d35 1
a35 1
 Push   "R0-R8,R9,LR"
d37 47
a83 47
 [ Debug3
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 wrhex  R6
 mess   ,"*>LowLevel",NL
 ]

 [ Debug3
 mess   , "LowLevelEntry/LowLevelOp - "
 ]

 [ HotPlug
 MOV    LR,R2,LSR #(32-3)
 DrvRecPtr LR,LR
 mapDrvToDevLo LR,LR,LR
 CMP    LR,#-1
 BEQ    BadDrive
 ]

 CMPS   R4, #0                  ;IF 0 length
 BICEQ  R7, R1, #NoTimeOut :OR: NoEscape :OR: ScatterBit :OR: AltDefectBit
 ASSERT DiscOp_Verify < DiscOp_ReadTrk
 ASSERT DiscOp_ReadSecs < DiscOp_ReadTrk
 ASSERT DiscOp_WriteSecs < DiscOp_ReadTrk 
 CMPEQS R7, #DiscOp_ReadTrk     ;AND verify, read/write secs, not background
 Pull    "R0-R8,R9,PC",LO       ;THEN nothing to do

 [ :LNOT: BigDisc
 [ FloppySupport
 TST    R2, #bit31
 BEQ    %FT10
 ]
 TEQS   R6, #NIL
 BEQ    %FT10                   ;if mount

 LDRB   R7, [R5,#Zones]         ;Here we check that the winnie map size held in
 LDRB   R8, [R5,#SectorSize]    ;CMOS is up to date
 MOV    R8, R7, LSL R8
 MOVS   R8, R8, LSR #8
 MOVEQ  R8, #2
 sbaddr R7, MapSizes-4          ;N.B. R2 LSR #(32-3) gives winnie drive number 4..7
 LDRB   LR, [R7,R2, LSR #(32-3)]
 TEQS   LR, R8
 BLNE   UpdateMapSize           ;(R2,R7,R8) if not we update it
d86 2
a87 2
 ]
 sbaddr R7, BlockSizes-4        ;if not examined drive yet
d89 10
a98 10
 LDRB   R8, [R7,R2, LSR #(32-3)]
 CMPS   R8, #0                  ;V=0
 BLEQ   Examine                 ;(R2,R7->R0,R8,V) then do it now
 BVS    LowError

 [ BigDisc
 LDR    R7, FCFeatures
 ]
 ANDS   R5, R1, #OpMask
 CMPS   R5, #DiscOp_Restore+1        ;moan if bad reason code
d101 1
a101 1
 [ FloppySupport
d103 2
a104 2
 ]
 BCS    BadParameters
d106 1
a106 1
 MOV    R0, R2, LSR #29
d109 19
a127 19
 mapDrvToDevLo R0, R0           ;map drive onto device
 AND    LR, R1, #ScatterBit :OR: NoEscape :OR: NoTimeOut :OR: BackgroundOp
 ORR    R0, R0, LR, LSL #CTL_cnvt
 ASSERT DiscOp_StepIn > DiscOp_Restore
 ASSERT DiscOp_StepOut > DiscOp_Restore
 ASSERT DiscOp_CachedReadSecs > DiscOp_Restore
 ASSERT DiscOp_Specify > DiscOp_Restore
 CMPS   R5, #DiscOp_Restore
 BHS    %FT20
                                ;convert byte disc address to block address
 BIC    LR, R2, #DiscBits
 [ BigDisc
 TST    R7, #FC_Big
 MOVNE  R7, LR
 BNE    %FT20
 ]
 MOV    R7, LR, LSR R8          ;block number
 TEQS   LR, R7, LSL R8
 BNE    BadParameters
d130 16
a145 16
 [ AllowPartitions
 MOV    LR, R2, LSR #(32-3)     ; disc number
 ADD    LR, SB, LR, LSL #2      ; to word address
 LDR    LR, [LR, #:INDEX:PartitionBaseAdd-:INDEX:SCSIFSWorkBase]
 ADD    R7, R7, LR              ; offset by base sector offset
 ]
 ADD    PC, PC, R5, LSL #2      ;dispatch on reason
 NOP

 B      VerifyCase
 B      ReadSecsCase
 B      WriteSecsCase
 B      ReadTrackCase           ;may be read ids ?
 B      WriteTrackCase          ;whatever needed for formatting
 B      SeekCase
 B      RestoreCase
d148 5
a152 5
 [ Debug3
 mess   , "Verify", NL
 ]
 MOV    R1, #&2F                ;VERIFY command
 B      OpCommon
d155 6
a160 6
 [ Debug3
 mess   , "ReadSectors", NL
 ]
 ORR    R0, R0, #CTL_TXREAD
 MOV    R1, #&28                ;READ extended command
 B      OpCommon
d163 6
a168 6
 [ Debug3
 mess   , "WriteSectors", NL
 ]
 ORR    R0, R0, #CTL_TXWRITE
 MOV    R1, #&2A                ;WRITE extended command
 B      OpCommon
d171 4
a174 4
 [ Debug3
 mess   , "ReadTrack !!NOT SUPPORTED - NOP !!", NL
 ]
 B      DoNOP
d177 4
a180 4
 [ Debug3
 mess   , "WriteTrack !!NOT SUPPORTED - NOP!!", NL
 ]
 B      DoNOP
d183 17
a199 17
 [ MediaLocking
 MOV    R1, R0
 BL     UnLockMedia
 ]
 [ SeekIsNOP
 [ Debug3
 mess   , "Seek !!NOT SUPPORTED - NOP !!", NL
 ]
 B      DoNOP
 |
 [ Debug3
 mess   , "Seek", NL
 ]
 MOV    R1, #&2B                ;SEEK command
 MOV    R4, #0                  ;Ensure cdb[7]..cdb[8] are zero
 B      OpCommon
 ]
d202 4
a205 4
 [ Debug3
 mess   , "Restore !!NOT SUPPORTED - NOP !!", NL
 ]
 B      DoNOP
d230 5
a234 5
 MOV    R5, #0                          ;Default timeout
 [ UseSpecialScatterBlk
 STR    R5, ScatterFlag                 ;Default: dont use scatter method
 ]
 SUB StkPtr,StkPtr,#12                  ;Largest CBD is 12 bytes
d236 2
a237 2
 MOV R2,StkPtr                          ;->CDB built on stack
 Push "R2,R3,R4,R9"
d239 1
a239 1
 RevBytes R7, R5,R6                     ;Change sex of disc block address
d247 15
a261 15
 MOV R5, R4, LSR R8                     ;Xfer length in blocks (was in bytes)
 TEQ R4, R5, LSL R8
 ADDNE  R5, R5, #1                      ;Inc if Xfer length not a whole number
 [ UseSpecialScatterBlk
 BEQ DontNeedScatBlk                    ;If the length was a whole number fine ...

 AND R9, R0, #CTL_TXWRITE :OR: CTL_TXREAD
 CMP R9, #CTL_TXWRITE
 BNE DontNeedScatBlk                    ;If we arent writing fine ...
 TST R0, #CTL_SCATTER
 [ Debug3                               ;Oh dear already using a scatter pointer ...
 BEQ NotAppropriate1
 SWI OS_WriteS                          ;So we cant make things easy for the Driver
 = "Having to save a nasty block slowly, as scatter list already used"
 SWI OS_NewLine
d263 2
a264 2
 ]
 BNE DontNeedScatBlk
d266 26
a291 26
 RSB R9, R4, R5, LSL R8                 ;Get required dummy block length
 CMP R9, #?PaddingBlock                 ;Too big?
 BHS DontNeedScatBlk                    ;Let driver deal with it

 [ Debug3
 SWI OS_WriteS
 = "Tranferring to a scatter block ..."
 SWI OS_NewLine
 ]

 Push "R5"
 MOV R9, #1                             ;Note that the scatterblock is required
 STR R9, ScatterFlag
 ORR R0, R0, #CTL_SCATTER               ;Save the transfer to a Scatter pointer
 ADR R9, WriteScatBlk
 STR R3, [R9, #0]
 STR R4, [R9, #4]
 ADR LR, PaddingBlock
 STR LR, [R9, #8]
 
                                        ;Take the rounded up no. of blocks
 MOV R5, R5, LSL R8                     ;Convert this into bytes
 STR R5, ScatterData                    ;Save this new Total Length
 SUB R5, R5, R4                         ;And take off the original length
 STR R5, [R9, #12]                      ;This is the length of the dummy block
 Pull "R5"
d294 1
a294 1
 ]
d296 1
a296 1
 [ CheckXferLen
d310 17
a326 17
 [ XferLenMax64K
 MOV R3,#65536
 MOV R3,R3,LSR R8
 CMP R3,R5
 MOVLO R5,R3
 CMP R5,#65536 ; Just in case we have a device with a block size of 1
 SUBEQ R5,R5,#1
 |
 CMP R5,#&10000
 MOVHS R5,#&FF00
 ORRHS R5,R5,#&00FF
 ]
 ]

 MOV R3,R5,LSR #8
 MOV R3,R3,LSL #24                      ;MSB in CDB[7] {R3 bits 24..31}
 AND R6,R5,#&FF                         ;LSB in CDB[8] {R4 bits  0..7 }
d328 2
a329 2
 ORR R1,R1,R7,LSL #16                   ;Add sex changed block address
 ORR R3,R3,R7,LSR #16                   ; to CDB
d331 1
a331 1
 STMIA R2,{R1,R3,R6}                    ;Copy 12bytes of CDB onto stack
d337 2
a338 2
 MOV R1,#10
 Pull "R2,R3,R4,R9"
d340 6
a345 6
 [ UseSpecialScatterBlk
 LDR R6, ScatterFlag                    ;Are we using the special ScatterBlock ?
 CMP R6, #0
 ADRNE R3, WriteScatBlk                 ;Yes ! Better make RAMptr point to it,
 LDRNE R4, ScatterData                  ;and use the rounded up total length
 ]
d352 14
a365 14
 SUBS   R6,R4,R5,LSL R8
 SUBGT  R4,R4,R6
 MOVLT  R6,#0
 [ BigDisc
 Push   "R6,R8"
 |
 Push   "R6"
 ]

 MOV R5, #0

 TSTS   R0, #CTL_BACKGROUND
 LDRNE  R6, WinnieCallAfter             ;Callback address
 LDRNE  R7, FileCorePrivate             ; & wsptr (if needed)
d367 1
a367 1
 MOV    R8, R12                         ;AccessKey
d369 2
a370 2
 [ RetryIfBusy
 MOV    R9,#60                          ;Retry on timeout for 60 seconds
d372 10
a381 10
 Push   "R0-R4"                         ;Stack incase we need to retry
 DoSCSIOp
 [ IgnoreRecoveredError
 BLVS   CheckRecovered                  ;If error is 'Recovered error' clear
                                        ; V and pretend it never happened
 ]
 BVC    %FT35                           ;OK, so ditch stacked R0-R4 and continue
 BL     CheckRetry
 Pull   "R0-R4",VC                      ;Retry with stacked R0-R4
 BVC    %BT30
d383 10
a392 10
 LDR    LR, FCFeatures
 ADD    StkPtr,StkPtr,#5*4              ;Ditch stacked R0-R4 before reporting error
 |
 DoSCSIOp
 [ IgnoreRecoveredError
 BLVS   CheckRecovered                  ;If error is 'Recovered error' clear
                                        ; V and pretend it never happened
 ]
 LDR    LR, FCFeatures
 ]
d395 2
a396 2
 Pull   "R6"
 ADD    R4,R4,R6
d398 9
a406 9
 TST    LR, #FC_NewErrors
 ORREQ  R0, R0, #ExternalErrorBit
 MOVVC  R0, #0
 [ BigDisc
 LDR    R8, [StkPtr], #16               ;Pull blocksize & discard stacked CBD
 |
 ADD StkPtr,StkPtr,#12                  ;Discard the stacked CBD
 ]
 LDMIB  SP, {R1-R2,R6-R7}
d408 1
a408 1
 [ UseSpecialScatterBlk
d411 10
a420 10
 LDR    R9, ScatterFlag
 TEQ    R9, #0
 BEQ    %FT10
 LDR    R9, ScatterData ; Get adjusted length
 SUB    R9, R9, R7 ; Calculate the amount of padding we used
 SUB    R4, R4, R9 ; Forget the padding
 TEQ    R4, #0 ; Preserve V
 MOVMI  R4, #0 ; Clamp R4 if we managed to transfer everything we were originally asked to
 SUB    R3, R7, R4 ; Get amount transferred
 ADD    R3, R6, R3 ; And calculate the correct value of R3 to return
d422 1
a422 1
 ]
d424 9
a432 9
 SUB    R7, R7, R4                      ;Amount Xfered
 [ BigDisc
 TST    LR, #FC_Big
 ADDNE  R2, R2, R7, LSR R8              ;Inc. disc address by amount transfered
 ADDEQ  R2, R2, R7                      ;Inc. disc address by amount transfered
 |
 ADD    R2, R2, R7                      ;Inc. disc address by amount transfered
 ]
 STMIA  SP, {R0,R1-R2,R3-R4}
d434 1
a434 1
 [ XferLenMax64K
d448 12
a459 12
 BVS    %FT10
 TEQ    R4,#0
 BEQ    %FT10
 AND    LR, R1, #OpMask
 TEQ    LR, #1 ; Read sectors
 TEQNE  LR, #2 ; Write sectors
 [ Debug3
 mess   EQ,"Looping back round to transfer rest of data",NL
 ]
 ADDEQ  R5,R13,#5*4
 LDMEQIA R5,{R5-R6} ; Recover disc record, defect list
 BEQ    LowLevelOp2
d461 2
a462 2
 ]
 
d464 10
a473 10
 STRVS  R0, [SP]
 [ Debug3
 wrhex  R0,VS
 mess   VC,"         "
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 mess   ,"*<LowLevel",NL,NL
 ]
d475 1
a475 1
 Pull   "R0-R8,R9,PC"
d478 3
a480 3
 MOV    R0, #BadParmsErr
 BL     SetV
 B      LowError
d482 1
a482 1
 [ HotPlug
d484 4
a487 4
 MOV    R0, #BadDriveErr
 BL     SetV
 B      LowError
 ]
d489 1
a489 1
 [ :LNOT: BigDisc
d491 14
a504 14
 Push   "R0-R2,LR"
 STRB   R8, [R7,R2, LSR #(32-3)]
 MOV    R0, #OsByte_WriteCMOS
 MOV    R1, R2, LSR #(32-3)
 [ Debug2
 wrhex  R1
 wrhex  R8
 mess   ,"oldsize drive newsize",NL
 ]
 ADD    R1, R1, #MapSizeCMOS-4
 MOV    R2, R8
 SWI    XOS_Byte    ;(R0-R2->R0-R2,V)
 Pull   "R0-R2,PC"
 ]
d506 1
a506 1
 [ IgnoreRecoveredError
d516 8
a523 8
 Push   "R0,R1"
 LDR    R0,[R0]                         ;Error number
 LDR    R1,=ErrorNumber_SCSI_RecoveredError
 TEQ    R0,R1                           ;If RecoveredError (V preserved)
 Pull   "R0,R1"
 CMPEQ  R0,#0                           ; pretend it never happened (clear V)
 MOV    PC,LR                           ; else keep the error
 ]
d537 13
a549 13
 Push   "R0,R1,LR"
 SETV
 LDR    R0,[R0]                         ;Error number
 LDR    R1,=ErrorNumber_SCSI_Busy
 TEQ    R0,R1                           ;If NOT("Target status - busy" or
 LDRNE  R1,=ErrorNumber_SCSI_CC_NotReady
 TEQNE  R0,R1                           ;       "Target error - Not ready"
 LDRNE  R1,=ErrorNumber_SCSI_Timeout
 TEQNE  R0,R1                           ;       "Timeout"
 LDRNE  R1,=ErrorNumber_SCSI_Died
 TEQNE  R0,R1                           ;       "Unexpected disconnection"
                                        ;      )
 Pull   "R0,R1,PC",NE                   ; return indicating report error
d551 2
a552 2
 TEQ    R9,#0                           ;Retry counter hit zero
 Pull   "R0,R1,PC",EQ                   ; return indicating report error
d556 4
a559 4
 SUB    R9,R9,#1
 BL     WaitOneSecond
 CMP    R0,#0
 Pull   "R0,R1,PC",AL                   ;Return indicating do-a-retry
d567 3
a569 3
 Push "R0,R1,LR"
 SWI XOS_ReadMonotonicTime
 ADD R1,R0,#100
d571 4
a574 4
 SWI XOS_ReadMonotonicTime
 CMP R0,R1
 BLO Wait_10
 Pull "R0,R1,PC",AL
d577 1
a577 1
 [ FloppySupport
d597 4
a600 4
 Push   "R0,R1,R4-R9,LR"
 [ Debug4
 mess   ,"*Enter PollChanged",NL
 ]
d606 18
a623 18
 DrvRecPtr R4,R1
 LDRB   R5, [R4,#DrvFlags]
 LDR    R6, [R4,#DrvSequenceNum]

 BIC    R0, R5, #LostUnitAtn
 STRB   R0, [R4,#DrvFlags]

 TST    R1, #4
 BEQ    %FT05
 ; Hard drive case - only for hotplugging, really.
 mapDrvToDevLo LR, R1, R4
 CMP    LR, #-1
 MOVEQ  R3, #MiscOp_PollChanged_Empty_Flag
 BEQ    %FT04
 TSTS   R5, #LostUnitAtn
 TEQEQS R2, R6
 MOVEQ  R3, #MiscOp_PollChanged_NotChanged_Flag
 MOVNE  R3, #MiscOp_PollChanged_Changed_Flag
d625 5
a629 5
 TST    R3, #MiscOp_PollChanged_NotChanged_Flag
 ADDEQ  R2, R6, #1
 STREQ  R2, [R4,#DrvSequenceNum]
 ORR    R3, R3, #MiscOp_PollChanged_ChangedWorks_Flag :OR: MiscOp_PollChanged_EmptyWorks_Flag
 Pull   "R0,R1,R4-R9,PC"
d633 3
a635 3
 ; Floppy drive case
 BL TestUnitReady
 BLNE TestUnitReady         ; try once more to be sure
d638 2
a639 2
 TSTEQS R5, #LostUnitAtn
 BNE    %FT10
d643 5
a647 5
 MOV    R3, #MiscOp_PollChanged_Changed_Flag+MiscOp_PollChanged_Ready_Flag
 TEQS   R2, R6
 MOVEQ  R3, #MiscOp_PollChanged_NotChanged_Flag+MiscOp_PollChanged_Ready_Flag
 MOV    R2, R6                   ;Returned as the new drive sequence number
 B      %FT20
d651 6
a656 6
 ADD   R2, R6, #1
 STR   R2, [R4,#DrvSequenceNum]
 BL TestUnitReady
 BLNE TestUnitReady         ; try once more to be sure
 ORRNE  R0, R5, #LostUnitAtn
 STRNEB R0, [R4,#DrvFlags]
d659 2
a660 2
 MOVEQ  R3, #MiscOp_PollChanged_Changed_Flag+MiscOp_PollChanged_Ready_Flag
 MOVNE  R3, #MiscOp_PollChanged_Empty_Flag
d663 11
a673 11
 [ Debug4
 ASSERT Drv_Empty   > Drv_Changed
 ASSERT Drv_Changed > Drv_NotChanged
 AND    R0, R3, #Drv_Empty+Drv_Changed+Drv_NotChanged
 CMP    R0, #Drv_Changed
 mess   LT,"Not Changed",NL
 mess   EQ,"*Changed"   ,NL
 mess   GT,"*Empty"     ,NL
 ]
 ORR    R3, R3, #MiscOp_PollChanged_ChangedWorks_Flag :OR: MiscOp_PollChanged_EmptyWorks_Flag :OR: MiscOp_PollChanged_ReadyWorks_Flag
 Pull   "R0,R1,R4-R9,PC"
d682 31
a712 31
 Push   "R0-R6,R8,LR"
 SavePSR R6
 [ Debug4
 mess   , "TestUnitReady"
 ]
 mapDrvToDevLo R1, R1
 MOV    R0, #4                  ;RC for ControlErrors
 MOV    R2, #1                  ;Auto Request-Sense, Return Unit-Attention
 MOV    R8, R12
 SWI    XSCSI_Control

 MOVVC  R0, R1
 ADRVC  R2, CDB_TestUnitReady

 MOVVC  R1, #6          ;CDB len
 MOVVC  R3, #0          ;
 MOVVC  R4, #0
 MOVVC  R5, #0
 MOVVC  R8, R12         ;AccessKey
 SWIVC  XSCSI_Op
 [ Debug4
 mess   VC,"*Ready",NL
 mess   VS,"*Not Ready ("
 LDRVS  LR,[R0]
 wrhex  LR,VS
 mess   VS,")",NL
 ]
 ORRVC  R6, R6, #Z_bit
 BICVS  R6, R6, #Z_bit
 RestPSR R6,,f
 Pull   "R0-R6,R8,PC"
d715 7
a721 7
 DCB    &00             ;TEST UNIT READY
 DCB    0               ;LUN & reserved
 DCB    0               ;Reserved
 DCB    0               ;Reserved
 DCB    0               ;Reserved
 DCB    0               ;Vendor Unique=0 (b7..b6),Reserved=0 (b5..b2),
 ALIGN
d734 9
a742 9
 Push   "R0-R4,R9,LR"           ; Remember entry registers corrupted by SCSI_Op
 SWI    XSCSI_Op                ; Issue the operation
 ADDVC  StkPtr,StkPtr,#5*4      ; If no error, then return
 Pull   "R9,PC",VC
 LDR    LR,[R0]                 ; Was it a "Unit attention" error?
 LDR    R9,=ErrorNumber_SCSI_CC_UnitAttention
 TEQ    LR,R9
 ADDNE  StkPtr,StkPtr,#5*4      ; If not, return the error
 Pull   "R9,PC",NE
d744 2
a745 2
 LDRB   R2,[SP,#0]              ; R2 = SCSI device of operation
 MOV    R1,#7                   ; loop over 8 drives
d747 7
a753 7
 mapDrvToDevLo R0,R1
 TEQ    R0,R2                   ; were we talking to this drive's device?
 BNE    %FT10
 DrvRecPtr R4,R1                ; if so, set the drive's LostUnitAtn flag
 LDRB   LR, [R4,#DrvFlags]
 ORR    LR, LR, #LostUnitAtn
 STRB   LR, [R4,#DrvFlags]
d755 6
a760 6
 SUBS   R1, R1, #1              ; keep going down to drive 0
 BPL    %BT05
 Pull   "R0-R4"             ; restore entry registers
 SWI    XSCSI_Op                ; retry the operation
 Pull   "R9,PC"
 ]
d762 1
a762 1
 LNK    s.ScsiFs20
@


4.12
log
@Don't source padding data from zero page
Detail:
  s/ScsiFs00, s/ScsiFs15, s/ScsiFs50 - When UseSpecialScatterBlk, pad writes out to device block size by using an empty block of RMA instead of the contents of zero page.
Admin:
  Fixes crashes when high processor vectors are in use


Version 1.26. Tagged as 'SCSIFS-1_26'
@
text
@d493 1
a493 1
 MOV    R0, #OsbyteWriteCMOS
@


4.11
log
@  Support for FileCore API relaxations
Detail:
  * Previously, SCSIFS always set the "No directory state" startup option
    bit in FileCore_Create, even though from the PRM's description of the
    *Configure Dir/NoDir options, it should have been setting it according
    to the shared bit in CMOS byte &0B. However, since RISC OS 3.00, FileCore
    has not done anything with this information, so I'm retiring the bit.
  * No longer passes hard disc map sizes in R6 to FileCore_Create. This means
    it no longer reads them from CMOS, and nor does it update the CMOS when
    discs are mounted. This is safe because FileCore hasn't actually used
    these values since RISC OS 4.00. For consistency with ADFS (which stopped
    using its equivalent CMOS at RISC OS 5.00) the code is switched out via
    the BigDisc switch. This means we can free up a whole 4 bytes of CMOS!
Admin:
  Tested briefly via a softload on an OMAP3 machine.

Version 1.25. Tagged as 'SCSIFS-1_25'
@
text
@d266 4
d283 2
a284 4
 MOV LR, #0
 STR LR, [R9, #8]                       ;Second Block starts at address 0 and can
                                        ; be up to 2^Log2BlockSize -1 long, so
                                        ; this better be RAM !!!
@


4.10
log
@Update to use some of the exported FileCore headers.
There are still a large number of local copies that should be visited, but this change at least allows it to assemble again FileCore-3_45.

Version 1.22. Tagged as 'SCSIFS-1_22'
@
text
@d67 1
d86 1
d487 1
d502 1
@


4.9
log
@Fix issues with large or oddly-sized SCSIFS transfers
Detail:
  s/ScsiFs15 - The code which fixes up the return values when a temp scatter block has been used was corrupting R7, causing later code to miscalculate the post-transfer disc address. Now fixed.
  s/ScsiFs15 - The code which handles splitting big transfers into 64K chunks was re-entering LowLevelOp with corrupt values of R5 & R6, leading to potential malfunction. Now fixed.
Admin:
  Tested on Iyonix & rev A2 BB-xM.
  Fingers crossed for no more bugs here.


Version 1.20. Tagged as 'SCSIFS-1_20'
@
text
@d61 4
a64 1
 CMPEQS R7, #Param3Op           ;AND verify, read/write secs, not background
d96 1
a96 1
 CMPS   R5, #RestoreOp+1        ;moan if bad reason code
d110 5
a114 1
 CMPS   R5, #Param1Op
d612 1
a612 1
 MOVEQ  R3, #Drv_Empty
d616 2
a617 2
 MOVEQ  R3, #Drv_NotChanged
 MOVNE  R3, #Drv_Changed
d619 1
a619 1
 TST    R3, #Drv_NotChanged
d622 1
a622 1
 ORR    R3, R3, #Drv_ChangedWorks :OR: Drv_EmptyWorks
d637 1
a637 1
 MOV    R3, #Drv_Changed+Drv_Ready
d639 1
a639 1
 MOVEQ  R3, #Drv_NotChanged+Drv_Ready
d653 2
a654 2
 MOVEQ  R3, #Drv_Changed+Drv_Ready
 MOVNE  R3, #Drv_Empty
d666 1
a666 1
 ORR    R3, R3, #Drv_ChangedWorks :OR: Drv_EmptyWorks :OR: Drv_ReadyWorks
@


4.8
log
@Fix XferMaxLen64K code to perform multiple SCSI_Ops instead of relying on the caller to retry the operation until all the data has been transferred
Detail:
  s/ScsiFs15 - Instead of relying on undocumented FileCore behaviour to ensure that long transfers are performed properly, SCSIFS now splits the transfer into chunks and loops internally until all the data has been transferred. This ensures the SCSIFS_DiscOp SWI works as expected.
  s/ScsiFs05 - Swap and ADR for ADRL, seems to be needed when enabling debug code.
Admin:
  Tested as a module softload on an Iyonix.
  Fixes issue with DiscKnight complaining that perfectly good discs contain thousands of errors.


Version 1.19. Tagged as 'SCSIFS-1_19'
@
text
@d408 2
a409 2
 SUB    R7, R7, R4 ; Get amount transferred
 ADD    R3, R6, R7 ; And calculate the correct value of R3 to return
d446 2
@


4.7
log
@Limit max transfer length to 64K, fix issues with transfer lengths being incorrectly modified
Detail:
  s/ScsiFs00, s/ScsiFs15 - As a workaround for numerous USB devices that fail when asked to transfer large amounts of data, SCSIFS now limits the maximum transfer length to 64K.
  This length seems to match the limit used by most operating systems. If necessary this code can be turned off via the XferLenMax64K switch.
  Additionally, a couple of bugs with the CheckXferLen and UseSpecialScatterBlk code have been fixed:
  - When CheckXferLen (and XferLenMax64K) limit the block count in the CDB, the code now calculates a new value of R4 to send to the SCSI driver instead of using the original. This ensures there's no ambiguity in the transfer length.
  - After the SCSI op is completed, the returned value of R4 is then adjusted to represent the real amount of untransferred data from FileCore's perspective.
  - When the special scatter block is in use, the code now returns to FileCore with R3 pointing to the correct location in the source buffer, and with R4 adjusted to take into account the extra padding that had been inserted. Previously the old code would have returned with R3 and R4 left unmodified (i.e. R3 would have been pointing at SCSIFS's temp scatter list)
Admin:
  Tested in ROM on a rev C2 beagleboard over the course of a few hours with the help of an automated test script.
  No more 'no sense' errors when attempting large block transfers to USB devices, and no sign of data corruption for large or small transfers.
  See the forums for more discussion of these issues: http://www.riscosopen.org/forum/forums/4/topics/470


Version 1.18. Tagged as 'SCSIFS-1_18'
@
text
@d36 1
d290 1
a290 2
; put 65535 in the CDB. Filecore will see that not all of the data has been
; transfered and call us again for the residue.
d423 27
@


4.6
log
@	small number of changes to correctly work with scatterlists such
	used by filecore format discs.
Detail: these should have been committed as part of the mods of 5th March
	though it appears the something was missed as recent checkouts didn't
	contain all the mods.
Admin:  castle added IP


Version 1.15. Tagged as 'SCSIFS-1_15'
@
text
@a290 2
; This condition will probably never arise, since it represents 16/32/64 Mbyte
; (for 256/512/1024 byte blocks).
d295 11
a305 3
 [ XferLenMax255
 CMP R5,#&100
 MOVHS R5,#&FF
d315 1
a315 1
 AND R5,R5,#&FF                         ;LSB in CDB[8] {R4 bits  0..7 }
d320 1
a320 1
 STMIA R2,{R1,R3,R5}                    ;Copy 12bytes of CDB onto stack
d330 2
a331 2
 LDR R5, ScatterFlag                    ;Are we using the special ScatterBlock ?
 CMP R5, #0
d336 14
a355 3
 [ BigDisc
 Push   "R8"
 ]
d383 4
d396 17
@


4.5
log
@	Added note on SCSIFS_Partitions swi.
	Committing correct files this time.
        previous version, 1.14 failed to include these

Detail:
Admin:  castle added IP. to be beta tested


Version 1.14. Tagged as 'SCSIFS-1_14'
@
text
@a42 1
 wrhex  R13
d101 2
a102 5
 [ Debug3
 wrhex  R0
 wrhex  R1
 mess , "xx1 ", NL
 ]
a105 5
 [ Debug3
 wrhex  R0
 wrhex  R1
 mess , "xx2 ", NL
 ]
a219 13
; [ CheckSpareRMA
; STMFD  R13!,{R0-R3}
; MOV    R0, #5                          ; return total free space
; SWI    XOS_Module                     
; BVS    %ft11                           ; failed to read size
; CMP    R3, #ExtraRMA                   ; at least xxx free?
;                                        ; no
; RSBLT  R1, R3, #ExtraRMA               ; extra we need
; MOVLT  R0, #1                          ; RMA space
; SWILT  XOS_ChangeDynamicArea           ; try to change it
;11                                     
; LDMFD  R13!, {R0-R3}                   ; recover regs
; ]
a245 5
 [ Debug3
   wrhex r0
   mess , "op entry1 "
 ]

a344 10
 [ Debug3
 wrhex  R0
 wrhex  R1
 wrhex  R2
 wrhex  R3
 wrhex  R4
 wrhex  R5
 wrhex  R6
 mess   , "DoSCSIOp", NL
 ]
a393 1
 wrhex  R13
@


4.4
log
@        found unexpected data workspace embedded in code .. moved to
        module RMA. module now builds into ROM
Detail:
Admin:  castle added IP ..


Version 1.13. Tagged as 'SCSIFS-1_13'
@
text
@d43 1
d101 6
a106 3
 AND    R0, R1, #ScatterBit :OR: NoEscape :OR: NoTimeOut :OR: BackgroundOp
 MOV    R0, R0, LSL #CTL_cnvt
 EOR    R0, R0, R2, LSR #29
d108 7
a129 5
 Push   "R0, R1,R2"
 MOV    R2, R2, LSR #(32-3)     ; disc number requested
 LDR    R1, =Service_SCSIMounting
 SWI    OS_ServiceCall          ; announce our intentions
 Pull   "R0,R1,R2"
d229 13
d268 5
d296 2
a297 2
 MOV R5, #0
 STR R5, [R9, #8]                       ;Second Block starts at address 0 and can
d300 2
a301 2
 Pull "R5"
 Push "R5"                              ;Take the rounded up no. of blocks
d372 10
d393 1
a393 1
 ADD    StkPtr,StkPtr,#20               ;Ditch stacked R0-R4 before reporting error
d431 1
d593 1
d612 1
d692 1
a692 1
 Push   "R0-R4,R10,LR"          ; Remember entry registers corrupted by SCSI_Op
d694 2
a695 2
 ADDVC  StkPtr,StkPtr,#6*4      ; If no error, then return
 Pull   "PC",VC
d697 2
a698 2
 LDR    R10,=ErrorNumber_SCSI_CC_UnitAttention
 TEQ    LR,R10
d700 1
a700 1
 Pull   "R10,PC",NE
d715 1
a715 1
 Pull   "R0-R4,R10"             ; restore entry registers
d717 1
a717 1
 Pull   "PC"
@


4.3
log
@          fixed a memory leak /unstable callback removal in scsifs.
          Added in detect needed for dosfs partitions.. didnt seem to make it
          into cvs in 1.11.
          Added SWI_SCSIFSPartitions and Service_SCSIMounting to permit external
          partition manger to provide partition handling

Detail:

Admin:    tested at castle.. castle added IP


Version 1.12. Tagged as 'SCSIFS-1_12'
@
text
@a221 6
 [ UseSpecialScatterBlk
ScatterFlag % 4                         ;Are we converting a save to use scatterblk ?
ScatterData % 4                         ;New Length (=Old Length rounded up to next block)
WriteScatBlk  DCD  0,0,0,0,0,0          ;Here is the scatter special block
 ]

@


4.2
log
@* Activated "floppy" (removable) support.
* Added big disc support.
* Added new error reporting scheme.
* Added autoconfiguration, and new SCSIdriver hotplugging.
* Added eject functionality (currently disabled due to issues with some USB
  devices).
* 32-bit compatible.

Version 1.11. Tagged as 'SCSIFS-1_11'
@
text
@d118 11
d303 7
d314 1
@


4.1
log
@Initial revision
@
text
@d50 8
d61 1
a61 1
 Pull    "R0-R8,R9,PC",LO,^     ;THEN nothing to do
d81 1
a81 1
 sbaddr R7, BlockSizes-4        ;if not examined drive yet 
d88 3
d93 1
a93 1
 LDRCCB R0, Winnies
d108 5
d201 1
a201 1
;                       
d234 1
a234 1
;              
d260 1
a260 1
 Push "R5"                                            
d264 2
a265 2
 ADR R9, WriteScatBlk                   
 STR R3, [R9, #0]                       
d326 3
d335 1
a335 1
 SWI    XSCSI_Op
d340 1
a340 2
 ADDVC  StkPtr,StkPtr,#20               ;OK, so ditch stacked R0-R4
 BVC    %FT35                           ; and continue
a343 2
 ADDVS  StkPtr,StkPtr,#20               ;Ditch stacked R0-R4
 ORRVS  R0, R0, #ExternalErrorBit       ; before reporting error
d345 2
d348 1
a348 1
 SWI    XSCSI_Op
d353 1
a353 1
 ORRVS  R0, R0, #ExternalErrorBit
d355 7
d363 1
a363 3
                      
 MOVVC  R0, #0
 [ ProperScatter
d366 4
a369 2
 ADD    R2, R2, R7                      ;Inc. disc address by amount transfered
 STMIA  SP, {R0,R1-R2,R3-R4}
a370 2
 LDMIB  SP, {R1-R3,R7}
 SUB    R7, R7, R4                      ;Amount Xfered
a371 2
 ADD    R3, R3, R7  ;>>>done by driver??;Inc. RAM address by amount transfered
 STMIA  SP, {R0,R1-R3,R4}
d373 2
a374 1
 
d394 7
d414 1
a414 1
 Pull   "R0-R2,PC",,^
d429 1
a429 1
 CMP    R0,R1                           ;If RecoveredError
d431 2
a432 2
 BICEQS PC,LR,#V_bit                    ; pretend it never happened
 ORRS   PC,LR,#V_bit                    ; else keep the error
d445 1
a445 1
; 
a446 1
 ORR    LR,LR,#V_bit
d448 1
d451 1
a451 1
 CMP    R0,R1                           ;If NOT("Target status - busy" or
d453 1
a453 1
 CMPNE  R0,R1                           ;       "Target error - Not ready"
d455 1
a455 1
 CMPNE  R0,R1                           ;       "Timeout"
d457 1
a457 1
 CMPNE  R0,R1                           ;       "Unexpected disconnection"
d459 1
a459 1
 Pull   "R0,R1,PC",NE,^                 ; return indicating report error
d461 2
a462 2
 CMP    R9,#0                           ;Retry counter hit zero
 Pull   "R0,R1,PC",EQ,^                 ; return indicating report error
d468 2
a469 2
 Pull   "R0,R1,LR",AL                   ;Return indicating do-a-retry
 BIC    PC,LR,#V_bit
d484 1
a484 1
 Pull "R0,R1,PC",AL,^
d512 1
a512 1
; Pull   "R0,R1,R4-R9,PC",,^
d523 21
d545 2
a546 2
 ORRNE  R0, R5, #LostUnitAtn
 STRNEB R0, [R4,#DrvFlags]
d550 1
a550 1

d552 1
a552 1
 MOV    R3, #Drv_Changed
d554 1
a554 1
 MOVEQ  R3, #Drv_NotChanged
d567 1
a567 1
 MOVEQ  R3, #Drv_Changed
d574 3
a576 2
 CMP    R3, #Drv_Changed
 mess   LT,"Not Chamged",NL
d580 3
a582 3
 ORR    R3, R3, #Drv_ChangedWorks :OR: Drv_EmptyWorks
 Pull   "R0,R1,R4-R9,PC",,^
 
d590 2
a591 1
 Push   "R0-R5,R8,LR"
d612 9
a620 5
 mess   VS,"*Not Ready",NL
 ]
 Pull   "R0-R5,R8,LR"
 ORRVCS PC, LR, #Z_bit
 BICS   PC, LR, #Z_bit
d629 1
a629 2
 ALIGN 

d631 37
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

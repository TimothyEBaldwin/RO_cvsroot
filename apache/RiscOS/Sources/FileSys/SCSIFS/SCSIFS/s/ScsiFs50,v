head	4.17;
access;
symbols
	SCSIFS-1_35:4.17
	SCSIFS-1_34:4.16
	SCSIFS-1_33:4.15
	SCSIFS-1_32:4.14
	SCSIFS-1_31:4.13
	SCSIFS-1_30:4.13
	SCSIFS-1_29:4.11
	SCSIFS-1_28:4.11
	SCSIFS-1_27:4.9
	SCSIFS-1_26:4.8
	SCSIFS-1_25:4.7
	SCSIFS-1_24:4.6
	SCSIFS-1_23:4.6
	SCSIFS-1_22:4.6
	SCSIFS-1_21:4.5
	SCSIFS-1_20:4.5
	SCSIFS-1_19:4.5
	SCSIFS-1_18:4.5
	SCSIFS-1_17:4.5
	SCSIFS-1_16:4.5
	SCSIFS-1_15:4.5
	SCSIFS-1_14:4.3
	SCSIFS-1_13:4.3
	SCSIFS-1_12:4.3
	RO_5_07:4.2
	SCSIFS-1_11:4.2
	dellis_autobuild_BaseSW:4.1
	SCSIFS-0_25:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SCSIFS-0_25:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	RCA:4.1.0.2
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.17
date	2018.07.19.23.35.37;	author jballance;	state Exp;
branches;
next	4.16;
commitid	ehNjMt7G6PLuTNKA;

4.16
date	2018.07.16.20.54.10;	author jballance;	state Exp;
branches;
next	4.15;
commitid	SJpZ4PYeWmo66pKA;

4.15
date	2018.07.13.22.53.48;	author jballance;	state Exp;
branches;
next	4.14;
commitid	aFrQNZfF8zc8R1KA;

4.14
date	2017.09.09.20.44.51;	author jlee;	state Exp;
branches;
next	4.13;
commitid	fVsl5HJYpQ5I0z6A;

4.13
date	2017.09.09.20.30.02;	author jlee;	state Exp;
branches;
next	4.12;
commitid	bB8BD6OBVuZBVy6A;

4.12
date	2017.09.09.20.23.53;	author jlee;	state Exp;
branches;
next	4.11;
commitid	urDJ2k0Cof4xTy6A;

4.11
date	2013.10.06.13.49.21;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	8D9mMcKPmGAXNe8x;

4.10
date	2013.10.06.13.28.24;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	y16pwkkQv9juGe8x;

4.9
date	2013.08.23.07.00.55;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	7jw3CbjLYaGwXx2x;

4.8
date	2012.06.26.20.32.55;	author jlee;	state Exp;
branches;
next	4.7;
commitid	vuxe05m9OBG73gaw;

4.7
date	2012.03.21.01.59.37;	author bavison;	state Exp;
branches;
next	4.6;
commitid	Ds1Q6pzW6vPu0HXv;

4.6
date	2011.10.14.07.28.20;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	EhWGDLE3kx67WhDv;

4.5
date	2005.04.28.15.29.40;	author jballance;	state Exp;
branches;
next	4.4;

4.4
date	2005.03.05.02.00.15;	author jballance;	state Exp;
branches;
next	4.3;

4.3
date	2005.01.31.13.37.39;	author jballance;	state Exp;
branches;
next	4.2;

4.2
date	2003.05.23.13.05.38;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.34.14;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.34.14;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.05.01;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.42.13;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.38.32;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.17
log
@   Added method to find  SCSI ID and partition offset from icon number
Detail:
   SCSIFS_Partitions reason code 1 already provides the icon number
   for a given SCSI ID and partition offset. Reason code 2 provides
   the inverse function to this.
Admin:
  tested on iMx6


Version 1.35. Tagged as 'SCSIFS-1_35'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >ScsiFs50

        TTL     "Initialisation and FS star commands"

FSCreateBlock
        DCB     EjectBit+CreateFlag_FixedDiscPollChangeSupport
        DCB     (CreateFlag_DriveStatusWorks:SHR:8)+(BigBit:SHR:8)+(NewErrorBit:SHR:8)
        DCB     0,fsnumber_SCSIFS
        DCD     CreateTitle    - Module_BaseAddr
        DCD     ScsiFsBootText - Module_BaseAddr
        DCD     LowLevelEntry  - Module_BaseAddr
        DCD     MiscEntry      - Module_BaseAddr

; >>>>>>>>>
; InitEntry
; >>>>>>>>>

InitEntry ROUT                           ; NO REENTRANCY CHECK NEEDED
      [ Debug1
        mess    ,"InitEntry - In",NL
      ]
        Push    "R7-R11,SB,LR"
        MOV     R10,#1                  ; init flag
        MOV     R11,R12

        MOV     R0, #ModHandReason_Claim
        MOV     R3, #:INDEX: WorkSize
        SWI     XOS_Module              ; claim workspace
        BVS     %FT95

        MOV     SB, R2
        STR     SB, [R11]

      [ UseSpecialScatterBlk
        ADR     R0, PaddingBlock
        MOV     R1, #0
        MOV     R2, #?PaddingBlock
05
        SUBS    R2, R2, #4
        STR     R1, [R0], #4
        BNE     %BT05
      ]

        sbaddr  R0, DrvRecs
        MOV     R1, #(-1:SHL:8)
        MOV     R2, #0
        STRB    R2, AttCBCount
        STRB    R2, DetCBCount
        STRB    R2, Dieing
        ASSERT  MaxDriveNo = 8
      [ AllowPartitions
        STR     R2, PartitionBaseAdd+0
        STR     R2, PartitionBaseAdd+4
        STR     R2, PartitionBaseAdd+8
        STR     R2, PartitionBaseAdd+12
        STR     R2, PartitionBaseAdd+16
        STR     R2, PartitionBaseAdd+20
        STR     R2, PartitionBaseAdd+24
        STR     R2, PartitionBaseAdd+28
      ]
        STMIA   R0!, {R1,R2}            ; Drive rec for ScsiFs::0
        STMIA   R0!, {R1,R2}            ;                      1
        STMIA   R0!, {R1,R2}            ;                      2
        STMIA   R0!, {R1,R2}            ;                      3
        STMIA   R0!, {R1,R2}            ;                      4
        STMIA   R0!, {R1,R2}            ;                      5
        STMIA   R0!, {R1,R2}            ;                      6
        STMIA   R0!, {R1,R2}            ;                      7

        MOV     R2, #0
        ASSERT  MaxDriveNo = 8
        STR     R2, BlockSizes          ; >>>>Init floppy BlockSizes
        STR     R2, BlockSizes+4        ; Block (sector size) for ScsiFs::4..7

        ASSERT  DrvFlags = 0
        ASSERT  DevNo = 1
        ASSERT  DrvSequenceNum = 4
        ASSERT  SzDrvRec = 8
        sbaddr  R0, DrvRecs
        MOV     R1, #LostUnitAtn :OR: (-1:SHL:8)
        MOV     R2, #0
        STMIA   R0!, {R1,R2}            ; Drive rec for ScsiFs::0
        STMIA   R0!, {R1,R2}            ;                      1
        STMIA   R0!, {R1,R2}            ;                      2
        STMIA   R0!, {R1,R2}            ;                      3

        MOV     R0, #0
        STR     R0, MsgFileOpen         ; No it isn't
      [ standalone
        BL      MsgFileReg
        BVS     %FT85
      ]
        BL      ReadCMOSflags           ; (->R0,R2,R3,R4,R5,V) read #floppies & winnies
        BL      ScanDrives
        MOV     R3, #4
        MOV     R4, #4
        STRB    R3, Floppies
        STRB    R4, Winnies

;Assume for the moment that user wants to start up with dir set as SCSI drives
;remain attached, unlike floppies.


        ORR     R3, R3, R5, LSL #16     ; Combine floppy count and default drive
        ORR     R3, R3, R4, LSL #8      ; OR in number of drives
        BL      ReadDirCMOS             ; (->R0,R4,V)
        BL      ReadFileCMOS            ; (->R0,R5,V)

      [ DoBuffering
        ASSERT  F,"Read ahead/write behind NOT supported"
      |
        MOV     R5,#0                   ; NO background Xfers
      ]

        MVN     R6, #0
        ADR     R0, FSCreateBlock
        ADRL    R1, Module_BaseAddr
        MOV     R2, R11
        SWI     XFileCore_Create        ; (R0-R6->R0-R2,V)
        BVS     %FT85
        STR     R0, FileCorePrivate
        STR     R2, WinnieCallAfter
        MOV     R8, R0
        MOV     R0, #6
        SWI     XFileCore_MiscOp        ; (R0,R8->R0,V)
        MOVVC   R7, #FC_Big
        MOVVS   R7, #0
        SWI     XFileCore_Features
        SUBVSS  R0, R0, R0              ; R0=0, V cleared
        TST     R0, #Feature_NewErrors
        ORRNE   R7, R7, #FC_NewErrors
        STR     R7, FCFeatures
      [ Debug1
        mess    ,"InitEntry - Out",NL
      ]
        Pull    "R7-R11,SB,PC"

        LTORG



; >>>>>>>>
; DieEntry
; >>>>>>>>

DieEntry
      [ Debug1
        mess    ,"DieEntry",NL
      ]
        Push    "R7-R11,SB,LR"
        getSB

        MOV     R0, #1
        STRB    R0, Dieing                      ; prevent any further callbacks
        LDRB    R0, AttCBCount
        TEQ     R0, #0
        LDREQB  R0, DetCBCount
        TEQ     R0, #0
        BEQ     %ft1                            ; none awaited
; need to let CBs in **********
1


        MOV     R10,#0                          ; Delete "FileCore%SCSI"
        MOV     R0, #ModHandReason_Delete       ; filecore will close down all
        ADRL    R1, DieTitle                    ; open files before dying
        SWI     XOS_Module                      ; 
        MOVVS   R9, R0

        MOV     R5, #0
        sbaddr  R7, BlockSizes
01
        MOV     R0, #UpCall_DriveRemoved
        MOV     R1, R5
        BL      UpcallDrive
        LDRB    R4, [R7, R5]
        TST     R4, #&FF
        BEQ     %FT02
        mapDrvToDevLo R1, R5
        BL      UnLockMedia
        MOV     R0, #2                  ; RC for ReleaseDevice
        MOV     R8, R12                 ; Access key
        SWI     XSCSI_Reserve
02
        MOVVS   R9, R0
        ADD     R5, R5, #1              ; Next drive
        CMP     R5, #MaxDriveNo
        BNE     %BT01                   ; Loop until no more drives

85
        MOVVS   R9, R0                  ; Keep any earlier error

        LDR     R0, MsgFileOpen
        TEQ     R0, #0
        ADRNE   R0, MsgFileBlock        ; Close the messages if open
        SWINE   XMessageTrans_CloseFile 
        MOV     R0, #0
        STR     R0, MsgFileOpen

      [ standalone
        BL      MsgFileDereg            ; Remove ResourceFS messages
      ]

        MOV     R0, #ModHandReason_Free
        MOV     R2, SB
        SWI     XOS_Module              ; Free workspace
      [ Dev
        wrhex   R0, VS
        mess    VS,"Heap error",NL
      ]
95
        MOVVS   R9, R0
      [ Dev
        wrhex   R10,VS
        wrhex   R0, VS
        mess    VS,"Error",NL
      ]

        ADDS    R0, R9, #0
        ADDNES  R10,R10,#0              ; only error on init (R10=0/1 for Die/Init)
        Pull    "R7-R11,SB,PC",EQ

        BL      SetV
      [ Dev
        wrhex   R0
        mess    ,"ScsiFs Init Error",NL
      ]
        Pull    "R7-R11,SB,PC"

        LTORG

ServiceTable
        ASSERT  Service_Reset < Service_ResourceFSStarting
        ASSERT  Service_ResourceFSStarting < Service_SCSIAttached
        ASSERT  Service_SCSIAttached < Service_SCSIDetached
        ASSERT  Service_SCSIDetached < Service_BootChoicesVarsSet
        DCD     0
        DCD     ServiceEntry2 - Module_BaseAddr
        DCD     Service_Reset
      [ standalone
        DCD     Service_ResourceFSStarting
      ]
        DCD     Service_SCSIAttached
        DCD     Service_SCSIDetached
        DCD     Service_BootChoicesVarsSet
      [ PartitionManager
        DCD     Service_MorePartitions
      ]  
        DCD     0

;>>>>>>>>>>>>
;ServiceEntry
;>>>>>>>>>>>>

        DCD     ServiceTable - Module_BaseAddr
ServiceEntry
        MOV     R0, R0
        CMP     R1, #Service_Reset
      [ standalone
        CMPNE   R1, #Service_ResourceFSStarting
      ]
        Push    "LR"
        ASSERT  Service_SCSIAttached >= 0x10000
        LDRNE   LR,=Service_SCSIAttached
        CMPNE   R1,LR
        ADDNE   LR,LR,#Service_SCSIDetached - Service_SCSIAttached
        CMPNE   R1,LR
        LDRNE   LR,=Service_BootChoicesVarsSet
        CMPNE   R1,LR
      [ PartitionManager
        LDRNE   LR,=Service_MorePartitions
        CMPNE   R1,LR
      ]
        Pull    "PC",NE
        Pull    "LR"

ServiceEntry2
      [ standalone
        TEQ     R1, #Service_ResourceFSStarting
        BEQ     ServiceResFS
      ]
        Push    "LR"
        LDR     LR, =Service_BootChoicesVarsSet
        TEQ     R1, LR
        BEQ     ServiceChoicesVarsSet
      [ PartitionManager
        LDR     LR, =Service_MorePartitions
        TEQ     R1, LR
        Pull    "LR",EQ
        BEQ     ServiceMorePartitions
      ]
        TEQ     R1, #Service_Reset
        Pull    "LR",NE
        BNE     ServiceAttachDetach
      [ Debug1
        mess    ,"ServiceEntry, Service_Reset",NL
      ]
        Push    "R0-R5,R8"
        getSB
;
;Reservations are lost over reset, so Re-reserve each device/drive with
; a non-zero BlockSize entry
;
        MOV     R5, #0
        sbaddr  R4, BlockSizes
101
        LDRB    LR, [R4, R5]
        TST     LR, #&FF
        BEQ     %FT102
        mapDrvToDevLo R1, R5
        BL      ReserveDevice
102
        ADD     R5, R5, #1              ; Next drive
        CMP     R5, #MaxDriveNo
        BNE     %BT101                  ; Loop until no more drives

        Pull    "R0-R5,R8,PC"

      [ standalone
ServiceResFS
        Push    "R0,LR"
        ADRL    R0, MsgFileResArea
        MOV     LR, PC
        MOV     PC, R2                  ; Re-register with ResourceFS
        Pull    "R0,PC"
      ]

ServiceChoicesVarsSet ROUT
        Push    "R0-R5"                 ; LR already stacked
        ; Check all attached devices against the Hide file
        getSB
        MOV     R3, #MaxDriveNo-1
        sbaddr  R4, BlockSizes
10
        LDRB    LR, [R4, R3]
        TEQ     LR, #&FF
        BEQ     %FT90
        DrvRecPtr R5,R3
        mapDrvToDevLo R1,R3,R5
        BL      CheckDriveAllowed
        BNE     %FT90
        BL      DoDismount
        BLVC    DetachDevice
90
        SUBS    R3, R3, #1
        BGE     %BT10
        Pull    "R0-R5,PC"

DoSwiRetryDiscOp ROUT
        Push    "R8,LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_DiscOp
        Pull    "R8,PC"


DoNulSwi
        MOV     PC,LR


DoSwiDrives ROUT
        Push    "R8,LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_Drives
        Pull    "R8,PC"


DoSwiFreeSpace ROUT
        Push    "R8,LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_FreeSpace
        Pull    "R8,PC"

DoSwiMiscOp ROUT
        Push    "R8,LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_MiscOp
        Pull    "R8,PC"

DoSwiSectorDiscOp ROUT
        Push    "R8,LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_SectorDiscOp
        Pull    "R8,PC"

DoSwiDiscOp64 ROUT
        Push    "R8,LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_DiscOp64
        Pull    "R8,PC"

DoSwiFreeSpace64 ROUT
        Push    "R8,LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_FreeSpace64
        Pull    "R8,PC"

;Retry word = (Retry word BIC R0) EOR (R1 AND R0)
;exit R1 = R1 AND R0
; R2 old value, R3 new value

DoSwiDescribeDisc ROUT
        Push    "R8,LR"
        LDR     R8, FileCorePrivate
        SWI     XFileCore_DescribeDisc
        Pull    "R8,PC"


;
; DoSwiTestReady
; ==============
;
; On entry
;   R1 = Drive number (4..7)
;
; On exit
;   R0 = 0 - Drive NOT present
;   R1 = 1 - Don't know
;   R2 = 2 - Drive present & ready
;
DoSwiTestReady
        Push    "R1,R2,LR"
        SUB     SP,SP,#16
        MOV     R0,#2                           ; DetermineDevice
        mapDrvToDevLo R1, R1                   ; map drive onto device
        MOV     R2,SP
        SWI     XSCSI_Initialise
        ADD     SP,SP,#16

        MOVVS   R0,#1
        MOVVC   R0,#2
        CLRV
        Pull    "R1,R2,PC"

      [ AllowPartitions
; On entry
;   R0 = reason code
;   Reason code:  0 = Sector offset for drive 1 in R1 is in R2
;   R1 = Drive number (0..7)
;   R2 = sector offset to base of image
;        This offset is zero by default. It may be changed by this swi
;        at any time, but changing this value after mounting the disc
;        is usually not wise!
;
;   Reason code:  1 = report SCSIFS disc number
; returns
;   R2 = SCSIFS disc icon (0..7), or -1 if none
;
DoSWIPartitions ROUT
        Push    "R1,R2,LR"
        TEQ     R0, #0                  ; set partition base
        BNE     %ft1
        CMP     R1, #MaxDriveNo-1
        Pull    "R1,R2,PC", HI
        ADD     LR, SB, R1, LSL #2      ; word offset
        STR     R2, [LR, #:INDEX:PartitionBaseAdd-:INDEX:SCSIFSWorkBase] ; remember
        Pull    "R1,R2,PC"
1
        TEQ     R0, #1                 ; report icon used
        BNE     %FT6                   ; report ID and offset for icon

        Push    "R3,R4,R5"
        MOV     R2, #MaxDriveNo-1
        LDR     R5, [SP, #4*4]         ; retrieve R2 off stack
2
        DrvRecPtr R4, R2
        LDRB    R3, [R4, #:INDEX:DevNo]
        TEQ     R3, R1
        BNE     %ft4
        ADD     LR, SB, R2, LSL #2      ; word offset
        LDR     LR, [LR, #:INDEX:PartitionBaseAdd-:INDEX:SCSIFSWorkBase] ;
        TEQ     LR, R5
        BEQ     %ft3                    ; same start sector too
4
        SUBS    R2,R2,#1
        BGE     %bt2
3
        Pull    "R3,R4,R5"
        STR     R2,[R13, #4]            ; update R2 return value
        Pull    "R1,R2,PC"

6
        TEQ     R0, #2                 ; report id & offset for icon
        Pull    "R1,R2,PC",NE

        Push    "R3,R4,R5"

        DrvRecPtr R4, R1
        ADD     LR, SB, R1, LSL #2      ; word offset
        LDRB    R1, [R4, #:INDEX:DevNo]
        LDR     R2, [LR, #:INDEX:PartitionBaseAdd-:INDEX:SCSIFSWorkBase] ;

        Pull    "R3,R4,R5"
        ADD     sp, sp, #4*2            ; forget stored r1 and r2
        Pull    "PC"
      ]

; >>>>>>>>
; SwiEntry
; >>>>>>>>

SwiEntry ROUT
        Push    "SB,LR"
        getSB
        CMPS    R11,#FirstUnusedSwi
        ADRLO   LR, %FT10
        ADDLO   PC, PC, R11,LSL #2
        B       UnknownSwi
05
        B       DoSwiRetryDiscOp
        B       DoNulSwi
        B       DoSwiDrives
        B       DoSwiFreeSpace

        B       DoNulSwi
        B       DoSwiDescribeDisc
        B       DoSwiTestReady
        B       UnknownSwi

        B       UnknownSwi
        B       UnknownSwi
        B       UnknownSwi
        B       UnknownSwi

        B       DoSwiMiscOp
        B       DoSwiSectorDiscOp
        B       UnknownSwi
        B       UnknownSwi

        B       UnknownSwi
        B       UnknownSwi
        B       DoSwiFreeSpace64
        B       UnknownSwi

        B       DoSwiDiscOp64
      [ AllowPartitions
        B       DoSWIPartitions
      |
        B       UnknownSwi
      ]


FirstUnusedSwi  * (.-%BT05)/4

UnknownSwi
        ; SWI out of range: set R0 -> international error block
        Push    "R1"
        ADR     R0,ErrorBlock_ModuleBadSWI
        ADR     R1,SwiNames             ; R1 -> name of this module
        BL      CopyErrorOne
        Pull    "R1"
        ; Fall through

10      TEQ     PC,PC
        Pull    "SB,PC",EQ
        Pull    "SB,LR"
        MOVVCS  PC,LR
        ORRVSS  PC,LR,#V_bit

SwiNames ROUT
        DCB     "SCSIFS",0
        DCB     "DiscOp",0
        DCB     "NOP",0
        DCB     "Drives",0
        DCB     "FreeSpace",0
        DCB     "NOP",0
        DCB     "DescribeDisc",0
        DCB     "TestReady",0
        DCB     "7",0
        DCB     "8",0
        DCB     "9",0
        DCB     "10",0
        DCB     "11",0
        DCB     "MiscOp",0
        DCB     "SectorDiscOp",0
        DCB     "14",0
        DCB     "15",0
        DCB     "16",0
        DCB     "17",0
        DCB     "FreeSpace64",0
        DCB     "19",0
        DCB     "DiscOp64",0
        DCB     "Partitions",0
        DCB     0
        ALIGN

        MakeInternatErrorBlock ModuleBadSWI,,BadSWI

      [ international_help
ihflag  *       International_Help
      |
ihflag  *       0
      ]

ComTab
        Command SCSI,           0, 0, ihflag
      [ DoBuffering
        Command SCSIFSBuffers,  0, 0, ihflag :OR: Status_Keyword_Flag
      ]
        Command SCSIFSDirCache, 0, 0, ihflag :OR: Status_Keyword_Flag
        Command SCSIFSDrive,    0, 0, ihflag :OR: Status_Keyword_Flag
        DCB     0
        ALIGN


; >>>>>>>>>
; SCSI_Code
; >>>>>>>>>

SCSI_Code
        Push    "LR"                    ; NO REENTRANCY CHECK NEEDED
        MOV     R0, #FSControl_SelectFS
        ADRL    R1, CreateTitle         ; >>>RCM was ScsiFsTitle
        SWI     XOS_FSControl
        Pull    "PC"


; CONFIGURE/STATUS HANDLERS

      [ DoBuffering
; >>>>>>>>>>>>>>>>>>
; SCSIFSBuffers_Code
; >>>>>>>>>>>>>>>>>>

ShortConSynSCSIFSBuffers
        DCB     "SCSIFSBuffers <D>",0
        ALIGN

SCSIFSBuffers_Code ROUT
        Push    "R0-R6,SB,LR"
        getSB
        MOVS    R1, R0
        BNE     %FT05

; print syntax message
        ADR     R0, ShortConSynSCSIFSBuffers
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        B       ConfigReturn

05
        TEQS    R1, #1
        BNE     %FT15

; print status message
        BL      ReadFileCMOS            ; (->R0,R5,V)
        BVS     ConfigReturn
        SWI     XOS_WriteS
        DCB     "SCSIFSBuffers", 0
        ALIGN
        BVS     ConfigReturn
10
        MOV     R0, R5
        BL      WrDec                   ; (R0->R0,V)
        SWIVC   XOS_NewLine             ; (->R0,V)
        B       ConfigReturn

; parse configure
15
        MOV     R0, #10 :OR: bit31 :OR: bit30
        SWI     XOS_ReadUnsigned        ; (R0-R2->R0-R2,V)
        BVS     ConfigReturn
        MOV     R1, #FileCMOS
        B       ConWrite
      ]


; >>>>>>>>>>>>>>>>>>>
; SCSIFSDirCache_Code
; >>>>>>>>>>>>>>>>>>>

ShortConSynSCSIFSDirCache
        DCB     "SCSIFSDirCache <D>[K]",0
        ALIGN

SCSIFSDirCache_Code ROUT
        Push    "R0-R6,SB,LR"
        getSB
        MOVS    R1, R0
        BNE     %FT05

; print syntax message
        ADR     R0, ShortConSynSCSIFSDirCache
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        B       ConfigReturn

05
        TEQS    R1, #1
        BNE     %FT15

; print status message
        BL      ReadDirCMOS             ; (->R0,R4,V)
        BVS     ConfigReturn
        SWI     XOS_WriteS
        DCB     "SCSIFSDirCache", 0
        ALIGN
        BVS     ConfigReturn
10
        MOV     R0, R4, LSR #10
        BL      WrDec                   ; (R0->R0,V)
        MOVVC   R0, #"K"
        SWIVC   XOS_WriteC
        SWIVC   XOS_NewLine             ; (->R0,V)
        B       ConfigReturn

; parse configure
15
        MOV     R0, #10 :OR: bit30
        SWI     XOS_ReadUnsigned        ; (R0-R2->R0-R2,V)
        BVS     ConfigReturn
        MOV     R1, #DirCMOS
        B       ConWrite

; >>>>>>>>>>>>>>>>
; SCSIFSDrive_Code
; >>>>>>>>>>>>>>>>

ShortConSynSCSIFSDrive
        DCB     "SCSIFSDrive <D>",0
        ALIGN

SCSIFSDrive_Code ROUT
        Push    "R0-R6,SB,LR"
        getSB
        MOVS    R1, R0
        BNE     %FT05

; print syntax message
        ADR     R0, ShortConSynSCSIFSDrive
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        B       ConfigReturn

05
        BL      ReadCMOSflags           ; (->R0,R2,R4,R5,V)
        BVS     ConfigReturn
        TEQS    R1, #1
        BNE     %FT15

; print status message
        SWI     XOS_WriteS
        DCB     "SCSIFSDrive", 0
        ALIGN
        BVS     ConfigReturn
10
        MOV     R0, R5
        BL      WrDec                   ; (R0->R0,V)
        SWIVC   XOS_NewLine             ; (->R0,V)
        B       ConfigReturn

; parse configure
15
        BIC     R2, R2, #2_00111000                     ; clear old bits
        BL      ParseAnyDrive           ; (R1->R0,R1,V)
        BVS     ConfigReturn
        ORR     R2, R2, R0, LSL #3      ; form new byte
        MOV     R1, #CMOSflags
        B       ConWrite

ConWrite
        MOV     R0, #OsByte_WriteCMOS
        SWI     XOS_Byte                ; (R0-R2->R0-R2,V)
ConfigReturn
        STRVS   R0, [SP]
        Pull    "R0-R6,SB,PC"

        END
@


4.16
log
@  Extended SCSIFS_Partitions SWI reason 1 to be fully aware of partitions
Detail:
  Reason 1 did not check whether the given partition offset matched, so did not
  differentiate between different partitions on a disc
Admin:
  tested on iMx6

Version 1.34. Tagged as 'SCSIFS-1_34'
@
text
@d472 3
a474 2
        TEQ     R0, #1                  ; report icon used
        Pull    "R1,R2,PC",NE
d494 15
@


4.15
log
@  Altered interaction with PartMan. PartMan now tells SCSIFS when it can
  attempt to mount a newly connected disc.
Detail:
  In order to be certain that the partition table has been fully analysed
  before SCSIFS attempts to mount a newly connected disc, if Partman is
  detected, SCSIFS waits for a service call from PartMan before it attempts
  to mount any partitions on the disc. If PartMan interaction is not compiled,
  in, or PartMan is not detected, SCSIFS behaviour is unaltered.
Admin:
 tested on iMx6

Version 1.33. Tagged as 'SCSIFS-1_33'
@
text
@d474 1
a474 1
        Push    "R3,R4"
d476 1
d481 6
a486 1
        BEQ     %ft3
d490 1
a490 1
        Pull    "R3,R4"
@


4.14
log
@Make 'Hide' file feature more useful when SCSIFS in ROM
Detail:
  s/ScsiFs05, s/ScsiFs50 - Listen out for Service_BootChoicesVarsSet and use it as a trigger to check for any devices which should be hidden by the Hide file. This ensures that devices which are detected prior to the boot sequence starting will get Hide-processed
Admin:
  Tested on Raspberry Pi
  Partially resolves ticket #309 (there's still the problem that a multi-card reader could use up all available drive numbers during ROM init, preventing the boot drive from mounting)


Version 1.32. Tagged as 'SCSIFS-1_32'
@
text
@d260 3
d284 4
d300 6
@


4.13
log
@Strip some old code and options
Detail:
  Since we only really care about the RISC OS 5 version of this module, there are various old switches stretching back 20+ years which can be removed to make the sources a bit easier on the eye:
  * OpticalMemorySupport (-> {TRUE})
  * IgnoreRecoveredError (-> {TRUE})
  * FloppySupport (-> {TRUE})
  * MediaLocking (-> {TRUE})
  * BigDisc (-> {TRUE})
  * AutoDetect (-> {TRUE})
  * HotPlug (-> {TRUE})
  Files changed:
  HelpText, hdr/mymacros, s/Fixes, s/Hdr_fst, s/ScsiFs00, s/ScsiFs05, s/ScsiFs15, s/ScsiFs20, s/ScsiFs50
Admin:
  Resulting binary unchanged (for default options, at least)


Version 1.29. Not tagged
@
text
@d250 1
d259 1
d279 2
d289 4
d294 1
d299 1
a299 1
        Push    "R0-R5,R8,LR"
d329 21
@


4.12
log
@Tidy things up a bit
Detail:
  s/ScsiFs00, ScsiFs05, ScsiFs15, ScsiFs20, ScsiFs50 - Add comments for some of the different IDs which are used. Add MaxDriveNo constant, and make use of it where appropriate. Make BlockSizes non-braindead.
Admin:
  Cosmetic changes only, binary unchanged.


Version 1.29. Not tagged
@
text
@a57 1
    [ HotPlug
a82 1
    ]
a83 1
      [ FloppySupport
a99 17
      |
        ASSERT  MaxDriveNo = 8
        MOV     R0, #0
        STR     R0, BlockSizes+4
      ]

      [ AutoDetect:LAND:{FALSE}
        sbaddr  R0, DrvRecs
        MOV     R2, #0
10
        EOR     R14, R2, #4             ; original behaviour: device = drive EOR 4
        STDevNo R14, R0, R3
        ADD     R0, R0, #SzDrvRec
        ADD     R2, R2, #1
        CMP     R2, #8
        BLO     %BT10
      ]
a107 1
      [ AutoDetect
a108 2
      ]
      [ HotPlug
a110 2
      ]
      [ FloppySupport
a111 1
      ]
a117 1
      [ FloppySupport
a118 3
      |
        MOV     R3, R5, LSL #16
      ]
a128 1
      [ BigDisc
a129 4
      |
        BL      ReadMapSizeCMOS         ; (->R0,R6,V)
        STR     R6, MapSizes            ; Map sizes for ScsiFs::4..7
      ]
a136 1
      [ BigDisc
a146 1
      ]
a166 1
      [ HotPlug
a175 1
      ]
a186 1
      [ HotPlug
a189 1
      ]
a193 1
      [ MediaLocking
a194 1
      ]
a255 1
      [ HotPlug
a257 1
      ]
a270 1
      [ HotPlug
a278 3
      |
        MOVNE   PC, LR
      ]
a284 1
      [ HotPlug
a286 1
      ]
a291 1
      [ {TRUE}
a307 5
      |
        ASSERT  MaxDriveNo = 8
        MOV     R0, #0                  ; Reservation lost over reset, force 'Examine'
        STR     R0, BlockSizes+4        ; on next access
      ]
a349 1
      [ BigDisc
a366 1
      ]
a473 1
      [ BigDisc
a483 12
      |
        B       UnknownSwi
        B       UnknownSwi
        B       UnknownSwi

        B       UnknownSwi
        B       UnknownSwi
        B       UnknownSwi
        B       UnknownSwi

        B       UnknownSwi
      ]
a548 6
    [ :LNOT:HotPlug
      [ FloppySupport
        Command SCSIFSFloppies, 0, 0, ihflag :OR: Status_Keyword_Flag
      ]
        Command SCSIFSDiscs,    0, 0, ihflag :OR: Status_Keyword_Flag
    ]
a708 100
    [ :LNOT:HotPlug
      [ FloppySupport
; >>>>>>>>>>>>>>>>>>>
; SCSIFSFloppies_Code
; >>>>>>>>>>>>>>>>>>>

ShortConSynSCSIFSFloppies
        DCB     "SCSIFSFloppies   <D>",0
        ALIGN

SCSIFSFloppies_Code ROUT
        Push    "R0-R6,SB,LR"
        getSB
        MOVS    R1, R0
        BNE     %FT05

; print syntax message
        ADR     R0, ShortConSynSCSIFSFloppies
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        B       ConfigReturn

05
        BL      ReadCMOSflags           ; (->R0,R2,R4,R5,V)
        BVS     ConfigReturn
        TEQS    R1, #1
        BNE     %FT15

; print status message
        SWI     XOS_WriteS
        DCB     "SCSIFSFloppies  ", 0
        ALIGN
        BVS     ConfigReturn
10
        MOV     R0, R3
        BL      WrDec                   ; (R0->R0,V)
        SWIVC   XOS_NewLine             ; (->R0,V)
        B       ConfigReturn

; parse configure
15
        BIC     R3, R2, #2_11000000                     ; clear old bits
        MOV     R0, #10 :OR: bit31 :OR: bit29
        MOV     R2, #4
        SWI     XOS_ReadUnsigned        ; (R0-R2->R0-R2,V)
        BVS     ConfigReturn
        ORR     R2, R3, R2, LSL #6      ; form new byte
        MOV     R1, #CMOSflags
        B       ConWrite
      ]


; >>>>>>>>>>>>>>>>
; SCSIFSDiscs_Code
; >>>>>>>>>>>>>>>>

ShortConSynSCSIFSDiscs
        DCB     "SCSIFSDiscs <D>",0
        ALIGN

SCSIFSDiscs_Code ROUT
        Push    "R0-R6,SB,LR"
        getSB
        MOVS    R1, R0
        BNE     %FT05

; print syntax message
        ADR     R0, ShortConSynSCSIFSDiscs
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        B       ConfigReturn

05
        BL      ReadCMOSflags           ; (->R0,R2,R4,R5,V)
        BVS     ConfigReturn
        TEQS    R1, #1
        BNE     %FT15

; print status message
        SWI     XOS_WriteS
        DCB     "SCSIFSDiscs", 0
        ALIGN
        BVS     ConfigReturn
10
        MOV     R0, R4
        BL      WrDec                   ; (R0->R0,V)
        SWIVC   XOS_NewLine             ; (->R0,V)
        B       ConfigReturn

; parse configure
15
        BIC     R3, R2, #2_00000111                     ; clear old bits
        MOV     R0, #10 :OR: bit31 :OR: bit29
        MOV     R2, #4
        SWI     XOS_ReadUnsigned        ; (R0-R2->R0-R2,V)
        BVS     ConfigReturn
        ORR     R2, R3, R2              ; form new byte
        MOV     R1, #CMOSflags
    ]                                   ; :LNOT:HotPlug

@


4.11
log
@Internationalised
In addition
 - simplify WrDec to just use OS_ConvertCardinal1 hence not need a division routine
 - change the Hide check to at least use Choices: correctly, if you must
 - macros Text and baddr eliminated

Tested in an OMAP3 ROM build.

Version 1.28. Tagged as 'SCSIFS-1_28'
@
text
@d65 1
d88 3
a90 2
        STR     R2, Padding             ; >>>>Init floppy BlockSizes
        STR     R2, BlockSizes          ; Block (sector size) for ScsiFs::4..7
d104 1
d106 1
a106 1
        STR     R0, BlockSizes
d224 1
a224 1
        sbaddr  R7, BlockSizes-4
d244 1
a244 1
        CMP     R5, #8
d349 1
a349 1
        sbaddr  R4, BlockSizes-4
d358 1
a358 1
        CMP     R5, #8
d361 1
d363 1
a363 1
        STR     R0, BlockSizes          ; on next access
d482 1
a482 1
        CMP     R1, #7
d491 1
a491 1
        MOV     R2, #7
@


4.10
log
@Sources lined up to be more readable
One pass through AsmTidy, then a manual inspection.
Builds binary identical version. No tagged.
@
text
@d23 4
a26 4
        DCD     CreateTitle             ; >>>RCM was ScsiFsTitle
        DCD     ScsiFsBootText
        DCD     LowLevelEntry
        DCD     MiscEntry
d118 6
d162 2
a163 2
        baddr   R0, FSCreateBlock
        baddr   R1, org
d216 1
a216 1
        baddr   R1, DieTitle                    ; open files before dying
d245 13
a257 1
        MOVVS   R9, R0
d287 3
d291 1
a291 1
        DCD     ServiceEntry2
d293 3
d306 1
a306 1
        DCD     ServiceTable
d310 3
d327 4
d362 1
a362 2
        Pull    "R0-R5,R8,LR"
        MOV     PC, LR
d364 8
d561 9
a575 17
UnknownSwi
; SWI out of range: set R0 -> international error block

        Push    "R1-R7"

        ADR     R0,BadSWIErrBlk         ; R0 -> error block
        MOV     R1,#0
        MOV     R2,#0
        ADR     R4,SwiNames             ; R4 -> parameter to substitute
        MOV     R5,#0
        MOV     R6,#0
        MOV     R7,#0
        SWI     XMessageTrans_ErrorLookup

        Pull    "R1-R7"
        B       %BT10

d603 1
a603 1
BadSWIErrBlk            MakeErrorBlock          ModuleBadSWI
d605 5
a609 26
FsCom   bit     (31-24)

        MACRO
        ComEntry $Com,$MinArgs,$MaxArgs,$GsTransBits,$HiBits
        ASSERT  $MinArgs<=$MaxArgs
Com$Com DCB     "$Com",0
        ALIGN
        DCD     Do$Com
        =       $MinArgs
        =       $GsTransBits
        =       $MaxArgs
        =       $HiBits
        DCD     Syn$Com
        DCD     Help$Com
        MEND


        MACRO
        Config  $Com
        DCB     "$Com",0
        ALIGN
        DCD     Con$Com
        DCD     bit30
        DCD     0
        DCD     ConHelp$Com
        MEND
d611 2
a612 4
ComTab                                  ;general star commands
        ComEntry SCSI,          0,0,0,0
        ;filing system star commands
        ;status/configure optioms
d614 1
a614 1
        Config  SCSIFSbuffers
d616 1
a616 1
        Config  SCSIFSDirCache
d619 1
a619 1
        Config  SCSIFSFloppies
d621 1
a621 1
        Config  SCSIFSdiscs
d623 1
a623 2
        Config  SCSIFSdrive

d628 3
a630 3
; >>>>>>
; DoSCSI
; >>>>>>
d632 1
a632 1
DoSCSI
d635 1
a635 1
        baddr   R1, CreateTitle         ; >>>RCM was ScsiFsTitle
d643 3
a645 3
; >>>>>>>>>>>>>>>>
; ConSCSIFSbuffers
; >>>>>>>>>>>>>>>>
d647 2
a648 2
ShortConSynSCSIFSbuffers
        DCB     "SCSIFSbuffers <D>",0
d651 1
a651 1
ConSCSIFSbuffers
d658 1
a658 1
        baddr   R0, ShortConSynSCSIFSbuffers
d671 2
a672 1
        Text    "SCSIFSbuffers"
d690 3
a692 3
; >>>>>>>>>>>>>>>>>
; ConSCSIFSDirCache
; >>>>>>>>>>>>>>>>>
d698 1
a698 1
ConSCSIFSDirCache
d705 1
a705 1
        baddr   R0, ShortConSynSCSIFSDirCache
d718 2
a719 1
        Text    "SCSIFSDirCache"
d737 6
a742 2
ShortConSynSCSIFSdrive
        DCB     "SCSIFSdrive <D>",0
d745 1
a745 5
; >>>>>>>>>>>>>>
; ConSCSIFSdrive
; >>>>>>>>>>>>>>

ConSCSIFSdrive ROUT
d752 1
a752 1
        baddr   R0, ShortConSynSCSIFSdrive
d765 2
a766 1
        Text    "SCSIFSDrive"
d785 3
a787 3
; >>>>>>>>>>>
; ConSCSIFSFloppies
; >>>>>>>>>>>
d793 1
a793 1
ConSCSIFSFloppies ROUT
d800 1
a800 1
        baddr   R0, ShortConSynSCSIFSFloppies
d813 2
a814 1
        Text    "SCSIFSFloppies  "
d835 3
a837 3
; >>>>>>>>>>>>>>
; ConSCSIFSdiscs
; >>>>>>>>>>>>>>
d839 2
a840 2
ShortConSynSCSIFSdiscs
        DCB     "SCSIFSdiscs <D>",0
d843 1
a843 1
ConSCSIFSdiscs ROUT
d850 1
a850 1
        baddr   R0, ShortConSynSCSIFSdiscs
d863 2
a864 1
        Text    "SCSIFSdiscs"
@


4.9
log
@Minor cleanups
* Upcall and OsByte symbols used from central headers
* T and F swapped for ObjAsm built in variables
* Deleted some unused CPU and hardware definitions
* Put unused files in the attic
Tested briefly, still worked.

Version 1.27. Tagged as 'SCSIFS-1_27'
@
text
@d17 1
a17 1
 TTL    "Initialisation and FS star commands"
d20 7
a26 7
 =      EjectBit+CreateFlag_FixedDiscPollChangeSupport
 =      (CreateFlag_DriveStatusWorks:SHR:8)+(BigBit:SHR:8)+(NewErrorBit:SHR:8)
 =      0,fsnumber_SCSIFS
 &      CreateTitle             ;>>>RCM was ScsiFsTitle
 &      ScsiFsBootText
 &      LowLevelEntry
 &      MiscEntry
d33 19
a51 19
 [ Debug1
   mess ,"InitEntry - In",NL
 ]
 Push   "R7-R11,SB,LR"
 MOV    R10,#1          ;init flag
 MOV    R11,R12

 MOV    R0, #ModHandReason_Claim
 MOV    R3, #:INDEX: WorkSize
 SWI    XOS_Module              ;claim workspace
 BVS    %FT95

 MOV    SB, R2
 STR    SB, [R11]

 [ UseSpecialScatterBlk
 ADR    R0, PaddingBlock
 MOV    R1, #0
 MOV    R2, #?PaddingBlock
d53 56
a108 56
 SUBS   R2, R2, #4
 STR    R1, [R0], #4
 BNE    %BT05
 ]

 [ HotPlug
 sbaddr R0, DrvRecs
 MOV    R1, #(-1:SHL:8)
 MOV    R2, #0
 STRB   R2, AttCBCount
 STRB   R2, DetCBCount
 STRB   R2, Dieing
 [ AllowPartitions
 STR    R2, PartitionBaseAdd
 STR    R2, PartitionBaseAdd+4
 STR    R2, PartitionBaseAdd+8
 STR    R2, PartitionBaseAdd+12
 STR    R2, PartitionBaseAdd+16
 STR    R2, PartitionBaseAdd+20
 STR    R2, PartitionBaseAdd+24
 STR    R2, PartitionBaseAdd+28
 ]
 STMIA  R0!, {R1,R2}            ;Drive rec for ScsiFs::0
 STMIA  R0!, {R1,R2}            ;                      1
 STMIA  R0!, {R1,R2}            ;                      2
 STMIA  R0!, {R1,R2}            ;                      3
 STMIA  R0!, {R1,R2}            ;                      4
 STMIA  R0!, {R1,R2}            ;                      5
 STMIA  R0!, {R1,R2}            ;                      6
 STMIA  R0!, {R1,R2}            ;                      7
 ]

 [ FloppySupport
 MOV    R2, #0
 STR    R2, Padding  ;>>>>Init floppy BlockSizes
 STR    R2, BlockSizes          ;Block (sector size) for ScsiFs::4..7

 ASSERT DrvFlags = 0
 ASSERT DevNo = 1
 ASSERT DrvSequenceNum = 4
 ASSERT SzDrvRec = 8
 sbaddr R0, DrvRecs
 MOV    R1, #LostUnitAtn :OR: (-1:SHL:8)
 MOV    R2, #0
 STMIA  R0!, {R1,R2}            ;Drive rec for ScsiFs::0
 STMIA  R0!, {R1,R2}            ;                      1
 STMIA  R0!, {R1,R2}            ;                      2
 STMIA  R0!, {R1,R2}            ;                      3
 |
 MOV    R0, #0
 STR    R0, BlockSizes
 ]

 [ AutoDetect:LAND:{FALSE}
 sbaddr R0, DrvRecs
 MOV    R2, #0
d110 20
a129 20
 EOR    R14, R2, #4             ; original behaviour: device = drive EOR 4
 STDevNo R14, R0, R3
 ADD    R0, R0, #SzDrvRec
 ADD    R2, R2, #1
 CMP    R2, #8
 BLO    %BT10
 ]

 BL     ReadCMOSflags           ;(->R0,R2,R3,R4,R5,V) read #floppies & winnies
 [ AutoDetect
 BL     ScanDrives
 ]
 [ HotPlug
 MOV    R3, #4
 MOV    R4, #4
 ]
 [ FloppySupport
 STRB   R3, Floppies
 ]
 STRB   R4, Winnies
d135 44
a178 44
 [ FloppySupport
 ORR    R3, R3, R5, LSL #16     ;Combine floppy count and default drive
 |
 MOV    R3, R5, LSL #16
 ]
 ORR    R3, R3, R4, LSL #8      ;OR in number of drives
 BL     ReadDirCMOS             ;(->R0,R4,V)
 BL     ReadFileCMOS            ;(->R0,R5,V)

 [ DoBuffering
        ASSERT F,"Read ahead/write behind NOT supported"
 |
 MOV R5,#0 ;NO background Xfers
 ]

 [ BigDisc
 MVN    R6, #0
 |
 BL     ReadMapSizeCMOS         ;(->R0,R6,V)
 STR    R6, MapSizes            ;Map sizes for ScsiFs::4..7
 ]
 baddr  R0, FSCreateBlock
 baddr  R1, org
 MOV    R2, R11
 SWI    XFileCore_Create        ;(R0-R6->R0-R2,V)
 BVS    %FT85
 STR    R0, FileCorePrivate
 STR    R2, WinnieCallAfter
 [ BigDisc
 MOV    R8, R0
 MOV    R0, #6
 SWI    XFileCore_MiscOp        ;(R0,R8->R0,V)
 MOVVC  R7, #FC_Big
 MOVVS  R7, #0
 SWI    XFileCore_Features
 SUBVSS R0, R0, R0              ;R0=0, V cleared
 TST    R0, #Feature_NewErrors
 ORRNE  R7, R7, #FC_NewErrors
 STR    R7, FCFeatures
 ]
 [ Debug1
   mess ,"InitEntry - Out",NL
 ]
 Pull   "R7-R11,SB,PC"
d180 1
a180 1
 LTORG
d189 14
a202 14
 [ Debug1
   mess ,"DieEntry",NL
 ]
 Push   "R7-R11,SB,LR"
 getSB

 [ HotPlug
 MOV    R0, #1
 STRB   R0, Dieing                      ; prevent any further callbacks
 LDRB   R0, AttCBCount
 TEQ    R0, #0
 LDREQB R0, DetCBCount
 TEQ    R0, #0
 BEQ    %ft1                            ; none awaited
d205 1
a205 1
 ]
d208 5
a212 5
 MOV    R10,#0                          ;Delete "FileCore%SCSI"
 MOV    R0, #ModHandReason_Delete       ; filecore will close down all
 baddr  R1, DieTitle                    ; open files before dying
 SWI    XOS_Module                      ;
 MOVVS  R9, R0
d214 2
a215 2
 MOV    R5, #0
 sbaddr R7, BlockSizes-4
d217 15
a231 15
 [ HotPlug
 MOV    R0, #UpCall_DriveRemoved
 MOV    R1, R5
 BL     UpcallDrive
 ]
 LDRB   R4, [R7, R5]
 TST    R4, #&FF
 BEQ    %FT02
 mapDrvToDevLo R1, R5
 [ MediaLocking
 BL     UnLockMedia
 ]
 MOV    R0, #2                  ;RC for ReleaseDevice
 MOV    R8, R12                 ;Access key
 SWI    XSCSI_Reserve
d233 4
a236 4
 MOVVS  R9, R0
 ADD    R5, R5, #1              ;Next drive
 CMP    R5, #8
 BNE    %BT01                   ;Loop until no more drives
d239 8
a246 8
 MOVVS  R9, R0
 MOV    R0, #ModHandReason_Free
 MOV    R2, SB
 SWI    XOS_Module          ;Free workspace
 [ Dev
 wrhex  R0, VS
 mess   VS,"Heap error",NL
 ]
d248 17
a264 17
 MOVVS  R9, R0
 [ Dev
 wrhex  R10,VS
 wrhex  R0, VS
 mess   VS,"Error",NL
 ]

 ADDS   R0, R9, #0
 ADDNES R10,R10,#0       ;only error on init (R10=0/1 for Die/Init)
 Pull   "R7-R11,SB,PC",EQ

 BL     SetV
 [ Dev
 wrhex  R0
 mess   ,"ScsiFs Init Error",NL
 ]
 Pull   "R7-R11,SB,PC"
d266 1
a266 1
 LTORG
d269 8
a276 8
 DCD    0
 DCD    ServiceEntry2
 DCD    Service_Reset
 [ HotPlug
 DCD    Service_SCSIAttached
 DCD    Service_SCSIDetached
 ]
 DCD    0
d282 1
a282 1
 DCD    ServiceTable
d284 14
a297 14
 MOV    R0, R0
 CMP    R1, #Service_Reset
 [ HotPlug
 Push   "LR"
 ASSERT Service_SCSIAttached >= 0x10000
 LDRNE  LR,=Service_SCSIAttached
 CMPNE  R1,LR
 ADDNE  LR,LR,#Service_SCSIDetached - Service_SCSIAttached
 CMPNE  R1,LR
 Pull   "PC",NE
 Pull   "LR"
 |
 MOVNE  PC, LR
 ]
d300 10
a309 10
 [ HotPlug
 TEQ    R1, #Service_Reset
 BNE    ServiceAttachDetach
 ]
 [ Debug1
   mess ,"ServiceEntry, Service_Reset",NL
 ]
 Push   "R0-R5,R8,LR"
 getSB
 [ {TRUE}
d314 2
a315 2
 MOV    R5, #0
 sbaddr R4, BlockSizes-4
d317 5
a321 5
 LDRB   LR, [R4, R5]
 TST    LR, #&FF
 BEQ    %FT102
 mapDrvToDevLo R1, R5
 BL     ReserveDevice
d323 7
a329 7
 ADD    R5, R5, #1              ;Next drive
 CMP    R5, #8
 BNE    %BT101                  ;Loop until no more drives
 |
 MOV    R0, #0                  ;Reservation lost over reset, force 'Examine'
 STR    R0, BlockSizes          ; on next access
 ]
d331 2
a332 2
 Pull   "R0-R5,R8,LR"
 MOV    PC, LR
d336 4
a339 4
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_DiscOp
 Pull   "R8,PC"
d343 1
a343 1
 MOV    PC,LR
d347 4
a350 4
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_Drives
 Pull   "R8,PC"
d354 4
a357 4
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_FreeSpace
 Pull   "R8,PC"
d360 4
a363 4
 Push    "R8,LR"
 LDR     R8, FileCorePrivate
 SWI     XFileCore_MiscOp
 Pull    "R8,PC"
d365 1
a365 1
 [ BigDisc
d367 4
a370 4
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_SectorDiscOp
 Pull   "R8,PC"
d373 4
a376 4
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_DiscOp64
 Pull   "R8,PC"
d379 5
a383 5
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_FreeSpace64
 Pull   "R8,PC"
 ]
d390 4
a393 4
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_DescribeDisc
 Pull   "R8,PC"
d409 12
a420 12
 Push   "R1,R2,LR"
 SUB    StkPtr,StkPtr,#16
 MOV    R0,#2                           ;DetermineDevice
 mapDrvToDevLo R1, R1                   ;map drive onto device
 MOV    R2,StkPtr
 SWI    XSCSI_Initialise
 ADD    StkPtr,StkPtr,#16

 MOVVS  R0,#1
 MOVVC  R0,#2
 CLRV
 Pull   "R1,R2,PC"
d422 1
a422 1
 [  AllowPartitions
d431 1
a431 1
;    
d437 8
a444 8
 Push   "R1,R2,LR"
 TEQ    R0, #0              ; set partition base
 BNE    %ft1
 CMP    R1, #7
 Pull   "R1,R2,PC", HI
 ADD    LR, SB, R1, LSL #2  ; word offset
 STR    R2, [LR, #:INDEX:PartitionBaseAdd-:INDEX:SCSIFSWorkBase] ; remember 
  Pull   "R1,R2,PC"
d446 11
a456 11
 TEQ    R0, #1              ; report icon used
 Pull   "R1,R2,PC",NE
 Push   "R3,R4" 
 MOV    R2, #7
2 
 DrvRecPtr  R4, R2
 LDRB   R3, [R4, #:INDEX:DevNo]
 TEQ    R3, R1
 BEQ    %ft3
 SUBS   R2,R2,#1
 BGE    %bt2
d458 4
a461 4
 Pull   "R3,R4"
 STR     R2,[R13, #4]  ; update R2 return value
 Pull   "R1,R2,PC"
 ]
d468 6
a473 6
 Push   "SB,LR"
 getSB
 CMPS   R11,#FirstUnusedSwi
 ADRLO  LR, %FT10
 ADDLO  PC, PC, R11,LSL #2
 B      UnknownSwi
d475 45
a519 45
 B      DoSwiRetryDiscOp
 B      DoNulSwi
 B      DoSwiDrives
 B      DoSwiFreeSpace

 B      DoNulSwi
 B      DoSwiDescribeDisc
 B      DoSwiTestReady
 B      UnknownSwi

 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi

 B      DoSwiMiscOp
 [ BigDisc
 B      DoSwiSectorDiscOp
 B      UnknownSwi
 B      UnknownSwi

 B      UnknownSwi
 B      UnknownSwi
 B      DoSwiFreeSpace64
 B      UnknownSwi

 B      DoSwiDiscOp64
 |
 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi

 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi

 B      UnknownSwi
 ]
 [ AllowPartitions
 B      DoSWIPartitions
 |
 B      UnknownSwi
 ]
 
d547 25
a571 25
 = "SCSIFS",0
 = "DiscOp",0
 = "NOP",0
 = "Drives",0
 = "FreeSpace",0
 = "NOP",0
 = "DescribeDisc",0
 = "TestReady",0
 = "7",0
 = "8",0
 = "9",0
 = "10",0
 = "11",0
 = "MiscOp",0
 = "SectorDiscOp",0
 = "14",0
 = "15",0
 = "16",0
 = "17",0
 = "FreeSpace64",0
 = "19",0
 = "DiscOp64",0
 = "Partitions",0
 = 0
 ALIGN
d577 3
a579 3
 MACRO
 ComEntry $Com,$MinArgs,$MaxArgs,$GsTransBits,$HiBits
 ASSERT $MinArgs<=$MaxArgs
d581 20
a600 20
 ALIGN
 DCD    Do$Com
 =       $MinArgs
 =       $GsTransBits
 =       $MaxArgs
 =       $HiBits
 DCD    Syn$Com
 DCD    Help$Com
 MEND


 MACRO
 Config $Com
 DCB    "$Com",0
 ALIGN
 DCD    Con$Com
 DCD    bit30
 DCD    0
 DCD    ConHelp$Com
 MEND
d603 14
a616 14
 ComEntry SCSI,          0,0,0,0
                                        ;filing system star commands
                                        ;status/configure optioms
 [ DoBuffering
 Config SCSIFSbuffers
 ]
 Config SCSIFSDirCache
 [ :LNOT:HotPlug
 [ FloppySupport
 Config SCSIFSFloppies
 ]
 Config SCSIFSdiscs
 ]
 Config SCSIFSdrive
d618 2
a619 2
 =      0
 ALIGN
d627 5
a631 5
 Push   "LR"             ; NO REENTRANCY CHECK NEEDED
 MOV    R0, #FscSelectFs
 baddr  R1, CreateTitle         ;>>>RCM was ScsiFsTitle
 SWI    XOS_FSControl
 Pull   "PC"
d636 1
a636 1
 [ DoBuffering
d642 2
a643 2
 = "SCSIFSbuffers <D>",0
 ALIGN
d646 4
a649 4
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05
d652 4
a655 4
 baddr  R0, ShortConSynSCSIFSbuffers
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn
d658 2
a659 2
 TEQS   R1, #1
 BNE    %FT15
d662 5
a666 5
 BL     ReadFileCMOS    ;(->R0,R5,V)
 BVS    ConfigReturn
 SWI    XOS_WriteS
 Text   "SCSIFSbuffers"
 BVS    ConfigReturn
d668 4
a671 4
 MOV    R0, R5
 BL     WrDec           ;(R0->R0,V)
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn
d675 6
a680 6
 MOV    R0, #10 :OR: bit31 :OR: bit30
 SWI    XOS_ReadUnsigned        ;(R0-R2->R0-R2,V)
 BVS    ConfigReturn
 MOV    R1, #FileCMOS
 B      ConWrite
 ]
d688 2
a689 2
 = "SCSIFSDirCache <D>[K]",0
 ALIGN
d692 4
a695 4
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05
d698 4
a701 4
 baddr  R0, ShortConSynSCSIFSDirCache
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn
d704 2
a705 2
 TEQS   R1, #1
 BNE    %FT15
d708 5
a712 5
 BL     ReadDirCMOS    ;(->R0,R4,V)
 BVS    ConfigReturn
 SWI    XOS_WriteS
 Text   "SCSIFSDirCache"
 BVS    ConfigReturn
d714 6
a719 6
 MOV    R0, R4, LSR #10
 BL     WrDec           ;(R0->R0,V)
 MOVVC  R0, #"K"
 SWIVC  XOS_WriteC
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn
d723 5
a727 5
 MOV    R0, #10 :OR: bit30
 SWI    XOS_ReadUnsigned        ;(R0-R2->R0-R2,V)
 BVS    ConfigReturn
 MOV    R1, #DirCMOS
 B      ConWrite
d730 2
a731 2
 = "SCSIFSdrive <D>",0
 ALIGN
d738 4
a741 4
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05
d744 4
a747 4
 baddr  R0, ShortConSynSCSIFSdrive
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn
d750 4
a753 4
 BL     ReadCMOSflags   ;(->R0,R2,R4,R5,V)
 BVS    ConfigReturn
 TEQS   R1, #1
 BNE    %FT15
d756 3
a758 3
 SWI    XOS_WriteS
 Text   "SCSIFSDrive"
 BVS    ConfigReturn
d760 4
a763 4
 MOV    R0, R5
 BL     WrDec           ;(R0->R0,V)
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn
d767 6
a772 6
 BIC    R2, R2, #2_00111000                     ;clear old bits
 BL     ParseAnyDrive           ;(R1->R0,R1,V)
 BVS    ConfigReturn
 ORR    R2, R2, R0, LSL #3      ;form new byte
 MOV    R1, #CMOSflags
 B      ConWrite
d774 2
a775 2
 [ :LNOT:HotPlug
 [ FloppySupport
d781 2
a782 2
 = "SCSIFSFloppies   <D>",0
 ALIGN
d785 4
a788 4
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05
d791 4
a794 4
 baddr  R0, ShortConSynSCSIFSFloppies
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn
d797 4
a800 4
 BL     ReadCMOSflags    ;(->R0,R2,R4,R5,V)
 BVS    ConfigReturn
 TEQS   R1, #1
 BNE    %FT15
d803 3
a805 3
 SWI    XOS_WriteS
 Text   "SCSIFSFloppies  "
 BVS    ConfigReturn
d807 4
a810 4
 MOV    R0, R3
 BL     WrDec           ;(R0->R0,V)
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn
d814 9
a822 9
 BIC    R3, R2, #2_11000000                     ;clear old bits
 MOV    R0, #10 :OR: bit31 :OR: bit29
 MOV    R2, #4
 SWI    XOS_ReadUnsigned        ;(R0-R2->R0-R2,V)
 BVS    ConfigReturn
 ORR    R2, R3, R2, LSL #6      ;form new byte
 MOV    R1, #CMOSflags
 B      ConWrite
 ]
d830 2
a831 2
 = "SCSIFSdiscs <D>",0
 ALIGN
d834 4
a837 4
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05
d840 4
a843 4
 baddr  R0, ShortConSynSCSIFSdiscs
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn
d846 4
a849 4
 BL     ReadCMOSflags   ;(->R0,R2,R4,R5,V)
 BVS    ConfigReturn
 TEQS   R1, #1
 BNE    %FT15
d852 3
a854 3
 SWI    XOS_WriteS
 Text   "SCSIFSdiscs"
 BVS    ConfigReturn
d856 4
a859 4
 MOV    R0, R4
 BL     WrDec           ;(R0->R0,V)
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn
d863 8
a870 8
 BIC    R3, R2, #2_00000111                     ;clear old bits
 MOV    R0, #10 :OR: bit31 :OR: bit29
 MOV    R2, #4
 SWI    XOS_ReadUnsigned        ;(R0-R2->R0-R2,V)
 BVS    ConfigReturn
 ORR    R2, R3, R2              ;form new byte
 MOV    R1, #CMOSflags
 ] ; :LNOT:HotPlug
d873 2
a874 2
 MOV    R0, #OsByte_WriteCMOS
 SWI    XOS_Byte    ;(R0-R2->R0-R2,V)
d876 2
a877 2
 STRVS  R0, [SP]
 Pull   "R0-R6,SB,PC"
d879 1
a879 1
 END
@


4.8
log
@Don't source padding data from zero page
Detail:
  s/ScsiFs00, s/ScsiFs15, s/ScsiFs50 - When UseSpecialScatterBlk, pad writes out to device block size by using an empty block of RMA instead of the contents of zero page.
Admin:
  Fixes crashes when high processor vectors are in use


Version 1.26. Tagged as 'SCSIFS-1_26'
@
text
@d218 1
a218 1
 MOV    R0, #Upcall_DriveRemoved
d309 1
a309 1
 [ T
d873 1
a873 1
 MOV    R0, #OsbyteWriteCMOS
@


4.7
log
@  Support for FileCore API relaxations
Detail:
  * Previously, SCSIFS always set the "No directory state" startup option
    bit in FileCore_Create, even though from the PRM's description of the
    *Configure Dir/NoDir options, it should have been setting it according
    to the shared bit in CMOS byte &0B. However, since RISC OS 3.00, FileCore
    has not done anything with this information, so I'm retiring the bit.
  * No longer passes hard disc map sizes in R6 to FileCore_Create. This means
    it no longer reads them from CMOS, and nor does it update the CMOS when
    discs are mounted. This is safe because FileCore hasn't actually used
    these values since RISC OS 4.00. For consistency with ADFS (which stopped
    using its equivalent CMOS at RISC OS 5.00) the code is switched out via
    the BigDisc switch. This means we can free up a whole 4 bytes of CMOS!
Admin:
  Tested briefly via a softload on an OMAP3 machine.

Version 1.25. Tagged as 'SCSIFS-1_25'
@
text
@d48 10
@


4.6
log
@Update to use some of the exported FileCore headers.
There are still a large number of local copies that should be visited, but this change at least allows it to assemble again FileCore-3_45.

Version 1.22. Tagged as 'SCSIFS-1_22'
@
text
@a129 6
 ORR R3,R3,#DriveConfig_StartupOpt_NoDir   ;>>>RCM see what happens
 [ LeftToDo
 ! 0, "Left to do - think about Dir/NoDir bit"
 ; Should we Set it, Clear it or read it from CMOS???
 ; for now, set it (above)
 ]
d140 3
d145 1
@


4.5
log
@	small number of changes to correctly work with scatterlists such
	used by filecore format discs.
Detail: these should have been committed as part of the mods of 5th March
	though it appears the something was missed as recent checkouts didn't
	contain all the mods.
Admin:  castle added IP


Version 1.15. Tagged as 'SCSIFS-1_15'
@
text
@d20 2
a21 2
 =      EjectBit+WinniePollChanges
 =      (DriveStatusWorks:SHR:8)+(BigBit:SHR:8)+(NewErrorBit:SHR:8)
d130 1
a130 1
 ORR R3,R3,#&40000000    ;>>>RCM see what happens
@


4.4
log
@	Added note on SCSIFS_Partitions swi.
	Committing correct files this time.
        previous version, 1.14 failed to include these

Detail:
Admin:  castle added IP. to be beta tested


Version 1.14. Tagged as 'SCSIFS-1_14'
@
text
@d423 1
a423 1
;
d436 1
a436 1
 Pull   "R1,R2,PC"
@


4.3
log
@          fixed a memory leak /unstable callback removal in scsifs.
          Added in detect needed for dosfs partitions.. didnt seem to make it
          into cvs in 1.11.
          Added SWI_SCSIFSPartitions and Service_SCSIMounting to permit external
          partition manger to provide partition handling

Detail:

Admin:    tested at castle.. castle added IP


Version 1.12. Tagged as 'SCSIFS-1_12'
@
text
@d417 1
a417 1
;        0 = Sector offset for drive 1 in R1 is in R2
d423 5
a427 1
;    
d430 2
d436 17
a452 1
  Pull   "R1,R2,PC"
d561 1
a561 1
 = "PartitionBase",0
@


4.2
log
@* Activated "floppy" (removable) support.
* Added big disc support.
* Added new error reporting scheme.
* Added autoconfiguration, and new SCSIdriver hotplugging.
* Added eject functionality (currently disabled due to issues with some USB
  devices).
* 32-bit compatible.

Version 1.11. Tagged as 'SCSIFS-1_11'
@
text
@d52 13
d188 9
a196 5
 ADRL   R0, DoAttachedCallback
 MOV    R1, SB
 SWI    XOS_RemoveCallBack
 ADRL   R0, DoDetachedCallback
 SWI    XOS_RemoveCallBack
d199 1
d414 18
d472 16
d489 1
d539 1
@


4.1
log
@Initial revision
@
text
@d20 3
a22 2
 =      0
 =      0,0,fsnumber_SCSIFS
d48 13
d68 1
d72 1
a72 1
 MOV    R1, #LostUnitAtn
d83 12
d96 7
d138 1
a138 1
 SWI    XOS_FileCoreCreate      ;(R0-R6->R0-R2,V)
d142 12
d157 1
a157 1
 Pull   "R7-R11,SB,PC",,^
d174 8
d188 2
a189 2
 mapDrvToDevImm R1, #4          ;DeviceID for drive ScsiFs::4
 LDR    R4, BlockSizes
d191 6
d198 2
d201 1
a201 1
 BLNE UnLockMedia
d203 4
a206 3
 MOVNE  R0, #2                  ;RC for ReleaseDevice 
 MOVNE  R8, R12                 ;Access key
 SWINE  XSCSI_Reserve
d208 2
a209 2
 ADD    R1, R1, #1              ;Next deviceID
 MOVS   R4, R4, LSR #8          ;
d229 3
a231 3
 MOVS   R0, R9
 MOVNES R10,R10         ;only error on init (R10=0/1 for Die/Init)
 Pull   "R7-R11,SB,PC",EQ,^
d242 9
d256 1
d258 1
d260 18
a277 1
 MOVNES PC, LR
d281 1
a281 1
 Push   "R0-R4,R8,LR"
d288 2
a289 2
 mapDrvToDevImm R1, #4          ;DeviceID for drive ScsiFs::4
 LDR    R4, BlockSizes
d291 8
a298 4
 TST    R4, #&FF
 BLNE   ReserveDevice
 ADD    R1, R1, #1              ;Next deviceID
 MOVS   R4, R4, LSR #8          ;
d305 2
a306 2
 Pull   "R0-R4,R8,LR"
 MOVS   PC, LR
d312 1
a312 1
 SWI    XOS_FileCoreDiscOp
d317 1
a317 1
 MOVS   PC,LR
d323 1
a323 1
 SWI    XOS_FileCoreDrives
d330 1
a330 1
 SWI    XOS_FileCoreFreeSpace
d333 26
d366 1
a366 1
 SWI    XOS_FileCoreDescribeDisc
d393 2
a394 2
 Pull   "R1,R2,LR"
 MOVS   PC,LR
d405 1
a405 1
 MOV    LR, PC
d407 1
a407 1
 B      %FT10
d417 20
d440 19
a458 2
10
 Pull   "SB,PC"
d460 2
d472 14
d489 2
d526 1
d531 1
d690 1
a690 1

d781 1
a781 1
 MOV    R2, #4         
d786 1
d793 1
a793 4
 Pull   "R0-R6,SB,LR"
 BIC    LR, LR, #NZCV           ;return with NZC clear
 ORRVS  LR, LR, #V_bit          ;V set <=> error
 MOVS   PC,LR
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

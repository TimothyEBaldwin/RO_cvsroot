head	1.5;
access;
symbols
	PartMan-0_16:1.5
	PartMan-0_15:1.5
	PartMan-0_14:1.5
	PartMan-0_13:1.5
	PartMan-0_12:1.4
	PartMan-0_11:1.3
	PartMan-0_10:1.2
	PartMan-0_09:1.1.1.1
	start:1.1.1.1
	INITIAL:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2017.01.09.21.24.54;	author jballance;	state Exp;
branches;
next	1.4;
commitid	yFxEcnSEVzAI2lBz;

1.4
date	2016.12.11.21.27.50;	author jballance;	state Exp;
branches;
next	1.3;
commitid	Gg0AAlw0femwZBxz;

1.3
date	2016.12.06.08.24.15;	author jballance;	state Exp;
branches;
next	1.2;
commitid	n7zTGodkOF8GOTwz;

1.2
date	2016.12.01.18.37.38;	author jballance;	state Exp;
branches;
next	1.1;
commitid	YAJCcZqGGbY3njwz;

1.1
date	2016.11.28.22.08.42;	author jballance;	state Exp;
branches
	1.1.1.1;
next	;
commitid	HKcQ8iJU5OQNCWvz;

1.1.1.1
date	2016.11.28.22.08.42;	author jballance;	state Exp;
branches;
next	;
commitid	HKcQ8iJU5OQNCWvz;


desc
@@


1.5
log
@   More work on filecore format routine.
Detail:
   The routine embedded in the sources will now write a correct filecore format
   across the full range of IDLen values, though in use it will generally select
   the largest IDLen value as this permits the most files to be stored on disc.
Admin:
   tested in iMx6


Version 0.13. Tagged as 'PartMan-0_13'
@
text
@/* Copyright 2016 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Format routine...
// computes format parameters and lays out disc specified
//
//
//
//
//
//
//

#include        "PMInclude.h"
#include        "Format.h"
#include        "Diagnostic.h"

#define CHSRound(c,h,s,secs) {c=0;h=16;s=63;do{h++;c=secs/h;s=63;while(c%s)s--;c/=s;}while((c>=65536)||(h>=256));/*secs=c*h*s;*/}

// Possible layout limits :
// (f is the FormatArray*)
#define MaxZonesNormalDir (0x7f)  // max number of zones to permit in a format without big dirs
#define MaxZonesBigDir    (0x7fff)// max number of zones to permit in a format with big dirs
#define ZonesMax          (f->bigdisc?MaxZonesBigDir:MaxZonesNormalDir)
#define IDlenMax          (f->bigdir?19:15)
#define IDlenMin          (f->log2secsize+3)
#define IDsMax            ((1<<IDlenMax)-1)
#define BigDiscSize       (((512<<20)/(f->SecSize))-1)
#define ShareSizeMax      (15)
#define ZW                (4*8)
#define ZWZone0x          (60*8)
#define RootDirLen        (0x800)
#define BootReservedLen   (0xe00)
#define ZoneCap           ((f->SecSize*8)-ZW)
// fragment count zones can hold
#define Zb                (((ZoneCap)/(f->idlen+1))*(f->idlen+1))
#define Z0b               (Zb-ZWZone0x)
// MaxZones is the max zone count to keep the root dir address in range
#define MaxZones          (2*((1<<f->idlen)-1)/(Zb/8))

// write a fragment into a zone
// Assume FragmentID and FragmentLen are legitimate
void fragwrite(char* mapsector, int position, int FragmentID, int FragmentLen, int IDlen)
{
  testprint("FW: mapsec:%x pos:%x id:%x len:%x idlen%x mapoffxet byte %x\n",
             (int)mapsector,position,FragmentID,FragmentLen,IDlen,position/8);
  FragmentID=(FragmentID>>8)<<(position%8);
  // n.b. offset of 1 added to position to allow for zone cksum at byte 0 of zone
  mapsector[1+(position/8)] |= (FragmentID>>0 );
  mapsector[2+(position/8)] |= (FragmentID>>8 );
  mapsector[3+(position/8)] |= (FragmentID>>16);
  mapsector[4+(position/8)] |= (FragmentID>>24);
  // terminate object
  position+=FragmentLen-1;
  mapsector[1+(position/8)] |= 1<<(position%8);
}


// create root directory 0x800 long
void MakeRootDir(int bigdir , char* map, int rootaddress)
{
  int *j,i,l;
// create root dir
   if(!bigdir)
   {
     map[1] = 'N';
     map[2] = 'i';
     map[3] = 'c';
     map[4] = 'k';
     map[0x800-38] = (char)rootaddress;
     map[0x800-37] = (char)(rootaddress>>8);
     map[0x800-36] = (char)(rootaddress>>16);
     map[0x800-35] = '$';
     map[0x800-16] = '$';
     map[0x800-5] = 'N';
     map[0x800-4] = 'i';
     map[0x800-3] = 'c';
     map[0x800-2] = 'k';
     j = (int*)map;
     l = *j;
     l = *(j+1) ^ (((l>>13) & 0x7ffff)+(l<<19) );
     i = 0x800 -40;
     while((i&3)>0)
     {
       l = ((int)map[i]) ^ (((l>>13) & 0x7ffff)+(l<<19) );
       i++;
     }
     while(i<(0x800-4))
     {
       l = *(j+(i/4)) ^ (((l>>13) & 0x7ffff)+(l<<19) );
       i+=4;
     }
     i=l^(l>>8)^(l>>16)^(l>>24);
     map[0x800-1] = (unsigned char)i;
   }
   else
   {  // write bigdir header
     map[0] =  0;
     map[1] =  0;
     map[2] =  0;
     map[3] =  0;

     map[4] = 'S';
     map[5] = 'B';
     map[6] = 'P';
     map[7] = 'r';

     map[8] =  1; // dir name length
     map[9] =  0;
     map[10] = 0;
     map[11] = 0;

     map[12] = 0x00; // dir length in bytes
     map[13] = 0x08;
     map[14] = 0x00;
     map[15] = 0x00;

     map[16] = 0; // no of entries in dir
     map[17] = 0;
     map[18] = 0;
     map[19] = 0;

     map[20] = 0; // no of bytes allocated for names
     map[21] = 0;
     map[22] = 0;
     map[23] = 0;

     map[24] = (char)(rootaddress>>0 ); // indirect disc addr of parent dir
     map[25] = (char)(rootaddress>>8 );
     map[26] = (char)(rootaddress>>16);
     map[27] = (char)(rootaddress>>24);

     map[28] ='$';  // root dir name and CR
     map[29] =13;
     map[30] = 0;
     map[31] = 0;

   // new dir tail
     map[0x800-8] = 'o';
     map[0x800-7] = 'v';
     map[0x800-6] = 'e';
     map[0x800-5] = 'n';
     map[0x800-4] = 0;  // to match byte 0
     map[0x800-3] = 0;
     map[0x800-2] = 0;
     j = (int*)map;     // use *j as int access, map as char access
     l = 0;
     i=0;
     while(i<(32))      // first 28 bytes
     {
       l = *(j+(i/4)) ^ (((l>>13) & 0x7ffff)+(l<<19) );
       i+=4;
     }
     l = *(j+((0x800-8)/4)) ^ (((l>>13) & 0x7ffff)+(l<<19) );
     l = map[0x800-4] ^ (((l>>13) & 0x7ffff)+(l<<19) );
     l = map[0x800-3] ^ (((l>>13) & 0x7ffff)+(l<<19) );
     l = map[0x800-2] ^ (((l>>13) & 0x7ffff)+(l<<19) );
     i=l^(l>>8)^(l>>16)^(l>>24);
     map[0x800-1] = (unsigned char)i;
   }
}


// Compute and write disc format to SCSI device ID
//  At sector offset Offset, for Size sectors
int MakeAcornFormat(int         ID,
               unsigned int     AccessKey,
               int              SecSize,
               int              PartnBase,
               int              SecCount,
               char             *name,
               int              *defect,
               char             bootoption,
               int              bigdir)
{
   bootsector   *boot;
   int          *j,i,k,offset2next=0,base,zonestart,zoneend,temp;
   int           shift,insecoffset,zoneendbit,dirsectors,zonesectors,mapbase;
   char         *map,*newname,*tfbuf;
   static FormatArray fa,*f=&fa;

   fa.SecSize = SecSize; fa.SecCount = SecCount;
   fa.bigdir = (char)bigdir;
   fa.rootdirsize = RootDirLen;

   // suggest a head/cylinder/lfau setup
   CHSRound(fa.cyls,fa.heads,fa.spt,fa.SecCount);

   if(tfbuf=calloc((SecSize>0x200)?SecSize:0x200,1),!tfbuf) return -1;
   // first read in the sector there
   wimp_error( SecRead(ID, AccessKey, tfbuf, (SecSize>0x200)?SecSize:0x200, (0xc00/SecSize)+PartnBase,  SecSize));
   insecoffset=0xc00-((0xc00/SecSize)*SecSize);
   boot=(bootsector*)((int)tfbuf+insecoffset);
   newname=name;

   // compute format parameters
   fa.SecSize=SecSize; fa.SecCount=SecCount;

   // decide whether to use bigdisc parameters
   fa.bigdisc=fa.SecCount>BigDiscSize?1:0;

   // default to big directory style
   fa.bigdir=1;

   // compute log2 secsize
   temp=fa.SecSize; fa.log2secsize=0;
   while(temp>1){fa.log2secsize++;temp/=2;}
   // start at idlenmax
   //    at present its the only value used....
   fa.idlen=IDlenMax;
   fa.log2zsize=0;
   fa.log2bpmb = fa.log2secsize+3;

   // maxzones is the theoretical max zonecount for this idlen which
   // keeps the root directory address < idlen bits
   fa.zonec=((fa.SecCount-1)/Zb)+1; // total zones needed
   // get zonecount viable by increasing LFAU (bits/mapbit)
   while( (fa.zonec>>(fa.log2bpmb-fa.log2secsize)) > ((ZonesMax>MaxZones)?MaxZones:ZonesMax) ){fa.log2bpmb++; }

   fa.zonec>>=(fa.log2bpmb-fa.log2secsize);

   // scale this zonecount so it fits in 8 bits
   while((fa.zonec>>fa.log2zsize)>255)fa.log2zsize++;

   // we know total zones for this disc size
   // we know log2zsize needed to get total zone count < ZonesMax
   // bpmb comes in here.. its what we use to get zone count acceptable
   // log2zsize is used to get the reported zone count < 256 as that is needed
   // for root dir address.
   // round this out
   fa.zonec=(fa.zonec>>fa.log2zsize)<<fa.log2zsize;


   // we now know fa.zonec (0-fa.zonec-1 gives fa.zonec zones), fa.log2zsize,
   // fa.log2bpmb, fa.secsize, fa.idlen, fa.bigdisc, fa.bigdir - compute the rest
   shift= fa.log2bpmb-fa.log2secsize;

   fa.zonespare = (fa.SecSize*8) - Zb;
   fa.SecCount=(((fa.zonec-1)*Zb)+Z0b)<<(fa.log2bpmb-fa.log2secsize);

   fa.zonec=((fa.zonec>>fa.log2zsize)<<fa.log2zsize);
   fa.zonecount  = fa.zonec;
   fa.zonecount2 = (fa.zonec)>>8;
   fa.discsize   = fa.SecCount<<    fa.log2secsize;
   fa.discsizehi = fa.SecCount>>(32-fa.log2secsize);

   reportfmt(&fa);
   // build disc record in boot sector
   j = (int*)(boot);
   for(i=0;i<128;i++)
   {
     *(j+i) = 0;                    // clear to null
   }
   k=0;
   while(defect&&(*(defect+k)>0)&&(*(defect+k)<(0x1fffffff>>fa.log2secsize)))
   {
     boot->defects[k] = *(defect+k)<<fa.log2secsize;
     k++;
   }
   boot->defects[k]=0x20000000;
   if(fa.bigdisc == 1)
   {
     while(defect&&*(defect+k)>0)
     {
       boot->defects[k+1] = *(defect+k);
       k++;
     }
     boot->defects[k+1]=0x40000000;
   }
   DefectChecksum((int*)&boot->defects[0],fa.bigdisc);
   boot->dr.l2secsize    = fa.log2secsize;
   boot->dr.spt          = fa.spt;
   boot->dr.heads        = fa.heads;
   boot->dr.skew         = fa.skew;
   boot->dr.idlen        = fa.idlen;
   boot->dr.l2bpmb       = fa.log2bpmb;
   boot->dr.bootoption   = bootoption;
   boot->dr.nzones       = fa.zonecount;
   boot->dr.zonespare[0] = (char)fa.zonespare;
   boot->dr.zonespare[1] = (char)((fa.zonespare)>>8);
   boot->dr.discsize     = fa.discsize;
   boot->dr.discsizehi   = fa.discsizehi;
   boot->dr.log2zsize    = fa.log2zsize;
   boot->dr.discid[0]    = newname[0]^newname[2]^newname[4]^newname[6]^newname[8];
   boot->dr.discid[1]    = newname[1]^newname[3]^newname[5]^newname[7]^newname[9];
   for (i=0; i<=9; i++)
   {
     if(strlen(newname) >=i)
     {
       boot->dr.discname[i] = newname[i];
     }
     else
     {
       boot->dr.discname[i] = 0x0d;
     }
   }
   boot->dr.disctype= 0;
   boot->dr.bigflag = fa.bigdisc;
   boot->dr.nzones2 = (bigdir>0)?fa.zonecount2:0;
   boot->dr.bdspare1= 0;              // must be 0
   boot->dr.formatversion= (bigdir>0)?1:0;
   boot->dr.rootdirsize=(bigdir>0)?RootDirLen:0;
   // we'll write this once root address is calculated

   // get space for building map
   if((map = (char*)calloc(((SecSize*fa.zonec)),1)),!map)
   {
     if(tfbuf) free(tfbuf);
     return(-1);
   }

   // Create zone maps
   base=0;
   zonestart = zoneend = mapbase = 0;

   for(k=0; k<fa.zonec;k++)
   {
     //   init freelink pointer
     map[1+base] = 0x18;    // pointer past byte 1 to first free bit in zone
     map[2+base] = 0x80;    // hi bit terminates zonespare segment
     map[3+base] = 0xff;    // zone crosscheck init to &ff in all zones
                            // (see z0 later)

     // handle defect mapping out on zone by zone basis

     //   compute zonestart & zoneend disc addresses (bits==sectors)
     //   units here are sectors
     zonestart = zoneend;
     zoneend   = zonestart + (((k)?Zb:Z0b)<<shift);

     // check if defect is in this zone ***********check code?********
     while(defect&&(*defect)&&(*defect>=zonestart)&&(*defect<zoneend))
     {
       // compute bitpos & offset2next of frag start to map out defect sector
       i = offset2next = (((*(defect++)-zonestart)<<shift))+0x18;
       // map out the fragment with the defect
       fragwrite((char*)(map+base), i, 0x100, fa.idlen+1,fa.idlen+1);
     }

     if(k==0) // Create zone 0 map...
     {
       // a) copy in disc record
       for(i=4;i<64;i++) { map[i+base] =(char)*(((char*)&(boot->dr))+i-4);}

       // b) write in first fragment to map out boot area
       int bbits = fa.idlen;
       while((bbits*(1<<fa.log2bpmb))<0xe00)bbits++;
       i=(1<<bbits);// this gets  end bit, then
       i+=2;        // 2 is the type that maps out boot stuff
       map[64+base] = (char)i;
       map[65+base] = (char)(i>>8);
       map[66+base] = (char)(i>>16);
       map[67+base] = (char)(i>>24);

       // c) update and write freelink
       offset2next  = (int)map[1+base] + ((((int)map[2+base])*0x100)&0x7f00);
       offset2next += (ZWZone0x)+bbits+1;       // first free alloc unit after
       map[1+base] = (char)offset2next;
       map[2+base] = (char)((offset2next)>>8) + (0x80);
       // d) ensure EOR of all Zonechecks->0xff
       map[3+base] = (fa.zonec&1)?0xff:0x00;
     }
     if(k == (fa.zonec/2)) //root dir zone is 1/2 way through
     { // write map adding in root dir allocation
       // mark as used fragments for map and root dir
       // work out sector address for root dir.

       fa.rootdiradd = zonestart + (fa.zonec*2);
       // make sure its at start of shared map bit, rounded up
       if(fa.rootdiradd%(1<<fa.log2zsize))
       {
         fa.rootdiradd>>=fa.log2zsize;
         fa.rootdiradd+=1;
         fa.rootdiradd<<=fa.log2zsize;
       }
       // remember base address of map
       mapbase=zonestart;

       // compute root dir fragment address
       dirsectors = (fa.SecSize>=RootDirLen)?1:(RootDirLen/fa.SecSize);
       zonesectors =(fa.bigdir)? 0:dirsectors;
       zonesectors += 2*(fa.zonec);

       fa.bootsecbits = BootReservedLen/fa.SecSize;
       if(BootReservedLen%fa.SecSize)fa.bootsecbits +=1;
       if(shift>=0)  // 1 or more sectors/mapbit
       {
         fa.dirbits     = dirsectors     >> shift;
         fa.mapbits     = zonesectors    >> shift;
         fa.bootsecbits = fa.bootsecbits >> shift;
         // round up to integer count above if needed
         if(shift)if ( dirsectors%(1<<shift)) fa.dirbits++;
         if(shift)if (zonesectors%(1<<shift)) fa.mapbits++;
       }
       else          // more than 1 mapbits/sector
       {
         fa.dirbits     = dirsectors     << (-shift);
         fa.mapbits     = zonesectors    << (-shift);
         fa.bootsecbits = fa.bootsecbits << (-shift);
       }
       //  ensure these are at least min length
       if(fa.bootsecbits<(fa.idlen+1)) fa.bootsecbits = (fa.idlen+1);
       if(fa.mapbits    <(fa.idlen+1)) fa.mapbits=(fa.idlen+1);
       if(fa.dirbits    <(fa.idlen+1)) fa.dirbits=(fa.idlen+1);

       // compute expected root dir disc address
       if(fa.bigdir==0)
       {
         fa.rootaddress = 0x201+(((2*(fa.zonec))+(1<<fa.log2zsize)-1)/(1<<fa.log2zsize));
         fa.rootdiradd=(((2*(fa.zonec))*fa.log2zsize-1)/(1<<fa.log2zsize))*(1<<fa.log2zsize);
       }
       else
       {
         fa.rootaddress = 1+((((fa.zonec/2)*(Zb/(fa.idlen+1))))<<8);
         fa.rootdiradd  = zonestart + (fa.mapbits<<(shift));
       }
       // update boot sector view of root address
       boot->dr.root    = fa.rootaddress;
       boot->bootchksum = bootvalidbyte ( boot);
       // copy into zone map too
       for(i=4;i<64;i++) { map[i] =(char)*(((char*)&(boot->dr))+i-4);}
       map[0] = mapvalidbyte(map,fa.log2secsize,0);

       // Write sector(s) with bootblock  out again
       wimp_error( SecWrite(ID, AccessKey, tfbuf, (SecSize>0x200)?SecSize:0x200, (0xc00/SecSize)+PartnBase,  SecSize));
       // compute bit offset & offset2next of frag start
       i = (int)map[1+base] + ((((int)map[2+base])<<8)&0x7f00);
       fragwrite((char*)(map+base), i, 0x201, fa.mapbits,fa.idlen+1);

       i += (fa.mapbits);
       if(fa.bigdir)
       {
         fragwrite((char*)(map+base),i,fa.rootaddress, fa.dirbits,fa.idlen+1);
         i += (fa.dirbits);
       }
       map[1+base] = (char)i;
       map[2+base] = ((char)(i>>8))+ 0x80;
     }
     // all zones
     zoneendbit = Zb -1 + ZW;
     // terminate zone before zonespare section
     map[(zoneendbit/8)+base] |= 1<<(zoneendbit%8);
     map[0+base] = mapvalidbyte(map,fa.log2secsize,k);
     base+=fa.SecSize;
   }

   // Write out Zone map & copy
   wimp_error( SecWrite(ID, AccessKey, map, SecSize*fa.zonec, mapbase+PartnBase,  SecSize));
   wimp_error( SecWrite(ID, AccessKey, map, SecSize*fa.zonec, mapbase+fa.zonec+PartnBase,  SecSize));
   if(map) free(map);
   if(tfbuf) free(tfbuf);

   // get space for building rootdir
   if(map = (char*)calloc(0x800,1),!map)
   {
     return(-1);
   }
   // create root dir
   MakeRootDir(fa.bigdir,map,fa.rootaddress);
   // write out root dir
   wimp_error( SecWrite(ID, AccessKey, map, 0x800, fa.rootdiradd+PartnBase,  SecSize));
   if(map) free(map);

   return (0);
}

unsigned char mapvalidbyte( void const * const map,
                            int log2secsize,
                            unsigned int zone)
{
  unsigned char const * const mapbase = map;
  unsigned int sum0=0,sum1=0,sum2=0,sum3=0,zonestart,rover;

  zonestart = zone<<log2secsize;
  for( rover = ((zone+1)<<log2secsize)-4;
       rover > zonestart;
       rover -= 4)
  {
    sum0 += mapbase[rover + 0] + (sum3 >>8);
    sum3 &= 0xff;
    sum1 += mapbase[rover + 1] + (sum0 >>8);
    sum0 &= 0xff;
    sum2 += mapbase[rover + 2] + (sum1 >>8);
    sum1 &= 0xff;
    sum3 += mapbase[rover + 3] + (sum2 >>8);
    sum2 &= 0xff;
  }

  sum0 += (sum3>>8);
  sum1 += mapbase[rover + 1] + (sum0 >>8);
  sum2 += mapbase[rover + 2] + (sum1 >>8);
  sum3 += mapbase[rover + 3] + (sum2 >>8);
  return (unsigned char)
         ( sum0^sum1^sum2^sum3);
}

unsigned char bootvalidbyte ( bootsector* boot)
{
  int i,sum = 0 ,cc=0,  same= 0, last = *((char*)boot);

  for(i=0;i < 511; i++)
  {
    cc=sum +=*((char*)boot + i);
    if(last!=*((char*)boot + i))same=1;// flag that sector is not all ientical
    if(sum>0xff)sum-=0xff;
  }
  if((cc==0) || (same==0))sum++;// fudge to catch an all zero sector
                                // and or an all identical sector
  return (unsigned char) (sum);
}


// compute defect list checksums
void DefectChecksum(int *defect, int disctype)
{
  int a,b=0;
// put in standard chksum
  while((a=*(defect++))<0x20000000)
  {
     b = a ^ (((b>>13) & 0x7ffff)+(b<<19) );
  }
  *(defect-1)= 0x20000000 + ((b^(b>>8)^(b>>16)^(b>>24))&0xff);
  b=0;
// put in extended bit if needed
  if(disctype == 1)
  {
    while((a=*(defect++))<0x40000000)
    {
       b = a ^ (((b>>13) & 0x7ffff)+(b<<19) );
    }
    *(defect-1)= 0x40000000 + ((b^(b>>8)^(b>>16)^(b>>24))&0xff);
  }

}

@


1.4
log
@  Further work to the filecore formatter routine
Detail:
  The formatter now produces a layout comparable to the !HForm one
  (The 16 bit zonecount was erroneously cast to 8bit)
Admin:
  produces a layout that passes DiscKnight validation. After copyint 15Gig
  of data in sone 250000 files the disc usage is comparable.

Version 0.12. Tagged as 'PartMan-0_12'
@
text
@d29 1
a29 2
extern void wimp_error(_kernel_oserror *er);
static _kernel_oserror our_error;
d31 20
a50 4
#define MaxZonesNormalDir 0x7f           // max number of zones to permit in a format without big dirs
#define MaxZonesBigDir    0x7fff         // max number of zones to permit in a format with big dirs

#define CHSRound(c,h,s,secs) {h=16;do{h++;c=secs/h;s=63;while(c%s)s--;c/=s;}while((c>65535)&&(h>255));secs=c*h*s;}
d56 2
a57 2

testprint("FW: mapsec:%x pos:%x id:%x len:%x idlen%x\n",(int)mapsector,position,FragmentID,FragmentLen,IDlen);
d70 105
d180 1
a180 1
               int              BaseOffset,
d185 1
a185 1
               int		bigdir)
d188 2
a189 1
   int          *j,i,k,l,boff,skew,base,zonestart,zoneend,insecoffset,secsperblock = 1;
d191 1
a191 1
   static FormatArray fa;
a193 1
   if(fa.SecSize > 0x400)secsperblock=fa.SecSize/0x400;
d195 1
d200 1
a200 9
   testprint(" suggested heads %d, cyls %d, secs %d giving disk size %x\n",fa.heads,fa.cyls,fa.spt,fa.SecCount);

#if Debug
 map = calloc(1024,1);
 sprintf(map,"AFmt id   %x key %x size %x BaseOff %x SC %x bigdir %d\n",ID,AccessKey,fa.SecSize,BaseOffset,fa.SecCount,bigdir);
 testprint(map);
 free(map);
#endif
   if(tfbuf=calloc(SecSize,1),tfbuf==NULL) return -1;
d202 1
a202 1
   wimp_error( SecRead(ID, AccessKey, tfbuf, (SecSize>0x200)?SecSize:0x200, (0xc00/SecSize)+BaseOffset,  SecSize));
d205 4
a208 3
  testprint("\n tfbuf:%x boot:%x  ",(int)tfbuf,(int)boot);
     newname=name;
 testprint("\nabt to build layout");
d210 2
a211 2
// compute format parameters
   if(BuildAcornLayout(&fa,NULL) == -1) return 0;
d213 44
a256 1
 testprint("...done building layout");
d258 2
a259 1
// build disc record in boot sector
d285 1
d291 1
a291 2
   boot->dr.zonespare[1] = (char)(fa.zonespare>>8);
   boot->dr.root         = fa.rootaddress;
d294 1
a294 1
   boot->dr.sharesize    = fa.sharesize;
d313 2
a314 10
   boot->dr.rootdirsize=(bigdir>0)?fa.rootdirsize:0;
   boot->bootchksum = bootvalidbyte ( boot);


//// fudge required by filecore fault...
//  if(SecSize > 0x200)
//  {
//      boot=(bootsector*)((int)tfbuf+insecoffset);
//      memcpy(tfbuf,boot,0x200);
//  }
d316 2
a317 9
// Write sector(s) with bootblock  out again
   testprint("base offset %x at boot sector write, discname %s\n",BaseOffset,(int)newname);

//testsave(tfbuf,0x200);

   wimp_error( SecWrite(ID, AccessKey, tfbuf, (SecSize>0x200)?SecSize:0x200, (0xc00/SecSize)+BaseOffset,  SecSize));

// get space for building map
   if((map = (char*)calloc((SecSize*fa.zonec),1))== NULL)
d319 1
a319 1
     if(tfbuf != NULL) free(tfbuf);
d323 3
a326 3
// Create zone maps
   base=0;
   zonestart = zoneend = 0;
d329 1
a329 1
//   init freelink pointer
d332 7
a338 2
     map[3+base] = 0xff;    // zone crosscheck init to &ff in all zones (see z0 later)
//   compute zonestart & zoneend disc addresses (sectors)
d340 4
a343 2
     zoneend = zonestart + ((((60*8)-fa.zonespare)<<fa.log2bpmb)>>fa.log2secsize);
     while(defect&&(*defect>0)&&(*defect>=zonestart)&&(*defect<zoneend))
d345 3
a347 4
//     compute bit offset & skew of frag start to map out defect sector
       i = skew = (((*(defect++)-zonestart)<<fa.log2bpmb)>>fa.log2secsize)+0x18;

//     map out the fragment with the defect
d351 1
a351 1
     if(k==0)
d353 8
a360 20
//     Create zone 0 map... copy in disc record
       for(i=4;i<64;i++)
       {
         map[i+base] =(char)*(((char*)&(boot->dr))+i-4);
       }
//     write in first fragment to map out boot area
       boff = fa.idlen;
  testprint("\n bytes for base %x, boff %x ",(int)(boff*(1<<fa.log2bpmb)),boff);
       while((boff*(1<<fa.log2bpmb))<0xe00)boff++;      // ensure boot sector mapped out
  testprint("\n boff %x ",(int)(boff));
       if((1<<fa.log2bpmb)<SecSize)
       {                                                // ensure we point to highest subsec alloc unit
         boff++;
         while(((boff*(1<<fa.log2bpmb))%SecSize)>0)boff++;// ensure integer sector count for this
         boff--;
       }
  testprint("\n boff %x ",(int)(boff));
       i=(1<<(boff));                                   // mark last unit used
       i+=2;                                            // add in ID
  testprint("\nmarking bit: %x ",(int)i);
d365 8
a372 7
//     write in freelink
       skew = (int)map[1+base] + ((((int)map[2+base])*0x100)&0x7f00);
       skew += (60*8)+boff+1;                           // first free alloc unit after
  testprint("\nskew: %x ",(int)skew);
       map[1+base] = (char)skew;
       map[2+base] = (char)(skew>>8) + (0x80);
       map[3+base] = (fa.zonec&1)?0xff:0x00; // ensure EOR of all Zonechecks -> 0xff
d374 50
a423 3
     else
     {
       if((k == fa.zonec/2))    // write map adding in root dir allocation
d425 15
a439 1
//       mark as used fragments for map and root dir
d441 5
a445 14
//       compute bit offset & skew of frag start
         i = 0x18;//(int)map[1+base] + ((int)map[2+base])<<8;
 testprint("root zone offset %x.. starting freelink at %x\n",k*SecSize,i);
         fragwrite((char*)(map+base), i, 0x201, fa.mapbits,fa.idlen+1);

         i += (fa.mapbits);
         if(fa.bigdir>0)
         {
           fragwrite((char*)(map+base), i, fa.rootaddress, fa.dirbits,fa.idlen+1);
           i += (fa.dirbits);
         }
         map[1+base] = (char)i;
         map[2+base] = ((char)(i>>8))+ 0x80;
 testprint("setting freelink to %x\nrootdirzone\n",i);
d447 2
d450 4
a453 10
//   compute bit offset & skew of free space end (so as to terminate zone)
     skew = 0x18-1;
     skew+= ((k==0)?((fa.fragmentzone0*(fa.idlen+1))+(60*8)):
              (k == fa.zonec-1)?(fa.endzonebits):
                (fa.fragmentzonenorm*(fa.idlen+1)));
//   testprint("Sk:%x %x",skew,k);
//   terminate zone
     map[(skew/8)+base+1] |= 1<<(skew%8);
//   start zonespare fragment
     map[((skew+1)/8)+base+1] |= 1<<((skew+1)%8);
d455 1
a455 1
     base+=SecSize;
d457 4
a460 5
// Write out Zone map & copy
   wimp_error( SecWrite(ID, AccessKey, map, SecSize*fa.zonec, fa.mapbase+BaseOffset,  SecSize));
   wimp_error( SecWrite(ID, AccessKey, map, SecSize*fa.zonec, fa.mapbase+fa.zonec+BaseOffset,  SecSize));
 testprint ("End of map at %x\n rootdir at %x\n",fa.mapbase+fa.zonec+fa.zonec+BaseOffset,fa.mapbase+fa.rootdiradd+BaseOffset);
 testsave ("map",(char*)(map),SecSize*fa.zonec);
d464 1
a464 1
// get space for building rootdir
d469 4
a472 102
// create root dir
   if(fa.bigdir==0)
   {
     map[1] = 'N';
     map[2] = 'i';
     map[3] = 'c';
     map[4] = 'k';
     map[0x800-38] = (char)fa.rootaddress;
     map[0x800-37] = (char)(fa.rootaddress>>8);
     map[0x800-36] = (char)(fa.rootaddress>>16);
     map[0x800-35] = '$';
     map[0x800-16] = '$';
     map[0x800-5] = 'N';
     map[0x800-4] = 'i';
     map[0x800-3] = 'c';
     map[0x800-2] = 'k';
     j = (int*)map;
     l = *j;
     l = *(j+1) ^ (((l>>13) & 0x7ffff)+(l<<19) );
     i = 0x800 -40;
     while((i&3)>0)
     {
       l = ((int)map[i]) ^ (((l>>13) & 0x7ffff)+(l<<19) );
       i++;
     }
     while(i<(0x800-4))
     {
       l = *(j+(i/4)) ^ (((l>>13) & 0x7ffff)+(l<<19) );
       i+=4;
     }
     i=l^(l>>8)^(l>>16)^(l>>24);
     map[0x800-1] = (unsigned char)i;
   }
   else
   {  // write bigdir header
     map[0] =  0;
     map[1] =  0;
     map[2] =  0;
     map[3] =  0;

     map[4] = 'S';
     map[5] = 'B';
     map[6] = 'P';
     map[7] = 'r';

     map[8] =  1; // dir name length
     map[9] =  0;
     map[10] = 0;
     map[11] = 0;

     map[12] = 0x00; // dir length in bytes
     map[13] = 0x08;
     map[14] = 0x00;
     map[15] = 0x00;

     map[16] = 0; // no of entries in dir
     map[17] = 0;
     map[18] = 0;
     map[19] = 0;

     map[20] = 0; // no of bytes allocated for names
     map[21] = 0;
     map[22] = 0;
     map[23] = 0;

     map[24] = (char)(fa.rootaddress>>0 ); // indirect disc addr of parent dir
     map[25] = (char)(fa.rootaddress>>8 );
     map[26] = (char)(fa.rootaddress>>16);
     map[27] = (char)(fa.rootaddress>>24);

     map[28] ='$';  // root dir name and CR
     map[29] =13;
     map[30] = 0;
     map[31] = 0;

   // new dir tail
     map[0x800-8] = 'o';
     map[0x800-7] = 'v';
     map[0x800-6] = 'e';
     map[0x800-5] = 'n';
     map[0x800-4] = 0;  // to match byte 0
     map[0x800-3] = 0;
     map[0x800-2] = 0;
     j = (int*)map;     // use *j as int access, map as char access
     l = 0;
     i=0;
     while(i<(32))      // first 28 bytes
     {
       l = *(j+(i/4)) ^ (((l>>13) & 0x7ffff)+(l<<19) );
       i+=4;
     }
     l = *(j+((0x800-8)/4)) ^ (((l>>13) & 0x7ffff)+(l<<19) );
     l = map[0x800-4] ^ (((l>>13) & 0x7ffff)+(l<<19) );
     l = map[0x800-3] ^ (((l>>13) & 0x7ffff)+(l<<19) );
     l = map[0x800-2] ^ (((l>>13) & 0x7ffff)+(l<<19) );
     i=l^(l>>8)^(l>>16)^(l>>24);
     map[0x800-1] = (unsigned char)i;
   }
// write out root dir
 testprint("rootdiradd=%x\n",fa.mapbase+fa.rootdiradd+BaseOffset);
// testsave (map,0x800);
   wimp_error( SecWrite(ID, AccessKey, map, 0x800, fa.mapbase+fa.rootdiradd+BaseOffset,  SecSize));
a477 97

// compute the format parameters to use
// or complete calculations if boot sector provided
// returns -1 if failed, else 0
int BuildAcornLayout(FormatArray* fmt,bootsector* bsec)
{
  unsigned int tmp,idmaxlen,MaxFragments,MaxZones,MinZones;
  IGNORE(bsec);

  MaxZones=(fmt->bigdir>0)?MaxZonesBigDir:MaxZonesNormalDir;
  MinZones=(fmt->bigdisc>0)?48:2;

  idmaxlen=(fmt->bigdir>0)?19:15;
  MaxFragments = (1<<idmaxlen)-1;
// check if rather large disc
  fmt->bigdisc     = (fmt->SecCount>= 0x100000)?1:0;

// initialise variables for iteration (only know SecSize & SecCount so far)
  fmt->log2secsize = 1;while((1<<fmt->log2secsize)<fmt->SecSize)fmt->log2secsize++;
  fmt->idlen = fmt->log2secsize+3;      // min allocation
  fmt->zonec=MinZones;
  fmt->zonecount = fmt->zonec;   		//  minzones!!
  fmt->zonecount2= fmt->zonec>>8;   	//  minzones!!
  fmt->zonespare   = 0;
  fmt->rootaddress = 0;
  fmt->log2bpmb    = fmt->log2secsize+3; // ensure min granularity OK
// ensure integer number of 32k  there
  tmp=(idmaxlen-fmt->log2secsize)>0?(idmaxlen-fmt->log2secsize):1; // compute rounddown factor (15 = log2 of 32k)
  fmt->SecCount= (fmt->SecCount>>tmp)<<tmp; // and round down


  fmt->discsize    = fmt->SecCount<<fmt->log2secsize;
  fmt->discsizehi  = fmt->SecCount>>(32-fmt->log2secsize);
// have a first stab
  ComputeAcornLayout(fmt);

// cycle round till everything fits..
  while(0
     || (fmt->fragmentcount<=(fmt->zonec*8))              // too many zones
     || (((fmt->idlen+1)*(1<<fmt->log2bpmb))>(254*(1<<(fmt->sharesize+fmt->log2secsize))))
     || (fmt->fragmentcount>((1<<fmt->idlen)-1))     // idlen too small for
                                                     // total fragments
     || (fmt->fragmentcount>=(MaxFragments))         // too many fragments
     || (fmt->fragmentzonelast>fmt->fragmentzonenorm)// too much in last zone
     || (fmt->zone0sparefound!=fmt->zonesparefound)
        )
  { // trial and error loop
    // first try upping the Zonecount
    // if that wont work, then try again on next idlen up...
    // if that wont work, then try again on next alloc size up...
    if(fmt->zonec< MaxZones-1)
    {
      fmt->zonec++;
   //testprint("zc:%x ",fmt->zonec);
    }
    else
    {
      fmt->zonec=MinZones; // reset zonecount
      if((fmt->idlen<idmaxlen))
      {
        fmt->idlen+=1;
    //testprint("\nidl:%x ",fmt->idlen);
      }
      else
      {
        fmt->idlen=fmt->log2secsize+3;   // reset fragment length to min
        if(fmt->log2bpmb>24)
        {       // no viable format possible
          strcpy(our_error.errmess,"No format possible with this disc size.. please try a different one");
          wimp_error(&our_error);
          return -1;
        }
        else
        {
          fmt->log2bpmb+=1;                // increase allocation length
   testprint("\nl2bmb:%x ",fmt->log2bpmb);
        }
      }
    }
    fmt->zonecount=fmt->zonec;
    fmt->zonecount2=fmt->zonec>>8;
    ComputeAcornLayout(fmt);
    fmt->sharesize=fmt->newsharesize;
  }
  fmt->zonecount=--fmt->zonec;
  fmt->zonecount2=fmt->zonec>>8;
// recalc with resultant figures
  fmt->zonespare =  fmt->zonesparefound;
  fmt->rootaddress = fmt->newrootaddress;
  ComputeAcornLayout(fmt);
  reportfmt(fmt);
// ensure zonespare value is integer sector count
  testprint("\nbefore: zonesparebits %x endzonesparebits %x",(int)fmt->zonespare,(int)fmt->endzonebits);
  return 0;
}


a503 1

d519 1
a519 1
  				// and or an all identical sector
a546 187

// return actual name of formatted partition if it exists
// else return name from partition's boot sector
// offset is in 512 byte blocks. this needs scaling to sectorsize (512,1024,2048)
_kernel_oserror* ReadAcornPartitionName(int ID,
                                        unsigned int AccessKey,
                                        int PartitionOffset,
                                        char *Name,int sectorsize)
{
  static bootsector  mysecbuf;
  static disc_record *drec;
  unsigned int aubits,mapbase,temp;
  int sdiv = 1,tmp = sectorsize,changed;
  IGNORE(AccessKey);

  sprintf(Name,"%s","UnNamed");

  while(tmp>512)
  {
    tmp/=2;
    sdiv*=2;
  }
  sdiv/=2;

  BufSecRead(ID,0xfc000003,&mysecbuf,sectorsize,PartitionOffset+(6>>sdiv),sectorsize,&changed);
  if(mysecbuf.bootchksum == bootvalidbyte(&mysecbuf))
  {
    strncpy(Name,mysecbuf.dr.discname,10);
//  compute number of sectors to get to map start
    aubits = ((((mysecbuf.dr.nzones/2)*(1<<(mysecbuf.dr.l2secsize)))-60)*8)
             -((mysecbuf.dr.nzones/2)*(mysecbuf.dr.zonespare[0]+((mysecbuf.dr.zonespare[1])<<8)));

    if(mysecbuf.dr.l2bpmb>mysecbuf.dr.l2secsize)
    {
      mapbase = aubits<<(mysecbuf.dr.l2bpmb-mysecbuf.dr.l2secsize);
    }
    else
    {
      mapbase = aubits>>(mysecbuf.dr.l2secsize-mysecbuf.dr.l2bpmb);
    }
    temp=(int)(mysecbuf.dr.lowsector);
    if(changed==0)
    {
      BufSecRead(ID,0xfc000003,&mysecbuf,sectorsize,PartitionOffset+mapbase,sectorsize,&changed);
      drec=(disc_record*)(4+((int)&mysecbuf));
  // check if it looks like the same disc record
      if((int)(drec->lowsector) == temp) strncpy(Name,drec->discname,10);
    }
  }

  return NULL;
}

// compute the format parameters to use from min info held in boot sector
// no boundary or overflow checking carried out
void ComputeAcornLayout(FormatArray* fmt)
{
   int shift,allocunits,zonesectors,dirsectors,sharesize,MaxZones;

   MaxZones=(fmt->bigdir)?MaxZonesBigDir:MaxZonesNormalDir;

// n.b. 4 bytes of zone taken up by the zone header
// compute fragments for zone 0, + fractional fragment
   fmt->fragmentzone0   = ((fmt->SecSize-4-60)*8)/(fmt->idlen+1);
   fmt->zone0sparefound = ((fmt->SecSize-4-60)*8)%(fmt->idlen+1);
   fmt->zone0sparefound+= 4*8;

// compute fragments for normal zone, + fractional fragment
   fmt->fragmentzonenorm = ((fmt->SecSize-4)*8)/(fmt->idlen+1);
   fmt->zonesparefound   = ((fmt->SecSize-4)*8)%(fmt->idlen+1);
   fmt->zonesparefound  += 4*8;

// correct counts for zonespare value given
   while(fmt->zonesparefound<fmt->zonespare)
   {
     fmt->fragmentzone0 -=1;
     fmt->zone0sparefound+=(fmt->idlen+1);
     fmt->fragmentzonenorm -=1;
     fmt->zonesparefound+=(fmt->idlen+1);
   }

// compute shifter
// if positive, then 1 or more sectors per map bit, else several map bits per sector
   shift=fmt->log2bpmb-fmt->log2secsize;

// compute total alloc units possible
   if(shift>=0)  // 1 or more sectors per mapbit
   {
     allocunits =  fmt->SecCount>>shift;
   }
   else          // 1 or more mapbits per sector
   {
     allocunits = fmt->SecCount<<(-shift);
   }
// compute total possible fragment content of disc
   fmt->fragmentcount   = allocunits/(fmt->idlen+1);
   fmt->fragmentmissed  = allocunits%(fmt->idlen+1);

// compute lastzone fragment count & bits
   if((fmt->zonec)==1)
   {
     fmt->fragmentzonelast = fmt->fragmentcount;
   }
   if((fmt->zonec)==2)
   {
     fmt->fragmentzonelast = fmt->fragmentcount
                             -(fmt->fragmentzone0);
   }
   if((fmt->zonec)>2)
   {
     fmt->fragmentzonelast = fmt->fragmentcount
                            -fmt->fragmentzone0
                            -(((fmt->zonec)-2)*fmt->fragmentzonenorm);
   }
   fmt->endzonebits=(fmt->fragmentzonelast*(fmt->idlen+1))+fmt->fragmentmissed;

   //  testprint("ezb %x fzl %x fmm %x \n",fmt->endzonebits,fmt->fragmentzonelast,fmt->fragmentmissed);
// compute expected mapbase offset
   fmt->mapbase =
              ((((fmt->zonec)/2)-1)*(fmt->fragmentzonenorm*(fmt->idlen+1)))
            + (fmt->fragmentzone0*(fmt->idlen+1))
            + ((((fmt->zonec)/2)-1)*(fmt->zonesparefound-fmt->zonespare))
            + (fmt->zone0sparefound-fmt->zonespare);

   if(shift>=0)  // 1 or more sectors/mapbit
   {
     fmt->mapbase = fmt->mapbase << shift;
   }
   else          // 1 or more mapbits/sector
   {
     fmt->mapbase = fmt->mapbase >>(-shift);
   }

// compute number of alloc bits to use for the map & rootdir (root dir = 2048
//  bytes, and min size to map out at start of disc to protect the boot sector
   fmt->rootdirsize=2048;
   dirsectors = (fmt->SecSize>=fmt->rootdirsize)?1:(fmt->rootdirsize/fmt->SecSize);
   zonesectors =(fmt->bigdir)? 0:dirsectors;
   zonesectors += 2*(fmt->zonec);

   fmt->bootsecbits = 0xe00/fmt->SecSize;
   if(0xe00%fmt->SecSize)fmt->bootsecbits +=1;
   if(shift>=0)  // 1 or more sectors/mapbit
   {
     fmt->dirbits = dirsectors >> shift;
     fmt->mapbits = zonesectors >> shift;
     fmt->bootsecbits = fmt->bootsecbits >> shift;
     // round up to integer count above if needed
     if(shift!=0)if ( dirsectors%(1<<shift)) fmt->dirbits++;
     if(shift!=0)if (zonesectors%(1<<shift)) fmt->mapbits++;
   }
   else          // more than 1 mapbits/sector
   {
     fmt->dirbits = dirsectors  << (-shift);
     fmt->mapbits = zonesectors << (-shift);
     fmt->bootsecbits = fmt->bootsecbits << (-shift);
   }
//  ensure these are at least min length
   if(fmt->bootsecbits < (fmt->idlen+1)) fmt->bootsecbits = (fmt->idlen+1);
   if(fmt->mapbits<(fmt->idlen+1)) fmt->mapbits=(fmt->idlen+1);
   if(fmt->dirbits<(fmt->idlen+1)) fmt->dirbits=(fmt->idlen+1);

// compute sharesize
   fmt->newsharesize=0;
   if((fmt->bigdisc>0)&&(fmt->log2bpmb>12))fmt->newsharesize=fmt->log2bpmb-12;
   sharesize=1<<fmt->newsharesize;

// compute expected root dir disc address
   if(fmt->bigdir==0)
   {
     fmt->newrootaddress = 0x201+(((2*(fmt->zonec))+sharesize-1)/sharesize);
     fmt->rootdiradd=(((2*(fmt->zonec))+sharesize-1)/sharesize)*sharesize;
   }
   else
   {
     // mapzone*ids/zone +1
     fmt->newrootaddress =1+((((fmt->zonec)/2)*fmt->fragmentzonenorm)<<8);
     // rootdiradd is in sectors
     // go past map zones, modulo sharesize
     // and go to whole 'bits per map bit' offset if multiple sector)
     fmt->rootdiradd=fmt->mapbits<<(fmt->log2bpmb-fmt->log2secsize);
   }
   fmt->zonecount=fmt->zonec;fmt->zonecount2=fmt->zonec>>8;
   // suggest a head/cylinder/spt setup
   CHSRound(fmt->cyls,fmt->heads,fmt->spt,fmt->SecCount);

}
@


1.3
log
@   progress, bug fixes, and improved diagnostics
Detail:
  still needs optimisation of formatter element
Admin:


Version 0.11. Tagged as 'PartMan-0_11'
@
text
@a78 9
//   do
//   {
//     heads++;
//     cyls=discsize/heads;
//     secs=63;
//     while(cyls%secs) secs--;
//     cyls=cyls/secs;
//
//   } while((cyls>65535)&&(heads>255));
a80 3



d174 1
a174 1
   if((map = (char*)calloc((SecSize*fa.zonecount),1))== NULL)
d184 1
a184 1
   for(k=0; k<fa.zonecount;k++)
d234 1
a234 1
       map[3+base] = (fa.zonecount&1)?0xff:0x00; // ensure EOR of all Zonechecks -> 0xff
d238 1
a238 1
       if((k == fa.zonecount/2))    // write map adding in root dir allocation
d261 1
a261 1
              (k == fa.zonecount-1)?(fa.endzonebits):
d263 1
a263 1
//testprint("Sk:%x ",skew);
d272 6
a277 6
   wimp_error( SecWrite(ID, AccessKey, map, SecSize*fa.zonecount, fa.mapbase+BaseOffset,  SecSize));
   wimp_error( SecWrite(ID, AccessKey, map, SecSize*fa.zonecount, fa.mapbase+fa.zonecount+BaseOffset,  SecSize));
 testprint ("End of map at %x\n rootdir at %x\n",fa.mapbase+fa.zonecount+fa.zonecount+BaseOffset,fa.mapbase+fa.rootdiradd+BaseOffset);
 testsave ("map",(char*)(map),SecSize*fa.zonecount);
   if(map != NULL) free(map);
   if(tfbuf != NULL) free(tfbuf);
d280 1
a280 1
   if((map = (char*)calloc(0x800,1))== NULL)
d386 1
a386 1
   if(map != NULL) free(map);
d397 1
a397 1
  unsigned int tmp,idmaxlen,MaxFragments,MaxZones,zonec,MinZones;
d411 3
a413 3
  fmt->zonecount = MinZones;   		//  minzones!!
  fmt->zonecount2= MinZones>>8;   	//  minzones!!
  zonec=fmt->zonecount+(fmt->zonecount2<<8);
d429 1
a429 1
     || (fmt->fragmentcount<=(zonec*8))              // too many zones
d441 1
a441 1
    if(zonec< MaxZones-1)
d443 2
a444 2
      zonec++;
   //testprint("zc:%x ",zonec);
d448 1
a448 1
      zonec=MinZones; // reset zonecount
d470 2
a471 2
    fmt->zonecount=zonec;
    fmt->zonecount2=zonec>>8;
d475 2
a481 1
// testprint("\n Z0cap %x Zcap %x",zone0cap,zonecap);
d483 1
a483 1
  testprint("\nbefore: zs %x endzs %x",(int)fmt->zonespare,(int)fmt->endzonebits);
d525 2
a526 2
    cc=sum += *((char*)boot + i);
    if(last!=*((char*)boot + i))same=1; // flag that sector is not all ientical
d531 1
a531 2
  return (unsigned char)
         (sum);
a610 1

d617 1
a617 1
   MaxZones=(fmt->bigdir>1)?MaxZonesBigDir:MaxZonesNormalDir;
d621 3
a623 3
   fmt->fragmentzone0 = ((fmt->SecSize-4-60)*8)/(fmt->idlen+1);
   fmt->zone0sparefound=((fmt->SecSize-4-60)*8)%(fmt->idlen+1);
   fmt->zone0sparefound+=4*8;
d627 2
a628 2
   fmt->zonesparefound=    ((fmt->SecSize-4)*8)%(fmt->idlen+1);
   fmt->zonesparefound+=4*8;
d653 1
a653 1
   fmt->fragmentcount = allocunits/(fmt->idlen+1);
d657 1
a657 1
   if(fmt->zonecount==1)
d661 1
a661 1
   if(fmt->zonecount==2)
d666 1
a666 1
   if(fmt->zonecount>2)
d670 1
a670 1
                            -((fmt->zonecount-2)*fmt->fragmentzonenorm);
d672 1
a672 1
   fmt->endzonebits = (fmt->fragmentzonelast * (fmt->idlen+1))+fmt->fragmentmissed;
d674 1
d676 5
a680 4
   fmt->mapbase = (((fmt->zonecount/2)-1) * (fmt->fragmentzonenorm*(fmt->idlen+1)))
                + (fmt->fragmentzone0*(fmt->idlen+1))
                + (((fmt->zonecount/2)-1) * (fmt->zonesparefound-fmt->zonespare))
                + (fmt->zone0sparefound-fmt->zonespare);
d691 2
a692 2
// compute number of alloc bits to use for the map & rootdir (root dir = 2048 bytes)
//  and compute min size to map out at start of disc to protect the boot sector
d695 2
a696 2
   zonesectors =(fmt->bigdir==0)? dirsectors:0;
   zonesectors += 2*fmt->zonecount;
d699 1
a699 1
   if((0xe00%fmt->SecSize)>0)fmt->bootsecbits +=1;
d706 2
a707 2
     if(shift!=0)if ( (dirsectors%(1<<shift)) !=0)fmt->dirbits++;
     if(shift!=0)if ((zonesectors%(1<<shift) )!=0)fmt->mapbits++;
d711 1
a711 1
     fmt->dirbits = dirsectors << (-shift);
d716 1
a716 1
   if(fmt->bootsecbits <(fmt->idlen+1))fmt->bootsecbits =(fmt->idlen+1);
d722 1
a722 5
   if((fmt->bigdisc>0)&&(fmt->log2bpmb>12))
   {
     fmt->newsharesize=fmt->log2bpmb-12;
   }
//   if((fmt->bigdisc>0)&&(fmt->newsharesize<4)&&((fmt->zonecount>>fmt->newsharesize)>MaxZones))fmt->newsharesize++;
d728 2
a729 2
     fmt->newrootaddress = 0x201 + (((2*fmt->zonecount) + sharesize-1)/sharesize);
     fmt->rootdiradd=(((2*fmt->zonecount) + sharesize-1)/sharesize)*sharesize;
d734 1
a734 2

     fmt->newrootaddress =1+(((fmt->zonecount/2)*fmt->fragmentzonenorm)<<8);
a738 1

d740 1
a740 2
// compute plausible heads & spt

a742 11
//   fmt->heads=16;   // initialise
//   do
//   {
//     fmt->heads++;
//     fmt->cyls=fmt->SecCount/fmt->heads;
//     fmt->spt=63;
//     while(fmt->cyls%fmt->spt) fmt->spt--;
//     fmt->cyls=fmt->cyls/fmt->spt;
//
//   } while((fmt->cyls>65535)&&(fmt->heads>255));
//   testprint("heads %d, cyls %d, secs %d\n",fmt->heads,fmt->cyls,fmt->spt);
@


1.2
log
@  Rounded up a couple of 'zero pains'
Detail:
  Some list checkers produce a null at the end. A couple of routines
  needed to be more robust...
Admin:


Version 0.10. Tagged as 'PartMan-0_10'
@
text
@d42 1
a42 1
testprint5("FW: mapsec:%x pos:%x id:%x len:%x idlen%x\n",(int)mapsector,position,FragmentID,FragmentLen,IDlen);
d88 1
a88 1
   testprint4(" suggested heads %d, cyls %d, secs %d giving disk size %x\n",fa.heads,fa.cyls,fa.spt,fa.SecCount);
d104 1
a104 1
  testprint2("\n tfbuf:%x boot:%x  ",(int)tfbuf,(int)boot);
d179 1
a179 1
   testprint2("base offset %x at boot sector write, discname %s\n",BaseOffset,(int)newname);
d223 1
a223 1
  testprint2("\n bytes for base %x, boff %x ",(int)(boff*(1<<fa.log2bpmb)),boff);
d225 1
a225 1
  testprint1("\n boff %x ",(int)(boff));
d232 1
a232 1
  testprint1("\n boff %x ",(int)(boff));
d235 1
a235 1
  testprint1("\nmarking bit: %x ",(int)i);
d243 1
a243 1
  testprint1("\nskew: %x ",(int)skew);
d256 1
a256 1
 testprint2("root zone offset %x.. starting freelink at %x\n",k*SecSize,i);
d267 1
a267 1
 testprint1("setting freelink to %x\nrootdirzone\n",i);
d275 1
a275 1
//testprint1("Sk:%x ",skew);
d286 1
a286 1
 testprint2 ("End of map at %x\n rootdir at %x\n",fa.mapbase+fa.zonecount+fa.zonecount+BaseOffset,fa.mapbase+fa.rootdiradd+BaseOffset);
d395 1
a395 1
 testprint1("rootdiradd=%x\n",fa.mapbase+fa.rootdiradd+BaseOffset);
d456 1
a456 1
   //testprint1("zc:%x ",zonec);
d464 1
a464 1
    //testprint1("\nidl:%x ",fmt->idlen);
d478 1
a478 1
   testprint1("\nl2bmb:%x ",fmt->log2bpmb);
d492 1
a492 1
// testprint2("\n Z0cap %x Zcap %x",zone0cap,zonecap);
d494 1
a494 1
  testprint2("\nbefore: zs %x endzs %x",(int)fmt->zonespare,(int)fmt->endzonebits);
d771 1
a771 1
//   testprint3("heads %d, cyls %d, secs %d\n",fmt->heads,fmt->cyls,fmt->spt);
@


1.1
log
@Initial revision
@
text
@d35 1
d77 1
a77 9
   int discsize = SecCount;
   int heads=16, secs=63,cyls=0;  // initialise
   do
   {
     heads++;
     cyls=discsize/heads;
     secs=63;
     while(cyls%secs) secs--;
     cyls=cyls/secs;
d79 10
a88 2
   } while((cyls>65535)&&(heads>255));
   testprint3(" suggested heads %d, cyls %d, secs %d\n",heads,cyls,secs);
d95 1
a95 1
 sprintf(map,"AFmt id   %x key %x size %x BaseOff %x SC %x bigdir %d\n",ID,AccessKey,SecSize,BaseOffset,SecCount,bigdir);
d120 5
a124 5
   //while((*(defect+k)>0)&&(*(defect+k)<(0x1fffffff>>fa.log2secsize)))
   //{
   //  boot->defects[k] = *(defect+k)<<fa.log2secsize;
   //  k++;
   //}
d128 5
a132 5
    // while(*(defect+k)>0)
    // {
    //   boot->defects[k+1] = *(defect+k);
    //   k++;
    // }
d205 1
a205 1
     while((*defect>0)&&(*defect>=zonestart)&&(*defect<zoneend))
d759 12
a770 11
// suggest a head/cylinder/spt setup
   fmt->heads=16;   // initialise
   do
   {
     fmt->heads++;
     fmt->cyls=fmt->SecCount/fmt->heads;
     fmt->spt=63;
     while(fmt->cyls%fmt->spt) fmt->spt--;
     fmt->cyls=fmt->cyls/fmt->spt;

   } while((fmt->cyls>65535)&&(fmt->heads>255));
@


1.1.1.1
log
@  Initial import of PartMan module
Detail:
  This is early work. It can be used 'manually' to format up a disc using
  the GPT partition header system. Current working format is filecore, though
  with a non optimal format. Functional, but work in progress.
Admin:
@
text
@@

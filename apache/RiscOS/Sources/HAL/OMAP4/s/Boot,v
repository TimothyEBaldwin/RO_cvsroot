head	1.33;
access;
symbols
	OMAP4-0_60:1.33
	OMAP4-0_59-1_52_2_3:1.29.2.3
	OMAP4-0_59:1.32
	OMAP4-0_58:1.32
	OMAP4-0_57:1.31
	OMAP4-0_56:1.31
	OMAP4-0_55:1.30
	OMAP4-0_54-1_52_2_2:1.29.2.2
	OMAP4-0_54:1.30
	OMAP4-0_53:1.29
	OMAP4-0_52-1_52_2_1:1.29.2.1
	SMP:1.29.0.2
	SMP_bp:1.29
	OMAP4-0_52:1.29
	OMAP4-0_51:1.29
	OMAP4-0_50:1.28
	OMAP4-0_49:1.27
	OMAP4-0_48:1.27
	OMAP4-0_47:1.26
	OMAP4-0_46:1.25
	OMAP4-0_45:1.25
	OMAP4-0_44:1.25
	OMAP4-0_43:1.24
	OMAP4-0_42:1.24
	OMAP4-0_41:1.24
	OMAP4-0_40:1.23
	OMAP4-0_39:1.22
	OMAP4-0_38:1.21
	OMAP4-0_37:1.21
	OMAP4-0_36:1.20
	OMAP4-0_35:1.19
	OMAP4-0_34:1.19
	OMAP4-0_33:1.19
	OMAP4-0_32:1.19
	OMAP4-0_31:1.19
	OMAP4-0_30:1.19
	OMAP4-0_29:1.19
	OMAP4-0_28:1.18
	OMAP4-0_27:1.17
	OMAP4-0_26:1.16
	OMAP4-0_25:1.16
	OMAP4-0_24:1.15
	OMAP4-0_23:1.15
	OMAP4-0_22:1.14
	OMAP4-0_21:1.14
	OMAP4-0_20:1.14
	OMAP4-0_19:1.13
	OMAP4-0_18:1.12
	OMAP4-0_17:1.11
	OMAP4-0_16:1.10
	OMAP4-0_15:1.9
	OMAP4-0_14:1.8
	OMAP4-0_13:1.8
	OMAP4-0_12:1.7
	OMAP4-0_11:1.6
	OMAP4-0_10:1.5
	OMAP4-0_09:1.4
	OMAP4-0_08:1.4
	OMAP4-0_07:1.4
	OMAP4-0_06:1.3
	OMAP4-0_05:1.2
	OMAP4-0_04:1.1.1.1
	OMAP4-0_03:1.1.1.1
	OMAP4-0_02:1.1.1.1
	OMAP4-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.33
date	2018.07.07.14.46.31;	author jlee;	state Exp;
branches;
next	1.32;
commitid	IdpQqfjTDGJUldJA;

1.32
date	2018.04.01.21.25.23;	author rsprowson;	state Exp;
branches;
next	1.31;
commitid	DGu4k0OhERg3GMwA;

1.31
date	2018.03.30.07.56.36;	author rsprowson;	state Exp;
branches;
next	1.30;
commitid	LAp0FHnJajEzgswA;

1.30
date	2017.09.09.10.50.36;	author rool;	state Exp;
branches;
next	1.29;
commitid	ONjvDfN94I0QIv6A;

1.29
date	2016.05.06.21.41.51;	author jlee;	state Exp;
branches
	1.29.2.1;
next	1.28;
commitid	kj2dniyIsLwM6t5z;

1.28
date	2016.01.16.09.02.05;	author rool;	state Exp;
branches;
next	1.27;
commitid	8dCQBlKKcU1jt8Ry;

1.27
date	2015.12.19.09.46.24;	author rool;	state Exp;
branches;
next	1.26;
commitid	iqiMyeOD9jOkCxNy;

1.26
date	2015.09.01.21.22.45;	author rool;	state Exp;
branches;
next	1.25;
commitid	wG3IDGBgTDRpYAzy;

1.25
date	2015.04.08.07.33.53;	author rsprowson;	state Exp;
branches;
next	1.24;
commitid	ziZUYwsqx4235Lgy;

1.24
date	2015.01.11.23.15.07;	author jlee;	state Exp;
branches;
next	1.23;
commitid	vaUEn7syNuKk5F5y;

1.23
date	2014.12.21.10.17.19;	author rsprowson;	state Exp;
branches;
next	1.22;
commitid	UOamvdRbreJnsT2y;

1.22
date	2014.12.06.09.18.19;	author rsprowson;	state Exp;
branches;
next	1.21;
commitid	Se8WzhsroxnXBX0y;

1.21
date	2014.10.25.17.47.13;	author rsprowson;	state Exp;
branches;
next	1.20;
commitid	eUvY0kdCylOiMBVx;

1.20
date	2014.09.04.21.41.12;	author jlee;	state Exp;
branches;
next	1.19;
commitid	AjMWLbVyJ9pcI4Px;

1.19
date	2014.03.09.09.44.54;	author rsprowson;	state Exp;
branches;
next	1.18;
commitid	sHn8PVob0xicv0sx;

1.18
date	2014.03.08.16.55.57;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	tpkfnWqSEp73VUrx;

1.17
date	2013.12.15.22.47.22;	author jlee;	state Exp;
branches;
next	1.16;
commitid	cmuaDr9qMOE2xhhx;

1.16
date	2013.11.12.21.13.50;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	shNC1iEaRRcJ42dx;

1.15
date	2013.11.01.19.01.19;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	3j2IHKaDTdkbHBbx;

1.14
date	2013.09.02.20.50.55;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	JoqxfvCSt5omeU3x;

1.13
date	2013.09.01.17.37.22;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	GLy09A6uBpnXbL3x;

1.12
date	2013.08.17.13.15.01;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	PyZVfvLeTl0RdO1x;

1.11
date	2013.08.15.13.49.09;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	HeOil151Spdxty1x;

1.10
date	2013.04.13.08.40.34;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	dmbT4ciXHqpNKALw;

1.9
date	2013.04.10.21.15.50;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	qm7wa7AC4tnS1hLw;

1.8
date	2013.01.22.23.26.19;	author jlee;	state Exp;
branches;
next	1.7;
commitid	hs6r3ZZoTSm6ggBw;

1.7
date	2012.07.09.07.22.42;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	Z61ud2LzYYd8gRbw;

1.6
date	2012.07.04.17.59.09;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	7eFD0kniLkapWgbw;

1.5
date	2012.07.03.23.09.03;	author bavison;	state Exp;
branches;
next	1.4;
commitid	0Wfi25ZdrHiIGabw;

1.4
date	2012.03.25.11.42.57;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	4FjnaYBzkPTA6gYv;

1.3
date	2012.03.25.10.28.46;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	wcxutstPODhaHfYv;

1.2
date	2012.02.11.17.48.09;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	W3PfhFs2h9uBvLSv;

1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;
commitid	M3eV6gzJuoHHMezv;

1.29.2.1
date	2017.07.29.11.55.49;	author jlee;	state Exp;
branches;
next	1.29.2.2;
commitid	tNqXOj5HJ9lUq71A;

1.29.2.2
date	2017.09.10.11.38.49;	author jlee;	state Exp;
branches;
next	1.29.2.3;
commitid	XS2rGzzvdYrnXD6A;

1.29.2.3
date	2018.07.07.14.32.13;	author jlee;	state Exp;
branches;
next	;
commitid	0eMRUMdd3I00hdJA;

1.1.1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches;
next	;
commitid	M3eV6gzJuoHHMezv;


desc
@@


1.33
log
@Merge SMP branch to trunk
Detail:
  Makefile, s/DBell - Add doorbell HAL device implementation, using GIC SGIs
  hdr/StaticWS, hdr/omap4430 - Tidy things up a bit by removing the DebugInterrupts code.
  hdr/omap4_reg - Offset all the shared interrupt numbers so that RISC OS IRQs 0-31 are core 0 private, 32-63 core 1 private, 64-159 shared
  s/Boot - Implement SMP ARMops
  s/Interrupts - Tidy up interrupt handling and implement new HAL IRQ calls
Admin:
  Untested
  Requires Kernel-6_09


Version 0.60. Tagged as 'OMAP4-0_60'
@
text
@; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:HALSize.<HALSize>

        GET     Hdr:MEMM.VMSAv6

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.omap4430
        GET     hdr.StaticWS
        GET     hdr.SDRC
        GET     hdr.Interrupts
        GET     hdr.Timers
        GET     hdr.GPIO
        GET     hdr.UART
        GET     hdr.PRCM
        GET     hdr.GPMC

; This version assumes a RISC OS image starting OSROM_HALSize after us.

; FIQs are not available on Cortex-A9 (outside the secure world)
; FIQ-based debugger - prints out the PC when the beagleboard/touchbook USER button is pressed
; The code installs itself when HAL_InitDevices is called with R0=123.
; e.g. SYS "OS_Hardware",123,,,,,,,,0,100
                GBLL    FIQDebug
FIQDebug        SETL    {FALSE}

                GBLL    MoreDebug
MoreDebug       SETL    Debug :LAND: {FALSE}

                GBLL    UseSR44x
UseSR44x        SETL    {TRUE}

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  rom_checkedout_ok

        IMPORT  HAL_Base
        IMPORT  RTC_Init
        IMPORT  SR44x_Init
        IMPORT  SR44x_Exit
        IMPORT  PowerCtrl_Init
        IMPORT  PowerCtrl_SwitchOff

; v8 is used as pointer to RISC OS entry table throughout pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

rom_checkedout_ok
        ; On entry, v8 -> OS entry table, sb -> board config
        ; Register the attached RAM

        LDR     v1, =DMM_Base
        MOV     sp, #0
        ; Check all DMM_LISA_MAP_i registers (starting with highest priority)
        LDR     a1, =DMM_LISA_MAP_3
        LDR     a4, =DMM_LISA_MAP_i_SDRC_ADDRSPC
05
        LDR     a2, =DMM_LISA_MAP_i_SDRC_MAP
        LDR     a3, [v1, a1]
        ANDS    a2, a3, a2      ; MAP_x used ?
        BEQ     %FT10
        AND     a2, a3, a4      ; check ADDRSPC
        CMP     a2, #DMM_LISA_MAP_i_SDRC_ADDRSPC_SDRAM
        BEQ     %FT15
10
        ; Next DMM_LISA_MAP_x
        CMP     a1, #DMM_LISA_MAP_0
        SUBHI   a1, a1, #4
        BHI     %BT05

        ; This should not happen: no RAM found
        B       .
15
        ; Check DMM_LISA_MAP_x
        LDR     a2, =DMM_LISA_MAP_i_SYS_SIZE
        AND     a2, a3, a2
        MOV     a2, a2, LSR #DMM_LISA_MAP_i_SYS_SIZE_SHIFT
        LDR     a4, =(16 * 1024 * 1024) ; 16 MiB smallest size
        MOV     a4, a4, LSL a2          ; final size
        AND     a2, a3, #DMM_LISA_MAP_i_SYS_ADDR
        ; Check for overflow of address range
        ADDS    a3, a4, a2
        LDRCS   a3, =((4096 - 16) << 20)        ; round down to next 16 MiB boundary
        LDR     a4, =&FFFFFFFF
        ADD     sp, a2, #4096 ; HAL spec says that (for software reset compliance only?) stack should be 4K into first block
        MOV     a1, #0
        STR     a1, [sp, #-4]!
        CallOSM OS_AddRAM
        DebugChar a3,a2,71

        ; Check for reset cause: test PRM_RSTST.GLOBAL_COLD_RST
        LDR     a3, =L4_PowerMan
        ADD     a3, a3, #DEVICE_PRM
        LDR     a2, [a3, #PRM_RSTST]
        STR     a2, [a3, #PRM_RSTST]    ; clear old status
        TST     a2, #1                  ; GLOBAL_COLD_RST
        MOV     a4, a1
        MOVNE   a1, #(OSStartFlag_RAMCleared :OR: OSStartFlag_POR)
        MOVEQ   a1, #OSStartFlag_RAMCleared
        ADRL    a2, HAL_Base + OSROM_HALSize    ; a2 -> RISC OS image
        ADR     a3, HALdescriptor
        CallOSM OS_Start


HALdescriptor   DATA
        DCD     HALFlag_NCNBWorkspace
        DCD     HAL_Base - HALdescriptor
        DCD     OSROM_HALSize
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     HAL_WsSize


        MACRO
        HALEntry $name
        ASSERT  (. - HAL_EntryTable) / 4 = EntryNo_$name
        DCD     $name - HAL_EntryTable
        MEND

        MACRO
        NullEntry
        DCD     HAL_Null - HAL_EntryTable
        MEND

        IMPORT  Video_Init
        IMPORT  Interrupt_Init
        IMPORT  Timer_Init
        IMPORT  PRCM_SetClocks
        IMPORT  USB_Init
        IMPORT  I2C_Init
        IMPORT  SDMA_Init
        IMPORT  VideoDevice_Init
        IMPORT  Audio_Init
        IMPORT  GPMC_Init
        IMPORT  GPIO_Init
        IMPORT  GPIOx_SetAsOutput
        IMPORT  GPIO_InitDevices
        IMPORT  SDIO_InitDevices
        IMPORT  NVMemory_Init
        IMPORT  NVMemory_InitDevice
        IMPORT  PL310_InitDevice
        IMPORT  DBell_InitDevices

        EXPORT  Board_InitDevices_None
        EXPORT  Board_InitDevices_Panda

        IMPORT  HAL_IRQEnable
        IMPORT  HAL_IRQDisable
        IMPORT  HAL_IRQClear
        IMPORT  HAL_IRQSource
        IMPORT  HAL_IRQStatus
        IMPORT  HAL_FIQEnable
        IMPORT  HAL_FIQDisable
        IMPORT  HAL_FIQDisableAll
        IMPORT  HAL_FIQClear
        IMPORT  HAL_FIQSource
        IMPORT  HAL_FIQStatus
        IMPORT  HAL_IRQMax
        IMPORT  HAL_IRQProperties
        IMPORT  HAL_IRQSetCores
        IMPORT  HAL_IRQGetCores

        IMPORT  HAL_Timers
        IMPORT  HAL_TimerDevice
        IMPORT  HAL_TimerGranularity
        IMPORT  HAL_TimerMaxPeriod
        IMPORT  HAL_TimerSetPeriod
        IMPORT  HAL_TimerPeriod
        IMPORT  HAL_TimerReadCountdown
        IMPORT  HAL_TimerIRQClear

        IMPORT  HAL_CounterRate
        IMPORT  HAL_CounterPeriod
        IMPORT  HAL_CounterRead
        IMPORT  HAL_CounterDelay

        IMPORT  HAL_IICBuses
        IMPORT  HAL_IICType
        IMPORT  HAL_IICDevice
        IMPORT  HAL_IICTransfer
        IMPORT  HAL_IICMonitorTransfer

        IMPORT  HAL_NVMemoryType
        IMPORT  HAL_NVMemorySize
        IMPORT  HAL_NVMemoryPageSize
        IMPORT  HAL_NVMemoryProtectedSize
        IMPORT  HAL_NVMemoryProtection
        IMPORT  HAL_NVMemoryRead
        IMPORT  HAL_NVMemoryWrite

        IMPORT  HAL_VideoIICOp ; Implemented in s.I2C

        IMPORT  HAL_UARTPorts
        IMPORT  HAL_UARTStartUp
        IMPORT  HAL_UARTShutdown
        IMPORT  HAL_UARTFeatures
        IMPORT  HAL_UARTReceiveByte
        IMPORT  HAL_UARTTransmitByte
        IMPORT  HAL_UARTLineStatus
        IMPORT  HAL_UARTInterruptEnable
        IMPORT  HAL_UARTRate
        IMPORT  HAL_UARTFormat
        IMPORT  HAL_UARTFIFOSize
        IMPORT  HAL_UARTFIFOClear
        IMPORT  HAL_UARTFIFOEnable
        IMPORT  HAL_UARTFIFOThreshold
        IMPORT  HAL_UARTInterruptID
        IMPORT  HAL_UARTBreak
        IMPORT  HAL_UARTModemControl
        IMPORT  HAL_UARTModemStatus
        IMPORT  HAL_UARTDevice
        IMPORT  HAL_UARTDefault

        IMPORT  HAL_DebugRX
        IMPORT  HAL_DebugTX

        IMPORT  HAL_KbdScanDependencies

        IMPORT  HAL_USBControllerInfo

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource
        HALEntry HAL_IRQStatus
        HALEntry HAL_FIQEnable
        HALEntry HAL_FIQDisable
        HALEntry HAL_FIQDisableAll
        HALEntry HAL_FIQClear
        HALEntry HAL_FIQSource
        HALEntry HAL_FIQStatus

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        HALEntry HAL_NVMemoryType
        HALEntry HAL_NVMemorySize
        HALEntry HAL_NVMemoryPageSize
        HALEntry HAL_NVMemoryProtectedSize
        HALEntry HAL_NVMemoryProtection
        NullEntry ; HAL_NVMemoryIICAddress
        HALEntry HAL_NVMemoryRead
        HALEntry HAL_NVMemoryWrite

        HALEntry HAL_IICBuses
        HALEntry HAL_IICType
        NullEntry ; HAL_IICSetLines
        NullEntry ; HAL_IICReadLines
        HALEntry HAL_IICDevice
        HALEntry HAL_IICTransfer
        HALEntry HAL_IICMonitorTransfer

        NullEntry ; HAL_VideoFlybackDevice
        NullEntry ; HAL_VideoSetMode
        NullEntry ; HAL_VideoWritePaletteEntry
        NullEntry ; HAL_VideoWritePaletteEntries
        NullEntry ; HAL_VideoReadPaletteEntry
        NullEntry ; HAL_VideoSetInterlace
        NullEntry ; HAL_VideoSetBlank
        NullEntry ; HAL_VideoSetPowerSave
        NullEntry ; HAL_VideoUpdatePointer
        NullEntry ; HAL_VideoSetDAG
        NullEntry ; HAL_VideoVetMode
        NullEntry ; HAL_VideoPixelFormats
        NullEntry ; HAL_VideoFeatures
        NullEntry ; HAL_VideoBufferAlignment
        NullEntry ; HAL_VideoOutputFormat

        HALEntry HAL_IRQProperties
        HALEntry HAL_IRQSetCores
        HALEntry HAL_IRQGetCores
        HALEntry HAL_CPUCount
        HALEntry HAL_CPUNumber
        HALEntry HAL_SMPStartup

        HALEntry HAL_MachineID

        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo
        HALEntry HAL_PlatformInfo
        NullEntry ; HAL_CleanerSpace

        HALEntry HAL_UARTPorts
        HALEntry HAL_UARTStartUp
        HALEntry HAL_UARTShutdown
        HALEntry HAL_UARTFeatures
        HALEntry HAL_UARTReceiveByte
        HALEntry HAL_UARTTransmitByte
        HALEntry HAL_UARTLineStatus
        HALEntry HAL_UARTInterruptEnable
        HALEntry HAL_UARTRate
        HALEntry HAL_UARTFormat
        HALEntry HAL_UARTFIFOSize
        HALEntry HAL_UARTFIFOClear
        HALEntry HAL_UARTFIFOEnable
        HALEntry HAL_UARTFIFOThreshold
        HALEntry HAL_UARTInterruptID
        HALEntry HAL_UARTBreak
        HALEntry HAL_UARTModemControl
        HALEntry HAL_UARTModemStatus
        HALEntry HAL_UARTDevice
        HALEntry HAL_UARTDefault

        HALEntry HAL_DebugRX
        HALEntry HAL_DebugTX

        NullEntry ; HAL_PCIFeatures
        NullEntry ; HAL_PCIReadConfigByte
        NullEntry ; HAL_PCIReadConfigHalfword
        NullEntry ; HAL_PCIReadConfigWord
        NullEntry ; HAL_PCIWriteConfigByte
        NullEntry ; HAL_PCIWriteConfigHalfword
        NullEntry ; HAL_PCIWriteConfigWord
        NullEntry ; HAL_PCISpecialCycle
        NullEntry ; HAL_PCISlotTable
        NullEntry ; HAL_PCIAddresses

        HALEntry HAL_PlatformName
        NullEntry ; Unused
        NullEntry ; Unused

        HALEntry HAL_InitDevices

        HALEntry HAL_KbdScanDependencies
        NullEntry ; Unused
        NullEntry ; Unused
        NullEntry ; Unused

        HALEntry HAL_PhysInfo

        HALEntry HAL_Reset

        HALEntry HAL_IRQMax

        HALEntry HAL_USBControllerInfo
        NullEntry ; HAL_USBPortPower
        NullEntry ; HAL_USBPortIRQStatus
        NullEntry ; HAL_USBPortIRQClear
        NullEntry ; HAL_USBPortDevice
        
        HALEntry HAL_TimerIRQClear
        NullEntry ; HAL_TimerIRQStatus

        HALEntry HAL_ExtMachineID

        NullEntry ; HAL_VideoFramestoreAddress
        NullEntry ; HAL_VideoRender
        NullEntry ; HAL_VideoStartupMode
        NullEntry ; HAL_VideoPixelFormatList
        HALEntry HAL_VideoIICOp

HAL_Entries     *       (. - HAL_EntryTable) / 4


;--------------------------------------------------------------------------------------


HAL_Init
        Entry   "v1-v3"

        STR     a2, NCNBWorkspace
        STR     a2, NCNBAllocNext
 
        BL      SetUpOSEntries

        ; Map in the main IO ranges (L3, L4) and then store the offsets to the components
        ; we're interested in
        MOV     a1, #0
        LDR     a2, =L3_ABE
        MOV     a3, #L3_ABE_Size
        CallOS  OS_MapInIO
        STR     a1, L3_Log

        MOV     a1, #0
        LDR     a2, =L4_ABE
        MOV     a3, #L4_ABE_Size
        CallOS  OS_MapInIO
        STR     a1, L4_ABE_Log

        ; Timers
        ADD     a2, a1, #(TIMER_BASE - L4_ABE)
        STR     a2, Timers_Log

        MOV     a1, #0
        LDR     a2, =L4_Core
        MOV     a3, #L4_Core_Size
        CallOS  OS_MapInIO
        STR     a1, L4_Core_Log

        ; ClockMan + ClockMan2
        ADD     a3, a1, #(L4_ClockMan - L4_Core)
        STR     a3, L4_ClockMan_Log
        ADD     a3, a1, #(L4_ClockMan2 - L4_Core)
        STR     a3, L4_ClockMan2_Log

        ; USB
        ADD     a3, a1, #(L4_USBTLL - L4_Core)
        STR     a3, L4_USBTLL_Log
        ADD     a3, a1, #(L4_USB_Host - L4_Core)
        STR     a3, L4_USB_Host_Log
        ADD     a3, a1, #(L4_USB_OTG - L4_Core)
        STR     a3, L4_USB_OTG_Log

        ; DMA
        ADD     a3, a1, #(L4_sDMA - L4_Core)
        STR     a3, L4_sDMA_Log

        MOV     a1, #0
        LDR     a2, =L4_Wakeup
        MOV     a3, #L4_Wakeup_Size
        CallOS  OS_MapInIO
        STR     a1, L4_Wakeup_Log

        ; L4_PowerMan, L4_32KTIMER, L4_GPIO1
        ADD     a3, a1, #(L4_PowerMan - L4_Wakeup)
        STR     a3, L4_PowerMan_Log
        ADD     a3, a1, #(L4_32KTIMER - L4_Wakeup)
        STR     a3, L4_32KTIMER_Log
        ADD     a3, a1, #(L4_GPIO1 - L4_Wakeup)
        STR     a3, L4_GPIO1_Log

        MOV     a1, #0
        LDR     a2, =L4_Per
        MOV     a3, #L4_Per_Size
        CallOS  OS_MapInIO
        STR     a1, L4_Per_Log

; this address range is only for backward compatibility !
; TI recommends using the DSS address range
;       ; Display
;       ADD     a3, a1, #(L4_Display - L4_Per)
;       STR     a3, L4_Display_Log

        ; GPIO2-6
        ADD     a2, a1, #(L4_GPIO2 - L4_Per)
        STR     a2, L4_GPIO2_Log
        ADD     a2, a1, #(L4_GPIO3 - L4_Per)
        STR     a2, L4_GPIO3_Log
        ADD     a2, a1, #(L4_GPIO4 - L4_Per)
        STR     a2, L4_GPIO4_Log
        ADD     a2, a1, #(L4_GPIO5 - L4_Per)
        STR     a2, L4_GPIO5_Log
        ADD     a2, a1, #(L4_GPIO6 - L4_Per)
        STR     a2, L4_GPIO6_Log

        ; Display subsystem (DSS)
        MOV     a1, #0
        LDR     a2, =DSS_Base
        MOV     a3, #(32 * 1024)
        CallOS  OS_MapInIO
        STR     a1, L4_Display_Log

        ; Interrupt controller
        MOV     a1, #0
        LDR     a2, =MPU_INTC
        MOV     a3, #MPU_INTC_SIZE
        CallOS  OS_MapInIO
        STR     a1, MPU_INTC_Log

        ; GPMC
        MOV     a1, #0
        LDR     a2, =GPMC_Regs
        MOV     a3, #4096 ; only a small register file
        CallOS  OS_MapInIO
        STR     a1, GPMC_Regs_Log

        ; Recover board config from SRAM
        MOV     a1, #0
        LDR     a2, =IntSRAM_Base
        MOV     a3, #IntSRAM_Size
        CallOS  OS_MapInIO
        STR     a1, IntSRAM_Log
        MOV     a2, #BoardConfig_Size
10      SUBS    a2, a2, #4
        LDR     a3, [a1, a2]
        STR     a3, [sb, a2]
        BGT     %BT10
        ; Now do phys -> log conversion on all the addresses contained within
        ; RISC OS doesn't currently provide a phys->log conversion function, so we do it
        ; manually based around the regions that were mapped in above
        ASSERT  BoardConfig_DebugUART = 0
        ASSERT  BoardConfig_DebugUART+4 = BoardConfig_HALUART
        MOV     a1, #(BoardConfig_HALUART + ?BoardConfig_HALUART-4)
10      BL      phys2log
        SUBS    a1, a1, #4
        BGE     %BT10

        ; handle supported I2C interfaces (at most MaxI2CControllers)
        LDRB    v1, [sb, #BoardConfig_NumI2C]
        CMP     v1, #MaxI2CControllers
        MOVGT   v1, #MaxI2CControllers
        ADR     v2, (I2C_Table + I2C_HW)
        MOV     a1, #BoardConfig_HALI2C
10
        BL      phys2log
        STR     a2, [v2], #I2CBlockSize
        ADD     a1, a1, #4
        SUBS    v1, v1, #1
        BGT     %BT10

 [ Debug
        DebugTX "HAL_Init"
        DebugTime a1, "@@ "
 ]

        BL      PRCM_SetClocks  ; Calls Timer_init & starts GPTIMER5

        BL      I2C_Init        ; Uses GPTIMER5

        ; Make sure all GPIO IRQs are disabled before we potentially start enabling them
        BL      GPIO_Init

 [ MoreDebug
        DebugTX "Video_Init"
 ] ; MoreDebug
        BL      Video_Init

 [ MoreDebug
        DebugTX "USB_Init"
 ] ; MoreDebug
        BL      USB_Init

 [ MoreDebug
        DebugTX "NVMemory_Init"
 ] ; MoreDebug
        BL      NVMemory_Init

 [ MoreDebug
        DebugTX "Timer_Init"
 ] ; MoreDebug
        BL      Timer_Init      ; Re-inits timers

 [ MoreDebug
        DebugTX "Interrupt_Init"
 ] ; MoreDebug
        BL      Interrupt_Init

 [ MoreDebug
        DebugTX "GPMC_Init"
 ] ; MoreDebug
        BL      GPMC_Init

        LDRB    v1, [sb, #BoardConfig_NumUART]
10      SUBS    v1, v1, #1
 [ Debug
        BLT     %FT20
        ; Don't reset the debug UART
        LDR     a3, [sb, #BoardConfig_DebugUART]
        ADD     a2, sb, v1, LSL #2
        LDR     a2, [a2, #BoardConfig_HALUART]
        CMP     a3, a2
        BEQ     %BT10
        MOV     a1, v1
        ADR     lr, %BT10
        B       HAL_UARTStartUp
 |
        MOVGE   a1, v1
        ADRGE   lr, %BT10
        BGE     HAL_UARTStartUp
 ]
20

        ; Mark HAL as initialised
        STR     pc, HALInitialised ; Any nonzero value will do

        DebugTime a1, "HAL initialised @@ "

        EXIT

; Dodgy phys->log conversion using the mapped in IO ranges
; In/out: a1 = offset into sb of address to get/put
; Out: a2 = log addr
; Corrupts a3
phys2log
        LDR     a3, [sb, a1]
        CMP     a3, #0 ; Null pointers are valid; ignore them
        MOVEQ   a2, #0
        MOVEQ   pc, lr
        LDR     a2, =L3_ABE
        SUB     a2, a3, a2
        CMP     a2, #L3_ABE_Size
        LDRLO   a3, L3_Log
        BLO     %FT10

        SUB     a2, a3, #L4_Per
        CMP     a2, #L4_Per_Size
        LDRLO   a3, L4_Per_Log
        BLO     %FT10

        SUB     a2, a3, #L4_ABE
        CMP     a2, #L4_ABE_Size
        LDRLO   a3, L4_ABE_Log
        BLO     %FT10

        SUB     a2, a3, #L4_Core
        CMP     a2, #L4_Core_Size
        LDRLO   a3, L4_Core_Log
        SUBHI   a2, a2, #(L4_Wakeup - L4_Core)
        LDRHI   a3, L4_Wakeup_Log
10
        ADD     a2, a2, a3
        STR     a2, [sb, a1]
        MOV     pc, lr

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #(HighestOSEntry + 1)
        MOVHI   a2, #(HighestOSEntry + 1)

        ADR     a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05
        ; Fall through

HAL_Null
        MOV     pc, lr

HAL_InitDevices
 [ FIQDebug
        CMP     a1, #123
        BNE     %FT10
        LDR     a1, =&E51FF004
        ADR     a2, FIQRoutine
        MOV     a4, #&1C
        STMIA   a4,{a1-a2,sb}
        ; Sync cache
        MOV     a1, #0
        MCR     p15, 0, a1, c7, c11, 1 ; Clean DCache by VA to PoU
        DSB     SY ; wait for clean to complete
        MCR     p15, 0, a1, c7, c5, 1 ; invalidate ICache entry (to PoC)
        MCR     p15, 0, a1, c7, c5, 6 ; invalidate entire BTC
        DSB     SY ; wait for cache invalidation to complete
        ISB     SY ; wait for BTC invalidation to complete?
        ; Now reconfigure the USER button (GPIO 7) to fire an FIQ
        LDR     a1, L4_GPIO1_Log
        LDR     a2, [a1, #GPIO_OE]
        ORR     a2, a2, #1:SHL:7 ; Configure as input
        STR     a2, [a1, #GPIO_OE]
        MOV     a2, #0
        STR     a2, [a1, #GPIO_LEVELDETECT0]
        STR     a2, [a1, #GPIO_LEVELDETECT1]
        STR     a2, [a1, #GPIO_FALLINGDETECT]
        MOV     a2, #1:SHL:7
        STR     a2, [a1, #GPIO_RISINGDETECT] ; Enable IRQ on rising edge
        STR     a2, [a1, #GPIO_IRQENABLE1] ; Set MPU as interrupt target
        MOV     a1, #29 ; GPIO1 IRQ
        ; tail-optimised, repeating the HAL device init would be a bad thing!
        B       HAL_FIQEnable
10
 ]
        Entry   "v1-v3"
        DebugTime a1, "HAL_InitDevices @@ "
        ; Common HAL devices
 [ UseSR44x
        BL      SR44x_Init
 ]
        BL      NVMemory_InitDevice
        BL      RTC_Init
        BL      SDMA_Init
        BL      VideoDevice_Init
        BL      Audio_Init
        BL      PowerCtrl_Init
        BL      PL310_InitDevice
        BL      DBell_InitDevices
        ; Board-specific HAL devices
        LDR     pc, [sb, #BoardConfig_InitDevices]
Board_InitDevices_None
        EXIT


Board_InitDevices_Panda
        ; SD needs boardtype and revision to configure the devices correctly
        ; for OMAP4 we just differentiate between ES (4460) and non-ES (4430)
        LDR     a2, L4_Core_Log
        LDR     a1, =(L4_CONTROL_IDCODE - L4_Core)
        LDR     a2, [a2, a1]
        LDR     v2, =HAWKEYE_OMAP4460_ES10
        UBFX    a2, a2, #12, #16
        CMP     v2, a2
        MOV     a1, #BoardType_OMAP4_Panda
        MOVNE   a2, #BoardRevision_Panda
        MOVEQ   a2, #BoardRevision_PandaES
        Push    "a1-a2"
        BL      GPIO_InitDevices
        ; SD needs the same parameters to configure the device correctly
        Pull    "a1-a2"
        BL      SDIO_InitDevices
        DebugTime a1, "Done @@ "
        EXIT


HAL_ControllerAddress
        MOV     a1, #0
        MOV     pc, lr

HAL_HardwareInfo
        LDR     ip, =&FFFFFF00
        STR     ip, [a1]
        MOV     ip, #0
        STR     ip, [a2]
        STR     ip, [a3]
        MOV     pc, lr

HAL_PlatformName
        ADD     a1, sb, #BoardConfig_Name
        MOV     pc, lr

HAL_PlatformInfo
        LDRB    ip, [sb, #BoardConfig_BoardFlags]
        STR     ip, [a2]
        MOV     ip, #2_11111    ; mask of valid bits
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        MOV     ip, #0
        STR     ip, [a1]
        STR     ip, [a2]
        MOV     pc, lr

HAL_MachineID
        MOV     a1, #0
        MOV     a2, #0
        MOV     pc, lr

HAL_ExtMachineID
        MOVS    ip, a1
        MOV     a1, #16
        MOVEQ   pc, lr

; OMAP44xx: L4_CONTROL_IDCODE lies in between L4_DIE_ID0 and L4_DIE_ID1
        LDR     a2, L4_Core_Log
        ADD     a2, a2, #(L4_DIE_ID0 - L4_Core)
        LDR     a3, [a2], #8    ; skip L4_CONTROL_IDCODE
        LDR     a4, [a2], #4
        STMIA   ip!, {a3-a4}
        LDMIA   a2, {a3-a4}
        STMIA   ip, {a3-a4}
        MOV     pc, lr

; Shifts to determine number of bytes/words to allocate in table.
NibbleShift     *       12 ; 1<<12 = 4K ARM page size
ByteShift       *       NibbleShift + 1
WordShift       *       ByteShift + 2

; Bit patterns for different types of memory.
NotPresent      *       &00000000
DRAM_Pattern    *       &11111111
VRAM_Pattern    *       &22222222
ROM_Pattern     *       &33333333
IO_Pattern      *       &44444444
NotAvailable    *       &88888888

        IMPORT  memset

HAL_PhysInfo
        TEQ     a1, #PhysInfo_GetTableSize
        MOVEQ   a1, #1:SHL:(32-ByteShift)
        STREQ   a1, [a2]
        MVNEQ   a1, #0          ; Supported
        MOVEQ   pc, lr

        TEQ     a1, #PhysInfo_HardROM
        MOVEQ   a1, #0          ; No hard ROM, since the NAND flash isn't yet supported
        MOVEQ   a2, #0
        STMEQIA a3, {a1-a2}
        MVNEQ   a1, #0          ; Supported
        MOVEQ   pc, lr

        TEQ     a1, #PhysInfo_WriteTable
        MOVNE   a1, #0
        MOVNE   pc, lr

        ; Do the PhysInfo_WriteTable table output
        Push    "v1-v2,lr"
        MOV     a1, #&80000000  ; Up to 2GB physical RAM from &80000000 
        LDR     lr, =&FFFFFFFF
        STMIA   a3, {a1,lr}
        MOV     v1, a2

        ADR     v2, HAL_PhysTable
10      LDMIA   v2, {a1, a2, lr}
        SUB     a3, lr, a1
        ADD     a1, v1, a1, LSR #ByteShift
        MOV     a3, a3, LSR #ByteShift
        BL      memset
        LDR     a1, [v2, #8]!
        TEQ     a1, #0
        BNE     %BT10

        MVN     a1, #0          ; Supported
        Pull    "v1,v2,pc"

; HAL_PhysInfo uses memset to fill the table, so all regions
; must be byte-aligned (ie double-page-aligned addresses).
HAL_PhysTable
        DCD     &00000000, NotPresent  :OR: NotAvailable ; GPMC
        DCD     &40000000, IO_Pattern  :OR: NotAvailable ; All I/O registers
        DCD     &80000000, NotPresent  :OR: NotAvailable ; SDRC-SMS/SDRAM
        DCD     &C0000000, NotPresent  :OR: NotAvailable ; SDRC-SMS/SDRAM
        DCD     0

HAL_Reset
        ; Reset or power off?
        CMP     a1, #0
        BNE     %FT10

        ; If there is a power control unit connected we can do a power off command
        BL      PowerCtrl_SwitchOff

10
 [ UseSR44x
        BL      SR44x_Exit
 ]
        ; Reset, or power off not supported
        ; For a reset, we just poke PRM_RSTCTRL.RST_GLOBAL_WARM_software
        LDR     a3, L4_PowerMan_Log
        ADD     a3, a3, #DEVICE_PRM
        MOV     a2, #1
        STR     a2, [a3, #PRM_RSTCTRL]
        DebugTX "HAL_Reset failed!"
        B       .       ; Just in case

; Out: a1 = number of CPU cores
HAL_CPUCount
        MOV     a1, #2
        MOV     pc, lr

; Out: a1 = number of this core
HAL_CPUNumber
        MRC     p15, 0, a1, c0, c0, 5
        AND     a1, a1, #1
        MOV     pc, lr

; In: a1 = core number
;     a2 = boot physical address
; Out: Indicated core will be booting (undefined if a1 is current core)
; Assume caller has fully flushed the boot code to RAM (no DSB prior to mbox write)
HAL_SMPStartup
        LDR     a3, L4_Per_Log
        LDR     a4, =AUX_CORE_BOOT_1-L4_Per
        STR     a2, [a3, a4]!
        DMB
        MOV     a4, #-1
        STR     a4, [a3, #AUX_CORE_BOOT_0-AUX_CORE_BOOT_1]
        DSB
        SEV
        MOV     pc, lr

        LTORG

        EXPORT  vtophys
vtophys
        CallOS  OS_LogToPhys, tailcall

        EXPORT  mapinio
mapinio
        CallOS  OS_MapInIO, tailcall

 [ FIQDebug
FIQRoutine
        ; Dump PC value to the serial port
        MOV     r8, #&24
        LDR     sb, [r8]
        LDR     r8, [sb, #BoardConfig_DebugUART]
        ADR     r9, hextab
        MOV     r10, #8
        MOV     r11, lr ; Preserve return address
10
        LDRB    r12, [r8, #UART_LSR]
        TST     r12, #UART_LSR_THRE
        BEQ     %BT10
        LDRB    r12, [r9, r11, LSR #28]
        STRB    r12, [r8, #UART_THR]
        MOV     r11, r11, LSL #4
        SUBS    r10, r10, #1
        BNE     %BT10
10
        LDRB    r12, [r8, #UART_LSR]
        TST     r12, #UART_LSR_THRE
        BEQ     %BT10
        MOV     r12, #13
        STRB    r12, [r8, #UART_THR]
10
        LDRB    r12, [r8, #UART_LSR]
        TST     r12, #UART_LSR_THRE
        BEQ     %BT10
        MOV     r12, #10
        STRB    r12, [r8, #UART_THR]
        ; Clear interrupt
        MOV     r8, #&24
        LDR     sb, [r8]
        LDR     r8, L4_GPIO1_Log
        LDR     r10, [r8, #GPIO_IRQSTATUS1]
        STR     r10, [r8, #GPIO_IRQSTATUS1]
        LDR     r8, MPU_INTC_Log
        MOV     r10, #2
        STR     r10, [r8, #INTCPS_CONTROL]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
   [ {FALSE} ; Code to call DebugCallstack on any button press
        ; Switch back to original mode
        MRS     r8, CPSR
        MRS     r9, SPSR
        BIC     r8, r8, #&1F
        AND     r9, r9, #&1F
        ORR     r8, r8, r9
        MSR     CPSR_c, r8
        ; Dump the callstack & other regs
        Push    "sb" ; preserve original sb so it can be dumped
        MOV     sb, #&24
        LDR     sb, [sb]
        B       DebugCallstack
   ]
        ; Now return
        SUBS    pc, lr, #4

hextab  DCB "0123456789abcdef"
 ]

        END
@


1.32
log
@Add GPIO device implementation
Update to API 1.0, and corresponding set of register wide accessor functions.
The tables of permitted pins come from staring at the schematics for any connectors, minus those that are "owned" by the OS.

Tested on a Pandaboard, toggling the two user LEDs and scanning the 'USER' push button (which, by the way, needs the pullup enabling as there isn't a discrete one).

Version 0.58. Tagged as 'OMAP4-0_58'
@
text
@d166 1
d183 3
d306 6
a311 7
        NullEntry ; HAL_MatrixColumns
        NullEntry ; HAL_MatrixScan

        NullEntry ; HAL_TouchscreenType
        NullEntry ; HAL_TouchscreenRead
        NullEntry ; HAL_TouchscreenMode
        NullEntry ; HAL_TouchscreenMeasure
d710 1
d870 26
@


1.31
log
@Make type and revision private
Adopt the board type and revision enum privately in board.hdr (mass search & replace exercise).
Don't re-export it via a stub GPIO device; it's private.

Version 0.56. Tagged as 'OMAP4-0_56'
@
text
@d161 1
a161 1
        IMPORT  GPIO_InitDevice
d726 1
a726 1
        BL      GPIO_InitDevice
@


1.30
log
@Participate in keyboard scan dependencies
Detail:
  Replace keyboard scan code with list of modules that the kernel needs to do the same.
  Reorder the HALEntries to match Kernel-5_89.
  Delete unused workspace.
  Don't link against HAL USB library.
Admin:
  Submission for USB bounty.

Version 0.54. Tagged as 'OMAP4-0_54'
@
text
@d722 3
a724 3
        MOV     a1, #GPIOType_OMAP4_Panda
        MOVNE   a2, #GPIORevision_Panda
        MOVEQ   a2, #GPIORevision_PandaES
@


1.29
log
@Implement HAL_TimerIRQClear
Detail:
  s/Boot, s/Interrupts, s/Timers - Move timer IRQ clear code out of HAL_IRQClear and into HAL_TimerIRQClear. Streamlines HAL_IRQClear, and necessary to avoid undefined symbols when linking with latest HAL USB library
Admin:
  Builds, untested


Version 0.51. Tagged as 'OMAP4-0_51'
@
text
@d237 1
a237 4
        IMPORT  HAL_KbdScanSetup
        IMPORT  HAL_KbdScan
        IMPORT  HAL_KbdScanFinish
        IMPORT  HAL_KbdScanInterrupt
d337 1
a337 2

        HALEntry HAL_Reset
d359 4
a362 4
        HALEntry HAL_KbdScanSetup
        HALEntry HAL_KbdScan
        HALEntry HAL_KbdScanFinish
        HALEntry HAL_KbdScanInterrupt
d366 1
a366 1
        HALEntry HAL_USBControllerInfo
d370 1
a370 2
        NullEntry ; HAL_VideoRender

d374 2
a375 3

        HALEntry HAL_VideoIICOp

d382 4
a385 2

        HALEntry HAL_UARTDefault
@


1.29.2.1
log
@Initial SMP support
Detail:
  s/DBell, Makefile - Implement doorbell device
  s/Boot - Implement new SMP-related HAL entry points
  s/Interrupts - Remove DebugInterrupts code to make things easier to follow. Add a couple of macros for mapping IRQ numbers to register bits, to help deal with IRQ number translation. Implement new IRQ-related HAL entry points.
  hdr/omap4_reg - Offset the peripheral interrupt numbers so that 0-31 are core 0 private, 32-63 core 1 private, 64+ = peripheral
  hdr/StaticWS - Remove DebugInterrupts code. Reserve space for doorbell device.
  hdr/omap4430 - Remove DebugInterrupts code. Add definitions for aux core boot registers.
Admin:
  Tested on PandaBoard Rev A6


Version 0.52, 1.52.2.1. Tagged as 'OMAP4-0_52-1_52_2_1'
@
text
@a165 1
        IMPORT  DBell_InitDevices
a181 3
        IMPORT  HAL_IRQProperties
        IMPORT  HAL_IRQSetCores
        IMPORT  HAL_IRQGetCores
d305 7
a311 6
        HALEntry HAL_IRQProperties
        HALEntry HAL_IRQSetCores
        HALEntry HAL_IRQGetCores
        HALEntry HAL_CPUCount
        HALEntry HAL_CPUNumber
        HALEntry HAL_SMPStartup
a710 1
        BL      DBell_InitDevices
a869 26
; Out: a1 = number of CPU cores
HAL_CPUCount
        MOV     a1, #2
        MOV     pc, lr

; Out: a1 = number of this core
HAL_CPUNumber
        MRC     p15, 0, a1, c0, c0, 5
        AND     a1, a1, #1
        MOV     pc, lr

; In: a1 = core number
;     a2 = boot physical address
; Out: Indicated core will be booting (undefined if a1 is current core)
; Assume caller has fully flushed the boot code to RAM (no DSB prior to mbox write)
HAL_SMPStartup
        LDR     a3, L4_Per_Log
        LDR     a4, =AUX_CORE_BOOT_1-L4_Per
        STR     a2, [a3, a4]!
        DMB
        MOV     a4, #-1
        STR     a4, [a3, #AUX_CORE_BOOT_0-AUX_CORE_BOOT_1]
        DSB
        SEV
        MOV     pc, lr

@


1.29.2.2
log
@Merge in latest changes from main branch

Version 0.54, 1.52.2.2. Tagged as 'OMAP4-0_54-1_52_2_2'
@
text
@d241 4
a244 1
        IMPORT  HAL_KbdScanDependencies
d343 2
a344 1
        HALEntry HAL_UARTDefault
d366 4
a369 4
        HALEntry HAL_KbdScanDependencies
        NullEntry ; Unused
        NullEntry ; Unused
        NullEntry ; Unused
d373 1
a373 1
        HALEntry HAL_Reset
d377 2
a378 1
        HALEntry HAL_USBControllerInfo
d382 3
a384 2
        NullEntry ; HAL_USBPortDevice
        
d391 2
a392 4
        NullEntry ; HAL_VideoRender
        NullEntry ; HAL_VideoStartupMode
        NullEntry ; HAL_VideoPixelFormatList
        HALEntry HAL_VideoIICOp
@


1.29.2.3
log
@Merge in latest changes from HEAD

Version 0.59, 1.52.2.3. Tagged as 'OMAP4-0_59-1_52_2_3'
@
text
@d161 1
a161 1
        IMPORT  GPIO_InitDevices
d726 3
a728 3
        MOV     a1, #BoardType_OMAP4_Panda
        MOVNE   a2, #BoardRevision_Panda
        MOVEQ   a2, #BoardRevision_PandaES
d730 1
a730 1
        BL      GPIO_InitDevices
@


1.28
log
@Add HAL_PlatformName implementation
Detail:
  Return the board name for this entry.
  Rename CPU temperature sensor register per datasheet.
Admin:
  Submission from Willi Theiss.
  Not tested.

Version 0.50. Tagged as 'OMAP4-0_50'
@
text
@d190 1
d382 1
a382 1
        NullEntry ; HAL_TimerIRQClear
@


1.27
log
@Remove stubbed out HAL entries
Detail:
  There's no need to provide an empty implementation, just use NullEntry.
Admin:
  Submission from Willi Theiss.

Version 0.48. Tagged as 'OMAP4-0_48'
@
text
@d288 23
a310 23
        NullEntry ; HALEntry HAL_VideoFlybackDevice
        NullEntry ; HALEntry HAL_VideoSetMode
        NullEntry ; HALEntry HAL_VideoWritePaletteEntry
        NullEntry ; HALEntry HAL_VideoWritePaletteEntries
        NullEntry ; HALEntry HAL_VideoReadPaletteEntry
        NullEntry ; HALEntry HAL_VideoSetInterlace
        NullEntry ; HALEntry HAL_VideoSetBlank
        NullEntry ; HALEntry HAL_VideoSetPowerSave
        NullEntry ; HALEntry HAL_VideoUpdatePointer
        NullEntry ; HALEntry HAL_VideoSetDAG
        NullEntry ; HALEntry HAL_VideoVetMode
        NullEntry ; HALEntry HAL_VideoPixelFormats
        NullEntry ; HALEntry HAL_VideoFeatures
        NullEntry ; HALEntry HAL_VideoBufferAlignment
        NullEntry ; HALEntry HAL_VideoOutputFormat

        NullEntry ; HALEntry HAL_MatrixColumns
        NullEntry ; HALEntry HAL_MatrixScan

        NullEntry ; HALEntry HAL_TouchscreenType
        NullEntry ; HALEntry HAL_TouchscreenRead
        NullEntry ; HALEntry HAL_TouchscreenMode
        NullEntry ; HALEntry HAL_TouchscreenMeasure
d318 1
a318 1
        NullEntry ; HALEntry HAL_CleanerSpace
d356 3
a358 3
        NullEntry ; HAL_ATAControllerInfo
        NullEntry ; HAL_ATASetModes
        NullEntry ; HAL_ATACableID
d749 4
@


1.26
log
@Minor OMAP4 tidying
omap4430.hdr/Debug,s:
  Define a dummy symbol so when debug is enabled there aren't conflicting IMPORT and EXPORTs.
PRCM.s:
  Fill in missing frequency.
Boot.s:
  Update comment to match HAL function names.
NVMemory.s:
  Add offset to account for FATLoadedCMOS not being at offset 0.
Top.s:
  Remove unused Post header. Replace DCI with instruction now objasm supports it.
Submission from Willi Theiss.

Version 0.47. Tagged as 'OMAP4-0_47'
@
text
@a235 2
        IMPORT  HAL_ATAControllerInfo

d356 1
a356 1
        HALEntry HAL_ATAControllerInfo
@


1.25
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Built, but not tested.

Version 0.44. Tagged as 'OMAP4-0_44'
@
text
@d378 2
a379 2
        NullEntry ; HAL_USBPortStatus
        NullEntry ; HAL_USBPortDevice
@


1.24
log
@Add HAL device implementation for PL310 L2 cache controller
Detail:
  s/PL310 - Add basic HAL device for the PL310 cache controller. Reports the base address to the OS and handles basic cache initialisation.
  Makefile - Include PL310 code
  hdr/StaticWS - Allocate workspace for HAL device
  s/Boot - Remove L2 cache initialisation from HAL_Init. Register PL310 device during HAL_InitDevices.
Admin:
  Tested on rev A6 Pandaboard
  Requires Kernel-5_35-4_79_2_252


Version 0.41. Tagged as 'OMAP4-0_41'
@
text
@a57 3
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
        IMPORT  DebugHALPrintByte
a58 1
        IMPORT  DebugCallstack
@


1.23
log
@Enable L2 cache in HAL_Init
On the OMAP4 we're in a privileged but unsecure mode, so to do the initial PL310 enable we call an SMC sunction embedded in the OMAP's onboard mask ROM to do the deed.
Also, correct the range of SDRAM hinted to the kernel - this looks like a copy and paste mistake from the Tungsten HAL.

Version 0.40. Tagged as 'OMAP4-0_40'
@
text
@d169 1
a409 10
        ; The PL320 L2CC control registers aren't writable from non secure modes on
        ; this particular Cortex-A9, so call the OMAP4 HLOS support function (see
        ; TRM 27.5.1) to get it enabled
        Push    "v4-v5, sb, v7-v8"
        LDR     ip, =0x102      ; write control register
        MOV     a1, #1          ; L2 cache enable
        DSB     SY
        SMC     #0
        Pull    "v4-v5, sb, v7-v8"

d715 1
@


1.22
log
@Minor HAL API corrections
HAL_HardwareInfo - as word 0 specified that no IOMD or VIDC was present, don't waste time reporting anything in word 2.
Not tagged.
@
text
@d406 2
d409 9
a417 1
        BL      SetUpOSEntries
d831 2
a832 2
        MOV     a1, #&80000000  ; Physical RAM from &80000000 and up?
        LDR     lr, =&FFFFE000-1
d855 1
a855 1
        DCD     &FFFFE000, NotPresent  :OR: NotAvailable ; SDRC-SMS/SDRAM
@


1.21
log
@Don't bother providing even dummy implementations of USB port and overcurrent functions
As the flag bit in HAL_USBControllerInfo isn't set, no need to provide them.
Use symbols from Hdr:HALEntries when building the USB info.
No need for AASMFLAGS in the makefile.
Built, but not tested.

Version 0.37. Tagged as 'OMAP4-0_37'
@
text
@a749 1
        LDR     ip, =&00FFFF00
@


1.20
log
@Add support for recent U-Boot versions
Detail:
  hdr/PRCM:
  - added further definitions (not listed in older TRMs)
  s/Audio:
  - configure all GPIO pads used by audio system
    (for supporting latest U-Boot 2014-7)
  s/Boot:
  - added overflow check for address range
  s/RAM:
  - added overflow check for address range
  - address comparison with unsigned arithmetic
  s/RTC:
  - added initialisation code and pad configuration for TWL6030 RTC
    (for supporting latest U-Boot 2014-07)
  s/SDIO:
  - added pad configuration for LEDs used by SDIO
    (for supporting latest U-Boot 2014-07)
  s/USB:
  - removed unused code parts
  - use defines for controller types
  s/Video:
  - added pad configuration for DVI framer pin
  - enable DSS power and clock domain and DSS specific clocks
  - activate thermal sensor clock
  - wait for activated module in VideoDevice_Activate
    (for supporting latest U-Boot 2014-07)
Admin:
  Submission from Willi Theiss
  Tested on Panda ES rev B3 (Willi), Panda rev A6 (myself)


Version 0.36. Tagged as 'OMAP4-0_36'
@
text
@a246 3
        IMPORT  HAL_USBPortPower
        IMPORT  HAL_USBPortStatus
        IMPORT  HAL_USBPortIRQ
d378 1
a378 1
        NullEntry ;HALEntry HAL_VideoRender
d380 3
a382 3
        HALEntry HAL_USBPortPower
        HALEntry HAL_USBPortStatus
        HALEntry HAL_USBPortIRQ
@


1.19
log
@Rework of SDRAM detection
hdr.SDRC: Extra bit fields added to definitions
s.RAM: scan through all LISA_MAP register
       rework of clear loop (only one instance used)
s.Boot: scan through all LISA_MAP register

This should remove the dependence of the OMAP4 HAL to be run with a specific version of the accompanying loader.
Submission from Willi Theiss. Built, but not tested here,

Version 0.29. Tagged as 'OMAP4-0_29'
@
text
@d109 3
a111 1
        ADD     a3, a4, a2
@


1.18
log
@Use DSB/ISB directly
Objasm 4 supports ARMv7 opcodes, and this HAL is only every for ARMv7.
Built, but not tested. Submission from Willi Theiss.

Version 0.28. Tagged as 'OMAP4-0_28'
@
text
@d82 4
a85 2
        ; Check LISA_MAP_0
        LDR     a3, [v1, #DMM_LISA_MAP_0]
d87 1
d89 14
a102 1
        BEQ     no_cs0
d115 1
a115 22
        DebugChar a3,a2,72
no_cs0
        ; Check LISA_MAP_1
        LDR     a3, [v1, #DMM_LISA_MAP_1]
        LDR     a2, =DMM_LISA_MAP_i_SDRC_MAP
        ANDS    a2, a3, a2      ; MAP_x used ?
        BEQ     no_cs1
        LDR     a2, =DMM_LISA_MAP_i_SYS_SIZE
        AND     a2, a3, a2
        MOV     a2, a2, LSR #DMM_LISA_MAP_i_SYS_SIZE_SHIFT
        LDR     a4, =(16 * 1024 * 1024) ; 16 MiB smallest size
        MOV     a4, a4, LSL a2          ; final size
        AND     a2, a3, #DMM_LISA_MAP_i_SYS_ADDR
        ADD     a3, a4, a2
        LDR     a4, =&FFFFFFFF
        CMP     sp, #0
        ADDEQ   sp, a2, #4096 ; If no CS0 set up stack in CS1
        MOV     a1, #0
        STR     a1, [sp, #-4]!
        CallOSM OS_AddRAM
        DebugChar v1,v2,71
no_cs1
d117 1
a117 1
        ; check for reset cause: test PRM_RSTST.GLOBAL_COLD_RST
@


1.17
log
@Remove obsolete stub HAL video API implementation
Detail:
  hdr/Video - Remove unused local VIDC list type 3 definition
  s/Boot, s/Video - Removed obsolete HAL video API implementation. A stub implementation is no longer required for systems that have a GraphicsV driver in a module, and can even cause problems if the OS decides to use the HAL implementation instead of the module one.
Admin:
  Builds, but untested. Essentially the same changes as for the OMAP3 HAL.
  Requires Kernel-5_35-4_79_2_203


Version 0.27. Tagged as 'OMAP4-0_27'
@
text
@a33 1
        GET     hdr.Copro15ops
d686 1
a686 1
        myDSB ; wait for clean to complete
d689 2
a690 2
        myDSB ; wait for cache invalidation to complete
        myISB ; wait for BTC invalidation to complete?
d926 1
a926 1
        myDSB
@


1.16
log
@Add support for IIC attached power control and real time clock addons
Boot.s: reorder the SmartReflex turn off to allow for power control module
PowerCtrl.s: new
RTC: scan for a DS1338 real time clock too (and prefer that if found)
Built, but not tested here.

Version 0.25. Tagged as 'OMAP4-0_25'
@
text
@a216 15
        IMPORT  HAL_VideoFlybackDevice
        IMPORT  HAL_VideoSetMode
        IMPORT  HAL_VideoWritePaletteEntry
        IMPORT  HAL_VideoWritePaletteEntries
        IMPORT  HAL_VideoReadPaletteEntry
        IMPORT  HAL_VideoSetInterlace
        IMPORT  HAL_VideoSetBlank
        IMPORT  HAL_VideoSetPowerSave
        IMPORT  HAL_VideoUpdatePointer
        IMPORT  HAL_VideoSetDAG
        IMPORT  HAL_VideoVetMode
        IMPORT  HAL_VideoPixelFormats
        IMPORT  HAL_VideoFeatures
        IMPORT  HAL_VideoBufferAlignment
        IMPORT  HAL_VideoOutputFormat
d300 15
a314 15
        HALEntry HAL_VideoFlybackDevice
        HALEntry HAL_VideoSetMode
        HALEntry HAL_VideoWritePaletteEntry
        HALEntry HAL_VideoWritePaletteEntries
        HALEntry HAL_VideoReadPaletteEntry
        HALEntry HAL_VideoSetInterlace
        HALEntry HAL_VideoSetBlank
        HALEntry HAL_VideoSetPowerSave
        HALEntry HAL_VideoUpdatePointer
        HALEntry HAL_VideoSetDAG
        HALEntry HAL_VideoVetMode
        HALEntry HAL_VideoPixelFormats
        HALEntry HAL_VideoFeatures
        HALEntry HAL_VideoBufferAlignment
        HALEntry HAL_VideoOutputFormat
@


1.15
log
@Refactor IIC calls to use RISCOS_IICOpV
Copy changes from OMAP3-0_90 to OMAP4.
Built, but not tested.

Version 0.23. Tagged as 'OMAP4-0_23'
@
text
@d66 2
d735 1
a871 5
 [ UseSR44x
        Push    "a1"
        BL      SR44x_Exit
        Pull    "a1"
 ]
d876 3
d880 3
@


1.14
log
@Add SmartReflex driver
Submission from Willi Theiss.
Built, but not tested here.

Version 0.20. Tagged as 'OMAP4-0_20'
@
text
@a74 13
        MACRO
        CallOS  $entry, $tailcall
        ASSERT  $entry <= HighestOSEntry
 [ "$tailcall"=""
        MOV     lr, pc
 |
   [ "$tailcall"<>"tailcall"
        ! 0, "Unrecognised parameter to CallOS"
   ]
 ]
        LDR     pc, OSentries + 4*$entry
        MEND

@


1.13
log
@Add support for all 4 I2C interfaces
hdr.board
    support all 4 I2C interfaces
    added BoardFlags variable
    remove unused BoardConfig_APLL_CTL variable
hdr.StaticWS
    support all 4 I2C interfaces on OMAP4
board.s
    removed unused parameter apll_ctl
    added support for all 4 I2C and UART interfaces
    added BoardFlags variable
Boot.s
    support all 4 I2C interfaces
    some code tweaks (tidy up)
    removed unused Touchbook code
I2C.s
    support all 4 I2C interfaces
    some code cleanup and comment correction
Submission from Willi Theiss.

Version 0.19. Tagged as 'OMAP4-0_19'
@
text
@d51 3
d64 2
d738 3
d882 5
@


1.12
log
@Probe earlier, declare device later
Reflects changes in OMAP3-0_88.

Version 0.18. Tagged as 'OMAP4-0_18'
@
text
@a60 3
        IMPORT  TPSRead
        IMPORT  TPSWrite
        IMPORT  IIC_DoOp_Poll
d558 6
d565 1
d567 4
a570 7
        STR     a2, (I2C1Block + I2C_HW)
        MOV     a1, #(BoardConfig_HALI2C + 4)
        BL      phys2log
        STR     a2, (I2C2Block + I2C_HW)
        MOV     a1, #(BoardConfig_HALI2C + 8)
        BL      phys2log
        STR     a2, (I2C3Block + I2C_HW)
d779 1
a779 6
        ; TouchBook can do soft-off, others can't (yet)
        LDR     ip, [sb, #BoardConfig_MachID]
        LDR     a1, =MachID_TouchBook
        CMP     ip, a1
        MOVNE   ip, #2_10000    ; no podules,no PCI cards,no multi CPU,no soft off,and soft ROM
        MOVEQ   ip, #2_11000
d874 2
a875 6
        ; TouchBook can power off by setting GPIO168 to 0
        ; TODO - Sort out the other machine types
        LDR     a3, [sb, #BoardConfig_MachID]
        LDR     a2, =MachID_TouchBook
        CMP     a3, a2
        CMPEQ   a1, #0
d877 1
a877 8
        MOV     a1, #168
        MOV     a2, #0
        BL      GPIOx_SetAsOutput
        ; It seems like there's a short delay before the system shuts down; if we try doing a
        ; soft reset during that time then we'll hang with the power still on
        ; So just loop here, with a warning message for if something's gone wrong
        DebugTX "TouchBook power off failed!"
        B       .
d879 1
a879 1
        ; At the moment we only support resets, not power off
@


1.11
log
@Create placeholder NVMemory HAL device when EEPROM detected
Merged from OMAP3-0_87, builds but not tested.
Expanded tabs in hdr/StaticWS.

Version 0.17. Tagged as 'OMAP4-0_17'
@
text
@d166 1
a166 1
        IMPORT  Video_init
d181 1
d584 1
a584 1
        DebugTX "Video_init"
d586 1
a586 1
        BL      Video_init
d594 5
d732 1
a732 1
        BL      NVMemory_Init
@


1.10
log
@Add skeleton GPIO device
Changes from Willi Theiss.
Built, but not tested here.

Version 0.16. Tagged as 'OMAP4-0_16'
@
text
@a592 5
        DebugTX "NVMemory_Init"
 ] ; MoreDebug
        BL      NVMemory_Init

 [ MoreDebug
d726 1
@


1.9
log
@Tidy ups to OMAP4
hdr.GPIO
  removed TWL/TPS pins (not available on OMAP4/TWL6030)
s.GPIO
  removed TWL/TPS related GPIO pins (not available on OMAP4/TWL6030)
s.SDIO
  some code cleanup (remove OMAP3 specific stuff)
s.Boot
  some code tweaks (tidy up)

Changes from Willi Theiss. Built, but not tested here.

Version 0.15. Tagged as 'OMAP4-0_15'
@
text
@a26 1
        GET     Hdr:GPIODevice
d178 1
a581 19
        ; nothing to do here for OMAP4
  [ {FALSE}
        ; Do extra board-specific GPIO init
        ; Touchbook & classic beagle need TPS LED A turning off for EHCI
        ; Beagle xM needs TPS GPIO 1 off and TPS LED A on for DVI & EHCI
        ; For the moment, just work out what board it is based around the
        ; Linux machine ID & OMAP type
        LDR     a1, [sb, #BoardConfig_MachID]
        LDR     a2, =MachID_BeagleBoard
        CMP     a1, a2
        LDRNE   a2, =MachID_TouchBook
        CMPNE   a1, a2
        BNE     %FT20
10
        MOV     a1, #(GPIO_PIN_MAX + TPS_GPIO_PIN_MAX)
        BL      GPIOx_SetAsOutput
20
  ] ; not for OMAP4

d585 1
a585 1
        BL      Video_init      ; Uses GPTIMER5
d590 1
a590 1
        BL      USB_Init        ; Uses GPTIMER5
d745 2
a746 2
        ADD     a2, a2, #((L4_CONTROL_IDCODE - L4_Core) :AND: &FF00)
        LDR     a2, [a2, #((L4_CONTROL_IDCODE - L4_Core) :AND: &00FF)]
d748 2
a749 2
        MOV     a2, a2, LSL #4
        CMP     v2, a2, LSR #16
d753 4
d832 1
a832 1
        MVNEQ   a1, #0             ; Supported
d836 1
a836 1
        MOVEQ   a1, #0             ; No hard ROM, since the NAND flash isn't yet supported
d839 1
a839 1
        MVNEQ   a1, #0             ; Supported
d846 1
a846 1
        ; Do the PhysInfo_WriteTable table output 
d848 1
a848 1
        MOV     a1, #&80000000     ; Physical RAM from &80000000 and up?
d863 1
a863 1
        MVN     a1, #0             ; Supported
d899 1
a899 1
        B       . ; Just in case
@


1.8
log
@Implement HAL_IRQMax
Detail:
  s/Boot, s/Interrupts - Added HAL_IRQMax implementation, to ensure correct functionality with latest Kernel
Admin:
  Builds OK but untested at runtime
  Requires Kernel-5_35-4_79_2_182


Version 0.13. Tagged as 'OMAP4-0_13'
@
text
@d27 1
a758 3
GPIOType_OMAP4_Panda    *       0
GPIORevision_Panda      *       0
GPIORevision_PandaES    *       1
@


1.7
log
@Adopt revised HAL_PhysInfo API
Also spotted that USAT can be conditional in the I2C code.

Version 0.12. Tagged as 'OMAP4-0_12'
@
text
@d195 1
d405 1
a405 1
        NullEntry ;HALEntry HAL_MonitorLeadID
@


1.6
log
@Refactor HAL_VideoIICOp to be ATPCS
No longer specified to return _kernel_oserror * implements GraphicsV 14.
Make use of IICStatus defines instead of local copies.
Rename HAL_Video_ to HAL_Video.
Compiles, but not tested.


Version 0.11. Tagged as 'OMAP4-0_11'
@
text
@d845 1
a845 1
        TEQ     a1, #0
d847 9
d858 11
a868 2
        Push    "a2,v1,v2,lr"
        MOV     v1, a1
d878 2
a879 4
        MOV     a1, #&80000000 ; Physical RAM from &80000000 and up?
        LDR     lr, =&FFFFE000-1
        Pull    "a2"
        STR     lr, [a2]
@


1.5
log
@  Added SD support for Pandaboard
Detail:
  SDHCI HAL device created. Also, Entry HAL_UARTDefault added (supports
  OS_SerialOp) and HALDoesVideo switch, previously disabled, is now removed.
Admin:
  Requires SDIODriver 0.04.
  Changes received from Willi Theiss.

Version 0.10. Tagged as 'OMAP4-0_10'
@
text
@d224 15
a238 15
        IMPORT  HAL_Video_SetMode
        IMPORT  HAL_Video_WritePaletteEntry
        IMPORT  HAL_Video_WritePaletteEntries
        IMPORT  HAL_Video_ReadPaletteEntry
        IMPORT  HAL_Video_SetInterlace
        IMPORT  HAL_Video_SetBlank
        IMPORT  HAL_Video_SetPowerSave
        IMPORT  HAL_Video_UpdatePointer
        IMPORT  HAL_Video_SetDAG
        IMPORT  HAL_Video_VetMode
        IMPORT  HAL_Video_PixelFormats
        IMPORT  HAL_Video_Features
        IMPORT  HAL_Video_BufferAlignment
        IMPORT  HAL_Video_OutputFormat
        IMPORT  HAL_Video_IICOp ; Implemented in s.I2C
d322 14
a335 14
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode
        HALEntry HAL_Video_PixelFormats
        HALEntry HAL_Video_Features
        HALEntry HAL_Video_BufferAlignment
        HALEntry HAL_Video_OutputFormat
d406 1
a406 1
        NullEntry ;HALEntry HAL_Video_Render
d412 1
a412 1
        HALEntry HAL_Video_IICOp
d419 1
a419 1
        NullEntry ; HAL_Video_FramestoreAddress
@


1.4
log
@Bulk expand of tabs.
Helps to make tracking changes between OMAP3 and OMAP4 less eye watering, but otherwise functionally the same as 0.06.

Version 0.07. Tagged as 'OMAP4-0_07'
@
text
@a172 1
 [ :LNOT: HALDoesVideo
a173 1
 ]
d178 1
d182 1
d259 1
d419 4
a749 1
 [ :LNOT: HALDoesVideo
a750 1
 ]
d755 19
@


1.3
log
@Updates to OMAP4 port.
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.Audio
    changes for better sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.omap4430
    added DebugTiming macros
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.StaticWS
    added variable NVMemoryFound
    removed variables for NVRAM over SD card support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Audio
    changes for better sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.board
    adjusted max pixel-clock rate
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Boot
    added debug timing
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.KdbScan
    added debug timing
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.NVMemory
    EEPROM support over JTAG port (EMU0/EMU1)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.RAM
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Top
    use DMA for copying ROM at top of RAM
    added debug timing
    support for compressed images (as in OMAP3)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Video
    added debug timing OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.c.CLib
    reverted to version without SD card NVRAM support

Changes from Willi Theiss.
Assembles without errors, but not tested here.

Version 0.06. Tagged as 'OMAP4-0_06'
@
text
@d16 22
a37 22
	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:Machine.<Machine>
	GET	Hdr:HALSize.<HALSize>

	GET	Hdr:MEMM.VMSAv6

	GET	Hdr:Proc
	GET	Hdr:OSEntries
	GET	Hdr:HALEntries

	GET	hdr.omap4430
	GET	hdr.StaticWS
	GET	hdr.SDRC
	GET	hdr.Interrupts
	GET	hdr.Timers
	GET	hdr.GPIO
	GET	hdr.Copro15ops
	GET	hdr.UART
	GET	hdr.PRCM
	GET	hdr.GPMC
d45 2
a46 2
		GBLL	FIQDebug
FIQDebug	SETL	{FALSE}
d48 2
a49 2
		GBLL	MoreDebug
MoreDebug	SETL	Debug :LAND: {FALSE}
d51 1
a51 1
	AREA	|Asm$$Code|, CODE, READONLY, PIC
d53 11
a63 11
	EXPORT	rom_checkedout_ok

	IMPORT	HAL_Base
	IMPORT	DebugHALPrint
	IMPORT	DebugHALPrintReg
	IMPORT	DebugHALPrintByte
	IMPORT	RTC_Init
	IMPORT	DebugCallstack
	IMPORT	TPSRead
	IMPORT	TPSWrite
	IMPORT	IIC_DoOp_Poll
d66 10
a75 10
	MACRO
	CallOSM $entry, $reg
	LDR	ip, [v8, #$entry*4]
	MOV	lr, pc
	ADD	pc, v8, ip
	MEND

	MACRO
	CallOS	$entry, $tailcall
	ASSERT	$entry <= HighestOSEntry
d77 1
a77 1
	MOV	lr, pc
d80 1
a80 1
	! 0, "Unrecognised parameter to CallOS"
d83 2
a84 2
	LDR	pc, OSentries + 4*$entry
	MEND
d87 2
a88 2
	; On entry, v8 -> OS entry table, sb -> board config
	; Register the attached RAM
d90 20
a109 20
	LDR	v1, =DMM_Base
	MOV	sp, #0
	; Check LISA_MAP_0
	LDR	a3, [v1, #DMM_LISA_MAP_0]
	LDR	a2, =DMM_LISA_MAP_i_SDRC_MAP
	ANDS	a2, a3, a2	; MAP_x used ?
	BEQ	no_cs0
	LDR	a2, =DMM_LISA_MAP_i_SYS_SIZE
	AND	a2, a3, a2
	MOV	a2, a2, LSR #DMM_LISA_MAP_i_SYS_SIZE_SHIFT
	LDR	a4, =(16 * 1024 * 1024)	; 16 MiB smallest size
	MOV	a4, a4, LSL a2		; final size
	AND	a2, a3, #DMM_LISA_MAP_i_SYS_ADDR
	ADD	a3, a4, a2
	LDR	a4, =&FFFFFFFF
	ADD	sp, a2, #4096 ; HAL spec says that (for software reset compliance only?) stack should be 4K into first block
	MOV	a1, #0
	STR	a1, [sp, #-4]!
	CallOSM OS_AddRAM
	DebugChar a3,a2,72
d111 19
a129 19
	; Check LISA_MAP_1
	LDR	a3, [v1, #DMM_LISA_MAP_1]
	LDR	a2, =DMM_LISA_MAP_i_SDRC_MAP
	ANDS	a2, a3, a2	; MAP_x used ?
	BEQ	no_cs1
	LDR	a2, =DMM_LISA_MAP_i_SYS_SIZE
	AND	a2, a3, a2
	MOV	a2, a2, LSR #DMM_LISA_MAP_i_SYS_SIZE_SHIFT
	LDR	a4, =(16 * 1024 * 1024)	; 16 MiB smallest size
	MOV	a4, a4, LSL a2		; final size
	AND	a2, a3, #DMM_LISA_MAP_i_SYS_ADDR
	ADD	a3, a4, a2
	LDR	a4, =&FFFFFFFF
	CMP	sp, #0
	ADDEQ	sp, a2, #4096 ; If no CS0 set up stack in CS1
	MOV	a1, #0
	STR	a1, [sp, #-4]!
	CallOSM OS_AddRAM
	DebugChar v1,v2,71
d132 41
a172 41
	; check for reset cause: test PRM_RSTST.GLOBAL_COLD_RST
	LDR	a3, =L4_PowerMan
	ADD	a3, a3, #DEVICE_PRM
	LDR	a2, [a3, #PRM_RSTST]
	STR	a2, [a3, #PRM_RSTST]	; clear old status
	TST	a2, #1			; GLOBAL_COLD_RST
	MOV	a4, a1
	MOVNE	a1, #(OSStartFlag_RAMCleared :OR: OSStartFlag_POR)
	MOVEQ	a1, #OSStartFlag_RAMCleared
	ADRL	a2, HAL_Base + OSROM_HALSize	; a2 -> RISC OS image
	ADR	a3, HALdescriptor
	CallOSM OS_Start


HALdescriptor	DATA
	DCD	HALFlag_NCNBWorkspace
	DCD	HAL_Base - HALdescriptor
	DCD	OSROM_HALSize
	DCD	HAL_EntryTable - HALdescriptor
	DCD	HAL_Entries
	DCD	HAL_WsSize


	MACRO
	HALEntry $name
	ASSERT	(. - HAL_EntryTable) / 4 = EntryNo_$name
	DCD	$name - HAL_EntryTable
	MEND

	MACRO
	NullEntry
	DCD	HAL_Null - HAL_EntryTable
	MEND

	IMPORT	Video_init
	IMPORT	Interrupt_Init
	IMPORT	Timer_Init
	IMPORT	PRCM_SetClocks
	IMPORT	USB_Init
	IMPORT	I2C_Init
	IMPORT	SDMA_Init
d174 1
a174 1
	IMPORT	VideoDevice_Init
d176 234
a409 234
	IMPORT	Audio_Init
	IMPORT	GPMC_Init
	IMPORT	GPIO_Init
	IMPORT	GPIOx_SetAsOutput
	IMPORT	NVMemory_Init

	EXPORT	Board_InitDevices_None

	IMPORT	HAL_IRQEnable
	IMPORT	HAL_IRQDisable
	IMPORT	HAL_IRQClear
	IMPORT	HAL_IRQSource
	IMPORT	HAL_IRQStatus
	IMPORT	HAL_FIQEnable
	IMPORT	HAL_FIQDisable
	IMPORT	HAL_FIQDisableAll
	IMPORT	HAL_FIQClear
	IMPORT	HAL_FIQSource
	IMPORT	HAL_FIQStatus

	IMPORT	HAL_Timers
	IMPORT	HAL_TimerDevice
	IMPORT	HAL_TimerGranularity
	IMPORT	HAL_TimerMaxPeriod
	IMPORT	HAL_TimerSetPeriod
	IMPORT	HAL_TimerPeriod
	IMPORT	HAL_TimerReadCountdown

	IMPORT	HAL_CounterRate
	IMPORT	HAL_CounterPeriod
	IMPORT	HAL_CounterRead
	IMPORT	HAL_CounterDelay

	IMPORT	HAL_IICBuses
	IMPORT	HAL_IICType
	IMPORT	HAL_IICDevice
	IMPORT	HAL_IICTransfer
	IMPORT	HAL_IICMonitorTransfer

	IMPORT	HAL_NVMemoryType
	IMPORT	HAL_NVMemorySize
	IMPORT	HAL_NVMemoryPageSize
	IMPORT	HAL_NVMemoryProtectedSize
	IMPORT	HAL_NVMemoryProtection
	IMPORT	HAL_NVMemoryRead
	IMPORT	HAL_NVMemoryWrite

	IMPORT	HAL_VideoFlybackDevice
	IMPORT	HAL_Video_SetMode
	IMPORT	HAL_Video_WritePaletteEntry
	IMPORT	HAL_Video_WritePaletteEntries
	IMPORT	HAL_Video_ReadPaletteEntry
	IMPORT	HAL_Video_SetInterlace
	IMPORT	HAL_Video_SetBlank
	IMPORT	HAL_Video_SetPowerSave
	IMPORT	HAL_Video_UpdatePointer
	IMPORT	HAL_Video_SetDAG
	IMPORT	HAL_Video_VetMode
	IMPORT	HAL_Video_PixelFormats
	IMPORT	HAL_Video_Features
	IMPORT	HAL_Video_BufferAlignment
	IMPORT	HAL_Video_OutputFormat
	IMPORT	HAL_Video_IICOp ; Implemented in s.I2C

	IMPORT	HAL_UARTPorts
	IMPORT	HAL_UARTStartUp
	IMPORT	HAL_UARTShutdown
	IMPORT	HAL_UARTFeatures
	IMPORT	HAL_UARTReceiveByte
	IMPORT	HAL_UARTTransmitByte
	IMPORT	HAL_UARTLineStatus
	IMPORT	HAL_UARTInterruptEnable
	IMPORT	HAL_UARTRate
	IMPORT	HAL_UARTFormat
	IMPORT	HAL_UARTFIFOSize
	IMPORT	HAL_UARTFIFOClear
	IMPORT	HAL_UARTFIFOEnable
	IMPORT	HAL_UARTFIFOThreshold
	IMPORT	HAL_UARTInterruptID
	IMPORT	HAL_UARTBreak
	IMPORT	HAL_UARTModemControl
	IMPORT	HAL_UARTModemStatus
	IMPORT	HAL_UARTDevice

	IMPORT	HAL_DebugRX
	IMPORT	HAL_DebugTX

	IMPORT	HAL_ATAControllerInfo

	IMPORT	HAL_KbdScanSetup
	IMPORT	HAL_KbdScan
	IMPORT	HAL_KbdScanFinish
	IMPORT	HAL_KbdScanInterrupt

	IMPORT	HAL_USBControllerInfo
	IMPORT	HAL_USBPortPower
	IMPORT	HAL_USBPortStatus
	IMPORT	HAL_USBPortIRQ

HAL_EntryTable	DATA
	HALEntry HAL_Init

	HALEntry HAL_IRQEnable
	HALEntry HAL_IRQDisable
	HALEntry HAL_IRQClear
	HALEntry HAL_IRQSource
	HALEntry HAL_IRQStatus
	HALEntry HAL_FIQEnable
	HALEntry HAL_FIQDisable
	HALEntry HAL_FIQDisableAll
	HALEntry HAL_FIQClear
	HALEntry HAL_FIQSource
	HALEntry HAL_FIQStatus

	HALEntry HAL_Timers
	HALEntry HAL_TimerDevice
	HALEntry HAL_TimerGranularity
	HALEntry HAL_TimerMaxPeriod
	HALEntry HAL_TimerSetPeriod
	HALEntry HAL_TimerPeriod
	HALEntry HAL_TimerReadCountdown

	HALEntry HAL_CounterRate
	HALEntry HAL_CounterPeriod
	HALEntry HAL_CounterRead
	HALEntry HAL_CounterDelay

	HALEntry HAL_NVMemoryType
	HALEntry HAL_NVMemorySize
	HALEntry HAL_NVMemoryPageSize
	HALEntry HAL_NVMemoryProtectedSize
	HALEntry HAL_NVMemoryProtection
	NullEntry ; HAL_NVMemoryIICAddress
	HALEntry HAL_NVMemoryRead
	HALEntry HAL_NVMemoryWrite

	HALEntry HAL_IICBuses
	HALEntry HAL_IICType
	NullEntry ; HAL_IICSetLines
	NullEntry ; HAL_IICReadLines
	HALEntry HAL_IICDevice
	HALEntry HAL_IICTransfer
	HALEntry HAL_IICMonitorTransfer

	HALEntry HAL_VideoFlybackDevice
	HALEntry HAL_Video_SetMode
	HALEntry HAL_Video_WritePaletteEntry
	HALEntry HAL_Video_WritePaletteEntries
	HALEntry HAL_Video_ReadPaletteEntry
	HALEntry HAL_Video_SetInterlace
	HALEntry HAL_Video_SetBlank
	HALEntry HAL_Video_SetPowerSave
	HALEntry HAL_Video_UpdatePointer
	HALEntry HAL_Video_SetDAG
	HALEntry HAL_Video_VetMode
	HALEntry HAL_Video_PixelFormats
	HALEntry HAL_Video_Features
	HALEntry HAL_Video_BufferAlignment
	HALEntry HAL_Video_OutputFormat

	NullEntry ; HALEntry HAL_MatrixColumns
	NullEntry ; HALEntry HAL_MatrixScan

	NullEntry ; HALEntry HAL_TouchscreenType
	NullEntry ; HALEntry HAL_TouchscreenRead
	NullEntry ; HALEntry HAL_TouchscreenMode
	NullEntry ; HALEntry HAL_TouchscreenMeasure

	HALEntry HAL_MachineID

	HALEntry HAL_ControllerAddress
	HALEntry HAL_HardwareInfo
	HALEntry HAL_SuperIOInfo
	HALEntry HAL_PlatformInfo
	NullEntry ; HALEntry HAL_CleanerSpace

	HALEntry HAL_UARTPorts
	HALEntry HAL_UARTStartUp
	HALEntry HAL_UARTShutdown
	HALEntry HAL_UARTFeatures
	HALEntry HAL_UARTReceiveByte
	HALEntry HAL_UARTTransmitByte
	HALEntry HAL_UARTLineStatus
	HALEntry HAL_UARTInterruptEnable
	HALEntry HAL_UARTRate
	HALEntry HAL_UARTFormat
	HALEntry HAL_UARTFIFOSize
	HALEntry HAL_UARTFIFOClear
	HALEntry HAL_UARTFIFOEnable
	HALEntry HAL_UARTFIFOThreshold
	HALEntry HAL_UARTInterruptID
	HALEntry HAL_UARTBreak
	HALEntry HAL_UARTModemControl
	HALEntry HAL_UARTModemStatus
	HALEntry HAL_UARTDevice

	HALEntry HAL_Reset

	HALEntry HAL_DebugRX
	HALEntry HAL_DebugTX

	NullEntry ; HAL_PCIFeatures
	NullEntry ; HAL_PCIReadConfigByte
	NullEntry ; HAL_PCIReadConfigHalfword
	NullEntry ; HAL_PCIReadConfigWord
	NullEntry ; HAL_PCIWriteConfigByte
	NullEntry ; HAL_PCIWriteConfigHalfword
	NullEntry ; HAL_PCIWriteConfigWord
	NullEntry ; HAL_PCISpecialCycle
	NullEntry ; HAL_PCISlotTable
	NullEntry ; HAL_PCIAddresses

	HALEntry HAL_ATAControllerInfo
	NullEntry ; HAL_ATASetModes
	NullEntry ; HAL_ATACableID

	HALEntry HAL_InitDevices

	HALEntry HAL_KbdScanSetup
	HALEntry HAL_KbdScan
	HALEntry HAL_KbdScanFinish
	HALEntry HAL_KbdScanInterrupt

	HALEntry HAL_PhysInfo

	HALEntry HAL_USBControllerInfo

	NullEntry ;HALEntry HAL_MonitorLeadID

	NullEntry ;HALEntry HAL_Video_Render

	HALEntry HAL_USBPortPower
	HALEntry HAL_USBPortStatus
	HALEntry HAL_USBPortIRQ
d411 1
a411 1
	HALEntry HAL_Video_IICOp
d413 2
a414 2
	NullEntry ; HAL_TimerIRQClear
	NullEntry ; HAL_TimerIRQStatus
d416 1
a416 1
	HALEntry HAL_ExtMachineID
d418 1
a418 1
HAL_Entries	*	(. - HAL_EntryTable) / 4
d425 1
a425 1
	Entry	"v1-v3"
d427 2
a428 2
	STR	a2, NCNBWorkspace
	STR	a2, NCNBAllocNext
d430 1
a430 1
	BL	SetUpOSEntries
d432 61
a492 61
	; Map in the main IO ranges (L3, L4) and then store the offsets to the components
	; we're interested in
	MOV	a1, #0
	LDR	a2, =L3_ABE
	MOV	a3, #L3_ABE_Size
	CallOS	OS_MapInIO
	STR	a1, L3_Log

	MOV	a1, #0
	LDR	a2, =L4_ABE
	MOV	a3, #L4_ABE_Size
	CallOS	OS_MapInIO
	STR	a1, L4_ABE_Log

	; Timers
	ADD	a2, a1, #(TIMER_BASE - L4_ABE)
	STR	a2, Timers_Log

	MOV	a1, #0
	LDR	a2, =L4_Core
	MOV	a3, #L4_Core_Size
	CallOS	OS_MapInIO
	STR	a1, L4_Core_Log

	; ClockMan + ClockMan2
	ADD	a3, a1, #(L4_ClockMan - L4_Core)
	STR	a3, L4_ClockMan_Log
	ADD	a3, a1, #(L4_ClockMan2 - L4_Core)
	STR	a3, L4_ClockMan2_Log

	; USB
	ADD	a3, a1, #(L4_USBTLL - L4_Core)
	STR	a3, L4_USBTLL_Log
	ADD	a3, a1, #(L4_USB_Host - L4_Core)
	STR	a3, L4_USB_Host_Log
	ADD	a3, a1, #(L4_USB_OTG - L4_Core)
	STR	a3, L4_USB_OTG_Log

	; DMA
	ADD	a3, a1, #(L4_sDMA - L4_Core)
	STR	a3, L4_sDMA_Log

	MOV	a1, #0
	LDR	a2, =L4_Wakeup
	MOV	a3, #L4_Wakeup_Size
	CallOS	OS_MapInIO
	STR	a1, L4_Wakeup_Log

	; L4_PowerMan, L4_32KTIMER, L4_GPIO1
	ADD	a3, a1, #(L4_PowerMan - L4_Wakeup)
	STR	a3, L4_PowerMan_Log
	ADD	a3, a1, #(L4_32KTIMER - L4_Wakeup)
	STR	a3, L4_32KTIMER_Log
	ADD	a3, a1, #(L4_GPIO1 - L4_Wakeup)
	STR	a3, L4_GPIO1_Log

	MOV	a1, #0
	LDR	a2, =L4_Per
	MOV	a3, #L4_Per_Size
	CallOS	OS_MapInIO
	STR	a1, L4_Per_Log
d496 66
a561 66
;	; Display
;	ADD	a3, a1, #(L4_Display - L4_Per)
;	STR	a3, L4_Display_Log

	; GPIO2-6
	ADD	a2, a1, #(L4_GPIO2 - L4_Per)
	STR	a2, L4_GPIO2_Log
	ADD	a2, a1, #(L4_GPIO3 - L4_Per)
	STR	a2, L4_GPIO3_Log
	ADD	a2, a1, #(L4_GPIO4 - L4_Per)
	STR	a2, L4_GPIO4_Log
	ADD	a2, a1, #(L4_GPIO5 - L4_Per)
	STR	a2, L4_GPIO5_Log
	ADD	a2, a1, #(L4_GPIO6 - L4_Per)
	STR	a2, L4_GPIO6_Log

	; Display subsystem (DSS)
	MOV	a1, #0
	LDR	a2, =DSS_Base
	MOV	a3, #(32 * 1024)
	CallOS	OS_MapInIO
	STR	a1, L4_Display_Log

	; Interrupt controller
	MOV	a1, #0
	LDR	a2, =MPU_INTC
	MOV	a3, #MPU_INTC_SIZE
	CallOS	OS_MapInIO
	STR	a1, MPU_INTC_Log

	; GPMC
	MOV	a1, #0
	LDR	a2, =GPMC_Regs
	MOV	a3, #4096 ; only a small register file
	CallOS	OS_MapInIO
	STR	a1, GPMC_Regs_Log

	; Recover board config from SRAM
	MOV	a1, #0
	LDR	a2, =IntSRAM_Base
	MOV	a3, #IntSRAM_Size
	CallOS	OS_MapInIO
	STR	a1, IntSRAM_Log
	MOV	a2, #BoardConfig_Size
10	SUBS	a2, a2, #4
	LDR	a3, [a1, a2]
	STR	a3, [sb, a2]
	BGT	%BT10
	; Now do phys -> log conversion on all the addresses contained within
	; RISC OS doesn't currently provide a phys->log conversion function, so we do it
	; manually based around the regions that were mapped in above
	ASSERT	BoardConfig_DebugUART = 0
	ASSERT	BoardConfig_DebugUART+4 = BoardConfig_HALUART
	MOV	a1, #(BoardConfig_HALUART + ?BoardConfig_HALUART-4)
10	BL	phys2log
	SUBS	a1, a1, #4
	BGE	%BT10
	MOV	a1, #BoardConfig_HALI2C
	BL	phys2log
	STR	a2, (I2C1Block + I2C_HW)
	MOV	a1, #(BoardConfig_HALI2C + 4)
	BL	phys2log
	STR	a2, (I2C2Block + I2C_HW)
	MOV	a1, #(BoardConfig_HALI2C + 8)
	BL	phys2log
	STR	a2, (I2C3Block + I2C_HW)
d564 2
a565 2
	DebugTX "HAL_Init"
	DebugTime a1, "@@ "
d568 1
a568 1
	BL	PRCM_SetClocks	; Calls Timer_init & starts GPTIMER5
d570 1
a570 1
	BL	I2C_Init	; Uses GPTIMER5
d572 2
a573 2
	; Make sure all GPIO IRQs are disabled before we potentially start enabling them
	BL	GPIO_Init
d575 1
a575 1
	; nothing to do here for OMAP4
d577 11
a587 11
	; Do extra board-specific GPIO init
	; Touchbook & classic beagle need TPS LED A turning off for EHCI
	; Beagle xM needs TPS GPIO 1 off and TPS LED A on for DVI & EHCI
	; For the moment, just work out what board it is based around the
	; Linux machine ID & OMAP type
	LDR	a1, [sb, #BoardConfig_MachID]
	LDR	a2, =MachID_BeagleBoard
	CMP	a1, a2
	LDRNE	a2, =MachID_TouchBook
	CMPNE	a1, a2
	BNE	%FT20
d589 2
a590 2
	MOV	a1, #(GPIO_PIN_MAX + TPS_GPIO_PIN_MAX)
	BL	GPIOx_SetAsOutput
d595 1
a595 1
	DebugTX	"Video_init"
d597 1
a597 1
	BL	Video_init	; Uses GPTIMER5
d600 1
a600 1
	DebugTX	"USB_Init"
d602 1
a602 1
	BL	USB_Init	; Uses GPTIMER5
d605 1
a605 1
	DebugTX	"NVMemory_Init"
d607 1
a607 1
	BL	NVMemory_Init
d610 1
a610 1
	DebugTX	"Timer_Init"
d612 1
a612 1
	BL	Timer_Init	; Re-inits timers
d615 1
a615 1
	DebugTX	"Interrupt_Init"
d617 1
a617 1
	BL	Interrupt_Init
d620 1
a620 1
	DebugTX	"GPMC_Init"
d622 1
a622 1
	BL	GPMC_Init
d624 2
a625 2
	LDRB	v1, [sb, #BoardConfig_NumUART]
10	SUBS	v1, v1, #1
d627 10
a636 10
	BLT	%FT20
	; Don't reset the debug UART
	LDR	a3, [sb, #BoardConfig_DebugUART]
	ADD	a2, sb, v1, LSL #2
	LDR	a2, [a2, #BoardConfig_HALUART]
	CMP	a3, a2
	BEQ	%BT10
	MOV	a1, v1
	ADR	lr, %BT10
	B	HAL_UARTStartUp
d638 3
a640 3
	MOVGE	a1, v1
	ADRGE	lr, %BT10
	BGE	HAL_UARTStartUp
d644 2
a645 2
	; Mark HAL as initialised
	STR	pc, HALInitialised ; Any nonzero value will do
d647 1
a647 1
	DebugTime a1, "HAL initialised @@ "
d649 1
a649 1
	EXIT
d656 25
a680 25
	LDR	a3, [sb, a1]
	CMP	a3, #0 ; Null pointers are valid; ignore them
	MOVEQ	a2, #0
	MOVEQ	pc, lr
	LDR	a2, =L3_ABE
	SUB	a2, a3, a2
	CMP	a2, #L3_ABE_Size
	LDRLO	a3, L3_Log
	BLO	%FT10

	SUB	a2, a3, #L4_Per
	CMP	a2, #L4_Per_Size
	LDRLO	a3, L4_Per_Log
	BLO	%FT10

	SUB	a2, a3, #L4_ABE
	CMP	a2, #L4_ABE_Size
	LDRLO	a3, L4_ABE_Log
	BLO	%FT10

	SUB	a2, a3, #L4_Core
	CMP	a2, #L4_Core_Size
	LDRLO	a3, L4_Core_Log
	SUBHI	a2, a2, #(L4_Wakeup - L4_Core)
	LDRHI	a3, L4_Wakeup_Log
d682 3
a684 3
	ADD	a2, a2, a3
	STR	a2, [sb, a1]
	MOV	pc, lr
d687 16
a702 16
SetUpOSEntries	ROUT
	STR	a1, OSheader
	LDR	a2, [a1, #OSHdr_NumEntries]
	CMP	a2, #(HighestOSEntry + 1)
	MOVHI	a2, #(HighestOSEntry + 1)

	ADR	a3, OSentries
	LDR	a4, [a1, #OSHdr_Entries]
	ADD	a4, a4, a1

05	SUBS	a2, a2, #1
	LDR	ip, [a4, a2, LSL #2]
	ADD	ip, ip, a4
	STR	ip, [a3, a2, LSL #2]
	BNE	%BT05
	; Fall through
d705 1
a705 1
	MOV	pc, lr
d709 29
a737 29
	CMP	a1, #123
	BNE	%FT10
	LDR	a1, =&E51FF004
	ADR	a2, FIQRoutine
	MOV	a4, #&1C
	STMIA	a4,{a1-a2,sb}
	; Sync cache
	MOV	a1, #0
	MCR	p15, 0, a1, c7, c11, 1 ; Clean DCache by VA to PoU
	myDSB ; wait for clean to complete
	MCR	p15, 0, a1, c7, c5, 1 ; invalidate ICache entry (to PoC)
	MCR	p15, 0, a1, c7, c5, 6 ; invalidate entire BTC
	myDSB ; wait for cache invalidation to complete
	myISB ; wait for BTC invalidation to complete?
	; Now reconfigure the USER button (GPIO 7) to fire an FIQ
	LDR	a1, L4_GPIO1_Log
	LDR	a2, [a1, #GPIO_OE]
	ORR	a2, a2, #1:SHL:7 ; Configure as input
	STR	a2, [a1, #GPIO_OE]
	MOV	a2, #0
	STR	a2, [a1, #GPIO_LEVELDETECT0]
	STR	a2, [a1, #GPIO_LEVELDETECT1]
	STR	a2, [a1, #GPIO_FALLINGDETECT]
	MOV	a2, #1:SHL:7
	STR	a2, [a1, #GPIO_RISINGDETECT] ; Enable IRQ on rising edge
	STR	a2, [a1, #GPIO_IRQENABLE1] ; Set MPU as interrupt target
	MOV	a1, #29 ; GPIO1 IRQ
	; tail-optimised, repeating the HAL device init would be a bad thing!
	B	HAL_FIQEnable
d740 5
a744 5
	Entry	"v1-v3"
	DebugTime a1, "HAL_InitDevices @@ "
	; Common HAL devices
	BL	RTC_Init
	BL	SDMA_Init
d746 1
a746 1
	BL	VideoDevice_Init
d748 3
a750 3
	BL	Audio_Init
	; Board-specific HAL devices
	LDR	pc, [sb, #BoardConfig_InitDevices]
d752 2
a753 2
	DebugTime a1, "Done @@ "
	EXIT
d757 2
a758 2
	MOV	a1, #0
	MOV	pc, lr
d761 7
a767 7
	LDR	ip, =&FFFFFF00
	STR	ip, [a1]
	MOV	ip, #0
	STR	ip, [a2]
	LDR	ip, =&00FFFF00
	STR	ip, [a3]
	MOV	pc, lr
d770 10
a779 10
	; TouchBook can do soft-off, others can't (yet)
	LDR	ip, [sb, #BoardConfig_MachID]
	LDR	a1, =MachID_TouchBook
	CMP	ip, a1
	MOVNE	ip, #2_10000	; no podules,no PCI cards,no multi CPU,no soft off,and soft ROM
	MOVEQ	ip, #2_11000
	STR	ip, [a2]
	MOV	ip, #2_11111	; mask of valid bits
	STR	ip, [a3]
	MOV	pc, lr
d782 4
a785 4
	MOV	ip, #0
	STR	ip, [a1]
	STR	ip, [a2]
	MOV	pc, lr
d788 3
a790 3
	MOV	a1, #0
	MOV	a2, #0
	MOV	pc, lr
d793 3
a795 3
	MOVS	ip, a1
	MOV	a1, #16
	MOVEQ	pc, lr
d798 8
a805 8
	LDR	a2, L4_Core_Log
	ADD	a2, a2, #(L4_DIE_ID0 - L4_Core)
	LDR	a3, [a2], #8	; skip L4_CONTROL_IDCODE
	LDR	a4, [a2], #4
	STMIA	ip!, {a3-a4}
	LDMIA	a2, {a3-a4}
	STMIA	ip, {a3-a4}
	MOV	pc, lr
d808 3
a810 3
NibbleShift	*	12 ; 1<<12 = 4K ARM page size
ByteShift	*	NibbleShift + 1
WordShift	*	ByteShift + 2
d813 6
a818 6
NotPresent	*	&00000000
DRAM_Pattern	*	&11111111
VRAM_Pattern	*	&22222222
ROM_Pattern	*	&33333333
IO_Pattern	*	&44444444
NotAvailable	*	&88888888
d820 1
a820 1
	IMPORT	memset
d823 20
a842 20
	TEQ	a1, #0
	MOVEQ	a1, #1:SHL:(32-ByteShift)
	MOVEQ	pc, lr

	Push	"a2,v1,v2,lr"
	MOV	v1, a1
	ADR	v2, HAL_PhysTable
10	LDMIA	v2, {a1, a2, lr}
	SUB	a3, lr, a1
	ADD	a1, v1, a1, LSR #ByteShift
	MOV	a3, a3, LSR #ByteShift
	BL	memset
	LDR	a1, [v2, #8]!
	TEQ	a1, #0
	BNE	%BT10
	MOV	a1, #&80000000 ; Physical RAM from &80000000 and up?
	LDR	lr, =&FFFFE000-1
	Pull	"a2"
	STR	lr, [a2]
	Pull	"v1,v2,pc"
d847 5
a851 5
	DCD	&00000000, NotPresent  :OR: NotAvailable ; GPMC
	DCD	&40000000, IO_Pattern  :OR: NotAvailable ; All I/O registers
	DCD	&80000000, NotPresent  :OR: NotAvailable ; SDRC-SMS/SDRAM
	DCD	&FFFFE000, NotPresent  :OR: NotAvailable ; SDRC-SMS/SDRAM
	DCD	0
d854 15
a868 15
	; TouchBook can power off by setting GPIO168 to 0
	; TODO - Sort out the other machine types
	LDR	a3, [sb, #BoardConfig_MachID]
	LDR	a2, =MachID_TouchBook
	CMP	a3, a2
	CMPEQ	a1, #0
	BNE	%FT10
	MOV	a1, #168
	MOV	a2, #0
	BL	GPIOx_SetAsOutput
	; It seems like there's a short delay before the system shuts down; if we try doing a
	; soft reset during that time then we'll hang with the power still on
	; So just loop here, with a warning message for if something's gone wrong
	DebugTX	"TouchBook power off failed!"
	B	.
d870 8
a877 8
	; At the moment we only support resets, not power off
	; For a reset, we just poke PRM_RSTCTRL.RST_GLOBAL_WARM_software
	LDR	a3, L4_PowerMan_Log
	ADD	a3, a3, #DEVICE_PRM
	MOV	a2, #1
	STR	a2, [a3, #PRM_RSTCTRL]
	DebugTX	"HAL_Reset failed!"
	B	. ; Just in case
d879 1
a879 1
	LTORG
d881 1
a881 1
	EXPORT	vtophys
d883 1
a883 1
	CallOS	OS_LogToPhys, tailcall
d885 1
a885 1
	EXPORT	mapinio
d887 1
a887 1
	CallOS	OS_MapInIO, tailcall
d891 7
a897 7
	; Dump PC value to the serial port
	MOV	r8, #&24
	LDR	sb, [r8]
	LDR	r8, [sb, #BoardConfig_DebugUART]
	ADR	r9, hextab
	MOV	r10, #8
	MOV	r11, lr ; Preserve return address
d899 8
a906 8
	LDRB	r12, [r8, #UART_LSR]
	TST	r12, #UART_LSR_THRE
	BEQ	%BT10
	LDRB	r12, [r9, r11, LSR #28]
	STRB	r12, [r8, #UART_THR]
	MOV	r11, r11, LSL #4
	SUBS	r10, r10, #1
	BNE	%BT10
d908 5
a912 5
	LDRB	r12, [r8, #UART_LSR]
	TST	r12, #UART_LSR_THRE
	BEQ	%BT10
	MOV	r12, #13
	STRB	r12, [r8, #UART_THR]
d914 16
a929 16
	LDRB	r12, [r8, #UART_LSR]
	TST	r12, #UART_LSR_THRE
	BEQ	%BT10
	MOV	r12, #10
	STRB	r12, [r8, #UART_THR]
	; Clear interrupt
	MOV	r8, #&24
	LDR	sb, [r8]
	LDR	r8, L4_GPIO1_Log
	LDR	r10, [r8, #GPIO_IRQSTATUS1]
	STR	r10, [r8, #GPIO_IRQSTATUS1]
	LDR	r8, MPU_INTC_Log
	MOV	r10, #2
	STR	r10, [r8, #INTCPS_CONTROL]
	; Data synchronisation barrier to make sure INTC gets the message
	myDSB
d931 12
a942 12
	; Switch back to original mode
	MRS	r8, CPSR
	MRS	r9, SPSR
	BIC	r8, r8, #&1F
	AND	r9, r9, #&1F
	ORR	r8, r8, r9
	MSR	CPSR_c, r8
	; Dump the callstack & other regs
	Push	"sb" ; preserve original sb so it can be dumped
	MOV	sb, #&24
	LDR	sb, [sb]
	B	DebugCallstack
d944 2
a945 2
	; Now return
	SUBS	pc, lr, #4
d947 1
a947 1
hextab	DCB "0123456789abcdef"
d950 1
a950 1
	END
@


1.2
log
@Update to OMAP4 HAL.
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.Audio
    added further definitions for TWL6040 audio chip
    changes for working sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.SDMA
    added further register descriptions according OMAP4 TRM
    changes for working sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.UART
    added further register descriptions according OMAP4 TRM
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.omap4430
    added definitions for OMAP4460 (Panda ES)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.board
    adjusted max pixel-clock rate
    order of UART entries changed
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Boot
    don't reset debug UART
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Top
    modifications according to OMAP3 version
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.debug
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.UART
    changes according to hdr.UART changes; HAL_UARTModemControl
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.RAM
    use definitions from hdr.SDMA
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.SDMA
    use definitions from hdr.SDMA
    changes for working sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Video
    added code to VideoDevice_Activate (enable DSS power)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.omap4430
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.SDMA
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Audio
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.SDMA
    changes for working sound support

Submissions from Willi Theiss. Compiles, but not tested here.

Version 0.05. Tagged as 'OMAP4-0_05'
@
text
@d41 1
d45 5
a49 2
		GBLL FIQDebug
FIQDebug	SETL {FALSE}
d180 1
a180 1
	IMPORT	NVMem_Init
d565 1
d594 3
d599 3
d604 8
a611 2
	BL	NVMem_Init	; Uses GPTIMER5

d614 3
d619 3
d647 2
d740 2
a741 1
	Entry
d752 1
d797 1
a797 1
; OMAP4430: L4_CONTROL_IDCODE lies in between L4_DIE_ID0 and L4_DIE_ID1
d867 1
a867 1
	DebugTX "TouchBook power off failed!"
d876 1
a876 1
	DebugTX "HAL_Reset failed!"
@


1.1
log
@Initial revision
@
text
@a54 1
;	IMPORT	generate_POR_flags
d127 7
a133 1
;	DebugChar v1,v2,71
d135 2
a136 1
	MOV	a1, #OSStartFlag_RAMCleared
d545 1
a545 1
	MOV	a1, #(BoardConfig_HALUART + 4*2)
d603 12
d618 2
@


1.1.1.1
log
@  Initial import of OMAP4 HAL
Detail:
  Target platform is the Pandaboard, based on the TI OMAP4 SoC.
  Port is not yet complete, in particular, audio is not yet working.
Admin:
  Submission from Willi Theiß
@
text
@@

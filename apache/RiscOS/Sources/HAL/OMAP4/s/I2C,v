head	1.10;
access;
symbols
	OMAP4-0_60:1.10
	OMAP4-0_59-1_52_2_3:1.10
	OMAP4-0_59:1.10
	OMAP4-0_58:1.10
	OMAP4-0_57:1.10
	OMAP4-0_56:1.10
	OMAP4-0_55:1.10
	OMAP4-0_54-1_52_2_2:1.10
	OMAP4-0_54:1.10
	OMAP4-0_53:1.10
	OMAP4-0_52-1_52_2_1:1.10
	SMP:1.10.0.2
	SMP_bp:1.10
	OMAP4-0_52:1.10
	OMAP4-0_51:1.10
	OMAP4-0_50:1.10
	OMAP4-0_49:1.10
	OMAP4-0_48:1.10
	OMAP4-0_47:1.10
	OMAP4-0_46:1.10
	OMAP4-0_45:1.10
	OMAP4-0_44:1.10
	OMAP4-0_43:1.9
	OMAP4-0_42:1.9
	OMAP4-0_41:1.9
	OMAP4-0_40:1.9
	OMAP4-0_39:1.9
	OMAP4-0_38:1.9
	OMAP4-0_37:1.9
	OMAP4-0_36:1.9
	OMAP4-0_35:1.9
	OMAP4-0_34:1.8
	OMAP4-0_33:1.8
	OMAP4-0_32:1.7
	OMAP4-0_31:1.7
	OMAP4-0_30:1.7
	OMAP4-0_29:1.7
	OMAP4-0_28:1.7
	OMAP4-0_27:1.7
	OMAP4-0_26:1.7
	OMAP4-0_25:1.7
	OMAP4-0_24:1.7
	OMAP4-0_23:1.7
	OMAP4-0_22:1.7
	OMAP4-0_21:1.7
	OMAP4-0_20:1.6
	OMAP4-0_19:1.5
	OMAP4-0_18:1.4
	OMAP4-0_17:1.4
	OMAP4-0_16:1.4
	OMAP4-0_15:1.4
	OMAP4-0_14:1.4
	OMAP4-0_13:1.4
	OMAP4-0_12:1.4
	OMAP4-0_11:1.3
	OMAP4-0_10:1.2
	OMAP4-0_09:1.2
	OMAP4-0_08:1.2
	OMAP4-0_07:1.2
	OMAP4-0_06:1.1.1.1
	OMAP4-0_05:1.1.1.1
	OMAP4-0_04:1.1.1.1
	OMAP4-0_03:1.1.1.1
	OMAP4-0_02:1.1.1.1
	OMAP4-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2015.04.08.07.33.53;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	ziZUYwsqx4235Lgy;

1.9
date	2014.07.20.14.43.15;	author jlee;	state Exp;
branches;
next	1.8;
commitid	OEhWLReNWIhwS7Jx;

1.8
date	2014.04.14.19.25.46;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	L4Bu2kroUyJKyGwx;

1.7
date	2013.09.28.07.09.35;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	Iq3Q8pQtPDENQa7x;

1.6
date	2013.09.01.17.41.52;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	ZsMQPB6AP8ModL3x;

1.5
date	2013.09.01.17.37.22;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	GLy09A6uBpnXbL3x;

1.4
date	2012.07.09.07.22.43;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	Z61ud2LzYYd8gRbw;

1.3
date	2012.07.04.17.59.09;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	7eFD0kniLkapWgbw;

1.2
date	2012.03.25.11.42.57;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	4FjnaYBzkPTA6gYv;

1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;
commitid	M3eV6gzJuoHHMezv;

1.1.1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches;
next	;
commitid	M3eV6gzJuoHHMezv;


desc
@@


1.10
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Built, but not tested.

Version 0.44. Tagged as 'OMAP4-0_44'
@
text
@; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.omap4430
        GET     hdr.StaticWS
        GET     hdr.Timers
        GET     hdr.PRCM

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  I2C_Init

        EXPORT  HAL_IICBuses
        EXPORT  HAL_IICType
        EXPORT  HAL_IICDevice
        EXPORT  HAL_IICTransfer
        EXPORT  HAL_IICMonitorTransfer
        EXPORT  HAL_VideoIICOp
        EXPORT  IIC_DoOp_Poll

        IMPORT  HAL_CounterDelay

; The OMAP4430 has 5 I2C controllers:
; (usage on pandaboard)
; I2C1 - connected to the TWL6030 (power) and TWL6040 (audio) companion chip
;        RISC OS sees it as I2C bus 0.
;   used I2C addresses
;        TWL6030: 0x48, 0x49, 0x4A; TWL6040: 0x4B
; I2C2 - routed to the display expansion connector (external LCD control e.g. touchscreen)
;        RISC OS sees it as I2C bus 1.
; I2C3 - routed to DVI-D connector (P1) and Camera Expansion connector (J17)
;        This means its sole use is for reading EDID/DDC data.
;        RISC OS therefore accesses it via HAL_VideoIICOp.
; I2C4 - routed to WL1271 (BT/FM control) and Expansion Connectors J6 (future expansion)
;        RISC OS sees it as I2C bus 3.
; I2C5 - used for SmartReflex control (part of PRCM) in connection with TWL6030 power chip
;        RISC OS does not see this bus at all.

                GBLL    I2CDebug
I2CDebug        SETL    {FALSE} :LAND: Debug
;I2CDebug       SETL    {TRUE} :LAND: Debug

                GBLL    I2CDebugData ; Display bytes sent & received?
I2CDebugData    SETL    {FALSE} :LAND: I2CDebug
;I2CDebugData   SETL    {TRUE} :LAND: I2CDebug

                GBLL    I2CDebugError ; Debug unexpected_error occurences
I2CDebugError   SETL    {FALSE} :LAND: Debug
;I2CDebugError  SETL    {TRUE} :LAND: Debug

; ubuntu-omap4 does not use FIFO
                GBLL    I2C_USE_FIFO
I2C_USE_FIFO    SETL    {FALSE}

I2C_Init
        Push    "v1-v3,lr"
 [ I2CDebug
        DebugTX "I2C_Init"
 ]


;       ; 1. Make sure clocks are enabled
;        clocks are already activated by u-boot

        ; 2. Initialise each I2C controller
        MOV     v1, #MaxI2CControllers  ; max # of supported I2C interfaces
        ADR     v2, I2C_Table
10
 [ I2CDebug
        DebugReg  v1, "remaining busses: "
 ]
        LDR     v3, [v2, #I2C_HW]
        CMP     v3, #0
        BEQ     %FT30 ; Skip unused busses
        ; First we'll reset the controller
        LDRH    a4, [v3, #I2C_CON]
        TST     a4, #I2C_CON_EN
        BEQ     %FT20
        MOV     a4, #0
        STRH    a4, [v3, #I2C_CON]
20
        MOV     a4, #I2C_SYSC_SRST      ; soft reset
        STRH    a4, [v3, #I2C_SYSC]
        MOV     a4, #I2C_CON_EN
        STRH    a4, [v3, #I2C_CON]
20
        LDRH    a4, [v3, #I2C_SYSS]
        TST     a4, #I2C_SYSS_RDONE     ; reset done
        BEQ     %BT20
        ; Now disable the controller again so we can program it properly
        MOV     a4, #0
        STRH    a4, [v3, #I2C_CON]

        ; setup clock values according Table 23-8 and 23-9 (OMAP4 TRM Rev. O)
        ; based on I2Cn_FCLK 96 MHz
        ;
        ; fInternal = I2Cn_FCLK / (PSC + 1)
        ; tLow  = (SCLL + 7) * 1 / fInternal
        ; tHigh = (SCLH + 5) * 1 / fInternal
        ; fI2Cn = 1 / (tLow + tHigh)
        ; tLow == tHigh ==> valSCL = fInternal / (2 * fI2Cn)
        ;
        ;          PSC   SCLL   SCLH  fInternal  valSCL
        ; 100 kHz:  23     13     15    4.0 MHz      20
        ; 400 kHz:   9      5      7    9.6 MHz      12
        ;
        ; Run at 400kbps for now. TODO - Add support for higher speeds!
        MOV     a4, #(10 - 1)           ; 9.6 MHz
        STRH    a4, [v3, #I2C_PSC]
        MOV     a4, #(12 - 7)
        STRH    a4, [v3, #I2C_SCLL]
        MOV     a4, #(12 - 5)
        STRH    a4, [v3, #I2C_SCLH]
        ; Program own address
        MOV     a4, #1
        STRH    a4, [v3, #I2C_OA0]
        ; Set FIFO thresholds
  [ I2C_USE_FIFO
        LDRH    a4, [v3, #I2C_BUFSTAT]
        ADR     a3, fifo_thresholds
        AND     a4, a4, #I2C_BUFSTAT_FIFODEPTH  ; Get FIFO size
        LDR     a4, [a3, a4, LSR #12]
  |
        MOV     a4, #0
  ] ; I2C_USE_FIFO
        STRH    a4, [v3, #I2C_BUF]
        ; Enable auto idle, smart idle. Both clocks off when in idle mode?
        MOV     a4, #(I2C_SYSC_AUTOIDLE + I2C_SYSC_IDLEMODE_SMART)
        STRH    a4, [v3, #I2C_SYSC]
        ; Enable the controller
        MOV     a4, #I2C_CON_EN
        STRH    a4, [v3, #I2C_CON]
        ; Next!
        SUBS    v1, v1, #1
        ADD     v2, v2, #I2CBlockSize
        BNE     %BT10
        ; Done
30
 [ I2CDebug
        DebugTX "I2C_Init complete"
 ]
        Pull    "v1-v3,pc"

  [ I2C_USE_FIFO
fifo_thresholds
        DCD     &0606 ; 8 byte FIFO: Threshold at 7 bytes
        DCD     &0B0B ; 16 byte FIFO: Threshold at 12 bytes
        DCD     &1B1B ; 32 byte FIFO: Threshold at 28 bytes
        DCD     &3B3B ; 64 byte FIFO: Threshold at 60 bytes
  ] ; I2C_USE_FIFO

HAL_IICBuses
        LDRB    a1, [sb, #BoardConfig_NumI2C]
        MOV     pc, lr

HAL_IICType
        ; todo - set the 'missing flags' alluded to in Kernel.Docs.HAL.MoreEnts?
        ;        (multi-master & slave operation)
        LDRB    a2, [sb, #BoardConfig_NumI2C]
        CMP     a1, a2
        MOVHS   a1, #0
        LDRLO   a1, =IICFlag_HighLevel+IICFlag_Fast+IICFlag_Background+IICFlag_HighSpeed+(210:SHL:20)
        MOV     pc, lr

; HAL_IICDevice
; in:
;       r0 = bus number
; out:
;       r0 = device number

HAL_IICDevice
        LDRB    a3, [sb, #BoardConfig_NumI2C]
        CMP     a1, a3
        MOVHS   a1, #-1
        ADDLO   a3, sb, #BoardConfig_HALI2CIRQ
        LDRLOB  a1, [a3, a1]
        MOV     pc, lr

; HAL_IICTransfer
; in:
;      r0 = bus number
;      r1 = number of transfers
;      r2 = iic_transfer array ptr
; out:
;      r0 = IICStatus return code
; Transfer list format:
;      typedef struct iic_transfer
;      {
;        unsigned addr:8;
;        unsigned :22;
;        unsigned checksumonly:1;
;        unsigned nostart:1;
;        union
;        {   unsigned checksum;
;            void *data;
;        } d;
;        unsigned len;
;      } iic_transfer;

HAL_IICTransfer
        LDRB    a4, [sb, #BoardConfig_NumI2C]
        CMP     a1, a4
        MOVHS   a1, #IICStatus_Error
        MOVHS   pc, lr
        ; Quickly validate the transfer list
        ; We have several constraints:
        ; 1. Must have 1 or more iic_transfers
        ; 2. First transfer must not have nostart bit set
        ; 3. Between start bits (and between the last start bit and the end of the list)
        ;    there must be between 1 and 65536 bytes of data (but for the moment we do allow
        ;    individual iic_transfers to be 0-length)
        CMP     a2, #0
        MOVLT   a1, #IICStatus_Error
        MOVLT   pc, lr
        LDR     a4, [a3]
        TST     a4, #1:SHL:31   ; First transfer has nostart set!
        MOVNE   a1, #IICStatus_Error
        MOVNE   pc, lr
        STMFD   sp!, {v1-v5,lr}
        ADD     a4, a3, a2, LSL #3
        ADD     a4, a4, a2, LSL #2
        MOV     v1, a3
30
        MOV     v5, #-1
10
        LDMIB   v1!, {v2-v4}    ; data ptr & length from current transfer, flags from next
        ADD     v5, v5, v3
        CMP     v1, a4
        BEQ     %FT20           ; Last transfer just read
        TST     v4, #1:SHL:31
        BNE     %BT10           ; Still more data in this transfer
20
        CMP     v5, #65536
        MOVHS   a1, #IICStatus_Error    ; Too much (or too little) data
        LDMHSIA sp! ,{v1-v5,pc}
        CMP     v1, a4
        BNE     %BT30
_IICTransfer_Video ; Entry point for HAL_VideoIICOp
 [ I2CDebug
        DebugTX "HAL_IICTransfer"
        DebugReg a1, "bus="
        DebugReg a2, "num="
        DebugReg a3, "iic_transfer="
 ]
        ADR     v5, I2C_Table
        MOV     v4, #I2CBlockSize
        MLA     v5, a1, v4, v5
        MRS     ip, CPSR
        ORR     a4, ip, #I32_bit
        MSR     CPSR_c, a4              ; disable interrupts for atomic claim
        LDR     a4, [v5, #I2C_XStart]
        TEQ     a4, #0                  ; in use already?
        STREQ   a3, [v5, #I2C_XStart]   ; if not, claim it
        MSR     CPSR_c, ip
        MOVNE   a1, #IICStatus_Busy     ; if it is, return "BUSY"
 [ I2CDebug
        BEQ     %FT10
        DebugReg a4, "BUSY: XStart="
        LDMFD   sp!, {v1-v5,pc}
10
        DebugTX "OK"
 |
        LDMNEFD sp!, {v1-v5,pc}
 ]
        SUB     a2, a2, #1              ; a2 = transfers - 1 (needed below)
        ADD     v1, a3, a2, LSL #3
        ADD     v1, v1, a2, LSL #2
        STR     v1, [v5, #I2C_XEnd]
        LDR     v4, [v5, #I2C_HW]
        ; Make sure controller is enabled, since we don't do any initialisation atm!
        LDRH    a4, [v4, #I2C_CON]
        TST     a4, #I2C_CON_EN
        LDREQH  v3, [v4, #I2C_STAT]
 [ I2CDebugError
        BNE     %FT10
        DebugTX "Controller not enabled!"
        B       unexpected_error
10
 |
        BEQ     unexpected_error
 ]
        MOV     v1, a3
start_transfer ; Start the transfer in v1
        ; a1-a4 free
        ; v1 = iic_transfer to start
        ; v2-v3 free
        ; v4 = I2C controller ptr
        ; v5 = I2C state ptr
 [ I2CDebug
        DebugReg v1, "start_transfer: "
 ]
        STR     v1, [v5, #I2C_XCurrent]
        MOV     lr, #0
        STR     lr, [v5, #I2C_XBytes]
        ; Get its info
        LDMIA   v1, {a1-a3}
 [ I2CDebug
        DebugReg a1, "addr="
        DebugReg a2, "data="
        DebugReg a3, "len ="
 ]
        ; If it's a 'checksum-only' read, clear the checksum to 0
        TST     a1, #1:SHL:30
        TSTNE   a1, #1
        MOVNE   a2, #0
        STRNE   a2, [v1, #4]
        ; Wait for the controller to be fully idle - if two iic_transfer lists are executed
        ; back-to-back then there's a chance the controller won't have yet sent the stop bit
        ; from the previous transfer. Thus we must wait here for the bit to be sent.
        MOV     v2, #50*1024 ; timeout - this should be more than adequate (with a CPU of 500MHz, there'd be 1250 CPU clock cycles per 400kbps I2C clock cycle)
10
        LDRH    a4, [v4, #I2C_CON]
        TST     a4, #(I2C_CON_STT + I2C_CON_STP)
        ; Check STT and STP (Although we're primarily interested in STP, the manual warns
        ; about bad things happening if STT is cleared)
        BEQ     %FT20
        SUBS    v2, v2, #1
        BNE     %BT10
 [ I2CDebug
        DebugReg a4, "ISC_CON timeout: "
 ]
        MOV     a1, #IICStatus_Busy
        MOV     v3, #0
        STR     v3, [v5, #I2C_XStart]
        LDMFD   sp!, {v1-v5,pc}
20
        ; Configure controller
        ; 1. I2C_CON.MST, ISC_CON.TRX
        BIC     a4, a4, #(I2C_CON_STT+I2C_CON_STP+I2C_CON_XOA3+I2C_CON_XOA2+I2C_CON_XOA1+I2C_CON_XOA0)
        BIC     a4, a4, #(I2C_CON_STB+I2C_CON_MST+I2C_CON_TRX+I2C_CON_XSA)
        ORR     a4, a4, #I2C_CON_MST    ; Set MST (slave mode not supported ATM)
        TST     a1, #1
        ORREQ   a4, a4, #I2C_CON_TRX    ; Set transmitter mode if appropriate
        STRH    a4, [v4, #I2C_CON]
        ; Clear any pending interrupts, just in case?
        LDRH    v2, [v4, #I2C_STAT]
        STRH    v2, [v4, #I2C_STAT]
        ; 2. I2C_IE.XRDY_IE, I2C_IE.RRDY
        MOVEQ   v2, #(I2C_INT_AL + I2C_INT_NACK + I2C_INT_ARDY + I2C_INT_XRDY)
        MOVNE   v2, #(I2C_INT_AL + I2C_INT_NACK + I2C_INT_ARDY + I2C_INT_RRDY)
  [ I2C_USE_FIFO
        ORREQ   v2, v2, #I2C_INT_XDR
        ORRNE   v2, v2, #I2C_INT_RDR
  ] ; I2C_USE_FIFO
;       STRH    v2, [v4, #I2C_IE]
        STRH    v2, [v4, #I2C_IRQENABLE_SET]
        ; 3. Ignore DMA for now
        ; 4. I2C_SA, I2C_CNT
        MOV     v2, a1, LSR #1
        AND     v2, v2, #&7F
        STRH    v2, [v4, #I2C_SA]

        ; The I2C controller doesn't seem to like it if we don't send a start bit - it simply
        ; ignores I2C_CNT and goes straight to sending the stop bit (or sits there and does
        ; nothing if no stop bit was wanted).
        ; So to get around this we scan forward through the iic_transfer list and set I2C_CNT
        ; to the number of bytes to transmit before the next start/stop bit is required
        MOV     v2, v1
        LDR     ip, [v5, #I2C_XEnd]
10
        CMP     ip, v2
        ORREQ   a4, a4, #I2C_CON_STP    ; Last transfer in list; set stop bit

        BEQ     %FT20
        ADD     v2, v2, #12 ; Increment after compare, just in case some crazy person creates an iic_transfer that wraps from &FFF.... to &000...
        LDMIA   v2,{a1-a2,v3} ; Get transfer info
        TST     a1, #1:SHL:31
        ADDNE   a3, a3, v3 ; nostart is set; increment length and loop around
        BNE     %BT10
20
 [ I2CDebug
        DebugReg a3, "I2C_CNT="
 ]
        STRH    a3, [v4, #I2C_CNT]
        ; 5. Wait for I2C_STAT.BB to 0 (but only if this is the first iic_transfer of a
        ;    sequence - otherwise we'll be stuck waiting to unlock a bus we already own)
        LDR     v2, [v5, #I2C_XStart]
        CMP     v1, v2 ; v1 = I2C_XCurrent from earlier
        BNE     %FT20
        MOV     v2, #50*1024 ; timeout
10
        LDRH    v3, [v4, #I2C_STAT]
        TST     v3, #I2C_INT_BB
        BEQ     %FT20
        SUBS    v2, v2, #1
        BNE     %BT10
 [ I2CDebug
        DebugReg v3, "BB timeout: I2C_STAT="
 ]
        MOV     a1, #IICStatus_Busy
        B       clear_and_return
20
        ; 6. configure I2C_CON.STT=1, I2C_CON.STP=0/1
;       ORR     a4, a4, #(I2C_CON_STT + I2C_CON_STP)
        ORR     a4, a4, #(I2C_CON_STT)
        STRH    a4, [v4, #I2C_CON]
        ; Now we just sit back and wait for the interrupts?
 [ I2CDebug
        DebugTX "Transfer started"
 ]
        MOV     a1, #IICStatus_InProgress
        LDMFD   sp!, {v1-v5,pc}

        ; For receive:
        ; 1. Use I2C_IE.RRDY_IE
        ; 2. Except we use I2C_IE.RDR_IE if the receive size doesn't match the RX FIFO
        ;    threshold?
        ; For transmit:
        ; 1. Use I2C_IE.XRDY_IE
        ; 2. Except we use I2C_IE.XDR_IE if the length doesn't match the TX FIFO threshold?

; Return IICStatus state for transfer on bus r0
; Called on appropriate interrupt
HAL_IICMonitorTransfer
        ; Process the interrupts, according to figures 18-31/18-32 in spruf98b
        STMFD   sp!, {v1-v5,lr}
 [ I2CDebug
        DebugReg a1, "HAL_IICMonitorTransfer: bus "
 ]
        ADR     v5, I2C_Table
        MOV     v4, #I2CBlockSize
        MLA     v5, a1, v4, v5
        LDR     v4, [v5, #I2C_HW]
        LDR     a1, [v5, #I2C_XStart]
 [ I2CDebug
        DebugReg a1, "XStart="
 ]
        LDRH    v3, [v4, #I2C_STAT]
        TEQ     a1, #0 ; If no transfer, shut off all interrupts
        ASSERT  IICStatus_Completed=0
 [ I2CDebug
        BNE     %FT10
        DebugTX "No XStart!"
        TEQ     a1, #0 ; reset EQ condition
10
 ]
        MOVEQ   a1,#-1
        STREQH  a1, [v4, #I2C_IRQENABLE_CLR]
        STREQH  v3, [v4, #I2C_STAT]
        LDMEQFD sp!, {v1-v5,pc}
 [ I2CDebug
        DebugReg v3, "I2C_STAT="
 ]
        TST     v3, #I2C_INT_NACK
        BNE     i2c_nack
        TST     v3, #I2C_INT_AL
        BNE     i2c_al
        TST     v3, #I2C_INT_ARDY
        BNE     i2c_ardy
        TST     v3, #I2C_INT_XDR
        BNE     i2c_xdr
        TST     v3, #I2C_INT_XRDY
        BNE     i2c_xrdy
        TST     v3, #I2C_INT_RDR
        BNE     i2c_rdr
        TST     v3, #I2C_INT_RRDY
        BNE     i2c_rrdy
        ; Did anything actually happen?
        BIC     v3, v3, #(I2C_INT_BB+I2C_INT_ROVR+I2C_INT_XUDF+I2C_INT_BF)
        ; Clear XUDF, ROVR, BB, BF - they're status bits and don't indicate anything
        ; we care about here
        CMP     v3, #0
        MOVEQ   a1, #IICStatus_InProgress ; If nothing interesting happened, claim everything is OK (required for polling-mode transfers, e.g. HAL_VideoIICOp)
        LDMEQFD sp!, {v1-v5,pc}
        ; Else bad stuff - unhandled interrupt
 [ I2CDebugError
        DebugReg v3, "Unhandled IRQ - "
 ]
unexpected_error
        MOV     a1, #IICStatus_Error
        ; recover from error situation
recover_from_error
        MOV     v2, #0
        STRH    v2, [v4, #I2C_CON]
        MOV     v3, #-1
        STRH    v3, [v4, #I2C_STAT]
        STRH    v3, [v4, #I2C_IRQENABLE_CLR]
        STR     v2, [v5, #I2C_XStart]
        STRH    v2, [v4, #I2C_CNT]
        MOV     v2, #I2C_CON_EN
        STRH    v2, [v4, #I2C_CON]
        LDMFD   sp!, {v1-v5,pc}
clear_and_return
 [ I2CDebug
        DebugReg a1, "clear_and_return: "
 ]
        CMP     a1, #IICStatus_InProgress
        BHI     recover_from_error
        STRH    v3, [v4, #I2C_STAT]
        MOV     v3, #-1
        STRH    v3, [v4, #I2C_IRQENABLE_CLR]
        MOV     v3, #0
        STR     v3, [v5, #I2C_XStart]
        STRH    v3, [v4, #I2C_CNT]
        LDMFD   sp!, {v1-v5,pc}

i2c_nack
        ; No ack was received - give up and return error
        MOV     a1, #IICStatus_NoACK
        B       clear_and_return

i2c_al
        ; Arbitration lost - restart the transfer list
        STRH    v3, [v4, #I2C_STAT]
        LDR     v1, [v5, #I2C_XStart]
        B       start_transfer

i2c_ardy
        ; Previous transfer has completed successfully; start a new one
        LDR     a3, [v5, #I2C_XCurrent]
        LDR     a2, [v5, #I2C_XBytes]
        LDR     ip, [a3, #8]
        CMP     a2, ip
 [ I2CDebugError
        BEQ     %FT10
        DebugTX "HW requested wrong byte count"
        DebugReg a2, "I2C_XBytes="
        DebugReg ip, "xfer len="
        B       unexpected_error
10
 |
        BNE     unexpected_error ; Hardware hasn't requested the full number of bytes
 ]
        LDR     a4, [v5, #I2C_XEnd]
        CMP     a3, a4
        MOVEQ   a1, #IICStatus_Completed
        BEQ     clear_and_return
        ; Skip any zero-length nostart transfers that follow this one
        ADD     v1, a3, #12
10
        LDMIA   v1, {a1-a3}
        TST     a1, #1:SHL:31
        STREQH  v3, [v4, #I2C_STAT]
        BEQ     start_transfer
        CMP     a3, #0
 [ I2CDebugError
        BEQ     %FT5
        DebugReg a3, "nostart transfer with nonzero length, length="
        B       unexpected_error
5
 |
        BNE     unexpected_error ; nostart transfer with nonzero length = hardware hasn't requested full number of bytes
 ]
        CMP     v1, a4
        MOVEQ   a1, #IICStatus_Completed
        BEQ     clear_and_return
        ADD     v1, v1, #12
        B       %BT10


i2c_xdr
  [ I2C_USE_FIFO
        ; Transfer I2C_BUFSTAT[5:0] bytes
        LDRH    a4, [v4, #I2C_BUFSTAT]
        AND     a4, a4, #I2C_BUFSTAT_TXSTAT
  |
        MOV     a4, #1
  ] ; I2C_USE_FIFO
        B       send_bytes

i2c_xrdy
  [ I2C_USE_FIFO
        ; Transfer I2C_BUF[5:0]+1 bytes
        LDRH    a4, [v4, #I2C_BUF]
        AND     a4, a4, #I2C_BUF_TXTRSH
        ADD     a4, a4, #1
  |
        MOV     a4, #1
  ] ; I2C_USE_FIFO
send_bytes
 [ I2CDebug
        DebugReg  a4, "send_bytes: "
 ]
        LDR     v2, [v5, #I2C_XCurrent]
        LDR     a3, [v5, #I2C_XBytes] ; Get bytes sent
        LDMIB   v2, {a2,ip} ; Get data ptr, transfer length
10
        ; Check if we need to advance to the next iic_transfer
        CMP     a3, ip
        BEQ     %FT20
        LDRB    v1, [a2,a3]
 [ I2CDebugData
        DebugRegByte v1
 ]
        ADD     a3, a3, #1
        SUBS    a4, a4, #1
        STRB    v1, [v4, #I2C_DATA]
        BNE     %BT10
 [ I2CDebugData
        DebugTX ""
 ]
        STR     a3, [v5, #I2C_XBytes]
        MOV     a1, #IICStatus_InProgress
        STRH    v3, [v4, #I2C_STAT]
        LDMIA   sp!, {v1-v5,pc}
20
        ; Advance to next iic_transfer
        LDR     a3, [v5, #I2C_XEnd]
        CMP     a3, v2
 [ I2CDebugError
        BNE     %FT5
        DebugTX "End of transfer list but hardware wants more"
        B       unexpected_error
5
 |
        BEQ     unexpected_error ; Hardware is asking for more data than we can give
 ]
        ADD     v2, v2, #12
        STR     v2, [v5, #I2C_XCurrent]
        MOV     a3, #0
        STR     a3, [v5, #I2C_XBytes]
        LDMIA   v2, {a1-a2,ip}
        TST     a1, #1:SHL:31
        BNE     %BT10
 [ I2CDebugError
        DebugTX "nostart reached but hardware wants more"
 ]
        B       unexpected_error ; Hardware is asking for more data than we can give

i2c_rdr
  [ I2C_USE_FIFO
        ; Read I2C_BUFSTAT[13:8] bytes
        LDRH    a4, [v4, #I2C_BUFSTAT]
        ANDS    a4, a4, #I2C_BUFSTAT_RXSTAT ; ERRATA - sometimes RDR is set when there's no data. So, don't attempt to read from the empty buffer.
        MOVNE   a4, a4, LSR #I2C_BUFSTAT_RXSTAT_SHIFT
        BEQ     %FT15
  |
        MOV     a4, #1
  ] ; I2C_USE_FIFO
        B       read_bytes

i2c_rrdy
  [ I2C_USE_FIFO
        ; Read I2C_BUF[13:8]+1 bytes
        LDRH    a4, [v4, #I2C_BUF]
        AND     a4, a4, #I2C_BUF_RXTRSH
        MOV     a4, a4, LSR #I2C_BUF_RXTRSH_SHIFT
        ADD     a4, a4, #1
  |
        MOV     a4, #1
  ] ; I2C_USE_FIFO
read_bytes
 [ I2CDebug
        DebugReg  a4, "read_bytes: "
 ]
        LDR     v2, [v5, #I2C_XCurrent]
        LDMIA   v2, {a1-a2,ip} ; Get checksum flag, data ptr/checksum, transfer length
        LDR     a3, [v5, #I2C_XBytes] ; Get bytes received
10
        ; Check if we need to advance to the next iic_transfer
        CMP     a3, ip
        BEQ     %FT20
        TST     a1, #1:SHL:30 ; Checksum mode?
        LDRB    v1, [v4, #I2C_DATA]
        ADDNE   a2, a2, v1 ; adjust checksum
        STREQB  v1, [a2, a3]
 [ I2CDebugData
        DebugRegByte    v1
 ]
        SUBS    a4, a4, #1
        ADD     a3, a3, #1
        BNE     %BT10
 [ I2CDebugData
        DebugTX ""
 ]
        STR     a2, [v2, #4] ; Update checksum
        STR     a3, [v5, #I2C_XBytes]
15
        MOV     a1, #IICStatus_InProgress
        STRH    v3, [v4, #I2C_STAT]
        LDMIA   sp!, {v1-v5,pc}
20
        ; Advance to next iic_transfer
        LDR     a3, [v5, #I2C_XEnd]
        CMP     a3, v2
 [ I2CDebugError
        BNE     %FT5
        DebugTX "End of transfer list but hardware received more data"
        B       unexpected_error
5
 |
        BEQ     unexpected_error ; Hardware is receiving more data than we want
 ]
        ADD     v2, v2, #12
        STR     v2, [v5, #I2C_XCurrent]
        MOV     a3, #0
        STR     a3, [v5, #I2C_XBytes]
        LDMIA   v2, {a1-a2,ip}
        TST     a1, #1:SHL:31
 [ I2CDebugError
        BNE     %FT5
        DebugTX "nostart reached but hardware received more data"
        B       unexpected_error
5
 |
        BEQ     unexpected_error ; Hardware is receiving more data than we want
 ]
        TST     a1, #1:SHL:30 ; Checksum mode?
        MOVNE   a2, #0 ; Start with zero checksum (as per start_transfer)
        B       %BT10


; int HAL_VideoIICOp(uint32_t op, uint8_t *buffer, uint32_t *size)
; in:
;      r0 = b0-15 offset within IIC device to start at
;           b16-23 base IICAddress
;           b24-31 zero
;      r1 = buffer to read from/write to
;      r2 = pointer to number of bytes to transfer
; returns:
;      r0 = IICStatus return code
;      size = bytes successfully transferred (prior to any error)

HAL_VideoIICOp
        ; Make sure we've got a valid IIC bus to use
        LDRB    a4, [sb, #BoardConfig_VideoI2C]
        CMP     a4, #255
        MOV     ip, #0
        STREQ   ip, [a3]
        MOVEQ   a1, #IICStatus_Error
        MOVEQ   pc, lr
        ; Check if this is an EDID read or write
        UBFX    a4, a1, #16, #8
        TEQ     a4, #&a0 ; Don't allow writing to EDID for safety reasons
        STREQ   ip, [a3]
        MOVEQ   a1, #IICStatus_Error
        MOVEQ   pc, lr
        TEQ     a4, #&a1
        TSTNE   a1, #&ff00 ; If not EDID read, limit to 0-255 offset in device
        STRNE   ip, [a3]
        MOVNE   a1, #IICStatus_Completed
        MOVNE   pc, lr
        Push    "a1-a3,lr"
        LDR     a3, [a3]

        ; Build a set of iic_transfer blocks and call RISCOS_IICOpV
        ; We construct (up to) three iic_transfer blocks
        ; - First block is an (optional) single byte write to the EDID segment pointer
        ; - Second block is a single byte write containing the start address (lower 8 bits of r0)
        ; - Third block is a read. r2 bytes written to r1.
        ; The E-EDID EEPROM spec says that the segment pointer should auto-increment when a sequential (i.e. block) read occurs, so we shouldn't have to worry about splitting requests into 256 byte blocks and manually writing the pointer each time.
        ; Block 3:
        UBFX    a1, a1, #16, #8 ; Extract base IICAddress
        Push    "a1-a3"         ; Push the block on the stack (a2 & a3 are already correct)
        ; Block 2:
        BIC     a1, a1, #1      ; Clear RnW of base address
        ADD     a2, sp, #12     ; sp+12 should point to the 8 bit offset
        MOV     a3, #1
        Push    "a1-a3"
        ; Block 1:
        MOV     a1, #&60        ; Write to segment pointer
        ADD     a2, a2, #1      ; With bits 8-15 of the offset
        Push    "a1-a3"
        ; Work out if block 1 is needed or not
        LDR     a2, [sp, #36]   ; Get r0
        TST     a2, #&ff00      ; If segment == 0
        MOVEQ   a2, #0          ; ... then avoid matching address &A0/&A1
        AND     a2, a2, #&fe0000
        TEQ     a2, #&a00000
        ; Now attempt to start the transfer
        LDRB    a2, [sb, #BoardConfig_VideoI2C]
        MOV     a2, a2, LSL #24
        ADD     a2, a2, #3
        MOV     a1, sp
        SUBNE   a2, a2, #1      ; Skip block 1 if segment == 0 or not EDID addr
        ADDNE   a1, a1, #12
        ; If HAL_Init isn't done yet, we can't use RISCOS_IICOpV
        LDR     a3, HALInitialised
        CMP     a3, #0
        BEQ     %FT10
        LDR     a3, OSentries+4*OS_IICOpV
        BLX     a3
        B       %FT20
10
        BL      IIC_DoOp_Poll
20
        ; In case of error, assume nothing got transferred at all
        CMP     a1, #IICStatus_Completed
        LDREQ   a4, [sp, #(12*2)+(2*4)] ; Block 3 request size
        MOVNE   a4, #0
        ADD     sp, sp, #12*3           ; Junk the iic_transfer blocks
        STR     a1, [sp, #0]            ; Propagate return code
        LDR     a3, [sp, #8]
        STR     a4, [a3]                ; Actual transfer size
        Pull    "a1-a3,pc"

IIC_DoOp_Poll
        ; IIC transfer function that performs a polling transfer, similar to HAL_VideoIICOp
        ; This allows us to do IIC transfers before RISC OS is fully initialised (e.g. from inside HAL_Init)
        ; Parameters are identical to RISCOS_IICOpV:
        ; r0 = iic_transfer array ptr
        ; r1 = bits 0-23: iic_transfer count
        ;      bits 24-31: bus number
        ; Returns IICStatus return code in R0 (0 success, anything else failure)
        Push    "v1,lr"
 [ {FALSE}
        ; If IRQs and IIC IRQ are enabled, panic
        Push    "a1-a4"
        MRS     a1, CPSR
        TST     a1, #I32_bit
        BNE     %FT10
        ADR     a1, BoardConfig_HALI2CIRQ
        LDRB    a1, [a1, a2, LSR #24]
        IMPORT  HAL_IRQDisable
        BL      HAL_IRQDisable
        CMP     a1, #0
        BEQ     %FT10
        DebugTX "Warning - IIC_DoOp_Poll called with IIC IRQ enabled!"
        B       .
10
        Pull    "a1-a4"
 ]
        MOV     a3, a1
        MOV     a1, a2, LSR #24
        BIC     a2, a2, #&ff000000
        MOV     v1, a1
        BL      HAL_IICTransfer
        ; Now just poll until we're done
10
        CMP     a1, #IICStatus_InProgress ; Done?
        Pull    "v1,pc", NE
        ADR     lr, %BT10
        MOV     a1, v1
        B       HAL_IICMonitorTransfer

        END
@


1.9
log
@Disallow EDID writes. Add support for EDID reads which require the segment pointer to be set.
Detail:
  s/I2C - Revise HAL_VideoIICOp implementation to disallow EDID writes (&A0 IIC address). Attempt to write the EDID segment pointer when accessing EDID addresses >= 256.
Admin:
  Builds but untested
  Same code as OMAP3-0_97


Version 0.35. Tagged as 'OMAP4-0_35'
@
text
@a76 8

 [ I2CDebug :LOR: I2CDebugError
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
        IMPORT  DebugMemDump
        IMPORT  DebugHALPrintByte
 ]

@


1.8
log
@Changed to use simpler HAL_IICDevice

Version 0.33. Tagged as 'OMAP4-0_33'
@
text
@d735 1
a735 1
;      r0 = b0-15 offset within IIC device to start at (currently assumed 8 bit)
d752 11
a762 7
        ; Check for input passed end
        UBFX    a4, a1, #0, #16
        CMP     a4, #256
        STRCS   ip, [a3]
        MOVCS   a1, #IICStatus_Completed
        MOVCS   pc, lr
        ; Clip request at end
a764 3
        ADD     ip, a4, a3
        CMP     ip, #256
        RSBHI   a3, a4, #256
d767 6
a772 4
        ; We construct two iic_transfer blocks
        ; - First block is a single byte write containing the start address (lower 8 bits of r0)
        ; - Second block is a read. r2 bytes written to r1.
        ; Block 2:
d775 1
a775 1
        ; Block 1:
d780 10
a789 1

d793 1
a793 1
        ADD     a2, a2, #2
d795 2
d809 1
a809 1
        LDREQ   a4, [sp, #(3*4)+(2*4)]  ; Clipped block 2 request size
d811 1
a811 1
        ADD     sp, sp, #24             ; Junk the iic_transfer blocks
@


1.7
log
@Modification to RISCOS_IICOpV
Now assumes an IICStatus return, per Kernel-5_35-4_79_2_196.
Built, but not tested.

Version 0.21. Tagged as 'OMAP4-0_21'
@
text
@d197 1
a197 2
;       r0 = irq_descriptor ptr
;       r1 = bus number
d199 2
a200 16
;       r0 filled in
; typedef struct irq_descriptor
; {
;     int device;
;     union {
;        struct {
;          unsigned char *addr;
;          int maskandpolarity;
;        } bit;
;        struct {
;          int (*forme)(void *handle);
;          void *handle;
;        } func;
;     } sub;
; } irq_descriptor;
;
d203 2
a204 2
        CMP     a2, a3
        MOVHS   a2, #-1
d206 1
a206 4
        LDRLOB  a2, [a3, a2]
        MOV     a3, #0
        MOV     a4, #0
        STMIA   a1, {a2-a4}
@


1.6
log
@Whitespace changes
Code and hashes lined up nicely.
Not tagged.
@
text
@a24 2
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
a806 9
        ; Unmap RISC OS error numbers to IICStatus return codes
        ASSERT  IICStatus_Completed = 0
        TEQ     a1, #0
        LDRNE   a1, [a1]
        LDRNE   lr, =ErrorNumber_IIC_NoAcknowledge
        SUBNE   a1, a1, lr              ;   0/1/2 = NoAck/Error/Busy
        USATNE  a1, #2, a1              ; 4+ => 3 = Error
        ADRNE   lr, %FT05
        LDRNEB  a1, [lr, a1]
a807 4
05
        ASSERT  (ErrorNumber_IIC_Error - ErrorNumber_IIC_NoAcknowledge) = 1
        ASSERT  (ErrorNumber_IIC_Busy - ErrorNumber_IIC_NoAcknowledge) = 2
        DCB     IICStatus_NoACK, IICStatus_Error, IICStatus_Busy, IICStatus_Error
@


1.5
log
@Add support for all 4 I2C interfaces
hdr.board
    support all 4 I2C interfaces
    added BoardFlags variable
    remove unused BoardConfig_APLL_CTL variable
hdr.StaticWS
    support all 4 I2C interfaces on OMAP4
board.s
    removed unused parameter apll_ctl
    added support for all 4 I2C and UART interfaces
    added BoardFlags variable
Boot.s
    support all 4 I2C interfaces
    some code tweaks (tidy up)
    removed unused Touchbook code
I2C.s
    support all 4 I2C interfaces
    some code cleanup and comment correction
Submission from Willi Theiss.

Version 0.19. Tagged as 'OMAP4-0_19'
@
text
@d766 6
a771 6
        LDRB      a4, [sb, #BoardConfig_VideoI2C]
        CMP       a4, #255
        MOV       ip, #0
        STREQ     ip, [a3]
        MOVEQ     a1, #IICStatus_Error
        MOVEQ     pc, lr
d773 5
a777 5
        UBFX      a4, a1, #0, #16
        CMP       a4, #256
        STRCS     ip, [a3]
        MOVCS     a1, #IICStatus_Completed
        MOVCS     pc, lr
d779 5
a783 5
        Push      "a1-a3,lr"
        LDR       a3, [a3]
        ADD       ip, a4, a3
        CMP       ip, #256
        RSBHI     a3, a4, #256
d790 2
a791 2
        UBFX      a1, a1, #16, #8 ; Extract base IICAddress
        Push      "a1-a3"         ; Push the block on the stack (a2 & a3 are already correct)
d793 4
a796 4
        BIC       a1, a1, #1      ; Clear RnW of base address
        ADD       a2, sp, #12     ; sp+12 should point to the 8 bit offset
        MOV       a3, #1
        Push      "a1-a3"
d799 4
a802 4
        LDRB      a2, [sb, #BoardConfig_VideoI2C]
        MOV       a2, a2, LSL #24
        ADD       a2, a2, #2
        MOV       a1, sp
d804 5
a808 5
        LDR       a3, HALInitialised
        CMP       a3, #0
        BEQ       %FT10
        LDR       a3, OSentries+4*OS_IICOpV
        BLX       a3
d810 9
a818 9
        ASSERT    IICStatus_Completed = 0
        TEQ       a1, #0
        LDRNE     a1, [a1]
        LDRNE     lr, =ErrorNumber_IIC_NoAcknowledge
        SUBNE     a1, a1, lr             ;   0/1/2 = NoAck/Error/Busy
        USATNE    a1, #2, a1             ; 4+ => 3 = Error
        ADRNE     lr, %FT05
        LDRNEB    a1, [lr, a1]
        B         %FT20
d820 3
a822 3
        ASSERT    (ErrorNumber_IIC_Error - ErrorNumber_IIC_NoAcknowledge) = 1
        ASSERT    (ErrorNumber_IIC_Busy - ErrorNumber_IIC_NoAcknowledge) = 2
        DCB       IICStatus_NoACK, IICStatus_Error, IICStatus_Busy, IICStatus_Error
d824 1
a824 1
        BL        IIC_DoOp_Poll
d827 9
a835 9
        CMP       a1, #IICStatus_Completed
        LDREQ     a4, [sp, #(3*4)+(2*4)] ; Clipped block 2 request size
        MOVNE     a4, #0
        ADD       sp, sp, #24            ; Junk the iic_transfer blocks
        STR       a1, [sp, #0]           ; Propagate return code
        LDR       a3, [sp, #8]
        STR       a4, [a3]               ; Actual transfer size
        Pull      "a1-a3,pc"
        
@


1.4
log
@Adopt revised HAL_PhysInfo API
Also spotted that USAT can be conditional in the I2C code.

Version 0.12. Tagged as 'OMAP4-0_12'
@
text
@d47 1
a47 1
; The OMAP4430 has 4 I2C controllers:
d59 3
a61 1
;        RISC OS does not use this bus at all, and neither does this code.
a92 1
; clocks are already activated by u-boot
d95 1
a95 10
;       LDR     a1, L4_ClockMan_Log
;       LDR     a2, [a1, #CM_ICLKEN1_CORE]
;       ORR     a2, a2, #7:SHL:15
;       STR     a2, [a1, #CM_ICLKEN1_CORE]
;       LDR     a2, [a1, #CM_FCLKEN1_CORE]
;       ORR     a2, a2, #7:SHL:15
;       STR     a2, [a1, #CM_FCLKEN1_CORE]
;       ; Wait for power?
;       MOV     a1, #50*1024 ; 50msec ish
;       BL      HAL_CounterDelay
d98 1
a98 1
        MOV     v1, #3
a112 4
        ; The manual makes no mention of it, but u-boot waits for a while after
        ; enabling & disabling each controller. So to play it safe I'll follow u-boot's lead.
;       MOV     a1, #50*1024 ; 50msec ish
;       BL      HAL_CounterDelay
a117 3
;       ; Wait
;       MOV     a1, #10*1024 ; 10msec ish
;       BL      HAL_CounterDelay
a124 3
;       ; Wait
;       MOV     a1, #50*1024 ; 50msec ish
;       BL      HAL_CounterDelay
d126 1
a126 1
        ; setup clock values according Table 23-9 (OMAP4 TRM Rev. O)
d128 11
a138 3
        ;          PSC   SCLL   SCLH
        ; 100 kHz:  23     13     15
        ; 400 kHz:   9      5      7
d142 1
a142 1
        MOV     a4, #(6 - 1)
d144 1
a144 1
        MOV     a4, #(8 - 1)
a168 3
;       ; Wait for last controller to init fully
;       MOV     a1, #10*1024 ; 10msec ish
;       BL      HAL_CounterDelay
d487 1
a487 2
;       STREQH  a1, [v4, #I2C_IE]
        MOV     a1,#-1
d527 1
d540 2
d605 1
a605 1
        AND     a4, a4, #&3F
d615 1
a615 1
        AND     a4, a4, #&3F
d674 2
a675 2
        MOV     a4, a4, LSR #8
        ANDS    a4, a4, #&3F ; ERRATA - sometimes RDR is set when there's no data. So, don't attempt to read from the empty buffer.
d686 2
a687 2
        MOV     a4, a4, LSR #8
        AND     a4, a4, #&3F
@


1.3
log
@Refactor HAL_VideoIICOp to be ATPCS
No longer specified to return _kernel_oserror * implements GraphicsV 14.
Make use of IICStatus defines instead of local copies.
Rename HAL_Video_ to HAL_Video.
Compiles, but not tested.


Version 0.11. Tagged as 'OMAP4-0_11'
@
text
@d826 1
a826 1
        USAT      a1, #2, a1             ; 4+ => 3 = Error
@


1.2
log
@Bulk expand of tabs.
Helps to make tracking changes between OMAP3 and OMAP4 less eye watering, but otherwise functionally the same as 0.06.

Version 0.07. Tagged as 'OMAP4-0_07'
@
text
@d25 2
d42 1
a42 1
        EXPORT  HAL_Video_IICOp
d57 1
a57 1
;        RISC OS therefore accesses it via HAL_Video_IICOp.
d248 1
a248 1
;      r0 = E* return code
d266 1
a266 1
        MOVHS   a1, #EERROR
d276 1
a276 1
        MOVLT   a1, #EERROR
d280 1
a280 1
        MOVNE   a1, #EERROR
d297 1
a297 1
        MOVHS   a1, #EERROR     ; Too much (or too little) data
d301 1
a301 1
_IICTransfer_Video ; Entry point for HAL_Video_IICOp
d318 1
a318 1
        MOVNE   a1, #EBUSY              ; if it is, return "BUSY"
d385 1
a385 1
        MOV     a1, #EBUSY
d453 1
a453 1
        MOV     a1, #EBUSY
d464 1
a464 1
        MOV     a1, #EINPROGRESS
d475 1
a475 1
; Return E* state for transfer on bus r0
d493 1
a493 1
        ASSERT  ECOMPLETED=0
d527 1
a527 1
        MOVEQ   a1, #EINPROGRESS ; If nothing interesting happened, claim everything is OK (required for polling-mode transfers, e.g. HAL_Video_IICOp)
d534 1
a534 1
        MOV     a1, #EERROR
d550 1
a550 1
        CMP     a1, #EINPROGRESS
d560 1
a560 1
        MOV     a1, #ENOACK
d587 1
a587 1
        MOVEQ   a1, #ECOMPLETED
d606 1
a606 1
        MOVEQ   a1, #ECOMPLETED
d654 1
a654 1
        MOV     a1, #EINPROGRESS
d730 1
a730 1
        MOV     a1, #EINPROGRESS
d764 32
a795 20
; HAL_Video_IICOp
; Officially:
;  r0 = card<<28 + channel<<24 + I2Ccmnd << 16 + address
;  I2Ccmnd = 1 for read, 0 write
;  r1 = DMA address
;  r2 = byte count
;  Returns:
;  r0 = 0 or error block
;  r1 updated
;  r2 updated
; In reality:
;  r0 = as above. The NVidia driver describes 'address' as being 11-bit, but only seems to handle it as 8-bit. The address is the offset to read from in the EDID data (Only EDID is supported, at I2C address 0x50. DDC, which is apparently at 0x37, isn't supported)
;  r1 = logical address
;  r2 = byte count
;  Returns:
;  r0 = 0 on success, unmodified on error (which also be 0 for a write to 0 on card 0 channel 0?!)
;  r1 = r1+r2 on success, unmodified on error
;  r2 = 0 on success, unmodified on error
;  There appears to be no support for partial transfers; NVidia driver implementation simply writes corrupt data for any failed bytes.
HAL_Video_IICOp
d797 3
a799 14
        ; First let's discard writes, to be equivalent to the NVidia driver
        TST     a1, #1<<16
        ; Also make sure we've got a valid IIC bus to use
        LDRB    a4, [sb, #BoardConfig_VideoI2C]
        CMPNE   a4, #255
        MOVEQ   pc, lr
        ; Also check we're transferring a valid number of bytes
        SUB     a4, a3, #1
        CMP     a4, #65536
        MOVHS   pc, lr
        Push    "a1-a3,lr"
        ; Now we construct two iic_transfer blocks
        ; - First block is a write to 0x50. Single byte containing EDID start address (lower 8 bits of r0)
        ; - Second block is a read from 0x50. r2 bytes written to r1.
d801 2
a802 4
        TST     a1, #1<<16 ; Is this read or write? (although this code isn't guaranteed to work properly for EDID writes!)
        MOVNE   a1, #&a1 ; Read from I2C
        MOVEQ   a1, #&a0 ; Write to I2C
        Push    "a1-a3" ; Push the block on the stack (a2 & a3 are already correct)
d804 5
a808 4
        MOV     a1, #&a0
        ADD     a2, sp, #12 ; sp+12 should point to the 8 bit EDID address
        MOV     a3, #1
        Push    "a1-a3"
d810 37
a846 19
        LDRB    a2, [sb, #BoardConfig_VideoI2C]
        MOV     a2, a2, LSL #24
        ADD     a2, a2, #2
        MOV     a1, sp
        ; If HAL_Init isn't done yet, we can't use OS_IICOpV
        LDR     a3, HALInitialised
        CMP     a3, #0
        ADREQ   a3, IIC_DoOp_Poll
        LDRNE   a3, OSentries+4*OS_IICOpV
        BLX     a3
        ; On error, return with unmodified regs, ala NVidia driver
        CMP     a1, #0
        ADD     sp, sp, #24
        Pull    "a1-a3,lr"
        ADDEQ   a2, a2, a3
        MOVEQ   a1, #0
        MOVEQ   a3, #0
        MOV     pc, lr

d848 1
a848 1
        ; IIC transfer function that performs a polling transfer, similar to HAL_Video_IICOp
d854 1
a854 1
        ; Returns E* return code in R0 (0 success, anything else failure)
d880 1
a880 1
        CMP     a1, #EINPROGRESS ; Done?
@


1.1
log
@Initial revision
@
text
@d16 26
a41 26
	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:Machine.<Machine>
	GET	Hdr:ImageSize.<ImageSize>
	$GetIO

	GET	Hdr:OSEntries
	GET	Hdr:HALEntries

	GET	hdr.omap4430
	GET	hdr.StaticWS
	GET	hdr.Timers
	GET	hdr.PRCM

	AREA	|Asm$$Code|, CODE, READONLY, PIC

	EXPORT	I2C_Init

	EXPORT	HAL_IICBuses
	EXPORT	HAL_IICType
	EXPORT	HAL_IICDevice
	EXPORT	HAL_IICTransfer
	EXPORT	HAL_IICMonitorTransfer
	EXPORT	HAL_Video_IICOp
	EXPORT	IIC_DoOp_Poll
d43 1
a43 1
	IMPORT	HAL_CounterDelay
d59 11
a69 11
		GBLL	I2CDebug
I2CDebug	SETL	{FALSE} :LAND: Debug
;I2CDebug	SETL	{TRUE} :LAND: Debug

		GBLL	I2CDebugData ; Display bytes sent & received?
I2CDebugData	SETL	{FALSE} :LAND: I2CDebug
;I2CDebugData	SETL	{TRUE} :LAND: I2CDebug

		GBLL	I2CDebugError ; Debug unexpected_error occurences
I2CDebugError	SETL	{FALSE} :LAND: Debug
;I2CDebugError	SETL	{TRUE} :LAND: Debug
d72 2
a73 2
		GBLL	I2C_USE_FIFO
I2C_USE_FIFO	SETL	{FALSE}
d77 4
a80 4
	IMPORT	DebugHALPrint
	IMPORT	DebugHALPrintReg
	IMPORT	DebugMemDump
	IMPORT	DebugHALPrintByte
d84 1
a84 1
	Push	"v1-v3,lr"
d86 1
a86 1
	DebugTX "I2C_Init"
d91 32
a122 32
;	; 1. Make sure clocks are enabled
;	LDR	a1, L4_ClockMan_Log
;	LDR	a2, [a1, #CM_ICLKEN1_CORE]
;	ORR	a2, a2, #7:SHL:15
;	STR	a2, [a1, #CM_ICLKEN1_CORE]
;	LDR	a2, [a1, #CM_FCLKEN1_CORE]
;	ORR	a2, a2, #7:SHL:15
;	STR	a2, [a1, #CM_FCLKEN1_CORE]
;	; Wait for power?
;	MOV	a1, #50*1024 ; 50msec ish
;	BL	HAL_CounterDelay

	; 2. Initialise each I2C controller
	MOV	v1, #3
	ADR	v2, I2C_Table
10
 [ I2CDebug
	DebugReg  v1, "remaining busses: "
 ]
	LDR	v3, [v2, #I2C_HW]
	CMP	v3, #0
	BEQ	%FT30 ; Skip unused busses
	; First we'll reset the controller
	LDRH	a4, [v3, #I2C_CON]
	TST	a4, #I2C_CON_EN
	BEQ	%FT20
	MOV	a4, #0
	STRH	a4, [v3, #I2C_CON]
	; The manual makes no mention of it, but u-boot waits for a while after
	; enabling & disabling each controller. So to play it safe I'll follow u-boot's lead.
;	MOV	a1, #50*1024 ; 50msec ish
;	BL	HAL_CounterDelay
d124 7
a130 7
	MOV	a4, #I2C_SYSC_SRST	; soft reset
	STRH	a4, [v3, #I2C_SYSC]
	MOV	a4, #I2C_CON_EN
	STRH	a4, [v3, #I2C_CON]
;	; Wait
;	MOV	a1, #10*1024 ; 10msec ish
;	BL	HAL_CounterDelay
d132 26
a157 26
	LDRH	a4, [v3, #I2C_SYSS]
	TST	a4, #I2C_SYSS_RDONE	; reset done
	BEQ	%BT20
	; Now disable the controller again so we can program it properly
	MOV	a4, #0
	STRH	a4, [v3, #I2C_CON]
;	; Wait
;	MOV	a1, #50*1024 ; 50msec ish
;	BL	HAL_CounterDelay

	; setup clock values according Table 23-9 (OMAP4 TRM Rev. O)
	; based on I2Cn_FCLK 96 MHz
	;          PSC   SCLL   SCLH
	; 100 kHz:  23     13     15
	; 400 kHz:   9      5      7
	; Run at 400kbps for now. TODO - Add support for higher speeds!
	MOV	a4, #(10 - 1)		; 9.6 MHz
	STRH	a4, [v3, #I2C_PSC]
	MOV	a4, #(6 - 1)
	STRH	a4, [v3, #I2C_SCLL]
	MOV	a4, #(8 - 1)
	STRH	a4, [v3, #I2C_SCLH]
	; Program own address
	MOV	a4, #1
	STRH	a4, [v3, #I2C_OA0]
	; Set FIFO thresholds
d159 4
a162 4
	LDRH	a4, [v3, #I2C_BUFSTAT]
	ADR	a3, fifo_thresholds
	AND	a4, a4, #I2C_BUFSTAT_FIFODEPTH	; Get FIFO size
	LDR	a4, [a3, a4, LSR #12]
d164 1
a164 1
	MOV	a4, #0
d166 15
a180 15
	STRH	a4, [v3, #I2C_BUF]
	; Enable auto idle, smart idle. Both clocks off when in idle mode?
	MOV	a4, #(I2C_SYSC_AUTOIDLE + I2C_SYSC_IDLEMODE_SMART)
	STRH	a4, [v3, #I2C_SYSC]
	; Enable the controller
	MOV	a4, #I2C_CON_EN
	STRH	a4, [v3, #I2C_CON]
	; Next!
	SUBS	v1, v1, #1
	ADD	v2, v2, #I2CBlockSize
	BNE	%BT10
;	; Wait for last controller to init fully
;	MOV	a1, #10*1024 ; 10msec ish
;	BL	HAL_CounterDelay
	; Done
d183 1
a183 1
	DebugTX "I2C_Init complete"
d185 1
a185 1
	Pull	"v1-v3,pc"
d189 4
a192 4
	DCD	&0606 ; 8 byte FIFO: Threshold at 7 bytes
	DCD	&0B0B ; 16 byte FIFO: Threshold at 12 bytes
	DCD	&1B1B ; 32 byte FIFO: Threshold at 28 bytes
	DCD	&3B3B ; 64 byte FIFO: Threshold at 60 bytes
d196 2
a197 2
	LDRB	a1, [sb, #BoardConfig_NumI2C]
	MOV	pc, lr
d200 7
a206 7
	; todo - set the 'missing flags' alluded to in Kernel.Docs.HAL.MoreEnts?
	;        (multi-master & slave operation)
	LDRB	a2, [sb, #BoardConfig_NumI2C]
	CMP	a1, a2
	MOVHS	a1, #0
	LDRLO	a1, =IICFlag_HighLevel+IICFlag_Fast+IICFlag_Background+IICFlag_HighSpeed+(210:SHL:20)
	MOV	pc, lr
d210 2
a211 2
;	r0 = irq_descriptor ptr
;	r1 = bus number
d213 1
a213 1
;	r0 filled in
d218 8
a225 8
;	 struct {
;	   unsigned char *addr;
;	   int maskandpolarity;
;	 } bit;
;	 struct {
;	   int (*forme)(void *handle);
;	   void *handle;
;	 } func;
d230 9
a238 9
	LDRB	a3, [sb, #BoardConfig_NumI2C]
	CMP	a2, a3
	MOVHS	a2, #-1
	ADDLO	a3, sb, #BoardConfig_HALI2CIRQ
	LDRLOB	a2, [a3, a2]
	MOV	a3, #0
	MOV	a4, #0
	STMIA	a1, {a2-a4}
	MOV	pc, lr
d250 9
a258 9
;	 unsigned addr:8;
;	 unsigned :22;
;	 unsigned checksumonly:1;
;	 unsigned nostart:1;
;	 union
;	 {   unsigned checksum;
;	     void *data;
;	 } d;
;	 unsigned len;
d262 22
a283 22
	LDRB	a4, [sb, #BoardConfig_NumI2C]
	CMP	a1, a4
	MOVHS	a1, #EERROR
	MOVHS	pc, lr
	; Quickly validate the transfer list
	; We have several constraints:
	; 1. Must have 1 or more iic_transfers
	; 2. First transfer must not have nostart bit set
	; 3. Between start bits (and between the last start bit and the end of the list)
	;    there must be between 1 and 65536 bytes of data (but for the moment we do allow
	;    individual iic_transfers to be 0-length)
	CMP	a2, #0
	MOVLT	a1, #EERROR
	MOVLT	pc, lr
	LDR	a4, [a3]
	TST	a4, #1:SHL:31	; First transfer has nostart set!
	MOVNE	a1, #EERROR
	MOVNE	pc, lr
	STMFD	sp!, {v1-v5,lr}
	ADD	a4, a3, a2, LSL #3
	ADD	a4, a4, a2, LSL #2
	MOV	v1, a3
d285 1
a285 1
	MOV	v5, #-1
d287 6
a292 6
	LDMIB	v1!, {v2-v4}	; data ptr & length from current transfer, flags from next
	ADD	v5, v5, v3
	CMP	v1, a4
	BEQ	%FT20		; Last transfer just read
	TST	v4, #1:SHL:31
	BNE	%BT10		; Still more data in this transfer
d294 5
a298 5
	CMP	v5, #65536
	MOVHS	a1, #EERROR	; Too much (or too little) data
	LDMHSIA	sp! ,{v1-v5,pc}
	CMP	v1, a4
	BNE	%BT30
d301 20
a320 20
	DebugTX "HAL_IICTransfer"
	DebugReg a1, "bus="
	DebugReg a2, "num="
	DebugReg a3, "iic_transfer="
 ]
	ADR	v5, I2C_Table
	MOV	v4, #I2CBlockSize
	MLA	v5, a1, v4, v5
	MRS	ip, CPSR
	ORR	a4, ip, #I32_bit
	MSR	CPSR_c, a4		; disable interrupts for atomic claim
	LDR	a4, [v5, #I2C_XStart]
	TEQ	a4, #0			; in use already?
	STREQ	a3, [v5, #I2C_XStart]	; if not, claim it
	MSR	CPSR_c, ip
	MOVNE	a1, #EBUSY		; if it is, return "BUSY"
 [ I2CDebug
	BEQ	%FT10
	DebugReg a4, "BUSY: XStart="
	LDMFD	sp!, {v1-v5,pc}
d322 1
a322 1
	DebugTX	"OK"
d324 1
a324 1
	LDMNEFD	sp!, {v1-v5,pc}
d326 9
a334 9
	SUB	a2, a2, #1		; a2 = transfers - 1 (needed below)
	ADD	v1, a3, a2, LSL #3
	ADD	v1, v1, a2, LSL #2
	STR	v1, [v5, #I2C_XEnd]
	LDR	v4, [v5, #I2C_HW]
	; Make sure controller is enabled, since we don't do any initialisation atm!
	LDRH	a4, [v4, #I2C_CON]
	TST	a4, #I2C_CON_EN
	LDREQH	v3, [v4, #I2C_STAT]
d336 3
a338 3
	BNE	%FT10
	DebugTX	"Controller not enabled!"
	B	unexpected_error
d341 1
a341 1
	BEQ	unexpected_error
d343 1
a343 1
	MOV	v1, a3
d345 42
a386 42
	; a1-a4 free
	; v1 = iic_transfer to start
	; v2-v3 free
	; v4 = I2C controller ptr
	; v5 = I2C state ptr
 [ I2CDebug
	DebugReg v1, "start_transfer: "
 ]
	STR	v1, [v5, #I2C_XCurrent]
	MOV	lr, #0
	STR	lr, [v5, #I2C_XBytes]
	; Get its info
	LDMIA	v1, {a1-a3}
 [ I2CDebug
	DebugReg a1, "addr="
	DebugReg a2, "data="
	DebugReg a3, "len ="
 ]
	; If it's a 'checksum-only' read, clear the checksum to 0
	TST	a1, #1:SHL:30
	TSTNE	a1, #1
	MOVNE	a2, #0
	STRNE	a2, [v1, #4]
	; Wait for the controller to be fully idle - if two iic_transfer lists are executed
	; back-to-back then there's a chance the controller won't have yet sent the stop bit
	; from the previous transfer. Thus we must wait here for the bit to be sent.
	MOV	v2, #50*1024 ; timeout - this should be more than adequate (with a CPU of 500MHz, there'd be 1250 CPU clock cycles per 400kbps I2C clock cycle)
10
	LDRH	a4, [v4, #I2C_CON]
	TST	a4, #(I2C_CON_STT + I2C_CON_STP)
	; Check STT and STP (Although we're primarily interested in STP, the manual warns
	; about bad things happening if STT is cleared)
	BEQ	%FT20
	SUBS	v2, v2, #1
	BNE	%BT10
 [ I2CDebug
	DebugReg a4, "ISC_CON timeout: "
 ]
	MOV	a1, #EBUSY
	MOV	v3, #0
	STR	v3, [v5, #I2C_XStart]
	LDMFD	sp!, {v1-v5,pc}
d388 14
a401 14
	; Configure controller
	; 1. I2C_CON.MST, ISC_CON.TRX
	BIC	a4, a4, #(I2C_CON_STT+I2C_CON_STP+I2C_CON_XOA3+I2C_CON_XOA2+I2C_CON_XOA1+I2C_CON_XOA0)
	BIC	a4, a4, #(I2C_CON_STB+I2C_CON_MST+I2C_CON_TRX+I2C_CON_XSA)
	ORR	a4, a4, #I2C_CON_MST	; Set MST (slave mode not supported ATM)
	TST	a1, #1
	ORREQ	a4, a4, #I2C_CON_TRX	; Set transmitter mode if appropriate
	STRH	a4, [v4, #I2C_CON]
	; Clear any pending interrupts, just in case?
	LDRH	v2, [v4, #I2C_STAT]
	STRH	v2, [v4, #I2C_STAT]
	; 2. I2C_IE.XRDY_IE, I2C_IE.RRDY
	MOVEQ	v2, #(I2C_INT_AL + I2C_INT_NACK + I2C_INT_ARDY + I2C_INT_XRDY)
	MOVNE	v2, #(I2C_INT_AL + I2C_INT_NACK + I2C_INT_ARDY + I2C_INT_RRDY)
d403 2
a404 2
	ORREQ	v2, v2, #I2C_INT_XDR
	ORRNE	v2, v2, #I2C_INT_RDR
d406 25
a430 25
;	STRH	v2, [v4, #I2C_IE]
	STRH	v2, [v4, #I2C_IRQENABLE_SET]
	; 3. Ignore DMA for now
	; 4. I2C_SA, I2C_CNT
	MOV	v2, a1, LSR #1
	AND	v2, v2, #&7F
	STRH	v2, [v4, #I2C_SA]

	; The I2C controller doesn't seem to like it if we don't send a start bit - it simply
	; ignores I2C_CNT and goes straight to sending the stop bit (or sits there and does
	; nothing if no stop bit was wanted).
	; So to get around this we scan forward through the iic_transfer list and set I2C_CNT
	; to the number of bytes to transmit before the next start/stop bit is required
	MOV	v2, v1
	LDR	ip, [v5, #I2C_XEnd]
10
	CMP	ip, v2
	ORREQ	a4, a4, #I2C_CON_STP	; Last transfer in list; set stop bit

	BEQ	%FT20
	ADD	v2, v2, #12 ; Increment after compare, just in case some crazy person creates an iic_transfer that wraps from &FFF.... to &000...
	LDMIA	v2,{a1-a2,v3} ; Get transfer info
	TST	a1, #1:SHL:31
	ADDNE	a3, a3, v3 ; nostart is set; increment length and loop around
	BNE	%BT10
d433 1
a433 1
	DebugReg a3, "I2C_CNT="
d435 13
a447 13
	STRH	a3, [v4, #I2C_CNT]
	; 5. Wait for I2C_STAT.BB to 0 (but only if this is the first iic_transfer of a
	;    sequence - otherwise we'll be stuck waiting to unlock a bus we already own)
	LDR	v2, [v5, #I2C_XStart]
	CMP	v1, v2 ; v1 = I2C_XCurrent from earlier
	BNE	%FT20
	MOV	v2, #50*1024 ; timeout
10
	LDRH	v3, [v4, #I2C_STAT]
	TST	v3, #I2C_INT_BB
	BEQ	%FT20
	SUBS	v2, v2, #1
	BNE	%BT10
d449 1
a449 1
	DebugReg v3, "BB timeout: I2C_STAT="
d451 2
a452 2
	MOV	a1, #EBUSY
	B	clear_and_return
d454 18
a471 18
	; 6. configure I2C_CON.STT=1, I2C_CON.STP=0/1
;	ORR	a4, a4, #(I2C_CON_STT + I2C_CON_STP)
	ORR	a4, a4, #(I2C_CON_STT)
	STRH	a4, [v4, #I2C_CON]
	; Now we just sit back and wait for the interrupts?
 [ I2CDebug
	DebugTX	"Transfer started"
 ]
	MOV	a1, #EINPROGRESS
	LDMFD	sp!, {v1-v5,pc}

	; For receive:
	; 1. Use I2C_IE.RRDY_IE
	; 2. Except we use I2C_IE.RDR_IE if the receive size doesn't match the RX FIFO
	;    threshold?
	; For transmit:
	; 1. Use I2C_IE.XRDY_IE
	; 2. Except we use I2C_IE.XDR_IE if the length doesn't match the TX FIFO threshold?
d476 2
a477 2
	; Process the interrupts, according to figures 18-31/18-32 in spruf98b
	STMFD	sp!, {v1-v5,lr}
d479 1
a479 1
	DebugReg a1, "HAL_IICMonitorTransfer: bus "
d481 47
a527 47
	ADR	v5, I2C_Table
	MOV	v4, #I2CBlockSize
	MLA	v5, a1, v4, v5
	LDR	v4, [v5, #I2C_HW]
	LDR	a1, [v5, #I2C_XStart]
 [ I2CDebug
	DebugReg a1, "XStart="
 ]
	LDRH	v3, [v4, #I2C_STAT]
	TEQ	a1, #0 ; If no transfer, shut off all interrupts
	ASSERT	ECOMPLETED=0
 [ I2CDebug
	BNE	%FT10
	DebugTX	"No XStart!"
	TEQ	a1, #0 ; reset EQ condition
10
 ]
;	STREQH	a1, [v4, #I2C_IE]
	MOV	a1,#-1
	STREQH	a1, [v4, #I2C_IRQENABLE_CLR]
	STREQH	v3, [v4, #I2C_STAT]
	LDMEQFD	sp!, {v1-v5,pc}
 [ I2CDebug
	DebugReg v3, "I2C_STAT="
 ]
	TST	v3, #I2C_INT_NACK
	BNE	i2c_nack
	TST	v3, #I2C_INT_AL
	BNE	i2c_al
	TST	v3, #I2C_INT_ARDY
	BNE	i2c_ardy
	TST	v3, #I2C_INT_XDR
	BNE	i2c_xdr
	TST	v3, #I2C_INT_XRDY
	BNE	i2c_xrdy
	TST	v3, #I2C_INT_RDR
	BNE	i2c_rdr
	TST	v3, #I2C_INT_RRDY
	BNE	i2c_rrdy
	; Did anything actually happen?
	BIC	v3, v3, #(I2C_INT_BB+I2C_INT_ROVR+I2C_INT_XUDF+I2C_INT_BF)
	; Clear XUDF, ROVR, BB, BF - they're status bits and don't indicate anything
	; we care about here
	CMP	v3, #0
	MOVEQ	a1, #EINPROGRESS ; If nothing interesting happened, claim everything is OK (required for polling-mode transfers, e.g. HAL_Video_IICOp)
	LDMEQFD	sp!, {v1-v5,pc}
	; Else bad stuff - unhandled interrupt
d529 1
a529 1
	DebugReg v3, "Unhandled IRQ - "
d532 2
a533 2
	MOV	a1, #EERROR
	; recover from error situation
d535 9
a543 9
	MOV	v2, #0
	STRH	v2, [v4, #I2C_CON]
	MOV	v3, #-1
	STRH	v3, [v4, #I2C_STAT]
	STR	v2, [v5, #I2C_XStart]
	STRH	v2, [v4, #I2C_CNT]
	MOV	v2, #I2C_CON_EN
	STRH	v2, [v4, #I2C_CON]
	LDMFD	sp!, {v1-v5,pc}
d546 1
a546 1
	DebugReg a1, "clear_and_return: "
d548 7
a554 7
	CMP	a1, #EINPROGRESS
	BHI	recover_from_error
	STRH	v3, [v4, #I2C_STAT]
	MOV	v3, #0
	STR	v3, [v5, #I2C_XStart]
	STRH	v3, [v4, #I2C_CNT]
	LDMFD	sp!, {v1-v5,pc}
d557 3
a559 3
	; No ack was received - give up and return error
	MOV	a1, #ENOACK
	B	clear_and_return
d562 4
a565 4
	; Arbitration lost - restart the transfer list
	STRH	v3, [v4, #I2C_STAT]
	LDR	v1, [v5, #I2C_XStart]
	B	start_transfer
d568 5
a572 5
	; Previous transfer has completed successfully; start a new one
	LDR	a3, [v5, #I2C_XCurrent]
	LDR	a2, [v5, #I2C_XBytes]
	LDR	ip, [a3, #8]
	CMP	a2, ip
d574 5
a578 5
	BEQ	%FT10
	DebugTX	"HW requested wrong byte count"
	DebugReg a2, "I2C_XBytes="
	DebugReg ip, "xfer len="
	B	unexpected_error
d581 1
a581 1
	BNE	unexpected_error ; Hardware hasn't requested the full number of bytes
d583 12
a594 12
	LDR	a4, [v5, #I2C_XEnd]
	CMP	a3, a4
	MOVEQ	a1, #ECOMPLETED
	BEQ	clear_and_return
	; Skip any zero-length nostart transfers that follow this one
	ADD	v1, a3, #12
10
	LDMIA	v1, {a1-a3}
	TST	a1, #1:SHL:31
	STREQH	v3, [v4, #I2C_STAT]
	BEQ	start_transfer
	CMP	a3, #0
d596 3
a598 3
	BEQ	%FT5
	DebugReg a3, "nostart transfer with nonzero length, length="
	B	unexpected_error
d601 1
a601 1
	BNE	unexpected_error ; nostart transfer with nonzero length = hardware hasn't requested full number of bytes
d603 5
a607 5
	CMP	v1, a4
	MOVEQ	a1, #ECOMPLETED
	BEQ	clear_and_return
	ADD	v1, v1, #12
	B	%BT10
d612 3
a614 3
	; Transfer I2C_BUFSTAT[5:0] bytes
	LDRH	a4, [v4, #I2C_BUFSTAT]
	AND	a4, a4, #&3F
d616 1
a616 1
	MOV	a4, #1
d618 1
a618 1
	B	send_bytes
d622 4
a625 4
	; Transfer I2C_BUF[5:0]+1 bytes
	LDRH	a4, [v4, #I2C_BUF]
	AND	a4, a4, #&3F
	ADD	a4, a4, #1
d627 1
a627 1
	MOV	a4, #1
d631 1
a631 1
	DebugReg  a4, "send_bytes: "
d633 8
a640 8
	LDR	v2, [v5, #I2C_XCurrent]
	LDR	a3, [v5, #I2C_XBytes] ; Get bytes sent
	LDMIB	v2, {a2,ip} ; Get data ptr, transfer length
10
	; Check if we need to advance to the next iic_transfer
	CMP	a3, ip
	BEQ	%FT20
	LDRB	v1, [a2,a3]
d642 1
a642 1
	DebugRegByte v1
d644 4
a647 4
	ADD	a3, a3, #1
	SUBS	a4, a4, #1
	STRB	v1, [v4, #I2C_DATA]
	BNE	%BT10
d649 1
a649 1
	DebugTX	""
d651 4
a654 4
	STR	a3, [v5, #I2C_XBytes]
	MOV	a1, #EINPROGRESS
	STRH	v3, [v4, #I2C_STAT]
	LDMIA	sp!, {v1-v5,pc}
d656 3
a658 3
	; Advance to next iic_transfer
	LDR	a3, [v5, #I2C_XEnd]
	CMP	a3, v2
d660 3
a662 3
	BNE	%FT5
	DebugTX	"End of transfer list but hardware wants more"
	B	unexpected_error
d665 1
a665 1
	BEQ	unexpected_error ; Hardware is asking for more data than we can give
d667 7
a673 7
	ADD	v2, v2, #12
	STR	v2, [v5, #I2C_XCurrent]
	MOV	a3, #0
	STR	a3, [v5, #I2C_XBytes]
	LDMIA	v2, {a1-a2,ip}
	TST	a1, #1:SHL:31
	BNE	%BT10
d675 1
a675 1
	DebugTX	"nostart reached but hardware wants more"
d677 1
a677 1
	B	unexpected_error ; Hardware is asking for more data than we can give
d681 5
a685 5
	; Read I2C_BUFSTAT[13:8] bytes
	LDRH	a4, [v4, #I2C_BUFSTAT]
	MOV	a4, a4, LSR #8
	ANDS	a4, a4, #&3F ; ERRATA - sometimes RDR is set when there's no data. So, don't attempt to read from the empty buffer.
	BEQ	%FT15
d687 1
a687 1
	MOV	a4, #1
d689 1
a689 1
	B	read_bytes
d693 5
a697 5
	; Read I2C_BUF[13:8]+1 bytes
	LDRH	a4, [v4, #I2C_BUF]
	MOV	a4, a4, LSR #8
	AND	a4, a4, #&3F
	ADD	a4, a4, #1
d699 1
a699 1
	MOV	a4, #1
d703 1
a703 1
	DebugReg  a4, "read_bytes: "
d705 11
a715 11
	LDR	v2, [v5, #I2C_XCurrent]
	LDMIA	v2, {a1-a2,ip} ; Get checksum flag, data ptr/checksum, transfer length
	LDR	a3, [v5, #I2C_XBytes] ; Get bytes received
10
	; Check if we need to advance to the next iic_transfer
	CMP	a3, ip
	BEQ	%FT20
	TST	a1, #1:SHL:30 ; Checksum mode?
	LDRB	v1, [v4, #I2C_DATA]
	ADDNE	a2, a2, v1 ; adjust checksum
	STREQB	v1, [a2, a3]
d717 1
a717 1
	DebugRegByte	v1
d719 3
a721 3
	SUBS	a4, a4, #1
	ADD	a3, a3, #1
	BNE	%BT10
d723 1
a723 1
	DebugTX	""
d725 2
a726 2
	STR	a2, [v2, #4] ; Update checksum
	STR	a3, [v5, #I2C_XBytes]
d728 3
a730 3
	MOV	a1, #EINPROGRESS
	STRH	v3, [v4, #I2C_STAT]
	LDMIA	sp!, {v1-v5,pc}
d732 3
a734 3
	; Advance to next iic_transfer
	LDR	a3, [v5, #I2C_XEnd]
	CMP	a3, v2
d736 3
a738 3
	BNE	%FT5
	DebugTX "End of transfer list but hardware received more data"
	B	unexpected_error
d741 1
a741 1
	BEQ	unexpected_error ; Hardware is receiving more data than we want
d743 6
a748 6
	ADD	v2, v2, #12
	STR	v2, [v5, #I2C_XCurrent]
	MOV	a3, #0
	STR	a3, [v5, #I2C_XBytes]
	LDMIA	v2, {a1-a2,ip}
	TST	a1, #1:SHL:31
d750 3
a752 3
	BNE	%FT5
	DebugTX	"nostart reached but hardware received more data"
	B	unexpected_error
d755 1
a755 1
	BEQ	unexpected_error ; Hardware is receiving more data than we want
d757 3
a759 3
	TST	a1, #1:SHL:30 ; Checksum mode?
	MOVNE	a2, #0 ; Start with zero checksum (as per start_transfer)
	B	%BT10
d782 44
a825 44
	; Build a set of iic_transfer blocks and call RISCOS_IICOpV
	; First let's discard writes, to be equivalent to the NVidia driver
	TST	a1, #1<<16
	; Also make sure we've got a valid IIC bus to use
	LDRB	a4, [sb, #BoardConfig_VideoI2C]
	CMPNE	a4, #255
	MOVEQ	pc, lr
	; Also check we're transferring a valid number of bytes
	SUB	a4, a3, #1
	CMP	a4, #65536
	MOVHS	pc, lr
	Push	"a1-a3,lr"
	; Now we construct two iic_transfer blocks
	; - First block is a write to 0x50. Single byte containing EDID start address (lower 8 bits of r0)
	; - Second block is a read from 0x50. r2 bytes written to r1.
	; Block 2:
	TST	a1, #1<<16 ; Is this read or write? (although this code isn't guaranteed to work properly for EDID writes!)
	MOVNE	a1, #&a1 ; Read from I2C
	MOVEQ	a1, #&a0 ; Write to I2C
	Push	"a1-a3" ; Push the block on the stack (a2 & a3 are already correct)
	; Block 1:
	MOV	a1, #&a0
	ADD	a2, sp, #12 ; sp+12 should point to the 8 bit EDID address
	MOV	a3, #1
	Push	"a1-a3"
	; Now attempt to start the transfer
	LDRB	a2, [sb, #BoardConfig_VideoI2C]
	MOV	a2, a2, LSL #24
	ADD	a2, a2, #2
	MOV	a1, sp
	; If HAL_Init isn't done yet, we can't use OS_IICOpV
	LDR	a3, HALInitialised
	CMP	a3, #0
	ADREQ	a3, IIC_DoOp_Poll
	LDRNE	a3, OSentries+4*OS_IICOpV
	BLX	a3
	; On error, return with unmodified regs, ala NVidia driver
	CMP	a1, #0
	ADD	sp, sp, #24
	Pull	"a1-a3,lr"
	ADDEQ	a2, a2, a3
	MOVEQ	a1, #0
	MOVEQ	a3, #0
	MOV	pc, lr
d828 8
a835 8
	; IIC transfer function that performs a polling transfer, similar to HAL_Video_IICOp
	; This allows us to do IIC transfers before RISC OS is fully initialised (e.g. from inside HAL_Init)
	; Parameters are identical to RISCOS_IICOpV:
	; r0 = iic_transfer array ptr
	; r1 = bits 0-23: iic_transfer count
	;      bits 24-31: bus number
	; Returns E* return code in R0 (0 success, anything else failure)
	Push	"v1,lr"
d837 28
a864 28
	; If IRQs and IIC IRQ are enabled, panic
	Push	"a1-a4"
	MRS	a1, CPSR
	TST	a1, #I32_bit
	BNE	%FT10
	ADR	a1, BoardConfig_HALI2CIRQ
	LDRB	a1, [a1, a2, LSR #24]
	IMPORT	HAL_IRQDisable
	BL	HAL_IRQDisable
	CMP	a1, #0
	BEQ	%FT10
	DebugTX	"Warning - IIC_DoOp_Poll called with IIC IRQ enabled!"
	B	.
10
	Pull	"a1-a4"
 ]
	MOV	a3, a1
	MOV	a1, a2, LSR #24
	BIC	a2, a2, #&ff000000
	MOV	v1, a1
	BL	HAL_IICTransfer
	; Now just poll until we're done
10
	CMP	a1, #EINPROGRESS ; Done?
	Pull	"v1,pc", NE
	ADR	lr, %BT10
	MOV	a1, v1
	B	HAL_IICMonitorTransfer
d866 1
a866 1
	END
@


1.1.1.1
log
@  Initial import of OMAP4 HAL
Detail:
  Target platform is the Pandaboard, based on the TI OMAP4 SoC.
  Port is not yet complete, in particular, audio is not yet working.
Admin:
  Submission from Willi Theiß
@
text
@@

head	1.11;
access;
symbols
	OMAP4-0_60:1.11
	OMAP4-0_59-1_52_2_3:1.10.2.1
	OMAP4-0_59:1.10
	OMAP4-0_58:1.10
	OMAP4-0_57:1.10
	OMAP4-0_56:1.10
	OMAP4-0_55:1.10
	OMAP4-0_54-1_52_2_2:1.10.2.1
	OMAP4-0_54:1.10
	OMAP4-0_53:1.10
	OMAP4-0_52-1_52_2_1:1.10.2.1
	SMP:1.10.0.2
	SMP_bp:1.10
	OMAP4-0_52:1.10
	OMAP4-0_51:1.10
	OMAP4-0_50:1.9
	OMAP4-0_49:1.9
	OMAP4-0_48:1.9
	OMAP4-0_47:1.9
	OMAP4-0_46:1.9
	OMAP4-0_45:1.9
	OMAP4-0_44:1.9
	OMAP4-0_43:1.8
	OMAP4-0_42:1.8
	OMAP4-0_41:1.8
	OMAP4-0_40:1.8
	OMAP4-0_39:1.8
	OMAP4-0_38:1.8
	OMAP4-0_37:1.8
	OMAP4-0_36:1.8
	OMAP4-0_35:1.8
	OMAP4-0_34:1.8
	OMAP4-0_33:1.8
	OMAP4-0_32:1.8
	OMAP4-0_31:1.7
	OMAP4-0_30:1.6
	OMAP4-0_29:1.5
	OMAP4-0_28:1.5
	OMAP4-0_27:1.4
	OMAP4-0_26:1.4
	OMAP4-0_25:1.4
	OMAP4-0_24:1.4
	OMAP4-0_23:1.4
	OMAP4-0_22:1.4
	OMAP4-0_21:1.4
	OMAP4-0_20:1.4
	OMAP4-0_19:1.4
	OMAP4-0_18:1.4
	OMAP4-0_17:1.4
	OMAP4-0_16:1.4
	OMAP4-0_15:1.4
	OMAP4-0_14:1.4
	OMAP4-0_13:1.4
	OMAP4-0_12:1.3
	OMAP4-0_11:1.3
	OMAP4-0_10:1.3
	OMAP4-0_09:1.2
	OMAP4-0_08:1.2
	OMAP4-0_07:1.2
	OMAP4-0_06:1.1.1.1
	OMAP4-0_05:1.1.1.1
	OMAP4-0_04:1.1.1.1
	OMAP4-0_03:1.1.1.1
	OMAP4-0_02:1.1.1.1
	OMAP4-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2018.07.07.14.46.32;	author jlee;	state Exp;
branches;
next	1.10;
commitid	IdpQqfjTDGJUldJA;

1.10
date	2016.05.06.21.41.51;	author jlee;	state Exp;
branches
	1.10.2.1;
next	1.9;
commitid	kj2dniyIsLwM6t5z;

1.9
date	2015.04.08.07.33.53;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	ziZUYwsqx4235Lgy;

1.8
date	2014.03.23.20.40.32;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	fwiOxhSMPWpfGRtx;

1.7
date	2014.03.22.12.10.32;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	z6xyRA0ajhphTGtx;

1.6
date	2014.03.22.12.00.22;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	jgt6RY8rdYvMPGtx;

1.5
date	2014.03.08.16.55.57;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	tpkfnWqSEp73VUrx;

1.4
date	2013.01.22.23.26.20;	author jlee;	state Exp;
branches;
next	1.3;
commitid	hs6r3ZZoTSm6ggBw;

1.3
date	2012.07.03.23.09.04;	author bavison;	state Exp;
branches;
next	1.2;
commitid	0Wfi25ZdrHiIGabw;

1.2
date	2012.03.25.11.42.57;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	4FjnaYBzkPTA6gYv;

1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;
commitid	M3eV6gzJuoHHMezv;

1.10.2.1
date	2017.07.29.11.55.49;	author jlee;	state Exp;
branches;
next	;
commitid	tNqXOj5HJ9lUq71A;

1.1.1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches;
next	;
commitid	M3eV6gzJuoHHMezv;


desc
@@


1.11
log
@Merge SMP branch to trunk
Detail:
  Makefile, s/DBell - Add doorbell HAL device implementation, using GIC SGIs
  hdr/StaticWS, hdr/omap4430 - Tidy things up a bit by removing the DebugInterrupts code.
  hdr/omap4_reg - Offset all the shared interrupt numbers so that RISC OS IRQs 0-31 are core 0 private, 32-63 core 1 private, 64-159 shared
  s/Boot - Implement SMP ARMops
  s/Interrupts - Tidy up interrupt handling and implement new HAL IRQ calls
Admin:
  Untested
  Requires Kernel-6_09


Version 0.60. Tagged as 'OMAP4-0_60'
@
text
@; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.omap4430
        GET     hdr.StaticWS
        GET     hdr.Interrupts

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  Interrupt_Init
        EXPORT  HAL_IRQEnable
        EXPORT  HAL_IRQDisable
        EXPORT  HAL_IRQClear
        EXPORT  HAL_IRQSource
        EXPORT  HAL_IRQStatus
        EXPORT  HAL_FIQEnable
        EXPORT  HAL_FIQDisable
        EXPORT  HAL_FIQDisableAll
        EXPORT  HAL_FIQClear
        EXPORT  HAL_FIQSource
        EXPORT  HAL_FIQStatus
        EXPORT  HAL_IRQMax
        EXPORT  HAL_IRQProperties
        EXPORT  HAL_IRQSetCores
        EXPORT  HAL_IRQGetCores

        ; $base += ($num >> 5) << 2
        ; $bit = 1 << ($num & 31)
        ; NE if $num >= 32
        ; $temp can be $num
        MACRO
        BitMap  $num, $base, $bit, $temp
        MOVS    $bit, $num, LSR #5
        AND     $temp, $num, #31
        ADD     $base, $base, $bit, LSL #2
        MOV     $bit, #1
        MOV     $bit, $bit, LSL $temp
        MEND

        ; As above, but $base = ($num >> 5) << 2
        MACRO
        BitMap0 $num, $base, $bit, $temp
        MOVS    $base, $num, LSR #5
        AND     $temp, $num, #31
        MOV     $base, $base, LSL #2
        MOV     $bit, #1
        MOV     $bit, $bit, LSL $temp
        MEND

Interrupt_Init
        ; 1. disable Distributor Controller
        LDR     a1, MPU_INTC_Log
        ADD     a1, a1, #MPU_INTC_DIST
        MOV     a2, #0          ; disable ICDDCR
        STR     a2, [a1, #GIC_DIST_CTRL]

        ; 2. set all global interrupts to be level triggered, active low
        ADD     a3, a1, #GIC_DIST_CONFIG
        ADD     a3, a3, #8
        MOV     a4, #INTERRUPT_MAX-32
        MOV     ip, #32
10
        STR     a2, [a3], #4
        ADD     ip, ip, #16
        CMP     ip, a4
        BNE     %BT10

        ; 3. set all global interrupts to this CPU only
        ADD     a3, a1, #(GIC_DIST_TARGET + 32)
        MOV     ip, #32
        MOV     a2, #1
        ORR     a2, a2, a2, LSL #8
        ORR     a2, a2, a2, LSL #16
20
        STR     a2, [a3], #4
        ADD     ip, ip, #4
        CMP     ip, a4
        BNE     %BT20

        ; 4. set priority on all interrupts
        ADD     a3, a1, #(GIC_DIST_PRI + 32)
        MOV     ip, #32
        MOV     a2, #&A0
        ORR     a2, a2, a2, LSL #8
        ORR     a2, a2, a2, LSL #16
30
        STR     a2, [a3], #4
        ADD     ip, ip, #4
        CMP     ip, a4
        BNE     %BT30

        ; 5. disable all interrupts
        ADD     a3, a1, #GIC_DIST_ENABLE_CLEAR
        MOV     ip, #32
        MOV     a2, #-1
40
        STR     a2, [a3], #4
        ADD     ip, ip, #32
        CMP     ip, a4
        BNE     %BT40

        ; 6. enable Distributor Controller
        MOV     a2, #ICDDCR_ENABLE
        STR     a2, [a1, #GIC_DIST_CTRL]

        ; 7. set PRIMASK in CPU interface
        LDR     a1, MPU_INTC_Log
        MOV     a2, #&F0
        STR     a2, [a1, #(MPU_INTC_CPU + GIC_CPU_PRIMASK)]

        ; 8. enable CPU interface
        MOV     a2, #ICCICR_ENABLE
        STR     a2, [a1, #(MPU_INTC_CPU + GIC_CPU_CTRL)]
        ; ... and everything else looks good?
        MOV     pc, lr

HAL_IRQEnable   ROUT
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        BitMap0 a1, a2, a3, a4
        CMP     a1, #32
        LDR     a4, MPU_INTC_Log
        SUBHS   a2, a2, #4 ; Remap to GIC registers (assume we won't get called with wrong private interrupt)
        ADD     a4, a4, #MPU_INTC_DIST + GIC_DIST_ENABLE_SET
        LDR     a1, [a4, a2] ; Get old state
        STR     a3, [a4, a2] ; Set new state
        AND     a1, a1, a3 ; Return value
        MOV     pc, lr

HAL_IRQDisable  ROUT
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        BitMap0 a1, a2, a3, a4
        CMP     a1, #32
        LDR     ip, MPU_INTC_Log
        SUBHS   a2, a2, #4 ; Remap to GIC registers (assume we won't get called with wrong private interrupt)
        ADD     a4, ip, #MPU_INTC_DIST + GIC_DIST_ENABLE_CLEAR
        LDR     a2, [a4, a2]! ; Get old state
        STR     a3, [a4] ; Set new state
        LDR     a4, [a4, #GIC_DIST_ACTIVE_BIT-GIC_DIST_ENABLE_CLEAR] ; TODO could this be bogus? - if register isn't banked we'll do the wrong thing
        SUBHS   a1, a1, #32
        TST     a4, a3 ; Was it active?
        BEQ     %FT90
        CMPLO   a1, #16 ; LO if this is core 0 private, check to see if SGI
        ORRLO   a1, a1, #1<<10 ; Set opposite to current CPU
        STR     a1, [ip, #(MPU_INTC_CPU + GIC_CPU_EOI)]
90
        AND     a1, a2, a3 ; Return value
        DSB     SY
        MOV     pc, lr

HAL_IRQClear    ROUT
        CMP     a1, #32
        SUBHS   a1, a1, #32     ; Map to GIC interrupt number
        ; Signal End Of Interrupt
        CMP     a1, #16         ; SGI?
        BHS     %FT10
        MRC     p15, 0, a2, c0, c0, 5
        TST     a2, #1
        ADDEQ   a1, a1, #1<<10  ; Assume it came from the other CPU
10
        LDR     a2, MPU_INTC_Log
        STR     a1, [a2, #(MPU_INTC_CPU + GIC_CPU_EOI)]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
        MOV     pc, lr

HAL_IRQSource   ROUT
        LDR     a2, MPU_INTC_Log
        LDR     a3, [a2, #(MPU_INTC_CPU + GIC_CPU_INTACK)]
        BIC     a1, a3, #ICCIAR_CPUID
        CMP     a1, #INTERRUPT_MAX-32
        MOVHI   a1, #-1            ; Spurious interrupt, ignore it
        MOVHI   pc, lr
        MRC     p15, 0, a4, c0, c0, 5
        AND     a4, a4, #1
        CMP     a1, #32
        ADDLO   a1, a1, a4, LSL #5 ; Remap private interrupt
        ADDHS   a1, a1, #32        ; Remap shared interrupt
        MOV     pc, lr

HAL_IRQStatus
        ; Test if IRQ is firing, irrespective of mask state
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        LDR     a2, MPU_INTC_Log
        ADD     a2, a2, #(MPU_INTC_DIST + GIC_DIST_ACTIVE_BIT)
        BitMap  a1, a2, a3, a4
        SUBNE   a2, a2, #4      ; Remap to GIC registers
        LDR     a1, [a2]        ; Get status
        AND     a1, a1, a3
        MOV     pc, lr


;
; ToDo: do we have FIQs in Non-Secure environment GIC ???
;    FIQ_Supported part contains register names from OMAP3 implementation;
;    this needs updating for GICv1 naming conventions!
;
                GBLL    FIQ_Supported
FIQ_Supported   SETL    {FALSE}

HAL_FIQEnable
  [ FIQ_Supported
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        ; Disable interrupts while we update the controller
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        ; Set the interrupt type & priority, and then unmask it
        MOV     a2, #1 ; highest priority for all FIQs.
        LDR     a3, MPU_INTC_Log
        ADD     ip, a3, #INTCPS_ILR
        ASSERT  INTCPS_ILR_SIZE = 4
        STR     a2, [ip, a1, LSL #2]
        AND     a2, a1, #&1F ; Mask bit
        MOV     a1, a1, LSR #5 ; BITS index
        ASSERT  INTCPS_BITS_SIZE = 32
        ADD     ip, a3, a1, LSL #5
        MOV     a1, #1
        MOV     a2, a1, LSL a2
        LDR     a1, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
        STR     a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_CLEAR] ; Write to clear reg to set new state
        MSR     CPSR_c, a4 ; Re-enable interrupts
        MVN     a1, a1 ; Invert so we get a mask of enabled interrupts
        AND     a1, a1, a2 ; Test if it was enabled or not
        MOV     pc, lr
  |
        MOV     a1, #0
        MOV     pc, lr
  ] ; FIQ_Supported

HAL_FIQDisable
  [ FIQ_Supported
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        Push    "lr"
        ; Disable interrupts while we update the controller (not necessarily needed for disabling them?)
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        ; Check if this is actually an FIQ
        LDR     a3, MPU_INTC_Log
        ASSERT  INTCPS_ILR_SIZE = 4
        ADD     a2, a3, a1, LSL #2
        LDR     a2, [a2, #INTCPS_ILR]
        TST     a2, #1
        MOVEQ   a1, #0 ; This is an IRQ, so don't disable it
        MSREQ   CPSR_c, a4
        Pull    "pc", EQ
        ; Now mask the interrupt
        AND     a2, a1, #&1F ; Mask bit
        MOV     lr, a1, LSR #5 ; BITS index
        ASSERT  INTCPS_BITS_SIZE = 32
        ADD     ip, a3, lr, LSL #5
        MOV     lr, #1
        MOV     a2, lr, LSL a2
        LDR     lr, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
        STR     a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_SET] ; Mask the interrupt
        ; Check if we just disabled the active interrupt
        LDR     ip, [a3, #INTCPS_SIR_FIQ]
        CMP     ip, a1
        MOVEQ   ip, #2
        STREQ   ip, [a3, #INTCPS_CONTROL]
        MSR     CPSR_c, a4 ; Re-enable interrupts
        BIC     a1, a2, lr ; Clear the masked interrupts from a2 to get nonzero result if it was enabled
        Pull    "pc"
  |
        MOV     a1, #0
        MOV     pc, lr
  ] ; FIQ_Supported

HAL_FIQDisableAll
  [ FIQ_Supported
        ; This isn't particularly great, we need to scan the entire ILR array
        ; and work out which are FIQs, and then write to the ISR_SET registers
        ; We should probably keep our own array of enabled FIQs so this can be
        ; done more quickly
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        LDR     a1, MPU_INTC_Log
        ADD     a1, a1, #INTCPS_ILR
        MOV     a2, #1 ; Mask to write
        ADD     a3, a1, #INTCPS_BITS+INTCPS_BITS_MIR_SET-INTCPS_ILR
HAL_FIQDisableAll_Loop1
        LDR     ip, [a1],#INTCPS_ILR_SIZE
        TST     ip, #1 ; 1=FIQ, 0=IRQ
        STRNE   a2, [a3] ; Disable it
        MOVS    a2, a2, LSL #1
        BCC     HAL_FIQDisableAll_Loop1
        ; Move on to next word
        MOV     a2, #1
        ADD     a3, a3, #INTCPS_BITS_SIZE
HAL_FIQDisableAll_Loop2
        LDR     ip, [a1],#INTCPS_ILR_SIZE
        TST     ip, #1 ; 1=FIQ, 0=IRQ
        STRNE   a2, [a3] ; Disable it
        MOVS    a2, a2, LSL #1
        BCC     HAL_FIQDisableAll_Loop2
        ; Move on to last word
        MOV     a2, #1
        ADD     a3, a3, #INTCPS_BITS_SIZE
HAL_FIQDisableAll_Loop3
        LDR     ip, [a1],#INTCPS_ILR_SIZE
        TST     ip, #1 ; 1=FIQ, 0=IRQ
        STRNE   a2, [a3] ; Disable it
        MOVS    a2, a2, LSL #1
        BCC     HAL_FIQDisableAll_Loop3
        ; Done
        ASSERT  INTCPS_BITS_COUNT = 3
        MSR     CPSR_c, a4
        ; FIQDisableAll is only called during emergency situations, so restart INTC priority
        ; sorting to avoid having to rewrite various bits of RISC OS code to query FIQ sources
        ; and call FIQClear on each one (which would otherwise be the only legal way of
        ; stopping all FIQs from firing)
        LDR     a2, MPU_INTC_Log
        MOV     a1, #2
        STR     a1, [a2, #INTCPS_CONTROL]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
  ] ; FIQ_Supported
        MOV     pc, lr

HAL_FIQClear
  [ FIQ_Supported
        ; Restart INTC priority sorting
        LDR     a2, MPU_INTC_Log
        MOV     a1, #2
        STR     a1, [a2, #INTCPS_CONTROL]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
  ] ; FIQ_Supported
        MOV     pc, lr

HAL_FIQStatus
  [ FIQ_Supported
        ; Test if FIQ is firing, irrespective of mask state
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        ; First we need to make sure this is an FIQ, not an IRQ?
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        LDR     a2, MPU_INTC_Log
        ASSERT  INTCPS_ILR_SIZE = 4
        ADD     a3, a2, a1, LSL #2
        LDR     a3, [a3, #INTCPS_ILR]
        TST     a3, #1
        MOVEQ   a1, #0 ; This is an IRQ, so it can't fire for FIQ
        MSREQ   CPSR_c, a4
        MOVEQ   pc, lr
        ; Now check if it's firing
        ASSERT  INTCPS_BITS_SIZE = 32
        MOV     a3, a1, LSR #5
        ADD     a3, a2, a3, LSL #5
        LDR     a3, [a3, #INTCPS_BITS+INTCPS_BITS_ITR]
        MSR     CPSR_c, a4
        AND     a1, a1, #31
        MOV     a1, a3, LSR a1 ; Shift and invert so 1=active
        AND     a1, a1, #1 ; 0 = not firing, 1 = firing
        MOV     pc, lr
  |
        MOV     a1, #0
        MOV     pc, lr
  ] ; FIQ_Supported

HAL_FIQSource
  [ FIQ_Supported
        ; Does the ARM think an interrupt is occuring?
        MRC     p15, 0, a1, c12, c1, 0
        TST     a1, #F32_bit
        MOVEQ   a1, #-1
        MOVEQ   pc, lr
        LDR     a2, MPU_INTC_Log
        LDR     a1, [a2, #INTCPS_SIR_FIQ]
        CMP     a1, #INTERRUPT_MAX
        ANDLO   a1, a1, #&7F
        MOVLO   pc, lr
        ; Authentic spurious interrupt - restart INTC and return -1
        MOV     a1, #-1
        MOV     a3, #2
        STR     a3, [a2, #INTCPS_CONTROL]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
        MOV     pc, lr
  |
        MOV     a1, #0
        MOV     pc, lr
  ] ; FIQ_Supported

HAL_IRQMax
        MOV     a1, #INTERRUPT_MAX
        MOV     pc, lr

; In: a1 = device number
; Out: a1 = IRQ mask
;      a2 = FIQ mask
;           bits 0-29 of each register give cores that the interrupt can be
;           assigned to
;           bit 30 = private flag
;           bit 31 = interrupt can be routed to multiple cores at once
HAL_IRQProperties
        ; 0-31 for core 0
        ; 32-63 for core 1
        ; 64+ for shared
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a2, #0
        BHS     %FT10
        CMP     a1, #64
        MOVLO   a2, #2 + HALIRQProperty_Private
        MOVHS   a2, #3 + HALIRQProperty_Multicore
        CMP     a1, #32
        MOVLO   a2, #1 + HALIRQProperty_Private
10
        MOV     a1, a2
      [ :LNOT: FIQ_Supported
        MOV     a2, #0
      ]
        MOV     pc, lr

; In: a1 = device number
;     a2 = desired core mask
; Out: a1 = actual core mask
HAL_IRQSetCores
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        CMP     a1, #64
        BLO     %FT10
        LDR     a3, MPU_INTC_Log
        ADD     a3, a3, #MPU_INTC_DIST + GIC_DIST_TARGET
        ADD     a3, a3, a1
        AND     a1, a2, #3
        STRB    a1, [a3, #-32] ; Update mapping
        MOV     pc, lr

HAL_IRQGetCores ; read-only version of IRQSetCores
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        CMP     a1, #64
        BLO     %FT10
        LDR     a3, MPU_INTC_Log
        ADD     a3, a3, #MPU_INTC_DIST + GIC_DIST_TARGET
        ADD     a3, a3, a1
        LDRB    a1, [a3, #-32] ; Get mapping
        MOV     pc, lr

10
        CMP     a1, #32
        MOVHS   a1, #2
        MOVLO   a1, #1
        MOV     pc, lr

        END
@


1.10
log
@Implement HAL_TimerIRQClear
Detail:
  s/Boot, s/Interrupts, s/Timers - Move timer IRQ clear code out of HAL_IRQClear and into HAL_TimerIRQClear. Streamlines HAL_IRQClear, and necessary to avoid undefined symbols when linking with latest HAL USB library
Admin:
  Builds, untested


Version 0.51. Tagged as 'OMAP4-0_51'
@
text
@d23 1
d44 26
a69 6

; Debug flag to cause the DebugInterrupts noncleared IRQ detection code to disable the source
; of the noncleared interrupt. This can be useful in debugging issues that cause the
; nonclearance of the IRQ, e.g. if an IRQ handler aborts before it's able to call IRQClear.
                        GBLL    DebugDisablePrevious
DebugDisablePrevious    SETL    {FALSE}
d81 1
a81 1
        MOV     a4, #INTERRUPT_MAX
a135 9
 [ DebugInterrupts
        MOV     a1, #-1
        STR     a1, LastInterrupt_IRQ
        STR     a1, LastInterrupt_FIQ
  [ ExtraDebugInterrupts
        MOV     a1, #0
        STR     a1, ExtraDebugIRQEnabled
  ]
 ]
d138 1
a138 1
HAL_IRQEnable
d142 8
a149 16
        ; Disable interrupts while we update the controller
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        ; Unmask the interrupt
        LDR     a3, MPU_INTC_Log
        ADD     ip, a3, #(MPU_INTC_DIST + GIC_DIST_ENABLE_SET)
        AND     a2, a1, #31     ; bit   = intno % 32
        MOV     a1, a1, LSR #5  ; index = intno / 32
        ADD     ip, ip, a1, LSL #2
        MOV     a1, #1
        MOV     a2, a1, LSL a2  ; mask = (1 << bit)
        LDR     a1, [ip, #0]    ; get old state
        STR     a2, [ip, #0]    ; set new state
        MSR     CPSR_c, a4      ; Re-enable interrupts
        AND     a1, a1, a2      ; Test if it was enabled or not
d152 1
a152 1
HAL_IRQDisable
d156 18
a173 40
        Push    "lr"
        ; Disable interrupts while we update the controller
        ; (not necessarily needed for disabling them?)
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        ; Now mask the interrupt
        LDR     a3, MPU_INTC_Log
        ADD     ip, a3, #(MPU_INTC_DIST + GIC_DIST_ENABLE_CLEAR)
        AND     a2, a1, #31     ; bit   = intno % 32
        MOV     lr, a1, LSR #5  ; index = intno / 32
        ADD     ip, ip, lr, LSL #2
        MOV     lr, #1
        MOV     a2, lr, LSL a2  ; mask = (1 << bit)
        LDR     lr, [ip, #0]    ; get old state
        STR     a2, [ip, #0]    ; mask the interrupt
  [ {FALSE} ; reading GIC_CPU_INTACK has side effects on the interrupt system !?
        ; Check if we just disabled the active interrupt
        LDR     ip, [a3, #(MPU_INTC_CPU + GIC_CPU_INTACK)]
        CMP     ip, a1
        STREQ   ip, [a3, #(MPU_INTC_CPU + GIC_CPU_EOI)]
    [ DebugInterrupts
        MOVEQ   ip, #-1
        STREQ   ip, LastInterrupt_IRQ
    ]
  |
        ; Clear any pending state of this source
        STR     a2, [ip, #(GIC_DIST_PENDING_CLEAR - GIC_DIST_ENABLE_CLEAR)]
        ; Was it active?
        LDR     ip, [ip, #(GIC_DIST_ACTIVE_BIT - GIC_DIST_ENABLE_CLEAR)]
        TST     ip, a2
        STRNE   a1, [a3, #(MPU_INTC_CPU + GIC_CPU_EOI)]
    [ DebugInterrupts
        MOVNE   ip, #-1
        STRNE   ip, LastInterrupt_IRQ
    ]
  ]
        MSR     CPSR_c, a4      ; Re-enable interrupts
        AND     a1, lr, a2      ; Test if it was enabled or not
        Pull    "pc"
d175 9
a183 8
HAL_IRQClear
 [ ExtraDebugInterrupts
        LDR     a2, ExtraDebugIRQEnabled
        CMP     a2, #0
        BEQ     %FT10
        Push    "lr"
        DebugReg a1, "HAL_IRQClear: "
        Pull    "lr"
a184 2
 ]
        ; Signal End Of Interrupt
a188 4
 [ DebugInterrupts
        MOV     a1, #-1
        STR     a1, LastInterrupt_IRQ
 ]
d191 1
a191 34
HAL_IRQSource
 [ DebugInterrupts
        LDR     a1, LastInterrupt_IRQ
        CMP     a1, #0
        BLT     %FT10
        Push    "lr"
        BL      DebugHALPrint
        =       "HAL_IRQSource: Previous IRQ not cleared: ", 0
        DebugReg a1
  [ DebugDisablePrevious
        BL      HAL_IRQDisable
  ]
  [ ExtraDebugInterrupts
    [ :LNOT: DebugDisablePrevious ; Doesn't play nice with this since it'll just spam the HAL_IRQClear messages
        STR     pc, ExtraDebugIRQEnabled ; any nonzero value will do
    ]
        MOV     lr, pc ; BL to the main routine so we can get the exit code
        B       %FT05
        DebugReg a1, "HAL_IRQSource: New IRQ: "
        Pull    "pc"
05
  |
        Pull    "lr"
  ]
10
 ]
        ; Does the ARM think an interrupt is occuring?
        MRC     p15, 0, a1, c12, c1, 0
        TST     a1, #I32_bit
        MOVEQ   a1, #-1
 [ DebugInterrupts
        STREQ   a1, LastInterrupt_IRQ
 ]
        MOVEQ   pc, lr
d195 8
a202 13
        CMP     a1, #INTERRUPT_MAX
 [ DebugInterrupts
        STRLO   a1, LastInterrupt_IRQ
 ]
        MOVLO   pc, lr
        ; Authentic spurious interrupt - restart INTC and return -1
        STR     a3, [a2, #(MPU_INTC_CPU + GIC_CPU_EOI)]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
        MOV     a1, #-1
 [ DebugInterrupts
        STR     a1, LastInterrupt_IRQ
 ]
a209 1

d211 5
a215 7
        ADD     ip, a2, #(MPU_INTC_DIST + GIC_DIST_ACTIVE_BIT)
        MOV     a3, a1, LSR #5  ; index = intno / 32
        ADD     ip, ip, a3, LSL #2
        LDR     a3, [ip, #0]    ; get old state
        AND     a1, a1, #31     ; bit   = intno % 32
        MOV     a1, a3, LSR a1  ; Shift and invert so 1=active
        AND     a1, a1, #1      ; 0 = not firing, 1 = firing
a291 4
    [ DebugInterrupts
        MOVEQ   ip, #-1
        STREQ   ip, LastInterrupt_FIQ
    ]
a348 4
    [ DebugInterrupts
        MOV     a1, #-1
        STR     a1, LastInterrupt_FIQ
    ]
a359 4
    [ DebugInterrupts
        MOV     a1, #-1
        STR     a1, LastInterrupt_FIQ
    ]
a397 11
    [ DebugInterrupts
        LDR     a1, LastInterrupt_FIQ
        CMP     a1, #0
        BLT     %FT10
        Push    "lr"
        BL      DebugHALPrint
        =       "HAL_FIQSource: Previous FIQ not cleared: ", 0
        DebugReg a1
        Pull    "lr"
10
    ]
a401 3
    [ DebugInterrupts
        STREQ   a1, LastInterrupt_FIQ
    ]
a406 3
    [ DebugInterrupts
        STRLO   a1, LastInterrupt_FIQ
    ]
a409 3
    [ DebugInterrupts
        STR     a1, LastInterrupt_FIQ
    ]
d424 60
@


1.10.2.1
log
@Initial SMP support
Detail:
  s/DBell, Makefile - Implement doorbell device
  s/Boot - Implement new SMP-related HAL entry points
  s/Interrupts - Remove DebugInterrupts code to make things easier to follow. Add a couple of macros for mapping IRQ numbers to register bits, to help deal with IRQ number translation. Implement new IRQ-related HAL entry points.
  hdr/omap4_reg - Offset the peripheral interrupt numbers so that 0-31 are core 0 private, 32-63 core 1 private, 64+ = peripheral
  hdr/StaticWS - Remove DebugInterrupts code. Reserve space for doorbell device.
  hdr/omap4430 - Remove DebugInterrupts code. Add definitions for aux core boot registers.
Admin:
  Tested on PandaBoard Rev A6


Version 0.52, 1.52.2.1. Tagged as 'OMAP4-0_52-1_52_2_1'
@
text
@a22 1
        GET     Hdr:HALEntries
d43 6
a48 26
        EXPORT  HAL_IRQProperties
        EXPORT  HAL_IRQSetCores
        EXPORT  HAL_IRQGetCores

        ; $base += ($num >> 5) << 2
        ; $bit = 1 << ($num & 31)
        ; NE if $num >= 32
        ; $temp can be $num
        MACRO
        BitMap  $num, $base, $bit, $temp
        MOVS    $bit, $num, LSR #5
        AND     $temp, $num, #31
        ADD     $base, $base, $bit, LSL #2
        MOV     $bit, #1
        MOV     $bit, $bit, LSL $temp
        MEND

        ; As above, but $base = ($num >> 5) << 2
        MACRO
        BitMap0 $num, $base, $bit, $temp
        MOVS    $base, $num, LSR #5
        AND     $temp, $num, #31
        MOV     $base, $base, LSL #2
        MOV     $bit, #1
        MOV     $bit, $bit, LSL $temp
        MEND
d60 1
a60 1
        MOV     a4, #INTERRUPT_MAX-32
d115 9
d126 1
a126 1
HAL_IRQEnable   ROUT
d130 16
a145 8
        BitMap0 a1, a2, a3, a4
        CMP     a1, #32
        LDR     a4, MPU_INTC_Log
        SUBHS   a2, a2, #4 ; Remap to GIC registers (assume we won't get called with wrong private interrupt)
        ADD     a4, a4, #MPU_INTC_DIST + GIC_DIST_ENABLE_SET
        LDR     a1, [a4, a2] ; Get old state
        STR     a3, [a4, a2] ; Set new state
        AND     a1, a1, a3 ; Return value
d148 1
a148 1
HAL_IRQDisable  ROUT
d152 40
a191 18
        BitMap0 a1, a2, a3, a4
        CMP     a1, #32
        LDR     ip, MPU_INTC_Log
        SUBHS   a2, a2, #4 ; Remap to GIC registers (assume we won't get called with wrong private interrupt)
        ADD     a4, ip, #MPU_INTC_DIST + GIC_DIST_ENABLE_CLEAR
        LDR     a2, [a4, a2]! ; Get old state
        STR     a3, [a4] ; Set new state
        LDR     a4, [a4, #GIC_DIST_ACTIVE_BIT-GIC_DIST_ENABLE_CLEAR] ; TODO could this be bogus? - if register isn't banked we'll do the wrong thing
        SUBHS   a1, a1, #32
        TST     a4, a3 ; Was it active?
        BEQ     %FT90
        CMPLO   a1, #16 ; LO if this is core 0 private, check to see if SGI
        ORRLO   a1, a1, #1<<10 ; Set opposite to current CPU
        STR     a1, [ip, #(MPU_INTC_CPU + GIC_CPU_EOI)]
90
        AND     a1, a2, a3 ; Return value
        DSB     SY
        MOV     pc, lr
d193 10
a202 3
HAL_IRQClear    ROUT
        CMP     a1, #32
        SUBHS   a1, a1, #32     ; Map to GIC interrupt number
a203 6
        CMP     a1, #16         ; SGI?
        BHS     %FT10
        MRC     p15, 0, a2, c0, c0, 5
        TST     a2, #1
        ADDEQ   a1, a1, #1<<10  ; Assume it came from the other CPU
10
d208 4
d214 34
a247 1
HAL_IRQSource   ROUT
d251 13
a263 8
        CMP     a1, #INTERRUPT_MAX-32
        MOVHI   a1, #-1            ; Spurious interrupt, ignore it
        MOVHI   pc, lr
        MRC     p15, 0, a4, c0, c0, 5
        AND     a4, a4, #1
        CMP     a1, #32
        ADDLO   a1, a1, a4, LSL #5 ; Remap private interrupt
        ADDHS   a1, a1, #32        ; Remap shared interrupt
d271 1
d273 7
a279 5
        ADD     a2, a2, #(MPU_INTC_DIST + GIC_DIST_ACTIVE_BIT)
        BitMap  a1, a2, a3, a4
        SUBNE   a2, a2, #4      ; Remap to GIC registers
        LDR     a1, [a2]        ; Get status
        AND     a1, a1, a3
d356 4
d417 4
d432 4
d474 11
d489 3
d497 3
d503 3
a519 60
; In: a1 = device number
; Out: a1 = IRQ mask
;      a2 = FIQ mask
;           bits 0-29 of each register give cores that the interrupt can be
;           assigned to
;           bit 30 = private flag
;           bit 31 = interrupt can be routed to multiple cores at once
HAL_IRQProperties
        ; 0-31 for core 0
        ; 32-63 for core 1
        ; 64+ for shared
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a2, #0
        BHS     %FT10
        CMP     a1, #64
        MOVLO   a2, #2 + HALIRQProperty_Private
        MOVHS   a2, #3 + HALIRQProperty_Multicore
        CMP     a1, #32
        MOVLO   a2, #1 + HALIRQProperty_Private
10
        MOV     a1, a2
      [ :LNOT: FIQ_Supported
        MOV     a2, #0
      ]
        MOV     pc, lr

; In: a1 = device number
;     a2 = desired core mask
; Out: a1 = actual core mask
HAL_IRQSetCores
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        CMP     a1, #64
        BLO     %FT10
        LDR     a3, MPU_INTC_Log
        ADD     a3, a3, #MPU_INTC_DIST + GIC_DIST_TARGET
        ADD     a3, a3, a1
        AND     a1, a2, #3
        STRB    a1, [a3, #-32] ; Update mapping
        MOV     pc, lr

HAL_IRQGetCores ; read-only version of IRQSetCores
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        CMP     a1, #64
        BLO     %FT10
        LDR     a3, MPU_INTC_Log
        ADD     a3, a3, #MPU_INTC_DIST + GIC_DIST_TARGET
        ADD     a3, a3, a1
        LDRB    a1, [a3, #-32] ; Get mapping
        MOV     pc, lr

10
        CMP     a1, #32
        MOVHS   a1, #2
        MOVLO   a1, #1
        MOV     pc, lr

@


1.9
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Built, but not tested.

Version 0.44. Tagged as 'OMAP4-0_44'
@
text
@a26 1
        GET     hdr.Timers
a193 3
        ; This routine is also used to clear the timer interrupts
        ; It must also restart the INTC priority sorting, as it is called after every
        ; OS IRQ handler silences the interrupting device
a202 8
        SUB     a2, a1, #TIMER_IRQ_BASE
        CMP     a2, #TIMER_MAX
        BHS     %FT10
        LDR     a3, Timers_Log
        ADD     a3, a3, a2, LSL #TIMER_STRIDE_POW2
        MOV     a2, #7          ; Clear all interrupts
        STR     a2, [a3, #GPT_IRQSTATUS]
10
@


1.8
log
@Fix to spurious interrupt return value in HAL_IRQSource
For a spurious interrupt the return value was not set to -1.
Also, the return value in the non spurious case was only correct because the CPU id is 0.
Inspected, but not tested.

Version 0.32. Tagged as 'OMAP4-0_32'
@
text
@a44 6
 [ DebugInterrupts
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
        IMPORT  DebugHALPrintByte
 ]

@


1.7
log
@Rework of detection of active interrupt source
Avoids stalling of the interrupt system in some circumstances, in particular when shutting down the computer.
Submission from Willi Theiss.
Built, but not tested here.

Version 0.31. Tagged as 'OMAP4-0_31'
@
text
@d267 3
a269 3
        LDR     a1, [a2, #(MPU_INTC_CPU + GIC_CPU_INTACK)]
        BIC     a3, a1, #ICCIAR_CPUID
        CMP     a3, #INTERRUPT_MAX
d271 1
a271 1
        STRLO   a3, LastInterrupt_IRQ
d275 4
a278 1
        MOV     a3, #-1
d280 1
a280 1
        STR     a3, LastInterrupt_IRQ
a281 3
        STR     a1, [a2, #(MPU_INTC_CPU + GIC_CPU_EOI)]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
@


1.6
log
@Switch out, rather than comment out, FIQ code
FIQ's aren't currently supported, but this is now controlled by the 'FIQ_Supported' switch.

Version 0.30. Tagged as 'OMAP4-0_30'
@
text
@d165 1
a165 1
        ; Check if this is actually an IRQ
a166 8
;       ASSERT  INTCPS_ILR_SIZE = 4
;       ADD     a2, a3, a1, LSL #2
;       LDR     a2, [a2, #INTCPS_ILR]
;       TST     a2, #1
;       MOVNE   a1, #0 ; This is an FIQ, so don't disable it
;       MSRNE   CPSR_c, a4
;       Pull    "pc", NE
        ; Now mask the interrupt
d173 1
a173 2
        SUB     lr, ip, #(GIC_DIST_ENABLE_CLEAR - GIC_DIST_ENABLE_SET)
        LDR     lr, [lr, #0]    ; get old state (from ENABLE_SET reg)
d175 1
d180 1
a180 1
 [ DebugInterrupts
d183 13
a195 1
 ]
d201 1
a201 1
        ; This routine is used to clear the timer & vsync interrupts
d221 1
a221 1
        ; signal End Of Interrupt
d289 1
a289 4
        ; First we need to make sure this is an IRQ, not an FIQ?
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
a290 9
;       ASSERT  INTCPS_ILR_SIZE = 4
;       ADD     a3, a2, a1, LSL #2
;       LDR     a3, [a3, #INTCPS_ILR]
;       TST     a3, #1
;       MOVNE   a1, #0 ; This is an FIQ, so it can't fire for IRQ
;       MSRNE   CPSR_c, a4
;       MOVNE   pc, lr
        ; Now check if it's firing

a294 1
        MSR     CPSR_c, a4
@


1.5
log
@Use DSB/ISB directly
Objasm 4 supports ARMv7 opcodes, and this HAL is only every for ARMv7.
Built, but not tested. Submission from Willi Theiss.

Version 0.28. Tagged as 'OMAP4-0_28'
@
text
@d312 2
d315 2
d319 27
d348 1
a348 25
;       CMP     a1, #INTERRUPT_MAX
;       MOVHS   a1, #0
;       MOVHS   pc, lr
;       ; Disable interrupts while we update the controller
;       MRS     a4, CPSR
;       ORR     a3, a4, #F32_bit+I32_bit
;       MSR     CPSR_c, a3
;       ; Set the interrupt type & priority, and then unmask it
;       MOV     a2, #1 ; highest priority for all FIQs.
;       LDR     a3, MPU_INTC_Log
;       ADD     ip, a3, #INTCPS_ILR
;       ASSERT  INTCPS_ILR_SIZE = 4
;       STR     a2, [ip, a1, LSL #2]
;       AND     a2, a1, #&1F ; Mask bit
;       MOV     a1, a1, LSR #5 ; BITS index
;       ASSERT  INTCPS_BITS_SIZE = 32
;       ADD     ip, a3, a1, LSL #5
;       MOV     a1, #1
;       MOV     a2, a1, LSL a2
;       LDR     a1, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
;       STR     a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_CLEAR] ; Write to clear reg to set new state
;       MSR     CPSR_c, a4 ; Re-enable interrupts
;       MVN     a1, a1 ; Invert so we get a mask of enabled interrupts
;       AND     a1, a1, a2 ; Test if it was enabled or not
;       MOV     pc, lr
d351 40
d393 1
a393 38
;       CMP     a1, #INTERRUPT_MAX
;       MOVHS   a1, #0
;       MOVHS   pc, lr
;       Push    "lr"
;       ; Disable interrupts while we update the controller (not necessarily needed for disabling them?)
;       MRS     a4, CPSR
;       ORR     a3, a4, #F32_bit+I32_bit
;       MSR     CPSR_c, a3
;       ; Check if this is actually an FIQ
;       LDR     a3, MPU_INTC_Log
;       ASSERT  INTCPS_ILR_SIZE = 4
;       ADD     a2, a3, a1, LSL #2
;       LDR     a2, [a2, #INTCPS_ILR]
;       TST     a2, #1
;       MOVEQ   a1, #0 ; This is an IRQ, so don't disable it
;       MSREQ   CPSR_c, a4
;       Pull    "pc", EQ
;       ; Now mask the interrupt
;       AND     a2, a1, #&1F ; Mask bit
;       MOV     lr, a1, LSR #5 ; BITS index
;       ASSERT  INTCPS_BITS_SIZE = 32
;       ADD     ip, a3, lr, LSL #5
;       MOV     lr, #1
;       MOV     a2, lr, LSL a2
;       LDR     lr, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
;       STR     a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_SET] ; Mask the interrupt
;       ; Check if we just disabled the active interrupt
;       LDR     ip, [a3, #INTCPS_SIR_FIQ]
;       CMP     ip, a1
;       MOVEQ   ip, #2
;       STREQ   ip, [a3, #INTCPS_CONTROL]
; [ DebugInterrupts
;       MOVEQ   ip, #-1
;       STREQ   ip, LastInterrupt_FIQ
; ]
;       MSR     CPSR_c, a4 ; Re-enable interrupts
;       BIC     a1, a2, lr ; Clear the masked interrupts from a2 to get nonzero result if it was enabled
;       Pull    "pc"
d396 1
d401 48
a448 44
;       MRS     a4, CPSR
;       ORR     a3, a4, #F32_bit+I32_bit
;       MSR     CPSR_c, a3
;       LDR     a1, MPU_INTC_Log
;       ADD     a1, a1, #INTCPS_ILR
;       MOV     a2, #1 ; Mask to write
;       ADD     a3, a1, #INTCPS_BITS+INTCPS_BITS_MIR_SET-INTCPS_ILR
;HAL_FIQDisableAll_Loop1
;       LDR     ip, [a1],#INTCPS_ILR_SIZE
;       TST     ip, #1 ; 1=FIQ, 0=IRQ
;       STRNE   a2, [a3] ; Disable it
;       MOVS    a2, a2, LSL #1
;       BCC     HAL_FIQDisableAll_Loop1
;       ; Move on to next word
;       MOV     a2, #1
;       ADD     a3, a3, #INTCPS_BITS_SIZE
;HAL_FIQDisableAll_Loop2
;       LDR     ip, [a1],#INTCPS_ILR_SIZE
;       TST     ip, #1 ; 1=FIQ, 0=IRQ
;       STRNE   a2, [a3] ; Disable it
;       MOVS    a2, a2, LSL #1
;       BCC     HAL_FIQDisableAll_Loop2
;       ; Move on to last word
;       MOV     a2, #1
;       ADD     a3, a3, #INTCPS_BITS_SIZE
;HAL_FIQDisableAll_Loop3
;       LDR     ip, [a1],#INTCPS_ILR_SIZE
;       TST     ip, #1 ; 1=FIQ, 0=IRQ
;       STRNE   a2, [a3] ; Disable it
;       MOVS    a2, a2, LSL #1
;       BCC     HAL_FIQDisableAll_Loop3
;       ; Done
;       ASSERT  INTCPS_BITS_COUNT = 3
;       MSR     CPSR_c, a4
;       ; FIQDisableAll is only called during emergency situations, so restart INTC priority sorting to avoid having to rewrite various bits of RISC OS code to query FIQ sources and call FIQClear on each one (which would otherwise be the only legal way of stopping all FIQs from firing)
;       LDR     a2, MPU_INTC_Log
;       MOV     a1, #2
;       STR     a1, [a2, #INTCPS_CONTROL]
;       ; Data synchronisation barrier to make sure INTC gets the message
;       DSB     SY
; [ DebugInterrupts
;       MOV     a1, #-1
;       STR     a1, LastInterrupt_FIQ
; ]
d452 12
a463 10
;       ; Restart INTC priority sorting
;       LDR     a2, MPU_INTC_Log
;       MOV     a1, #2
;       STR     a1, [a2, #INTCPS_CONTROL]
;       ; Data synchronisation barrier to make sure INTC gets the message
;       DSB     SY
; [ DebugInterrupts
;       MOV     a1, #-1
;       STR     a1, LastInterrupt_FIQ
; ]
d467 28
d497 1
a497 26
;       ; Test if FIQ is firing, irrespective of mask state
;       CMP     a1, #INTERRUPT_MAX
;       MOVHS   a1, #0
;       MOVHS   pc, lr
;       ; First we need to make sure this is an FIQ, not an IRQ?
;       MRS     a4, CPSR
;       ORR     a3, a4, #F32_bit+I32_bit
;       MSR     CPSR_c, a3
;       LDR     a2, MPU_INTC_Log
;       ASSERT  INTCPS_ILR_SIZE = 4
;       ADD     a3, a2, a1, LSL #2
;       LDR     a3, [a3, #INTCPS_ILR]
;       TST     a3, #1
;       MOVEQ   a1, #0 ; This is an IRQ, so it can't fire for FIQ
;       MSREQ   CPSR_c, a4
;       MOVEQ   pc, lr
;       ; Now check if it's firing
;       ASSERT  INTCPS_BITS_SIZE = 32
;       MOV     a3, a1, LSR #5
;       ADD     a3, a2, a3, LSL #5
;       LDR     a3, [a3, #INTCPS_BITS+INTCPS_BITS_ITR]
;       MSR     CPSR_c, a4
;       AND     a1, a1, #31
;       MOV     a1, a3, LSR a1 ; Shift and invert so 1=active
;       AND     a1, a1, #1 ; 0 = not firing, 1 = firing
;       MOV     pc, lr
d500 39
d541 1
a541 37
; [ DebugInterrupts
;       LDR     a1, LastInterrupt_FIQ
;       CMP     a1, #0
;       BLT     %FT10
;       Push    "lr"
;       BL      DebugHALPrint
;       =       "HAL_FIQSource: Previous FIQ not cleared: ", 0
;       DebugReg a1
;       Pull    "lr"
;10
; ]
;       ; Does the ARM think an interrupt is occuring?
;       MRC     p15, 0, a1, c12, c1, 0
;       TST     a1, #F32_bit
;       MOVEQ   a1, #-1
; [ DebugInterrupts
;       STREQ   a1, LastInterrupt_FIQ
; ]
;       MOVEQ   pc, lr
;       LDR     a2, MPU_INTC_Log
;       LDR     a1, [a2, #INTCPS_SIR_FIQ]
;       CMP     a1, #INTERRUPT_MAX
;       ANDLO   a1, a1, #&7F
; [ DebugInterrupts
;       STRLO   a1, LastInterrupt_FIQ
; ]
;       MOVLO   pc, lr
;       ; Authentic spurious interrupt - restart INTC and return -1
;       MOV     a1, #-1
; [ DebugInterrupts
;       STR     a1, LastInterrupt_FIQ
; ]
;       MOV     a3, #2
;       STR     a3, [a2, #INTCPS_CONTROL]
;       ; Data synchronisation barrier to make sure INTC gets the message
;       DSB     SY
;       MOV     pc, lr
@


1.4
log
@Implement HAL_IRQMax
Detail:
  s/Boot, s/Interrupts - Added HAL_IRQMax implementation, to ensure correct functionality with latest Kernel
Admin:
  Builds OK but untested at runtime
  Requires Kernel-5_35-4_79_2_182


Version 0.13. Tagged as 'OMAP4-0_13'
@
text
@a27 1
        GET     hdr.CoPro15ops
d221 1
a221 1
        myDSB
d277 1
a277 1
        myDSB
d429 1
a429 1
;       myDSB
d442 1
a442 1
;       myDSB
d517 1
a517 1
;       myDSB
@


1.3
log
@  Added SD support for Pandaboard
Detail:
  SDHCI HAL device created. Also, Entry HAL_UARTDefault added (supports
  OS_SerialOp) and HALDoesVideo switch, previously disabled, is now removed.
Admin:
  Requires SDIODriver 0.04.
  Changes received from Willi Theiss.

Version 0.10. Tagged as 'OMAP4-0_10'
@
text
@d44 1
d521 4
@


1.2
log
@Bulk expand of tabs.
Helps to make tracking changes between OMAP3 and OMAP4 less eye watering, but otherwise functionally the same as 0.06.

Version 0.07. Tagged as 'OMAP4-0_07'
@
text
@a208 8
 [ HALDoesVideo
        CMP     a1, #VIDEO_IRQ
        LDREQ   a2, L4_Display_Log
        ADDEQ   a2, a2, #DISPC_BASE
        MVNEQ   a3, #0          ; Clear all DSS IRQs, just in case
        STREQ   a3, [a2, #(DISPC_IRQSTATUS - DISPC_BASE)]
        BEQ     %FT10
 ]
@


1.1
log
@Initial revision
@
text
@d16 28
a43 28
	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:Machine.<Machine>
	GET	Hdr:ImageSize.<ImageSize>

	GET	Hdr:OSEntries

	GET	hdr.omap4430
	GET	hdr.StaticWS
	GET	hdr.Interrupts
	GET	hdr.Timers
	GET	hdr.CoPro15ops

	AREA	|Asm$$Code|, CODE, READONLY, PIC

	EXPORT	Interrupt_Init
	EXPORT	HAL_IRQEnable
	EXPORT	HAL_IRQDisable
	EXPORT	HAL_IRQClear
	EXPORT	HAL_IRQSource
	EXPORT	HAL_IRQStatus
	EXPORT	HAL_FIQEnable
	EXPORT	HAL_FIQDisable
	EXPORT	HAL_FIQDisableAll
	EXPORT	HAL_FIQClear
	EXPORT	HAL_FIQSource
	EXPORT	HAL_FIQStatus
d46 3
a48 3
	IMPORT	DebugHALPrint
	IMPORT	DebugHALPrintReg
	IMPORT	DebugHALPrintByte
d54 2
a55 2
			GBLL	DebugDisablePrevious
DebugDisablePrevious	SETL	{FALSE}
d58 11
a68 11
	; 1. disable Distributor Controller
	LDR	a1, MPU_INTC_Log
	ADD	a1, a1, #MPU_INTC_DIST
	MOV	a2, #0		; disable ICDDCR
	STR	a2, [a1, #GIC_DIST_CTRL]

	; 2. set all global interrupts to be level triggered, active low
	ADD	a3, a1, #GIC_DIST_CONFIG
	ADD	a3, a3, #8
	MOV	a4, #INTERRUPT_MAX
	MOV	ip, #32
d70 11
a80 11
	STR	a2, [a3], #4
	ADD	ip, ip, #16
	CMP	ip, a4
	BNE	%BT10

	; 3. set all global interrupts to this CPU only
	ADD	a3, a1, #(GIC_DIST_TARGET + 32)
	MOV	ip, #32
	MOV	a2, #1
	ORR	a2, a2, a2, LSL #8
	ORR	a2, a2, a2, LSL #16
d82 11
a92 11
	STR	a2, [a3], #4
	ADD	ip, ip, #4
	CMP	ip, a4
	BNE	%BT20

	; 4. set priority on all interrupts
	ADD	a3, a1, #(GIC_DIST_PRI + 32)
	MOV	ip, #32
	MOV	a2, #&A0
	ORR	a2, a2, a2, LSL #8
	ORR	a2, a2, a2, LSL #16
d94 9
a102 9
	STR	a2, [a3], #4
	ADD	ip, ip, #4
	CMP	ip, a4
	BNE	%BT30

	; 5. disable all interrupts
	ADD	a3, a1, #GIC_DIST_ENABLE_CLEAR
	MOV	ip, #32
	MOV	a2, #-1
d104 18
a121 18
	STR	a2, [a3], #4
	ADD	ip, ip, #32
	CMP	ip, a4
	BNE	%BT40

	; 6. enable Distributor Controller
	MOV	a2, #ICDDCR_ENABLE
	STR	a2, [a1, #GIC_DIST_CTRL]

	; 7. set PRIMASK in CPU interface
	LDR	a1, MPU_INTC_Log
	MOV	a2, #&F0
	STR	a2, [a1, #(MPU_INTC_CPU + GIC_CPU_PRIMASK)]

	; 8. enable CPU interface
	MOV	a2, #ICCICR_ENABLE
	STR	a2, [a1, #(MPU_INTC_CPU + GIC_CPU_CTRL)]
	; ... and everything else looks good?
d123 3
a125 3
	MOV	a1, #-1
	STR	a1, LastInterrupt_IRQ
	STR	a1, LastInterrupt_FIQ
d127 2
a128 2
	MOV	a1, #0
	STR	a1, ExtraDebugIRQEnabled
d131 1
a131 1
	MOV	pc, lr
d134 20
a153 20
	CMP	a1, #INTERRUPT_MAX
	MOVHS	a1, #0
	MOVHS	pc, lr
	; Disable interrupts while we update the controller
	MRS	a4, CPSR
	ORR	a3, a4, #F32_bit+I32_bit
	MSR	CPSR_c, a3
	; Unmask the interrupt
	LDR	a3, MPU_INTC_Log
	ADD	ip, a3, #(MPU_INTC_DIST + GIC_DIST_ENABLE_SET)
	AND	a2, a1, #31	; bit   = intno % 32
	MOV	a1, a1, LSR #5	; index = intno / 32
	ADD	ip, ip, a1, LSL #2
	MOV	a1, #1
	MOV	a2, a1, LSL a2	; mask = (1 << bit)
	LDR	a1, [ip, #0]	; get old state
	STR	a2, [ip, #0]	; set new state
	MSR	CPSR_c, a4	; Re-enable interrupts
	AND	a1, a1, a2	; Test if it was enabled or not
	MOV	pc, lr
d156 32
a187 32
	CMP	a1, #INTERRUPT_MAX
	MOVHS	a1, #0
	MOVHS	pc, lr
	Push	"lr"
	; Disable interrupts while we update the controller
	; (not necessarily needed for disabling them?)
	MRS	a4, CPSR
	ORR	a3, a4, #F32_bit+I32_bit
	MSR	CPSR_c, a3
	; Check if this is actually an IRQ
	LDR	a3, MPU_INTC_Log
;	ASSERT	INTCPS_ILR_SIZE = 4
;	ADD	a2, a3, a1, LSL #2
;	LDR	a2, [a2, #INTCPS_ILR]
;	TST	a2, #1
;	MOVNE	a1, #0 ; This is an FIQ, so don't disable it
;	MSRNE	CPSR_c, a4
;	Pull	"pc", NE
	; Now mask the interrupt
	ADD	ip, a3, #(MPU_INTC_DIST + GIC_DIST_ENABLE_CLEAR)
	AND	a2, a1, #31	; bit   = intno % 32
	MOV	lr, a1, LSR #5	; index = intno / 32
	ADD	ip, ip, lr, LSL #2
	MOV	lr, #1
	MOV	a2, lr, LSL a2	; mask = (1 << bit)
	SUB	lr, ip, #(GIC_DIST_ENABLE_CLEAR - GIC_DIST_ENABLE_SET)
	LDR	lr, [lr, #0]	; get old state (from ENABLE_SET reg)
	STR	a2, [ip, #0]	; mask the interrupt
	; Check if we just disabled the active interrupt
	LDR	ip, [a3, #(MPU_INTC_CPU + GIC_CPU_INTACK)]
	CMP	ip, a1
	STREQ	ip, [a3, #(MPU_INTC_CPU + GIC_CPU_EOI)]
d189 2
a190 2
	MOVEQ	ip, #-1
	STREQ	ip, LastInterrupt_IRQ
d192 3
a194 3
	MSR	CPSR_c, a4	; Re-enable interrupts
	AND	a1, lr, a2	; Test if it was enabled or not
	Pull	"pc"
d197 3
a199 3
	; This routine is used to clear the timer & vsync interrupts
	; It must also restart the INTC priority sorting, as it is called after every
	; OS IRQ handler silences the interrupting device
d201 6
a206 6
	LDR	a2, ExtraDebugIRQEnabled
	CMP	a2, #0
	BEQ	%FT10
	Push	"lr"
	DebugReg a1, "HAL_IRQClear: "
	Pull	"lr"
d210 6
a215 6
	CMP	a1, #VIDEO_IRQ
	LDREQ	a2, L4_Display_Log
	ADDEQ	a2, a2, #DISPC_BASE
	MVNEQ	a3, #0		; Clear all DSS IRQs, just in case
	STREQ	a3, [a2, #(DISPC_IRQSTATUS - DISPC_BASE)]
	BEQ	%FT10
d217 7
a223 7
	SUB	a2, a1, #TIMER_IRQ_BASE
	CMP	a2, #TIMER_MAX
	BHS	%FT10
	LDR	a3, Timers_Log
	ADD	a3, a3, a2, LSL #TIMER_STRIDE_POW2
	MOV	a2, #7		; Clear all interrupts
	STR	a2, [a3, #GPT_IRQSTATUS]
d225 5
a229 5
	; signal End Of Interrupt
	LDR	a2, MPU_INTC_Log
	STR	a1, [a2, #(MPU_INTC_CPU + GIC_CPU_EOI)]
	; Data synchronisation barrier to make sure INTC gets the message
	myDSB
d231 2
a232 2
	MOV	a1, #-1
	STR	a1, LastInterrupt_IRQ
d234 1
a234 1
	MOV	pc, lr
d238 7
a244 7
	LDR	a1, LastInterrupt_IRQ
	CMP	a1, #0
	BLT	%FT10
	Push	"lr"
	BL	DebugHALPrint
	=	"HAL_IRQSource: Previous IRQ not cleared: ", 0
	DebugReg a1
d246 1
a246 1
	BL	HAL_IRQDisable
d250 1
a250 1
	STR	pc, ExtraDebugIRQEnabled ; any nonzero value will do
d252 4
a255 4
	MOV	lr, pc ; BL to the main routine so we can get the exit code
	B	%FT05
	DebugReg a1, "HAL_IRQSource: New IRQ: "
	Pull	"pc"
d258 1
a258 1
	Pull	"lr"
d262 4
a265 4
	; Does the ARM think an interrupt is occuring?
	MRC	p15, 0, a1, c12, c1, 0
	TST	a1, #I32_bit
	MOVEQ	a1, #-1
d267 1
a267 1
	STREQ	a1, LastInterrupt_IRQ
d269 5
a273 5
	MOVEQ	pc, lr
	LDR	a2, MPU_INTC_Log
	LDR	a1, [a2, #(MPU_INTC_CPU + GIC_CPU_INTACK)]
	BIC	a3, a1, #ICCIAR_CPUID
	CMP	a3, #INTERRUPT_MAX
d275 1
a275 1
	STRLO	a3, LastInterrupt_IRQ
d277 3
a279 3
	MOVLO	pc, lr
	; Authentic spurious interrupt - restart INTC and return -1
	MOV	a3, #-1
d281 1
a281 1
	STR	a3, LastInterrupt_IRQ
d283 4
a286 4
	STR	a1, [a2, #(MPU_INTC_CPU + GIC_CPU_EOI)]
	; Data synchronisation barrier to make sure INTC gets the message
	myDSB
	MOV	pc, lr
d289 27
a315 27
	; Test if IRQ is firing, irrespective of mask state
	CMP	a1, #INTERRUPT_MAX
	MOVHS	a1, #0
	MOVHS	pc, lr
	; First we need to make sure this is an IRQ, not an FIQ?
	MRS	a4, CPSR
	ORR	a3, a4, #F32_bit+I32_bit
	MSR	CPSR_c, a3
	LDR	a2, MPU_INTC_Log
;	ASSERT	INTCPS_ILR_SIZE = 4
;	ADD	a3, a2, a1, LSL #2
;	LDR	a3, [a3, #INTCPS_ILR]
;	TST	a3, #1
;	MOVNE	a1, #0 ; This is an FIQ, so it can't fire for IRQ
;	MSRNE	CPSR_c, a4
;	MOVNE	pc, lr
	; Now check if it's firing

	ADD	ip, a2, #(MPU_INTC_DIST + GIC_DIST_ACTIVE_BIT)
	MOV	a3, a1, LSR #5	; index = intno / 32
	ADD	ip, ip, a3, LSL #2
	LDR	a3, [ip, #0]	; get old state
	MSR	CPSR_c, a4
	AND	a1, a1, #31	; bit   = intno % 32
	MOV	a1, a3, LSR a1	; Shift and invert so 1=active
	AND	a1, a1, #1	; 0 = not firing, 1 = firing
	MOV	pc, lr
d323 27
a349 27
	MOV	a1, #0
	MOV	pc, lr
;	CMP	a1, #INTERRUPT_MAX
;	MOVHS	a1, #0
;	MOVHS	pc, lr
;	; Disable interrupts while we update the controller
;	MRS	a4, CPSR
;	ORR	a3, a4, #F32_bit+I32_bit
;	MSR	CPSR_c, a3
;	; Set the interrupt type & priority, and then unmask it
;	MOV	a2, #1 ; highest priority for all FIQs.
;	LDR	a3, MPU_INTC_Log
;	ADD	ip, a3, #INTCPS_ILR
;	ASSERT	INTCPS_ILR_SIZE = 4
;	STR	a2, [ip, a1, LSL #2]
;	AND	a2, a1, #&1F ; Mask bit
;	MOV	a1, a1, LSR #5 ; BITS index
;	ASSERT	INTCPS_BITS_SIZE = 32
;	ADD	ip, a3, a1, LSL #5
;	MOV	a1, #1
;	MOV	a2, a1, LSL a2
;	LDR	a1, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
;	STR	a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_CLEAR] ; Write to clear reg to set new state
;	MSR	CPSR_c, a4 ; Re-enable interrupts
;	MVN	a1, a1 ; Invert so we get a mask of enabled interrupts
;	AND	a1, a1, a2 ; Test if it was enabled or not
;	MOV	pc, lr
d352 33
a384 33
	MOV	a1, #0
	MOV	pc, lr
;	CMP	a1, #INTERRUPT_MAX
;	MOVHS	a1, #0
;	MOVHS	pc, lr
;	Push	"lr"
;	; Disable interrupts while we update the controller (not necessarily needed for disabling them?)
;	MRS	a4, CPSR
;	ORR	a3, a4, #F32_bit+I32_bit
;	MSR	CPSR_c, a3
;	; Check if this is actually an FIQ
;	LDR	a3, MPU_INTC_Log
;	ASSERT	INTCPS_ILR_SIZE = 4
;	ADD	a2, a3, a1, LSL #2
;	LDR	a2, [a2, #INTCPS_ILR]
;	TST	a2, #1
;	MOVEQ	a1, #0 ; This is an IRQ, so don't disable it
;	MSREQ	CPSR_c, a4
;	Pull	"pc", EQ
;	; Now mask the interrupt
;	AND	a2, a1, #&1F ; Mask bit
;	MOV	lr, a1, LSR #5 ; BITS index
;	ASSERT	INTCPS_BITS_SIZE = 32
;	ADD	ip, a3, lr, LSL #5
;	MOV	lr, #1
;	MOV	a2, lr, LSL a2
;	LDR	lr, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
;	STR	a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_SET] ; Mask the interrupt
;	; Check if we just disabled the active interrupt
;	LDR	ip, [a3, #INTCPS_SIR_FIQ]
;	CMP	ip, a1
;	MOVEQ	ip, #2
;	STREQ	ip, [a3, #INTCPS_CONTROL]
d386 2
a387 2
;	MOVEQ	ip, #-1
;	STREQ	ip, LastInterrupt_FIQ
d389 3
a391 3
;	MSR	CPSR_c, a4 ; Re-enable interrupts
;	BIC	a1, a2, lr ; Clear the masked interrupts from a2 to get nonzero result if it was enabled
;	Pull	"pc"
d394 11
a404 11
	; This isn't particularly great, we need to scan the entire ILR array
	; and work out which are FIQs, and then write to the ISR_SET registers
	; We should probably keep our own array of enabled FIQs so this can be
	; done more quickly
;	MRS	a4, CPSR
;	ORR	a3, a4, #F32_bit+I32_bit
;	MSR	CPSR_c, a3
;	LDR	a1, MPU_INTC_Log
;	ADD	a1, a1, #INTCPS_ILR
;	MOV	a2, #1 ; Mask to write
;	ADD	a3, a1, #INTCPS_BITS+INTCPS_BITS_MIR_SET-INTCPS_ILR
d406 8
a413 8
;	LDR	ip, [a1],#INTCPS_ILR_SIZE
;	TST	ip, #1 ; 1=FIQ, 0=IRQ
;	STRNE	a2, [a3] ; Disable it
;	MOVS	a2, a2, LSL #1
;	BCC	HAL_FIQDisableAll_Loop1
;	; Move on to next word
;	MOV	a2, #1
;	ADD	a3, a3, #INTCPS_BITS_SIZE
d415 8
a422 8
;	LDR	ip, [a1],#INTCPS_ILR_SIZE
;	TST	ip, #1 ; 1=FIQ, 0=IRQ
;	STRNE	a2, [a3] ; Disable it
;	MOVS	a2, a2, LSL #1
;	BCC	HAL_FIQDisableAll_Loop2
;	; Move on to last word
;	MOV	a2, #1
;	ADD	a3, a3, #INTCPS_BITS_SIZE
d424 14
a437 14
;	LDR	ip, [a1],#INTCPS_ILR_SIZE
;	TST	ip, #1 ; 1=FIQ, 0=IRQ
;	STRNE	a2, [a3] ; Disable it
;	MOVS	a2, a2, LSL #1
;	BCC	HAL_FIQDisableAll_Loop3
;	; Done
;	ASSERT	INTCPS_BITS_COUNT = 3
;	MSR	CPSR_c, a4
;	; FIQDisableAll is only called during emergency situations, so restart INTC priority sorting to avoid having to rewrite various bits of RISC OS code to query FIQ sources and call FIQClear on each one (which would otherwise be the only legal way of stopping all FIQs from firing)
;	LDR	a2, MPU_INTC_Log
;	MOV	a1, #2
;	STR	a1, [a2, #INTCPS_CONTROL]
;	; Data synchronisation barrier to make sure INTC gets the message
;	myDSB
d439 2
a440 2
;	MOV	a1, #-1
;	STR	a1, LastInterrupt_FIQ
d442 1
a442 1
	MOV	pc, lr
d445 6
a450 6
;	; Restart INTC priority sorting
;	LDR	a2, MPU_INTC_Log
;	MOV	a1, #2
;	STR	a1, [a2, #INTCPS_CONTROL]
;	; Data synchronisation barrier to make sure INTC gets the message
;	myDSB
d452 2
a453 2
;	MOV	a1, #-1
;	STR	a1, LastInterrupt_FIQ
d455 1
a455 1
	MOV	pc, lr
d458 28
a485 28
	MOV	a1, #0
	MOV	pc, lr
;	; Test if FIQ is firing, irrespective of mask state
;	CMP	a1, #INTERRUPT_MAX
;	MOVHS	a1, #0
;	MOVHS	pc, lr
;	; First we need to make sure this is an FIQ, not an IRQ?
;	MRS	a4, CPSR
;	ORR	a3, a4, #F32_bit+I32_bit
;	MSR	CPSR_c, a3
;	LDR	a2, MPU_INTC_Log
;	ASSERT	INTCPS_ILR_SIZE = 4
;	ADD	a3, a2, a1, LSL #2
;	LDR	a3, [a3, #INTCPS_ILR]
;	TST	a3, #1
;	MOVEQ	a1, #0 ; This is an IRQ, so it can't fire for FIQ
;	MSREQ	CPSR_c, a4
;	MOVEQ	pc, lr
;	; Now check if it's firing
;	ASSERT	INTCPS_BITS_SIZE = 32
;	MOV	a3, a1, LSR #5
;	ADD	a3, a2, a3, LSL #5
;	LDR	a3, [a3, #INTCPS_BITS+INTCPS_BITS_ITR]
;	MSR	CPSR_c, a4
;	AND	a1, a1, #31
;	MOV	a1, a3, LSR a1 ; Shift and invert so 1=active
;	AND	a1, a1, #1 ; 0 = not firing, 1 = firing
;	MOV	pc, lr
d488 2
a489 2
	MOV	a1, #0
	MOV	pc, lr
d491 8
a498 8
;	LDR	a1, LastInterrupt_FIQ
;	CMP	a1, #0
;	BLT	%FT10
;	Push	"lr"
;	BL	DebugHALPrint
;	=	"HAL_FIQSource: Previous FIQ not cleared: ", 0
;	DebugReg a1
;	Pull	"lr"
d501 4
a504 4
;	; Does the ARM think an interrupt is occuring?
;	MRC	p15, 0, a1, c12, c1, 0
;	TST	a1, #F32_bit
;	MOVEQ	a1, #-1
d506 1
a506 1
;	STREQ	a1, LastInterrupt_FIQ
d508 5
a512 5
;	MOVEQ	pc, lr
;	LDR	a2, MPU_INTC_Log
;	LDR	a1, [a2, #INTCPS_SIR_FIQ]
;	CMP	a1, #INTERRUPT_MAX
;	ANDLO	a1, a1, #&7F
d514 1
a514 1
;	STRLO	a1, LastInterrupt_FIQ
d516 3
a518 3
;	MOVLO	pc, lr
;	; Authentic spurious interrupt - restart INTC and return -1
;	MOV	a1, #-1
d520 1
a520 1
;	STR	a1, LastInterrupt_FIQ
d522 5
a526 5
;	MOV	a3, #2
;	STR	a3, [a2, #INTCPS_CONTROL]
;	; Data synchronisation barrier to make sure INTC gets the message
;	myDSB
;	MOV	pc, lr
d528 1
a528 1
	END
@


1.1.1.1
log
@  Initial import of OMAP4 HAL
Detail:
  Target platform is the Pandaboard, based on the TI OMAP4 SoC.
  Port is not yet complete, in particular, audio is not yet working.
Admin:
  Submission from Willi Theiß
@
text
@@

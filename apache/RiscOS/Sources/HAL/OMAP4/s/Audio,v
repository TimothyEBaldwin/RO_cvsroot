head	1.14;
access;
symbols
	OMAP4-0_60:1.14
	OMAP4-0_59-1_52_2_3:1.14
	OMAP4-0_59:1.14
	OMAP4-0_58:1.14
	OMAP4-0_57:1.14
	OMAP4-0_56:1.14
	OMAP4-0_55:1.14
	OMAP4-0_54-1_52_2_2:1.14
	OMAP4-0_54:1.14
	OMAP4-0_53:1.14
	OMAP4-0_52-1_52_2_1:1.14
	SMP:1.14.0.2
	SMP_bp:1.14
	OMAP4-0_52:1.14
	OMAP4-0_51:1.14
	OMAP4-0_50:1.14
	OMAP4-0_49:1.14
	OMAP4-0_48:1.14
	OMAP4-0_47:1.14
	OMAP4-0_46:1.14
	OMAP4-0_45:1.14
	OMAP4-0_44:1.14
	OMAP4-0_43:1.13
	OMAP4-0_42:1.11
	OMAP4-0_41:1.11
	OMAP4-0_40:1.11
	OMAP4-0_39:1.11
	OMAP4-0_38:1.11
	OMAP4-0_37:1.11
	OMAP4-0_36:1.11
	OMAP4-0_35:1.10
	OMAP4-0_34:1.10
	OMAP4-0_33:1.9
	OMAP4-0_32:1.9
	OMAP4-0_31:1.9
	OMAP4-0_30:1.9
	OMAP4-0_29:1.9
	OMAP4-0_28:1.9
	OMAP4-0_27:1.9
	OMAP4-0_26:1.9
	OMAP4-0_25:1.7
	OMAP4-0_24:1.7
	OMAP4-0_23:1.7
	OMAP4-0_22:1.6
	OMAP4-0_21:1.6
	OMAP4-0_20:1.6
	OMAP4-0_19:1.6
	OMAP4-0_18:1.6
	OMAP4-0_17:1.6
	OMAP4-0_16:1.6
	OMAP4-0_15:1.6
	OMAP4-0_14:1.6
	OMAP4-0_13:1.5
	OMAP4-0_12:1.5
	OMAP4-0_11:1.5
	OMAP4-0_10:1.4
	OMAP4-0_09:1.4
	OMAP4-0_08:1.4
	OMAP4-0_07:1.4
	OMAP4-0_06:1.3
	OMAP4-0_05:1.2
	OMAP4-0_04:1.1.1.1
	OMAP4-0_03:1.1.1.1
	OMAP4-0_02:1.1.1.1
	OMAP4-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.14
date	2015.04.08.07.33.52;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	ziZUYwsqx4235Lgy;

1.13
date	2015.04.06.09.10.08;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	XYNIs9mfAwAVFvgy;

1.11
date	2014.09.04.21.41.12;	author jlee;	state Exp;
branches;
next	1.10;
commitid	AjMWLbVyJ9pcI4Px;

1.10
date	2014.04.22.06.48.05;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	eiJRxQSZyLUP6Exx;

1.9
date	2013.11.16.14.23.24;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	EPfrAKQl1ecNFvdx;

1.8
date	2013.11.16.12.42.14;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	rq7TCNxuD31f7vdx;

1.7
date	2013.11.01.19.01.19;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	3j2IHKaDTdkbHBbx;

1.6
date	2013.04.07.08.13.12;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	pJ3reWwimQfmNOKw;

1.5
date	2012.07.04.17.59.09;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	7eFD0kniLkapWgbw;

1.4
date	2012.03.25.11.42.57;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	4FjnaYBzkPTA6gYv;

1.3
date	2012.03.25.10.28.46;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	wcxutstPODhaHfYv;

1.2
date	2012.02.11.17.48.09;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	W3PfhFs2h9uBvLSv;

1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;
commitid	M3eV6gzJuoHHMezv;

1.1.1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches;
next	;
commitid	M3eV6gzJuoHHMezv;


desc
@@


1.14
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Built, but not tested.

Version 0.44. Tagged as 'OMAP4-0_44'
@
text
@; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries
        GET     Hdr:HALDevice
        GET     Hdr:AudioDevice
        GET     Hdr:MixerDevice
        GET     Hdr:Proc

        GET     hdr.omap4430
        GET     hdr.StaticWS
        GET     hdr.PRCM
        GET     hdr.GPIO

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  Audio_Init

        IMPORT  TPSRead
        IMPORT  TPSWrite

        IMPORT  memcpy
        IMPORT  HAL_IRQClear
        IMPORT  HAL_CounterDelay
        IMPORT  GPIOx_SetAsOutput

; A brief rundown of OMAP4 HAL audio support:
; Audio in/out is typically provided via the TWL6040 companion chip.
; Two interfaces are used to link the audio subsystem to the OMAP: I2C is used to program the
; audio subsystem, and PDM is used to transmit & receive data (using the McPDM module on the
; OMAP side).
; Both the TWL6040 and the OMAP are capable of acting as either the master or slave across the
; PDM link, so to keep things simple this implementation has the TWL6040 acting as master and
; the OMAP acting as slave.
; Finally, to keep the McPDM buffer full, the SDMA module of the OMAP is used

; This means that, on the software side, audio is provided by the following network of
; components:
;
;                             HAL I2C driver
;                                   |
;                           RISC OS I2C driver
;                           |                |
;                HAL mixer device  <->  HAL audio device
;                       |                     |
;             SoundControl module  <->  SoundDMA module
;                                             |
;                                       DMAManager module
;                                             |
;                                       HAL DMA device
;
; (Note - there's also a small amount of communication between the HAL DMA device and the HAL
; audio device, to allow for the correct setting of the FIFO threshold/DMA packet size)

; With regards to the actual sound I/O features TWL6040 makes available:
; Audio output:
;   Headset
;   Handsfree
;   Vibrator
;   Auxiliary
;   Earphone
; Audio input:
;   Mic left input (Main mic | HS mic | AUX/FM left input)
;   Mic right input (Main mic | HS mic | AUX/FM right input)
;   Line In

; The Phoenix codec (TWL6040) renders samples at 88.2 kHz and 96 kHz.
; Handsfree speakers and other paths work at 96 kHz, but headphone has 2 modes:
;   Low power mode (88.2 and 96 kHz)
;   High performance mode (96 kHz only)

; There are 8 digital input channels on TWL6040 that can be used for rendering audio out
; to 9 different analogue outputs. There are 5 McPDM channels (DL0 - DL4), an I2C channel
; and 2 auxiliary inputs that can be used for FM radio (AFM0/AFM1). Audio from these
; inputs can be routed to the various analogue outputs as per following table:

; Output port   DL0     DL1     DL2     DL3     DL4     I2C or frame(3) AFM0    AFM1
; Earphone      X(1)
; Left Headset  X                                                       X
; Right Headset X       X                                                       X
; Left HF                       X                                       X
; Right HF                      X       X                                       X
; Left Aux                      X(2)                                    X
; Right Aux                     X(2)    X(2)                                    X
; Left Vibr.                                    X       X
; Right Vibr.                                   X       X
; (1) This path cannot be concurrent of L/R headset paths
; (2) These paths can be concurrent but not independent of L/R handsfree paths
; (3) The frame line can be used for register write in command mode

; TWL6040 has the following 5 analogue input channels that can be used for encoding audio.
; Uplink audio from TWL6040 to the OMAP Audio BackEnd (ABE) can be transferred over
; 2 McPDM channles (UL0 and UL1) or via 2 auxiliary ports, AFM0 and AFM1, which are often
; used for FM radio audio. The possible mappings of these inputs to uplink channels in to
; the OMAP ABE are as follows:

; Input port            UL0     UL1     AFM0    AFM1
; Main Microphone, MMIC X
; Sub Microphone, SMIC          X
; Headset Micro, HSMIC  X       X
; Left Aux/FM radio     X               X
; Right Aux/FM radio            X               X

; So, in summary.....
; * Since RISC OS only produces one stream of stereo data, we can assign one DAC/amplifier pair
;   (HSL/HSR, to keep the voice path free for the future?) to playing the data generated by
;   the OS
; * There are only two ADCs, so you can only really sample from one stereo source at a time
;   (or two mono)
; * The plethora of outputs can select their mix from RISC OS sound data & the ADC data at will
; * In any case, RISC OS doesn't really have an API for sound recording (or setting the
;   recording source), so we could just ignore all the inputs entirely until that gets
;   rectified (although for most OMAP devices which RISC OS is targeting, it's likely that the
;   stereo "auxiliary" input will be the one providing all the input data, so an API to select
;   the recording source isn't entirely necessary)

; As for mapping inputs & outputs to those currently supported by the HAL mixer API:
; TWL6040                         HAL mixer category
; Headset left/right              HEADPHONES
; Earphone                        SPEAKER
; Hands-free left/right           LINE_OUT
; Auxiliary left/right            AUX_OUT
;
; Headset mic                     MIC
; Handset main mic                AUX_IN
; Handset sub mic                 none?
; Digital mic 0                   none?
; Digital mic 1                   none?
; Stereo FM/aux input             LINE_IN


; For all pandaboards the TWL6040 is connected to the OMAP4 via I2C1 & McPDM.
;
; The OMAP4430 Pandaboard provides a stacked audio connector, which provides two 3.5 mm audio
; jack connections. The upper jack on this stacked connector (J16A) is connected to the
; Headset Microphone Plus and Minus inputs of the TWL6040 Audio Companion IC. The lower jack on
; this stacked connector (J16B) is connected to the Headset Left and Right outputs of the
; TWL6040 Audio Companion IC. For expansion purposes the left and right Hands-Free speaker
; outputs of the TWL6040 are connected to the Expansion Connector J6 [Pin 13,14,15,16].
;
; The OMAP4460 Pandaboard ES provides a stacked audio connector, which provides two 3.5 mm audio
; jack connections. The upper jack on this stacked connector (J16A) is connected to the
; FM Audio Left and Right inputs of the TWL6040 Audio Companion IC (AFML/AFMR). The lower jack
; on this stacked connector (J16B) is connected to the Headset Left and Right outputs of the
; TWL6040 Audio Companion IC. For expansion purposes the left Hands-Free speaker
; outputs of the TWL6040 are connected to the Expansion Connector J6 [Pin 13,15].
;


; Flag to enable gobs of debug output
                GBLL    AudioDebug
AudioDebug      SETL    {FALSE}
;AudioDebug     SETL    {TRUE}


; GPIO pin for activating power to TWL6040 audio chip
AUDIO_POWER_PIN         *       127
AUDIO_POWER_DELAY       *       (50*1024)       ; ~51 ms

; interrupt mask for use with McPDM downlink channel
MCPDM_IRQ_DN_MASK       *       (MCPDM_IRQ_DN_EMPTY + MCPDM_IRQ_DN_FULL)

; flag for using only supported sample rates
                GBLL    AllSampleRates
AllSampleRates  SETL    {FALSE}

; flag to enable mono to stereo switching for headset
; ATM just for testing: it doubles the playrate because the right channel gets the same value
;                       as the left channel
; ToDo: how to map lower sample rates to the supported ones (88.2 | 96 kHz)?
                GBLL    Mono2Stereo
Mono2Stereo     SETL    {TRUE} :LAND: AllSampleRates

; McPDM downlink channel mask
MCPDM_DL_CHANNELS       *       (MCPDM_CTRL_PDM_DN1_EN + MCPDM_CTRL_PDM_DN2_EN)

; special gain values for marking OFF state
HS_GAIN_OFF             *       &F0
HF_GAIN_OFF             *       &1F


Audio_Init
        Push    "v1-v4,lr"
  [ AudioDebug
        DebugTX "Audio_Init"
  ]
        ADRL    v1, AudioWS
        MOV     a1, v1
        ADR     a2, AudioTemplate
        MOV     a3, #Audio_DeviceSize
        BL      memcpy
        STR     sb, [v1, #:INDEX:AudioWorkspace]
        ; Get McPDM logical address
        LDR     v2, L4_ABE_Log
        ADD     v2, v2, #(L4_McPDM - L4_ABE)
        STR     v2, [v1, #:INDEX:AudioRegs]
  [ AudioDebug
        DebugReg v2, "McPDM @@ "
  ]

        ; Configure all PADs for McPDM and AUDIOPWRON pin
        LDR     a1, L4_Core_Log
        LDR     a2, =(L4_SYSCTRL_PADCONF_CORE - L4_Core)
        ADD     a1, a2, a1
        ADD     a1, a1, #0x100          ; add common offset
        MOV     a2, #0x03               ; output: Mode 3 (GPIO)
        STRH    a2, [a1, #0x020]        ; GPIO_127 at offset 0x120
        LDR     a2, =0x01080108         ; inputs: IEN + PTD + Mode 0
        LDR     a3, =0x0118             ; input:  IEN + PTU + Mode 0
        STRH    a2, [a1, #0x0006]       ; ABE_PDM_UL_DATA
        STRH    a2, [a1, #0x0008]       ; ABE_PDM_DL_DATA
        STRH    a3, [a1, #0x000A]       ; ABE_PDM_FRAME
        STR     a2, [a1, #0x000C]       ; ABE_PDM_LB_CLK + ABE_CLKS

        ; Before we go any further, enable module McPDM
        LDR     a1, L4_ClockMan_Log
        ADD     a1, a1, #CKGEN_CM1
        LDR     a2, [a1, #CM_CLKSEL_ABE]
        ORR     a2, a2, #(1 << 8)       ; PAD_CLOCKS_GATE
        STR     a2, [a1, #CM_CLKSEL_ABE]
        ADD     a1, a1, #(ABE_CM1 - CKGEN_CM1)
        MOV     a2, #2          ; enable module
        STR     a2, [a1, #CM1_ABE_PDM_CLKCTRL]
        LDR     a2, [a1, #CM1_ABE_CLKSTCTRL]
        BIC     a2, a2, #3      ; NO SLEEP
        STR     a2, [a1, #CM1_ABE_CLKSTCTRL]

        ; turn on the power for external audio chip (TWL6040)
        MOV     a1, #AUDIO_POWER_PIN
        MOV     a2, #1
        BL      GPIOx_SetAsOutput
        ; wait a bit
        LDR     a1, =AUDIO_POWER_DELAY
        BL      HAL_CounterDelay

        ; Set McPDM to reset state
        ; Perform full reset, in fact
        MOV     a1, #MCPDM_SYSCONFIG_SOFTRESET
        STR     a1, [v2, #MCPDM_SYSCONFIG]
10
        LDR     a1, [v2, #MCPDM_SYSCONFIG]
        TST     a1, #MCPDM_SYSCONFIG_SOFTRESET
        BNE     %BT10

        ; Set smart idle mode. No auto-idle available! :(
        MOV     a1, #MCPDM_SYSCONFIG_IDLEMODE_SMART
        STR     a1, [v2, #MCPDM_SYSCONFIG]
        MOV     v3, v2                          ; save ptr to PcPDM for later


        ; Now resume HAL device setup...

        ADD     v2, v1, #Audio_DeviceSize
        MOV     a1, v2
        ADR     a2, MixerTemplate
        MOV     a3, #Mixer_DeviceSize
        BL      memcpy

        ; Fill in pointers to each other
        STR     v1, [v2, #HALDevice_MixerCtrlr]
        STR     v2, [v1, #HALDevice_AudioMixer]

        LDRB    a1, [sb, #BoardConfig_MixerChans]
        STRB    a1, [v2, #:INDEX:MixerDisableFlags]
        ; Unavailable channels, and input channels, start muted
        ORR     a1, a1, #((1<<MixerChannel_HeadsetMic) + (1<<MixerChannel_AuxInput) + (1<<MixerChannel_MainMic))
        ADD     a2, v2, #:INDEX:MixerSettings
10      AND     a3, a1, #1
        MOVS    a1, a1, LSR #1
        STR     a3, [a2], #8
        BNE     %BT10

        ; Register devices
        MOV     a2, v1
        MOV     a1, #0
        CallOS  OS_AddDevice
        MOV     a2, v2
        MOV     a1, #0
        CallOS  OS_AddDevice


        ; allow registers to be accessed by i2c (only I2C, in fast mode)
        ; twl6040_write(codec, TWL6040_REG_ACCCTL, cache[TWL6040_REG_ACCCTL]);
        MOV     v4, v1                  ; save workspace ptr for later
        ADD     a2, v4, #:INDEX: AudioChipCache
        MOV     a4, #TWL6040_REG_ACCCTL
        ADD     a2, a2, a4
        MOV     a3, #(TWL6040_I2CSEL + TWL6040_INTCLRMODE + TWL6040_I2CMODE_FM)
        STRB    a3, [a2]
        MOV     a1, #TWL6040_IIC*2
        MOV     a3, #1
        LDR     v1, OSentries+4*OS_IICOpV
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT10
        DebugTX "Audio_Init: TWL6040_ACCCTL access failed!"
10
  ]

        ; now read all regs into our reg cache
        ADD     a2, v4, #:INDEX: AudioChipCache ; address our reg cache
        MOV     a4, #TWL6040_REG_ASICID
        ADD     a2, a2, a4                      ; start with first valid register
        MOV     a1, #TWL6040_IIC*2
        MOV     a3, #(TWL6040_REG_STATUS + 1 - TWL6040_REG_ASICID)
        LDR     v1, OSentries+4*OS_IICOpV
        BL      TPSRead
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT20
        DebugTX "Audio_Init: read of TWL6040 regs failed!"
20
  ]

        ; extract offsets from TWL6040_REG_HSOTRIM register and set McPDM offsets
        ADD     a2, v4, #:INDEX: AudioChipCache
        MOV     a4, #TWL6040_REG_HSOTRIM
        LDRB    a3, [a2, a4]
        MOV     a2, a3, LSR #4          ; extract HSF part
        AND     a3, a3, #TWL6040_HSLO   ; isolate HSL part
        CMP     a3, #7
        SUBHI   a3, a3, #16             ; sign correction
        AND     a3, a3, #0x1F           ; mask valid offset bits
        CMP     a2, #7
        SUBHI   a2, a2, #16             ; sign correction
        AND     a2, a2, #0x1F           ; mask valid offset bits
        MOV     a3, a3, LSL #1          ; shift into DN_OFST_RX1 field
        MOV     a2, a2, LSL #9          ; shift into DN_OFST_RX2 field
        ORR     a3, a3, #MCPDM_DN_OFFSET_DN_OFST_RX1_EN
        ORR     a2, a2, #MCPDM_DN_OFFSET_DN_OFST_RX2_EN
        ORR     a2, a3, a2
        STR     a2, [v3, #MCPDM_DN_OFFSET]
        ; configure downlink threshold (differentiate between OMAP4460 and OMAP4430)
        LDR     a1, L4_Core_Log
        ADD     a1, a1, #(L4_SYSCTRL_GENERAL_CORE - L4_Core)
        LDR     a2, [a1, #CONTROL_ID_CODE]
        UBFX    a1, a2, #12, #16        ; HAWKEYE field
        MOV     v1, #HAWKEYE_OMAP4460_ES10
        CMP     a1, v1
        MOVEQ   a2, #(8 - 1)
        MOVNE   a2, #1
        STR     a2, [v3, #MCPDM_FIFO_CTRL_DN]
        ; remember usable FIFO size
        MOVEQ   a2, #8
        MOVNE   a2, #16
        ADD     a3, v4, #:INDEX: AudioDMASize
        STRB    a2, [a3]

30

  [ AudioDebug
        DebugTX "Audio_Init done"
  ]
        Pull    "v1-v4,pc"




; Sample rate table
; The first 'reserved' byte is used to store the value that needs programming into the
; TWL6040 LPPLLCTL register, the second byte is used for 'mono --> stereo' flag (HSMN2ST)
; 'mono' means: R channel gets same value as L channel (==> double sample rate)

        GBLA    numrate
numrate SETA    0

        MACRO
$lab    cdf     $freq, $per, $m, $mode  ; CD-derived rate ($freq in Hz, since all integral)
$lab    DCD     $freq*1024              ; frequency value as reported by Sound_SampleRate
        DCB     $per                    ; period as reported via Sound_Configure
        DCB     $mode                   ; 0=TWL6040_LPLLFIN not set, sysclk=19200000
                                        ; 1=TWL6040_LPLLFIN     set, sysclk=17640000
        DCB     $m                      ; 1=HSMN2ST active, 0=HSMN2ST not active
        DCB     0                       ; padding to 8 bytes
numrate SETA    numrate+1
        MEND

        ASSERT  AudioRateTableSize = 8

; short forms for mode
MODE_1920       *       (TWL6040_LPLLENA + 0)
MODE_1764       *       (TWL6040_LPLLENA + TWL6040_LPLLFIN)

ratetab
  [ AllSampleRates
        cdf     8000, 125, 1, MODE_1920         ;  8kHz     (125us)  AC97/6
        cdf     11025, 91, 1, MODE_1764         ; 11.025kHz (~91 us) CD/4
        cdf     16000, 63, 1, MODE_1920         ; 16kHz     (~63 us) AC97/3
        cdf     22050, 45, 1, MODE_1764         ; 22.05kHz  (~45 us) CD/2
        cdf     32000, 31, 1, MODE_1920         ; 32kHz     (~31 us) AC97*2/3
  ] ; AllSampleRates
  [ {FALSE} ; these are not natively supported
        cdf     44100, 23, 1, MODE_1764         ; 44.1kHz   (~23 us) CD/1
        cdf     48000, 21, 1, MODE_1920         ; 48kHz     (~21 us) AC97/1
  ]
        cdf     88200, 11, 0, MODE_1764         ; 88.2kHz   (~11 us) CD*2
        cdf     96000, 10, 0, MODE_1920         ; 96kHz     (~10 us) AC97*2

; Audio controller HAL device

AudioTemplate
        DCW     HALDeviceType_Audio + HALDeviceAudio_AudC
        DCW     HALDeviceID_AudC_TWL6040
        DCD     HALDeviceBus_Ser + HALDeviceSerBus_IIC
        DCD     2:SHL:16        ; API version 2.0
        DCD     AudioDesc
        DCD     0               ; Address - N/A
        %       12              ; Reserved
        DCD     AudioActivate
        DCD     AudioDeactivate
        DCD     AudioReset
        DCD     AudioSleep
        DCD     AUDIO_IRQ       ; Device
        DCD     0               ; TestIRQ cannot be called
        %       8
        DCD     0               ; Filled in during init
        DCD     1               ; Output channels (supported so far)
        DCD     0               ; Input channels (supported so far)
        ASSERT  (.-AudioTemplate) = HALDevice_Audio_Size
        ; DMA channel parameters
        DCD     0               ; flags
        DCD     AUDIO_DMA_CHAN + 1              ; logical channel
        DCD     0                               ; 'cycle speed'
        DCD     2                               ; transfer unit size: 16 bit (2 byte)
        DCD     L4_McPDM + MCPDM_DN_DATA + 2    ; *physical* address to send data to
                                                ; use upper half word only (left aligned 24 bit)
        ; Enable/disable/IRQ routines
        DCD     PreEnable
        DCD     PostEnable
        DCD     PreDisable
        DCD     PostDisable
        DCD     IRQHandle
        DCD     numrate         ; Number of sample rates
        DCD     ratetab         ; Sample rate table
        DCD     AudioSetRate    ; SetRate function
        ; extra fields for API 2.0
        DCD     0               ; AudioCustomDMAEnable
        DCD     AudioFlag_StereoReverse       ; map R-L to L-R
        DCD     0               ; AudioMinBuffSize
        DCD     0               ; AudioBuffAlign
        ASSERT  (. - AudioTemplate) = HALDevice_Audio_Size_2
        DCD     0               ; AudioRegs: filled in during init
        DCD     0               ; AudioWorkspace: filled in during init
        DCB     0               ; AudioMode
        DCB     0               ; AudioMono
        DCB     0               ; AudioDMASize
        DCB     0               ; AudioChannels
        %       48              ; AudioChipCache
        ALIGN

        ASSERT  (. - AudioTemplate) = Audio_DeviceSize

; Mixer HAL device

MixerTemplate
        DCW     HALDeviceType_Audio + HALDeviceAudio_Mixer
        DCW     HALDeviceID_Mixer_TWL6040
        DCD     HALDeviceBus_Ser + HALDeviceSerBus_IIC
        DCD     1               ; API version
        DCD     MixerDesc
        DCD     0               ; Address - N/A
        %       12              ; Reserved
        DCD     MixerActivate
        DCD     MixerDeactivate
        DCD     MixerReset
        DCD     MixerSleep
        DCD     -1              ; Device
        DCD     0               ; TestIRQ cannot be called
        %       8
        DCD     0               ; Filled in during init
        DCD     MixerChannels
        DCD     MixerGetFeatures
        DCD     MixerSetMix
        DCD     MixerGetMix
        DCD     MixerGetMixLimits
        ASSERT  (.-MixerTemplate) = HALDevice_Mixer_Size + 4
        ; Default settings will be filled in during init
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCW     HS_GAIN_OFF     ; MixerHeadsetGain
        DCW     0               ; MixerEarphoneGain
        DCW     0               ; MixerHandsFreeGain
        DCW     0               ; MixerAuxOutputGain
        DCW     &1B             ; MixerSystemGain
        %       2
        ASSERT  (.-MixerTemplate) = Mixer_DeviceSize

AudioDesc
        =       "TWL6040-compatible audio controller", 0

MixerDesc
        =       "TWL6040-compatible audio mixer", 0
        ALIGN

AudioActivate
        ; TODO - Fix this!
        ; SoundDMA is higher up the module chain than SoundControl
        ; Which means we need the audio controller to do the mixer init, otherwise stuff might
        ; not work properly
        Entry   "v1,sb", 4
        ; Turn off codec, program mix params
        LDR     v1, [a1, #HALDevice_AudioMixer]
        ADD     v1, v1, #(:INDEX:MixerSettings)+8*MixerChannels
        MOV     a2, #MixerChannels-1
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "AudioActivate: Setting defaults"
  ]
        ADR     a3, ratetab
  [ AllSampleRates
        LDRB    a4, [a3, #(6*8+6)]
        LDRB    a3, [a3, #(6*8+5)]      ; use 48 kHz rate
  |
        LDRB    a4, [a3, #(1*8+6)]
        LDRB    a3, [a3, #(1*8+5)]      ; use 96 kHz rate
  ] ; AllSampleRates
        STRB    a4, AudioMono
        CMP     a4, #0
        MOVNE   a4, #(MCPDM_CTRL_PDM_DN1_EN)
        MOVEQ   a4, #(MCPDM_CTRL_PDM_DN1_EN + MCPDM_CTRL_PDM_DN2_EN)
        STRB    a4, AudioChannels
        STRB    a3, AudioMode
        BL      SetCodecMode
10      LDMDB   v1!,{a3-a4}
        BL      ReallySetMix
        SUBS    a2, a2, #1
        BGE     %BT10
        ; Finished!
        MOV     a1, #1
        EXIT

AudioDeactivate
        MOV     pc, lr

AudioReset
        MOV     pc, lr

AudioSleep
        MOV     a1, #0
        MOV     pc, lr

SetCodecMode
        ; Reprogram TWL6040_REG_LPPLLCTL from softcopy
        ; Assumes a1=audio device ptr, sb=HAL workspace
        Entry   "a1-a4,v1"

        ADR     a2, AudioMode
        MOV     a1, #TWL6040_IIC*2
        MOV     a3, #1
        MOV     a4, #TWL6040_REG_LPPLLCTL
        LDR     v1, OSentries+4*OS_IICOpV
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        EXIT    EQ
        DebugTX "SetCodecMode: TPS write failed!"
  ]
        EXIT

PreEnable
        ; a2 = DMA buffer length
        ; Use the buffer length to calculate a DMA packet size that fits in the FIFO.
        ; McPDM has at most 16 FIFO entries; 1 entry contains 2 channels (stereo)
        ; packet size is handled in element numbers
        LDR     a3, AudioWorkspace
        LDRB    a4, AudioMono
        CMP     a4, #0
        LDRB    a4, AudioDMASize
        MOVEQ   a4, a4, LSL #1  ; double it for stereo
        STR     a4, [a3, #:INDEX: DMAPktSz_Audio]
        MOV     pc, lr

PostEnable
        ; a2 = DMA buffer length
        ; This function is a mix of two things:
        ; The McPDM instance is initialised first, to allow the DMA to prefill the TX FIFO.
        ; The TWL6040 is then initialised afterwards.
        Entry   "v1-v2,sb"
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "PostEnable"
  ]
        Push    "a1"
        LDR     v1, AudioRegs
        LDRB    v2, AudioChannels

        ; set McPDM Downlink path to reset state
        ; omap_mcpdm_reset_playback(1)
        LDR     a1, [v1, #MCPDM_CTRL]
        ORR     a1, a1, #MCPDM_CTRL_SW_DN_RST
        STR     a1, [v1, #MCPDM_CTRL]

        ; omap_mcpdm_playback_open()
        ; clear any outstanding interrupt causes
        MOV     a1, #-1
        STR     a1, [v1, #MCPDM_IRQSTATUS]
        ; enable irq request generation
        MOV     a1, #MCPDM_IRQ_DN_MASK
        STR     a1, [v1, #MCPDM_IRQENABLE_SET]
        ; enable DMA request generation
        MOV     a1, #MCPDM_DMA_DN
        STR     a1, [v1, #MCPDM_DMAENABLE_SET]
        ; set PDM out format
;       LDR     a1, [v1, #MCPDM_CTRL]
;       BIC     a1, a1, #MCPDM_CTRL_PDMOUTFORMAT        ; left justified
;       STR     a1, [v1, #MCPDM_CTRL]

        ; release McPDM Downlink path from reset state
        ; omap_mcpdm_reset_playback(0)
        ; omap_mcpdm_start()
        ; enable playback channel
        LDR     a1, [v1, #MCPDM_CTRL]
        BIC     a1, a1, #MCPDM_CTRL_SW_DN_RST
        ORR     a1, a1, #MCPDM_CTRL_WD_EN
        ORR     a1, a1, v2                              ; activate our channels
        STR     a1, [v1, #MCPDM_CTRL]

        Pull    "a1"

        ; enable headset (if needed)
        LDRB    a3, AudioMono
        LDR     a1, [a1, #HALDevice_AudioMixer]
        LDR     a2, MixerSettings+MixerChannel_HeadsetOut*8
        TST     a2, #MixerMixFlag_Mute
        BLEQ    UpdateHeadset

        EXIT

PreDisable
        ; Disable the TWL6040, and then McPDM
        ; This should avoid unwanted underflow IRQs
        Entry   "v1,sb"
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "PreDisable"
  ]

        ; Disable headset output if required
        LDR     v1, [a1, #HALDevice_AudioMixer]
        LDR     a2, [v1, #:INDEX:MixerSettings+MixerChannel_HeadsetOut*8]
        ANDS    a2, a2, #MixerMixFlag_Mute
        BNE     %FT30
        MOV     a2, #HS_GAIN_OFF        ; mark it as OFF
        STRH    a2, [v1, #:INDEX:MixerHeadsetGain]
        Push    "a1"
        LDRB    a2, AudioMono
        CMP     a2, #0
        ADRNEL  a2, HeadsetDisableSequenceM
        ADREQL  a2, HeadsetDisableSequenceS
        MOV     a3, #1
        LDR     v1, OSentries+4*OS_IICOpV
10
        LDRB    a4, [a2],#1
        MOV     a1, #TWL6040_IIC*2
        CMP     a4, #0
        BEQ     %FT20
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT15
        DebugReg a4,"PreDisable: Write failed, reg="
15
  ]
        ADD     a2, a2, #1
        B       %BT10
20
        Pull    "a1"
30

        ; omap_mcpdm_stop()
        ; disable playback channel
        LDR     a2, AudioRegs
        LDR     a3, [a2, #MCPDM_CTRL]
        BIC     a3, a3, #MCPDM_DL_CHANNELS
        STR     a3, [a2, #MCPDM_CTRL]

        ; omap_mcpdm_playback_close()
        ; disable IRQ request generation
        MOV     a3, #MCPDM_IRQ_DN_MASK
        STR     a3, [a2, #MCPDM_IRQENABLE_CLR]
        ; disable DMA request generation
        MOV     a3, #MCPDM_DMA_DN
        STR     a3, [a2, #MCPDM_DMAENABLE_CLR]

        EXIT

PostDisable
        MOV     pc, lr

IRQHandle
  [ AudioDebug
        Push    "sb,lr"
        LDR     sb, AudioWorkspace
        LDR     a2, AudioRegs
        LDR     a2, [a2, #MCPDM_IRQSTATUS]
        DebugReg a2,"IRQHandle: IRQSTATUS="
        Pull    "sb,lr"
  ]
  [ {FALSE} ;{TRUE}
        ; Just clear the IRQ and ask for an audio reset
        LDR     a3, AudioRegs
        MVN     a2, #0
        ; Make sure we don't get bothered about this again - we can't guarantee when the OS
        ; will get round to resetting the audio, and could potentially get stuck in a loop
        ; if we allow the IRQ to keep firing
        STR     a2, [a3, #MCPDM_IRQENABLE_CLR]
        STR     a2, [a3, #MCPDM_IRQSTATUS]      ; clear all possible causes
        MOV     a1, #AudioIRQHandle_RequestReset
        MOV     pc, lr
  |
        ; restart the PDM channels and go on
        LDR     a3, AudioRegs
        LDR     a2, [a3, #MCPDM_IRQSTATUS]
        STR     a2, [a3, #MCPDM_IRQSTATUS]      ; clear interrupt causes
        LDR     a2, [a3, #MCPDM_CTRL]
        BIC     a2, a2, #MCPDM_DL_CHANNELS
        ORR     a2, a2, #MCPDM_CTRL_SW_DN_RST   ; reset downlink path
        STR     a2, [a3, #MCPDM_CTRL]
        BIC     a2, a2, #MCPDM_CTRL_SW_DN_RST   ; release reset
        STR     a2, [a3, #MCPDM_CTRL]
        ; prepare some data in FIFO (to avoid underflow)
        MOV     a2, #0
        STR     a2, [a3, #MCPDM_DN_DATA]
        STR     a2, [a3, #MCPDM_DN_DATA]
        LDR     a2, [a3, #MCPDM_CTRL]
        LDRB    a1, AudioChannels
        ORR     a2, a2, a1                      ; reenable channels
        STR     a2, [a3, #MCPDM_CTRL]
        MOV     a1, #AudioIRQHandle_NOP
        MOV     pc, lr
  ]

AudioSetRate
        ; a2 = sample rate index (0-based)
        Entry   "sb"
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugReg a2, "AudioSetRate: "
  ]
        ; Reload TWL6040_REG_LPPLLCTL with the required value
        ADRL    a3, ratetab
        ASSERT  AudioRateTableSize = 8
        ADD     a3, a3, a2, LSL #3
        LDRB    a4, [a3, #6]
        LDRB    a3, [a3, #5]
        STRB    a4, AudioMono
        CMP     a4, #0
        MOVNE   a4, #(MCPDM_CTRL_PDM_DN1_EN)
        MOVEQ   a4, #(MCPDM_CTRL_PDM_DN1_EN + MCPDM_CTRL_PDM_DN2_EN)
        STRB    a4, AudioChannels
        STRB    a3, AudioMode
        BL      SetCodecMode
        EXIT

MixerActivate
        MOV     a1, #1

MixerDeactivate
        MOV     pc, lr

MixerReset
        Entry   "v1,sb", 4
        ; program default mix params
        ADR     v1, MixerSettings+8*MixerChannels
        LDR     a1, [a1, #HALDevice_MixerCtrlr]
        MOV     a2, #MixerChannels-1
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "MixerReset: Setting defaults"
  ]
10      LDMDB   v1!,{a3-a4}
        BL      ReallySetMix
        SUBS    a2, a2, #1
        BGE     %BT10
        EXIT

MixerSleep
        ; TODO?
        MOV     a1, #0
        MOV     pc, lr

MixerGetFeatures
        ; Check if this channel is disabled and needs the 'fixed' flag
        MOV     a4, #1
        LDRB    a3, MixerDisableFlags
        TST     a3, a4, LSL a2
        ADR     a1, MixerFeaturesTab
        LDR     a1, [a1, a2, LSL #2]
        ORRNE   a1, a1, #MixerFeaturesFlag_Fixed
        MOV     pc, lr

MixerFeaturesTab
        ; Stereo headset output
        DCW     0
        DCW     MixerCategory_Headphones
        ; Mono earphone output
        DCW     MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_Speaker
        ; Stereo hands-free output
        DCW     MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_LineOut
        ; Stereo FM/aux output
        DCW     MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_AuxOut
        ; System audio
        DCW     0
        DCW     MixerCategory_System
        ; Stereo headset mic
        DCW     MixerFeaturesFlag_Mono :OR: MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_Mic
        ; Stereo FM/aux input
        DCW     MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_LineIn
        ; Mono main mic
        DCW     MixerFeaturesFlag_Mono :OR: MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_AuxIn

; MixerDevice API v0.1
MixerGetMixLimits
        ADR     a1, MixerLimitsTab
        ADD     a1, a1, a2, LSL #3
        ADD     a1, a1, a2, LSL #2
        LDMIA   a1, {a1, a2, a4}
        STMIA   a3, {a1, a2, a4}
        MOV     pc, lr

MixerLimitsTab
        ; Stereo headset output
        DCD     -30*16
        DCD     0
        DCD     2*16
        ; Mono speaker output
        DCD     -24*16
        DCD     6*16
        DCD     2*16
        ; Stereo hands-free output
        DCD     -52*16
        DCD     6*16
        DCD     2*16
        ; Stereo FM/aux output
        DCD     -52*16
        DCD     6*16
        DCD     2*16
        ; System audio
        DCD     -18*16
        DCD     24*16
        DCD     6*16
        ; Stereo headset mic
        DCD     6*16
        DCD     30*16
        DCD     6*16
        ; Stereo FM/aux input
        DCD     6*16
        DCD     30*16
        DCD     6*16
        ; Mono main mic
        DCD     6*16
        DCD     30*16
        DCD     6*16

MixerSetMix
        ; a1 = mixer device
        ; a2 = channel
        ; a3 = mute flag
        ; a4 = gain, in dB*16
        Entry   "v1"
        ; Double-check that we aren't being asked to program a disabled channel
        ; Although ReallySetMix will do another check, we must check here to make sure we don't
        ; update the stored settings (particularly the headset settings, which UpdateHeadset
        ; treats as gospel)
        MOV     ip, #1
        LDRB    v1, MixerDisableFlags
        TST     v1, ip, LSL a2
        EXIT    NE
        ADR     v1, MixerSettings
        ADD     v1, v1, a2, LSL #3
        LDMIA   v1, {ip, lr}
        TEQ     a3, ip
        TEQEQ   a4, lr
        STMNEIA v1, {a3, a4}
        LDRNE   a1, [a1, #HALDevice_MixerCtrlr]
        BLNE    ReallySetMix
        EXIT

ReallySetMix
        ; a1 = *audio* device
        ; a2-a4 as above
        ; Preserves all regs
        ; Channel gain & mute control can't easily be abstracted, need to do it on a
        ; case-by-case basis :(
        ; Common code to get ready for IIC transfers
        Entry   "a1-a4,v1-v5,sb,v7"
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "ReallySetMix:"
        DebugReg a2,"Channel="
        DebugReg a3,"Mute="
        DebugReg a4,"Gain="
  ]
        ; Triple-check that we aren't being asked to program a disabled channel
        ; (ReallySetMix gets called unconditionally in a few places; easier to just check for
        ; invalid channels here rather than in every place it gets called from)
        LDRB    v5, [sb, #BoardConfig_MixerChans]
        MOV     v2, #1
        TST     v5, v2, LSL a2
        EXIT    NE
        LDR     v5, [a1, #HALDevice_AudioMixer]
        MOV     v2, a3
;       LDRB    v4, AudioMode
        LDRB    v4, AudioMono
        ADD     v7, v5, #:INDEX: MixerSettings+4
        LDR     v1, OSentries+4*OS_IICOpV
        MOV     a1, #TWL6040_IIC*2
        ADD     v7, v7, a2, LSL #3
        ADR     a3, SetMixTab
        MOV     v3, a4
        LDR     pc, [a3, a2, LSL #2]
        ; Following code entered with:
        ; a1, v1 ready for TPSRead/TPSWrite
        ; v2 = mute flag
        ; v3 = gain
        ; v4 = current AudioMono setting
        ; v5 = mixer device
        ; sb = HAL WS
        ; v7 = gain writeback ptr
SetMixTab
        DCD     SetMixHeadsetOut
        DCD     SetMixEarphone
        DCD     SetMixHandsFree
        DCD     SetMixAuxOutput
        DCD     SetMixSystem
        DCD     SetMixHeadsetMic
        DCD     SetMixAuxInput
        DCD     SetMixMainMic

SetMixHeadsetOut ; HS_* regs
        ; Go through to UpdateHeadset
        MOV     a3, v4
        MOV     a1, v5
        BL      UpdateHeadset
        EXIT

SetMixEarphone ; TWL6040 has no predriver regs ==> use earphone instead
        ; Calculate EARGAIN: 0x0 == 6 dB, 0x1 == 4 dB, 0x2 == 2 dB ... 0xF == -24dB
        TST     v2, #MixerMixFlag_Mute
        MOVNE   v4, #0                  ; disable everything
        BNE     %FT10
        ; limit gain to allowed range
        CMP     v3, #-24*16
        LDRLT   v3, =(-24*16)
        CMP     v3, #6*16
        MOVGT   v3, #6*16
        ; calculate gain value
        MOV     lr, v3, ASR #(4+1)      ; div by step width (2 dB)
        RSB     v4, lr, #3              ; negate at zero point
        MOV     v4, v4, LSL #1          ; shift into EARGAIN position
        STR     v3, [v7]                ; remember used gain value
        ORR     v4, v4, #TWL6040_EARENA ; enable it
10
        ADD     a2, v5, #:INDEX:MixerEarphoneGain
        LDRH    ip, [a2]
        CMP     ip, v4
        EXIT    EQ
        STRH    v4, [a2]
        MOV     a3, #1
        MOV     a4, #TWL6040_REG_EARCTL
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #0
        EXIT    EQ
        DebugTX "SetMixEarphone: TPS write failed!"
  ]
        EXIT

SetMixHandsFree ; HF* regs
        ; Go through to UpdateHandsFree
        MOV     a1, v5
        BL      UpdateHandsFree
        EXIT


SetMixAuxOutput
        ; Aux Output path has no separate control registers in TWL6040
        ; it is internally connected to handsfree path
        B       SetMixHandsFree

SetMixSystem
        ; there is no such thing for output in TWL6040
        ; there is only a general LINEGAIN for input paths
        ; Calculate LINEGAIN (L|R): 0x0 == -18 dB, 0x1 == -12 dB, ... 0x7 == +24 dB
        ; range mapping: [-18 dB .. +24 dB]
        ; mapping: fScale = (1 / 6) = 0.166.. ~ 2370 [ * 2^14]
        ; "/ 6" for step width of 6 dB
        TST     v2, #MixerMixFlag_Mute
        MOVNE   v4, #0                  ; disable everything
        BNE     %FT10
        ; limit gain to allowed range
        CMP     v3, #-18*16
        LDRLT   v3, =(-18*16)
        CMP     v3, #24*16
        MOVGT   v3, #24*16
        STR     v3, [v7]                ; remember used gain value
        ; calculate scaled gain value
        CMP     v3, #0
        ADDGT   v3, v3, #1              ; compensate for rounding errors
        MOV     a3, #2370               ; == fScale
        MUL     a3, v3, a3
        MOV     a3, a3, ASR #(14+4)     ; div by (16 * 2^14)
        ADD     a3, a3, #3              ; add 0 dB offset
        AND     v4, a3, #TWL6040_LINEGAINL      ; only relevant bits
        ORR     v4, v4, v4, LSL #3      ; fold into LINEGAINR
10
        ADD     a2, v5, #:INDEX:MixerSystemGain
        LDRH    ip, [a2]
        CMP     ip, v4
        EXIT    EQ
        MOV     a3, #1
        STRH    v4, [a2]
        MOV     a4, #TWL6040_REG_LINEGAIN
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #0
        EXIT    EQ
        DebugTX "SetMixSystem: TPS write failed!"
  ]
        EXIT

SetMixHeadsetMic ; TODO - Implement!
SetMixAuxInput ; TODO - Implement!
SetMixMainMic ; TODO - Implement!
        EXIT

MixerGetMix
        ADR     a1, MixerSettings
        ADD     a1, a1, a2, LSL #3
        LDMIA   a1, {a1, a2}
        MOV     pc, lr

UpdateHeadset
        ; This performs the steps necessary to enable/disable the headset output
        ; Input:
        ; a1 = mixer device
        ; a3 = AudioMono flag
        ; sb = HAL workspace
        Entry   "a1-a4,v1", 12

        ; Get mixer settings for headset
        ADR     ip, MixerSettings+MixerChannel_HeadsetOut*8
        LDMIA   ip, {a4,v1}     ; a4 = mute flag, v1 = gain
        TST     a4, #MixerMixFlag_Mute
        BEQ     %FT02
        CMP     a3, #0
        ADRNE   a2, HeadsetDisableSequenceM ; Muted, so disable it
        ADREQ   a2, HeadsetDisableSequenceS ; Muted, so disable it
        MOV     ip, #0
        B       %FT05
02
        ; limit gain to allowed range
        CMP     v1, #-30*16
        LDRLT   v1, =(-30*16)
        CMP     v1, #0
        MOVGT   v1, #0
        ; Calculate HSGAIN: 0x0 == 0 dB, 0x1 == -2 dB, ... 0xF == -30dB
        MOV     a2, v1, ASR #(4+1)      ; div by step width (2 dB)
        RSB     ip, a2, #0              ; negate
        ORR     ip, ip, ip, LSL #4      ; fold it into HSGAINR
        ; Copy enable sequence to stack so we can modify it with the correct gain
        CMP     a3, #0
        ADRNE   a3, HeadsetEnableSequenceM
        ADREQ   a3, HeadsetEnableSequenceS
        MOV     a2, sp
        LDRH    v1, MixerHeadsetGain
        CMP     v1, #HS_GAIN_OFF        ; Is the headset currently turned off?
        LDMIA   a3, {a3,a4,v1}
        ORR     a4, a4, ip, LSL #8      ; Set correct gain
        STMEQIA a2, {a3,a4,v1}          ; Full programming sequence if headset off
        MOVNE   a4, a4, LSL #16         ; If headset on, only change HSGAIN
        MOVNE   a4, a4, LSR #16
        STRNE   a4, [a2]
05
        ; a2 = sequence to program
        ; ip = HSGAIN value
        LDRH    v1, MixerHeadsetGain
  [ AudioDebug
        DebugReg ip,"UpdateHeadset: New="
        DebugReg v1,"Old="
  ]
        CMP     v1, ip
        EXIT    EQ              ; Avoid reprogramming identical values
        STRH    ip, MixerHeadsetGain
        MOV     a3, #1
        LDR     v1, OSentries+4*OS_IICOpV
10
        LDRB    a4, [a2],#1
        MOV     a1, #TWL6040_IIC*2
        CMP     a4, #0
        EXIT    EQ
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT15
        DebugReg a4,"UpdateHeadset: Write failed, reg="
15
  ]
        ADD     a2, a2, #1
        B       %BT10

HeadsetEnableSequenceM
        DCB     TWL6040_REG_HSLCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSRCTL, &AB ; DAC ON + HSMN2ST
        DCB     TWL6040_REG_HSGAIN, 0   ; this gets filled in above
        DCB     TWL6040_REG_HSLCTL, &2F ; DAC + Driver ON
        DCB     TWL6040_REG_HSRCTL, &AF ; DAC + Driver ON + HSMN2ST
        DCB     0       ; Terminator
        ALIGN

HeadsetEnableSequenceS
        DCB     TWL6040_REG_HSLCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSRCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSGAIN, 0   ; this gets filled in above
        DCB     TWL6040_REG_HSLCTL, &2F ; DAC + Driver ON
        DCB     TWL6040_REG_HSRCTL, &2F ; DAC + Driver ON
        DCB     0       ; Terminator
        ALIGN

HeadsetDisableSequenceM
        DCB     TWL6040_REG_HSLCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSRCTL, &AB ; DAC ON + HSMN2ST
        DCB     TWL6040_REG_HSGAIN, HS_GAIN_OFF ; special value for marking OFF
        DCB     0       ; Terminator
        ALIGN

HeadsetDisableSequenceS
        DCB     TWL6040_REG_HSLCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSRCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSGAIN, HS_GAIN_OFF ; special value for marking OFF
        DCB     0       ; Terminator
        ALIGN


UpdateHandsFree
        ; This performs the steps necessary to enable/disable the hands-free output
        ; Input:
        ; a1 = mixer device
        ; sb = HAL workspace
        Entry   "a1-a4,v1", 16

        ; Get mixer settings for headset
        ADR     ip, MixerSettings+MixerChannel_HandsFree*8
        LDMIA   ip, {a4,v1}     ; a4 = mute flag, v1 = gain
        TST     a4, #MixerMixFlag_Mute
        ADRNE   a2, HandsFreeDisableSequence ; Muted, so disable it
        MOVNE   ip, #0
        BNE     %FT05
        ; gain is in HFLGAIN and HFRGAIN each with the following values:
        ; 0x00 == 6 dB, 0x01 == 4 dB, 0x02 == 2 dB, 0x03 == 0 dB, 0x04 == -2 dB,
        ; ... 0x1C == -50 dB, 0x1D == -52 dB  (0x1E and 0x1F not valid)
        ; limit gain to allowed range
        CMP     v1, #-52*16
        LDRLT   v1, =(-52*16)
        CMP     v1, #6*16
        MOVGT   v1, #6*16
        ; calculate gain value
        MOV     a3, v1, ASR #(4+1)      ; div by step width (2 dB)
        RSB     ip, a3, #3              ; negate at zero point
        ; Copy enable sequence to stack so we can modify it with the correct gain
        ADR     a3, HandsFreeEnableSequence
        MOV     a2, sp
        LDRH    v1, MixerHandsFreeGain
        CMP     v1, #HF_GAIN_OFF        ; Is the hands-free currently turned off?
        LDMIA   a3, {a3,a4,v1}
        ORR     a4, a4, ip, LSL #8      ; Set correct gain HFLGAIN
        ORR     a4, a4, ip, LSL #24     ; Set correct gain HFRGAIN
        STMEQIA a2, {a3,a4,v1}          ; Full programming sequence if hands-free off
        STRNE   a4, [a2]                ; If hands-free on, only change HFxGAIN
        MOV     a4, #0                  ; terminate sequence with 0
        STRNE   a4, [a2, #4]
        STREQ   a4, [a2, #3*4]
05
        ; a2 = sequence to program
        ; ip = HFxGAIN value
        LDRH    v1, MixerHandsFreeGain
  [ AudioDebug
        DebugReg ip,"UpdateHandsFree: New="
        DebugReg v1,"Old="
  ]
        CMP     v1, ip
        EXIT    EQ              ; Avoid reprogramming identical values
        STRH    ip, MixerHandsFreeGain
        MOV     a3, #1
        LDR     v1, OSentries+4*OS_IICOpV
10
        LDRB    a4, [a2],#1
        MOV     a1, #TWL6040_IIC*2
        CMP     a4, #0
        EXIT    EQ
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT15
        DebugReg a4,"UpdateHandsFree: Write failed, reg="
15
  ]
        ADD     a2, a2, #1
        B       %BT10

HandsFreeEnableSequence
        DCB     TWL6040_REG_HFLCTL, &07 ; DAC ON
  [ Mono2Stereo
        DCB     TWL6040_REG_HFRCTL, &27 ; DAC ON + HFMN2ST
  |
        DCB     TWL6040_REG_HFRCTL, &07 ; DAC ON
  ] ; Mono2Stereo
        DCB     TWL6040_REG_HFLGAIN, 0  ; this gets filled in above
        DCB     TWL6040_REG_HFRGAIN, 0  ; this gets filled in above
        DCB     TWL6040_REG_HFLCTL, &17 ; DAC + Driver ON
  [ Mono2Stereo
        DCB     TWL6040_REG_HFRCTL, &37 ; DAC + Driver ON + HFMN2ST
  |
        DCB     TWL6040_REG_HFRCTL, &17 ; DAC + Driver ON
  ] ; Mono2Stereo
        DCB     0       ; Terminator
        ALIGN

HandsFreeDisableSequence
        DCB     TWL6040_REG_HFLCTL, &07 ; DAC ON
  [ Mono2Stereo
        DCB     TWL6040_REG_HFRCTL, &27 ; DAC ON + HFMN2ST
  |
        DCB     TWL6040_REG_HFRCTL, &07 ; DAC ON
  ] ; Mono2Stereo
        DCB     TWL6040_REG_HFLGAIN, &1D        ; nearly mute
        DCB     TWL6040_REG_HFRGAIN, &1D        ; nearly mute
        DCB     0       ; Terminator
        ALIGN


        END
@


1.13
log
@Build fix
Updated for Sound0HAL-1_80.

Version 0.43. Tagged as 'OMAP4-0_43'
@
text
@a42 2
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
@


1.11
log
@Add support for recent U-Boot versions
Detail:
  hdr/PRCM:
  - added further definitions (not listed in older TRMs)
  s/Audio:
  - configure all GPIO pads used by audio system
    (for supporting latest U-Boot 2014-7)
  s/Boot:
  - added overflow check for address range
  s/RAM:
  - added overflow check for address range
  - address comparison with unsigned arithmetic
  s/RTC:
  - added initialisation code and pad configuration for TWL6030 RTC
    (for supporting latest U-Boot 2014-07)
  s/SDIO:
  - added pad configuration for LEDs used by SDIO
    (for supporting latest U-Boot 2014-07)
  s/USB:
  - removed unused code parts
  - use defines for controller types
  s/Video:
  - added pad configuration for DVI framer pin
  - enable DSS power and clock domain and DSS specific clocks
  - activate thermal sensor clock
  - wait for activated module in VideoDevice_Activate
    (for supporting latest U-Boot 2014-07)
Admin:
  Submission from Willi Theiss
  Tested on Panda ES rev B3 (Willi), Panda rev A6 (myself)


Version 0.36. Tagged as 'OMAP4-0_36'
@
text
@d401 1
a401 1
        ASSERT  HALDevice_AudioRateTableSize = 8
d461 1
a461 1
        DCD     HALDevice_AudioFlag_StereoReverse       ; map R-L to L-R
d737 1
a737 1
        MOV     a1, #1
d758 1
a758 1
        MOV     a1, #0
d771 1
a771 1
        ASSERT  HALDevice_AudioRateTableSize = 8
@


1.10
log
@Improvements to audio FIFOing
hdr/Audio: split AudioChannels to allow new AudioDMASize field to differentiate OMAP4430 v 4460.
Audio.s: handle FIFO underflow events of the audio stream, differentiate FIFO sizes for OMAP4430 v 4460.
SDMA.s: add prefetch flag in DMA control for audio channel
Submission from Willi Theiss.

Version 0.34. Tagged as 'OMAP4-0_34'
@
text
@d223 14
d728 1
a728 1
  [ {FALSE}
@


1.9
log
@Delete a few bits of trial code
Retagged as OMAP4-0_26.
@
text
@d183 1
a183 2
;MCPDM_IRQ_DN_MASK      *       (MCPDM_IRQ_DN_EMPTY + MCPDM_IRQ_DN_FULL)
MCPDM_IRQ_DN_MASK       *       (MCPDM_IRQ_DN_FULL)
d342 9
a350 2
        ; configure downlink threshold
        MOV     a2, #(8 - 1)
d352 5
d455 2
a456 1
        DCW     0               ; AudioChannels
d536 1
a536 1
        STRH    a4, AudioChannels
a580 2
; remark: setting threshold to 1 and using all FIFO entries does not work on OMAP4460
;         it works on OMAP4430 (better than everything else)
d583 2
a584 2
        MOVEQ   a4, #(8 * 2)    ; stereo mode
        MOVNE   a4, #(8 * 1)    ; mono mode (R is copy of L)
d600 1
a600 1
        LDRH    v2, AudioChannels
d714 1
a714 1
  [ {TRUE} ;{FALSE}
d734 8
a741 1
        LDRH    a1, AudioChannels
a743 2
        BIC     a2, a2, #MCPDM_CTRL_SW_DN_RST   ; release reset
        STR     a2, [a3, #MCPDM_CTRL]
d765 1
a765 1
        STRH    a4, AudioChannels
@


1.8
log
@Change audio device to API v2.0
For stereo reversal.
Comment corrections and extensions.
Added range check to gain controls.
Submission from Willi Theiss, built but not tested here.

Version 0.26. Tagged as 'OMAP4-0_26'
@
text
@a343 1
  [ {TRUE}
a344 5
;       MOV     a2, #(8 - 2)
  |
;       MOV     a2, #1                  ; this does work with OMAP4430 but not OMAP4460
        MOV     a2, #3
  ]
@


1.7
log
@Refactor IIC calls to use RISCOS_IICOpV
Copy changes from OMAP3-0_90 to OMAP4.
Built, but not tested.

Version 0.23. Tagged as 'OMAP4-0_23'
@
text
@d154 16
a169 3
; For the pandaboard, the TWL6040 is connected to the OMAP4 via I2C1 & McPDM
; The audio out header is connected to the headset L/R channels on the TWL
; The audio in header is connected to the aux L/R channels on the TWL
d344 7
a350 2
;       MOV     a2, #1                  ; this does work with OMAP4430 bot not OMAP4460
        MOV     a2, #(8 - 2)
d409 1
a409 1
        DCD     1:SHL:16        ; API version
d425 1
a425 1
        DCD     0 ; flags
d440 6
a445 1
        ASSERT  (. - AudioTemplate) = HALDevice_Audio_Size_1
d943 1
a943 5
        ; If the codec is on, go through to UpdateHeadset
        ; Else do nothing
;       TST     v4, #TWL6040_LPLLENA
;       MOVNE   a1, v5
;       BLNE    UpdateHeadset
d954 5
d982 3
a984 5
        ; If the codec is on, go through to UpdateHandsFree
        ; Else do nothing
        TST     v4, #TWL6040_LPLLENA
        MOVNE   a1, v5
        BLNE    UpdateHandsFree
d988 1
a988 3
SetMixAuxOutput ; PRECK* regs
  [ {FALSE}
        ; adapt for TWL6040 !?
d991 1
a991 24

        MOV     a3, #2
        MOV     a4, #PRECKL_CTL
        MOV     v4, #&64 ; 0dB gain, AL2
        CMP     v3, #6*16
        MOVGE   v4, #&54 ; 6dB gain, AL2
        CMP     v3, #-6*16
        MOVLE   v4, #&74 ; -6dB gain, AL2
        TST     v2, #MixerMixFlag_Mute
        ORREQ   v4, v4, v4, LSL #8 ; R channel settings
        MOVNE   v4, #0 ; Else disable everything
        ADD     a2, v5, #:INDEX:MixerCarkitOutGain
        LDRH    ip, [a2]
        CMP     ip, v4
        EXIT    EQ
        STRH    v4, [a2]
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #0
        EXIT    EQ
        DebugTX "SetMixAuxOutput: TPS write failed!"
  ]
  ]
        EXIT
d1003 5
d1064 5
d1164 6
@


1.6
log
@Changes for OMAP4 HAL
hdr/GPIO: aligned columns
hdr/USB: added more USB related register definitions (OTG and USBPHY)
hdr/Video: global variable for preventing multiple inclusion renamed to its original
hdr/irqs44xx: interrupt numbers and naming according to latest OMAP44xx TRMs
hdr/omap4430: address correction for L4_USBPHY
s/Audio:
    changed recovering from error conditions
    disabled kludge for supporting non native samplerates (44.1 + 48k)
s/PRCM:
    removed unused function PRCM_GetFreqSel and related table
s/SDIO
    aligned columns
s/USB
    name change for OTG interrupt source

Part of a number of changes from Willi Theiss.
Build, but not tested.

Version 0.14. Tagged as 'OMAP4-0_14'
@
text
@a48 7
        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND

@


1.5
log
@Refactor HAL_VideoIICOp to be ATPCS
No longer specified to return _kernel_oserror * implements GraphicsV 14.
Make use of IICStatus defines instead of local copies.
Rename HAL_Video_ to HAL_Video.
Compiles, but not tested.


Version 0.11. Tagged as 'OMAP4-0_11'
@
text
@d180 4
d189 1
a189 1
Mono2Stereo     SETL    {TRUE}
a193 4
; flag for using only supported sample rates
                GBLL    AllSampleRates
AllSampleRates  SETL    {FALSE}

d385 1
d388 1
d508 1
a508 1
        LDRB    a3, [a3, #(1*8+5)]      ; use 48 kHz rate
d694 1
a694 1
  [ {FALSE}
@


1.4
log
@Bulk expand of tabs.
Helps to make tracking changes between OMAP3 and OMAP4 less eye watering, but otherwise functionally the same as 0.06.

Version 0.07. Tagged as 'OMAP4-0_07'
@
text
@d298 1
a298 1
        CMP     a1, #ECOMPLETED
d313 1
a313 1
        CMP     a1, #ECOMPLETED
d545 1
a545 1
        CMP     a1, #ECOMPLETED
d652 1
a652 1
        CMP     a1, #ECOMPLETED
d1104 1
a1104 1
        CMP     a1, #ECOMPLETED
d1197 1
a1197 1
        CMP     a1, #ECOMPLETED
@


1.3
log
@Updates to OMAP4 port.
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.Audio
    changes for better sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.omap4430
    added DebugTiming macros
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.StaticWS
    added variable NVMemoryFound
    removed variables for NVRAM over SD card support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Audio
    changes for better sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.board
    adjusted max pixel-clock rate
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Boot
    added debug timing
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.KdbScan
    added debug timing
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.NVMemory
    EEPROM support over JTAG port (EMU0/EMU1)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.RAM
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Top
    use DMA for copying ROM at top of RAM
    added debug timing
    support for compressed images (as in OMAP3)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Video
    added debug timing OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.c.CLib
    reverted to version without SD card NVRAM support

Changes from Willi Theiss.
Assembles without errors, but not tested here.

Version 0.06. Tagged as 'OMAP4-0_06'
@
text
@d16 39
a54 39
	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:Machine.<Machine>
	GET	Hdr:ImageSize.<ImageSize>
	$GetIO

	GET	Hdr:OSEntries
	GET	Hdr:HALEntries
	GET	Hdr:HALDevice
	GET	Hdr:AudioDevice
	GET	Hdr:MixerDevice
	GET	Hdr:Proc

	GET	hdr.omap4430
	GET	hdr.StaticWS
	GET	hdr.PRCM
	GET	hdr.GPIO

	AREA	|Asm$$Code|, CODE, READONLY, PIC

	EXPORT	Audio_Init

	IMPORT	TPSRead
	IMPORT	TPSWrite

	IMPORT	memcpy
	IMPORT	DebugHALPrint
	IMPORT	DebugHALPrintReg
	IMPORT	HAL_IRQClear
	IMPORT	HAL_CounterDelay
	IMPORT	GPIOx_SetAsOutput

	MACRO
	CallOS	$entry
	ASSERT	$entry <= HighestOSEntry
	MOV	lr, pc
	LDR	pc, OSentries + 4*$entry
	MEND
d106 10
a115 10
; Output port	DL0	DL1	DL2	DL3	DL4	I2C or frame(3)	AFM0	AFM1
; Earphone	X(1)
; Left Headset	X							X
; Right Headset	X	X							X
; Left HF			X					X
; Right HF			X	X					X
; Left Aux			X(2)					X
; Right Aux			X(2)	X(2)					X
; Left Vibr.					X	X
; Right Vibr.					X	X
d126 6
a131 6
; Input port		UL0	UL1	AFM0	AFM1
; Main Microphone, MMIC	X
; Sub Microphone, SMIC		X
; Headset Micro, HSMIC	X	X
; Left Aux/FM radio	X		X
; Right Aux/FM radio		X		X
d167 3
a169 3
		GBLL	AudioDebug
AudioDebug	SETL	{FALSE}
;AudioDebug	SETL	{TRUE}
d173 2
a174 2
AUDIO_POWER_PIN		*	127
AUDIO_POWER_DELAY	*	(50*1024)	; ~51 ms
d177 2
a178 2
;MCPDM_IRQ_DN_MASK	*	(MCPDM_IRQ_DN_EMPTY + MCPDM_IRQ_DN_FULL)
MCPDM_IRQ_DN_MASK	*	(MCPDM_IRQ_DN_FULL)
d182 1
a182 1
;			as the left channel
d184 2
a185 3
		GBLL	Mono2Stero
;Mono2Stero	SETL	{FALSE}
Mono2Stero	SETL	{TRUE}
d188 1
a188 1
MCPDM_DL_CHANNELS	*	(MCPDM_CTRL_PDM_DN1_EN + MCPDM_CTRL_PDM_DN2_EN)
d191 2
a192 2
		GBLL	AllSampleRates
AllSampleRates	SETL	{FALSE}
d195 2
a196 2
HS_GAIN_OFF		*	&F0
HF_GAIN_OFF		*	&1F
d200 1
a200 1
	Push	"v1-v4,lr"
d202 1
a202 1
	DebugTX "Audio_Init"
d204 39
a242 39
	ADRL	v1, AudioWS
	MOV	a1, v1
	ADR	a2, AudioTemplate
	MOV	a3, #Audio_DeviceSize
	BL	memcpy
	STR	sb, [v1, #:INDEX:AudioWorkspace]
	; Get McPDM logical address
	LDR	v2, L4_ABE_Log
	ADD	v2, v2, #(L4_McPDM - L4_ABE)
	STR	v2, [v1, #:INDEX:AudioRegs]
  [ AudioDebug
	DebugReg v2, "McPDM @@ "
  ]

	; Before we go any further, enable module McPDM
	LDR	a1, L4_ClockMan_Log
	ADD	a1, a1, #CKGEN_CM1
	LDR	a2, [a1, #CM_CLKSEL_ABE]
	ORR	a2, a2, #(1 << 8)	; PAD_CLOCKS_GATE
	STR	a2, [a1, #CM_CLKSEL_ABE]
	ADD	a1, a1, #(ABE_CM1 - CKGEN_CM1)
	MOV	a2, #2		; enable module
	STR	a2, [a1, #CM1_ABE_PDM_CLKCTRL]
	LDR	a2, [a1, #CM1_ABE_CLKSTCTRL]
	BIC	a2, a2, #3	; NO SLEEP
	STR	a2, [a1, #CM1_ABE_CLKSTCTRL]

	; turn on the power for external audio chip (TWL6040)
	MOV	a1, #AUDIO_POWER_PIN
	MOV	a2, #1
	BL	GPIOx_SetAsOutput
	; wait a bit
	LDR	a1, =AUDIO_POWER_DELAY
	BL	HAL_CounterDelay

	; Set McPDM to reset state
	; Perform full reset, in fact
	MOV	a1, #MCPDM_SYSCONFIG_SOFTRESET
	STR	a1, [v2, #MCPDM_SYSCONFIG]
d244 57
a300 57
	LDR	a1, [v2, #MCPDM_SYSCONFIG]
	TST	a1, #MCPDM_SYSCONFIG_SOFTRESET
	BNE	%BT10

	; Set smart idle mode. No auto-idle available! :(
	MOV	a1, #MCPDM_SYSCONFIG_IDLEMODE_SMART
	STR	a1, [v2, #MCPDM_SYSCONFIG]
	MOV	v3, v2				; save ptr to PcPDM for later


	; Now resume HAL device setup...

	ADD	v2, v1, #Audio_DeviceSize
	MOV	a1, v2
	ADR	a2, MixerTemplate
	MOV	a3, #Mixer_DeviceSize
	BL	memcpy

	; Fill in pointers to each other
	STR	v1, [v2, #HALDevice_MixerCtrlr]
	STR	v2, [v1, #HALDevice_AudioMixer]

	LDRB	a1, [sb, #BoardConfig_MixerChans]
	STRB	a1, [v2, #:INDEX:MixerDisableFlags]
	; Unavailable channels, and input channels, start muted
	ORR	a1, a1, #((1<<MixerChannel_HeadsetMic) + (1<<MixerChannel_AuxInput) + (1<<MixerChannel_MainMic))
	ADD	a2, v2, #:INDEX:MixerSettings
10	AND	a3, a1, #1
	MOVS	a1, a1, LSR #1
	STR	a3, [a2], #8
	BNE	%BT10

	; Register devices
	MOV	a2, v1
	MOV	a1, #0
	CallOS	OS_AddDevice
	MOV	a2, v2
	MOV	a1, #0
	CallOS	OS_AddDevice


	; allow registers to be accessed by i2c (only I2C, in fast mode)
	; twl6040_write(codec, TWL6040_REG_ACCCTL, cache[TWL6040_REG_ACCCTL]);
	MOV	v4, v1			; save workspace ptr for later
	ADD	a2, v4, #:INDEX: AudioChipCache
	MOV	a4, #TWL6040_REG_ACCCTL
	ADD	a2, a2, a4
	MOV	a3, #(TWL6040_I2CSEL + TWL6040_INTCLRMODE + TWL6040_I2CMODE_FM)
	STRB	a3, [a2]
	MOV	a1, #TWL6040_IIC*2
	MOV	a3, #1
	LDR	v1, OSentries+4*OS_IICOpV
	BL	TPSWrite
  [ AudioDebug
	CMP	a1, #ECOMPLETED
	BEQ	%FT10
	DebugTX	"Audio_Init: TWL6040_ACCCTL access failed!"
d304 12
a315 12
	; now read all regs into our reg cache
	ADD	a2, v4, #:INDEX: AudioChipCache	; address our reg cache
	MOV	a4, #TWL6040_REG_ASICID
	ADD	a2, a2, a4			; start with first valid register
	MOV	a1, #TWL6040_IIC*2
	MOV	a3, #(TWL6040_REG_STATUS + 1 - TWL6040_REG_ASICID)
	LDR	v1, OSentries+4*OS_IICOpV
	BL	TPSRead
  [ AudioDebug
	CMP	a1, #ECOMPLETED
	BEQ	%FT20
	DebugTX	"Audio_Init: read of TWL6040 regs failed!"
d319 22
a340 22
	; extract offsets from TWL6040_REG_HSOTRIM register and set McPDM offsets
	ADD	a2, v4, #:INDEX: AudioChipCache
	MOV	a4, #TWL6040_REG_HSOTRIM
	LDRB	a3, [a2, a4]
	MOV	a2, a3, LSR #4		; extract HSF part
	AND	a3, a3, #TWL6040_HSLO	; isolate HSL part
	CMP	a3, #7
	SUBHI	a3, a3, #16		; sign correction
	AND	a3, a3, #0x1F		; mask valid offset bits
	CMP	a2, #7
	SUBHI	a2, a2, #16		; sign correction
	AND	a2, a2, #0x1F		; mask valid offset bits
	MOV	a3, a3, LSL #1		; shift into DN_OFST_RX1 field
	MOV	a2, a2, LSL #9		; shift into DN_OFST_RX2 field
	ORR	a3, a3, #MCPDM_DN_OFFSET_DN_OFST_RX1_EN
	ORR	a2, a2, #MCPDM_DN_OFFSET_DN_OFST_RX2_EN
	ORR	a2, a3, a2
	STR	a2, [v3, #MCPDM_DN_OFFSET]
	; configure downlink threshold
;	MOV	a2, #1			; this does work with OMAP4430 bot not OMAP4460
	MOV	a2, #(8 - 2)
	STR	a2, [v3, #MCPDM_FIFO_CTRL_DN]
d345 1
a345 1
	DebugTX	"Audio_Init done"
d347 1
a347 1
	Pull	"v1-v4,pc"
d357 2
a358 2
	GBLA	numrate
numrate SETA	0
d360 10
a369 10
	MACRO
$lab	cdf	$freq, $per, $m, $mode	; CD-derived rate ($freq in Hz, since all integral)
$lab	DCD	$freq*1024		; frequency value as reported by Sound_SampleRate
	DCB	$per			; period as reported via Sound_Configure
	DCB	$mode			; 0=TWL6040_LPLLFIN not set, sysclk=19200000
					; 1=TWL6040_LPLLFIN     set, sysclk=17640000
	DCB	$m			; 1=HSMN2ST active, 0=HSMN2ST not active
	DCB	0			; padding to 8 bytes
numrate SETA	numrate+1
	MEND
d371 1
a371 1
	ASSERT	HALDevice_AudioRateTableSize = 8
d374 2
a375 2
MODE_1920	*	(TWL6040_LPLLENA + 0)
MODE_1764	*	(TWL6040_LPLLENA + TWL6040_LPLLFIN)
d379 5
a383 5
	cdf	8000, 125, 1, MODE_1920		;  8kHz     (125us)  AC97/6
	cdf	11025, 91, 1, MODE_1764		; 11.025kHz (~91 us) CD/4
	cdf	16000, 63, 1, MODE_1920		; 16kHz     (~63 us) AC97/3
	cdf	22050, 45, 1, MODE_1764		; 22.05kHz  (~45 us) CD/2
	cdf	32000, 31, 1, MODE_1920		; 32kHz     (~31 us) AC97*2/3
d385 4
a388 4
	cdf	44100, 23, 1, MODE_1764		; 44.1kHz   (~23 us) CD/1
	cdf	48000, 21, 1, MODE_1920		; 48kHz     (~21 us) AC97/1
	cdf	88200, 11, 0, MODE_1764		; 88.2kHz   (~11 us) CD*2
	cdf	96000, 10, 0, MODE_1920		; 96kHz     (~10 us) AC97*2
d393 42
a434 42
	DCW	HALDeviceType_Audio + HALDeviceAudio_AudC
	DCW	HALDeviceID_AudC_TWL6040
	DCD	HALDeviceBus_Ser + HALDeviceSerBus_IIC
	DCD	1:SHL:16	; API version
	DCD	AudioDesc
	DCD	0		; Address - N/A
	%	12		; Reserved
	DCD	AudioActivate
	DCD	AudioDeactivate
	DCD	AudioReset
	DCD	AudioSleep
	DCD	AUDIO_IRQ	; Device
	DCD	0		; TestIRQ cannot be called
	%	8
	DCD	0		; Filled in during init
	DCD	1		; Output channels (supported so far)
	DCD	0		; Input channels (supported so far)
	ASSERT	(.-AudioTemplate) = HALDevice_Audio_Size
	; DMA channel parameters
	DCD	0 ; flags
	DCD	AUDIO_DMA_CHAN + 1		; logical channel
	DCD	0				; 'cycle speed'
	DCD	2				; transfer unit size: 16 bit (2 byte)
	DCD	L4_McPDM + MCPDM_DN_DATA + 2	; *physical* address to send data to
						; use upper half word only (left aligned 24 bit)
	; Enable/disable/IRQ routines
	DCD	PreEnable
	DCD	PostEnable
	DCD	PreDisable
	DCD	PostDisable
	DCD	IRQHandle
	DCD	numrate		; Number of sample rates
	DCD	ratetab		; Sample rate table
	DCD	AudioSetRate	; SetRate function
	ASSERT	(. - AudioTemplate) = HALDevice_Audio_Size_1
	DCD	0		; AudioRegs: filled in during init
	DCD	0		; AudioWorkspace: filled in during init
	DCB	0		; AudioMode
	DCB	0		; AudioMono
	DCW	0		; AudioChannels
	%	48		; AudioChipCache
	ALIGN
d436 1
a436 1
	ASSERT	(. - AudioTemplate) = Audio_DeviceSize
d441 37
a477 37
	DCW	HALDeviceType_Audio + HALDeviceAudio_Mixer
	DCW	HALDeviceID_Mixer_TWL6040
	DCD	HALDeviceBus_Ser + HALDeviceSerBus_IIC
	DCD	1		; API version
	DCD	MixerDesc
	DCD	0		; Address - N/A
	%	12		; Reserved
	DCD	MixerActivate
	DCD	MixerDeactivate
	DCD	MixerReset
	DCD	MixerSleep
	DCD	-1		; Device
	DCD	0		; TestIRQ cannot be called
	%	8
	DCD	0		; Filled in during init
	DCD	MixerChannels
	DCD	MixerGetFeatures
	DCD	MixerSetMix
	DCD	MixerGetMix
	DCD	MixerGetMixLimits
	ASSERT	(.-MixerTemplate) = HALDevice_Mixer_Size + 4
	; Default settings will be filled in during init
	DCD	0, 0
	DCD	0, 0
	DCD	0, 0
	DCD	0, 0
	DCD	0, 0
	DCD	0, 0
	DCD	0, 0
	DCD	0, 0
	DCW	HS_GAIN_OFF	; MixerHeadsetGain
	DCW	0		; MixerEarphoneGain
	DCW	0		; MixerHandsFreeGain
	DCW	0		; MixerAuxOutputGain
	DCW	&1B		; MixerSystemGain
	%	2
	ASSERT	(.-MixerTemplate) = Mixer_DeviceSize
d480 1
a480 1
	=	"TWL6040-compatible audio controller", 0
d483 2
a484 2
	=	"TWL6040-compatible audio mixer", 0
	ALIGN
d487 10
a496 10
	; TODO - Fix this!
	; SoundDMA is higher up the module chain than SoundControl
	; Which means we need the audio controller to do the mixer init, otherwise stuff might
	; not work properly
	Entry	"v1,sb", 4
	; Turn off codec, program mix params
	LDR	v1, [a1, #HALDevice_AudioMixer]
	ADD	v1, v1, #(:INDEX:MixerSettings)+8*MixerChannels
	MOV	a2, #MixerChannels-1
	LDR	sb, AudioWorkspace
d498 1
a498 1
	DebugTX "AudioActivate: Setting defaults"
d500 1
a500 1
	ADR	a3, ratetab
d502 2
a503 2
	LDRB	a4, [a3, #(6*8+6)]
	LDRB	a3, [a3, #(6*8+5)]	; use 48 kHz rate
d505 2
a506 2
	LDRB	a4, [a3, #(1*8+6)]
	LDRB	a3, [a3, #(1*8+5)]	; use 48 kHz rate
d508 14
a521 14
	STRB	a4, AudioMono
	CMP	a4, #0
	MOVNE	a4, #(MCPDM_CTRL_PDM_DN1_EN)
	MOVEQ	a4, #(MCPDM_CTRL_PDM_DN1_EN + MCPDM_CTRL_PDM_DN2_EN)
	STRH	a4, AudioChannels
	STRB	a3, AudioMode
	BL	SetCodecMode
10	LDMDB	v1!,{a3-a4}
	BL	ReallySetMix
	SUBS	a2, a2, #1
	BGE	%BT10
	; Finished!
	MOV	a1, #1
	EXIT
d524 1
a524 1
	MOV	pc, lr
d527 1
a527 1
	MOV	pc, lr
d530 2
a531 2
	MOV	a1, #0
	MOV	pc, lr
d534 14
a547 14
	; Reprogram TWL6040_REG_LPPLLCTL from softcopy
	; Assumes a1=audio device ptr, sb=HAL workspace
	Entry	"a1-a4,v1"

	ADR	a2, AudioMode
	MOV	a1, #TWL6040_IIC*2
	MOV	a3, #1
	MOV	a4, #TWL6040_REG_LPPLLCTL
	LDR	v1, OSentries+4*OS_IICOpV
	BL	TPSWrite
  [ AudioDebug
	CMP	a1, #ECOMPLETED
	EXIT	EQ
	DebugTX "SetCodecMode: TPS write failed!"
d549 1
a549 1
	EXIT
d552 5
a556 5
	; a2 = DMA buffer length
	; Use the buffer length to calculate a DMA packet size that fits in the FIFO.
	; McPDM has at most 16 FIFO entries; 1 entry contains 2 channels (stereo)
	; packet size is handled in element numbers
	LDR	a3, AudioWorkspace
d559 6
a564 6
	LDRB	a4, AudioMono
	CMP	a4, #0
	MOVEQ	a4, #(8 * 2)	; stereo mode
	MOVNE	a4, #(8 * 1)	; mono mode (R is copy of L)
	STR	a4, [a3, #:INDEX: DMAPktSz_Audio]
	MOV	pc, lr
d567 52
a618 52
	; a2 = DMA buffer length
	; This function is a mix of two things:
	; The McPDM instance is initialised first, to allow the DMA to prefill the TX FIFO.
	; The TWL6040 is then initialised afterwards.
	Entry	"v1-v2,sb"
	LDR	sb, AudioWorkspace
  [ AudioDebug
	DebugTX "PostEnable"
  ]
	Push	"a1"
	LDR	v1, AudioRegs
	LDRH	v2, AudioChannels

	; set McPDM Downlink path to reset state
	; omap_mcpdm_reset_playback(1)
	LDR	a1, [v1, #MCPDM_CTRL]
	ORR	a1, a1, #MCPDM_CTRL_SW_DN_RST
	STR	a1, [v1, #MCPDM_CTRL]

	; omap_mcpdm_playback_open()
	; clear any outstanding interrupt causes
	MOV	a1, #-1
	STR	a1, [v1, #MCPDM_IRQSTATUS]
	; enable irq request generation
	MOV	a1, #MCPDM_IRQ_DN_MASK
	STR	a1, [v1, #MCPDM_IRQENABLE_SET]
	; enable DMA request generation
	MOV	a1, #MCPDM_DMA_DN
	STR	a1, [v1, #MCPDM_DMAENABLE_SET]
	; set PDM out format
;	LDR	a1, [v1, #MCPDM_CTRL]
;	BIC	a1, a1, #MCPDM_CTRL_PDMOUTFORMAT	; left justified
;	STR	a1, [v1, #MCPDM_CTRL]

	; release McPDM Downlink path from reset state
	; omap_mcpdm_reset_playback(0)
	; omap_mcpdm_start()
	; enable playback channel
	LDR	a1, [v1, #MCPDM_CTRL]
	BIC	a1, a1, #MCPDM_CTRL_SW_DN_RST
	ORR	a1, a1, #MCPDM_CTRL_WD_EN
	ORR	a1, a1, v2				; activate our channels
	STR	a1, [v1, #MCPDM_CTRL]

	Pull	"a1"

	; enable headset (if needed)
	LDRB	a3, AudioMono
	LDR	a1, [a1, #HALDevice_AudioMixer]
	LDR	a2, MixerSettings+MixerChannel_HeadsetOut*8
	TST	a2, #MixerMixFlag_Mute
	BLEQ	UpdateHeadset
d620 1
a620 1
	EXIT
d623 22
a644 22
	; Disable the TWL6040, and then McPDM
	; This should avoid unwanted underflow IRQs
	Entry	"v1,sb"
	LDR	sb, AudioWorkspace
  [ AudioDebug
	DebugTX "PreDisable"
  ]

	; Disable headset output if required
	LDR	v1, [a1, #HALDevice_AudioMixer]
	LDR	a2, [v1, #:INDEX:MixerSettings+MixerChannel_HeadsetOut*8]
	ANDS	a2, a2, #MixerMixFlag_Mute
	BNE	%FT30
	MOV	a2, #HS_GAIN_OFF	; mark it as OFF
	STRH	a2, [v1, #:INDEX:MixerHeadsetGain]
	Push	"a1"
	LDRB	a2, AudioMono
	CMP	a2, #0
	ADRNEL	a2, HeadsetDisableSequenceM
	ADREQL	a2, HeadsetDisableSequenceS
	MOV	a3, #1
	LDR	v1, OSentries+4*OS_IICOpV
d646 9
a654 9
	LDRB	a4, [a2],#1
	MOV	a1, #TWL6040_IIC*2
	CMP	a4, #0
	BEQ	%FT20
	BL	TPSWrite
  [ AudioDebug
	CMP	a1, #ECOMPLETED
	BEQ	%FT15
	DebugReg a4,"PreDisable: Write failed, reg="
d657 2
a658 2
	ADD	a2, a2, #1
	B	%BT10
d660 1
a660 1
	Pull	"a1"
d663 14
a676 14
	; omap_mcpdm_stop()
	; disable playback channel
	LDR	a2, AudioRegs
	LDR	a3, [a2, #MCPDM_CTRL]
	BIC	a3, a3, #MCPDM_DL_CHANNELS
	STR	a3, [a2, #MCPDM_CTRL]

	; omap_mcpdm_playback_close()
	; disable IRQ request generation
	MOV	a3, #MCPDM_IRQ_DN_MASK
	STR	a3, [a2, #MCPDM_IRQENABLE_CLR]
	; disable DMA request generation
	MOV	a3, #MCPDM_DMA_DN
	STR	a3, [a2, #MCPDM_DMAENABLE_CLR]
d678 1
a678 1
	EXIT
d681 1
a681 1
	MOV	pc, lr
d685 6
a690 6
	Push	"sb,lr"
	LDR	sb, AudioWorkspace
	LDR	a2, AudioRegs
	LDR	a2, [a2, #MCPDM_IRQSTATUS]
	DebugReg a2,"IRQHandle: IRQSTATUS="
	Pull	"sb,lr"
d693 10
a702 10
	; Just clear the IRQ and ask for an audio reset
	LDR	a3, AudioRegs
	MVN	a2, #0
	; Make sure we don't get bothered about this again - we can't guarantee when the OS
	; will get round to resetting the audio, and could potentially get stuck in a loop
	; if we allow the IRQ to keep firing
	STR	a2, [a3, #MCPDM_IRQENABLE_CLR]
	STR	a2, [a3, #MCPDM_IRQSTATUS]	; clear all possible causes
	MOV	a1, #1
	MOV	pc, lr
d704 15
a718 15
	; restart the PDM channels and go on
	LDR	a3, AudioRegs
	LDR	a2, [a3, #MCPDM_IRQSTATUS]
	STR	a2, [a3, #MCPDM_IRQSTATUS]	; clear interrupt causes
	LDR	a2, [a3, #MCPDM_CTRL]
	BIC	a2, a2, #MCPDM_DL_CHANNELS
	ORR	a2, a2, #MCPDM_CTRL_SW_DN_RST	; reset downlink path
	STR	a2, [a3, #MCPDM_CTRL]
	LDRH	a1, AudioChannels
	ORR	a2, a2, a1			; reenable channels
	STR	a2, [a3, #MCPDM_CTRL]
	BIC	a2, a2, #MCPDM_CTRL_SW_DN_RST	; release reset
	STR	a2, [a3, #MCPDM_CTRL]
	MOV	a1, #0
	MOV	pc, lr
d722 20
a741 20
	; a2 = sample rate index (0-based)
	Entry	"sb"
	LDR	sb, AudioWorkspace
  [ AudioDebug
	DebugReg a2, "AudioSetRate: "
  ]
	; Reload TWL6040_REG_LPPLLCTL with the required value
	ADRL	a3, ratetab
	ASSERT	HALDevice_AudioRateTableSize = 8
	ADD	a3, a3, a2, LSL #3
	LDRB	a4, [a3, #6]
	LDRB	a3, [a3, #5]
	STRB	a4, AudioMono
	CMP	a4, #0
	MOVNE	a4, #(MCPDM_CTRL_PDM_DN1_EN)
	MOVEQ	a4, #(MCPDM_CTRL_PDM_DN1_EN + MCPDM_CTRL_PDM_DN2_EN)
	STRH	a4, AudioChannels
	STRB	a3, AudioMode
	BL	SetCodecMode
	EXIT
d744 1
a744 1
	MOV	a1, #1
d747 1
a747 1
	MOV	pc, lr
d750 14
a763 14
	Entry	"v1,sb", 4
	; program default mix params
	ADR	v1, MixerSettings+8*MixerChannels
	LDR	a1, [a1, #HALDevice_MixerCtrlr]
	MOV	a2, #MixerChannels-1
	LDR	sb, AudioWorkspace
  [ AudioDebug
	DebugTX "MixerReset: Setting defaults"
  ]
10	LDMDB	v1!,{a3-a4}
	BL	ReallySetMix
	SUBS	a2, a2, #1
	BGE	%BT10
	EXIT
d766 3
a768 3
	; TODO?
	MOV	a1, #0
	MOV	pc, lr
d771 8
a778 8
	; Check if this channel is disabled and needs the 'fixed' flag
	MOV	a4, #1
	LDRB	a3, MixerDisableFlags
	TST	a3, a4, LSL a2
	ADR	a1, MixerFeaturesTab
	LDR	a1, [a1, a2, LSL #2]
	ORRNE	a1, a1, #MixerFeaturesFlag_Fixed
	MOV	pc, lr
d781 24
a804 24
	; Stereo headset output
	DCW	0
	DCW	MixerCategory_Headphones
	; Mono earphone output
	DCW	MixerFeaturesFlag_DefaultMute
	DCW	MixerCategory_Speaker
	; Stereo hands-free output
	DCW	MixerFeaturesFlag_DefaultMute
	DCW	MixerCategory_LineOut
	; Stereo FM/aux output
	DCW	MixerFeaturesFlag_DefaultMute
	DCW	MixerCategory_AuxOut
	; System audio
	DCW	0
	DCW	MixerCategory_System
	; Stereo headset mic
	DCW	MixerFeaturesFlag_Mono :OR: MixerFeaturesFlag_DefaultMute
	DCW	MixerCategory_Mic
	; Stereo FM/aux input
	DCW	MixerFeaturesFlag_DefaultMute
	DCW	MixerCategory_LineIn
	; Mono main mic
	DCW	MixerFeaturesFlag_Mono :OR: MixerFeaturesFlag_DefaultMute
	DCW	MixerCategory_AuxIn
d808 6
a813 6
	ADR	a1, MixerLimitsTab
	ADD	a1, a1, a2, LSL #3
	ADD	a1, a1, a2, LSL #2
	LDMIA	a1, {a1, a2, a4}
	STMIA	a3, {a1, a2, a4}
	MOV	pc, lr
d816 32
a847 32
	; Stereo headset output
	DCD	-30*16
	DCD	0
	DCD	2*16
	; Mono speaker output
	DCD	-24*16
	DCD	6*16
	DCD	2*16
	; Stereo hands-free output
	DCD	-52*16
	DCD	6*16
	DCD	2*16
	; Stereo FM/aux output
	DCD	-52*16
	DCD	6*16
	DCD	2*16
	; System audio
	DCD	-18*16
	DCD	24*16
	DCD	6*16
	; Stereo headset mic
	DCD	6*16
	DCD	30*16
	DCD	6*16
	; Stereo FM/aux input
	DCD	6*16
	DCD	30*16
	DCD	6*16
	; Mono main mic
	DCD	6*16
	DCD	30*16
	DCD	6*16
d850 22
a871 22
	; a1 = mixer device
	; a2 = channel
	; a3 = mute flag
	; a4 = gain, in dB*16
	Entry	"v1"
	; Double-check that we aren't being asked to program a disabled channel
	; Although ReallySetMix will do another check, we must check here to make sure we don't
	; update the stored settings (particularly the headset settings, which UpdateHeadset
	; treats as gospel)
	MOV	ip, #1
	LDRB	v1, MixerDisableFlags
	TST	v1, ip, LSL a2
	EXIT	NE
	ADR	v1, MixerSettings
	ADD	v1, v1, a2, LSL #3
	LDMIA	v1, {ip, lr}
	TEQ	a3, ip
	TEQEQ	a4, lr
	STMNEIA v1, {a3, a4}
	LDRNE	a1, [a1, #HALDevice_MixerCtrlr]
	BLNE	ReallySetMix
	EXIT
d874 40
a913 40
	; a1 = *audio* device
	; a2-a4 as above
	; Preserves all regs
	; Channel gain & mute control can't easily be abstracted, need to do it on a
	; case-by-case basis :(
	; Common code to get ready for IIC transfers
	Entry	"a1-a4,v1-v5,sb,v7"
	LDR	sb, AudioWorkspace
  [ AudioDebug
	DebugTX "ReallySetMix:"
	DebugReg a2,"Channel="
	DebugReg a3,"Mute="
	DebugReg a4,"Gain="
  ]
	; Triple-check that we aren't being asked to program a disabled channel
	; (ReallySetMix gets called unconditionally in a few places; easier to just check for
	; invalid channels here rather than in every place it gets called from)
	LDRB	v5, [sb, #BoardConfig_MixerChans]
	MOV	v2, #1
	TST	v5, v2, LSL a2
	EXIT	NE
	LDR	v5, [a1, #HALDevice_AudioMixer]
	MOV	v2, a3
;	LDRB	v4, AudioMode
	LDRB	v4, AudioMono
	ADD	v7, v5, #:INDEX: MixerSettings+4
	LDR	v1, OSentries+4*OS_IICOpV
	MOV	a1, #TWL6040_IIC*2
	ADD	v7, v7, a2, LSL #3
	ADR	a3, SetMixTab
	MOV	v3, a4
	LDR	pc, [a3, a2, LSL #2]
	; Following code entered with:
	; a1, v1 ready for TPSRead/TPSWrite
	; v2 = mute flag
	; v3 = gain
	; v4 = current AudioMono setting
	; v5 = mixer device
	; sb = HAL WS
	; v7 = gain writeback ptr
d915 8
a922 8
	DCD	SetMixHeadsetOut
	DCD	SetMixEarphone
	DCD	SetMixHandsFree
	DCD	SetMixAuxOutput
	DCD	SetMixSystem
	DCD	SetMixHeadsetMic
	DCD	SetMixAuxInput
	DCD	SetMixMainMic
d925 9
a933 9
	; If the codec is on, go through to UpdateHeadset
	; Else do nothing
;	TST	v4, #TWL6040_LPLLENA
;	MOVNE	a1, v5
;	BLNE	UpdateHeadset
	MOV	a3, v4
	MOV	a1, v5
	BL	UpdateHeadset
	EXIT
d936 10
a945 10
	; Calculate EARGAIN: 0x0 == 6 dB, 0x1 == 4 dB, 0x2 == 2 dB ... 0xF == -24dB
	TST	v2, #MixerMixFlag_Mute
	MOVNE	v4, #0			; disable everything
	BNE	%FT10
	; calculate gain value
	MOV	lr, v3, ASR #(4+1)	; div by step width (2 dB)
	RSB	v4, lr, #3		; negate at zero point
	MOV	v4, v4, LSL #1		; shift into EARGAIN position
	STR	v3, [v7]		; remember used gain value
	ORR	v4, v4, #TWL6040_EARENA	; enable it
d947 12
a958 12
	ADD	a2, v5, #:INDEX:MixerEarphoneGain
	LDRH	ip, [a2]
	CMP	ip, v4
	EXIT	EQ
	STRH	v4, [a2]
	MOV	a3, #1
	MOV	a4, #TWL6040_REG_EARCTL
	BL	TPSWrite
  [ AudioDebug
	CMP	a1, #0
	EXIT	EQ
	DebugTX "SetMixEarphone: TPS write failed!"
d960 1
a960 1
	EXIT
d963 6
a968 6
	; If the codec is on, go through to UpdateHandsFree
	; Else do nothing
	TST	v4, #TWL6040_LPLLENA
	MOVNE	a1, v5
	BLNE	UpdateHandsFree
	EXIT
d973 24
a996 24
	; adapt for TWL6040 !?
	; Aux Output path has no separate control registers in TWL6040
	; it is internally connected to handsfree path

	MOV	a3, #2
	MOV	a4, #PRECKL_CTL
	MOV	v4, #&64 ; 0dB gain, AL2
	CMP	v3, #6*16
	MOVGE	v4, #&54 ; 6dB gain, AL2
	CMP	v3, #-6*16
	MOVLE	v4, #&74 ; -6dB gain, AL2
	TST	v2, #MixerMixFlag_Mute
	ORREQ	v4, v4, v4, LSL #8 ; R channel settings
	MOVNE	v4, #0 ; Else disable everything
	ADD	a2, v5, #:INDEX:MixerCarkitOutGain
	LDRH	ip, [a2]
	CMP	ip, v4
	EXIT	EQ
	STRH	v4, [a2]
	BL	TPSWrite
  [ AudioDebug
	CMP	a1, #0
	EXIT	EQ
	DebugTX "SetMixAuxOutput: TPS write failed!"
d999 1
a999 1
	EXIT
d1002 19
a1020 19
	; there is no such thing for output in TWL6040
	; there is only a general LINEGAIN for input paths
	; Calculate LINEGAIN (L|R): 0x0 == -18 dB, 0x1 == -12 dB, ... 0x7 == +24 dB
	; range mapping: [-18 dB .. +24 dB]
	; mapping: fScale = (1 / 6) = 0.166.. ~ 2370 [ * 2^14]
	; "/ 6" for step width of 6 dB
	TST	v2, #MixerMixFlag_Mute
	MOVNE	v4, #0			; disable everything
	BNE	%FT10
	STR	v3, [v7]		; remember used gain value
	; calculate scaled gain value
	CMP	v3, #0
	ADDGT	v3, v3, #1		; compensate for rounding errors
	MOV	a3, #2370		; == fScale
	MUL	a3, v3, a3
	MOV	a3, a3, ASR #(14+4)	; div by (16 * 2^14)
	ADD	a3, a3, #3		; add 0 dB offset
	AND	v4, a3, #TWL6040_LINEGAINL	; only relevant bits
	ORR	v4, v4, v4, LSL #3	; fold into LINEGAINR
d1022 12
a1033 12
	ADD	a2, v5, #:INDEX:MixerSystemGain
	LDRH	ip, [a2]
	CMP	ip, v4
	EXIT	EQ
	MOV	a3, #1
	STRH	v4, [a2]
	MOV	a4, #TWL6040_REG_LINEGAIN
	BL	TPSWrite
  [ AudioDebug
	CMP	a1, #0
	EXIT	EQ
	DebugTX "SetMixSystem: TPS write failed!"
d1035 1
a1035 1
	EXIT
d1040 1
a1040 1
	EXIT
d1043 4
a1046 4
	ADR	a1, MixerSettings
	ADD	a1, a1, a2, LSL #3
	LDMIA	a1, {a1, a2}
	MOV	pc, lr
d1049 17
a1065 17
	; This performs the steps necessary to enable/disable the headset output
	; Input:
	; a1 = mixer device
	; a3 = AudioMono flag
	; sb = HAL workspace
	Entry	"a1-a4,v1", 12

	; Get mixer settings for headset
	ADR	ip, MixerSettings+MixerChannel_HeadsetOut*8
	LDMIA	ip, {a4,v1}	; a4 = mute flag, v1 = gain
	TST	a4, #MixerMixFlag_Mute
	BEQ	%FT02
	CMP	a3, #0
	ADRNE	a2, HeadsetDisableSequenceM ; Muted, so disable it
	ADREQ	a2, HeadsetDisableSequenceS ; Muted, so disable it
	MOV	ip, #0
	B	%FT05
d1067 17
a1083 17
	; Calculate HSGAIN: 0x0 == 0 dB, 0x1 == -2 dB, ... 0xF == -30dB
	MOV	a2, v1, ASR #(4+1)	; div by step width (2 dB)
	RSB	ip, a2, #0		; negate
	ORR	ip, ip, ip, LSL #4	; fold it into HSGAINR
	; Copy enable sequence to stack so we can modify it with the correct gain
	CMP	a3, #0
	ADRNE	a3, HeadsetEnableSequenceM
	ADREQ	a3, HeadsetEnableSequenceS
	MOV	a2, sp
	LDRH	v1, MixerHeadsetGain
	CMP	v1, #HS_GAIN_OFF	; Is the headset currently turned off?
	LDMIA	a3, {a3,a4,v1}
	ORR	a4, a4, ip, LSL #8	; Set correct gain
	STMEQIA	a2, {a3,a4,v1}		; Full programming sequence if headset off
	MOVNE	a4, a4, LSL #16		; If headset on, only change HSGAIN
	MOVNE	a4, a4, LSR #16
	STRNE	a4, [a2]
d1085 12
a1096 12
	; a2 = sequence to program
	; ip = HSGAIN value
	LDRH	v1, MixerHeadsetGain
  [ AudioDebug
	DebugReg ip,"UpdateHeadset: New="
	DebugReg v1,"Old="
  ]
	CMP	v1, ip
	EXIT	EQ		; Avoid reprogramming identical values
	STRH	ip, MixerHeadsetGain
	MOV	a3, #1
	LDR	v1, OSentries+4*OS_IICOpV
d1098 9
a1106 9
	LDRB	a4, [a2],#1
	MOV	a1, #TWL6040_IIC*2
	CMP	a4, #0
	EXIT	EQ
	BL	TPSWrite
  [ AudioDebug
	CMP	a1, #ECOMPLETED
	BEQ	%FT15
	DebugReg a4,"UpdateHeadset: Write failed, reg="
d1109 2
a1110 2
	ADD	a2, a2, #1
	B	%BT10
d1113 7
a1119 7
	DCB	TWL6040_REG_HSLCTL, &2B	; DAC ON
	DCB	TWL6040_REG_HSRCTL, &AB	; DAC ON + HSMN2ST
	DCB	TWL6040_REG_HSGAIN, 0	; this gets filled in above
	DCB	TWL6040_REG_HSLCTL, &2F	; DAC + Driver ON
	DCB	TWL6040_REG_HSRCTL, &AF	; DAC + Driver ON + HSMN2ST
	DCB	0	; Terminator
	ALIGN
d1122 7
a1128 7
	DCB	TWL6040_REG_HSLCTL, &2B	; DAC ON
	DCB	TWL6040_REG_HSRCTL, &2B	; DAC ON
	DCB	TWL6040_REG_HSGAIN, 0	; this gets filled in above
	DCB	TWL6040_REG_HSLCTL, &2F	; DAC + Driver ON
	DCB	TWL6040_REG_HSRCTL, &2F	; DAC + Driver ON
	DCB	0	; Terminator
	ALIGN
d1131 5
a1135 5
	DCB	TWL6040_REG_HSLCTL, &2B	; DAC ON
	DCB	TWL6040_REG_HSRCTL, &AB	; DAC ON + HSMN2ST
	DCB	TWL6040_REG_HSGAIN, HS_GAIN_OFF	; special value for marking OFF
	DCB	0	; Terminator
	ALIGN
d1138 5
a1142 5
	DCB	TWL6040_REG_HSLCTL, &2B	; DAC ON
	DCB	TWL6040_REG_HSRCTL, &2B	; DAC ON
	DCB	TWL6040_REG_HSGAIN, HS_GAIN_OFF	; special value for marking OFF
	DCB	0	; Terminator
	ALIGN
d1146 31
a1176 31
	; This performs the steps necessary to enable/disable the hands-free output
	; Input:
	; a1 = mixer device
	; sb = HAL workspace
	Entry	"a1-a4,v1", 16

	; Get mixer settings for headset
	ADR	ip, MixerSettings+MixerChannel_HandsFree*8
	LDMIA	ip, {a4,v1}	; a4 = mute flag, v1 = gain
	TST	a4, #MixerMixFlag_Mute
	ADRNE	a2, HandsFreeDisableSequence ; Muted, so disable it
	MOVNE	ip, #0
	BNE	%FT05
	; gain is in HFLGAIN and HFRGAIN each with the following values:
	; 0x00 == 6 dB, 0x01 == 4 dB, 0x02 == 2 dB, 0x03 == 0 dB, 0x04 == -2 dB,
	; ... 0x1C == -50 dB, 0x1D == -52 dB  (0x1E and 0x1F not valid)
	MOV	a3, v1, ASR #(4+1)	; div by step width (2 dB)
	RSB	ip, a3, #3		; negate at zero point
	; Copy enable sequence to stack so we can modify it with the correct gain
	ADR	a3, HandsFreeEnableSequence
	MOV	a2, sp
	LDRH	v1, MixerHandsFreeGain
	CMP	v1, #HF_GAIN_OFF	; Is the hands-free currently turned off?
	LDMIA	a3, {a3,a4,v1}
	ORR	a4, a4, ip, LSL #8	; Set correct gain HFLGAIN
	ORR	a4, a4, ip, LSL #24	; Set correct gain HFRGAIN
	STMEQIA	a2, {a3,a4,v1}		; Full programming sequence if hands-free off
	STRNE	a4, [a2]		; If hands-free on, only change HFxGAIN
	MOV	a4, #0			; terminate sequence with 0
	STRNE	a4, [a2, #4]
	STREQ	a4, [a2, #3*4]
d1178 12
a1189 12
	; a2 = sequence to program
	; ip = HFxGAIN value
	LDRH	v1, MixerHandsFreeGain
  [ AudioDebug
	DebugReg ip,"UpdateHandsFree: New="
	DebugReg v1,"Old="
  ]
	CMP	v1, ip
	EXIT	EQ		; Avoid reprogramming identical values
	STRH	ip, MixerHandsFreeGain
	MOV	a3, #1
	LDR	v1, OSentries+4*OS_IICOpV
d1191 9
a1199 9
	LDRB	a4, [a2],#1
	MOV	a1, #TWL6040_IIC*2
	CMP	a4, #0
	EXIT	EQ
	BL	TPSWrite
  [ AudioDebug
	CMP	a1, #ECOMPLETED
	BEQ	%FT15
	DebugReg a4,"UpdateHandsFree: Write failed, reg="
d1202 2
a1203 2
	ADD	a2, a2, #1
	B	%BT10
d1206 3
a1208 3
	DCB	TWL6040_REG_HFLCTL, &07	; DAC ON
  [ Mono2Stero
	DCB	TWL6040_REG_HFRCTL, &27	; DAC ON + HFMN2ST
d1210 7
a1216 7
	DCB	TWL6040_REG_HFRCTL, &07	; DAC ON
  ] ; Mono2Stero
	DCB	TWL6040_REG_HFLGAIN, 0	; this gets filled in above
	DCB	TWL6040_REG_HFRGAIN, 0	; this gets filled in above
	DCB	TWL6040_REG_HFLCTL, &17	; DAC + Driver ON
  [ Mono2Stero
	DCB	TWL6040_REG_HFRCTL, &37	; DAC + Driver ON + HFMN2ST
d1218 4
a1221 4
	DCB	TWL6040_REG_HFRCTL, &17	; DAC + Driver ON
  ] ; Mono2Stero
	DCB	0	; Terminator
	ALIGN
d1224 3
a1226 3
	DCB	TWL6040_REG_HFLCTL, &07	; DAC ON
  [ Mono2Stero
	DCB	TWL6040_REG_HFRCTL, &27	; DAC ON + HFMN2ST
d1228 6
a1233 6
	DCB	TWL6040_REG_HFRCTL, &07	; DAC ON
  ] ; Mono2Stero
	DCB	TWL6040_REG_HFLGAIN, &1D	; nearly mute
	DCB	TWL6040_REG_HFRGAIN, &1D	; nearly mute
	DCB	0	; Terminator
	ALIGN
d1236 1
a1236 1
	END
@


1.2
log
@Update to OMAP4 HAL.
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.Audio
    added further definitions for TWL6040 audio chip
    changes for working sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.SDMA
    added further register descriptions according OMAP4 TRM
    changes for working sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.UART
    added further register descriptions according OMAP4 TRM
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.omap4430
    added definitions for OMAP4460 (Panda ES)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.board
    adjusted max pixel-clock rate
    order of UART entries changed
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Boot
    don't reset debug UART
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Top
    modifications according to OMAP3 version
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.debug
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.UART
    changes according to hdr.UART changes; HAL_UARTModemControl
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.RAM
    use definitions from hdr.SDMA
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.SDMA
    use definitions from hdr.SDMA
    changes for working sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Video
    added code to VideoDevice_Activate (enable DSS power)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.omap4430
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.SDMA
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Audio
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.SDMA
    changes for working sound support

Submissions from Willi Theiss. Compiles, but not tested here.

Version 0.05. Tagged as 'OMAP4-0_05'
@
text
@a188 3
  [ Mono2Stero
MCPDM_DL_CHANNELS	*	(MCPDM_CTRL_PDM_DN1_EN)
  |
a189 1
  ] ; Mono2Stero
d338 4
d354 3
a356 1
; The first 'reserved' byte is used to store the value that needs programming into the TPS CODEC_MODE register
d362 1
a362 1
$lab	cdf	$freq, $per, $mode	; CD-derived rate ($freq in Hz, since all integral)
d367 2
a368 1
	DCW	0			; padding to 8 bytes
d374 4
d380 5
a384 5
	cdf	8000, 125, (TWL6040_LPLLENA + 0)		;  8kHz     (125usec)  AC97/6
	cdf	11025, 91, (TWL6040_LPLLENA + TWL6040_LPLLFIN)	; 11.025kHz (~91 usec) CD/4
	cdf	16000, 63, (TWL6040_LPLLENA + 0)		; 16kHz     (~63 usec) AC97/3
	cdf	22050, 45, (TWL6040_LPLLENA + TWL6040_LPLLFIN)	; 22.05kHz  (~45 usec) CD/2
	cdf	32000, 31, (TWL6040_LPLLENA + 0)		; 32kHz     (~31 usec) AC97*2/3
d386 4
a389 4
	cdf	44100, 23, (TWL6040_LPLLENA + TWL6040_LPLLFIN)	; 44.1kHz   (~23 usec) CD/1
	cdf	48000, 21, (TWL6040_LPLLENA + 0)		; 48kHz     (~21 usec) AC97/1
	cdf	88200, 11, (TWL6040_LPLLENA + TWL6040_LPLLFIN)	; 88.2kHz   (~11 usec) CD*2
	cdf	96000, 10, (TWL6040_LPLLENA + 0)		; 96kHz     (~10 usec) AC97*2
d431 3
a433 1
	DCD	0		; AudioMode
d503 1
d506 1
d509 6
a514 1
	STR	a3, AudioMode
d558 6
a563 5
  [ Mono2Stero
	MOV	a4, #(8 * 1)	; avoid FIFO FULL conditions
  |
	MOV	a4, #(8 * 2)	; avoid FIFO FULL conditions
  ] ; Mono2Stero
d572 1
a572 1
	Entry	"v1-v3,sb"
d579 1
a593 4
	; configure downlink threshold
	MOV	a1, #2
;	MOV	a1, #(8 - 2)
	STR	a1, [v1, #MCPDM_FIFO_CTRL_DN]
d609 1
a609 1
	ORR	a1, a1, #MCPDM_DL_CHANNELS
d615 1
d640 4
a643 1
	ADRL	a2, HeadsetDisableSequence
d713 2
a714 1
	ORR	a2, a2, #MCPDM_DL_CHANNELS	; reenable channels
d733 1
d735 6
a740 13
	LDR	a2, AudioMode
	CMP	a2, a3
	EXIT	EQ ; Redundant update, ignore
	TST	a2, #2
  [ AudioDebug
	BEQ	%FT10
	DebugTX "AudioSetRate: Failed, codec is active!"
	EXIT
10
  |
	EXIT	NE
  ]
	STR	a3, AudioMode
d898 2
a899 1
	LDR	v4, AudioMode
d911 1
a911 1
	; v4 = current TWL6040_REG_LPPLLCTL setting
d928 6
a933 3
	TST	v4, #TWL6040_LPLLENA
	MOVNE	a1, v5
	BLNE	UpdateHeadset
d1053 1
d1061 7
a1067 3
	ADRNE	a2, HeadsetDisableSequence ; Muted, so disable it
	MOVNE	ip, #0
	BNE	%FT05
d1069 2
a1070 2
	MOV	a3, v1, ASR #(4+1)	; div by step width (2 dB)
	RSB	ip, a3, #0		; negate
d1073 3
a1075 1
	ADR	a3, HeadsetEnableSequence
d1113 1
a1113 1
HeadsetEnableSequence
a1114 1
  [ Mono2Stero
d1116 8
a1123 1
  |
a1124 1
  ] ; Mono2Stero
a1126 3
  [ Mono2Stero
	DCB	TWL6040_REG_HSRCTL, &AF	; DAC + Driver ON + HSMN2ST
  |
a1127 1
  ] ; Mono2Stero
d1131 1
a1131 1
HeadsetDisableSequence
a1132 1
  [ Mono2Stero
d1134 6
a1139 1
  |
a1140 1
  ] ; Mono2Stero
@


1.1
log
@Initial revision
@
text
@d135 1
a135 1
;   (DACL2/DACR2, to keep the voice path free for the future?) to playing the data generated by
a136 2
; * VDL_GAIN, DACL1, DACR1 amplifiers can be ignored (although VDL_GAIN would be useful for
;   mono data received by Ampli_L?)
d147 1
a147 1
; TPS                             HAL mixer category
d149 1
a149 1
; Predriver left/right            SPEAKER
d151 2
a152 3
; Carkit left/right               AUX_OUT (carkit is more likely to be useful than earphone, if
;                                          a carkit-compatible USB driver is written)
; Earphone                        none?
d154 1
a154 1
; Handset main mic                none?
a158 1
; Mono carkit mic                 AUX_IN (to match AUX_OUT)
a159 2
; 'SYSTEM' should obviously control the volume of the sound RO generates - i.e. by using the
; ARXL2PGA/ARXR2PGA amplifiers
d168 2
a169 8
;AudioDebug	SETL	{FALSE}
AudioDebug	SETL	{TRUE}

; TWL6040 register which can be set to default values before power-up (RO regs excluded)
TWL6040VioRegsSize	*	(18 - 4)

; TWL6040 register which can be set after power-up
TWL6040VddRegsSize	*	(21)
d176 27
d206 1
a206 1
 [ AudioDebug
d208 1
a208 1
 ]
d219 1
a219 1
 [ AudioDebug
d221 1
a221 1
 ]
d256 1
d274 1
a274 1
	ORR	a1, a1, #(1<<MixerChannel_HeadsetMic)+(1<<MixerChannel_AuxInput)+(1<<MixerChannel_CarkitMic)
d289 2
a290 2
	; twl6040_init_vio_regs()
	; allow registers to be accessed by i2c
d292 2
a293 2
	MOV	a1, #TWL6040_IIC*2
	ADR	a2, TWL6040Defaults
d296 3
d302 2
a303 2
 [ AudioDebug
	CMP	a1, #0
d307 1
a307 1
 ]
d309 4
a312 4
	; Set TWL6040 writeable (VIO) audio registers to default values
	ADR	v2, TWL6040VioRegs
	MOV	v3, #TWL6040VioRegsSize
05
d314 9
a322 14
	ADR	a2, TWL6040Defaults
	LDRB	a4, [v2], #1	; get regs number
	ADD	a2, a2, a4
	MOV	a3, #1
	BL	TPSWrite
 [ AudioDebug
	CMP	a1, #0
	BEQ	%FT10
	DebugTX	"Audio_Init: TPS audio reset (VIO) failed!"
	B	%FT20
10
 ]
	SUBS	v3, v3, #1
	BNE	%BT05
d324 18
a341 20
20
	; Set TWL6040 VDD/VSS audio registers to default values
	ADR	v2, TWL6040VddRegs
	MOV	v3, #TWL6040VddRegsSize
05
	MOV	a1, #TWL6040_IIC*2
	ADR	a2, TWL6040Defaults
	LDRB	a4, [v2], #1	; get regs number
	ADD	a2, a2, a4
	MOV	a3, #1
	BL	TPSWrite
 [ AudioDebug
	CMP	a1, #0
	BEQ	%FT10
	DebugTX	"Audio_Init: TPS audio reset (VDD) failed!"
	B	%FT30
10
 ]
	SUBS	v3, v3, #1
	BNE	%BT05
d345 1
a345 1
 [ AudioDebug
d347 1
a347 1
 ]
a349 51
TWL6040Defaults ; List of default settings for TWL6040 registers
	; taken from ubuntu-omap4/sound/soc/codecs/twl6040.c
	DCB	0x00 ; not used
	DCB	0x4B ; TWL6040_ASICID (ro)	0x01
	DCB	0x00 ; TWL6040_ASICREV (ro)	0x02
	DCB	0x00 ; TWL6040_INTID		0x03
	DCB	0x00 ; TWL6040_INTMR		0x04
	DCB	0x81 ; TWL6040_NCPCTRL		0x05
	DCB	0x45 ; TWL6040_LDOCTL		0x06
	DCB	0x6C ; TWL6040_HPPLLCTL		0x07
	DCB	0x10 ; TWL6040_LPPLLCTL		0x08
	DCB	0x4A ; TWL6040_LPPLLDIV		0x09
	DCB	0x00 ; TWL6040_AMICBCTL		0x0A
	DCB	0x00 ; TWL6040_DMICBCTL		0x0B
	DCB	0x18 ; TWL6040_MICLCTL		0x0C - Bit 4,3: 3 = "OFF"
	DCB	0x18 ; TWL6040_MICRCTL		0x0D - Bit 4,3: 3 = "OFF"
	DCB	0x00 ; TWL6040_MICGAIN		0x0E
	DCB	0x1B ; TWL6040_LINEGAIN		0x0F
	DCB	0x21 ; TWL6040_HSLCTL		0x10 - Bit 6,5: 1 = "HS DAC"
	DCB	0x21 ; TWL6040_HSRCTL		0x11 - Bit 6,5: 1 = "HS DAC"
	DCB	0x00 ; TWL6040_HSGAIN		0x12 - 0 db (highest) gain (L/R)
	DCB	0x1E ; TWL6040_EARCTL		0x13
	DCB	0x00 ; TWL6040_HFLCTL		0x14 - Bit 3,2: 0 = "OFF"
	DCB	0x1D ; TWL6040_HFLGAIN		0x15
	DCB	0x00 ; TWL6040_HFRCTL		0x16 - Bit 3,2: 0 = "OFF"
	DCB	0x1D ; TWL6040_HFRGAIN		0x17
	DCB	0x00 ; TWL6040_VIBCTLL		0x18
	DCB	0x00 ; TWL6040_VIBDATL		0x19
	DCB	0x00 ; TWL6040_VIBCTLR		0x1A
	DCB	0x00 ; TWL6040_VIBDATR		0x1B
	DCB	0x00 ; TWL6040_HKCTL1		0x1C
	DCB	0x00 ; TWL6040_HKCTL2		0x1D
	DCB	0x02 ; TWL6040_GPOCTL		0x1E
	DCB	0x00 ; TWL6040_ALB		0x1F
	DCB	0x00 ; TWL6040_DLB		0x20
	DCB	0x00 ; not used			0x21
	DCB	0x00 ; not used			0x22
	DCB	0x00 ; not used			0x23
	DCB	0x00 ; not used			0x24
	DCB	0x00 ; not used			0x25
	DCB	0x00 ; not used			0x26
	DCB	0x00 ; not used			0x27
	DCB	0x00 ; TWL6040_TRIM1		0x28
	DCB	0x00 ; TWL6040_TRIM2		0x29
	DCB	0x00 ; TWL6040_TRIM3		0x2A
	DCB	0x00 ; TWL6040_HSOTRIM		0x2B
	DCB	0x00 ; TWL6040_HFOTRIM		0x2C
	DCB	0x09 ; TWL6040_ACCCTL		0x2D
	DCB	0x00 ; TWL6040_STATUS (ro)	0x2E

	ALIGN
a350 51
TWL6040VioRegs ; list of regs which can be accessed before the power-up sequence
	; regs which are read only not used, ACCCTL is handled separate
;	DCB	TWL6040_REG_ASICID
;	DCB	TWL6040_REG_ASICREV
	DCB	TWL6040_REG_INTID
	DCB	TWL6040_REG_INTMR
	DCB	TWL6040_REG_NCPCTL
	DCB	TWL6040_REG_LDOCTL
	DCB	TWL6040_REG_AMICBCTL
	DCB	TWL6040_REG_DMICBCTL
	DCB	TWL6040_REG_HKCTL1
	DCB	TWL6040_REG_HKCTL2
	DCB	TWL6040_REG_GPOCTL
	DCB	TWL6040_REG_TRIM1
	DCB	TWL6040_REG_TRIM2
	DCB	TWL6040_REG_TRIM3
	DCB	TWL6040_REG_HSOTRIM
	DCB	TWL6040_REG_HFOTRIM
;	DCB	TWL6040_REG_ACCCTL
;	DCB	TWL6040_REG_STATUS

	ASSERT (. - TWL6040VioRegs) = TWL6040VioRegsSize

	ALIGN

TWL6040VddRegs ; list of regs which can be accessed after the power-up sequence
	DCB	TWL6040_REG_HPPLLCTL
	DCB	TWL6040_REG_LPPLLCTL
	DCB	TWL6040_REG_LPPLLDIV
	DCB	TWL6040_REG_MICLCTL
	DCB	TWL6040_REG_MICRCTL
	DCB	TWL6040_REG_MICGAIN
	DCB	TWL6040_REG_LINEGAIN
	DCB	TWL6040_REG_HSLCTL
	DCB	TWL6040_REG_HSRCTL
	DCB	TWL6040_REG_HSGAIN
	DCB	TWL6040_REG_EARCTL
	DCB	TWL6040_REG_HFLCTL
	DCB	TWL6040_REG_HFLGAIN
	DCB	TWL6040_REG_HFRCTL
	DCB	TWL6040_REG_HFRGAIN
	DCB	TWL6040_REG_VIBCTLL
	DCB	TWL6040_REG_VIBDATL
	DCB	TWL6040_REG_VIBCTLR
	DCB	TWL6040_REG_VIBDATR
	DCB	TWL6040_REG_ALB
	DCB	TWL6040_REG_DLB

	ASSERT (. - TWL6040VddRegs) = TWL6040VddRegsSize

	ALIGN
d371 12
a382 9
ratetab cdf	8000, 125, 0		;  8kHz     (125usec)  AC97/6
	cdf	11025, 91, 1		; 11.025kHz (~91 usec) CD/4
	cdf	16000, 63, 0		; 16kHz     (~63 usec) AC97/3
	cdf	22050, 45, 1		; 22.05kHz  (~45 usec) CD/2
	cdf	32000, 31, 0		; 32kHz     (~31 usec) AC97*2/3
	cdf	44100, 23, 1		; 44.1kHz   (~23 usec) CD/1
	cdf	48000, 21, 0		; 48kHz     (~21 usec) AC97/1
	cdf	88200, 11, 1		; 88.2kHz   (~11 usec) CD*2
	cdf	96000, 10, 0		; 96kHz     (~10 usec)
d408 4
a411 3
	DCD	0	; 'cycle speed'
	DCD	2	; transfer unit size: 32 bit
	DCD	L3_McPDM + MCPDM_DN_DATA	; *physical* address to send data to
d422 4
a425 3
	DCD	0		; Filled in during init
	DCD	0		; Filled in during init
	DCD	0
d436 1
a436 1
	DCD	0		; API version
d452 2
a453 1
	ASSERT	(.-MixerTemplate) = HALDevice_Mixer_Size
d463 5
a467 5
	DCW	0 ; MixerHeadsetGain
	DCW	0 ; MixerPredriverGain
	DCW	0 ; MixerHandsFreeGain
	DCW	0 ; MixerCarkitOutGain
	DCW	&3F3F ; MixerSystemGain
d489 1
a489 1
 [ AudioDebug
d491 1
a491 1
 ]
d493 5
a497 1
	LDRB	a3, [a3, #5] ; Just use first rate for now
d519 1
a519 1
	; Reprogram CODEC_MODE from softcopy
a521 2
 [ {FALSE}
	; adapt for TWL6040 !?
d526 1
a526 1
	MOV	a4, #CODEC_MODE
d529 3
a531 3
 [ AudioDebug
	CMP	a1, #0
	EXIT EQ
d533 1
a533 2
 ]
 ]
d539 2
a540 1
	; McPDM has at most 16 FIFO entries
d542 6
a547 2
	MOV	a4, #16
	STR	a4, [a3, #:INDEX:DMAPktSz_Audio]
d552 1
a552 4
	; This function is a mix of two things - the TPS programming steps from section 14.5.3
	; of the manual (swcu050d.pdf, page 715/716), and the McBSP programming steps
	; The steps for both have been stripped down to the bare minimum that are required for
	; (re)initialisation.
d557 1
a557 1
 [ AudioDebug
d559 1
a559 1
 ]
d570 3
d574 1
a574 1
	MOV	a1, #(MCPDM_IRQ_DN_EMPTY + MCPDM_IRQ_DN_FULL)
d578 1
d584 3
a586 3
	LDR	a1, [v1, #MCPDM_CTRL]
	ORR	a1, a1, #MCPDM_CTRL_PDMOUTFORMAT	; right justified
	STR	a1, [v1, #MCPDM_CTRL]
d590 2
d595 1
a597 14
;	; Program FIFO threshold value, using our precomputed packet size
;	LDR	a2, DMAPktSz_Audio
; [ AudioDebug
;	DebugReg a2, "Packet size="
; ]
	; Wait for FIFO to fill by DMA
;10
;	LDR	a2, [v1, #MCBSPLP_XBUFFSTAT]
;	CMP	a2, v3
;	BGT	%BT10
; [ AudioDebug
;	LDR	a1, [v1, #MCBSPLP_XBUFFSTAT]
;	DebugReg a1, "Post-prime XBUFFSTAT="
; ]
d600 5
a604 27
;	; TPS Step 18 - turn codec power on
;	LDR	v1, AudioMode
;	ORR	v1, v1, #2
;	STR	v1, AudioMode
;	BL	SetCodecMode
;	; TPS Steps 28-30 - Set and wait for antipop
;	BL	SetAndWaitForAntiPop
;	; TPS Step 32 - Disable codec, for some unmentioned reason
;	BIC	v1, v1, #2
;	STR	v1, AudioMode
;	BL	SetCodecMode
;	; TPS Step 33 - Enable codec again
;	ORR	v1, v1, #2
;	STR	v1, AudioMode
;	BL	SetCodecMode
;	; TPS Steps 34-37 - Enable headset (if needed!)
;	LDR	a1, [a1, #HALDevice_AudioMixer]
;	LDR	a2, MixerSettings+MixerChannel_HeadsetOut*8
;	TST	a2, #1
;	BLEQ	UpdateHeadset

	; omap_mcpdm_start()
	; enable playback channel
	LDR	a1, [v1, #MCPDM_CTRL]
	BIC	a1, a1, #MCPDM_CTRL_SW_DN_RST
	ORR	a1, a1, #MCPDM_CTRL_PDM_DN1_EN
	STR	a1, [v1, #MCPDM_CTRL]
d613 1
a613 1
 [ AudioDebug
d615 1
a615 16
 ]

	; omap_mcpdm_stop()
	; disable playback channel
	LDR	a2, AudioRegs
	LDR	a3, [a2, #MCPDM_CTRL]
	BIC	a3, a3, #MCPDM_CTRL_PDM_DN1_EN
	STR	a3, [a2, #MCPDM_CTRL]

	; omap_mcpdm_playback_close()
	; disable IRQ request generation
	MOV	a3, #(MCPDM_IRQ_DN_EMPTY + MCPDM_IRQ_DN_FULL)
	STR	a3, [a2, #MCPDM_IRQENABLE_CLR]
	; disable DMA request generation
	MOV	a3, #MCPDM_DMA_DN
	STR	a3, [a2, #MCPDM_DMAENABLE_CLR]
d620 1
a620 1
	ANDS	a2, a2, #1
d622 1
d634 2
a635 2
 [ AudioDebug
	CMP	a1, #0
d639 1
a639 1
 ]
d645 15
a659 5
	; Turn codec power off
	LDR	a2, AudioMode
	BIC	a2, a2, #2
	STR	a2, AudioMode
	BL	SetCodecMode
d667 1
a667 1
 [ AudioDebug
d674 2
a675 1
 ]
d679 10
a688 1
	STR	a2, [a3, #MCPDM_IRQENABLE_CLR] ; Make sure we don't get bothered about this again - we can't guarantee when the OS will get round to resetting the audio, and could potentially get stuck in a loop if we allow the IRQ to keep firing
d690 10
a699 2
	STR	a2, [a3, #MCPDM_IRQSTATUS]
	MOV	a1, #1
d701 1
d707 1
a707 1
 [ AudioDebug
d709 2
a710 3
 ]
	; Reload CODEC_MODE with the required value
	; The manual states APLL_RATE can only be changed if the codec is off!
d717 1
a717 1
	EXIT EQ ; Redundant update, ignore
d719 1
a719 1
 [ AudioDebug
d724 3
a726 3
 |
	EXIT NE
 ]
d739 1
a739 1
	; Turn off codec, program default mix params
d744 1
a744 1
 [ AudioDebug
d746 1
a746 5
 ]
	LDR	a3, AudioMode
	BIC	a3, a3, #2
	STR	a3, AudioMode
	BL	SetCodecMode
d772 1
a772 1
	; Stereo speaker predriver output
d778 1
a778 1
	; Stereo carkit output
d784 1
a784 1
	; Mono headset mic
d790 1
a790 1
	; Mono carkit mic
d794 43
d868 1
a868 1
	Entry	"a1-a4,v1-v5,sb"
d883 2
d886 2
a887 1
	LDR	v5, [a1, #HALDevice_AudioMixer]
d889 2
a890 1
	MOV	v2, a3
a891 2
	ADR	a3, SetMixTab
	LDR	v1, OSentries+4*OS_IICOpV
d897 1
a897 1
	; v4 = current CODEC_MODE setting
d899 2
d903 1
a903 1
	DCD	SetMixPredriver
d905 1
a905 1
	DCD	SetMixCarkitOut
d909 1
a909 1
	DCD	SetMixCarkitMic
d914 1
a914 1
	TST	v4, #2
d919 13
a931 15
SetMixPredriver ; PRED* regs
 [ {FALSE}
	; adapt for TWL6040 !?

	MOV	a3, #2
	MOV	a4, #PREDL_CTL
	MOV	v4, #&24 ; 0dB gain, AL2
	CMP	v3, #6*16
	MOVGE	v4, #&14 ; 6dB gain, AL2
	CMP	v3, #-6*16
	MOVLE	v4, #&34 ; -6dB gain, AL2
	TST	v2, #1
	ORREQ	v4, v4, v4, LSL #8 ; R channel settings
	MOVNE	v4, #0 ; Else disable everything
	ADD	a2, v5, #:INDEX:MixerPredriverGain
d936 2
d939 1
a939 1
 [ AudioDebug
d941 3
a943 4
	EXIT EQ
	DebugTX "SetMixPredriver: TPS write failed!"
 ]
 ]
d947 6
a952 2
 [ {FALSE}
	; adapt for TWL6040 !?
a953 19
	MOV	a3, #2
	MOV	a4, #HFL_CTL
	TST	v2, #1
	MOVEQ	v4, #&3E ; AL2, enabled
	ORREQ	v4, v4, #&3E00 ; AR2, enabled
	MOVNE	v4, #0
	ADD	a2, v5, #:INDEX:MixerHandsFreeGain
	LDRH	ip, [a2]
	CMP	ip, v4
	EXIT	EQ
	STRH	v4, [a2]
	BL	TPSWrite
 [ AudioDebug
	CMP	a1, #0
	EXIT EQ
	DebugTX "SetMixHandsFree: TPS write failed!"
 ]
 ]
	EXIT
d955 2
a956 2
SetMixCarkitOut ; PRECK* regs
 [ {FALSE}
d958 2
d968 1
a968 1
	TST	v2, #1
d977 1
a977 1
 [ AudioDebug
d979 4
a982 4
	EXIT EQ
	DebugTX "SetMixCarkitOut: TPS write failed!"
 ]
 ]
d985 21
a1005 23
SetMixSystem ; ARX(L/R)1PGA regs. TODO - Also ARX(L/R)1_APGA_CTL?
 [ {FALSE}
	; adapt for TWL6040 !?

	MOV	a3, #2
	MOV	a4, #ARXR2PGA
	; The ARX(L/R)1PGA regs have both a coarse grain stage (0dB, 6dB, 12dB)
	; and fine-grain stage (-62dB -> 0dB)
	; So first we boost the volume using the coarse grain, then reduce it as
	; necessary by using the fine grain
	MOV	v4, #0
	MOVS	v3, v3, ASR #4
	ADDGT	v4, v4, #&40 ; +6dB
	SUBGTS	v3, v3, #6
	ADDGT	v4, v4, #&40 ; +12dB
	SUBGTS	v3, v3, #6
	MOVGT	v3, #0 ; Don't go any higher than 12dB
	ADDS	v3, v3, #&3F
	MOVLE	v3, #1 ; Clamp to -62dB
	ORR	v4, v4, v3
	TST	v2, #1
	ORREQ	v4, v4, v4, LSL #8 ; L channel settings
	MOVNE	v4, #0 ; Else disable everything
d1010 1
d1012 1
d1014 1
a1014 1
 [ AudioDebug
d1016 1
a1016 1
	EXIT EQ
d1018 1
a1018 2
 ]
 ]
d1023 1
a1023 1
SetMixCarkitMic ; TODO - Implement!
a1037 2
 [ {FALSE}
	; adapt for TWL6040 !?
d1041 2
a1042 2
	LDMIA	ip, {a4,v1} ; a4 = mute flag, v1 = gain
	TST	a4, #1
d1046 4
a1049 6
	; Calculate HS_GAIN_SET
	MOV	ip, #&a ; 0dB gain
	CMP	v1, #6*16
	MOVGE	ip, #&5 ; 6dB gain
	CMP	v1, #-6*16
	MOVLE	ip, #&f ; -6dB gain
d1054 1
a1054 1
	CMP	v1, #0 ; Is the headset currently turned off?
d1056 4
a1059 3
	ORR	a4, a4, ip, LSL #24 ; Set correct gain
	STMEQIA a2, {a3,a4,v1} ; Full programming sequence if headset off
	MOVNE	a4, a4, LSR #16 ; If headset on, only change HS_GAIN_SET
d1063 1
a1063 1
	; ip = HS_GAIN_SET value
d1065 1
a1065 1
 [ AudioDebug
d1068 1
a1068 1
 ]
d1070 1
a1070 1
	EXIT	EQ ; Avoid reprogramming identical values
d1080 2
a1081 2
 [ AudioDebug
	CMP	a1, #0
d1085 1
a1085 1
 ]
a1087 3
 |
	EXIT
 ]
d1090 15
a1104 2
 [ {FALSE}
	; adapt for TWL6040 !?
d1106 9
a1114 7
	DCB HS_SEL, &24 ; 19. Select the headset outputs
	DCB HS_POPN_SET,&14 ; 34. Program antipop bias ramp delay
	DCB HS_POPN_SET,&54 ; 35. Enable Vmid. TODO - Can probably be merged with above.
	DCB HS_GAIN_SET,&00 ; 36. Enable headset output stage & gain setting. NOTE - This gets filled in above.
	DCB HS_POPN_SET,&56 ; 37. Enable ramp
 ]
	DCB 0 ; Terminator
a1116 3
HeadsetDisableSequence
 [ {FALSE}
	; adapt for TWL6040 !?
d1118 88
a1205 7
	DCB HS_POPN_SET,&54 ; Disable ramp
	DCB HS_GAIN_SET,&00 ; Disable gain
	DCB HS_POPN_SET,&14 ; Disable Vmid
	DCB HS_POPN_SET,&34 ; Enable external mute
	DCB HS_SEL,&00 ; Disable headset outputs (for when external mute isn't available)
 ]
	DCB 0 ; Terminator
@


1.1.1.1
log
@  Initial import of OMAP4 HAL
Detail:
  Target platform is the Pandaboard, based on the TI OMAP4 SoC.
  Port is not yet complete, in particular, audio is not yet working.
Admin:
  Submission from Willi Thei
@
text
@@

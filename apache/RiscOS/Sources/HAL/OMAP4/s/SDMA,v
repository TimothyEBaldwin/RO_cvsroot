head	1.8;
access;
symbols
	OMAP4-0_60:1.8
	OMAP4-0_59-1_52_2_3:1.8
	OMAP4-0_59:1.8
	OMAP4-0_58:1.8
	OMAP4-0_57:1.8
	OMAP4-0_56:1.8
	OMAP4-0_55:1.8
	OMAP4-0_54-1_52_2_2:1.8
	OMAP4-0_54:1.8
	OMAP4-0_53:1.8
	OMAP4-0_52-1_52_2_1:1.8
	SMP:1.8.0.2
	SMP_bp:1.8
	OMAP4-0_52:1.8
	OMAP4-0_51:1.8
	OMAP4-0_50:1.8
	OMAP4-0_49:1.8
	OMAP4-0_48:1.8
	OMAP4-0_47:1.8
	OMAP4-0_46:1.8
	OMAP4-0_45:1.7
	OMAP4-0_44:1.7
	OMAP4-0_43:1.6
	OMAP4-0_42:1.6
	OMAP4-0_41:1.6
	OMAP4-0_40:1.6
	OMAP4-0_39:1.6
	OMAP4-0_38:1.5
	OMAP4-0_37:1.5
	OMAP4-0_36:1.5
	OMAP4-0_35:1.5
	OMAP4-0_34:1.5
	OMAP4-0_33:1.4
	OMAP4-0_32:1.4
	OMAP4-0_31:1.4
	OMAP4-0_30:1.4
	OMAP4-0_29:1.4
	OMAP4-0_28:1.4
	OMAP4-0_27:1.4
	OMAP4-0_26:1.4
	OMAP4-0_25:1.4
	OMAP4-0_24:1.4
	OMAP4-0_23:1.4
	OMAP4-0_22:1.3
	OMAP4-0_21:1.3
	OMAP4-0_20:1.3
	OMAP4-0_19:1.3
	OMAP4-0_18:1.3
	OMAP4-0_17:1.3
	OMAP4-0_16:1.3
	OMAP4-0_15:1.3
	OMAP4-0_14:1.3
	OMAP4-0_13:1.3
	OMAP4-0_12:1.3
	OMAP4-0_11:1.3
	OMAP4-0_10:1.3
	OMAP4-0_09:1.3
	OMAP4-0_08:1.3
	OMAP4-0_07:1.3
	OMAP4-0_06:1.2
	OMAP4-0_05:1.2
	OMAP4-0_04:1.1.1.1
	OMAP4-0_03:1.1.1.1
	OMAP4-0_02:1.1.1.1
	OMAP4-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2015.08.14.22.15.35;	author jlee;	state Exp;
branches;
next	1.7;
commitid	cyCuyL8v262tQhxy;

1.7
date	2015.04.08.07.33.53;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	ziZUYwsqx4235Lgy;

1.6
date	2014.12.06.10.46.39;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	xF8TrVZkCuXk6Y0y;

1.5
date	2014.04.22.06.48.06;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	eiJRxQSZyLUP6Exx;

1.4
date	2013.11.01.19.01.19;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	3j2IHKaDTdkbHBbx;

1.3
date	2012.03.25.11.42.58;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	4FjnaYBzkPTA6gYv;

1.2
date	2012.02.11.17.48.09;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	W3PfhFs2h9uBvLSv;

1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;
commitid	M3eV6gzJuoHHMezv;

1.1.1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches;
next	;
commitid	M3eV6gzJuoHHMezv;


desc
@@


1.8
log
@Add additional memory barriers
Detail:
  s/SDMA - Add extra memory barriers to DMA code, ready for when the default NCB memory cache policy is changed from Device to Normal, non-cacheable (increased risk of out-of-order accesses)
  s/PL310 - Add DMB ST implementation that also deals with PL310 synchronisation
Admin:
  Tested on PandaBoard


Version 0.46. Tagged as 'OMAP4-0_46'
@
text
@; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries
        GET     Hdr:HALDevice
        GET     Hdr:DMA
        GET     Hdr:DMADevice
        GET     Hdr:Proc

        GET     hdr.omap4430
        GET     hdr.StaticWS

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  SDMA_Init

        IMPORT  memcpy
        IMPORT  HAL_IRQClear
        IMPORT  HAL_FIQClear
        IMPORT  HAL_CounterDelay
        IMPORT  dmb_st

; Flag to enable gobs of debug output
        GBLL    SDMADebug
SDMADebug SETL  {FALSE}
;SDMADebug SETL {TRUE}

; Flag to disable IRQs during (most) debug output, making high-frequency output more readable
                GBLL    SDMADebugNoIRQ
SDMADebugNoIRQ  SETL    {FALSE} :LAND: SDMADebug

        MACRO
        DumpReg $ptr, $temp, $r
        LCLS    string
string  SETS    "::" :CC: "$r" :CC: ": "
        LDR     $temp, [$ptr, #$r]
        DebugReg $temp, $string
        MEND

SDMA_Init
        Push   "v1-v4,lr"
        ; Do basic reset of SDMA controller, then register the HAL devices
        LDR     v2, L4_sDMA_Log
 [ SDMADebug
        DebugReg v2, "SDMA_Init, L4_sDMA_Log="
 ]
;       MOV     a2, #2          ; this bit is reserved on OMAP4430 (!?)
;       STR     a2, [v2, #DMA4_OCP_SYSCONFIG]
5
        LDR     a2, [v2, #DMA4_SYSSTATUS]
        TST     a2, #DMA4_SYSSTATUS_RESETDONE
        BEQ     %BT5
 [ SDMADebug
        DebugTX "DMA reset OK"
 ]
        ; Autoidle, smart idle
        LDR     a2, =(DMA4_OCP_SYSCONFIG_AUTOIDLE + DMA4_OCP_SYSCONFIG_SIDLEMODE_SMART + DMA4_OCP_SYSCONFIG_MIDLEMODE_SMART)
        STR     a2, [v2, #DMA4_OCP_SYSCONFIG]
        ADR     v1, SDMAWS
        MOV     a1, v1
        ADR     a2, ControllerTemplate
        MOV     a3, #SDMAC_DeviceSize
        BL      memcpy
        STR     sb, [v1, #:INDEX:SDMACWorkspace]
        STR     v2, [v1, #:INDEX:SDMACRegs]

        LDR     a2, =SDMAC_DeviceSize+(SDMA_NumDevices-1)*SDMA_DeviceSize
        ADD     a2, a2, v1
        ADD     a3, v1, #(:INDEX:SDMACPhysList)+SDMA_NumDevices*4
        MOV     a4, #SDMA_NumDevices
10
        SUBS    a4, a4, #1
        STRPL   a2, [a3, #-4]!
        SUBPL   a2, a2, #SDMA_DeviceSize
        BPL     %BT10

        ; This is a bit nasty. We register the DMA controller before we initialise the channels.
        MOV     a2, v1
        MOV     a1, #0
        CallOS  OS_AddDevice

        ADR     v1, SDMAWS + SDMAC_DeviceSize
        MOV     v2, #0
        LDR     v3, L4_sDMA_Log
        ADD     v4, v3, #DMA4_i
10
 [ SDMADebug
        DebugReg v2, "Set up device "
 ]
        MOV     a1, v1
        ADR     a2, ChannelTemplate
        MOV     a3, #SDMA_DeviceSize
        BL      memcpy

        STR     v3, SDMARegs
        MOV     a4, #1
        STR     v4, SDMAChanRegs
        MOV     a4, a4, LSL v2
        STR     sb, SDMAWorkspace
        STR     a4, SDMAIRQMask
        ADR     a3, SDMAWS
        STR     a3, [a1, #HALDevice_DMAController]
        ADD     a2, a1, #:INDEX:SDMADesc
        STR     a2, [a1, #HALDevice_Description]
        ; Simple two digit number -> string conversion
        MOV     a3, #48 ; '0'
        MOV     a4, v2
15
        CMP     a4, #10
        ADDGE   a3, a3, #1
        SUBGE   a4, a4, #10
        BGE     %BT15
        ADD     a2, a2, #ChannelDescNum-ChannelDescStart
        CMP     a3, #48
        STRNEB  a3, [a2], #1
        ADD     a4, a4, #48
        STRB    a4, [a2]

        MOV     a2, a1
        MOV     a1, #0
        CallOS  OS_AddDevice

        ADD     v1, v1, #SDMA_DeviceSize
        ADD     v2, v2, #1
        ADD     v4, v4, #DMA4_CHANNEL_SIZE
        CMP     v2, #SDMA_NumDevices
        BLT     %BT10
 [ SDMADebug
        DebugTX "SDMA_Init done"
 ]
        Pull    "v1-v4,pc"

        LTORG

; DMA controller HAL device

ControllerTemplate
        DCW     HALDeviceType_SysPeri + HALDeviceSysPeri_DMAC
        DCW     HALDeviceID_DMAC_OMAP4
        DCD     HALDeviceBus_Sys + HALDeviceSysBus_NoC
        DCD     &10000          ; API version - 1.0
        DCD     SDMACDesc
        DCD     0               ; Address - N/A
        %       12              ; Reserved
        DCD     SDMACActivate
        DCD     SDMACDeactivate
        DCD     SDMACReset
        DCD     SDMACSleep
        DCD     SDMA_IRQ_0      ; Device. Bit 31 not set, because DMAManager should either use
                                ; the controller to determine the interrupt cause, or the
                                ; channels, but not both.
        DCD     0               ; TestIRQ cannot be called
        %       8
        DCD     SDMACFeatures
        DCD     SDMACEnumerate
        DCD     SDMACAllocate
        DCD     SDMACDeallocate
        DCD     SDMACTestIRQ2
        ASSERT  (. - ControllerTemplate) = HALDevice_DMAC_Size_0_1
        %       4               ; Regs
        %       4               ; HAL Workspace
        %       4               ; Mask of allocated devices
        %       4 * SDMA_NumDevices ; Device list
        ALIGN

        ASSERT (. - ControllerTemplate) = SDMAC_DeviceSize

; DMA 'physical' channel HAL device

ChannelTemplate
        ; Public interface
        DCW     HALDeviceType_SysPeri + HALDeviceSysPeri_DMAB
        DCW     HALDeviceID_DMAB_OMAP4
        DCD     HALDeviceBus_Sys + HALDeviceSysBus_NoC
        DCD     &10000          ; API version - 1.0
        DCD     0               ; Description
        DCD     0               ; Address - N/A
        %       12              ; Reserved
        DCD     SDMAActivate
        DCD     SDMADeactivate
        DCD     SDMAReset
        DCD     SDMASleep
        DCD     SDMA_IRQ_0+(1<<31) ; Device. Bit 31 set because it's shared with all the channels.
        DCD     SDMATestIRQ
        %       8
        DCD     SDMAFeatures
        DCD     0               ; DMA controller device
        DCD     SDMAAbort
        DCD     SDMASetOptions
        DCD     SDMASetCurrentTransfer
        DCD     SDMASetNextTransfer
        DCD     SDMATransferState
        DCD     SDMAIRQClear
        DCD     SDMAStatus
        DCD     SDMASetCurrentTransfer2
        DCD     SDMASetNextTransfer2
        DCD     SDMATransferState2
        ASSERT  (.-ChannelTemplate) = HALDevice_DMA_Size
        ; Private interface
        DCD     0               ; Regs (for the controller)
        DCD     0               ; Regs (for this channel)
        DCD     0               ; HAL Workspace
        DCD     0               ; IRQ mask
        DCD     0               ; Packet size ptr
ChannelDescStart
        =       "OMAP4 system DMA channel "
ChannelDescNum
        DCB     0, 0, 0 ; 2 digit number + terminator
        ALIGN
        ASSERT  (. - ChannelDescStart) = 28 ; hardcoded in hdr.SDMA!

        ASSERT  (. - ChannelTemplate) = SDMA_DeviceSize

SDMACDesc
        = "OMAP4 system DMA controller", 0
        ALIGN

; DMA controller device
; ---------------------

SDMACActivate
        ; Nothing to do?
        MOV     a1, #1
        MOV     pc, lr

SDMACDeactivate
        ; Just do the same as on a reset...
SDMACReset
        Entry   "sb"
        LDR     sb, SDMACWorkspace
        LDR     a3, SDMACRegs
;       MOV     a2, #2          ; this bit is reserved on OMAP4430 (!?)
;       STR     a2, [a3, #DMA4_OCP_SYSCONFIG]
5
        LDR     a2, [a3, #DMA4_SYSSTATUS]
        TST     a2, #DMA4_SYSSTATUS_RESETDONE
        BEQ     %BT5
        ; Set DMA4_GCR to a sensible value:
        ; Arbitration rate=1, no reserved resources, max per-channel FIFO depth 128 bytes
        LDR     a2, =((1 << DMA4_GCR_ARBITRAION_RATE_SHIFT) + 128)
        STR     a2, [a3, #DMA4_GCR]
        ; Reset the allocation list
        MOV     a2, #0
        STR     a2, SDMACAllocated
        ; Give INTC a bit of a kick, since any pending IRQs will no longer look like they came
        ; from us, causing DMAManager to fail to clear them
        MOV     a1, #SDMA_IRQ_0 ; Only need to clear the first IRQ since all we're interested in is the write to INTCPS_CONTROL
        BL      HAL_IRQClear
;       MOV     a1, #SDMA_IRQ_0
;       BL      HAL_FIQClear ; Just in case
        EXIT

SDMACSleep
        ; Nothing we can do
        MOV     a1, #0
        MOV     pc, lr

SDMACFeatures
        MOV     a1, #0
        MOV     pc, lr

SDMACEnumerate
        ADR     a1, SDMACPhysList
        MOV     a2, #SDMA_NumDevices
        MOV     pc, lr

SDMACAllocate
        ; a2 = RISC OS-speak logical DMA channel
        ; In OMAP speak, this is the value to be programmed into the DMA4_CCRi register,
        ; i.e. 0 for CPU synchronisation, else the DMA request ID + 1
        ; For the moment, we assume the user is smart enough not to request the same logical ID
        ; multiple times, because that will result in bad things (unless they're chained
        ; together)
        ; This allocation scheme also means we're technically limited to using 1 CPU
        ; synchronised channel at once :(
        Entry   "sb"
        LDR     sb, SDMACWorkspace
 [ SDMADebug
        DebugReg a2, "SDMACAllocate: "
 ]
        MRS     lr, CPSR
        ORR     a4, lr, #I32_bit
        MSR     CPSR_c, a4 ; interrupts off
        LDR     a3, SDMACAllocated
        CLZ     a4, a3
        CMP     a4, #32-SDMA_NumDevices ; Assume that channels 0 to SDMA_NumDevices are to be used
        MOVEQ   a1, #0 ; No controllers left
        BEQ     %FT10
        MOV     ip, #1
        ORR     a3, a3, ip, ROR a4
        STR     a3, SDMACAllocated
        ; Grab the pointer to the DMA channel device
        ADR     a1, SDMACPhysList
        RSB     a4, a4, #32
        LDR     a1, [a1, a4, LSL #2]
        ; Set the packet size pointer, if appropriate
        CMP     a2, #AUDIO_DMA_CHAN+1
        ADREQ   a3, DMAPktSz_Audio
        MOVNE   a3, #0
        STR     a3, SDMAPacketSizePtr
        ; Program the request ID into the channel registers
        LDR     a3, SDMARegs
        AND     ip, a2, #DMA4_CCR_SYNCHRO_CONTROL
        AND     a2, a2, #&60
        ORR     ip, ip, a2, LSL #(DMA4_CCR_SYNCHRO_CONTROL_UPPER_SHIFT - 5)
        STR     ip, [a3, #DMA4_i+DMA4_CCRi]
10
        MSR     CPSR_c, lr ; Interrupts restored
 [ SDMADebug
        DebugReg a4, "<-Channel: "
        DebugReg a1, "<-Device: "
 ]
        EXIT

SDMACDeallocate
        ; For API 0.x, we only get given the logical channel #. Which is bad, because
        ; memory-to-memory transfers all use logical channel 0, so there could easily be
        ; multiple instances of the same logical channel.
        ; So for API 1.x, we also get passed a pointer to the channel which we're deallocating
        ; (in a3)
 [ SDMADebug
        Entry   "sb"
        LDR     sb, SDMACWorkspace
        DebugReg a2, "SDMACDeallocate: "
        DebugReg a3, "  Ptr: "
 ]
        ; Assuming a3 is valid, we can just load the IRQ mask word and use that to update our
        ; allocation mask
        MRS     ip, CPSR
        LDR     a3, [a3, #:INDEX:SDMAIRQMask]
        ORR     a4, ip, #I32_bit
        MSR     CPSR_c, a4 ; interrupts off
        LDR     a2, SDMACAllocated
        BIC     a2, a2, a3
        STR     a2, SDMACAllocated
        MSR     CPSR_c, ip ; Interrupts restored
 [ SDMADebug
        CLZ     a1, a3
        RSB     a1, a1, #31
        DebugReg a1, "  Was channel #"
        EXIT
 |
        MOV     pc, lr
 ]

SDMACTestIRQ2
        ; Return index of interrupting channel (as per Enumerate list), or -1 for none
 [ SDMADebug
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMACWorkspace
        DebugTX "SDMACTestIRQ2:"
 ]
        LDR     a2, SDMACRegs
        LDR     a2, [a2, #DMA4_IRQSTATUS_L0]
        CLZ     a1, a2
        RSB     a1, a1, #31 ; Device index or -1 for none
 [ SDMADebug
        DebugReg a1, "="
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
        EXIT
 |
        MOV     pc, lr
 ]


; DMA channel device
; ------------------

SDMAActivate
        ; The only thing we do here is enable the IRQ for the device
 [ SDMADebug
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
        DebugReg a1, "SDMAActivate: "
 ]
        LDR     a2, SDMARegs
        MRS     a3, CPSR
        LDR     ip, SDMAIRQMask
        ORR     a4, a3, #I32_bit
        MSR     CPSR_c, a4 ; interrupts off
        LDR     a4, [a2, #DMA4_IRQENABLE_L0]
        ORR     a4, a4, ip
        STR     a4, [a2, #DMA4_IRQENABLE_L0] ; Unmask the interrupt
        MOV     a1, #1
        MSR     CPSR_c, a3 ; Interrupts restored
 [ SDMADebug
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
        EXIT
 |
        MOV     pc, lr
 ]

SDMAAbort ; Docs say Abort musn't block, but Deactivate shouldn't result in a significant block so we'll just use that
SDMADeactivate
        Entry   "v1,sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
 [ SDMADebug
        DebugReg a1, "SDMAAbort/Deactivate: "
 ]
        ; Halt any active transfer
        LDR     a2, SDMAChanRegs
        LDR     a3, [a2, #DMA4_CCRi]
        BIC     a3, a3, #DMA4_CCR_ENABLE ; Clear ENABLE bit
        STR     a3, [a2, #DMA4_CCRi]
10
        LDR     a3, [a2, #DMA4_CCRi]
        TST     a3, #(DMA4_CCR_RD_ACTIVE + DMA4_CCR_WR_ACTIVE) ; Check RD_ACTIVE & WR_ACTIVE
        BNE     %BT10
        DMB     SY ; If this was a write to RAM, ensure CPU sees the final data
        ; Now disable interrupts (or should we do this first?)
        LDR     a2, SDMARegs
        MRS     v1, CPSR
        LDR     ip, SDMAIRQMask
        ORR     a4, v1, #I32_bit
        MSR     CPSR_c, a4 ; Interrupts off
        LDR     a1, [a2, #DMA4_IRQSTATUS_L0]
        LDR     a4, [a2, #DMA4_IRQENABLE_L0]
        TST     a1, ip
        BIC     a4, a4, ip
        STR     a4, [a2, #DMA4_IRQENABLE_L0] ; Mask the interrupt
        ; If the channel was interrupting, we must call HAL_IRQClear to (potentially) restart
        ; interrupt processing
        ; todo - this code should probably be in the OS, like all the other code that's meant
        ; to call HAL_IRQClear
        MOVNE   a1, #SDMA_IRQ_0
        BLNE    HAL_IRQClear
        MSR     CPSR_c, v1 ; Interrupts restored
        ; Done!
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
        EXIT

SDMAReset
 [ SDMADebug
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
        DebugReg a1, "SDMAReset: "
 ]
        LDR     a2, SDMARegs
        MRS     a3, CPSR
        LDR     ip, SDMAIRQMask
        ORR     a4, a3, #I32_bit
        MSR     CPSR_c, a4 ; Interrupts off
        LDR     a4, [a2, #DMA4_IRQENABLE_L0]
        BIC     a4, a4, ip
        STR     a4, [a2, #DMA4_IRQENABLE_L0] ; Mask the interrupt
        MSR     CPSR_c, a3 ; Interrupts restored
        ; Now reset the channel registers to something sensible
        MOV     ip, #DMA4_CCR_SYNCHRO_CONTROL
        LDR     a2, SDMAChanRegs
        ORR     ip, ip, #DMA4_CCR_SYNCHRO_CONTROL_UPPER
        LDR     a3, [a2, #DMA4_CCRi]
        MOV     a1, #0
        AND     a3, a3, ip ; Mask everything except the SYNCHRO_CONTROL field
        STR     a3, [a2, #DMA4_CCRi]
10
        LDR     a3, [a2, #DMA4_CCRi]
        TST     a3, #(DMA4_CCR_RD_ACTIVE + DMA4_CCR_WR_ACTIVE) ; Check RD_ACTIVE & WR_ACTIVE
        BNE     %BT10
        MVN     a4, #0
        STR     a1, [a2, #DMA4_CLNK_CTRLi] ; Disable channel linking
        STR     a1, [a2, #DMA4_CICRi] ; Disable all interrupts
        STR     a4, [a2, #DMA4_CSRi] ; Reset interrupt status bits
        ; These registers don't really need to be reset, because we'll reprogram them as and
        ; when needed.
;       STR     a1, [a2, #DMA4_CSDPi]
;       STR     a1, [a2, #DMA4_CENi]
;       STR     a1, [a2, #DMA4_CFNi]
;       STR     a1, [a2, #DMA4_CSSAi]
;       STR     a1, [a2, #DMA4_CDSAi]
;       STR     a1, [a2, #DMA4_CSEIi]
;       STR     a1, [a2, #DMA4_CSFIi]
;       STR     a1, [a2, #DMA4_CDEIi]
;       STR     a1, [a2, #DMA4_CDFIi]
;       STR     a1, [a2, #DMA4_CDACi]
;       STR     a1, [a2, #DMA4_COLORi]
        ; These registers are readonly and thus can't be reset
;       STR     a1, [a2, #DMA4_CSACi]
;       STR     a1, [a2, #DMA4_CCENi]
;       STR     a1, [a2, #DMA4_CCFNi]
        ; Finished!
 [ SDMADebug
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
        EXIT
 |
        MOV     pc, lr
 ]

SDMASleep
        ; Nothing we can do
        MOV     a1, #0
        MOV     pc, lr

SDMATestIRQ
        ; This interface doesn't work too well, due to there being many more interrupt channels
        ; than IRQ lines. Hence the addition of TestIRQ2 to the controller device.
        ; This old interface is retained purely for backwards-compatability
 [ SDMADebug
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
        DebugReg a1, "SDMATestIRQ: "
 ]
        LDR     a2, SDMARegs
        LDR     a3, SDMAIRQMask
        LDR     a4, [a2, #DMA4_IRQSTATUS_L0]
        ANDS    a1, a4, a3
        MOVNE   a1, #1 ; 1 = interrupting, 0 = not interrupting
 [ SDMADebug
        DebugReg a1, "<-"
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
        EXIT
 |
        MOV     pc, lr
 ]

SDMAFeatures
        ; Check SYNCHRO_CONTROL field to see if this is CPU synchronised (memory-to-memory) or
        ; device synchronised
        LDR     a2, SDMAChanRegs
        MOV     a3, #DMA4_CCR_SYNCHRO_CONTROL
        LDR     a2, [a2, #DMA4_CCRi]
        ORR     a3, a3, #DMA4_CCR_SYNCHRO_CONTROL_UPPER
        TST     a2, a3
        MOVEQ   a1, #DMAFeaturesFlag_DualAddress+DMAFeaturesFlag_NoInitIRQ
        MOVNE   a1, #DMAFeaturesFlag_NoInitIRQ
        MOV     pc, lr

SDMASetOptions
        ; a2: bit 0:  1=memory->device, 0=device->memory (iff device DMA)
        ;     bits 1-5: transfer unit width, bytes
        ;     bits 6-8: cycle speed, ignored
        ;     bits 9-12: minimum delay between transfers on same physical channel, ignored
        ;     bit 13: 1=disable burst transactions
        ;     bit 14: 1=bypass clock synchronisation, ignored
        ; a3: device address for device DMA
        ; We use this call to program everything except the transfer source/dest address (and
        ; the transfer length)
 [ SDMADebug
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
        DebugReg a1, "SDMASetOptions: "
        DebugReg a2, "->Flags: "
        DebugReg a3, "->Addr: "
 |
        Entry
 ]
        LDR     a4, SDMAChanRegs
        MOV     lr, #DMA4_CCR_SYNCHRO_CONTROL
        ; Calculate CCR
        LDR     ip, [a4, #DMA4_CCRi]
        ORR     lr, lr, #DMA4_CCR_SYNCHRO_CONTROL_UPPER
        ANDS    ip, ip, lr ; Clear everything except the SYNCHRO bits
        ; SYNCHRO_CONTROL == 0 -> is memory-to-memory channel
        ORREQ   ip, ip, #(DMA4_CCR_DST_AMODE_POST_INC + DMA4_CCR_SRC_AMODE_POST_INC) ; Post-increment src & dest
        ORREQ   ip, ip, #(DMA4_CCR_SEL_SRC_DST_SYNC) ; Source-synchronised for mem-to-mem
        BEQ     %FT10
        ; Else this is some kind of device channel. Program appropriately.
        TST     a2, #DMASetOptionsFlag_Write
        ORREQ   ip, ip, #DMA4_CCR_DST_AMODE_POST_INC ; Post-increment dest for device->memory
        STREQ   a3, [a4, #DMA4_CSSAi] ; Source addr = Device address
        ORRNE   ip, ip, #DMA4_CCR_SRC_AMODE_POST_INC ; Post-increment src for memory->device
        STRNE   a3, [a4, #DMA4_CDSAi] ; Dest addr = Device address
        ORRNE   ip, ip, #DMA4_CCR_PREFETCH ; Enable prefetch for mem->device only
        ; Configure for packet transfers if required
        LDR     a3, SDMAPacketSizePtr
        CMP     a3, #0
        ; FS = BS = 1 ==> packet transfer; higher priority (R + W)
        ORRNE   ip, ip, #(DMA4_CCR_FS + DMA4_CCR_READ_PRIORITY)
        ORRNE   ip, ip, #(DMA4_CCR_BS + DMA4_CCR_PREFETCH)
        ORRNE   ip, ip, #DMA4_CCR_WRITE_PRIORITY
10
        STR     ip, [a4, #DMA4_CCRi]
        ; Calculate CSDP
        AND     a3, a2, #DMASetOptionsMask_Width ; Get transfer unit size
        CMP     a3, #2:SHL:DMASetOptionsShift_Width
        MOVGT   a3, #(DMA4_CSDP_SRC_PACKED + DMA4_CSDP_DATA_TYPE_32BIT) ; 32bit or larger data
        MOVEQ   a3, #(DMA4_CSDP_SRC_PACKED + DMA4_CSDP_DATA_TYPE_16BIT) ; 16bit data
        MOVLT   a3, #(DMA4_CSDP_SRC_PACKED + DMA4_CSDP_DATA_TYPE_8BIT) ; 8bit data
        ORR     a3, a3, #(DMA4_CSDP_DST_PACKED + DMA4_CSDP_WRITE_MODE_LAST_WRNP) ; DST_PACKED, last write nonposted
        TST     a2, #DMASetOptionsFlag_NoBursts
        ORREQ   a3, a3, #DMA4_CSDP_SRC_BURST_EN_64B ; Source burst of 64 bytes
        ORREQ   a3, a3, #DMA4_CSDP_DST_BURST_EN_64B ; Dest burst of 64 bytes
        TST     ip, lr
        BEQ     %FT20
        ; If it's a device transfer, disable packing for the device side
        TST     a2, #DMASetOptionsFlag_Write
        BICEQ   a3, a3, #(DMA4_CSDP_SRC_PACKED) ; Disable src packing for device->memory
        BICNE   a3, a3, #(DMA4_CSDP_DST_PACKED) ; Disable dest packing for memory->device
20
        STR     a3, [a4, #DMA4_CSDPi]
        ; Enable frame or packet interrupt - this should trigger when the transfer completes
        LDR     a3, SDMAPacketSizePtr
        CMP     a3, #0
        MOVNE   a1, #DMA4_CICR_BLOCK_IE ; fires after all packets sent
        MOVEQ   a1, #DMA4_CICR_FRAME_IE
        STR     a1, [a4, #DMA4_CICRi]
        ; Done
 [ SDMADebug
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
 ]
        EXIT

SDMASetCurrentTransfer
        ; a2: buffer physical address
        ; a3: buffer length, bytes
        ; a4: bit 0: 1="stop and raise TC signal when this transfer completes". Ignore?
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
 [ SDMADebug
        DebugReg a1, "SDMASetCurrentTransfer: "
        DebugReg a2, "->Buffer: "
        DebugReg a3, "->Length: "
 ]
        LDR     a4, SDMAChanRegs
        LDR     ip, [a4, #DMA4_CCRi]
        TST     ip, #DMA4_CCR_SRC_AMODE_POST_INC
        LDR     lr, [a4, #DMA4_CSDPi]
        STREQ   a2, [a4, #DMA4_CDSAi]   ; device->memory, so set dest addr
        AND     lr, lr, #3              ; Get element size
        STRNE   a2, [a4, #DMA4_CSSAi]   ; memory->device, so set src addr
        MOV     a3, a3, LSR lr          ; Get number of elements in buffer
        STR     a3, [a4, #DMA4_CENi] ; todo - what to do if we're asked to transfer too much data?
        ; Check if this is a packet transfer, and program appropriately
        LDR     a2, SDMAPacketSizePtr
        CMP     a2, #0
        MOVEQ   a2, #1  ; Only 1 frame to transfer for non packet transfers
        BEQ     %FT10
        LDR     a2, [a2]
        TST     ip, #DMA4_CCR_SRC_AMODE_POST_INC
        STREQ   a2, [a4, #DMA4_CSFIi]   ; device->memory, put it here
        STRNE   a2, [a4, #DMA4_CDFIi]   ; memory->device, put it here
        ; size of one packet must go here
        STR     a2, [a4, #DMA4_CENi]
        ; calculate number of frames (assumption: packet size is power of 2)
        CLZ     lr, a2
        RSB     lr, lr, #31
        MOV     a2, a3, LSR lr
10
        STR     a2, [a4, #DMA4_CFNi]
        ; Now just enable it?
        ORR     ip, ip, #(DMA4_CCR_ENABLE+DMA4_CCR_FS) ; Frame synchronised by default if not packet synchronised
 [ SDMADebug
        DebugReg ip, "::DMA4_CCRi: "
        DumpReg a4, a1, DMA4_CLNK_CTRLi
        DumpReg a4, a1, DMA4_CICRi
        DumpReg a4, a1, DMA4_CSRi
        DumpReg a4, a1, DMA4_CSDPi
        DumpReg a4, a1, DMA4_CENi
        DumpReg a4, a1, DMA4_CFNi
        DumpReg a4, a1, DMA4_CSSAi
        DumpReg a4, a1, DMA4_CDSAi
        DumpReg a4, a1, DMA4_CSEIi
        DumpReg a4, a1, DMA4_CSFIi
        DumpReg a4, a1, DMA4_CDEIi
        DumpReg a4, a1, DMA4_CDFIi
        DumpReg a4, a1, DMA4_CSACi
        DumpReg a4, a1, DMA4_CDACi
        DumpReg a4, a1, DMA4_CCENi
        DumpReg a4, a1, DMA4_CCFNi
        DumpReg a4, a1, DMA4_COLORi
 ]
        BL      dmb_st ; If this is a read from RAM, ensure CPU has finished writing. If this is a write to RAM, ensure we don't have a buffered write which is going to clobber the DMA results.
        STR     ip, [a4, #DMA4_CCRi]
 [ SDMADebug
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
 ]
        EXIT

SDMASetNextTransfer
        ; N/A
        MOV     pc, lr

SDMATransferState
        ; We need to return the current read/write address, and the amount left to transfer...
        ; I think
 [ SDMADebug
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
        DebugReg a1, "SDMATransferState: "
 ]
        MRS     ip, CPSR
        LDR     a3, SDMAChanRegs
        ORR     a4, ip, #I32_bit
        MSR     CPSR_c, a4 ; Interrupts off
 [ SDMADebug
        DumpReg a3, a2, DMA4_CCRi
        DumpReg a3, a2, DMA4_CLNK_CTRLi
        DumpReg a3, a2, DMA4_CICRi
        DumpReg a3, a2, DMA4_CSRi
        DumpReg a3, a2, DMA4_CSDPi
        DumpReg a3, a2, DMA4_CENi
        DumpReg a3, a2, DMA4_CFNi
        DumpReg a3, a2, DMA4_CSSAi
        DumpReg a3, a2, DMA4_CDSAi
        DumpReg a3, a2, DMA4_CSEIi
        DumpReg a3, a2, DMA4_CSFIi
        DumpReg a3, a2, DMA4_CDEIi
        DumpReg a3, a2, DMA4_CDFIi
        DumpReg a3, a2, DMA4_CSACi
        DumpReg a3, a2, DMA4_CDACi
        DumpReg a3, a2, DMA4_CCENi
        DumpReg a3, a2, DMA4_CCFNi
        DumpReg a3, a2, DMA4_COLORi
 ]
        LDR     a1, [a3, #DMA4_CCRi]
        LDR     a2, [a3, #DMA4_CCENi] ; Get current element number
        LDR     a4, [a3, #DMA4_CENi] ; Transfer length
        TST     a1, #DMA4_CCR_SRC_AMODE_POST_INC
        LDR     a1, [a3, #DMA4_CSDPi]
        LDREQ   a3, [a3, #DMA4_CDSAi] ; Get correct source address
        AND     a1, a1, #3 ; Get element size
        LDRNE   a3, [a3, #DMA4_CSSAi]
        MOV     a2, a2, LSL a1
        MOV     a4, a4, LSL a1
        ADD     a1, a3, a2 ; Update source address
        SUB     a2, a4, a2 ; Update transfer length
        MSR     CPSR_c, ip ; Interrupts restored
        DMB     SY ; If this is a write to RAM, ensure CPU sees the data we're saying is there
 [ SDMADebug
        DebugReg a1, "<-Addr: "
        DebugReg a2, "<-Length: "
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
        EXIT
 |
        MOV     pc, lr
 ]

SDMAIRQClear
        Entry   "v1,sb"
 [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
 ]
        LDR     sb, SDMAWorkspace
 [ SDMADebug
        DebugReg a1, "SDMAIRQClear: "
 ]
        MRS     v1, CPSR
        LDR     ip, SDMAChanRegs
        ORR     a4, v1, #I32_bit
        LDR     a2, SDMARegs
        MVN     a3, #0
        LDR     a1, SDMAIRQMask
        MSR     CPSR_c, a4 ; Interrupts off
        STR     a3, [ip, #DMA4_CSRi] ; Clear all active interrupts
        STR     a1, [a2, #DMA4_IRQSTATUS_L0] ; Clear main IRQ bit
        MOV     a1, #SDMA_IRQ_0
        BL      HAL_IRQClear ; Clear IRQ (todo - should be in DMAManager?)
        MSR     CPSR_c, v1 ; Interrupts restored
 [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
 ]
        EXIT

SDMAStatus
 [ SDMADebug
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
        DebugReg a1, "SDMAStatus: "
 ]
        LDR     a2, SDMAChanRegs
        MOV     a1, #DMAStatusFlag_NoUnstarted ; We don't support double-buffering, so NoUnstarted must always be set
        LDR     a2, [a2, #DMA4_CCRi]
        TST     a2, #DMA4_CCR_ENABLE ; Check ENABLE bit
        ORREQ   a1, a1, #DMAStatusFlag_Overrun ; If we're inactive, we're in the overrun state
        DMB     SY ; If this is a write to RAM, ensure CPU sees the data we're saying is there
 [ SDMADebug
        DebugReg a1, "<-Flags: "
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
        EXIT
 |
        MOV     pc, lr
 ]

SDMASetCurrentTransfer2
        ; a2: source physical address
        ; a3: dest physical address
        ; a4: buffer length, bytes
        ; a5: bit 0: 1="stop and raise TC signal when this transfer completes". Ignore?
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
 [ SDMADebug
        DebugReg a1, "SDMASetCurrentTransfer2: "
        DebugReg a2, "->Source: "
        DebugReg a3, "->Dest: "
        DebugReg a4, "->Length: "
 ]
        LDR     ip, SDMAChanRegs
        LDR     a1, [ip, #DMA4_CSDPi]
        STR     a2, [ip, #DMA4_CSSAi] ; set src addr
        AND     a1, a1, #3 ; Get element size
        STR     a3, [ip, #DMA4_CDSAi] ; set dest addr
        MOV     a4, a4, LSR a1 ; Get number of elements in buffer
        STR     a4, [ip, #DMA4_CENi] ; todo - what to do if we're asked to transfer too much data?
        MOV     a2, #1
        STR     a2, [ip, #DMA4_CFNi] ; Only 1 frame to transfer
        ; Now just enable it?
        ORR     a1, a1, #DMA4_CCR_ENABLE
        BL      dmb_st ; If this is a read from RAM, ensure CPU has finished writing. If this is a write to RAM, ensure we don't have a buffered write which is going to clobber the DMA results.
        STR     a1, [ip, #DMA4_CCRi]
 [ SDMADebug
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
 ]
        EXIT

SDMASetNextTransfer2
        ; N/A
        MOV     pc, lr

SDMATransferState2
        ; We need to return the current read & write address, and the amount left to transfer... I think
 [ SDMADebug
        Entry   "sb"
  [ SDMADebugNoIRQ
        PHPSEI  lr,sb
        Push    "lr"
  ]
        LDR     sb, SDMAWorkspace
        DebugReg a1, "SDMATransferState2: "
 ]
        MRS     ip, CPSR
        LDR     a2, SDMAChanRegs
        ORR     a4, ip, #I32_bit
        MSR     CPSR_c, a4 ; Interrupts off
        LDR     a1, [a2, #DMA4_CSDPi]
        LDR     a3, [a2, #DMA4_CCENi] ; Get current element number
        AND     a1, a1, #3 ; Get element size
        LDR     a4, [a2, #DMA4_CENi] ; Transfer length
        MOV     a3, a3, LSL a1
        MOV     a4, a4, LSL a1
        LDR     a1, [a2, #DMA4_CSSAi]
        LDR     a2, [a2, #DMA4_CDSAi]
        ADD     a1, a1, a3 ; Update source address
        ADD     a2, a2, a3 ; Update dest address
        SUB     a3, a4, a3 ; Update transfer length
        MSR     CPSR_c, ip ; Interrupts restored
        DMB     SY ; If this is a write to RAM, ensure CPU sees the data we're saying is there
 [ SDMADebug
        DebugReg a1, "<-Source: "
        DebugReg a2, "<-Dest: "
        DebugReg a3, "<-Length: "
  [ SDMADebugNoIRQ
        Pull    "lr"
        PLP     lr
  ]
        EXIT
 |
        MOV     pc, lr
 ]

        LTORG

        END
@


1.7
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Built, but not tested.

Version 0.44. Tagged as 'OMAP4-0_44'
@
text
@d41 1
d447 1
a667 1
 [ SDMADebug
d674 1
a677 2
 |
        Entry
d727 1
d790 1
d846 1
a862 1
 [ SDMADebug
d869 1
d886 1
d893 1
a894 3
 |
        MOV     pc, lr
 ]
d927 1
@


1.6
log
@Change over to reassigned bus types
Note, the SDIO controller was previously misreported as being on L4, when in fact it's on L3.

Version 0.39. Tagged as 'OMAP4-0_39'
@
text
@a37 2
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
@


1.5
log
@Improvements to audio FIFOing
hdr/Audio: split AudioChannels to allow new AudioDMASize field to differentiate OMAP4430 v 4460.
Audio.s: handle FIFO underflow events of the audio stream, differentiate FIFO sizes for OMAP4430 v 4460.
SDMA.s: add prefetch flag in DMA control for audio channel
Submission from Willi Theiss.

Version 0.34. Tagged as 'OMAP4-0_34'
@
text
@d161 1
a161 1
        DCD     HALDeviceBus_Interconnect + HALDeviceInterconnectBus_L3
d195 1
a195 1
        DCD     HALDeviceBus_Interconnect + HALDeviceInterconnectBus_L3
@


1.4
log
@Refactor IIC calls to use RISCOS_IICOpV
Copy changes from OMAP3-0_90 to OMAP4.
Built, but not tested.

Version 0.23. Tagged as 'OMAP4-0_23'
@
text
@d627 1
a627 1
        ORRNE   ip, ip, #DMA4_CCR_BS
@


1.3
log
@Bulk expand of tabs.
Helps to make tracking changes between OMAP3 and OMAP4 less eye watering, but otherwise functionally the same as 0.06.

Version 0.07. Tagged as 'OMAP4-0_07'
@
text
@a43 7
        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND

@


1.2
log
@Update to OMAP4 HAL.
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.Audio
    added further definitions for TWL6040 audio chip
    changes for working sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.SDMA
    added further register descriptions according OMAP4 TRM
    changes for working sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.UART
    added further register descriptions according OMAP4 TRM
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.omap4430
    added definitions for OMAP4460 (Panda ES)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.board
    adjusted max pixel-clock rate
    order of UART entries changed
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Boot
    don't reset debug UART
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Top
    modifications according to OMAP3 version
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.debug
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.UART
    changes according to hdr.UART changes; HAL_UARTModemControl
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.RAM
    use definitions from hdr.SDMA
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.SDMA
    use definitions from hdr.SDMA
    changes for working sound support
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Video
    added code to VideoDevice_Activate (enable DSS power)
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.omap4430
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.hdr.SDMA
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.Audio
OMAP4Dev.castle.RiscOS.Sources.HAL.OMAP4.s.SDMA
    changes for working sound support

Submissions from Willi Theiss. Compiles, but not tested here.

Version 0.05. Tagged as 'OMAP4-0_05'
@
text
@d16 34
a49 34
	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:Machine.<Machine>
	GET	Hdr:ImageSize.<ImageSize>
	$GetIO

	GET	Hdr:OSEntries
	GET	Hdr:HALEntries
	GET	Hdr:HALDevice
	GET	Hdr:DMA
	GET	Hdr:DMADevice
	GET	Hdr:Proc

	GET	hdr.omap4430
	GET	hdr.StaticWS

	AREA	|Asm$$Code|, CODE, READONLY, PIC

	EXPORT	SDMA_Init

	IMPORT	memcpy
	IMPORT	DebugHALPrint
	IMPORT	DebugHALPrintReg
	IMPORT	HAL_IRQClear
	IMPORT	HAL_FIQClear
	IMPORT	HAL_CounterDelay

	MACRO
	CallOS	$entry
	ASSERT	$entry <= HighestOSEntry
	MOV	lr, pc
	LDR	pc, OSentries + 4*$entry
	MEND
d52 3
a54 3
	GBLL	SDMADebug
SDMADebug SETL	{FALSE}
;SDMADebug SETL	{TRUE}
d57 2
a58 2
		GBLL	SDMADebugNoIRQ
SDMADebugNoIRQ	SETL	{FALSE} :LAND: SDMADebug
d60 7
a66 7
	MACRO
	DumpReg $ptr, $temp, $r
	LCLS	string
string	SETS	"::" :CC: "$r" :CC: ": "
	LDR	$temp, [$ptr, #$r]
	DebugReg $temp, $string
	MEND
d69 3
a71 3
	Push   "v1-v4,lr"
	; Do basic reset of SDMA controller, then register the HAL devices
	LDR	v2, L4_sDMA_Log
d73 1
a73 1
	DebugReg v2, "SDMA_Init, L4_sDMA_Log="
d75 2
a76 2
;	MOV	a2, #2		; this bit is reserved on OMAP4430 (!?)
;	STR	a2, [v2, #DMA4_OCP_SYSCONFIG]
d78 21
a98 21
	LDR	a2, [v2, #DMA4_SYSSTATUS]
	TST	a2, #DMA4_SYSSTATUS_RESETDONE
	BEQ	%BT5
 [ SDMADebug
	DebugTX "DMA reset OK"
 ]
	; Autoidle, smart idle
	LDR	a2, =(DMA4_OCP_SYSCONFIG_AUTOIDLE + DMA4_OCP_SYSCONFIG_SIDLEMODE_SMART + DMA4_OCP_SYSCONFIG_MIDLEMODE_SMART)
	STR	a2, [v2, #DMA4_OCP_SYSCONFIG]
	ADR	v1, SDMAWS
	MOV	a1, v1
	ADR	a2, ControllerTemplate
	MOV	a3, #SDMAC_DeviceSize
	BL	memcpy
	STR	sb, [v1, #:INDEX:SDMACWorkspace]
	STR	v2, [v1, #:INDEX:SDMACRegs]

	LDR	a2, =SDMAC_DeviceSize+(SDMA_NumDevices-1)*SDMA_DeviceSize
	ADD	a2, a2, v1
	ADD	a3, v1, #(:INDEX:SDMACPhysList)+SDMA_NumDevices*4
	MOV	a4, #SDMA_NumDevices
d100 14
a113 14
	SUBS	a4, a4, #1
	STRPL	a2, [a3, #-4]!
	SUBPL	a2, a2, #SDMA_DeviceSize
	BPL	%BT10

	; This is a bit nasty. We register the DMA controller before we initialise the channels.
	MOV	a2, v1
	MOV	a1, #0
	CallOS	OS_AddDevice

	ADR	v1, SDMAWS + SDMAC_DeviceSize
	MOV	v2, #0
	LDR	v3, L4_sDMA_Log
	ADD	v4, v3, #DMA4_i
d116 1
a116 1
	DebugReg v2, "Set up device "
d118 18
a135 18
	MOV	a1, v1
	ADR	a2, ChannelTemplate
	MOV	a3, #SDMA_DeviceSize
	BL	memcpy

	STR	v3, SDMARegs
	MOV	a4, #1
	STR	v4, SDMAChanRegs
	MOV	a4, a4, LSL v2
	STR	sb, SDMAWorkspace
	STR	a4, SDMAIRQMask
	ADR	a3, SDMAWS
	STR	a3, [a1, #HALDevice_DMAController]
	ADD	a2, a1, #:INDEX:SDMADesc
	STR	a2, [a1, #HALDevice_Description]
	; Simple two digit number -> string conversion
	MOV	a3, #48 ; '0'
	MOV	a4, v2
d137 19
a155 19
	CMP	a4, #10
	ADDGE	a3, a3, #1
	SUBGE	a4, a4, #10
	BGE	%BT15
	ADD	a2, a2, #ChannelDescNum-ChannelDescStart
	CMP	a3, #48
	STRNEB	a3, [a2], #1
	ADD	a4, a4, #48
	STRB	a4, [a2]

	MOV	a2, a1
	MOV	a1, #0
	CallOS	OS_AddDevice

	ADD	v1, v1, #SDMA_DeviceSize
	ADD	v2, v2, #1
	ADD	v4, v4, #DMA4_CHANNEL_SIZE
	CMP	v2, #SDMA_NumDevices
	BLT	%BT10
d157 1
a157 1
	DebugTX	"SDMA_Init done"
d159 1
a159 1
	Pull	"v1-v4,pc"
d161 1
a161 1
	LTORG
d166 27
a192 27
	DCW	HALDeviceType_SysPeri + HALDeviceSysPeri_DMAC
	DCW	HALDeviceID_DMAC_OMAP4
	DCD	HALDeviceBus_Interconnect + HALDeviceInterconnectBus_L3
	DCD	&10000		; API version - 1.0
	DCD	SDMACDesc
	DCD	0		; Address - N/A
	%	12		; Reserved
	DCD	SDMACActivate
	DCD	SDMACDeactivate
	DCD	SDMACReset
	DCD	SDMACSleep
	DCD	SDMA_IRQ_0	; Device. Bit 31 not set, because DMAManager should either use
				; the controller to determine the interrupt cause, or the
				; channels, but not both.
	DCD	0		; TestIRQ cannot be called
	%	8
	DCD	SDMACFeatures
	DCD	SDMACEnumerate
	DCD	SDMACAllocate
	DCD	SDMACDeallocate
	DCD	SDMACTestIRQ2
	ASSERT	(. - ControllerTemplate) = HALDevice_DMAC_Size_0_1
	%	4		; Regs
	%	4		; HAL Workspace
	%	4		; Mask of allocated devices
	%	4 * SDMA_NumDevices ; Device list
	ALIGN
d194 1
a194 1
	ASSERT (. - ControllerTemplate) = SDMAC_DeviceSize
d199 34
a232 34
	; Public interface
	DCW	HALDeviceType_SysPeri + HALDeviceSysPeri_DMAB
	DCW	HALDeviceID_DMAB_OMAP4
	DCD	HALDeviceBus_Interconnect + HALDeviceInterconnectBus_L3
	DCD	&10000		; API version - 1.0
	DCD	0		; Description
	DCD	0		; Address - N/A
	%	12		; Reserved
	DCD	SDMAActivate
	DCD	SDMADeactivate
	DCD	SDMAReset
	DCD	SDMASleep
	DCD	SDMA_IRQ_0+(1<<31) ; Device. Bit 31 set because it's shared with all the channels.
	DCD	SDMATestIRQ
	%	8
	DCD	SDMAFeatures
	DCD	0		; DMA controller device
	DCD	SDMAAbort
	DCD	SDMASetOptions
	DCD	SDMASetCurrentTransfer
	DCD	SDMASetNextTransfer
	DCD	SDMATransferState
	DCD	SDMAIRQClear
	DCD	SDMAStatus
	DCD	SDMASetCurrentTransfer2
	DCD	SDMASetNextTransfer2
	DCD	SDMATransferState2
	ASSERT	(.-ChannelTemplate) = HALDevice_DMA_Size
	; Private interface
	DCD	0		; Regs (for the controller)
	DCD	0		; Regs (for this channel)
	DCD	0		; HAL Workspace
	DCD	0		; IRQ mask
	DCD	0		; Packet size ptr
d234 1
a234 1
	=	"OMAP4 system DMA channel "
d236 3
a238 3
	DCB	0, 0, 0 ; 2 digit number + terminator
	ALIGN
	ASSERT	(. - ChannelDescStart) = 28 ; hardcoded in hdr.SDMA!
d240 1
a240 1
	ASSERT	(. - ChannelTemplate) = SDMA_DeviceSize
d243 2
a244 2
	= "OMAP4 system DMA controller", 0
	ALIGN
d250 3
a252 3
	; Nothing to do?
	MOV	a1, #1
	MOV	pc, lr
d255 1
a255 1
	; Just do the same as on a reset...
d257 5
a261 5
	Entry	"sb"
	LDR	sb, SDMACWorkspace
	LDR	a3, SDMACRegs
;	MOV	a2, #2		; this bit is reserved on OMAP4430 (!?)
;	STR	a2, [a3, #DMA4_OCP_SYSCONFIG]
d263 17
a279 17
	LDR	a2, [a3, #DMA4_SYSSTATUS]
	TST	a2, #DMA4_SYSSTATUS_RESETDONE
	BEQ	%BT5
	; Set DMA4_GCR to a sensible value:
	; Arbitration rate=1, no reserved resources, max per-channel FIFO depth 128 bytes
	LDR	a2, =((1 << DMA4_GCR_ARBITRAION_RATE_SHIFT) + 128)
	STR	a2, [a3, #DMA4_GCR]
	; Reset the allocation list
	MOV	a2, #0
	STR	a2, SDMACAllocated
	; Give INTC a bit of a kick, since any pending IRQs will no longer look like they came
	; from us, causing DMAManager to fail to clear them
	MOV	a1, #SDMA_IRQ_0 ; Only need to clear the first IRQ since all we're interested in is the write to INTCPS_CONTROL
	BL	HAL_IRQClear
;	MOV	a1, #SDMA_IRQ_0
;	BL	HAL_FIQClear ; Just in case
	EXIT
d282 3
a284 3
	; Nothing we can do
	MOV	a1, #0
	MOV	pc, lr
d287 2
a288 2
	MOV	a1, #0
	MOV	pc, lr
d291 3
a293 3
	ADR	a1, SDMACPhysList
	MOV	a2, #SDMA_NumDevices
	MOV	pc, lr
d296 39
a334 39
	; a2 = RISC OS-speak logical DMA channel
	; In OMAP speak, this is the value to be programmed into the DMA4_CCRi register,
	; i.e. 0 for CPU synchronisation, else the DMA request ID + 1
	; For the moment, we assume the user is smart enough not to request the same logical ID
	; multiple times, because that will result in bad things (unless they're chained
	; together)
	; This allocation scheme also means we're technically limited to using 1 CPU
	; synchronised channel at once :(
	Entry	"sb"
	LDR	sb, SDMACWorkspace
 [ SDMADebug
	DebugReg a2, "SDMACAllocate: "
 ]
	MRS	lr, CPSR
	ORR	a4, lr, #I32_bit
	MSR	CPSR_c, a4 ; interrupts off
	LDR	a3, SDMACAllocated
	CLZ	a4, a3
	CMP	a4, #32-SDMA_NumDevices ; Assume that channels 0 to SDMA_NumDevices are to be used
	MOVEQ	a1, #0 ; No controllers left
	BEQ	%FT10
	MOV	ip, #1
	ORR	a3, a3, ip, ROR a4
	STR	a3, SDMACAllocated
	; Grab the pointer to the DMA channel device
	ADR	a1, SDMACPhysList
	RSB	a4, a4, #32
	LDR	a1, [a1, a4, LSL #2]
	; Set the packet size pointer, if appropriate
	CMP	a2, #AUDIO_DMA_CHAN+1
	ADREQ	a3, DMAPktSz_Audio
	MOVNE	a3, #0
	STR	a3, SDMAPacketSizePtr
	; Program the request ID into the channel registers
	LDR	a3, SDMARegs
	AND	ip, a2, #DMA4_CCR_SYNCHRO_CONTROL
	AND	a2, a2, #&60
	ORR	ip, ip, a2, LSL #(DMA4_CCR_SYNCHRO_CONTROL_UPPER_SHIFT - 5)
	STR	ip, [a3, #DMA4_i+DMA4_CCRi]
d336 1
a336 1
	MSR	CPSR_c, lr ; Interrupts restored
d338 2
a339 2
	DebugReg a4, "<-Channel: "
	DebugReg a1, "<-Device: "
d341 1
a341 1
	EXIT
d344 26
a369 26
	; For API 0.x, we only get given the logical channel #. Which is bad, because
	; memory-to-memory transfers all use logical channel 0, so there could easily be
	; multiple instances of the same logical channel.
	; So for API 1.x, we also get passed a pointer to the channel which we're deallocating
	; (in a3)
 [ SDMADebug
	Entry	"sb"
	LDR	sb, SDMACWorkspace
	DebugReg a2, "SDMACDeallocate: "
	DebugReg a3, "  Ptr: "
 ]
	; Assuming a3 is valid, we can just load the IRQ mask word and use that to update our
	; allocation mask
	MRS	ip, CPSR
	LDR	a3, [a3, #:INDEX:SDMAIRQMask]
	ORR	a4, ip, #I32_bit
	MSR	CPSR_c, a4 ; interrupts off
	LDR	a2, SDMACAllocated
	BIC	a2, a2, a3
	STR	a2, SDMACAllocated
	MSR	CPSR_c, ip ; Interrupts restored
 [ SDMADebug
	CLZ	a1, a3
	RSB	a1, a1, #31
	DebugReg a1, "  Was channel #"
	EXIT
d371 1
a371 1
	MOV	pc, lr
d375 1
a375 1
	; Return index of interrupting channel (as per Enumerate list), or -1 for none
d377 1
a377 1
	Entry	"sb"
d379 2
a380 2
	PHPSEI	lr,sb
	Push	"lr"
d382 2
a383 2
	LDR	sb, SDMACWorkspace
	DebugTX "SDMACTestIRQ2:"
d385 4
a388 4
	LDR	a2, SDMACRegs
	LDR	a2, [a2, #DMA4_IRQSTATUS_L0]
	CLZ	a1, a2
	RSB	a1, a1, #31 ; Device index or -1 for none
d390 1
a390 1
	DebugReg a1, "="
d392 2
a393 2
	Pull	"lr"
	PLP	lr
d395 1
a395 1
	EXIT
d397 1
a397 1
	MOV	pc, lr
d405 1
a405 1
	; The only thing we do here is enable the IRQ for the device
d407 1
a407 1
	Entry	"sb"
d409 2
a410 2
	PHPSEI	lr,sb
	Push	"lr"
d412 2
a413 2
	LDR	sb, SDMAWorkspace
	DebugReg a1, "SDMAActivate: "
d415 10
a424 10
	LDR	a2, SDMARegs
	MRS	a3, CPSR
	LDR	ip, SDMAIRQMask
	ORR	a4, a3, #I32_bit
	MSR	CPSR_c, a4 ; interrupts off
	LDR	a4, [a2, #DMA4_IRQENABLE_L0]
	ORR	a4, a4, ip
	STR	a4, [a2, #DMA4_IRQENABLE_L0] ; Unmask the interrupt
	MOV	a1, #1
	MSR	CPSR_c, a3 ; Interrupts restored
d427 2
a428 2
	Pull	"lr"
	PLP	lr
d430 1
a430 1
	EXIT
d432 1
a432 1
	MOV	pc, lr
d437 1
a437 1
	Entry	"v1,sb"
d439 2
a440 2
	PHPSEI	lr,sb
	Push	"lr"
d442 1
a442 1
	LDR	sb, SDMAWorkspace
d444 1
a444 1
	DebugReg a1, "SDMAAbort/Deactivate: "
d446 5
a450 5
	; Halt any active transfer
	LDR	a2, SDMAChanRegs
	LDR	a3, [a2, #DMA4_CCRi]
	BIC	a3, a3, #DMA4_CCR_ENABLE ; Clear ENABLE bit
	STR	a3, [a2, #DMA4_CCRi]
d452 22
a473 22
	LDR	a3, [a2, #DMA4_CCRi]
	TST	a3, #(DMA4_CCR_RD_ACTIVE + DMA4_CCR_WR_ACTIVE) ; Check RD_ACTIVE & WR_ACTIVE
	BNE	%BT10
	; Now disable interrupts (or should we do this first?)
	LDR	a2, SDMARegs
	MRS	v1, CPSR
	LDR	ip, SDMAIRQMask
	ORR	a4, v1, #I32_bit
	MSR	CPSR_c, a4 ; Interrupts off
	LDR	a1, [a2, #DMA4_IRQSTATUS_L0]
	LDR	a4, [a2, #DMA4_IRQENABLE_L0]
	TST	a1, ip
	BIC	a4, a4, ip
	STR	a4, [a2, #DMA4_IRQENABLE_L0] ; Mask the interrupt
	; If the channel was interrupting, we must call HAL_IRQClear to (potentially) restart
	; interrupt processing
	; todo - this code should probably be in the OS, like all the other code that's meant
	; to call HAL_IRQClear
	MOVNE	a1, #SDMA_IRQ_0
	BLNE	HAL_IRQClear
	MSR	CPSR_c, v1 ; Interrupts restored
	; Done!
d475 2
a476 2
	Pull	"lr"
	PLP	lr
d478 1
a478 1
	EXIT
d482 1
a482 1
	Entry	"sb"
d484 2
a485 2
	PHPSEI	lr,sb
	Push	"lr"
d487 2
a488 2
	LDR	sb, SDMAWorkspace
	DebugReg a1, "SDMAReset: "
d490 17
a506 17
	LDR	a2, SDMARegs
	MRS	a3, CPSR
	LDR	ip, SDMAIRQMask
	ORR	a4, a3, #I32_bit
	MSR	CPSR_c, a4 ; Interrupts off
	LDR	a4, [a2, #DMA4_IRQENABLE_L0]
	BIC	a4, a4, ip
	STR	a4, [a2, #DMA4_IRQENABLE_L0] ; Mask the interrupt
	MSR	CPSR_c, a3 ; Interrupts restored
	; Now reset the channel registers to something sensible
	MOV	ip, #DMA4_CCR_SYNCHRO_CONTROL
	LDR	a2, SDMAChanRegs
	ORR	ip, ip, #DMA4_CCR_SYNCHRO_CONTROL_UPPER
	LDR	a3, [a2, #DMA4_CCRi]
	MOV	a1, #0
	AND	a3, a3, ip ; Mask everything except the SYNCHRO_CONTROL field
	STR	a3, [a2, #DMA4_CCRi]
d508 25
a532 25
	LDR	a3, [a2, #DMA4_CCRi]
	TST	a3, #(DMA4_CCR_RD_ACTIVE + DMA4_CCR_WR_ACTIVE) ; Check RD_ACTIVE & WR_ACTIVE
	BNE	%BT10
	MVN	a4, #0
	STR	a1, [a2, #DMA4_CLNK_CTRLi] ; Disable channel linking
	STR	a1, [a2, #DMA4_CICRi] ; Disable all interrupts
	STR	a4, [a2, #DMA4_CSRi] ; Reset interrupt status bits
	; These registers don't really need to be reset, because we'll reprogram them as and
	; when needed.
;	STR	a1, [a2, #DMA4_CSDPi]
;	STR	a1, [a2, #DMA4_CENi]
;	STR	a1, [a2, #DMA4_CFNi]
;	STR	a1, [a2, #DMA4_CSSAi]
;	STR	a1, [a2, #DMA4_CDSAi]
;	STR	a1, [a2, #DMA4_CSEIi]
;	STR	a1, [a2, #DMA4_CSFIi]
;	STR	a1, [a2, #DMA4_CDEIi]
;	STR	a1, [a2, #DMA4_CDFIi]
;	STR	a1, [a2, #DMA4_CDACi]
;	STR	a1, [a2, #DMA4_COLORi]
	; These registers are readonly and thus can't be reset
;	STR	a1, [a2, #DMA4_CSACi]
;	STR	a1, [a2, #DMA4_CCENi]
;	STR	a1, [a2, #DMA4_CCFNi]
	; Finished!
d535 2
a536 2
	Pull	"lr"
	PLP	lr
d538 1
a538 1
	EXIT
d540 1
a540 1
	MOV	pc, lr
d544 3
a546 3
	; Nothing we can do
	MOV	a1, #0
	MOV	pc, lr
d549 3
a551 3
	; This interface doesn't work too well, due to there being many more interrupt channels
	; than IRQ lines. Hence the addition of TestIRQ2 to the controller device.
	; This old interface is retained purely for backwards-compatability
d553 1
a553 1
	Entry	"sb"
d555 2
a556 2
	PHPSEI	lr,sb
	Push	"lr"
d558 2
a559 2
	LDR	sb, SDMAWorkspace
	DebugReg a1, "SDMATestIRQ: "
d561 5
a565 5
	LDR	a2, SDMARegs
	LDR	a3, SDMAIRQMask
	LDR	a4, [a2, #DMA4_IRQSTATUS_L0]
	ANDS	a1, a4, a3
	MOVNE	a1, #1 ; 1 = interrupting, 0 = not interrupting
d567 1
a567 1
	DebugReg a1, "<-"
d569 2
a570 2
	Pull	"lr"
	PLP	lr
d572 1
a572 1
	EXIT
d574 1
a574 1
	MOV	pc, lr
d578 10
a587 10
	; Check SYNCHRO_CONTROL field to see if this is CPU synchronised (memory-to-memory) or
	; device synchronised
	LDR	a2, SDMAChanRegs
	MOV	a3, #DMA4_CCR_SYNCHRO_CONTROL
	LDR	a2, [a2, #DMA4_CCRi]
	ORR	a3, a3, #DMA4_CCR_SYNCHRO_CONTROL_UPPER
	TST	a2, a3
	MOVEQ	a1, #DMAFeaturesFlag_DualAddress+DMAFeaturesFlag_NoInitIRQ
	MOVNE	a1, #DMAFeaturesFlag_NoInitIRQ
	MOV	pc, lr
d590 46
a635 46
	; a2: bit 0:  1=memory->device, 0=device->memory (iff device DMA)
	;     bits 1-5: transfer unit width, bytes
	;     bits 6-8: cycle speed, ignored
	;     bits 9-12: minimum delay between transfers on same physical channel, ignored
	;     bit 13: 1=disable burst transactions
	;     bit 14: 1=bypass clock synchronisation, ignored
	; a3: device address for device DMA
	; We use this call to program everything except the transfer source/dest address (and
	; the transfer length)
 [ SDMADebug
	Entry	"sb"
  [ SDMADebugNoIRQ
	PHPSEI	lr,sb
	Push	"lr"
  ]
	LDR	sb, SDMAWorkspace
	DebugReg a1, "SDMASetOptions: "
	DebugReg a2, "->Flags: "
	DebugReg a3, "->Addr: "
 |
	Entry
 ]
	LDR	a4, SDMAChanRegs
	MOV	lr, #DMA4_CCR_SYNCHRO_CONTROL
	; Calculate CCR
	LDR	ip, [a4, #DMA4_CCRi]
	ORR	lr, lr, #DMA4_CCR_SYNCHRO_CONTROL_UPPER
	ANDS	ip, ip, lr ; Clear everything except the SYNCHRO bits
	; SYNCHRO_CONTROL == 0 -> is memory-to-memory channel
	ORREQ	ip, ip, #(DMA4_CCR_DST_AMODE_POST_INC + DMA4_CCR_SRC_AMODE_POST_INC) ; Post-increment src & dest
	ORREQ	ip, ip, #(DMA4_CCR_SEL_SRC_DST_SYNC) ; Source-synchronised for mem-to-mem
	BEQ	%FT10
	; Else this is some kind of device channel. Program appropriately.
	TST	a2, #DMASetOptionsFlag_Write
	ORREQ	ip, ip, #DMA4_CCR_DST_AMODE_POST_INC ; Post-increment dest for device->memory
	STREQ	a3, [a4, #DMA4_CSSAi] ; Source addr = Device address
	ORRNE	ip, ip, #DMA4_CCR_SRC_AMODE_POST_INC ; Post-increment src for memory->device
	STRNE	a3, [a4, #DMA4_CDSAi] ; Dest addr = Device address
	ORRNE	ip, ip, #DMA4_CCR_PREFETCH ; Enable prefetch for mem->device only
	; Configure for packet transfers if required
	LDR	a3, SDMAPacketSizePtr
	CMP	a3, #0
	; FS = BS = 1 ==> packet transfer; higher priority (R + W)
	ORRNE	ip, ip, #(DMA4_CCR_FS + DMA4_CCR_READ_PRIORITY)
	ORRNE	ip, ip, #DMA4_CCR_BS
	ORRNE	ip, ip, #DMA4_CCR_WRITE_PRIORITY
d637 17
a653 17
	STR	ip, [a4, #DMA4_CCRi]
	; Calculate CSDP
	AND	a3, a2, #DMASetOptionsMask_Width ; Get transfer unit size
	CMP	a3, #2:SHL:DMASetOptionsShift_Width
	MOVGT	a3, #(DMA4_CSDP_SRC_PACKED + DMA4_CSDP_DATA_TYPE_32BIT) ; 32bit or larger data
	MOVEQ	a3, #(DMA4_CSDP_SRC_PACKED + DMA4_CSDP_DATA_TYPE_16BIT) ; 16bit data
	MOVLT	a3, #(DMA4_CSDP_SRC_PACKED + DMA4_CSDP_DATA_TYPE_8BIT) ; 8bit data
	ORR	a3, a3, #(DMA4_CSDP_DST_PACKED + DMA4_CSDP_WRITE_MODE_LAST_WRNP) ; DST_PACKED, last write nonposted
	TST	a2, #DMASetOptionsFlag_NoBursts
	ORREQ	a3, a3, #DMA4_CSDP_SRC_BURST_EN_64B ; Source burst of 64 bytes
	ORREQ	a3, a3, #DMA4_CSDP_DST_BURST_EN_64B ; Dest burst of 64 bytes
	TST	ip, lr
	BEQ	%FT20
	; If it's a device transfer, disable packing for the device side
	TST	a2, #DMASetOptionsFlag_Write
	BICEQ	a3, a3, #(DMA4_CSDP_SRC_PACKED) ; Disable src packing for device->memory
	BICNE	a3, a3, #(DMA4_CSDP_DST_PACKED) ; Disable dest packing for memory->device
d655 8
a662 8
	STR	a3, [a4, #DMA4_CSDPi]
	; Enable frame or packet interrupt - this should trigger when the transfer completes
	LDR	a3, SDMAPacketSizePtr
	CMP	a3, #0
	MOVNE	a1, #DMA4_CICR_BLOCK_IE	; fires after all packets sent
	MOVEQ	a1, #DMA4_CICR_FRAME_IE
	STR	a1, [a4, #DMA4_CICRi]
	; Done
d665 2
a666 2
	Pull	"lr"
	PLP	lr
d669 1
a669 1
	EXIT
d672 40
a711 40
	; a2: buffer physical address
	; a3: buffer length, bytes
	; a4: bit 0: 1="stop and raise TC signal when this transfer completes". Ignore?
 [ SDMADebug
	Entry	"sb"
  [ SDMADebugNoIRQ
	PHPSEI	lr,sb
	Push	"lr"
  ]
	LDR	sb, SDMAWorkspace
	DebugReg a1, "SDMASetCurrentTransfer: "
	DebugReg a2, "->Buffer: "
	DebugReg a3, "->Length: "
 |
	Entry
 ]
	LDR	a4, SDMAChanRegs
	LDR	ip, [a4, #DMA4_CCRi]
	TST	ip, #DMA4_CCR_SRC_AMODE_POST_INC
	LDR	lr, [a4, #DMA4_CSDPi]
	STREQ	a2, [a4, #DMA4_CDSAi]	; device->memory, so set dest addr
	AND	lr, lr, #3		; Get element size
	STRNE	a2, [a4, #DMA4_CSSAi]	; memory->device, so set src addr
	MOV	a3, a3, LSR lr		; Get number of elements in buffer
	STR	a3, [a4, #DMA4_CENi] ; todo - what to do if we're asked to transfer too much data?
	; Check if this is a packet transfer, and program appropriately
	LDR	a2, SDMAPacketSizePtr
	CMP	a2, #0
	MOVEQ	a2, #1	; Only 1 frame to transfer for non packet transfers
	BEQ	%FT10
	LDR	a2, [a2]
	TST	ip, #DMA4_CCR_SRC_AMODE_POST_INC
	STREQ	a2, [a4, #DMA4_CSFIi]	; device->memory, put it here
	STRNE	a2, [a4, #DMA4_CDFIi]	; memory->device, put it here
	; size of one packet must go here
	STR	a2, [a4, #DMA4_CENi]
	; calculate number of frames (assumption: packet size is power of 2)
	CLZ	lr, a2
	RSB	lr, lr, #31
	MOV	a2, a3, LSR lr
d713 22
a734 22
	STR	a2, [a4, #DMA4_CFNi]
	; Now just enable it?
	ORR	ip, ip, #(DMA4_CCR_ENABLE+DMA4_CCR_FS) ; Frame synchronised by default if not packet synchronised
 [ SDMADebug
	DebugReg ip, "::DMA4_CCRi: "
	DumpReg a4, a1, DMA4_CLNK_CTRLi
	DumpReg a4, a1, DMA4_CICRi
	DumpReg a4, a1, DMA4_CSRi
	DumpReg a4, a1, DMA4_CSDPi
	DumpReg a4, a1, DMA4_CENi
	DumpReg a4, a1, DMA4_CFNi
	DumpReg a4, a1, DMA4_CSSAi
	DumpReg a4, a1, DMA4_CDSAi
	DumpReg a4, a1, DMA4_CSEIi
	DumpReg a4, a1, DMA4_CSFIi
	DumpReg a4, a1, DMA4_CDEIi
	DumpReg a4, a1, DMA4_CDFIi
	DumpReg a4, a1, DMA4_CSACi
	DumpReg a4, a1, DMA4_CDACi
	DumpReg a4, a1, DMA4_CCENi
	DumpReg a4, a1, DMA4_CCFNi
	DumpReg a4, a1, DMA4_COLORi
d736 1
a736 1
	STR	ip, [a4, #DMA4_CCRi]
d739 2
a740 2
	Pull	"lr"
	PLP	lr
d743 1
a743 1
	EXIT
d746 2
a747 2
	; N/A
	MOV	pc, lr
d750 2
a751 2
	; We need to return the current read/write address, and the amount left to transfer...
	; I think
d753 1
a753 1
	Entry	"sb"
d755 2
a756 2
	PHPSEI	lr,sb
	Push	"lr"
d758 43
a800 43
	LDR	sb, SDMAWorkspace
	DebugReg a1, "SDMATransferState: "
 ]
	MRS	ip, CPSR
	LDR	a3, SDMAChanRegs
	ORR	a4, ip, #I32_bit
	MSR	CPSR_c, a4 ; Interrupts off
 [ SDMADebug
	DumpReg a3, a2, DMA4_CCRi
	DumpReg a3, a2, DMA4_CLNK_CTRLi
	DumpReg a3, a2, DMA4_CICRi
	DumpReg a3, a2, DMA4_CSRi
	DumpReg a3, a2, DMA4_CSDPi
	DumpReg a3, a2, DMA4_CENi
	DumpReg a3, a2, DMA4_CFNi
	DumpReg a3, a2, DMA4_CSSAi
	DumpReg a3, a2, DMA4_CDSAi
	DumpReg a3, a2, DMA4_CSEIi
	DumpReg a3, a2, DMA4_CSFIi
	DumpReg a3, a2, DMA4_CDEIi
	DumpReg a3, a2, DMA4_CDFIi
	DumpReg a3, a2, DMA4_CSACi
	DumpReg a3, a2, DMA4_CDACi
	DumpReg a3, a2, DMA4_CCENi
	DumpReg a3, a2, DMA4_CCFNi
	DumpReg a3, a2, DMA4_COLORi
 ]
	LDR	a1, [a3, #DMA4_CCRi]
	LDR	a2, [a3, #DMA4_CCENi] ; Get current element number
	LDR	a4, [a3, #DMA4_CENi] ; Transfer length
	TST	a1, #DMA4_CCR_SRC_AMODE_POST_INC
	LDR	a1, [a3, #DMA4_CSDPi]
	LDREQ	a3, [a3, #DMA4_CDSAi] ; Get correct source address
	AND	a1, a1, #3 ; Get element size
	LDRNE	a3, [a3, #DMA4_CSSAi]
	MOV	a2, a2, LSL a1
	MOV	a4, a4, LSL a1
	ADD	a1, a3, a2 ; Update source address
	SUB	a2, a4, a2 ; Update transfer length
	MSR	CPSR_c, ip ; Interrupts restored
 [ SDMADebug
	DebugReg a1, "<-Addr: "
	DebugReg a2, "<-Length: "
d802 2
a803 2
	Pull	"lr"
	PLP	lr
d805 1
a805 1
	EXIT
d807 1
a807 1
	MOV	pc, lr
d811 1
a811 1
	Entry	"v1,sb"
d813 2
a814 2
	PHPSEI	lr,sb
	Push	"lr"
d816 1
a816 1
	LDR	sb, SDMAWorkspace
d818 1
a818 1
	DebugReg a1, "SDMAIRQClear: "
d820 12
a831 12
	MRS	v1, CPSR
	LDR	ip, SDMAChanRegs
	ORR	a4, v1, #I32_bit
	LDR	a2, SDMARegs
	MVN	a3, #0
	LDR	a1, SDMAIRQMask
	MSR	CPSR_c, a4 ; Interrupts off
	STR	a3, [ip, #DMA4_CSRi] ; Clear all active interrupts
	STR	a1, [a2, #DMA4_IRQSTATUS_L0] ; Clear main IRQ bit
	MOV	a1, #SDMA_IRQ_0
	BL	HAL_IRQClear ; Clear IRQ (todo - should be in DMAManager?)
	MSR	CPSR_c, v1 ; Interrupts restored
d833 2
a834 2
	Pull	"lr"
	PLP	lr
d836 1
a836 1
	EXIT
d840 1
a840 1
	Entry	"sb"
d842 2
a843 2
	PHPSEI	lr,sb
	Push	"lr"
d845 2
a846 2
	LDR	sb, SDMAWorkspace
	DebugReg a1, "SDMAStatus: "
d848 5
a852 5
	LDR	a2, SDMAChanRegs
	MOV	a1, #DMAStatusFlag_NoUnstarted ; We don't support double-buffering, so NoUnstarted must always be set
	LDR	a2, [a2, #DMA4_CCRi]
	TST	a2, #DMA4_CCR_ENABLE ; Check ENABLE bit
	ORREQ	a1, a1, #DMAStatusFlag_Overrun ; If we're inactive, we're in the overrun state
d854 1
a854 1
	DebugReg a1, "<-Flags: "
d856 2
a857 2
	Pull	"lr"
	PLP	lr
d859 1
a859 1
	EXIT
d861 1
a861 1
	MOV	pc, lr
d865 28
a892 28
	; a2: source physical address
	; a3: dest physical address
	; a4: buffer length, bytes
	; a5: bit 0: 1="stop and raise TC signal when this transfer completes". Ignore?
 [ SDMADebug
	Entry	"sb"
  [ SDMADebugNoIRQ
	PHPSEI	lr,sb
	Push	"lr"
  ]
	LDR	sb, SDMAWorkspace
	DebugReg a1, "SDMASetCurrentTransfer2: "
	DebugReg a2, "->Source: "
	DebugReg a3, "->Dest: "
	DebugReg a4, "->Length: "
 ]
	LDR	ip, SDMAChanRegs
	LDR	a1, [ip, #DMA4_CSDPi]
	STR	a2, [ip, #DMA4_CSSAi] ; set src addr
	AND	a1, a1, #3 ; Get element size
	STR	a3, [ip, #DMA4_CDSAi] ; set dest addr
	MOV	a4, a4, LSR a1 ; Get number of elements in buffer
	STR	a4, [ip, #DMA4_CENi] ; todo - what to do if we're asked to transfer too much data?
	MOV	a2, #1
	STR	a2, [ip, #DMA4_CFNi] ; Only 1 frame to transfer
	; Now just enable it?
	ORR	a1, a1, #DMA4_CCR_ENABLE
	STR	a1, [ip, #DMA4_CCRi]
d895 2
a896 2
	Pull	"lr"
	PLP	lr
d898 1
a898 1
	EXIT
d900 1
a900 1
	MOV	pc, lr
d904 2
a905 2
	; N/A
	MOV	pc, lr
d908 1
a908 1
	; We need to return the current read & write address, and the amount left to transfer... I think
d910 1
a910 1
	Entry	"sb"
d912 2
a913 2
	PHPSEI	lr,sb
	Push	"lr"
d915 2
a916 2
	LDR	sb, SDMAWorkspace
	DebugReg a1, "SDMATransferState2: "
d918 16
a933 16
	MRS	ip, CPSR
	LDR	a2, SDMAChanRegs
	ORR	a4, ip, #I32_bit
	MSR	CPSR_c, a4 ; Interrupts off
	LDR	a1, [a2, #DMA4_CSDPi]
	LDR	a3, [a2, #DMA4_CCENi] ; Get current element number
	AND	a1, a1, #3 ; Get element size
	LDR	a4, [a2, #DMA4_CENi] ; Transfer length
	MOV	a3, a3, LSL a1
	MOV	a4, a4, LSL a1
	LDR	a1, [a2, #DMA4_CSSAi]
	LDR	a2, [a2, #DMA4_CDSAi]
	ADD	a1, a1, a3 ; Update source address
	ADD	a2, a2, a3 ; Update dest address
	SUB	a3, a4, a3 ; Update transfer length
	MSR	CPSR_c, ip ; Interrupts restored
d935 3
a937 3
	DebugReg a1, "<-Source: "
	DebugReg a2, "<-Dest: "
	DebugReg a3, "<-Length: "
d939 2
a940 2
	Pull	"lr"
	PLP	lr
d942 1
a942 1
	EXIT
d944 1
a944 1
	MOV	pc, lr
d947 1
a947 1
	LTORG
d949 1
a949 1
	END
@


1.1
log
@Initial revision
@
text
@d75 2
a76 2
	MOV	a2, #2
	STR	a2, [v2, #DMA4_OCP_SYSCONFIG]
d79 1
a79 1
	TST	a2, #1
d85 1
a85 1
	LDR	a2, =1+(2<<3)+(2<<12)
d260 2
a261 2
	MOV	a2, #2
	STR	a2, [a3, #DMA4_OCP_SYSCONFIG]
d264 1
a264 1
	TST	a2, #1
d267 2
a268 1
	LDR	a2, =&100080 ; Arbitration rate=1, no reserved resources, max per-channel FIFO depth 128 bytes
d277 2
a278 2
	MOV	a1, #SDMA_IRQ_0
	BL	HAL_FIQClear ; Just in case
d331 1
a331 1
	AND	ip, a2, #&1F
d333 1
a333 1
	ORR	ip, ip, a2, LSL #14
d449 1
a449 1
	BIC	a3, a3, #1<<7 ; Clear ENABLE bit
d453 1
a453 1
	TST	a3, #(1<<9) :OR: (1<<10) ; Check RD_ACTIVE & WR_ACTIVE
d500 1
a500 1
	MOV	ip, #&1F
d502 1
a502 1
	ORR	ip, ip, #3<<19
d509 1
a509 1
	TST	a3, #(1<<9) :OR: (1<<10) ; Check RD_ACTIVE & WR_ACTIVE
d581 1
a581 1
	MOV	a3, #&1F
d583 1
a583 1
	ORR	a3, a3, #3<<19
d613 1
a613 1
	MOV	lr, #&1F
d616 1
a616 1
	ORR	lr, lr, #3<<19
d619 2
a620 2
	ORREQ	ip, ip, #(1<<14)+(1<<12) ; Post-increment src & dest
	ORREQ	ip, ip, #(1<<24) ; Source-synchronised for mem-to-mem
d624 1
a624 1
	ORREQ	ip, ip, #1<<14 ; Post-increment dest for device->memory
d626 1
a626 1
	ORRNE	ip, ip, #1<<12 ; Post-increment src for memory->device
d628 1
a628 1
	ORRNE	ip, ip, #1<<23 ; Enable prefetch for mem->device only
d632 4
a635 2
	ORRNE	ip, ip, #1<<5 ; FS +
	ORRNE	ip, ip, #1<<18 ; BS = packet transfer
d641 4
a644 4
	MOVGT	a3, #(1<<6)+2 ; 32bit or larger data (plus set SRC_PACKED)
	MOVEQ	a3, #(1<<6)+1 ; 16bit data
	MOVLT	a3, #(1<<6)+0 ; 8bit data
	ORR	a3, a3, #(1<<13)+(2<<16) ; DST_PACKED, last write nonposted
d646 2
a647 2
	ORREQ	a3, a3, #3<<7 ; Source burst of 64 bytes
	ORREQ	a3, a3, #3<<14 ; Dest burst of 64 bytes
d652 2
a653 2
	BICEQ	a3, a3, #(1<<6) ; Disable src packing for device->memory
	BICNE	a3, a3, #(1<<13) ; Disable dest packing for memory->device
d656 5
a660 3
	; Enable frame interrupt - this should trigger when the transfer completes (since it
	; only contains one frame)
	MOV	a1, #1<<3
d690 1
a690 1
	TST	ip, #1<<12
d692 4
a695 4
	STREQ	a2, [a4, #DMA4_CDSAi] ; device->memory, so set dest addr
	AND	lr, lr, #3 ; Get element size
	STRNE	a2, [a4, #DMA4_CSSAi] ; memory->device, so set src addr
	MOV	a3, a3, LSR lr ; Get number of elements in buffer
a696 2
	MOV	a2, #1
	STR	a2, [a4, #DMA4_CFNi] ; Only 1 frame to transfer
d700 1
d703 9
a711 3
	TST	ip, #1<<12
	STREQ	a2, [a4, #DMA4_CSFIi] ; device->memory, put it here
	STRNE	a2, [a4, #DMA4_CDFIi] ; memory->device, put it here
d713 1
d715 1
a715 1
	ORR	ip, ip, #(1<<7)+(1<<5) ; Frame synchronised by default if not packet synchronised
d788 1
a788 1
	TST	a1, #1<<12
d851 1
a851 1
	TST	a2, #1<<7 ; Check ENABLE bit
d891 1
a891 1
	ORR	a1, a1, #1<<7
@


1.1.1.1
log
@  Initial import of OMAP4 HAL
Detail:
  Target platform is the Pandaboard, based on the TI OMAP4 SoC.
  Port is not yet complete, in particular, audio is not yet working.
Admin:
  Submission from Willi Theiß
@
text
@@

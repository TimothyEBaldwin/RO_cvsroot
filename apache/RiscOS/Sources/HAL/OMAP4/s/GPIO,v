head	1.9;
access;
symbols
	OMAP4-0_60:1.9
	OMAP4-0_59-1_52_2_3:1.6.2.1
	OMAP4-0_59:1.9
	OMAP4-0_58:1.8
	OMAP4-0_57:1.7
	OMAP4-0_56:1.7
	OMAP4-0_55:1.6
	OMAP4-0_54-1_52_2_2:1.6
	OMAP4-0_54:1.6
	OMAP4-0_53:1.6
	OMAP4-0_52-1_52_2_1:1.6
	SMP:1.6.0.2
	SMP_bp:1.6
	OMAP4-0_52:1.6
	OMAP4-0_51:1.6
	OMAP4-0_50:1.6
	OMAP4-0_49:1.6
	OMAP4-0_48:1.6
	OMAP4-0_47:1.6
	OMAP4-0_46:1.6
	OMAP4-0_45:1.6
	OMAP4-0_44:1.6
	OMAP4-0_43:1.5
	OMAP4-0_42:1.5
	OMAP4-0_41:1.5
	OMAP4-0_40:1.5
	OMAP4-0_39:1.5
	OMAP4-0_38:1.4
	OMAP4-0_37:1.4
	OMAP4-0_36:1.4
	OMAP4-0_35:1.4
	OMAP4-0_34:1.4
	OMAP4-0_33:1.4
	OMAP4-0_32:1.4
	OMAP4-0_31:1.4
	OMAP4-0_30:1.4
	OMAP4-0_29:1.4
	OMAP4-0_28:1.4
	OMAP4-0_27:1.4
	OMAP4-0_26:1.4
	OMAP4-0_25:1.4
	OMAP4-0_24:1.4
	OMAP4-0_23:1.4
	OMAP4-0_22:1.4
	OMAP4-0_21:1.4
	OMAP4-0_20:1.4
	OMAP4-0_19:1.4
	OMAP4-0_18:1.4
	OMAP4-0_17:1.4
	OMAP4-0_16:1.4
	OMAP4-0_15:1.3
	OMAP4-0_14:1.2
	OMAP4-0_13:1.2
	OMAP4-0_12:1.2
	OMAP4-0_11:1.2
	OMAP4-0_10:1.2
	OMAP4-0_09:1.2
	OMAP4-0_08:1.2
	OMAP4-0_07:1.2
	OMAP4-0_06:1.1.1.1
	OMAP4-0_05:1.1.1.1
	OMAP4-0_04:1.1.1.1
	OMAP4-0_03:1.1.1.1
	OMAP4-0_02:1.1.1.1
	OMAP4-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2018.04.08.08.17.54;	author rool;	state Exp;
branches;
next	1.8;
commitid	PxIWabOXkeaW5CxA;

1.8
date	2018.04.01.21.25.23;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	DGu4k0OhERg3GMwA;

1.7
date	2018.03.30.07.56.36;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	LAp0FHnJajEzgswA;

1.6
date	2015.04.08.07.33.53;	author rsprowson;	state Exp;
branches
	1.6.2.1;
next	1.5;
commitid	ziZUYwsqx4235Lgy;

1.5
date	2014.12.06.10.46.39;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	xF8TrVZkCuXk6Y0y;

1.4
date	2013.04.13.08.40.34;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	dmbT4ciXHqpNKALw;

1.3
date	2013.04.10.21.15.50;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	qm7wa7AC4tnS1hLw;

1.2
date	2012.03.25.11.42.57;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	4FjnaYBzkPTA6gYv;

1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;
commitid	M3eV6gzJuoHHMezv;

1.6.2.1
date	2018.07.07.14.32.13;	author jlee;	state Exp;
branches;
next	;
commitid	0eMRUMdd3I00hdJA;

1.1.1.1
date	2011.09.12.19.01.15;	author bavison;	state Exp;
branches;
next	;
commitid	M3eV6gzJuoHHMezv;


desc
@@


1.9
log
@GPIO corrections
Detail:
  Correct group number for pin 58.
  Use OMAP44x0 register names for interrupt handling, the status registers are split into set/clear pairs.
Admin:
  Submission from Willi Theiss.

Version 0.59. Tagged as 'OMAP4-0_59'
@
text
@; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO
        GET     Hdr:Proc

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.omap4430
        GET     hdr.StaticWS
        GET     hdr.GPIO

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  GPIO_Init
        EXPORT  GPIOx_SetAsOutput
        EXPORT  GPIOx_SetOutput
        EXPORT  GPIOx_SetAndEnableIRQ
        EXPORT  GPIO_InitDevices
        IMPORT  memcpy

GPIO_Init
        ; Don't bother resetting the controllers for now, just make sure no IRQs are enabled
        ADR     a1, L4_GPIO_Table
        MOV     a2, #GPIO_PORT_MAX
        MVN     a3, #0
10
        LDR     a4, [a1], #4
        SUBS    a2, a2, #1
        STR     a3, [a4, #GPIO_IRQSTATUS_CLR_0]
        BNE     %BT10
        MOV     pc, lr

        ; a1 = GPIO # (OMAP)
        ; a2 = initial value (zero or nonzero)
GPIOx_SetAsOutput
        SUBS    a3, a1, #GPIO_PIN_MAX
        MOVGE   pc, lr
        ; OMAP GPIO
        GPIO_PrepareR a3, a4, a1
        GPIO_SetAsOutput a3, a4, a1
        GPIO_SetOutput a2, a3, a4
        MOV     pc, lr

        ; a1 = GPIO # (OMAP)
        ; a2 = value (zero or nonzero)
GPIOx_SetOutput
        SUBS    a3, a1, #GPIO_PIN_MAX
        MOVGE   pc, lr
        ; OMAP GPIO
        GPIO_PrepareR a3, a4, a1
        GPIO_SetOutput a2, a3, a4
        MOV     pc, lr

        ; a1 = GPIO # (OMAP only!)
        ; a2 = IRQ type flags:
        ;      +1 = LEVELDETECT0
        ;      +2 = LEVELDETECT1
        ;      +4 = RISINGDETECT
        ;      +8 = FALLINGDETECT
GPIOx_SetAndEnableIRQ
        GPIO_PrepareR a3, a4, a1
        MRS     ip, CPSR
        ORR     a1, ip, #I32_bit ; interrupts off
        MSR     CPSR_c, a1
        MOV     a2, a2, LSL #28
        MSR     CPSR_f, a2 ; load into NZCV flags (MI EQ CS VS condition codes)
        LDR     a1, [a3, #GPIO_FALLINGDETECT]
        BICPL   a1, a1, a4
        LDR     a2, [a3, #GPIO_RISINGDETECT]
        ORRMI   a1, a1, a4
        STR     a1, [a3, #GPIO_FALLINGDETECT]
        BICNE   a2, a2, a4
        LDR     a1, [a3, #GPIO_LEVELDETECT1]
        ORREQ   a2, a2, a4
        STR     a2, [a3, #GPIO_RISINGDETECT]
        BICCC   a1, a1, a4
        LDR     a2, [a3, #GPIO_LEVELDETECT0]
        ORRCS   a1, a1, a4
        STR     a1, [a3, #GPIO_LEVELDETECT1]
        BICVC   a2, a2, a4
        LDR     a1, [a3, #GPIO_OE]
        ORRVS   a2, a2, a4
        ORR     a1, a1, a4 ; set pin as input
        STR     a2, [a3, #GPIO_LEVELDETECT0]
        STR     a1, [a3, #GPIO_OE]
        STR     a4, [a3, #GPIO_IRQSTATUS_SET_0]
        MSR     CPSR_c, ip ; interrupts restored
        MOV     pc, lr

; Template for GPIO interface
GPIOTemplate
        DCW     HALDeviceType_Comms + HALDeviceComms_GPIO
        DCW     HALDeviceID_GPIO_OMAP4
        DCD     HALDeviceBus_Peri + HALDevicePeriBus_Sonics3220
        DCD     &10000          ; API 1.0
TDesc   DCD     0               ; Description (filled at runtime)
TAddr   DCD     0               ; Address (filled at runtime)
        %       12              ; Reserved
        DCD     GPIOActivate
        DCD     GPIODeactivate
        DCD     GPIOReset
        DCD     GPIOSleep
        DCD     -1              ; Device (none)
        DCD     0               ; TestIRQ
        DCD     0               ; ClearIRQ
        %       4               ; Reserved
        DCD     GPIO_PORT_MAX
TNumb   DCD     0               ; Port number (filled at runtime)
        DCD     GPIOEnumerate
        DCD     GPIOSetDataBits
        DCD     GPIOClearDataBits
        DCD     GPIOToggleDataBits
        DCD     GPIOReadDataBits
        DCD     GPIODataDirection
        DCD     GPIOReadMode
        DCD     GPIOWriteMode
        DCD     GPIOPullControl
        DCD     GPIOPullDirection
        DCD     GPIOEdgeControl
        DCD     GPIOEdgePollStatus
        ASSERT  (. - GPIOTemplate) = HALDevice_GPIO_Size_1_0

; GPIO structures
                    ^ 0
                    # HALDevice_GPIO_Size_1_0
WkspValidMask       # 4                 ; Valid bits on this port for this Type/Revision
WkspCopySB          # 4
Wksp_GPIO_Size      # 0
                    ASSERT ?GPIOWS = GPIO_PORT_MAX * Wksp_GPIO_Size

; Map Type/Revision to entry in GPIOFreeToUse table
                    ^ 0
GPIOType_Panda      # 1 ; OMAP4430
GPIOType_PandaES    # 1 ; OMAP4460
GPIOType_Max        # 0

GPIOTypeMap
        DCD     BoardType_OMAP4_Panda, BoardRevision_Panda,   GPIOType_Panda
        DCD     BoardType_OMAP4_Panda, BoardRevision_PandaES, GPIOType_PandaES
        DCD     -1, -1, -1

; Friendly names
GPIODesc0
        DCB     "OMAP GPIO interface pins 0-31", 0
GPIODesc1
        DCB     "OMAP GPIO interface pins 32-63", 0
GPIODesc2
        DCB     "OMAP GPIO interface pins 64-95", 0
GPIODesc3
        DCB     "OMAP GPIO interface pins 96-127", 0
GPIODesc4
        DCB     "OMAP GPIO interface pins 128-159", 0
GPIODesc5
        DCB     "OMAP GPIO interface pins 160-191", 0
        ALIGN
GPIODescriptions
        DCD     GPIODesc0
        DCD     GPIODesc1
        DCD     GPIODesc2
        DCD     GPIODesc3
        DCD     GPIODesc4
        DCD     GPIODesc5

; Half a register of CONTROL_PADCONF
PADCONF_MUXMODE_SHIFT        * 0
PADCONF_MUXMODE_BITS         * 3
PADCONF_MUXMODE_GPIO         * 4:SHL:PADCONF_MUXMODE_SHIFT
PADCONF_MUXMODE_SAFE         * 7:SHL:PADCONF_MUXMODE_SHIFT
PADCONF_MUXMODE_MASK         * 7:SHL:PADCONF_MUXMODE_SHIFT
PADCONF_PULLUDENABLE_SHIFT   * 3
PADCONF_PULLUDENABLE         * 1:SHL:PADCONF_PULLUDENABLE_SHIFT
PADCONF_PULLTYPESELECT_SHIFT * 4
PADCONF_PULLTYPESELECT       * 1:SHL:PADCONF_PULLTYPESELECT_SHIFT
PADCONF_INPUTENABLE_SHIFT    * 8
PADCONF_INPUTENABLE          * 1:SHL:PADCONF_INPUTENABLE_SHIFT
PADCONF_OFFENABLE            * 1:SHL:9
PADCONF_OFFOUTENABLE         * 1:SHL:10
PADCONF_OFFOUTVALUE          * 1:SHL:11
PADCONF_OFFPULLUDENABLE      * 1:SHL:12
PADCONF_OFFPULLTYPESELECT    * 1:SHL:13
PADCONF_WAKEUPENABLE         * 1:SHL:14
PADCONF_WAKEUPEVENT          * 1:SHL:15

; Offset to CONTROL_PADCONF register from OMAP4460 datasheet Table 18-9 and 18-10
;                                         OMAP4430 datasheet Table 18-8 and 18-9
; Those in CONTROL_WKUP have b15 set, those in CONTROL_CORE do not
GPIOPadConfs
        DCW     &8040, &8042, &8044, &8046, &8048, &8050, &8054, &805A ; 0-31      
        DCW     &805C, &8068, &806A, &01AE, &01B0, &01B2, &01B4, &01B6             
        DCW     &01B8, &01BA, &01BC, &01BE, &01C0, &01C2, &01C4, &01C6             
        DCW     &01C8, &01CA, &01CC, &01CE, &01D0, &8066, &8056, &8058             
        DCW     &0050, &0052, &0054, &0056, &0058, &005A, &005C, &005E ; 32-63     
        DCW     &0060, &0062, &0064, &0066, &0068, &006A, &006C, &006E             
        DCW     &0070, &0072, &0074, &0076, &0078, &007A, &007C, &007E             
        DCW     &0080, &0082, &0084, &0086, &0088, &008A, &008C, &0098             
        DCW     &009A, &009C, &009E, &00A0, &00A2, &00A4, &00A6, &00A8 ; 64-95     
        DCW     &00AA, &00AC, &00AE, &00B0, &00B2, &00B4, &00B6, &00B8             
        DCW     &00BA, &00BC, &00BE, &00C0, &00C2, &00C4, &00C6, &00C8             
        DCW     &00CA, &00CC, &00CE, &00D0, &00D2, &00D4, &00D6, &00D8             
        DCW     &00DA, &00DC, &00DE, &00E0, &00E2, &00E4, &00E6, &00E8 ; 96-127    
        DCW     &00EA, &00EC, &00EE, &00F0, &00F2, &00F4, &00F6, &00F8             
        DCW     &00FA, &00FC, &00FE, &0100, &0102, &0104, &010E, &0110             
        DCW     &0112, &0114, &0116, &0118, &011A, &011C, &011E, &0120             
        DCW     &0126, &0128, &012A, &012C, &012E, &0130, &0132, &0134 ; 128-159   
        DCW     &0136, &0138, &013A, &013C, &013E, &0140, &0142, &0144             
        DCW     &0146, &0148, &014A, &014C, &014E, &0150, &0152, &0154             
        DCW     &0156, &0158, &015A, &015C, &015E, &0160, &0162, &0164             
        DCW     &0166, &0168, &016A, &016C, &016E, &0170, &0172, &0174 ; 160-191   
        DCW     &0176, &0178, &017A, &017C, &017E, &0180, &0182, &0188
        DCW     &018A, &018C, &018E, &0196, &0198, &019A, &019C, &01A0
        DCW     &01A2, &01A4, &01A6, &01A8, &01AA, &01AC, &01D2, &01D4
        ALIGN
GPIOAltsTables
        DCD     GPIOAlts0
        DCD     GPIOAlts1
        DCD     GPIOAlts2
        DCD     GPIOAlts3
        DCD     GPIOAlts4
        DCD     GPIOAlts5

; Available pins per target board
GPIOFreeToUse
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_Panda * GPIO_PORT_MAX)
        DCD     2_00000000000000000001100110000000 ; PandaBoard
        DCD     2_00101001110011001011010111111111
        DCD     2_00000000000011100001111111111000
        DCD     2_00000010000000000000000000000000
        DCD     2_00011000000000000001111111111111
        DCD     2_00000000001000000000000000000000
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_PandaES * GPIO_PORT_MAX)
        DCD     2_00000000000000000011100100000000 ; PandaBoard ES
        DCD     2_00001001110111001011010111111111
        DCD     2_00000000000011100001111111111000
        DCD     2_00000010000000100100000001100000
        DCD     2_00011000000000000001111111111111
        DCD     2_00001000001000000000000000000000
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_Max * GPIO_PORT_MAX)

        ; Init our GPIO HAL devices
        ; a1 = BoardType value
        ; a2 = BoardRevision value
GPIO_InitDevices ROUT
        Push    "v1-v3, lr"

        ADRL    ip, GPIOTypeMap
10
        LDMIA   ip!, {a3,a4,v1}
        CMP     a3, #-1
        CMPEQ   a4, #-1
        Pull    "v1-v3, pc", EQ         ; Not in known table
        TEQ     a3, a1
        TEQEQ   a4, a2
        BNE     %BT10

        ; Copy each port's template and update the varying fields
        MOV     v3, #0
        ADRL    v2, GPIOWS
20
        MOV     a1, v2
        ADRL    a2, GPIOTemplate
        MOV     a3, #HALDevice_GPIO_Size_1_0
        BL      memcpy

        ADR     a2, GPIOFreeToUse
        MOV     a3, #GPIO_PORT_MAX:SHL:2
        MLA     a2, v1, a3, a2          ; Masks for that type
        LDR     a2, [a2, v3, LSL #2]    ; Mask for this port
        STR     a2, [a1, #WkspValidMask]

        STR     sb, [a1, #WkspCopySB]
        STR     v3, [a1, #TNumb - GPIOTemplate]

        ADR     a3, L4_GPIO_Table
        LDR     a3, [a3, v3, LSL #2]    ; Logical address of this port
        STR     a3, [a1, #TAddr - GPIOTemplate]

        ADR     a3, GPIODescriptions
        LDR     a3, [a3, v3, LSL #2]    ; Name of this port
        STR     a3, [a1, #TDesc - GPIOTemplate]

        MOV     a1, #0
        MOV     a2, v2
        CallOS  OS_AddDevice            ; Register it

        ADD     v3, v3, #1              ; Next port
        CMP     v3, #GPIO_PORT_MAX
        ADDCC   v2, v2, #Wksp_GPIO_Size
        BCC     %BT20
        
        Pull    "v1-v3, pc"

GPIOActivate
        MOV     a1, #1
GPIODeactivate
GPIOReset
        MOV     pc, lr

GPIOSleep
        MOV     a1, #0
        MOV     pc, lr

; int GPIOSetDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be set
; Return     a1 = previous value
GPIOSetDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid

        LDR     ip, [a3, #GPIO_OE]
        LDR     a1, [a3, #GPIO_DATAOUT]
        BIC     a4, a1, ip              ; State of outputs
        LDR     a1, [a3, #GPIO_DATAIN]
        AND     a1, a1, ip              ; State of inputs
        ORR     a1, a1, a4

        STRNE   a2, [a3, #GPIO_SETDATAOUT]
        MOV     pc, lr

; int GPIOClearDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be cleared
; Return     a1 = previous value
GPIOClearDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid

        LDR     ip, [a3, #GPIO_OE]
        LDR     a1, [a3, #GPIO_DATAOUT]
        BIC     a4, a1, ip              ; State of outputs
        LDR     a1, [a3, #GPIO_DATAIN]
        AND     a1, a1, ip              ; State of inputs
        ORR     a1, a1, a4

        STRNE   a2, [a3, #GPIO_CLEARDATAOUT]
        MOV     pc, lr

; void GPIOToggleDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be toggled from its current value
GPIOToggleDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid
        MOVEQ   pc, lr

        PHPSEI  ip                      ; No toggle register, emulate in software
        LDR     a1, [a3, #GPIO_DATAOUT]
        EOR     a1, a1, a2
        STR     a1, [a3, #GPIO_DATAOUT]
        PLP     ip

        MOV     pc, lr

; int GPIOReadDataBits(struct gpiodevice *)
; Enter with a1 = device struct pointer
; Return     a1 = previous value
GPIOReadDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]

        LDR     ip, [a3, #GPIO_OE]
        LDR     a1, [a3, #GPIO_DATAOUT]
        BIC     a4, a1, ip              ; State of outputs
        LDR     a1, [a3, #GPIO_DATAIN]
        AND     a1, a1, ip              ; State of inputs
        ORR     a1, a1, a4

        MOV     pc, lr

; int GPIODataDirection(struct gpiodevice *, int pins, int dir)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = direction to set the bits to (1=input 0=output)
; Return     a1 = previous data direction bits (or current if pins=0)
GPIODataDirection ROUT
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid
        LDREQ   a3, [a1, #HALDevice_Address]
        LDREQ   a1, [a3, #GPIO_OE]
        MOVEQ   pc, lr

        Push    "v1-v5, sb, lr"

        MOV     v2, a2
        AND     v3, a4, a3

        LDR     sb, [a1, #WkspCopySB]

        LDR     v4, [a1, #TNumb - GPIOTemplate]
        LDR     v5, [a1, #HALDevice_Address] 

        MOV     v1, #0                  ; Go bitwise because CONTROL_PADCONF has input direction too
10
        MOV     lr, #1
        MOV     lr, lr, LSL v1
        TST     lr, v2
        BEQ     %FT20                   ; No change

        ADD     a1, v1, v4, LSL #5      ; Global pin number
        ANDS    a2, lr, v3
        MOVNE   a2, #1
        MOV     a3, #PADCONF_INPUTENABLE_SHIFT
        MOV     a4, #1
        BL      BitFieldInsertPadConf
20
        ADD     v1, v1, #1
        CMP     v1, #32
        BCC     %BT10

        LDR     a1, [v5, #GPIO_OE]

        PHPSEI  ip                      ; Safe read/modify/write
        BIC     a4, a1, v2
        ORR     a4, a4, v3              ; 1 = input, 0 = output
        STR     a4, [v5, #GPIO_OE]
        PLP     ip

        Pull    "v1-v5, sb, pc"

; void GPIOEdgeControl(struct gpiodevice *, int pins, int *enable, int *edge, int *risehigh)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = pointer to bits to enable detection on
;            a4 = pointer to bits set for edge mode (else level)
;        [sp+0] = pointer to bits set to detect on rising/high (else falling/low)
GPIOEdgeControl ROUT
        LDR     ip, [sp, #0]

        Push    "v1-v5, lr"
        Push    "a3-a4, ip"

        LDR     v1, [a1, #HALDevice_Address]

        LDR     a3, [a3]                ; Pick up new values
        LDR     a4, [a4]
        LDR     ip, [ip]

        PHPSEI  v2                      ; Safe read/modify/write

        LDR     v3, [v1, #GPIO_RISINGDETECT]
        LDR     a1, [v1, #GPIO_FALLINGDETECT]
        MOV     v5, v3                  ; rising = rising
        ORR     v4, v3, a1              ; OR(rising,falling) = edge
        ORR     v3, v3, a1              ; OR(rising,falling) = edge enable
        LDR     lr, [v1, #GPIO_LEVELDETECT1]
        LDR     a1, [v1, #GPIO_LEVELDETECT0]
        ORR     v5, v5, lr              ; OR(rising,high) = rising/high
        ORR     a1, a1, lr
        ORR     v3, v3, a1              ; OR(edge enable,OR(high,low)) = enable
        TEQ     a2, #0
        BEQ     %FT10

        LDR     a1, [v1, #GPIO_RISINGDETECT]
        BIC     a1, a1, a2              ; disable by default
        AND     lr, a3, a4
        AND     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,edge,rising) = rising
        STR     a1, [v1, #GPIO_RISINGDETECT]

        LDR     a1, [v1, #GPIO_FALLINGDETECT]
        BIC     a1, a1, a2              ; disable by default
        AND     lr, a3, a4
        BIC     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,edge,NOT(rising)) = falling
        STR     a1, [v1, #GPIO_FALLINGDETECT]

        LDR     a1, [v1, #GPIO_LEVELDETECT1]
        BIC     a1, a1, a2              ; disable by default
        BIC     lr, a3, a4
        AND     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,NOT(edge),rising) = high
        STR     a1, [v1, #GPIO_LEVELDETECT1]

        LDR     a1, [v1, #GPIO_LEVELDETECT0]
        BIC     a1, a1, a2              ; disable by default
        BIC     lr, a3, a4
        BIC     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,NOT(edge),NOT(rising)) = low
        STR     a1, [v1, #GPIO_LEVELDETECT0]
10
        PLP     v2

        Pull    "a3-a4, ip"
        STR     v3, [a3]                ; Write out previous values
        STR     v4, [a4]
        STR     v5, [ip]

        Pull    "v1-v5, pc"
 
; int GPIOEdgePollStatus(struct gpiodevice *, int collect)
; Enter with a1 = device struct pointer
;            a2 = clear these bits having polled the status
; Return     a1 = states latched in edge/level since last poll
GPIOEdgePollStatus ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being cleared are valid
        LDR     a1, [a3, #GPIO_IRQSTATUS_0]
        STRNE   a2, [a3, #GPIO_IRQSTATUS_0]
        MOV     pc, lr

; enum HAL_GPIOReadMode(struct gpiodevice *, int pin)
; Enter with a1 = device struct pointer
;            a2 = pin (singular) to read
; Return     a1 = current mode
GPIOReadMode ROUT
        MOV     a3, #-1
        ; Fall through

; enum GPIOWriteMode(struct gpiodevice *, int pin, enum useage)
; Enter with a1 = device struct pointer
;            a2 = pin (singular) to change
;            a3 = new mode (opaque value from Enumerate)
; Return     a1 = previous mode
GPIOWriteMode      
        Push    "sb, lr"

        LDR     sb, [a1, #WkspCopySB]

        LDR     a4, [a1, #TNumb - GPIOTemplate]
        ADD     a1, a2, a4, LSL #5      ; Global pin number
        MOV     a2, a3
        MOV     a3, #PADCONF_MUXMODE_SHIFT
        MOV     a4, #PADCONF_MUXMODE_BITS
        BL      BitFieldInsertPadConf
        ASSERT  PADCONF_MUXMODE_SHIFT = 0

        Pull    "sb, pc"

; int GPIOPullControl(struct gpiodevice *, int pins, int enable)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = pull resistor enables for those pins
; Return     a1 = previous pull enable bits (or current if pins=0)
GPIOPullControl ROUT
        Push    "v1-v5, sb, lr"

        LDR     v5, [a1, #TNumb - GPIOTemplate]
        LDR     a4, [a1, #WkspValidMask]
        AND     v3, a4, a3
        AND     v2, a4, a2

        LDR     sb, [a1, #WkspCopySB]

        MOV     v4, #0                  ; Previous values
        MOV     v1, #0                  ; For each pin
10
        ADD     a1, v1, v5, LSL #5      ; Global pin number
        MOV     lr, #1
        MOV     lr, lr, LSL v1
        ANDS    a2, lr, v3
        MOVNE   a2, #1
        TST     v2, lr
        MOVEQ   a2, #-1                 ; No change
        MOV     a3, #PADCONF_PULLUDENABLE_SHIFT
        MOV     a4, #1
        BL      BitFieldInsertPadConf
        TEQ     a1, #0
        ORRNE   v4, v4, #1:SHL:31       ; Was previously set

        ADD     v1, v1, #1              ; Next pin
        CMP     v1, #32
        MOVCC   v4, v4, LSR #1
        BCC     %BT10

        MOV     a1, v4

        Pull    "v1-v5, sb, pc"

; int GPIOPullDirection(struct gpiodevice *, int pins, int up)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = bits to set as pull up else pull down
; Return     a1 = previous pull direction bits (or current if pins=0)
GPIOPullDirection ROUT 
        Push    "v1-v5, sb, lr"

        LDR     v5, [a1, #TNumb - GPIOTemplate]
        LDR     a4, [a1, #WkspValidMask]
        AND     v3, a4, a3
        AND     v2, a4, a2

        LDR     sb, [a1, #WkspCopySB]

        MOV     v4, #0                  ; Previous values
        MOV     v1, #0                  ; For each pin
10
        ADD     a1, v1, v5, LSL #5      ; Global pin number
        MOV     lr, #1
        MOV     lr, lr, LSL v1
        ANDS    a2, lr, v3
        MOVNE   a2, #1
        TST     v2, lr
        MOVEQ   a2, #-1                 ; No change
        MOV     a3, #PADCONF_PULLTYPESELECT_SHIFT
        MOV     a4, #1
        BL      BitFieldInsertPadConf
        TEQ     a1, #0
        ORRNE   v4, v4, #1:SHL:31       ; Was previously set

        ADD     v1, v1, #1              ; Next pin
        CMP     v1, #32
        MOVCC   v4, v4, LSR #1
        BCC     %BT10

        MOV     a1, v4

        Pull    "v1-v5, sb, pc"

; int BitFieldInsertPadConf(int pin, int value, int lsb, int width)
; Enter with a1 = flattened pin number
;            a2 = new value for bit(s), or -1 to read
;            a3 = leftmost bit position
;            a4 = bit width
;            sb = HAL workspace
; Return     a1 = old value for bit(s)
BitFieldInsertPadConf ROUT
        Push   "v1, lr"

        MOV     v1, #1
        MOV     v1, v1, LSL a4
        SUB     v1, v1, #1              ; Mask of bits to change
        CMP     a2, #-1
        ANDNE   a2, a2, v1              ; Sanitised input value

        ADRL    lr, GPIOPadConfs        ; Array of half words
        ADD     lr, lr, a1, LSL #1
        LDRSH   lr, [lr]                ; Offset from L4_Control
        CMP     lr, #-1
        Pull    "v1, pc", EQ            ; Missing PADCONF register
       
        TST     lr, #1:SHL:15           ; WKUP or CORE?
        BFC     lr, #15, #17
        LDREQ   a1, L4_Core_Log
        ADDEQ   a1, a1, #L4_SYSCTRL_PADCONF_CORE-L4_Core
        LDRNE   a1, L4_Wakeup_Log
        ADDNE   a1, a1, #L4_SYSCTRL_PADCONF_WKUP-L4_Wakeup
        ADD     lr, a1, lr

        PHPSEI  ip                      ; Safe read/modify/write
        LDRH    a1, [lr]                ; 18.4.8 "These registers can be accessed using 8-, 16-, or 32-bit operations"
        CMP     a2, #-1
        BICNE   a4, a1, v1, LSL a3
        ORRNE   a4, a4, a2, LSL a3
        STRNEH  a4, [lr]
        PLP     ip

        MOV     a1, a1, LSR a3
        AND     a1, a1, v1

        Pull    "v1, pc"

; struct onepin *GPIOEnumerate(struct gpiodevice *, int *carryon)
; Enter with a1 = device struct pointer
;            a2 = pointer to continuation value (0 to start)
; Return     a1 = pointer to pin info for one more pin
;            continuation value updated (-1 if no more)
GPIOEnumerate
        Push    "v1-v3, lr"

        LDR     v1, [a1, #WkspValidMask]
        LDR     a1, [a1, #TNumb - GPIOTemplate]

        LDR     a3, [a2]                ; Just use the continuation value as a bit position
        CMP     a3, #32
        BCS     %FT60                   ; Out of bounds

        CMP     a3, #0
        BNE     %FT20                   ; Not the start condition

        MOVS    ip, v1
        BEQ     %FT60                   ; No valid pins
10
        ; Find first set
        MOVS    ip, ip, LSR #1          
        ADDCC   a3, a3, #1
        BCC     %BT10
20
        MOV     ip, #1
        TST     v1, ip, LSL a3
        BEQ     %FT60                   ; Invalid on this target

        ADRL    v2, GPIOAltsTables
        LDR     v2, [v2, a1, LSL #2]    ; Start of pin data
        MOV     v3, #0
30
        LDR     ip, [v2], #4            ; Fetch & skip private word
        CMP     ip, #-1
        BEQ     %FT60                   ; Reached table end

        TEQ     v3, a3
        MOVEQ   a1, v2
        BEQ     %FT40

        ; Jump to next item
        ADD     v2, v2, #GPIOEnumerate_GroupList
        ADD     ip, ip, #1              ; List terminator is one entry
        ASSERT  GPIOGroupList_Size = 4
        ADD     v2, v2, ip, LSL #2      ; Account for list entries
        ADD     v3, v3, #1              ; Next pin
        B       %BT30
40
        ; Find next set
        ADD     v3, v3, #1
        CMP     v3, #32
        MOVNES  v1, v1, LSR v3
        BEQ     %FT70
50
        MOVS    v1, v1, LSR #1
        ADDCC   v3, v3, #1
        BCC     %BT50

        STR     v3, [a2]

        Pull    "v1-v3, pc"
60
        MOV     a1, #0                  ; Nothing found
70
        MOV     ip, #-1                 ; Continuation value set for last one
        STR     ip, [a2]

        Pull    "v1-v3, pc"

        GET     hdr.GPIOPadConf

        END
@


1.8
log
@Add GPIO device implementation
Update to API 1.0, and corresponding set of register wide accessor functions.
The tables of permitted pins come from staring at the schematics for any connectors, minus those that are "owned" by the OS.

Tested on a Pandaboard, toggling the two user LEDs and scanning the 'USER' push button (which, by the way, needs the pullup enabling as there isn't a discrete one).

Version 0.58. Tagged as 'OMAP4-0_58'
@
text
@d43 2
a44 2
        MOV     a2, #6
        MOV     a3, #0
d48 1
a48 1
        STR     a3, [a4, #GPIO_IRQENABLE1]
d105 1
a105 1
        STR     a4, [a3, #GPIO_SETIRQENABLE1]
d258 1
a258 1
        ; Init the GPIO HAL device
d519 2
a520 2
        LDR     a1, [a3, #GPIO_IRQSTATUS1]
        STRNE   a2, [a3, #GPIO_IRQSTATUS1]
@


1.7
log
@Make type and revision private
Adopt the board type and revision enum privately in board.hdr (mass search & replace exercise).
Don't re-export it via a stub GPIO device; it's private.

Version 0.56. Tagged as 'OMAP4-0_56'
@
text
@d37 1
a37 1
        EXPORT  GPIO_InitDevice
d109 149
d259 262
a520 3
        ; a1 = GPIOType value
        ; a2 = GPIORevision value
GPIO_InitDevice
d523 224
@


1.6
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Built, but not tested.

Version 0.44. Tagged as 'OMAP4-0_44'
@
text
@a112 45
        Push    "a1-a2,lr"
        ADRL    a1, GPIOWS
        ADR     a2, GPIOTemplate
        MOV     a3, #HALDeviceSize
        BL      memcpy
        Pull    "a1-a2,lr"
        ADRL    a3, GPIOWS
        STR     a1, [a3, #HALDevice_GPIOType]
        STR     a2, [a3, #HALDevice_GPIORevision]
        MOV     a2, a3
        MOV     a1, #0
        LDR     pc, OSentries + 4*OS_AddDevice ; Tail call

; Generic HAL device used for all board types
GPIOTemplate
        DCW     HALDeviceType_Comms + HALDeviceComms_GPIO
        DCW     HALDeviceID_GPIO_OMAP4
        DCD     HALDeviceBus_Peri + HALDevicePeriBus_Sonics3220
        DCD     0               ; API version
        DCD     GPIODesc        ; Description
        DCD     0               ; Address (none)
        %       12              ; Reserved
        DCD     GPIOActivate
        DCD     GPIODeactivate
        DCD     GPIOReset
        DCD     GPIOSleep
        DCD     -1              ; Device (none)
        DCD     0               ; TestIRQ
        DCD     0               ; ClearIRQ
        %       4
        ASSERT  (.-GPIOTemplate) = HALDeviceSize

GPIODesc
        =       "OMAP4 GPIO interface", 0
        ALIGN

        ; These don't do much
GPIOActivate
        MOV     a1, #1
GPIODeactivate
GPIOReset
        MOV     pc, lr

GPIOSleep
        MOV     a1, #0
@


1.6.2.1
log
@Merge in latest changes from HEAD

Version 0.59, 1.52.2.3. Tagged as 'OMAP4-0_59-1_52_2_3'
@
text
@d37 1
a37 1
        EXPORT  GPIO_InitDevices
d43 2
a44 2
        MOV     a2, #GPIO_PORT_MAX
        MVN     a3, #0
d48 1
a48 1
        STR     a3, [a4, #GPIO_IRQSTATUS_CLR_0]
d105 1
a105 1
        STR     a4, [a3, #GPIO_IRQSTATUS_SET_0]
d109 18
a126 1
; Template for GPIO interface
d131 3
a133 3
        DCD     &10000          ; API 1.0
TDesc   DCD     0               ; Description (filled at runtime)
TAddr   DCD     0               ; Address (filled at runtime)
d142 2
a143 35
        %       4               ; Reserved
        DCD     GPIO_PORT_MAX
TNumb   DCD     0               ; Port number (filled at runtime)
        DCD     GPIOEnumerate
        DCD     GPIOSetDataBits
        DCD     GPIOClearDataBits
        DCD     GPIOToggleDataBits
        DCD     GPIOReadDataBits
        DCD     GPIODataDirection
        DCD     GPIOReadMode
        DCD     GPIOWriteMode
        DCD     GPIOPullControl
        DCD     GPIOPullDirection
        DCD     GPIOEdgeControl
        DCD     GPIOEdgePollStatus
        ASSERT  (. - GPIOTemplate) = HALDevice_GPIO_Size_1_0

; GPIO structures
                    ^ 0
                    # HALDevice_GPIO_Size_1_0
WkspValidMask       # 4                 ; Valid bits on this port for this Type/Revision
WkspCopySB          # 4
Wksp_GPIO_Size      # 0
                    ASSERT ?GPIOWS = GPIO_PORT_MAX * Wksp_GPIO_Size

; Map Type/Revision to entry in GPIOFreeToUse table
                    ^ 0
GPIOType_Panda      # 1 ; OMAP4430
GPIOType_PandaES    # 1 ; OMAP4460
GPIOType_Max        # 0

GPIOTypeMap
        DCD     BoardType_OMAP4_Panda, BoardRevision_Panda,   GPIOType_Panda
        DCD     BoardType_OMAP4_Panda, BoardRevision_PandaES, GPIOType_PandaES
        DCD     -1, -1, -1
d145 2
a146 13
; Friendly names
GPIODesc0
        DCB     "OMAP GPIO interface pins 0-31", 0
GPIODesc1
        DCB     "OMAP GPIO interface pins 32-63", 0
GPIODesc2
        DCB     "OMAP GPIO interface pins 64-95", 0
GPIODesc3
        DCB     "OMAP GPIO interface pins 96-127", 0
GPIODesc4
        DCB     "OMAP GPIO interface pins 128-159", 0
GPIODesc5
        DCB     "OMAP GPIO interface pins 160-191", 0
a147 135
GPIODescriptions
        DCD     GPIODesc0
        DCD     GPIODesc1
        DCD     GPIODesc2
        DCD     GPIODesc3
        DCD     GPIODesc4
        DCD     GPIODesc5

; Half a register of CONTROL_PADCONF
PADCONF_MUXMODE_SHIFT        * 0
PADCONF_MUXMODE_BITS         * 3
PADCONF_MUXMODE_GPIO         * 4:SHL:PADCONF_MUXMODE_SHIFT
PADCONF_MUXMODE_SAFE         * 7:SHL:PADCONF_MUXMODE_SHIFT
PADCONF_MUXMODE_MASK         * 7:SHL:PADCONF_MUXMODE_SHIFT
PADCONF_PULLUDENABLE_SHIFT   * 3
PADCONF_PULLUDENABLE         * 1:SHL:PADCONF_PULLUDENABLE_SHIFT
PADCONF_PULLTYPESELECT_SHIFT * 4
PADCONF_PULLTYPESELECT       * 1:SHL:PADCONF_PULLTYPESELECT_SHIFT
PADCONF_INPUTENABLE_SHIFT    * 8
PADCONF_INPUTENABLE          * 1:SHL:PADCONF_INPUTENABLE_SHIFT
PADCONF_OFFENABLE            * 1:SHL:9
PADCONF_OFFOUTENABLE         * 1:SHL:10
PADCONF_OFFOUTVALUE          * 1:SHL:11
PADCONF_OFFPULLUDENABLE      * 1:SHL:12
PADCONF_OFFPULLTYPESELECT    * 1:SHL:13
PADCONF_WAKEUPENABLE         * 1:SHL:14
PADCONF_WAKEUPEVENT          * 1:SHL:15

; Offset to CONTROL_PADCONF register from OMAP4460 datasheet Table 18-9 and 18-10
;                                         OMAP4430 datasheet Table 18-8 and 18-9
; Those in CONTROL_WKUP have b15 set, those in CONTROL_CORE do not
GPIOPadConfs
        DCW     &8040, &8042, &8044, &8046, &8048, &8050, &8054, &805A ; 0-31      
        DCW     &805C, &8068, &806A, &01AE, &01B0, &01B2, &01B4, &01B6             
        DCW     &01B8, &01BA, &01BC, &01BE, &01C0, &01C2, &01C4, &01C6             
        DCW     &01C8, &01CA, &01CC, &01CE, &01D0, &8066, &8056, &8058             
        DCW     &0050, &0052, &0054, &0056, &0058, &005A, &005C, &005E ; 32-63     
        DCW     &0060, &0062, &0064, &0066, &0068, &006A, &006C, &006E             
        DCW     &0070, &0072, &0074, &0076, &0078, &007A, &007C, &007E             
        DCW     &0080, &0082, &0084, &0086, &0088, &008A, &008C, &0098             
        DCW     &009A, &009C, &009E, &00A0, &00A2, &00A4, &00A6, &00A8 ; 64-95     
        DCW     &00AA, &00AC, &00AE, &00B0, &00B2, &00B4, &00B6, &00B8             
        DCW     &00BA, &00BC, &00BE, &00C0, &00C2, &00C4, &00C6, &00C8             
        DCW     &00CA, &00CC, &00CE, &00D0, &00D2, &00D4, &00D6, &00D8             
        DCW     &00DA, &00DC, &00DE, &00E0, &00E2, &00E4, &00E6, &00E8 ; 96-127    
        DCW     &00EA, &00EC, &00EE, &00F0, &00F2, &00F4, &00F6, &00F8             
        DCW     &00FA, &00FC, &00FE, &0100, &0102, &0104, &010E, &0110             
        DCW     &0112, &0114, &0116, &0118, &011A, &011C, &011E, &0120             
        DCW     &0126, &0128, &012A, &012C, &012E, &0130, &0132, &0134 ; 128-159   
        DCW     &0136, &0138, &013A, &013C, &013E, &0140, &0142, &0144             
        DCW     &0146, &0148, &014A, &014C, &014E, &0150, &0152, &0154             
        DCW     &0156, &0158, &015A, &015C, &015E, &0160, &0162, &0164             
        DCW     &0166, &0168, &016A, &016C, &016E, &0170, &0172, &0174 ; 160-191   
        DCW     &0176, &0178, &017A, &017C, &017E, &0180, &0182, &0188
        DCW     &018A, &018C, &018E, &0196, &0198, &019A, &019C, &01A0
        DCW     &01A2, &01A4, &01A6, &01A8, &01AA, &01AC, &01D2, &01D4
        ALIGN
GPIOAltsTables
        DCD     GPIOAlts0
        DCD     GPIOAlts1
        DCD     GPIOAlts2
        DCD     GPIOAlts3
        DCD     GPIOAlts4
        DCD     GPIOAlts5

; Available pins per target board
GPIOFreeToUse
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_Panda * GPIO_PORT_MAX)
        DCD     2_00000000000000000001100110000000 ; PandaBoard
        DCD     2_00101001110011001011010111111111
        DCD     2_00000000000011100001111111111000
        DCD     2_00000010000000000000000000000000
        DCD     2_00011000000000000001111111111111
        DCD     2_00000000001000000000000000000000
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_PandaES * GPIO_PORT_MAX)
        DCD     2_00000000000000000011100100000000 ; PandaBoard ES
        DCD     2_00001001110111001011010111111111
        DCD     2_00000000000011100001111111111000
        DCD     2_00000010000000100100000001100000
        DCD     2_00011000000000000001111111111111
        DCD     2_00001000001000000000000000000000
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_Max * GPIO_PORT_MAX)

        ; Init our GPIO HAL devices
        ; a1 = BoardType value
        ; a2 = BoardRevision value
GPIO_InitDevices ROUT
        Push    "v1-v3, lr"

        ADRL    ip, GPIOTypeMap
10
        LDMIA   ip!, {a3,a4,v1}
        CMP     a3, #-1
        CMPEQ   a4, #-1
        Pull    "v1-v3, pc", EQ         ; Not in known table
        TEQ     a3, a1
        TEQEQ   a4, a2
        BNE     %BT10

        ; Copy each port's template and update the varying fields
        MOV     v3, #0
        ADRL    v2, GPIOWS
20
        MOV     a1, v2
        ADRL    a2, GPIOTemplate
        MOV     a3, #HALDevice_GPIO_Size_1_0
        BL      memcpy

        ADR     a2, GPIOFreeToUse
        MOV     a3, #GPIO_PORT_MAX:SHL:2
        MLA     a2, v1, a3, a2          ; Masks for that type
        LDR     a2, [a2, v3, LSL #2]    ; Mask for this port
        STR     a2, [a1, #WkspValidMask]

        STR     sb, [a1, #WkspCopySB]
        STR     v3, [a1, #TNumb - GPIOTemplate]

        ADR     a3, L4_GPIO_Table
        LDR     a3, [a3, v3, LSL #2]    ; Logical address of this port
        STR     a3, [a1, #TAddr - GPIOTemplate]

        ADR     a3, GPIODescriptions
        LDR     a3, [a3, v3, LSL #2]    ; Name of this port
        STR     a3, [a1, #TDesc - GPIOTemplate]

        MOV     a1, #0
        MOV     a2, v2
        CallOS  OS_AddDevice            ; Register it

        ADD     v3, v3, #1              ; Next port
        CMP     v3, #GPIO_PORT_MAX
        ADDCC   v2, v2, #Wksp_GPIO_Size
        BCC     %BT20
        
        Pull    "v1-v3, pc"
d149 1
a159 426
; int GPIOSetDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be set
; Return     a1 = previous value
GPIOSetDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid

        LDR     ip, [a3, #GPIO_OE]
        LDR     a1, [a3, #GPIO_DATAOUT]
        BIC     a4, a1, ip              ; State of outputs
        LDR     a1, [a3, #GPIO_DATAIN]
        AND     a1, a1, ip              ; State of inputs
        ORR     a1, a1, a4

        STRNE   a2, [a3, #GPIO_SETDATAOUT]
        MOV     pc, lr

; int GPIOClearDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be cleared
; Return     a1 = previous value
GPIOClearDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid

        LDR     ip, [a3, #GPIO_OE]
        LDR     a1, [a3, #GPIO_DATAOUT]
        BIC     a4, a1, ip              ; State of outputs
        LDR     a1, [a3, #GPIO_DATAIN]
        AND     a1, a1, ip              ; State of inputs
        ORR     a1, a1, a4

        STRNE   a2, [a3, #GPIO_CLEARDATAOUT]
        MOV     pc, lr

; void GPIOToggleDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be toggled from its current value
GPIOToggleDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid
        MOVEQ   pc, lr

        PHPSEI  ip                      ; No toggle register, emulate in software
        LDR     a1, [a3, #GPIO_DATAOUT]
        EOR     a1, a1, a2
        STR     a1, [a3, #GPIO_DATAOUT]
        PLP     ip

        MOV     pc, lr

; int GPIOReadDataBits(struct gpiodevice *)
; Enter with a1 = device struct pointer
; Return     a1 = previous value
GPIOReadDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]

        LDR     ip, [a3, #GPIO_OE]
        LDR     a1, [a3, #GPIO_DATAOUT]
        BIC     a4, a1, ip              ; State of outputs
        LDR     a1, [a3, #GPIO_DATAIN]
        AND     a1, a1, ip              ; State of inputs
        ORR     a1, a1, a4

        MOV     pc, lr

; int GPIODataDirection(struct gpiodevice *, int pins, int dir)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = direction to set the bits to (1=input 0=output)
; Return     a1 = previous data direction bits (or current if pins=0)
GPIODataDirection ROUT
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid
        LDREQ   a3, [a1, #HALDevice_Address]
        LDREQ   a1, [a3, #GPIO_OE]
        MOVEQ   pc, lr

        Push    "v1-v5, sb, lr"

        MOV     v2, a2
        AND     v3, a4, a3

        LDR     sb, [a1, #WkspCopySB]

        LDR     v4, [a1, #TNumb - GPIOTemplate]
        LDR     v5, [a1, #HALDevice_Address] 

        MOV     v1, #0                  ; Go bitwise because CONTROL_PADCONF has input direction too
10
        MOV     lr, #1
        MOV     lr, lr, LSL v1
        TST     lr, v2
        BEQ     %FT20                   ; No change

        ADD     a1, v1, v4, LSL #5      ; Global pin number
        ANDS    a2, lr, v3
        MOVNE   a2, #1
        MOV     a3, #PADCONF_INPUTENABLE_SHIFT
        MOV     a4, #1
        BL      BitFieldInsertPadConf
20
        ADD     v1, v1, #1
        CMP     v1, #32
        BCC     %BT10

        LDR     a1, [v5, #GPIO_OE]

        PHPSEI  ip                      ; Safe read/modify/write
        BIC     a4, a1, v2
        ORR     a4, a4, v3              ; 1 = input, 0 = output
        STR     a4, [v5, #GPIO_OE]
        PLP     ip

        Pull    "v1-v5, sb, pc"

; void GPIOEdgeControl(struct gpiodevice *, int pins, int *enable, int *edge, int *risehigh)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = pointer to bits to enable detection on
;            a4 = pointer to bits set for edge mode (else level)
;        [sp+0] = pointer to bits set to detect on rising/high (else falling/low)
GPIOEdgeControl ROUT
        LDR     ip, [sp, #0]

        Push    "v1-v5, lr"
        Push    "a3-a4, ip"

        LDR     v1, [a1, #HALDevice_Address]

        LDR     a3, [a3]                ; Pick up new values
        LDR     a4, [a4]
        LDR     ip, [ip]

        PHPSEI  v2                      ; Safe read/modify/write

        LDR     v3, [v1, #GPIO_RISINGDETECT]
        LDR     a1, [v1, #GPIO_FALLINGDETECT]
        MOV     v5, v3                  ; rising = rising
        ORR     v4, v3, a1              ; OR(rising,falling) = edge
        ORR     v3, v3, a1              ; OR(rising,falling) = edge enable
        LDR     lr, [v1, #GPIO_LEVELDETECT1]
        LDR     a1, [v1, #GPIO_LEVELDETECT0]
        ORR     v5, v5, lr              ; OR(rising,high) = rising/high
        ORR     a1, a1, lr
        ORR     v3, v3, a1              ; OR(edge enable,OR(high,low)) = enable
        TEQ     a2, #0
        BEQ     %FT10

        LDR     a1, [v1, #GPIO_RISINGDETECT]
        BIC     a1, a1, a2              ; disable by default
        AND     lr, a3, a4
        AND     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,edge,rising) = rising
        STR     a1, [v1, #GPIO_RISINGDETECT]

        LDR     a1, [v1, #GPIO_FALLINGDETECT]
        BIC     a1, a1, a2              ; disable by default
        AND     lr, a3, a4
        BIC     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,edge,NOT(rising)) = falling
        STR     a1, [v1, #GPIO_FALLINGDETECT]

        LDR     a1, [v1, #GPIO_LEVELDETECT1]
        BIC     a1, a1, a2              ; disable by default
        BIC     lr, a3, a4
        AND     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,NOT(edge),rising) = high
        STR     a1, [v1, #GPIO_LEVELDETECT1]

        LDR     a1, [v1, #GPIO_LEVELDETECT0]
        BIC     a1, a1, a2              ; disable by default
        BIC     lr, a3, a4
        BIC     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,NOT(edge),NOT(rising)) = low
        STR     a1, [v1, #GPIO_LEVELDETECT0]
10
        PLP     v2

        Pull    "a3-a4, ip"
        STR     v3, [a3]                ; Write out previous values
        STR     v4, [a4]
        STR     v5, [ip]

        Pull    "v1-v5, pc"
 
; int GPIOEdgePollStatus(struct gpiodevice *, int collect)
; Enter with a1 = device struct pointer
;            a2 = clear these bits having polled the status
; Return     a1 = states latched in edge/level since last poll
GPIOEdgePollStatus ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being cleared are valid
        LDR     a1, [a3, #GPIO_IRQSTATUS_0]
        STRNE   a2, [a3, #GPIO_IRQSTATUS_0]
        MOV     pc, lr

; enum HAL_GPIOReadMode(struct gpiodevice *, int pin)
; Enter with a1 = device struct pointer
;            a2 = pin (singular) to read
; Return     a1 = current mode
GPIOReadMode ROUT
        MOV     a3, #-1
        ; Fall through

; enum GPIOWriteMode(struct gpiodevice *, int pin, enum useage)
; Enter with a1 = device struct pointer
;            a2 = pin (singular) to change
;            a3 = new mode (opaque value from Enumerate)
; Return     a1 = previous mode
GPIOWriteMode      
        Push    "sb, lr"

        LDR     sb, [a1, #WkspCopySB]

        LDR     a4, [a1, #TNumb - GPIOTemplate]
        ADD     a1, a2, a4, LSL #5      ; Global pin number
        MOV     a2, a3
        MOV     a3, #PADCONF_MUXMODE_SHIFT
        MOV     a4, #PADCONF_MUXMODE_BITS
        BL      BitFieldInsertPadConf
        ASSERT  PADCONF_MUXMODE_SHIFT = 0

        Pull    "sb, pc"

; int GPIOPullControl(struct gpiodevice *, int pins, int enable)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = pull resistor enables for those pins
; Return     a1 = previous pull enable bits (or current if pins=0)
GPIOPullControl ROUT
        Push    "v1-v5, sb, lr"

        LDR     v5, [a1, #TNumb - GPIOTemplate]
        LDR     a4, [a1, #WkspValidMask]
        AND     v3, a4, a3
        AND     v2, a4, a2

        LDR     sb, [a1, #WkspCopySB]

        MOV     v4, #0                  ; Previous values
        MOV     v1, #0                  ; For each pin
10
        ADD     a1, v1, v5, LSL #5      ; Global pin number
        MOV     lr, #1
        MOV     lr, lr, LSL v1
        ANDS    a2, lr, v3
        MOVNE   a2, #1
        TST     v2, lr
        MOVEQ   a2, #-1                 ; No change
        MOV     a3, #PADCONF_PULLUDENABLE_SHIFT
        MOV     a4, #1
        BL      BitFieldInsertPadConf
        TEQ     a1, #0
        ORRNE   v4, v4, #1:SHL:31       ; Was previously set

        ADD     v1, v1, #1              ; Next pin
        CMP     v1, #32
        MOVCC   v4, v4, LSR #1
        BCC     %BT10

        MOV     a1, v4

        Pull    "v1-v5, sb, pc"

; int GPIOPullDirection(struct gpiodevice *, int pins, int up)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = bits to set as pull up else pull down
; Return     a1 = previous pull direction bits (or current if pins=0)
GPIOPullDirection ROUT 
        Push    "v1-v5, sb, lr"

        LDR     v5, [a1, #TNumb - GPIOTemplate]
        LDR     a4, [a1, #WkspValidMask]
        AND     v3, a4, a3
        AND     v2, a4, a2

        LDR     sb, [a1, #WkspCopySB]

        MOV     v4, #0                  ; Previous values
        MOV     v1, #0                  ; For each pin
10
        ADD     a1, v1, v5, LSL #5      ; Global pin number
        MOV     lr, #1
        MOV     lr, lr, LSL v1
        ANDS    a2, lr, v3
        MOVNE   a2, #1
        TST     v2, lr
        MOVEQ   a2, #-1                 ; No change
        MOV     a3, #PADCONF_PULLTYPESELECT_SHIFT
        MOV     a4, #1
        BL      BitFieldInsertPadConf
        TEQ     a1, #0
        ORRNE   v4, v4, #1:SHL:31       ; Was previously set

        ADD     v1, v1, #1              ; Next pin
        CMP     v1, #32
        MOVCC   v4, v4, LSR #1
        BCC     %BT10

        MOV     a1, v4

        Pull    "v1-v5, sb, pc"

; int BitFieldInsertPadConf(int pin, int value, int lsb, int width)
; Enter with a1 = flattened pin number
;            a2 = new value for bit(s), or -1 to read
;            a3 = leftmost bit position
;            a4 = bit width
;            sb = HAL workspace
; Return     a1 = old value for bit(s)
BitFieldInsertPadConf ROUT
        Push   "v1, lr"

        MOV     v1, #1
        MOV     v1, v1, LSL a4
        SUB     v1, v1, #1              ; Mask of bits to change
        CMP     a2, #-1
        ANDNE   a2, a2, v1              ; Sanitised input value

        ADRL    lr, GPIOPadConfs        ; Array of half words
        ADD     lr, lr, a1, LSL #1
        LDRSH   lr, [lr]                ; Offset from L4_Control
        CMP     lr, #-1
        Pull    "v1, pc", EQ            ; Missing PADCONF register
       
        TST     lr, #1:SHL:15           ; WKUP or CORE?
        BFC     lr, #15, #17
        LDREQ   a1, L4_Core_Log
        ADDEQ   a1, a1, #L4_SYSCTRL_PADCONF_CORE-L4_Core
        LDRNE   a1, L4_Wakeup_Log
        ADDNE   a1, a1, #L4_SYSCTRL_PADCONF_WKUP-L4_Wakeup
        ADD     lr, a1, lr

        PHPSEI  ip                      ; Safe read/modify/write
        LDRH    a1, [lr]                ; 18.4.8 "These registers can be accessed using 8-, 16-, or 32-bit operations"
        CMP     a2, #-1
        BICNE   a4, a1, v1, LSL a3
        ORRNE   a4, a4, a2, LSL a3
        STRNEH  a4, [lr]
        PLP     ip

        MOV     a1, a1, LSR a3
        AND     a1, a1, v1

        Pull    "v1, pc"

; struct onepin *GPIOEnumerate(struct gpiodevice *, int *carryon)
; Enter with a1 = device struct pointer
;            a2 = pointer to continuation value (0 to start)
; Return     a1 = pointer to pin info for one more pin
;            continuation value updated (-1 if no more)
GPIOEnumerate
        Push    "v1-v3, lr"

        LDR     v1, [a1, #WkspValidMask]
        LDR     a1, [a1, #TNumb - GPIOTemplate]

        LDR     a3, [a2]                ; Just use the continuation value as a bit position
        CMP     a3, #32
        BCS     %FT60                   ; Out of bounds

        CMP     a3, #0
        BNE     %FT20                   ; Not the start condition

        MOVS    ip, v1
        BEQ     %FT60                   ; No valid pins
10
        ; Find first set
        MOVS    ip, ip, LSR #1          
        ADDCC   a3, a3, #1
        BCC     %BT10
20
        MOV     ip, #1
        TST     v1, ip, LSL a3
        BEQ     %FT60                   ; Invalid on this target

        ADRL    v2, GPIOAltsTables
        LDR     v2, [v2, a1, LSL #2]    ; Start of pin data
        MOV     v3, #0
30
        LDR     ip, [v2], #4            ; Fetch & skip private word
        CMP     ip, #-1
        BEQ     %FT60                   ; Reached table end

        TEQ     v3, a3
        MOVEQ   a1, v2
        BEQ     %FT40

        ; Jump to next item
        ADD     v2, v2, #GPIOEnumerate_GroupList
        ADD     ip, ip, #1              ; List terminator is one entry
        ASSERT  GPIOGroupList_Size = 4
        ADD     v2, v2, ip, LSL #2      ; Account for list entries
        ADD     v3, v3, #1              ; Next pin
        B       %BT30
40
        ; Find next set
        ADD     v3, v3, #1
        CMP     v3, #32
        MOVNES  v1, v1, LSR v3
        BEQ     %FT70
50
        MOVS    v1, v1, LSR #1
        ADDCC   v3, v3, #1
        BCC     %BT50

        STR     v3, [a2]

        Pull    "v1-v3, pc"
60
        MOV     a1, #0                  ; Nothing found
70
        MOV     ip, #-1                 ; Continuation value set for last one
        STR     ip, [a2]

        Pull    "v1-v3, pc"

        GET     hdr.GPIOPadConf

@


1.5
log
@Change over to reassigned bus types
Note, the SDIO controller was previously misreported as being on L4, when in fact it's on L3.

Version 0.39. Tagged as 'OMAP4-0_39'
@
text
@a37 2
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
@


1.4
log
@Add skeleton GPIO device
Changes from Willi Theiss.
Built, but not tested here.

Version 0.16. Tagged as 'OMAP4-0_16'
@
text
@d132 1
a132 1
        DCD     HALDeviceBus_Interconnect + HALDeviceInterconnectBus_L4
@


1.3
log
@Tidy ups to OMAP4
hdr.GPIO
  removed TWL/TPS pins (not available on OMAP4/TWL6030)
s.GPIO
  removed TWL/TPS related GPIO pins (not available on OMAP4/TWL6030)
s.SDIO
  some code cleanup (remove OMAP3 specific stuff)
s.Boot
  some code tweaks (tidy up)

Changes from Willi Theiss. Built, but not tested here.

Version 0.15. Tagged as 'OMAP4-0_15'
@
text
@d37 1
a37 1
        IMPORT  IIC_DoOp_Poll
d40 1
d111 51
@


1.2
log
@Bulk expand of tabs.
Helps to make tracking changes between OMAP3 and OMAP4 less eye watering, but otherwise functionally the same as 0.06.

Version 0.07. Tagged as 'OMAP4-0_07'
@
text
@a36 2
        IMPORT  TPSRead
        IMPORT  TPSWrite
d53 1
a53 1
        ; a1 = GPIO # (OMAP or TPS or TPS LED)
d57 1
a57 1
        BGE     %FT10
a62 58
10      ; TPS GPIO
        Entry   "v1-v3", 4
        CMP     a3, #TPS_GPIO_PIN_MAX
        BGE     %FT20
        MOV     a4, a3, LSR #3 ; Register offset
        MOV     v2, a2
        AND     a3, a3, #&7
        MOV     v3, #1
        MOV     v3, v3, LSL a3 ; Mask value
        ; If HAL_Init isn't done yet, we can't use OS_IICOpV
        LDR     v1, HALInitialised
        CMP     v1, #0
        ADREQL  v1, IIC_DoOp_Poll
        LDRNE   v1, OSentries+4*OS_IICOpV
        MOV     a1, #TPSGPIO_IIC*2
        MOV     a2, sp
        MOV     a3, #1
        ADD     a4, a4, #TPS_GPIODATADIR1
        BL      TPSRead
        ; TODO - Handle error!
        LDRB    ip, [a2]
        ORR     ip, ip, v3
        STRB    ip, [a2]
        MOV     a1, #TPSGPIO_IIC*2
        BL      TPSWrite
        STRB    v3, [a2]
        MOV     a1, #TPSGPIO_IIC*2
        CMP     v2, #0
        ADDNE   a4, a4, #TPS_SETGPIODATAOUT1-TPS_GPIODATADIR1
        ADDEQ   a4, a4, #TPS_CLEARGPIODATAOUT1-TPS_GPIODATADIR1
        BL      TPSWrite
        EXIT
20      ; TPS LED
        ; Match the behaviour of Linux:
        ; a2=0 sets the LED*ON and LED*PWM bits
        ; a2!=0 clears them
        MOVEQ   v3, #&55 ; Mask for LEDA bits
        MOVNE   v3, #&AA ; Mask for LEDB bits
        CMP     a2, #0
        MOVNE   v2, #0 ; a2!=0, don't set any bits
        ANDEQ   v2, v3, #&33 ; a2=0, set appropriate LED*ON and LED*PWM bit
        MOV     a1, #TPSLED_IIC*2
        MOV     a2, sp
        MOV     a3, #1
        MOV     a4, #TPS_LEDEN
        ; If HAL_Init isn't done yet, we can't use OS_IICOpV
        LDR     v1, HALInitialised
        CMP     v1, #0
        ADREQL  v1, IIC_DoOp_Poll
        LDRNE   v1, OSentries+4*OS_IICOpV
        BL      TPSRead
        LDRB    ip, [a2]
        BIC     ip, ip, v3
        ORR     ip, ip, v2
        STRB    ip, [a2]
        MOV     a1, #TPSLED_IIC*2
        BL      TPSWrite
        EXIT
d64 1
a64 1
        ; a1 = GPIO # (OMAP or TPS)
d68 1
a68 1
        BGE     %FT10
a72 20
10      ; TPS GPIO
        Entry   "v1-v2", 4
        MOV     a4, a3, LSR #3 ; Register offset
        CMP     a2, #0
        AND     a3, a3, #&7
        ADDNE   a4, a4, #TPS_SETGPIODATAOUT1
        MOV     v1, #1
        ADDEQ   a4, a4, #TPS_CLEARGPIODATAOUT1
        MOV     v1, v1, LSL a3 ; Mask value
        MOV     a2, sp
        STRB    v1, [sp]
        MOV     a1, #TPSGPIO_IIC*2
        ; If HAL_Init isn't done yet, we can't use OS_IICOpV
        LDR     v1, HALInitialised
        CMP     v1, #0
        ADREQL  v1, IIC_DoOp_Poll
        LDRNE   v1, OSentries+4*OS_IICOpV
        MOV     a3, #1
        BL      TPSWrite
        EXIT
@


1.1
log
@Initial revision
@
text
@d16 26
a41 26
	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:Machine.<Machine>
	GET	Hdr:ImageSize.<ImageSize>
	$GetIO
	GET	Hdr:Proc

	GET	Hdr:OSEntries
	GET	Hdr:HALEntries

	GET	hdr.omap4430
	GET	hdr.StaticWS
	GET	hdr.GPIO

	AREA	|Asm$$Code|, CODE, READONLY, PIC

	EXPORT	GPIO_Init
	EXPORT	GPIOx_SetAsOutput
	EXPORT	GPIOx_SetOutput
	EXPORT	GPIOx_SetAndEnableIRQ
	IMPORT	TPSRead
	IMPORT	TPSWrite
	IMPORT	IIC_DoOp_Poll
	IMPORT	DebugHALPrint
	IMPORT	DebugHALPrintReg
d44 4
a47 4
	; Don't bother resetting the controllers for now, just make sure no IRQs are enabled
	ADR	a1, L4_GPIO_Table
	MOV	a2, #6
	MOV	a3, #0
d49 5
a53 5
	LDR	a4, [a1], #4
	SUBS	a2, a2, #1
	STR	a3, [a4, #GPIO_IRQENABLE1]
	BNE	%BT10
	MOV	pc, lr
d55 2
a56 2
	; a1 = GPIO # (OMAP or TPS or TPS LED)
	; a2 = initial value (zero or nonzero)
d58 65
a122 65
	SUBS	a3, a1, #GPIO_PIN_MAX
	BGE	%FT10
	; OMAP GPIO
	GPIO_PrepareR a3, a4, a1
	GPIO_SetAsOutput a3, a4, a1
	GPIO_SetOutput a2, a3, a4
	MOV	pc, lr
10	; TPS GPIO
	Entry	"v1-v3", 4
	CMP	a3, #TPS_GPIO_PIN_MAX
	BGE	%FT20
	MOV	a4, a3, LSR #3 ; Register offset
	MOV	v2, a2
	AND	a3, a3, #&7
	MOV	v3, #1
	MOV	v3, v3, LSL a3 ; Mask value
	; If HAL_Init isn't done yet, we can't use OS_IICOpV
	LDR	v1, HALInitialised
	CMP	v1, #0
	ADREQL	v1, IIC_DoOp_Poll
	LDRNE	v1, OSentries+4*OS_IICOpV
	MOV	a1, #TPSGPIO_IIC*2
	MOV	a2, sp
	MOV	a3, #1
	ADD	a4, a4, #TPS_GPIODATADIR1
	BL	TPSRead
	; TODO - Handle error!
	LDRB	ip, [a2]
	ORR	ip, ip, v3
	STRB	ip, [a2]
	MOV	a1, #TPSGPIO_IIC*2
	BL	TPSWrite
	STRB	v3, [a2]
	MOV	a1, #TPSGPIO_IIC*2
	CMP	v2, #0
	ADDNE	a4, a4, #TPS_SETGPIODATAOUT1-TPS_GPIODATADIR1
	ADDEQ	a4, a4, #TPS_CLEARGPIODATAOUT1-TPS_GPIODATADIR1
	BL	TPSWrite
	EXIT
20	; TPS LED
	; Match the behaviour of Linux:
	; a2=0 sets the LED*ON and LED*PWM bits
	; a2!=0 clears them
	MOVEQ	v3, #&55 ; Mask for LEDA bits
	MOVNE	v3, #&AA ; Mask for LEDB bits
	CMP	a2, #0
	MOVNE	v2, #0 ; a2!=0, don't set any bits
	ANDEQ	v2, v3, #&33 ; a2=0, set appropriate LED*ON and LED*PWM bit
	MOV	a1, #TPSLED_IIC*2
	MOV	a2, sp
	MOV	a3, #1
	MOV	a4, #TPS_LEDEN
	; If HAL_Init isn't done yet, we can't use OS_IICOpV
	LDR	v1, HALInitialised
	CMP	v1, #0
	ADREQL	v1, IIC_DoOp_Poll
	LDRNE	v1, OSentries+4*OS_IICOpV
	BL	TPSRead
	LDRB	ip, [a2]
	BIC	ip, ip, v3
	ORR	ip, ip, v2
	STRB	ip, [a2]
	MOV	a1, #TPSLED_IIC*2
	BL	TPSWrite
	EXIT
d124 2
a125 2
	; a1 = GPIO # (OMAP or TPS)
	; a2 = value (zero or nonzero)
d127 33
a159 33
	SUBS	a3, a1, #GPIO_PIN_MAX
	BGE	%FT10
	; OMAP GPIO
	GPIO_PrepareR a3, a4, a1
	GPIO_SetOutput a2, a3, a4
	MOV	pc, lr
10	; TPS GPIO
	Entry	"v1-v2", 4
	MOV	a4, a3, LSR #3 ; Register offset
	CMP	a2, #0
	AND	a3, a3, #&7
	ADDNE	a4, a4, #TPS_SETGPIODATAOUT1
	MOV	v1, #1
	ADDEQ	a4, a4, #TPS_CLEARGPIODATAOUT1
	MOV	v1, v1, LSL a3 ; Mask value
	MOV	a2, sp
	STRB	v1, [sp]
	MOV	a1, #TPSGPIO_IIC*2
	; If HAL_Init isn't done yet, we can't use OS_IICOpV
	LDR	v1, HALInitialised
	CMP	v1, #0
	ADREQL	v1, IIC_DoOp_Poll
	LDRNE	v1, OSentries+4*OS_IICOpV
	MOV	a3, #1
	BL	TPSWrite
	EXIT

	; a1 = GPIO # (OMAP only!)
	; a2 = IRQ type flags:
	;      +1 = LEVELDETECT0
	;      +2 = LEVELDETECT1
	;      +4 = RISINGDETECT
	;      +8 = FALLINGDETECT
d161 28
a188 28
	GPIO_PrepareR a3, a4, a1
	MRS	ip, CPSR
	ORR	a1, ip, #I32_bit ; interrupts off
	MSR	CPSR_c, a1
	MOV	a2, a2, LSL #28
	MSR	CPSR_f, a2 ; load into NZCV flags (MI EQ CS VS condition codes)
	LDR	a1, [a3, #GPIO_FALLINGDETECT]
	BICPL	a1, a1, a4
	LDR	a2, [a3, #GPIO_RISINGDETECT]
	ORRMI	a1, a1, a4
	STR	a1, [a3, #GPIO_FALLINGDETECT]
	BICNE	a2, a2, a4
	LDR	a1, [a3, #GPIO_LEVELDETECT1]
	ORREQ	a2, a2, a4
	STR	a2, [a3, #GPIO_RISINGDETECT]
	BICCC	a1, a1, a4
	LDR	a2, [a3, #GPIO_LEVELDETECT0]
	ORRCS	a1, a1, a4
	STR	a1, [a3, #GPIO_LEVELDETECT1]
	BICVC	a2, a2, a4
	LDR	a1, [a3, #GPIO_OE]
	ORRVS	a2, a2, a4
	ORR	a1, a1, a4 ; set pin as input
	STR	a2, [a3, #GPIO_LEVELDETECT0]
	STR	a1, [a3, #GPIO_OE]
	STR	a4, [a3, #GPIO_SETIRQENABLE1]
	MSR	CPSR_c, ip ; interrupts restored
	MOV	pc, lr
d190 1
a190 1
	END
@


1.1.1.1
log
@  Initial import of OMAP4 HAL
Detail:
  Target platform is the Pandaboard, based on the TI OMAP4 SoC.
  Port is not yet complete, in particular, audio is not yet working.
Admin:
  Submission from Willi Theiß
@
text
@@

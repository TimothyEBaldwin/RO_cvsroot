head	1.28;
access;
symbols
	Tungsten-0_63:1.28
	Tungsten-0_62:1.28
	Tungsten-0_61:1.28
	Tungsten-0_60:1.27
	SMP:1.26.0.2
	SMP_bp:1.26
	Tungsten-0_59:1.26
	Tungsten-0_58:1.26
	Tungsten-0_57:1.24
	Tungsten-0_56:1.24
	Tungsten-0_55:1.24
	Tungsten-0_54:1.24
	Tungsten-0_53:1.23
	Tungsten-0_52:1.23
	Tungsten-0_51:1.22
	Tungsten-0_50:1.22
	Tungsten-0_49:1.22
	Tungsten-0_48:1.22
	Tungsten-0_47:1.21
	Tungsten-0_46:1.20
	Tungsten-0_45:1.20
	Tungsten-0_44:1.19
	Tungsten-0_43:1.19
	Tungsten-0_42:1.18
	Tungsten-0_41:1.17
	Tungsten-0_40:1.17
	Tungsten-0_39:1.17
	Tungsten-0_38:1.17
	Tungsten-0_37:1.17
	Tungsten-0_36:1.16
	Tungsten-0_35:1.16
	Tungsten-0_34:1.16
	Tungsten-0_33:1.16
	Tungsten-0_32:1.16
	Tungsten-0_31:1.15
	Tungsten-0_30:1.15
	Tungsten-0_29:1.15
	Tungsten-0_28:1.14
	Tungsten-Official514:1.14
	Tungsten-0_27:1.14
	Tungsten-0_26:1.14
	Tungsten-0_25:1.14
	Tungsten-0_24:1.14
	Tungsten-0_23:1.14
	Tungsten-0_22:1.14
	Tungsten-0_21:1.14
	Tungsten-0_20:1.14
	RO_5_07:1.13
	Tungsten-0_19:1.13
	Tungsten-0_18:1.13
	Tungsten-0_17:1.12
	Tungsten-0_16:1.12
	Tungsten-0_15:1.12
	Tungsten-0_14:1.11
	Tungsten-0_13:1.10
	Tungsten-0_12:1.9
	Tungsten-0_11:1.8
	Tungsten-0_10:1.7
	Tungsten-0_09:1.7
	Tungsten-0_08:1.7
	Tungsten-0_07:1.7
	Tungsten-0_06:1.6
	Tungsten-0_05:1.6
	Tungsten-0_04:1.5
	Tungsten-0_03:1.3
	Tungsten-0_02:1.2
	Tungsten-0_01:1.1;
locks; strict;
comment	@# @;


1.28
date	2018.02.08.00.26.31;	author jlee;	state Exp;
branches;
next	1.27;
commitid	YMfT17CbT7cPnZpA;

1.27
date	2017.09.09.10.57.04;	author rool;	state Exp;
branches;
next	1.26;
commitid	JbhyAilQebq1Lv6A;

1.26
date	2016.01.07.08.23.43;	author rsprowson;	state Exp;
branches;
next	1.24;
commitid	tvVIiiw9BzL1yYPy;

1.24
date	2014.12.06.09.05.50;	author rsprowson;	state Exp;
branches;
next	1.23;
commitid	TLqepVQ7QzQKxX0y;

1.23
date	2014.10.25.17.54.03;	author rsprowson;	state Exp;
branches;
next	1.22;
commitid	ERa0hjpDEerFOBVx;

1.22
date	2013.12.15.22.58.41;	author jlee;	state Exp;
branches;
next	1.21;
commitid	g5xPCvBcMXyWAhhx;

1.21
date	2013.11.01.18.42.01;	author rsprowson;	state Exp;
branches;
next	1.20;
commitid	s4z9LXAGCdnyABbx;

1.20
date	2013.01.22.23.30.50;	author jlee;	state Exp;
branches;
next	1.19;
commitid	Q6Z3DTOeKB1EhgBw;

1.19
date	2012.07.09.07.26.06;	author rsprowson;	state Exp;
branches;
next	1.18;
commitid	KRTEdlJrzUihhRbw;

1.18
date	2012.07.04.18.00.47;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	SL20BFLvbcrZWgbw;

1.17
date	2012.02.25.16.43.16;	author jlee;	state Exp;
branches;
next	1.16;
commitid	jZ2NTOmQjvfsHyUv;

1.16
date	2011.12.06.00.18.18;	author jlee;	state Exp;
branches;
next	1.15;
commitid	q4Iqqfm8nb60R3Kv;

1.15
date	2011.08.08.21.13.51;	author jlee;	state Exp;
branches;
next	1.14;
commitid	xMdaqswlSv6QEKuv;

1.14
date	2004.10.29.00.30.40;	author jballance;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.30.14.35.51;	author kbracey;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.15.20.11.03;	author kbracey;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.15.20.03.35;	author kbracey;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.23.18.19.43;	author rsprowson;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.21.20.26.36;	author bavison;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.16.18.55.45;	author rsprowson;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.13.17.47.02;	author bavison;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.18.10.34.00;	author rsprowson;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.17.09.17.19;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.16.17.29.06;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.15.18.55.07;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.15.14.56.36;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.07.12.34.08;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Implement HAL_TimerIRQClear
Detail:
  s/Timers - Implement HAL_TimerIRQClear
  s/Interupts - Remove HAL_IRQClear implementation, since clearing the timer interrupts was the only thing it did. Remove empty HAL_FIQClear as well.
  s/Boot - NOP out HAL_IRQClear & HAL_FIQClear entry points. Hook up HAL_TimerIRQClear entry point.
Admin:
  Tested on Iyonix


Version 0.61. Tagged as 'Tungsten-0_61'
@
text
@; Copyright 2002 Tematic Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:HALSize.<HALSize>

        GET     Hdr:MEMM.ARM600

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS
        GET     hdr.80321

; This version assumes a RISC OS image starting OSROM_HALSize bytes after us.

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  get_end_of_ram
        EXPORT  rom_checkedout_ok

        IMPORT  HAL_Base
        IMPORT  generate_POR_flags
        IMPORT  HAL_PCIWriteConfigHalfword
        IMPORT  PCI_TungstenSecondaryBus

; v8 is used as pointer to RISC OS entry table throughout pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

rom_checkedout_ok

 [ RAM_Base <> Boot_RAM_Base

        SUB     a3, a4, #ROM_Base
        SUB     pc, pc, a3
        NOP

        MCR     p15, 0, a1, c7, c5      ; invalidate I cache again

; now move the RAM into final position

        STMFD   sp!, {a1-a4}
        BL      move_ram
        LDMFD   sp!, {a1-a4}

; and back into RAM, at final position
        ADD     a3, a3, #RAM_Base - Boot_RAM_Base
        ADD     a4, a4, #RAM_Base - Boot_RAM_Base
        ADD     v8, v8, #RAM_Base - Boot_RAM_Base
        ADD     pc, pc, a3
        NOP
 ]

        LDMFD   sp!, {v1-v3}                    ; junk stack contents from copy_rom_to_ram

        MOV     sb, #0

        BL      get_end_of_ram
        MOV     a3, a1

        MOV     a1, #4:SHL:8
        LDR     a2, =RAM_Base
        ADRL    lr, HAL_Base                    ; bottom of HAL, may be top of RAM
        CMP     lr, a3
        MOVLO   a3, lr
        LDR     a4, =&FFFFFFFF
        MOV     ip, #0
        STR     ip, [sp, #-4]!
        CallOSM OS_AddRAM
        STR     a1, [sp]
        ADD     sp, sp, #4

        MOV     v1, a1
        BL      generate_POR_flags
        ORR     a1, a1, #OSStartFlag_RAMCleared

        ADRL    a2, HAL_Base + OSROM_HALSize          ; a2 -> RISC OS image
        ADR     a3, HALdescriptor
        MOV     a4, v1
        CallOSM OS_Start


HALdescriptor   DATA
        DCD     HALFlag_NCNBWorkspace
        DCD     HAL_Base - HALdescriptor
        DCD     OSROM_HALSize
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     HAL_WsSize


        MACRO
        HALEntry $name
        ASSERT  (. - HAL_EntryTable) / 4 = EntryNo_$name
        DCD     $name - HAL_EntryTable
        MEND

        MACRO
        NullEntry
        DCD     HAL_Null - HAL_EntryTable
        MEND

        IMPORT   Video_init
        IMPORT   Interrupt_Init
        IMPORT   Timer_Init
        IMPORT   HAL_DebugInit
        IMPORT   HAL_DebugInit2
        IMPORT   PCI_Init
        IMPORT   IDE_Init
        IMPORT   IDEDevice_Init
        IMPORT   M1535DMA_Init
        IMPORT   Audio_Init
        IMPORT   RTC_Init

        IMPORT   HAL_IRQEnable
        IMPORT   HAL_IRQDisable
        IMPORT   HAL_IRQSource
        IMPORT   HAL_IRQStatus
        IMPORT   HAL_FIQEnable
        IMPORT   HAL_FIQDisable
        IMPORT   HAL_FIQDisableAll
        IMPORT   HAL_FIQSource
        IMPORT   HAL_FIQStatus
        IMPORT   HAL_IRQMax

        IMPORT   HAL_Timers
        IMPORT   HAL_TimerDevice
        IMPORT   HAL_TimerGranularity
        IMPORT   HAL_TimerMaxPeriod
        IMPORT   HAL_TimerSetPeriod
        IMPORT   HAL_TimerPeriod
        IMPORT   HAL_TimerReadCountdown
        IMPORT   HAL_TimerIRQClear

        IMPORT   HAL_CounterRate
        IMPORT   HAL_CounterPeriod
        IMPORT   HAL_CounterRead
        IMPORT   HAL_CounterDelay

        IMPORT   HAL_IICBuses
        IMPORT   HAL_IICType
        IMPORT   HAL_IICDevice
        IMPORT   HAL_IICTransfer
        IMPORT   HAL_IICMonitorTransfer

        IMPORT   HAL_NVMemoryType
        IMPORT   HAL_NVMemorySize
        IMPORT   HAL_NVMemoryPageSize
        IMPORT   HAL_NVMemoryProtectedSize
        IMPORT   HAL_NVMemoryProtection
        IMPORT   HAL_NVMemoryIICAddress

        IMPORT   HAL_UARTPorts
        IMPORT   HAL_UARTStartUp
        IMPORT   HAL_UARTShutdown
        IMPORT   HAL_UARTFeatures
        IMPORT   HAL_UARTReceiveByte
        IMPORT   HAL_UARTTransmitByte
        IMPORT   HAL_UARTLineStatus
        IMPORT   HAL_UARTInterruptEnable
        IMPORT   HAL_UARTRate
        IMPORT   HAL_UARTFormat
        IMPORT   HAL_UARTFIFOSize
        IMPORT   HAL_UARTFIFOClear
        IMPORT   HAL_UARTFIFOEnable
        IMPORT   HAL_UARTFIFOThreshold
        IMPORT   HAL_UARTInterruptID
        IMPORT   HAL_UARTBreak
        IMPORT   HAL_UARTModemControl
        IMPORT   HAL_UARTModemStatus
        IMPORT   HAL_UARTDevice
        IMPORT   HAL_UARTDefault

        IMPORT   HAL_MachineID

        IMPORT   HAL_DebugRX
        IMPORT   HAL_DebugTX

        IMPORT   HAL_PCIFeatures
        IMPORT   HAL_PCIReadConfigByte
        IMPORT   HAL_PCIReadConfigHalfword
        IMPORT   HAL_PCIReadConfigWord
        IMPORT   HAL_PCIWriteConfigByte
        IMPORT   HAL_PCIWriteConfigHalfword
        IMPORT   HAL_PCIWriteConfigWord
;       IMPORT   HAL_PCISpecialCycle
        IMPORT   HAL_PCISlotTable
        IMPORT   HAL_PCIAddresses

        IMPORT   HAL_KbdScanDependencies

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        NullEntry ; HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource
        HALEntry HAL_IRQStatus
        HALEntry HAL_FIQEnable
        HALEntry HAL_FIQDisable
        HALEntry HAL_FIQDisableAll
        NullEntry ; HALEntry HAL_FIQClear
        HALEntry HAL_FIQSource
        HALEntry HAL_FIQStatus

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        HALEntry HAL_NVMemoryType
        HALEntry HAL_NVMemorySize
        HALEntry HAL_NVMemoryPageSize
        HALEntry HAL_NVMemoryProtectedSize
        HALEntry HAL_NVMemoryProtection
        HALEntry HAL_NVMemoryIICAddress
        NullEntry ; HAL_NVMemoryRead 
        NullEntry ; HAL_NVMemoryWrite

        HALEntry HAL_IICBuses
        HALEntry HAL_IICType
        NullEntry ; HAL_IICSetLines   
        NullEntry ; HAL_IICReadLines  
        HALEntry HAL_IICDevice
        HALEntry HAL_IICTransfer
        HALEntry HAL_IICMonitorTransfer

        NullEntry ; HALEntry HAL_VideoFlybackDevice
        NullEntry ; HALEntry HAL_VideoSetMode
        NullEntry ; HALEntry HAL_VideoWritePaletteEntry
        NullEntry ; HALEntry HAL_VideoWritePaletteEntries
        NullEntry ; HALEntry HAL_VideoReadPaletteEntry
        NullEntry ; HALEntry HAL_VideoSetInterlace
        NullEntry ; HALEntry HAL_VideoSetBlank
        NullEntry ; HALEntry HAL_VideoSetPowerSave
        NullEntry ; HALEntry HAL_VideoUpdatePointer
        NullEntry ; HALEntry HAL_VideoSetDAG
        NullEntry ; HALEntry HAL_VideoVetMode
        NullEntry ; HALEntry HAL_VideoPixelFormats
        NullEntry ; HALEntry HAL_VideoFeatures
        NullEntry ; HALEntry HAL_VideoBufferAlignment
        NullEntry ; HALEntry HAL_VideoOutputFormat

        NullEntry ; HALEntry HAL_MatrixColumns
        NullEntry ; HALEntry HAL_MatrixScan

        NullEntry ; HALEntry HAL_TouchscreenType
        NullEntry ; HALEntry HAL_TouchscreenRead
        NullEntry ; HALEntry HAL_TouchscreenMode
        NullEntry ; HALEntry HAL_TouchscreenMeasure

        HALEntry HAL_MachineID

        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo
        HALEntry HAL_PlatformInfo
        NullEntry ; HALEntry HAL_CleanerSpace

        HALEntry HAL_UARTPorts
        HALEntry HAL_UARTStartUp
        HALEntry HAL_UARTShutdown
        HALEntry HAL_UARTFeatures
        HALEntry HAL_UARTReceiveByte
        HALEntry HAL_UARTTransmitByte
        HALEntry HAL_UARTLineStatus
        HALEntry HAL_UARTInterruptEnable
        HALEntry HAL_UARTRate
        HALEntry HAL_UARTFormat
        HALEntry HAL_UARTFIFOSize
        HALEntry HAL_UARTFIFOClear
        HALEntry HAL_UARTFIFOEnable
        HALEntry HAL_UARTFIFOThreshold
        HALEntry HAL_UARTInterruptID
        HALEntry HAL_UARTBreak
        HALEntry HAL_UARTModemControl
        HALEntry HAL_UARTModemStatus
        HALEntry HAL_UARTDevice
        HALEntry HAL_UARTDefault

        HALEntry HAL_DebugRX
        HALEntry HAL_DebugTX

        HALEntry HAL_PCIFeatures
        HALEntry HAL_PCIReadConfigByte
        HALEntry HAL_PCIReadConfigHalfword
        HALEntry HAL_PCIReadConfigWord
        HALEntry HAL_PCIWriteConfigByte
        HALEntry HAL_PCIWriteConfigHalfword
        HALEntry HAL_PCIWriteConfigWord
        NullEntry ; HALEntry HAL_PCISpecialCycle
        HALEntry HAL_PCISlotTable
        HALEntry HAL_PCIAddresses

        HALEntry HAL_PlatformName
        NullEntry ; Unused
        NullEntry ; Unused

        HALEntry HAL_InitDevices

        HALEntry HAL_KbdScanDependencies
        NullEntry ; Unused
        NullEntry ; Unused
        NullEntry ; Unused

        HALEntry HAL_PhysInfo

        HALEntry HAL_Reset

        HALEntry HAL_IRQMax

        NullEntry ; HALEntry HAL_USBControllerInfo
        NullEntry ; HALEntry HAL_USBPortPower
        NullEntry ; HALEntry HAL_USBPortIRQStatus
        NullEntry ; HALEntry HAL_USBPortIRQClear
        NullEntry ; HALEntry HAL_USBPortDevice

        HALEntry HAL_TimerIRQClear


HAL_Entries     * (.-HAL_EntryTable)/4


;--------------------------------------------------------------------------------------


HAL_Init
        Entry

        STR     a2, NCNBWorkspace

        BL      SetUpOSEntries

        MOV     a1, #0
        LDR     a2, =IO_Base
        MOV     a3, #IO_Size
        CallOS  OS_MapInIO
        STR     a1, IO_Address
        ADD     a1, a1, #&00200000    ; Offset to base of IOMD
        STR     a1, IOMD_Address

        MOV     a1, #0
        LDR     a2, =PMMR_Base
        LDR     a3, =PMMR_Size
        CallOS  OS_MapInIO
        ADD     a1, a1, #PMMR - PMMR_Base
        STR     a1, PMMR_Address

        MOV     a1, #0
        LDR     a2, =EASI_Base
        MOV     a3, #EASI_Size
        CallOS  OS_MapInIO
        STR     a1, EASI_Address

        MOV     a1, #0
        LDR     a2, =PCI_IO_Base
        MOV     a3, #PCI_IO_Size
        CallOS  OS_MapInIO
        STR     a1, PCI_IO_Address

        BL      Timer_Init

        BL      HAL_DebugInit

        BL      PCI_Init

        BL      HAL_DebugInit2

        BL      Interrupt_Init

        BL      IDE_Init

   [ :LNOT: (Debug :LAND: (DebugPort = 3))
        MOV     a1,#0
        BL      HAL_UARTStartUp
   ]
;        MOV     a1,#1
;        BL      HAL_UARTStartUp
;        MOV     a1,#2
;        BL      HAL_UARTStartUp

        EXIT

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADR     a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05
        ; Fall through

HAL_Null
        MOV     pc, lr

HAL_InitDevices
        Entry

        BL      RTC_Init
        
        BL      M1535DMA_Init

        BL      Audio_Init

        BL      Video_init

        BL      IDEDevice_Init

        EXIT

HAL_ControllerAddress
        AND     a3, a2, #&FF
        MOV     a2, a2, LSR#8                   ; a3=sequence number a2=controller
        CMP     a2, #6
        MOVCS   a1, #-1                         ; don't know about that controller
        MOVCS   pc, lr

        TEQ     a2, #0
        LDREQ   a1, IOMD_Address
        ADDEQ   a1, a1, #ECTCR
        MOVEQ   pc, lr

        TEQ     a2, #1
        BNE     %FT15
        CMP     a3, #NumberOfPodules
        MOVCS   a1, #0
        LDRCC   a1, EASI_Address
        ADDCC   a1, a1, a3, LSL#24
        MOV     pc, lr
15
        TEQ     a2, #4
        LDREQ   a1, IOMD_Address
        MOVNE   a1, #0                          ; one we know about,but isn't fitted
        MOV     pc, lr

HAL_HardwareInfo
        LDR     ip, =&FFFFFF00
        STR     ip, [a1]
        MOV     ip, #0
        STR     ip, [a2]
        STR     ip, [a3]
        MOV     pc, lr

HAL_PlatformInfo
 [ RevB
        MOV     ip, #2_11011                    ; podules,PCI cards,soft off,and soft ROM
 |
        MOV     ip, #2_10011                    ; podules,PCI cards,soft off didn't work,and soft ROM
 ]
        STR     ip, [a2]
        MOV     ip, #2_11111                    ; mask of valid bits
        STR     ip, [a3]
        MOV     pc, lr

HAL_PlatformName
        ADR     a1, %FT01
        MOV     pc, lr
01      DCB     "Tungsten", 0
        ALIGN
                        
HAL_SuperIOInfo
        MOV     ip, #0
        STR     ip, [a1]
        STR     ip, [a2]
        MOV     pc, lr

; Shifts to determine number of bytes/words to allocate in table.
NibbleShift     *       12
ByteShift       *       NibbleShift + 1
WordShift       *       ByteShift + 2

; Bit patterns for different types of memory.
NotPresent      *       &00000000
DRAM_Pattern    *       &11111111
VRAM_Pattern    *       &22222222
ROM_Pattern     *       &33333333
IO_Pattern      *       &44444444
NotAvailable    *       &88888888

        IMPORT  memset

HAL_PhysInfo
        TEQ     a1, #PhysInfo_GetTableSize
        MOVEQ   a1, #1:SHL:(32-ByteShift)
        STREQ   a1, [a2]
        MVNEQ   a1, #0             ; Supported
        MOVEQ   pc, lr

        TEQ     a1, #PhysInfo_HardROM
        MOVEQ   a1, #&A0000000     ; 4MB of NOR flash here
        LDREQ   a2, =&A0400000-1   ; Inclusive end address
        STMEQIA a3, {a1-a2}
        MVNEQ   a1, #0             ; Supported
        MOVEQ   pc, lr

        TEQ     a1, #PhysInfo_WriteTable
        MOVNE   a1, #0
        MOVNE   pc, lr

        ; Do the PhysInfo_WriteTable table output 
        Push    "v1-v2,lr"
        MOV     a1, #&C0000000     ; Physical RAM
        LDR     lr, =&FFFFE000-1
        STMIA   a3, {a1,lr}
        MOV     v1, a2

        ADR     v2, HAL_PhysTable
10      LDMIA   v2, {a1, a2, lr}
        SUB     a3, lr, a1
        ADD     a1, v1, a1, LSR #ByteShift
        MOV     a3, a3, LSR #ByteShift
        BL      memset
        LDR     a1, [v2, #8]!
        TEQ     a1, #0
        BNE     %BT10

        MVN     a1, #0             ; Supported
        Pull    "v1,v2,pc"

; HAL_PhysInfo uses memset to fill the table, so all regions
; must be byte-aligned (ie double-page-aligned addresses).
HAL_PhysTable
        DCD     &00000000, IO_Pattern  :OR: NotAvailable ; PCI memory windows
        DCD     &88000000, NotPresent  :OR: NotAvailable
        DCD     &90000000, IO_Pattern  :OR: NotAvailable ; PCI I/O window
        DCD     &90010000, NotPresent  :OR: NotAvailable
        DCD     &A0000000, ROM_Pattern :OR: NotAvailable ; 4MB of ROM
        DCD     &A0400000, NotPresent  :OR: NotAvailable
        DCD     &A3000000, IO_Pattern  :OR: NotAvailable ; IOMD + podules
        DCD     &A3400000, NotPresent  :OR: NotAvailable
        DCD     &A8000000, IO_Pattern  :OR: NotAvailable ; EASI space for podules
        DCD     &AC000000, NotPresent  :OR: NotAvailable
        DCD     &FFFFE000, IO_Pattern  :OR: NotAvailable ; PMMR
        DCD     0

HAL_Reset
        TEQ     a1, #0                      ; reset,or power off?
        LDRNE   ip, PMMR_Address
        LDRNE   a1, [ip, #ATU_PCSR]
        ORRNE   a1, a1, #1:SHL:5
        STRNE   a1, [ip, #ATU_PCSR]
        BNE     .

        BL      PCI_TungstenSecondaryBus
        MOV     v1, a1
        MOV     a2, #12*8
        MOV     a3, #&9A                    ; a1 = bus, a2 = dev/fn, a3 = addr
        MOV     a4, #4
        BL      HAL_PCIWriteConfigHalfword  ; GPIO2 is output
        MOV     a1, v1
        MOV     a2, #12*8
        MOV     a3, #&9C
        BL      HAL_PCIWriteConfigHalfword  ; Bit 2 high in PMU device
        B       .

        LTORG

        EXPORT  vtophys
vtophys
        CallOS  OS_LogToPhys, tailcall

        EXPORT  mapinio
mapinio
        CallOS  OS_MapInIO, tailcall

move_ram
 [ RAM_Base <> Boot_RAM_Base
        ; so that SBR regs don't need changing
        ASSERT  (RAM_Base :AND: &3FFFFFFF) = (Boot_RAM_Base :AND: &3FFFFFFF)
        LDR     ip, =PMMR
        MOV     a1, #RAM_Base
        STR     a1, [ip, #MCU_SDBR]
        ADD     sp, sp, #RAM_Base - Boot_RAM_Base
 ]
        MOV     pc, lr

get_end_of_ram
        LDR     ip, =PMMR
        LDR     a1, [ip, #MCU_SBR1]             ; read end direct from control register
        LDR     a2, [ip, #MCU_SDBR]             ; and start
        AND     a1, a1, #&3F
        AND     a2, a2, #&C0000000
        ADD     a1, a2, a1, LSL #25
        SUB     a3, a1, #1
        CMP     a3, #&FFF00000
        MOVHS   a1, #&FFF00000-1
        ADDHS   a1, a1, #1
        MOV     pc, lr

        END
@


1.27
log
@Participate in keyboard scan dependencies
Detail:
  Replace keyboard scan code with list of modules that the kernel needs to do the same.
  Reorder the HALEntries to match Kernel-5_89.
  Back fill missing UARTDefault entry point.
  Delete unused workspace.
  Remove now unused USB driver and local copies of OHCI registers.
Admin:
  Submission for USB bounty.

Version 0.60. Tagged as 'Tungsten-0_60'
@
text
@a136 1
        IMPORT   HAL_IRQClear
a141 1
        IMPORT   HAL_FIQClear
d153 1
d217 1
a217 1
        HALEntry HAL_IRQClear
d223 1
a223 1
        HALEntry HAL_FIQClear
d341 9
@


1.26
log
@Declare the presence of an IDE controller
ATA.s:
  Refactor to report a PATA IDE controller.
Boot.s:
  Init the ATA device.
Report a HAL platform name string for OS_ReadSysInfo 9,7.

Version 0.58. Tagged as 'Tungsten-0_58'
@
text
@d193 1
d211 1
a211 4
        IMPORT   HAL_KbdScanSetup
        IMPORT   HAL_KbdScan
        IMPORT   HAL_KbdScanFinish
        IMPORT   HAL_KbdScanInterrupt
d309 1
a309 2

        HALEntry HAL_Reset
d331 4
a334 4
        HALEntry HAL_KbdScanSetup
        HALEntry HAL_KbdScan
        HALEntry HAL_KbdScanFinish
        HALEntry HAL_KbdScanInterrupt
d338 1
a338 1
        NullEntry ;HALEntry HAL_USBControllerInfo
@


1.24
log
@Minor HAL API corrections
HAL_HardwareInfo - as word 0 specified that no IOMD or VIDC was present, don't waste time reporting anything in word 2.
HAL_PhysInfo - report the ROM range as an inclusive range for op 2, same as the RAM is for op 1.
Requires Kernel 4.79.2.248 to get the corresponding ROM range change.

Version 0.54. Tagged as 'Tungsten-0_54'
@
text
@d129 2
a130 1
        IMPORT   ATA_Init
a209 4
        IMPORT   HAL_ATAControllerInfo
        IMPORT   HAL_ATASetModes
        IMPORT   HAL_ATACableID

d328 3
a330 3
        HALEntry HAL_ATAControllerInfo
        HALEntry HAL_ATASetModes
        HALEntry HAL_ATACableID
d395 1
a395 1
        BL      ATA_Init
d440 2
d488 6
@


1.23
log
@Trim NullEntries from end of HAL table
Built, but not tested.

Version 0.52. Tagged as 'Tungsten-0_52'
@
text
@a474 1
        LDR     ip, =&00FFFF00
d519 1
a519 1
        LDREQ   a2, =&A0400000
@


1.22
log
@Remove obsolete stub HAL video API implementation
Detail:
  s/Boot, s/Bideo - Removed obsolete HAL video API implementation. A stub implementation is no longer required for systems that have a GraphicsV driver in a module, and can even cause problems if the OS decides to use the HAL implementation instead of the module one.
Admin:
  Tested in Tungsten ROM softload
  Requires Kernel-5_35-4_79_2_203


Version 0.48. Tagged as 'Tungsten-0_48'
@
text
@a347 8
        NullEntry ;HALEntry HAL_VideoRender

        NullEntry ;HALEntry HAL_USBPortPower
        NullEntry ;HALEntry HAL_USBPortStatus
        NullEntry ;HALEntry HAL_USBPortIRQ

        NullEntry ;HALEntry HAL_VideoIICOp

@


1.21
log
@Add RTC device
HAL RTC device added after probing IIC address &D0.
Moved CallOS macro into a header.

Version 0.47. Tagged as 'Tungsten-0_47'
@
text
@a172 6
        IMPORT   HAL_VideoFlybackDevice
        IMPORT   HAL_VideoVetMode
        IMPORT   HAL_VideoPixelFormats
        IMPORT   HAL_VideoFeatures
        IMPORT   HAL_VideoBufferAlignment

d263 1
a263 1
        HALEntry HAL_VideoFlybackDevice
d273 4
a276 4
        HALEntry HAL_VideoVetMode
        HALEntry HAL_VideoPixelFormats
        HALEntry HAL_VideoFeatures
        HALEntry HAL_VideoBufferAlignment
@


1.20
log
@Implement HAL_IRQMax
Detail:
  s/Boot, s/Interrupts - Added HAL_IRQMax implementation, to ensure correct functionality with latest Kernel
Admin:
  Tested in Iyonix ROM softload
  Requires Kernel-5_35-4_79_2_182


Version 0.45. Tagged as 'Tungsten-0_45'
@
text
@a49 13
        MACRO
        CallOS  $entry, $tailcall
        ASSERT  $entry <= HighestOSEntry
 [ "$tailcall"=""
        MOV     lr, pc
 |
   [ "$tailcall"<>"tailcall"
        ! 0, "Unrecognised parameter to CallOS"
   ]
 ]
        LDR     pc, OSentries + 4*$entry
        MEND

d132 1
d449 2
@


1.19
log
@Adopt revised HAL_PhysInfo API
Also spotted that HAL_MachineID was corrupting v1-v4 so rejigged the register use a bit.

Version 0.43. Tagged as 'Tungsten-0_43'
@
text
@d157 1
d364 1
a364 1
        NullEntry ;HALEntry HAL_MonitorLeadID
@


1.18
log
@Mark some unused video entrypoints as NullEntry
Rename HAL_Video_ to HAL_Video.
Make use of IICStatus defines.
Compiles, but not tested.

Version 0.42. Tagged as 'Tungsten-0_42'
@
text
@d535 1
a535 1
        TEQ     a1, #0
d537 9
d548 11
a558 2
        Push    "a2,v1,v2,lr"
        MOV     v1, a1
d568 2
a569 4
        MOV     a1, #&C0000000
        LDR     lr, =&FFFFE000-1
        Pull    "a2"
        STR     lr, [a2]
@


1.17
log
@Add compressed ROM support. Make softload-aware.
Detail:
  hdr/Post, s/FlashProg - Add sizeofROM definition, for expected size of compressed ROM/physical ROM chip. Used to replace references to OSROM_ImageSize throughout the code.
  s/ATA, s/Boot, s/Debug, s/DebugPCI, s/IIC, s/Interrupts, s/MSI, s/NVMemory, s/Timers, s/Top, s/UART - Removed unnecessary GETs of Hdr:ImageSize.<ImageSize>
  s/Boot, s/Video - Add a new 'Tungsten video' HAL device, for storing the NVidia STRAP data that the softload & ROM flash tools need to poke into the ROMs on a per-machine basis. Previously the data was stored in the NVidia module, which would have caused complications with compressed ROM images.
  s/RAM, s/Top - Add compressed ROM & softload support. Softload code just skips some hardware initialisation and relocates the ROM to the high end of RAM.
Admin:
  Tested as Tungsten ROM softload only.
  For safety, compressed ROMs that have been burnt to ROM are required to be 4MB in size. This helps to simplify the ROM consistency checks and recovery code.
  Softloaded ROMs aren't subjected to the FlashCheck code and can be any size.


Version 0.37. Tagged as 'Tungsten-0_37'
@
text
@d185 4
a188 14
        IMPORT   HAL_Video_SetMode
        IMPORT   HAL_Video_WritePaletteEntry
        IMPORT   HAL_Video_WritePaletteEntries
        IMPORT   HAL_Video_ReadPaletteEntry
        IMPORT   HAL_Video_SetInterlace
        IMPORT   HAL_Video_SetBlank
        IMPORT   HAL_Video_SetPowerSave
        IMPORT   HAL_Video_UpdatePointer
        IMPORT   HAL_Video_SetDAG
        IMPORT   HAL_Video_VetMode
        IMPORT   HAL_Video_PixelFormats
        IMPORT   HAL_Video_Features
        IMPORT   HAL_Video_BufferAlignment
        IMPORT   HAL_Video_OutputFormat
d281 14
a294 14
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode
        HALEntry HAL_Video_PixelFormats
        HALEntry HAL_Video_Features
        HALEntry HAL_Video_BufferAlignment
        HALEntry HAL_Video_OutputFormat
d365 1
a365 1
        NullEntry ;HALEntry HAL_Video_Render
d371 1
a371 1
        NullEntry ;HALEntry HAL_Video_IICOp
@


1.16
log
@Update to support alternate HAL sizes
Detail:
  s/Boot, s/Top - Now uses OSROM_HALSize for the HAL size instead of fixed 64K constant.
Admin:
  Tested in ROM softload with 64K & 32K HAL sizes.
  However, Aemulor doesn't seem to like a 32K HAL size.


Version 0.32. Tagged as 'Tungsten-0_32'
@
text
@a18 1
        GET     Hdr:ImageSize.<ImageSize>
d87 1
a87 1
        LDMFD   sp!, {v1-v3}
a424 2
        BL      Video_init

d474 2
@


1.15
log
@Tweak debug code
Detail:
  hdr/80321 - Improved notes about debug options.
  s/Boot - Don't reinit UART 3 if it's already in use for debugging
  s/Top, hdr/80321 - Use new FlashCheckInDebug option to help work out whether flash check failure code is called
  s/UART - Disable HAL UART API if UART 3 is in use for debugging
Admin:
  Tested in ROM softload


Version 0.29. Tagged as 'Tungsten-0_29'
@
text
@d20 1
d31 1
a31 1
; This version assumes a RISC OS image starting 64K after us.
d111 1
a111 1
        ADRL    a2, HAL_Base + 64*1024          ; a2 -> RISC OS image
d120 1
a120 1
        DCD     64*1024
@


1.14
log
@       added HAL entry for HAL_Video_IIC_Op
Detail:
Admin:
    jb .. castle IP

Version 0.20. Tagged as 'Tungsten-0_20'
@
text
@d437 1
d440 1
@


1.13
log
@Split USB and PCI parts of HAL into hardware-specific and generic parts.
The generic parts are included by other HALs.

Version 0.18. Tagged as 'Tungsten-0_18'
@
text
@d381 1
@


1.12
log
@Add copyright message to c.PCI,move a comment.

Version 0.15. Tagged as 'Tungsten-0_15'
@
text
@d279 2
a280 2
        NullEntry
        NullEntry
d284 2
a285 2
        NullEntry
        NullEntry
d370 11
@


1.11
log
@First venture into the world of message signalled interrupts (s.MSI).
High speed RAM clear added using AAU in the XScale.
Tighten up check on RAM modules to reject some 4 bit wide devices.
Fix for CMOS protect link being ignored.
Add table returned by ReadPhysicalMemory.
New poke to move sound DMA into the top half of physical memory.
PCI rewrite.

Version 0.14. Tagged as 'Tungsten-0_14'
@
text
@d500 1
a500 1
        MOV     ip, #2_11011                    ; podules,PCI cards,soft off, and soft ROM
d502 1
a502 1
        MOV     ip, #2_10011                    ; podules,PCI cards,soft off didn't work
@


1.10
log
@Kevin's new PCI enumeration C.
Kevin's UART control for DualSerial to talk to.
Completion of flash recovery stuff - it now flashes the floppy drive
light appropriately then requests a new OS image down the serial port
but is careful never to erase itself.To allow this has required some
shuffling to ensure the first 8k of binary is fixed and makes no
external calls - "s.Top" arranges this and effectively moves the
HAL up 8k in ROM.

Version 0.13. Tagged as 'Tungsten-0_13'
@
text
@d108 1
d369 2
d500 1
a500 1
        MOV     ip, #2_1011                     ; podules,PCI cards,and soft off
d502 1
a502 1
        MOV     ip, #2_0011                     ; podules,PCI cards,soft off didn't work
d505 1
a505 1
        MOV     ip, #2_1111                     ; mask of valid bits
d514 53
@


1.9
log
@Added HAL devices for the sound system (controller and mixer). Requires
today's kernel to build. Required by today's SoundDMA and SoundControl in
order to function correctly at run-time.

Version 0.12. Tagged as 'Tungsten-0_12'
@
text
@d32 1
a32 1
        AREA    |!!!ROMStart|, CODE, READONLY, PIC
d34 7
d63 1
a63 6
        IMPORT  initialise_iic
        IMPORT  initialise_ram
        IMPORT  move_ram
        IMPORT  get_end_of_ram
        IMPORT  recover_flash
        IMPORT  generate_POR_flags
d65 1
a65 2
        IMPORT  HAL_PCIWriteConfigHalfword
        IMPORT  PCI_TungstenSecondaryBus
d67 3
a69 1
HAL_Base
d71 1
a71 9
        B       start
        B       .
        B       .
        B       .
        B       .
        B       .
        B       .
        B       .
        DCD     1024*1024       ; image size (temp hack)
d73 1
a73 8
        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
ROMsize
        DCD     0                               ; patched in by build system

        ENTRY
start
        B       restart
d75 3
a77 1
        LTORG
d79 6
a84 70
restart
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode
        MOV     a1, #&70
        MCR     p15, 0, a1, c1, c0              ; MMU, caches etc off
        MOV     a1, #0
        MCR     p15, 0, a1, c7, c7              ; invalidate caches
        MCR     p15, 0, a1, c8, c7              ; invalidate TLBs

        ADRL    v1, HAL_Base + 64*1024          ; v1 -> RISC OS image

        LDR     v8, [v1, #OSHdr_Entries]
        ADD     v8, v8, v1                      ; v8 -> RISC OS entry table

 [ :LNOT: FlashCheck
        ; Can't do this,as the OS might be corrupt
        MOV     a1, #0
        CallOSM OS_InitARM
 |
        ; Take a local copy from the Kernel,knowing we're on an XScale
        GET     hdr.Copro15ops

        [ {FALSE}
        MOV     a4, lr
        ; Check if we're architecture 3. If so, don't read the control register.
        BL      Init_ARMarch
        |
        MOVS    a1, #4                          ; XScale is ARM V5T
        ]
        MOVEQ   a1, #0
        ARM_read_control a1, NE
        ; Late abort (ARM6 only), 32-bit Data and Program space. No Write buffer (ARM920T
        ; spec says W bit should be set, but I reckon they're bluffing).
        ;
        ; The F bit's tricky. (1 => CPCLK=FCLK, 0=>CPCLK=FCLK/2). The only chip using it was the
        ; ARM700, it never really reached the customer, and it's always been programmed with
        ; CPCLK=FCLK. Therefore we'll keep it that way, and ignore the layering violation.
        ORR     a1, a1, #MMUC_F+MMUC_L+MMUC_D+MMUC_P
        ; All of these bits should be off already, but just in case...
        BIC     a1, a1, #MMUC_B+MMUC_W+MMUC_C+MMUC_A+MMUC_M
        BIC     a1, a1, #MMUC_RR+MMUC_V+MMUC_I+MMUC_Z+MMUC_R+MMUC_S

        ; Off we go.
        ARM_write_control a1

        ; In case it wasn't a hard reset
        MOV     a2, #0
        MCR     ARM_config_cp,0,a2,ARMv4_cache_reg,C7           ; invalidate I+D caches
        MCREQ   ARM_config_cp,0,a2,ARMv3_TLBflush_reg,C0        ; flush TLBs
        MCRNE   ARM_config_cp,0,a2,ARMv4_TLB_reg,C7             ; flush TLBs

        ; We assume that ARMs with an I cache can have it enabled while the MMU is off.
        [ :LNOT:CacheOff
        ORRNE   a1, a1, #MMUC_I
        ARM_write_control a1, NE                                ; whoosh
        ]

        ; Check if we are in a 26-bit mode.
        MRS     a2, CPSR
        ; Keep a soft copy of the CR in a banked register (R13_und)
        MSR     CPSR_c, #F32_bit+I32_bit+UND32_mode
        MOV     sp, a1
        ; Switch into SVC32 mode (we may have been in SVC26 before).
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode

        [ {FALSE}
        ; If we were in a 26-bit mode, the lr value given to us would have had PSR flags in.
        TST     a2, #2_11100
        MOVNE   pc, a4
        BICEQ   pc, a4, #ARM_CC_Mask
        ]
d87 1
a87 18
        MRC     p15, 0, a1, c15, c1             ; Ensure access to CP0,6,7 enabled
        ORR     a1, a1, #2_11000001
        MCR     p15, 0, a1, c15, c1

        MOV     a1, #0
        MCR     p15, 0, a1, c7, c10, 4          ; drain buffers (just in case)

        MOV     sb, #0

        BL      initialise_rom

        BL      initialise_iic

        BL      initialise_ram

        LDR     sp, =Boot_RAM_Base + &1000      ; Wahey! A stack!

        BL      copy_rom_to_ram
a106 1

d199 20
d321 19
a339 19
        NullEntry ; HALEntry HAL_UARTPorts
        NullEntry ; HALEntry HAL_UARTStartUp
        NullEntry ; HALEntry HAL_UARTShutdown
        NullEntry ; HALEntry HAL_UARTFeatures
        NullEntry ; HALEntry HAL_UARTReceiveByte
        NullEntry ; HALEntry HAL_UARTTransmitByte
        NullEntry ; HALEntry HAL_UARTLineStatus
        NullEntry ; HALEntry HAL_UARTInterruptEnable
        NullEntry ; HALEntry HAL_UARTRate
        NullEntry ; HALEntry HAL_UARTFormat
        NullEntry ; HALEntry HAL_UARTFIFOSize
        NullEntry ; HALEntry HAL_UARTFIFOClear
        NullEntry ; HALEntry HAL_UARTFIFOEnable
        NullEntry ; HALEntry HAL_UARTFIFOThreshold
        NullEntry ; HALEntry HAL_UARTInterruptID
        NullEntry ; HALEntry HAL_UARTBreak
        NullEntry ; HALEntry HAL_UARTModemControl
        NullEntry ; HALEntry HAL_UARTModemStatus
        NullEntry ; HALEntry HAL_UARTDevice
a370 148



; The ROM is a 16-bit flash device on the PBI bus. We set up the rest of the PBI
; bus here too.
initialise_rom
        LDR     a4, =PMMR
        ; Need to figure out a good speed setting for the flash here
        ; Dev manual section 8.6.3 says we can't do this while executing from flash.
        ; Let's risk it, as we're not changing the address, or moving the limit.
        ASSERT  PBICLK=66666667
        ; 90ns ROM - 8 address-data wait states, 4 recovery wait states, 16-bit
        MOV     a3, #&00000244
        ORR     a3, a3, #2_01
        STR     a3, [a4, #PBI_PBBAR0]
        MOV     a3, #&FF000000                  ; 16MB of memory space
        STR     a3, [a4, #PBI_PBLR0]

        MOV     a3, #IO_Base
        ORR     a3, a3, #2_10                   ; 32-bit, handshaking (not timed)
        STR     a3, [a4, #PBI_PBBAR1]
        LDR     a3, =-IO_Size
        STR     a3, [a4, #PBI_PBLR1]

        MOV     a3, #EASI_Base
        ORR     a3, a3, #2_10                   ; 32-bit, handshaking (not timed)
        STR     a3, [a4, #PBI_PBBAR2]
        LDR     a3, =-EASI_Size
        STR     a3, [a4, #PBI_PBLR2]

        MOV     pc, lr

copy_rom_to_ram
        STMFD   sp!, {v1-v3,lr}
        ADRL    v1, HAL_Base + 64*1024
        LDR     v2, [v1, #OSHdr_ImageSize]
        SUB     v1, v1, #64*1024                ; start of ROM
        ADD     v2, v2, #64*1024                ; size of ROM
        BL      get_end_of_ram
        SUB     a2, a1, v2                      ; a2 -> start of RAM copy

 [ {FALSE}
        ; We'll use the AAU (it can do it faster than we can with the MMU off)
        MOV     a3, sp
        SUB     sp, sp, #32
        BIC     sp, sp, #31                     ; align to 8-word boundary

        STR     a2, [sp, #AAUDesc_DAR]
        STR     v1, [sp, #AAUDesc_SAR1]
        STR     v2, [sp, #AAUDesc_BC]
        MOV     a1, #0
        STR     a1, [sp, #AAUDesc_NDA]

        MOV     a1, #ADCR_WriteEnable + ADCR_DirectCmd:SHL:ADCR_1
        STR     a1, [sp, #AAUDesc_DC]

        ; Write buffer is off, so no need to synchronise

        LDR     ip, =PMMR
        STR     sp, [ip, #AAU_ANDAR]
        MOV     a1, #0
        STR     a1, [ip, #AAU_ASR]
        MOV     a1, #ACR_Enable
        STR     a1, [ip, #AAU_ACR]

        ; Not using interrupts, and we don't have anything better to do
        ; while it's running. Put a delay in so we're not constantly
        ; accessing the bus. It will take something of the order of 0.25s.
wait_for_aau
        Delay   10
        LDR     a1, [ip, #AAU_ASR]
        TST     a1, #ASR_Active
        BNE     wait_for_aau

 |
        ADD     v3, v1, v2
        ADD     v2, a2, v2

        LDMDB   v3, {a1,a3}
        RSB     v4, a1, #0
        SUB     v4, v4, a3      ; don't include the checksum itself

10      LDMDB   v3!, {a1,a3,a4,lr}
        CMP     v3, v1
        STMDB   v2!, {a1,a3,a4,lr}
        ADD     a3, a3, a1
        ADD     a4, a4, lr
        ADD     v4, v4, a3
        ADD     v4, v4, a4      ; accumulate checksum
        BHI     %BT10
 ]

        ; Now we trampoline into the RAM copy. Invalidate the instruction cache
        ; before (just in case) and after.

        MOV     a1, #0
        MCR     p15, 0, a1, c7, c5

        SUB     a4, a2, v1
        ADD     pc, pc, a4
        NOP

; re-entry point (now in RAM). invalidate the I-cache as we're about to move the ROM.
        MCR     p15, 0, a1, c7, c5

        ADD     v8, v8, a4      ; Also update OS entry pointer

; now re-program ROM location back out of the way of the PCI direct-addressing window
; this means the processor vectors aren't there any longer, but we don't need them.
        LDR     a2, [ip, #PBI_PBBAR0]
        ADD     a2, a2, #ROM_Base
        STR     a2, [ip, #PBI_PBBAR0]

; now back up to ROM

 [ FlashCheck :LAND: :LNOT: Debug
        ; Is the ROM valid?
        TEQ     v4, #0
        ; if not signal the failure on the floppy drive light and
        ; request a new ROM image down the serial port
        BNE     recover_flash
 ]
 [ RAM_Base <> Boot_RAM_Base

        SUB     a3, a4, #ROM_Base
        SUB     pc, pc, a3
        NOP

        MCR     p15, 0, a1, c7, c5      ; invalidate I cache again

; now move the RAM into final position

        STMFD   sp!, {a1-a4}
        BL      move_ram
        LDMFD   sp!, {a1-a4}

; and back into RAM, at final position
        ADD     a3, a3, #RAM_Base - Boot_RAM_Base
        ADD     a4, a4, #RAM_Base - Boot_RAM_Base
        ADD     v8, v8, #RAM_Base - Boot_RAM_Base
        ADD     pc, pc, a3
        NOP
 ]

        LDMFD   sp!, {v1-v3,lr}
        ADD     pc, lr, a4      ; don't forget to relocate return address


a411 2
;        BL      IIC_Init

d422 2
a423 4
;        BL      USB_Init

;        MOV     a1,#0
;        BL      HAL_UARTStartUp
d447 1
d449 1
a460 3
HAL_Null
        MOV     pc, lr

d541 24
@


1.8
log
@Random check in as it's been rather a long time and I don't trust
people's harddiscs.
Changes for DMA support (s.ATA)
Bug fix to HAL Counter info,it only worked if R0=0 on entry - spotted
by Dan Ellis
Power on <key held down> support in C.USBHAL and H.USBHAL
Reads the CMOS lock jumper
The beginnings of flash recovery code
Some code tidy ups and documentation updates

Version 0.11. Tagged as 'Tungsten-0_11'
@
text
@d235 1
d678 2
@


1.7
log
@  Support for latest DMA Manager module, plus some housekeeping.
Detail:
  * Removed obsolete DMA-related HAL entries (no longer required by latest
    DMA Manager).
  * Device location field now correctly constructed at initialisation time.
  * Some device entries moved around / removed (see today's DMA Manager log).
  * DMA channels now registered in reverse order, so that they come out the
    "right way" round when enumerated using SWI OS_Hardware 4.
  * Slapped various bits of C around so that they compile without warnings.
Admin:
  Tested.

Version 0.07. Tagged as 'Tungsten-0_07'
@
text
@d44 1
a44 1
        CallOS  $entry
d46 1
d48 5
d60 2
d81 1
a81 1
        DCD     0                       ; patched in by build system
a86 6
;irq_test
;        LDR     r13, =HEX_DIGIT_0
;        MOV     r12, #&FF
;        STRB    r12, [r13]
;        SUBS    pc, lr, #4

d102 2
d106 54
a169 3
;        MOV     a1, #&70
;        BL      DisplayHex

a171 3
;        MOV     a1, #&71
;        BL      DisplayHex

d176 1
a176 1
        LDR     sp, =Boot_RAM_Base + &1000           ; Wahey! A stack!
a180 13
 [ {FALSE}
        MOV     v1, #0
hexloop MOV     a1, v1
        BL      DisplayHex
        Delay   100000
        ADD     v1, v1, #1
        B       hexloop
 ]

;        MOV     a1, #&01
;        BL      DisplayHex

        LDR     v4, =PMMR
d199 1
a199 2
;        MOV     a1, #&02
;        BL      DisplayHex
a200 2
        MOV     a4, v1
        MOV     a1, #OSStartFlag_POR
d203 1
d208 1
a208 1
        DCD     0
a228 1
;        IMPORT   Matrix_Init
a229 1
;        IMPORT   USB_Init
a262 2
;        IMPORT   HAL_IICSetLines
;        IMPORT   HAL_IICReadLines
d290 1
a290 29
;        IMPORT   HAL_MatrixColumns
;        IMPORT   HAL_MatrixScan
;
;        IMPORT   HAL_TouchscreenType
;        IMPORT   HAL_TouchscreenRead
;        IMPORT   HAL_TouchscreenMode
;        IMPORT   HAL_TouchscreenMeasure

         IMPORT   HAL_MachineID

;        IMPORT   HAL_UARTPorts
;        IMPORT   HAL_UARTStartUp
;        IMPORT   HAL_UARTShutdown
;        IMPORT   HAL_UARTFeatures
;        IMPORT   HAL_UARTReceiveByte
;        IMPORT   HAL_UARTTransmitByte
;        IMPORT   HAL_UARTLineStatus
;        IMPORT   HAL_UARTInterruptEnable
;        IMPORT   HAL_UARTRate
;        IMPORT   HAL_UARTFormat
;        IMPORT   HAL_UARTFIFOSize
;        IMPORT   HAL_UARTFIFOClear
;        IMPORT   HAL_UARTFIFOEnable
;        IMPORT   HAL_UARTFIFOThreshold
;        IMPORT   HAL_UARTInterruptID
;        IMPORT   HAL_UARTBreak
;        IMPORT   HAL_UARTModemControl
;        IMPORT   HAL_UARTModemStatus
;        IMPORT   HAL_UARTDevice
d302 1
a302 1
;        IMPORT   HAL_PCISpecialCycle
d310 5
d434 5
a448 1
 [ {FALSE}
a458 1
 ]
d519 5
d527 4
d555 9
a564 1
; now back up to ROM
d596 2
a650 12
;
;        MOV     a1, #&11
;        BL      DisplayHex

        ; Enable 80200 external IRQ# line only.
        ; External FIQ# line appears to be always low (?)
;        MOV     a1, #2_0010
;        MCR     p13, 0, a1, c0, c0

;        MOV     a1, #&12
;        BL      DisplayHex

d755 8
@


1.6
log
@Change to new IIC address
Uncommented HAL_SuperIOInfo,fixes bug report of ReadSysInfo 3
returning garbled R0.
Misc other serial port changes.

Version 0.05. Tagged as 'Tungsten-0_05'
@
text
@a304 20
        IMPORT   HAL_DMA_Activate
        IMPORT   HAL_DMA_Deactivate
        IMPORT   HAL_DMA_Reset
        IMPORT   HAL_DMA_Sleep
        IMPORT   HAL_DMA_TestIRQ
        IMPORT   HAL_DMA_DMA_EnumeratePhysical
        IMPORT   HAL_DMA_DMA_EnumerateLogical
        IMPORT   HAL_DMA_DMA_Allocate
        IMPORT   HAL_DMA_DMA_Deallocate
        IMPORT   HAL_DMA_DMA_Features
        IMPORT   HAL_DMA_DMA_SetOptions
        IMPORT   HAL_DMA_DMA_SetCurrentTransfer
        IMPORT   HAL_DMA_DMA_SetNextTransfer
        IMPORT   HAL_DMA_DMA_TransferState
        IMPORT   HAL_DMA_DMA_SetCurrentTransfer2
        IMPORT   HAL_DMA_DMA_SetNextTransfer2
        IMPORT   HAL_DMA_DMA_TransferState2
        IMPORT   HAL_DMA_DMA_IRQClear
        IMPORT   HAL_DMA_DMA_Status

a423 20
        HALEntry HAL_DMA_Activate
        HALEntry HAL_DMA_Deactivate
        HALEntry HAL_DMA_Reset
        HALEntry HAL_DMA_Sleep
        HALEntry HAL_DMA_TestIRQ
        HALEntry HAL_DMA_DMA_EnumeratePhysical
        HALEntry HAL_DMA_DMA_EnumerateLogical
        HALEntry HAL_DMA_DMA_Allocate
        HALEntry HAL_DMA_DMA_Deallocate
        HALEntry HAL_DMA_DMA_Features
        HALEntry HAL_DMA_DMA_SetOptions
        HALEntry HAL_DMA_DMA_SetCurrentTransfer
        HALEntry HAL_DMA_DMA_SetNextTransfer
        HALEntry HAL_DMA_DMA_TransferState
        HALEntry HAL_DMA_DMA_SetCurrentTransfer2
        HALEntry HAL_DMA_DMA_SetNextTransfer2
        HALEntry HAL_DMA_DMA_TransferState2
        HALEntry HAL_DMA_DMA_IRQClear
        HALEntry HAL_DMA_DMA_Status

a629 2

;        BL      M1535DMA_Init
@


1.5
log
@HAL_PlatformInfo and HAL_CleanerSpace were the wrong way round in the HAL
entries table, so the HAL wouldn't build.

Retagged as 'Tungsten-0_04'

Version 0.04. Not tagged
@
text
@d298 1
a298 1
        IMPORT   HAL_PCISlotNumber
d398 1
a398 1
        NullEntry ; HALEntry HAL_SuperIOInfo
d435 1
a435 1
        HALEntry HAL_PCISlotNumber
d671 2
d740 1
d742 3
@


1.4
log
@  Now registers DMA devices with the kernel.
Detail:
  * Old temporary DMA HAL entries maintained for the time being.
  * DMA init now done during HAL_InitDevices instead of HAL_Init.
Admin:
  Requires new kernel.

Version 0.04. Tagged as 'Tungsten-0_04'
@
text
@d399 1
a400 1
        HALEntry HAL_PlatformInfo
d767 1
a767 1
        BL      HAL_PCIWriteConfigHalfword  ; Bit 2 high in PMU device 
@


1.3
log
@Added support for soft power off
Now report this via HAL_PlatformInfo to the Kernel

Version 0.03. Tagged as 'Tungsten-0_03'
@
text
@d442 2
a670 2
        BL      M1535DMA_Init

d692 7
@


1.2
log
@  Added code to drive the M1535's "legacy" DMA controller for floppies etc.
Detail:
  At the moment, this is only using HAL entries that are hard-coded to the
  M1535 routines, eventually this should be chaned to use the kernel's device
  APIs.
Admin:
  Also creates/removes build directories as required.

Version 0.02. Tagged as 'Tungsten-0_02'
@
text
@d55 3
d400 1
a400 1
        NullEntry ; HALEntry HAL_PlatformInfo
d730 7
d744 17
a760 4
        LDR     ip, PMMR_Address
        LDR     a1, [ip, #ATU_PCSR]
        ORR     a1, a1, #1:SHL:5
        STR     a1, [ip, #ATU_PCSR]
@


1.1
log
@Initial check-in.

Version 0.01. Tagged as 'Tungsten-0_01'
@
text
@d196 1
d302 20
d439 20
d665 2
@


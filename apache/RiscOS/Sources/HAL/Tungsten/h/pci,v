head	1.7;
access;
symbols
	Tungsten-0_63:1.7
	Tungsten-0_62:1.7
	Tungsten-0_61:1.7
	Tungsten-0_60:1.7
	SMP:1.7.0.2
	SMP_bp:1.7
	Tungsten-0_59:1.7
	Tungsten-0_58:1.7
	Tungsten-0_57:1.7
	Tungsten-0_56:1.7
	Tungsten-0_55:1.7
	Tungsten-0_54:1.7
	Tungsten-0_53:1.7
	Tungsten-0_52:1.7
	Tungsten-0_51:1.7
	Tungsten-0_50:1.7
	Tungsten-0_49:1.7
	Tungsten-0_48:1.7
	Tungsten-0_47:1.7
	Tungsten-0_46:1.7
	Tungsten-0_45:1.7
	Tungsten-0_44:1.7
	Tungsten-0_43:1.7
	Tungsten-0_42:1.7
	Tungsten-0_41:1.7
	Tungsten-0_40:1.7
	Tungsten-0_39:1.7
	Tungsten-0_38:1.7
	Tungsten-0_37:1.7
	Tungsten-0_36:1.7
	Tungsten-0_35:1.7
	Tungsten-0_34:1.7
	Tungsten-0_33:1.7
	Tungsten-0_32:1.7
	Tungsten-0_31:1.7
	Tungsten-0_30:1.7
	Tungsten-0_29:1.7
	Tungsten-0_28:1.7
	Tungsten-Official514:1.7
	Tungsten-0_27:1.7
	Tungsten-0_26:1.7
	Tungsten-0_25:1.7
	Tungsten-0_24:1.7
	Tungsten-0_23:1.6
	Tungsten-0_22:1.5
	Tungsten-0_21:1.4
	Tungsten-0_20:1.4
	RO_5_07:1.4
	Tungsten-0_19:1.4
	Tungsten-0_18:1.4
	Tungsten-0_17:1.3
	Tungsten-0_16:1.3
	Tungsten-0_15:1.3
	Tungsten-0_14:1.3
	Tungsten-0_13:1.2
	Tungsten-0_12:1.1
	Tungsten-0_11:1.1
	Tungsten-0_10:1.1
	Tungsten-0_09:1.1
	Tungsten-0_08:1.1
	Tungsten-0_07:1.1
	Tungsten-0_06:1.1
	Tungsten-0_05:1.1
	Tungsten-0_04:1.1
	Tungsten-0_03:1.1
	Tungsten-0_02:1.1
	Tungsten-0_01:1.1;
locks; strict;
comment	@# @;


1.7
date	2005.08.11.00.55.32;	author jballance;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.10.23.12.35;	author jballance;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.25.13.46.50;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.30.14.35.50;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.15.20.03.34;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.23.18.19.42;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.07.12.34.05;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.7
log
@	corrected h.pci, wrong file committed in v0.23
Detail:
Admin:


Version 0.24. Tagged as 'Tungsten-0_24'
@
text
@/* Copyright 2002 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdbool.h>
#include "sys/queue.h"

#define DEV(devfunc) ((devfunc) >> 3)
#define FUNC(devfunc) ((devfunc) & 7)
#define DEVFUNC(dev,func) (((dev) << 3) | (func))

typedef struct pci_dev
{
    STAILQ_ENTRY(pci_dev) global_list;
    STAILQ_ENTRY(pci_dev) bus_list;
    STAILQ_HEAD(addrlist, pci_addr) addresses;
    struct pci_bridge *parent;
    unsigned vendor : 16;
    unsigned devid : 16;
    unsigned class : 24;
    unsigned devfunc : 8;
    unsigned bus : 8;
    unsigned headertype : 8;
    unsigned msi : 8;
    unsigned messages : 8;
    bool     msi64 : 1;
    bool     iobad : 1;
    bool     membad : 1;
    bool     fastb2b : 1;
    bool     bridge : 1;
    bool     capabilities : 1;
} pci_dev;

typedef struct pci_bridge
{
    pci_dev dev;
    unsigned secondary : 8;
    unsigned subordinate : 8;
    bool fastb2b_sec : 1;
    bool root : 1;
    bool supports_prefetch : 1;
    struct pci_addr *window[3];
    STAILQ_HEAD(busdevlist, pci_dev) devices;
    STAILQ_HEAD(busaddrlist, pci_addr) addresses;
} pci_bridge;

uint8_t  HAL_PCIReadConfigByte
         (unsigned bus, unsigned devfn, unsigned address);
uint16_t HAL_PCIReadConfigHalfword
         (unsigned bus, unsigned devfn, unsigned address);
uint32_t HAL_PCIReadConfigWord
         (unsigned bus, unsigned devfn, unsigned address);

void HAL_PCIWriteConfigByte
     (unsigned bus, unsigned devfn, unsigned address, uint8_t value);
void HAL_PCIWriteConfigHalfword
     (unsigned bus, unsigned devfn, unsigned address, uint16_t value);
void HAL_PCIWriteConfigWord
     (unsigned bus, unsigned devfn, unsigned address, uint32_t value);

typedef struct pci_state pci_state;

uint8_t pci_find_capability(pci_dev *d, uint8_t cap);
bool pci_known_int_line(pci_dev *d, int pin, int *line);
void pci_platform_setup(pci_state *pci);

/* return the base address for device class cl, starting with *device = 0,
   returns with *device = 0 and value 0 when no more devices */
void *pci_find_class_address(unsigned int class, int *device);
uint8_t pci_read_config_byte_dev(pci_dev *dev, uint8_t address);


/* Standard configuration space header layout */
#define PCI_VENDOR_ID 0x00
#define PCI_DEVICE_ID 0x02
#define PCI_COMMAND   0x04
#define PCI_STATUS    0x06
#define PCI_CLASS_REV 0x08
#define PCI_REVISION_ID 0x08
#define PCI_CLASS_IF  0x09
#define PCI_CLASS     0x0A
#define PCI_CL_SIZE   0x0C
#define PCI_LATENCY   0x0D
#define PCI_HEADER_TYPE 0x0E
#define PCI_BIST      0x0F

/* graphics card AGP capabilities register */
#define PCI_AGP_COMMAND 0x4C

#define PCI_HEADER_TYPE_NORMAL  0
#define PCI_HEADER_TYPE_BRIDGE  1
#define PCI_HEADER_TYPE_CARDBUS 2

/* Type 0 header */
#define PCI_BASE_ADDRESS_0 0x10
#define PCI_BASE_ADDRESS_1 0x14
#define PCI_BASE_ADDRESS_2 0x18
#define PCI_BASE_ADDRESS_3 0x1C
#define PCI_BASE_ADDRESS_4 0x20
#define PCI_BASE_ADDRESS_5 0x24
#define PCI_SUBSYSTEM_VENDOR_ID 0x2C
#define PCI_SUBSYSTEM_ID   0x2E
#define PCI_ROM_ADDR  0x30
#define PCI_CAP_PTR   0x34
#define PCI_INT_LINE  0x3C
#define PCI_INT_PIN   0x3D
#define PCI_MIN_GNT   0x3E
#define PCI_MAX_LAT   0x3F

#define  PCI_BASE_ADDRESS_SPACE	0x01	/* 0 = memory, 1 = I/O */
#define  PCI_BASE_ADDRESS_SPACE_IO 0x01
#define  PCI_BASE_ADDRESS_SPACE_MEMORY 0x00
#define  PCI_BASE_ADDRESS_MEM_TYPE_MASK 0x06
#define  PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
#define  PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M [obsolete] */
#define  PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
#define  PCI_BASE_ADDRESS_MEM_PREFETCH	0x08	/* prefetchable? */
#define  PCI_BASE_ADDRESS_MEM_MASK	(~0x0fU)
#define  PCI_BASE_ADDRESS_IO_MASK	(~0x03U)
/* bit 1 is reserved if address_space = 1 */

#define PCI_CMD_IO      0x0001
#define PCI_CMD_MEMORY  0x0002
#define PCI_CMD_MASTER  0x0004
#define PCI_CMD_SPECIAL 0x0008
#define PCI_CMD_MWI     0x0010
#define PCI_CMD_VGAPAL  0x0020
#define PCI_CMD_PERR    0x0040
#define PCI_CMD_STEP    0x0080
#define PCI_CMD_SERR    0x0100
#define PCI_CMD_FASTB2B 0x0200

#define PCI_STA_CAP     0x0010
#define PCI_STA_66MHZ   0x0020
#define PCI_STA_FASTB2B 0x0080
#define PCI_STA_PERR    0x0100
#define PCI_STA_DEVSEL  0x0600
#define PCI_STA_DEVSEL_FAST   0x0000
#define PCI_STA_DEVSEL_MEDIUM 0x0200
#define PCI_STA_DEVSEL_SLOW   0x0400
#define PCI_STA_TABT_TGT 0x0800
#define PCI_STA_TABT_MTR 0x1000
#define PCI_STA_MABT_MTR 0x2000
#define PCI_STA_SERR     0x4000
#define PCI_STA_PARITY   0x8000

#define  PCI_BASE_ADDRESS_SPACE	0x01	/* 0 = memory, 1 = I/O */
#define  PCI_BASE_ADDRESS_SPACE_IO 0x01
#define  PCI_BASE_ADDRESS_SPACE_MEMORY 0x00
#define  PCI_BASE_ADDRESS_MEM_TYPE_MASK 0x06
#define  PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
#define  PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M [obsolete] */
#define  PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
#define  PCI_BASE_ADDRESS_MEM_PREFETCH	0x08	/* prefetchable? */
#define  PCI_BASE_ADDRESS_MEM_MASK	(~0x0fU)
#define  PCI_BASE_ADDRESS_IO_MASK	(~0x03U)
/* bit 1 is reserved if address_space = 1 */

#define PCI_BAR_IS_IO(a) (((a) & 3) == 1)
#define PCI_BAR_IS_MEM(a) (((a) & 3) == 0) /* 32-bit or 64-bit only */
#define PCI_BAR_IS_MEM20(a) (((a) & 7) == 2)
#define PCI_BAR_IS_MEM64(a) (((a) & 7) == 4)
#define PCI_BAR_IS_PREFETCHABLE(a) (((a) & PCI_BASE_ADDRESS_MEM_PREFETCH) != 0)

#define PCI_BAR_IO_ADDRESS(a) ((a) & PCI_BASE_ADDRESS_IO_MASK)
#define PCI_BAR_MEM_ADDRESS(a) ((a) & PCI_BASE_ADDRESS_MEM_MASK)
#define PCI_BAR_ROM_ADDRESS(a) ((a) & PCI_ROM_ADDR_MASK)

#define PCI_ROM_ADDR_ENABLE 0x00000001
#define PCI_ROM_ADDR_MASK   0xfffff800

#define PCI_BASE_CLASS_OLD        0x00
#define PCI_BASE_CLASS_STORAGE    0x01
#define PCI_BASE_CLASS_NETWORK    0x02
#define PCI_BASE_CLASS_DISPLAY    0x03
#define PCI_BASE_CLASS_MULTIMEDIA 0x04
#define PCI_BASE_CLASS_MEMORY     0x05
#define PCI_BASE_CLASS_BRIDGE     0x06
#define PCI_BASE_CLASS_COMMS      0x07
#define PCI_BASE_CLASS_SYSTEM     0x08
#define PCI_BASE_CLASS_INPUT      0x09
#define PCI_BASE_CLASS_DOCKING    0x0A
#define PCI_BASE_CLASS_CPU        0x0B
#define PCI_BASE_CLASS_SERIAL     0x0C
#define PCI_BASE_CLASS_WIRELESS   0x0D
#define PCI_BASE_CLASS_IIO        0x0E
#define PCI_BASE_CLASS_SATELLITE  0x0F
#define PCI_BASE_CLASS_ENCRYPT    0x10
#define PCI_BASE_CLASS_DATA       0x11
#define PCI_BASE_CLASS_OTHER      0xFF

#define PCI_CLASS_BRIDGE_HOST 0x0600
#define PCI_CLASS_BRIDGE_ISA  0x0601
#define PCI_CLASS_BRIDGE_EISA 0x0602
#define PCI_CLASS_BRIDGE_MCA  0x0603
#define PCI_CLASS_BRIDGE_PCI  0x0604
#define PCI_CLASS_BRIDGE_PCCARD 0x0605
#define PCI_CLASS_BRIDGE_NUBUS 0x0606
#define PCI_CLASS_BRIDGE_CARDBUS 0x0607
#define PCI_CLASS_BRIDGE_RACEWAY 0x0608
#define PCI_CLASS_BRIDGE_OTHER 0x0680

#define PCI_CAP_MSI 5

#define PCI_CAP_ID    0x00
#define PCI_CAP_NEXT  0x01

#define PCI_MSI_CTRL  0x02
#define PCI_MSI_ADDR  0x04
#define PCI_MSI_DATA32 0x08
#define PCI_MSI_DATA64 0x0C

#define PCI_MSI_64BIT 0x80
#define PCI_MSI_MMENA 0x70
#define PCI_MSI_MMENA_SHIFT 4
#define PCI_MSI_MMCAP 0x0E
#define PCI_MSI_MMCAP_SHIFT 1
#define PCI_MSI_ENABLE 0x01

/* Bridge configuration space header layout (type 1) */

/*      PCI_BASE_ADDRESS_0 0x10 */
/*      PCI_BASE_ADDRESS_1 0x14 */
#define PCI_PRIMARY_BUS 0x18
#define PCI_SECONDARY_BUS 0x19
#define PCI_SUBORDINATE_BUS 0x1A
#define PCI_SECONDARY_LATENCY 0x1B
#define PCI_IO_BASE 0x1C
#define PCI_IO_LIMIT 0x1D
#define PCI_SECONDARY_STATUS 0x1E
#define PCI_MEMORY_BASE 0x20
#define PCI_MEMORY_LIMIT 0x22
#define PCI_PREFETCHABLE_BASE 0x24
#define PCI_PREFETCHABLE_LIMIT 0x26
#define PCI_PREFETCHABLE_BASE_UPPER 0x28
#define PCI_PREFETCHABLE_LIMIT_UPPER 0x2C
#define PCI_IO_BASE_UPPER 0x30
#define PCI_IO_LIMIT_UPPER 0x32
/*      PCI_CAP_PTR 0x34 */
#define PCI_BRIDGE_ROM_ADDR 0x38
/*      PCI_INT_LINE  0x3C */
/*      PCI_INT_PIN   0x3D */
#define PCI_BRIDGE_CONTROL 0x3E

#define PCI_BCR_PERR    0x0001
#define PCI_BCR_SERR    0x0002
#define PCI_BCR_ISA     0x0004
#define PCI_BCR_VGA     0x0008
#define PCI_BCR_MABT    0x0020
#define PCI_BCR_RST     0x0040
#define PCI_BCR_FASTB2B 0x0080
#define PCI_BCR_PRIMARY_DISCARD 0x0100
#define PCI_BCR_SECONDARY_DISCARD 0x0200
#define PCI_BCR_DISCARD_STATUS  0x0400
#define PCI_BCR_DISCARD_SERR    0x0800
@


1.6
log
@	Ensure debug is turned off by default.
	Added code to ensure any video card is forced into
	PCI (not AGP) mode before PCI Enumeration.
Detail:
	now writes graphics card AGP Command register to 0
	to ensure card is in PCI mode. This is to help overcome
	an issue seen occasionally on Tungsten.
Admin:  in test at CTL


Version 0.23. Tagged as 'Tungsten-0_23'
@
text
@a14 13
/*#define DEBUG*/

/*****************************************************************************
* Copyright 2003 Tematic Ltd.  All rights reserved.
*
* The copyright in this material is owned by Tematic Limited ("Tematic")
* This material is regarded as a highly confidential trade secret of Tematic.
* It may not be reproduced, used, sold or in any other way exploited
* or transferred to any third party without the prior written permission of
* Tematic.
*****************************************************************************/

#include <stdint.h>
d16 1
a16 829
#include <stdio.h>
#include "swis.h"
#include "pci.h"
#include "pciconf.h"

/* Calling standard mungery - mustn't touch sb/v6 */
__global_reg(6) void *sb;

#ifndef UINT_LEAST24_MAX
typedef uint_least32_t uint_least24_t;
#endif

#ifndef STAILQ_FOREACH
#define STAILQ_FOREACH(var, head, field) \
        for (var = STAILQ_FIRST(head); var; var = STAILQ_NEXT(var, field))
#endif

#define for_every_device(d) \
                         STAILQ_FOREACH((d), &pci->devices, global_list)
#define for_each_bus_device(b, d) \
                         STAILQ_FOREACH((d), &(b)->devices, bus_list)
#define for_each_bus_address(b, a) \
                         STAILQ_FOREACH((a), &(b)->addresses, bus_list)
#define for_each_device_address(d, a) \
                         STAILQ_FOREACH((a), &(d)->addresses, dev_list)

typedef struct pci_bus pci_bus;
typedef struct pci_addr pci_addr;

#ifdef DEBUG
#define dprintf(...) printf(__VA_ARGS__)
#else
#define dprintf(...)
#endif

struct pci_addr
{
    STAILQ_ENTRY(pci_addr) bus_list;
    STAILQ_ENTRY(pci_addr) dev_list;
    pci_dev *dev;
    uint8_t bar;
    uint8_t type;
    uint32_t addr;
    uint32_t size;
    uint32_t align;
};

#define IO 0
#define NonPrefetchable 1
#define Prefetchable 2
#define Unknown 255

#define ADDR_UNASSIGNED UINT32_C(0xFFFFFFFF)
#define ADDR_FAILED     UINT32_C(0xFFFFFFFE)

#define LATENCY_SETTING 32
#define CACHELINE_SETTING 8

struct pci_state
{
    STAILQ_HEAD(devlist, pci_dev) devices;
    pci_bridge host_bridge;
};

#define ROUND_UP(addr, align) (((addr) + (align)-1) &~ ((align)-1))
#define ROUND_DOWN(addr, align) ((addr) &~ ((align)-1))

static void pci_enumerate_bus(pci_state *pci, pci_bridge *bridge, int bus, int *highest_bus);

extern void *hal_alloc(size_t);
extern pci_state *pci_get_state(void);
extern void pci_set_state(pci_state *);

#define pci_read_config_byte      HAL_PCIReadConfigByte
#define pci_read_config_halfword  HAL_PCIReadConfigHalfword
#define pci_read_config_word      HAL_PCIReadConfigWord
#define pci_write_config_byte     HAL_PCIWriteConfigByte
#define pci_write_config_halfword HAL_PCIWriteConfigHalfword
#define pci_write_config_word     HAL_PCIWriteConfigWord

uint8_t pci_read_config_byte_dev(pci_dev *dev, uint8_t address)
{
    return HAL_PCIReadConfigByte(dev->bus, dev->devfunc, address);
}

uint16_t pci_read_config_halfword_dev(pci_dev *dev, uint8_t address)
{
    return HAL_PCIReadConfigHalfword(dev->bus, dev->devfunc, address);
}

uint32_t pci_read_config_word_dev(pci_dev *dev, uint8_t address)
{
    return HAL_PCIReadConfigWord(dev->bus, dev->devfunc, address);
}

void pci_write_config_byte_dev(pci_dev *dev, uint8_t address, uint8_t value)
{
    HAL_PCIWriteConfigByte(dev->bus, dev->devfunc, address, value);
}

void pci_write_config_halfword_dev(pci_dev *dev, uint8_t address, uint16_t value)
{
    HAL_PCIWriteConfigHalfword(dev->bus, dev->devfunc, address, value);
}

void pci_write_config_word_dev(pci_dev *dev, uint8_t address, uint32_t value)
{
    HAL_PCIWriteConfigWord(dev->bus, dev->devfunc, address, value);
}

/*
 * 1: Find bridges and bus numbers (to allow configuration cycles to work)
 */
static pci_dev *pci_add_device(pci_state *pci, pci_bridge *parent, int bus, int devfunc, bool bridge)
{
    pci_dev *d = hal_alloc(bridge ? sizeof(pci_bridge) : sizeof(pci_dev));

    STAILQ_INSERT_TAIL(&pci->devices, d, global_list);
    STAILQ_INSERT_TAIL(&parent->devices, d, bus_list);
    STAILQ_INIT(&d->addresses);
    d->parent = parent;
    d->bus = bus;
    d->devfunc = devfunc;
    d->iobad = false;
    d->membad = false;
    d->bridge = bridge;
    d->fastb2b = false;
    if (bridge)
    {
        pci_bridge *b = (pci_bridge *) d;
        b->root = false;
        b->window[IO] =
        b->window[NonPrefetchable] =
        b->window[Prefetchable] = NULL;
        STAILQ_INIT(&b->devices);
        STAILQ_INIT(&b->addresses);
    }

    dprintf("Added bus %d, dev %d, fun %d\n", bus, devfunc >> 3, devfunc & 7);

    return d;
}

static void pci_enumerate_device(pci_state *pci, int *highest_bus,
                                 pci_bridge *bridge,
                                 int bus, int devfunc,
                                 uint32_t vend_dev, uint8_t headertype)
{
    uint_least24_t class;
    uint16_t status;

    #ifdef IGNORE_SOME_DEVICES
    if (pci_ignore_device(vend_dev)) return;
    #endif

    dprintf("Enumerating bus %d, dev %d, func %d\n", bus, devfunc >> 3, devfunc & 7);

    /* Take the opportunity to shut down all devices */
    uint16_t cmd;
    cmd = pci_read_config_halfword(bus, devfunc, PCI_COMMAND);
    cmd &=~(PCI_CMD_IO | PCI_CMD_MEMORY | PCI_CMD_MASTER | PCI_CMD_SPECIAL |
            PCI_CMD_MWI | PCI_CMD_VGAPAL | PCI_CMD_STEP | PCI_CMD_FASTB2B);
    cmd |= (PCI_CMD_PERR | PCI_CMD_SERR);
    pci_write_config_halfword(bus, devfunc, PCI_COMMAND, cmd);

    class = pci_read_config_word(bus, devfunc, PCI_CLASS_REV) >> 8;

    /* Add it to the global list of devices */
    pci_dev *d = pci_add_device(pci, bridge, bus, devfunc, (class >> 8) == PCI_CLASS_BRIDGE_PCI);

    pci_write_config_byte_dev(d, PCI_LATENCY, LATENCY_SETTING);
    pci_write_config_byte_dev(d, PCI_CL_SIZE, CACHELINE_SETTING);

    status = pci_read_config_halfword_dev(d, PCI_STATUS);
    d->fastb2b = status & PCI_STA_FASTB2B;
    d->capabilities = status & PCI_STA_CAP;
    d->vendor = vend_dev;
    d->devid = vend_dev >> 16;
    d->class = class;
    d->headertype = headertype & 0x7F;

    if ((class >> 8) == PCI_CLASS_BRIDGE_PCI)
    {
        pci_bridge *b = (pci_bridge *) d;
        status = pci_read_config_halfword_dev(d, PCI_SECONDARY_STATUS);
        b->fastb2b_sec = status & PCI_STA_FASTB2B;
        b->secondary = ++*highest_bus;
        /* primary, secondary, subordinate bus + 2ary latency all form 1
         * word */
        pci_write_config_word_dev(d, PCI_PRIMARY_BUS,
                                     bus |                   /* primary */
                                     (b->secondary << 8) | /* secondary */
                                     (255 << 16) |       /* subordinate */
                                     (LATENCY_SETTING << 24) /* latency */
                                  );
        if (d->parent->supports_prefetch)
        {
            pci_write_config_word_dev(d, PCI_PREFETCHABLE_BASE, 0x0000ffff);
            b->supports_prefetch =
               pci_read_config_word_dev(d, PCI_PREFETCHABLE_BASE) != 0;
        }
        else
            b->supports_prefetch = false;
        pci_enumerate_bus(pci, b, b->secondary, highest_bus);
        b->subordinate = *highest_bus;
        pci_write_config_byte_dev(d, PCI_SUBORDINATE_BUS, b->subordinate);
        uint16_t bcr;
        bcr = pci_read_config_halfword_dev(d, PCI_BRIDGE_CONTROL);
        bcr &=~(PCI_BCR_ISA | PCI_BCR_VGA | PCI_BCR_MABT | PCI_BCR_RST |
                PCI_BCR_FASTB2B | PCI_BCR_PRIMARY_DISCARD |
                PCI_BCR_SECONDARY_DISCARD | PCI_BCR_DISCARD_STATUS |
                PCI_BCR_DISCARD_SERR);
        bcr |= (PCI_BCR_PERR | PCI_BCR_SERR);
        pci_write_config_halfword_dev(d, PCI_BRIDGE_CONTROL, bcr);
    }
}

static void pci_enumerate_bus(pci_state *pci, pci_bridge *bridge,
                              int bus, int *highest_bus)
{
    for (int dev = 0; dev < 32; dev++)
    {
        int funcs = 1;
        uint8_t headertype;
        for (int func = 0; func < funcs; func++)
        {
            uint32_t vend_dev;
            int devfunc = DEVFUNC(dev, func);

            vend_dev = pci_read_config_word(bus, devfunc, PCI_VENDOR_ID);
            if (vend_dev == UINT32_C(0xFFFFFFFF)) continue;
            if (func == 0)
            {
                headertype = pci_read_config_byte(bus, devfunc, PCI_HEADER_TYPE);
                if (headertype & 0x80) funcs = 8;
            }
            pci_enumerate_device(pci, highest_bus, bridge, bus, devfunc, vend_dev, headertype);
        }
    }
}

static void pci_enumerate_devices(pci_state *pci)
{
    STAILQ_INIT(&pci->devices);

    STAILQ_INIT(&pci->host_bridge.dev.addresses);
    STAILQ_INIT(&pci->host_bridge.devices);
    STAILQ_INIT(&pci->host_bridge.addresses);
    pci->host_bridge.dev.parent = NULL;
    pci->host_bridge.root = true;
    pci->host_bridge.secondary = 0;

    int highest_bus = 0;
    pci_enumerate_bus(pci, &pci->host_bridge, 0, &highest_bus);
    pci->host_bridge.subordinate = highest_bus;
}

/*
 * 2: Note the address claims of each device.
 */
static pci_addr *pci_add_address(pci_dev *d, int bar)
{
    pci_addr *a = hal_alloc(sizeof *a);

    STAILQ_INSERT_TAIL(&d->addresses, a, dev_list);
    if (d->parent)
        STAILQ_INSERT_TAIL(&d->parent->addresses, a, bus_list);
    a->dev = d;
    a->bar = bar;
    a->type = Unknown;
    a->addr = ADDR_UNASSIGNED;
    a->size = a->align = 0;

    return a;
}

static bool poweroftwo(uint32_t a)
{
    return a != 0 && (a & (a-1)) == 0;
}

static void pci_note_addresses(pci_dev *d)
{
    int bus = d->bus, devfunc = d->devfunc;
    int bar, end, rombar;
    uint32_t addr;
    switch (d->headertype)
    {
        case 0: bar = PCI_BASE_ADDRESS_0;
                end = bar + 6*4;
                rombar = PCI_ROM_ADDR;
                break;
        case 1: bar = PCI_BASE_ADDRESS_0;
                end = bar + 2*4;
                rombar = PCI_BRIDGE_ROM_ADDR;
                break;
        default:d->membad = true;
                d->iobad = true;
                return;
    }

    /* Special for the southbridge */
    if (d->parent->dev.bus == 0 &&
        d->parent->dev.devfunc == DEVFUNC(8,0) &&
        devfunc == DEVFUNC(2,0))
    {
        pci_addr *a = pci_add_address(d, 0);
        a->type = IO;
        a->size = 0x800;
        a->align = 0x10000; /* High alignment forces it to low address */
    }

    for (; bar<end; bar+=4)
    {
        pci_write_config_word(bus, devfunc, bar, UINT32_C(0xFFFFFFFF));
        addr = pci_read_config_word(bus, devfunc, bar);

        if (addr == 0) continue;

        pci_addr *a = pci_add_address(d, bar);

        if (PCI_BAR_IS_IO(addr))
        {
            if ((addr & 0xFFFF0000) == 0)
                addr |= 0xFFFF0000;
            a->type = IO;
            a->size = a->align = ~PCI_BAR_IO_ADDRESS(addr) + 1;
            if (a->size > 256 || !poweroftwo(a->size))
            {
                a->size = a->align = 0;
                a->addr = ADDR_FAILED;
                d->iobad = true;
                continue;
            }
        }
        else if (PCI_BAR_IS_MEM20(addr))
        {
            a->addr = ADDR_FAILED;
            a->type = NonPrefetchable;
            d->membad = true;
            continue;
        }
        else if (PCI_BAR_IS_MEM(addr)) /* 32-bit or 64-bit */
        {
            a->size = a->align = ~PCI_BAR_MEM_ADDRESS(addr) + 1;
            a->type = PCI_BAR_IS_PREFETCHABLE(addr) &&
                            d->parent->supports_prefetch ? Prefetchable
                                                         : NonPrefetchable;

            /* Zero & skip top 32 bits of 64-bit addresses - we're 32-bit */
            if (PCI_BAR_IS_MEM64(addr))
                pci_write_config_word(bus, devfunc, bar+=4, 0);

            /* Requests of 4GB or more come out as a->size = 0, which fails
             * the poweroftwo test.
             */
            if (!poweroftwo(a->size))
            {
                a->size = a->align = 0;
                a->addr = ADDR_FAILED;
                d->membad = true;
                continue;
            }
        }
        else
        {
            a->addr = ADDR_FAILED;
            a->type = Unknown;
            d->iobad = true;
            d->membad = true;
            continue;
        }
    }

    /* Also the ROM */
    pci_write_config_word(bus, devfunc, rombar, UINT32_C(0xFFFFFFFF));
    addr = pci_read_config_word(bus, devfunc, rombar);
    if (addr == 0) return;
    pci_write_config_word(bus, devfunc, rombar, 0);

    pci_addr *a = pci_add_address(d, rombar);
    a->size = a->align = ~PCI_BAR_ROM_ADDRESS(addr) + 1;
    a->type = ROM_TYPE;
    if (a->size > 16*1024*1024 || !poweroftwo(a->size))
    {
        a->size = a->align = 0;
        a->addr = ADDR_FAILED;
    }
}

/*
 * 3: Calculate the size and alignment requirements of each bridge window
 */
static void pci_calc_bridge_windows(pci_bridge *bridge, int type)
{
    pci_dev *d;
    for_each_bus_device(bridge, d)
    {
        if (d->bridge)
        {
            pci_calc_bridge_windows((pci_bridge *) d, type);
        }
    }

    dprintf("Calculating window type %d for bus %d\n", type, bridge->secondary);

    pci_addr *a;
    uint32_t maxalign = type == IO ? 0x1000 : 0x100000;
    for_each_bus_address(bridge, a)
    {
        if (a->type != type) continue;
        if (a->align > maxalign) maxalign = a->align;
    }

    uint32_t size = 0, align;
    for (align = maxalign; align; align >>= 1)
    {
        for_each_bus_address(bridge, a)
        {
            if (a->type != type || a->align != align) continue;
            size = ROUND_UP(size, align);
            size += a->size;
            dprintf("(%08x,%08x)\n", a->size, a->align);
        }
    }

    if (type == IO)
        size = ROUND_UP(size, 0x1000);
    else
        size = ROUND_UP(size, 0x100000);

    dprintf("Alignment = %x\n", maxalign);
    dprintf("Size = %x\n", size);

    if (size > 0)
    {
        bridge->window[type] = a = pci_add_address((pci_dev *) bridge, 0);
        a->type = type;
        a->size = size;
        a->align = maxalign;
    }
}

static void pci_calc_windows(pci_state *pci)
{
    pci_calc_bridge_windows(&pci->host_bridge, IO);
    pci_calc_bridge_windows(&pci->host_bridge, NonPrefetchable);
    pci_calc_bridge_windows(&pci->host_bridge, Prefetchable);
}

/*
 * 4: Allocate the addresses for each device
 */
static uint32_t pci_allocate_bus(pci_bridge *bridge, int type,
                                 uint32_t min, uint32_t max, int dir)
{
    uint32_t align, addr;

    addr = dir > 0 ? min : max + 1;

    if (!bridge->window[type]) return addr;

    /* For all buses except the primary, the address space is aligned
     * (at the top or bottom) to the highest alignment requirement
     * of everything in that bus. Thus we just start with the
     * highest aligned address claim, and work our way down.
     *
     * The primary bus is unfortunately different, as the memory
     * space can't start at 0, as some cards interpret that
     * as a null pointer. Thus we will end up with holes; we deal
     * with these holes by recursively using the same algorithm in the
     * opposite direction in the hole.
     *
     * This ultimately means that the size of the actual
     * memory window of the primary bus may be larger than
     * that allocated by pci_calc_bridge_windows, but it doesn't
     * matter - we return the highest (or lowest) address used.
     */

    for (align = bridge->window[type]->align; align; align >>= 1)
    {
        pci_addr *a;
        for_each_bus_address(bridge, a)
        {
            uint32_t newaddr;
            if (a->type != type || a->align != align ||
                a->addr != ADDR_UNASSIGNED) continue;

            if (dir > 0)
                newaddr = ROUND_UP(addr, align);
            else
                newaddr = ROUND_DOWN(addr, align) - a->size;

            if (newaddr > max || newaddr < min ||
                newaddr + a->size - 1 > max ||
                newaddr + a->size - 1 < min)
                continue;

            a->addr = newaddr;

            if (dir > 0)
            {
                if (a->addr > addr)
                    pci_allocate_bus(bridge, type, addr, a->addr - 1, -1);
                addr = a->addr + a->size;
            }
            else
            {
                if (a->addr + a->size < addr)
                    pci_allocate_bus(bridge, type, a->addr + a->size, addr - 1, +1);
                addr = a->addr;
            }
            dprintf("[%02d,%02d,%02d,%02x] = %08x-%08x\n", a->dev->bus, a->dev->devfunc >> 3, a->dev->devfunc & 7, a->bar, a->addr, a->addr+a->size-1);

            /* If we've just allocated a bridge window, allocate its
             * addresses now (in the same direction, for alignment).
             */
            if (a->dev->bridge)
            {
                pci_bridge *b = (pci_bridge *) a->dev;
                if (b->window[type] == a)
                    pci_allocate_bus(b, type, a->addr, a->addr + a->size - 1, dir);
            }
        }
    }

    return addr;
}

static void pci_allocate_addresses(pci_state *pci)
{
    pci_allocate_bus(&pci->host_bridge, IO, IO_MIN, IO_MAX, +1);
    uint32_t pfstart =
    pci_allocate_bus(&pci->host_bridge, NonPrefetchable, MEM_MIN, MEM_MAX, +1);
    pci_allocate_bus(&pci->host_bridge, Prefetchable, pfstart, MEM_MAX, -1);
}

static void pci_find_addresses(pci_state *pci)
{
    pci_dev *d;
    for_every_device(d)
        pci_note_addresses(d);
}

/*
 * 5: Program the base address and window registers for each device
 */
static void pci_program_windows(pci_bridge *b)
{
    uint32_t min, max;
    if (b->window[IO])
    {
        min = b->window[IO]->addr;
        max = b->window[IO]->addr + b->window[IO]->size - 1;
    }
    else
        min = 0xFFFF, max = 0x0000;

    pci_write_config_halfword_dev(&b->dev, PCI_IO_BASE,
                                  (max & 0xFF00) | (min >> 8));
    pci_write_config_word_dev(&b->dev, PCI_IO_BASE_UPPER, 0);

    if (b->window[NonPrefetchable])
    {
        min = b->window[NonPrefetchable]->addr;
        max = b->window[NonPrefetchable]->addr +
              b->window[NonPrefetchable]->size - 1;
    }
    else
        min = 0xFFFFFFFF, max = 0x00000000;

    pci_write_config_word_dev(&b->dev, PCI_MEMORY_BASE,
                          (max & 0xFFFF0000) | (min >> 16));

    if (b->window[Prefetchable])
    {
        min = b->window[Prefetchable]->addr;
        max = b->window[Prefetchable]->addr +
              b->window[Prefetchable]->size - 1;
    }
    else
        min = 0xFFFFFFFF, max = 0x00000000;

    pci_write_config_word_dev(&b->dev, PCI_PREFETCHABLE_BASE,
                          (max & 0xFFFF0000) | (min >> 16));
    pci_write_config_word_dev(&b->dev, PCI_PREFETCHABLE_BASE_UPPER, 0);

}

static void pci_program_addresses(pci_state *pci)
{
    pci_dev *d;
    for_every_device(d)
    {
        pci_addr *a;
        for_each_device_address(d, a)
        {
            if (a->bar != 0)
                pci_write_config_word_dev(a->dev, a->bar, a->addr);
        }

        if (d->bridge)
            pci_program_windows((pci_bridge *) d);

        uint16_t cmd = pci_read_config_halfword_dev(d, PCI_COMMAND);
        cmd &=~ (PCI_CMD_IO | PCI_CMD_MEMORY);
        if (!d->membad) cmd |= PCI_CMD_MEMORY;
        if (!d->iobad)  cmd |= PCI_CMD_IO;
        cmd |= PCI_CMD_MASTER;
        pci_write_config_halfword_dev(d, PCI_COMMAND, cmd);
    }
}

/*
 * 6: Activate fast back-to-back cycles on each bus that supports them
 */
extern void pci_set_host_fastb2b(bool);

static void pci_calc_fastb2b_for_bus(pci_bridge *b, bool host)
{
    pci_dev *d;
    if (b->fastb2b_sec)
    {
        bool fastb2b = true;
        for_each_bus_device(b, d)
        {
            if (!d->fastb2b)
            {
                fastb2b = false;
                break;
            }
        }
        if (fastb2b)
        {
            for_each_bus_device(b, d)
            {
                uint16_t cmd = pci_read_config_halfword_dev(d, PCI_COMMAND);
                cmd |= PCI_CMD_FASTB2B;
                pci_write_config_halfword_dev(d, PCI_COMMAND, cmd);
            }
            if (host)
                pci_set_host_fastb2b(true);
            else
            {
                uint16_t bcr;
                bcr = pci_read_config_halfword_dev(&b->dev, PCI_BRIDGE_CONTROL);
                bcr |= PCI_BCR_FASTB2B;
                pci_write_config_halfword_dev(&b->dev, PCI_BRIDGE_CONTROL, bcr);
            }
        }
    }
    for_each_bus_device(b, d)
        if (d->bridge)
            pci_calc_fastb2b_for_bus((pci_bridge *) d, false);
}

static void pci_set_fastb2b(pci_state *pci)
{
    pci_calc_fastb2b_for_bus(&pci->host_bridge, true);
}

/*
 * 7: Program the interrupt pin register of each device
 */
static void pci_program_interrupts(pci_state *pci)
{
    pci_dev *d, *d1;
    for_every_device(d)
    {
        int line = 255;
        int pin;
        pin = pci_read_config_byte_dev(d, PCI_INT_PIN);
        if (pin >= 1 && pin <= 4)
        {
            d1 = d;
            while (!pci_known_int_line(d1, pin, &line))
            {
                pin = (((pin - 1) + DEV(d1->devfunc)) & 3) + 1;
                d1 = &d1->parent->dev;
            }
        }
        pci_write_config_byte_dev(d, PCI_INT_LINE, line);
    }
}

#ifdef MSI_SUPPORT
/*
 * 8: Set up the MSI address and data registers for all MSI devices
 */
static void pci_process_msi(pci_state *pci)
{
    pci_dev *d;
    for_every_device(d)
    {
        unsigned msi = pci_find_capability(d, PCI_CAP_MSI);
        d->msi = msi;
        if (msi)
        {
            unsigned ctrl = pci_read_config_halfword_dev(d, msi + PCI_MSI_CTRL);
            d->messages = 1 << ((ctrl & PCI_MSI_MMCAP) >> PCI_MSI_MMCAP_SHIFT);
            pci_write_config_halfword_dev(d, msi + PCI_MSI_CTRL, 0);
            pci_write_config_word_dev(d, msi + PCI_MSI_ADDR, 0);
            if (ctrl & PCI_MSI_64BIT)
            {
                pci_write_config_word_dev(d, msi + PCI_MSI_ADDR+4, 0);
                pci_write_config_halfword_dev(d, msi + PCI_MSI_DATA64, 0);
                d->msi64 = true;
            }
            else
            {
                pci_write_config_halfword_dev(d, msi + PCI_MSI_DATA32, 0);
                d->msi64 = false;
            }
            if (d->messages > 32) d->messages = 0;
        }
        else
            d->messages = 0;
    }

    extern uint32_t pci_msi_addr(void);

    unsigned ptr = MSI_MIN;
    for (int align = 5; align >= 0; align--)
    {
        for_every_device(d)
        {
            if (d->messages != (1 << align)) continue;
            if (ptr <= MSI_MAX+1 - (1 << align))
            {
                /* Note that MSI is not enabled yet - it is only enabled
                 * later by the PCI manager when a MSI-compatible device
                 * driver attaches to it.
                 */
                pci_write_config_halfword_dev(d, d->msi + PCI_MSI_CTRL,
                                                 align << PCI_MSI_MMENA_SHIFT);
                pci_write_config_word_dev(d, d->msi + PCI_MSI_ADDR,
                                             pci_msi_addr());
                pci_write_config_halfword_dev(d, d->msi +
                                              (d->msi64 ? PCI_MSI_DATA64
                                                        : PCI_MSI_DATA32),
                                              ptr);
                ptr += (1 << align);
            }
            else
                d->messages >>= 1;
        }
    }
}
#endif

static pci_state *pci_initialise_state(void)
{
    pci_state *pci = hal_alloc(sizeof *pci);

    STAILQ_INIT(&pci->devices);

    STAILQ_INIT(&pci->host_bridge.dev.addresses);
    STAILQ_INIT(&pci->host_bridge.devices);
    STAILQ_INIT(&pci->host_bridge.addresses);
    pci->host_bridge.dev.parent = NULL;
    pci->host_bridge.root = true;
    pci->host_bridge.supports_prefetch = true;
    pci->host_bridge.secondary = 0;

    pci_set_state(pci);

    return pci;
}

void pci_initialise(void)
{
    pci_state *pci = pci_initialise_state();

    /* State-of-the-art procedural programming techniques */
    pci_platform_setup(pci);
    pci_enumerate_devices(pci);
    pci_find_addresses(pci);
    pci_calc_windows(pci);
    pci_allocate_addresses(pci);
    pci_program_addresses(pci);
    pci_set_fastb2b(pci);
    pci_program_interrupts(pci);
    #ifdef MSI_SUPPORT
    pci_process_msi(pci);
    #endif
}

pci_dev *pci_find_by_class(pci_state *pci,
                           uint_least24_t class,
                           uint_least24_t mask,
                           const pci_dev *from)
{
    const pci_dev *d = from ? STAILQ_NEXT(from, global_list)
                            : STAILQ_FIRST(&pci->devices);

    class &= mask;
    for (; d; d = STAILQ_NEXT(d, global_list))
        if ((d->class & mask) == class)
            return (pci_dev *) d;

    return NULL;
}

void *pci_find_class_address(unsigned int class, int *device)
{
    pci_dev *d = (struct pci_dev *) *device;
    d = pci_find_by_class(pci_get_state(), class, 0xffffff, d);
    *(pci_dev **)device = d;
    if (!d) return NULL;
    extern void *mapinio(int flags, uint32_t addr, uint32_t size);
    pci_addr *a = STAILQ_FIRST(&d->addresses);
    return mapinio(0, a->addr, a->size);
}

uint8_t pci_find_capability(pci_dev *d, uint8_t cap)
{
    if (d->headertype >= 2 || !d->capabilities) return 0;

    uint8_t ptr;
    unsigned id_next;

    for (ptr = pci_read_config_byte_dev(d, PCI_CAP_PTR) & 0xFC;
         ptr != 0;
         ptr = (id_next >> 8) & 0xFC)
    {
        id_next = pci_read_config_halfword_dev(d, ptr);
        if ((id_next & 0xFF) == cap)
            break;
    }
d18 248
a265 2
    return ptr;
}
@


1.5
log
@Moved Tungsten-specific setup code out of PCI.c into PCItung.c.
pci_initialise() in pci.c now calls pci_platform_setup() - for the benefit
of other HALs.

Version 0.22. Tagged as 'Tungsten-0_22'
@
text
@d15 13
d29 829
a857 1
#include "sys/queue.h"
d859 2
a860 245
#define DEV(devfunc) ((devfunc) >> 3)
#define FUNC(devfunc) ((devfunc) & 7)
#define DEVFUNC(dev,func) (((dev) << 3) | (func))

typedef struct pci_dev
{
    STAILQ_ENTRY(pci_dev) global_list;
    STAILQ_ENTRY(pci_dev) bus_list;
    STAILQ_HEAD(addrlist, pci_addr) addresses;
    struct pci_bridge *parent;
    unsigned vendor : 16;
    unsigned devid : 16;
    unsigned class : 24;
    unsigned devfunc : 8;
    unsigned bus : 8;
    unsigned headertype : 8;
    unsigned msi : 8;
    unsigned messages : 8;
    bool     msi64 : 1;
    bool     iobad : 1;
    bool     membad : 1;
    bool     fastb2b : 1;
    bool     bridge : 1;
    bool     capabilities : 1;
} pci_dev;

typedef struct pci_bridge
{
    pci_dev dev;
    unsigned secondary : 8;
    unsigned subordinate : 8;
    bool fastb2b_sec : 1;
    bool root : 1;
    bool supports_prefetch : 1;
    struct pci_addr *window[3];
    STAILQ_HEAD(busdevlist, pci_dev) devices;
    STAILQ_HEAD(busaddrlist, pci_addr) addresses;
} pci_bridge;

uint8_t  HAL_PCIReadConfigByte
         (unsigned bus, unsigned devfn, unsigned address);
uint16_t HAL_PCIReadConfigHalfword
         (unsigned bus, unsigned devfn, unsigned address);
uint32_t HAL_PCIReadConfigWord
         (unsigned bus, unsigned devfn, unsigned address);

void HAL_PCIWriteConfigByte
     (unsigned bus, unsigned devfn, unsigned address, uint8_t value);
void HAL_PCIWriteConfigHalfword
     (unsigned bus, unsigned devfn, unsigned address, uint16_t value);
void HAL_PCIWriteConfigWord
     (unsigned bus, unsigned devfn, unsigned address, uint32_t value);

typedef struct pci_state pci_state;

uint8_t pci_find_capability(pci_dev *d, uint8_t cap);
bool pci_known_int_line(pci_dev *d, int pin, int *line);
void pci_platform_setup(pci_state *pci);

/* return the base address for device class cl, starting with *device = 0,
   returns with *device = 0 and value 0 when no more devices */
void *pci_find_class_address(unsigned int class, int *device);
uint8_t pci_read_config_byte_dev(pci_dev *dev, uint8_t address);


/* Standard configuration space header layout */
#define PCI_VENDOR_ID 0x00
#define PCI_DEVICE_ID 0x02
#define PCI_COMMAND   0x04
#define PCI_STATUS    0x06
#define PCI_CLASS_REV 0x08
#define PCI_REVISION_ID 0x08
#define PCI_CLASS_IF  0x09
#define PCI_CLASS     0x0A
#define PCI_CL_SIZE   0x0C
#define PCI_LATENCY   0x0D
#define PCI_HEADER_TYPE 0x0E
#define PCI_BIST      0x0F

#define PCI_HEADER_TYPE_NORMAL  0
#define PCI_HEADER_TYPE_BRIDGE  1
#define PCI_HEADER_TYPE_CARDBUS 2

/* Type 0 header */
#define PCI_BASE_ADDRESS_0 0x10
#define PCI_BASE_ADDRESS_1 0x14
#define PCI_BASE_ADDRESS_2 0x18
#define PCI_BASE_ADDRESS_3 0x1C
#define PCI_BASE_ADDRESS_4 0x20
#define PCI_BASE_ADDRESS_5 0x24
#define PCI_SUBSYSTEM_VENDOR_ID 0x2C
#define PCI_SUBSYSTEM_ID   0x2E
#define PCI_ROM_ADDR  0x30
#define PCI_CAP_PTR   0x34
#define PCI_INT_LINE  0x3C
#define PCI_INT_PIN   0x3D
#define PCI_MIN_GNT   0x3E
#define PCI_MAX_LAT   0x3F

#define  PCI_BASE_ADDRESS_SPACE	0x01	/* 0 = memory, 1 = I/O */
#define  PCI_BASE_ADDRESS_SPACE_IO 0x01
#define  PCI_BASE_ADDRESS_SPACE_MEMORY 0x00
#define  PCI_BASE_ADDRESS_MEM_TYPE_MASK 0x06
#define  PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
#define  PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M [obsolete] */
#define  PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
#define  PCI_BASE_ADDRESS_MEM_PREFETCH	0x08	/* prefetchable? */
#define  PCI_BASE_ADDRESS_MEM_MASK	(~0x0fU)
#define  PCI_BASE_ADDRESS_IO_MASK	(~0x03U)
/* bit 1 is reserved if address_space = 1 */

#define PCI_CMD_IO      0x0001
#define PCI_CMD_MEMORY  0x0002
#define PCI_CMD_MASTER  0x0004
#define PCI_CMD_SPECIAL 0x0008
#define PCI_CMD_MWI     0x0010
#define PCI_CMD_VGAPAL  0x0020
#define PCI_CMD_PERR    0x0040
#define PCI_CMD_STEP    0x0080
#define PCI_CMD_SERR    0x0100
#define PCI_CMD_FASTB2B 0x0200

#define PCI_STA_CAP     0x0010
#define PCI_STA_66MHZ   0x0020
#define PCI_STA_FASTB2B 0x0080
#define PCI_STA_PERR    0x0100
#define PCI_STA_DEVSEL  0x0600
#define PCI_STA_DEVSEL_FAST   0x0000
#define PCI_STA_DEVSEL_MEDIUM 0x0200
#define PCI_STA_DEVSEL_SLOW   0x0400
#define PCI_STA_TABT_TGT 0x0800
#define PCI_STA_TABT_MTR 0x1000
#define PCI_STA_MABT_MTR 0x2000
#define PCI_STA_SERR     0x4000
#define PCI_STA_PARITY   0x8000

#define  PCI_BASE_ADDRESS_SPACE	0x01	/* 0 = memory, 1 = I/O */
#define  PCI_BASE_ADDRESS_SPACE_IO 0x01
#define  PCI_BASE_ADDRESS_SPACE_MEMORY 0x00
#define  PCI_BASE_ADDRESS_MEM_TYPE_MASK 0x06
#define  PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
#define  PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M [obsolete] */
#define  PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
#define  PCI_BASE_ADDRESS_MEM_PREFETCH	0x08	/* prefetchable? */
#define  PCI_BASE_ADDRESS_MEM_MASK	(~0x0fU)
#define  PCI_BASE_ADDRESS_IO_MASK	(~0x03U)
/* bit 1 is reserved if address_space = 1 */

#define PCI_BAR_IS_IO(a) (((a) & 3) == 1)
#define PCI_BAR_IS_MEM(a) (((a) & 3) == 0) /* 32-bit or 64-bit only */
#define PCI_BAR_IS_MEM20(a) (((a) & 7) == 2)
#define PCI_BAR_IS_MEM64(a) (((a) & 7) == 4)
#define PCI_BAR_IS_PREFETCHABLE(a) (((a) & PCI_BASE_ADDRESS_MEM_PREFETCH) != 0)

#define PCI_BAR_IO_ADDRESS(a) ((a) & PCI_BASE_ADDRESS_IO_MASK)
#define PCI_BAR_MEM_ADDRESS(a) ((a) & PCI_BASE_ADDRESS_MEM_MASK)
#define PCI_BAR_ROM_ADDRESS(a) ((a) & PCI_ROM_ADDR_MASK)

#define PCI_ROM_ADDR_ENABLE 0x00000001
#define PCI_ROM_ADDR_MASK   0xfffff800

#define PCI_BASE_CLASS_OLD        0x00
#define PCI_BASE_CLASS_STORAGE    0x01
#define PCI_BASE_CLASS_NETWORK    0x02
#define PCI_BASE_CLASS_DISPLAY    0x03
#define PCI_BASE_CLASS_MULTIMEDIA 0x04
#define PCI_BASE_CLASS_MEMORY     0x05
#define PCI_BASE_CLASS_BRIDGE     0x06
#define PCI_BASE_CLASS_COMMS      0x07
#define PCI_BASE_CLASS_SYSTEM     0x08
#define PCI_BASE_CLASS_INPUT      0x09
#define PCI_BASE_CLASS_DOCKING    0x0A
#define PCI_BASE_CLASS_CPU        0x0B
#define PCI_BASE_CLASS_SERIAL     0x0C
#define PCI_BASE_CLASS_WIRELESS   0x0D
#define PCI_BASE_CLASS_IIO        0x0E
#define PCI_BASE_CLASS_SATELLITE  0x0F
#define PCI_BASE_CLASS_ENCRYPT    0x10
#define PCI_BASE_CLASS_DATA       0x11
#define PCI_BASE_CLASS_OTHER      0xFF

#define PCI_CLASS_BRIDGE_HOST 0x0600
#define PCI_CLASS_BRIDGE_ISA  0x0601
#define PCI_CLASS_BRIDGE_EISA 0x0602
#define PCI_CLASS_BRIDGE_MCA  0x0603
#define PCI_CLASS_BRIDGE_PCI  0x0604
#define PCI_CLASS_BRIDGE_PCCARD 0x0605
#define PCI_CLASS_BRIDGE_NUBUS 0x0606
#define PCI_CLASS_BRIDGE_CARDBUS 0x0607
#define PCI_CLASS_BRIDGE_RACEWAY 0x0608
#define PCI_CLASS_BRIDGE_OTHER 0x0680

#define PCI_CAP_MSI 5

#define PCI_CAP_ID    0x00
#define PCI_CAP_NEXT  0x01

#define PCI_MSI_CTRL  0x02
#define PCI_MSI_ADDR  0x04
#define PCI_MSI_DATA32 0x08
#define PCI_MSI_DATA64 0x0C

#define PCI_MSI_64BIT 0x80
#define PCI_MSI_MMENA 0x70
#define PCI_MSI_MMENA_SHIFT 4
#define PCI_MSI_MMCAP 0x0E
#define PCI_MSI_MMCAP_SHIFT 1
#define PCI_MSI_ENABLE 0x01

/* Bridge configuration space header layout (type 1) */

/*      PCI_BASE_ADDRESS_0 0x10 */
/*      PCI_BASE_ADDRESS_1 0x14 */
#define PCI_PRIMARY_BUS 0x18
#define PCI_SECONDARY_BUS 0x19
#define PCI_SUBORDINATE_BUS 0x1A
#define PCI_SECONDARY_LATENCY 0x1B
#define PCI_IO_BASE 0x1C
#define PCI_IO_LIMIT 0x1D
#define PCI_SECONDARY_STATUS 0x1E
#define PCI_MEMORY_BASE 0x20
#define PCI_MEMORY_LIMIT 0x22
#define PCI_PREFETCHABLE_BASE 0x24
#define PCI_PREFETCHABLE_LIMIT 0x26
#define PCI_PREFETCHABLE_BASE_UPPER 0x28
#define PCI_PREFETCHABLE_LIMIT_UPPER 0x2C
#define PCI_IO_BASE_UPPER 0x30
#define PCI_IO_LIMIT_UPPER 0x32
/*      PCI_CAP_PTR 0x34 */
#define PCI_BRIDGE_ROM_ADDR 0x38
/*      PCI_INT_LINE  0x3C */
/*      PCI_INT_PIN   0x3D */
#define PCI_BRIDGE_CONTROL 0x3E

#define PCI_BCR_PERR    0x0001
#define PCI_BCR_SERR    0x0002
#define PCI_BCR_ISA     0x0004
#define PCI_BCR_VGA     0x0008
#define PCI_BCR_MABT    0x0020
#define PCI_BCR_RST     0x0040
#define PCI_BCR_FASTB2B 0x0080
#define PCI_BCR_PRIMARY_DISCARD 0x0100
#define PCI_BCR_SECONDARY_DISCARD 0x0200
#define PCI_BCR_DISCARD_STATUS  0x0400
#define PCI_BCR_DISCARD_SERR    0x0800
@


1.4
log
@Split USB and PCI parts of HAL into hardware-specific and generic parts.
The generic parts are included by other HALs.

Version 0.18. Tagged as 'Tungsten-0_18'
@
text
@d71 2
d75 1
@


1.3
log
@First venture into the world of message signalled interrupts (s.MSI).
High speed RAM clear added using AAU in the XScale.
Tighten up check on RAM modules to reject some 4 bit wide devices.
Fix for CMOS protect link being ignored.
Add table returned by ReadPhysicalMemory.
New poke to move sound DMA into the top half of physical memory.
PCI rewrite.

Version 0.14. Tagged as 'Tungsten-0_14'
@
text
@d15 41
a55 1
typedef struct pci_dev pci_dev;
d72 7
@


1.2
log
@Kevin's new PCI enumeration C.
Kevin's UART control for DualSerial to talk to.
Completion of flash recovery stuff - it now flashes the floppy drive
light appropriately then requests a new OS image down the serial port
but is careful never to erase itself.To allow this has required some
shuffling to ensure the first 8k of binary is fixed and makes no
external calls - "s.Top" arranges this and effectively moves the
HAL up 8k in ROM.

Version 0.13. Tagged as 'Tungsten-0_13'
@
text
@d15 2
d31 2
d159 17
@


1.1
log
@Initial check-in.

Version 0.01. Tagged as 'Tungsten-0_01'
@
text
@d36 2
d111 10
@


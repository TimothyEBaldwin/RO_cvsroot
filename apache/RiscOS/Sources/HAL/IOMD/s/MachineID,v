head	1.3;
access;
symbols
	IOMD-0_36:1.3
	SMP:1.3.0.2
	SMP_bp:1.3
	IOMD-0_35:1.3
	IOMD-0_34:1.3
	IOMD-0_33:1.3
	IOMD-0_32:1.3
	IOMD-0_31:1.3
	IOMD-0_30:1.3
	IOMD-0_29:1.3
	IOMD-0_28:1.3
	IOMD-0_27:1.3
	IOMD-0_26:1.3
	IOMD-0_25:1.3
	IOMD-0_24:1.3
	IOMD-0_23:1.3
	IOMD-0_22:1.3
	IOMD-0_20:1.3
	IOMD-0_19:1.3
	IOMD-0_18:1.3
	IOMD-0_17:1.3
	IOMD-0_16:1.3
	IOMD-0_15:1.3
	IOMD-0_14:1.3
	IOMD-0_13:1.3
	IOMD-0_12:1.3
	IOMD-0_11:1.2
	IOMD-0_10:1.2
	IOMD-0_09:1.2
	IOMD-0_08:1.2
	IOMD-0_07:1.2
	IOMD-0_06:1.2
	IOMD-0_05:1.2
	IOMD-0_04:1.2
	IOMD-0_03:1.2
	IOMD-0_02:1.2
	HAL_merge:1.1.2.2
	IOMD-0_01:1.2
	Kernel-5_35-4_79_2_59:1.1.2.2
	Kernel-5_35-4_79_2_58:1.1.2.2
	Kernel-5_35-4_79_2_57:1.1.2.2
	Kernel-5_35-4_79_2_56:1.1.2.2
	Kernel-5_35-4_79_2_55:1.1.2.2
	Kernel-5_35-4_79_2_54:1.1.2.2
	Kernel-5_35-4_79_2_53:1.1.2.2
	Kernel-5_35-4_79_2_52:1.1.2.2
	Kernel-5_35-4_79_2_51:1.1.2.2
	Kernel-5_35-4_79_2_50:1.1.2.2
	Kernel-5_35-4_79_2_49:1.1.2.2
	Kernel-5_35-4_79_2_48:1.1.2.2
	Kernel-5_35-4_79_2_47:1.1.2.2
	Kernel-5_35-4_79_2_46:1.1.2.2
	Kernel-5_35-4_79_2_45:1.1.2.2
	Kernel-5_35-4_79_2_44:1.1.2.2
	MSI_Demo_merge:1.1.2.2
	Kernel-5_35-4_79_2_25_2_2:1.1.2.2
	Kernel-5_35-4_79_2_43:1.1.2.2
	Kernel-5_35-4_79_2_42:1.1.2.2
	Kernel-5_35-4_79_2_41:1.1.2.2
	Kernel-5_35-4_79_2_40:1.1.2.2
	Kernel-5_35-4_79_2_39:1.1.2.2
	Kernel-5_35-4_79_2_38:1.1.2.2
	Kernel-5_35-4_79_2_37:1.1.2.2
	Kernel-5_35-4_79_2_36:1.1.2.2
	Kernel-5_35-4_79_2_35:1.1.2.2
	Kernel-5_35-4_79_2_34:1.1.2.2
	Kernel-5_35-4_79_2_33:1.1.2.2
	Kernel-5_35-4_79_2_32:1.1.2.2
	Kernel-5_35-4_79_2_25_2_1:1.1.2.2
	MSI_Demo:1.1.2.2.0.2
	Kernel-5_35-4_79_2_31:1.1.2.2
	Kernel-5_35-4_79_2_30:1.1.2.2
	Kernel-5_35-4_79_2_29:1.1.2.2
	Kernel-5_35-4_79_2_28:1.1.2.2
	Kernel-5_35-4_79_2_27:1.1.2.2
	Kernel-5_35-4_79_2_26:1.1.2.2
	Kernel-5_35-4_79_2_25:1.1.2.2
	Kernel-5_35-4_79_2_24:1.1.2.2
	Kernel-5_35-4_79_2_23:1.1.2.2
	Kernel-5_35-4_79_2_22:1.1.2.2
	Kernel-5_35-4_79_2_21:1.1.2.2
	Kernel-5_35-4_79_2_20:1.1.2.2
	Kernel-5_35-4_79_2_19:1.1.2.2
	Kernel-5_35-4_79_2_18:1.1.2.2
	Kernel-5_35-4_79_2_17:1.1.2.2
	Kernel-5_35-4_79_2_16:1.1.2.2
	Kernel-5_35-4_79_2_15:1.1.2.2
	Kernel-5_35-4_79_2_14:1.1.2.2
	Kernel-5_35-4_79_2_13:1.1.2.2
	Kernel-5_35-4_79_2_12:1.1.2.2
	Kernel-5_35-4_79_2_11:1.1.2.2
	Kernel-5_35-4_79_2_10:1.1.2.2
	Kernel-5_35-4_79_2_9:1.1.2.2
	Kernel-5_35-4_79_2_8:1.1.2.2
	Kernel-5_35-4_79_2_7:1.1.2.1
	Kernel-5_35-4_79_2_6:1.1.2.1
	Kernel-5_35-4_79_2_5:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2012.06.09.11.29.48;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	QBFdo1jqgrSEA18w;

1.2
date	2008.12.22.00.15.18;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.05.13.54.49;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.10.05.13.54.49;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2000.10.05.16.37.33;	author mstephen;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Fix to HAL_MachineID
In transplanting the unique id chip bit basher, the routine carefully preserves the (write only) IOControl register in IOMD, but unfortunately uses a softcopy of 0 since that's never set. Since the I2C startup happens first the ID line is low pretty quickly after startup, therefore the ID chip reset doesn't work (needs a H-L-H transition) and so no unique ID is retrieved.

hdr.StaticWS: define symbol for Medusa.
s.Boot: once some workspace is available, ensure the softcopy matches the hardware.
s.MachineID: trim out the CheckCRC function since the Kernel does this, allows the error exit to be a bit more simple too.
s.Top: improve commenting of startup sequence, and get some consistency on IOC/IOMD, since this doesn't run on IOC. Move the default podule setup into the common setup.

Inspected on a scope, pin 2 of the DS2401 wiggles appropriately and a valid looking MAC address is available from OS_ReadSysInfo 4.

Version 0.12. Tagged as 'IOMD-0_12'
@
text
@; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO
        GET     Hdr:Proc

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  HAL_MachineID

        IMPORT  HAL_TimerPeriod
        IMPORT  HAL_TimerSetPeriod

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ReadUniqueID - Read unique machine ID
;
; 10-Dec-93  BCockburn  Modified to leave raw 64 bit ID from chip in RawMachineID

Tsyc    *       5       ; time between frames - minimum of 1탎, so give it a bit more
Trstl   *       500     ; time reset pulse held low - minimum of 480탎, so give it a bit more
Trsth   *       500     ; time reset pulse held high - minimum of 480탎, so give it a bit more
Tlow0   *       80      ; time for write0 low - min 60탎, max 120탎
Tlow1   *       5       ; time for write1 low - min 1탎, max 15탎
Tslot   *       90      ; time for total read/write slot - min 60탎, max 120탎
Trdlow  *       5       ; time for read slot low before release - min 1탎, max 15탎
Trddat  *       3       ; time after read slot high before read it

        ASSERT  Tslot-Tlow0 > Tsyc
        ASSERT  Trdlow+Trddat < 15

; Macro to set wire to a given state, and optionally count transitions (starting at low) while waiting for a given time

        MACRO
        SetWire $hilo, $time, $monstate, $count
        LCLS    reg
 [ "$hilo"="LOW"
reg     SETS    "r4"
 |
        ASSERT  "$hilo"="HIGH"
reg     SETS    "r5"
 ]
 [ ($time) = 0
        STRB    $reg, [r1, #IOCControl]         ; set appropriate level on line
 |
        ASSERT  ($time) < 32768
        MOV     r12, #(($time)*2):AND:&FF
        STRB    r12, [r1, #Timer0LL]            ; program low latch
        MOV     r12, #(($time)*2):SHR:8
        STRB    r12, [r1, #Timer0LH]            ; program high latch
        STRB    $reg, [r1, #IOCControl]         ; set appropriate level on line
        STRB    r12, [r1, #Timer0GO]            ; and start timer
        LDRB    r12, [r1, #IOCIRQSTAA]          ; dummy instruction to avoid bug in IOC
        LDRB    r12, [r1, #IOCIRQSTAA]          ; dummy instruction (repeated for FE)
        STRB    r11, [r1, #IOCIRQCLRA]          ; immediately clear IRQ bit
  [ "$monstate"<>""
        MOV     $monstate, #0
  ]
  [ "$count"<>""
        MOV     $count, #0
  ]
10
        LDRB    r12, [r1, #IOCIRQSTAA]
        TST     r12, r11
  [ "$count"<>""
        ADDEQ   $count, $count, #1
  ]
  [ "$monstate"=""
        BEQ     %BT10                                   ; not timed out, so just loop
  |
        BNE     %FT30                                   ; timed out
        LDRB    r12, [r1, #IOCControl]
        TST     r12, #IOEB_unique_machine_ID_bit
        BEQ     %BT10                                   ; if still low then loop to 10

        ADD     $monstate, $monstate, #1                ; increment number of transitions
20
        LDRB    r12, [r1, #IOCIRQSTAA]
        TST     r12, r11
   [ "$count"<>""
        ADDEQ   $count, $count, #1
   ]
        BNE     %FT30                                   ; timed out
        LDRB    r12, [r1, #IOCControl]
        TST     r12, #IOEB_unique_machine_ID_bit
        BNE     %BT20                                   ; if still high then loop to 20
        ADD     $monstate, $monstate, #1                ; increment number of transitions
        B       %BT10
30
  ]
 ]
        MEND

HAL_MachineID
        Entry   "r4-r11", 8
        MOV     r0, #0
        LDR     r1, IOMD_Address

        STR     r0, [sp, #0]                            ; indicate no ID in case of error exit
        STR     r0, [sp, #4]                           

        MRS     r8, CPSR                                ; remember PSR
        ORR     r3, r8, #I32_bit+F32_bit
        MSR     CPSR_c, r3                              ; FIQs and IRQs off

        LDRB    r3, IOCRSoftCopy
        BIC     r4, r3, #IOEB_unique_machine_ID_bit     ; r4 is value to pull ID line low
        ORR     r5, r3, #IOEB_unique_machine_ID_bit     ; r5 is value to pull ID line high
        MOV     r11, #timer0_bit
        BL      SendResetPulse
        BVS     ResetFailed
        BL      SendCommandWord

        MOV     r7, #0                                  ; no. of bytes to store = 8 bits type + 48 bits ID + 8 bits checksum
10
        BL      GetAByte
        STRB    r6, [sp, r7]
        ADD     r7, r7, #1
        CMP     r7, #8
        BNE     %BT10

ResetFailed
        BL      RestoreIOCState
        LDMIA   sp, {r0, r1}
        EXIT

RestoreIOCState Entry
        STRB    r3, [r1, #IOCControl]                   ; put back old value
        MOV     r0, #0
        BL      HAL_TimerPeriod
        MOV     r1, r0
        MOV     r0, #0
        BL      HAL_TimerSetPeriod
        MSR     CPSR_c, r8                              ; restore old interrupt state
        EXIT

SendResetPulse ROUT
        SetWire HIGH, Tsyc
        SetWire LOW, Trstl,,r6
        SetWire HIGH, Trsth,r10
        TEQ     r6, #0
      [ {FALSE} ; only for debugging
        ADREQ   r0, IOCBugHappenedError
      ]
        BEQ     %FT05
        CMP     r10, #3                                 ; H-L-H is ok
        MOVEQ   pc, lr                                  ; V clear
      [ {FALSE} ; only for debugging
        ADRHI   r0, TooManyTransitionsError             ; H-L-H-L...
        CMP     r10, #2
        ADREQ   r0, NeverWentHighAgainError             ; H-L
        CMP     r10, #1
        ADREQ   r0, NeverWentLowError                   ; H
        ADRCC   r0, NeverWentHighError                  ; stayed low permanently even though we released it
      ]
05
        SETV
        MOV     pc, lr

      [ {FALSE} ; only for debugging
NeverWentHighError
        =       "Never went high", 0
NeverWentLowError
        =       "Never went low", 0
NeverWentHighAgainError
        =       "Never went high again", 0
TooManyTransitionsError
        =       "Too many transitions", 0
IOCBugHappenedError
        =       "IOC bug happened", 0
        ALIGN
      ]

SendCommandWord ROUT
        CLRV
        LDR     r6, =&10F               ; &0F is command word
10
        MOVS    r6, r6, LSR #1
        MOVEQ   pc, lr
        BCS     SendOne
        SetWire LOW, Tlow0
        SetWire HIGH, Tslot-Tlow0
        B       %BT10

SendOne
        SetWire LOW, Tlow1
        SetWire HIGH, Tslot-Tlow1
        B       %BT10

GetAByte ROUT
        MOV     r6, #&80
10
        SetWire LOW, Trdlow
        SetWire HIGH, Trddat
        LDRB    r10, [r1, #IOCControl]
        SetWire HIGH, Tslot-Trdlow-Trddat
        MOVS    r10, r10, LSR #IOEB_ID_bit_number+1    ; move bit into carry
        MOVS    r6, r6, RRX
        BCC     %BT10
        MOV     r6, r6, LSR #24
        MOV     pc, lr

        END
@


1.2
log
@Merged IOMD HAL to trunk.

Version 0.01. Tagged as 'IOMD-0_01'
@
text
@a40 2
defaultlatch *  20000-1 ; TMD 21-May-93: "-1" correction applied

d116 1
a116 1
        Entry "r4-r11",8
d119 5
a123 1
        MRS     r8, CPSR                                ; remember PSR in r8
d126 1
d143 1
a144 3
        MOV     r1, sp
        BL      CheckCRC
        BVS     IDError
a147 7
ResetFailed
        BL      RestoreIOCState
IDError
        MOV     r0, #0
        MOV     r1, #0                                  ; indicate no ID by putting zero here
        EXIT

d163 3
a165 1
;        ADREQ   r0, IOCBugHappenedError
d169 8
a176 6
;        ADRHI   r0, TooManyTransitionsError             ; H-L-H-L...
;        CMP     r10, #2
;        ADREQ   r0, NeverWentHighAgainError             ; H-L
;        CMP     r10, #1
;        ADREQ   r0, NeverWentLowError                   ; H
;        ADRCC   r0, NeverWentHighError                  ; stayed low permanently even though we released it
d181 1
a181 1
 [ {FALSE} ; only for debugging
d193 1
a193 1
 ]
a223 19
CheckCRC ROUT
        MOV     r2, #0
        MOV     r3, #7                          ; number of bytes to do
10
        LDRB    r4, [r1], #1
        EOR     r2, r2, r4
        MOV     r4, #8                          ; number of bits to do
20
        MOVS    r2, r2, LSR #1                  ; shift bit out into carry
        EORCS   r2, r2, #&8C                    ; feedback carry into other bits
        SUBS    r4, r4, #1                      ; one less bit to do
        BNE     %BT20                           ; loop until done whole byte
        SUBS    r3, r3, #1                      ; one less byte to do
        BNE     %BT10                           ; loop until done all 7 bytes
        LDRB    r4, [r1], #1                    ; read CRC
        CMP     r4, r2                          ; if correct
        MOVEQ   pc, lr                          ; exit (V clear)
        RETURNVS                                ; else exit indicating error

@


1.1
log
@file MachineID was initially added on branch HAL.
@
text
@d1 245
@


1.1.2.1
log
@More HAL work. IOMD HAL fleshed out somewhat - system gets most of the way
through initialisation.

Version 5.35, 4.79.2.5. Tagged as 'Kernel-5_35-4_79_2_5'
@
text
@a0 245
; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO
        GET     Hdr:Proc

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  HAL_MachineID

        IMPORT  HAL_TimerPeriod
        IMPORT  HAL_TimerSetPeriod

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ReadUniqueID - Read unique machine ID
;
; 10-Dec-93  BCockburn  Modified to leave raw 64 bit ID from chip in RawMachineID

defaultlatch *  20000-1 ; TMD 21-May-93: "-1" correction applied

Tsyc    *       5       ; time between frames - minimum of 1탎, so give it a bit more
Trstl   *       500     ; time reset pulse held low - minimum of 480탎, so give it a bit more
Trsth   *       500     ; time reset pulse held high - minimum of 480탎, so give it a bit more
Tlow0   *       80      ; time for write0 low - min 60탎, max 120탎
Tlow1   *       5       ; time for write1 low - min 1탎, max 15탎
Tslot   *       90      ; time for total read/write slot - min 60탎, max 120탎
Trdlow  *       5       ; time for read slot low before release - min 1탎, max 15탎
Trddat  *       3       ; time after read slot high before read it

        ASSERT  Tslot-Tlow0 > Tsyc
        ASSERT  Trdlow+Trddat < 15

; Macro to set wire to a given state, and optionally count transitions (starting at low) while waiting for a given time

        MACRO
        SetWire $hilo, $time, $monstate, $count
        LCLS    reg
 [ "$hilo"="LOW"
reg     SETS    "r4"
 |
        ASSERT  "$hilo"="HIGH"
reg     SETS    "r5"
 ]
 [ ($time) = 0
        STRB    $reg, [r1, #IOCControl]         ; set appropriate level on line
 |
        ASSERT  ($time) < 32768
        MOV     r12, #(($time)*2):AND:&FF
        STRB    r12, [r1, #Timer0LL]            ; program low latch
        MOV     r12, #(($time)*2):SHR:8
        STRB    r12, [r1, #Timer0LH]            ; program high latch
        STRB    $reg, [r1, #IOCControl]         ; set appropriate level on line
        STRB    r12, [r1, #Timer0GO]            ; and start timer
        LDRB    r12, [r1, #IOCIRQSTAA]          ; dummy instruction to avoid bug in IOC
        LDRB    r12, [r1, #IOCIRQSTAA]          ; dummy instruction (repeated for FE)
        STRB    r11, [r1, #IOCIRQCLRA]          ; immediately clear IRQ bit
  [ "$monstate"<>""
        MOV     $monstate, #0
  ]
  [ "$count"<>""
        MOV     $count, #0
  ]
10
        LDRB    r12, [r1, #IOCIRQSTAA]
        TST     r12, r11
  [ "$count"<>""
        ADDEQ   $count, $count, #1
  ]
  [ "$monstate"=""
        BEQ     %BT10                                   ; not timed out, so just loop
  |
        BNE     %FT30                                   ; timed out
        LDRB    r12, [r1, #IOCControl]
        TST     r12, #IOEB_unique_machine_ID_bit
        BEQ     %BT10                                   ; if still low then loop to 10

        ADD     $monstate, $monstate, #1                ; increment number of transitions
20
        LDRB    r12, [r1, #IOCIRQSTAA]
        TST     r12, r11
   [ "$count"<>""
        ADDEQ   $count, $count, #1
   ]
        BNE     %FT30                                   ; timed out
        LDRB    r12, [r1, #IOCControl]
        TST     r12, #IOEB_unique_machine_ID_bit
        BNE     %BT20                                   ; if still high then loop to 20
        ADD     $monstate, $monstate, #1                ; increment number of transitions
        B       %BT10
30
  ]
 ]
        MEND

HAL_MachineID
        Entry "r4-r11",8
        MOV     r0, #0
        LDR     r1, IOMDa
        MRS     r8, CPSR                                ; remember PSR in r8
        ORR     r3, r8, #I32_bit+F32_bit
        MSR     CPSR_c, r3                              ; FIQs and IRQs off
        LDRB    r3, IOCRSoftCopy
        BIC     r4, r3, #IOEB_unique_machine_ID_bit     ; r4 is value to pull ID line low
        ORR     r5, r3, #IOEB_unique_machine_ID_bit     ; r5 is value to pull ID line high
        MOV     r11, #timer0_bit
        BL      SendResetPulse
        BVS     ResetFailed
        BL      SendCommandWord

        MOV     r7, #0                                  ; no. of bytes to store = 8 bits type + 48 bits ID + 8 bits checksum
10
        BL      GetAByte
        STRB    r6, [sp, r7]
        ADD     r7, r7, #1
        CMP     r7, #8
        BNE     %BT10

        BL      RestoreIOCState
        MOV     r1, sp
        BL      CheckCRC
        BVS     IDError
        LDMIA   sp, {r0, r1}
        EXIT

ResetFailed
        BL      RestoreIOCState
IDError
        MOV     r0, #0
        MOV     r1, #0                                  ; indicate no ID by putting zero here
        EXIT

RestoreIOCState Entry
        STRB    r3, [r1, #IOCControl]                   ; put back old value
        MOV     r0, #0
        BL      HAL_TimerPeriod
        MOV     r1, r0
        MOV     r0, #0
        BL      HAL_TimerSetPeriod
        MSR     CPSR_c, r8                              ; restore old interrupt state
        EXIT

SendResetPulse ROUT
        SetWire HIGH, Tsyc
        SetWire LOW, Trstl,,r6
        SetWire HIGH, Trsth,r10
        TEQ     r6, #0
;        ADREQ   r0, IOCBugHappenedError
        BEQ     %FT05
        CMP     r10, #3                                 ; H-L-H is ok
        MOVEQ   pc, lr                                  ; V clear
;        ADRHI   r0, TooManyTransitionsError             ; H-L-H-L...
;        CMP     r10, #2
;        ADREQ   r0, NeverWentHighAgainError             ; H-L
;        CMP     r10, #1
;        ADREQ   r0, NeverWentLowError                   ; H
;        ADRCC   r0, NeverWentHighError                  ; stayed low permanently even though we released it
05
        SETV
        MOV     pc, lr

 [ {FALSE} ; only for debugging
NeverWentHighError
        =       "Never went high", 0
NeverWentLowError
        =       "Never went low", 0
NeverWentHighAgainError
        =       "Never went high again", 0
TooManyTransitionsError
        =       "Too many transitions", 0
IOCBugHappenedError
        =       "IOC bug happened", 0
        ALIGN
 ]

SendCommandWord ROUT
        CLRV
        LDR     r6, =&10F               ; &0F is command word
10
        MOVS    r6, r6, LSR #1
        MOVEQ   pc, lr
        BCS     SendOne
        SetWire LOW, Tlow0
        SetWire HIGH, Tslot-Tlow0
        B       %BT10

SendOne
        SetWire LOW, Tlow1
        SetWire HIGH, Tslot-Tlow1
        B       %BT10

GetAByte ROUT
        MOV     r6, #&80
10
        SetWire LOW, Trdlow
        SetWire HIGH, Trddat
        LDRB    r10, [r1, #IOCControl]
        SetWire HIGH, Tslot-Trdlow-Trddat
        MOVS    r10, r10, LSR #IOEB_ID_bit_number+1    ; move bit into carry
        MOVS    r6, r6, RRX
        BCC     %BT10
        MOV     r6, r6, LSR #24
        MOV     pc, lr

CheckCRC ROUT
        MOV     r2, #0
        MOV     r3, #7                          ; number of bytes to do
10
        LDRB    r4, [r1], #1
        EOR     r2, r2, r4
        MOV     r4, #8                          ; number of bits to do
20
        MOVS    r2, r2, LSR #1                  ; shift bit out into carry
        EORCS   r2, r2, #&8C                    ; feedback carry into other bits
        SUBS    r4, r4, #1                      ; one less bit to do
        BNE     %BT20                           ; loop until done whole byte
        SUBS    r3, r3, #1                      ; one less byte to do
        BNE     %BT10                           ; loop until done all 7 bytes
        LDRB    r4, [r1], #1                    ; read CRC
        CMP     r4, r2                          ; if correct
        MOVEQ   pc, lr                          ; exit (V clear)
        RETURNVS                                ; else exit indicating error

        END
@


1.1.2.2
log
@first attemp at mjs video code in real HAL
@
text
@d120 1
a120 1
        LDR     r1, IOMD_Address
@



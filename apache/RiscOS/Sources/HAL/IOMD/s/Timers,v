head	1.3;
access;
symbols
	IOMD-0_36:1.3
	SMP:1.3.0.2
	SMP_bp:1.3
	IOMD-0_35:1.3
	IOMD-0_34:1.3
	IOMD-0_33:1.3
	IOMD-0_32:1.3
	IOMD-0_31:1.3
	IOMD-0_30:1.3
	IOMD-0_29:1.3
	IOMD-0_28:1.3
	IOMD-0_27:1.2
	IOMD-0_26:1.2
	IOMD-0_25:1.2
	IOMD-0_24:1.2
	IOMD-0_23:1.2
	IOMD-0_22:1.2
	IOMD-0_20:1.2
	IOMD-0_19:1.2
	IOMD-0_18:1.2
	IOMD-0_17:1.2
	IOMD-0_16:1.2
	IOMD-0_15:1.2
	IOMD-0_14:1.2
	IOMD-0_13:1.2
	IOMD-0_12:1.2
	IOMD-0_11:1.2
	IOMD-0_10:1.2
	IOMD-0_09:1.2
	IOMD-0_08:1.2
	IOMD-0_07:1.2
	IOMD-0_06:1.2
	IOMD-0_05:1.2
	IOMD-0_04:1.2
	IOMD-0_03:1.2
	IOMD-0_02:1.2
	HAL_merge:1.1.2.2
	IOMD-0_01:1.2
	Kernel-5_35-4_79_2_59:1.1.2.2
	Kernel-5_35-4_79_2_58:1.1.2.2
	Kernel-5_35-4_79_2_57:1.1.2.2
	Kernel-5_35-4_79_2_56:1.1.2.2
	Kernel-5_35-4_79_2_55:1.1.2.2
	Kernel-5_35-4_79_2_54:1.1.2.2
	Kernel-5_35-4_79_2_53:1.1.2.2
	Kernel-5_35-4_79_2_52:1.1.2.2
	Kernel-5_35-4_79_2_51:1.1.2.2
	Kernel-5_35-4_79_2_50:1.1.2.2
	Kernel-5_35-4_79_2_49:1.1.2.2
	Kernel-5_35-4_79_2_48:1.1.2.2
	Kernel-5_35-4_79_2_47:1.1.2.2
	Kernel-5_35-4_79_2_46:1.1.2.2
	Kernel-5_35-4_79_2_45:1.1.2.2
	Kernel-5_35-4_79_2_44:1.1.2.2
	MSI_Demo_merge:1.1.2.2
	Kernel-5_35-4_79_2_25_2_2:1.1.2.2
	Kernel-5_35-4_79_2_43:1.1.2.2
	Kernel-5_35-4_79_2_42:1.1.2.2
	Kernel-5_35-4_79_2_41:1.1.2.2
	Kernel-5_35-4_79_2_40:1.1.2.2
	Kernel-5_35-4_79_2_39:1.1.2.2
	Kernel-5_35-4_79_2_38:1.1.2.2
	Kernel-5_35-4_79_2_37:1.1.2.2
	Kernel-5_35-4_79_2_36:1.1.2.2
	Kernel-5_35-4_79_2_35:1.1.2.2
	Kernel-5_35-4_79_2_34:1.1.2.2
	Kernel-5_35-4_79_2_33:1.1.2.2
	Kernel-5_35-4_79_2_32:1.1.2.2
	Kernel-5_35-4_79_2_25_2_1:1.1.2.2
	MSI_Demo:1.1.2.2.0.2
	Kernel-5_35-4_79_2_31:1.1.2.2
	Kernel-5_35-4_79_2_30:1.1.2.2
	Kernel-5_35-4_79_2_29:1.1.2.2
	Kernel-5_35-4_79_2_28:1.1.2.2
	Kernel-5_35-4_79_2_27:1.1.2.2
	Kernel-5_35-4_79_2_26:1.1.2.2
	Kernel-5_35-4_79_2_25:1.1.2.2
	Kernel-5_35-4_79_2_24:1.1.2.2
	Kernel-5_35-4_79_2_23:1.1.2.2
	Kernel-5_35-4_79_2_22:1.1.2.2
	Kernel-5_35-4_79_2_21:1.1.2.2
	Kernel-5_35-4_79_2_20:1.1.2.2
	Kernel-5_35-4_79_2_19:1.1.2.2
	Kernel-5_35-4_79_2_18:1.1.2.2
	Kernel-5_35-4_79_2_17:1.1.2.2
	Kernel-5_35-4_79_2_16:1.1.2.2
	Kernel-5_35-4_79_2_15:1.1.2.2
	Kernel-5_35-4_79_2_14:1.1.2.2
	Kernel-5_35-4_79_2_13:1.1.2.2
	Kernel-5_35-4_79_2_12:1.1.2.2
	Kernel-5_35-4_79_2_11:1.1.2.2
	Kernel-5_35-4_79_2_10:1.1.2.2
	Kernel-5_35-4_79_2_9:1.1.2.2
	Kernel-5_35-4_79_2_8:1.1.2.2
	Kernel-5_35-4_79_2_7:1.1.2.1
	Kernel-5_35-4_79_2_6:1.1.2.1
	Kernel-5_35-4_79_2_5:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2013.05.26.16.57.14;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	f14o5MDou3Mo7aRw;

1.2
date	2008.12.22.00.15.18;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.05.13.54.49;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.10.05.13.54.49;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2000.10.05.16.37.33;	author mstephen;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Magic number replaced with symbollic name
Not tagged
@
text
@; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries
        GET     Hdr:DevNos

        GET     hdr.StaticWS

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  HAL_Timers
        EXPORT  HAL_TimerDevice
        EXPORT  HAL_TimerGranularity
        EXPORT  HAL_TimerMaxPeriod
        EXPORT  HAL_TimerSetPeriod
        EXPORT  HAL_TimerPeriod
        EXPORT  HAL_TimerReadCountdown

        EXPORT  HAL_CounterRate
        EXPORT  HAL_CounterPeriod
        EXPORT  HAL_CounterRead
        EXPORT  HAL_CounterDelay

HAL_Timers
        MOV     a1, #2                  ; 2 timers
        MOV     pc, lr

HAL_TimerDevice
        ASSERT  IOMD_Timer1_DevNo = IOMD_Timer0_DevNo + 1
        ADD     a1, a1, #IOMD_Timer0_DevNo
        MOV     pc, lr

HAL_CounterRate
HAL_TimerGranularity
        LDR     a1, =2000000            ; 2MHz
        MOV     pc, lr

HAL_TimerMaxPeriod
        MOV     a1, #&10000             ; 16-bit counter
        MOV     pc, lr

HAL_TimerSetPeriod
        LDR     a4, IOMD_Address
        SUB     a2, a2, #1              ; count down from period-1 (&FFFF if period 0)
        ASSERT  Timer1LL-Timer0LL = 16
        ADD     a4, a4, a1, LSL #4
        STRB    a2, [a4, #Timer0LL]
        MOV     a3, a2, LSR #8
        STRB    a3, [a4, #Timer0LH]
        STRB    a3, [a4, #Timer0GO]

        MOV     a2, a2, LSL #16         ; a2 = actual period programmed (1-&10000)
        MOV     a2, a2, LSR #16
        ADD     a2, a2, #1

        ADR     a4, TimerPeriods
        STR     a2, [a4, a1, LSL #2]

        MOV     pc, lr

HAL_TimerPeriod
        ADR     a4, TimerPeriods
        LDR     a1, [a4, a1, LSL #2]
        MOV     pc, lr

HAL_CounterRead
        MOV     a1, #0
        ; Fall through

HAL_TimerReadCountdown
        LDR     a4, IOMD_Address

        MRS     ip, CPSR                ; interrupts off for latching
        ORR     a2, ip, #I32_bit

        ASSERT  Timer1LL-Timer0LL = 16
        ADD     a4, a4, a1, LSL #4

        MSR     CPSR_c, a2
        STRB    a4, [a4, #Timer0LR]
        LDRB    a1, [a4, #Timer0CL]
        LDRB    a2, [a4, #Timer0CH]
        MSR     CPSR_c, ip

        ORR     a1, a1, a2, LSL #8
        MOV     pc, lr

HAL_CounterPeriod
        LDR     a1, TimerPeriods + 0
        MOV     pc, lr

; If they want n ticks, wait until we've seen n+1 transitions of the clock.
HAL_CounterDelay
        LDR     a4, IOMD_Address

        MOV     a1, a1, LSL #1          ; convert to 0.5us ticks

        STRB    a1, [a4, #Timer0LR]     ; read counter
        LDRB    a2, [a4, #Timer0CL]

10      STRB    a1, [a4, #Timer0LR]
        LDRB    a3, [a4, #Timer0CL]     ; read counter
        SUBS    ip, a2, a3              ; ip = difference in 0.5us ticks
        ADDLO   ip, a2, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        MOVLO   pc, lr
        STRB    a1, [a4, #Timer0LR]
        LDRB    a2, [a4, #Timer0CL]     ; read counter
        SUBS    ip, a3, a2              ; ip = difference in 0.5us ticks
        ADDLO   ip, a3, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        BHS     %BT10
        MOV     pc, lr

        END
@


1.2
log
@Merged IOMD HAL to trunk.

Version 0.01. Tagged as 'IOMD-0_01'
@
text
@d24 1
d48 2
a49 1
        ADD     a1, a1, #5              ; devices 5 and 6
@


1.1
log
@file Timers was initially added on branch HAL.
@
text
@d1 132
@


1.1.2.1
log
@More HAL work. IOMD HAL fleshed out somewhat - system gets most of the way
through initialisation.

Version 5.35, 4.79.2.5. Tagged as 'Kernel-5_35-4_79_2_5'
@
text
@a0 132
; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  HAL_Timers
        EXPORT  HAL_TimerDevice
        EXPORT  HAL_TimerGranularity
        EXPORT  HAL_TimerMaxPeriod
        EXPORT  HAL_TimerSetPeriod
        EXPORT  HAL_TimerPeriod
        EXPORT  HAL_TimerReadCountdown

        EXPORT  HAL_CounterRate
        EXPORT  HAL_CounterPeriod
        EXPORT  HAL_CounterRead
        EXPORT  HAL_CounterDelay

HAL_Timers
        MOV     a1, #2                  ; 2 timers
        MOV     pc, lr

HAL_TimerDevice
        ADD     a1, a1, #5              ; devices 5 and 6
        MOV     pc, lr

HAL_CounterRate
HAL_TimerGranularity
        LDR     a1, =2000000            ; 2MHz
        MOV     pc, lr

HAL_TimerMaxPeriod
        MOV     a1, #&10000             ; 16-bit counter
        MOV     pc, lr

HAL_TimerSetPeriod
        LDR     a4, IOMDa
        SUB     a2, a2, #1              ; count down from period-1 (&FFFF if period 0)
        ASSERT  Timer1LL-Timer0LL = 16
        ADD     a4, a4, a1, LSL #4
        STRB    a2, [a4, #Timer0LL]
        MOV     a3, a2, LSR #8
        STRB    a3, [a4, #Timer0LH]
        STRB    a3, [a4, #Timer0GO]

        MOV     a2, a2, LSL #16         ; a2 = actual period programmed (1-&10000)
        MOV     a2, a2, LSR #16
        ADD     a2, a2, #1

        ADR     a4, TimerPeriods
        STR     a2, [a4, a1, LSL #2]

        MOV     pc, lr

HAL_TimerPeriod
        ADR     a4, TimerPeriods
        LDR     a1, [a4, a1, LSL #2]
        MOV     pc, lr

HAL_CounterRead
        MOV     a1, #0
        ; Fall through

HAL_TimerReadCountdown
        LDR     a4, IOMDa

        MRS     ip, CPSR                ; interrupts off for latching
        ORR     a2, ip, #I32_bit

        ASSERT  Timer1LL-Timer0LL = 16
        ADD     a4, a4, a1, LSL #4

        MSR     CPSR_c, a2
        STRB    a4, [a4, #Timer0LR]
        LDRB    a1, [a4, #Timer0CL]
        LDRB    a2, [a4, #Timer0CH]
        MSR     CPSR_c, ip

        ORR     a1, a1, a2, LSL #8
        MOV     pc, lr

HAL_CounterPeriod
        LDR     a1, TimerPeriods + 0
        MOV     pc, lr

; If they want n ticks, wait until we've seen n+1 transitions of the clock.
HAL_CounterDelay
        LDR     a4, IOMDa

        MOV     a1, a1, LSL #1          ; convert to 0.5us ticks

        STRB    a1, [a4, #Timer0LR]     ; read counter
        LDRB    a2, [a4, #Timer0CL]

10      STRB    a1, [a4, #Timer0LR]
        LDRB    a3, [a4, #Timer0CL]     ; read counter
        SUBS    ip, a2, a3              ; ip = difference in 0.5us ticks
        ADDLO   ip, a2, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        MOVLO   pc, lr
        STRB    a1, [a4, #Timer0LR]
        LDRB    a2, [a4, #Timer0CL]     ; read counter
        SUBS    ip, a3, a2              ; ip = difference in 0.5us ticks
        ADDLO   ip, a3, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        BHS     %BT10
        MOV     pc, lr

        END
@


1.1.2.2
log
@first attemp at mjs video code in real HAL
@
text
@d60 1
a60 1
        LDR     a4, IOMD_Address
d88 1
a88 1
        LDR     a4, IOMD_Address
d111 1
a111 1
        LDR     a4, IOMD_Address
@



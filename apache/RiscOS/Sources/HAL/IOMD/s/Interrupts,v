head	1.8;
access;
symbols
	IOMD-0_36:1.8
	SMP:1.8.0.2
	SMP_bp:1.8
	IOMD-0_35:1.8
	IOMD-0_34:1.8
	IOMD-0_33:1.8
	IOMD-0_32:1.8
	IOMD-0_31:1.8
	IOMD-0_30:1.8
	IOMD-0_29:1.8
	IOMD-0_28:1.8
	IOMD-0_27:1.8
	IOMD-0_26:1.8
	IOMD-0_25:1.8
	IOMD-0_24:1.8
	IOMD-0_23:1.7
	IOMD-0_22:1.7
	IOMD-0_20:1.6
	IOMD-0_19:1.5
	IOMD-0_18:1.4
	IOMD-0_17:1.4
	IOMD-0_16:1.4
	IOMD-0_15:1.4
	IOMD-0_14:1.4
	IOMD-0_13:1.4
	IOMD-0_12:1.4
	IOMD-0_11:1.4
	IOMD-0_10:1.4
	IOMD-0_09:1.4
	IOMD-0_08:1.4
	IOMD-0_07:1.4
	IOMD-0_06:1.3
	IOMD-0_05:1.3
	IOMD-0_04:1.3
	IOMD-0_03:1.3
	IOMD-0_02:1.3
	HAL_merge:1.1.2.4
	IOMD-0_01:1.2
	Kernel-5_35-4_79_2_59:1.1.2.4
	Kernel-5_35-4_79_2_58:1.1.2.4
	Kernel-5_35-4_79_2_57:1.1.2.4
	Kernel-5_35-4_79_2_56:1.1.2.4
	Kernel-5_35-4_79_2_55:1.1.2.4
	Kernel-5_35-4_79_2_54:1.1.2.4
	Kernel-5_35-4_79_2_53:1.1.2.4
	Kernel-5_35-4_79_2_52:1.1.2.4
	Kernel-5_35-4_79_2_51:1.1.2.4
	Kernel-5_35-4_79_2_50:1.1.2.4
	Kernel-5_35-4_79_2_49:1.1.2.4
	Kernel-5_35-4_79_2_48:1.1.2.4
	Kernel-5_35-4_79_2_47:1.1.2.4
	Kernel-5_35-4_79_2_46:1.1.2.4
	Kernel-5_35-4_79_2_45:1.1.2.4
	Kernel-5_35-4_79_2_44:1.1.2.4
	MSI_Demo_merge:1.1.2.3
	Kernel-5_35-4_79_2_25_2_2:1.1.2.3
	Kernel-5_35-4_79_2_43:1.1.2.4
	Kernel-5_35-4_79_2_42:1.1.2.4
	Kernel-5_35-4_79_2_41:1.1.2.4
	Kernel-5_35-4_79_2_40:1.1.2.4
	Kernel-5_35-4_79_2_39:1.1.2.4
	Kernel-5_35-4_79_2_38:1.1.2.4
	Kernel-5_35-4_79_2_37:1.1.2.4
	Kernel-5_35-4_79_2_36:1.1.2.4
	Kernel-5_35-4_79_2_35:1.1.2.4
	Kernel-5_35-4_79_2_34:1.1.2.4
	Kernel-5_35-4_79_2_33:1.1.2.4
	Kernel-5_35-4_79_2_32:1.1.2.4
	Kernel-5_35-4_79_2_25_2_1:1.1.2.3
	MSI_Demo:1.1.2.3.0.2
	Kernel-5_35-4_79_2_31:1.1.2.4
	Kernel-5_35-4_79_2_30:1.1.2.4
	Kernel-5_35-4_79_2_29:1.1.2.3
	Kernel-5_35-4_79_2_28:1.1.2.3
	Kernel-5_35-4_79_2_27:1.1.2.3
	Kernel-5_35-4_79_2_26:1.1.2.3
	Kernel-5_35-4_79_2_25:1.1.2.3
	Kernel-5_35-4_79_2_24:1.1.2.3
	Kernel-5_35-4_79_2_23:1.1.2.3
	Kernel-5_35-4_79_2_22:1.1.2.3
	Kernel-5_35-4_79_2_21:1.1.2.3
	Kernel-5_35-4_79_2_20:1.1.2.3
	Kernel-5_35-4_79_2_19:1.1.2.3
	Kernel-5_35-4_79_2_18:1.1.2.3
	Kernel-5_35-4_79_2_17:1.1.2.3
	Kernel-5_35-4_79_2_16:1.1.2.3
	Kernel-5_35-4_79_2_15:1.1.2.3
	Kernel-5_35-4_79_2_14:1.1.2.3
	Kernel-5_35-4_79_2_13:1.1.2.3
	Kernel-5_35-4_79_2_12:1.1.2.3
	Kernel-5_35-4_79_2_11:1.1.2.3
	Kernel-5_35-4_79_2_10:1.1.2.3
	Kernel-5_35-4_79_2_9:1.1.2.3
	Kernel-5_35-4_79_2_8:1.1.2.3
	Kernel-5_35-4_79_2_7:1.1.2.2
	Kernel-5_35-4_79_2_6:1.1.2.1
	Kernel-5_35-4_79_2_5:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


1.8
date	2013.02.03.22.43.03;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	yButiU4P8gslDNCw;

1.7
date	2013.01.22.23.32.43;	author jlee;	state Exp;
branches;
next	1.6;
commitid	scjHrR0sFnviigBw;

1.6
date	2012.12.24.14.02.39;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	MJfUGj0f0YLt4uxw;

1.5
date	2012.10.20.18.14.23;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	z1ni8btRBpLpy9pw;

1.4
date	2010.12.02.20.28.07;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.22.01.41.45;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.22.00.15.18;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.05.13.54.49;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.10.05.13.54.49;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2000.10.05.16.20.00;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2000.10.05.16.37.33;	author mstephen;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.05.17.10.51.08;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Fix HAL_IRQSource to sign extend 'NoInterrupt' return value
The tables of priorities are looked up with LDRB, so the NoInterrupt case returns 0xFF not -1, leading to a branch through zero in the kernel's IRQ despatch.
Interrupts.s: Reordered the priority tables to be in the same order as the IRQ status registers are inspected, saving a whole instruction, which is then used to do a final compare on r0. If only LDRSB were available...
IOMD21DMA.s: UAL syntax warning resolved

Version 0.24. Tagged as 'IOMD-0_24'
@
text
@; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO
        GET     Hdr:DevNos

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS

        AREA    |Asm32$$Code|, CODE, READONLY, PIC, ALIGN=5

NoInterrupt     * -1

        EXPORT  HAL_IRQSource
        EXPORT  HAL_IRQEnable
        EXPORT  HAL_IRQDisable
        EXPORT  HAL_IRQClear
        EXPORT  HAL_IRQStatus
        EXPORT  HAL_FIQSource
        EXPORT  HAL_FIQEnable
        EXPORT  HAL_FIQDisable
        EXPORT  HAL_FIQDisableAll
        EXPORT  HAL_FIQClear
        EXPORT  HAL_FIQStatus
        EXPORT  HAL_IRQMax

HAL_IRQSource
        LDR     r3, IOMD_Address
        ADR     r12, DeviceTables

        LDRB    r0, [r3, #IOMD_DMAREQ]
        ASSERT  DeviceTables = IrqDMADevnos
        
        TEQ     r0, #0
        LDREQB  r0, [r3, #IOCIRQREQB]   ; if not DMA then assume IRQB
        ADDEQ   r12, r12, #IrqReqBDevnos - IrqDMADevnos

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQD]  ; if not IRQB then assume IRQD
        ADDEQ   r12, r12, #IrqReqDDevnos - IrqReqBDevnos

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQC]  ; if not IRQD then assume IRQC
        ADDEQ   r12, r12, #IrqReqCDevnos - IrqReqDDevnos

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOCIRQREQA]   ; if not IRQC then assume IRQA
        ADDEQ   r12, r12, #IrqReqADevnos - IrqReqCDevnos

        TEQEQ   r0, #0
        LDRNEB  r0, [r12, r0]           ; pick up offset in device despatcher
        MOVNE   pc, lr
        MOV     r0, #NoInterrupt        ; if none of them
        MOV     pc, lr

HAL_FIQSource
        LDR     r3, IOMD_Address
        LDRB    r0, [r3, #IOCFIQREQ]
        ORR     r0, r0, r0, LSR #4
        ORR     r0, r0, r0, LSR #2
        ORR     r0, r0, r0, LSR #1
        ADD     r0, r0, #1              ; r0 = 2, 4, 8, 16, 32, 64, 128 or 256
        MOV     r1, #&0E800000
        MUL     r0, r1, r0              ; r0>>29 = 0, 1, 3, 7, 6, 5, 2 or 4
        LDRB    r0, [pc, r0, LSR #29]
        MOV     pc, lr
        DCB     0, 1, 6, 2, 7, 5, 4, 3

HAL_FIQEnable
        LDR     a4, IOMD_Address
        MOV     ip, #1
        MRS     a3, CPSR
        MOV     ip, ip, LSL a1
        ORR     a2, a3, #F32_bit+I32_bit
        MSR     CPSR_c, a2
        LDRB    a1, [a4, #IOCFIQMSK]
        ORR     a2, a1, ip
        STRB    a2, [a4, #IOCFIQMSK]
        MSR     CPSR_c, a3
        AND     a1, a1, ip
        MOV     pc, lr

HAL_FIQDisable
        LDR     a4, IOMD_Address
        MOV     ip, #1
        MRS     a3, CPSR
        MOV     ip, ip, LSL a1
        ORR     a2, a3, #F32_bit+I32_bit
        MSR     CPSR_c, a2
        LDRB    a1, [a4, #IOCFIQMSK]
        BIC     a2, a1, ip
        STRB    a2, [a4, #IOCFIQMSK]
        MSR     CPSR_c, a3
        AND     a1, a1, ip
        MOV     pc, lr

HAL_FIQDisableAll
        LDR     a4, IOMD_Address
        MOV     a1, #0
        STRB    a1, [a4, #IOCFIQMSK]
        MOV     pc, lr

HAL_FIQClear
        MOV     pc, lr

HAL_FIQStatus
        LDR     a4, IOMD_Address
        MOV     ip, #1
        LDRB    a2, [a4, #IOCFIQSTA]
        AND     a1, a2, ip, LSL a1
        MOV     pc, lr



; In: a1 = device no.
; Out: a1 = bit number within register, ip = register offset / 4
        MACRO
        DevNoToRegAndBit $type
        CMP     a1, #22
        ADDHS   a1, a1, #2
        ADR     ip, IRQRegTable
        LDRB    ip, [ip, a1, LSR #3]
        AND     a1, a1, #7
  [ "$type" <> "STA"
        ADD     ip, ip, #(IOCIRQ$type.A - IOCIRQSTAA) / 4
  ]
        MEND

; In: a1 = bit number within register, ip = register offset
; Out: a1-a4 corrupt
        MACRO
        ModifyBit $op
        MRS     a4, CPSR
        MOV     a2, #1
        ADD     ip, a3, ip, LSL #2
        MOV     a1, a2, LSL a1
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        LDRB    a2, [ip]
        $op     a2, a2, a1
        STRB    a2, [ip]
        MSR     CPSR_c, a4
        MEND

HAL_IRQEnable
        LDR     a3, IOMD_Address
        DevNoToRegAndBit MSK
        ModifyBit ORR
        MOV     pc, lr

HAL_IRQDisable
        LDR     a3, IOMD_Address
        DevNoToRegAndBit MSK
        ModifyBit BIC
        MOV     pc, lr

HAL_IRQClear
        LDR     a3, IOMD_Address
        MOV     a2, #1
        DevNoToRegAndBit CLR
        MOV     a2, a2, LSL a1
        STRB    a2, [a3, ip, LSL #2]
        MOV     pc, lr

HAL_IRQStatus
        LDR     a3, IOMD_Address
        DevNoToRegAndBit STA
        LDRB    a2, [a3, ip, LSL #2]
        MOV     a2, a2, LSR a1
        AND     a2, a2, #1
	MOV	a1, a2
        MOV     pc, lr

HAL_IRQMax
        MOV     a1, #38
        MOV     pc, lr

        ALIGN   32

        ASSERT  (IOCIRQSTAA :SHR: 2) < &100
        ASSERT  (IOCIRQSTAB :SHR: 2) < &100
        ASSERT  (IOMD_DMASTA :SHR: 2) < &100
        ASSERT  (IOMD_IRQSTD :SHR: 2) < &100
        ASSERT  (IOMD_IRQSTC :SHR: 2) < &100
IRQRegTable
        DCB     IOCIRQSTAA :SHR: 2
        DCB     IOCIRQSTAB :SHR: 2
        DCB     IOMD_DMASTA :SHR: 2
        DCB     IOMD_IRQSTD :SHR: 2
        DCB     IOMD_IRQSTC :SHR: 2

        ALIGN

        GBLA    DTabC
; Following tables encode the priority of the devices within each register
;
DeviceTables


; Prioritised IOMD DMA device numbers

IrqDMAPrio0     * 1:SHL:5
IrqDMADev0      * IOMD_DMASound1_DevNo

IrqDMAPrio1     * 1:SHL:4
IrqDMADev1      * IOMD_DMASound0_DevNo

IrqDMAPrio2     * 1:SHL:3
IrqDMADev2      * IOMD_DMAChannel3_DevNo

IrqDMAPrio3     * 1:SHL:2
IrqDMADev3      * IOMD_DMAChannel2_DevNo

IrqDMAPrio4     * 1:SHL:1
IrqDMADev4      * IOMD_DMAChannel1_DevNo

IrqDMAPrio5     * 1:SHL:0
IrqDMADev5      * IOMD_DMAChannel0_DevNo

DTabC   SETA 1

IrqDMADevnos
  = NoInterrupt

; Top 2 bits are always 0 so table need only be 64 bytes
  WHILE DTabC <64
  [ (DTabC:AND:IrqDMAPrio5)<>0
  = IrqDMADev5
  |
  [ (DTabC:AND:IrqDMAPrio4)<>0
  = IrqDMADev4
  |
  [ (DTabC:AND:IrqDMAPrio3)<>0
  = IrqDMADev3
  |
  [ (DTabC:AND:IrqDMAPrio2)<>0
  = IrqDMADev2
  |
  [ (DTabC:AND:IrqDMAPrio1)<>0
  = IrqDMADev1
  |
  [ (DTabC:AND:IrqDMAPrio0)<>0
  = IrqDMADev0
  ]
  ]
  ]
  ]
  ]
  ]
DTabC   SETA DTabC+1
  WEND


; Prioritised IOMD IRQB device numbers

IrqReqBPrio2 * podule_FIQ_as_IRQ_bit
IrqReqBDev2  * PFIQasIRQ_DevNo

IrqReqBPrio3 * serial_Tx_bit
IrqReqBDev3 * SerialTx_DevNo

IrqReqBPrio4 * serial_Rx_bit
IrqReqBDev4 * SerialRx_DevNo

IrqReqBPrio5 * podule_IRQ_bit
IrqReqBDev5 * Podule_DevNo

 [ ReassignedIOMDInterrupts
IrqReqBPrio0 * IOMDr_MPEGAudio_IRQ_bit
IrqReqBDev0 * IOMDr_MPEGAudio_DevNo

IrqReqBPrio1 * IOMDr_MPEGVideo_IRQ_bit
IrqReqBDev1 * IOMDr_MPEGVideo_DevNo

IrqReqBPrio6 * IOMDr_Network_IRQ_bit
IrqReqBDev6 * IOMDr_Network_DevNo

IrqReqBPrio7 * IOMDr_serial_IRQ_bit
IrqReqBDev7 * IOMDr_Serial_DevNo
 |
IrqReqBPrio0 * IOMD_floppy_IRQ_bit
IrqReqBDev0 * DiscChanged_DevNo

IrqReqBPrio1 * IOMD_HardDisc_IRQ_bit
IrqReqBDev1 * Sound_DevNo

IrqReqBPrio6 * IOMD_Network_IRQ_bit
IrqReqBDev6 * WinnieIRQ_DevNo

IrqReqBPrio7 * IOMD_serial_IRQ_bit
IrqReqBDev7 * IOMD_Serial_DevNo
 ]

DTabC   SETA 1

IrqReqBDevnos
  = NoInterrupt

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqBPrio7)<>0
  = IrqReqBDev7
  |
  [ (DTabC:AND:IrqReqBPrio6)<>0
  = IrqReqBDev6
  |
  [ (DTabC:AND:IrqReqBPrio5)<>0
  = IrqReqBDev5
  |
  [ (DTabC:AND:IrqReqBPrio4)<>0
  = IrqReqBDev4
  |
  [ (DTabC:AND:IrqReqBPrio3)<>0
  = IrqReqBDev3
  |
  [ (DTabC:AND:IrqReqBPrio2)<>0
  = IrqReqBDev2
  |
  [ (DTabC:AND:IrqReqBPrio1)<>0
  = IrqReqBDev1
  |
  [ (DTabC:AND:IrqReqBPrio0)<>0
  = IrqReqBDev0
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC   SETA DTabC+1
  WEND


; Prioritised IOMD IRQD device numbers


IrqReqDPrio0     * 1:SHL:4
IrqReqDDev0      * IOMD_Event2_DevNo

IrqReqDPrio1     * 1:SHL:3
IrqReqDDev1      * IOMD_Event1_DevNo

IrqReqDPrio2     * 1:SHL:2
IrqReqDDev2      * IOMD_AtoD_DevNo

IrqReqDPrio3     * 1:SHL:1
IrqReqDDev3      * IOMD_MouseTxEmpty_DevNo

IrqReqDPrio4     * 1:SHL:0
IrqReqDDev4      * IOMD_MouseRxFull_DevNo

DTabC   SETA 1

IrqReqDDevnos
  = NoInterrupt

; Top 3 bits are always 0 so table need only be 32 bytes (this will
; need to change if bits 5 to 7 are ever used).
  WHILE DTabC <32
  [ (DTabC:AND:IrqReqDPrio4)<>0
  = IrqReqDDev4
  |
  [ (DTabC:AND:IrqReqDPrio3)<>0
  = IrqReqDDev3
  |
  [ (DTabC:AND:IrqReqDPrio2)<>0
  = IrqReqDDev2
  |
  [ (DTabC:AND:IrqReqDPrio1)<>0
  = IrqReqDDev1
  |
  [ (DTabC:AND:IrqReqDPrio0)<>0
  = IrqReqDDev0
  ]
  ]
  ]
  ]
  ]
DTabC   SETA DTabC+1
  WEND


; Prioritised IOMD IRQC device numbers

IrqReqCPrio0    * 1:SHL:0
IrqReqCDev0     * IOMD_C_Bit0_DevNo

IrqReqCPrio1    * 1:SHL:1
IrqReqCDev1     * IOMD_C_Bit1_DevNo

IrqReqCPrio2    * 1:SHL:2
IrqReqCDev2     * IOMD_C_Bit2_DevNo

IrqReqCPrio3    * 1:SHL:3
IrqReqCDev3     * IOMD_C_Bit3_DevNo

IrqReqCPrio4    * 1:SHL:4
IrqReqCDev4     * IOMD_C_Bit4_DevNo

IrqReqCPrio5    * 1:SHL:5
IrqReqCDev5     * IOMD_C_Bit5_DevNo

IrqReqCPrio6    * 1:SHL:6
IrqReqCDev6     * IOMD_C_Bit6_DevNo

IrqReqCPrio7    * 1:SHL:7
IrqReqCDev7     * IOMD_C_Bit7_DevNo

DTabC   SETA 1

IrqReqCDevnos
  = NoInterrupt

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqCPrio7)<>0
  = IrqReqCDev7
  |
  [ (DTabC:AND:IrqReqCPrio6)<>0
  = IrqReqCDev6
  |
  [ (DTabC:AND:IrqReqCPrio5)<>0
  = IrqReqCDev5
  |
  [ (DTabC:AND:IrqReqCPrio4)<>0
  = IrqReqCDev4
  |
  [ (DTabC:AND:IrqReqCPrio3)<>0
  = IrqReqCDev3
  |
  [ (DTabC:AND:IrqReqCPrio2)<>0
  = IrqReqCDev2
  |
  [ (DTabC:AND:IrqReqCPrio1)<>0
  = IrqReqCDev1
  |
  [ (DTabC:AND:IrqReqCPrio0)<>0
  = IrqReqCDev0
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC   SETA DTabC+1
  WEND


; Prioritised IOMD IRQA device numbers

IrqReqAPrio0 * por_bit
IrqReqADev0  * PowerOn_DevNo

IrqReqAPrio4 * timer1_bit
IrqReqADev4 * Timer1_DevNo

IrqReqAPrio5 * vsync_bit
IrqReqADev5 * VSync_DevNo

IrqReqAPrio6 * timer0_bit
IrqReqADev6 * Timer0_DevNo

IrqReqAPrio7 * force_bit
IrqReqADev7 * FIQDowngrade_DevNo

IrqReqAPrio1 * 1:SHL:1          ; not used
IrqReqADev1 * 1

 [ ReassignedIOMDInterrupts
 ASSERT IOMDr_PrinterIRQ_DevNo = 2

IrqReqAPrio2 * IOMDr_printer_IRQ_bit
IrqReqADev2 * IOMDr_PrinterIRQ_DevNo

IrqReqAPrio3 * 1:SHL:0          ; not used
IrqReqADev3 * 0
 |
 ASSERT IOMD_PrinterIRQ_DevNo = 0
 ASSERT IOMD_FloppyIndex_DevNo = 2

IrqReqAPrio2 * IOMD_printer_IRQ_bit
IrqReqADev2 * IOMD_PrinterIRQ_DevNo

IrqReqAPrio3 * IOMD_floppy_index_bit
IrqReqADev3 * IOMD_FloppyIndex_DevNo
 ]

DTabC   SETA 1

IrqReqADevnos
  = NoInterrupt

; We have to handle ALL interrupts using specific device numbers as
; we don't know what the IO pins are connected to
  WHILE DTabC <256
  [ (DTabC:AND:IrqReqAPrio7)<>0
  = IrqReqADev7
  |
  [ (DTabC:AND:IrqReqAPrio6)<>0
  = IrqReqADev6
  |
  [ (DTabC:AND:IrqReqAPrio5)<>0
  = IrqReqADev5
  |
  [ (DTabC:AND:IrqReqAPrio4)<>0
  = IrqReqADev4
  |
  [ (DTabC:AND:IrqReqAPrio3)<>0
  = IrqReqADev3
  |
  [ (DTabC:AND:IrqReqAPrio2)<>0
  = IrqReqADev2
  |
  [ (DTabC:AND:IrqReqAPrio1)<>0
  = IrqReqADev1
  |
  [ (DTabC:AND:IrqReqAPrio0)<>0
  = IrqReqADev0
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC   SETA DTabC+1
  WEND

        END
@


1.7
log
@Implement HAL_IRQMax
Detail:
  s/Boot, s/Interrupts - Added HAL_IRQMax implementation, to ensure correct functionality with latest Kernel
Admin:
  Tested on SA RiscPC with IOMD softload
  Requires Kernel-5_35-4_79_2_182


Version 0.22. Tagged as 'IOMD-0_22'
@
text
@d47 2
d50 2
d53 2
a54 3
        ADRNE   r1, IrqDMADevnos
        LDREQB  r0, [r3, #IOCIRQREQB]   ; if not DMA then assume IRQB until we know otherwise
        ADREQ   r1, IrqReqBDevnos
d56 3
a58 1
        ADREQ   r12, DeviceTables       ; can't reach these tables with ADR
d61 2
a62 2
        LDREQB  r0, [r3, #IOMD_IRQRQD]
        ADDEQ   r1, r12, #IrqReqDDevnos-DeviceTables
d65 2
a66 2
        LDREQB  r0, [r3, #IOMD_IRQRQC]
        ADDEQ   r1, r12, #IrqReqCDevnos-DeviceTables
d69 3
a71 4
        LDREQB  r0, [r3, #IOCIRQREQA]   ; not DMA and not IRQB so assume IRQA
        ADREQ   r1, IrqReqADevnos

        LDRB    r0, [r1, r0]            ; pick up offset in device despatcher
d212 1
d238 1
a238 3

       GBLA  DTabC
DTabC  SETA 1
d268 1
a268 1
DTabC SETA DTabC+1
d272 1
a273 83
; generic IRQA bits
IrqReqAPrio0 * por_bit
IrqReqADev0  * PowerOn_DevNo

IrqReqAPrio4 * timer1_bit
IrqReqADev4 * Timer1_DevNo

IrqReqAPrio5 * vsync_bit
IrqReqADev5 * VSync_DevNo

IrqReqAPrio6 * timer0_bit
IrqReqADev6 * Timer0_DevNo

IrqReqAPrio7 * force_bit
IrqReqADev7 * FIQDowngrade_DevNo

; Machine specific IRQB bits (devices 0-2)

IrqReqAPrio1 * 1:SHL:1          ; not used
IrqReqADev1 * 1

 [ ReassignedIOMDInterrupts
 ASSERT IOMDr_PrinterIRQ_DevNo = 2

IrqReqAPrio2 * IOMDr_printer_IRQ_bit
IrqReqADev2 * IOMDr_PrinterIRQ_DevNo

IrqReqAPrio3 * 1:SHL:0          ; not used
IrqReqADev3 * 0
 |
 ASSERT IOMD_PrinterIRQ_DevNo = 0
 ASSERT IOMD_FloppyIndex_DevNo = 2

IrqReqAPrio2 * IOMD_printer_IRQ_bit
IrqReqADev2 * IOMD_PrinterIRQ_DevNo

IrqReqAPrio3 * IOMD_floppy_index_bit
IrqReqADev3 * IOMD_FloppyIndex_DevNo
 ]


DTabC  SETA 1

IrqReqADevnos
  = NoInterrupt

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqAPrio7)<>0
  = IrqReqADev7
  |
  [ (DTabC:AND:IrqReqAPrio6)<>0
  = IrqReqADev6
  |
  [ (DTabC:AND:IrqReqAPrio5)<>0
  = IrqReqADev5
  |
  [ (DTabC:AND:IrqReqAPrio4)<>0
  = IrqReqADev4
  |
  [ (DTabC:AND:IrqReqAPrio3)<>0
  = IrqReqADev3
  |
  [ (DTabC:AND:IrqReqAPrio2)<>0
  = IrqReqADev2
  |
  [ (DTabC:AND:IrqReqAPrio1)<>0
  = IrqReqADev1
  |
  [ (DTabC:AND:IrqReqAPrio0)<>0
  = IrqReqADev0
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND


; generic IRQB bits
a285 2
; Machine specific IRQB bits

d312 1
a312 2

DTabC  SETA 1
d349 1
a349 1
DTabC SETA DTabC+1
d353 2
a354 1
; Prioritised IRQD device numbers
d371 1
a371 2

DTabC  SETA 1
d398 1
a398 1
DTabC SETA DTabC+1
d401 2
a402 4
; Prioritised IRQC device numbers. We have to handle ALL interrupts
; using specific device numbers as we don't know what the IO pins
; are connected to and the NOIRQ code has to know what bit to clear
; when an unknown interrupt is triggered.
a427 1

d465 83
a547 1
DTabC SETA DTabC+1
@


1.6
log
@Fix keyboard jamming when attempting to disable the unknown IRQ
Function HAL_IRQSource was returning 38 when a ghost interrupt occurred rather than -1 as documented.
When the kernel can't find anyone interesting in device number 38 (which doesn't exist on IOMD) it ends up at the NOIRQ handler which then calls HAL_DisableIRQ with that device number.
DevNoToRegAndBit then adds 2, divides by 8, and tries to pick up offset 5 from a table that only has entries 0-4 (so now has offset 0 from IOMD), then adds the difference between MSK & STA (8), which is unfortunately KBDCR.
The BIC operation then clears bit 0 of KBDCR which forces the PS/2 keyboard clock line and stops the keyboard working.

Tested with EtherB NIC running the IRQ line self test which sets and clears an interrupt with interrupts disabled.

Version 0.20. Tagged as 'IOMD-0_20'
@
text
@d43 1
d188 4
@


1.5
log
@Fix to HAL_FIQEnable and HAL_FIQDisable
Interrupts.s
 A typo meant that any attempt to enable FIQs actually OR'd the mask register with the temporary PSR value. To add to the woes this PSR value has I32 and F32 set, which means the bit 7 (software generated FIQ) was getting enabled.
 The main use of FIQs on IOMD is ADFS, the result of this bug was that floppies immediately locked up the machine because the data pump routines could never clear the FIQ.
 Similar typo in HAL_FIQDisable.
Top.s
 Retire STB conditional.

Version 0.19. Tagged as 'IOMD-0_19'
@
text
@d30 1
a30 1
NoInterrupt     * 38
d309 2
a310 1
  =  NoInterrupt
d392 1
a392 1
  =  NoInterrupt
d451 1
a451 1
  =  NoInterrupt
d511 1
a511 1
  =  NoInterrupt
@


1.4
log
@  Added RPCEmu support
Detail:
  Not supplied
Admin:
  Changes by Tom Walker

Version 0.07. Tagged as 'IOMD-0_07'
@
text
@d90 1
a90 1
        ORR     a2, a2, ip
d104 1
a104 1
        BIC     a2, a2, ip
@


1.3
log
@  Updating and development of the IOMD HAL.
Detail:
  * Resolved multiple declaration of HighestOSEntry
  * Extended IRQ code to modern HAL API
  * New FIQ code, partially copied from Tungsten HAL
  * Added HAL_PlatformInfo and HAL_NVMemoryPageSize, both additional
    requirements of recent kernels
  * Default hard-coded screen mode changed to VGA timings - few modern monitors
    will sync down to the old TV rate modes
  * RAM map hard-coded to match the A7000 I'm using for development
    (previously was hard-coded for a 2MB VRAM + 16 MB DRAM Risc PC -
    ultimately, we need to merge in the autodetection code from non-HAL kernels)
  * Video DMA width tweaked so it works on non-VRAM machines (again this should
    be autodetected)
Admin:
  Known issues include: OS_Reset and hardware scrolling don't work
                        CMOS appears to be reset on every boot
  Work in progress

Version 0.02. Tagged as 'IOMD-0_02'
@
text
@d81 1
a81 1
        
d184 1
@


1.2
log
@Merged IOMD HAL to trunk.

Version 0.01. Tagged as 'IOMD-0_01'
@
text
@d36 7
a42 14
        EXPORT  HAL_FIQDisableCode

HAL_FIQDisableCode
        ADR     r1, FIQOff_Code
        LDR     ip, IOMD_Address
        LDMIA   r1, {r1,r2,r3}
        STMIA   r0, {r1,r2,r3,ip}
        MOV     pc, lr

FIQOff_Code
        LDR     r8, FIQOff_IOMD_Address
        STRB    r8, [r8, #IOCFIQMSK]    ; LSB of IOMD's physical, and hence logical address = 0
        SUBS    pc, lr, #4
FIQOff_IOMD_Address
d69 57
@


1.1
log
@file Interrupts was initially added on branch HAL.
@
text
@d1 496
@


1.1.2.1
log
@More HAL work. IOMD HAL fleshed out somewhat - system gets most of the way
through initialisation.

Version 5.35, 4.79.2.5. Tagged as 'Kernel-5_35-4_79_2_5'
@
text
@a0 467
; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO
        GET     Hdr:DevNos

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS

        AREA    |Asm$$Code|, CODE, READONLY, PIC

NoInterrupt     * 38

        EXPORT  HAL_IRQSource
        EXPORT  HAL_IRQEnable
        EXPORT  HAL_IRQDisable
        EXPORT  HAL_IRQClear

HAL_IRQSource
        LDR     r3, IOMDa
        LDRB    r0, [r3, #IOMD_DMAREQ]
        TEQ     r0, #0
        ADRNE   r1, IrqDMADevnos
        LDREQB  r0, [r3, #IOCIRQREQB]   ; if not DMA then assume IRQB until we know otherwise
        ADREQ   r1, IrqReqBDevnos

        ADREQ   r12, DeviceTables       ; can't reach these tables with ADR

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQD]
        ADDEQ   r1, r12, #IrqReqDDevnos-DeviceTables

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQC]
        ADDEQ   r1, r12, #IrqReqCDevnos-DeviceTables

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOCIRQREQA]   ; not DMA and not IRQB so assume IRQA
        ADREQ   r1, IrqReqADevnos

        LDRB    r0, [r1, r0]            ; pick up offset in device despatcher
        MOV     pc, lr


; Following tables encode the priority of the devices within each register
;
DeviceTables


; Prioritised IOMD DMA device numbers

IrqDMAPrio0     * 1:SHL:5
IrqDMADev0      * IOMD_DMASound1_DevNo

IrqDMAPrio1     * 1:SHL:4
IrqDMADev1      * IOMD_DMASound0_DevNo

IrqDMAPrio2     * 1:SHL:3
IrqDMADev2      * IOMD_DMAChannel3_DevNo

IrqDMAPrio3     * 1:SHL:2
IrqDMADev3      * IOMD_DMAChannel2_DevNo

IrqDMAPrio4     * 1:SHL:1
IrqDMADev4      * IOMD_DMAChannel1_DevNo

IrqDMAPrio5     * 1:SHL:0
IrqDMADev5      * IOMD_DMAChannel0_DevNo


       GBLA  DTabC
DTabC  SETA 1

IrqDMADevnos
  = NoInterrupt*3

; Top 2 bits are always 0 so table need only be 64 bytes
  WHILE DTabC <64
  [ (DTabC:AND:IrqDMAPrio5)<>0
  = IrqDMADev5*3
  |
  [ (DTabC:AND:IrqDMAPrio4)<>0
  = IrqDMADev4*3
  |
  [ (DTabC:AND:IrqDMAPrio3)<>0
  = IrqDMADev3*3
  |
  [ (DTabC:AND:IrqDMAPrio2)<>0
  = IrqDMADev2*3
  |
  [ (DTabC:AND:IrqDMAPrio1)<>0
  = IrqDMADev1*3
  |
  [ (DTabC:AND:IrqDMAPrio0)<>0
  = IrqDMADev0*3
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND



; generic IRQA bits
IrqReqAPrio0 * por_bit
IrqReqADev0  * PowerOn_DevNo

IrqReqAPrio4 * timer1_bit
IrqReqADev4 * Timer1_DevNo

IrqReqAPrio5 * vsync_bit
IrqReqADev5 * VSync_DevNo

IrqReqAPrio6 * timer0_bit
IrqReqADev6 * Timer0_DevNo

IrqReqAPrio7 * force_bit
IrqReqADev7 * FIQDowngrade_DevNo

; Machine specific IRQB bits (devices 0-2)

IrqReqAPrio1 * 1:SHL:1          ; not used
IrqReqADev1 * 1

 [ ReassignedIOMDInterrupts
 ASSERT IOMDr_PrinterIRQ_DevNo = 2

IrqReqAPrio2 * IOMDr_printer_IRQ_bit
IrqReqADev2 * IOMDr_PrinterIRQ_DevNo

IrqReqAPrio3 * 1:SHL:0          ; not used
IrqReqADev3 * 0
 |
 ASSERT IOMD_PrinterIRQ_DevNo = 0
 ASSERT IOMD_FloppyIndex_DevNo = 2

IrqReqAPrio2 * IOMD_printer_IRQ_bit
IrqReqADev2 * IOMD_PrinterIRQ_DevNo

IrqReqAPrio3 * IOMD_floppy_index_bit
IrqReqADev3 * IOMD_FloppyIndex_DevNo
 ]


DTabC  SETA 1

IrqReqADevnos
  =  NoInterrupt*3
  WHILE DTabC <256
  [ (DTabC:AND:IrqReqAPrio7)<>0
  = IrqReqADev7*3
  |
  [ (DTabC:AND:IrqReqAPrio6)<>0
  = IrqReqADev6*3
  |
  [ (DTabC:AND:IrqReqAPrio5)<>0
  = IrqReqADev5*3
  |
  [ (DTabC:AND:IrqReqAPrio4)<>0
  = IrqReqADev4*3
  |
  [ (DTabC:AND:IrqReqAPrio3)<>0
  = IrqReqADev3*3
  |
  [ (DTabC:AND:IrqReqAPrio2)<>0
  = IrqReqADev2*3
  |
  [ (DTabC:AND:IrqReqAPrio1)<>0
  = IrqReqADev1*3
  |
  [ (DTabC:AND:IrqReqAPrio0)<>0
  = IrqReqADev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND


; generic IRQB bits
IrqReqBPrio2 * podule_FIQ_as_IRQ_bit
IrqReqBDev2  * PFIQasIRQ_DevNo

IrqReqBPrio3 * serial_Tx_bit
IrqReqBDev3 * SerialTx_DevNo

IrqReqBPrio4 * serial_Rx_bit
IrqReqBDev4 * SerialRx_DevNo

IrqReqBPrio5 * podule_IRQ_bit
IrqReqBDev5 * Podule_DevNo

; Machine specific IRQB bits

 [ ReassignedIOMDInterrupts
IrqReqBPrio0 * IOMDr_MPEGAudio_IRQ_bit
IrqReqBDev0 * IOMDr_MPEGAudio_DevNo

IrqReqBPrio1 * IOMDr_MPEGVideo_IRQ_bit
IrqReqBDev1 * IOMDr_MPEGVideo_DevNo

IrqReqBPrio6 * IOMDr_Network_IRQ_bit
IrqReqBDev6 * IOMDr_Network_DevNo

IrqReqBPrio7 * IOMDr_serial_IRQ_bit
IrqReqBDev7 * IOMDr_Serial_DevNo
 |
IrqReqBPrio0 * IOMD_floppy_IRQ_bit
IrqReqBDev0 * DiscChanged_DevNo

IrqReqBPrio1 * IOMD_HardDisc_IRQ_bit
IrqReqBDev1 * Sound_DevNo

IrqReqBPrio6 * IOMD_Network_IRQ_bit
IrqReqBDev6 * WinnieIRQ_DevNo

IrqReqBPrio7 * IOMD_serial_IRQ_bit
IrqReqBDev7 * IOMD_Serial_DevNo
 ]


DTabC  SETA 1

IrqReqBDevnos
  =  NoInterrupt*3

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqBPrio7)<>0
  = IrqReqBDev7*3
  |
  [ (DTabC:AND:IrqReqBPrio6)<>0
  = IrqReqBDev6*3
  |
  [ (DTabC:AND:IrqReqBPrio5)<>0
  = IrqReqBDev5*3
  |
  [ (DTabC:AND:IrqReqBPrio4)<>0
  = IrqReqBDev4*3
  |
  [ (DTabC:AND:IrqReqBPrio3)<>0
  = IrqReqBDev3*3
  |
  [ (DTabC:AND:IrqReqBPrio2)<>0
  = IrqReqBDev2*3
  |
  [ (DTabC:AND:IrqReqBPrio1)<>0
  = IrqReqBDev1*3
  |
  [ (DTabC:AND:IrqReqBPrio0)<>0
  = IrqReqBDev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND


; Prioritised IRQD device numbers

IrqReqDPrio0     * 1:SHL:4
IrqReqDDev0      * IOMD_Event2_DevNo

IrqReqDPrio1     * 1:SHL:3
IrqReqDDev1      * IOMD_Event1_DevNo

IrqReqDPrio2     * 1:SHL:2
IrqReqDDev2      * IOMD_AtoD_DevNo

IrqReqDPrio3     * 1:SHL:1
IrqReqDDev3      * IOMD_MouseTxEmpty_DevNo

IrqReqDPrio4     * 1:SHL:0
IrqReqDDev4      * IOMD_MouseRxFull_DevNo


DTabC  SETA 1

IrqReqDDevnos
  =  NoInterrupt*3

; Top 3 bits are always 0 so table need only be 32 bytes (this will
; need to change if bits 5 to 7 are ever used).
  WHILE DTabC <32
  [ (DTabC:AND:IrqReqDPrio4)<>0
  = IrqReqDDev4*3
  |
  [ (DTabC:AND:IrqReqDPrio3)<>0
  = IrqReqDDev3*3
  |
  [ (DTabC:AND:IrqReqDPrio2)<>0
  = IrqReqDDev2*3
  |
  [ (DTabC:AND:IrqReqDPrio1)<>0
  = IrqReqDDev1*3
  |
  [ (DTabC:AND:IrqReqDPrio0)<>0
  = IrqReqDDev0*3
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

; Prioritised IRQC device numbers. We have to handle ALL interrupts
; using specific device numbers as we don't know what the IO pins
; are connected to and the NOIRQ code has to know what bit to clear
; when an unknown interrupt is triggered.

IrqReqCPrio0    * 1:SHL:0
IrqReqCDev0     * IOMD_C_Bit0_DevNo

IrqReqCPrio1    * 1:SHL:1
IrqReqCDev1     * IOMD_C_Bit1_DevNo

IrqReqCPrio2    * 1:SHL:2
IrqReqCDev2     * IOMD_C_Bit2_DevNo

IrqReqCPrio3    * 1:SHL:3
IrqReqCDev3     * IOMD_C_Bit3_DevNo

IrqReqCPrio4    * 1:SHL:4
IrqReqCDev4     * IOMD_C_Bit4_DevNo

IrqReqCPrio5    * 1:SHL:5
IrqReqCDev5     * IOMD_C_Bit5_DevNo

IrqReqCPrio6    * 1:SHL:6
IrqReqCDev6     * IOMD_C_Bit6_DevNo

IrqReqCPrio7    * 1:SHL:7
IrqReqCDev7     * IOMD_C_Bit7_DevNo


DTabC   SETA 1

IrqReqCDevnos
  =  NoInterrupt*3

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqCPrio7)<>0
  = IrqReqCDev7*3
  |
  [ (DTabC:AND:IrqReqCPrio6)<>0
  = IrqReqCDev6*3
  |
  [ (DTabC:AND:IrqReqCPrio5)<>0
  = IrqReqCDev5*3
  |
  [ (DTabC:AND:IrqReqCPrio4)<>0
  = IrqReqCDev4*3
  |
  [ (DTabC:AND:IrqReqCPrio3)<>0
  = IrqReqCDev3*3
  |
  [ (DTabC:AND:IrqReqCPrio2)<>0
  = IrqReqCDev2*3
  |
  [ (DTabC:AND:IrqReqCPrio1)<>0
  = IrqReqCDev1*3
  |
  [ (DTabC:AND:IrqReqCPrio0)<>0
  = IrqReqCDev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

; In: a1 = device no.
; Out: a1 = bit number within register, ip = register offset
        MACRO
        DevNoToRegAndBit $type
        MOV     ip, #IOMD_IRQSTC + (IOCIRQ$type.A - IOCIRQSTAA)
        SUBS    a1, a1, #30
        MOVMI   ip, #IOMD_IRQSTD + (IOCIRQ$type.A - IOCIRQSTAA)
        ADDMIS  a1, a1, #8
        MOVMI   ip, #IOMD_DMASTA + (IOCIRQ$type.A - IOCIRQSTAA)
        ADDMIS  a1, a1, #6
        MOVMI   ip, #IOCIRQSTAB + (IOCIRQ$type.A - IOCIRQSTAA)
        ADDMIS  a1, a1, #8
        MOVMI   ip, #IOCIRQSTAA + (IOCIRQ$type.A - IOCIRQSTAA)
        ADDMI   a1, a1, #8
        MEND

; In: a1 = bit number within register, ip = register offset
; Out: a1-a4 corrupt
        MACRO
        ModifyBit $op
        MRS     a4, CPSR
        MOV     a2, #1
        ADD     ip, a3, ip
        MOV     a1, a2, LSL a1
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        LDRB    a2, [ip]
        $op     a2, a2, a1
        STRB    a2, [ip]
        MSR     CPSR_c, a4
        MEND

HAL_IRQEnable
        LDR     a3, IOMDa
        DevNoToRegAndBit MSK
        ModifyBit ORR
        MOV     pc, lr

HAL_IRQDisable
        LDR     a3, IOMDa
        DevNoToRegAndBit MSK
        ModifyBit BIC
        MOV     pc, lr

HAL_IRQClear
        LDR     a3, IOMDa
        MOV     a2, #1
        DevNoToRegAndBit CLR
        MOV     a2, a2, LSL a1
        STRB    a2, [a3, ip]
        MOV     pc, lr

HAL_IRQStatus
        LDR     a3, IOMDa
        DevNoToRegAndBit STA
        LDRB    a2, [a3, ip]
        MOV     a2, a2, LSR a1
        AND     a2, a2, #1
        MOV     pc, lr

        END
@


1.1.2.2
log
@Interrupt handling tweaks.

Version 5.35, 4.79.2.7. Tagged as 'Kernel-5_35-4_79_2_7'
@
text
@d28 1
a28 1
        AREA    |Asm32$$Code|, CODE, READONLY, PIC, ALIGN=5
a62 75

; In: a1 = device no.
; Out: a1 = bit number within register, ip = register offset / 4
        MACRO
        DevNoToRegAndBit $type
        CMP     a1, #22
        ADDHS   a1, a1, #2
        ADR     ip, IRQRegTable
        LDRB    ip, [ip, a1, LSR #3]
        AND     a1, a1, #7
  [ "$type" <> "STA"
        ADD     ip, ip, #(IOCIRQ$type.A - IOCIRQSTAA) / 4
  ]
        MEND

; In: a1 = bit number within register, ip = register offset
; Out: a1-a4 corrupt
        MACRO
        ModifyBit $op
        MRS     a4, CPSR
        MOV     a2, #1
        ADD     ip, a3, ip, LSL #2
        MOV     a1, a2, LSL a1
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        LDRB    a2, [ip]
        $op     a2, a2, a1
        STRB    a2, [ip]
        MSR     CPSR_c, a4
        MEND

HAL_IRQEnable
        LDR     a3, IOMDa
        DevNoToRegAndBit MSK
        ModifyBit ORR
        MOV     pc, lr

HAL_IRQDisable
        LDR     a3, IOMDa
        DevNoToRegAndBit MSK
        ModifyBit BIC
        MOV     pc, lr

HAL_IRQClear
        LDR     a3, IOMDa
        MOV     a2, #1
        DevNoToRegAndBit CLR
        MOV     a2, a2, LSL a1
        STRB    a2, [a3, ip, LSL #2]
        MOV     pc, lr

HAL_IRQStatus
        LDR     a3, IOMDa
        DevNoToRegAndBit STA
        LDRB    a2, [a3, ip, LSL #2]
        MOV     a2, a2, LSR a1
        AND     a2, a2, #1
        MOV     pc, lr

        ALIGN   32

        ASSERT  (IOCIRQSTAA :SHR: 2) < &100
        ASSERT  (IOCIRQSTAB :SHR: 2) < &100
        ASSERT  (IOMD_DMASTA :SHR: 2) < &100
        ASSERT  (IOMD_IRQSTD :SHR: 2) < &100
        ASSERT  (IOMD_IRQSTC :SHR: 2) < &100
IRQRegTable
        DCB     IOCIRQSTAA :SHR: 2
        DCB     IOCIRQSTAB :SHR: 2
        DCB     IOMD_DMASTA :SHR: 2
        DCB     IOMD_IRQSTD :SHR: 2
        DCB     IOMD_IRQSTC :SHR: 2

        ALIGN

d93 1
a93 1
  = NoInterrupt
d98 1
a98 1
  = IrqDMADev5
d101 1
a101 1
  = IrqDMADev4
d104 1
a104 1
  = IrqDMADev3
d107 1
a107 1
  = IrqDMADev2
d110 1
a110 1
  = IrqDMADev1
d113 1
a113 1
  = IrqDMADev0
d169 1
a169 1
  =  NoInterrupt
d172 1
a172 1
  = IrqReqADev7
d175 1
a175 1
  = IrqReqADev6
d178 1
a178 1
  = IrqReqADev5
d181 1
a181 1
  = IrqReqADev4
d184 1
a184 1
  = IrqReqADev3
d187 1
a187 1
  = IrqReqADev2
d190 1
a190 1
  = IrqReqADev1
d193 1
a193 1
  = IrqReqADev0
d251 1
a251 1
  =  NoInterrupt
d255 1
a255 1
  = IrqReqBDev7
d258 1
a258 1
  = IrqReqBDev6
d261 1
a261 1
  = IrqReqBDev5
d264 1
a264 1
  = IrqReqBDev4
d267 1
a267 1
  = IrqReqBDev3
d270 1
a270 1
  = IrqReqBDev2
d273 1
a273 1
  = IrqReqBDev1
d276 1
a276 1
  = IrqReqBDev0
d310 1
a310 1
  =  NoInterrupt
d316 1
a316 1
  = IrqReqDDev4
d319 1
a319 1
  = IrqReqDDev3
d322 1
a322 1
  = IrqReqDDev2
d325 1
a325 1
  = IrqReqDDev1
d328 1
a328 1
  = IrqReqDDev0
d370 1
a370 1
  =  NoInterrupt
d374 1
a374 1
  = IrqReqCDev7
d377 1
a377 1
  = IrqReqCDev6
d380 1
a380 1
  = IrqReqCDev5
d383 1
a383 1
  = IrqReqCDev4
d386 1
a386 1
  = IrqReqCDev3
d389 1
a389 1
  = IrqReqCDev2
d392 1
a392 1
  = IrqReqCDev1
d395 1
a395 1
  = IrqReqCDev0
d406 60
@


1.1.2.3
log
@first attemp at mjs video code in real HAL
@
text
@d38 1
a38 1
        LDR     r3, IOMD_Address
d95 1
a95 1
        LDR     a3, IOMD_Address
d101 1
a101 1
        LDR     a3, IOMD_Address
d107 1
a107 1
        LDR     a3, IOMD_Address
d115 1
a115 1
        LDR     a3, IOMD_Address
@


1.1.2.4
log
@* Fixed the IIC code.
* Kernel puts sensible default FIQ handler in through the HAL.
* Fix to temporary page uncaching code.

Version 5.35, 4.79.2.30. Tagged as 'Kernel-5_35-4_79_2_30'
@
text
@a35 14
        EXPORT  HAL_FIQDisableCode

HAL_FIQDisableCode
        ADR     r1, FIQOff_Code
        LDR     ip, IOMD_Address
        LDMIA   r1, {r1,r2,r3}
        STMIA   r0, {r1,r2,r3,ip}
        MOV     pc, lr

FIQOff_Code
        LDR     r8, FIQOff_IOMD_Address
        STRB    r8, [r8, #IOCFIQMSK]    ; LSB of IOMD's physical, and hence logical address = 0
        SUBS    pc, lr, #4
FIQOff_IOMD_Address
@



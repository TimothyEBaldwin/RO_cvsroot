head	1.27;
access;
symbols
	IOMD-0_36:1.27
	SMP:1.25.0.2
	SMP_bp:1.25
	IOMD-0_35:1.25
	IOMD-0_34:1.25
	IOMD-0_33:1.24
	IOMD-0_32:1.23
	IOMD-0_31:1.21
	IOMD-0_30:1.21
	IOMD-0_29:1.20
	IOMD-0_28:1.19
	IOMD-0_27:1.19
	IOMD-0_26:1.19
	IOMD-0_25:1.19
	IOMD-0_24:1.18
	IOMD-0_23:1.18
	IOMD-0_22:1.17
	IOMD-0_20:1.16
	IOMD-0_19:1.16
	IOMD-0_18:1.16
	IOMD-0_17:1.15
	IOMD-0_16:1.13
	IOMD-0_15:1.12
	IOMD-0_14:1.12
	IOMD-0_13:1.12
	IOMD-0_12:1.11
	IOMD-0_11:1.10
	IOMD-0_10:1.9
	IOMD-0_09:1.8
	IOMD-0_08:1.7
	IOMD-0_07:1.6
	IOMD-0_06:1.5
	IOMD-0_05:1.4
	IOMD-0_04:1.4
	IOMD-0_03:1.3
	IOMD-0_02:1.3
	HAL_merge:1.1.2.12
	IOMD-0_01:1.2
	Kernel-5_35-4_79_2_59:1.1.2.12
	Kernel-5_35-4_79_2_58:1.1.2.12
	Kernel-5_35-4_79_2_57:1.1.2.12
	Kernel-5_35-4_79_2_56:1.1.2.12
	Kernel-5_35-4_79_2_55:1.1.2.12
	Kernel-5_35-4_79_2_54:1.1.2.12
	Kernel-5_35-4_79_2_53:1.1.2.12
	Kernel-5_35-4_79_2_52:1.1.2.12
	Kernel-5_35-4_79_2_51:1.1.2.12
	Kernel-5_35-4_79_2_50:1.1.2.12
	Kernel-5_35-4_79_2_49:1.1.2.12
	Kernel-5_35-4_79_2_48:1.1.2.12
	Kernel-5_35-4_79_2_47:1.1.2.12
	Kernel-5_35-4_79_2_46:1.1.2.12
	Kernel-5_35-4_79_2_45:1.1.2.12
	Kernel-5_35-4_79_2_44:1.1.2.12
	MSI_Demo_merge:1.1.2.9
	Kernel-5_35-4_79_2_25_2_2:1.1.2.9
	Kernel-5_35-4_79_2_43:1.1.2.12
	Kernel-5_35-4_79_2_42:1.1.2.12
	Kernel-5_35-4_79_2_41:1.1.2.11
	Kernel-5_35-4_79_2_40:1.1.2.10
	Kernel-5_35-4_79_2_39:1.1.2.10
	Kernel-5_35-4_79_2_38:1.1.2.10
	Kernel-5_35-4_79_2_37:1.1.2.10
	Kernel-5_35-4_79_2_36:1.1.2.10
	Kernel-5_35-4_79_2_35:1.1.2.10
	Kernel-5_35-4_79_2_34:1.1.2.10
	Kernel-5_35-4_79_2_33:1.1.2.10
	Kernel-5_35-4_79_2_32:1.1.2.10
	Kernel-5_35-4_79_2_25_2_1:1.1.2.9
	MSI_Demo:1.1.2.9.0.2
	Kernel-5_35-4_79_2_31:1.1.2.10
	Kernel-5_35-4_79_2_30:1.1.2.10
	Kernel-5_35-4_79_2_29:1.1.2.9
	Kernel-5_35-4_79_2_28:1.1.2.9
	Kernel-5_35-4_79_2_27:1.1.2.9
	Kernel-5_35-4_79_2_26:1.1.2.9
	Kernel-5_35-4_79_2_25:1.1.2.9
	Kernel-5_35-4_79_2_24:1.1.2.9
	Kernel-5_35-4_79_2_23:1.1.2.9
	Kernel-5_35-4_79_2_22:1.1.2.9
	Kernel-5_35-4_79_2_21:1.1.2.9
	Kernel-5_35-4_79_2_20:1.1.2.9
	Kernel-5_35-4_79_2_19:1.1.2.9
	Kernel-5_35-4_79_2_18:1.1.2.8
	Kernel-5_35-4_79_2_17:1.1.2.8
	Kernel-5_35-4_79_2_16:1.1.2.8
	Kernel-5_35-4_79_2_15:1.1.2.8
	Kernel-5_35-4_79_2_14:1.1.2.8
	Kernel-5_35-4_79_2_13:1.1.2.7
	Kernel-5_35-4_79_2_12:1.1.2.7
	Kernel-5_35-4_79_2_11:1.1.2.7
	Kernel-5_35-4_79_2_10:1.1.2.7
	Kernel-5_35-4_79_2_9:1.1.2.7
	Kernel-5_35-4_79_2_8:1.1.2.4
	Kernel-5_35-4_79_2_7:1.1.2.2
	Kernel-5_35-4_79_2_6:1.1.2.2
	Kernel-5_35-4_79_2_5:1.1.2.2
	Kernel-5_35-4_79_2_4:1.1.2.1
	Kernel-5_35-4_79_2_3:1.1.2.1
	Kernel-5_35-4_79_2_2:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


1.27
date	2017.12.20.14.27.41;	author rsprowson;	state Exp;
branches;
next	1.26;
commitid	pIrAhZaHUf3VDDjA;

1.26
date	2017.09.09.10.40.59;	author rool;	state Exp;
branches;
next	1.25;
commitid	dKxxNzzikYuxFv6A;

1.25
date	2016.01.05.21.52.59;	author rsprowson;	state Exp;
branches;
next	1.24;
commitid	ivRNyzwriH1I5NPy;

1.24
date	2014.12.06.09.09.31;	author rsprowson;	state Exp;
branches;
next	1.23;
commitid	D1h4LC2lMub1zX0y;

1.23
date	2014.10.07.07.52.13;	author rsprowson;	state Exp;
branches;
next	1.22;
commitid	fxPTDhIsKSw54fTx;

1.22
date	2014.10.07.07.25.10;	author rsprowson;	state Exp;
branches;
next	1.21;
commitid	6z0LCoFhcaULUeTx;

1.21
date	2013.12.15.22.24.59;	author jlee;	state Exp;
branches;
next	1.20;
commitid	itxoCMPuM5Ynphhx;

1.20
date	2013.10.28.22.28.58;	author rsprowson;	state Exp;
branches;
next	1.19;
commitid	MrM5i56lHItnY6bx;

1.19
date	2013.03.28.21.48.44;	author jlee;	state Exp;
branches;
next	1.18;
commitid	4NAwCJkLkDe3DBJw;

1.18
date	2013.02.02.09.12.25;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	MY6QD1zOoCvdbBCw;

1.17
date	2013.01.22.23.32.43;	author jlee;	state Exp;
branches;
next	1.16;
commitid	scjHrR0sFnviigBw;

1.16
date	2012.07.15.12.07.32;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	th0BmFZji9LRDEcw;

1.15
date	2012.07.09.07.34.55;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	jW0kKJmaem76kRbw;

1.14
date	2012.07.09.07.32.09;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	5eSZam1l3tbmjRbw;

1.13
date	2012.07.04.18.19.02;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	nTJOJt9IePDd3hbw;

1.12
date	2012.06.19.23.38.31;	author jlee;	state Exp;
branches;
next	1.11;
commitid	bSrBAroyIB3Jin9w;

1.11
date	2012.06.09.11.29.48;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	QBFdo1jqgrSEA18w;

1.10
date	2012.02.25.17.16.39;	author jlee;	state Exp;
branches;
next	1.9;
commitid	Dn81wPJ3GobPSyUv;

1.9
date	2011.07.18.22.35.07;	author jlee;	state Exp;
branches;
next	1.8;
commitid	wVUi11YAueRAM3sv;

1.8
date	2011.06.25.22.20.24;	author jlee;	state Exp;
branches;
next	1.7;
commitid	FZ1UGujZgGLmr6pv;

1.7
date	2011.06.22.00.56.14;	author jlee;	state Exp;
branches;
next	1.6;
commitid	udJTrSwtAzLNqBov;

1.6
date	2010.12.02.20.28.07;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.02.00.56.55;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.01.02.22.27;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.22.01.41.45;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.22.00.15.18;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.02.08.52.19;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.10.02.08.52.19;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2000.10.05.13.54.49;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2000.10.05.16.37.33;	author mstephen;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2000.10.05.16.46.36;	author dellis;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2000.10.06.09.08.11;	author kbracey;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2000.10.09.15.59.15;	author kbracey;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2000.10.16.11.37.10;	author mstephen;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2001.01.09.17.17.30;	author mstephen;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2001.03.07.15.12.51;	author kbracey;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2001.05.17.10.51.08;	author kbracey;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2001.06.26.09.37.09;	author mstephen;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2001.06.27.14.16.26;	author mstephen;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Comment correction
No code change, retagged as IOMD-0_36.
@
text
@; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        GET     Hdr:HALSize.<HALSize>
        $GetCPU
        $GetIO
        $GetMEMC
        $GetMEMM
        $GetVIDC

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS
        GET     hdr.IOMD
        GET     hdr.Copro15ops

        EXPORT  HALdescriptor
        EXPORT  Config710
        IMPORT  HAL_Base
        IMPORT  start

        AREA    |Asm$$Code|, CODE, READONLY, PIC


HALdescriptor   DATA
        DCD     0
        DCD     HAL_Base - HALdescriptor
        DCD     OSROM_HALSize
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     HAL_WsSize

        MACRO
        HALEntry $name
        ASSERT  (. - HAL_EntryTable) / 4 = EntryNo_$name
        DCD     $name - HAL_EntryTable
        MEND

        MACRO
        NullEntry
        DCD     HAL_Null - HAL_EntryTable
        MEND

        IMPORT   VideoDevice_Init
        IMPORT   IOMD21DMA_Init
        IMPORT   IDEDevice_Init
        IMPORT   RTC_Init

        IMPORT   HAL_IRQEnable
        IMPORT   HAL_IRQDisable
        IMPORT   HAL_IRQClear
        IMPORT   HAL_IRQSource
        IMPORT   HAL_IRQStatus
        IMPORT   HAL_FIQEnable
        IMPORT   HAL_FIQDisable
        IMPORT   HAL_FIQDisableAll
        IMPORT   HAL_FIQClear
        IMPORT   HAL_FIQSource
        IMPORT   HAL_FIQStatus
        IMPORT   HAL_IRQMax

        IMPORT   HAL_Timers
        IMPORT   HAL_TimerDevice
        IMPORT   HAL_TimerGranularity
        IMPORT   HAL_TimerMaxPeriod
        IMPORT   HAL_TimerSetPeriod
        IMPORT   HAL_TimerPeriod
        IMPORT   HAL_TimerReadCountdown

        IMPORT   HAL_CounterRate
        IMPORT   HAL_CounterPeriod
        IMPORT   HAL_CounterRead
        IMPORT   HAL_CounterDelay

        IMPORT   HAL_IICBuses
        IMPORT   HAL_IICType
        IMPORT   HAL_IICSetLines
        IMPORT   HAL_IICReadLines

        IMPORT   HAL_NVMemoryType
        IMPORT   HAL_NVMemorySize
        IMPORT   HAL_NVMemoryPageSize
        IMPORT   HAL_NVMemoryProtectedSize
        IMPORT   HAL_NVMemoryProtection
        IMPORT   HAL_NVMemoryIICAddress
        IMPORT   HAL_NVMemoryRead
        IMPORT   HAL_NVMemoryWrite

        IMPORT   HAL_MachineID

        IMPORT   HAL_KbdScanDependencies

        IMPORT   HAL_DebugRX
        IMPORT   HAL_DebugTX

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource
        HALEntry HAL_IRQStatus
        HALEntry HAL_FIQEnable
        HALEntry HAL_FIQDisable
        HALEntry HAL_FIQDisableAll
        HALEntry HAL_FIQClear
        HALEntry HAL_FIQSource
        HALEntry HAL_FIQStatus

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        HALEntry HAL_NVMemoryType
        HALEntry HAL_NVMemorySize
        HALEntry HAL_NVMemoryPageSize
        HALEntry HAL_NVMemoryProtectedSize
        HALEntry HAL_NVMemoryProtection
        HALEntry HAL_NVMemoryIICAddress
        HALEntry HAL_NVMemoryRead
        HALEntry HAL_NVMemoryWrite

        HALEntry HAL_IICBuses
        HALEntry HAL_IICType
        HALEntry HAL_IICSetLines
        HALEntry HAL_IICReadLines
        NullEntry ;HAL_IICDevice
        NullEntry ;HAL_IICTransfer
        NullEntry ;HAL_IICMonitorTransfer

        NullEntry ;HALEntry HAL_VideoFlybackDevice
        NullEntry ;HALEntry HAL_VideoSetMode
        NullEntry ;HALEntry HAL_VideoWritePaletteEntry
        NullEntry ;HALEntry HAL_VideoWritePaletteEntries
        NullEntry ;HALEntry HAL_VideoReadPaletteEntry
        NullEntry ;HALEntry HAL_VideoSetInterlace
        NullEntry ;HALEntry HAL_VideoSetBlank
        NullEntry ;HALEntry HAL_VideoSetPowerSave
        NullEntry ;HALEntry HAL_VideoUpdatePointer
        NullEntry ;HALEntry HAL_VideoSetDAG
        NullEntry ;HALEntry HAL_VideoVetMode
        NullEntry ;HALEntry HAL_VideoPixelFormats
        NullEntry ;HALEntry HAL_VideoFeatures
        NullEntry ;HALEntry HAL_VideoBufferAlignment
        NullEntry ;HALEntry HAL_VideoOutputFormat

        NullEntry ;HAL_MatrixColumns
        NullEntry ;HAL_MatrixScan

        NullEntry ;HAL_TouchscreenType
        NullEntry ;HAL_TouchscreenRead
        NullEntry ;HAL_TouchscreenMode
        NullEntry ;HAL_TouchscreenMeasure

        HALEntry HAL_MachineID

        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo
        HALEntry HAL_PlatformInfo
        HALEntry HAL_CleanerSpace

        NullEntry ;HAL_UARTPorts
        NullEntry ;HAL_UARTStartUp
        NullEntry ;HAL_UARTShutdown
        NullEntry ;HAL_UARTFeatures
        NullEntry ;HAL_UARTReceiveByte
        NullEntry ;HAL_UARTTransmitByte
        NullEntry ;HAL_UARTLineStatus
        NullEntry ;HAL_UARTInterruptEnable
        NullEntry ;HAL_UARTRate
        NullEntry ;HAL_UARTFormat
        NullEntry ;HAL_UARTFIFOSize
        NullEntry ;HAL_UARTFIFOClear
        NullEntry ;HAL_UARTFIFOEnable
        NullEntry ;HAL_UARTFIFOThreshold
        NullEntry ;HAL_UARTInterruptID
        NullEntry ;HAL_UARTBreak
        NullEntry ;HAL_UARTModemControl
        NullEntry ;HAL_UARTModemStatus
        NullEntry ;HAL_UARTDevice
        NullEntry ;HAL_UARTDefault
        
        HALEntry HAL_DebugRX
        HALEntry HAL_DebugTX

        NullEntry ;HAL_PCIFeatures
        NullEntry ;HAL_PCIReadConfigByte
        NullEntry ;HAL_PCIReadConfigHalfword
        NullEntry ;HAL_PCIReadConfigWord
        NullEntry ;HAL_PCIWriteConfigByte
        NullEntry ;HAL_PCIWriteConfigHalfword
        NullEntry ;HAL_PCIWriteConfigWord
        NullEntry ;HAL_PCISpecialCycle
        NullEntry ;HAL_PCISlotTable
        NullEntry ;HAL_PCIAddresses

        HALEntry HAL_PlatformName
        NullEntry ;Unused
        NullEntry ;Unused

        HALEntry HAL_InitDevices

        HALEntry HAL_KbdScanDependencies
        NullEntry ;Unused
        NullEntry ;Unused
        NullEntry ;Unused

        HALEntry HAL_PhysInfo

        HALEntry HAL_Reset

        HALEntry HAL_IRQMax

HAL_Entries     * (.-HAL_EntryTable)/4

;--------------------------------------------------------------------------------------


HAL_Init
        Entry

        BL      SetUpOSEntries
        MOV     a1, #0
        MOV     a2, #IOPhys
        MOV     a3, #IOSize
        CallOS  OS_MapInIO
        STR     a1, IO_Address
        ADD     a2, a1, #IOMDPhys - IOPhys
        STR     a2, IOMD_Address
        ADD     a3, a1, #VIDCPhys - IOPhys
        STR     a3, VIDC_Address
        ADD     a3, a1, #C710Phys - IOPhys
        STR     a3, C710_Address
        ADD     a3, a1, #GeminiPhys - IOPhys
        STR     a3, Gemini_Address

        LDRB    a1, [a2, #IOMD_ID0]
        LDRB    a4, [a2, #IOMD_ID1]
        ORR     a1, a1, a4, LSL #8
        LDR     a4, =IOMD_Original
        TEQ     a1, a4
        MOVEQ   ip, #IOST_Medusa          ; assume Medusa
        MOVNE   ip, #IOST_7500            ; else assume Morris/Kryten
        STRB    ip, IOSystemType

        MOV     ip, #&FF                  ; make softcopy match the poke done in CommonInit
        STRB    ip, IOCRSoftCopy

        MOVNE   ip, #IOMD_MonitorIDMask   ; the only thing wired up to CLine
        STRNEB  ip, [a2, #IOMD_CLINES]
        STRNEB  ip, CLine_Softcopy

        LDRB    ip, [a2, #IOMD_ROMCR1]    ; recover counted ROM size
        ADD     ip, ip, #1
        MOV     ip, ip, LSL #20           ; Scale up to bytes
        STR     ip, HardROMAmount
        LDRB    ip, [a2, #IOMD_ROMCR0]
        STRB    ip, [a2, #IOMD_ROMCR1]    ; Restore 2nd bank timing

        LDR     a1, [a2, #IOMD_SD0ENDA]   ; recover Kinetic test result
        STRB    a1, IsKinetic
        
        ASSERT  SAMLength/2/256 = 4       ; SAM length for 1MB VRAM
        LDRB    ip, [a2, #IOMD_VIDCR]     ; Read back VIDCR to recalculate the VRAM size based on what we
                                          ; know Allocate_DRAM programs. However, RPCemu is buggy and always reports
                                          ; DRAMMode + bit 4 set! Luckily we only need bits 2 & 3 to get the VRAM size
        MOV     ip, ip, LSR #2
        AND     ip, ip, #3                ; should be 0, 1, 2 depending on VRAM size
        CMP     ip, #3                    ; ... or 3 for RPCEmu's 8MB
        MOVEQ   ip, #8
        STRB    ip, VRAMWidth

        MOV     a1, #0
        MOV     a2, #EASIPhys
        MOV     a3, #EASISize
        CallOS  OS_MapInIO
        STR     a1, EASI_Address

        LDR     a1, C710_Address        ; Get C710/SuperIO
        BL      Config710

        EXIT

Config710 ; Note: called by Debug_Init pre-MMU/stack, assumed to preserve a1 & v1
        MOV     a2, #0x55               ; Enter config mode
        STRB    a2, [a1, #0xfc0]
        STRB    a2, [a1, #0xfc0]
        MOV     a2, #0x0d
        STRB    a2, [a1, #0xfc0]

        ADR     a2, SuperIOTab
SPL     LDRB    a3, [a2], #1
        CMP     a3, #0xff
        LDRNEB  a4, [a2], #1
        STRNEB  a3, [a1, #0xfc0]
        STRNEB  a4, [a1, #0xfc4]
        BNE     SPL

        MOV     a2, #0xaa               ; Leave config mode
        STRB    a2, [a1, #0xfc0]

        MOV     pc, lr

SuperIOTab
        DCB     0x01,0x87,0x02,0x1c,0x03,0x78,0x04,0x03,0x05,0x00,0x06,0xff
        DCB     0x07,0x00,0x08,0x00,0x09,0x00,0x0a,0x00,0x00,0xbb
        DCB     0xff

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADR     a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05

        MOV     pc, lr

HAL_InitDevices
        Push    "lr"
        BL      RTC_Init
        LDRB    a1, IsKinetic
        CMP     a1, #0
        BLEQ    IOMD21DMA_Init
        BL      VideoDevice_Init
        BL      IDEDevice_Init
        Pull    "pc"
        
HAL_Null
        MOV     pc, lr

HAL_ControllerAddress
        MOV     a1, #0                  ; Default to "not fitted"
        AND     a3, a2, #&FF            ; Get sequence number.
        MOV     a2, a2, LSR #8          ; Get controller type.
        CMP     a2, #34
        BEQ     ca_82C710
        CMP     a2, #6
        ADDLS   pc, pc, a2, LSL #2
        MOV     pc, lr
        B       ca_EASIspeed
        B       ca_EASIspace
        MOV     pc, lr                  ; No VIDC1
        B       ca_VIDC20
        B       ca_SSpace
        MOV     pc, lr                  ; No extension ROMs
        B       ca_Gemini

ca_EASIspeed
        LDR     ip, IOMD_Address
        CMP     a3, #EASISlots
        ADDLO   a1, ip, #IOMD_ECTCR
        MOV     pc, lr

ca_EASIspace
        LDR     ip, EASI_Address
        CMP     a3, #EASISlots
        ADDLO   a1, ip, a3, LSL #EASISlotSizeShift
        MOV     pc, lr

ca_VIDC20
        TEQ     a3, #0
        LDREQ   a1, VIDC_Address
        MOV     pc, lr

ca_SSpace
        TEQ     a3, #0
        LDREQ   a1, IOMD_Address        ; IOMD = S0
        MOV     pc, lr

ca_82C710
        TEQ     a3, #0
        LDREQ   a1, C710_Address
        MOV     pc, lr

ca_Gemini
        TEQ     a3, #0
        LDREQB  a3, IOSystemType
        TEQEQ   a3, #IOST_Medusa        ; No socket on IOST_7500
        LDREQ   a1, Gemini_Address      ; 2nd processor ASIC lives here
        MOV     pc, lr

HAL_HardwareInfo
        LDR     ip, =&01010100
        STR     ip, [a1]
        MOV     ip, #1
        STR     ip, [a2]
        LDRB    a1, IOSystemType
        TEQ     a1, #IOST_Medusa
        MOVEQ   ip, #0                  ; Medusa, so VIDC20 and IOMD
        MOVNE   ip,     #&00010000      ; VIDC2L
        ORRNE   ip, ip, #&00000100      ; IOMDL
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        LDR     ip, =&00311111
        STR     ip, [a1]
        LDR     ip, =&00011100
        STR     ip, [a2]
        MOV     pc, lr

HAL_PlatformInfo
        ADR     a4, %86
        LDR     ip, IOMD_Address
        LDRB    ip, [ip, #IOMD_ID0]
82
        LDR     a1, [a4], #4
        TEQ     a1, #&80000000     ;terminator
        TEQNE   a1, ip
        ADDNE   a4, a4, #2*4
        BNE     %BT82
        ; Assuming no ROM patches are in use, a log->phys conversion on the ROM
        ; base should reveal whether we're running from RAM or not
        Push    "a2-a4,lr"
        LDR     a1, =HAL_Base
        CallOS  OS_LogToPhys
        CMP     a1, #ROMBank0Phys
        Pull    "a2-a4,lr"
        LDMIA   a4, {a4,ip}
        ORRNE   a4, a4, #16 ; Soft ROM
        STR     a4, [a2]
        STR     ip, [a3]
        MOV     pc, lr
86
        DCD     IOMD_Original :AND: &FF, &00000005, &0000001F
        DCD     IOMD_7500     :AND: &FF, &00000001, &0000001F
        DCD     IOMD_7500FE   :AND: &FF, &00000001, &0000001F
        DCD     IOMD_IOMD2    :AND: &FF, &0000000F, &0000001F
        DCD     &80000000,                       0,         0  ;terminator

HAL_PlatformName
        LDRB    a1, IOSystemType
        CMP     a1, #IOST_Medusa
        ADRNE   a1, %FT07
        MOVNE   pc, lr
        LDRB    a1, IsKinetic
        CMP     a1, #0
        ADREQ   a1, %FT05
        ADRNE   a1, %FT06
        MOV     pc, lr
06      DCB     "Kinetic "
05      DCB     "Risc PC", 0
07      DCB     "A7000/A7000+", 0
        ALIGN
        
;must return address of at least 64k of physical space suitable for
;cache cleaning (at least 4k aligned, preferably 64k aligned)
;or, return -1 if HAL knows not needed (eg. knows core in system)
;
HAL_CleanerSpace
        LDRB    a1, IsKinetic
        CMP     a1, #0
        MOVNE   a1, #ZeroWaitState
        MOVEQ   a1, #ROMBank1Phys
        MOV     pc, lr

HAL_Reset
        ; a1 = reset/power off flag
        ; a2 = L1PT
        ; Follow the same basic procedure as the softload tool; set up a
        ; mapping in L1PT for the first MB of the ROM, and then disable the
        ; MMU and jump to it
        MOV     v1, a2
        ADRL    a1, start
        CallOS  OS_LogToPhys ; Find ourselves
        MSR     CPSR_c, #SVC32_mode+I32_bit+F32_bit
        MOV     a2, a1, LSR #20
        MOV     a3, a2, LSL #20
        ORR     a3, a3, #(1:SHL:10)     ; svc-only access
        ORR     a3, a3, #(1:SHL:4):OR:2 ; U~C~B, section mapped
        STR     a3, [v1, a2, LSL #2]
        ARM_read_ID a2
        AND     a2,a2,#&F000
;flush cache
        CMP     a2,#&A000
        ARM67_flush_cache NE       ;if not StrongARM, assume 6,7
        ARM67_flush_TLB NE
        BNE     %FT10
;StrongARM then
        ; We don't know where the cleaner space is.
        ; Just use a 32K block from the start of the OS image.
        LDR     a2, =HAL_Base+OSROM_HALSize
        ARMA_clean_DC a2,a3,a4
        ADD     a2, a2, #16*1024
        ARMA_clean_DC a2,a3,a4
        ARMA_drain_WB
        ARMA_flush_DC
        ARMA_flush_IC
        ARMA_flush_TLBs
10
        ; Now we're ready to go
        MOV     a2, #&30
        ARM_write_control a2
        MOV     pc, a1

; Shifts to determine number of bytes/words to allocate in table.
NibbleShift     *       12
ByteShift       *       NibbleShift + 1
WordShift       *       ByteShift + 2

; Bit patterns for different types of memory.
NotPresent      *       &00000000
DRAM_Pattern    *       &11111111
VRAM_Pattern    *       &22222222
ROM_Pattern     *       &33333333
IO_Pattern      *       &44444444
NotAvailable    *       &88888888

HAL_PhysInfo ROUT
        TEQ     a1, #PhysInfo_GetTableSize
        BNE     %FT10
        LDRB    a1, IsKinetic
        CMP     a1, #0
        MOVNE   a1, #512*1024
        MOVEQ   a1, #IOMDPhysSpaceSize :SHR: ByteShift
        STR     a1, [a2]
        MVN     a1, #0             ; Supported
        MOV     pc, lr

10
        TEQ     a1, #PhysInfo_HardROM
        MOVEQ   a1, #ROMBank0Phys
        LDREQ   a2, HardROMAmount
        ADDEQ   a2, a1, a2
        SUBEQ   a2, a2, #1         ; Inclusive end address
        STMEQIA a3, {a1-a2}
        MVNEQ   a1, #0             ; Supported
        MOVEQ   pc, lr

        TEQ     a1, #PhysInfo_WriteTable
        MOVNE   a1, #0
        MOVNE   pc, lr

        ; Do the PhysInfo_WriteTable table output 
        MOV     ip, lr
        MOV     a1, #DRAM0PhysRam  ; Start of DRAM area for kernel to fill in
        LDRB    a4, IsKinetic
        CMP     a4, #0
        MOVEQ   a4, #IOMDPhysSpaceSize ; End of DRAM area for kernel to fill in
        MOVNE   a4, #SDRAM1PhysRam + SDRAMBankSize
        STMIA   a3, {a1,a4}
        MOV     a1, a2

        ; &00000000 to HardROMAmount is ROM.
        LDR     a4, HardROMAmount
        MOV     a2, a4, LSR #WordShift
        LDR     a3, =ROM_Pattern :OR: NotAvailable
        BL      fill_words

        ; HardROMAmount to &02000000 includes ROM bank 1, but is not present.
        RSB     a2, a4, #&02000000
        MOV     a2, a2, LSR #WordShift
        LDR     a3, =NotPresent :OR: NotAvailable
        BL      fill_words

        ; &02000000 to &02800000 is VRAM or not present.
        LDRB    a4, VRAMWidth           ; Get amount of VRAM (in megabytes).
        MOVS    a4, a4, LSL #20
        MOVNE   a2, a4, LSR #WordShift  ; If there is some then fill part of table.
        LDRNE   a3, =VRAM_Pattern :OR: NotAvailable
        BLNE    fill_words

        ; End of VRAM to &03000000 is not present.
        RSB     a4, a4, #&03000000-&02000000
        MOV     a2, a4, LSR #WordShift
        LDR     a3, =NotPresent :OR: NotAvailable
        BL      fill_words

        ; &03000000 to &03800000 is I/O.
        MOV     a2, #(&03800000-&03000000) :SHR: WordShift
        LDR     a3, =IO_Pattern :OR: NotAvailable
        BL      fill_words

        ; &03800000 to &08000000 is not present.
        MOV     a2, #(&08000000-&03800000) :SHR: WordShift
        LDR     a3, =NotPresent :OR: NotAvailable
        BL      fill_words

        ; &08000000 to &10000000 is I/O (EASI space).
        MOV     a2, #(&10000000-&08000000) :SHR: WordShift
        LDR     a3, =IO_Pattern :OR: NotAvailable
        BL      fill_words

        ; &10000000 to &20000000 is DRAM (filled in by kernel) or not present
        MOV     a2, #(&20000000-&10000000) :SHR: WordShift
        LDR     a3, =NotPresent :OR: NotAvailable
        BL      fill_words

        LDRB    a2, IsKinetic
        CMP     a2, #0
        BEQ     %FT20

        ; &20000000 to &40000000 is SDRAM (filled in by kernel) or not present
        ; &40000000 to &E0000000 is not present
        ; &E0000000 to &E8000000 is ROM, but we're assuming the mapping is disabled
        MOV     a2, #(&E8000000-&20000000) :SHR: WordShift
        LDR     a3, =NotPresent :OR: NotAvailable
        BL      fill_words

        ; &E8000000 to &FFFFFFFF is I/O
        MOV     a2, #(&00000000-&E8000000) :SHR: WordShift
        LDR     a3, =IO_Pattern :OR: NotAvailable
        BL      fill_words

20
        MVN     r0, #0             ; Supported
        MOV     pc, ip

fill_words
        STR     a3, [a1], #4
        SUBS    a2, a2, #1
        BNE     fill_words
        MOV     pc, lr

        LTORG

        END
@


1.26
log
@Participate in keyboard scan dependencies
Detail:
  Replace keyboard scan code with list of modules that the kernel needs to do the same.
  Reorder the HALEntries to match Kernel-5_89.
  Delete unused workspace.
Admin:
  Submission for USB bounty.

Version 0.36. Tagged as 'IOMD-0_36'
@
text
@d179 3
a181 3
        NullEntry ;HAL_Touchscreenread
        NullEntry ;HAL_Touchscreenread
        NullEntry ;HAL_Touchscreenread
@


1.25
log
@Declare the presence of an IDE controller
ATA.s:
  Refactor to report a PATA IDE controller. Delete lots of junk left over from copying this from the Tungsten HAL.
Boot.s:
  Init the ATA device.
  Report a HAL platform name string for OS_ReadSysInfo 9,7.
Tested on a Risc PC.

Version 0.34. Tagged as 'IOMD-0_34'
@
text
@d109 1
a109 4
        IMPORT   HAL_KbdScanSetup
        IMPORT   HAL_KbdScanFinish
        IMPORT   HAL_KbdScan
        IMPORT   HAL_KbdScanInterrupt
d210 2
a211 2

        HALEntry HAL_Reset
d232 4
a235 4
        HALEntry HAL_KbdScanSetup
        HALEntry HAL_KbdScan
        HALEntry HAL_KbdScanFinish
        HALEntry HAL_KbdScanInterrupt
d239 1
a239 1
        NullEntry ;HAL_USBControllerInfo
@


1.24
log
@Minor HAL API corrections
HAL_HardwareInfo - now adjusts word 2 depending on whether it's an A7000(+) or Risc PC.
HAL_PhysInfo - report the ROM range as an inclusive range for op 2, same as the RAM is for op 1.
Requires Kernel 4.79.2.248 to get the corresponding ROM range change.

Version 0.33. Tagged as 'IOMD-0_33'
@
text
@d64 1
a106 4
        IMPORT   HAL_ATAControllerInfo
        IMPORT   HAL_ATASetModes
        IMPORT   HAL_ATACableID

d229 3
a231 3
        HALEntry HAL_ATAControllerInfo
        HALEntry HAL_ATASetModes
        HALEntry HAL_ATACableID
d242 1
a242 1
        NullEntry ;HALEntry HAL_USBControllerInfo
d336 5
d367 1
d473 15
a658 5
SuperIOTab
        DCB     0x01,0x87,0x02,0x1c,0x03,0x78,0x04,0x03,0x05,0x00,0x06,0xff
        DCB     0x07,0x00,0x08,0x00,0x09,0x00,0x0a,0x00,0x00,0xbb
        DCB     0xff

@


1.23
log
@Notch out Gemini on IOST_7500
Should have written the documentation first, makes sense to deny the existance of a 2nd processor ASIC on 7500(FE) models since that chip has no OPEN bus.

Version 0.32. Not tagged
@
text
@d426 5
a430 1
        MOV     ip, #0
d549 1
@


1.22
log
@Extend HAL_ControllerAddress to report where the Gemini ASIC is
Useful for a future 32 bit PC card, or similar coprocessor plugins.

Version 0.32. Tagged as 'IOMD-0_32'
@
text
@d416 3
a418 1
        LDREQ   a1, Gemini_Address      ; Or any other 2nd processor
@


1.21
log
@Remove obsolte stub HAL video API implementation
Detail:
  s/Boot, s/Video - Removed obsolete HAL video API implementation. A stub implementation is no longer required for systems that have a GraphicsV driver in a module, and can even cause problems if the OS decides to use the HAL implementation instead of the module one.
Admin:
  Tested in IOMD ROM softload
  Requires Kernel-5_35-4_79_2_203


Version 0.30. Tagged as 'IOMD-0_30'
@
text
@d269 2
d376 1
a376 1
        CMP     a2, #4
d383 3
a385 1
        B       ca_IOMD
d404 1
a404 1
ca_IOMD
d406 1
a406 1
        LDREQ   a1, IOMD_Address
d414 5
@


1.20
log
@Add RTC device
HAL RTC device added after probing IIC address &A0.
Moved CallOS macro into a header.

Version 0.29. Tagged as 'IOMD-0_29'
@
text
@a96 6
        IMPORT   HAL_VideoFlybackDevice
        IMPORT   HAL_VideoVetMode
        IMPORT   HAL_VideoPixelFormats
        IMPORT   HAL_VideoFeatures
        IMPORT   HAL_VideoBufferAlignment

d165 1
a165 1
        HALEntry HAL_VideoFlybackDevice
d175 4
a178 4
        HALEntry HAL_VideoVetMode
        HALEntry HAL_VideoPixelFormats
        HALEntry HAL_VideoFeatures
        HALEntry HAL_VideoBufferAlignment
@


1.19
log
@Add Kinetic support
Detail:
  hdr/IOMD - Add definitions for the interesting bits of the Kinetic memory map
  hdr/StaticWS - Add an extra flag to workspace for whether we're running on a Kinetic
  s/Top - Add debug options for ignoring DRAM & ignoring the Kinetic card. Update startup code to add Kinetic card + SDRAM detection. Current code makes no attempt to configure the SDRAM timings and assumes the correct settings have been set via the DIP switches.
  s/Boot - Update HAL_CleanerSpace, HAL_PhysInfo & HAL_InitDevices to cope with running on a Kinetic.
  s/Post - Update POST routine register usage. Add experimental (disabled) code to not count a "SDRAM+VRAM but no DRAM" situation as a POST failure. The OS will boot in that configuration, but lack of DMA capable memory is troublesome.
  s/ATA - Adjust the flags returned by HAL_ATAControllerInfo to match the comments. Although the old flags were technically wrong, this had no effect on function as the lack of DMA support meant they were never acted on by ADFS.
Admin:
  Tested in ROM softload on Kinetic RiscPC, and in RPCEmu
  Note that if a Kinetic card is fitted, the IOMD DMA HAL devices won't be registered with the OS, as DMAManager isn't yet ready to cope with the possibility of DMA-incapable memory.


Version 0.25. Tagged as 'IOMD-0_25'
@
text
@d64 1
a256 7
        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND

d364 1
@


1.18
log
@Add HAL device for IOMD's DMA controller
Tested with simple DMA test podule 8067660000012 rev 0.10 and DMAManager 0.20.

Version 0.23. Tagged as 'IOMD-0_23'
@
text
@d304 3
d370 3
a372 1
        BL      IOMD21DMA_Init
d471 4
a474 1
        MOV     a1, #ROMBank1Phys
d531 8
a538 4
        MOVEQ   a1, #PhysSpaceSize :SHR: ByteShift
        STREQ   a1, [a2]
        MVNEQ   a1, #0             ; Supported
        MOVEQ   pc, lr
d540 1
d556 4
a559 1
        MOV     a4, #PhysSpaceSize ; End of DRAM area for kernel to fill in
d608 17
@


1.17
log
@Implement HAL_IRQMax
Detail:
  s/Boot, s/Interrupts - Added HAL_IRQMax implementation, to ensure correct functionality with latest Kernel
Admin:
  Tested on SA RiscPC with IOMD softload
  Requires Kernel-5_35-4_79_2_182


Version 0.22. Tagged as 'IOMD-0_22'
@
text
@d63 1
d367 1
@


1.16
log
@Addition of POST checking
Unlike some more recent targets, there are a lot of optional/removeable bits on IOMD platforms which may stop the machine booting, this checks for
* VRAM (non fatal if missing)
* RAM
* ROM checksum
* Video timing
* IOMD
in the event of a failure the fault code is flashed on the floppy drive LED (pattern decoder in TRM appendix A).

Video.s: the POST code highlighted that the VIDCTAB had the wrong VCO reference clock on Medusa - this is now corrected for a 60Hz mode.
IOMD.hdr: share the address line bits
Tested on Risc PC + A7000, the timing emulation is not accurate enough on RPCEmu, so POST is skipped under emulation.

Version 0.18. Tagged as 'IOMD-0_18'
@
text
@d75 1
d249 4
@


1.15
log
@Return TRUE not FALSE
Comment was right, shame about the code.
Retagged as IOMD-0_17.
@
text
@d597 3
a599 2
        = 0x01,0x87,0x02,0x1c,0x03,0x78,0x04,0x03,0x05,0x00,0x06,0xff
        = 0x07,0x00,0x08,0x00,0x09,0x00,0x0a,0x00,0x00,0xbb,0xff
@


1.14
log
@Added autodetection of ROM size
New function Count_Hard_ROM looks with the MMU off at how big the ROM chip is (because both softloaded and compressed ROMs might be smaller or larger than the chips themselves).
Adopt revised HAL_PhysInfo API.
Removed pointless setting of ECTCR since the podule manager does that itself anyway.
Last two NullEntry in the entry point table trimmed.
Tested on RPCEmu (which emulates 8MB of ROM) and a Risc PC (with 4MB ROM).

Version 0.17. Tagged as 'IOMD-0_17'
@
text
@d585 1
a585 1
        MOV     r0, #0             ; Supported
@


1.13
log
@Add HAL device for VIDC20
Required by VIDC20Video to locate the controller and its info.
Moved the HAL video code out into a module.
Reordered the power on VIDC pokes to disable sound ASAP.
Added a header file to the 'cbits' for 1 less warning.
Used IOMDPhys where we mean its physical address, and IOMD_Base where offsets are being referred to.
Set up "CLines" single GPIO bit as input (it's the only thing on port C on the A7000/A7000+.
Tested on RiscPC and RPCEmu.

Version 0.16. Tagged as 'IOMD-0_16'
@
text
@a247 4
        NullEntry ;HALEntry HAL_USBControllerInfo

        NullEntry ;HALEntry HAL_MonitorLeadID

d292 7
a513 2
PhysSpaceSize * &20000000 ; IOMD physical map is 512M big. Will be wrong for Kinetic!

d515 1
a515 1
        TEQ     a1, #0
d517 10
d529 5
d535 8
a542 10
        MOV     a3, #PhysSpaceSize ; End of DRAM area for kernel to fill in
        STR     a3, [a2]
        
        ; &00000000 to OSROM_ImageSize*1024 is ROM.
        ; This will obviously be wrong for compressed images, but at the moment
        ; we don't have any way of knowing what size the compressed image was.
        ; And it could still end up being wrong for any softload. Oh well.
        ASSERT  ((OSROM_ImageSize*1024) :AND: ((1<<WordShift)-1))=0
        ASSERT  OSROM_ImageSize*1024 <= &02000000
        MOV     a2, #(OSROM_ImageSize*1024-&00000000) :SHR: WordShift
d546 3
a548 2
        ; OSROM_ImageSize*1024 to &02000000 is allocated to ROM but is not present.
        MOV     a2, #(&02000000-OSROM_ImageSize*1024) :SHR: WordShift
d585 1
a585 1
        MOV     a1, #DRAM0PhysRam ; Start of DRAM area for kernel to fill in
@


1.12
log
@Add debugging code. Fix detection of RAM in bank 3.
Detail:
  hdr/Debug, hdr/UART, s/Boot, s/Debug, Makefile - Added HAL_DebugTX/HAL_DebugRX implementations, and assorted functions/macros for getting pre-MMU debug output from the HAL. Use Debug switch in hdr/Debug to turn debugging on/off (currently off by default).
  s/Top - Added lots of debug output to help track down RAM detection/configuration issues. Fixed RAM detection result for bank 3 being overwritten with result for bank 2 in NoRelocate.
Admin:
  Tested under RPCEmu & StrongARM softload
  Warning - RPCEmu doesn't emulate the serial line status register. This means debug builds will hang on startup.


Version 0.13. Tagged as 'IOMD-0_13'
@
text
@d62 1
a62 1
        IMPORT   Video_init
d94 6
a108 17
        IMPORT   HAL_VideoFlybackDevice
        IMPORT   HAL_Video_SetMode
        IMPORT   HAL_Video_WritePaletteEntry
        IMPORT   HAL_Video_WritePaletteEntries
        IMPORT   HAL_Video_ReadPaletteEntry
        IMPORT   HAL_Video_SetInterlace
        IMPORT   HAL_Video_SetBlank
        IMPORT   HAL_Video_SetPowerSave
        IMPORT   HAL_Video_UpdatePointer
        IMPORT   HAL_Video_SetDAG
        IMPORT   HAL_Video_VetMode
        IMPORT   HAL_Video_PixelFormats
        IMPORT   HAL_Video_Features
        IMPORT   HAL_Video_BufferAlignment
        IMPORT   HAL_Video_OutputFormat
        IMPORT   HAL_MonitorLeadID

a111 2
        ;IMPORT   HAL_MatrixColumns
        ;IMPORT   HAL_MatrixScan
d169 14
a182 14
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode
        HALEntry HAL_Video_PixelFormats
        HALEntry HAL_Video_Features
        HALEntry HAL_Video_BufferAlignment
        HALEntry HAL_Video_OutputFormat
d239 1
a239 1
        NullEntry ;HAL_InitDevices
d250 1
a250 1
        HALEntry HAL_MonitorLeadID
d286 1
a286 1
        MOVNE   ip, #IOST_7500            ; else assume Morris
d292 14
a311 2
        BL      Video_init

d356 5
a360 1

d375 1
a375 1
        MOV     pc, lr
@


1.11
log
@Fix to HAL_MachineID
In transplanting the unique id chip bit basher, the routine carefully preserves the (write only) IOControl register in IOMD, but unfortunately uses a softcopy of 0 since that's never set. Since the I2C startup happens first the ID line is low pretty quickly after startup, therefore the ID chip reset doesn't work (needs a H-L-H transition) and so no unique ID is retrieved.

hdr.StaticWS: define symbol for Medusa.
s.Boot: once some workspace is available, ensure the softcopy matches the hardware.
s.MachineID: trim out the CheckCRC function since the Kernel does this, allows the error exit to be a bit more simple too.
s.Top: improve commenting of startup sequence, and get some consistency on IOC/IOMD, since this doesn't run on IOC. Move the default podule setup into the common setup.

Inspected on a scope, pin 2 of the DS2401 wiggles appropriately and a valid looking MAC address is available from OS_ReadSysInfo 4.

Version 0.12. Tagged as 'IOMD-0_12'
@
text
@d36 1
d133 3
d234 2
a235 2
        NullEntry ;HAL_DebugRX
        NullEntry ;HAL_DebugTX
d314 3
d318 1
d336 1
a336 1
        EXIT
@


1.10
log
@Rewrite Makefile & RAM setup code. Remove/tidy other scripts. Add support for compressed ROMs, keyboard scan, HAL_Reset, HAL_MonitorLeadID and HAL_PhysInfo.
Detail:
  Makefile, MkClean,fd7, MkRom,fd7 - Rewritten
  CopyIt,feb, CopyIt2,feb, CopyItKB,feb, GlueIt,feb, aif, bin, gpa, o - Deleted obsolete files/folders
  s/Boot, s/Top - Moved image entry point from s/Boot to s/Top, to match other HALs. Rewritten RAM setup code to avoid poking dangerous registers during softloads, and to hopefully fix problems people have been having with some memory configurations.
  c/cbits - C code for use during RAM initialisation. Examines the detected RAM banks to work out the optimal physical RAM layout and where to relocate the ROM image, taking into account any ROM compression.
  s/ATA - Convert tabs to spaces for consistency. Fix conditional MOV pc,lr in HAL_ATACableID.
  s/Boot - Added HAL_PhysInfo implementation, based around pre-HAL kernel code. Added HAL_Reset implementation, using similar code to the softload tool to disable the MMU and restart the ROM. Convert tabs to spaces for consistency.
  s/Video, hdr/StaticWS - Added HAL_MonitorLeadID implementation, based around pre-HAL kernel code. Retab Video_init.
  s/KbdScan, hdr/StaticWS - Added HAL_KbdScan_* implementation, based around pre-HAL kernel code.
  s/NVRAM - Convert tabs to spaces for consistency
  hdr/Copro15ops - ARMv3/v4 cache/TLB macros for use during HAL_Reset
  hdr/IOMD - New header to pull together all the physical memory map definitions
Admin:
  Tested in IOMD ROM softload on RiscPC, plus as 'real' ROM under RPCEmu
  New RAM setup code may be a bit buggy still


Version 0.11. Tagged as 'IOMD-0_11'
@
text
@d294 1
a294 1
        MOVEQ   ip, #0                    ; assume Medusa
d298 3
@


1.9
log
@Fix HAL_ControllerAddress clashing with OS_Memory 9
Detail:
  s/Boot - Changed the 82C710/SuperIO/SMC37C665/whatever to be controller #34 instead of controller #6. This stops it clashing with the tube ULA allocation, and matches the controller number that ROL are using.
  s/ATA - Use C710_Address instead of a hardcoded offset from IOMD_Address
Admin:
  Tested in ROM softload on RiscPC


Version 0.10. Tagged as 'IOMD-0_10'
@
text
@d20 1
a26 3
                GBLL    CheckProtectionLink     ; if true, disallow CMOS RAM changes if link in protected position
CheckProtectionLink SETL (IO_Type = "IOMD") :LAND: {TRUE}       ; NB affects Delete/Copy/R/T and 0-9/.

d32 2
d35 3
d39 1
a40 64
                GBLL    VCOstartfix
VCOstartfix     SETL    {TRUE}

        GBLL    A7000
A7000   SETL    {TRUE} ; Should be replaced with auto-detect ASAP

                GBLL    RO371Timings
RO371Timings    SETL    :LNOT: STB

                GBLL    IgnoreVRAM
IgnoreVRAM      SETL    {FALSE}

VideoPhysRam *  &02000000               ; Amazing - it's in the same place!
DRAM0PhysRam *  &10000000               ; 4 DRAM banks
DRAM1PhysRam *  &14000000
DRAM2PhysRam *  &18000000
DRAM3PhysRam *  &1C000000
DRAMBaseAddressMask * &1C000000         ; used to mask off bits after stealing video RAM
SAMLength *     512*4                   ; SAM length in bytes for 1 bank of VRAM

; This version assumes a RISC OS image starting 64K after us.

        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        ENTRY

HAL_Base

vectors
;	B	start
        LDR     pc, ResetInd            ; Reset
        LDR     pc, HaltInd             ; Undefined instruction
        LDR     pc, HaltInd             ; SWI
        LDR     pc, HaltInd             ; Prefetch abort
        LDR     pc, HaltInd             ; Data abort
        LDR     pc, HaltInd             ; (Address exception)
        LDR     pc, HaltInd             ; IRQ
        LDR     pc, HaltInd             ; FIQ

; The above 8 instructions will operate as expected in 32-bit ROM mode,
; or in 16-bit ROM mode with a 16-bit ROM used.  In 16-bit ROM mode, and
; with 32-bit wide ROMs in use, they will instead be intepreted as 4
; NV-condition instructions (exact meaning not determined and should be
; irrelevant) which should do nothing and so allow control to drop
; through to this point, still in 16-bit mode.  Force IOMD into 32-bit
; ROM mode for bank 0.  The following instruction sequence has been
; produced in 16-in-32 form by extracting hex values from a listing...

        DCD     &0000B632, &0000E3A0    ; 20: MOV R11, #IO+IOMDREGS - point at IOMD
        DCD     &00000000, &0000E3A0    ; 28: MOV R0, #&0 - ROMCR:32b,slow,218.75us,no burst
        DCD     &00000080, &0000E5CB    ; 30: STRB R0,[R11,#ROMCR0] - switch mode
        DCD     &0000F000, &0000E3A0    ; 38: MOV PC, #0 - jump to 0 (this instr pre-fetched)

ResetInd
        DCD     start - HAL_Base
HaltInd
        DCD     halt - HAL_Base

halt    B       halt

        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
ROMsize
        DCD     0                       ; patched in by build system
d45 1
a45 1
        DCD     64*1024
d117 1
d119 3
a121 3
	IMPORT   HAL_ATAControllerInfo
	IMPORT   HAL_ATASetModes
	IMPORT   HAL_ATACableID
d127 5
d229 1
a229 1
        NullEntry ;HAL_Reset
d255 6
a262 8
; R11 is used as pointer to RISC OS entry table throughout pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

a269 746

start
        ADRL    R5, HAL_Base + 64*1024          ; R5 -> RISC OS image

        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table

        MOV     R0, #0
        CallOSM OS_InitARM

  ;      LDR     R13, =&10001000

        MOV     r12, #IOMD_Base

; Perform a dummy write to IOMD (some harmless register) to get it out of ROM force mode.
; Reads from IOMD will return garbage before this has happened. If we're actually running out
; of 32-bit wide ROMs on MORRIS, a write will already have happened, to get ROMCR0 from
; 16 to 32-bit wide mode, but we can't yet determine for sure (by reading it back), so do it
; anyway.

        STRB    r12, [r12, #IOMD_DMAREQ]              ; writes to DMAREQ are ignored

        LDRB    r2,[r12,#IOMD_ID1]      ; load r2 with IOMD ID high byte
        LDRB    r0,[r12,#IOMD_ID0]      ; load r0 with IOMD ID low byte
        ORR     r0,r0,r2, LSL #8        ; Or r0 and r2 - shifted left 8, put in r0
        LDR     r2,=IOMD_7500           ; get Ref IOMD ID code for IOMD in a 7500
        CMPS    r0,r2                   ; check for IOMD ID Code for IOMD in a 7500
        BEQ     init7500cpu             ; If equal, got to init7500cpu

        LDRNE   r2,=IOMD_7500FE         ; If not, get ID code for IOMD in a 7500FE
        CMPNES  r0,r2                   ; If not, check for IOMD ID Code for IOMD in a 7500FE
        BNE     MedusaInit              ; NOT MORRIS assume Medusa hardware


init7500FEcpu
; Here bceause its an ARM7500 'FE' variant
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-

;       CPUCLK divide by 1
;       MEMCLK divide by 2
;       IOCLK  divide by 2
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkHalf + IOMD_CLKCTL_IOclkHalf
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all the prescalers.
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...
;
        LDRB    r0, [r12, #IOMD_ROMCR0]         ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]         ; Prog. the reg.s

; Program the 2nd ROM bank

        STRB    r0, [r12, #IOMD_ROMCR1]         ; 2nd bank unused: program it the same anyway


; Now program ASTCR to add wait states, since MEMCLK is fast relative to IOCLK

        MOV     r0, #IOMD_ASTCR_WaitStates
        STRB    r0, [r12, #IOMD_ASTCR]

        B       init7500cpu_common              ; branch to common init code.
;

init7500cpu
; Here because its an ARM7500 variant - NON 'FE' device.
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;       CPUCLK divide by 1
;       MEMCLK divide by 1
;       IOCLK  divide by 1
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all prescalers to div1
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...

        LDRB    r0, [r12, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]          ; Prog. the reg.s

; Program the 2nd ROM bank

        STRB    r0, [r12, #IOMD_ROMCR1]         ; Program the 2nd bank the same as the 1st


; Now program ASTCR to *NOT* add wait states, since MEMCLK is slow relative to IOCLK

        MOV     r0, #IOMD_ASTCR_Minimal
        STRB    r0, [r12, #IOMD_ASTCR]

;
;
init7500cpu_common
; Common setup requirments for BOTH 7500 and 7500FE.
;
; MORRIS doesn't support VRAM. Kryten has same DRAM speed as Medusa
;
        MOV     r0, #IOMD_VREFCR_REF_16                         ; select 16µs refresh
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
        STRB    r0, [r12, #IOMD_ECTCR]

        B       CommonInit

        LTORG

MedusaInit

        ; we know we might meet StrongARM 110, enable fast core clock if so
        ; (grey area - clocking regarded as HAL rather than kernel problem)
        ;
        MRC     p15, 0, r0, c0, c0, 0   ; read id
        AND     r0, r0, #&F000
        TEQ     r0, #&A000              ; is that my old friend, StrongARM?
        MCREQ   p15, 0, r0, c15, c1, 2  ; enable fast core clock

        MOV     r0, #&12    ; 5-3 cycle ROM access

        STRB    r0, [r12, #IOMD_ROMCR0]
        STRB    r0, [r12, #IOMD_ROMCR1]         ; and do the same for extension ROMs (just in case)
        MOV     r0, #IOMD_VREFCR_VRAM_256Kx64 :OR: IOMD_VREFCR_REF_16   ; select 16µs refresh, assume 2 banks of VRAM
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
        STRB    r0, [r12, #IOMD_ECTCR]

CommonInit

 [ {FALSE}
; Turn off VIDC (set power down bit in control register)

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        MOV     R0, #1:SHL:14   ; we may get vsync interrupts that stiff us
        ORR     R0, R0, #&E0000000
        STR     R0, [R1]
 |
; VInit etc set on ze mode change: no DMA going yet so don't set owt.

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        ADRL    R2, VIDCTAB     ; we may get vsync interrupts that stiff us
10      LDR     R0, [R2], #4    ; permanently as VIDC is in an undefined state
        CMP     R0, #-1         ; so have mode 0 with all black palette
        STRNE   R0, [R1]
        BNE     %BT10

 ]

; Now bang IOC (disable all but keyboard interrupts)

        MOV     R1, #IOC
        MOV     R0, #&FF                ; all inputs
        STRB    R0, [R1, #IOCControl]   ; in case called by Tim

        MOV     R0, #0
        STRB    R0, [R1, #IOCIRQMSKA]   ; kein interrupts
	STRB	R0, [R1, #IOCIRQMSKB]
        STRB    R0, [R1, #IOCFIQMSK]    ; knob off, FIQ
        STRB    R0, [R1, #IOMD_DMAMSK]  ; disable DMA interrupts, too
        STRB    R0, [R1, #IOMD_IRQMSKC] ; and the rest...
        STRB    R0, [R1, #IOMD_IRQMSKD]

  [ Keyboard_Type = "PC"
        MOV     R0, #serial_Rx_bit      ; used for Archi keyboard or IOMD PC keyboard
  ]
        ;STRB    R0, [R1, #IOCIRQMSKB]   ; allow communication with kbd, when I_bit gets cleared

; now bits to allow CMOS read/write : need timer

        LDR     R0, =20000-1    ; R0 = Timer delay (units of 0.5 microsecond)
                                ; 20000*0.5E-6 = 0.01 Seconds (100Hz ticker)
                                ; TMD 21-May-93: "-1" correction applied

        STRB    R0, [R1, #Timer0LL]     ; Set up the delay
        MOV     R0, R0, LSR #8
        STRB    R0, [R1, #Timer0LH]
        STRB    R0, [R1, #Timer0GO]     ; and start the ticks

        MOV     R0, #timer0_bit
        STRB    R0, [R1, #IOCIRQCLRA]   ; Clear pending t0 interrupt j.i.c.

  [ VCOstartfix
        ;2nd part of fix for VCO failing to start on A7000 (esp. 7500FE) - forcing PCOMP high for about 3 ms
        LDRB    R0, [R1,#IOMD_ID0]
        CMP     R0, #&E7
        LDREQB  R0, [R1,#IOMD_ID1]
        CMPEQ   R0, #&D4
        BEQ     vcofix_notMorris      ; risky to force PCOMP on Risc PC
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000A46        ; VIDC20 FSYNREG, as in VIDCTAB but with force PCOMP high
        STR     R2, [R0]
        MOV     R0, #3072*2           ; time delay of about 3 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
vcofix_waitloop
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     vcofix_waitloop       ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     vcofix_waitloop       ; loop if not finished
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000A06        ; VIDC20 FSYNREG, as in VIDCTAB (PCOMP low again)
        STR     R2, [R0]
vcofix_notMorris
  ]

        MOV     R0, #0
        STRB    R0, [R1, #IOMD_ATODICR] ; power down the A to D convertor

; On breaks (ie software resets) we have to turn the MMU off.
; This is slightly tricky if we've been soft-loaded!

        MOV     r13, #0 ; No stack until we find the first RAM bank
        MOV     r12, #IOMD_Base

 [ MorrisSupport
;
        LDRB    r0, [r12, #IOMD_ID0]    ; load r1 with IOMD ID high byte
        LDRB    r1, [r12, #IOMD_ID1]    ; load r0 with IOMD ID low byte
        ORR     r0,r0,r1,LSL#8          ; Or r0 and r1, shifted left 8, put in r0
        LDR     r1,=IOMD_Original       ; get Ref IOMD ID code - original
        CMP     r0,r1                   ; check for IOMD ID Code - original
        BEQ     MemSizeIOMD             ; Not ID Code - original,
                                        ;    therefore jump to Medusa hardware code
                                        ;    else fall through to Morris code.
;
; MemSize for Morris
;
  [ RO371Timings
        MOV     r11, #&70     ;all 4 banks assumed 32 bit - EDO and timing bits set in case 7500FE (don't care bits otherwise)
  |
        MOV     r11, #IOMD_DRAMWID_DRAM_32bit * &0F     ;set all 4 banks to be 32bit initially
        LDR     r1, =IOMD_7500FE
        TEQ     r0, r1                                  ; are we on FE part?
        ORREQ   r11, r11, #IOMD_DRAMWID_EDO_Enable :OR: IOMD_DRAMWID_RASCAS_3 :OR: IOMD_DRAMWID_RASPre_3
                                                        ; if so, then enable EDO and slower RASCAS and RASPre times
        ! 0,"7500FE support expects EDO memory in s.ARM600"
  ]
        MOV     r14, #IOMD_Base
        STRB    r11, [r14, #IOMD_DRAMWID]
        MOV     r10, #0                                 ; R10 = reference pointer for OS_AddRAM
        MOV     r9, #IOMD_DRAMWID_DRAM_16bit            ;bit to OR into DRAMWID to set 16bit
        MOV     r0, #DRAM0PhysRam
;
; r0    DRAM address
; r9    IOMD_DRAMWID_DRAM_16bit for current DRAM bank
; r11   current IOMD_DRAMWID register contents
;
ExamineDRAMBank                                         ;examine first/next DRAM bank
;
        LDMIA   r0, {r1, r2}                            ;Preserve the two locations that we widdle on

        ADR     r3, funnypatterns                       ;We write different values to two locations
        LDMIA   r3, {r3, r4}                            ; incase bus capacitance holds our value
        STMIA   r0, {r3, r4}
        LDMIA   r0, {r5, r6}                            ;Reread test locations
        EORS    r5, r5, r3                              ;Both locations should read correctly
        EOR     r6, r6, r4                              ; if memory is 32bits wide
       ;TEQ     r5, #0
        TEQEQ   r6, #0
        BEQ     %FT05                                   ;32bit wide memory

        TST     r5, #&00FF                              ;If the bottom 16bits of each location
        TSTEQ   r5, #&FF00                              ; are correct, the memory is 16bits wide
        TSTEQ   r6, #&00FF
        TSTEQ   r6, #&FF00
        ADDNE   r0, r0, #DRAM1PhysRam-DRAM0PhysRam      ; move onto next bank
        BNE     NoRamInBank                             ;No memory in this bank

        ORR     r11, r11, r9                            ;Bank is 16bits wide
05
        STMIA   r0, {r1, r2}                            ;Restore the two locations we widdled on
                                                        ;Must do BEFORE poking the DRAMWID register
        MOV     r14, #IOMD_Base                         ;
        STRB    r11, [r14, #IOMD_DRAMWID]               ;

        BL      Add_DRAM_bank

NoRamInBank
        MOV     r9, r9, LSL #1                          ; shunt up position in DRAMWID
        CMP     r9, #&0010                              ; if more banks to do
        BLT     ExamineDRAMBank                         ; then loop

        MOV     r6, #0                                  ; No VRAM
        MOV     r0, #0
        MOV     r14, #IOMD_Base

        LDRB    r4, [r14, #IOMD_ID0]
        LDRB    r7, [r14, #IOMD_ID1]
        ORR     r4, r4, r7, LSL #8
        LDR     r7, =IOMD_7500FE                        ; if FE part, then assume EDO DRAM
        TEQ     r4, r7
        LDREQ   r2, =80000000                           ; so allow 80E6 bytes/s
 [ STB
        LDRNE   r2, =44000000                           ; else only allow 44E6 bytes/s
 |
        LDRNE   r2, =46500000                           ; if no VRAM, then 46.5E6 bytes/sec bandwidth
 ]
        MOV     r1, #IOMD_VIDCR_DRAMMode :OR: &10       ; if no VRAM, then turn on DRAM mode, and set increment to &10

        B       Allocate_DRAM

MemSizeIOMD
 ]

; Right, let's find out where our memory is


MemSizeIOMD_notSA

        MOV     r11, #IOMD_DRAMCR_DRAM_Large * &55      ; set all banks to be large initially
        MOV     r14, #IOMD_Base
        STRB    r11, [r14, #IOMD_DRAMCR]

        MOV     r10, #0                                 ; R10 = Reference pointer for OS_AddRAM
        MOV     r9, #IOMD_DRAMCR_DRAM_Small             ; bit to OR into DRAMCR
        MOV     r0, #DRAM0PhysRam
10
        ADD     r1, r0, #A10                            ; this should be OK for both configurations
        BL      DistinctAddresses
        ADDNE   r0, r0, #DRAM1PhysRam-DRAM0PhysRam      ; move onto next bank
        BNE     %FT15                                   ; [no RAM in this bank at all]

        ADD     r1, r0, #A11                            ; test for 256K DRAM
        BL      DistinctAddresses
        ORRNE   r11, r11, r9                            ; it is, so select small multiplexing
        MOVNE   r14, #IOMD_Base
        STRNEB  r11, [r14, #IOMD_DRAMCR]                ; store new value of DRAMCR, so we can use memory immediately

        BL      Add_DRAM_bank

; Now, we have to find a bank of DRAM, so we've got somewhere to store our results!
15
        MOV     r9, r9, LSL #2                          ; shunt up position in DRAMCR
        CMP     r9, #&100                               ; if more banks to do
        BCC     %BT10                                   ; then loop

; Now, we check out the VRAM.
; Don't bother checking for more than 2M of VRAM, because we don't know what the 1/2 SAM length is for larger sizes

        MOV     r2, #IOMD_VREFCR_VRAM_256Kx64 :OR: IOMD_VREFCR_REF_16 ; assume 2 banks of VRAM by default
        STRB    r2, [r12, #IOMD_VREFCR]

; Check for 8mb VRAM - for RPCemu
	MOV	r0, #VideoPhysRam
	ADD	r1, r0, #A22
	BL	DistinctAddresses
	MOVEQ	r6, #8
	BEQ	%FT20

        MOV     r0, #VideoPhysRam                       ; point at VRAM
        ADD     r1, r0, #A2                             ; test A2
        BL      DistinctAddresses
        MOVEQ   r6, #2                                  ; we've got 2M of VRAM
        BEQ     %FT20

        MOV     r2, #IOMD_VREFCR_VRAM_256Kx32 :OR: IOMD_VREFCR_REF_16
        STRB    r2, [r12, #IOMD_VREFCR]
        ADD     r1, r0, #A2                             ; check for any VRAM at all
        BL      DistinctAddresses
        MOVEQ   r6, #1                                  ; we've got 1M of VRAM
        MOVNE   r6, #0                                  ; no VRAM
20
 [ IgnoreVRAM
        MOV     r6, #0                                  ; pretend there's no VRAM
 ]
        CMP     r6, #1
        MOVCC   r1, #IOMD_VIDCR_DRAMMode :OR: &10       ; if no VRAM, then turn on DRAM mode, and set increment to &10
        MOVEQ   r1, #SAMLength/2/256                    ; if 1M VRAM, then use VRAM mode, and set increment for 1/2 SAM
        MOVHI   r1, #SAMLength/2/256*2                  ; if 2M VRAM, then use VRAM mode, and set increment for 2*1/2 SAM
        LDRCC   r2, =46500000                           ; if no VRAM, then 46.5E6 bytes/sec bandwidth
        LDREQ   r2, =80000000                           ; if 1M VRAM, then 80E6   ---------""--------
        LDRHI   r2, =160000000                          ; if 2M VRAM, then 160E6  ---------""--------
        MOVCC   r0, #0                                  ; Clear VRAM base if there is no VRAM

; Allocate_DRAM
;   r0  = Video base if r6!=0
;   r1  = Value for IOMD VIDCR
;   r2  = Bandwidth limit
;   r6  = VRAM size in Mb
;   r10 = OS_AddRAM ref ptr
Allocate_DRAM
        ; Tell IOMD about VRAM.
        ; We don't need to worry about r1/r2/etc. - Video_init can reverse-engineer the values from IOMD_VIDCR and from the machine type
        MOV     r14, #IOMD_Base
        STRB    r1, [r14, #IOMD_VIDCR]

        ADRL    R5, HAL_Base + 64*1024          ; R5 -> RISC OS image
        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table

        ; Tell OS about VRAM
        CMP     R6,#0
        MOVEQ   R3,R10                 ; parameter for OS_Start
        BEQ     NoVRAM
        MOV     R1,R0
        ADD     R2,R1,R6,LSL #20
        LDR     R3,=&FFFFFFFF
        Push    "R10"
        LDR     R0,=4:SHL:8+1
        CallOSM OS_AddRAM
        ADD     R13,R13,#4
        MOV     R3, R0                 ; parameter for OS_Start
NoVRAM

; Check the various reset flags

        MOV     R0, #0
        MOV     R12, #IOC
        LDRB    R1, [R12, #IOCIRQSTAA]
        ANDS    R1, R1, #por_bit
        STRNEB  R1, [R12, #IOCIRQCLRA]  ; clear POR if set
        ORRNE   R0, R0, #OSStartFlag_POR

 [ CheckProtectionLink
        LDR     R2, =IOMD_MonitorType

; on Issue A's the protection bit is only weakly pulled up,
; so force it high, then read it back

        LDRB    R1, [R2]
        ORR     R1, R1, #IOMD_ProtectionLinkBit
        STRB    R1, [R2]
        LDRB    R1, [R2]
        TST     R1, #IOMD_ProtectionLinkBit
        ORRNE   R0, R0, #OSStartFlag_NoCMOSReset
 ]

 [ STB :LAND: IOMD_C_FrontPanelButton <> 0
  [ FrontPanelButtClearsCMOS
        LDRB    R1, [R12, #IOMD_CLINES] ; if front panel button pressed then CMOS reset
        TST     R1, #IOMD_C_FrontPanelButton
        ORRNE   R0, R0, #OSStartFlag_CMOSReset
  ]
 ]

        MOV     R1, R5
        ADRL    R2, HALdescriptor
        CallOSM OS_Start

funnypatterns
        &       &66CC9933   ; 0110 1100 1001 0011
        &       &CC993366   ; 1100 1001 0011 0110

        LTORG

; add_dram_bank
;   Entry: r10 -> workspace (initially 0)
;          r0  =  bank address
;   Exit:  r10 -> workspace (allocated if 0 on entry)
;          r0  =  next bank address
;          r9, r11, r13 preserved
;   Probe a DRAM bank, and add any DRAM found to the workspace
Add_DRAM_bank
        ROUT
        MOV     r12, lr                 ; r12 = return address
        EOR     r1, r0, #A16            ; Check there is some RAM in the bank
        BL      DistinctAddresses
        ADDNE   r0, r0, #DRAM1PhysRam-DRAM0PhysRam
        MOVNE   pc, r12                 ; Return if no RAM in the bank

        ; Only some address lines are decoded by the SIMM.  For example, a 4M SIMM may be split
        ; into 2 banks, with A2-A20 decoded on each, or A2-A19,A21 decoded.  First we need to
        ; find out which address lines are decoded, and which are ignored.
        MOV     r6, #DRAM1PhysRam-DRAM0PhysRam
        MOV     r7, #A17
        SUB     r6, r6, #1              ; Get address lines which select address within bank.

        ; Loop through the address lines, finding out which are decoded.  We clear the bits in r6
        ; which correspond to non-decoded address lines.
        ; r6 = address line mask
        ; r7 = current address line
10      EOR     r1, r0, r7              ; Toggle the address line
        BL      DistinctAddresses       ; Check if address line has any effect.
        BICNE   r6, r6, r7              ; Clear the bit if the address line fails.
        MOV     r7, r7, LSL #1          ; Move onto the next address line.
        TST     r6, r7                  ; Have we reached the limit?
        BNE     %BT10                   ; Repeat if not.

        ; r6 = decoded address lines in bank. (ie in A0-A25)
        ; r7 = The size of the DRAM bank
        ; Since the DRAM bank may not be contiguous, we now split the bank up into contiguous
        ; blocks.  We make these as large as possible to save work.  Here we set r8 to the
        ; size of the smallest contiguous block(s) of RAM.  (There will also be some contiguous
        ; blocks which are twice this size in some cases.)
        ADD     r8, r6, #A17
        BIC     r8, r8, r6              ; r8 = First clear bit in r6 from A17 up.

        RSB     r4, r8, #0              ; r4 = All bits at or above r8 set since r8 is a power of 2.

        RSB     r7, r7, #0              ; r7 = address bits which select the bank since r7 was a
                                        ;      power of 2.
        ORR     r3, r7, r6              ; r3 = All decoded address lines.
        AND     r7, r4, r3              ; r7 = All decoded bits at or above r8.

; Make sure that the dram bank may not be contained within the image.  The code below fails
; to work correctly if a dram bank is contained within an OS image.  Currently this would
; require an image larger than 64M.
                ASSERT  OSROM_ImageSize*1024 <= DRAM1PhysRam-DRAM0PhysRam

15      MOV     r1, r0                  ; r1 = Address of start of block (inclusive).
        ADD     r2, r1, r8              ; r2 = End of the block (exclusive).

        ; Move the end of the block if the OS image begins in this block.
        ADRL    r4, HAL_Base            ; r4 = Start of the OS image (which may be in RAM).
        EOR     r5, r4, r1              ; r5 = Difference between image and memory block.
        TST     r5, r7                  ; Check if the image begins in this block of RAM.
        ANDEQ   r2, r4, r3              ; Set end of block to start of image.

        ; Move the start of the block if the OS image ends in this block.
        ADD     r4, r4, #OSROM_ImageSize*1024
        SUB     r4, r4, #1              ; r4 = Last byte of the OS image.
        EOR     r5, r4, r1              ; r5 = Difference between end of image and block.
        TST     r5, r7                  ; Check if the image ends in this block of RAM.
        ANDEQ   r5, r4, r3              ; r5 = Address of last byte of the image within this block.
        ADDEQ   r1, r5, #1              ; Set start of block to the byte after the image.

        ; If the image is contained in the block, we will have swapped the start and end
        ; addresses.  This means that the block is split into two parts.  The bit below
        ; the image and the bit above the image.
        CMP     r1, r2
        BLS     %FT20                   ; If start <= end, then block is not fragmented.
        CMP     r2, r0                  ; Check the size of the fragment before the image.
        MOV     r0, r1                  ; Store old start address
        AND     r1, r1, r7              ; Get the start of the block
        BLNE    Allocate_DRAM_fragment  ; Allocate it if it's non-zero.
        MOV     r1, r0                  ; Restore the old start of fragment
        AND     r0, r0, r7              ; Get the start of the block again.
        ADD     r2, r0, r8              ; End of next fragment is the end of the block.

        CMP     r1, r2                  ; Compare start and (modified) end.
20      BLNE    Allocate_DRAM_fragment

        ; Now move onto the next block.  We add the non-decoded address lines to cause the
        ; carry to be propagated across them.  Then we mask them out.
        MVN     r4, r7                  ; Add the non-connected address lines to ...
        ADD     r4, r4, r0              ; ... the block address ...
        ADD     r4, r4, r8              ; ... and the block size.
;       EOR     r5, r0, r4              ; Compare with old address
        AND     r0, r4, r7              ; Leave only the decoded lines set.
;       BIC     r5, r5, r6              ; Clear decoded lines within the bank.
;       TST     r5, r7                  ; Check only the bank lines.
;       BEQ     %BT15                   ; Repeat for next block.

        TST     r0, r6
        BNE     %BT15

        MOV     pc, r12                 ; Done for this bank.

; Allocate_DRAM_block
;   Entry:
;     r1 = block start (inclusive)
;     r2 = block end (exclusive)
;     r3 = All decoded address lines
;     r7 = All decoded bits at or above r8
;     r8 = Size of largest contiguous block
;     block length is assumed to be at least the size of the static data - ie. 160k
;     The maximum block list size is then 4k, which fits easily into the cursor chunk
;   Exit:
;     r10 updated
;     r0, r3, r6-r9, r11-r13 preserved
;     r10 points to a word containing the number of blocks stored.
;     The pairs of words before
Allocate_DRAM_fragment
        ; Set up stack (if required) and call OS_AddRAM
        CMP     r13, #0
        ADDEQ   r13, r1, #4096 ; Top of first page is 'best'
        Push    "r0-r9,r11-r12,lr" ; Hello stack!
        MOV     r0, #4:SHL:8 ; TODO - set flags
        ; r1, r2 are correct
        LDR     R3, =&FFFFFFFF
        ; r3 should be correct?
        Push    "r10" ; Push reference ptr
        ADRL    R5, HAL_Base + 64*1024          ; R5 -> RISC OS image
        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table
        CallOSM OS_AddRAM
        ADD     R13,R13,#4
        MOV     r10, r0 ; Keep reference
        Pull    "r0-r9,r11-r12,pc"

; DistinctAddresses routine...
; r0,r1 are the addresses to check
; uses r2-5
; writes interleaved patterns (to prevent dynamic storage...)
; checks writing every bit low and high...
; return Z-flag set if distinct

; This routine must work in 32-bit mode

DistinctAddresses ROUT
        LDR     r2, [r0] ; preserve
        LDR     r3, [r1]
        LDR     r4, Pattern
        STR     r4, [r0] ; mark first
        MOV     r5, r4, ROR #16
        STR     r5, [r1] ; mark second
        LDR     r5, [r0]
        CMP     r5, r4 ; check first
        BNE     %10    ; exit with Z clear
        LDR     r5, [r1] ; check second
        CMP     r5, r4, ROR #16 ; clear Z if not same
        BNE     %10
; now check inverse bit writes
        STR     r4, [r1] ; mark second
        MOV     r5, r4, ROR #16
        STR     r5, [r0] ; mark first
        LDR     r5, [r1]
        CMP     r5, r4 ; check second
        BNE     %10   ; exit with Z clear
        LDR     r5, [r0] ; check first
        CMP     r5, r4, ROR #16 ; clear Z if not same
10      STR     r3, [r1] ; restore
        STR     r2, [r0]
        MOV     pc, lr                  ; Z flag is already set up, and other flags don't matter

Pattern
        &       &AAFF5500 ; shiftable bit check pattern

; Constants
;
A0      *       1 :SHL: 00
A1      *       1 :SHL: 01
A2      *       1 :SHL: 02
A3      *       1 :SHL: 03
A4      *       1 :SHL: 04
A5      *       1 :SHL: 05
A6      *       1 :SHL: 06
A7      *       1 :SHL: 07
A8      *       1 :SHL: 08
A9      *       1 :SHL: 09
A10     *       1 :SHL: 10
A11     *       1 :SHL: 11
A12     *       1 :SHL: 12
A13     *       1 :SHL: 13
A14     *       1 :SHL: 14
A15     *       1 :SHL: 15
A16     *       1 :SHL: 16
A17     *       1 :SHL: 17
A18     *       1 :SHL: 18
A19     *       1 :SHL: 19
A20     *       1 :SHL: 20
A21     *       1 :SHL: 21
A22     *       1 :SHL: 22
A23     *       1 :SHL: 23
A24     *       1 :SHL: 24
A25     *       1 :SHL: 25
A26     *       1 :SHL: 26
A27     *       1 :SHL: 27
A28     *       1 :SHL: 28
A29     *       1 :SHL: 29
A30     *       1 :SHL: 30
A31     *       1 :SHL: 31

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data tables: VIDC := mode 0, all palette black

VIDCTAB DATA
; Program Control Register first, to clear power-down bit
; Now depending upon the VIDCClockSource flag, re-program the clock source.
   [ VIDCClockSource = "VCO"
     [ VCOstartfix
        & &E0000404     ; CR: FIFO load 16 words, 1 bpp, ck/2, vclk (allow for doubled VCO freq)
     |
        & &E0000400     ; CR: FIFO load 16 words, 1 bpp, ck/1, vclk
     ]
   ]
   [ VIDCClockSource = "HCLK"
        & &E0000401     ; CR: FIFO load 16 words, 1 bpp, ck/1, hclk
   ]
   [ VIDCClockSource = "RCLK"
        & &E0000406     ; CR: FIFO load 16 words, 1 bpp, ck/2, rclk
   ]

; Don't bother programming all 256 palette entries, we'll be here all night
; Since we're setting up a 1 bit-per-pixel mode, just do colours 0 and 1

        & &10000000     ; Palette address register = 0
        & &00000000     ; Colour 0 = black
        & &00000000     ; Colour 1 = black
        & &40000000     ; Border colour = black
        & &50000000     ; Pointer colour 1 = black
        & &60000000     ; Pointer colour 2 = black
        & &70000000     ; Pointer colour 3 = black

; Get a stable display up so we get stable signals

        & &80000318     ; HCR + 8 = 94 + 22 + 22 + 640 + 22 + 0
        & &81000056     ; HSWR+ 8 = 94
        & &82000068     ; HBSR+12 = 94 + 22
        & &83000078     ; HDSR+18 = 94 + 22 + 22
        & &840002F8     ; HDER+18 = 94 + 22 + 22 + 640
        & &85000314     ; HBER+12 = 94 + 22 + 22 + 640 + 22
        & &86000079     ; HCSR+17 = HDSR+18

        & &9000020B     ; VCR +2 = 2 + 32 + 0 + 480 + 0 + 11
        & &91000000     ; VSWR+2 = 2
        & &92000021     ; VBSR+1 = 2 + 32
        & &93000021     ; VDSR+1 = 2 + 32 + 0
 [ MEMC_Type = "IOMD"
        & &94000201     ; VDER+1 = 2 + 32 + 0 + 480
 | ;MEMC_Type <> "IOMD"
        & &94000201     ; VDER+1 = 2 + 32 + 0 + 480
 ] ;MEMC_Tupe = "IOMD"
        & &95000201     ; VBER+1 = 2 + 32 + 0 + 480 + 0
        & &96000021     ; VCSR+1 = VDSR+1
        & &97000021     ; VCER+1 = VDSR+1

        & &B1000001     ; SCR: sound disabled (+use 24MHz clock)

        & &C00F1003     ; EREG = comp sync, DACs on, ereg output ext lut
   [ VCOstartfix
        & &D0000A06     ; FSYNREG, clk = (10+1)/(6+1) * 32MHz = 50.286MHz  (higher frequency as part of fix)
   |
        & &D0000A0D     ; FSYNREG, clk = (10+1)/(13+1) * 32MHz = 25.143MHz
   ]
        & &F0013000     ; DCR: bus D[31:0], Hdisc       ;RCM 29/9/94: changed from &F0012000 at PSwindells request
        & &FFFFFFFF     ; That's the lot

IOPhys          *       &03000000
IOSize          *       &00800000

EASIPhys        *       &08000000
EASISlotSize    *       &01000000
EASISlotSizeShift *     24
EASISlots       *       8
EASISize        *       EASISlotSize * EASISlots

IOMDPhys        *       &03200000
VIDCPhys        *       &03400000       ; used to address VIDC when MMU is off
C710Phys        *       &03010000       ; 82C710/SuperIO/SMC37C665/whatever you want to call it

ROMBank1Phys    *       &01000000       ; For HAL_CleanerSpace

d306 1
a306 1
	LDR 	a1, C710_Address  	; Get C710/SuperIO
d308 13
a320 13
	MOV	a2, #0x55               ; Enter config mode
	STRB	a2, [a1, #0xfc0]
	STRB	a2, [a1, #0xfc0]
	MOV	a2, #0x0d
	STRB	a2, [a1, #0xfc0]

	ADR	a2, SuperIOTab
SPL	LDRB 	a3, [a2], #1
	CMP	a3, #0xff
	LDRNEB  a4, [a2], #1
	STRNEB	a3, [a1, #0xfc0]
	STRNEB  a4, [a1, #0xfc4]
	BNE 	SPL
d322 2
a323 2
	MOV 	a2, #0xaa       	; Leave config mode
	STRB	a2, [a1, #0xfc0]
d423 1
a423 1
        CMP     a1, #0 ; ROM bank 0?
d445 120
a566 9

        ! 0, "TODO - Sort out keyboard scan for IOMD HAL"
HAL_KbdScan
        MOV     a1, #&C0000000 ; scan complete, keyboard present
HAL_KbdScanSetup
HAL_KbdScanInterrupt
HAL_KbdScanFinish
        MOV     pc, lr

d568 2
a569 2
	= 0x01,0x87,0x02,0x1c,0x03,0x78,0x04,0x03,0x05,0x00,0x06,0xff
	= 0x07,0x00,0x08,0x00,0x09,0x00,0x0a,0x00,0x00,0xbb,0xff
@


1.8
log
@Fix HAL_CleanerSpace. Improve HAL_PlatformInfo.
Detail:
  hdr/StaticWS, s/Boot - Fixed HAL_CleanerSpace implementation to return the physical address of the cleaner area instead of the logical address
  s/Boot - Improve HAL_PlatformInfo to provide an indication of whether the OS is running from RAM or ROM
Admin:
  Tested in ROM softload on RiscPC


Version 0.09. Tagged as 'IOMD-0_09'
@
text
@d1068 1
a1068 1
C710Phys        *       &03010000       ; 82C710/SuperIO
d1156 3
a1158 1
        CMP     a2, #6
a1165 2
        MOV     pc, lr
        B       ca_82C710
@


1.7
log
@IOMD HAL improvements
Detail:
  Makefile - Specify link base address to fix any absolute address issues
  s/Boot - Add support for new HAL_ControllerAddress reason code to get the 82C710 address. Correct HAL_HardwareInfo. Make HAL_CleanerSpace return the address of ROM bank 1, as per pre-HAL kernel.
  hdr/StaticWS - New workspace entries for 82C710 & CleanerSpace addresses
Admin:
  Tested in ROM softload on RiscPC


Version 0.08. Tagged as 'IOMD-0_08'
@
text
@a1079 5
        MOV     a2, #ROMBank1Phys
        MOV     a3, #64*1024
        CallOS  OS_MapInIO
        STR     a1, CleanerSpace
        MOV     a1, #0
d1218 14
a1231 6
        LDMEQIA a4, {a4,ip}
        STREQ   a4, [a2]
        STREQ   ip, [a3]
        MOVEQ   pc, lr
        ADD     a4, a4, #2*4
        B       %BT82
d1233 4
a1236 4
        DCD     IOMD_Original :AND: &FF, &00000005, &0000000F
        DCD     IOMD_7500     :AND: &FF, &00000001, &0000000F
        DCD     IOMD_7500FE   :AND: &FF, &00000001, &0000000F
        DCD     IOMD_IOMD2    :AND: &FF, &0000000F, &0000000F
d1244 1
a1244 1
        LDR     a1, CleanerSpace
@


1.6
log
@  Added RPCEmu support
Detail:
  Not supplied
Admin:
  Changes by Tom Walker

Version 0.07. Tagged as 'IOMD-0_07'
@
text
@d1068 3
d1080 5
d1093 2
d1113 1
a1113 2
	LDR 	a1, IOMD_Address  	; SuperIO at IOMD-0x1f0000
	SUB	a1, a1, #0x1f0000
d1161 1
a1161 1
        CMP     a2, #4
d1169 2
d1194 5
d1200 1
a1200 1
        LDR     ip, =&01010101
d1241 1
a1241 5
        [ {FALSE}
          ???don't know what do yet, in generic memory size case
        |
          MOV   a1, #&10000000  ; return start of physical RAM
        ]
@


1.5
log
@Tweak IOMD HAL NVRAM settings and add dummy keyboard scan code to get CMOS working properly
Detail:
  s/NVRAM - Changed the NVRAM setting from 'MaybeIIC' to just 'IIC', as a workaround for RPCemu's apparently buggy support for IIC probing (plus we know the address of the RTC/CMOS chip anyway - no need for the kernel to probe for it)
  s/Boot - Add dummy keyboard scan functions, so kernel doesn't think the CMOS reset keys are being held down on each boot.
Admin:
  Tested under RPCemu. CMOS settings now seem to load and save properly.


Version 0.06. Tagged as 'IOMD-0_06'
@
text
@d66 1
d178 3
d284 2
a285 2
        NullEntry ;HAL_DebugRX             
        NullEntry ;HAL_DebugTX             
d287 2
a288 2
        NullEntry ;HAL_PCIFeatures         
        NullEntry ;HAL_PCIReadConfigByte   
d290 2
a291 2
        NullEntry ;HAL_PCIReadConfigWord   
        NullEntry ;HAL_PCIWriteConfigByte  
d293 15
a307 15
        NullEntry ;HAL_PCIWriteConfigWord  
        NullEntry ;HAL_PCISpecialCycle     
        NullEntry ;HAL_PCISlotTable        
        NullEntry ;HAL_PCIAddresses        

        NullEntry ;HAL_ATAControllerInfo   
        NullEntry ;HAL_ATASetModes         
        NullEntry ;HAL_ATACableID          

        NullEntry ;HAL_InitDevices         

        HALEntry HAL_KbdScanSetup        
        HALEntry HAL_KbdScan             
        HALEntry HAL_KbdScanFinish       
        HALEntry HAL_KbdScanInterrupt    
d492 1
d501 1
a501 1
        STRB    R0, [R1, #IOCIRQMSKB]   ; allow communication with kbd, when I_bit gets cleared
d681 7
d1102 21
d1243 3
@


1.4
log
@Add DRAM + VRAM detection logic to IOMD HAL
Detail:
  s/Boot - Added DRAM + VRAM detection code, taken from the pre-HAL bits of the kernel.
  s/Video - Calculate VRAMWidth by reverse-engineering the value programmed into IOMD_VIDCR
Admin:
  Tested under RPCemu - seems to detect correct DRAM + VRAM sizes for all of the combinations supported by RPCemu.


Version 0.04. Tagged as 'IOMD-0_04'
@
text
@d280 24
d1201 10
@


1.3
log
@  Updating and development of the IOMD HAL.
Detail:
  * Resolved multiple declaration of HighestOSEntry
  * Extended IRQ code to modern HAL API
  * New FIQ code, partially copied from Tungsten HAL
  * Added HAL_PlatformInfo and HAL_NVMemoryPageSize, both additional
    requirements of recent kernels
  * Default hard-coded screen mode changed to VGA timings - few modern monitors
    will sync down to the old TV rate modes
  * RAM map hard-coded to match the A7000 I'm using for development
    (previously was hard-coded for a 2MB VRAM + 16 MB DRAM Risc PC -
    ultimately, we need to merge in the autodetection code from non-HAL kernels)
  * Video DMA width tweaked so it works on non-VRAM machines (again this should
    be autodetected)
Admin:
  Known issues include: OS_Reset and hardware scrolling don't work
                        CMOS appears to be reset on every boot
  Work in progress

Version 0.02. Tagged as 'IOMD-0_02'
@
text
@d43 13
d308 1
a308 1
        LDR     R13, =&10001000
d448 1
a448 1
        ADR     R2, VIDCTAB     ; we may get vsync interrupts that stiff us
d521 2
d524 36
a559 10
 [ {FALSE}
  ; Config for Dave's medusa
        MOV     R0, #4:SHL:8
        LDR     R1, =&10000000
        ADD     R2, R1, #&00400000
        LDR     R3, =&FFFFFFFF
        MOV     R12, #0
        STR     R12, [R13, #-4]!
        CallOSM OS_AddRAM
        STR     R0, [R13]
d561 47
a607 6
        MOV     R0, #4:SHL:8
        LDR     R1, =&14000000
        ADD     R2, R1, #&00400000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]
d609 1
a609 20
        MOV     R0, #4:SHL:8
        LDR     R1, =&1C000000
        ADD     R2, R1, #&00400000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]
  |
  ; The Risc PC (RAM from 10000000 - 11000000, ROM image at 10B00000-10F00000)
  ;
        ! 0, "HAL assumes fixed 16M memory @@ 10000000"
  ;
 [ :LNOT: A7000
        MOV     R0, #4:SHL:8
        LDR     R1, =&10000000
        ADD     R2, R1, #&00B00000
        LDR     R3, =&FFFFFFFF
        MOV     R12, #0
        STR     R12, [R13, #-4]!
        CallOSM OS_AddRAM
        STR     R0, [R13]
d611 1
a611 15
        MOV     R0, #4:SHL:8
        LDR     R1, =&10F00000
        ADD     R2, R1, #&00100000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]
 |
        MOV     R0, #4:SHL:8
        LDR     R1, =&10000000
        ADD     R2, R1, #&00800000
        LDR     R3, =&FFFFFFFF
        MOV     R12, #0
        STR     R12, [R13, #-4]!
        CallOSM OS_AddRAM
        STR     R0, [R13]
d614 4
a617 1
  ]
d619 48
a666 9
 [ :LNOT: A7000 ; no vram on A7000
        LDR     R0, =4:SHL:8 + 1
        LDR     R1, =&02000000
        ADD     R2, R1, #&00200000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        ADD     R13, R13, #4
 |
        LDR     R0, [R13], #4
d668 24
d693 13
a705 1
        MOV     R3, R0                  ; parameter for OS_Start
d739 1
a739 1
        ADR     R2, HALdescriptor
d742 4
d748 208
@


1.2
log
@Merged IOMD HAL to trunk.

Version 0.01. Tagged as 'IOMD-0_01'
@
text
@d40 3
d113 7
a119 1
        IMPORT   HAL_FIQDisableCode
d141 1
d176 7
a182 1
        HALEntry HAL_FIQDisableCode
d199 1
d210 3
d243 1
d483 1
a483 1
        LDR     R2, =&D0000342        ; VIDC20 FSYNREG, as in VIDCTAB but with force PCOMP high
d497 1
a497 1
        LDR     R2, =&D0000302        ; VIDC20 FSYNREG, as in VIDCTAB (PCOMP low again)
d538 1
d554 10
d567 1
d574 3
d650 12
a661 12
        & &800003F8     ; HCR  = 76 + 88 + 96 + 640 + 96 + 28
        & &81000044     ; HSWR = 76
        & &82000098     ; HBSR = 76 + 88
        & &830000F2     ; HDSR = 76 + 88 + 96
        & &84000372     ; HDER = 76 + 88 + 96 + 640
        & &850003D8     ; HBER = 76 + 88 + 96 + 640 + 96
        & &860000F3     ; HCSR = HDSR

        & &90000137     ; VCR  = 3 + 19 + 16 + 256 + 16 + 2
        & &91000002     ; VSWR = 3
        & &92000015     ; VBSR = 3 + 19
        & &93000025     ; VDSR = 3 + 19 + 16
d663 1
a663 1
        & &94000125     ; VDER = 3 + 19 + 16 + 256
d665 1
a665 1
        & &94000125     ; VDER = 3 + 19 + 16 + 256
d667 3
a669 3
        & &95000135     ; VBER = 3 + 19 + 16 + 256 + 16
        & &96000025     ; VCSR = VDSR
        & &97000025     ; VCER = VDSR
d675 1
a675 1
        & &D0000302     ; FSYNREG, clk = (3+1)/(2+1) * 24MHz = 32MHz  (higher frequency as part of fix)
d677 1
a677 1
        & &D0000305     ; FSYNREG, clk = (3+1)/(5+1) * 24MHz = 16MHz
d803 21
@


1.1
log
@file Boot was initially added on branch HAL.
@
text
@d1 781
@


1.1.2.1
log
@More HAL work. IOMD HAL work in progress. Lots of my own little build
scripts. Don't touch this.

Version 5.35, 4.79.2.2. Tagged as 'Kernel-5_35-4_79_2_2'
@
text
@a0 649
; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetCPU
        $GetIO
        $GetMEMC
        $GetMEMM
        $GetVIDC

                GBLL    CheckProtectionLink     ; if true, disallow CMOS RAM changes if link in protected position
CheckProtectionLink SETL (IO_Type = "IOMD") :LAND: {TRUE}       ; NB affects Delete/Copy/R/T and 0-9/.

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS



TimerPeriods    #       4*2

                GBLL    VCOstartfix
VCOstartfix     SETL    {TRUE}


; This version assumes a RISC OS image starting 64K after us.

        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        ENTRY

HAL_Base

vectors
        LDR     pc, ResetInd            ; Reset
        LDR     pc, HaltInd             ; Undefined instruction
        LDR     pc, HaltInd             ; SWI
        LDR     pc, HaltInd             ; Prefetch abort
        LDR     pc, HaltInd             ; Data abort
        LDR     pc, HaltInd             ; (Address exception)
        LDR     pc, HaltInd             ; IRQ
        LDR     pc, HaltInd             ; FIQ

; The above 8 instructions will operate as expected in 32-bit ROM mode,
; or in 16-bit ROM mode with a 16-bit ROM used.  In 16-bit ROM mode, and
; with 32-bit wide ROMs in use, they will instead be intepreted as 4
; NV-condition instructions (exact meaning not determined and should be
; irrelevant) which should do nothing and so allow control to drop
; through to this point, still in 16-bit mode.  Force IOMD into 32-bit
; ROM mode for bank 0.  The following instruction sequence has been
; produced in 16-in-32 form by extracting hex values from a listing...

        DCD     &0000B632, &0000E3A0    ; 20: MOV R11, #IO+IOMDREGS - point at IOMD
        DCD     &00000000, &0000E3A0    ; 28: MOV R0, #&0 - ROMCR:32b,slow,218.75us,no burst
        DCD     &00000080, &0000E5CB    ; 30: STRB R0,[R11,#ROMCR0] - switch mode
        DCD     &0000F000, &0000E3A0    ; 38: MOV PC, #0 - jump to 0 (this instr pre-fetched)

ResetInd
        DCD     start - HAL_Base
HaltInd
        DCD     halt - HAL_Base

halt    B       halt

HALdescriptor   DATA
        DCD     0
        DCD     HAL_Base - HALdescriptor
        DCD     64*1024
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     HAL_WsSize

        MACRO
        HALEntry $name
        ASSERT  (. - HAL_EntryTable) / 4 = EntryNo_$name
        DCD     $name - HAL_EntryTable
        MEND

        MACRO
        NullEntry
        DCD     HAL_Null - HAL_EntryTable
        MEND

        IMPORT   HAL_IICBuses
        IMPORT   HAL_IICType
        IMPORT   HAL_IICSetLines
        IMPORT   HAL_IICReadLines

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry

        HALEntry HAL_IICBuses
        HALEntry HAL_IICType
        HALEntry HAL_IICSetLines
        HALEntry HAL_IICReadLines


HAL_Entries     * (.-HAL_EntryTable)/4

; R11 is used as pointer to RISC OS entry table throughout pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND


start
        ADRL    R5, HAL_Base + 64*1024          ; R5 -> RISC OS image

        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table

        MOV     R0, #0
        CallOSM OS_InitARM

        LDR     R13, =&10001000

        MOV     r12, #IOMD_Base

; Perform a dummy write to IOMD (some harmless register) to get it out of ROM force mode.
; Reads from IOMD will return garbage before this has happened. If we're actually running out
; of 32-bit wide ROMs on MORRIS, a write will already have happened, to get ROMCR0 from
; 16 to 32-bit wide mode, but we can't yet determine for sure (by reading it back), so do it
; anyway.

        STRB    r12, [r12, #IOMD_DMAREQ]              ; writes to DMAREQ are ignored

        LDRB    r2,[r12,#IOMD_ID1]	; load r2 with IOMD ID high byte
        LDRB    r0,[r12,#IOMD_ID0]	; load r0 with IOMD ID low byte
        ORR     r0,r0,r2, LSL #8	; Or r0 and r2 - shifted left 8, put in r0
        LDR     r2,=IOMD_7500		; get Ref IOMD ID code for IOMD in a 7500
        CMPS    r0,r2                   ; check for IOMD ID Code for IOMD in a 7500
	BEQ	init7500cpu		; If equal, got to init7500cpu

        LDRNE   r2,=IOMD_7500FE		; If not, get ID code for IOMD in a 7500FE
        CMPNES  r0,r2			; If not, check for IOMD ID Code for IOMD in a 7500FE
        BNE     MedusaInit              ; NOT MORRIS assume Medusa hardware


init7500FEcpu
; Here bceause its an ARM7500 'FE' variant
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-

;	CPUCLK divide by 1
;	MEMCLK divide by 2
;	IOCLK  divide by 2
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkHalf + IOMD_CLKCTL_IOclkHalf
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all the prescalers.
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...
;
        LDRB    r0, [r12, #IOMD_ROMCR0]         ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]         ; Prog. the reg.s

; Program the 2nd ROM bank

        STRB	r0, [r12, #IOMD_ROMCR1]		; 2nd bank unused: program it the same anyway


; Now program ASTCR to add wait states, since MEMCLK is fast relative to IOCLK

	MOV	r0, #IOMD_ASTCR_WaitStates
	STRB	r0, [r12, #IOMD_ASTCR]

	B	init7500cpu_common		; branch to common init code.
;

init7500cpu
; Here because its an ARM7500 variant - NON 'FE' device.
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;	CPUCLK divide by 1
;	MEMCLK divide by 1
;	IOCLK  divide by 1
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all prescalers to div1
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...

        LDRB    r0, [r12, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]          ; Prog. the reg.s

; Program the 2nd ROM bank

        STRB	r0, [r12, #IOMD_ROMCR1]		; Program the 2nd bank the same as the 1st


; Now program ASTCR to *NOT* add wait states, since MEMCLK is slow relative to IOCLK

	MOV	r0, #IOMD_ASTCR_Minimal
	STRB	r0, [r12, #IOMD_ASTCR]

;
;
init7500cpu_common
; Common setup requirments for BOTH 7500 and 7500FE.
;
; MORRIS doesn't support VRAM. Kryten has same DRAM speed as Medusa
;
        MOV     r0, #IOMD_VREFCR_REF_16                         ; select 16µs refresh
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
        STRB    r0, [r12, #IOMD_ECTCR]

        B       CommonInit

        LTORG

MedusaInit


        MOV     r0, #&12    ; 5-3 cycle ROM access

        STRB    r0, [r12, #IOMD_ROMCR0]
        STRB    r0, [r12, #IOMD_ROMCR1]         ; and do the same for extension ROMs (just in case)
        MOV     r0, #IOMD_VREFCR_VRAM_256Kx64 :OR: IOMD_VREFCR_REF_16   ; select 16µs refresh, assume 2 banks of VRAM
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
        STRB    r0, [r12, #IOMD_ECTCR]

CommonInit

; Turn off VIDC (set power down bit in control register)

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        MOV     R0, #1:SHL:14   ; we may get vsync interrupts that stiff us
        ORR     R0, R0, #&E0000000
        STR     R0, [R1]

; Now bang IOC (disable all but keyboard interrupts)

        MOV     R1, #IOC
        MOV     R0, #&FF                ; all inputs
        STRB    R0, [R1, #IOCControl]   ; in case called by Tim

        MOV     R0, #0
        STRB    R0, [R1, #IOCIRQMSKA]   ; kein interrupts
        STRB    R0, [R1, #IOCFIQMSK]    ; knob off, FIQ
        STRB    R0, [R1, #IOMD_DMAMSK]  ; disable DMA interrupts, too
        STRB    R0, [R1, #IOMD_IRQMSKC] ; and the rest...
        STRB    R0, [R1, #IOMD_IRQMSKD]

  [ Keyboard_Type = "PC"
        MOV     R0, #serial_Rx_bit      ; used for Archi keyboard or IOMD PC keyboard
  ]
        STRB    R0, [R1, #IOCIRQMSKB]   ; allow communication with kbd, when I_bit gets cleared

; now bits to allow CMOS read/write : need timer

        LDR     R0, =20000-1    ; R0 = Timer delay (units of 0.5 microsecond)
                                ; 20000*0.5E-6 = 0.01 Seconds (100Hz ticker)
                                ; TMD 21-May-93: "-1" correction applied

        STRB    R0, [R1, #Timer0LL]     ; Set up the delay
        MOV     R0, R0, LSR #8
        STRB    R0, [R1, #Timer0LH]
        STRB    R0, [R1, #Timer0GO]     ; and start the ticks

        MOV     R0, #timer0_bit
        STRB    R0, [R1, #IOCIRQCLRA]   ; Clear pending t0 interrupt j.i.c.

  [ VCOstartfix
        ;2nd part of fix for VCO failing to start on A7000 (esp. 7500FE) - forcing PCOMP high for about 3 ms
        LDRB    R0, [R1,#IOMD_ID0]
        CMP     R0, #&E7
        LDREQB  R0, [R1,#IOMD_ID1]
        CMPEQ   R0, #&D4
        BEQ     vcofix_notMorris      ; risky to force PCOMP on Risc PC
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000342        ; VIDC20 FSYNREG, as in VIDCTAB but with force PCOMP high
        STR     R2, [R0]
        MOV     R0, #3072*2           ; time delay of about 3 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
vcofix_waitloop
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     vcofix_waitloop       ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     vcofix_waitloop       ; loop if not finished
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000302        ; VIDC20 FSYNREG, as in VIDCTAB (PCOMP low again)
        STR     R2, [R0]
vcofix_notMorris
  ]

; On breaks (ie software resets) we have to turn the MMU off.
; This is slightly tricky if we've been soft-loaded!


 [ {FALSE}
  ; Config for Dave's medusa
        MOV     R0, #4:SHL:8
        LDR     R1, =&10000000
        ADD     R2, R1, #&00400000
        LDR     R3, =&FFFFFFFF
        MOV     R12, #0
        STR     R12, [R13, #-4]!
        CallOSM OS_AddRAM
        STR     R0, [R13]

        MOV     R0, #4:SHL:8
        LDR     R1, =&14000000
        ADD     R2, R1, #&00400000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]

        MOV     R0, #4:SHL:8
        LDR     R1, =&1C000000
        ADD     R2, R1, #&00400000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]
  |
  ; The Risc PC (RAM from 10000000 - 11000000, ROM image at 10B00000-10F00000)
        MOV     R0, #4:SHL:8
        LDR     R1, =&10000000
        ADD     R2, R1, #&00B00000
        LDR     R3, =&FFFFFFFF
        MOV     R12, #0
        STR     R12, [R13, #-4]!
        CallOSM OS_AddRAM
        STR     R0, [R13]

        MOV     R0, #4:SHL:8
        LDR     R1, =&10F00000
        ADD     R2, R1, #&00100000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]

  ]

        LDR     R0, =4:SHL:8 + 1
        LDR     R1, =&02000000
        ADD     R2, R1, #&00200000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        ADD     R13, R13, #4

        MOV     R3, R0                  ; parameter for OS_Start

; Check the various reset flags

        MOV     R12, #IOC
        LDRB    R1, [R12, #IOCIRQSTAA]
        ANDS    R1, R1, #por_bit
        STRNEB  R1, [R12, #IOCIRQCLRA]  ; clear POR if set
        ORRNE   R0, R0, #OSStartFlag_POR

 [ CheckProtectionLink
        LDR     R2, =IOMD_MonitorType

; on Issue A's the protection bit is only weakly pulled up,
; so force it high, then read it back

        LDRB    R1, [R2]
        ORR     R1, R1, #IOMD_ProtectionLinkBit
        STRB    R1, [R2]
        LDRB    R1, [R2]
        TST     R1, #IOMD_ProtectionLinkBit
        ORRNE   R0, R0, #OSStartFlag_NoCMOSReset
 ]

 [ STB :LAND: IOMD_C_FrontPanelButton <> 0
  [ FrontPanelButtClearsCMOS
        LDRB    R1, [R12, #IOMD_CLINES] ; if front panel button pressed then CMOS reset
        TST     R1, #IOMD_C_FrontPanelButton
        ORRNE   R0, R0, #OSStartFlag_CMOSReset
  ]
 ]

        MOV     R1, R5
        ADR     R2, HALdescriptor
        CallOSM OS_Start

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data tables: VIDC := mode 0, all palette black

VIDCTAB DATA
; Program Control Register first, to clear power-down bit
; Now depending upon the VIDCClockSource flag, re-program the clock source.
   [ VIDCClockSource = "VCO"
     [ VCOstartfix
        & &E0000404     ; CR: FIFO load 16 words, 1 bpp, ck/2, vclk (allow for doubled VCO freq)
     |
        & &E0000400     ; CR: FIFO load 16 words, 1 bpp, ck/1, vclk
     ]
   ]
   [ VIDCClockSource = "HCLK"
        & &E0000401     ; CR: FIFO load 16 words, 1 bpp, ck/1, hclk
   ]
   [ VIDCClockSource = "RCLK"
        & &E0000406     ; CR: FIFO load 16 words, 1 bpp, ck/2, rclk
   ]

; Don't bother programming all 256 palette entries, we'll be here all night
; Since we're setting up a 1 bit-per-pixel mode, just do colours 0 and 1

        & &10000000     ; Palette address register = 0
        & &00000000     ; Colour 0 = black
        & &00000000     ; Colour 1 = black
        & &40000000     ; Border colour = black
        & &50000000     ; Pointer colour 1 = black
        & &60000000     ; Pointer colour 2 = black
        & &70000000     ; Pointer colour 3 = black

; Get a stable display up so we get stable signals

        & &800003F8     ; HCR  = 76 + 88 + 96 + 640 + 96 + 28
        & &81000044     ; HSWR = 76
        & &82000098     ; HBSR = 76 + 88
        & &830000F2     ; HDSR = 76 + 88 + 96
        & &84000372     ; HDER = 76 + 88 + 96 + 640
        & &850003D8     ; HBER = 76 + 88 + 96 + 640 + 96
        & &860000F3     ; HCSR = HDSR

        & &90000137     ; VCR  = 3 + 19 + 16 + 256 + 16 + 2
        & &91000002     ; VSWR = 3
        & &92000015     ; VBSR = 3 + 19
        & &93000025     ; VDSR = 3 + 19 + 16
 [ MEMC_Type = "IOMD"
        & &94000125     ; VDER = 3 + 19 + 16 + 256
 | ;MEMC_Type <> "IOMD"
        & &94000125     ; VDER = 3 + 19 + 16 + 256
 ] ;MEMC_Tupe = "IOMD"
        & &95000135     ; VBER = 3 + 19 + 16 + 256 + 16
        & &96000025     ; VCSR = VDSR
        & &97000025     ; VCER = VDSR

        & &B1000001     ; SCR: sound disabled (+use 24MHz clock)

        & &C00F1003     ; EREG = comp sync, DACs on, ereg output ext lut
   [ VCOstartfix
        & &D0000302     ; FSYNREG, clk = (3+1)/(2+1) * 24MHz = 32MHz  (higher frequency as part of fix)
   |
        & &D0000305     ; FSYNREG, clk = (3+1)/(5+1) * 24MHz = 16MHz
   ]
        & &F0013000     ; DCR: bus D[31:0], Hdisc       ;RCM 29/9/94: changed from &F0012000 at PSwindells request
        & &FFFFFFFF     ; That's the lot

IOPhys          *       &03000000
IOSize          *       &00800000

IOMDPhys        *       &03200000
VIDCPhys        *       &03400000       ; used to address VIDC when MMU is off

;--------------------------------------------------------------------------------------


HAL_Init
        Entry

        BL      SetUpOSEntries
        MOV     a1, #0
        MOV     a2, #IOPhys
        MOV     a3, #IOSize
        CallOS  OS_MapInIO
        STR     a1, IOa
        ADD     a2, a1, #IOMDPhys - IOPhys
        STR     a2, IOMDa
        ADD     a2, a1, #VIDCPhys - IOPhys
        STR     a2, VIDCa

        EXIT

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADR     a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05

        MOV     pc, lr


HAL_Timers
        MOV     a1, #2                  ; 2 timers
        MOV     pc, lr

HAL_TimerDevice
        ADD     a1, a1, #5              ; devices 5 and 6
        MOV     pc, lr

HAL_CounterRate
HAL_TimerGranularity
        LDR     a1, =2000000            ; 2MHz
        MOV     pc, lr

HAL_TimerMaxPeriod
        MOV     a1, #&10000             ; 16-bit counter
        MOV     pc, lr

HAL_TimerSetPeriod
        LDR     a4, IOMDa
        SUB     a2, a2, #1              ; count down from period-1 (&FFFF if period 0)
        ASSERT  Timer1LL-Timer0LL = 16
        ADD     a4, a4, a1, LSL #4
        STRB    a2, [a4, #Timer0LL]
        MOV     a3, a2, LSR #8
        STRB    a3, [a4, #Timer0LH]
        STRB    a3, [a4, #Timer0GO]

        MOV     a2, a2, LSL #16         ; a2 = actual period programmed (1-&10000)
        MOV     a2, a2, LSR #16
        ADD     a2, a2, #1

        ADR     a4, TimerPeriods
        STR     a2, [a4, a1, LSL #2]

        MOV     pc, lr

HAL_TimerPeriod
        ADR     a4, TimerPeriods
        LDR     a1, [a4, a1, LSL #2]
        MOV     pc, lr

HAL_CounterRead
        MOV     a1, #0
        ; Fall through

HAL_TimerReadCountdown
        LDR     a4, IOMDa

        MRS     ip, CPSR                ; interrupts off for latching
        ORR     a2, ip, #I32_bit

        ASSERT  Timer1LL-Timer0LL = 16
        ADD     a4, a4, a1, LSL #4

        MSR     CPSR_c, a2
        STRB    a4, [a4, #Timer0LR]
        LDRB    a1, [a4, #Timer0CL]
        LDRB    a2, [a4, #Timer0CH]
        MSR     CPSR_c, ip

        ORR     a1, a1, a2, LSL #8
        MOV     pc, lr

HAL_CounterPeriod
        LDR     a1, TimerPeriods + 0
        MOV     pc, lr

; If they want n ticks, wait until we've seen n+1 transitions of the clock.
HAL_CounterDelay
        LDR     a4, IOMDa

        MOV     a1, a1, LSL #1          ; convert to 0.5us ticks

        STRB    a1, [a4, #Timer0LR]     ; read counter
        LDRB    a2, [a4, #Timer0CL]

10      STRB    a1, [a4, #Timer0LR]
        LDRB    a3, [a4, #Timer0CL]     ; read counter
        SUBS    ip, a2, a3              ; ip = difference in 0.5us ticks
        ADDLO   ip, a2, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        MOVLO   pc, lr
        STRB    a1, [a4, #Timer0LR]
        LDRB    a2, [a4, #Timer0CL]     ; read counter
        SUBS    ip, a3, a2              ; ip = difference in 0.5us ticks
        ADDLO   ip, a3, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        BHS     %BT10
        MOV     pc, lr

HAL_Null
        MOV     pc, lr

        LTORG

        END
@


1.1.2.2
log
@More HAL work. IOMD HAL fleshed out somewhat - system gets most of the way
through initialisation.

Version 5.35, 4.79.2.5. Tagged as 'Kernel-5_35-4_79_2_5'
@
text
@d37 2
a100 18
        IMPORT   HAL_IRQEnable
        IMPORT   HAL_IRQDisable
        IMPORT   HAL_IRQClear
        IMPORT   HAL_IRQSource

        IMPORT   HAL_Timers
        IMPORT   HAL_TimerDevice
        IMPORT   HAL_TimerGranularity
        IMPORT   HAL_TimerMaxPeriod
        IMPORT   HAL_TimerSetPeriod
        IMPORT   HAL_TimerPeriod
        IMPORT   HAL_TimerReadCountdown

        IMPORT   HAL_CounterRate
        IMPORT   HAL_CounterPeriod
        IMPORT   HAL_CounterRead
        IMPORT   HAL_CounterDelay

a105 4
        IMPORT   HAL_VideoFlybackDevice

        IMPORT   HAL_MachineID

a108 5
        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource

a134 4
        HALEntry HAL_VideoFlybackDevice

        HALEntry HAL_MachineID

a350 3
        MOV     R0, #0
        STRB    R0, [R1, #IOMD_ATODICR] ; power down the A to D convertor

d553 90
@


1.1.2.3
log
@first attemp at mjs video code in real HAL
@
text
@a98 2
        IMPORT   Video_init

a122 10
        IMPORT   HAL_Video_SetMode
        IMPORT   HAL_Video_WritePaletteEntry
        IMPORT   HAL_Video_WritePaletteEntries
        IMPORT   HAL_Video_ReadPaletteEntry
        IMPORT   HAL_Video_SetInterlace
        IMPORT   HAL_Video_SetBlank
        IMPORT   HAL_Video_SetPowerSave
        IMPORT   HAL_Video_UpdatePointer
        IMPORT   HAL_Video_SetDAG
        IMPORT   HAL_Video_VetMode
a160 10
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode
d558 1
a558 1
        STR     a1, IO_Address
d560 3
a562 12
        STR     a2, IOMD_Address
        ADD     a3, a1, #VIDCPhys - IOPhys
        STR     a3, VIDC_Address

        LDRB    a1, [a2, #IOMD_ID0]
        LDRB    a4, [a2, #IOMD_ID1]
        ORR     a1, a1, a4, LSL #8
        LDR     a4, =IOMD_Original
        TEQ     a1, a4
        MOVEQ   ip, #0                    ; assume Medusa
        MOVNE   ip, #IOST_7500            ; else assume Morris
        STRB    ip, IOSystemType
a563 1
        BL      Video_init
@


1.1.2.4
log
@  Added HAL NVRAM support
Detail:
  Added the HAL NVRAM entries.
  Modified i2cutils to use the HAL entries for NVRAM and behave sensibly if the HAL reports that there is no NVRAM, in which case there must be a forced reset_cmos call so that the cache gets set up sensibly.
Admin:
  Tested under the RPC emulator and appears to be working correctly, although some calls to IIC are still being made in the no nvram case.

Version 5.35, 4.79.2.8. Tagged as 'Kernel-5_35-4_79_2_8'
@
text
@a123 8
    	IMPORT	 HAL_NVMemoryType
    	IMPORT	 HAL_NVMemorySize
    	IMPORT	 HAL_NVMemoryProtectedSize
    	IMPORT	 HAL_NVMemoryProtection
    	IMPORT	 HAL_NVMemoryIICAddress
    	IMPORT	 HAL_NVMemoryRead
    	IMPORT	 HAL_NVMemoryWrite

d159 7
a165 7
    	HALEntry HAL_NVMemoryType
    	HALEntry HAL_NVMemorySize
    	HALEntry HAL_NVMemoryProtectedSize
    	HALEntry HAL_NVMemoryProtection
    	HALEntry HAL_NVMemoryIICAddress
    	HALEntry HAL_NVMemoryRead
    	HALEntry HAL_NVMemoryWrite
d437 1
a437 1
        ADD     R2, R1, #&00400000
d444 6
a449 6
;        MOV     R0, #4:SHL:8
;        LDR     R1, =&10F00000
;        ADD     R2, R1, #&00100000
;        LDR     R3, =&FFFFFFFF
;        CallOSM OS_AddRAM
;        STR     R0, [R13]
@


1.1.2.5
log
@Wahey! This version gives you a display.

It says "Abort on data transfer".
@
text
@a343 1
 [ {FALSE}
a349 11
 |
; VInit etc set on ze mode change: no DMA going yet so don't set owt.

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        ADR     R2, VIDCTAB     ; we may get vsync interrupts that stiff us
10      LDR     R0, [R2], #4    ; permanently as VIDC is in an undefined state
        CMP     R0, #-1         ; so have mode 0 with all black palette
        STRNE   R0, [R1]
        BNE     %BT10

 ]
d445 1
a445 1
        ADD     R2, R1, #&00B00000
d452 6
a457 6
        MOV     R0, #4:SHL:8
        LDR     R1, =&10F00000
        ADD     R2, R1, #&00100000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]
@


1.1.2.6
log
@More L7200 HAL work
@
text
@a79 5
        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
ROMsize
        DCD     0                       ; patched in by build system

a193 4
        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo

a585 6
EASIPhys        *       &08000000
EASISlotSize    *       &01000000
EASISlotSizeShift *     24
EASISlots       *       8
EASISize        *       EASISlotSize * EASISlots

a614 6
        MOV     a1, #0
        MOV     a2, #EASIPhys
        MOV     a3, #EASISize
        CallOS  OS_MapInIO
        STR     a1, EASI_Address

a639 52

HAL_ControllerAddress
        MOV     a1, #0                  ; Default to "not fitted"
        AND     a3, a2, #&FF            ; Get sequence number.
        MOV     a2, a2, LSR #8          ; Get controller type.
        CMP     a2, #4
        ADDLS   pc, pc, a2, LSL #2
        MOV     pc, lr
        B       ca_EASIspeed
        B       ca_EASIspace
        MOV     pc, lr
        B       ca_VIDC20
        B       ca_IOMD

ca_EASIspeed
        LDR     ip, IOMD_Address
        CMP     a3, #EASISlots
        ADDLO   a1, ip, #IOMD_ECTCR
        MOV     pc, lr

ca_EASIspace
        LDR     ip, EASI_Address
        CMP     a3, #EASISlots
        ADDLO   a1, ip, a3, LSL #EASISlotSizeShift
        MOV     pc, lr

ca_VIDC20
        TEQ     a3, #0
        LDREQ   a1, VIDC_Address
        MOV     pc, lr

ca_IOMD
        TEQ     a3, #0
        LDREQ   a1, IOMD_Address
        MOV     pc, lr

HAL_HardwareInfo
        LDR     ip, =&01010101
        STR     ip, [a1]
        MOV     ip, #1
        STR     ip, [a2]
        MOV     ip, #0
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        LDR     ip, =&00311111
        STR     ip, [a1]
        LDR     ip, =&00011100
        STR     ip, [a2]
        MOV     pc, lr

@


1.1.2.7
log
@add some HAL_Video calls, attempt to deal with lack of h/w scroll

Version 5.35, 4.79.2.9. Tagged as 'Kernel-5_35-4_79_2_9'
@
text
@d129 7
a135 7
        IMPORT   HAL_NVMemoryType
        IMPORT   HAL_NVMemorySize
        IMPORT   HAL_NVMemoryProtectedSize
        IMPORT   HAL_NVMemoryProtection
        IMPORT   HAL_NVMemoryIICAddress
        IMPORT   HAL_NVMemoryRead
        IMPORT   HAL_NVMemoryWrite
a147 6
        IMPORT   HAL_Video_PixelFormats
        IMPORT   HAL_Video_Features
        IMPORT   HAL_Video_BufferAlignment

        ;IMPORT   HAL_MatrixColumns
        ;IMPORT   HAL_MatrixScan
d172 7
a178 7
        HALEntry HAL_NVMemoryType
        HALEntry HAL_NVMemorySize
        HALEntry HAL_NVMemoryProtectedSize
        HALEntry HAL_NVMemoryProtection
        HALEntry HAL_NVMemoryIICAddress
        HALEntry HAL_NVMemoryRead
        HALEntry HAL_NVMemoryWrite
a195 6
        HALEntry HAL_Video_PixelFormats
        HALEntry HAL_Video_Features
        HALEntry HAL_Video_BufferAlignment

        NullEntry ;HAL_MatrixColumns
        NullEntry ;HAL_MatrixScan
d243 4
a246 4
        LDRB    r2,[r12,#IOMD_ID1]      ; load r2 with IOMD ID high byte
        LDRB    r0,[r12,#IOMD_ID0]      ; load r0 with IOMD ID low byte
        ORR     r0,r0,r2, LSL #8        ; Or r0 and r2 - shifted left 8, put in r0
        LDR     r2,=IOMD_7500           ; get Ref IOMD ID code for IOMD in a 7500
d248 1
a248 1
        BEQ     init7500cpu             ; If equal, got to init7500cpu
d250 2
a251 2
        LDRNE   r2,=IOMD_7500FE         ; If not, get ID code for IOMD in a 7500FE
        CMPNES  r0,r2                   ; If not, check for IOMD ID Code for IOMD in a 7500FE
d260 3
a262 3
;       CPUCLK divide by 1
;       MEMCLK divide by 2
;       IOCLK  divide by 2
d276 1
a276 1
        STRB    r0, [r12, #IOMD_ROMCR1]         ; 2nd bank unused: program it the same anyway
d281 2
a282 2
        MOV     r0, #IOMD_ASTCR_WaitStates
        STRB    r0, [r12, #IOMD_ASTCR]
d284 1
a284 1
        B       init7500cpu_common              ; branch to common init code.
d291 3
a293 3
;       CPUCLK divide by 1
;       MEMCLK divide by 1
;       IOCLK  divide by 1
d307 1
a307 1
        STRB    r0, [r12, #IOMD_ROMCR1]         ; Program the 2nd bank the same as the 1st
d312 2
a313 2
        MOV     r0, #IOMD_ASTCR_Minimal
        STRB    r0, [r12, #IOMD_ASTCR]
@


1.1.2.8
log
@First attempt at ARM9 support, and general clean-up of old ARM-specific
code, now using vectored ARMops.
Not tested.

Version 5.35, 4.79.2.14. Tagged as 'Kernel-5_35-4_79_2_14'
@
text
@a208 3
        NullEntry ;HAL_TouchscreenType
        NullEntry ;HAL_Touchscreenread

a504 1
        MOV     R0, #0
@


1.1.2.9
log
@TViLINK-y HAL-y IIC-y type stuff. It's great.
@
text
@a210 2
        NullEntry ;HAL_Touchscreenread
        NullEntry ;HAL_Touchscreenread
@


1.1.2.10
log
@* Fixed the IIC code.
* Kernel puts sensible default FIQ handler in through the HAL.
* Fix to temporary page uncaching code.

Version 5.35, 4.79.2.30. Tagged as 'Kernel-5_35-4_79_2_30'
@
text
@a109 1
        IMPORT   HAL_FIQDisableCode
a163 1
        HALEntry HAL_FIQDisableCode
@


1.1.2.11
log
@1) Bring IOMD HAL more up to date. Add support for new
call HAL_CleanerSpace (preparation for StrongARM kernel
support).

2) In kernel, add HAL_CleanerSpace call (preparation for
StrongARM and XScale core support). Fix bug found with
ARMv3 support during test on Risc PC.

3) Implement new API for kernel SWIs that have used top
bits of addresses as flags. The new API has an extra
flag that must be set, so kernel can distinguish and
support both APIs. The reason for all this is that
addresses are 32-bits now, people, keep up there. Briefly:

  OS_HeapSort
    bit 31 of r0 set for new API, r1 is full 32-bit address
    flags move from r1 bits 31-29 to r0 bits 30-28

  OS_ReadLine
    bit 31 of r1 set for new API, r0 is full 32-bit address
    flags move from bits 31,30 of r0 to bits 30,29 of r1

  OS_SubstituteArgs
    bit 31 of r2 set for new API, r0 is full 32-bit address
    flag moves from bit 31 of r0 to bit 30 of r2

Tested on Risc PC

Ta

Version 5.35, 4.79.2.41. Tagged as 'Kernel-5_35-4_79_2_41'
@
text
@a151 1
        IMPORT   HAL_Video_OutputFormat
a206 1
        HALEntry HAL_Video_OutputFormat
a220 1
        HALEntry HAL_CleanerSpace
a221 21
        NullEntry ;HAL_UARTPorts
        NullEntry ;HAL_UARTStartUp
        NullEntry ;HAL_UARTShutdown
        NullEntry ;HAL_UARTFeatures
        NullEntry ;HAL_UARTReceiveByte
        NullEntry ;HAL_UARTTransmitByte
        NullEntry ;HAL_UARTLineStatus
        NullEntry ;HAL_UARTInterruptEnable
        NullEntry ;HAL_UARTRate
        NullEntry ;HAL_UARTFormat
        NullEntry ;HAL_UARTFIFOSize
        NullEntry ;HAL_UARTFIFOClear
        NullEntry ;HAL_UARTFIFOEnable
        NullEntry ;HAL_UARTFIFOThreshold
        NullEntry ;HAL_UARTInterruptID
        NullEntry ;HAL_UARTBreak
        NullEntry ;HAL_UARTModemControl
        NullEntry ;HAL_UARTModemStatus
        NullEntry ;HAL_UARTDevice

        NullEntry ;HAL_Reset
a482 3
  ;
        ! 0, "HAL assumes fixed 16M memory @@ 10000000"
  ;
a732 11
;must return address of at least 64k of physical space suitable for
;cache cleaning (at least 4k aligned, preferably 64k aligned)
;or, return -1 if HAL knows not needed (eg. knows core in system)
;
HAL_CleanerSpace
        [ {FALSE}
          ???don't know what do yet, in generic memory size case
        |
          MOV   a1, #&10000000  ; return start of physical RAM
        ]
        MOV     pc, lr
@


1.1.2.12
log
@StrongARM is back, and this time it's provisional!

IOMD HAL:
  enables fast clock for StrongARM on Medusa h/w

Kernel:
  ARMops for StrongARM implemented. Tested moderately on
  HAL/32-bit minimal desktop build for Risc PC. Could do
  with more testing later. eg. does reentrant cache
  cleaning support really work?
  Lazy task swapping is enabled for revT or later, wahey.

Version 5.35, 4.79.2.42. Tagged as 'Kernel-5_35-4_79_2_42'
@
text
@a379 7
        ; we know we might meet StrongARM 110, enable fast core clock if so
        ; (grey area - clocking regarded as HAL rather than kernel problem)
        ;
        MRC     p15, 0, r0, c0, c0, 0   ; read id
        AND     r0, r0, #&F000
        TEQ     r0, #&A000              ; is that my old friend, StrongARM?
        MCREQ   p15, 0, r0, c15, c1, 2  ; enable fast core clock
@



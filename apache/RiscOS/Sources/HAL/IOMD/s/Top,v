head	1.12;
access;
symbols
	IOMD-0_36:1.12
	SMP:1.12.0.2
	SMP_bp:1.12
	IOMD-0_35:1.12
	IOMD-0_34:1.12
	IOMD-0_33:1.12
	IOMD-0_32:1.12
	IOMD-0_31:1.12
	IOMD-0_30:1.12
	IOMD-0_29:1.12
	IOMD-0_28:1.12
	IOMD-0_27:1.12
	IOMD-0_26:1.11
	IOMD-0_25:1.10
	IOMD-0_24:1.9
	IOMD-0_23:1.9
	IOMD-0_22:1.9
	IOMD-0_20:1.8
	IOMD-0_19:1.8
	IOMD-0_18:1.7
	IOMD-0_17:1.6
	IOMD-0_16:1.5
	IOMD-0_15:1.4
	IOMD-0_14:1.4
	IOMD-0_13:1.3
	IOMD-0_12:1.2
	IOMD-0_11:1.1;
locks; strict;
comment	@# @;


1.12
date	2013.05.25.15.52.28;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	kwoJ5V6eAGLfN1Rw;

1.11
date	2013.04.21.19.51.39;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	8YOlwQ0mTgI4dGMw;

1.10
date	2013.03.28.21.48.44;	author jlee;	state Exp;
branches;
next	1.9;
commitid	4NAwCJkLkDe3DBJw;

1.9
date	2013.01.12.10.41.02;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	ZzPrVbzkYwpulUzw;

1.8
date	2012.10.20.18.14.23;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	z1ni8btRBpLpy9pw;

1.7
date	2012.07.15.12.07.32;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	th0BmFZji9LRDEcw;

1.6
date	2012.07.09.07.32.10;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	5eSZam1l3tbmjRbw;

1.5
date	2012.07.04.18.19.03;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	nTJOJt9IePDd3hbw;

1.4
date	2012.06.20.00.40.34;	author jlee;	state Exp;
branches;
next	1.3;
commitid	V4TfYa4ZA6i2En9w;

1.3
date	2012.06.19.23.38.32;	author jlee;	state Exp;
branches;
next	1.2;
commitid	bSrBAroyIB3Jin9w;

1.2
date	2012.06.09.11.29.48;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	QBFdo1jqgrSEA18w;

1.1
date	2012.02.25.17.16.39;	author jlee;	state Exp;
branches;
next	;
commitid	Dn81wPJ3GobPSyUv;


desc
@@


1.12
log
@Change to SDRAM probing for 256MB Kinetic
The RAM probing for Kinetic relied on the default row/column split which doesn't quite have enough address lines for 256MB SODIMMs.
Try probing each of the 3 supported row/column splits in descending order, stopping when either no RAM is found (it's not a Kinetic) or when the address lines have no holes, whichever is sooner.
Careful not to rearrange the memory when softloaded!
Tested with a 64MB, 128MB, 256MB SODIMM in both physical ROM and softload form.

Version 0.27. Tagged as 'IOMD-0_27'
@
text
@; Copyright 2012 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        GET     Hdr:HALSize.<HALSize>
        $GetCPU
        $GetIO
        $GetMEMC
        $GetMEMM

                GBLL    CheckProtectionLink
CheckProtectionLink SETL {TRUE}         ; When TRUE, disallow CMOS RAM changes if link in protected position

                GBLL    IgnoreVRAM
IgnoreVRAM      SETL    {FALSE}         ; When TRUE, pretend there's no VRAM

                GBLL    IgnoreDRAM
IgnoreDRAM      SETL    {FALSE}         ; When TRUE, pretend there's no DRAM

                GBLL    IgnoreKinetic
IgnoreKinetic   SETL    {FALSE}         ; When TRUE, pretend we're not on Kinetic

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS
        GET     hdr.IOMD
        GET     hdr.Copro15ops
        GET     hdr.Debug

        EXPORT  HAL_Base
        EXPORT  start
        EXPORT  DistinctAddresses
        IMPORT  Video_Init
        IMPORT  HALdescriptor
        IMPORT  Decide_On_Memory_Layout
        IMPORT  Power_On_Self_Test

; R11 is used as pointer to RISC OS entry table during pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND


        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        ENTRY

HAL_Base

vectors
        LDR     pc, ResetInd            ; Reset
        LDR     pc, HaltInd             ; Undefined instruction
        LDR     pc, HaltInd             ; SWI
        LDR     pc, HaltInd             ; Prefetch abort
        LDR     pc, HaltInd             ; Data abort
        LDR     pc, HaltInd             ; (Address exception)
        LDR     pc, HaltInd             ; IRQ
        LDR     pc, HaltInd             ; FIQ

; The above 8 instructions will operate as expected in 32-bit ROM mode,
; or in 16-bit ROM mode with a 16-bit ROM used.  In 16-bit ROM mode, and
; with 32-bit wide ROMs in use, they will instead be intepreted as 4
; NV-condition instructions (exact meaning not determined and should be
; irrelevant) which should do nothing and so allow control to drop
; through to this point, still in 16-bit mode.  Force IOMD into 32-bit
; ROM mode for bank 0.  The following instruction sequence has been
; produced in 16-in-32 form by extracting hex values from a listing...

        DCD     &0000B632, &0000E3A0    ; 20: MOV  R11, #IOMDPhys - point at IOMD physical address
        DCD     &00000000, &0000E3A0    ; 28: MOV  R0, #0 - ROMCR:32b, slow, 7xMEMCLK (218.75ns), no burst
        DCD     &00000080, &0000E5CB    ; 30: STRB R0,[R11,#ROMCR0] - switch mode
        DCD     &0000F000, &0000E3A0    ; 38: MOV  PC, #0 - jump to 0 (this instruction pre-fetched)

ResetInd
        DCD     start - HAL_Base
HaltInd
        DCD     halt - HAL_Base

halt    B       halt

        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
ROMsize
        DCD     0                       ; patched in by build system

; Boot flow:
; 1. start - CPU, IOMD, VIDC initialisation
;    - init7500FEcpu for 7500FE
;    - init7500cpu for 7500
;    - MedusaInit for ARM6/7/StrongARM
;    - Count_Hard_ROM
; 2. Initialise_DRAM - Locate all DRAM and program control registers
;    - Initialise_DRAM_RiscPC for original IOMD
;    - Initialise_DRAM_A7000 for 7500/7500FE
; 3. Find_WS_Page - Find a spare page for stack/workspace
; 4. Power_On_Self_Test - Simple POST
; 5. Decide_On_Memory_Layout - Decide how we're going to present the physical RAM to RISC OS, and where to relocate our ROM image (if necessary)
; 6. Relocate_Forwards/Relocate_Backwards - ROM image relocation
; 7. NoRelocate - Register DRAM with RISC OS
; 8. Initialise_VRAM - Locate all VRAM, program control registers, register with RISC OS
;    - Initialise_VRAM_RiscPC for IOMD
;    - Initialise_VRAM_A7000 for 7500/7500FE
; 9. RISCOS_Start


start
        ; Ensure SVC32 with IRQ+FIQ off
        MSR     CPSR_c, #SVC32_mode+I32_bit+F32_bit

        ADRL    R5, HAL_Base + OSROM_HALSize    ; R5 -> RISC OS image

        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table

        MOV     R0, #0
        CallOSM OS_InitARM

        MOV     r12, #IOMDPhys

; Perform a dummy write to IOMD (some harmless register) to get it out of ROM force mode.
; Reads from IOMD will return garbage before this has happened. If we're actually running out
; of 32-bit wide ROMs on MORRIS, a write will already have happened to get ROMCR0 from
; 16 to 32-bit wide mode, but we can't yet determine for sure (by reading it back), so do it
; anyway.

        STRB    r12, [r12, #IOMD_DMAREQ]              ; writes to DMAREQ are ignored

        LDRB    r2,[r12,#IOMD_ID1]      ; load r2 with IOMD ID high byte
        LDRB    r0,[r12,#IOMD_ID0]      ; load r0 with IOMD ID low byte
        ORR     r0,r0,r2, LSL #8        ; Or r0 and r2 - shifted left 8, put in r0
        LDR     r2,=IOMD_7500           ; get Ref IOMD ID code for IOMD in a 7500
        CMP     r0,r2                   ; check for IOMD ID Code for IOMD in a 7500
        BEQ     init7500cpu             ; If equal, got to init7500cpu

        LDRNE   r2,=IOMD_7500FE         ; If not, get ID code for IOMD in a 7500FE
        CMPNE   r0,r2                   ; If not, check for IOMD ID Code for IOMD in a 7500FE
        BNE     MedusaInit              ; NOT MORRIS assume Medusa hardware

init7500FEcpu
; Here because its an ARM7500 'FE' variant
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;       CPUCLK divide by 1
;       MEMCLK divide by 2
;       IOCLK  divide by 2
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkHalf + IOMD_CLKCTL_IOclkHalf
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all the prescalers.
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...

        LDRB    r0, [r12, #IOMD_ROMCR0]         ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]         ; Prog. the regs
        STRB    r0, [r12, #IOMD_ROMCR1]         ; 2nd bank unused: program it the same anyway

; Now program ASTCR to add wait states, since MEMCLK is fast relative to IOCLK

        MOV     r0, #IOMD_ASTCR_WaitStates
        STRB    r0, [r12, #IOMD_ASTCR]

        B       init7500cpu_common              ; branch to common init code.

init7500cpu
; Here because its an ARM7500 variant - NON 'FE' device.
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;       CPUCLK divide by 1
;       MEMCLK divide by 1
;       IOCLK  divide by 1
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all prescalers to div1
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...

        LDRB    r0, [r12, #IOMD_ROMCR0]         ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]         ; Prog. the regs
        STRB    r0, [r12, #IOMD_ROMCR1]         ; 2nd bank unused: program it the same anyway

; Now program ASTCR to *NOT* add wait states, since MEMCLK is slow relative to IOCLK

        MOV     r0, #IOMD_ASTCR_Minimal
        STRB    r0, [r12, #IOMD_ASTCR]

init7500cpu_common
; Common setup requirments for BOTH 7500 and 7500FE.
;
; MORRIS doesn't support VRAM. Kryten has same DRAM speed as Medusa
;
        MOV     r0, #IOMD_VREFCR_REF_16         ; select 16µs refresh
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

        MOV     r0, #2_10                       ; Japanese format audio, LCD colour mux off 
        STRB    r0, [r12, #IOMD_VIDMUX]

        B       CommonInit

        LTORG

MedusaInit

        ; we know we might meet StrongARM 110, enable fast core clock if so
        ; (grey area - clocking regarded as HAL rather than kernel problem)
        ;
        ARM_read_ID r0                          ; read id
        AND     r0, r0, #&F000
        TEQ     r0, #&A000                      ; is that my old friend, StrongARM?
        MCREQ   p15, 0, r0, c15, c1, 2          ; enable fast core clock

        MOV     r0, #IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3

        STRB    r0, [r12, #IOMD_ROMCR0]         ; 5-3 cycle ROM access
        STRB    r0, [r12, #IOMD_ROMCR1]         ; 2nd bank unused: program it the same anyway

        MOV     r0, #IOMD_VREFCR_VRAM_256Kx64 :OR: IOMD_VREFCR_REF_16   ; select 16µs refresh, assume 2 banks of VRAM
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

CommonInit

; Now bang IOMD (disable all but keyboard interrupts)

        MOV     R1, #IOMDPhys

        MOV     R0, #&FF                ; all inputs
        STRB    R0, [R1, #IOCControl]   ; in case called by Tim

        MOV     R0, #0
        STRB    R0, [R1, #IOCIRQMSKA]   ; kein interrupts
        STRB    R0, [R1, #IOCIRQMSKB]
        STRB    R0, [R1, #IOCFIQMSK]    ; knob off, FIQ
        STRB    R0, [R1, #IOMD_DMAMSK]  ; disable DMA interrupts, too
        STRB    R0, [R1, #IOMD_IRQMSKC] ; and the rest...
        STRB    R0, [R1, #IOMD_IRQMSKD]

; Set the centisecond timer running so things can be timed properly

        LDR     R0, =20000-1            ; R0 = Timer delay (units of 0.5 microsecond)
                                        ; 20000*0.5E-6 = 0.01 Seconds (100Hz ticker)
                                        ; TMD 21-May-93: "-1" correction applied

        STRB    R0, [R1, #Timer0LL]     ; Set up the delay
        MOV     R0, R0, LSR #8
        STRB    R0, [R1, #Timer0LH]
        STRB    R0, [R1, #Timer0GO]     ; and start the ticks

        MOV     R0, #timer0_bit
        STRB    R0, [R1, #IOCIRQCLRA]   ; Clear pending t0 interrupt j.i.c.

; Power down the A to D convertor

        MOV     R0, #0
        STRB    R0, [R1, #IOMD_ATODICR]

; Minimal VIDC setup

        BL      Video_Init

  [ Debug
        IMPORT  Debug_Init
        BL      Debug_Init
        DebugTX "IOMD HAL init"
  ]

        BL      Count_Hard_ROM
        MOV     r12, #IOMDPhys
        MOV     r0, r0, LSR #20         ; No RAM yet, pack result into 5 bits (1->32MB => 0->31) and
        SUB     r0, r0, #1              ; stash it in the 5 bit bank 1 timing reg since this code must
        STRB    r0, [r12, #IOMD_ROMCR1] ; be in bank 0

; Initialise_DRAM
Initialise_DRAM ROUT
        LDRB    r0, [r12, #IOMD_ID0]
        LDRB    r1, [r12, #IOMD_ID1]
        ORR     r0, r0, r1, LSL #8
        DebugReg r0
        DebugTX_inl " = IOMD ID", r1, r2, r3
        LDR     r1, =IOMD_Original
        CMP     r0, r1
        BEQ     Initialise_DRAM_RiscPC
        B       Initialise_DRAM_A7000


; Initialise_DRAM_RiscPC
;   Exit:  r0-r3 = address lines
Initialise_DRAM_RiscPC ROUT
        MOV     r11, #IOMD_DRAMCR_DRAM_Large * &55      ; set all banks to be large initially
        CMP     pc, #VideoPhysRam
        MOV     r14, #IOMDPhys
        STRLOB  r11, [r14, #IOMD_DRAMCR]                ; Don't fiddle with DRAM config if softloaded
        MOV     r0, #DRAM0PhysRam
        MOV     r13, #IOMD_DRAMCR_DRAM_Small            ; bit to OR into DRAMCR
10
        ADD     r1, r0, #A10                            ; this should be OK for both configurations
        BL      DistinctAddresses
        MOVNE   r6, #0                                  ; move onto next bank
        BNE     %FT15                                   ; [no RAM in this bank at all]

        ADD     r1, r0, #A11                            ; test for 256K DRAM
        BL      DistinctAddresses
        BEQ     %FT12
        ORR     r11, r11, r13                           ; it is, so select small multiplexing
        MOV     r14, #IOMDPhys
        CMP     pc, #VideoPhysRam
        STRLOB  r11, [r14, #IOMD_DRAMCR]                ; store new value of DRAMCR, so we can use memory immediately
12
        BL      Probe_DRAM_bank
15
        ADD     r0, r0, #DRAMBankSize
        MOV     r13, r13, LSL #2                        ; shunt up position in DRAMCR
        CMP     r13, #&100                              ; if more banks to do
        MOVCC   r10, r9                                 ; then shuffle everything up
        MOVCC   r9, r8
        MOVCC   r8, r6
        BCC     %BT10                                   ; and loop
        DebugTX "Initialise_DRAM_RiscPC done"
        DebugReg r10
        DebugTX " = bank 0"
        DebugReg r9
        DebugTX " = bank 1"
        DebugReg r8
        DebugTX " = bank 2"
        DebugReg r6
        DebugTX " = bank 3"
        DebugReg r11
        DebugTX " = DRAMCR"

        ; Kinetic detection
        ; There aren't any sensible registers that we can use to detect if we're running on a Kinetic.
        ; However if a Kinetic is fitted, Probe_DRAM_bank should be able to detect the
        ; first SDRAM bank, while failing on IOMD machines (due to it mapping to ROM bank 0).
        ; The SODIMM is 64b wide, split as two identical 32b banks, so success with one infers the other.
        ; While the SODIMM detect EEPROM is wired up, we'll try to guess the row/column/bank split
        ; by just probing until there's a blob of RAM that looks contiguous (max 256MB).
        MOV     r13, r6                                 ; Push "R6"

        CMP     pc, #VideoPhysRam
        BHS     %FT20                                   ; Don't fiddle with SDRAM config if softloaded

        LDR     r0, =SDCfgReg
        MOV     r14, #SDCfg_SIZE_13_2_9                 
        STR     r14, [r0]                
        MOV     r0, #SDRAM0PhysRam
        BL      Probe_DRAM_bank
        ADD     r0, r6, #1
        TST     r0, r6                                  ; Implements IS_POWER_OF_TWO()
        BEQ     %FT25                                   ; R6 has no missing address lines (or R6=0, not Kinetic)

        LDR     r0, =SDCfgReg
        MOV     r14, #SDCfg_SIZE_12_2_9                 
        STR     r14, [r0]                
        MOV     r0, #SDRAM0PhysRam
        BL      Probe_DRAM_bank
        ADD     r0, r6, #1
        TST     r0, r6                                  ; Implements IS_POWER_OF_TWO()
        BEQ     %FT25                                   ; R6 has no missing address lines

        LDR     r0, =SDCfgReg
        MOV     r14, #SDCfg_SIZE_12_2_8                 ; Last chance saloon
        STR     r14, [r0]                
20
        MOV     r0, #SDRAM0PhysRam
        BL      Probe_DRAM_bank
25
        MOV     r11, r6
        MOV     r12, r6                                 ; Duplicate in other bank
        MOV     r6, r13                                 ; Pull "R6"
        DebugReg r11
        DebugTX " = SDRAM bank 0"
        DebugReg r12
        DebugTX " = SDRAM bank 1"

        ; Move results to correct regs
        MOV     r0, r10
        MOV     r1, r9
        MOV     r2, r8
        MOV     r3, r6
        B       Find_WS_Page

; Initialise_DRAM_A7000
;   Exit:  r0-r3 = address lines
Initialise_DRAM_A7000 ROUT
        ; Initially assume 32 bit wide, EDO, and timing bits set in case 7500FE (don't care bits otherwise)
        MOV     r11, #IOMD_DRAMWID_EDO_Enable :OR: \
                      IOMD_DRAMWID_RASCAS_3 :OR: IOMD_DRAMWID_RASPre_4 :OR: \
                      (IOMD_DRAMWID_DRAM_32bit * &0F)
        CMP     pc, #VideoPhysRam
        MOV     r14, #IOMDPhys
        STRLOB  r11, [r14, #IOMD_DRAMWID]               ; Don't fiddle with DRAM config if softloaded
        MOV     r13, #IOMD_DRAMWID_DRAM_16bit           ;bit to OR into DRAMWID to set 16bit
        MOV     r0, #DRAM0PhysRam
        ; r0    DRAM address
        ; r11   current IOMD_DRAMWID register contents
        ; r13   IOMD_DRAMWID_DRAM_16bit for current DRAM bank
10                                                      ;examine first/next DRAM bank
        LDMIA   r0, {r1, r2}                            ;Preserve the two locations that we widdle on

        ADR     r3, funnypatterns                       ;We write different values to two locations
        LDMIA   r3, {r3, r4}                            ; incase bus capacitance holds our value
        STMIA   r0, {r3, r4}
        LDMIA   r0, {r5, r6}                            ;Reread test locations
        EORS    r5, r5, r3                              ;Both locations should read correctly
        EOR     r6, r6, r4                              ; if memory is 32bits wide
        TEQEQ   r6, #0
        BEQ     %FT12                                   ;32bit wide memory

        TST     r5, #&00FF                              ;If the bottom 16bits of each location
        TSTEQ   r5, #&FF00                              ; are correct, the memory is 16bits wide
        TSTEQ   r6, #&00FF
        TSTEQ   r6, #&FF00
        MOVNE   r6, #0                                  ; move onto next bank
        BNE     %FT15                                   ;No memory in this bank

        ORR     r11, r11, r13                           ;Bank is 16bits wide
12
        STMIA   r0, {r1, r2}                            ;Restore the two locations we widdled on
        CMP     pc, #VideoPhysRam                       ;Must do BEFORE poking the DRAMWID register
        MOV     r14, #IOMDPhys                          ;
        STRLOB  r11, [r14, #IOMD_DRAMWID]               ; Don't fiddle with DRAM config if softloaded

        BL      Probe_DRAM_bank

15          
        ADD     r0, r0, #DRAMBankSize
        MOV     r13, r13, LSL #1                        ; shunt up position in DRAMWID
        CMP     r13, #&0010                             ; if more banks to do
        MOVLT   r10, r9                                 ; then shuffle everything up
        MOVLT   r9, r8
        MOVLT   r8, r6
        BLT     %BT10                                   ; and loop
        DebugTX "Initialise_DRAM_A7000 done"
        DebugReg r10
        DebugTX " = bank 0"
        DebugReg r9
        DebugTX " = bank 1"
        DebugReg r8
        DebugTX " = bank 2"
        DebugReg r6
        DebugTX " = bank 3"
        DebugReg r11
        DebugTX " = DRAMWID"
        ; Move results to correct regs
        MOV     r0, r10
        MOV     r1, r9
        MOV     r2, r8
        MOV     r3, r6
        MOV     r11, #0
        MOV     r12, #0
        B       Find_WS_Page

funnypatterns
        &       &66CC9933   ; 0110 1100 1001 0011
        &       &CC993366   ; 1100 1001 0011 0110

        LTORG


; Probe_DRAM_bank
;   Entry: r0  =  bank address
;   Exit:  r6  =  address lines
;          r1-r5, r7, r12 corrupt
;   Probe a DRAM bank
Probe_DRAM_bank ROUT
        MOV     r12, lr                 ; r12 = return address
      [ Debug
        MOV     r5, r0
        DebugTX "Probe_DRAM_bank"
        DebugReg r5
        DebugTX " = bank address"
        MOV     r0, r5
      ]
        EOR     r1, r0, #A16            ; Check there is some RAM in the bank
        MOV     r6, #0
        BL      DistinctAddresses
      [ Debug
        BEQ     %FT05
        DebugTX "Bank empty"
        MOV     pc, r12
05
      |
        MOVNE   pc, r12                 ; Return if no RAM in the bank
      ]

        ; Only some address lines are decoded by the SIMM.  For example, a 4M SIMM may be split
        ; into 2 banks, with A2-A20 decoded on each, or A2-A19,A21 decoded.  First we need to
        ; find out which address lines are decoded, and which are ignored.
        CMP     r0, #SDRAM0PhysRam
        MOVHS   r6, #SDRAMBankSize
        MOVLO   r6, #DRAMBankSize
        MOV     r7, #A17
        SUB     r6, r6, #1              ; Get address lines which select address within bank.

        ; Loop through the address lines, finding out which are decoded.  We clear the bits in r6
        ; which correspond to non-decoded address lines.
        ; r6 = address line mask
        ; r7 = current address line
10      EOR     r1, r0, r7              ; Toggle the address line
        BL      DistinctAddresses       ; Check if address line has any effect.
        BICNE   r6, r6, r7              ; Clear the bit if the address line doesn't appear to be wired up.
        MOV     r7, r7, LSL #1          ; Move onto the next address line.
        TST     r6, r7                  ; Have we reached the limit?
        BNE     %BT10                   ; Repeat if not.

        ; r6 = decoded address lines in bank. (ie in A0-A25)
      [ Debug
        MOV     r5, r0
        DebugReg r6
        DebugTX " = decoded address lines"
        MOV     r0, r5
      ]

        MOV     pc, r12                 ; Done for this bank.

; DistinctAddresses routine...
; r0,r1 are the addresses to check
; uses r2-5
; writes interleaved patterns (to prevent dynamic storage...)
; checks writing every bit low and high...
; return Z-flag set if distinct

; This routine must work in 32-bit mode

DistinctAddresses ROUT
        LDR     r2, [r0] ; preserve
        LDR     r3, [r1]
        LDR     r4, Pattern
        STR     r4, [r0] ; mark first
        MOV     r5, r4, ROR #16
        STR     r5, [r1] ; mark second
        LDR     r5, [r0]
        CMP     r5, r4 ; check first
        BNE     %10    ; exit with Z clear
        LDR     r5, [r1] ; check second
        CMP     r5, r4, ROR #16 ; clear Z if not same
        BNE     %10
; now check inverse bit writes
        STR     r4, [r1] ; mark second
        MOV     r5, r4, ROR #16
        STR     r5, [r0] ; mark first
        LDR     r5, [r1]
        CMP     r5, r4 ; check second
        BNE     %10   ; exit with Z clear
        LDR     r5, [r0] ; check first
        CMP     r5, r4, ROR #16 ; clear Z if not same
10      STR     r3, [r1] ; restore
        STR     r2, [r0]
        MOV     pc, lr                  ; Z flag is already set up, and other flags don't matter

Pattern
        &       &AAFF5500 ; shiftable bit check pattern

; Find_WS_Page_In_Bank
;  Entry: r4 = bank base address
;         r5 = address lines
;  Exit:  r0-r4 preserved
;         r5-r10 corrupt
;         r13 = top of page if found
Find_WS_Page_In_Bank ROUT
        ; Mark the high bits of the address lines valid so we can mask an
        ; address without losing which bank its in
        CMP     r4, #SDRAM0PhysRam
        ORRHS   r5, r5, #&F8000000
        ORRLO   r5, r5, #&FC000000
        ADRL    r7, HAL_Base + OSROM_HALSize
        LDR     r8, [r7, #OSHdr_Flags]
        TST     r8, #OSHdrFlag_SupportsCompression
        LDRNE   r8, [r7, #OSHdr_CompressedSize]
        LDREQ   r8, [r7, #OSHdr_ImageSize]
        SUB     r7, r7, #OSROM_HALSize ; Start of ROM image
        ADD     r8, r8, #OSROM_HALSize ; Size of compressed ROM image
        ADD     r8, r8, r7 ; End of ROM image
        LDR     r9, =4095
        BIC     r7, r7, r9 ; Round down to page boundary
        ADD     r8, r8, r9 ; Round up to page boundary
        BIC     r8, r8, r9
        SUB     r8, r8, #1 ; End addr inclusive
        CMP     r4, r7 ; Is this bank below the bank the OS is in?
        CMPHS   r8, r4 ; Is this bank above the bank the OS is in?
        ADDLO   r13, r4, #4096
        MOVLO   pc, lr
        ; This bank at least partially intersects the OS. Search page by page for simplicity.
        CMP     r7, r4
        MOVLO   r7, r4 ; Clamp OS start addr to start of bank
        CMP     r4, #SDRAM0PhysRam
        ADDHS   r9, r4, #SDRAMBankSize
        ADDLO   r9, r4, #DRAMBankSize
        CMP     r8, r9
        MOVHI   r8, r9 ; Clamp OS end addr to end of bank
        AND     r7, r7, r5 ; Mask down to just the valid bits
        AND     r8, r8, r5
        MOV     r6, r4 ; Current search address
        MVN     r10, r5 ; inverse lines
10
        CMP     r6, r7
        CMPHS   r8, r6
        ADDLO   r13, r6, #4096
        MOVLO   pc, lr
        ; Try next page
        ADD     r6, r6, #4096 ; Add a page
        ADD     r6, r6, r10 ; Add inverse mask to cause us to skip indistinct address lines
        AND     r6, r6, r5 ; And mask to get back to a valid address we can check with the OS bounds
        CMP     r6, r9
        BLO     %BT10
        ; No free page
        MOV     pc, lr


; Find_WS_Page
;  Entry: r0-r3 = address lines for all 4 RAM banks
;         r11-r12 = address lines for Kinetic SDRAM banks
; Examine the banks and the OS location to find a free page we can use for workspace
Find_WS_Page ROUT
      [ IgnoreDRAM
        ; Pretend there's no DRAM
        ; Note: This won't have affected DRAMCR programming
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
      ]
      [ IgnoreKinetic
        MOV     r11, #0
        MOV     r12, #0
      ]
        MOV     r13, #0                 ; Result
        MOV     r4, #DRAM0PhysRam       ; Current search address
        MOVS    r5, r0
        BLNE    Find_WS_Page_In_Bank
        CMP     r13, #0
        BNE     %FT10
        MOV     r4, #DRAM1PhysRam
        MOVS    r5, r1
        BLNE    Find_WS_Page_In_Bank
        CMP     r13, #0
        BNE     %FT10
        MOV     r4, #DRAM2PhysRam
        MOVS    r5, r2
        BLNE    Find_WS_Page_In_Bank
        CMP     r13, #0
        BNE     %FT10
        MOV     r4, #DRAM3PhysRam
        MOVS    r5, r3
        BLNE    Find_WS_Page_In_Bank
        CMP     r13, #0
        BNE     %FT10
        MOV     r4, #SDRAM0PhysRam
        MOVS    r5, r11
        BLNE    Find_WS_Page_In_Bank
        CMP     r13, #0
        BNE     %FT10
        MOV     r4, #SDRAM1PhysRam
        MOVS    r5, r12
        BLNE    Find_WS_Page_In_Bank
        ; Assume the last call succeeded (if not, we're pretty screwed)
10
        BL      Power_On_Self_Test
      [ Debug
        MOV     r4, r0
        MOV     r5, r1
        MOV     r6, r2
        DebugReg r13
        DebugTX " = top of workspace page"
        MOV     r0, r4
        MOV     r1, r5
        MOV     r2, r6
      ]
        ; Now we have r13 = top of free page
        ; i.e. a stack
        ; Drop into some C code to make the memory analysis significantly easier
        ADRL    r7, HAL_Base + OSROM_HALSize
        LDR     r8, [r7, #OSHdr_Flags]
        TST     r8, #OSHdrFlag_SupportsCompression
        LDR     r9, [r7, #OSHdr_ImageSize]
        LDRNE   r8, [r7, #OSHdr_CompressedSize]
        MOVEQ   r8, r9
        SUB     r7, r7, #OSROM_HALSize ; Start of ROM image
        ADD     r8, r8, #OSROM_HALSize ; Size of compressed ROM image
        ADD     r9, r9, #OSROM_HALSize ; Size of uncompressed ROM image
        MOV     r4, r11
        MOV     r5, r12
        Push    "r0-r5,r7-r9"
        DebugReg r7
        DebugTX " = start of ROM image"
        DebugReg r8
        DebugTX " = size of compressed ROM image"
        DebugReg r9
        DebugTX " = size of uncompressed ROM image"
        MOV     r0,sp
        BL      Decide_On_Memory_Layout
        ; Handle any relocation
        AND     r4, r0, #63 ; spanflags for RAM setup
        BIC     r5, r0, #63 ; ROM relocation address
        DebugTX "Decide_On_Memory_Layout done"
        DebugReg r4
        DebugTX " = spanflags"
        DebugReg r5
        DebugTX " = ROM relocation address"
        Pull    "r0-r3,r11-r12" ; Recover address lines (may get overwritten by relocation)
        ORR     r0, r0, #&FC000000 ; Mark high bits valid so we can mask addresses without losing which bank they're in
        ORR     r1, r1, #&FC000000
        ORR     r2, r2, #&FC000000
        ORR     r3, r3, #&FC000000
        ORR     r11, r11, #&F8000000
        ORR     r12, r12, #&F8000000
        CMP     r5, r7
        BEQ     NoRelocate

        ; ROM relocation code
        ; r5 = dest addr
        ; r7 = src addr
        ; r8 = length
        LDR     r9, =4095
        ADD     r8, r8, r9
        BIC     r8, r8, r9 ; Round length up to page multiple
        ; Work out whether we want to copy up or down
        ; This is made easier by the fact that the copy loop is in the first page of the image
        CMP     r7, #VideoPhysRam
        BLO     Relocate_Backwards ; We're in ROM; just do simple relocation
        CMP     r7, #SDRAM1PhysRam+SDRAMBankSize
        BHI     Relocate_Backwards ; We're above RAM (hopefully): just do simple relocation
        ; Else we're somewhere in RAM
        ; Find which banks r5 & r7 are in, mask the addresses, and work out whether we need to go up or down
        CMP     r5, #DRAM1PhysRam
        ANDLT   r9, r5, r0
        BLT     %FT15
        CMP     r5, #DRAM2PhysRam
        ANDLT   r9, r5, r1
        BLT     %FT15
        CMP     r5, #DRAM3PhysRam
        ANDLT   r9, r5, r2
        BLT     %FT15
        CMP     r5, #SDRAM0PhysRam
        ANDLT   r9, r5, r3
        BLT     %FT15
        CMP     r5, #SDRAM1PhysRam
        ANDLT   r9, r5, r11
        ANDGE   r9, r5, r12
15
        CMP     r7, #DRAM1PhysRam
        ANDLT   r10, r7, r0
        BLT     %FT20
        CMP     r7, #DRAM2PhysRam
        ANDLT   r10, r7, r1
        BLT     %FT20
        CMP     r7, #DRAM3PhysRam
        ANDLT   r10, r7, r2
        BLT     %FT20
        CMP     r7, #SDRAM0PhysRam
        ANDLT   r10, r7, r3
        BLT     %FT20
        CMP     r7, #SDRAM1PhysRam
        ANDLT   r10, r7, r11
        ANDGE   r10, r7, r12
20
        CMP     r9, r10
        MOVEQ   r8, #0 ; After the masking it's possible we were in the right place after all. Set copy length to 0 and fall through to copy code (so we jump to the correct mirror of the ROM)
        BHS     Relocate_Backwards
        ; Fall through to Relocate_Forwards
                
Relocate_Forwards ROUT
        ; Relocate the first page containing this copy loop
        DebugTX_inl "Relocate_Forwards", r9, r10, lr
        ADR     r6, Relocate_Forwards_2
        MOV     r9, #4096
        SUB     r8, r8, #4096
        SUB     r6, r6, r7
        ADD     r6, r6, r5 ; Relocated branch target
10
        SUBS    r9, r9, #4
        LDRGE   r10, [r7], #4
        STRGE   r10, [r5], #4
        BGT     %BT10
        B       Relocate_Done

Relocate_Forwards_2
        ; We're now in the relocated image; copy the rest of ourselves, still in the forwards direction 
        MOV     r9, r8
        ADR     r6, NoRelocate
        B       %BT10

        ; Relocate ourselves, from the top of the image down to the bottom
Relocate_Backwards ROUT
        DebugTX_inl "Relocate_Backwards", r9, r10, lr
        ADR     r6, NoRelocate
        SUB     r6, r6, r7
        ADD     r6, r6, r5 ; Relocated branch target
10
        SUBS    r8, r8, #4
        LDRGE   r9, [r7, r8]
        STRGE   r9, [r5, r8]
        BGT     %BT10
Relocate_Done
        ARM_flush_cacheandTLB r9
        MOV     pc, r6

        LTORG

        ; Relocation code must be in first page in order to cope with overlapping target address (see Relocate_Forwards)
        ASSERT (. - HAL_Base) <= 4096

Count_Hard_ROM ROUT
        ; Entry: Nothing
        ; Exit:  r0 = amount of ROM found in bytes
        ;        r1-r3 & r12 corrupt
        ; This check is done before the MMU is turned on to save having to map in 32MB of logical
        ; address space later (the result is likely to be less than half that). The check
        ; looks for the alias of the first 256B of ROM appearing higher up in the memory map, using a
        ; granularity of 1MB.
        ; The probability of 2^2048 bits being the same in two places in any one ROM is hopefully small. 
        ; By looking for the alias this also deals with the softloaded and compressed ROM case
        ; where OSROM_ImageSize could contain some number larger than the physical chips.
        ; It can't use the ROM checksum because the personalised RISC OS 4 ROMs have the wrong checksum.
        ; For now, only ROM bank 0 is probed, bank 1 isn't tracked out on the RiscPC/A7000/A7000+ anyway.
        MOV     r1, #ROMBank0Phys
        ADD     r0, r1, #1*1024*1024
10
        MOV     r12, #256 - 4
20
        LDR     r2, [r0, r12]           ; Potential alias
        LDR     r3, [r1, r12]           ; Real data
        TEQ     r2, r3
        BNE     %FT40                   ; No match, try next

        SUBS    r12, r12, #4
        BPL     %BT20
30
        SUB     r0, r0, #ROMBank0Phys   ; 256B matched, alias at real size
        MOV     pc, lr
40
        ADD     r0, r0, #1*1024*1024
        CMP     r0, #ROMBank1Phys
        BCC     %BT10
        B       %BT30                   ; End of bank

AddBlock ROUT
        ; Entry: r1 = base
        ;        r2 = end
        ;        r13 = stack (with pushed reference ptr)
        ; Exit:  r0-r3 corrupt
        ;        r13 updated
        ; TODO - This mess of logic to avoid trashing the OS or registering small banks could be made simpler if we used Find_WS_Page?
        CMP     r13, #0
        Pull    "r0",NE ; Get OS_AddRAM reference
        MOVEQ   r0, #0
        CMP     r0, #0
        BNE     %FT10
        ; Check for any overlap with the OS image
        ; This is only necessary if we don't have any workspace yet (since we want to use the first block as workspace)
        ADRL    r0, HAL_Base
        CMP     r0, r1
        MOVHI   r0, #0
        BHI     %FT10
        ADD     r0, r0, #OSROM_HALSize
        LDR     r3, [r0, #OSHdr_ImageSize]
        ADD     r3, r0, r3 ; End of OS
        CMP     r3, r1
        MOVHI   r1, r3 ; Shift start of block up to end of OS
        MOV     r0, #0
10
        CMP     r1, r2
        BGE     %FT90 ; Zero/negative length, skip
        CMP     r13, #0
        ADDEQ   r13, r1, #4096 ; We have a stack!
        ; HAL docs suggest first block must be at least 256K, so check for that
        ; Any blocks which are too small will get collected on the stack and added at the end
        ; (We're unlikely to receive blocks this small, but it's better to be safe than sorry)
        CMP     r0, #0
        BNE     %FT20
        SUB     r0, r2, r1
        CMP     r0, #256*1024
        MOV     r0, #0
        Push    "r0-r2",LT ; push empty OS_AddRAM reference + block details
        MOVLT   pc, lr
20
        Push    "r0,r11-r12,lr"
      [ Debug
        Push    "r1-r2"
        DebugTX "OS_AddRAM"
        LDR     r0, [sp]
        DebugReg r0
        DebugTX " = start"
        LDR     r0, [sp, #4]
        DebugReg r0
        DebugTX " = end"
        LDR     r0, [sp, #8]
        DebugReg r0
        DebugTX " = reference"
        Pull    "r1-r2"
      ]
        CMP     r1, #SDRAM0PhysRam
        LDRHS   r0, =15*OSAddRAM_Speed + OSAddRAM_NoDMA ; Kinetic SDRAM
        MOVLO   r0, #4*OSAddRAM_Speed                   ; Regular DRAM
        LDR     r3, =&ffffffff
        ADRL    R12, HAL_Base + OSROM_HALSize    ; R12 -> RISC OS image
        LDR     R11, [R12, #OSHdr_Entries]
        ADD     R11, R11, R12                    ; R11 -> RISC OS entry table
        CallOSM OS_AddRAM
        ADD     R13,R13,#4
        Pull    "r11-r12,lr"
90
        CMP     r13, #0
        Push    "r0",NE ; Remember reference
        MOV     pc, lr

        MACRO
        Iterate_RAM $lines, $base, $flag, $limit
        ; Must preserve r4-r8, r13
        ; This is essentially an assembler version of the Iterate_RAM C function
        ; See 'Different RAM configurations' in c.cbits for an explanation of what this does!
        ; TODO - Looks like there are enough registers spare for this to be turned into a function?
        CMP     $lines, #0
        BEQ     %FT90
        MVN     r10, $lines
        SUB     r9, r10, #1
        BIC     r9, r10, r9 ; r9 = smallest
        SUB     r10, $lines, r9
        ADDS    r11, r10, #1 ; mask-smallest+1
        BNE     %FT10
        ; Single block
        TST     r4, #$flag
        MOV     r1, #$base
        ADDNE   r1, r1, #$limit
        SUBNE   r1, r1, r9
        ADD     r2, r1, r9
        BL      AddBlock
        B       %FT90
10
        ; Multiple blocks
        BIC     r10, r11, r10 ; r10 = next
        SUB     r11, r10, r9 ; r11 = offset
        TST     r4, #$flag
        MOVEQ   r10, #0 ; r10 = span
        MOV     r12, #0 ; r12 = pos
20
        ADD     r12, r12, r11
        CMP     r12, r10
        MOV     r1, #$base
        ADDGE   r1, r1, r12
        SUBGE   r1, r1, r10
        ADD     r2, r1, r9
        ADDGE   r2, r2, r9
        BL      AddBlock
        MVN     r0, $lines
        ADD     r12, r12, r0
        ADD     r12, r12, r9, LSL #1
        ANDS    r12, r12, $lines
        BNE     %BT20
        CMP     r10, #0
        RSBNE   r1, r9, #$base+$limit
        ADDNE   r2, r1, r9
        BLNE    AddBlock 
90
        MEND

NoRelocate ROUT
        ; Arrive here with:
        ; r0-r3,r11-r12 = address lines
        ; r4 = spanflags
        ; Now we want to go ahead and start calling OS_AddRAM
        BIC     r5, r0, #&FC000000 ; Clear high bits (Iterate_RAM doesn't want them)
        BIC     r6, r1, #&FC000000
        BIC     r7, r2, #&FC000000
        BIC     r8, r3, #&FC000000
        DebugTX "Relocation complete"
        ; Drop into FIQ mode to keep SDRAM results safe
        MSR     CPSR_c, #FIQ32_mode+F32_bit+I32_bit
        MOV     r13, #0
        ; Once we find the first page, we'll use it both as stack and as somewhere to store the OS_AddRAM reference
        ; Iterate through the available RAM
        Iterate_RAM r5, DRAM0PhysRam, 1, A26
        Iterate_RAM r6, DRAM1PhysRam, 2, A26
        Iterate_RAM r7, DRAM2PhysRam, 4, A26
        ; Back to SVC mode for remaining checks
        MOV     r5, r13
        MSR     CPSR_c, #SVC32_mode+F32_bit+I32_bit
        MOV     r13, r5
        BIC     r5, r11, #&F8000000
        BIC     r6, r12, #&F8000000
        Iterate_RAM r8, DRAM3PhysRam, 8, A26
        Iterate_RAM r5, SDRAM0PhysRam, 16, A27
        Iterate_RAM r6, SDRAM1PhysRam, 32, A27
        ; Use SD0ENDA to store the Kinetic test results, for reading back in HAL_Init
        ORRS    r5, r5, r6
        MVNNE   r6, #0
        MOV     r6, #IOMDPhys
        STR     r5, [r6, #IOMD_SD0ENDA]
        ; Handle any small blocks which we postponed registering
        MOV     r5, r13, LSL #20
        ADDS    r5, r5, #4<<20
        BEQ     %FT20
10
        Pull    "r0-r2" ; Reference + block details
        Push    "r0"
        BL      AddBlock
        ADDS    r5, r5, #8<<20
        BNE     %BT10
20
        ; Now we can finally detect some VRAM, and then get on with starting the OS
        B       Initialise_VRAM


; Initialise_VRAM
; Entry: r12 = IOMD
;        r13 = stack pointer with OS_AddRAM reference
; Exit:  r0 = VRAM base (0 if none)
;        r1 = VIDCR setting
;        r6 = VRAM size (MB)
Initialise_VRAM ROUT
        DebugTX "Initialise_VRAM"
        MOV     r12, #IOMDPhys
        LDRB    r0, [r12, #IOMD_ID0]
        LDRB    r1, [r12, #IOMD_ID1]
        ORR     r0, r0, r1, LSL #8
        LDR     r1, =IOMD_Original
        CMP     r0, r1
        BEQ     Initialise_VRAM_RiscPC
        B       Initialise_VRAM_A7000


; Initialise_VRAM_RiscPC
; Entry: r12 = IOMD
;        r13 = stack pointer with OS_AddRAM reference
; Exit:  r0 = VRAM base (0 if none)
;        r1 = VIDCR setting
;        r6 = VRAM size (MB)
Initialise_VRAM_RiscPC ROUT
        MOV     r0, #VideoPhysRam                       ; point at VRAM

        MOV     r2, #IOMD_VREFCR_VRAM_256Kx64 :OR: IOMD_VREFCR_REF_16 ; assume 2 banks of VRAM by default
        STRB    r2, [r12, #IOMD_VREFCR]
        
        ADD     r1, r0, #A22                            ; Check for 8M VRAM - for RPCemu
        BL      DistinctAddresses
        MOVEQ   r6, #8
        BEQ     %FT20

        ADD     r1, r0, #A2                             ; test A2
        BL      DistinctAddresses
        MOVEQ   r6, #2                                  ; we've got 2M of VRAM
        BEQ     %FT20

        MOV     r2, #IOMD_VREFCR_VRAM_256Kx32 :OR: IOMD_VREFCR_REF_16
        STRB    r2, [r12, #IOMD_VREFCR]

        ADD     r1, r0, #A2                             ; check for any VRAM at all
        BL      DistinctAddresses
        MOVEQ   r6, #1                                  ; we've got 1M of VRAM
        MOVNE   r6, #0                                  ; no VRAM
20
 [ IgnoreVRAM
        MOV     r6, #0                                  ; pretend there's no VRAM
 ]
        CMP     r6, #1
        MOVCC   r1, #IOMD_VIDCR_DRAMMode :OR: &10       ; if no VRAM, then turn on DRAM mode, and set increment to &10
        MOVEQ   r1, #SAMLength/2/256                    ; if 1M VRAM, then use VRAM mode, and set increment for 1/2 SAM
        MOVHI   r1, #SAMLength/2/256*2                  ; if 2M VRAM, then use VRAM mode, and set increment for 2*1/2 SAM
        MOVCC   r0, #0                                  ; Clear VRAM base if there is no VRAM
        CMP     r6, #8
        MOVEQ   r1, #SAMLength/2/256*3                  ; Fake SAM length for RPCEmu (purely so Video_init can detect that we've got 8MB)        
        B       Add_VRAM

; Initialise_VRAM_A7000
; Entry: r12 = IOMD
;        r13 = stack pointer with OS_AddRAM reference
; Exit:  r0 = VRAM base (0 if none)
;        r1 = VIDCR setting
;        r6 = VRAM size (MB)
Initialise_VRAM_A7000 ROUT
        MOV     r6, #0                                  ; No VRAM
        MOV     r0, #0
        MOV     r1, #IOMD_VIDCR_DRAMMode :OR: &10       ; Turn on DRAM mode, and set increment to &10
        B       Add_VRAM

; Add_VRAM
; Entry: r0 = VRAM base (0 if none)
;        r1 = VIDCR setting
;        r6 = VRAM size (MB)
;        r13 = stack pointer with OS_AddRAM reference
Add_VRAM ROUT
      [ Debug
        Push    "r0-r1"
        DebugTX "Add_VRAM"
        LDR     r0, [sp]
        DebugReg r0
        DebugTX " = base"
        LDR     r0, [sp, #4]
        DebugReg r0
        DebugTX " = VIDCR"
        DebugReg r6
        DebugTX " = size"
        Pull    "r0-r1"
      ]
        ; Tell IOMD about VRAM.
        MOV     r14, #IOMDPhys
        STRB    r1, [r14, #IOMD_VIDCR]

        ADRL    R5, HAL_Base + OSROM_HALSize    ; R5 -> RISC OS image
        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table

        ; Tell OS about VRAM
        CMP     R6,#0
        Pull    "r3",EQ                 ; parameter for OS_Start
        BEQ     %FT10
        MOV     R1,R0
        ADD     R2,R1,R6,LSL #20
        LDR     R3,=&FFFFFFFF
        LDR     R0,=4*OSAddRAM_Speed+OSAddRAM_IsVRAM
        CallOSM OS_AddRAM
        ADD     R13,R13,#4
        MOV     R3,R0
10
        ; R3 = OS_AddRAM reference number
        ; R5 = OS header
        ; R11 = OS entry table

; Check the various reset flags

        MOV     R0, #0
        MOV     R12, #IOMDPhys
        LDRB    R1, [R12, #IOCIRQSTAA]
        ANDS    R1, R1, #por_bit
        STRNEB  R1, [R12, #IOCIRQCLRA]  ; clear POR if set
        ORRNE   R0, R0, #OSStartFlag_POR

 [ CheckProtectionLink
        LDR     R2, =IOMD_MonitorType

; on Issue A's the protection bit is only weakly pulled up,
; so force it high, then read it back

        LDRB    R1, [R2]
        ORR     R1, R1, #IOMD_ProtectionLinkBit
        STRB    R1, [R2]
        LDRB    R1, [R2]
        TST     R1, #IOMD_ProtectionLinkBit
        ORREQ   R0, R0, #OSStartFlag_NoCMOSReset
 ]

     [ Debug
        Push    "r0"
        DebugTX "OS_Start"
        LDR     r0, [sp]
        DebugReg r0
        DebugTX " = flags"
        DebugReg r3
        DebugTX " = OS_AddRAM reference"
        Pull    "r0"
     ]
        MOV     R1, R5
        ADRL    R2, HALdescriptor
        CallOSM OS_Start
        
        END
@


1.11
log
@Fix for distorted audio output on A7k/A7k+
The VIDMUX register (which used to be poked in the Kernel) was not being set up, so the audio data was being sent to the DACs with an extra bit of phase shift between the data and the LRCLK - this resulted in lots of clipping.

Version 0.26. Tagged as 'IOMD-0_26'
@
text
@d232 1
a232 1
        MRC     p15, 0, r0, c0, c0, 0           ; read id
d336 1
a336 1
        BL      Add_DRAM_bank
d356 1
d358 23
a380 4
        ; There aren't any sensible registers that we can use to detect if we're running on a Kinetic
        ; However if a Kinetic is fitted, Add_DRAM_bank should be able to detect the first SDRAM bank, while failing on IOMD machines (due to it mapping to ROM bank 0)
        ; We can then use the presence of that bank as a hint that the 2nd bank (which would alias DRAM bank 0 on IOMD) should be present
        MOV     r13, r6
d382 15
a396 6
        BL      Add_DRAM_bank
        MOVS    r11, r6
        MOVNE   r0, #SDRAM1PhysRam
        BLNE    Add_DRAM_bank
        MOV     r12, r6
        MOV     r6, r13
d401 1
a401 6
        B       IsAKinetic
NotAKinetic
        ; Clear Kinetic results
        MOV     r11, #0
        MOV     r12, #0
IsAKinetic
d450 1
a450 1
        BL      Add_DRAM_bank
d487 1
a487 1
; Add_DRAM_bank
d491 2
a492 2
;   Probe a DRAM bank, and add any DRAM found to the workspace
Add_DRAM_bank ROUT
d496 1
a496 1
        DebugTX "Add_DRAM_bank"
d528 1
a528 1
        BICNE   r6, r6, r7              ; Clear the bit if the address line fails.
@


1.10
log
@Add Kinetic support
Detail:
  hdr/IOMD - Add definitions for the interesting bits of the Kinetic memory map
  hdr/StaticWS - Add an extra flag to workspace for whether we're running on a Kinetic
  s/Top - Add debug options for ignoring DRAM & ignoring the Kinetic card. Update startup code to add Kinetic card + SDRAM detection. Current code makes no attempt to configure the SDRAM timings and assumes the correct settings have been set via the DIP switches.
  s/Boot - Update HAL_CleanerSpace, HAL_PhysInfo & HAL_InitDevices to cope with running on a Kinetic.
  s/Post - Update POST routine register usage. Add experimental (disabled) code to not count a "SDRAM+VRAM but no DRAM" situation as a POST failure. The OS will boot in that configuration, but lack of DMA capable memory is troublesome.
  s/ATA - Adjust the flags returned by HAL_ATAControllerInfo to match the comments. Although the old flags were technically wrong, this had no effect on function as the lack of DMA support meant they were never acted on by ADFS.
Admin:
  Tested in ROM softload on Kinetic RiscPC, and in RPCEmu
  Note that if a Kinetic card is fitted, the IOMD DMA HAL devices won't be registered with the OS, as DMAManager isn't yet ready to cope with the possibility of DMA-incapable memory.


Version 0.25. Tagged as 'IOMD-0_25'
@
text
@d220 3
@


1.9
log
@Correct the sense of the protection link LK5
Top.s: ORRNE -> ORREQ to match RISC OS 3.70 et al
KbdScan.s: Substitute a few of the constants to make it simpler to read
Tested on a Risc PC with and without protection enabled, compared with RISC OS 3.70 ROMs.

Version 0.21. Tagged as 'IOMD-0_21'
@
text
@d32 6
d118 1
a118 1
; 6. Relocate_Fordwards/Relocate_Backwards - ROM image relocation
d353 22
d449 2
d457 2
d489 3
a491 1
        MOV     r6, #DRAMBankSize
d563 3
a565 1
        ORR     r5, r5, #&FC000000
d586 3
a588 1
        ADD     r9, r4, #DRAMBankSize
d612 1
d615 12
d646 10
d681 3
a683 1
        Push    "r0-r3,r7-r9"
d693 2
a694 2
        AND     r4, r0, #15 ; spanflags for RAM setup
        BIC     r5, r0, #15 ; ROM relocation address
d700 1
a700 1
        Pull    "r0-r3" ; Recover address lines (may get overwritten by relocation)
d705 2
d721 1
a721 1
        CMP     r7, #DRAM3PhysRam+DRAMBankSize
d733 7
a739 1
        ANDGE   r9, r5, r3
d749 7
a755 1
        ANDGE   r10, r7, r3
d798 3
a800 1
        ; Relocation code must be in first page in order to cope with overlapping target address
d892 3
a894 1
        MOV     r0, #4:SHL:8
d908 1
a908 1
        Iterate_RAM $lines, $base, $flag
d924 1
a924 1
        ADDNE   r1, r1, #A26
d951 1
a951 1
        RSBNE   r1, r9, #$base+A26
d959 1
a959 1
        ; r0-r3 = address lines
d967 2
d972 17
a988 4
        Iterate_RAM r5, DRAM0PhysRam, 1
        Iterate_RAM r6, DRAM1PhysRam, 2
        Iterate_RAM r7, DRAM2PhysRam, 4
        Iterate_RAM r8, DRAM3PhysRam, 8
d1110 1
a1110 1
        LDR     R0,=4:SHL:8+1
@


1.8
log
@Fix to HAL_FIQEnable and HAL_FIQDisable
Interrupts.s
 A typo meant that any attempt to enable FIQs actually OR'd the mask register with the temporary PSR value. To add to the woes this PSR value has I32 and F32 set, which means the bit 7 (software generated FIQ) was getting enabled.
 The main use of FIQs on IOMD is ADFS, the result of this bug was that floppies immediately locked up the machine because the data pump routines could never clear the FIQ.
 Similar typo in HAL_FIQDisable.
Top.s
 Retire STB conditional.

Version 0.19. Tagged as 'IOMD-0_19'
@
text
@d1019 1
a1019 1
        ; R3 = OS_Start parameter
d1043 1
a1043 1
        ORRNE   R0, R0, #OSStartFlag_NoCMOSReset
@


1.7
log
@Addition of POST checking
Unlike some more recent targets, there are a lot of optional/removeable bits on IOMD platforms which may stop the machine booting, this checks for
* VRAM (non fatal if missing)
* RAM
* ROM checksum
* Video timing
* IOMD
in the event of a failure the fault code is flashed on the floppy drive LED (pattern decoder in TRM appendix A).

Video.s: the POST code highlighted that the VIDCTAB had the wrong VCO reference clock on Medusa - this is now corrected for a 60Hz mode.
IOMD.hdr: share the address line bits
Tested on Risc PC + A7000, the timing emulation is not accurate enough on RPCEmu, so POST is skipped under emulation.

Version 0.18. Tagged as 'IOMD-0_18'
@
text
@a28 3
                GBLL    RO371Timings
RO371Timings    SETL    :LNOT: STB      ; When TRUE, assume 32 bit DRAM always

d357 4
a360 14
  [ RO371Timings
        MOV     r11, #&70     ;all 4 banks assumed 32 bit - EDO and timing bits set in case 7500FE (don't care bits otherwise)
  |
        MOV     r11, #IOMD_DRAMWID_DRAM_32bit * &0F     ;set all 4 banks to be 32bit initially
        MOV     r12, #IOMDPhys
        LDRB    r0, [r12, #IOMD_ID0]    ; load r1 with IOMD ID high byte
        LDRB    r1, [r12, #IOMD_ID1]    ; load r0 with IOMD ID low byte
        ORR     r0,r0,r1,LSL#8          ; Or r0 and r1, shifted left 8, put in
        LDR     r1, =IOMD_7500FE
        TEQ     r0, r1                                  ; are we on FE part?
        ORREQ   r11, r11, #IOMD_DRAMWID_EDO_Enable :OR: IOMD_DRAMWID_RASCAS_3 :OR: IOMD_DRAMWID_RASPre_3
                                                        ; if so, then enable EDO and slower RASCAS and RASPre times
        ! 0,"7500FE support expects EDO memory in s.ARM600"
  ]
@


1.6
log
@Added autodetection of ROM size
New function Count_Hard_ROM looks with the MMU off at how big the ROM chip is (because both softloaded and compressed ROMs might be smaller or larger than the chips themselves).
Adopt revised HAL_PhysInfo API.
Removed pointless setting of ECTCR since the podule manager does that itself anyway.
Last two NullEntry in the entry point table trimmed.
Tested on RPCEmu (which emulates 8MB of ROM) and a Risc PC (with 4MB ROM).

Version 0.17. Tagged as 'IOMD-0_17'
@
text
@d46 1
d50 1
d107 2
a108 1
;    - MedusaInit for ARM6/7/SA
d113 5
a117 4
; 4. Decide_On_Memory_Layout - Decide how we're going to present the physical RAM to RISC OS, and where to relocate our ROM image (if necessary)
; 5. Relocate_Fordwards/Relocate_Backwards - ROM image relocation
; 6. NoRelocate - Register DRAM with RISC OS
; 7. Initialise_VRAM - Locate all VRAM, program control registers, register with RISC OS
d120 1
a120 1
; 8. RISCOS_Start
d405 1
a405 1
        MOV     r14, #IOMDPhys                         ;
a532 36
; Constants
;
A0      *       1 :SHL: 00
A1      *       1 :SHL: 01
A2      *       1 :SHL: 02
A3      *       1 :SHL: 03
A4      *       1 :SHL: 04
A5      *       1 :SHL: 05
A6      *       1 :SHL: 06
A7      *       1 :SHL: 07
A8      *       1 :SHL: 08
A9      *       1 :SHL: 09
A10     *       1 :SHL: 10
A11     *       1 :SHL: 11
A12     *       1 :SHL: 12
A13     *       1 :SHL: 13
A14     *       1 :SHL: 14
A15     *       1 :SHL: 15
A16     *       1 :SHL: 16
A17     *       1 :SHL: 17
A18     *       1 :SHL: 18
A19     *       1 :SHL: 19
A20     *       1 :SHL: 20
A21     *       1 :SHL: 21
A22     *       1 :SHL: 22
A23     *       1 :SHL: 23
A24     *       1 :SHL: 24
A25     *       1 :SHL: 25
A26     *       1 :SHL: 26
A27     *       1 :SHL: 27
A28     *       1 :SHL: 28
A29     *       1 :SHL: 29
A30     *       1 :SHL: 30
A31     *       1 :SHL: 31


d610 1
d946 2
d950 2
a951 4

        ; Check for 8mb VRAM - for RPCemu
        MOV     r0, #VideoPhysRam
        ADD     r1, r0, #A22
a955 1
        MOV     r0, #VideoPhysRam                       ; point at VRAM
d963 1
@


1.5
log
@Add HAL device for VIDC20
Required by VIDC20Video to locate the controller and its info.
Moved the HAL video code out into a module.
Reordered the power on VIDC pokes to disable sound ASAP.
Added a header file to the 'cbits' for 1 less warning.
Used IOMDPhys where we mean its physical address, and IOMD_Base where offsets are being referred to.
Set up "CLines" single GPIO bit as input (it's the only thing on port C on the A7000/A7000+.
Tested on RiscPC and RPCEmu.

Version 0.16. Tagged as 'IOMD-0_16'
@
text
@d135 1
a135 1
; of 32-bit wide ROMs on MORRIS, a write will already have happened, to get ROMCR0 from
d168 1
a168 4
        STRB    r0, [r12, #IOMD_ROMCR0]         ; Prog. the reg.s

; Program the 2nd ROM bank

a170 1

d194 2
a195 6
        STRB    r0, [r12, #IOMD_ROMCR0]         ; Prog. the reg.s

; Program the 2nd ROM bank

        STRB    r0, [r12, #IOMD_ROMCR1]         ; Program the 2nd bank the same as the 1st

d230 1
a230 1
        STRB    r0, [r12, #IOMD_ROMCR1]         ; and do the same for extension ROMs (just in case)
d240 1
a240 1
; Podule manager wants TypeA setting by default for all podules
a242 4
        MOV     r0, #0                          
        STRB    r0, [r1, #IOMD_ECTCR]

; Now bang IOMD (disable all but keyboard interrupts)
d284 5
a288 1
        B       Initialise_DRAM
a291 1
        MOV     r12, #IOMDPhys
d768 34
@


1.4
log
@Fix detection of multiple DRAM banks when debugging enabled
Detail:
  s/Top - The debug output at the end of Add_DRAM_bank was corrupting R0, causing any banks after the 1st occupied one to fail detection
Admin:
  Tested in ROM softload on StrongARM RiscPC


Version 0.14. Tagged as 'IOMD-0_14'
@
text
@a24 1
        $GetVIDC
d26 2
a27 5
                GBLL    CheckProtectionLink     ; if true, disallow CMOS RAM changes if link in protected position
CheckProtectionLink SETL (IO_Type = "IOMD") :LAND: {TRUE}       ; NB affects Delete/Copy/R/T and 0-9/.

                GBLL    VCOstartfix
VCOstartfix     SETL    {TRUE}
d30 1
a30 1
RO371Timings    SETL    :LNOT: STB
d33 1
a33 1
IgnoreVRAM      SETL    {FALSE}
d46 1
d84 1
a84 1
        DCD     &0000B632, &0000E3A0    ; 20: MOV  R11, #IOMD_Base - point at IOMD physical address
d131 1
a131 1
        MOV     r12, #IOMD_Base
d250 1
d252 1
a252 10
        STRB    r0, [r12, #IOMD_ECTCR]

; VInit etc set on ze mode change: no DMA going yet so don't set owt.

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        ADRL    R2, VIDCTAB     ; we may get vsync interrupts that stiff us
10      LDR     R0, [R2], #4    ; permanently as VIDC is in an undefined state
        CMP     R0, #-1         ; so have mode 0 with all black palette
        STRNE   R0, [R1]
        BNE     %BT10
a255 1
        MOV     R1, #IOMD_Base
d267 1
a267 5
  [ Keyboard_Type = "PC"
        MOV     R0, #serial_Rx_bit      ; used for Archi keyboard or IOMD PC keyboard
  ]

; now bits to allow CMOS read/write : need timer
d269 3
a271 3
        LDR     R0, =20000-1    ; R0 = Timer delay (units of 0.5 microsecond)
                                ; 20000*0.5E-6 = 0.01 Seconds (100Hz ticker)
                                ; TMD 21-May-93: "-1" correction applied
d281 1
a281 26
  [ VCOstartfix
        ;2nd part of fix for VCO failing to start on A7000 (esp. 7500FE) - forcing PCOMP high for about 3 ms
        LDRB    R0, [R1,#IOMD_ID0]
        CMP     R0, #&E7
        LDREQB  R0, [R1,#IOMD_ID1]
        CMPEQ   R0, #&D4
        BEQ     vcofix_notMorris      ; risky to force PCOMP on Risc PC
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000A46        ; VIDC20 FSYNREG, as in VIDCTAB but with force PCOMP high
        STR     R2, [R0]
        MOV     R0, #3072*2           ; time delay of about 3 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
vcofix_waitloop
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     vcofix_waitloop       ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     vcofix_waitloop       ; loop if not finished
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000A06        ; VIDC20 FSYNREG, as in VIDCTAB (PCOMP low again)
        STR     R2, [R0]
vcofix_notMorris
  ]
d284 5
a288 1
        STRB    R0, [R1, #IOMD_ATODICR] ; power down the A to D convertor
d300 1
a300 1
        MOV     r12, #IOMD_Base
d317 1
a317 1
        MOV     r14, #IOMD_Base
d331 1
a331 1
        MOV     r14, #IOMD_Base
d369 1
a369 1
        MOV     r12, #IOMD_Base
d380 1
a380 1
        MOV     r14, #IOMD_Base
d410 1
a410 1
        MOV     r14, #IOMD_Base                         ;
d935 1
a935 1
        MOV     r12, #IOMD_Base
d1019 1
a1019 1
        MOV     r14, #IOMD_Base
d1045 1
a1045 1
        MOV     R12, #IOMD_Base
a1064 8
 [ STB :LAND: IOMD_C_FrontPanelButton <> 0
  [ FrontPanelButtClearsCMOS
        LDRB    R1, [R12, #IOMD_CLINES] ; if front panel button pressed then CMOS reset
        TST     R1, #IOMD_C_FrontPanelButton
        ORRNE   R0, R0, #OSStartFlag_CMOSReset
  ]
 ]

a1078 66

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data tables: VIDC := mode 0, all palette black

VIDCTAB DATA
; Program Control Register first, to clear power-down bit
; Now depending upon the VIDCClockSource flag, re-program the clock source.
   [ VIDCClockSource = "VCO"
     [ VCOstartfix
        & &E0000404     ; CR: FIFO load 16 words, 1 bpp, ck/2, vclk (allow for doubled VCO freq)
     |
        & &E0000400     ; CR: FIFO load 16 words, 1 bpp, ck/1, vclk
     ]
   ]
   [ VIDCClockSource = "HCLK"
        & &E0000401     ; CR: FIFO load 16 words, 1 bpp, ck/1, hclk
   ]
   [ VIDCClockSource = "RCLK"
        & &E0000406     ; CR: FIFO load 16 words, 1 bpp, ck/2, rclk
   ]

; Don't bother programming all 256 palette entries, we'll be here all night
; Since we're setting up a 1 bit-per-pixel mode, just do colours 0 and 1

        & &10000000     ; Palette address register = 0
        & &00000000     ; Colour 0 = black
        & &00000000     ; Colour 1 = black
        & &40000000     ; Border colour = black
        & &50000000     ; Pointer colour 1 = black
        & &60000000     ; Pointer colour 2 = black
        & &70000000     ; Pointer colour 3 = black

; Get a stable display up so we get stable signals

        & &80000318     ; HCR + 8 = 94 + 22 + 22 + 640 + 22 + 0
        & &81000056     ; HSWR+ 8 = 94
        & &82000068     ; HBSR+12 = 94 + 22
        & &83000078     ; HDSR+18 = 94 + 22 + 22
        & &840002F8     ; HDER+18 = 94 + 22 + 22 + 640
        & &85000314     ; HBER+12 = 94 + 22 + 22 + 640 + 22
        & &86000079     ; HCSR+17 = HDSR+18

        & &9000020B     ; VCR +2 = 2 + 32 + 0 + 480 + 0 + 11
        & &91000000     ; VSWR+2 = 2
        & &92000021     ; VBSR+1 = 2 + 32
        & &93000021     ; VDSR+1 = 2 + 32 + 0
 [ MEMC_Type = "IOMD"
        & &94000201     ; VDER+1 = 2 + 32 + 0 + 480
 | ;MEMC_Type <> "IOMD"
        & &94000201     ; VDER+1 = 2 + 32 + 0 + 480
 ] ;MEMC_Tupe = "IOMD"
        & &95000201     ; VBER+1 = 2 + 32 + 0 + 480 + 0
        & &96000021     ; VCSR+1 = VDSR+1
        & &97000021     ; VCER+1 = VDSR+1

        & &B1000001     ; SCR: sound disabled (+use 24MHz clock)

        & &C00F1003     ; EREG = comp sync, DACs on, ereg output ext lut
   [ VCOstartfix
        & &D0000A06     ; FSYNREG, clk = (10+1)/(6+1) * 32MHz = 50.286MHz  (higher frequency as part of fix)
   |
        & &D0000A0D     ; FSYNREG, clk = (10+1)/(13+1) * 32MHz = 25.143MHz
   ]
        & &F0013000     ; DCR: bus D[31:0], Hdisc       ;RCM 29/9/94: changed from &F0012000 at PSwindells request
        & &FFFFFFFF     ; That's the lot

@


1.3
log
@Add debugging code. Fix detection of RAM in bank 3.
Detail:
  hdr/Debug, hdr/UART, s/Boot, s/Debug, Makefile - Added HAL_DebugTX/HAL_DebugRX implementations, and assorted functions/macros for getting pre-MMU debug output from the HAL. Use Debug switch in hdr/Debug to turn debugging on/off (currently off by default).
  s/Top - Added lots of debug output to help track down RAM detection/configuration issues. Fixed RAM detection result for bank 3 being overwritten with result for bank 2 in NoRelocate.
Admin:
  Tested under RPCEmu & StrongARM softload
  Warning - RPCEmu doesn't emulate the serial line status register. This means debug builds will hang on startup.


Version 0.13. Tagged as 'IOMD-0_13'
@
text
@d528 2
d532 2
@


1.2
log
@Fix to HAL_MachineID
In transplanting the unique id chip bit basher, the routine carefully preserves the (write only) IOControl register in IOMD, but unfortunately uses a softcopy of 0 since that's never set. Since the I2C startup happens first the ID line is low pretty quickly after startup, therefore the ID chip reset doesn't work (needs a H-L-H transition) and so no unique ID is retrieved.

hdr.StaticWS: define symbol for Medusa.
s.Boot: once some workspace is available, ensure the softcopy matches the hardware.
s.MachineID: trim out the CheckCRC function since the Kernel does this, allows the error exit to be a bit more simple too.
s.Top: improve commenting of startup sequence, and get some consistency on IOC/IOMD, since this doesn't run on IOC. Move the default podule setup into the common setup.

Inspected on a scope, pin 2 of the DS2401 wiggles appropriately and a valid looking MAC address is available from OS_ReadSysInfo 4.

Version 0.12. Tagged as 'IOMD-0_12'
@
text
@d46 1
d327 6
d341 2
d381 11
d460 11
d490 7
d500 6
d507 1
d528 2
d684 10
d707 6
d717 6
a722 1
        BICS    r5, r0, #15 ; ROM relocation address
d728 1
a728 1
        CMPNE   r5, r7
d773 1
d794 1
d813 1
a813 1
        ;        r13 = stack/reference ptr
d851 14
d936 2
a937 1
        BIC     r8, r2, #&FC000000
d967 1
d1038 13
d1106 10
@


1.1
log
@Rewrite Makefile & RAM setup code. Remove/tidy other scripts. Add support for compressed ROMs, keyboard scan, HAL_Reset, HAL_MonitorLeadID and HAL_PhysInfo.
Detail:
  Makefile, MkClean,fd7, MkRom,fd7 - Rewritten
  CopyIt,feb, CopyIt2,feb, CopyItKB,feb, GlueIt,feb, aif, bin, gpa, o - Deleted obsolete files/folders
  s/Boot, s/Top - Moved image entry point from s/Boot to s/Top, to match other HALs. Rewritten RAM setup code to avoid poking dangerous registers during softloads, and to hopefully fix problems people have been having with some memory configurations.
  c/cbits - C code for use during RAM initialisation. Examines the detected RAM banks to work out the optimal physical RAM layout and where to relocate the ROM image, taking into account any ROM compression.
  s/ATA - Convert tabs to spaces for consistency. Fix conditional MOV pc,lr in HAL_ATACableID.
  s/Boot - Added HAL_PhysInfo implementation, based around pre-HAL kernel code. Added HAL_Reset implementation, using similar code to the softload tool to disable the MMU and restart the ROM. Convert tabs to spaces for consistency.
  s/Video, hdr/StaticWS - Added HAL_MonitorLeadID implementation, based around pre-HAL kernel code. Retab Video_init.
  s/KbdScan, hdr/StaticWS - Added HAL_KbdScan_* implementation, based around pre-HAL kernel code.
  s/NVRAM - Convert tabs to spaces for consistency
  hdr/Copro15ops - ARMv3/v4 cache/TLB macros for use during HAL_Reset
  hdr/IOMD - New header to pull together all the physical memory map definitions
Admin:
  Tested in IOMD ROM softload on RiscPC, plus as 'real' ROM under RPCEmu
  New RAM setup code may be a bit buggy still


Version 0.11. Tagged as 'IOMD-0_11'
@
text
@d86 2
a87 2
        DCD     &0000B632, &0000E3A0    ; 20: MOV R11, #IO+IOMDREGS - point at IOMD
        DCD     &00000000, &0000E3A0    ; 28: MOV R0, #&0 - ROMCR:32b,slow,218.75us,no burst
d89 1
a89 1
        DCD     &0000F000, &0000E3A0    ; 38: MOV PC, #0 - jump to 0 (this instr pre-fetched)
a153 1

d155 1
a155 1
; Here bceause its an ARM7500 'FE' variant
a157 1

d166 1
a166 1
;
a182 1
;
d197 1
a197 1
        LDRB    r0, [r12, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
d200 1
a200 1
        STRB    r0, [r12, #IOMD_ROMCR0]          ; Prog. the reg.s
a211 2
;
;
d217 1
a217 1
        MOV     r0, #IOMD_VREFCR_REF_16                         ; select 16µs refresh
a222 3
        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
        STRB    r0, [r12, #IOMD_ECTCR]

d232 1
a232 1
        MRC     p15, 0, r0, c0, c0, 0   ; read id
d234 2
a235 2
        TEQ     r0, #&A000              ; is that my old friend, StrongARM?
        MCREQ   p15, 0, r0, c15, c1, 2  ; enable fast core clock
d237 1
a237 1
        MOV     r0, #&12    ; 5-3 cycle ROM access
d239 1
a239 1
        STRB    r0, [r12, #IOMD_ROMCR0]
d241 1
d248 5
a252 1
        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
a254 2
CommonInit

d264 1
a264 1
; Now bang IOC (disable all but keyboard interrupts)
d266 1
a266 1
        MOV     R1, #IOC
d979 1
a979 1
        MOV     R12, #IOC
@


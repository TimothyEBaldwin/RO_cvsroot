head	1.7;
access;
symbols
	OMAP3-1_18:1.7
	OMAP3-1_17:1.7
	OMAP3-1_16:1.7
	OMAP3-1_15:1.7
	OMAP3-1_14:1.7
	SMP:1.7.0.2
	SMP_bp:1.7
	OMAP3-1_13:1.7
	OMAP3-1_12:1.7
	OMAP3-1_11:1.7
	OMAP3-1_10:1.7
	OMAP3-1_09:1.7
	OMAP3-1_08:1.6
	OMAP3-1_07:1.6
	OMAP3-1_06:1.6
	OMAP3-1_05:1.6
	OMAP3-1_04:1.6
	OMAP3-1_03:1.6
	OMAP3-1_02:1.6
	OMAP3-1_01:1.6
	OMAP3-1_00:1.6
	OMAP3-0_99:1.6
	OMAP3-0_98:1.6
	OMAP3-0_97:1.6
	OMAP3-0_96:1.6
	OMAP3-0_95:1.6
	OMAP3-0_94:1.6
	OMAP3-0_93:1.6
	OMAP3-0_92:1.6
	OMAP3-0_91:1.6
	OMAP3-0_90:1.6
	OMAP3-0_89:1.6
	OMAP3-0_88:1.6
	OMAP3-0_87:1.6
	OMAP3-0_86:1.6
	OMAP3-0_85:1.6
	OMAP3-0_84:1.6
	OMAP3-0_83:1.6
	OMAP3-0_82:1.6
	OMAP3-0_81:1.6
	OMAP3-0_80:1.6
	OMAP3-0_79:1.6
	OMAP3-0_78:1.6
	OMAP3-0_77:1.6
	OMAP3-0_76:1.6
	OMAP3-0_75:1.6
	OMAP3-0_74:1.6
	OMAP3-0_73:1.6
	OMAP3-0_72:1.6
	OMAP3-0_71:1.6
	OMAP3-0_70:1.6
	OMAP3-0_69:1.6
	OMAP3-0_68:1.6
	OMAP3-0_67:1.6
	OMAP3-0_66:1.6
	OMAP3-0_65:1.6
	OMAP3-0_64:1.6
	OMAP3-0_63:1.6
	OMAP3-0_62:1.6
	OMAP3-0_61:1.6
	OMAP3-0_60:1.5
	OMAP3-0_59:1.5
	OMAP3-0_58:1.5
	OMAP3-0_57:1.5
	OMAP3-0_56:1.5
	OMAP3-0_55:1.5
	OMAP3-0_54:1.5
	OMAP3-0_53:1.5
	OMAP3-0_52:1.5
	OMAP3-0_51:1.5
	OMAP3-0_50:1.5
	OMAP3-0_49:1.5
	OMAP3-0_48:1.5
	OMAP3-0_47:1.5
	OMAP3-0_46:1.5
	OMAP3-0_45:1.5
	OMAP3-0_44:1.5
	OMAP3-0_43:1.5
	OMAP3-0_42:1.5
	OMAP3-0_41:1.5
	OMAP3-0_40:1.5
	OMAP3-0_39:1.5
	OMAP3-0_38:1.5
	OMAP3-0_37:1.5
	OMAP3-0_36:1.5
	OMAP3-0_35:1.5
	OMAP3-0_34:1.5
	OMAP3-0_33:1.5
	OMAP3-0_32:1.5
	OMAP3-0_31:1.4
	OMAP3-0_30:1.4
	OMAP3-0_29:1.4
	OMAP3-0_28:1.4
	OMAP3-0_27:1.4
	OMAP3-0_26:1.4
	OMAP3-0_25:1.4
	OMAP3-0_24:1.4
	OMAP3-0_23:1.4
	OMAP3-0_22:1.4
	OMAP3-0_21:1.4
	OMAP3-0_20:1.3
	OMAP3-0_19:1.3
	OMAP3-0_18:1.3
	OMAP3-0_17:1.3
	OMAP3-0_16:1.3
	OMAP3-0_15:1.3
	OMAP3-0_14:1.3
	OMAP3-0_13:1.3
	OMAP3-0_12:1.3
	OMAP3-0_11:1.3
	OMAP3-0_10:1.3
	OMAP3-0_09:1.3
	OMAP3-0_08:1.3
	OMAP3-0_07:1.2
	OMAP3-0_06:1.2
	OMAP3-0_05:1.2
	OMAP3-0_04:1.2
	OMAP3-0_03:1.2
	OMAP3-0_02:1.2
	OMAP3-0_01:1.1;
locks; strict;
comment	@# @;


1.7
date	2016.05.06.21.36.30;	author jlee;	state Exp;
branches;
next	1.6;
commitid	JTxsHfHHRMZW4t5z;

1.6
date	2012.03.25.11.49.09;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	c99VvmwezV2J8gYv;

1.5
date	2010.09.14.20.58.50;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.30.00.23.20;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.09.19.04.58;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2009.02.21.18.51.47;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.02.01.13.58.05;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Implement HAL_TimerIRQClear
Detail:
  s/Boot, s/Interrupts, s/Timers - Move timer IRQ clear code out of HAL_IRQClear and into HAL_TimerIRQClear. Streamlines HAL_IRQClear and allows timers to be used by FIQ handlers.
Admin:
  Tested on BB-xM


Version 1.09. Tagged as 'OMAP3-1_09'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.omap3530
        GET     hdr.StaticWS
        GET     hdr.Timers
        GET     hdr.PRCM

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  HAL_Timers
        EXPORT  HAL_TimerDevice
        EXPORT  HAL_TimerGranularity
        EXPORT  HAL_TimerMaxPeriod
        EXPORT  HAL_TimerSetPeriod
        EXPORT  HAL_TimerPeriod
        EXPORT  HAL_TimerReadCountdown
        EXPORT  HAL_TimerIRQClear

        EXPORT  HAL_CounterRate
        EXPORT  HAL_CounterPeriod
        EXPORT  HAL_CounterRead
        EXPORT  HAL_CounterDelay

        EXPORT  Timer_Init

        IMPORT  __rt_udiv10

        MACRO
        SetRegBits $r,$bits
        LDR     a3, =$r
        LDR     a4, =$bits
        LDR     a2, [a1, a3]
        ORR     a2, a2, a4
        STR     a2, [a1, a3]
        MEND

Timer_Init
        ; Make sure all the timers are using the 26MHz source, and are actually enabled
        LDR     a1, L4_ClockMan_Log
        ; GPTIMER1
;        SetRegBits CM_CLKSEL_WKUP,&1
;        SetRegBits CM_FCLKEN_WKUP,&1
;        SetRegBits CM_ICLKEN_WKUP,&1
        ; GPTIMER2-8
        SetRegBits CM_CLKSEL_PER,&7F
        SetRegBits CM_FCLKEN_PER,&3F8
        SetRegBits CM_ICLKEN_PER,&3F8
        ; GPTIMER10-11
;        SetRegBits CM_CLKSEL_CORE,&C0
;        SetRegBits CM_FCLKEN1_CORE,&1800
;        SetRegBits CM_ICLKEN1_CORE,&1800
        ; Now reset each timer for good luck
        LDR     a1, Timers_Log
        MOV     a2, #TIMER_MAX
        MOV     a3, #2
Timer_Init_Loop
        STR     a3, [a1,#TIOCP_CFG]
        ; Wait for reset to complete
Timer_Init_ResetLoop
        LDR     a4, [a1,#TISTAT]
        TST     a4, #1
        BEQ     Timer_Init_ResetLoop
        ; Autoidle, smart idle
        MOV     a4, #1+(2<<3)
        STR     a4, [a1,#TIOCP_CFG]
        SUBS    a2, a2, #1
        ADD     a1, a1, #TIMER_STRIDE
        BNE     Timer_Init_Loop
        MOV     pc, lr

        
HAL_Timers
        MOV     a1, #TIMER_MAX
        MOV     pc, lr

HAL_TimerDevice
        CMP     a1, #TIMER_MAX
        MVNHS   a1, #0 ; Error!
        ADDLO   a1, a1, #TIMER_IRQ_BASE
        MOV     pc, lr

HAL_CounterRate
HAL_TimerGranularity
        LDR     a1, sys_clk
        MOV     pc, lr

HAL_TimerMaxPeriod
        MVN     a1, #0 ; 32-bit timers
        MOV     pc, lr

HAL_TimerSetPeriod
        CMP     a1, #TIMER_MAX
        MOVHS   pc, lr
        ; Get pointer to registers
        LDR     a3, Timers_Log
        ADD     a3, a3, a1, LSL #TIMER_STRIDE_POW2
        ; Temporarily stop the timer to avoid unexpected shenanigans
        LDR     a4, [a3, #TCLR]
        BIC     a4, a4, #&7F ; Stop timer and disable all timing modes
        STR     a4, [a3, #TCLR]
        ; If we actually wanted to stop the timer, we can exit now
        CMP     a2, #0
        MOVEQ   pc, lr
        ; Else set up the timer to auto-reload
        CMP     a2, #1 ; OMAP manual warns against writing &FFFFFFFF to the reload register, so limit the timer interrupt frequency to TIMER_FREQUENCY/2
        MOVEQ   a2, #2
        RSB     a2, a2, #0
        STR     a2, [a3, #TLDR] ; Reload value set
        STR     a2, [a3, #TCRR] ; Timer current value set
        MOV     a2, #2
        STR     a2, [a3, #TIER] ; Enable overflow interrupt
        ; Re-enable the timer, in auto-reload mode
        ORR     a4, a4, #3 ; Enable timer and enable autoreload
        STR     a4, [a3, #TCLR]
        MOV     pc, lr

HAL_CounterPeriod
        MOV     a1, #0
        ; Fall through

HAL_TimerPeriod
        CMP     a1, #TIMER_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        LDR     a2, Timers_Log
        ADD     a2, a2, a1, LSL #TIMER_STRIDE_POW2
        LDR     a1, [a2, #TCLR]
        ANDS    a1, a1, #&7F ; =0 if timer is stopped
        LDRNE   a1, [a2, #TLDR] ; if timer running, get reload value and invert to convert back to original input value
        RSBNE   a1, a1, #0
        MOV     pc, lr

HAL_CounterRead
        MOV     a1, #0
        ; Fall through

HAL_TimerReadCountdown
        CMP     a1, #TIMER_MAX
        MOVHS   a1, #0
        LDRLO   a2, Timers_Log
        ADDLO   a2, a2, a1, LSL #TIMER_STRIDE_POW2
        LDRLO   a1, [a2, #TCRR]
        RSBLO   a1, a1, #0
        MOV     pc, lr

; If they want n ticks, wait until we've seen n+1 transitions of the clock.
; This function is limited to delays of around 223.6 seconds. Should be plenty!
HAL_CounterDelay
        LDR     a2, Timer_DelayMul
        MUL     a1, a2, a1 ; Calculate required ticks*10
        MOV     a4, lr
        BL      __rt_udiv10 ; Actual required ticks
        MOV     lr, a4
        LDR     a4, Timers_Log ; Get timer 0
        LDR     a2, [a4, #TCRR]
        RSB     a2, a2, #0 ; Convert to countdown time for ease of reuse of Tungsten code
10
        LDR     a3, [a4, #TCRR]
        RSB     a3, a3, #0
        SUBS    ip, a2, a3              ; ip = difference in ticks
        ADDLO   ip, a2, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        MOVLO   pc, lr
        LDR     a2, [a4, #TCRR]
        RSB     a2, a2, #0
        SUBS    ip, a3, a2              ; ip = difference in ticks
        ADDLO   ip, a3, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        BHS     %BT10
        MOV     pc, lr

HAL_TimerIRQClear
        CMP     a1, #TIMER_MAX
        LDRLO   a2, Timers_Log
        MOVLO   a3, #7 ; Clear all interrupts
        ADDLO   a1, a2, a1, LSL #TIMER_STRIDE_POW2
        STRLO   a3, [a1, #TISR]
        MOV     pc, lr

        END
@


1.6
log
@Line some things up.
To help OMAP4 tracking changes a number of the changes were purely cosmetic lining up differences, this change is where OMAP3 wasn't on a conventional column layout.

Version 0.61. Tagged as 'OMAP3-0_61'
@
text
@d40 1
d195 8
@


1.5
log
@BeagleBoard-xM, TouchBook fixes
Detail:
  s/board, hdr/board, hdr/omap3530, hdr/UART - Add support for 4th UART available on AM/DM37x (i.e. BeagleBoard-xM)
  hdr/omap3530 - Add details of CONTROL_IDCODE register & known hawkeye/revision numbers for OMAP type/revision detection
  s/Boot, s/GPIO, hdr/GPIO, s/I2C, hdr/StaticWS - Allow TPS LED drivers to be used as (output-only) GPIOs. Add new polled I/O I2C function, and appropriate logic to make GPIO code use it instead of RISCOS_IICOpV if RISC OS hasn't finished initialising yet. Add code to initialise some extra BB/TB GPIOs on boot.
  s/Timers, hdr/Timers - Stop RISC OS from using GPTIMER9, because it's used to drive the screen backlight on the TouchBook
  s/Video - Use appropriate porch/sync limits on non-OMAP35x
  s/PRCM - Don't mess with the system clock divider when calculating system clock speed (AM/DM37x fix)
Admin:
  Tested on rev C2 beagleboard, rev A2 BB-xM (indirectly), rev C1 TouchBook


Version 0.32. Tagged as 'OMAP3-0_32'
@
text
@d15 1
@


1.4
log
@Various OMAP3 HAL power management improvements, plus add support for board config autodetection via Linux machine ID
Detail:
  s/board, hdr/board - Add Linux machine ID & available mixer channels to board config table
  s/Top - Add new entry point at offset &64, for booting as a fake Linux kernel. Searches the board config table until it finds a config matching the machine ID passed in R1. Also minor ROM copy optimisation, unsigned pointer comparison fixes
  s/Audio, hdr/Audio - Use board config to lock-out mixer channels that aren't connected to any hardware, to avoid excessive power drain or other problems if the channels get turned on. Also perform many other setting tweaks to tidy up default settings for unused mixer paths/channels.
  s/Video - Fix Video_Init logic when deciding whether to reset DSS, enable DSI PLL drift guard
  s/I2C - Increase I2C timeout values, since the previous values were perhaps a bit low
  s/Audio, s/I2C, s/Interrupts, s/RAM, s/SDMA, s/Timers, s/UART, hdr/UART, s/USB, s/Video - Enable autoidle/smart idle where possible to help save power.
Admin:
  Tested on rev C2 beagleboard


Version 0.21. Tagged as 'OMAP3-0_21'
@
text
@d65 4
a68 4
        ; GPTIMER2-9
        SetRegBits CM_CLKSEL_PER,&FF
        SetRegBits CM_FCLKEN_PER,&7F8
        SetRegBits CM_ICLKEN_PER,&7F8
d94 1
a94 1
        MOV     a1, #TIMER_MAX                  ; 8 timers
@


1.3
log
@OMAP3 HAL USB (EHCI) support, interrupt handling fixes
Detail:
  Makefile - added USB to objects list
  s/Boot, s/USB, hdr/StaticWS, hdr/USB - USB EHCI code
  s/Debug, s/Stubs, s/Timers, s/Top, s/UART, s/Video - Debugging tweaks and header dependency fixes
  s/Interrupts, hdr/omap3530 - Interrupt fixes & debugging code
  hdr/PRCM - typo fix
Admin:
  Tested on rev C2 beagleboard


Version 0.08. Tagged as 'OMAP3-0_08'
@
text
@d84 3
@


1.2
log
@  OMAP3 HAL fixes and updates to allow booting on real hardware.
Detail:
  Makefile - add s.PRCM to objects
  s/Boot - Call PRCM_SetClocks during HAL_Init. Added (disabled) debugging code.
  s/Interrupts - Updated HAL_IRQSource, HAL_FIQSource to query ARM interrupt state instead of relying on INTC alone to detect whether an interrupt is firing or not.
  s/PRCM - Code to measure system clock frequency, store it for HAL purposes, and notify the OMAP of the frequency in order to ensure correct operation.
  s/Timers - Use measured system clock frequency as the timer frequency instead of hard-coded value. Return correct values from HAL_TimerPeriod.
  s/Top - Added (disabled) debugging code. Updated ARM initialisation to use correct cache cleaning procedure.
  s/Video - Further minor work towards completing video driver.
  hdr/CoPro15ops - Deprecate ARM_flush_* macros
  hdr/PRCM - Add more register addresses
  hdr/StaticWS - Add entried for PowerMan & 32K timer logical addresses, system clock speed
  hdr/Timers - remove incorrect, hard-coded timer frequency
  hdr/omap3530 - remove unused FlashCheck global, add DebugChar macro
Admin:
  Tested with HALTester and the RISC OS kernel using qemu-omap3.
  Tested with HALTester on a rev. B6 beagleboard.


Version 0.02. Tagged as 'OMAP3-0_02'
@
text
@d25 1
a27 1
        GET     hdr.omap3530
@


1.1
log
@Basic OMAP3 HAL
Detail:
  Performs startup procedure suitable for any location in ROM or RAM. UART, timer, counter, interrupt & debug functionality implemented. Video support incomplete and nonfunctional.
Admin:
  Tested with HALTester & RISC OS kernel under qemu-omap3


Version 0.01. Tagged as 'OMAP3-0_01'
@
text
@d47 2
d102 1
a102 1
        LDR     a1, =TIMER_FREQUENCY
d142 7
a148 3
        LDRLO   a2, Timers_Log
        ADDLO   a2, a2, a1, LSL #TIMER_STRIDE_POW2
        LDRLO   a1, [a2, #TLDR]
d165 1
d167 5
a171 3
        ASSERT  TIMER_FREQUENCY > 1000000
        LDR     a2, =TIMER_FREQUENCY/1000000
        MUL     a1, a2, a1
@


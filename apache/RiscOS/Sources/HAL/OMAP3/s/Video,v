head	1.31;
access;
symbols
	OMAP3-1_18:1.31
	OMAP3-1_17:1.31
	OMAP3-1_16:1.31
	OMAP3-1_15:1.31
	OMAP3-1_14:1.31
	SMP:1.31.0.2
	SMP_bp:1.31
	OMAP3-1_13:1.31
	OMAP3-1_12:1.31
	OMAP3-1_11:1.31
	OMAP3-1_10:1.31
	OMAP3-1_09:1.31
	OMAP3-1_08:1.31
	OMAP3-1_07:1.31
	OMAP3-1_06:1.31
	OMAP3-1_05:1.31
	OMAP3-1_04:1.31
	OMAP3-1_03:1.31
	OMAP3-1_02:1.31
	OMAP3-1_01:1.31
	OMAP3-1_00:1.31
	OMAP3-0_99:1.30
	OMAP3-0_98:1.30
	OMAP3-0_97:1.30
	OMAP3-0_96:1.29
	OMAP3-0_95:1.29
	OMAP3-0_94:1.28
	OMAP3-0_93:1.27
	OMAP3-0_92:1.27
	OMAP3-0_91:1.26
	OMAP3-0_90:1.26
	OMAP3-0_89:1.25
	OMAP3-0_88:1.25
	OMAP3-0_87:1.24
	OMAP3-0_86:1.24
	OMAP3-0_85:1.24
	OMAP3-0_84:1.24
	OMAP3-0_83:1.23
	OMAP3-0_82:1.23
	OMAP3-0_81:1.23
	OMAP3-0_80:1.23
	OMAP3-0_79:1.23
	OMAP3-0_78:1.22
	OMAP3-0_77:1.22
	OMAP3-0_76:1.22
	OMAP3-0_75:1.22
	OMAP3-0_74:1.22
	OMAP3-0_73:1.21
	OMAP3-0_72:1.21
	OMAP3-0_71:1.21
	OMAP3-0_70:1.21
	OMAP3-0_69:1.21
	OMAP3-0_68:1.20
	OMAP3-0_67:1.20
	OMAP3-0_66:1.20
	OMAP3-0_65:1.20
	OMAP3-0_64:1.20
	OMAP3-0_63:1.19
	OMAP3-0_62:1.19
	OMAP3-0_61:1.19
	OMAP3-0_60:1.19
	OMAP3-0_59:1.19
	OMAP3-0_58:1.18
	OMAP3-0_57:1.18
	OMAP3-0_56:1.18
	OMAP3-0_55:1.18
	OMAP3-0_54:1.18
	OMAP3-0_53:1.18
	OMAP3-0_52:1.18
	OMAP3-0_51:1.18
	OMAP3-0_50:1.18
	OMAP3-0_49:1.18
	OMAP3-0_48:1.18
	OMAP3-0_47:1.18
	OMAP3-0_46:1.18
	OMAP3-0_45:1.18
	OMAP3-0_44:1.18
	OMAP3-0_43:1.18
	OMAP3-0_42:1.18
	OMAP3-0_41:1.18
	OMAP3-0_40:1.18
	OMAP3-0_39:1.18
	OMAP3-0_38:1.18
	OMAP3-0_37:1.18
	OMAP3-0_36:1.18
	OMAP3-0_35:1.18
	OMAP3-0_34:1.18
	OMAP3-0_33:1.17
	OMAP3-0_32:1.17
	OMAP3-0_31:1.16
	OMAP3-0_30:1.16
	OMAP3-0_29:1.16
	OMAP3-0_28:1.16
	OMAP3-0_27:1.15
	OMAP3-0_26:1.15
	OMAP3-0_25:1.15
	OMAP3-0_24:1.15
	OMAP3-0_23:1.14
	OMAP3-0_22:1.13
	OMAP3-0_21:1.13
	OMAP3-0_20:1.12
	OMAP3-0_19:1.12
	OMAP3-0_18:1.11
	OMAP3-0_17:1.10
	OMAP3-0_16:1.9
	OMAP3-0_15:1.8
	OMAP3-0_14:1.8
	OMAP3-0_13:1.8
	OMAP3-0_12:1.8
	OMAP3-0_11:1.8
	OMAP3-0_10:1.8
	OMAP3-0_09:1.7
	OMAP3-0_08:1.6
	OMAP3-0_07:1.5
	OMAP3-0_06:1.5
	OMAP3-0_05:1.4
	OMAP3-0_04:1.4
	OMAP3-0_03:1.3
	OMAP3-0_02:1.2
	OMAP3-0_01:1.1;
locks; strict;
comment	@# @;


1.31
date	2014.12.06.10.43.11;	author rsprowson;	state Exp;
branches;
next	1.30;
commitid	txtXqid4r9I85Y0y;

1.30
date	2014.07.20.14.17.29;	author jlee;	state Exp;
branches;
next	1.29;
commitid	kuWegyKgNNXFJ7Jx;

1.29
date	2014.03.08.16.59.13;	author rsprowson;	state Exp;
branches;
next	1.28;
commitid	CdtiAiQ8vMQbWUrx;

1.28
date	2013.12.17.23.49.46;	author jlee;	state Exp;
branches;
next	1.27;
commitid	xmZ8fZAPbpltOxhx;

1.27
date	2013.12.15.22.41.28;	author jlee;	state Exp;
branches;
next	1.26;
commitid	IxRihA5IJEl1vhhx;

1.26
date	2013.11.01.18.52.57;	author rsprowson;	state Exp;
branches;
next	1.25;
commitid	exT1lzL3WDXiEBbx;

1.25
date	2013.08.17.13.13.54;	author rsprowson;	state Exp;
branches;
next	1.24;
commitid	sIqq7KO5sExsdO1x;

1.24
date	2013.01.13.20.35.10;	author jlee;	state Exp;
branches;
next	1.23;
commitid	ZhVfsWvYtPXiB5Aw;

1.23
date	2012.09.21.15.17.06;	author jlee;	state Exp;
branches;
next	1.22;
commitid	x7ZCrdwZgdjnvplw;

1.22
date	2012.07.18.23.02.44;	author jlee;	state Exp;
branches;
next	1.21;
commitid	gm1WcfapVdjFa6dw;

1.21
date	2012.07.04.17.58.00;	author rsprowson;	state Exp;
branches;
next	1.20;
commitid	XMhv0CBs1aW0Wgbw;

1.20
date	2012.06.04.23.45.11;	author jlee;	state Exp;
branches;
next	1.19;
commitid	m70jrk0mZm9UOr7w;

1.19
date	2012.02.25.16.28.11;	author jlee;	state Exp;
branches;
next	1.18;
commitid	8PdHKiULlWJhCyUv;

1.18
date	2010.10.31.20.03.30;	author jlee;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.14.20.58.50;	author jlee;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.23.22.30.33;	author jlee;	state Exp;
branches;
next	1.15;

1.15
date	2010.03.20.01.07.07;	author jlee;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.28.19.47.14;	author jlee;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.30.00.23.21;	author jlee;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.24.02.49.33;	author jlee;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.16.04.10.25;	author jlee;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.29.19.28.07;	author jlee;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.28.22.30.57;	author jlee;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.13.00.12.50;	author jlee;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.10.18.53.33;	author jlee;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.09.19.04.58;	author jlee;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.22.22.03.40;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.08.22.25.11;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.06.23.35.43;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2009.02.21.18.51.47;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.02.01.13.58.05;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Change over to reassigned bus types

Version 1.00. Tagged as 'OMAP3-1_00'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO
        GET     Hdr:Proc

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.omap3530
        GET     hdr.StaticWS
        GET     hdr.PRCM
        GET     hdr.GPIO
        GET     hdr.Timers
        GET     hdr.SPI

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  Video_Init
        EXPORT  VideoDevice_Init
        EXPORT  Video_Power_VBC_DVI
        EXPORT  Video_Power_VBC_Pandora
        EXPORT  Video_Power_VBC_TouchBook
        EXPORT  Video_SetPandoraGamma

        IMPORT  memcpy
        IMPORT  GPIOx_SetAsOutput
        IMPORT  GPIOx_SetOutput
        IMPORT  HAL_CounterDelay
        IMPORT  TPSWrite

Video_Init
        ; Configure GPIO pins so we can turn the DVI framer on/off
        LDRB    a1, [sb, #BoardConfig_VideoGPIO]
        CMP     a1, #255
        MOV     a2, #0
        BNE     GPIOx_SetAsOutput ; Turn DVI framer off
        MOV     pc, lr

VideoDevice_Init
        ; Not much to do here - just register our HAL device
        Push    "v1,lr"
        ADRL    v1, VideoDevice
        MOV     a1, v1
        ADR     a2, VideoDeviceTemplate
        MOV     a3, #Video_DeviceSize
        BL      memcpy
        LDR     a1, L4_Display_Log
        STR     a1, [v1, #HALDevice_Address]
        ADRL    a3, VideoBoardConfig
        STR     a3, [v1, #HALDevice_VDUDeviceSpecificField]
        STR     sb, [v1, #:INDEX:VideoWorkspace]
        ; Fill in the board config
        LDR     a2, sys_clk
        STR     a2, [a3, #VideoBoardConfig_sys_clk]
        BL      Determine_PorchSync_Limits
        STRH    a1, [a3, #VideoBoardConfig_Max_Porch]
        STRH    a2, [a3, #VideoBoardConfig_Max_Sync]
        LDR     a2, L4_sDMA_Log
        STR     a2, [a3, #VideoBoardConfig_DMA_Ptr]
        MOV     a2, #SDMA_IRQ_1
        STR     a2, [a3, #VideoBoardConfig_DMA_Device]
        ASSERT  SDMA_NumDevices = 31
        MOV     a2, #&80000000
        STR     a2, [a3, #VideoBoardConfig_DMA_Chans]
        LDRB    a2, [sb, #BoardConfig_VBC_Flags]
        STRB    a2, [a3, #VideoBoardConfig_Flags]
        LDRB    a2, [sb, #BoardConfig_VBC_LCDNum]
        STRB    a2, [a3, #VideoBoardConfig_Num_LCDs]
        MOV     a2, #VideoBoardConfig_Size
        STRH    a2, [a3, #VideoBoardConfig_MySize]
        LDR     a2, [sb, #BoardConfig_VBC_LCDPtr]
        STR     a2, [a3, #VideoBoardConfig_LCD_Configs]
        ADR     a2, Video_TVDet_Func
        STR     a2, [a3, #VideoBoardConfig_TVDet_Func]
        ADR     a2, Video_TVPower_Func
        STR     a2, [a3, #VideoBoardConfig_TVPower_Func]
        MOV     a1, #0
        MOV     a2, v1
        CallOS  OS_AddDevice
      [ {FALSE}
        ; Pandora hack - point GFX overlay at the start of physical memory so we can catch any early error messages
        ; This will treat the 8bpp display as 16bpp, so it'll be a bit squashed, but better than nothing
        LDR     a1, L4_Display_Log
        MOV     a2, #&80000000
        STR     a2, [a1, #&480]
        STR     a2, [a1, #&484]
        LDR     a2, =319+(479<<16)
        STR     a2, [a1, #&48c]
        LDR     a2, =&18329
        STR     a2, [a1, #&440]
      ]
        Pull    "v1,pc"

VideoDeviceTemplate
        DCW     HALDeviceType_Video + HALDeviceVideo_VDU
        DCW     HALDeviceID_VDU_OMAP3
        DCD     HALDeviceBus_Sys + HALDeviceSysBus_SonicsMX
        DCD     0               ; API version 0
        DCD     VideoDevice_Desc
        DCD     0               ; Address - filled in later
        %       12              ; Reserved
        DCD     VideoDevice_Activate
        DCD     VideoDevice_Deactivate
        DCD     VideoDevice_Reset
        DCD     VideoDevice_Sleep
        DCD     VIDEO_IRQ ; Device.
        DCD     0               ; TestIRQ cannot be called
        %       8
        DCD     0          ; Pointer to board config stuff - filled in later
        ASSERT (.-VideoDeviceTemplate) = HALDevice_VDU_Size
        DCD     0          ; HAL workspace pointer - filled in later
        ASSERT (.-VideoDeviceTemplate) = Video_DeviceSize        

VideoDevice_Desc
        =       "OMAP3 video controller", 0
        ALIGN

VideoDevice_Activate
        Entry   "sb"
        LDR     sb, VideoWorkspace
        ; Enable DSS power
        ; TODO - should disable interrupts for this bit!
        LDR     a1, L4_ClockMan_Log
        LDR     a2, [a1, #CM_ICLKEN_DSS]
        ORR     a2, a2, #1 ; EN_DSS (correct to enable iclk before fclk?)
        STR     a2, [a1, #CM_ICLKEN_DSS]
        LDR     a2, [a1, #CM_FCLKEN_DSS]
        ORR     a2, a2, #7 ; EN_DSS1, EN_DSS2, EN_TV (required for reset)
        STR     a2, [a1, #CM_FCLKEN_DSS]
        MOV     a1, #1
        EXIT

VideoDevice_Deactivate ; TODO!
VideoDevice_Reset
        MOV     pc, lr

VideoDevice_Sleep
        MOV     a1, #0
        MOV     pc, lr

Video_Power_VBC_DVI
        ; a1 = HAL device
        ; a2 = brightness 0-65536, which we treat as a simple on/off flag
        Entry   "sb"
        LDR     sb, VideoWorkspace
      [ DebugTiming
        CMP     a2, #0
        BEQ     %FT10
        DebugTime a1, "Video on @@ "
10
      ]
        ; Just set the GPIO to the right value
        LDRB    a1, [sb, #BoardConfig_VideoGPIO]
        CMP     a1, #255
        BLNE    GPIOx_SetOutput
        EXIT

Video_Power_VBC_TouchBook
        ; a1 = HAL device
        ; a2 = brightness 0-65536
        Entry   "sb"
        LDR     sb, VideoWorkspace
        ; TODO - Proper brightness controls
        ; For now, just toggle on/off, via the SCPWM bit of GPTIMER9.TCLR
        LDR     a3, Timers_Log
        ADD     a3, a3, #L4_GPTIMER9-TIMER_BASE
        CMP     a2, #0
        LDR     a4, [a3, #TCLR]
        BICEQ   a4, a4, #&80
        ORRNE   a4, a4, #&80
        STR     a4, [a3, #TCLR]
        ; Also toggle the GPIO that controls the DVI framer
        LDRB    a1, [sb, #BoardConfig_VideoGPIO]
        CMP     a1, #255
        BLNE    GPIOx_SetOutput
        EXIT

Video_Power_VBC_Pandora ROUT
        ; a1 = HAL device
        ; a2 = brightness 0-65536
        Entry   "a2,v4,sb"
        LDR     sb, VideoWorkspace
        ; TODO - Proper brightness controls, and proper LCD power control.
        ; To turn the power on/off properly it looks like it needs to be done over several frames, which would ideally require some changes to OMAPVideo to ensure we're called from the foreground and aren't re-entered.
        ; For now we'll just put the LCD in/out of standby, via the SPI interface
        TEQ     a2, #0
        MOVEQ   a4, #&d8
        MOVNE   a4, #&df
        LDR     a2, L4_Core_Log
        ADD     a2, a2, #L4_McSPI1-L4_Core
        ADD     a2, a2, #MCSPI_STRIDE
        LDR     v4, =(7<<2)+(1<<6)+(15<<7)+(2<<12)+(1<<16)
        MOV     a3, #3
        BL      td043_write
        ; The datasheet says we should wait 9 frames before cutting the sync
        ; signals, but OMAPVideo will cut them right away. Luckily it looks like
        ; we can get by with waiting just one frame.
        LDR     a2, [sp]
        TEQ     a2, #0
        LDREQ   a1, =17000
        BLEQ    HAL_CounterDelay
        EXIT

Determine_PorchSync_Limits
        ; Returns:
        ; a1 = max porch value
        ; a2 = max sync value
        ; Get the OMAP revision so we can find out how large the timing registers are. OMAP35x errata shows that in ES 3.1+ the registers were increased from 8/6 bits to 12/8 bits.
        LDR     a2, L4_Wakeup_Log
        ADD     a2, a2, #(L4_CONTROL_IDCODE-L4_Wakeup) :AND: &FF00
        LDR     a2, [a2, #(L4_CONTROL_IDCODE-L4_Wakeup) :AND: &00FF]
        ; Check revision first
        CMP     a2, #REVISION_ES31 :SHL: 28
        MOVHS   a1, #1:SHL:12
        MOVHS   a2, #1:SHL:8
        MOVHS   pc, lr
        ; Revision check failed - check if this is OMAP35x
        ; If not, assume it's something newer which supports the larger timings
        LDR     a1, =HAWKEYE_OMAP35x_ES10
        MOV     a2, a2, LSL #4
        CMP     a1, a2, LSR #16
        LDRNE   a1, =HAWKEYE_OMAP35x
        CMPNE   a1, a2, LSR #16
        MOVNE   a1, #1:SHL:12
        MOVNE   a2, #1:SHL:8
        MOVEQ   a1, #1:SHL:8
        MOVEQ   a2, #1:SHL:6
        MOV     pc, lr

Video_TVDet_Func
        Entry   "sb"
        LDR     sb, VideoWorkspace
        ; The TV detect signal is internally hardwired to GPIO 33
        GPIO_PrepareC a1, a2, 33
        GPIO_GetInput a1, a1, a2
        EXIT

Video_TVPower_Func
        Entry   "v1-v2,sb", 4
        LDR     sb, VideoWorkspace
        LDR     v1, OSentries+4*OS_IICOpV
        MOVS    ip, a2
        MOV     a3, #1
        MOV     a2, sp
        BEQ     %FT50
        ; Configure VDAC for 1.8V output
        MOV     a1, #&4b*2
        MOV     ip, #3
        MOV     a4, #&99 ; VDAC_DEDICATED
        STR     ip, [a2]
        BL      TPSWrite
        ; Enable it
        MOV     ip, #&20
50      ; Arrive here with ip=0 when disabling
        MOV     a1, #&4b*2
        MOV     a4, #&96 ; VDAC_DEV_GRP
        STR     ip, [a2]
        BL      TPSWrite
        EXIT

Video_SetPandoraGamma ROUT
        Entry   "v1-v4"
        ADR     a1, PandoraGamma
        ; Reset McSPI1 and configure channel 1
        LDR     a2, L4_Core_Log
        ADD     a2, a2, #L4_McSPI1-L4_Core
        MOV     a3, #2
        STR     a3, [a2, #MCSPI_SYSCONFIG]
10
        LDR     a3, [a2, #MCSPI_SYSSTATUS]
        TST     a3, #1
        BEQ     %BT10
        MOV     a3, #1
        STR     a3, [a2, #MCSPI_MODULCTRL]
        LDR     v4, =(7<<2)+(1<<6)+(15<<7)+(2<<12)+(1<<16)
        ADD     a2, a2, #MCSPI_STRIDE
        STR     v4, [a2, #MCSPI_CHxCONF]
        ; Configure display
        MOV     a3, #2
        MOV     a4, #&f
        BL      td043_write
        MOV     a3, #3
        MOV     a4, #&df
        BL      td043_write
        MOV     a3, #&20
        MOV     a4, #&f0
        BL      td043_write
        MOV     a3, #&21
        MOV     a4, #&f0
        BL      td043_write
        ; Process gamma table
        ; Bits 9-8 of table entries
        MOV     v1, #2
20
        MOV     a4, #0
        MOV     v2, #3
30
        ADD     v3, v2, v1, LSL #2
        ADD     v3, a1, v3, LSL #1
        ADD     ip, v2, #1
        LDRH    v3, [v3]
        MOV     ip, ip, LSL #1
        AND     v3, v3, #&300
        ORR     a4, a4, v3, LSR ip
        SUBS    v2, v2, #1
        BGE     %BT30
        ADD     a3, v1, #&11
        BL      td043_write
        SUBS    v1, v1, #1
        BGE     %BT20
        ; bits 7-0
        MOV     v1, #0
40
        LDRH    a4, [a1], #2
        ADD     a3, v1, #&14
        AND     a4, a4, #255
        BL      td043_write
        ADD     v1, v1, #1
        CMP     v1, #12
        BLT     %BT40
        ; Done
        EXIT

td043_write     ROUT
        Entry   "a1-a2"
        ; In:
        ;  a2 = SPI register block
        ;  a3 = register
        ;  a4 = data
        ;  v4 = channel config
        ; Out:
        ;  a3-a4 corrupt
        ; Construct 16 bit SPI data word
        ORR     a3, a4, a3, LSL #10
        ORR     a3, a3, #1<<8
        ; Set force flag
        ORR     a4, v4, #1<<20
        STR     a4, [a2, #MCSPI_CHxCONF]
        ; Enable channel
        MOV     a4, #1
        STR     a4, [a2, #MCSPI_CHxCTRL]
        ; Write data
        STR     a3, [a2, #MCSPI_TXx]
        ; Wait for transmission
10
        LDR     a4, [a2, #MCSPI_CHxSTAT]
        AND     a4, a4, #6
        TEQ     a4, #6
        BNE     %BT10
        ; Disable channel
        MOV     a4, #0
        STR     a4, [a2, #MCSPI_CHxCTRL]
        ; Clear force flag
        STR     v4, [a2, #MCSPI_CHxCONF]
        ; TD043 datasheet says a minimum 1ns period is needed between transfers
        ; Chances are that amount of time has already passed, but play it safe
        ; and wait for 1us
        MOV     a1, #1
        BL      HAL_CounterDelay
        EXIT

        ; Default gamma table used by Linux
PandoraGamma
        DCW 105
        DCW 315
        DCW 381
        DCW 431
        DCW 490
        DCW 537
        DCW 579
        DCW 686
        DCW 780
        DCW 837
        DCW 880
        DCW 1023

        END

@


1.30
log
@Disallow EDID writes. Add support for EDID reads which require the segment pointer to be set. Improve Pandora screen blanking.
Detail:
  s/I2C - Revise HAL_VideoIICOp implementation to disallow EDID writes (&A0 IIC address). Attempt to write the EDID segment pointer when accessing EDID addresses >= 256.
  s/Video - Make Pandora screen blanking put the LCD into/out of standby mode. If it's left active while the video sync signals are cut then there'll often be garbage displayed on the screen.
Admin:
  Tested on BB-xM, Pandora


Version 0.97. Tagged as 'OMAP3-0_97'
@
text
@d115 1
a115 1
        DCD     HALDeviceBus_Interconnect + HALDeviceInterconnectBus_L3
@


1.29
log
@Use DSB/ISB directly
Reflects similar change in OMAP4-0_28.
Built, but not tested.

Version 0.95. Tagged as 'OMAP3-0_95'
@
text
@a158 1
Video_Power_VBC_Pandora
d195 27
a221 1
        
@


1.28
log
@Re-enable Pandora TV-out support
Detail:
  s/board - Re-enable Pandora TV-out support now that we have the ability to turn TV-out power on/off
  hdr/board, s/Video - Add the new TV-out power control function to the video board config struct. All OMAP boards should be able to use the same implementation, which enables/disables the VDAC power supply in the TPS
Admin:
  Tested on BB-xM and Pandora
  TV detection (and TV-out in general) now works properly on the Pandora


Version 0.94. Tagged as 'OMAP3-0_94'
@
text
@a30 1
        GET     hdr.CoPro15ops
@


1.27
log
@Remove obsolete stub HAL video API implementation
Detail:
  hdr/Video, s/Top - Remove local VIDC list type 3 definition, use Hdr:VIDCList instead
  s/Boot, s/Video - Removed obsolete HAL video API implementation. A stub implementation is no longer required for systems that have a GraphicsV driver in a module, and can even cause problems if the OS decides to use the HAL implementation instead of the module one.
Admin:
  Tested in OMAP3 ROM on BB-xM
  Requires Kernel-5_35-4_79_2_203


Version 0.92. Tagged as 'OMAP3-0_92'
@
text
@d48 1
d94 2
d232 23
@


1.26
log
@Refactor IIC calls to use RISCOS_IICOpV
- Comments and symbolic names for RTC register bits copied over from OMAP4 sources.
- Delete dead function ReadTimeForNVRAM.
- Use RTCFormatFlags_BCD_NeedsYearHelp flag for year 2070 compatibility.
- Moved CallOS macro into a header.
Tested on a Beagleboard xM, clock still worked over a power cycle.

Version 0.90. Tagged as 'OMAP3-0_90'
@
text
@a36 16
        EXPORT  HAL_VideoFlybackDevice
        EXPORT  HAL_VideoSetMode
        EXPORT  HAL_VideoWritePaletteEntry
        EXPORT  HAL_VideoWritePaletteEntries
        EXPORT  HAL_VideoReadPaletteEntry
        EXPORT  HAL_VideoSetInterlace
        EXPORT  HAL_VideoSetBlank
        EXPORT  HAL_VideoSetPowerSave
        EXPORT  HAL_VideoUpdatePointer
        EXPORT  HAL_VideoSetDAG
        EXPORT  HAL_VideoVetMode
        EXPORT  HAL_VideoPixelFormats
        EXPORT  HAL_VideoFeatures
        EXPORT  HAL_VideoBufferAlignment
        EXPORT  HAL_VideoOutputFormat

a56 32
; Stubs for unused HAL functions

HAL_VideoOutputFormat
HAL_VideoVetMode
        MOV     r0, #0
HAL_VideoSetMode
HAL_VideoWritePaletteEntry
HAL_VideoWritePaletteEntries
HAL_VideoSetInterlace
HAL_VideoSetBlank
HAL_VideoSetPowerSave
HAL_VideoUpdatePointer
HAL_VideoSetDAG
HAL_VideoReadPaletteEntry
        MOV     pc, lr

HAL_VideoFlybackDevice
        MOV     a1, #-1
        MOV     pc, lr

HAL_VideoPixelFormats
        MOV     a1, #2_111111
        MOV     pc, lr

HAL_VideoFeatures
        MOV     a1, #2_10010            ; hw pointer, no VSyncs
        MOV     pc, lr

HAL_VideoBufferAlignment
        MOV     a1, #4
        MOV     pc, lr

@


1.25
log
@Probe earlier, declare device later
Revision 0.87 moved the NVMemory probe too late for the kernel, which fell back to using its default table.
Fixes problem of apparently lost configuration
  http://www.riscosopen.org/forum/forums/4/topics/2063
Video_Init capitalised like the other initialisation functions.

Version 0.88. Tagged as 'OMAP3-0_88'
@
text
@a64 7
        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND

@


1.24
log
@Program the gamma table in the Pandora's LCD
Detail:
  s/Video - Added code to program the gamma table in the Pandora's LCD, as the power-on settings aren't very good
  s/Boot - Initialise the LCD at the right time
  hdr/SPI - SPI register definitions, for programming the gamma table and (eventually) a full SPI driver
Admin:
  Tested on Pandora


Version 0.84. Tagged as 'OMAP3-0_84'
@
text
@a36 1
        EXPORT  Video_init
d53 1
d72 1
a72 1
Video_init
@


1.23
log
@Tidy up board-specific code. Improve Pandora support.
Detail:
  hdr/board, s/board, s/Boot - Tidied up board-specific code a bit by adding more board-specific function pointers to the BoardConfig struct instead of relying on manual board detection in code.
  s/board - Disable Pandora VideoGPIO as turning the LCD on & off seems to result in graphical corruption, most likely due to settings which were set by the SPI interface being lost.
  s/KbdMatrix, Makefile - New file for handling the Pandora's keyboard matrix (and anything else that may require keyboard matrix code in the HAL). Contains stub code for the boot-time keyboard scan, and code to register a keyboard HAL device for detection by the PandoraKey module.
  s/Boot - Add soft-off support for Pandora. Add Pandora-specific initialisation code to enable some extra power supplies (touchscreen, nubs, audio DAC, EHCI PHY)
  s/KbdScan - Use Pandora-specific keyboard scan code instead of USB code when running on Pandora
  s/SDIO - Correct sense of MMC activity LEDs on Pandora. Now only lit during periods of activity, to match behaviour of the Pandora Linux distro.
  s/Video - Add some switched out hack code to allow easier debugging of aborts that occur during ROM initialisation
Admin:
  Tested on Pandora, rev C2 BB, rev A2 BB-xM, rev C1 TouchBook


Version 0.79. Tagged as 'OMAP3-0_79'
@
text
@d33 1
d58 1
d63 1
d284 116
@


1.22
log
@Add support for TV detection
Detail:
  hdr/board, s/Video - Video device now implements the tvdet_func function for polling the TV detect GPIO
Admin:
  Tested on BB-xM with high processor vectors


Version 0.74. Tagged as 'OMAP3-0_74'
@
text
@d148 12
@


1.21
log
@Refactor HAL_VideoIICOp to be ATPCS
No longer specified to return _kernel_oserror * implements GraphicsV 14.
Make use of IICStatus defines instead of local copies.
Rename HAL_Video_ to HAL_Video.
Tested on Beagleboard xM, reading EDID from Hyundai monitor.

Version 0.69. Tagged as 'OMAP3-0_69'
@
text
@d139 2
d143 2
d261 8
@


1.20
log
@Add HAL_UARTDefault implementation. Delete old HAL video code. Add some SmartReflex tweaks.
Detail:
  hdr/board, s/board, s/Boot, s/UART - Added HAL_UARTDefault implementation, to allow OS_SerialOp to be used
  hdr/StaticWS, hdr/omap3530, s/Boot, s/Interrupts, s/Video - Removed old HAL video code. The OMAPVideo module is a much better video driver.
  s/SR37x - Add some SmartReflex tweaks which we can try if we run into any stability issues with the current code.
Admin:
  Tested on rev A2 BB-xM


Version 0.64. Tagged as 'OMAP3-0_64'
@
text
@d38 14
a51 14
        EXPORT  HAL_Video_SetMode
        EXPORT  HAL_Video_WritePaletteEntry
        EXPORT  HAL_Video_WritePaletteEntries
        EXPORT  HAL_Video_ReadPaletteEntry
        EXPORT  HAL_Video_SetInterlace
        EXPORT  HAL_Video_SetBlank
        EXPORT  HAL_Video_SetPowerSave
        EXPORT  HAL_Video_UpdatePointer
        EXPORT  HAL_Video_SetDAG
        EXPORT  HAL_Video_VetMode
        EXPORT  HAL_Video_PixelFormats
        EXPORT  HAL_Video_Features
        EXPORT  HAL_Video_BufferAlignment
        EXPORT  HAL_Video_OutputFormat
d79 2
a80 2
HAL_Video_OutputFormat
HAL_Video_VetMode
d82 9
a90 9
HAL_Video_SetMode
HAL_Video_WritePaletteEntry
HAL_Video_WritePaletteEntries
HAL_Video_SetInterlace
HAL_Video_SetBlank
HAL_Video_SetPowerSave
HAL_Video_UpdatePointer
HAL_Video_SetDAG
HAL_Video_ReadPaletteEntry
d97 1
a97 1
HAL_Video_PixelFormats
d101 1
a101 1
HAL_Video_Features
d105 1
a105 1
HAL_Video_BufferAlignment
@


1.19
log
@Add compressed ROM support. Add boot timing code. Other misc tweaks.
Detail:
  hdr/omap3530, s/Boot, s/KbdScan, s/Top, s/Video - Added code for profiling/timing the startup sequence, using the 32K system timer
  s/Boot - Ensure VAUX2 is enabled during EVM startup
  s/Boot, s/CPUClk - Go to full CPU speed during HAL_Init instead of HAL_InitDevices.
  s/KbdScan - Print out heap usage stats when debugging is enabled
  s/NVMemory - Skip probing for CMOS carrier board if JTAG is active
  s/RAM, s/Top - Use DMA to relocate the ROM image instead of simple memcpy code. Relocate compressed ROMs to a location suitable for decompression.
Admin:
  Tested with compressed & uncompressed OMAP3/OMAP3Live images


Version 0.59. Tagged as 'OMAP3-0_59'
@
text
@d53 4
a56 6
 [ :LNOT: HALDoesVideo
        EXPORT   VideoDevice_Init
        EXPORT   Video_Power_VBC_DVI
        EXPORT   Video_Power_VBC_Pandora
        EXPORT   Video_Power_VBC_TouchBook
 ]
a57 7
        IMPORT  vtophys
        IMPORT  |__rt_udiv|
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
        IMPORT  PRCM_GetFreqSel
        IMPORT  HAL_CounterDelay
        IMPORT  DebugMemDump
a68 1507
; A brief rundown of OMAP3530 video output modes:
; RFBI - Parallel interface using MIPI DBI protocol. Supports two RFBI-compliant LCD panels
; RFBI bypass - Parallel interface using MIPI DPI protocol
; SDI - Serial interface for TI FlatLink 3G panels (and for those alone?)
; DSI - Serial interface for other types of LCD panel. Supports multiple panels via mix of video & command modes.
; TV out - Supports composite & S-Video, PAL & NTSC

; Currently this code only supports the RFBI bypass mode, as used to interface with the TFP410 DVI framer used on the beagleboard. Luckily this is also the simplest interface of the lot.

; A note on pixel clock sources:
; There are two pixel clock sources - one from DPLL4 in the PRCM, and the DSI PLL. DPLL4 provides the source for multiple clocks, so changing its frequency at runtime would cause many problems. So we use the DSI PLL instead, as its clock output only affects the pixel clock in the display controller (which we do use) and the DSI protocol engine (which we don't use for RFBI bypass mode)

 [ HALDoesVideo
DSI_BPP     *   24 ; BPP of the data sent out by DSI
DSI_LANES   *   3  ; Number of data lanes used by DSI
 ]
 
; TFP410 power is controlled via GPIO 170
;TFP410_GPIO * 170 -> gone to board config

; Max pixel rate:
; - DSI1_PLL_FCLK is limited to 173MHz (spruf98b p2113). Combine with minimum LCD & PCD values and you get a max pixel rate of 86.5MHz (173/2)
; - However spruf98b p2008 says the max pixel rate is 75MHz
; - Beagleboard ref. manual says 65MHz (but TFP410 datasheet says 165MHz?)

; For the moment, limit the pixel rate to 75MHz. This could probably be increased to 86.5 if some of the FIFO fixes were brought over from the OMAPVideo module.
 [ HALDoesVideo
MAX_PIXEL_RATE * 75000
 ] 

; Clock flow:
; sys_clk -> DSS2_ALWON_FCLK -> DSI PLL -> DSI1_PLL_FCLK, DSI2_PLL_FCLK (173MHz max)
; DSI1_PLL_FCLK -> DISPC_FCLK -> LCD -> PCD (75MHz max)
; DSI2_PLL_FCLK -> DSI_FCLK. Must be > byte clock(?), L4 interface clock, video port clock. But we don't care for RFBI bypass.
; -----------------------------------------------------------------------------------

 [ HALDoesVideo

        MACRO
        SetRegBits $r,$bits
        LDR     a2, [a1, #$r]
        ORR     a2, a2, #$bits
        STR     a2, [a1, #$r]
        MEND

        MACRO
        DumpReg $r
        DebugTX "$r"
        LDR     a1, =$r
        LDR     a1, [a3, a1]
        DebugReg a1
        MEND

                GBLL    VideoDebug
VideoDebug      SETL    {TRUE}

                GBLL    ExtraVideoDebug
ExtraVideoDebug SETL    {FALSE}

                GBLL    VetModeDebug
VetModeDebug    SETL    {FALSE}

                ; Set to TRUE to disable all changes to video output settings
                GBLL    PassiveVideo
PassiveVideo    SETL    {FALSE}

        MACRO
        SetGoBits $base,$temp,$temp2,$str
;        MOV     $temp2, #1024*1024 ; How long is typical wait time? Do we need to wait for vsync or what?
;5
;        LDR     $temp, [$base, #DISPC_CONTROL]
;        TST     $temp, #&1:SHL:5 ; Only test GOLCD, since EVSYNC doesn't happen often enough on beagleboard?
;        BEQ     %FT10
;        SUBS    $temp2, $temp2, #1
;        BNE     %BT5
; [ VideoDebug
;        Push "lr" ; Just in case
;        DebugTX $str
;        DebugReg $temp
;        Pull "lr"
; ]
;10
;        ORR     $temp, $temp, #&3:SHL:5
;        STR     $temp, [$base, #DISPC_CONTROL]
        ; New SetGoBits: Rather than blocking on the update and clashing with UpdatePointer, we just set a flag which UpdatePointer will monitor
        ; Only downside is that if interrupts are disabled for a long time, nothing will happen. But long stretches without interrupts is generally a bad thing anyway.
        MOV     $temp, #3:SHL:5
        STR     $temp, video_gobits
        MEND


 [ ExtraVideoDebug
        LTORG

DumpDispcRegs
      Push    "a1-a3,lr"
      LDR     a3, L4_Display_Log
      DumpReg DSS_SYSCONFIG
      DumpReg DSS_SYSSTATUS
      DumpReg DSS_IRQSTATUS
      DumpReg DSS_CONTROL           
      DumpReg DSS_SDI_CONTROL       
      DumpReg DSS_PLL_CONTROL       
      DumpReg DSS_SDI_STATUS        
      DumpReg DISPC_SYSCONFIG               
      DumpReg DISPC_SYSTATUS                
      DumpReg DISPC_IRQSTATUS               
      DumpReg DISPC_IRQENABLE               
      DumpReg DISPC_CONTROL                 
      DumpReg DISPC_CONFIG                  
      DumpReg DISPC_DEFAULT_COLOR0          
      DumpReg DISPC_DEFAULT_COLOR1          
      DumpReg DISPC_TRANS_COLOR0            
      DumpReg DISPC_TRANS_COLOR1            
      DumpReg DISPC_LINE_STATUS             
      DumpReg DISPC_LINE_NUMBER             
      DumpReg DISPC_TIMING_H                
      DumpReg DISPC_TIMING_V                
      DumpReg DISPC_POL_FREQ                
      DumpReg DISPC_DIVISOR                 
      DumpReg DISPC_GLOBAL_ALPHA            
      DumpReg DISPC_SIZE_DIG                
      DumpReg DISPC_SIZE_LCD                
      DumpReg DISPC_GFX_BA0                 
      DumpReg DISPC_GFX_BA1                 
      DumpReg DISPC_GFX_POSITION            
      DumpReg DISPC_GFX_SIZE                
      DumpReg DISPC_GFX_ATTRIBUTES          
      DumpReg DISPC_GFX_FIFO_THRESHOLD      
      DumpReg DISPC_GFX_FIFO_SIZE_STATUS    
      DumpReg DISPC_GFX_ROW_INC             
      DumpReg DISPC_GFX_PIXEL_INC           
      DumpReg DISPC_GFX_WINDOW_SKIP         
      DumpReg DISPC_GFX_TABLE_BA
      DumpReg DISPC_VID1+DISPC_VIDn_BA0                
      DumpReg DISPC_VID1+DISPC_VIDn_BA1                
      DumpReg DISPC_VID1+DISPC_VIDn_POSITION           
      DumpReg DISPC_VID1+DISPC_VIDn_SIZE               
      DumpReg DISPC_VID1+DISPC_VIDn_ATTRIBUTES         
      DumpReg DISPC_VID1+DISPC_VIDn_FIFO_THRESHOLD     
      DumpReg DISPC_VID1+DISPC_VIDn_FIFO_SIZE_STATUS   
      DumpReg DISPC_VID1+DISPC_VIDn_ROW_INC            
      DumpReg DISPC_VID1+DISPC_VIDn_PIXEL_INC          
      DumpReg DISPC_VID1+DISPC_VIDn_FIR                
      DumpReg DISPC_VID1+DISPC_VIDn_PICTURE_SIZE       
      DumpReg DISPC_VID1+DISPC_VIDn_ACCU0              
      DumpReg DISPC_VID1+DISPC_VIDn_ACCU1              
      DumpReg DISPC_VID1+DISPC_VIDn_FIR_COEF_H0        
      DumpReg DISPC_VID1+DISPC_VIDn_FIR_COEF_HV0       
      DumpReg DISPC_VID1+DISPC_VIDn_FIR_COEF_H1        
      DumpReg DISPC_VID1+DISPC_VIDn_FIR_COEF_HV1       
      DumpReg DISPC_VID1+DISPC_VIDn_FIR_COEF_H2        
      DumpReg DISPC_VID1+DISPC_VIDn_FIR_COEF_HV2       
      DumpReg DISPC_VID1+DISPC_VIDn_FIR_COEF_H3        
      DumpReg DISPC_VID1+DISPC_VIDn_FIR_COEF_HV3       
      DumpReg DISPC_VID1+DISPC_VIDn_CONV_COEF0         
      DumpReg DISPC_VID1+DISPC_VIDn_CONV_COEF1         
      DumpReg DISPC_VID1+DISPC_VIDn_CONV_COEF2         
      DumpReg DISPC_VID1+DISPC_VIDn_CONV_COEF3         
      DumpReg DISPC_VID1+DISPC_VIDn_CONV_COEF4
      B %FT10
      LTORG
10
      DumpReg DISPC_VID2+DISPC_VIDn_BA0                
      DumpReg DISPC_VID2+DISPC_VIDn_BA1                
      DumpReg DISPC_VID2+DISPC_VIDn_POSITION           
      DumpReg DISPC_VID2+DISPC_VIDn_SIZE               
      DumpReg DISPC_VID2+DISPC_VIDn_ATTRIBUTES         
      DumpReg DISPC_VID2+DISPC_VIDn_FIFO_THRESHOLD     
      DumpReg DISPC_VID2+DISPC_VIDn_FIFO_SIZE_STATUS   
      DumpReg DISPC_VID2+DISPC_VIDn_ROW_INC            
      DumpReg DISPC_VID2+DISPC_VIDn_PIXEL_INC          
      DumpReg DISPC_VID2+DISPC_VIDn_FIR                
      DumpReg DISPC_VID2+DISPC_VIDn_PICTURE_SIZE       
      DumpReg DISPC_VID2+DISPC_VIDn_ACCU0              
      DumpReg DISPC_VID2+DISPC_VIDn_ACCU1              
      DumpReg DISPC_VID2+DISPC_VIDn_FIR_COEF_H0        
      DumpReg DISPC_VID2+DISPC_VIDn_FIR_COEF_HV0       
      DumpReg DISPC_VID2+DISPC_VIDn_FIR_COEF_H1        
      DumpReg DISPC_VID2+DISPC_VIDn_FIR_COEF_HV1       
      DumpReg DISPC_VID2+DISPC_VIDn_FIR_COEF_H2        
      DumpReg DISPC_VID2+DISPC_VIDn_FIR_COEF_HV2       
      DumpReg DISPC_VID2+DISPC_VIDn_FIR_COEF_H3        
      DumpReg DISPC_VID2+DISPC_VIDn_FIR_COEF_HV3       
      DumpReg DISPC_VID2+DISPC_VIDn_CONV_COEF0         
      DumpReg DISPC_VID2+DISPC_VIDn_CONV_COEF1         
      DumpReg DISPC_VID2+DISPC_VIDn_CONV_COEF2         
      DumpReg DISPC_VID2+DISPC_VIDn_CONV_COEF3         
      DumpReg DISPC_VID2+DISPC_VIDn_CONV_COEF4         
      DumpReg DISPC_DATA_CYCLE0            
      DumpReg DISPC_VID0_FIR_COEF_V
      DumpReg DISPC_VID1_FIR_COEF_V        
      DumpReg DISPC_CPR_COEF_R             
      DumpReg DISPC_CPR_COEF_G             
      DumpReg DISPC_CPR_COEF_B             
      DumpReg DISPC_GFX_PRELOAD            
      DumpReg DISPC_VID0_PRELOAD           
      DumpReg DISPC_VID1_PRELOAD
      Pull    "a1-a3,pc"

      LTORG
 ]

Video_init
        Push    "v1,lr"
 [ :LNOT: PassiveVideo
        ; omap_dss_probe()
        ; - dss_clk_enable_all_no_ctx()
        LDR     a1, L4_ClockMan_Log
        LDR     a2, [a1, #CM_ICLKEN_DSS]
        ORR     a2, a2, #1 ; EN_DSS (correct to enable iclk before fclk?)
        STR     a2, [a1, #CM_ICLKEN_DSS]
        LDR     a2, [a1, #CM_FCLKEN_DSS]
        ORR     a2, a2, #7 ; EN_DSS1, EN_DSS2, EN_TV (required for reset)
        STR     a2, [a1, #CM_FCLKEN_DSS]
 [ ExtraVideoDebug
        DebugTX "Original regs"
        BL DumpDispcRegs
 ]
        ; - dss_init()
        LDR     v1, L4_Display_Log
        LDR     a2, [v1, #DISPC_CONTROL]
        TST     a2, #1 ; LCD already enabled?
        BNE     %FT10 ; Skip init
        ; Apparently, bad things happen if you reset the DSS immediately after enabling the clocks
        DebugTX "Performing DSS reset"
        MOV     a1, #50*1024 ; 50msec ish
        BL      HAL_CounterDelay ; Wait (timer should already running)
        ; -- omap_dss_reset()
        LDR     a1, [v1, #DSS_SYSCONFIG]
        ORR     a1, a1, #2 ; SOFTRESET
        STR     a1, [v1, #DSS_SYSCONFIG]
        ; Wait for completion
5
        LDR     a1, [v1, #DSS_SYSSTATUS]
        TST     a1, #1
        BEQ     %BT5
10
        DebugTX "DSS init"
        ; Enable autoidle mode
        LDR     a1, [v1, #DSS_SYSCONFIG]
        ORR     a1, a1, #1
        STR     a1, [v1, #DSS_SYSCONFIG]
        ; Select DSS1_ALWON_FCLK as DISPC fclk
        LDR     a1, [v1, #DSS_CONTROL]
        BIC     a1, a1, #1
        STR     a1, [v1, #DSS_CONTROL]
        ; - dpi_init()
        ;   (nothing)
        ; - dispc_init()
        ; -- _omap_dispc_initial_config()
        LDR     a1, =&2015 ; AUTOIDLE, ENWAKEUP, SIDLEMODE=2, MIDLEMODE=2 (smart idle modes)
        STR     a1, [v1, #DISPC_SYSCONFIG]
        LDR     a1, [v1, #DISPC_CONFIG]
        ORR     a1, a1, #1:SHL:9 ; Gate functional clocks
        STR     a1, [v1, #DISPC_CONFIG]
        ; - dss_init_displays()
        ; -- dpi_init_display()
        ;    (nothing)
        ; - dss_init_overlay_managers()
        ;   (nothing)
        ; - dss_init_overlays()
        ;   (nothing)
        ; Other old bits:
        ; Configure GPIO pins so we can turn the DVI framer on/off
        LDRB    a1, [sb, #BoardConfig_VideoGPIO]
        CMP     a1, #255
        MOV     a2, #0
        BLNE    GPIOx_SetAsOutput ; Turn DVI framer off
 |
 [ ExtraVideoDebug
        DebugTX "Original regs"
        BL DumpDispcRegs
 ]
        LDR     v1, L4_Display_Log
 ] ; PassiveVideo
        ; Configure FIFO thresholds. these don't match u-boot, but they do match some linux code, so I'll stick with this for now.
        LDR     a3, [v1, #DISPC_GFX_FIFO_SIZE_STATUS]
        MOV     a2, a3, LSR #2 ; low threshold = 1/4 size
        SUB     a3, a3, a2 ; High threshold = 3/4 size
        ORR     a3, a2, a3, LSL #16
        STR     a3, [v1, #DISPC_GFX_FIFO_THRESHOLD]
        ADD     a4, v1, #DISPC_VID1:AND:&FF
        ADD     a4, a4, #DISPC_VID1:AND:&FF00
        LDR     a3, [a4, #DISPC_VIDn_FIFO_SIZE_STATUS]
        MOV     a2, a3, LSR #2 ; low threshold = 1/4 size
        SUB     a3, a3, a2 ; High threshold = 3/4 size
        ORR     a3, a2, a3, LSL #16
        STR     a3, [a4, #DISPC_VIDn_FIFO_THRESHOLD]
        ADD     a4, v1, #DISPC_VID2:AND:&FF
        ADD     a4, a4, #DISPC_VID2:AND:&FF00
        LDR     a3, [a4, #DISPC_VIDn_FIFO_SIZE_STATUS]
        MOV     a2, a3, LSR #2 ; low threshold = 1/4 size
        SUB     a3, a3, a2 ; High threshold = 3/4 size
        ORR     a3, a2, a3, LSL #16
        STR     a3, [a4, #DISPC_VIDn_FIFO_THRESHOLD]
        ; Allocate palette space
        LDR     a1, NCNBAllocNext
        STR     a1, video_palette
        ADD     a1, a1, #4*256
        ; Allocate hardware cursor space
        STR     a1, cursor_image
        ADD     a1, a1, #HW_CURSOR_WIDTH*HW_CURSOR_HEIGHT*4
        STR     a1, NCNBAllocNext
        MOV     a1, #0 ; Pixel rate isn't set yet
        STR     a1, pixel_rate
        STR     a1, video_gobits
        BL      Determine_PorchSync_Limits
        STR     a1, video_maxporch
        STR     a2, video_maxsync
        Pull    "v1,pc"

; -----------------------------------------------------------------------------------

HAL_VideoFlybackDevice
        MOV     a1, #VIDEO_IRQ ; DSS IRQ
        MOV     pc, lr

; -------------------------------------------------------------------------

;
;  void HAL_Video_SetMode(const void *VIDCList3)
;
;  program DSS registers from VIDCList3 specification
;
;  in: VIDClist -> video mode list (in VIDCList type 3 format)
;

HAL_Video_SetMode ROUT
        Push    "v1-v4,lr"
 [ VideoDebug
        DebugTX "HAL_Video_SetMode"
 ]
        ; Most of these registers are programmed with (VIDC value)-1
        LDR     v1, L4_Display_Log
 [ :LNOT: PassiveVideo
        ; Start off by programming pixel clock, so we can exit cleanly if we've been asked to change to a mode with a bad clock rate
        ; Program CM_CLKSEL2_PLL
        LDR     a4, [a1, #VIDCList3_PixelRate] ; Desired pixel rate, kHz
 [ VideoDebug
        DebugTX "Pixel rate:"
        DebugReg a4
        LDR a2, sys_clk
        DebugTX "sys_clk"
        DebugReg a2
 ]
        LDR     a2, =MAX_PIXEL_RATE
        CMP     a4, a2
        BLS     %FT10
        DebugTX "HAL_Video_SetMode: Pixel rate too high"
        Pull    "v1-v4,pc"
10
        ; Check if we're already programmed to this pixel rate
        LDR     a2, pixel_rate
        CMP     a2, a4
        BEQ     %FT20
        ; Else we need to reprogram the DSI PLL
        ; Use the sequence indicated in the OMAP TRM (spruf98b, fig 15-135), tweaked a bit to avoid writing values until we know the desired pixel rate is possible
        ; We also follow figures 15-142 and 15-143, to ensure video output is disabled & re-enabled in the correct manner before we go tweaking the clock frequencies (although those two figures reference the SDI PLL, not the DSI PLL) although this is wrong now that we're using RFBI? just need to follow dpi_set_mode()
        ; todo - investigate what the role of the sys_clk divider is (i.e. whether it really does need to be on for some frequencies)

        ; Calculate REGM, REGN
        MOV     a2, #1000
        Push    "a1"
        MUL     a1,a2,a4 ; Pixel rate, Hz
        BL      calculate_DSS_clock_divider
        CMP     a1, #2048
        CMPLO   a2, #128
        BLO     %FT10
        DebugTX "HAL_Video_SetMode: Bad DSS clock divider"
        DebugReg a4
        DebugReg a1
        DebugReg a2
        Pull    "a1,v1-v4,pc"
10
        ; Calculate FREQSEL
        MOV     v2, a1 ; REGM
        MOV     v3, a2 ; REGN
        ; First, calculate Fint
        ADD     a1, a2, #1
        LDR     a2, sys_clk
        BL      |__rt_udiv|
        BL      PRCM_GetFreqSel
        SUB     a2, a1, #3
        CMP     a2, #4
        BLS     %FT10
        DebugTX "HAL_Video_SetMode: Bad Fint"
        DebugReg a4
        DebugReg v2
        DebugReg v3 
        Pull    "a1,v1-v4,pc"
10
        MOV     v4, a1 ; FREQSEL

        ; Disable Vsync IRQ to avoid pointer corruption issues
        MOV     a1, #0
        STR     a1, [v1, #DISPC_IRQENABLE]
        
        ; Data synchronisation barrier
        myDSB

        ; New pixel rate is good, shutdown DISPC while we update the DSI PLL
        LDR     a1, pixel_rate
        CMP     a1, #0
        BEQ     %FT30 ; Skip DISPC/PLL shutdown sequence
 [ VideoDebug
        DebugTX "Performing DISPC shutdown"
 ]
        ; Should we turn off the DVI framer here?

        ; Wait for any pending GOLCD/GODIGITAL to complete
10
        LDR     a1, [v1, #DISPC_CONTROL]
        TST     a1, #3:SHL:5
        BNE     %BT10
        
        ; Now we turn off the DISPC outputs
        ; Just gating the functional clocks should work?
        LDR     a1, [v1, #DISPC_CONFIG]
        ORR     a1, a1, #1:SHL:9
        STR     a1, [v1, #DISPC_CONFIG]        
30
        ; DISPC is turned off, now we can program the new DSI PLL value
        ; v2 = REGM
        ; v3 = REGN
        ; v4 = FREQSEL
        ; dpi_display_enable()
        ; - dpi_basic_init()
        ; -- dispc_set_parallel_interface_mode(OMAP_DSS_PARALLELMODE_BYPASS)
        LDR     a1, [v1, #DISPC_CONTROL]
        BIC     a1, a1, #1:SHL:11 ; STALLMODE=0
        ORR     a1, a1, #3:SHL:15 ; GPOUT0=1,GPOUT1=1
        ; -- dispc_set_lcd_display_type(OMAP_DSS_LCD_DISPLAY_TFT)
        ORR     a1, a1, #1:SHL:3
        ; -- dispc_set_tft_data_lines(DSI_LINES)
        ORR     a1, a1, #3:SHL:8
        STR     a1, [v1, #DISPC_CONTROL]
        ; - dsi_pll_init(0,1)
        ; -- dss_dsi_power_up()
        ;    (nothing?)
        ; -- dispc_pck_free_enable(1)
        LDR     a1, [v1, #DISPC_CONTROL]
        ORR     a1, a1, #1:SHL:27 ; PCKFREEENABLE - PLL doesn't come out of reset without this, according to some linux code
        STR     a1, [v1, #DISPC_CONTROL]
 [ :LNOT: QEMU
        ; -- wait_for_bit_up(DSI_PLL_STATUS,0)
  [ VideoDebug
        DebugTX "Wait for DSI_PLLCTRL_RESET_DONE"
  ]
10
        LDR     a1, [v1, #DSI_PLL_STATUS]
        TST     a1, #1 ; DSI_PLLCTRL_RESET_DONE? (surely this assumes that it's just been reset?)
        BEQ     %BT10
        ; -- dispc_pck_free_enable(0)
        LDR     a1, [v1, #DISPC_CONTROL]
        BIC     a1, a1, #1:SHL:27 ; Disable PCKFREEENABLE because it causes problems with video planes? (more linux stuff)
        STR     a1, [v1, #DISPC_CONTROL]
        ; -- dsi_pll_power(DSI_PLL_POWER_ON_DIV)
        LDR     a1, [v1, #DSI_CLK_CTRL]
        ORR     a1, a1, #3:SHL:30 ; PLL on, HSDIVIDER on, but no output to DSI complex I/O
        STR     a1, [v1, #DSI_CLK_CTRL]
  [ VideoDebug
        DebugTX "Wait for DSI_PLL_POWER_ON_HSCLK"
  ]
10
        LDR     a1, [v1, #DSI_CLK_CTRL]
        AND     a1, a1, #3:SHL:28
        CMP     a1, #3:SHL:28
        BNE     %BT10 ; Wait for requested state to be reached

        ; - dpi_set_mode()
        ; -- dispc_set_pol_freq() - ok to delay until later?
        ; -- dpi_set_dsi_clk()
  [ VideoDebug
        DebugTX "Programming DSI PLL"
  ]
        ; --- dsi_pll_program() - what we do here:
        LDR     a1, [v1, #DSI_PLL_CONTROL]
        BIC     a1, a1, #1 ; DSI_PLL_AUTOMODE = manual (apparently)
        STR     a1, [v1, #DSI_PLL_CONTROL]
        ; Calculate DSI_PLL_CONFIGURATION1
        LDR     a1, [v1, #DSI_PLL_CONFIGURATION1]
        BIC     a1, a1, #&FE
        ORR     a1, a1, v3, LSL #1 ; REGN
        BIC     a1, a1, #&70000
        BIC     a1, a1, #&0FF00
        ORR     a1, a1, v2, LSL #8 ; REGM
        ORR     a1, a1, #1 ; STOPMODE selected (why?)
        ; REGM3, REGM4
        LDR     a2, =&7F80000
        BIC     a1, a1, a2 ; Clear old values
        ; We leave REGM4 as 0, since we don't use it
        ; But REGM3+1 = frequency on data lane/(pixel rate*2)
        ; REMG3+1 = (2*pixel rate*bpp)/(pixel rate*2*lanes) = DSI_BPP/DSI_LANES
        ASSERT  (DSI_BPP :MOD: DSI_LANES)=0
        ORR     a1, a1, #((DSI_BPP/DSI_LANES)-1):SHL:19
        ORR     a1, a1, #7:SHL:23 ; Set REGM4?
        STR     a1, [v1, #DSI_PLL_CONFIGURATION1]
        ; Calculate DSI_PLL_CONFIGURATION2       
        LDR     a2, [v1, #DSI_PLL_CONFIGURATION2]
        BIC     a2, a2, #3:SHL:11 ; Select sys_clk, clear HIGHFREQ
        BIC     a2, a2, #&1E
        ORR     a2, a2, v4, LSL #1 ; FREQSEL (angstrom always uses 7?)
        ORR     a2, a2, #(1:SHL:13)+(1:SHL:8) ; Enable reference clock, drift guard
        BIC     a2, a2, #1:SHL:14 ; Disable DSIPHY clock
        ORR     a2, a2, #1:SHL:20 ; HSDIVIDER in bypass mode
        STR     a2, [v1, #DSI_PLL_CONFIGURATION2]
        ; Set DSI_PLL_GO
        MOV     a1, #1
        STR     a1, [v1, #DSI_PLL_GO]
        ; Wait for completion
  [ VideoDebug
        DebugTX "Wait for DSI_PLL_GO"
  ]
10
        LDR     a1, [v1, #DSI_PLL_GO]
        TST     a1, #1 ; GO bit still set?
        BNE     %BT10
  [ VideoDebug
        DebugTX "Wait for DSI PLL lock"
  ]
        MOV     a3, #2*1024*1024
10
        LDR     a1, [v1, #DSI_PLL_STATUS]
        TST     a1, #2 ; DSI PLL locked?
;        BEQ     %BT10
        BNE     %FT5
        SUBS    a3, a3, #1
        BNE     %BT10
  [ VideoDebug
        DebugTX "DSI PLL lock timeout"
        LDR     a1, [v1, #DSI_PLL_CONTROL] ; 00000000
        DebugReg a1
        LDR     a1, [v1, #DSI_PLL_STATUS] ; 00000041 - DSI_PLL_BYPASS, RESETDONE
        DebugReg a1
        LDR     a1, [v1, #DSI_PLL_GO] ; 00000000
        DebugReg a1
        LDR     a1, [v1, #DSI_PLL_CONFIGURATION1] ; 00387c0f - STOPMODE selected (bad?), REGN = 7, REGM = 7c, M3REG = 7, M4REG = 0
        DebugReg a1
        LDR     a1, [v1, #DSI_PLL_CONFIGURATION2] ; 0010200c - FREQSEL 1.5-1.75, DSI_PLL_REFEN, DSI_HSDIVBYPASS
        DebugReg a1
        LDR     a1, [v1, #DSI_CLK_CTRL] ; 50000001 - LP_CLK_DIVISOR 1, power=HSDIVIDER off, PLL on
        DebugReg a1
  ]
;6
;        B       %BT6
5
        ; Modify CONFIGURATION2 again to do stuff
        ; Some of this can be skipped, matches reset values?
        BIC     a2, a2, #1 ; DSI_PLL_IDLE = 0
        BIC     a2, a2, #&6E0 ; DSI_PLL_PLLLPMODE, LOWCURRSTBY, TIGHTPHASELOCK, LOCKSEL = 0
        ORR     a2, a2, #1:SHL:16 ; DSS_CLOCK_EN
        BIC     a2, a2, #1:SHL:17 ; DSS_CLOCK_PWDN
        BIC     a2, a2, #1:SHL:20 ; HSDIVIDER in normal mode
        STR     a2, [v1, #DSI_PLL_CONFIGURATION2] 
 ]       
        ; Make sure DISPC uses DSI1_PLL_FCLK
        LDR     a1, [v1, #DSS_CONTROL]
        ORR     a1, a1, #1
        STR     a1, [v1, #DSS_CONTROL]

        ; Enable functional clock again
        LDR     a1, [v1, #DISPC_CONFIG]
        BIC     a1, a1, #1:SHL:9
        ; Also make sure colour phase rotation is enabled
        ORR     a1, a1, #1:SHL:15
        ; Also make sure transparency colour key is enabled for the mouse cursor
        ORR     a1, a1, #&F:SHL:10 ; Video source transparency colour key for both LCD & digital output
        BIC     a1, a1, #3:SHL:1 ; load palette+frame data!
        STR     a1, [v1, #DISPC_CONFIG]

        Pull    "a1"
        ; Remember the new pixel rate!
        LDR     a3, [a1, #VIDCList3_PixelRate]
        STR     a3, pixel_rate
20
 [ VideoDebug
        DebugTX "Programming VIDC timings"
 ]
        ; Now we can program the rest of the VIDC list
        ; Program DISPC_TIMING_H
        LDR     a2, [a1, #VIDCList3_HorizSyncWidth]
        LDR     a4, video_maxsync
        SUBS    a2, a2, #1
        MOVLT   a2, #0
        CMP     a2, a4
        SUBGE   a2, a4, #1 ; a4 is actually max value+1
        LDR     a3, [a1, #VIDCList3_HorizFrontPorch]
        LDR     a4, video_maxporch
        SUBS    a3, a3, #1
        MOVLT   a3, #0
        CMP     a3, a4
        SUBGE   a3, a4, #1
        ORR     a2, a2, a3, LSL #8
        LDR     a3, [a1, #VIDCList3_HorizBackPorch]
        SUBS    a3, a3, #1
        MOVLT   a3, #0
        CMP     a3, a4
        SUBGE   a3, a4, #1
        ORR     a2, a2, a3, LSL #20
        STR     a2, [v1, #DISPC_TIMING_H]
        ; Program DISPC_TIMING_V
        LDR     a2, [a1, #VIDCList3_VertiSyncWidth]
        LDR     a4, video_maxsync
        SUBS    a2, a2, #1
        MOVLT   a2, #0
        CMP     a2, a4
        SUBGE   a2, a4, #1
        LDR     a3, [a1, #VIDCList3_VertiFrontPorch]
        LDR     a4, video_maxporch
        CMP     a3, #0
        MOVLT   a3, #0
        CMP     a3, a4
        SUBGE   a3, a4, #1
        ORR     a2, a2, a3, LSL #8
        LDR     a3, [a1, #VIDCList3_VertiBackPorch]
        CMP     a3, #0
        MOVLT   a3, #0
        CMP     a3, a4
        SUBGE   a3, a4, #1
        ORR     a2, a2, a3, LSL #20
        STR     a2, [v1, #DISPC_TIMING_V]
        ; Program DISPC_POL_FREQ
        MOV     a2, #&28 ; AC bias pin frequency - from u-boot
        LDR     a3, [a1, #VIDCList3_SyncPol]
        TST     a3, #SyncPol_InvertHSync
        ORRNE   a2, a2, #&2000
        TST     a3, #SyncPol_InvertVSync
        ORRNE   a2, a2, #&1000
        STR     a2, [v1, #DISPC_POL_FREQ]
        ; DISPC_SIZE_DIG, DISPC_SIZE_LCD, DISPC_GFX_SIZE, DISPC_PICTURE_SIZE
        LDR     a2, [a1, #VIDCList3_HorizDisplaySize]
        CMP     a2, #2048
        MOVGT   a2, #2048
        CMP     a2, #0
        MOVLE   a2, #1
        SUB     a2, a2, #1
        LDR     a3, [a1, #VIDCList3_VertiDisplaySize]
        CMP     a3, #2048
        MOVGT   a3, #2048
        CMP     a3, #0
        MOVLE   a3, #1
        SUB     a3, a3, #1
        ORR     a2, a2, a3, LSL #16
        STR     a2, [v1, #DISPC_SIZE_DIG]
        STR     a2, [v1, #DISPC_SIZE_LCD]
        STR     a2, [v1, #DISPC_GFX_SIZE]
 |
        ; Disable Vsync IRQ to avoid pointer corruption issues
        MOV     a2, #0
        STR     a2, [v1, #DISPC_IRQENABLE]
        
        ; Data synchronisation barrier
        myDSB
        ; Remember the new pixel rate!
        LDR     a3, [a1, #VIDCList3_PixelRate]
        STR     a3, pixel_rate
        ; Update DISPC_CONFIG to make sure colour phase rotation & transparency colour key is in use
        LDR     a2, [v1, #DISPC_CONFIG]
        BIC     a2, a2, #1:SHL:3 ; LUT used as palette
        BIC     a2, a2, #3:SHL:18 ; alpha blending disabled
        ORR     a2, a2, #1:SHL:15 ; colour phase rotation enabled
        ORR     a2, a2, #&F:SHL:10 ; Video source transparency colour key for both LCD & digital output
        BIC     a2, a2, #3:SHL:1 ; Load palette+frame data!
        STR     a2, [v1, #DISPC_CONFIG]
        ; Crop graphics overlay to fit LCD size
        LDR     a2, [v1, #DISPC_SIZE_LCD]
        MOV     a3, a2, LSR #16 ; height-1
        BIC     a2, a2, a3, LSL #16
        ADD     a2, a2, #1 ; width
        LDR     a4, [a1, #VIDCList3_HorizDisplaySize]
        CMP     a4, a2
        SUBGT   v2, a4, a2
        MOVGT   a4, a2
        MOVLE   v2, #0
        SUB     a4, a4, #1
        LDR     a2, [a1, #VIDCList3_VertiDisplaySize]
        SUB     a2, a2, #1
        CMP     a2, a3
        ORRGT   a4, a4, a3, LSL #16
        ORRLE   a4, a4, a2, LSL #16
        STR     a4, [v1, #DISPC_GFX_SIZE]
        LDR     a2, [a1, #VIDCList3_PixelDepth]
        SUBS    a2, a2, #3
        MOVGT   v2, v2, LSL a2 ; Convert pixel overlap to bytes
        RSBLT   a2, a2, #0
        MOVLT   v2, v2, LSR a2
        ADD     v2, v2, #1
        STR     v2, [v1, #DISPC_GFX_ROW_INC]
        MOV     v2, #1
        STR     v2, [v1, #DISPC_GFX_PIXEL_INC] ; Just in case
 ] ; PassiveVideo
        ; DISPC_GFX_ATTRIBUTES
        LDR     a2, [a1, #VIDCList3_PixelDepth]
        ADR     a3, gfxenable_table
        LDR     a2, [a3, a2, LSL #2]
        STR     a2, [v1, #DISPC_GFX_ATTRIBUTES]
        ; DISPC_GFX_TABLE_BA
        Push    "a1"
        LDR     a1, video_palette
        BL      vtophys
        STR     a1, [v1, #DISPC_GFX_TABLE_BA]
        Pull    "a1"
        ; DISPC_CPR_COEF_*
        ; For now, swap R&B channels regardless of whether we're in a palettised mode or not
        MOV     a2,#256
        STR     a2, [v1, #DISPC_CPR_COEF_R]
        MOV     a2, a2, LSL #11
        STR     a2, [v1, #DISPC_CPR_COEF_G]
        MOV     a2, a2, LSL #11
        STR     a2, [v1, #DISPC_CPR_COEF_B]
        ; DISPC_GLOBAL_ALPHA
        LDR     a2, =&FF00FF
        STR     a2, [v1, #DISPC_GLOBAL_ALPHA]
        ; DISPC_CONTROL
 [ :LNOT: PassiveVideo
        LDR     a2, =&1836b ; Same value as u-boot: GPOUT0, GPOUT1, 24-bit TFT data lines, GODIGITAL, GOLCD, active matrix display, DIGITALENABLE, LCDENABLE
 |
        LDR     a2, [v1, #DISPC_CONTROL]
        ORR     a2, a2, #3:SHL:5
 ]
        STR     a2, [v1, #DISPC_CONTROL]
 [ VideoDebug
        DebugTX "Video mode programmed, waiting for GOLCD/GODIGITAL to clear"
 ]
10
        LDR     a1, [v1, #DISPC_CONTROL]
        TST     a1, #3:SHL:5
        BNE     %BT10
        ; Re-enable VSync IRQ
        MOV     a1, #2
        STR     a1, [v1, #DISPC_IRQENABLE]
 [ :LNOT: PassiveVideo
        ; Now enable the DVI framer
        LDRB    a1, [sb, #BoardConfig_VideoGPIO]
        CMP     a1, #255
        MOV     a2, #1
        BLNE    GPIOx_SetOutput
 ]
        ; Done?
 [ VideoDebug
        DebugTX "HAL_Video_SetMode complete"
 ]
;        MOV     a1, #1 ; NTSC 601 s-video
;        BL venc_setmode
 [ ExtraVideoDebug
        DebugTX "Final regs"
        BL DumpDispcRegs
 ]
        Pull    "v1-v4,pc"

gfxenable_table ; GFXENABLE values for different BPP values
            ; FEDCBA9876543210
        DCD 2_0100100010000001 ; 1BPP
        DCD 2_0100100010000011 ; 2BPP
        DCD 2_0100100010000101 ; 4BPP
        DCD 2_0100100010000111 ; 8BPP
        DCD 2_0100100010001101 ; 16BPP
        DCD 2_0100100010010001 ; 32BPP

; -------------------------------------------------------------------------

;
; void HAL_Video_WritePaletteEntry(uint type, uint pcolour, uint index)
;
; write palette entry to video controller
;
;  type     = 0 for normal palette entry
;             1 for border colour
;             2 for pointer colour
;          >= 3 reserved
;  pcolour  = palette entry colour in BBGGRRSS format (Blue,Green,Red,Supremacy)
;  index    = index of entry  (0..255 for normal, 0 for border, 0..3 for pointer)
;             note that RISC OS only uses 1..3 for pointer (0 is assumed to be transparent)
;
HAL_Video_WritePaletteEntry ROUT
        CMP     a1, #3
        MOVHS   pc, lr
        CMP     a1, #1
        BEQ     %FT10 ; Border colour
        BGT     %FT20 ; Pointer colour
        CMP     a3, #255
        MOVHI   pc, lr ; Out of range
        LDR     a4, video_palette
        MOV     a2, a2, ROR #8
        STR     a2, [a4, a3, LSL #2]
        MOV     pc, lr
10      ; Update border colour
        ; We don't really support this properly. for now just set the default background colour.
        MOV     a2, a2, ROR #8
        LDR     a1, L4_Display_Log
        STR     a2, [a1, #DISPC_DEFAULT_COLOR0]
        STR     a2, [a1, #DISPC_DEFAULT_COLOR1]
        ; GODIGITAL+GOLCD to ensure it's updated
        SetGoBits a1,a2,a3,"HAL_Video_WritePaletteEntry GOLCD timeout"
        MOV     pc, lr
20      ; Update cursor colour
        CMP     a3, #4
        MOVHS   pc, lr ; Out of range
        MOV     a2, a2, LSR #8 ; 00bbggrr
        ADR     a1, cursor_palette
        STR     a2, [a1, a3, LSL #2]
        STR     a1, cursor_update ; Store nonzero value to update flag
        MOV     pc, lr

; -------------------------------------------------------------------------

;
; void HAL_Video_WritePaletteEntries(uint type, const uint *pcolours, uint index, uint Nentries)
;
; write block of palette entries to video controller
;
;  type     = 0 for normal palette entry
;             1 for border colour
;             2 for pointer colour
;          >= 3 reserved
;  pcolours = pointer to block of palette entry colours in BBGGRRSS format (Blue,Green,Red,Supremacy)
;  index    = start index in palette (for first entry in block)
;             note that RISC OS only uses 1..3 for pointer (0 is assumed to be transparent)
;  Nentries = number of entries in block (must be >= 1)
;
HAL_Video_WritePaletteEntries ROUT
        CMP     a4, #0
        MOVEQ   pc, lr ; Nothing to store
        CMP     a1, #3
        MOVHS   pc, lr
        CMP     a1, #1
        BEQ     %FT10 ; Border colour
        BGT     %FT20 ; Pointer colour
        CMP     a3, #255
        CMPLS   a4, #256
        MOVHI   pc, lr ; Out of range
        ADD     ip, a3, a4
        CMP     ip, #256
        MOVHI   pc, lr ; Out of range
        LDR     a1, video_palette
        ADD     a1, a1, a3, LSL #2
5
        LDR     a3, [a2], #4
        MOV     a3, a3, ROR #8
        STR     a3, [a1], #4
        SUBS    a4, a4, #1
        BGT     %BT5
        MOV     pc, lr
10      ; Border update
        ; We don't really support this properly. for now just set the default background colour.
        CMP     a4, #1
        MOVNE   pc, lr
        LDR     a2, [a2]
        MOV     a2, a2, ROR #8
        LDR     a1, L4_Display_Log
        STR     a2, [a1, #DISPC_DEFAULT_COLOR0]
        STR     a2, [a1, #DISPC_DEFAULT_COLOR1]
        ; GODIGITAL+GOLCD to ensure it's updated
        SetGoBits a1,a2,a3,"HAL_Video_WritePaletteEntries GOLCD timeout"
        MOV     pc, lr
20      ; Cursor update
        CMP     a3, #3
        CMPLS   a4, #4
        MOVHI   pc, lr ; Out of range
        ADD     ip, a3, a4
        CMP     ip, #4
        MOVHI   pc, lr ; Out of range
        ADR     a1, cursor_palette
        ADD     a1, a1, a3, LSL #2
5
        LDR     ip, [a2], #4
        MOV     ip, ip, LSR #8 ; 00bbggrr
        ADD     a3, a3, #1
        STR     ip, [a1], #4
        SUBS    a4, a4, #1
        BGT     %BT5
        STR     a1, cursor_update ; Store nonzero value to update flag
        MOV     pc, lr

        LTORG

; -------------------------------------------------------------------------

;
; uint HAL_Video_ReadPaletteEntry(uint type, uint pcolour, uint index)
;
; return the effective palette entry after taking into account any hardware
; restrictions in the video controller, assuming it was programmed with pcolour
;
;  type     = 0 for normal palette entry
;             1 for border colour
;             2 for pointer colour
;          >= 3 reserved
;  pcolour  = palette entry colour in BBGGRRSS format (Blue,Green,Red,Supremacy)
;  index    = index of entry  (0..255 for normal, 0 for border, 0..3 for pointer)
;             note that RISC OS only uses 1..3 for pointer (0 is assumed to be transparent)
;  returns  : effective BBGGRRSS
;
;  mjs: depending on h/w capabilities, specific HALs may have to
;       remember current settings (eg. bits per pixel), keep soft copy
;       of entries or whatever, in their workspace. Because the HAL API
;       supplies a pcolour, the need to keep a full palette soft copy
;       in the HAL is minimised

HAL_Video_ReadPaletteEntry ROUT
        MOV     a1, a2
        MOV     pc, lr

; -------------------------------------------------------------------------

; void HAL_Video_SetInterlace(uint interlace)
;
;  interlace = 0/1 for interlace off/on

HAL_Video_SetInterlace ROUT
        MOV     pc, lr

; -------------------------------------------------------------------------

; void HAL_Video_SetBlank(uint blank, uint DPMS)
;
; blank = 0/1 for unblank/blank
; DMPS  = 0..3 as specified by monitor DPMSState (from mode file)
;         0 for no DPMS power saving

; HAL is expected to attempt to turn syncs off according to DPMS, and
; to turn video DMA off for blank (and therefore on for unblank) if possible.
; HAL is not expected to do anything else, eg. blank all palette entries.
; Such things are the responsibility of the OS, and also this call is expected
; to be fast. May be called with interrupts off.

HAL_Video_SetBlank ROUT
        MOV     pc, lr

; -------------------------------------------------------------------------

; void HAL_Video_SetPowerSave(uint powersave)
;
; powersave = 0/1 for power save off/on

HAL_Video_SetPowerSave ROUT
        MOV     pc, lr

; -------------------------------------------------------------------------

; void HAL_Video_UpdatePointer(uint flags, int x, int y, const shape_t *shape)
;
; Update the displayed position of the current pointer shape (or turn
; shape off)
;
; HAL code may need to take note of shape updated flag, and make its
; own new copies if true. This is to handle cases like dual scan LCD
; pointer, which typically needs two or more shapes buffers for the
; hardware. This work should _only_ be done when the updated flag
; is true, or possibly because provoked by clipping requirements.
; A simple HAL, using the kernel shape buffer directly, may be able to
; ignore the updated flag.
;
; flags:
;   bit 0  = pointer display enable (0=off, 1=on)
;   bit 1  = pointer shape update (0=no change, 1=updated)
;   bits 2..31 reserved (0)
; xpos = x position of top left of pointer (xpos = 0 for left of display)
; ypos = y position of top left of pointer (ypos = 0 for top of display)
; shape points to shape_t descriptor block:
;   typedef struct shape_t
;   {
;     uint8   width;      /* unpadded width in bytes (see notes) */
;     uint8   height;     /* in pixels */
;     uint8   padding[2]; /* 2 bytes of padding for field alignment */
;     void   *buffLA;     /* logical address of buffer holding pixel data */
;     void   *buffPA;     /* corresponding physical address of buffer */
;   }
;
; Notes:
; 1) if flags bit 0 is 0 (pointer off), x, y, shape are undefined
; 2) the shape data from RISC OS is always padded with transparent pixels
;    on the rhs, to a width of 32 pixels (8 bytes)
; 3) pointer clipping is the responsibility of the HAL (eg. may be able to
;    allow display of pointer in border region on some h/w)
; 4) buffer for pixel data is aligned to a multiple of 256 bytes or better
;
; This call is made by the OS at a time to allow smoothly displayed changes
; (on a VSync)

HAL_Video_UpdatePointer ROUT
        Push     "v1-v5,lr"
        TST     a1, #1
        BEQ     %FT10 ; Cursor off
        ; Update image?
        TST      a1, #2
        LDREQ    a1, cursor_update ; Any palette changes that need implementing?
        CMPEQ    a1, #0
        BEQ      %FT20
        ; The current pointer implementation assumes that palette index 0 is
        ; the only transparent entry (which is currently true for RISC OS).
        ; And since we're using the DSS transparency colour key feature, we
        ; need to make sure the (24bit RGB) value for entry 0 is unique.
        ; So this piece of code, just before the image update, ensures that
        ; the palette entry is unique
        ADR      a1, cursor_palette
        LDMIA    a1, {v1-v4} ; Grab the 4 entries. We assume that the top bit is already clear (the palette set functions should have done that for us)
5
        CMP      v1, v2
        CMPNE    v1, v3
        CMPNE    v1, v4
        ADDEQ    v1, v1, #1
        BICEQ    v1, v1, #&FF000000 ; Avoid overflowing into top byte
        BEQ      %BT5 ; Loop until we find a uinque colour
        STR      v1, [a1] ; Store it back
        ; Here we also update the colour key registers with the right value
        LDR      v2, L4_Display_Log
        STR      v1, [v2, #DISPC_TRANS_COLOR0]
        STR      v1, [v2, #DISPC_TRANS_COLOR1]
        ; Now we can update the image
        LDRB     v1, [a4] ; width
        LDRB     v2, [a4,#1] ; height
        MOV      v1, v1, LSL #2 ; Byte width -> pixel width
        ; Clamp size to sensible values
        CMP      v1, #0
        CMPNE    v2, #0
        BEQ      %FT20 ; No width/height... ignore
        CMP      v2, #HW_CURSOR_HEIGHT
        MOVGT    v2, #HW_CURSOR_HEIGHT
        ; No upper bound on width; we just skip the extra pixels when copying to our buffer
        LDR      lr, cursor_image
        ; Good - now copy the data over
        ASSERT   HW_CURSOR_WIDTH = 32 ; RISC OS pads each row to be 32 pixels wide, make sure our buffer is the same width
        MOV      v4, #0 ; Current y
        LDR      a4, [a4,#4] ; Get source buffer
5
        MOV      v1, #16
        CMP      v4,v2 ; If the cursor is smaller than our buffer, don't load. No need to set v3 & v5 to 0 either; they will be 0 from the previous row
        LDMLTIA  a4!, {v3,v5} ; Get all 32 pixels for this row
6
        AND      ip, v3, #&3
        LDR      ip, [a1, ip, LSL #2]
        MOV      v3, v3, LSR #2
        SUBS     v1, v1, #1
        STR      ip, [lr], #4
        BGT      %BT6
        MOV      v1, #16
7
        AND      ip, v5, #&3
        LDR      ip, [a1, ip, LSL #2]
        MOV      v5, v5, LSR #2
        SUBS     v1, v1, #1
        STR      ip, [lr], #4
        BGT      %BT7
        ADD      v4,v4,#1
        CMP      v4,#HW_CURSOR_HEIGHT
        BLT      %BT5
        ; Image updated!
        STR      v3, cursor_update ; Clear update flag (v3 will be 0 at this point)
20
        ; Update position
        ; Even though the source image is likely to be smaller than our buffer, we always treat it as being the full buffer size
        LDR     a1, cursor_image
        MOV     v1, a2
        MOV     v2, a3
        BL      vtophys ; Get physical addr for programming VID2 base address
        MOV     v3, #HW_CURSOR_WIDTH
        MOV     v4, #HW_CURSOR_HEIGHT
        CMP     v1, #0
        SUBLT   a1, a1, v1, LSL #2 ; Skip pixels that are off the left of the screen
        ADDLT   v3, v3, v1
        MOVLT   v1, #0
        CMP     v2, #0
        SUBLT   a1, a1, v2, LSL #HW_CURSOR_WIDTH_POW2+2 ; Skip rows that are off the top of the screen
        ADDLT   v4, v4, v2
        MOVLT   v2, #0
        ; This may just be an issue with how the graphics windows are set up, but it looks like we need to crop the pixels that are off the right/bottom of the screen
        LDR     a3, L4_Display_Log
        LDR     a4, [a3, #DISPC_SIZE_LCD] ; Use SIZE_LCD, since we program VID2 for LCD output? (Not that it matters, since the sizes are identical ATM)
        MOV     v5, a4, LSR #16 ; Height-1
        BIC     a4, a4, v5, LSL #16 ; Width-1
        ADD     v5, v5, #1
        ADD     a4, a4, #1
        SUB     a4, a4, v1 ; a4 = max width
        CMP     a4, v3
        MOVLT   v3, a4
        SUB     v5, v5, v2 ; v5 = max height
        CMP     v5, v4
        MOVLT   v4, v5 
        CMP     v1, #2048
        CMPLS   v2, #2048
        BHI     %FT10 ; Outside programmable video window position
        CMP     v3, #0
        CMPGT   v4, #0
        BLE     %FT10 ; Cropped image has no or negative size
        ; Else program attributes
        ADD     a4, a3, #DISPC_VID2:AND:&FF
        ADD     a4, a4, #DISPC_VID2:AND:&FF00
        LDR     a2, [a4, #DISPC_VIDn_BA0]
        CMP     a1, a2 ; Update required?
        STR     a1, [a4, #DISPC_VIDn_BA0]
        LDR     a2, [a4, #DISPC_VIDn_BA1]
        CMPEQ   a1, a2
        STR     a1, [a4, #DISPC_VIDn_BA1]
        ORR     a1, v1, v2, LSL #16
        LDR     a2, [a4, #DISPC_VIDn_POSITION]
        CMPEQ   a1, a2
        STR     a1, [a4, #DISPC_VIDn_POSITION]
        MOV     a1, v3, LSL #2 ; Width in bytes
        RSB     a1, a1, #HW_CURSOR_WIDTH*4 ; ROW_INC in bytes
        ADD     a1, a1, #1 ; Add 1 to get correct ROW_INC value
        LDR     a2, [a4, #DISPC_VIDn_ROW_INC]
        CMPEQ   a1, a2
        STR     a1, [a4, #DISPC_VIDn_ROW_INC]
        SUB     v3, v3, #1
        SUB     v4, v4, #1
        ORR     a1, v3, v4, LSL #16
        LDR     a2, [a4, #DISPC_VIDn_SIZE]
        CMPEQ   a1, a2
        STR     a1, [a4, #DISPC_VIDn_SIZE]
        LDR     a2, [a4, #DISPC_VIDn_PICTURE_SIZE]
        CMPEQ   a1, a2
        STR     a1, [a4, #DISPC_VIDn_PICTURE_SIZE] ; Required?
        LDR     a1, =2_0100010000000000000011001 ; high priority pipeline, use FIFO threshold, LCD output, 4x32bit DMA burst, ARGB 32, enabled
        LDR     a2, [a4, #DISPC_VIDn_ATTRIBUTES]
        CMPEQ   a1, a2
        STR     a1, [a4, #DISPC_VIDn_ATTRIBUTES]
        BEQ     %FT30 ; Will only be EQ if none of the registers changed
        B       %FT20 ; Else at least one reg changed and we need to set the go bits
10
        ; Cursor off
        LDR     a3, L4_Display_Log
        ADD     a1, a3, #DISPC_VID2:AND:&FF
        ADD     a1, a1, #DISPC_VID2:AND:&FF00
        MOV     a2, #0 ; Disabled
        LDR     a4, [a1, #DISPC_VIDn_ATTRIBUTES]
        CMP     a4, a2
        BEQ     %FT30 ; Skip update
        STR     a2, [a1, #DISPC_VIDn_ATTRIBUTES]
20
        ; Set GODIGITAL+GOLCD to ensure the register updates are applied
        SetGoBits a3,a1,a2,"HAL_Video_UpdatePointer GOLCD timeout"
30
        ; If pixel_rate is zero or DISPC_CONFIG bit 9 is set, we're in the middle of a mode change
        ; in which case setting the go bits is probably a bad idea
        LDR     a1, pixel_rate
        CMP     a1, #0
        Pull    "v1-v5,pc",EQ
        LDR     a1, [a3, #DISPC_CONFIG]
        TST     a1, #1:SHL:9
        Pull    "v1-v5,pc",NE
        ; Do we have a pending gobits from elsewhere?
        LDR     a1, video_gobits
        LDR     a2, [a3, #DISPC_CONTROL]
        BICS    a4, a1, a2 ; a4 = bits we can safely set
        ORRNE   a2, a2, a4
        STRNE   a2, [a3, #DISPC_CONTROL] ; Set the bits
        BICNE   a1, a1, a4 ; Clear them from our update mask
        STRNE   a1, video_gobits
        Pull     "v1-v5,pc"
        

; -------------------------------------------------------------------------

; void HAL_Video_SetDAG(uint DAG, uint paddr)
;
; set Video DMA address generator value to given physical address
;
; DAG   = 0 set start address of current video display
;         1 set start address of total video buffer
;         2 set end address (exclusive) of total video buffer
;         all other values reserved
; paddr = physical address for given DAG
;
; Notes:
; The OS has a video buffer which is >= total display size, and may be using
; bank switching (several display buffers) or hardware scroll within the
; total video buffer.
;
; DAG=1 will be start address of current total video buffer
; DAG=2 will be end address (exclusive) of current total video buffer
; DAG=0 will be start address in buffer for current display
;
; HALs should respond as follows:
; 1) If they have no hardware scroll support, only DAG=0 is significant,
;    and the end address of the current display is implied by the size
;    of the current mode. Calls with DAG=1,2 should be ignored.
; 2) If they support hardware scroll, DAG=0 again defines display start.
;    DAG=2 defines the last address (exclusive) that should be displayed
;    before wrapping back (if reached within display size), and DAG=1
;    defines the address to which accesses should wrap back.

HAL_Video_SetDAG ROUT
        CMP     a1, #0
        MOVNE   pc, lr
        Push    "lr"
        LDR     a3, L4_Display_Log
        STR     a2, [a3, #DISPC_GFX_BA0]
        STR     a2, [a3, #DISPC_GFX_BA1]
 [ VideoDebug
        DebugTX "SetDAG"
        DebugReg a2
 ]
        ; GODIGITAL+GOLCD to ensure it's updated
        SetGoBits a3,a1,a2,"HAL_Video_SetDAG GOLCD timeout"
        Pull    "pc"
        MOV     pc, lr


; -------------------------------------------------------------------------

;
; uint HAL_Video_Features(void)
;
; returns a flags word:
;    bit 0     h/w scroll is supported
;    bit 1     h/w pointer is supported
;    bit 2     interlace is supported with progressive framestore
;    other bits reserved (returned as 0)

HAL_Video_Features ROUT
        MOV     a1, #2_010   ; no hw scroll, h/w pointer, no interlace
        MOV     pc, lr

; -------------------------------------------------------------------------

;
; uint HAL_Video_PixelFormats(void)
;
;
; returns flags word:
;    bit 0     1 bpp is supported
;    bit 1     2 bpp is supported
;    bit 2     4 bpp is supported
;    bit 3     8 bpp is supported
;    bit 4    16 bpp is supported
;    bit 5    32 bpp is supported
;    other bits reserved (returned as 0)
;    bits 0-5 refer to support with standard RO pixel layout (little endian
;    packing for 1,2,4 bpp, 5-5-5 RGB for 16 bpp, etc.)
;    other formats may be introduced when/if RO supports them

HAL_Video_PixelFormats ROUT
        MOV     a1, #2_111111   ; 1,2,4,8,16,32 bpp
        MOV     pc, lr

; -------------------------------------------------------------------------

;
; uint HAL_Video_BufferAlignment(void)
;
; returns the required alignment for the framestore buffer, in bytes
; (expected to be a power of 2)

HAL_Video_BufferAlignment ROUT
        MOV     a1, #32          ; align to 32 bytes
        MOV     pc, lr

; -------------------------------------------------------------------------

;
; uint HAL_Video_OutputFormat(void)
;
; returns current video output format
;      0 = analogue (or 'normal', unspecified)
;      1 = 16-bit non-multiplexed RGB 5-6-5 (Chrontel 7003 format 0)
;     ...
;     10 = Chrontel 7003 format 9
;  >= 11 reserved
;

HAL_Video_OutputFormat
        MOV     a1, #0     ;normal/unspecified
        MOV     pc, lr

; -------------------------------------------------------------------------

;;;mjsHAL - is the mode workspace really generic enough to pass to HAL?
;;;

;
; int HAL_Video_VetMode(const void *VIDClist, const void *workspace)
;
; VIDClist  -> generic video controller list (VIDC list type 3)
; workspace -> mode workspace (if mode number), or 0
; returns 0 if OK (may be minor adjusts to VIDClist and/or workspace values)
;         non-zero if not OK
;
HAL_Video_VetMode ROUT
 [ :LNOT: PassiveVideo
 [ VetModeDebug
        Push "lr"
        DebugTX "HAL_Video_VetMode"
        LDR     a3, [a1, #VIDCList3_PixelRate]
        DebugTX "Pixel rate"
        DebugReg a3
        LDR     a3, [a1, #VIDCList3_PixelRate]
        MOV     a2,#1000
        Push    "a1"
        MUL     a1,a2,a3
        BL      calculate_DSS_clock_divider
        DebugTX "DSI PLL divider"
        DebugReg a1
        DebugReg a2
        ADD     a1, a2, #1
        LDR     a2, sys_clk
        BL      |__rt_udiv|
        DebugTX "Fint"
        DebugReg a1
        BL      PRCM_GetFreqSel
        DebugTX "FreqSel"
        DebugReg a1 
        Pull    "a1"
        LDR     a2, [a1, #VIDCList3_HorizSyncWidth]
        DebugTX "HSW"
        DebugReg a2
        LDR     a2, [a1, #VIDCList3_HorizFrontPorch]
        DebugTX "HFP"
        DebugReg a2
        LDR     a2, [a1, #VIDCList3_HorizBackPorch]
        DebugTX "HBP"
        DebugReg a2
        LDR     a2, [a1, #VIDCList3_VertiSyncWidth]
        DebugTX "VSW"
        DebugReg a2
        LDR     a2, [a1, #VIDCList3_VertiFrontPorch]
        DebugTX "VFP"
        DebugReg a2
        LDR     a2, [a1, #VIDCList3_VertiBackPorch]
        DebugTX "VBP"
        DebugReg a2
        LDR     a2, [a1, #VIDCList3_HorizDisplaySize]
        DebugTX "Width"
        DebugReg a2
        LDR     a2, [a1, #VIDCList3_VertiDisplaySize]
        DebugTX "Height"
        DebugReg a2
        LDR     a2, [a1, #VIDCList3_PixelDepth]
        DebugTX "Colours"
        DebugReg a2
        Pull "lr"
 ]
        ; Check pixel rate
        LDR     a3, [a1, #VIDCList3_PixelRate]
        LDR     a2, =MAX_PIXEL_RATE
        CMP     a3, a2
        MOVGT   pc,lr
        CMP     a3,#0
        MOVEQ   pc,lr
        MOV     a2,#1000
        Push    "a1,lr"
        MUL     a1,a2,a3
        BL      calculate_DSS_clock_divider
        CMP     a1, #2048
        CMPLO   a2, #128
        Pull    "a1,pc",HS
        ; Check Fint is between 0.75MHz and 2.1MHz
        ADD     a1, a2, #1
        LDR     a2, sys_clk
        BL      |__rt_udiv|
        BL      PRCM_GetFreqSel
        SUB     a1, a1, #3
        CMP     a1, #4
        Pull    "a1,lr"
        MOVHI   pc,lr ; Accept FreqSel values of 3-7 (0.75MHz->2.1MHz)
        ; Check H, V timing values
        ; Although SetMode does attempt to adjust these itself, for the time being let's try and avoid any modes with out of range values altogether.
        LDR     a2, [a1, #VIDCList3_HorizSyncWidth]
        LDR     a3, video_maxsync
        SUB     a2, a2, #1
        CMP     a2, a3
        MOVHS   pc,lr
        LDR     a2, [a1, #VIDCList3_VertiSyncWidth]
        SUB     a2, a2, #1
        CMP     a2, a3
        MOVHS   pc,lr
        LDR     a2, [a1, #VIDCList3_HorizFrontPorch]
        LDR     a3, video_maxporch
        SUB     a2, a2, #1
        CMP     a2, a3
        MOVHS   pc,lr
        LDR     a2, [a1, #VIDCList3_HorizBackPorch]
        SUB     a2, a2, #1
        CMP     a2, a3
        MOVHS   pc,lr
        LDR     a2, [a1, #VIDCList3_VertiFrontPorch]
        SUB     a2, a2, #1
        CMP     a2, a3
        MOVHS   pc,lr
        LDR     a2, [a1, #VIDCList3_VertiBackPorch]
        SUB     a2, a2, #1
        CMP     a2, a3
        MOVHS   pc,lr
        ; Check (HBP+HSW+HFP)*PCD > 8
        LDR     a2, [a1, #VIDCList3_HorizBackPorch]
        LDR     a3, [a1, #VIDCList3_HorizSyncWidth]
        LDR     a4, [a1, #VIDCList3_HorizFrontPorch]
        ADD     a2, a2, a3
        ADD     a2, a2, a4
        CMP     a2, #4 ; We always use PCD of 2
        MOVLE   pc,lr
        ; Check screen size
        LDR     a2, [a1, #VIDCList3_HorizDisplaySize]
        SUB     a2, a2, #1
        CMP     a2, #2048
        MOVHS   pc,lr
        LDR     a2, [a1, #VIDCList3_VertiDisplaySize]
        SUB     a2, a2, #1
        CMP     a2, #2048
        ; Check colour depth
        LDR     a2, [a1, #VIDCList3_PixelDepth]
        CMP     a2, #5
        MOVHI   pc,lr
 ] ; PassiveVideo
        ; Else we're good
        MOV     a1,#0
        MOV     pc,lr

; -------------------------------------------------------------------------

; Function for calculating DSI PLL clock dividers
; in:  a1 = desired pixel rate (Hz)
; out: a1 = DSI_PLL_REGM (values not guaranteed to be in range)
;      a2 = DSI_PLL_REGN
; all other regs preserved
;
; The full clock flow is as follows:
;   DSI PLL input = DSI_PLL_REFCLK (= DSS2_ALWON_FCLK = sys_clk)
;   Data lane freq = DSIPHY = 2*pixel rate*DSI_BPP/DSI_LANES
;   DSIPHY = 2*DSI_PLL_REGM/(DSI_PLL_REGN+1)*DSI_PLL_REFCLK/(HIGHFREQ+1)
;   HIGHFREQ = (DSI_PLL_REFCLK>32MHz?1:0) (=0 for all current sys_clk values) 
; Also, 0.75MHz <= Fint <= 2.1MHz where Fint = DSI_PLL_REFCLK/(DSI_PLL_REGN+1)
; DSIPHY is then used as the source for the HSDIVIDER, which does the following:
;   DSI1_PLL_FCLK = DSIPHY/REGM3
;   DSI2_PLL_FCLK = DSIPHY/REGM4
; Both must be <= 173MHz
; DSI2_PLL_FCLK can be used to drive the DSI module, except we don't care much for that
; DSI1_PLL_FCLK is what we use to drive the DISPC pixel clock:
;   pixel rate = (DSI1_PLL_FCLK/LCD)/PCD
;   1 <= LCD <= 255
;   2 <= PCD <= 255
; Even though we don't use the DSI output module, we still calculate DSIPHY as if we are using it (so that DSIPHY = data lane freq)
; This then simplifies REGM3, REGM4, LCD and PCD programming so that it can use fixed values independent of the pixel rate:
;   REGM3 = DSIPHY/(pixel rate*2) = DSI_LANES/DSI_BPP (so that DSI1_PLL_FCLK = 2*pixel rate)
;   LCD=1, PCD=2 (so that DSI1_PLL_FCLK is divided by two to get the target pixel rate)
;
; An algorithm that aims for 100% accurate clock rates was found to be incapable of calculating divider values for most RISC OS screen modes (in particular the 25.175MHz mode used at boot). Instead, an algorithm that aims to find the closest possible clock rate is used. Most clock rate errors appear to be tiny (within 1kHz of the desired data lane frequency), so this shouldn't pose any problems.
;
calculate_DSS_clock_divider
        CMP     a1, #0
        MVNEQ   a2, #0
        MOVEQ   pc, lr
        Push    "a3-v5,lr"
        ; data lane freq = 2*pixel rate*bpp/lanes
        ASSERT  ((2*DSI_BPP) :MOD: DSI_LANES)=0
        MOV     a3, #(2*DSI_BPP)/DSI_LANES
        MUL     v3, a3, a1 ; data lane freq
        MOV     v1, v3 ; Best error. This can easily be modified to limit the clock to a maximum error value, either fixed or to within a percentage of the pixel rate.
        MVN     v4, #0 ; Best REGM
        MVN     v5, #0 ; Best REGN
        ; Search for satisfactory REGN:
        ; - Provides Fint that's within range
        ; - sys_clk MOD REGN = 0
        MOV     v2, #1 ; Current N(+1)
;        DebugTX "calculate_DSS_clock_divider"
        LDR     a1, sys_clk
;        DebugReg a1
10
        MOV     a1, v2
        LDR     a2, sys_clk
        BL      |__rt_udiv| ; a1 = Fint, a2 = remainder
        CMP     a2, #0
        BNE     %FT20
        LDR     a3, =750000
        LDR     a4, =2100000
        CMP     a1, a3
        CMPHI   a4, a1
        BLO     %FT20
;        DebugTX "REGN -> Fint"
;        DebugReg v2
;        DebugReg a1
        ; REGN is good; use it to calculate nearest REGM
        MOV     a4, a1 ; Fint
        MOV     a1, a4, LSL #1 ; Fint*2
        MOV     a2, v3
;        DebugTX "REGM calc"
;        DebugReg a1
;        DebugReg a2
        BL      |__rt_udiv| ; a1 = REGM, a2 = error
;        DebugTX "REGM result"
;        DebugReg a1
;        DebugReg a2
        ; Round to nearest, maintaining a2 as the error
        CMP     a2, a4
        ADDGE   a1, a1, #1
        RSBGE   a2, a2, a4, LSL #1
        ; Is a2 better than our current error?
        CMP     a2, v1
        MOVLT   v1, a2
        MOVLT   v4, a1
        MOVLT   v5, v2
        CMP     a2, #0 ; Is it perfect?
        BEQ     %FT30
20
        ; Try another N
        ADD     v2, v2, #1
        CMP     v2, #129
        BLT     %BT10
30
        ; Use v4 & v5, whether they're accurate or not
        MOV     a1, v4 ; DSI_PLL_REGM
        SUB     a2, v5, #1 ; DSI_PLL_REGN
        Pull    "a3-v5,pc"

  | ; HALDoesVideo

a230 2
  ]

@


1.18
log
@Miscellaneous OMAP3 HAL updates
Detail:
  s/Boot - HAL_Reset now sets the PRM_RSTCTRL.RST_DPLL3 bit instead of the PRM_RSTCTRL_GS bit. This matches what Linux does, and seems to fix resets on the TouchBook.
  s/board - Changed TouchBook audio to use the hands-free output instead of the predriver. This fixes speaker output (although it's currently listed as "line out" by the sound setup configure plugin)
  hdr/board, s/board, s/Video - Update the LCDConfig struct to contain an entry for controlling LCD power/brightness. Hook up basic power controls for current machine types.
Admin:
  Tested on rev C2 beagleboard & C1 touchbook.
  Video changes mean that OMAPVideo 0.08 or newer is required.


Version 0.34. Tagged as 'OMAP3-0_34'
@
text
@d1715 6
@


1.17
log
@BeagleBoard-xM, TouchBook fixes
Detail:
  s/board, hdr/board, hdr/omap3530, hdr/UART - Add support for 4th UART available on AM/DM37x (i.e. BeagleBoard-xM)
  hdr/omap3530 - Add details of CONTROL_IDCODE register & known hawkeye/revision numbers for OMAP type/revision detection
  s/Boot, s/GPIO, hdr/GPIO, s/I2C, hdr/StaticWS - Allow TPS LED drivers to be used as (output-only) GPIOs. Add new polled I/O I2C function, and appropriate logic to make GPIO code use it instead of RISCOS_IICOpV if RISC OS hasn't finished initialising yet. Add code to initialise some extra BB/TB GPIOs on boot.
  s/Timers, hdr/Timers - Stop RISC OS from using GPTIMER9, because it's used to drive the screen backlight on the TouchBook
  s/Video - Use appropriate porch/sync limits on non-OMAP35x
  s/PRCM - Don't mess with the system clock divider when calculating system clock speed (AM/DM37x fix)
Admin:
  Tested on rev C2 beagleboard, rev A2 BB-xM (indirectly), rev C1 TouchBook


Version 0.32. Tagged as 'OMAP3-0_32'
@
text
@d32 1
d55 3
a1685 1
; todo - allow DVI framer to be turned on/off independently of main power
a1697 5
        ; Now enable the DVI framer
        LDRB    a1, [sb, #BoardConfig_VideoGPIO]
        CMP     a1, #255
        MOV     a2, #1
        BLNE    GPIOx_SetOutput
d1709 32
@


1.16
log
@Update OMAP3 HAL to use correct instruction/memory barrier operations and to handle branch target predictors
Detail:
  hdr/Copro15ops - Added myISB, myDSB, myDMB macros to provide barrier functionality for ARMv6+
  s/Boot, s/Interrupts, s/RAM, s/Top, s/Video - updated to use correct barrier operations after CP15 writes, and to invalidate branch predictors where appropriate
Admin:
  Tested on rev C2 beagleboard


Version 0.28. Tagged as 'OMAP3-0_28'
@
text
@d381 1
a381 8
        ; Get the OMAP revision so we can find out how large the timing registers are. Errata shows that in ES 3.1+ the registers were increased from 8/6 bits to 12/8 bits.
        LDR     a1, L4_Wakeup_Log
        ADD     a1, a1, #(L4_CONTROL_IDCODE-L4_Wakeup) :AND: &FF00
        LDR     a1, [a1, #(L4_CONTROL_IDCODE-L4_Wakeup) :AND: &00FF]
        MOV     a1, a1, LSR #28 ; Get revision number
        CMP     a1, #3 ; > ES 3.0?
        MOVGT   a1, #1:SHL:12
        MOVLE   a1, #1:SHL:8
d383 1
a383 3
        MOVGT   a1, #1:SHL:8
        MOVLE   a1, #1:SHL:6
        STR     a1, video_maxsync
d1631 2
a1632 2
        ADRL    a1, VideoBoardConfig
        STR     a1, [v1, #HALDevice_VDUDeviceSpecificField]
d1636 4
a1639 13
        STR     a2, [a1, #VideoBoardConfig_sys_clk]
        ; Get the OMAP revision so we can find out how large the timing registers are. Errata shows that in ES 3.1+ the registers were increased from 8/6 bits to 12/8 bits.
        LDR     a2, L4_Wakeup_Log
        ADD     a2, a2, #(L4_CONTROL_IDCODE-L4_Wakeup) :AND: &FF00
        LDR     a2, [a2, #(L4_CONTROL_IDCODE-L4_Wakeup) :AND: &00FF]
        MOV     a2, a2, LSR #28 ; Get revision number
        CMP     a2, #3 ; > ES 3.0?
        MOVGT   a2, #1:SHL:12
        MOVLE   a2, #1:SHL:8
        STRH    a2, [a1, #VideoBoardConfig_Max_Porch]
        MOVGT   a2, #1:SHL:8
        MOVLE   a2, #1:SHL:6
        STRH    a2, [a1, #VideoBoardConfig_Max_Sync]
d1641 1
a1641 1
        STR     a2, [a1, #VideoBoardConfig_DMA_Ptr]
d1643 1
a1643 1
        STR     a2, [a1, #VideoBoardConfig_DMA_Device]
d1646 1
a1646 1
        STR     a2, [a1, #VideoBoardConfig_DMA_Chans]        
d1648 1
a1648 1
        STRB    a2, [a1, #VideoBoardConfig_Flags]
d1650 1
a1650 1
        STRB    a2, [a1, #VideoBoardConfig_Num_LCDs]
d1652 1
a1652 1
        STR     a2, [a1, #VideoBoardConfig_LCD_Configs]
d1713 26
@


1.15
log
@Add basic GPMC setup code and NIC HAL devices to OMAP HAL
Detail:
  s/GPMC, hdr/GPMC, hdr/StaticWS - basic code to reset the GPMC and configure chip selects
  s/NIC, hdr/NIC, hdr/StaticWS - code to expose any onboard NICs (SMSC9221, DM9000) to RISC OS as simple HAL devices.
  Makefile - added GPMC & NIC source files
  s/board, hdr/board - Expanded board config struct to include a pointer to extra code to call at the end of HAL_InitDevices, to allow board-specific devices to be initialised
  s/boot - Extra HAL_InitDevices code to set up the NICs on the IGEP/DevKit
  s/GPIO, hdr/GPIO - Improved functionality to allow GPIO IRQs to be used
  s/SDMA, s/Video - Tweaked the HAL device descriptors to indicate that the devices are on the L3 interconnect
Admin:
  Tested on rev C2 beagleboard. IGEP/DevKit entry points booted OK, but no attempts were made to look for or interact with the new HAL devices!


Version 0.24. Tagged as 'OMAP3-0_24'
@
text
@d482 1
a482 2
        MOV     a1, #0
        MCR     ARM_config_cp, 0, a1, C7, C10, 4
d736 1
a736 2
        MOV     a2, #0
        MCR     ARM_config_cp, 0, a2, C7, C10, 4
@


1.14
log
@Update OMAP3 HAL to support new OMAPVideo module, plus other minor changes
Detail:
  hdr/StaticWS, hdr/Video, hdr/board, hdr/omap3530, s/Boot, s/Video, s/board - Add new HALDoesVideo switch to control whether the HAL provides the video driver or whether a HAL device is used to expose the video hardware to the OMAPVideo module. Switch defaults to the 'off' state, i.e. OMAPVideo provides the video driver. Also updated the board config struct to contain more detailed information about the video capabilities of each board.
  s/Audio - fix the FIFO underflow/overflow IRQ handler to disable the IRQ after the underflow/overflow has been detection. This prevents the OS from (potentially) getting stuck in a loop servicing the interrupt and never reaching the state where it can shut down & re-initialise the audio to fix the error properly.
  s/Debug - add DebugCallstack function that disables IRQs/FIQs and dumps the stack contents over the serial port
Admin:
  Tested on rev C2 beagleboard.


Version 0.23. Tagged as 'OMAP3-0_23'
@
text
@d1681 1
a1681 1
        DCD     HALDeviceBus_Pro + HALDeviceProBus_Core ; Just claim it's part of the processor for now!
@


1.13
log
@Various OMAP3 HAL power management improvements, plus add support for board config autodetection via Linux machine ID
Detail:
  s/board, hdr/board - Add Linux machine ID & available mixer channels to board config table
  s/Top - Add new entry point at offset &64, for booting as a fake Linux kernel. Searches the board config table until it finds a config matching the machine ID passed in R1. Also minor ROM copy optimisation, unsigned pointer comparison fixes
  s/Audio, hdr/Audio - Use board config to lock-out mixer channels that aren't connected to any hardware, to avoid excessive power drain or other problems if the channels get turned on. Also perform many other setting tweaks to tidy up default settings for unused mixer paths/channels.
  s/Video - Fix Video_Init logic when deciding whether to reset DSS, enable DSI PLL drift guard
  s/I2C - Increase I2C timeout values, since the previous values were perhaps a bit low
  s/Audio, s/I2C, s/Interrupts, s/RAM, s/SDMA, s/Timers, s/UART, hdr/UART, s/USB, s/Video - Enable autoidle/smart idle where possible to help save power.
Admin:
  Tested on rev C2 beagleboard


Version 0.21. Tagged as 'OMAP3-0_21'
@
text
@a28 1
        GET     hdr.Video
d52 3
a54 1
        EXPORT  VideoDevice_Init
d86 1
d89 2
a90 1

d99 4
a102 2
; For the moment, limit the pixel rate to 75MHz. This allows us to generate 1280x1024 @@ 50Hz (86MHz was also tried, but resulted in signal breakup when dragging windows round the screen)
;MAX_PIXEL_RATE * 75000   -> gone to board config
d110 2
a369 1
        ; todo - set DMA burst sizes
d429 1
a429 1
        LDR     a2, [sb, #BoardConfig_MaxPixRate]
d1420 1
a1420 1
        LDR     a2, [sb, #BoardConfig_MaxPixRate]
d1590 37
a1626 130
venc_setmode
       ; Change VENC mode
       ; a1 = mode:
       ;  -1 = off
       ;   0 = NTSC 601, composite
       ;   1 = NTSC 601, s-video
       ;   2 = PAL 601, composite
       ;   3 = PAL 601, s-video
       CMP      a1, #-1
       CMPNE    a1, #3
       MOVHI    pc, lr
       Push     "v1,lr"
       LDR      v1, L4_Display_Log
       ; todo - enable clocks & stuff.
       ; First we reset VENC
       LDR      a2, =VENC_F_CONTROL
       LDR      a3, [v1, a2]
       ORR      a3, a3, #1:SHL:8 ; SOFTRESET
       STR      a3, [v1, a2]
       ; Wait for reset
10
       LDR      a3, [v1, a2]
       TST      a3, #1:SHL:8
       BNE      %BT10
       ; If we were turning it off, we're done
       CMP      a1, #0
       MOVEQ    pc, lr
       ; Else we need to program the right registers
       TST      a1, #2
       MOVEQ    a2, #0 ; NTSC offset
       MOVNE    a2, #4 ; PAL offset
       ADR      a3, venc_settings
10
       LDR      a4, [a3], #4
       CMP      a4, #0
       BLT      %FT20
       LDR      ip, [a3, a2]
       STR      ip, [v1, a4]
       ADD      a3, a3, #8
       B        %BT10
20
       ; Composite/s-video
       TST      a1, #1
       MOVEQ    ip, #&A ; Composite
       MOVNE    ip, #&D ; S-video
       LDR      a4, =VENC_OUTPUT_CONTROL
       STR      ip, [v1, a4]
       ; And in DSS
       LDR      ip, [v1, #DSS_CONTROL]
       BICEQ    ip, ip, #1:SHL:6 ; Composite
       ORRNE    ip, ip, #1:SHL:6 ; S-video
       ; Other bits from u-boot: DAC_POWERDN_BGZ, DAC_DEMEN, VENC4x2
       ORR      ip, ip, #&38
       STR      ip, [v1, #DSS_CONTROL]
       ; Program remaining regs from the table
10
       LDR      a4, [a3], #4
       CMP      a4, #0
       BLT      %FT20
       LDR      ip, [a3, a2]
       STR      ip, [v1, a4]
       ADD      a3, a3, #8
       B        %BT10
20
       ; Set GODIGITAL, DIGITALENABLE
       LDR      a1, [v1, #DISPC_CONTROL]
       ORR      a1, a1, #&42
       STR      a1, [v1, #DISPC_CONTROL]
       ; Wait for vsync
       ; Except we're too lazy to do it properly
       MOV      a1, #50*1024 ; 50msec ish
       BL       HAL_CounterDelay
       ; Clear SYNCLOSTDIGITAL
       LDR      a1, [v1, #DISPC_IRQSTATUS]
       ORR      a1, a1, #1:SHL:15
       STR      a1, [v1, #DISPC_IRQSTATUS]
       ; Done!
       Pull     "v1,pc"
           
       
venc_settings
; VENC settings table
; Taken from OMAP3530 TRM (spruf98b, table 15-64)
; Format:
;           register                               NTSC 601    PAL 601
        DCD VENC_VIDOUT_CTRL,                      &00000001, &00000001
        DCD VENC_LLEN,                             &00000359, &0000035F
        DCD VENC_FLENS,                            &0000020C, &00000270
        DCD VENC_HFLTR_CTRL,                       &00000000, &00000000
        DCD VENC_CC_CARR_WSS_CARR,                 &043F2631, &2F7225ED
        DCD VENC_C_PHASE,                          &00000000, &00000000
        DCD VENC_GAIN_U,                           &00000102, &00000111
        DCD VENC_GAIN_V,                           &0000016C, &00000181
        DCD VENC_GAIN_Y,                           &0000012F, &00000140
        DCD VENC_BLACK_LEVEL,                      &00000043, &0000003B
        DCD VENC_BLANK_LEVEL,                      &00000043, &0000003B
        DCD VENC_X_COLOR,                          &00000007, &00000007
        DCD VENC_M_CONTROL,                        &00000001, &00000002
        DCD VENC_BSTAMP_WSS_DATA,                  &00000038, &0000003F
        DCD VENC_S_CARR,                           &21F07C1F, &2A098ACB
        DCD VENC_LINE21,                           &00000000, &00000000
        DCD VENC_LN_SEL,                           &01310011, &01290015
        DCD VENC_L21_WC_CTL,                       &0000F003, &0000F603
        DCD VENC_HTRIGGER_VTRIGGER,                &00000000, &00000000
        DCD VENC_SAVID_EAVID,                      &069300F4, &06A70108
        DCD VENC_FLEN_FAL,                         &0016020C, &00180270
        DCD VENC_LAL_PHASE_RESET,                  &00060107, &00040135
        DCD VENC_HS_INT_START_STOP_X,              &008E0350, &00880358
        DCD VENC_HS_EXT_START_STOP_X,              &000F0359, &000F035F
        DCD VENC_VS_INT_START_X,                   &01A00000, &01A70000
        DCD VENC_VS_INT_STOP_X_VS_INT_START_Y,     &020701A0, &000001A7
        DCD VENC_VS_INT_STOP_Y_VS_EXT_START_X,     &01AC0024, &01AF0000
        DCD VENC_VS_EXT_STOP_X_VS_EXT_START_Y,     &020D01AC, &000101AF
        DCD VENC_VS_EXT_STOP_Y,                    &00000006, &00000025
        DCD VENC_AVID_START_STOP_X,                &03480078, &03530083
        DCD VENC_AVID_START_STOP_Y,                &02060024, &026C002E
        DCD VENC_FID_INT_START_X_FID_INT_START_Y,  &0001008A, &0001008A
        DCD VENC_FID_INT_OFFSET_Y_FID_EXT_START_X, &01CA0106, &002E0138
        DCD VENC_FID_EXT_START_Y_FID_EXT_OFFSET_Y, &01060006, &01380001
        DCD VENC_TVDETGP_INT_START_STOP_X,         &00140001, &00140001
        DCD VENC_TVDETGP_INT_START_STOP_Y,         &00010001, &00010001
        DCD VENC_GEN_CTRL,                         &00F90000, &00FF0000
        DCD VENC_OUTPUT_TEST,                      &00000000, &00000000
        ; Fix display resolution - how does this affect the other regs? (SIZE_LCD, etc.) Do we need to set up scaling stuff?
        DCD DISPC_SIZE_DIG,                        &00F002CF, &00F002CF
        DCD -1 ; Break to program other registers
        ; These two must be last, apparently
        DCD VENC_F_CONTROL,                        &00000000, &00000000
        DCD VENC_SYNC_CTRL,                        &00008040, &00000040
        DCD -1
d1628 3
d1638 1
a1638 1
        MOV     a3, #HALDevice_VDU_Size
d1642 31
a1672 2
        LDR     a1, L4_sDMA_Log
        STR     a1, [v1, #HALDevice_VDUAddress2]
d1693 4
a1696 5
        DCD     SDMA_IRQ_1 ; Secondary device
        DCD     0          ; Secondary address - filled in later
        ASSERT SDMA_NumDevices = 31
        DCD     &80000000  ; Mask of available DMA channels
        ASSERT (.-VideoDeviceTemplate) = HALDevice_VDU_Size        
d1702 1
a1702 1
; todo - it makes sense for these to do board-specific stuff like enabling the DVI framer
d1704 16
d1721 1
a1721 1
        MOV     pc, lr
d1723 1
a1723 1
VideoDevice_Deactivate
d1731 2
@


1.12
log
@Update OMAP HAL to support different board configs, plus use new YearLOIsGood flag to ensure correct RTC handling, plus other misc tidying
Detail:
  The OMAP HAL now has multiple entry points, one per board config. See Top.s/board.s for more info.
  audio.s - Moved APLL_CTL value to board config
  board.s - New file to list all the settings for the different board configs
  boot.s - Change HAL_Init to deal with the new board config stuff
  debug.s - Debug UART now specified in board config
  GPIO.s - A few utility functions for handling OMAP/TPS GPIO pins
  I2C.s - Update to use new board config struct
  RAM.s - Disable the beagleboard-specific RAM init code. Instead we'll just rely on u-boot to initialise all our RAM for us.
  RTC.s - Get rid of the magic numbers, and use the YearLOIsGood flag to indicate to RISC OS that YearLO is 2-digit BCD
  Top.s - Got rid of old debug code and rewrote initial flow to handle detecting & storing the board config
  UART.s - Update to use board config struct, support multiple UARTs
  USB.s - Get EHCI PHY power GPIO from board config
  Video.s - Get DVI framer power GPIO and max pixel rate from board config. Add 'PassiveVideo' option, to build a driver that doesn't alter the video output settings - should hopefully result in a usable display on Touch Book, etc.
  board.hdr - Definition of board config table struct
  GPIO.hdr - Add lots of macros for handling OMAP GPIO pins, new constants for OMAP/TPS GPIO
  I2C.hdr - Added I2C transfer block struct, HAL I2C API transfer states (both moved here from other source files)
  omap3530.hdr - Move/remove some unwanted constants, disable DebugChar for now
  StaticWS.hdr - Move I2C transfer block struct to I2C.hdr, add board config struct to HAL workspace, get rid of unused 64K AllocArea
  Timers.hdr - Tidy up constants a bit
  UART.hdr - Add UARTCLK (moved from StaticWS.hdr), UART IRQ #'s
  Makefile - add GPIO.s
Admin:
  Tested on rev C2 beagleboard. Board configs for other board types may be inaccurate in a couple of places.


Version 0.19. Tagged as 'OMAP3-0_19'
@
text
@d290 1
a290 1
        BEQ     %FT10 ; Skip init
d581 1
a581 1
        ORR     a2, a2, #1:SHL:13 ; Enable reference clock
d628 1
a628 1
        BIC     a2, a2, #&3F:SHL:5 ; DSI_PLL_PLLLPMODE, LOWCURRSTBY, TIGHTPHASELOCK, DRIFTGUARDEN, LOCKSEL = 0
@


1.11
log
@Add sound support to OMAP3 HAL, plus other changes
Detail:
  hdr/Audio, s/Audio, Makefile, hdr/StaticWS, s/Boot - Add sound support to OMAP3 HAL. Should work with a TPS65950 connected to I2C1/McBSP2, as per beagleboard.
  s/TPS, s/RTC - Moved TPSRead, TPSWrite functions out of s/RTC and into their own file
  hdr/SDMA, s/SDMA - Add support for packet-based transfer (for audio), improve debug code, remove TestRAMToRAM test code
  s/I2C - Update to handle spurious RDR interrupts as mentioned in OMAP3 errata
  s/Video - Enable support for the larger porch & sync timing registers found in OMAP3 ES3.1 and above
Admin:
  Tested on rev C2 beagleboard


Version 0.18. Tagged as 'OMAP3-0_18'
@
text
@d63 2
d89 1
a89 3
TFP410_GPIO * 170
TFP410_Ptr  * L4_GPIO_Table+4*(TFP410_GPIO>>5)
TFP410_Pin  * 1 :SHL: (TFP410_GPIO :AND: 31)
d94 1
a94 1
; - Beagleboard ref. manual says 65MHz (TFP410 limitation?)
d97 1
a97 1
MAX_PIXEL_RATE * 75000
d129 4
d272 1
d332 11
a342 6
        LDR     a3, TFP410_Ptr
        LDR     a1, [a3, #GPIO_OE]
        MOV     a2, #TFP410_Pin
        BIC     a1, a1, a2
        STR     a1, [a3, #GPIO_OE] ; Set to output
        STR     a2, [a3, #GPIO_CLEARDATAOUT] ; Turn it off
d412 1
d423 1
a423 1
        LDR     a2, =MAX_PIXEL_RATE
d426 1
a426 1
        DebugTX "HAL_Video_SetMode: Pixel rate too high (>65MHz)"
d470 1
a470 1
        
d472 1
a472 2
        LDR     a1, [v1, #DISPC_IRQENABLE]
        MOV     a1, #2
d646 1
d725 46
d794 1
d796 4
a808 1
        LDR     a1, [v1, #DISPC_IRQENABLE]
d811 1
d813 5
a817 3
        LDR     v2, TFP410_Ptr
        MOV     a1, #TFP410_Pin
        STR     a1, [v2, #GPIO_SETDATAOUT]
d954 2
d1359 1
d1414 1
a1414 1
        LDR     a2, =MAX_PIXEL_RATE
d1483 1
@


1.10
log
@Fix undefined instruction abort when booting OMAP HAL
Detail:
  I guess I didn't test this after all.
Admin:
  Tested on rev C2 beagleboard. (No, really, I mean it this time!)


Version 0.17. Tagged as 'OMAP3-0_17'
@
text
@d365 8
a372 15
        ; Get the OMAP revision so we can find out how large the timing registers are
;        LDR     a1, L4_Wakeup_Log
;        ADD     a1, a1, #(L4_CONTROL_IDCODE-L4_Wakeup) :AND: &FF00
;        LDR     a1, [a1, #(L4_CONTROL_IDCODE-L4_Wakeup) :AND: &00FF]
;        DebugReg a1
;        MOV     a1, a1, LSR #28 ; Get revision number
;        CMP     a1, #3
;        MOVGT   a1, #1:SHL:12
;        MOVLE   a1, #1:SHL:8
;        STR     a1, video_maxporch
;        MOVGT   a1, #1:SHL:8
;        MOVLE   a1, #1:SHL:6
;        STR     a1, video_maxsync
        ; Limit to the safe values for now until we can be certain what revision the timing registers have been fixed in
        MOV     a1, #1:SHL:8
d374 2
a375 1
        MOV     a1, #1:SHL:6
@


1.9
log
@OMAP3 DMA support, video device, debugging improvements
Detail:
  Boot.s - Make FIQDebug work again
  Boot.s - Add support for DMA & video devices
  Interrupts.s, hdr/omap3530 - Add 'ExtraDebugInterrupts' option
  hdr/SDMA, SDMA.s, Makefile - DMA code which presents itself to RISC OS as a set of single-buffered, interrupt-driven DMA channels.
  hdr/StaticWS - Add extra DMA, video & debug entries to workspace
  Interrupts.s - Add 'DebugDisablePrevious' debug option for more flexibility in tracking down noncleared IRQs with ExtraDebugInterrupts
  RAM.s - Use DMA to clear RAM on boot. RAM clear now takes less than 1 second on a rev C board, whereas before it used to take several.
  Video.s - Add simple HAL device to expose information needed by upcoming RISC OS module based video driver.
Admin:
  Tested on rev C2 beagleboard.


Version 0.16. Tagged as 'OMAP3-0_16'
@
text
@d1669 1
@


1.8
log
@OMAP3 HAL video tweaks & improvements
Detail:
  hdr/StaticWS - Add entries for max porch & sync values, in anticipation of future OMAP revisions increasing the limits from 8/6 bits to 12/8 bits.
  hdr/omap3530 - Add entry for CONTROL_IDCODE register for reading silicon revision
  s/Video - Increase max pixel rate from 65MHz to 75MHz (86.5MHz seems unstable). Add support for different max porch/sync values depending on hardware revision (currently disabled). Make mode change code more robust to try and fix corruption seen when changing mode too many times. Improve HAL_Video_VetMode to check for (HFP+HSW+HBP)*PCD > 8 limitation. Add a bit more debug code.
Admin:
  Tested on rev C2 beagleboard.


Version 0.10. Tagged as 'OMAP3-0_10'
@
text
@d53 2
d62 8
d1653 55
@


1.7
log
@Fix OMAP3 HAL_Video_UpdatePointer to correctly handle images which aren't 32 pixels wide
Detail:
  s/Video - Rewritten pointer image update code to correctly read data from RISC OS's 32 pixel wide cursor buffer.
Admin:
  Tested on rev C2 beagleboard. Hourglass now appears properly!


Version 0.09. Tagged as 'OMAP3-0_09'
@
text
@d32 1
d81 7
a87 2
; Max pixel rate: Beagleboard ref. manual says 65MHz (TFP limitation?)
MAX_PIXEL_RATE * 65000 ; In KHz
d116 3
a343 3
        ; Enable Vsync IRQ
        MOV     a2, #2
        STR     a2, [v1, #DISPC_IRQENABLE]
d355 18
d455 9
d472 8
a479 2
        ; First we turn off the DVI framer
        ; todo - do we need to do this? No other code turns it on/off when changing config settings, AFAIK
d645 1
d648 2
a649 2
        CMP     a2, #63
        MOVGT   a2, #63
d651 1
d654 2
a655 2
        CMP     a3, #255
        MOVGT   a3, #255
d660 2
a661 2
        CMP     a3, #255
        MOVGT   a3, #255
d666 1
d669 2
a670 2
        CMP     a2, #63
        MOVGT   a2, #63
d672 1
d675 2
a676 2
        CMP     a3, #255
        MOVGT   a3, #255
d681 2
a682 2
        CMP     a3, #255
        MOVGT   a3, #255
d735 11
d1289 52
d1367 1
d1369 5
a1373 1
        CMP     a2, #64
d1376 1
d1378 1
a1378 1
        CMP     a2, #256
d1382 1
a1382 5
        CMP     a2, #256
        MOVHS   pc,lr
        LDR     a2, [a1, #VIDCList3_VertiSyncWidth]
        SUB     a2, a2, #1
        CMP     a2, #64
d1386 1
a1386 1
        CMP     a2, #256
d1390 1
a1390 1
        CMP     a2, #256
d1392 8
a1399 2
        ; todo - check (HBP+HSW+HFP)*PCD > 8 (and any other stuff listed in manual)
        ; todo - also allow for PCD > 2 (and LCD > 1?) to allow for modes with tighter timings (just try different REGM3, PCD, LCD values until DSI1_PLL_FCLK<173MHz and pixel rate is correct? if increasing from 1, won't take many iterations for either until output is < pixel rate and another combo can be tried) 
@


1.6
log
@OMAP3 HAL USB (EHCI) support, interrupt handling fixes
Detail:
  Makefile - added USB to objects list
  s/Boot, s/USB, hdr/StaticWS, hdr/USB - USB EHCI code
  s/Debug, s/Stubs, s/Timers, s/Top, s/UART, s/Video - Debugging tweaks and header dependency fixes
  s/Interrupts, hdr/omap3530 - Interrupt fixes & debugging code
  hdr/PRCM - typo fix
Admin:
  Tested on rev C2 beagleboard


Version 0.08. Tagged as 'OMAP3-0_08'
@
text
@d978 1
a978 1
        MOV      v3, #0 ; Current x
d982 12
a993 4
        CMP      v3,v1 ; Transparent pixels on RHS
        CMPLT    v4,v2 ; Transparent pixels on bottom
        LDRLTB   v5, [a4,v3,LSR #2]
        MOVGE    v5, #0
d996 4
a999 16
        STR      ip, [lr],#4
        AND      ip, v5, #&C
        LDR      ip, [a1, ip]
        STR      ip, [lr],#4
        AND      ip, v5, #&30
        LDR      ip, [a1, ip, LSR #2]
        STR      ip, [lr],#4
        AND      ip, v5, #&C0
        LDR      ip, [a1, ip, LSR #4]
        STR      ip, [lr],#4
        ADD      v3,v3,#4
        CMP      v3,#HW_CURSOR_WIDTH
        BLT      %BT5
        ; Point to next row
        ADD      a4,a4,v1,LSR #2
        MOV      v3,#0
d1004 1
a1004 1
        STR      v3, cursor_update ; Clear update flag
@


1.5
log
@OMAP3 HAL video support, safer RAM initialisation
Detail:
  Makefile - Enable compilation of s.video
  hdr/StaticWS - New workspace entries for video support
  hdr/Video - Typo fix, VENC registers
  s/Boot - Change initialisation order for video support
  s/Debug - Added DebugMemDump routine
  s/RAM - Added code to verify RAM config, to avoid crash if a board looks like a revision C but doesn't have the extra RAM
  s/Stubs - Disable stub video functions
  s/Video - Working video code, beginnings of TV-out code
Admin:
  Tested on rev C2 beagleboard. Video code may only function correctly if kernel is loaded via u-boot.


Version 0.06. Tagged as 'OMAP3-0_06'
@
text
@d27 1
a27 4
        EXPORT  HAL_Video_PixelFormats
        EXPORT  HAL_Video_Features
        EXPORT  HAL_Video_BufferAlignment
        EXPORT  HAL_Video_OutputFormat
a28 1
        GET     hdr.omap3530
d47 4
@


1.4
log
@OMAP3 HAL Beagleboard Rev C support, further video work.
Detail:
  s/Boot - Fixes for rev C beagleboard. Added GPIO code.
  s/Debug - DebugHALPrint, DebugHALPrintReg routines
  s/PRCM - PRCM_GetFreqSel added
  s/RAM - Fixes for rev C beagleboard. Sped up RAM clear by using more regs.
  s/Top - Fixes for rev C beagleboard
  s/Video - Video code potentially complete, but full of bugs and so still disabled.
  hdr/GPIO - Added GPIO registers
  hdr/omap3530 - Fixes for rev C beagleboard, GPIO, debug macros, QEMU support for new video code
  hdr/SDRC - Typo fix
  hdr/StaticWS - GPIO, pixel rate entries added
  hdr/Video - DSI PLL registers added
Admin:
  Tested on rev C beagleboard.


Version 0.04. Tagged as 'OMAP3-0_04'
@
text
@d57 2
d96 151
d248 59
d314 2
a315 19
        ; Enable clocks
        LDR     a1, L4_ClockMan_Log
        SetRegBits CM_ICLKEN_DSS,1 ; EN_DSS (correct to enable iclk before fclk?)
        SetRegBits CM_FCLKEN_DSS,7 ; EN_DSS1, EN_DSS2, EN_TV (required for reset)
        ; Perform DSS reset
        LDR     a1, L4_Display_Log
        SetRegBits DSS_SYSCONFIG,2 ; SOFTRESET
        ; Wait for completion
10
        LDR     a2, [a1, #DSS_SYSSTATUS]
        TST     a2, #1
        BEQ     %BT10
        ; Disable smart idle mode to avoid any power management shenanigans
        ; These values are mostly taken from u-boot
        LDR     a2, =&2015 ; AUTOIDLE, ENWAKEUP, SIDLEMODE=2, MIDLEMODE=2 (smart idle modes)
        STR     a2, [a1, #DISPC_SYSCONFIG]
        SetRegBits DISPC_CONFIG,1:SHL:9 ; Gate functional clocks
        ; Configure FIFO thresholds. these don't match u-boot, but they do match some linux code, so I'll stich with this for now.
        LDR     a3, [a1, #DISPC_GFX_FIFO_SIZE_STATUS]
d319 2
a320 2
        STR     a3, [a1, #DISPC_GFX_FIFO_THRESHOLD]
        ADD     a4, a1, #DISPC_VID1:AND:&FF
d327 1
a327 1
        ADD     a4, a1, #DISPC_VID2:AND:&FF
d337 1
a337 1
        STR     a2, [a1, #DISPC_IRQENABLE]
d346 1
a346 1
        MVN     a1, #0 ; Pixel rate isn't set yet
d348 2
a349 1
        MOV     pc, lr
d369 3
d377 7
d436 3
d451 15
a465 3
        ; Let's follow dsi_pll_init(), even though I suspect some of it isn't needed for RFBI bypass
        ; - dispc_set_lcd_divisor(1,2) - matches reset value & our value
        ; - dsipc_pck_free_enable(1) - doesn't come out of reset without this?
d470 4
a473 1
        ; - wait_for_bit_up(DSI_PLL_STATUS,0)
d478 5
a482 1
        ; - dsi_pll_power(DSI_PLL_POWER_ON_HSCLK)
d484 1
a484 2
        BIC     a1, a1, #3:SHL:30
        ORR     a1, a1, #1:SHL:30 ; PLL on, HSDIVIDER off (to ensure we can program new value but our shenanigans won't break any reliant modules?)
d486 3
d492 1
a492 1
        CMP     a1, #1:SHL:28
d494 8
a501 2
        
        ; - dsi_pll_config(DSI_BPP,DSI_LANES) - what we do here:
d521 1
d527 1
a527 1
        ORR     a2, a2, v4, LSL #1 ; FREQSEL
d536 3
d543 4
d550 22
a571 1
        BEQ     %BT10
d575 1
a575 1
        BIC     a2, a2, #&3F:SHL:5 ; DSI_PLL_PLLLPMODE, LOPCURRSTBY, TIGHTPHASELOCK, DRIFTGUARDEN, LOCKSEL = 0
d589 5
a593 1
        STR     a1, [v1, #DISPC_CONFIG]        
d600 3
d686 3
d697 9
d750 2
d756 1
a756 1
        MOV     a2, a2, ROR #8
d810 2
d823 4
a826 3
        LDR     a3, [a2], #4
        MOV     a3, a3, ROR #8
        STR     a3, [a1], #4
d937 1
a937 1
        Push     "v1-v6,lr"
d945 6
d952 15
d968 1
a968 1
        LDRB     v1, [a4],#4 ; width
d975 2
a976 3
        ADD      v2, v2, #3
        BIC      v2, v2, #3 ; Byte aligned width
        LDR      v6, cursor_image
d980 1
d984 1
a984 1
        LDRLTB   v5, [a4],#1
d988 1
a988 1
        STR      ip, [v6],#4
d991 1
a991 1
        STR      ip, [v6],#4
d994 1
a994 1
        STR      ip, [v6],#4
d997 1
a997 1
        STR      ip, [v6],#4
d1001 1
a1001 2
        ; Skip any remaining pixels on this row if the source was too wide
        SUB      a4,a4,v3,LSR #2
d1026 13
d1046 1
a1046 2
        LDR     a4, L4_Display_Log
        ADD     a4, a4, #DISPC_VID2:AND:&FF
d1048 2
d1051 2
d1055 2
d1058 6
d1067 2
d1070 2
d1073 6
a1078 6
        MOV     a1, v3, LSL #2 ; Width in bytes
        RSB     a1, a1, #HW_CURSOR_WIDTH ; ROW_INC in bytes
        STR     a1, [a4, #DISPC_VIDn_ROW_INC]
        LDR     a1, =2_0100000000000000000011011 ; high priority pipeline, RGBA 32, enabled
        STR     a1, [a4, #DISPC_VIDn_ATTRIBUTES]                
        Pull     "v1-v6,pc"
d1081 2
a1082 2
        LDR     a1, L4_Display_Log
        ADD     a1, a1, #DISPC_VID2:AND:&FF
d1084 4
a1087 1
        MOV     a2, #1
d1089 21
a1109 1
        Pull     "v1-v6,pc"
d1145 1
d1149 7
d1171 1
a1171 1
        MOV     a1, #2_011   ; hw scroll, h/w pointer, no interlace
d1402 131
@


1.3
log
@OMAP3 HAL fixes and further video work
Detail:
  s/Boot - Store some workspace vars used by video code. Disable some debug output.
  s/Interrupts - Update HAL_IRQClear to allow clearing of VSync IRQ
  s/Top - Fix CP15 flags
  s/Video - Implemented majority of video code needed by kernel. Correct code for calculating and programming pixel clocks still required, so code remains disabled by default.
  hdr/PRCM - Correct typo
  hdr/StaticWS - Add video-related workspace entries
  hdr/Video - Add constants for mouse pointer image buffer size
Admin:
  Tested under qemu-omap3 and rev B6 beagleboard.


Version 0.03. Tagged as 'OMAP3-0_03'
@
text
@d35 1
d54 26
d82 3
a84 21
; sys_xtalin -> PRCM.PRCM_CLKSRC_CTRL -> OSC_SYS_CLK -> divider (1,2) -> SYS_CLK -> DPLL4_ALWON_FCLK (=13MHz?)
; CLKOUTX2 = (Fref*2*M)/(N+1) (M 11 bit, N 7 bit): PRCM.CM_CLKSEL2_PLL
; CLKOUT = CLKOUTX2/2
; CLKOUT_M4X2 = CLKOUTX2/M4 (M4 1-16): PRCM.CM_CLKSEL_DSS
; DSS1_ALWON_FCLK = CLKOUT_M4X2?
; Also need to set correct jitter value (PRCM.CM_CLKEN_DSS) - but set to what? 12.5-15MHz?
; u-boot detects the clock speed itself by comparing against 32khz timer
; - do we need to do this ourselves?
; - probably a good idea to do full clock init, especially if we don't want to make any assumptions about boot state
; - also, looks like the OMAP supports booting from flash - so need to take appropriate precautions (copying clock change code into OCM), plus making sure HAL is ROM-friendly!
; Max pixel rate 75MHz
; - Only 67MHz for MIPI DSI?
; DSS1_ALWON_FCLK: Max 173MHz
; DSS2_ALWON_FCLK: SYS_CLK
; DSI1_PLL_FCLK: Max 173MHz
; DSI2_PLL_FCLK: Max 173MHz
; DSS_TV_FCLK: 54MHz or sys_alt_clk (up to 59MHz)
; DSI_PLL_REFCLK = DSS2_ALWON_FCLK
; DSI_FCLK = DSS1_ALWON_FCLK. Must be > byte clock(?), L4 interface clock, video port clock
; (HBP+HSW+HFP)*PCD > 8
; Need to program according to page 2257!
d95 7
d104 2
a105 5
        SetRegBits CM_FCLKEN_DSS,7 ; EN_DSS1, EN_DSS2, EN_TV (required?)
        SetRegBits CM_ICLKEN_DSS,1 ; EN_DSS
        ; todo - program CM_CLKEN_PLL here? (to enable DPLL4, ensure clocks are powered up, etc.)
        LDR     a2, =&1001 ; DPLL4 M3 = 16 (TV divisor), DPLL4 M4 = 1 (main divisor)
        STR     a2, [a1, #CM_CLKSEL_DSS]
d110 1
a110 1
Video_init_loop
d113 27
a139 7
        BEQ     Video_init_loop
        ; Poke a few config registers - mostly copied from u-boot
        MOV     a2, #&79
        STR     a2, [a1, #DSS_CONTROL]
        MOV     a2, #&15
        ORR     a2, a2, #&2000
        STR     a2, [a1, #DISPC_SYSCONFIG] ; Smart idle config
d142 1
a142 1
        STR     a2, [a1, #DISPC_IRQENABLE] 
d149 1
a149 1
        ADD     a1, a1, #HW_CURSOR_WIDTH*HW_CURSOR_HEIGHT
d151 2
d174 1
a174 1
        LDR     a4, L4_Display_Log
d177 3
a179 2
        LDR     a2, [a1, #VIDCList3_PixelRate] ; Desired pixel rate, kHz
        CMP     a2, #75000
d181 1
a181 1
        DebugTX "HAL_Video_SetMode: Pixel rate too high (>75MHz)"
d184 11
a194 1
        MOV     a3, #1000
d196 1
a196 1
        MUL     a1,a3,a2 ; Pixel rate, Hz
d198 2
a199 2
        CMP     a1, #128
        CMPLO   a2, #2048
d202 20
d224 1
a224 11
        ORR     v2, a1, a2, LSL #8
        Pull    "a1"
        LDR     v3, L4_PowerMan_Log
        LDR     v4, =CM_CLKSEL2_PLL
        ; Do CM_CLKSEL2_PLL or DISPC_DIVISOR actually need changing? If not, we can skip the complicated update procedure
        LDR     a2, [v3, v4]
        CMP     a2, v2
        LDR     v1, =&10002 ; default value is all we need
        LDR     a2, [a4, #DISPC_DIVISOR]
        CMPEQ   a2,v1
        BEQ     %FT10
d226 73
a298 2
        STR     v2, [v3, v4]
        STR     v1, [a4, #DISPC_DIVISOR]
d300 32
a331 3
        ; Now we can program DISPC_DIVISOR
        ; Default values should do - CM_CLKSEL2_PLL does all the work
        LDR     v1, =&10002
d350 1
a350 1
        STR     a2, [a4, #DISPC_TIMING_H]
d369 1
a369 1
        STR     a2, [a4, #DISPC_TIMING_V]
d377 1
a377 1
        STR     a2, [a4, #DISPC_POL_FREQ]
d392 3
a394 3
        STR     a2, [a4, #DISPC_SIZE_DIG]
        STR     a2, [a4, #DISPC_SIZE_LCD]
        STR     a2, [a4, #DISPC_GFX_SIZE]
d399 1
a399 1
        STR     a2, [a4, #DISPC_GFX_ATTRIBUTES]
d401 1
a401 2
        MOV     v1, a4
        Push    "a1,a4"
d405 1
a405 1
        Pull    "a1,a4"
d409 1
a409 1
        STR     a2, [a4, #DISPC_CPR_COEF_R]
d411 1
a411 1
        STR     a2, [a4, #DISPC_CPR_COEF_G]
d413 1
a413 1
        STR     a2, [a4, #DISPC_CPR_COEF_B]
d415 6
a420 2
        LDR     a2, =&1836b ; Same value as u-boot: GPOUT0, GPOUT1 reset, 24-bit TFT data lines, GODIGITAL, GOLCD, active matrix display, DIGITALENABLE, LCDENABLE
        STR     a2, [a4, #DISPC_CONTROL]
d532 1
a532 1
        ADR     a1, cursor_palete
d725 4
a728 2
        STR     a1, [a4, #DISPC_VID2_BA0]
        STR     a1, [a4, #DISPC_VID2_BA1]
d730 1
a730 1
        STR     a1, [a4, #DISPC_VID2_POSITION]
d734 2
a735 2
        STR     a1, [a4, #DISPC_VID2_SIZE]
        STR     a1, [a4, #DISPC_VID2_PICTURE_SIZE] ; Required?
d738 1
a738 1
        STR     a1, [a4, #DISPC_VID2_ROW_INC]
d740 1
a740 1
        STR     a1, [a4, #DISPC_VID2_ATTRIBUTES]                
d745 2
d748 1
a748 1
        STR     a2, [a1, #DISPC_VID2_ATTRIBUTES]
d872 3
a874 2
        LDR     a2, [a1, #VIDCList3_PixelRate]
        CMP     a2, #75000
d876 1
a876 1
        CMP     a2,#0
d878 1
a878 1
        MOV     a3,#1000
d882 10
a891 2
        CMP     a1, #128
        CMPLO   a2, #2048
d893 1
a893 1
        MOVHS   pc,lr
d921 1
d940 4
a943 4
; Function for calculating DSS clock dividers
; in:  a1 = pixel rate (Hz)
; out: a1 = CM_CLKSEL2_PLL.M (values not guaranteed to be in range)
;      a2 = CM_CLKSEL2_PLL.N
d945 23
d970 1
a970 1
        MOVEQ   a2, #0
d972 13
a984 32
        Push    "a3-v4,lr"
        ; First we calculate the GCD of the pixel rate and sys_clk
        ; ARM GCD algorithm from Wikipedia - http://en.wikipedia.org/wiki/Binary_GCD_algorithm
        MOV     v1, a1 ; pixel rate
        LDR     v2, sys_clk ; source clock
        SUBS    v4, v1, v1
        ORRS    v3, v1, v2
gcd_remove_twos_loop
        MOVNES  v3, v3, LSR #1
        ADDCC   v4, v4, #1
        BCC     gcd_remove_twos_loop
        MOVS    v1, v1, LSR v3
        MOVNES  v2, v2, LSR v3
        BEQ     gcd_finish
gcd_check_two_v1
        MOVS    v1, v1, LSR #1
        BCC     gcd_check_two_v1
gcd_check_two_v2
        MOVS    v2, v2, LSR #1
        BCC     gcd_check_two_v2
        SUBS    v2, v2, v1
        RSBCC   v2, v2, #0
        SUBCC   v1, v1, v2
        BNE     gcd_check_two_v1
        ADC     v1, v1, v1
gcd_finish
        ORR     v1, v2, v1, LSL v4 ; v1 = gcd
        ; Now divide pixel rate & sys_clk by v1 to get M and N values for PRCM.CM_CLKSEL2_PLL
        MOV     a1, a2
        MOV     a2, v1
        BL      |__rt_udiv|
        MOV     v2, a1 ; M = pixel rate/gcd
d986 2
a987 3
        MOV     a2, v1
        BL      |__rt_udiv|
        SUB     a2, a1, #1 ; N = (sys_clk/gcd)-1
d989 44
a1032 1
        Pull    "a3-v4,pc"        
@


1.2
log
@  OMAP3 HAL fixes and updates to allow booting on real hardware.
Detail:
  Makefile - add s.PRCM to objects
  s/Boot - Call PRCM_SetClocks during HAL_Init. Added (disabled) debugging code.
  s/Interrupts - Updated HAL_IRQSource, HAL_FIQSource to query ARM interrupt state instead of relying on INTC alone to detect whether an interrupt is firing or not.
  s/PRCM - Code to measure system clock frequency, store it for HAL purposes, and notify the OMAP of the frequency in order to ensure correct operation.
  s/Timers - Use measured system clock frequency as the timer frequency instead of hard-coded value. Return correct values from HAL_TimerPeriod.
  s/Top - Added (disabled) debugging code. Updated ARM initialisation to use correct cache cleaning procedure.
  s/Video - Further minor work towards completing video driver.
  hdr/CoPro15ops - Deprecate ARM_flush_* macros
  hdr/PRCM - Add more register addresses
  hdr/StaticWS - Add entried for PowerMan & 32K timer logical addresses, system clock speed
  hdr/Timers - remove incorrect, hard-coded timer frequency
  hdr/omap3530 - remove unused FlashCheck global, add DebugChar macro
Admin:
  Tested with HALTester and the RISC OS kernel using qemu-omap3.
  Tested with HALTester on a rev. B6 beagleboard.


Version 0.02. Tagged as 'OMAP3-0_02'
@
text
@d51 3
d65 11
d87 1
a87 1
        LDR     a1, =L4_ClockMan
d90 3
d94 1
a94 1
        LDR     a1, =L4_Display
d98 1
a98 1
        LDR     a2, [a1, #DSS_SYSTATUS]
d102 1
a102 1
        MOV     a2, #&78
d107 11
d137 39
a175 2
        ; Most of these registers are programmed with the VIDC value -1
        LDR     a4, =L4_Display
d221 52
a272 604
        STR     a2, [a1, #DISPC_POL_FREQ]
        ; Program DISPC_DIVISOR
        ; todo - calculate this! - page 2257
        
        Push    "r4, r7,r8,r10,r11, lr"
        MOV     r3, r0                    ; r3 -> VIDCList3

        SUB     sp, sp, #VIDC20ParmsSize  ; create workspace for VIDC20 table on stack
        SUB     r11, sp, #(&80*4)         ; r11 indexes into table workspace (allowing for
                                          ; VIDC register numbers starting at &80)

        MOV     r2, #-1                   ; first clear all entries to -1 (means dont program reg)
        MOV     r4, #VIDC20ParmsSize
        MOV     r14, sp
10
        STR     r2, [r14], #4
        SUBS    r4, r4, #4
        BNE     %BT10

        LDR     r2, [r3, #VIDCList3_HorizSyncWidth]
        BIC     r2, r2, #1                ; must be even
        SUB     r2, r2, #8                ; horiz parameters start off at n-8
        ORR     r14, r2, #HorizSyncWidth
        STR     r14, [r11, #HorizSyncWidth :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizBackPorch]
        ADD     r2, r2, r4
        BIC     r2, r2, #1
        SUB     r2, r2, #4                ; HBSR is N-12
        ORR     r14, r2, #HorizBorderStart
        STR     r14, [r11, #HorizBorderStart :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizLeftBorder]
        ADD     r2, r2, r4
        BIC     r2, r2, #1
        SUB     r2, r2, #6                ; HDSR is N-18
        ORR     r14, r2, #HorizDisplayStart
        STR     r14, [r11, #HorizDisplayStart :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizDisplaySize]
        BIC     r4, r4, #1
        LDR     r7, [r3, #VIDCList3_PixelDepth]
        MOV     r10, r4, LSL r7           ; number of bits in one displayed raster (not needed later any more)

        ANDS    r8, r10, #31              ; if line length not multiple of 32
        MOVNE   r8, #DCR_HDis             ; then set HDis bit
        ORR     r8, r8, r10, LSR #5       ; OR in number of words per line

; Note - the DCR_Bus bits get overridden and the HDWR bits modified further down the line by the mode change code
; on the basis of how much VRAM we've got, and on whether we have a dual-panel LCD or not...

        ORR     r8, r8, #DCR_VRAMOff :OR: DCR_Bus31_0 :OR: DCR_Sync
        ORR     r8, r8, #VIDCDataControl
        STR     r8, [r11, #VIDCDataControl :SHR: 22]

        ADD     r2, r2, r4                ; HDER is also N-18
        ORR     r14, r2, #HorizDisplayEnd
        STR     r14, [r11, #HorizDisplayEnd :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizRightBorder]
        ADD     r2, r2, r4
        ADD     r2, r2, #6                ; HBER is N-12
        BIC     r2, r2, #1
        ORR     r14, r2, #HorizBorderEnd
        STR     r14, [r11, #HorizBorderEnd :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizFrontPorch]
        ADD     r2, r2, r4
        ADD     r2, r2, #4                ; HCR is N-8
        BIC     r2, r2, #3                ; must be mult of 4
        ORR     r14, r2, #HorizCycle
        STR     r14, [r11, #HorizCycle :SHR: 22]

        ADD     r2, r2, #8                ; HIR is N/2
        MOV     r2, r2, LSR #1
        ORR     r14, r2, #HorizInterlace
        STR     r14, [r11, #HorizInterlace :SHR: 22]

        LDR     r2, [r3, #VIDCList3_VertiSyncWidth]
        SUB     r2, r2, #2                ; vertical registers are N-2
        ORR     r14, r2, #VertiSyncWidth
        STR     r14, [r11, #VertiSyncWidth :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiBackPorch]
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiBorderStart
        STR     r14, [r11, #VertiBorderStart :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiTopBorder]
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiDisplayStart
        STR     r14, [r11, #VertiDisplayStart :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiDisplaySize]
        STR     r4, VIDC_VertiDisplaySize              ; save it for cursor clipping
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiDisplayEnd
        STR     r14, [r11, #VertiDisplayEnd :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiBottomBorder]
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiBorderEnd
        STR     r14, [r11, #VertiBorderEnd :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiFrontPorch]
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiCycle
        STR     r14, [r11, #VertiCycle :SHR: 22]

        LDR     r4, [r3, #VIDCList3_SyncPol]
        TST     r4, #SyncPol_Interlace
        MOVEQ   r14, #0
        MOVNE   r14, #1
        STR     r14, VIDC_Interlace
        MOV     r14, #VIDCExternal
        TST     r4, #SyncPol_InvertHSync
        ORRNE   r14, r14, #Ext_InvertHSYNC
        TST     r4, #SyncPol_InvertVSync
        ORRNE   r14, r14, #Ext_InvertVSYNC
        ORR     r14, r14, #Ext_DACsOn
        ORR     r14, r14, #Ext_ERegExt
        STR     r14, [r11, #VIDCExternal :SHR: 22]

        MOV     r14, #VIDCControl
        STR     r14, [r11, #VIDCControl :SHR: 22]

        Push    "r3"

; Now go through VIDC control parameters list (not all indices can be handled yet)

        ADD     r3, r3, #VIDCList3_ControlList-8  ; point at 1st entry -8
50
        LDR     r4, [r3, #8]!                   ; load next index
        CMP     r4, #-1                         ; if -1 then end of list
        BEQ     %FT60                           ; so skip

        CMP     r4, #0                          ; if non-zero (CS if zero)
        CMPNE   r4, #ControlList_InvalidReason  ; and if known reason
        LDRCC   r2, [r3, #4]                    ; then load value
        BLCC    ProcessControlListItem          ; and process this item
        B       %BT50                           ; go onto next item in list

; put a minimum of 4, cos 800 x 600 x 1bpp don't work otherwise
FIFOLoadTable
        &       0                               ; dummy entry (not used)
        &       0                               ; never use 0
        &       0                               ; use 1 up to (and including) here
        &       0                               ; use 2 up to (and including) here
        &       0                               ; use 3 up to (and including) here
        &       60000 :SHL: 3                   ; use 4 up to (and including) here
        &       75000 :SHL: 3                   ; use 5 up to (and including) here
        &       90000 :SHL: 3                   ; use 6 up to (and including) here
                                                ; else use 7

60
        Pull    "r3"
        LDR     r0, [r3, #VIDCList3_PixelRate]  ; get pixel rate
        MOV     r10, r0, LSL r7                 ; peak mem b/w (x 1E3 bits/sec) - save for FIFO calculation

        MOV     R1, #0
        LDRB    R1, IOSystemType
        TST     R1, #IOST_7500
        LDREQ   R1, =24000              ;(Medusa), VIDC20 at 24MHz
        MOVNE   R1, #32000              ;Morris, VIDC20L at 32Mhz

        BL      ComputeModuli   ; out: r0 = FSync bits, r1 = CR bits

        ORR     r0, r0, #VIDCFSyn
        STR     r0, [r11, #VIDCFSyn :SHR: 22]

        LDR     r0, [r11, #VIDCControl :SHR: 22]
        ORR     r0, r0, r1

        TEQ     r7, #5          ; if 32 bpp, then stick in 6 not 5
        MOVEQ   r7, #6
        ORR     r0, r0, r7, LSL #5

; now work out FIFO load position - r10 is b/w in thousands of bytes/sec

; do it by means of a binary chop on 3 bits

        ADR     r4, FIFOLoadTable
        LDR     r2, [r4, #4*4]                  ; load 0-3/4-7 split
        CMP     r10, r2
        MOVLS   r7, #0                          ; if <=, then bottom half
        MOVHI   r7, #4                          ; else top half
        ADDHI   r4, r4, #4*4                    ; and advance table pointer

        LDR     r2, [r4, #2*4]
        CMP     r10, r2
        ORRHI   r7, r7, #2
        ADDHI   r4, r4, #2*4

        LDR     r2, [r4, #1*4]
        CMP     r10, r2
        ORRHI   r7, r7, #1

        ORR     r0, r0, r7, LSL #CR_FIFOLoadShift
        STR     r0, [r11, #VIDCControl :SHR: 22]

        ADD     R0, r11, #(&80*4)           ; R0 -> VIDC20 table (remove offset for reg indices starting at &80)
        BL      ProgramVIDC20Regs

        ; now make sure video DMA enabled
        ;
        LDR     r7, IOMD_Address
        LDRB    r8, [r7, #IOMD_VIDCR]
        AND     r8, r8, #&7F                 ; knock out IOMD_VIDCR_Dup
        ORR     r8, r8, #IOMD_VIDCR_Enable   ; enable video DMA
        STRB    r8, [r7, #IOMD_VIDCR]

        ADD     sp, sp, #VIDC20ParmsSize   ; drop workspace for table
        Pull    "r4, r7,r8,r10,r11, pc"

; -------------------------------------------------------------------------

; ProgramVIDC20Regs - program registers from table
;
;  entry: r0 -> VIDC table to program into registers
;         (and r9 -> HAL workspace)
;
;  allowed to corrupt any of r0-r4, r7,r8,r10,r11 (only called from HAL_Video_SetMode)

ProgramVIDC20Regs ROUT
        Push    "r6, lr"

        LDR     R4, VIDC_Interlace
        TST     R4, #1
        MOVNE   R4, #CR_Interlace

        MOV     R7, R0                  ; keep copy in R7 in case we go wrong
        LDR     R3, VIDC_Address        ; R3 -> VIDC20 h/w
18
        MOV     R1, #(128-PseudoRegisters)*4 ; number of bytes to do (don't program pseudo-registers!)
20
        LDR     R2, [R0], #4            ; Get data from table
        CMP     R2, #-1                 ; unprogrammed register ?
        BEQ     %FT80                   ; then skip

        AND     R6, R2, #&FF000000

        TEQ     R6, #HorizDisplayStart
        STREQ   R2, VIDC_PointerHAdjust  ; save here for later calculation of adjust

        TEQ     R6, #VertiDisplayStart   ; test for display start
        BICEQ   R14, R2, #&FF000000      ; get rid of register bits
        STREQ   R14, VIDC_PointerVAdjust ; save for pointer programming

        TEQ     R6, #HorizSyncWidth      ; if h.sync width register
        STREQ   R2, VIDC_HSWRSoftCopy    ; then save for DPMS stuff
        TEQ     R6, #VertiSyncWidth      ; likewise v.sync width
        STREQ   R2, VIDC_VSWRSoftCopy

        TEQ     R6, #VIDCExternal       ; check for external register (which contains syncs)
        BNE     %FT50

   ! 0, "mjsHAL - currently assume vertical sync rather than find out (by HAL call to OS?)"
;;;
;;;mjsHAL old code that operated on NE if composite sync found from SWI OS_ReadSysInfo 1
;;;
;;;     BICNE   R2, R2, #(Ext_HSYNCbits :OR: Ext_VSYNCbits)     ; if composite sync then don't invert syncs
;;;     ORRNE   R2, R2, #Ext_InvertCompVSYNC :OR: Ext_InvertCompHSYNC ; and force both syncs to be composite (because of lack of
                                                                ; swap in A540 VIDC card)
        B       %FT75
50
        TEQ     R6, #VIDCFSyn
        BNE     %FT60

        LDR     R8, =FSyn_ResetValue    ; set test bits on, and r > v
        ORR     R8, R8, #VIDCFSyn
        STR     R8, [R3]

; we may need some delay in here...

        LDR     R8, =FSyn_ClearR :OR: FSyn_ClearV :OR: FSyn_ForceLow :OR: FSyn_ForceHigh
        ORR     R2, R2, R8
        BIC     R2, R2, #FSyn_ForceHigh ; force test bits on, except this one
        STR     R2, [R3]

; we may also need some delay in here...

        BIC     R2, R2, R8              ; remove test bits
        B       %FT75

60
        TEQ     r6, #VIDCDataControl
        BNE     %FT65

        BIC     r2, r2, #DCR_BusBits
        LDRB    r14, VRAMWidth
        CMP     r14, #2                 ; if using 64-bit wide VRAM
        ORRCS   r2, r2, #DCR_Bus63_0    ; then data on all 64 bits
        ORRCC   r2, r2, #DCR_Bus31_0    ; else for 32-bit wide VRAM or DRAM-only,
                                        ; data is on low 32 bits
        BCC     %FT65

; dual-bank VRAM, so HDWR value needs to be halved

        MOV     r14, r2, LSL #(31-10)   ; get HDWR bits at top - NB allow bit 10 to be used here!
        BIC     r2, r2, r14, LSR #(31-10) ; knock off bits
        TST     r14, #1 :SHL: (31-10)   ; see if bottom bit would get knocked off
        ORRNE   r2, r2, #DCR_HDis       ; if so, then disable HDis mechanism (for eg mode 29)
        ORREQ   r2, r2, r14, LSR #(31-9) ; otherwise, put bits back one bit further down

65
        TEQ     R6, #VIDCControl        ; if control register
        BNE     %FT75

; programming control register, so EOR sync/interlace bits, save in soft copy
; then work out horizontal pointer adjust from HorizDisplayStart
; (saved in VIDC_PointerHAdjust) and bits-per-pixel in control register

        EOR     R2, R2, R4               ; then EOR sync/interlace bits
        STR     R2, VIDC_ControlSoftCopy ; and save in copy

; now compute FSIZE properly
        LDR     R10, [R7, #(&94-&80)*4]  ; get vertidisplayend
        BIC     R10, R10, #&FF000000
        LDR     R8, [R7, #(&93-&80)*4]   ; get vertidisplaystart
        BIC     R8, R8, #&FF000000
        SUB     R10, R10, R8             ; verti displayed
        LDR     R8, [R7, #(&90-&80)*4]   ; verti total
        BIC     R8, R8, #&FF000000
        SUB     R10, R8, R10
        ADD     R10, R10, #1             ; vidc parms are n-2, we want n-1
        LDR     R8,  IOMD_Address
        STRB    R10, [R8, #IOMD_FSIZE]

        LDR     R14, VIDC_PointerHAdjust ; R14 = horiz display start (-18)
        BIC     R14, R14, #&FF000000
        ADD     R14, R14, #(18-17)       ; horiz cursor start is programmed with n-17
        STR     R14, VIDC_PointerHAdjust
75
        TEQ     R6, #VIDCExternal
        STREQ   R2, VIDC_ExternalSoftCopy
        TEQ     R6, #VIDCFSyn
        STREQ   R2, VIDC_FSynSoftCopy
        TEQ     R6, #VIDCControl
        STREQ   R2, VIDC_ControlSoftCopy

        STR     R2, [R3]                ; stuff it into VIDC20
80
        SUBS    R1, R1, #4
        BNE     %BT20

        MOV     R2, #VertiCursorStart + 0       ; program cursor start and end
        STR     R2, [R3]
        MOV     R2, #VertiCursorEnd + 0         ; to zero
        STR     R2, [R3]

        Pull    "r6, pc"

; -------------------------------------------------------------------------

;
;       ProcessControlListItem
;
; in:   r2  = value for item
;       r4  = index for item (guaranteed in range)
;       r11 -> VIDC register array
;
; out:  r0-r2, r4, r7, r8, r10 may be corrupted
;       r3, r9, r11 must be preserved

ProcessControlListItem Entry
        LDR     pc, [pc, r4, LSL #2]
        NOP
        &       ProcessControlListNOP                   ; 0 - NOP
        &       ProcessControlListLCDMode               ; 1 - LCD mode
        &       ProcessControlListLCDDualPanelMode      ; 2 - LCD dual-panel mode
        &       ProcessControlListLCDOffsetRegister0    ; 3 - LCD offset register 0
        &       ProcessControlListLCDOffsetRegister1    ; 4 - LCD offset register 1
        &       ProcessControlListHiResMode             ; 5 - Hi-res mode
        &       ProcessControlListDACControl            ; 6 - DAC control
        &       ProcessControlListRGBPedestals          ; 7 - RGB pedestal enables
        &       ProcessControlListExternalRegister      ; 8 - External register
        &       ProcessControlListHClockSelect          ; 9 - HClk select/specify
        &       ProcessControlListNOP                   ; 10 - RClk frequency
        &       ProcessControlListDPMSState             ; 11 - DPMS state
        &       ProcessControlListNOP                   ; 12 - Interlaced mode

  ! 0, "mjsHAL - no LCD support (VIDCList3 control list stuff)"

ProcessControlListLCDMode
        ;;;mjsHAL we have no support
        EXIT

ProcessControlListHiResMode
        MOV     r1, #Ext_HiResMono              ; bit of a misnomer, it's not nec. mono
05
        MOV     r0, #VIDCExternal
10
        MOV     r7, r1
        TEQ     r2, #0                          ; if value non-zero
        MOVNE   r2, r1                          ; then use value in r1
15
        AND     r2, r2, r7                      ; ensure only relevant bits set
        LDR     lr, [r11, r0, LSR #22]           ; load word from register bank
        BIC     lr, lr, r7                      ; knock out bits in mask
        ORR     lr, lr, r2                      ; OR in new bits
        STR     lr, [r11, r0, LSR #22]           ; and store in array
;
ProcessControlListNOP
        EXIT

ProcessControlListDACControl
        MOV     r1, #Ext_DACsOn
        B       %BT05

ProcessControlListRGBPedestals
        MOV     r0, #VIDCExternal
        MOV     r2, r2, LSL #Ext_PedsShift
        MOV     r7, #Ext_PedsOn
        B       %BT15

ProcessControlListExternalRegister
        MOV     r0, #VIDCExternal
        MOV     r7, #&FF
        B       %BT15

ProcessControlListLCDDualPanelMode
        ;;;mjsHAL we have no support
        EXIT

ProcessControlListLCDOffsetRegister0
        ;;;mjsHAL we have no support
        EXIT

ProcessControlListLCDOffsetRegister1
        ;;;mjsHAL we have no support
        EXIT

ProcessControlListHClockSelect
        MOV     r0, #PseudoRegister_HClockSpeed ; pseudo-register holding HClock speed
        ORR     r2, r2, r0                      ; form combined value
        STR     r2, [r11, r0, LSR #22]           ; store in register
        EXIT

ProcessControlListDPMSState
        ; no longer used in HAL code (kernel keeps DPMSState)
        EXIT

; -------------------------------------------------------------------------

;
;       ComputeModuli - Work out VCO moduli for a given frequency
;
; in:   r0  = desired frequency (kHz)
;       r1  = rclk frequency (kHz) (normally 24000)
;       r11 -> VIDC table
;
; out:  r0 = bits to put in bits 0..15 of Frequency Synthesizer Register
;       r1 = bits to put in bits 0..4 of Control Register

rclk    *       24000           ; Reference clock into VIDC20 (in kHz)
VCO_Min *       55000           ; minimum VCO frequency (in kHz)
VCO_Max *      110000           ; maximum VCO frequency (in kHz)

fpshf   *       11              ; Shift value for fixed point arithmetic

        ^       0, sp

BestDInOrOutOfRange     #       4
BestRInOrOutOfRange     #       4
BestVInOrOutOfRange     #       4
BestDInRange            #       4
BestRInRange            #       4
BestVInRange            #       4
BestRangeError          #       4
ComputeModuliStack      *       :INDEX: @@

ComputeModuli Entry "r2-r12", ComputeModuliStack
        LDR     r2, [r11, #PseudoRegister_HClockSpeed:SHR:22]           ; are we using HCLK?
        CMP     r2, #-1
        BEQ     %FT05                                                   ; -1 => no, use VCLK/RCLK

        BIC     r1, r2, #&FF000000                                      ; r1 = HCLK frequency
        SUB     r1, r1, r1, LSR #2                                      ; r1 = HCLK * 3/4
        CMP     r0, r1
        MOVLO   r1, #CR_HCLK :OR: ((2-1) :SHL: CR_PixelDivShift)        ; if < 3/4 HCLK, use divide by 2
        MOVHS   r1, #CR_HCLK :OR: ((1-1) :SHL: CR_PixelDivShift)        ; else use divide by 1
        LDR     r0, =(63 :SHL: FSyn_RShift) :OR: (1 :SHL: FSyn_VShift)  ; minimum V, maximum R
        EXIT

; Use VCLK/RCLK
05
        MOV     r12, #-1                ; smallest error for values in or out of VCO range
        MOV     r11, #-1                ; smallest error for values in VCO range
        STR     r11, BestDInRange
        STR     r11, BestVInRange
        STR     r11, BestRInRange
        STR     r11, BestDInOrOutOfRange
        STR     r11, BestVInOrOutOfRange
        STR     r11, BestRInOrOutOfRange
        STR     r11, BestRangeError
        MOV     r5, r1                  ; r5 = rclk frequency, normally 24000 (32000 on Morris)
        LDR     r1, =VCO_Min            ; r1 = minimum VCO frequency (in kHz)
        LDR     r2, =VCO_Max            ; r2 = maximum VCO frequency (in kHz)
        MOV     r3, #1                  ; r3 = D
10
        MOV     r4, #1                  ; r4 = R
15
        MUL     r6, r0, r3              ; r6 = xD
        MUL     r7, r6, r4              ; r7 = xRD
        ADD     r7, r7, r5, LSR #1      ; r7 = xRD + vref/2
        DivRem  r8, r7, r5, r9          ; r8 = (xRD + vref/2) DIV vref = V value

        TEQ     r4, #1                  ; if R=1 then V must be 1, else it's no good
        BNE     %FT20
        TEQ     r8, #1
        BNE     %FT50
        BEQ     %FT25
20
        CMP     r8, #2                  ; if R<>1 then V must be in range 2..64
        RSBCSS  r7, r8, #64
        BCC     %FT50                   ; V out of range, so skip
25
        MUL     r7, r5, r8              ; r7 = V * vref
        MOV     r7, r7, LSL #fpshf      ; r7 = (V * vref) << fixedpointshift
        DivRem  r9, r7, r4, r14         ; r9 = ((V * vref) << fixedpointshift)/R = VCO frequency << fixedpointshift
        MOV     r6, r9
        DivRem  r7, r9, r3, r14         ; r7 = output frequency << fixedpointshift
        SUBS    r7, r7, r0, LSL #fpshf
        RSBCC   r7, r7, #0              ; r7 = absolute error << fixedpointshift

        TEQ     r4, #1                  ; if R=1 then no need to check VCO range
        BEQ     %FT27                   ; because VCO won't be used, so it's a 1st class citizen

        CMP     r6, r1, LSL #fpshf      ; test if VCO freq >= min
        RSBCSS  r14, r6, r2, LSL #fpshf ; and <= max
        BCC     %FT40                   ; not in range, so not a first class citizen
27
        CMP     r7, r11
        BHI     %FT40                   ; worse than the best case for in VCO range, so ignore
        BCC     %FT30                   ; is definitely better than the best case for in or out

        LDR     r14, BestRInRange       ; is equal best for in, so check R value
        CMP     r4, r14                 ; is newR < bestR
        BCS     %FT40                   ; is greater or equal R value (ie not higher comp. freq., so not best)
30
        MOV     r11, r7
        STR     r3, BestDInRange
        STR     r4, BestRInRange
        STR     r8, BestVInRange
        MOV     r14, #0
        B       %FT45

40
        RSBS    r14, r6, r1, LSL #fpshf ; r14 = min-this, if this<min
        SUBCC   r14, r6, r2, LSL #fpshf ; else r14 = this-max, ie r14 = how much this is outside range

        CMP     r7, r12
        BHI     %FT50                   ; worse than the best case for in or out of VCO range, so ignore
        BCC     %FT45                   ; is definitely better than the best case for in or out

        LDR     r9, BestRangeError      ; is equal best for in or out, so check error
        CMP     r14, r9
        BCS     %FT50                   ; not lower error, so skip
45
        MOV     r12, r7
        STR     r3, BestDInOrOutOfRange
        STR     r4, BestRInOrOutOfRange
        STR     r8, BestVInOrOutOfRange
        STR     r14, BestRangeError
50
  [ :LNOT: DontUseVCO                   ; If we don't use the VCO, R has to be 1
        ADD     r4, r4, #1
        CMP     r4, #16                 ; R goes from 2 to 16 (was 2 to 64)
        BLS     %BT15
  ]

        ADD     r3, r3, #1
        CMP     r3, #8                  ; D goes from 1 to 8
        BLS     %BT10

        ADR     r2, BestDInRange
        LDR     r3, [r2]
        CMP     r3, #-1
        ADDEQ   r2, r2, #BestDInOrOutOfRange - BestDInRange
        LDREQ   r3, [r2]                ; r3 = Best D
        LDR     r4, [r2, #BestRInRange - BestDInRange]  ; r4 = Best R
        LDR     r5, [r2, #BestVInRange - BestDInRange]  ; r5 = Best V

        SUBS    r4, r4, #1              ; values in FSyn are n-1
  [ {TRUE} ;VCOstartfix
        ;do *not* do the very slow trick - this will stall the VCO and it may not restart
        ;properly later (we don't give a fig for power consumption)
        MOVEQ   r4, #3
        MOVEQ   r5, #8                  ; after sub below, (7+1)/(3+1) so VCO runs at twice ref clock
  |
        MOVEQ   r4, #63                 ; if R=V=1 then use max R
        MOVEQ   r5, #2                  ; and min V to make VCO go really slow
  ]

        SUB     r5, r5, #1              ; for both v and r
        ASSERT  FSyn_RShift = 0
        ORR     r0, r4, r5, LSL #FSyn_VShift

        SUB     r3, r3, #1              ; D is also stored as n-1
        MOV     r1, r3, LSL #CR_PixelDivShift
        ASSERT  CR_VCLK = 0
        ORREQ   r1, r1, #CR_RCLK        ; if using VCO then set for VCLK, else RCLK

        EXIT
d290 25
a314 53

        AND     r12, r1, #&F0               ; 000000S0 (4 MSbits of supremacy)
        MOV     r1, r1, LSR #8              ; 00BBGGRR
        ORR     r1, r1, r12, LSL #20        ; 0SBBGGRR

        LDR     r12, VIDC_Address

        CMP     r0, #1
        BLO     HV_WritePaletteEntry_type0
        BEQ     HV_WritePalettEntry_type1
;       else fall through to WritePaletteEntry_type2
;
HV_WritePaletteEntry_type2
        CMP     r2, #3                      ; index must be in range 0..3
        MOVHI   pc, lr
        SUBS    r2, r2, #1                  ; reduce 1..3 to 0..2
        MOVMI   pc, lr                      ; pointer colour 0 is always transparent on VIDC20
        ORR     r1, r1,#VIDC20PointerColour ; munge in base address of register
        ADD     r1, r1, r2, LSL #28         ; add in index (0..2), in bits 28,29 of register
        STR     r1, [r12]
        MOV     pc, lr
;
HV_WritePaletteEntry_type0
        ;Note: we only need to hit VIDCPalAddress if the index is not a direct increment
        ;of the last programmed index
        ;but, for insurance against permanent misalignment if any rogue accesses avoid this
        ;interface, we force an update for index 0
        ;
        CMP     r2, #255                  ; index must be in range 0..255
        MOVHI   pc, lr

        CMP     r2, #0

        STREQ   r1, VIDC_SoftPalette0

        LDRNE   r0, VIDC_NextPaletteIndex  ;increment from last index programmed
        MOVEQ   r0, #-1                    ;forced invalid for index 0

        TEQ     r0, r2
        ORRNE   r0, r2, #VIDCPalAddress        
        STRNE   r0, [r12]                 ; only update PalAddress if necessary
        STR     r1, [r12]                 ; update palette entry
        ADD     r2, r2, #1
        AND     r2, r2, #&FF
        STR     r2, VIDC_NextPaletteIndex
        MOV     pc, lr
;
;
HV_WritePalettEntry_type1
        CMP     r2, #0                     ; index must be 0
        MOVNE   pc, lr
        ORR     r1, r1,#VIDC20BorderColour ; munge in base address of register
        STR     r1, [r12]
d334 49
a382 56
        Push    "r4, lr"

        CMP     r2, #255                    ; all indices in loop must be in range 0..255
        BHI     %FT20
        ADD     r4, r2, r3
        CMP     r4, #256
        BHI     %FT20

        CMP     r0, #0
        BNE     %FT50
;
; type 0, try to be efficient
;
        LDR     r12, VIDC_Address

        CMP     r2, #0

        LDREQ   r0, [r1]
        STREQ   r0, VIDC_SoftPalette0

        LDRNE   r0, VIDC_NextPaletteIndex
        MOVEQ   r0,#-1                      ; insurance! (see comments for WritePaletteEntry_type0)

        TEQ     r0, r2
        ORRNE   r0, r2, #VIDCPalAddress        
        STRNE   r0, [r12]                   ; only update PalAddress if necessary

        ADD     r0, r2, r3
        AND     r0, r0, #&FF
        STR     r0, VIDC_NextPaletteIndex

        MOV     r4, r1
10
        LDR     r1, [r4], #4
        AND     r0, r1, #&F0                ; 000000S0 (4 msbits of supremacy)
        MOV     r1, r1, LSR #8              ; 00BBGGRR
        ORR     r1, r1, r0, LSL #20         ; 0SBBGGRR
        STR     r1, [r12]
        SUBS    r3, r3, #1
        BNE     %BT10
20
        Pull    "r4, pc"
;
; not type 0
;
50
        MOV     r4, r1
60
        LDR     r1, [r4], #4        ; next pcolour
        Push    "r2, r3"
        BL      HAL_Video_WritePaletteEntry
        Pull    "r2, r3"
        ADD     r2, r2, #1
        SUBS    r3, r3, #1
        BNE     %BT60
        Pull    "r4, pc"
d408 1
a408 20

        CMP     r0, #0
        BNE     HV_ReadPaletteEntry_not_type0
;
; type 0
; only 4 bits of S, and only 16 S entries
; S for indices 16..255 comes from palette entry 0 
;
        CMP     r2, #16
        LDRHS   r12, VIDC_SoftPalette0
        MOVLO   r12, r1

        AND     r12, r12, #&000000F0  ; effective S bits
        BIC     r0, r1, #&000000FF    ; effective BGR bits
        ORR     r0, r0, r12           ; munge together
        MOV     pc, lr
;
HV_ReadPaletteEntry_not_type0
; no special restrictions, just that there are only 4 bits of S
        BIC     r0, r1, #&0000000F
a417 8

        LDR     r1, VIDC_ControlSoftCopy
        BIC     r1, r1, #CR_Interlace
        TST     r0, #1
        ORRNE   r1, r1, #CR_Interlace    ; zero => no interlace

        LDR     r0, VIDC_Address
        STR     r1, [r0]                ; program VIDC
a434 49

        LDR     r3, VIDC_Address

        TEQ     r0, #0
        BEQ     %FT50
;
; blanking
;
        TST     r1, #1                  ; if hsyncs should be off,
        LDRNE   r2, =HorizSyncWidth + ((1:SHL:14) -1)   ; maximum value in h.sync width register
        STRNE   r2, [r3]

        TST     r1, #2                  ; if vsyncs should be off,
        LDRNE   r2, =VertiSyncWidth + ((1:SHL:13) -1)   ; maximum value in v.sync width register
        STRNE   r2, [r3]

        LDR     r2, VIDC_ExternalSoftCopy
        AND     r1, r1, #3
        TEQ     r1, #3                                         ; if both syncs off
        BICEQ   r2, r2, #Ext_HSYNCbits :OR: Ext_VSYNCbits
        ORREQ   r2, r2, #Ext_InvertHSYNC :OR: Ext_InvertVSYNC  ; set sync signals to low (less power)
        BIC     r2, r2, #Ext_DACsOn                            ; turn off the DACs
        STR     r2, [r3]

        LDR     r0, IOMD_Address
        LDRB    r1, [r0, #IOMD_VIDCR]
        BIC     r1, r1, #IOMD_VIDCR_Enable   ; disable video DMA
        STRB    r1, [r0, #IOMD_VIDCR]

        MOV     pc, lr
;
; unblanking
;
50      LDR     r2, VIDC_ExternalSoftCopy
        STR     r2, [r3]                     ; restore DACs and sync type

        TST     r1, #1                       ; if hsyncs were turned off,
        LDRNE   r2, VIDC_HSWRSoftCopy        ; then restore from soft copy
        STRNE   r2, [r3]

        TST     r1, #2                       ; if vsyncs were turned off,
        LDRNE   r2, VIDC_VSWRSoftCopy        ; then restore from soft copy
        STRNE   r2, [r3]

        LDR     r0, IOMD_Address
        LDRB    r1, [r0, #IOMD_VIDCR]
        ORR     r1, r1, #IOMD_VIDCR_Enable   ; enable video DMA
        STRB    r1, [r0, #IOMD_VIDCR]

a443 48

        LDR     r1, VIDC_Address

        TEQ     r0, #0
        BEQ     %FT50
;
; power save on
;
        LDR     r2, =&C0000003    ;dac off, ereg set to external LUT
        STR     r2, [r1]

        LDR     r2, =&D0004000    ;Vclk off, Pcomp=0
        STR     r2, [r1]

        LDR     r2, =&E0004049    ;PoDown, Hclk
        STR     r2, [r1]

        MOV     pc, lr
;
; power save off
;
50      
        LDR     r2, VIDC_ControlSoftCopy       ;restore from soft copy
        STR     r2, [r1]

        LDR     r2, VIDC_ExternalSoftCopy      ;restore from soft copy
        STR     r2, [r1]

        LDR     r2, VIDC_FSynSoftCopy          ;restore from soft copy

 [ {TRUE}
        LDR     R3, =FSyn_ResetValue    ; set test bits on, and r > v
        ORR     R3, R3, #VIDCFSyn
        STR     R3, [R1]

; we may need some delay in here...

        LDR     R3, =FSyn_ClearR :OR: FSyn_ClearV :OR: FSyn_ForceLow :OR: FSyn_ForceHigh
        ORR     R2, R2, R3
        BIC     R2, R2, #FSyn_ForceHigh ; force test bits on, except this one
        STR     R2, [R1]

; we may also need some delay in here...

        BIC     R2, R2, R3              ; remove test bits
 ]
        STR     r2, [r1]

d489 98
a586 45

        Push    "r4, r5, lr"

        LDR     r14, VIDC_Address

        TST     r0, #1
        BEQ     %FT90          ; pointer off

;
; process x (and assume shape width is padded 32 pixels)
;
        LDR     r4, VIDC_PointerHAdjust
        ADDS    r1, r1, r4
        MOVLT   r1, #0                    ; x:= x+fudge, clamped to 0

        CMP     r1, #&4000                ; VIDC has 14 bits for cursor start
        MOVGE   r1, #&4000
        SUBGE   r1, r1, #1

        ORR     r1, r1, #HorizCursorStart
        STR     r1, [r14]
;
; process y
;
        LDRB    r4, [r3, #1]              ; height from shape_t block
        LDR     r5, [r3, #8]              ; buffer physical address from shape_t block

        CMP     r2, #0                    ; if -ve y
        BICLT   r2, r2, #1                ; TEMP FUDGE - really ought to have two copies, one offset by 1 row
                                          ; because VIDC can only cope with 16 byte aligned data pointer
        ADDLT   r4, r4, r2                ; reduce height
        SUBLT   r5, r5, r2, LSL #3        ; and advance data pointer (8 bytes per row) to clip pointer to 0
        MOVLT   r2, #0
        CMP     r4, #0
        BLE     %FT90                     ; pointer off if clipped to oblivion

        LDR     r1, VIDC_VertiDisplaySize
        SUB     r1, r1, r2                       ; if display_height - y < pointer height
        CMP     r1, r4
        MOVLT   r4, r1                           ; clip pointer height
        CMP     r4, #0
        BLE     %FT90                            ; pointer off if clipped to oblivion

        LDR     r1, VIDC_PointerVAdjust
        ADD     r2, r2, r1                       ; y := y+adjust
a587 22
        ORR     r1, r2, #VertiCursorStart
        STR     r1, [r14]

        ADD     r2, r2, r4                ; y:= y+height
        ORR     r1, r2, #VertiCursorEnd
        STR     r1, [r14]

        LDR     r14, IOMD_Address
        STR     r5, [r14, #IOMD_CURSINIT]

        Pull    "r4, r5, pc"

90
;
; pointer off
;
        MOV     r4, #VertiCursorStart
        STR     r4, [r14]
        MOV     r4, #VertiCursorEnd
        STR     r4, [r14]

        Pull    "r4, r5, pc"
d620 5
a624 19

        LDR     r12, IOMD_Address

        CMP     r0, #1
        BEQ     %FT20
        BHI     %FT40
;
; DAG=0 program VInit
;
        STR     r1, IOMD_VInitSoftCopy   ; save VInit so that writes to VEnd can check
        LDR     r2, IOMD_VEndSoftCopy
        CMP     r1, r2                   ; if VInit >= VEnd then set L bit
        ORRCS   r1, r1, #IOMD_DMA_L_Bit
        STR     r1, [r12, #IOMD_VIDINIT]
        MOV     pc, lr
;
; DAG=1 program VStart
;
20      STR     r1, [r12, #IOMD_VIDSTART]
a626 17
;
; DAG=2 program VEnd
;
40      MOV     r2, #0                          ; we must adjust address to that of
        LDRB    r2, VRAMWidth                   ; last DMA fetch, allowing for fetch size
        CMP     r2, #1
        MOVLO   r2, #16                         ; DRAM-only, subtract 16 (quadword)
        MOVEQ   r2, #SAMLength/2                ; 1 bank of VRAM - 1/2 SAM
        MOVHI   r2, #SAMLength                  ; 2 banks of VRAM - 1/2 SAM * 2
        SUB     r1, r1, r2
        STR     r1, IOMD_VEndSoftCopy           ; remember VEnd value
        LDR     r2, IOMD_VInitSoftCopy          ; load current VInit
        CMP     r2, r1                          ; if VInit >= VEnd
        ORRCS   r2, r2, #IOMD_DMA_L_Bit         ; then set L bit
        STR     r2, [r12, #IOMD_VIDINIT]        ; store VInit
        STR     r1, [r12, #IOMD_VIDEND]         ; and VEnd
        MOV     pc, lr
d640 2
a641 2
        MOV   a1, #2_011   ; hw scroll, h/w pointer, no interlace
        MOV   pc, lr
d662 2
a663 2
        MOV   a1, #2_111111   ; 1,2,4,8,16,32 bpp
        MOV   pc, lr
d674 2
a675 2
        MOV   a1, #32          ; align to 32 bytes
        MOV   pc, lr
d691 2
a692 2
        MOV   a1, #0     ;normal/unspecified
        MOV   pc, lr
d708 106
a813 4
        MOV   r0,#0    ; do nothing for now
        MOV   PC,LR

; -------------------------------------------------------------------------
@


1.1
log
@Basic OMAP3 HAL
Detail:
  Performs startup procedure suitable for any location in ROM or RAM. UART, timer, counter, interrupt & debug functionality implemented. Video support incomplete and nonfunctional.
Admin:
  Tested with HALTester & RISC OS kernel under qemu-omap3


Version 0.01. Tagged as 'OMAP3-0_01'
@
text
@d51 11
@


head	1.10;
access;
symbols
	OMAP3-1_18:1.10
	OMAP3-1_17:1.10
	OMAP3-1_16:1.10
	OMAP3-1_15:1.10
	OMAP3-1_14:1.10
	SMP:1.10.0.2
	SMP_bp:1.10
	OMAP3-1_13:1.10
	OMAP3-1_12:1.10
	OMAP3-1_11:1.9
	OMAP3-1_10:1.9
	OMAP3-1_09:1.9
	OMAP3-1_08:1.9
	OMAP3-1_07:1.9
	OMAP3-1_06:1.9
	OMAP3-1_05:1.9
	OMAP3-1_04:1.9
	OMAP3-1_03:1.9
	OMAP3-1_02:1.9
	OMAP3-1_01:1.9
	OMAP3-1_00:1.9
	OMAP3-0_99:1.9
	OMAP3-0_98:1.9
	OMAP3-0_97:1.9
	OMAP3-0_96:1.9
	OMAP3-0_95:1.9
	OMAP3-0_94:1.9
	OMAP3-0_93:1.9
	OMAP3-0_92:1.9
	OMAP3-0_91:1.9
	OMAP3-0_90:1.8
	OMAP3-0_89:1.7
	OMAP3-0_88:1.7
	OMAP3-0_87:1.7
	OMAP3-0_86:1.7
	OMAP3-0_85:1.7
	OMAP3-0_84:1.7
	OMAP3-0_83:1.7
	OMAP3-0_82:1.7
	OMAP3-0_81:1.7
	OMAP3-0_80:1.7
	OMAP3-0_79:1.7
	OMAP3-0_78:1.7
	OMAP3-0_77:1.7
	OMAP3-0_76:1.7
	OMAP3-0_75:1.7
	OMAP3-0_74:1.7
	OMAP3-0_73:1.7
	OMAP3-0_72:1.7
	OMAP3-0_71:1.7
	OMAP3-0_70:1.7
	OMAP3-0_69:1.7
	OMAP3-0_68:1.6
	OMAP3-0_67:1.6
	OMAP3-0_66:1.6
	OMAP3-0_65:1.6
	OMAP3-0_64:1.6
	OMAP3-0_63:1.6
	OMAP3-0_62:1.6
	OMAP3-0_61:1.6
	OMAP3-0_60:1.5
	OMAP3-0_59:1.5
	OMAP3-0_58:1.5
	OMAP3-0_57:1.5
	OMAP3-0_56:1.5
	OMAP3-0_55:1.5
	OMAP3-0_54:1.5
	OMAP3-0_53:1.5
	OMAP3-0_52:1.5
	OMAP3-0_51:1.5
	OMAP3-0_50:1.5
	OMAP3-0_49:1.4
	OMAP3-0_48:1.4
	OMAP3-0_47:1.4
	OMAP3-0_46:1.4
	OMAP3-0_45:1.4
	OMAP3-0_44:1.4
	OMAP3-0_43:1.4
	OMAP3-0_42:1.4
	OMAP3-0_41:1.4
	OMAP3-0_40:1.4
	OMAP3-0_39:1.4
	OMAP3-0_38:1.4
	OMAP3-0_37:1.4
	OMAP3-0_36:1.3
	OMAP3-0_35:1.3
	OMAP3-0_34:1.3
	OMAP3-0_33:1.3
	OMAP3-0_32:1.3
	OMAP3-0_31:1.3
	OMAP3-0_30:1.3
	OMAP3-0_29:1.3
	OMAP3-0_28:1.3
	OMAP3-0_27:1.3
	OMAP3-0_26:1.3
	OMAP3-0_25:1.3
	OMAP3-0_24:1.3
	OMAP3-0_23:1.3
	OMAP3-0_22:1.3
	OMAP3-0_21:1.3
	OMAP3-0_20:1.3
	OMAP3-0_19:1.3
	OMAP3-0_18:1.2
	OMAP3-0_17:1.1
	OMAP3-0_16:1.1
	OMAP3-0_15:1.1
	OMAP3-0_14:1.1
	OMAP3-0_13:1.1;
locks; strict;
comment	@# @;


1.10
date	2016.07.01.19.29.54;	author jlee;	state Exp;
branches;
next	1.9;
commitid	L2HUweyrYfiUzEcz;

1.9
date	2013.11.09.15.59.21;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	CyH10lVSP94PqCcx;

1.8
date	2013.11.01.18.52.57;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	exT1lzL3WDXiEBbx;

1.7
date	2012.07.04.17.57.59;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	XMhv0CBs1aW0Wgbw;

1.6
date	2012.03.25.11.49.08;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	c99VvmwezV2J8gYv;

1.5
date	2011.11.06.13.51.46;	author jlee;	state Exp;
branches;
next	1.4;
commitid	xDHSfy5FwWIFjhGv;

1.4
date	2010.12.04.16.57.47;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.24.02.49.32;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.16.04.10.08;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.23.01.03.02;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Support DS1307-compatible RTCs attached to I2C3 on the TouchBook
Detail:
  s/RTC - Copy over the DS1307/DS1338 driver from the OMAP4 HAL, in order to allow TouchBook owners to make use of such a chip if they attach it to I2C3 (since the TPS isn't battery-backed on that machine)
Admin:
  Tested on TouchBook


Version 1.12. Tagged as 'OMAP3-1_12'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries
        GET     Hdr:HALDevice
        GET     Hdr:RTCDevice

        GET     hdr.omap3530
        GET     hdr.StaticWS
        GET     hdr.Timers
        GET     hdr.PRCM

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  I2CBusRead
        EXPORT  I2CBusWrite
        EXPORT  RTC_Init
        IMPORT  TPSRead
        IMPORT  TPSWrite
        IMPORT  IIC_DoOp_Poll
        IMPORT  memcpy

; TWL/TPS RTC IIC address
TPSRTC_IIC        * &4b

; Some RTC registers
SECONDS_REG       * &1C
RTC_CTRL_REG      * &29
RTC_STATUS_REG    * &2a

; RTC_CTRL_REG bitfields
RTC_CTRL_STOP_RTC_M             *       (1 << 0)
RTC_CTRL_ROUND_30S_M            *       (1 << 1)
RTC_CTRL_AUTO_COMP_M            *       (1 << 2)
RTC_CTRL_MODE_12_24_M           *       (1 << 3)
RTC_CTRL_TEST_MODE_M            *       (1 << 4)
RTC_CTRL_SET_32_COUNTER_M       *       (1 << 5)
RTC_CTRL_GET_TIME_M             *       (1 << 6)

; RTC_STATUS_REG bitfields
RTC_STATUS_RUN_M                *       (1 << 1)
RTC_STATUS_1S_EVENT_M           *       (1 << 2)
RTC_STATUS_1M_EVENT_M           *       (1 << 3)
RTC_STATUS_1H_EVENT_M           *       (1 << 4)
RTC_STATUS_1D_EVENT_M           *       (1 << 5)
RTC_STATUS_ALARM_M              *       (1 << 6)
RTC_STATUS_POWER_UP_M           *       (1 << 7)

; support for external DS1338 RTC chip
DS1338_IIC_BUS          *       (3 - 1) ; I2C3
DS1338_IIC_ADDR         *       (&68 * 2)

DS_RTC_SEC_REG          *       0
DS_RTC_MIN_REG          *       1
DS_RTC_HOUR_REG         *       2
DS_RTC_WDAY_REG         *       3
DS_RTC_DAY_REG          *       4
DS_RTC_MONTH_REG        *       5
DS_RTC_YEAR_REG         *       6
DS_RTC_CTRL_REG         *       7

; bits in DS_RTC_CTRL_REG
DS_RTC_CTRL_RS0         *       (1 << 0)
DS_RTC_CTRL_RS1         *       (1 << 1)
DS_RTC_CTRL_SQWE        *       (1 << 4)
DS_RTC_CTRL_OSF         *       (1 << 5)
DS_RTC_CTRL_OUT         *       (1 << 7)

; read/write functions for I2C on any bus

I2CBusRead
        ; a1 = IIC address(*2)
        ; a2 = buffer
        ; a3 = count
        ; a4 = start register
        ; v1 = IIC func
        ; v2 = IIC bus no
        ; out:
        ; a1 = return code
        ; ip corrupted
        ; buffer updated
        ORR     a1, a1, #1      ; read
        Push    "a1-a4,lr"      ; Push regs and second iic_transfer block
        EOR     a1, a1, #1+(1:SHL:29) ; write with retry
        ADD     a2, sp, #12
        MOV     a3, #1
        Push    "a1-a3"         ; push first iic_transfer block
        MOV     a1, sp
        MOV     a2, v2, LSL #24 ; bus number goes here
        ADD     a2, a2, #2
        MOV     a3, #0
        BLX     v1
        ADD     sp, sp, #16
        Pull    "a2-a4,pc"

I2CBusWrite
        ; a1 = IIC address(*2)
        ; a2 = buffer
        ; a3 = count
        ; a4 = start register
        ; v1 = IIC func
        ; v2 = IIC bus no
        ; out:
        ; a1 = return code
        ; ip corrupted
        ORR     a1, a1, #1:SHL:31 ; Write (no start bit)
        Push    "a1-a4,lr"      ; Push regs and second iic_transfer block
        EOR     a1, a1, #(1:SHL:29)+(1:SHL:31) ; Write (retries)
        ADD     a2, sp, #12
        MOV     a3, #1
        Push    "a1-a3"         ; push first iic_transfer block
        MOV     a1, sp
        MOV     a2, v2, LSL #24 ; bus number goes here
        ADD     a2, a2, #2
        MOV     a3, #0
        BLX     v1
        ADD     sp, sp, #16
        Pull    "a2-a4,pc"

RTC_Init
        Push    "v1-v2,lr"
        ADRL    a1, RTCWS
        ADR     a2, RTCDeviceTemplate
        MOV     a3, #RTCSize
        BL      memcpy
        STR     sb, [a1, #RTCDeviceHAL_SB]
        SUB     sp, sp, #4                      ; temp small buffer on stack

        ; If this is a TouchBook, check for a DS1338 or similar on I2C3
        ; (potential user modification, since the TPS isn't battery-backed for
        ; that machine)
        LDR     a1, [sb, #BoardConfig_MachID]
        LDR     a2, =MachID_TouchBook
        CMP     a1, a2
        BNE     %FT10

        LDR     v1, OSentries+4*OS_IICOpV       ; for I2CBusRead/I2CBusWrite
        MOV     v2, #DS1338_IIC_BUS             ; specify I2C bus
        MOV     a1, #DS1338_IIC_ADDR
        MOV     a3, #1
        MOV     a4, #DS_RTC_CTRL_REG
        MOV     a2, sp
        BL      I2CBusRead
        CMP     a1, #IICStatus_Completed
        BNE     %FT10
        LDRB    a1, [a2]
        TST     a1, #DS_RTC_CTRL_OSF
        BEQ     %FT05
        BIC     a1, a1, #DS_RTC_CTRL_OSF
        STRB    a1, [a2]
        MOV     a1, #DS1338_IIC_ADDR
        BL      I2CBusWrite

05      ; we have seen a DS1338 chip ==> mark it in our workspace
        ADRL    a3, RTCWS
        ADR     a1, DS_RTCReadTime
        STR     a1, [a3, #HALDevice_RTCReadTime]
        ADR     a1, DS_RTCWriteTime
        STR     a1, [a3, #HALDevice_RTCWriteTime]
        ADR     a1, DS_RTCDesc
        STR     a1, [a3, #HALDevice_Description]
        MOV     a1, #HALDeviceID_RTC_DS1307     ; at least we are compatible to this one :-)
        STRH    a1, [a3, #HALDevice_ID]
10
        ADD     sp, sp, #4

        Pull    "v1-v2,lr"
        MOV     a1, #0
        ADRL    a2, RTCWS
        CallOS  OS_AddDevice, tailcall

RTCDeviceTemplate
        DCW     HALDeviceType_SysPeri + HALDeviceSysPeri_RTC
        DCW     HALDeviceID_RTC_TPS65950
        DCD     HALDeviceBus_Ser + HALDeviceSerBus_IIC
        DCD     0               ; API version
        DCD     RTCDesc
        DCD     0               ; Address - N/A
        %       12              ; Reserved
        DCD     RTCActivate
        DCD     RTCDeactivate
        DCD     RTCReset
        DCD     RTCSleep
        DCD     -1              ; Interrupt N/A
        DCD     0
        %       8
        DCB     RTCTimeFormat_BCD
        DCB     RTCFormatFlags_BCD_1BasedDay + \
                RTCFormatFlags_BCD_1BasedMonth + \
                RTCFormatFlags_BCD_YearLOIsGood + \
                RTCFormatFlags_BCD_NeedsYearHelp
        %       2
        DCD     RTCReadTime
        DCD     RTCWriteTime

RTCDesc
        DCB     "TPS65950-compatible real-time clock",0
DS_RTCDesc
        DCB     "DS1338-compatible real-time clock",0

        ALIGN

RTCActivate
        MOV     a1, #1
RTCDeactivate
RTCReset
        MOV     pc, lr

RTCSleep
        MOV     a1, #0 ; Previously at full power
        MOV     pc, lr

RTCReadTime
        ; In:
        ; a1 = HALDevice ptr
        ; a2 = RTCTimeStruct ptr
        ; Out:
        ; a1 = return code
        ; RTCTimeStruct updated
        Push    "v1,v3,sb,lr"
        LDR     sb, [a1, #RTCDeviceHAL_SB]
        LDR     v1, OSentries+4*OS_IICOpV ; for TPSRead/TPSWrite
        MOV     v3, a2
        ; Reading the time safely involves several transfers:
        ; 1. Read RTC_STATUS_REG. If bit 1 is clear, the RTC is stopped and we can just
        ;    assume its contents are invalid.
        ; 2. Set RTC_CTRL_REG=&41 (RTC running, GET_TIME set, 24hr mode). GET_TIME will read
        ;    the time from the RTC circuitry and latch it into the time registers (the regular
        ;    time registers, NOT the alarm ones as stated by the manual!)
        ; 3. Read the time regs to read latched time.
        ; There's no need to clear GET_TIME either, as it is cleared automatically by the HW.
        MOV     a1, #TPSRTC_IIC*2
        SUB     sp, sp, #4 ; temp small buffer on stack
        MOV     a3, #1
        MOV     a4, #RTC_STATUS_REG
        MOV     a2, sp
        BL      TPSRead
        CMP     a1, #IICStatus_Completed
        LDRB    ip, [a2]
        MOV     a1, #RTCRetCode_InvalidTime
        MOVNE   a1, #RTCRetCode_Error
        EOR     ip, ip, #RTC_STATUS_RUN_M
        TSTEQ   ip, #RTC_STATUS_RUN_M
        ADDNE   sp, sp, #4
        Pull    "v1,v3,sb,pc", NE
        MOV     ip, #(RTC_CTRL_GET_TIME_M + RTC_CTRL_STOP_RTC_M)
        STR     ip, [a2]
        MOV     a1, #TPSRTC_IIC*2
        MOV     a4, #RTC_CTRL_REG
        BL      TPSWrite
        CMP     a1, #IICStatus_Completed
        MOVNE   a1, #RTCRetCode_Error
        ADD     sp, sp, #4
        Pull    "v1,v3,sb,pc", NE
        MOV     a1, #TPSRTC_IIC*2
        ; We can read the time directly into the RTCTimeStruct buffer
        ASSERT RTCTimeStruct_BCD_Minutes=RTCTimeStruct_BCD_Seconds+1
        ASSERT RTCTimeStruct_BCD_Hours=RTCTimeStruct_BCD_Seconds+2
        ASSERT RTCTimeStruct_BCD_DayOfMonth=RTCTimeStruct_BCD_Seconds+3
        ASSERT RTCTimeStruct_BCD_Month=RTCTimeStruct_BCD_Seconds+4
        ASSERT RTCTimeStruct_BCD_YearLO=RTCTimeStruct_BCD_Seconds+5
        ADD     a2, v3, #RTCTimeStruct_BCD_Seconds
        MOV     a3, #6
        MOV     a4, #SECONDS_REG
        BL      TPSRead
        CMP     a1, #IICStatus_Completed
        MOVNE   a1, #RTCRetCode_Error
        ASSERT  IICStatus_Completed = 0
        STREQB  a1, [v3, #RTCTimeStruct_BCD_Centiseconds] ; No centisecond time
        STREQB  a1, [v3, #RTCTimeStruct_BCD_YearHI] ; Kernel gives year help
        ASSERT  RTCRetCode_OK = 0
        Pull    "v1,v3,sb,pc"

RTCWriteTime
        ; In:
        ; a1 = HALDevice ptr
        ; a2 = RTCTimeStruct ptr
        ; Out:
        ; a1 = return code
        Push    "v1,v3,sb,lr"
        LDR     sb, [a1, #RTCDeviceHAL_SB]
        LDR     v1, OSentries+4*OS_IICOpV ; for TPSRead/TPSWrite
        MOV     v3, a2
        ; Writing the time safely involves several transfers:
        ; 1. Write 0 to RTC_CTRL_REG to stop the clock (just in case there are any issues with
        ;    the clock updating while it's being written to)
        ; 2. Write the new time values
        ; 3. Write 1 to RTC_CTRL_REG to start the clock
        MOV     a1, #TPSRTC_IIC*2
        MOV     ip, #0
        STR     ip, [sp,#-4]! ; temp small buffer on stack
        MOV     a3, #1
        MOV     a4, #RTC_CTRL_REG
        MOV     a2, sp
        BL      TPSWrite
        CMP     a1, #IICStatus_Completed
        MOVNE   a1, #RTCRetCode_Error
        ADDNE   sp, sp, #4
        Pull    "v1,v3,sb,pc", NE
        MOV     a1, #TPSRTC_IIC*2
        ; We can write the time directly from the RTCTimeStruct buffer
        ASSERT RTCTimeStruct_BCD_Minutes=RTCTimeStruct_BCD_Seconds+1
        ASSERT RTCTimeStruct_BCD_Hours=RTCTimeStruct_BCD_Seconds+2
        ASSERT RTCTimeStruct_BCD_DayOfMonth=RTCTimeStruct_BCD_Seconds+3
        ASSERT RTCTimeStruct_BCD_Month=RTCTimeStruct_BCD_Seconds+4
        ASSERT RTCTimeStruct_BCD_YearLO=RTCTimeStruct_BCD_Seconds+5
        ADD     a2, v3, #RTCTimeStruct_BCD_Seconds
        MOV     a3, #6
        MOV     a4, #SECONDS_REG
        ; Sometimes we don't write the time, so skip those bytes if necessary
        LDRB    ip, [a2]
        CMP     ip, #255
        ADDEQ   a2, a2, #3
        SUBEQ   a3, a3, #3
        ADDEQ   a4, a4, #3
        ; Sometimes we don't write the date either
        LDRB    ip, [v3, #RTCTimeStruct_BCD_DayOfMonth]
        CMP     ip, #255
        SUBEQS  a3, a3, #3
        BEQ     %FT01 ; Nothing left to write!
        BL      TPSWrite
        CMP     a1, #IICStatus_Completed
        MOVNE   a1, #RTCRetCode_Error
        ADDNE   sp, sp, #4
        Pull    "v1,v3,sb,pc", NE
01
        MOV     a3, #RTC_CTRL_STOP_RTC_M
        STR     a3, [sp]
        MOV     a2, sp
        MOV     a4, #RTC_CTRL_REG
        MOV     a1, #TPSRTC_IIC*2
        BL      TPSWrite
        CMP     a1, #IICStatus_Completed
        ASSERT  RTCRetCode_OK = IICStatus_Completed
        MOVNE   a1, #RTCRetCode_Error
        ADD     sp, sp, #4
        Pull    "v1,v3,sb,pc"

; read/write functions for DS1338 chip

DS_RTCReadTime
        ; In:
        ; a1 = HALDevice ptr
        ; a2 = RTCTimeStruct ptr
        ; Out:
        ; a1 = return code
        ; RTCTimeStruct updated
        Push    "v1-v3,sb,lr"
        LDR     sb, [a1, #RTCDeviceHAL_SB]
        LDR     v1, OSentries+4*OS_IICOpV       ; for I2CBusRead
        MOV     v2, #DS1338_IIC_BUS             ; specify I2C bus
        MOV     v3, a2
        ; Reading the time starting with DS_RTC_SEC_REG automatically latches the current time.
        ; There is nothing else to do. We must read the time in 2 blocks because there is
        ; the weekday register in between which has no corresponding part in RTCTimeStruct.
        MOV     a1, #DS1338_IIC_ADDR
        ; We can read the time directly into the RTCTimeStruct buffer
        ASSERT RTCTimeStruct_BCD_Minutes=RTCTimeStruct_BCD_Seconds+1
        ASSERT RTCTimeStruct_BCD_Hours=RTCTimeStruct_BCD_Seconds+2
        ASSERT RTCTimeStruct_BCD_DayOfMonth=RTCTimeStruct_BCD_Seconds+3
        ASSERT RTCTimeStruct_BCD_Month=RTCTimeStruct_BCD_Seconds+4
        ASSERT RTCTimeStruct_BCD_YearLO=RTCTimeStruct_BCD_Seconds+5
        ADD     a2, v3, #RTCTimeStruct_BCD_Seconds
        MOV     a3, #(DS_RTC_WDAY_REG - DS_RTC_SEC_REG)
        MOV     a4, #DS_RTC_SEC_REG
        BL      I2CBusRead
        CMP     a1, #IICStatus_Completed
        MOVNE   a1, #RTCRetCode_Error
        Pull    "v1-v3,sb,pc", NE
        ; read second part
        MOV     a1, #DS1338_IIC_ADDR
        ADD     a2, v3, #RTCTimeStruct_BCD_DayOfMonth
        MOV     a3, #(DS_RTC_YEAR_REG - DS_RTC_WDAY_REG)
        MOV     a4, #DS_RTC_DAY_REG
        BL      I2CBusRead
        CMP     a1, #IICStatus_Completed
        MOVNE   a1, #RTCRetCode_Error
        ASSERT  IICStatus_Completed = 0
        STREQB  a1, [v3, #RTCTimeStruct_BCD_Centiseconds] ; No centisecond time
        STREQB  a1, [v3, #RTCTimeStruct_BCD_YearHI] ; Kernel gives year help
        ASSERT  RTCRetCode_OK = 0
        Pull    "v1-v3,sb,pc"

DS_RTCWriteTime
        ; In:
        ; a1 = HALDevice ptr
        ; a2 = RTCTimeStruct ptr
        ; Out:
        ; a1 = return code
        Push    "v1-v3,sb,lr"
        LDR     sb, [a1, #RTCDeviceHAL_SB]
        ; check if we are called with interrupts disabled - do a polling transfer
        ; this can happen during the shutdown sequence
        MRS     v1, CPSR
        TST     v1, #I32_bit
        ADRNEL  v1, IIC_DoOp_Poll
        LDREQ   v1, OSentries+4*OS_IICOpV       ; for I2CBusWrite
        MOV     v2, #DS1338_IIC_BUS             ; specify I2C bus
        MOV     v3, a2
        ; Writing the time starting with DS_RTC_SEC_REG automatically synchronises the write.
        ; There is nothing else to do. But we must cope for differences in the register layout
        ; and the RTCTimeStruct (weekday register in between).
        ; We can write the time directly from the RTCTimeStruct buffer
        ASSERT RTCTimeStruct_BCD_Minutes=RTCTimeStruct_BCD_Seconds+1
        ASSERT RTCTimeStruct_BCD_Hours=RTCTimeStruct_BCD_Seconds+2
        ASSERT RTCTimeStruct_BCD_DayOfMonth=RTCTimeStruct_BCD_Seconds+3
        ASSERT RTCTimeStruct_BCD_Month=RTCTimeStruct_BCD_Seconds+4
        ASSERT RTCTimeStruct_BCD_YearLO=RTCTimeStruct_BCD_Seconds+5
        ADD     a2, v3, #RTCTimeStruct_BCD_Seconds
        ; Sometimes we don't write the time, so skip those bytes if necessary
        LDRB    ip, [a2]
        CMP     ip, #255
        BEQ     %FT10
        MOV     a1, #DS1338_IIC_ADDR
        MOV     a3, #(DS_RTC_WDAY_REG - DS_RTC_SEC_REG)
        MOV     a4, #DS_RTC_SEC_REG
        BL      I2CBusWrite
        CMP     a1, #IICStatus_Completed
        MOVNE   a1, #RTCRetCode_Error
        Pull    "v1-v3,sb,pc", NE
10
        ; write second part
        ; Sometimes we don't write the date either
        LDRB    ip, [v3, #RTCTimeStruct_BCD_DayOfMonth]
        CMP     ip, #255
        BEQ     %FT20
        MOV     a1, #DS1338_IIC_ADDR
        ADD     a2, v3, #RTCTimeStruct_BCD_DayOfMonth
        MOV     a3, #(DS_RTC_YEAR_REG - DS_RTC_WDAY_REG)
        MOV     a4, #DS_RTC_DAY_REG
        BL      I2CBusWrite
        CMP     a1, #IICStatus_Completed
        MOVNE   a1, #RTCRetCode_Error
        Pull    "v1-v3,sb,pc"
20
        MOV     a1, #RTCRetCode_OK
        Pull    "v1-v3,sb,pc"

        END
@


1.9
log
@Pass the right address to register the RTC
Spotted by Willi Theiss.

Version 0.91. Tagged as 'OMAP3-0_91'
@
text
@d35 2
d40 1
d69 71
d141 1
a141 1
        ; Just register our HAL Device with the OS
a144 1
        Push    "lr"
a145 1
        Pull    "lr"
d147 41
a187 2
        
        MOV     a2, a1
d189 1
d218 2
d359 100
@


1.8
log
@Refactor IIC calls to use RISCOS_IICOpV
- Comments and symbolic names for RTC register bits copied over from OMAP4 sources.
- Delete dead function ReadTimeForNVRAM.
- Use RTCFormatFlags_BCD_NeedsYearHelp flag for year 2070 compatibility.
- Moved CallOS macro into a header.
Tested on a Beagleboard xM, clock still worked over a power cycle.

Version 0.90. Tagged as 'OMAP3-0_90'
@
text
@d76 1
a77 1
        ADR     a2, RTCDevice
@


1.7
log
@Refactor HAL_VideoIICOp to be ATPCS
No longer specified to return _kernel_oserror * implements GraphicsV 14.
Make use of IICStatus defines instead of local copies.
Rename HAL_Video_ to HAL_Video.
Tested on Beagleboard xM, reading EDID from Hyundai monitor.

Version 0.69. Tagged as 'OMAP3-0_69'
@
text
@d38 1
a38 6

;       Note - debug stuff won't work since we don't get passed a HAL workspace pointer!
;        IMPORT  DebugHALPrint
;        IMPORT  DebugHALPrintReg
;        IMPORT  DebugMemDump
;        IMPORT  DebugHALPrintByte
d41 1
a41 1
TPSRTC_IIC     * &4b
d48 17
a64 13

        MACRO
        CallOS  $entry, $tailcall
        ASSERT  $entry <= HighestOSEntry
 [ "$tailcall"=""
        MOV     lr, pc
 |
   [ "$tailcall"<>"tailcall"
        ! 0, "Unrecognised parameter to CallOS"
   ]
 ]
        LDR     pc, OSentries + 4*$entry
        MEND
d68 8
d80 1
a80 1
RTCDevice
d96 4
a99 1
        DCB     RTCFormatFlags_BCD_1BasedDay+RTCFormatFlags_BCD_1BasedMonth+RTCFormatFlags_BCD_YearLOIsGood ; todo - add RTCFormatFlags_BCD_NeedsYearHelp once NVRAM is implemented
d105 1
a105 1
        DCB "TPS65950-compatible real-time clock",0
a122 2
        ; a3 = IICOp func ptr
        ; a4 = kernel workspace ptr
d126 3
a128 3
        Push    "v1-v3,lr"
        MOV     v1, a3
        MOV     v2, a4
d131 5
a135 2
        ; 1. Read RTC_STATUS_REG. If bit 1 is clear, the RTC is stopped and we can just assume its contents are invalid.
        ; 2. Set RTC_CTRL_REG=&41 (RTC running, GET_TIME set, 24hr mode). GET_TIME will read the time from the RTC circuitry and latch it into the time registers (the regular time registers, NOT the alarm ones as stated by the manual!)
d148 2
a149 2
        EOR     ip, ip, #2
        TSTEQ   ip, #2
d151 2
a152 2
        Pull    "v1-v3,pc", NE
        MOV     ip, #&41
d160 1
a160 1
        Pull    "v1-v3,pc", NE
a173 1
        Pull    "v1-v3,pc", NE
d175 2
a176 9
        STRB    a1, [v3, #RTCTimeStruct_BCD_Centiseconds] ; No centisecond time
        ; Construct a fakey YearHI by looking at YearLO
        ; Anything 70 or above is considered 1970+, else 2000+
        ; This should work OK, since RISC OS clamps the time to 1970 for unix compatability (or it does on boot, at least)
        LDRB    a2, [v3, #RTCTimeStruct_BCD_YearLO]
        CMP     a2, #&70
        MOVGE   a3, #&19
        MOVLT   a3, #&20
        STRB    a3, [v3, #RTCTimeStruct_BCD_YearHI]
d178 1
a178 1
        Pull    "v1-v3,pc"
a183 2
        ; a3 = IICOp func ptr
        ; a4 = kernel workspace ptr
d186 3
a188 3
        Push    "v1-v3,lr"
        MOV     v1, a3
        MOV     v2, a4
d191 2
a192 1
        ; 1. Write 0 to RTC_CTRL_REG to stop the clock (just in case there are any issues with the clock updating while it's being written to)
d205 1
a205 1
        Pull    "v1-v3,pc", NE
d231 1
a231 1
        Pull    "v1-v3,pc", NE
d233 1
a233 1
        MOV     a3, #1
d243 1
a243 16
        Pull    "v1-v3,pc"

        EXPORT  ReadTimeForNVRAM
        IMPORT  IIC_DoOp_Poll

; int ReadTimeForNVRAM (struct rtctime*)
; Reads BCD time into given rtctime struct
; Returns zero on success, non-zero on failure
ReadTimeForNVRAM
        MOV     a2, a1
        ADRL    a1, RTCDevice
        LDR     a3, HALInitialised
        CMP     a3, #0
        ADREQL  a3, IIC_DoOp_Poll
        LDRNE   a3, OSentries + 4 * OS_IICOpV
        B       RTCReadTime
@


1.6
log
@Line some things up.
To help OMAP4 tracking changes a number of the changes were purely cosmetic lining up differences, this change is where OMAP3 wasn't on a conventional column layout.

Version 0.61. Tagged as 'OMAP3-0_61'
@
text
@d133 1
a133 1
        CMP     a1, #ECOMPLETED
d146 1
a146 1
        CMP     a1, #ECOMPLETED
d161 1
a161 1
        CMP     a1, #ECOMPLETED
d164 1
a164 1
        ASSERT  ECOMPLETED = 0
d200 1
a200 1
        CMP     a1, #ECOMPLETED
d226 1
a226 1
        CMP     a1, #ECOMPLETED
d237 2
a238 2
        CMP     a1, #ECOMPLETED
        ASSERT  RTCRetCode_OK = ECOMPLETED
@


1.5
log
@Add Dave Higton's CMOS save code
Detail:
  Makefile - fixed warning about StdRules being included twice (via CModule)
  c/NVMem, c/fat, h/NVMem, h/common, h/fat, hdr/StaticWS, s/NVMemory, s/RTC - Added Dave Higton's code to create/update the 'CMOS' file on NVRAM writes
Admin:
  Tested on rev A2 BB-xM


Version 0.50. Tagged as 'OMAP3-0_50'
@
text
@d15 1
@


1.4
log
@Fix RTC code to handle the case where only the date or only the time should be updated
Detail:
  s/RTC - RISC OS will set the time members and/or the date members of the RTCTimeStruct to -1 when it doesn't want them updating.
  So skip writing those entries to the RTC if they're not meant to be updated!
Admin:
  Tested on rev C2 beagle.
  Fixes issue reported on forums with setting date from BASIC:
  http://www.riscosopen.org/forum/forums/4/topics/521


Version 0.37. Tagged as 'OMAP3-0_37'
@
text
@d65 1
a65 1
        
d223 1
a223 1
        BEQ     %FT01 ; Nothing left to write!  
d241 15
a255 1
        
@


1.3
log
@Update OMAP HAL to support different board configs, plus use new YearLOIsGood flag to ensure correct RTC handling, plus other misc tidying
Detail:
  The OMAP HAL now has multiple entry points, one per board config. See Top.s/board.s for more info.
  audio.s - Moved APLL_CTL value to board config
  board.s - New file to list all the settings for the different board configs
  boot.s - Change HAL_Init to deal with the new board config stuff
  debug.s - Debug UART now specified in board config
  GPIO.s - A few utility functions for handling OMAP/TPS GPIO pins
  I2C.s - Update to use new board config struct
  RAM.s - Disable the beagleboard-specific RAM init code. Instead we'll just rely on u-boot to initialise all our RAM for us.
  RTC.s - Get rid of the magic numbers, and use the YearLOIsGood flag to indicate to RISC OS that YearLO is 2-digit BCD
  Top.s - Got rid of old debug code and rewrote initial flow to handle detecting & storing the board config
  UART.s - Update to use board config struct, support multiple UARTs
  USB.s - Get EHCI PHY power GPIO from board config
  Video.s - Get DVI framer power GPIO and max pixel rate from board config. Add 'PassiveVideo' option, to build a driver that doesn't alter the video output settings - should hopefully result in a usable display on Touch Book, etc.
  board.hdr - Definition of board config table struct
  GPIO.hdr - Add lots of macros for handling OMAP GPIO pins, new constants for OMAP/TPS GPIO
  I2C.hdr - Added I2C transfer block struct, HAL I2C API transfer states (both moved here from other source files)
  omap3530.hdr - Move/remove some unwanted constants, disable DebugChar for now
  StaticWS.hdr - Move I2C transfer block struct to I2C.hdr, add board config struct to HAL workspace, get rid of unused 64K AllocArea
  Timers.hdr - Tidy up constants a bit
  UART.hdr - Add UARTCLK (moved from StaticWS.hdr), UART IRQ #'s
  Makefile - add GPIO.s
Admin:
  Tested on rev C2 beagleboard. Board configs for other board types may be inaccurate in a couple of places.


Version 0.19. Tagged as 'OMAP3-0_19'
@
text
@d213 11
d229 1
@


1.2
log
@Add sound support to OMAP3 HAL, plus other changes
Detail:
  hdr/Audio, s/Audio, Makefile, hdr/StaticWS, s/Boot - Add sound support to OMAP3 HAL. Should work with a TPS65950 connected to I2C1/McBSP2, as per beagleboard.
  s/TPS, s/RTC - Moved TPSRead, TPSWrite functions out of s/RTC and into their own file
  hdr/SDMA, s/SDMA - Add support for packet-based transfer (for audio), improve debug code, remove TestRAMToRAM test code
  s/I2C - Update to handle spurious RDR interrupts as mentioned in OMAP3 errata
  s/Video - Enable support for the larger porch & sync timing registers found in OMAP3 ES3.1 and above
Admin:
  Tested on rev C2 beagleboard


Version 0.18. Tagged as 'OMAP3-0_18'
@
text
@a30 1
        GET     hdr.I2C
d44 9
a64 7

; HAL API I2C transfer states
ECOMPLETED *    0
EINPROGRESS *   1
ENOACK  *       2
EBUSY   *       3
EERROR  *       5
d88 1
a88 1
        DCB     RTCFormatFlags_BCD_1BasedDay+RTCFormatFlags_BCD_1BasedMonth ; todo - add RTCFormatFlags_BCD_NeedsYearHelp once NVRAM is implemented
d126 1
a126 1
        MOV     a1, #&4b*2
d129 1
a129 1
        MOV     a4, #&2a ; RTC_STATUS_REG
d142 2
a143 2
        MOV     a1, #&4b*2
        MOV     a4, #&29 ; RTC_CTRL_REG
d149 1
a149 1
        MOV     a1, #&4b*2
d158 1
a158 1
        MOV     a4, #&1c ; SECONDS_REG
d192 1
a192 1
        MOV     a1, #&4b*2
d196 1
a196 1
        MOV     a4, #&29 ; RTC_CTRL_REG
d203 1
a203 1
        MOV     a1, #&4b*2
d212 1
a212 1
        MOV     a4, #&1c ; SECONDS_REG
d221 2
a222 2
        MOV     a4, #&29 ; RTC_CTRL_REG
        MOV     a1, #&4b*2
@


1.1
log
@Add HAL RTC support to OMAP3 kernel, improve IIC code
Detail:
  s/RTC - Implementation of new HAL RTC API. Uses the RTC built into the TWL/TPS companion chip.
  s/Boot - Initialise RTC HALDevice
  s/I2C - Add workaround for apparent hardware limitation of the OMAP I2C controllers; where appropriate multiple iic_transfers will now be merged together into one transfer, to ensure that a start bit is always sent at the start of each transfer
  hdr/omap3530 - Tweak DebugReg and DebugRegByte to allow LR to be output
  Makefile - add s.RTC to list of files. Fix GPADBG definition to not conflict with the 'gpa' folder that one of the makefile fragments creates.
Admin:
  Tested on rev C2 beagleboard


Version 0.13. Tagged as 'OMAP3-0_13'
@
text
@d36 2
a96 75
TPSRead
        ; a1 = IIC address(*2)
        ; a2 = buffer
        ; a3 = count
        ; a4 = start register
        ; v1 = IIC func
        ; v2 = IIC param
        ; out:
        ; a1 = return code
        ; ip corrupted
        ; buffer updated
        ORR     a1, a1, #1 ; read
        Push    "a1-a4,lr" ; Push regs and second iic_transfer block
        EOR     a1, a1, #1+(1:SHL:29) ; write with retry
        ADD     a2, sp, #12
        MOV     a3, #1
        Push    "a1-a3" ; push first iic_transfer block
        MOV     a1, sp
        MOV     a2, #2
        MOV     a3, v2
        MOV     lr, pc
        MOV     pc, v1
        ADD     sp, sp, #16
        Pull    "a2-a4,pc"

TPSWrite
        ; a1 = IIC address(*2)
        ; a2 = buffer
        ; a3 = count
        ; a4 = start register
        ; v1 = IIC func
        ; v2 = IIC param
        ; out:
        ; a1 = return code
        ; ip corrupted
        ORR     a1, a1, #1:SHL:31 ; Write (no start bit)
        Push    "a1-a4,lr" ; Push regs and second iic_transfer block
        EOR     a1, a1, #(1:SHL:29)+(1:SHL:31) ; Write (retries)
        ADD     a2, sp, #12
        MOV     a3, #1
        Push    "a1-a3" ; push first iic_transfer block
        MOV     a1, sp
        MOV     a2, #2
        MOV     a3, v2
        MOV     lr, pc
        MOV     pc, v1
        ADD     sp, sp, #16
        Pull    "a2-a4,pc"
        ; Hack version to get around nostart bug
;        Push    "a2-a4,v3-v5,lr"
;        MOV     v4, sp
;        ; Copy the write data to the stack
;        MOV     v5, a3
;10
;        SUBS    v5, v5, #1
;        LDRB    ip, [a2,v5]
;        STRB    ip, [sp,#-1]!
;        BNE     %BT10
;        ; Add the TPS register address
;        STRB    a4, [sp,#-1]!
;        MOV     a2, sp
;        ADD     a3, a3, #1
;        BIC     sp, sp, #3 ; round sp to word address
;        ORR     a1, a1, #(1:SHL:29) ; Write (retries)
;        Push    "a1-a3" ; push iic_transfer block
;        MOV     a1, sp
;        MOV     a2, #1
;        MOV     a3, v2
;        MOV     lr, pc
;        MOV     pc, v1
;        MOV     sp, v4 ; restore original sp
;        Pull    "a2-a4,v3-v5,pc"
        


@


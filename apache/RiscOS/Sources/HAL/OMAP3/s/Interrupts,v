head	1.16;
access;
symbols
	OMAP3-1_18:1.16
	OMAP3-1_17:1.16
	OMAP3-1_16:1.16
	OMAP3-1_15:1.16
	OMAP3-1_14:1.16
	SMP:1.16.0.2
	SMP_bp:1.16
	OMAP3-1_13:1.16
	OMAP3-1_12:1.16
	OMAP3-1_11:1.16
	OMAP3-1_10:1.16
	OMAP3-1_09:1.16
	OMAP3-1_08:1.15
	OMAP3-1_07:1.15
	OMAP3-1_06:1.15
	OMAP3-1_05:1.15
	OMAP3-1_04:1.15
	OMAP3-1_03:1.14
	OMAP3-1_02:1.14
	OMAP3-1_01:1.14
	OMAP3-1_00:1.14
	OMAP3-0_99:1.14
	OMAP3-0_98:1.14
	OMAP3-0_97:1.14
	OMAP3-0_96:1.14
	OMAP3-0_95:1.14
	OMAP3-0_94:1.13
	OMAP3-0_93:1.13
	OMAP3-0_92:1.13
	OMAP3-0_91:1.13
	OMAP3-0_90:1.13
	OMAP3-0_89:1.13
	OMAP3-0_88:1.13
	OMAP3-0_87:1.13
	OMAP3-0_86:1.13
	OMAP3-0_85:1.13
	OMAP3-0_84:1.12
	OMAP3-0_83:1.12
	OMAP3-0_82:1.12
	OMAP3-0_81:1.12
	OMAP3-0_80:1.12
	OMAP3-0_79:1.12
	OMAP3-0_78:1.12
	OMAP3-0_77:1.12
	OMAP3-0_76:1.12
	OMAP3-0_75:1.12
	OMAP3-0_74:1.12
	OMAP3-0_73:1.12
	OMAP3-0_72:1.12
	OMAP3-0_71:1.12
	OMAP3-0_70:1.12
	OMAP3-0_69:1.12
	OMAP3-0_68:1.12
	OMAP3-0_67:1.12
	OMAP3-0_66:1.12
	OMAP3-0_65:1.12
	OMAP3-0_64:1.12
	OMAP3-0_63:1.11
	OMAP3-0_62:1.11
	OMAP3-0_61:1.11
	OMAP3-0_60:1.10
	OMAP3-0_59:1.10
	OMAP3-0_58:1.10
	OMAP3-0_57:1.10
	OMAP3-0_56:1.10
	OMAP3-0_55:1.10
	OMAP3-0_54:1.10
	OMAP3-0_53:1.10
	OMAP3-0_52:1.10
	OMAP3-0_51:1.10
	OMAP3-0_50:1.10
	OMAP3-0_49:1.10
	OMAP3-0_48:1.10
	OMAP3-0_47:1.10
	OMAP3-0_46:1.10
	OMAP3-0_45:1.10
	OMAP3-0_44:1.10
	OMAP3-0_43:1.10
	OMAP3-0_42:1.10
	OMAP3-0_41:1.10
	OMAP3-0_40:1.10
	OMAP3-0_39:1.10
	OMAP3-0_38:1.10
	OMAP3-0_37:1.10
	OMAP3-0_36:1.10
	OMAP3-0_35:1.10
	OMAP3-0_34:1.10
	OMAP3-0_33:1.10
	OMAP3-0_32:1.10
	OMAP3-0_31:1.10
	OMAP3-0_30:1.10
	OMAP3-0_29:1.10
	OMAP3-0_28:1.10
	OMAP3-0_27:1.9
	OMAP3-0_26:1.9
	OMAP3-0_25:1.9
	OMAP3-0_24:1.9
	OMAP3-0_23:1.9
	OMAP3-0_22:1.8
	OMAP3-0_21:1.8
	OMAP3-0_20:1.7
	OMAP3-0_19:1.7
	OMAP3-0_18:1.7
	OMAP3-0_17:1.7
	OMAP3-0_16:1.7
	OMAP3-0_15:1.6
	OMAP3-0_14:1.5
	OMAP3-0_13:1.5
	OMAP3-0_12:1.5
	OMAP3-0_11:1.4
	OMAP3-0_10:1.4
	OMAP3-0_09:1.4
	OMAP3-0_08:1.4
	OMAP3-0_07:1.3
	OMAP3-0_06:1.3
	OMAP3-0_05:1.3
	OMAP3-0_04:1.3
	OMAP3-0_03:1.3
	OMAP3-0_02:1.2
	OMAP3-0_01:1.1;
locks; strict;
comment	@# @;


1.16
date	2016.05.06.21.36.30;	author jlee;	state Exp;
branches;
next	1.15;
commitid	JTxsHfHHRMZW4t5z;

1.15
date	2015.04.08.07.37.49;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	KMkj6KKX1Lup6Lgy;

1.14
date	2014.03.08.16.59.12;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	CdtiAiQ8vMQbWUrx;

1.13
date	2013.01.22.23.24.13;	author jlee;	state Exp;
branches;
next	1.12;
commitid	Almuk1cqEHQnfgBw;

1.12
date	2012.06.04.23.45.11;	author jlee;	state Exp;
branches;
next	1.11;
commitid	m70jrk0mZm9UOr7w;

1.11
date	2012.03.25.11.49.07;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	c99VvmwezV2J8gYv;

1.10
date	2010.06.23.22.30.33;	author jlee;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.28.19.47.14;	author jlee;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.30.00.23.20;	author jlee;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.28.22.30.57;	author jlee;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.07.03.22.50;	author jlee;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.17.00.16.37;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.09.19.04.58;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.06.23.35.43;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2009.02.21.18.51.47;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.02.01.13.58.05;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Implement HAL_TimerIRQClear
Detail:
  s/Boot, s/Interrupts, s/Timers - Move timer IRQ clear code out of HAL_IRQClear and into HAL_TimerIRQClear. Streamlines HAL_IRQClear and allows timers to be used by FIQ handlers.
Admin:
  Tested on BB-xM


Version 1.09. Tagged as 'OMAP3-1_09'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:OSEntries

        GET     hdr.omap3530
        GET     hdr.StaticWS
        GET     hdr.Interrupts

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  Interrupt_Init
        EXPORT  HAL_IRQEnable
        EXPORT  HAL_IRQDisable
        EXPORT  HAL_IRQClear
        EXPORT  HAL_IRQSource
        EXPORT  HAL_IRQStatus
        EXPORT  HAL_FIQEnable
        EXPORT  HAL_FIQDisable
        EXPORT  HAL_FIQDisableAll
        EXPORT  HAL_FIQClear
        EXPORT  HAL_FIQSource
        EXPORT  HAL_FIQStatus
        EXPORT  HAL_IRQMax

; Debug flag to cause the DebugInterrupts noncleared IRQ detection code to disable the source of the noncleared interrupt. This can be useful in debugging issues that cause the nonclearance of the IRQ, e.g. if an IRQ handler aborts before it's able to call IRQClear.
                      GBLL    DebugDisablePrevious
DebugDisablePrevious  SETL    {FALSE}

Interrupt_Init
        ; 1. Program the MPU_INTC.INTCPS_SYSCONFIG reg. If necessary, enable the interface clock autogating by setting the AUTOIDLE bit
        ; 2. Program the MPU_INTC.INTCPS_IDLE reg. If necessary, disable functional clock autogating or enable synchronizer autogating by setting the FUNCIDLE bit or TURBO bit accordingly
        ; 3. Program the MPU_INTC.INTCPS_ILRm register for each interrupt line; assign a priority level and set the FIQNFIQ bit
        ; 4. Program the MPU_INTC.INTCPS_MIRn register to enable the required interrupts
        LDR     a1, MPU_INTC_Log
        MOV     a2, #2 ; Trigger INTCPS soft reset
        STR     a2, [a1, #INTCPS_SYSCONFIG]
        ; Wait  for completion
10
        LDR     a2, [a1, #INTCPS_SYSSTATUS]
        TST     a2, #1
        BEQ     %BT10
        ; Enable autoidle
        MOV     a2, #1
        STR     a2, [a1, #INTCPS_SYSCONFIG]
        ; ... and everything else looks good?
 [ DebugInterrupts
        MOV     a1, #-1
        STR     a1, LastInterrupt_IRQ
        STR     a1, LastInterrupt_FIQ
  [ ExtraDebugInterrupts
        MOV     a1, #0
        STR     a1, ExtraDebugIRQEnabled
  ]
 ]
        MOV     pc, lr
        
HAL_IRQEnable
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        ; Disable interrupts while we update the controller
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        ; Set the interrupt type & priority, and then unmask it
        MOV     a2, #32<<2 ; mid-priority for all IRQs.
        LDR     a3, MPU_INTC_Log
        ADD     ip, a3, #INTCPS_ILR
        ASSERT  INTCPS_ILR_SIZE = 4
        STR     a2, [ip, a1, LSL #2]
        AND     a2, a1, #&1F ; Mask bit
        MOV     a1, a1, LSR #5 ; BITS index
        ASSERT  INTCPS_BITS_SIZE = 32
        ADD     ip, a3, a1, LSL #5
        MOV     a1, #1
        MOV     a2, a1, LSL a2
        LDR     a1, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
        STR     a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_CLEAR] ; Write to clear reg to set new state
        MSR     CPSR_c, a4 ; Re-enable interrupts
        MVN     a1, a1 ; Invert so we get a mask of enabled interrupts
        AND     a1, a1, a2 ; Test if it was enabled or not
        MOV     pc, lr
        
HAL_IRQDisable
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        Push    "lr"
        ; Disable interrupts while we update the controller (not necessarily needed for disabling them?)
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        ; Check if this is actually an IRQ
        LDR     a3, MPU_INTC_Log
        ASSERT  INTCPS_ILR_SIZE = 4
        ADD     a2, a3, a1, LSL #2
        LDR     a2, [a2, #INTCPS_ILR]
        TST     a2, #1
        MOVNE   a1, #0 ; This is an FIQ, so don't disable it
        MSRNE   CPSR_c, a4
        Pull    "pc", NE
        ; Now mask the interrupt
        AND     a2, a1, #&1F ; Mask bit
        MOV     lr, a1, LSR #5 ; BITS index
        ASSERT  INTCPS_BITS_SIZE = 32
        ADD     ip, a3, lr, LSL #5
        MOV     lr, #1
        MOV     a2, lr, LSL a2
        LDR     lr, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
        STR     a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_SET] ; Mask the interrupt
        ; Check if we just disabled the active interrupt
        LDR     ip, [a3, #INTCPS_SIR_IRQ]
        CMP     ip, a1
        MOVEQ   ip, #1
        STREQ   ip, [a3, #INTCPS_CONTROL]
 [ DebugInterrupts
        MOVEQ   ip, #-1
        STREQ   ip, LastInterrupt_IRQ
 ]
        MSR     CPSR_c, a4 ; Re-enable interrupts
        BIC     a1, a2, lr ; Clear the masked interrupts from a2 to get nonzero result if it was enabled
        Pull    "pc"

HAL_IRQClear
 [ ExtraDebugInterrupts
        LDR     a2, ExtraDebugIRQEnabled
        CMP     a2, #0
        BEQ     %FT10
        Push    "lr"
        DebugReg a1, "HAL_IRQClear: "
        Pull    "lr"
10
 ]
        LDR     a2, MPU_INTC_Log
        MOV     a1, #1
        STR     a1, [a2, #INTCPS_CONTROL]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
 [ DebugInterrupts
        MOV     a1, #-1
        STR     a1, LastInterrupt_IRQ
 ]
        MOV     pc, lr

HAL_IRQSource
 [ DebugInterrupts
        LDR     a1, LastInterrupt_IRQ
        CMP     a1, #0
        BLT     %FT10
        Push    "lr"
        BL      DebugHALPrint
        =       "HAL_IRQSource: Previous IRQ not cleared: ", 0
        DebugReg a1
  [ DebugDisablePrevious
        BL      HAL_IRQDisable
  ]
  [ ExtraDebugInterrupts
    [ :LNOT: DebugDisablePrevious ; Doesn't play nice with this since it'll just spam the HAL_IRQClear messages
        STR     pc, ExtraDebugIRQEnabled ; any nonzero value will do
    ]
        MOV     lr, pc ; BL to the main routine so we can get the exit code
        B       %FT05
        DebugReg a1, "HAL_IRQSource: New IRQ: "
        Pull    "pc"
05
  |
        Pull    "lr"
  ]
10
 ]
        ; Does the ARM think an interrupt is occuring?
        MRC     p15, 0, a1, c12, c1, 0
        TST     a1, #I32_bit
        MOVEQ   a1, #-1
 [ DebugInterrupts
        STREQ   a1, LastInterrupt_IRQ
 ]
        MOVEQ   pc, lr
        LDR     a2, MPU_INTC_Log
        LDR     a1, [a2, #INTCPS_SIR_IRQ]
        CMP     a1, #INTERRUPT_MAX
        ANDLO   a1, a1, #&7F
 [ DebugInterrupts
        STRLO   a1, LastInterrupt_IRQ
 ]
        MOVLO   pc, lr
        ; Authentic spurious interrupt - restart INTC and return -1
        MOV     a1, #-1
 [ DebugInterrupts
        STR     a1, LastInterrupt_IRQ
 ]
        MOV     a3, #1
        STR     a3, [a2, #INTCPS_CONTROL]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
        MOV     pc, lr

HAL_IRQStatus
        ; Test if IRQ is firing, irrespective of mask state
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        ; First we need to make sure this is an IRQ, not an FIQ?
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        LDR     a2, MPU_INTC_Log
        ASSERT  INTCPS_ILR_SIZE = 4
        ADD     a3, a2, a1, LSL #2
        LDR     a3, [a3, #INTCPS_ILR]
        TST     a3, #1
        MOVNE   a1, #0 ; This is an FIQ, so it can't fire for IRQ
        MSRNE   CPSR_c, a4
        MOVNE   pc, lr
        ; Now check if it's firing
        ASSERT  INTCPS_BITS_SIZE = 32
        MOV     a3, a1, LSR #5
        ADD     a3, a2, a3, LSL #5
        LDR     a3, [a3, #INTCPS_BITS+INTCPS_BITS_ITR]
        MSR     CPSR_c, a4
        AND     a1, a1, #31
        MOV     a1, a3, LSR a1 ; Shift and invert so 1=active
        AND     a1, a1, #1 ; 0 = not firing, 1 = firing
        MOV     pc, lr        

HAL_FIQEnable
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        ; Disable interrupts while we update the controller
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        ; Set the interrupt type & priority, and then unmask it
        MOV     a2, #1 ; highest priority for all FIQs.
        LDR     a3, MPU_INTC_Log
        ADD     ip, a3, #INTCPS_ILR
        ASSERT  INTCPS_ILR_SIZE = 4
        STR     a2, [ip, a1, LSL #2]
        AND     a2, a1, #&1F ; Mask bit
        MOV     a1, a1, LSR #5 ; BITS index
        ASSERT  INTCPS_BITS_SIZE = 32
        ADD     ip, a3, a1, LSL #5
        MOV     a1, #1
        MOV     a2, a1, LSL a2
        LDR     a1, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
        STR     a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_CLEAR] ; Write to clear reg to set new state
        MSR     CPSR_c, a4 ; Re-enable interrupts
        MVN     a1, a1 ; Invert so we get a mask of enabled interrupts
        AND     a1, a1, a2 ; Test if it was enabled or not
        MOV     pc, lr

HAL_FIQDisable
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        Push    "lr"
        ; Disable interrupts while we update the controller (not necessarily needed for disabling them?)
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        ; Check if this is actually an FIQ
        LDR     a3, MPU_INTC_Log
        ASSERT  INTCPS_ILR_SIZE = 4
        ADD     a2, a3, a1, LSL #2
        LDR     a2, [a2, #INTCPS_ILR]
        TST     a2, #1
        MOVEQ   a1, #0 ; This is an IRQ, so don't disable it
        MSREQ   CPSR_c, a4
        Pull    "pc", EQ
        ; Now mask the interrupt
        AND     a2, a1, #&1F ; Mask bit
        MOV     lr, a1, LSR #5 ; BITS index
        ASSERT  INTCPS_BITS_SIZE = 32
        ADD     ip, a3, lr, LSL #5
        MOV     lr, #1
        MOV     a2, lr, LSL a2
        LDR     lr, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
        STR     a2, [ip, #INTCPS_BITS+INTCPS_BITS_MIR_SET] ; Mask the interrupt
        ; Check if we just disabled the active interrupt
        LDR     ip, [a3, #INTCPS_SIR_FIQ]
        CMP     ip, a1
        MOVEQ   ip, #2
        STREQ   ip, [a3, #INTCPS_CONTROL]
 [ DebugInterrupts
        MOVEQ   ip, #-1
        STREQ   ip, LastInterrupt_FIQ
 ]
        MSR     CPSR_c, a4 ; Re-enable interrupts
        BIC     a1, a2, lr ; Clear the masked interrupts from a2 to get nonzero result if it was enabled
        Pull    "pc"

HAL_FIQDisableAll
        ; This isn't particularly great, we need to scan the entire ILR array
        ; and work out which are FIQs, and then write to the ISR_SET registers
        ; We should probably keep our own array of enabled FIQs so this can be
        ; done more quickly
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        LDR     a1, MPU_INTC_Log
        ADD     a1, a1, #INTCPS_ILR
        MOV     a2, #1 ; Mask to write
        ADD     a3, a1, #INTCPS_BITS+INTCPS_BITS_MIR_SET-INTCPS_ILR
HAL_FIQDisableAll_Loop1
        LDR     ip, [a1],#INTCPS_ILR_SIZE
        TST     ip, #1 ; 1=FIQ, 0=IRQ
        STRNE   a2, [a3] ; Disable it
        MOVS    a2, a2, LSL #1
        BCC     HAL_FIQDisableAll_Loop1
        ; Move on to next word
        MOV     a2, #1
        ADD     a3, a3, #INTCPS_BITS_SIZE
HAL_FIQDisableAll_Loop2
        LDR     ip, [a1],#INTCPS_ILR_SIZE
        TST     ip, #1 ; 1=FIQ, 0=IRQ
        STRNE   a2, [a3] ; Disable it
        MOVS    a2, a2, LSL #1
        BCC     HAL_FIQDisableAll_Loop2
        ; Move on to last word
        MOV     a2, #1
        ADD     a3, a3, #INTCPS_BITS_SIZE
HAL_FIQDisableAll_Loop3
        LDR     ip, [a1],#INTCPS_ILR_SIZE
        TST     ip, #1 ; 1=FIQ, 0=IRQ
        STRNE   a2, [a3] ; Disable it
        MOVS    a2, a2, LSL #1
        BCC     HAL_FIQDisableAll_Loop3
        ; Done
        ASSERT  INTCPS_BITS_COUNT = 3
        MSR     CPSR_c, a4
        ; FIQDisableAll is only called during emergency situations, so restart INTC priority sorting to avoid having to rewrite various bits of RISC OS code to query FIQ sources and call FIQClear on each one (which would otherwise be the only legal way of stopping all FIQs from firing)
        LDR     a2, MPU_INTC_Log
        MOV     a1, #2
        STR     a1, [a2, #INTCPS_CONTROL]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
 [ DebugInterrupts
        MOV     a1, #-1
        STR     a1, LastInterrupt_FIQ
 ]
        MOV     pc, lr

HAL_FIQClear
        ; Restart INTC priority sorting
        LDR     a2, MPU_INTC_Log
        MOV     a1, #2
        STR     a1, [a2, #INTCPS_CONTROL]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
 [ DebugInterrupts
        MOV     a1, #-1
        STR     a1, LastInterrupt_FIQ
 ]
        MOV     pc, lr

HAL_FIQStatus
        ; Test if FIQ is firing, irrespective of mask state
        CMP     a1, #INTERRUPT_MAX
        MOVHS   a1, #0
        MOVHS   pc, lr
        ; First we need to make sure this is an FIQ, not an IRQ?
        MRS     a4, CPSR
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        LDR     a2, MPU_INTC_Log
        ASSERT  INTCPS_ILR_SIZE = 4
        ADD     a3, a2, a1, LSL #2
        LDR     a3, [a3, #INTCPS_ILR]
        TST     a3, #1
        MOVEQ   a1, #0 ; This is an IRQ, so it can't fire for FIQ
        MSREQ   CPSR_c, a4
        MOVEQ   pc, lr
        ; Now check if it's firing
        ASSERT  INTCPS_BITS_SIZE = 32
        MOV     a3, a1, LSR #5
        ADD     a3, a2, a3, LSL #5
        LDR     a3, [a3, #INTCPS_BITS+INTCPS_BITS_ITR]
        MSR     CPSR_c, a4
        AND     a1, a1, #31
        MOV     a1, a3, LSR a1 ; Shift and invert so 1=active
        AND     a1, a1, #1 ; 0 = not firing, 1 = firing
        MOV     pc, lr        

HAL_FIQSource
 [ DebugInterrupts
        LDR     a1, LastInterrupt_FIQ
        CMP     a1, #0
        BLT     %FT10
        Push    "lr"
        BL      DebugHALPrint
        =       "HAL_FIQSource: Previous FIQ not cleared: ", 0
        DebugReg a1
        Pull    "lr"
10
 ]
        ; Does the ARM think an interrupt is occuring?
        MRC     p15, 0, a1, c12, c1, 0
        TST     a1, #F32_bit
        MOVEQ   a1, #-1
 [ DebugInterrupts
        STREQ   a1, LastInterrupt_FIQ
 ]
        MOVEQ   pc, lr
        LDR     a2, MPU_INTC_Log
        LDR     a1, [a2, #INTCPS_SIR_FIQ]
        CMP     a1, #INTERRUPT_MAX
        ANDLO   a1, a1, #&7F
 [ DebugInterrupts
        STRLO   a1, LastInterrupt_FIQ
 ]
        MOVLO   pc, lr
        ; Authentic spurious interrupt - restart INTC and return -1
        MOV     a1, #-1
 [ DebugInterrupts
        STR     a1, LastInterrupt_FIQ
 ]
        MOV     a3, #2
        STR     a3, [a2, #INTCPS_CONTROL]
        ; Data synchronisation barrier to make sure INTC gets the message
        DSB     SY
        MOV     pc, lr

HAL_IRQMax
        MOV     a1, #INTERRUPT_MAX
        MOV     pc, lr

        END
@


1.15
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Rename a couple of symbols in PAudio missed in OMAP3-1_03.
Built, but not tested.


Version 1.04. Tagged as 'OMAP3-1_04'
@
text
@a26 1
        GET     hdr.Timers
a143 2
        ; This routine is used to clear the timer & vsync interrupts
        ; It must also restart the INTC priority sorting, as it is called after every OS IRQ handler silences the interrupting device
a152 8
        SUB     a2, a1, #TIMER_IRQ_BASE
        CMP     a2, #TIMER_MAX
        BHS     %FT10
        LDR     a1, Timers_Log
        MOV     a3, #7 ; Clear all interrupts
        ADD     a1, a1, a2, LSL #TIMER_STRIDE_POW2
        STR     a3, [a1, #TISR]
10
@


1.14
log
@Use DSB/ISB directly
Reflects similar change in OMAP4-0_28.
Built, but not tested.

Version 0.95. Tagged as 'OMAP3-0_95'
@
text
@a44 6
 [ DebugInterrupts
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
        IMPORT  DebugHALPrintByte
 ]

@


1.13
log
@Implement HAL_IRQMax
Detail:
  s/Boot, s/Interrupts - Added HAL_IRQMax implementation, to ensure correct functionality with latest Kernel
Admin:
  Tested on BB-xM
  Requires Kernel-5_35-4_79_2_182


Version 0.85. Tagged as 'OMAP3-0_85'
@
text
@a27 1
        GET     hdr.CoPro15ops
d174 1
a174 1
        myDSB
d231 1
a231 1
        myDSB
d373 1
a373 1
        myDSB
d386 1
a386 1
        myDSB
d457 1
a457 1
        myDSB
@


1.12
log
@Add HAL_UARTDefault implementation. Delete old HAL video code. Add some SmartReflex tweaks.
Detail:
  hdr/board, s/board, s/Boot, s/UART - Added HAL_UARTDefault implementation, to allow OS_SerialOp to be used
  hdr/StaticWS, hdr/omap3530, s/Boot, s/Interrupts, s/Video - Removed old HAL video code. The OMAPVideo module is a much better video driver.
  s/SR37x - Add some SmartReflex tweaks which we can try if we run into any stability issues with the current code.
Admin:
  Tested on rev A2 BB-xM


Version 0.64. Tagged as 'OMAP3-0_64'
@
text
@d44 1
d461 4
@


1.11
log
@Line some things up.
To help OMAP4 tracking changes a number of the changes were purely cosmetic lining up differences, this change is where OMAP3 wasn't on a conventional column layout.

Version 0.61. Tagged as 'OMAP3-0_61'
@
text
@a161 7
 [ HALDoesVideo
        CMP     a1, #VIDEO_IRQ
        LDREQ   a2, L4_Display_Log
        MVNEQ   a3, #0 ; Clear all DSS IRQs, just in case
        STREQ   a3, [a2, #DISPC_IRQSTATUS]
        BEQ     %FT10
 ]
@


1.10
log
@Update OMAP3 HAL to use correct instruction/memory barrier operations and to handle branch target predictors
Detail:
  hdr/Copro15ops - Added myISB, myDSB, myDMB macros to provide barrier functionality for ARMv6+
  s/Boot, s/Interrupts, s/RAM, s/Top, s/Video - updated to use correct barrier operations after CP15 writes, and to invalidate branch predictors where appropriate
Admin:
  Tested on rev C2 beagleboard


Version 0.28. Tagged as 'OMAP3-0_28'
@
text
@d15 1
@


1.9
log
@Update OMAP3 HAL to support new OMAPVideo module, plus other minor changes
Detail:
  hdr/StaticWS, hdr/Video, hdr/board, hdr/omap3530, s/Boot, s/Video, s/board - Add new HALDoesVideo switch to control whether the HAL provides the video driver or whether a HAL device is used to expose the video hardware to the OMAPVideo module. Switch defaults to the 'off' state, i.e. OMAPVideo provides the video driver. Also updated the board config struct to contain more detailed information about the video capabilities of each board.
  s/Audio - fix the FIFO underflow/overflow IRQ handler to disable the IRQ after the underflow/overflow has been detection. This prevents the OS from (potentially) getting stuck in a loop servicing the interrupt and never reaching the state where it can shut down & re-initialise the audio to fix the error properly.
  s/Debug - add DebugCallstack function that disables IRQs/FIQs and dumps the stack contents over the serial port
Admin:
  Tested on rev C2 beagleboard.


Version 0.23. Tagged as 'OMAP3-0_23'
@
text
@d180 1
a180 2
        MOV     a3, #0
        MCR     ARM_config_cp, 0, a3, C7, C10, 4
d237 1
a237 2
        MOV     a3, #0
        MCR     ARM_config_cp, 0, a3, C7, C10, 4
d379 1
a379 2
        MOV     a3, #0
        MCR     ARM_config_cp, 0, a3, C7, C10, 4
d392 1
a392 2
        MOV     a3, #0
        MCR     ARM_config_cp, 0, a3, C7, C10, 4
d463 1
a463 2
        MOV     a3, #0
        MCR     ARM_config_cp, 0, a3, C7, C10, 4
@


1.8
log
@Various OMAP3 HAL power management improvements, plus add support for board config autodetection via Linux machine ID
Detail:
  s/board, hdr/board - Add Linux machine ID & available mixer channels to board config table
  s/Top - Add new entry point at offset &64, for booting as a fake Linux kernel. Searches the board config table until it finds a config matching the machine ID passed in R1. Also minor ROM copy optimisation, unsigned pointer comparison fixes
  s/Audio, hdr/Audio - Use board config to lock-out mixer channels that aren't connected to any hardware, to avoid excessive power drain or other problems if the channels get turned on. Also perform many other setting tweaks to tidy up default settings for unused mixer paths/channels.
  s/Video - Fix Video_Init logic when deciding whether to reset DSS, enable DSI PLL drift guard
  s/I2C - Increase I2C timeout values, since the previous values were perhaps a bit low
  s/Audio, s/I2C, s/Interrupts, s/RAM, s/SDMA, s/Timers, s/UART, hdr/UART, s/USB, s/Video - Enable autoidle/smart idle where possible to help save power.
Admin:
  Tested on rev C2 beagleboard


Version 0.21. Tagged as 'OMAP3-0_21'
@
text
@a27 1
        GET     hdr.Video
d47 1
d160 2
a161 1
 ] 
d167 1
@


1.7
log
@OMAP3 DMA support, video device, debugging improvements
Detail:
  Boot.s - Make FIQDebug work again
  Boot.s - Add support for DMA & video devices
  Interrupts.s, hdr/omap3530 - Add 'ExtraDebugInterrupts' option
  hdr/SDMA, SDMA.s, Makefile - DMA code which presents itself to RISC OS as a set of single-buffered, interrupt-driven DMA channels.
  hdr/StaticWS - Add extra DMA, video & debug entries to workspace
  Interrupts.s - Add 'DebugDisablePrevious' debug option for more flexibility in tracking down noncleared IRQs with ExtraDebugInterrupts
  RAM.s - Use DMA to clear RAM on boot. RAM clear now takes less than 1 second on a rev C board, whereas before it used to take several.
  Video.s - Add simple HAL device to expose information needed by upcoming RISC OS module based video driver.
Admin:
  Tested on rev C2 beagleboard.


Version 0.16. Tagged as 'OMAP3-0_16'
@
text
@d62 8
@


1.6
log
@Fix bug in HAL_IRQDisable/HAL_FIQDisable in OMAP3 HAL
Detail:
  The code which checks if you've just disabled the active interrupt was broken and was dereferencing a bad pointer, causing (a) bad things, and (b) failure when alignment exceptions are turned on. This change fixes that, so the change I checked in a couple of hours ago won't cause the OS to crash anymore!
Admin:
  Tested on rev C2 beagleboard.


Version 0.15. Tagged as 'OMAP3-0_15'
@
text
@d50 4
d67 4
d143 10
a152 1
        ; It must also restart the INTC priority sorting, as it is called after every OS IRQ handler silences the interrupting device 
d187 13
d201 1
@


1.5
log
@Add I2C support to OMAP3 HAL. Fix FIQ handling. Improve debugging code.
Detail:
  Makefile, s/Boot, s/I2C, hdr/I2C, hdr/StaticWS - Adds I2C support to the OMAP3 HAL, via both HAL_IIC* and HAL_Video_IICOp.
  s/Interrupts - Fix bug causing incorrect clearing of FIQs
  s/Debug, s/Boot, hdr/omap3530 - Improve debugging code, and add simple FIQ debugger that outputs the PC to the serial port when the beagleboard USER button is pressed
  s/Stubs - Remove old stub functions
Admin:
  Tested on rev C2 beagleboard


Version 0.12. Tagged as 'OMAP3-0_12'
@
text
@d118 1
a118 1
        LDR     a3, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
d121 1
a121 1
        LDR     ip, [lr, #INTCPS_SIR_IRQ]
d124 1
a124 1
        STREQ   ip, [lr, #INTCPS_CONTROL]
d130 1
a130 1
        BIC     a1, a2, a3 ; Clear the masked interrupts from a2 to get nonzero result if it was enabled
d281 1
a281 1
        LDR     a3, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
d284 1
a284 1
        LDR     ip, [lr, #INTCPS_SIR_FIQ]
d287 1
a287 1
        STREQ   ip, [lr, #INTCPS_CONTROL]
d293 1
a293 1
        BIC     a1, a2, a3 ; Clear the masked interrupts from a2 to get nonzero result if it was enabled
@


1.4
log
@OMAP3 HAL USB (EHCI) support, interrupt handling fixes
Detail:
  Makefile - added USB to objects list
  s/Boot, s/USB, hdr/StaticWS, hdr/USB - USB EHCI code
  s/Debug, s/Stubs, s/Timers, s/Top, s/UART, s/Video - Debugging tweaks and header dependency fixes
  s/Interrupts, hdr/omap3530 - Interrupt fixes & debugging code
  hdr/PRCM - typo fix
Admin:
  Tested on rev C2 beagleboard


Version 0.08. Tagged as 'OMAP3-0_08'
@
text
@d286 1
a286 1
        MOVEQ   ip, #1
d337 1
a337 1
        MOV     a1, #1
d351 1
a351 1
        MOV     a1, #1
@


1.3
log
@OMAP3 HAL fixes and further video work
Detail:
  s/Boot - Store some workspace vars used by video code. Disable some debug output.
  s/Interrupts - Update HAL_IRQClear to allow clearing of VSync IRQ
  s/Top - Fix CP15 flags
  s/Video - Implemented majority of video code needed by kernel. Correct code for calculating and programming pixel clocks still required, so code remains disabled by default.
  hdr/PRCM - Correct typo
  hdr/StaticWS - Add video-related workspace entries
  hdr/Video - Add constants for mouse pointer image buffer size
Admin:
  Tested under qemu-omap3 and rev B6 beagleboard.


Version 0.03. Tagged as 'OMAP3-0_03'
@
text
@d23 1
a24 1
        GET     hdr.omap3530
d45 5
d59 5
d97 1
d102 1
a102 1
        ; Just mask the interrupt and GTFO
d104 8
d113 1
a113 1
        MOV     a1, a1, LSR #5 ; BITS index
d115 4
a118 4
        ADD     ip, a3, a1, LSL #5
        MOV     a1, #1
        MOV     a2, a1, LSL a2
        LDR     a1, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
d120 9
d130 2
a131 3
        MVN     a1, a1 ; Invert so we get a mask of enabled interrupts
        AND     a1, a1, a2 ; Test if it was enabled or not
        MOV     pc, lr
d134 2
a135 1
        ; This routine is (apparently) used to clear the timer & vsync interrupts
d140 1
a140 1
        MOVEQ   pc, lr
d143 1
a143 1
        MOVHS   pc, lr
d147 12
a158 1
        STR     a3, [a1, #TISR]                    
d162 11
d177 3
d184 10
a193 3
        MOVHS   a1, #-1 ; Spurious interrupt
        ANDLO   a1, a1, #&7F ; Else get device
        ; We now know this device is interrupting; re-enable the priority sorting to allow the next device to be detected
d260 1
d265 1
a265 1
        ; Just mask the interrupt and GTFO
d267 8
d276 1
a276 1
        MOV     a1, a1, LSR #5 ; BITS index
d278 4
a281 4
        ADD     ip, a3, a1, LSL #5
        MOV     a1, #1
        MOV     a2, a1, LSL a2
        LDR     a1, [ip, #INTCPS_BITS+INTCPS_BITS_MIR] ; Get old state
d283 9
d293 2
a294 3
        MVN     a1, a1 ; Invert so we get a mask of enabled interrupts
        AND     a1, a1, a2 ; Test if it was enabled or not
        MOV     pc, lr
d335 11
d349 11
d391 11
d406 3
d413 10
a422 3
        MOVHS   a1, #-1 ; Spurious interrupt
        ANDLO   a1, a1, #&7F ; Else get device
        ; We now know this device is interrupting; re-enable the priority sorting to allow the next device to be detected
@


1.2
log
@  OMAP3 HAL fixes and updates to allow booting on real hardware.
Detail:
  Makefile - add s.PRCM to objects
  s/Boot - Call PRCM_SetClocks during HAL_Init. Added (disabled) debugging code.
  s/Interrupts - Updated HAL_IRQSource, HAL_FIQSource to query ARM interrupt state instead of relying on INTC alone to detect whether an interrupt is firing or not.
  s/PRCM - Code to measure system clock frequency, store it for HAL purposes, and notify the OMAP of the frequency in order to ensure correct operation.
  s/Timers - Use measured system clock frequency as the timer frequency instead of hard-coded value. Return correct values from HAL_TimerPeriod.
  s/Top - Added (disabled) debugging code. Updated ARM initialisation to use correct cache cleaning procedure.
  s/Video - Further minor work towards completing video driver.
  hdr/CoPro15ops - Deprecate ARM_flush_* macros
  hdr/PRCM - Add more register addresses
  hdr/StaticWS - Add entried for PowerMan & 32K timer logical addresses, system clock speed
  hdr/Timers - remove incorrect, hard-coded timer frequency
  hdr/omap3530 - remove unused FlashCheck global, add DebugChar macro
Admin:
  Tested with HALTester and the RISC OS kernel using qemu-omap3.
  Tested with HALTester on a rev. B6 beagleboard.


Version 0.02. Tagged as 'OMAP3-0_02'
@
text
@d28 1
d107 6
a112 1
        ; This routine is (apparently) used to clear the timer interrupts
@


1.1
log
@Basic OMAP3 HAL
Detail:
  Performs startup procedure suitable for any location in ROM or RAM. UART, timer, counter, interrupt & debug functionality implemented. Video support incomplete and nonfunctional.
Admin:
  Tested with HALTester & RISC OS kernel under qemu-omap3


Version 0.01. Tagged as 'OMAP3-0_01'
@
text
@d117 5
d286 5
@


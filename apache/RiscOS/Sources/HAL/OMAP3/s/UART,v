head	1.8;
access;
symbols
	OMAP3-1_18:1.8
	OMAP3-1_17:1.8
	OMAP3-1_16:1.8
	OMAP3-1_15:1.8
	OMAP3-1_14:1.8
	SMP:1.8.0.2
	SMP_bp:1.8
	OMAP3-1_13:1.8
	OMAP3-1_12:1.8
	OMAP3-1_11:1.8
	OMAP3-1_10:1.8
	OMAP3-1_09:1.8
	OMAP3-1_08:1.8
	OMAP3-1_07:1.8
	OMAP3-1_06:1.8
	OMAP3-1_05:1.8
	OMAP3-1_04:1.8
	OMAP3-1_03:1.8
	OMAP3-1_02:1.8
	OMAP3-1_01:1.8
	OMAP3-1_00:1.8
	OMAP3-0_99:1.8
	OMAP3-0_98:1.8
	OMAP3-0_97:1.8
	OMAP3-0_96:1.8
	OMAP3-0_95:1.8
	OMAP3-0_94:1.8
	OMAP3-0_93:1.8
	OMAP3-0_92:1.8
	OMAP3-0_91:1.8
	OMAP3-0_90:1.8
	OMAP3-0_89:1.8
	OMAP3-0_88:1.8
	OMAP3-0_87:1.8
	OMAP3-0_86:1.8
	OMAP3-0_85:1.8
	OMAP3-0_84:1.8
	OMAP3-0_83:1.8
	OMAP3-0_82:1.8
	OMAP3-0_81:1.8
	OMAP3-0_80:1.8
	OMAP3-0_79:1.8
	OMAP3-0_78:1.8
	OMAP3-0_77:1.8
	OMAP3-0_76:1.8
	OMAP3-0_75:1.8
	OMAP3-0_74:1.8
	OMAP3-0_73:1.8
	OMAP3-0_72:1.8
	OMAP3-0_71:1.8
	OMAP3-0_70:1.8
	OMAP3-0_69:1.8
	OMAP3-0_68:1.8
	OMAP3-0_67:1.8
	OMAP3-0_66:1.7
	OMAP3-0_65:1.7
	OMAP3-0_64:1.7
	OMAP3-0_63:1.6
	OMAP3-0_62:1.6
	OMAP3-0_61:1.6
	OMAP3-0_60:1.6
	OMAP3-0_59:1.6
	OMAP3-0_58:1.6
	OMAP3-0_57:1.6
	OMAP3-0_56:1.6
	OMAP3-0_55:1.6
	OMAP3-0_54:1.6
	OMAP3-0_53:1.6
	OMAP3-0_52:1.6
	OMAP3-0_51:1.5
	OMAP3-0_50:1.4
	OMAP3-0_49:1.4
	OMAP3-0_48:1.4
	OMAP3-0_47:1.4
	OMAP3-0_46:1.4
	OMAP3-0_45:1.4
	OMAP3-0_44:1.4
	OMAP3-0_43:1.4
	OMAP3-0_42:1.4
	OMAP3-0_41:1.4
	OMAP3-0_40:1.4
	OMAP3-0_39:1.4
	OMAP3-0_38:1.4
	OMAP3-0_37:1.4
	OMAP3-0_36:1.4
	OMAP3-0_35:1.4
	OMAP3-0_34:1.4
	OMAP3-0_33:1.4
	OMAP3-0_32:1.4
	OMAP3-0_31:1.4
	OMAP3-0_30:1.4
	OMAP3-0_29:1.4
	OMAP3-0_28:1.4
	OMAP3-0_27:1.4
	OMAP3-0_26:1.4
	OMAP3-0_25:1.4
	OMAP3-0_24:1.4
	OMAP3-0_23:1.4
	OMAP3-0_22:1.4
	OMAP3-0_21:1.4
	OMAP3-0_20:1.3
	OMAP3-0_19:1.3
	OMAP3-0_18:1.2
	OMAP3-0_17:1.2
	OMAP3-0_16:1.2
	OMAP3-0_15:1.2
	OMAP3-0_14:1.2
	OMAP3-0_13:1.2
	OMAP3-0_12:1.2
	OMAP3-0_11:1.2
	OMAP3-0_10:1.2
	OMAP3-0_09:1.2
	OMAP3-0_08:1.2
	OMAP3-0_07:1.1
	OMAP3-0_06:1.1
	OMAP3-0_05:1.1
	OMAP3-0_04:1.1
	OMAP3-0_03:1.1
	OMAP3-0_02:1.1
	OMAP3-0_01:1.1;
locks; strict;
comment	@# @;


1.8
date	2012.06.11.22.42.59;	author jlee;	state Exp;
branches;
next	1.7;
commitid	progsLwVVKLDfl8w;

1.7
date	2012.06.04.23.45.11;	author jlee;	state Exp;
branches;
next	1.6;
commitid	m70jrk0mZm9UOr7w;

1.6
date	2011.12.04.19.14.50;	author jlee;	state Exp;
branches;
next	1.5;
commitid	ITJDzEpHbl3ScUJv;

1.5
date	2011.11.29.22.46.15;	author jlee;	state Exp;
branches;
next	1.4;
commitid	bYJYUuZQ3ItlxhJv;

1.4
date	2010.01.30.00.23.21;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.24.02.49.33;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.09.19.04.58;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.02.01.13.58.05;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Fix HAL_UARTModemControl. Tweak HAL_UARTStartUp.
Detail:
  s/UART:
  - HAL_UARTModemControl now uses the correct AND mask; previous code would have always had bit 0 of the mask set.
  - Fixed code in HAL_UARTModemControl that was testing for calls that don't write to the register
  - Removed code from HAL_UARTStartUp that was setting the OUT2 bit of MCR (that bit has a different purpose on OMAP, and won't do anything interesting unless another bit it set as well)
Admin:
  Tested on rev A2 BB-xM
  HAL now reports modem control lines changing correctly upon calls to HAL_UARTModemControl


Version 0.67. Tagged as 'OMAP3-0_67'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        EXPORT  HAL_UARTPorts
        EXPORT  HAL_UARTStartUp
        EXPORT  HAL_UARTShutdown
        EXPORT  HAL_UARTFeatures
        EXPORT  HAL_UARTReceiveByte
        EXPORT  HAL_UARTTransmitByte
        EXPORT  HAL_UARTLineStatus
        EXPORT  HAL_UARTInterruptEnable
        EXPORT  HAL_UARTRate
        EXPORT  HAL_UARTFormat
        EXPORT  HAL_UARTFIFOSize
        EXPORT  HAL_UARTFIFOClear
        EXPORT  HAL_UARTFIFOEnable
        EXPORT  HAL_UARTFIFOThreshold
        EXPORT  HAL_UARTInterruptID
        EXPORT  HAL_UARTBreak
        EXPORT  HAL_UARTModemControl
        EXPORT  HAL_UARTModemStatus
        EXPORT  HAL_UARTDevice
        EXPORT  HAL_UARTDefault

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:Proc
        GET     Hdr:OSEntries

        GET     hdr.omap3530
        GET     hdr.StaticWS
        GET     hdr.UART

; Put base address into the a1, given port number in a1
        MACRO
        BaseAddr
        ADD     a1, sb, a1, LSL #2
        LDR     a1, [a1, #BoardConfig_HALUART]
        MEND

        AREA    |Asm$$Code|, CODE, READONLY, PIC

; int Ports(void)
;
;   Return array of UART port physical addresses.
;
HAL_UARTPorts
        LDRB    a1, [sb, #BoardConfig_NumUART]
        MOV     pc, lr

; void Shutdown(int port)
;
HAL_UARTShutdown
        ; Just reuse the startup code

; void StartUp(int port)
;
HAL_UARTStartUp
        ADD     a3, sb, a1
        BaseAddr
        ; Perform soft reset
        MOV     a2, #2
        STRB    a2, [a1, #UART_SYSC]
10
        LDRB    a2, [a1, #UART_SYSS]
        TST     a2, #1
        BEQ     %BT10
        ; Autoidle, smart idle
        MOV     a2, #1+(2<<3)
        STRB    a2, [a1, #UART_SYSC]
        
        MOV     a2, #0
        STRB    a2, [a3, #:INDEX:UARTFCRSoftCopy]
        MOV     a2, #0
        STRB    a2, [a1, #UART_MCR]
        MOV     a2, #WLS_8
        STRB    a2, [a1, #UART_LCR]
        MOV     pc, lr

; int Features(int port)
;
;      Bit 0:  FIFOs available
;      Bit 1:  DMA available
;      Bit 2:  Modem lines available
;
HAL_UARTFeatures
        MOV     a1, #2_101
        MOV     pc, lr

; int ReceiveByte(int port, int *status)
;
;   Returns the next byte from the FIFO (if enabled) or the holding register.
;   If status is non-NULL, the line status associated with the byte is
;   read (see LineStatus). The return value is only meaningful if a
;   received byte is available (bit 0 of *status will be set).
;
HAL_UARTReceiveByte
        BaseAddr
        TEQ     a2, #0
        LDRNEB  a3, [a1, #UART_LSR]     ; Read int state if returning status
        LDRB    a1, [a1, #UART_RBR]
        STRNE   a3, [a2]
        MOV     pc, lr

; void TransmitByte(int port, int byte)
;
HAL_UARTTransmitByte
        BaseAddr
        STRB    a2, [a1, #UART_THR]
        MOV     pc, lr

; int LineStatus(int port)
;
;      Bit 0: Receiver Data Ready
;      Bit 1: Overrun Error
;      Bit 2: Parity Error
;      Bit 3: Framing Error
;      Bit 4: Break Error
;      Bit 5: Transmitter Holding Register Empty
;      Bit 6: Transmitter Empty (including FIFO)
;      Bit 7: FIFO contains a Parity, Framing or Break error
;
;   Parity, Framing and Break errors are associated with each byte received.
;   Whether the values reported here are associated with the last byte
;   read using ReceiveByte or with the next byte to be read is undefined.
;   You should request the status using ReceiveByte to ensure accurate
;   identification of bytes with errors.
;
;   Error bits are cleared whenever status is read, using either LineStatus
;   or ReceiveByte with status non-NULL.
;
HAL_UARTLineStatus
        BaseAddr
        LDRB    a1, [a1, #UART_LSR]
        MOV     pc, lr

; int InterruptEnable(int port, int eor, int mask)
;
;   Enables interrupts. Bits are:
;
;      Bit 0: Received Data Available (and Character Timeout)
;      Bit 1: Transmitter Holding Register Empty
;      Bit 2: Received Line Status
;      Bit 3: Modem Status
;
;   Returns previous state.
;
HAL_UARTInterruptEnable
        BaseAddr
        PHPSEI  ip, a4
        LDRB    a4, [a1, #UART_IER]
        AND     a3, a4, a3
        EOR     a3, a2, a3
        STRB    a3, [a1, #UART_IER]
        PLP     ip
        MOV     a1, a4
        MOV     pc, lr


; int Rate(int port, int baud16)
;
;   Sets the rate, in units of 1/16 of a baud. Returns the previous rate.
;   Use -1 to read.
;
HAL_UARTRate
        Entry   "v1,v3"
        BaseAddr
        PHPSEI  ip, a4

        MOV     v1, #7
        STRB    v1, [a1, #UART_MDR1]    ; Disable UART
        
        LDRB    v3, [a1, #UART_LCR]
        ORR     a4, v3, #DLAB           ; Access divisor latch registers
        STRB    a4, [a1, #UART_LCR]

        LDRB    a3, [a1, #UART_DLL]     ; Read the current baud rate
        LDRB    a4, [a1, #UART_DLM]
        LDR     v1, =UARTCLK
        ADDS    a4, a3, a4, LSL#8
        BEQ     %FT05                   ; Skip divide if no baud programmed yet
        DivRem  a3, v1, a4, lr          ; a3 now contains baud rate * 16
        CMP     v1, a4, LSR#1           ; If the remainder is greater than 1/2
        ADDGE   a3, a3, #1              ; the divisor, round up
05
        CMN     a2, #1                  ; Don't write if we're reading!
        BEQ     %FT10

; We need to program 48MHz / (16 * baud rate)

        LDR     v1, =UARTCLK            ; This was corrupted by the above DIVREM
        DivRem  a4, v1, a2, lr
        CMP     v1, a2, LSR#1           ; If the remainder is greater than 1/2
        ADDGE   a4, a4, #1              ; the divisor, round up

        STRB    a4, [a1, #UART_DLL]
        MOV     a4, a4, LSR#8
        STRB    a4, [a1, #UART_DLM]

10      STRB    v3, [a1, #UART_LCR]     ; Turn off divisor latch access
        MOV     v3, #0
        STRB    v3, [a1, #UART_MDR1]    ; Restart UART
        MOV     a1, a3                  ; Return previous state
        PLP     ip
        EXIT

; int Format(int port, int format)
;
;   Bits 0-1: Bits per word  0=>5, 1=>6, 2=>7, 3=>8
;   Bit 2:    Stop length 0=>1, 1=>2 (1.5 if 5 bits)
;   Bit 3:    Parity enabled
;   Bits 4-5: Parity:  0 => Odd (or disabled)
;                      1 => Even
;                      2 => Mark (parity bit = 1)
;                      3 => Space (parity bit = 0)
;
;   Returns previous format. -1 to read.
;

HAL_UARTFormatMask    *  SPA+EPS+PEN+STP+WLS

HAL_UARTFormat
        BaseAddr
        PHPSEI  ip, a3
        LDRB    a3, [a1, #UART_LCR]
        CMP     a2, #-1
        AND     a4, a3, #HAL_UARTFormatMask     ; a4 = relevant bits of current LCR
        BIC     a3, a3, #HAL_UARTFormatMask     ; a3 = other bits of current LCR
        ANDNE   a2, a2, #HAL_UARTFormatMask     ; a2 = relevant bits on entry
        ORRNE   a2, a2, a3
        STRNEB  a2, [a1, #UART_LCR]
        PLP     ip
        MOV     a1, a4
        MOV     pc, lr

; void FIFOSize(int port, int *rx, int *tx)
;
;   Returns the size of the RX and TX FIFOs. Either parameter may be NULL.
;   Note that the size of the TX FIFO is the total amount of data that can
;   be sent immediately when the Transmitter Holding Register Empty
;   status holds. (So an unusual UART that had a transmit threshold
;   should return total FIFO size minus threshold).
;
HAL_UARTFIFOSize
        BaseAddr
        MOV     a1, #64
        TEQ     a2, #0
        STRNE   a1, [a2]
        TEQ     a3, #0
        STRNE   a1, [a3]
        MOV     pc, lr

; void FIFOClear(int port, int flags)
;
;   Clears the input FIFO (if bit 0 set) and the output FIFO (if bit 1 set).
;
HAL_UARTFIFOClear
        ADD     a4, sb, a1
        BaseAddr
        AND     a2, a2, #2_11
        PHPSEI  ip, a3
        LDRB    a3, [a4, #:INDEX:UARTFCRSoftCopy]
        ORR     a3, a3, a2, LSL #1
        STRB    a3, [a1, #UART_FCR]
        PLP     ip
        MOV     pc, lr

; int FIFOEnable(int port, int enable)
;
;   Enables or disables the RX and TX FIFOs: 0 => disable, 1 => enable
;   -1 => read status. Returns previous status.
;
HAL_UARTFIFOEnable
        Entry   "v1-v2"
        ADD     v1, sb, a1
        BaseAddr
        PHPSEI  ip, a3
        LDRB    a3, [v1, #:INDEX:UARTFCRSoftCopy]
        ASSERT  FIFOEN=1
        AND     a4, a3, #FIFOEN
        CMP     a2, #-1
        BEQ     %FT10
        CMP     a2, #0
        BICEQ   a2, a3, #FIFOEN
        ORRNE   a2, a3, #FIFOEN
        CMP     a2, a3
        BEQ     %FT10
        ; Must disable the baud clock to flush the FIFO

        STRB    a2, [v1, #:INDEX:UARTFCRSoftCopy]

        MOV     lr, #7
        STRB    lr, [a1, #UART_MDR1]    ; Disable UART

        LDRB    v2, [a1, #UART_LCR]
        ORR     a3, v2, #DLAB           ; Access divisor latch registers
        STRB    a3, [a1, #UART_LCR]

        LDRB    a3, [a1, #UART_DLL]     ; Read the current baud rate
        LDRB    v1, [a1, #UART_DLM]

        MOV     lr, #0
        STRB    lr, [a1, #UART_DLL]     ; Stop the clock
        STRB    lr, [a1, #UART_DLM]

        STRB    a2, [a1, #UART_FCR]     ; Configure FIFO

        STRB    a3, [a1, #UART_DLL]     ; Restart clock
        STRB    v1, [a1, #UART_DLM]

        STRB    v2, [a1, #UART_LCR]     ; Restore operational mode

        STRB    lr, [a1, #UART_MDR1]    ; Restart UART

10      MOV     a1, a4
        PLP     ip
        EXIT

; int FIFOThreshold(int port, int threshold)
;
;   Sets the receive threshold level for the FIFO RX interrupt. For OMAP3530
;   this is 8, 16, 56 or 60 bytes. Returns previous value. -1 to read.
;
HAL_UARTFIFOThreshold
        Entry   "v1"
        ADD     v1, sb, a1
        BaseAddr
        PHPSEI  ip, a3
        LDRB    a3, [v1, #:INDEX:UARTFCRSoftCopy]
        ANDS    a4, a3, #FIFOTHR
        BIC     a3, a3, #FIFOTHR
        ASSERT  FIFOTHR_8 = 0
        MOVEQ   a4, #8
        BEQ     %FT10
        CMP     a4, #FIFOTHR_56
        MOVLO   a4, #16
        MOVEQ   a4, #56
        MOVHI   a4, #60
10      CMP     a2, #-1
        BEQ     %FT20
        CMP     a2, #16
        ADDGE   a3, a3, #FIFOTHR_16
        CMP     a2, #56
        ADDGE   a3, a3, #FIFOTHR_56-FIFOTHR_16
        CMP     a2, #60
        ADDGE   a3, a3, #FIFOTHR_60-FIFOTHR_56
        STRB    a3, [a1, #UART_FCR]
        STRB    a3, [v1, #:INDEX:UARTFCRSoftCopy]
20      MOV     a1, a4
        PLP     ip
        EXIT

; int InterruptID(int port)
;
;   Returns the highest priority interrupt currently asserted. In order
;   of priority:
;
;   3 => Receiver Line Status (Cleared by ReceiveByte)
;   2 => Received Data Available (Cleared by reading enough data)
;   6 => Character Timeout (received data waiting)
;   1 => Transmitter Holding Register Empty (Cleared by this call)
;   0 => Modem Status (Cleared by ModemStatus)
;   -1 => No Interrupt
;
;   The Modem Status interrupt occurs when the CTS, DSR or DCD inputs
;   change, or when RI goes from high to low (ie bits 0 to 3 of ModemStatus
;   are set).
;
HAL_UARTInterruptID
        BaseAddr
        LDRB    a4, [a1, #UART_IIR]
        TST     a4, #1
        MOVEQ   a1, a4, LSR #1
        ANDEQ   a1, a1, #7
        MOVNE   a1, #-1
        MOV     pc, lr

; int Break(int port, int enable)
;
;   Activates (1) or deactivates (0) a break condition. -1 to read,
;   returns previous state.
;
HAL_UARTBreak
        BaseAddr
        PHPSEI  ip, a3
        LDRB    a3, [a1, #UART_LCR]
        ANDS    a4, a3, #BCR
        MOVNE   a4, #1
        CMP     a2, #-1
        BEQ     %FT10
        CMP     a2, #0
        BICEQ   a3, a3, #BCR
        ORRNE   a3, a3, #BCR
        STRB    a3, [a1, #UART_LCR]
10      MOV     a1, a4
        PLP     ip
        MOV     pc, lr

; int ModemControl(int port, int eor, int mask)
;
;   Modifies the modem control outputs.
;
;   Bit 0: DTR
;   Bit 1: RTS
;
;   Note that these are logical outputs, although the physical pins may be
;   inverted.  So 1 indicates a request to send.  Returns previous state.
;   Needs to clear the modem interrupt status.
;

HAL_UARTModemControl
        BaseAddr
        PHPSEI  ip, a4
        LDRB    a4, [a1, #UART_MCR]
        ORR     a3, a3, #255-(DTR+RTS) ; Only allow DTR+RTS to be modified
        AND     a2, a2, #DTR+RTS      
        AND     a3, a3, a4
        EOR     a3, a3, a2
        CMP     a3, a4
        STRNEB  a3, [a1, #UART_MCR]
        PLP     ip
        AND     a1, a4, #DTR+RTS
        MOV     pc, lr

; int ModemStatus(int port)
;
;   Reads the modem status inputs.
;
;   Bit 0: CTS changed since last call
;   Bit 1: DSR changed since last call
;   Bit 2: RI changed from high to low since last call
;   Bit 3: DCD changed since last call
;   Bit 4: CTS
;   Bit 5: DSR
;   Bit 6: RI
;   Bit 7: DCD
;
;   Note that these are logical inputs, although the physical pins may be
;   inverted.  So 1 indicates a Clear To Send condition.  This must also clear
;   the modem interrupt status.
;
HAL_UARTModemStatus
        BaseAddr
        LDRB    a1, [a1, #UART_MSR]
        MOV     pc, lr

; int Device(int port)
;
;   Return the device number allocated to the UART port
;
HAL_UARTDevice
        ADD     a1, sb, a1
        LDRB    a1, [a1, #BoardConfig_HALUARTIRQ]
        MOV     pc, lr

; int Default(void)
;
;   Return the default UART for the OS to use, or -1 for none
;
HAL_UARTDefault
        LDRB    a1, [sb, #BoardConfig_DefaultUART]
        MOV     pc, lr

        END
@


1.7
log
@Add HAL_UARTDefault implementation. Delete old HAL video code. Add some SmartReflex tweaks.
Detail:
  hdr/board, s/board, s/Boot, s/UART - Added HAL_UARTDefault implementation, to allow OS_SerialOp to be used
  hdr/StaticWS, hdr/omap3530, s/Boot, s/Interrupts, s/Video - Removed old HAL video code. The OMAPVideo module is a much better video driver.
  s/SR37x - Add some SmartReflex tweaks which we can try if we run into any stability issues with the current code.
Admin:
  Tested on rev A2 BB-xM


Version 0.64. Tagged as 'OMAP3-0_64'
@
text
@d90 1
a90 1
        MOV     a2, #OUT2
d431 1
a431 2
        CMP     a2, #-1
        ORR     a3, a3, #256-(DTR+RTS) ; Only allow DTR+RTS to be modified
d433 3
a435 2
        ANDNE   a3, a3, a4
        EORNE   a3, a3, a2
@


1.6
log
@Add preliminary OMAP3 EVM support. Fix HAL_UARTModemControl
Detail:
  hdr/board, s/Boot, s/Top, s/board - Added preliminary support for OMAP3 EVM boards. Only generation 2 boards are supported at the moment.
  s/UART - Fixed HAL_UARTModemControl to pay attention to the 'mask' parameter
Admin:
  Tested on rev A2 BB-xM. EVM support might not be fully working.


Version 0.52. Tagged as 'OMAP3-0_52'
@
text
@d35 1
d472 8
@


1.5
log
@Fix OMAP3 HAL UART code
Detail:
  hdr/UART - Added a couple more register addresses, removed incorrect FIFO64 flag
  hdr/omap3530 - Corrected UART 2 address
  s/Boot - Ensure we perform phys2log address conversion for all UART addresses, not just the first 3. Also avoid resetting the debug UART.
  s/UART - Fix HAL UART calls to obey the programming rules laid out in the TRM
  s/board - Change the order in which the UARTs are exposed to RISC OS so that they match the hardware order. HAL UART 0 is now OMAP UART1, etc.
Admin:
  Tested on rev A2 BB-xM


Version 0.51. Tagged as 'OMAP3-0_51'
@
text
@a14 1
; This is currently set up to provide only 1 serial port - UART3
d428 2
a429 2
        PHPSEI  ip, a3
        LDRB    a3, [a1, #UART_MCR]
d431 5
a435 5
        AND     a4, a3, #DTR+RTS                ; a4 = relevant bits of current MCR
        BIC     a3, a3, #DTR+RTS                ; a3 = other bits of current MCR
        ANDNE   a2, a2, #DTR+RTS                ; a2 = relevant bits on entry
        ORRNE   a2, a2, a3
        STRNEB  a2, [a1, #UART_MCR]
d437 1
a437 1
        MOV     a1, a4
a439 1

@


1.4
log
@Various OMAP3 HAL power management improvements, plus add support for board config autodetection via Linux machine ID
Detail:
  s/board, hdr/board - Add Linux machine ID & available mixer channels to board config table
  s/Top - Add new entry point at offset &64, for booting as a fake Linux kernel. Searches the board config table until it finds a config matching the machine ID passed in R1. Also minor ROM copy optimisation, unsigned pointer comparison fixes
  s/Audio, hdr/Audio - Use board config to lock-out mixer channels that aren't connected to any hardware, to avoid excessive power drain or other problems if the channels get turned on. Also perform many other setting tweaks to tidy up default settings for unused mixer paths/channels.
  s/Video - Fix Video_Init logic when deciding whether to reset DSS, enable DSI PLL drift guard
  s/I2C - Increase I2C timeout values, since the previous values were perhaps a bit low
  s/Audio, s/I2C, s/Interrupts, s/RAM, s/SDMA, s/Timers, s/UART, hdr/UART, s/USB, s/Video - Enable autoidle/smart idle where possible to help save power.
Admin:
  Tested on rev C2 beagleboard


Version 0.21. Tagged as 'OMAP3-0_21'
@
text
@d52 1
a52 1
$label  BaseAddr
d67 5
d77 11
a88 2
        STRB    a2, [a1, #UART_IER]
        STRB    a2, [a1, #UART_FCR]
a93 14
        ; Autoidle, smart idle
        ; TODO - we should really perform a full reset too
        MOV     a2, #1+(2<<3)
        STRB    a2, [a1, #UART_SYSC]
        MOV     pc, lr

; void Shutdown(int port)
;
HAL_UARTShutdown
        BaseAddr
        MOV     a2, #0
        STRB    a2, [a1, #UART_IER]
        STRB    a2, [a1, #UART_FCR]
        STRB    a2, [a1, #UART_MCR]
d185 4
d196 2
a197 1
        ADD     a4, a3, a4, LSL#8
d201 1
d217 2
d290 1
a290 1
        Entry   "v1"
d300 31
a330 4
        BICEQ   a3, a3, #FIFOEN
        ORRNE   a3, a3, #FIFOEN
        STRB    a3, [a1, #UART_FCR]
        STRB    a3, [v1, #:INDEX:UARTFCRSoftCopy]
@


1.3
log
@Update OMAP HAL to support different board configs, plus use new YearLOIsGood flag to ensure correct RTC handling, plus other misc tidying
Detail:
  The OMAP HAL now has multiple entry points, one per board config. See Top.s/board.s for more info.
  audio.s - Moved APLL_CTL value to board config
  board.s - New file to list all the settings for the different board configs
  boot.s - Change HAL_Init to deal with the new board config stuff
  debug.s - Debug UART now specified in board config
  GPIO.s - A few utility functions for handling OMAP/TPS GPIO pins
  I2C.s - Update to use new board config struct
  RAM.s - Disable the beagleboard-specific RAM init code. Instead we'll just rely on u-boot to initialise all our RAM for us.
  RTC.s - Get rid of the magic numbers, and use the YearLOIsGood flag to indicate to RISC OS that YearLO is 2-digit BCD
  Top.s - Got rid of old debug code and rewrote initial flow to handle detecting & storing the board config
  UART.s - Update to use board config struct, support multiple UARTs
  USB.s - Get EHCI PHY power GPIO from board config
  Video.s - Get DVI framer power GPIO and max pixel rate from board config. Add 'PassiveVideo' option, to build a driver that doesn't alter the video output settings - should hopefully result in a usable display on Touch Book, etc.
  board.hdr - Definition of board config table struct
  GPIO.hdr - Add lots of macros for handling OMAP GPIO pins, new constants for OMAP/TPS GPIO
  I2C.hdr - Added I2C transfer block struct, HAL I2C API transfer states (both moved here from other source files)
  omap3530.hdr - Move/remove some unwanted constants, disable DebugChar for now
  StaticWS.hdr - Move I2C transfer block struct to I2C.hdr, add board config struct to HAL workspace, get rid of unused 64K AllocArea
  Timers.hdr - Tidy up constants a bit
  UART.hdr - Add UARTCLK (moved from StaticWS.hdr), UART IRQ #'s
  Makefile - add GPIO.s
Admin:
  Tested on rev C2 beagleboard. Board configs for other board types may be inaccurate in a couple of places.


Version 0.19. Tagged as 'OMAP3-0_19'
@
text
@d80 4
@


1.2
log
@OMAP3 HAL USB (EHCI) support, interrupt handling fixes
Detail:
  Makefile - added USB to objects list
  s/Boot, s/USB, hdr/StaticWS, hdr/USB - USB EHCI code
  s/Debug, s/Stubs, s/Timers, s/Top, s/UART, s/Video - Debugging tweaks and header dependency fixes
  s/Interrupts, hdr/omap3530 - Interrupt fixes & debugging code
  hdr/PRCM - typo fix
Admin:
  Tested on rev C2 beagleboard


Version 0.08. Tagged as 'OMAP3-0_08'
@
text
@d53 2
a54 1
        LDR     a1, L4_UART3_Log
d64 1
a64 1
        MOV     a1, #1
d70 1
d75 1
a75 1
        STRB    a2, UARTFCRSoftCopy
d262 1
d266 1
a266 1
        LDRB    a3, UARTFCRSoftCopy
d278 2
d282 1
a282 1
        LDRB    a3, UARTFCRSoftCopy
d291 1
a291 1
        STRB    a3, UARTFCRSoftCopy
d294 1
a294 1
        MOV     pc, lr
d302 2
d306 1
a306 1
        LDRB    a3, UARTFCRSoftCopy
d325 1
a325 1
        STRB    a3, UARTFCRSoftCopy
d328 1
a328 1
        MOV     pc, lr
d430 2
a431 1
        MOV     a1, #74
@


1.1
log
@Basic OMAP3 HAL
Detail:
  Performs startup procedure suitable for any location in ROM or RAM. UART, timer, counter, interrupt & debug functionality implemented. Video support incomplete and nonfunctional.
Admin:
  Tested with HALTester & RISC OS kernel under qemu-omap3


Version 0.01. Tagged as 'OMAP3-0_01'
@
text
@d46 1
a47 1
        GET     hdr.omap3530
@


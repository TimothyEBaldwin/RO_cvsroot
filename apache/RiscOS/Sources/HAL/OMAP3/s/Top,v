head	1.23;
access;
symbols
	OMAP3-1_18:1.23
	OMAP3-1_17:1.23
	OMAP3-1_16:1.23
	OMAP3-1_15:1.23
	OMAP3-1_14:1.23
	SMP:1.23.0.2
	SMP_bp:1.23
	OMAP3-1_13:1.23
	OMAP3-1_12:1.23
	OMAP3-1_11:1.23
	OMAP3-1_10:1.23
	OMAP3-1_09:1.23
	OMAP3-1_08:1.23
	OMAP3-1_07:1.22
	OMAP3-1_06:1.22
	OMAP3-1_05:1.22
	OMAP3-1_04:1.22
	OMAP3-1_03:1.21
	OMAP3-1_02:1.21
	OMAP3-1_01:1.21
	OMAP3-1_00:1.21
	OMAP3-0_99:1.21
	OMAP3-0_98:1.21
	OMAP3-0_97:1.21
	OMAP3-0_96:1.21
	OMAP3-0_95:1.21
	OMAP3-0_94:1.20
	OMAP3-0_93:1.20
	OMAP3-0_92:1.20
	OMAP3-0_91:1.19
	OMAP3-0_90:1.19
	OMAP3-0_89:1.19
	OMAP3-0_88:1.19
	OMAP3-0_87:1.19
	OMAP3-0_86:1.19
	OMAP3-0_85:1.19
	OMAP3-0_84:1.19
	OMAP3-0_83:1.19
	OMAP3-0_82:1.19
	OMAP3-0_81:1.19
	OMAP3-0_80:1.19
	OMAP3-0_79:1.19
	OMAP3-0_78:1.19
	OMAP3-0_77:1.19
	OMAP3-0_76:1.19
	OMAP3-0_75:1.19
	OMAP3-0_74:1.19
	OMAP3-0_73:1.19
	OMAP3-0_72:1.19
	OMAP3-0_71:1.19
	OMAP3-0_70:1.19
	OMAP3-0_69:1.19
	OMAP3-0_68:1.19
	OMAP3-0_67:1.19
	OMAP3-0_66:1.19
	OMAP3-0_65:1.19
	OMAP3-0_64:1.19
	OMAP3-0_63:1.19
	OMAP3-0_62:1.19
	OMAP3-0_61:1.19
	OMAP3-0_60:1.18
	OMAP3-0_59:1.17
	OMAP3-0_58:1.16
	OMAP3-0_57:1.16
	OMAP3-0_56:1.16
	OMAP3-0_55:1.16
	OMAP3-0_54:1.16
	OMAP3-0_53:1.16
	OMAP3-0_52:1.16
	OMAP3-0_51:1.15
	OMAP3-0_50:1.15
	OMAP3-0_49:1.15
	OMAP3-0_48:1.14
	OMAP3-0_47:1.14
	OMAP3-0_46:1.14
	OMAP3-0_45:1.14
	OMAP3-0_44:1.14
	OMAP3-0_43:1.14
	OMAP3-0_42:1.13
	OMAP3-0_41:1.13
	OMAP3-0_40:1.13
	OMAP3-0_39:1.13
	OMAP3-0_38:1.13
	OMAP3-0_37:1.13
	OMAP3-0_36:1.13
	OMAP3-0_35:1.13
	OMAP3-0_34:1.13
	OMAP3-0_33:1.13
	OMAP3-0_32:1.13
	OMAP3-0_31:1.13
	OMAP3-0_30:1.13
	OMAP3-0_29:1.12
	OMAP3-0_28:1.11
	OMAP3-0_27:1.10
	OMAP3-0_26:1.10
	OMAP3-0_25:1.10
	OMAP3-0_24:1.10
	OMAP3-0_23:1.10
	OMAP3-0_22:1.10
	OMAP3-0_21:1.10
	OMAP3-0_20:1.9
	OMAP3-0_19:1.9
	OMAP3-0_18:1.8
	OMAP3-0_17:1.8
	OMAP3-0_16:1.8
	OMAP3-0_15:1.8
	OMAP3-0_14:1.8
	OMAP3-0_13:1.8
	OMAP3-0_12:1.8
	OMAP3-0_11:1.8
	OMAP3-0_10:1.7
	OMAP3-0_09:1.7
	OMAP3-0_08:1.7
	OMAP3-0_07:1.6
	OMAP3-0_06:1.5
	OMAP3-0_05:1.5
	OMAP3-0_04:1.5
	OMAP3-0_03:1.4
	OMAP3-0_02:1.3
	OMAP3-0_01:1.2
	OMAP3-0_00:1.1;
locks; strict;
comment	@# @;


1.23
date	2016.01.08.23.01.48;	author jlee;	state Exp;
branches;
next	1.22;
commitid	Infb2G92SOfknbQy;

1.22
date	2015.04.08.07.37.49;	author rsprowson;	state Exp;
branches;
next	1.21;
commitid	KMkj6KKX1Lup6Lgy;

1.21
date	2014.03.08.16.59.12;	author rsprowson;	state Exp;
branches;
next	1.20;
commitid	CdtiAiQ8vMQbWUrx;

1.20
date	2013.12.15.22.41.28;	author jlee;	state Exp;
branches;
next	1.19;
commitid	IxRihA5IJEl1vhhx;

1.19
date	2012.03.25.11.49.09;	author rsprowson;	state Exp;
branches;
next	1.18;
commitid	c99VvmwezV2J8gYv;

1.18
date	2012.03.07.21.47.21;	author jlee;	state Exp;
branches;
next	1.17;
commitid	6ngNMpmvDflR10Wv;

1.17
date	2012.02.25.16.28.11;	author jlee;	state Exp;
branches;
next	1.16;
commitid	8PdHKiULlWJhCyUv;

1.16
date	2011.12.04.19.14.50;	author jlee;	state Exp;
branches;
next	1.15;
commitid	ITJDzEpHbl3ScUJv;

1.15
date	2011.09.12.20.35.50;	author jlee;	state Exp;
branches;
next	1.14;
commitid	b4CSwApHlXY3kfzv;

1.14
date	2011.05.22.19.36.06;	author jlee;	state Exp;
branches;
next	1.13;
commitid	VEzaKWvEB8QKCIkv;

1.13
date	2010.06.24.00.33.51;	author jlee;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.24.00.29.36;	author jlee;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.23.22.30.33;	author jlee;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.30.00.23.21;	author jlee;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.24.02.49.32;	author jlee;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.11.21.04.46;	author bavison;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.09.19.04.58;	author jlee;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.23.23.35.07;	author jlee;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.08.22.25.11;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.06.23.35.43;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2009.02.21.18.51.47;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2009.02.01.13.58.05;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.27.21.28.48;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Fix build error. Add HAL_PlatformName implementation.
Detail:
  s/Boot, Makefile, s/Stubs - Remove references to deleted HAL ATA calls. Delete s/Subs it's now redundant.
  hdr/board, s/board, s/Top - Refactor how board names are stored so that we can differentiate between OMAP3 and DM37x versions of boards (at least the BeagleBoard and the Pandora come in OMAP3 and DM37x variants)
  s/Boot - Add HAL_PlatformName implementation, using the new board name system
Admin:
  Tested on BB-xM


Version 1.08. Tagged as 'OMAP3-1_08'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:HALSize.<HALSize>

        GET     Hdr:MEMM.VMSAv6

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries
        GET     Hdr:VIDCList

        GET     hdr.omap3530
        GET     hdr.StaticWS
        GET     hdr.UART
        GET     hdr.Post
        GET     hdr.SDRC
        GET     hdr.GPIO

        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        IMPORT  rom_checkedout_ok
        EXPORT  HAL_Base
        IMPORT  HAL_DebugTX

; Using the DMA controller to relocate the ROM image is much faster than doing it with the CPU
             GBLL Use_DMA_Copy
Use_DMA_Copy SETL {TRUE}
 
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

        ; Jump table used to select board config on startup
        ; See board.s for ordering of configs, and therefore what entry corresponds to what board
HAL_Base
        BL      selectconfig
        BL      selectconfig
        BL      selectconfig
        BL      selectconfig
        BL      selectconfig
        BL      selectconfig
        BL      selectconfig
JumpTableEnd
        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
        DCD     0 ; Empty - was ROMsize
        B       selectconfig_linux ; offset &64 - for booting as a uImage/Linux kernel. Uses Linux machine type ID to select board config.

        ENTRY
selectconfig
        ; Get pointer to board config
        ADR     v1, HAL_Base+4
        SUB     v1, lr, v1
        ADR     a1, BoardConfigTable
        MOV     a2, #BoardConfig_Size>>2
        MLA     v1, a2, v1, a1
foundconfig
        ; v1 = board config
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode ; Get into SVC mode now, so we can write to sb without much fear of losing it (we may have been in FIQ)
 [ Debug
        ; Announce ourselves if debug
        ADR     v2, HelloWorld
        MOV     sb, v1
10      LDRB    a1, [v2], #1
        CMP     a1, #0
        ADRNE   lr, %BT10
        BNE     HAL_DebugTX
        LDR     v2, =L4_CONTROL_IDCODE
        LDR     v2, [v2]
        LDR     a1, =HAWKEYE_AMDM37x
        MOV     v2, v2, LSL #4
        CMP     a1, v2, LSR #16
        LDRNEB  v2, [v1, #BoardConfig_NameOMAP3]
        LDREQB  v2, [v1, #BoardConfig_NameDM37x]
        ADRL    a1, BoardConfigNames
        ADD     v2, v2, a1
10      LDRB    a1, [v2], #1
        CMP     a1, #0
        ADRNE   lr, %BT10
        BNE     HAL_DebugTX
        MOV     a1, #13
        BL      HAL_DebugTX
        MOV     a1, #10
        BL      HAL_DebugTX
 ]
        ; Now copy the config to SRAM
        ; We'll assume that the L3 interconnect has been correctly configured to give us access
        LDR     sb, =IntSRAM_Base
        MOV     a2, #BoardConfig_Size
10      SUBS    a2, a2, #4
        LDR     a3, [v1, a2]
        STR     a3, [sb, a2]
        BGT     %BT10
 [ DebugTiming
        ADD     sp, sb, #32768 ; Temp stack for debug code
        ; Ensure debug UART FIFO is enabled (assuming UART 3)
        MOV     a1, #0
        STRB    a1, UARTFCRSoftCopy+2
        MOV     a1, #2
        STRB    a1, [sb, #BoardConfig_NumUART] ; Hide UART from RO
        MOV     a2, #1
        IMPORT  HAL_UARTFIFOEnable
        BL      HAL_UARTFIFOEnable
        DebugTimeNoMMU a1, "@@ "
 ]
        ; Now do common init
        B       restart

 [ Debug
HelloWorld DCB "OMAP3 HAL init",13,10,"Board config=",0
        ALIGN
 ]

        ; Entry point for masquerading as a Linux kernel
        ; r0=0
        ; r1=machine type ID
        ; r2=ptr to tag list (linux/include/asm/setup.h)
selectconfig_linux
        ADR     v1, BoardConfigTable_End-BoardConfig_Size
        ADR     a3, BoardConfigTable
10
        LDR     a1, [v1, #BoardConfig_MachID]
        CMP     a1, a2
        CMPNE   v1, a3 ; If we can't find a config, abort and use default? (i.e. beagleboard)
        BEQ     foundconfig
        SUB     v1, v1, #BoardConfig_Size
        B       %BT10

        LTORG
        GET     board.s
        ASSERT  ((JumpTableEnd-HAL_Base)/4) >= (BoardConfigTable_End-BoardConfigTable)/BoardConfig_Size ; If this fires, we need a bigger jump table!

; ------------------------------------------------------------------------------
; Perform some Cortex-A8 specific CPU setup
; Then start looking for RAM
; In: sb = board config ptr
restart
        DebugChar a3,a4,48
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode
        DebugChar a3,a4,49

        ADRL    v1, HAL_Base + OSROM_HALSize    ; v1 -> RISC OS image

        LDR     v8, [v1, #OSHdr_Entries]
        ADD     v8, v8, v1                      ; v8 -> RISC OS entry table

        ; Ensure CPU is set up
        MOV     a1, #0
        CallOSM OS_InitARM
        DebugChar a3,a4,50

        ; Initialise RAM
        BL      init_ram

        ; The first 4K of the first registered block of RAM is used by RISC OS's init code, and also contains the stack
        ; To keep things simple and safe, we'll relocate the HAL and OS image to the top end of RAM
        ; Although with the beagleboard we know we'll be booted from RAM, this code has been written so that it should work if running from ROM

        ; First, identify the top end of RAM
        ; Then check if we intersect it
        ; If we do, first copy ourselves down
        ; Then copy ourselves up

 [ Use_DMA_Copy
        ; We'll use DMA for extra speed, so start by resetting the DMA controller
        LDR     v5, =L4_sDMA
        MOV     v1, #2
        STR     v1, [v5, #DMA4_OCP_SYSCONFIG]
5
        LDR     v1, [v5, #DMA4_SYSSTATUS]
        TST     v1, #1
        BEQ     %BT5
        ; Set a sensible FIFO budget (as per SDMACReset)
        LDR     a2, =&100080
        STR     a2, [v5, #DMA4_GCR]
        ; Configure channel 0 for the right settings
        ADD     v5, v5, #DMA4_i
        LDR     v1, [v5, #DMA4_CLNK_CTRLi]
        BIC     v1, v1, #&8000 ; Disable channel linking
        STR     v1, [v5, #DMA4_CLNK_CTRLi]
        MOV     v1, #1<<4
        STR     v1, [v5, #DMA4_CICRi] ; frame end interrupt enabled
        LDR     v1, =&2E1C2 ; 32bit elements, 64 byte bursts with packing, last write non-posted
        STR     v1, [v5, #DMA4_CSDPi]
        MOV     v1, #1
        STR     v1, [v5, #DMA4_CFNi] ; 1 frame
 ]

relocate_code
        DebugChar a1,a2,66
        BL      get_end_of_ram
        DebugChar v1,v2,67

        ; How big are we?
        ADRL    v1, HAL_Base + OSROM_HALSize
        LDR     v2, [v1, #OSHdr_ImageSize]
        LDR     lr, [v1, #OSHdr_Flags]
        TST     lr, #OSHdrFlag_SupportsCompression
        LDRNE   lr, [v1, #OSHdr_CompressedSize]
        MOVEQ   lr, v2
        SUB     v1, v1, #OSROM_HALSize ; Start of HAL
        ADD     v2, v2, #OSROM_HALSize ; Size of HAL+OS
        ADD     lr, lr, #OSROM_HALSize ; Size of compressed HAL+OS
        ADD     v3, v1, lr ; End of OS
        MOV     v4, a1 ; End of RAM
        SUB     v5, v4, v2 ; New start address of HAL
        CMP     v1, v5
        BEQ     %FT10 ; No copy needed
        CMP     v1, v4
        BHI     %FT20 ; We're in some ROM above RAM. OK to continue with copy.
        CMP     v3, v5
        BLS     %FT20 ; We're in some ROM/RAM below our copy destination. OK to continue with copy.
        ; Else we currently overlap the area we want to copy ourselves into.
        SUB     v5, v1, lr ; Copy the HAL+OS to just before itself. TODO - This will fail with big ROMs (128MB beagleboard with >42MB ROM size)
20
 [ Use_DMA_Copy
        ; Transfer everything in one DMA frame; this gives us a max ROM size of 64MB-4 bytes
        LDR     a3, =L4_sDMA+DMA4_i
        LDR     a1, [a3, #DMA4_CSRi]
        STR     a1, [a3, #DMA4_CSRi] ; Clear status register
        MOV     a1, lr, LSR #2
        STR     a1, [a3, #DMA4_CENi]
        STR     v5, [a3, #DMA4_CDSAi]
        STR     v1, [a3, #DMA4_CSSAi]
        LDR     a1, =&805080 ; Enable channel with post-increment source & destination, prefetch
        STR     a1, [a3, #DMA4_CCRi]
        ; Wait for copy to complete
30
        LDR     a1, [a3, #DMA4_CSRi]
        TST     a1, #1<<4
        BEQ     %BT30
        ; Make doubly sure that it's finished by checking WR_ACTIVE/RD_ACTIVE
40
        LDR     a1, [a3, #DMA4_CCRi]
        TST     a1, #&600
        BNE     %BT40
 |
        MOV     a1, v5
        MOV     a2, v1 ; Copy source
        MOV     a3, lr
30
        LDR     a4, [a2], #4
        SUBS    a3, a3, #4
        STR     a4, [a1], #4
        BGT     %BT30
 ]
        ; Invalidate I-cache, branch predictors
        MOV     a1, #0
        MCR     p15, 0, a1, c7, c5, 0
        MCR     p15, 0, a1, c7, c5, 6
        DSB     SY ; Wait for I-cache invalidation to complete
        ISB     SY ; Wait for branch predictor invalidation to complete?
        DebugChar a1,a2,68
        ; Jump to our new copy
        ADR     a1, relocate_code ; Keep things simple by just running through the same code again
        SUB     a2, v5, v1
        ADD     a1, a1, a2 ; relocate our branch target
        ADD     v8, v8, a2 ; Update OS entry table ptr
        MOV     pc, a1
10
        ; Copy completed OK.
        ; v2 = size of HAL+OS
        ; v4 = end of OS/RAM
        ; v5 = start of HAL
        ; v8 = OS entry table ptr
        DebugChar a1,a2,69
        DebugTimeNoMMU a1, "ROM relocated @@ "
        ; Clear RAM up to v5
        MOV     a1, v5
        BL      clear_ram

        DebugChar a1,a2,70
        DebugTimeNoMMU a1, "RAM cleared @@ "

; TODO - NEON seems to be on by default, need to work out how to turn it off before I can test code to turn it on!
;        ; Enable power to the NEON unit, if present
;        LDR     a1, =&4800244C ; 'control OMAP status register'
;        LDR     a1, [a1]
;        TST     a1, #1<<4
;        BNE     %FT10
;;        ; NEON is available, make sure it's turned on
;        ; Enable CP10/CP11 access
;        MRC     p15, 0, a1, c1, c0, 2
;        ORR     a1, a1, #&F<<20
;        MCR     p15, 0, a1, c1, c0, 2
;        ISB     SY
;        ; Now enable the unit
;        MOV     a1, #1<<30 ; EN bit
;        DCI     &EEE80A10 ; VMSR FPEXC, a1

        B       rom_checkedout_ok

        GET     RAM.s
        LTORG
        
        END
@


1.22
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Rename a couple of symbols in PAudio missed in OMAP3-1_03.
Built, but not tested.


Version 1.04. Tagged as 'OMAP3-1_04'
@
text
@d88 9
a96 1
        ADD     v2, v1, #BoardConfig_Name
@


1.21
log
@Use DSB/ISB directly
Reflects similar change in OMAP4-0_28.
Built, but not tested.

Version 0.95. Tagged as 'OMAP3-0_95'
@
text
@a40 2
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
@


1.20
log
@Remove obsolete stub HAL video API implementation
Detail:
  hdr/Video, s/Top - Remove local VIDC list type 3 definition, use Hdr:VIDCList instead
  s/Boot, s/Video - Removed obsolete HAL video API implementation. A stub implementation is no longer required for systems that have a GraphicsV driver in a module, and can even cause problems if the OS decides to use the HAL implementation instead of the module one.
Admin:
  Tested in OMAP3 ROM on BB-xM
  Requires Kernel-5_35-4_79_2_203


Version 0.92. Tagged as 'OMAP3-0_92'
@
text
@a33 1
        GET     hdr.Copro15ops
d265 2
a266 2
        myDSB ; Wait for I-cache invalidation to complete
        myISB ; Wait for branch predictor invalidation to complete?
d300 1
a300 1
;        DCI     &F57FF06F ; ISB {SY}
@


1.19
log
@Line some things up.
To help OMAP4 tracking changes a number of the changes were purely cosmetic lining up differences, this change is where OMAP3 wasn't on a conventional column layout.

Version 0.61. Tagged as 'OMAP3-0_61'
@
text
@d27 1
@


1.18
log
@Fix bug when linked against old kernels
Detail:
  s/Top - If a kernel which doesn't support compression was in use, a typo would lead to the ROM image size being calculated incorrectly, most likely causing the ROM relocation code to fail.
Admin:
  Tested on BB-xM
  Bug spotted by Willi Theiss


Version 0.60. Tagged as 'OMAP3-0_60'
@
text
@d136 1
a136 1
        LDR     a1, [v1, #BoardConfig_MachID]        
@


1.17
log
@Add compressed ROM support. Add boot timing code. Other misc tweaks.
Detail:
  hdr/omap3530, s/Boot, s/KbdScan, s/Top, s/Video - Added code for profiling/timing the startup sequence, using the 32K system timer
  s/Boot - Ensure VAUX2 is enabled during EVM startup
  s/Boot, s/CPUClk - Go to full CPU speed during HAL_Init instead of HAL_InitDevices.
  s/KbdScan - Print out heap usage stats when debugging is enabled
  s/NVMemory - Skip probing for CMOS carrier board if JTAG is active
  s/RAM, s/Top - Use DMA to relocate the ROM image instead of simple memcpy code. Relocate compressed ROMs to a location suitable for decompression.
Admin:
  Tested with compressed & uncompressed OMAP3/OMAP3Live images


Version 0.59. Tagged as 'OMAP3-0_59'
@
text
@d214 1
a214 1
        MOVEQ   lr, r2
@


1.16
log
@Add preliminary OMAP3 EVM support. Fix HAL_UARTModemControl
Detail:
  hdr/board, s/Boot, s/Top, s/board - Added preliminary support for OMAP3 EVM boards. Only generation 2 boards are supported at the moment.
  s/UART - Fixed HAL_UARTModemControl to pay attention to the 'mask' parameter
Admin:
  Tested on rev A2 BB-xM. EVM support might not be fully working.


Version 0.52. Tagged as 'OMAP3-0_52'
@
text
@d41 6
d108 12
d178 25
d211 4
d217 2
a218 1
        ADD     v3, v1, v2 ; End of OS
d223 1
d228 1
a228 1
        SUB     v5, v1, v2 ; Copy the HAL+OS to just before itself
d230 22
d254 1
a254 1
        MOV     a3, v2
d260 1
d281 1
d287 1
@


1.15
log
@OMAP3 HAL tweaks
Detail:
  hdr/Copro15ops - Correct encoding of ISH/ISHST variants of DMB/DSB instructions
  s/Top - Use RISCOS_InitARM to initialise the CPU instead of the (now out of date) custom code.
Admin:
  Tested on rev A2 BB-xM


Version 0.49. Tagged as 'OMAP3-0_49'
@
text
@d58 1
d62 1
a62 2
ROMsize
        DCD     0 ; patched in by build system. See ROMSizeOffset in Hdr:Machine.Machine
@


1.14
log
@Update OMAP3 HAL to support keyboard scan on boot, plus other changes
Detail:
  Makefile, s/KdbScan, hdr/StaticWS - Code to handle keyboard scanning, via the new HAL build of the USB drivers.
  s/Stubs - Removed old stub keyboard scan routines
  s/CPUClk - ADR -> ADRL to cope with new workspace layout
  s/Boot, s/Top, hdr/Post - Modified to use new HALSize variable for determining the HAL size. Trimmed dead code/definitions.
  s/Boot - FIQDebug code now copes with the different USER button GPIO used on the BB-xM
  s/board - Increased max pixel rate from 86.5MHz to 100MHz. This allows a wider range of screen modes to be used, although it is beyond the spec of the video controller, and not all boards will be able to reach 100MHz. This should match the value used in the initial ARMini units.
Admin:
  Tested on rev C2 BB, A2 BB-xM, C1 TouchBook
  Needs latest USB drivers, Kernel source, BuildSys & Env (not all of which have been checked in yet)


Version 0.43. Tagged as 'OMAP3-0_43'
@
text
@a136 60
        MOV     a1, #&78 ; Matches MMUC_L+MMUC_D+MMUC_P+MMUC_W, which are now reserved bits in the Cortex spec, but should be written as 1
        MCR     p15, 0, a1, c1, c0, 0              ; MMU, caches etc off
        myISB
        DebugChar a3,a4,50
        MRC     p15, 0, a1, c1, c0, 1
        BIC     a1, a1, #2
        MCR     p15, 0, a1, c1, c0, 1 ; Ensure L2 cache disabled
        myISB
        DebugChar a3,a4,51

        MOV     a1, #0
        MCR     p15, 0, a1, c7, c5, 0           ; invalidate instruction cache
        DebugChar a3,a4,52
        MCR     p15, 0, a1, c8, c7, 0           ; invalidate TLBs
        DebugChar a3,a4,53

        ; Invalidate data caches. To do this we must query their sizes
        ; The register describes up to 8 cache levels, so to provide some future-proofing I might as well implement a full cache clean routine here
        MRC     p15, 1, a1, c0, c0, 1 ; Cache level ID register
        DebugChar a3,a4,54
        BIC     a1, a1, #&FF000000 ; Discard unification/coherency bits
        MOV     a2, #0 ; Current cache level
20
        DebugChar a3,a4,49
        ANDS    a3, a1, #7 ; Get flags
        BEQ     %FT10 ; Cache clean complete
        MCR     p15, 2, a2, c0, c0, 0 ; Program cache size selection register
        myISB
        MRC     p15, 1, a3, c0, c0, 0 ; Get size info
        AND     v1, a3, #&7 ; log2(Line size)-2
        BIC     a3, a3, #&F0000007 ; Clear flags & line size
        MOV     v2, a3, LSL #19 ; Number of ways-1 in upper 10 bits
        MOV     v3, a3, LSR #13 ; Number of sets-1 in lower 15 bits
        ; Way number needs to be packed right up at the high end of the data word; shift it up
        CLZ     a4, v2
        MOV     v2, v2, LSL a4
        ; Set number needs to start at log2(Line size)+2
        MOV     v3, v3, LSL #4 ; Start at bit 4
        MOV     v3, v3, LSL v1 ; Start at log2(Line size)+2
        ; Now calculate the offset numbers we will use to increment sets & ways
        BIC     v4, v2, v2, LSL #1 ; Way increment
        BIC     v5, v3, v3, LSL #1 ; Set increment
        ; Now we can finally clean this cache!
        ORR     a3, a2, v3 ; Current way (0), set (max), and level
30
        MCR     p15, 0, a3, c7, c6, 2 ; Invalidate
        ADDS    a3, a3, v4 ; Increment way
        BCC     %BT30 ; Overflow will occur once ways are enumerated
        TST     a3, v3 ; Are set bits all zero?
        SUBNE   a3, a3, v5 ; No, so decrement set and loop around again
        BNE     %BT30
        ; This cache is now clean. Move on to the next level.
        DebugChar a3,a4,50
        ADD     a2, a2, #2
        MOVS    a1, a1, LSR #3
        BNE     %BT20
10
        myDSB
        myISB
        DebugChar a1,a2,51
d143 4
a146 13
        ARM_read_control a1
        ; We assume that ARMs with an I cache can have it enabled while the MMU is off.
        [ :LNOT:CacheOff
        ORR   a1, a1, #MMUC_I
        ]
        ARM_write_control a1                                ; whoosh
        myISB

        ; Keep a soft copy of the CR in a banked register (R13_und)
        MSR     CPSR_c, #F32_bit+I32_bit+UND32_mode
        MOV     sp, a1
        ; Switch into SVC32 mode (we may have been in SVC26 before).
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode                
@


1.13
log
@This time, put the GET directive in the right place, so it fixes all the compile errors and not just the ones AMU's dodgy dependency tracking reported

Version 0.30. Tagged as 'OMAP3-0_30'
@
text
@d20 1
a20 1
        GET     Hdr:ImageSize.<ImageSize>
d22 1
a22 1
        GET     Hdr:MEMM.ARM600
a37 1
        ; Note: there must be only one fixed link from "Top" to "Boot" at +&2000
d62 1
a62 1
        DCD     0                               ; patched in by build system
d198 1
a198 1
        ADRL    v1, HAL_Base + 64*1024          ; v1 -> RISC OS image
d235 1
a235 1
        ADRL    v1, HAL_Base + 64*1024
d237 2
a238 2
        SUB     v1, v1, #64*1024 ; Start of HAL
        ADD     v2, v2, #64*1024 ; Size of HAL+OS
a301 3
; ------------------------------------------------------------------------------
; The RAM setup is locked in the first 8k of ROM
; as is the flash recovery code
a303 1
        ALIGN   sizeofRecoveryArea
@


1.12
log
@Fix OMAP3 HAL compilation - a required GET directive went AWOL

Version 0.29. Tagged as 'OMAP3-0_29'
@
text
@a26 1
        GET     Hdr:CPU.Arch
@


1.11
log
@Update OMAP3 HAL to use correct instruction/memory barrier operations and to handle branch target predictors
Detail:
  hdr/Copro15ops - Added myISB, myDSB, myDMB macros to provide barrier functionality for ARMv6+
  s/Boot, s/Interrupts, s/RAM, s/Top, s/Video - updated to use correct barrier operations after CP15 writes, and to invalidate branch predictors where appropriate
Admin:
  Tested on rev C2 beagleboard


Version 0.28. Tagged as 'OMAP3-0_28'
@
text
@d27 1
d286 16
@


1.10
log
@Various OMAP3 HAL power management improvements, plus add support for board config autodetection via Linux machine ID
Detail:
  s/board, hdr/board - Add Linux machine ID & available mixer channels to board config table
  s/Top - Add new entry point at offset &64, for booting as a fake Linux kernel. Searches the board config table until it finds a config matching the machine ID passed in R1. Also minor ROM copy optimisation, unsigned pointer comparison fixes
  s/Audio, hdr/Audio - Use board config to lock-out mixer channels that aren't connected to any hardware, to avoid excessive power drain or other problems if the channels get turned on. Also perform many other setting tweaks to tidy up default settings for unused mixer paths/channels.
  s/Video - Fix Video_Init logic when deciding whether to reset DSS, enable DSI PLL drift guard
  s/I2C - Increase I2C timeout values, since the previous values were perhaps a bit low
  s/Audio, s/I2C, s/Interrupts, s/RAM, s/SDMA, s/Timers, s/UART, hdr/UART, s/USB, s/Video - Enable autoidle/smart idle where possible to help save power.
Admin:
  Tested on rev C2 beagleboard


Version 0.21. Tagged as 'OMAP3-0_21'
@
text
@d140 1
d145 1
d165 1
d195 2
d210 1
d259 1
a259 1
        ; Invalidate I-cache
d262 3
@


1.9
log
@Update OMAP HAL to support different board configs, plus use new YearLOIsGood flag to ensure correct RTC handling, plus other misc tidying
Detail:
  The OMAP HAL now has multiple entry points, one per board config. See Top.s/board.s for more info.
  audio.s - Moved APLL_CTL value to board config
  board.s - New file to list all the settings for the different board configs
  boot.s - Change HAL_Init to deal with the new board config stuff
  debug.s - Debug UART now specified in board config
  GPIO.s - A few utility functions for handling OMAP/TPS GPIO pins
  I2C.s - Update to use new board config struct
  RAM.s - Disable the beagleboard-specific RAM init code. Instead we'll just rely on u-boot to initialise all our RAM for us.
  RTC.s - Get rid of the magic numbers, and use the YearLOIsGood flag to indicate to RISC OS that YearLO is 2-digit BCD
  Top.s - Got rid of old debug code and rewrote initial flow to handle detecting & storing the board config
  UART.s - Update to use board config struct, support multiple UARTs
  USB.s - Get EHCI PHY power GPIO from board config
  Video.s - Get DVI framer power GPIO and max pixel rate from board config. Add 'PassiveVideo' option, to build a driver that doesn't alter the video output settings - should hopefully result in a usable display on Touch Book, etc.
  board.hdr - Definition of board config table struct
  GPIO.hdr - Add lots of macros for handling OMAP GPIO pins, new constants for OMAP/TPS GPIO
  I2C.hdr - Added I2C transfer block struct, HAL I2C API transfer states (both moved here from other source files)
  omap3530.hdr - Move/remove some unwanted constants, disable DebugChar for now
  StaticWS.hdr - Move I2C transfer block struct to I2C.hdr, add board config struct to HAL workspace, get rid of unused 64K AllocArea
  Timers.hdr - Tidy up constants a bit
  UART.hdr - Add UARTCLK (moved from StaticWS.hdr), UART IRQ #'s
  Makefile - add GPIO.s
Admin:
  Tested on rev C2 beagleboard. Board configs for other board types may be inaccurate in a couple of places.


Version 0.19. Tagged as 'OMAP3-0_19'
@
text
@d64 1
d74 2
d111 15
d239 1
a239 1
        BGT     %FT20 ; We're in some ROM above RAM. OK to continue with copy.
d241 1
a241 1
        BLE     %FT20 ; We're in some ROM/RAM below our copy destination. OK to continue with copy.
d250 1
a251 1
        SUBS    a3, a3, #4
@


1.8
log
@  GET file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both objasm and asasm.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 0.10. Not tagged
@
text
@d42 7
d50 2
d53 7
a59 11

        B       start
        B       .
        B       .
        B       .
        B       .
        B       .
        B       .
        B       .
        DCD     1024*1024       ; image size (temp hack)

d66 35
a100 19
start
        DebugChar  a1,a2,65
        DebugChar  a1,a2,48
;        MVN     a1, #0
;        BL      hexnumber
;        MVN     a1, #0
;        BL      hexnumber
;        MRS     a1, CPSR ; CPSR 200001d3 - SVC32 FIQ IRQ ImpAbrt
;        BL      hexnumber
;        MRC     p15, 0, a1, c1, c0, 0 ; control register 00c5187a - IZA
;        BL      hexnumber
;        MRC     p15, 0, a1, c1, c0, 1 ; aux control register 00000042 - IBE L2EN
;        BL      hexnumber
;        MRC     p15, 1, a1, c0, c0, 1 ; cache level id register 0a000023 - OK
;        BL      hexnumber
;        MRC     p15, 0, a1, c1, c1, 2 ; nonsecure access control register 00070c00 - PLE, TLB, CL, CP10, CP11 available
;        BL      hexnumber
;        MRC     p15, 0, a1, c1, c0, 2 ; coprocessor access control register 00000000 - all disabled
;        BL      hexnumber
d103 4
a106 29
;hexnumber ; Output a1 in hex to the serial port
;        LDR     a2, =L4_UART3
;        ADR     a3, hextab
;        MOV     a4, #8
;10
;        LDRB    v1, [a2, #UART_LSR]
;        TST     v1, #THRE
;        BEQ     %BT10
;        LDRB    v1, [a3, a1, LSR #28]
;        STRB    v1, [a2, #UART_THR]
;        MOV     a1, a1, LSL #4
;        SUBS    a4, a4, #1
;        BNE     %BT10
;20
;        LDRB    v1, [a2, #UART_LSR]
;        TST     v1, #THRE
;        BEQ     %BT20
;        MOV     v1, #13
;        STRB    v1, [a2, #UART_THR]
;30
;        LDRB    v1, [a2, #UART_LSR]
;        TST     v1, #THRE
;        BEQ     %BT30
;        MOV     v1, #10
;        STRB    v1, [a2, #UART_THR]
;        
;        MOV     pc, lr
;
;hextab  DCB "0123456789abcdef"
d109 2
a110 7

        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND
d115 1
a193 2
        MOV     sb, #0

@


1.7
log
@OMAP3 HAL USB (EHCI) support, interrupt handling fixes
Detail:
  Makefile - added USB to objects list
  s/Boot, s/USB, hdr/StaticWS, hdr/USB - USB EHCI code
  s/Debug, s/Stubs, s/Timers, s/Top, s/UART, s/Video - Debugging tweaks and header dependency fixes
  s/Interrupts, hdr/omap3530 - Interrupt fixes & debugging code
  hdr/PRCM - typo fix
Admin:
  Tested on rev C2 beagleboard


Version 0.08. Tagged as 'OMAP3-0_08'
@
text
@d273 1
a273 1
        GET     s.RAM
@


1.6
log
@OMAP3 HAL cache clean fix
Detail:
  s/Top - Fix cache clean code to iterate sets/ways/cache levels correctly
Admin:
  Tested on rev C2 beagleboard


Version 0.07. Tagged as 'OMAP3-0_07'
@
text
@d28 1
a29 1
        GET     hdr.omap3530
@


1.5
log
@OMAP3 HAL Beagleboard Rev C support, further video work.
Detail:
  s/Boot - Fixes for rev C beagleboard. Added GPIO code.
  s/Debug - DebugHALPrint, DebugHALPrintReg routines
  s/PRCM - PRCM_GetFreqSel added
  s/RAM - Fixes for rev C beagleboard. Sped up RAM clear by using more regs.
  s/Top - Fixes for rev C beagleboard
  s/Video - Video code potentially complete, but full of bugs and so still disabled.
  hdr/GPIO - Added GPIO registers
  hdr/omap3530 - Fixes for rev C beagleboard, GPIO, debug macros, QEMU support for new video code
  hdr/SDRC - Typo fix
  hdr/StaticWS - GPIO, pixel rate entries added
  hdr/Video - DSI PLL registers added
Admin:
  Tested on rev C beagleboard.


Version 0.04. Tagged as 'OMAP3-0_04'
@
text
@d157 1
a157 1
        MOV     v3, a3, LSR #13 ; Number of sets-1 in upper 15 bits
d161 3
a163 3
        ; Set number needs to start at log2(Line size)
        MOV     v3, v3, LSR #15 ; Start at bit 2
        MOV     v3, v3, LSL v1 ; Start at log2(Line size)
@


1.4
log
@OMAP3 HAL fixes and further video work
Detail:
  s/Boot - Store some workspace vars used by video code. Disable some debug output.
  s/Interrupts - Update HAL_IRQClear to allow clearing of VSync IRQ
  s/Top - Fix CP15 flags
  s/Video - Implemented majority of video code needed by kernel. Correct code for calculating and programming pixel clocks still required, so code remains disabled by default.
  hdr/PRCM - Correct typo
  hdr/StaticWS - Add video-related workspace entries
  hdr/Video - Add constants for mouse pointer image buffer size
Admin:
  Tested under qemu-omap3 and rev B6 beagleboard.


Version 0.03. Tagged as 'OMAP3-0_03'
@
text
@d34 1
d204 4
a207 1
        ; RISC OS assumes that the first N bytes of the first registered block of RAM is free; therefore we must make sure that we don't inhabit that area
d209 1
a209 2
        ; Just below that we'll place the stack
        ; Although with the beagleboard we know we'll be booted from RAM, this code has been written so that it should work if running from ROM (assuming something initialises the RAM first!)
d260 1
a265 1
        ADRL    sp, HAL_Base      ; Wahey! A stack!
@


1.3
log
@  OMAP3 HAL fixes and updates to allow booting on real hardware.
Detail:
  Makefile - add s.PRCM to objects
  s/Boot - Call PRCM_SetClocks during HAL_Init. Added (disabled) debugging code.
  s/Interrupts - Updated HAL_IRQSource, HAL_FIQSource to query ARM interrupt state instead of relying on INTC alone to detect whether an interrupt is firing or not.
  s/PRCM - Code to measure system clock frequency, store it for HAL purposes, and notify the OMAP of the frequency in order to ensure correct operation.
  s/Timers - Use measured system clock frequency as the timer frequency instead of hard-coded value. Return correct values from HAL_TimerPeriod.
  s/Top - Added (disabled) debugging code. Updated ARM initialisation to use correct cache cleaning procedure.
  s/Video - Further minor work towards completing video driver.
  hdr/CoPro15ops - Deprecate ARM_flush_* macros
  hdr/PRCM - Add more register addresses
  hdr/StaticWS - Add entried for PowerMan & 32K timer logical addresses, system clock speed
  hdr/Timers - remove incorrect, hard-coded timer frequency
  hdr/omap3530 - remove unused FlashCheck global, add DebugChar macro
Admin:
  Tested with HALTester and the RISC OS kernel using qemu-omap3.
  Tested with HALTester on a rev. B6 beagleboard.


Version 0.02. Tagged as 'OMAP3-0_02'
@
text
@d61 2
a62 2
;        DebugChar  a1,a2,65
;        DebugChar  a1,a2,48
d127 1
a127 1
        MOV     a1, #&38 ; Matches MMUC_L+MMUC_D+MMUC_P+MMUC_W, which are now reserved bits in the Cortex spec, but should be written as 1
@


1.2
log
@Basic OMAP3 HAL
Detail:
  Performs startup procedure suitable for any location in ROM or RAM. UART, timer, counter, interrupt & debug functionality implemented. Video support incomplete and nonfunctional.
Admin:
  Tested with HALTester & RISC OS kernel under qemu-omap3


Version 0.01. Tagged as 'OMAP3-0_01'
@
text
@d33 1
d61 18
d81 30
d121 2
a122 2
; Start of ROM,do some ARM core set up then see if
; there's any RAM plugged in
d124 1
d126 9
a134 2
        MOV     a1, #&70
        MCR     p15, 0, a1, c1, c0              ; MMU, caches etc off
d136 46
a181 2
        MCR     p15, 0, a1, c7, c7              ; invalidate caches
        MCR     p15, 0, a1, c8, c7              ; invalidate TLBs
d188 1
a188 31
 [ :LNOT: FlashCheck
        ; Can't do this,as the OS might be corrupt
        MOV     a1, #0
        CallOSM OS_InitARM
 |
        ; Take a local copy from the Kernel,knowing we're on an XScale
        GET     hdr.Copro15ops

        MOVS    a1, #4                          ; XScale is ARM V5T
        MOVEQ   a1, #0
        ARM_read_control a1, NE
        ; Late abort (ARM6 only), 32-bit Data and Program space. No Write buffer (ARM920T
        ; spec says W bit should be set, but I reckon they're bluffing).
        ;
        ; The F bit's tricky. (1 => CPCLK=FCLK, 0=>CPCLK=FCLK/2). The only chip using it was the
        ; ARM700, it never really reached the customer, and it's always been programmed with
        ; CPCLK=FCLK. Therefore we'll keep it that way, and ignore the layering violation.
        ORR     a1, a1, #MMUC_F+MMUC_L+MMUC_D+MMUC_P
        ; All of these bits should be off already, but just in case...
        BIC     a1, a1, #MMUC_B+MMUC_W+MMUC_C+MMUC_A+MMUC_M
        BIC     a1, a1, #MMUC_RR+MMUC_V+MMUC_I+MMUC_Z+MMUC_R+MMUC_S

        ; Off we go.
        ARM_write_control a1

        ; In case it wasn't a hard reset
        MOV     a2, #0
        MCR     ARM_config_cp,0,a2,ARMv4_cache_reg,C7           ; invalidate I+D caches
        MCREQ   ARM_config_cp,0,a2,ARMv3_TLBflush_reg,C0        ; flush TLBs
        MCRNE   ARM_config_cp,0,a2,ARMv4_TLB_reg,C7             ; flush TLBs

d191 1
a191 2
        ORRNE   a1, a1, #MMUC_I
        ARM_write_control a1, NE                                ; whoosh
d193 1
a194 2
        ; Check if we are in a 26-bit mode.
        MRS     a2, CPSR
d199 1
a199 9
        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode
 ]

        MRC     p15, 0, a1, c15, c1             ; Ensure access to CP0,6,7 enabled
        ORR     a1, a1, #2_11000001
        MCR     p15, 0, a1, c15, c1

        MOV     a1, #0
        MCR     p15, 0, a1, c7, c10, 4          ; drain buffers (just in case)
d214 1
d216 1
d244 2
a245 1
        MCR     p15, 0, a1, c7, c5
d257 1
a257 1

d263 1
@


1.1
log
@  Initial commit of a bare bones component for the OMAP3 HAL.
Detail:
  The code does nothing (an infinite loop) but the Makefile implements all
  necessary phases of a ROM build.
Admin:
  Used in a test build.

Version 0.00. Not tagged
@
text
@d1 14
d19 5
d28 6
d36 2
d39 1
d60 1
a60 1
        B       start
d64 145
@


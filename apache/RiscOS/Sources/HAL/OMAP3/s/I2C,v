head	1.16;
access;
symbols
	OMAP3-1_18:1.16
	OMAP3-1_17:1.16
	OMAP3-1_16:1.16
	OMAP3-1_15:1.16
	OMAP3-1_14:1.16
	SMP:1.16.0.2
	SMP_bp:1.16
	OMAP3-1_13:1.16
	OMAP3-1_12:1.16
	OMAP3-1_11:1.16
	OMAP3-1_10:1.16
	OMAP3-1_09:1.16
	OMAP3-1_08:1.16
	OMAP3-1_07:1.16
	OMAP3-1_06:1.16
	OMAP3-1_05:1.16
	OMAP3-1_04:1.16
	OMAP3-1_03:1.15
	OMAP3-1_02:1.15
	OMAP3-1_01:1.15
	OMAP3-1_00:1.15
	OMAP3-0_99:1.15
	OMAP3-0_98:1.15
	OMAP3-0_97:1.15
	OMAP3-0_96:1.14
	OMAP3-0_95:1.13
	OMAP3-0_94:1.13
	OMAP3-0_93:1.13
	OMAP3-0_92:1.13
	OMAP3-0_91:1.13
	OMAP3-0_90:1.13
	OMAP3-0_89:1.13
	OMAP3-0_88:1.12
	OMAP3-0_87:1.12
	OMAP3-0_86:1.12
	OMAP3-0_85:1.12
	OMAP3-0_84:1.12
	OMAP3-0_83:1.12
	OMAP3-0_82:1.12
	OMAP3-0_81:1.12
	OMAP3-0_80:1.12
	OMAP3-0_79:1.12
	OMAP3-0_78:1.12
	OMAP3-0_77:1.12
	OMAP3-0_76:1.12
	OMAP3-0_75:1.12
	OMAP3-0_74:1.12
	OMAP3-0_73:1.12
	OMAP3-0_72:1.12
	OMAP3-0_71:1.11
	OMAP3-0_70:1.11
	OMAP3-0_69:1.11
	OMAP3-0_68:1.10
	OMAP3-0_67:1.10
	OMAP3-0_66:1.10
	OMAP3-0_65:1.10
	OMAP3-0_64:1.10
	OMAP3-0_63:1.10
	OMAP3-0_62:1.10
	OMAP3-0_61:1.10
	OMAP3-0_60:1.9
	OMAP3-0_59:1.9
	OMAP3-0_58:1.9
	OMAP3-0_57:1.9
	OMAP3-0_56:1.9
	OMAP3-0_55:1.9
	OMAP3-0_54:1.9
	OMAP3-0_53:1.9
	OMAP3-0_52:1.9
	OMAP3-0_51:1.9
	OMAP3-0_50:1.9
	OMAP3-0_49:1.9
	OMAP3-0_48:1.9
	OMAP3-0_47:1.9
	OMAP3-0_46:1.9
	OMAP3-0_45:1.9
	OMAP3-0_44:1.9
	OMAP3-0_43:1.9
	OMAP3-0_42:1.9
	OMAP3-0_41:1.8
	OMAP3-0_40:1.8
	OMAP3-0_39:1.8
	OMAP3-0_38:1.7
	OMAP3-0_37:1.7
	OMAP3-0_36:1.7
	OMAP3-0_35:1.7
	OMAP3-0_34:1.7
	OMAP3-0_33:1.7
	OMAP3-0_32:1.6
	OMAP3-0_31:1.5
	OMAP3-0_30:1.5
	OMAP3-0_29:1.5
	OMAP3-0_28:1.5
	OMAP3-0_27:1.5
	OMAP3-0_26:1.5
	OMAP3-0_25:1.5
	OMAP3-0_24:1.5
	OMAP3-0_23:1.5
	OMAP3-0_22:1.5
	OMAP3-0_21:1.5
	OMAP3-0_20:1.4
	OMAP3-0_19:1.4
	OMAP3-0_18:1.3
	OMAP3-0_17:1.2
	OMAP3-0_16:1.2
	OMAP3-0_15:1.2
	OMAP3-0_14:1.2
	OMAP3-0_13:1.2
	OMAP3-0_12:1.1;
locks; strict;
comment	@# @;


1.16
date	2015.04.08.07.37.49;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	KMkj6KKX1Lup6Lgy;

1.15
date	2014.07.20.14.17.28;	author jlee;	state Exp;
branches;
next	1.14;
commitid	kuWegyKgNNXFJ7Jx;

1.14
date	2014.04.14.19.25.13;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	05qR1NVtp11zyGwx;

1.13
date	2013.09.28.07.07.51;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	jSkqFhfWJkacQa7x;

1.12
date	2012.07.09.07.23.31;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	7gpK5cMp8ToogRbw;

1.11
date	2012.07.04.17.57.59;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	XMhv0CBs1aW0Wgbw;

1.10
date	2012.03.25.11.49.07;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	c99VvmwezV2J8gYv;

1.9
date	2011.03.20.17.04.07;	author jlee;	state Exp;
branches;
next	1.8;
commitid	MYulLwX3WKwbOBcv;

1.8
date	2011.02.19.22.26.29;	author jlee;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.26.23.27.14;	author jlee;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.14.20.58.50;	author jlee;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.30.00.23.19;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.24.02.49.32;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.16.04.09.59;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.23.01.03.02;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.17.00.16.34;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Rename a couple of symbols in PAudio missed in OMAP3-1_03.
Built, but not tested.


Version 1.04. Tagged as 'OMAP3-1_04'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries
        
        GET     hdr.omap3530
        GET     hdr.StaticWS
        GET     hdr.Timers
        GET     hdr.PRCM

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  I2C_Init

        EXPORT  HAL_IICBuses
        EXPORT  HAL_IICType
        EXPORT  HAL_IICDevice
        EXPORT  HAL_IICTransfer
        EXPORT  HAL_IICMonitorTransfer
        EXPORT  HAL_VideoIICOp
        EXPORT  IIC_DoOp_Poll

        IMPORT  HAL_CounterDelay

; The OMAP3530 has 4 I2C controllers:
; I2C1 - On the beagleboard this is connected to the TWL/TPS companion chip. RISC OS sees it as I2C bus 0.
; I2C2 - On the beagleboard this is routed to the expansion connector, and so has no use by default. RISC OS sees it as I2C bus 1.
; I2C3 - On the beagleboard this is routed to the HDMI connector. This means its sole use is for reading EDID/DDC data. RISC OS therefore accesses it via HAL_VideoIICOp.
; I2C4 - This is a bus that the OMAP does not fully expose to the programmer. Connected to the TWL/TPS, it's part of the PRCM system. RISC OS does not see this bus at all, and neither does this code.

                GBLL    I2CDebug
I2CDebug        SETL {FALSE} :LAND: Debug

                GBLL    I2CDebugData ; Display bytes sent & received?
I2CDebugData    SETL {FALSE} :LAND: I2CDebug

                GBLL    I2CDebugError ; Debug unexpected_error occurences
I2CDebugError   SETL {FALSE} :LAND: Debug

I2C_Init
        Push    "v1-v3,lr"
 [ I2CDebug
        DebugTX "I2C_Init"
 ]
        ; 1. Make sure clocks are enabled
        LDR     a1, L4_ClockMan_Log
        LDR     a2, [a1, #CM_ICLKEN1_CORE]
        ORR     a2, a2, #7:SHL:15
        STR     a2, [a1, #CM_ICLKEN1_CORE]
        LDR     a2, [a1, #CM_FCLKEN1_CORE]
        ORR     a2, a2, #7:SHL:15
        STR     a2, [a1, #CM_FCLKEN1_CORE]
        ; Wait for power?
        MOV     a1, #50*1024 ; 50msec ish
        BL      HAL_CounterDelay
        ; 2. Initialise each I2C controller
        MOV     v1, #3
        ADR     v2, I2C_Table
10
 [ I2CDebug
        DebugReg  v1, "remaining busses: "
 ]
        LDR     v3, [v2, #I2C_HW]
        CMP     v3, #0
        BEQ     %FT30 ; Skip unused busses
        ; First we'll reset the controller
        LDRH    a4, [v3, #I2C_CON]
        TST     a4, #1:SHL:15
        BEQ     %FT20
        MOV     a4, #0
        STRH    a4, [v3, #I2C_CON]
        ; The manual makes no mention of it, but u-boot waits for a while after enabling & disabling each controller. So to play it safe I'll follow u-boot's lead.
        MOV     a1, #50*1024 ; 50msec ish
        BL      HAL_CounterDelay
20
        MOV     a4, #2
        STRH    a4, [v3, #I2C_SYSC]
        MOV     a4, #1:SHL:15
        STRH    a4, [v3, #I2C_CON]
        ; Wait
        MOV     a1, #10*1024 ; 10msec ish
        BL      HAL_CounterDelay
20
        LDRH    a4, [v3, #I2C_SYSS]
        TST     a4, #1
        BEQ     %BT20
        ; Now disable the controller again so we can program it properly
        MOV     a4, #0
        STRH    a4, [v3, #I2C_CON]
        ; Wait
        MOV     a1, #50*1024 ; 50msec ish
        BL      HAL_CounterDelay
        ; Set up the 12MHz sampling clock
        MOV     a4, #7
        STRH    a4, [v3, #I2C_PSC]
        ; Run at 100kbps for now. TODO - Add support for higher speeds!
        ; i.e. SCLL, SCLH = 12000000/(2*100000) = 60 (-7 for SCLL, -5 for SCLH)
        MOV     a4, #60-7
        STRH    a4, [v3, #I2C_SCLL]
        MOV     a4, #60-5
        STRH    a4, [v3, #I2C_SCLH]
        ; Program own address
        MOV     a4, #1
        STRH    a4, [v3, #I2C_OA0]
        ; Set FIFO thresholds
        LDRH    a4, [v3, #I2C_BUFSTAT]
        ADR     a3, fifo_thresholds
        AND     a4, a4, #&C000 ; Get FIFO size
        LDR     a4, [a3, a4, LSR #12]
        STRH    a4, [v3, #I2C_BUF]
        ; Enable auto idle, smart idle. Both clocks off when in idle mode?
        MOV     a4, #1+(2<<3)
        STRH    a4, [v3, #I2C_SYSC]
        ; Enable the controller
        MOV     a4, #1:SHL:15
        STRH    a4, [v3, #I2C_CON]
        ; Next!
        SUBS    v1, v1, #1
        ADD     v2, v2, #I2CBlockSize
        BNE     %BT10
        ; Wait for last controller to init fully
        MOV     a1, #10*1024 ; 10msec ish
        BL      HAL_CounterDelay
        ; Done
30
 [ I2CDebug
        DebugTX "I2C_Init complete"
 ]
        Pull    "v1-v3,pc"

fifo_thresholds
        DCD     &0606 ; 8 byte FIFO: Threshold at 7 bytes
        DCD     &0B0B ; 16 byte FIFO: Threshold at 12 bytes
        DCD     &1B1B ; 32 byte FIFO: Threshold at 28 bytes
        DCD     &3B3B ; 64 byte FIFO: Threshold at 60 bytes

HAL_IICBuses
        LDRB    a1, [sb, #BoardConfig_NumI2C]
        MOV     pc, lr

HAL_IICType
        ; todo - set the 'missing flags' alluded to in Kernel.Docs.HAL.MoreEnts? (multi-master & slave operation)
        LDRB    a2, [sb, #BoardConfig_NumI2C]
        CMP     a1, a2
        MOVHS   a1, #0
        LDRLO   a1, =IICFlag_HighLevel+IICFlag_Fast+IICFlag_Background+IICFlag_HighSpeed+(210:SHL:20)
        MOV     pc, lr

; HAL_IICDevice
; in:
;       r0 = bus number
; out:
;       r0 = device number

HAL_IICDevice
        LDRB    a3, [sb, #BoardConfig_NumI2C]
        CMP     a1, a3
        MOVHS   a1, #-1
        ADDLO   a3, sb, #BoardConfig_HALI2CIRQ
        LDRLOB  a1, [a3, a1]
        MOV     pc, lr

; HAL_IICTransfer
; in:
;      r0 = bus number
;      r1 = number of transfers
;      r2 = iic_transfer array ptr
; out:
;      r0 = IICStatus return code
; Transfer list format:
;      typedef struct iic_transfer
;      {
;        unsigned addr:8;
;        unsigned :22;
;        unsigned checksumonly:1;
;        unsigned nostart:1;
;        union
;        {   unsigned checksum;
;            void *data;
;        } d;
;        unsigned len;
;      } iic_transfer;

HAL_IICTransfer
        LDRB    a4, [sb, #BoardConfig_NumI2C]
        CMP     a1, a4
        MOVHS   a1, #IICStatus_Error
        MOVHS   pc, lr
        ; Quickly validate the transfer list
        ; We have several constraints:
        ; 1. Must have 1 or more iic_transfers
        ; 2. First transfer must not have nostart bit set
        ; 3. Between start bits (and between the last start bit and the end of  the list) there must be between 1 and 65536 bytes of data (but for the moment we do allow individual iic_transfers to be 0-length)
        CMP     a2, #0
        MOVLT   a1, #IICStatus_Error
        MOVLT   pc, lr
        LDR     a4, [a3]
        TST     a4, #1:SHL:31 ; First transfer has nostart set!
        MOVNE   a1, #IICStatus_Error
        MOVNE   pc, lr
        STMFD   sp!, {v1-v5,lr}
        ADD     a4, a3, a2, LSL #3
        ADD     a4, a4, a2, LSL #2
        MOV     v1, a3
30
        MOV     v5, #-1
10
        LDMIB   v1!, {v2-v4}    ; data ptr & length from current transfer, flags from next
        ADD     v5, v5, v3
        CMP     v1, a4
        BEQ     %FT20           ; Last transfer just read
        TST     v4, #1:SHL:31
        BNE     %BT10           ; Still more data in this transfer
20
        CMP     v5, #65536
        MOVHS   a1, #IICStatus_Error    ; Too much (or too little) data
        LDMHSIA sp! ,{v1-v5,pc}
        CMP     v1, a4
        BNE     %BT30
_IICTransfer_Video ; Entry point for HAL_VideoIICOp
 [ I2CDebug
        DebugTX "HAL_IICTransfer"
        DebugReg a1, "bus="
        DebugReg a2, "num="
        DebugReg a3, "iic_transfer="
 ]
        ADR     v5, I2C_Table
        MOV     v4, #I2CBlockSize
        MLA     v5, a1, v4, v5
        MRS     ip, CPSR
        ORR     a4, ip, #I32_bit
        MSR     CPSR_c, a4              ; disable interrupts for atomic claim
        LDR     a4, [v5, #I2C_XStart]
        TEQ     a4, #0                  ; in use already?
        STREQ   a3, [v5, #I2C_XStart]   ; if not, claim it
        MSR     CPSR_c, ip
        MOVNE   a1, #IICStatus_Busy     ; if it is, return "BUSY"
 [ I2CDebug
        BEQ     %FT10
        DebugReg a4, "BUSY: XStart="
        LDMFD   sp!, {v1-v5,pc}
10
        DebugTX "OK"
 |
        LDMNEFD sp!, {v1-v5,pc}
 ]
        SUB     a2, a2, #1              ; a2 = transfers - 1 (needed below)
        ADD     v1, a3, a2, LSL #3
        ADD     v1, v1, a2, LSL #2
        STR     v1, [v5, #I2C_XEnd]
        LDR     v4, [v5, #I2C_HW]
        ; Make sure controller is enabled, since we don't do any initialisation atm!
        LDRH    a4, [v4, #I2C_CON]
        TST     a4, #1:SHL:15
        LDREQH  v3, [v4, #I2C_STAT]
 [ I2CDebugError
        BNE     %FT10
        DebugTX "Controller not enabled!"
        B       unexpected_error
10
 |
        BEQ     unexpected_error
 ]
        MOV     v1, a3
start_transfer ; Start the transfer in v1
        ; a1-a4 free
        ; v1 = iic_transfer to start
        ; v2-v3 free
        ; v4 = I2C controller ptr
        ; v5 = I2C state ptr
 [ I2CDebug
        DebugReg v1, "start_transfer: "
 ]
        STR     v1, [v5, #I2C_XCurrent]
        MOV     lr, #0
        STR     lr, [v5, #I2C_XBytes]
        ; Get its info
        LDMIA   v1, {a1-a3}
 [ I2CDebug
        DebugReg a1, "addr="
        DebugReg a2, "data="
        DebugReg a3, "len ="
 ]
        ; If it's a 'checksum-only' read, clear the checksum to 0
        TST     a1, #1:SHL:30
        TSTNE   a1, #1
        MOVNE   a2, #0
        STRNE   a2, [v1, #4]
        ; Wait for the controller to be fully idle - if two iic_transfer lists are executed back-to-back then there's a chance the controller won't have yet sent the stop bit from the previous transfer. Thus we must wait here for the bit to be sent.
        MOV     v2, #100*1024 ; timeout - this should be more than adequate (with a CPU of 1GHz, there'd be 10K CPU clock cycles per 100kbps I2C clock cycle)
10
        LDRH    a4, [v4, #I2C_CON]
        TST     a4, #3 ; Check STT and STP (Although we're primarily interested in STP, the manual warns about bad things happening if STT is cleared)
        BEQ     %FT20
        SUBS    v2, v2, #1
        BNE     %BT10
 [ I2CDebug
        DebugReg a4, "ISC_CON timeout: "
 ]
        MOV     a1, #IICStatus_Busy
        MOV     v3, #0
        STR     v3, [v5, #I2C_XStart]
        LDMFD   sp!, {v1-v5,pc}
20
        ; Flush the RX/TX FIFOs
        ; The manual says we only need to do this on NACK errors, but to play it safe I'm going to do it at the start of each transfer
        LDRH    v2, [v4, #I2C_BUF]
        LDR     v3, =&4040
        ORR     v2, v2, v3
        STRH    v2, [v4, #I2C_BUF]
10
        LDRH    v2, [v4, #I2C_BUF]
        TST     v2, v3
        BNE     %BT10           
        ; Configure controller
        ; 1. I2C_CON.MST, ISC_CON.TRX
        BIC     a4, a4, #&FF ; Clear STT, STP, XOA0-XOA3
        BIC     a4, a4, #&F00 ; Clear STB, MST, TRX, XSA
        ORR     a4, a4, #&400 ; Set MST (slave mode not supported ATM)
        TST     a1, #1
        ORREQ   a4, a4, #&200 ; Set transmitter mode if appropriate
        STRH    a4, [v4, #I2C_CON]
        ; Clear any pending interrupts, just in case?
        LDRH    v2, [v4, #I2C_STAT]
        STRH    v2, [v4, #I2C_STAT]
        ; 2. I2C_IE.XRDY_IE, I2C_IE.RRDY
        MOVEQ   v2, #&17 ; AL_IE, NACK_IE, ARDY_IE, XRDY_IE
        MOVNE   v2, #&0F ; AL_IE, NACK_IE, ARDY_IE, RRDY_IE
        ORREQ   v2, v2, #&4000 ; XDR_IE
        ORRNE   v2, v2, #&2000 ; RDR_IE
        STRH    v2, [v4, #I2C_IE]
        ; 3. Ignore DMA for now
        ; 4. I2C_SA, I2C_CNT
        MOV     v2, a1, LSR #1
        AND     v2, v2, #&7F
        STRH    v2, [v4, #I2C_SA]
        ; The I2C controller doesn't seem to like it if we don't send a start bit - it simply ignores I2C_CNT and goes straight to sending the stop bit (or sits there and does nothing if no stop bit was wanted).
        ; So to get around this we scan forward through the iic_transfer list and set I2C_CNT to the number of bytes to transmit before the next start/stop bit is required
        MOV     v2, v1
        LDR     ip, [v5, #I2C_XEnd]
10
        CMP     ip, v2
        ORREQ   a4, a4, #2 ; Last transfer in list; set stop bit
        BEQ     %FT20
        ADD     v2, v2, #12 ; Increment after compare, just in case some crazy person creates an iic_transfer that wraps from &FFF.... to &000...
        LDMIA   v2,{a1-a2,v3} ; Get transfer info
        TST     a1, #1:SHL:31
        ADDNE   a3, a3, v3 ; nostart is set; increment length and loop around
        BNE     %BT10
20
 [ I2CDebug
        DebugReg a3, "I2C_CNT="
 ]
        STRH    a3, [v4, #I2C_CNT]
        ; 5. Wait for I2C_STAT.BB to 0 (but only if this is the first iic_transfer of a sequence - otherwise we'll be stuck waiting to unlock a bus we already own)
        LDR     v2, [v5, #I2C_XStart]
        CMP     v1, v2 ; v1 = I2C_XCurrent from earlier
        BNE     %FT20
        MOV     v2, #50*1024 ; timeout
10
        LDRH    v3, [v4, #I2C_STAT]
        TST     v3, #1:SHL:12
        BEQ     %FT20
        SUBS    v2, v2, #1
        BNE     %BT10
 [ I2CDebug
        DebugReg v3, "BB timeout: I2C_STAT="
 ]
        MOV     a1, #IICStatus_Busy
        B       clear_and_return
20
        ; 6. configure I2C_CON.STT=1, I2C_CON.STP=0/1
        ORR     a4, a4, #1 ; Always send start bit
        ; If required, stop bit will already have been set by the I2C_CNT calculator
        STRH    a4, [v4, #I2C_CON]
        ; Now we just sit back and wait for the interrupts?
 [ I2CDebug
        DebugTX "Transfer started"
 ]        
        MOV     a1, #IICStatus_InProgress
        LDMFD   sp!, {v1-v5,pc}

        ; For receive:
        ; 1. Use I2C_IE.RRDY_IE
        ; 2. Except we use I2C_IE.RDR_IE if the receive size doesn't match the RX FIFO threshold?
        ; For transmit:
        ; 1. Use I2C_IE.XRDY_IE
        ; 2. Except we use I2C_IE.XDR_IE if the length doesn't match the TX FIFO threshold?

; Return IICStatus state for transfer on bus r0
; Called on appropriate interrupt
HAL_IICMonitorTransfer
        ; Process the interrupts, according to figures 18-31/18-32 in spruf98b
        STMFD   sp!, {v1-v5,lr}
 [ I2CDebug
        DebugReg a1, "HAL_IICMonitorTransfer: bus "
 ]
        ADR     v5, I2C_Table
        MOV     v4, #I2CBlockSize
        MLA     v5, a1, v4, v5
        LDR     v4, [v5, #I2C_HW]
        LDR     a1, [v5, #I2C_XStart]
 [ I2CDebug
        DebugReg a1, "XStart="
 ]
        LDRH    v3, [v4, #I2C_STAT]
        TEQ     a1, #0 ; If no transfer, shut off all interrupts
        ASSERT  IICStatus_Completed=0
 [ I2CDebug
        BNE     %FT10
        DebugTX "No XStart!"
        TEQ     a1, #0 ; reset EQ condition
10
 ]
        STREQH  a1, [v4, #I2C_IE]
        STREQH  v3, [v4, #I2C_STAT]
        LDMEQFD sp!, {v1-v5,pc}
 [ I2CDebug
        DebugReg v3, "I2C_STAT="
 ]
        TST     v3, #2
        BNE     i2c_nack
        TST     v3, #1
        BNE     i2c_al
        TST     v3, #4
        BNE     i2c_ardy
        TST     v3, #1:SHL:14
        BNE     i2c_xdr
        TST     v3, #1:SHL:4
        BNE     i2c_xrdy
        TST     v3, #1:SHL:13
        BNE     i2c_rdr
        TST     v3, #1:SHL:3
        BNE     i2c_rrdy
        ; Did anything actually happen?
        BIC     v3, v3, #&1d00 ; Clear XUDF, ROVR, BB, BF - they're status bits and don't indicate anything we care about here
        CMP     v3, #0
        MOVEQ   a1, #IICStatus_InProgress ; If nothing interesting happened, claim everything is OK (required for polling-mode transfers, e.g. HAL_VideoIICOp)
        LDMEQFD sp!, {v1-v5,pc}
        ; Else bad stuff - unhandled interrupt
 [ I2CDebugError
        DebugReg v3, "Unhandled IRQ - "
 ]
unexpected_error
        MOV     a1, #IICStatus_Error
clear_and_return
 [ I2CDebug
        DebugReg a1, "clear_and_return: "
 ]
        STRH    v3, [v4, #I2C_STAT]
        MOV     v3, #0
        STR     v3, [v5, #I2C_XStart]
        LDMFD   sp!, {v1-v5,pc}

i2c_nack
        ; No ack was received - give up and return error
        MOV     a1, #IICStatus_NoACK
        B       clear_and_return

i2c_al
        ; Arbitration lost - restart the transfer list
        STRH    v3, [v4, #I2C_STAT]
        LDR     v1, [v5, #I2C_XStart]
        B       start_transfer

i2c_ardy
        ; Previous transfer has completed successfully; start a new one
        LDR     a3, [v5, #I2C_XCurrent]
        LDR     a2, [v5, #I2C_XBytes]
        LDR     ip, [a3, #8]
        CMP     a2, ip
 [ I2CDebugError
        BEQ     %FT10
        DebugTX "HW requested wrong byte count"
        DebugReg a2, "I2C_XBytes="
        DebugReg ip, "xfer len="
        B       unexpected_error
10
 |
        BNE     unexpected_error ; Hardware hasn't requested the full number of bytes
 ]
        LDR     a4, [v5, #I2C_XEnd]
        CMP     a3, a4
        MOVEQ   a1, #IICStatus_Completed
        BEQ     clear_and_return
        ; Skip any zero-length nostart transfers that follow this one
        ADD     v1, a3, #12
10
        LDMIA   v1, {a1-a3}
        TST     a1, #1:SHL:31
        STREQH  v3, [v4, #I2C_STAT]
        BEQ     start_transfer
        CMP     a3, #0
 [ I2CDebugError
        BEQ     %FT5
        DebugReg a3, "nostart transfer with nonzero length, length="
        B       unexpected_error
5
 |
        BNE     unexpected_error ; nostart transfer with nonzero length = hardware hasn't requested full number of bytes
 ]
        CMP     v1, a4
        MOVEQ   a1, #IICStatus_Completed
        BEQ     clear_and_return
        ADD     v1, v1, #12
        B       %BT10


i2c_xdr
        ; Transfer I2C_BUFSTAT[5:0] bytes
        LDRH    a4, [v4, #I2C_BUFSTAT]
        AND     a4, a4, #&3F
        B       send_bytes        

i2c_xrdy
        ; Transfer I2C_BUF[5:0]+1 bytes
        LDRH    a4, [v4, #I2C_BUF]
        AND     a4, a4, #&3F
        ADD     a4, a4, #1
send_bytes
 [ I2CDebug
        DebugReg  a4, "send_bytes: "
 ]
        LDR     v2, [v5, #I2C_XCurrent]
        LDR     a3, [v5, #I2C_XBytes] ; Get bytes sent
        LDMIB   v2, {a2,ip} ; Get data ptr, transfer length
10
        ; Check if we need to advance to the next iic_transfer
        CMP     a3, ip
        BEQ     %FT20 
        LDRB    v1, [a2,a3]
 [ I2CDebugData
        DebugRegByte v1
 ]
        ADD     a3, a3, #1
        SUBS    a4, a4, #1
        STRB    v1, [v4, #I2C_DATA]
        BNE     %BT10
 [ I2CDebugData
        DebugTX ""
 ]
        STR     a3, [v5, #I2C_XBytes]        
        MOV     a1, #IICStatus_InProgress
        STRH    v3, [v4, #I2C_STAT]
        LDMIA   sp!, {v1-v5,pc}
20
        ; Advance to next iic_transfer
        LDR     a3, [v5, #I2C_XEnd]
        CMP     a3, v2
 [ I2CDebugError
        BNE     %FT5
        DebugTX "End of transfer list but hardware wants more"
        B       unexpected_error
5
 |
        BEQ     unexpected_error ; Hardware is asking for more data than we can give
 ]
        ADD     v2, v2, #12
        STR     v2, [v5, #I2C_XCurrent]
        MOV     a3, #0
        STR     a3, [v5, #I2C_XBytes]
        LDMIA   v2, {a1-a2,ip}
        TST     a1, #1:SHL:31
        BNE     %BT10
 [ I2CDebugError
        DebugTX "nostart reached but hardware wants more"
 ]
        B       unexpected_error ; Hardware is asking for more data than we can give

i2c_rdr
        ; Read I2C_BUFSTAT[13:8] bytes
        LDRH    a4, [v4, #I2C_BUFSTAT]
        MOV     a4, a4, LSR #8
        ANDS    a4, a4, #&3F ; ERRATA - sometimes RDR is set when there's no data. So, don't attempt to read from the empty buffer.
        BEQ     %FT15
        B       read_bytes

i2c_rrdy
        ; Read I2C_BUF[13:8]+1 bytes
        LDRH    a4, [v4, #I2C_BUF]
        MOV     a4, a4, LSR #8
        AND     a4, a4, #&3F
        ADD     a4, a4, #1
read_bytes
 [ I2CDebug
        DebugReg  a4, "read_bytes: "
 ]
        LDR     v2, [v5, #I2C_XCurrent]
        LDMIA   v2, {a1-a2,ip} ; Get checksum flag, data ptr/checksum, transfer length
        LDR     a3, [v5, #I2C_XBytes] ; Get bytes received
10
        ; Check if we need to advance to the next iic_transfer
        CMP     a3, ip
        BEQ     %FT20
        TST     a1, #1:SHL:30 ; Checksum mode?
        LDRB    v1, [v4, #I2C_DATA]
        ADDNE   a2, a2, v1 ; adjust checksum
        STREQB  v1, [a2, a3]
 [ I2CDebugData
        DebugRegByte    v1
 ]
        SUBS    a4, a4, #1
        ADD     a3, a3, #1
        BNE     %BT10
 [ I2CDebugData
        DebugTX ""
 ]
        STR     a2, [v2, #4] ; Update checksum
        STR     a3, [v5, #I2C_XBytes]
15
        MOV     a1, #IICStatus_InProgress
        STRH    v3, [v4, #I2C_STAT]
        LDMIA   sp!, {v1-v5,pc}
20
        ; Advance to next iic_transfer
        LDR     a3, [v5, #I2C_XEnd]
        CMP     a3, v2
 [ I2CDebugError
        BNE     %FT5
        DebugTX "End of transfer list but hardware received more data"
        B       unexpected_error
5
 |
        BEQ     unexpected_error ; Hardware is receiving more data than we want
 ]
        ADD     v2, v2, #12
        STR     v2, [v5, #I2C_XCurrent]
        MOV     a3, #0
        STR     a3, [v5, #I2C_XBytes]
        LDMIA   v2, {a1-a2,ip}
        TST     a1, #1:SHL:31
 [ I2CDebugError
        BNE     %FT5
        DebugTX "nostart reached but hardware received more data"
        B       unexpected_error
5
 |
        BEQ     unexpected_error ; Hardware is receiving more data than we want
 ]
        TST     a1, #1:SHL:30 ; Checksum mode?
        MOVNE   a2, #0 ; Start with zero checksum (as per start_transfer)
        B       %BT10


; int HAL_VideoIICOp(uint32_t op, uint8_t *buffer, uint32_t *size)
; in:
;      r0 = b0-15 offset within IIC device to start at
;           b16-23 base IICAddress
;           b24-31 zero
;      r1 = buffer to read from/write to
;      r2 = pointer to number of bytes to transfer
; returns:
;      r0 = IICStatus return code
;      size = bytes successfully transferred (prior to any error)

HAL_VideoIICOp
        ; Make sure we've got a valid IIC bus to use
        LDRB    a4, [sb, #BoardConfig_VideoI2C]
        CMP     a4, #255
        MOV     ip, #0
        STREQ   ip, [a3]
        MOVEQ   a1, #IICStatus_Error
        MOVEQ   pc, lr
        ; Check if this is an EDID read or write
        UBFX    a4, a1, #16, #8
        TEQ     a4, #&a0 ; Don't allow writing to EDID for safety reasons
        STREQ   ip, [a3]
        MOVEQ   a1, #IICStatus_Error
        MOVEQ   pc, lr
        TEQ     a4, #&a1
        TSTNE   a1, #&ff00 ; If not EDID read, limit to 0-255 offset in device
        STRNE   ip, [a3]
        MOVNE   a1, #IICStatus_Completed
        MOVNE   pc, lr
        Push    "a1-a3,lr"
        LDR     a3, [a3]

        ; Build a set of iic_transfer blocks and call RISCOS_IICOpV
        ; We construct (up to) three iic_transfer blocks
        ; - First block is an (optional) single byte write to the EDID segment pointer
        ; - Second block is a single byte write containing the start address (lower 8 bits of r0)
        ; - Third block is a read. r2 bytes written to r1.
        ; The E-EDID EEPROM spec says that the segment pointer should auto-increment when a sequential (i.e. block) read occurs, so we shouldn't have to worry about splitting requests into 256 byte blocks and manually writing the pointer each time.
        ; Block 3:
        UBFX    a1, a1, #16, #8 ; Extract base IICAddress
        Push    "a1-a3"         ; Push the block on the stack (a2 & a3 are already correct)
        ; Block 2:
        BIC     a1, a1, #1      ; Clear RnW of base address
        ADD     a2, sp, #12     ; sp+12 should point to the 8 bit offset
        MOV     a3, #1
        Push    "a1-a3"
        ; Block 1:
        MOV     a1, #&60        ; Write to segment pointer
        ADD     a2, a2, #1      ; With bits 8-15 of the offset
        Push    "a1-a3"
        ; Work out if block 1 is needed or not
        LDR     a2, [sp, #36]   ; Get r0
        TST     a2, #&ff00      ; If segment == 0
        MOVEQ   a2, #0          ; ... then avoid matching address &A0/&A1
        AND     a2, a2, #&fe0000
        TEQ     a2, #&a00000
        ; Now attempt to start the transfer
        LDRB    a2, [sb, #BoardConfig_VideoI2C]
        MOV     a2, a2, LSL #24
        ADD     a2, a2, #3
        MOV     a1, sp
        SUBNE   a2, a2, #1      ; Skip block 1 if segment == 0 or not EDID addr
        ADDNE   a1, a1, #12
        ; If HAL_Init isn't done yet, we can't use RISCOS_IICOpV
        LDR     a3, HALInitialised
        CMP     a3, #0
        BEQ     %FT10
        LDR     a3, OSentries+4*OS_IICOpV
        BLX     a3
        B       %FT20
10
        BL      IIC_DoOp_Poll
20
        ; In case of error, assume nothing got transferred at all
        CMP     a1, #IICStatus_Completed
        LDREQ   a4, [sp, #(12*2)+(2*4)] ; Block 3 request size
        MOVNE   a4, #0
        ADD     sp, sp, #12*3           ; Junk the iic_transfer blocks
        STR     a1, [sp, #0]            ; Propagate return code
        LDR     a3, [sp, #8]
        STR     a4, [a3]                ; Actual transfer size
        Pull    "a1-a3,pc"

IIC_DoOp_Poll
        ; IIC transfer function that performs a polling transfer, similar to HAL_VideoIICOp
        ; This allows us to do IIC transfers before RISC OS is fully initialised (e.g. from inside HAL_Init)
        ; Parameters are identical to RISCOS_IICOpV:
        ; r0 = iic_transfer array ptr
        ; r1 = bits 0-23: iic_transfer count
        ;      bits 24-31: bus number
        ; Returns IICStatus return code in R0 (0 success, anything else failure)
        Push    "v1,lr"
 [ {FALSE}
        ; If IRQs and IIC IRQ are enabled, panic
        Push    "a1-a4"
        MRS     a1, CPSR
        TST     a1, #I32_bit
        BNE     %FT10
        ADR     a1, BoardConfig_HALI2CIRQ
        LDRB    a1, [a1, a2, LSR #24]
        IMPORT  HAL_IRQDisable
        BL      HAL_IRQDisable
        CMP     a1, #0
        BEQ     %FT10
        DebugTX "Warning - IIC_DoOp_Poll called with IIC IRQ enabled!"
        B       .
10
        Pull    "a1-a4"
 ]
        MOV     a3, a1
        MOV     a1, a2, LSR #24
        BIC     a2, a2, #&ff000000
        MOV     v1, a1
        BL      HAL_IICTransfer
        ; Now just poll until we're done
10
        CMP     a1, #IICStatus_InProgress ; Done?
        Pull    "v1,pc", NE
        ADR     lr, %BT10
        MOV     a1, v1
        B       HAL_IICMonitorTransfer

        END
@


1.15
log
@Disallow EDID writes. Add support for EDID reads which require the segment pointer to be set. Improve Pandora screen blanking.
Detail:
  s/I2C - Revise HAL_VideoIICOp implementation to disallow EDID writes (&A0 IIC address). Attempt to write the EDID segment pointer when accessing EDID addresses >= 256.
  s/Video - Make Pandora screen blanking put the LCD into/out of standby mode. If it's left active while the video sync signals are cut then there'll often be garbage displayed on the screen.
Admin:
  Tested on BB-xM, Pandora


Version 0.97. Tagged as 'OMAP3-0_97'
@
text
@a59 8

 [ I2CDebug :LOR: I2CDebugError
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
        IMPORT  DebugMemDump
        IMPORT  DebugHALPrintByte
 ]

@


1.14
log
@Changed to use simpler HAL_IICDevice

Version 0.96. Tagged as 'OMAP3-0_96'
@
text
@d675 1
a675 1
;      r0 = b0-15 offset within IIC device to start at (currently assumed 8 bit)
d692 11
a702 7
        ; Check for input passed end
        UBFX    a4, a1, #0, #16
        CMP     a4, #256
        STRCS   ip, [a3]
        MOVCS   a1, #IICStatus_Completed
        MOVCS   pc, lr
        ; Clip request at end
a704 3
        ADD     ip, a4, a3
        CMP     ip, #256
        RSBHI   a3, a4, #256
d707 6
a712 4
        ; We construct two iic_transfer blocks
        ; - First block is a single byte write containing the start address (lower 8 bits of r0)
        ; - Second block is a read. r2 bytes written to r1.
        ; Block 2:
d715 1
a715 1
        ; Block 1:
d720 10
a729 1

d733 1
a733 1
        ADD     a2, a2, #2
d735 2
d749 1
a749 1
        LDREQ   a4, [sp, #(3*4)+(2*4)]  ; Clipped block 2 request size
d751 1
a751 1
        ADD     sp, sp, #24             ; Junk the iic_transfer blocks
@


1.13
log
@Modification to RISCOS_IICOpV
Now assumes an IICStatus return, per Kernel-5_35-4_79_2_196.
I2C sources lined up to column 17.
Built, but not tested.

Version 0.89. Tagged as 'OMAP3-0_89'
@
text
@d179 1
a179 2
;       r0 = irq_descriptor ptr
;       r1 = bus number
d181 2
a182 16
;       r0 filled in
; typedef struct irq_descriptor
; {
;     int device;
;     union {
;        struct {
;          unsigned char *addr;
;          int maskandpolarity;
;        } bit;
;        struct {
;          int (*forme)(void *handle);
;          void *handle;
;        } func;
;     } sub;
; } irq_descriptor;
;
d185 2
a186 2
        CMP     a2, a3
        MOVHS   a2, #-1
d188 1
a188 4
        LDRLOB  a2, [a3, a2]
        MOV     a3, #0
        MOV     a4, #0
        STMIA   a1, {a2-a4}
@


1.12
log
@Adopt revised HAL_PhysInfo API
Also spotted that USAT can be conditional in the I2C code.

Version 0.72. Tagged as 'OMAP3-0_72'
@
text
@a24 2
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
d231 4
a234 4
        LDRB      a4, [sb, #BoardConfig_NumI2C]
        CMP       a1, a4
        MOVHS     a1, #IICStatus_Error
        MOVHS     pc, lr
d240 11
a250 11
        CMP       a2, #0
        MOVLT     a1, #IICStatus_Error
        MOVLT     pc, lr
        LDR       a4, [a3]
        TST       a4, #1:SHL:31 ; First transfer has nostart set!
        MOVNE     a1, #IICStatus_Error
        MOVNE     pc, lr
        STMFD     sp!, {v1-v5,lr}
        ADD       a4, a3, a2, LSL #3
        ADD       a4, a4, a2, LSL #2
        MOV       v1, a3
d252 1
a252 1
        MOV       v5, #-1
d254 6
a259 6
        LDMIB     v1!, {v2-v4} ; data ptr & length from current transfer, flags from next
        ADD       v5, v5, v3
        CMP       v1, a4
        BEQ       %FT20 ; Last transfer just read
        TST       v4, #1:SHL:31
        BNE       %BT10 ; Still more data in this transfer
d261 5
a265 5
        CMP       v5, #65536
        MOVHS     a1, #IICStatus_Error    ; Too much (or too little) data
        LDMHSIA   sp! ,{v1-v5,pc}
        CMP       v1, a4
        BNE       %BT30
d273 11
a283 11
        ADR       v5, I2C_Table
        MOV       v4, #I2CBlockSize
        MLA       v5, a1, v4, v5
        MRS       ip, CPSR
        ORR       a4, ip, #I32_bit
        MSR       CPSR_c, a4              ; disable interrupts for atomic claim
        LDR       a4, [v5, #I2C_XStart]
        TEQ       a4, #0                  ; in use already?
        STREQ     a3, [v5, #I2C_XStart]   ; if not, claim it
        MSR       CPSR_c, ip
        MOVNE     a1, #IICStatus_Busy     ; if it is, return "BUSY"
d285 1
a285 1
        BEQ %FT10
d287 1
a287 1
        LDMFD     sp!, {v1-v5,pc}
d291 1
a291 1
        LDMNEFD   sp!, {v1-v5,pc}
d293 5
a297 5
        SUB       a2, a2, #1              ; a2 = transfers - 1 (needed below)
        ADD       v1, a3, a2, LSL #3
        ADD       v1, v1, a2, LSL #2
        STR       v1, [v5, #I2C_XEnd]
        LDR       v4, [v5, #I2C_HW]
d299 3
a301 3
        LDRH      a4, [v4, #I2C_CON]
        TST       a4, #1:SHL:15
        LDREQH    v3, [v4, #I2C_STAT]
d303 3
a305 3
        BNE       %FT10
        DebugTX   "Controller not enabled!"
        B         unexpected_error
d308 1
a308 1
        BEQ       unexpected_error
d310 1
a310 1
        MOV       v1, a3
d320 3
a322 3
        STR       v1, [v5, #I2C_XCurrent]
        MOV       lr, #0
        STR       lr, [v5, #I2C_XBytes]
d324 1
a324 1
        LDMIA     v1, {a1-a3}
d331 4
a334 4
        TST       a1, #1:SHL:30
        TSTNE     a1, #1
        MOVNE     a2, #0
        STRNE     a2, [v1, #4]
d336 1
a336 1
        MOV       v2, #100*1024 ; timeout - this should be more than adequate (with a CPU of 1GHz, there'd be 10K CPU clock cycles per 100kbps I2C clock cycle)
d338 12
a349 12
        LDRH      a4, [v4, #I2C_CON]
        TST       a4, #3 ; Check STT and STP (Although we're primarily interested in STP, the manual warns about bad things happening if STT is cleared)
        BEQ       %FT20
        SUBS      v2, v2, #1
        BNE       %BT10
 [ I2CDebug
        DebugReg  a4, "ISC_CON timeout: "
 ]
        MOV       a1, #IICStatus_Busy
        MOV       v3, #0
        STR       v3, [v5, #I2C_XStart]
        LDMFD     sp!, {v1-v5,pc}
d353 8
a360 8
        LDRH      v2, [v4, #I2C_BUF]
        LDR       v3, =&4040
        ORR       v2, v2, v3
        STRH      v2, [v4, #I2C_BUF]
10
        LDRH      v2, [v4, #I2C_BUF]
        TST       v2, v3
        BNE       %BT10           
d363 6
a368 6
        BIC       a4, a4, #&FF ; Clear STT, STP, XOA0-XOA3
        BIC       a4, a4, #&F00 ; Clear STB, MST, TRX, XSA
        ORR       a4, a4, #&400 ; Set MST (slave mode not supported ATM)
        TST       a1, #1
        ORREQ     a4, a4, #&200 ; Set transmitter mode if appropriate
        STRH      a4, [v4, #I2C_CON]
d370 2
a371 2
        LDRH      v2, [v4, #I2C_STAT]
        STRH      v2, [v4, #I2C_STAT]
d373 5
a377 5
        MOVEQ     v2, #&17 ; AL_IE, NACK_IE, ARDY_IE, XRDY_IE
        MOVNE     v2, #&0F ; AL_IE, NACK_IE, ARDY_IE, RRDY_IE
        ORREQ     v2, v2, #&4000 ; XDR_IE
        ORRNE     v2, v2, #&2000 ; RDR_IE
        STRH      v2, [v4, #I2C_IE]
d380 3
a382 3
        MOV       v2, a1, LSR #1
        AND       v2, v2, #&7F
        STRH      v2, [v4, #I2C_SA]
d385 2
a386 2
        MOV       v2, v1
        LDR       ip, [v5, #I2C_XEnd]
d388 8
a395 8
        CMP       ip, v2
        ORREQ     a4, a4, #2 ; Last transfer in list; set stop bit
        BEQ       %FT20
        ADD       v2, v2, #12 ; Increment after compare, just in case some crazy person creates an iic_transfer that wraps from &FFF.... to &000...
        LDMIA     v2,{a1-a2,v3} ; Get transfer info
        TST       a1, #1:SHL:31
        ADDNE     a3, a3, v3 ; nostart is set; increment length and loop around
        BNE       %BT10
d398 1
a398 1
        DebugReg  a3, "I2C_CNT="
d400 1
a400 1
        STRH      a3, [v4, #I2C_CNT]
d402 10
a411 10
        LDR       v2, [v5, #I2C_XStart]
        CMP       v1, v2 ; v1 = I2C_XCurrent from earlier
        BNE       %FT20
        MOV       v2, #50*1024 ; timeout
10
        LDRH      v3, [v4, #I2C_STAT]
        TST       v3, #1:SHL:12
        BEQ       %FT20
        SUBS      v2, v2, #1
        BNE       %BT10
d413 1
a413 1
        DebugReg  v3, "BB timeout: I2C_STAT="
d415 2
a416 2
        MOV       a1, #IICStatus_Busy
        B         clear_and_return
d419 1
a419 1
        ORR       a4, a4, #1 ; Always send start bit
d421 1
a421 1
        STRH      a4, [v4, #I2C_CON]
d424 1
a424 1
        DebugTX   "Transfer started"
d426 2
a427 2
        MOV       a1, #IICStatus_InProgress
        LDMFD     sp!, {v1-v5,pc}
d440 1
a440 1
        STMFD     sp!, {v1-v5,lr}
d442 1
a442 1
        DebugReg  a1, "HAL_IICMonitorTransfer: bus "
d444 37
a480 37
        ADR       v5, I2C_Table
        MOV       v4, #I2CBlockSize
        MLA       v5, a1, v4, v5
        LDR       v4, [v5, #I2C_HW]
        LDR       a1, [v5, #I2C_XStart]
 [ I2CDebug
        DebugReg  a1, "XStart="
 ]
        LDRH      v3, [v4, #I2C_STAT]
        TEQ       a1, #0 ; If no transfer, shut off all interrupts
        ASSERT    IICStatus_Completed=0
 [ I2CDebug
        BNE       %FT10
        DebugTX   "No XStart!"
        TEQ       a1, #0 ; reset EQ condition
10
 ]
        STREQH    a1, [v4, #I2C_IE]
        STREQH    v3, [v4, #I2C_STAT]
        LDMEQFD   sp!, {v1-v5,pc}
 [ I2CDebug
        DebugReg  v3, "I2C_STAT="
 ]
        TST       v3, #2
        BNE       i2c_nack
        TST       v3, #1
        BNE       i2c_al
        TST       v3, #4
        BNE       i2c_ardy
        TST       v3, #1:SHL:14
        BNE       i2c_xdr
        TST       v3, #1:SHL:4
        BNE       i2c_xrdy
        TST       v3, #1:SHL:13
        BNE       i2c_rdr
        TST       v3, #1:SHL:3
        BNE       i2c_rrdy
d482 4
a485 4
        BIC       v3, v3, #&1d00 ; Clear XUDF, ROVR, BB, BF - they're status bits and don't indicate anything we care about here
        CMP       v3, #0
        MOVEQ     a1, #IICStatus_InProgress ; If nothing interesting happened, claim everything is OK (required for polling-mode transfers, e.g. HAL_VideoIICOp)
        LDMEQFD   sp!, {v1-v5,pc}        
d488 1
a488 1
        DebugReg  v3, "Unhandled IRQ - "
d491 1
a491 1
        MOV       a1, #IICStatus_Error
d494 1
a494 1
        DebugReg  a1, "clear_and_return: "
d496 4
a499 4
        STRH      v3, [v4, #I2C_STAT]
        MOV       v3, #0
        STR       v3, [v5, #I2C_XStart]
        LDMFD     sp!, {v1-v5,pc}
d502 3
a504 3
        ; No ack was received - give up and return error       
        MOV       a1, #IICStatus_NoACK
        B         clear_and_return
d508 3
a510 3
        STRH      v3, [v4, #I2C_STAT]
        LDR       v1, [v5, #I2C_XStart]
        B         start_transfer
d514 4
a517 4
        LDR       a3, [v5, #I2C_XCurrent]
        LDR       a2, [v5, #I2C_XBytes]
        LDR       ip, [a3, #8]
        CMP       a2, ip
d519 5
a523 5
        BEQ       %FT10
        DebugTX   "HW requested wrong byte count"
        DebugReg  a2, "I2C_XBytes="
        DebugReg  ip, "xfer len="
        B         unexpected_error
d526 1
a526 1
        BNE       unexpected_error ; Hardware hasn't requested the full number of bytes
d528 4
a531 4
        LDR       a4, [v5, #I2C_XEnd]
        CMP       a3, a4
        MOVEQ     a1, #IICStatus_Completed
        BEQ       clear_and_return
d533 1
a533 1
        ADD       v1, a3, #12
d535 5
a539 5
        LDMIA     v1, {a1-a3}
        TST       a1, #1:SHL:31
        STREQH    v3, [v4, #I2C_STAT]
        BEQ       start_transfer
        CMP       a3, #0
d541 3
a543 3
        BEQ       %FT5
        DebugReg  a3, "nostart transfer with nonzero length, length="
        B         unexpected_error
d546 1
a546 1
        BNE       unexpected_error ; nostart transfer with nonzero length = hardware hasn't requested full number of bytes
d548 5
a552 5
        CMP       v1, a4
        MOVEQ     a1, #IICStatus_Completed
        BEQ       clear_and_return
        ADD       v1, v1, #12
        B         %BT10
d557 3
a559 3
        LDRH      a4, [v4, #I2C_BUFSTAT]
        AND       a4, a4, #&3F
        B         send_bytes        
d563 3
a565 3
        LDRH      a4, [v4, #I2C_BUF]
        AND       a4, a4, #&3F
        ADD       a4, a4, #1
d570 3
a572 3
        LDR       v2, [v5, #I2C_XCurrent]
        LDR       a3, [v5, #I2C_XBytes] ; Get bytes sent
        LDMIB     v2, {a2,ip} ; Get data ptr, transfer length
d575 3
a577 3
        CMP       a3, ip
        BEQ       %FT20 
        LDRB      v1, [a2,a3]
d579 1
a579 1
        DebugRegByte  v1
d581 4
a584 4
        ADD       a3, a3, #1
        SUBS      a4, a4, #1
        STRB      v1, [v4, #I2C_DATA]
        BNE       %BT10
d588 4
a591 4
        STR       a3, [v5, #I2C_XBytes]        
        MOV       a1, #IICStatus_InProgress
        STRH      v3, [v4, #I2C_STAT]
        LDMIA     sp!, {v1-v5,pc}
d594 2
a595 2
        LDR       a3, [v5, #I2C_XEnd]
        CMP       a3, v2
d597 3
a599 3
        BNE       %FT5
        DebugTX   "End of transfer list but hardware wants more"
        B         unexpected_error
d602 1
a602 1
        BEQ       unexpected_error ; Hardware is asking for more data than we can give
d604 7
a610 7
        ADD       v2, v2, #12
        STR       v2, [v5, #I2C_XCurrent]
        MOV       a3, #0
        STR       a3, [v5, #I2C_XBytes]
        LDMIA     v2, {a1-a2,ip}
        TST       a1, #1:SHL:31
        BNE       %BT10
d612 1
a612 1
        DebugTX   "nostart reached but hardware wants more"
d614 1
a614 1
        B         unexpected_error ; Hardware is asking for more data than we can give
d618 5
a622 5
        LDRH      a4, [v4, #I2C_BUFSTAT]
        MOV       a4, a4, LSR #8
        ANDS      a4, a4, #&3F ; ERRATA - sometimes RDR is set when there's no data. So, don't attempt to read from the empty buffer.
        BEQ       %FT15
        B         read_bytes
d626 4
a629 4
        LDRH      a4, [v4, #I2C_BUF]
        MOV       a4, a4, LSR #8
        AND       a4, a4, #&3F
        ADD       a4, a4, #1
d634 3
a636 3
        LDR       v2, [v5, #I2C_XCurrent]
        LDMIA     v2, {a1-a2,ip} ; Get checksum flag, data ptr/checksum, transfer length
        LDR       a3, [v5, #I2C_XBytes] ; Get bytes received
d639 6
a644 6
        CMP       a3, ip
        BEQ       %FT20
        TST       a1, #1:SHL:30 ; Checksum mode?
        LDRB      v1, [v4, #I2C_DATA]
        ADDNE     a2, a2, v1 ; adjust checksum
        STREQB    v1, [a2, a3]
d646 1
a646 1
        DebugRegByte  v1
d648 3
a650 3
        SUBS      a4, a4, #1
        ADD       a3, a3, #1
        BNE       %BT10
d654 2
a655 2
        STR       a2, [v2, #4] ; Update checksum
        STR       a3, [v5, #I2C_XBytes]
d657 3
a659 3
        MOV       a1, #IICStatus_InProgress
        STRH      v3, [v4, #I2C_STAT]
        LDMIA     sp!, {v1-v5,pc}
d662 2
a663 2
        LDR       a3, [v5, #I2C_XEnd]
        CMP       a3, v2
d665 3
a667 3
        BNE       %FT5
        DebugTX   "End of transfer list but hardware received more data"
        B         unexpected_error
d670 1
a670 1
        BEQ       unexpected_error ; Hardware is receiving more data than we want
d672 6
a677 6
        ADD       v2, v2, #12
        STR       v2, [v5, #I2C_XCurrent]
        MOV       a3, #0
        STR       a3, [v5, #I2C_XBytes]
        LDMIA     v2, {a1-a2,ip}
        TST       a1, #1:SHL:31
d679 3
a681 3
        BNE       %FT5
        DebugTX   "nostart reached but hardware received more data"
        B         unexpected_error
d684 1
a684 1
        BEQ       unexpected_error ; Hardware is receiving more data than we want
d686 4
a689 4
        TST       a1, #1:SHL:30 ; Checksum mode?
        MOVNE     a2, #0 ; Start with zero checksum (as per start_transfer)
        B         %BT10
  
d704 6
a709 6
        LDRB      a4, [sb, #BoardConfig_VideoI2C]
        CMP       a4, #255
        MOV       ip, #0
        STREQ     ip, [a3]
        MOVEQ     a1, #IICStatus_Error
        MOVEQ     pc, lr
d711 5
a715 5
        UBFX      a4, a1, #0, #16
        CMP       a4, #256
        STRCS     ip, [a3]
        MOVCS     a1, #IICStatus_Completed
        MOVCS     pc, lr
d717 5
a721 5
        Push      "a1-a3,lr"
        LDR       a3, [a3]
        ADD       ip, a4, a3
        CMP       ip, #256
        RSBHI     a3, a4, #256
d728 2
a729 2
        UBFX      a1, a1, #16, #8 ; Extract base IICAddress
        Push      "a1-a3"         ; Push the block on the stack (a2 & a3 are already correct)
d731 4
a734 4
        BIC       a1, a1, #1      ; Clear RnW of base address
        ADD       a2, sp, #12     ; sp+12 should point to the 8 bit offset
        MOV       a3, #1
        Push      "a1-a3"
d737 4
a740 4
        LDRB      a2, [sb, #BoardConfig_VideoI2C]
        MOV       a2, a2, LSL #24
        ADD       a2, a2, #2
        MOV       a1, sp
d742 6
a747 19
        LDR       a3, HALInitialised
        CMP       a3, #0
        BEQ       %FT10
        LDR       a3, OSentries+4*OS_IICOpV
        BLX       a3
        ; Unmap RISC OS error numbers to IICStatus return codes
        ASSERT    IICStatus_Completed = 0
        TEQ       a1, #0
        LDRNE     a1, [a1]
        LDRNE     lr, =ErrorNumber_IIC_NoAcknowledge
        SUBNE     a1, a1, lr             ;   0/1/2 = NoAck/Error/Busy
        USATNE    a1, #2, a1             ; 4+ => 3 = Error
        ADRNE     lr, %FT05
        LDRNEB    a1, [lr, a1]
        B         %FT20
05
        ASSERT    (ErrorNumber_IIC_Error - ErrorNumber_IIC_NoAcknowledge) = 1
        ASSERT    (ErrorNumber_IIC_Busy - ErrorNumber_IIC_NoAcknowledge) = 2
        DCB       IICStatus_NoACK, IICStatus_Error, IICStatus_Busy, IICStatus_Error
d749 1
a749 1
        BL        IIC_DoOp_Poll
d752 8
a759 8
        CMP       a1, #IICStatus_Completed
        LDREQ     a4, [sp, #(3*4)+(2*4)] ; Clipped block 2 request size
        MOVNE     a4, #0
        ADD       sp, sp, #24            ; Junk the iic_transfer blocks
        STR       a1, [sp, #0]           ; Propagate return code
        LDR       a3, [sp, #8]
        STR       a4, [a3]               ; Actual transfer size
        Pull      "a1-a3,pc"
d769 1
a769 1
        Push      "v1,lr"
d772 20
a791 20
        Push      "a1-a4"
        MRS       a1, CPSR
        TST       a1, #I32_bit
        BNE       %FT10
        ADR       a1, BoardConfig_HALI2CIRQ
        LDRB      a1, [a1, a2, LSR #24]
        IMPORT HAL_IRQDisable
        BL        HAL_IRQDisable
        CMP       a1, #0
        BEQ       %FT10
        DebugTX   "Warning - IIC_DoOp_Poll called with IIC IRQ enabled!"
        B         .
10
        Pull      "a1-a4"
 ]
        MOV       a3, a1
        MOV       a1, a2, LSR #24
        BIC       a2, a2, #&ff000000
        MOV       v1, a1
        BL        HAL_IICTransfer
d794 5
a798 5
        CMP       a1, #IICStatus_InProgress ; Done?
        Pull      "v1,pc", NE
        ADR       lr, %BT10
        MOV       a1, v1
        B         HAL_IICMonitorTransfer
@


1.11
log
@Refactor HAL_VideoIICOp to be ATPCS
No longer specified to return _kernel_oserror * implements GraphicsV 14.
Make use of IICStatus defines instead of local copies.
Rename HAL_Video_ to HAL_Video.
Tested on Beagleboard xM, reading EDID from Hyundai monitor.

Version 0.69. Tagged as 'OMAP3-0_69'
@
text
@d755 1
a755 1
        USAT      a1, #2, a1             ; 4+ => 3 = Error
@


1.10
log
@Line some things up.
To help OMAP4 tracking changes a number of the changes were purely cosmetic lining up differences, this change is where OMAP3 wasn't on a conventional column layout.

Version 0.61. Tagged as 'OMAP3-0_61'
@
text
@d25 3
a27 1

d42 1
a42 1
        EXPORT  HAL_Video_IICOp
d50 1
a50 1
; I2C3 - On the beagleboard this is routed to the HDMI connector. This means its sole use is for reading EDID/DDC data. RISC OS therefore accesses it via HAL_Video_IICOp.
d217 1
a217 1
;      r0 = E* return code
d235 1
a235 1
        MOVHS     a1, #EERROR
d243 1
a243 1
        MOVLT     a1, #EERROR
d247 1
a247 1
        MOVNE     a1, #EERROR
d264 1
a264 1
        MOVHS     a1, #EERROR ; Too much (or too little) data
d268 1
a268 1
_IICTransfer_Video ; Entry point for HAL_Video_IICOp
d283 1
a283 1
        STREQ     a3, [v5, #I2C_XStart]    ; if not, claim it
d285 1
a285 1
        MOVNE     a1, #EBUSY              ; if it is, return "BUSY"
d348 1
a348 1
        MOV       a1, #EBUSY
d417 1
a417 1
        MOV       a1, #EBUSY
d428 1
a428 1
        MOV       a1, #EINPROGRESS
d438 1
a438 1
; Return E* state for transfer on bus r0
d456 1
a456 1
        ASSERT    ECOMPLETED=0
d486 1
a486 1
        MOVEQ     a1, #EINPROGRESS ; If nothing interesting happened, claim everything is OK (required for polling-mode transfers, e.g. HAL_Video_IICOp)
d493 1
a493 1
        MOV       a1, #EERROR
d505 1
a505 1
        MOV       a1, #ENOACK
d532 1
a532 1
        MOVEQ     a1, #ECOMPLETED
d551 1
a551 1
        MOVEQ     a1, #ECOMPLETED
d591 1
a591 1
        MOV       a1, #EINPROGRESS
d659 1
a659 1
        MOV       a1, #EINPROGRESS
d693 13
a705 24
; HAL_Video_IICOp
; Officially:
;  r0 = card<<28 + channel<<24 + I2Ccmnd << 16 + address
;  I2Ccmnd = 1 for read, 0 write
;  r1 = DMA address
;  r2 = byte count
;  Returns:
;  r0 = 0 or error block
;  r1 updated
;  r2 updated
; In reality:
;  r0 = as above. The NVidia driver describes 'address' as being 11-bit, but only seems to handle it as 8-bit. The address is the offset to read from in the EDID data (Only EDID is supported, at I2C address 0x50. DDC, which is apparently at 0x37, isn't supported)
;  r1 = logical address
;  r2 = byte count
;  Returns:
;  r0 = 0 on success, unmodified on error (which also be 0 for a write to 0 on card 0 channel 0?!)
;  r1 = r1+r2 on success, unmodified on error
;  r2 = 0 on success, unmodified on error
;  There appears to be no support for partial transfers; NVidia driver implementation simply writes corrupt data for any failed bytes.
HAL_Video_IICOp
        ; Build a set of iic_transfer blocks and call RISCOS_IICOpV
        ; First let's discard writes, to be equivalent to the NVidia driver
        TST       a1, #1<<16
        ; Also make sure we've got a valid IIC bus to use
d707 4
a710 1
        CMPNE     a4, #255
d712 7
a718 4
        ; Also check we're transferring a valid number of bytes
        SUB       a4, a3, #1
        CMP       a4, #65536
        MOVHS     pc, lr
d720 9
a728 3
        ; Now we construct two iic_transfer blocks
        ; - First block is a write to 0x50. Single byte containing EDID start address (lower 8 bits of r0)
        ; - Second block is a read from 0x50. r2 bytes written to r1.
d730 2
a731 4
        TST       a1, #1<<16 ; Is this read or write? (although this code isn't guaranteed to work properly for EDID writes!)
        MOVNE     a1, #&a1 ; Read from I2C
        MOVEQ     a1, #&a0 ; Write to I2C
        Push      "a1-a3" ; Push the block on the stack (a2 & a3 are already correct)
d733 2
a734 2
        MOV       a1, #&a0
        ADD       a2, sp, #12 ; sp+12 should point to the 8 bit EDID address
d737 1
d743 1
a743 1
        ; If HAL_Init isn't done yet, we can't use OS_IICOpV
d746 2
a747 2
        ADREQ     a3, IIC_DoOp_Poll
        LDRNE     a3, OSentries+4*OS_IICOpV
d749 26
a774 8
        ; On error, return with unmodified regs, ala NVidia driver
        CMP       a1, #0
        ADD       sp, sp, #24
        Pull      "a1-a3,lr"
        ADDEQ     a2, a2, a3
        MOVEQ     a1, #0
        MOVEQ     a3, #0
        MOV       pc, lr
d777 1
a777 1
        ; IIC transfer function that performs a polling transfer, similar to HAL_Video_IICOp
d783 1
a783 1
        ; Returns E* return code in R0 (0 success, anything else failure)
d809 1
a809 1
        CMP       a1, #EINPROGRESS ; Done?
@


1.9
log
@Fix OMAP3 IIC driver to flush RX/TX FIFOs before each transfer
Detail:
  s/I2C - The IIC driver now flushes the RX & TX FIFOs before each transfer. This ensures the correct data is sent/received following certain errors (e.g. NACK)
Admin:
  Tested on rev C1 TouchBook


Version 0.42. Tagged as 'OMAP3-0_42'
@
text
@d15 1
@


1.8
log
@Update OMAP3 HAL to cope with kernel support for multiple IIC buses
Detail:
  s/I2C - Changed HAL_Video_IICOp to call RISCOS_IICOpV instead of using its own polling based transfer loop. Updated IIC_DoOp_Poll to work with multiple buses.
  s/board - Allow the OS to see the video IIC buses now that any transfers on them will be using OS_IICOp's queueing/re-entrancy code
Admin:
  Tested on rev A2 BB-xM


Version 0.39. Tagged as 'OMAP3-0_39'
@
text
@d335 1
a335 1
        MOV       v2, #50*1024 ; timeout - this should be more than adequate (with a CPU of 500MHz, there'd be 5000 CPU clock cycles per 100kbps I2C clock cycle)
d349 11
a359 1
20        
@


1.7
log
@Miscellaneous OMAP3 HAL improvements
Detail:
  hdr/board, s/board, s/Boot - Linux machine IDs are now defined via constants in hdr/board instead of magic numbers on a per-use basis
  s/Boot - Added video fix for BB-xM rev A3.
  s/Boot - Added code to enable tablet battery charging on TouchBook.
  s/Boot - Added support for power-off on TouchBook
  s/GPIO - Fixed bug in GPIOx_SetAsOutput that would prevent LEDs from being disabled properly
  s/I2C - Updated code to ignore BF interrupts. Added debugging code to help track down unexpected errors, and to check that IIC_DoOp_Poll is being called with interrupts disabled.
  s/SDMA - Call HAL_IRQClear when resetting the DMA controller device. This fixes the "previous IRQ not cleared" loop that would occur during RISC OS's pre-reset sequence
Admin:
  Tested on rev C2 beagleboard, C1 touchbook, A3 BBxM.
  Resets should now work reliably on all machines, except TouchBook, which still seems to hang. But on the bright side, the TouchBook is currently the only machine to support soft-off.


Version 0.33. Tagged as 'OMAP3-0_33'
@
text
@d700 1
a700 1
        ; Let's implement this the easy way - reuse HAL_IICTransfer and HAL_IICMonitorTransfer
d726 15
a740 13
        LDRB      a1, [sb, #BoardConfig_VideoI2C]
        MOV       a2, #2
        MOV       a3, sp
        ; Ugly branch into main I2C code (to avoid pointless error check)
        ADR       lr, %FT10
        STMFD     sp!, {v1-v5,lr}
        B         _IICTransfer_Video
        ; Now just poll until we're done
10
        CMP       a1, #ECOMPLETED ; Complete?
        ADDEQ     sp, sp, #24
        Pull      "a1-a3,lr",EQ
        ADDEQ     a2,a2,a3
d743 1
a743 8
        MOVEQ     pc, lr
        CMP       a1, #EINPROGRESS ; Error?
        ADDNE     sp, sp, #24
        Pull      "a1-a3,pc",NE ; On error, return with unmodified regs, ala NVidia driver
        ; Else poll transfer status
        LDRB      a1, [sb, #BoardConfig_VideoI2C]
        ADR       lr, %BT10
        B         HAL_IICMonitorTransfer
d750 2
a751 1
        ; r1 = iic_transfer count
d753 1
a753 1
        Push      "lr"
d760 2
a761 1
        MOV       a1, #I2C1_IRQ
d772 3
a774 1
        MOV       a1, #0 ; Bus 0 only :(
d779 1
a779 1
        Pull      "pc", NE
d781 1
a781 1
        MOV       a1, #0
@


1.6
log
@BeagleBoard-xM, TouchBook fixes
Detail:
  s/board, hdr/board, hdr/omap3530, hdr/UART - Add support for 4th UART available on AM/DM37x (i.e. BeagleBoard-xM)
  hdr/omap3530 - Add details of CONTROL_IDCODE register & known hawkeye/revision numbers for OMAP type/revision detection
  s/Boot, s/GPIO, hdr/GPIO, s/I2C, hdr/StaticWS - Allow TPS LED drivers to be used as (output-only) GPIOs. Add new polled I/O I2C function, and appropriate logic to make GPIO code use it instead of RISCOS_IICOpV if RISC OS hasn't finished initialising yet. Add code to initialise some extra BB/TB GPIOs on boot.
  s/Timers, hdr/Timers - Stop RISC OS from using GPTIMER9, because it's used to drive the screen backlight on the TouchBook
  s/Video - Use appropriate porch/sync limits on non-OMAP35x
  s/PRCM - Don't mess with the system clock divider when calculating system clock speed (AM/DM37x fix)
Admin:
  Tested on rev C2 beagleboard, rev A2 BB-xM (indirectly), rev C1 TouchBook


Version 0.32. Tagged as 'OMAP3-0_32'
@
text
@d51 1
a51 1
I2CDebug        SETL {FALSE}
d56 2
d59 2
a60 1
 [ I2CDebug
d301 6
d308 1
d471 1
a471 1
        BIC       v3, v3, #7:SHL:10 ; Clear XUDF, ROVR, BB - they're status bits and don't indicate anything we care about here
d476 3
d507 8
d516 1
d529 6
d536 1
d585 6
d592 1
d599 5
a603 2
        BEQ       unexpected_error ; Hardware is asking for more data than we can give
        B         %BT10
d653 6
d660 1
d667 6
d674 1
d758 16
@


1.5
log
@Various OMAP3 HAL power management improvements, plus add support for board config autodetection via Linux machine ID
Detail:
  s/board, hdr/board - Add Linux machine ID & available mixer channels to board config table
  s/Top - Add new entry point at offset &64, for booting as a fake Linux kernel. Searches the board config table until it finds a config matching the machine ID passed in R1. Also minor ROM copy optimisation, unsigned pointer comparison fixes
  s/Audio, hdr/Audio - Use board config to lock-out mixer channels that aren't connected to any hardware, to avoid excessive power drain or other problems if the channels get turned on. Also perform many other setting tweaks to tidy up default settings for unused mixer paths/channels.
  s/Video - Fix Video_Init logic when deciding whether to reset DSS, enable DSI PLL drift guard
  s/I2C - Increase I2C timeout values, since the previous values were perhaps a bit low
  s/Audio, s/I2C, s/Interrupts, s/RAM, s/SDMA, s/Timers, s/UART, hdr/UART, s/USB, s/Video - Enable autoidle/smart idle where possible to help save power.
Admin:
  Tested on rev C2 beagleboard


Version 0.21. Tagged as 'OMAP3-0_21'
@
text
@d40 1
d696 19
a714 1
        
@


1.4
log
@Update OMAP HAL to support different board configs, plus use new YearLOIsGood flag to ensure correct RTC handling, plus other misc tidying
Detail:
  The OMAP HAL now has multiple entry points, one per board config. See Top.s/board.s for more info.
  audio.s - Moved APLL_CTL value to board config
  board.s - New file to list all the settings for the different board configs
  boot.s - Change HAL_Init to deal with the new board config stuff
  debug.s - Debug UART now specified in board config
  GPIO.s - A few utility functions for handling OMAP/TPS GPIO pins
  I2C.s - Update to use new board config struct
  RAM.s - Disable the beagleboard-specific RAM init code. Instead we'll just rely on u-boot to initialise all our RAM for us.
  RTC.s - Get rid of the magic numbers, and use the YearLOIsGood flag to indicate to RISC OS that YearLO is 2-digit BCD
  Top.s - Got rid of old debug code and rewrote initial flow to handle detecting & storing the board config
  UART.s - Update to use board config struct, support multiple UARTs
  USB.s - Get EHCI PHY power GPIO from board config
  Video.s - Get DVI framer power GPIO and max pixel rate from board config. Add 'PassiveVideo' option, to build a driver that doesn't alter the video output settings - should hopefully result in a usable display on Touch Book, etc.
  board.hdr - Definition of board config table struct
  GPIO.hdr - Add lots of macros for handling OMAP GPIO pins, new constants for OMAP/TPS GPIO
  I2C.hdr - Added I2C transfer block struct, HAL I2C API transfer states (both moved here from other source files)
  omap3530.hdr - Move/remove some unwanted constants, disable DebugChar for now
  StaticWS.hdr - Move I2C transfer block struct to I2C.hdr, add board config struct to HAL workspace, get rid of unused 64K AllocArea
  Timers.hdr - Tidy up constants a bit
  UART.hdr - Add UARTCLK (moved from StaticWS.hdr), UART IRQ #'s
  Makefile - add GPIO.s
Admin:
  Tested on rev C2 beagleboard. Board configs for other board types may be inaccurate in a couple of places.


Version 0.19. Tagged as 'OMAP3-0_19'
@
text
@d134 3
d324 1
a324 1
        MOV       v2, #5*1024 ; timeout - this should be more than adequate (with a CPU of 500MHz, there'd be 5000 CPU clock cycles per 100kbps I2C clock cycle)
d383 1
a383 1
        MOV       v2, #5*1024 ; timeout
@


1.3
log
@Add sound support to OMAP3 HAL, plus other changes
Detail:
  hdr/Audio, s/Audio, Makefile, hdr/StaticWS, s/Boot - Add sound support to OMAP3 HAL. Should work with a TPS65950 connected to I2C1/McBSP2, as per beagleboard.
  s/TPS, s/RTC - Moved TPSRead, TPSWrite functions out of s/RTC and into their own file
  hdr/SDMA, s/SDMA - Add support for packet-based transfer (for audio), improve debug code, remove TestRAMToRAM test code
  s/I2C - Update to handle spurious RDR interrupts as mentioned in OMAP3 errata
  s/Video - Enable support for the larger porch & sync timing registers found in OMAP3 ES3.1 and above
Admin:
  Tested on rev C2 beagleboard


Version 0.18. Tagged as 'OMAP3-0_18'
@
text
@a28 1
        GET     hdr.I2C
d55 2
a56 1
; [ I2CDebug
d61 1
a61 8
; ]

; HAL API I2C transfer states
ECOMPLETED *    0
EINPROGRESS *   1
ENOACK  *       2
EBUSY   *       3
EERROR  *       5
d80 1
a80 1
        MOV     v1, #3 ; Initialise I2C1-I2C3
d87 2
d116 1
d119 1
a119 1
        ; Run at 100kbps for now
d145 1
d158 1
a158 1
        MOV     a1, #2 ; Only tell RISC OS about I2C1 and I2C2; I2C3 is accessed via HAL_Video_IICOp.
d163 2
a164 1
        CMP     a1, #2
a168 4
IICIRQs
        DCB I2C1_IRQ, I2C2_IRQ, I2C3_IRQ
        ALIGN

d191 2
a192 1
        CMP     a2, #2
d194 1
a194 1
        ADRLO   a3, IICIRQs
d223 2
a224 1
        CMP       a1, #2
d646 3
d669 1
a669 1
        MOV       a1, #2
d689 1
a689 1
        MOV       a1, #2
@


1.2
log
@Add HAL RTC support to OMAP3 kernel, improve IIC code
Detail:
  s/RTC - Implementation of new HAL RTC API. Uses the RTC built into the TWL/TPS companion chip.
  s/Boot - Initialise RTC HALDevice
  s/I2C - Add workaround for apparent hardware limitation of the OMAP I2C controllers; where appropriate multiple iic_transfers will now be merged together into one transfer, to ensure that a start bit is always sent at the start of each transfer
  hdr/omap3530 - Tweak DebugReg and DebugRegByte to allow LR to be output
  Makefile - add s.RTC to list of files. Fix GPADBG definition to not conflict with the 'gpa' folder that one of the makefile fragments creates.
Admin:
  Tested on rev C2 beagleboard


Version 0.13. Tagged as 'OMAP3-0_13'
@
text
@d570 3
a572 2
        AND       a4, a4, #&3F
        B         read_bytes        
d606 1
@


1.1
log
@Add I2C support to OMAP3 HAL. Fix FIQ handling. Improve debugging code.
Detail:
  Makefile, s/Boot, s/I2C, hdr/I2C, hdr/StaticWS - Adds I2C support to the OMAP3 HAL, via both HAL_IIC* and HAL_Video_IICOp.
  s/Interrupts - Fix bug causing incorrect clearing of FIQs
  s/Debug, s/Boot, hdr/omap3530 - Improve debugging code, and add simple FIQ debugger that outputs the PC to the serial port when the beagleboard USER button is pressed
  s/Stubs - Remove old stub functions
Admin:
  Tested on rev C2 beagleboard


Version 0.12. Tagged as 'OMAP3-0_12'
@
text
@d232 4
d239 5
d246 3
d250 12
a261 8
        LDR       ip, [a4, #-4]
        SUB       ip, ip, #1
        CMP       ip, #65536 ; We only support transfers 1-65536 bytes long (although if required we could easily transfer more by checking I2C_XBytes in i2c_ardy)
        MOVHS     a1, #EERROR
        MOVHS     pc, lr
        SUB       a4, a4, #12
        CMP       a4, a3
        BNE       %BT10
a262 1
        STMFD     sp!, {v1-v5,lr}
d301 5
d362 17
d398 2
a399 5
        TST       a1, #1:SHL:31
        ORREQ     a4, a4, #1 ; Send start bit
        LDR       v2, [v5, #I2C_XEnd]
        CMP       v1, v2 ; v1 = I2C_XCurrent from earlier
        ORREQ     a4, a4, #2 ; Send stop bit
d491 4
d499 1
a499 1
        STRH      v3, [v4, #I2C_STAT]
d501 13
a513 1
        B         start_transfer
a530 1
        LDR       a2, [v2, #4] ; Get data ptr
d532 1
d534 3
d552 13
d584 1
a584 1
        LDMIA     v2, {a1-a2} ; Get checksum flag, data ptr/checksum
d587 3
d608 16
a623 1

d671 4
a674 1
        BL        _IICTransfer_Video
@


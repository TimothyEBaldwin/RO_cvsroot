head	1.12;
access;
symbols
	OMAP3-1_18:1.12
	OMAP3-1_17:1.12
	OMAP3-1_16:1.12
	OMAP3-1_15:1.12
	OMAP3-1_14:1.12
	SMP:1.12.0.2
	SMP_bp:1.12
	OMAP3-1_13:1.12
	OMAP3-1_12:1.12
	OMAP3-1_11:1.12
	OMAP3-1_10:1.12
	OMAP3-1_09:1.12
	OMAP3-1_08:1.12
	OMAP3-1_07:1.12
	OMAP3-1_06:1.12
	OMAP3-1_05:1.12
	OMAP3-1_04:1.12
	OMAP3-1_03:1.12
	OMAP3-1_02:1.12
	OMAP3-1_01:1.12
	OMAP3-1_00:1.12
	OMAP3-0_99:1.12
	OMAP3-0_98:1.12
	OMAP3-0_97:1.12
	OMAP3-0_96:1.12
	OMAP3-0_95:1.12
	OMAP3-0_94:1.11
	OMAP3-0_93:1.11
	OMAP3-0_92:1.11
	OMAP3-0_91:1.11
	OMAP3-0_90:1.11
	OMAP3-0_89:1.11
	OMAP3-0_88:1.11
	OMAP3-0_87:1.11
	OMAP3-0_86:1.11
	OMAP3-0_85:1.11
	OMAP3-0_84:1.11
	OMAP3-0_83:1.11
	OMAP3-0_82:1.11
	OMAP3-0_81:1.11
	OMAP3-0_80:1.11
	OMAP3-0_79:1.11
	OMAP3-0_78:1.11
	OMAP3-0_77:1.11
	OMAP3-0_76:1.11
	OMAP3-0_75:1.11
	OMAP3-0_74:1.11
	OMAP3-0_73:1.11
	OMAP3-0_72:1.11
	OMAP3-0_71:1.11
	OMAP3-0_70:1.11
	OMAP3-0_69:1.11
	OMAP3-0_68:1.11
	OMAP3-0_67:1.11
	OMAP3-0_66:1.11
	OMAP3-0_65:1.11
	OMAP3-0_64:1.11
	OMAP3-0_63:1.11
	OMAP3-0_62:1.11
	OMAP3-0_61:1.11
	OMAP3-0_60:1.10
	OMAP3-0_59:1.10
	OMAP3-0_58:1.9
	OMAP3-0_57:1.9
	OMAP3-0_56:1.8
	OMAP3-0_55:1.8
	OMAP3-0_54:1.8
	OMAP3-0_53:1.8
	OMAP3-0_52:1.8
	OMAP3-0_51:1.8
	OMAP3-0_50:1.8
	OMAP3-0_49:1.8
	OMAP3-0_48:1.8
	OMAP3-0_47:1.8
	OMAP3-0_46:1.8
	OMAP3-0_45:1.8
	OMAP3-0_44:1.8
	OMAP3-0_43:1.8
	OMAP3-0_42:1.8
	OMAP3-0_41:1.8
	OMAP3-0_40:1.8
	OMAP3-0_39:1.8
	OMAP3-0_38:1.8
	OMAP3-0_37:1.8
	OMAP3-0_36:1.8
	OMAP3-0_35:1.8
	OMAP3-0_34:1.8
	OMAP3-0_33:1.8
	OMAP3-0_32:1.8
	OMAP3-0_31:1.8
	OMAP3-0_30:1.8
	OMAP3-0_29:1.8
	OMAP3-0_28:1.8
	OMAP3-0_27:1.7
	OMAP3-0_26:1.7
	OMAP3-0_25:1.7
	OMAP3-0_24:1.7
	OMAP3-0_23:1.7
	OMAP3-0_22:1.7
	OMAP3-0_21:1.7
	OMAP3-0_20:1.6
	OMAP3-0_19:1.6
	OMAP3-0_18:1.5
	OMAP3-0_17:1.5
	OMAP3-0_16:1.5
	OMAP3-0_15:1.4
	OMAP3-0_14:1.4
	OMAP3-0_13:1.4
	OMAP3-0_12:1.4
	OMAP3-0_11:1.4
	OMAP3-0_10:1.4
	OMAP3-0_09:1.4
	OMAP3-0_08:1.4
	OMAP3-0_07:1.4
	OMAP3-0_06:1.4
	OMAP3-0_05:1.3
	OMAP3-0_04:1.2
	OMAP3-0_03:1.1
	OMAP3-0_02:1.1
	OMAP3-0_01:1.1;
locks; strict;
comment	@# @;


1.12
date	2014.03.08.16.59.12;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	CdtiAiQ8vMQbWUrx;

1.11
date	2012.03.25.11.49.08;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	c99VvmwezV2J8gYv;

1.10
date	2012.02.25.16.28.11;	author jlee;	state Exp;
branches;
next	1.9;
commitid	8PdHKiULlWJhCyUv;

1.9
date	2012.01.15.08.37.20;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	x0ab4JAMToptkfPv;

1.8
date	2010.06.23.22.30.33;	author jlee;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.30.00.23.20;	author jlee;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.24.02.49.32;	author jlee;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.28.22.30.57;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.22.22.03.40;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.10.22.05.49;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.08.22.25.11;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.02.01.13.58.05;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Use DSB/ISB directly
Reflects similar change in OMAP4-0_28.
Built, but not tested.

Version 0.95. Tagged as 'OMAP3-0_95'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Using the DMA controller to clear RAM is much faster than doing it with the CPU (with the cache/write buffer off, at least)
                 GBLL Use_DMA_Clear
Use_DMA_Clear    SETL {TRUE}

init_ram
        ; There is some setup we want to do here - auto & smart idle modes!
        LDR     v1, =SDRC_Regs
        MOV     a1, #1+(2<<3)
        STR     a1, [v1, #SDRC_SYSCONFIG]
 [ {FALSE} ; With multiple board types supported, it's now much easier just to rely on u-boot to set everything up properly.
        ; Make sure all attached RAM is initialised
        ; Although x-loader will initialise some RAM for us, it might not necessarily use the best settings, and it might not initialise all the RAM that's available (e.g. CS1 on rev C beagleboard)
        ; This code roughly follows the sdrc_init()/dram_init() flow in u-boot

        LDR     v1, =SDRC_Regs
        ; CS0 setup:
        ; - If we're not running from SDRAM, (re)init CS0
        MOV     a1, pc
        CMP     a1, #CS0_SDRAM
        BHS     %FT10
        ; do_sdrc_init(CS0,EARLY_INIT)
        ; First we reset SDRC
        MOV     a1, #2
        STR     a1, [v1, #SDRC_SYSCONFIG] ; SOFTRESET
        MOV     a2, #12*1024*1024
20
        LDR     a1, [v1, #SDRC_SYSSTATUS]
        TST     a1, #1
        BNE     %FT30
        SUBS    a2, a2, #1
        BNE     %BT20
30
        MOV     a1, #0
        STR     a1, [v1, #SDRC_SYSCONFIG]
        ; Setup SDRC to ball mux. Or something.
        MOV     a1, #&100
        STR     a1, [v1, #SDRC_SHARING]
        ; Disable powerdown via CKE
        MOV     a1, #&81
        STR     a1, [v1, #SDRC_POWER_REG]
        ; Enable DLL, 90 degree phase
        MOV     a1, #&A
        STR     a1, [v1, #SDRC_DLLA_CTRL]
        ; Wait for lock (indefinitely?)
20
        LDR     a1, [v1, #SDRC_DLLA_STATUS]
        TST     a1, #4
        BEQ     %BT20

        ; Now initialise CS0
        LDR     a1, =&02584099 ; 128MB, etc.
        STR     a1, [v1, #SDRC_MCFG_0]
        LDR     a1, =&4E201
        STR     a1, [v1, #SDRC_RFR_CTRL_0]
        LDR     a1, =(21 :SHL: 27) :OR: (10 :SHL: 22) :OR: (7 :SHL: 18) :OR: (3 :SHL: 15) :OR: (3 :SHL: 12) :OR: (2 :SHL: 9) :OR: (3 :SHL: 6) :OR: 6
        STR     a1, [v1, #SDRC_ACTIM_CTRLA_0] ; 165MHz timings
        LDR     a1, =(1 :SHL: 12) :OR: 23 :OR: (5 :SHL: 8) :OR: (1 :SHL: 16)
        STR     a1, [v1, #SDRC_ACTIM_CTRLB_0]
        ; NOP, PRECHARGE, AUTOREFRESH, AUTOREFRESH sequence
        MOV     a1, #0
        STR     a1, [v1, #SDRC_MANUAL_0]
        MOV     a1, #1
        STR     a1, [v1, #SDRC_MANUAL_0]
        MOV     a1, #2
        STR     a1, [v1, #SDRC_MANUAL_0]
        STR     a1, [v1, #SDRC_MANUAL_0]
        ; CAS latency, burst length, etc.
        MOV     a1, #&32
        STR     a1, [v1, #SDRC_MR_0]
        ; Now check the setup
        ; This is the same technique as mem_ok() in u-boot
        LDR     a1, =CS0_SDRAM
        MOV     a2, #0
        LDR     a3, =&12345678
        STR     a2, [a1, #&400]
        STR     a3, [a1]
        STR     a2, [a1, #4]
        LDR     a2, [a1, #&400]
        LDR     a4, [a1]
        CMP     a2, #0
        CMPEQ   a3, a4
        BEQ     %FT10 ; It's good
        ; Else it's bad and we need to disable CS0
        MOV     a1, #0
        STR     a1, [v1, #SDRC_MCFG_0]
10
        ; Check if CS1 is active
        ; If not, and we're a rev C beagleboard, activate it
        LDR     a1, [v1, #SDRC_MCFG_1]
        LDR     a2, =&3FF00
        TST     a1, a2
        BNE     %FT10
        ; Beagleboard rev C check:
        ; Although the manual fails to mention it, apparently GPIO 171 will be low if we're on rev C
        ; Else we're rev A/B
        LDR     a2, =L4_GPIO6
        LDR     a1, [a2, #GPIO_OE]
        ORR     a1, a1, #1:SHL:11
        STR     a1, [a2, #GPIO_OE]
        ; Wait a bit just to make sure the input is up to date
        MOV     a1, #32768
5
        SUBS    a1, a1, #1
        BNE     %BT5
        LDR     a1, [a2, #GPIO_DATAIN]
        TST     a1, #1:SHL:11
        BNE     %FT10

        ; Make CS0 and CS1 contiguous, in case it helps RISC OS a bit (e.g. finding large areas of contiguous physical memory for IO)
        LDR     a1, [v1, #SDRC_MCFG_0]
        LDR     a2, =&3FF<<1
        ANDS    a1, a2, a1, LSR #7 ; CS0 size in MB
        BEQ     %FT5 ; If no CS0, just program offset of 0
        CMP     a1, #32
        MOVLT   a1, #32 ; Min 32MB offset if CS0 present
        ; Round up to power of two
        SUB     a2, a1, #1
        TST     a2, a1
        CLZNE   a2, a1
        MOVNE   a1, #1
        MOVNE   a1, a1, ROR a2
5
        AND     a2, a1, #&60 ; 32MB offset
        MOV     a1, a1, LSR #7 ; 128MB offset
        ORR     a1, a1, a2, LSL #3
        STR     a1, [v1, #SDRC_CS_CFG]
        
        ; Initialise CS1
        LDR     a1, =&02584099 ; 128MB, etc.
        STR     a1, [v1, #SDRC_MCFG_1]
        LDR     a1, =&4E201
        STR     a1, [v1, #SDRC_RFR_CTRL_1]
        LDR     a1, =(21 :SHL: 27) :OR: (10 :SHL: 22) :OR: (7 :SHL: 18) :OR: (3 :SHL: 15) :OR: (3 :SHL: 12) :OR: (2 :SHL: 9) :OR: (3 :SHL: 6) :OR: 6
        STR     a1, [v1, #SDRC_ACTIM_CTRLA_1] ; 165MHz timings
        LDR     a1, =(1 :SHL: 12) :OR: 23 :OR: (5 :SHL: 8) :OR: (1 :SHL: 16)
        STR     a1, [v1, #SDRC_ACTIM_CTRLB_1]
        ; NOP, PRECHARGE, AUTOREFRESH, AUTOREFRESH sequence
        MOV     a1, #0
        STR     a1, [v1, #SDRC_MANUAL_1]
        MOV     a1, #1
        STR     a1, [v1, #SDRC_MANUAL_1]
        MOV     a1, #2
        STR     a1, [v1, #SDRC_MANUAL_1]
        STR     a1, [v1, #SDRC_MANUAL_1]
        ; CAS latency, burst length, etc.
        MOV     a1, #&32
        STR     a1, [v1, #SDRC_MR_1]
        ; Now check the setup
        LDR     a1, =CS0_SDRAM
        LDR     a4, [v1, #SDRC_CS_CFG]
        AND     a3, a4, #7 ; Offset in 128MB units
        ADD     a1, a1, a3, LSL #20+7
        AND     a3, a4, #&300 ; Offset in 32MB units
        ADD     a1, a1, a3, LSL #20+5-8 ; a1 = CS1 start
        MOV     a2, #0
        LDR     a3, =&12345678
        STR     a2, [a1, #&400]
        STR     a3, [a1]
        STR     a2, [a1, #4]
        LDR     a2, [a1, #&400]
        LDR     a4, [a1]
        CMP     a2, #0
        CMPEQ   a3, a4
        BEQ     %FT10 ; It's good
        ; Else it's bad and we need to disable CS1
        MOV     a1, #0
        STR     a1, [v1, #SDRC_MCFG_1]
10
 ]
        ; Done!
        MOV     pc, lr

        
        
; a1 <= Highest physical address in RAM +1
get_end_of_ram
        LDR     v1, =SDRC_Regs
        LDR     a3, [v1, #SDRC_MCFG_1]
        LDR     a2, =&3FF00<<13
        ANDS    a3, a2, a3, LSL #13
        BEQ     %FT10
        LDR     a2, =CS0_SDRAM
        LDR     a4, [v1, #SDRC_CS_CFG]
        AND     v2, a4, #7 ; Offset in 128MB units
        ADD     a2, a2, v2, LSL #20+7
        AND     v2, a4, #&300 ; Offset in 32MB units
        ADD     a2, a2, v2, LSL #20+5-8
        ADD     a1, a3, a2
        MOV     pc, lr
10
        ; No RAM in CS1; therefore must be in CS0
        LDR     a3, [v1, #SDRC_MCFG_0]
        LDR     a2, =&3FF00<<13
        AND     a3, a2, a3, LSL #13 ; Get CS0 RAM size
        LDR     a2, =CS0_SDRAM
        ADD     a1, a3, a2
        MOV     pc, lr



clear_ram
        ; Clear everything up to a1
        ; Can clobber all regs except v8 & sb
        ; If DMA clear is disabled, the clear areas must be multiples of 128 bytes in length. Else they must be multiples of 4 bytes.
 [ Use_DMA_Clear
        ; Reset the DMA controller
        LDR     v5, =L4_sDMA
  [ :LNOT: Use_DMA_Copy ; Already reset if using DMA copy
        MOV     v1, #2
        STR     v1, [v5, #DMA4_OCP_SYSCONFIG]
5
        LDR     v1, [v5, #DMA4_SYSSTATUS]
        TST     v1, #1
        BEQ     %BT5
        ; Set a sensible FIFO budget (as per SDMACReset)
        LDR     a2, =&100080
        STR     a2, [v5, #DMA4_GCR]
        ; Configure channel 0 for the right settings
        ADD     v5, v5, #DMA4_i
        LDR     v1, [v5, #DMA4_CLNK_CTRLi]
        BIC     v1, v1, #&8000 ; Disable channel linking
        STR     v1, [v5, #DMA4_CLNK_CTRLi]
        MOV     v1, #1<<4
        STR     v1, [v5, #DMA4_CICRi] ; frame end interrupt enabled
        MOV     v1, #1
        STR     v1, [v5, #DMA4_CFNi] ; 1 frame
  |
        ADD     v5, v5, #DMA4_i
  ]
        LDR     v1, =&2C002 ; 32bit elements, 64 byte bursts, last write non-posted
        STR     v1, [v5, #DMA4_CSDPi]
        MOV     v1, #0
        STR     v1, [v5, #DMA4_COLORi] ; Clear colour of 0. Although the clear colour register only holds a 24 bit value, the MSB (for 4-byte DMA) is always written as 0.
 ]
        MOV     v2, a1
        LDR     v1, =SDRC_Regs
        LDR     a3, [v1, #SDRC_MCFG_0]
        LDR     a2, =&3FF00<<13
        ANDS    a3, a2, a3, LSL #13 ; Get CS0 RAM size
        BEQ     %FT10
        LDR     a2, =CS0_SDRAM
        SUB     a1, v2, a2
        CMP     a1, a3
        MOVGT   a1, a3 ; Work out how much we're meant to be clearing
        CMP     a1, #0
        BEQ     %FT10
 [ Use_DMA_Clear
        ; To keep things simple we split the transfer into chunks small enough to fit inside
        ; one frame (64MB) and wait for each one to complete
        ; This means we don't have to worry about the code breaking if the clear area isn't
        ; MB aligned (or 128 byte aligned, as the original code assumed)
        MOV     a1, a1, LSR #2 ; Number of elements remaining
        MOV     a3, #&1000000 ; Max elements per transfer+1 (not quite 64MB!)
40
        LDR     v1, [v5, #DMA4_CSRi]
        STR     v1, [v5, #DMA4_CSRi] ; Clear status register
        CMP     a1, a3
        MOVLT   v1, a1
        SUBGE   v1, a3, #1
        STR     v1, [v5, #DMA4_CENi]
        SUB     a1, a1, v1
        STR     a2, [v5, #DMA4_CDSAi]
        ADD     a2, a2, v1, LSL #2
        LDR     a4, =&1014080
        STR     a4, [v5, #DMA4_CCRi] ; Enable channel with constant fill, post-increment destination, source synchronised
        ; Use the transfer size as a rough timer for how long we should wait before
        ; we start hammering the status register
50
        SUBS    v1, v1, #256
        BGT     %BT50
50
        LDR     v1, [v5, #DMA4_CSRi]
        TST     v1, #1<<4
        BEQ     %BT50
        ; Make doubly sure that it's finished by checking WR_ACTIVE/RD_ACTIVE
50
        LDR     v1, [v5, #DMA4_CCRi]
        TST     v1, #&600
        BNE     %BT50
        CMP     a1, #0
        BNE     %BT40
 |
        MOV     a3, #0
        MOV     a4, #0
        MOV     v1, #0
        MOV     v3, #0
        MOV     v4, #0
        MOV     v5, #0
        MOV     sp, #0
        MOV     ip, #0
20
        STMIA   a2!,{a3,a4,v1,v3,v4,v5,sp,ip} ; 32 bytes
        STMIA   a2!,{a3,a4,v1,v3,v4,v5,sp,ip} ; 64 bytes
        STMIA   a2!,{a3,a4,v1,v3,v4,v5,sp,ip} ; 96 bytes
        STMIA   a2!,{a3,a4,v1,v3,v4,v5,sp,ip} ; 128 bytes
        SUBS    a1, a1, #128
        BGT     %BT20
 ]
10
        LDR     v1, =SDRC_Regs
        LDR     a3, [v1, #SDRC_MCFG_1]
        LDR     a2, =&3FF00<<13
        ANDS    a3, a2, a3, LSL #13
        BEQ     %FT30
        LDR     a2, =CS0_SDRAM
        LDR     a4, [v1, #SDRC_CS_CFG]
        AND     v3, a4, #7 ; Offset in 128MB units
        ADD     a2, a2, v3, LSL #20+7
        AND     v3, a4, #&300 ; Offset in 32MB units
        ADD     a2, a2, v3, LSL #20+5-8
        SUB     a1, v2, a2
        CMP     a1, a3
        MOVGT   a1, a3 ; Work out how much we're meant to be clearing
        CMP     a1, #0
        BEQ     %FT30
 [ Use_DMA_Clear
        ; To keep things simple we split the transfer into chunks small enough to fit inside
        ; one frame (64MB) and wait for each one to complete
        ; This means we don't have to worry about the code breaking if the clear area isn't
        ; MB aligned (or 128 byte aligned, as the original code assumed)
        MOV     a1, a1, LSR #2 ; Number of elements remaining
        MOV     a3, #&1000000 ; Max elements per transfer+1 (not quite 64MB!)
40
        LDR     v1, [v5, #DMA4_CSRi]
        STR     v1, [v5, #DMA4_CSRi] ; Clear status register
        CMP     a1, a3
        MOVLT   v1, a1
        SUBGE   v1, a3, #1
        STR     v1, [v5, #DMA4_CENi]
        SUB     a1, a1, v1
        STR     a2, [v5, #DMA4_CDSAi]
        ADD     a2, a2, v1, LSL #2
        LDR     a4, =&1014080
        STR     a4, [v5, #DMA4_CCRi] ; Enable channel
        ; Use the transfer size as a rough timer for how long we should wait before we start hammering the status register
50
        SUBS    v1, v1, #256
        BGT     %BT50
50
        LDR     v1, [v5, #DMA4_CSRi]
        TST     v1, #1<<4
        BEQ     %BT50
        ; Make doubly sure that it's finished by checking WR_ACTIVE/RD_ACTIVE
50
        LDR     v1, [v5, #DMA4_CCRi]
        TST     v1, #&600
        BNE     %BT50
        CMP     a1, #0
        BNE     %BT40
 |

        MOV     a3, #0
        MOV     a4, #0
        MOV     v1, #0
        MOV     v3, #0
        MOV     v4, #0
        MOV     v5, #0
        MOV     sp, #0
        MOV     ip, #0
40
        STMIA   a2!,{a3,a4,v1,v3,v4,v5,sp,ip} ; 32 bytes
        STMIA   a2!,{a3,a4,v1,v3,v4,v5,sp,ip} ; 64 bytes
        STMIA   a2!,{a3,a4,v1,v3,v4,v5,sp,ip} ; 96 bytes
        STMIA   a2!,{a3,a4,v1,v3,v4,v5,sp,ip} ; 128 bytes
        SUBS    a1, a1, #128
        BGT     %BT40
 ]
30
 [ Use_DMA_Clear
        ; Invalidate the I-cache & BTC, just in case
        ; (D cache & L2 cache should be turned off, so no need to worry about them)
        MOV     a1, #0
        MCR     p15, 0, a1, c7, c5, 0
        MCR     p15, 0, a1, c7, c5, 6
        DSB     SY
        ISB     SY
 ]
        MOV     pc, lr

        END
@


1.11
log
@Line some things up.
To help OMAP4 tracking changes a number of the changes were purely cosmetic lining up differences, this change is where OMAP3 wasn't on a conventional column layout.

Version 0.61. Tagged as 'OMAP3-0_61'
@
text
@d389 2
a390 2
        myDSB
        myISB
@


1.10
log
@Add compressed ROM support. Add boot timing code. Other misc tweaks.
Detail:
  hdr/omap3530, s/Boot, s/KbdScan, s/Top, s/Video - Added code for profiling/timing the startup sequence, using the 32K system timer
  s/Boot - Ensure VAUX2 is enabled during EVM startup
  s/Boot, s/CPUClk - Go to full CPU speed during HAL_Init instead of HAL_InitDevices.
  s/KbdScan - Print out heap usage stats when debugging is enabled
  s/NVMemory - Skip probing for CMOS carrier board if JTAG is active
  s/RAM, s/Top - Use DMA to relocate the ROM image instead of simple memcpy code. Relocate compressed ROMs to a location suitable for decompression.
Admin:
  Tested with compressed & uncompressed OMAP3/OMAP3Live images


Version 0.59. Tagged as 'OMAP3-0_59'
@
text
@d262 4
a265 2
        ; To keep things simple we split the transfer into chunks small enough to fit inside one frame (64MB) and wait for each one to complete
        ; This means we don't have to worry about the code breaking if the clear area isn't MB aligned (or 128 byte aligned, as the original code assumed)
d280 2
a281 1
        ; Use the transfer size as a rough timer for how long we should wait before we start hammering the status register
d331 4
a334 2
        ; To keep things simple we split the transfer into chunks small enough to fit inside one frame (64MB) and wait for each one to complete
        ; This means we don't have to worry about the code breaking if the clear area isn't MB aligned (or 128 byte aligned, as the original code assumed)
d384 2
a385 1
        ; Invalidate the I-cache & BTC, just in case (D cache & L2 cache should be turned off, so no need to worry about them)
d392 1
a392 1
        MOV     pc, lr 
@


1.9
log
@Add support for POR detection.
Harder than it should have been because someone wired the reset button up to the cold reset pin.
Now gets the OSStartFlags right so that delete-power-on et al are respected by the kernel.

Version 0.57. Tagged as 'OMAP3-0_57'
@
text
@d222 1
a233 2
        LDR     v1, =&1014000 ; Constant fill, post-increment destination, source synchronised
        STR     v1, [v5, #DMA4_CCRi]
a236 2
        MOV     v1, #0
        STR     v1, [v5, #DMA4_COLORi] ; Clear colour of 0. Although the clear colour register only holds a 24 bit value, the MSB (for 4-byte DMA) is always written as 0.
d239 5
d246 2
a247 2
        MOV     v1, #1
        STR     v1, [v5, #DMA4_CFNi] ; 1 frame
d277 1
a277 1
        STR     a4, [v5, #DMA4_CCRi] ; Enable channel
@


1.8
log
@Update OMAP3 HAL to use correct instruction/memory barrier operations and to handle branch target predictors
Detail:
  hdr/Copro15ops - Added myISB, myDSB, myDMB macros to provide barrier functionality for ARMv6+
  s/Boot, s/Interrupts, s/RAM, s/Top, s/Video - updated to use correct barrier operations after CP15 writes, and to invalidate branch predictors where appropriate
Admin:
  Tested on rev C2 beagleboard


Version 0.28. Tagged as 'OMAP3-0_28'
@
text
@d235 3
a238 1
        STR     v1, [v5, #DMA4_CLNK_CTRLi] ; Disable channel linking
@


1.7
log
@Various OMAP3 HAL power management improvements, plus add support for board config autodetection via Linux machine ID
Detail:
  s/board, hdr/board - Add Linux machine ID & available mixer channels to board config table
  s/Top - Add new entry point at offset &64, for booting as a fake Linux kernel. Searches the board config table until it finds a config matching the machine ID passed in R1. Also minor ROM copy optimisation, unsigned pointer comparison fixes
  s/Audio, hdr/Audio - Use board config to lock-out mixer channels that aren't connected to any hardware, to avoid excessive power drain or other problems if the channels get turned on. Also perform many other setting tweaks to tidy up default settings for unused mixer paths/channels.
  s/Video - Fix Video_Init logic when deciding whether to reset DSS, enable DSI PLL drift guard
  s/I2C - Increase I2C timeout values, since the previous values were perhaps a bit low
  s/Audio, s/I2C, s/Interrupts, s/RAM, s/SDMA, s/Timers, s/UART, hdr/UART, s/USB, s/Video - Enable autoidle/smart idle where possible to help save power.
Admin:
  Tested on rev C2 beagleboard


Version 0.21. Tagged as 'OMAP3-0_21'
@
text
@d375 1
a375 1
        ; Invalidate the I-cache & TLB, just in case (D cache & L2 cache should be turned off, so no need to worry about them)
d378 3
a380 1
        MCR     p15, 0, a1, c8, c7, 0
@


1.6
log
@Update OMAP HAL to support different board configs, plus use new YearLOIsGood flag to ensure correct RTC handling, plus other misc tidying
Detail:
  The OMAP HAL now has multiple entry points, one per board config. See Top.s/board.s for more info.
  audio.s - Moved APLL_CTL value to board config
  board.s - New file to list all the settings for the different board configs
  boot.s - Change HAL_Init to deal with the new board config stuff
  debug.s - Debug UART now specified in board config
  GPIO.s - A few utility functions for handling OMAP/TPS GPIO pins
  I2C.s - Update to use new board config struct
  RAM.s - Disable the beagleboard-specific RAM init code. Instead we'll just rely on u-boot to initialise all our RAM for us.
  RTC.s - Get rid of the magic numbers, and use the YearLOIsGood flag to indicate to RISC OS that YearLO is 2-digit BCD
  Top.s - Got rid of old debug code and rewrote initial flow to handle detecting & storing the board config
  UART.s - Update to use board config struct, support multiple UARTs
  USB.s - Get EHCI PHY power GPIO from board config
  Video.s - Get DVI framer power GPIO and max pixel rate from board config. Add 'PassiveVideo' option, to build a driver that doesn't alter the video output settings - should hopefully result in a usable display on Touch Book, etc.
  board.hdr - Definition of board config table struct
  GPIO.hdr - Add lots of macros for handling OMAP GPIO pins, new constants for OMAP/TPS GPIO
  I2C.hdr - Added I2C transfer block struct, HAL I2C API transfer states (both moved here from other source files)
  omap3530.hdr - Move/remove some unwanted constants, disable DebugChar for now
  StaticWS.hdr - Move I2C transfer block struct to I2C.hdr, add board config struct to HAL workspace, get rid of unused 64K AllocArea
  Timers.hdr - Tidy up constants a bit
  UART.hdr - Add UARTCLK (moved from StaticWS.hdr), UART IRQ #'s
  Makefile - add GPIO.s
Admin:
  Tested on rev C2 beagleboard. Board configs for other board types may be inaccurate in a couple of places.


Version 0.19. Tagged as 'OMAP3-0_19'
@
text
@d20 4
@


1.5
log
@OMAP3 DMA support, video device, debugging improvements
Detail:
  Boot.s - Make FIQDebug work again
  Boot.s - Add support for DMA & video devices
  Interrupts.s, hdr/omap3530 - Add 'ExtraDebugInterrupts' option
  hdr/SDMA, SDMA.s, Makefile - DMA code which presents itself to RISC OS as a set of single-buffered, interrupt-driven DMA channels.
  hdr/StaticWS - Add extra DMA, video & debug entries to workspace
  Interrupts.s - Add 'DebugDisablePrevious' debug option for more flexibility in tracking down noncleared IRQs with ExtraDebugInterrupts
  RAM.s - Use DMA to clear RAM on boot. RAM clear now takes less than 1 second on a rev C board, whereas before it used to take several.
  Video.s - Add simple HAL device to expose information needed by upcoming RISC OS module based video driver.
Admin:
  Tested on rev C2 beagleboard.


Version 0.16. Tagged as 'OMAP3-0_16'
@
text
@d20 1
d179 1
d213 1
a213 1
        ; Can clobber all regs except v8
@


1.4
log
@OMAP3 HAL video support, safer RAM initialisation
Detail:
  Makefile - Enable compilation of s.video
  hdr/StaticWS - New workspace entries for video support
  hdr/Video - Typo fix, VENC registers
  s/Boot - Change initialisation order for video support
  s/Debug - Added DebugMemDump routine
  s/RAM - Added code to verify RAM config, to avoid crash if a board looks like a revision C but doesn't have the extra RAM
  s/Stubs - Disable stub video functions
  s/Video - Working video code, beginnings of TV-out code
Admin:
  Tested on rev C2 beagleboard. Video code may only function correctly if kernel is loaded via u-boot.


Version 0.06. Tagged as 'OMAP3-0_06'
@
text
@d15 4
d29 1
a29 1
        BGE     %FT10
d211 28
a238 1
        ; This relies on the clear areas being multiples of 128 bytes in length
d249 35
d299 1
d315 36
d366 1
d368 6
@


1.3
log
@Fix RAM clear in OMAP3 HAL
Detail:
  s/RAM - Added v4 to register list in RAM clear routines to ensure correct amount of RAM is cleared
Admin:
  Tested on Rev C2 beagleboard


Version 0.05. Tagged as 'OMAP3-0_05'
@
text
@d75 16
a90 1
        ; todo - check setup like mem_ok()
d153 20
a172 1
        ; todo - check, etc.
@


1.2
log
@OMAP3 HAL Beagleboard Rev C support, further video work.
Detail:
  s/Boot - Fixes for rev C beagleboard. Added GPIO code.
  s/Debug - DebugHALPrint, DebugHALPrintReg routines
  s/PRCM - PRCM_GetFreqSel added
  s/RAM - Fixes for rev C beagleboard. Sped up RAM clear by using more regs.
  s/Top - Fixes for rev C beagleboard
  s/Video - Video code potentially complete, but full of bugs and so still disabled.
  hdr/GPIO - Added GPIO registers
  hdr/omap3530 - Fixes for rev C beagleboard, GPIO, debug macros, QEMU support for new video code
  hdr/SDRC - Typo fix
  hdr/StaticWS - GPIO, pixel rate entries added
  hdr/Video - DSI PLL registers added
Admin:
  Tested on rev C beagleboard.


Version 0.04. Tagged as 'OMAP3-0_04'
@
text
@d193 4
a196 4
        STMIA   a2!,{a3,a4,v1,v3,v5,sp,ip} ; 32 bytes
        STMIA   a2!,{a3,a4,v1,v3,v5,sp,ip} ; 64 bytes
        STMIA   a2!,{a3,a4,v1,v3,v5,sp,ip} ; 96 bytes
        STMIA   a2!,{a3,a4,v1,v3,v5,sp,ip} ; 128 bytes
d223 4
a226 4
        STMIA   a2!,{a3,a4,v1,v3,v5,sp,ip} ; 32 bytes
        STMIA   a2!,{a3,a4,v1,v3,v5,sp,ip} ; 64 bytes
        STMIA   a2!,{a3,a4,v1,v3,v5,sp,ip} ; 96 bytes
        STMIA   a2!,{a3,a4,v1,v3,v5,sp,ip} ; 128 bytes
@


1.1
log
@Basic OMAP3 HAL
Detail:
  Performs startup procedure suitable for any location in ROM or RAM. UART, timer, counter, interrupt & debug functionality implemented. Video support incomplete and nonfunctional.
Admin:
  Tested with HALTester & RISC OS kernel under qemu-omap3


Version 0.01. Tagged as 'OMAP3-0_01'
@
text
@d15 130
d152 1
a152 1
        LDR     a2, =CS1_SDRAM
d168 2
a169 1
        
d173 1
d185 7
d193 5
a197 2
        STR     a3, [a2], #4
        SUBS    a1, a1, #4
d200 1
d205 1
a205 1
        LDR     a2, =CS1_SDRAM
d207 4
a210 4
        AND     v2, a4, #7 ; Offset in 128MB units
        ADD     a2, a2, v2, LSL #20+7
        AND     v2, a4, #&300 ; Offset in 32MB units
        ADD     a2, a2, v2, LSL #20+5-8
d215 7
d223 5
a227 2
        STR     a3, [a2], #4
        SUBS    a1, a1, #4
@


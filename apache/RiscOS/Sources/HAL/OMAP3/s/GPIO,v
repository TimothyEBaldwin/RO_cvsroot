head	1.14;
access;
symbols
	OMAP3-1_18:1.14
	OMAP3-1_17:1.12
	OMAP3-1_16:1.12
	OMAP3-1_15:1.11
	OMAP3-1_14:1.11
	SMP:1.11.0.2
	SMP_bp:1.11
	OMAP3-1_13:1.11
	OMAP3-1_12:1.11
	OMAP3-1_11:1.11
	OMAP3-1_10:1.11
	OMAP3-1_09:1.11
	OMAP3-1_08:1.11
	OMAP3-1_07:1.11
	OMAP3-1_06:1.11
	OMAP3-1_05:1.11
	OMAP3-1_04:1.11
	OMAP3-1_03:1.10
	OMAP3-1_02:1.10
	OMAP3-1_01:1.10
	OMAP3-1_00:1.10
	OMAP3-0_99:1.9
	OMAP3-0_98:1.9
	OMAP3-0_97:1.9
	OMAP3-0_96:1.9
	OMAP3-0_95:1.9
	OMAP3-0_94:1.9
	OMAP3-0_93:1.9
	OMAP3-0_92:1.9
	OMAP3-0_91:1.9
	OMAP3-0_90:1.9
	OMAP3-0_89:1.9
	OMAP3-0_88:1.9
	OMAP3-0_87:1.9
	OMAP3-0_86:1.9
	OMAP3-0_85:1.9
	OMAP3-0_84:1.9
	OMAP3-0_83:1.9
	OMAP3-0_82:1.9
	OMAP3-0_81:1.9
	OMAP3-0_80:1.9
	OMAP3-0_79:1.9
	OMAP3-0_78:1.9
	OMAP3-0_77:1.9
	OMAP3-0_76:1.9
	OMAP3-0_75:1.9
	OMAP3-0_74:1.9
	OMAP3-0_73:1.9
	OMAP3-0_72:1.9
	OMAP3-0_71:1.9
	OMAP3-0_70:1.9
	OMAP3-0_69:1.9
	OMAP3-0_68:1.9
	OMAP3-0_67:1.9
	OMAP3-0_66:1.9
	OMAP3-0_65:1.9
	OMAP3-0_64:1.9
	OMAP3-0_63:1.9
	OMAP3-0_62:1.9
	OMAP3-0_61:1.9
	OMAP3-0_60:1.9
	OMAP3-0_59:1.9
	OMAP3-0_58:1.9
	OMAP3-0_57:1.9
	OMAP3-0_56:1.9
	OMAP3-0_55:1.9
	OMAP3-0_54:1.9
	OMAP3-0_53:1.9
	OMAP3-0_52:1.9
	OMAP3-0_51:1.9
	OMAP3-0_50:1.9
	OMAP3-0_49:1.9
	OMAP3-0_48:1.9
	OMAP3-0_47:1.8
	OMAP3-0_46:1.7
	OMAP3-0_45:1.7
	OMAP3-0_44:1.6
	OMAP3-0_43:1.6
	OMAP3-0_42:1.6
	OMAP3-0_41:1.6
	OMAP3-0_40:1.6
	OMAP3-0_39:1.6
	OMAP3-0_38:1.6
	OMAP3-0_37:1.6
	OMAP3-0_36:1.6
	OMAP3-0_35:1.6
	OMAP3-0_34:1.6
	OMAP3-0_33:1.6
	OMAP3-0_32:1.5
	OMAP3-0_31:1.4
	OMAP3-0_30:1.4
	OMAP3-0_29:1.4
	OMAP3-0_28:1.4
	OMAP3-0_27:1.4
	OMAP3-0_26:1.4
	OMAP3-0_25:1.3
	OMAP3-0_24:1.2
	OMAP3-0_23:1.1
	OMAP3-0_22:1.1
	OMAP3-0_21:1.1
	OMAP3-0_20:1.1
	OMAP3-0_19:1.1;
locks; strict;
comment	@# @;


1.14
date	2018.04.08.08.22.27;	author rool;	state Exp;
branches;
next	1.13;
commitid	oE2UfMWDo6GU6CxA;

1.13
date	2018.04.01.21.23.04;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	0gqrh5c5mI0fFMwA;

1.12
date	2018.03.30.07.55.39;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	KtoigwpzbOUegswA;

1.11
date	2015.04.08.07.37.49;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	KMkj6KKX1Lup6Lgy;

1.10
date	2014.12.06.10.43.11;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	txtXqid4r9I85Y0y;

1.9
date	2011.07.31.18.56.21;	author jlee;	state Exp;
branches;
next	1.8;
commitid	trdyxuPEj4eC9Itv;

1.8
date	2011.07.24.21.34.35;	author jlee;	state Exp;
branches;
next	1.7;
commitid	2eoDX0AwjB7SfPsv;

1.7
date	2011.05.25.20.19.27;	author jlee;	state Exp;
branches;
next	1.6;
commitid	3j2efxRJLXkFL6lv;

1.6
date	2010.10.26.23.27.14;	author jlee;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.14.20.58.50;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.28.17.59.49;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.20.01.40.19;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.20.01.07.07;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.24.02.49.32;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.14
log
@GPIO readability
Detail:
  Use symbol instead of magic 6. Comment correction.
Admin:
  Binary unchanged. Retagged as 'OMAP3-1_18'.
@
text
@; Copyright 2010 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO
        GET     Hdr:Proc

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.omap3530
        GET     hdr.StaticWS
        GET     hdr.GPIO

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  GPIO_Init
        EXPORT  GPIOx_SetAsOutput
        EXPORT  GPIOx_SetOutput
        EXPORT  GPIOx_SetAndEnableIRQ
        EXPORT  GPIO_InitDevices
        IMPORT  TPSRead
        IMPORT  TPSWrite
        IMPORT  IIC_DoOp_Poll
        IMPORT  memcpy

GPIO_Init
        ; Don't bother resetting the controllers, it could conflict with settings made by x-loader/u-boot
        Entry   "v1-v3",4
        ADR     a1, L4_GPIO_Table
        MOV     a2, #GPIO_PORT_MAX
        MOV     a3, #0
10
        LDR     a4, [a1], #4
        SUBS    a2, a2, #1
        STR     a3, [a4, #GPIO_IRQENABLE1]
        BNE     %BT10
        ; Make sure the TPS GPIOs are enabled properly.
        ; Specifically:
        ; - Set the GPIO_ON bit in GPIO_CTRL
        LDR     v1, HALInitialised
        CMP     v1, #0
        ADREQL  v1, IIC_DoOp_Poll
        LDRNE   v1, OSentries+4*OS_IICOpV
        MOV     a1, #TPSGPIO_IIC*2
        MOV     a2, sp
        MOV     a3, #1
        MOV     a4, #TPS_GPIO_CTRL
        BL      TPSRead
        LDRB    ip, [a2]
        TST     ip, #4 ; GPIO_ON
        ORREQ   ip, ip, #4
        STREQB  ip, [a2]
        MOVEQ   a1, #TPSGPIO_IIC*2
        BLEQ    TPSWrite
        ; - For the beagleboard, set up the right pullup/down settings
        ; TODO - Do other platforms, and add to boardconfig
        LDR     a1, [sb, #BoardConfig_MachID]
        LDR     a2, =MachID_BeagleBoard
        CMP     a1, a2
        BNE     %FT10
        MOV     a1, #TPSGPIO_IIC*2
        ADR     a2, Beagle_TPS_PUPD
        MOV     a3, #5
        MOV     a4, #TPS_GPIOPUPCTR1
        BL      TPSWrite
10
        EXIT

Beagle_TPS_PUPD
        DCD     4_1010000111000120 ; 0 = PU/PD off, 1=PD, 2=PU
        DCD     4_0011

        ; a1 = GPIO # (OMAP or TPS or TPS LED)
        ; a2 = initial value (zero or nonzero)
GPIOx_SetAsOutput
        SUBS    a3, a1, #GPIO_PIN_MAX
        BGE     %FT10
        ; OMAP GPIO
        GPIO_PrepareR a3, a4, a1
        GPIO_SetAsOutput a3, a4, a1
        GPIO_SetOutput a2, a3, a4
        MOV     pc, lr
10      ; TPS GPIO
        Entry   "v1-v3", 4
        CMP     a3, #TPS_GPIO_PIN_MAX
        BGE     %FT20
        MOV     a4, a3, LSR #3 ; Register offset
        MOV     v2, a2
        AND     a3, a3, #&7
        MOV     v3, #1
        MOV     v3, v3, LSL a3 ; Mask value
        ; If HAL_Init isn't done yet, we can't use OS_IICOpV
        LDR     v1, HALInitialised
        CMP     v1, #0
        ADREQL  v1, IIC_DoOp_Poll
        LDRNE   v1, OSentries+4*OS_IICOpV
        MOV     a1, #TPSGPIO_IIC*2
        MOV     a2, sp
        MOV     a3, #1
        ADD     a4, a4, #TPS_GPIODATADIR1
        BL      TPSRead
        ; TODO - Handle error!
        LDRB    ip, [a2]
        ORR     ip, ip, v3
        STRB    ip, [a2]
        MOV     a1, #TPSGPIO_IIC*2
        BL      TPSWrite
        STRB    v3, [a2]
        MOV     a1, #TPSGPIO_IIC*2
        CMP     v2, #0
        ADDNE   a4, a4, #TPS_SETGPIODATAOUT1-TPS_GPIODATADIR1
        ADDEQ   a4, a4, #TPS_CLEARGPIODATAOUT1-TPS_GPIODATADIR1
        BL      TPSWrite
        EXIT
20      ; TPS LED
        ; First make sure the relevant PWM is configured correctly
        ; i.e. generate a constant signal, not timed on/off
        Push    "a2,a3"
        MOV     a1, #TPSLED_IIC*2
        ADR     a2, PWM_Value
        MOV     a3, #2
        MOVEQ   a4, #TPS_PWMAON
        MOVNE   a4, #TPS_PWMBON
        LDR     v1, HALInitialised
        CMP     v1, #0
        ADREQL  v1, IIC_DoOp_Poll
        LDRNE   v1, OSentries+4*OS_IICOpV
        BL      TPSWrite
        ; Also make sure the PWM clocks are enabled
        MOV     a1, #&49*2
        ADD     a2, sp, #8
        MOV     a3, #1
        MOV     a4, #&91 ; GPBR1
        BL      TPSRead
        LDR     ip, [sp, #4]
        CMP     ip, #TPS_GPIO_PIN_MAX
        LDRB    ip, [a2]
        ORREQ   ip, ip, #&5
        ORRNE   ip, ip, #&a
        STRB    ip, [a2]
        MOV     a1, #&49*2
        BL      TPSWrite
        Pull    "a2,a3"
        CMP     a3, #TPS_GPIO_PIN_MAX
        ; Match the behaviour of Linux:
        ; a2=0 sets the LED*ON and LED*PWM bits
        ; a2!=0 clears them
        MOVEQ   v3, #&55 ; Mask for LEDA bits
        MOVNE   v3, #&AA ; Mask for LEDB bits
        CMP     a2, #0
        MOVNE   v2, #0 ; a2!=0, don't set any bits
        ANDEQ   v2, v3, #&33 ; a2=0, set appropriate LED*ON and LED*PWM bit
        MOV     a1, #TPSLED_IIC*2
        MOV     a2, sp
        MOV     a3, #1
        MOV     a4, #TPS_LEDEN
        ; If HAL_Init isn't done yet, we can't use OS_IICOpV
        BL      TPSRead
        LDRB    ip, [a2]
        BIC     ip, ip, v3
        ORR     ip, ip, v2
        STRB    ip, [a2]
        MOV     a1, #TPSLED_IIC*2
        BL      TPSWrite
        EXIT

PWM_Value
        DCD     &7f7f

        ; a1 = GPIO # (OMAP or TPS)
        ; a2 = value (zero or nonzero)
GPIOx_SetOutput
        SUBS    a3, a1, #GPIO_PIN_MAX
        BGE     %FT10
        ; OMAP GPIO
        GPIO_PrepareR a3, a4, a1
        GPIO_SetOutput a2, a3, a4
        MOV     pc, lr
10      ; TPS GPIO
        Entry   "v1-v2", 4
        MOV     a4, a3, LSR #3 ; Register offset
        CMP     a2, #0
        AND     a3, a3, #&7
        ADDNE   a4, a4, #TPS_SETGPIODATAOUT1
        MOV     v1, #1
        ADDEQ   a4, a4, #TPS_CLEARGPIODATAOUT1
        MOV     v1, v1, LSL a3 ; Mask value
        MOV     a2, sp
        STRB    v1, [sp]
        MOV     a1, #TPSGPIO_IIC*2
        ; If HAL_Init isn't done yet, we can't use OS_IICOpV
        LDR     v1, HALInitialised
        CMP     v1, #0
        ADREQL  v1, IIC_DoOp_Poll
        LDRNE   v1, OSentries+4*OS_IICOpV
        MOV     a3, #1
        BL      TPSWrite
        EXIT

        ; a1 = GPIO # (OMAP only!)
        ; a2 = IRQ type flags:
        ;      +1 = LEVELDETECT0
        ;      +2 = LEVELDETECT1
        ;      +4 = RISINGDETECT
        ;      +8 = FALLINGDETECT
GPIOx_SetAndEnableIRQ
        GPIO_PrepareR a3, a4, a1
        MRS     ip, CPSR
        ORR     a1, ip, #I32_bit ; interrupts off
        MSR     CPSR_c, a1
        MOV     a2, a2, LSL #28
        MSR     CPSR_f, a2 ; load into NZCV flags (MI EQ CS VS condition codes)
        LDR     a1, [a3, #GPIO_FALLINGDETECT]
        BICPL   a1, a1, a4
        LDR     a2, [a3, #GPIO_RISINGDETECT]
        ORRMI   a1, a1, a4
        STR     a1, [a3, #GPIO_FALLINGDETECT]
        BICNE   a2, a2, a4
        LDR     a1, [a3, #GPIO_LEVELDETECT1]
        ORREQ   a2, a2, a4
        STR     a2, [a3, #GPIO_RISINGDETECT]
        BICCC   a1, a1, a4
        LDR     a2, [a3, #GPIO_LEVELDETECT0]
        ORRCS   a1, a1, a4
        STR     a1, [a3, #GPIO_LEVELDETECT1]
        BICVC   a2, a2, a4
        LDR     a1, [a3, #GPIO_OE]
        ORRVS   a2, a2, a4
        ORR     a1, a1, a4 ; set pin as input
        STR     a2, [a3, #GPIO_LEVELDETECT0]
        STR     a1, [a3, #GPIO_OE]
        STR     a4, [a3, #GPIO_SETIRQENABLE1]
        MSR     CPSR_c, ip ; interrupts restored
        MOV     pc, lr

; Template for GPIO interface
GPIOTemplate
        DCW     HALDeviceType_Comms + HALDeviceComms_GPIO
        DCW     HALDeviceID_GPIO_OMAP3
        DCD     HALDeviceBus_Peri + HALDevicePeriBus_Sonics3220
        DCD     &10000          ; API 1.0
TDesc   DCD     0               ; Description (filled at runtime)
TAddr   DCD     0               ; Address (filled at runtime)
        %       12              ; Reserved
        DCD     GPIOActivate
        DCD     GPIODeactivate
        DCD     GPIOReset
        DCD     GPIOSleep
        DCD     -1              ; Device (none)
        DCD     0               ; TestIRQ
        DCD     0               ; ClearIRQ
        %       4               ; Reserved
        DCD     GPIO_PORT_MAX
TNumb   DCD     0               ; Port number (filled at runtime)
        DCD     GPIOEnumerate
        DCD     GPIOSetDataBits
        DCD     GPIOClearDataBits
        DCD     GPIOToggleDataBits
        DCD     GPIOReadDataBits
        DCD     GPIODataDirection
        DCD     GPIOReadMode
        DCD     GPIOWriteMode
        DCD     GPIOPullControl
        DCD     GPIOPullDirection
        DCD     GPIOEdgeControl
        DCD     GPIOEdgePollStatus
        ASSERT  (. - GPIOTemplate) = HALDevice_GPIO_Size_1_0

; GPIO structures
                    ^ 0
                    # HALDevice_GPIO_Size_1_0
WkspValidMask       # 4                 ; Valid bits on this port for this Type/Revision
WkspCopySB          # 4
Wksp_GPIO_Size      # 0
                    ASSERT ?GPIOWS = GPIO_PORT_MAX * Wksp_GPIO_Size

; Map Type/Revision to entry in GPIOFreeToUse table
                    ^ 0
GPIOType_BB         # 1 ; OMAP3530
GPIOType_BBxM       # 1 ; DM3730
GPIOType_DevKit8000 # 1 ; OMAP3530
GPIOType_IGEPv2     # 1 ; DM3730
GPIOType_Pandora    # 1 ; OMAP3530
;   Type_TouchBook  # 1 ; OMAP3530 (need schematic)
GPIOType_Max        # 0

GPIOTypeMap
        DCD     BoardType_OMAP3_BeagleBoard, BoardRevision_BeagleBoard_AB,     GPIOType_BB
        DCD     BoardType_OMAP3_BeagleBoard, BoardRevision_BeagleBoard_C123,   GPIOType_BB
        DCD     BoardType_OMAP3_BeagleBoard, BoardRevision_BeagleBoard_C4,     GPIOType_BB
        DCD     BoardType_OMAP3_BeagleBoard, BoardRevision_BeagleBoard_xMA,    GPIOType_BBxM
        DCD     BoardType_OMAP3_BeagleBoard, BoardRevision_BeagleBoard_xMB,    GPIOType_BBxM
        DCD     BoardType_OMAP3_BeagleBoard, BoardRevision_BeagleBoard_xMC,    GPIOType_BBxM
        DCD     BoardType_OMAP3_DevKit8000,  BoardRevision_DevKit8000_Unknown, GPIOType_DevKit8000
        DCD     BoardType_OMAP3_IGEPv2,      BoardRevision_IGEPv2_BC,          GPIOType_IGEPv2
        DCD     BoardType_OMAP3_IGEPv2,      BoardRevision_IGEPv2_C,           GPIOType_IGEPv2
        DCD     BoardType_OMAP3_Pandora,     BoardRevision_Pandora_Unknown,    GPIOType_Pandora
        ;       BoardType_OMAP3_TouchBook,   BoardRevision_TouchBook_Unknown,  GPIOType_TouchBook
        DCD     -1, -1, -1

; Friendly names
GPIODesc0
        DCB     "OMAP GPIO interface pins 0-31", 0
GPIODesc1
        DCB     "OMAP GPIO interface pins 32-63", 0
GPIODesc2
        DCB     "OMAP GPIO interface pins 64-95", 0
GPIODesc3
        DCB     "OMAP GPIO interface pins 96-127", 0
GPIODesc4
        DCB     "OMAP GPIO interface pins 128-159", 0
GPIODesc5
        DCB     "OMAP GPIO interface pins 160-191", 0
        ALIGN
GPIODescriptions
        DCD     GPIODesc0
        DCD     GPIODesc1
        DCD     GPIODesc2
        DCD     GPIODesc3
        DCD     GPIODesc4
        DCD     GPIODesc5

; Half a register of CONTROL_PADCONF
PADCONF_MUXMODE_SHIFT        * 0
PADCONF_MUXMODE_BITS         * 3
PADCONF_MUXMODE_GPIO         * 4:SHL:PADCONF_MUXMODE_SHIFT
PADCONF_MUXMODE_SAFE         * 7:SHL:PADCONF_MUXMODE_SHIFT
PADCONF_MUXMODE_MASK         * 7:SHL:PADCONF_MUXMODE_SHIFT
PADCONF_PULLUDENABLE_SHIFT   * 3
PADCONF_PULLUDENABLE         * 1:SHL:PADCONF_PULLUDENABLE_SHIFT
PADCONF_PULLTYPESELECT_SHIFT * 4
PADCONF_PULLTYPESELECT       * 1:SHL:PADCONF_PULLTYPESELECT_SHIFT
PADCONF_INPUTENABLE_SHIFT    * 8
PADCONF_INPUTENABLE          * 1:SHL:PADCONF_INPUTENABLE_SHIFT
PADCONF_OFFENABLE            * 1:SHL:9
PADCONF_OFFOUTENABLE         * 1:SHL:10
PADCONF_OFFOUTVALUE          * 1:SHL:11
PADCONF_OFFPULLUDENABLE      * 1:SHL:12
PADCONF_OFFPULLTYPESELECT    * 1:SHL:13
PADCONF_WAKEUPENABLE         * 1:SHL:14
PADCONF_WAKEUPEVENT          * 1:SHL:15

; Offset to CONTROL_PADCONF register from OMAP3530 datasheet Table 7-4
GPIOPadConfs
        DCW     &1E0, &A06, &A0A, &A0C, &A0E, &A10, &A12, &A14 ; 0-31
        DCW     &A16, &A18, &A1A, &A24, &5D8, &5DA, &5DC, &5DE
        DCW     &5E0, &5E2, &5E4, &5E6, &5E8, &5EA, &5EC, &5EE
        DCW     &5F0, &5F2, &5F4, &5F6, &5F8, &5FA, &A08, &A26
        DCW     &238,   -1, &07A, &07C, &07E, &080, &082, &084 ; 32-63
        DCW     &086, &088, &08A, &08C, &09E, &0A0, &0A2, &0A4
        DCW     &0A6, &0A8, &0AA, &0AC, &0B0, &0B2, &0B4, &0B6
        DCW     &0B8, &0BA, &0BC, &0BE, &0C6, &0C8, &0CA, &0CE
        DCW     &0D0, &0D2, &0D4, &0D6, &0D8, &0DA, &0DC, &0DE ; 64-95
        DCW     &0E0, &0E2, &0E4, &0E6, &0E8, &0EA, &0EC, &0EE
        DCW     &0F0, &0F2, &0F4, &0F6, &0F8, &0FA, &0FC, &0FE
        DCW     &100, &102, &104, &106, &108, &10A, &10C, &10E
        DCW     &110, &112, &114, &116, &118, &11A, &11C, &11E ; 96-127
        DCW     &120, &122, &124, &126, &128, &12A, &12C, &12E
        DCW     &134, &136, &138, &13A, &13C, &13E, &140, &142
        DCW     &144, &146, &148, &14A, &14C, &14E, &150, &152
        DCW     &154, &156, &158, &15A, &15C, &15E, &160, &162 ; 128-159
        DCW     &164, &166, &168, &16A, &16C, &16E, &170, &172
        DCW     &174, &176, &178, &17A, &17C, &17E, &180, &182
        DCW     &184, &186, &188, &18A, &18C, &18E, &190, &192
        DCW     &194, &196, &198, &19A, &19C, &19E, &1A0, &130 ; 160-191
        DCW     &1BE, &1B0, &1C6, &1C8, &1CA, &1CC, &1CE, &1D0
        DCW     &1D2, &1D4, &1D6, &1D8, &1DA, &1DC, &1DE, &1C0
        DCW     &1C2, &1C4, &1E2, &238, &1B2, &1B4, &1B6, &1B8
        ALIGN
GPIOAltsTables
        DCD     GPIOAlts0
        DCD     GPIOAlts1
        DCD     GPIOAlts2
        DCD     GPIOAlts3
        DCD     GPIOAlts4
        DCD     GPIOAlts5

; Available pins per target board
GPIOFreeToUse
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_BB * GPIO_PORT_MAX)
        DCD     2_10000000000000000000100010000000 ; BeagleBoard 
        DCD     2_00000000000000000000000000000000
        DCD     2_00000000000000000000000000000000
        DCD     2_00000000000000000000000000000000
        DCD     2_11110000011000001111111111111100
        DCD     2_00000000100000000000000100000110
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_BBxM * GPIO_PORT_MAX)
        DCD     2_10000000111111111111100000010000 ; BeagleBoard-xM
        DCD     2_00000010000000000000000000000000
        DCD     2_11000000000000000000000000000000
        DCD     2_00000000111100000111111111111111
        DCD     2_00000000011000000000111111111100
        DCD     2_00000000100000000000010110000000
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_DevKit8000 * GPIO_PORT_MAX)
        DCD     2_10000000000000000000100010000000 ; DevKit 8000
        DCD     2_00000000000000000000000000000000
        DCD     2_11000000000000000000000000000000
        DCD     2_01000000000000001111111111111111
        DCD     2_11110000111100001111111111111100
        DCD     2_00000111000000100111100010011111
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_IGEPv2 * GPIO_PORT_MAX)
        DCD     2_10000000000000000000100010001100 ; IGEPv2
        DCD     2_00000000000000000000000000000000
        DCD     2_11000000000000000000000000000000
        DCD     2_01000000000011111111111111111111
        DCD     2_11111111011000001111111111111100
        DCD     2_00000000100000001111100110000110
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_Pandora * GPIO_PORT_MAX)
        DCD     2_00000000000000000000000000000000 ; Pandora
        DCD     2_00000100000000000000000000000000
        DCD     2_10000000000000000000000000000011
        DCD     2_00000000000000000000100000000010
        DCD     2_00000000000011110000000000000000
        DCD     2_00000000000000000000010011100000
        ASSERT  (. - GPIOFreeToUse):SHR:2 = (GPIOType_Max * GPIO_PORT_MAX)

        ; Init the GPIO HAL devices
        ; a1 = BoardType value
        ; a2 = BoardRevision value
GPIO_InitDevices ROUT
        Push    "v1-v3, lr"

        ADRL    ip, GPIOTypeMap
10
        LDMIA   ip!, {a3,a4,v1}
        CMP     a3, #-1
        CMPEQ   a4, #-1
        Pull    "v1-v3, pc", EQ         ; Not in known table
        TEQ     a3, a1
        TEQEQ   a4, a2
        BNE     %BT10

        ; Copy each port's template and update the varying fields
        MOV     v3, #0
        ADRL    v2, GPIOWS
20
        MOV     a1, v2
        ADRL    a2, GPIOTemplate
        MOV     a3, #HALDevice_GPIO_Size_1_0
        BL      memcpy

        ADR     a2, GPIOFreeToUse
        MOV     a3, #GPIO_PORT_MAX:SHL:2
        MLA     a2, v1, a3, a2          ; Masks for that type
        LDR     a2, [a2, v3, LSL #2]    ; Mask for this port
        STR     a2, [a1, #WkspValidMask]

        STR     sb, [a1, #WkspCopySB]
        STR     v3, [a1, #TNumb - GPIOTemplate]

        ADR     a3, L4_GPIO_Table
        LDR     a3, [a3, v3, LSL #2]    ; Logical address of this port
        STR     a3, [a1, #TAddr - GPIOTemplate]

        ADR     a3, GPIODescriptions
        LDR     a3, [a3, v3, LSL #2]    ; Name of this port
        STR     a3, [a1, #TDesc - GPIOTemplate]

        MOV     a1, #0
        MOV     a2, v2
        CallOS  OS_AddDevice            ; Register it

        ADD     v3, v3, #1              ; Next port
        CMP     v3, #GPIO_PORT_MAX
        ADDCC   v2, v2, #Wksp_GPIO_Size
        BCC     %BT20
        
        Pull    "v1-v3, pc"

GPIOActivate
        MOV     a1, #1
GPIODeactivate
GPIOReset
        MOV     pc, lr

GPIOSleep
        MOV     a1, #0
        MOV     pc, lr

; int GPIOSetDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be set
; Return     a1 = previous value
GPIOSetDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid

        LDR     ip, [a3, #GPIO_OE]
        LDR     a1, [a3, #GPIO_DATAOUT]
        BIC     a4, a1, ip              ; State of outputs
        LDR     a1, [a3, #GPIO_DATAIN]
        AND     a1, a1, ip              ; State of inputs
        ORR     a1, a1, a4

        STRNE   a2, [a3, #GPIO_SETDATAOUT]
        MOV     pc, lr

; int GPIOClearDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be cleared
; Return     a1 = previous value
GPIOClearDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid

        LDR     ip, [a3, #GPIO_OE]
        LDR     a1, [a3, #GPIO_DATAOUT]
        BIC     a4, a1, ip              ; State of outputs
        LDR     a1, [a3, #GPIO_DATAIN]
        AND     a1, a1, ip              ; State of inputs
        ORR     a1, a1, a4

        STRNE   a2, [a3, #GPIO_CLEARDATAOUT]
        MOV     pc, lr

; void GPIOToggleDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be toggled from its current value
GPIOToggleDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid
        MOVEQ   pc, lr

        PHPSEI  ip                      ; No toggle register, emulate in software
        LDR     a1, [a3, #GPIO_DATAOUT]
        EOR     a1, a1, a2
        STR     a1, [a3, #GPIO_DATAOUT]
        PLP     ip

        MOV     pc, lr

; int GPIOReadDataBits(struct gpiodevice *)
; Enter with a1 = device struct pointer
; Return     a1 = previous value
GPIOReadDataBits ROUT
        LDR     a3, [a1, #HALDevice_Address]

        LDR     ip, [a3, #GPIO_OE]
        LDR     a1, [a3, #GPIO_DATAOUT]
        BIC     a4, a1, ip              ; State of outputs
        LDR     a1, [a3, #GPIO_DATAIN]
        AND     a1, a1, ip              ; State of inputs
        ORR     a1, a1, a4

        MOV     pc, lr

; int GPIODataDirection(struct gpiodevice *, int pins, int dir)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = direction to set the bits to (1=input 0=output)
; Return     a1 = previous data direction bits (or current if pins=0)
GPIODataDirection ROUT
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being asked are valid
        LDREQ   a3, [a1, #HALDevice_Address]
        LDREQ   a1, [a3, #GPIO_OE]
        MOVEQ   pc, lr

        Push    "v1-v5, sb, lr"

        MOV     v2, a2
        AND     v3, a4, a3

        LDR     sb, [a1, #WkspCopySB]

        LDR     v4, [a1, #TNumb - GPIOTemplate]
        LDR     v5, [a1, #HALDevice_Address] 

        MOV     v1, #0                  ; Go bitwise because CONTROL_PADCONF has input direction too
10
        MOV     lr, #1
        MOV     lr, lr, LSL v1
        TST     lr, v2
        BEQ     %FT20                   ; No change

        ADD     a1, v1, v4, LSL #5      ; Global pin number
        ANDS    a2, lr, v3
        MOVNE   a2, #1
        MOV     a3, #PADCONF_INPUTENABLE_SHIFT
        MOV     a4, #1
        BL      BitFieldInsertPadConf
20
        ADD     v1, v1, #1
        CMP     v1, #32
        BCC     %BT10

        LDR     a1, [v5, #GPIO_OE]

        PHPSEI  ip                      ; Safe read/modify/write
        BIC     a4, a1, v2
        ORR     a4, a4, v3              ; 1 = input, 0 = output
        STR     a4, [v5, #GPIO_OE]
        PLP     ip

        Pull    "v1-v5, sb, pc"

; void GPIOEdgeControl(struct gpiodevice *, int pins, int *enable, int *edge, int *risehigh)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = pointer to bits to enable detection on
;            a4 = pointer to bits set for edge mode (else level)
;        [sp+0] = pointer to bits set to detect on rising/high (else falling/low)
GPIOEdgeControl ROUT
        LDR     ip, [sp, #0]

        Push    "v1-v5, lr"
        Push    "a3-a4, ip"

        LDR     v1, [a1, #HALDevice_Address]

        LDR     a3, [a3]                ; Pick up new values
        LDR     a4, [a4]
        LDR     ip, [ip]

        PHPSEI  v2                      ; Safe read/modify/write

        LDR     v3, [v1, #GPIO_RISINGDETECT]
        LDR     a1, [v1, #GPIO_FALLINGDETECT]
        MOV     v5, v3                  ; rising = rising
        ORR     v4, v3, a1              ; OR(rising,falling) = edge
        ORR     v3, v3, a1              ; OR(rising,falling) = edge enable
        LDR     lr, [v1, #GPIO_LEVELDETECT1]
        LDR     a1, [v1, #GPIO_LEVELDETECT0]
        ORR     v5, v5, lr              ; OR(rising,high) = rising/high
        ORR     a1, a1, lr
        ORR     v3, v3, a1              ; OR(edge enable,OR(high,low)) = enable
        TEQ     a2, #0
        BEQ     %FT10

        LDR     a1, [v1, #GPIO_RISINGDETECT]
        BIC     a1, a1, a2              ; disable by default
        AND     lr, a3, a4
        AND     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,edge,rising) = rising
        STR     a1, [v1, #GPIO_RISINGDETECT]

        LDR     a1, [v1, #GPIO_FALLINGDETECT]
        BIC     a1, a1, a2              ; disable by default
        AND     lr, a3, a4
        BIC     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,edge,NOT(rising)) = falling
        STR     a1, [v1, #GPIO_FALLINGDETECT]

        LDR     a1, [v1, #GPIO_LEVELDETECT1]
        BIC     a1, a1, a2              ; disable by default
        BIC     lr, a3, a4
        AND     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,NOT(edge),rising) = high
        STR     a1, [v1, #GPIO_LEVELDETECT1]

        LDR     a1, [v1, #GPIO_LEVELDETECT0]
        BIC     a1, a1, a2              ; disable by default
        BIC     lr, a3, a4
        BIC     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,NOT(edge),NOT(rising)) = low
        STR     a1, [v1, #GPIO_LEVELDETECT0]
10
        PLP     v2

        Pull    "a3-a4, ip"
        STR     v3, [a3]                ; Write out previous values
        STR     v4, [a4]
        STR     v5, [ip]

        Pull    "v1-v5, pc"
 
; int GPIOEdgePollStatus(struct gpiodevice *, int collect)
; Enter with a1 = device struct pointer
;            a2 = clear these bits having polled the status
; Return     a1 = states latched in edge/level since last poll
GPIOEdgePollStatus ROUT
        LDR     a3, [a1, #HALDevice_Address]
        LDR     a4, [a1, #WkspValidMask]
        ANDS    a2, a4, a2              ; Ensure bits being cleared are valid
        LDR     a1, [a3, #GPIO_IRQSTATUS1]
        STRNE   a2, [a3, #GPIO_IRQSTATUS1]
        MOV     pc, lr

; enum HAL_GPIOReadMode(struct gpiodevice *, int pin)
; Enter with a1 = device struct pointer
;            a2 = pin (singular) to read
; Return     a1 = current mode
GPIOReadMode ROUT
        MOV     a3, #-1
        ; Fall through

; enum GPIOWriteMode(struct gpiodevice *, int pin, enum useage)
; Enter with a1 = device struct pointer
;            a2 = pin (singular) to change
;            a3 = new mode (opaque value from Enumerate)
; Return     a1 = previous mode
GPIOWriteMode      
        Push    "sb, lr"

        LDR     sb, [a1, #WkspCopySB]

        LDR     a4, [a1, #TNumb - GPIOTemplate]
        ADD     a1, a2, a4, LSL #5      ; Global pin number
        MOV     a2, a3
        MOV     a3, #PADCONF_MUXMODE_SHIFT
        MOV     a4, #PADCONF_MUXMODE_BITS
        BL      BitFieldInsertPadConf
        ASSERT  PADCONF_MUXMODE_SHIFT = 0

        Pull    "sb, pc"

; int GPIOPullControl(struct gpiodevice *, int pins, int enable)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = pull resistor enables for those pins
; Return     a1 = previous pull enable bits (or current if pins=0)
GPIOPullControl ROUT
        Push    "v1-v5, sb, lr"

        LDR     v5, [a1, #TNumb - GPIOTemplate]
        LDR     a4, [a1, #WkspValidMask]
        AND     v3, a4, a3
        AND     v2, a4, a2

        LDR     sb, [a1, #WkspCopySB]

        MOV     v4, #0                  ; Previous values
        MOV     v1, #0                  ; For each pin
10
        ADD     a1, v1, v5, LSL #5      ; Global pin number
        MOV     lr, #1
        MOV     lr, lr, LSL v1
        ANDS    a2, lr, v3
        MOVNE   a2, #1
        TST     v2, lr
        MOVEQ   a2, #-1                 ; No change
        MOV     a3, #PADCONF_PULLUDENABLE_SHIFT
        MOV     a4, #1
        BL      BitFieldInsertPadConf
        TEQ     a1, #0
        ORRNE   v4, v4, #1:SHL:31       ; Was previously set

        ADD     v1, v1, #1              ; Next pin
        CMP     v1, #32
        MOVCC   v4, v4, LSR #1
        BCC     %BT10

        MOV     a1, v4

        Pull    "v1-v5, sb, pc"

; int GPIOPullDirection(struct gpiodevice *, int pins, int up)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = bits to set as pull up else pull down
; Return     a1 = previous pull direction bits (or current if pins=0)
GPIOPullDirection ROUT 
        Push    "v1-v5, sb, lr"

        LDR     v5, [a1, #TNumb - GPIOTemplate]
        LDR     a4, [a1, #WkspValidMask]
        AND     v3, a4, a3
        AND     v2, a4, a2

        LDR     sb, [a1, #WkspCopySB]

        MOV     v4, #0                  ; Previous values
        MOV     v1, #0                  ; For each pin
10
        ADD     a1, v1, v5, LSL #5      ; Global pin number
        MOV     lr, #1
        MOV     lr, lr, LSL v1
        ANDS    a2, lr, v3
        MOVNE   a2, #1
        TST     v2, lr
        MOVEQ   a2, #-1                 ; No change
        MOV     a3, #PADCONF_PULLTYPESELECT_SHIFT
        MOV     a4, #1
        BL      BitFieldInsertPadConf
        TEQ     a1, #0
        ORRNE   v4, v4, #1:SHL:31       ; Was previously set

        ADD     v1, v1, #1              ; Next pin
        CMP     v1, #32
        MOVCC   v4, v4, LSR #1
        BCC     %BT10

        MOV     a1, v4

        Pull    "v1-v5, sb, pc"

; int BitFieldInsertPadConf(int pin, int value, int lsb, int width)
; Enter with a1 = flattened pin number
;            a2 = new value for bit(s), or -1 to read
;            a3 = leftmost bit position
;            a4 = bit width
;            sb = HAL workspace
; Return     a1 = old value for bit(s)
BitFieldInsertPadConf ROUT
        Push   "v1, lr"

        MOV     v1, #1
        MOV     v1, v1, LSL a4
        SUB     v1, v1, #1              ; Mask of bits to change
        CMP     a2, #-1
        ANDNE   a2, a2, v1              ; Sanitised input value

        ADRL    lr, GPIOPadConfs        ; Array of half words
        ADD     lr, lr, a1, LSL #1
        LDRSH   lr, [lr]                ; Offset from L4_Control
        CMP     lr, #-1
        Pull    "v1, pc", EQ            ; Missing PADCONF register
       
        LDR     a1, L4_Core_Log
        ADD     a1, a1, #L4_Control-L4_Core
        ADD     lr, a1, lr

        PHPSEI  ip                      ; Safe read/modify/write
        LDRH    a1, [lr]                ; 7.6.2 "All module registers are 8-, 16-, or 32-bit accessible"
        CMP     a2, #-1
        BICNE   a4, a1, v1, LSL a3
        ORRNE   a4, a4, a2, LSL a3
        STRNEH  a4, [lr]
        PLP     ip

        MOV     a1, a1, LSR a3
        AND     a1, a1, v1

        Pull    "v1, pc"

; struct onepin *GPIOEnumerate(struct gpiodevice *, int *carryon)
; Enter with a1 = device struct pointer
;            a2 = pointer to continuation value (0 to start)
; Return     a1 = pointer to pin info for one more pin
;            continuation value updated (-1 if no more)
GPIOEnumerate
        Push    "v1-v3, lr"

        LDR     v1, [a1, #WkspValidMask]
        LDR     a1, [a1, #TNumb - GPIOTemplate]

        LDR     a3, [a2]                ; Just use the continuation value as a bit position
        CMP     a3, #32
        BCS     %FT60                   ; Out of bounds

        CMP     a3, #0
        BNE     %FT20                   ; Not the start condition

        MOVS    ip, v1
        BEQ     %FT60                   ; No valid pins
10
        ; Find first set
        MOVS    ip, ip, LSR #1          
        ADDCC   a3, a3, #1
        BCC     %BT10
20
        MOV     ip, #1
        TST     v1, ip, LSL a3
        BEQ     %FT60                   ; Invalid on this target

        ADRL    v2, GPIOAltsTables
        LDR     v2, [v2, a1, LSL #2]    ; Start of pin data
        MOV     v3, #0
30
        LDR     ip, [v2], #4            ; Fetch & skip private word
        CMP     ip, #-1
        BEQ     %FT60                   ; Reached table end

        TEQ     v3, a3
        MOVEQ   a1, v2
        BEQ     %FT40

        ; Jump to next item
        ADD     v2, v2, #GPIOEnumerate_GroupList
        ADD     ip, ip, #1              ; List terminator is one entry
        ASSERT  GPIOGroupList_Size = 4
        ADD     v2, v2, ip, LSL #2      ; Account for list entries
        ADD     v3, v3, #1              ; Next pin
        B       %BT30
40
        ; Find next set
        ADD     v3, v3, #1
        CMP     v3, #32
        MOVNES  v1, v1, LSR v3
        BEQ     %FT70
50
        MOVS    v1, v1, LSR #1
        ADDCC   v3, v3, #1
        BCC     %BT50

        STR     v3, [a2]

        Pull    "v1-v3, pc"
60
        MOV     a1, #0                  ; Nothing found
70
        MOV     ip, #-1                 ; Continuation value set for last one
        STR     ip, [a2]

        Pull    "v1-v3, pc"

        GET     hdr.GPIOPadConf

        END
@


1.13
log
@Add GPIO device implementation
Update to API 1.0, and corresponding set of register wide accessor functions.
The tables of permitted pins come from staring at the schematics for any connectors, minus those that are "owned" by the OS.
In the absence of any Touchbook schematics, no GPIO device will be registered for this (given the physical size of the Touchbook it's unlikely there are any usefully accessible headers anyway).

Tested on a BB-xM, toggling the two user LEDs and scanning the 'USER' push button.

Version 1.18. Tagged as 'OMAP3-1_18'
@
text
@d47 1
a47 1
        MOV     a2, #6
d434 1
a434 1
        ; Init the GPIO HAL device
@


1.12
log
@Make type and revision private
Adopt the board type and revision enum privately in board.hdr (mass search & replace exercise).
Don't re-export it via a stub GPIO device; it's private.

Version 1.16. Tagged as 'OMAP3-1_16'
@
text
@d37 1
a37 1
        EXPORT  GPIO_InitDevice
d253 181
d435 262
a696 3
        ; a1 = GPIOType value
        ; a2 = GPIORevision value
GPIO_InitDevice
d699 220
a919 1
       @


1.11
log
@Turn off debug
Anyone using the serial port for other peripheral uses might get confused if some HAL debug comes out on it.
Move the IMPORTs into a header so we don't end up with lots of unresolved symbols with Debug {FALSE}.
Rename a couple of symbols in PAudio missed in OMAP3-1_03.
Built, but not tested.


Version 1.04. Tagged as 'OMAP3-1_04'
@
text
@a256 45
        Push    "a1-a2,lr"
        ADRL    a1, GPIOWS
        ADR     a2, GPIOTemplate
        MOV     a3, #HALDeviceSize
        BL      memcpy
        Pull    "a1-a2,lr"
        ADRL    a3, GPIOWS
        STR     a1, [a3, #HALDevice_GPIOType]
        STR     a2, [a3, #HALDevice_GPIORevision]
        MOV     a2, a3
        MOV     a1, #0
        LDR     pc, OSentries + 4*OS_AddDevice ; Tail call

; Generic HAL device used for all board types
GPIOTemplate
        DCW     HALDeviceType_Comms + HALDeviceComms_GPIO
        DCW     HALDeviceID_GPIO_OMAP3
        DCD     HALDeviceBus_Peri + HALDevicePeriBus_Sonics3220
        DCD     0               ; API version
        DCD     GPIODesc        ; Description
        DCD     0               ; Address (none)
        %       12              ; Reserved
        DCD     GPIOActivate
        DCD     GPIODeactivate
        DCD     GPIOReset
        DCD     GPIOSleep
        DCD     -1              ; Device (none)
        DCD     0               ; TestIRQ
        DCD     0               ; ClearIRQ
        %       4
        ASSERT  (.-GPIOTemplate) = HALDeviceSize

GPIODesc
        =       "OMAP3 GPIO interface", 0
        ALIGN

        ; These don't do much
GPIOActivate
        MOV     a1, #1
GPIODeactivate
GPIOReset
        MOV     pc, lr

GPIOSleep
        MOV     a1, #0
@


1.10
log
@Change over to reassigned bus types

Version 1.00. Tagged as 'OMAP3-1_00'
@
text
@a40 2
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
@


1.9
log
@Add new support for the new GPIO HAL device
Detail:
  hdr/board - Add information about determining the IGEP board revision
  hdr/StaticWS - Add workspace for storing the GPIO HAL device
  s/board - Update BeagleBoard entry to have a custom HAL device init func
  s/Boot - Fix HAL_Init to not configure GPIOs 171-173 if not running on a beagleboard. Update HAL_InitDevices to preserve the right registers and initialise the GPIO devices where appropriate.
  s/GPIO - Added GPIO_InitDevice function to do the actual initialisation
Admin:
  Tested on rev A2 BB-xM


Version 0.48. Tagged as 'OMAP3-0_48'
@
text
@d276 1
a276 1
        DCD     HALDeviceBus_Interconnect + HALDeviceInterconnectBus_L4
@


1.8
log
@Fix broken GPIO initialisation code
Detail:
  s/GPIO - GPIO_Init was broken and causing (silent) data aborts instead of clearing the GPIO module IRQ enable flags.
Admin:
  Tested on rev A2 BB-xM.
  Fixes issue reported by Willi Theiss.


Version 0.47. Tagged as 'OMAP3-0_47'
@
text
@d37 1
d43 1
d254 52
a305 1
        
@


1.7
log
@Be more thorough in GPIO initialisation
Detail:
  s/GPIO - The OMAP HAL now takes steps to make sure that the TPS GPIO controller is enabled, and that any GPIO-LEDs have the correct PWM settings. The TPS GPIO pull up/down settings are also initialised for the beagleboard.
Admin:
  Tested on rev C2 BB, A2 BB-xM, C BB-xM, C1 TouchBook


Version 0.45. Tagged as 'OMAP3-0_45'
@
text
@d46 1
a46 1
        LDR     a1, L4_GPIO_Table
@


1.6
log
@Miscellaneous OMAP3 HAL improvements
Detail:
  hdr/board, s/board, s/Boot - Linux machine IDs are now defined via constants in hdr/board instead of magic numbers on a per-use basis
  s/Boot - Added video fix for BB-xM rev A3.
  s/Boot - Added code to enable tablet battery charging on TouchBook.
  s/Boot - Added support for power-off on TouchBook
  s/GPIO - Fixed bug in GPIOx_SetAsOutput that would prevent LEDs from being disabled properly
  s/I2C - Updated code to ignore BF interrupts. Added debugging code to help track down unexpected errors, and to check that IIC_DoOp_Poll is being called with interrupts disabled.
  s/SDMA - Call HAL_IRQClear when resetting the DMA controller device. This fixes the "previous IRQ not cleared" loop that would occur during RISC OS's pre-reset sequence
Admin:
  Tested on rev C2 beagleboard, C1 touchbook, A3 BBxM.
  Resets should now work reliably on all machines, except TouchBook, which still seems to hang. But on the bright side, the TouchBook is currently the only machine to support soft-off.


Version 0.33. Tagged as 'OMAP3-0_33'
@
text
@d44 2
a45 1
        ; Don't bother resetting the controllers for now, just make sure no IRQs are enabled
d54 35
a88 1
        MOV     pc, lr
d133 29
a174 4
        LDR     v1, HALInitialised
        CMP     v1, #0
        ADREQL  v1, IIC_DoOp_Poll
        LDRNE   v1, OSentries+4*OS_IICOpV
d184 3
@


1.5
log
@BeagleBoard-xM, TouchBook fixes
Detail:
  s/board, hdr/board, hdr/omap3530, hdr/UART - Add support for 4th UART available on AM/DM37x (i.e. BeagleBoard-xM)
  hdr/omap3530 - Add details of CONTROL_IDCODE register & known hawkeye/revision numbers for OMAP type/revision detection
  s/Boot, s/GPIO, hdr/GPIO, s/I2C, hdr/StaticWS - Allow TPS LED drivers to be used as (output-only) GPIOs. Add new polled I/O I2C function, and appropriate logic to make GPIO code use it instead of RISCOS_IICOpV if RISC OS hasn't finished initialising yet. Add code to initialise some extra BB/TB GPIOs on boot.
  s/Timers, hdr/Timers - Stop RISC OS from using GPTIMER9, because it's used to drive the screen backlight on the TouchBook
  s/Video - Use appropriate porch/sync limits on non-OMAP35x
  s/PRCM - Don't mess with the system clock divider when calculating system clock speed (AM/DM37x fix)
Admin:
  Tested on rev C2 beagleboard, rev A2 BB-xM (indirectly), rev C1 TouchBook


Version 0.32. Tagged as 'OMAP3-0_32'
@
text
@d103 2
a104 1
        MOVS    v2, a2 ; a2!=0, don't set any bits
@


1.4
log
@Fix OMAP HAL GPIO/NIC setup code
Detail:
  s/GPIO - Fixed use of invalid 'MSR <psr>,<rn>,<shift>' instruction in GPIOx_SetAndEnableIRQ. Fixed PSR flags that are used to calculate LEVELDETECT0 value.
  s/NIC - Fixed NICActivate to load NICGPIO_Mode before the HAL device ptr gets clobbered
Admin:
  Tested on rev C2 beagleboard, using IGEP config. NICActivate now appears to configure the GPIO controller properly.


Version 0.26. Tagged as 'OMAP3-0_26'
@
text
@d39 3
d55 1
a55 1
        ; a1 = GPIO # (OMAP or TPS)
d67 2
d74 5
a78 1
        LDR     v1, OSentries+4*OS_IICOpV
d97 25
d144 5
a148 1
        LDR     v1, OSentries+4*OS_IICOpV
@


1.3
log
@Add basic GPIO init code to OMAP HAL
Detail:
  s/Boot, s/GPIO - Added some basic GPIO init code, to make sure there aren't any unexpected GPIO IRQs active
Admin:
  Tested on rev C2 beagleboard.


Version 0.25. Tagged as 'OMAP3-0_25'
@
text
@d126 2
a127 1
        MSR     CPSR_f, a2, LSL #28 ; load into NZCV flags (MI EQ CS VS condition codes)
d143 1
a143 1
        ORRCS   a2, a2, a4
@


1.2
log
@Add basic GPMC setup code and NIC HAL devices to OMAP HAL
Detail:
  s/GPMC, hdr/GPMC, hdr/StaticWS - basic code to reset the GPMC and configure chip selects
  s/NIC, hdr/NIC, hdr/StaticWS - code to expose any onboard NICs (SMSC9221, DM9000) to RISC OS as simple HAL devices.
  Makefile - added GPMC & NIC source files
  s/board, hdr/board - Expanded board config struct to include a pointer to extra code to call at the end of HAL_InitDevices, to allow board-specific devices to be initialised
  s/boot - Extra HAL_InitDevices code to set up the NICs on the IGEP/DevKit
  s/GPIO, hdr/GPIO - Improved functionality to allow GPIO IRQs to be used
  s/SDMA, s/Video - Tweaked the HAL device descriptors to indicate that the devices are on the L3 interconnect
Admin:
  Tested on rev C2 beagleboard. IGEP/DevKit entry points booted OK, but no attempts were made to look for or interact with the new HAL devices!


Version 0.24. Tagged as 'OMAP3-0_24'
@
text
@d33 1
d40 12
@


1.1
log
@Update OMAP HAL to support different board configs, plus use new YearLOIsGood flag to ensure correct RTC handling, plus other misc tidying
Detail:
  The OMAP HAL now has multiple entry points, one per board config. See Top.s/board.s for more info.
  audio.s - Moved APLL_CTL value to board config
  board.s - New file to list all the settings for the different board configs
  boot.s - Change HAL_Init to deal with the new board config stuff
  debug.s - Debug UART now specified in board config
  GPIO.s - A few utility functions for handling OMAP/TPS GPIO pins
  I2C.s - Update to use new board config struct
  RAM.s - Disable the beagleboard-specific RAM init code. Instead we'll just rely on u-boot to initialise all our RAM for us.
  RTC.s - Get rid of the magic numbers, and use the YearLOIsGood flag to indicate to RISC OS that YearLO is 2-digit BCD
  Top.s - Got rid of old debug code and rewrote initial flow to handle detecting & storing the board config
  UART.s - Update to use board config struct, support multiple UARTs
  USB.s - Get EHCI PHY power GPIO from board config
  Video.s - Get DVI framer power GPIO and max pixel rate from board config. Add 'PassiveVideo' option, to build a driver that doesn't alter the video output settings - should hopefully result in a usable display on Touch Book, etc.
  board.hdr - Definition of board config table struct
  GPIO.hdr - Add lots of macros for handling OMAP GPIO pins, new constants for OMAP/TPS GPIO
  I2C.hdr - Added I2C transfer block struct, HAL I2C API transfer states (both moved here from other source files)
  omap3530.hdr - Move/remove some unwanted constants, disable DebugChar for now
  StaticWS.hdr - Move I2C transfer block struct to I2C.hdr, add board config struct to HAL workspace, get rid of unused 64K AllocArea
  Timers.hdr - Tidy up constants a bit
  UART.hdr - Add UARTCLK (moved from StaticWS.hdr), UART IRQ #'s
  Makefile - add GPIO.s
Admin:
  Tested on rev C2 beagleboard. Board configs for other board types may be inaccurate in a couple of places.


Version 0.19. Tagged as 'OMAP3-0_19'
@
text
@d35 1
d102 35
@


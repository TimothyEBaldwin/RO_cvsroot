head	1.7;
access;
symbols
	OMAP3-1_18:1.7
	OMAP3-1_17:1.6
	OMAP3-1_16:1.6
	OMAP3-1_15:1.6
	OMAP3-1_14:1.6
	SMP:1.6.0.2
	SMP_bp:1.6
	OMAP3-1_13:1.6
	OMAP3-1_12:1.6
	OMAP3-1_11:1.6
	OMAP3-1_10:1.6
	OMAP3-1_09:1.6
	OMAP3-1_08:1.6
	OMAP3-1_07:1.6
	OMAP3-1_06:1.6
	OMAP3-1_05:1.6
	OMAP3-1_04:1.6
	OMAP3-1_03:1.6
	OMAP3-1_02:1.6
	OMAP3-1_01:1.6
	OMAP3-1_00:1.6
	OMAP3-0_99:1.6
	OMAP3-0_98:1.6
	OMAP3-0_97:1.6
	OMAP3-0_96:1.6
	OMAP3-0_95:1.6
	OMAP3-0_94:1.6
	OMAP3-0_93:1.6
	OMAP3-0_92:1.6
	OMAP3-0_91:1.6
	OMAP3-0_90:1.6
	OMAP3-0_89:1.6
	OMAP3-0_88:1.6
	OMAP3-0_87:1.6
	OMAP3-0_86:1.6
	OMAP3-0_85:1.6
	OMAP3-0_84:1.6
	OMAP3-0_83:1.6
	OMAP3-0_82:1.6
	OMAP3-0_81:1.6
	OMAP3-0_80:1.6
	OMAP3-0_79:1.6
	OMAP3-0_78:1.6
	OMAP3-0_77:1.6
	OMAP3-0_76:1.6
	OMAP3-0_75:1.6
	OMAP3-0_74:1.6
	OMAP3-0_73:1.6
	OMAP3-0_72:1.6
	OMAP3-0_71:1.6
	OMAP3-0_70:1.6
	OMAP3-0_69:1.6
	OMAP3-0_68:1.6
	OMAP3-0_67:1.6
	OMAP3-0_66:1.6
	OMAP3-0_65:1.6
	OMAP3-0_64:1.6
	OMAP3-0_63:1.6
	OMAP3-0_62:1.6
	OMAP3-0_61:1.5
	OMAP3-0_60:1.4
	OMAP3-0_59:1.4
	OMAP3-0_58:1.4
	OMAP3-0_57:1.4
	OMAP3-0_56:1.4
	OMAP3-0_55:1.4
	OMAP3-0_54:1.4
	OMAP3-0_53:1.4
	OMAP3-0_52:1.4
	OMAP3-0_51:1.4
	OMAP3-0_50:1.4
	OMAP3-0_49:1.4
	OMAP3-0_48:1.4
	OMAP3-0_47:1.4
	OMAP3-0_46:1.4
	OMAP3-0_45:1.4
	OMAP3-0_44:1.4
	OMAP3-0_43:1.4
	OMAP3-0_42:1.4
	OMAP3-0_41:1.4
	OMAP3-0_40:1.4
	OMAP3-0_39:1.4
	OMAP3-0_38:1.4
	OMAP3-0_37:1.4
	OMAP3-0_36:1.4
	OMAP3-0_35:1.4
	OMAP3-0_34:1.4
	OMAP3-0_33:1.4
	OMAP3-0_32:1.4
	OMAP3-0_31:1.3
	OMAP3-0_30:1.3
	OMAP3-0_29:1.3
	OMAP3-0_28:1.3
	OMAP3-0_27:1.3
	OMAP3-0_26:1.3
	OMAP3-0_25:1.3
	OMAP3-0_24:1.3
	OMAP3-0_23:1.2
	OMAP3-0_22:1.2
	OMAP3-0_21:1.2
	OMAP3-0_20:1.2
	OMAP3-0_19:1.2
	OMAP3-0_18:1.1
	OMAP3-0_17:1.1
	OMAP3-0_16:1.1
	OMAP3-0_15:1.1
	OMAP3-0_14:1.1
	OMAP3-0_13:1.1
	OMAP3-0_12:1.1
	OMAP3-0_11:1.1
	OMAP3-0_10:1.1
	OMAP3-0_09:1.1
	OMAP3-0_08:1.1
	OMAP3-0_07:1.1
	OMAP3-0_06:1.1
	OMAP3-0_05:1.1
	OMAP3-0_04:1.1;
locks; strict;
comment	@# @;


1.7
date	2018.04.01.21.23.01;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	0gqrh5c5mI0fFMwA;

1.6
date	2012.04.08.22.37.50;	author jlee;	state Exp;
branches;
next	1.5;
commitid	3W6tvBOo1ezoh70w;

1.5
date	2012.03.25.11.49.02;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	c99VvmwezV2J8gYv;

1.4
date	2010.09.14.20.58.47;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.20.01.07.06;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.24.02.49.28;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.08.22.25.08;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Add GPIO device implementation
Update to API 1.0, and corresponding set of register wide accessor functions.
The tables of permitted pins come from staring at the schematics for any connectors, minus those that are "owned" by the OS.
In the absence of any Touchbook schematics, no GPIO device will be registered for this (given the physical size of the Touchbook it's unlikely there are any usefully accessible headers anyway).

Tested on a BB-xM, toggling the two user LEDs and scanning the 'USER' push button.

Version 1.18. Tagged as 'OMAP3-1_18'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

; GPIO registers - relative to L4_GPIO1, L4_GPIO2, L4_GPIO3, etc.

GPIO_REVISION           * &000
GPIO_SYSCONFIG          * &010
GPIO_SYSTATUS           * &014
GPIO_IRQSTATUS1         * &018
GPIO_IRQENABLE1         * &01C
GPIO_WAKEUPENABLE       * &020
GPIO_IRQSTATUS2         * &028
GPIO_IRQENABLE2         * &02C
GPIO_CTRL               * &030
GPIO_OE                 * &034
GPIO_DATAIN             * &038
GPIO_DATAOUT            * &03C
GPIO_LEVELDETECT0       * &040
GPIO_LEVELDETECT1       * &044
GPIO_RISINGDETECT       * &048
GPIO_FALLINGDETECT      * &04C
GPIO_DEBOUNCEENABLE     * &050
GPIO_DEBOUNCETIME       * &054
GPIO_CLEARIRQENABLE1    * &060
GPIO_SETIRQENABLE1      * &064
GPIO_CLEARIRQENABLE2    * &070
GPIO_SETIRQENABLE2      * &074
GPIO_CLEARWKUENA        * &080
GPIO_SETWKUENA          * &084
GPIO_CLEARDATAOUT       * &090
GPIO_SETDATAOUT         * &094


GPIO_PORT_MAX           * 6
GPIO_PIN_MAX            * (32 * GPIO_PORT_MAX)

; Flags for GPIOx_SetAndEnableIRQ
GPIO_LEVELDETECT0_FLAG  * 1
GPIO_LEVELDETECT1_FLAG  * 2
GPIO_RISINGDETECT_FLAG  * 4
GPIO_FALLINGDETECT_FLAG * 8

; TWL/TPS GPIO registers
TPS_GPIODATAIN1         * &98 ; *3
TPS_GPIODATADIR1        * &9B ; *3
TPS_GPIODATAOUT1        * &9E ; *3
TPS_CLEARGPIODATAOUT1   * &A1 ; *3
TPS_SETGPIODATAOUT1     * &A4 ; *3
TPS_GPIO_DEBEN1         * &A7 ; *3
TPS_GPIO_CTRL           * &AA
TPS_GPIOPUPCTR1         * &AB ; *5
TPS_GPIO_ISR1A          * &B1 ; *3
TPS_GPIO_IMR1A          * &B4 ; *3
TPS_GPIO_ISR1B          * &B7 ; *3
TPS_GPIO_IMR1B          * &BA ; *3
TPS_GPIO_EDR1           * &C0 ; *5
TPS_GPIO_SIH_CTRL       * &C5
TPS_PMBR1               * &92
TPS_PMBR2               * &93
TPS_GPPUPDCTR1          * &94
                          
TPSGPIO_IIC             * &49
                          
TPS_GPIO_PIN_MAX        * 17

; TWL/TPS LED registers
; (we treat these as extra output-only GPIOs, like Linux)
TPS_LEDEN               * &EE
TPS_PWMAON              * &EF
TPS_PWMAOFF             * &F0
TPS_PWMBON              * &F1
TPS_PWMBOFF             * &F2
                        
TPSLED_IIC              * &4A
                        
TPS_LED_PIN_MAX         * 2

; OMAP GPIO related macros
; All assume sb = HAL workspace

        ; Prepare for GPIO operations (constant pin)
        ; In:
        ;   $num = constant GPIO pin number
        ;   $cc = condition code
        ; Out:
        ;   $regs = GPIO register block ptr
        ;   $mask = bit mask for pin
        MACRO
        GPIO_PrepareC $regs, $mask, $num, $cc
        ASSERT  $regs <> $mask
        ASSERT  $num < GPIO_PIN_MAX
        LDR$cc  $regs, L4_GPIO_Table+4*($num>>5)
        MOV$cc  $mask, #1 :SHL: ($num :AND: 31)
        MEND
 
        ; Prepare for GPIO operations (register pin)
        ; In:
        ;   $num = register containing GPIO pin number
        ;   $cc = condition code
        ;   $tmp = optional temp register to avoid clobbering $num
        ; Out:
        ;   $regs = GPIO register block ptr
        ;   $mask = bit mask for pin
        ;   $num corrupted, unless $tmp specified
        MACRO
        GPIO_PrepareR $regs, $mask, $num, $cc, $tmp
        ASSERT  $regs <> $mask
  [ "$tmp" = ""
        ASSERT  $mask <> $num
   [ $regs = $num
        EOR$cc  $num, $num, #31
        MOV$cc  $mask, #&80000000
        MOV$cc  $mask, $mask, ROR $num
        MOV$cc  $regs, $num, LSR #5
        ADD$cc  $regs, sb, $regs, LSL #2
        LDR$cc  $regs, [$regs, #:INDEX:L4_GPIO_Table]
   |
        ; Slightly better instruction ordering
        MOV$cc  $regs, $num, LSR #5
        EOR$cc  $num, $num, #31
        ADD$cc  $regs, sb, $regs, LSL #2
        MOV$cc  $mask, #&80000000
        LDR$cc  $regs, [$regs, #:INDEX:L4_GPIO_Table]
        MOV$cc  $mask, $mask, ROR $num
   ]
  |
        ASSERT  $mask <> $tmp
        ASSERT  $regs <> $tmp
        ASSERT  $num <> $tmp ; no point using $tmp if the two are the same!
        ASSERT  $regs <> $num
        MOV$cc  $regs, $num, LSR #5
        EOR$cc  $tmp, $num, #31
        ADD$cc  $regs, sb, $regs, LSL #2
        MOV$cc  $mask, #&80000000
        LDR$cc  $regs, [$regs, #:INDEX:L4_GPIO_Table]
        MOV$cc  $mask, $mask, ROR $num
  ]
        MEND
 
        ; Set pin for output
        MACRO
        GPIO_SetAsOutput $regs, $mask, $temp, $cc
        ASSERT  $regs <> $temp
        ASSERT  $mask <> $temp
        LDR$cc  $temp, [$regs, #GPIO_OE]
        BIC$cc  $temp, $temp, $mask
        STR$cc  $temp, [$regs, #GPIO_OE]
        MEND
 
        ; Set pin for input
        MACRO
        GPIO_SetAsInput $regs, $mask, $temp, $cc
        ASSERT  $regs <> $temp
        ASSERT  $mask <> $temp
        LDR$cc  $temp, [$regs, #GPIO_OE]
        ORR$cc  $temp, $temp, $mask
        STR$cc  $temp, [$regs, #GPIO_OE]
        MEND
 
        ; Set output to 0
        MACRO
        GPIO_SetOutput0 $regs, $mask, $cc
        STR$cc  $mask, [$regs, #GPIO_CLEARDATAOUT]
        MEND
 
        ; Set output to 1
        MACRO
        GPIO_SetOutput1 $regs, $mask, $cc
        STR$cc  $mask, [$regs, #GPIO_SETDATAOUT]
        MEND
 
        ; Set output 0/1
        ; In:
        ;  $val = zero, or non-zero
        MACRO
        GPIO_SetOutput $val, $regs, $mask
        TEQ     $val, #0
        STRNE   $mask, [$regs, #GPIO_SETDATAOUT]
        STREQ   $mask, [$regs, #GPIO_CLEARDATAOUT]
        MEND
 
        ; Get input value
        ; Out:
        ;  $val = zero, or non-zero
        MACRO
        GPIO_GetInput $val, $regs, $mask, $cc 
        ASSERT  $mask <> $val
        LDR$cc  $val, [$regs, #GPIO_DATAIN]
        AND$cc  $val, $val, $mask
        MEND
 
        ; Get GPIO IRQ # (constant pin)
        MACRO
        GPIO_GetIRQC $irq, $pin, $cc
        MOV$cc  $irq, #($pin>>5)+29
        MEND
 
        ; Get GPIO IRQ # (register pin)
        MACRO
        GPIO_GetIRQR $irq, $pin, $cc
        MOV$cc  $irq, $pin, LSR #5
        ADD$cc  $irq, $irq, #29
        MEND
 
        ; Get GPIO IRQ # (as DCD)
        ; In:
        ;   $shared = "shared" to set bit 31
        MACRO
        GPIO_GetIRQD $pin, $shared
  [ $shared = "shared"
        DCD      ($pin>>5)+29+(1<<31)
  |
        ASSERT   $shared = ""
        DCD      ($pin>>5)+29
  ]
        MEND


        END
@


1.6
log
@Add AM/DM37x SmartReflex driver
Detail:
  s/SR37x, hdr/SR37x - New files containing SmartReflex driver targeting AM/DM37x chips. Initialises SmartReflex for both VDD1 & VDD2, but currently only VDD1/DPLL1 settings can be adjusted at runtime (via CPUClk HAL device)
  Makefile - Add SR37x to object list
  hdr/CPUClk - Adjust OPPTbl_Max so CPUClk workspace size is >= SR37x workspace size (both drivers share their HAL workspace, since only one can be active at once)
  hdr/GPIO - Add TPS_GPPUPDCTR1 definition
  hdr/PRCM - Add SmartReflex related registers
  hdr/omap3530 - Add "control device status" register & extra AM/DM37x revision numbers
  s/CPUClk:
  - Modify CPUClk_PreInit to try initialising the SmartReflex driver.
  - Ensure SmartReflex is disabled in the TPS if using CPUClk driver.
  - Fix 'OPP60' typo in AMDM37x table.
  - Move DPLL adjustment code into its own function to allow it to be shared with SmartReflex driver.
  - Add a few ROUTs and ASSERTs for safety.
Admin:
  Both new & old CPUClk devices tested on BB-xM


Version 0.62. Tagged as 'OMAP3-0_62'
@
text
@d46 2
a47 1
GPIO_PIN_MAX            * 192
@


1.5
log
@Line some things up.
To help OMAP4 tracking changes a number of the changes were purely cosmetic lining up differences, this change is where OMAP3 wasn't on a conventional column layout.

Version 0.61. Tagged as 'OMAP3-0_61'
@
text
@d71 1
@


1.4
log
@BeagleBoard-xM, TouchBook fixes
Detail:
  s/board, hdr/board, hdr/omap3530, hdr/UART - Add support for 4th UART available on AM/DM37x (i.e. BeagleBoard-xM)
  hdr/omap3530 - Add details of CONTROL_IDCODE register & known hawkeye/revision numbers for OMAP type/revision detection
  s/Boot, s/GPIO, hdr/GPIO, s/I2C, hdr/StaticWS - Allow TPS LED drivers to be used as (output-only) GPIOs. Add new polled I/O I2C function, and appropriate logic to make GPIO code use it instead of RISCOS_IICOpV if RISC OS hasn't finished initialising yet. Add code to initialise some extra BB/TB GPIOs on boot.
  s/Timers, hdr/Timers - Stop RISC OS from using GPTIMER9, because it's used to drive the screen backlight on the TouchBook
  s/Video - Use appropriate porch/sync limits on non-OMAP35x
  s/PRCM - Don't mess with the system clock divider when calculating system clock speed (AM/DM37x fix)
Admin:
  Tested on rev C2 beagleboard, rev A2 BB-xM (indirectly), rev C1 TouchBook


Version 0.32. Tagged as 'OMAP3-0_32'
@
text
@d18 26
a43 25
GPIO_SYSCONFIG              *         &010
GPIO_SYSTATUS               *         &014
GPIO_IRQSTATUS1             *         &018
GPIO_IRQENABLE1             *         &01C
GPIO_WAKEUPENABLE           *         &020
GPIO_IRQSTATUS2             *         &028
GPIO_IRQENABLE2             *         &02C
GPIO_CTRL                   *         &030
GPIO_OE                     *         &034
GPIO_DATAIN                 *         &038
GPIO_DATAOUT                *         &03C
GPIO_LEVELDETECT0           *         &040
GPIO_LEVELDETECT1           *         &044
GPIO_RISINGDETECT           *         &048
GPIO_FALLINGDETECT          *         &04C
GPIO_DEBOUNCEENABLE         *         &050
GPIO_DEBOUNCETIME           *         &054
GPIO_CLEARIRQENABLE1        *         &060
GPIO_SETIRQENABLE1          *         &064
GPIO_CLEARIRQENABLE2        *         &070
GPIO_SETIRQENABLE2          *         &074
GPIO_CLEARWKUENA            *         &080
GPIO_SETWKUENA              *         &084
GPIO_CLEARDATAOUT           *         &090
GPIO_SETDATAOUT             *         &094
d46 1
a46 1
GPIO_PIN_MAX                *         192
d55 20
a74 20
TPS_GPIODATAIN1        *   &98 ; *3
TPS_GPIODATADIR1       *   &9B ; *3
TPS_GPIODATAOUT1       *   &9E ; *3
TPS_CLEARGPIODATAOUT1  *   &A1 ; *3
TPS_SETGPIODATAOUT1    *   &A4 ; *3
TPS_GPIO_DEBEN1        *   &A7 ; *3
TPS_GPIO_CTRL          *   &AA
TPS_GPIOPUPCTR1        *   &AB ; *5
TPS_GPIO_ISR1A         *   &B1 ; *3
TPS_GPIO_IMR1A         *   &B4 ; *3
TPS_GPIO_ISR1B         *   &B7 ; *3
TPS_GPIO_IMR1B         *   &BA ; *3
TPS_GPIO_EDR1          *   &C0 ; *5
TPS_GPIO_SIH_CTRL      *   &C5
TPS_PMBR1              *   &92
TPS_PMBR2              *   &93

TPSGPIO_IIC            *   &49

TPS_GPIO_PIN_MAX       *   17
d78 9
a86 9
TPS_LEDEN              *   &EE
TPS_PWMAON             *   &EF
TPS_PWMAOFF            *   &F0
TPS_PWMBON             *   &F1
TPS_PWMBOFF            *   &F2

TPSLED_IIC             *   &4A

TPS_LED_PIN_MAX        *   2
d91 131
a221 36
       ; Prepare for GPIO operations (constant pin)
       ; In:
       ;   $num = constant GPIO pin number
       ;   $cc = condition code
       ; Out:
       ;   $regs = GPIO register block ptr
       ;   $mask = bit mask for pin
       MACRO
       GPIO_PrepareC $regs, $mask, $num, $cc
       ASSERT   $regs <> $mask
       ASSERT   $num < GPIO_PIN_MAX
       LDR$cc   $regs, L4_GPIO_Table+4*($num>>5)
       MOV$cc   $mask, #1 :SHL: ($num :AND: 31)
       MEND

       ; Prepare for GPIO operations (register pin)
       ; In:
       ;   $num = register containing GPIO pin number
       ;   $cc = condition code
       ;   $tmp = optional temp register to avoid clobbering $num
       ; Out:
       ;   $regs = GPIO register block ptr
       ;   $mask = bit mask for pin
       ;   $num corrupted, unless $tmp specified
       MACRO
       GPIO_PrepareR $regs, $mask, $num, $cc, $tmp
       ASSERT   $regs <> $mask
 [ "$tmp" = ""
       ASSERT   $mask <> $num
  [ $regs = $num
       EOR$cc   $num, $num, #31
       MOV$cc   $mask, #&80000000
       MOV$cc   $mask, $mask, ROR $num
       MOV$cc   $regs, $num, LSR #5
       ADD$cc   $regs, sb, $regs, LSL #2
       LDR$cc   $regs, [$regs, #:INDEX:L4_GPIO_Table]
d223 2
a224 7
       ; Slightly better instruction ordering
       MOV$cc   $regs, $num, LSR #5
       EOR$cc   $num, $num, #31
       ADD$cc   $regs, sb, $regs, LSL #2
       MOV$cc   $mask, #&80000000
       LDR$cc   $regs, [$regs, #:INDEX:L4_GPIO_Table]
       MOV$cc   $mask, $mask, ROR $num
d226 1
a226 91
 |
       ASSERT   $mask <> $tmp
       ASSERT   $regs <> $tmp
       ASSERT   $num <> $tmp ; no point using $tmp if the two are the same!
       ASSERT   $regs <> $num
       MOV$cc   $regs, $num, LSR #5
       EOR$cc   $tmp, $num, #31
       ADD$cc   $regs, sb, $regs, LSL #2
       MOV$cc   $mask, #&80000000
       LDR$cc   $regs, [$regs, #:INDEX:L4_GPIO_Table]
       MOV$cc   $mask, $mask, ROR $num
 ]
       MEND

       ; Set pin for output
       MACRO
       GPIO_SetAsOutput $regs, $mask, $temp, $cc
       ASSERT   $regs <> $temp
       ASSERT   $mask <> $temp
       LDR$cc   $temp, [$regs, #GPIO_OE]
       BIC$cc   $temp, $temp, $mask
       STR$cc   $temp, [$regs, #GPIO_OE]
       MEND

       ; Set pin for input
       MACRO
       GPIO_SetAsInput $regs, $mask, $temp, $cc
       ASSERT   $regs <> $temp
       ASSERT   $mask <> $temp
       LDR$cc   $temp, [$regs, #GPIO_OE]
       ORR$cc   $temp, $temp, $mask
       STR$cc   $temp, [$regs, #GPIO_OE]
       MEND

       ; Set output to 0
       MACRO
       GPIO_SetOutput0 $regs, $mask, $cc
       STR$cc   $mask, [$regs, #GPIO_CLEARDATAOUT]
       MEND

       ; Set output to 1
       MACRO
       GPIO_SetOutput1 $regs, $mask, $cc
       STR$cc   $mask, [$regs, #GPIO_SETDATAOUT]
       MEND

       ; Set output 0/1
       ; In:
       ;  $val = zero, or non-zero
       MACRO
       GPIO_SetOutput $val, $regs, $mask
       TEQ      $val, #0
       STRNE    $mask, [$regs, #GPIO_SETDATAOUT]
       STREQ    $mask, [$regs, #GPIO_CLEARDATAOUT]
       MEND

       ; Get input value
       ; Out:
       ;  $val = zero, or non-zero
       MACRO
       GPIO_GetInput $val, $regs, $mask, $cc 
       ASSERT   $mask <> $val
       LDR$cc   $val, [$regs, #GPIO_DATAIN]
       AND$cc   $val, $val, $mask
       MEND

       ; Get GPIO IRQ # (constant pin)
       MACRO
       GPIO_GetIRQC $irq, $pin, $cc
       MOV$cc   $irq, #($pin>>5)+29
       MEND

       ; Get GPIO IRQ # (register pin)
       MACRO
       GPIO_GetIRQR $irq, $pin, $cc
       MOV$cc   $irq, $pin, LSR #5
       ADD$cc   $irq, $irq, #29
       MEND

       ; Get GPIO IRQ # (as DCD)
       ; In:
       ;   $shared = "shared" to set bit 31
       MACRO
       GPIO_GetIRQD $pin, $shared
 [ $shared = "shared"
       DCD      ($pin>>5)+29+(1<<31)
 |
       ASSERT   $shared = ""
       DCD      ($pin>>5)+29
 ]
       MEND
d229 1
a229 1
       END
@


1.3
log
@Add basic GPMC setup code and NIC HAL devices to OMAP HAL
Detail:
  s/GPMC, hdr/GPMC, hdr/StaticWS - basic code to reset the GPMC and configure chip selects
  s/NIC, hdr/NIC, hdr/StaticWS - code to expose any onboard NICs (SMSC9221, DM9000) to RISC OS as simple HAL devices.
  Makefile - added GPMC & NIC source files
  s/board, hdr/board - Expanded board config struct to include a pointer to extra code to call at the end of HAL_InitDevices, to allow board-specific devices to be initialised
  s/boot - Extra HAL_InitDevices code to set up the NICs on the IGEP/DevKit
  s/GPIO, hdr/GPIO - Improved functionality to allow GPIO IRQs to be used
  s/SDMA, s/Video - Tweaked the HAL device descriptors to indicate that the devices are on the L3 interconnect
Admin:
  Tested on rev C2 beagleboard. IGEP/DevKit entry points booted OK, but no attempts were made to look for or interact with the new HAL devices!


Version 0.24. Tagged as 'OMAP3-0_24'
@
text
@d75 7
d83 3
@


1.2
log
@Update OMAP HAL to support different board configs, plus use new YearLOIsGood flag to ensure correct RTC handling, plus other misc tidying
Detail:
  The OMAP HAL now has multiple entry points, one per board config. See Top.s/board.s for more info.
  audio.s - Moved APLL_CTL value to board config
  board.s - New file to list all the settings for the different board configs
  boot.s - Change HAL_Init to deal with the new board config stuff
  debug.s - Debug UART now specified in board config
  GPIO.s - A few utility functions for handling OMAP/TPS GPIO pins
  I2C.s - Update to use new board config struct
  RAM.s - Disable the beagleboard-specific RAM init code. Instead we'll just rely on u-boot to initialise all our RAM for us.
  RTC.s - Get rid of the magic numbers, and use the YearLOIsGood flag to indicate to RISC OS that YearLO is 2-digit BCD
  Top.s - Got rid of old debug code and rewrote initial flow to handle detecting & storing the board config
  UART.s - Update to use board config struct, support multiple UARTs
  USB.s - Get EHCI PHY power GPIO from board config
  Video.s - Get DVI framer power GPIO and max pixel rate from board config. Add 'PassiveVideo' option, to build a driver that doesn't alter the video output settings - should hopefully result in a usable display on Touch Book, etc.
  board.hdr - Definition of board config table struct
  GPIO.hdr - Add lots of macros for handling OMAP GPIO pins, new constants for OMAP/TPS GPIO
  I2C.hdr - Added I2C transfer block struct, HAL I2C API transfer states (both moved here from other source files)
  omap3530.hdr - Move/remove some unwanted constants, disable DebugChar for now
  StaticWS.hdr - Move I2C transfer block struct to I2C.hdr, add board config struct to HAL workspace, get rid of unused 64K AllocArea
  Timers.hdr - Tidy up constants a bit
  UART.hdr - Add UARTCLK (moved from StaticWS.hdr), UART IRQ #'s
  Makefile - add GPIO.s
Admin:
  Tested on rev C2 beagleboard. Board configs for other board types may be inaccurate in a couple of places.


Version 0.19. Tagged as 'OMAP3-0_19'
@
text
@d47 6
d99 1
d103 1
a103 1
       ;   $num corrupted
d105 1
a105 1
       GPIO_PrepareR $regs, $mask, $num, $cc
d107 1
d109 1
a109 1
 [ $regs = $num
d116 1
a116 1
 |
d124 12
a149 1
       ; TODO - need way of setting level detect options
@


1.1
log
@OMAP3 HAL Beagleboard Rev C support, further video work.
Detail:
  s/Boot - Fixes for rev C beagleboard. Added GPIO code.
  s/Debug - DebugHALPrint, DebugHALPrintReg routines
  s/PRCM - PRCM_GetFreqSel added
  s/RAM - Fixes for rev C beagleboard. Sped up RAM clear by using more regs.
  s/Top - Fixes for rev C beagleboard
  s/Video - Video code potentially complete, but full of bugs and so still disabled.
  hdr/GPIO - Added GPIO registers
  hdr/omap3530 - Fixes for rev C beagleboard, GPIO, debug macros, QEMU support for new video code
  hdr/SDRC - Typo fix
  hdr/StaticWS - GPIO, pixel rate entries added
  hdr/Video - DSI PLL registers added
Admin:
  Tested on rev C beagleboard.


Version 0.04. Tagged as 'OMAP3-0_04'
@
text
@d44 155
@


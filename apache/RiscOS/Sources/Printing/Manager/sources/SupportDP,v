head	4.8;
access;
symbols
	Manager-1_89:4.8
	Manager-1_88:4.8
	Manager-1_87:4.8
	Manager-1_86:4.8
	Manager-1_85:4.8
	Manager-1_84:4.8
	Manager-1_83:4.8
	Manager-1_82:4.8
	Manager-1_81:4.7
	Manager-1_80:4.7
	Manager-1_79:4.7
	Manager-1_78:4.7
	Manager-1_77:4.7
	Manager-1_76:4.7
	Manager-1_75:4.7
	Manager-1_74:4.7
	Manager-1_73:4.7
	Manager-1_72:4.7
	Manager-1_71:4.7
	Manager-1_70:4.7
	Manager-1_69:4.7
	Manager-1_68:4.7
	Manager-1_67:4.7
	Manager-1_66:4.6
	Manager-1_65:4.5
	Manager-1_64:4.4
	Manager-1_63:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2
	rthornb_UrsulaBuild-21May1998:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.7.1
	Ursula_31Mar1998:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	RO_3_71:4.1.3.1
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2013.12.17.19.21.58;	author jlee;	state Exp;
branches;
next	4.7;
commitid	EkfBVBL8hUnBkwhx;

4.7
date	2003.04.11.22.29.44;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2003.04.03.10.22.00;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2003.01.17.14.37.36;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2003.01.06.22.27.41;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.26.10.55.47;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	97.05.13.14.49.34;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.47.58;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.47.58;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.59.37;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.24.53;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.28.51;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Fix countless null pointer dereferences
Detail:
  sources/Export, sources/RunImage, sources/Sparrow, sources/SupportDP, sources/SupportLJ:
  - Add new FNsafe_string() function to provide a safe version of the $... operator which will return an empty string when given a null pointer
  - Update lots of uses of the $... operator to use FNsafe_string() instead
  - Fix a few other null pointer dereferences due to BASIC's lack of lazy evaluation in IF statements (i.e. IF A% AND A%!0 ...)
  - Fixed a few other miscellaneous null pointer dereferences seen during testing
Admin:
  Fixes PrinterManager generally crashing horribly when high processor vectors are enabled
  Tested with loading up and configuring assorted printer definitions and doing a couple of test print jobs on a BB-xM with high processor vectors enabled


Version 1.82. Tagged as 'Manager-1_82'
@
text
@REM >SupportDP
REM for dot matrix printers

/* Changes list:
 *
 * AMcC: 20-Sep-94
 * - Now pre-processed using CPP (cc -E) instead of basic prog 'Constants'.
 *   Allows us to use the same include file "Values" as used by front-end
 *   prog (!Printers.!RunImage).
 * - Uses C-style comments where cc -E  complains about // ones.
 * - All constants changed from the form CONST_name% to CONST_name.
 *
 */

#include "Values.h"
#include "Trace.h"

DEF FNdp_support(buff%)
  LOCAL reason%,psup%,prnt%,prdt%,cnfg%,xbuff%,psize_head%,code_entry%
  reason%=buff%!0
  psup%=buff%!4
  prnt%=buff%!8
  xbuff%=buff%!12
  psize_head%=buff%!16
  code_entry%=buff%!20
  IF prnt% THEN
    prdt%=FNprinter_find_prdata_entry(psup%,$prnt%!CONST_prnt_type)
    cnfg%=prnt%!CONST_prnt_cnfg
  ENDIF
  CASE reason% OF
    WHEN -1: PROCdp_m1
    WHEN -2: PROCdp_m2
    WHEN -3: PROCdp_m3
    WHEN -4: PROCdp_m4
    WHEN -5: PROCdp_m5
    WHEN -6: PROCdp_m6
    WHEN -7: PROCdp_m7
    WHEN -8: PROCdp_m8
    WHEN 3: PROCdp_p3
    WHEN 6: PROCdp_p6
    WHEN 8: PROCdp_p8
    WHEN 9: PROCdp_p9
    WHEN 17,18: PROCdp_p17
  ENDCASE
=FALSE

DEF PROCdp_m1
  LOCAL colours%, pdriverdp%, exists%
  // psup%!CONST_psup_flags OR= 0
  psup%!CONST_psup_type=&FF4
  psup%!CONST_psup_text=%0100
  psup%!CONST_psup_cnfg=CONST_cnfg_dp_MAX/4
  psup%!CONST_psup_vsn=2
  // note that the version number really only reflects
  // the status of the files being read, ie only change
  // this number if the file contents change.
  psup%!CONST_psup_dvsn=100
  psup%!CONST_psup_rma_block=0
  colours%=FNrmload_latest_module("ColourTrans","System:Modules.Colours")
  IFFNrmload_latest_module("PDriver","Printers:Modules.PDriver")
  IFFNrmload_latest_module("PDumperSupport","Printers:Modules.PDumperSpt")
  pdriverdp%=FNrmload_latest_module("PDriverDP","Printers:Modules.PDriverDP")
  // ***** WARNING!
  // ***** THESE VERSION NUMBERS ARE HARD CODED!
  IFpdriverdp%>400 AND colours%<150 THEN
    SYS"Wimp_ReportError",FNmsg_0(FNdp_host_desc,"WA12"), 1 OR 1<<4,FNmsg_1(FNdp_host_desc,"ER2",FNmsg_0(FNdp_host_desc,"ID"))
  ENDIF
/* do not allow this now
  SYS "XOS_ReadVarVal","Printers$DPLJfullQ",,-1,,3 TO,,exists%
  IF exists% THEN DPQ$="F" ELSE DPQ$="S"
*/
DPQ$="S"
ENDPROC

DEF PROCdp_m2
/*  We don't want to free up the RMA when we quit, thank you very much
 *   IF psup%!CONST_psup_rma_block THEN
 *     PROCftracef("*** FREEING R M A ***")
 *     SYS "ResourceFS_DeregisterFiles",psup%!CONST_psup_rma_block
 *     SYS "OS_Module",7,,psup%!CONST_psup_rma_block  // OSModule_Free
 *     psup%!CONST_psup_rma_block=0
 *   ENDIF
 */
ENDPROC

DEF PROCdp_m3
  // initialise the configuration window
  LOCAL config%,dp_i%,dp_j%
  config%=FNprinter_find_window(prnt%,"configure")
  PROCicon_write(config%,30,FNprinter_read_string(prnt%!CONST_prnt_name))
  PROCicon_write(config%,6,$prnt%!CONST_prnt_type)
  PROCicon_write(config%,3,FNdp_res(cnfg%))
  PROCicon_write(config%,15,FNdp_qual(cnfg%))
  dp_i%=!cnfg%!CONST_cnfg_dp_flags
  dp_j%=dp_i%>>CONST_dp_flags_feed_offset AND CONST_dp_flags_feed_width
  PROCicon_write(config%,17,FNmsg_0(psup%!CONST_psup_msg,"PF"+STR$ dp_j%))
  IF FNhas_external_config_app(prnt%) THEN
    PROCicon_unshade(config%,35)
  ELSE
    PROCicon_shade(config%,35)
  ENDIF
  IF prnt%!CONST_prnt_flags AND 1<<6 THEN
    PROCicon_shade(config%,8)
    PROCicon_shade(config%,11)
    PROCicon_shade(config%,12)
    PROCicon_shade(config%,14)
    PROCicon_shade(config%,19)
    PROCicon_shade(config%,23)
    PROCicon_shade(config%,24)
  ELSE
    dp_j%=dp_i% AND %000010
    IF dp_j% PROCicon_select(config%,8)ELSE PROCicon_deselect(config%,8)
    dp_j%=dp_i% AND %000100
    IF dp_j% PROCicon_select(config%,11)ELSE PROCicon_deselect(config%,11)
    dp_j%=dp_i% AND %001000
    IF dp_j% PROCicon_select(config%,12)ELSE PROCicon_deselect(config%,12)
    dp_j%=(dp_i% AND %110000)>>4
    PROCicon_write(config%,14,FNmsg_0(psup%!CONST_psup_msg,"TQ"+STR$ dp_j%))
    dp_j%=(dp_i% AND &F00)>>8
    PROCicon_write(config%,23,FNmsg_0(psup%!CONST_psup_msg,"CC"+STR$ dp_j%))
  ENDIF
  dp_i%=prnt%!CONST_prnt_psze
  PROCicon_write(config%,27,$dp_i%!CONST_psze_name)
ENDPROC

DEF PROCdp_m4
  // create a CNFG block with suitable defaults
  LOCAL dp_s$,dp_nm$,dp_nm2$,dp_i%,dp_s%,dp_t%,dp_co%,dp_ht%,B%,C%,dp_inf%,dp_x%,dp_y%

  // OSS set the text options to be no highlights, Print linefeeds.
  // PJC: default changed to be draft with linefeeds.
  cnfg%!CONST_cnfg_dp_flags=FNstore_integer(%011000)
  dp_i%=FNprinter_read_list_integer_entry(prdt%,5,2,1)
  IF dp_i%=0 THEN
    // no draft - fall back to no highlights
    !cnfg%!CONST_cnfg_dp_flags=%001000
    dp_i%=FNprinter_read_list_integer_entry(prdt%,5,1,1)
  ENDIF
  IF dp_i% THEN
    B%=CONST_ident_POTR
    C%=4
    cnfg%!CONST_cnfg_dp_text=USR(code_entry%+CONST_entry_heap_claim)
    IFcnfg%!CONST_cnfg_dp_text=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
    !cnfg%!CONST_cnfg_dp_text=dp_i%
  ELSE
    prnt%!CONST_prnt_flags=prnt%!CONST_prnt_flags OR 1<<6
  ENDIF

  // try to read the default x and y resolutions and name from the PRDT block
  dp_x%=FNprinter_read_integer_entry(prdt%,8)
  dp_y%=FNprinter_read_integer_entry(prdt%,9)
  dp_nm$=FNprinter_read_string_entry(prdt%,12)
  IF dp_nm$<>"" THEN
    // try to find the graphics mode which matches this name
    C%=1
    REPEAT
      B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
      // first of all, see if we've run out of modes
      IF B%=0 THEN
        C%=-1
      ELSE
        dp_nm2$=FNprinter_read_string_entry(B%,8)
        // if no match, try the next mode
        IFdp_nm$<>dp_nm2$ C%+=1
      ENDIF
    UNTIL C%=-1 OR dp_nm$=dp_nm2$
    // if we found it, remember where it was
    IF C%<>-1 dp_i%=C%
  ELSE
    IF (dp_x%<>0 AND dp_y%<>0) THEN
      // try to find the graphics mode which matches this resolution
      C%=1
      REPEAT
        B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
        // first of all, see if we've run out of modes
        IF B%=0 THEN
          C%=-1
        ELSE
          dp_s%=FNprinter_read_integer_entry(B%,4)
          dp_t%=FNprinter_read_integer_entry(B%,5)
          // if no match, try the next mode
          IFdp_s%<>dp_x% OR dp_t%<>dp_y% C%+=1
        ENDIF
      UNTIL C%=-1 OR (dp_s%=dp_x% AND dp_t%=dp_y%)
      // if we found it, remember where it was
      IF C%<>-1 dp_i%=C%
    ELSE
      // show we didn't match - which we couldn't 'cos we didn't have the values
      C%=-1
    ENDIF
  ENDIF

  // if didn't match on supplied resolutions, or no resolutions given
  // do a best fit

  IF C%=-1 THEN
    // OSS set the graphics options to be the highest non-interlaced resolution
    B%=CONST_ident_PDBF
    C%=256
    dp_inf%=USR(code_entry%+CONST_entry_heap_claim)
    IFdp_inf%=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
    C%=1
    dp_i%=FALSE
    REPEAT
      B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
      IF B%=0 THEN
        // run out of parameters, go back to the last one
        C%-=1
        dp_i%=TRUE
      ELSE
        $dp_inf%=FNprinter_read_string_entry(B%,6)
        IF dp_inf%?CONST_dp_y_interlace=0 AND dp_inf%?CONST_dp_x_interlace=0 THEN
          C%+=1
        ELSE
          C%-=1
          dp_i%=TRUE
        ENDIF
      ENDIF
    UNTIL dp_i%
    dp_i%=C%
    B%=CONST_ident_PDBF
    C%=dp_inf%
    CALL code_entry%+CONST_entry_heap_free
  ENDIF

  B%=CONST_ident_POTR
  C%=4
  cnfg%!CONST_cnfg_dp_graphics=USR(code_entry%+CONST_entry_heap_claim)
  IFcnfg%!CONST_cnfg_dp_graphics=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  !cnfg%!CONST_cnfg_dp_graphics=FNprinter_read_list_integer_entry(prdt%,4,dp_i%,1)

  // ensure that the module is present in memory
  dp_s$=FNprinter_read_string_entry(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,1),2)
  IFFNrmload_latest_module(dp_s$,"Printers:PDumpers."+dp_s$)

  // ensure that the palette file needed at the resolution is cached
  // bit 23 of palette no. flags whether already ensured or not
  dp_s$=STR$(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,2) AND &7FFFFF)
  PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_s$,"Printers:Palettes."+dp_s$,!cnfg%!CONST_cnfg_dp_graphics)

  // initialise the quality
  // see if a quality was provided in the PDF
  dp_i%=FNprinter_read_integer_entry(prdt%,10)
  // get the qualities available at the configured resolution
  dp_s%=FNdp_get_quality_options(!cnfg%!CONST_cnfg_dp_graphics)
  IF dp_i%<>0 THEN

    // validate values! reset dp_i% to zero if the requested
    // colour and halftone type aren't available at the specified
    // resolution
    //
    // Note that the 'new' strip types (3,4 and 5) cannot be set from
    // the printer definition file, therefore aren't checked for here

    dp_co%=dp_i% AND &FF
    dp_ht%=(dp_i% AND &FF00)>>8
    CASE dp_co% OF
      WHEN 0  // mono
        IF (dp_s% AND 7) THEN
          IF dp_ht%=4 AND (dp_s% AND 1)=0 dp_i%=0
          IF dp_ht%=8 AND (dp_s% AND 2)=0 dp_i%=0
          IF dp_ht%=1 AND (dp_s% AND 4)=0 dp_i%=0
        ELSE
          dp_i%=0
        ENDIF
      WHEN 1  // greyscale
        IF (dp_s% AND &70) THEN
          IF dp_ht%=4 AND ((dp_s%>>4) AND 1)=0 dp_i%=0
          IF dp_ht%=8 AND ((dp_s%>>4) AND 2)=0 dp_i%=0
          IF dp_ht%=1 AND ((dp_s%>>4) AND 4)=0 dp_i%=0
        ELSE
          dp_i%=0
        ENDIF
      WHEN 2  // colour
        IF (dp_s% AND &700) THEN
          IF dp_ht%=4 AND ((dp_s%>>8) AND 1)=0 dp_i%=0
          IF dp_ht%=8 AND ((dp_s%>>8) AND 2)=0 dp_i%=0
          IF dp_ht%=1 AND ((dp_s%>>8) AND 4)=0 dp_i%=0
        ELSE
          dp_i%=0
        ENDIF
    ENDCASE
  ENDIF
  IF dp_i%<>0 THEN
    cnfg%!CONST_cnfg_dp_options=FNstore_integer(dp_i%)
  ELSE
    PROCdp_decode_options(dp_s%,dp_co%,dp_ht%)
    cnfg%!CONST_cnfg_dp_options=FNstore_integer(dp_ht%<<8 OR dp_co%)
  ENDIF

  $buff%=FNprinter_read_string_entry(prdt%,2)
  B%=buff%
  C%=2
  prnt%!CONST_prnt_name=USR(code_entry%+CONST_entry_store_string)
  dp_s$=FNprinter_read_string_entry(prdt%,3)
  // if the sprite name isn't the same as the class name, store the new sprite name
  IF dp_s$<>"dp" $buff%=dp_s$:B%=buff%:C%=2:prnt%!CONST_prnt_sprt=USR(code_entry%+CONST_entry_store_string)

  // initialise the best paper size we can find ...
  // start by trying to read the 'default_paper_size' entry
  // from the PRDT block (entry 7)
  dp_s$=FNprinter_read_string_entry(prdt%,7)
  // fall back to going for the default
  IF dp_s$="" dp_s$=FNmsg_0(psup%!CONST_psup_msg,"PAP")

  dp_i%=psize_head%
  WHILE dp_s$<>FNprinter_read_string(dp_i%!CONST_psze_name)
    dp_i%=dp_i%!CONST_psze_next
    // if we run out of paper entries, go for the first one
    IF dp_i%=0 dp_i%=psize_head%: dp_s$=FNprinter_read_string(dp_i%!CONST_psze_name)
  ENDWHILE
  prnt%!CONST_prnt_psze=dp_i%

  // if this printer supports fast parallel, set the appropriate flag
  dp_i%=FNprinter_read_integer_entry(prdt%,11)
  IFdp_i%<>0 prnt%!CONST_prnt_flags = prnt%!CONST_prnt_flags OR (1<<7)
ENDPROC

DEF PROCdp_ensure_resource_file(resource$,disc$,gprdt%)
  LOCAL obj_type%,load_addr%,exec_addr%,file_size%,obj_attr%,rma_size%,rma_block%
  LOCAL found_type%,found_load%,found_exec%,found_size%,c%,a%,w%,pnum%,reload_if_outofdate%
  VDU: PROCftracef("dp_ensure_resource_file")
  // We use this to load palette files for the printers in order to reduce
  // the probability of having to ask for the printers disc again later.

  // check for out of date palette if we have not ensured this one before (bit 23 of palette number)
  pnum% = FNprinter_read_integer_entry(gprdt%,2)
  reload_if_outofdate% = ((pnum% AND &800000) = 0)
  PROCprinter_write_integer_entry(gprdt%,2,pnum% OR &800000) // we (will) have ensured it

  // First of all, check if the file exists already
  SYS "OS_File",17,"Resources:"+resource$ TO found_type%,,found_load%,found_exec%,found_size%  // OS_FileReadNoPath

  IF found_type% AND reload_if_outofdate%=FALSE ENDPROC

  SYS "OS_File",17,disc$ TO obj_type%,,load_addr%,exec_addr%,file_size%,obj_attr%  // OS_FileReadNoPath
  IF obj_type%<>1 SYS "OS_File",19,disc$,obj_type%  // OS_FileMakeError

  IF found_type% THEN
    IFfound_load%=load_addr% AND found_exec%=exec_addr% AND found_size%=file_size% ENDPROC
    // cached palette is not the same as the one on disc
    // try to remove the cached palette
    c%=OPENIN("Resources:"+resource$)
    IFc%=0 ERROR CONST_error_ok, FNmsg_1(FNdp_host_desc,"OKBB",resource$)
    SYS"OS_FSControl",21,c% TO ,a%,w%
    CLOSE#c%
    IF(w%AND&FF)<>46 ERROR CONST_error_ok, FNmsg_1(FNdp_host_desc,"OKBC",resource$)
    a%-=(LENresource$+4ANDNOT3)+4
    a%-=20
    IFa%!-4 = &48434143 THEN
      SYS"ResourceFS_DeregisterFiles",a%
      SYS"OS_Module",7,,a%-4
    ENDIF
  ENDIF

  rma_size%=20+(LEN resource$+4 AND NOT 3)+4+(file_size%+3 AND NOT 3)  // Size needed for this file only
  VDU: PROCftracef("File "+disc$+", size "+STR$ file_size%)

  // claim some RMA for the file
  SYS "OS_Module",6,,,rma_size%+8 TO,,rma_block%  // OSModule_Alloc
  // Put a check tag at the beginning of the block
  !rma_block%=&48434143 // CACH
  rma_block%+=4
  // Fill in the block
  rma_block%!0=rma_size%
  rma_block%!4=load_addr%
  rma_block%!8=exec_addr%
  rma_block%!12=file_size%
  rma_block%!16=obj_attr%
  $(rma_block%+20)=resource$
  rma_block%!(20+LEN resource$)=0 /*   // pad with 0's */
  rma_block%!(20+(LEN resource$+4 AND NOT 3))=file_size%+4
  SYS "OS_File",16,disc$,rma_block%+20+(LEN resource$+4 AND NOT 3)+4  // OS_FileLoadNoPath
  rma_block%!rma_size%=0  // Terminator
  SYS "ResourceFS_RegisterFiles",rma_block%
ENDPROC

DEF PROCdp_m5
  // cache any palette files that are used by dp printers and ensure
  // that the relevant PDumper modules are loaded
  LOCAL dp_prnt%,dp_cnfg%,dp_graphics_prdt%,dp_pal$
  dp_prnt%=prnt%
  WHILE dp_prnt%>0
    IF dp_prnt%!CONST_prnt_psup=psup% THEN
      // got a printer in our class - cache the palette file
      dp_cnfg%=dp_prnt%!CONST_prnt_cnfg
      dp_graphics_prdt%=!dp_cnfg%!CONST_cnfg_dp_graphics
      // bit 23 of palette no. flags whether already ensured or not
      dp_pal$=STR$(FNprinter_read_integer_entry(dp_graphics_prdt%,2) AND &7FFFFF)
      PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_pal$,"Printers:Palettes."+dp_pal$,dp_graphics_prdt%)

      // and ensure the pdumper module
      dp_pal$=FNprinter_read_string_entry(FNprinter_read_integer_entry(dp_graphics_prdt%,1),2)
      IFFNrmload_latest_module(dp_pal$, "Printers:PDumpers."+dp_pal$)
    ENDIF
    dp_prnt%=dp_prnt%!CONST_prnt_next
  ENDWHILE
ENDPROC

DEF PROCdp_m6
  // do whatever is necessary to prime the specified printer
  LOCAL dp_s$,dp_t$,dp_i%,xres%,yres%,halftone%,ptr%,flags%,pal%,dmp$,inf%,strip%,graphics_prdt%,text_prdt%,B%,C%
  LOCAL flags%,newblock%,i%,a$,s%
  // 7 is the magic number for the dumper driver
  SYS "XPDriver_SelectDriver",7
  dp_s$=FNprinter_read_string(prnt%!CONST_prnt_name)
  IF dp_s$="" THEN
    dp_s$=$prnt%!CONST_prnt_type
    IF LEN dp_s$>20 THEN
      dp_i%=LEN dp_s$
      WHILE MID$(dp_s$,dp_i%,1)<>" " AND dp_i%>0
        dp_i%-=1
      ENDWHILE
      IF dp_i% dp_s$=LEFT$(dp_s$,dp_i%-1)ELSE dp_s$=LEFT$(dp_s$,20)
    ENDIF
  ENDIF
  graphics_prdt%=!cnfg%!CONST_cnfg_dp_graphics
  xres%=FNprinter_read_integer_entry(graphics_prdt%,4)
  yres%=FNprinter_read_integer_entry(graphics_prdt%,5)
  halftone%=(!cnfg%!CONST_cnfg_dp_options AND &FF00)>>8
  strip%=!cnfg%!CONST_cnfg_dp_options AND &FF
  // WARNING!
  // The comparison is made against strip type 2 (colour) or greater
  // This assumes, therefore, that any strip types that are 2 or greater
  // are colour which is currently true
  IF (strip% >= 2) THEN
   SYS"XPDriver_SetInfo",,xres%,yres%,1,dp_s$,xres%/halftone%,yres%/halftone% TO ptr%;dp_i%
  ELSE
   SYS"XPDriver_SetInfo",,xres%,yres%,0,dp_s$,xres%/halftone%,yres%/halftone% TO ptr%;dp_i%
  ENDIF
  IF (dp_i% AND 1) AND (ptr%<>0) THEN
    dp_s$="": ptr%+=4
    WHILE ?ptr%: dp_s$+=CHR$ ?ptr%: ptr%+=1: ENDWHILE
    ERROR CONST_error_ok,dp_s$
    ENDPROC
  ENDIF

  // bit 23 of palette no. flags whether already ensured or not
  dp_s$=STR$(FNprinter_read_integer_entry(graphics_prdt%,2) AND &7FFFFF)

  B%=CONST_ident_PDBF
  C%=256

  pal%=USR(code_entry%+CONST_entry_heap_claim)
  IF pal% ELSE ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  $pal%="Resources:$.Resources.Printers.Palettes."+dp_s$

  inf%=USR(code_entry%+CONST_entry_heap_claim)
  IF inf% ELSE ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  $inf%=FNprinter_read_string_entry(graphics_prdt%,6)
  strip%=!cnfg%!CONST_cnfg_dp_options AND &FF

  // if we have strip type 5 and the dumper doesn't support it,
  // deprecate it down to strip type 3

  IF strip%=5 THEN
   dp_i%=FNprinter_read_integer_entry(graphics_prdt%,1)
   dp_i%=FNprinter_read_integer_entry(dp_i%,1)
   // we've selected the dumper driver, so this should work :-)
   SYS"XPDriver_MiscOp",&80000002,dp_i% TO ptr%;dp_i%
   IF(dp_i%AND1)=0 IFptr%<>&80000002 IF(ptr% AND (1<<5))=0 strip%=3
  ENDIF
  // this may be necessary, if multiple palettes for one printer
  PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_s$,"Printers:Palettes."+dp_s$,graphics_prdt%)

  // Module name:
  dp_s$=FNprinter_read_string_entry(FNprinter_read_integer_entry(graphics_prdt%,1),2)
  dmp$="RMLoad Printers:PDumpers."+dp_s$+CHR$ 13

  // set passes per line entry
  // WARNING!
  // The comparison is made against strip type 2 (colour) or greater
  // This assumes, therefore, that any strip types that are 2 or greater
  // are colour which is currently true
  IF strip%>=2 inf%?CONST_dp_pass_per_line=4 ELSE inf%?CONST_dp_pass_per_line=1

  // set strip type field
  inf%?CONST_dp_strip_type=strip%

  // set output bpp field
  IF strip%=0 inf%?CONST_dp_output_bpp=1 ELSE inf%?CONST_dp_output_bpp=8

  // set num passes field
  IF strip%=3 inf%?CONST_dp_no_passes=3 ELSE inf%?CONST_dp_no_passes=1

  // OSS Set the NoPageAdvance bit in the flags if paper feed is "Roll"
  flags%=FNprinter_read_integer_entry(graphics_prdt%,7)
  IF(!cnfg%!CONST_cnfg_dp_flags>>CONST_dp_flags_feed_offset AND CONST_dp_flags_feed_width)=CONST_dp_flags_feed_roll flags%+=2

  // OSS Fixup old version numbers by moving it to the new location.
  IF(flags%>>>24)=0 flags%=flags% OR inf%?CONST_dp_data_old_version<<24

  // OSS Set lines per page if version>0. We only need to check the new
  // version field as the fixup has already been done.
  IF(flags%>>>24)>0 THEN
    dp_i%=prnt%!CONST_prnt_psze
    inf%?CONST_dp_data_num_lines=dp_i%!CONST_psze_theight
  ENDIF

  flags%=FNprinter_read_integer_entry(graphics_prdt%,7)
  IF ((flags% >>> 24) < 5) = 0 THEN
    ptr% = CONST_dp_data_text_start // Free space for each string
    ptr% = FNdp_dataN_block(inf%, ptr%, 0,  CONST_dp_data_set_lines)      // data1
    ptr% = FNdp_dataN_block(inf%, ptr%, 1,  CONST_dp_data_page_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 2,  CONST_dp_data_form_feed)
    ptr% = FNdp_dataN_block(inf%, ptr%, 3,  CONST_dp_data_page_end)
    ptr% = FNdp_dataN_block(inf%, ptr%, 4,  CONST_dp_data_line_return)
    ptr% = FNdp_dataN_block(inf%, ptr%, 5,  CONST_dp_data_line_skip)
    ptr% = FNdp_dataN_block(inf%, ptr%, 6,  CONST_dp_data_line_end)
    ptr% = FNdp_dataN_block(inf%, ptr%, 7,  CONST_dp_data_line_end_i2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 8,  CONST_dp_data_line_end_i3)
    ptr% = FNdp_dataN_block(inf%, ptr%, 9,  CONST_dp_data_zero_skip)
    ptr% = FNdp_dataN_block(inf%, ptr%, 10, CONST_dp_data_line_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 11, CONST_dp_data_line_start_2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 12, CONST_dp_data_pass1_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 13, CONST_dp_data_pass1_start_2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 14, CONST_dp_data_pass2_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 15, CONST_dp_data_pass2_start_2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 16, CONST_dp_data_pass3_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 17, CONST_dp_data_pass3_start_2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 18, CONST_dp_data_pass4_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 19, CONST_dp_data_pass4_start_2)  // data20
  ENDIF
  SYS "XPDriver_SetDriver",, FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%, 1), 1), dmp$, pal%, inf%, flags%
  B%=CONST_ident_PDBF
  C%=pal%
  CALL code_entry%+CONST_entry_heap_free
  C%=inf%
  CALL code_entry%+CONST_entry_heap_free
  SYS "OS_CLI","Unset PDriver$TextChars1"

  // point to the chars PRDT block
  dp_i%=FNprinter_read_integer_entry(prdt%,6)
  IF dp_i% THEN
    dp_i%=dp_i%!CONST_prdt_1st
    WHILE dp_i%
      IF dp_i%?CONST_char_char=ASC"£" THEN
        dp_s$=FNdp_hex2(ASC "£")+FNdp_hex2(dp_i%?CONST_char_len)
        ptr%=dp_i%+CONST_char_trans: dp_i%=dp_i%?CONST_char_len
        WHILE dp_i%
          dp_s$+=FNdp_hex2(?ptr%)
          ptr%+=1
          dp_i%-=1
        ENDWHILE
        SYS"OS_CLI","Set PDriver$TextChars1 "+dp_s$
      ELSE
        dp_i%=dp_i%!CONST_char_next
      ENDIF
    ENDWHILE
  ENDIF

  IF cnfg%!CONST_cnfg_dp_text=0 THEN
    SYS"OS_CLI","Unset PDriver$TextPage"
  ELSE
    text_prdt%=!cnfg%!CONST_cnfg_dp_text
    dp_i%=prnt%!CONST_prnt_psze
    dp_s$="-Ph "+STR$ dp_i%!CONST_psze_theight+" -Mt "+STR$ dp_i%!CONST_psze_ttop+" -Mb "
    dp_s$+=STR$ dp_i%!CONST_psze_tbottom+" -Ml "+STR$ dp_i%!CONST_psze_tleft+" -Th "
    IF cnfg%!CONST_cnfg_dp_flags AND 2 dp_s$+="2" ELSE dp_s$+="0"
    dp_s$+=" -Nl "
    IF cnfg%!CONST_cnfg_dp_flags AND 8 THEN
      dp_s$+=FNungstrans(FNungstrans(FNprinter_read_string_entry(text_prdt%,6)))
    ELSE
      dp_s$+=FNungstrans(FNungstrans(FNprinter_read_string_entry(text_prdt%,5)))
    ENDIF
    dp_t$=FNprinter_read_string_entry(text_prdt%,7)
    IF dp_t$<>"" dp_s$+=" -Rs "+FNungstrans(FNungstrans(dp_t$))
    dp_t$=FNprinter_read_string_entry(text_prdt%,11)
    IF dp_t$<>"" dp_s$+=" -Cd "+FNungstrans(FNungstrans(dp_t$))
    SYS"OS_CLI","Set PDriver$TextPage "+dp_s$
  ENDIF
ENDPROC

// Fill in the inf% block based on the "dataN:" lines in the PDF
DEF FNdp_dataN_block(inf%, ptr%, B%, C%)
  LOCAL type%, str%, len%

Ftracef("graphics_prdt%=&"+STR$~graphics_prdt%+", inf%=&"+STR$~inf%+", ptr%=&"+STR$~ptr%+", B%="+STR$B%)

  // Get a pointer to the string and read its type
  str% = FNprinter_read_string_pointer(graphics_prdt%, 10 + B%)
Ftracef("str%=&"+STR$~str%)
  IF str% = 0 THEN
    inf%?C% = 0
    =ptr%
  ENDIF

#ifdef Trace
  CASE str%!-4 OF
    WHEN CONST_ident_STRG
      Ftracef("dataN: type=STRG (CR-terminated)")
    WHEN CONST_ident_STR0
      Ftracef("dataN: type=STR0 (zero-terminated)")
    WHEN CONST_ident_GSTR
      Ftracef("dataN: type=GSTR (byte counted)")
    WHEN CONST_ident_LSTR
      Ftracef("dataN: type=LSTR (word counted)")
    OTHERWISE
      Ftracef("dataN: type=UNKNOWN")
  ENDCASE
#endif

  // If this entry is not of long string type, return an error
  IF str%!-4 <> CONST_ident_LSTR THEN
    // This was probably the result
    ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc, "FAM")
  ENDIF

  // Read string length and point to start of string
  len%  = !str%
  str% += 4
  Ftracef("len%="+STR$len%)

  // If the string is of zero length, record that and exit
  IF len% = 0 THEN
    inf%?C% = 0
    =ptr%
  ENDIF

#ifdef Trace
  // Make sure that we're writing to word-aligned addresses
  IF (inf% + ptr%) AND %11 THEN
    ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc, "FAN")
  ENDIF
#endif

  // Copy the string and return pointer for next entry (long string format)
  inf%?C%        = ptr% - CONST_dp_data_dlm
  inf%!ptr%      = len% << 8
  !(inf%+ptr%+4) = str%
=ptr% + 8

DEF PROCdp_m7
  LOCAL queu%,dp_p%,B%,C%
  queu%=!xbuff%
  dp_p%=queu%!CONST_queu_tprv
  IF dp_p% THEN
    PROCfree_structure(dp_p%!CONST_tprv_dp_page_prologue)
    B%=CONST_ident_TPRV
    C%=dp_p%
    CALL code_entry%+CONST_entry_heap_free
    queu%!CONST_queu_tprv=0
  ENDIF
ENDPROC

DEF PROCdp_p3
  SYS"Wimp_CloseWindow",,xbuff%
ENDPROC

DEF PROCdp_p6
  LOCAL wind%,dummy%
  // mouseclick on the configure window
  CASE xbuff%!8 OF
    WHEN 2  // menu
      CASE xbuff%!16 OF
        WHEN 20: PROCdp_menu("ME1",TRUE,TRUE)
        WHEN 18: PROCdp_menu("ME2",TRUE,TRUE)
        WHEN  4: PROCdp_menu("ME3",TRUE,TRUE)
        WHEN 19: PROCdp_menu("ME4",TRUE,TRUE)
        WHEN 24: PROCdp_menu("ME5",TRUE,TRUE)
        WHEN 26: PROCdp_menu("MP1",TRUE,TRUE)
      ENDCASE
    WHEN 4  // select
      CASE xbuff%!16 OF
        WHEN 25
          wind%=xbuff%!12
          PROCdp_save_configuration(wind%)
          !xbuff%=wind%:SYS"Wimp_CloseWindow",,xbuff%
        WHEN 20
          PROCdp_menu("ME1",TRUE,TRUE)
        WHEN 18
          PROCdp_menu("ME2",TRUE,TRUE)
        WHEN  4
          PROCdp_menu("ME3",TRUE,TRUE)
        WHEN 19
          PROCdp_menu("ME4",TRUE,TRUE)
        WHEN 24
          PROCdp_menu("ME5",TRUE,TRUE)
        WHEN 26
          PROCdp_menu("MP1",TRUE,TRUE)
        WHEN 31
          !xbuff%=xbuff%!12
          SYS"Wimp_CloseWindow",,xbuff%
        WHEN 35
          dummy%=FNexternal_config_app(prnt%)
      ENDCASE
    WHEN 1  // adjust
      CASE xbuff%!16 OF
        WHEN 25
          wind%=xbuff%!12
          PROCdp_save_configuration(wind%)
        WHEN 35
          dummy%=FNexternal_config_app(prnt%)
      ENDCASE
  ENDCASE
ENDPROC

DEF PROCdp_p8
  // a key press!
  LOCAL dp_i%
  dp_i%=psup%!CONST_psup_wind
  WHILE dp_i%
    IF dp_i%!CONST_wind_hand=!xbuff% THEN
      IF xbuff%!24=13 THEN
        CASE $(dp_i%+CONST_wind_name)OF
          WHEN "configure"
            SYS "Wimp_CloseWindow",,xbuff%
            PROCdp_save_configuration(!xbuff%)
        ENDCASE
      ELSE
        SYS "Wimp_ProcessKey",xbuff%!24
      ENDIF

      ENDPROC
    ENDIF

    dp_i%=dp_i%!CONST_wind_next
  ENDWHILE
ENDPROC

DEF PROCdp_p9
  LOCAL adjust%,wind%,icon%,ptr%,xres%,yres%,dp_s$,dp_i%,dp_j%,dp_k%

  // menu selections are easy ... we just write the
  // selected string into the appropriate icon.
  // some other actions may be taken to ensure that
  // other choices are OK, but we don't touch any
  // data yet.

  wind%=FNprinter_find_window(prnt%,"configure")
  adjust%=FNwas_adjust_used
  CASE dp_menu_chsn$ OF
    WHEN "ME1": icon%=3
    WHEN "ME2": icon%=17
    WHEN "ME3": icon%=15
    WHEN "ME4": icon%=14
    WHEN "ME5": icon%=23
    WHEN "MP1": icon%=27
  ENDCASE
  ptr%=dp_menu%+28+!xbuff%*24
  IF ptr%!8 AND &100 THEN
    PROCicon_write(wind%,icon%,$ptr%!12)
  ELSE
    PROCicon_write(wind%,icon%,$(ptr%+12))
  ENDIF
  IF dp_menu_chsn$="ME1" THEN
    // if the resolution changes, we may have to change the quality as well
    dp_j%=prdt%!20
    dp_s$=FNicon_read(wind%,3)
    WHILE dp_j%
      dp_k%=!dp_j%!CONST_lstd_1st
      IF (dp_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)) OR \
         (dp_s$=FNsafe_string(dp_k%!36)) THEN

        // ok - found the pointer to the graphics data, now check the graphics quality
        // basically, we need to see if the request quality is available in this dump
        // if it isn't, we reset it to the best fit we can manage

        dp_s$=FNicon_read(wind%,15): dp_i%=INSTR(dp_s$,",")
        CASE LEFT$(dp_s$,dp_i%-1)OF
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  dp_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): dp_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  dp_j%=2
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  dp_j%=4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  dp_j%=5
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): dp_j%=5
          OTHERWISE:                                 dp_j%=0
        ENDCASE
        dp_s$=MID$(dp_s$,dp_i%+2)
        CASE dp_s$ OF
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  dp_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): dp_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  dp_i%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): dp_i%=1
          OTHERWISE:                                 dp_i%=4
        ENDCASE
        dp_k%=FNdp_get_quality_options(dp_k%)
        IF(dp_k% AND (7<<(dp_j%*4)))=0 dp_j%=-1
        IF dp_j%<>-1 THEN
          dp_j%=dp_k%>>(dp_j%*4)
          CASE dp_i% OF
            WHEN 4: IF(dp_j% AND 1)=0 dp_i%=-1
            WHEN 8: IF(dp_j% AND 2)=0 dp_i%=-1
            WHEN 1: IF(dp_j% AND 4)=0 dp_i%=-1
          ENDCASE
        ENDIF
        IF dp_j%=-1 OR dp_i%=-1 THEN
          PROCdp_decode_options(dp_k%,dp_j%,dp_i%)
          PROCicon_write(wind%,15,FNdp_qual_name(dp_j% + (dp_i% << 8)))
        ENDIF
        dp_j%=0
      ELSE
        dp_j%=!dp_j%
      ENDIF
    ENDWHILE
  ENDIF
  IF adjust% THEN
    SYS"Wimp_GetPointerInfo",,xbuff%
    PROCdp_menu(dp_menu_chsn$,FALSE,FALSE)
  ENDIF
ENDPROC

DEF PROCdp_p17
  LOCAL wind%,dp_s$,dp_t$
  CASE xbuff%!16 OF
    WHEN &502  // HelpRequest
      wind%=psup%!CONST_psup_wind
      WHILE wind%
        IF wind%!CONST_wind_hand=xbuff%!32 THEN
          CASE $(wind%+CONST_wind_name)OF
            WHEN "configure"
              dp_s$=STR$ xbuff%!36
              CASE xbuff%!36 OF
                WHEN 8,11,12: IF FNicon_set(xbuff%!32,xbuff%!36)dp_s$+="b" ELSE dp_s$+="a"
              ENDCASE
              dp_t$=FNmsg_0(psup%!CONST_psup_msg,"CON"+dp_s$)
              IFdp_t$="CON"+dp_s$ dp_t$=FNmsg_0(psup%!CONST_psup_msg,"CON")
              PROCinteractive_help(dp_t$)
          ENDCASE
          wind%=0
        ELSE
          wind%=wind%!CONST_wind_next
          IF wind%=0 PROCinteractive_help(FNmsg_0(psup%!CONST_psup_msg,"H"+dp_menu_chsn$))
        ENDIF
      ENDWHILE
    WHEN &8014B
      /*PrintInterrogate*/
      CASE xbuff%!20 OF
      WHEN 0
        IF prnt% AND xbuff%!24=prnt% THEN PROCdp_interrogate0
      ENDCASE
  ENDCASE
ENDPROC

DEF PROCdp_interrogate0
  LOCAL a$,sender%
  /* Ack the message */
  xbuff%!12=xbuff%!8
  sender%=xbuff%!4
  SYS "Wimp_SendMessage",19,xbuff%,sender%
  /* Construct and send the reply */
  xbuff%!28=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,2)
  xbuff%!32=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,3)
  xbuff%!36=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,4)
  xbuff%!40=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,5)
  xbuff%!44=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,7)
  a$=FNprinter_read_string_entry(!cnfg%!CONST_cnfg_dp_graphics,8)+CHR$(0)
  $(xbuff%+48)=a$
  !xbuff%=(48+3+LENa$)ANDNOT3
  SYS "Wimp_SendMessage",17,xbuff%,sender%
ENDPROC

DEF PROCdp_save_configuration(window%)
  LOCAL dp_i%,dp_j%,dp_k%,dp_s$,B%,C%
  prdt%=FNprinter_find_prdata_entry(psup%,FNicon_read(window%,6))
  PROCfree_structure(prnt%!CONST_prnt_name)
  $buff%=FNicon_read(window%,30)
  B%=buff%
  C%=2
  prnt%!CONST_prnt_name=USR(code_entry%+CONST_entry_store_string)
  dp_i%=cnfg%
  FOR dp_j%=1 TO CONST_cnfg_dp_MAX/4
    PROCfree_structure(!dp_i%)
   !dp_i%=0: dp_i%+=4
  NEXT

  dp_j%=0
  IF FNicon_read(window%,17)=FNmsg_0(psup%!CONST_psup_msg,"PF1")dp_j%+=CONST_dp_flags_feed_manual<<CONST_dp_flags_feed_offset
  IF FNicon_read(window%,17)=FNmsg_0(psup%!CONST_psup_msg,"PF2")dp_j%+=CONST_dp_flags_feed_roll<<CONST_dp_flags_feed_offset
  IF FNicon_set(window%,8)dp_j%+=2
  IF FNicon_set(window%,11)dp_j%+=4
  IF FNicon_set(window%,12)dp_j%+=8
  CASE FNicon_read(window%,14)OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"TQ1"): dp_j%+=1<<4: dp_i%=2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"TQ2"): dp_j%+=1<<5: dp_i%=3
    OTHERWISE: dp_i%=1
  ENDCASE
  CASE FNicon_read(window%,23)OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CC1"): dp_j%+=1<<8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CC2"): dp_j%+=1<<9
  ENDCASE
  cnfg%!CONST_cnfg_dp_flags=FNstore_integer(dp_j%)

  dp_j%=FNprinter_read_list_integer_entry(prdt%,5,dp_i%,1)
  IF dp_j% THEN
    B%=CONST_ident_POTR
    C%=4
    cnfg%!CONST_cnfg_dp_text=USR(code_entry%+CONST_entry_heap_claim)
    IFcnfg%!CONST_cnfg_dp_text=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
    !cnfg%!CONST_cnfg_dp_text=dp_j%
    prnt%!CONST_prnt_flags=prnt%!CONST_prnt_flags AND NOT(1<<6)
  ELSE
    prnt%!CONST_prnt_flags=prnt%!CONST_prnt_flags OR 1<<6
  ENDIF

  // point to the resolution possibilities
  dp_j%=prdt%!20  // printer name is 8, short name is 12, sprite name is 16, resolution is 20
  dp_s$=FNicon_read(window%,3)
  WHILE dp_j%
    dp_k%=!dp_j%!CONST_lstd_1st  // get the pointer
    // module is 8, palette is 12, options is 16, pxres is 20, pyres is 24
    IF (dp_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)) OR \
       (dp_s$=FNsafe_string(dp_k%!36)) THEN
      dp_j%=0
    ELSE
      dp_j%=!dp_j%
    ENDIF
  ENDWHILE
  B%=CONST_ident_POTR:C%=4
  cnfg%!CONST_cnfg_dp_graphics=USR(code_entry%+CONST_entry_heap_claim)
  IFcnfg%!CONST_cnfg_dp_graphics=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  !cnfg%!CONST_cnfg_dp_graphics=dp_k%

  dp_s$=FNicon_read(window%,15)
  dp_i%=INSTR(dp_s$,",")
  CASE LEFT$(dp_s$,dp_i%-1)OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  dp_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): dp_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  dp_j%=2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  dp_j%=4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  dp_j%=5
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): dp_j%=5
    OTHERWISE: dp_j%=0
  ENDCASE
  dp_s$=MID$(dp_s$,dp_i%+2)
  CASE dp_s$ OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  dp_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): dp_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  dp_i%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): dp_i%=1
    OTHERWISE: dp_i%=4
  ENDCASE
  cnfg%!CONST_cnfg_dp_options=FNstore_integer((dp_i%<<8)+dp_j%)

  dp_j%=prnt%!CONST_prnt_psze
  dp_s$=FNicon_read(window%,27)
  IF $dp_j%!CONST_psze_name<>dp_s$ THEN
    dp_i%=psize_head%
    WHILE dp_i%
      IF $dp_i%!CONST_psze_name=dp_s$ THEN
        prnt%!CONST_prnt_psze=dp_i%
        dp_i%=0
      ELSE
        dp_i%=!dp_i%
      ENDIF
    ENDWHILE
  ENDIF

  IF prnt%!CONST_prnt_icon<>-1 THEN

    // this printer is ACTIVE!
    // ensure that its details are correct

    PROCselect_printer(prnt%,TRUE,FALSE)

    // The front end code will spot that the selected printer has
    // changed and put everything back the way it was
    // PROCselect_printer(0,TRUE,TRUE): Don't do this - calls overlay

  ENDIF
ENDPROC

DEF FNdp_res(cnfg%)
  LOCAL xres%,yres%,graphics_prdt%,nm$
  graphics_prdt%=!cnfg%!CONST_cnfg_dp_graphics
  xres%=FNprinter_read_integer_entry(graphics_prdt%,4)
  yres%=FNprinter_read_integer_entry(graphics_prdt%,5)
  nm$=FNprinter_read_string_entry(graphics_prdt%,8)
  IF nm$="" THEN  nm$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%)
=nm$

DEF FNdp_qual_name(dp_i%)
  LOCAL dp_s$,dp_t$
  IF DPQ$ = "S" THEN
    dp_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(dp_i% AND &FF)+"s")
    dp_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((dp_i% AND &FF00)>>8)+"s")
  ELSE
    dp_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(dp_i% AND &FF))
    dp_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((dp_i% AND &FF00)>>8))
  ENDIF
=dp_s$+", "+dp_t$

DEF FNdp_qual(cnfg%)
  LOCAL dp_i%
  dp_i%=!cnfg%!CONST_cnfg_dp_options
=FNdp_qual_name(dp_i%)

DEF FNdp_get_quality_options(graphics_definition%)
LOCAL s%,c%,t%
s%=FNprinter_read_integer_entry(graphics_definition%,3)
// if colour small halftone present, add colour large halftone
IF (s% AND &100) s% = s% OR &200
// if colour available, add new colour options
IF (s% AND &700) THEN
 t%=FNprinter_read_integer_entry(graphics_definition%,1) // ptr to module defn
 t%=FNprinter_read_integer_entry(t%,1) // module number
 // need to pass the MiscOp through to the dumper driver
 SYS"XPDriver_MiscOpForDriver",&80000002,t%,,,,,,,7 TO t%;c% // strip type mask
 IF(c%AND1)=0 AND t%<>&80000002 THEN
  IF (t% AND (1<<3)) THEN
   // add strip type 3 based on the greyscale options (or colour, if no grey)
   c%=s% AND &70
   IF c%=0 THEN c%=(s% AND &700)>>4
   s%=s% OR (c%<<16)
  ENDIF
  IF (t% AND (1<<4)) THEN
/*   // add strip type 4 based on the colour options */
   c%=s% AND &700
   s%=s% OR (c%<<8)
  ENDIF
  IF (t% AND (1<<5)) THEN
   // add strip type 5 based on the colour options
   c%=s% AND &700
   s%=s% OR (c%<<12)
  ENDIF
 ENDIF
ENDIF
// If simple qualities, knock out Mono,256 colours,32k colours
IF DPQ$ = "S" s%=s% AND &700070
=s%

// If DPQ$ = "S" then the following qualities are
// actually deemed not to exist:
// - Any 'Mono'; '256 colours'; '32k colours'

// This procedure tries to find a good default quality to pick.
// Modified on 22-Jul-93/3-Dec-93 to pick in this order:
// Modified on 02-Aug-95 to favour error diff instead of halftone
// * 16 million, diffused
// * colour, diffused
// * grey, diffused
// * mono, diffused
//
// The option value is split into 3 nibbles:
// &7xxxxx = 24bpp colour, either strip type 3 or 5 depending on
//                         whether or not it is a full colour system
// &x7xxxx = 16bpp colour, strip type 4
// &xxx7xx = colour, strip type 2
// &xxxx7x = greyscale, strip type 1
// &xxxxx7 = monochrome, strip type 0
//
// Within the 3 nibbles, the following values are valid:
// 1 = small halftone, tone type 4
// 2 = large halftone, tone type 8
// 4 = dithered, tone type 1
DEF PROCdp_decode_options(option%,RETURN strip%,RETURN tone%)
  // try to pick colour, then grey, then mono
  IF option% AND &700000 THEN
   strip%=5
  ELSE
   IF option% AND &700 THEN
    strip%=2
   ELSE
    IF option% AND &70 THEN
     strip%=1
    ELSE
     // force grey if Simple (Mono not allowed)
     IF DPQ$ = "S" THEN strip%=1 ELSE strip%=0
    ENDIF
   ENDIF
  ENDIF

  // find out what is available now
  option%=option%>>(strip%*4)
  tone%=-1
  IF (strip%=5 AND (option% AND 4)<>0) tone%=1
  IF (strip%=2 AND (option% AND 4)<>0) tone%=1
  IF (strip%=1 AND (option% AND 4)<>0) tone%=1
  IF (strip%=0 AND (option% AND 4)<>0) tone%=1

  // if we've failed now, try to pick
  // dithered, large halftone, small halftone

  IF tone%=-1 THEN
    IF option% AND 4 THEN
      tone%=1
    ELSE
      IF option% AND 2 THEN
        tone%=8
      ELSE
        tone%=4
      ENDIF
    ENDIF
  ENDIF
ENDPROC

DEF PROCdp_menu(top$,rebuild%,iconpos%)
  LOCAL wind%,dp_ix%,dp_iy%,dp_i%,dp_x%,dp_j%,dp_k%,xres%,yres%,indt%
  IF rebuild% dp_menu_xpos%=xbuff%!0-64: dp_menu_ypos%=xbuff%!4
  IF iconpos% THEN
    !buff%=xbuff%!12:buff%!4=xbuff%!16:SYS"Wimp_GetIconState",,buff%
    dp_ix%=buff%!16:dp_iy%=buff%!20
    SYS"Wimp_GetWindowState",,buff%
    dp_menu_xpos%=buff%!20+buff%!4+dp_ix%+2
    dp_menu_ypos%=buff%!24+buff%!16+dp_iy%-2
  ENDIF
  wind%=FNprinter_find_window(prnt%,"configure")
  dp_menu_chsn$=top$
  // because of the way the configuration window works,
  // we have to adjust prdt% to point to the printer data
  // record for the printer specified in the window, NOT
  // the current printer.
  prdt%=FNprinter_find_prdata_entry(psup%,FNicon_read(wind%,6))
  CASE top$ OF
    WHEN "ME1"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME1"))
      indt%=(dp_menu%!28 AND &100)<>0
      // get the resolution strings for this printer
      dp_j%=prdt%!20: dp_i%=0: dp_x%=0
      WHILE dp_j%
        dp_k%=!dp_j%!CONST_lstd_1st
        xres%=FNprinter_read_integer_entry(dp_k%,4)
        yres%=FNprinter_read_integer_entry(dp_k%,5)
        nm$=FNprinter_read_string_entry(dp_k%,8)
        IF nm$<>"" THEN
          PROCmenu_item(dp_menu%,dp_i%,nm$,indt%)
        ELSE
          PROCmenu_item(dp_menu%,dp_i%,FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%),indt%)
        ENDIF
        dp_i%+=1
        dp_j%=!dp_j%
      ENDWHILE
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,3))
    WHEN "ME2"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME2"))
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,17))
    WHEN "ME3"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME3"))
      // need to find the right graphics entry for the current resolution
      dp_j%=prdt%!20  // point to first record for this list
      WHILE dp_j%
        dp_k%=!dp_j%!CONST_lstd_1st
        IF (FNicon_read(wind%,3)=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)) OR \
           (FNicon_read(wind%,3)=FNsafe_string(dp_k%!36)) THEN
          // ok - found the graphics entry, now get the options word
          dp_j%=FNdp_get_quality_options(dp_k%): dp_i%=0: dp_x%=0
          IF dp_j% AND &000007 PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO0"),dp_j%)
          IF dp_j% AND &000070 THEN
            IF DPQ$="S" THEN
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1s"),dp_j%>>4)
            ELSE
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1"),dp_j%>>4)
            ENDIF
          ENDIF
          IF dp_j% AND &000700 PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO2"),dp_j%>>8)
          IF dp_j% AND &070000 PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO4"),dp_j%>>16)
          IF dp_j% AND &700000 THEN
            IF DPQ$="S" THEN
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5s"),dp_j%>>20)
            ELSE
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5"),dp_j%>>20)
            ENDIF
          ENDIF
          dp_j%=0
        ELSE
          dp_j%=!dp_j%
        ENDIF
      ENDWHILE
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,15))
    WHEN "ME4"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME4"))
      indt%=(dp_menu%!28 AND &100)<>0
      IF FNprinter_read_list_integer_entry(prdt%,5,2,1)THEN
        // we have draft highlights
        PROCmenu_item(dp_menu%,1,FNmsg_0(psup%!CONST_psup_msg,"TQ1"),indt%)
        IF FNprinter_read_list_integer_entry(prdt%,5,3,1)PROCmenu_item(dp_menu%,2,FNmsg_0(psup%!CONST_psup_msg,"TQ2"),indt%)
      ENDIF
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,14))
    WHEN "ME5"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME5"))
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,23))
    WHEN "MP1"
      PROCcreate_paper_menu(dp_menu%,wind%,27)
  ENDCASE
  PROCdisplay_menu(prnt%,dp_menu%,dp_menu_xpos%,dp_menu_ypos%)
ENDPROC

DEF PROCdp_menu_quality(RETURN dp_menu%,RETURN dp_i%,strip$,tone%)
  LOCAL indt%
  indt%=(dp_menu%!28 AND &100)<>0
  IF tone% AND 1 THEN
    IF DPQ$="S" THEN
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4s"),indt%)
    ELSE
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4"),indt%)
    ENDIF
    dp_i%+=1
  ENDIF
  IF tone% AND 2 THEN
    IF DPQ$="S" THEN
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8s"),indt%)
    ELSE
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8"),indt%)
    ENDIF
    dp_i%+=1
  ENDIF
  IF tone% AND 4 THEN
    IF DPQ$="S" THEN
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1s"),indt%)
    ELSE
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1"),indt%)
    ENDIF
    dp_i%+=1
  ENDIF
ENDPROC

DEF FNdp_hex2(v%)
=RIGHT$("0"+STR$~v%,2)

// text printing code

DEF PROCdp_m8
  LOCAL dp_r%,queu%,tpub%,tprv%,text_prdt%
  VDU: PROCftracef("dp_m8(), reason "+STR$!xbuff%)
  VDU: PROCftracef(STR$~cnfg%)
  VDU: PROCftracef(STR$~cnfg%!CONST_cnfg_dp_text)
  VDU: PROCftracef(STR$~!cnfg%!CONST_cnfg_dp_text)
  text_prdt%=!cnfg%!CONST_cnfg_dp_text
  dp_r%=!xbuff%
  queu%=xbuff%!4
  tpub%=queu%!CONST_queu_tpub
  tprv%=queu%!CONST_queu_tprv
  CASE dp_r% OF
    WHEN  -1: PROCdp_1
    WHEN  -2: PROCdp_2
    WHEN  -4: PROCdp_4
    WHEN  -6: PROCdp_6
    WHEN  -7: PROCdp_7
    WHEN  -9: PROCdp_9
    WHEN -10: PROCdp_10
    WHEN -11: PROCdp_11
    WHEN -12: PROCdp_12
    WHEN -13: PROCdp_13
    WHEN -15: PROCdp_15
    WHEN -16: PROCdp_16
    WHEN -17: PROCdp_17
    WHEN -18: PROCdp_18
    WHEN -19: PROCdp_19
  ENDCASE
  VDU: PROCftracef("Afterwards ...")
  VDU: PROCftracef(STR$~cnfg%)
  VDU: PROCftracef(STR$~cnfg%!CONST_cnfg_dp_text)
  VDU: PROCftracef(STR$~!cnfg%!CONST_cnfg_dp_text)
ENDPROC

DEF PROCdp_1
  // only called if we aren't printing a DP file
  LOCAL dp_i%,dp_i$,psze%,dp_j%,B%,C%,D%
  B%=CONST_ident_TPRV:C%=CONST_tprv_dp_MAX
  tprv%=USR(code_entry%+CONST_entry_heap_claim)
  IFtprv%=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  queu%!CONST_queu_tprv=tprv%
  FOR dp_i%=0 TO CONST_tprv_dp_MAX-4
    tprv%!dp_i%=0
  NEXT
  psze%=prnt%!CONST_prnt_psze
  tprv%!CONST_tprv_dp_left_print=psze%!CONST_psze_tleft
  dp_j%=!cnfg%!CONST_cnfg_dp_flags
  tpub%!CONST_tpub_cc_print=(dp_j% AND &FF00)>>8
  IF dp_j% AND 4 tpub%!CONST_tpub_number_print=TRUE
  IF dp_j% AND 2 tpub%!CONST_tpub_title_print=TRUE
  IF(dp_j%>>CONST_dp_flags_feed_offset AND CONST_dp_flags_feed_width)=CONST_dp_flags_feed_manual tpub%!CONST_tpub_manual_flag=TRUE
  // set the line epilogue string
  IF dp_j% AND 8 THEN
    dp_i$=FNprinter_read_string_entry(text_prdt%,6)
  ELSE
    dp_i$=FNprinter_read_string_entry(text_prdt%,5)
  ENDIF
  B%=A%!CONST_interface_scratch
  $B%=dp_i$
  C%=5
  D%=LEN dp_i$
  tpub%!CONST_tpub_line_epilogue=USR(code_entry%+CONST_entry_store_string)
  dp_i$=STRING$(psze%!CONST_psze_ttop,dp_i$)
  $B%=dp_i$
  C%=5
  D%=LEN dp_i$
  tprv%!CONST_tprv_dp_page_prologue=USR(code_entry%+CONST_entry_store_string)
  tprv%!CONST_tprv_dp_height_print=psze%!CONST_psze_theight
  tpub%!CONST_tpub_line_max=psze%!CONST_psze_theight-psze%!CONST_psze_ttop-psze%!CONST_psze_tbottom
  // set the pointer to the char translation list
  dp_j%=FNprinter_read_integer_entry(prdt%,6)  // point to the PRDT block
  IF dp_j% dp_j%=dp_j%!CONST_prdt_1st
  queu%!CONST_queu_char=dp_j%
ENDPROC

DEF PROCdp_2
  LOCAL dp_s$,pheight%,graphics_prdt%
  // output job start string
  dp_s$=FNprinter_read_string_entry(text_prdt%,7)
  IF dp_s$<>"" BPUT#xbuff%!8,dp_s$;
  dp_s$=FNprinter_read_string_entry(text_prdt%,1)
  pheight%=prnt%!CONST_prnt_psze
  pheight%=pheight%!CONST_psze_theight

  // Ouput set lines if both string exists and page length is not zero.
  // OSS Kludge - if dumper name = "PDumperIW" then output as 144ths of
  // an inch as a four digit decimal number with leading zeros. Assume
  // 6 lines per inch, 144/6 = 24.

  IF dp_s$<>"" AND pheight%<>0 THEN
    graphics_prdt%=!cnfg%!CONST_cnfg_dp_graphics
    IF FNprinter_read_string_entry(FNprinter_read_integer_entry(graphics_prdt%,1),2)="PDumperIW" THEN
      dp_s$+="0000"
      RIGHT$(dp_s$,4)=STR$(pheight%*24)
      BPUT#xbuff%!8,dp_s$;
    ELSE
      BPUT#xbuff%!8,dp_s$+CHR$(pheight%);
    ENDIF
  ENDIF
ENDPROC

DEF PROCdp_4
  // no data to output
  xbuff%?8=0
ENDPROC

DEF PROCdp_6
  // do control code processing
  LOCAL dp_b$
  dp_b$=FNdp_display(xbuff%!8)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_7
  // process a backspace
  LOCAL dp_b$
  dp_b$=FNprinter_read_string_entry(text_prdt%,2)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_9
  LOCAL changed_bits%,clr_bits%,set_bits%,bit%,dp_b$
  changed_bits%=tpub%!CONST_tpub_style_bits EOR xbuff%!8
  clr_bits%=tpub%!CONST_tpub_style_bits AND changed_bits%
  set_bits%=changed_bits% AND NOTclr_bits%
  IF clr_bits% OR set_bits% THEN
    FOR bit%=0 TO 5
      IF clr_bits% AND 1<<bit% THEN dp_b$+=FNdp_style_off(bit%)
      IF set_bits% AND 1<<bit% THEN dp_b$+=FNdp_style_on(bit%)
    NEXT
  ENDIF
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_10
  // start a new line
  LOCAL dp_s$,dp_b$
  tpub%!CONST_tpub_line_page+=1
  tpub%!CONST_tpub_line_doc+=1
  IF tpub%!CONST_tpub_number_print<>0 OR tprv%!CONST_tprv_dp_left_print>0 THEN
    dp_b$=FNdp_font(0)  // pica
    FOR bit%=0 TO 5
     IF tpub%!CONST_tpub_style_bits AND 1<<bit% dp_b$+=FNdp_style_off(bit%)
    NEXT
    dp_b$+=STRING$(tprv%!CONST_tprv_dp_left_print," ")
    IF tpub%!CONST_tpub_number_print THEN
      dp_s$=STR$ tpub%!CONST_tpub_line_doc
      dp_b$+=STRING$(5-LEN dp_s$," ")+dp_s$+" "
    ENDIF
    FOR bit%=0 TO 5
      IF tpub%!CONST_tpub_style_bits AND 1<<bit% dp_b$+=FNdp_style_on(bit%)
    NEXT
  ENDIF
  dp_b$+=FNdp_font(tpub%!CONST_tpub_font_num)+STRING$(tprv%!CONST_tprv_dp_left_ruler," ")
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_11
  LOCAL dp_b$,dp_i%
  PROCdp_10:dp_b$=FNprinter_read_string(tpub%!CONST_tpub_line_epilogue)+$(xbuff%+9)
  PROCdp_10:dp_b$+=FNprinter_read_string(tpub%!CONST_tpub_line_epilogue)+$(xbuff%+9)
  dp_b$+=FNdp_style_on(4)  // superscript
  dp_b$+=FNdp_trans(RIGHT$("  "+STR$ tpub%!CONST_tpub_footnote_num,3)+STRING$(3,FNprinter_read_string_entry(text_prdt%,2)))
  dp_b$+=FNdp_style_off(4)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_12
  LOCAL dp_b$
  dp_b$=FNdp_trans($(xbuff%+8))
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_13
  tpub%!CONST_tpub_font_num=xbuff%!8
  xbuff%?8=0
ENDPROC

DEF PROCdp_15
/*  // end of job */
  LOCAL text_prdt%,tpub%,dp_epilogue$,dp_formfeed$,dp_lineepi$
  IF queu%!CONST_queu_type<>&FF4 THEN
    text_prdt%=!cnfg%!CONST_cnfg_dp_text
    tpub%=queu%!CONST_queu_tpub
    dp_lineepi$=FNprinter_read_string(tpub%!CONST_tpub_line_epilogue)
    IF queu%!CONST_queu_type=&FFF THEN

      // if the page pause flag is true, it means that the user stopped
      // the printing, so don't bother to tidy up

      IF(tpub%!CONST_tpub_pause_flag)=0 THEN
        dp_epilogue$=FNprinter_read_string_entry(text_prdt%,8)
        dp_formfeed$=FNprinter_read_string_entry(text_prdt%,4)
        IF INSTR(dp_epilogue$,dp_lineepi$)<>1 THEN
          IF dp_lineepi$<>"" BPUT#xbuff%!8,dp_lineepi$;
        ENDIF
        IF dp_epilogue$<>"" BPUT#xbuff%!8,dp_epilogue$;
      ENDIF
    ELSE
      // output a blank line between files
      IF dp_lineepi$<>"" BPUT#xbuff%!8,dp_lineepi$;
    ENDIF
  ENDIF
ENDPROC

DEF PROCdp_16
  // process a tab
  LOCAL dp_b$
  dp_b$=FNprinter_read_string_entry(text_prdt%,3)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_17
  // do a formfeed
  LOCAL dp_b$
  dp_b$=FNprinter_read_string_entry(text_prdt%,4)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_18
  // change layout
  LOCAL layout_height%,layout_top%,layout_bottom%,dp_b$,dp_i%,dp_i$,B%,C%,D%,graphics_prdt%
  layout_height%=xbuff%!8
  layout_top%=xbuff%!12
  layout_bottom%=xbuff%!16
  IF layout_height%<=tprv%!CONST_tprv_dp_height_print AND layout_top%<=layout_height%*0.33 AND layout_bottom%<=layout_height%*0.33 THEN
    tpub%!CONST_tpub_line_max=layout_height%-layout_top%-layout_bottom%
    IF tprv%!CONST_tprv_dp_page_prologue THEN
      VDU: PROCftracef("Calling heap free with ptr "+STR$~tprv%!CONST_tprv_dp_page_prologue)
      B%=CONST_ident_GSTR
      C%=tprv%!CONST_tprv_dp_page_prologue
      CALL code_entry%+CONST_entry_heap_free
    ENDIF
    dp_i$=STRING$(layout_top%,FNprinter_read_string(tpub%!CONST_tpub_line_epilogue))
    B%=A%!CONST_interface_scratch
    $B%=dp_i$
    C%=5
    D%=LEN dp_i$
    tprv%!CONST_tprv_dp_page_prologue=USR(code_entry%+CONST_entry_store_string)
    dp_b$=FNprinter_read_string_entry(text_prdt%,1)  // text_page_line

    // OSS Kludge - if dumper name = "PDumperIW" then output as 144ths of
    // an inch as a four digit decimal number with leading zeros. Assume
    // 6 lines per inch, 144/6 = 24.

    IF dp_b$<>"" AND layout_height%<>0 THEN
      graphics_prdt%=!(cnfg%!CONST_cnfg_dp_graphics)
      IF FNprinter_read_string_entry(FNprinter_read_integer_entry(graphics_prdt%,1),2)="PDumperIW" THEN
        dp_b$+="0000"
        RIGHT$(dp_b$,4)=STR$(layout_height%*24)
      ELSE
        dp_b$+=CHR$ layout_height%
      ENDIF
    ENDIF
  ENDIF
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_19
  LOCAL dp_b$,dp_i%,dp_s$,bit%
  dp_b$=FNprinter_read_string(tprv%!CONST_tprv_dp_page_prologue)
  tpub%!CONST_tpub_line_page=0
  tpub%!CONST_tpub_page_num+=1
  IF tpub%!CONST_tpub_title_print THEN
    tpub%!CONST_tpub_line_page+=2
    dp_b$+=FNdp_font(0)  // pica
    FOR bit%=0 TO 5
     IF tpub%!CONST_tpub_style_bits AND 1<<bit% dp_b$+=FNdp_style_off(bit%)
    NEXT
    dp_b$+=STRING$(tprv%!CONST_tprv_dp_left_print+tprv%!CONST_tprv_dp_left_ruler," ")
    dp_s$=FNprinter_read_string(tpub%!CONST_tpub_name)+"   "+FNprinter_read_string(tpub%!CONST_tpub_time)
    dp_s$+="   "+FNmsg_1(psup%!CONST_psup_msg,"PAG",STR$ tpub%!CONST_tpub_page_num)
    dp_b$+=FNdp_trans(dp_s$)
    FOR bit%=0 TO 5
      IF tpub%!CONST_tpub_style_bits AND 1<<bit% dp_b$+=FNdp_style_on(bit%)
    NEXT
    dp_b$+=STRING$(2,FNprinter_read_string(tpub%!CONST_tpub_line_epilogue))
  ENDIF
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF FNdp_trans(dp_s$)
  LOCAL dp_i%,byte%,out$,str$
  IF dp_s$="" THEN =""
  FOR dp_i%=1 TO LEN dp_s$
    byte%=ASC MID$(dp_s$,dp_i%,1)
    str$=""
    CASE TRUE OF
      WHEN byte%<32 OR byte%=127
        IF tpub%!CONST_tpub_cc_print=1 str$=FNdp_display(byte%)
      WHEN byte%>127 AND tpub%!CONST_tpub_cc_print<>0
        IF tpub%!CONST_tpub_cc_print=1 str$=FNdp_display(byte%)
      WHEN tpub%!CONST_tpub_cc_print<>0
        str$=CHR$ byte%
      OTHERWISE
        str$=FNdp_text_char(byte%)
        IF str$="" str$=CHR$ byte%
    ENDCASE
    out$+=str$
  NEXT
=out$

DEF FNdp_text_char(byte%)
  LOCAL dp_p%,dp_s$,dp_i%
  dp_p%=queu%!CONST_queu_char
  WHILE dp_p%
    CASE TRUE OF
      WHEN dp_p%?4=byte%
        dp_i%=dp_p%?5:dp_p%=dp_p%+6
        WHILE dp_i%
          dp_s$+=CHR$ ?dp_p%
          dp_p%+=1
          dp_i%-=1
        ENDWHILE
        =dp_s$
      WHEN dp_p%?4>byte%
        dp_p%=0
      OTHERWISE
        dp_p%=!dp_p%
    ENDCASE
  ENDWHILE
=""

DEF FNdp_display(byte%)
="["+RIGHT$("0"+FNtask_lower(STR$~byte%),2)+"]"

DEF FNdp_style_on(bit%)
  CASE bit% OF
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,13)  // bold on
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,17)  // light on
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,15)  // italic on
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,23)  // underline on
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,19)  // superscript on
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,21)  // subscript on
  ENDCASE
=""
:
DEF FNdp_style_off(bit%)
  CASE bit% OF
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,14)  // bold off
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,18)  // light off
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,16)  // italic off
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,24)  // underline off
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,20)  // superscript off
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,22)  // subscript off
  ENDCASE
=""

DEF FNdp_font(font%)
  CASE font% OF
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,9)  // pica
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,10) // elite
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,11) // condensed
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,12) // expanded
  ENDCASE
=""

DEF FNdp_host_desc
LOCAL a%
a%=buff%!24
=a%!CONST_interface_host_desc
@


4.7
log
@Fix to FNsupported_baudrates to avoid "Bad DIM" when no serialdevdriver
is present.
Fix usb_device_removed to start looking at the list from 0.
Make shared USB printers remember their shared settings.
Change in SuppSrc to avoid oflaofla in the queue display with two digit
connection types (eg.CN13 for USB).
Template changes to connection window.
Added "duplicate" entry to control menu.
Added "install new printer" to iconbar menu (opens PrintDefs:)
Rename control menu to have title "Control"
Added laserjet 5 and 6 paper definitions to the built in sizes so it
doesn't default to size A2.
Fix to store_string so it only asks for the right amount of store.
Change to Makefile to rmensure some modules so SWI names get squished.
Removed a whole load of unused variables.
Plugging in an unknown USB printer prompts the user to tell us which
it really is.
Now appends "#alternateN" to the devicefs filename for USB.
Fix to loading of old style PDF files (borken ungstrans in suppsrc).

Version 1.67. Tagged as 'Manager-1_67'
@
text
@d753 1
a753 1
         (dp_s$=$(dp_k%!36)) THEN
d903 1
a903 1
       (dp_s$=$(dp_k%!36)) THEN
d1134 1
a1134 1
           (FNicon_read(wind%,3)=$(dp_k%!36)) THEN
@


4.6
log
@Addition of USB "plug-and-play" support.This version is a little ropey and
is here for reference rather than use.
Fix to SupportPS to silently ignore the absence of a "Feeds" directory
and simply have a default menu entry instead (OSGBPB -> XOSGBPB).

Version 1.66. Tagged as 'Manager-1_66'
@
text
@d357 1
a357 1
  PROCftracef("File "+disc$+", size "+STR$ file_size%)
d1214 1
a1214 1
  PROCftracef("dp_m8(), reason "+STR$!xbuff%)
@


4.5
log
@Dustbinned all the !Sprites23 files.
Addition of long dump string support (requires appropriate modules too).
Serial baud rates now detected at run time with OS_SerialOp rather than
plucking them out of a messages file.
Debug build made to work (use !MkDebug) outputs much debugging to a RAM
disc.
Adobe PDF support removed (the sources remain) as this is RISC OS Ltd code.
Test PDF files added to the Test directory.

Version 1.65. Tagged as 'Manager-1_65'
@
text
@a19 1
  VDU: PROCftracef("FNdp_support")
a48 1
  VDU: PROCftracef("PROCdp_m1")
a75 1
  VDU: PROCftracef("PROCdp_m2")
d78 1
a78 1
 *     VDU: PROCftracef("*** FREEING R M A ***")
a88 1
  VDU: PROCftracef("PROCdp_m3")
a128 1
  VDU: PROCftracef("PROCdp_m4")
d357 1
a357 1
  VDU: PROCftracef("File "+disc$+", size "+STR$ file_size%)
a381 1
  VDU: PROCftracef("PROCdp_m5")
a403 1
  VDU: PROCftracef("PROCdp_m6")
a634 1
  VDU: PROCftracef("PROCdp_m7")
a646 1
  VDU: PROCftracef("PROCdp_p3")
a651 1
  VDU: PROCftracef("PROCdp_p6")
a700 1
  VDU: PROCftracef("PROCdp_p8")
a722 1
  VDU: PROCftracef("PROCdp_p9")
a804 1
  VDU: PROCftracef("PROCdp_p17")
a854 1
  VDU: PROCftracef("PROCdp_save_configuration")
a964 1
  VDU: PROCftracef("FNdp_res")
a984 1
  VDU: PROCftracef("FNdp_qual")
a1046 1
  VDU: PROCftracef("PROCdp_decode_options")
a1088 1
  VDU: PROCftracef("PROCdp_menu")
a1179 1
  VDU: PROCftracef("PROCdp_menu_quality")
a1207 1
  VDU: PROCftracef("FNdp_hex2")
d1214 1
a1214 1
  VDU: PROCftracef("PROCdp_m8, reason "+STR$!xbuff%)
a1248 1
  VDU: PROCftracef("PROCdp_1")
a1288 1
  VDU: PROCftracef("PROCdp_2")
a1314 1
  VDU: PROCftracef("PROCdp_4")
a1320 1
  VDU: PROCftracef("PROCdp_6")
a1328 1
  VDU: PROCftracef("PROCdp_7")
a1335 1
  VDU: PROCftracef("PROCdp_9")
a1351 1
  VDU: PROCftracef("PROCdp_10")
a1374 1
  VDU: PROCftracef("PROCdp_11")
a1385 1
  VDU: PROCftracef("PROCdp_12")
a1391 1
  VDU: PROCftracef("PROCdp_13")
a1398 1
  VDU: PROCftracef("PROCdp_15")
a1425 1
  VDU: PROCftracef("PROCdp_16")
a1433 1
  VDU: PROCftracef("PROCdp_17")
a1441 1
  VDU: PROCftracef("PROCdp_18")
a1479 1
  VDU: PROCftracef("PROCdp_19")
a1504 1
  VDU: PROCftracef("FNdp_trans")
a1525 1
  VDU: PROCftracef("FNdp_text_char")
a1545 1
  VDU: PROCftracef("FNdp_display")
a1548 1
  VDU: PROCftracef("FNdp_style_on")
a1559 1
  VDU: PROCftracef("FNdp_style_off")
a1570 1
  VDU: PROCftracef("FNdp_font")
@


4.4
log
@Rewrote the LJ and DP code which passes the dump strings down to the driver
as this was passing the wrong format block in the wrong register since
the LJ and DP support code does not match the dumper modules.
This allows a V4 style PDF file (with the dataN: dump strings) to be read
in and the dump strings output correctly.
Note the caveat that the sum of the dump strings must not exceed 200 bytes
as the total block size passed to the dumpers is tiny!

Version 1.64. Tagged as 'Manager-1_64'
@
text
@d1 2
a2 1
REM > Support - for dot matrix printers
d10 1
a10 1
 * - Uses C-style comments where cc -E  complains about REM ones.
d12 1
a12 1
 * 
d51 1
a51 1
  REM psup%!CONST_psup_flags OR= 0
d56 3
a58 3
  REM note that the version number really only reflects
  REM the status of the files being read, ie only change
  REM this number if the file contents change.
d65 2
a66 2
  REM ***** WARNING!
  REM ***** THESE VERSION NUMBERS ARE HARD CODED!
d79 7
a85 7
/* REM We don't want to free up the RMA when we quit, thank you very much
 * REM  IF psup%!CONST_psup_rma_block THEN 
 * REM    VDU: PROCftracef("*** FREEING R M A ***")
 * REM    SYS "ResourceFS_DeregisterFiles",psup%!CONST_psup_rma_block
 * REM    SYS "OS_Module",7,,psup%!CONST_psup_rma_block: REM OSModule_Free
 * REM    psup%!CONST_psup_rma_block=0
 * REM  ENDIF
d90 1
a90 1
  REM initialise the configuration window
d131 1
a131 1
  REM create a CNFG block with suitable defaults
d135 2
a136 2
  REM OSS set the text options to be no highlights, Print linefeeds.
  REM PJC: default changed to be draft with linefeeds.
d140 1
a140 1
    REM no draft - fall back to no highlights
d154 1
a154 1
  REM try to read the default x and y resolutions and name from the PRDT block
d159 1
a159 1
    REM try to find the graphics mode which matches this name
d163 1
a163 1
/*      REM first of all, see if we've run out of modes */
d168 1
a168 1
        REM if no match, try the next mode
d172 1
a172 1
    REM if we found it, remember where it was
d176 1
a176 1
      REM try to find the graphics mode which matches this resolution
d180 1
a180 1
  /*      REM first of all, see if we've run out of modes */
d186 1
a186 1
          REM if no match, try the next mode
d190 1
a190 1
      REM if we found it, remember where it was
d193 1
a193 1
      REM show we didn't match - which we couldn't 'cos we didn't have the values
d198 3
a200 3
/*  REM if didn't match on supplied resolutions, or no resolutions given
 *  REM do a best fit
 */
d202 1
a202 1
    REM OSS set the graphics options to be the highest non-interlaced resolution
d212 1
a212 1
        REM run out of parameters, go back to the last one
d237 1
a237 1
  REM ensure that the module is present in memory
d241 2
a242 2
  REM ensure that the palette file needed at the resolution is cached
  REM bit 23 of palette no. flags whether already ensured or not
d246 2
a247 2
  REM initialise the quality
  REM see if a quality was provided in the PDF
d249 1
a249 1
  REM get the qualities available at the configured resolution
d252 8
a259 8
/*
 *   REM validate values! reset dp_i% to zero if the requested
 *   REM colour and halftone type aren't available at the specified
 *   REM resolution
 *   REM
 *   REM Note that the 'new' strip types (3,4 and 5) cannot be set from
 *   REM the printer definition file, therefore aren't checked for here
 */
d263 1
a263 1
      WHEN 0: REM mono
d271 1
a271 1
      WHEN 1: REM greyscale
d279 1
a279 1
      WHEN 2: REM colour
d301 1
a301 1
/*  REM if the sprite name isn't the same as the class name, store the new sprite name */
d304 3
a306 3
  REM initialise the best paper size we can find ...
  REM start by trying to read the 'default_paper_size' entry
  REM from the PRDT block (entry 7)
d308 1
a308 1
  REM fall back to going for the default
d314 1
a314 1
    REM if we run out of paper entries, go for the first one
d319 1
a319 1
  REM if this printer supports fast parallel, set the appropriate flag
d328 2
a329 2
  REM We use this to load palette files for the printers in order to reduce
  REM the probability of having to ask for the printers disc again later.
d331 1
a331 1
  REM check for out of date palette if we have not ensured this one before (bit 23 of palette number)
d334 4
a337 1
  PROCprinter_write_integer_entry(gprdt%,2,pnum% OR &800000):REM we (will) have ensured it
a338 3
  REM First of all, check if the file exists already
  SYS "OS_File",17,"Resources:"+resource$ TO found_type%,,found_load%,found_exec%,found_size%: REM OS_FileReadNoPath
  
d341 2
a342 2
  SYS "OS_File",17,disc$ TO obj_type%,,load_addr%,exec_addr%,file_size%,obj_attr%: REM OS_FileReadNoPath
  IF obj_type%<>1 SYS "OS_File",19,disc$,obj_type%: REM OS_FileMakeError
d346 2
a347 2
    REM cached palette is not the same as the one on disc
    REM try to remove the cached palette
d361 1
a361 1
  rma_size%=20+(LEN resource$+4 AND NOT 3)+4+(file_size%+3 AND NOT 3): REM Size needed for this file only
d364 4
a367 4
  REM claim some RMA for the file
  SYS "OS_Module",6,,,rma_size%+8 TO,,rma_block%: REM OSModule_Alloc
  REM Put a check tag at the beginning of the block
  !rma_block%=&48434143:REM CACH
d369 1
a369 1
/*  REM Fill in the block */
d376 1
a376 1
  rma_block%!(20+LEN resource$)=0 /* : REM pad with 0's */
d378 2
a379 2
  SYS "OS_File",16,disc$,rma_block%+20+(LEN resource$+4 AND NOT 3)+4: REM OS_FileLoadNoPath
  rma_block%!rma_size%=0: REM Terminator
d384 2
a385 2
  REM cache any palette files that are used by dp printers and ensure
  REM that the relevant PDumper modules are loaded
d391 1
a391 1
      REM got a printer in our class - cache the palette file
d394 1
a394 1
      REM bit 23 of palette no. flags whether already ensured or not
d398 1
a398 1
      REM and ensure the pdumper module
d407 1
a407 1
  REM do whatever is necessary to prime the specified printer
d411 1
a411 1
  REM 7 is the magic number for the dumper driver
d429 4
a432 4
  REM WARNING!
  REM The comparison is made against strip type 2 (colour) or greater
  REM This assumes, therefore, that any strip types that are 2 or greater
  REM are colour which is currently true
d445 1
a445 1
  REM bit 23 of palette no. flags whether already ensured or not
d447 1
d450 1
d452 1
a452 1
  IFpal%=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
d454 1
d456 1
a456 1
  IFinf%=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
d459 4
a462 3
/*  REM if we have strip type 5 and the dumper doesn't support it,
 *  REM deprecate it down to strip type 3
 */
d466 1
a466 1
/*   REM we've selected the dumper driver, so this should work :-) */
d470 1
a470 1
/*  REM this may be necessary, if multiple palettes for one printer */
d473 1
a473 1
  REM Module name:
d477 5
a481 5
  REM set passes per line entry
  REM WARNING!
  REM The comparison is made against strip type 2 (colour) or greater
  REM This assumes, therefore, that any strip types that are 2 or greater
  REM are colour which is currently true
d484 1
a484 1
  REM set strip type field
d487 1
a487 1
  REM set output bpp field
d490 1
a490 1
  REM set num passes field
d493 1
a493 1
  REM OSS Set the NoPageAdvance bit in the flags if paper feed is "Roll"
d497 1
a497 1
  REM OSS Fixup old version numbers by moving it to the new location.
d500 2
a501 2
  REM OSS Set lines per page if version>0. We only need to check the new
  REM version field as the fixup has already been done.
d508 22
a529 37
  IF ((flags% >>> 24) < 5) THEN
    SYS "XPDriver_SetDriver",,FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%,1),1),dmp$,pal%,inf%,flags%
  ELSE
    REM Fill in the inf% block based on the "dataN:" lines in the PDF
    ptr%=CONST_dp_data_text_start:REM Free space for text
    FOR B%=0 TO 19
      a$=FNprinter_read_string_entry(graphics_prdt%,10+B%)
      CASE B% OF
        WHEN0:C%=CONST_dp_data_set_lines:REM data1
        WHEN1:C%=CONST_dp_data_page_start
        WHEN2:C%=CONST_dp_data_form_feed
        WHEN3:C%=CONST_dp_data_page_end
        WHEN4:C%=CONST_dp_data_line_return
        WHEN5:C%=CONST_dp_data_line_skip
        WHEN6:C%=CONST_dp_data_line_end
        WHEN7:C%=CONST_dp_data_line_end_i2
        WHEN8:C%=CONST_dp_data_line_end_i3
        WHEN9:C%=CONST_dp_data_zero_skip
        WHEN10:C%=CONST_dp_data_line_start
        WHEN11:C%=CONST_dp_data_line_start_2
        WHEN12:C%=CONST_dp_data_pass1_start
        WHEN13:C%=CONST_dp_data_pass1_start_2
        WHEN14:C%=CONST_dp_data_pass2_start
        WHEN15:C%=CONST_dp_data_pass2_start_2
        WHEN16:C%=CONST_dp_data_pass3_start
        WHEN17:C%=CONST_dp_data_pass3_start_2
        WHEN18:C%=CONST_dp_data_pass4_start
        WHEN19:C%=CONST_dp_data_pass4_start_2:REM data20
      ENDCASE
      inf%?C%=0
      IFLENa$>0 THEN
        inf%?C%=ptr%-CONST_dp_data_dlm:inf%?ptr%=LENa$:ptr%+=1
        FOR i%=1 TO LENa$:inf%?ptr%=ASC(MID$(a$,i%,1)):ptr%+=1:NEXT
      ENDIF
      IFptr%>=256 THENERROR CONST_error_fatal, FNmsg_1(FNdp_host_desc,"Block overflowed","OKZ")
    NEXT
    SYS "XPDriver_SetDriver",,FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%,1),1),dmp$,pal%,inf%,flags%
d531 1
d539 1
a539 1
  REM point to the chars PRDT block
d581 59
d662 1
a662 1
  REM mouseclick on the configure window
d664 1
a664 1
    WHEN 2: REM menu
d673 1
a673 1
    WHEN 4: REM select
d697 1
a697 1
    WHEN 1: REM adjust
d709 1
a709 1
  REM a key press!
d735 7
a741 7
/*
 * REM menu selections are easy ... we just write the
 * REM selected string into the appropriate icon.
 * REM some other actions may be taken to ensure that
 * REM other choices are OK, but we don't touch any
 * REM data yet.
 */
d759 1
a759 1
    REM if the resolution changes, we may have to change the quality as well
d766 5
a770 5
/*
 *       REM ok - found the pointer to the graphics data, now check the graphics quality
 *       REM basically, we need to see if the request quality is available in this dump
 *       REM if it isn't, we reset it to the best fit we can manage
 */
d819 1
a819 1
    WHEN &502: REM HelpRequest
d910 2
a911 2
  REM point to the resolution possibilities
  dp_j%=prdt%!20: REM printer name is 8, short name is 12, sprite name is 16, resolution is 20
d914 2
a915 2
    dp_k%=!dp_j%!CONST_lstd_1st: REM get the pointer
    REM module is 8, palette is 12, options is 16, pxres is 20, pyres is 24
d964 4
a967 4
/*
 *   REM this printer is ACTIVE!
 *   REM ensure that its details are correct
 */
d969 5
a973 5
/*
 *   REM The front end code will spot that the selected printer has
 *   REM changed and put everything back the way it was
 *   REM PROCselect_printer(0,TRUE,TRUE): Don't do this - calls overlay
 */
d1007 1
a1007 1
REM if colour small halftone present, add colour large halftone
d1009 1
a1009 1
REM if colour available, add new colour options
d1011 4
a1014 4
 t%=FNprinter_read_integer_entry(graphics_definition%,1):REM ptr to module defn
 t%=FNprinter_read_integer_entry(t%,1):REM module number
 REM need to pass the MiscOp through to the dumper driver
 SYS"XPDriver_MiscOpForDriver",&80000002,t%,,,,,,,7 TO t%;c%:REM strip type mask
d1017 1
a1017 1
   REM add strip type 3 based on the greyscale options (or colour, if no grey)
d1023 1
a1023 1
/*   REM add strip type 4 based on the colour options */
d1028 1
a1028 1
   REM add strip type 5 based on the colour options
d1034 1
a1034 1
REM If simple qualities, knock out Mono,256 colours,32k colours
d1038 24
a1061 24
REM If DPQ$ = "S" then the following qualities are
REM actually deemed not to exist:
REM - Any 'Mono'; '256 colours'; '32k colours'

REM This procedure tries to find a good default quality to pick.
REM Modified on 22-Jul-93/3-Dec-93 to pick in this order:
REM Modified on 02-Aug-95 to favour error diff instead of halftone
REM * 16 million, diffused
REM * colour, diffused
REM * grey, diffused
REM * mono, diffused
REM
REM The option value is split into 3 nibbles:
REM &7xxxxx = 24bpp colour, either strip type 3 or 5 depending on
REM                         whether or not it is a full colour system
REM &x7xxxx = 16bpp colour, strip type 4
REM &xxx7xx = colour, strip type 2
REM &xxxx7x = greyscale, strip type 1
REM &xxxxx7 = monochrome, strip type 0
REM
REM Within the 3 nibbles, the following values are valid:
REM 1 = small halftone, tone type 4
REM 2 = large halftone, tone type 8
REM 4 = dithered, tone type 1
d1064 1
a1064 1
  REM try to pick colour, then grey, then mono
d1067 1
a1067 1
  ELSE 
d1074 1
a1074 1
     REM force grey if Simple (Mono not allowed)
d1080 1
a1080 1
/* REM find out what is available now */
d1087 4
a1090 4
/*
 * REM if we've failed now, try to pick
 * REM dithered, large halftone, small halftone
 */
d1117 4
a1120 4
  REM because of the way the configuration window works,
  REM we have to adjust prdt% to point to the printer data
  REM record for the printer specified in the window, NOT
  REM the current printer.
d1126 1
a1126 1
      REM get the resolution strings for this printer
d1147 2
a1148 2
      REM need to find the right graphics entry for the current resolution
      dp_j%=prdt%!20: REM point to first record for this list
d1153 1
a1153 1
          REM ok - found the graphics entry, now get the options word
d1182 1
a1182 1
        REM we have draft highlights
d1230 1
a1230 1
REM text printing code
d1267 1
a1267 1
/*  REM only called if we aren't printing a DP file */
d1284 1
a1284 1
  REM set the line epilogue string
d1302 2
a1303 2
  REM set the pointer to the char translation list
  dp_j%=FNprinter_read_integer_entry(prdt%,6): REM point to the PRDT block
d1311 1
a1311 1
  REM output job start string
d1318 4
a1321 4
  REM Ouput set lines if both string exists and page length is not zero.
  REM OSS Kludge - if dumper name = "PDumperIW" then output as 144ths of
  REM an inch as a four digit decimal number with leading zeros. Assume
 REM 6 lines per inch, 144/6 = 24.
d1336 1
a1336 1
  REM no data to output
d1342 1
a1342 1
  REM do control code processing
d1351 1
a1351 1
  REM process a backspace
d1376 1
a1376 1
  REM start a new line
d1382 1
a1382 1
    dp_b$=FNdp_font(0): REM pica
d1405 1
a1405 1
  dp_b$+=FNdp_style_on(4): REM superscript
d1427 1
a1427 1
/*  REM end of job */
d1435 4
a1438 4
/*
 *     REM if the page pause flag is true, it means that the user stopped
 *     REM the printing, so don't bother to tidy up
 */
d1448 1
a1448 1
      REM output a blank line between files
d1455 1
a1455 1
  REM process a tab
d1464 1
a1464 1
  REM do a formfeed
d1473 1
a1473 1
  REM change layout
d1493 1
a1493 1
    dp_b$=FNprinter_read_string_entry(text_prdt%,1): REM text_page_line
d1495 3
a1497 3
    REM OSS Kludge - if dumper name = "PDumperIW" then output as 144ths of
    REM an inch as a four digit decimal number with leading zeros. Assume
    REM 6 lines per inch, 144/6 = 24.
d1521 1
a1521 1
    dp_b$+=FNdp_font(0): REM pica
d1589 6
a1594 6
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,13): REM bold on
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,17): REM light on
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,15): REM italic on
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,23): REM underline on
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,19): REM superscript on
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,21): REM subscript on
d1601 6
a1606 6
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,14): REM bold off
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,18): REM light off
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,16): REM italic off
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,24): REM underline off
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,20): REM superscript off
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,22): REM subscript off
d1613 4
a1616 4
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,9):REM pica
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,10):REM elite
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,11):REM condensed
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,12):REM expanded
@


4.3
log
@Changes to SetPrint util for additional printer$type understanding
Template tidy up
Change to get version number from VesionNum file
Tweak to SuppSrc for 32 bit high bit addresses
Change !Run file to look for OS3.50 as we use MSR and MRS now
Pick up all but 2 of the changes added to 1.65 on 26-Jun-2001,mostly
cosmetic,with two exceptions
 - use of Parallel_IgnoreErrors
 - warning about dropping "bundled" printer definitions onto it

Version 1.63. Tagged as 'Manager-1_63'
@
text
@d506 2
a507 1
    s%=4*(20+2)
a508 11
      s%+=1+LENFNprinter_read_string_entry(graphics_prdt%,10+B%)
    NEXT
    C%=s%
    B%=CONST_ident_DATA
    newblock%=USR(code_entry%+CONST_entry_heap_claim)
    IFnewblock%=0 ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
    !newblock%=20
    newblock%!4=s%
    C%=newblock%+4*(20+2)
    FOR B%=0 TO 19
      newblock%!(8+4*B%)=C%-newblock%
d510 26
a535 6
      ?C%=LENa$:C%+=1
      IF LEN a$>0 THEN
        FOR i%=1 TO LEN a$
         ?C%=ASC(MID$(a$,i%,1))
         C%+=1
        NEXT
d537 1
d539 1
a539 4
    SYS "XPDriver_SetDriver",,FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%,1),1),dmp$,pal%,inf%,flags%,newblock%
    B%=CONST_ident_DATA
    C%=newblock%
    CALL code_entry%+CONST_entry_heap_free
@


4.2
log
@Version RO_3_71 taken
@
text
@d100 5
d408 1
d502 31
a532 1
  SYS "XPDriver_SetDriver",,FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%,1),1),dmp$,pal%,inf%,flags%
d602 1
a602 1
  LOCAL wind%
d636 2
d644 2
d781 6
d788 18
@


4.1
log
@Initial revision
@
text
@d48 1
a48 1
  LOCAL colours%, pdriverdp%
d69 5
d126 1
a126 1
  LOCAL dp_s$,dp_i%,dp_s%,dp_t%,dp_co%,dp_ht%,B%,C%,dp_inf%,dp_x%,dp_y%
d148 1
a148 1
  REM try to read the default x and y resolutions from the PRDT block
d151 3
a153 2
  IF (dp_x%<>0 AND dp_y%<>0) THEN
    REM try to find the graphics mode which matches this resolution
d161 1
a161 2
        dp_s%=FNprinter_read_integer_entry(B%,4)
        dp_t%=FNprinter_read_integer_entry(B%,5)
d163 1
a163 1
        IFdp_s%<>dp_x% OR dp_t%<>dp_y% C%+=1
d165 1
a165 1
    UNTIL C%=-1 OR (dp_s%=dp_x% AND dp_t%=dp_y%)
d169 21
a189 2
    REM show we didn't match - which we couldn't 'cos we didn't have the values
    C%=-1
d236 3
a238 2
  dp_s$=STR$(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,2))
  PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_s$,"Printers:Palettes."+dp_s$,TRUE)
d318 1
a318 1
DEF PROCdp_ensure_resource_file(resource$,disc$,reload_if_outofdate%)
d320 1
a320 1
  LOCAL found_type%,found_load%,found_exec%,found_size%,c%,a%,w%
d325 5
d332 1
d388 3
a390 2
      dp_pal$=STR$FNprinter_read_integer_entry(dp_graphics_prdt%,2)
      PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_pal$,"Printers:Palettes."+dp_pal$,TRUE)
d438 2
a439 1
  dp_s$=STR$ FNprinter_read_integer_entry(graphics_prdt%,2): REM suffix
d459 2
a460 2
/*  REM hopefully the following isn't necessary, but cache it just in case */
  PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_s$,"Printers:Palettes."+dp_s$,FALSE)
d666 2
a667 1
      IF dp_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)THEN
d675 6
a680 4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"): dp_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"): dp_j%=2
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"): dp_j%=4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"): dp_j%=5
d685 4
a688 2
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"): dp_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"): dp_i%=1
d703 1
a703 1
          PROCicon_write(wind%,15,FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$ dp_j%)+", "+FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$ dp_i%))
d794 2
a795 1
    IF dp_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)THEN
d809 6
a814 4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"): dp_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"): dp_j%=2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"): dp_j%=4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"): dp_j%=5
d819 4
a822 2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"): dp_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"): dp_i%=1
d856 1
a856 1
  LOCAL xres%,yres%,graphics_prdt%
d861 14
a874 1
=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%)
d877 1
a877 1
  LOCAL dp_i%,dp_s$,dp_t$
d880 1
a880 3
  dp_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(dp_i% AND &FF))
  dp_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((dp_i% AND &FF00)>>8))
=dp_s$+", "+dp_t$
d895 1
a895 1
   REM add strip type 3 based on the greyscale options
d897 1
d912 2
d916 4
d922 5
a926 4
REM * 16 million, large halftone
REM * colour, large halftone
REM * grey, large halftone
REM * mono, large halftone
d952 2
a953 1
     strip%=0
d961 4
a964 4
  IF (strip%=5 AND (option% AND 1)<>0) tone%=8
  IF (strip%=2 AND (option% AND 1)<>0) tone%=8
  IF (strip%=1 AND (option% AND 2)<>0) tone%=8
  IF (strip%=0 AND (option% AND 2)<>0) tone%=8
d967 1
a967 1
 * REM large halftone, small halftone, dithered
d970 2
a971 2
    IF option% AND 2 THEN
      tone%=8
d973 3
a975 1
      IF option% AND 1 THEN
a976 2
      ELSE
        tone%=1
d1010 6
a1015 1
        PROCmenu_item(dp_menu%,dp_i%,FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%),indt%)
d1029 2
a1030 1
        IF FNicon_read(wind%,3)=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)THEN
d1034 7
a1040 1
          IF dp_j% AND &000070 PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1"),dp_j%>>4)
d1043 7
a1049 1
          IF dp_j% AND &700000 PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5"),dp_j%>>20)
d1079 5
a1083 1
    PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4"),indt%)
d1087 5
a1091 1
    PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8"),indt%)
d1095 5
a1099 1
    PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1"),indt%)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d48 1
a48 1
  LOCAL colours%, pdriverdp%, exists%
a68 5
/* do not allow this now
  SYS "XOS_ReadVarVal","Printers$DPLJfullQ",,-1,,3 TO,,exists%
  IF exists% THEN DPQ$="F" ELSE DPQ$="S"
*/
DPQ$="S"
d121 1
a121 1
  LOCAL dp_s$,dp_nm$,dp_nm2$,dp_i%,dp_s%,dp_t%,dp_co%,dp_ht%,B%,C%,dp_inf%,dp_x%,dp_y%
d143 1
a143 1
  REM try to read the default x and y resolutions and name from the PRDT block
d146 2
a147 3
  dp_nm$=FNprinter_read_string_entry(prdt%,12)
  IF dp_nm$<>"" THEN
    REM try to find the graphics mode which matches this name
d155 2
a156 1
        dp_nm2$=FNprinter_read_string_entry(B%,8)
d158 1
a158 1
        IFdp_nm$<>dp_nm2$ C%+=1
d160 1
a160 1
    UNTIL C%=-1 OR dp_nm$=dp_nm2$
d164 2
a165 21
    IF (dp_x%<>0 AND dp_y%<>0) THEN
      REM try to find the graphics mode which matches this resolution
      C%=1
      REPEAT
        B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
  /*      REM first of all, see if we've run out of modes */
        IF B%=0 THEN
          C%=-1
        ELSE
          dp_s%=FNprinter_read_integer_entry(B%,4)
          dp_t%=FNprinter_read_integer_entry(B%,5)
          REM if no match, try the next mode
          IFdp_s%<>dp_x% OR dp_t%<>dp_y% C%+=1
        ENDIF
      UNTIL C%=-1 OR (dp_s%=dp_x% AND dp_t%=dp_y%)
      REM if we found it, remember where it was
      IF C%<>-1 dp_i%=C%
    ELSE
      REM show we didn't match - which we couldn't 'cos we didn't have the values
      C%=-1
    ENDIF
d212 2
a213 3
  REM bit 23 of palette no. flags whether already ensured or not
  dp_s$=STR$(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,2) AND &7FFFFF)
  PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_s$,"Printers:Palettes."+dp_s$,!cnfg%!CONST_cnfg_dp_graphics)
d293 1
a293 1
DEF PROCdp_ensure_resource_file(resource$,disc$,gprdt%)
d295 1
a295 1
  LOCAL found_type%,found_load%,found_exec%,found_size%,c%,a%,w%,pnum%,reload_if_outofdate%
a299 5
  REM check for out of date palette if we have not ensured this one before (bit 23 of palette number)
  pnum% = FNprinter_read_integer_entry(gprdt%,2)
  reload_if_outofdate% = ((pnum% AND &800000) = 0)
  PROCprinter_write_integer_entry(gprdt%,2,pnum% OR &800000):REM we (will) have ensured it

a301 1
  
d357 2
a358 3
      REM bit 23 of palette no. flags whether already ensured or not
      dp_pal$=STR$(FNprinter_read_integer_entry(dp_graphics_prdt%,2) AND &7FFFFF)
      PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_pal$,"Printers:Palettes."+dp_pal$,dp_graphics_prdt%)
d406 1
a406 2
  REM bit 23 of palette no. flags whether already ensured or not
  dp_s$=STR$(FNprinter_read_integer_entry(graphics_prdt%,2) AND &7FFFFF)
d426 2
a427 2
/*  REM this may be necessary, if multiple palettes for one printer */
  PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_s$,"Printers:Palettes."+dp_s$,graphics_prdt%)
d633 1
a633 2
      IF (dp_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)) OR \
         (dp_s$=$(dp_k%!36)) THEN
d641 4
a644 6
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  dp_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): dp_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  dp_j%=2
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  dp_j%=4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  dp_j%=5
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): dp_j%=5
d649 2
a650 4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  dp_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): dp_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  dp_i%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): dp_i%=1
d665 1
a665 1
          PROCicon_write(wind%,15,FNdp_qual_name(dp_j% + (dp_i% << 8)))
d756 1
a756 2
    IF (dp_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)) OR \
       (dp_s$=$(dp_k%!36)) THEN
d770 4
a773 6
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  dp_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): dp_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  dp_j%=2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  dp_j%=4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  dp_j%=5
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): dp_j%=5
d778 2
a779 4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  dp_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): dp_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  dp_i%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): dp_i%=1
d813 1
a813 1
  LOCAL xres%,yres%,graphics_prdt%,nm$
d818 1
a818 14
  nm$=FNprinter_read_string_entry(graphics_prdt%,8)
  IF nm$="" THEN  nm$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%)
=nm$

DEF FNdp_qual_name(dp_i%)
  LOCAL dp_s$,dp_t$
  IF DPQ$ = "S" THEN
    dp_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(dp_i% AND &FF)+"s")
    dp_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((dp_i% AND &FF00)>>8)+"s")
  ELSE
    dp_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(dp_i% AND &FF))
    dp_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((dp_i% AND &FF00)>>8))
  ENDIF
=dp_s$+", "+dp_t$
d821 1
a821 1
  LOCAL dp_i%
d824 3
a826 1
=FNdp_qual_name(dp_i%)
d841 1
a841 1
   REM add strip type 3 based on the greyscale options (or colour, if no grey)
a842 1
   IF c%=0 THEN c%=(s% AND &700)>>4
a856 2
REM If simple qualities, knock out Mono,256 colours,32k colours
IF DPQ$ = "S" s%=s% AND &700070
a858 4
REM If DPQ$ = "S" then the following qualities are
REM actually deemed not to exist:
REM - Any 'Mono'; '256 colours'; '32k colours'

d861 4
a864 5
REM Modified on 02-Aug-95 to favour error diff instead of halftone
REM * 16 million, diffused
REM * colour, diffused
REM * grey, diffused
REM * mono, diffused
d890 1
a890 2
     REM force grey if Simple (Mono not allowed)
     IF DPQ$ = "S" THEN strip%=1 ELSE strip%=0
d898 4
a901 4
  IF (strip%=5 AND (option% AND 4)<>0) tone%=1
  IF (strip%=2 AND (option% AND 4)<>0) tone%=1
  IF (strip%=1 AND (option% AND 4)<>0) tone%=1
  IF (strip%=0 AND (option% AND 4)<>0) tone%=1
d904 1
a904 1
 * REM dithered, large halftone, small halftone
d907 2
a908 2
    IF option% AND 4 THEN
      tone%=1
d910 2
a911 2
      IF option% AND 2 THEN
        tone%=8
d913 1
a913 1
        tone%=4
d947 1
a947 6
        nm$=FNprinter_read_string_entry(dp_k%,8)
        IF nm$<>"" THEN
          PROCmenu_item(dp_menu%,dp_i%,nm$,indt%)
        ELSE
          PROCmenu_item(dp_menu%,dp_i%,FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%),indt%)
        ENDIF
d961 1
a961 2
        IF (FNicon_read(wind%,3)=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)) OR \
           (FNicon_read(wind%,3)=$(dp_k%!36)) THEN
d965 1
a965 7
          IF dp_j% AND &000070 THEN
            IF DPQ$="S" THEN
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1s"),dp_j%>>4)
            ELSE
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1"),dp_j%>>4)
            ENDIF
          ENDIF
d968 1
a968 7
          IF dp_j% AND &700000 THEN
            IF DPQ$="S" THEN
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5s"),dp_j%>>20)
            ELSE
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5"),dp_j%>>20)
            ENDIF
          ENDIF
d998 1
a998 5
    IF DPQ$="S" THEN
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4s"),indt%)
    ELSE
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4"),indt%)
    ENDIF
d1002 1
a1002 5
    IF DPQ$="S" THEN
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8s"),indt%)
    ELSE
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8"),indt%)
    ENDIF
d1006 1
a1006 5
    IF DPQ$="S" THEN
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1s"),indt%)
    ELSE
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1"),indt%)
    ENDIF
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

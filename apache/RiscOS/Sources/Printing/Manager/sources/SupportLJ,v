head	4.6;
access;
symbols
	Manager-1_89:4.6
	Manager-1_88:4.6
	Manager-1_87:4.6
	Manager-1_86:4.6
	Manager-1_85:4.6
	Manager-1_84:4.6
	Manager-1_83:4.6
	Manager-1_82:4.6
	Manager-1_81:4.5
	Manager-1_80:4.5
	Manager-1_79:4.5
	Manager-1_78:4.5
	Manager-1_77:4.5
	Manager-1_76:4.5
	Manager-1_75:4.5
	Manager-1_74:4.5
	Manager-1_73:4.5
	Manager-1_72:4.5
	Manager-1_71:4.5
	Manager-1_70:4.5
	Manager-1_69:4.5
	Manager-1_68:4.5
	Manager-1_67:4.5
	Manager-1_66:4.5
	Manager-1_65:4.5
	Manager-1_64:4.4
	Manager-1_63:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2
	rthornb_UrsulaBuild-21May1998:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.7.1
	Ursula_31Mar1998:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	RO_3_71:4.1.3.1
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2013.12.17.19.21.58;	author jlee;	state Exp;
branches;
next	4.5;
commitid	EkfBVBL8hUnBkwhx;

4.5
date	2003.01.17.14.37.36;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2003.01.06.22.27.42;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.26.10.55.47;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	97.05.13.14.49.35;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.47.59;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.47.59;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.59.40;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.24.54;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.28.52;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Fix countless null pointer dereferences
Detail:
  sources/Export, sources/RunImage, sources/Sparrow, sources/SupportDP, sources/SupportLJ:
  - Add new FNsafe_string() function to provide a safe version of the $... operator which will return an empty string when given a null pointer
  - Update lots of uses of the $... operator to use FNsafe_string() instead
  - Fix a few other null pointer dereferences due to BASIC's lack of lazy evaluation in IF statements (i.e. IF A% AND A%!0 ...)
  - Fixed a few other miscellaneous null pointer dereferences seen during testing
Admin:
  Fixes PrinterManager generally crashing horribly when high processor vectors are enabled
  Tested with loading up and configuring assorted printer definitions and doing a couple of test print jobs on a BB-xM with high processor vectors enabled


Version 1.82. Tagged as 'Manager-1_82'
@
text
@REM >SupportLJ
REM for Laser/Desk Jet printers

/* Changes list:
 *
 * AMcC: 20-Sep-94
 * - Now pre-processed using CPP (cc -E) instead of basic prog 'Constants'.
 *   Allows us to use the same include file "Values" as used by front-end
 *   prog (!Printers.!RunImage).
 * - Uses C-style comments where cc -E  complains about // ones.
 * - All constants changed from the form CONST_name% to CONST_name.
 *
 */

#include "Values.h"
#include "Trace.h"

DEF FNlj_support(buff%)
  LOCAL reason%,psup%,prnt%,prdt%,cnfg%,xbuff%,psize_head%,code_entry%
  reason%=buff%!0
  psup%=buff%!4
  prnt%=buff%!8
  xbuff%=buff%!12
  psize_head%=buff%!16
  code_entry%=buff%!20
  IF prnt% THEN
    prdt%=FNprinter_find_prdata_entry(psup%,$prnt%!CONST_prnt_type)
    cnfg%=prnt%!CONST_prnt_cnfg
  ENDIF
  CASE reason% OF
    WHEN -1: PROClj_m1
    WHEN -2: PROClj_m2
    WHEN -3: PROClj_m3
    WHEN -4: PROClj_m4
    WHEN -5: PROClj_m5
    WHEN -6: PROClj_m6
    WHEN -7: PROClj_m7
    WHEN -8: PROClj_m8
    WHEN 3: PROClj_p3
    WHEN 6: PROClj_p6
    WHEN 8: PROClj_p8
    WHEN 9: PROClj_p9
    WHEN 17,18: PROClj_p17
  ENDCASE
=FALSE

DEF PROClj_m1
  LOCAL colours%, pdriverdp%, exists%
  // psup%!CONST_psup_flags OR= 0
  psup%!CONST_psup_type=&FF4
  psup%!CONST_psup_text=%1001
  psup%!CONST_psup_cnfg=CONST_cnfg_lj_MAX/4
  psup%!CONST_psup_vsn=2
  // note that the version number really only reflects
  // the status of the files being read, ie only change
  // this number if the file contents change.
  psup%!CONST_psup_dvsn=100
  psup%!CONST_psup_rma_block=0
  colours%=FNrmload_latest_module("ColourTrans","System:Modules.Colours")
  IFFNrmload_latest_module("PDriver","Printers:Modules.PDriver")
  IFFNrmload_latest_module("PDumperSupport","Printers:Modules.PDumperSpt")
  pdriverdp%=FNrmload_latest_module("PDriverDP","Printers:Modules.PDriverDP")
  // ***** WARNING!
  // ***** THESE VERSION NUMBERS ARE HARD CODED!
  IFpdriverdp%>400 AND colours%<150 THEN
    SYS"Wimp_ReportError",FNmsg_0(FNlj_host_desc,"WA12"), 1 OR 1<<4,FNmsg_1(FNlj_host_desc,"ER2",FNmsg_0(FNlj_host_desc,"ID"))
  ENDIF
/* do not allow this any more
  SYS "XOS_ReadVarVal","Printers$DPLJfullQ",,-1,,3 TO,,exists%
  IF exists% THEN LJQ$="F" ELSE LJQ$="S"
*/
LJQ$="S"
ENDPROC

DEF PROClj_m2
  // We don't want to free up the RMA when we quit, thank you very much
  //  IF psup%!CONST_psup_rma_block THEN
  //    VDU: PROCftracef("*** FREEING R M A ***")
  //    SYS "ResourceFS_DeregisterFiles",psup%!CONST_psup_rma_block
  //    SYS "OS_Module",7,,psup%!CONST_psup_rma_block: // OSModule_Free
  //    psup%!CONST_psup_rma_block=0
  //  ENDIF
ENDPROC

DEF PROClj_m3
  // initialise the configuration window
  LOCAL config%,lj_i%,lj_j%
  config%=FNprinter_find_window(prnt%,"configure")
  PROCicon_write(config%,27,FNprinter_read_string(prnt%!CONST_prnt_name))
  PROCicon_write(config%,6,$prnt%!CONST_prnt_type)
  PROCicon_write(config%,3,FNlj_res(cnfg%))
  PROCicon_write(config%,15,FNlj_qual(cnfg%))
  lj_i%=!cnfg%!CONST_cnfg_lj_flags
  lj_j%=lj_i% AND 1
  PROCicon_write(config%,17,FNmsg_0(psup%!CONST_psup_msg,"PF"+STR$ lj_j%))
  IF FNhas_external_config_app(prnt%) THEN
    PROCicon_unshade(config%,33)
  ELSE
    PROCicon_shade(config%,33)
  ENDIF
  IF prnt%!CONST_prnt_flags AND 1<<6 THEN
    PROCicon_shade(config%,8)
    PROCicon_shade(config%,11)
    PROCicon_shade(config%,13)
    PROCicon_shade(config%,14)
    PROCicon_shade(config%,22)
    PROCicon_shade(config%,23)
  ELSE
    PROCicon_unshade(config%,8)
    PROCicon_unshade(config%,11)
    PROCicon_unshade(config%,13)
    PROCicon_unshade(config%,14)
    PROCicon_unshade(config%,22)
    PROCicon_unshade(config%,23)
    lj_j%=lj_i% AND %000010
    IF lj_j% PROCicon_select(config%,8)ELSE PROCicon_deselect(config%,8)
    lj_j%=lj_i% AND %000100
    IF lj_j% PROCicon_select(config%,11)ELSE PROCicon_deselect(config%,11)
    lj_j%=lj_i% AND %001000
    PROCicon_write(config%,13,FNmsg_0(psup%!CONST_psup_msg,"PO"+STR$(lj_j%>>3)))
    lj_j%=(lj_i% AND &F00)>>8
    PROCicon_write(config%,22,FNmsg_0(psup%!CONST_psup_msg,"CC"+STR$ lj_j%))
  ENDIF
  lj_i%=prnt%!CONST_prnt_psze
  PROCicon_write(config%,25,$lj_i%!CONST_psze_name)
ENDPROC

DEF PROClj_m4
  // create a CNFG block with suitable defaults
  LOCAL lj_s$,lj_nm$,lj_nm2$,lj_i%,lj_s%,lj_t%,lj_x%,lj_y%,lj_co%,lj_ht%,B%,C%
  // PJC: set the text options to be draft
  cnfg%!CONST_cnfg_lj_flags=FNstore_integer(%010000)
  // portrait mode is no-highlights entry
  lj_i%=FNprinter_read_list_integer_entry(prdt%,5,1,1)
  IF lj_i% THEN
    B%=CONST_ident_POTR
    C%=4
    cnfg%!CONST_cnfg_lj_text=USR(code_entry%+CONST_entry_heap_claim)
    IF cnfg%!CONST_cnfg_lj_text=0 ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
    !cnfg%!CONST_cnfg_lj_text=lj_i%
  ELSE
    prnt%!CONST_prnt_flags=prnt%!CONST_prnt_flags OR 1<<6
  ENDIF

  // try to read the default x and y resolutions and name from the PRDT block
  lj_x%=FNprinter_read_integer_entry(prdt%,8)
  lj_y%=FNprinter_read_integer_entry(prdt%,9)
  lj_nm$=FNprinter_read_string_entry(prdt%,12)
  IF lj_nm$<>"" THEN
    // try to find the graphics mode which matches this name
    C%=1
    REPEAT
      B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
      // first of all, see if we've run out of modes
      IF B%=0 THEN
        C%=-1
      ELSE
        lj_nm2$=FNprinter_read_string_entry(B%,8)
        // if no match, try the next mode
        IFlj_nm$<>lj_nm2$ C%+=1
      ENDIF
    UNTIL C%=-1 OR lj_nm$=lj_nm2$
    // if we found it, remember where it was
    IF C%<>-1 lj_i%=C%
  ELSE
    IF (lj_x%<>0 AND lj_y%<>0) THEN
      // try to find the graphics mode which matches this resolution
      C%=1
      REPEAT
        B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
        // first of all, see if we've run out of modes
        IF B%=0 THEN
          C%=-1
        ELSE
          lj_s%=FNprinter_read_integer_entry(B%,4)
          lj_t%=FNprinter_read_integer_entry(B%,5)
          // if no match, try the next mode
          IFlj_s%<>lj_x% OR lj_t%<>lj_y% C%+=1
        ENDIF
      UNTIL C%=-1 OR (lj_s%=lj_x% AND lj_t%=lj_y%)
      // if we found it, remember where it was
      IF C%<>-1 lj_i%=C%
    ELSE
      // show we didn't match - which we couldn't 'cos we didn't have the values
      C%=-1
    ENDIF
  ENDIF

  // if didn't match on supplied resolutions, or no resolutions given
  // set the graphics options to be the closest resolution to 300 x 300

  IF C%=-1 THEN
    C%=1
    lj_i%=FALSE
    REPEAT
      B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
      IF B%=0 THEN
        // run out of parameters, go back to the last one
        C%-=1: lj_i%=TRUE
      ELSE
        lj_x%=FNprinter_read_integer_entry(B%,4)
        lj_y%=FNprinter_read_integer_entry(B%,5)
        IF lj_x%<300 OR lj_y%<300 C%+=1 ELSE lj_i%=TRUE
      ENDIF
    UNTIL lj_i%
    lj_i%=C%
  ENDIF

  B%=CONST_ident_POTR
  C%=4
  cnfg%!CONST_cnfg_lj_graphics=USR(code_entry%+CONST_entry_heap_claim)
  IF cnfg%!CONST_cnfg_lj_graphics=0 ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
  !cnfg%!CONST_cnfg_lj_graphics=FNprinter_read_list_integer_entry(prdt%,4,lj_i%,1)

  // ensure that the module is present in memory
  lj_s$=FNprinter_read_string_entry(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_lj_graphics,1),2)
  IFFNrmload_latest_module(lj_s$, "Printers:PDumpers."+lj_s$)

  // ensure that the palette file needed at the resolution is cached
  // bit 23 of palette no. flags whether already ensured or not
  lj_s$=STR$(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_lj_graphics,2) AND &7FFFFF)
  PROClj_ensure_resource_file("Resources.Printers.Palettes."+lj_s$,"Printers:Palettes."+lj_s$,!cnfg%!CONST_cnfg_lj_graphics)

  // initialise the quality
  // see if a quality was provided in the PDF
  lj_i%=FNprinter_read_integer_entry(prdt%,10)
  // get the qualities available at the configured resolution
  lj_s%=FNlj_get_quality_options(!cnfg%!CONST_cnfg_lj_graphics)
  IF lj_i%<>0 THEN

    // validate values! reset lj_i% to zero if the requested
    // colour and halftone type aren't available at the specified
    // resolution

    lj_co%=lj_i% AND &FF
    lj_ht%=(lj_i% AND &FF00)>>8
    CASE lj_co% OF
      WHEN 0: // mono
        IF (lj_s% AND 7) THEN
          IF lj_ht%=4 AND (lj_s% AND 1)=0 lj_i%=0
          IF lj_ht%=8 AND (lj_s% AND 2)=0 lj_i%=0
          IF lj_ht%=1 AND (lj_s% AND 4)=0 lj_i%=0
        ELSE
          lj_i%=0
        ENDIF
      WHEN 1: // greyscale
        IF (lj_s% AND &70) THEN
          IF lj_ht%=4 AND ((lj_s%>>4) AND 1)=0 lj_i%=0
          IF lj_ht%=8 AND ((lj_s%>>4) AND 2)=0 lj_i%=0
          IF lj_ht%=1 AND ((lj_s%>>4) AND 4)=0 lj_i%=0
        ELSE
          lj_i%=0
        ENDIF
      WHEN 2: // colour
        IF (lj_s% AND &700) THEN
          IF lj_ht%=4 AND ((lj_s%>>8) AND 1)=0 lj_i%=0
          IF lj_ht%=8 AND ((lj_s%>>8) AND 2)=0 lj_i%=0
          IF lj_ht%=1 AND ((lj_s%>>8) AND 4)=0 lj_i%=0
        ELSE
          lj_i%=0
        ENDIF
    ENDCASE
  ENDIF

  IF lj_i%<>0 THEN
    cnfg%!CONST_cnfg_lj_options=FNstore_integer(lj_i%)
  ELSE
    PROClj_decode_options(lj_s%,lj_co%,lj_ht%)
    cnfg%!CONST_cnfg_lj_options=FNstore_integer(lj_ht%<<8 OR lj_co%)
  ENDIF

  $buff%=FNprinter_read_string_entry(prdt%,2)
  B%=buff%
  C%=2
  prnt%!CONST_prnt_name=USR(code_entry%+CONST_entry_store_string)
  lj_s$=FNprinter_read_string_entry(prdt%,3)
  // if the sprite name isn't the same as the class name, store the new sprite name
  IF lj_s$<>"lj" $buff%=lj_s$:B%=buff%:C%=2:prnt%!CONST_prnt_sprt=USR(code_entry%+CONST_entry_store_string)

  // initialise the best paper size we can find ...
  // start by trying to read the 'default_paper_size' entry
  // from the PRDT block (entry 7)

  lj_s$=FNprinter_read_string_entry(prdt%,7)
  // fall back to going for the default
  IF lj_s$="" lj_s$=FNmsg_0(psup%!CONST_psup_msg,"PAP")

  lj_i%=psize_head%
  WHILE lj_s$<>FNprinter_read_string(lj_i%!CONST_psze_name)
    lj_i%=lj_i%!CONST_psze_next
    // if we run out of paper entries, go for the first one
    IF lj_i%=0 lj_i%=psize_head%: lj_s$=FNprinter_read_string(lj_i%!CONST_psze_name)
  ENDWHILE
  prnt%!CONST_prnt_psze=lj_i%

  // if this printer supports fast parallel, set the appropriate flag
  lj_i%=FNprinter_read_integer_entry(prdt%,11)
  IFlj_i%<>0 prnt%!CONST_prnt_flags = prnt%!CONST_prnt_flags OR (1<<7)

ENDPROC

DEF PROClj_ensure_resource_file(resource$,disc$,gprdt%)
  LOCAL obj_type%,load_addr%,exec_addr%,file_size%,obj_attr%,rma_size%,rma_block%
  LOCAL found_type%,found_load%,found_exec%,found_size%,c%,a%,w%,pnum%,reload_if_outofdate%
  // We use this to load palette files for the printers in order to reduce
  // the probability of having to ask for the printers disc again later.

  // check for out of date palette if we have not ensured this one before (bit 23 of palette number)
  pnum% = FNprinter_read_integer_entry(gprdt%,2)
  reload_if_outofdate% = ((pnum% AND &800000) = 0)
  PROCprinter_write_integer_entry(gprdt%,2,pnum% OR &800000) // we (will) have ensured it

  // First of all, check if the file exists already
  SYS "OS_File",17,"Resources:"+resource$ TO found_type%,,found_load%,found_exec%,found_size%: // OS_FileReadNoPath

  IF found_type% AND reload_if_outofdate%=FALSE ENDPROC

  SYS "OS_File",17,disc$ TO obj_type%,,load_addr%,exec_addr%,file_size%,obj_attr%: // OS_FileReadNoPath
  IF obj_type%<>1 SYS "OS_File",19,disc$,obj_type%: // OS_FileMakeError

  IF found_type% THEN
    IFfound_load%=load_addr% AND found_exec%=exec_addr% AND found_size%=file_size% ENDPROC
    // cached palette is not the same as the one on disc
    // try to remove the cached palette
    c%=OPENIN("Resources:"+resource$)
    IFc%=0 ERROR CONST_error_ok, FNmsg_1(FNlj_host_desc,"OKBB",resource$)
    SYS"OS_FSControl",21,c% TO ,a%,w%
    CLOSE#c%
    IF(w%AND&FF)<>46 ERROR CONST_error_ok, FNmsg_1(FNlj_host_desc,"OKBC",resource$)
    a%-=(LENresource$+4ANDNOT3)+4
    a%-=20
    IFa%!-4 = &48434143 THEN
      SYS"ResourceFS_DeregisterFiles",a%
      SYS"OS_Module",7,,a%-4
    ENDIF
  ENDIF

  rma_size%=20+(LEN resource$+4 AND NOT 3)+4+(file_size%+3 AND NOT 3): // Size needed for this file only

  // claim some RMA for the file
  SYS "OS_Module",6,,,rma_size%+8 TO,,rma_block%: // OSModule_Alloc
  // Put a check tag at the beginning of the block
  !rma_block%=&48434143 // CACH
  rma_block%+=4
  // Fill in the block
  rma_block%!0=rma_size%
  rma_block%!4=load_addr%
  rma_block%!8=exec_addr%
  rma_block%!12=file_size%
  rma_block%!16=obj_attr%
  $(rma_block%+20)=resource$
  rma_block%!(20+LEN resource$)=0 /*: // pad with 0's */
  rma_block%!(20+(LEN resource$+4 AND NOT 3))=file_size%+4
  SYS "OS_File",16,disc$,rma_block%+20+(LEN resource$+4 AND NOT 3)+4: // OS_FileLoadNoPath
  rma_block%!rma_size%=0: // Terminator
  SYS "ResourceFS_RegisterFiles",rma_block%
ENDPROC

DEF PROClj_m5
  // cache any palette files that are used by lj printers and ensure
  // that the relevant PDumper modules are loaded
  LOCAL lj_prnt%,lj_cnfg%,lj_graphics_prdt%,lj_pal$
  lj_prnt%=prnt%
  WHILE lj_prnt%>0
    IF lj_prnt%!CONST_prnt_psup=psup% THEN
      // got a printer in our class - cache the palette file
      lj_cnfg%=lj_prnt%!CONST_prnt_cnfg
      lj_graphics_prdt%=!lj_cnfg%!CONST_cnfg_lj_graphics
      // bit 23 of palette no. flags whether already ensured or not
      lj_pal$=STR$(FNprinter_read_integer_entry(lj_graphics_prdt%,2) AND &7FFFFF)
      PROClj_ensure_resource_file("Resources.Printers.Palettes."+lj_pal$,"Printers:Palettes."+lj_pal$,lj_graphics_prdt%)

      // and ensure the pdumper module
      lj_pal$=FNprinter_read_string_entry(FNprinter_read_integer_entry(lj_graphics_prdt%,1),2)
      IFFNrmload_latest_module(lj_pal$, "Printers:PDumpers."+lj_pal$)
    ENDIF
    lj_prnt%=lj_prnt%!CONST_prnt_next
  ENDWHILE
ENDPROC

DEF PROClj_m6
  // do whatever is necessary to prime the specified printer
  LOCAL lj_s$,lj_t$,lj_i%,lj_j%,xres%,yres%,halftone%,ptr%,pal%,dmp$,inf%,strip%,graphics_prdt%,text_prdt%
  LOCAL format_print%,local_pl%,local_pr%,local_pb%,local_pt%,local_ph%,local_A%,local_B%,local_G%,local_B$,B%,C%
  LOCAL flags%,newblock%,i%,a$,s%
  // 7 is the magic number for the dumper driver
  IF(lj_i% AND 1)=0 SYS"XPDriver_SelectDriver",7
  lj_s$=FNprinter_read_string(prnt%!CONST_prnt_name)
  IF lj_s$="" THEN
    lj_s$=$prnt%!CONST_prnt_type
    IF LEN lj_s$>20 THEN
      lj_i%=LEN lj_s$
      WHILE MID$(lj_s$,lj_i%,1)<>" " AND lj_i%>0
        lj_i%-=1
      ENDWHILE
      IF lj_i% lj_s$=LEFT$(lj_s$,lj_i%-1)ELSE lj_s$=LEFT$(lj_s$,20)
    ENDIF
  ENDIF
  graphics_prdt%=!cnfg%!CONST_cnfg_lj_graphics
  xres%=FNprinter_read_integer_entry(graphics_prdt%,4)
  yres%=FNprinter_read_integer_entry(graphics_prdt%,5)
  halftone%=(!cnfg%!CONST_cnfg_lj_options AND &FF00)>>8
  strip%=!cnfg%!CONST_cnfg_lj_options AND &FF
  // WARNING!
  // The comparison is made against strip type 2 (colour) or greater
  // This assumes, therefore, that any strip types that are 2 or greater
  // are colour which is currently true
  IF (strip% >= 2) THEN
    SYS"XPDriver_SetInfo",,xres%,yres%,1,lj_s$,xres%/halftone%,yres%/halftone% TO ptr%;lj_i%
  ELSE
    SYS"XPDriver_SetInfo",,xres%,yres%,0,lj_s$,xres%/halftone%,yres%/halftone% TO ptr%;lj_i%
  ENDIF
  IF (lj_i% AND 1) AND (ptr%<>0) THEN
    lj_s$="": ptr%+=4
    WHILE ?ptr%: lj_s$+=CHR$ ?ptr%: ptr%+=1: ENDWHILE
    ERROR CONST_error_ok,lj_s$
    ENDPROC
  ENDIF

  // bit 23 of palette no. flags whether already ensured or not
  lj_s$=STR$(FNprinter_read_integer_entry(graphics_prdt%,2) AND &7FFFFF)

  B%=CONST_ident_PDBF
  C%=256

  pal%=USR(code_entry%+CONST_entry_heap_claim)
  IF pal% ELSE ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
  $pal%="Resources:$.Resources.Printers.Palettes."+lj_s$

  inf%=USR(code_entry%+CONST_entry_heap_claim)
  IF inf% ELSE ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
  $inf%=FNprinter_read_string_entry(graphics_prdt%,6)
  strip%=!cnfg%!CONST_cnfg_lj_options AND &FF

  // if we have strip type 5 and the dumper doesn't support it,
  // deprecate it down to strip type 3

  IF strip%=5 THEN
   lj_i%=FNprinter_read_integer_entry(graphics_prdt%,1)
   lj_i%=FNprinter_read_integer_entry(lj_i%,1)
   SYS"XPDriver_MiscOp",&80000002,lj_i% TO ptr%;lj_i%
   IF(lj_i%AND1)=0 IF ptr%<>&80000002 IF(ptr% AND (1<<5))=0 strip%=3
  ENDIF
  // this may be necessary, if multiple palettes for one printer
  PROClj_ensure_resource_file("Resources.Printers.Palettes."+lj_s$,"Printers:Palettes."+lj_s$,graphics_prdt%)

  // Module name:
  lj_s$=FNprinter_read_string_entry(FNprinter_read_integer_entry(graphics_prdt%,1),2)
  dmp$="RMLoad Printers:PDumpers."+lj_s$+CHR$ 13

  // set passes per line entry
  // WARNING!
  // The comparison is made against strip type 2 (colour) or greater
  // This assumes, therefore, that any strip types that are 2 or greater
  // are colour which is currently true
  IF strip%>=2 inf%?CONST_lj_pass_per_line=4 ELSE inf%?CONST_lj_pass_per_line=1

  // set strip type field
  inf%?CONST_lj_strip_type=strip%

  // set output bpp field
  IF strip%=0 inf%?CONST_lj_output_bpp=1 ELSE inf%?CONST_lj_output_bpp=8

  // set num passes field
  IF strip%=3 inf%?CONST_dp_no_passes=3 ELSE inf%?CONST_dp_no_passes=1

  flags%=FNprinter_read_integer_entry(graphics_prdt%,7)
  IF ((flags% >>> 24) < 5) = 0 THEN
    ptr%=CONST_dp_data_text_start // Free space for text
    ptr% = FNlj_dataN_block(inf%, ptr%, 0,  CONST_dp_data_set_lines)      // data1
    ptr% = FNlj_dataN_block(inf%, ptr%, 1,  CONST_dp_data_page_start)
    ptr% = FNlj_dataN_block(inf%, ptr%, 2,  CONST_dp_data_form_feed)
    ptr% = FNlj_dataN_block(inf%, ptr%, 3,  CONST_dp_data_page_end)
    ptr% = FNlj_dataN_block(inf%, ptr%, 4,  CONST_dp_data_line_return)
    ptr% = FNlj_dataN_block(inf%, ptr%, 5,  CONST_dp_data_line_skip)
    ptr% = FNlj_dataN_block(inf%, ptr%, 6,  CONST_dp_data_line_end)
    ptr% = FNlj_dataN_block(inf%, ptr%, 7,  CONST_dp_data_line_end_i2)
    ptr% = FNlj_dataN_block(inf%, ptr%, 8,  CONST_dp_data_line_end_i3)
    ptr% = FNlj_dataN_block(inf%, ptr%, 9,  CONST_dp_data_zero_skip)
    ptr% = FNlj_dataN_block(inf%, ptr%, 10, CONST_dp_data_line_start)
    ptr% = FNlj_dataN_block(inf%, ptr%, 11, CONST_dp_data_line_start_2)
    ptr% = FNlj_dataN_block(inf%, ptr%, 12, CONST_dp_data_pass1_start)
    ptr% = FNlj_dataN_block(inf%, ptr%, 13, CONST_dp_data_pass1_start_2)
    ptr% = FNlj_dataN_block(inf%, ptr%, 14, CONST_dp_data_pass2_start)
    ptr% = FNlj_dataN_block(inf%, ptr%, 15, CONST_dp_data_pass2_start_2)
    ptr% = FNlj_dataN_block(inf%, ptr%, 16, CONST_dp_data_pass3_start)
    ptr% = FNlj_dataN_block(inf%, ptr%, 17, CONST_dp_data_pass3_start_2)
    ptr% = FNlj_dataN_block(inf%, ptr%, 18, CONST_dp_data_pass4_start)
    ptr% = FNlj_dataN_block(inf%, ptr%, 19, CONST_dp_data_pass4_start_2)  // data20
  ENDIF
  SYS "XPDriver_SetDriver",, FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%, 1), 1), dmp$, pal%, inf%, flags%
  B%=CONST_ident_PDBF
  C%=pal%
  CALL code_entry%+CONST_entry_heap_free
  C%=inf%
  CALL code_entry%+CONST_entry_heap_free
  SYS"OS_CLI","Unset PDriver$TextChars1"

  // point to the chars PRDT block
  lj_i%=FNprinter_read_integer_entry(prdt%,6): // point to the chars PRDT block
  IF lj_i% THEN
    lj_i%=lj_i%!CONST_prdt_1st
    WHILE lj_i%
      IF lj_i%?CONST_char_char=ASC"£" THEN
        lj_s$=FNlj_hex2(ASC"£")+FNlj_hex2(lj_i%?CONST_char_len)
        ptr%=lj_i%+CONST_char_trans
        lj_i%=lj_i%?CONST_char_len
        WHILE lj_i%
          lj_s$+=FNlj_hex2(?ptr%)
          ptr%+=1
          lj_i%-=1
        ENDWHILE
        SYS"OS_CLI","Set PDriver$TextChars1 "+lj_s$
      ELSE
        lj_i%=lj_i%!CONST_char_next
      ENDIF
    ENDWHILE
  ENDIF

  text_prdt%=!cnfg%!CONST_cnfg_lj_text
  lj_i%=prnt%!CONST_prnt_psze
  lj_s$=$lj_i%!CONST_psze_name
  lj_j%=0
  WHILE MID$(lj_s$,lj_j%,1)<>" " AND lj_j%<=LEN lj_s$
    lj_j%+=1
  ENDWHILE
  lj_t$="PT_"+LEFT$(lj_s$,lj_j%-1)
  lj_s$=FNmsg_0(psup%!CONST_psup_msg,lj_t$)
  IF lj_s$=lj_t$ lj_s$=FNmsg_0(psup%!CONST_psup_msg,"PT_A4")
  IF !cnfg%!CONST_cnfg_lj_flags AND 1 THEN
    lj_t$=FNmsg_0(psup%!CONST_psup_msg,"MANUAL_FEED")
  ELSE
    lj_t$=FNmsg_0(psup%!CONST_psup_msg,"AUTO_FEED")
  ENDIF
  SYS"OS_CLI","Set PDumperLJ$Extra "+FNungstrans(lj_t$+lj_s$)
  format_print%=(!cnfg%!CONST_cnfg_lj_flags AND 8)>>3
  local_pl%=lj_i%!CONST_psze_lmargin
  local_pr%=lj_i%!CONST_psze_rmargin
  local_pb%=lj_i%!CONST_psze_bmargin
  local_pt%=lj_i%!CONST_psze_tmargin
  local_ph%=lj_i%!CONST_psze_pheight
  IF format_print%=0 THEN
    local_yt%=0
    WHILE local_yt%*12000<local_ph%-local_pt%
      local_yt%+=1
    ENDWHILE
    local_pt%=local_ph%-local_yt%*12000: // 72000 DIV 6
    local_B%=(local_pr%-local_pl%)*10 DIV 72000
    local_A%=(local_pt%-local_pb%)*6 DIV 72000
  ELSE
    local_yt%=0
    WHILE local_yt%*9000<local_pl%
      local_yt%+=1
    ENDWHILE
    local_pl%=local_yt%*9000: // 72000 DIV 8
    local_B%=((local_pt%-local_pb%)*16.66 DIV 72000 - 1)DIV 2
    local_A%=(local_pr%-local_pl%)*8 DIV 72000
  ENDIF
  IF !cnfg%!CONST_cnfg_lj_flags AND %1000 local_G%=2 ELSE local_G%=0
  lj_t$="-Ph "+STR$ local_A%+" -Pw "+STR$ local_B%+" -Mt "+STR$ lj_i%!CONST_psze_ttop
  lj_t$+=" -Mb "+STR$ lj_i%!CONST_psze_tbottom+" -Ml "+STR$ lj_i%!CONST_psze_tleft
  lj_t$+=" -Mr "+STR$ lj_i%!CONST_psze_tright+" -Th "+STR$ local_G%+" -Nl |<10>|<13>"
  local_B$=FNungstrans(FNungstrans(FNlj_font(0)))
  IF local_B$<>"" lj_t$+=" -Rs "+local_B$
  local_B$=FNungstrans(FNungstrans(FNlj_font(2)))
  IF local_B$<>"" lj_t$+=" -Cd "+local_B$
  SYS"OS_CLI","Set PDriver$TextPage "+lj_t$
ENDPROC

// Fill in the inf% block based on the "dataN:" lines in the PDF
DEF FNlj_dataN_block(inf%, ptr%, B%, C%)
  LOCAL type%, str%, len%

Ftracef("graphics_prdt%=&"+STR$~graphics_prdt%+", inf%=&"+STR$~inf%+", ptr%=&"+STR$~ptr%+", B%="+STR$B%)

  // Get a pointer to the string and read its type
  str% = FNprinter_read_string_pointer(graphics_prdt%, 10 + B%)
Ftracef("str%=&"+STR$~str%)
  IF str% = 0 THEN
    inf%?C% = 0
    =ptr%
  ENDIF

#ifdef Trace
  CASE str%!-4 OF
    WHEN CONST_ident_STRG
      Ftracef("dataN: type=STRG (CR-terminated)")
    WHEN CONST_ident_STR0
      Ftracef("dataN: type=STR0 (zero-terminated)")
    WHEN CONST_ident_GSTR
      Ftracef("dataN: type=GSTR (byte counted)")
    WHEN CONST_ident_LSTR
      Ftracef("dataN: type=LSTR (word counted)")
    OTHERWISE
      Ftracef("dataN: type=UNKNOWN")
  ENDCASE
#endif

  // If this entry is not of long string type, return an error
  IF str%!-4 <> CONST_ident_LSTR THEN
    // This was probably the result
    ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc, "FAM")
  ENDIF

  // Read string length and point to start of string
  len%  = !str%
  str% += 4
  Ftracef("len%="+STR$len%)

  // If the string is of zero length, record that and exit
  IF len% = 0 THEN
    inf%?C% = 0
    =ptr%
  ENDIF

#ifdef Trace
  // Make sure that we're writing to word-aligned addresses
  IF (inf% + ptr%) AND %11 THEN
    ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc, "FAN")
  ENDIF
#endif

  // Copy the string and return pointer for next entry (long string format)
  inf%?C%        = ptr% - CONST_dp_data_dlm
  inf%!ptr%      = len% << 8
  !(inf%+ptr%+4) = str%
=ptr% + 8

DEF PROClj_m7
  LOCAL queu%,lj_p%,B%,C%
  queu%=!xbuff%
  lj_p%=queu%!CONST_queu_tprv
  IF lj_p% THEN
    B%=CONST_ident_TPRV
    C%=lj_p%
    CALL code_entry%+CONST_entry_heap_free
    queu%!CONST_queu_tprv=0
  ENDIF
ENDPROC

DEF PROClj_p3
  SYS"Wimp_CloseWindow",,xbuff%
ENDPROC

DEF PROClj_p6
  LOCAL wind%,dummy%
  // mouseclick on the configure window
  CASE xbuff%!8 OF
    WHEN 2: // menu
      CASE xbuff%!16 OF
        WHEN 20: PROClj_menu("ME1",TRUE,TRUE)
        WHEN 18: PROClj_menu("ME2",TRUE,TRUE)
        WHEN  4: PROClj_menu("ME3",TRUE,TRUE)
        WHEN 14: PROClj_menu("ME4",TRUE,TRUE)
        WHEN 23: PROClj_menu("ME5",TRUE,TRUE)
        WHEN 26: PROClj_menu("MP1",TRUE,TRUE)
      ENDCASE
    WHEN 4: // select
      CASE xbuff%!16 OF
        WHEN 24
          wind%=xbuff%!12
          PROClj_save_configuration(wind%)
          !xbuff%=wind%
          SYS"Wimp_CloseWindow",,xbuff%
        WHEN 20: PROClj_menu("ME1",TRUE,TRUE)
        WHEN 18: PROClj_menu("ME2",TRUE,TRUE)
        WHEN  4: PROClj_menu("ME3",TRUE,TRUE)
        WHEN 14: PROClj_menu("ME4",TRUE,TRUE)
        WHEN 23: PROClj_menu("ME5",TRUE,TRUE)
        WHEN 26: PROClj_menu("MP1",TRUE,TRUE)
        WHEN 30
          !xbuff%=xbuff%!12
          SYS"Wimp_CloseWindow",,xbuff%
        WHEN 33
          dummy%=FNexternal_config_app(prnt%)
      ENDCASE
    WHEN 1: // adjust
      CASE xbuff%!16 OF
        WHEN 24
          wind%=xbuff%!12
          PROClj_save_configuration(wind%)
        WHEN 33
          dummy%=FNexternal_config_app(prnt%)
      ENDCASE
  ENDCASE
ENDPROC

DEF PROClj_p8
  // a key press!
  LOCAL lj_i%
  lj_i%=psup%!CONST_psup_wind
  WHILE lj_i%
    IF lj_i%!CONST_wind_hand=!xbuff% THEN
      IF xbuff%!24=13 THEN
        CASE $(lj_i%+CONST_wind_name)OF
          WHEN "configure"
            SYS "Wimp_CloseWindow",,xbuff%
            PROClj_save_configuration(!xbuff%)
        ENDCASE
      ELSE
        SYS "Wimp_ProcessKey",xbuff%!24
      ENDIF

      ENDPROC
    ENDIF

    lj_i%=lj_i%!CONST_wind_next
  ENDWHILE
ENDPROC

DEF PROClj_p9
  LOCAL adjust%,wind%,icon%,ptr%,xres%,yres%

  // menu selections are easy ... we just write the
  // selected string into the appropriate icon.
  // some other actions may be taken to ensure that
  // other choices are OK, but we don't touch any
  // data yet.

  wind%=FNprinter_find_window(prnt%,"configure")
  adjust%=FNwas_adjust_used
  CASE lj_menu_chsn$ OF
    WHEN "ME1": icon%=3
    WHEN "ME2": icon%=17
    WHEN "ME3": icon%=15
    WHEN "ME4": icon%=13
    WHEN "ME5": icon%=22
    WHEN "MP1": icon%=25
  ENDCASE
  ptr%=lj_menu%+28+!xbuff%*24
  IF ptr%!8 AND &100 THEN
    PROCicon_write(wind%,icon%,$ptr%!12)
  ELSE
    PROCicon_write(wind%,icon%,$(ptr%+12))
  ENDIF
  IF lj_menu_chsn$="ME1" THEN
    // if the resolution changes, we may have to change the quality as well
    lj_j%=prdt%!20
    lj_s$=FNicon_read(wind%,3)
    WHILE lj_j%
      lj_k%=!lj_j%!CONST_lstd_1st
      IF (lj_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !lj_k%!20,STR$ !lj_k%!24)) OR \
         (lj_s$=FNsafe_string(lj_k%!36)) THEN

        // ok - found the pointer to the graphics data, now check the graphics quality
        // basically, we need to see if the request quality is available in this dump
        // if it isn't, we reset it to the best fit we can manage

        lj_s$=FNicon_read(wind%,15): lj_i%=INSTR(lj_s$,",")
        CASE LEFT$(lj_s$,lj_i%-1)OF
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  lj_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): lj_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  lj_j%=2
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  lj_j%=4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  lj_j%=5
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): lj_j%=5
          OTHERWISE:                                 lj_j%=0
        ENDCASE
        lj_s$=MID$(lj_s$,lj_i%+2)
        CASE lj_s$ OF
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  lj_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): lj_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  lj_i%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): lj_i%=1
          OTHERWISE:                                 lj_i%=4
        ENDCASE
        lj_k%=FNlj_get_quality_options(lj_k%)
        IF(lj_k% AND (7<<(lj_j%*4)))=0 lj_j%=-1
        IF lj_j%<>-1 THEN
          lj_j%=lj_k%>>lj_j%*4
          CASE lj_i% OF
            WHEN 4: IF(lj_j% AND 1)=0 lj_i%=-1
            WHEN 8: IF(lj_j% AND 2)=0 lj_i%=-1
            WHEN 1: IF(lj_j% AND 4)=0 lj_i%=-1
          ENDCASE
        ENDIF
        IF lj_j%=-1 OR lj_i%=-1 THEN
          PROClj_decode_options(lj_k%,lj_j%,lj_i%)
          PROCicon_write(wind%,15,FNlj_qual_name(lj_j% + (lj_i% << 8)))
        ENDIF
        lj_j%=0
      ELSE
        lj_j%=!lj_j%
      ENDIF
    ENDWHILE
  ENDIF
  IF adjust% THEN
    SYS"Wimp_GetPointerInfo",,xbuff%
    PROClj_menu(lj_menu_chsn$,FALSE,FALSE)
  ENDIF
ENDPROC

DEF PROClj_p17
  LOCAL wind%,lj_s$,lj_t$
  CASE xbuff%!16 OF
    WHEN &502
      wind%=psup%!CONST_psup_wind
      WHILE wind%
        IF wind%!CONST_wind_hand=xbuff%!32 THEN
          CASE $(wind%+CONST_wind_name) OF
            WHEN "configure"
              lj_s$=STR$ xbuff%!36
              CASE xbuff%!36 OF
                WHEN 8,11,12
                  IF FNicon_set(xbuff%!32,xbuff%!36)lj_s$+="b" ELSE lj_s$+="a"
              ENDCASE
              lj_t$=FNmsg_0(psup%!CONST_psup_msg,"CON"+lj_s$)
              IF lj_t$="CON"+lj_s$ lj_t$=FNmsg_0(psup%!CONST_psup_msg,"CON")
              PROCinteractive_help(lj_t$)
          ENDCASE
          wind%=0
        ELSE
          wind%=wind%!CONST_wind_next
          IF wind%=0 PROCinteractive_help(FNmsg_0(psup%!CONST_psup_msg,"H"+lj_menu_chsn$))
        ENDIF
      ENDWHILE
    WHEN &8014B
      /*PrintInterrogate*/
      CASE xbuff%!20 OF
      WHEN 0
        IF prnt% AND xbuff%!24=prnt% THEN PROClj_interrogate0
      ENDCASE
  ENDCASE
ENDPROC

DEF PROClj_interrogate0
  LOCAL a$,sender%
  /* Ack the message */
  sender%=xbuff%!4
  xbuff%!12=xbuff%!8
  SYS "Wimp_SendMessage",19,xbuff%,sender%
  /* Construct and send the reply */
  xbuff%!28=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_lj_graphics,2)
  xbuff%!32=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_lj_graphics,3)
  xbuff%!36=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_lj_graphics,4)
  xbuff%!40=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_lj_graphics,5)
  xbuff%!44=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_lj_graphics,7)
  a$=FNprinter_read_string_entry(!cnfg%!CONST_cnfg_lj_graphics,8)+CHR$(0)
  $(xbuff%+48)=a$
  !xbuff%=(48+3+LENa$)ANDNOT3
  SYS "Wimp_SendMessage",17,xbuff%,sender%
ENDPROC

DEF PROClj_save_configuration(window%)
  LOCAL lj_i%,lj_j%,lj_k%,lj_s$,B%,C%
  prdt%=FNprinter_find_prdata_entry(psup%,FNicon_read(window%,6))
  PROCfree_structure(prnt%!CONST_prnt_name)
  $buff%=FNicon_read(window%,27)
  B%=buff%
  C%=2
  prnt%!CONST_prnt_name=USR(code_entry%+CONST_entry_store_string)
  lj_i%=cnfg%
  FOR lj_j%=1 TO CONST_cnfg_lj_MAX/4
    PROCfree_structure(!lj_i%)
    !lj_i%=0
    lj_i%+=4
  NEXT
  lj_j%=0
  IF FNicon_read(window%,17)=FNmsg_0(psup%!CONST_psup_msg,"PF1")lj_j%+=1
  IF FNicon_set(window%,8)lj_j%+=2
  IF FNicon_set(window%,11)lj_j%+=4
  IF FNicon_read(window%,13)=FNmsg_0(psup%!CONST_psup_msg,"PO1")lj_j%+=8
  CASE FNicon_read(window%,22)OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CC1"): lj_j%+=1<<8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CC2"): lj_j%+=1<<9
  ENDCASE
  cnfg%!CONST_cnfg_lj_flags=FNstore_integer(lj_j%)
  // portrait mode is no-highlights entry
  // landscape mode is drafts entry
  IF lj_j% AND 8 THEN
    lj_j%=FNprinter_read_list_integer_entry(prdt%,5,2,1)
  ELSE
    lj_j%=FNprinter_read_list_integer_entry(prdt%,5,1,1)
  ENDIF
  IF lj_j% THEN
    B%=CONST_ident_POTR
    C%=4
    cnfg%!CONST_cnfg_lj_text=USR(code_entry%+CONST_entry_heap_claim)
    IF cnfg%!CONST_cnfg_lj_text=0 ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
    !cnfg%!CONST_cnfg_lj_text=lj_j%
    prnt%!CONST_prnt_flags=prnt%!CONST_prnt_flags AND NOT(1<<6)
  ELSE
    prnt%!CONST_prnt_flags=prnt%!CONST_prnt_flags OR 1<<6
  ENDIF
  // point to the resolution possibilities
  lj_j%=prdt%!20: // printer name is 8, short name is 12, sprite name is 16, resolution is 20
  lj_s$=FNicon_read(window%,3)
  WHILE lj_j%
    lj_k%=!lj_j%!CONST_lstd_1st: // get the pointer
    // module is 8, palette is 12, options is 16, pxres is 20, pyres is 24
    IF (lj_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !lj_k%!20,STR$ !lj_k%!24)) OR \
       (lj_s$=FNsafe_string(lj_k%!36)) THEN
      lj_j%=0
    ELSE
      lj_j%=!lj_j%
    ENDIF
  ENDWHILE
  B%=CONST_ident_POTR
  C%=4
  cnfg%!CONST_cnfg_lj_graphics=USR(code_entry%+CONST_entry_heap_claim)
  IF cnfg%!CONST_cnfg_lj_graphics=0 ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
  !cnfg%!CONST_cnfg_lj_graphics=lj_k%
  lj_s$=FNicon_read(window%,15)
  lj_i%=INSTR(lj_s$,",")
  CASE LEFT$(lj_s$,lj_i%-1)OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  lj_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): lj_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  lj_j%=2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  lj_j%=4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  lj_j%=5
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): lj_j%=5
    OTHERWISE: lj_j%=0
  ENDCASE
  lj_s$=MID$(lj_s$,lj_i%+2)
  CASE lj_s$ OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  lj_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): lj_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  lj_i%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): lj_i%=1
    OTHERWISE:                                 lj_i%=4
  ENDCASE
  cnfg%!CONST_cnfg_lj_options=FNstore_integer((lj_i%<<8)+lj_j%)
  lj_j%=prnt%!CONST_prnt_psze
  lj_s$=FNicon_read(window%,25)
  IF $lj_j%!CONST_psze_name<>lj_s$ THEN
    lj_i%=psize_head%
    WHILE lj_i%
      IF $lj_i%!CONST_psze_name=lj_s$ THEN
        prnt%!CONST_prnt_psze=lj_i%
        lj_i%=0
      ELSE
        lj_i%=!lj_i%
      ENDIF
    ENDWHILE
  ENDIF

  IF prnt%!CONST_prnt_icon<>-1 THEN
    // this printer is ACTIVE!
    // ensure that its details are correct
    PROCselect_printer(prnt%,TRUE,FALSE)
    // The front end code will spot that the selected printer has
    // changed and put everything back the way it was
    // PROCselect_printer(0,TRUE,TRUE): // don't do this (calls into overlay). JRC 12 Feb '92
  ENDIF
ENDPROC

DEF FNlj_res(cnfg%)
  LOCAL xres%,yres%,graphics_prdt%,nm$
  graphics_prdt%=!cnfg%!CONST_cnfg_lj_graphics
  xres%=FNprinter_read_integer_entry(graphics_prdt%,4)
  yres%=FNprinter_read_integer_entry(graphics_prdt%,5)
  nm$=FNprinter_read_string_entry(graphics_prdt%,8)
  IF nm$="" THEN  nm$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%)
=nm$

DEF FNlj_qual_name(lj_i%)
  LOCAL lj_s$,lj_t$
  IF LJQ$ = "S" THEN
    lj_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(lj_i% AND &FF)+"s")
    lj_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((lj_i% AND &FF00)>>8)+"s")
  ELSE
    lj_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(lj_i% AND &FF))
    lj_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((lj_i% AND &FF00)>>8))
  ENDIF
=lj_s$+", "+lj_t$

DEF FNlj_qual(cnfg%)
  LOCAL lj_i%
  lj_i%=!cnfg%!CONST_cnfg_lj_options
=FNlj_qual_name(lj_i%)

DEF FNlj_get_quality_options(graphics_definition%)
LOCAL s%,c%,t%
s%=FNprinter_read_integer_entry(graphics_definition%,3)
// if colour small halftone present, add colour large halftone
IF (s% AND &100) s% = s% OR &200
// if colour available, add new colour options
IF (s% AND &700) THEN
 t%=FNprinter_read_integer_entry(graphics_definition%,1) // ptr to module defn
 t%=FNprinter_read_integer_entry(t%,1) // module number
 // pass the MiscOp through to the dumper driver
 SYS"XPDriver_MiscOpForDriver",&80000002,t%,,,,,,,7 TO t%;c% // strip type mask
 IF(c%AND1)=0 AND t%<>&80000002 THEN
  IF (t% AND (1<<3)) THEN
   // add strip type 3 based on the greyscale options (or colour, if no grey)
   c%=s% AND &70
   IF c%=0 THEN c%=(s% AND &700)>>4
   s%=s% OR (c%<<16)
  ENDIF
  IF (t% AND (1<<4)) THEN
   // add strip type 4 based on the colour options
   c%=s% AND &700
   s%=s% OR (c%<<8)
  ENDIF
  IF (t% AND (1<<5)) THEN
   // add strip type 5 based on the colour options
   c%=s% AND &700
   s%=s% OR (c%<<12)
  ENDIF
 ENDIF
ENDIF
// If simple qualities, knock out Mono,256 colours,32k colours
IF LJQ$ = "S" s%=s% AND &700070
=s%

// If LJQ$ = "S" then the following qualities are
// actually deemed not to exist:
// - Any 'Mono'; '256 colours'; '32k colours'

// This procedure tries to find a good default quality to pick.
// Modified on 22-Jul-93/3-Dec-93 to pick in this order:
// Modified on 02-Aug-95 to favour error diff instead of halftone
// * 16 million, diffused
// * colour, diffused
// * grey, diffused
// * mono, diffused
//
// The option value is split into 3 nibbles:
// &7xxxxx = 24bpp colour, either strip type 3 or 5 depending on
//                        whether or not it is a full colour system
// &x7xxxx = 16bpp colour, strip type 4
// &xxx7xx = colour, strip type 2
// &xxxx7x = greyscale, strip type 1
// &xxxxx7 = monochrome, strip type 0
//
// Within the 3 nibbles, the following values are valid:
// 1 = small halftone, tone type 4
// 2 = large halftone, tone type 8
// 4 = dithered, tone type 1
DEF PROClj_decode_options(option%,RETURN strip%,RETURN tone%)
  // try to pick colour, then grey, then mono
  IF option% AND &700000 THEN
   strip%=5
  ELSE
   IF option% AND &700 THEN
    strip%=2
   ELSE
    IF option% AND &70 THEN
     strip%=1
    ELSE
     // force grey if "Simple" (Mono not allowed)
     IF LJQ$ = "S" THEN strip%=1 ELSE strip%=0
    ENDIF
   ENDIF
  ENDIF

  // find out what is available now
  option%=option%>>(strip%*4)
  tone%=-1
  IF (strip%=5 AND (option% AND 4)<>0) tone%=1
  IF (strip%=2 AND (option% AND 4)<>0) tone%=1
  IF (strip%=1 AND (option% AND 4)<>0) tone%=1
  IF (strip%=0 AND (option% AND 4)<>0) tone%=1

  // if we've failed now, try to pick
  // dithered, large halftone, small halftone

  IF tone%=-1 THEN
    IF option% AND 4 THEN
      tone%=1
    ELSE
      IF option% AND 2 THEN
        tone%=8
      ELSE
        tone%=4
      ENDIF
    ENDIF
  ENDIF
ENDPROC

DEF PROClj_menu(top$,rebuild%,iconpos%)
  LOCAL wind%,lj_ix%,lj_iy%,lj_i%,lj_x%,lj_j%,lj_k%,xres%,yres%,indt%,nm$
  IF rebuild% THEN
    lj_menu_xpos%=xbuff%!0-64
    lj_menu_ypos%=xbuff%!4
  ENDIF
  IF iconpos% THEN
    !buff%=xbuff%!12
    buff%!4=xbuff%!16
    SYS"Wimp_GetIconState",,buff%
    lj_ix%=buff%!16
    lj_iy%=buff%!20
    SYS"Wimp_GetWindowState",,buff%
    lj_menu_xpos%=buff%!20+buff%!4+lj_ix%+2
    lj_menu_ypos%=buff%!24+buff%!16+lj_iy%-2
  ENDIF
  wind%=FNprinter_find_window(prnt%,"configure")
  lj_menu_chsn$=top$
  // because of the way the configuration window works,
  // we have to adjust prdt% to point to the printer data
  // record for the printer specified in the window, NOT
  // the current printer.
  prdt%=FNprinter_find_prdata_entry(psup%,FNicon_read(wind%,6))
  CASE top$ OF
    WHEN "ME1"
      PROCmenu_create(lj_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME1"))
      indt%=(lj_menu%!28 AND &100)<>0
      // get the resolution strings for this printer
      lj_j%=prdt%!20
      lj_i%=0
      lj_x%=0
      WHILE lj_j%
        lj_k%=!lj_j%!CONST_lstd_1st
        xres%=FNprinter_read_integer_entry(lj_k%,4)
        yres%=FNprinter_read_integer_entry(lj_k%,5)
        nm$=FNprinter_read_string_entry(lj_k%,8)
        IF nm$<>"" THEN
          PROCmenu_item(lj_menu%,lj_i%,nm$,indt%)
        ELSE
          PROCmenu_item(lj_menu%,lj_i%,FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%),indt%)
        ENDIF
        lj_i%+=1
        lj_j%=!lj_j%
      ENDWHILE
      PROCmenu_tick_match(lj_menu%,FNicon_read(wind%,3))
    WHEN "ME2"
      PROCmenu_create(lj_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME2"))
      PROCmenu_tick_match(lj_menu%,FNicon_read(wind%,17))
    WHEN "ME3"
      PROCmenu_create(lj_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME3"))
      // need to find the right graphics entry for the current resolution
      lj_j%=prdt%!20: // point to first record for this list
      WHILE lj_j%
        lj_k%=!lj_j%!CONST_lstd_1st
        IF (FNicon_read(wind%,3)=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !lj_k%!20,STR$ !lj_k%!24)) OR \
           (FNicon_read(wind%,3)=FNsafe_string(lj_k%!36)) THEN
          // ok - found the graphics entry, now get the options word
          lj_j%=FNlj_get_quality_options(lj_k%)
          lj_i%=0
          lj_x%=0
          IF lj_j% AND &000007 PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO0"),lj_j%)
          IF lj_j% AND &000070 THEN
            IF LJQ$="S" THEN
              PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1s"),lj_j%>>4)
            ELSE
              PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1"),lj_j%>>4)
            ENDIF
          ENDIF
          IF lj_j% AND &000700 PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO2"),lj_j%>>8)
          IF lj_j% AND &070000 PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO4"),lj_j%>>16)
          IF lj_j% AND &700000 THEN
            IF LJQ$="S" THEN
              PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5s"),lj_j%>>20)
            ELSE
              PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5"),lj_j%>>20)
            ENDIF
          ENDIF
          lj_j%=0
        ELSE
          lj_j%=!lj_j%
        ENDIF
      ENDWHILE
      PROCmenu_tick_match(lj_menu%,FNicon_read(wind%,15))
    WHEN "ME4"
      IFFNprinter_read_list_integer_entry(prdt%,5,2,1)<>0 THEN
        PROCmenu_create(lj_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME4a"))
      ELSE
        PROCmenu_create(lj_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME4b"))
      ENDIF
      PROCmenu_tick_match(lj_menu%,FNicon_read(wind%,13))
    WHEN "ME5"
      PROCmenu_create(lj_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME5"))
      PROCmenu_tick_match(lj_menu%,FNicon_read(wind%,22))
    WHEN "MP1"
      PROCcreate_paper_menu(lj_menu%,wind%,25)
  ENDCASE
  PROCdisplay_menu(prnt%,lj_menu%,lj_menu_xpos%,lj_menu_ypos%)
ENDPROC

DEF PROClj_menu_quality(RETURN lj_menu%,RETURN lj_i%,strip$,tone%)
  LOCAL indt%
  indt%=(lj_menu%!28 AND &100)<>0
  IF tone% AND 1 THEN
    IF LJQ$="S" THEN
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4s"),indt%)
    ELSE
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4"),indt%)
    ENDIF
    lj_i%+=1
  ENDIF
  IF tone% AND 2 THEN
    IF LJQ$="S" THEN
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8s"),indt%)
    ELSE
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8"),indt%)
    ENDIF
    lj_i%+=1
  ENDIF
  IF tone% AND 4 THEN
    IF LJQ$="S" THEN
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1s"),indt%)
    ELSE
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1"),indt%)
    ENDIF
    lj_i%+=1
  ENDIF
ENDPROC

DEF FNlj_hex2(v%)
=RIGHT$("00"+STR$~v%,2)

// text printing code

DEF PROClj_m8
  LOCAL lj_r%,queu%,tpub%,tprv%,text_prdt%
  text_prdt%=!cnfg%!CONST_cnfg_lj_text
  lj_r%=!xbuff%
  queu%=xbuff%!4
  tpub%=queu%!CONST_queu_tpub
  tprv%=queu%!CONST_queu_tprv
  CASE lj_r% OF
    WHEN  -1: PROClj_1
    WHEN  -2: PROClj_2
    WHEN  -4: PROClj_4
    WHEN  -6: PROClj_6
    WHEN  -7: PROClj_7
    WHEN  -9: PROClj_9
    WHEN -10: PROClj_10
    WHEN -11: PROClj_11
    WHEN -12: PROClj_12
    WHEN -13: PROClj_13
    WHEN -15: PROClj_15
    WHEN -16: PROClj_16
    WHEN -17: PROClj_17
    WHEN -18: PROClj_18
    WHEN -19: PROClj_19
  ENDCASE
ENDPROC

DEF PROClj_1
  // only called if we aren't printing an LJ data file
  LOCAL lj_i%,lj_i$,lj_j%,B%,C%
  B%=CONST_ident_TPRV
  C%=CONST_tprv_lj_MAX
  tprv%=USR(code_entry%+CONST_entry_heap_claim)
  IF tprv%=0 ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
  queu%!CONST_queu_tprv=tprv%
  FOR lj_i%=0 TO CONST_tprv_lj_MAX-4
    tprv%!lj_i%=0
  NEXT
  lj_j%=!cnfg%!CONST_cnfg_lj_flags
  tpub%!CONST_tpub_cc_print=(lj_j% AND &FF00)>>8
  IF lj_j% AND 4 THEN
    tpub%!CONST_tpub_number_print=TRUE
    tprv%!CONST_tprv_lj_xt=6
  ELSE
    tprv%!CONST_tprv_lj_xt=0
  ENDIF
  IF lj_j% AND 2 tpub%!CONST_tpub_title_print=TRUE
  lj_i$=FNprinter_read_string_entry(text_prdt%,6)
  B%=A%!CONST_interface_scratch
  $B%=lj_i$
  C%=5
  D%=LEN lj_i$
  tpub%!CONST_tpub_line_epilogue=USR(code_entry%+CONST_entry_store_string)
  // set the pointer to the char translation list
  lj_j%=FNprinter_read_integer_entry(prdt%,6): // point to the PRDT block
  IF lj_j% lj_j%=lj_j%!CONST_prdt_1st
  queu%!CONST_queu_char=lj_j%
ENDPROC

DEF PROClj_2
  // output job start strings
  LOCAL format_print%,lj_pl%,lj_pr%,lj_pb%,lj_pt%,lj_ph%,psze%,lj_yt%
  LOCAL lj_i%, lj_j%, lj_s$, lj_t$
  // first reset the printer
  BPUT#xbuff%!8,CHR$ 27+"E";
  // set paper feed ...
  IF !cnfg%!CONST_cnfg_lj_flags AND 1 THEN
    lj_s$=FNmsg_0(psup%!CONST_psup_msg,"MANUAL_FEED")
  ELSE
    lj_s$=FNmsg_0(psup%!CONST_psup_msg,"AUTO_FEED")
  ENDIF
  IF lj_s$<>"" THEN
    SYS "OS_GSTrans",lj_s$,buff%,256 TO ,,lj_j%
    lj_i%=0
    WHILE lj_j%: BPUT#xbuff%!8,buff%?lj_i%: lj_i%+=1: lj_j%-=1: ENDWHILE
  ENDIF
  // set paper size ...
  lj_i%=prnt%!CONST_prnt_psze
  lj_s$=$lj_i%!CONST_psze_name
  lj_j%=0
  WHILE MID$(lj_s$,lj_j%,1)<>" " AND lj_j%<=LEN lj_s$
    lj_j%+=1
  ENDWHILE
  lj_t$="PT_"+LEFT$(lj_s$,lj_j%-1)
  lj_s$=FNmsg_0(psup%!CONST_psup_msg,lj_t$)
  IF lj_s$=lj_t$ lj_s$=FNmsg_0(psup%!CONST_psup_msg,"PT_A4")
  IF lj_s$<>"" THEN
    SYS "OS_GSTrans",lj_s$,buff%,256 TO ,,lj_j%
    lj_i%=0
    WHILE lj_j%: BPUT#xbuff%!8,buff%?lj_i%: lj_i%+=1: lj_j%-=1: ENDWHILE
  ENDIF
  format_print%=(!cnfg%!CONST_cnfg_lj_flags AND 8)>>3
  psze%=prnt%!CONST_prnt_psze
  lj_pl%=psze%!CONST_psze_lmargin
  lj_pr%=psze%!CONST_psze_rmargin
  lj_pb%=psze%!CONST_psze_bmargin
  lj_pt%=psze%!CONST_psze_tmargin
  lj_ph%=psze%!CONST_psze_pheight
  IF format_print%=0 THEN
    // portrait
    lj_yt%=0
    WHILE lj_yt%*12000<lj_ph%-lj_pt%
      lj_yt%+=1
    ENDWHILE
    lj_pt%=lj_ph%-lj_yt%*12000: // 72000 DIV 6
    lj_yt%+=psze%!CONST_psze_ttop
    tpub%!CONST_tpub_xc=(lj_pr%-lj_pl%)*10 DIV 72000
    tprv%!CONST_tprv_lj_yc=(lj_pt%-lj_pb%)*6 DIV 72000
  ELSE
    lj_yt%=0
    WHILE lj_yt%*9000<lj_pl%
      lj_yt%+=1
    ENDWHILE
    lj_pl%=lj_yt%*9000: // 72000 DIV 8
    lj_yt%+=psze%!CONST_psze_ttop
    tpub%!CONST_tpub_xc=((lj_pt%-lj_pb%)*16.66 DIV 72000 -1) DIV 2
    tprv%!CONST_tprv_lj_yc=(lj_pr%-lj_pl%)*8 DIV 72000
  ENDIF
  tprv%!CONST_tprv_lj_right_print=psze%!CONST_psze_tright
  tpub%!CONST_tpub_xc-=tprv%!CONST_tprv_lj_right_print
  tprv%!CONST_tprv_lj_yc-=psze%!CONST_psze_ttop+psze%!CONST_psze_tbottom
  lj_s$=FNprinter_read_string_entry(text_prdt%,7)
  IFlj_s$<>"" BPUT#xbuff%!8,lj_s$;
  // finally, set the number of lines per page
  BPUT#xbuff%!8,CHR$ 27+"&l"+STR$(tprv%!CONST_tprv_lj_yc+lj_yt%)+"F";
  tprv%!CONST_tprv_lj_xw=tpub%!CONST_tpub_xc
  tprv%!CONST_tprv_lj_left_print=psze%!CONST_psze_tleft
  tprv%!CONST_tprv_lj_left_ruler=0
  tprv%!CONST_tprv_lj_mt=lj_yt%
  tpub%!CONST_tpub_line_max=tprv%!CONST_tprv_lj_yc
  tprv%!CONST_tprv_lj_xl=tprv%!CONST_tprv_lj_left_print
  IF tpub%!CONST_tpub_number_print tprv%!CONST_tprv_lj_xl+=6
ENDPROC

DEF PROClj_4
  // no data to output
  xbuff%?8=0
ENDPROC

DEF PROClj_6
  // do control code processing
  LOCAL lj_b$
  lj_b$=FNlj_display(xbuff%!8)
  xbuff%?8=LEN lj_b$
  $(xbuff%+9)=lj_b$
ENDPROC

DEF PROClj_7
  // process a backspace
  LOCAL lj_b$
  lj_b$=FNprinter_read_string_entry(text_prdt%,2)
  xbuff%?8=LEN(lj_b$)
  $(xbuff%+9)=lj_b$
ENDPROC

DEF PROClj_9
  LOCAL changed_bits%,clr_bits%,set_bits%,bit%,lj_b$
  changed_bits%=tpub%!CONST_tpub_style_bits EOR xbuff%!8
  clr_bits%=tpub%!CONST_tpub_style_bits AND changed_bits%
  set_bits%=changed_bits% AND NOTclr_bits%
  IF clr_bits% OR set_bits% THEN
    FOR bit%=0 TO 5
      IF clr_bits% AND 1<<bit% lj_b$+=FNlj_style_off(bit%)
      IF set_bits% AND 1<<bit% lj_b$+=FNlj_style_on(bit%)
    NEXT
  ENDIF
  xbuff%?8=LEN lj_b$
  $(xbuff%+9)=lj_b$
ENDPROC

DEF PROClj_10
  // end the previous line and start a new line
  LOCAL lj_b$,wrap%,line_num$,lj_bit%
  tpub%!CONST_tpub_line_page+=1
  tpub%!CONST_tpub_line_doc+=1
  FOR lj_bit%=0 TO 5
    IF tpub%!CONST_tpub_style_bits AND 1<<lj_bit% lj_b$+=FNlj_style_off(lj_bit%)
  NEXT
  // lj_b$+=FNprinter_read_string_entry(text_prdt%,6)
  lj_b$+=CHR$ 27+"&a"
  lj_b$+=STR$(tprv%!CONST_tprv_lj_left_print+tprv%!CONST_tprv_lj_left_ruler+tprv%!CONST_tprv_lj_col*(tprv%!CONST_tprv_lj_xw+1))+"C"
  wrap%=(tpub%!CONST_tpub_cpos>=tpub%!CONST_tpub_xc)
  IF tpub%!CONST_tpub_number_print THEN
    // print line number unless wrapped line
    lj_b$+=FNlj_font(0)
    IF wrap% THEN
      tpub%!CONST_tpub_line_doc-=1
      lj_b$+=STRING$(6," ")
    ELSE
      line_num$=STR$ tpub%!CONST_tpub_line_doc
      lj_b$+=STRING$(5-LEN line_num$," ")+line_num$+" "
    ENDIF
    lj_b$+=FNlj_font(tpub%!CONST_tpub_font_num)
    tpub%!CONST_tpub_cpos=6
  ELSE
    tpub%!CONST_tpub_cpos=0
  ENDIF
  IF wrap% THEN
    tpub%!CONST_tpub_cpos+=1
    lj_b$+=FNlj_style_on(0)+"|"+FNlj_style_off(0)
  ENDIF
  FOR lj_bit%=0 TO 5
    IF tpub%!CONST_tpub_style_bits AND 1<<lj_bit% lj_b$+=FNlj_style_on(lj_bit%)
  NEXT
  tpub%!CONST_tpub_cpos+=tprv%!CONST_tprv_lj_left_print+tprv%!CONST_tprv_lj_left_ruler
  xbuff%?8=LEN lj_b$
  $(xbuff%+9)=lj_b$
ENDPROC

DEF PROClj_11
  // print a footnote number
  LOCAL lj_b$,lj_i%
  PROClj_10: lj_b$=FNprinter_read_string(tpub%!CONST_tpub_line_epilogue)+$(xbuff%+9)
  PROClj_10: lj_b$+=FNprinter_read_string(tpub%!CONST_tpub_line_epilogue)+$(xbuff%+9)
  lj_b$+=FNlj_style_on(4): // superscript
  lj_b$+=FNlj_trans(RIGHT$("  "+STR$ tpub%!CONST_tpub_footnote_num,3)+STRING$(3,FNprinter_read_string_entry(text_prdt%,2)))
  lj_b$+=FNlj_style_off(4)
  xbuff%?8=LEN lj_b$
  $(xbuff%+9)=lj_b$
ENDPROC

DEF PROClj_12
  // do bulk string translation
  LOCAL lj_b$
  lj_b$=FNlj_trans($(xbuff%+8))
  xbuff%?8=LEN lj_b$
  $(xbuff%+9)=lj_b$
ENDPROC

DEF PROClj_13
  // do font change
  LOCAL lj_b$,lj_i%
  tpub%!CONST_tpub_font_num=xbuff%!8
  lj_i%=tprv%!CONST_tprv_lj_xl
  lj_i%+=INT((tprv%!CONST_tprv_lj_xw-tprv%!CONST_tprv_lj_xl-tprv%!CONST_tprv_lj_right_print)*FNlj_fontsize(xbuff%!8)/FNlj_fontsize(0))
  tpub%!CONST_tpub_xc=lj_i%
  IF tpub%!CONST_tpub_left_new<tpub%!CONST_tpub_xc-tprv%!CONST_tprv_lj_xl THEN
    tprv%!CONST_tprv_lj_left_ruler=tpub%!CONST_tpub_left_new
  ELSE
    tprv%!CONST_tprv_lj_left_ruler=0
  ENDIF
  IF tpub%!CONST_tpub_right_new<tpub%!CONST_tpub_xc-tprv%!CONST_tprv_lj_xl AND tpub%!CONST_tpub_right_new>tprv%!CONST_tprv_lj_left_ruler THEN
    tpub%!CONST_tpub_xc=tprv%!CONST_tprv_lj_xl+tpub%!CONST_tpub_right_new
  ENDIF
  lj_b$=FNlj_font(xbuff%!8)
  xbuff%?8=LEN lj_b$
  $(xbuff%+9)=lj_b$
ENDPROC

DEF PROClj_15
  // end of job
  LOCAL text_prdt%,tpub%,lj_s$
  IF queu%!CONST_queu_type<>&FF4 THEN
    text_prdt%=!cnfg%!CONST_cnfg_lj_text
    tpub%=queu%!CONST_queu_tpub
    // finish off the text printing
    lj_s$=FNprinter_read_string_entry(text_prdt%,8)
    IF lj_s$<>"" BPUT#xbuff%!8,lj_s$;
  ENDIF
ENDPROC

DEF PROClj_16
  // process a tab
  LOCAL lj_b$
  lj_b$=CHR$ 27+"&a+"
  lj_b$+=STR$(8-((tpub%!CONST_tpub_cpos-tprv%!CONST_tprv_lj_left_print-tprv%!CONST_tprv_lj_left_ruler+1-tprv%!CONST_tprv_lj_xt)MOD 8))+"C"
  tpub%!CONST_tpub_xc+=8-((tpub%!CONST_tpub_cpos-tprv%!CONST_tprv_lj_left_print-tprv%!CONST_tprv_lj_left_ruler+1-tprv%!CONST_tprv_lj_xt)MOD 8)
  xbuff%?8=LEN lj_b$
  $(xbuff%+9)=lj_b$
ENDPROC

DEF PROClj_17
  // do a formfeed
  xbuff%?8=0
ENDPROC

DEF PROClj_18
  // change layout
  LOCAL layout_height%,layout_top%,layout_bottom%
  layout_height%=xbuff%!8
  layout_top%=xbuff%!12
  layout_bottom%=xbuff%!16
  IF layout_height%-layout_top%-layout_bottom%>3 AND layout_height%<=tprv%!CONST_tprv_lj_yc THEN
    tpub%!CONST_tpub_line_max=layout_height%-layout_top%-layout_bottom%
    tprv%!CONST_tprv_lj_mt=layout_top%
  ENDIF
  xbuff%?8=0
ENDPROC

DEF PROClj_19
  // start a new page
  LOCAL lj_b$,lj_bit%,lj_p%,lj_t$
  tpub%!CONST_tpub_line_page=0
  tpub%!CONST_tpub_page_num+=1
  IF((!cnfg%!CONST_cnfg_lj_flags AND 8)>>3)=0 OR (tpub%!CONST_tpub_page_num MOD 2)<>0 THEN
    tprv%!CONST_tprv_lj_col=0
  ELSE
    tprv%!CONST_tprv_lj_col=1
  ENDIF
  IF tpub%!CONST_tpub_page_num>1 THEN
    // turn off the highlights from the previous page
    FOR lj_bit%=0 TO 5
      IF tpub%!CONST_tpub_style_bits AND 1<<lj_bit% lj_b$+=FNlj_style_off(lj_bit%)
    NEXT
  ENDIF
  // physical formfeed only if not staying on same piece of paper
  IF tprv%!CONST_tprv_lj_col=0 AND tpub%!CONST_tpub_page_num>1 THEN
    lj_b$+=FNprinter_read_string_entry(text_prdt%,4)
  ENDIF
  lj_b$+=CHR$ 27+"&a"+STR$ tprv%!CONST_tprv_lj_mt+"R"
  IF tpub%!CONST_tpub_title_print THEN
    lj_p%=tpub%!CONST_tpub_page_num
    IF(!cnfg%!CONST_cnfg_lj_flags AND 8)>>3 THEN
      // if landscape mode, we fit two pages per physical page
      lj_p%=(lj_p%+1)DIV 2
    ENDIF
    tpub%!CONST_tpub_line_page+=2
    IF tprv%!CONST_tprv_lj_col=0 THEN
      lj_b$+=CHR$ 27+"&a"+STR$(tprv%!CONST_tprv_lj_left_print+tprv%!CONST_tprv_lj_left_ruler)+"C"+CHR$ 14
      lj_t$=FNprinter_read_string(tpub%!CONST_tpub_name)+"   "+FNprinter_read_string(tpub%!CONST_tpub_time)
      lj_t$+="   "+FNmsg_1(psup%!CONST_psup_msg,"PAG",STR$ lj_p%)
      lj_b$+=FNlj_trans(lj_t$)+CHR$ 15
    ENDIF
    lj_b$+=FNprinter_read_string_entry(text_prdt%,6)+FNprinter_read_string_entry(text_prdt%,6)
  ENDIF
  xbuff%?8=LEN lj_b$
  $(xbuff%+9)=lj_b$
ENDPROC

DEF FNlj_trans(lj_s$)
  LOCAL lj_i%,byte%,out$,str$
  IF lj_s$="" THEN =""
  FOR lj_i%=1 TO LEN lj_s$
    byte%=ASC MID$(lj_s$,lj_i%,1): str$=""
    CASE TRUE OF
      WHEN byte%<32 OR byte%=127
        IF tpub%!CONST_tpub_cc_print=1 str$=FNlj_display(byte%)
      WHEN byte%>127 AND tpub%!CONST_tpub_cc_print<>0
        IF tpub%!CONST_tpub_cc_print=1 str$=FNlj_display(byte%)
      WHEN tpub%!CONST_tpub_cc_print<>0
        str$=CHR$ byte%
      OTHERWISE
        str$=FNlj_text_char(byte%)
        IF str$="" str$=CHR$ byte%
    ENDCASE
    out$+=str$
  NEXT
=out$

DEF FNlj_text_char(byte%)
  LOCAL lj_p%,lj_s$,lj_i%
  lj_p%=queu%!CONST_queu_char
  WHILE lj_p%
    CASE TRUE OF
      WHEN lj_p%?4=byte%
        lj_i%=lj_p%?5
        lj_p%=lj_p%+6
        WHILE lj_i%
          lj_s$+=CHR$ ?lj_p%
          lj_p%+=1
          lj_i%-=1
        ENDWHILE
        =lj_s$
      WHEN lj_p%?4>byte%
        lj_p%=0
      OTHERWISE
        lj_p%=!lj_p%
    ENDCASE
  ENDWHILE
=""

DEF FNlj_display(byte%)
="["+RIGHT$("0"+STR$~byte%,2)+"]"

DEF FNlj_style_on(bit%)
  CASE bit% OF
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,13): // bold on
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,17): // light on
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,15): // italic on
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,23): // underline on
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,19): // superscript on
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,21): // subscript on
  ENDCASE
=""

DEF FNlj_style_off(bit%)
  CASE bit% OF
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,14): // bold off
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,18): // light off
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,16): // italic off
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,24): // underline off
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,20): // superscript off
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,22): // subscript off
  ENDCASE
=""

DEF FNlj_font(font%)
  CASE font% OF
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,9): // pica
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,10): // elite
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,11): // condensed
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,12): // expanded
  ENDCASE
=""

DEF FNlj_fontsize(num%)
  // provide notional cpi sizes
  CASE num% OF
    WHEN 0: =10: // pica
    WHEN 1: =12: // elite
    WHEN 2: =17: // condensed
    WHEN 3: = 6: // expanded
  ENDCASE
=10

DEF FNlj_host_desc
LOCAL a%
a%=buff%!24
=a%!CONST_interface_host_desc
@


4.5
log
@Dustbinned all the !Sprites23 files.
Addition of long dump string support (requires appropriate modules too).
Serial baud rates now detected at run time with OS_SerialOp rather than
plucking them out of a messages file.
Debug build made to work (use !MkDebug) outputs much debugging to a RAM
disc.
Adobe PDF support removed (the sources remain) as this is RISC OS Ltd code.
Test PDF files added to the Test directory.

Version 1.65. Tagged as 'Manager-1_65'
@
text
@d743 1
a743 1
         (lj_s$=$(lj_k%!36)) THEN
d892 1
a892 1
       (lj_s$=$(lj_k%!36)) THEN
d1126 1
a1126 1
           (FNicon_read(wind%,3)=$(lj_k%!36)) THEN
@


4.4
log
@Rewrote the LJ and DP code which passes the dump strings down to the driver
as this was passing the wrong format block in the wrong register since
the LJ and DP support code does not match the dumper modules.
This allows a V4 style PDF file (with the dataN: dump strings) to be read
in and the dump strings output correctly.
Note the caveat that the sum of the dump strings must not exceed 200 bytes
as the total block size passed to the dumpers is tiny!

Version 1.64. Tagged as 'Manager-1_64'
@
text
@d1 2
a2 1
REM > Support - for Laser/Desk Jet printers
d10 1
a10 1
 * - Uses C-style comments where cc -E  complains about REM ones.
d12 1
a12 1
 * 
a19 1
  VDU: PROCftracef("PROClj_support")
d49 1
a49 2
  REM psup%!CONST_psup_flags OR= 0
  VDU: PROCftracef("PROClj_m1")
d54 3
a56 3
  REM note that the version number really only reflects
  REM the status of the files being read, ie only change
  REM this number if the file contents change.
d63 2
a64 2
  REM ***** WARNING!
  REM ***** THESE VERSION NUMBERS ARE HARD CODED!
d76 7
a82 9
  VDU: PROCftracef("PROClj_m2")
/* REM We don't want to free up the RMA when we quit, thank you very much
 * REM  IF psup%!CONST_psup_rma_block THEN
 * REM    VDU: PROCftracef("*** FREEING R M A ***")
 * REM    SYS "ResourceFS_DeregisterFiles",psup%!CONST_psup_rma_block
 * REM    SYS "OS_Module",7,,psup%!CONST_psup_rma_block: REM OSModule_Free
 * REM    psup%!CONST_psup_rma_block=0
 * REM  ENDIF
 */
d86 1
a86 1
  REM initialise the configuration window
a87 1
  VDU: PROCftracef("PROClj_m3")
d129 1
a129 1
  REM create a CNFG block with suitable defaults
d131 1
a131 2
  VDU: PROCftracef("PROClj_m4")
  REM PJC: set the text options to be draft
d133 1
a133 1
  REM portrait mode is no-highlights entry
d145 1
a145 1
  REM try to read the default x and y resolutions and name from the PRDT block
d150 1
a150 1
    REM try to find the graphics mode which matches this name
d154 1
a154 1
/*      REM first of all, see if we've run out of modes */
d159 1
a159 1
        REM if no match, try the next mode
d163 1
a163 1
    REM if we found it, remember where it was
d167 1
a167 1
      REM try to find the graphics mode which matches this resolution
d171 1
a171 1
  /*      REM first of all, see if we've run out of modes */
d177 1
a177 1
          REM if no match, try the next mode
d181 1
a181 1
      REM if we found it, remember where it was
d184 1
a184 1
      REM show we didn't match - which we couldn't 'cos we didn't have the values
d188 4
a191 4
/*
 * REM if didn't match on supplied resolutions, or no resolutions given
 * REM set the graphics options to be the closest resolution to 300 x 300
 */
d198 1
a198 1
        REM run out of parameters, go back to the last one
d215 1
a215 1
  REM ensure that the module is present in memory
d219 2
a220 2
  REM ensure that the palette file needed at the resolution is cached
  REM bit 23 of palette no. flags whether already ensured or not
d224 2
a225 2
  REM initialise the quality
  REM see if a quality was provided in the PDF
d227 1
a227 1
  REM get the qualities available at the configured resolution
d230 5
a234 5
/*
 *   REM validate values! reset lj_i% to zero if the requested
 *   REM colour and halftone type aren't available at the specified
 *   REM resolution
 */
d238 1
a238 1
      WHEN 0: REM mono
d246 1
a246 1
      WHEN 1: REM greyscale
d254 1
a254 1
      WHEN 2: REM colour
d277 1
a277 1
/*  REM if the sprite name isn't the same as the class name, store the new sprite name */
d279 5
a283 5
/*
 * REM initialise the best paper size we can find ...
 * REM start by trying to read the 'default_paper_size' entry
 * REM from the PRDT block (entry 7)
 */
d285 1
a285 1
  REM fall back to going for the default
a287 1
  VDU: PROCftracef("initialise the best paper size we can find")
d291 1
a291 1
    REM if we run out of paper entries, go for the first one
d296 1
a296 1
  REM if this printer supports fast parallel, set the appropriate flag
a299 1
  VDU: PROCftracef("PROClj_m4 done")
d305 2
a306 3
  VDU: PROCftracef("lj_ensure_resource_file("+resource$+disc$+")")
  REM We use this to load palette files for the printers in order to reduce
  REM the probability of having to ask for the printers disc again later.
d308 1
a308 1
  REM check for out of date palette if we have not ensured this one before (bit 23 of palette number)
d311 1
a311 1
  PROCprinter_write_integer_entry(gprdt%,2,pnum% OR &800000):REM we (will) have ensured it
d313 2
a314 2
  REM First of all, check if the file exists already
  SYS "OS_File",17,"Resources:"+resource$ TO found_type%,,found_load%,found_exec%,found_size%: REM OS_FileReadNoPath
d318 2
a319 2
  SYS "OS_File",17,disc$ TO obj_type%,,load_addr%,exec_addr%,file_size%,obj_attr%: REM OS_FileReadNoPath
  IF obj_type%<>1 SYS "OS_File",19,disc$,obj_type%: REM OS_FileMakeError
d323 2
a324 2
    REM cached palette is not the same as the one on disc
    REM try to remove the cached palette
d338 1
a338 2
  rma_size%=20+(LEN resource$+4 AND NOT 3)+4+(file_size%+3 AND NOT 3): REM Size needed for this file only
  VDU: PROCftracef("File "+disc$+", size "+STR$ file_size%)
d340 4
a343 4
  REM claim some RMA for the file
  SYS "OS_Module",6,,,rma_size%+8 TO,,rma_block%: REM OSModule_Alloc
  REM Put a check tag at the beginning of the block
  !rma_block%=&48434143:REM CACH
d345 1
a345 1
  REM Fill in the block
d352 1
a352 1
  rma_block%!(20+LEN resource$)=0 /*: REM pad with 0's */
d354 2
a355 2
  SYS "OS_File",16,disc$,rma_block%+20+(LEN resource$+4 AND NOT 3)+4: REM OS_FileLoadNoPath
  rma_block%!rma_size%=0: REM Terminator
d360 2
a361 2
  REM cache any palette files that are used by lj printers and ensure
  REM that the relevant PDumper modules are loaded
a362 1
  VDU: PROCftracef("PROClj_m5")
d366 1
a366 1
      REM got a printer in our class - cache the palette file
d369 1
a369 1
      REM bit 23 of palette no. flags whether already ensured or not
d373 1
a373 1
      REM and ensure the pdumper module
d382 1
a382 1
  REM do whatever is necessary to prime the specified printer
d386 1
a386 2
  VDU: PROCftracef("PROClj_m6")
  REM 7 is the magic number for the dumper driver
d404 4
a407 4
  REM WARNING!
  REM The comparison is made against strip type 2 (colour) or greater
  REM This assumes, therefore, that any strip types that are 2 or greater
  REM are colour which is currently true
d420 1
a420 1
  REM bit 23 of palette no. flags whether already ensured or not
d422 1
d425 1
d427 1
a427 1
  IFpal%=0 ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
d429 1
d431 1
a431 1
  IFinf%=0 ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
d434 4
a437 4
/*
 * REM if we have strip type 5 and the dumper doesn't support it,
 * REM deprecate it down to strip type 3
 */
d444 1
a444 1
/*  REM this may be necessary, if multiple palettes for one printer */
d447 1
a447 1
  REM Module name:
d451 5
a455 5
  REM set passes per line entry
  REM WARNING!
  REM The comparison is made against strip type 2 (colour) or greater
  REM This assumes, therefore, that any strip types that are 2 or greater
  REM are colour which is currently true
d458 1
a458 1
  REM set strip type field
d461 1
a461 1
  REM set output bpp field
d464 1
a464 1
  REM set num passes field
d468 22
a489 37
  IF ((flags% >>> 24) < 5) THEN
    SYS "XPDriver_SetDriver",,FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%,1),1),dmp$,pal%,inf%,flags%
  ELSE
    REM Fill in the inf% block based on the "dataN:" lines in the PDF
    ptr%=CONST_dp_data_text_start:REM Free space for text
    FOR B%=0 TO 19
      a$=FNprinter_read_string_entry(graphics_prdt%,10+B%)
      CASE B% OF
        WHEN0:C%=CONST_dp_data_set_lines:REM data1
        WHEN1:C%=CONST_dp_data_page_start
        WHEN2:C%=CONST_dp_data_form_feed
        WHEN3:C%=CONST_dp_data_page_end
        WHEN4:C%=CONST_dp_data_line_return
        WHEN5:C%=CONST_dp_data_line_skip
        WHEN6:C%=CONST_dp_data_line_end
        WHEN7:C%=CONST_dp_data_line_end_i2
        WHEN8:C%=CONST_dp_data_line_end_i3
        WHEN9:C%=CONST_dp_data_zero_skip
        WHEN10:C%=CONST_dp_data_line_start
        WHEN11:C%=CONST_dp_data_line_start_2
        WHEN12:C%=CONST_dp_data_pass1_start
        WHEN13:C%=CONST_dp_data_pass1_start_2
        WHEN14:C%=CONST_dp_data_pass2_start
        WHEN15:C%=CONST_dp_data_pass2_start_2
        WHEN16:C%=CONST_dp_data_pass3_start
        WHEN17:C%=CONST_dp_data_pass3_start_2
        WHEN18:C%=CONST_dp_data_pass4_start
        WHEN19:C%=CONST_dp_data_pass4_start_2:REM data20
      ENDCASE
      inf%?C%=0
      IFLENa$>0 THEN
        inf%?C%=ptr%-CONST_dp_data_dlm:inf%?ptr%=LENa$:ptr%+=1
        FOR i%=1 TO LENa$:inf%?ptr%=ASC(MID$(a$,i%,1)):ptr%+=1:NEXT
      ENDIF
      IFptr%>=256 THENERROR CONST_error_fatal, FNmsg_1(FNlj_host_desc,"Block overflowed","OKZ")
    NEXT
    SYS "XPDriver_SetDriver",,FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%,1),1),dmp$,pal%,inf%,flags%
d491 1
d498 3
a500 1
  lj_i%=FNprinter_read_integer_entry(prdt%,6): REM point to the chars PRDT block
d519 1
d547 1
a547 1
    local_pt%=local_ph%-local_yt%*12000: REM 72000 DIV 6
d555 1
a555 1
    local_pl%=local_yt%*9000: REM 72000 DIV 8
a567 1
  VDU: PROCftracef("PROClj_m6 done")
d570 59
a630 1
  VDU: PROCftracef("PROClj_m7")
a641 1
  VDU: PROCftracef("PROClj_p3")
d647 1
a647 2
  REM mouseclick on the configure window
  VDU: PROCftracef("PROClj_p6")
d649 1
a649 1
    WHEN 2: REM menu
d658 1
a658 1
    WHEN 4: REM select
d677 1
a677 1
    WHEN 1: REM adjust
d689 1
a689 1
  REM a key press!
a690 1
  VDU: PROCftracef("PROClj_p8")
d713 7
a719 8
/*
 * REM menu selections are easy ... we just write the
 * REM selected string into the appropriate icon.
 * REM some other actions may be taken to ensure that
 * REM other choices are OK, but we don't touch any
 * REM data yet.
 */
  VDU: PROCftracef("PROClj_p9")
d737 1
a737 1
    REM if the resolution changes, we may have to change the quality as well
d744 5
a748 5
/*
 *       REM ok - found the pointer to the graphics data, now check the graphics quality
 *       REM basically, we need to see if the request quality is available in this dump
 *       REM if it isn't, we reset it to the best fit we can manage
 */
a794 1
  VDU: PROCftracef("PROClj_p17")
a845 1
  VDU: PROCftracef("PROClj_save_configuration_window")
d868 2
a869 2
  REM portrait mode is no-highlights entry
  REM landscape mode is drafts entry
d885 2
a886 2
  REM point to the resolution possibilities
  lj_j%=prdt%!20: REM printer name is 8, short name is 12, sprite name is 16, resolution is 20
d889 2
a890 2
    lj_k%=!lj_j%!CONST_lstd_1st: REM get the pointer
    REM module is 8, palette is 12, options is 16, pxres is 20, pyres is 24
d938 2
a939 2
    REM this printer is ACTIVE!
    REM ensure that its details are correct
d941 3
a943 3
    REM The front end code will spot that the selected printer has
    REM changed and put everything back the way it was
    REM PROCselect_printer(0,TRUE,TRUE): REM don't do this (calls into overlay). JRC 12 Feb '92
a948 1
  VDU: PROCftracef("FNlj_res")
a968 1
  VDU: PROCftracef("FNlj_qual")
d975 1
a975 1
REM if colour small halftone present, add colour large halftone
d977 1
a977 1
REM if colour available, add new colour options
d979 4
a982 4
 t%=FNprinter_read_integer_entry(graphics_definition%,1):REM ptr to module defn
 t%=FNprinter_read_integer_entry(t%,1):REM module number
 REM pass the MiscOp through to the dumper driver
 SYS"XPDriver_MiscOpForDriver",&80000002,t%,,,,,,,7 TO t%;c%:REM strip type mask
d985 1
a985 1
   REM add strip type 3 based on the greyscale options (or colour, if no grey)
d991 1
a991 1
   REM add strip type 4 based on the colour options
d996 1
a996 1
   REM add strip type 5 based on the colour options
d1002 1
a1002 1
REM If simple qualities, knock out Mono,256 colours,32k colours
d1006 24
a1029 24
REM If LJQ$ = "S" then the following qualities are
REM actually deemed not to exist:
REM - Any 'Mono'; '256 colours'; '32k colours'

REM This procedure tries to find a good default quality to pick.
REM Modified on 22-Jul-93/3-Dec-93 to pick in this order:
REM Modified on 02-Aug-95 to favour error diff instead of halftone
REM * 16 million, diffused
REM * colour, diffused
REM * grey, diffused
REM * mono, diffused
REM
REM The option value is split into 3 nibbles:
REM &7xxxxx = 24bpp colour, either strip type 3 or 5 depending on
REM                        whether or not it is a full colour system
REM &x7xxxx = 16bpp colour, strip type 4
REM &xxx7xx = colour, strip type 2
REM &xxxx7x = greyscale, strip type 1
REM &xxxxx7 = monochrome, strip type 0
REM
REM Within the 3 nibbles, the following values are valid:
REM 1 = small halftone, tone type 4
REM 2 = large halftone, tone type 8
REM 4 = dithered, tone type 1
d1031 1
a1031 2
  VDU: PROCftracef("PROClj_decode_options")
  REM try to pick colour, then grey, then mono
d1041 1
a1041 1
     REM force grey if "Simple" (Mono not allowed)
d1047 1
a1047 1
  REM find out what is available now
d1055 3
a1057 3
/* REM if we've failed now, try to pick
 * REM dithered, large halftone, small halftone
 */
a1072 1
  VDU: PROCftracef("PROClj_menu")
d1089 4
a1092 4
  REM because of the way the configuration window works,
  REM we have to adjust prdt% to point to the printer data
  REM record for the printer specified in the window, NOT
  REM the current printer.
d1098 1
a1098 1
      REM get the resolution strings for this printer
d1121 2
a1122 2
      REM need to find the right graphics entry for the current resolution
      lj_j%=prdt%!20: REM point to first record for this list
d1127 1
a1127 1
          REM ok - found the graphics entry, now get the options word
a1171 1
  VDU: PROCftracef("PROClj_menu")
a1199 1
  VDU: PROCftracef("PROClj_hex2")
d1202 1
a1202 1
REM text printing code
a1205 1
  VDU: PROCftracef("PROClj_m8")
d1231 1
a1231 1
/*  REM only called if we aren't printing an LJ data file */
a1232 1
  VDU: PROCftracef("PROClj_1")
d1256 2
a1257 2
  REM set the pointer to the char translation list
  lj_j%=FNprinter_read_integer_entry(prdt%,6): REM point to the PRDT block
d1263 1
a1263 1
  REM output job start strings
d1266 1
a1266 2
  VDU: PROCftracef("PROClj_2")
  REM first reset the printer
d1268 1
a1268 1
  REM set paper feed ...
d1279 1
a1279 1
  REM set paper size ...
d1302 1
a1302 1
    REM portrait
d1307 1
a1307 1
    lj_pt%=lj_ph%-lj_yt%*12000: REM 72000 DIV 6
d1316 1
a1316 1
    lj_pl%=lj_yt%*9000: REM 72000 DIV 8
d1326 1
a1326 1
  REM finally, set the number of lines per page
d1338 1
a1338 2
  REM no data to output
  VDU: PROCftracef("PROClj_4")
d1343 1
a1343 1
  REM do control code processing
a1344 1
  VDU: PROCftracef("PROClj_6")
d1351 1
a1351 1
  REM process a backspace
a1352 1
  VDU: PROCftracef("PROClj_7")
a1359 1
  VDU: PROCftracef("PROClj_9")
d1374 1
a1374 1
  REM end the previous line and start a new line
a1375 1
  VDU: PROCftracef("PROClj_10")
d1381 1
a1381 1
  REM lj_b$+=FNprinter_read_string_entry(text_prdt%,6)
d1386 1
a1386 1
    REM print line number unless wrapped line
d1413 1
a1413 1
  REM print a footnote number
a1414 1
  VDU: PROCftracef("PROClj_11")
d1417 1
a1417 1
  lj_b$+=FNlj_style_on(4): REM superscript
d1425 1
a1425 1
  REM do bulk string translation
a1426 1
  VDU: PROCftracef("PROClj_12")
d1433 1
a1433 1
  REM do font change
a1434 1
  VDU: PROCftracef("PROClj_13")
d1453 1
a1453 1
  REM end of job
a1454 1
  VDU: PROCftracef("PROClj_15")
d1458 1
a1458 1
    REM finish off the text printing
d1465 1
a1465 1
  REM process a tab
a1466 1
  VDU: PROCftracef("PROClj_16")
d1475 1
a1475 2
  REM do a formfeed
  VDU: PROCftracef("PROClj_17")
d1480 1
a1480 1
  REM change layout
a1481 1
  VDU: PROCftracef("PROClj_18")
d1493 1
a1493 1
  REM start a new page
a1494 1
  VDU: PROCftracef("PROClj_19")
d1503 1
a1503 1
    REM turn off the highlights from the previous page
d1508 1
a1508 1
  REM physical formfeed only if not staying on same piece of paper
d1516 1
a1516 1
      REM if landscape mode, we fit two pages per physical page
a1533 1
  VDU: PROCftracef("FNlj_trans")
a1553 1
  VDU: PROCftracef("FNlj_text_char")
a1574 1
  VDU: PROCftracef("FNlj_display")
a1577 1
  VDU: PROCftracef("FNlj_style_on")
d1579 6
a1584 6
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,13): REM bold on
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,17): REM light on
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,15): REM italic on
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,23): REM underline on
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,19): REM superscript on
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,21): REM subscript on
a1588 1
  VDU: PROCftracef("FNlj_style_off")
d1590 6
a1595 6
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,14): REM bold off
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,18): REM light off
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,16): REM italic off
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,24): REM underline off
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,20): REM superscript off
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,22): REM subscript off
a1599 1
  VDU: PROCftracef("FNlj_font")
d1601 4
a1604 4
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,9): REM pica
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,10): REM elite
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,11): REM condensed
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,12): REM expanded
a1605 1
  VDU: PROCftracef("FNlj_font done")
d1609 1
a1609 2
  REM provide notional cpi sizes
  VDU: PROCftracef("FNlj_fontsize")
d1611 4
a1614 4
    WHEN 0: =10: REM pica
    WHEN 1: =12: REM elite
    WHEN 2: =17: REM condensed
    WHEN 3: = 6: REM expanded
@


4.3
log
@Changes to SetPrint util for additional printer$type understanding
Template tidy up
Change to get version number from VesionNum file
Tweak to SuppSrc for 32 bit high bit addresses
Change !Run file to look for OS3.50 as we use MSR and MRS now
Pick up all but 2 of the changes added to 1.65 on 26-Jun-2001,mostly
cosmetic,with two exceptions
 - use of Parallel_IgnoreErrors
 - warning about dropping "bundled" printer definitions onto it

Version 1.63. Tagged as 'Manager-1_63'
@
text
@d479 2
a480 1
    s%=4*(20+2)
a481 11
      s%+=1+LENFNprinter_read_string_entry(graphics_prdt%,10+B%)
    NEXT
    C%=s%
    B%=CONST_ident_DATA
    newblock%=USR(code_entry%+CONST_entry_heap_claim)
    IFnewblock%=0 ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc,"FA5")
    !newblock%=20
    newblock%!4=s%
    C%=newblock%+4*(20+2)
    FOR B%=0 TO 19
      newblock%!(8+4*B%)=C%-newblock%
d483 26
a508 6
      ?C%=LENa$:C%+=1
      IF LEN a$>0 THEN
        FOR i%=1 TO LEN a$
         ?C%=ASC(MID$(a$,i%,1))
         C%+=1
        NEXT
d510 1
d512 1
a512 4
    SYS "XPDriver_SetDriver",,FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%,1),1),dmp$,pal%,inf%,flags%,newblock%
    B%=CONST_ident_DATA
    C%=newblock%
    CALL code_entry%+CONST_entry_heap_free
@


4.2
log
@Version RO_3_71 taken
@
text
@d100 5
d395 1
d420 1
a420 1
   SYS"XPDriver_SetInfo",,xres%,yres%,1,lj_s$,xres%/halftone%,yres%/halftone% TO ptr%;lj_i%
d422 1
a422 1
   SYS"XPDriver_SetInfo",,xres%,yres%,0,lj_s$,xres%/halftone%,yres%/halftone% TO ptr%;lj_i%
d475 31
a505 1
  SYS "XPDriver_SetDriver",,FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%,1),1),dmp$,pal%,inf%,FNprinter_read_integer_entry(graphics_prdt%,7)
d601 1
a601 1
  LOCAL wind%
d630 2
d634 7
a640 4
      IF xbuff%!16=24 THEN
        wind%=xbuff%!12
        PROClj_save_configuration(wind%)
      ENDIF
d776 6
d783 18
@


4.1
log
@Initial revision
@
text
@d48 1
a48 1
  LOCAL colours%, pdriverdp%
d69 5
d129 1
a129 1
  LOCAL lj_s$,lj_i%,lj_s%,lj_t%,lj_x%,lj_y%,lj_co%,lj_ht%,B%,C%
d145 1
a145 1
  REM try to read the default x and y resolutions from the PRDT block
d148 3
a150 2
  IF (lj_x%<>0 AND lj_y%<>0) THEN
    REM try to find the graphics mode which matches this resolution
d158 1
a158 2
        lj_s%=FNprinter_read_integer_entry(B%,4)
        lj_t%=FNprinter_read_integer_entry(B%,5)
d160 1
a160 1
        IFlj_s%<>lj_x% OR lj_t%<>lj_y% C%+=1
d162 1
a162 1
    UNTIL C%=-1 OR (lj_s%=lj_x% AND lj_t%=lj_y%)
d166 21
a186 2
    REM show we didn't match - which we couldn't 'cos we didn't have the values
    C%=-1
d220 3
a222 2
  lj_s$=STR$(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_lj_graphics,2))
  PROClj_ensure_resource_file("Resources.Printers.Palettes."+lj_s$,"Printers:Palettes."+lj_s$,TRUE)
d304 1
a304 1
DEF PROClj_ensure_resource_file(resource$,disc$,reload_if_outofdate%)
d306 1
a306 1
  LOCAL found_type%,found_load%,found_exec%,found_size%,c%,a%,w%
d311 5
d318 1
d374 3
a376 2
      lj_pal$=STR$FNprinter_read_integer_entry(lj_graphics_prdt%,2)
      PROClj_ensure_resource_file("Resources.Printers.Palettes."+lj_pal$,"Printers:Palettes."+lj_pal$,TRUE)
d425 2
a426 1
  lj_s$=STR$ FNprinter_read_integer_entry(graphics_prdt%,2): REM suffix
d446 2
a447 2
/*  REM hopefully the following isn't necessary, but cache it just in case */
  PROClj_ensure_resource_file("Resources.Printers.Palettes."+lj_s$,"Printers:Palettes."+lj_s$,FALSE)
d659 2
a660 1
      IF lj_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !lj_k%!20,STR$ !lj_k%!24)THEN
d668 6
a673 4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"): lj_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"): lj_j%=2
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"): lj_j%=4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"): lj_j%=5
d678 4
a681 2
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"): lj_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"): lj_i%=1
d696 1
a696 1
          PROCicon_write(wind%,15,FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$ lj_j%)+", "+FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$ lj_i%))
d786 2
a787 1
    IF lj_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !lj_k%!20,STR$ !lj_k%!24)THEN
d801 6
a806 4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"): lj_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"): lj_j%=2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"): lj_j%=4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"): lj_j%=5
d811 4
a814 2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"): lj_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"): lj_i%=1
d843 1
a843 1
  LOCAL xres%,yres%,graphics_prdt%
d848 14
a861 1
=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%)
d864 1
a864 1
  LOCAL lj_i%,lj_s$,lj_t$
d867 1
a867 3
  lj_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(lj_i% AND &FF))
  lj_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((lj_i% AND &FF00)>>8))
=lj_s$+", "+lj_t$
d882 1
a882 1
   REM add strip type 3 based on the greyscale options
d884 1
d899 2
d903 4
d909 5
a913 4
REM * 16 million, large halftone
REM * colour, large halftone
REM * grey, large halftone
REM * mono, large halftone
d939 2
a940 1
     strip%=0
d948 4
a951 4
  IF (strip%=5 AND (option% AND 1)<>0) tone%=8
  IF (strip%=2 AND (option% AND 1)<>0) tone%=8
  IF (strip%=1 AND (option% AND 2)<>0) tone%=8
  IF (strip%=0 AND (option% AND 2)<>0) tone%=8
d954 1
a954 1
 * REM large halftone, small halftone, dithered
d957 2
a958 2
    IF option% AND 2 THEN
      tone%=8
d960 3
a962 1
      IF option% AND 1 THEN
a963 2
      ELSE
        tone%=1
d970 1
a970 1
  LOCAL wind%,lj_ix%,lj_iy%,lj_i%,lj_x%,lj_j%,lj_k%,xres%,yres%,indt%
d1005 6
a1010 1
        PROCmenu_item(lj_menu%,lj_i%,FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%),indt%)
d1024 2
a1025 1
        IF FNicon_read(wind%,3)=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !lj_k%!20,STR$ !lj_k%!24)THEN
d1031 7
a1037 1
          IF lj_j% AND &000070 PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1"),lj_j%>>4)
d1040 7
a1046 1
          IF lj_j% AND &700000 PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5"),lj_j%>>20)
d1074 5
a1078 1
    PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4"),indt%)
d1082 5
a1086 1
    PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8"),indt%)
d1090 5
a1094 1
    PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1"),indt%)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d48 1
a48 1
  LOCAL colours%, pdriverdp%, exists%
a68 5
/* do not allow this any more
  SYS "XOS_ReadVarVal","Printers$DPLJfullQ",,-1,,3 TO,,exists%
  IF exists% THEN LJQ$="F" ELSE LJQ$="S"
*/
LJQ$="S"
d124 1
a124 1
  LOCAL lj_s$,lj_nm$,lj_nm2$,lj_i%,lj_s%,lj_t%,lj_x%,lj_y%,lj_co%,lj_ht%,B%,C%
d140 1
a140 1
  REM try to read the default x and y resolutions and name from the PRDT block
d143 2
a144 3
  lj_nm$=FNprinter_read_string_entry(prdt%,12)
  IF lj_nm$<>"" THEN
    REM try to find the graphics mode which matches this name
d152 2
a153 1
        lj_nm2$=FNprinter_read_string_entry(B%,8)
d155 1
a155 1
        IFlj_nm$<>lj_nm2$ C%+=1
d157 1
a157 1
    UNTIL C%=-1 OR lj_nm$=lj_nm2$
d161 2
a162 21
    IF (lj_x%<>0 AND lj_y%<>0) THEN
      REM try to find the graphics mode which matches this resolution
      C%=1
      REPEAT
        B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
  /*      REM first of all, see if we've run out of modes */
        IF B%=0 THEN
          C%=-1
        ELSE
          lj_s%=FNprinter_read_integer_entry(B%,4)
          lj_t%=FNprinter_read_integer_entry(B%,5)
          REM if no match, try the next mode
          IFlj_s%<>lj_x% OR lj_t%<>lj_y% C%+=1
        ENDIF
      UNTIL C%=-1 OR (lj_s%=lj_x% AND lj_t%=lj_y%)
      REM if we found it, remember where it was
      IF C%<>-1 lj_i%=C%
    ELSE
      REM show we didn't match - which we couldn't 'cos we didn't have the values
      C%=-1
    ENDIF
d196 2
a197 3
  REM bit 23 of palette no. flags whether already ensured or not
  lj_s$=STR$(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_lj_graphics,2) AND &7FFFFF)
  PROClj_ensure_resource_file("Resources.Printers.Palettes."+lj_s$,"Printers:Palettes."+lj_s$,!cnfg%!CONST_cnfg_lj_graphics)
d279 1
a279 1
DEF PROClj_ensure_resource_file(resource$,disc$,gprdt%)
d281 1
a281 1
  LOCAL found_type%,found_load%,found_exec%,found_size%,c%,a%,w%,pnum%,reload_if_outofdate%
a285 5
  REM check for out of date palette if we have not ensured this one before (bit 23 of palette number)
  pnum% = FNprinter_read_integer_entry(gprdt%,2)
  reload_if_outofdate% = ((pnum% AND &800000) = 0)
  PROCprinter_write_integer_entry(gprdt%,2,pnum% OR &800000):REM we (will) have ensured it

a287 1

d343 2
a344 3
      REM bit 23 of palette no. flags whether already ensured or not
      lj_pal$=STR$(FNprinter_read_integer_entry(lj_graphics_prdt%,2) AND &7FFFFF)
      PROClj_ensure_resource_file("Resources.Printers.Palettes."+lj_pal$,"Printers:Palettes."+lj_pal$,lj_graphics_prdt%)
d393 1
a393 2
  REM bit 23 of palette no. flags whether already ensured or not
  lj_s$=STR$(FNprinter_read_integer_entry(graphics_prdt%,2) AND &7FFFFF)
d413 2
a414 2
/*  REM this may be necessary, if multiple palettes for one printer */
  PROClj_ensure_resource_file("Resources.Printers.Palettes."+lj_s$,"Printers:Palettes."+lj_s$,graphics_prdt%)
d626 1
a626 2
      IF (lj_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !lj_k%!20,STR$ !lj_k%!24)) OR \
         (lj_s$=$(lj_k%!36)) THEN
d634 4
a637 6
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  lj_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): lj_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  lj_j%=2
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  lj_j%=4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  lj_j%=5
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): lj_j%=5
d642 2
a643 4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  lj_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): lj_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  lj_i%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): lj_i%=1
d658 1
a658 1
          PROCicon_write(wind%,15,FNlj_qual_name(lj_j% + (lj_i% << 8)))
d748 1
a748 2
    IF (lj_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !lj_k%!20,STR$ !lj_k%!24)) OR \
       (lj_s$=$(lj_k%!36)) THEN
d762 4
a765 6
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  lj_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): lj_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  lj_j%=2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  lj_j%=4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  lj_j%=5
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): lj_j%=5
d770 2
a771 4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  lj_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): lj_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  lj_i%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): lj_i%=1
d800 1
a800 1
  LOCAL xres%,yres%,graphics_prdt%,nm$
d805 1
a805 14
  nm$=FNprinter_read_string_entry(graphics_prdt%,8)
  IF nm$="" THEN  nm$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%)
=nm$

DEF FNlj_qual_name(lj_i%)
  LOCAL lj_s$,lj_t$
  IF LJQ$ = "S" THEN
    lj_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(lj_i% AND &FF)+"s")
    lj_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((lj_i% AND &FF00)>>8)+"s")
  ELSE
    lj_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(lj_i% AND &FF))
    lj_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((lj_i% AND &FF00)>>8))
  ENDIF
=lj_s$+", "+lj_t$
d808 1
a808 1
  LOCAL lj_i%
d811 3
a813 1
=FNlj_qual_name(lj_i%)
d828 1
a828 1
   REM add strip type 3 based on the greyscale options (or colour, if no grey)
a829 1
   IF c%=0 THEN c%=(s% AND &700)>>4
a843 2
REM If simple qualities, knock out Mono,256 colours,32k colours
IF LJQ$ = "S" s%=s% AND &700070
a845 4
REM If LJQ$ = "S" then the following qualities are
REM actually deemed not to exist:
REM - Any 'Mono'; '256 colours'; '32k colours'

d848 4
a851 5
REM Modified on 02-Aug-95 to favour error diff instead of halftone
REM * 16 million, diffused
REM * colour, diffused
REM * grey, diffused
REM * mono, diffused
d877 1
a877 2
     REM force grey if "Simple" (Mono not allowed)
     IF LJQ$ = "S" THEN strip%=1 ELSE strip%=0
d885 4
a888 4
  IF (strip%=5 AND (option% AND 4)<>0) tone%=1
  IF (strip%=2 AND (option% AND 4)<>0) tone%=1
  IF (strip%=1 AND (option% AND 4)<>0) tone%=1
  IF (strip%=0 AND (option% AND 4)<>0) tone%=1
d891 1
a891 1
 * REM dithered, large halftone, small halftone
d894 2
a895 2
    IF option% AND 4 THEN
      tone%=1
d897 2
a898 2
      IF option% AND 2 THEN
        tone%=8
d900 1
a900 1
        tone%=4
d907 1
a907 1
  LOCAL wind%,lj_ix%,lj_iy%,lj_i%,lj_x%,lj_j%,lj_k%,xres%,yres%,indt%,nm$
d942 1
a942 6
        nm$=FNprinter_read_string_entry(lj_k%,8)
        IF nm$<>"" THEN
          PROCmenu_item(lj_menu%,lj_i%,nm$,indt%)
        ELSE
          PROCmenu_item(lj_menu%,lj_i%,FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%),indt%)
        ENDIF
d956 1
a956 2
        IF (FNicon_read(wind%,3)=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !lj_k%!20,STR$ !lj_k%!24)) OR \
           (FNicon_read(wind%,3)=$(lj_k%!36)) THEN
d962 1
a962 7
          IF lj_j% AND &000070 THEN
            IF LJQ$="S" THEN
              PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1s"),lj_j%>>4)
            ELSE
              PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1"),lj_j%>>4)
            ENDIF
          ENDIF
d965 1
a965 7
          IF lj_j% AND &700000 THEN
            IF LJQ$="S" THEN
              PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5s"),lj_j%>>20)
            ELSE
              PROClj_menu_quality(lj_menu%,lj_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5"),lj_j%>>20)
            ENDIF
          ENDIF
d993 1
a993 5
    IF LJQ$="S" THEN
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4s"),indt%)
    ELSE
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4"),indt%)
    ENDIF
d997 1
a997 5
    IF LJQ$="S" THEN
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8s"),indt%)
    ELSE
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8"),indt%)
    ENDIF
d1001 1
a1001 5
    IF LJQ$="S" THEN
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1s"),indt%)
    ELSE
      PROCmenu_item(lj_menu%,lj_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1"),indt%)
    ENDIF
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

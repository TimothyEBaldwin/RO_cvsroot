head	4.10;
access;
symbols
	PDumpers-1_46:4.10
	PDumpers-1_45:4.10
	PDumpers-1_44:4.10
	PDumpers-1_43:4.10
	PDumpers-1_42:4.10
	PDumpers-1_41:4.10
	RO_5_07:4.10
	PDumpers-1_40:4.10
	PDumpers-1_39:4.10
	PDumpers-1_38:4.9
	PDumpers-1_33:4.7
	PDumpers-1_32:4.7
	PDumpers-1_31:4.7
	PDumpers-1_30:4.7
	PDumpers-1_29:4.7
	PDumpers-1_28:4.7
	PDumpers-1_27:4.7
	PDumpers-1_26:4.6
	PDumpers-1_25:4.6
	Spin_merge-1_21:4.1.7.3
	PDumpers-1_24:4.5
	PDumpers-1_23:4.5
	PDumpers-1_22:4.4
	dellis_autobuild_BaseSW:4.4
	PDumpers-1_21:4.4
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.7
	dcotton_MPT2_build_16061999:4.1.7.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.4
	Ursula_RiscPC:4.1.7.4.0.4
	nicke_PDumpers-1_21:4.1.7.4
	rthornb_UrsulaBuild-19Aug1998:4.1.7.4
	UrsulaBuild_FinalSoftload:4.1.7.4
	rthornb_UrsulaBuild-12Aug1998:4.1.7.4
	aglover_UrsulaBuild-05Aug1998:4.1.7.4
	rthornb_UrsulaBuild-29Jul1998:4.1.7.4
	rthornb_UrsulaBuild-22Jul1998:4.1.7.4
	hsimons_BOCA-1_2-Release:4.1.7.4
	rthornb_UrsulaBuild-15Jul1998:4.1.7.4
	rthornb_UrsulaBuild-07Jul1998:4.1.7.4
	rthornb_UrsulaBuild-17Jun1998:4.1.7.4
	rthornb_UrsulaBuild-03Jun1998:4.1.7.4
	rthornb_UrsulaBuild-27May1998:4.1.7.4
	rthornb_UrsulaBuild-21May1998:4.1.7.4
	rthornb_UrsulaBuild_01May1998:4.1.7.4
	afrost_NC2_Generic:4.1.7.4
	afrost_Funai01-33:4.1.7.4
	Ursula:4.1.7.4.0.2
	Ursula_bp:4.1.7.4
	Ursula_31Mar1998:4.3
	Spinner_RCA116:4.1.7.4
	Spinner_B20_2:4.1.7.4
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.4
	Spinner_B17:4.1.7.3
	Spinner_B15:4.1.7.3
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Spinner_B12:4.1.7.3
	Spin_merge_28May97:4.1.7.3
	Spinner_B10:4.1.7.3
	Spin_merge_16May97:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.4
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2003.01.17.10.54.41;	author srevill;	state Exp;
branches;
next	4.9;

4.9
date	2002.12.17.18.54.43;	author srevill;	state Exp;
branches;
next	4.8;

4.8
date	2002.11.15.16.05.23;	author srevill;	state dead;
branches;
next	4.7;

4.7
date	2001.06.20.15.00.02;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2001.01.03.16.29.58;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.20.09.50.55;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.06.09.11.07.57;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	97.05.16.12.47.03;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.13.53;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.49.11;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.49.11;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.10.20;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.30.09;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.33.32;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.04.30.17.17.34;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.05.14.09.41.14;	author jcoxhead;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.07.11.09.56.16;	author arodger;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Build tweaks to allow these to be assembled with an objasm which doesn't
have a '-J' option - see previous check in.
Fix for macro "PrintCountedString",the length was a factor 256 out.

Version 1.39. Tagged as 'PDumpers-1_39'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Macros

;..............................................................................
;
; Prep the routines as required

        MACRO
        PDumper_InitialiseMacros
        MEND

strip_type_mono  * StripType_Monochrome
strip_type_greys * StripType_GreyLevel
strip_type_256   * StripType_256Colour
strip_type_24bm  * StripType_Multi
        [ Medusa
strip_type_16bs  * StripType_16Bit
strip_type_24bs  * StripType_24Bit
        ]

;..............................................................................

; Reset the buffer pointer, purging the contents.  Should only be called at
; the start of a strip.

        MACRO
$l      PDumper_Reset $cc
$l      ;DebugEscState PDumper_Reset
        MOV$cc  ofs,#buffer_length      ;Reset the free space in the buffer
        ADR$cc  ptr,buffer_posn         ;..and its position
        MEND

;..............................................................................

; Store a byte into the buffer, flushing if it is full or fills up

        MACRO
$l      PDumper_OutputReg $reg
$l      ;DebugEscState PDumper_OutputReg
        STRB    $reg,[ptr,ofs,LSR #16]  ;Store the character
        ADD     ofs,ofs,#&10000         ;And then advance the pointer
        CMP     ofs,ofs,LSL #16         ;Has the buffer filled up yet?
        PDumper_EmptyBuffer GT
        MEND

;..............................................................................

; Empty the buffer.

        MACRO
$l      PDumper_EmptyBuffer $cc
$l      ;DebugEscState PDumper_EmptyBuffer
        BL$cc   PDumper_EmptyBuffer     ;Empty the buffer
        PDumper_Reset $cc
        MEND

;..............................................................................

; Print a full word, ie. all four bytes.

        MACRO
$l      PDumper_PrintBinaryWord $reg,$temp
$l      ;DebugEscState PDumper_PrintBinaryWord
        MOV     $temp,$reg              ;bits 0..7
        PDumper_OutputReg $temp
        MOV     $temp,$reg,LSR #8       ;bits 8..15
        PDumper_OutputReg $temp
        MOV     $temp,$reg,LSR #16      ;bits 16..23
        PDumper_OutputReg $temp
        MOV     $temp,$reg,LSR #24      ;bits 24..31
        PDumper_OutputReg $temp
        MEND

;..............................................................................

; Print a half word, ie. two bytes.

        MACRO
$l      PDumper_PrintBinaryPair $reg,$temp
$l      ;DebugEscState PDumper_PrintBinaryPair
        MOV     $temp,$reg              ;bits 0..7
        PDumper_OutputReg $temp
        MOV     $temp,$reg,LSR #8       ;bits 8..15
        PDumper_OutputReg $temp
        MEND

; As PrintBinaryPair, but high byte first

        MACRO
$l      PDumper_PrintBinaryPair_HighFirst $reg,$temp
$l      ;DebugEscState PDumper_PrintBinaryPair_HighFirst
        MOV     $temp,$reg ,LSR #8      ;bits 8..15
        PDumper_OutputReg $temp
        MOV     $temp,$reg              ;bits 0..7
        PDumper_OutputReg $temp
        MEND

;..............................................................................

; Print a counted string, data stored as the first byte is its length
; and then data follows on.
;
; If the length byte is zero,this is read to mean that it is a "long" counted string
; potentially up to 16M.The data is then stored as [ 0 ] [ 3 byte length ] [ address ]
;
; Pointer register is advanced beyond the end of the string

        MACRO
$l      PDumper_PrintCountedString $reg,$temp1,$temp2
$l      ;DebugEscState PDumper_PrintCountedString
        LDRB    $temp1,[$reg]           ;Get the length of the string to print
        TEQ     $temp1, #0
        LDREQ   $temp1,[$reg],#4   
        MOVEQ   $temp1,$temp1,LSR#8     ;in both cases $temp1 is now the length
        ADDNE   $reg, $reg, #1
        LDREQ   $reg, [$reg]            ;in both cases $reg now points to the string start
50
        SUBS    $temp1,$temp1,#1        ;Decrease the counter
        BLT     %FT51                   ;..and when <=0 then we must exit!

        LDRB    $temp2,[$reg],#1        ;Get the byte to send
        PDumper_OutputReg $temp2
        B       %BT50                   ;Then loop back until the counter is zero
51
        MEND

;..............................................................................

; Print a string given its length.  The pointer is advance beyond the last character
; in the text and then length string is reset to zero.

        MACRO
$l      PDumper_PrintLengthString $reg,$length,$temp
$l      DebugEscState PDumper_PrintLengthString
        CMP     $length,#buffer_length  ;Is the string longer than the current buffer
        BLT     %FT50                   ;If so just insert

        PDumper_EmptyBuffer             ;Ensure that the buffer is correctly flushed

        Push    "$reg"                  ;Preserve the pointer to the text
        Push    "R0-R3,R4"

        ;Check the GBPB error flag
        ADR     r1, pd_error_flag_set
        LDR     r0, [r1]
        TST     r0, #1 :SHL: 1
        BNE     %01

      [ "$length"<>"R3"
        MOV     R3,$length
      ]
        LDR     R2,[SP,#16]             ;Get the pointer
        LDR     R1,FileHandle
        MOV     R0,#OSGBPB_WriteAtPTR   ;Get the handle and reeason code

        CMP     R3,#0                   ;Is there any data to write (clears V)
        BEQ     %01
        SWI     XOS_GBPB
        DebugIf VC, misc, "OS_GBPB ok"
        BVC     %01
        DebugE  misc, "OS_GBPB error"

        ;Set the GBPB error flag (without corrupting more registers)
        Push    "r0, r1, r2"
        LDR     R0, [R0]
        TEQ     R0, #ErrorNumber_Escape
        BEQ     %20
        ADR     r1, pd_error_flag_set
        LDR     r2, [r1]
        ORR     r2, r2, #1 :SHL: 1
        STR     r2, [r1]
20
        Pull    "r0, r1, r2"

        PDumper_Error                   ;..and then trap any errors that occur
01
        Pull    "R0-R3,R4"
        Pull    "$reg"                  ;Balance the stack and restore the pointers

        ADD     $reg,$reg,$length       ;Advance the pointer beyond the data sent
        B       %FT51
50
        SUBS    $length,$length,#1      ;Decrease the counter
        BLT     %FT51                   ;..and when <=0 then we must exit!

        LDRB    $temp,[$reg],#1         ;Get the byte to send
        PDumper_OutputReg $temp
        B       %BT50                   ;Then loop back until the counter is zero
51

        MEND

;..............................................................................

        GBLS    PDumper_EntryRegList

; Entry to a PDumper routine

        MACRO
$l      PDumper_Entry $reglist
      [ "$reglist"=""
PDumper_EntryRegList SETS "ofs,ptr"     ;Always push the important ones
      |
PDumper_EntryRegList SETS "$reglist,ofs,ptr"
      ]
$l      ;DebugEscState PDumper_Entry
        Push    "lr"
        STR     SP,FramePointer         ;->Return frame+4 ready to exit
        Push    "$PDumper_EntryRegList"
        Debug   misc, "PDumper_Entry lr", lr
        MEND

; Exit from a PDumper routine

        MACRO
$l      PDumper_Exit
$l      ;DebugEscState PDumper_Exit
        [ No32bitCode
        Pull    "$PDumper_EntryRegList ,LR"
        BICS    PC,LR,#V_bit
        |
        CLRV
        Pull    "$PDumper_EntryRegList ,PC"
        ]
        MEND

; Trap an error from a PDumper SWI.  Returning as required. Note that you
; cannot easily preserve all the registers here. It might look as if you
; can by simply restoring the register set as in PDumper_Exit, but
; PDumper_Error calls are not always matched with the right PDumper_Entry.
; Specifically, the PDumper_Error call in the PDumper_EmptyBuffer
; subroutine (see below) gets the register set used in the very last
; PDumper_Entry call before it, yet PDumper_EmptyBuffer is called from
; all over the place with various different sets of pushed registers.
; Any attempt to restore all the registers has to get clever eg. a common
; (and enforced) set of pushed regsiters, or a flag word saying what
; registers were pushed etc. The easiest option (used below) is to not
; restore the registers - PDriverDP doesn't seem to mind on errors.

        MACRO
$l      PDumper_Error
$l      BVC     %79
        DebugE  misc, "PDumper_Error"

        ;Copy the error into a local block. If you don't do this, FileSwitch
        ;overwrites the buffer that MessageTrans gives us with the usual lot of
        ;'Variable <fs>$Path not found' messages.
        BL      PDumper_CopyError
        DebugE  misc, "PDumper_Error (copy)"

        LDR     sp, FramePointer        ; Restore SP as at entry
        LDR     pc, [sp], #4            ; Return (with V set) to the
                                        ; caller of the top-level routine
79
        MEND

;..............................................................................

; Insert routines required for the above code.

        MACRO
$l      PDumper_InsertRoutines

PDumper_GetLeftMargin ROUT
        ;This palaver needed because this routine returns results in R14.
        ;EXITS needs R14 as a temporary register in 32-bit builds.
        Push    "lr"
        Push    "r0,lr"
        SavePSR lr
        Push    lr

        LDR     R14,[R7,#pd_leftmargin -pd_data]

        LDRB    R0,[R7,#pd_data_version -pd_data]
        CMP     R0,#3                   ; is it a version file
        BLT     %FT10

        LDR     R0,[R7,#pd_data_left_offset]
        SUBS    R14,R14,R0
        MOVMI   R14,#0                  ; adjust by margin, account for -ve
10
        STR     R14,[sp, #8]            ; adjust stacked R14
        Pull    lr                      ; retrieve the stacked CPSR
        RestPSR lr,,cf                  ; restore the flags
        Pull    "r0,lr,pc"              ; return from function

PDumper_EmptyBuffer
        DebugEscState PDumper_EmptyBuffer
        Push    "R0-R4,LR"
        SavePSR R0
        Push    r0

        ADR     r1, pd_error_flag_set
        LDR     r0, [r1]                ;check GBPB error bit
        TST     r0, #1 :SHL: 1
        BNE     %01                     ;go away if non-0

        MOV     R0,#OSGBPB_WriteAtPTR
        LDR     R1,FileHandle           ;Get the file handle + reason code
        MOV     R2,ptr
        MOV     R3,ofs,LSR #16          ;Get the pointer and the length

        CMP     R3,#0                   ;Is there any data to write (will clear V)
        BEQ     %01
        SWI     XOS_GBPB
        DebugIf VC, misc, "OS_GBPB ok"
        BVC     %25
        DebugE  misc, "OS_GBPB error"

        ;Set the GBPB error flag (without corrupting more registers)
        Push    "r0, r1, r2"
        LDR     R0, [R0]
        TEQ     R0, #ErrorNumber_Escape
        BEQ     %30
        ADR     r1, pd_error_flag_set
        LDR     r2, [r1]
        ORR     r2, r2, #1 :SHL: 1
        STR     r2, [r1]
30
        Pull    "r0, r1, r2"

        ;Do we need to ignore any errors because we are tidying up
        Push    "R0-R1"
        ADR     R1, pd_error_flag_set
        LDR     R0, [R1]
        TST     R0, #1                  ;Only look at the error bit
        Pull    "R0-R1"
        DebugIf NE, misc, "ignoring error"
        BNE     %FT25                   ; yes - so don't trap the error!

        PDumper_Error                   ;..and then trap any errors
25
        MOV     ofs,#buffer_length      ;Reset the pointer
01
        Pull    r0
        RestPSR r0,,cf
        Pull    "r0-r4,pc"              ;And then exit

PDumper_CopyError ROUT
;Entry
; R0 -> error block
; V set
;Exit
; R0 -> copy of error block in our workspace
; V still set

        Push    "r1-r9, lr"
        MOV     r8, r0
        ADRL    r9, error_buffer

        LCLA    count
        LCLA    i
count   SETA    256/(4*8)               ;bytes in an error block/bytes in r0-r7
i       SETA    0
        WHILE   i < count
        LDMIA   r8!, {r0-r7}
        STMIA   r9!, {r0-r7}
i       SETA    i + 1
        WEND
        SUB     r0, r9, #256
        Pull    "r1-r9, pc"

        MEND

;..............................................................................

; Adjust feed length based on version of the printer description file being
;   used.

        MACRO
$l      PDumper_AdjustFeed $x,$y,$r,$temp
$l      ;DebugEscState PDumper_AdjustFeed
        LDRB    $temp,[$r,#pd_data_version -pd_data]
        CMP     $temp,#3                ; does it have support for the modified feed values
        BLT     %FT10                   ;   no, so ignore it

        Debug   ,"Before offset",$x,$y

        LDR     $temp,[$r,#pd_data_left_offset]
        SUBS    $x,$x,$temp             ; allow for -ve value
        MOVMI   $x,#0
        LDR     $temp,[$r,#pd_data_top_offset]
        SUBS    $y,$y,$temp
        MOVMI   $y,#0                   ; subtract the y offset, account for -ve

        Debug   ,"After offset",$x,$y
10
        MEND

        MACRO
$l      PDumper_GetLeftMargin $r,$cc
$l      ;DebugEscState PDumper_GetLeftMargin
        BL$cc   PDumper_GetLeftMargin
      [ ("$r"="lr") :LOR: ("$r"="LR")
      |
        ! 0,"Compiling to return in $r"
        MOV     $r,R14
      ]
        MEND


        MACRO
$l      DebugEscState   $fn
        [               debug
$l      Push            "r0-r3, lr"
        SavePSR         r3                      ;save flags
        MOV             r0, #229
        MOV             r1, #0
        MOV             r2, #255
        SWI             XOS_Byte
        Debug           misc, "$fn: esc disabled", r1
        RestPSR         r3,,f                   ;restore flags
        Pull            "r0-r3, lr"             ;restore everything else
        ]
        MEND

        END
@


4.9
log
@Build changes,no code changes.
Took out the bodge of prefixing all the files GOT from the Generic
directory with a G,and replaced it with use of new flag "-J" in objasm.
Improved clean rule in top MakeFile.
Deleted some unused !Mk files.

Version 1.38. Tagged as 'PDumpers-1_38'
@
text
@d118 1
a118 1
; 
d126 2
a127 1
        LDREQ   $temp1,[$reg],#4        ;in both cases $temp1 is now the length
@


4.8
log
@Renamed generic driver sources
Makefiles rewritten
Converted to use objasm
First pass at 32 bit compatibility.

Version 1.34. Tagged as 'PDumpers-1_34'
@
text
@d42 1
a42 1
	MOV$cc  ofs,#buffer_length      ;Reset the free space in the buffer
d52 2
a53 2
$l	;DebugEscState PDumper_OutputReg
	STRB    $reg,[ptr,ofs,LSR #16]  ;Store the character
d65 2
a66 2
$l	;DebugEscState PDumper_EmptyBuffer
	BL$cc   PDumper_EmptyBuffer     ;Empty the buffer
d76 2
a77 2
$l	;DebugEscState PDumper_PrintBinaryWord
	MOV     $temp,$reg              ;bits 0..7
d93 2
a94 2
$l	;DebugEscState PDumper_PrintBinaryPair
	MOV     $temp,$reg              ;bits 0..7
d104 2
a105 2
$l	;DebugEscState PDumper_PrintBinaryPair_HighFirst
	MOV     $temp,$reg ,LSR #8      ;bits 8..15
d115 5
a119 2

; Pointer register is advanced beyond the end of the string.
d123 6
a128 2
$l	;DebugEscState PDumper_PrintCountedString
	LDRB    $temp1,[$reg],#1        ;Get the length of the string to print
d146 1
a146 1
$l	DebugEscState PDumper_PrintLengthString
d155 5
a159 5
	;Check the GBPB error flag
	ADR	r1, pd_error_flag_set
	LDR	r0, [r1]
	TST	r0, #1 :SHL: 1
	BNE	%01
d169 15
a183 15
	BEQ	%01
	SWI	XOS_GBPB
	DebugIf	VC, misc, "OS_GBPB ok"
	BVC	%01
	DebugE	misc, "OS_GBPB error"

	;Set the GBPB error flag (without corrupting more registers)
	Push	"r0, r1, r2"
	LDR	R0, [R0]
	TEQ	R0, #ErrorNumber_Escape
	BEQ	%20
	ADR	r1, pd_error_flag_set
	LDR	r2, [r1]
	ORR	r2, r2, #1 :SHL: 1
	STR	r2, [r1]
d185 1
a185 1
	Pull	"r0, r1, r2"
d218 1
a218 1
$l	;DebugEscState PDumper_Entry
d220 1
a220 1
	STR     SP,FramePointer         ;->Return frame+4 ready to exit
d222 1
a222 1
	Debug	misc, "PDumper_Entry lr", lr
d229 1
a229 1
$l	;DebugEscState PDumper_Exit
d254 2
a255 2
$l	BVC	%79
	DebugE  misc, "PDumper_Error"
d257 9
a265 9
	;Copy the error into a local block. If you don't do this, FileSwitch
	;overwrites the buffer that MessageTrans gives us with the usual lot of
	;'Variable <fs>$Path not found' messages.
	BL	PDumper_CopyError
	DebugE  misc, "PDumper_Error (copy)"

        LDR	sp, FramePointer	; Restore SP as at entry
        LDR	pc, [sp], #4		; Return (with V set) to the
        				; caller of the top-level routine
d300 1
a300 1
	DebugEscState PDumper_EmptyBuffer
d305 4
a308 4
	ADR	r1, pd_error_flag_set
	LDR	r0, [r1]		;check GBPB error bit
        TST	r0, #1 :SHL: 1
        BNE	%01			;go away if non-0
d316 3
a318 3
	BEQ	%01
	SWI	XOS_GBPB
	DebugIf	VC, misc, "OS_GBPB ok"
d320 1
a320 1
	DebugE	misc, "OS_GBPB error"
d322 9
a330 9
	;Set the GBPB error flag (without corrupting more registers)
	Push	"r0, r1, r2"
	LDR	R0, [R0]
	TEQ	R0, #ErrorNumber_Escape
	BEQ	%30
	ADR	r1, pd_error_flag_set
	LDR	r2, [r1]
	ORR	r2, r2, #1 :SHL: 1
	STR	r2, [r1]
d332 1
a332 1
	Pull	"r0, r1, r2"
d338 1
a338 1
        TST     R0, #1			;Only look at the error bit
d340 1
a340 1
        DebugIf	NE, misc, "ignoring error"
d359 15
a373 15
	Push	"r1-r9, lr"
	MOV	r8, r0
	ADRL	r9, error_buffer

	LCLA	count
	LCLA	i
count	SETA	256/(4*8)		;bytes in an error block/bytes in r0-r7
i	SETA	0
	WHILE	i < count
	LDMIA	r8!, {r0-r7}
	STMIA	r9!, {r0-r7}
i	SETA	i + 1
	WEND
	SUB     r0, r9, #256
	Pull	"r1-r9, pc"
d384 1
a384 1
$l	;DebugEscState PDumper_AdjustFeed
d404 1
a404 1
$l	;DebugEscState PDumper_GetLeftMargin
d414 14
a427 14
	MACRO
$l	DebugEscState	$fn
	[		debug
$l	Push		"r0-r3, lr"
	SavePSR         r3			;save flags
	MOV		r0, #229
	MOV		r1, #0
	MOV		r2, #255
	SWI		XOS_Byte
	Debug		misc, "$fn: esc disabled", r1
	RestPSR         r3,,f			;restore flags
	Pull		"r0-r3, lr"		;restore everything else
	]
	MEND
@


4.7
log
@  Fixed some stack imbalances that had gone undetected ... until we shipped
    the source code to third parties who actually tested it.
Admin:
  Probably ought to build correct code.


Version 1.27. Tagged as 'PDumpers-1_27'
@
text
@@


4.6
log
@  Merge of Spinner branch.
Detail:
  All Makefiles now export the PDumper header.
Admin:
  Fixes from the spinner branch have been merged in.
  Should now build in the build system.

Version 1.25. Tagged as 'PDumpers-1_25'
@
text
@d177 1
a177 1
20	
d179 1
a179 1
	
d324 1
a324 1
30	
d326 1
a326 1
	
a416 1
	Pull		"lr"
@


4.5
log
@  Fixed some macro problems.
Detail:
  One function was using R14 as a function result register, but R14 is corrupted
    by EXITS in 32-bit builds.  Some faffing around added to get around this.
  Some minor improvements to remove No32bitCode conditionals - the Generic26 and
    Generic32 macros can sort out the differences so this modules invokes those
    macros (CLRPSR, TOGPSRR, WritePSRc) instead.
  Fast service call table added (not the broken one on the Ursula branch)
Admin:
  Built, not tested.

Version 1.23. Tagged as 'PDumpers-1_23'
@
text
@d169 4
a172 1
	Push	"r1, r2"
d177 3
a179 2
	Pull	"r1, r2"

d316 4
a319 1
	Push	"r1, r2"
d324 3
a326 2
	Pull	"r1, r2"

@


4.4
log
@32-bit compatible.

Version 1.21. Tagged as 'PDumpers-1_21'
@
text
@d266 6
a271 2
	;DebugEscState PDumper_GetLeftMargin
        EntryS  "R0"
d277 1
a277 1
        EXITS   LT
d282 5
a286 2

        EXITS
d291 2
d332 3
a334 1
        Pull    "R0-R4,PC"              ;And then exit
d357 1
a357 1
	ADRL	r0, error_buffer
@


4.3
log
@Spinner branch merged
@
text
@d58 1
a58 1
            
d73 1
a73 1
                                        
d85 1
a85 1
        MEND                           
d90 1
a90 1
                                        
d98 1
a98 1
        MEND                           
d101 1
a101 1
                                        
d105 1
a105 1
	MOV     $temp,$reg ,LSR #8      ;bits 8..15   
d109 1
a109 1
        MEND                           
d115 1
a115 1
                           
d125 1
a125 1
                                                                          
d136 1
a136 1
                                                      
d139 1
a139 1
$l	DebugEscState PDumper_PrintLengthString	
d144 1
a144 1
                      
d147 1
a147 1
                          
d186 1
a186 1
                                                                          
d208 3
a210 2
	STR     SP,FramePointer         ;->Return frame ready to exit
        Push    "$PDumper_EntryRegList ,lr"
d218 2
a219 1
$l	;DebugEscState PDumper_Exit	
d222 4
d253 1
a253 1
        LDR	pc, [sp, #-4]		; Return (with V set) to the
d259 1
a259 1
          
d267 1
a267 1
        Push    "R0,LR"                                    
d271 1
a271 1
        LDRB    R0,[R7,#pd_data_version -pd_data]      
d273 1
a273 1
        Pull    "R0,PC",LT,^
d279 1
a279 1
        Pull    "R0,PC",,^
d323 1
a323 1
        Pull    "R0-R4,PC"              ;And then exit 
d336 1
a336 1
	
d362 1
a362 1
           
d367 1
a367 1
        MOVMI   $x,#0                  
d387 1
a387 1
	
d391 2
a392 2
$l	Push		"r0-r2, lr"
	Push		"pc"			;save flags
d399 2
a400 2
	TEQP		lr, #0			;restore flags
	Pull		"r0-r2, lr"		;restore everything else
@


4.2
log
@Version Spin_merge taken
@
text
@d41 2
a42 1
$l      MOV$cc  ofs,#buffer_length      ;Reset the free space in the buffer
d52 2
a53 1
$l      STRB    $reg,[ptr,ofs,LSR #16]  ;Store the character
d65 2
a66 1
$l      BL$cc   PDumper_EmptyBuffer     ;Empty the buffer
d76 2
a77 1
$l      MOV     $temp,$reg              ;bits 0..7
d93 2
a94 1
$l      MOV     $temp,$reg              ;bits 0..7
d104 2
a105 1
$l      MOV     $temp,$reg ,LSR #8      ;bits 8..15   
d120 2
a121 2
$l      
        LDRB    $temp1,[$reg],#1        ;Get the length of the string to print
d139 1
a139 1
                   
d148 6
d162 14
a175 1
        SWINE   XOS_GBPB                ;..yup so send it now
d177 1
a177 1

d207 2
a208 2
$l      
        STR     SP,FramePointer         ;->Return frame ready to exit
d210 1
d217 1
d237 2
a238 2
$l
        DebugE  Error, "Error taken "
d240 10
a249 3
        LDRVS   R14,FramePointer        ; Points ABOVE lr that we need
        SUBVS   sp, r14, #4             ; Ensure stack never too high
        Pull    "pc", VS                ; Error - stuff the flags
d260 1
a260 1

a273 1
                          
d276 2
d279 4
a282 1
        Push    "R0-R4,LR"
d290 13
a302 4
        SWIGT   XOS_GBPB                ;..yup so write it now
        BVC     %FT25

        ; do we need to ignore any errors because we are tidying up
d304 1
d308 1
a308 1
        TEQ     R0, #1
d310 3
a312 1
        BEQ     %FT25                   ; yes - so don't trap the error!
d316 1
d318 25
d352 1
a352 1
$l
d372 1
a372 1
$l
d380 17
@


4.1
log
@Initial revision
@
text
@d95 10
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a94 10
; As PrintBinaryPair, but high byte first
                                        
        MACRO
$l      PDumper_PrintBinaryPair_HighFirst $reg,$temp
$l      MOV     $temp,$reg ,LSR #8      ;bits 8..15   
        PDumper_OutputReg $temp
        MOV     $temp,$reg              ;bits 0..7
        PDumper_OutputReg $temp
        MEND                           

@


4.1.7.2
log
@  Introduce 'PDumper in use' error, reported if PDumper is reentered (in the
foreground).
   Introduce 'GBPB error' bit, suppresses calls to OS_GBPB while set.
   Use local error block for MessageTrans.
@
text
@a141 6
	;Check the GBPB error flag
	ADR	r1, pd_error_flag_set
	LDR	r0, [r1]
	TST	r0, #1 :SHL: 1
	BNE	%01

d152 1
a152 1
01
a212 8
	;Set the GBPB error flag (without corrupting more registers)
	Push	"r1, r2", VS
	ADRVS	r1, pd_error_flag_set
	LDRVS	r2, [r1]
	ORRVS	r2, r2, #1 :SHL: 1
	STRVS	r2, [r1]
	Pull	"r1, r2", VS

a245 5
	ADR	r1, pd_error_flag_set
	LDR	r0, [r1]		;check GBPB error bit
        TST	r0, #1 :SHL: 1
        BNE	%01			;go away if non-0

a265 1
01
@


4.1.7.3
log
@   Return an error EscDisabled if any PDumper is called with escape disabled.
   Check the GBPB error flag before checking the error-suppress flag.
   Copy the error block returned by OS_GBPB so FileSwitch doesn't overwrite it.
@
text
@d41 1
a41 2
$l      ;DebugEscState PDumper_Reset
	MOV$cc  ofs,#buffer_length      ;Reset the free space in the buffer
d51 1
a51 2
$l	;DebugEscState PDumper_OutputReg
	STRB    $reg,[ptr,ofs,LSR #16]  ;Store the character
d63 1
a63 2
$l	;DebugEscState PDumper_EmptyBuffer
	BL$cc   PDumper_EmptyBuffer     ;Empty the buffer
d73 1
a73 2
$l	;DebugEscState PDumper_PrintBinaryWord
	MOV     $temp,$reg              ;bits 0..7
d89 1
a89 2
$l	;DebugEscState PDumper_PrintBinaryPair
	MOV     $temp,$reg              ;bits 0..7
d99 1
a99 2
$l	;DebugEscState PDumper_PrintBinaryPair_HighFirst
	MOV     $temp,$reg ,LSR #8      ;bits 8..15   
d114 2
a115 2
$l	;DebugEscState PDumper_PrintCountedString
	LDRB    $temp1,[$reg],#1        ;Get the length of the string to print
d133 1
a133 1
$l	DebugEscState PDumper_PrintLengthString	
d156 1
a156 14
	BEQ	%01
	SWI	XOS_GBPB
	DebugIf	VC, misc, "OS_GBPB ok"
	BVC	%01
	DebugE	misc, "OS_GBPB error"

	;Set the GBPB error flag (without corrupting more registers)
	Push	"r1, r2"
	ADR	r1, pd_error_flag_set
	LDR	r2, [r1]
	ORR	r2, r2, #1 :SHL: 1
	STR	r2, [r1]
	Pull	"r1, r2"

d188 2
a189 2
$l	;DebugEscState PDumper_Entry
	STR     SP,FramePointer         ;->Return frame ready to exit
a190 1
	Debug	misc, "PDumper_Entry lr", lr
a196 1
$l	;DebugEscState PDumper_Exit	
d216 2
a217 2
$l	BVC	%79
	DebugE  misc, "PDumper_Error"
d219 11
a229 10
	;Copy the error into a local block. If you don't do this, FileSwitch
	;overwrites the buffer that MessageTrans gives us with the usual lot of
	;'Variable <fs>$Path not found' messages.
	BL	PDumper_CopyError
	DebugE  misc, "PDumper_Error (copy)"

        LDR	sp, FramePointer	; Restore SP as at entry
        LDR	pc, [sp, #-4]		; Return (with V set) to the
        				; caller of the top-level routine
79
d240 1
a240 1
	;DebugEscState PDumper_GetLeftMargin
d254 1
d257 1
a257 1
	DebugEscState PDumper_EmptyBuffer
d271 2
a272 5
	BEQ	%01
	SWI	XOS_GBPB
	DebugIf	VC, misc, "OS_GBPB ok"
        BVC     %25
	DebugE	misc, "OS_GBPB error"
d274 1
a274 7
	;Set the GBPB error flag (without corrupting more registers)
	Push	"r1, r2"
	ADR	r1, pd_error_flag_set
	LDR	r2, [r1]
	ORR	r2, r2, #1 :SHL: 1
	STR	r2, [r1]
	Pull	"r1, r2"
a275 1
        ;Do we need to ignore any errors because we are tidying up
d279 1
a279 1
        TST     R0, #1			;Only look at the error bit
d281 1
a281 3
        DebugIf	NE, misc, "ignoring error"
        BNE     %FT25                   ; yes - so don't trap the error!

a286 25

PDumper_CopyError ROUT
;Entry
; R0 -> error block
; V set
;Exit
; R0 -> copy of error block in our workspace
; V still set

	Push	"r1-r9, lr"
	MOV	r8, r0
	ADRL	r9, error_buffer
	
	LCLA	count
	LCLA	i
count	SETA	256/(4*8)		;bytes in an error block/bytes in r0-r7
i	SETA	0
	WHILE	i < count
	LDMIA	r8!, {r0-r7}
	STMIA	r9!, {r0-r7}
i	SETA	i + 1
	WEND
	ADRL	r0, error_buffer
	Pull	"r1-r9, pc"

d296 1
a296 1
$l	;DebugEscState PDumper_AdjustFeed
d316 1
a316 1
$l	;DebugEscState PDumper_GetLeftMargin
a323 17

	
	MACRO
$l	DebugEscState	$fn
	[		debug
$l	Push		"r0-r2, lr"
	Push		"pc"			;save flags
	MOV		r0, #229
	MOV		r1, #0
	MOV		r2, #255
	SWI		XOS_Byte
	Debug		misc, "$fn: esc disabled", r1
	Pull		"lr"
	TEQP		lr, #0			;restore flags
	Pull		"r0-r2, lr"		;restore everything else
	]
	MEND
@


4.1.7.4
log
@restricted the ban on output when a GBPB error occurs, to continue under the escape
condition to allow communication with the printer, allowing the end of page to be
sent.
@
text
@d169 1
a169 4
	Push	"r0, r1, r2"
	LDR	R0, [R0]
	TEQ	R0, #ErrorNumber_Escape
	BEQ	%20
d174 2
a175 3
20	
	Pull	"r0, r1, r2"
	
d297 1
a297 4
	Push	"r0, r1, r2"
	LDR	R0, [R0]
	TEQ	R0, #ErrorNumber_Escape
	BEQ	%30
d302 2
a303 3
30	
	Pull	"r0, r1, r2"
	
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a94 10
; As PrintBinaryPair, but high byte first
                                        
        MACRO
$l      PDumper_PrintBinaryPair_HighFirst $reg,$temp
$l      MOV     $temp,$reg ,LSR #8      ;bits 8..15   
        PDumper_OutputReg $temp
        MOV     $temp,$reg              ;bits 0..7
        PDumper_OutputReg $temp
        MEND                           

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a94 10
; As PrintBinaryPair, but high byte first
                                        
        MACRO
$l      PDumper_PrintBinaryPair_HighFirst $reg,$temp
$l      MOV     $temp,$reg ,LSR #8      ;bits 8..15   
        PDumper_OutputReg $temp
        MOV     $temp,$reg              ;bits 0..7
        PDumper_OutputReg $temp
        MEND                           

@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

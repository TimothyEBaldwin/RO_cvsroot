head	4.6;
access;
symbols
	PDumpers-1_46:4.6
	PDumpers-1_45:4.6
	PDumpers-1_44:4.6
	PDumpers-1_43:4.6
	PDumpers-1_42:4.6
	PDumpers-1_41:4.6
	RO_5_07:4.6
	PDumpers-1_40:4.6
	PDumpers-1_39:4.6
	PDumpers-1_38:4.6
	PDumpers-1_37:4.5
	PDumpers-1_36:4.5
	PDumpers-1_35:4.5
	PDumpers-1_34:4.5
	PDumpers-1_33:4.4
	PDumpers-1_32:4.4
	PDumpers-1_31:4.4
	PDumpers-1_30:4.4
	PDumpers-1_29:4.4
	PDumpers-1_27:4.4
	PDumpers-1_26:4.4
	PDumpers-1_25:4.4
	Spin_merge-1_21:4.1.7.1
	PDumpers-1_24:4.4
	PDumpers-1_23:4.3
	PDumpers-1_22:4.3
	dellis_autobuild_BaseSW:4.2
	PDumpers-1_21:4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.4
	dcotton_MPT2_build_16061999:4.1.7.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.1
	Ursula_RiscPC:4.1.7.1.0.6
	nicke_PDumpers-1_21:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.7.1
	UrsulaBuild_FinalSoftload:4.1.7.1
	rthornb_UrsulaBuild-12Aug1998:4.1.7.1
	aglover_UrsulaBuild-05Aug1998:4.1.7.1
	rthornb_UrsulaBuild-29Jul1998:4.1.7.1
	rthornb_UrsulaBuild-22Jul1998:4.1.7.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.1.7.1
	rthornb_UrsulaBuild-17Jun1998:4.1.7.1
	rthornb_UrsulaBuild-03Jun1998:4.1.7.1
	rthornb_UrsulaBuild-27May1998:4.1.7.1
	rthornb_UrsulaBuild-21May1998:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Ursula:4.1.7.1.0.4
	Ursula_bp:4.1.7.1
	Ursula_31Mar1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spin_merge_28May97:4.1.7.1
	Spinner_B10:4.1.7.1
	Spin_merge_16May97:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2002.12.17.18.54.45;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.15.16.05.24;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2000.11.26.11.22.00;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.10.19.14.01.57;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	2000.06.09.11.07.58;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.49.14;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.49.14;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.11.08;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.30.28;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.33.48;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Build changes,no code changes.
Took out the bodge of prefixing all the files GOT from the Generic
directory with a G,and replaced it with use of new flag "-J" in objasm.
Improved clean rule in top MakeFile.
Deleted some unused !Mk files.

Version 1.38. Tagged as 'PDumpers-1_38'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > OutputDump

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Specialised 24 pin PDumper.
; ---------------------------
;
                GET     ^.Generic.OutputDump.s

;..............................................................................
;
; Output monochrome sprite to the current file.
;
;  in: R0 ->Strip
;      R1 dump width in bytes
;      R2 dump height in rows
;      R3 row width in bytes (>=R3)
;      R5 Row width in bytes
;      R7 ->Job workspace
;
; out: -

output_mono_sprite ROUT

        Push    "LR"

        Debug   Dump,"Strip at",R0
        Debuga  Dump,"Width in pixels",R1
        Debug   Dump," and in bytes",R3
        Debug   Dump,"Number of scans",R4

        ADD     R7,R7,#pd_data          ; Address the sequences
04                                      ; Back for next total pass
        SWI     XOS_ReadEscapeState
        Pull    "PC",CS                 ; Return if an escape is pending

        Push    "R0"                    ; Preserve the line start for interlace
        MOV     R2,#0                   ; Vertical interlace

        LDRB    R1,[R7,#pd_interlace -pd_data]
        ADD     R1,R1,#1                ; Multiply line step by vertical interlace factor
03                                      ; Back for next vert. interlace pass
        Push    "R0-R5"

        MOV     r4, #255
        MOV     r3, r5
        BL      get24_length            ; Get the length of a 24 line
        MOVS    R3,LR,LSL #3            ; Multiply length by 8
        BLE     %FT10                   ; Skip this line if length is zero

; Adjust start position and length for leading zeros, and then modify the
; skip length to include the left margin and to be in the skip DPI, which
; is always 60 (for EPSONs) or 120 (for IBMs). Returns remainder of skip
; in R4. If we are not skipping, put the left margin in R4 instead.

        MOVS    r8, r8, LSL #3          ; Multiply skip by 8
        PDumper_GetLeftMargin R4,EQ
;<<        LDREQ   r4, [r7, #pd_leftmargin - pd_data]      ; Margin if no skip
        ADDNE   r0, r0, r8, LSR #3      ; Adjust the data start, NO multiply
        BLNE    adjust_24_skip

        MUL     R5,R1,R5
        LDRB    R9,[R7,#pd_x_interlace -pd_data]
02                                      ; Back for next X interlace pass
        Push    "R0,R3,R8,R9"           ; Preserve line start and horizontal interlace
        TEQ     R8, #0
        BEQ     %FT20                   ; No leading zero skip
        LDRB    R1, [R7, #pd_data_zero_skip]
        ADD     R1, R7, R1
        PDumper_PrintCountedString R1,R2,LR
        PDumper_PrintBinaryPair R8,R2
20                                      ; No leading zero skip
        LDRB    R1,[R7,#pd_data_line_start]
        CMP     R1,#0                   ; Line start data
        BEQ     %FT20

        ADD     R1,R7,R1
        PDumper_PrintCountedString R1,R2,R6
20
        LDRB    R1,[R7,#pd_data_dlm]    ; Line length * dlm + dla
        ADD     LR,R4,R3                ; Add left margin or skip remainder
        LDRB    R6,[R7,#pd_data_dla]
        MLA     R6,R1,LR,R6             ; Calculate the total line length
        PDumper_PrintBinaryPair R6,R1

        LDRB    R1,[R7,#pd_data_line_start_2]
        CMP     R1,#0                   ; Is there a second line start sequence
        BEQ     %FT20

        ADD     R1,R7,R1
        PDumper_PrintCountedString R1,R2,R6
20
        BL      send24_leading          ; Output margin/excess skip as zeros

        MOV     R2,#1                   ; Per dump_depth do R3 bits across, using R2 as mask
01                                      ; Back for next X position
        Push    "R0,R7"

        LDRB    R7,[R7,#pd_data_dht]    ;Get number of bit rows high (<=24)

        MOV     R6,#0
        CMP     R9,#0
        BNE     %FT20                   ;If at ignore point output a null

        CMP     R7,#24
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#22
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#20
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#18
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#16
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#14
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#12
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#10
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
20
        PDumper_OutputReg R6

        MOV     R6,#0
        CMP     R9,#0
        BNE     %FT20                   ;If at ignore point output a null

        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
20
        PDumper_OutputReg R6

        MOV     R6,#0
        CMP     R9,#0
        BNE     %FT20                   ;If at ignore point output a null

        CMP     R7,#9
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#11
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#13
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#15
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#17
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#19
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#21
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#23
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R2
        ORRNE   R6,R6,#1
80
20
        PDumper_OutputReg R6

        Pull    "R0,R7"                 ; Move to next horizontal position

        SUBS    R9,R9,#1
        LDRMIB  R9,[R7,#pd_x_interlace -pd_data]
        MOV     R2,R2,LSL #1
        CMP     R2,#128
        ADDGT   R0,R0,#1
        MOVGT   R2,#1
        SUBS    R3,R3,#1
        BGT     %BT01                   ; Go back for next horiz. position
25
        Pull    "R0,R3,R8,R9"           ; Handle the horizontal interlace
        SUBS    R9,R9,#1
        BLT     %FT10

        LDRB    R1,[R7,#pd_data_line_return]
        CMP     R1,#0                   ; Line return data
        BEQ     %FT20

        ADD     R1,R7,R1
        PDumper_PrintCountedString R1,R2,LR
20
        B       %BT02                   ; Go back for next X interlace pass
10
        Pull    "R0-R5"

        Debug   Dump,"Line now finished"

        ADD     R8,R7,#pd_data_line_end
        LDRB    R8,[R8,R2]
        CMP     R8,#0                   ;Is there any for this pass?
        BEQ     %FT20

        ADD     R8,R7,R8
        PDumper_PrintCountedString R8,R9,R6
20
        ADD     R2,R2,#1
        ADD     R0,R0,R5
        CMP     R2,R1
        BLT     %BT03                   ; Go back for next vert. interlace

        Pull    "R0"                    ; Now move down by dht*interlace rows and do next lot

        LDRB    R8,[R7,#pd_data_dht]
        MUL     R8,R1,R8
        MLA     R0,R5,R8,R0
        SUBS    R4,R4,R8
        BGT     %BT04                   ; Go back for next total pass

        Debug   Dump,"Finished strip"

        Pull    "PC"

;..............................................................................
;
; Output a 8BPP sprite to the current file.
;
;  in: R0 ->Strip
;      R1 dump width in bytes
;      R2 dump height in rows
;      R3 row width in bytes (>=R3)
;      R5 Row width in bytes
;      R7 ->Job workspace
;
; out: -

output_grey_sprite ROUT
output_colour_sprite ROUT

        Push    "LR"

        ADD     R7,R7,#pd_data
05                                      ; Back for next total pass
        SWI     XOS_ReadEscapeState
        Pull    "PC",CS                 ; Return if escape pending

        Push    "R0"

        MOV     R2,#0                   ; Level of vertical interlace

        LDRB    R1,[R7,#pd_interlace -pd_data]
        ADD     R1,R1,#1
04                                      ; Back for next vert. interlace pass
        Push    "R0-R5"
stack_04_r0 * 0
stack_04_r5 * 20

        MUL     R5,R1,R5                ; Vertical line data step multiplied by interlace
        MOV     R6,#0                   ;Multiple ribbon passes required
03                                      ; Back for next colour pass
        MOV     R9,#1
        MOV     R4,R9,LSL R6            ; Get correct bit for this pass

        LDR     r0, [sp, #stack_04_r0]
        LDR     r3, [sp, #stack_04_r5]
        BL      get24_length
        MOVS    R3, LR                  ; Is this colour pass zero length?
        MOVLE   r1, #0                  ; Flag to say no line return please
        BLE     %FT11                   ; Go and do the next color pass

; Adjust start position and length for leading zeros, and then modify the
; skip length to include the left margin and to be in the skip DPI, which
; is always 60 (for EPSONs) or 120 (for IBMs). Returns remainder of skip
; in R4. If we are not skipping, put the left margin in R4 instead.

        TEQ     r8, #0
        PDumper_GetLeftMargin R4,EQ
;<<        LDREQ   r4, [r7, #pd_leftmargin - pd_data]      ; Margin if no skip
        ADDNE   r0, r0, r8              ; Adjust the data start.
        BLNE    adjust_24_skip          ; Tramples on mask in r4.

        LDRB    R9,[R7,#pd_x_interlace -pd_data]
02                                      ; Back for next X interlace pass
        Push    "R0,R3,R4,R6,R8,R9"
stack_02_r6 * 12

        TEQ     R8, #0
        BEQ     %FT20                   ; No leading zero skip
        LDRB    R1, [R7, #pd_data_zero_skip]
        ADD     R1, R7, R1
        PDumper_PrintCountedString R1,R2,LR
        PDumper_PrintBinaryPair R8,R2
20                                      ; No leading zero skip
        LDRB    LR,[R7,#pd_passes_per_line -pd_data]
        CMP     LR,#1                   ;Line start (pd_data_line_start+ 2*ribbonpass +2 if passes >1)
        MOV     R6,R6,ASL#1
        ADDGT   R6,R6,#2
        ADD     R6,R6,#pd_data_line_start
        LDRB    R1,[R7,R6]
        CMP     R1,#0                   ;Any sequence for this pass?
        BEQ     %FT20                   ;Obviously not

        ADD     R1,R7,R1
        PDumper_PrintCountedString R1,R2,LR
20
        LDRB    R1,[R7,#pd_data_dlm]
        ADD     LR,R4,R3                ; Add left margin or skip remainder
        LDRB    r8,[R7,#pd_data_dla]
        MLA     r8,R1,LR,r8             ;Line length+left margin *dlm +dla
        PDumper_PrintBinaryPair r8,R1

        ADD     R6,R6,#1                ;Line start 2 data (pd_data_line_start+ 2*....

        LDRB    R1,[R7,R6]
        CMP     R1,#0                   ;Any postfixing string
        BEQ     %FT20

        ADD     R1,R7,R1
        PDumper_PrintCountedString R1,R2,LR
20
        BL      send24_leading          ; Output margin/excess skip as zeros
        LDR     lr, [sp, #stack_02_r6]  ; Get colour pass number now that
        MOV     r4, #1                  ; we have finished with r4.
        MOV     r4, r4, LSL lr          ; Get correct bit for this pass.

        MOV     R8,R3                   ;Setup the horizontal bit count per bit slice horizontally
01                                      ; Back for next X position
        Push    "R0,R7"

        LDRB    R7,[R7,#pd_data_dht]    ;Get number of bit rows high (<=24)

        MOV     R6,#0
        CMP     R9,#0
        BNE     %FT20                   ;If at ignore point output a null

        CMP     R7,#24
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#22
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#20
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#18
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#16
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#14
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#12
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#10
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
20
        PDumper_OutputReg R6

        MOV     R6,#0
        CMP     R9,#0
        BNE     %FT20                   ;If at ignore point output a null

        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
20
        PDumper_OutputReg R6

        MOV     R6,#0
        CMP     R9,#0
        BNE     %FT20                   ;If at ignore point output a null

        CMP     R7,#9
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#11
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#13
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#15
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#17
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#19
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#21
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
        MOV     R6,R6,LSL #1            ;Munge in bit from pass correctly

        CMP     R7,#23
        BLT     %FT80
        LDRB    R1,[R0],R5
        TST     R1,R4
        ORRNE   R6,R6,#1
80
20
        PDumper_OutputReg R6

        Pull    "R0,R7"

        SUBS    R9,R9,#1
        LDRMIB  R9,[R7,#pd_x_interlace -pd_data]
        ADD     R0,R0,#1
        SUBS    R8,R8,#1
        BGT     %BT01                   ;Now move on to next x position

        Pull    "R0,R3,R4,R6,R8,R9"     ;Handle horizontal interlace
        SUBS    R9,R9,#1
        BLT     %FT10

        LDRB    R1,[R7,#pd_data_line_return]
        CMP     R1,#0                   ;Is there any return data?
        BEQ     %FT20

        ADD     R1,R7,R1
        PDumper_PrintCountedString R1,R2,LR
20
        B       %BT02
10
        LDRB    R1,[R7,#pd_data_line_return]
11                                      ; Come here to miss a colour pass
        LDRB    R8,[R7,#pd_passes_per_line -pd_data]
        ADD     R6,R6,#1
        CMP     R6,R8                   ;Multi-ribbon handling?
        BGE     %FT25

        CMP     R1,#0                   ;Output line return data
        BEQ     %FT20

        ADD     R8,R7,R1
        PDumper_PrintCountedString R8,R1,R2
20
        B       %BT03
25
        Pull    "R0-R5"

        ADD     R8,R7,#pd_data_line_end
        LDRB    R8,[R8,R2]
        CMP     R8,#0                   ;End of line sequence
        BEQ     %FT20                   ;There is not one

        ADD     R8,R7,R8
        PDumper_PrintCountedString R8,R9,R6
20
        ADD     R2,R2,#1                ;Move down to correct position and next interlace line
        ADD     R0,R0,R5
        CMP     R2,R1
        BLT     %BT04                   ;Loop back

        Pull    "R0"

        LDRB    R8,[R7,#pd_data_dht]
        MUL     R8,R1,R8
        MLA     R0,R5,R8,R0
        SUBS    R4,R4,R8
        BGT     %BT05                   ;Move down by dht rows and do next lot

        Pull    "PC"

;..............................................................................
;
; send24_leading .. send leading zeros for the 24 pin dumper
;
; in    R4 = number of pixels to output
;       R7 ->pd_data block
; out   V =1 => R0 -> error block

send24_leading ROUT

        Push    "R0-R1,LR"

        MOV     R0,#0
        MOV     R1,#24
        MUL     R1,R4,R1                ;Data to be sent (zeros * 24)

send24_leadingloop
        SUBS    R1,R1,#8                ;Decrease by 8 as dump depth is a multiple of 8
        Pull    "R0-R1,PC",MI           ;And return when <0

        PDumper_OutputReg R0
        B       send24_leadingloop      ;Loop back until all sent


;..............................................................................
;
; get24_length .. obtain length of a scan line, removing any trailing and
; leading zeros.
;
; Get the line length of the line to be sent.
; This routine attempts to ensure that the length of the line is valid.  The
; routine scans the line attempting to find the point where no more data is
; transmitted.  The loop has to check the complete dump depth and returns the
; byte width which you should then modify as required for you specific dumper.
;
; The routine checks all scans within the specified dump depth (a multiple
; of 8) and then returns.
;
;  in: R0 ->Strip to be scanned
;      r3 Original length of a line
;      R4 - bit mask for this pass
;      R7 ->Configuration block
; out: r0 -> adjusted start of strip
;      r8 = skip length, at printer skip DPI (usually 60 or 120)
;      LR = modified length of the line
;

get24_length Entry "R0-R2,R6"
  [ No32bitCode
stack_get24_r0 * Proc_RegOffset
  |
        SavePSR r2
        Push    r2
stack_get24_r0 * Proc_RegOffset + 4
  ]

; Find trailing zeros first.
        LDRB    R1, [R7, #pd_dump_depth -pd_data]
        MOV     R2, #-1         ; Shortest number of trailing zeros so far

get24_trail_newline
        MOV     r6, r3          ; Length of line to be printed

get24_trail_scanline
        SUB     r6, r6, #1      ; Have we finished the line yet?
        CMP     r6, r2
        BLE     get24_trail_finishedline

        LDRB    LR, [R0, r6]
        TST     LR, r4          ; Any trailing zeros?
        BEQ     get24_trail_scanline  ; Loop again until either end of line or non-zero byte

get24_trail_finishedline
        MOV     R2, r6          ; Update shortest trailing zeros found

        ADD     R0, R0, r3      ; Adjust starting position
        SUBS    R1, R1, #1      ; Have we checked all the scan lines yet?
        BGT     get24_trail_newline

        ADDS    LR, R2, #1
        LDRNEB  r1, [r7, #pd_data_version - pd_data]
        TEQNE   r1, #0          ; Check for version > 0
        LDRNEB  r1, [r7, #pd_data_zero_skip]
        TEQNE   r1, #0          ; Quit now if can't skip on this printer or
        MOVEQ   r8, #0          ; if line zero length (for speed and ease)
        BEQ     get24_length_exit


; Now find leading zeros.
        LDR     r0, [sp, #stack_get24_r0]
        LDRB    r1, [r7, #pd_dump_depth -pd_data]
        MOV     r8, lr          ; Don't go into trailing zeros

get24_lead_newline
        MOV     r6, #-1         ; Sart at beginning of line

get24_lead_scanline
        ADD     r6, r6, #1      ; Have we finished the line yet?
        CMP     r6, r8
        BGE     get24_lead_finishedline

        LDRB    r2, [r0, r6]
        TST     r2, r4          ; Any leading zeros?
        BEQ     get24_lead_scanline  ; Loop again until non-zero byte

get24_lead_finishedline
        MOV     r8, r6          ; Update shortest leading zeros found

        ADD     r0, r0, r3      ; Adjust starting position
        SUBS    r1, r1, #1      ; Have we checked all the scan lines yet?
        BGT     get24_lead_newline

; Adjust returned data length to skip the zeros.

        SUB     lr, lr, r8
get24_length_exit
  [ No32bitCode
        EXITS
  |
        Pull    r2
        RestPSR r2,,f
        EXIT
  ]


; This routine adds the left margin into the length to skip, and then
; modifies the skip to be at the skip resolution. The remainder of this is
; calculated (eg. 60 DPI skip at 180 DPI gives remainders of 0,1 or 2), to
; be output as extra zeros, effectively as a new sort of "left margin".

; In:   r8 = skip at output DPI without left margin
; Out:  r4 = skip remainder at output DPI inc. left margin
;       r8 = skip at skip DPI inc. left margin

adjust_24_skip EntryS "r0-r2"
        PDumper_GetLeftMargin lr
        ADD     r8, r8, lr      ; Add left margin to zero skip.

        LDRB    r2, [r7, #pd_data_pixel_run_up] ; 1/6 inch run-up for head
        SUBS    r8, r8, r2      ; Subtract run-up from zero skip
        ADDMI   r4, r2, r8      ; Reduce run-up if skip goes negative
        MOVMI   r8, #0          ; Ensure skip not negative
        EXITS   MI              ; Skip is zero so might as well quit

        LDR     r1, [r7, #pd_data_skip_multiplier]
        MUL     r0, r8, r1      ; Multiply by multiplier

        LDR     r4, [r7, #pd_data_skip_divider] ; Divide by divider
        TEQ     r4, #1          ; Is divider 1?
        MOVEQ   r4, r2          ; If so, remainder is run-up and
        MOVEQ   r8, r0          ; result is unaffected.
        EXITS   EQ
        DivRem  r8, r0, r4, lr  ; r4 is preserved, r0 becomes remainder

        TEQ     r1, #1          ; Is multiplier 1?
        ADDEQ   r4, r0, r2      ; Put print head run up on to remainder
        EXITS   EQ
        DivRem  r4, r0, r1, lr  ; Divide remainder by multiplier

        ADD     r4, r4, r2      ; Put print head run up on to remainder
        EXITS

        END
@


4.5
log
@Renamed generic driver sources
Makefiles rewritten
Converted to use objasm
First pass at 32 bit compatibility.

Version 1.34. Tagged as 'PDumpers-1_34'
@
text
@d22 1
a22 1
                GET     ^.Generic.GOutputDump.s
@


4.4
log
@  32-bit fixes.
Detail:
  Some routines using EXITS needed R14 as a result register.
    These routines now work in 32-bit modes.
  Fixed ADR lr, unthread to be JumpAddress lr, unthread so that
    26-bit builds work when the routine jumped to uses EntryS.
Admin:
  Built 26-bit and 32-bit versions - untested,

Version 1.24. Tagged as 'PDumpers-1_24'
@
text
@d22 1
a22 1
                GET     ^.Generic.s.OutputDump
d750 1
a750 1
get24_length ENTRY "R0-R2,R6"
@


4.3
log
@  32-bit fixes - some stack offsets were wrong.
Admin:
  Built 26-bit and 32-bit builds.
  Not tested.

Version 1.22. Tagged as 'PDumpers-1_22'
@
text
@d750 2
a751 1
get24_length EntryS "R0-R2,R6"
d753 5
d788 1
a788 1
        EXITS   EQ
d818 2
d821 5
@


4.2
log
@32-bit compatible.

Version 1.21. Tagged as 'PDumpers-1_21'
@
text
@d751 1
a751 1
stack_get24_r0 * 0
@


4.1
log
@Initial revision
@
text
@d40 1
a40 1
  
d64 1
a64 1
  
d330 1
a330 1
        
d368 1
a368 1
       
d384 1
a384 1
                      
d661 1
a661 1
        B       %BT02           
d694 1
a694 1
        
d704 1
a704 1
; 
d728 1
a728 1
; 
d733 1
a733 1
; This routine attempts to ensure that the length of the line is valid.  The 
d738 1
a738 1
; The routine checks all scans within the specified dump depth (a multiple 
d750 1
a750 1
get24_length ENTRY "R0-R2,R6"
d756 1
a756 1
                                
d759 1
a759 1
        
d768 2
a769 2
          
get24_trail_finishedline      
d771 1
a771 1
       
d775 1
a775 1
                      
d789 1
a789 1
                                
d792 1
a792 1
        
d801 1
a801 1
          
d804 1
a804 1
       
d824 1
a824 1
adjust_24_skip ENTRY "r0-r2"
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

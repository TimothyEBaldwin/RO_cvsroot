head	4.8;
access;
symbols
	PDumpers-1_46:4.8
	PDumpers-1_45:4.8
	PDumpers-1_44:4.8
	PDumpers-1_43:4.8
	PDumpers-1_42:4.8
	PDumpers-1_41:4.8
	RO_5_07:4.8
	PDumpers-1_40:4.8
	PDumpers-1_39:4.8
	PDumpers-1_38:4.8
	PDumpers-1_37:4.7
	PDumpers-1_36:4.7
	PDumpers-1_35:4.7
	PDumpers-1_33:4.6
	PDumpers-1_32:4.6
	PDumpers-1_31:4.6
	PDumpers-1_30:4.6
	PDumpers-1_29:4.6
	PDumpers-1_27:4.6
	PDumpers-1_26:4.6
	PDumpers-1_25:4.6
	Spin_merge-1_21:4.1.7.2
	PDumpers-1_24:4.6
	PDumpers-1_23:4.5
	PDumpers-1_22:4.5
	dellis_autobuild_BaseSW:4.4
	PDumpers-1_21:4.4
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.6
	dcotton_MPT2_build_16061999:4.1.7.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.2
	Ursula_RiscPC:4.1.7.2.0.4
	nicke_PDumpers-1_21:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.1.7.2
	UrsulaBuild_FinalSoftload:4.1.7.2
	rthornb_UrsulaBuild-12Aug1998:4.1.7.2
	aglover_UrsulaBuild-05Aug1998:4.1.7.2
	rthornb_UrsulaBuild-29Jul1998:4.1.7.2
	rthornb_UrsulaBuild-22Jul1998:4.1.7.2
	hsimons_BOCA-1_2-Release:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.1.7.2
	rthornb_UrsulaBuild-07Jul1998:4.1.7.2
	rthornb_UrsulaBuild-17Jun1998:4.1.7.2
	rthornb_UrsulaBuild-03Jun1998:4.1.7.2
	rthornb_UrsulaBuild-27May1998:4.1.7.2
	rthornb_UrsulaBuild-21May1998:4.1.7.2
	rthornb_UrsulaBuild_01May1998:4.1.7.2
	afrost_NC2_Generic:4.1.7.2
	afrost_Funai01-33:4.1.7.2
	Ursula:4.1.7.2.0.2
	Ursula_bp:4.1.7.2
	Ursula_31Mar1998:4.3
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spin_merge_28May97:4.1.7.2
	Spinner_B10:4.1.7.2
	Spin_merge_16May97:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2002.12.17.18.54.54;	author srevill;	state Exp;
branches;
next	4.7;

4.7
date	2002.11.15.16.05.33;	author srevill;	state Exp;
branches;
next	4.6;

4.6
date	2000.11.26.11.22.01;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.19.14.01.57;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.06.09.11.08.05;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	97.05.16.12.47.17;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.22.15.09.09;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.49.26;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.49.26;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.13.43;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.31.41;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.35.05;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.05.14.09.42.00;	author jcoxhead;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Build changes,no code changes.
Took out the bodge of prefixing all the files GOT from the Generic
directory with a G,and replaced it with use of new flag "-J" in objasm.
Improved clean rule in top MakeFile.
Deleted some unused !Mk files.

Version 1.38. Tagged as 'PDumpers-1_38'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > OutputDump

        GET     ^.Generic.OutputDump.s

; debugDump SETL true


;Macro to perform bit transforms on the data about to be sent to the
;device, this should be called proir to doing a counted string output
;it will preserve the start and size registers but will destory
;the three temporary registers.

        MACRO
$l      LJTranspose $start,$size,$temp1,$temp2,$temp3
$l
        Push    "$start,$size"  ;Preserve start and end points correctly
00
        SUBS    $size,$size,#1  ;Have we finished sending the line yet?
        BLT     %FT20           ;Yes so exit the main loop

        LDRB    $temp1,[$start],#1
        MOV     $temp1,$temp1,LSL #24
        MOV     $temp2,#8       ;Reverse the top eight bits of $temp1
10
        MOVS    $temp1,$temp1,LSL #1
        MOV     $temp3,$temp3,RRX
        SUBS    $temp2,$temp2,#1
        BNE     %BT10           ;Loop back until all bits transposed

        MOV     $temp3,$temp3,LSR #24
        STRB    $temp3,[$start,#-1]
        B       %BT00           ;Make byte to be stored (copy top 8 bits down) and loop again
20
        Pull    "$start,$size"
        MEND

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; in:   r0  -> strip
;       r3   = dump width (in bytes)
;       r4   = dump height
;       r5   = row width in bytes ( >= r3 )
;       r7  -> job workspace
;
; Output strip as monochrome data to device.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

output_mono_sprite ROUT
        Push    "R1-R4"
        MUL     R3,R5,R4
        LJTranspose R0,R3,R1,R2,R4
        Pull    "R1-R4"
        B       output_mono_sprite_norev

;all the following entries assume bit-reversal-within-byte not needed

output_mono_spriteV ROUT

        EntryS "R1"
        MOV    R3,R5
        MOV    R1,#"V"
        B      output_mono_altentryV

output_mono_sprite_norev ALTENTRY

        MOV     R3,R5           ;Get the byte width of the image correct
        MOV     R1,#"W"

output_mono_altentryV ROUT
;This version has scan type in R1 and R1,LR on stack

        LDRB    R7,[R7,#pd_private_flags]
        Debug   Dump,"PDumper byte contains",R7
10
        SWI     XOS_ReadEscapeState
        EXIT    CS              ;Return if escape pressed

        Push    "R3"            ;Get the line width
15
        SUBS    R3,R3,#1
        BMI     %20             ;Any more bytes pending?

        LDRB    LR,[R0,R3]
        TEQ     LR,#0           ;Is there a valid byte here?
        BEQ     %15
20
        ADD     R3,R3,#1        ;Account for pre-index

        TST     R7,#pdf_Compression
        BLEQ    sendlj_compressoff
        BLNE    sendlj_compressed

        Pull    "R3"            ;Restore real line length

        ADD     R0,R0,R5
        SUBS    R4,R4,#1
        BNE     %BT10           ;Loop back until all scan lines checked

        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Send a line of data uncompressed to the device.
;
;  in: R0 ->Line data
;      R1 = scan type (V or W)
;      R3 Length of the line to send in bytes
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

sendlj_compressoff ROUT

        EntryS  "R0-R4"

        Debuga  Dump,"Length of line to send",R3
        Debug   Dump," from",R0

        ADRL	R0,line_prologue
        PDumper_PrintCountedString R0,R2,LR
        MOV     R0,R3
        BL      print_number
        PDumper_OutputReg R1    ;Send print line prologue

        ASSERT (Proc_RegOffset = 0) :LOR: (Proc_RegOffset = 4)
        [ Proc_RegOffset = 0
        LDMIA   SP,{R0}         ;Get the length and the width
        |
        LDMIB   SP,{R0}         ;Get the length and the width
        ]
        PDumper_PrintLengthString R0,R3,R1

        EXITS

line_prologue   = 3,27,"*b"
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Send a line in Level 2 compression.
;
;  in: R0 ->Data line
;      R1 = scan type (V or W)
;      R3 Length of the line to send
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

sendlj_compressed
        EntryS  "R0-R8"

        MOV     R8,#0           ;Do not send any data as R1=0
        BL      compresslj      ;And return the size back in R1

        Debuga  Dump,"Scan to get length of line at",R0
        Debug   Dump,", yeilds length of",R1

        ADRL	R2,line_prologuecompressed
        PDumper_PrintCountedString R2,R5,R8
        MOV     R0,R1
        BL      print_number
        LDR     R2,[SP,#Proc_RegOffset + 1*4]      ;Pick the line characteristic off the stack
        PDumper_OutputReg R2    ;Describe the line characteristics to the printer

        ASSERT (Proc_RegOffset = 0) :LOR: (Proc_RegOffset = 4)
        [ Proc_RegOffset = 0
        LDMIA   SP,{R0-R3}
        |
        LDMIB   SP,{R0-R3}
        ]

        MOV     R8,#-1          ;This time output the real data
        BL      compresslj

        EXITS

line_prologuecompressed
        = 5,27,"*b2m"

;..............................................................................
;
; Perform HP graphics compression (level 2) on the scan line specified, returning
; the length of the generated data and spooling data to the specified
; stream if required.
;
; in    R0 ->Line to compress
;       R3 byte length of the line
;       R8 flag to indicate if data should be sent
;
; out   R0 ->Byte after line sent
;       R1 length of data sent to stream
;       R3 preserved



compresslj ROUT

        EntryS  "R3,R6-R7"

        MOV     R1,#0           ;Amount of data spat out so far
        ADD     R3,R0,R3        ;End point of the current line
        MOV     R4,#-1          ;No image data has been sent

        Debuga  Dump,"Compress line from",R0
        Debug   Dump," to",R3

compresslj_loop
        Debug   Dump,"Looping and checking byte from",R0

        TEQ     R0,R3           ;Has the line expired?
        BLEQ    compresslj_flush
        EXITS   EQ

        LDRB    R6,[R0],#1      ;Get a character
        TEQ     R0,R3           ;End of the line, ie. only a single byte remaining?
        BEQ     compresslj_single

        LDRB    R7,[R0]         ;Get the next byte to check for run lengthing
        TEQ     R6,R7           ;Is it a run length starting?
        BEQ     compresslj_scanrun

compresslj_single
        CMP     R4,#-1          ;Is there any image data already?
        SUBEQ   R4,R0,#1        ;Nope so back step and reset the length
        MOVEQ   R5,#0
        ADD     R5,R5,#1        ;Otherwise just update the length and loop again until finished
        B       compresslj_loop

;..............................................................................
;
; As a two byte sequence has been found we attempt to scan forward looking
; for a run length.  Once this has been scanned we then break it up
; into 128 character runs that are then sent to the stream if R8 is
; none zero.
;
; in    R0 ->character following start of section
;       R1 number of bytes already sent in this line
;       R3 ->end of line
;       R6 character obtained
;       R8 flag to indicate if data should be sent
;
; out   R0 updated (must be <= R3)
;       R1 updated
;       R8 preserved

compresslj_scanrun
        SUB     R7,R0,#1        ;Setup to contain the a copy of the start of the run length

        Debug   Dump,"Scanning a run length from",R7

compresslj_looprun
        TEQ     R0,R3           ;Have we reached the end of the line yet?
        BEQ     compresslj_finished

        LDRB    LR,[R0],#1      ;Get a character
        TEQ     LR,R6           ;Is it the same as the previous one?
        BEQ     compresslj_looprun

        SUB     R0,R0,#1        ;Backstep as this character is different

compresslj_finished
        Push    "R2,R7"         ;Store away the important registers
        BL      compresslj_flush
        Pull    "R2,R7"         ;Flush the image data preceeding the run and then restore registers

        SUBS    R7,R0,R7        ;Get the length of the run area
        BEQ     compresslj_loop ;If it is zero (by accident) then skip back

compresslj_flushrunlength
        Debug   Dump,"Flushing run length",R7

        Push    "R7"

        CMP     R7,#128         ;Can I send this section of data without clipping it?
        MOVGT   R7,#128         ;Truncate if too big man
        SUB     R7,R7,#1        ;Get the length -1
        RSB     R7,R7,#0        ;and then make -ve as run length info stored as -ve value

        ADD     R1,R1,#2        ;We will output two bytes so increase the bytes sent register

        TEQ     R8,#0           ;Do I need to write anything to the stream?
        BEQ     compresslj_flushrunskip

        PDumper_OutputReg R7    ;Send the length and then the byte to be replicated
        PDumper_OutputReg R6

compresslj_flushrunskip
        Pull    "R7"            ;Restore the length remaining
        SUBS    R7,R7,#128      ;Decrease the counter
        BGT     compresslj_flushrunlength
        B       compresslj_loop ;Try some more data and stream that to the file


;..............................................................................
;
; Flush data to the stream, this routine is a general one called to flush
; any image data to the stream that is pointed to by R4 (and if R8 is non-zero).
;
; in    R1 number of bytes sent so far
;       R4 ->start of image data to be sent / =-1 for no image data
;       R5 length of image section to send / if R4 =-1 then ignored
;       R8 flag to indicate if data should be sent (<>0 then send)
;
; out   R1 updated
;       R4 -1 to indicate no image data remaining
;       R5 corrupt
;       R8 preserved

compresslj_flush
        EntryS  "r2"
        CMP     R4,#-1          ;Is there any image data worth sending?
        EXITS   EQ              ;Nope so return now


compresslj_flushloop
        Debug   Dump,"Flushing image data length",R5

        Push    "R5"            ;Store the length of the run section

        CMP     R5,#128         ;Do I need to truncate it (ie. is it more than 128 characters)
        MOVGT   R5,#128         ;Yup so truncate
        ADD     R1,R1,#1
        ADD     R1,R1,R5        ;Sending the length byte followed by the actual data for the section

        TEQ     R8,#0           ;Do we need to send any data to the stream?
        BEQ     compresslj_flushskip

        SUB     R2,R5,#1        ;Decrease the length so stored as length -1
        PDumper_OutputReg R2
        PDumper_PrintLengthString R4,R5,R2

compresslj_flushskip
        Pull    "R5"            ;Data has been spat out and R5 will have been corrupted so restore
        SUBS    R5,R5,#128
        BGT     compresslj_flushloop

        MOV     R4,#-1          ;Mark as their being no image data queued up
        EXITS


;send pending blank lines as vertical move - should never be called if
;pdf_SupportsYOffset flag bit is not set
send_vertical_move
   Push    "R0-R2,LR"
   ADRL    R0,relvert_move
   PDumper_PrintCountedString R0,R2,LR
   LDR     R0,pending_blank_lines
   BL      print_number
   MOV     R1,#'Y'
   PDumper_OutputReg R1
   MOV     R0,#0
   STR     R0,pending_blank_lines
   Pull    "R0-R2,PC"
relvert_move = 3,27,"*b"    ;raster Y offset command = ESC * b <rasters> Y
   ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; in:   r0  -> strip
;       r3   = dump width
;       r4   = dump height
;       r5   = row width in bytes ( >= r3 )
;       r7  -> job workspace
;
; Ouput the 8BPP strip in colour. Bytes are KCMY, and have to be rearranged
; in situ, in order to do compression sensibly. The rearrangement is only
; possible, if like output_grey_sprite, the area of memory written lags
; behind the area read from. There is a lower bound for this, but PDriverDP
; ensures a width of at least 8, so we are OK (any sensible width much bigger
; than 8 of course)
; Start is  %0000KCMY %0000KCMY %0000KCMY ....
; Finish is %BBBBBBBB %BBBBBBBB... %GGGGGGGG %GGGGGGGG... %RRRRRRRR ....   (3 planes separated)
;        or %YYYYYYYY %YYYYYYYY... %MMMMMMMM... %CCCCCCCC.... %KKKKKKKK... (4 planes separated)
; First occupies N bytes
; Latter occupies (N/8+1)*3 or (N/8+1)*4 at most
; First phase packs info into upper N/2+1 bytes at most

; !!! assumes width (pixels) is multiple of 8 (should be ensured by
;     PDriverDP)

output_colour_sprite ROUT

  Debug DumpMJS,"output_colour_sprite w,h,align ",R3,R4,R5

        EntryS  "R0-R2,R4,R6-R8"
        TEQ     R3,#0           ;Ignore zero widths!
        EXITS   EQ


colourlj_lineloop

        Push    "R0,R3-R5,R7"         ;will need this again

        Push    "R0,R3,R7,R9"   ;Need to keep position of strip for output
        Push    "R0,R3"         ;and for CMYK scanning

        ADD     R0,R0,R3        ;->Scan line end to shuffle up
        MOV     R1,R0           ;second pointer for save

        MOV     R9, #1          ;R9 will be set false if we notice whole row is not white

;first phase - pack nibbles into bytes
   LDRB  R4,[R7,#pd_private_flags]
   TST   R4,#pdf_FourPlanes
   BNE   %FT10

;three planes case - replace K with CMY
5  SUB   R0,R0,#8
   LDMIA R0,{R4,R7}             ;load next 8 pixels
   ORRS  R4,R4,R7,LSL #4        ;munge together (8 KCMY nibbles)
   MOVNE R9,#0                  ;reset whole-row white flag if necessary
;replace any K's with CMY's
   TST   R4,#&80000000
   ORRNE R4,R4,#&70000000
   TST   R4,#&08000000
   ORRNE R4,R4,#&07000000
   TST   R4,#&00800000
   ORRNE R4,R4,#&00700000
   TST   R4,#&00080000
   ORRNE R4,R4,#&00070000
   TST   R4,#&00008000
   ORRNE R4,R4,#&00007000
   TST   R4,#&00000800
   ORRNE R4,R4,#&00000700
   TST   R4,#&00000080
   ORRNE R4,R4,#&00000070
   TST   R4,#&00000008
   ORRNE R4,R4,#&00000007
   BIC   R4,R4,#&88000000
   BIC   R4,R4,#&00880000
   BIC   R4,R4,#&00008800
   BIC   R4,R4,#&00000088
   MVN   R4,R4                  ;CMY -> RGB, to suit 3-plane case
   STR   R4,[R1,#-4]!           ;store for next pass
   SUBS  R3,R3,#8
   BNE   %BT5
   B     %FT12

;four planes case - K allowed
10 SUB   R0,R0,#8
   LDMIA R0,{R4,R7}             ;load next 8 pixels
   ORRS  R4,R4,R7,LSL #4        ;munge together (8 KCMY nibbles)
   MOVNE R9,#0                  ;reset whole-row white flag if necessary
   STR   R4,[R1,#-4]!           ;store for next pass
   SUBS  R3,R3,#8
   BNE   %BT10

12
   Pull  "R0,R3"                ;restore line start, count
   CMP   R9, #1                 ;was whole row white?
   BNE   %FT15
;yes
   LDR   R9,pending_blank_lines
   CMP   R9,#&80000000          ;is Y Offset unsupported?
   BEQ   %FT15
;let's skip a whole load of work
   ADD   R9,R9,#1
   STR   R9,pending_blank_lines
;max value of +32767 allowed in vertical move command
   CMP   R9,#&7F00              ;close enough
   BLGE  send_vertical_move
   Pull  "R0,R3,R7,R9"
   B     colourlj_nextline

;now separate out the bits in each plane
15
   LDR   R4,pending_blank_lines
   CMP   R4,#0
   BLGT  send_vertical_move     ;less than 0 (&80000000) if Y Offset not supported

   MOV   R4,#1                  ;current ribbon, starts at Y
   ORR   R9,R4,R4,LSL #4
   ORR   R9,R9,R9,LSL #8
   ORR   R9,R9,R9,LSL #16       ;ribbon bits, all 8 nibbles, start at Y (&11111111)
20
   MOV   R7,#0                  ;byte so far
   Push  "R1,R3"                ;Read from here for each pass
   B     %FT30

25
   STRB  R7,[R0],#1
   SUBS  R3,R3,#8
   BLE   %FT35
30
   LDR   R8,[R1],#4             ;get 8 KCMY nibbles
   TST   R8,R9                  ;check for none of 8 nibbles set against ribbon
   BEQ   %BT25                  ;skip nibble-wise checks if none
   TST   R8,R4                  ;check for nibble 0 set against ribbon
   ORRNE R7,R7,#1:SHL:7         ;set bit 7 if match (bits required reversed in byte)
   TST   R8,R4,LSL #8           ;repeat for other 7 nibbles
   ORRNE R7,R7,#1:SHL:6
   TST   R8,R4,LSL #16
   ORRNE R7,R7,#1:SHL:5
   TST   R8,R4,LSL #24
   ORRNE R7,R7,#1:SHL:4
   TST   R8,R4,LSL #4
   ORRNE R7,R7,#1:SHL:3
   TST   R8,R4,LSL #12
   ORRNE R7,R7,#1:SHL:2
   TST   R8,R4,LSL #20
   ORRNE R7,R7,#1:SHL:1
   TST   R8,R4,LSL #28
   ORRNE R7,R7,#1:SHL:0
   STRB  R7,[R0],#1             ;a byte of ribbon colour now ready to store
   MOV   R7, #0                 ;clear ribbon colour bits again
   SUBS  R3,R3,#8
   BGT   %BT30
35
   Pull  "R1,R3"                ;Get the input data back
   MOV   R4,R4,LSL #1           ;Next ribbon (1 bit mask)
   MOV   R9,R9,LSL #1           ;Next ribbon (8 bit mask)
   ANDS  R4,R4,#15              ;Check if bit is in range
   BNE   %BT20

        Pull    "R0,R3,R7,R9"

colourlj_rearranged
        Push    "R4"
        LDRB    R4,[R7,#pd_private_flags]
        TST     R4,#pdf_FourPlanes
        BLNE    colourlj_colourstrip4
        TST     R4,#pdf_FourPlanes
        BLEQ    colourlj_colourstrip3
        Pull    "R4"

colourlj_nextline

        Pull    "R0,R3-R5,R7"
        ADD     R0,R0,R5          ;Adjust the line pointer
        SUBS    R4,R4,#1
        BGT     colourlj_lineloop ;Loop back until all bits tested

colourlj_exit
 Debug DumpMJS,"output_colour_sprite done"
        EXITS

;for four planes case
;So now can do four output_mono_strip's from R0 width R3 job R7
colourlj_colourstrip4
        Push    "R4,LR"

        ADD     R5,R3,#7
        MOV     R5,R5,LSR#3
        MOV     R4,#1

        ADD     R0,R0,R5
        ADD     R0,R0,R5,LSL#1                 ;Starts with K!!

        Push    "R0,R3,R4,R5,R7"               ;Keep this lot for each pass
        BL      output_mono_spriteV
        Pull    "R0,R3,R4,R5,R7"
        SUB     R0,R0,R5                       ;Back down to previous colour
        Push    "R0,R3,R4,R5,R7"
        BL      output_mono_spriteV
        Pull    "R0,R3,R4,R5,R7"
        SUB     R0,R0,R5
        Push    "R0,R3,R4,R5,R7"
        BL      output_mono_spriteV
        Pull    "R0,R3,R4,R5,R7"
        SUB     R0,R0,R5
        BL      output_mono_sprite_norev      ;W to terminate

        Pull    "R4,PC"


;for three planes case
;So now can do three output_mono_strip's from R0 width R3 job R7
colourlj_colourstrip3
        Push    "R4,LR"

        ADD     R5,R3,#7
        MOV     R5,R5,LSR#3
        MOV     R4,#1

        ADD     R0,R0,R5,LSL#1                 ;Starts with R!!

        Push    "R0,R3,R4,R5,R7"               ;Keep this lot for each pass
        BL      output_mono_spriteV
        Pull    "R0,R3,R4,R5,R7"
        SUB     R0,R0,R5
        Push    "R0,R3,R4,R5,R7"
        BL      output_mono_spriteV
        Pull    "R0,R3,R4,R5,R7"
        SUB     R0,R0,R5
        BL      output_mono_sprite_norev       ;W to terminate

        Pull    "R4,PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; in:   r0  -> strip
;       r3   = dump width
;       r4   = dump height
;       r5   = row width in bytes ( >= r3 )
;       r7  -> job workspace
;
; Output and 8BPP strip for the current device, this is done by converting
; the data from the 8BPP data to the 1BPP data suitable for printing via
; the monochrome output routines, we need not attempt to perform bit
; reversal.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


output_grey_sprite ROUT

        EntryS  "r1"
        Push    "R0,R2,R4,R6-R8"


        Debug   Dump,"Converting to monochrome"
        Debuga  Dump,"At",R0
        Debuga  Dump,", Width",R3
        Debuga  Dump,", Height",R4
        Debuga  Dump,", Byte width",R5
        Debug   Dump,", Workspace at",R7

        MOV     R1,R0           ;->Scan line to convert
        MOV     R2,#1:SHL:7     ;Bit to modify in source data
10
        Push    "R1,R3-R5"      ;Store the byte width of the line

;we know width is a multiple of 8, so gulp 8 pixels at a time
15
        SUBS    R3,R3,#8
        BLT     %FT20
        LDMIA   R1!,{R6,R7}     ;next 8 pixels
        ORRS    R4,R6,R7        ;all white?
        STREQB  R4,[R0],#1
        BEQ     %BT15           ;fast route if so
        MOV     R4,#0
        TST     R6,#1:SHL:3     ;K bit of 1st pixel
        ORRNE   R4,R4,#1:SHL:7
        TST     R6,#1:SHL:11    ;K bit of 2nd pixel
        ORRNE   R4,R4,#1:SHL:6
        TST     R6,#1:SHL:19
        ORRNE   R4,R4,#1:SHL:5
        TST     R6,#1:SHL:27
        ORRNE   R4,R4,#1:SHL:4
        TST     R7,#1:SHL:3
        ORRNE   R4,R4,#1:SHL:3
        TST     R7,#1:SHL:11
        ORRNE   R4,R4,#1:SHL:2
        TST     R7,#1:SHL:19
        ORRNE   R4,R4,#1:SHL:1
        TST     R7,#1:SHL:27
        ORRNE   R4,R4,#1:SHL:0
        STRB    R4,[R0],#1
        B       %BT15

20
        ADD     R0,R0,#3
        BIC     R0,R0,#3        ;Align to a word boundary (nb - pad bytes contain junk!)

        Pull    "R1,R3-R5"
        ADD     R1,R1,R5        ;Adjust the line pointer
        SUBS    R4,R4,#1
        BGT     %BT10           ;Loop back until all bits tested

        ADD     R3,R3,#7
        MOV     R3,R3,LSR #3    ;Ensure a nice byte width of the scan
        ADD     R5,R3,#3
        BIC     R5,R5,#3        ;Word align the width of the strip

        Pull    "R0,R2,R4,R6-R8"

;below is similar to output_mono_altentry routine, but deals with blank lines
; (other routine used for colour - cannot deal with blank lines itself, because a
; 'line' is just one plane)

        MOV     R1,#"W"
        LDRB    R7,[R7,#pd_private_flags]
30
        SWI     XOS_ReadEscapeState
        EXIT    CS              ;Return if escape pressed

        Push    "R3"            ;Get the line width
35
        SUBS    R3,R3,#1
        BMI     %40             ;Any more bytes pending?

        LDRB    LR,[R0,R3]
        TEQ     LR,#0           ;Is there a valid byte here?
        BEQ     %35
40
        ADDS    R3,R3,#1        ;Account for pre-index
        BNE     %FT42

        LDR     LR,pending_blank_lines
        CMP     LR,#&80000000   ;check whether Y Offset supported
        BEQ     %FT42

        ADD     LR,LR,#1
        STR     LR,pending_blank_lines
;max value of +32767 allowed in vertical move command
        CMP     LR,#&7F00          ;close enough
        BLGE    send_vertical_move
        B       %FT44

42
        LDR     LR,pending_blank_lines
        CMP     LR,#0
        BLGT    send_vertical_move ;less than if Y Offset not supported

        TST     R7,#pdf_Compression
        BLEQ    sendlj_compressoff
        BLNE    sendlj_compressed

44
        Pull    "R3"            ;Restore real line length

        ADD     R0,R0,R5
        SUBS    R4,R4,#1
        BNE     %BT30           ;Loop back until all scan lines checked

        EXITS


        END
@


4.7
log
@Renamed generic driver sources
Makefiles rewritten
Converted to use objasm
First pass at 32 bit compatibility.

Version 1.34. Tagged as 'PDumpers-1_34'
@
text
@d17 1
a17 1
        GET     ^.Generic.GOutputDump.s
@


4.6
log
@  32-bit fixes.
Detail:
  Some routines using EXITS needed R14 as a result register.
    These routines now work in 32-bit modes.
  Fixed ADR lr, unthread to be JumpAddress lr, unthread so that
    26-bit builds work when the routine jumped to uses EntryS.
Admin:
  Built 26-bit and 32-bit versions - untested,

Version 1.24. Tagged as 'PDumpers-1_24'
@
text
@d17 1
a17 1
        GET     ^.Generic.s.OutputDump
@


4.5
log
@  32-bit fixes - some stack offsets were wrong.
Admin:
  Built 26-bit and 32-bit builds.
  Not tested.

Version 1.22. Tagged as 'PDumpers-1_22'
@
text
@d175 1
a175 1
        LDR     R2,[SP,#4]      ;Pick the line characteristic off the stack
@


4.4
log
@32-bit compatible.

Version 1.21. Tagged as 'PDumpers-1_21'
@
text
@d139 2
d142 3
d178 2
d181 3
@


4.3
log
@Spinner branch merged
@
text
@d33 1
a33 1
        BLT     %FT20           ;Yes so exit the main loop 
d50 1
a50 1
        
d74 1
a74 1
        Push   "R1,LR"
d79 2
a80 3
output_mono_sprite_norev ROUT
              
        Push    "LR"
a81 4
                  
output_mono_altentry ROUT

        Push    "R1"
d91 2
a92 2
        Pull    "R1,PC",CS         ;Return if escape pressed
                  
d112 1
a112 1
        BNE     %BT10           ;Loop back until all scan lines checked       
d114 1
a114 1
        Pull    "R1,PC",,^
d125 1
a125 1
                                                 
d128 2
a129 2
        Push    "R0-R4,LR"
             
d138 1
a138 1
                 
d142 1
a142 1
        Pull    "R0-R4,PC",,^
d155 1
a155 1
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++                                
d158 2
a159 2
        Push    "R0-R8,LR"
         
d165 1
a165 1
        
a176 2
         
        Pull    "R0-R8,PC",,^
d178 3
a180 1
line_prologuecompressed 
d184 1
a184 1
; 
d201 1
a201 1
        Push    "R3,R6-R7,LR"
d215 1
a215 1
        Pull    "R3,R6-R7,PC",EQ,^ 
d224 1
a224 1
          
d248 1
a248 1
        
d283 1
a283 1
     
d298 1
a298 1
; 
d305 2
a306 2
;       R8 flag to indicate if data should be sent (<>0 then send)       
;                                           
d313 1
d315 2
a316 3
        MOVEQS  PC,LR           ;Nope so return now 
                                                    
        Push    "R2,LR"
d325 1
a325 1
        ADD     R1,R1,#1  
d330 1
a330 1
        
d341 1
a341 1
        Pull    "R2,PC",,^
d388 1
d390 1
a390 1
        MOVEQS  PC,LR
a391 1
        Push    "R0-R2,R4,R6-R8,LR"
d401 1
a401 1
        MOV     R1,R0           ;second pointer for save   
d477 1
a477 1
   ORR   R9,R9,R9,LSL #16       ;ribbon bits, all 8 nibbles, start at Y (&11111111)    
d531 1
a531 1
        Pull    "R0,R3-R5,R7"      
d538 1
a538 1
        Pull    "R0-R2,R4,R6-R8,PC",,^
d611 2
a612 1
        Push    "R0-R2,R4,R6-R8,LR"
d621 1
a621 1
       
d659 1
a659 1
        Pull    "R1,R3-R5"      
d663 1
a663 1
         
d669 1
a669 1
        Pull    "R0-R2,R4,R6-R8"
a674 1
        Push    "R1"
d679 2
a680 2
        Pull    "R1,PC",CS      ;Return if escape pressed
                  
d718 1
a718 1
        BNE     %BT30           ;Loop back until all scan lines checked       
d720 1
a720 1
        Pull    "R1,PC",,^
@


4.2
log
@Version Spin_merge taken
@
text
@d138 1
a138 1
        ADR     R0,line_prologue
d171 1
a171 1
        ADR     R2,line_prologuecompressed
d353 1
a353 1
   ADR     R0,relvert_move
@


4.1
log
@Initial revision
@
text
@d19 1
a19 1
debugDump SETL true
d63 9
d79 1
a79 1
output_mono_sprite ROUT
a144 1
        LJTranspose R0,R3,R1,R2,R4
a178 1
        LJTranspose R0,R3, R1,R2,R4
d349 16
d376 6
a381 4
; behind the area read from. There is unfortunately a lower bound for this
; which has to be treated as a special case....
; Start is %0000KCMY %0000KCMY %0000KCMY ....
; Finish is %RRRRRRRR %RRRRRRRR... %GGGGGGGGG %GGGGGGGG... %BBBBBBBB ....
d383 1
a383 1
; Latter occupies (N/8+1)*3 at most
d386 3
d391 2
d398 1
a398 35
        [ FourPlanes

        LDRB    LR,[R7,#pd_private_flags]
        TST     LR,#pdf_FourPlanes
        BEQ     colourlj_lineloop           ;Usual stuff...
        ;BNE     colourlj_lineloop           ;Usual stuff...
;This is an approximate copy of the Escape-P2 driver!
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; in:   r0  -> strip
;       r3   = dump width
;       r4   = dump height
;       r5   = row width in bytes ( >= r3 )
;       r7  -> job workspace
;
; Ouput the 8BPP strip in colour. Bytes are KCMY, and have to be rearranged
; in situ, in order to do compression sensibly. The rearrangement is only
; possible, if like output_grey_sprite, the area of memory written lags
; behind the area read from. There is unfortunately a lower bound for this
; which has to be treated as a special case....
; Start is %0000KCMY %0000KCMY %0000KCMY ....
; Finish is %YYYYYYYY %YYYYYYYY... %MMMMMMMM... %CCCCCCCC.... %KKKKKKKK...
; First occupies N bytes
; Latter occupies (N/8+1)*4 at most
; First phase packs info into upper N/2+1 bytes at most
        Debug   , "in FourPlanes stuff"

        Debug   Dump,"Converting colour to monochrome"
        Debuga  Dump,"At",R0
        Debuga  Dump,", Width",R3
        Debuga  Dump,", Height",R4
        Debuga  Dump,", Byte width",R5
        Debug   Dump,", Workspace at",R7

colourE2_lineloop
d402 1
a402 30
        CMP     R3,#5           ;fewer than 5 bytes to store in?
        BGT     longE2_colour   ;enough for a general algorithm
        BLT     vshortE2_colour ;bit of an unlikely picture format
        BL      shortE2_colour
        B       colourE2_rearranged

vshortE2_colour
;Oh well, I'll have to use the stack!
        SUB     SP,SP,#8
        MOV     R1,#0
        STR     R1,[SP]
        LDRB    R1,[R0,#0]      ;At least one byte (see above)
        STRB    R1,[SP,#0]
        CMP     R3,#2
        LDRGEB  R1,[R0,#1]
        STRGEB  R1,[SP,#1]
        CMP     R3,#3
        LDRGEB  R1,[R0,#2]
        STRGEB  R1,[SP,#2]
        CMP     R3,#4
        LDRGEB  R1,[R0,#3]
        STRGEB  R1,[SP,#3]
        MOV     R0,SP
        BL      shortE2_colour
        BL      colourE2_colourstrip
        ADD     SP,SP,#8        ;Balance the stack
        B       colourE2_nextline

longE2_colour
        Push    "R0,R3,R7"      ;Need to keep position of strip for output
d406 1
a406 1
        MOV     R1,R0           ;second pointer for save
d408 1
a408 4
        TST     R3,#1           ;Is the line length odd?
        SUBNE   R0,R0,#1        ;if so the last byte stays the same
        SUBNE   R1,R1,#1
        SUBNE   R3,R3,#1        ;Length is now definitely even
d410 62
a471 2
10      LDRB    R4,[R0,#-1]!    ;Load colours
        LDRB    R7,[R0,#-1]!
d473 10
a482 8
        ORR     R4,R7,R4,LSL#4  ;Munge together as a single byte
        STRB    R4,[R1,#-1]!    ;and keep for next pass

        SUBS    R3,R3,#2        ;Finished the even bit yet?
        BNE     %BT10

        Pull    "R0,R3"         ;Restore the line start, count
        MOV     R4,#1:SHL:0     ;Current ribbon (start at Y!)
d484 8
a491 4
        MOV     R2,#1:SHL:0     ;Bit to modify output
        MOV     R6,#0           ;Current bit to set
        MOV     R7,#0           ;Byte so far
        Push    "R1,R3"         ;Read from here for each pass
d493 29
a521 19
        LDRB    R8,[R1],#1      ;Get two CMYK clusters
        TST     R8,R4           ;Check the "ribbon"
        ORRNE   R7,R7,R2,LSL R6 ;and set a bit if required
        ADD     R6,R6,#1
        TST     R8,R4,LSL#4
        ORRNE   R7,R7,R2,LSL R6
        ADD     R6,R6,#1
        ANDS    R6,R6,#7
        STREQB  R7,[R0],#1      ;Write a destination byte if finished a complete one
        MOVEQ   R7,#0
        SUBS    R3,R3,#2        ;May go to 0 or -1
        BGT     %BT30

        ANDS    R6,R6,#7
        STRNEB  R7,[R0],#1      ;Store the byte if bit index >0
        Pull    "R1,R3"         ;Get the input data back
        MOV     R4,R4,LSL#1     ;Next ribbon
        ANDS    R4,R4,#15       ;Check if bit is in range
        BNE     %BT20
d523 1
a523 1
        Pull    "R0,R3,R7"
d525 8
a532 2
colourE2_rearranged
        BL      colourE2_colourstrip
d534 1
a534 1
colourE2_nextline
d537 1
a537 1
        ADD     R0,R0,R5        ;Adjust the line pointer
d539 1
a539 1
        BGT     colourE2_lineloop ;Loop back until all bits tested
d541 2
a542 1
colourE2_exit
d545 1
a545 1
colourE2_colourstrip
d547 2
a548 1
        Push    "LR"
d553 1
a558 1

a561 1

a562 1

a565 1

a566 1

d569 1
d571 1
a571 103
        BL      output_mono_sprite          ;W to terminate

        Pull    "PC"

shortE2_colour
;Exactly 4 bytes to store in!
        Push    "R5,R6,R7,LR"
        LDRB    R1,[R0,#0]
        LDRB    R2,[R0,#1]
        LDRB    R4,[R0,#2]
        LDRB    R5,[R0,#3]
        LDRB    R6,[R0,#4]
;Yellow 
        MOV     R7,#0
        TST     R1,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:2
        TST     R5,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:3
        TST     R6,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:4
        STRB    R7,[R0,#0]
;Magenta
        MOV     R7,#0
        TST     R1,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:2
        TST     R5,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:3
        TST     R6,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:4
        STRB    R7,[R0,#1]
;Cyan
        MOV     R7,#0
        TST     R1,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:2
        TST     R5,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:3
        TST     R6,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:4
        STRB    R7,[R0,#2]
;Key
        MOV     R7,#0
        TST     R1,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:2
        TST     R5,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:3
        TST     R6,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:4
        STRB    R7,[R0,#3]

        Pull    "R5,R6,R7,PC"

        ]

;----------------USUAL STUFF FOR 3-BIT PLANES---------------------

        Debug   Dump,"Converting colour to monochrome"
        Debuga  Dump,"At",R0
        Debuga  Dump,", Width",R3
        Debuga  Dump,", Height",R4
        Debuga  Dump,", Byte width",R5
        Debug   Dump,", Workspace at",R7

colourlj_lineloop

        Push    "R0,R3-R5,R7"         ;will need this again

        CMP     R3,#3           ;fewer than 3 bytes to store in?
        BGT     longlj_colour   ;enough for a general algorithm
        BLT     vshortlj_colour ;bit of an unlikely picture format
        BL      shortlj_colour
        B       colourlj_rearranged

vshortlj_colour
;Oh well, I'll have to use the stack!
        SUB     SP,SP,#4
        MOV     R1,#0
        STR     R1,[SP]
        LDRB    R1,[R0,#0]      ;At least one byte (see above)
        STRB    R1,[SP,#0]
        CMP     R3,#2
        LDRGEB  R1,[R0,#1]
        STRGEB  R1,[SP,#1]
        MOV     R0,SP
        BL      shortlj_colour
        BL      colourlj_colourstrip
        ADD     SP,SP,#4        ;Balance the stack
        B       colourlj_nextline
a572 59
longlj_colour
        Push    "R0,R3,R7"      ;Need to keep position of strip for output
        Push    "R0,R3"         ;and for CMYK scanning

        ADD     R0,R0,R3        ;->Scan line end to shuffle up
        MOV     R1,R0           ;second pointer for save

        TST     R3,#1           ;Is the line length odd?
        SUBNE   R0,R0,#1        ;if so the last byte stays the same
        SUBNE   R1,R1,#1
        SUBNE   R3,R3,#1        ;Length is now definitely even

10      LDRB    R4,[R0,#-1]!    ;Load colours
        TST     R4,#8
        MOVNE   R4,#7           ;and put back CMY for K!

        LDRB    R7,[R0,#-1]!
        TST     R7,#8
        MOVNE   R7,#7           ;second four-bit set

        ORR     R4,R7,R4,LSL#4  ;Munge together as a single byte
        STRB    R4,[R1,#-1]!    ;and keep for next pass

        SUBS    R3,R3,#2        ;Finished the even bit yet?
        BNE     %BT10

        Pull    "R0,R3"         ;Restore the line start, count
        MOV     R4,#1:SHL:2     ;Current ribbon
20
        MOV     R2,#1:SHL:0     ;Bit to modify output
        MOV     R6,#0           ;Current bit to set
        MOV     R7,#255         ;Byte so far
        Push    "R1,R3"         ;Read from here for each pass
30
        LDRB    R8,[R1],#1      ;Get two CMY clusters
        TST     R8,R4           ;Check the "ribbon"
        BICNE   R7,R7,R2,LSL R6 ;and clear a bit if required
        ADD     R6,R6,#1
        TST     R8,R4,LSL#4
        BICNE   R7,R7,R2,LSL R6
        ADD     R6,R6,#1
        ANDS    R6,R6,#7
        STREQB  R7,[R0],#1      ;Write a destination byte if finished a complete one
        MOVEQ   R7,#255
        SUBS    R3,R3,#2        ;May go to 0 or -1
        BGT     %BT30

        ANDS    R6,R6,#7
        STRNEB  R7,[R0],#1      ;Store the byte if bit index >0
        Pull    "R1,R3"         ;Get the input data back
        MOVS    R4,R4,LSR#1     ;Next ribbon
        BNE     %BT20

        Pull    "R0,R3,R7"

colourlj_rearranged
        BL      colourlj_colourstrip

colourlj_nextline
d574 1
a574 9
        Pull    "R0,R3-R5,R7"      
        ADD     R0,R0,R5        ;Adjust the line pointer
        SUBS    R4,R4,#1
        BGT     colourlj_lineloop ;Loop back until all bits tested

colourlj_exit
        Pull    "R0-R2,R4,R6-R8,PC",,^

colourlj_colourstrip
d576 2
a577 1
        Push    "LR"
d583 2
a586 1

d588 1
a588 1
        ADD     R0,R0,R5
a589 1

a590 1

d592 2
a593 3
        ADD     R0,R0,R5

        BL      output_mono_sprite          ;W to terminate
d595 1
a595 1
        Pull    "PC"
a596 34
shortlj_colour
;Exactly 3 bytes to store in!
        Push    "R7,LR"
        LDRB    R1,[R0,#0]
        LDRB    R2,[R0,#1]
        LDRB    R4,[R0,#2]
;Red (=>Opposite of Cyan)
        MOV     R7,#255
        TST     R1,#(1:SHL:2):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:2):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:2):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:2
        STRB    R7,[R0,#0]
;Green
        MOV     R7,#255
        TST     R1,#(1:SHL:1):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:1):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:1):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:2
        STRB    R7,[R0,#1]
;Blue
        MOV     R7,#255
        TST     R1,#(1:SHL:0):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:0):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:0):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:2
        STRB    R7,[R0,#2]
        Pull    "R7,PC"
d627 1
a627 1
        MOV     R2,#1:SHL:0     ;Bit to modify in source data
d630 2
a631 3
        
        MOV     R4,#0           ;Reset the pixel to write
        MOV     R6,#0
d633 24
a656 11
        SUBS    R3,R3,#1        ;Decrease the pixel count along the scan line
        BLT     %FT20           ;If <min width then exit
        
        LDRB    R7,[R1],#1      ;Get a byte from the source and check to see if bit is set
        TST     R7,#1:SHL:0     ;use the bottom bit, not the K bit!!
        ORRNE   R4,R4,R2,LSL R6

        ADD     R6,R6,#1
        ANDS    R6,R6,#7
        STREQB  R4,[R0],#1      ;Write a destination byte if finished a complete one
        MOVEQ   R4,#0           ;...and then reset the byte to write
d658 1
a659 3
        ANDS    R6,R6,#7
        STRNEB  R4,[R0],#1      ;Store the byte if bit index >0

d674 52
a725 1
        B       output_mono_altentry
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d19 1
a19 1
; debugDump SETL true
a62 9
output_mono_sprite ROUT
        Push    "R1-R4"
        MUL     R3,R5,R4
        LJTranspose R0,R3,R1,R2,R4
        Pull    "R1-R4"
        B       output_mono_sprite_norev

;all the following entries assume bit-reversal-within-byte not needed

d70 1
a70 1
output_mono_sprite_norev ROUT
d136 1
d171 1
a341 16
;send pending blank lines as vertical move - should never be called if
;pdf_SupportsYOffset flag bit is not set
send_vertical_move
   Push    "R0-R2,LR"
   ADR     R0,relvert_move
   PDumper_PrintCountedString R0,R2,LR
   LDR     R0,pending_blank_lines
   BL      print_number
   MOV     R1,#'Y'
   PDumper_OutputReg R1
   MOV     R0,#0
   STR     R0,pending_blank_lines
   Pull    "R0-R2,PC"
relvert_move = 3,27,"*b"    ;raster Y offset command = ESC * b <rasters> Y
   ALIGN

d353 4
a356 6
; behind the area read from. There is a lower bound for this, but PDriverDP
; ensures a width of at least 8, so we are OK (any sensible width much bigger
; than 8 of course)
; Start is  %0000KCMY %0000KCMY %0000KCMY ....
; Finish is %BBBBBBBB %BBBBBBBB... %GGGGGGGG %GGGGGGGG... %RRRRRRRR ....   (3 planes separated)
;        or %YYYYYYYY %YYYYYYYY... %MMMMMMMM... %CCCCCCCC.... %KKKKKKKK... (4 planes separated)
d358 1
a358 1
; Latter occupies (N/8+1)*3 or (N/8+1)*4 at most
a360 3
; !!! assumes width (pixels) is multiple of 8 (should be ensured by
;     PDriverDP)

a362 2
  Debug DumpMJS,"output_colour_sprite w,h,align ",R3,R4,R5

d368 35
a402 1
colourlj_lineloop
d406 30
a435 1
        Push    "R0,R3,R7,R9"   ;Need to keep position of strip for output
d439 6
a444 1
        MOV     R1,R0           ;second pointer for save   
d446 2
a447 1
        MOV     R9, #1          ;R9 will be set false if we notice whole row is not white
d449 2
a450 62
;first phase - pack nibbles into bytes
   LDRB  R4,[R7,#pd_private_flags]
   TST   R4,#pdf_FourPlanes
   BNE   %FT10

;three planes case - replace K with CMY
5  SUB   R0,R0,#8
   LDMIA R0,{R4,R7}             ;load next 8 pixels
   ORRS  R4,R4,R7,LSL #4        ;munge together (8 KCMY nibbles)
   MOVNE R9,#0                  ;reset whole-row white flag if necessary
;replace any K's with CMY's
   TST   R4,#&80000000
   ORRNE R4,R4,#&70000000
   TST   R4,#&08000000
   ORRNE R4,R4,#&07000000
   TST   R4,#&00800000
   ORRNE R4,R4,#&00700000
   TST   R4,#&00080000
   ORRNE R4,R4,#&00070000
   TST   R4,#&00008000
   ORRNE R4,R4,#&00007000
   TST   R4,#&00000800
   ORRNE R4,R4,#&00000700
   TST   R4,#&00000080
   ORRNE R4,R4,#&00000070
   TST   R4,#&00000008
   ORRNE R4,R4,#&00000007
   BIC   R4,R4,#&88000000
   BIC   R4,R4,#&00880000
   BIC   R4,R4,#&00008800
   BIC   R4,R4,#&00000088
   MVN   R4,R4                  ;CMY -> RGB, to suit 3-plane case
   STR   R4,[R1,#-4]!           ;store for next pass
   SUBS  R3,R3,#8
   BNE   %BT5
   B     %FT12

;four planes case - K allowed
10 SUB   R0,R0,#8
   LDMIA R0,{R4,R7}             ;load next 8 pixels
   ORRS  R4,R4,R7,LSL #4        ;munge together (8 KCMY nibbles)
   MOVNE R9,#0                  ;reset whole-row white flag if necessary
   STR   R4,[R1,#-4]!           ;store for next pass
   SUBS  R3,R3,#8
   BNE   %BT10

12
   Pull  "R0,R3"                ;restore line start, count
   CMP   R9, #1                 ;was whole row white?
   BNE   %FT15
;yes
   LDR   R9,pending_blank_lines
   CMP   R9,#&80000000          ;is Y Offset unsupported?
   BEQ   %FT15
;let's skip a whole load of work
   ADD   R9,R9,#1
   STR   R9,pending_blank_lines
;max value of +32767 allowed in vertical move command
   CMP   R9,#&7F00              ;close enough
   BLGE  send_vertical_move
   Pull  "R0,R3,R7,R9"
   B     colourlj_nextline
d452 5
a456 10
;now separate out the bits in each plane
15
   LDR   R4,pending_blank_lines
   CMP   R4,#0
   BLGT  send_vertical_move     ;less than 0 (&80000000) if Y Offset not supported

   MOV   R4,#1                  ;current ribbon, starts at Y
   ORR   R9,R4,R4,LSL #4
   ORR   R9,R9,R9,LSL #8
   ORR   R9,R9,R9,LSL #16       ;ribbon bits, all 8 nibbles, start at Y (&11111111)    
d458 4
a461 8
   MOV   R7,#0                  ;byte so far
   Push  "R1,R3"                ;Read from here for each pass
   B     %FT30

25
   STRB  R7,[R0],#1
   SUBS  R3,R3,#8
   BLE   %FT35
d463 19
a481 29
   LDR   R8,[R1],#4             ;get 8 KCMY nibbles
   TST   R8,R9                  ;check for none of 8 nibbles set against ribbon
   BEQ   %BT25                  ;skip nibble-wise checks if none
   TST   R8,R4                  ;check for nibble 0 set against ribbon
   ORRNE R7,R7,#1:SHL:7         ;set bit 7 if match (bits required reversed in byte)
   TST   R8,R4,LSL #8           ;repeat for other 7 nibbles
   ORRNE R7,R7,#1:SHL:6
   TST   R8,R4,LSL #16
   ORRNE R7,R7,#1:SHL:5
   TST   R8,R4,LSL #24
   ORRNE R7,R7,#1:SHL:4
   TST   R8,R4,LSL #4
   ORRNE R7,R7,#1:SHL:3
   TST   R8,R4,LSL #12
   ORRNE R7,R7,#1:SHL:2
   TST   R8,R4,LSL #20
   ORRNE R7,R7,#1:SHL:1
   TST   R8,R4,LSL #28
   ORRNE R7,R7,#1:SHL:0
   STRB  R7,[R0],#1             ;a byte of ribbon colour now ready to store
   MOV   R7, #0                 ;clear ribbon colour bits again
   SUBS  R3,R3,#8
   BGT   %BT30
35
   Pull  "R1,R3"                ;Get the input data back
   MOV   R4,R4,LSL #1           ;Next ribbon (1 bit mask)
   MOV   R9,R9,LSL #1           ;Next ribbon (8 bit mask)
   ANDS  R4,R4,#15              ;Check if bit is in range
   BNE   %BT20
d483 1
a483 1
        Pull    "R0,R3,R7,R9"
d485 2
a486 8
colourlj_rearranged
        Push    "R4"
        LDRB    R4,[R7,#pd_private_flags]
        TST     R4,#pdf_FourPlanes
        BLNE    colourlj_colourstrip4
        TST     R4,#pdf_FourPlanes
        BLEQ    colourlj_colourstrip3
        Pull    "R4"
d488 1
a488 1
colourlj_nextline
d491 1
a491 1
        ADD     R0,R0,R5          ;Adjust the line pointer
d493 1
a493 1
        BGT     colourlj_lineloop ;Loop back until all bits tested
d495 1
a495 2
colourlj_exit
 Debug DumpMJS,"output_colour_sprite done"
d498 1
a498 1
;for four planes case
d500 1
a500 2
colourlj_colourstrip4
        Push    "R4,LR"
a504 1

d510 1
d514 1
d516 1
d520 1
d522 1
a524 1
        BL      output_mono_sprite_norev      ;W to terminate
d526 103
a628 1
        Pull    "R4,PC"
d630 59
d690 9
a698 1
;for three planes case
d700 1
a700 2
colourlj_colourstrip3
        Push    "R4,LR"
a705 2
        ADD     R0,R0,R5,LSL#1                 ;Starts with R!!

d708 1
d710 1
a710 1
        SUB     R0,R0,R5
d712 1
d714 1
d716 3
a718 2
        SUB     R0,R0,R5
        BL      output_mono_sprite_norev       ;W to terminate
d720 1
a720 1
        Pull    "R4,PC"
d722 34
d786 1
a786 1
        MOV     R2,#1:SHL:7     ;Bit to modify in source data
d789 3
a791 2

;we know width is a multiple of 8, so gulp 8 pixels at a time
d793 11
a803 24
        SUBS    R3,R3,#8
        BLT     %FT20
        LDMIA   R1!,{R6,R7}     ;next 8 pixels
        ORRS    R4,R6,R7        ;all white?
        STREQB  R4,[R0],#1
        BEQ     %BT15           ;fast route if so
        MOV     R4,#0
        TST     R6,#1:SHL:3     ;K bit of 1st pixel
        ORRNE   R4,R4,#1:SHL:7
        TST     R6,#1:SHL:11    ;K bit of 2nd pixel
        ORRNE   R4,R4,#1:SHL:6
        TST     R6,#1:SHL:19
        ORRNE   R4,R4,#1:SHL:5
        TST     R6,#1:SHL:27
        ORRNE   R4,R4,#1:SHL:4
        TST     R7,#1:SHL:3
        ORRNE   R4,R4,#1:SHL:3
        TST     R7,#1:SHL:11
        ORRNE   R4,R4,#1:SHL:2
        TST     R7,#1:SHL:19
        ORRNE   R4,R4,#1:SHL:1
        TST     R7,#1:SHL:27
        ORRNE   R4,R4,#1:SHL:0
        STRB    R4,[R0],#1
d805 3
a808 1
20
d823 1
a823 52

;below is similar to output_mono_altentry routine, but deals with blank lines
; (other routine used for colour - cannot deal with blank lines itself, because a
; 'line' is just one plane)

        Push    "R1"
        MOV     R1,#"W"
        LDRB    R7,[R7,#pd_private_flags]
30
        SWI     XOS_ReadEscapeState
        Pull    "R1,PC",CS      ;Return if escape pressed
                  
        Push    "R3"            ;Get the line width
35
        SUBS    R3,R3,#1
        BMI     %40             ;Any more bytes pending?

        LDRB    LR,[R0,R3]
        TEQ     LR,#0           ;Is there a valid byte here?
        BEQ     %35
40
        ADDS    R3,R3,#1        ;Account for pre-index
        BNE     %FT42

        LDR     LR,pending_blank_lines
        CMP     LR,#&80000000   ;check whether Y Offset supported
        BEQ     %FT42

        ADD     LR,LR,#1
        STR     LR,pending_blank_lines
;max value of +32767 allowed in vertical move command
        CMP     LR,#&7F00          ;close enough
        BLGE    send_vertical_move
        B       %FT44

42
        LDR     LR,pending_blank_lines
        CMP     LR,#0
        BLGT    send_vertical_move ;less than if Y Offset not supported

        TST     R7,#pdf_Compression
        BLEQ    sendlj_compressoff
        BLNE    sendlj_compressed

44
        Pull    "R3"            ;Restore real line length

        ADD     R0,R0,R5
        SUBS    R4,R4,#1
        BNE     %BT30           ;Loop back until all scan lines checked       

        Pull    "R1,PC",,^
@


4.1.7.2
log
@   Return an error EscDisabled if any PDumper is called with escape disabled.
   Check the GBPB error flag before checking the error-suppress flag.
   Copy the error block returned by OS_GBPB so FileSwitch doesn't overwrite it.
@
text
@d138 1
a138 1
        ADRL	R0,line_prologue
d171 1
a171 1
        ADRL	R2,line_prologuecompressed
d353 1
a353 1
   ADRL    R0,relvert_move
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d19 1
a19 1
; debugDump SETL true
a62 9
output_mono_sprite ROUT
        Push    "R1-R4"
        MUL     R3,R5,R4
        LJTranspose R0,R3,R1,R2,R4
        Pull    "R1-R4"
        B       output_mono_sprite_norev

;all the following entries assume bit-reversal-within-byte not needed

d70 1
a70 1
output_mono_sprite_norev ROUT
d136 1
d171 1
a341 16
;send pending blank lines as vertical move - should never be called if
;pdf_SupportsYOffset flag bit is not set
send_vertical_move
   Push    "R0-R2,LR"
   ADR     R0,relvert_move
   PDumper_PrintCountedString R0,R2,LR
   LDR     R0,pending_blank_lines
   BL      print_number
   MOV     R1,#'Y'
   PDumper_OutputReg R1
   MOV     R0,#0
   STR     R0,pending_blank_lines
   Pull    "R0-R2,PC"
relvert_move = 3,27,"*b"    ;raster Y offset command = ESC * b <rasters> Y
   ALIGN

d353 4
a356 6
; behind the area read from. There is a lower bound for this, but PDriverDP
; ensures a width of at least 8, so we are OK (any sensible width much bigger
; than 8 of course)
; Start is  %0000KCMY %0000KCMY %0000KCMY ....
; Finish is %BBBBBBBB %BBBBBBBB... %GGGGGGGG %GGGGGGGG... %RRRRRRRR ....   (3 planes separated)
;        or %YYYYYYYY %YYYYYYYY... %MMMMMMMM... %CCCCCCCC.... %KKKKKKKK... (4 planes separated)
d358 1
a358 1
; Latter occupies (N/8+1)*3 or (N/8+1)*4 at most
a360 3
; !!! assumes width (pixels) is multiple of 8 (should be ensured by
;     PDriverDP)

a362 2
  Debug DumpMJS,"output_colour_sprite w,h,align ",R3,R4,R5

d368 35
a402 1
colourlj_lineloop
d406 30
a435 1
        Push    "R0,R3,R7,R9"   ;Need to keep position of strip for output
d439 6
a444 1
        MOV     R1,R0           ;second pointer for save   
d446 2
a447 1
        MOV     R9, #1          ;R9 will be set false if we notice whole row is not white
d449 2
a450 62
;first phase - pack nibbles into bytes
   LDRB  R4,[R7,#pd_private_flags]
   TST   R4,#pdf_FourPlanes
   BNE   %FT10

;three planes case - replace K with CMY
5  SUB   R0,R0,#8
   LDMIA R0,{R4,R7}             ;load next 8 pixels
   ORRS  R4,R4,R7,LSL #4        ;munge together (8 KCMY nibbles)
   MOVNE R9,#0                  ;reset whole-row white flag if necessary
;replace any K's with CMY's
   TST   R4,#&80000000
   ORRNE R4,R4,#&70000000
   TST   R4,#&08000000
   ORRNE R4,R4,#&07000000
   TST   R4,#&00800000
   ORRNE R4,R4,#&00700000
   TST   R4,#&00080000
   ORRNE R4,R4,#&00070000
   TST   R4,#&00008000
   ORRNE R4,R4,#&00007000
   TST   R4,#&00000800
   ORRNE R4,R4,#&00000700
   TST   R4,#&00000080
   ORRNE R4,R4,#&00000070
   TST   R4,#&00000008
   ORRNE R4,R4,#&00000007
   BIC   R4,R4,#&88000000
   BIC   R4,R4,#&00880000
   BIC   R4,R4,#&00008800
   BIC   R4,R4,#&00000088
   MVN   R4,R4                  ;CMY -> RGB, to suit 3-plane case
   STR   R4,[R1,#-4]!           ;store for next pass
   SUBS  R3,R3,#8
   BNE   %BT5
   B     %FT12

;four planes case - K allowed
10 SUB   R0,R0,#8
   LDMIA R0,{R4,R7}             ;load next 8 pixels
   ORRS  R4,R4,R7,LSL #4        ;munge together (8 KCMY nibbles)
   MOVNE R9,#0                  ;reset whole-row white flag if necessary
   STR   R4,[R1,#-4]!           ;store for next pass
   SUBS  R3,R3,#8
   BNE   %BT10

12
   Pull  "R0,R3"                ;restore line start, count
   CMP   R9, #1                 ;was whole row white?
   BNE   %FT15
;yes
   LDR   R9,pending_blank_lines
   CMP   R9,#&80000000          ;is Y Offset unsupported?
   BEQ   %FT15
;let's skip a whole load of work
   ADD   R9,R9,#1
   STR   R9,pending_blank_lines
;max value of +32767 allowed in vertical move command
   CMP   R9,#&7F00              ;close enough
   BLGE  send_vertical_move
   Pull  "R0,R3,R7,R9"
   B     colourlj_nextline
d452 5
a456 10
;now separate out the bits in each plane
15
   LDR   R4,pending_blank_lines
   CMP   R4,#0
   BLGT  send_vertical_move     ;less than 0 (&80000000) if Y Offset not supported

   MOV   R4,#1                  ;current ribbon, starts at Y
   ORR   R9,R4,R4,LSL #4
   ORR   R9,R9,R9,LSL #8
   ORR   R9,R9,R9,LSL #16       ;ribbon bits, all 8 nibbles, start at Y (&11111111)    
d458 4
a461 8
   MOV   R7,#0                  ;byte so far
   Push  "R1,R3"                ;Read from here for each pass
   B     %FT30

25
   STRB  R7,[R0],#1
   SUBS  R3,R3,#8
   BLE   %FT35
d463 19
a481 29
   LDR   R8,[R1],#4             ;get 8 KCMY nibbles
   TST   R8,R9                  ;check for none of 8 nibbles set against ribbon
   BEQ   %BT25                  ;skip nibble-wise checks if none
   TST   R8,R4                  ;check for nibble 0 set against ribbon
   ORRNE R7,R7,#1:SHL:7         ;set bit 7 if match (bits required reversed in byte)
   TST   R8,R4,LSL #8           ;repeat for other 7 nibbles
   ORRNE R7,R7,#1:SHL:6
   TST   R8,R4,LSL #16
   ORRNE R7,R7,#1:SHL:5
   TST   R8,R4,LSL #24
   ORRNE R7,R7,#1:SHL:4
   TST   R8,R4,LSL #4
   ORRNE R7,R7,#1:SHL:3
   TST   R8,R4,LSL #12
   ORRNE R7,R7,#1:SHL:2
   TST   R8,R4,LSL #20
   ORRNE R7,R7,#1:SHL:1
   TST   R8,R4,LSL #28
   ORRNE R7,R7,#1:SHL:0
   STRB  R7,[R0],#1             ;a byte of ribbon colour now ready to store
   MOV   R7, #0                 ;clear ribbon colour bits again
   SUBS  R3,R3,#8
   BGT   %BT30
35
   Pull  "R1,R3"                ;Get the input data back
   MOV   R4,R4,LSL #1           ;Next ribbon (1 bit mask)
   MOV   R9,R9,LSL #1           ;Next ribbon (8 bit mask)
   ANDS  R4,R4,#15              ;Check if bit is in range
   BNE   %BT20
d483 1
a483 1
        Pull    "R0,R3,R7,R9"
d485 2
a486 8
colourlj_rearranged
        Push    "R4"
        LDRB    R4,[R7,#pd_private_flags]
        TST     R4,#pdf_FourPlanes
        BLNE    colourlj_colourstrip4
        TST     R4,#pdf_FourPlanes
        BLEQ    colourlj_colourstrip3
        Pull    "R4"
d488 1
a488 1
colourlj_nextline
d491 1
a491 1
        ADD     R0,R0,R5          ;Adjust the line pointer
d493 1
a493 1
        BGT     colourlj_lineloop ;Loop back until all bits tested
d495 1
a495 2
colourlj_exit
 Debug DumpMJS,"output_colour_sprite done"
d498 1
a498 1
;for four planes case
d500 1
a500 2
colourlj_colourstrip4
        Push    "R4,LR"
a504 1

d510 1
d514 1
d516 1
d520 1
d522 1
a524 1
        BL      output_mono_sprite_norev      ;W to terminate
d526 103
a628 1
        Pull    "R4,PC"
d630 59
d690 9
a698 1
;for three planes case
d700 1
a700 2
colourlj_colourstrip3
        Push    "R4,LR"
a705 2
        ADD     R0,R0,R5,LSL#1                 ;Starts with R!!

d708 1
d710 1
a710 1
        SUB     R0,R0,R5
d712 1
d714 1
d716 3
a718 2
        SUB     R0,R0,R5
        BL      output_mono_sprite_norev       ;W to terminate
d720 1
a720 1
        Pull    "R4,PC"
d722 34
d786 1
a786 1
        MOV     R2,#1:SHL:7     ;Bit to modify in source data
d789 3
a791 2

;we know width is a multiple of 8, so gulp 8 pixels at a time
d793 11
a803 24
        SUBS    R3,R3,#8
        BLT     %FT20
        LDMIA   R1!,{R6,R7}     ;next 8 pixels
        ORRS    R4,R6,R7        ;all white?
        STREQB  R4,[R0],#1
        BEQ     %BT15           ;fast route if so
        MOV     R4,#0
        TST     R6,#1:SHL:3     ;K bit of 1st pixel
        ORRNE   R4,R4,#1:SHL:7
        TST     R6,#1:SHL:11    ;K bit of 2nd pixel
        ORRNE   R4,R4,#1:SHL:6
        TST     R6,#1:SHL:19
        ORRNE   R4,R4,#1:SHL:5
        TST     R6,#1:SHL:27
        ORRNE   R4,R4,#1:SHL:4
        TST     R7,#1:SHL:3
        ORRNE   R4,R4,#1:SHL:3
        TST     R7,#1:SHL:11
        ORRNE   R4,R4,#1:SHL:2
        TST     R7,#1:SHL:19
        ORRNE   R4,R4,#1:SHL:1
        TST     R7,#1:SHL:27
        ORRNE   R4,R4,#1:SHL:0
        STRB    R4,[R0],#1
d805 3
a808 1
20
d823 1
a823 52

;below is similar to output_mono_altentry routine, but deals with blank lines
; (other routine used for colour - cannot deal with blank lines itself, because a
; 'line' is just one plane)

        Push    "R1"
        MOV     R1,#"W"
        LDRB    R7,[R7,#pd_private_flags]
30
        SWI     XOS_ReadEscapeState
        Pull    "R1,PC",CS      ;Return if escape pressed
                  
        Push    "R3"            ;Get the line width
35
        SUBS    R3,R3,#1
        BMI     %40             ;Any more bytes pending?

        LDRB    LR,[R0,R3]
        TEQ     LR,#0           ;Is there a valid byte here?
        BEQ     %35
40
        ADDS    R3,R3,#1        ;Account for pre-index
        BNE     %FT42

        LDR     LR,pending_blank_lines
        CMP     LR,#&80000000   ;check whether Y Offset supported
        BEQ     %FT42

        ADD     LR,LR,#1
        STR     LR,pending_blank_lines
;max value of +32767 allowed in vertical move command
        CMP     LR,#&7F00          ;close enough
        BLGE    send_vertical_move
        B       %FT44

42
        LDR     LR,pending_blank_lines
        CMP     LR,#0
        BLGT    send_vertical_move ;less than if Y Offset not supported

        TST     R7,#pdf_Compression
        BLEQ    sendlj_compressoff
        BLNE    sendlj_compressed

44
        Pull    "R3"            ;Restore real line length

        ADD     R0,R0,R5
        SUBS    R4,R4,#1
        BNE     %BT30           ;Loop back until all scan lines checked       

        Pull    "R1,PC",,^
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d19 1
a19 1
; debugDump SETL true
a62 9
output_mono_sprite ROUT
        Push    "R1-R4"
        MUL     R3,R5,R4
        LJTranspose R0,R3,R1,R2,R4
        Pull    "R1-R4"
        B       output_mono_sprite_norev

;all the following entries assume bit-reversal-within-byte not needed

d70 1
a70 1
output_mono_sprite_norev ROUT
d136 1
d171 1
a341 16
;send pending blank lines as vertical move - should never be called if
;pdf_SupportsYOffset flag bit is not set
send_vertical_move
   Push    "R0-R2,LR"
   ADR     R0,relvert_move
   PDumper_PrintCountedString R0,R2,LR
   LDR     R0,pending_blank_lines
   BL      print_number
   MOV     R1,#'Y'
   PDumper_OutputReg R1
   MOV     R0,#0
   STR     R0,pending_blank_lines
   Pull    "R0-R2,PC"
relvert_move = 3,27,"*b"    ;raster Y offset command = ESC * b <rasters> Y
   ALIGN

d353 4
a356 6
; behind the area read from. There is a lower bound for this, but PDriverDP
; ensures a width of at least 8, so we are OK (any sensible width much bigger
; than 8 of course)
; Start is  %0000KCMY %0000KCMY %0000KCMY ....
; Finish is %BBBBBBBB %BBBBBBBB... %GGGGGGGG %GGGGGGGG... %RRRRRRRR ....   (3 planes separated)
;        or %YYYYYYYY %YYYYYYYY... %MMMMMMMM... %CCCCCCCC.... %KKKKKKKK... (4 planes separated)
d358 1
a358 1
; Latter occupies (N/8+1)*3 or (N/8+1)*4 at most
a360 3
; !!! assumes width (pixels) is multiple of 8 (should be ensured by
;     PDriverDP)

a362 2
  Debug DumpMJS,"output_colour_sprite w,h,align ",R3,R4,R5

d368 35
a402 1
colourlj_lineloop
d406 30
a435 1
        Push    "R0,R3,R7,R9"   ;Need to keep position of strip for output
d439 6
a444 1
        MOV     R1,R0           ;second pointer for save   
d446 2
a447 1
        MOV     R9, #1          ;R9 will be set false if we notice whole row is not white
d449 2
a450 62
;first phase - pack nibbles into bytes
   LDRB  R4,[R7,#pd_private_flags]
   TST   R4,#pdf_FourPlanes
   BNE   %FT10

;three planes case - replace K with CMY
5  SUB   R0,R0,#8
   LDMIA R0,{R4,R7}             ;load next 8 pixels
   ORRS  R4,R4,R7,LSL #4        ;munge together (8 KCMY nibbles)
   MOVNE R9,#0                  ;reset whole-row white flag if necessary
;replace any K's with CMY's
   TST   R4,#&80000000
   ORRNE R4,R4,#&70000000
   TST   R4,#&08000000
   ORRNE R4,R4,#&07000000
   TST   R4,#&00800000
   ORRNE R4,R4,#&00700000
   TST   R4,#&00080000
   ORRNE R4,R4,#&00070000
   TST   R4,#&00008000
   ORRNE R4,R4,#&00007000
   TST   R4,#&00000800
   ORRNE R4,R4,#&00000700
   TST   R4,#&00000080
   ORRNE R4,R4,#&00000070
   TST   R4,#&00000008
   ORRNE R4,R4,#&00000007
   BIC   R4,R4,#&88000000
   BIC   R4,R4,#&00880000
   BIC   R4,R4,#&00008800
   BIC   R4,R4,#&00000088
   MVN   R4,R4                  ;CMY -> RGB, to suit 3-plane case
   STR   R4,[R1,#-4]!           ;store for next pass
   SUBS  R3,R3,#8
   BNE   %BT5
   B     %FT12

;four planes case - K allowed
10 SUB   R0,R0,#8
   LDMIA R0,{R4,R7}             ;load next 8 pixels
   ORRS  R4,R4,R7,LSL #4        ;munge together (8 KCMY nibbles)
   MOVNE R9,#0                  ;reset whole-row white flag if necessary
   STR   R4,[R1,#-4]!           ;store for next pass
   SUBS  R3,R3,#8
   BNE   %BT10

12
   Pull  "R0,R3"                ;restore line start, count
   CMP   R9, #1                 ;was whole row white?
   BNE   %FT15
;yes
   LDR   R9,pending_blank_lines
   CMP   R9,#&80000000          ;is Y Offset unsupported?
   BEQ   %FT15
;let's skip a whole load of work
   ADD   R9,R9,#1
   STR   R9,pending_blank_lines
;max value of +32767 allowed in vertical move command
   CMP   R9,#&7F00              ;close enough
   BLGE  send_vertical_move
   Pull  "R0,R3,R7,R9"
   B     colourlj_nextline
d452 5
a456 10
;now separate out the bits in each plane
15
   LDR   R4,pending_blank_lines
   CMP   R4,#0
   BLGT  send_vertical_move     ;less than 0 (&80000000) if Y Offset not supported

   MOV   R4,#1                  ;current ribbon, starts at Y
   ORR   R9,R4,R4,LSL #4
   ORR   R9,R9,R9,LSL #8
   ORR   R9,R9,R9,LSL #16       ;ribbon bits, all 8 nibbles, start at Y (&11111111)    
d458 4
a461 8
   MOV   R7,#0                  ;byte so far
   Push  "R1,R3"                ;Read from here for each pass
   B     %FT30

25
   STRB  R7,[R0],#1
   SUBS  R3,R3,#8
   BLE   %FT35
d463 19
a481 29
   LDR   R8,[R1],#4             ;get 8 KCMY nibbles
   TST   R8,R9                  ;check for none of 8 nibbles set against ribbon
   BEQ   %BT25                  ;skip nibble-wise checks if none
   TST   R8,R4                  ;check for nibble 0 set against ribbon
   ORRNE R7,R7,#1:SHL:7         ;set bit 7 if match (bits required reversed in byte)
   TST   R8,R4,LSL #8           ;repeat for other 7 nibbles
   ORRNE R7,R7,#1:SHL:6
   TST   R8,R4,LSL #16
   ORRNE R7,R7,#1:SHL:5
   TST   R8,R4,LSL #24
   ORRNE R7,R7,#1:SHL:4
   TST   R8,R4,LSL #4
   ORRNE R7,R7,#1:SHL:3
   TST   R8,R4,LSL #12
   ORRNE R7,R7,#1:SHL:2
   TST   R8,R4,LSL #20
   ORRNE R7,R7,#1:SHL:1
   TST   R8,R4,LSL #28
   ORRNE R7,R7,#1:SHL:0
   STRB  R7,[R0],#1             ;a byte of ribbon colour now ready to store
   MOV   R7, #0                 ;clear ribbon colour bits again
   SUBS  R3,R3,#8
   BGT   %BT30
35
   Pull  "R1,R3"                ;Get the input data back
   MOV   R4,R4,LSL #1           ;Next ribbon (1 bit mask)
   MOV   R9,R9,LSL #1           ;Next ribbon (8 bit mask)
   ANDS  R4,R4,#15              ;Check if bit is in range
   BNE   %BT20
d483 1
a483 1
        Pull    "R0,R3,R7,R9"
d485 2
a486 8
colourlj_rearranged
        Push    "R4"
        LDRB    R4,[R7,#pd_private_flags]
        TST     R4,#pdf_FourPlanes
        BLNE    colourlj_colourstrip4
        TST     R4,#pdf_FourPlanes
        BLEQ    colourlj_colourstrip3
        Pull    "R4"
d488 1
a488 1
colourlj_nextline
d491 1
a491 1
        ADD     R0,R0,R5          ;Adjust the line pointer
d493 1
a493 1
        BGT     colourlj_lineloop ;Loop back until all bits tested
d495 1
a495 2
colourlj_exit
 Debug DumpMJS,"output_colour_sprite done"
d498 1
a498 1
;for four planes case
d500 1
a500 2
colourlj_colourstrip4
        Push    "R4,LR"
a504 1

d510 1
d514 1
d516 1
d520 1
d522 1
a524 1
        BL      output_mono_sprite_norev      ;W to terminate
d526 103
a628 1
        Pull    "R4,PC"
d630 59
d690 9
a698 1
;for three planes case
d700 1
a700 2
colourlj_colourstrip3
        Push    "R4,LR"
a705 2
        ADD     R0,R0,R5,LSL#1                 ;Starts with R!!

d708 1
d710 1
a710 1
        SUB     R0,R0,R5
d712 1
d714 1
d716 3
a718 2
        SUB     R0,R0,R5
        BL      output_mono_sprite_norev       ;W to terminate
d720 1
a720 1
        Pull    "R4,PC"
d722 34
d786 1
a786 1
        MOV     R2,#1:SHL:7     ;Bit to modify in source data
d789 3
a791 2

;we know width is a multiple of 8, so gulp 8 pixels at a time
d793 11
a803 24
        SUBS    R3,R3,#8
        BLT     %FT20
        LDMIA   R1!,{R6,R7}     ;next 8 pixels
        ORRS    R4,R6,R7        ;all white?
        STREQB  R4,[R0],#1
        BEQ     %BT15           ;fast route if so
        MOV     R4,#0
        TST     R6,#1:SHL:3     ;K bit of 1st pixel
        ORRNE   R4,R4,#1:SHL:7
        TST     R6,#1:SHL:11    ;K bit of 2nd pixel
        ORRNE   R4,R4,#1:SHL:6
        TST     R6,#1:SHL:19
        ORRNE   R4,R4,#1:SHL:5
        TST     R6,#1:SHL:27
        ORRNE   R4,R4,#1:SHL:4
        TST     R7,#1:SHL:3
        ORRNE   R4,R4,#1:SHL:3
        TST     R7,#1:SHL:11
        ORRNE   R4,R4,#1:SHL:2
        TST     R7,#1:SHL:19
        ORRNE   R4,R4,#1:SHL:1
        TST     R7,#1:SHL:27
        ORRNE   R4,R4,#1:SHL:0
        STRB    R4,[R0],#1
d805 3
a808 1
20
d823 1
a823 52

;below is similar to output_mono_altentry routine, but deals with blank lines
; (other routine used for colour - cannot deal with blank lines itself, because a
; 'line' is just one plane)

        Push    "R1"
        MOV     R1,#"W"
        LDRB    R7,[R7,#pd_private_flags]
30
        SWI     XOS_ReadEscapeState
        Pull    "R1,PC",CS      ;Return if escape pressed
                  
        Push    "R3"            ;Get the line width
35
        SUBS    R3,R3,#1
        BMI     %40             ;Any more bytes pending?

        LDRB    LR,[R0,R3]
        TEQ     LR,#0           ;Is there a valid byte here?
        BEQ     %35
40
        ADDS    R3,R3,#1        ;Account for pre-index
        BNE     %FT42

        LDR     LR,pending_blank_lines
        CMP     LR,#&80000000   ;check whether Y Offset supported
        BEQ     %FT42

        ADD     LR,LR,#1
        STR     LR,pending_blank_lines
;max value of +32767 allowed in vertical move command
        CMP     LR,#&7F00          ;close enough
        BLGE    send_vertical_move
        B       %FT44

42
        LDR     LR,pending_blank_lines
        CMP     LR,#0
        BLGT    send_vertical_move ;less than if Y Offset not supported

        TST     R7,#pdf_Compression
        BLEQ    sendlj_compressoff
        BLNE    sendlj_compressed

44
        Pull    "R3"            ;Restore real line length

        ADD     R0,R0,R5
        SUBS    R4,R4,#1
        BNE     %BT30           ;Loop back until all scan lines checked       

        Pull    "R1,PC",,^
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

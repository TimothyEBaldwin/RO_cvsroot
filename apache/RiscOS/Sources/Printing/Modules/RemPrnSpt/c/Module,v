head	4.10;
access;
symbols
	RemPrnSpt-1_15:4.10
	RemPrnSpt-1_14:4.9
	RemPrnSpt-1_13:4.9
	RemPrnSpt-1_12:4.8
	RemPrnSpt-1_11:4.7
	RemPrnSpt-1_10:4.7
	RemPrnSpt-1_09:4.6
	RemPrnSpt-1_08:4.5
	RemPrnSpt-1_07:4.4
	RemPrnSpt-1_06:4.3
	RemPrnSpt-1_05:4.2
	RemPrnSpt-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.1
	Ursula_RiscPC:4.1.7.1.0.6
	rthornb_UrsulaBuild-19Aug1998:4.1.7.1
	UrsulaBuild_FinalSoftload:4.1.7.1
	rthornb_UrsulaBuild-12Aug1998:4.1.7.1
	aglover_UrsulaBuild-05Aug1998:4.1.7.1
	rthornb_UrsulaBuild-29Jul1998:4.1.7.1
	rthornb_UrsulaBuild-22Jul1998:4.1.7.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.1.7.1
	rthornb_UrsulaBuild-17Jun1998:4.1.7.1
	rthornb_UrsulaBuild-03Jun1998:4.1.7.1
	rthornb_UrsulaBuild-27May1998:4.1.7.1
	rthornb_UrsulaBuild-21May1998:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Ursula:4.1.7.1.0.4
	Ursula_bp:4.1.7.1
	Ursula_31Mar1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spin_merge_28May97:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2015.11.15.19.23.04;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	mNkGmHP4eMvUTdJy;

4.9
date	2013.12.17.19.32.21;	author jlee;	state Exp;
branches;
next	4.8;
commitid	NFSBNLj9J4Vaowhx;

4.8
date	2013.04.06.07.00.05;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	Nxd1WLOLjqKfqGKw;

4.7
date	2004.08.12.15.46.14;	author jballance;	state Exp;
branches;
next	4.6;

4.6
date	2003.04.15.08.20.40;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2003.04.11.09.14.58;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2003.03.24.15.50.47;	author srevill;	state Exp;
branches;
next	4.3;

4.3
date	2003.01.17.10.38.54;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2003.01.09.13.51.58;	author rsprowson;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.48.55;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.48.55;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.08.12;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.29.10;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.32.40;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Fix for NULL pointer dereference when Access disabled
With Access turned off in InetSetup Freeway doesn't run, so Inet$LocalAddr is unset, so getenv() returns a NULL pointer.
Be more careful not to strncpy() it.

Version 1.15. Tagged as 'RemPrnSpt-1_15'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * module.c - the module wrapper and guts of RemotePrinterSupport
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <kernel.h>

#include <swis.h>

#include "Global/Services.h"
#include "Global/UpCall.h"
#include "Global/RISCOS.h"
#include "USB/USBDevFS.h"

#include "Freeway.h"
#include "Pollword.h"

#include "Module.h"
#include "Debug.h"
#include "Msgs.h"
#include "StrExtra.h"
#include "EventQueue.h"
#include "RemPrnSptHdr.h"

/***********************************************************************\
**                                                                     **
** Nasty old global variables                                          **
**                                                                     **
\***********************************************************************/

/*
 * The string that gets stored in PrinterType$n
 */

static char printer_type[256] ;

/*
 * Somewhere to hold the name of the remote printer we're dealing with
 */

static char printer_name[15] ;

/*
 * The current job number
 */

static int job_no = 0 ;

/*
 * A temporary array used for forming rename pathnames.
 * Could allocate it on the fly, but the less chances
 * for things to go wrong the better.
 */

static char tmp[256] ;

/*
 * A structure used for creating a collection of USB
 * device information on receipt of Service_USB. This
 * includes the VendorID, ProductID, USB device name and
 * the name of the PDF file to use (if found).
 *
 * If you change this structure, you will have to change
 * the supporting code in !Printers (sources.Sparrow) to
 * reflect your changes.
 */

typedef struct usb_object
{
  uint16_t vendor ;
  uint16_t product ;
  uint8_t  devclass ;
  uint8_t  devsubclass ;
  uint8_t  protocol ;
  uint8_t  alternate_setting ;
  uint8_t  interface_setting ;
  uint8_t  spare[3];           // align to word offset
  char     devname[20] ;
  char     pdfname[40] ;
} usb_object ;
static usb_object usb_obj ;

/*
 * A USB object list (returned by enumerate SWI)
 */
typedef struct usb_object_list usb_object_list ;
struct usb_object_list
{
  usb_object_list *next ;
  usb_object       obj ;
} ;

/*
 * The string that represents the unique hardware address
 * of the ethernet hardware in this machine
 */

static char unique_address[11] ;

/*
 * The IP address of the remote printer we're dealing with,
 * used if !Printers is quitting to allow the module to
 * function on its own
 */

static int ip_address ;

/*
 * The pollword used by !Printers
 */

static int poll_word = 0 ;

/*
 * An often used structre
 */

static struct _Event event ;

/*
 * Keep a record of what printer: was pointing to before we
 * mangled it.
 */

static int old_printer_type = -1 ;

/*
 * Are we meant to be doing anything now?
 */

static int rps_enabled = FALSE ;

/*
 * Is printers there? No? Then do file renaming.
 */

static int do_rename = FALSE ;

/*
 * Has printers started yet? If so, return object changed/added/removed
 * queue entries.
 */

static int printers_started = FALSE ;

/*
 * Global set of registers to use.
 * Less coming and going off stack each function entry
 */

_kernel_swi_regs r ;

/*
 * Global error block for constructing our own errors.
 */

_kernel_oserror err ;

/*
 * Global error block pointer for _kernel_* returns
 */

_kernel_oserror *e ;

/*
 * Trap upcall media not present
 */

static int trap_upcalls = FALSE ;

/*
 * Backend filetype for direct printing
 */

static int filetype ;

/***********************************************************************\
**                                                                     **
** Functions                                                           **
**                                                                     **
\***********************************************************************/

/*
 * Finalisation handler
 */

_kernel_oserror *rps_modfinal(int fatal, int podule, void *pw)
{
    msgs_closefile (msgs_handle) ;
    msgs_closefile (map_handle) ;

#ifndef ROM
    r.r[0] = (int) remprn_messages(); 
    _kernel_swi (ResourceFS_DeregisterFiles, &r, &r);
#endif

    r.r[0] = UpCallV ;
    r.r[1] = (int) rps_entry ;
    r.r[2] = (int) pw ;
    _kernel_swi (OS_Release, &r, &r) ;

debug dprintf ("rps: Dying\n\r") ;
debug debug_stop () ;

    UNUSED(podule);
    UNUSED(fatal);
    
    return NULL;
}

/*
 * Initialisation handler
 */

_kernel_oserror *rps_modinit (const char *cmd_tail, int podule_base, void *pw)
{
    const char *local;

#ifndef ROM
    /*
     * Register the messages for RAM based modules
     */
    r.r[0] = (int) remprn_messages();
    if ((e = _kernel_swi (ResourceFS_RegisterFiles, &r, &r)) != NULL)
        return (e) ;
#endif
    /*
     * Open our messages file
     */
    if ((e = msgs_openfile (msgs_handle, Module_MessagesFile)) != NULL)
        goto fail ;

    /*
     * Open our printer to PDF mappings file
     */
    if ((e = msgs_openfile (map_handle, MAPPINGS_FILE)) != NULL)
        goto fail_msgs ;

    /*
     * Hurray! It all worked, get local address from Freeway
     */
    local = getenv ("Inet$LocalAddr");
    if (local != NULL)
        strncpy (unique_address, local, 10) ;

    /*
     * Stuff a routine on UpCallV
     */

    r.r[0] = UpCallV ;
    r.r[1] = (int) rps_entry ;
    r.r[2] = (int) pw ;
    if ((e = _kernel_swi (OS_Claim, &r, &r)) != NULL)
        goto fail_map_msgs ;

    debug debug_start () ;
    debug dprintf ("rps: Initialising\n\r") ;

    UNUSED(cmd_tail);
    UNUSED(podule_base);
    
    return NULL;

fail_map_msgs:
    msgs_closefile (map_handle) ;
fail_msgs:
    msgs_closefile (msgs_handle) ;
fail:
#ifndef ROM
    r.r[0] = (int) remprn_messages();
    _kernel_swi (ResourceFS_DeregisterFiles, &r, &r);
#endif
    return (e);
}

static void write_information_file (int ip_address, char *unique_address, int job_no)
{
  FILE *f ;

  sprintf (tmp, "Share::_S%x.RemQueue.%s.R%dI",ip_address, unique_address, job_no) ;

  debug dprintf ("Trying to open information file %s\n\r", tmp) ;

  f = fopen (tmp, "ab+") ;
  if (f == NULL)
  {
    /*
     * Failed to write info file, delete spool file
     */
    sprintf (tmp, "Share::_S%x.RemQueue.%s.R%d",ip_address, unique_address, job_no) ;

    debug dprintf ("Failed, deleting %s\n\r", tmp) ;

    r.r[0] = 6 ; /* Delete object */
    r.r[1] = (int) tmp ;
    _kernel_swi (OS_File, &r, &r) ;

    /*
     * We don't particularly care if this goes wrong, difficult to
     * do anything about it...
     */
  }
  else
  {
    fprintf (f, "%s%c%s%c%s%c%s\n", printer_name, 0, unique_address, 0, msgs_lookup (msgs_handle, "UNKN", 0), 0, msgs_lookup (msgs_handle, "UNKN", 0)) ;

    debug dprintf ("Succeeded, writing %s %s %s\n\r", printer_name, unique_address, msgs_lookup (msgs_handle, "UNKN", 0)) ;

    fclose (f) ;
  }
}

/*
 * Rename callback handler
 */

int rename_handler (_kernel_swi_regs *lr, void *pw)
{
    _kernel_oserror *e ;
    /*
     * FIXME: Delete destination file just in case it exists?
     */

    write_information_file (ip_address, unique_address, job_no) ;

    sprintf (tmp, "Share::_S%x.RemQueue.%s.R%d",ip_address, unique_address, job_no) ;

    debug dprintf ("Rename from %s to %s\n\r", printer_type, tmp) ;

    r.r[0] = 25 ; /* rename */
    r.r[1] = (int) printer_type ;
    r.r[2] = (int) tmp ;
    e = _kernel_swi (OS_FSControl, &r, &r) ;

    if (e)
    {
      debug dprintf ("Error is %d %s\n\r", (int *) e, (char *)e+4) ;
    }
    else
    {
      r.r[0] = 18 ; /* Settype */
      r.r[1] = (int) tmp ;
      r.r[2] = filetype ;
      _kernel_swi (OS_File, &r, &r) ;
    }

    if (++job_no > 255)
      job_no = 0 ;

    UNUSED(pw);
    UNUSED(lr);

    return (1) ;
}

/*
 * Queue handling thingy
 */

static _kernel_oserror *add_to_queue (int type, char *string_object)
{
        event.type     = type ;
        event.obj_size = strlen (string_object) + 1 ;
        event.object   = (char *) malloc (event.obj_size) ;
        memcpy (event.object, string_object, event.obj_size) ;

        debug dprintf ("About to add to queue\n\r") ;

        if ((e = Queue_Add (&event)) != NULL)
                return (e)  ;

        debug dprintf ("Added to queue\n\r") ;

        poll_word = POLLWORD_SOMETHING_HAPPENED ;

        return ((_kernel_oserror *) NULL) ;
}

/*
 * Another queue handling thingy
 */

static _kernel_oserror *add_usb_to_queue (int type, usb_object *object)
{
        event.type     = type ;
        event.obj_size = sizeof (usb_object) ;
        event.object   = (char *) malloc (event.obj_size) ;
        memcpy (event.object, (char *) object, event.obj_size) ;

        debug dprintf ("About to add USB object to queue\n\r") ;

        if ((e = Queue_Add (&event)) != NULL)
                return (e)  ;

        debug dprintf ("Added USB object to queue\n\r") ;

        poll_word = POLLWORD_SOMETHING_HAPPENED ;

        return ((_kernel_oserror *) NULL) ;
}


/*
 * Returns 1 if this USB device mapped onto a printer in our USBMap file.
 *
 * As a side-effect, the global 'usb_obj' is filled-in with the details of
 * the printer.
 */
static int is_it_a_USB_printer (USBServiceCall *service)
{
    char               *pdf ;
    char               *ptr, *ptr_end ;

    debug dprintf (" dev_name '%s' dev_class %d\n\r", service->devname, (service->ddesc).bDeviceClass) ;
    debug dprintf (" vendor %04X, product %04X\n\r", (service->ddesc).idVendor, (service->ddesc).idProduct) ;
    debug dprintf (" subclass %X, spec %X\n\r",    (service->ddesc).bDeviceSubClass, (service->ddesc).bcdUSB) ;

    usb_obj.vendor  = (service->ddesc).idVendor ;
    usb_obj.product = (service->ddesc).idProduct ;
    strcpy (usb_obj.devname, service->devname) ;

    /* Walk through the descriptors until an interface one is found */
    ptr     = (char *) &service->ddesc;
    ptr_end = ((char *) service) + service->sclen;

    while ((ptr < ptr_end) && (*ptr != 0))
          {
          debug dprintf (" look at type %d length %d\n\r",(int)ptr[1],(int)ptr[0]);
          if (ptr[1] == UDESC_INTERFACE)
             {
             /* An interface type */
             usb_interface_descriptor_t *interface;
             interface = (usb_interface_descriptor_t *)ptr;
             debug dprintf(" interface descriptor for %d.%d:%d\n\r",interface->bInterfaceClass,
                                                                  interface->bInterfaceSubClass,
                                                                  interface->bInterfaceProtocol);
             if ((interface->bInterfaceClass == 7) &&
                 (interface->bInterfaceSubClass == 1) &&
                 (interface->bInterfaceProtocol == 2))
                {
                /* A bulk interface of type printer */
                usb_obj.alternate_setting = interface->bAlternateSetting;
                usb_obj.interface_setting = interface->bInterfaceNumber;
                usb_obj.devclass          = 7; /* Printer */
                usb_obj.devsubclass       = 1;
                usb_obj.protocol          = 2; /* Bulk */
                sprintf (tmp, "%04X%04X\0", (service->ddesc).idVendor, (service->ddesc).idProduct) ;

                debug dprintf (" -> USB device token '%s'\n\r", tmp) ;
                debug dprintf (" if:%d alt:%d \n\r",usb_obj.interface_setting,usb_obj.alternate_setting);
                pdf = msgs_quick_lookup(map_handle, tmp) ;
                if (pdf)
                   {
                   /* Success ! */
                   debug dprintf (" -> USB maps to PDF '%s'\n\r", pdf) ;
                   strcpy (usb_obj.pdfname, pdf) ;
                   }
                else
                   {
                   /* It's not in the mapping file,but we're pretty sure it's a printer so return
                      it anyway incase !Printers wants to have a go at guessing the printer type */
                   *usb_obj.pdfname = '\0' ;
                   debug dprintf (" -> USB printer not in mappings but reported anyway\n\r") ;
                   }
                return (1) ;
                }
             }
          ptr += *ptr;
          }

    /* Something went wrong or it simply didn't look like a printer */
    return (0) ;
}


/*
 * Enumerate all USB devices and do a look-up on each to find out
 * if it is a printer. Return a linked-list of usb_objects containing
 * information about each printer. It is the caller's responsibility
 * to free the (RMA) blocks in the linked list.
 */
static usb_object_list *swi_enumerate_USB_printers (int flags)
{
    USBServiceAnswer *device, *next ;
    usb_object_list  *head, *node ;

    r.r[0] = 1 ;
    r.r[1] = Service_USB ;
    r.r[2] = 0 ;
    if (_kernel_swi (OS_ServiceCall, &r, &r)) return (NULL) ;

    device = (USBServiceAnswer *) r.r[2] ;
    head   = NULL ;
    while (device)
    {
        next = device->link ;
        if ( is_it_a_USB_printer (&(device->svc)) )
        {
            node = (usb_object_list *) malloc (sizeof(usb_object_list)) ;
            if (node)
            {
                node->next = head ;
                head       = node ;
                memcpy (&(node->obj), &usb_obj, sizeof(usb_object)) ;
            }
        }

        free (device) ;
        device = next ;
    }

    UNUSED(flags);
    
    return (head) ;
}


/*
 * UpcallV handler
 */

int rps_handler (_kernel_swi_regs *lr, void *pw)
{
    char *s ;
    char *sp ;
    char *wscrap ;

    /*
     * return 1 else it'll blow up
     */

    switch (lr->r[0])
    {
        case UpCall_MediaNotKnown:
        case UpCall_MediaNotPresent:

             if (trap_upcalls)
             {
                  lr->r[0] = -1;
                  return 0; /* CLAIM! */
             }
             break ;

        case UpCall_ModifyingFile:

            if (lr->r[9] == 520)  /* Renaming file */
            {
                sp = getenv ("Wimp$ScrapDir") ;
                /*
                 * Get to $.blah
                 */
                wscrap = strchr (sp, ':') + 1 ;
                debug dprintf ("Wimp Scrap path = %s\n\r", wscrap) ;

                if (strlen(wscrap) < strlen((char *)(lr->r[2])))
                {
                    s = (char *)(lr->r[2]) + strlen (wscrap) + 1 ;

                    debug dprintf ("$.path = %s\n\r", s) ;
                    /*
                     * Get to blah
                     */
                    debug dprintf ("path = %s\n\r", s) ;
                    s = strchr (s, '.') + 1;

                    if ((unsigned int) s > 1)
                    {
                        debug dprintf ("match = %s\n\r", s) ;

                        /*
                         * TESTME! Seems to work
                         */
                        if (strincmp (s, "RemQueue", 8) == 0)
                        {
                            debug dprintf ("About to add file renamed to queue\n\r") ;
                            (void) add_to_queue (RPS_FILE_RENAMED, s) ;
                        }
                    }
                }
            }

            if (lr->r[9] == 259)  /* Closing file */
            {
                int temp;
                r.r[0] = 7 ;
                r.r[1] = lr->r[1] ;
                r.r[2] = (int) tmp ;
                r.r[5] = 257 ;
                _kernel_swi (OS_Args, &r, &r) ;

#ifdef OldPrinters
                if (strncmp (tmp, "printer:", 8) == 0)
#else
                temp = trap_upcalls;
                trap_upcalls = TRUE;
                s = canon (getenv ("Printer$Path")) ;
                trap_upcalls = temp;
                debug dprintf ("Comparing %s with %s\n\r", tmp, s) ;
                if (stricmp (tmp, s) == 0)
#endif
                {
                    debug dprintf ("printer: is about to be closed\n\r") ;

                    if (rps_enabled)
                    {
                        if (do_rename)
                        {
                            r.r[0] = 50 ; /* 2 seconds */
                            r.r[1] = (int) rename_entry ;
                            r.r[2] = (int) pw ;
                            _kernel_swi (OS_CallAfter, &r, &r) ;
                        }
                        else
                        {
                            debug dprintf ("Adding printer closed event to the queue\n\r") ;
                            if (rps_enabled)
                                (void) add_to_queue (RPS_PRINTER_CLOSED, "") ;
                        }
                    }
                }
                free (s) ;
            }
            break ;

        case UpCall_Freeway:

        debug dprintf ("UpCall_Freeway received object type %d reason %d object %s\n\r",
        lr->r[2], lr->r[1], lr->r[3]) ;

            if ((lr->r[2] == FreewayType_Printers) && (printers_started))
            {
                switch (lr->r[1])
                {
                    case Freeway_ObjectAdded:
                        (void) add_to_queue (RPS_PRINTER_ADDED, (char *)(lr->r[3])) ;
                        break ;

                    case Freeway_ObjectRemoved:
                        (void) add_to_queue (RPS_PRINTER_DELETED, (char *)(lr->r[3])) ;
                        break ;

                    case Freeway_ObjectChanged:
                        (void) add_to_queue (RPS_PRINTER_CHANGED, (char *)(lr->r[3])) ;
                        break ;

                    case Freeway_ObjectDeleted:
                        (void) add_to_queue (RPS_LOCALPRINTER_DELETED, (char *)(lr->r[3])) ;
                        break ;
                    /*
                     * Don't complain about unknown freeway reasons
                     * else it'll go bang in the future
                     */
                }
            }
            break ;
    }

    return (1) ;
}

/*
 * Service call handler
 */

void sc_handler (int service_number, _kernel_swi_regs *lr, void *pw)
{
    switch (service_number)
    {
        /* Service_DeviceDead
         *
         * Was it a USB device? If so, add the device name to our queue
         * for !Printers to see if it was a known printer.
         */
        case Service_DeviceDead:
        {
            debug dprintf ("Service_DeviceDead received\n\r") ;

            if (lr->r[3] == 0)
               {
               debug dprintf (" -> string was empty, ignored\n\r") ;
               break ;
               }

            if (strstr ((char *) (lr->r[3]), "USB") != (char *) (lr->r[3]))
               {
               debug dprintf (" -> not a USB device, ignored\n\r") ;
               break ;
               }

            debug dprintf (" -> USB device removed\n\r") ;
            (void) add_to_queue (USB_DEVICE_REMOVED, (char *) (lr->r[3])) ;
            break ;
        }
#ifndef ROM
        /* Service_ResourceFSStarting
         * Reregister our messages
         */
        case Service_ResourceFSStarting:
            (*(void (*)(void *, void *, void *, void *)) lr->r[2])(remprn_messages(), 0, 0, (void *) lr->r[3]);
            break;
#endif                    
        /* Service calls from Freeway module.
         */
        case Service_FreewayTerminating:
        {
            (void) add_to_queue (RPS_FREEWAY_TERMINATING, "") ;
            rps_enabled = FALSE ;
            debug dprintf ("Service_FreewayTerminating received\n\r") ;
            break ;
        }
        case Service_FreewayStarting:
        {
            (void) add_to_queue (RPS_FREEWAY_STARTING, "") ;
            rps_enabled = FALSE ;
            debug dprintf ("Service_FreewayStarting received\n\r") ;
            break ;
        }
        /* Service_USB
         *
         * Was it a device being added? Was the class 'printer'? If it was,
         * add some pertinent info to our queue.
         */
        case Service_USB:
        {
            debug dprintf ("Service_USB received R0=%d\n\r", lr->r[0]) ;
            if (lr->r[0] == Service_USB_Attach)
            {
                if ( is_it_a_USB_printer ((USBServiceCall *) (lr->r[2])) )
                   add_usb_to_queue (USB_PRINTER_ADDED, &usb_obj) ;
            }
            break ;
        }
    }

    UNUSED(pw);
}

/*
 * SWI Handler: 0 = ReadPollwordLocation
 *              1 = GetNextEvent
 *              2 = ReadUniqueAddress
 *              3 = Enable
 *              4 = Disable
 *              5 = EnableUpcalls
 *              6 = DisableUpcalls
 *              7 = EnumerateUSBPrinters
 */

_kernel_oserror *rps_swi (int swi_number, _kernel_swi_regs *r, void *pw)
{
    _kernel_swi_regs rr ;
    Event ev = NULL ;

    switch (swi_number)
    {
        case 0:
            r->r[0] = (int) &poll_word ;
            return ((_kernel_oserror *) 0) ;
            break ;

        case 1: /* FIXME */
            e = Queue_Read (&ev) ;
            debug dprintf ("rps_swi: Just done queue_read, ev r = %d, obj = %d\n\r", ev->type, ev->object) ;
            debug dprintf ("rps_swi: Registers are r0 %d r1 %X r2 %d\n\r", r->r[0], r->r[1], r->r[2]) ;

            if (e)
                return (e) ;

            if (ev == NULL) /* Then there's nothing in the queue */
            {
                debug dprintf ("rps_swi: Empty event queue - returning all -1\n\r") ;
                r->r[0] = -1 ;
                r->r[1] = -1 ;
                r->r[2] = -1 ;
            }
            else
            {
              if (r->r[2] == -1) /* Read reqd buffer size */
              {
                debug dprintf ("rps_swi: asked to return buffer size, %d\n\r", ev->obj_size) ;
                r->r[0] = ev->type ;
                r->r[2] = ev->obj_size ;
              }
              else
              {
                debug dprintf ("rps_swi: returning real data into buffer, r %d b %d l %d\n\r", ev->type, r->r[1], r->r[2]) ;
                r->r[0] = ev->type ;
                if (r->r[2])
                  {
                  debug dprintf ("rps_swi: memcpy %d from %08X to %08X\n\r", r->r[2], ev->object, (char *)(r->r[1]));
                  memcpy((char *)(r->r[1]), ev->object, r->r[2]) ;
                  }
                Queue_Remove () ; /* Frees string too if necessary */
              }
            }
            return ((_kernel_oserror *) 0) ;

            break ;

        case 2:
            r->r[0] = (int) unique_address ;
            return ((_kernel_oserror *) 0) ;
            break ;

        case 3:
            /*
             * Enable: R0 = flags
             *         R1 = IP address of printer
             *         R2 = printer name
             *         R3 = significant backend filetype
             */
            rps_enabled = TRUE ;

            if (r->r[0] & 1) /* Printers is present */
                do_rename = FALSE ;
            else /* Printers is quitting */
            {
                do_rename = TRUE ;
                printers_started = FALSE ;
            }

            if (r->r[0] & 2) /* Printers has started & is ready for messages */
            {
                debug dprintf ("Setting printers started flag\n\r") ;
                printers_started = TRUE ;
                break ;
            }

            ip_address = r->r[1] ;
            strncpy (printer_name, (char *)(r->r[2]), 14) ;

            debug dprintf ("Setting up printer:\n\r") ;

            /*
             * Make our directories, assumes it all exists up to
             *   Share::_S<IPaddr>.RemSpool
             */
            if (!(r->r[0])) /* If printers is quitting */
            {
              /*
               * Set up the appropriate PrinterType$ variable
               */

              printers_started = FALSE ;

              filetype = r->r[3] ;

              sprintf (printer_type, "Share::_S%x.RemSpool.%s.Rspool",
                  r->r[1], unique_address) ;

              rr.r[0] = (int) "PrinterType$9" ;
              rr.r[1] = (int) printer_type ;
              rr.r[2] = strlen (printer_type) ;
              rr.r[3] = 0 ;
              rr.r[4] = 4 ; /* Literal String */
              e = _kernel_swi (OS_SetVarVal, &rr, &rr) ;
              if (e)
                  return (e) ;

              /*
               * Write current printer type to be xx
               */

              rr.r[0] = 5 ;
              rr.r[1] = 9 ; /* FIXME! Might not be right */
              e = _kernel_swi (OS_Byte, &rr, &rr) ;
              if (e)
                  return (e) ;

              /*
               * Remember what it used to be
               */

              old_printer_type = rr.r[1] ;
            }

            return ((_kernel_oserror *) 0) ;
            break ;

        case 4:
            /*
             * Change back to old printer driver
             */

            debug dprintf ("Reverting to old printer:\n\r") ;

            rps_enabled = FALSE ;

            if ((do_rename) && (old_printer_type != -1))
            {
                rr.r[0] = 5 ;
                rr.r[1] = old_printer_type ;
                _kernel_swi (OS_Byte, &rr, &rr) ;
                old_printer_type = -1 ;
            }

            return ((_kernel_oserror *) 0) ;
            break ;

        case 5:
            /*
             * Enable Upcalls again
             */
             trap_upcalls = FALSE ;
             break ;

        case 6:
            /*
             * Disable (claim) UpCall_MediaNotPresent
             */
             trap_upcalls = TRUE ;
             break ;

        case 7:
            /*
             * Enumerate USB printers
             *
             * On entry:
             *   R0 = flags (undefined)
             * On exit:
             *   R0 = preserved
             *   R2 = pointer to linked list of usb_objects (or NULL for none)
             */
            r->r[2] = (int) swi_enumerate_USB_printers(r->r[0]) ;
            break ;

        default:
            /*
             * Unknown SWI
             */
            return error_BAD_SWI;
    }

    UNUSED(pw);
    
    /* NOTREACHED */
    return ((_kernel_oserror *) 0) ;
}
@


4.9
log
@Fix null pointer dereferences in SWI RemotePrinterSupport_Enable
Detail:
  c/Module - When PrinterManager calls RemotePrinterSupport_Enable with flag bit 1 set, no printer IP or name is supplied. However the code was still trying to read them, causing null pointer dereferences. Code rearranged slightly so that flag bit 1 is handled before the values are read.
Admin:
  Tested on BB-xM with high processor vectors
  Fixes crash when loading !Printers


Version 1.13. Tagged as 'RemPrnSpt-1_13'
@
text
@d233 2
d256 1
a256 1
     * Hurray! It all worked, get local address
d258 3
a260 1
    strncpy (unique_address, getenv ("Inet$LocalAddr"), 10) ;
@


4.8
log
@Makefile recreated from fragments
Usual drill
* Rename CMHG file to be the auto generated one
* Cast away some warnings
* Swap a few header files around, use defs from central headers where available
Also, add hdr/RemotePrin which in turn will be exported and end up in <swis.h>.

Eliminated the RemPrnSptMsgs module target - if we're disc based then carry round and register our own messages (through the magic of the shared makefiles), and if we're ROM based the messages are exported to ResourceFS as usual in the resources phase.

Compiled and ran, messages were correctly registered.


Version 1.11. Tagged as 'RemPrnSpt-1_11'
@
text
@a825 3
            ip_address = r->r[1] ;
            strncpy (printer_name, (char *)(r->r[2]), 14) ;

d841 3
@


4.7
log
@  Update UpCall_claiming to return correct value to claim (J Byrne)
  Added support for capturing both interface and alternate values
Detail:

Admin:
 Tested at Castle


Version 1.10. Tagged as 'RemPrnSpt-1_10'
@
text
@d26 4
a29 1
#include "Global/services.h"
a30 1
#include "Module.h"
d34 1
d39 1
a39 2

#include "USB/USBDevFS.h"
a47 13
 * Used when we want to kill the module
 */

char module_name[] = "RemotePrinterSupport" ;

/*
 * Use to kill the messages module, and to check for
 * its presence
 */

char messagesmod_name[] = "RemotePrinterMessages" ;

/*
a109 6
 * A copy of the private word
 */

void *private_word_pointer ;

/*
d114 1
a114 1
char unique_address[11] ;
d122 1
a122 1
int ip_address ;
d128 1
a128 1
int poll_word = 0 ;
d134 1
a134 1
struct _Event event ;
d141 1
a141 1
int old_printer_type = -1 ;
d147 1
a147 1
int rps_enabled = FALSE ;
d153 1
a153 1
int do_rename = FALSE ;
d160 1
a160 1
int printers_started = FALSE ;
d185 1
a185 1
int trap_upcalls = FALSE ;
d191 1
a191 20
int filetype ;

/***********************************************************************\
**                                                                     **
** Forward decls                                                       **
**                                                                     **
\***********************************************************************/

/*
 * Needed for passing to OS_Claim, sits on UpCallV
 */

extern int rps_entry (_kernel_swi_regs *r, void *pw) ;

/*
 * For OS_AddCallBack, to do file renaming after an UpCall
 */

extern int rename_entry (_kernel_swi_regs *r, void *pw) ;

d203 1
a203 1
void rps_modfinal (void)
a204 1
#ifdef Messages
d206 5
a212 2
    msgs_closefile (map_handle) ;

d215 1
a215 1
    r.r[2] = (int) private_word_pointer ;
d220 5
d231 1
a231 1
_kernel_oserror *rps_modinit (char *cmd_fail, int podule_base, void *pw)
d233 1
a233 2
    private_word_pointer = pw ;

d235 1
a235 2
     * Check that our messages module is loaded.
     * Die if not
d237 2
a238 5
#ifdef Messages
#ifdef Disc
    r.r[0] = 18 ;
    r.r[1] = (int) messagesmod_name ;
    if ((e = _kernel_swi (OS_Module, &r, &r)) != NULL)
a240 1
#endif
d244 2
a245 4
#ifdef Messages
    if ((e = msgs_openfile (msgs_handle, MESSAGES_FILE)) != NULL)
        return (e) ;
#endif
d251 1
a251 1
        return (e) ;
d266 1
a266 7
    {
        msgs_closefile (msgs_handle) ;
        msgs_closefile (map_handle) ;
        return (e) ;
    }

    atexit (rps_modfinal) ;
d271 15
a285 1
    return ((_kernel_oserror *) 0) ;
d288 1
a288 1
void write_information_file (int ip_address, char *unique_address, int job_no)
d362 3
d372 1
a372 1
_kernel_oserror *add_to_queue (int type, char *string_object)
d395 1
a395 1
_kernel_oserror *add_usb_to_queue (int type, usb_object *object)
d421 1
a421 1
int is_it_a_USB_printer (USBServiceCall *service)
d494 1
a494 1
usb_object_list *swi_enumerate_USB_printers (int flags)
d523 3
d706 8
d746 2
a762 1
    char *s ;
d943 1
a943 4

            err.errnum = 1 ;
            strcpy (err.errmess, (s = msgs_lookup (msgs_handle, "BadSWI", 1, module_name))) ;
            return (&err) ;
d946 2
@


4.6
log
@Moved test of DEADDEAD out of service call handler into somewhere where
it actually has effect.

Version 1.09. Tagged as 'RemPrnSpt-1_09'
@
text
@d103 2
d481 1
d488 1
d575 1
a575 1
                  return 1; /* CLAIM! */
d753 1
a753 1
            if (lr->r[0] == Service_USBDriver_Attach)
@


4.5
log
@Added test that r2 <> DEADDEAD which was causing some bum messages to
be passed to printer manager.
Belt and braces installed,tested briefly.

Version 1.08. Tagged as 'RemPrnSpt-1_08'
@
text
@d709 1
a709 1
            if ((lr->r[3] == 0) || (lr->r[2] == 0xDEADDEADu))
@


4.4
log
@Addition of RemotePrinterSupport_EnumerateUSBPrinters SWI.
Also now looks for USB devices appearing and disappearing and adds them
to the event list passed to printer manager.
When a new USB printer is plugged in an attempt will be made to find it
in the messages file pointed to by "PrintDefs$Dir.USBMap" to work out
which PDF is needed.When no match is made this is passed to !Printers
anyway incase it wants to ask the user to choose one themselves.
Also #if'd out the whole of the debug file when not doing debug versions
which makes it smaller and removes some,ahem,text strings!

Version 1.07. Tagged as 'RemPrnSpt-1_07'
@
text
@d709 1
a709 1
            if (lr->r[3] == 0)
@


4.3
log
@Having fixed the media not present code in the last version,this now makes
use of the fix to avoid an error trying to canonicalise a path on a non
existant shared printer.
Fix from Dan Ellis.

Version 1.06. Tagged as 'RemPrnSpt-1_06'
@
text
@d26 2
d37 2
d52 1
a52 1
 * Use to kill the messages module, and th check for
d76 1
a76 1
/*
d83 35
a117 1

d177 2
a178 2
/*
 * Global set of registers to use.
d183 1
a183 1

d202 1
a202 1
/*
d218 1
a218 1
extern int rps_entry (_kernel_swi_regs *r, void *pw) ;
d240 1
a240 1
    msgs_closefile () ;
d243 2
d278 1
a278 1
    if ((e = msgs_openfile (MESSAGES_FILE)) != NULL)
d281 7
a290 1

d302 2
a303 1
        msgs_closefile () ;
d309 2
a310 2
debug debug_start () ;
debug dprintf ("rps: Initialising\n\r") ;
d330 2
a331 2

debug dprintf ("Failed, deleting %s\n\r", tmp) ;
d344 1
a344 1
    fprintf (f, "%s%c%s%c%s%c%s\n", printer_name, 0, unique_address, 0, msgs_lookup ("UNKN", 0), 0, msgs_lookup ("UNKN", 0)) ;
d346 1
a346 1
    debug dprintf ("Succeeded, writing %s %s %s\n\r", printer_name, unique_address, msgs_lookup ("UNKN", 0)) ;
a350 1

d367 1
a367 1
debug dprintf ("Rename from %s to %s\n\r", printer_type, tmp) ;
d376 1
a376 1
debug dprintf ("Error is %d %s\n\r", (int *) e, (char *)e+4) ;
d396 1
a396 1
_kernel_oserror *add_to_queue (int type, char *object)
d398 4
a401 3
        event.type   = type ;
        event.object = (char *) malloc (strlen (object) + 1) ;
        strcpy (event.object, object) ;
d403 1
a403 1
debug dprintf ("About to add to queue\n\r") ;
d408 1
a408 1
debug dprintf ("Added to queue\n\r") ;
d416 134
d559 1
a559 1
    /*
d563 1
a563 1
    switch (lr->r[0])
d569 4
a572 4
                {
                lr->r[0] = -1;
                return (1) ; /* CLAIM! */
                }
d584 1
a584 1
                debug dprintf ("Wimp Scrap path = %s\n\r", wscrap) ;
d606 1
a606 1
                            debug dprintf ("About to add file renamed to queue\n\r") ;
d633 1
a633 1
debug dprintf ("printer: is about to be closed\n\r") ;
d646 1
a646 1
debug dprintf ("Adding printer closed event to the queue\n\r") ;
d658 1
a658 1
debug dprintf ("UpCall_Freeway received object type %d reason %d object %s\n\r",
d691 1
a691 1

d700 27
d728 1
d731 1
a731 3

debug dprintf ("Service_FreewayTerminating received\n\r") ;

d733 1
a733 1

d735 1
d738 16
a753 3

debug dprintf ("Service_FreewayStarting received\n\r") ;

d755 1
d765 3
d785 2
a786 3

debug dprintf ("rps_swi: Just done queue_read, ev r = %d, obj = %d\n\r", ev->type, ev->object) ;
debug dprintf ("rps_swi: Registers are r0 %d r1 %d r2 %d\n\r", r->r[0], r->r[1], r->r[2]) ;
d789 1
a789 1
                return (e) ;
d793 1
a793 1
debug dprintf ("rps_swi: Empty event queue - returning all -1\n\r") ;
d802 1
a802 1
debug dprintf ("rps_swi: asked to return buffer size, %d\n\r", strlen (ev->object) + 1) ;
d804 1
a804 1
                r->r[2] = strlen (ev->object) + 1 ;
d808 1
a808 1
debug dprintf ("rps_swi: returning real data into buffer, r %d b %d l %d\n\r", ev->type, r->r[1], r->r[2]) ;
d811 4
a814 1
                  strncpy ((char *)(r->r[1]), ev->object, r->r[2]) ;
d845 1
a845 1
            }
d847 1
a847 1
            if (r->r[0] & 2) /* Printers has started & is ready for messages */
d849 1
a849 1
debug dprintf ("Setting printers started flag") ;
d854 1
a854 1
debug dprintf ("Setting up printer:\n\r") ;
d856 1
a856 1
            /*
d870 1
a870 1
              sprintf (printer_type, "Share::_S%x.RemSpool.%s.Rspool",
d907 1
a907 1
debug dprintf ("Reverting to old printer:\n\r") ;
d909 1
a909 1
            rps_enabled = FALSE ;
d936 13
d955 2
a956 2
            strcpy (err.errmess, (s = msgs_lookup ("BadSWI", 1, module_name))) ;
            return (&err) ;
@


4.2
log
@Two bug fixes from D.Ellis
 Upcall_MediaNotPresent was not being claimed properly so if a machine
 with a shared printer on was switched off all the other machines would
 complain that Share::_Sxxxx was not available (ie.the shared spool file)
 A signed cast of a string point was stopping shared printing to file
 and hence shared USB printing
Tiny tweak to remove two warnings while we're at it.

Version 1.05. Tagged as 'RemPrnSpt-1_05'
@
text
@d434 1
d444 2
d447 1
@


4.1
log
@Initial revision
@
text
@d388 4
a391 1
                  return (-1) ; /* CLAIM! */
d416 1
a416 1
                    if ((int) s > 1)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

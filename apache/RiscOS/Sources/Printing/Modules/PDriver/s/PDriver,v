head	4.12;
access;
symbols
	PDriver-3_40:4.12
	PDriver-3_39:4.11
	RO_5_07:4.11
	PDriver-3_38:4.11
	PDriver-3_37:4.10
	PDriver-3_36:4.10
	PDriver-3_35:4.10
	PDriver-3_34:4.9
	kbracey_32bit_merge:4.8.2.1
	PDriver-3_33-4_7_2_1:4.8.2.1
	kbracey_32bit:4.8.0.2
	kbracey_32bit_bp:4.8
	PDriver-3_33:4.8
	PDriver-3_32:4.7
	PDriver-3_31:4.6
	dellis_autobuild_BaseSW:4.5
	PDriver-3_30:4.5
	sbrodie_sedwards_16Mar2000:4.4
	dcotton_autobuild_BaseSW:4.10
	PDriver-3_29:4.4
	Ursula_merge:4.1.7.5.2.1
	nturton_PDriver-3_27:4.1.7.5
	dcotton_pdriver_MPTInitialBuild:4.1.7.5
	PDriver-3_28:4.1.7.5.2.1.2.1
	sbrodie_PDriver_trunk_251198:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.5.2.1
	Ursula_RiscPC:4.1.7.5.2.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.1.7.5.2.1
	UrsulaBuild_FinalSoftload:4.1.7.5.2.1
	rthornb_UrsulaBuild-12Aug1998:4.1.7.5.2.1
	aglover_UrsulaBuild-05Aug1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-29Jul1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-22Jul1998:4.1.7.5.2.1
	hsimons_BOCA-1_2-Release:4.1.7.5
	rthornb_UrsulaBuild-15Jul1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-07Jul1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-17Jun1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-03Jun1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-27May1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-21May1998:4.1.7.5.2.1
	rthornb_UrsulaBuild_01May1998:4.1.7.5.2.1
	afrost_NC2_Generic:4.1.7.5
	afrost_Funai01-33:4.1.7.5
	Ursula:4.1.7.5.0.2
	Ursula_bp:4.1.7.5
	Ursula_31Mar1998:4.2
	Spinner_RCA116:4.1.7.5
	Spinner_B20_2:4.1.7.4
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.4
	Spinner_B17:4.1.7.4
	Spinner_B15:4.1.7.4
	Spinner_B14:4.1.7.4
	Spinner_B13:4.1.7.4
	Spinner_B12:4.1.7.4
	Spin_merge_28May97:4.1.7.4
	Spinner_B10:4.1.7.4
	Spin_merge_16May97:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.5
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.12
date	2016.04.08.21.03.53;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	4VmvwulPX52xNR1z;

4.11
date	2004.08.12.15.42.12;	author jballance;	state Exp;
branches;
next	4.10;

4.10
date	2001.03.29.13.09.50;	author dellis;	state Exp;
branches;
next	4.9;

4.9
date	2001.01.10.10.21.55;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	2000.12.15.10.16.15;	author sbrodie;	state Exp;
branches
	4.8.2.1;
next	4.7;

4.7
date	2000.12.07.12.36.38;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2000.10.19.15.08.18;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.06.09.13.35.18;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	99.08.16.11.53.37;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.08.16.11.45.07;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.16.11.35.12;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.48.48;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.8.2.1
date	2000.12.15.10.19.54;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.48.48;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.06.58;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.28.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.32.04;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.04.30.17.46.20;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.05.01.10.44.00;	author nturton;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.05.14.09.38.18;	author jcoxhead;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.08.19.14.09.27;	author arodger;	state Exp;
branches
	4.1.7.5.2.1;
next	;

4.1.7.5.2.1
date	98.04.07.17.01.26;	author arodger;	state Exp;
branches
	4.1.7.5.2.1.2.1;
next	4.1.7.5.2.2;

4.1.7.5.2.2
date	99.08.16.11.51.16;	author kbracey;	state Exp;
branches;
next	;

4.1.7.5.2.1.2.1
date	98.11.25.13.38.21;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Makefile recreated from fragments
Use {TRUE} and {FALSE}, Push/Pull, Unix style file names, and $MergedMsgs for the source of the resources when built standalone.

Version 3.40. Tagged as 'PDriver-3_40'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > PDriver

; ********************
; *** CHANGES LIST ***
; ********************

; 23-Jul-90 0.00 GJS Created concept of PDriver sharer module.
; 24-Jul-90      GJS Created first sources.
; 13-Aug-90 3.00 GJS So good it deserves 3.00 status.
; 18-Sep-90 3.01 GJS Bug fix: Abort job (error returned accidentally)
; 14-Jan-91      OSS Added word "sharer" to help text.
; 13-Feb-91 3.05 OSS Added PDriver_DeclareFont.
; 04-Apr-91 3.06 OSS Internationalised, some minor bug fixes.
; 19-Apr-91 3.08 OSS Fixed some internationalisation bugs.
; 06-May-91      DDV Sorted out sources reformatting as required.
; 06-May-91      DDV Added better errors for declaring printers.
; 06-May-91      DDV Check for no pending jobs when killing module.
; 06-May-91      DDV Sorted out registering of the device on a callback rather than service call.
; 06-May-91      DDV Inserted a new SWI PDriver_RemovePrinter.
; 07-May-91      DDV New internationalisation code.
; 08-May-91      DDV Added returning of previous printer in R0.
; 08-May-91 3.09 DDV Bug fix: ClearJob called wrong routine to abandon call the device.
; 09-May-91      DDV PDriver_<foo>ForPrinter now take parameters in r8 not r7.
; 16-May-91      DDV Bug fix: -1 on SelectDriver does not corrupt selected device.
; 16-May-91 3.10 DDV Bug fix: r8 not being used on one of the pass through calls.
; 24-May-91 3.11 DDV Added PDriver_MiscOp and MiscOpForDriver.
; 28-May-91 3.12 DDV Fixed the broken Deregistering of PDriver modules.
; 13-Jun-91      DDV PDriver_<foo>ForDriver SWIs removed and changed some names.
; 13-Jun-91 3.13 DDV Introduced PDriver_MiscOpForDriver.
; 15-Jun-91 3.14 DDV Decided did not like 13 as a version number so upped it a bit.
; 27-Jun-91 3.15 DDV Added PDumper_SetDriver SWI.
; 22-Jul-91 3.16 DDV Added Service_PDriverChanged.
; -------------------------------- RISC OS 3.00 release version ---------------------------
; 10-Dec-91 3.17 SMC Shortened message tokens
; 30-Mar-92 3.18 DDV Bug fix: Select job failing to report the correct error.
; 13-Oct-93 3.19 NK  Added standalone flag so that it can install its messages- This is
;                    necessary on Medusa platforms as PDrivers directory is not in ROM.
; -------------------------------- RISC OS 3.50 release version ---------------------------
; 12-Sep-94      AMcC Look for Messages file in Locale directory
; 13-Sep-94 3.21 MJS changes for JPEG plot support
; 30-Sep-94 3.23 MJS change in hdr.PDriver; step version up to agree with SrcFiler
; 09-Jan-95 3.24 MJS fix PDriver_EnumerateDrivers (MED-04281)
; 20-Feb-95 3.25 MJS fix R9 corruption in several places
; 07-May-97 3.26 JRC Added InUse and NoEsc error tokens.
; 13-Aug-97 3.27 AR  Added Command SWI
; 12-May-04      JWB Compile with objasm

                GET     hdr:ListOpts
                GET     hdr:Macros
                GET     hdr:System
                GET     hdr:Services
                GET     hdr:FSNumbers
                GET     hdr:ModHand
                GET     hdr:NewErrors
                GET     hdr:MsgTrans
                GET     hdr:Proc
                GET     hdr:HostFS
                GET     hdr:NDRDebug
                GET     hdr:DDVMacros
                GET     hdr:ResourceFS

                GET     VersionASM

                GBLL    debug
                GBLL    hostvdu
                GBLS    PrivMessages
 [ :LNOT: :DEF: standalone
                GBLL    standalone
standalone      SETL    {FALSE}
 ]

debug           SETL    {FALSE}
hostvdu         SETL    {FALSE}
PrivMessages    SETS    ""                      ; no private messages
debug_file	SETS	"<PDrvDebug>"

ChangeJob       SETD    {FALSE}                 ; job selection/creation.
ClearJob        SETD    {FALSE}                 ; clearing of job handles
CurrentJob      SETD    {FALSE}                 ; returning the current job handle
Enumerate       SETD    {FALSE}                 ; enumerating the current jobs
PassToDriver    SETD    {FALSE}                 ; pass to the specified driver
PassToJobR0     SETD    {FALSE}                 ; passing to job in r0
Reset           SETD    {FALSE}                 ; reseting the job list
DeclareDriver   SETD    {FALSE}                 ; declaring the printer
RemoveDriver    SETD    {FALSE}                 ; remove printer
SelectDriver    SETD    {FALSE}                 ; selecting a device
ToCurrent       SETD    {TRUE}                  ; redirect to current job
SWI             SETD    {FALSE}                 ; decoding of SWIs within the system
xx              SETD    {FALSE}                 ; misc stuff
fnt             SETD    {TRUE}                  ; FontSWI
calljobR10      SETD    {FALSE}                 ; call job with handle in R10
calldriverR10   SETD    {TRUE}                  ; calling driver with handle in R10

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                        ^ 0
next_printer            # 4                     ; -> next block in list, =0 if none
branch_code             # 4                     ; -> branch routine
private_word            # 4                     ;  = private word
printer_number          # 4                     ;  = prrinter number
printer_end             * :INDEX: @@

                        ^ 0, wp
SharedMessages          # 4                     ; -> shared block
MessagesOpen            # 4                     ;  = messages file open word
MessagesBlock           # 16                    ;  = messages block

printer_list            # 4                     ; -> head of printer list
current_job             # 4                     ;  = current job handle
current_printer         # 4                     ;  = current printer
job_descriptions        # 4*256                 ;  = one word pointer for each of the 256 job handle
old_job                 # 4                     ;  = previously selected job
flags                   # 4                     ;  = global flags word
error_buffer		# 256

workspace_end           * :INDEX: @@

f_CallBackPending       * 1:SHL:0               ; set => callback pending should be removed.

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Module header.
;
                AREA    |PDriver$$code|, CODE, READONLY

module_start    & 0
                & Initialisation -module_start                  ; init code
                & Finalisation -module_start                    ; finalisation
                & Service -module_start                         ; service code

                & Title -module_start                           ; title string offset
                & Help -module_start                            ; help string offset
                & 0

                & PrintSWI * Module_SWIChunkSize + Module_SWIApplicationBase
                & SWIHandler -module_start                      ; handler for SWIs
                & SWITable -module_start                        ; SWI decoding table
                & 0
  [ :LNOT: No32bitCode
                & 0
                & Flags -module_start
  ]

Help            = "Printer sharer", 9, "$Module_HelpVersion"
              [ debug
                = " Development version"
              ]
                = 0
                ALIGN

  [ :LNOT: No32bitCode
Flags           DCD ModuleFlag_32bit
  ]

Title
SWITable        = "PDriver", 0
                = "Info", 0
                = "SetInfo", 0
                = "CheckFeatures", 0
                = "PageSize", 0
                = "SetPageSize", 0
                = "SelectJob", 0
                = "CurrentJob", 0
                = "FontSWI", 0
                = "EndJob", 0
                = "AbortJob", 0
                = "Reset", 0
                = "GiveRectangle", 0
                = "DrawPage", 0
                = "GetRectangle", 0
                = "CancelJob", 0
                = "ScreenDump", 0
                = "EnumerateJobs", 0
                = "SetPrinter", 0
                = "CancelJobWithError", 0
                = "SelectIllustration", 0
                = "InsertIllustration", 0
                = "DeclareFont", 0
                = "DeclareDriver", 0
                = "RemoveDriver", 0
                = "SelectDriver", 0
                = "EnumerateDrivers", 0
                = "MiscOp", 0
                = "MiscOpForDriver", 0
                = "SetDriver", 0
                = "JPEGSWI", 0
                = "Command", 0
                = 0
                ALIGN

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle the despatch of SWIs within the module.

SWIHandler      ROUT

                LDR     wp, [wp]                                ; -> workspace

                Debug	ToCurrent, "PDriver SWI", r11, lr

                CMP     r11, #(%90 -%80)/4
                ADDCC   pc, pc, r11, LSL #2
                B       %90
80
                B       PassToDriver                            ; PDriver_Info
                B       PassToDriver                            ; PDriver_SetInfo
                B       PassToDriver                            ; PDriver_CheckFeatures
                B       PassToDriver                            ; PDriver_PageSize
                B       PassToDriver                            ; PDriver_SetPageSize
                B       ChangeJob                               ; PDriver_SelectJob
                B       CurrentJob                              ; PDriver_CurrentJob
                B       PassToCurrent                           ; PDriver_FontSWI
                B       ClearJob                                ; PDriver_EndJob
                B       ClearJob                                ; PDriver_AbortJob
                B       Reset                                   ; PDriver_Reset
                B       PassToCurrent                           ; PDriver_GiveRectangle
                B       PassToCurrent                           ; PDriver_DrawPage
                B       PassToCurrent                           ; PDriver_GetRectangle
                B       PassToR0Job                             ; PDriver_CancelJob
                B       PassToDriver                            ; PDriver_ScreenDump
                B       EnumerateJobs                           ; PDriver_EnumerateJobs
                B       PassToDriver                            ; PDriver_SetPrinter
                B       PassToR0Job                             ; PDriver_CancelJobWithError
                B       ChangeJob                               ; PDriver_SelectIllustration
                B       PassToCurrent                           ; PDriver_InsertIllustration
                B       PassToCurrent                           ; PDriver_DeclareFont
                B       DeclareDriver                           ; PDriver_DeclareDriver
                B       RemoveDriver                            ; PDriver_RemoveDriver
                B       SelectDriver                            ; PDriver_SelectDriver
                B       EnumDrivers                             ; PDriver_EnumerateDrivers
                B       MiscOp                                  ; PDriver_MiscOp
                B       MiscOpForDriver                         ; PDriver_MiscOpForDriver
                B       PassToDriver                            ; PDriver_SetDriver
                B       PassToCurrent                           ; PDriver_JPEGSWI
                B	PassToDriver				; PDriver_Command
90
                ADR     r0, ErrorBlock_ModuleBadSWI
                ADDR    r1, Title                               ; -> module title
                B       LookupError                             ; -> r0 -> error block, V set

                MakeErrorBlock ModuleBadSWI

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle claiming of workspace and other stuff.
;

Initialisation  ROUT

                Push    "lr"

                LDR     r2, [wp]
                TEQ     r2, #0                                  ; do we already have workspace
                BNE     %10

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =workspace_end                      ; amount required
                SWI     XOS_Module
                Pull    "pc", VS                                ; return it it went wrong

                STR     r2, [wp]
10
                MOV     wp, r2                                  ; -> workspace

                MOV     r0, #0
                LDR     r1, =workspace_end/4                    ; amount of workspace to zap
20
                STR     r0, [r2], #4
                SUBS    r1, r1, #1
                BNE     %20                                     ; loop until its all done

                ADR     r0, callback
                MOV     r1, wp                                  ; -> workspace
                SWI     XOS_AddCallBack
                LDRVC   r0, flags
                ORRVC   r0, r0, #f_CallBackPending
                STRVC   r0, flags                               ; mark as a callback is pending

        [ standalone
; NK, 13-10-93 PDriver now installs its messages file
; SB, 25-11-98 Only if V clear - otherwise module disappears and takes registered block with it!
        ADRVCL  R0,resourcefsfiles
        SWIVC   XResourceFS_RegisterFiles   ; ignore errors
        ]

                Pull    "pc"                                    ; return should all be OK

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle the callback code, this is called we then issue a Service call
; to allow all pdriver modules to register.
;

callback        ROUT

                Push    "r1, lr"

                LDR     r1, flags
                BIC     r1, r1, #f_CallBackPending
                STR     r1, flags                               ; mark as no call back anymore

                MOV     r1, #Service_PDriverStarting
                SWI     XOS_ServiceCall                         ; declare yourself now modules...

                Pull    "r1, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Finalisation.
;

Finalisation    ROUT

                Push    "r1-r3, lr"

                LDR     wp, [wp]                                ; -> workspace

                LDR     r2, flags
                TST     r2, #f_CallBackPending                  ; is a callback pending?
                BEQ     %10                                     ; no...

                ADR     r0, callback
                MOV     r1, wp
                SWI     XOS_RemoveCallBack                      ; attempt to remove it
                Pull    "r1-r3, pc", VS

                BIC     r2, r2, #f_CallBackPending
                STR     r2, flags                               ; and then mark as removed
10
                ADR     r0, job_descriptions                    ; -> jobs descriptions list
                MOV     r1, #256
15
                LDR     r2, [r0], #4
                TEQ     r2, #0                                  ; is the job record empty?
                BNE     %90

                SUBS    r1, r1, #1
                BNE     %15                                     ; loop back until all checked

                BL      CloseMessages                           ; tidy up the messages files

        [ standalone
; free up resource fs
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles   ; ignore errors
        CLRV                                  ; clear V
        ]

                CLRV
                Pull    "r1-r3, pc"
90
                ADR     r0, ErrorBlock_PrintInUse
                BL      LookupSingle                            ; expand error message
                Pull    "r1-r3, pc"                             ; return with r0 and v intact.

                MakeInternatErrorBlock PrintInUse,,PDrUsed

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Service code handling.
;
	ASSERT	Service_ResourceFSStarting < Service_PDriverGetMessages

serviceentry_ServTab
	DCD	0
        DCD     Service_FastEntry - module_start
	[ standalone
	DCD	Service_ResourceFSStarting
	]
 	DCD	Service_PDriverGetMessages         ; finding messages block?
	DCD	0
        DCD     serviceentry_ServTab - module_start  ;anchor for table

Service         ROUT
	MOV	R0, R0
Service_FastEntry
        TEQ     r1, #Service_PDriverGetMessages         ; finding messages block?
        LDREQ   wp, [wp]
        BEQ     ServiceMessages

        [ standalone
; NK resource handling
        TEQ     R1,#Service_ResourceFSStarting
        MOVNE   PC,LR
        Push    "R0, LR"
        ADRL    R0, resourcefsfiles ; R0 -> ResourceFS file structure
        MOV     LR, PC          ; LR -> return address
        MOV     PC, R2          ; call ResourceFS routine
        Pull    "R0, PC"
        ]


                MOV    pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ChangeJob (SelectJob, SelectIllustration)
;
; in:   r0   = new job handle
;       r1   = job title
;       r11  = size number of SWI to call in printers code.
;
; bit bit 5 or r11 set then:-
;       r8   = printer driver number
;
; else:-
;       use current
;
; out:  -
;
; This code is called when the job is about to be changed, ie. on a SelectJob
; or SelectIllustration.
;

ChangeJob       ROUT

                Debuga  ChangeJob, "change job in:", r0,r1,r2,r3,r4,r5
                Debug   ChangeJob, "",r6,r7,r8,r9

                CMP     r0, #255                                ; is the handle valid?
                BLS     %00                                     ; yes...

                ADDR    r0, ErrorBlock_PrintNoSuchJob
                B       LookupSingle                            ; return an error
00
                Push    "r1-r5, lr"

                ADR     r3, job_descriptions                    ; -> descriptions list
                LDR     r2, current_job
                STR     r2, old_job                             ; store old job handle

                Debug   ChangeJob, "pointer to job records", r3
                Debug   ChangeJob, "current job is", r2

                TEQ     r0, #0                                  ; selecting a new job?
                BNE     %10
                TEQ     r2, #0                                  ; are we changing from no job to no job?
                BEQ     %50                                     ; return correctly

                LDR     r2, [r3, r2, LSL #2]                    ; get printer handle of job
                B       %40
10
                LDR     r2, [r3, r0, LSL #2]
                TEQ     r2, #0                                  ; does the job have a printer?
                BNE     %30

                LDR     r2, current_printer                     ; get current device
                TEQ     r2, #0                                  ; is there one?
                BEQ     nocurrentdriver
25
                Debug   ChangeJob, "driver to be used", r2

                STR     r2, [r3, r0, LSL #2]                    ; store the printer number
30
                Debug   ChangeJob, "record setup to select printer"

                LDR     r4, current_job
                TEQ     r4, #0                                  ; is there a current job?
                BEQ     %40

                LDR     r5, [r3, r4, LSL #2]
                CMP     r2, r5                                  ; do we need to deselect the current one?
                BEQ     %40

                Debug   ChangeJob, "deselecting old job!"

                MOV     r4, r0

                Push    "r2, r4, r11, wp"
                MOV     r10, r5
                MOV     r0, #0                                  ; no current job
                AND     r11, r11, #31                           ; mask out unwanted bits
                BL      calldriverR10
                Pull    "r2, r4, r11, wp"                       ; preserve them
                BVS     %60

                MOV     r0, r4
40
                Debug   ChangeJob, "selecting new job, handle is", r0

                STR     r0, current_job
                MOV     r10, r2

                Debug   ChangeJob, "new driver handle", r2

                Push    "r2, r10-r11, wp"
                AND     r11, r11, #31
                BL      calldriverR10                           ; call driver in R10
                Pull    "r2, r10-r11, wp"
                DebugE
                BVC     %50

                Debug   ChangeJob, "selecting new job went wrong!"
                DebugE  ChangeJob, "error return is"

                SavePSR lr
                Push    "r0, wp, lr"
                LDR     r2, current_job
                ADR     r3, job_descriptions
                MOV     r0, #0
                STR     r0, [r3, r2, LSL #2]
                STR     r0, current_job                         ; no longer an active job
                BL      calldriverR10                           ; call driver and inform
                Pull    "r0, wp, lr"

                RestPSR lr,,f                                   ; restore the flags
                B       %60
50
                LDR     r0, old_job                             ; = old job handle
55
                Debug   ChangeJob, "previous job handle is", r0
60
                Pull    "r1-r5, lr"

                Debuga  ChangeJob, "exiting with", r0,r1,r2,r3,r4,r5
                Debug   ChangeJob, "",r6,r7,r8,r9
                DebugE  ChangeJob, "and an error: "

                MOVVS   pc, lr
                TEQ     pc, pc
                MOVNES  pc, lr
                MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ClearJob
;
; in:   r0   = handle.
;
; out:  -
;
; Handle the clearing of a job within the system, called on EndJob or
; AbortJob.
;

ClearJob        ROUT

                EntryS  "R0,WP"

                MOVS    R10, R0                                 ; copy to r10
                LDREQ   R10, current_job                        ; setup to current job if =0

                Debug   ClearJob, "clear job handle", r10

                BL      calljobR10                              ; call to pass onto the device
                DebugE  ClearJob, "oopsy doopsy it went wrong"

                STRVS   R0, [SP, #Proc_RegOffset]
                EXIT    VS                                      ; return if device went wrong

                Debug   ClearJob, "managed to call the device"

                ASSERT (Proc_RegOffset = 0) :LOR: (Proc_RegOffset = 4)
                [ Proc_RegOffset = 0
                LDMIA   SP,{R0, WP}                             ; get a nice copy from the stack
                |
                LDMIB   SP,{R0, WP}                             ; get a nice copy from the stack
                ]

                LDR     R10, current_job
                TEQ     R10, R0
                MOV     R10, #0
                STREQ   R10, current_job
                Push    "R9"
                ADR     R9, job_descriptions
                STR     R10, [R9, R0, LSL #2]
                Pull    "R9"

                EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: CurrentJob
;
; in:   -
;
; out:  r0   = job handle.
;
; Return the currently selected job.
;

CurrentJob      ROUT

                LDR     r0, current_job                         ; = job handle to be returned
                Debug   CurrentJob, "returning job handle", r0

                MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: EnumerateJobs
;
; in:   r0   = job handle to start searching for
;
; out:  r0   = next job handle / =0 if none
;
; Enumerate the current known about jobs within the sharing system.
;

EnumerateJobs   ROUT

                ADR     r10, job_descriptions                   ; -> head of descriptions list

                Debug   Enumerate, "enumerating from list at", r10
00
                ADD     r0, r0, #1
                CMP     r0, #256
                BGE     %10

                Debug   Enumerate, "does this handle exist?", r0

                Push    "r9"
                LDR     r9, [r10, r0, LSL #2]
                CMP     r9, #0                                  ; if there is a job then return home (clear V)
                Pull    "r9"
                MOVNE   pc, lr                                  ; return now

                Debug   Enumerate, "obviously not!"

                B       %00                                     ; loop back otherwise
10
                SUBS    r0, r0, r0                              ;  MOV     r0, #0 : CLRV
                MOV     pc, lr                                  ; no more jobs, r0 =0, V clear.

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: EnumerateDrivers
;
; in:   r0  = next printer / =0 if first
;
; out:  r0 updated to contain correct value / =0 if none
;       r1  = global printer type to be returned.
;
; This call allows you to enumerate all the printers within the system,
; scanning from the first (with r0 specified to be 0 on entry), until r0
; is returned to be zero.
;

EnumDrivers     ROUT

                TEQ     R0, #0                                  ; start from head of list?
                ADREQ   R0, printer_list                        ; yes, so -> start

                CMP     R0, #0                                  ; any more? (clear V)
                MOVEQ   R1, #-1
                LDRNE   R0, [R0, #next_printer]
                LDRNE   R1, [R0, #printer_number]               ; get printer number / =-1 if none

                MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: PassToDriver (Info, SetInfo, CheckFeatures, PageSize, SetPageSize,
;                     ScreenDump, SetPrinter).
;
; in:   r0   = job handle
;       r1.. = parameters for call
;       r11  = SWI number in printers code, bit 5 set => r8 => driver handle
;
; out:  -
;
; This code passes on the call to the specified printer driver or the currently
; active one.
;

PassToDriver    ROUT

                Debug   PassToDriver, "Pass to driver SWI number", r11

                LDR     r10, current_printer
                B       calldriverR10

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: PassToCurrent (FontSWI, GiveRectangle, DrawPage, GetRectangle,
;                      InsertIllustration, DeclareFont, JPEGSWI).
;
; in:   r0   = job handle
;       r1...  parameters
;       r11  = SWI number required
;
; out:  -
;
; Pass onto the current job record selected.
;

PassToCurrent   ROUT

		[	debug
		TEQ	r11, #7
		DebugIf	EQ, fnt, "PDriver_FontSWI", r8
		]

                Debug   ToCurrent, "PassToCurrentJob with handle of", r0
                Debug   ToCurrent, "PassToCurrentJob SWI number", r11
                Debug   ToCurrent, "PassToCurrentJob lr", lr

                LDR     r10, current_job                        ; -> current job
                B       calljobR10

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: PassToR0Job (CancelJob, CancelJobWithError)
;
; in:   r0   = job handle
;       r1...
;       r11  = number of the SWI to be called.
;
; out:  -
;
; This passes the event to the job specified in r10.
;

PassToR0Job     ROUT

                Debug   PassToJobR0, "PassToR0Job with handle of", r0
                Debug   PassToJobR0, "PassToR0Job SWI number", r11

                MOV     r10, r0
                B       calljobR10

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: Reset
;
; in:   -
;
; out:  -
;
; Reset all jobs within the system.
;

Reset           ROUT

                Push    "r1-r3, lr"

                Debug   Reset, "Resetting the job lists"

                LDR     r10, printer_list                       ; -> head of printer list
00
                TEQ     r10, #0                                 ; end of the list yet?
                BEQ     %20                                     ; yes, so clear the list

                MOV     r11, #&0A                               ; reset the device
                Push    "r10, wp"
                BL      calldriverR10                           ; call driver in r10
                Pull    "r10, wp"

                LDR     r10, [r10, #next_printer]               ; -> next printer
                B       %00
20
                MOV     r1, #0
                STR     r1, current_job                         ; no longer a current job

                ADR     r2, job_descriptions
                MOV     r3, #256                                ; reset all the job records
30
                STR     r1, [r2], #4
                SUBS    r3, r3, #1
                BNE     %30                                     ; loop back until all reset

                ; V will be clear
                Pull    "r1-r3, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: DeclareDriver
;
; in:   r0  -> branch code / =0 to remove a printer object.
;       r1   = WP for branch code
;       r2   = printer number (must be unique)
;
; out:  -
;
; Attempt to register a printer driver within the system, if r0 =0 then we remove it,
; all other registers must be setup correctly.
;
; Then we can allocate a block and store its vital statistics.
;

DeclareDriver  ROUT

                Push    "r1-r4, r9-r10, lr"

                Debug   DeclareDriver, "declaring with branch code at", r0
                Debug   DeclareDriver, "workspace for call", r1
                Debug   DeclareDriver, "unique printer id", r2

                ADR     r9, printer_list                        ; -> printer list
00
                LDR     r10, [r9, #next_printer]
                TEQ     r10, #0                                 ; is the next printer in the list?
                BEQ     %20

                LDR     r4, [r10, #printer_number]
                TEQ     r2, r4                                  ; does this printer exist?
                BEQ     %10

                MOV     r9, r10                                 ; advance the pointer
                B       %00                                     ; and loop again
10
                Debug   DeclareDriver, "Are we attempting to remove", r0

                TEQ     r0, #0                                  ; are we attempting undeclare a printer?
                BEQ     %50                                     ; yes, so don't give uniqueness error.

                Debug   DeclareDriver, "Oh fiddle sticks we are not"

                ADR     r0, ErrorBlock_PrintDuplicateNumber
                BL      LookupSingle
                B       %90                                     ; return a suitable error, r0 -> error block.
20
                Debug   DeclareDriver, "Make new record, pointer to last found", r9

                MOV     r10, r0
                MOV     r4, r2

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =printer_end                        ; amount of workspace needed
                SWI     XOS_Module
                BVS     %90                                     ; it didn't work so give up now

                STR     r2, [r9, #next_printer]                 ; store forwards link for previous record

                STR     r1, [r2, #private_word]
                STR     r4, [r2, #printer_number]
                STR     r10, [r2, #branch_code]
                MOV     r10, #0
                STR     r10, [r2, #next_printer]                ; setup the record to correspond to specified data

                B       %90                                     ; return accordingly.
50
                Debug   DeclareDriver, "Remove handle", r10

                LDR     r4, [r10, #next_printer]
                STR     r4, [r9, #next_printer]                 ; fix the chain

                LDR     r4, current_printer
                TEQ     r4, r10                                 ; is the current printer this one?
                Debug   DeclareDriver, "Same as current device", r4,r10

                MOVEQ   r4, #0
                STREQ   r4, current_printer                     ; yes, so deselect it

                MOV     r0, #ModHandReason_Free
                MOV     r2, r10
                SWI     XOS_Module                              ; release the memory block
90
                Pull    "r1-r4, r9-r10, pc", VS
                TEQ     pc, pc
                Pull    "r1-r4, r9-r10, pc", NE, ^              ; return clearing V (26-bit case)
                Pull    "r1-r4, r9-r10, pc"

                MakeInternatErrorBlock PrintDuplicateNumber,,DupNum

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: RemoveDriver
;
; in:   r0   = printer name.
;
; out:  -
;
; This code will remove a printer that has been registered using PDriver_DeclareDriver.
;

RemoveDriver    ROUT

                Debug   RemoveDriver, "remove printer of ID", r0

                MOV     r2, r0
                MOV     r1, #0
                MOV     r0, #0
                B       DeclareDriver                           ; attempt to remove

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: SelectDriver
;
; in:   r0  = driver number / =-1 to no active driver / =-2 to just read
;
; out:  r0  = previous driver
;
; This code will select the current printer device to be used, or return the
; number of the one currently selected.
;

SelectDriver    ROUT

                Push    "r1-r2, lr"

                LDR     r11, current_printer                    ; current printer
                CMP     r11, #0                                 ; is there one?
                MOVEQ   r11, #-1
                LDRNE   r11, [r11, #printer_number]

                TEQ     R0, R11                                 ; no change in device?
                BEQ     %20

                CMP     R0, #-1                                 ; is device to be unset?
                MOVEQ   R0, #0
                STREQ   R0, current_printer
                BLE     %20                                     ; yes, so no longer active and return

                LDR     r10, printer_list                       ; -> printer list
00
                TEQ     r10, #0
                BEQ     %10                                     ; select printer in r10

                LDR     r1, [r10, #printer_number]
                TEQ     r0, r1                                  ; the one we are looking for?
                MOVEQ   r0, r11
                BEQ     %10                                     ; yes, so select it

                LDR     r10, [r10, #next_printer]
                B       %00                                     ; loop back
10
                TEQ     r10, #0                                 ; did we match a device?
                BEQ     %15

                STR     r10, current_printer                    ; yes, so store new device number

                MOV     r1, #Service_PDriverChanged
                LDR     r2, [r10, #printer_number]
                SWI     XOS_ServiceCall                         ; broadcast to the outside world about the new driver
20
                MOVVC   r0, r11                                 ; previous device selected
                Pull    "r1-r2, pc", VS
                TEQ     pc, pc
                Pull    "r1-r2, pc", NE, ^
                Pull    "r1-r2, pc"
15
                ADR     r0, ErrorBlock_PrintUnknownNumber
                BL      LookupSingle                            ; otherwise give an error
                B       %20                                     ; jumping to the a suitable point to balance the stack

                MakeInternatErrorBlock PrintUnknownNumber,,BadPDNo

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; PDriver_MiscOp implementation
;
;   Entry: R0  = reason code (with bit 31 set => for specific device)
;          R1..R7 as required by call.
;
;          IF PDriver_MiscOpForPrinter then r8 =id of device to direct call at.
;
;   Exit:  V set, R0 -> error block.
;          V clear; as specified by call.
;
; MiscOp functions to be handled by printer driver, some are handled by
; the printer independent code and some are passed to the back end code.
;
; Two SWIs are supported by the PDriver module for this type of operation,
; one directs calls at the current device and the other at the one specified
; in R8.  If no device is specified then we must resolve the pointer by
; loading the current printer.  If a device is specified then we have to
; scan the list of printers and call the relevant one or generate an
; error if that one is not known.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ASSERT  next_printer =0

MiscOp  ROUT

        Push    "R10,LR"

        LDR     R10,current_printer     ;->Current printer job
        B       miscop_alt              ;Jump in because R10 already points to record

MiscOpForDriver ROUT

        Push    "R10,LR"

        ADR     R10,printer_list        ;Address the printer list correctly

miscop_finddevice
        LDR     R10,[R10,#next_printer]
        TEQ     R10,#0                  ;End of the list of devices yet?
        BEQ     miscop_devicenotfound

        LDR     LR,[R10,#printer_number]
        TEQ     LR,R8                   ;Is this the device we are looking for?
        BNE     miscop_finddevice       ;No so loop again until found

miscop_alt
        BL      calldriverR10
        Pull    "R10,PC"                ;Call device and then return (r0 and V carried through)

miscop_devicenotfound
        ADR     R0,ErrorBlock_PrintUnknownNumber
        Pull    "R10,LR"
        B       LookupSingle            ;Convert token to a suitable message




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: calljobR10
;
; in:   r0..  = parameters
;       r10   = job handle to pass calls to,  =0 then ignore
;       r11   = SWI number to pass through.
;
; out:  -
;
; Pass call to the job specified in r10.
;

calljobR10      ROUT

                Debug   calljobR10, "calljobR10, job handle", r10
                Debug   calljobR10, "calljobR10, swi number", r11

                TEQ     r10, #0
                CMPNE   r10, #256                               ; is handle within suitable range?
                BGE     %90                                     ; no, so bog off!

                Push    "r9"
                ADR     r9, job_descriptions
                LDR     r10, [r9, r10, LSL #2]
                Pull    "r9"
                TEQ     r10, #0                                 ; is there a printer associated with this job?
                BNE     calldriverR10                           ; yes, so call it
90
                ADR     r0, ErrorBlock_PrintNoSuchJob
                B       LookupSingle                            ; handle was duff!!!

                MakeInternatErrorBlock PrintNoSuchJob,,NoJob

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: calldriverR10
;
; in:   r0.. = parameters
;       r10  = driver to call, 0 ignore call.
;       r11  = SWI number
;
; out:  -
;
; Call the device specified in r10.
;

calldriverR10   ROUT

                Debug   calldriverR10, "calldriver handle", r10
                Debug   calldriverR10, "calldriver SWI number", r11
                Debug   calldriverR10, "calldriver lr", lr

                CMP     r10, #0                                 ; is there a current driver? (clears V)
                LDRNE   wp, [r10, #private_word]                ; -> workspace
                LDRNE   pc, [r10, #branch_code]                 ;    call the doofer
nocurrentdriver
                ADR     r0, ErrorBlock_PrintNoCurrentDriver
                B       LookupSingle                            ; give an error because no current driver

                MakeInternatErrorBlock PrintNoCurrentDriver,,NoDrive

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                LTORG

                GET     MsgCode.s

              [ debug
                InsertNDRDebugRoutines
              ]

        [ standalone
resourcefsfiles
        ResourceFile    $MergedMsgs, Resources.PDrivers.Messages
        DCD     0
        ]

                END
@


4.11
log
@  modified to build on Iyonix
Detail:

Admin:
  Tested at Castle


Version 3.38. Tagged as 'PDriver-3_38'
@
text
@d86 2
a87 2
debug           SETL    false
hostvdu         SETL    false
d91 16
a106 16
ChangeJob       SETD    false			; job selection/creation.
ClearJob        SETD    false                   ; clearing of job handles
CurrentJob      SETD    false                   ; returning the current job handle
Enumerate       SETD    false                   ; enumerating the current jobs
PassToDriver    SETD    false                   ; pass to the specified driver
PassToJobR0     SETD    false                   ; passing to job in r0
Reset           SETD    false                   ; reseting the job list
DeclareDriver   SETD    false                   ; declaring the printer
RemoveDriver    SETD    false                   ; remove printer
SelectDriver    SETD    false                   ; selecting a device
ToCurrent       SETD    true			; redirect to current job
SWI             SETD    false                   ; decoding of SWIs within the system
xx              SETD    false			; misc stuff
fnt		SETD	true			; FontSWI
calljobR10      SETD    false                   ; call job with handle in R10
calldriverR10   SETD    true			; calling driver with handle in R10
d143 1
a143 2
                AREA    |C$$code|, CODE, READONLY
;                LEADR   Module_LoadAddr
a162 4
  [ :LNOT: No32bitCode
Flags           DCD ModuleFlag_32bit
  ]

d169 5
d311 1
a311 1
; NK, 13-10-93 PDriver now installs its messgage file
d433 1
a433 1
        STMFD   SP!, {R0, LR}
d437 1
a437 1
        LDMFD   SP!, {R0, PC}
d1183 1
a1183 1
                GET     s.MsgCode
d1191 1
a1191 1
        ResourceFile    Resources.<Locale>.Messages,       Resources.PDrivers.Messages
@


4.10
log
@  Fixed standalone build

Detail:
  It was looking for <Locale>.Messages instead of
Resources.<Locale>.Messages. The directories UK and Germany are redundant and
have been removed.

Admin:
  Module tested on a RiscPC, files appear in resourcefs.

Version 3.35. Tagged as 'PDriver-3_35'
@
text
@d60 1
d143 2
a144 1
                LEADR   Module_LoadAddr
@


4.9
log
@  Merge of 32-bit branch.
Detail:
  This represents the current master version of this module now that
    32-bit printing has been tested.
Admin:
  This module has received some testing but not exhaustive testing.
  Projects taking this version should take care with this version.

Version 3.34. Tagged as 'PDriver-3_34'
@
text
@d1189 1
a1189 1
        ResourceFile    <Locale>.Messages,       Resources.PDrivers.Messages
@


4.8
log
@  Backed out 32-bit compatible version - it does not work yet.
Detail:
  32-bit version will re-appear on a branch from this version.
Admin:
  Retained BBE changes.
  Not tested.

Version 3.33. Tagged as 'PDriver-3_33'
@
text
@d157 8
d166 1
a166 4
Help            = "Printer sharer", 9, "$Module_MajorVersion ($Module_Date)"
              [ Module_MinorVersion <> ""
                = " $Module_MinorVersion"
              ]
d341 1
a341 1
                Pull    "r1, pc",,^
d390 2
a391 1
                Pull    "r1-r3, pc",,^
d430 1
a430 1
        MOVNES  PC,LR
d435 1
a435 1
        LDMFD   SP!, {R0, PC}^
d439 1
a439 1
                MOVS    pc, lr
d547 2
a548 1
                Push    "r0, wp, pc"
d557 1
a557 1
                TEQP    lr, #0                                  ; restore the flags
d570 4
a573 2
                ORRVS   pc, lr, #V_bit
                MOVS    pc, lr                                  ; return, setup V if required.
d594 1
a594 1
                Push    "R0, WP, LR"
d604 2
a605 2
                ADDVS   SP, SP, #4
                Pull    "WP, PC", VS                            ; return if device went wrong
d609 2
d612 3
d625 1
a625 1
                Pull    "R0, WP, PC",,^
d648 1
a648 1
                MOVS    pc, lr
d680 1
a680 1
                TEQ     r9, #0                                  ; if there is a job then return home
d682 1
a682 1
                MOVNES  pc, lr                                  ; return now
d688 2
a689 2
                MOV     r0, #0
                BICS    pc, lr, #V_bit                          ; no more jobs, r0 =0, V clear.
d715 1
a715 1
                TEQ     R0, #0                                  ; any more?
d720 1
a720 1
                MOVS    pc, lr
d853 2
a854 1
                Pull    "r1-r3, pc",,^
d945 4
a948 3
                Pull    "r1-r4, r9-r10, lr"
                ORRVS   lr, lr, #V_bit
                MOVS    pc, lr                                  ; return setting V if needed.
d1034 4
a1037 3
                Pull    "r1-r2, lr"
                ORRVS   lr, lr, #V_bit                          ; ensure that the v bit copied across correctly
                MOVS    pc, lr
a1163 2
                CLRV

d1168 1
a1168 1
                TEQ     r10, #0                                 ; is there a current driver?
@


4.8.2.1
log
@  Re-import of 32-bit compatible version onto branch.
Detail:
  This version is version 3.29 + 32-bit changes + BBE changes.
  The branch point (version 3.33) is 3.20 + BBE changes.
Admin:
  Not tested - 32-bit work can continue is isolation.

Version 3.33, 4.7.2.1. Tagged as 'PDriver-3_33-4_7_2_1'
@
text
@a156 8
  [ :LNOT: No32bitCode
                & 0
                & Flags -module_start
  ]

  [ :LNOT: No32bitCode
Flags           DCD ModuleFlag_32bit
  ]
d158 4
a161 1
Help            = "Printer sharer", 9, "$Module_HelpVersion"
d336 1
a336 1
                Pull    "r1, pc"
d385 1
a385 2
                CLRV
                Pull    "r1-r3, pc"
d424 1
a424 1
        MOVNE   PC,LR
d429 1
a429 1
        LDMFD   SP!, {R0, PC}
d433 1
a433 1
                MOV    pc, lr
d541 1
a541 2
                SavePSR lr
                Push    "r0, wp, lr"
d550 1
a550 1
                RestPSR lr,,f                                   ; restore the flags
d563 2
a564 4
                MOVVS   pc, lr
                TEQ     pc, pc
                MOVNES  pc, lr
                MOV     pc, lr
d585 1
a585 1
                EntryS  "R0,WP"
d595 2
a596 2
                STRVS   R0, [SP, #Proc_RegOffset]
                EXIT    VS                                      ; return if device went wrong
a599 2
                ASSERT (Proc_RegOffset = 0) :LOR: (Proc_RegOffset = 4)
                [ Proc_RegOffset = 0
a600 3
                |
                LDMIB   SP,{R0, WP}                             ; get a nice copy from the stack
                ]
d611 1
a611 1
                EXITS
d634 1
a634 1
                MOV     pc, lr
d666 1
a666 1
                CMP     r9, #0                                  ; if there is a job then return home (clear V)
d668 1
a668 1
                MOVNE   pc, lr                                  ; return now
d674 2
a675 2
                SUBS    r0, r0, r0                              ;  MOV     r0, #0 : CLRV
                MOV     pc, lr                                  ; no more jobs, r0 =0, V clear.
d701 1
a701 1
                CMP     R0, #0                                  ; any more? (clear V)
d706 1
a706 1
                MOV     pc, lr
d839 1
a839 2
                ; V will be clear
                Pull    "r1-r3, pc"
d930 3
a932 4
                Pull    "r1-r4, r9-r10, pc", VS
                TEQ     pc, pc
                Pull    "r1-r4, r9-r10, pc", NE, ^              ; return clearing V (26-bit case)
                Pull    "r1-r4, r9-r10, pc"
d1018 3
a1020 4
                Pull    "r1-r2, pc", VS
                TEQ     pc, pc
                Pull    "r1-r2, pc", NE, ^
                Pull    "r1-r2, pc"
d1147 2
d1153 1
a1153 1
                CMP     r10, #0                                 ; is there a current driver? (clears V)
@


4.7
log
@  Fixed Makefile to use Resources directory.
Detail:
  Instead of littering the locale directories around the root of the
    component, a Resources directory now exists to hold all of these.
    The existing Messages file (UK and Germany) have been copied in situ
    into the new locations and the Makefile updated appropriately.
Admin:
  The revision histories have been copied to the new files.
  The old files have been cvs remove'd.

Version 3.32. Tagged as 'PDriver-3_32'
@
text
@a156 8
  [ :LNOT: No32bitCode
                & 0
                & Flags -module_start
  ]

  [ :LNOT: No32bitCode
Flags           DCD ModuleFlag_32bit
  ]
d158 4
a161 1
Help            = "Printer sharer", 9, "$Module_HelpVersion"
d336 1
a336 1
                Pull    "r1, pc"
d385 1
a385 2
                CLRV
                Pull    "r1-r3, pc"
d424 1
a424 1
        MOVNE   PC,LR
d429 1
a429 1
        LDMFD   SP!, {R0, PC}
d433 1
a433 1
                MOV    pc, lr
d541 1
a541 2
                SavePSR lr
                Push    "r0, wp, lr"
d550 1
a550 1
                RestPSR lr,,f                                   ; restore the flags
d563 2
a564 4
                MOVVS   pc, lr
                TEQ     pc, pc
                MOVNES  pc, lr
                MOV     pc, lr
d585 1
a585 1
                EntryS  "R0,WP"
d595 2
a596 2
                STRVS   R0, [SP, #Proc_RegOffset]
                EXIT    VS                                      ; return if device went wrong
a599 2
                ASSERT (Proc_RegOffset = 0) :LOR: (Proc_RegOffset = 4)
                [ Proc_RegOffset = 0
a600 3
                |
                LDMIB   SP,{R0, WP}                             ; get a nice copy from the stack
                ]
d611 1
a611 1
                EXITS
d634 1
a634 1
                MOV     pc, lr
d666 1
a666 1
                CMP     r9, #0                                  ; if there is a job then return home (clear V)
d668 1
a668 1
                MOVNE   pc, lr                                  ; return now
d674 2
a675 2
                SUBS    r0, r0, r0                              ;  MOV     r0, #0 : CLRV
                MOV     pc, lr                                  ; no more jobs, r0 =0, V clear.
d701 1
a701 1
                CMP     R0, #0                                  ; any more? (clear V)
d706 1
a706 1
                MOV     pc, lr
d839 1
a839 2
                ; V will be clear
                Pull    "r1-r3, pc"
d930 3
a932 4
                Pull    "r1-r4, r9-r10, pc", VS
                TEQ     pc, pc
                Pull    "r1-r4, r9-r10, pc", NE, ^              ; return clearing V (26-bit case)
                Pull    "r1-r4, r9-r10, pc"
d1018 3
a1020 4
                Pull    "r1-r2, pc", VS
                TEQ     pc, pc
                Pull    "r1-r2, pc", NE, ^
                Pull    "r1-r2, pc"
d1147 2
d1153 1
a1153 1
                CMP     r10, #0                                 ; is there a current driver? (clears V)
@


4.6
log
@  32-bit fixes - stack imbalance problems.
Admin:
  Built.

Version 3.31. Tagged as 'PDriver-3_31'
@
text
@d166 1
a166 4
Help            = "Printer sharer", 9, "$Module_MajorVersion ($Module_Date)"
              [ Module_MinorVersion <> ""
                = " $Module_MinorVersion"
              ]
@


4.5
log
@32-bit compatible

Version 3.30. Tagged as 'PDriver-3_30'
@
text
@d607 2
a608 2
                ADDVS   SP, SP, #4
                Pull    "WP, PC", VS                            ; return if device went wrong
d612 2
d615 3
@


4.4
log
@A further merge from Ursula_RiscPC.

Version 3.29. Tagged as 'PDriver-3_29'
@
text
@d157 8
d344 1
a344 1
                Pull    "r1, pc",,^
d393 2
a394 1
                Pull    "r1-r3, pc",,^
d433 1
a433 1
        MOVNES  PC,LR
d438 1
a438 1
        LDMFD   SP!, {R0, PC}^
d442 1
a442 1
                MOVS    pc, lr
d550 2
a551 1
                Push    "r0, wp, pc"
d560 1
a560 1
                TEQP    lr, #0                                  ; restore the flags
d573 4
a576 2
                ORRVS   pc, lr, #V_bit
                MOVS    pc, lr                                  ; return, setup V if required.
d597 1
a597 1
                Push    "R0, WP, LR"
d623 1
a623 1
                Pull    "R0, WP, PC",,^
d646 1
a646 1
                MOVS    pc, lr
d678 1
a678 1
                TEQ     r9, #0                                  ; if there is a job then return home
d680 1
a680 1
                MOVNES  pc, lr                                  ; return now
d686 2
a687 2
                MOV     r0, #0
                BICS    pc, lr, #V_bit                          ; no more jobs, r0 =0, V clear.
d713 1
a713 1
                TEQ     R0, #0                                  ; any more?
d718 1
a718 1
                MOVS    pc, lr
d851 2
a852 1
                Pull    "r1-r3, pc",,^
d943 4
a946 3
                Pull    "r1-r4, r9-r10, lr"
                ORRVS   lr, lr, #V_bit
                MOVS    pc, lr                                  ; return setting V if needed.
d1032 4
a1035 3
                Pull    "r1-r2, lr"
                ORRVS   lr, lr, #V_bit                          ; ensure that the v bit copied across correctly
                MOVS    pc, lr
a1161 2
                CLRV

d1166 1
a1166 1
                TEQ     r10, #0                                 ; is there a current driver?
@


4.3
log
@Ursula and Spinner branches merged.
Changed to use srccommit.

Version 3.28. Tagged as 'PDriver-3_28'
@
text
@d305 3
a307 2
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_RegisterFiles   ; ignore errors
a353 6
        [ standalone
; free up resource fs
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles   ; ignore errors
        ]

d378 7
d406 1
d416 1
@


4.2
log
@Spinner branch merged
@
text
@d59 1
d75 1
a75 1
                GET     Version
d158 4
a161 1
Help            = "Printer sharer", 9, "$VString ($Date)"
d199 1
d254 1
d400 10
d412 4
a415 4

                TEQ     r1, #Service_PDriverGetMessages         ; finding messages block?
                LDREQ   wp, [wp]
                BEQ     ServiceMessages
@


4.1
log
@Initial revision
@
text
@d58 1
d73 1
a73 1
             
d85 1
a85 1
hostvdu         SETL    true
d87 1
d89 1
a89 1
ChangeJob       SETD    true                    ; job selection/creation.
d99 1
a99 1
ToCurrent       SETD    true                    ; redirect to current job
d101 2
a102 2
xx              SETD    true                    ; misc stuff

d104 1
a104 1
calldriverR10   SETD    false                    ; calling driver with handle in R10
d126 1
d142 1
a142 1
  
a207 1
;
d213 2
d249 1
a249 1
90                                                
d253 1
a253 1
                
d264 1
a264 1
;                              
d278 1
a278 1
                                                                
d328 1
a328 1
                
d362 1
a362 1
                BIC     r2, r2, #f_CallBackPending                                       
d412 1
a412 1
                
d444 1
a444 1
        
d461 1
a461 1
                BNE     %10                
d466 1
a466 1
                B       %40         
d470 1
a470 1
                BNE     %30       
d488 2
a489 2
                BEQ     %40           
                              
d500 1
a500 1
                BVS     %60                   
d516 2
a517 2
                BVC     %50                 
                                
d529 1
a529 1
                                   
d538 1
a538 1
               
d545 1
a545 1
                                
d562 1
a562 1
                                                 
d564 1
a564 1
                       
d581 1
a581 1
                            
d592 1
a592 1
                
d608 1
a608 1
                                    
d675 1
a675 1
                          
d680 1
a680 1
        
d707 1
a707 1
             
d711 1
a711 1
                             
d735 6
a740 1
                      
d743 1
d789 1
a789 1
                                   
d845 1
a845 1
                                                                                 
d867 1
a867 1
        
d878 1
a878 1
                
d957 1
a957 1
                                                              
d969 1
a969 1
        
d1002 1
a1002 1
                ADR     r0, ErrorBlock_PrintUnknownNumber       
d1021 1
a1021 1
;                     
d1025 1
a1025 1
; MiscOp functions to be handled by printer driver, some are handled by 
d1085 1
a1085 1
                                        
d1087 1
a1087 1
                                   
d1091 1
a1091 1
                TEQ     r10, #0                        
d1119 1
a1119 1
;       
d1124 1
a1124 1
                                   
d1131 1
d1147 1
a1147 1
              
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@   Use buffer in workspace for MessageTrans.
   Added 'Colour' debugging flag.
   Do not pass SpriteV calls to pdriver if a Wimp error box is open.
@
text
@d84 1
a84 1
hostvdu         SETL    false
a85 1
debug_file	SETS	"<PDrvDebug>"
d87 1
a87 1
ChangeJob       SETD    false			; job selection/creation.
d97 1
a97 1
ToCurrent       SETD    false			; redirect to current job
d99 2
a100 2
xx              SETD    false			; misc stuff
fnt		SETD	true			; FontSWI
d102 1
a102 1
calldriverR10   SETD    false			; calling driver with handle in R10
d731 1
a731 6

		[	debug
		TEQ	r11, #7
		DebugIf	EQ, fnt, "PDriver_FontSWI", r8
		]

@


4.1.7.3
log
@Tested, and fixed the previous set of fixes...
@
text
@a124 1
error_buffer		# 256
@


4.1.7.4
log
@   Just some tracing.
@
text
@a57 1
; 07-May-97 3.26 JRC Added InUse and NoEsc error tokens.
d72 1
a72 1

d98 1
a98 1
ToCurrent       SETD    true			; redirect to current job
d103 1
a103 1
calldriverR10   SETD    true			; calling driver with handle in R10
d141 1
a141 1

d207 1
a212 2
                Debug	ToCurrent, "PDriver SWI", r11, lr

d247 1
a247 1
90
d251 1
a251 1

d262 1
a262 1
;
d276 1
a276 1

d326 1
a326 1

d360 1
a360 1
                BIC     r2, r2, #f_CallBackPending
d410 1
a410 1

d442 1
a442 1

d459 1
a459 1
                BNE     %10
d464 1
a464 1
                B       %40
d468 1
a468 1
                BNE     %30
d486 2
a487 2
                BEQ     %40

d498 1
a498 1
                BVS     %60
d514 2
a515 2
                BVC     %50

d527 1
a527 1

d536 1
a536 1

d543 1
a543 1

d560 1
a560 1

d562 1
a562 1

d579 1
a579 1

d590 1
a590 1

d606 1
a606 1

d673 1
a673 1

d678 1
a678 1

d705 1
a705 1

d709 1
a709 1

a740 1
                Debug   ToCurrent, "PassToCurrentJob lr", lr
d786 1
a786 1

d842 1
a842 1

d864 1
a864 1

d875 1
a875 1

d954 1
a954 1

d966 1
a966 1

d999 1
a999 1
                ADR     r0, ErrorBlock_PrintUnknownNumber
d1018 1
a1018 1
;
d1022 1
a1022 1
; MiscOp functions to be handled by printer driver, some are handled by
d1082 1
a1082 1

d1084 1
a1084 1

d1088 1
a1088 1
                TEQ     r10, #0
d1116 1
a1116 1
;
d1121 1
a1121 1

a1127 1
                Debug   calldriverR10, "calldriver lr", lr
d1143 1
a1143 1

@


4.1.7.5
log
@Added the Command SWI.
@
text
@a58 1
; 13-Aug-97 3.27 AR  Added Command SWI
a194 1
                = "Command", 0
a248 1
                B	PassToDriver				; PDriver_Command
@


4.1.7.5.2.1
log
@changed the service call handler as per new spec.
@
text
@a396 1
	ASSERT	Service_ResourceFSStarting < Service_PDriverGetMessages
d398 1
a398 8
serviceentry_ServTab
	DCD	0
	[ standalone
	DCD	Service_ResourceFSStarting
	]
 	DCD	Service_PDriverGetMessages         ; finding messages block?
	DCD	0
        DCD     serviceentry_ServTab - module_start  ;anchor for table
d400 3
a402 5
Service         ROUT
	MOV	R0, R0
        TEQ     r1, #Service_PDriverGetMessages         ; finding messages block?
        LDREQ   wp, [wp]
        BEQ     ServiceMessages
@


4.1.7.5.2.2
log
@Ursula_RiscPC branch folded onto Ursula branch.
@
text
@d302 2
a303 3
; SB, 25-11-98 Only if V clear - otherwise module disappears and takes registered block with it!
        ADRVCL  R0,resourcefsfiles
        SWIVC   XResourceFS_RegisterFiles   ; ignore errors
d350 6
a379 7
        [ standalone
; free up resource fs
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles   ; ignore errors
        CLRV                                  ; clear V
        ]

a400 1
        DCD     Service_FastEntry - module_start
a409 1
Service_FastEntry
@


4.1.7.5.2.1.2.1
log
@  Fixed faulty Ursula fast service call table.
Detail:
  The code offset field was missing - yet the table remained valid enough
    for the Ursula kernel to believe it was still good.  Resulted in aborts
    whenever Service_PDriverGetMessages was sent round in RAM builds; resulted
    in PDriver never responding to the service call in ROM builds.
  Doesn't deregister the ResourceFS block unless module finalisation is
    going to succeed (also closes the message file before removing the
    ResourceFS block).
  Doesn't register ResourceFS block if module initialisation is going to
    fail (since when the module leaves the chain, it takes the messages file
    with it, yet leaving it registered with ResourceFS)
Admin:
  Tagged as PDriver-3_28
@
text
@d302 2
a303 3
; SB, 25-11-98 Only if V clear - otherwise module disappears and takes registered block with it!
        ADRVCL  R0,resourcefsfiles
        SWIVC   XResourceFS_RegisterFiles   ; ignore errors
d350 6
a379 7
        [ standalone
; free up resource fs
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles   ; ignore errors
        CLRV                                  ; clear V
        ]

a400 1
        DCD     Service_FastEntry - module_start
a409 1
Service_FastEntry
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

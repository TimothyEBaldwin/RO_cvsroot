head	4.10;
access;
symbols
	PDModules-4_64:4.10
	PDModules-4_63:4.10
	PDModules-4_62:4.9
	PDModules-4_61:4.8
	PDModules-4_60:4.8
	PDModules-4_59:4.8
	PDModules-4_58:4.7
	PDModules-4_57:4.7
	PDModules-4_56:4.6
	PDModules-4_55:4.6
	PDModules-4_54:4.6
	PDModules-4_53:4.6
	PDModules-4_52:4.6
	PDModules-4_51:4.6
	PDModules-4_50:4.6
	PDModules-4_49:4.5
	PDModules-4_48:4.5
	PDModules-4_47:4.5
	PDModules-4_46:4.4
	kbracey_32bit_merge:4.3.2.2
	PDModules-4_45:4.4
	PDModules-4_44-4_1_2_7:4.3.2.2
	PDModules-4_44-4_1_2_6:4.3.2.2
	PDModules-4_44-4_1_2_5:4.3.2.2
	PDModules-4_44-4_1_2_4:4.3.2.2
	PDModules-4_44-4_1_2_3:4.3.2.2
	PDModules-4_44-4_1_2_2:4.3.2.2
	PDModules-4_44-4_1_2_1:4.3.2.1
	kbracey_32bit:4.3.0.2
	kbracey_32bit_bp:4.3
	dellis_autobuild_BaseSW:4.3
	Ursula_merge:4.1.7.2
	PDModules-4_44:4.3
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.2
	Ursula_RiscPC:4.1.7.2.0.4
	rthornb_UrsulaBuild-19Aug1998:4.1.7.2
	UrsulaBuild_FinalSoftload:4.1.7.2
	rthornb_UrsulaBuild-12Aug1998:4.1.7.2
	aglover_UrsulaBuild-05Aug1998:4.1.7.2
	rthornb_UrsulaBuild-29Jul1998:4.1.7.2
	rthornb_UrsulaBuild-22Jul1998:4.1.7.2
	hsimons_BOCA-1_2-Release:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.1.7.2
	rthornb_UrsulaBuild-07Jul1998:4.1.7.2
	rthornb_UrsulaBuild-17Jun1998:4.1.7.2
	rthornb_UrsulaBuild-03Jun1998:4.1.7.2
	rthornb_UrsulaBuild-27May1998:4.1.7.2
	rthornb_UrsulaBuild-21May1998:4.1.7.2
	rthornb_UrsulaBuild_01May1998:4.1.7.2
	afrost_NC2_Generic:4.1.7.2
	afrost_Funai01-33:4.1.7.2
	Ursula:4.1.7.2.0.2
	Ursula_bp:4.1.7.2
	Ursula_31Mar1998:4.3
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spin_merge_28May97:4.1.7.2
	Spinner_B10:4.1.7.2
	Spin_merge_16May97:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2018.07.03.21.21.59;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	wlcRMNq9s64zFJIA;

4.9
date	2018.07.03.21.14.47;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	8KGlIKKeLIz2DJIA;

4.8
date	2014.10.20.21.53.08;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	kYvwc1FHitWAiZUx;

4.7
date	2013.11.27.21.53.24;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	mE89vdb18rfoOXex;

4.6
date	2003.03.10.11.33.29;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2002.12.05.20.45.10;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2001.01.09.13.59.43;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	97.05.16.12.55.56;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.17.07.54;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.48.42;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2000.10.18.11.32.02;	author sbrodie;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2000.11.24.13.27.32;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.48.42;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.06.07;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.28.03;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.31.40;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.05.01.12.38.46;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Add support for 4k/64k sprite printing via PDriverPS
Look harder at the sprite type bits rather than assume the sequence 1/2/4/8/16/32bpp still holds. This lets through the RISC OS 5 sprite type for 4k and 64k colours.
Look up the RGB ordering via the respective ModeFlags mode variable, change the order of output RGB PostScript bytes as required.
Add some helper functions to map 4:4:4, 5:5:5, 5:6:5 to deal with the 6 possible 16bpp types, since they all ultimately output RGB888.

Tested printing a Draw file with all true colour combinations of test sprites, then converting with Adobe Distiller.

Version 4.63. Tagged as 'PDModules-4_63'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.PDriverPS.Sprite

; Sprite handling routines for the PostScript printer driver

; This routine is used by the sprite plotting routines in this file and
; TransSprite.  It checks to see if bit 4 of R5 is set, and if so
; it arranges to use the sprite's palette in preference to the
; translation table, unless the palette is nonexistent or the wrong size.
      [ PSAllowHighTables
; It does this by modifying R7 to point at the palette, setting bit 0
; so that the later code notices.
      |
; It does this by modifying R7 to point at the palette, setting bit 31
; so that the later code notices.
      ]
; On entry, R0-R2 are sprite identifiers, R7 is the translation table.
; On exit registers are preserved except R7 may have been updated.

sprite_checkR5bit4
        Push    "R0-R5,LR"

        Debug   Sprite, "sprite_checkR5bit4 in: Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9
        TST     R5, #1 :SHL: 4
        Pull    "R0-R5,PC", EQ

        ; Read palette size into R3, sprite mode to R5
        BIC     R0,R0,#&FF
        ORR     R0,R0,#SpriteReason_CreateRemovePalette
        MOV     R3,#-1
        SWI     XOS_SpriteOp

        Debug   Sprite, "after createremovepalette Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9

        MOVVC   R0,R5
        MOVVC   R1,#VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable

        Debug   Sprite, "after ReadModeVariable Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9

        Pull    "R0-R5,PC", VS
        Pull    "R0-R5,PC", CS

        TEQ     R3, #0                  ; If the sprite has no palette
        TEQNE   R2, #4                  ; or if it's 16 or 32bpp, then this is all
        TEQNE   R2, #5                  ; irrelevant - we use a different strategy
        Pull    "R0-R5,PC", EQ          ; so return

        MOV     R0, #1
        MOV     R1, R0, LSL R2          ; R1 is number of bits per pixel in the mode
        MOV     R1, R0, LSL R1          ; now R1 is the max number of colours in the mode

        Debug   Sprite, "Finally ncol,npal == ", R1,R3

        TEQ     R3, R1                  ; Number of colours == number of palette entries?
      [ PSAllowHighTables
        ORREQ   R7, R4, #1 :SHL: 0      ; If so, set a "use palette" flag in bit 0
      |
        ORREQ   R7, R4, #1 :SHL: 31     ; If so, point to palette instead of translation table
      ]        
        Debug   Sprite, "On exit R7 is",R7

        Pull    "R0-R5,PC"


; Sprite outputting routine
; =========================
;
; Entry: R0 is SpriteOp reason code and controls how R1 and R2 should be
;          interpreted.
;        R1 -> sprite area if R0 >= &100; otherwise the sprite area concerned
;          is the system area.
;        R2 -> sprite name if R0 < &200.
;        R2 -> sprite if R0 >= &200.
;        R3 is the X co-ordinate relative to the bottom left of the current
;          rectangle (in OS units).
;        R4 is the Y co-ordinate relative to the bottom left of the current
;          rectangle (in OS units).
;        R5 is the GCOL action.  Bit 4 may be set, meaning "use sprite's
;          palette in preference to the trans table".  The rest of the bits
;          in this register are guaranteed to be 0 or 8 meaning
;          "don't use mask" and "use mask" respectively
;        R6 = 0 or -1 for no scaling, or points to 4 scaling factors (x-mag,
;          y-mag, x-div, y-div).
;        R7 = 0 or -1 for no translation, or points to a translation table.
; Exit:  All registers preserved

        [ Medusa
; For TrueColour sprites on B/W printers, we create the temporary
; sprite in a suitable 8bpp mode, and we create our own translation
; table to render the source down to 256 grey-levels.

; For TrueColour sprites on colour printers, we call new code that
; uses colorimage to image the sprite.  This code is incapable of
; handling the MASK properly; PostScript simply does not cope with
; the idea of a bitmap mask for the colorimage operator.  In desparation,
; we simply map masked pixels to white; this is horribly bogus but
; will at least cover one common case.

        GBLA    FakeMaskColour
FakeMaskColour  SETA    &00FFFFFF       ; RGB white

        ]




sprite_put
        Push    "R0-R9,LR"
        PrError sprite_put_no_grestore_return

        Debug   Sprite, "Sprite_Put in: Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9
        Debug   Medusa, "Sprite_Put starts"
        Debug   Medusa, "Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9


        CMP     R7, R7, ASR#31          ;If user wants no translation table, then
        MOVEQ   R7, #0                  ;force R7 to zero (internally we use a spare bit of R7
                                        ;  to distinguish a translation table from a
                                        ;  sprite palette)
        [ Medusa
        BL      sprite_clear32Ktable
        ]

; Not doing source clipping
        MOV     lr, #0
        STR     lr, sourceclip_x
        STR     lr, sourceclip_y

; Sprite and VDU calls issued from in here should go to the real code.

        LDRB    LR,passthrough
        STRB    LR,sprpassthrough
        ORR     LR,LR,#passthrough_spr
        STRB    LR,passthrough

; Save current graphics state, then translate to sprite origin.

        [       PSCoordSpeedUps
        BL      ensure_OScoords
        BLVC    output_gsave
        |
        BL      output_gsave
        ]
        BLVC    sprite_translatebyR3R4

; Get sprite information, first putting GCOL action and the scaling
; information in safe registers.

        ANDVC   R8,R5,#15
        MOVVC   R9,R6

; Check whether the user has asked to use the sprite's palette, rather
; than the translation table.  Adjust if so.
        BL      sprite_checkR5bit4

        BICVC   R0,R0,#&FF
        ORRVC   R0,R0,#SpriteReason_ReadSpriteSize
        SWIVC   XOS_SpriteOp
        PrPassError
        TEQ     R3,#0
        TEQNE   R4,#0
        BEQ     sprite_put_return               ;Note V is clear

; Make GCOL actions 8-15 identical to actions 0-7 if the sprite has no mask.
; Then ignore GCOL actions other than 0 and 8 (overwriting).

        TEQ     R5,#0
        ANDEQ   R8,R8,#7
        TST     R8,#7
        BNE     sprite_put_return               ;Note V is clear

        [ Medusa

; If the sprite is 16 or 32bpp, we want to process it specially.
; XXX check the TransSprite code keeps in step with this

        Push    "R0-R2"
        MOV     R0,R6
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        MOV     LR,R2
        Debug   Medusa, "Sprite Log2BPP=",LR
        Pull    "R0-R2"
        TEQ     LR,#4
        BEQ     %FT02
        TEQ     LR,#5
        BNE     %FT00

; It's a 32bpp sprite.

        LDR     LR,info_features        ;If output is destined for a monochrome
        TST     LR,#1                   ;  printer, fudge the sprite mode
        BEQ     %FT01

        BL      sprite_scaling
        BLVC    sprite_output32bpp
        PrPassError
        B       sprite_put_return

; It's a 16bpp sprite
02
        LDR     LR,info_features        ;If output is destined for a monochrome
        TST     LR,#1                   ;  printer, fudge the sprite mode
        BEQ     %FT01

        BL      sprite_scaling
        BLVC    sprite_output16bpp
        PrPassError
        B       sprite_put_return

; Truecolour sprite->mono printer, so modify the mode number to make a
; similar 8bpp mode and arrange for the real sprite to be plotted into
; that as greyscale
01
        Debuga  Medusa, "Changing sprite type from ", R6
        BIC     R6, R6, #2_11111 :SHL: 27
        ORR     R6, R6, #SpriteType_New8bpp :SHL: 27
        Debug   Medusa, " to ", R6
; And create a suitable translation table, putting the address of the anchor block into R7
        BL      sprite_make32Ktable

00
        ]

; Use scaling factors to get the co-ordinate system units right.

        BL      sprite_scaling
        PrPassError

; Clear out the printer driver's temporary sprite area and create a 256 bits
; by 64 lines sprite for this sprite's mode in it. Give the new sprite a
; mask, then get its address for future reference.
;
; R0-R2:   the info about the sprite (as usual)
; R3,R4:   sprite width & height in pixels, as returned from ReadSpriteSize
; R6:      the sprite's mode
; R7:      translation table pointer.
; R8:      0 for unmasked plotting, 8 for masked plotting (& mask exists).
; R10-R12: file handle and workspace pointers.

sprite_commonoutput

        BL    sprite_createtempsprite
        PrPassError

        Debug   Medusa, "Start of plot loop"
        Debug   Medusa, "Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9

; We're now ready to start plotting 256 bits by 64 rows chunks of the
; sprite. First split it into 256 bit wide strips.
;   Currently, important register contents are:
; R0-R2:   sprite identifiers.
; R3,R4:   sprite width & height in pixels.
; R5:      number of pixels that make up 256 bits.
; R6:      sprite mode.
; R7:      translation table pointer.
; R8:      0 for unmasked plotting, 8 for masked plotting (& mask exists).
; R10-R12: file handle and workspace pointers.

sprite_put_xloop
        CMP     R5,R3
        MOVGT   R5,R3

;   Currently, important register contents are:
; R0-R2:   sprite identifiers.
; R3:      width of the part of the sprite we still have to do.
; R4:      sprite height in pixels.
; R5:      width of the strip we're taking off the right hand side of the
;            sprite.
; R6:      sprite mode.
; R7:      translation table pointer.
; R8:      0 for unmasked plotting, 8 for masked plotting (& mask exists).
; R10-R12: file handle and workspace pointers.

        Push    "R4"
        MOV     R9,#64
sprite_put_yloop
        CMP     R9,R4
        MOVGT   R9,R4

;   Currently, important register contents are:
; R0-R2:   sprite identifiers.
; R3:      width of the part of the sprite we still have to do.
; R4:      height of the part of the current strip we still have to do.
; R5:      width of the strip we're taking off the right hand side of the
;            sprite.
; R6:      sprite mode.
; R7:      translation table pointer.
; R8:      0 for unmasked plotting, 8 for masked plotting (& mask exists).
; R9:      height of the chunk we're taking off the top of the current strip.
; R10-R12: file handle and workspace pointers.

        BL      sprite_putchunk
        Pull    "R4",VS
        PrPassError

        SUBS    R4,R4,R9
        BNE     sprite_put_yloop
        Pull    "R4"

        SUBS    R3,R3,R5
        BNE     sprite_put_xloop

; Restore original graphics state.

sprite_put_return
        BL      output_grestore

sprite_put_no_grestore_return

        [ Medusa
        BL      sprite_free32Ktable             ; free it if allocated
        ]

; Revert to normal handling of sprite calls and return
        LDRB    LR,sprpassthrough
        STRB    LR,passthrough
        STRVS   R0,[R13]
        Pull    "R0-R9,PC"

; Sprite mask outputting routine
; ==============================
;
; Entry: R0 is SpriteOp reason code and controls how R1 and R2 should be
;          interpreted.
;        R1 -> sprite area if R0 >= &100; otherwise the sprite area concerned
;          is the system area.
;        R2 -> sprite name if R0 < &200.
;        R2 -> sprite if R0 >= &200.
;        R3 is the X co-ordinate relative to the bottom left of the current
;          rectangle (in OS units).
;        R4 is the Y co-ordinate relative to the bottom left of the current
;          rectangle (in OS units).
;        R6 <= 0 for no scaling, or points to 4 scaling factors (x-mag,
;          y-mag, x-div, y-div).
;        Correct colour has already been set up.
; Exit:  All registers preserved

sprite_mask
        Push    "R0-R9,LR"
        PrError sprite_mask_no_grestore_return

; Not doing source clipping
        MOV     lr, #0
        STR     lr, sourceclip_x
        STR     lr, sourceclip_y

; Sprite and VDU calls issued from in here should go to the real code.

        LDRB    LR,passthrough
        STRB    LR,sprpassthrough
        ORR     LR,LR,#passthrough_spr
        STRB    LR,passthrough

; Save current graphics state, then translate to sprite origin.

        [       PSCoordSpeedUps
        BL      ensure_OScoords
        BLVC    colour_ensure
        BLVC    output_gsave
        |
        BL      output_gsave
        ]
        BLVC    sprite_translatebyR3R4

; Get sprite information, first putting the scaling information in a safe
; register.

        MOVVC   R9,R6
        BICVC   R0,R0,#&FF
        ORRVC   R0,R0,#SpriteReason_ReadSpriteSize
        SWIVC   XOS_SpriteOp
        PrPassError
        TEQ     R3,#0
        TEQNE   R4,#0
        BEQ     sprite_mask_return              ;Note V is clear

        MOV     R8,R5                           ;Preserve mask information

; Use scaling factors to get the co-ordinate system units right.

        BL      sprite_scaling

; Note: don't try to deal with unmasked sprites here, before breaking them
; down into pieces. Problem with attempting to do so is that the 'FFs' string
; may be too small to do so with 'imagemask's, but we must use 'imagemask' if
; we don't want to get rounding errors on the edges of the result.

; Clear out the printer driver's temporary sprite area and create a 256 bits
; by 64 lines sprite for this sprite's mode in it. Give the new sprite a
; mask, then get its address for future reference.

sprite_mask_commonoutput

        BLVC    sprite_createtempsprite
        PrPassError

; We're now ready to start plotting 256 bits by 64 rows chunks of the
; mask. First split it into 256 bit wide strips.
;   Currently, important register contents are:
; R0-R2:   sprite identifiers.
; R3,R4:   sprite width & height in pixels.
; R5:      number of pixels that make up 256 bits.
; R6:      sprite mode.
; R8:      0 if no mask exists, 1 if mask exists.
; R10-R12: file handle and workspace pointers.

sprite_mask_xloop
        CMP     R5,R3
        MOVGT   R5,R3

;   Currently, important register contents are:
; R0-R2:   sprite identifiers.
; R3:      width of the part of the sprite we still have to do.
; R4:      sprite height in pixels.
; R5:      width of the strip we're taking off the right hand side of the
;            sprite.
; R6:      sprite mode.
; R8:      0 if no mask exists, 1 if mask exists.
; R10-R12: file handle and workspace pointers.

        Push    "R4"
        MOV     R9,#64
sprite_mask_yloop
        CMP     R9,R4
        MOVGT   R9,R4

;   Currently, important register contents are:
; R0-R2:   sprite identifiers.
; R3:      width of the part of the sprite we still have to do.
; R4:      height of the part of the current strip we still have to do.
; R5:      width of the strip we're taking off the right hand side of the
;            sprite.
; R6:      sprite mode.
; R8:      0 if no mask exists, 1 if mask exists.
; R9:      height of the chunk we're taking off the top of the current strip.
; R10-R12: file handle and workspace pointers.

        BL      sprite_maskchunk
        Pull    "R4",VS
        PrPassError

        SUBS    R4,R4,R9
        BNE     sprite_mask_yloop
        Pull    "R4"

        SUBS    R3,R3,R5
        BNE     sprite_mask_xloop

; Restore original graphics state.
; Revert to normal handling of sprite calls and return

sprite_mask_return
        BL      output_grestore
sprite_mask_no_grestore_return
        LDRB    LR,sprpassthrough
        STRB    LR,passthrough
        STRVS   R0,[R13]
        Pull    "R0-R9,PC"

; Subroutine to get the co-ordinate system units right for sprite plotting.
;
; The co-ordinate system has been translated to the correct origin, but we
; still have to get the units right. They are currently OS units by OS units.
; They need to be sprite bits by sprite pixels. So the X scaling involves:
;   (a) Dividing by the sprite's bits/pixel (sprite bits -> sprite pixels);
;   (b) Multiplying by the current screen mode's X pixel size (sprite pixels
;       -> sprite OS units);
;   (c) Multiplying by the X multiplier and dividing by the X divisor (sprite
;       OS units -> real OS units).
; The Y scaling involves:
;   (a) Multiplying by the current screen mode's Y pixel size (sprite pixels
;       -> sprite OS units);
;   (b) Multiplying by the Y multiplier and dividing by the Y divisor (sprite
;       OS units -> real OS units).
; To do these, we need to look up the appropriate mode variables.
;   At this stage, we also generate the scaling matrix used by 'imagemask' or
; 'image' in the sprite output routine. This is based on the number of bits/
; pixel in the sprite, but note that it should use Log2BPP, not Log2BPC...
; Entry: R0-R2:   sprite identifiers.
;        R3,R4:   sprite width & height in pixels.
;        R6:      sprite mode.
;        R9:      scale factors pointer.
;        R10-R12: file handle and workspace pointers.
; Exit:  R0-R8, R10-R12 preserved (except R0 on an error).
;        R9 = Log(bytes/character) for sprite's screen mode.

sprite_scaling
        Push    "R0-R6,LR"
        PrError sprite_scaling_return
        MOV     R0,R6

        CMP     R9, R9, ASR#31                  ;Pick up scaling factors
        LDMNEIA R9,{R3-R6}
        MOVEQ   R3,#1
        MOVEQ   R4,#1
        MOVEQ   R5,#1
        MOVEQ   R6,#1

        MOV     R1,#VduExt_Log2BPC              ;Adjust X divisor for
        SWI     XOS_ReadModeVariable            ;  (software) bits/pixel
        MOVVC   R5,R5,LSL R2
        MOVVC   R9,R2

        LDRVC   R2,currxeig                     ;Adjust X multiplier for
        MOVVC   R3,R3,LSL R2                    ;  pixel size

        LDRVC   R2,curryeig                     ;Adjust Y multiplier for
        MOVVC   R4,R4,LSL R2                    ;  pixel size

        MOVVC   R1,#VduExt_Log2BPP              ;Get (hardware) bits/pixel
        SWIVC   XOS_ReadModeVariable            ;  for scaling matrix

        PrPassError

        PrPair  R3,R5
        PrPair  R4,R6
        PrLnIm  "SS"

        MOV     LR,#1
        MOV     R2,LR,LSL R2
        PrNumSp R2
        PrLnIm  "SM",FallThroughOnError

        PrError
sprite_scaling_return
        STRVS   R0,[R13]
        Pull    "R0-R6,PC"

; Subroutine to put an appropriate (256 bit by 64 lines) sprite into the
; printer driver's temporary sprite area.
; Entry: R6 = mode number / sprite type
;        R9 = LOG(bytes/character) for the sprite's mode.
; Exit:  R0-R4,R6-R12 preserved (except R0 on an error).
;        R5 = number of pixels that make up 256 bits.

sprite_createtempsprite
        MOV     R5,#&100                        ;Calculate width of a 256 bit
        MOV     R5,R5,LSR R9                    ;  chunk in pixels

        Push    "R0-R5,LR"

        LDR     R0,=&100+SpriteReason_ClearSprites
        ADRL    R1,sprarea
        SWI     XOS_SpriteOp

        LDRVC   R0,=&100+SpriteReason_CreateSprite
        ADRVC   R2,sprite_name
        MOVVC   R3,#0
        MOVVC   R4,R5
        MOVVC   R5,#64

        DebugIf VC,Medusa,"Create temp. sprite ",R0,R1,R2,R3,R4,R5,R6
        SWIVC   XOS_SpriteOp

        [ Medusa
; Create a second identical sprite to hold the mask data
        ADRVC   R2,spritemsk_name
        DebugIf VC,Medusa,"Create temp. mask ",R0,R1,R2,R3,R4,R5,R6
        SWIVC   XOS_SpriteOp
        |
; Give the sprite a mask
        LDRVC   R0,=&100+SpriteReason_CreateMask
        SWIVC   XOS_SpriteOp
        ]

        LDRVC   R0,=&100+SpriteReason_SelectSprite
        [ Medusa
        ADRVC   R2,spritemsk_name
        SWIVC   XOS_SpriteOp
        STRVC   R2,spritemskaddress
        ]
        ADRVC   R2,sprite_name
        SWIVC   XOS_SpriteOp
        STRVC   R2,spriteaddress

        STRVS   R0,[R13]
        Pull    "R0-R5,PC"

sprite_name
        DCB     "tmp",0
spritemsk_name
        DCB     "msk",0
        ALIGN

        LTORG


; Subroutine to output a specified rectangular chunk of a sprite. The chunk
; to be printed has its top right hand corner at (R3,R4) and is of size
; (R5,R9).
; Entry: R0-R2 identify the sprite in the usual way.
;        R3 contains the right edge of the chunk to be plotted.
;        R4 contains the top edge of the chunk to be plotted.
;        R5 contains the width of the chunk to be plotted.
;        R6 contains the mode of the sprite.
;        R7 contains a translation table pointer.
;        R8 contains 0 for unmasked plotting, 8 for masked plotting. In the
;           latter case, the sprite definitely has a mask.
;        R9 contains the height of the chunk to be plotted.
;        R10-R12 contain the file handle and workspace pointers as usual.
;        sourceclip_x,_y: source x and y offsets in pixels.  Normally 0.
;        The sprite pointed to by 'spritehandle' is suitable as a place into
;        which to copy the chunk to be plotted.
; Exit:  All registers preserved.

sprite_putchunk
        Push    "R0-R9,LR"

        Debug   Medusa, "sprite_putchunk; Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9
; Convert R3,R4 to bottom left corner of chunk.

        SUB     R3,R3,R5
        SUB     R4,R4,R9

; The next major step is to transfer a copy of the chunk concerned to the
; sprite pointed to by 'spriteaddress'

        Push    "R3-R5"

; Negate the bottom left corner and convert it to OS co-ordinates (this is
; the position at which we want to plot the given sprite in the one pointed
; at by 'spritehandle').

        RSB     R3,R3,#0
        RSB     R4,R4,#0

; Here we must allow for the altered source origin brought about by
; source clipping.  Simply subtract this offset from the bottom-left
; position in R3,R4.  Note that this is only used for obtaining the source data -
; the real values of R3,R4 have been pushed.

        Push    "R0-R2"

        LDR     r0, sourceclip_x
        LDR     r1, sourceclip_y
        SUB     R3, R3, R0
        SUB     R4, R4, R1

        Debuga  Medusa, "Pixel offsets are ", R3, R4

        MOV     R0,R6
        MOV     R1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        MOVVC   R3,R3,LSL R2

        MOVVC   R1,#VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   R4,R4,LSL R2

        Debug   Medusa, " & OSunit offsets are ", R3, R4

        STRVS   R0,[R13]
        Pull    "R0-R2"

; Switch output to the sprite pointed to by 'spritehandle'

        Push    "R0-R3"
        LDRVC   R0,=&200+SpriteReason_SwitchOutputToSprite
        ADRVCL  R1,sprarea
        LDRVC   R2,spriteaddress
        MOVVC   R3,#0
        SWIVC   XOS_SpriteOp
        ADRVCL  LR,oldspritestate
        STMVCIA LR,{R0-R3}
        STRVS   R0,[R13]
        Pull    "R0-R3"
        BVS     sprite_putchunk_chunktransferred

; Plot the given chunk's data.

        BIC     R0,R0,#&FF
        MOV     R5,#0                           ; Plot action

        [ Medusa
        ORR     R0,R0,#SpriteReason_PutSpriteScaled
        Push    "R6,R7"
        MOV     R6, #0                          ; No scaling
        ADRL    LR, colourtrans32K              ; We only want to pass a translation
        TEQ     LR, R7                          ; table through if it is our own
        MOVNE   R7, #0                          ; 32K greyscale one.  Zero it if not.
        SWI     XOS_SpriteOp
        Pull    "R6,R7"
        |
        ORR     R0,R0,#SpriteReason_PutSpriteUserCoords
        SWI     XOS_SpriteOp
        ]
        BVS     sprite_putchunk_switchoutputback

; We're done if no mask is wanted.

        TEQ     R8,#0
        BEQ     sprite_putchunk_switchoutputback        ;Note V is clear

; Aaargh! We must transfer the mask data. Technique: switch output to the
; mask of the sprite pointed to by 'spriteaddress'. Clear it to zeroes, then
; plot the mask of the given sprite, using the inverting action.

        Push    "R0-R3"
        ADRL    R1,sprarea

        [ Medusa
        Debug   Medusa, "Switching output to sprite instead of mask"
        LDR     R0,=&200+SpriteReason_SwitchOutputToSprite
        LDR     R2,spritemskaddress
        |
        LDR     R0,=&200+SpriteReason_SwitchOutputToMask
        LDR     R2,spriteaddress
        ]
        MOV     R3,#0
        SWI     XOS_SpriteOp
        STRVS   R0,[R13]
        Pull    "R0-R3"

        SWIVC   XOS_WriteI+16           ;Current background must be zeroes
                                        ;  after the output switch, so we can
                                        ;  do a CLG immediately.

        SWIVC   XOS_WriteI+18           ;Set inverting background
        SWIVC   XOS_WriteI+4
        SWIVC   XOS_WriteI+128

        Push    "R6"
        BICVC   R0,R0,#&FF              ;Plot this sprite's mask
        ORRVC   R0,R0,#SpriteReason_PlotMaskScaled
        MOV     R6, #0                  ; No scaling
        SWIVC   XOS_SpriteOp
        Pull    "R6"

sprite_putchunk_switchoutputback
        Push    "R0-R3,R10"
        SavePSR R10
        ADRL    LR,oldspritestate
        LDMIA   LR,{R0-R3}
        SWI     XOS_SpriteOp
        STRVS   R0,[R13]
        RestPSR R10,VC,f                ;Collect up V flags
        Pull    "R0-R3,R10"

sprite_putchunk_chunktransferred
        DebugE  Medusa, "chunktransferred error: "
        Pull    "R3-R5"

; The chunk we want to plot is now safely in the sprite pointed to by
; 'spriteaddress'.
;   Currently, important register contents are:
; R3,R4:   pixel co-ordinates of where we want to plot the current chunk.
; R5:      width of the chunk in pixels.
; R6:      sprite mode.
; R7:      translation table pointer.
; R8:      0 for unmasked plotting, 8 for masked plotting (& mask exists).
; R9:      height of the chunk in pixels.
; R10-R12: file handle and workspace pointers.

; Now we change the X co-ordinates to bits, then translate the co-ordinate
; system to the chunk origin.

        Debug   Medusa, "chunk xferred; Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9

        PrError sprite_putchunk_return

        MOVVC   R0,R6
        MOVVC   R1,#VduExt_Log2BPC
        SWIVC   XOS_ReadModeVariable
        MOVVC   R3,R3,LSL R2
        MOVVC   R5,R5,LSL R2

        MOVVC   R1,#VduExt_Log2BPP              ;To interpret colours in the
        SWIVC   XOS_ReadModeVariable            ;  data, we need this form
        MOVVC   R6,R2                           ;  of Log2(bits/pixel)
        STRVC   R6,spritelog2bpp
        BLVC    output_gsave
        BLVC    sprite_translatebyR3R4
        PrPassError

        Debug   Medusa, "translated; Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9

; The next step is to scan the chunk we are to plot, to find out which
; pixel values exist and what their bounding boxes are. First prepare for
; the main analysis.
;   Currently, important register contents are:
; R5:      width of the chunk in bits.
; R6:      Log2(bits/pixel)
; R7:      translation table pointer.
; R8:      0 for unmasked plotting, 8 for masked plotting (& mask exists).
; R9:      height of the chunk in pixels.
; R10-R12: file handle and workspace pointers.

        ADRL    R4,colourbounds                 ;Start by clearing the
        ADD     R3,R4,#4*&100                   ;  'colourbounds' table
        [       PSSprUseBBoxes
        LDR     R2,=&FFFF0000
        |
        MOV     R2,#&00FF0000           ;If not using bounding boxes, all
                                        ;  we need to do is distinguish
                                        ;  colours found from ones not found
        ]
sprite_putchunk_clearcolourbounds
        STR     R2,[R3],#-4
        CMP     R3,R4
        BHS     sprite_putchunk_clearcolourbounds

        LDR     LR,spriteaddress                ;Get address of the temp. sprite
        LDR     R0,[LR,#spImage]                ;Get offset of image data
        ADD     R0,LR,R0                        ;Convert to address
        [ Medusa
        LDR     LR,spritemskaddress             ;Get address of 'mask' sprite
        LDR     R1,[LR,#spImage]                ;Get offset of image data
        ADD     R1,LR,R1                        ;Convert to address
        |
        LDR     R1,[LR,#spTrans]                ;Get offset of mask data
        ADD     R1,LR,R1                        ;Convert to address
        ]
        ADD     R0,R0,#63*32                    ;Shift origins to bottom left
        ADD     R1,R1,#63*32                    ;  of sprite

        MOV     LR,#1                           ;Calculate bits/pixel
        MOV     R6,LR,LSL R6
        RSB     LR,LR,LR,LSL R6                 ;And pixel mask

        EOR     R8,R8,#8                        ;Invert masking flag
        MOV     R8,R8,LSL #13                   ;Move it up to bit 16
        ORR     R8,R8,LR,LSL #24                ;And merge in the pixel mask

; Now do the analysis.
;   Currently, important register contents are:
; R0:      address of sprite data.
; R1:      address of sprite mask.
; R4:      address of 'colourbounds' table.
; R5:      width of the chunk in bits.
; R6:      bits/pixel.
; R7:      translation table pointer.
; R8:      Bit 16 set for unmasked plotting, clear for masked plotting.
;          Bits 31 to 24 are the pixel mask.
;          All other bits clear.
; R9:      height of the chunk in pixels.
; R10-R12: file handle and workspace pointers.

        Debug   Medusa, "start analysis; Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9

        [       :LNOT:PSSprUseBBoxes

        SUB     LR,R9,#1                ;If not using real bounding boxes,
        ADD     LR,LR,R5,LSL #8         ;  generate a "colourbounds" entry
        SUBS    LR,LR,R6,LSL #8         ;  that describes the boundary of
                                        ;  the chunk.

        ]

        Push    "R0,R1,R7,R9,R10"
        SUB     R9,R9,#1
        SUB     R0,R0,R9,LSL #5                 ;Shift origins to top left
        SUB     R1,R1,R9,LSL #5                 ;  of chunk
sprite_putchunk_analyseyloop

        Push    "R0,R1"
        MOV     R10,#0
sprite_putchunk_analysexloop
        TST     R10,#31                 ;Get another word if we need to
        LDREQ   R2,[R0],#4
        LDREQ   R3,[R1],#4

        TST     R8,#&10000              ;Use mask?
        TSTEQ   R3,R8,LSR #24           ;If so, test for transparency
        MOVEQ   R7,#&100                ;Either set "transparent" colour
        ANDNE   R7,R2,R8,LSR #24        ;  or read pixel, as appropriate

        [       PSSprUseBBoxes

        MOV     R7,R7,LSL #2            ;Update high Y for this colour
        LDRB    LR,[R4,R7]
        CMP     R9,LR
        STRGTB  R9,[R4,R7]

        ADD     R7,R7,#1                ;Update high X for this colour
        LDRB    LR,[R4,R7]
        CMP     R10,LR
        STRGTB  R10,[R4,R7]

        ADD     R7,R7,#1                ;Update low Y for this colour
        LDRB    LR,[R4,R7]
        CMP     R9,LR
        STRLTB  R9,[R4,R7]

        ADD     R7,R7,#1                ;Update low X for this colour
        LDRB    LR,[R4,R7]
        CMP     R10,LR
        STRLTB  R10,[R4,R7]

        |

        STR     LR,[R4,R7,LSL #2]       ;Store boundary of chunk (so all used
                                        ;  colours have this bounding box)

        ]

        MOV     R2,R2,ROR R6            ;Advance to next pixel
        MOV     R3,R3,ROR R6
        ADD     R10,R10,R6
        CMP     R10,R5
        BLT     sprite_putchunk_analysexloop
        Pull    "R0,R1"

        ADD     R0,R0,#32               ;Advance to next row
        ADD     R1,R1,#32
        SUBS    R9,R9,#1                ;Note V is clear on exit from loop
        BGE     sprite_putchunk_analyseyloop
        Pull    "R0,R1,R7,R9,R10"

; The 'colourbounds' table now contains all the information we want. At this
; point, we want to select between printing strategies. This selection is
; done by the following algorithm:
;
;   IF transparent pixels exist THEN
;     print colour by colour, using 'imagemask'
;   ELSIF exactly one colour THEN
;     fill the chunk with this colour, using 'imagemask'
;   ELSIF monochrome output AND enough colours exist THEN
;     print all at once using an 8 bit/pixel 'image' operator
;   ELSIF "fill with largest colour" optimisation allowed THEN
;     fill the chunk with the colour with the largest extent, then
;       print the remaining colours one by one, using 'imagemask'
;   ELSE
;     print colour by colour, using 'imagemask'
;   ENDIF

        LDR     LR,[R4,#4*&100]
        TST     LR,#&800000                     ;Y values only go up to 63,
                                                ;  so any transparent pixel
                                                ;  will have cleared this
        DebugIf EQ, Medusa, "Colour by colour"
        BEQ     sprite_putchunk_colourbycolour  ;Note V is clear here

        ADD     R3,R4,#4*&FF
        MOV     R2,#0                           ;Initialise colour count
sprite_putchunk_countcolours
        LDR     LR,[R3],#-4
        TST     LR,#&800000
        ADDEQ   R2,R2,#1                        ;Count an existing colour
        CMP     R3,R4
        BGE     sprite_putchunk_countcolours

        Debug   Medusa, "Colour count was ", R2

        [       PSSprColLimit >= 256

        [       :LNOT:PSSprFillChunk
        CMP     R2,#1
        BNE     sprite_putchunk_colourbycolour
        ]
; Fall through to sprite_putchunk_fillandcols

        |

        CMP     R2,#1
        BEQ     sprite_putchunk_fillandcols

        LDR     LR,info_features
        TST     LR,#1
       [       PSSprFillChunk
        BNE     sprite_putchunk_fillandcols
        |
        BNE     sprite_putchunk_colourbycolour
        ]

        CMP     R2,#PSSprColLimit
        [       PSSprFillChunk
        BLT     sprite_putchunk_fillandcols
        |
        BLT     sprite_putchunk_colourbycolour
        ]

; We should output this sprite all at once, via an 'image' operator.
;   Currently, important register contents are:
; R0:      address of sprite data.
; R5:      width of the chunk in bits.
; R6:      bits/pixel.
; R7:      translation table pointer.
; R8:      Bit 16 set for unmasked plotting, clear for masked plotting.
;          Bits 31 to 24 are the pixel mask.
;          All other bits clear.
; R9:      height of the chunk in pixels.
; R10-R12: file handle and workspace pointers.
; 'spritelog2bpp' holds Log2(R6).

sprite_putchunk_allatonce
        Push    "R0-R4,R9"
        PrError sprite_putchunk_allatonce_return

        Debug   Medusa, "All at once; Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9

; Get height and width of bounding box and start printing the plane.

        LDR     LR,spritelog2bpp
        MOV     R4,R5,LSR LR

        PrPair  R4,R9
        PrLnIm  "SN"

; Now we just have to output the hex data.

        [       PSSprRLEncode
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
        MOV     LR,#0                           ;We're run-length encoding,
        STRB    LR,sprstringlen                 ;  so initialise byte counts.
        STR     LR,sprrepeatcount               ;NB 'sprlastbyte' irrelevant.
        ]

sprite_putchunk_allatonce_yloop
        MOV     R2,#0
        [       :LNOT:PSSprRLEncode
        MOV     R4,#33
        ]
sprite_putchunk_allatonce_xloop
        TST     R2,#31                          ;Get another word if it's
        LDREQ   R3,[R0,R2,LSR #3]               ;  needed

        AND     R1,R3,R8,LSR #24                ;Isolate pixel value

        CMP     R7,#0                           ;R7 could be a translation table, a palette or neither
        BEQ     sprite_putchunk_allatonce_pixval_lookup
        [ Medusa
        ADRL    LR, colourtrans32K              ;Is it our truecolour trans table?
        TEQ     R7, LR                          ;If so, pixel value is a valid grey level
        BEQ     sprite_putchunk_allatonce_gotgrey
        ]
      [ PSAllowHighTables
        TST     R7, #1 :SHL: 0                  ;If bit 0 is clear, it's a translation table;
      |
        TST     R7, #1 :SHL: 31                 ;If bit 31 is clear, it's a translation table;
      ]
        LDREQB  R1, [R7, R1]                    ;  get a byte representing a grey level
        BEQ     sprite_putchunk_allatonce_gotgrey
      [ PSAllowHighTables
        BIC     LR, R7, #1 :SHL: 0              ;If bit 0 is set, it's a 256-entry sprite palette
      |
        BIC     LR, R7, #1 :SHL: 31             ;If bit 31 is set, it's a 256-entry sprite palette
      ]
        LDR     R1, [LR, R1, LSL #3]            ; take the first 4 of the 8-byte entry
        B       sprite_putchunk_allatonce_rgbtogrey

sprite_putchunk_allatonce_pixval_lookup
        BL      pixval_lookup                   ;Otherwise, look up screen
sprite_putchunk_allatonce_rgbtogrey
        BL      colour_rgbtogrey                ;  RGB, then convert to grey
sprite_putchunk_allatonce_gotgrey

        [       PSSprRLEncode

        BL      sprite_outputbyte

        |

        SUBS    R4,R4,#1                        ;Print a newline at 32 byte
        BNE     sprite_putchunk_allatonce_cont  ;  boundaries
        PrNewLn FallThroughOnError
        [       PSDebugEscapes
        BLVC    readescapestate                 ;Check for escape, returning
        |
        SWIVC   XOS_ReadEscapeState             ;Check for escape, returning
        ]
        SETV    CS                              ;  error if so. NB top level
        PrPassError                             ;  will set R0 for us if so.
        ADD     R4,R4,#32
sprite_putchunk_allatonce_cont

        PrHex   R1                              ;Print the byte we just got

        ]

        ADD     R2,R2,R6                        ;Advance to next pixel and
        MOV     R3,R3,LSR R6                    ;  loop if necessary
        CMP     R2,R5
        BLT     sprite_putchunk_allatonce_xloop

        [       :LNOT:PSSprRLEncode
        PrNewLn FallThroughOnError
        [       PSDebugEscapes
        BLVC    readescapestate
        |
        SWIVC   XOS_ReadEscapeState             ;Check for escape, returning
        ]
        SETV    CS                              ;  error if so. NB top level
        PrPassError                             ;  will set R0 for us if so.
        ]

        SUB     R0,R0,#32                       ;Advance to next line
        SUB     R1,R1,#32
        SUBS    R9,R9,#1
        BGT     sprite_putchunk_allatonce_yloop

        [       PSSprRLEncode
        BL      sprite_endoutput
        ]

sprite_putchunk_allatonce_return
        STRVS   R0,[R13]
        Pull    "R0-R4,R9"

        PrError sprite_putchunk_return
        PrPassError

        B       sprite_putchunk_grestoreandreturn

        ]

sprite_putchunk_fillandcols

        [       PSSprFillChunk:LAND:PSSprUseBBoxes

; We want to find the colour with the largest extent in the sprite, fill
; the area with that colour, then print the remaining colours one by one.
;   Currently, important register contents are:
; R0:      address of sprite data.
; R1:      address of sprite mask.
; R4:      address of 'colourbounds' table.
; R6:      bits/pixel.
; R7:      translation table pointer.
; R8:      Bit 16 set for unmasked plotting, clear for masked plotting.
;          Bits 31 to 24 are the pixel mask.
;          All other bits clear.
; R10-R12: file handle and workspace pointers.

        Debug   Medusa, "fillandcols; Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9

        Push    "R7"
        ADD     R3,R4,#4*&100
        MOV     R7,#-1                          ;Init. largest area found
sprite_putchunk_findlargestcolour
        LDR     LR,[R3,#-4]!
        AND     R2,LR,#&FF0000                  ;Isolate low Y
        AND     R9,LR,#&FF                      ;Isolate high Y
        SUBS    R9,R9,R2,LSR #16                ;Get difference & check if
                                                ;  colour exists. If so:
        ADDGE   R9,R9,#1                        ;Get height
        MOVGE   R2,LR,LSR #24                   ;Isolate low X
        ANDGE   LR,LR,#&FF00                    ;Isolate high X
        RSBGE   R2,R2,LR,LSR #8                 ;Get difference
        MOVGE   R2,R2,LSR #3                    ;Calculate width, rounded up
        ADDGE   R2,R2,#1                        ;  to a number of bytes
        MULGE   LR,R2,R9                        ;Calculate bpp * (number of
                                                ;  bytes to output colour)
        CMPGE   LR,R7                           ;Larger than largest so far?
        MOVGE   R7,LR                           ;If so, update largest so far
        MOVGE   R5,R3                           ;  and remember which colour

        CMP     R3,R4
        BHI     sprite_putchunk_findlargestcolour

        Pull    "R7"

        LDR     R3,[R5]                         ;Get the bounding box of the
                                                ;  colour concerned
        |

; Either we are not using colour bounding boxes, in which case all colours
; have the same size, or there is only one colour. In either case, we want
; to find a colour that exists, fill the entire chunk with that colour, then
; print the remaining colours one by one.
;   Currently, important register contents are:
; R0:      address of sprite data.
; R1:      address of sprite mask.
; R4:      address of 'colourbounds' table.
; R6:      bits/pixel.
; R7:      translation table pointer.
; R8:      Bit 16 set for unmasked plotting, clear for masked plotting.
;          Bits 31 to 24 are the pixel mask.
;          All other bits clear.
; R10-R12: file handle and workspace pointers.

        ADD     R5,R4,#4*&100
sprite_putchunk_findacolour
        LDR     R3,[R5,#-4]!                    ;Does this colour exist?
        TST     R3,#&800000
        BNE     sprite_putchunk_findacolour

        ]

        BL      sprite_fillboundingbox          ;Fill the bounding box of the
        PrPassError                             ;  colour concerned

        MOV     R2,R5
        B       sprite_putchunk_remainingcols

sprite_putchunk_colourbycolour
        MOV     R2,#-1                  ;Don't use "fill with largest colour"
                                        ;  optimisation

sprite_putchunk_remainingcols

; We want to output all or all but one of the colours, one at a time, via
; the 'imagemask' operator.
;   Currently, important register contents are:
; R0:      address of sprite data.
; R1:      address of sprite mask.
; R2:      address of 'colourbounds' entry for colour to avoid plotting,
;          or -1 to plot all colours.
; R4:      address of 'colourbounds' table.
; R6:      bits/pixel.
; R7:      translation table pointer.
; R8:      Bit 16 set for unmasked plotting, clear for masked plotting.
;          Bits 31 to 24 are the pixel mask.
;          All other bits clear.
; R10-R12: file handle and workspace pointers.

        Debug   Medusa, "remainingcols; Regs: ", R0,R1,R2,R3,R4,R5,R6,R7,R8,R9

        ADD     R5,R4,#4*&FF                    ;Initialise loop counter,
        TEQ     R5,R2                           ;  avoiding the undesirable
        SUBEQ   R5,R5,#4                        ;  colour
sprite_putchunk_colourloop

        CLRV
        LDR     R3,[R5]                         ;Get bounding box, then
        TST     R3,#&800000                     ;  output colour if it exists

        BLEQ    sprite_putplane
        PrPassError

        SUB     R5,R5,#4                        ;Advance to next colour,
        TEQ     R5,R2                           ;  avoiding the undesirable
        SUBEQ   R5,R5,#4                        ;  colour
        CMP     R5,R4
        BHS     sprite_putchunk_colourloop

sprite_putchunk_grestoreandreturn
        BL      output_grestore

        PrError
sprite_putchunk_return
        STRVS   R0,[R13]
        Pull    "R0-R9,PC"

; Subroutine to output a specified rectangular chunk of a sprite's mask. The
; chunk to be printed has its top right hand corner at (R3,R4) and is of size
; (R5,R9).
; Entry: R0-R2 identify the sprite in the usual way.
;        R3 contains the right edge of the chunk to be plotted.
;        R4 contains the top edge of the chunk to be plotted.
;        R5 contains the width of the chunk to be plotted.
;        R6 contains the mode of the sprite.
;        R8 contains 0 if the sprite has no mask, 1 if is does have one.
;        R9 contains the height of the chunk to be plotted.
;        R10-R12 contain the file handle and workspace pointers as usual.
;        sourceclip_x,_y: source x and y offsets in pixels.  Normally 0.
;        The sprite pointed to by 'spritehandle' is suitable as a place into
;        which to copy the chunk to be plotted.
; Exit:  All registers preserved.

        [ Medusa
; For the time being, we take the simplest possible approach to changing
; this code to work with Medusa sprites.  Instead of switching output to the
; temporary sprite's mask (1bpp) we switch it to the temporary sprite's image (Nbpp).
; (The image part of the temporary sprites is otherwise unused in this code).
; The SpriteReason_PlotMaskScaled then scales the mask from 1bpp to Nbpp
; where N is the bpp of the source sprite.  The rest of the code then continues
; to work for old-format sprites, and also for new 1bpp mask sprites.
; The code will work correctly with all sprites with 1bpp masks, including
; 16 and 32bpp sprites.
;
; XXXX However, this strategy is not very efficient for sprites with large
; numbers of bits per pixel.  The code renders the mask in strips 256/N pixels
; wide, which means that there will be an excessive number of strips in the
; output.  As an optimisation, the code should be rejigged to take advantage
; of the fact that 256 pixel-wide strips can be output for sprites of all
; modes, providing they have 1bpp masks.  This is fairly low priority, though,
; as plotting the mask of a sprite to the printer is not a particularly common
; thing to do.
        ]

sprite_maskchunk
        Push    "R0-R9,LR"

; Convert R3,R4 to bottom left corner of chunk.

        SUB     R3,R3,R5
        SUB     R4,R4,R9

; This is pretty easy if there's no mask...

        TEQ     R8,#0
        BEQ     sprite_maskchunk_nomask

; There is a mask. The next major step is to transfer a copy of the chunk
; concerned to the sprite pointed to by 'spriteaddress'.

        Push    "R3-R5"

; Negate the bottom left corner and convert it to OS co-ordinates (this is
; the position at which we want to plot the given sprite in the one pointed
; at by 'spritehandle').

        RSB     R3,R3,#0
        RSB     R4,R4,#0

; Here we must allow for the altered source origin brought about by
; source clipping.  Simply subtract this offset from the bottom-left
; position in R3,R4.  Note that this is only used for obtaining the source data -
; the real values of R3,R4 have been pushed.

        Push    "R0-R2"

        LDR     r0, sourceclip_x
        LDR     r1, sourceclip_y
        SUB     R3, R3, R0
        SUB     R4, R4, R1

        MOV     R0,R6
        MOV     R1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        MOVVC   R3,R3,LSL R2

        MOVVC   R1,#VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   R4,R4,LSL R2

        STRVS   R0,[R13]
        Pull    "R0-R2"

; Transfer the mask data. Technique: switch output to the mask of the sprite
; pointed to by 'spriteaddress'. Clear it to zeroes, then plot the mask of
; the given sprite, using the inverting action.

        Push    "R0-R3"
        [ Medusa
        Debug   Medusa, "Switching output to sprite instead of mask"
        LDRVC   R0,=&200+SpriteReason_SwitchOutputToSprite
        LDRVC   R2,spritemskaddress
        |
        LDRVC   R0,=&200+SpriteReason_SwitchOutputToMask
        LDRVC   R2,spriteaddress
        ]
        ADRVCL  R1,sprarea
        MOVVC   R3,#0
        SWIVC   XOS_SpriteOp
        ADRVCL  LR,oldspritestate
        STMVCIA LR,{R0-R3}
        STRVS   R0,[R13]
        Pull    "R0-R3"
        BVS     sprite_maskchunk_chunktransferred

        SWI     XOS_WriteI+16           ;Current background must be zeroes
                                        ;  after the output switch, so we can
                                        ;  do a CLG immediately.

        SWIVC   XOS_WriteI+18           ;Set inverting background
        SWIVC   XOS_WriteI+4
        SWIVC   XOS_WriteI+128

        Push    "R6"
        BICVC   R0,R0,#&FF              ;Plot this sprite's mask
        ORRVC   R0,R0,#SpriteReason_PlotMaskScaled
        MOV     R6, #0                  ; No scaling
        SWIVC   XOS_SpriteOp
        Pull    "R6"

        Push    "R0-R3,R10"
        SavePSR R10
        ADRL    LR,oldspritestate
        LDMIA   LR,{R0-R3}
        SWI     XOS_SpriteOp
        STRVS   R0,[R13]
        RestPSR R10,VC,f                ;Collect up V flags
        Pull    "R0-R3,R10"

sprite_maskchunk_chunktransferred
        Pull    "R3-R5"

; The chunk we want to plot is now safely in the mask of the sprite pointed
; to by 'spriteaddress'.
;   Currently, important register contents are:
; R3,R4:   pixel co-ordinates of where we want to plot the current chunk.
; R5:      width of the chunk in pixels.
; R6:      sprite mode.
; R9:      height of the chunk in pixels.
; R10-R12: file handle and workspace pointers.

; Now we change the X co-ordinates to bits, then translate the co-ordinate
; system to the chunk origin.

        PrError sprite_maskchunk_return

        MOVVC   R0,R6
        MOVVC   R1,#VduExt_Log2BPC
        SWIVC   XOS_ReadModeVariable
        MOVVC   R3,R3,LSL R2
        MOVVC   R5,R5,LSL R2

        MOVVC   R1,#VduExt_Log2BPP              ;To interpret colours in the
        SWIVC   XOS_ReadModeVariable            ;  data, we need this form
        MOVVC   R6,R2                           ;  of Log2(bits/pixel)
        STRVC   R6,spritelog2bpp
        BLVC    output_gsave
        BLVC    sprite_translatebyR3R4
        PrPassError

; The next step is to scan the chunk we are to plot, to find interesting
; information about the non-zero mask pixels.

        [ Medusa
        LDR     LR,spritemskaddress
        LDR     R0,[LR,#spImage]                ;The mask data is actually in the image
        |
        LDR     LR,spriteaddress
        LDR     R0,[LR,#spTrans]                ;Get transparency mask offset
        ]
        ADD     R0,LR,R0                        ;Convert to address, with
        ADD     R0,R0,#63*32                    ;  origin at bottom left

        MOV     LR,#1                           ;Calculate bits/pixel
        MOV     R6,LR,LSL R6
        RSB     R8,LR,LR,LSL R6                 ;And pixel mask

        [       PSSprUseBBoxes

; Now do the analysis: we want the bounding box and information about
; whether transparent pixels exist.
;   Important register contents are:
; R0:      address of sprite mask.
; R1:      (will be used for high X).
; R2:      (will be used for high Y).
; R3:      (will be used for low X).
; R4:      (will be used for low Y).
; R5:      width of the chunk in bits.
; R6:      bits/pixel.
; R7:      (will be used to indicate existence of a transparent pixel).
; R8:      pixel mask.
; R9:      height of the chunk in pixels.
; R10-R12: file handle and workspace pointers.

        MOV     R1,#0
        MOV     R2,#0
        MOV     R3,#&FF
        MOV     R4,#&FF
        MOV     R7,#0

        Push    "R0,R9,R10"
        SUB     R9,R9,#1
        SUB     R0,R0,R9,LSL #5                 ;Shift origin to top left
sprite_maskchunk_analyseyloop

        Push    "R0"
        MOV     R10,#0
sprite_maskchunk_analysexloop
        TST     R10,#31                 ;Get another word if we need to
        LDREQ   LR,[R0],#4

        TST     LR,R8                   ;Check for transparency
        MOVEQ   R7,#1                   ;Record its existence if found
        BEQ     sprite_maskchunk_analysexloop_end

        CMP     R2,R9                   ;Update high Y
        MOVLT   R2,R9
        CMP     R1,R10                  ;Update high X
        MOVLT   R1,R10
        CMP     R4,R9                   ;Update low Y
        MOVGT   R4,R9
        CMP     R3,R10                  ;Update low X
        MOVGT   R3,R10

sprite_maskchunk_analysexloop_end
        MOV     LR,LR,ROR R6            ;Advance to next pixel
        ADD     R10,R10,R6
        CMP     R10,R5
        BLT     sprite_maskchunk_analysexloop
        Pull    "R0"

        ADD     R0,R0,#32               ;Advance to next row
        SUBS    R9,R9,#1                ;Note V is clear on exit from loop
        BGE     sprite_maskchunk_analyseyloop
        Pull    "R0,R9,R10"

        CMP     R1,R3                   ;Any pixels? Return if not. NB V:=0
        BLT     sprite_maskchunk_grestoreandreturn

        |

; Now do the analysis: we want information about whether tranparent and
; non-transparent pixels exist. This code also sets up a fake bounding box in
; R1-R4 to fit in with the optimised case above.
;   Important register contents are:
; R0:      address of sprite mask.
; R1:      (will be used to indicate existence of a non-transparent pixel).
; R5:      width of the chunk in bits.
; R6:      bits/pixel.
; R7:      (will be used to indicate existence of a transparent pixel).
; R8:      pixel mask.
; R9:      height of the chunk in pixels.
; R10-R12: file handle and workspace pointers.

        MOV     R1,#0
        MOV     R7,#0

        SUB     R2,R9,#1
        SUB     R4,R0,R2,LSL #5         ;Shift origin to top left
sprite_maskchunk_analyseyloop

        Push    "R4"
        MOV     R3,#0
sprite_maskchunk_analysexloop
        TST     R3,#31                  ;Get another word if we need to
        LDREQ   LR,[R4],#4

        TST     LR,R8                   ;Check for transparency
        MOVEQ   R7,#1                   ;Record transparency or
        MOVNE   R1,#1                   ;  non-transparency as found

        TST     R1,R7                   ;Finished if both have been found
        Pull    "R4",NE
        BNE     sprite_maskchunk_analysisdone

        MOV     LR,LR,ROR R6            ;Advance to next pixel
        ADD     R3,R3,R6
        CMP     R3,R5
        BLT     sprite_maskchunk_analysexloop
        Pull    "R4"

        ADD     R4,R4,#32               ;Advance to next row
        SUBS    R2,R2,#1                ;Note V is clear on exit from loop
        BGE     sprite_maskchunk_analyseyloop

sprite_maskchunk_analysisdone
        CMP     R1,#0                   ;Any pixels? Return if not. NB V:=0
        BEQ     sprite_maskchunk_grestoreandreturn

        SUB     R1,R5,R6                ;Generate fake bounding box
        SUB     R2,R9,#1
        MOV     R3,#0
        MOV     R4,#0

        ]

; We've now got the bounding box and simply want to output the mask by
; using an appropriately sized 'imagemask' operation. Translate to the
; bottom left corner of the bounding box.

        BL      sprite_translatebyR3R4
        PrPassError

        SUB     R0,R0,R4,LSL #5                 ;Address bottom of box

; Get height and width of bounding box and start printing the plane.

        SUB     R4,R2,R4                        ;Get height of bounding box
        ADD     R4,R4,#1

        SUB     R9,R1,R3                        ;Get width in pixels
        LDR     LR,spritelog2bpp
        MOV     R9,R9,LSR LR
        ADD     R9,R9,#1

        PrPair  R9,R4

; If no transparent pixels exist, we can avoid outputting the main load of
; data. Otherwise start outputting.

        TEQ     R7,#0
        BEQ     sprite_maskchunk_fillchunk
        PrLnIm  "S1"

; Now we just have to output the hex data.

        [       PSSprRLEncode
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
        MOV     LR,#0                           ;We're run-length encoding,
        STRB    LR,sprstringlen                 ;  so initialise byte counts.
        STR     LR,sprrepeatcount               ;NB 'sprlastbyte' irrelevant.
        ]

sprite_maskchunk_yloop
        Push    "R3"

        BIC     LR,R3,#31                       ;Get first mask word, then
        LDR     R2,[R0,LR,LSR #3]               ;  shift it into the correct
        AND     LR,R3,#31                       ;  position for the first
        MOV     R2,R2,LSR LR                    ;  pixel
        MOV     R9,#&800000                     ;Put a sentinel bit in R9, to
                                                ;  output after 9 data bits
sprite_maskchunk_xloop
        TST     R3,#31                          ;Get another word if it's
        LDREQ   R2,[R0,R3,LSR #3]               ;  needed

        TST     R2,R8                           ;Test for transparency and
        ORRNE   R9,R9,#&400000                  ;  set output bit if not.

        CLRV
        MOVS    R9,R9,LSL #1                    ;Shift output data up, then
        BLCS    sprite_putmaskbyte              ;  output and clear a byte if
        BVS     sprite_maskchunk_yloopexit      ;  the sentinel bit appeared

        ADD     R3,R3,R6                        ;Advance to next pixel and
        MOV     R2,R2,LSR R6                    ;  loop if necessary
        CMP     R3,R1
        BLE     sprite_maskchunk_xloop

sprite_maskchunk_padloop
        MOVS    R9,R9,LSL #1                    ;Output whatever data remains
        BCC     sprite_maskchunk_padloop        ;  in R7, first padding with
        BL      sprite_putmaskbyte              ;  zeroes to a byte boundary
                                                ;  (Note there is at least 1
                                                ;  bit waiting for output.)

        [       :LNOT:PSSprRLEncode
        BVS     sprite_maskchunk_yloopexit
        PrNewLn FallThroughOnError
        [       PSDebugEscapes
        BLVC    readescapestate                 ;Check for escape, return
        |
        SWIVC   XOS_ReadEscapeState             ;Check for escape, return
        ]
        SETV    CS                              ;  error if so. NB top level
                                                ;  will set R0 for us if so
        ]

sprite_maskchunk_yloopexit
        Pull    "R3"
        PrPassError

        SUB     R0,R0,#32                       ;Advance to next line
        SUBS    R4,R4,#1                        ;NB clears V on last
        BGT     sprite_maskchunk_yloop          ;  iteration

        [       PSSprRLEncode
        BL      sprite_endoutput
        ]

        B       sprite_maskchunk_grestoreandreturn

; The sprite has no mask - this is pretty easy!
;   Currently, important register contents are:
; R3,R4:   pixel co-ordinates of where we want to plot the current chunk.
; R5:      width of the chunk in pixels.
; R6:      sprite mode.
; R9:      height of the chunk in pixels.
; R10-R12: file handle and workspace pointers.

sprite_maskchunk_nomask

; Now we change the X co-ordinates to bits, then translate the co-ordinate
; system to the chunk origin.

        MOV     R0,R6
        MOV     R1,#VduExt_Log2BPC
        SWI     XOS_ReadModeVariable
        MOVVC   R3,R3,LSL R2
        MOVVC   R5,R5,LSL R2

        MOVVC   R1,#VduExt_Log2BPP              ;To interpret colours in the
        SWIVC   XOS_ReadModeVariable            ;  data, we need this form
        MOVVC   R6,R2                           ;  of Log2(bits/pixel)
        STRVC   R6,spritelog2bpp
        BLVC    output_gsave
        BLVC    sprite_translatebyR3R4
        PrPassError

; Output height and width of bounding box and print the plane.

        LDR     LR,spritelog2bpp                ;Get width in pixels
        MOV     R5,R5,LSR LR

        PrPair  R5,R9

sprite_maskchunk_fillchunk
        PrStrIm "SF ",FallThroughOnError

sprite_maskchunk_grestoreandreturn
        BLVC    output_grestore

        PrError
sprite_maskchunk_return
        STRVS   R0,[R13]
        Pull    "R0-R9,PC"

        LTORG

; Subroutine to fill the bounding box of a given colour with that colour.
; Entry: R3 = bounding box of colour concerned, in 'colourbounds' format.
;        R4 points to 'colourbounds' table.
;        R5 points to 'colourbounds' entry for this colour.
;        R7 = translation table pointer.
;        R10-R12: file handle and workspace pointers.
; Exit:  All registers preserved.

sprite_fillboundingbox
        Push    "R2,R3,R4,R7,R9,LR"
        PrError sprite_fillboundingbox_return

        BL      sprite_setcolour
        BLVC    output_gsave

        MOVVC   LR,#&FF                         ;Isolate left, bottom, right
        ANDVC   R2,LR,R3,LSR #8                 ;  and top co-ordinates of
        ANDVC   R4,LR,R3,LSR #16                ;  bounding box
        ANDVC   R7,LR,R3
        MOVVC   R3,R3,LSR #24

        BLVC    sprite_translatebyR3R4
        PrPassError

; Get height and width of bounding box and start printing the plane.

        SUB     R4,R7,R4                        ;Get height of bounding box
        ADD     R4,R4,#1

        SUB     R9,R2,R3                        ;Get width in pixels
        LDR     LR,spritelog2bpp
        MOV     R9,R9,LSR LR
        ADD     R9,R9,#1

        PrPair  R9,R4
        PrStrIm "SF ",FallThroughOnError
        BLVC    output_grestore

        PrError
sprite_fillboundingbox_return
        Pull    "R2,R3,R4,R7,R9,PC"

; Subroutine to output the pixels of a given colour via an 'imagemask'
; operator.
; Entry: R0 = address of sprite data.
;        R1 = address of sprite mask.
;        R3 = bounding box of colour concerned, in 'colourbounds' format.
;        R4 points to 'colourbounds' table.
;        R5 points to 'colourbounds' entry for this colour.
;        R6 = bits/pixel.
;        R7 = translation table pointer.
;        R8: bit 16 set for unmasked plotting, clear for masked plotting;
;            bits 31 to 24 are the pixel mask;
;            all other bits clear.
;        R10-R12: file handle and workspace pointers.
;        'spritelog2bpp' holds Log2(R6).
; Exit:  All registers preserved.

sprite_putplane
        Push    "R0-R5,R7,R9,LR"
        PrError sprite_putplane_return

; Set up correct colour

        BL      sprite_setcolour
        BLVC    output_gsave

        SUBVC   R5,R5,R4                        ;Get correct pixel value
        MOVVC   R5,R5,LSR #2

; Get bounding box co-ordinates and translate co-ordinate system to its
; bottom left corner.

        MOVVC   LR,#&FF                         ;Isolate left, bottom, right
        ANDVC   R2,LR,R3,LSR #8                 ;  and top co-ordinates of
        ANDVC   R4,LR,R3,LSR #16                ;  bounding box
        ANDVC   R7,LR,R3
        MOVVC   R3,R3,LSR #24

        BLVC    sprite_translatebyR3R4
        PrPassError

        SUB     R0,R0,R4,LSL #5                 ;Address bottom of bounding
        SUB     R1,R1,R4,LSL #5                 ;  box in sprite data & mask

; Get height and width of bounding box and start printing the plane.

        SUB     R4,R7,R4                        ;Get height of bounding box
        ADD     R4,R4,#1

        SUB     R9,R2,R3                        ;Get width in pixels
        LDR     LR,spritelog2bpp
        MOV     R9,R9,LSR LR
        ADD     R9,R9,#1

        PrPair  R9,R4
        PrLnIm  "S1"

; Now we just have to output the hex data.

        [       PSSprRLEncode
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
        MOV     LR,#0                           ;We're run-length encoding,
        STRB    LR,sprstringlen                 ;  so initialise byte counts.
        STR     LR,sprrepeatcount               ;NB 'sprlastbyte' irrelevant.
        ]

sprite_putplane_yloop
        Push    "R3,R4"

        BIC     LR,R3,#31                       ;Get first data and mask
        LDR     R4,[R0,LR,LSR #3]               ;  words, then shift them
        LDR     R7,[R1,LR,LSR #3]               ;  into the correct position
        AND     LR,R3,#31                       ;  for the first pixel
        MOV     R4,R4,LSR LR
        MOV     R7,R7,LSR LR
        MOV     R9,#&800000                     ;Put a sentinel bit in R9, to
                                                ;  output after 9 data bits
sprite_putplane_xloop
        TST     R3,#31                          ;Get another word if it's
        LDREQ   R4,[R0,R3,LSR #3]               ;  needed
        LDREQ   R7,[R1,R3,LSR #3]

        TST     R8,#&10000                      ;Use mask?
        TSTEQ   R7,R8,LSR #24                   ;If so, test for transparency
        MOVEQ   LR,#&100                        ;Set "transparent" colour or
        ANDNE   LR,R4,R8,LSR #24                ;  read pixel, as appropriate

        CMP     LR,R5                           ;Check for correct colour and
        ORREQ   R9,R9,#&400000                  ;  set output bit if found.
                                                ;  Clear V into the bargain.

        MOVS    R9,R9,LSL #1                    ;Shift output data up, then
        BLCS    sprite_putmaskbyte              ;  output and clear a byte if
        BVS     sprite_putplane_yloopexit       ;  the sentinel bit appeared

        ADD     R3,R3,R6                        ;Advance to next pixel and
        MOV     R4,R4,LSR R6                    ;  loop if necessary
        MOV     R7,R7,LSR R6
        CMP     R3,R2
        BLE     sprite_putplane_xloop

sprite_putplane_padloop
        MOVS    R9,R9,LSL #1                    ;Output whatever data remains
        BCC     sprite_putplane_padloop         ;  in R7, first padding with
        BL      sprite_putmaskbyte              ;  zeroes to a byte boundary
                                                ;  (Note there is at least 1
                                                ;  bit waiting for output.)
        [       :LNOT:PSSprRLEncode
        BVS     sprite_putplane_yloopexit
        PrNewLn FallThroughOnError
        [       PSDebugEscapes
        BLVC    readescapestate                 ;Check for escape, return
        |
        SWIVC   XOS_ReadEscapeState             ;Check for escape, return
        ]
        SETV    CS                              ;  error if so. NB top level
                                                ;  will set R0 for us if so
        ]

sprite_putplane_yloopexit
        Pull    "R3,R4"
        PrPassError

        SUB     R0,R0,#32                       ;Advance to next line
        SUB     R1,R1,#32
        SUBS    R4,R4,#1
        BGT     sprite_putplane_yloop

        [       PSSprRLEncode
        BL      sprite_endoutput
        BLVC    output_grestore
        |
        BL      output_grestore
        ]

        PrError
sprite_putplane_return
        STRVS   R0,[R13]
        Pull    "R0-R5,R7,R9,PC"

        [       PSSprRLEncode

; Subroutine to output the high byte of R9, then clear this byte and set a
; new sentinel bit, preserving the extra output data bit held in bit 23.

sprite_putmaskbyte
        Push    "R1,LR"

        [       PSSprInverted
        MVN     R1,R9,LSR #24
        |
        MOV     R1,R9,LSR #24
        ]
        BIC     R9,R9,#&FF000000
        ORR     R9,R9,#&01000000                ;Set sentinel bit to output
                                                ;  after 8 more data bits
        BL      sprite_outputbyte
        Pull    "R1,PC"

; Subroutine to terminate the run-length encoding of data, purging all
; data in buffers to the file. Preserves all registers.

sprite_endoutput
        Push    "R0-R1,R4,LR"
        LDRB    LR,joblevel2
        CMP     LR,#0
        BEQ     sprite_endoutput_notL2
        MOV     R1,#&100                ;Start a fake new run of a non-byte
        BL      sprite_outputbyte       ;  value
        LDRVCB  R4,sprstringlen         ;Then output any remaining string
        BLVC    sprite_outputstring_L2
        MOVVC   R0,#128                 ;Level2 RLE end-of-data
        BLVC    ascii85_byte
        BLVC    ascii85_end
        STRVS   R0,[SP]
        Pull    "R0-R1,R4,PC"
sprite_endoutput_notL2
        MOV     R1,#&100                ;Start a fake new run of a non-byte
        BL      sprite_outputbyte       ;  value
        LDRVCB  R4,sprstringlen         ;Then output any remaining string
        BLVC    sprite_outputstring
        STRVS   R0,[SP]
        Pull    "R0-R1,R4,PC"

; Subroutine to output the byte in R1 through the run-length encoding
; mechanism. The value in R1 is assumed to be a byte value and is never
; actually output by the current call to this routine (the worst that happens
; is that we end with an empty string and a run of length 1 of this byte).
;   This allows us to clear up at the end of our data by first calling
; this routine with R1 not a byte value (which will definitely result in
; a string - possibly empty - followed by a run of length one), then calling
; 'sprite_outputstring' below to output any remaining string.

sprite_outputbyte
        Push    "R1-R4,LR"
        PrError sprite_outputbyte_return

        LDRB    R2,joblevel2
        CMP     R2,#0
        BNE     sprite_outputbyte_L2_pushdone

; Get current state of run-length encoding algorithm.

        LDRB    R2,sprlastbyte                  ;Last byte encountered
        LDRB    R4,sprstringlen                 ;Current length of string
        LDR     R3,sprrepeatcount               ;Repeat count for this byte

; Is this byte the same as the last one? If so, we just increment the repeat
; count and return.

        CMP     R1,R2
        ADDEQ   R3,R3,#1
        BEQ     sprite_outputbyte_storeandreturn        ;NB V=0 if taken

; This byte is distinct from the last one. We have a choice of three
; strategies:
;   (1) We can append the last run of identical bytes to the end of the
;       string and start a new run of identical bytes.
;   (2) We can output the string, then restart with a string equal to the
;       last run of identical bytes and a new run of identical bytes.
;   (3) We can output the string followed by the last run of identical bytes,
;       then restart with an empty string and a new run of identical bytes.
; We choose the first strategy if (a) it will not increase the length of the
; string above 'PSSprRLMaxStr' bytes, and (b) the last sequence of
; identical bytes is less than 'PSSprRLMinRun' + 2 bytes long - i.e. we
; probably won't waste output volume by appending the sequence of identical
; bytes.
;   Otherwise, we choose the second strategy if it probably won't waste
; output volume - i.e. if the last run of identical bytes is not more than
; 'PSSprRLMinRun' bytes long.

        ADD     LR,R3,R4
        CMP     LR,#PSSprRLMaxStr       ;First condition
        CMPLS   R3,#PSSprRLMinRun+1     ;Second condition
        BLS     sprite_outputbyte_extendandstartrun

; We are going to adopt the second or third strategy, so output the string.
; Note we have an empty string (i.e. R4=0) after this call.

        BL      sprite_outputstring
        PrPassError

; Now adopt the second strategy if 'sprrepeatcount' <= 'PSSprRLMinRun', the
; third otherwise.

        CMP     R3,#PSSprRLMinRun
        BLO     sprite_outputbyte_extendandstartrun
        BL      sprite_outputrun
        B       sprite_outputbyte_startrun

; Extend the string we've got by R3 bytes equal to R2, then start a new
; run of identical bytes.

sprite_outputbyte_extendandstartrun
        ADRL    LR,sprstring
        CMP     R3,#0
sprite_outputbyte_extendloop
        STRNEB  R2,[LR,R4]
        ADDNE   R4,R4,#1
        SUBNES  R3,R3,#1
        BNE     sprite_outputbyte_extendloop    ;NB V=0 if not taken

; Start a new run of identical bytes.

sprite_outputbyte_startrun
        MOVVC   R2,R1
        MOVVC   R3,#1

; Store new state of run-length encoding algorithm and return.

        STRVCB  R2,sprlastbyte                  ;Last byte encountered
        STRVCB  R4,sprstringlen                 ;Current length of string
sprite_outputbyte_storeandreturn
        STRVC   R3,sprrepeatcount               ;Repeat count for this byte

        PrError
sprite_outputbyte_return
        Pull    "R1-R4,PC"

; Subroutine to output the byte count held in R4 as a decimal integer, then a
; space, then the R4 bytes starting at 'sprstring' as hex data, then a new
; line. Does nothing if R4=0. Returns with R4=0, all other registers
; unchanged.

sprite_outputstring
        [       PSSprRLMaxStr > 32
        Push    "R0,R1,R2,LR"
        |
        Push    "R0,R1,LR"
        ]
        PrError sprite_outputstring_return

        CMP     R4,#0                           ;NB clears V
        BEQ     sprite_outputstring_return

        PrNumSp R4

        ADRL    R1,sprstring
        [       PSSprRLMaxStr > 32
        MOV     R2,#33
        ]
sprite_outputstring_loop
        [       PSSprRLMaxStr > 32
        SUBS    R2,R2,#1
        BNE     sprite_outputstring_continue
        PrNewLn
        MOV     R2,#32
sprite_outputstring_continue
        ]
        LDRB    R0,[R1],#1
        PrHex   R0,CorruptR0
        SUBS    R4,R4,#1
        BNE     sprite_outputstring_loop

        PrNewLn FallThroughOnError
        [       PSDebugEscapes
        BLVC    readescapestate                 ;Check for ESCAPE, return
        |
        SWIVC   XOS_ReadEscapeState             ;Check for ESCAPE, return
        ]
        SETV    CS                              ;  error if so. NB top level
                                                ;  will set R0 for us if so
sprite_outputstring_return
        STRVS   R0,[R13]
        [       PSSprRLMaxStr > 32
        Pull    "R0,R1,R2,PC"
        |
        Pull    "R0,R1,PC"
        ]

; Subroutine to output the repeat count held in R3, negated, then a space,
; then the byte value held in R2, then a new line. Preserves all registers.

sprite_outputrun
        Push    "R0,LR"
        PrError sprite_outputrun_return

        RSB     R0,R3,#0
        PrNumSp R0,CorruptR0
        PrNum   R2,CorruptR0

        PrNewLn FallThroughOnError
        [       PSDebugEscapes
        BLVC    readescapestate                 ;Check for ESCAPE, return
        |
        SWIVC   XOS_ReadEscapeState             ;Check for ESCAPE, return
        ]
        SETV    CS                              ;  error if so. NB top level
                                                ;  will set R0 for us if so
        PrError
sprite_outputrun_return
        STRVS   R0,[R13]
        Pull    "R0,PC"


;following RLE routines very similar to above, but use Level2 RLE style
;and ASCII85 encoding, instead of hex


sprite_outputbyte_L2
        Push    "R1-R4,LR"        ;MUST match push in sprite_outputbyte
        PrError sprite_outputbyte_L2_return

sprite_outputbyte_L2_pushdone
; Get current state of run-length encoding algorithm.

        LDRB    R2,sprlastbyte                  ;Last byte encountered
        LDRB    R4,sprstringlen                 ;Current length of string
        LDR     R3,sprrepeatcount               ;Repeat count for this byte

; Is this byte the same as the last one? If so, we just increment the repeat
; count and return.

        CMP     R1,R2
        ADDEQ   R3,R3,#1
        BEQ     sprite_outputbyte_L2_storeandreturn        ;NB V=0 if taken

;distinct
        ADD     LR,R3,R4
        CMP     LR,#PSSprRLMaxStrL2     ;First condition
        CMPLS   R3,#PSSprRLMinRunL2+1   ;Second condition
        BLS     sprite_outputbyte_L2_extendandstartrun

        BL      sprite_outputstring_L2
        PrPassError

        CMP     R3,#PSSprRLMinRunL2
        BLO     sprite_outputbyte_L2_extendandstartrun
        BL      sprite_outputrun_L2
        B       sprite_outputbyte_L2_startrun

sprite_outputbyte_L2_extendandstartrun
        ADRL    LR,sprstring
        CMP     R3,#0
sprite_outputbyte_L2_extendloop
        STRNEB  R2,[LR,R4]
        ADDNE   R4,R4,#1
        SUBNES  R3,R3,#1
        BNE     sprite_outputbyte_L2_extendloop    ;NB V=0 if not taken

sprite_outputbyte_L2_startrun
        MOVVC   R2,R1
        MOVVC   R3,#1

        STRVCB  R2,sprlastbyte                  ;Last byte encountered
        STRVCB  R4,sprstringlen                 ;Current length of string
sprite_outputbyte_L2_storeandreturn
        STRVC   R3,sprrepeatcount               ;Repeat count for this byte

        PrError
sprite_outputbyte_L2_return
        Pull    "R1-R4,PC"

sprite_outputstring_L2
        Push    "R0,R1,LR"
        PrError sprite_outputstring_L2_return
        CMP     R4,#0                           ;NB clears V
        BEQ     sprite_outputstring_L2_return
        SUB     R0,R4,#1    ;length byte = n-1
        BL      ascii85_byte
        BVS     sprite_outputstring_L2_return
        ADRL    R0,sprstring
        MOV     R1,R4
        BL      ascii85_block
sprite_outputstring_L2_return
        STRVS   R0,[R13]
        MOV     R4,#0       ;required to mirror sprite_outputstring
        Pull    "R0,R1,PC"

sprite_outputrun_L2
        Push    "R0,R1,R3,LR"
        PrError sprite_outputrun_L2_return
sprite_outputrun_L2_loop
        MOV     R1,R3
        CMP     R1,#128
        MOVGT   R1,#128       ;max run 128
        RSB     R0,R1,#256
        ADD     R0,R0,#1      ;length byte for run = 257-n
        BL      ascii85_byte
        BVS     sprite_outputrun_L2_return
        MOV     R0,R2
        BL      ascii85_byte   ;value byte for run
        BVS     sprite_outputrun_L2_return
        SUBS    R3,R3,R1
        BNE     sprite_outputrun_L2_loop
        [       PSDebugEscapes
        BLVC    readescapestate                 ;Check for ESCAPE, return
        |
        SWIVC   XOS_ReadEscapeState             ;Check for ESCAPE, return
        ]
        SETV    CS
sprite_outputrun_L2_return
        STRVS   R0,[R13]
        Pull    "R0,R1,R3,PC"


;end of RLE conditional stuff
        |

; Subroutine to output the high byte of R9, then clear this byte and set a
; new sentinel bit, preserving the extra output data bit held in bit 23.

sprite_putmaskbyte
        Push    "R0,LR"

        [       PSSprInverted
        MVN     R0,R9,LSR #24
        |
        MOV     R0,R9,LSR #24
        ]

        BIC     R9,R9,#&FF000000
        ORR     R9,R9,#&01000000                ;Set sentinel bit to output
                                                ;  after 8 more data bits
        PrHex   R0,CorruptR0,FallThroughOnError

        STRVS   R0,[R13]
        Pull    "R0,PC"

        ]

; Subroutine to set a given colour for a sprite.
; Entry: R4 points to 'colourbounds' table.
;        R5 points to 'colourbounds' entry for this colour.
;        R7 = translation table pointer.
;        R10-R12: file handle and workspace pointers.
; Exit:  All registers preserved.

sprite_setcolour
        Push    "R1,LR"

; R5-R4 is four times a sprite pixel value. We need to find the corresponding
; RGB combination.
;   This is rather tricky. The solution used depends on whether a translation
; table is specified in the call. If it isn't, the value is looked up as a
; pixel value for the current screen mode (this is just about the only thing
; we CAN do).
;   If it is, we assume that the values in the translation table have been
; produced by the intercepted ColourTrans calls. If this is a monochrome
; version of the printer driver, this value is simply a grey scale value. If
; this is a colour version, we have to look up the value in the 'pixelvalues'
; table.

        SUB     R1,R5,R4
        CMP     R7,#0                   ;Translation table/palette available?
        BNE     sprite_setcolour_translate
        MOV     R1,R1,LSR #2            ;If neither, go and look
        BL      pixval_lookup           ;  up screen RGB combination.
        B       sprite_setcolour_gotrgb
sprite_setcolour_translate
      [ PSAllowHighTables
        TST     R7, #1 :SHL: 0          ;Is it a translation table or a palette?
        BICNE   LR, R7, #1 :SHL: 0      ;If palette, look up the RGB value from the
      |
        TST     R7, #1 :SHL: 31         ;Is it a translation table or a palette?
        BICNE   LR, R7, #1 :SHL: 31     ;If palette, look up the RGB value from the
      ]      
        LDRNE   R1,[LR,R1,LSL #1]       ;  palette entry (first 4 of the 8 bytes)
        BNE     sprite_setcolour_gotrgb
        [ Medusa
        ADRL    LR, colourtrans32K      ;Is it our truecolour translation table?
        TEQ     LR, R7                  ;  If so, the translation has already been done
        MOVEQ   R1, R1, LSR #2          ;  when we plotted the chunk into the temporary
        BEQ     sprite_setcolour_grey   ;  sprite, so just expand this grey level to RGB
        ]
        LDRB    R1,[R7,R1,LSR #2]       ;If translating, look the pixel value
                                        ;  up in the translation table.
        LDR     LR,info_features        ;If output is destined for a colour
        TST     LR,#1                   ;  printer, look the result up in the
        ADRNEL  LR,pixelvalues          ;  'pixelvalues' table.
        LDRNE   R1,[LR,R1,LSL #2]
sprite_setcolour_grey
        ORREQ   R1,R1,R1,LSL #8         ;If for a monochrome printer, expand
        ORREQ   R1,R1,R1,LSL #16        ;  grey level to rgb. No need to
                                        ;  clear the bottom byte.
sprite_setcolour_gotrgb

        BL      colour_setrealrgb
        [       PSCoordSpeedUps
        BLVC    colour_ensure
        ]
        Pull    "R1,PC"

; Subroutine to translate the co-ordinate system by the vector held in
; R3,R4. Optimises out translations by 0,0. Preserves all registers.

sprite_translatebyR3R4
        Push    "R0,R1,LR"
        PrError sprite_translatebyR3R4_return

        CLRV
        ORRS    LR,R3,R4
        BEQ     sprite_translatebyR3R4_return

        PrPair  R3,R4,CorruptR0andR1
        PrLnIm  "T",FallThroughOnError

sprite_translatebyR3R4_return
        STRVS   R0,[R13]
        Pull    "R0,R1,PC"


        [ Medusa

; Subroutine to generate a ColourTrans translation table suitable for
; mapping from a 16/32bpp truecolour sprite onto 256 grey levels.
; The table is generated in the RMA, and its address is stored in
; the three-word anchor block 'colourtrans32K'
;
; Returns the address of the anchor block in R7

sprite_make32Ktable
        Push    "R0-R5,LR"

        [ debugMedusa
        SWI     XOS_ReadMonotonicTime
        Debug   Medusa, "** Start time ", R0
        ]
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #32 * 1024
        SWI     XOS_Module
        MOVVC   R4, R2                          ; get ptr into R4
        STRVS   R0, [SP]
        Pull    "R0-R5,PC",VS

        MOV     R0, #1 :SHL: 15
        SUB     R0, R0, #1                      ; 2_11111 11111 11111
        MOV     R5, #2_11111000
00
        AND     R3, R5, R0, LSL #3
        ORR     R3, R3, R3, LSR #5
        AND     R2, R5, R0, LSR #2
        ORR     R2, R2, R2, LSR #5
        AND     R1, R5, R0, LSR #7
        ORR     R1, R1, R1, LSR #5
        BL      colour_rgbcomponentstogray      ; R1 gets gray level (0-255)
        STRB    R1, [R4, R0]                    ; put it in the table
        SUBS    R0, R0, #1
        BPL     %BT00

        ADRL    R7, colourtrans32K
        MOV     R1, R7
        ADR     R2, thirtytwok
        LDR     R2, [R2]
        STR     R2, [R1], #4
        STR     R4, [R1], #4
        STR     R2, [R1]

        [ debugMedusa
        SWI     XOS_ReadMonotonicTime
        Debuga  Medusa, "** End time ", R0
        Debug   Medusa, " addresses: anchor, table = ", R7, R4
        ]
        Pull    "R0-R5,PC"

; Subroutine to clear the ColourTrans translation table anchor block

sprite_clear32Ktable
        Push    "R1,R4,LR"
        ADRL    R1, colourtrans32K
        MOV     R4, #0
        STR     R4, [R1, #4]
        Pull    "R1,R4,PC"

; Subroutine to free the ColourTrans translation table if allocated
; This gets used in cleaning up errors, so we ignore errors in this
; routine and ensure that the flags are preserved.

sprite_free32Ktable
        EntryS  "R0-R2"
        ADRL    R1, colourtrans32K
        LDR     R2, [R1, #4]
        MOV     LR, #0
        TEQ     R2, #0
        STRNE   LR, [R1, #4]
        MOVNE   R0, #ModHandReason_Free
        SWINE   XOS_Module
        EXITS

thirtytwok
        = "32K."

        ]


        [ Medusa

; Routine to output the data for a 32bpp sprite.
; In:
;       R0-R2:  info about the sprite
;       R3,R4:  width & height in pixels, after any source clipping
;       R8:     0 for unmasked plotting, 8 for masked plotting (& mask exists).
;       R10-R12:file handle and workspace pointers.
;       sourceclip_x,y: start position in image
;
; The PostScript coordinate system has been set up to sprite bits by sprite pixels
; (by sprite_scaling).  Also the matrix for imagemask has been constructed by the same call.
;
; Caller has saved R0-R9 if required.


sprite_output32bpp

        Push    "LR"                            ; R0-R9 have been saved by caller
        PrError sprite_output32bpp_error_return

        Debug   Medusa, "sprite_output32bpp entered"
        Debug   Medusa, "Regs ", r0, r1, r2, r3, r4, r5, r6, r7, r8, r9

        BL      sprite_getspriteaddress         ; normalise R1 and R2
        PrPassError

;we'll use ASCII85 encoding for Level 2, hex coding otherwise
        LDRB    R5,joblevel2
        CMP     R5,#0
        BLNE    ascii85_begin

; Now get some essential info about the sprite

        LDR     R5, [R2, #spImage]              ; get address of the image
        ADD     R5, R2, R5
        TEQ     R8, #8                          ; is this 'masked plotting'?
        MOVNE   R6, #0                          ; if not, then no mask data
        LDREQ   R6, [R2, #spTrans]              ; get address of the mask
        ADDEQ   R6, R2, R6
        TEQEQ   R5, R6                          ; if the addresses are the same
        MOVEQ   R6, #0                          ; then no mask data

; Now R5->image data, R6->mask data (if mask is to be used, else 0)

        Debug   Medusa, "Addresses: Image, Mask = ", R5, R6

        LDR     R7, [R2, #spWidth]              ; get sprite width-1 (in words)
        ADD     R7, R7, #1
        MOV     R7, R7, LSL #2                  ; R7 is image row offset in bytes

; Find out the pixel packing order

        Push    "R0-R2"
        LDR     R0, [R2, #spMode]
        MOV     R1, #VduExt_ModeFlags
        SWI     XOS_ReadModeVariable
        AND     R9, R2, #ModeFlag_DataFormatFamily_Mask :OR: ModeFlag_DataFormatSub_RGB
        Pull    "R0-R2"

; Determine the bytes per row in the mask.  This is a simple function of
; the total width in pixels, because there is one mask bit per pixel and up to
; 31 bits of wastage.  We need the sprite's total width for this:-

        TEQ     R6, #0                          ; no mask?
        BEQ     %FT01

        Push    "R3-R6"

        BIC     R0, R0, #255
        ORR     R0, R0, #SpriteReason_ReadSpriteSize
        SWI     XOS_SpriteOp

        ADDVC   R8, R3, #31
        MOVVC   R8, R8, LSR #5                  ; R8 = mask row offset in words
        MOVVC   R8, R8, LSL #2                  ; R8 = mask row offset in bytes

        Pull    "R3-R6"
        PrPassError
01

; Now adjust R5 and R6 to point to the start of the lowest row we intend to plot

        LDR     LR, [R2, #spHeight]             ; height in scanlines - 1
        LDR     R0, sourceclip_y                ; this is in pixels from the bottom
        SUB     LR, LR, R0                      ; height - 1 - sourceclip_y
        MLA     R5, LR, R7, R5                  ; start of first desired line in image

        TEQ     R6, #0                          ; If there is a mask
        MLANE   R6, LR, R8, R6                  ; start of first desired line in mask

;  R0-R2, the sprite identifiers, are no longer needed.

; Now the registers look like this:-
;  R0-R2: scratch
;  R3, R4: width and height of portion to plot, in pixels
;  R5: address of bottom row of the image to plot
;  R6: address of bottom row of the mask to plot, or 0 for no mask
;  R7: number of bytes to subtract from R5 to get to previous row in image
;  R8: number of bytes to subtract from R6 to get to previous row in mask
;  R9: source sprite ModeFlags
;  R10-R12: file handle and workspace pointers


; Output the colorimage command

        PrPair  R3, R4                          ; width & height in pixels
        PrLnIm  "S32"

        Debug   Medusa, "Outputting data"
        Debug   Medusa, "Regs ", r0, r1, r2, r3, r4, r5, r6, r7, r8, r9

; Now loop over all the rows from the bottommost up.  We know that R4 is at least 1

sprite_output32bpp_yloop

; Check for the ESCAPE key at the start of each scanline.

        [       PSDebugEscapes
        BLVC    readescapestate
        |
        SWIVC   XOS_ReadEscapeState             ;Check for escape, returning
        ]
        SETV    CS                              ;  error if so. NB top level
        PrPassError                             ;  will set R0 for us if so.

        Push    "R3,R4,R7,R9"                   ; stack width, height, image row offsets, image ModeFlags

        MOV     R7, R9                          ; keep ModeFlags in a register

        LDR     R9, sourceclip_x                ; Advance to the first pixel of the
        ADD     R1, R5, R9, LSL #2              ; image data to be plotted

        TEQ     R6, #0                          ; Masked?
        MOVNE   LR, R9, LSR #5                  ; If mask, determine number of words into the mask row to start
        ADDNE   R2, R6, LR, LSL #2              ;   and make R2 point there
        LDRNE   R4, [R2], #4                    ;   Pick up first mask word
        ANDNE   LR, R9, #31                     ;   LR = sourceclip_x MOD 32
        MOVNE   R4, R4, LSR LR                  ;   Shift mask word so that first wanted bit is in lsbit

; Now the registers look like this:-
;  R1 -> next word to lift out of the image
;  R2 -> next word to lift out of the mask, or undefined if no mask
;  R3: width of portion to plot, in pixels
;  R4: first mask word, with first wanted bit at bit 0, or undefined if no mask
;  R5: address of bottom row of the image to plot
;  R6: address of bottom row of the mask to plot, or undefined if no mask
;  R7: ModeFlags or
;      number of bytes to subtract from R5 to get to previous row in image
;  R8: number of bytes to subtract from R6 to get to previous row in mask
;  R9: sourceclip_x
;  R10-R12: file handle and workspace pointers

        Debug   Medusa, "S.of.ROW: Regs ", r0, r1, r2, r3, r4, r5, r6, r7, r8, r9

; Now loop across all the pixels in the row.  We know that R3 is at least 1
; Use a different loop for the unmasked case to reduce the number of
; comparisons

        BNE     sprite_output32bpp_masked_xloop

        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_xloop_L1

sprite_output32bpp_xloop_L2
        LDR     R0, [R1], #4                    ; Get the next pixel
        TST     R7, #ModeFlag_DataFormatSub_RGB
        MOVNE   LR, R0, LSL #8                  ; xRGB -> RGB0
        ANDNE   R0, R0, #&FF:SHL:8              ;      -> 00G0
        ORRNE   R0, R0, LR, ROR #24             ;      -> GBGR

        BL      ascii85_byte
        MOVVC   R0, R0, LSR #8
        BLVC    ascii85_byte
        MOVVC   R0, R0, LSR #8
        BLVC    ascii85_byte
        Pull    "R3,R4,R7,R9,PC",VS
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_xloop_L2
        B       sprite_output32bpp_next_y

sprite_output32bpp_xloop_L1
        LDR     R0, [R1], #4                    ; Get the next pixel
        TST     R7, #ModeFlag_DataFormatSub_RGB
        MOVNE   LR, R0, LSL #8                  ; xRGB -> RGB0
        ANDNE   R0, R0, #&FF:SHL:8              ;      -> 00G0
        ORRNE   R0, R0, LR, ROR #24             ;      -> GBGR

        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError              ; Output R
        MOV     R0, R0, LSR #8
        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError              ; Output G
        MOV     R0, R0, LSR #8
        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError              ; Output B
        ADD     R9, R9, #1                      ; Newline wanted?
        TST     R9, #2_11111                    ; do one every 32 pixels or so
        BNE     %FT02
        PrNewLn FallThroughOnError
02
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_xloop_L1
        B       sprite_output32bpp_next_y

sprite_output32bpp_masked_xloop

        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_masked_xloop_L1

sprite_output32bpp_masked_xloop_L2
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        ADDCC   R1, R1, #4                      ; If mask clear, skip the next pixel and use
        MOVCC   R0, #FakeMaskColour             ;   the "background" colour (white)
        LDRCS   R0, [R1], #4                    ; If mask set, get the next pixel
        TSTCS   R7, #ModeFlag_DataFormatSub_RGB
        MOVHI   LR, R0, LSL #8                  ; xRGB -> RGB0
        ANDHI   R0, R0, #&FF:SHL:8              ;      -> 00G0
        ORRHI   R0, R0, LR, ROR #24             ;      -> GBGR

        BL      ascii85_byte
        MOVVC   R0, R0, LSR #8
        BLVC    ascii85_byte
        MOVVC   R0, R0, LSR #8
        BLVC    ascii85_byte
        Pull    "R3,R4,R7,R9,PC",VS
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_masked_xloop_L2
        B       sprite_output32bpp_next_y

sprite_output32bpp_masked_xloop_L1
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        ADDCC   R1, R1, #4                      ; If mask clear, skip the next pixel and use
        MOVCC   R0, #FakeMaskColour             ;   the "background" colour (white)
        LDRCS   R0, [R1], #4                    ; If mask set, get the next pixel
        TSTCS   R7, #ModeFlag_DataFormatSub_RGB
        MOVHI   LR, R0, LSL #8                  ; xRGB -> RGB0
        ANDHI   R0, R0, #&FF:SHL:8              ;      -> 00G0
        ORRHI   R0, R0, LR, ROR #24             ;      -> GBGR

        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError              ; Output R
        MOV     R0, R0, LSR #8
        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError              ; Output G
        MOV     R0, R0, LSR #8
        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError              ; Output B
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        BNE     %FT03
        PrNewLn FallThroughOnError              ; and do a newline too
03
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_masked_xloop_L1

; FALLTHRU

sprite_output32bpp_next_y

; Move on to the next (previous in fact) row

        Pull    "R3,R4,R7,R9"                   ; Get registers back

        SUB     R5, R5, R7                      ; Address previous row of image
        TEQ     R6, #0
        SUBNE   R6, R6, R8                      ; and mask
        SUBS    R4, R4, #1                      ; more rows?
        BNE     sprite_output32bpp_yloop

; All the data that colorimage is expecting has been output.  Terminate tidily.

        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_end_L1
        BL      ascii85_end
        Pull    "PC"

sprite_output32bpp_end_L1
        PrNewLn FallThroughOnError

        Debug   Medusa, "Leaving sprite_output32bpp"

sprite_output32bpp_error_return
        Pull    "PC"                            ; caller outputs grestore, etc


; Routine to output the data for a 16bpp sprite.
;
; PostScript does not understand 5 bits per colour component!  We therefore
; have the awkward choice between losing a bit, and generating 4 bits per component,
; or inventing three bits to generate 8 bits per component.  It is expected that
; the former method would produce unacceptable degradation when printing a
; dithered image; therefore we choose the latter method.
; Even for 4k sprites (which could use the 4 bits per component facility of
; PostScript) we stick with 8 bits per component for sharing of code.  

; In:
;       R0-R2:  info about the sprite
;       R3,R4:  width & height in pixels, after any source clipping
;       R8:     0 for unmasked plotting, 8 for masked plotting (& mask exists).
;       R10-R12:file handle and workspace pointers.
;       sourceclip_x,y: start position in image
;
; The PostScript coordinate system has been set up to sprite bits by sprite pixels
; (by sprite_scaling).  Also the matrix for imagemask has been constructed by the same call.
;
; Caller has saved R0-R9 if required.


sprite_output16bpp

        Push    "LR"                            ; R0-R9 have been saved by caller
        PrError sprite_output16bpp_error_return

        Debug   Medusa, "sprite_output16bpp entered"
        Debug   Medusa, "Regs ", r0, r1, r2, r3, r4, r5, r6, r7, r8, r9

        BL      sprite_getspriteaddress         ; normalise R1 and R2
        PrPassError

;we'll use ASCII85 encoding for Level 2, hex coding otherwise
        LDRB    R5,joblevel2
        CMP     R5,#0
        BLNE    ascii85_begin

; Now get some essential info about the sprite

        LDR     R5, [R2, #spImage]              ; get address of the image
        ADD     R5, R2, R5
        TEQ     R8, #8                          ; is this 'masked plotting'?
        MOVNE   R6, #0                          ; if not, then no mask data
        LDREQ   R6, [R2, #spTrans]              ; get address of the mask
        ADDEQ   R6, R2, R6
        TEQEQ   R5, R6                          ; if the addresses are the same
        MOVEQ   R6, #0                          ; then no mask data

; Now R5->image data, R6->mask data (if mask is to be used, else 0)

        Debug   Medusa, "Addresses: Image, Mask = ", R5, R6

        LDR     R7, [R2, #spWidth]              ; get sprite width-1 (in words)
        ADD     R7, R7, #1
        MOV     R7, R7, LSL #2                  ; R7 is image row offset in bytes

; Find out the pixel packing order

        Push    "R0-R3"
        LDR     R0, [R2, #spMode]
        MOV     R1, #VduExt_ModeFlags
        SWI     XOS_ReadModeVariable
        MOV     R3, R2
        MOV     R1, #VduExt_NColour
        SWI     XOS_ReadModeVariable
        ADD     R2, R2, #1
        CMP     R2, #65536
        TSTEQ   R3, #ModeFlag_FullPalette
        MOVEQ   R2, R2, LSR #1                  ; Now have 4096/32768/65536
        CMP     R2, #32768
        ADRCC   R9, sprite_map444
        ADREQ   R9, sprite_map555
        ADRHI   R9, sprite_map565
        TST     R3, #ModeFlag_DataFormatSub_RGB
        ORRNE   R9, R9, #1                      ; Copy RGB flag
        Pull    "R0-R3"

; Determine the bytes per row in the mask.  This is a simple function of
; the total width in pixels, because there is one mask bit per pixel and up to
; 31 bits of wastage.  We need the sprite's total width for this:-

        TEQ     R6, #0                          ; no mask?
        BEQ     %FT01

        Push    "R3-R6"

        BIC     R0, R0, #255
        ORR     R0, R0, #SpriteReason_ReadSpriteSize
        SWI     XOS_SpriteOp

        ADDVC   R8, R3, #31
        MOVVC   R8, R8, LSR #5                  ; R8 = mask row offset in words
        MOVVC   R8, R8, LSL #2                  ; R8 = mask row offset in bytes

        Pull    "R3-R6"
        PrPassError
01

; Now adjust R5 and R6 to point to the start of the lowest row we intend to plot

        LDR     LR, [R2, #spHeight]             ; height in scanlines - 1
        LDR     R0, sourceclip_y                ; this is in pixels from the bottom
        SUB     LR, LR, R0                      ; height - 1 - sourceclip_y
        MLA     R5, LR, R7, R5                  ; start of first desired line in image

        TEQ     R6, #0                          ; If there is a mask
        MLANE   R6, LR, R8, R6                  ; start of first desired line in mask

;  R0-R2, the sprite identifiers, are no longer needed.

; Now the registers look like this:-
;  R0-R2,R9: scratch
;  R3, R4: width and height of portion to plot, in pixels
;  R5: address of bottom row of the image to plot
;  R6: address of bottom row of the mask to plot, or 0 for no mask
;  R7: number of bytes to subtract from R5 to get to previous row in image
;  R8: number of bytes to subtract from R6 to get to previous row in mask
;  R9: helper function and source sprite ModeFlags
;  R10-R12: file handle and workspace pointers


; Output the colorimage command

        PrPair  R3, R4                          ; width & height in pixels
        PrLnIm  "S32"

        Debug   Medusa, "Outputting data"
        Debug   Medusa, "Regs ", r0, r1, r2, r3, r4, r5, r6, r7, r8, r9

; Now loop over all the rows from the bottommost up.  We know that R4 is at least 1

sprite_output16bpp_yloop

; Check for the ESCAPE key at the start of each scanline.

        [       PSDebugEscapes
        BLVC    readescapestate
        |
        SWIVC   XOS_ReadEscapeState             ;Check for escape, returning
        ]
        SETV    CS                              ;  error if so. NB top level
        PrPassError                             ;  will set R0 for us if so.

        Push    "R3,R4,R5,R7,R8,R9"             ; stack width, height, image row address and row offsets, helper fn

        MOV     R8, R9                          ; keep helper fn in a register

        LDR     R9, sourceclip_x                ; Advance to the first pixel of the
        ADD     R1, R5, R9, LSL #1              ; image data to be plotted
        BIC     R1, R1, #2_11                   ; two pixels per word
        LDR     R7, [R1], #4                    ; get the first word
        TST     R9, #1                          ; Is sourceclip_x odd?
        MOVNE   R7, R7, LSR #16                 ; Shift the second pixel down if so

        TEQ     R6, #0                          ; Masked?
        MOVNE   LR, R9, LSR #5                  ; If mask, determine number of words into the mask row to start
        ADDNE   R2, R6, LR, LSL #2              ;   and make R2 point there
        LDRNE   R4, [R2], #4                    ;   Pick up first mask word
        ANDNE   LR, R9, #31                     ;   LR = sourceclip_x MOD 32
        MOVNE   R4, R4, LSR LR                  ;   Shift mask word so that first wanted bit is in lsbit

; Now the registers look like this:-
;  R0: scratch
;  R1 -> next word to lift out of the image
;  R2 -> next word to lift out of the mask, or undefined if no mask
;  R3: width of portion to plot, in pixels
;  R4: first mask word, with first wanted bit at bit 0, or undefined if no mask
;  R5: scratch
;  R6: address of bottom row of the mask to plot, or undefined if no mask
;  R7: first word of image, shifted so that the first pixel is in bits 0..15
;  R8: helper function to map 444/555/565 to 888
;      plus ModeFlag_DataFormatSub_RGB in bottom bit
;  R9: sourceclip_x
;  R10-R12: file handle and workspace pointers

        Debug   Medusa, "S.of.ROW: Regs ", r0, r1, r2, r3, r4, r5, r6, r7, r8, r9

; Now loop across all the pixels in the row.  We know that R3 is at least 1
; Use a different loop for the unmasked case to reduce the number of
; comparisons

        BNE     sprite_output16bpp_masked_xloop

        LDRB    LR,joblevel2
        CMP     LR,#0
        BEQ     sprite_output16bpp_xloop_L1

sprite_output16bpp_xloop_L2
        MOV     R5, R7
        MOV     LR, PC
        BIC     PC, R8, #3                      ; Knock out flags and call the helper

        BL      ascii85_byte
        MOVVC   R0, R0, LSR #8
        BLVC    ascii85_byte
        MOVVC   R0, R0, LSR #8
        BLVC    ascii85_byte
        Pull    "R3,R4,R5,R7,R8,R9,PC",VS
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R7, R7, LSR #16                 ; by shifting down
        LDRNE   R7, [R1], #4                    ; or by loading
        ADD     R9, R9, #1
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_xloop_L2
        B       sprite_output16bpp_next_y

sprite_output16bpp_xloop_L1
        MOV     R5, R7
        MOV     LR, PC
        BIC     PC, R8, #3                      ; Knock out flags and call the helper

        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError          ; Output R
        MOV     R0, R0, LSR #8
        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError          ; Output G
        MOV     R0, R0, LSR #8
        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError          ; Output B
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R7, R7, LSR #16                 ; by shifting down
        LDRNE   R7, [R1], #4                    ; or by loading
        ADD     R9, R9, #1                      ; Newline wanted?
        TST     R9, #2_11111                    ; do one every 32 pixels or so
        BNE     %FT02
        PrNewLn FallThroughOnError
02
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_xloop_L1
        B       sprite_output16bpp_next_y

sprite_output16bpp_masked_xloop

        LDRB    LR,joblevel2
        CMP     LR,#0
        BEQ     sprite_output16bpp_masked_xloop_L1

sprite_output16bpp_masked_xloop_L2
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        MOVCS   R5, R7                          ; Use the pixel value if mask set
        MOVCC   R5, #FakeMaskColour             ; or white otherwise

        MOV     LR, PC
        BIC     PC, R8, #3                      ; Knock out flags and call the helper

        BL      ascii85_byte
        MOVVC   R0, R0, LSR #8
        BLVC    ascii85_byte
        MOVVC   R0, R0, LSR #8
        BLVC    ascii85_byte
        Pull    "R3,R4,R5,R7,R8,R9,PC",VS
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R7, R7, LSR #16                 ; by shifting down
        LDRNE   R7, [R1], #4                    ; or by loading
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_masked_xloop_L2
        B       sprite_output16bpp_next_y

sprite_output16bpp_masked_xloop_L1
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        MOVCS   R5, R7                          ; Use the pixel value if mask set
        MOVCC   R5, #FakeMaskColour             ; or white otherwise

        MOV     LR, PC
        BIC     PC, R8, #3                      ; Knock out flags and call the helper

        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError              ; Output R
        MOV     R0, R0, LSR #8
        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError              ; Output G
        MOV     R0, R0, LSR #8
        PrHex   R0,ThisDoesNotCorruptR0,FallThroughOnError              ; Output B
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R7, R7, LSR #16                 ; by shifting down
        LDRNE   R7, [R1], #4                    ; or by loading
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        BNE     %FT03
        PrNewLn FallThroughOnError              ; and do a newline too
03
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_masked_xloop_L1
; FALLTHRU

sprite_output16bpp_next_y

; Move on to the next (previous in fact) row

        Pull    "R3,R4,R5,R7,R8,R9"             ; Get width, height, image row address and offsets, helper fn back

        SUB     R5, R5, R7                      ; Address previous row of image
        TEQ     R6, #0
        SUBNE   R6, R6, R8                      ; and mask
        SUBS    R4, R4, #1                      ; more rows?
        BNE     sprite_output16bpp_yloop

; All the data that colorimage is expecting has been output.  Terminate tidily.

        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output16bpp_end_L1
        BL      ascii85_end
        Pull    "PC"

sprite_output16bpp_end_L1
        PrNewLn FallThroughOnError

        Debug   Medusa, "Leaving sprite_output16bpp"

sprite_output16bpp_error_return
        Pull    "PC"                            ; caller outputs grestore, etc

; Turn 444 into BGR888
; In: R5: Packed value
;     R8: Own address, plus ModeFlag_DataFormatSub_RGB in b0
; Out:R0: xBGR
;     Others preserved
sprite_map444
        Push    "LR"
        TST     R8, #1
        AND     LR, R5, #2_1111:SHL:4           ; G
        MOV     R0, LR, LSL #8
        AND     LR, R5, #2_1111:SHL:0           ; R (or B)
        ORREQ   R0, R0, LR, LSL #4
        ORRNE   R0, R0, LR, LSL #20
        AND     LR, R5, #2_1111:SHL:8           ; B (or R)
        ORREQ   R0, R0, LR, LSL #12
        ORRNE   R0, R0, LR, LSR #4

        LDR     LR, =&F0F0F0
        AND     LR, R0, LR
        ORR     R0, R0, LR, LSR #4              ; Expand range by copying bits
        Pull    "PC"

; Turn 555 into BGR888
; In: R5: Packed value
;     R8: Own address, plus ModeFlag_DataFormatSub_RGB in b0
; Out:R0: xBGR
;     Others preserved
sprite_map555
        Push    "LR"
        TST     R8, #1
        AND     LR, R5, #2_11111:SHL:5          ; G
        MOV     R0, LR, LSL #6
        AND     LR, R5, #2_11111:SHL:0          ; R (or B)
        ORREQ   R0, R0, LR, LSL #3
        ORRNE   R0, R0, LR, LSL #19
        AND     LR, R5, #2_11111:SHL:10         ; B (or R)
        ORREQ   R0, R0, LR, LSL #9
        ORRNE   R0, R0, LR, LSR #7

        LDR     LR, =&E0E0E0
        AND     LR, R0, LR
        ORR     R0, R0, LR, LSR #5              ; Expand range by copying bits
        Pull    "PC"

; Turn 565 into BGR888
; In: R5: Packed value
;     R8: Own address, plus ModeFlag_DataFormatSub_RGB in b0
; Out:R0: xBGR
;     Others preserved
sprite_map565
        Push    "LR"
        TST     R8, #1
        AND     LR, R5, #2_111111:SHL:5         ; G
        MOV     R0, LR, LSL #5
        AND     LR, R5, #2_11111:SHL:0          ; R (or B)
        ORREQ   R0, R0, LR, LSL #3
        ORRNE   R0, R0, LR, LSL #19
        AND     LR, R5, #2_11111:SHL:11         ; B (or R)
        ORREQ   R0, R0, LR, LSL #8
        ORRNE   R0, R0, LR, LSR #8

        LDR     LR, =&E000E0
        AND     LR, R0, LR
        ORR     R0, R0, LR, LSR #5              ; Expand range by copying bits
        AND     LR, R0, #&00C000
        ORR     R0, R0, LR, LSR #6
        Pull    "PC"

; Given a standard set of R0-R2 SpriteOp entry values, obtain the sprite's
; control block address.
;
; System sprite pool needs special attention due to the fact the
; SpriteReason_SelectSprite refuses to return the sprite address for
; sprites in the system pool.
;
; In: R0: SpriteOp reason code (bits 8 and 9 used)
;     R1: may be a pointer to a sprite pool depending on bits 8 and 9 of R0
;     R2: pointer to a sprite or sprite name depending on bits 8 and 9 of R0
; Out:R0: a different SpriteOp reason code but with the same values in bits 8 and 9
;     R1: pointer to the sprite pool
;     R2: pointer to the sprite control block


sprite_getspriteaddress
        Push    "LR"

        TST     R0, #256 + 512                  ; Is it "system sprite pool"
        BNE     %FT00

        DebugS  Medusa, "Performing system sprite pool lookup of ", R2

        Push    "R0,R2"
        MOV     R0, #3                          ; dynamic area 3 = system sprite pool
        SWI     XOS_ReadDynamicArea
        STRVS   R0, [SP]
        MOVVC   R1, R0                          ; R1 <- system sprite pool address
        Pull    "R0,R2"
        Pull    "PC", VS

        ORR     R0, R0, #256                    ; Now R1->sprite area, R2->name

; Now obtain the address of the sprite if R2 is a name

00      BIC     R0, R0, #255
        ORR     R0, R0, #SpriteReason_SelectSprite
        SWI     XOS_SpriteOp                    ; Now R2->sprite control block regardless
                                                ; of the contents of R0-R2 on entry

        DebugIf VC, Medusa, "Sprite address is ", R2

        Pull    "PC"

        ]


        END
@


4.9
log
@Update SpriteOp support, loosen/tighten some checks
Core/Header.s,Core/SWIs.s,Core/Constants.s: Define a new bad pointer rather than using &80000000 since that's now a perfectly valid logical address to have.
Core/Device.s, Core/Sprite.s, PDriverDP/Sprite.s, PDriverPS/Sprite.s: Delete support for the greyscale SpriteOp plots, these were removed from SpriteExtend in 1993. Just error them now. Extend the table of SpriteOps to include letting through TileSpriteScaled.
PDriverDP/Transprite.s: Allow 0 or -1 to mean "has no translation table" in line with PDriverPS and SpriteExtend.
PDriverPS/Sprite.s, PDriverPS/TranSprite.s: Use define instead of magic numbers.

Version 4.62. Tagged as 'PDModules-4_62'
@
text
@d191 8
a198 3
        MOV     LR, R6, LSR #27
        Debug   Medusa, "Sprite T=",LR
        TEQ     LR, #SpriteType_New16bpp
d200 1
a200 1
        TEQ     LR, #SpriteType_New32bpp
d1900 1
a1900 1
        Push    "R1,R4,R7,LR"
d1908 2
a1909 2
        MOVVC   R7,#128                 ;Level2 RLE end-of-data
        BLVC    ascii85_byteR7
d1911 2
a1912 1
        Pull    "R1,R4,R7,PC"
d1918 2
a1919 1
        Pull    "R1,R4,R7,PC"
d1934 3
a1936 3
       LDRB    R2,joblevel2
       CMP     R2,#0
       BNE     sprite_outputbyte_L2_pushdone
d2416 1
a2416 1
        LDR     R5, [R2, #32]                   ; get address of the image
d2420 1
a2420 1
        LDREQ   R6, [R2, #36]                   ; get address of the mask
d2429 1
a2429 1
        LDR     R7, [R2, #16]                   ; get sprite width-1 (in words)
d2433 9
d2465 1
a2465 1
        LDR     LR, [R2, #20]                   ; height in scanlines - 1
d2476 1
a2476 1
;  R0-R2,R9: scratch
d2482 1
d2508 3
a2510 1
        Push    "R3,R4"                         ; stack width & height to free some registers
d2529 2
a2530 1
;  R7: number of bytes to subtract from R5 to get to previous row in image
d2549 5
d2555 5
a2559 7
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
d2566 5
a2592 1
        LDRCS   R0, [R1], #4                    ; If mask set, get the next pixel
d2595 6
d2602 5
a2606 7
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
a2615 1
        LDRCS   R0, [R1], #4                    ; If mask set, get the next pixel
d2618 6
d2644 1
a2644 1
        Pull    "R3,R4"                         ; Get width & height back
d2676 2
d2710 1
a2710 1
        LDR     R5, [R2, #32]                   ; get address of the image
d2714 1
a2714 1
        LDREQ   R6, [R2, #36]                   ; get address of the mask
d2723 1
a2723 1
        LDR     R7, [R2, #16]                   ; get sprite width-1 (in words)
d2727 21
d2771 1
a2771 1
        LDR     LR, [R2, #20]                   ; height in scanlines - 1
d2788 1
d2814 4
d2821 1
a2821 1
        LDR     R0, [R1], #4                    ; get the first word
d2823 1
a2823 4
        MOVNE   R0, R0, LSR #16                 ; Shift the second pixel down if so

        Push    "R3,R4,R5,R7,R8"                ; stack width, height, image row address and row offsets
        MOV     R8, #2_11111000                 ; useful for extracting the pixels
d2833 1
a2833 1
;  R0: first word of image, shifted so that the first pixel is in bits 0..15
d2840 3
a2842 2
;  R7: scratch
;  R8: 2_11111000
a2851 1

d2854 2
a2855 2
        LDRB    R7,joblevel2
        CMP     R7,#0
d2859 10
a2868 12
        AND     R7, R8, R0, LSL #3
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R0, LSR #2
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R0, LSR #7
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
d2870 2
a2871 2
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
d2878 9
a2886 9
        AND     R7, R8, R0, LSL #3
        ORR     R7, R7, R7, LSR #5
        PrHex   R7,,FallThroughOnError          ; Output R
        AND     R7, R8, R0, LSR #2
        ORR     R7, R7, R7, LSR #5
        PrHex   R7,,FallThroughOnError          ; Output G
        AND     R7, R8, R0, LSR #7
        ORR     R7, R7, R7, LSR #5
        PrHex   R7,,FallThroughOnError          ; Output B
d2888 2
a2889 2
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
d2901 2
a2902 2
        LDRB    R7,joblevel2
        CMP     R7,#0
d2907 1
a2907 1
        MOVCS   R5, R0                          ; Use the pixel value if mask set
d2909 10
a2918 12
        AND     R7, R8, R5, LSL #3
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R5, LSR #2
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R5, LSR #7
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
d2920 2
a2921 2
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
d2931 1
a2931 1
        MOVCS   R5, R0                          ; Use the pixel value if mask set
d2933 9
a2941 9
        AND     R7, R8, R5, LSL #3
        ORR     R7, R7, R7, LSR #5
        PrHex   R7,,FallThroughOnError          ; Output R
        AND     R7, R8, R5, LSR #2
        ORR     R7, R7, R7, LSR #5
        PrHex   R7,,FallThroughOnError          ; Output G
        AND     R7, R8, R5, LSR #7
        ORR     R7, R7, R7, LSR #5
        PrHex   R7,,FallThroughOnError          ; Output B
d2943 2
a2944 2
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
d2959 1
a2959 1
        Pull    "R3,R4,R5,R7,R8"                ; Get width, height, image row address and offsets back
d2983 43
d3027 23
@


4.8
log
@Some PDModule tidy ups
Core/FontSWI.s & PDriverDP/Font.s:
 The pointer compares are now unsigned, so raise the limit for printing strings in top bit set addresses when no length is passed in R7.
 Couple of comment typos.
Core/Header.s:
 A CVS merge mistake left behind two copies of Push/return sequence.
Core/PDriver.s:
 Unused VersionString removed.
PDriverDP/Macros.s & PDriverDP/ManageJob.s:
 Single use unhelpful debug message removed.
PDriverDP/Private2.s & Sprite.s & TranSprite.s:
 Use some of the defines from Hdr:Sprite.
Makefile:
 For ROMming, explicitly state there's no resources phase
PDriverDP/PageBox.s:
 Unjumble the set_sprite_output_state data. The MonoBufferOK and Libra1 switch happen to work when both are {TRUE} but other combinations would output a silly table. Let ObjAsm work out the size instead.

Tested briefly, still printed OK.

Version 4.59. Tagged as 'PDModules-4_59'
@
text
@d121 1
a121 2
sprite_greyscaled                       ;No sensible difference exists
sprite_put                              ;  between these two in PostScript
d226 1
a226 1
        ORR     R6, R6, #2_00100 :SHL: 27
@


4.7
log
@Remove a couple of dodgy 26 bit-isms
PageBox.s: STRB of PC, hoping the bottom 2 bits are set in SVC mode
Sprite.s: Push of PC and subsequent pull, hoping to inspect the stacked V flag
Built, but not tested.

Version 4.57. Tagged as 'PDModules-4_57'
@
text
@a192 1
        AND     LR, LR, #31
d194 1
a194 1
        TEQ     LR, #5
d196 1
a196 1
        TEQ     LR, #6
@


4.6
log
@Fix for the thingy which sits on SpriteV,it got optimised sometime round
2000 which led to it getting the "redirected to sprite" switch in a
muddle so printing from some apps ended up on the screen not in the
postscript file.
Changed the "%%Creator" string a bit.
Took the opportunity to eliminate all the signed pointer comparisons.
Tightened up the checking of pointers to palettes and translation tables
so that "0 or -1" means to use the default,not <= 0.

Version 4.50. Tagged as 'PDModules-4_50'
@
text
@d742 2
a743 1
        Push    "R0-R3,PC"
d748 2
a749 3
        Pull    "R0-R3,LR"
        TST     LR,#V_bit
        SETV    NE
d1370 2
a1371 1
        Push    "R0-R3,PC"
d1376 2
a1377 3
        Pull    "R0-R3,LR"
        TST     LR,#V_bit
        SETV    NE
@


4.5
log
@Changed to use objasm to avoid any LDR rN,[rN],#0 problems
Changed to use shared Makefiles
Numerous small 32 bit conversion improvements
Bugfix to PDriverPS,it was pulling LR not PC - this has been the case for
many years so not sure how it ever worked.
Due to a bug in objasm 3.27 this checkin will infact not build directly.
You must first
 - rename the PDriverDP dir to PDriverDP2
 - rename the PDriverPS dir to PDriverPS2
 - move the 2 source files of the same name up a directory
checked in in this way to minimise messing in CVS.

Version 4.47. Tagged as 'PDModules-4_47'
@
text
@d23 4
d29 1
d69 3
d73 1
d96 1
a96 1
;        R6 <= 0 for no scaling, or points to 4 scaling factors (x-mag,
d98 1
a98 1
;        R7 <= 0 for no translation, or points to a translation table.
d130 3
a132 2
        CMP     R7, #0                  ;If user wants no translation table, then
        MOVLT   R7, #0                  ;force R7 to zero (we use top bit of R7
a134 1

d504 6
a509 6
        CMP     R9,#0                           ;Pick up scaling factors
        LDMGTIA R9,{R3-R6}
        MOVLE   R3,#1
        MOVLE   R4,#1
        MOVLE   R5,#1
        MOVLE   R6,#1
d1040 3
d1044 1
d1047 3
d1051 1
d2242 4
d2248 1
@


4.4
log
@  Merge of 32-bit branch.
Detail:
  These modules are now thought to work.
Admin:
  This module has received some testing of both 26-bit and 32-bit
    builds and is believed to function correctly.

Version 4.45. Tagged as 'PDModules-4_45'
@
text
@d2341 1
a2342 1
        LDR     R2, [R1, #4]
@


4.3
log
@Spinner branch merged
@
text
@d38 1
a38 1
        MOV     R3,#-1                          
d161 1
a161 1
        
d2309 1
a2309 1
        
d2339 1
a2339 1
        Push    "R0-R2,LR"
d2341 1
d2344 4
a2347 6
        Pull    "R0-R2,PC", EQ, ^
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
        MOV     R2, #0
        STR     R2, [R1, #4]
        Pull    "R0-R2,PC",,^
d2354 1
a2354 1
        
d2418 1
a2418 1
        
d2681 1
a2681 1
        
@


4.3.2.1
log
@  First attempt at 32-bit compatible modules.
Admin:
  Tested that modules build 26-bit and 32-bit.
  Requires HdrSrc-1_05 or later.

Version 4.44, 4.1.2.1. Tagged as 'PDModules-4_44-4_1_2_1'
@
text
@d38 1
a38 1
        MOV     R3,#-1
d161 1
a161 1

d2309 1
a2309 1

d2339 1
a2339 1
        EntryS  "R0-R2"
d2343 1
a2343 1
        EXITS   EQ
d2348 1
a2348 1
        EXITS
d2355 1
a2355 1

d2419 1
a2419 1

d2682 1
a2682 1

@


4.3.2.2
log
@  Lots of fixes.
Detail:
  Several stack imbalances and missing conditions on instructions fixed.
  Some flag removal code sequences improved (RSB rn,pc,pc:SUB rn,lr,rn)
Admin:
  Built both 26 and 32-bit versions - neither tested.

Version 4.44, 4.1.2.2. Tagged as 'PDModules-4_44-4_1_2_2'
@
text
@a2340 1
        MOV     LR, #0
d2343 5
a2347 3
        STRNE   LR, [R1, #4]
        MOVNE   R0, #ModHandReason_Free
        SWINE   XOS_Module
@


4.2
log
@Version Spin_merge taken
@
text
@d666 1
a666 1
        ADRVC   LR,oldspritestate
d734 1
a734 1
        ADR     LR,oldspritestate
d1332 1
a1332 1
        ADRVC   LR,oldspritestate
d1354 1
a1354 1
        ADR     LR,oldspritestate
d1969 1
a1969 1
        ADR     LR,sprstring
d2012 1
a2012 1
        ADR     R1,sprstring
d2107 1
a2107 1
        ADR     LR,sprstring
d2136 1
a2136 1
        ADR     R0,sprstring
@


4.1
log
@Initial revision
@
text
@d681 1
a681 1
        ADR     LR, colourtrans32K              ; We only want to pass a translation
d1005 3
d1027 1
a1027 1
        ADR     LR, colourtrans32K              ;Is it our truecolour trans table?
d1212 1
d1560 3
d1775 3
a1873 1

d1880 13
a1892 2
        Push    "R1,R4,LR"

a1894 1

d1897 1
a1897 2

        Pull    "R1,R4,PC"
d1912 4
d2069 103
d2230 1
a2230 1
        ADR     LR, colourtrans32K      ;Is it our truecolour translation table?
d2310 1
a2310 1
        ADR     R7, colourtrans32K
d2329 1
a2329 1
        ADR     R1, colourtrans32K
d2340 1
a2340 1
        ADR     R1, colourtrans32K
d2383 5
a2502 2
        
sprite_output32bpp_xloop
d2504 5
d2510 11
d2522 2
a2528 1

a2533 1

d2535 1
a2535 1
        BNE     sprite_output32bpp_xloop
d2540 5
d2549 14
d2564 5
a2573 1

d2580 2
a2582 2
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_masked_xloop
d2597 1
a2597 2
; All the data that colorimage is expecting has been output.  Terminate tidily with
; a newline.
d2599 7
d2646 5
a2772 2
        
sprite_output16bpp_xloop
d2774 26
a2808 1

a2811 1

a2816 1

d2818 1
a2818 1
        BNE     sprite_output16bpp_xloop
d2823 5
d2831 21
d2853 4
a2865 1

a2868 1

a2874 1

d2876 1
a2876 1
        BNE     sprite_output16bpp_masked_xloop
d2891 7
a2897 2
; All the data that colorimage is expecting has been output.  Terminate tidily with
; a newline.
d2899 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d681 1
a681 1
        ADRL    LR, colourtrans32K              ; We only want to pass a translation
a1004 3
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
d1024 1
a1024 1
        ADRL    LR, colourtrans32K              ;Is it our truecolour trans table?
a1208 1

a1555 3
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
a1767 3
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
d1864 1
d1871 2
a1872 13
        Push    "R1,R4,R7,LR"
        LDRB    LR,joblevel2
        CMP     LR,#0
        BEQ     sprite_endoutput_notL2
        MOV     R1,#&100                ;Start a fake new run of a non-byte
        BL      sprite_outputbyte       ;  value
        LDRVCB  R4,sprstringlen         ;Then output any remaining string
        BLVC    sprite_outputstring_L2
        MOVVC   R7,#128                 ;Level2 RLE end-of-data
        BLVC    ascii85_byteR7
        BLVC    ascii85_end
        Pull    "R1,R4,R7,PC"
sprite_endoutput_notL2
d1875 1
d1878 2
a1879 1
        Pull    "R1,R4,R7,PC"
a1893 4
       LDRB    R2,joblevel2
       CMP     R2,#0
       BNE     sprite_outputbyte_L2_pushdone

a2046 103

;following RLE routines very similar to above, but use Level2 RLE style
;and ASCII85 encoding, instead of hex


sprite_outputbyte_L2
        Push    "R1-R4,LR"        ;MUST match push in sprite_outputbyte
        PrError sprite_outputbyte_L2_return

sprite_outputbyte_L2_pushdone
; Get current state of run-length encoding algorithm.

        LDRB    R2,sprlastbyte                  ;Last byte encountered
        LDRB    R4,sprstringlen                 ;Current length of string
        LDR     R3,sprrepeatcount               ;Repeat count for this byte

; Is this byte the same as the last one? If so, we just increment the repeat
; count and return.

        CMP     R1,R2
        ADDEQ   R3,R3,#1
        BEQ     sprite_outputbyte_L2_storeandreturn        ;NB V=0 if taken

;distinct
        ADD     LR,R3,R4
        CMP     LR,#PSSprRLMaxStrL2     ;First condition
        CMPLS   R3,#PSSprRLMinRunL2+1   ;Second condition
        BLS     sprite_outputbyte_L2_extendandstartrun

        BL      sprite_outputstring_L2
        PrPassError

        CMP     R3,#PSSprRLMinRunL2
        BLO     sprite_outputbyte_L2_extendandstartrun
        BL      sprite_outputrun_L2
        B       sprite_outputbyte_L2_startrun

sprite_outputbyte_L2_extendandstartrun
        ADR     LR,sprstring
        CMP     R3,#0
sprite_outputbyte_L2_extendloop
        STRNEB  R2,[LR,R4]
        ADDNE   R4,R4,#1
        SUBNES  R3,R3,#1
        BNE     sprite_outputbyte_L2_extendloop    ;NB V=0 if not taken

sprite_outputbyte_L2_startrun
        MOVVC   R2,R1
        MOVVC   R3,#1

        STRVCB  R2,sprlastbyte                  ;Last byte encountered
        STRVCB  R4,sprstringlen                 ;Current length of string
sprite_outputbyte_L2_storeandreturn
        STRVC   R3,sprrepeatcount               ;Repeat count for this byte

        PrError
sprite_outputbyte_L2_return
        Pull    "R1-R4,PC"

sprite_outputstring_L2
        Push    "R0,R1,LR"
        PrError sprite_outputstring_L2_return
        CMP     R4,#0                           ;NB clears V
        BEQ     sprite_outputstring_L2_return
        SUB     R0,R4,#1    ;length byte = n-1
        BL      ascii85_byte
        BVS     sprite_outputstring_L2_return
        ADR     R0,sprstring
        MOV     R1,R4
        BL      ascii85_block
sprite_outputstring_L2_return
        STRVS   R0,[R13]
        MOV     R4,#0       ;required to mirror sprite_outputstring
        Pull    "R0,R1,PC"

sprite_outputrun_L2
        Push    "R0,R1,R3,LR"
        PrError sprite_outputrun_L2_return
sprite_outputrun_L2_loop
        MOV     R1,R3
        CMP     R1,#128
        MOVGT   R1,#128       ;max run 128
        RSB     R0,R1,#256
        ADD     R0,R0,#1      ;length byte for run = 257-n
        BL      ascii85_byte
        BVS     sprite_outputrun_L2_return
        MOV     R0,R2
        BL      ascii85_byte   ;value byte for run
        BVS     sprite_outputrun_L2_return
        SUBS    R3,R3,R1
        BNE     sprite_outputrun_L2_loop
        [       PSDebugEscapes
        BLVC    readescapestate                 ;Check for ESCAPE, return
        |
        SWIVC   XOS_ReadEscapeState             ;Check for ESCAPE, return
        ]
        SETV    CS
sprite_outputrun_L2_return
        STRVS   R0,[R13]
        Pull    "R0,R1,R3,PC"


;end of RLE conditional stuff
d2105 1
a2105 1
        ADRL    LR, colourtrans32K      ;Is it our truecolour translation table?
d2185 1
a2185 1
        ADRL    R7, colourtrans32K
d2204 1
a2204 1
        ADRL    R1, colourtrans32K
d2215 1
a2215 1
        ADRL    R1, colourtrans32K
a2257 5
;we'll use ASCII85 encoding for Level 2, hex coding otherwise
        LDRB    R5,joblevel2
        CMP     R5,#0
        BLNE    ascii85_begin

d2373 2
a2375 5
        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_xloop_L1

sprite_output32bpp_xloop_L2
a2376 11
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_xloop_L2
        B       sprite_output32bpp_next_y
a2377 2
sprite_output32bpp_xloop_L1
        LDR     R0, [R1], #4                    ; Get the next pixel
d2383 1
d2389 1
d2391 1
a2391 1
        BNE     sprite_output32bpp_xloop_L1
a2395 5
        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_masked_xloop_L1

sprite_output32bpp_masked_xloop_L2
a2399 14
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_masked_xloop_L2
        B       sprite_output32bpp_next_y
a2400 5
sprite_output32bpp_masked_xloop_L1
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        LDRCS   R0, [R1], #4                    ; If mask set, get the next pixel
        ADDCC   R1, R1, #4                      ; If mask clear, skip the next pixel and use
        MOVCC   R0, #FakeMaskColour             ;   the "background" colour (white)
d2406 1
d2413 1
d2415 1
a2415 2
        BNE     sprite_output32bpp_masked_xloop_L1

d2430 2
a2431 1
; All the data that colorimage is expecting has been output.  Terminate tidily.
a2432 7
        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_end_L1
        BL      ascii85_end
        Pull    "PC"

sprite_output32bpp_end_L1
a2472 5
;we'll use ASCII85 encoding for Level 2, hex coding otherwise
        LDRB    R5,joblevel2
        CMP     R5,#0
        BLNE    ascii85_begin

d2595 2
a2597 26
        LDRB    R7,joblevel2
        CMP     R7,#0
        BEQ     sprite_output16bpp_xloop_L1

sprite_output16bpp_xloop_L2
        AND     R7, R8, R0, LSL #3
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R0, LSR #2
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R0, LSR #7
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
        ADD     R9, R9, #1
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_xloop_L2
        B       sprite_output16bpp_next_y

sprite_output16bpp_xloop_L1
d2607 1
d2611 1
d2617 1
d2619 1
a2619 1
        BNE     sprite_output16bpp_xloop_L1
a2623 5
        LDRB    R7,joblevel2
        CMP     R7,#0
        BEQ     sprite_output16bpp_masked_xloop_L1

sprite_output16bpp_masked_xloop_L2
a2626 21
        AND     R7, R8, R5, LSL #3
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R5, LSR #2
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R5, LSR #7
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_masked_xloop_L2
        B       sprite_output16bpp_next_y
a2627 4
sprite_output16bpp_masked_xloop_L1
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        MOVCS   R5, R0                          ; Use the pixel value if mask set
        MOVCC   R5, #FakeMaskColour             ; or white otherwise
d2637 1
d2641 1
d2648 1
d2650 1
a2650 1
        BNE     sprite_output16bpp_masked_xloop_L1
d2665 2
a2666 7
; All the data that colorimage is expecting has been output.  Terminate tidily.

        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output16bpp_end_L1
        BL      ascii85_end
        Pull    "PC"
a2667 1
sprite_output16bpp_end_L1
@


4.1.7.2
log
@Fixed data abort on init
@
text
@d666 1
a666 1
        ADRVCL  LR,oldspritestate
d734 1
a734 1
        ADRL    LR,oldspritestate
d1332 1
a1332 1
        ADRVCL  LR,oldspritestate
d1354 1
a1354 1
        ADRL    LR,oldspritestate
d1969 1
a1969 1
        ADRL    LR,sprstring
d2012 1
a2012 1
        ADRL    R1,sprstring
d2107 1
a2107 1
        ADRL    LR,sprstring
d2136 1
a2136 1
        ADRL    R0,sprstring
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d681 1
a681 1
        ADRL    LR, colourtrans32K              ; We only want to pass a translation
a1004 3
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
d1024 1
a1024 1
        ADRL    LR, colourtrans32K              ;Is it our truecolour trans table?
a1208 1

a1555 3
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
a1767 3
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
d1864 1
d1871 2
a1872 13
        Push    "R1,R4,R7,LR"
        LDRB    LR,joblevel2
        CMP     LR,#0
        BEQ     sprite_endoutput_notL2
        MOV     R1,#&100                ;Start a fake new run of a non-byte
        BL      sprite_outputbyte       ;  value
        LDRVCB  R4,sprstringlen         ;Then output any remaining string
        BLVC    sprite_outputstring_L2
        MOVVC   R7,#128                 ;Level2 RLE end-of-data
        BLVC    ascii85_byteR7
        BLVC    ascii85_end
        Pull    "R1,R4,R7,PC"
sprite_endoutput_notL2
d1875 1
d1878 2
a1879 1
        Pull    "R1,R4,R7,PC"
a1893 4
       LDRB    R2,joblevel2
       CMP     R2,#0
       BNE     sprite_outputbyte_L2_pushdone

a2046 103

;following RLE routines very similar to above, but use Level2 RLE style
;and ASCII85 encoding, instead of hex


sprite_outputbyte_L2
        Push    "R1-R4,LR"        ;MUST match push in sprite_outputbyte
        PrError sprite_outputbyte_L2_return

sprite_outputbyte_L2_pushdone
; Get current state of run-length encoding algorithm.

        LDRB    R2,sprlastbyte                  ;Last byte encountered
        LDRB    R4,sprstringlen                 ;Current length of string
        LDR     R3,sprrepeatcount               ;Repeat count for this byte

; Is this byte the same as the last one? If so, we just increment the repeat
; count and return.

        CMP     R1,R2
        ADDEQ   R3,R3,#1
        BEQ     sprite_outputbyte_L2_storeandreturn        ;NB V=0 if taken

;distinct
        ADD     LR,R3,R4
        CMP     LR,#PSSprRLMaxStrL2     ;First condition
        CMPLS   R3,#PSSprRLMinRunL2+1   ;Second condition
        BLS     sprite_outputbyte_L2_extendandstartrun

        BL      sprite_outputstring_L2
        PrPassError

        CMP     R3,#PSSprRLMinRunL2
        BLO     sprite_outputbyte_L2_extendandstartrun
        BL      sprite_outputrun_L2
        B       sprite_outputbyte_L2_startrun

sprite_outputbyte_L2_extendandstartrun
        ADR     LR,sprstring
        CMP     R3,#0
sprite_outputbyte_L2_extendloop
        STRNEB  R2,[LR,R4]
        ADDNE   R4,R4,#1
        SUBNES  R3,R3,#1
        BNE     sprite_outputbyte_L2_extendloop    ;NB V=0 if not taken

sprite_outputbyte_L2_startrun
        MOVVC   R2,R1
        MOVVC   R3,#1

        STRVCB  R2,sprlastbyte                  ;Last byte encountered
        STRVCB  R4,sprstringlen                 ;Current length of string
sprite_outputbyte_L2_storeandreturn
        STRVC   R3,sprrepeatcount               ;Repeat count for this byte

        PrError
sprite_outputbyte_L2_return
        Pull    "R1-R4,PC"

sprite_outputstring_L2
        Push    "R0,R1,LR"
        PrError sprite_outputstring_L2_return
        CMP     R4,#0                           ;NB clears V
        BEQ     sprite_outputstring_L2_return
        SUB     R0,R4,#1    ;length byte = n-1
        BL      ascii85_byte
        BVS     sprite_outputstring_L2_return
        ADR     R0,sprstring
        MOV     R1,R4
        BL      ascii85_block
sprite_outputstring_L2_return
        STRVS   R0,[R13]
        MOV     R4,#0       ;required to mirror sprite_outputstring
        Pull    "R0,R1,PC"

sprite_outputrun_L2
        Push    "R0,R1,R3,LR"
        PrError sprite_outputrun_L2_return
sprite_outputrun_L2_loop
        MOV     R1,R3
        CMP     R1,#128
        MOVGT   R1,#128       ;max run 128
        RSB     R0,R1,#256
        ADD     R0,R0,#1      ;length byte for run = 257-n
        BL      ascii85_byte
        BVS     sprite_outputrun_L2_return
        MOV     R0,R2
        BL      ascii85_byte   ;value byte for run
        BVS     sprite_outputrun_L2_return
        SUBS    R3,R3,R1
        BNE     sprite_outputrun_L2_loop
        [       PSDebugEscapes
        BLVC    readescapestate                 ;Check for ESCAPE, return
        |
        SWIVC   XOS_ReadEscapeState             ;Check for ESCAPE, return
        ]
        SETV    CS
sprite_outputrun_L2_return
        STRVS   R0,[R13]
        Pull    "R0,R1,R3,PC"


;end of RLE conditional stuff
d2105 1
a2105 1
        ADRL    LR, colourtrans32K      ;Is it our truecolour translation table?
d2185 1
a2185 1
        ADRL    R7, colourtrans32K
d2204 1
a2204 1
        ADRL    R1, colourtrans32K
d2215 1
a2215 1
        ADRL    R1, colourtrans32K
a2257 5
;we'll use ASCII85 encoding for Level 2, hex coding otherwise
        LDRB    R5,joblevel2
        CMP     R5,#0
        BLNE    ascii85_begin

d2373 2
a2375 5
        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_xloop_L1

sprite_output32bpp_xloop_L2
a2376 11
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_xloop_L2
        B       sprite_output32bpp_next_y
a2377 2
sprite_output32bpp_xloop_L1
        LDR     R0, [R1], #4                    ; Get the next pixel
d2383 1
d2389 1
d2391 1
a2391 1
        BNE     sprite_output32bpp_xloop_L1
a2395 5
        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_masked_xloop_L1

sprite_output32bpp_masked_xloop_L2
a2399 14
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_masked_xloop_L2
        B       sprite_output32bpp_next_y
a2400 5
sprite_output32bpp_masked_xloop_L1
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        LDRCS   R0, [R1], #4                    ; If mask set, get the next pixel
        ADDCC   R1, R1, #4                      ; If mask clear, skip the next pixel and use
        MOVCC   R0, #FakeMaskColour             ;   the "background" colour (white)
d2406 1
d2413 1
d2415 1
a2415 2
        BNE     sprite_output32bpp_masked_xloop_L1

d2430 2
a2431 1
; All the data that colorimage is expecting has been output.  Terminate tidily.
a2432 7
        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_end_L1
        BL      ascii85_end
        Pull    "PC"

sprite_output32bpp_end_L1
a2472 5
;we'll use ASCII85 encoding for Level 2, hex coding otherwise
        LDRB    R5,joblevel2
        CMP     R5,#0
        BLNE    ascii85_begin

d2595 2
a2597 26
        LDRB    R7,joblevel2
        CMP     R7,#0
        BEQ     sprite_output16bpp_xloop_L1

sprite_output16bpp_xloop_L2
        AND     R7, R8, R0, LSL #3
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R0, LSR #2
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R0, LSR #7
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
        ADD     R9, R9, #1
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_xloop_L2
        B       sprite_output16bpp_next_y

sprite_output16bpp_xloop_L1
d2607 1
d2611 1
d2617 1
d2619 1
a2619 1
        BNE     sprite_output16bpp_xloop_L1
a2623 5
        LDRB    R7,joblevel2
        CMP     R7,#0
        BEQ     sprite_output16bpp_masked_xloop_L1

sprite_output16bpp_masked_xloop_L2
a2626 21
        AND     R7, R8, R5, LSL #3
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R5, LSR #2
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R5, LSR #7
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_masked_xloop_L2
        B       sprite_output16bpp_next_y
a2627 4
sprite_output16bpp_masked_xloop_L1
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        MOVCS   R5, R0                          ; Use the pixel value if mask set
        MOVCC   R5, #FakeMaskColour             ; or white otherwise
d2637 1
d2641 1
d2648 1
d2650 1
a2650 1
        BNE     sprite_output16bpp_masked_xloop_L1
d2665 2
a2666 7
; All the data that colorimage is expecting has been output.  Terminate tidily.

        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output16bpp_end_L1
        BL      ascii85_end
        Pull    "PC"
a2667 1
sprite_output16bpp_end_L1
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d681 1
a681 1
        ADRL    LR, colourtrans32K              ; We only want to pass a translation
a1004 3
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
d1024 1
a1024 1
        ADRL    LR, colourtrans32K              ;Is it our truecolour trans table?
a1208 1

a1555 3
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
a1767 3
        LDRB    LR,joblevel2
        CMP     LR,#0
        BLNE    ascii85_begin
d1864 1
d1871 2
a1872 13
        Push    "R1,R4,R7,LR"
        LDRB    LR,joblevel2
        CMP     LR,#0
        BEQ     sprite_endoutput_notL2
        MOV     R1,#&100                ;Start a fake new run of a non-byte
        BL      sprite_outputbyte       ;  value
        LDRVCB  R4,sprstringlen         ;Then output any remaining string
        BLVC    sprite_outputstring_L2
        MOVVC   R7,#128                 ;Level2 RLE end-of-data
        BLVC    ascii85_byteR7
        BLVC    ascii85_end
        Pull    "R1,R4,R7,PC"
sprite_endoutput_notL2
d1875 1
d1878 2
a1879 1
        Pull    "R1,R4,R7,PC"
a1893 4
       LDRB    R2,joblevel2
       CMP     R2,#0
       BNE     sprite_outputbyte_L2_pushdone

a2046 103

;following RLE routines very similar to above, but use Level2 RLE style
;and ASCII85 encoding, instead of hex


sprite_outputbyte_L2
        Push    "R1-R4,LR"        ;MUST match push in sprite_outputbyte
        PrError sprite_outputbyte_L2_return

sprite_outputbyte_L2_pushdone
; Get current state of run-length encoding algorithm.

        LDRB    R2,sprlastbyte                  ;Last byte encountered
        LDRB    R4,sprstringlen                 ;Current length of string
        LDR     R3,sprrepeatcount               ;Repeat count for this byte

; Is this byte the same as the last one? If so, we just increment the repeat
; count and return.

        CMP     R1,R2
        ADDEQ   R3,R3,#1
        BEQ     sprite_outputbyte_L2_storeandreturn        ;NB V=0 if taken

;distinct
        ADD     LR,R3,R4
        CMP     LR,#PSSprRLMaxStrL2     ;First condition
        CMPLS   R3,#PSSprRLMinRunL2+1   ;Second condition
        BLS     sprite_outputbyte_L2_extendandstartrun

        BL      sprite_outputstring_L2
        PrPassError

        CMP     R3,#PSSprRLMinRunL2
        BLO     sprite_outputbyte_L2_extendandstartrun
        BL      sprite_outputrun_L2
        B       sprite_outputbyte_L2_startrun

sprite_outputbyte_L2_extendandstartrun
        ADR     LR,sprstring
        CMP     R3,#0
sprite_outputbyte_L2_extendloop
        STRNEB  R2,[LR,R4]
        ADDNE   R4,R4,#1
        SUBNES  R3,R3,#1
        BNE     sprite_outputbyte_L2_extendloop    ;NB V=0 if not taken

sprite_outputbyte_L2_startrun
        MOVVC   R2,R1
        MOVVC   R3,#1

        STRVCB  R2,sprlastbyte                  ;Last byte encountered
        STRVCB  R4,sprstringlen                 ;Current length of string
sprite_outputbyte_L2_storeandreturn
        STRVC   R3,sprrepeatcount               ;Repeat count for this byte

        PrError
sprite_outputbyte_L2_return
        Pull    "R1-R4,PC"

sprite_outputstring_L2
        Push    "R0,R1,LR"
        PrError sprite_outputstring_L2_return
        CMP     R4,#0                           ;NB clears V
        BEQ     sprite_outputstring_L2_return
        SUB     R0,R4,#1    ;length byte = n-1
        BL      ascii85_byte
        BVS     sprite_outputstring_L2_return
        ADR     R0,sprstring
        MOV     R1,R4
        BL      ascii85_block
sprite_outputstring_L2_return
        STRVS   R0,[R13]
        MOV     R4,#0       ;required to mirror sprite_outputstring
        Pull    "R0,R1,PC"

sprite_outputrun_L2
        Push    "R0,R1,R3,LR"
        PrError sprite_outputrun_L2_return
sprite_outputrun_L2_loop
        MOV     R1,R3
        CMP     R1,#128
        MOVGT   R1,#128       ;max run 128
        RSB     R0,R1,#256
        ADD     R0,R0,#1      ;length byte for run = 257-n
        BL      ascii85_byte
        BVS     sprite_outputrun_L2_return
        MOV     R0,R2
        BL      ascii85_byte   ;value byte for run
        BVS     sprite_outputrun_L2_return
        SUBS    R3,R3,R1
        BNE     sprite_outputrun_L2_loop
        [       PSDebugEscapes
        BLVC    readescapestate                 ;Check for ESCAPE, return
        |
        SWIVC   XOS_ReadEscapeState             ;Check for ESCAPE, return
        ]
        SETV    CS
sprite_outputrun_L2_return
        STRVS   R0,[R13]
        Pull    "R0,R1,R3,PC"


;end of RLE conditional stuff
d2105 1
a2105 1
        ADRL    LR, colourtrans32K      ;Is it our truecolour translation table?
d2185 1
a2185 1
        ADRL    R7, colourtrans32K
d2204 1
a2204 1
        ADRL    R1, colourtrans32K
d2215 1
a2215 1
        ADRL    R1, colourtrans32K
a2257 5
;we'll use ASCII85 encoding for Level 2, hex coding otherwise
        LDRB    R5,joblevel2
        CMP     R5,#0
        BLNE    ascii85_begin

d2373 2
a2375 5
        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_xloop_L1

sprite_output32bpp_xloop_L2
a2376 11
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_xloop_L2
        B       sprite_output32bpp_next_y
a2377 2
sprite_output32bpp_xloop_L1
        LDR     R0, [R1], #4                    ; Get the next pixel
d2383 1
d2389 1
d2391 1
a2391 1
        BNE     sprite_output32bpp_xloop_L1
a2395 5
        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_masked_xloop_L1

sprite_output32bpp_masked_xloop_L2
a2399 14
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        MOV     R0, R0, LSR #8
        BL      ascii85_byte
        Pull    "R3,R4,PC",VS
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output32bpp_masked_xloop_L2
        B       sprite_output32bpp_next_y
a2400 5
sprite_output32bpp_masked_xloop_L1
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        LDRCS   R0, [R1], #4                    ; If mask set, get the next pixel
        ADDCC   R1, R1, #4                      ; If mask clear, skip the next pixel and use
        MOVCC   R0, #FakeMaskColour             ;   the "background" colour (white)
d2406 1
d2413 1
d2415 1
a2415 2
        BNE     sprite_output32bpp_masked_xloop_L1

d2430 2
a2431 1
; All the data that colorimage is expecting has been output.  Terminate tidily.
a2432 7
        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output32bpp_end_L1
        BL      ascii85_end
        Pull    "PC"

sprite_output32bpp_end_L1
a2472 5
;we'll use ASCII85 encoding for Level 2, hex coding otherwise
        LDRB    R5,joblevel2
        CMP     R5,#0
        BLNE    ascii85_begin

d2595 2
a2597 26
        LDRB    R7,joblevel2
        CMP     R7,#0
        BEQ     sprite_output16bpp_xloop_L1

sprite_output16bpp_xloop_L2
        AND     R7, R8, R0, LSL #3
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R0, LSR #2
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R0, LSR #7
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
        ADD     R9, R9, #1
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_xloop_L2
        B       sprite_output16bpp_next_y

sprite_output16bpp_xloop_L1
d2607 1
d2611 1
d2617 1
d2619 1
a2619 1
        BNE     sprite_output16bpp_xloop_L1
a2623 5
        LDRB    R7,joblevel2
        CMP     R7,#0
        BEQ     sprite_output16bpp_masked_xloop_L1

sprite_output16bpp_masked_xloop_L2
a2626 21
        AND     R7, R8, R5, LSL #3
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R5, LSR #2
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        AND     R7, R8, R5, LSR #7
        ORR     R7, R7, R7, LSR #5
        BL      ascii85_byteR7
        Pull    "R3,R4,R5,R7,R8,PC",VS
        TST     R9, #1                          ; Prepare next pixel
        MOVEQ   R0, R0, LSR #16                 ; by shifting down
        LDRNE   R0, [R1], #4                    ; or by loading
        ADD     R9, R9, #1                      ; move to the next mask bit
        TST     R9, #2_11111                    ; new mask word needed?
        LDREQ   R4, [R2], #4                    ; get next mask word if so
        SUBS    R3, R3, #1                      ; Any more pixels to do?
        BNE     sprite_output16bpp_masked_xloop_L2
        B       sprite_output16bpp_next_y
a2627 4
sprite_output16bpp_masked_xloop_L1
        MOVS    R4, R4, LSR #1                  ; Shift the mask bit into the C flag
        MOVCS   R5, R0                          ; Use the pixel value if mask set
        MOVCC   R5, #FakeMaskColour             ; or white otherwise
d2637 1
d2641 1
d2648 1
d2650 1
a2650 1
        BNE     sprite_output16bpp_masked_xloop_L1
d2665 2
a2666 7
; All the data that colorimage is expecting has been output.  Terminate tidily.

        LDRB    R0,joblevel2
        CMP     R0,#0
        BEQ     sprite_output16bpp_end_L1
        BL      ascii85_end
        Pull    "PC"
a2667 1
sprite_output16bpp_end_L1
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.6;
access;
symbols
	PDModules-4_64:4.6
	PDModules-4_63:4.6
	PDModules-4_62:4.5
	PDModules-4_61:4.4
	PDModules-4_60:4.4
	PDModules-4_59:4.4
	PDModules-4_58:4.3
	PDModules-4_57:4.3
	PDModules-4_56:4.3
	PDModules-4_55:4.3
	PDModules-4_54:4.3
	PDModules-4_53:4.3
	PDModules-4_52:4.3
	PDModules-4_51:4.3
	PDModules-4_50:4.3
	PDModules-4_49:4.2
	PDModules-4_48:4.2
	PDModules-4_47:4.2
	PDModules-4_46:4.1
	kbracey_32bit_merge:4.1
	PDModules-4_45:4.1
	PDModules-4_44-4_1_2_7:4.1
	PDModules-4_44-4_1_2_6:4.1
	PDModules-4_44-4_1_2_5:4.1
	PDModules-4_44-4_1_2_4:4.1
	PDModules-4_44-4_1_2_3:4.1
	PDModules-4_44-4_1_2_2:4.1
	PDModules-4_44-4_1_2_1:4.1
	kbracey_32bit:4.1.0.4
	kbracey_32bit_bp:4.1
	dellis_autobuild_BaseSW:4.1
	Ursula_merge:4.1.7.1
	PDModules-4_44:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.1
	Ursula_RiscPC:4.1.7.1.0.6
	rthornb_UrsulaBuild-19Aug1998:4.1.7.1
	UrsulaBuild_FinalSoftload:4.1.7.1
	rthornb_UrsulaBuild-12Aug1998:4.1.7.1
	aglover_UrsulaBuild-05Aug1998:4.1.7.1
	rthornb_UrsulaBuild-29Jul1998:4.1.7.1
	rthornb_UrsulaBuild-22Jul1998:4.1.7.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.1.7.1
	rthornb_UrsulaBuild-17Jun1998:4.1.7.1
	rthornb_UrsulaBuild-03Jun1998:4.1.7.1
	rthornb_UrsulaBuild-27May1998:4.1.7.1
	rthornb_UrsulaBuild-21May1998:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Ursula:4.1.7.1.0.4
	Ursula_bp:4.1.7.1
	Ursula_31Mar1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spin_merge_28May97:4.1.7.1
	Spinner_B10:4.1.7.1
	Spin_merge_16May97:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2018.07.03.21.21.59;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	wlcRMNq9s64zFJIA;

4.5
date	2018.07.03.21.14.47;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	8KGlIKKeLIz2DJIA;

4.4
date	2014.10.20.21.53.08;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	kYvwc1FHitWAiZUx;

4.3
date	2003.03.10.11.33.29;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2002.12.05.20.45.10;	author srevill;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.48.43;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.48.43;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.06.10;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.28.05;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.31.43;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Add support for 4k/64k sprite printing via PDriverPS
Look harder at the sprite type bits rather than assume the sequence 1/2/4/8/16/32bpp still holds. This lets through the RISC OS 5 sprite type for 4k and 64k colours.
Look up the RGB ordering via the respective ModeFlags mode variable, change the order of output RGB PostScript bytes as required.
Add some helper functions to map 4:4:4, 5:5:5, 5:6:5 to deal with the 6 possible 16bpp types, since they all ultimately output RGB888.

Tested printing a Draw file with all true colour combinations of test sprites, then converting with Adobe Distiller.

Version 4.63. Tagged as 'PDModules-4_63'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > TranSprite

; ********************************************************************************
;
; sprite_plotmasktransformed
; sprite_plotspritetransformed
;
;   in: r0  = reason code, tells you how r1, r2 should be handled.
;       r1 -> sprite control block
;       r2 -> sprite name / pointer to sprite (if r0 =&2xx).
;       r3  = flags word
;                   bit 0 set => R6 -> destination co-ords, else matrix.
;                   bit 1 set => R4 -> source rectangle within sprite.
;                   others are reserved for future expansion.
;
;       r4   = source rectangle block (if R3 bit 1 set).
;       r5   = GCOL action (bit 3 for masking, bit 4 for using sprite's palette)
;       r6  -> matrix (if R3 bit 0 clear):
;               r6!0,4,8,12,16,20 = matrix (as for Draw module)
;       r6  -> destination co-ordinates
;               r6!0,4 = X0,Y0 screen (1/256ths OS unit)
;               r6!8,12 = X1,Y1 on screen (1/256ths OS unit)
;               r6!16,20 = X2, Y2 on screen (1/256ths OS unit)
;               r6!24,28 = X3, Y3 on screen (1/256ths OS unit)
;       r7  -> translation table ( = 0 or -1 => none).
;
; The source cordinates are inclusive at the bottom-left, and exclusive at the
; top right.
;
; When specifying a destination parallelogram, the source rectangle is mapped as onto
; the destination as follows:
;
;       x0, y0  ->  X0, Y0
;       x1, y0  ->  X1, Y1
;       x1, y1  ->  X2, Y2
;       x0, y1  ->  X3, Y3
;
; In the future it may be possible to set the destination to an arbitary
; quadrilateral, rather than a parallelogram.   ** THIS IS NOT YET SUPPORTED **
;
; The routine handling this call should ensure that the resulting image covers exactly
; the area that a call to Draw_Fill would produce if passed the same rectangle
; and relevant transformation matrix, where it is filling to half-way through
; the boundary.
;
; If your printer driver supports transformed sprites then it should set bit 27
; of the printer driver info word to reflect this, so that applications
; authors can take advantage of the new features.
;
; ********************************************************************************

srcx0           RN      3               ; these four must be consecutive for LDMs
srcy0           RN      4               ; check the code carefully if you
srcx1           RN      5               ; change these assignments!
srcy1           RN      6
srcwidth        RN      8               ; these two must be consecutive too
srcheight       RN      9


        [ Medusa
; For TrueColour sprites on B/W printers, we create the temporary
; sprite in a suitable 8bpp mode, and we create our own translation
; table to render the source down to 256 grey-levels.
        ]

sprite_plotmasktransformed
sprite_plotspritetransformed
        Push    "R0-R9,LR"

        PrError sprite_put_no_grestore_return

        CMP     R7, R7, ASR#31          ;If user wants no translation table, then
        MOVEQ   R7, #0                  ;force R7 to zero (internally we use spare bit of R7
                                        ;  to distinguish a translation table from a
                                        ;  sprite palette)
        [ Medusa
        BL      sprite_clear32Ktable
        ]

; Sprite and VDU calls issued from in here should go to the real code.

        LDRB    LR,passthrough
        STRB    LR,sprpassthrough
        ORR     LR,LR,#passthrough_spr
        STRB    LR,passthrough

        [       PSDebugSprite
        PrLnIm  "(sprite_plottransformed\\n) print flush"
        ]

; Calculate the source origin and area
        Push    "r0-r6"
        BIC     r0,r0,#&FF
        ORR     r0,r0,#SpriteReason_ReadSpriteSize
        SWI     XOS_SpriteOp
        MOV     srcwidth, r3                    ; width in srcwidth
        MOV     srcheight, r4                   ; height in srcheight
        Pull    "r0-r6"

        TST     r3, #2
        BEQ     sprite_no_source_clipping

; Now fetch the source rectangle into registers
        Push    "srcx0-srcy1"
        LDMIA   r4, {srcx0-srcy1}               ; x0, y0, x1, y1

        Debug   TransSprite, "Source clipping: ", srcx0, srcy0, srcx1, srcy1

; Clip to sprite size. x0,y0 inclusive, x1,y1 exclusive, which is true
; even if x0 and y0 are swapped for reflection.

        CMP     srcx0, #0               ; If x0 < 0, set it to zero
        MOVLT   srcx0, #0
        CMP     srcx0, srcwidth         ; If x0 >= w, set it to w - 1
        SUBGE   srcx0, srcwidth, #1
        CMP     srcy0, #0               ; If y0 < 0, set it to zero
        MOVLT   srcy0, #0
        CMP     srcy0, srcheight        ; If y0 >= h, set it to h - 1
        SUBGE   srcy0, srcheight, #1
        CMP     srcx1, #-1              ; If x1 < -1, set it to -1
        MOVLT   srcx1, #-1
        CMP     srcx1, srcwidth         ; If x1 > w, set it to w
        MOVGT   srcx1, srcwidth
        CMP     srcy1, #-1              ; If y1 < -1, set it to -1
        MOVLT   srcy1, #-1
        CMP     srcy1, srcheight        ; If y1 > h, set it to h
        MOVGT   srcy1, srcheight

        Debug   TransSprite, "Clipped source area x0 y0 x1 y1 ", srcx0, srcy0, srcx1, srcy1

; Determine actual width and height (into srcwidth, srcheight).  If negative, alter
; start position appropriately (ie, ensure that x0,y0 is the bottom-left pixel required).
        SUBS    srcwidth, srcx1, srcx0          ; width
        ADDMI   srcx0, srcx1, #1                ; swap endpoints
        SUBS    srcheight, srcy1, srcy0         ; height
        ADDMI   srcy0, srcy1, #1                ; swap endpoints

        Debug   TransSprite, "Adjusted area ", srcx0, srcy0, srcx1, srcy1, srcwidth, srcheight

; Now srcx0,srcy0 is the bottom-left point in the source sprite.
        STR     srcx0, sourceclip_x
        STR     srcy0, sourceclip_y

        Pull    "srcx0-srcy1"
        B       sprite_width_and_height_known

sprite_no_source_clipping

        RSB     srcheight, srcheight, #0        ; XXX default is flipped vertically!! !! !!

        Debug   TransSprite, "No source clipping: width & height ", srcwidth, srcheight

        MOV     lr, #0
        STR     lr, sourceclip_x
        STR     lr, sourceclip_y

sprite_width_and_height_known

; Now all registers are as on entry, except srcwidth and srcheight are set
; correctly (though possibly negative indicating reflection (in the
; parallelogram case only)).

; Save current graphics state.

        [       PSCoordSpeedUps
        BL      ensure_OScoords
        BLVC    output_gsave
        |
        BL      output_gsave
        ]
        PrPassError

        TEQ     srcwidth, #0
        TEQNE   srcheight, #0
        BEQ     sprite_put_return               ; Note V is clear

        TST     r3, #1
        BEQ     sprite_explicit_matrix

        Debuga  TransSprite, "Parallelogram"

; R3 bit 0 set; so R6 points to a destination parallelogram.

        MOV     r3, #8                  ; output 4 coordinate pairs
00      LDR     r4, [r6], #4
        Debuga  TransSprite, " ", r4
        PrNumSp r4
        SUBS    r3, r3, #1
        BNE     %BT00
        Debug   TransSprite, ""

; Output the width and height in pixels.  These might be negative.
        PrPair  srcwidth, srcheight
        PrLnIm  "PAR"                   ; fit into parallogram command

; Now make sure that width and height are positive
        CMP     srcwidth, #0
        RSBLT   srcwidth, srcwidth, #0
        CMP     srcheight, #0
        RSBLT   srcheight, srcheight, #0

; Get size again to get the mask and mode values into r5 and r6
; Stack jiggerypokery gets srcwidth and srcheight into r3 and r4

        Push    "srcwidth, srcheight"

        AND     r8,r5,#15                       ; Put the mask flag somewhere safe
                                                ;   XXXX r8 same register as srcwidth
; Check whether the user has asked to use the sprite's palette, rather
; than the translation table.  Adjust if so.
        BL      sprite_checkR5bit4

        BICVC   r0,r0,#&FF
        ORRVC   r0,r0,#SpriteReason_ReadSpriteSize
        SWIVC   XOS_SpriteOp

        Pull    "r3, r4"
        PrPassError

; Make GCOL actions 8-15 identical to actions 0-7 if the sprite has no mask.
; Then ignore GCOL actions other than 0 and 8 (overwriting).
        LDR     lr, [ sp ]                      ; reason code
        AND     lr, lr, #255
        TEQ     lr, #55                         ; is is PlotMaskTransformed?
        MOVEQ   r8, r5                          ; yes; so preserve mask info
        BEQ     %FT00                           ; and skip the colour stuff...

        TEQ     r5, #0                          ; otherwise it's PutSpriteTransformed
        ANDEQ   r8, r8, #7
        TST     r8, #7
        BNE     sprite_put_return      ; Note V is clear

        [ Medusa

; If the sprite is 16 or 32bpp, we want to process it specially.
; XXX check the Sprite code keeps in step with this

        Push    "R0-R2"
        MOV     R0,R6
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        MOV     LR,R2
        Debug   Medusa, "TransSprite Log2BPP=",LR
        Pull    "R0-R2"
        TEQ     LR,#4
        BEQ     %FT02
        TEQ     LR,#5
        BNE     %FT00

; It's a 32bpp sprite.

        LDR     LR,info_features        ;If output is destined for a monochrome
        TST     LR,#1                   ;  printer, fudge the sprite mode
        BEQ     %FT01

        PrLnIm  "1 32 1 1 SS  32 SM"    ;Set up scaling info
        BLVC    sprite_output32bpp
        PrPassError
        B       sprite_put_return

; It's a 16bpp sprite
02
        LDR     LR,info_features        ;If output is destined for a monochrome
        TST     LR,#1                   ;  printer, fudge the sprite mode
        BEQ     %FT01

        PrLnIm  "1 16 1 1 SS  16 SM"    ;Set up scaling info
        BLVC    sprite_output16bpp
        PrPassError
        B       sprite_put_return


; Truecolour sprite->mono printer, so modify the mode number to make a
; similar 8bpp mode and arrange for the real sprite to be plotted into
; that as greyscale
01
        Debuga  Medusa, "Changing transprite type from ", R6
        BIC     R6, R6, #2_11111 :SHL: 27
        ORR     R6, R6, #SpriteType_New8bpp :SHL: 27
        Debug   Medusa, " to ", R6
; And create a suitable translation table, putting the address of the anchor block into R7
        BL      sprite_make32Ktable

        ]

00


;Now setup the special scaling required to ensure correct aspect ratio and size.
;Output:1 <bits/pixel> 1 1 SS
;      :<bits/pixel> SM

        Push    "r0-r4"
        MOV     r5, #1

        MOVVC   r0, r6
        MOVVC   r1, #VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable
        MOVVC   r3, r5, LSL r2

        PrPair  r5, r3,, FallThroughOnError
        PrPair  r5, r5,, FallThroughOnError
        PrLnIm  "SS", FallThroughOnError

        PrNumSp r3,, FallThroughOnError         ; Output bix per pixel
        PrLnIm  "SM", FallThroughOnError

        MOVVC   r1, #VduExt_Log2BPC             ; Adjust X divisor for
        SWIVC   XOS_ReadModeVariable            ; (software) bits/pixel
        MOVVC   r9, r2

        STRVS   r0, [ sp ]
        Pull    "r0-r4"

        LDR     lr, [ sp ]                      ; reason code
        AND     lr, lr, #255
        TEQ     lr, #55                         ; is is PlotMaskTransformed?

; At this point r3 and r4 contain the positive width and height
; of the sprite, possibly source clipped.
        BEQ     sprite_mask_commonoutput
        BNE     sprite_commonoutput

sprite_explicit_matrix

        Debuga  TransSprite, "Explicit matrix"

; Now make sure that width and height are positive
        CMP     srcwidth, #0
        RSBLT   srcwidth, srcwidth, #0
        CMP     srcheight, #0
        RSBLT   srcheight, srcheight, #0

        MOV     r3, #6
sprite_outputtransformloop
        LDR     r4, [ r6 ], #4
        Debuga  TransSprite, " ", r4
        PrNumSp r4
        SUBS    r3, r3, #1
        BNE     sprite_outputtransformloop
        Debug   TransSprite, ""

        PrLnIm  "SDM"

        Debug   TransSprite, "Absolute width and height: ", srcwidth, srcheight

; Do this again to get the mask and mode values into r5 and r6
; Stack jiggerypokery gets srcwidth and srcheight into r3 and r4

        Push    "srcwidth, srcheight"

        AND     r8,r5,#15                       ; Put the mask flag somewhere safe
                                                ;   XXXX r8 same register as srcwidth
; Check whether the user has asked to use the sprite's palette, rather
; than the translation table.  Adjust if so.
        BL      sprite_checkR5bit4

        BICVC   r0,r0,#&FF
        ORRVC   r0,r0,#SpriteReason_ReadSpriteSize
        SWIVC   XOS_SpriteOp
        PrPassError

        Pull    "r3, r4"

; Make GCOL actions 8-15 identical to actions 0-7 if the sprite has no mask.
; Then ignore GCOL actions other than 0 and 8 (overwriting).

        LDR     lr, [ sp ]                      ; reason code
        AND     lr, lr, #255
        TEQ     lr, #55                         ; is is PlotMaskTransformed?
        MOVEQ   r8, r5                          ; yes; so preserve mask info
        BEQ     %FT00                           ; and skip the colour stuff...

        TEQ     r5, #0                          ; otherwise it's PutSpriteTransformed
        ANDEQ   r8, r8, #7
        TST     r8, #7
        BNE     sprite_put_return               ; Note V is clear

        [ Medusa

; If the sprite is 16 or 32bpp, we want to process it specially.
; XXX check the Sprite code keeps in step with this

        Push    "R0-R2"
        MOV     R0,R6
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        MOV     LR,R2
        Debug   Medusa, "TransSprite Log2BPP=",LR
        Pull    "R0-R2"
        TEQ     LR,#4
        BEQ     %FT02
        TEQ     LR,#5
        BNE     %FT00

; It's a 32bpp sprite.

        LDR     LR,info_features        ;If output is destined for a monochrome
        TST     LR,#1                   ;  printer, fudge the sprite mode
        BEQ     %FT01

        BL      transsprite_outputscaling
        BLVC    sprite_output32bpp
        PrPassError
        B       sprite_put_return

; It's a 16bpp sprite
02
        LDR     LR,info_features        ;If output is destined for a monochrome
        TST     LR,#1                   ;  printer, fudge the sprite mode
        BEQ     %FT01

        BL      transsprite_outputscaling
        BLVC    sprite_output16bpp
        PrPassError
        B       sprite_put_return


; Truecolour sprite->mono printer, so modify the mode number to make a
; similar 8bpp mode and arrange for the real sprite to be plotted into
; that as greyscale
01
        Debuga  Medusa, "Changing transprite type from ", R6
        BIC     R6, R6, #2_11111 :SHL: 27
        ORR     R6, R6, #SpriteType_New8bpp :SHL: 27
        Debug   Medusa, " to ", R6
; And create a suitable translation table, putting the address of the anchor block into R7
        BL      sprite_make32Ktable

        ]

00

;Now setup the special scaling required to ensure correct aspect ratio and size.
;Output:<sprXeig> <bits/pixel> <sprYeig> 1 SS
;      :<bits/pixel> SM

        BL      transsprite_outputscaling
        STRVS   r0, [ sp ]

        LDR     lr, [ sp ]                      ; reason code
        AND     lr, lr, #255
        TEQ     lr, #55                         ; is is PlotMaskTransformed?
        BEQ     sprite_mask_commonoutput
        BNE     sprite_commonoutput

;NOTREACHED


;Subroutine to setup the special scaling required to ensure correct aspect ratio and size.
;Output:<sprXeig> <bits/pixel> <sprYeig> 1 SS
;      :<bits/pixel> SM
; This is called for the "explicit matrix" case only.
; R5 and R9 are altered.

transsprite_outputscaling
        Push    "r0-r4,r7-r8,lr"
        MOV     r5, #1

        MOVVC   r0, r6
        MOVVC   r1, #VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   r4, r5, LSL r2                  ; R2=1<<X Eigen factor for sprite

        MOVVC   r0, r6
        MOVVC   r1, #VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable
        MOVVC   r3, r5, LSL r2

        PrPair  r4, r3,, FallThroughOnError
        MOVVC   r1, #VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   r2, r5, LSL r2                  ; R2=1<<Y Eigen factor for sprite
        PrPair  r2, r5,, FallThroughOnError
        PrLnIm  "SS", FallThroughOnError

        PrNumSp r3,, FallThroughOnError         ; Output bix per pixel
        PrLnIm  "SM", FallThroughOnError

        MOVVC   r1, #VduExt_Log2BPC             ; Adjust X divisor for
        SWIVC   XOS_ReadModeVariable            ; (software) bits/pixel
        MOVVC   r9, r2
        BVS     transsprite_outputscaling_exit

; Source clipping!  The desired effect is for the source origin to be pushed through
; the user's transformation matrix.  At present, we have concatted the user's
; matrix with the CTM, and also scaled so that the X coordinates are in bits and
; the Y coordinates are in pixels.  So the following translate command should
; put us in the correct place.
;
; Note that this is not the desired behaviour when the destination is specified
; as a parallelogram, but this code is not used in that case.

        LDR     r7, sourceclip_x
        LDR     r8, sourceclip_y
        TEQ     r7, #0
        TEQEQ   r8, #0
        BEQ     transsprite_outputscaling_exit

        PrPair  r7, r3,, FallThroughOnError     ; r3 still contains bits per pixel
        PrStrIm "mul ", FallThroughOnError
        PrNumSp r8,, FallThroughOnError
        PrLnIm  "T", FallThroughOnError

transsprite_outputscaling_exit
        STRVS   r0, [ sp ]
        Pull    "r0-r4,r7-r8, pc"


        END
@


4.5
log
@Update SpriteOp support, loosen/tighten some checks
Core/Header.s,Core/SWIs.s,Core/Constants.s: Define a new bad pointer rather than using &80000000 since that's now a perfectly valid logical address to have.
Core/Device.s, Core/Sprite.s, PDriverDP/Sprite.s, PDriverPS/Sprite.s: Delete support for the greyscale SpriteOp plots, these were removed from SpriteExtend in 1993. Just error them now. Extend the table of SpriteOps to include letting through TileSpriteScaled.
PDriverDP/Transprite.s: Allow 0 or -1 to mean "has no translation table" in line with PDriverPS and SpriteExtend.
PDriverPS/Sprite.s, PDriverPS/TranSprite.s: Use define instead of magic numbers.

Version 4.62. Tagged as 'PDModules-4_62'
@
text
@d31 1
a31 1
;       r5   = GCOL action (bit 3 for masking, bit 4 for "use palette not transtable")
d252 8
a259 3
        MOV     LR, R6, LSR #27
        Debug   Medusa, "TransSprite T=",LR
        TEQ     LR, #SpriteType_New16bpp
d261 1
a261 1
        TEQ     LR, #SpriteType_New32bpp
d398 8
a405 3
        MOV     LR, R6, LSR #27
        Debug   Medusa, "TransSprite T=",LR
        TEQ     LR, #SpriteType_New16bpp
d407 1
a407 1
        TEQ     LR, #SpriteType_New32bpp
@


4.4
log
@Some PDModule tidy ups
Core/FontSWI.s & PDriverDP/Font.s:
 The pointer compares are now unsigned, so raise the limit for printing strings in top bit set addresses when no length is passed in R7.
 Couple of comment typos.
Core/Header.s:
 A CVS merge mistake left behind two copies of Push/return sequence.
Core/PDriver.s:
 Unused VersionString removed.
PDriverDP/Macros.s & PDriverDP/ManageJob.s:
 Single use unhelpful debug message removed.
PDriverDP/Private2.s & Sprite.s & TranSprite.s:
 Use some of the defines from Hdr:Sprite.
Makefile:
 For ROMming, explicitly state there's no resources phase
PDriverDP/PageBox.s:
 Unjumble the set_sprite_output_state data. The MonoBufferOK and Libra1 switch happen to work when both are {TRUE} but other combinations would output a silly table. Let ObjAsm work out the size instead.

Tested briefly, still printed OK.

Version 4.59. Tagged as 'PDModules-4_59'
@
text
@d288 1
a288 1
        ORR     R6, R6, #2_00100 :SHL: 27
d429 1
a429 1
        ORR     R6, R6, #2_00100 :SHL: 27
@


4.3
log
@Fix for the thingy which sits on SpriteV,it got optimised sometime round
2000 which led to it getting the "redirected to sprite" switch in a
muddle so printing from some apps ended up on the screen not in the
postscript file.
Changed the "%%Creator" string a bit.
Took the opportunity to eliminate all the signed pointer comparisons.
Tightened up the checking of pointers to palettes and translation tables
so that "0 or -1" means to use the default,not <= 0.

Version 4.50. Tagged as 'PDModules-4_50'
@
text
@a252 1
        AND     LR, LR, #31
d254 1
a254 1
        TEQ     LR, #5
d256 1
a256 1
        TEQ     LR, #6
a393 1
        AND     LR, LR, #31
d395 1
a395 1
        TEQ     LR, #5
d397 1
a397 1
        TEQ     LR, #6
@


4.2
log
@Changed to use objasm to avoid any LDR rN,[rN],#0 problems
Changed to use shared Makefiles
Numerous small 32 bit conversion improvements
Bugfix to PDriverPS,it was pulling LR not PC - this has been the case for
many years so not sure how it ever worked.
Due to a bug in objasm 3.27 this checkin will infact not build directly.
You must first
 - rename the PDriverDP dir to PDriverDP2
 - rename the PDriverPS dir to PDriverPS2
 - move the 2 source files of the same name up a directory
checked in in this way to minimise messing in CVS.

Version 4.47. Tagged as 'PDModules-4_47'
@
text
@d39 1
a39 1
;       r7  -> translation table ( <= 0 => none).
d86 2
a87 2
        CMP     R7, #0                  ;If user wants no translation table, then
        MOVLT   R7, #0                  ;force R7 to zero (we use top bit of R7
@


4.1
log
@Initial revision
@
text
@d16 1
a16 1
        
d18 1
a18 1
; 
d21 1
a21 1
; 
d51 1
a51 1
; 
d61 2
a62 2
; of the printer driver info word to reflect this, so that applications 
; authors can take advantage of the new features. 
d102 1
a102 1
        PrLnIm  "(sprite_plottransformed\n) print flush"
d122 1
a122 1
        
d313 1
a313 1
        PrLnIm  "SS", FallThroughOnError                          
d316 1
a316 1
        PrLnIm  "SM", FallThroughOnError                          
d333 1
a333 1
        
d454 1
a454 1
        
d481 1
a481 1
        PrLnIm  "SS", FallThroughOnError                          
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

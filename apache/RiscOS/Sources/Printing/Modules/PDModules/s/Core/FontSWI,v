head	4.8;
access;
symbols
	PDModules-4_64:4.8
	PDModules-4_63:4.8
	PDModules-4_62:4.8
	PDModules-4_61:4.8
	PDModules-4_60:4.8
	PDModules-4_59:4.8
	PDModules-4_58:4.7
	PDModules-4_57:4.7
	PDModules-4_56:4.7
	PDModules-4_55:4.6
	PDModules-4_54:4.5
	PDModules-4_53:4.5
	PDModules-4_52:4.4
	PDModules-4_51:4.4
	PDModules-4_50:4.4
	PDModules-4_49:4.3
	PDModules-4_48:4.3
	PDModules-4_47:4.3
	PDModules-4_46:4.3
	kbracey_32bit_merge:4.2.2.2
	PDModules-4_45:4.3
	PDModules-4_44-4_1_2_7:4.2.2.2
	PDModules-4_44-4_1_2_6:4.2.2.2
	PDModules-4_44-4_1_2_5:4.2.2.2
	PDModules-4_44-4_1_2_4:4.2.2.2
	PDModules-4_44-4_1_2_3:4.2.2.2
	PDModules-4_44-4_1_2_2:4.2.2.2
	PDModules-4_44-4_1_2_1:4.2.2.1
	kbracey_32bit:4.2.0.2
	kbracey_32bit_bp:4.2
	dellis_autobuild_BaseSW:4.2
	Ursula_merge:4.1.7.2
	PDModules-4_44:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.2
	Ursula_RiscPC:4.1.7.2.0.4
	rthornb_UrsulaBuild-19Aug1998:4.1.7.2
	UrsulaBuild_FinalSoftload:4.1.7.2
	rthornb_UrsulaBuild-12Aug1998:4.1.7.2
	aglover_UrsulaBuild-05Aug1998:4.1.7.2
	rthornb_UrsulaBuild-29Jul1998:4.1.7.2
	rthornb_UrsulaBuild-22Jul1998:4.1.7.2
	hsimons_BOCA-1_2-Release:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.1.7.2
	rthornb_UrsulaBuild-07Jul1998:4.1.7.2
	rthornb_UrsulaBuild-17Jun1998:4.1.7.2
	rthornb_UrsulaBuild-03Jun1998:4.1.7.2
	rthornb_UrsulaBuild-27May1998:4.1.7.2
	rthornb_UrsulaBuild-21May1998:4.1.7.2
	rthornb_UrsulaBuild_01May1998:4.1.7.2
	afrost_NC2_Generic:4.1.7.2
	afrost_Funai01-33:4.1.7.2
	Ursula:4.1.7.2.0.2
	Ursula_bp:4.1.7.2
	Ursula_31Mar1998:4.2
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spin_merge_28May97:4.1.7.2
	Spinner_B10:4.1.7.2
	Spin_merge_16May97:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2014.10.20.21.53.02;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	kYvwc1FHitWAiZUx;

4.7
date	2011.06.26.12.21.36;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	HO7LfmJCZQPX5bpv;

4.6
date	2008.05.28.12.57.50;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2007.11.05.17.15.42;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2003.03.10.11.33.27;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2001.01.09.13.59.35;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.16.12.55.34;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.48.32;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.10.18.11.32.02;	author sbrodie;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2000.11.24.13.27.32;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.48.32;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.03.57;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.26.58;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.30.42;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.04.30.17.46.00;	author scormie;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Some PDModule tidy ups
Core/FontSWI.s & PDriverDP/Font.s:
 The pointer compares are now unsigned, so raise the limit for printing strings in top bit set addresses when no length is passed in R7.
 Couple of comment typos.
Core/Header.s:
 A CVS merge mistake left behind two copies of Push/return sequence.
Core/PDriver.s:
 Unused VersionString removed.
PDriverDP/Macros.s & PDriverDP/ManageJob.s:
 Single use unhelpful debug message removed.
PDriverDP/Private2.s & Sprite.s & TranSprite.s:
 Use some of the defines from Hdr:Sprite.
Makefile:
 For ROMming, explicitly state there's no resources phase
PDriverDP/PageBox.s:
 Unjumble the set_sprite_output_state data. The MonoBufferOK and Libra1 switch happen to work when both are {TRUE} but other combinations would output a silly table. Let ObjAsm work out the size instead.

Tested briefly, still printed OK.

Version 4.59. Tagged as 'PDModules-4_59'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Core.FontSWI

;----------------------------------------------------------------------------
;
; SWI PDriver_FontSWI implementation
;
;----------------------------------------------------------------------------

fontswi
        Debug   CoreFont, "PDriver_FontSWI",R8
        Push    "LR"

; do precisely nothing if it is a counting pass
        LDR     LR, counting_pass
; Debug   CoreFont, "font counting_pass = ",LR
        CMP     LR, #0
        Pull    "PC",NE

        CMP     R8,#Font_Paint - Font_CacheAddr
        BEQ     fontswi_paint
        CMP     R8,#Font_LoseFont - Font_CacheAddr
        BEQ     fontswi_losefont
        CMP     R8,#Font_SetPalette - Font_CacheAddr
        BEQ     fontswi_setpalette
        CMP     R8,#Font_SetFontColours - Font_CacheAddr
        Pull    "PC",NE

; This is a Font_SetFontColours call. We need to tell the printer-specific
; code about it.

fontswi_setfontcolours
        Push    "R1,R2,R10,R11"

; Pick up current job's workspace, check for persistent errors, enable
; ESCAPEs and pass through recursive OS_WriteC's

        ASSERT  :BASE:currenthandle = R12
        ASSERT  :INDEX:currenthandle = 0
        ASSERT  currentws = currenthandle + 4
        LDMIA   R12,{R10,R11}           ;R10:=currenthandle, R11:=currentws

        BL      checkpersistenterror
        BVS     fontswi_setfontcolours_persistentreturn

        BL      enableescapes

; Flush any buffered VDU 5 characters

        BLVC    vdu5_flush

; Do the operation

        [       FontColourFixes
        ANDVC   R1,R1,#&F
        ANDVC   R2,R2,#&F
        ]
        BLVC    fontswi_setcolours

; And return

fontswi_setfontcolours_return
        BL      disableandcheckescapes
        BLVS    makepersistenterror
fontswi_setfontcolours_persistentreturn
        Pull    "R1,R2,R10,R11,PC"

; Subroutine to set GCOL-specified colours as well as we are reasonably able
; to. Algorithm used:
;   (A) If a 256-colour mode: if the foreground entry requested has been
;       defined in 'fontpalette', use the components of that entry to set
;       absolute colours. Otherwise use the parameters as GCOLs.
;   (B) If a non-256-colour mode, use any of the full foreground and
;       background entries implied by the call to set absolute colours,
;       provided the entries concerned have been defined. Set any remaining
;       values (including the offset) as GCOLs.

        [ Medusa
;   (C) In 8bpp full palette and 16/32bpp modes, behave exactly as
;       for (A).  If the fontpalette has been set, use it (it contains
;       24bit RGB values).  Otherwise, treat the numbers as GCOLs
;       which will subsequently be looked up by gcol_lookup.
        ]

fontswi_setcolours
        Debug   Colour, "fontswi_setcolours"
        Push    "R1-R5,LR"
        [       :LNOT:FontColourFixes
        CMP     R1,#-1                          ;Beware of out of range
        ANDNE   R1,R1,#&0F                      ;  parameters
        CMP     R2,#-1
        ANDNE   R2,R2,#&0F
        ]
        ADR     R4,fontpalette
        LDR     LR,lgbpp
        TEQ     LR,#3
        [ Medusa
        TEQNE   LR,#4                           ;Treat 16 and 32bpp exactly the same
        TEQNE   LR,#5                           ;  as 8bpp
        ]
        BNE     fontswi_setcolours_normal

        [       FontColourFixes

; OSS 23 Jan 91 *** TEQ instead of CMP

        TEQ     R2,#TopBit                      ;Setting foreground?
        |
        CMP     R2,#-1                          ;Setting foreground?
        ]
        BEQ     fontswi_setcolours_offset       ;Not much to do if not (Note
                                                ;  V clear if branch taken)
        LDR     LR,[R4,R2,LSL #2]!
        CMP     LR,#-1                          ;Has entry been set?
        BEQ     fontswi_setcolours_256col_gcol  ;Do what we can if not
        MOV     R2,LR
        BL      font_absfg
        LDRVC   R1,[R4,#16*4]
        BLVC    font_absbg
        [       :LNOT:FontColourFixes
        LDRVC   R3,[R4,#2*16*4]
        ]
        B       fontswi_setcolours_offset

fontswi_setcolours_256col_gcol
        [       FontColourFixes

; OSS 23 Jan 91 *** TEQ instead of CMP

        TEQ     R1,#TopBit
        |
        CMP     R1,#-1
        ]
        BLNE    font_bg                         ;Last, desperate, almost
        BLVC    font_fg                         ;  certainly wrong attempt!
        B       fontswi_setcolours_offset

fontswi_setcolours_normal
        [       FontColourFixes

; OSS 23 Jan 91 *** TEQ instead of CMP

        TEQ     R1,#TopBit                      ;Setting background?
        |
        CMP     R1,#-1                          ;Setting background?
        ]
        BEQ     fontswi_setcolours_normal_tryfg
        LDR     LR,[R4,R1,LSL #2]
        CMP     LR,#-1
        BNE     fontswi_setcolours_normal_absbg
        BL      font_bg
        B       fontswi_setcolours_normal_tryfg
fontswi_setcolours_normal_absbg
        MOV     R1,LR
        BL      font_absbg

fontswi_setcolours_normal_tryfg
        BVS     fontswi_setcolours_offset
        [       FontColourFixes

; OSS 23 Jan 91 *** TEQ instead of CMP

        TEQ     R2,#TopBit                      ;Setting foreground?
        |
        CMP     R2,#-1                          ;Setting foreground?
        ]
        BEQ     fontswi_setcolours_offset
        MOV     LR,R3
        [       FontColourFixes

; OSS 23 Jan 91 *** TEQ instead of CMP

        TEQ     LR,#TopBit
        |
        CMP     LR,#-1
        ]
        LDREQ   LR,fontcoloffset
        ADD     LR,R2,LR
        AND     LR,LR,#&F
        LDR     LR,[R4,LR,LSL #2]
        CMP     LR,#-1
        BNE     fontswi_setcolours_normal_absfg
        BL      font_fg
        B       fontswi_setcolours_offset
fontswi_setcolours_normal_absfg
        MOV     R2,LR
        BL      font_absfg

fontswi_setcolours_offset
        Pull    "R1-R5,PC",VS
        [       FontColourFixes

; OSS 23 Jan 91 *** TEQ instead of CMP

        TEQ     R3,#TopBit
        |
        CMP     R3,#-1
        ]
        STRNE   R3,fontcoloffset
        BLNE    font_coloffset
                Pull    "R1-R5,PC"

; This is a Font_SetPalette call. Use it to update our 'fontpalette' table.

        [ Medusa
; 8bpp full palette and 16/32bpp modes are treated as for old 8bpp modes
        ]

fontswi_setpalette
        Push    "R1-R11"

; Pick up current job's workspace, check for persistent errors, enable
; ESCAPEs and pass through recursive OS_WriteC's

        ASSERT  :BASE:currenthandle = R12
        ASSERT  :INDEX:currenthandle = 0
        ASSERT  currentws = currenthandle + 4
        LDMIA   R12,{R10,R11}           ;R10:=currenthandle, R11:=currentws

        BL      checkpersistenterror
        BVS     fontswi_setpalette_persistentreturn

        BL      enableescapes

; Flush any buffered VDU 5 characters

        BLVC    vdu5_flush
        BVS     fontswi_setpalette_return

; Do the real work

        AND     R1,R1,#&F               ;Don't trust the outside world!
        AND     R2,R2,#&F               ;  (But can trust R3, as font manager
        BIC     R4,R4,#&FF              ;  checks it.)
        BIC     R5,R5,#&FF
        ADR     R6,fontpalette          ;Address 'fontpalette' table
        LDR     LR,lgbpp                ;256 colour mode or higher
        CMP     LR,#3                   ;NB clears V if EQ
        [       FontColourFixes
        BCC     fontswi_setpalette_not256
        STR     R5,[R6,R2,LSL #2]!      ;If so, store desired foreground
        STR     R4,[R6,#16*4]           ;  and background,
        STR     R3,fontcoloffset        ;  set the offset and return
        BL      font_coloffset
        B       fontswi_setpalette_return
fontswi_setpalette_not256
        |
        STRCS   R5,[R6,R2,LSL #2]!      ;If so, store desired foreground,
        STRCS   R4,[R6,#16*4]           ;  background and offset and return
        STRCS   R3,[R6,#2*16*4]
        BCS     fontswi_setpalette_return
        ]

        STR     R4,[R6,R1,LSL #2]       ;Store background colour

        MOVS    R7,R3                   ;Get divisor and initial multipliers
        RSBMI   R7,R7,#0                ;  for colour calculations. Initial
        ADD     R1,R7,#1                ;  bg multiplier is ABS(R3), initial
        MOV     R8,#1                   ;  fg multiplier is 1, divisor is
                                        ;  ABS(R3)+1
fontswi_setpalette_loop
        AND     R2,R2,#&F               ;Reduce R2 MOD 16

        MOV     R9,R4,LSR #24           ;Calculate blue component of result
        MOV     R10,R5,LSR #24
        BL      fontswi_setpalette_interpolate
        MOV     R11,R10,LSL #24

        MOV     R9,R4,LSR #16           ;Calculate green component of result
        MOV     R10,R5,LSR #16
        AND     R9,R9,#&FF
        AND     R10,R10,#&FF
        BL      fontswi_setpalette_interpolate
        ORR     R11,R11,R10,LSL #16

        MOV     R9,R4,LSR #8            ;Calculate red component of result
        MOV     R10,R5,LSR #8
        AND     R9,R9,#&FF
        AND     R10,R10,#&FF
        BL      fontswi_setpalette_interpolate
        ORR     R11,R11,R10,LSL #8

        STR     R11,[R6,R2,LSL #2]      ;And store interpolated colour

        CMP     R3,#0                   ;Move R2 in correct direction
        ADDGE   R2,R2,#1
        SUBLT   R2,R2,#1
        ADD     R8,R8,#1                ;Increment foreground multiplier
        SUBS    R7,R7,#1                ;Decrement background multiplier
        BGE     fontswi_setpalette_loop ;Loop till full foreground

fontswi_setpalette_return
        BL      disableandcheckescapes
        BLVS    makepersistenterror
fontswi_setpalette_persistentreturn
        Pull    "R1-R11,PC"             ;Note V is clear

; Subroutine to interpolate a colour component.
; Entry: R1 = divisor
;        R7 = bg multiplier
;        R8 = fg multiplier
;        R9 = bg component
;        R10 = fg component
; Exit:  R9 corrupt
;        R10 = interpolated component

fontswi_setpalette_interpolate
        Push    "LR"
        MUL     R9,R7,R9                ;bg multiplier * bg
        MLA     R9,R8,R10,R9            ;+ fg multiplier * fg
        ADD     R9,R9,R1,ASR #1         ;Adjust for rounding
        DivRem  R10,R9,R1,LR            ;Divide by divisor
        Pull    "PC"

; This is a Font_LoseFont call. We need to tell all print jobs so that they
; can forget about any slaved fonts.

fontswi_losefont
        Push    "R11"
        ADR     R11,printjoblist - (:INDEX:joblink)
        ASSERT  :BASE:joblink = R11
fontswi_losefont_loop
        LDR     R11,joblink
        CMP     R11,#0
        Pull    "R11,PC",EQ             ;Return with VC if end of list
        BL      font_losefont
        BVC     fontswi_losefont_loop
        Pull    "R11,PC"


;This routine handles the Font_Paint SWI, it replaces the one above
;due to extensions within the RISC OS 3.00 Font Manager for transformed
;fonts, kerning and backwards writing.

        ASSERT :BASE:currenthandle = R12
        ASSERT :INDEX:currenthandle = 0
        ASSERT currentws = currenthandle + 4

      [ UCSText
        ; Utility macros used within fontswi_paint when handling UCS text.

        ; Read an unsigned integer from the string
        ;
        ; $ptr points to the start of the sequence to read
        ; $val is populated with the value read (1 byte, short or long)
        ;
        ; $ptr is advanced to after the read sequence
        ;
        ; This routine is taken from the FontManager sources
        ;
        MACRO
$lab    readuint1 $ptr, $val

$lab    LDR     $val, fontpaint_initflags
        AND     $val, $val, #fontpaintflag_16bit:OR:fontpaintflag_32bit
        CMP     $val, #fontpaintflag_16bit
        LDRLOB  $val, [$ptr], #1
        LDRHI   $val, [$ptr], #4                ; assume word aligned
        ASSERT  $val <> R14
        LDREQB  $val, [$ptr], #1
        LDREQB  R14, [$ptr], #1
        ORREQ   $val, $val, R14, LSL #8

        MEND

        ; Read a signed integer from the string
        ;
        ; $ptr points to the start of the sequence to read
        ; $val is populated with the value read (1 byte, short or long)
        ;
        ; $ptr is advanced to after the read sequence
        ;
        ; This routine is taken from the FontManager sources
        ;
        MACRO
$lab    readint1 $ptr, $val

$lab    LDR     $val, fontpaint_initflags
        AND     $val, $val, #fontpaintflag_16bit:OR:fontpaintflag_32bit
        CMP     $val, #fontpaintflag_16bit
        LDRLOB  $val, [$ptr], #1
        MOVLO   $val, $val, LSL #24             ; sign-extend
        MOVLO   $val, $val, ASR #24
        LDRHI   $val, [$ptr], #4                ; assume word aligned
        ASSERT  $val <> R14
        LDREQB  $val, [$ptr], #1
        LDREQB  R14, [$ptr], #1
        ORREQ   $val, $val, R14, LSL #8
        MOVEQ   $val, $val, LSL #16             ; sign-extend
        MOVEQ   $val, $val, ASR #16

        MEND

        ; Read an unsigned integer from the string without advancing the pointer
        ;
        ; $ptr points to the start of the sequence to read
        ; $len will be populated with the length (in bytes) of the value
        ; $val is populated with the value read (1 byte, short or long)
        ;
        ; This routine is based on readuint1 in the FontManager sources
        ;
        MACRO
$lab    readuint1_len        $ptr, $len, $val

$lab    LDR     $val, fontpaint_initflags
        AND     $val, $val, #fontpaintflag_16bit:OR:fontpaintflag_32bit
        CMP     $val, #fontpaintflag_16bit
        LDRLOB  $val, [$ptr]                ;8bit
        MOVLO   $len, #1
        LDRHI   $val, [$ptr]                ;32bit
        MOVHI   $len, #4
        LDREQB  $val, [$ptr, #0]            ;16bit
        LDREQB  $len, [$ptr, #1]
        ORREQ   $val, $val, $len, LSL#8
        MOVEQ   $len, #2

        MEND

        ; Read a signed integer from the string
        ;
        ; $ptr points to the start of the sequence to read
        ; $val is populated with the value read (3 bytes, or 2 shorts, or 1 long)
        ; $scratch is a scratch register
        ;
        ; $ptr is advanced to after the read sequence
        ;
        ; This routine is taken from the FontManager sources
        ;
        MACRO
$lab    readint3 $ptr, $val, $scratch

$lab    LDR     $scratch, fontpaint_initflags
        AND     $scratch, $scratch, #fontpaintflag_16bit:OR:fontpaintflag_32bit
        CMP     $scratch, #fontpaintflag_16bit

        LDRLOB  $val, [$ptr], #1                ; byte 0
        LDRLOB  $scratch, [$ptr], #1            ; byte 1
        ORRLO   $val, $val, $scratch, ASL #8
        LDRLOB  $scratch, [$ptr], #1            ; byte 2
        ORRLO   $val, $val, $scratch, ASL #16
        MOVLO   $val, $val, ASL #8              ; sign-extend
        MOVLO   $val, $val, ASR #8

        LDREQB  $val, [$ptr], #1                ; note that this could span a word boundary
        LDREQB  $scratch, [$ptr], #1
        ORREQ   $val, $val, $scratch, LSL #8
        LDREQB  $scratch, [$ptr], #1
        ORREQ   $val, $val, $scratch, LSL #16
        LDREQB  $scratch, [$ptr], #1
        ORREQ   $val, $val, $scratch, LSL #24

        LDRHI   $val, [$ptr], #4

        MEND

        ; Read an RGB value from the string
        ;
        ; $ptr points to the start of the sequence to read
        ; $val is populated with the value read
        ; $scratch is a scratch register
        ;
        ; $ptr is advanced to after the read sequence
        ;
        ; This routine is taken from the FontManager sources
        ;
        MACRO
$lab    readRGB $ptr, $val, $scratch

$lab    LDR     $scratch, fontpaint_initflags
        AND     $scratch, $scratch, #fontpaintflag_16bit:OR:fontpaintflag_32bit
        CMP     $scratch, #fontpaintflag_16bit

        LDRLOB  $val, [$ptr], #1                ; byte 0
        LDRLOB  $scratch, [$ptr], #1            ; byte 1
        ORRLO   $val, $val, $scratch, LSL #8
        LDRLOB  $scratch, [$ptr], #1            ; byte 2
        ORRLO   $val, $val, $scratch, LSL #16
        MOVLO   $val, $val, LSL #8              ; &BBGGRR00

        LDREQB  $val, [$ptr], #2                ; note that this could span a word boundary
        MOVEQ   $val, $val, LSL #8              ; &0000RR00
        LDREQB  $scratch, [$ptr], #1
        ORREQ   $val, $val, $scratch, LSL #16
        LDREQB  $scratch, [$ptr], #1
        ORREQ   $val, $val, $scratch, LSL #24   ; &BBGGRR00

        LDRHI   $val, [$ptr], #4                ; easy in 32-bit mode

        MEND

      ] ; UCSText

fontswi_paint
        Push    "R0-R11"

        Debug   CoreFont, "Font paint entered r1,r2,r7=",R1,R2,R7

        LDMIA   R12,{R10,R11}           ;R10 =current handle, R11 =current workspace
        BL      checkpersistenterror
        BVS     fontswi_paint_persistentreturn

        STR     R0,fontpaint_initfont   ;Initial font (this will be revised below in light
                                        ; of R2 bit 8)
        BL      enableescapes
        BLVC    vdu5_flush              ;Flush any buffered VDU 5 characters

        Push    "R3"
        MOVVC   R3,#intercept_all -intercept_font
        BLVC    changeintercept
        Pull    "R3"                    ;Stop intercepting PDriver_FontSWIs
        BVS     fontswi_paint_return

;Setup has been started we must now attempt to setup the pre-paint coordinates
;and ready ourselves for the painting extravanganzer.

        TST     R2,#fontpaintflag_mpoint
        BEQ     fontswi_paint_coordsinmpoint

        Push    "R1,R2"
        MOV     R1,R3
        MOV     R2,R4
        SWI     XFont_Converttopoints   ;Ensure that start position in millipoints
        MOVVC   R3,R1
        MOVVC   R4,R2                   ;And copy the coordinates up correctly
        Pull    "R1,R2"
        BVS     fontswi_paint_return    ;Give an error back to the caller

;Coordinates are now in millipoints so we must now read the information
;about the string and ready ourselfs for the reset of the deocding.  We now
;perform a string width to get the maximum X and Y offsets, last character
;and finally the number of split characters (" ").  This information is
;used for justification.

fontswi_paint_coordsinmpoint
        Push    "R0-R7"

      [ UCSText
        ;Preserve UCS flag bits
        AND     R3,R2,#fontpaintflag_16bit:OR:fontpaintflag_32bit
        TST     R2,#fontpaintflag_kern  ;Is kerning being performed?
        LDR     R2,=&140120
        ORR     R2,R2,R3
        ORRNE   R2,R2,#1:SHL:9          ;Yup, so set the kerning bit
      |
        TST     R2,#fontpaintflag_kern  ;Is kerning being performed?
        LDR     R2,=&140120
        ORRNE   R2,R2,#1:SHL:9          ;Yup, so set the kerning bit
      ]

        MOV     R3,#&2000000
        MOV     R4,#&2000000            ;Big offsets to get the last character

        SUB     SP,SP,#4*9
        MOV     R5,SP                   ;We need some scratch space

        MOV     R0,#0                   ;Using the current font
        STR     R0,[R5]
        STR     R0,[R5,#4]              ;No space add x/y
        STR     R0,[R5,#8]
        STR     R0,[R5,#12]             ;No char add x/y

        MOV     R7,#" "
        STR     R7,[R5,#16]             ;Split character is a space
        SWI     XFont_ScanString        ;Perform the scan of the string

        [ {TRUE}

; Use the 'string width' (offset after printing) rather than the bounding box
; when calculating the justification.  This is because the bounding box returned
; from Font_ScanString does NOT include any embedded movement sequences at the
; start or end of the string (it *does* count ones in the middle).  The string
; width includes ALL the movement caused by escape sequences.

        ADRVC   R0,fontpaint_maxhoffset
        STMVCIA R0,{R3,R4,R7}           ;Write the offset X,Y and the number of split characters

        |

        ADDVC   R0,R5,#20
        LDMVCIA R0,{R0,R1,R2,R3}        ;Get the coordinates returned by the scan string call
        SUBVC   R2,R2,R0
        SUBVC   R3,R3,R1                ;And then calculate the X,Y offsets
        ADRVC   R0,fontpaint_maxhoffset
        STMVCIA R0,{R2,R3,R7}           ;Write the offset X,Y and the number of split characters

        ]

        ADD     SP,SP,#4*9              ;Balance the stack out
        STRVS   R0,[SP]                 ;..and then write any error pointers

        Pull    "R0-R7"
        BVS     fontswi_paint_return

        TST     R2,#fontpaintflag_coordsblk
        BEQ     fontswi_paint_nocoordsblock

;A coordinate block has been specified, we must copy the relevant areas of
;this away into our own workspace assuming that all values are in millipoints
;as 1/256 of an OS unit sequences are not currently supported by the Font Manager.

        Push    "R0-R1,R2-R3"

        ADR     LR,fontpaint_spaceaddX  ;Copy justification information from the block
        LDMIA   R5!,{R0-R1,R8-R9}
        STMIA   LR!,{R0-R1,R8-R9}

        TST     R2,#fontpaintflag_rubout
        ADRNE   LR,fontpaint_ruboutbox
        LDMNEIA R5!,{R0-R1,R8-R9}
        STMNEIA LR!,{R0-R1,R8-R9}       ;Copy rubout information from the block

        Pull    "R0-R1,R2-R3"           ;Preserve starting font handle and string pointer
        B       fontswi_paint_coordsblock
        LTORG

;Now we need to handle the case of their being no coordinate block.  This is
;simply a case of converting the old style call to be a new style one, ie.
;getting and converting the justification region into coordinate offsets
;and then reading the four points for the rubout box and then stashing them
;in the block in 1/72000" format.

fontswi_paint_nocoordsblock
        Push    "R1-R3"                 ;Needed for coordinate conversion

        MOV     R8,R2                   ;Take a seperate copy of flags word
        ADR     R9,oldpoint             ;Pointer to the OS unit coordinate store

        MOV     LR,#0
        STR     LR,fontpaint_spaceaddY  ;No veritcal justification
        STR     LR,fontpaint_charaddX
        STR     LR,fontpaint_charaddY   ;No micro justification

        TST     R8,#fontpaintflag_justify
        STREQ   LR,fontpaint_spaceaddX  ;No justification to be performed
        BEQ     fontswi_paint_nojustify

        LDMIA   R9!,{R1,R2}             ;Get the justification final point
        SWI     XFont_Converttopoints
        Pull    "R1-R3",VS
        BVS     fontswi_paint_return    ;Return because the call failed

;We now calculate the justification offsets within the line, this is quite
;simple as we already know the number of space characters and the maximum
;offsets within the line.

        SUB     R1,R1,R3                ;Calculate area to justify into
        LDR     R2,fontpaint_maxhoffset
        SUB     R1,R1,R2                ;Remaining space at the end of the line (signed)
        LDR     R2,fontpaint_spacecount
        TEQ     R2,#0                   ;Division by zero?
        MOVEQ   R3,#0
        BEQ     fontswi_paint_divzeroskip

        Push    "R0"                    ;Calculate the inter-word spacing

        CMP     R1,#0
        RSBLT   R1,R1,#0
        SavePSR R0
        DivRem  R3,R1,R2,LR             ;Divide to work out extra spacing information needed
        RestPSR R0,,f
        RSBLT   R3,R3,#0                ;Ensure sign correct as converted to +VE before the divide

        Pull    "R0"                    ;Preserve this it is important

fontswi_paint_divzeroskip
        STR     R3,fontpaint_spaceaddX

;Justification calculated now carry on and see if we need to worry
;about the rubout region.

fontswi_paint_nojustify
        TST     R8,#fontpaintflag_rubout
        BEQ     fontswi_paint_norubout  ;No rubout box so don't bother to unpick the coordinates

;We now have to setup the rubout box, this is stored on the coordinate stack
;as two X,Y coordinate pairs.  We must attempt to read them and then convert
;them to millipoint values to then be used.

        ADR     R3,fontpaint_ruboutbox +(4*4)

        LDMIA   R9!,{R1,R2}
        SWI     XFont_Converttopoints   ;Get the top right of the rubout box in millipoints
        STMVCDB R3!,{R1,R2}             ;Store the converted coordinates

        LDMVCIA R9!,{R1,R2}
        SWIVC   XFont_Converttopoints   ;Get the bottom left of the rubout box in millipoints
        STMVCDB R3!,{R1,R2}             ;Store the converted coordinates

        Pull    "R1-R3",VS
        BVS     fontswi_paint_return

;Rub-out area has now been setup, we must now attempt to tidy up.

fontswi_paint_norubout
        Pull    "R1-R3"

;We have now setup the various registers and the coordinate block to contain meaningful
;information, we must now attempt to setup the registers ready to contain the painting
;of the string.

fontswi_paint_coordsblock
        TST     R2,#fontpaintflag_matrix
        ADREQ   R6,defaultmatrix        ;No matrix specified so use a default.

        Push    "R0-R4"
        LDMIA   R6,{R0-R3,R4,R5}
        ADR     LR,fontpaint_initmatrix
        STMIA   LR,{R0-R3,R4,R5}        ;Copy away the initial matrix to be used
        Pull    "R0-R4"                 ;Preserve the important registers

        TST     R2,#fontpaintflag_length
        ADDNE   R9,R1,R7                ;Calculate ending point of the line
        MOVEQ   R9,#&FFFFFF00           ;Practically limitless length

        Debug   CoreFont, "End of string=",R9

        Push    "R1,R2"
        ADR     LR,usersoffset
        LDMIA   LR,{R1,R2}              ;Read the user offset
        SWI     XFont_Converttopoints   ;And convert to points
        MOVVC   R5,R1
        MOVVC   R6,R2                   ;Copy the values away
        Pull    "R1,R2"                 ;Preserve the string pointer and flags
        BVS     fontswi_paint_return    ;Return if it errors

        Push    "R1-R3"
        TST     R2,#fontpaintflag_usehandle
        LDRNE   R0,fontpaint_initfont   ;Either get the font handle that was passed in R0
        MOVEQ   R0,#0                   ;Or use current font
        TEQ     R0,#0                   ;If font handle is zero
        SWIEQ   XFont_CurrentFont       ;Read the current font being used
        Pull    "R1-R3"

        LDR     LR,bitclear
        BIC     R2,R2,LR                ;Clear out the bonus flags from R2
        SUB     R3,R3,R5
        SUB     R4,R4,R6                ;Adjust the painting position via the user offset

        ADR     LR,fontpaint_initfont
        STMIA   LR,{R0,R1,R2,R3-R4}     ;Store handle, String pointer, Flags, Co-ordinates, Matrix ptr

        ADR     LR,fontpaint_ruboutbox
        LDMIA   LR,{R0-R3}              ;Get the rubout region
        SUB     R0,R0,R5
        SUB     R1,R1,R6
        SUB     R2,R2,R5
        SUB     R3,R3,R6                ;Adjust the rubout region via the user offset
        STMIA   LR,{R0-R3}              ;And then store them away

;We have now setup all the correct data for painting the string and R5 now points
;at the string terminator.  We now call 'font_stringstart' to prepare to
;output the string and find out how many passes over the string are wanted
;and the maximum string chunk length is.

        BL      font_savecolours        ;Take a checkpoint on the colour state
        BLVC    font_stringstart
        BVS     fontswi_paint_return

;Now start performing the passes over the string.  At the start of a pass
;R7 holds the string length limit, R8 the number of passes (count down value),
;R9 points to the string terminator and R10,R11 contain the usual gumpf.

fontswi_paint_nextpass
        Debuga  CoreFont, "Start of pass ",R8
        Debug   CoreFont, " r7,r9 ", R7, R9

        LDR     LR,fontpaint_initfont
        STR     LR,fontpaint_font       ;Setup the starting font

        ADR     LR,fontpaint_initmatrix
        LDMIA   LR,{R0-R3,R4-R5}
        ADR     LR,fontpaint_matrix
        STMIA   LR,{R0-R3,R4-R5}        ;Setup the start matrix to be used

        BL      font_passstart
        BVS     fontswi_paint_return    ;Setup the font and colour information as required

        MOV     R0,#0                   ;Underline thickness to zero
        STR     R0,fontpaint_ulpos
        STR     R0,fontpaint_ulthick

        ADR     R0,fontpaint_startpos
        LDMIA   R0,{R1,R2}
        ADR     R0,fontpaint_paintxy
        STMIA   R0,{R1,R2}              ;Setup a copy of the painting position

        LDR     R0,fontpaint_ruboutbox  ;Reset the rubout area start point
        STR     R0,fontpaint_ruboutstart

        LDR     R6,fontpaint_stringaddr ;Setup a pointer to the start of the string

fontswi_paint_interpretloop
        CMP     R6,R9                   ;End of the line yet?
        BCS     fontswi_paint_passdone

      [ UCSText
        ; Get value of next character
        ; R6 advanced to subsequent character
        ; R5 == byte length of read character
        ; LR == character
        BL      readnextchar
      |
        LDRB    LR,[R6],#1
      ]
        Debuga  CoreFont, "  ", R6, LR
        CMP     LR,#32                  ;Is the character printable?
      [ UCSText
        ; Printable, so need to rewind R6
        SUBHS   R6,R6,R5
      ]
        BHS     fontswi_paint_printable

        TEQ     LR,#0                   ;Finished a pass so exit the loop now
        TEQNE   LR,#10
        TEQNE   LR,#13
        BEQ     fontswi_paint_passdone

        TEQ     LR,#9
        TEQNE   LR,#11                  ;Horizontal or vertical offset?
        BEQ     fontswi_paint_movement
        TEQ     LR,#17
        BEQ     fontswi_paint_onecol    ;Single colour change (fore/background)
        TEQ     LR,#18
        BEQ     fontswi_paint_allcols   ;Change both for and background
        TEQ     LR,#19
        BEQ     fontswi_paint_abscols   ;Change to absolute colours
        TEQ     LR,#21
        BEQ     fontswi_paint_comment   ;Skip the comment string
        TEQ     LR,#25
        BEQ     fontswi_paint_underline ;Handle the underlining changing
        TEQ     LR,#26
        BEQ     fontswi_paint_setfont   ;Handle the font changing
        TEQ     LR,#27
        BEQ     fontswi_paint_matrix4   ;Four word matrix (change CTM)
        TEQ     LR,#28
        BEQ     fontswi_paint_matrix    ;Six word matrix (change CTM and offset)

;We have encounted an unknown escape sequence so we must fault it.

        ADR     R0,ErrorBlock_PrintCantThisFontPaint
        BL      LookupSingle
        B       fontswi_paint_return

        MakeInternatErrorBlock PrintCantThisFontPaint,,NoFPnt

fontswi_paint_passdone
        BL      font_passend            ;Inform printer specific code we finished this pass
        BVS     fontswi_paint_finished

        SUBS    R8,R8,#1                ;Decrease the pass counter (clear V)
        BNE     fontswi_paint_nextpass

        BL      font_stringend          ;Allow the printer specific code to tidy up correctly

fontswi_paint_finished
        MOV     R5,R0
        SavePSR R6                      ;Save error pointer and current flags

        LDR     R0,fontpaint_font       ;Font handle at end of paint sequence one (for compatibility)
        SWI     XFont_SetFont
        MOVVC   R0,R5                   ;Restore error pointer if no error
        RestPSR R6,VC,f                 ;And the original flags

fontswi_paint_return
        MOV     R3,#intercept_all
        BL      changeintercept         ;Restore interception of font calls
        BL      disableandcheckescapes  ;Restore escape state and report any that occured during handling
        BLVS    makepersistenterror     ;If an error (or escape) occured then make it a persistent error

fontswi_paint_persistentreturn
        STRVS   R0,[SP]                 ;It errored so return with R0 ->Error block
        Pull    "R0-R11,PC"

;Data used to create the default matrix and also to clear out the unused bit fields.

defaultmatrix
        & 65536, 0, 0, 65536, 0, 0
        ALIGN

bitclear
        & fontpaintflag_coordsblk +fontpaintflag_matrix +fontpaintflag_length +fontpaintflag_usehandle +fontpaintflag_mpoint
        ALIGN

;We now have a printable character, we must attempt to build up a sequence
;of printable characters to pass to the backend and we must attempt to
;loop building this string until we either run out of characters, the chunk
;is filled or a non-printable character is found.

fontswi_paint_printable

;Check to see if an identity matrix is being used, if so then we must
;attempt to clear or set the matrix bit accordingly.

        ADR     LR,fontpaint_matrix
        LDMIA   LR,{R0-R3,R4-R5}        ;Get the matrix being used

        TEQ     R0,#65536
        TEQEQ   R1,#0
        TEQEQ   R2,#0
        TEQEQ   R3,#65536
        TEQEQ   R4,#0
        TEQEQ   R5,#0                   ;Is it an identity matrix?

        LDR     R0,fontpaint_initflags
        ORRNE   R0,R0,#fontpaintflag_matrix
        STR     R0,fontpaint_flags      ;Put together a new set of flags

;Now scan and build up a section of printable characters.

      [ UCSText
        MOV     R1,R6                   ;Point at start of printable characters
      |
        SUB     R1,R6,#1                ;Point at start of printable characters
      ]

fontswi_paint_scanprintables
      [ UCSText
        MOV     R4,R6                   ;Previous char was printable, advance R4
        BL      readnextchar            ;Get the next character
        CMP     LR,#32                  ;Printable?
        CMPHS   R9,R6                   ;loop if printable & more wanted
        BHS     fontswi_paint_scanprintables
        SUB     R5, R4, R1              ;Get the length of this section
      |
        LDRB    LR,[R6],#1              ;Get the next byte
        CMP     LR,#32                  ;Printable?
        CMPHS   R9,R6                   ;loop if printable & more wanted
        BHS     fontswi_paint_scanprintables
        SUB     R5, R6, R1              ;Get the length of this
        SUB     R5, R5, #1              ;section
      ]

;Now:   R1 contains the start of the current chunk
;       R5 contains the length of the current chunk
;       R8 contains the pass number.
;       R9 points to the overall string terminator.
;       R10-R12 usual gumf

;Now attempt to paint the chunk, first we will handle the setting up of the
;rubout region - to do this we must see if the end point is greater than
;then user specified end point, if so then we can clip it and then
;turn the rubout handling off as it is invalid.
;
;Then we must paint the chunk of printable characters

        BL      fontswi_paint_nextposition
        BVS     fontswi_paint_return    ;Calculate the point after painting the string (used for rubout aswell)

        LDR     R6,fontpaint_initflags  ;Are we supposed to be handling the rubout?
        TST     R6,#fontpaintflag_rubout
        BEQ     fontswi_paintnorubout

        LDR     R3,fontpaint_ruboutbox+8
        LDR     R4,fontpaint_paintendxy ;Get the rubout end and the string end points
        CMP     R3,R4
        MOVGT   R3,R4                   ;If rubout ends before end of this chunk then truncate end point and setup
                                        ;  flag to indicate that rubout has been finished.

        BICGT   R6,R6,#fontpaintflag_rubout
        STR     R3,fontpaint_ruboutend

fontswi_paintnorubout
        ADR     R3,fontpaint_paintxy
        LDMIA   R3,{R3,R4}              ;Get the new painting position
        BL      font_paintchunk         ;Attempt to paint a suitable chunk
        BVS     fontswi_paint_return

        STR     R6,fontpaint_initflags  ;Store the modified painting flags (minus rubout if being turned off!)

        ADR     LR,fontpaint_paintendxy ;Setup the new painting coordinates
        LDMIA   LR,{R3,R4}
        ADR     LR,fontpaint_paintxy
        STMIA   LR,{R3,R4}

        LDR     R3,fontpaint_ruboutend  ;Swap the coordinates around correctly for the next chunk to be painted
        STR     R3,fontpaint_ruboutstart

        ADD     R6,R1,R5                ;Setup pointer to the next character
        B       fontswi_paint_interpretloop


;This code is used to calculate the position after painting the string.  The routine
;uses Font_ScanString with the same parameters as passed into the font_paintchunk
;call to get the offset to add onto the painting coordinates after the chunk.
;
;The routine sets up 'fontpaint_paintendxy' to contain the correct values.

        ASSERT  fontpaint_paintendxy =fontpaint_paintxy +8

fontswi_paint_nextposition
        Push    "R0-R7,LR"

        MOV     R7,R5                   ;Length of the section to be scanned

        ADR     R2,fontpaint_spaceaddX
        LDMIA   R2,{R3-R6}
        MOV     LR,#-1                  ;Split character is -1 (none)
        Push    "R3-R6,LR"              ;Push justification + split character

        LDR     R0,fontpaint_font       ;Get the handle of the font to be used

        LDR     R2,fontpaint_flags      ;Setup a valid flags word
      [ UCSText
        ;Ensure that UCS bits are preserved
        AND     R2,R2,#fontpaintflag_reversed +fontpaintflag_kern +fontpaintflag_matrix +fontpaintflag_16bit +fontpaintflag_32bit
      |
        AND     R2,R2,#fontpaintflag_reversed +fontpaintflag_kern +fontpaintflag_matrix
      ]
        ORR     R2,R2,#fontpaintflag_coordsblk +fontpaintflag_usehandle +fontpaintflag_length

        MOV     R3,#BigNum
        MOV     R4,#BigNum              ;Maximum offsets to get the caret position
        MOV     R5,SP                   ;Pointer to my coordinate block copy on the stack
        ADR     R6,fontpaint_matrix
        SWI     XFont_ScanString        ;Returns the nearest caret position to use as coordaintes
        ADD     SP,SP,#4*5              ;Balance the stack correctly
        BVS     fontswi_paint_nextpositionreturn

        ADR     LR,fontpaint_paintxy
        LDMIA   LR!,{R1,R2}
        ADD     R1,R1,R3
        ADD     R2,R2,R4
        STMIA   LR,{R1,R2}              ;Adjust the painting position correctly

fontswi_paint_nextpositionreturn
        STRVS   R0,[SP]
        Pull    "R0-R7,PC"


;Now we handle the various escape sequences within the line.  These routines
;attempt to unpack and handle the bits as required.

fontswi_paint_movement
        TEQ     LR,#11                          ;9 (X move) or 11 (Y move).
        ADR     R0,fontpaint_paintxy            ;  Address correct
        ADDEQ   R0,R0,#4                        ;  co-ordinate, then get
      [ UCSText
        readint3 R6,R1,LR
      |
        LDRB    R1,[R6],#1                      ;  3 byte number
        LDRB    LR,[R6],#1
        ORR     R1,R1,LR,LSL #8
        LDRB    LR,[R6],#1
        MOV     LR,LR,LSL #24
        ORR     R1,R1,LR,ASR #8
      ]
        LDR     LR,[R0]                 ;Update offset co-ordinate and loop
        ADD     LR,LR,R1
        STR     LR,[R0]
        B       fontswi_paint_interpretloop

fontswi_paint_onecol                    ;Deal with 17 (single colour change)
      [ UCSText
        readuint1 R6,R1                 ;Get the new colour
        MOV     LR,R1
      |
        LDRB    LR,[R6],#1              ;Get the new colour
      ]

        [       FontColourFixes
        MOV     R1,#TopBit
        MOV     R2,#TopBit
        MOV     R3,#TopBit
        |
        MOV     R1,#-1
        MOV     R2,#-1
        MOV     R3,#-1
        ]
        CMP     LR,#128
        ANDLT   R2,LR,#&F
        ANDGE   R1,LR,#&F
        B       fontswi_paint_docolours

fontswi_paint_allcols                   ;Deal with 18 (change all colours)
      [ UCSText
        readuint1 R6,R1
        readuint1 R6,R2
        readuint1 R6,R3
      |
        LDRB    R1,[R6],#1
        LDRB    R2,[R6],#1
        LDRB    R3,[R6],#1
      ]
        AND     R1,R1,#&F
        AND     R2,R2,#&F
        [       FontColourFixes
        MOV     R3,R3,LSL #24
        MOV     R3,R3,ASR #24
        |
        AND     R3,R3,#&F
        ]
fontswi_paint_docolours
        BL      fontswi_setcolours
        BVC     fontswi_paint_interpretloop
        B       fontswi_paint_return

fontswi_paint_abscols                   ;Deal with 19 (set absolute colours)
      [ UCSText
        readRGB        R6,R1,R2
      |
        LDRB    R1,[R6],#1
        LDRB    R2,[R6],#1
        LDRB    R3,[R6],#1
        MOV     R1,R1,LSL #8
        ORR     R1,R1,R2,LSL #16
        ORR     R1,R1,R3,LSL #24
      ]
        BL      font_absbg
      [ UCSText
        ; readRGB will clear V, so exit here if V is set
        BVS     fontswi_paint_return
        readRGB R6,R2,R1
      |
        LDRVCB  R1,[R6],#1
        LDRVCB  R2,[R6],#1
        LDRVCB  R3,[R6],#1
        MOVVC   R2,R2,LSL #16
        ORRVC   R2,R2,R1,LSL #8
        ORRVC   R2,R2,R3,LSL #24
      ]
        BLVC    font_absfg
      [ UCSText
        ; readuint1 will clear V, so exit here if V is set
        BVS     fontswi_paint_return
        readuint1 R6,R3
      |
        LDRVCB  R3,[R6],#1
      ]
        [       FontColourFixes
        MOVVC   R3,R3,LSL #24
        MOVVC   R3,R3,ASR #24
        ]
        STRVC   R3,fontcoloffset
        BLVC    font_coloffset
        BVC     fontswi_paint_interpretloop
        B       fontswi_paint_return

fontswi_paint_comment
fontswi_paint_commentloop               ;Deal with 21 (comment)
      [ UCSText
        readuint1 R6,R1
        MOV     R1,LR
      |
        LDRB    LR,[R6],#1
      ]
        CMP     LR,#32
        BHS     fontswi_paint_commentloop
        B       fontswi_paint_interpretloop

fontswi_paint_underline                 ;Deal with 25 (underline control)
      [ UCSText
        readint1  R6,R0                 ;FIXME - why isn't pos sign-extended in non UCS case?
        readuint1 R6,R1
      |
        LDRB    R0,[R6],#1
        LDRB    R1,[R6],#1
      ]
        ADR     LR,fontpaint_ulpos
        STMIA   LR,{R0,R1}
        ASSERT  fontpaint_ulthick = fontpaint_ulpos+4
        B       fontswi_paint_interpretloop

fontswi_paint_setfont                   ;Deal with 26 (change font)
      [ UCSText
        readuint1 R6,R0
      |
        LDRB    R0,[R6],#1
      ]
        STR     R0,fontpaint_font
        B       fontswi_paint_interpretloop

      [ UCSText
        ; Transformation matrices are word-aligned 32bit words, regardless
        ; of character width. Thus, there's nothing special to do for UCS text.
      ]

fontswi_paint_matrix4
        Push    "R0-R3,R4-R5"
        ADD     R6,R6,#3
        BIC     R6,R6,#3                ;Align to nice word boundary

        LDMIA   R6!,{R0-R3}
        MOV     R4,#0
        MOV     R5,#0                   ;Munge the translation point to zero

        ADR     LR,fontpaint_matrix
        STMIA   LR,{R0-R3,R4-R5}

        Pull    "R0-R3,R4-R5"
        B       fontswi_paint_interpretloop

fontswi_paint_matrix
        Push    "R0-R3,R4-R5"
        ADD     R6,R6,#3
        BIC     R6,R6,#3                ;Align to nice word boundary

        LDMIA   R6!,{R0-R3,R4,R5}       ;Read the matrix from the string
        ADR     LR,fontpaint_matrix
        STMIA   LR,{R0-R3,R4-R5}

        Pull    "R0-R3,R4-R5"
        B       fontswi_paint_interpretloop

      [ UCSText
; In    R6 -> next char to read
;       fontpaint_font = font handle to use
;       fontpaint_initflags = Font_Paint flags (for character width information)
; Out   R5 = length read (in bytes)
;       R6 updated
;       LR = next character
;
; Adapted from FontManager sources

readnextchar Entry "R0-R4,R7"

        readuint1_len R6,R5,R0
        ADD     R6,R6,R5

; If the returned number is <= &7F, the encoding is immaterial.
        CMP     R0,#&7F
        BLS     %FT99

        Push    "R0-R7"

        LDR     R0,fontpaint_font
        ADRL    R1,error_buffer
        LDR     R3,=&4C4C5546
        SWI     XFont_ReadDefn          ; Read the full font identifier
        Pull    "R0-R7",VS
        EXIT    VS

        MOV     R2,#'E'
        SWI     XFont_FindField         ; Find the encoding field
        Pull    "R0-R7",VS
        EXIT    VS

        TEQ     R2,#0
        Pull    "R0-R7",EQ
        BEQ     %FT99                   ; none - assume 8bit

        DebugS  CoreFont,"Encoding",R1

; Unless font's encoding is UCS, we've finished

        ADR     R3,encoding_UTF8
05
        LDRB    R2,[R1],#1
        LDRB    R4,[R3],#1

        CMP     R4,#32                  ; hit the end?
        BCC     %FT07
        TEQ     R2,R4                   ; no, straight match?
        Pull    "R0-R7",NE
        BNE     %FT99
        BEQ     %BT05
07
        CMP     R2,#32
        Pull    "R0-R7"                 ; unconditional
        BCS     %FT99

; OK, it's UCS - check character width to see if we're reading UTF-8, UTF-16 or UCS-4

        LDR     R14,fontpaint_initflags
        ASSERT  fontpaintflag_16bit < fontpaintflag_32bit
        AND     R14,R14,#fontpaintflag_16bit:OR:fontpaintflag_32bit
        CMP     R14,#fontpaintflag_16bit
        BHI     %FT99
        BEQ     %FT20

; UTF-8 parsing:
;
; Top n bits of first byte => how many bytes are in the code
; Top 2 bits of each continuation byte must be 10
; Other bits of first byte and continuations form the output byte
; most significant bits are read first
; So:
;       0xxxxxxx                    => &0000-&007F ( 7 bits)
;       110xxxxx 10xxxxxx           => &0080-&07FF (11 bits)
;       1110xxxx 10xxxxxx 10xxxxxx  => &0800-&FFFF (16 bits)
; etc. (max 6 bytes, which starts with 1111110x)
; It's also illegal to use an unnecessarily long code, eg.
;       11000000 10000000 => &0000, but this isn't allowed

        MOVS    R14,R0,LSL #25          ; CS => bit 7 was set, MI => bit 6 was set
        BCC     %FT99                   ; bit 7 clear => 1 byte code
        BPL     %FT98                   ; bit 6 clear => continuation byte (illegal - don't read it again)

        CMP     R0,#&FE                 ; &FE, &FF => illegal - don't read it again
        BHS     %FT98

        MOV     R4,#&80                 ; R4 = min value allowable
        MOV     R3,#&800                ; R3 = next bit to check for (NB: we gain only 4 bits the 1st time)
        BIC     R0,R0,#&C0              ; clear used control bits

10      LDRB    R2,[R6],#1
        AND     R14,R2,#&C0
        TEQ     R14,#&80
        BNE     %FT97                   ; it wasn't a continuation byte - step back so it'll be re-read
        ADD     R5,R5,#1                ; increase byte length count

        AND     R2,R2,#&3F              ; R2 = next 6 bits to add in
        ORR     R0,R2,R0,LSL #6         ; add in next 6 bits at the bottom

        TST     R0,#1 :SHL: 31          ; top-bit set is illegal
        BNE     %FT98

        TST     R0,R3                   ; if next control bit set, read another continuation byte
        BICNE   R0,R0,R3                ; clear used control bit in result
        MOVNE   R4,R3                   ; R4 = min value for next time (same as old control bit)
        MOVNE   R3,R3,LSL #5            ; R3 = control bit for next time (5 bits further up)
        BNE     %BT10

; finished reading the character - was it in the right range?

        CMP     R0,R4
        BHS     %FT99                   ; OK if R0 >= R4
        B       %FT98                   ; otherwise return &FFFD

; UTF-16 parsing:
;
; &DC00-&DFFF is illegal
; &D800-&DBFF => next char must be &DC00-&DFFF:
;                result is &10000 + ( (first-&D800) << 10 ) + ( second - &DC00 )
; Illegal => result is &FFFD

20      CMP     R0,#&D800
        BLO     %FT99
        CMP     R0,#&DC00
        BHS     %FT95

        LDRB    R2,[R6],#1
        LDRB    R14,[R6],#1
        ORR     R2,R2,R14,LSL #8
        SUB     R2,R2,#&DC00
        CMP     R2,#&400
        BHS     %FT96                           ; wasn't a continuation code - step back

        ADD     R5,R5,#2                        ; increase byte length count

        SUB     R0,R0,#&D800
        ADD     R0,R2,R0,LSL #10
        ADD     R0,R0,#&10000                   ; result is &10000 + ( (first-&D800) << 10 ) + (second-&DC00)
        B       %FT99

95      CMP     R0,#&E000                       ; R0 is >= &DC00 here
        BHS     %FT99
        B       %FT98                           ; continuation code in wrong place

96      SUB     R6,R6,#1                        ; step back 16 bits

97      SUB     R6,R6,#1                        ; step back 8 bits to character just read

98      LDR     R0,=&FFFD                       ; illegal character

99      MOV     LR,R0

        Debug   CoreFont,"readnextchar returns",LR,R5

        EXIT
        LTORG

encoding_UTF8   DCB     "utf8",0                ; first 4 bytes of encoding is enough to identify UCS
                ALIGN
      ] ; UCSText

        END
@


4.7
log
@Make FontSWI handling ARMv7 safe(r).
Reflects the changes made in FontManager 3.63, except here the changes must be even more bland as this is a disc component so could find itself on something that doesn't support LDRH.
Fix for ticket #289.

Version 4.56. Tagged as 'PDModules-4_56'
@
text
@d616 1
a616 1
        ADR     LR,fontpaint_spaceaddX  ;Copu justification information from the block
d726 1
a726 11

        ;amg  9th May 1994
        ;bignum is too low on a Medusa: it is &02000000, but rma is &02100000
        ;as a result font_paint calls which weren't specifying the string
        ;length, and were printing a string from rma, would fail and actually
        ;print nothing.
        ;Fix is to use the largest POSITIVE number possible. Can't use -1
        ;cos the rest of the code uses signed comparisons

        ;MOVEQ   R9,#BigNum
        MVNEQ   R9,#&80000000           ;gives &7FFFFFFF
d764 1
a764 1
;at the string terminator.  We no call 'font_stringstart' to prepare to
d905 1
a905 1
;attempt to clear or set the matrix being accordingly.
@


4.6
log
@  Fix stack imbalance when printing top-bit-set characters in PDriverDP.
Detail:
  Attempting to print top-bit-set characters in 8bit encoded strings
  resulted in 8 words not being popped from the stack, thus causing a
  stack imbalance.

  This has been fixed by inserting a Pull.
Admin:
  Both PDriverDP and PDriverPS tested on an A9Home with Ovation Pro,
  Fireworkz, and Draw.
  Attempts were made to print plain ASCII and top-bit-set characters.
  No ill effects were witnessed.
  Unicode printing has not been tested due to the current lack of a UCS Font
  Manager that will softload on modern ROL OSes. This change should have no
  effect on Unicode printing, as it will only happen in the non-Unicode case.
  This fixes bug #171.

Version 4.55. Tagged as 'PDModules-4_55'
@
text
@d24 1
a24 1
	Debug	CoreFont, "PDriver_FontSWI",R8
d99 1
a99 1
	Debug	Colour, "fontswi_setcolours"
d348 3
a350 3
        ASSERT :BASE:currenthandle =R12
        ASSERT :INDEX:currenthandle =0
        ASSERT currentws =currenthandle +4
d372 4
a375 3
        LDREQ   $val, [$ptr], #2                ; assume bottom 16 bits are OK for half-word access
        MOVEQ   $val, $val, LSL #16
        MOVEQ   $val, $val, LSR #16
d398 5
a402 2
        LDREQ   $val, [$ptr], #2                ; assume bottom 16 bits are OK for half-word access
        MOVEQ   $val, $val, LSL #16
d425 4
a428 4
        LDREQ   $val, [$ptr]
        MOVEQ   $len, #2                    ;16bit
        MOVEQ   $val, $val, LSL #16
        MOVEQ   $val, $val, LSR #16
d457 4
a460 4
        LDREQ   $val, [$ptr], #2                ; note that this could span a word boundary
        LDREQ   $scratch, [$ptr], #2
        MOVEQ   $val, $val, LSL #16
        MOVEQ   $val, $val, LSR #16
d462 2
d493 6
a498 5
        LDREQ   $val, [$ptr], #2                ; note that this could span a word boundary
        LDREQ   $scratch, [$ptr], #2
        MOVEQ   $val, $val, LSL #16
        MOVEQ   $val, $val, LSR #16             ; &0000RR00
        ORREQ   $val, $val, $scratch, LSL #16   ; &BBGGRR00
d1077 2
a1078 1
        readuint1 R6,LR                 ;Get the new colour
d1164 2
a1165 1
        readuint1 R6,LR
d1175 1
a1175 1
        readint1 R6,R0                  ;FIXME - why isn't pos sign-extended in non UCS case?
a1267 1
        LDR     R2,[R1],#4
d1269 7
a1275 3
        LDR     R3,[R3]

        TEQ     R2,R3
d1278 2
a1279 2

        LDRB    R2,[R1]
d1281 2
a1282 4
        Pull    "R0-R7",HS
        BHS     %FT99

        Pull    "R0-R7"
d1318 1
a1318 1
01      LDRB    R2,[R6],#1
d1334 1
a1334 1
        BNE     %BT01
d1354 3
a1356 3
        LDR     R2,[R6],#2
        MOV     R2,R2,LSL #16
        MOV     R2,R2,LSR #16
d1385 2
a1386 2
encoding_UTF8   DCB     "utf8",0,0,0,0          ; first 4 bytes of encoding is enough to identify UCS
                ALIGN                           ; just in case!
@


4.5
log
@Fixed printing of UTF-8, UTF-16 and UCS-4 encoded text strings for bitmap
  printers (PDriverDP).
Detail:
  The device-independent part of the PDriver code processes command
  sequences in text strings. Additionally, it modifies the flags passed
  to Font_Paint by the client application. This resulted in the character
  width bits (12 and 13) of the Font_Paint flags being stripped and
  command sequences being mis-recognised when UTF-16 or UCS-4 text
  strings were printed.

  The PDriverDP device-specific part of the PDriver code prepends an
  underline command sequence (25,position,thickness) to the printed
  string. This resulted in 8bit data being prepended to a potentially
  16bit or 32bit string.

  The device-independent part has been fixed to preserve the character
  width bits in the Font_Paint flags. It has also gained the ability to
  process UTF-8, UTF-16 and UCS-4 characters correctly.

  The PDriverDP device-specific part has been fixed to insert commands of
  the correct bit-width for the text encoding being used.
Admin:
  PDriverDP tested on Iyonix RO 5.11 with NetSurf for UTF-16 text printing
  and Draw for UTF-8 printing (drawfile exported from NetSurf) and non-UCS
  printing to ensure no regressions occurred.
  PDriverPS tested on Iyonix RO 5.11 with NetSurf and Draw to ensure no
  regression in behaviour. Note that printing of UCS text with PDriverPS
  is not fixed by these changes.
Notes:
  Changes by John-Mark Bell

Version 4.53. Tagged as 'PDModules-4_53'
@
text
@d1252 1
@


4.4
log
@Fix for the thingy which sits on SpriteV,it got optimised sometime round
2000 which led to it getting the "redirected to sprite" switch in a
muddle so printing from some apps ended up on the screen not in the
postscript file.
Changed the "%%Creator" string a bit.
Took the opportunity to eliminate all the signed pointer comparisons.
Tightened up the checking of pointers to palettes and translation tables
so that "0 or -1" means to use the default,not <= 0.

Version 4.50. Tagged as 'PDModules-4_50'
@
text
@d24 1
a24 1
	Debug	Colour, "PDriver_FontSWI"
d29 1
a29 1
; Debug   PageBox, "font counting_pass = ",LR
d352 147
d543 3
d548 1
d550 5
d812 7
d820 1
d823 4
d926 3
d930 1
d933 8
d947 1
d1019 4
d1024 1
d1053 3
d1062 1
d1069 3
d1073 1
d1090 5
d1098 1
d1113 3
d1122 1
d1124 5
d1135 1
d1137 5
d1143 1
d1155 3
d1159 1
d1165 4
d1171 1
d1178 3
d1182 1
d1186 5
d1218 160
@


4.3
log
@  Merge of 32-bit branch.
Detail:
  These modules are now thought to work.
Admin:
  This module has received some testing of both 26-bit and 32-bit
    builds and is believed to function correctly.

Version 4.45. Tagged as 'PDModules-4_45'
@
text
@d253 1
a253 1
        BLT     fontswi_setpalette_not256
d261 4
a264 4
        STRGE   R5,[R6,R2,LSL #2]!      ;If so, store desired foreground,
        STRGE   R4,[R6,#16*4]           ;  background and offset and return
        STRGE   R3,[R6,#2*16*4]
        BGE     fontswi_setpalette_return
d654 1
a654 1
        BGE     fontswi_paint_passdone
@


4.2
log
@Spinner branch merged
@
text
@d365 1
a365 1
        
d371 1
a371 1
                                     
d377 1
a377 1
        
d386 1
a386 1
               
d390 1
a390 1
;and finally the number of split characters (" ").  This information is 
d397 1
a397 1
        LDR     R2,=&140120           
d403 1
a403 1
        SUB     SP,SP,#4*9            
d407 1
a407 1
        STR     R0,[R5]            
d409 1
a409 1
        STR     R0,[R5,#8]            
d431 1
a431 1
        SUBVC   R2,R2,R0           
d457 1
a457 1
        TST     R2,#fontpaintflag_rubout  
d465 1
a465 1
                   
d467 1
a467 1
;simply a case of converting the old style call to be a new style one, ie. 
d472 1
a472 1
fontswi_paint_nocoordsblock        
d477 1
a477 1
        
d485 1
a485 1
        BEQ     fontswi_paint_nojustify 
d491 1
a491 1
   
d505 1
a505 1
           
d507 5
a511 5
        MVNLT   R1,R1
        MOV     R0,PC
        DivRem  R3,R1,R2,LR             ;Divide to work out extra spacing information needed 
        TEQP    R0,#0
        MVNLT   R3,R3                   ;Ensure sign correct as converted to +VE before the divide
d517 1
a517 1
                   
d528 1
a528 1
                      
d530 1
a530 1
               
d540 2
a541 2
        BVS     fontswi_paint_return   
        
d548 1
a548 1
;information, we must now attempt to setup the registers ready to contain the painting 
d560 2
a561 2
                          
        TST     R2,#fontpaintflag_length   
d563 1
a563 1
        
d571 1
a571 1
        
d574 1
a574 1
        
d601 1
a601 1
        
d659 2
a660 2
        BHS     fontswi_paint_printable        
   
d663 1
a663 1
        TEQNE   LR,#13  
d681 1
a681 1
        TEQ     LR,#27  
d687 1
a687 1
      
d689 1
a689 1
        BL      LookupSingle            
d696 1
a696 1
        BVS     fontswi_paint_finished  
d698 1
a698 1
        SUBS    R8,R8,#1                ;Decrease the pass counter
d705 1
a705 1
        MOV     R6,PC                   ;Save error pointer and current flags
d710 1
a710 1
        TEQVCP  R6,#0                   ;And the original flags
d724 1
a724 1
defaultmatrix   
d755 1
a755 1
                                      
d760 1
a760 1
fontswi_paint_scanprintables   
d775 2
a776 2
;rubout region - to do this we must see if the end point is greater than 
;then user specified end point, if so then we can clip it and then 
d780 1
a780 1
                     
d787 1
a787 1
             
d791 1
a791 1
        MOVGT   R3,R4                   ;If rubout ends before end of this chunk then truncate end point and setup 
d795 1
a795 1
        STR     R3,fontpaint_ruboutend 
d801 1
a801 1
        BVS     fontswi_paint_return    
d804 1
a804 1
                             
d808 2
a809 2
        STMIA   LR,{R3,R4}              
                
d815 1
a815 1
                
d829 1
a829 1
      
d840 2
a841 2
                
        MOV     R3,#BigNum 
d854 1
a854 1
                             
d858 1
a858 1
        
d956 1
a956 1
                
d965 1
a965 1
        
@


4.2.2.1
log
@  First attempt at 32-bit compatible modules.
Admin:
  Tested that modules build 26-bit and 32-bit.
  Requires HdrSrc-1_05 or later.

Version 4.44, 4.1.2.1. Tagged as 'PDModules-4_44-4_1_2_1'
@
text
@d365 1
a365 1

d371 1
a371 1

d377 1
a377 1

d386 1
a386 1

d390 1
a390 1
;and finally the number of split characters (" ").  This information is
d397 1
a397 1
        LDR     R2,=&140120
d403 1
a403 1
        SUB     SP,SP,#4*9
d407 1
a407 1
        STR     R0,[R5]
d409 1
a409 1
        STR     R0,[R5,#8]
d431 1
a431 1
        SUBVC   R2,R2,R0
d457 1
a457 1
        TST     R2,#fontpaintflag_rubout
d465 1
a465 1

d467 1
a467 1
;simply a case of converting the old style call to be a new style one, ie.
d472 1
a472 1
fontswi_paint_nocoordsblock
d477 1
a477 1

d485 1
a485 1
        BEQ     fontswi_paint_nojustify
d491 1
a491 1

d505 1
a505 1

d508 3
a510 3
        SavePSR R0
        DivRem  R3,R1,R2,LR             ;Divide to work out extra spacing information needed
        RestPSR R0,,f
d517 1
a517 1

d528 1
a528 1

d530 1
a530 1

d540 2
a541 2
        BVS     fontswi_paint_return

d548 1
a548 1
;information, we must now attempt to setup the registers ready to contain the painting
d560 2
a561 2

        TST     R2,#fontpaintflag_length
d563 1
a563 1

d571 1
a571 1

d574 1
a574 1

d601 1
a601 1

d659 2
a660 2
        BHS     fontswi_paint_printable

d663 1
a663 1
        TEQNE   LR,#13
d681 1
a681 1
        TEQ     LR,#27
d687 1
a687 1

d689 1
a689 1
        BL      LookupSingle
d696 1
a696 1
        BVS     fontswi_paint_finished
d698 1
a698 1
        SUBS    R8,R8,#1                ;Decrease the pass counter (clear V)
d705 1
a705 1
        SavePSR R6                      ;Save error pointer and current flags
d710 1
a710 1
        RestPSR R6,VC,f                 ;And the original flags
d724 1
a724 1
defaultmatrix
d755 1
a755 1

d760 1
a760 1
fontswi_paint_scanprintables
d775 2
a776 2
;rubout region - to do this we must see if the end point is greater than
;then user specified end point, if so then we can clip it and then
d780 1
a780 1

d787 1
a787 1

d791 1
a791 1
        MOVGT   R3,R4                   ;If rubout ends before end of this chunk then truncate end point and setup
d795 1
a795 1
        STR     R3,fontpaint_ruboutend
d801 1
a801 1
        BVS     fontswi_paint_return
d804 1
a804 1

d808 2
a809 2
        STMIA   LR,{R3,R4}

d815 1
a815 1

d829 1
a829 1

d840 2
a841 2

        MOV     R3,#BigNum
d854 1
a854 1

d858 1
a858 1

d956 1
a956 1

d965 1
a965 1

@


4.2.2.2
log
@  Lots of fixes.
Detail:
  Several stack imbalances and missing conditions on instructions fixed.
  Some flag removal code sequences improved (RSB rn,pc,pc:SUB rn,lr,rn)
Admin:
  Built both 26 and 32-bit versions - neither tested.

Version 4.44, 4.1.2.2. Tagged as 'PDModules-4_44-4_1_2_2'
@
text
@d507 1
a507 1
        RSBLT   R1,R1,#0
d511 1
a511 1
        RSBLT   R3,R3,#0                ;Ensure sign correct as converted to +VE before the divide
@


4.1
log
@Initial revision
@
text
@d24 1
d99 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@   Use buffer in workspace for MessageTrans.
   Added 'Colour' debugging flag.
   Do not pass SpriteV calls to pdriver if a Wimp error box is open.
@
text
@a23 1
	Debug	Colour, "PDriver_FontSWI"
a97 1
	Debug	Colour, "fontswi_setcolours"
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.3;
access;
symbols
	PDModules-4_64:4.3
	PDModules-4_63:4.3
	PDModules-4_62:4.3
	PDModules-4_61:4.3
	PDModules-4_60:4.3
	PDModules-4_59:4.3
	PDModules-4_58:4.3
	PDModules-4_57:4.3
	PDModules-4_56:4.3
	PDModules-4_55:4.3
	PDModules-4_54:4.3
	PDModules-4_53:4.3
	PDModules-4_52:4.3
	PDModules-4_51:4.3
	PDModules-4_50:4.3
	PDModules-4_49:4.3
	PDModules-4_48:4.3
	PDModules-4_47:4.3
	PDModules-4_46:4.3
	kbracey_32bit_merge:4.2.2.1
	PDModules-4_45:4.3
	PDModules-4_44-4_1_2_7:4.2.2.1
	PDModules-4_44-4_1_2_6:4.2.2.1
	PDModules-4_44-4_1_2_5:4.2.2.1
	PDModules-4_44-4_1_2_4:4.2.2.1
	PDModules-4_44-4_1_2_3:4.2.2.1
	PDModules-4_44-4_1_2_2:4.2.2.1
	PDModules-4_44-4_1_2_1:4.2.2.1
	kbracey_32bit:4.2.0.2
	kbracey_32bit_bp:4.2
	dellis_autobuild_BaseSW:4.2
	Ursula_merge:4.1.7.2
	PDModules-4_44:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.2
	Ursula_RiscPC:4.1.7.2.0.4
	rthornb_UrsulaBuild-19Aug1998:4.1.7.2
	UrsulaBuild_FinalSoftload:4.1.7.2
	rthornb_UrsulaBuild-12Aug1998:4.1.7.2
	aglover_UrsulaBuild-05Aug1998:4.1.7.2
	rthornb_UrsulaBuild-29Jul1998:4.1.7.2
	rthornb_UrsulaBuild-22Jul1998:4.1.7.2
	hsimons_BOCA-1_2-Release:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.1.7.2
	rthornb_UrsulaBuild-07Jul1998:4.1.7.2
	rthornb_UrsulaBuild-17Jun1998:4.1.7.2
	rthornb_UrsulaBuild-03Jun1998:4.1.7.2
	rthornb_UrsulaBuild-27May1998:4.1.7.2
	rthornb_UrsulaBuild-21May1998:4.1.7.2
	rthornb_UrsulaBuild_01May1998:4.1.7.2
	afrost_NC2_Generic:4.1.7.2
	afrost_Funai01-33:4.1.7.2
	Ursula:4.1.7.2.0.2
	Ursula_bp:4.1.7.2
	Ursula_31Mar1998:4.2
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spin_merge_28May97:4.1.7.2
	Spinner_B10:4.1.7.2
	Spin_merge_16May97:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2001.01.09.13.59.35;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.16.12.55.33;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.48.32;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.10.18.11.32.02;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.48.32;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.03.55;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.26.56;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.30.41;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.05.14.09.35.55;	author jcoxhead;	state Exp;
branches;
next	;


desc
@@


4.3
log
@  Merge of 32-bit branch.
Detail:
  These modules are now thought to work.
Admin:
  This module has received some testing of both 26-bit and 32-bit
    builds and is believed to function correctly.

Version 4.45. Tagged as 'PDModules-4_45'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Core.Error

;----------------------------------------------------------------------------
;
; Error handling
;
;----------------------------------------------------------------------------

; Subroutine to make a persistent error, normally adding a suffix.
; Entry: R0 points to error block
;        R11 points to print job's workspace
; Exit:  R0 points to modified error block
;        V set
;        All other registers preserved

      [ {TRUE}

makepersistenterror
        Push    "R0-R4, R8, LR"

        LDRB    LR, persistenterror
        TEQ     LR, #0                          ; is there a pending persistent error?
        BNE     makepersistenterror_return      ; yes, so don't disturbit

        MOV     R4, R0                          ; -> error string to be fared around with

        ADR     R0, cancelsuffix                ; -> suffix
        BL      LookupToken
        MOVVC   R0, #ModHandReason_Claim
        [ Medusa
        MOVVC   R3, #(?globalerrorbuffer)-4
        |
        MOVVC   R3, #(?errorbuffer)-4
        ]
        SUBVC   R3, R3, R1                      ; get size of buffer
        SWIVC   XOS_Module
        STRVS   R0, [SP]
        BVS     makepersistenterror_return      ; return now because it went wrong

        MOV     R8, R2                          ; -> temp block allocated

        ADD     R0, R4, #4                      ; -> error string
        SUB     R3, R3, #3
makepersistenterror_copy
        TEQ     R3, #0                          ; is the buffer full yet?
        LDRNEB  LR, [R0], #1
        TEQNE   LR, #0                          ; do we have an end of string?
        STRNEB  LR, [R2], #1                    ; store into temporary buffer
        BNE     makepersistenterror_copy

        TEQ     LR, #0                          ; end of string yet?
        MOVNE   LR, #"."
        STRNEB  LR, [R2], #1                    ; no so append ellipsis
        STRNEB  LR, [R2], #1
        STRNEB  LR, [R2], #1
        STRNEB  LR, [R2], #1
        MOV     LR, #0
        STRB    LR, [R2]                        ; terminate to make sure

        BL      OpenMessages
        BVS     makepersistenterror_giveup

        LDR     R0, SharedMessages              ; -> shared messages block
        ADR     R1, cancelsuffix                ; -> token
        [ Medusa
        ADR     R2, globalerrorbuffer
        MOV     R3, #(?globalerrorbuffer)-4
        |
        ADR     R2, errorbuffer                 ; -> suitable error buffer
        MOV     R3, #(?errorbuffer)-4           ;  = size of the buffer
        ]

        LDR     LR, [R4]
        STR     LR, [R2], #4                    ; copy the error message

        MOV     R4, R8                          ; -> string to substitute with
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_Lookup            ; dereference the token
        MOVVC   LR, #1
        STRVCB  LR, persistenterror             ; flag as being a persistent error
        [ Medusa
        ADRVC   R0, globalerrorbuffer
        |
        ADRVC   R0, errorbuffer                 ; -> error buffer
        ]

        BL      CloseMessages                   ; ensure messages file is closed

makepersistenterror_giveup
        STR     R0, [SP]                        ; store -> error block

        MOV     R0, #ModHandReason_Free
        MOV     R2, R8
        SWI     XOS_Module                      ; free the temporary block (ignore errors)

makepersistenterror_return
        SETV                                    ; always ensure that V set on exit
        Pull    "R0-R4, R8, PC"

cancelsuffix
        = "CanSuff", 0
        ALIGN

      |

makepersistenterror
        Push    "R1-R3,LR"
        LDRB    LR,persistenterror              ;Leave an already existing
        TEQ     LR,#0                           ;  persistent error alone
        BNE     makepersistenterror_return      ;  (avoid recursive addition
                                                ;  of " (print cancelled)"
                                                ;  on e.g. PLOT &D0-&D7)
        ADD     R1,R0,#4                        ;First copy error into
        [ Medusa
        ADR     R2, globalerrorbuffer+4
        MOV     R3,#(?globalerrorbuffer)-5
        |
        ADR     R2,errorbuffer+4                ;  'errorbuffer', not copying
        MOV     R3,#(?errorbuffer)-5            ;  too many characters
        ]
makepersistenterror_copyerror
        LDRB    LR,[R1],#1
        STRB    LR,[R2],#1
        TEQ     LR,#0                           ;Copy until ASCII 0, or
        SUBNES  R3,R3,#1                        ;  255 real characters copied
        BNE     makeper
sistenterror_copyerror
        LDR     LR,[R0]                         ;Copy error number,
        [ Medusa
        ADR     R0, globalerrorbuffer
        |
        ADR     R0,errorbuffer                  ;  addressing new error block
        ]
        STR     LR,[R0]
        CMP     R3,#?cancelsuffix               ;Space for suffix?
        ADRHS   R1,cancelsuffix                 ;If so, use simple suffix and
        SUBHS   R2,R2,#1                        ;  backtrack over ASCII 0
        ADRLO   R1,charslostcancelsuffix        ;If not, use longer suffix
        [ Medusa
        ADRLO   R2, globalerrorbuffer + globalerrorbufferlen - 1 - ?charslostcancelsuffix
        |
        ADRLO   R2,errorbuffer + errorbufferlen - 1 - ?charslostcancelsuffix
                                                ;  and lose characters
        ]
makepersistenterror_copysuffix                  ;Copy the suffix
        LDRB    LR,[R1],#1
        STRB    LR,[R2],#1
        TEQ     LR,#0
        BNE     makepersistenterror_copysuffix
makepersistenterror_suffixdone
        MOV     R1,#1                           ;Register persistent error
        STRB    R1,persistenterror
        MOV     R1,#0                           ;Force zero termination
        [ Medusa
        STRB    R1, globalerrorbufer + globalerrorbufferlen -1
        |
        STRB    R1,errorbuffer + errorbufferlen - 1
        ]
makepersistenterror_return
        SETV
        Pull    "R1-R3,PC"

charslostcancelsuffix   DCB     "..."
cancelsuffix            DCB     " (print cancelled)"
                        DCB     0
                        ALIGN


      ]

; Subroutine to make a persistent error, not adding a suffix.
;
; Entry: R0 points to error block
;        R11 points to print job's workspace
; Exit:  R0 points to modified error block
;        V set
;        All other registers preserved

makepersistentnosuffix
        Push    "R1-R3,LR"
        LDRB    LR,persistenterror              ;Leave an already existing
        TEQ     LR,#0                           ;  persistent error alone
        BNE     makepersistentnosuffix_return   ;  (avoid recursive addition
                                                ;  of " (print cancelled)"
                                                ;  on e.g. PLOT &D0-&D7)
        ADD     R1,R0,#4                        ;First copy error into
        [ Medusa
        ADR     R2, globalerrorbuffer+4
        MOV     R3, #(?globalerrorbuffer)-5
        |
        ADR     R2,errorbuffer+4                ;  'errorbuffer', not copying
        MOV     R3,#(?errorbuffer)-5            ;  too many characters
        ]
makepersistentnosuffix_copyerror
        LDRB    LR,[R1],#1
        STRB    LR,[R2],#1
        TEQ     LR,#0                           ;Copy until ASCII 0, or
        SUBNES  R3,R3,#1                        ;  255 real characters copied
        BNE     makepersistentnosuffix_copyerror
        LDR     LR,[R0]                         ;Copy error number,
        [ Medusa
        ADR     R0, globalerrorbuffer
        |
        ADR     R0,errorbuffer                  ;  addressing new error block
        ]
        STR     LR,[R0]
        MOV     R1,#1                           ;Register persistent error
        STRB    R1,persistenterror
        MOV     R1,#0                           ;Force zero termination
        [ Medusa
        STRB    R1, globalerrorbuffer + globalerrorbufferlen -1
        |
        STRB    R1,errorbuffer + errorbufferlen - 1
        ]
makepersistentnosuffix_return
        SETV
        Pull    "R1-R3,PC"


; Subroutine to re-generate a persistent error if it exists.
; Entry: R11 points to print job's workspace

checkpersistenterror
        Push    "LR"
        LDRB    LR,persistenterror
        CMP     LR,#0                   ;Clears V
        [ Medusa
        ADRNE   R0, globalerrorbuffer
        |
        ADRNE   R0,errorbuffer
        ]
        SETV    NE
        Pull    "PC"

; Subroutine to set up to pass OS_WriteC's through and then enable ESCAPEs.
;   These effects only happen if there have been equal numbers of calls to
; 'enableescapes' and 'disableandcheckescapes' before this call. But note
; that the nesting counter is only a byte, so don't nest things badly!

enableescapes
        Push    "R0,R1,R2,R3,LR"
        LDRB	LR,escapedepth
	Debug	misc, "enableescapes", lr
        ADD     LR,LR,#1
        STRB	LR,escapedepth
        CMP     LR,#1                   ;NB clears V
        BNE     enableescapes_return
        MOV     LR,#passthrough_wrch
        STRB    LR,passthrough
        MOV     R0,#&E5
        MOV     R1,#0
        MOV     R2,#0
        SWI     XOS_Byte		;escape state := enabled
        STRVCB  R1,oldescapestate
        MOVVC   R0,#&E6
        MOVVC   R1,#0
        MOVVC   R2,#0
        SWIVC   XOS_Byte		;escape effects := enabled
        STRVCB  R1,oldescapeeffect
	;Replace the current escape handler with one that does nothing (since
	;we are arranging things so we return escapes as a synchronous error)
	MOVVC	R0, #EscapeHandler
	ADRVC	R1, escapehandler	;handler's address
	MOVVC	R2, #0			;read R12
	MOVVC	R3, #0			;read buffer
	SWIVC	XOS_ChangeEnvironment
	ADRVC	R0, oldescapehandler
	STMVCIA	R0, {R1, R2, R3}	;save old values for later
enableescapes_return
        STRVS   R0,[R13]
        Pull    "R0,R1,R2,R3,PC"

; Subroutine to set up to intercept OS_WriteC's, then disable ESCAPEs, then
; if an ESCAPE condition has occurred, acknowledge it and generate an ESCAPE
; error. If no ESCAPE condition has occurred, any error state present when
; the routine was called is preserved.
;   These effects only happen if there has been one more call to
; 'enableescapes' than to 'disableandcheckescapes' before this call. But
; note that the nesting counter is only a byte, so don't nest things badly!

disableandcheckescapes
        EntryS  "R0,R1,R2,R3,R4"
        LDRB	LR,escapedepth
        SUBS    LR,LR,#1
        STRB	LR,escapedepth
	Debug	misc, "disableandcheckescapes", lr
        EXITS   NE
        ;LR must be zero to get here    ;MOV     LR,#0
        STRB    LR,passthrough
        MOV     R0,#&E5
        LDRB    R1,oldescapestate
        MOV     R2,#0
        SWI     XOS_Byte		;escape state := oldescapestate
        MOVVC   R0,#&E6
        LDRVCB  R1,oldescapeeffect
        MOVVC   R2,#0
        SWIVC   XOS_Byte		;escape effects := oldescapeeffect
        MOVVC   R0,#&7E
        SWIVC   XOS_Byte		;acknowledge escape (calling escape handler)
        MOVVC	R4, R1			;save R1 for later
        MOVVS	R4, #0			;if things are going wrong, say there's no escape

	;Restore previous escape handler
	ADRVC	R0, oldescapehandler
	LDMVCIA	R0, {R1, R2, R3}	;get old values from before
	MOVVC	R0, #EscapeHandler
	SWIVC	XOS_ChangeEnvironment

	CMP	R4, #0			;use saved R1 which indicates escape condition
        EXITS   EQ
        ADR     R0,ErrorBlock_Escape
        BL      LookupSingle            ; Always sets V flag
        STR	R0,[R13,#Proc_RegOffset]
        EXIT

        MakeErrorBlock  Escape          ; Global error message

escapehandler
	MOV	PC, LR

        END
@


4.2
log
@Spinner branch merged
@
text
@d34 1
a34 1
               
d42 1
a42 1
        BL      LookupToken                    
d53 1
a53 1
        
d64 1
a64 1
 
d73 1
a73 1
                  
d111 1
a111 1
    
d189 1
a189 1
; Entry: R0 points to error block          
d286 1
a286 2
        Pull    "R0,R1,R2,R3,PC",VC,^
        STR     R0,[R13]
d298 1
a298 1
        Push    "R0,R1,R2,R3,R4,LR"
d303 2
a304 2
        Pull    "R0,R1,R2,R3,R4,PC",NE,^
        MOV     LR,#0
d326 1
a326 1
        Pull    "R0,R1,R2,R3,R4,PC",EQ,^
d329 2
a330 2
        STR	R0,[R13]
        Pull    "R0,R1,R2,R3,R4,PC"
@


4.2.2.1
log
@  First attempt at 32-bit compatible modules.
Admin:
  Tested that modules build 26-bit and 32-bit.
  Requires HdrSrc-1_05 or later.

Version 4.44, 4.1.2.1. Tagged as 'PDModules-4_44-4_1_2_1'
@
text
@d34 1
a34 1

d42 1
a42 1
        BL      LookupToken
d53 1
a53 1

d64 1
a64 1

d73 1
a73 1

d111 1
a111 1

d189 1
a189 1
; Entry: R0 points to error block
d286 2
a287 1
        STRVS   R0,[R13]
d299 1
a299 1
        EntryS  "R0,R1,R2,R3,R4"
d304 2
a305 2
        EXITS   NE
        ;LR must be zero to get here    ;MOV     LR,#0
d327 1
a327 1
        EXITS   EQ
d330 2
a331 2
        STR	R0,[R13,#Proc_RegOffset]
        EXIT
@


4.1
log
@Initial revision
@
text
@d257 3
a259 2
        Push    "R0,R1,R2,LR"
        LDRB    LR,escapedepth
d261 1
a261 1
        STRB    LR,escapedepth
d269 1
a269 1
        SWI     XOS_Byte
d274 1
a274 1
        SWIVC   XOS_Byte
d276 9
d286 1
a286 1
        Pull    "R0,R1,R2,PC",VC,^
d288 1
a288 1
        Pull    "R0,R1,R2,PC"
d299 2
a300 2
        Push    "R0,R1,R2,LR"
        LDRB    LR,escapedepth
d302 3
a304 2
        STRB    LR,escapedepth
        Pull    "R0,R1,R2,PC",NE,^
d310 1
a310 1
        SWI     XOS_Byte
d314 1
a314 1
        SWIVC   XOS_Byte
d316 12
a327 4
        SWIVC   XOS_Byte
        BVS     disableandcheckescapes_errorreturn
        CMP     R1,#0
        Pull    "R0,R1,R2,PC",EQ,^
d330 2
a331 3
disableandcheckescapes_errorreturn
        STRVS   R0,[R13]
        Pull    "R0,R1,R2,PC"
d334 3
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@   Enable escapes round all calls to PDumper.
   Replace the caller's escape handler with a NOP. Otherwise, we end
up calling the current escape handler when we acknowledge the escape,
which has potentially horrible consequences. In the case of the C
library, the escape handler is expecting to have to raise a signal,
and if it can't do this is generates an error instead.
@
text
@d257 2
a258 3
        Push    "R0,R1,R2,R3,LR"
        LDRB	LR,escapedepth
	Debug	misc, "enableescapes", lr
d260 1
a260 1
        STRB	LR,escapedepth
d268 1
a268 1
        SWI     XOS_Byte		;escape state := enabled
d273 1
a273 1
        SWIVC   XOS_Byte		;escape effects := enabled
a274 9
	;Replace the current escape handler with one that does nothing (since
	;we are arranging things so we return escapes as a synchronous error)
	MOVVC	R0, #EscapeHandler
	ADRVC	R1, escapehandler	;handler's address
	MOVVC	R2, #0			;read R12
	MOVVC	R3, #0			;read buffer
	SWIVC	XOS_ChangeEnvironment
	ADRVC	R0, oldescapehandler
	STMVCIA	R0, {R1, R2, R3}	;save old values for later
d276 1
a276 1
        Pull    "R0,R1,R2,R3,PC",VC,^
d278 1
a278 1
        Pull    "R0,R1,R2,R3,PC"
d289 2
a290 2
        Push    "R0,R1,R2,R3,R4,LR"
        LDRB	LR,escapedepth
d292 2
a293 3
        STRB	LR,escapedepth
	Debug	misc, "disableandcheckescapes", lr
        Pull    "R0,R1,R2,R3,R4,PC",NE,^
d299 1
a299 1
        SWI     XOS_Byte		;escape state := oldescapestate
d303 1
a303 1
        SWIVC   XOS_Byte		;escape effects := oldescapeeffect
d305 4
a308 12
        SWIVC   XOS_Byte		;acknowledge escape (calling escape handler)
        MOVVC	R4, R1			;save R1 for later
        MOVVS	R4, #0			;if things are going wrong, say there's no escape

	;Restore previous escape handler
	ADRVC	R0, oldescapehandler
	LDMVCIA	R0, {R1, R2, R3}	;get old values from before
	MOVVC	R0, #EscapeHandler
	SWIVC	XOS_ChangeEnvironment

	CMP	R4, #0			;use saved R1 which indicates escape condition
        Pull    "R0,R1,R2,R3,R4,PC",EQ,^
d311 3
a313 2
        STR	R0,[R13]
        Pull    "R0,R1,R2,R3,R4,PC"
a315 3

escapehandler
	MOV	PC, LR
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.10;
access;
symbols
	PDModules-4_64:4.10
	PDModules-4_63:4.10
	PDModules-4_62:4.10
	PDModules-4_61:4.9
	PDModules-4_60:4.9
	PDModules-4_59:4.9
	PDModules-4_58:4.8
	PDModules-4_57:4.8
	PDModules-4_56:4.8
	PDModules-4_55:4.8
	PDModules-4_54:4.8
	PDModules-4_53:4.8
	PDModules-4_52:4.7
	PDModules-4_51:4.7
	PDModules-4_50:4.6
	PDModules-4_49:4.5
	PDModules-4_48:4.5
	PDModules-4_47:4.5
	PDModules-4_46:4.4
	kbracey_32bit_merge:4.3.2.1
	PDModules-4_45:4.4
	PDModules-4_44-4_1_2_7:4.3.2.1
	PDModules-4_44-4_1_2_6:4.3.2.1
	PDModules-4_44-4_1_2_5:4.3.2.1
	PDModules-4_44-4_1_2_4:4.3.2.1
	PDModules-4_44-4_1_2_3:4.3.2.1
	PDModules-4_44-4_1_2_2:4.3.2.1
	PDModules-4_44-4_1_2_1:4.3.2.1
	kbracey_32bit:4.3.0.2
	kbracey_32bit_bp:4.3
	dellis_autobuild_BaseSW:4.3
	Ursula_merge:4.1.7.5.2.1
	PDModules-4_44:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.5.2.1
	Ursula_RiscPC:4.1.7.5.2.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.1.7.5.2.1
	UrsulaBuild_FinalSoftload:4.1.7.5.2.1
	rthornb_UrsulaBuild-12Aug1998:4.1.7.5.2.1
	aglover_UrsulaBuild-05Aug1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-29Jul1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-22Jul1998:4.1.7.5.2.1
	hsimons_BOCA-1_2-Release:4.1.7.5
	rthornb_UrsulaBuild-15Jul1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-07Jul1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-17Jun1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-03Jun1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-27May1998:4.1.7.5.2.1
	rthornb_UrsulaBuild-21May1998:4.1.7.5.2.1
	rthornb_UrsulaBuild_01May1998:4.1.7.5.2.1
	afrost_NC2_Generic:4.1.7.5
	afrost_Funai01-33:4.1.7.5
	Ursula:4.1.7.5.0.2
	Ursula_bp:4.1.7.5
	Ursula_31Mar1998:4.2
	Spinner_RCA116:4.1.7.5
	Spinner_B20_2:4.1.7.4
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.4
	Spinner_B17:4.1.7.4
	Spinner_B15:4.1.7.4
	Spinner_B14:4.1.7.4
	Spinner_B13:4.1.7.4
	Spinner_B12:4.1.7.4
	Spin_merge_28May97:4.1.7.4
	Spinner_B10:4.1.7.4
	Spin_merge_16May97:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.4
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2018.07.03.21.14.43;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	8KGlIKKeLIz2DJIA;

4.9
date	2014.10.20.21.53.02;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	kYvwc1FHitWAiZUx;

4.8
date	2007.11.05.17.15.42;	author srevill;	state Exp;
branches;
next	4.7;

4.7
date	2003.07.11.18.10.20;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2003.03.10.11.33.27;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2002.12.05.20.45.09;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2001.01.09.13.59.35;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.07.10.12.26.09;	author sbrodie;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.05.16.12.55.36;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.48.33;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2000.10.18.11.32.02;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.48.33;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.03.59;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.26.59;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.30.44;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.04.30.17.46.01;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.05.01.13.47.23;	author nturton;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.05.14.09.35.58;	author jcoxhead;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.08.19.14.13.52;	author arodger;	state Exp;
branches
	4.1.7.5.2.1;
next	;

4.1.7.5.2.1
date	98.04.07.17.01.13;	author arodger;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Update SpriteOp support, loosen/tighten some checks
Core/Header.s,Core/SWIs.s,Core/Constants.s: Define a new bad pointer rather than using &80000000 since that's now a perfectly valid logical address to have.
Core/Device.s, Core/Sprite.s, PDriverDP/Sprite.s, PDriverPS/Sprite.s: Delete support for the greyscale SpriteOp plots, these were removed from SpriteExtend in 1993. Just error them now. Extend the table of SpriteOps to include letting through TileSpriteScaled.
PDriverDP/Transprite.s: Allow 0 or -1 to mean "has no translation table" in line with PDriverPS and SpriteExtend.
PDriverPS/Sprite.s, PDriverPS/TranSprite.s: Use define instead of magic numbers.

Version 4.62. Tagged as 'PDModules-4_62'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Core.Header

;----------------------------------------------------------------------------
;
; Module header
;
;----------------------------------------------------------------------------

        AREA    |Asm$$Code|, CODE, READONLY, PIC

Module_BaseAddr
        DCD     0                                 ;Not an application
        DCD     initialise    - Module_BaseAddr   ;Initialisation
        DCD     finalise      - Module_BaseAddr   ;Finalisation
        DCD     serviceentry  - Module_BaseAddr   ;Cancel print jobs on resets
        DCD     title         - Module_BaseAddr   ;Title string
        DCD     helpstr       - Module_BaseAddr   ;Help string
        DCD     0                                 ;No help/command table
    [ :LNOT: No32bitCode
        DCD     0                                 ;No SWI chunk
        DCD     0                                 ;No SWI handler
        DCD     0                                 ;No SWI names
        DCD     0                                 ;No special SWI decoding
        DCD     0                                 ;No international messages
        DCD     moduleflags   - Module_BaseAddr   ;Module flags
    ]

title   DCB     "PDriver$ModSuffix"
        DCB     0
helpstr DCB     "Printer driver",9,"$Module_HelpVersion"
        [       BeingDeveloped
        DCB     " Development version"
        ]
        DCB     " for $PrinterType printers"
        [        UCSText
        DCB        " (UCS)"
        ]
        DCB     0
        ALIGN

    [ :LNOT: No32bitCode
moduleflags DCD ModuleFlag_32bit
    ]

;----------------------------------------------------------------------------
;
; Define macros
;
;----------------------------------------------------------------------------

; Macros for normal and error returns when return link is in LR

        MACRO
$label  Return  $cond
$label  MOV$cond PC,LR
        MEND

; ***PRINTER SPECIFIC INFORMATION***
;   Each type of printer may need its own macro definitions. These should be
; given in the following file.
;   This file should only contain constant declarations and comments.

                GET     s.PDriver$DirSuffix..Macros

;----------------------------------------------------------------------------
;
; SWI handler and table
;
;----------------------------------------------------------------------------

mySWIhandler
        LDR     R12,[R12]       ;Point R12 at workspace
        CMP     R11,#(SWI_branch_table_end - SWI_branch_table) :SHR: 2 ; (clears V!)
mySWIcase
        ADDLO   PC,PC,R11,LSL #2
        B       swioutofrange   ;Error for out of range SWI
        ASSERT  . - mySWIcase = 8
SWI_branch_table
        B       info                    ;PDriver_Info
        B       setinfo                 ;PDriver_SetInfo
        B       checkfeatures           ;PDriver_CheckFeatures
        B       pagesize                ;PDriver_PageSize
        B       setpagesize             ;PDriver_SetPageSize
        B       selectjob               ;PDriver_SelectJob
        B       currentjob              ;PDriver_CurrentJob
        B       fontswi                 ;PDriver_FontSWI
        B       endjob                  ;PDriver_EndJob
        B       abortjob                ;PDriver_AbortJob
        B       reset                   ;PDriver_Reset
        B       giverectangle           ;PDriver_GiveRectangle
        B       drawpage                ;PDriver_DrawPage
        B       getrectangle            ;PDriver_GetRectangle
        B       canceljob               ;PDriver_CancelJob
        B       screendump_dump         ;PDriver_ScreenDump
        B       enumeratejobs           ;PDriver_EnumerateJobs
        B       configure_setprinter    ;PDriver_SetPrinter
        B       canceljobwitherror      ;PDriver_CancelJobWithError
        B       selectillustration      ;PDriver_SelectIllustration
        B       picture_insert          ;PDriver_InsertIllustration
        B       declarefont             ;PDriver_DeclareFont
        B       swioutofrange           ;PDriver_DeclareDriver - ERROR!
        B       swioutofrange           ;PDriver_RemoveDriver - ERROR!
        B       swioutofrange           ;PDriver_SelectDriver - ERROR!
        B       swioutofrange           ;PDriver_EnumerateDrivers - ERROR!
        B       miscop                  ;PDriver_MiscOp
        B       miscop                  ;PDriver_MiscOpForDriver
        B       configure_setdriver     ;PDriver_SetDriver
        B       jpegswi                 ;PDriver_JPEGSWI
SWI_branch_table_end

swioutofrange
        Push    "R1,LR"
        ADR     R0, ErrorBlock_ModuleBadSWI
        addr    R1, title               ; Module title (PDriverDP, PDriverPS)
;        BL      LookupSingle            ; Always sets V
        Pull    "R1,PC"

        MakeErrorBlock  ModuleBadSWI    ; Global error message

        ALIGN

;----------------------------------------------------------------------------
;
; Initialisation and finalisation
;
;----------------------------------------------------------------------------

initialise
        Push    "LR"
        LDR     R2,[R12]        ;On RMTidy, just claim SpriteV
        CMP     R2,#0           ;NB clears V
        BNE     claimvector

; we will be dormant in ROM, as long as PDriver is after us in chain
        SWI     XPDriver_CurrentJob     ;cheap check that PDriver module is present
        BVC     init_pdriver_active

        Debug	PageBox, "initialised PDriver$DirSuffix"

; PDriver not present
        ADR     r0, no_PDriver_error
        MOV     r1, #0 ; use global messages
        MOV     r2, #0 ; use internal buffer
        ADR     r4, title
        ADR     r5, pdr_title
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        Pull    "PC"

no_PDriver_error
        DCD     ErrorNumber_NeedMod
        DCB     "NeedMod",0
        ALIGN
pdr_title
        DCB     "PDriver",0
        ALIGN

init_pdriver_active
; Claim workspace
        MOV     R0,#ModHandReason_Claim
        LDR     R3,=wslength
        SWI     XOS_Module
        Pull    "PC",VS
        STR     R2,[R12]

        ASSERT  (wslength :AND: 3)=0
        MOV     R0, #0
99      SUBS    R3, R3, #4
        STR     R0, [R2, R3]
        BNE     %BT99

; we have no messages yet.
;        MOV     r0, #0
;        STR     r0, [r2, #:INDEX:SharedMessages]
;        STR     r0, [r2, #:INDEX:MessagesOpen]

; Declare to PDriver module
        MOV     R3, R2
        ADDR    R0, mySWIhandler
        MOV     R1, R12
        MOV     R2, #$PrinterNumber
        SWI     XPDriver_DeclareDriver
        MOV     R12,R3

; Initialise global variables
        MOV     R0,#0
        MOV     R1,#BadPtr      ;A suitable address exception generator!
        MOV     R2,#0
        ASSERT  :BASE:currenthandle = R12
        ASSERT  :INDEX:currenthandle = 0
        ASSERT  currentws = currenthandle + 4
        ASSERT  printjoblist = currentws + 4
        STMIA   R12,{R0,R1,R2}

; No printer name defined yet
        STR     R0,info_globalprintername
        STR     R0,info_globalnamelength

; No list of global printers
        STR     R0,fontlist

; No JPEG plot in progress
        STR     R0,jpeg_ctransflag

; zero memory requirement (for SpriteExtend) counted for JPEG's
        STR     R0,jpeg_maxmemory

; clear counting pass-flag and next rectangle
        STR     R0,counting_pass
        STR     R0,counting_nextrect

; No temporary block of RMA is currently claimed
        STR     R0,temprmablock

; We haven't played around with ESCAPEs yet
        STRB	R0,escapedepth
	Debug	misc, "escapedepth", r0

; Initialise interception information
        BL      initintercept

        [       UsePDriverPath

        BL      configure_init

        |

; Set up default value (if necessary) for the variable PDriver$Dir

        ADR     R0,configdir_name
        MOV     R2,#-1
        MOV     R3,#0
        SWI     XOS_ReadVarVal
        CMP     R2,#0           ;Clears V, sets EQ if non-existent variable
        ADREQ   R0,configdir_name
        ADREQ   R1,configdir_val
        MOVEQ   R2,#?configdir_val
        MOVEQ   R3,#0
        MOVEQ   R4,#VarType_String
        SWIEQ   XOS_SetVarVal

        BLVC    configure_init

        ]

; Intercept SpriteV so that we can maintain information about where output
; is redirected. Note that this is completely independent of the interception
; done during a print job.

        MOVVC   R2,R12
claimvector
        MOVVC   R0,#SpriteV
        ADRVC   R1,monitoroutput
        SWIVC   XOS_Claim

; Initialisation has now been done
        Pull    "PC"

        LTORG

        [       :LNOT:UsePDriverPath
configdir_name  DCB     "PDriver$Dir",0
configdir_val   DCB     "%.PDriverDir",0
                ALIGN
        ]

finalise

; This tries to finalise the module. All finalisations (including non-fatal
; ones) abort all current print jobs and release the SpriteV vector.
;   Development versions complain if an error occurs, others keep quiet!

        Push    "LR"

        LDR     R12,[R12]                       ; -> workspace

        LDR     R0, printjoblist
        TEQ     R0, #0                          ; are there any pending jobs on this device?
        BEQ     %10

        ADR     R0, ErrorBlock_PrintInUse
        BL      LookupSingle                    ; attempt to build error block
        B       %80                             ; and report it if needed
10
        MOV     R0, #$PrinterNumber
        SWI     XPDriver_RemoveDriver           ; remove outself from the pdriver module

        BL      configure_finalise              ; tidy up dependent source
        BL      CloseMessages                   ; attempt to close any open messages files

        LDR     R2,info_globalprintername
        TEQ     R2,#0                           ; any name block allocated?
        MOVNE   r0,#0
        STRNE   r0,info_globalprintername       ; mark as removed then
        MOVNE   r0,#ModHandReason_Free
        SWINE   XOS_Module                      ; attempt to release it then

        ADR     R2,fontlist                     ; pointer to he font list
        BL      miscop_removefontsR2

        MOV     R0,#SpriteV                     ; release SpriteV
        ADR     R1,monitoroutput
        MOV     R2,R12
        SWI     XOS_Release
80
        [       DevelopmentChecks
        BVC     %f99                            ; display any messages generated
        SWI     OS_WriteS
        DCB     "Disaster during PDriver finalisation - error is:",13,10,0
        ALIGN
        ADD     R0,R0,#4
        SWI     OS_Write0
        SWI     OS_NewLine
99
        ]
        
        Pull    "PC"                            ; may still be alive!

        MakeInternatErrorBlock PrintInUse,,PDrUsed

;----------------------------------------------------------------------------
;
; SpriteV interception routine to deal with redirection of output to sprites,
; etc. Unlike the other interception routines, this is around all the time,
; not just when a print job is active.
;
;---------------------------------------------------------------------------

monitoroutput
        Push    "LR"
        ;We are only interested in spriteops 60 and 61, regardless of bits 8, 9.
        ASSERT  SpriteReason_BadReasonCode < 125 
        AND     LR,R0,#&3E              ; this cheap test next aliases at 124
        TEQ     LR,#&3C
        Pull    "PC",NE                 ; Pass through if not interesting.

	[	debug
	CMP	r2, #0
	DebugIf EQ, PageBox, "monitoroutput: to screen"
	DebugIf	NE, PageBox, "monitoroutput: to sprite", r2
	]

	LDRB	lr, wimpreportflag	;Also, don't interfere if there's an error
	TEQ	lr, #0			;  box open. JRC Tue 22nd April 1997
	Pull	"pc", NE

        Pull    "LR"

        Push    "R0-R7"

;; The following stuff was removed by NRaine on 4-May-89
;; It is not necessary to trap this case, since applications are
;; supposed to redirect output back to the original bitmap anyway,
;; rather than assuming that output is to be returned to the screen.

;; Re-instated by DJS on 15-May-89. It doesn't seem to harm the
;; functionality of the module, though there are indications that
;; something went wrong during debugging of the module at some point.

        Push    "R10,R11"
        LDMIA   R12,{R10,R11}           ;R10:=currenthandle, R11:=currentws

        TEQ     R10,#0                  ;Don't deal with screen specially if
        BEQ     monitoroutput_nojob     ;  there's no current job

        TEQ     R2,#0                   ;If job exists & switching output to
        ADREQ   R10,jobspriteparams     ;  screen, really switch it to the
        LDMEQIA R10,{R0-R3}             ;  job's sprite
        DebugIf EQ, PageBox, "intercepting redirection to screen"
monitoroutput_nojob
        Pull    "R10,R11"
        TEQ     PC,PC
        ADRNE   R7,monitoroutput_cont+SVC_mode
        ADREQ   R7,monitoroutput_cont
        Push    "R7,R12"                ;Continuation address + wp
        MOV     PC,LR                   ;Pass on
monitoroutput_cont
        Pull    "R12"
        Pull    "R4-R7"                 ;Original values of R0-R3
        Pull    "R4-R7,PC",VS           ;Simply claim call if error occurred
        ADR     LR,spriteparams         ;Otherwise store original values in
        STMIA   LR,{R4-R7}              ;  'spriteparams'
        BL      adjustintercept
        Pull    "R4-R7,PC"              ;Return, claiming call

;----------------------------------------------------------------------------
;
; The service entry
; AR 27/march 98 changed to ursula code
;----------------------------------------------------------------------------
	ASSERT	  Service_Reset			< Service_ModeChange
	ASSERT	  Service_ModeChange 		< Service_WimpReportError
	ASSERT    Service_WimpReportError	< Service_PDriverStarting
	ASSERT    Service_PDriverStarting  	< Service_SwitchingOutputToSprite
	ASSERT    Service_SwitchingOutputToSprite < Service_PDriverGetMessages
	ASSERT	  Service_Print			< Service_WimpCloseDown
	ASSERT	  Service_WimpCloseDown		< Service_PDriverGetMessages

serviceentry_ServTab
	DCD	0
	DCD	serviceOentry - Module_BaseAddr ; offset to handler (skip rapid rejection)
	[ debug
	DCD	Service_Reset               ; Service reset?
	DCD	Service_Print
	]
	DCD	Service_ModeChange          ;Reset 'spriteparams' on a
	[ debug
	DCD	Service_WimpCloseDown
	]
	DCD	Service_WimpReportError     ;Must suspend interception on
	DCD	Service_PDriverStarting     ;Declare ourselves
	[ debug
	DCD	Service_SwitchingOutputToSprite
	]
	DCD	Service_PDriverGetMessages  ; find messages doofers!
 	DCD	0
        DCD     serviceentry_ServTab - Module_BaseAddr  ;anchor for table

serviceentry
	MOV	R0, R0
        TEQ     R1,#Service_ModeChange          ;Reset 'spriteparams' on a
        TEQNE   R1,#Service_WimpReportError     ;Must suspend interception on
        TEQNE   R1,#Service_PDriverStarting     ;Declare ourselves
        TEQNE   R1,#Service_PDriverGetMessages  ; find messages doofers!
        [ debug
        TEQNE   R1,#Service_Reset               ; Service reset?
	TEQNE	R1,#Service_Print
	TEQNE	R1,#Service_WimpCloseDown
	TEQNE	R1,#Service_SwitchingOutputToSprite
        ]
	MOVNE	pc, lr

serviceOentry
	[	debug
	TEQ	r1, #&68			;Don't attempt to trace Service_FileClosed
	DebugIf	NE, svc, "+service", r1
	]

        TEQ     R1,#Service_PDriverStarting     ;Declare ourselves
        BEQ     serviceentry_declare

        LDR     R12,[R12]
        TEQ     R1,#Service_WimpReportError     ;Must suspend interception on
        BEQ     serviceentry_reporterror        ;  this

        TEQ     R1,#Service_ModeChange          ;Reset 'spriteparams' on a
        BEQ     serviceentry_modechange         ;  mode change

        TEQ     R1,#Service_PDriverGetMessages  ; find messages doofers!
        BEQ     ServiceMessages

	[ debug	; these service calls only deal with debug
	TEQ	R1,#Service_SwitchingOutputToSprite
	BEQ	serviceentry_switchingoutputtosprite

	TEQ	R1,#Service_Print
	BEQ	serviceentry_print

	TEQ	R1,#Service_WimpCloseDown
	BEQ	serviceentry_wimpclosedown

        TEQ     R1,#Service_Reset               ; Service reset?
	BEQ	serviceentry_reset
	]

	[	debug
	TEQ	r1, #&68			;Don't attempt to trace Service_FileClosed
	DebugIf	NE, svc, "-service", r1
	]
	MOV 	pc,lr

serviceentry_reset
        Push    "R0,R1,R2,R3,R4,R11,LR"
        BL      initintercept           ;Reset will have stopped us
                                        ;  intercepting the vectors
        MOV     R0,#SpriteV             ;Reclaim the sprite vector
        ADR     R1,monitoroutput
        MOV     R2,R12                  ;Note that 'spriteparams' will be
        SWI     XOS_Claim               ;  re-initialised by the mode change
        ADR     R11,printjoblist - (:INDEX:joblink)
        ASSERT  :BASE:joblink = R11
serviceentry_fontslost_loop             ;Tell printer specific code the font
        LDR     R11,joblink             ;  manager has lost all fonts.
        CMP     R11,#0
        BEQ     serviceentry_fontslost_loopend
        BL      font_fontslost
        B       serviceentry_fontslost_loop
serviceentry_fontslost_loopend
        BL      releasetemprmablock     ;Get rid of any temporary RMA block
        BL      reset                   ;Abort all print jobs
	Debug	svc, "-service"
        Pull    "R0,R1,R2,R3,R4,R11,PC"

serviceentry_declare
        Push    "R0-R2,LR"

        ADDR    R0, mySWIhandler        ;Declare ourself to the printer drivers
        MOV     R1, R12
        MOV     R2, #$PrinterNumber
        SWI     XPDriver_DeclareDriver
	Debug	svc, "-service"
        Pull    "R0-R2,pc"

serviceentry_modechange
        Push    "R0-R4,LR"
        ADR     R0,spriteparams
        BL      setscreenparams
        BL      adjustintercept
	Debug	svc, "-service"
        Pull    "R0-R4,PC"

serviceentry_reporterror
        Push    "R10,R11,LR"
        STRB    R0,wimpreportflag
	[	debug
	TEQ	r0, #0
	DebugIf	NE, svc, "Service_WimpReportError---error box open"
	DebugIf	EQ, svc, "Service_WimpReportError---error box closed"
	]
        ASSERT  :BASE:currenthandle = R12
        ASSERT  :INDEX:currenthandle = 0
        ASSERT  currentws = currenthandle + 4
        LDMIA   R12,{R10,R11}           ;R10:=currenthandle, R11:=currentws
        TEQ     R10,#0
        BEQ     serviceentry_reporterror_return
        TEQ     R0,#0
        BNE     serviceentry_reporterror_suspend
        BL      managejob_resume
        B       serviceentry_reporterror_return
serviceentry_reporterror_suspend
        BL      managejob_suspend
serviceentry_reporterror_return
        BL      adjustintercept
	Debug	svc, "-service"
        Pull    "R10,R11,PC"

	[	debug
serviceentry_switchingoutputtosprite
	TEQ	r4, #0
	DebugIf	NE, svc, "Service_SwitchingOutputToSprite---to sprite"
	DebugIf	EQ, svc, "Service_SwitchingOutputToSprite---to screen"
	Debug	svc, "-service"
	MOV	pc, lr

serviceentry_print
	TEQ	r2, #0
	DebugIf NE, svc, "Service_Print---on"
	DebugIf EQ, svc, "Service_Print---off"
	Debug	svc, "-service"
	MOV	pc, lr

serviceentry_wimpclosedown
	Debug	svc, "Service_WimpCloseDown", r0, r2
	Debug	svc, "-service"
	MOV	pc, lr
        ]

; Subroutine to release any temporary RMA block that may exist.

releasetemprmablock
        Push    "R0,R2,LR"
        LDR     R2,temprmablock
        CMP     R2,#0                           ;NB clears V
        MOVNE   R0,#ModHandReason_Free
        SWINE   XOS_Module
        MOVVC   R2,#0
        STRVC   R2,temprmablock
        STRVS   R0,[R13]
        Pull    "R0,R2,PC"

; Subroutine to put the default "output directed to screen" parameters in
; the four word area pointed to by R0. Corrupts R1-R4.

setscreenparams
        LDR     R1,=&200+SpriteReason_SwitchOutputToSprite
        SUBS    R2,R2,R2 ; R2 = 0, clears V
        MOV     R3,#0
        MOV     R4,#1
        STMIA   R0,{R1-R4}
        MOV     pc, lr

        LTORG

        END
@


4.9
log
@Some PDModule tidy ups
Core/FontSWI.s & PDriverDP/Font.s:
 The pointer compares are now unsigned, so raise the limit for printing strings in top bit set addresses when no length is passed in R7.
 Couple of comment typos.
Core/Header.s:
 A CVS merge mistake left behind two copies of Push/return sequence.
Core/PDriver.s:
 Unused VersionString removed.
PDriverDP/Macros.s & PDriverDP/ManageJob.s:
 Single use unhelpful debug message removed.
PDriverDP/Private2.s & Sprite.s & TranSprite.s:
 Use some of the defines from Hdr:Sprite.
Makefile:
 For ROMming, explicitly state there's no resources phase
PDriverDP/PageBox.s:
 Unjumble the set_sprite_output_state data. The MonoBufferOK and Libra1 switch happen to work when both are {TRUE} but other combinations would output a silly table. Let ObjAsm work out the size instead.

Tested briefly, still printed OK.

Version 4.59. Tagged as 'PDModules-4_59'
@
text
@d202 1
a202 1
        MOV     R1,#TopBit      ;A suitable address exception generator!
@


4.8
log
@Fixed printing of UTF-8, UTF-16 and UCS-4 encoded text strings for bitmap
  printers (PDriverDP).
Detail:
  The device-independent part of the PDriver code processes command
  sequences in text strings. Additionally, it modifies the flags passed
  to Font_Paint by the client application. This resulted in the character
  width bits (12 and 13) of the Font_Paint flags being stripped and
  command sequences being mis-recognised when UTF-16 or UCS-4 text
  strings were printed.
 
  The PDriverDP device-specific part of the PDriver code prepends an
  underline command sequence (25,position,thickness) to the printed
  string. This resulted in 8bit data being prepended to a potentially
  16bit or 32bit string.
 
  The device-independent part has been fixed to preserve the character
  width bits in the Font_Paint flags. It has also gained the ability to
  process UTF-8, UTF-16 and UCS-4 characters correctly.
 
  The PDriverDP device-specific part has been fixed to insert commands of
  the correct bit-width for the text encoding being used.
Admin:
  PDriverDP tested on Iyonix RO 5.11 with NetSurf for UTF-16 text printing
  and Draw for UTF-8 printing (drawfile exported from NetSurf) and non-UCS
  printing to ensure no regressions occurred.
  PDriverPS tested on Iyonix RO 5.11 with NetSurf and Draw to ensure no
  regression in behaviour. Note that printing of UCS text with PDriverPS
  is not fixed by these changes.
Notes:
  Changes by John-Mark Bell

Version 4.53. Tagged as 'PDModules-4_53'
@
text
@a381 1
	DebugIf	EQ, PageBox, "intercepting redirection to screen"
d384 1
d390 2
a391 4
        Push    "R7,R12"
        MOV     PC,LR
        Push    "R7,R12"
        MOV     PC,LR
@


4.7
log
@Unoptimised a RMA clearing loop: went mad if the workspace was not a
multiple of 3.
Changed PDumper Upcall stuff to pass R0-R12 on the stack - curiously this
fixes the RMA corruption and instability of !Printers (as does switching
the UpCalls off.

Version 4.51. Tagged as 'PDModules-4_51'
@
text
@d49 3
@


4.6
log
@Fix for the thingy which sits on SpriteV,it got optimised sometime round
2000 which led to it getting the "redirected to sprite" switch in a
muddle so printing from some apps ended up on the screen not in the
postscript file.
Changed the "%%Creator" string a bit.
Took the opportunity to eliminate all the signed pointer comparisons.
Tightened up the checking of pointers to palettes and translation tables
so that "0 or -1" means to use the default,not <= 0.

Version 4.50. Tagged as 'PDModules-4_50'
@
text
@d178 1
d180 1
a180 1
99      SUBS    R3, R3, #3
d182 1
a182 1
        BHI     %BT99
a268 1

d328 1
a328 1

@


4.5
log
@Changed to use objasm to avoid any LDR rN,[rN],#0 problems
Changed to use shared Makefiles
Numerous small 32 bit conversion improvements
Bugfix to PDriverPS,it was pulling LR not PC - this has been the case for
many years so not sure how it ever worked.
Due to a bug in objasm 3.27 this checkin will infact not build directly.
You must first
 - rename the PDriverDP dir to PDriverDP2
 - rename the PDriverPS dir to PDriverPS2
 - move the 2 source files of the same name up a directory
checked in in this way to minimise messing in CVS.

Version 4.47. Tagged as 'PDModules-4_47'
@
text
@d344 2
a345 2
        BIC     LR,R0,#&300
;        AND     LR,R0,#&3E
d347 1
a347 1
        Pull    "PC",NE                 ;Pass through if not interesting.
@


4.4
log
@  Merge of 32-bit branch.
Detail:
  These modules are now thought to work.
Admin:
  This module has received some testing of both 26-bit and 32-bit
    builds and is believed to function correctly.

Version 4.45. Tagged as 'PDModules-4_45'
@
text
@d23 1
a23 1
        LEADR   Module_LoadAddr
d42 1
a42 1
title   DCB     "PDriver$DirSuffix"
d178 5
d184 3
a186 3
        MOV     r0, #0
        STR     r0, [r2, #:INDEX:SharedMessages]
        STR     r0, [r2, #:INDEX:MessagesOpen]
d343 3
a345 2
        ;We are interested in spriteops 60, 61, regardless of bits 8, 9.
        AND     LR,R0,#&3E
d384 7
a390 4

        ADR     R7,monitoroutput_cont+SVC_mode  ;Call routine, returning to
        Push    "R7,R12"                        ;  monitoroutput_cont
        MOV     PC,LR                           ;  afterwards
d418 1
d421 3
a427 1
	DCD	Service_Print
a429 3
	[ debug
	DCD	Service_WimpCloseDown
	]
d435 1
a435 1
        TEQ     R1,#Service_PDriverStarting     ;Declare ourselves
d437 1
a437 1
        TEQNE   R1,#Service_ModeChange          ;Reset 'spriteparams' on a
d440 1
a440 1
	TEQNE	R1,#Service_SwitchingOutputToSprite
d443 1
a443 1
        TEQNE   R1,#Service_Reset               ; Service reset?
@


4.3
log
@  Merged Ursula branch.
  Moved to srccommit.
Detail:
  Added fast service call table.
Admin:
  Tested briefly.

Version 4.44. Tagged as 'PDModules-4_44'
@
text
@d44 1
a44 1
helpstr DCB     "Printer driver",9,"$Module_MajorVersion ($Module_Date)"
d53 1
a53 1
moduleflags DCD 0 ; module is not yet 32-bit compatible (ModuleFlag_32bit)
d66 1
a66 6
$label  BIC$cond.S PC,LR,#V_bit
        MEND

        MACRO
$label  ErrorReturn $cond
$label  ORR$cond.S PC,LR,#V_bit
d84 1
a84 1
        CMP     R11,#(SWI_branch_table_end - SWI_branch_table) :SHR: 2
d148 1
a148 1
        
d150 1
a150 1
        
d177 1
a177 1
   
d204 1
a204 1
        
d206 1
a206 1
        STR     R0,fontlist             
d342 1
a342 1
        
d396 1
a396 1
	ASSERT	  Service_Reset			< Service_ModeChange 
d398 1
a398 1
	ASSERT    Service_WimpReportError	< Service_PDriverStarting    
d402 2
a403 2
	ASSERT	  Service_WimpCloseDown		< Service_PDriverGetMessages 
		
d430 1
a430 1
        [ debug	
d455 1
a455 1
        BEQ     ServiceMessages              
d549 1
a549 1
        
d556 1
a556 1
        
d581 1
a581 1
        MOV     R2,#0
d585 1
a585 1
        Return
@


4.3.2.1
log
@  First attempt at 32-bit compatible modules.
Admin:
  Tested that modules build 26-bit and 32-bit.
  Requires HdrSrc-1_05 or later.

Version 4.44, 4.1.2.1. Tagged as 'PDModules-4_44-4_1_2_1'
@
text
@d44 1
a44 1
helpstr DCB     "Printer driver",9,"$Module_HelpVersion"
d53 1
a53 1
moduleflags DCD ModuleFlag_32bit
d66 6
a71 1
$label  MOV$cond PC,LR
d89 1
a89 1
        CMP     R11,#(SWI_branch_table_end - SWI_branch_table) :SHR: 2 ; (clears V!)
d153 1
a153 1

d155 1
a155 1

d182 1
a182 1

d209 1
a209 1

d211 1
a211 1
        STR     R0,fontlist
d347 1
a347 1

d401 1
a401 1
	ASSERT	  Service_Reset			< Service_ModeChange
d403 1
a403 1
	ASSERT    Service_WimpReportError	< Service_PDriverStarting
d407 2
a408 2
	ASSERT	  Service_WimpCloseDown		< Service_PDriverGetMessages

d435 1
a435 1
        [ debug
d460 1
a460 1
        BEQ     ServiceMessages
d554 1
a554 1

d561 1
a561 1

d586 1
a586 1
        SUBS    R2,R2,R2 ; R2 = 0, clears V
d590 1
a590 1
        MOV     pc, lr
@


4.2
log
@Spinner branch merged
@
text
@d33 1
d38 3
d44 1
a44 1
helpstr DCB     "Printer driver",9,"$VersionString ($CurrentDate)"
d52 4
d399 1
a399 1
;
d401 27
d430 14
d462 1
a462 1
	[	debug
a470 1
        ]
d474 1
d480 1
a480 1
	MOVS	pc,lr
@


4.1
log
@Initial revision
@
text
@d145 3
d219 2
a220 1
        STRB    R0,escapedepth
d335 1
a337 2
        ASSERT  SpriteReason_SwitchOutputToSprite = &3C
        ASSERT  SpriteReason_SwitchOutputToMask = &3D
d339 11
a362 1
      [ {TRUE}
a363 3
        ASSERT  :BASE:currenthandle = R12
        ASSERT  :INDEX:currenthandle = 0
        ASSERT  currentws = currenthandle + 4
d365 1
d368 1
d370 1
a374 1
      ]
d395 5
d413 11
d425 7
a431 1
        MOVNES  pc,lr
d433 1
d452 1
d462 1
a462 1

d470 1
d476 5
d495 1
d497 21
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@   Use buffer in workspace for MessageTrans.
   Added 'Colour' debugging flag.
   Do not pass SpriteV calls to pdriver if a Wimp error box is open.
@
text
@a144 3
        
        Debug	PageBox, "initialised PDriver$DirSuffix"
        
a147 4
	[	true
	ADRL	r2, error_buffer
	MOV	r3, #?error_buffer
	|
a148 1
	]
a330 1
        ;We are interested in spriteops 60, 61, regardless of bits 8, 9.
d333 2
a335 11
        
	[	debug
	CMP	r2, #0
	DebugIf EQ, PageBox, "monitoroutput: to screen"
	DebugIf	NE, PageBox, "monitoroutput: to sprite", r2
	]

	LDRB	lr, wimpreportflag	;Also, don't interfere if there's an error
	TEQ	lr, #0			;  box open. JRC Tue 22nd April 1997
	Pull	"pc", NE

d349 1
d351 3
a354 1

a356 1

a357 1
	DebugIf	EQ, PageBox, "intercepting redirection to screen"
d362 1
a382 5
	[	debug
	TEQ	r1, #&68
	DebugIf	NE, PageBox, "service", r1
	]

a395 8
	[	debug
	TEQ	R1,#Service_SwitchingOutputToSprite
	BEQ	serviceentry_switchingoutputtosprite

	TEQ	R1,#Service_Print
	BEQ	serviceentry_print
        ]

a438 5
	[	debug
	TEQ	r0, #0
	DebugIf	NE, PageBox, "Service_WimpReportError---error box open"
	DebugIf	EQ, PageBox, "Service_WimpReportError---error box closed"
	]
a453 14

	[	debug
serviceentry_switchingoutputtosprite
	TEQ	r4, #0
	DebugIf	NE, PageBox, "Service_SwitchingOutputToSprite---to sprite"
	DebugIf	EQ, PageBox, "Service_SwitchingOutputToSprite---to screen"
	MOV	pc, lr
        
serviceentry_print
	TEQ	r2, #0
	DebugIf NE, PageBox, "Service_Print---on"
	DebugIf EQ, PageBox, "Service_Print---off"
	MOV	pc, lr
        ]
@


4.1.7.3
log
@Fixed corruption on module init
@
text
@d151 4
d156 1
@


4.1.7.4
log
@   Enable escapes round all calls to PDumper.
   Replace the caller's escape handler with a NOP. Otherwise, we end
up calling the current escape handler when we acknowledge the escape,
which has potentially horrible consequences. In the case of the C
library, the escape handler is expecting to have to raise a signal,
and if it can't do this is generates an error instead.
@
text
@d219 1
a219 2
        STRB	R0,escapedepth
	Debug	misc, "escapedepth", r0
d395 2
a396 2
	TEQ	r1, #&68			;Don't attempt to trace Service_FileClosed
	DebugIf	NE, svc, "+service", r1
a417 3

	TEQ	R1,#Service_WimpCloseDown
	BEQ	serviceentry_wimpclosedown
d421 1
a421 7
	BEQ	serviceentry_reset

	[	debug
	TEQ	r1, #&68			;Don't attempt to trace Service_FileClosed
	DebugIf	NE, svc, "-service", r1
	]
	MOVS	pc,lr
a422 1
serviceentry_reset
a440 1
	Debug	svc, "-service"
d450 1
a450 1
	Debug	svc, "-service"
a457 1
	Debug	svc, "-service"
d465 2
a466 2
	DebugIf	NE, svc, "Service_WimpReportError---error box open"
	DebugIf	EQ, svc, "Service_WimpReportError---error box closed"
a481 1
	Debug	svc, "-service"
d487 2
a488 3
	DebugIf	NE, svc, "Service_SwitchingOutputToSprite---to sprite"
	DebugIf	EQ, svc, "Service_SwitchingOutputToSprite---to screen"
	Debug	svc, "-service"
d493 2
a494 8
	DebugIf NE, svc, "Service_Print---on"
	DebugIf EQ, svc, "Service_Print---off"
	Debug	svc, "-service"
	MOV	pc, lr
        
serviceentry_wimpclosedown
	Debug	svc, "Service_WimpCloseDown", r0, r2
	Debug	svc, "-service"
@


4.1.7.5
log
@Added call PDriver_Command not supported in ps and passed to the dumper in DP
@
text
@a116 1
        B	command			;PDriver_Command
@


4.1.7.5.2.1
log
@changed the service call handler as per new spec.
@
text
@d392 1
a392 1
; AR 27/march 98 changed to ursula code
a393 27
	ASSERT	  Service_Reset			< Service_ModeChange 
	ASSERT	  Service_ModeChange 		< Service_WimpReportError
	ASSERT    Service_WimpReportError	< Service_PDriverStarting    
	ASSERT    Service_PDriverStarting  	< Service_SwitchingOutputToSprite
	ASSERT    Service_SwitchingOutputToSprite < Service_PDriverGetMessages
	ASSERT	  Service_Print			< Service_WimpCloseDown
	ASSERT	  Service_WimpCloseDown		< Service_PDriverGetMessages 
		
serviceentry_ServTab
	DCD	0
	DCD	serviceOentry - Module_BaseAddr ; offset to handler (skip rapid rejection)
	[ debug
	DCD	Service_Reset               ; Service reset?
	]
	DCD	Service_ModeChange          ;Reset 'spriteparams' on a
	DCD	Service_WimpReportError     ;Must suspend interception on
	DCD	Service_PDriverStarting     ;Declare ourselves
	[ debug
	DCD	Service_SwitchingOutputToSprite
	DCD	Service_Print
	]
	DCD	Service_PDriverGetMessages  ; find messages doofers!
	[ debug
	DCD	Service_WimpCloseDown
	]
 	DCD	0
        DCD     serviceentry_ServTab - Module_BaseAddr  ;anchor for table
a395 14
	MOV	R0, R0
        TEQ     R1,#Service_PDriverStarting     ;Declare ourselves
        TEQNE   R1,#Service_WimpReportError     ;Must suspend interception on
        TEQNE   R1,#Service_ModeChange          ;Reset 'spriteparams' on a
        TEQNE   R1,#Service_PDriverGetMessages  ; find messages doofers!
        [ debug	
	TEQNE	R1,#Service_SwitchingOutputToSprite
	TEQNE	R1,#Service_Print
	TEQNE	R1,#Service_WimpCloseDown
        TEQNE   R1,#Service_Reset               ; Service reset?
        ]
	MOVNE	pc, lr

serviceOentry
d414 1
a414 1
	[ debug	; these service calls only deal with debug
d423 1
a426 1
	]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

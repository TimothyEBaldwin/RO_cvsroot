head	4.8;
access;
symbols
	PDModules-4_64:4.8
	PDModules-4_63:4.8
	PDModules-4_62:4.8
	PDModules-4_61:4.8
	PDModules-4_60:4.8
	PDModules-4_59:4.8
	PDModules-4_58:4.8
	PDModules-4_57:4.7
	PDModules-4_56:4.7
	PDModules-4_55:4.7
	PDModules-4_54:4.7
	PDModules-4_53:4.7
	PDModules-4_52:4.7
	PDModules-4_51:4.7
	PDModules-4_50:4.6
	PDModules-4_49:4.6
	PDModules-4_48:4.5
	PDModules-4_47:4.5
	PDModules-4_46:4.4
	kbracey_32bit_merge:4.2.2.2
	PDModules-4_45:4.3
	PDModules-4_44-4_1_2_7:4.2.2.2
	PDModules-4_44-4_1_2_6:4.2.2.2
	PDModules-4_44-4_1_2_5:4.2.2.2
	PDModules-4_44-4_1_2_4:4.2.2.2
	PDModules-4_44-4_1_2_3:4.2.2.2
	PDModules-4_44-4_1_2_2:4.2.2.2
	PDModules-4_44-4_1_2_1:4.2.2.1
	kbracey_32bit:4.2.0.2
	kbracey_32bit_bp:4.2
	dellis_autobuild_BaseSW:4.2
	Ursula_merge:4.1.7.4
	PDModules-4_44:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.4
	Ursula_RiscPC:4.1.7.4.0.4
	rthornb_UrsulaBuild-19Aug1998:4.1.7.4
	UrsulaBuild_FinalSoftload:4.1.7.4
	rthornb_UrsulaBuild-12Aug1998:4.1.7.4
	aglover_UrsulaBuild-05Aug1998:4.1.7.4
	rthornb_UrsulaBuild-29Jul1998:4.1.7.4
	rthornb_UrsulaBuild-22Jul1998:4.1.7.4
	hsimons_BOCA-1_2-Release:4.1.7.4
	rthornb_UrsulaBuild-15Jul1998:4.1.7.4
	rthornb_UrsulaBuild-07Jul1998:4.1.7.4
	rthornb_UrsulaBuild-17Jun1998:4.1.7.4
	rthornb_UrsulaBuild-03Jun1998:4.1.7.4
	rthornb_UrsulaBuild-27May1998:4.1.7.4
	rthornb_UrsulaBuild-21May1998:4.1.7.4
	rthornb_UrsulaBuild_01May1998:4.1.7.4
	afrost_NC2_Generic:4.1.7.4
	afrost_Funai01-33:4.1.7.4
	Ursula:4.1.7.4.0.2
	Ursula_bp:4.1.7.4
	Ursula_31Mar1998:4.2
	Spinner_RCA116:4.1.7.4
	Spinner_B20_2:4.1.7.4
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.4
	Spinner_B17:4.1.7.4
	Spinner_B15:4.1.7.4
	Spinner_B14:4.1.7.4
	Spinner_B13:4.1.7.4
	Spinner_B12:4.1.7.4
	Spin_merge_28May97:4.1.7.4
	Spinner_B10:4.1.7.4
	Spin_merge_16May97:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.4
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2013.12.17.19.28.15;	author jlee;	state Exp;
branches;
next	4.7;
commitid	m18ziQfXH0uLmwhx;

4.7
date	2003.07.11.18.10.21;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2003.01.17.10.30.35;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2002.12.05.20.45.09;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2001.09.18.16.09.01;	author mboura;	state Exp;
branches;
next	4.3;

4.3
date	2001.01.09.13.59.39;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.16.12.55.42;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.48.36;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.10.18.11.32.02;	author sbrodie;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2000.11.24.13.27.32;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.48.36;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.04.31;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.27.16;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.31.00;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.04.30.17.46.06;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.05.01.12.38.20;	author nturton;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.05.14.09.36.22;	author jcoxhead;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Fix alignment exceptions in SWI PDriverDP_SetDriver
Detail:
  s/PDriverDP/Configure - Code for handling long strings was failing when encoutering short strings, because although long strings appear to be always word-aligned, short strings are only stored with byte alignment. Fixed to only do an LDR once we know it's a long string we're looking at.
Admin:
  Tested on BB-xM
  Loading DP printer drivers no longer causes aborts


Version 4.58. Tagged as 'PDModules-4_58'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.PDriverDP.Configure


; ************************************************************************
; printer specific initialisation of the configuration.
;  This routine must initialise the variables in info_globalvalues and
;  size_globalvalues, as well as any variables of its own.
; It should preserve all registers.
; ************************************************************************

configure_init  ROUT


      [ (:LNOT: hostvdu) :LAND: debug
        Debug_Open "<Debug$File>"
      ]

        Push    "r0-r7, lr"

        MOV     R0, #0                  ; Clear the PDumper handling stuff
        STR     R0, printer_pdumper_pointer
        STR     R0, printer_stringblocksize
        STR     R0, pdumper_list
        STR     R0, pending_info_flag
        STR     R0, pending_pdumper_command
        MOV     R0, #-1
        STR     R0, printer_pdumper_number

        ADR     R0,config_callback
        MOV     R1,#Service_PDumperStarting
        SWI     XOS_AddCallBack         ; setup a call back handler

        ADR     r6, config_data         ; Copy the default printer page size, resolution etc...
        ADR     lr, info_globalvalues
        LDMIA   r6!, {r0-r5}
        STMIA   lr!, {r0-r5}
        LDMIA   r6!, {r0-r5, r7}
        STMIA   lr!, {r0-r5, r7}


        ADR     lr, printer_dump_depth  ; Start of configured data. Basically just interlace and dump depth and strip type.
        MOV     r5, #mde-mydata

01      LDR     r0, [r6], #4
        STR     r0, [lr], #4
        SUBS    r5, r5, #4
        BGT     %BT01

        Pull   "r0-r7, pc"

config_data
        &       120                     ;       Real x resolution
        &       180                     ;       Real y resolution
        &       PDriverInfo_TransformedSprites +PDriverInfo_TransformedFonts +PDriverInfo_MiscOp +PDriverInfo_SetDevice +PDriverInfo_DrawPageFlags
                                        ;       Info word

        &       &0                      ;
        &       120/1                   ;       Halftone resolution (x)
        &       180/1                   ;       Halftone resolution (y)
        &       0                       ;

        &       594960                  ; A4 paper
        &       841920
        &       17280
        &       72000/2
        &       577680
        &       841920-36000


mydata
        =   24, 0, 0, 255   ; dump depth, not interlaced (y nor x), strip type
;                              255 to give an error. Must do PDriver_SetPrinter!
;                              (to set a palette up for PDumper).
mde



; ************************************************************************
; declare a pdumperxx module using the service call entry
; ************************************************************************

config_callback ROUT
        Push    "R1,LR"
        MOV     R1,wp
        SWI     XOS_ServiceCall
        Pull    "R1,PC"                 ; issued when module in module chain



; ************************************************************************
; printer specific finalisation of the configuration.
;  This routine must free the RMA claimed in initialisation, in this case
; we must remove all all the blocks claimed for holding the PDumper
; chain.
; It should preserve all registers.
; ************************************************************************

configure_finalise ROUT
        Entry   "R0-R3"

        MOV     R1,#Service_PDumperDying
        SWI     XOS_ServiceCall         ; hello world we are disappearing!

        LDR     R2,printer_stringblocksize
        TEQ     R2,#0
        LDRNE   R2,printer_stringblockptr
        MOVNE   R0,#ModHandReason_Free  ; could be megs of dump strings in there!
        SWINE   XOS_Module

      [ (:LNOT: hostvdu) :LAND: debug
        Debug_Close
      ]
        LDR     R3,pdumper_list         ; -> pdumper list
00
        MOVS    R2,R3                   ; end of list yet?
        STREQ   R2,pdumper_list
        EXIT    EQ                      ; yes, so return

        MOV     R0,#ModHandReason_Free
        LDR     R3,[R2,#pdumper_next]
        SWI     XOS_Module              ; attempt to free the block (ignoring the error)
        B       %00                     ; loop back until they are all zapped



; ************************************************************************
; printer specific production of an error for PDriver_CheckFeatures.
;   Entry: R0, R1 are PDriver_CheckFeatures parameters
;          R2 is ((features) AND R0) and is known not to be the same as R1.
;   Exit:  Appropriate error should have been produced.
; ************************************************************************

configure_makeerror EntryS   "r1-r2"
        EOR      r1, r1, r2
        BIC      r1, r1, #2_110
        BICS     r1, r1, #2_11100000000
        EXITS    EQ

        MOV      r2, #0                 ; find first mismatched bit between r1, r2
01      MOVS     r1, r1, LSR #1
        ADDCC    r2, r2, #1
        BCC      %BT01

        ADR      r1, error_table
        LDR      r0, [r1, r2, LSL #2]
        ADD      r0, r0, r1
        addr     r1, title              ; %0 -> "PDriverDP"
        BL       LookupError            ; Always sets the V bit
        EXIT

error_table
        & ErrorBlock_PrintNoColour     - error_table        ; bit 0
        & 0                                                 ; bit 1
        & 0                                                 ; bit 2
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 3
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 4
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 5
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 6
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 7
        & 0                                                 ; bit 8
        & 0                                                 ; bit 9
        & 0                                                 ; bit 10
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 11
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 12
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 13
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 14
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 15
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 16
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 17
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 18
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 19
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 20
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 21
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 22
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 23
        & ErrorBlock_PrintNoScreenDump - error_table        ; bit 24
        & ErrorBlock_PrintBadTransform - error_table        ; bit 25
        & ErrorBlock_PrintNoIncludedFiles  - error_table    ; bit 26
        & 0                                                 ; bit 27
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 28
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 29
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 30
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 31

        MakeInternatErrorBlock PrintBadFeatures,,BadFeat
        MakeInternatErrorBlock PrintNoColour,,NoCol
        ALIGN



; *****************************************************************
; routine to vet parameters for PDriver_SetInfo
; Entry parameters as for PDriver_SetInfo
; *****************************************************************

configure_vetinfo ROUT
        [ Libra1        ; no longer need to get upset - cos all dumpers
                        ; support colour!
        Push    "LR"
        Pull    "PC"
        |
        CLRV
        TST     R3, #1
        MOVEQ   pc, lr

        Push    "R1,LR"
        ADR     R0,ErrorBlock_PrintNoColour
        ADDR    R1,title                ; %0 -> "PDriverDP"
        BL      LookupError             ; Always sets the V flag
        Pull    "R1,PC"
        ]



; *****************************************************************
; Set Printer and information
; This SWI is ignored by the PDumper module for version 3 drivers.
; *****************************************************************

configure_setprinter ROUT

        Debug   Configure,"SetPrinter called"

        ADR     R0,ErrorBlock_PrintBadSetPrinter
        B       LookupSingle            ;Translate the error message

        MakeInternatErrorBlock PrintBadSetPrinter,,NoPDSet


; *****************************************************************
; Set PDumper and information
;       R1 =  PDumper number
;       R2 => Command for getting the PDumperXX module (max 256 bytes)
;       R3 => 256 bytes of PDumperXX specific data
;       R4 => 256 bytes for dump_depth, interlace, strip type, no. passes and strings for printing
;             When a string is marked as present in the top level but zero length when you actually
;             get there this signifies an extended (potentially up to 16Mbyte) dump string.This
;             routine adds up all the lengths and rejigs the block to collect them all together.
;       R5 =  Configuration word for Dumper
; *****************************************************************

configure_setdriver ROUT

        Push    "R0-R8,R11,LR"

        Debug   Configure,"Setting configuration for PDumper",R1
        DebugS  Configure,"Command line to execute",R2
        Debug   Configure,"PDumper specific data at",R3
        Debug   Configure,"Configuration block at",R4
        Debug   Configure,"Configuration word of",R5

        STR     R5,printer_configureword

        MOV     R5,#252                 ; index
        ADR     R6,printer_dump_depth
00
        LDR     LR,[R4,R5]              ; copy the main block of config data
        STR     LR,[R6,R5]
        SUBS    R5,R5,#4
        BPL     %00                     ; while index >= 0

        ; Now accumulate how long the long dump strings are
        ADRL    R5,setdriver_table      ; -> offsets from printer_dump_depth to a string entry
        MOV     R7,#0
05
        LDRB    LR,[R5],#1
        TEQ     LR,#255                 ; end of offsets table?
        BEQ     %FT10
        LDRB    LR,[R6,LR]
        TEQ     LR,#0                   ; no dump string present
        BEQ     %BT05
        ADD     LR,LR,#dp_data_dlm      ; -> [len1] [string] or possibly [0] [len3] [ptr]
        LDRB    R8,[R6,LR]
        TST     R8,#255
        BNE     %BT05                   ; no action,it's a [len1] [string]
        LDR     R8,[R6,LR]              ; extended strings are expected to be word aligned
        MOV     R8,R8,LSR#8
        ADD     R7,R7,R8                ; accumulate the [len3] >> 8 bit
        B       %BT05

        ; Extend,or claim a slice of pie
10
        Debug   Configure,"Need a dump string block of size",R7
        TEQ     R7,#0                   ; do nothing (the block is free'd on finalisation)
        BEQ     %FT30
        LDR     R8,printer_stringblocksize
        CMP     R7,R8
        BLS     %FT15                   ; no need to grow block
        CMP     R8,#0                   ; zero'd on initialisation
        Push    "R0,R2,R3"
        MOVNE   R0,#ModHandReason_Free
        LDRNE   R2,printer_stringblockptr
        SWINE   XOS_Module
        MOV     R0,#ModHandReason_Claim
        MOV     R3,R7
        SWI     XOS_Module
        STRVC   R2,printer_stringblockptr
        STRVC   R3,printer_stringblocksize
        Debug   Configure,"Claim dump block at",R2
        Debug   Configure,"Claim dump block size",R3
        STRVS   R0,[SP]
        Pull    "R0,R2,R3"
        BVS     %FT45                   ; couldn't get enough RMA

        ; Copy strings to claimed RMA region and update original structure
        ; R5 = string entry being fiddled
        ; R6 = printer_dump_depth from earlier
        ; R7 = next free byte in RMA
        ; R8,R0,LR = scrap
15
        ADRL    R5,setdriver_table      ; -> offsets from printer_dump_depth to a string entry
        LDR     R7,printer_stringblockptr
        Debug   Configure,"Use dump block at",R7
20
        LDRB    LR,[R5],#1
        TEQ     LR,#255                 ; end of offsets table?
        BEQ     %FT30
        Debug   Configure,"--Inspect dump string#",LR
        LDRB    LR,[R6,LR]
        TEQ     LR,#0                   ; no dump string present
        BEQ     %BT20
        ADD     LR,LR,#dp_data_dlm      ; -> [len1] [string] or possibly [0] [len3] [ptr]
        LDRB    R8,[R6,LR]
        TST     R8,#255
        BNE     %BT20                   ; no action,it's a [len1] [string]
        LDR     R8,[R6,LR]
        ADD     LR,LR,#4
        LDR     R0,[R6,LR]              ; := source
        STR     R7,[R6,LR]              ; fiddle to where it's about to be copied
        Debug   Configure,"  Store string at",R7
        MOV     R8,R8,LSR#8             ; := length
        Debug   Configure,"  Length",R8
25
        LDRB    LR,[R0],#1
        STRB    LR,[R7],#1
        SUBS    R8,R8,#1
        BNE     %BT25
        B       %BT20

30
        LDR     R5,pdumper_list         ; -> pdumper list
35
        TEQ     R5,#0
        BEQ     %50                     ; not found so mark as pending.

        LDR     R6,[R5,#pdumper_number]
        TEQ     R6,R1                   ; found the pdumper we want?
        LDRNE   R5,[R5,#pdumper_next]
        BNE     %35                     ; loop until all finished scanning
40
        Debug   Configure,"PDumper record at",R5

        STR     R1,printer_pdumper_number
        STR     R5,printer_pdumper_pointer

        LDR     R5,printer_configureword

        MOV     R11,#PDumperReason_SetDriver
        BL      CallPDumper

        MOV     LR,#0
        STR     LR,pending_info_flag    ; mark as no pending info
45
        STRVS   R0,[SP]
        Pull    "R0-R8,R11,PC"
50
        Debug   Configure,"Pending PDumper is",R1
        Debug   Configure,"Pointer being set to",R5

        STR     R1,printer_pdumper_number
        STR     R5,printer_pdumper_pointer      

        MOV     R1,#-1
        STR     R1,pending_info_flag    

        TEQ     R2,#0                   ; is there a command string?
        STREQ   R2,pending_pdumper_command
        BEQ     %65
        
        MOV     R0,#0                   ; index into buffer
        ADRL    R5,pending_pdumper_command

        Debug   Configure,"Storing pending command at",R5
60
        LDRB    R6,[R2],#1              ; get a character
        CMP     R6,#32
        MOVLT   R6,#0                   ; terminate with a null
        MOVLT   R0,#255                 ; index to end of string
        STRB    R6,[R5],#1

        ADD     R0,R0,#1
        TEQ     R0,#256                 ; end of buffer yet?
        BNE     %60                     ; loop back until all copied or overflow

        TEQ     R6,#0                   ; end of the string?
        BEQ     %65
   
        ADR     R0,ErrorBlock_PrintOverflow
        BL      LookupSingle 
        B       %45                     ; return because of the overflow
65
        Debug   Configure,"About to copy the dumper specific block"

        MOV     R11,#252
        ADRL    R9,pending_info_data
70
        LDR     R10,[R3,R11]
        STR     R10,[R9,R11]
        SUBS    R11,R11,#4
        BGE     %70                     ; loop until all copied

        CLRV
        Pull    "R0-R8,R11,PC"
        
        MakeInternatErrorBlock PrintOverflow,,BufOFlo

setdriver_table
        ; as the dump strings aren't in a nice row in the block,here's a table of offsets
        DCB 15  ; dp_data_page_start
        DCB 16  ; dp_data_page_end         
        DCB 17  ; dp_data_line_return      
        DCB 18  ; dp_data_line_skip        
        DCB 19  ; dp_data_line_end         
        DCB 20  ; dp_data_line_end_i2      
        DCB 21  ; dp_data_line_end_i3      
        DCB 22  ; dp_data_zero_skip        
        DCB 23  ; dp_data_line_start       
        DCB 24  ; dp_data_line_start_2     
        DCB 25  ; dp_data_pass1_start      
        DCB 26  ; dp_data_pass1_start_2    
        DCB 27  ; dp_data_pass2_start      
        DCB 28  ; dp_data_pass2_start_2    
        DCB 29  ; dp_data_pass3_start      
        DCB 30  ; dp_data_pass3_start_2    
        DCB 31  ; dp_data_pass4_start      
        DCB 32  ; dp_data_pass4_start_2    
        DCB 33  ; dp_data_set_lines        
        DCB 48  ; dp_data_form_feed
        DCB 255 ; end
        ALIGN

; *****************************************************************
;
; CallPDumper
;
; In:   R11  =reason code and other registers setup correctly.
;
; Out:  V clear, registers setup.
;       V set, R0 -> error block.
;
; *****************************************************************

CallPDumper ROUT

        Push    "R10-R12,LR"

        Debug   CallPDumper,"+CallPDumper",R11

        CLRV
        BL      enableescapes   ; Must make sure escapes are enabled for any PDumper call JRC 12 May '97
        LDR     R12,printer_pdumper_pointer     ;based on r12

        [ Libra1
        ; validate strip type
        TEQ     R11,#PDumperReason_SetDriver
        ; MOVEQ   R9,#0
        LDREQB  R9, [R4, #4]
        ANDNE   R9,R2,#&FF              ;Get the strip type or make one up if required
        MOV     LR, #1
        MOV     LR, LR, LSL R9
        Debug   CallPDumper,"Strip type as a mask = ",LR
        LDR     R9, [R12,#pdumper_striptypemask]
        Debug   CallPDumper,"Permissible mask = ",R9
        ANDS    R9, R9, LR
        BNE     %FT10
        Debug   CallPDumper,"Bad strip type requested"
        ADR     R0,ErrorBlock_PDumperBadStrip
        ADDR    R1,title                ;->Title string
        Debug   CallPDumper,"PDumper_LookupError"
        SWI     XPDumper_LookupError
        Pull    "R10-R12,lr"
        Push    lr
        BL      disableandcheckescapes  ;Error---reenable
        Pull    pc

10
        ]

        [ MakeUpCallsAtEntry
        BL      upcallPDumperActionAtEntry
        ]
        [ MakeUpCallsAtExit
        Push    "r12"
        ]

        ADD     R12,R12,#pdumper_workspace

        MOV     LR,PC
        LDMIA   R12,{R12,PC}            ; call the routine

        DebugIf VC, CallPDumper,"-CallPDumper---no error"
        DebugE  CallPDumper,"-CallPDumper"

        [ MakeUpCallsAtExit
        Pull    "r12"
        BL      upcallPDumperActionAtExit
        ]

        Pull    "R10-R12,lr"            ; and then return
        Push    lr
        BL      disableandcheckescapes  ;Reenable afterwards JRC Mon 12th May 1997
        Pull    pc

        MakeInternatErrorBlock PDumperBadStrip,,BadStrp


CallPDumperForJob ROUT
        DebugEscState CallPDumperForJob
        Push    "R10-R12,LR"

        Debug   CallPDumper,"+CallPDumperForJob",R9
        Debug   CallPDumper,"Job record is at",R11

        CLRV
        BL      enableescapes           ; JRC Mon 12th May 1997
        LDR     R12,job_pdumper_pointer

        [ Libra1
        Push    "R9"
        ; validate strip type
        TEQ     R11,#PDumperReason_SetDriver
        ; MOVEQ   R9,#0
        LDREQB  R9, [R4, #4]
        ANDNE   R9,R2,#&FF              ;Get the strip type or make one up if required
        MOV     LR, #1
        MOV     LR, LR, LSL R9
        Debug   CallPDumper,"Strip type as a mask = ",LR
        LDR     R9, [R12,#pdumper_striptypemask]
        Debug   CallPDumper,"Permissible mask = ",R9
        ANDS    R9, R9, LR
        BNE     no_error
        Debug   CallPDumper,"Bad strip type requested"
        ADR     R0,ErrorBlock_PDumperBadStrip
        ADDR    R1,title                ;->Title string
        Debug   CallPDumper,"PDumper_LookupError"
        SWI     XPDumper_LookupError
        Pull    "R9"
        Pull    "R10-R12,lr"
        Push    lr
        BL      disableandcheckescapes  ; JRC Mon 12th May 1997
        Pull    pc

no_error      Pull    "R9"
        ]
        [ MakeUpCallsAtEntry
        BL      upcallPDumperActionAtEntry
        ]
        [ MakeUpCallsAtExit
        Push    "r12"
        ]

        ADD     R12,R12,#pdumper_workspace

        MOV     R11,R9


        MOV     R14,PC
        LDMIA   R12,{R12,PC}            ; call the routine

        DebugIf VC, CallPDumper, "-CallPDumperForJob---no error"
        DebugE  CallPDumper, "-CallPDumperForJob"

        [ MakeUpCallsAtExit
        Pull    "r12"
        BL      upcallPDumperActionAtExit
        ]

        Pull    "R10-R12,lr"
        Push    lr
        BL      disableandcheckescapes  ; JRC Mon 12th May 1997
        Pull    pc


; Upcall generating code
        [ MakeUpCallsAtEntry

upcallPDumperActionAtEntry ROUT

        Push    "r0-r12,lr"
        MOV     r0, #UpCall_PDumperAction
        MOV     r1, #0                         ; PDumper entry flag
        MOV     r2, sp                         ; Pointer to r0-r12
        SWI     XOS_UpCall
        Pull    "r0-r12,pc"
        ]

        [ MakeUpCallsAtExit

upcallPDumperActionAtExit ROUT

        Push    "r0-r12,lr"
        MOV     r0, #UpCall_PDumperAction
        MOV     r1, #1                         ; PDumper exit flag
        ORRVS   r1, r1, #2                     ; Error flag
        MOV     r2, sp                         ; Pointer to r0-r12
        SWI     XOS_UpCall
        TST     r1, #2                         ; restore error (if any)
        SETV    NE
        Pull    "r0-r12,pc"
        ]

        END
@


4.7
log
@Unoptimised a RMA clearing loop: went mad if the workspace was not a
multiple of 3.
Changed PDumper Upcall stuff to pass R0-R12 on the stack - curiously this
fixes the RMA corruption and instability of !Printers (as does switching
the UpCalls off.

Version 4.51. Tagged as 'PDModules-4_51'
@
text
@d287 1
a287 1
        LDR     R8,[R6,LR]
d290 1
d337 1
a337 1
        LDR     R8,[R6,LR]
d340 1
@


4.6
log
@Addition of support for long dump strings to PDriverDP.
This calculates the sum length of all the dump strings given to it and
then takes a local copy (since the caller might be an application) and
rejigs the block to point to that local copy.
Will also still accept old format PDriver_SetDriver blocks,plus a mixture
of the two in theory.

Version 4.49. Tagged as 'PDModules-4_49'
@
text
@d277 1
a277 1
        ADR     R5,setdriver_table      ; -> offsets from printer_dump_depth to a string entry
d296 1
d312 3
d324 1
a324 1
        ADR     R5,setdriver_table      ; -> offsets from printer_dump_depth to a string entry
d326 1
d331 1
d342 1
d344 1
d395 1
a395 1
        Debug   Configure,"Storing pending comand at",R5
d472 2
a473 2
	BL	enableescapes	; Must make sure escapes are enabled for any PDumper call JRC 12 May '97
        LDR     R12,printer_pdumper_pointer	;based on r12
d491 1
a491 1
	Debug	CallPDumper,"PDumper_LookupError"
d494 3
a496 3
        Push	lr
        BL	disableandcheckescapes	;Error---reenable
        Pull	pc
d505 1
a505 1
          Push  "r12"
d513 2
a514 2
	DebugIf	VC, CallPDumper,"-CallPDumper---no error"
	DebugE	CallPDumper,"-CallPDumper"
d522 3
a524 3
        Push	lr
        BL	disableandcheckescapes	;Reenable afterwards JRC Mon 12th May 1997
        Pull	pc
d530 2
a531 2
	DebugEscState CallPDumperForJob
	Push    "R10-R12,LR"
d537 1
a537 1
	BL	enableescapes		; JRC Mon 12th May 1997
d557 1
a557 1
	Debug	CallPDumper,"PDumper_LookupError"
d561 3
a563 3
        Push	lr
        BL	disableandcheckescapes	; JRC Mon 12th May 1997
        Pull	pc
d580 1
a580 1
        LDMIA   R12,{R12,PC}		; call the routine
d582 2
a583 2
	DebugIf	VC, CallPDumper, "-CallPDumperForJob---no error"
	DebugE	CallPDumper, "-CallPDumperForJob"
d586 2
a587 2
          Pull    "r12"
          BL      upcallPDumperActionAtExit
d590 4
a593 4
        Pull	"R10-R12,lr"
        Push	lr
        BL	disableandcheckescapes	; JRC Mon 12th May 1997
	Pull	pc
d601 1
a601 3
        Push    "lr"
        ADRL    lr, upCallRegs
        STMIA   lr, {r0-r12}
d604 1
a604 1
        MOV     r2, lr                         ; Pointer to r0-r12
d606 1
a606 3
        ADRL    lr, upCallRegs
        LDMIA   lr,  {r0-r12}
        Pull    "pc"
d613 1
a613 4
        Push    "lr"

        ADRL    lr, upCallRegs
        STMIA   lr, {r0-r12}
d617 1
a617 1
        MOV     r2, lr                         ; Pointer to r0-r12
d621 1
a621 3
        ADRL    lr, upCallRegs
        LDMIA   lr,  {r0-r12}
        Pull    "pc"
@


4.5
log
@Changed to use objasm to avoid any LDR rN,[rN],#0 problems
Changed to use shared Makefiles
Numerous small 32 bit conversion improvements
Bugfix to PDriverPS,it was pulling LR not PC - this has been the case for
many years so not sure how it ever worked.
Due to a bug in objasm 3.27 this checkin will infact not build directly.
You must first
 - rename the PDriverDP dir to PDriverDP2
 - rename the PDriverPS dir to PDriverPS2
 - move the 2 source files of the same name up a directory
checked in in this way to minimise messing in CVS.

Version 4.47. Tagged as 'PDModules-4_47'
@
text
@d36 1
d118 6
d250 3
a253 9
;       R6 =  Pointer to extension block (for Config versions >= 5)
;                  0 Number of entries in block
;                  4 Size of block
;                  8 Offset within block of data1 string (n1)
;		  12 Offset withing block of data2 string (n2)
;		 ...
;		  n0 Length of data1 string
;		n0+1 data1 string data
;		  n1 ...
d258 1
a258 1
        EntryS  "R0-R8,R11"
d268 2
a269 22
	STMFD	r13!,{r0-r3}
	MOV	R5,R5,ASR#24
	CMP	R5,#5
	BLT	%02		; Old version - no extended data
	LDR	r7,printer_extendedstringsblocksize
	LDR	r8,[r6,#4]	; r8 = size of block
	LDR	r2,printer_extendedstringsblock
	CMP	r7,r8		; If the block is big enough anyway, no probs.
	BGE	%00
	; Else Resize the block
	MOV	r0,#7
	CMP	r2,#0
	SWINE	XOS_Module
	MOV	r0,#6
	MOV	r3,r8
	SWI	XOS_Module
	MOVVS	r2,#0
	MOVVS	r8,#0
	STR	r8,printer_extendedstringsblocksize
	STR	r2,printer_extendedstringsblock
	LDMVSFD	r13!,{r0-r3}
	Pull	"R0-R8,R11,PC",VS
d271 72
a342 26
	MOV	r3,r8
01
	; Now copy into that block
	SUBS	r3,r3,#1
	LDRGEB	lr,[r6,r3]
	STRGEB	lr,[r2,r3]
	BGT	%01
	B	%03
02
	; Free any extended data we have got
	LDR	r2,printer_extendedstringsblock
	MOV	r0,#7
	CMP	r2,#0
	SWINE	XOS_Module
	MOV	r2,#0
	STR	r2,printer_extendedstringsblock
	STR	r2,printer_extendedstringsblocksize
03
	LDMFD	r13!,{r0-r3}
        MOV     R5,#255                 ; index
        ADR     R6,printer_dump_depth
04
        LDRB    LR,[R4,R5]              ; copy the data
        STRB    LR,[R6,R5]
        SUBS    R5,R5,#1
        BPL     %04                     ; while index >=0
d344 1
d346 1
a346 1
05
d348 1
a348 1
        BEQ     %20                     ; not found so mark as pending.
d353 2
a354 2
        BNE     %05                     ; loop until all finished scanning
10
a361 1
	LDR	R6,printer_extendedstringsblock
d367 4
a370 4
15
        STRVS   R0,[SP,#Proc_RegOffset]
        EXIT
20
d375 1
a375 1
        STR     R5,printer_pdumper_pointer
d378 1
a378 1
        STR     R1,pending_info_flag
d382 2
a383 2
        BEQ     %35

d388 1
a388 1
30
d397 1
a397 1
        BNE     %30                     ; loop back until all copied or overflow
d400 2
a401 2
        BEQ     %35

d403 3
a405 3
        BL      LookupSingle
        B       %15                     ; return because of the overflow
35
d410 1
a410 1
40
d414 1
a414 3
        BGE     %40                     ; loop until all copied

        EXITS
d416 3
d421 24
a444 1

@


4.4
log
@Added UpCall to provide information about what the dumper is doing.
Detail:
UpCall made at exit from dumper routines to enable page counting. Could also be used for things like progress indication. Code is in place for UpCall at entry to dumper, but not assembled at present.
Admin:
Tested with module provisionally called PMonitor.

Version 4.46. Tagged as 'PDModules-4_46'
@
text
@d244 9
d267 42
d311 1
a311 1
00
d315 1
a315 1
        BPL     %00                     ; while index >=0
d334 1
d448 1
a448 1
          
d469 1
a469 1
        
d514 1
a514 1
        
d555 1
a555 1
        
d559 1
a559 1
        
d573 1
a573 1
        
@


4.3
log
@  Merge of 32-bit branch.
Detail:
  These modules are now thought to work.
Admin:
  This module has received some testing of both 26-bit and 32-bit
    builds and is believed to function correctly.

Version 4.45. Tagged as 'PDModules-4_45'
@
text
@d389 8
d398 1
d405 5
d417 1
a417 1

d456 7
d466 2
d474 5
d484 38
@


4.2
log
@Spinner branch merged
@
text
@d42 1
a42 1
        ADR     R0,config_callback     
d53 1
a53 1
       
d68 1
a68 1
                                        ;       Info word                                     
d70 1
a70 1
        &       &0                      ; 
d112 1
a112 1
        Push    "R0-R3,LR"
d120 1
a120 1
        LDR     R2,pdumper_list         ; -> pdumper list
d122 1
a122 1
        TEQ     R2,#0                   ; end of list yet?
d124 1
a124 2
        Pull    "R0-R3,PC",EQ,^         ; yes, so return

a128 2
        
        MOV     R2,R3   
d140 1
a140 1
configure_makeerror ENTRY "r1-r2"
d209 1
d211 2
a212 2
        MOVEQS  pc, lr
               
d248 1
a248 1
        Push    "R0-R8,R11,LR"
d288 3
a290 3
15                              
        STRVS   R0,[SP]
        Pull    "R0-R8,R11,PC"
d296 1
a296 1
        STR     R5,printer_pdumper_pointer      
d299 1
a299 1
        STR     R1,pending_info_flag    
d304 1
a304 1
        
d322 1
a322 1
   
d324 1
a324 1
        BL      LookupSingle 
d337 2
a338 2
        Pull    "R0-R8,R11,PC",,^
        
d359 1
a359 1
        
d379 1
a379 1
        ADDR    R1,title                ;->Title string 
d381 1
a381 1
        SWI     XPDumper_LookupError     
d410 1
a410 1
        
d431 1
a431 1
        ADDR    R1,title                ;->Title string 
d433 2
a434 2
        SWI     XPDumper_LookupError 
        Pull    "R9"    
d446 1
a446 1
        LDMIA   R12,{R12,PC}		; call the routine 
@


4.2.2.1
log
@  First attempt at 32-bit compatible modules.
Admin:
  Tested that modules build 26-bit and 32-bit.
  Requires HdrSrc-1_05 or later.

Version 4.44, 4.1.2.1. Tagged as 'PDModules-4_44-4_1_2_1'
@
text
@d42 1
a42 1
        ADR     R0,config_callback
d53 1
a53 1

d68 1
a68 1
                                        ;       Info word
d70 1
a70 1
        &       &0                      ;
d112 1
a112 1
        Entry   "R0-R3"
d120 1
a120 1
        LDR     R3,pdumper_list         ; -> pdumper list
d122 1
a122 1
        MOVS    R2,R3                   ; end of list yet?
d124 2
a125 1
        EXIT    EQ                      ; yes, so return
d130 2
d143 1
a143 2
configure_makeerror
        EntryS   "r1-r2"
a211 1
        CLRV
d213 2
a214 2
        MOVEQ   pc, lr

d250 1
a250 1
        EntryS  "R0-R8,R11"
d290 3
a292 3
15
        STRVS   R0,[SP,#Proc_RegOffset]
        EXIT
d298 1
a298 1
        STR     R5,printer_pdumper_pointer
d301 1
a301 1
        STR     R1,pending_info_flag
d306 1
a306 1

d324 1
a324 1

d326 1
a326 1
        BL      LookupSingle
d339 2
a340 2
        EXITS

d361 1
a361 1

d381 1
a381 1
        ADDR    R1,title                ;->Title string
d383 1
a383 1
        SWI     XPDumper_LookupError
d412 1
a412 1

d433 1
a433 1
        ADDR    R1,title                ;->Title string
d435 2
a436 2
        SWI     XPDumper_LookupError
        Pull    "R9"
d448 1
a448 1
        LDMIA   R12,{R12,PC}		; call the routine
@


4.2.2.2
log
@  Lots of fixes.
Detail:
  Several stack imbalances and missing conditions on instructions fixed.
  Some flag removal code sequences improved (RSB rn,pc,pc:SUB rn,lr,rn)
Admin:
  Built both 26 and 32-bit versions - neither tested.

Version 4.44, 4.1.2.2. Tagged as 'PDModules-4_44-4_1_2_2'
@
text
@d140 2
a141 1
configure_makeerror EntryS   "r1-r2"
@


4.1
log
@Initial revision
@
text
@d308 1
a308 1
        ADR     R5,pending_pdumper_command
d355 1
a355 1
           
d360 1
a360 1
        Debug   CallPDumper,"Calling PDumper with reason",R11
d363 2
a364 2

        LDR     R12,printer_pdumper_pointer
d382 1
d384 4
a387 1
        Pull    "R10-R12,PC"
a391 1

d395 2
a396 1
        Debug   CallPDumper,"Back from PDumper"
d398 4
a401 1
        Pull    "R10-R12,PC"            ; and then return
d407 2
d410 1
a410 3
        Push    "R10-R12,LR"

        Debug   CallPDumper,"Calling PDumper with reason",R9
d414 1
a414 1

d434 1
d437 4
a440 1
        Pull    "R10-R12,PC"
d448 1
a448 5
        LDMIA   R12,{R12,PC}                 
         
        Debug   CallPDumper,"Back from calling the PDumper"

        Pull    "R10-R12,PC"
d450 2
d453 4
a458 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@   Use buffer in workspace for MessageTrans.
   Added 'Colour' debugging flag.
   Do not pass SpriteV calls to pdriver if a Wimp error box is open.
@
text
@d360 1
a360 1
        Debug   CallPDumper,"+CallPDumper",R11
a381 1
	Debug	CallPDumper,"PDumper_LookupError"
d392 1
a392 6
	[	debug
	DebugIf	VC, CallPDumper,"-CallPDumper---no error"
	ADDVS	r0, r0, #4
	DebugSIf VS, CallPDumper,"-CallPDumper---error", r0
	SUBVS	r0, r0, #4
	]
d403 1
a403 1
        Debug   CallPDumper,"+CallPDumperForJob",R9
a426 1
	Debug	CallPDumper,"PDumper_LookupError"
d438 2
a439 7

	[	debug
	DebugIf	VC, CallPDumper,"-CallPDumperForJob---no error"
	ADDVS	r0, r0, #4
	DebugSIf VS, CallPDumper,"-CallPDumperForJob---error", r0
	SUBVS	r0, r0, #4
	]
@


4.1.7.3
log
@Fixed data abort on init
@
text
@d308 1
a308 1
        ADRL    R5,pending_pdumper_command
@


4.1.7.4
log
@   Enable escapes round all calls to PDumper.
   Replace the caller's escape handler with a NOP. Otherwise, we end
up calling the current escape handler when we acknowledge the escape,
which has potentially horrible consequences. In the case of the C
library, the escape handler is expecting to have to raise a signal,
and if it can't do this is generates an error instead.
@
text
@d355 1
a355 1

d363 2
a364 2
	BL	enableescapes	; Must make sure escapes are enabled for any PDumper call JRC 12 May '97
        LDR     R12,printer_pdumper_pointer	;based on r12
d384 1
a384 4
        Pull    "R10-R12,lr"
        Push	lr
        BL	disableandcheckescapes	;Error---reenable
        Pull	pc
d389 1
d393 1
d395 4
a398 1
	DebugE	CallPDumper,"-CallPDumper"
d400 1
a400 4
        Pull    "R10-R12,lr"            ; and then return
        Push	lr
        BL	disableandcheckescapes	;Reenable afterwards JRC Mon 12th May 1997
        Pull	pc
d406 2
a407 2
	DebugEscState CallPDumperForJob
	Push    "R10-R12,LR"
d413 1
a413 1
	BL	enableescapes		; JRC Mon 12th May 1997
d436 1
a436 4
        Pull    "R10-R12,lr"
        Push	lr
        BL	disableandcheckescapes	; JRC Mon 12th May 1997
        Pull	pc
d444 10
a453 1
        LDMIA   R12,{R12,PC}		; call the routine 
a454 2
	DebugIf	VC, CallPDumper, "-CallPDumperForJob---no error"
	DebugE	CallPDumper, "-CallPDumperForJob"
a455 4
        Pull	"R10-R12,lr"
        Push	lr
        BL	disableandcheckescapes	; JRC Mon 12th May 1997
	Pull	pc
d458 1
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

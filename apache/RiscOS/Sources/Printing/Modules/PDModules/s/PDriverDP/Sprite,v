head	4.9;
access;
symbols
	PDModules-4_64:4.9
	PDModules-4_63:4.8
	PDModules-4_62:4.8
	PDModules-4_61:4.7
	PDModules-4_60:4.7
	PDModules-4_59:4.7
	PDModules-4_58:4.6
	PDModules-4_57:4.6
	PDModules-4_56:4.6
	PDModules-4_55:4.6
	PDModules-4_54:4.6
	PDModules-4_53:4.6
	PDModules-4_52:4.6
	PDModules-4_51:4.6
	PDModules-4_50:4.6
	PDModules-4_49:4.5
	PDModules-4_48:4.5
	PDModules-4_47:4.5
	PDModules-4_46:4.4
	kbracey_32bit_merge:4.3.2.1
	PDModules-4_45:4.4
	PDModules-4_44-4_1_2_7:4.3.2.1
	PDModules-4_44-4_1_2_6:4.3.2.1
	PDModules-4_44-4_1_2_5:4.3.2.1
	PDModules-4_44-4_1_2_4:4.3.2.1
	PDModules-4_44-4_1_2_3:4.3.2.1
	PDModules-4_44-4_1_2_2:4.3.2.1
	PDModules-4_44-4_1_2_1:4.3.2.1
	kbracey_32bit:4.3.0.2
	kbracey_32bit_bp:4.3
	dellis_autobuild_BaseSW:4.3
	Ursula_merge:4.1.7.2
	PDModules-4_44:4.3
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.2
	Ursula_RiscPC:4.1.7.2.0.4
	rthornb_UrsulaBuild-19Aug1998:4.1.7.2
	UrsulaBuild_FinalSoftload:4.1.7.2
	rthornb_UrsulaBuild-12Aug1998:4.1.7.2
	aglover_UrsulaBuild-05Aug1998:4.1.7.2
	rthornb_UrsulaBuild-29Jul1998:4.1.7.2
	rthornb_UrsulaBuild-22Jul1998:4.1.7.2
	hsimons_BOCA-1_2-Release:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.1.7.2
	rthornb_UrsulaBuild-07Jul1998:4.1.7.2
	rthornb_UrsulaBuild-17Jun1998:4.1.7.2
	rthornb_UrsulaBuild-03Jun1998:4.1.7.2
	rthornb_UrsulaBuild-27May1998:4.1.7.2
	rthornb_UrsulaBuild-21May1998:4.1.7.2
	rthornb_UrsulaBuild_01May1998:4.1.7.2
	afrost_NC2_Generic:4.1.7.2
	afrost_Funai01-33:4.1.7.2
	Ursula:4.1.7.2.0.2
	Ursula_bp:4.1.7.2
	Ursula_31Mar1998:4.3
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spin_merge_28May97:4.1.7.2
	Spinner_B10:4.1.7.2
	Spin_merge_16May97:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2018.07.18.07.53.24;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	svgg0RWLmbKgIAKA;

4.8
date	2018.07.03.21.14.45;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	8KGlIKKeLIz2DJIA;

4.7
date	2014.10.20.21.53.05;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	kYvwc1FHitWAiZUx;

4.6
date	2003.03.10.11.33.28;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2002.12.05.20.45.09;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2001.01.09.13.59.39;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	97.05.16.12.55.49;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.17.07.48;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.48.39;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2000.10.18.11.32.02;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.48.39;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.05.14;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.27.38;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.31.19;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.04.30.17.46.12;	author scormie;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Let through post 3.50 sprite types in PDriverDP
Pass the sprite type to OS_ReadModeVariable rather than trying to infer the Log2BPP from the sprite type directly.
Tested printing a Draw file with all true colour combinations of test sprites, via the PCL dumper, to a Kyocera 2551ci colour laser printer.

Version 4.64. Tagged as 'PDModules-4_64'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.PDriverDP.Sprite (as from 3.26 onwards)

;------------------------------------------------------------------------------
; sprite_put    - plot a sprite at the given coordinates with suitable
;                 scaling and translation.
;
;                       in      R0 = SpriteOp reason code
;                               R1 -> sprite area if R0 >= &100; otherwise assumed
;                                     to be the system area
;                               R2 -> sprite/name (if R0 >=&100 / &200)
;                               R3 = X co-ordinate relative to bottom left of
;                                      current rectangle (in OS units)
;                               R4 = y co-ordinate relative to bottom left of
;                                      current rectangle (in OS units)
;                               R5 = gcol action
;                               R6 = 0 or -1 for no scaling, or points to 4 scaling factors
;                                       (x-mag, y-mag, x-div, y-div)
;                               R7 = 0 or -1 for no translation, or points to translation table.
;
; Attempt to put a sprite at the specified co-ordinates, scaling and translating
; as needed.
;
; Due to problems with PutSpriteScaled the routine uses PutSpriteTransformed
; into a parallelogram.  The routine calculates the bounding box of the image
; and snaps the co-ordinates to nice pixel boundaries and then plots.
;
;------------------------------------------------------------------------------

sprite_put Entry "R3,R4,R6-R9"

        MOV     R9,#SpriteReason_PutSpriteTransformed

sprite_put_altentry
        CLRV
        LDRB    LR,disabled
        TST     LR,#disabled_nullclip   ; is it a null clip region?
        EXIT    NE

        Debug   Sprite,"SpriteOp",R0
        Debuga  Sprite,"CBptr",R1
        Debug   Sprite,", SPptr",R2
        Debuga  Sprite,"X co-ordinate",R3
        Debug   Sprite,", Y co-ordinate",R4
        Debug   Sprite,"GCOL action",R5
        Debug   Sprite,"Mag table at",R6
        Debug   Sprite,"Trans table at",R7

        CMP     R0,#&100                ; is a system sprite operation?
        ORRLT   R0,R0,#&100             ;  if it is then convert to an op with name

        Push    "R0"
        BGE     %FT01
        MOV     R0,#3
        SWI     XOS_ReadDynamicArea     ; read the address of the system sprite pool
        MOV     R1,R0                   ;   and then move to CBptr
01
; R0 has been corrupted!

        CMP     R6, R6, ASR#31          ; any scaling being performed?
        ADREQ   R6,nullscale            ;   no, so address a default scale block

        Push    "R1-R6"

        LDR     R0,[SP,#4*6]            ; restore the sprite operation
        BIC     R0,R0,#&FF              ;   and then setup the suitable reason code
        ORR     R0,R0,#SpriteReason_ReadSpriteSize
        SWI     XOS_SpriteOp
        BVS     %FT02

        STR     R3,job_spritescale +8
        STR     R4,job_spritescale +12  ; R3,R4 contain the width, height of sprite (pixels)

        [ Medusa
        MOV     R0,R6
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable 
        MOV     LR,R2
        TEQ     LR,#4
        TEQNE   LR,#5
        BNE     %FT02                   ; only fake colourtrans tables for 16bpp and 32bpp

        [ Libra1
        LDRB    R6, job_strip_type
        CMP     R6, #0
        CMPNE   R6, #1
        BLEQ    sprite_makemono32Ktable ; one for greyscale output
        CMP     R6, #2
        BLEQ    sprite_make256c32Ktable ; one for colour output
        |
        LDRB    R6, printer_strip_type  ; make fake colourtrans table
        CMP     R6, #2
        BLEQ    sprite_make256c32Ktable ; one for colour output
        BLNE    sprite_makemono32Ktable ; one for greyscale output
        ]

        ]
02
        Pull    "R1-R6"
        BVS     %FT99                   ; if it fails then attempt to tidy up

        Push    "R1,R3,R4"              ; lower left co-ordinates

        LDR     R0,[R6,#0]              ; x multiplier
        LDR     R8,job_spritescale +8   ; sprite width in pixels
        MUL     R0,R8,R0
        LDR     R1,[R6,#8]              ; get the divisor
        LDR     LR, currxeig            ; scale to OS units

        [ Libra1                        ; ensure that the divisor doesn't get set
        Push    "R2"                    ; to 0 by being shifted
        MOV     R2, R1
        TEQ     R2, #0
        BEQ     %FT01
        MOV     R2, R2, LSR LR
        TEQ     R2, #0                  ; if divisor->0 then
        MOVEQ   R1, R1, LSL LR          ; scale multiplier & divisor by same amount
        MOVEQ   R0, R0, LSL LR          ; in order to prevent divisor -> 0
01
        Pull    "R2"
        ]

        TEQ     R1,#0                   ;   trap division by zero
        MOVNE   R1, R1, LSR LR
        MOVEQ   R0, R0, LSL LR
        BLNE    Divide                  ; divide out yeilding target x size
        ADD     R3,R3,R0                ;   and the right X co-ordinate

        LDR     R0,[R6,#4]              ; y multiplier
        LDR     R8,job_spritescale+12   ; sprite height in pixels
        MUL     R0,R8,R0
        LDR     R1,[R6,#12]             ; get the y divisor
        LDR     LR, curryeig            ; scale to OS units

        [ Libra1                        ; ensure that the divisor doesn't get set
        Push    "R2"                    ; to 0 by being shifted
        MOV     R2, R1
        TEQ     R2, #0
        BEQ     %FT02
        MOV     R2, R2, LSR LR
        TEQ     R2, #0                  ; if divisor->0 then
        MOVEQ   R1, R1, LSL LR          ; scale multiplier & divisor by same amount
        MOVEQ   R0, R0, LSL LR          ; in order to prevent divisor -> 0
02
        Pull    "R2"
        ]
        TEQ     R1,#0                   ;   and trap division by zero
        MOVNE   R1, R1, LSR LR
        MOVEQ   R0, R0, LSL LR
        BLNE    Divide                  ; divide out yeilding target y size
        ADD     R4,R4,R0                ;  and then the top co-ordinate

        BL      scale_r3r4              ; scale the co-ordiantes to device values
        Debug   Sprite,"Top right co-ordinates",R3,R4

        MOV     R3,R3,LSR #bufferpix_l2size
        MOV     R3,R3,LSL #8+bufferpix_l2size
        MOV     R4,R4,LSR #bufferpix_l2size
        MOV     R4,R4,LSL #8+bufferpix_l2size

; R3 = top x co-ordinate of the bounding box
; R4 = top y co-ordinate of the bounding box

        STR     R3,job_spritescale+8    ; X0
        STR     R4,job_spritescale+4    ;   ,Y0

        STR     R3,job_spritescale+16   ; X0,Y0
        STR     R4,job_spritescale+12

; Due to a problem with the PutSpriteTransformed co-ordinate block the
; call renders from the top of the specified bouning box down, taking the top
; line to be the first line of the sprite.
;
; Therefore the co-ordinates need to be shuffled around and this bit may
; not seem very logical, but its due to the brain damaged aprproach used
; in Sprite Distend.

        Pull    "R1,R3,R4"
        BL      scale_r3r4              ; scale the co-ordinates to device values
        MOV     R3,R3,LSR #bufferpix_l2size
        MOV     R3,R3,LSL #8+bufferpix_l2size
        MOV     R4,R4,LSR #bufferpix_l2size
        MOV     R4,R4,LSL #8+bufferpix_l2size

; R3 = bottom x co-ordinate of bounding box
; R4 = bottom y co-ordinate of bounding box

        STR     R3,job_spritescale      ; X0,Y0
        STR     R4,job_spritescale+28

        STR     R3,job_spritescale+24   ; X0
        STR     R4,job_spritescale+20   ;   ,Y0


        ADRL    R6,job_spritescale      ; -> new sprite scaling table

        CMP     R7, R7, ASR#31          ; has a translation table been specified?
        BNE     %FT01                   ;   yes, so no need to generate one

        Push    "R0-R4"
        MOV     R0,#-1                  ; translate from current to current mode
        MOV     R1,#-1                  ;   this is intercepted by the printer
        MOV     R2,#-1                  ;   drivers to map the current palette to the
        MOV     R3,#-1                  ;   current printer palette.
        ADRL    R4,job_spritetrans
        SWI     XColourTrans_SelectTable


        STRVS   R0,[SP]
        Pull    "R0-R4"                 ; return a sensible error pointer
        BVS     %FT99                   ;   and act accordingly, giving up!

        ADRL    R7,job_spritetrans
01
        Pull    "R0"                    ; restore the reason code
        BIC     R0,R0,#&FF              ;   and then make a new one
        ORR     R0,R0,R9                ;   with the specified reason code (used for mask plotting)


        MOV     R3,#2_1                 ; destination in co-ordinate block
        Debug mjs,"pass to spriteop with R0 R5 = ",R0,R5
        BL      pass_spriteop           ;   and then pass onto SpriteExtend to cope with it
        EXIT                            ;   returning with the flags from exiting the call
99
        ADD     SP,SP,#4
        EXIT                            ; return because of an error balancing the stack


; scale_r3,r4 = from user co-ords to buffer co-ordiantes
;
; in    R3,R4 pre-scaled co-ordinates
; out   R0 corrupt
;       R3,R4 modified to be within current strip

scale_r3r4 EntryS

        MOV     R0,R3,LSL #8            ; convert to suitable co-ordinate system
        BL      XScale                  ;   and then scale properly
        LDR     LR,job_currentXoffset
        SUB     R0,R0,LR                ; adjust by the current horizontal offset
        MOV     R3,R0,LSR #8            ;   and trim back down to size

        MOV     R0,R4,LSL #8            ; convert to suitable co-ordinate system
        BL      YScale                  ;   and then scale properly
        LDR     LR,job_currentYoffset
        SUB     R0,R0,LR                ; adjust by the current horizontal offset
        MOV     R4,R0,LSR #8            ;   and trim back down to size

        EXITS                           ; corrupts R0, preserves flags


; empty scaling block used when no scaling block is specified

nullscale       & 1,1,1,1               ; 1-1 mapping for scaling



;------------------------------------------------------------------------------
; Process put mask transformed using similar code to the above.
;------------------------------------------------------------------------------

sprite_mask ROUT
        Push    "R0-R1,R3-R4,R6-R9,LR"

        MOV     r1, #disabled_vdu
        BL      gcol_lookupbg
        MOV     r0, r1
        BL      setbackground_colour
        STRVS   r0, [stack]
        Pull    "r0, r1, r3, r4, r6-r9, pc", VS

        Pull    "r0, r1"
        MOV     r7, #1                 ; dummy translation table
        MOV     r9, #SpriteReason_PlotMaskTransformed
        B       sprite_put_altentry

       [ Medusa

; Subroutine to generate a ColourTrans translation table suitable for
; mapping from a 16/32bpp truecolour sprite onto 256 grey levels.
; The table is generated in the RMA, and its address is stored in
; the four-word anchor block 'colourtrans32K'
;
; Returns the address of the anchor block in R7

sprite_makemono32Ktable
        Push    "R0-R5,LR"

        [ debugMedusa
        SWI     XOS_ReadMonotonicTime
        Debug   Medusa, "** Start time ", R0
        ]


        ADRL    R3, colourtrans32K              ; check to see if fake table has already been allocated
        LDR     R4, [R3, #4]                    ; must load into R4 - expected at end of code block
        CMP     R4, #0
        BNE     colourtrans32K_monoallocated


        MOV     R0, #ModHandReason_Claim        ; allocate space for fake colour  trans table
        MOV     R3, #32 * 1024
        SWI     XOS_Module
        MOVVC   R4, R2                          ; get ptr into R4
        STRVS   R0, [SP]
        Pull    "R0-R5,PC",VS

colourtrans32K_monoallocated
	Debug	Colour, "colourtrans32K_monoallocated"
        ADRL    R0, colourtrans32K              ; check to see if previously allocated was for this type
        LDR     R1, [R0, #12]
        CMP     R1, #1
        BEQ     colourtrans32K_monodefined

        ADRL    R0, colourtrans32K              ; set the table type to match that about to be created
        MOV     R1, #1
        STR     R1, [R0, #12]

        MOV     R0, #1 :SHL: 15
        SUB     R0, R0, #1                      ; 2_11111 11111 11111
        MOV     R5, #2_11111000
00
        AND     R3, R5, R0, LSL #3
        ORR     R3, R3, R3, LSR #5
        AND     R2, R5, R0, LSR #2
        ORR     R2, R2, R2, LSR #5
        AND     R1, R5, R0, LSR #7
        ORR     R1, R1, R1, LSR #5
        BL      colour_rgbcomponentstogray      ; R1 gets gray level (0-255)
        Push    "R0"
        MOV     R0,R1,LSL #24
        ORR     R0,R0,R1,LSL #16
        ORR     R0,R0,R1,LSL #8                 ; R0 = grey as &BBGGRR00
        BL      colour_rgbtopixval              ; R0 -> pixel value
        MOV     R1,R0
        Pull    "R0"
        STRB    R1, [R4, R0]                    ; put it in the table
        SUBS    R0, R0, #1
        BPL     %BT00

colourtrans32K_monodefined
        ADRL    R7, colourtrans32K
        MOV     R1, R7
        ADRL    R2, thirtytwok
        LDR     R2, [R2]
        STR     R2, [R1], #4
        STR     R4, [R1], #4
        STR     R2, [R1]                        ;REMEBER THAT [colourtans32K, #12] contains table type

        [ debugMedusa
        SWI     XOS_ReadMonotonicTime
        Debuga  Medusa, "** End time ", R0
        Debug   Medusa, " addresses: anchor, table = ", R7, R4
        ]
        Pull    "R0-R5,PC"

; Subroutine to generate a ColourTrans translation table suitable for
; mapping from a 16/32bpp truecolour sprite onto 256 colour levels.
; The table is generated in the RMA, and its address is stored in
; the four-word anchor block 'colourtrans32K'
;
; Returns the address of the anchor block in R7
; routine to allocate colour table via select_table
sprite_make256c32Ktable
        EntryS  "R0-R5"

        [ debugMedusa
        SWI     XOS_ReadMonotonicTime
        Debug   Medusa, "** Start time ", R0
        ]

        ADRL    R3, colourtrans32K              ; check to see if fake table has already been allocated
        LDR     R4, [R3, #4]                    ; must load into R4 'cos this is where address is expected
        CMP     R4, #0
        BNE     colourtrans32K_256callocated

        MOV     R0, #ModHandReason_Claim
        MOV     R3, #32 * 1024
        SWI     XOS_Module                      ; allocate memory for fake table
        MOVVC   R4, R2
        STRVS   R0, [SP,#Proc_RegOffset]
        EXIT    VS

colourtrans32K_256callocated
	Debug	Colour, "colourtrans32K_256callocated"
        ADRL    R0, colourtrans32K              ; check to see if previously allocated was for this type
        LDR     R1, [R0, #12]
        CMP     R1, #2

        BEQ     colourtrans32K_256cdefined

        ADRL    R0, colourtrans32K              ; set the table type to match that about to be created
        MOV     R1, #2
        STR     R1, [R0, #12]

        MOV     R0, #1 :SHL: 15
        SUB     R0, R0, #1                      ; 2_11111 11111 11111
        MOV     R5, #2_11111000
00

        AND     R3, R5, R0, LSL #3
        ORR     R3, R3, R3, LSR #5
        AND     R2, R5, R0, LSR #2
        ORR     R2, R2, R2, LSR #5
        AND     R1, R5, R0, LSR #7
        ORR     R1, R1, R1, LSR #5

; routine to transfer R G B into register as BBGGRR00, for call to rgbtopixval

        Push    "R0"

        ORR     R1, R2, R1, LSL #8
        ORR     R1, R3, R1, LSL #8
        MOV     R0, R1, LSL #8

        BL      colour_rgbtopixval
        MOV     R1, R0
        Pull    "R0"

        STRB    R1, [R4, R0]                    ; put it in the table
        SUBS    R0, R0, #1
        BPL     %BT00

colourtrans32K_256cdefined

        ADRL    R7, colourtrans32K
        MOV     R1, R7
        ADRL    R2, thirtytwok
        LDR     R2, [R2]
        STR     R2, [R1], #4
        STR     R4, [R1], #4
        STR     R2, [R1]

        [ debugMedusa
        SWI     XOS_ReadMonotonicTime
        Debuga  Medusa, "** End time ", R0
        Debug   Medusa, " addresses: anchor, table = ", R7, R4
        ]
        EXITS


; Subroutine to clear the ColourTrans translation table anchor block
sprite_clear32Ktable
        Push    "R1,R4,LR"
        ADRL    R1, colourtrans32K
        MOV     R4, #0
        STR     R4, [R1, #4]            ; set pointer to block == NULL
        MOV     R4, #0
        STR     R4, [R1, #12]           ; set table type to empty
        LDR     R4, [R1, #4]

        Pull    "R1,R4,PC"

; Subroutine to free the ColourTrans translation table if allocated

sprite_free32Ktable
        Push    "R0-R2,LR"
        ADRL     R1, colourtrans32K
        LDR     R2, [R1, #4]
        TEQ     R2, #0
        Pull    "R0-R2,PC", EQ
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
        STRVS   R0, [SP]
        MOV     R2, #0
        STR     R2, [R1, #4]            ;set pointer to block == NULL
        MOV     R2, #0
        STR     R2, [R1, #12]           ; set table type to empty
        Pull    "R0-R2,PC"

thirtytwok
        = "32K."

        ]
        END
@


4.8
log
@Update SpriteOp support, loosen/tighten some checks
Core/Header.s,Core/SWIs.s,Core/Constants.s: Define a new bad pointer rather than using &80000000 since that's now a perfectly valid logical address to have.
Core/Device.s, Core/Sprite.s, PDriverDP/Sprite.s, PDriverPS/Sprite.s: Delete support for the greyscale SpriteOp plots, these were removed from SpriteExtend in 1993. Just error them now. Extend the table of SpriteOps to include letting through TileSpriteScaled.
PDriverDP/Transprite.s: Allow 0 or -1 to mean "has no translation table" in line with PDriverPS and SpriteExtend.
PDriverPS/Sprite.s, PDriverPS/TranSprite.s: Use define instead of magic numbers.

Version 4.62. Tagged as 'PDModules-4_62'
@
text
@d88 6
a93 3
        MOV     LR, R6, LSR #27         ; XOS_SpriteOp return sprite type in top bits of R6
        TEQ     LR, #SpriteType_New16bpp
        TEQNE   LR, #SpriteType_New32bpp
d376 1
a376 1
; rotuine to allocate colour table via select_table
@


4.7
log
@Some PDModule tidy ups
Core/FontSWI.s & PDriverDP/Font.s:
 The pointer compares are now unsigned, so raise the limit for printing strings in top bit set addresses when no length is passed in R7.
 Couple of comment typos.
Core/Header.s:
 A CVS merge mistake left behind two copies of Push/return sequence.
Core/PDriver.s:
 Unused VersionString removed.
PDriverDP/Macros.s & PDriverDP/ManageJob.s:
 Single use unhelpful debug message removed.
PDriverDP/Private2.s & Sprite.s & TranSprite.s:
 Use some of the defines from Hdr:Sprite.
Makefile:
 For ROMming, explicitly state there's no resources phase
PDriverDP/PageBox.s:
 Unjumble the set_sprite_output_state data. The MonoBufferOK and Libra1 switch happen to work when both are {TRUE} but other combinations would output a silly table. Let ObjAsm work out the size instead.

Tested briefly, still printed OK.

Version 4.59. Tagged as 'PDModules-4_59'
@
text
@a42 1
sprite_greyscaled ; no sensible implementation for PrinterDrivers (so simply scale)
@


4.6
log
@Fix for the thingy which sits on SpriteV,it got optimised sometime round
2000 which led to it getting the "redirected to sprite" switch in a
muddle so printing from some apps ended up on the screen not in the
postscript file.
Changed the "%%Creator" string a bit.
Took the opportunity to eliminate all the signed pointer comparisons.
Tightened up the checking of pointers to palettes and translation tables
so that "0 or -1" means to use the default,not <= 0.

Version 4.50. Tagged as 'PDModules-4_50'
@
text
@d90 3
a92 4
        AND     LR, LR, #31
        TEQ     LR, #5                  ; is sprite a 16bpp
        TEQNE   LR, #6                  ; or 32bpp ????
        BNE     %FT02                   ; if it isn't then we don't need to make fake colourtrans tables
@


4.5
log
@Changed to use objasm to avoid any LDR rN,[rN],#0 problems
Changed to use shared Makefiles
Numerous small 32 bit conversion improvements
Bugfix to PDriverPS,it was pulling LR not PC - this has been the case for
many years so not sure how it ever worked.
Due to a bug in objasm 3.27 this checkin will infact not build directly.
You must first
 - rename the PDriverDP dir to PDriverDP2
 - rename the PDriverPS dir to PDriverPS2
 - move the 2 source files of the same name up a directory
checked in in this way to minimise messing in CVS.

Version 4.47. Tagged as 'PDModules-4_47'
@
text
@d30 1
a30 1
;                               R6 <= 0 no scaling, or points to 4 scaling factors
d32 1
a32 1
;                               R7 <= 0 no translation, or points to translation table.
d74 2
a75 2
        CMP     R6,#0                   ; any scaling being performed?
        ADRLE   R6,nullscale            ;   no, so address a default scale block
d209 2
a210 2
        CMP     R7,#0                   ; has a translation table been specified?
        BGT     %FT01                   ;   yes, so no need to generate one
@


4.4
log
@  Merge of 32-bit branch.
Detail:
  These modules are now thought to work.
Admin:
  This module has received some testing of both 26-bit and 32-bit
    builds and is believed to function correctly.

Version 4.45. Tagged as 'PDModules-4_45'
@
text
@d44 1
a44 1
sprite_put ENTRY "R3,R4,R6-R9"
d67 6
a72 5
        MOVLT   R0,#3
        SWILT   XOS_ReadDynamicArea     ; read the address of the system sprite pool
        MOVLT   R1,R0                   ;   and then move to CBptr

; R0 has been corrupt!
@


4.3
log
@Spinner branch merged
@
text
@d25 1
a25 1
;                               R3 = X co-ordinate relative to bottom left of 
d31 1
a31 1
;                                       (x-mag, y-mag, x-div, y-div)                                                                     
d33 1
a33 1
;       
d45 1
a45 1
           
d65 1
a65 1
       
d70 1
a70 1
                      
d75 1
a75 1
                
d77 1
a77 1
                      
d86 1
a86 1
        
d93 1
a93 1
        
d107 1
a107 1
        
d117 1
a117 1
        MUL     R0,R8,R0  
d127 1
a127 1
        TEQ     R2, #0                  ; if divisor->0 then 
d152 1
a152 1
        TEQ     R2, #0                  ; if divisor->0 then 
d163 1
a163 1
        
d165 2
a166 2
        Debug   Sprite,"Top right co-ordinates",R3,R4        
 
d171 1
a171 1
      
d177 1
a177 1
        
d189 1
a189 1
        Pull    "R1,R3,R4"  
d205 1
a205 1
                               
d210 1
a210 1
 
d212 2
a213 2
        MOV     R0,#-1                  ; translate from current to current mode 
        MOV     R1,#-1                  ;   this is intercepted by the printer 
d220 1
a220 1
        STRVS   R0,[SP]     
d224 1
a224 1
        ADRL    R7,job_spritetrans      
d235 1
a235 1
99 
d246 1
a246 1
scale_r3r4 ENTRY 
d287 1
a287 1
                
d303 2
a304 2
        ]  
    
d310 1
a310 1
        
d329 1
a329 1
        
d347 1
a347 1
        Pull    "R0"       
d352 1
a352 1
colourtrans32K_monodefined        
d376 2
a377 2
        Push    "R0-R5,LR"
        
d391 4
a394 4
        MOVVC   R4, R2 
        STRVS   R0, [SP]
        Pull    "R0-R5,PC",VS 
        
d399 1
a399 1
        CMP     R1, #2 
d406 1
a406 1
        
d411 1
a411 1
     
d422 1
a422 1
        
d426 1
a426 1
       
d430 1
a430 1
       
d443 1
a443 1
        STR     R2, [R1] 
d450 1
a450 1
        Pull    "R0-R5,PC",AL,^
d460 1
a460 1
        STR     R4, [R1, #12]           ; set table type to empty 
@


4.3.2.1
log
@  First attempt at 32-bit compatible modules.
Admin:
  Tested that modules build 26-bit and 32-bit.
  Requires HdrSrc-1_05 or later.

Version 4.44, 4.1.2.1. Tagged as 'PDModules-4_44-4_1_2_1'
@
text
@d25 1
a25 1
;                               R3 = X co-ordinate relative to bottom left of
d31 1
a31 1
;                                       (x-mag, y-mag, x-div, y-div)
d33 1
a33 1
;
d45 1
a45 1

d65 1
a65 1

d70 1
a70 1

d75 1
a75 1

d77 1
a77 1

d86 1
a86 1

d93 1
a93 1

d107 1
a107 1

d117 1
a117 1
        MUL     R0,R8,R0
d127 1
a127 1
        TEQ     R2, #0                  ; if divisor->0 then
d152 1
a152 1
        TEQ     R2, #0                  ; if divisor->0 then
d163 1
a163 1

d165 2
a166 2
        Debug   Sprite,"Top right co-ordinates",R3,R4

d171 1
a171 1

d177 1
a177 1

d189 1
a189 1
        Pull    "R1,R3,R4"
d205 1
a205 1

d210 1
a210 1

d212 2
a213 2
        MOV     R0,#-1                  ; translate from current to current mode
        MOV     R1,#-1                  ;   this is intercepted by the printer
d220 1
a220 1
        STRVS   R0,[SP]
d224 1
a224 1
        ADRL    R7,job_spritetrans
d235 1
a235 1
99
d246 1
a246 1
scale_r3r4 EntryS
d287 1
a287 1

d303 2
a304 2
        ]

d310 1
a310 1

d329 1
a329 1

d347 1
a347 1
        Pull    "R0"
d352 1
a352 1
colourtrans32K_monodefined
d376 2
a377 2
        EntryS  "R0-R5"

d391 4
a394 4
        MOVVC   R4, R2
        STRVS   R0, [SP,#Proc_RegOffset]
        EXIT    VS

d399 1
a399 1
        CMP     R1, #2
d406 1
a406 1

d411 1
a411 1

d422 1
a422 1

d426 1
a426 1

d430 1
a430 1

d443 1
a443 1
        STR     R2, [R1]
d450 1
a450 1
        EXITS
d460 1
a460 1
        STR     R4, [R1, #12]           ; set table type to empty
@


4.2
log
@Version Spin_merge taken
@
text
@d320 1
a320 1

d396 1
a396 1

@


4.1
log
@Initial revision
@
text
@d206 1
a206 1
        ADR     R6,job_spritescale      ; -> new sprite scaling table
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d206 1
a206 1
        ADRL    R6,job_spritescale      ; -> new sprite scaling table
@


4.1.7.2
log
@   Use buffer in workspace for MessageTrans.
   Added 'Colour' debugging flag.
   Do not pass SpriteV calls to pdriver if a Wimp error box is open.
@
text
@d320 1
a320 1
	Debug	Colour, "colourtrans32K_monoallocated"
d396 1
a396 1
	Debug	Colour, "colourtrans32K_256callocated"
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d206 1
a206 1
        ADRL    R6,job_spritescale      ; -> new sprite scaling table
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d206 1
a206 1
        ADRL    R6,job_spritescale      ; -> new sprite scaling table
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.7;
access;
symbols
	PDModules-4_64:4.7
	PDModules-4_63:4.7
	PDModules-4_62:4.7
	PDModules-4_61:4.7
	PDModules-4_60:4.7
	PDModules-4_59:4.7
	PDModules-4_58:4.6
	PDModules-4_57:4.6
	PDModules-4_56:4.6
	PDModules-4_55:4.6
	PDModules-4_54:4.6
	PDModules-4_53:4.6
	PDModules-4_52:4.6
	PDModules-4_51:4.6
	PDModules-4_50:4.5
	PDModules-4_49:4.4
	PDModules-4_48:4.4
	PDModules-4_47:4.4
	PDModules-4_46:4.3
	kbracey_32bit_merge:4.2.2.7
	PDModules-4_45:4.3
	PDModules-4_44-4_1_2_7:4.2.2.7
	PDModules-4_44-4_1_2_6:4.2.2.6
	PDModules-4_44-4_1_2_5:4.2.2.5
	PDModules-4_44-4_1_2_4:4.2.2.4
	PDModules-4_44-4_1_2_3:4.2.2.3
	PDModules-4_44-4_1_2_2:4.2.2.2
	PDModules-4_44-4_1_2_1:4.2.2.1
	kbracey_32bit:4.2.0.2
	kbracey_32bit_bp:4.2
	dellis_autobuild_BaseSW:4.2
	Ursula_merge:4.1.7.2
	PDModules-4_44:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.2
	Ursula_RiscPC:4.1.7.2.0.4
	rthornb_UrsulaBuild-19Aug1998:4.1.7.2
	UrsulaBuild_FinalSoftload:4.1.7.2
	rthornb_UrsulaBuild-12Aug1998:4.1.7.2
	aglover_UrsulaBuild-05Aug1998:4.1.7.2
	rthornb_UrsulaBuild-29Jul1998:4.1.7.2
	rthornb_UrsulaBuild-22Jul1998:4.1.7.2
	hsimons_BOCA-1_2-Release:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.1.7.2
	rthornb_UrsulaBuild-07Jul1998:4.1.7.2
	rthornb_UrsulaBuild-17Jun1998:4.1.7.2
	rthornb_UrsulaBuild-03Jun1998:4.1.7.2
	rthornb_UrsulaBuild-27May1998:4.1.7.2
	rthornb_UrsulaBuild-21May1998:4.1.7.2
	rthornb_UrsulaBuild_01May1998:4.1.7.2
	afrost_NC2_Generic:4.1.7.2
	afrost_Funai01-33:4.1.7.2
	Ursula:4.1.7.2.0.2
	Ursula_bp:4.1.7.2
	Ursula_31Mar1998:4.2
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spin_merge_28May97:4.1.7.1
	Spinner_B10:4.1.7.1
	Spin_merge_16May97:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2014.10.20.21.53.05;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	kYvwc1FHitWAiZUx;

4.6
date	2003.07.11.18.10.21;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2003.03.10.11.33.28;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2002.12.05.20.45.09;	author srevill;	state Exp;
branches;
next	4.3;

4.3
date	2001.01.09.13.59.39;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.07.45;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.48.38;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.10.18.11.32.02;	author sbrodie;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2000.11.24.13.27.32;	author sbrodie;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2000.11.30.12.13.39;	author sbrodie;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	2000.12.04.10.18.04;	author sbrodie;	state Exp;
branches;
next	4.2.2.5;

4.2.2.5
date	2000.12.04.10.28.48;	author sbrodie;	state Exp;
branches;
next	4.2.2.6;

4.2.2.6
date	2001.01.05.12.16.27;	author dellis;	state Exp;
branches;
next	4.2.2.7;

4.2.2.7
date	2001.01.05.12.47.34;	author dellis;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.48.38;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.05.12;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.27.35;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.31.16;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.07.09.15.31.12;	author arodger;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Some PDModule tidy ups
Core/FontSWI.s & PDriverDP/Font.s:
 The pointer compares are now unsigned, so raise the limit for printing strings in top bit set addresses when no length is passed in R7.
 Couple of comment typos.
Core/Header.s:
 A CVS merge mistake left behind two copies of Push/return sequence.
Core/PDriver.s:
 Unused VersionString removed.
PDriverDP/Macros.s & PDriverDP/ManageJob.s:
 Single use unhelpful debug message removed.
PDriverDP/Private2.s & Sprite.s & TranSprite.s:
 Use some of the defines from Hdr:Sprite.
Makefile:
 For ROMming, explicitly state there's no resources phase
PDriverDP/PageBox.s:
 Unjumble the set_sprite_output_state data. The MonoBufferOK and Libra1 switch happen to work when both are {TRUE} but other combinations would output a silly table. Let ObjAsm work out the size instead.

Tested briefly, still printed OK.

Version 4.59. Tagged as 'PDModules-4_59'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.PDriverDP.Private2


; *************************************************************
; Coordinate scaling
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

YScale ROUT          ; apply currentYscale to r0
           Push  "r1, lr"
           BL     times_currYs
           B      %FT01

XScale               ; apply currentXscale to r0
           Push  "r1, lr"
           BL     times_currXs
01         MOV    r1, #180
           BL     Divide
           Pull  "r1, pc"

;; The old versions of these routines were incorrect!
;; The mantissa (lower 16 bits) of currentXscale can easily be &8000,
;; in which case, since r0 can be > &8000, overflow occurs.
;; The solution is to split r0 itself into 2 when calculating the mantissa.
;;
;; if    r0 = (x_hi << 16) + x_lo
;;    scale = y_hi + (y_lo >> 16)
;; answer := (((x_hi << 16) + x_lo) * (y_hi + (y_lo >> 16))
;;         = (x_hi*y_hi << 16) + x_hi*y_lo + x_lo*y_hi + (x_lo*y_lo >> 16)
;;
;; Note that x_hi and y_hi must be sign-extended.

;; times_currXs ROUT             ; times_currYs was similar
;;           Push  "r1, lr"
;;           LDR    r1, job_currentXscale
;;           MOV    lr, r1, LSR #16
;;           BIC    r1, r1, lr, LSL #16
;;           MUL    r1, r0, r1        ; low part of answer
;;           MOV    r1, r1, LSR #16   ; scaled back down
;;           MLA    r0, lr, r0, r1    ; X coord * current scale
;;           MOV    r0, r0, LSL #bufferpix_l2size
;;           Pull  "r1, pc"

times_currXs ROUT
           Push  "r1-r3, lr"

           LDR    r1, job_currentXscale
           MOV    r2, r1, ASR #16       ; r2 = scale_hi
           BIC    r1, r1, r2, LSL #16   ; r1 = scale_lo
           MOV    r3, r0, ASR #16       ; r3 = input_hi
           BIC    r0, r0, r3, LSL #16   ; r0 = input_lo

           MUL    lr, r2, r0            ; lr = scale_hi * input_lo
           MLA    lr, r1, r3, lr        ; lr = scale_lo * input_hi + lr
           MUL    r0, r1, r0            ; r0 = scale_lo * input_lo
           MUL    r1, r2, r3            ; r1 = scale_hi * input_hi

           ADD    r0, lr, r0, LSR #16
           ADD    r0, r0, r1, LSL #16   ; r0 = answer!

           MOV    r0, r0, LSL #bufferpix_l2size
           Pull  "r1-r3, pc"

times_currYs ROUT
           Push  "r1-r3, lr"

           LDR    r1, job_currentYscale
           MOV    r2, r1, ASR #16       ; r2 = scale_hi (signed)
           BIC    r1, r1, r2, LSL #16   ; r1 = scale_lo
           MOV    r3, r0, ASR #16       ; r3 = input_hi (signed)
           BIC    r0, r0, r3, LSL #16   ; r0 = input_lo

           MUL    lr, r2, r0            ; lr = scale_hi * input_lo
           MLA    lr, r1, r3, lr        ; lr = scale_lo * input_hi + lr
           MUL    r0, r1, r0            ; r0 = scale_lo * input_lo
           MUL    r1, r2, r3            ; r1 = scale_hi * input_hi

           ADD    r0, lr, r0, LSR #16
           ADD    r0, r0, r1, LSL #16   ; r0 = answer!

           MOV    r0, r0, LSL #bufferpix_l2size
           Pull  "r1-r3, pc"

;.............................................................................

Divide     ROUT      ; r0:= r0/r1, sign of r0 noted
           Push   "r1-r3, lr"
           MOVS    lr, r0
           RSBMI   r0, r0, #1

         [ debugPrivate
           CMP     r1,#0
           BNE     %FT80
           Debug   ,"****Division by zero"
80
         ]
           ADD     r0, r0, r1, LSR #1      ; rounded division
           DivRem  r2, r0, r1, r3
           CMP     lr, #0
           RSBMI   r0, r2, #0
           MOVPL   r0, r2
           Pull   "r1-r3, pc"

; swap output to the sprite at the start of the job_currentbuffer sprite area

redirect_output ROUT
         Push   "r0-r3, lr"

  ; need to get redirection params in sprite pointer form for
  ; recognition by main code

         LDR     r2, job_currentbuffer

  ; can't call get_sprite_address as we need r1 on exit as well!

         LDR       r1, job_spritearea
       [ debugPrivate
         CMP       r1, #-1
         BNE       %FT80
         Debug     Private,"*********** redirect_output: no sprite area !!!"
80
       ]
         CMP      r1, #0
         BNE      %FT82
         MOV      r0, #3
         SWI      XOS_ReadDynamicArea
         MOV      r1, r0
82
         LDR      r0, =SpriteReason_SelectSprite+256
         BL       pass_spriteop

         BVS      %FT99

         Debuga   Private,"swap output to sprite area @@",R1

         LDR      r0, =SpriteReason_SwitchOutputToSprite+512
         LDR      r3, job_VDUsavearea

       [ debugPrivate
         Debug   ,", save area",R3
         LDR     LR,[R3]
         Debug   ,", first word",LR
         LDR     LR,job_savedVDUstate
         CMP     LR,#0
         BEQ     %FT80
         Debug   ,"** output already redirected"
80
       ]
         ADR     lr, jobspriteparams
         STMIA   lr, {r0-r3}
         BL      pass_spriteop

         ADRVC   lr, job_savedVDUstate
         STMVCIA lr, {r0-r3}

         MOVVC   r0, #5
         BLVC    vdu_char

;; we must invalidate ColourTrans's cache, as output bitmap is changing
;; (also done in PDriverDP.ManageJob: restore_output_state)

         SWIVC   XColourTrans_InvalidateCache   ;; ADDED BY NRAINE

99       STRVS   r0, [stack]
         Pull   "r0-r3, pc"

myspriteop
         LDR     r1, job_spritearea
         CMP     r1, #-1
       [ debugPrivate
         BNE     %FT80
         Debug   ,"*** myspriteop: no sprite area"
80
       ]
         MOVEQ   pc, lr                 ; not yet allocated
         TEQ     r1, #0
         ADDNE   r0, r0, #256

pass_spriteop
         Push   "r11, lr"
         ASSERT :BASE: passthrough = 12

         LDRB    r11, passthrough
         ORR     lr, r11, #passthrough_spr
         STRB    lr, passthrough
         SWI     XOS_SpriteOp             ; redirect output

         STRB    r11, passthrough
         Pull   "r11, pc"


; find a name in the current sprite area not in use, create it

fourzeros   = "0000"

create_buffer_sprite
        Push    "r2, r3, r6, lr"
        LDR      lr, fourzeros
        STR      lr, [r2]
        STR      lr, [r2, #4]
        STR      lr, [r2, #8]
02      BL       get_sprite_address
        BVS      %FT01                ; doesn't exist: can use this name
        LDR      r2, [stack]
03      LDRB     lr, [r2]
        ADD      lr, lr, #1
        CMP      lr, #"9"+1
        MOVEQ    lr, #"0"
        STRB     lr, [r2], #1
        BEQ      %BT03
        LDR      r2, [stack]
        B        %BT02

01      MOV      r0, #SpriteReason_CreateSprite
        MOV      r3, #0

    [ MonoBufferOK
      [ NbppBufferOK
        LDRB     r6, job_output_bpp
        CMP      r6, #8
      |
        LDRB     r6, job_use_1bpp
        CMP      r6, #0
      ]
        MOVEQ    r6, #21               ; a square pixel 256 colour mode
        MOVNE    r6, #18               ; a square pixel mono mode
    |
        MOV      r6, #21               ; a square pixel 256 colour mode
    ]
        [ Libra1
        Push    "R0"
        LDRB    R0, job_strip_type
        CMP     R0, #4                 ; if output sprite strip = 16bpp
        MOVEQ   R0, #SpriteType_New16bpp
        BEQ     %FT05
        CMP     R0, #5                 ; if output sprite strip = 32bpp
        MOVEQ   R0, #SpriteType_New32bpp
05
        MOVEQ   R6, R0, LSL #27        ; spritetype
        MOVEQ   r0, #90
        ORREQ   R6, R6, R0, LSL #14    ; Vdpi = 90
        ORREQ   R6, R6, R0, LSL #1     ; Hdpi = 90
        ORREQ   R6, R6, #1             ; distringuishing bit
        Pull    "R0"
        ]
    [ debugPrivate
      LDRB   lr, [r2, #12]
      STRB   r3, [r2, #12]
      Debuga  ,"Create sprite ",R2
      STRB   lr, [r2, #12]
      Debuga ,", width",r4
      Debug  ,", height",r5
    ]

        BL       myspriteop

;We have now created the sprite, for ColourTrans 0.90+ we need to add
;a palette block in for this.  We use the sprite reason to create
;one, space will already have been allocated for this.
        [ Libra1
        BVS     %FT01
        LDRB    LR, job_strip_type
        CMP     LR, #4
        CMPNE   LR, #5
        MOVNE   R0, #SpriteReason_CreateRemovePalette
        MOVNE   R3, #&100
        BLNE    myspriteop              ; Attempt to append a suitable palette
01
        |
        MOVVC   R0, #SpriteReason_CreateRemovePalette
        MOVVC   R3, #&100
        BLVC    myspriteop              ; Attempt to append a suitable palette

        ]
        Pull    "r2, r3, r6, pc"

; get the address of the named sprite in the current spritearea

get_sprite_address ROUT
        Push     "r0, r1, lr"
        LDR       r1, job_spritearea
      [ debugPrivate
        CMP       r1, #-1
        BNE       %FT80
        Debug     ,"*** no sprite area"
80
      ]
        CMP       r1, #0
        BNE       %FT82
        MOV       r0, #3
        SWI       XOS_ReadDynamicArea
        MOV       r1, r0
82        
        LDR       r0, =SpriteReason_SelectSprite+256
        BL        pass_spriteop
        STRVS     r0, [stack]
        Pull     "r0, r1, pc"

; transform a point in the current rectangle space

transform_point ROUT
        Push  "r0-r3, r7, lr"

  ; transform coordinates with matrix
        LDR    r7, recttransform
        BL     full_signed_multiply
        Push  "r0, r1"
        LDR    r0, [stack, #12]
        LDR    r7, recttransform+8
        BLVC   full_signed_multiply
        Pull  "r2, r3"
        Pull  "r0-r3, r7, pc",VS
        ADDS   r1, r1, r3
        ADCS   r0, r0, r2              ; r0 is new x coordinate, OS units*2^16
        Pull  "r0-r3, r7, pc",VS

 ;  convert to 1/72000 inch from OS coordinates:
 ; i.e. multiply by 72000/180 = 400
 ; but coordinates are currently 2^16 too big
 ; so shift down 12 and multiply by &19

        MOV    r2, r1, LSR #8
        ADDS   r2, r2, r0, LSL #24     ; r2 := r0,r1 >>8
        ADDVCS r2, r2, r1, LSR #9
        ADDVCS r2, r2, r0, LSL #23     ; += r0,r1 >>9
        ADDVCS r2, r2, r1, LSR #12
        ADDVCS r2, r2, r0, LSL #20     ; += r0,r1 >>12
        Pull  "r0-r3, r7, pc",VS
        LDR    r0, [stack]
        STR    r2, [stack]

 ; repeat for Y coordinate
        LDR    r7, recttransform+4
        BL     full_signed_multiply
        Push  "r0, r1"
        LDR    r0, [stack, #12]
        LDR    r7, recttransform+12
        BL     full_signed_multiply
        Pull  "r2, r3"
        Pull  "r0-r3, r7, pc",VS
        ADDS   r1, r1, r3
        ADCS   r0, r0, r2              ; r0 is new y coordinate, OS units*2^16
        Pull  "r0-r3, r7, pc",VS

        MOV    r2, r1, LSR #8
        ADDS   r2, r2, r0, LSL #24     ; r2 := r0,r1 >>8
        ADDVCS r2, r2, r1, LSR #9
        ADDVCS r2, r2, r0, LSL #23     ; += r0,r1 >>9
        ADDVCS r2, r2, r1, LSR #12
        ADDVCS r2, r2, r0, LSL #20     ; += r0,r1 >>12
        STR    r2, [stack, #4]
        Pull  "r0-r3, r7, pc"

; update the visible area limits in job_print_area

update_limits ROUT
        Push "lr"

        Debuga Private,"update_limits with coords",R0
        Debug  Private,",",R1

 ;  clip against the current area

        LDR   lr, job_print_area
        CMP   lr, r0
        STRGT r0, job_print_area
        LDR   lr, job_print_area+8
        CMP   lr, r0
        STRLT r0, job_print_area+8

 ; repeat for Y coordinate

        LDR   lr, job_print_area+4
        CMP   lr, r1
        STRGT r1, job_print_area+4
        LDR   lr, job_print_area+12
        CMP   lr, r1
        STRLT r1, job_print_area+12

        Pull  "pc"
        LTORG

full_signed_multiply ROUT
        Push "lr"
        CMP   r7, #0
        RSBMI r7, r7, #0
        BL    full_multiply
        Pull "pc",VS
        Pull "pc",PL
        RSBS  r1, r1, #0
        RSC   r0, r0, #0
        RSB   r7, r7, #0
        Pull "pc"

; free a buffer sprite: pointer to name in R0

losebuffersprite ROUT
         Push "r0-r2, lr"
         MOV   r2, r0
         MOV   r0, #SpriteReason_DeleteSprite
         BL    myspriteop
         Pull "r0-r2, pc"


; routines to go with the vdu_ stuff in the main file

; send 2 bytes from r0

vdu_pair
     Push "r0, lr"
     BL    vdu_char
     MOVVC r0, r0, LSR #8
     BLVC  vdu_char
     STRVS r0, [stack]
     Pull "r0, pc"

; send a counted string @@ r0

vdu_counted_string
    Push   "r0, r1, lr"
    LDRB    r1, [r0], #1
    BL      vdu_stringN
    STRVS   r0, [stack]
    Pull   "r0, r1, pc"


; do a 64 bit multiply where one of the operands may be negative.
; In: r7, known to be positive
;     r0, may be negative
; Out: r0, r1 contain r7*r0 (hi, lo)

full_multiply ROUT
    Push   "r0, r7, r8, r9, lr"
    SavePSR r9                      ; need to preserve entry flags except V
    BICVS   r9, r9, #V_bit
    CMP     r0, #0
    RSBMI   r0, r0, #0

    MOV     lr, r7, LSR #16         ; Ah
    BIC     r7, r7, lr, LSL #16     ; Al
    MOV     r8, r0, LSR #16         ; Bh
    BIC     r0, r0, r8, LSL #16     ; Bl: now got all the halfwords

    MUL     r1, r0, r7              ; low word: Al*Bl
    MUL     r7, r8, r7              ; intermediate: Al*Bh
    MUL     r0, lr, r0              ; intermediate: Ah*Bl
    MUL     r8, lr, r8              ; high: Ah*Bh

    ADDS    r1, r1, r0, LSL #16
    ADCS    r0, r8, r0, LSR #16
    ORRVS   r9, r9, #V_bit
    ADDS    r1, r1, r7, LSL #16
    ADCS    r0, r0, r7, LSR #16
    ORRVS   r9, r9, #V_bit

    Pull   "r7"

    CMP     r7, #0
    BPL     %FT99

    RSBS    r1, r1, #0
    RSC     r0, r0, #0
99
    RestPSR r9,,f
    Pull   "r7, r8, r9, pc"

; extended precision division: take 64 bit number in r0(high), r1(low),
; and return that divided by the 32 bit number in r2

extended_divide ROUT
    EntryS  "r0-r7"
    MOV     r1, r2
    ASSERT (Proc_RegOffset = 4) :LOR: (Proc_RegOffset = 0)
  [ Proc_RegOffset = 4
    LDMIB   stack,{r2, r3}
  |
    LDMIA   stack,{r2, r3}
  ]
    CMP     r2, #0
    BPL     %FT10
    RSBS    r3, r3, #0
    RSC     r2, r2, #0
    B       %FT10

; routine used from pagebox_nextbox:
; return r0*2^16/r1

divide_and_scale
    ALTENTRY

    CMP     r0, #0
    RSBMI   r0, r0, #0

    MOV     r2, r0, LSR #16      ; high word of r0*2^16
    MOV     r3, r0, LSL #16      ; r2, r3 form 64 bit numerator (ra)

10                               ; alternate entry
    ADDS    r3, r3, r1, LSR #1   ; rounded division
    ADC     r2, r2, #0
    MOVS    r4, r1               ; rtemp = rb
  [ debugPrivate
    BNE     %FT80
    Debug   Private,"*** Extended divide by zero"
80
  ]
    MOV     r5, #0               ; r5, r4 are 64 bit rtemp

    MOVS    r6, r2, LSR #1       ; form ra>>1
    MOV     lr, r3, RRX

01  CMP     r5, r6               ; CMP rtemp, ra, LSR #1
    CMPEQ   r4, lr
    BHI     %FT02
    ADDS    r4, r4, r4
    ADC     r5, r5, r5           ; rtemp := rtemp LSL #1
    B       %BT01

02  MOV     r0, #0               ; the answer so far
03  SUBS    r7, r3, r4
    SBCS    r7, r2, r5
    ADC     r0, r0, r0
    BCC     %FT04
    SUBS    r3, r3, r4           ; SUB ra, ra, rtemp
    SBC     r2, r2, r5
04  MOVS    r5, r5, LSR #1
    MOV     r4, r4, RRX          ; rtemp := rtemp>>1
    SUBS    r7, r4, r1
    SBCS    r7, r5, #0           ; CMP rtemp, rb
    BCS     %BT03
    LDR     r1, [sp, #Proc_RegOffset + 0 * 4]
    CMP     r1, #0
    RSBMI   r0, r0, #0
    STR     r0, [sp, #Proc_RegOffset + 0 * 4]

    EXITS

; +++++++++++++++++++++++++++++++++++++++++
; Apply flips indicated by job_rotation_id
; +++++++++++++++++++++++++++++++++++++++++

flip_buffer ROUT
     Entry  "r0-r3"


     LDRB   lr, job_buffer_marked
     CMP    lr, #0

   [ debugPrivate
     BNE    %FT80
     Debug  ,"Skip flips - no point"
80
80
   ]
     EXIT   EQ

     BL     restore_output_state
     LDR    r2, job_currentbuffer
     LDRB   r3, job_rotation_id
     TST    r3, #2

   [ debugPrivate
     BEQ    %FT80
     Debug  ,"invert X coordinates"
80
   ]
     MOVNE  r0, #SpriteReason_FlipAboutYAxis  ; invert X coordinates
     BLNE   myspriteop
     BVS    %FT99
     TST    r3, #4
   [ debugPrivate
     BEQ    %FT81
     Debug  ,"invert Y coordinates"
81
   ]
     MOVNE  r0, #SpriteReason_FlipAboutXAxis  ; invert Y coordinates
     BLNE   myspriteop
     BLVC   redirect_output
99   STRVS  r0, [stack, #Proc_RegOffset]
     EXIT

; *****************************************************************************
;
;       SquareRoot - Calculate the square root of a 32-bit number
;         Adapted for use on radius calculations: given a 32-bit number,
;         return the square root of input*2^16
;           (i.e. answer scaled up by 8 places, i.e. scaled for Draw coord)
; in:   R7 = number to squareroot
; out:  R8 = result
;

SquareRoot ROUT
        EntryS  "r7, r9-r11"
        MOV     R11, #24                ; 24 bit result
        MOV     R8, #0                  ; result=0
        MOV     R10, #0                 ; sqdiff=0
10
        MOVS    R10, R10, LSL #2        ; C:=0 (we hope!) while doing (sqdiff,
        ORR     R10, R10, R7, LSR #30   ;   number) := (sqdiff, number) * 4
        MOV     R7, R7, LSL #2

        SBCS    R9, R10, R8, LSL #2     ; C=0 here, so try to subtract
                                        ; result*4 +1 from sqdiff
        MOVCS   R10, R9                 ; if successful then shift in a "1" bit
        ADC     R8, R8, R8              ; else shift in a "0" bit
        SUBS    R11, R11, #1            ; decrement loop counter
        BNE     %BT10
        EXITS

; *****************************************************************************
;
;  BigSquareRoot - Calculate the square root of a 64-bit number
; in:   R0,1 = number to squareroot
; out:    R0 = result
;

BigSquareRoot ROUT
        EntryS  "r5, r8-r12"

        Debuga  Private,"Square root of",R0
        Debuga  Private,"",R1

        MOV     r12, #32                ; 32 bit result
        MOV     r5, #0                  ; result=0
   ; r10,r11 form a 64-bit "sqdiff"
        MOV     r10, #0                 ; sqdiff(hi)=0
        MOV     r11, #0                 ; sqdiff(lo)=0
  ; r8, r9 form a temp 64 bit number
10
        MOVS    r10, r10, LSL #2        ; C:=0 (we hope!) while doing (sqdiff,
        ORR     r10, r10, r11, LSR #30   ;   number) := (sqdiff, number) * 4
        MOV     r11, r11, LSL #2
        ORR     r11, r11, r0, LSR #30
        MOV     r0, r0, LSL #2
        ORR     r0, r0, r1, LSR #30
        MOV     r1, r1, LSL #2

        SBCS    r9, r11, r5, LSL #2     ; C=0 here, so try to subtract
        SBCS    r8, r10, #0             ; result*4 +1 from sqdiff
        MOVCS   r10, r8                 ; if successful then shift in a "1" bit
        MOVCS   r11, r9
        ADC     r5, r5, r5              ; else shift in a "0" bit
        SUBS    r12, r12, #1            ; decrement loop counter
        BNE     %BT10

        MOV     r0, r5

        Debug   Private," yields",R0

        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; copy from one sprite (area) to another with 90 degree (anticlockwise)
; rotation.
; In:  r0 -> source sprite area
;      r1 -> dest sprite area
; and we know both sprites have the same shape, both are 256 colours
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

copysprite_withrotate ROUT
        EntryS  "r0-r7"

        LDRB    lr, job_buffer_marked
        CMP     lr, #0
        BNE     %FT20

        Debug   Private,"Skip rotation - no point"

; simply clearing the destination sprite will do

        LDR     r2, job_currentbuffer
        STR     r1, job_currentbuffer
        BL      redirect_output
        [ Libra1
        BL      set_sprite_background
        ]
        ADRL    r0, set_sprite_output_state
        BL      vdu_counted_string
        BL      restore_output_state
        STR     r2, job_currentbuffer
        EXIT

20      MOV     r2, r0
        BL      get_sprite_address
        MOV     r0, r2
        MOV     r2, r1
        BL      get_sprite_address
        MOV     r1, r2

      [ debugPrivate
        Debug   ,"copysprite_withrotate from",R0
        Debug   ,"to",R1
        LDR     R2,[R0,#spLBit]
        LDR     R3,[R1,#spLBit]
        ORRS    R2,R2,R3
        BEQ     %FT80
        Debug   ,"** flip with wastage!!!"
80
      ]



        [ Libra1
        LDRB    R7, job_strip_type
        CMP     R7, #4
        BEQ     Handle_16bpp_rotation
        CMP     R7, #5
        BEQ     Handle_32bpp_rotation
        BNE     Handle_8bpp_rotation
        ]

        [ Libra1
Handle_16bpp_rotation

  Debug Privatemjs,"16 bpp rotation case (Landscape)"
        LDR     R4, [r1, #spHeight]
        ADD     r4, r4, #1
  Debug Privatemjs,"destination sp height = ",R4
        MOV     R6, R4

        LDR     R5, [r1, #spWidth]
        ADD     R5, R5, #1
  Debug Privatemjs,"destination sp width = ",R5
        MOV     R5, R5, LSL #1

      ; now set initial pixel pointers
        LDR     r7, [r0, #spImage]
        ADD     r0, r0, r7

      ; destination copy starts at the first pixel on the last row
        LDR     r7, [r1, #spImage]
        ADD     r1, r1, r7          ; point at first byte after sprite

        MOV     R7, R5
        MOV     R3, R4, LSL #1      ; significant bytes in row

        ADD     R0, R0, R3          ; r0 -> last pixel in row, + 1 pixel

        TST     R3, #2              ; r3 is step to next row, ...
        ADDNE   R3, R3, #2          ; ... remembering padding to word alignment
  Debug Privatemjs, "row step (R3) = ",R3

        MOV     R2, R0


Start_loop16
        SUB     R2, R2, #2
        MOV     R0, R2
main_loopy16
        LDRB    R8, [R0]
        STRB    R8, [R1], #1

        LDRB    R8, [r0, #1]
        STRB    R8, [R1], #1

        ADD     R0, R0, R3

        SUBS    R5, R5, #1
        BGT     main_loopy16
        MOV     R5, R7
        SUBS    R4, R4, #1
        BGT     Start_loop16


        EXITS
        ]
        [ Libra1
Handle_32bpp_rotation
        Push    "R8-R11"
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
;  Debug PageBoxMem,"32bpp rotate: source width height = ",R2,R3
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
;  Debug PageBoxMem,"32bpp rotate:R0 R1 start = ",R0,R1
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
;  Debug PageBoxMem,"32bpp rotate:R0 R1 next = ",R0,R1
        BNE     %BT01
        Pull    "R8-R11"
        EXITS
        ]

        [ Libra1
Handle_8bpp_rotation
        ]
      ; get the number of pixels we will copy in the inner loop
      ; we copy right then down  in the source sprite,
      ;       upwards then right in the destination

        LDR     r2, [r1, #spHeight]
        ADD     r2, r2, #1         ; number of pixels we will copy (= n)

      ; step up in destination = -linelength
        LDR     r4, [r1, #spWidth]
        ADD     r4, r4, #1
        MOV     r4, r4, LSL #2
        RSB     r4, r4, #0        ; -linelength (in bytes)

      ; step right in destination = 1 - (-linelength*n)
        MUL     r5, r4, r2
        RSB     r5, r5, #1        ; 1 - (-linelength*n)


      ; outer loop count = depth of source
        LDR     r6, [r0, #spHeight]

      ; step right in source = 1
      ; step down 1 and back n = linelength - n

        LDR     r3, [r0, #spWidth]
        ADD     r3, r3, #1         ; number of words

      ; now set initial pixel pointers
        LDR     r7, [r0, #spImage]
        ADD     r0, r0, r7

      ; destination copy starts at the first pixel on the last row
        LDR     r7, [r1, #spNext]
        ADD     r1, r1, r7          ; point at first byte after sprite

    [ MonoBufferOK
      [ NbppBufferOK
        LDRB    lr, job_output_bpp
        CMP     lr, #8
      |
        LDRB    lr, job_use_1bpp
        CMP     lr, #0
      ]
        BNE     cswr_1bpp
    ]

        RSB     r3, r2, r3, LSL #2 ; number of bytes to step

        Debug   Private,"Source pointer",R0
        Debug   Private,"Dest pointer",R1
        Debug   Private,"Inner loop count",R2
        Debug   Private,"Source outer step",R3
        Debug   Private,"Dest inner step",R4
        Debug   Private,"Dest outer step",R5
        Debug   Private,"Outer loop count",R6

01      SUBS    r7, r2, #4
03      LDRHS   lr, [r0], #4        ; do this loop while >= 4 bytes remain
        STRHSB  lr, [r1, r4]!       ; essentially, it's the lower loop
        MOVHS   lr, lr, LSR #8      ; unrolled to allow word fetches
        STRHSB  lr, [r1, r4]!
        MOVHS   lr, lr, LSR #8
        STRHSB  lr, [r1, r4]!
        MOVHS   lr, lr, LSR #8
        STRHSB  lr, [r1, r4]!
        SUBHSS  r7, r7, #4
        BHS     %BT03
        ADDS    r7, r7, #4
02      LDRGTB  lr, [r0], #1        ; beware exactly 4*n columns
        STRGTB  lr, [r1, r4]!
        SUBS    r7, r7, #1
        BGT     %BT02
        ADD     r1, r1, r5
        ADD     r0, r0, r3
        SUBS    r6, r6, #1
        BPL     %BT01              ; counter is rows-1

        EXITS

    [ MonoBufferOK
cswr_1bpp
        Push   "r1, r8-r12"
        [ Libra1        ; getting rid of this stops noise at top of page.
       ; ADD     r6, r6, #1         ; was height-1 before
        |
        ADD     r6, r6, #1      ; was height-1 before
        ]

;  got:
;    source byte pointer        : r0
;    source row length          : r3 << 2
;    dest byte pointer          : r1
;    dest row length            : -r4
;    width, height in dots      ; r2, r6

        Debug   Private,"mono: source byte pointer",R0
        Debug   Private,"dest byte pointer",R1
        Debug   Private,"width",R2
        Debug   Private,"source words per row",R3
        Debug   Private,"dest row len",R4
        Debug   Private,"height",R6
;
;use:
;    loop count : r7
;    rs1, rs2   : r8, r9
;    rd1, rd2   : r10,r11
;    bit        : r12

13      SUBS    r6, r6, #8       ; see if full height cube can be picked out
        BLT     %FT10

        MOV     r7, r2
12      LDRB    r8, [r0], r3, LSL #2     ; build a source cube
        LDRB    lr, [r0], r3, LSL #2
        ORR     r8, r8, lr, LSL #8
        LDRB    lr, [r0], r3, LSL #2
        ORR     r8, r8, lr, LSL #16
        LDRB    lr, [r0], r3, LSL #2
        ORR     r8, r8, lr, LSL #24      ; rs1 complete
        LDRB    r9, [r0], r3, LSL #2
        LDRB    lr, [r0], r3, LSL #2
        ORR     r9, r9, lr, LSL #8
        LDRB    lr, [r0], r3, LSL #2
        ORR     r9, r9, lr, LSL #16
        LDRB    lr, [r0], r3, LSL #2
        ORR     r9, r9, lr, LSL #24      ; rs2 complete
        BL      spin8x8_in_words         ; get rd1,rd2 (corrupts flags)

        SUBS    r7, r7, #8               ; decrement the counter
        BLGE    save_with_gay_abandon
        BLLT    save_carefully

    ; step the pixel pointers
        SUB     r0, r0, r3, LSL #2+3     ; step back to start point
        ADD     r0, r0, #1               ; and on one byte
        BGT     %BT12                    ; loop while more
        ADD     r0, r0, #3               ; step to word boundary
        BIC     r0, r0, #3               ; now at next row start
        ADD     r0, r0, r3, LSL #2+3     ; step on 8 rows
        SUB     r0, r0, r3, LSL #2       ; and back one
        LDR     r1, [stack]
        ADD     r1, r1, #1
        STR     r1, [stack]

        Debug   Private,"Source ptr",R0
        Debug   Private,"Dest ptr",R1

        B       %BT13                    ; step to next row

10  ; there are less than 8 rows left in the source: pick up carefully
        MOV     r7, r2
        ADD     r6, r6, #8
11      LDRB    r8, [r0], r3, LSL #2     ; build a source cube
        SUBS    r12, r6, #1              ; count the rows
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r8, r8, lr, LSL #8
        SUBS    r12, r12, #1
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r8, r8, lr, LSL #16
        SUBS    r12, r12, #1
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r8, r8, lr, LSL #24      ; rs1 complete
        SUBS    r12, r12, #1
        LDRGTB  r9, [r0], r3, LSL #2
        MOVLE   r9, #0
        SUBS    r12, r12, #1
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r9, r9, lr, LSL #8
        SUBS    r12, r12, #1
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r9, r9, lr, LSL #16
        BL      spin8x8_in_words         ; get rd1,rd2 (corrupts flags)

        SUBS    r7, r7, #8               ; decrement the counter
        BLGE    save_with_gay_abandon
        BLLT    save_carefully

    ; step the pixel pointers

        MUL     r12, r3, r6
        SUB     r0, r0, r12, LSL #2      ; step back to start point
        ADD     r0, r0, #1               ; and on one byte
        BGT     %BT11                    ; loop while more

    ; finished!
        Pull   "r1, r8-r12"
        EXITS

save_with_gay_abandon ROUT               ; Must preserve flags
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!
        MOV     r10, r10, ROR #24
        STRB    r10, [r1, r4]!
        MOV     r10, r10, ROR #24
        STRB    r10, [r1, r4]!
        MOV     r10, r10, ROR #24
        STRB    r10, [r1, r4]!
        MOV     r10, r10, ROR #24
        STRB    r10, [r1, r4]!
        MOV     pc, lr

; saving may drop off the start of the destination: do it carefully

save_carefully ROUT
        EntryS
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!           ; at least one to do
        ADDS    r7, r7, #7               ; count of bytes left to do
        MOV     r11, r11, ROR #24
        STRGTB  r11, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r11, r11, ROR #24
        STRGTB  r11, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r11, r11, ROR #24
        STRGTB  r11, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r10, r10, ROR #24
        STRGTB  r10, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r10, r10, ROR #24
        STRGTB  r10, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r10, r10, ROR #24
        STRGTB  r10, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r10, r10, ROR #24
        STRGTB  r10, [r1, r4]!
        EXITS

; take 8x8 source pixels in rs1, rs2 and build rd1, rd2

spin8x8_in_words ROUT

        Debuga  Private,"Source ptr",R0
        Debuga  Private,", pixels",R8
        Debug   Private,",",R9

        MOV     r12, #1:SHL:24     ; start in LSB of byte 8 in dest
        MOV     r10, #0
        MOV     r11, #0
01      MOVS    r8, r8, LSR #1   ; next bit -> C
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSL #24  ; step to next word

        MOVS    r8, r8, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r10, r10, r12
        MOVS    r12, r12, LSL #29
        MOVCC   r12, r12, LSR #4   ; step to next source byte
        BCC     %BT01              ; still on first source word

        MOV     r12, #1:SHL:28     ; start in r12 4 of byte 8 in dest
02      MOVS    r9, r9, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSL #24  ; step to next word

        MOVS    r9, r9, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r10, r10, r12
        MOVS    r12, r12, LSL #25
        BCC     %BT02              ; still on second source word

        Debug   Private,"Result pixels",R11
        Debug   Private,",",R12

        MOV     pc, lr             ; no need to preserve flags
    ]

;
;fast copysprite_withrotate, 32 bpp case, 90 degrees
;
copysprite_withrotate_32bpp90 ROUT
        EntryS  "R0-R11"
  Debug PageBoxMem,"copysprite_withrotate_32bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        EXITS

;
;fast copysprite_withrotate, 32 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_32bpp270 ROUT
        EntryS  "R0-R11"
  Debug PageBoxMem,"copysprite_withrotate_32bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3,LSL #2
        SUB     R1,R1,#16           ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R11,[R0],R2,LSL #2  ;load next 4 pixels...
        LDR     R10,[R0],R2,LSL #2
        LDR     R9,[R0],R2,LSL #2
        LDR     R8,[R0],R2,LSL #2   ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        ADD     R1,R1,R3,LSL #2     ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5,LSL #2
        SUB     R1,R1,#16           ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        EXITS


;
;fast copysprite_withrotate, 8 bpp case, 90 degrees
;
copysprite_withrotate_8bpp90 ROUT
        EntryS  "R0-R12"
  Debug PageBoxMem,"copysprite_withrotate_8bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5
        SUB     R1,R1,R3            ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R8,[R0],R12         ;load next 4 pixels...
        LDRB    R9,[R0],R12
        LDRB    R10,[R0],R12
        LDRB    R11,[R0],R12        ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        SUB     R1,R1,R3            ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5
        ADD     R1,R1,#4            ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        EXITS


;
;fast copysprite_withrotate, 8 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_8bpp270 ROUT
        EntryS  "R0-R12"
  Debug PageBoxMem,"copysprite_withrotate_8bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3
        SUB     R1,R1,#4            ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R11,[R0],R12        ;load next 4 pixels...
        LDRB    R10,[R0],R12
        LDRB    R9,[R0],R12
        LDRB    R8,[R0],R12         ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        ADD     R1,R1,R3            ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5
        SUB     R1,R1,#4            ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        EXITS


; ******************************************************************


        END
@


4.6
log
@Unoptimised a RMA clearing loop: went mad if the workspace was not a
multiple of 3.
Changed PDumper Upcall stuff to pass R0-R12 on the stack - curiously this
fixes the RMA corruption and instability of !Printers (as does switching
the UpCalls off.

Version 4.51. Tagged as 'PDModules-4_51'
@
text
@d246 3
a248 15
        CMP     R0, #4                 ; if output sprite strip - 16bpp
        MOVEQ   R0, #5                  ; create fancy spritetype with 16bpp information
        MOVEQ   R6, R0, LSL #13         ; 16bpp
        MOVEQ   r0, #90
        ORREQ   R6, R6, R0              ; Vdpi = 90
        MOVEQ   R6, R6, LSL #13
        ORREQ   R6, R6, R0              ; Hdpi = 90
        MOVEQ   R6, R6, LSL #1
        MOVEQ   R0, #1
        ORREQ   R6, R6, R0              ; distringuishing bit
        Pull    "R0"
        ]
        [ Libra1
        Push    "R0"
        LDRB    R0, job_strip_type
d250 3
a252 2
        MOVEQ   R0, #6                  ; create fancy spritetype with 32bpp information
        MOVEQ   R6, R0, LSL #13         ; 32bpp
d254 3
a256 6
        ORREQ   R6, R6, R0              ; Vdpi = 90
        MOVEQ   R6, R6, LSL #13
        ORREQ   R6, R6, R0              ; Hdpi = 90
        MOVEQ   R6, R6, LSL #1
        MOVEQ   R0, #1
        ORREQ   R6, R6, R0              ; distringuishing bit
@


4.5
log
@Fix for the thingy which sits on SpriteV,it got optimised sometime round
2000 which led to it getting the "redirected to sprite" switch in a
muddle so printing from some apps ended up on the screen not in the
postscript file.
Changed the "%%Creator" string a bit.
Took the opportunity to eliminate all the signed pointer comparisons.
Tightened up the checking of pointers to palettes and translation tables
so that "0 or -1" means to use the default,not <= 0.

Version 4.50. Tagged as 'PDModules-4_50'
@
text
@d729 1
a729 1
        [  Libra1
@


4.4
log
@Changed to use objasm to avoid any LDR rN,[rN],#0 problems
Changed to use shared Makefiles
Numerous small 32 bit conversion improvements
Bugfix to PDriverPS,it was pulling LR not PC - this has been the case for
many years so not sure how it ever worked.
Due to a bug in objasm 3.27 this checkin will infact not build directly.
You must first
 - rename the PDriverDP dir to PDriverDP2
 - rename the PDriverPS dir to PDriverPS2
 - move the 2 source files of the same name up a directory
checked in in this way to minimise messing in CVS.

Version 4.47. Tagged as 'PDModules-4_47'
@
text
@a129 1
         CMP       r1, #0
d131 2
a132 1
         BGE       %FT80
d136 1
d182 1
a182 1
         CMP     r1, #0
d184 1
a184 1
         BGE     %FT80
d188 2
a189 1
         MOVLT   pc, lr                 ; not yet allocated
a308 1
        CMP       r1, #0
d310 2
a311 1
        BGE       %FT80
d315 1
@


4.3
log
@  Merge of 32-bit branch.
Detail:
  These modules are now thought to work.
Admin:
  This module has received some testing of both 26-bit and 32-bit
    builds and is believed to function correctly.

Version 4.45. Tagged as 'PDModules-4_45'
@
text
@d136 5
a140 3
         MOVEQ    r0, #3
         SWIEQ    XOS_ReadDynamicArea
         MOVEQ    r1, r0
d313 5
a317 3
        MOVEQ     r0, #3
        SWIEQ     XOS_ReadDynamicArea
        MOVEQ     r1, r0
@


4.2
log
@Version Spin_merge taken
@
text
@d143 1
a143 1
      
d165 1
a165 1
      
d196 1
a196 1
        
d239 1
a239 1
        [ Libra1 
d254 1
a254 1
        [ Libra1 
d378 1
a378 1
        
d422 1
a422 22
         Pull "r0-r2, pc",,^


      [ {FALSE}

; routine to send a counted string (i.e. length followed by bytes)
; to the current output.

send_counted_string ROUT
        Push  "r0-r2, lr"

        Debug Private,"counted string at",R0
        MOV   r1, r0
        LDRB  r2, [r1], #1

        Debug Private,"Length",R2

01      SUBS   r2, r2, #1
        LDRGEB r0, [r1], #1
        BLGE   send_byte
        BVS    %FT99
        BGE    %BT01
a423 16
        Pull  "r0-r2, pc",,^

99      STR    r0, [stack]
        Pull  "r0-r2, pc"

; send a byte to the output stream

send_byte ROUT
        Push   "r1, lr"
        LDRB    r1, jobhandle
        SWI     XOS_BPut
        Pull   "r1, lr"
        MOVVCS  pc, lr
        ORRS    pc, lr, #V_bit
       
     ]
d453 3
a455 2
    BIC     lr, lr, #V_bit
    Push   "r0, r7, r8, lr"
d471 1
a471 1
    BLVS    %FT99
d474 1
a474 1
    BLVS    %FT99
d479 1
a480 1
    Pull   "r7, r8, pc", PL, ^
d483 3
a485 7

    Pull   "r7, r8, pc",, ^

99  LDR     r8, [stack, #12]
    ORR     r8, lr, #V_bit
    STR     r8, [stack, #12]       ; ensure V set returned
    MOV     pc, lr
d491 1
a491 1
    Push   "r0-r7, lr"
d493 6
a498 1
    LDMFD   stack, {r2, r3}
d509 1
a509 1
    Push   "r0-r7, lr"
d550 1
a550 1
    Pull   "r1"
d553 1
d555 1
a555 1
    Pull   "r1-r7, pc",,^
d562 1
a562 1
     Push  "r0-r3, lr"
d574 1
a574 1
     Pull   "r0-r3, pc", EQ
d598 2
a599 2
99   STRVS  r0, [stack]
     Pull  "r0-r3, pc"
d612 1
a612 1
        Push   "r7, r9-r11, lr"
d627 1
a627 1
        Pull   "r7, r9-r11, pc",,^
d637 2
a638 2
        Push   "r5, r8-r12, lr"
      
a665 2
     
        Debug   Private," yeilds",R0
d667 3
a669 1
        Pull   "r5, r8-r12, pc",,^
d680 1
a680 1
        Push   "r0-r7, lr"
d700 1
a700 1
        Pull   "r0-r7, pc"
d721 1
a721 1
        
d730 1
a730 1
        
d752 1
a752 1
                     
d784 1
a784 1
        Pull   "r0-r7, pc",,^
d816 1
a816 1
        ADD     R0,R0,R2,LSL #3     
d824 1
a824 1
        Pull   "r0-r7, pc",,^
d877 1
a877 1
                
d907 1
a907 1
        Pull   "r0-r7, pc",,^
d956 1
a956 1
        BL      spin8x8_in_words         ; get rd1,rd2
d1001 1
a1001 1
        BL      spin8x8_in_words         ; get rd1,rd2
d1016 1
a1016 1
        Pull   "r0-r7, pc",,^
d1018 1
a1018 1
save_with_gay_abandon ROUT
d1035 1
a1035 1
        MOVS    pc, lr
d1040 1
d1064 1
a1064 1
        MOVS    pc, lr
d1132 1
a1132 1
             
d1136 1
a1136 1
        MOVS    pc, lr             ; preserve flags
d1143 1
a1143 1
        Push   "R0-R11,LR"
d1176 1
a1176 1
        ADD     R0,R0,R2,LSL #3     
d1182 1
a1182 1
        Pull    "R0-R11,PC",,^
d1188 1
a1188 1
        Push   "R0-R11,LR"
d1221 1
a1221 1
        ADD     R0,R0,R2,LSL #3     
d1227 1
a1227 1
        Pull    "R0-R11,PC",,^
d1234 1
a1234 1
        Push   "R0-R12,LR"
d1273 1
a1273 1
        ADD     R0,R0,R12,LSL #1     
d1279 1
a1279 1
        Pull    "R0-R12,PC",,^
d1286 1
a1286 1
        Push   "R0-R12,LR"
d1325 1
a1325 1
        ADD     R0,R0,R12,LSL #1     
d1331 1
a1331 1
        Pull    "R0-R12,PC",,^
@


4.2.2.1
log
@  First attempt at 32-bit compatible modules.
Admin:
  Tested that modules build 26-bit and 32-bit.
  Requires HdrSrc-1_05 or later.

Version 4.44, 4.1.2.1. Tagged as 'PDModules-4_44-4_1_2_1'
@
text
@d143 1
a143 1

d165 1
a165 1

d196 1
a196 1

d239 1
a239 1
        [ Libra1
d254 1
a254 1
        [ Libra1
d378 1
a378 1

d422 22
a443 1
         Pull "r0-r2, pc"
d445 16
d490 2
a491 2
    Push   "r0, r7, r8, r9, lr"
    MOV     r9, #0
d507 1
a507 2
    SavePSR r9, VS
    ORRVS   r9, r9, #V_bit
d510 1
a510 2
    SavePSR r9, VS
    ORRVS   r9, r9, #V_bit
a514 1
    BPL     %FT99
d516 1
d519 7
a525 3
99
    RestPSR r9,,f
    Pull   "r7, r8, r9, pc"
d544 1
a544 1
    EntryS  "r0-r7"
d589 1
a589 1
    EXITS
d596 1
a596 1
     Entry  "r0-r3"
d608 1
a608 1
     EXIT   EQ
d632 2
a633 2
99   STRVS  r0, [stack, #Proc_RegOffset]
     EXIT
d646 1
a646 1
        EntryS  "r7, r9-r11"
d661 1
a661 1
        EXITS
d671 2
a672 2
        EntryS  "r5, r8-r12"

d700 1
a700 1

d703 1
a703 1
        EXITS
d714 1
a714 1
        EntryS  "r0-r7"
d734 1
a734 1
        EXIT
d755 1
a755 1

d764 1
a764 1

d786 1
a786 1

d818 1
a818 1
        EXITS
d850 1
a850 1
        ADD     R0,R0,R2,LSL #3
d858 1
a858 1
        EXITS
d911 1
a911 1

d941 1
a941 1
        EXITS
d990 1
a990 1
        BL      spin8x8_in_words         ; get rd1,rd2 (corrupts flags)
d1035 1
a1035 1
        BL      spin8x8_in_words         ; get rd1,rd2 (corrupts flags)
d1050 1
a1050 1
        EXITS
a1052 1
        EntryS
d1069 1
a1069 1
        EXITS
a1073 1
        EntryS
d1097 1
a1097 1
        EXITS
d1165 1
a1165 1

d1169 1
a1169 1
        MOV     pc, lr             ; no need to preserve flags
d1176 1
a1176 1
        EntryS  "R0-R11"
d1209 1
a1209 1
        ADD     R0,R0,R2,LSL #3
d1215 1
a1215 1
        EXITS
d1221 1
a1221 1
        EntryS  "R0-R11"
d1254 1
a1254 1
        ADD     R0,R0,R2,LSL #3
d1260 1
a1260 1
        EXITS
d1267 1
a1267 1
        EntryS  "R0-R12"
d1306 1
a1306 1
        ADD     R0,R0,R12,LSL #1
d1312 1
a1312 1
        EXITS
d1319 1
a1319 1
        EntryS  "R0-R12"
d1358 1
a1358 1
        ADD     R0,R0,R12,LSL #1
d1364 1
a1364 1
        EXITS
@


4.2.2.2
log
@  Lots of fixes.
Detail:
  Several stack imbalances and missing conditions on instructions fixed.
  Some flag removal code sequences improved (RSB rn,pc,pc:SUB rn,lr,rn)
Admin:
  Built both 26 and 32-bit versions - neither tested.

Version 4.44, 4.1.2.2. Tagged as 'PDModules-4_44-4_1_2_2'
@
text
@d454 1
a454 2
    SavePSR r9                      ; need to preserve entry flags except V
    BICVS   r9, r9, #V_bit
d470 1
d474 1
d1013 2
a1014 1
save_with_gay_abandon ROUT               ; Must preserve flags
d1031 1
a1031 1
        MOV     pc, lr
@


4.2.2.3
log
@  More fixes.
Detail:
  26-bit builds work again - a stack imbalance in PDriverDP has been fixed.
  Tidied up some nasty code that effected an EOR in a convoluted manner.  It
    now uses an EOR instruction instead of loads of TSTs and TEQP.
Admin:
  26-bit build tested very briefly - no longer dies.
  32-bit build dies still.

Version 4.44, 4.1.2.3. Tagged as 'PDModules-4_44-4_1_2_3'
@
text
@d545 1
a545 1
    LDR     r1, [sp, #Proc_RegOffset + 0 * 4]
a547 1
    STRMI   r0, [sp, #Proc_RegOffset + 0 * 4]
d661 1
a661 1
        Debug   Private," yields",R0
@


4.2.2.4
log
@  Stack imbalance fix in 32-bit builds.
Detail:
  Cross-jumping between routines didn't work now that they stacked
    different things on entry.  This is now fixed, and an unnecessary
    CMP has been removed too.
Admin:
  Tested briefly.
  Bug discovered by Dan Ellis.

Version 4.44, 4.1.2.4. Tagged as 'PDModules-4_44-4_1_2_4'
@
text
@d491 4
a494 8
    EntryS  "r0-r7"
    MOVS    r1, r2
    ASSERT (Proc_RegOffset = 4) :LOR: (Proc_RegOffset = 0)
    [ Proc_RegOffset = 4
    LDMIB   sp, {r2, r3}
    |
    LDMIA   sp, {r2, r3}
    ]
d504 1
a504 1
    ALTENTRY
@


4.2.2.5
log
@The CMP wasn't spurious - it was vital

Version 4.44, 4.1.2.5. Tagged as 'PDModules-4_44-4_1_2_5'
@
text
@d492 1
a492 1
    MOV     r1, r2
a498 1
    CMP     r2, #0
@


4.2.2.6
log
@  32bit fixes

Detail:
  A bug was introduced fixing the bug introduced making PDumperDP 32bit
  compatible.  The result of an extended division wasn't being put on the
  return stack unless it was negative.

  A few instructions remained in PDriverPS which cleared the link register
  with BIC #psr (for accessing the data after the function call
  instruction), these have been replaced with the processor mode neutral
  variant:

             RSB temp, pc, pc
             SUB lr, lr, temp

Admin:
  Pages now print correctly from pdumperdp, and pdumperps still prints
  without error.

Version 4.44, 4.1.2.6. Tagged as 'PDModules-4_44-4_1_2_6'
@
text
@d491 1
a491 1
    Push   "r0-r7, lr"
d493 6
a498 1
    LDMFD   stack, {r2, r3}
d509 1
a509 1
    Push   "r0-r7, lr"
d553 1
a553 1
    STR     r0, [sp, #Proc_RegOffset + 0 * 4]
@


4.2.2.7
log
@Wrong file checked in last time...
.

Version 4.44, 4.1.2.7. Tagged as 'PDModules-4_44-4_1_2_7'
@
text
@d491 1
a491 1
    EntryS  "r0-r7"
d493 1
a493 6
    ASSERT (Proc_RegOffset = 4) :LOR: (Proc_RegOffset = 0)
  [ Proc_RegOffset = 4
    LDMIB   stack,{r2, r3}
  |
    LDMIA   stack,{r2, r3}
  ]
d504 1
a504 1
    ALTENTRY
@


4.1
log
@Initial revision
@
text
@d598 1
d614 1
a614 1
    
d822 36
a857 37

        LDR     R4, [r1, #spHeight]
        ADD     r4, r4, #1
        MOV     R6, R4

        LDR     R5, [r1, #spWidth]
        ADD     R5, R5, #1
        MOV     R7, R5

      ; now set initial pixel pointers
        LDR     r7, [r0, #spImage]
        ADD     r0, r0, r7

      ; destination copy starts at the first pixel on the last row
        LDR     r7, [r1, #spImage]
        ADD     r1, r1, r7          ; point at first byte after sprite

        MOV     R7, R5
        MOV     R3, R4, LSL #2

        ADD     R0, R0, R3
        MOV     R2, R0


Start_loop32
        SUB     R2, R2, #4
        MOV     R0, R2
main_loopy32
        LDR     LR, [R0], R3
        STR     LR, [R1], #4
        SUBS    R5, R5, #1
        BGT     main_loopy32
        MOV     R5, R7
        SUBS    R4, R4, #1
        BGT     Start_loop32


d1171 195
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a597 1

d613 1
a613 1

d821 37
a857 36
        Push    "R8-R11"
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
;  Debug PageBoxMem,"32bpp rotate: source width height = ",R2,R3
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
;  Debug PageBoxMem,"32bpp rotate:R0 R1 start = ",R0,R1
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3     
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
;  Debug PageBoxMem,"32bpp rotate:R0 R1 next = ",R0,R1
        BNE     %BT01
        Pull    "R8-R11"
a1170 195

;
;fast copysprite_withrotate, 32 bpp case, 90 degrees
;
copysprite_withrotate_32bpp90 ROUT
        Push   "R0-R11,LR"
  Debug PageBoxMem,"copysprite_withrotate_32bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3     
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R11,PC",,^

;
;fast copysprite_withrotate, 32 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_32bpp270 ROUT
        Push   "R0-R11,LR"
  Debug PageBoxMem,"copysprite_withrotate_32bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3,LSL #2
        SUB     R1,R1,#16           ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R11,[R0],R2,LSL #2  ;load next 4 pixels...
        LDR     R10,[R0],R2,LSL #2
        LDR     R9,[R0],R2,LSL #2
        LDR     R8,[R0],R2,LSL #2   ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        ADD     R1,R1,R3,LSL #2     ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3     
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5,LSL #2
        SUB     R1,R1,#16           ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R11,PC",,^


;
;fast copysprite_withrotate, 8 bpp case, 90 degrees
;
copysprite_withrotate_8bpp90 ROUT
        Push   "R0-R12,LR"
  Debug PageBoxMem,"copysprite_withrotate_8bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5
        SUB     R1,R1,R3            ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R8,[R0],R12         ;load next 4 pixels...
        LDRB    R9,[R0],R12
        LDRB    R10,[R0],R12
        LDRB    R11,[R0],R12        ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        SUB     R1,R1,R3            ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1     
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5
        ADD     R1,R1,#4            ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R12,PC",,^


;
;fast copysprite_withrotate, 8 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_8bpp270 ROUT
        Push   "R0-R12,LR"
  Debug PageBoxMem,"copysprite_withrotate_8bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3
        SUB     R1,R1,#4            ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R11,[R0],R12        ;load next 4 pixels...
        LDRB    R10,[R0],R12
        LDRB    R9,[R0],R12
        LDRB    R8,[R0],R12         ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        ADD     R1,R1,R3            ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1     
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5
        SUB     R1,R1,#4            ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R12,PC",,^

@


4.1.7.2
log
@Placed code in redirect output to check for the current state, so as not to duplicate the present output direction(jobspriteparams)
@
text
@d159 1
a159 12
         ADR     lr, jobspriteparams	; AR checks for existing direction of output
	 Push	 "r4-r7"
	 LDMIA	 lr, {r4-r7}
	 CMP	 r4, r0
	 CMPEQ   r5, r1
	 CMPEQ   r6, r2
	 CMPEQ	 r7, r3
	 Pull    "r4-r7"

	 DebugIf EQ, Private,"Attempting to save over present direction of sprites"
	 BEQ	 %FT100	;the big avoid	 
          
a174 1
100
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a597 1

d613 1
a613 1

d821 37
a857 36
        Push    "R8-R11"
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
;  Debug PageBoxMem,"32bpp rotate: source width height = ",R2,R3
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
;  Debug PageBoxMem,"32bpp rotate:R0 R1 start = ",R0,R1
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3     
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
;  Debug PageBoxMem,"32bpp rotate:R0 R1 next = ",R0,R1
        BNE     %BT01
        Pull    "R8-R11"
a1170 195

;
;fast copysprite_withrotate, 32 bpp case, 90 degrees
;
copysprite_withrotate_32bpp90 ROUT
        Push   "R0-R11,LR"
  Debug PageBoxMem,"copysprite_withrotate_32bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3     
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R11,PC",,^

;
;fast copysprite_withrotate, 32 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_32bpp270 ROUT
        Push   "R0-R11,LR"
  Debug PageBoxMem,"copysprite_withrotate_32bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3,LSL #2
        SUB     R1,R1,#16           ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R11,[R0],R2,LSL #2  ;load next 4 pixels...
        LDR     R10,[R0],R2,LSL #2
        LDR     R9,[R0],R2,LSL #2
        LDR     R8,[R0],R2,LSL #2   ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        ADD     R1,R1,R3,LSL #2     ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3     
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5,LSL #2
        SUB     R1,R1,#16           ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R11,PC",,^


;
;fast copysprite_withrotate, 8 bpp case, 90 degrees
;
copysprite_withrotate_8bpp90 ROUT
        Push   "R0-R12,LR"
  Debug PageBoxMem,"copysprite_withrotate_8bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5
        SUB     R1,R1,R3            ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R8,[R0],R12         ;load next 4 pixels...
        LDRB    R9,[R0],R12
        LDRB    R10,[R0],R12
        LDRB    R11,[R0],R12        ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        SUB     R1,R1,R3            ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1     
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5
        ADD     R1,R1,#4            ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R12,PC",,^


;
;fast copysprite_withrotate, 8 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_8bpp270 ROUT
        Push   "R0-R12,LR"
  Debug PageBoxMem,"copysprite_withrotate_8bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3
        SUB     R1,R1,#4            ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R11,[R0],R12        ;load next 4 pixels...
        LDRB    R10,[R0],R12
        LDRB    R9,[R0],R12
        LDRB    R8,[R0],R12         ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        ADD     R1,R1,R3            ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1     
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5
        SUB     R1,R1,#4            ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R12,PC",,^

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a597 1

d613 1
a613 1

d821 37
a857 36
        Push    "R8-R11"
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
;  Debug PageBoxMem,"32bpp rotate: source width height = ",R2,R3
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
;  Debug PageBoxMem,"32bpp rotate:R0 R1 start = ",R0,R1
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3     
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
;  Debug PageBoxMem,"32bpp rotate:R0 R1 next = ",R0,R1
        BNE     %BT01
        Pull    "R8-R11"
a1170 195

;
;fast copysprite_withrotate, 32 bpp case, 90 degrees
;
copysprite_withrotate_32bpp90 ROUT
        Push   "R0-R11,LR"
  Debug PageBoxMem,"copysprite_withrotate_32bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3     
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R11,PC",,^

;
;fast copysprite_withrotate, 32 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_32bpp270 ROUT
        Push   "R0-R11,LR"
  Debug PageBoxMem,"copysprite_withrotate_32bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3,LSL #2
        SUB     R1,R1,#16           ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R11,[R0],R2,LSL #2  ;load next 4 pixels...
        LDR     R10,[R0],R2,LSL #2
        LDR     R9,[R0],R2,LSL #2
        LDR     R8,[R0],R2,LSL #2   ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        ADD     R1,R1,R3,LSL #2     ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3     
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5,LSL #2
        SUB     R1,R1,#16           ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R11,PC",,^


;
;fast copysprite_withrotate, 8 bpp case, 90 degrees
;
copysprite_withrotate_8bpp90 ROUT
        Push   "R0-R12,LR"
  Debug PageBoxMem,"copysprite_withrotate_8bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5
        SUB     R1,R1,R3            ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R8,[R0],R12         ;load next 4 pixels...
        LDRB    R9,[R0],R12
        LDRB    R10,[R0],R12
        LDRB    R11,[R0],R12        ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        SUB     R1,R1,R3            ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1     
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5
        ADD     R1,R1,#4            ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R12,PC",,^


;
;fast copysprite_withrotate, 8 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_8bpp270 ROUT
        Push   "R0-R12,LR"
  Debug PageBoxMem,"copysprite_withrotate_8bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3
        SUB     R1,R1,#4            ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R11,[R0],R12        ;load next 4 pixels...
        LDRB    R10,[R0],R12
        LDRB    R9,[R0],R12
        LDRB    R8,[R0],R12         ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        ADD     R1,R1,R3            ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1     
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5
        SUB     R1,R1,#4            ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        Pull    "R0-R12,PC",,^

@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.5;
access;
symbols
	PDModules-4_64:4.5
	PDModules-4_63:4.5
	PDModules-4_62:4.5
	PDModules-4_61:4.5
	PDModules-4_60:4.5
	PDModules-4_59:4.5
	PDModules-4_58:4.5
	PDModules-4_57:4.5
	PDModules-4_56:4.5
	PDModules-4_55:4.5
	PDModules-4_54:4.5
	PDModules-4_53:4.5
	PDModules-4_52:4.5
	PDModules-4_51:4.5
	PDModules-4_50:4.5
	PDModules-4_49:4.4
	PDModules-4_48:4.4
	PDModules-4_47:4.4
	PDModules-4_46:4.4
	kbracey_32bit_merge:4.3.2.3
	PDModules-4_45:4.4
	PDModules-4_44-4_1_2_7:4.3.2.3
	PDModules-4_44-4_1_2_6:4.3.2.3
	PDModules-4_44-4_1_2_5:4.3.2.3
	PDModules-4_44-4_1_2_4:4.3.2.3
	PDModules-4_44-4_1_2_3:4.3.2.3
	PDModules-4_44-4_1_2_2:4.3.2.2
	PDModules-4_44-4_1_2_1:4.3.2.1
	kbracey_32bit:4.3.0.2
	kbracey_32bit_bp:4.3
	dellis_autobuild_BaseSW:4.3
	Ursula_merge:4.1.7.3
	PDModules-4_44:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.7.3
	Ursula_RiscPC:4.1.7.3.0.4
	rthornb_UrsulaBuild-19Aug1998:4.1.7.3
	UrsulaBuild_FinalSoftload:4.1.7.3
	rthornb_UrsulaBuild-12Aug1998:4.1.7.3
	aglover_UrsulaBuild-05Aug1998:4.1.7.3
	rthornb_UrsulaBuild-29Jul1998:4.1.7.3
	rthornb_UrsulaBuild-22Jul1998:4.1.7.3
	hsimons_BOCA-1_2-Release:4.1.7.3
	rthornb_UrsulaBuild-15Jul1998:4.1.7.3
	rthornb_UrsulaBuild-07Jul1998:4.1.7.3
	rthornb_UrsulaBuild-17Jun1998:4.1.7.3
	rthornb_UrsulaBuild-03Jun1998:4.1.7.3
	rthornb_UrsulaBuild-27May1998:4.1.7.3
	rthornb_UrsulaBuild-21May1998:4.1.7.3
	rthornb_UrsulaBuild_01May1998:4.1.7.3
	afrost_NC2_Generic:4.1.7.3
	afrost_Funai01-33:4.1.7.3
	Ursula:4.1.7.3.0.2
	Ursula_bp:4.1.7.3
	Ursula_31Mar1998:4.2
	Spinner_RCA116:4.1.7.3
	Spinner_B20_2:4.1.7.3
	Spinner_19_3:4.1.7.3
	Spinner_B18:4.1.7.3
	Spinner_B17:4.1.7.3
	Spinner_B15:4.1.7.3
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Spinner_B12:4.1.7.3
	Spin_merge_28May97:4.1.7.3
	Spinner_B10:4.1.7.3
	Spin_merge_16May97:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.3
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2003.03.10.11.33.28;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2001.01.09.13.59.39;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.07.10.12.26.09;	author sbrodie;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.05.16.12.55.47;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.48.37;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2000.10.18.11.32.02;	author sbrodie;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2000.11.24.13.27.32;	author sbrodie;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	2000.11.30.12.13.39;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.48.37;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.05.00;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.27.28;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.31.10;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.04.30.17.46.10;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.05.01.12.38.27;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Fix for the thingy which sits on SpriteV,it got optimised sometime round
2000 which led to it getting the "redirected to sprite" switch in a
muddle so printing from some apps ended up on the screen not in the
postscript file.
Changed the "%%Creator" string a bit.
Took the opportunity to eliminate all the signed pointer comparisons.
Tightened up the checking of pointers to palettes and translation tables
so that "0 or -1" means to use the default,not <= 0.

Version 4.50. Tagged as 'PDModules-4_50'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > MiscOp

;----------------------------------------------------------------------------
;
; miscop_decode implementation
;
;   Entry:     R0 reason code, bit 31 set.
;          R1..R7 reserved for the call.
;
;   Exit:  V set, r0 -> error block.
;          V clear, as defined by the call.
;
; This routine decodes the reason code specified in R0 and despatches to
; the relevant routine.  The call takes the reason code and sees if it
; is greater than or equal to the base of PDumper specific reasons, if it
; is then we despatch to the handler within the PDumper.  If a job is selected
; then the call is directed at the routines local to that job otherwise they
; go to the global handler.
;
; A set of reason codes are reserved for the PDumper manager itself to
; handle the registering and deregistering of PDumpers for instance.
;
;----------------------------------------------------------------------------

miscop_decode ROUT

        Debug   Configure,"Reason code",R0

        BIC     R0,R0,#TopBit                   ;Convert to useable reason code

        CMP     R0,#(PDumperMiscOp_DumperSpecific -PDriverMiscOp_DriverSpecific)
        BLT     miscop_ours                     ;If not greater than the to dumper threshold then handle

        Debug   Configure,"Attempting to direct at device"

        Push    "R9,LR"

        TEQ     R10,#0                          ;Is there a job currently?
        BNE     miscop_tojob

; We could use conditional coding here, but because the device may corrupt
; the flags and possibly R10 it is safer to have two specific cases.

        MOV     R11,#PDumperReason_MiscOp
        BL      CallPDumper                     ;Despatch to current global PDumper
        Pull    "R9,PC"                         ;And return allowing flags and registers through

miscop_tojob
        MOV     R9,#PDumperReason_MiscOp
        BL      CallPDumperForJob               ;Direct at the current job (R10 -> record)
        Pull    "R9,PC"                         ;Return allowing flags and registers through

miscop_ours
        CMP     R0,#(%10-%00)/4                 ;Is the reason code valid?
        ADDCC   PC,PC,R0,LSL #2                 ;Yes so despatch
        B       miscop_invalid
00
        B       miscop_addpdumper
        B       miscop_removepdumper
        B       miscop_getpdumperstriptypemask
10

;----------------------------------------------------------------------------
;
; miscop_addpdumper implementation
;
;   Entry: R1 PDumper number
;          R2 PDriverDP version required
;          R3 -> Branch code
;          R4 Workspace (private word) pointer
;          R5 Bit mask describing the branches supported
;          R6 Bit mask describing the strip types supported
;
;   Exit:  V set, r0 -> error block.
;
; This call registers a new PDumper with the PDriverDP manager, the routine
; first validates R2 to see if the PDriverDP being used is suitable for
; handling the pdumper.
;
; We then scan the list of installed PDumpers to see if this PDumper is
; already registered, if it is then we will error otherwise we allocate
; a new block and link it into the PDumper list.
;
; R5 contains a bit mask used to work out which calls are supported by the
; driver.
;
;----------------------------------------------------------------------------

miscop_addpdumper ROUT

        EntryS  "R0-R9"

        Debug   Configure,"PDumper number",R1
        Debug   Configure,"PDumperDP version required",R2
        Debug   Configure,"Workspace pointer (private word)",R3
        Debug   Configure,"Branch table at",R4
        Debug   Configure,"Branch table mask",R5
        Debug   Configure,"Strip mask",R6

        LDR     R8,=Module_Version
        CMP     R2,R8                   ; valid PDriverDP module installed?
        ADRGTL  r0,ErrorBlock_PDumperTooOld
        BGT     %90

        BL      miscop_removepdumper    ; attempt to remove it
        BVC     %FT05

        DebugE  Configure,"(register) 'removedumper' gave error "

        LDR     LR,[R0]                 ; get the error number
        LDR     R9,ErrorBlock_PDumperUndeclared
        TEQ     R9,LR
        BNE     %FT90                   ; if not complaining about it being already registered exit
05

        Debug   Configure,"(register) checking for dumper ID",R1

        ASSERT  (:INDEX: pdumper_next) =0

        ADDR    R8,pdumper_list
00
        LDR     R8,[R8,#pdumper_next]   ; -> block in list
        TEQ     R8,#0
        BEQ     %10                     ; not installed so allocate a new block

        LDR     LR,[R8,#pdumper_number]
        TEQ     R1,LR                   ; is it already registered?
        BNE     %00                     ; loop back until duplicate or what ever

        ADR     R0,ErrorBlock_PDumperDuplicateModule
90
        BL      LookupSingle
91
        STR     R0,[sp,#Proc_RegOffset] ; overwrite stacked R0
        EXIT
10

        MOV     R0,#ModHandReason_Claim
        LDR     R3,=pdumper_SIZE
        SWI     XOS_Module              ; get some new memory for block
        BVS     %91                     ; and then leave if it errors

        MOV     R9,R2                   ; -> new record block
        ASSERT (Proc_RegOffset = 4) :LOR: (Proc_RegOffset = 0)
  [ Proc_RegOffset = 4
        LDMIB   SP,{R0-R3}
  |
        LDMIA   SP,{R0-R3}
  ]
        ADD     R0,R9,#pdumper_number
        STMIA   R0,{R1-R6}              ; setup the record

        LDR     R0,pdumper_list         ; -> first record
        STR     R9,pdumper_list         ; -> first record (now the block allocated)
        STR     R0,[R9,#pdumper_next]


        LDR     R0,printer_pdumper_number
        Debug   Configure,"PDumper number to be configured",R0,R1

        TEQ     R0,R1                   ; is it the one we are currently using?
        EXITS   NE                      ; return if not because cannot configure


        STR     R9,printer_pdumper_pointer

        LDR     R0,pending_info_flag
        CMP     R0,#0                   ; any pending info? (clears V for call to configure_setdriver)
        ADRNEL  R2,pending_pdumper_command
        ADRNEL  R3,pending_info_data
        ADRNE   R4,printer_dump_depth
        LDRNE   R5,printer_configureword

      [ debugConfigure
        BEQ     %FT10
        DebugS  Configure,"PDumper command executed",R2
        DebugS  Configure,"PDumper palette filename",R3
        Debug   Configure,"PDumper dump data is at",R4
        Debug   Configure,"PDumper flags word",R5
10
      ]
        BLNE    configure_setdriver     ; setup the configuration

        MOV     LR,#0
        STR     LR,pending_info_flag    ; mark as no pending info
99
        STRVS   R0,[SP,#Proc_RegOffset]
        EXIT                            ; return because all done now

        MakeInternatErrorBlock PDumperDuplicateModule,,DupPDNo
        MakeInternatErrorBlock PDumperTooOld,,TooOld

;----------------------------------------------------------------------------
;
; miscop_removepdumper implementation
;
;   Entry: R1 PDumper number to be removed.
;
;   Exit:  V set, r0 -> error block.
;
; This call scans the list of PDumpers and then attempts to remove the pdumper
; if found or generate an error if it cannot be found.
;
;----------------------------------------------------------------------------

        ASSERT  pdumper_next =0

miscop_removepdumper ROUT

        EntryS  "R0-R3,R11"

        ADR     R11,printjoblist -(:INDEX: joblink)
10
        LDR     R11,joblink
        TEQ     R11,#0                  ; end of the list yet?
        BEQ     %FT15                   ; yes, so PDumper is not being used so exit

        LDR     LR,job_pdumper_number
        TEQ     LR,R1                   ; is the PDumper in use?
        BNE     %BT10                   ; ...nope so loop back until we have finished checking

        ADR     R0,ErrorBlock_PDumperInUse
        B       %FT90                   ; lookup the error and exit if it is
15

        ADDR    R0,pdumper_list         ; -> head of the list (pointer)
        LDR     R2,[R0]                 ; -> head of the list
00
        TEQ     R2,#0                   ; is the end of the list?
        ADREQ   R0,ErrorBlock_PDumperUndeclared
        BEQ     %90                     ; return because of an error

        LDR     R3,[R2,#pdumper_number]
        TEQ     R3,R1                   ; is it the PDumper we want?
        MOVNE   R0,R2
        LDRNE   R2,[R0,#pdumper_next]
        BNE     %00                     ; loop until all scanned

        Debug   Configure,"My record at",R2
        Debug   Configure,"Previous record at",R0

        LDR     LR,[R2,#pdumper_next]
        STR     LR,[R0,#pdumper_next]   ; unlink around the block

        MOV     R0,#ModHandReason_Free
        SWI     XOS_Module
        BVS     %95                     ; return because free failed!

        LDR     R2,printer_pdumper_number
        EORS    R3,R1,R2                ; killing the current pdumper?

        Debug   Configure,"PDumper being removed",R1
        Debug   Configure,"Current PDumper",R2

        MOVEQ   R0,#-1
        STREQ   R0,printer_pdumper_number

        ; mark as no pdumper or pending data (R3 was 0 from EORS)
        STREQ   R3,printer_pdumper_pointer
        STREQ   R3,pending_pdumper_command

        EXITS
90
        BL      LookupSingle
95
        STR     R0,[SP,#Proc_RegOffset] ; store error pointer
        EXIT

        MakeInternatErrorBlock PDumperUndeclared,,PDUndec
        MakeInternatErrorBlock PDumperInUse,,PDuUsed

; On entry, R1 = dumper number
; On exit, R0 = strip type mask if dumper loaded, otherwise regs preserved
miscop_getpdumperstriptypemask ROUT
        Push    "R0 - R2, LR"
        LDR     R0, pdumper_list
10      TEQ     R0, #0
        BEQ     %FT20
        LDR     R2, [R0, #pdumper_number]
        TEQ     R2, R1
        LDRNE   R0, [R0, #pdumper_next]
        BNE     %BT10
        LDR     R1, [R0, #pdumper_striptypemask]
        STR     R1, [R13]               ; overwrite value that was stacked
        Pull    "R0 - R2, PC"

20      ; no match on dumper number
        Pull    "R0 - R2, PC"

        END

@


4.4
log
@  Merge of 32-bit branch.
Detail:
  These modules are now thought to work.
Admin:
  This module has received some testing of both 26-bit and 32-bit
    builds and is believed to function correctly.

Version 4.45. Tagged as 'PDModules-4_45'
@
text
@d116 1
a116 1
        ADRGTL	r0,ErrorBlock_PDumperTooOld
@


4.3
log
@  Merged Ursula branch.
  Moved to srccommit.
Detail:
  Added fast service call table.
Admin:
  Tested briefly.

Version 4.44. Tagged as 'PDModules-4_44'
@
text
@d105 1
a105 1
        Push    "R0-R9,LR"
d148 2
a149 2
        ADD     SP,SP,#4                ; skip stack entry
        Pull    "R1-R9,PC"
d158 4
d163 1
d176 1
a176 1
        Pull    "R0-R9,PC",NE,^         ; return if not because cannot configure
d182 1
a182 1
        TEQ     R0,#0                   ; any pending info?
d201 2
a202 2
        STRVS   R0,[SP]
        Pull    "R0-R9,PC"              ; return because all done now
d224 1
a224 1
        Push    "R0-R3,R11,LR"
d264 1
a264 1
        TEQ     R1,R2                   ; killing the current pdumper?
d272 3
a274 3
        MOVEQ   R0,#0                   ; mark as no pdumper or pending data
        STREQ   R0,printer_pdumper_pointer
        STREQ   R0,pending_pdumper_command
d276 1
a276 1
        Pull    "R0-R3,R11,PC",,^
d280 2
a281 2
        STR     R0,[SP]                 ; store error pointer
        Pull    "R0-R3,R11,PC"
@


4.3.2.1
log
@  First attempt at 32-bit compatible modules.
Admin:
  Tested that modules build 26-bit and 32-bit.
  Requires HdrSrc-1_05 or later.

Version 4.44, 4.1.2.1. Tagged as 'PDModules-4_44-4_1_2_1'
@
text
@d105 1
a105 1
        EntryS  "R0-R9"
d148 2
a149 2
        STR     R0,[sp,#Proc_RegOffset] ; overwrite stacked R0
        EXIT
a157 4
        ASSERT (Proc_RegOffset = 4) :LOR: (Proc_RegOffset = 0)
  [ Proc_RegOffset = 4
        LDMIB   SP,{R0-R3}
  |
a158 1
  ]
d171 1
a171 1
        EXITS   NE                      ; return if not because cannot configure
d196 2
a197 2
        STRVS   R0,[SP,#Proc_RegOffset]
        EXIT                            ; return because all done now
d219 1
a219 1
        EntryS  "R0-R3,R11"
d271 1
a271 1
        EXITS
d275 2
a276 2
        STR     R0,[SP,#Proc_RegOffset] ; store error pointer
        EXIT
@


4.3.2.2
log
@  Lots of fixes.
Detail:
  Several stack imbalances and missing conditions on instructions fixed.
  Some flag removal code sequences improved (RSB rn,pc,pc:SUB rn,lr,rn)
Admin:
  Built both 26 and 32-bit versions - neither tested.

Version 4.44, 4.1.2.2. Tagged as 'PDModules-4_44-4_1_2_2'
@
text
@d264 1
a264 1
        EORS    R3,R1,R2                ; killing the current pdumper?
d272 3
a274 3
        ; mark as no pdumper or pending data (R3 was 0 from EORS)
        STREQ   R3,printer_pdumper_pointer
        STREQ   R3,pending_pdumper_command
@


4.3.2.3
log
@  More fixes.
Detail:
  26-bit builds work again - a stack imbalance in PDriverDP has been fixed.
  Tidied up some nasty code that effected an EOR in a convoluted manner.  It
    now uses an EOR instruction instead of loads of TSTs and TEQP.
Admin:
  26-bit build tested very briefly - no longer dies.
  32-bit build dies still.

Version 4.44, 4.1.2.3. Tagged as 'PDModules-4_44-4_1_2_3'
@
text
@d182 1
a182 1
        CMP     R0,#0                   ; any pending info? (clears V for call to configure_setdriver)
@


4.2
log
@Spinner branch merged
@
text
@d16 1
a16 1
                                                                                           
d23 1
a23 1
;                     
d44 1
a44 1
                   
d57 1
a57 1
                
d87 1
a87 1
;                     
d102 1
a102 1
                   
d113 2
a114 2
     
        LDR     R8,=VersionNumber
a118 2
      [ VersionNumber >= 323

d128 1
a128 2
05      
      ]
d160 1
a160 1
        STMIA   R0,{R1-R6}              ; setup the record              
d166 1
a166 1
                   
d173 1
a173 1
       
d207 1
a207 1
;                     
a220 2
      [ VersionNumber >= 323

d230 1
a230 1
        
a233 1
      ]
d253 1
a253 1
  
d270 1
a270 1
        
d300 1
a300 1
 
@


4.1
log
@Initial revision
@
text
@d116 1
a116 1
        ADRGT   R0,ErrorBlock_PDumperTooOld
d181 1
a181 1
        ADRNE   R2,pending_pdumper_command
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@   Use buffer in workspace for MessageTrans.
   Added 'Colour' debugging flag.
   Do not pass SpriteV calls to pdriver if a Wimp error box is open.
@
text
@d116 1
a116 1
        ADRGTL	r0,ErrorBlock_PDumperTooOld
@


4.1.7.3
log
@Fixed data abort on init
@
text
@d181 1
a181 1
        ADRNEL  R2,pending_pdumper_command
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

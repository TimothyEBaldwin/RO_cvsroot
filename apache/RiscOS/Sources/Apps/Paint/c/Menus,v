head	4.17;
access;
symbols
	Paint-2_23-1:4.17
	Paint-2_23:4.17
	Paint-2_22:4.16
	Paint-2_21:4.16
	Paint-2_20:4.15
	Paint-2_19:4.14
	Paint-2_18:4.14
	Paint-2_17:4.14
	Paint-2_16:4.14
	Paint-2_15:4.13
	Paint-2_14:4.12
	Paint-2_13:4.12
	Paint-2_12:4.12
	Paint-2_11:4.11
	Paint-2_10:4.11
	Paint-2_09:4.11
	Paint-2_08:4.11
	Paint-2_07:4.11
	Paint-2_06:4.11
	Paint-2_05:4.11
	Paint-2_04:4.11
	Paint-2_03:4.9
	Paint-2_02:4.8
	Paint-2_01:4.7
	Paint-2_00:4.6
	Paint-1_99:4.6
	Paint-1_98:4.5
	Paint-1_97:4.4
	RO_5_07:4.4
	Paint-1_96:4.4
	Paint-1_95:4.2
	Paint-1_94:4.1.1.1
	Ursula_merge:4.1.1.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.1.1
	Ursula_RiscPC:4.1.1.1.0.6
	rthornb_UrsulaBuild-19Aug1998:4.1.1.1
	UrsulaBuild_FinalSoftload:4.1.1.1
	rthornb_UrsulaBuild-12Aug1998:4.1.1.1
	aglover_UrsulaBuild-05Aug1998:4.1.1.1
	rthornb_UrsulaBuild-29Jul1998:4.1.1.1
	rthornb_UrsulaBuild-22Jul1998:4.1.1.1
	rthornb_UrsulaBuild-15Jul1998:4.1.1.1
	rthornb_UrsulaBuild-07Jul1998:4.1.1.1
	rthornb_UrsulaBuild-17Jun1998:4.1.1.1
	rthornb_UrsulaBuild-10Jun1998:4.1.1.1
	rthornb_UrsulaBuild-03Jun1998:4.1.1.1
	rthornb_UrsulaBuild-27May1998:4.1.1.1
	rthornb_UrsulaBuild-21May1998:4.1.1.1
	rthornb_UrsulaBuild_01May1998:4.1.1.1
	Daytona:4.1.1.1.0.4
	Daytona_bp:4.1.1.1
	Ursula:4.1.1.1.0.2
	Ursula_bp:4.1.1.1
	RO_3_71:4.1.3.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.17
date	2017.11.11.12.32.36;	author rool;	state Exp;
branches;
next	4.16;
commitid	7xcfho84RnWggCeA;

4.16
date	2017.05.20.08.52.53;	author rool;	state Exp;
branches;
next	4.15;
commitid	igjazMDLAvE4F6Sz;

4.15
date	2015.10.14.20.42.31;	author jlee;	state Exp;
branches;
next	4.14;
commitid	zi4LAThs0ylWm7Fy;

4.14
date	2014.03.27.23.18.34;	author jlee;	state Exp;
branches;
next	4.13;
commitid	zsqBYJ6Lrncsqoux;

4.13
date	2013.08.06.23.23.02;	author jlee;	state Exp;
branches;
next	4.12;
commitid	8Tn6wOJxX7xmWr0x;

4.12
date	2012.08.22.07.18.10;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	jkPgRNvjP7QROvhw;

4.11
date	2010.12.07.21.11.59;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2010.12.06.22.30.45;	author rsprowson;	state Exp;
branches;
next	4.9;

4.9
date	2010.12.05.19.04.57;	author rsprowson;	state Exp;
branches;
next	4.8;

4.8
date	2010.11.29.20.55.25;	author rsprowson;	state Exp;
branches;
next	4.7;

4.7
date	2009.05.29.02.09.30;	author pnaulls;	state Exp;
branches;
next	4.6;

4.6
date	2007.09.18.13.14.20;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2007.07.27.21.23.33;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2003.02.26.20.49.17;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2003.02.21.11.58.24;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2003.01.13.11.15.33;	author rsprowson;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.20.09;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1;
next	;

4.1.1.1
date	96.11.05.09.20.09;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.28.19;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.17
log
@Add mousewheel zoom/scroll and auto scrolling of selected tools
Detail:
  The mouse wheel can now be used to
  * scroll up/down
  * +shift to scroll left/right
  * +control to zoom in/out
  on an open sprite editing window.
  The sprite editing window will auto scroll when the mouse approaches the border with
  * the move whole sprite "hand" tool
  * the copy block "camera" tool
  * the move block "scissors" tool
Admin:
  Submission for the Paint bounty.

Version 2.23. Tagged as 'Paint-2_23'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* > c.Menus
 *
 *  Paint: Arthur 2 sprite editor
 *   Menu handling
 *
 *  Author: A.P. Thompson
 *  Others:
 *     DAHE David Elworthy
 *     JAB  James Bye
 *     CDP  Christopher Partington (Cambridge Systems Design)
 *     TMD  Tim Dobson
 *
 *  DAHE, 28 Aug  89 - internationalisation
 *         1 Sept 89 - made menu divisions symbolic
 *         6 Sept 89 - enable nulls during dboxtcol
 *  JAB,   3 Oct  90 - Changed sprite creation stuff
 *  JAB,  26 Oct  90 - Gave all dboxes raw event handlers for
 *                     interactive help purposes
 *  JAB,  30 Oct  90 - Added interactive menu help
 *  JAB,  22 Oct  90 - Now auto opens sprite window on sprite creation
 *  JAB,  04 Feb  91 - Fixed bug where lanscape/portrait always = portrait on
 *                     start up
 *  JAB,  06 May  91 - Added 'Misc' entry to sprite menu
 *  JAB,  08 May  91 - Added 'Misc' entry to sprite filer menu
 *  CDP,  20 Feb  92
 *     Added FIX9544: part of fix of G-RO-9544 (large shear factor causes
 *     arithmetic exception). Checks flex requests. See also PSprite.c.
 *     Added FIX0770: fixes RP-0770 (adjust size smaller causes crash) by
 *     substantial changes to menus_ensure_size (flex de/allocator).
 *     Added FIXDELSPR: fixes deletion of sprites causing crash, a bug that
 *     only showed up when the flex routine was sorted out.
 *  CDP,  27 Feb  92
 *     Added FIX0553: fixes a bug similar to RP-0553 (summary window not
 *     updated on create sprite) but copy rather than create sprite.
 *  TMD,  11 Mar  92
 *     Added FIX1764: fixes copy sprite to same name not giving error
 *  TMD,  12 Mar  92
 *     Disallow zero for width or height in 'Adjust size'
 */

#include <assert.h>
#include <ctype.h>
#include <stddef.h>
#include <swis.h>
#include <signal.h>
#include "Global/FileTypes.h"
#include "Global/VduExt.h"
#include "Global/Sprite.h"

#include "bbc.h"
#include "colourmenu.h"
#include "colourtran.h"
#include "dboxquery.h"
#include "dboxtcol.h"
#include "flex.h"
#include "help.h"
#include "magnify.h"
#include "msgtrans.h"
#include "saveas.h"
#include "visdelay.h"
#include "werr.h"
#include "wimpt.h"
#include "xfersend.h"

#include "m.h"
#include "ftrace.h"
#include "main.h"
#include "PSprite.h"
#include "Menus.h"
#include "SprWindow.h"
#include "ToolWindow.h"
#include "Tools.h"
#include "Colours.h"
#include "MenuD.h"
#include "trace.h"
#include "PaintLib.h"
#include "AltRename.h"

#define COPY_N(s1, s2, n) (sprintf ((s1), "%.*s", (n), (s2)), s1) /*this is strncpy() really*/

static int Do_Print (char *, void *);

typedef struct
{
  union
  {
    char       orgname[NAME_LIMIT + 1];
    int        orgsize;
  } type;
  main_sprite *orgsprite;
} sprite_tosort;

/***********************
 * Static menu handles *
 ***********************/

static menu
  sprite_main_menu,
  sprite_save_menu,
  sprite_paint_menu,
  sprite_edit_menu,
  spritefile_main_menu,
  spritefile_misc_menu,
  filedisplay_menu,
  sprite_colour_menu,
  sprite_selection_menu,
  sprite_misc_menu;

static char Spritename [22];
static main_sprite *hit_sprite;

static int Row;
static int Column;

/* data for graphic entry of insert/delete */

static int insdel_pending = 0; /* to frig entry by click in sprite window */
static int insdel_rowfield;
static int insdel_colfield;
static int insdel_row;
static int insdel_col;
static main_sprite *insdel_sprite;
static toolwindow_block *insdel_tool;
static dbox insdel_d;

static char
  spritenamebuffer [13],
  rotatebuffer [13] = "0",
  scalebuffer [13] = "1",
  shearbuffer [13] = "0";

/*************************************
 *   Static variables for printing   *
 *************************************/

#define PRINT_INCHES_TO_72000 72000.0
#define PRINT_CM_TO_72000 (18144.0*72000.0/ (180<<8))
 /* above is at least the same as Draw uses */

print_positionstr
    menus_print_where = {0, 0}, menus_print_last_where = {0, 0};
static int print_copies = 1;
static int print_landscape = 1;
static main_scaling_block print_scale = {1, 1, 1, 1};
static double print_scalefactor = PRINT_INCHES_TO_72000;

/*************************************
 *   Generate sprite info dbox       *
 *************************************/
static char *yesno (int from)

{ ftracef0 ("yesno\n");
  return msgs_lookup (from? "PntG3": "PntG4");
}

static void display_sprite_info (main_sprite *sprite)

{ dbox d;
  psprite_info info;
  char temp[64];

  ftracef0 ("display_sprite_info\n");
  psprite_read_full_info (sprite, &info);

  if ((d = dbox_new ("spriteInfo")) != 0)
  { dbox_setfield   (d, d_Info_Name, info.name);
    if ((unsigned) info.mode < 256u)
    {
      dbox_setnumeric (d, d_Info_Mode, info.mode);
    }
    else
    {
      sprintf(temp,"&%08x",info.mode);
      dbox_setfield (d, d_Info_Mode, temp);
    }

    dbox_setnumeric (d, d_Info_Size,    info.size);

    strcpy(temp,psprite_get_colours(info.mode));
    /* Attempt to extract the mode flags manually, so that we can display
       somewhat sensible information even if the kernel doesn't recognise the
       format. E.g. prior to full CMYK support in the kernel+SpriteExtend,
       RISC OS 5 will report CMYK sprites as being RGB */
    int modeflags;
    if(((unsigned) info.mode) < 256u)
    {
      /* Mode number - ask the OS, just in case something special */
      modeflags = bbc_modevar(info.mode,bbc_ModeFlags);
    }
    else if(((info.mode>>27) & 15) == SpriteType_RISCOS5)
    {
      /* RISC OS 5 mode word */
      modeflags = info.mode & 0xff00;
    }
    else
    {
      /* RISC OS 3.5 mode word */
      if(((info.mode>>27) & 15) == SpriteType_CMYK)
        modeflags = ModeFlag_DataFormatFamily_Misc;
      else
        modeflags = 0;
    }
    unsigned int colours = colours_count(sprite);
    if((modeflags != -1) && ((colours > 256) || (modeflags & ModeFlag_DataFormat_Mask)))
    {
      switch(modeflags & ModeFlag_DataFormatFamily_Mask)
      {
      case ModeFlag_DataFormatFamily_RGB:
        if(modeflags & ModeFlag_DataFormatSub_Alpha)
          strcat(temp," A");
        else
          strcat(temp," ");
        if(modeflags & ModeFlag_DataFormatSub_RGB)
          strcat(temp,"RGB");
        else
          strcat(temp,"BGR");
        break;
      case ModeFlag_DataFormatFamily_Misc:
        if(!(modeflags & ModeFlag_DataFormatSub_Mask))
          strcat(temp," CMYK");
        break;
      case ModeFlag_DataFormatFamily_YCbCr:
        strcat(temp," YCbCr"); /* Skip giving sub-format info */
        break;
      }
    }
    dbox_setfield (d, d_Info_Colours, temp);

    if((((unsigned) info.mode) >= 256u) && (((info.mode >> 27) & 15) != 15))
    {
      /* Looks like RISC OS 3.5 mode word, extract DPI manually, in case there's something unusual there */
      int xdpi = (info.mode >> 1) & 8191;
      int ydpi = (info.mode >> 14) & 8191;
      sprintf(temp,msgs_lookup("PntGF"),(float)xdpi,(float)ydpi);
      dbox_setfield(d, d_Info_DPI, temp);
    }
    else
    {
      int xeig = bbc_modevar(info.mode,bbc_XEigFactor);
      int yeig = bbc_modevar(info.mode,bbc_YEigFactor);
      
      if((xeig == -1) || (yeig == -1))
        dbox_setfield(d, d_Info_DPI, "?");
      else
      {
        sprintf(temp,msgs_lookup("PntGF"),180.0f/(float)(1L<<xeig),180.0f/(float)(1L<<yeig));
        dbox_setfield(d, d_Info_DPI, temp);
      }
    }

    transparency_type transparency = psprite_transparency_type(sprite);    

    static char *masktypes[] =
    {
      "PntG2", "PntG4", // transparency_type_none
      "PntG2", "PntG3", // transparency_type_onoffmask
      "PntG2", "PntGI", // transparency_type_alphamask
      "PntG7", "PntGE", // transparency_type_alphachannel
    };
    dbox_setfield (d, d_Info_MaskType, msgs_lookup(masktypes[transparency*2]));
    int alphabits=8;
    if(transparency == transparency_type_alphachannel)
    {
      switch(colours)
      {
      case 4096:
        alphabits = 4;
        break;
      case 32768:
        alphabits = 1;
        break;
      }
    }
    sprintf(temp,msgs_lookup(masktypes[transparency*2+1]),alphabits);
    dbox_setfield (d, d_Info_MaskSize, temp);

    if ((colours == 256) && info.palette)
    {
      if (info.truepalette)
        dbox_setfield (d, d_Info_Palette, msgs_lookup("PntGH"));
      else
        dbox_setfield (d, d_Info_Palette, msgs_lookup("PntGD"));
    }
    else
      dbox_setfield (d, d_Info_Palette, yesno(info.palette));

    if (info.width == -1)
      dbox_setfield (d, d_Info_Width, "?");
    else
      dbox_setnumeric (d, d_Info_Width, info.width);

    if (info.height == -1)
      dbox_setfield (d, d_Info_Height, "?");
    else
      dbox_setnumeric (d, d_Info_Height, info.height);

    int type = (info.mode>>27) & 31;
    if(type && !(info.mode & 1))
      type = -1;
    switch(type)
    {
    case SpriteType_Old:
      /* Arc */
      if(((unsigned) info.mode) >= 128u)
        dbox_setfield(d, d_Info_Compat, "?"); /* Shadow bit set or not mode number */
      else
        dbox_setfield(d, d_Info_Compat, msgs_lookup("PntG8"));
      break;
    case SpriteType_New1bpp:
    case SpriteType_New2bpp:
    case SpriteType_New4bpp:
    case SpriteType_New8bpp:
    case SpriteType_New16bpp:
    case SpriteType_New32bpp:
      /* 3.5 */
      dbox_setfield(d, d_Info_Compat, msgs_lookup("PntG9"));
      break;
    case SpriteType_CMYK:
    case 16+SpriteType_CMYK:
      /* CMYK -> Select */
      dbox_setfield(d, d_Info_Compat, msgs_lookup("PntGC"));
      break;
    case 16+SpriteType_New1bpp:
    case 16+SpriteType_New2bpp:
    case 16+SpriteType_New4bpp:
    case 16+SpriteType_New8bpp:
    case 16+SpriteType_New16bpp:
    case 16+SpriteType_New32bpp:
      /* Alpha masks -> Select, 5.21 */
      dbox_setfield(d, d_Info_Compat, msgs_lookup("PntGG"));
      break;
    case SpriteType_New64K:
    case 16+SpriteType_New64K:
      /* 64K -> RISC OS 5.21, 6 */
      dbox_setfield(d, d_Info_Compat, msgs_lookup("PntGB"));
      break;
    case SpriteType_RISCOS5:
    case 16+SpriteType_RISCOS5:
      /* RISC OS 5 types */
      /* However, only list types which are known to be fully supported */
      type = (info.mode>>20) & 127;
      if((info.mode & 0xf000f) != 1)
        type = -1;
      switch(type)
      {
      case SpriteType_New1bpp:
      case SpriteType_New2bpp:
      case SpriteType_New4bpp:
      case SpriteType_New8bpp:
        /* Nonstandard but valid: palettised sprite with RO 5 mode word */
        if(!(info.mode & 0xff00)) /* Can't have any mode flags set */
        {
          dbox_setfield(d, d_Info_Compat, msgs_lookup("PntGA"));
          break;
        }
        dbox_setfield(d, d_Info_Compat, "?");
        break;
      case SpriteType_New16bpp:
      case SpriteType_New32bpp:
      case SpriteType_New4K:
        /* RGB flag possible. Alpha flag only possible if no mask. */
        if(!(info.mode & 0x3f00)
           && !((info.mode & ModeFlag_DataFormatSub_Alpha) && (info.mask || (info.mode & 0x80000000))))
        {
          dbox_setfield(d, d_Info_Compat, msgs_lookup("PntGA"));
          break;
        }
        dbox_setfield(d, d_Info_Compat, "?");
        break;
      case SpriteType_New64K:
        /* Only RGB flag possible */
        if(!(info.mode & 0xbf00))
        {
          dbox_setfield(d, d_Info_Compat, msgs_lookup("PntGA"));
          break;
        }
        dbox_setfield(d, d_Info_Compat, "?");
        break;
      case SpriteType_CMYK:
        /* Nonstandard but valid. Make sure mode flags agree with colourspace. */       if((info.mode & 0xff00) == 0x1000)
        {
          dbox_setfield(d, d_Info_Compat, msgs_lookup("PntGA"));
          break;
        }
        dbox_setfield(d, d_Info_Compat, "?");
        break;
      default:
        /* Not defined or not fully supported yet */
        dbox_setfield(d, d_Info_Compat, "?");
        break;
      }
      break;
    default:
      /* Not defined or not fully supported yet */
      dbox_setfield(d, d_Info_Compat, "?");
      break;
    }

    dbox_show (d);
    dbox_raw_eventhandler (d, &help_dboxrawevents, (void *) "PntHA");
  }
}
/********************************
 * Generate info dbox           *
 ********************************/

static void show_info_box (void)

{ dbox d;

  ftracef0 ("show_info_box\n");
  if ((d = dbox_new ("progInfo"))!= 0)
  { dbox_setfield (d, d_Prog_Name,     msgs_lookup ("Pnt00"));
    dbox_setfield (d, d_Prog_Copy,     msgs_lookup ("PntM1"));
    dbox_setfield (d, d_Prog_WhatIsIt, msgs_lookup ("PntM2"));
    dbox_setfield (d, d_Prog_Version,  msgs_lookup ("_Version"));
    dbox_show (d);

    dbox_raw_eventhandler (d, &help_dboxrawevents, (void *) "PntH8");
  }
}

/********************************
 *  Force rethink on a file     *
 ********************************/

static void iconsize_has_changed (main_window *window)

{ main_file *file = &window->data->file;

  ftracef0 ("iconsize_has_changed\n");
  psprite_set_plot_info (file);

  window->data->file.lastwidth = 0; /*force screen update*/
  main_set_extent (window);
  main_force_redraw (window->handle);
}

void menus_file_has_changed (main_window *window)

{ main_file *file = &window->data->file;

  ftracef0 ("menus_file_has_changed\n");
  psprite_recalculate_offsets (file);
  iconsize_has_changed (window);
}

/****************************
 * Common create/copy code  *
 ****************************/

void menus_sprite_new (main_window *window, BOOL hack_palette)

{ main_file *file = &window->data->file;
  main_sprite **sprptr, *sprite;
  int o, offset = 0 /**/, spriteno;

  ftracef0 ("menus_sprite_new\n");
  /* find linked list end */
  for (sprptr = &file->sprites; *sprptr != NULL; sprptr = &(*sprptr)->link)
    ;

  /*Find the right offset and spriteno - they are actually used by
    psprite_new to get the number of colours.*/
  spriteno = 0;
  for (o = psprite_first (&file->spritearea); o != 0;
      o = psprite_next (&file->spritearea, o))
  { offset = o;
    spriteno++;
  }

  ftracef2 ("creating main_sprite for offset %d, spriteno %d\n",
      offset, spriteno);
  if ((sprite = *sprptr = psprite_new (offset, spriteno, file) /* at end */) == NULL)
    werr (FALSE, msgs_lookup ("PntEG"));

  menus_file_has_changed (window);   /* force recache of offsets */
  sprite->gcol.colour = colours_count (sprite) - 1;
  sprite->gcol.alpha = 255;
  sprite->gcol.ecf = FALSE;
  sprite->gcol2.colour = 0;
  sprite->gcol2.alpha = 255;
  sprite->gcol2.ecf = FALSE;

  if (hack_palette) menus_hack_palette (sprite);
  psprite_set_colour (sprite);
  psprite_set_brush_translation (sprite);
}

/*************************************
 * Ensure spritearea large enough    *
 *************************************/

BOOL menus_ensure_size (sprite_area **sarea, int bytesneeded)

{ int bytesfree = (*sarea)->size - (*sarea)->freeoff;
  int newsize;

  /*
   * OK: this is what I think menus_ensure_size() is supposed to do.
   *
   * bytesneeded > 0: if not at least <bytesneeded> bytes free in sprite area,
   *                  extend it.
   * bytesneeded < 0: reduce size of sprite area by <bytesneeded> bytes. This
   *                  used to do this regardless but I have changed it so
   *                  that it never reduces it such that the free offset points
   *                  outside the area. This should fix many bugs.
   * bytesneeded = 0: reduce size of sprite area to exactly what is needed by
   *                  the contents of the area.
   *
   * Hence I expect an operation that changes the size of a sprite area to
   * do an menus_ensure_size( , 0) on completion to release the free space. This seems
   * to be what is done so was probably the intention.
   *
   * Christopher Partington  18-Feb-1992
   */

  ftracef1 ("menus_ensure_size of %d\n", bytesneeded);
  ftracef3("bytesfree = %d - %d = %d\n", (*sarea)->size, (*sarea)->freeoff,
                                         bytesfree);
  #if TRACE
    assert (bytesfree >= 0);
  #endif

  ftracef1 ("menus_ensure_size: %d bytes free\n", bytesfree);

  if (bytesneeded > 0 && bytesneeded <= bytesfree)
  { ftracef0 ("... enough space already - do nothing\n"); /*JRC*/
    return TRUE;
  }

  bytesneeded -= bytesfree;         /* amount needed */
  if (bytesneeded > 0)
    bytesneeded += 256;             /* and a little headroom */

  ftracef1 ("... do flex_extend of %d\n", bytesneeded);

  if (bytesneeded < 0)
  {
    ftracef1("shrinking area, change = %d bytes\n", bytesneeded);
    /* shrinking area - make sure that ok to do so */
    if ((*sarea)->size + bytesneeded < (*sarea)->freeoff)
    {
       bytesneeded = - ((*sarea)->size - (*sarea)->freeoff);
       ftracef1("...would be too much - change by %d instead\n", bytesneeded);
    }
  }
  if (bytesneeded == 0)
  {
    ftracef0("area is just the right size - no change\n");
    return TRUE;
  }

  newsize = flex_size((flex_ptr) sarea) + bytesneeded;
  /* check for overflow before calling flex */
#if TRACE
  if (newsize < 0)
     ftracef0("arithmetic overflow, so not enough memory\n");
#endif
  if (newsize < 0 || !flex_extend((flex_ptr) sarea, newsize))
    return FALSE;

  (*sarea)->size += bytesneeded;
  ftracef1 ("menus_ensure_size: leaving area with %d bytes free\n",
      (*sarea)->size - (*sarea)->freeoff);
  return TRUE;
}

/**********************************
 * Check for sprite existence     *
 **********************************/

BOOL menus_sprite_exists (sprite_area *sarea, char *name)

{ sprite_id sid;

  ftracef0 ("menus_sprite_exists\n");
  sid.s.name = name; sid.tag = sprite_id_name;
  if (!sprite_select (sarea, &sid))
  { werr (FALSE, msgs_lookup ("PntE6"), name);
    return TRUE;
  }

  return FALSE;
}

/************************************************
 * xfersend handlers for sprite and file saving *
 ************************************************/

static BOOL myxfersend (int filetype, char *name, int estsize,
    xfersend_saveproc p1, xfersend_sendproc p2, xfersend_printproc p3,
    void *handle)

{ wimp_w nullc = win_idle_event_claimer ();
  BOOL res;

  ftracef0 ("myxfersend\n");
  main_claim_idle ((wimp_w) -1);

  ftracef1 ("myxfersend: calling saveas (..., \"%s\", ...)\n", name);
  res = saveas (filetype, name, estsize, p1, p2, p3, handle);

  main_claim_idle (nullc);
  return res;
}

static int My_File_Is_Safe;
static int File_Saved;

static BOOL save_file_proc (char *filename, void *handle)

{ main_window *window = (main_window *) handle;
  os_error *error = NULL;

  ftracef1 ("save_file_proc %s\n", filename);

  visdelay_begin ();

  if ((error = sprite_area_save (window->data->file.spritearea,
      filename)) != NULL)
    goto finish;

  if (My_File_Is_Safe || xfersend_file_is_safe ())
  { main_set_title (window, filename);
    window->data->file.modified = 0;
    main_set_extent (window);
  }

  File_Saved = 1;

finish:
  visdelay_end ();

  return wimpt_complain (error) == NULL;
}

static BOOL save_sprite (char *filename, void *shandle)

{ main_sprite *sprite = (main_sprite *) shandle;
  sprite_header *spriteaddr = psprite_address (sprite);
  int spritesize = spriteaddr->next, handle = 0, hdr [3];
  os_regset reg_set;
  os_filestr file_str;
  os_gbpbstr gbpb_str;
  os_error *error;
  char *txt = NULL;

  ftracef1 ("save_sprite %s\n", filename);

  visdelay_begin ();

  /* Open file */
  reg_set.r [0] = 0x8C;
  reg_set.r [1] = (int) filename;
  if ((error = os_find (&reg_set)) != NULL)
  { txt = error->errmess;
    goto finish;
  }
  handle = reg_set.r [0];

  if (handle == 0)
  { /*In case the FileSwitch bug returns a 0 handle.*/
    txt = msgs_lookup ("PntE4");
    goto finish;;
  }

  hdr [0] = 1;               /* no of sprites */
  hdr [1] = 16;              /* offset to sprite */
  hdr [2] = spritesize + 16; /* offset to first free */

  /* GBPB the header */
  gbpb_str.action = 2;
  gbpb_str.file_handle = handle;

  gbpb_str.data_addr = hdr;
  gbpb_str.number = sizeof hdr;
  if ((error = os_gbpb (&gbpb_str)) != NULL)
  { txt = error->errmess;
    goto finish;
  }

  gbpb_str.data_addr = spriteaddr;
  gbpb_str.number = spritesize;
  if ((error = os_gbpb (&gbpb_str)) != NULL)
  { txt = error->errmess;
    goto finish;
  }

finish:
  if (handle != 0)
  { /* Close the file */
    os_error *error1;

    reg_set.r [0] = 0;
    reg_set.r [1] = handle;
    error1 = os_find (&reg_set);
    if (txt == NULL && error1 != NULL) txt = error1->errmess;

    /*Set the file to type "Sprite"*/
    file_str.action = 18;
    file_str.name = filename;
    file_str.loadaddr = FileType_Sprite;
    error1 = os_file (&file_str);
    if (txt == NULL && error1 != NULL) txt = error1->errmess;
  }

  visdelay_end ();

  if (txt != NULL)
    werr (FALSE, txt, filename);

  return txt == NULL;
}

#if 0
static char vdu19bytes [] =
  { 0, 16,     1, 16,     2, 16,     3, 16,
    4, 16,     5, 16,     6, 16,     7, 16,
    8, 16,     9, 16,    10, 16,    11, 16,
   12, 16,    13, 16,    14, 16,    15, 16,
    0, 24,     1, 25,     2, 25,     3, 25 /*oops*/
  };
#endif

static void build_sprite_palette_file (main_sprite *sprite,
    char *palette)

{ int len, i;
  char *p = palette;
  os_error *error = NULL;

  static int *Palette = NULL;

  ftracef0 ("build_sprite_palette_file\n");
  if ((error = psprite_build_palette (sprite, &Palette)) != NULL)
    goto finish;

  len = psprite_palsize (sprite)/sizeof (int);

  for (i = 0; i < len; i++)
  { *p++ = 19;
    *p++ = i;
    *p++ = 16;
    *p++ = Palette [i] >> 8;
    *p++ = Palette [i] >> 16;
    *p++ = Palette [i] >> 24;
  }

  if (len == 16)
  { /*Append the current mouse and border colours, for historical reasons.*/
    wimp_palettestr palette_str;

    if ((error = wimp_readpalette (&palette_str)) != NULL)
      goto finish;
    for (i = 0; i < 4; i++)
    { *p++ = 19;
      *p++ = i;
      *p++ = i == 0? 24: 25;
      *p++ = palette_str.c [16 + i].bytes.red;
      *p++ = palette_str.c [16 + i].bytes.green;
      *p++ = palette_str.c [16 + i].bytes.blue;
    }
  }

finish:
  wimpt_noerr (error);
}

static BOOL save_sprite_palette (char *filename, void *shandle)

{ main_sprite *sprite = (main_sprite *) shandle;
  char palette [6*256];
  os_regset r;
  int len, oldattribs = -1;
  BOOL saved;

  ftracef1 ("save_sprite_palette %s\n", filename);

  /*Work out how long this palette file is.*/
  len = 6*(psprite_palsize (sprite)/sizeof (int));
  if (len == 6*16) len += 6*4;

  build_sprite_palette_file (sprite, palette);

  r.r [0] = 17; /* Read cat info */
  r.r [1] = (int) filename;
  (void) os_swix (OS_File, &r);
  /* if something is already there, remember its attributes */
  if (r.r [0] != 0) oldattribs = r.r [5];

  r.r [0] = 10;
  r.r [2] = FileType_Palette;
  r.r [4] = (int) &palette;
  r.r [5] = (int) &palette + len;

  visdelay_begin ();
  saved = wimpt_complain (os_swix (OS_File, &r)) == NULL;

  if (oldattribs != -1) {
    r.r [0] = 4; /* Write attribs */
    r.r [5] = oldattribs;
    (void) os_swix (OS_File, &r);
  };
  
  visdelay_end ();

  return saved;
}

static BOOL mysendbuf (char **buffer, int size, int *max, int fudge)

{ BOOL OK = TRUE;
  int done = 0;

  ftracef0 ("mysendbuf\n");
  while (done < size && OK)
  { int buffsize = size - done;

    if (*max < buffsize) buffsize = *max;
    OK = xfersend_sendbuf (*buffer + done + fudge, buffsize);
    done += buffsize;
  }

  return OK;
}

static BOOL buffer_file_proc (void *handle, int *max)

{ main_window *window = (main_window *)handle;
  sprite_area **sarea = &window->data->file.spritearea;

  ftracef1 ("buffer_file_proc %s\n", window->data->file.filename);
  return File_Saved = mysendbuf ((char **) sarea, (*sarea)->freeoff - 4,
      max, sizeof (int));
}

static BOOL print_file_proc (char *filename, void *handle)

{ main_sprite *sprite = ((main_window *) handle)->data->file.sprites;

  filename = filename; /*for Norcroft*/
  return sprite != NULL && menus_do_print (sprite)? xfersend_printPrinted:
      xfersend_printFailed;
}

static BOOL buffer_sprite (void *shandle, int *max)

{ main_sprite *sprite = (main_sprite *)shandle;
  int  hdr [3], i;
  char name [13];
  sprite_header *spriteaddr = psprite_address (sprite);
  int spritesize = spriteaddr->next;
  char *buffer;

  ftracef0 ("buffer_sprite\n");
  saveas_read_leafname_during_send (name, 13);
  ftracef1 ("sprite name is \"%.12s\"\n", name);

  if (strlen (name) == 0)
  { werr (FALSE, msgs_lookup ("PntE7"));
    return 0;
  }

  for (i = 0 ; i < 13 && name [i] != 0 ; i++) name [i] = tolower (name [i]);

  ftracef2 ("Buffering out sprite @@ %x, size %d\n", spriteaddr, spritesize);
  hdr [0] = 1;       /* no of sprites */
  hdr [1] = 16;      /* offset to sprite */
  hdr [2] = spritesize + 16; /* offset to first free */

  buffer = (char *)hdr;
  if (!mysendbuf (&buffer, 12, max, 0)) return 0;
  if (!mysendbuf ((char **)&sprite->file->spritearea,
                 4, max, sprite->offset)) return 0;

  buffer = (char *) &name;
  if (!mysendbuf (&buffer, 12, max, 0)) return 0;

  return mysendbuf ((char **)&sprite->file->spritearea,
                   spritesize, max, sprite->offset+16);
}

static BOOL buffer_sprite_palette (void *shandle, int *max)

{ main_sprite *sprite = (main_sprite *)shandle;
  char palette [6*256], *pp = palette;
  int len;

  ftracef0 ("buffer_sprite_palette\n");

  /*Work out how long this palette is.*/
  len = 6*(psprite_palsize (sprite)/sizeof (int));
  if (len == 6*16) len += 6*4;

  build_sprite_palette_file (sprite, palette);
  return mysendbuf (&pp, len, max, 0);
}

static void menus_save_selection (main_window *window)

{ ftracef0 ("menus_save_selection\n");

  if (window->selection.count==1)
  { main_sprite *sprite;

    /* Just one selected, find it, and save it on its own with
       the sprite name as the filename instead */
    for (sprite = window->data->file.sprites; sprite != NULL; sprite = sprite->link)
    { if (sprite->flags & MSF_SELECTED)
      { menus_save_sprite (sprite);
        break;
      }
    }
    return;
  }

  myxfersend (FileType_Sprite, msgs_lookup ("PntG6"),
              main_selection_file_size (window),
              main_save_selection, 0, 0, window);
}

void menus_save_sprite (main_sprite *sprite)

{ char name [NAME_LIMIT + 1];

  ftracef0 ("menus_save_sprite\n");
  (void) COPY_N (name, psprite_address (sprite)->name, NAME_LIMIT);

  ftracef1 ("sprite called \"%s\"\n", name);

  myxfersend (FileType_Sprite, name,
              psprite_address (sprite)->next + sizeof (sprite_area),
              &save_sprite, &buffer_sprite, &Do_Print, sprite);
}

BOOL menus_save_file (main_window *window, int askfor_name)

{ char *name = window->data->file.filename;
  File_Saved = 0;

  ftracef0 ("menus_save_file\n");
  if (name == NULL)
  { name = msgs_lookup ("PntF1");
    askfor_name = TRUE; /*JRC 12 July 1991*/
  }

  if (askfor_name)
  { My_File_Is_Safe = FALSE;
    ftracef0 ("menus_save_file: myxfersend\n");
    myxfersend (FileType_Sprite, name, window->data->file.spritearea->size,
        &save_file_proc, &buffer_file_proc,
        &print_file_proc, /*Protocol now in xfersend(), immediate printing
          allowed. Was NULL. JRC 4 Apr 1992*/
        /*FIX G-RO-7139 JRC 16 Oct '91 Use new printer protocol - was
          print_spritefile*/
        window);
  }
  else
  { My_File_Is_Safe = TRUE;
    save_file_proc (name, window);
  }

  return File_Saved;
}

/*******************************
 *  Add/delete columns/rows    *
 *******************************/

static void Change_Size (sprite_area **sarea, sprite_id *sid,
    main_sprite *sprite, int number, BOOL rows, int at)

{ BOOL insert = number > 0, hourglass = FALSE;
  main_sprite_window *sprw;
  psprite_info info;
  char *msg = NULL;
  os_error *error;

  ftracef3 ("Change_Size: number %d, rows %s, at %d\n",
      number, WHETHER (rows), at);
  sprwindow_remove_wastage (sprite);

  psprite_read_full_info (sprite, &info);
  ftracef2 ("BEFORE: sprite is %d columns by %d rows\n",
      info.width, info.height);
  if (at < 0) at = 0;      /* can menu outside the sprite */
  if (rows)
    {if (at > info.height) at = info.height;}
  else
    {if (at > info.width) at = info.width;}

  ftracef4 ("Insert %d %s%s at %d\n", number, rows? "row": "column",
      number == 1? "": "s", at);

  if (insert)
  { int newsize;

    newsize = psprite_size (info.width + (!rows? number: 0),
        info.height + (rows? number: 0), info.mode, info.mask,
        !info.palette? 0: !info.truepalette? 1: 2);
    ftracef2 ("newsize %d, oldsize %d\n", newsize, info.size);
    if (!menus_ensure_size (sarea, newsize - info.size))
    { msg = msgs_lookup ("PntEG");
      goto finish;
    }
  }
  else
  { /* Deleting - find the maximum number or rows or columns that can go */
    int max;

    max = (rows? info.height: info.width) - at;

    number = -number;
    if (number > max) number = max;
  }
  if (number == 0) goto finish;

  visdelay_begin ();
  hourglass = TRUE;

  ftracef3 ("sprite_change_size: rows %s, at %d, number %d\n",
      WHETHER (rows), at, insert? number: -number);
  if ((error = sprite_change_size (*sarea, sid, rows, at,
      insert? number: -number)) != NULL)
  { msg = error->errmess;
    goto finish;
  }

finish:
  if (hourglass) visdelay_end ();

  #if TRACE
    psprite_read_full_info (sprite, &info);
    ftracef2 ("AFTER: sprite is %d columns by %d rows\n",
        info.width, info.height);
  #endif

  sprwindow_invalidate (sprite);
  psprite_set_icon_scale (sprite);
  psprite_recalculate_offsets (sprite->file);

  for (sprw = sprite->windows; sprw != NULL; sprw = sprw->link)
    sprwindow_set_work_extent (sprw->window, TRUE);

  if (msg != NULL) werr (FALSE, msg);
}

/***************************************
 * Graphical display of insert/delete  *
 ***************************************/

void menus_restart_tool (void)

{ main_window *window;
  main_sprite *sprite;

  ftracef0 ("menus_restart_tool\n");
  for (window = main_windows; window != NULL; window = window->link)
  if (window->tag == main_window_is_file)
    for (sprite = window->data->file.sprites; sprite != NULL;
         sprite = sprite->link)
      sprite->needsnull = 1;
}

static void stop_insdel_graphics (void)

{ ftracef0 ("stop_insdel_graphics\n");
  toolwindow_current_tool->stop_action (insdel_sprite);
  toolwindow_current_tool = insdel_tool;

  /* now restart the tool if necessary */
  if (toolwindow_current_tool == &tools_textpaint ||
      toolwindow_current_tool == &tools_brushpaint)
    menus_restart_tool ();
}

static void insdel_drawEOR(main_sprite_window *sprw, int x0, int y0)
{
  int xmul = sprw->blobsize.scale_xmul*insdel_sprite->mode.scale_xmul;
  int xdiv = sprw->blobsize.scale_xdiv;
  int ymul = sprw->blobsize.scale_ymul*insdel_sprite->mode.scale_ymul;
  int ydiv = sprw->blobsize.scale_ydiv;
  os_swi2 (OS_SetColour, 3, -1);
#if 0 /*replace the following to avoid checking for full-palette modes.
    J R C 22nd Feb 1994*/
  bbc_gcol (3, 127);
  bbc_tint (2, 3); /*27 August 1991*/
#endif

  if (insdel_rowfield != -1)
  { ftracef0 ("insdel_EOR row\n");
    int top = MAX(insdel_row, Row) + 1;
    int bottom = MIN(insdel_row, Row);
    bbc_rectanglefill (MAX (x0, 0), y0 + bottom*ymul/ydiv,
        0x1FFF, (top - bottom)*ymul/ydiv-1);
  }

  if (insdel_colfield != -1)
  { ftracef0 ("insdel_EOR column\n");
    int left = MIN(insdel_col, Column);
    int right = MAX(insdel_col, Column) + 1;
    bbc_rectanglefill (x0 + left*xmul/xdiv, MAX (y0, 0),
        (right-left)*xmul/xdiv-1, 0x1FFF);
  }
}

static void insdel_EOR (void)

{ main_sprite_window *sprw;

  ftracef0 ("insdel_EOR\n");

  for (sprw = insdel_sprite->windows; sprw != NULL; sprw = sprw->link)
  { int more, x0, y0;
    wimp_redrawstr rds;
    wimp_winfo curr;

    curr.w = sprw->window->handle;
    wimpt_noerr (paintlib_get_wind_info (&curr));
    rds.w = sprw->window->handle;
    rds.box = main_big_extent;
    wimpt_noerr (wimp_update_wind (&rds, &more));

    x0 = rds.box.x0 - rds.scx;
    y0 = rds.box.y1 - rds.scy + curr.info.ex.y0;

    while (more)
    { insdel_drawEOR(sprw, x0, y0);
      wimpt_noerr (wimp_get_rectangle (&rds, &more));
    }
  }
}

static void insdeltool_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("insdeltool_click\n");

  if ((mpos->bbits & wimp_BLEFT) && window->data->sprite.sprite == insdel_sprite)
                           /* only SELECT in appropriate window */
  { int hit = (insdel_pending>>30)&3;
    sprite_area **sarea = &insdel_sprite->file->spritearea;
    sprite_id sid;
    char name [NAME_LIMIT + 1];

    ftracef0 ("perform insdeltool_click\n");

    insdel_pending &= 0x3FFFFFFF;
    sid.tag = sprite_id_name;
    sid.s.name = COPY_N (name, psprite_address (insdel_sprite)->name,
        NAME_LIMIT); /*doesn't flex*/

    if (hit > 1) insdel_pending = -insdel_pending;
    Change_Size (sarea, &sid, insdel_sprite, insdel_pending, hit & 1,
        hit & 1? MIN (Row, insdel_row): MIN (Column, insdel_col));
    menus_ensure_size (sarea, 0);
  }
}

static void insdeltool_null (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("insdeltool_null\n");
  if (mpos->w == window->handle)
  {
    int x, y;

    tools_mouse_to_pixel (window, mpos, &x, &y);

    ftracef2 ("extent coords are (%d, %d)\n", x, y);

    if (x != insdel_col || y != insdel_row)
    { insdel_EOR ();       /* remove old data */
      insdel_col = x; insdel_row = y;

      if (insdel_rowfield != -1)
        dbox_setnumeric (insdel_d, 0, abs (insdel_row - Row)+1);
      if (insdel_colfield != -1)
        dbox_setnumeric (insdel_d, 0, abs (insdel_col - Column)+1);

      insdel_EOR ();       /* EOR on the new */
    }
  }
}

static void insdeltool_redraw (main_window *window, int x0, int y0)

{ 
  ftracef0 ("insdeltool_redraw\n");

  if (window->data->sprite.sprite->needsnull)
    insdel_drawEOR(&window->data->sprite, x0, y0);
}

static void insdeltool_stop (main_sprite *sprite)

{ ftracef0 ("insdeltool_stop\n");
  if (sprite->needsnull)
  { sprwindow_release_idle_events (sprite);
    insdel_EOR ();        /* get rid of on-screen guff */
  }
}

static toolwindow_block insdel_toolblock =
 { &insdeltool_click,
   &insdeltool_null,
   &insdeltool_redraw,
   &insdeltool_stop,
   NULL
 };

static void start_insdel_graphics (main_sprite *sprite, int rowfield,
    int colfield)

{ main_window *window;

  ftracef0 ("start_insdel_graphics\n");
  insdel_rowfield = rowfield;
  insdel_colfield = colfield;
  insdel_sprite   = sprite;

  if (toolwindow_current_tool != &insdel_toolblock)
      insdel_tool = toolwindow_current_tool;
  spencer (else ftracef0 ("!"))

  insdel_row = Row; insdel_col = Column;

  /* stop the tool in all sprite windows */
  for (window = main_windows; window != NULL; window = window->link)
    if (window->tag == main_window_is_sprite)
      toolwindow_current_tool->stop_action (window->data->sprite.sprite);

  toolwindow_current_tool = &insdel_toolblock;
  sprite->needsnull = 1;

  insdel_EOR ();        /* EOR current data on */
}

void menus_insdel_frig (void)

{ ftracef0 ("menus_insdel_frig\n");
  if (insdel_pending) stop_insdel_graphics ();
  insdel_pending = 0;
}

void menus_showmag (void *handle)

{ main_sprite_window *sprite = (main_sprite_window *) handle;
  int m, d;
  wimp_wstate wstate;

  ftracef0 ("showmsg\n");
  wimpt_noerr (wimp_get_wind_state (sprite->window->handle, &wstate));
  m = sprite->blobsize.scale_ymul;
  d = sprite->blobsize.scale_ydiv;

  main_current_options.zoom.mul =
      sprite->blobsize.scale_ymul = sprite->blobsize.scale_xmul;
  main_current_options.zoom.div =
      sprite->blobsize.scale_ydiv = sprite->blobsize.scale_xdiv;
  sprwindow_set_work_extent (sprite->window, FALSE);

  /* now scale window size too */
  spencer (ftracef (__FILE__, __LINE__, "psize %d %d %d %d\n",
                      wstate.o.box.x0, wstate.o.box.x1,
                      wstate.o.box.y0, wstate.o.box.y1))
  wstate.o.box.x1 = wstate.o.box.x0 +
     (wstate.o.box.x1-wstate.o.box.x0)*d*main_current_options.zoom.mul/
     (m*main_current_options.zoom.div);
  wstate.o.box.y0 = wstate.o.box.y1 -
     (wstate.o.box.y1-wstate.o.box.y0)*d*main_current_options.zoom.mul/
     (m*main_current_options.zoom.div);
  spencer (ftracef (__FILE__, __LINE__, "nsize %d %d %d %d\n",
                      wstate.o.box.x0, wstate.o.box.x1,
                      wstate.o.box.y0, wstate.o.box.y1))

  /* and keep the same point at the top left */
  wstate.o.x = wstate.o.x*d*main_current_options.zoom.mul/
      (m*main_current_options.zoom.div);
  wstate.o.y = wstate.o.y*d*main_current_options.zoom.mul/
      (m*main_current_options.zoom.div);

  wimpt_noerr (wimp_open_wind (&wstate.o));
}


/**************************
 * Palette handling       *
 **************************/

static void sprite_palette_has_changed (main_sprite *sprite)

{ ftracef0 ("sprite_palette_has_changed\n");
  psprite_set_colour (sprite);
  psprite_set_brush_translation (sprite);

  sprwindow_redisplay (sprite, NULL);
  /*if (sprite->colourhandle != 0)
    main_force_redraw (sprite->colourhandle);*/

  if (sprite->colourdialogue == 0) colours_set_extent (sprite);
  main_set_modified (sprite->file);
}

void menus_set_palette (main_sprite *sprite, int entries, int *palette)

  /*Note: this routine assumes the palette is the right length for the
    sprite.*/

{ BOOL create = palette != NULL;
  char *start, *end;
  int old_size, new_size, diff;
  sprite_area **sarea = &sprite->file->spritearea;
  sprite_header *header;

  ftracef1 ("%s palette\n", create? "Create": "Delete");

  header = psprite_address (sprite);
  old_size = MIN (header->image, header->mask) - sizeof (sprite_header);
  new_size = create? 2*sizeof (int)*entries: 0;
  diff = new_size - old_size;

  ftracef3 ("Sprite \"%.12s\" had %d bytes of palette; wants %d bytes\n",
      header->name, old_size, new_size);

  /*Adjust the area to insert/delete 'diff' bytes at the right
    place for this sprite. The "right place" is the start of the image or the
    start of the mask, whichever comes first.*/
  if (diff > 0 && !menus_ensure_size (sarea, diff))
  { werr (FALSE, msgs_lookup ("PntEG"));
    return;
  }

  header = psprite_address (sprite); /*flex moved?*/
  start  = (char *) header + MIN (header->image, header->mask);
  end    = (char *) *sarea + (*sarea)->freeoff /*end of whole area*/;
  memmove (start + diff, start, end - start);

  if (create)
  { /*Now copy the new palette into the space just made.*/
    int i, *e = (int *) ((char *) header + sizeof (sprite_header));

    for (i = 0; i < entries; i++)
    { *e = *(e + 1) = palette [i];
      e += 2;
    }
  }

  /*Fix up every pointer in the world.*/
  header->image     += diff;
  header->mask      += diff;
  header->next      += diff;
  (*sarea)->freeoff += diff;

  sprwindow_invalidate (sprite);
  menus_ensure_size (sarea, 0);
  psprite_recalculate_offsets (sprite->file);
  sprite_palette_has_changed (sprite);
}

/*********************************
 *                               *
 *  Sprite window menu handler.  *
 *                               *
 *********************************/

static void Apply_Colour (dboxtcol_colour col, void *handle)

{ main_sprite *sprite = (main_sprite *) handle;
  sprite_header *spr = psprite_address (sprite);
  int *colour = &(&spr->mode + 1) [2*sprite->gcol.colour];

  ftracef0 ("Apply_Colour\n");
  /*Update source of colour.*/
  *colour = *(colour + 1) = col;

  sprite_palette_has_changed (sprite);
}

void menus_sprite_handler (void *handle, char *hit)

{ main_window *window = (main_window *) handle;
  main_sprite_window *sprw = &window->data->sprite;
  main_sprite *sprite = sprw->sprite;

  ftracef0 ("menus_sprite_handler\n");
  ftracef5 ("menu hit is {%d, %d, %d, %d, %d}\n",
      hit [0], hit [1], hit [2], hit [3], hit [4]);

  switch (hit [0])
  { case s_Misc:
      switch (hit [1])
      { case s_Misc_AppInfo:
          if (hit [2]) show_info_box ();
        break;

        case s_Misc_SpriteInfo:
          if (hit [2]) display_sprite_info (sprite);
        break;

        case s_Misc_Print:
          /*FIX G-RO-9923 JRC 15 Oct '91 Print on choosing Print.*/
          menus_print_sprite (sprite, /*ask?*/ hit [2] != 0);
        break;
      }
    break;

    case s_Save:
      switch (hit [1])
      { case s_Save_Sprite:
          ftracef1 ("Sprite save: hit [2] == %d\n", hit [2]);
          if (hit [2] != 0)
          { /*If there is only one sprite, offer to save the whole sprite
              file. This acts as a counterpart to the code that opens a
              sprite window if there is only one sprite. J R C 7th Feb 1995*/
            if (sprite->file->spritearea->number == 1)
              menus_save_file (sprite->file->window, TRUE);
            else
              menus_save_sprite (sprite);
          }
        break;

        case s_Save_Palette:
          if (hit [2] != 0)
          { int size = psprite_palsize (sprite);

            ftracef0 ("Sprite palette save\n");
            myxfersend (FileType_Palette, msgs_lookup ("PntG5"), size,
                &save_sprite_palette, &buffer_sprite_palette, 0, sprite);
          }
        break;
      }
    break;

    case s_Paint:
      switch (hit [1])
      { case s_Paint_ECF: /*rewritten. JRC 4 June 1991*/
        { BOOL open;
          dbox d;

          ftracef0 ("Select E C F\n");
          if ((d = dbox_new ("selectECF")) != NULL)
          { dbox_setfield (d, d_ECF_Sprite, "");

            dbox_raw_eventhandler (d, &help_dboxrawevents,
                (void *) "PntHC");
            dbox_show (d);

            open = TRUE;
            while (open)
            { wimp_i i = dbox_fillin (d);

              ftracef1 ("Got event on icon %d\n", i);

              switch (i)
              { case d_ECF_Ok:
                { char name [13];
                  int ECF, i;
                  main_sprite *ECFsprite;

                  /*Get the selected icon number (0, ..., 3).*/
                  ECF = -1;
                  for (i = 0; i < 4; i++)
                    if (dbox_getnumeric (d, d_ECF_1 + i))
                    { ECF = i;
                      break;
                    }

                  if (ECF != -1)
                  { dbox_getfield (d, d_ECF_Sprite, name, 13);

                    if ((ECFsprite = psprite_find (name, "PntE5b")) != NULL)
                      psprite_setup_ecf (sprite, ECF, ECFsprite);
                  }

                  open = dbox_persist ();
                }
                break;

                case dbox_CLOSE:
                  open = FALSE;
                break;
              }
            }
            dbox_dispose (&d);
          }
        }
        break;

        case s_Paint_Sel_Col:
        { sprite_id sid;
          char name [NAME_LIMIT + 1];
          sprite_maskstate mask = sprite_masksolid;
          sprite_colour colour;

          ftracef2 ("pick pixel colour %d %d\n", Column, Row);

          sid.tag = sprite_id_name;
          sid.s.name = COPY_N (name, psprite_address (sprite)->name,
              NAME_LIMIT); /*doesn't flex*/

          /*Force a redraw of the colours window, if necessary.*/
          if (sprite->colourhandle != NULL && sprite->colourdialogue == NULL)
            main_force_redraw (sprite->colourhandle);

          if (psprite_hasmask (sprite))
            wimpt_noerr (sprite_readmask (sprite->file->spritearea, &sid,
                  Column, Row, &mask));

          wimpt_noerr (main_read_pixel (sprite->file->spritearea,
                &sid, Column, Row, &colour));

          sprite->gcol = colours_unpack_colour2(sprite, colour, mask);

          ftracef1 ("select colour 0x%X\n", sprite->gcol);

          if (sprite->colourdialogue != 0)
          { colourpicker_dialogue dialogue;

            if (!sprite->gcol.alpha)
            { dialogue.flags = colourpicker_DIALOGUE_TRANSPARENT;
              ftracef0 ("ColourPicker_UpdateDialogue: setting transparent\n");
              os_swi3 (ColourPicker_UpdateDialogue,
                  colourpicker_UPDATE_TRANSPARENT, sprite->colourdialogue,
                  &dialogue);
            }
            else
            { dialogue.colour = colours_entry (psprite_address(sprite)->mode, sprite->gcol.colour);

              ftracef1 ("ColourPicker_UpdateDialogue: setting RGB colour to 0x%X\n",
                  dialogue.colour);
              os_swi3 (ColourPicker_UpdateDialogue,
                  colourpicker_UPDATE_COLOUR, sprite->colourdialogue,
                  &dialogue);
            }
          }
        }
        break;

        case s_Paint_Show_Col:
          ftracef0 ("show colour menu\n");
          colours_create_window (sprite);
          main_current_options.colours.show_colours = TRUE;
        break;

        case s_Paint_Show_Tool:
          ftracef0 ("show tool menu\n");
          toolwindow_display (/*at pointer?*/ TRUE);
          main_current_options.tools.show_tools = TRUE;
        break;

        case s_Paint_Small:
          ftracef0 ("Toggle colour size\n");
          sprite->coloursize =
              sprite->coloursize == colours_SIZE? colours_SIZE/2: colours_SIZE;

          main_current_options.colours.small_colours =
              sprite->coloursize != colours_SIZE;

          colours_set_extent (sprite);
        break;

        case s_Paint_Edit_Pal:
          if (hit [2])
          { sprite_header *spr = psprite_address (sprite);
            int *colour = &(&spr->mode + 1) [sprite->gcol.colour*2];
            wimp_emask emask;

            ftracef0 ("Edit colour\n");
            /* Enable nulls, so slider drags work */
            event_setmask ((wimp_emask) (((emask = event_getmask ()) & ~wimp_EMNULL)));

            dboxtcol (colour, /*allow transparent?*/ FALSE,
                msgs_lookup ("PntW8"), &Apply_Colour, (void *) sprite);

            event_setmask (emask);
          }
        break;
      }
    break;

    case s_Edit:
    { sprite_area **sarea = &sprite->file->spritearea;
      sprite_id sid;
      char name [NAME_LIMIT + 1];

      sid.tag = sprite_id_name;
      sid.s.name = COPY_N (name, psprite_address (sprite)->name, NAME_LIMIT);
        /*doesn't flex*/

      switch (hit [1])
      { case s_Edit_FlipV:
        case s_Edit_FlipH :
          ftracef1 ("flip %c\n", hit [1] == s_Edit_FlipV ? 'x' : 'y');
          wimpt_complain
             ((hit [1] == s_Edit_FlipV? sprite_flip_x: sprite_flip_y)
             (*sarea, &sid));
        break;

        case s_Edit_Rotate:
          ftracef0 ("Rotate\n");
          if (hit [2])
          { int angle, n;

            if (sscanf (rotatebuffer, "%d%n", &angle, &n) == 1 &&
                n == strlen (rotatebuffer))
              psprite_rotate (sprite, angle);
          }
        break;

        case s_Edit_Scale_X:
          ftracef0 ("Scale X\n");
          if (hit [2])
          { double factor = 1.0;
            int n;

            ftracef1 ("menus_sprite_handler: scalebuffer: %s\n",
                scalebuffer);
            if (sscanf (scalebuffer, "%lg%n", &factor, &n) == 1 &&
                n == strlen (scalebuffer) &&
                factor > 0.0)
              psprite_scale (sprite, factor, 1.0);
          }
        break;

        case s_Edit_Scale_Y:
          ftracef0 ("Scale Y\n");
          if (hit [2])
          { double factor = 1.0;
            int n;

            ftracef1 ("menus_sprite_handler: scalebuffer: %s\n",
                scalebuffer);
            if (sscanf (scalebuffer, "%lg%n", &factor, &n) == 1 &&
                n == strlen (scalebuffer) &&
                factor > 0.0)
              psprite_scale (sprite, 1.0, factor);
          }
        break;

        case s_Edit_Shear:
          ftracef0 ("Shear\n");
          if (hit [2])
          { double factor = 1.0;
            int n;

            if (sscanf (shearbuffer, "%lg%n", &factor, &n) == 1 &&
                n == strlen (shearbuffer))
              psprite_shear (sprite, factor);
          }
        break;

        case s_Edit_Adjust:
        { BOOL open;
          int rows, columns;
          psprite_info info;
          dbox d;

          ftracef0 ("adjust size");
          if ((d = dbox_new ("spritesize"))!=0)
          { psprite_read_full_info (sprite, &info);
            rows    = info.height;
            columns = info.width;

            dbox_setnumeric (d, d_Adjust_Cols, columns);
            dbox_setnumeric (d, d_Adjust_Rows, rows);

            dbox_show (d);
            dbox_raw_eventhandler (d, &help_dboxrawevents,
                (void *) "PntHD");

            open = TRUE;
            while (open)
            { wimp_i i = dbox_fillin (d);
              wimp_mousestr mouse_str;
              BOOL adjust;

              ftracef1 ("Got event on icon %d\n", i);

              columns = dbox_getnumeric (d, d_Adjust_Cols);
              rows    = dbox_getnumeric (d, d_Adjust_Rows);
              wimpt_noerr (wimp_get_point_info (&mouse_str));
              adjust = (mouse_str.bbits & wimp_BRIGHT) != 0;

              switch (i)
              { case d_Adjust_Ok:
                { int width_by, height_by, size_by;

                  if (rows == 0 || columns == 0)
                    werr (FALSE, msgs_lookup ("PntEA"));
                  else
                  { sprwindow_remove_wastage (sprite);

                    /*Adjust the smaller dimension first: then you don't run
                      out of store in an intermediate step.*/

                    psprite_read_full_info (sprite, &info);

                    height_by = rows - info.height;
                    width_by  = columns - info.width;
                    size_by   = psprite_size (columns, rows, info.mode,
                        info.mask, 0) - psprite_size (info.width,
                        info.height, info.mode, info.mask, 0);

                    /*Make sure there's enough space for the new sprite.*/
                    if (!menus_ensure_size (sarea, size_by))
                      werr (FALSE, msgs_lookup ("PntEG"));
                    else
                    { if (height_by < width_by)
                      { /*adjust no of rows*/
                        if (height_by != 0)
                          Change_Size (sarea, &sid, sprite, height_by, 1,
                              height_by > 0? info.height: rows);

                        /*adjust no of columns*/
                        if (width_by != 0)
                          Change_Size (sarea, &sid, sprite, width_by, 0,
                              width_by > 0? info.width: columns);
                      }
                      else
                      { /*adjust no of columns*/
                        if (width_by != 0)
                          Change_Size (sarea, &sid, sprite, width_by, 0,
                              width_by > 0? info.width: columns);

                        /*adjust no of rows*/
                        if (height_by != 0)
                          Change_Size (sarea, &sid, sprite, height_by, 1,
                              height_by > 0? info.height: rows);
                      }

                      menus_ensure_size (sarea, 0);
                      psprite_recalculate_offsets (sprite->file);
                      sprwindow_redisplay (sprite, NULL);
                    }
                  }
                  open = dbox_persist ();
                }
                break;

                case d_Adjust_RowDown:
                  adjust = !adjust;
                /*fall through*/

                case d_Adjust_RowUp:
                  if (adjust)
                  { if (rows > 1)
                      dbox_setnumeric (d, d_Adjust_Rows, rows - 1);
                  }
                  else
                    dbox_setnumeric (d, d_Adjust_Rows, rows + 1);
                break;

                case d_Adjust_ColDown:
                  adjust = !adjust;
                /*fall through*/

                case d_Adjust_ColUp:
                  if (adjust)
                  { if (columns > 1)
                      dbox_setnumeric (d, d_Adjust_Cols, columns - 1);
                  }
                  else
                    dbox_setnumeric (d, d_Adjust_Cols, columns + 1);
                break;

                case dbox_CLOSE:
                  open = FALSE;
                break;
              }
            }
            dbox_dispose (&d);
          }
        }
        break;

        case s_Edit_InsCol:
        case s_Edit_InsRow:
        case s_Edit_DelCol:
        case s_Edit_DelRow:
        { BOOL col = hit [1] == s_Edit_InsCol || hit [1] == s_Edit_DelCol,
            insert = hit [1] == s_Edit_InsCol || hit [1] == s_Edit_InsRow;
          int number = 0 /*for Norcroft*/;

          #if 0 /*dbox on menu hit is against style guide*/
          if (FALSE)
          { ftracef0 ("hit on menu - insert/delete 1 row/column\n");

            number     = 1;
            insdel_row = Row;
            insdel_col = Column;
          }
          else /* Hit is on writable menu */
          #endif

          ftracef0 ("submenu hit - start graphics and show dbox\n");
          menus_insdel_frig ();
          insdel_pending = 0;
          start_insdel_graphics (sprite, col? -1: 1, !col? -1: 1);

          if (hit [2])
          { wimp_i i;

            if ((insdel_d = dbox_new ("number")) == 0)
              return;
            ftracef0 ("dbox made\n");

            dbox_setnumeric (insdel_d, 0, 1);
            dbox_show (insdel_d);
            i = dbox_fillin (insdel_d);
            insdel_pending = dbox_getnumeric (insdel_d, 0);

            if (i != dbox_CLOSE)
            { ftracef0 ("Non-close menu event\n");
              number = insdel_pending;
              insdel_pending = 0;
            }
            else
            { int flags = insert? (col? 4: 5): (col? 6: 7);

              ftracef0 ("Close menu event\n");
              insdel_pending |= flags << 30; /*top two bits are flags*/
              number = (int)0x80000000;
              insert = col = FALSE; /* A fiddle */
            }
            dbox_dispose (&insdel_d);
          }

          if (!insdel_pending) stop_insdel_graphics ();

          if (hit [2])
          { if (!insert) number = -number;
            ftracef1 ("number %d\n", number);
            if (number != 0x80000000)
              Change_Size (sarea, &sid, sprite, number, !col,
                  !col? MIN (Row, insdel_row): MIN (Column, insdel_col));
            menus_ensure_size (sarea, 0);
          }
        }
        break;

        case s_Edit_Mask:
        { int create = !psprite_hasmask (sprite);
          char *msg = NULL;
          os_error *error;

          if (sprite == tools_brushsprite_ptr && toolwindow_current_tool == &tools_brushpaint)
            toolwindow_stop_all_tools ();

          ftracef1 ("%s mask\n", create? "Create" : "Delete");
          if (create)
            if (!menus_ensure_size (sarea, psprite_address (sprite)->next))
            { msg = msgs_lookup ("PntEG");
              goto masked;
            }

          if ((error = (create? sprite_create_mask: sprite_remove_mask)
              (*sarea, &sid)) != NULL)
          { msg = error->errmess;
            goto masked;
          }

          if (sprite->colourdialogue == 0) colours_set_extent (sprite);
          menus_ensure_size (sarea, 0);
          sprwindow_invalidate (sprite);

          if (sprite == tools_brushsprite_ptr && toolwindow_current_tool == &tools_brushpaint)
            menus_restart_tool ();

          if (sprite->colourdialogue != 0)
          { colourpicker_dialogue dialogue;

            if (!create)
            { /*Unset transparent if it is currently selected.*/
              dialogue.flags = 0;
              ftracef0 ("ColourPicker_UpdateDialogue: setting "
                  "'transparent'\n");
              if ((error = os_swix3 (ColourPicker_UpdateDialogue,
                  colourpicker_UPDATE_TRANSPARENT, sprite->colourdialogue,
                  &dialogue)) != NULL)
              { msg = error->errmess;
                goto masked;
              }
            }

            /*If creating a mask, set to offering transparent, otherwise to
                not.*/
            dialogue.flags = create?
                colourpicker_DIALOGUE_OFFERS_TRANSPARENT: 0;
            ftracef0 ("ColourPicker_UpdateDialogue: setting 'offers transparent'\n");
            if ((error = os_swix3 (ColourPicker_UpdateDialogue,
                colourpicker_UPDATE_OFFERS_TRANSPARENT,
                sprite->colourdialogue, &dialogue)) != NULL)
            { msg = error->errmess;
              goto masked;
            }
          }

          /*Fix MED-xxx J R C 21st Jul 1994*/
          if (!create)
          {
            sprite->gcol.alpha = 255;
            sprite->gcol2.alpha = 255;
          }

        masked:
          if (msg != NULL) werr (FALSE, msg);
        }
        break;

        case s_Edit_Palette:
        { int lb_bpp =
              bbc_modevar (psprite_address (sprite)->mode, bbc_Log2BPP);

          menus_set_palette (sprite, ENTRIES (lb_bpp),
              psprite_haspal (sprite)? NULL:
              psprite_std_palettes [sprite->file->use_current_palette? 0: 1]
                [lb_bpp]);
        }
        break;
      }
      psprite_recalculate_offsets (sprite->file);
      sprwindow_redisplay (sprite, NULL);
    }
    break;

    case s_Zoom:
      if (hit [1])
        magnify_select (&sprw->blobsize.scale_xmul,
            &sprw->blobsize.scale_xdiv, 999, 999, menus_showmag, sprw);
    break;

    case s_Grid:
      switch (hit [1])
      { case 0:
          /*Toggle grid*/
          sprw->gridcol =
              sprw->gridcol == 255? main_current_options.grid.colour: 255;

          main_current_options.grid.show = sprw->gridcol != 255;
        break;

        default:
          sprw->gridcol = hit [1] - 1;

          main_current_options.grid.show = TRUE;
          main_current_options.grid.colour = hit [1] - 1;
        break;
      }
      main_force_redraw (window->handle);
    break;
  }
}

static void print_setcorner (dbox d)

{ char realbuf [100];

  ftracef0 ("print_setcorner\n");
  main_set_printer_data (); /*Update menus_print_where if pagesize changed*/
  sprintf (realbuf, "%.2f", menus_print_where.dx/print_scalefactor);
  dbox_setfield (d, d_Print_XCorner, realbuf);
  sprintf (realbuf, "%.2f", menus_print_where.dy/print_scalefactor);
  dbox_setfield (d, d_Print_YCorner, realbuf);
}

static void print_readcorner (dbox d)

{ double t, max;
  char realbuf [100];
  int n;

  ftracef0 ("print_readcorner\n");
  max = 0x7FFFFFFF / print_scalefactor;

  dbox_getfield (d, d_Print_XCorner, realbuf, 100);
  ftracef2 ("readcorner x '%s', %g\n", realbuf, print_scalefactor);
  if (sscanf (realbuf, "%lf%n", &t, &n) == 1 &&
      n == strlen (realbuf))
  { if (t>max) t = max;
    if (t<-max) t = -max;
    menus_print_where.dx = (int) (t*print_scalefactor);
  }

  dbox_getfield (d, d_Print_YCorner, realbuf, 100);
  ftracef2 ("readcorner x '%s', %g\n", realbuf, print_scalefactor);
  if (sscanf (realbuf, "%lf%n", &t, &n) == 1 &&
      n == strlen (realbuf))
  { if (t>max) t = max;
    if (t<-max) t = -max;
    menus_print_where.dy = (int) (t*print_scalefactor);
  }

  ftracef2 ("read corner %d %d\n",
      menus_print_where.dx, menus_print_where.dy);
}


/**********************************************
 * Print Sprite DBox stuff                    *
 **********************************************/

/*FIX G-RO-7139 JRC 17 Oct '91 menus_do_print() split into two parts:
  queue_print() displays the dialogue box (if necessary) and then queues the
  file for later printing by calling xfersend_print(). menus_do_print() actually
  prints the file using options saved at the end of the file.*/

/*FIX G-RO-7139 JRC 17 Oct '91 New function queue_print() queues a file for
  later printing.*/

static int Do_Print(char *filename, void *handle)

{ filename = filename; /*for Norcroft*/
  return menus_do_print (handle)? xfersend_printPrinted: xfersend_printFailed;
}

static BOOL queue_print (dbox d, main_sprite *sprite)

{ psprite_info info;

  ftracef1 ("queue_print, sprite 1 called \"%.12s\"\n",
      psprite_address (sprite)->name);

  if (d != NULL)
  { print_copies           = dbox_getnumeric (d, d_Print_Copies);
    print_landscape        = dbox_getnumeric (d, d_Print_Landscape);
    print_scale.scale_xmul = dbox_getnumeric (d, d_Print_XMul);
    print_scale.scale_xdiv = dbox_getnumeric (d, d_Print_XDiv);
    print_scale.scale_ymul = dbox_getnumeric (d, d_Print_YMul);
    print_scale.scale_ydiv = dbox_getnumeric (d, d_Print_YDiv);
    print_readcorner (d);
  }

  ftracef2 ("landscape: %s; unit: %s\n", WHETHER (print_landscape),
      print_scalefactor == PRINT_INCHES_TO_72000? "inches": "cm");

  psprite_read_full_info (sprite, &info);

  if (!xfersend_print (FileType_Sprite, info.name, info.size,
      /*saver*/ &save_sprite, /*sender - no point yet*/ NULL,
      /*printer*/ &Do_Print, /*handle*/ sprite))
    return FALSE;

  return TRUE;
}

/*FIX G-RO-7139 JRC 17 Oct '91 New function menus_do_print() prints a given
  file - called when the printer manager sends Message_PrintTypeOdd.*/

BOOL menus_do_print (main_sprite *sprite)

{ BOOL more, done_begin = FALSE, done_select_job = FALSE,
    done_translate = FALSE;
  print_box pbox;
  print_transmatstr transform;
  os_error *err;
  int id, job = 0, oldjob;
  print_pagesizestr psize;
  psprite_info info;
  print_infostr infostr;
  print_box ssize;
  main_ttab *old_ttab = sprite->transtab;
  char *txt = NULL;
  os_regset reg_set;

  ftracef1 ("menus_do_print, sprite 1 called \"%.12s\"\n",
      psprite_address (sprite)->name);

  if (old_ttab->table != 0)
    ftracef3 ("initially, table is '%.4s', 0x%X, '%.4s'\n",
        (char *) &((int *) old_ttab->table) [0],
        ((int *) old_ttab->table) [1],
        (char *) &((int *) old_ttab->table) [2]);

  if ((err = print_info (&infostr)) != NULL)
  { txt = msgs_lookup ("PntE9");
    goto finish;
  }

  if ((err = print_pagesize (&psize)) != NULL)
  { txt = err->errmess;
    goto finish;
  }

  if (print_landscape)
  { transform.xx = 0;
    transform.xy = 0x10000;
    transform.yx = -0x10000;
    transform.yy = 0; /* -90deg rotation, no scaling */
  }
  else
  { transform.xx = 0x10000;
    transform.xy = 0;
    transform.yx = 0;
    transform.yy = 0x10000; /* no rotation, no scaling */
  }
  ftracef2 ("landscape: %s; unit: %s\n", WHETHER (print_landscape),
      print_scalefactor == PRINT_INCHES_TO_72000? "inches": "cm");

  visdelay_begin ();
  done_begin = TRUE;

  /*Open file*/
  reg_set.r [0] = 0x8C;
  reg_set.r [1] = (int) "printer:";
  if ((err = os_find (&reg_set)) != NULL)
  { txt = err->errmess;
    goto finish;
  }
  job = reg_set.r [0];

  if (job == 0)
  { /*In case the FileSwitch bug returns a 0 handle.*/
    ftracef0 ("File 'printer:' not opened sucessfully\n");
    txt = msgs_lookup ("PntWA");
    goto finish;
  }

  if (print_scale.scale_xmul == 0) print_scale.scale_xmul = 1;
  if (print_scale.scale_ymul == 0) print_scale.scale_ymul = 1;
  if (print_scale.scale_xdiv == 0) print_scale.scale_xdiv = 1;
  if (print_scale.scale_ydiv == 0) print_scale.scale_ydiv = 1;

  psprite_read_full_info (sprite, &info);
  ssize.x0 = 0;
  ssize.x1 = info.width*sprite->mode.scale_xmul*print_scale.scale_xmul/
      print_scale.scale_xdiv;
  ssize.y0 = 0;
  ssize.y1 = info.height*sprite->mode.scale_ymul*print_scale.scale_ymul/
      print_scale.scale_ydiv; /* sprite size in OS units*/

  if ((err = print_selectjob (job, NULL, &oldjob)) != NULL)
  { txt = err->errmess;
    goto finish;
  }
  done_select_job = TRUE;

  if ((infostr.features & 1 << 29) != 0)
  { ftracef0 ("printer driver supports PDriver_DeclareFont\n");
    /*No fonts in use. This is a sprite editor!*/
    if ((err = os_swix3 (PDriver_DeclareFont, 0, NULL, 0)) != NULL)
    { txt = err->errmess;
      goto finish;
    }
  }

  if (print_landscape) menus_print_where.dx += ssize.y1*72000/180;

  ftracef2 ("menus_print_where.dx = %d, menus_print_where.dy = %d\n",
      menus_print_where.dx, menus_print_where.dy);
  if ((err = print_giverectangle (1, &ssize, &transform, &menus_print_where,
      -1)) != NULL)
  { txt = err->errmess;
    goto finish;
  }

  if (print_landscape) menus_print_where.dx -= ssize.y1*72000/180;

  ftracef0 ("drawing page\n");
  if ((err = print_drawpage (print_copies, 0, NULL, &pbox, &more, &id)) !=
      NULL)
  { txt = err->errmess;
    goto finish;
  }

  /*Now generate translation table. Can't use psprite_ttab_for_sprite(),
    because it might not call ColourTrans.*/
  /*J R C 10th Jan 1994 It does now! So use it!!*/
  /*J R C 28th Jan 1994 Now it doesn't again, we use the part of it that
    does.*/
  if ((sprite->transtab = psprite_ttab_new (sprite, -1, (int *) -1)) == NULL)
  { txt = msgs_lookup ("PntEG");
    goto finish;
  }
  done_translate = TRUE;

  while (more)
  { int ID;

    if ((err = psprite_plot_scaled (0, 0, sprite, &print_scale, 0)) != NULL)
    { txt = err->errmess;
      goto finish;
    }

    if ((err = print_getrectangle (&pbox, &more, &ID)) != NULL)
    { txt = err->errmess;
      goto finish;
    }
  }

finish:
  if (done_translate)
  { ftracef0 ("calling psprite_ttab_delete\n");
    psprite_ttab_delete (sprite->transtab);
  }
  sprite->transtab = old_ttab;

  if (done_select_job)
  { os_error *err1;

    ftracef1 ("calling %s\n", txt == NULL? "print_endjob": "print_abortjob");
    err1 = txt == NULL? print_endjob (job): print_abortjob (job);
    if (txt == NULL && err1 != NULL) txt = err1->errmess;

    ftracef0 ("calling print_selectjob\n");
    err1 = print_selectjob (oldjob, NULL, &oldjob);
    if (txt == NULL && err1 != NULL) txt = err1->errmess;
  }

  if (job != 0)
  { /*close the printer stream*/
    os_error *err1;

    reg_set.r [0] = 0;
    reg_set.r [1] = job;
    ftracef0 ("calling os_find\n");
    err1 = os_find (&reg_set);
    if (txt == NULL && err1 != NULL) txt = err1->errmess;
  }

  if (done_begin)
  { ftracef0 ("calling visdelay_end\n");
    visdelay_end ();
  }

  /* Now it's safe to generate the error at last! (if we've had one) */
  if (txt != NULL)
  { ftracef1 ("menus_do_print got error \"%s\"\n", txt);
    werr (FALSE, txt);
  }
  else
    ftracef0 ("menus_do_print got no error\n");

  return txt == NULL;
}

static BOOL print_box_events (dbox d, void *event, void *h)

{ wimp_mousestr m;

  ftracef0 ("print_box_events\n");
  h = h;
  switch (((wimp_eventstr *) event)->e)
  { case wimp_EBUT:
      wimp_get_point_info (&m);
      if (m.i == d_Print_Landscape || m.i == d_Print_Portrait ||
          m.i == d_Print_Inches    || m.i == d_Print_Cm)
      { int other =
            m.i == d_Print_Landscape? d_Print_Portrait:
            m.i == d_Print_Portrait?  d_Print_Landscape:
            m.i == d_Print_Inches?    d_Print_Cm:    d_Print_Inches;
        dbox_setnumeric (d, m.i,   1);
        dbox_setnumeric (d, other, 0);

        if (m.i == d_Print_Inches || m.i == d_Print_Cm)
        { print_readcorner (d);
          print_scalefactor =
              m.i == d_Print_Inches? PRINT_INCHES_TO_72000: PRINT_CM_TO_72000;
          print_setcorner (d);
        }
        else
          print_landscape = m.i == d_Print_Landscape;

        return TRUE;
      }
    break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
      if (((wimp_eventstr *) event)->data.msg.hdr.action ==
          wimp_MHELPREQUEST)
      { ftracef0 ("Help request for print window\n");
        main_help_message ("PntHB", (wimp_eventstr *) event);
        return TRUE;
      }
    break;
  }

  return FALSE;
}

void menus_print_sprite (main_sprite *sprite, BOOL ask)

{ print_infostr infostr;
  os_error  *noprinter;

  ftracef0 ("menus_print_sprite\n");

  noprinter = print_info (&infostr);
  if (ask)
  { dbox d;

    if ((d = dbox_new ("Printing")) != 0)
    { BOOL open;

      dbox_setfield (d, d_Print_Printer,
          noprinter? msgs_lookup ("PntW9"): infostr.description);
      dbox_setnumeric (d, d_Print_Copies,    print_copies);
      dbox_setnumeric (d, d_Print_Portrait, !print_landscape);
      dbox_setnumeric (d, d_Print_Landscape, print_landscape);
      dbox_setnumeric (d, d_Print_XMul,      print_scale.scale_xmul);
      dbox_setnumeric (d, d_Print_XDiv,      print_scale.scale_xdiv);
      dbox_setnumeric (d, d_Print_YMul,      print_scale.scale_ymul);
      dbox_setnumeric (d, d_Print_YDiv,      print_scale.scale_ydiv);
      dbox_setnumeric (d, d_Print_Inches,
                      print_scalefactor == PRINT_INCHES_TO_72000);
      dbox_setnumeric (d, d_Print_Cm,
                      print_scalefactor == PRINT_CM_TO_72000);
      print_setcorner (d);

      dbox_raw_eventhandler (d, &print_box_events, (void *) sprite);
      dbox_show (d);
      open = TRUE;

      while (open)
      { wimp_i i = dbox_fillin (d);

        switch (i)
        { case d_Print_Print:
            /*FIX G-RO-7139 JRC 17 Oct '91 Call queue_print() instead of
               menus_do_print().*/
            (void) queue_print (d, sprite);
            open = dbox_persist ();
          break;

          case dbox_CLOSE:
            open = FALSE;
          break;
        }
      }
      dbox_dispose (&d);
    }
  }
  else
    /*FIX G-RO-7139 JRC 17 Oct '91 Call queue_print() instead of
      menus_do_print().*/
    (void) queue_print (NULL, sprite);
}

void menus_hack_palette (main_sprite *sprite)

{ sprite_header *s = psprite_address (sprite);

  ftracef1 ("menus_hack_palette for \"%.12s\"\n", s->name);
  if (bbc_modevar (s->mode, bbc_Log2BPP) != 3)
              /* dont hack 256 colour ones */
  { int *palstart = &s->mode + 1,
      *palend = (int *) ((char *) s + s->image);

    for (; palstart < palend; palstart++)
    { int t = *palstart & 0xF0F0F000;

      ftracef2 ("was 0x%.8X now 0x%.8X\n",
          *palstart, t | ((t >> 4) & 0xF0F0F00));
      *palstart = t | ((t >> 4) & 0xF0F0F00);
    }
  }
}

/***************************************************************************
 *                                                                         *
 *  Sprite file window menu handler.                                       *
 *                                                                         *
 ***************************************************************************/

static BOOL sprite_file_info_events (dbox d, void *event, void *handle )

{ wimp_eventstr *e;

  ftracef0 ("sprite_file_info_events\n");
  handle = handle;
  d      =      d;
  e = (wimp_eventstr *) event;
  if (e->e == wimp_ESEND || e->e == wimp_ESENDWANTACK)
  { if (e->data.msg.hdr.action == wimp_MHELPREQUEST)
    { ftracef0 ("Help request for sprite file info window\n");;
      main_help_message ("PntH9", e);
      return TRUE;
    }
  }
  return FALSE;
}

void menus_file_handler (void *handle, char *hit)

{ main_window *window = (main_window *) handle;

  ftracef0 ("menus_file_handler\n");
  switch (hit [0])
  { case m_Misc:
      switch (hit [1])
      { case m_Misc_Info:
          if (hit [2]) show_info_box ();
        break;

        case m_Misc_File:
          if (hit [2])
          { dbox d;
            sprite_area *sarea = window->data->file.spritearea;
            char sizestring[32];

            ftracef0 ("Misc about file\n");
            if ((d = dbox_new ("fileInfo"))!=0)
            { dbox_setfield (d, d_File_Name,
                  window->data->file.filename == NULL?
                  msgs_lookup ("PntF4"): window->data->file.filename);
              dbox_setnumeric (d, d_File_Number, sarea->number);
              os_swix3 (OS_ConvertFileSize, sarea->size, &sizestring, 32);              
              dbox_setfield (d, d_File_Size, sizestring);
              dbox_setfield (d, d_File_Mod,  yesno (window->data->file.modified));
              dbox_show (d);
              dbox_raw_eventhandler (d, sprite_file_info_events, NULL);
            }
          }
        break;

        case m_Misc_SBName:
        case m_Misc_SBSize:
        { /* Sort by name or size */
          sprite_area   *unsorted = window->data->file.spritearea;
          int            count = unsorted->number;

          if (count < 2) break; /* Not worth sorting */

          sprite_tosort  tosort[count];
          sprite_tosort *tosortptr[count];

          /* variable length array allocation may have caused flex blocks to move - re-fetch sprite area pointer */
          tosort[0].orgsprite = NULL; /* Paranoia - try and ensure compiler doesn't postpone array allocation */
          tosortptr[0] = NULL;
          unsorted = window->data->file.spritearea;

          sprite_area   *sorted;
          sprite_header *header;
          main_file     *file = &window->data->file;
          main_sprite   *sprite;
          int            loop, next;
          BOOL           byname = (hit[1] == m_Misc_SBName);
          os_regset      regs;


          ftracef1 ("sort - sorting %d sprites\n", count);
          count = 0;
          for (sprite = file->sprites; sprite != NULL; sprite = sprite->link)
          { if (byname)
            { /* Sprite names can be the full 12 letters long so take a copy */
              memcpy ((char *)tosort[count].type.orgname,
                     ((char *)unsorted) + sprite->offset + offsetof (sprite_header, name),
                     NAME_LIMIT);
              tosort[count].type.orgname[NAME_LIMIT] = '\0'; /* Ensure a string terminator */
            }
            else
            { /* Infer the size */
              header = (sprite_header *)((int)unsorted + sprite->offset);
              tosort[count].type.orgsize = header->next;
            }
            tosort[count].orgsprite = sprite; /* Remember its corresponding structure */
            tosortptr[count] = &tosort[count];
            count++;
          }

          regs.r[0] = count;
          regs.r[1] = (int)&tosortptr;
          regs.r[2] = byname ? 4 : 2;
          if (regs.r[1] & 0xE0000000)
          { /* Too high - give it to HeapSort32 to jiggle the pointers */
            regs.r[7] = 0;
            if (wimpt_complain (os_swix (OS_HeapSort32, &regs)) != NULL)
              break;
          }
          else
          { /* Give it to HeapSort to jiggle the pointers */
            if (wimpt_complain (os_swix (OS_HeapSort, &regs)) != NULL)
              break;
          }

          for (loop = 0; (loop < (count-1)) && (tosortptr[loop] < tosortptr[loop+1]); loop++)
          { /* Nothing */
          }
          if (loop==(count-1)) break; /* They were already in order */

          visdelay_begin ();

          /* Allocate a new blank area to copy into */
          if (!flex_alloc ((flex_ptr)&sorted, unsorted->size))
          { werr (FALSE, msgs_lookup ("PntEG"));
            break;
          }
          ftracef1 ("sort flex'd %08X\n", (char *)sorted);
          unsorted = window->data->file.spritearea; /* Might have shifted */
          sorted->size   = unsorted->size;
          sorted->number = count;
          sorted->sproff = next = 16;

          for (loop = 0; loop < count; loop++)
          { int size;
            /* For each sprite in the sorted pointers, locate the unsorted one, copy it */
            header = (sprite_header *)((int)unsorted + tosortptr[loop]->orgsprite->offset);
            size = header->next;
            ftracef2 ("sort selected %08X size %d\n", (int)header, size);
            memcpy ((char *)sorted + next, (char *)header, size);
            next = next + size;

            /* Append its structure to the list, when the file is marked as changed later
               a call to psprite_recalculate_offsets fixes up the spriteno and offset
               fields */
            if (loop == 0)
              file->sprites = tosortptr[loop]->orgsprite; /* Head */
            else
              sprite->link = tosortptr[loop]->orgsprite;
            sprite = tosortptr[loop]->orgsprite;
          }

          /* End the sprite area nicely */
          sprite->link = NULL;
          sorted->freeoff = next;
          flex_free ((flex_ptr)&window->data->file.spritearea);

          /* Reanchor the flex block assuming the format is
                                        int anchor
                                        int size
                            flex_ptr -> char store[] */ 
          *((int *)sorted - 2) = (int)&window->data->file.spritearea;
          window->data->file.spritearea = sorted;
          ftracef2 ("sort budg'd from %08X to %08X\n", (int)unsorted, (int)sorted);

          menus_file_has_changed (window);
          visdelay_end ();
        }
        break;
      }
    break;

    case m_Save:
      ftracef0 ("File save\n");
      if (hit [1] != 0)
        /*at the dialogue box proper*/
        menus_save_file (window, TRUE);
      else
        /*Click on the menu entry*/
        menus_save_file (window, FALSE);
    break;

    case m_Create:
      if (hit [1]) psprite_create_show (window, -1, "");
    break;

    case m_Sprite:
        switch (hit [1])
        { 
          case m_Sprite_SelectAll:
            main_select_all(window);
            break;

          case m_Sprite_ClearAll:
            main_clear_all(window);
            break;

          case m_Sprite_Delete:
          { main_sprite *sprite;
            main_sprite *next;
            int count;
            int total=window->selection.count;

            if (window->selection.count==0) break;
            visdelay_begin();
            for (count=1, sprite=window->data->file.sprites; sprite != NULL;
                          sprite = next, count++)
            { visdelay_percent(count*100/total);
              next = sprite->link;
              if (sprite->flags & MSF_SELECTED)
              { sprite_area *sarea = sprite->file->spritearea;
                main_file *spritefile = sprite->file;

                sprite_id sid;
                char name [NAME_LIMIT + 1];

                sid.tag = sprite_id_name; /*doesn't flex*/
                sid.s.name = COPY_N (name, psprite_address (sprite)->name,
                    NAME_LIMIT);

                ftracef0 ("Edit delete\n");

                /*The next two lines used to be reversed, but it could give a
                  fatal error. So do it this way*/
                wimpt_complain (sprite_delete (sarea, &sid));

                menus_ensure_size(&spritefile->spritearea, 0);

                psprite_delete (window, sprite);
                ftracef0("do menus_file_has_changed\n");
                menus_file_has_changed (window);
              }
            }
            visdelay_end();
          }
          break;

        case m_Sprite_Copy:
        case m_Sprite_Rename:
          if (hit [2])
          { sprite_area **sarea = &window->data->file.spritearea;
            sprite_id sid;
            char name [NAME_LIMIT + 1];

            if (strlen (spritenamebuffer) == 0)
            { werr (FALSE, msgs_lookup ("PntE7"));
              break;
            }

            if (hit[1] == m_Sprite_Copy)
              /*Copy*/
              if (menus_sprite_exists (*sarea, spritenamebuffer))
                break;

            sid.tag = sprite_id_name; /*doesn't flex*/
            sid.s.name = COPY_N (name, psprite_address (hit_sprite)->name,
                NAME_LIMIT);

            if (hit [1] == m_Sprite_Copy)
            { /*Copy*/
              char *msg = NULL;
              os_error *error;

              if (!menus_ensure_size (sarea, psprite_address (hit_sprite)->next))
              { msg = msgs_lookup ("PntEG");
                goto copied;
              }

              /*psprite_drop_translation (&hit_sprite->transtab);
                  Don't beleive this. J R C 20th Jul 1994*/
              if ((error = sprite_copy (hit_sprite->file->spritearea,
                  &sid, spritenamebuffer)) != NULL)
              { msg = error->errmess;
                goto copied;
              }

              menus_sprite_new (window, /*hack palette?*/ FALSE);
              /* force summary window to be updated */
              window->data->file.lastwidth = 0;
              main_set_extent (window);

            copied:
              if (msg != NULL) werr (FALSE, msg);
            }
            else
            { /*Rename*/
              if (wimpt_complain (sprite_rename
                  (hit_sprite->file->spritearea, &sid, spritenamebuffer)) !=
                  NULL)
                break;
              menus_file_has_changed (window);
              sprwindow_set_window_titles (hit_sprite);

              /* rename must reset the titles of all the windows open on
                the sprite */
              if (hit_sprite->colourdialogue != NULL)
              { char new_title [80];
                colourpicker_dialogue dialogue;

                dialogue.title = new_title;
                sprintf (new_title, msgs_lookup ("PntW7"), spritenamebuffer);
                ftracef0 ("ColourPicker_UpdateDialogue: setting new title");
                os_swix3 (ColourPicker_UpdateDialogue,
                    colourpicker_UPDATE_TITLE, hit_sprite->colourdialogue,
                    &dialogue);
              }
              else if (hit_sprite->colourhandle != NULL)
              { wimp_winfo winfo;
                wimp_redrawstr redraw_str;
                wimp_wstate wstate;

                winfo.w = hit_sprite->colourhandle;
                wimpt_noerr (paintlib_get_wind_info (&winfo));

                sprintf (winfo.info.title.indirecttext.buffer,
                    msgs_lookup ("PntW7"), spritenamebuffer);

                /*Force redraw of the title bar.*/
                wimpt_noerr (wimp_get_wind_state
                    (hit_sprite->colourhandle, &wstate));

                redraw_str.w = hit_sprite->colourhandle;
                wimpt_noerr (wimp_getwindowoutline (&redraw_str));

                redraw_str.w = -1;
                redraw_str.box.y0 = wstate.o.box.y1;
                wimpt_noerr (wimp_force_redraw (&redraw_str));
              }
            }
          }
        break;

        case m_Sprite_Save:
          ftracef1 ("File sprite save %x\n", hit_sprite);
          if (hit [2])
            menus_save_selection (window);
        break;

        case m_Sprite_Info:
          ftracef1 ("hit_sprite @@ %x\n", hit_sprite);
          if (hit [2])
            display_sprite_info (hit_sprite);
        break;

        case m_Sprite_Print:
          /*FIX G-RO-9923 JRC 15 Oct '91 Print on choosing Print.*/
          menus_print_sprite (hit_sprite, /*ask?*/ hit [2] != 0);
        break;
      }
    break;

    case m_Display:
      switch (hit [1])
      { case m_Display_Name:
          ftracef0 ("Display format icons\n");
          window->data->file.fullinfo = 0;
          main_current_options.display.full_info = FALSE;

          /*force the redraw to change*/
          window->data->file.lastwidth = 0;
          main_force_redraw (window->handle);
        break;

        case m_Display_Full:
        { wimp_winfo curr;

          ftracef0 ("Display format info\n");
          window->data->file.fullinfo = 1;
          main_current_options.display.full_info = TRUE;

          /*Change window width to allow one full item, if it is less.*/
          curr.w = window->handle;
          wimpt_noerr (paintlib_get_wind_info (&curr));

          ftracef2 ("current width is %d; need %d\n",
              curr.info.box.x1 - curr.info.box.x0,
              main_FILER_FullInfoWidth);
          if (curr.info.box.x1 - curr.info.box.x0 <
              main_FILER_FullInfoWidth)
          { curr.info.box.x1 = curr.info.box.x0 + main_FILER_FullInfoWidth;
            wimpt_noerr (wimp_open_wind ((wimp_openstr *) &curr));

            /*force the redraw to change*/
            window->data->file.lastwidth = 0;
            main_force_redraw (window->handle);
          }
        }
        break;

        case m_Display_UseDT:
          ftracef0 ("Toggle palette flag\n");
          { main_sprite *sprite;
            main_file *file = &window->data->file;
            file->use_current_palette = !file->use_current_palette;

            psprite_set_colour_info (file);

            if (tools_brushsprite_ptr != NULL &&
                tools_brushsprite_ptr->file == file)
            { psprite_free_brush_blocks ();
              psprite_set_brush_colour_translations ();
            }
            else
              psprite_set_brush_translations (file);

            for (sprite = file->sprites; sprite != NULL;
                sprite = sprite->link)
            { sprwindow_redisplay (sprite, NULL);
              if (sprite->colourhandle != 0 && sprite->colourdialogue == 0)
                main_force_redraw (sprite->colourhandle);
            }

            main_current_options.display.use_desktop_colours =
                file->use_current_palette;
          }
        break;

        default:
          spencer (ftracef (__FILE__, __LINE__, "Display menu %d\n", hit [1]))
        break;
      }
      iconsize_has_changed (window);
    break;
  }
}

/***************************************************************************
 *                                                                         *
 *  Icon menu handler.                                                     *
 *                                                                         *
 ***************************************************************************/

int menus_files_modified (void)

{ int modified = 0;
  main_window *w;

  ftracef0 ("menus_files_modified\n");
  for (w = main_windows; w != 0; w = w->link)
    if (w->tag == main_window_is_file &&
        w->data->file.modified) modified++;
      return modified;
}

int menus_quit_okayed (int modified)

{ char mess [256];

  ftracef0 ("menus_quit_okayed\n");
  sprintf (mess, modified == 1? msgs_lookup ("PntF5"):
      msgs_lookup ("PntF6"), modified);
  return dboxquery_quit (mess) == dboxquery_quit_DISCARD;
}

void menus_icon_proc (void *handle, char *hit)

{ ftracef0 ("menus_icon_proc\n");
  handle = handle;

  switch (hit [0])
  { case i_Info:
      if (hit [1]) show_info_box ();
    break;

    case i_GetScreen:
      ftracef0 ("Grabbing snapshot\n");;
      main_snapshot_show ();
    break;

    case i_Quit:
      if (menus_files_modified () == 0 ||
          menus_quit_okayed (menus_files_modified ()))
      { while (main_windows->link != NULL)
          main_window_delete (main_windows);
        ftracef1 ("Icon exit %d\n", win_activeno ());
        while (win_activeno () > 0)
          win_activedec ();
        m_SUMMARY ();
      }
    break;
  }
}

/*********************************************
 *                                           *
 *  Return updated spritefile menu structure *
 *                                           *
 *********************************************/

static void hack_entry (menu menyoo, int entryno, char *name)

{ int TextWidth = main_FILER_TextWidth;
  wimp_menuhdr *header = (wimp_menuhdr *) menu_syshandle (menyoo);
  wimp_menuitem *entry = (wimp_menuitem *) (header + 1) + entryno - 1;

  ftracef1 ("hack_entry: name '%s'\n", name);

 if (strlen (name) > 10)
     TextWidth = TextWidth - 4;

 header->width = (strlen (name)+1) * (TextWidth);
 if (header->width < (TextWidth)*10)
     header->width = (TextWidth) * 10;

 entry->data.indirecttext.buffer = name;
 entry->data.indirecttext.bufflen = 1;
 entry->data.indirecttext.validstring = NULL;
 entry->iconflags = (wimp_iconflags) (entry->iconflags | wimp_INDIRECT);
}

menu menus_file_maker (void *handle)

{ 
  main_window *window =(main_window *) handle;
  main_file *file = &window->data->file;

  int len;
  char term [2];
  
  altrename_delete();

  ftracef0 ("spritefile_menu_maker\n");
  if (!event_is_menu_being_recreated ())
  { 
    hit_sprite = main_pick_menu_button_sprite ((main_window *) handle);

    ftracef1 ("hit_sprite set to %x\n", hit_sprite);
  }
  else
  { main_sprite *sprite;

    for (sprite = file->sprites; sprite != NULL && sprite != hit_sprite;
        sprite = sprite->link);
    hit_sprite = sprite;   /* set to same or zero if sprite gone */
  }

  if (window->selection.count!=1)
  {
    strcpy (Spritename, msgs_lookup ("PntG6"));
  }
  else
  {
    strcpy (Spritename, msgs_lookup ("PntG1"));
    len = strlen (Spritename);
    term [0] = Spritename [len - 1], term [1] = '\0';
    Spritename [len - 1] = '\0';
  
    if (hit_sprite != NULL)
    { char *nameptr = psprite_address (hit_sprite)->name;
      int i;

      for (i = 0; i < 12 && nameptr [i] > ' '; i++)
        spritenamebuffer [i] = nameptr [i];
      spritenamebuffer [i] = '\0';
    }
    else
      strcpy (spritenamebuffer, "");

    strcat (Spritename, spritenamebuffer);
    strcat (Spritename, term);
  }

  hack_entry (spritefile_main_menu, m_Sprite, Spritename);

  /* When there are no sprites in the file, forbid its saving & selecting */
  menu_setflags (spritefile_main_menu, m_Save, 0,
                 (file->spritearea->number == 0));
  menu_setflags (spritefile_main_menu, m_Sprite, 0,
                 (file->spritearea->number == 0));

  menu_setflags (filedisplay_menu, m_Display_Name, !file->fullinfo, 0);
  menu_setflags (filedisplay_menu, m_Display_Full, file->fullinfo, 0);
  menu_setflags (filedisplay_menu, m_Display_UseDT,
                 file->use_current_palette, 0);

  menu_setflags (sprite_selection_menu, m_Sprite_ClearAll, 0, window->selection.count==0);
  menu_setflags (sprite_selection_menu, m_Sprite_Copy, 0, window->selection.count!=1);
  menu_setflags (sprite_selection_menu, m_Sprite_Rename, 0, window->selection.count!=1);
  menu_setflags (sprite_selection_menu, m_Sprite_Delete, 0, window->selection.count==0);
  menu_setflags (sprite_selection_menu, m_Sprite_Save, 0, window->selection.count==0);
  menu_setflags (sprite_selection_menu, m_Sprite_Info, 0, window->selection.count!=1);
  menu_setflags (sprite_selection_menu, m_Sprite_Print, 0, window->selection.count!=1);


  help_register_handler (&help_simplehandler, (void *) "FILER");

  return spritefile_main_menu;
}

/*********************************************
 *                                           *
 *  Return updated sprite menu structure     *
 *                                           *
 *********************************************/

menu menus_sprite_maker (void *handle)

{ main_window *window = (main_window *) handle;
  main_sprite_window *sprw = &window->data->sprite;
  BOOL read_only = sprw->read_only;
  main_sprite *sprite = sprw->sprite;
  int i, no_colours = colours_count (sprite);

  ftracef0 ("menus_sprite_maker\n");

  if (!event_is_menu_being_recreated ())
  { wimp_mousestr mouse;

    wimpt_noerr (wimp_get_point_info (&mouse));
    tools_mouse_to_pixel (window, &mouse, &Column, &Row);
    ftracef4 ("row %d, column %d, width %d, height %d\n", Row, Column,
        psprite_address (sprite)->width + 1,
        psprite_address (sprite)->height + 1);
  }

  menu_setflags (sprite_paint_menu, s_Paint_ECF,
      /*tick?*/ FALSE, /*grey?*/ read_only || no_colours > 256);
      /*only allow ECF's to be defined for shallow sprites - a colour picker
          allows no way of selecting them for deep sprites. J R C 9th Feb
          1995*/
  menu_setflags (sprite_paint_menu, s_Paint_Sel_Col,
      /*tick?*/ FALSE, /*grey?*/ read_only);

  menu_setflags (sprite_edit_menu, s_Edit_FlipV,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_FlipH,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Rotate,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Scale_X,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Scale_Y,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Shear,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Adjust,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_InsCol,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_InsRow,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_DelCol,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_DelRow,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Mask,
      /*tick?*/ psprite_hasmask (sprite), /*grey?*/ psprite_transparency_type(sprite) == transparency_type_alphachannel);
  menu_setflags (sprite_edit_menu, s_Edit_Palette,
      /*tick?*/ psprite_haspal (sprite),
      /*grey?*/ no_colours > 256 /*was (unsigned) saddr->mode > 255 J R C 6th Oct 1994*/);

  menu_setflags (sprite_main_menu, s_Grid,
      /*tick?*/ sprw->gridcol != 255, FALSE);

  for (i=0; i<16; i++)
    menu_setflags (sprite_colour_menu, i + 1,
        /*tick?*/ sprw->gridcol == i, /*grey?*/ FALSE);

  menu_setflags (sprite_save_menu, s_Save_Palette,
      /*tick?*/ FALSE, /*grey?*/ !psprite_haspal (sprite));
  menu_setflags (sprite_paint_menu, s_Paint_Show_Col,
      /*tick?*/ FALSE,
      /*grey?*/ read_only);
  menu_setflags (sprite_paint_menu, s_Paint_Small,
      /*tick?*/ sprite->coloursize == colours_SIZE/2,
      /*grey?*/ no_colours > 256);
  menu_setflags (sprite_paint_menu, s_Paint_Edit_Pal,
      /*tick?*/ FALSE, /*grey?*/ !(psprite_hastruecolpal (sprite) &&
      !sprite->gcol.ecf && sprite->gcol.colour < no_colours));

  /*strcpy (rotatebuffer, "90");
  strcpy (scalebuffer, "1");
  strcpy (shearbuffer, "0")*/

  help_register_handler (&help_simplehandler, (void *) "EDIT");

  return sprite_main_menu;
}

/******************************************
 * Initialise the static menu structures  *
 ******************************************/

static menu make_menu2 (char *titletag, char *bodytag)

{ ftracef0 ("make_menu2\n");
  ftracef2 ("titletag is \"%s\", bodytag is \"%s\"\n", titletag, bodytag);
  return menu_new (msgs_lookup (titletag), msgs_lookup (bodytag));
}

static menu make_menu1 (char *titletag, char *body)

{ ftracef0 ("make_menu1\n");
  ftracef2 ("titletag is \"%s\", body is \"%s\"\n", titletag, body);
  return menu_new (msgs_lookup (titletag), body);
}

void menus_init (void)

{ menu temp2, temp3, temp4, temp5;

  ftracef0 ("init_menus_init\n");

  spritefile_main_menu = make_menu2 ("Pnt00", "PntM3");

  sprite_selection_menu = make_menu2 ("PntM4", "PntM5");
  temp2 = make_menu1 ("PntM6", "123456789012");
  menu_make_writeable (temp2, 1, spritenamebuffer, 13, "A~ ");
  menu_submenu (sprite_selection_menu, m_Sprite_Copy, temp2);
  temp2 = make_menu1 ("PntM7", "123456789012");
  menu_make_writeable (temp2, 1, spritenamebuffer, 13, "A~ ");
  menu_submenu (sprite_selection_menu, m_Sprite_Rename, temp2);
  menu_submenu (spritefile_main_menu, m_Sprite, sprite_selection_menu);

  filedisplay_menu = make_menu2 ("PntM8", "PntM9");
  menu_submenu (spritefile_main_menu, m_Display, filedisplay_menu);

  spritefile_misc_menu = make_menu2 ("PntMM", "PntMN");
  menu_submenu (spritefile_main_menu, m_Misc, spritefile_misc_menu);

  ftracef0 ("Creating sprite_menu\n");

  sprite_main_menu = make_menu2 ("Pnt00", "PntMA");
  sprite_misc_menu = make_menu2 ("PntMK", "PntML");
  sprite_save_menu = make_menu2 ("PntMB", "PntMC");

  menu_submenu (sprite_main_menu, s_Misc, sprite_misc_menu);

  menu_submenu (sprite_main_menu, s_Save, sprite_save_menu);

  sprite_paint_menu = make_menu2 ("Pnt00", "PntMD");
  menu_submenu (sprite_main_menu, s_Paint, sprite_paint_menu);

  sprite_edit_menu = make_menu2 ("PntME", "PntMF");
  temp2 = make_menu1 ("PntMG", "?");
  menu_make_writeable (temp2, 1, rotatebuffer, 12, "A0-9\\-");
  menu_submenu (sprite_edit_menu, s_Edit_Rotate, temp2);

  temp3 = make_menu1 ("PntMJ", "?");
  menu_make_writeable (temp3, 1, scalebuffer, 12, "A0-9.eE");
  menu_submenu (sprite_edit_menu, s_Edit_Scale_X, temp3);

  temp4 = make_menu1 ("PntMJ", "?");
  menu_make_writeable (temp4, 1, scalebuffer, 12, "A0-9.eE");
  menu_submenu (sprite_edit_menu, s_Edit_Scale_Y, temp4);

  temp5 = make_menu1 ("PntMJ", "?");
  menu_make_writeable (temp5, 1, shearbuffer, 12, "A0-9\\-.eE");
  menu_submenu (sprite_edit_menu, s_Edit_Shear, temp5);

  menu_submenu (sprite_main_menu, s_Edit, sprite_edit_menu);

  sprite_colour_menu = colourmenu_make (msgs_lookup ("PntMH"), 0);
  menu_submenu (sprite_main_menu, s_Grid, sprite_colour_menu);
}
@


4.16
log
@Warning suppression
Detail:
  3 fewer compiler warnings.
Admin:
  Submission for the Paint bounty.
  Built, but no run time testing.
@
text
@d1259 1
a1259 1
static void showmag (void *handle)
d1943 1
a1943 1
            &sprw->blobsize.scale_xdiv, 999, 999, showmag, sprw);
@


4.15
log
@Fix unreliable sorting of sprites
Detail:
  c/Menus - Fix sprite sort code to take into account the fact that variable-length array allocations may cause flex blocks to be moved (due to CLib allocating the array from the heap)
Admin:
  Tested on Raspberry Pi
  Appears to fix 'sort by name' sometimes resulting in a random sort order being used
  Will hopefully fix 'out of memory' error reported on forums (unable to reproduce here, but this is a likely cause)
  https://www.riscosopen.org/forum/forums/4/topics/3657


Version 2.20. Tagged as 'Paint-2_20'
@
text
@d260 1
a260 1
        sprintf(temp,msgs_lookup("PntGF"),180.0f/(1<<xeig),180.0f/(1<<yeig));
@


4.14
log
@Various bugfixes. Improve sprite info dialog.
Detail:
  - Handling of currently selected foreground & background colour rewritten; colour is now stored as a 'main_colour' struct, in order to allow representation of alpha level, pixel colour/palette index (which must be 4 bytes for things like CMYK) and ECF index (previously encoded as negative colour values). Fixes crashes when editing RISC OS 5 32bpp ARGB sprites. Note that although the alpha level is now stored internally, and tools should mostly respect it, palette/colour picker limitations mean that only 0/255 is available when selecting colours.
  - "Select colour" code rewritten to decode all the new pixel formats correctly; colours_entry() now accepts a sprite mode word instead of a number-of-colours value
  - "Full info" display tweaked to give more information about the mask (now displays no mask, normal mask, alpha mask, alpha channel)
  - Sprite info dialog extended to display lots more information, including OS version compatibility
  - Fix sprite menu to disallow add/remove mask option if the sprite has a RISC OS 5 alpha channel
  - Fix ECF pattern that's used for the background of masked sprites to get black/white colour values from ColourTrans when in >8bpp modes, to ensure correct colours in new RISC OS 5 modes
  - Fix palette window to render ECF patterns correctly - when creating the sprite that shows the ECF pattern in the palette, psprite_setup_ecf() was failing to set its palette due to passing a sprite pointer to ColourTrans but setting the flags as if it was a sprite name
  - Fix sprwindow_redisplay() and sprwindow_invalidate() to refresh the display correctly when in full info mode; was previously assuming only one column of sprites visible
  - Fix sprites with alpha channels to have the mask ECF pattern plotted in the background
  Files changed:
  - Resources/UK/Messages, Resources/UK/Templates,fec, c/Colours, c/Main, c/Menus, c/PSprite, c/SprWindow, c/Tools, h/Colours, h/MenuD, h/PSprite, h/main
Admin:
  Tested on BB-xM
  Amongst others, fixes issue reported on forums with spritefile window not refreshing correctly when in full info display with multiple columns:
  http://www.riscosopen.org/forum/forums/8/topics/2146?page=5#posts-31272


Version 2.16. Tagged as 'Paint-2_16'
@
text
@d2434 12
a2447 1
          int            count = unsorted->number;
a2451 2
          sprite_tosort  tosort[count];
          sprite_tosort *tosortptr[count];
a2453 1
          if (count < 2) break; /* Not worth sorting */
@


4.13
log
@Fix rendering issues in new screen modes. Add basic support for new sprite types.
Detail:
  c/Main, c/PSprite, h/main - Update window background rendering & sprite translation table caching to work properly with new screen modes.
  c/Main, c/Menus, c/PSprite, h/PSprite, h/main - Code to generate description text for sprite colour count now uses new shared function, psprite_get_colours(), which understands the new sprite formats and won't crash horribly if given something unknown.
Admin:
  Tested on BB-xM with new format sprites and new screen modes
  Needs extending to report more info about new format sprites (RGB order, alpha channel, wide mask, etc.) along with relevant editing facilities.
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 2.15. Tagged as 'Paint-2_15'
@
text
@d61 2
d174 1
d182 1
a182 1
    { dbox_setfield   (d, d_Info_Type, msgs_lookup ("PntWB"));
d187 76
a262 3
      char *ncol = psprite_get_colours(info.mode);
      dbox_setfield (d, d_Info_Type, msgs_lookup ("PntWC"));
      dbox_setfield (d, d_Info_Mode, ncol);
d265 35
a299 1
    dbox_setfield (d, d_Info_Mask, yesno (info.mask));
d311 101
a411 2
    dbox_setfield   (d, d_Info_Palette, yesno (info.palette));
    dbox_setnumeric (d, d_Info_Size,    info.size);
d492 6
a497 2
  sprite->gcol = colours_count (sprite) - 1;
  sprite->gcol2 = 0;
d1384 1
a1384 1
  int *colour = &(&spr->mode + 1) [2*sprite->gcol];
d1504 1
a1504 2
        { int nc = colours_count (sprite);
          sprite_id sid;
d1506 2
a1507 1
          sprite_maskstate mask;
d1519 3
a1521 11
          if
          ( psprite_hasmask (sprite) &&
            ( wimpt_noerr (sprite_readmask (sprite->file->spritearea, &sid,
                  Column, Row, &mask)),
              mask == sprite_masktransparent
          ) )
          { ftracef0 ("pixel = transparent\n");
            sprite->gcol = nc;
          }
          else
          { sprite_colour colour;
d1523 1
a1523 1
            wimpt_noerr (main_read_pixel (sprite->file->spritearea,
a1524 2
            ftracef5 ("read pixel (col %d, row %d) c %d, t %d, nc 0x%X\n",
                Column, Row, colour.colour, colour.tint, nc);
d1526 1
a1526 7
            if (nc != 256 || psprite_hastruecolpal (sprite))
              sprite->gcol = colour.colour;
            else
              sprite->gcol =
                  colours_gcol_ttab [colours_gcol_ttab [colours_gcol_ttab
                  [colour.colour]]] << 2 | colour.tint >> 6;
          }
d1533 1
a1533 1
            if (sprite->gcol == nc)
d1541 1
a1541 1
            { dialogue.colour = colours_entry (nc, sprite->gcol);
d1579 1
a1579 1
            int *colour = &(&spr->mode + 1) [sprite->gcol*2];
d1914 3
a1916 4
          { int nc = colours_count (sprite);

            if (sprite->gcol  == nc) sprite->gcol--;
            if (sprite->gcol2 == nc) sprite->gcol2--;
d3013 1
a3013 1
      /*tick?*/ psprite_hasmask (sprite), /*grey?*/ FALSE);
d3035 1
a3035 1
      0 <= sprite->gcol && sprite->gcol < no_colours));
@


4.12
log
@Sprite filer selection logic made consistent with filer
Specifically, in the filer when you menu click on a file it is temporarily selected. Clicking on a different file loses the first temporary selection and moves the highlight to the new file. This behaviour is skipped if there are already files selected (using left or right click).
This change makes !Paint behave this way too, previously the menu click was a permanent selection, so menu clicking elsewhere on a different sprite would actually manipulate the sprite selected some time earlier - very confusing.
Tidy ups
 * Remove hardwired mouse button bitmask operations, now uses defines from <wimp.h>.
 * Use OS_Byte numbers from header

Version 2.12. Tagged as 'Paint-2_12'
@
text
@d183 2
a184 4
    { int T = (unsigned) info.mode >> 27;
      char *ncol [] =
          {"2", "4", "16", "256", "32k", "16M"};

d186 1
a186 1
      dbox_setfield (d, d_Info_Mode, ncol [T - 1]);
@


4.11
log
@Simplify _swix to os_swix.
Function main_icon_bboxes() reordered to only call the SWIs it needs to fulfil the requested information.

Version 2.04. Tagged as 'Paint-2_04'
@
text
@d942 1
a942 1
  if ((mpos->bbits & 4) && window->data->sprite.sprite == insdel_sprite)
d1501 1
a1501 1
              adjust = (mouse_str.bbits & 1) != 0;
@


4.10
log
@Clean up pass.
No functional changes, but it's now a consistent ball of spaghetti.
@
text
@d882 2
a883 2

{ int xmul = sprw->blobsize.scale_xmul*insdel_sprite->mode.scale_xmul;
d990 2
a991 1
{ ftracef0 ("insdeltool_redraw\n");
d1109 3
a1117 3
  /*Note: this routine assumes the palette is the right length for the
    sprite.*/

d2227 1
a2227 1
              _swix (OS_ConvertFileSize, _INR(0,2), sarea->size, &sizestring, 32);              
d2249 1
d2273 4
a2276 1
          if (((int)&tosortptr) & 0xE0000000)
d2278 2
a2279 2
            if (wimpt_complain (_swix (OS_HeapSort32, _INR(0,2) | _IN(7),
                                       count, &tosortptr, byname ? 4 : 2, 0)))
d2284 1
a2284 2
            if (wimpt_complain (_swix (OS_HeapSort, _INR(0,2),
                                       count, &tosortptr, byname ? 4 : 2)))
d2378 2
a2379 2
            for (count = 1, sprite = window->data->file.sprites; sprite != NULL;
                            sprite = next, count++)
d2685 2
a2686 1
{ main_window *window =(main_window *) handle;
@


4.9
log
@Prune the plethora of targets a bit.
Spurious ';' after an if at line 2386 of c.Main deleted, something to do with scroll wheel support. Untested.
Refer to FileType_ using the filetypes header file.
Internationalised "Selection" when saving a sprite selection.
main_save_selection wasn't checking if fwrite() worked so never reported 'disc full'.
Turn on egg timer during main_save_selection().
Fix (de)selection bug when in full sprite info view, the 'spritesperrow' was being rounded down to zero, and unlike everywhere else it wasn't being adjusted back to a minimum of 1.

Version 2.03. Tagged as 'Paint-2_03'
@
text
@d403 1
a403 1
#if (1)
d406 1
a406 3
#else
  res = xfersend (filetype, name, estsize, p1, p2, p3, handle);
#endif
d566 2
a567 1
  } }
d592 1
a592 1
  /* if something is already there,remember its attributes */
d704 2
a705 2
{
  ftracef0 ("menus_save_selection\n");
d708 9
a716 5
  {
    main_sprite *sprite;
    for (sprite=window->data->file.sprites;sprite;sprite=sprite->link)
    {
      if (sprite->flags & MSF_SELECTED) break;
a717 1
    if (sprite) menus_save_sprite(sprite);
d736 2
a737 7
      psprite_address (sprite)->next + sizeof (sprite_area),
      &save_sprite, &buffer_sprite,
      &Do_Print, /*Protocol now in xfersend(), immediate printing
          allowed. Was NULL. JRC 4 Apr 1992*/
      /*FIX G-RO-7139 JRC 16 Oct '91 Use new printer protocol - was
        &call_print_sprite*/
      sprite);
d809 2
a810 1
  } }
d865 1
a865 1
        sprite=sprite->link)
d882 2
a883 2
{
  int xmul = sprw->blobsize.scale_xmul*insdel_sprite->mode.scale_xmul;
d896 2
a897 2
    int top=MAX(insdel_row,Row)+1;
    int bottom=MIN(insdel_row,Row);
d904 2
a905 2
    int left=MIN(insdel_col,Column);
    int right=MAX(insdel_col,Column)+1;
d923 1
a923 1
    wimpt_noerr (PaintLib_get_wind_info (&curr));
d932 1
a932 2
    { 
      insdel_drawEOR(sprw,x0,y0);
d990 1
a990 2
{ 
  ftracef0 ("insdeltool_redraw\n");
d993 1
a993 1
      insdel_drawEOR(&window->data->sprite,x0,y0);
a1107 3
  /*Note: this routine assumes the palette is the right length for the
    sprite.*/

d1114 3
d1147 2
a1148 1
  } }
d1352 3
a1354 1
        } } }
d1655 2
a1656 1
        } }
d1713 2
a1714 1
          } }
d1962 2
a1963 1
  } }
d2006 2
a2007 1
  } }
d2147 2
a2148 1
      } }
d2150 2
a2151 1
  } }
d2174 3
a2176 1
} } }
d2231 2
a2232 1
          } }
d2253 1
a2253 1
          for (sprite=file->sprites;sprite!=NULL;sprite=sprite->link)
d2359 1
a2359 1
              main_select_all(window);
d2363 1
a2363 1
              main_clear_all(window);
d2367 1
a2367 2
          { 
            main_sprite *sprite;
d2374 4
a2377 4
            for (count=1,sprite=window->data->file.sprites;sprite;sprite=next,count++)
            {
              visdelay_percent(count*100/total);
              next=sprite->link;
d2379 1
a2379 2
              {
                sprite_area *sarea = sprite->file->spritearea;
d2395 1
a2395 1
                menus_ensure_size(&spritefile->spritearea,0);
d2397 1
a2397 1
                psprite_delete (window,sprite);
a2399 1
                ftracef0("do menus_ensure_size(,0)\n");
d2481 1
a2481 1
                wimpt_noerr (PaintLib_get_wind_info (&winfo));
d2496 3
a2498 1
          } } }
d2541 1
a2541 1
          wimpt_noerr (PaintLib_get_wind_info (&curr));
d2681 1
a2681 2
{ 
  main_window *window =(main_window *) handle;
d2687 1
a2687 1
  AltRename_delete();
d2706 1
a2706 1
    strcpy (Spritename,msgs_lookup ("PntG6"));
d2732 1
a2732 1
  /* When there are no sprites in the file,forbid its saving & selecting */
d2735 1
a2735 1
  menu_setflags (spritefile_main_menu,m_Sprite, 0,
d2739 1
a2739 1
  menu_setflags (filedisplay_menu, m_Display_Full,  file->fullinfo, 0);
d2743 7
a2749 7
  menu_setflags (sprite_selection_menu,m_Sprite_ClearAll,0,window->selection.count==0);
  menu_setflags (sprite_selection_menu,m_Sprite_Copy,0,window->selection.count!=1);
  menu_setflags (sprite_selection_menu,m_Sprite_Rename,0,window->selection.count!=1);
  menu_setflags (sprite_selection_menu,m_Sprite_Delete,0,window->selection.count==0);
  menu_setflags (sprite_selection_menu,m_Sprite_Save,0,window->selection.count==0);
  menu_setflags (sprite_selection_menu,m_Sprite_Info,0,window->selection.count!=1);
  menu_setflags (sprite_selection_menu,m_Sprite_Print,0,window->selection.count!=1);
@


4.8
log
@Fix abort when sorting the sprites by name and one or more sprite viewers
are open, also massively simplified it since the copying around of
main_sprite blocks was pointless - much simpler to just rejoin the linked
list leaving the data in place.
*Tidy up
 Delete awk.*, change to use central 'AwkVers' script.
 Delete h.types.
 Delete h.Paint, it's a duplicate of h.main.
 Delete writepixel, swap to using the one in RISCOS_Lib
 Retire 'h.fixes', switches collapsed, bugfixes proven after 18 years use.
 Cast away some warnings.
 Sprinkled in some consts, moved pointer qualifiers to get syntax colouring
 right.
 Remove local SWI defines, read from <swis.h> now.
 !MkInstall now installs into <Install$Dir>.Apps
*Little UI changes
 Make the colour number in the colour picker be in the right place vertically
 and correct horizontal position of 'T' and 'E' for ECFs.
 In the create new sprite dialogue box the 32k and 16M options are shaded
 when a palette is requested, this avoids the problem of selecting a deep
 colour mode (which trapped the radio icon in a shaded paletted selection).
 The 'Selection' menu is now shaded when there are zero sprites in the
 file
*Sprite filer
 Fix tiled main window fill to work in EX0 modes and not overwrite in EX2
 modes (was using the sprite's mode word not the current mode to deduce eigen
 factors), leading to odd chequer board areas not being redrawn.
 Refactored main_clear_background() to use stronger typing of RISC_OSLib
 rather than _swix where possible.
 A failure to get the Wimp pixel translation table now falls back to solid
 fill
 Double clicking on a sprite in the sprite file window no longer leaves it
 selected, to mimic the filer.
 Set DISPLAY_MARGIN to 0 to counter for the recent increase from 32 to 40
 of main_FILER_TextHeight
 Added 'Sort by size' after 'Sort by name'

Version 2.02. Tagged as 'Paint-2_02'
@
text
@d60 1
d508 1
a508 1
    file_str.loadaddr = SPRITE_FILE;
d597 1
a597 1
  r.r [2] = 0xFED;
d719 3
a721 1
  myxfersend (SPRITE_FILE,"Selection",main_selection_file_size(window),main_save_selection,0,0,window);
d733 1
a733 1
  myxfersend (SPRITE_FILE, name,
d757 1
a757 1
    myxfersend (SPRITE_FILE, name, window->data->file.spritearea->size,
d1232 1
a1232 1
            myxfersend (0xFED, msgs_lookup ("PntG5"), size,
d1856 1
a1856 1
  if (!xfersend_print (SPRITE_FILE, info.name, info.size,
a2725 2
//  menu_setflags (spritefile_main_menu, m_Sprite, 0, hit_sprite == NULL && window->selection.count==0);

@


4.7
log
@Filename fixes for case-sensitive environments.  No functional changes.  First commit to ROOL CVS, hooray.

Version 2.00. Not tagged
@
text
@d90 1
a90 2
#undef  ColourPicker_UpdateDialogue
#define ColourPicker_UpdateDialogue 0x47704
d92 1
a92 2
#define MIN(x, y) ((x) < (y)? (x): (y))
#define MAX(x, y) ((x) > (y)? (x): (y))
d94 9
a102 6
#define COPY_N(s1, s2, n) (sprintf ((s1), "%.*s", (n), (s2)), s1)
  /*this is strncpy() really*/

#define XPDriver_DeclareFont (0x80155 | 1 << 17)

static int Do_Print (char *, void *);
d222 1
a222 1
    dbox_setfield (d, d_Prog_Version,  msgs_lookup ("PntID"));
d295 1
a295 21
#if 1
#if FIX0770
/*
 * OK: this is what *I* think menus_ensure_size() is supposed to do.
 *
 * bytesneeded > 0: if not at least <bytesneeded> bytes free in sprite area,
 *                  extend it.
 * bytesneeded < 0: reduce size of sprite area by <bytesneeded> bytes. This
 *                  used to do this regardless but I have changed it so
 *                  that it never reduces it such that the free offset points
 *                  outside the area. This should fix many bugs.
 * bytesneeded = 0: reduce size of sprite area to exactly what is needed by
 *                  the contents of the area.
 *
 * Hence I expect an operation that changes the size of a sprite area to
 * do an menus_ensure_size( , 0) on completion to release the free space. This seems
 * to be what is done so was probably the intention.
 *
 * Christopher Partington  18-Feb-1992
 */
#endif
a298 1
#if FIX9544
d300 19
a318 1
#endif
d339 1
a339 1
#if FIX0770
a354 1
#endif
a355 1
#if FIX9544
a362 4
#else
  if (!flex_extend ((flex_ptr) sarea,
      flex_size ((flex_ptr) sarea) + bytesneeded))
#endif
a369 26
#else
int menus_ensure_size (sprite_area **sarea, int bytesneeded)

{ int bytesfree = (*sarea)->size - (*sarea)->freeoff;

  ftracef1 ("menus_ensure_size of %d\n", bytes_needed);
  if (bytesneeded < 0)
  { ftracef0 ("Asked to shrink negatively\n");
    bytesneeded = 0;
  }

  bytesneeded -= bytesfree;         /* amount needed */
  bytesneeded += 256;               /* and a little headroom */

  ftracef3 ("Extend sprite area from %d by %d (spare %d)\n",
      flex_size ((flex_ptr) sarea), bytesneeded, bytesfree);
  if (!flex_extend ((flex_ptr) sarea,
      flex_size ((flex_ptr) sarea) + bytesneeded))
  { main_NO_ROOM ("ensure size");
    return 0;
  }

  (*sarea)->size += bytesneeded;
  return 1;
}
#endif
d703 1
a703 1
static void menus_save_selection (main_window* window)
d709 1
a709 1
    main_sprite* sprite;
d880 1
a880 1
static void insdel_drawEOR(main_sprite_window* sprw,int x0,int y0)
d2224 4
a2227 8
        case m_Misc_SBName: {
          /* Sort by name */
          sprite_area  *sarea = window->data->file.spritearea;
          int          count  = sarea->number;

          if (count < 2) break; /* Not worth sorting */

          /* The sprite name has no terminator when it's 12 long,so copy and terminate the names */
d2229 6
a2234 5
          sprite_id      sid;
          main_sprite   *sprite,*nextsprite;
          main_file     *file    = &window->data->file;
          int            size    = sarea->size;
          int            loop,  next, i;
d2238 3
a2240 1
          ftracef1("sort - sorting %d sprites\n", count);
d2243 16
a2258 9
              {
              strncpy((char *)tosort[count].tosort, /* The heapsort copy */
                      ((char *)sarea) + sprite->offset + 4, /* The source name */
                      NAME_LIMIT);
              tosort[count].tosort[NAME_LIMIT] = '\0'; /* Ensure a terminator */
              tosort[count].tojumble = sprite; /* Remember the corresponding sprite structure pointer */
              tosortptr[count] = &tosort[count];
              count++;
              }
d2261 5
a2265 5
             {
             /* Too high - give it to HeapSort32 to jiggle the pointers */
             if (wimpt_complain (_swix (OS_HeapSort32, _INR(0,2) | _IN(7), count, &tosortptr, 4, 0)))
                break;
             }
d2267 5
a2271 5
             {
             /* Give it to HeapSort to jiggle the pointers */
             if (wimpt_complain (_swix (OS_HeapSort, _INR(0,2), count, &tosortptr, 4)))
                break;
             }             
d2274 2
a2275 3
              {
              /* Nothing */
              }
d2280 9
a2288 8
          /* Copy them over to a new area in the right order */
          if (!flex_alloc((flex_ptr) &sorted, size))
             {
             werr (FALSE, msgs_lookup ("PntEG"));
             break;
             }
          ftracef1("sort flex'd %08X\n",(char *)sorted);
          sorted->size   = size;
a2290 8
          if ((nextsprite = m_ALLOC( sizeof(main_sprite))) == NULL)
             { main_NO_ROOM ("sort rebuild link");
               visdelay_end ();
               flex_free ((flex_ptr) &sorted);
               break;
               /* If this happens it'll revert to the old unsorted sprite */
             }
          file->sprites = nextsprite;
d2292 17
a2308 30
              {
              sprite     = nextsprite;
              sid.s.name = tosortptr[loop]->tosort;
              sid.tag    = sprite_id_name;
              sarea      = window->data->file.spritearea; /* Incase flex shuffled */
              sprite_select_rp(sarea, &sid, &sid.s.addr); /* Will succeed as they were there about 15 lines ago */
              size = ((sprite_header *) sid.s.addr)->next;
              ftracef2("sort selected %08X size %d\n",(int)sid.s.addr, size);
              memcpy((char *)sorted + next,(char *)sid.s.addr, size);
              next = next + size;
              /* Now magic up a new sprite info block */
              sprite->file     = tosortptr[loop]->tojumble->file;
              sprite->windows  = tosortptr[loop]->tojumble->windows;
              sprite->transtab = tosortptr[loop]->tojumble->transtab;
              sprite->mode     = tosortptr[loop]->tojumble->mode;
              sprite->iconsize = tosortptr[loop]->tojumble->iconsize;
              sprite->colourhandle = tosortptr[loop]->tojumble->colourhandle;
              for (i = 0; i < 4; i++) sprite->ECFs [i].sarea = tosortptr[loop]->tojumble->ECFs [i].sarea;              
              sprite->gcol     = tosortptr[loop]->tojumble->gcol;
              sprite->gcol2    = tosortptr[loop]->tojumble->gcol2;
              for (i = 0; i < toolspacesize; i++) sprite->toolspace [i] = tosortptr[loop]->tojumble->toolspace [i];
              sprite->colourdialogue = tosortptr[loop]->tojumble->colourdialogue;
              sprite->colourtitle = tosortptr[loop]->tojumble->colourtitle;
              sprite->needsnull= tosortptr[loop]->tojumble->needsnull;
              sprite->coloursize  = tosortptr[loop]->tojumble->coloursize;
              /* Free the original,as that linked list is dead now */
              m_FREE(tosortptr[loop]->tojumble, sizeof(main_sprite));
              nextsprite = m_ALLOC( sizeof(main_sprite));
              sprite->link = nextsprite;
              }
d2310 1
a2310 2
          /* Free the original area,and update pointers */
          m_FREE(nextsprite, sizeof(main_sprite));
d2312 4
a2315 5
          sorted->number  = count;
          sorted->freeoff = next;          
          flex_free((flex_ptr) &window->data->file.spritearea);
          *((int *)sorted - 2) =
                            /* Reanchor the flex block assuming the format is
d2318 2
a2319 2
                                        char store */
                            (int)&window->data->file.spritearea;
d2321 3
a2323 3
          ftracef1("sort budg'd %08X\n",(char *)sorted);
          psprite_recalculate_offsets (file);
          menus_file_has_changed(window);
d2325 1
a2325 1
          }
a2326 1

d2357 2
a2358 2
            main_sprite* sprite;
            main_sprite* next;
a2370 1
#if FIXDELSPR
d2372 1
a2372 1
#endif
d2385 1
a2385 1
#if FIXDELSPR
d2387 1
a2387 1
#endif
a2391 3
#if !FIXDELSPR
                menus_ensure_size (&sprite->file->spritearea, 0);
#endif     
d2672 1
a2672 1
  main_window* window =(main_window *) handle;
d2725 1
a2725 1
  /* When there are no sprites in the file,forbid its saving */
d2728 2
d2734 1
a2734 1
      file->use_current_palette, 0);
@


4.6
log
@  Bugfix of version 1.98
Detail:
  * Show error message when dragging selection fails.
  * Sprite target area in spritefile window set to a minimum height
    of 64 units and minimum width of 64 units.
  * Moving brush now redrawn in the same place that it is updated.
  * Changed moving brush plotting from EOR to NOT to stop
    black in brushes not appearing.
  * Fixed situation where the moving text y position is different
    to plotted text y position at 1:1 scale.
  * Stopped text redrawing repeatedly at the same place. This makes
    single clicks when using EOR plotting always work as expected.
    (old bug)
  * fixed width of insert/delete display at 1:1 scale.
  * fixed ftrace calls left in from changes that cause the !Debug
    compilation to fail.
  * makefile: changed OBJSZ o.Paintlib and o.AltRename. Changed o. to  oz.
  * makefile: changed OBJSD o.Paintlib and o.AltRename. Changed o. to  od.
Admin:
 Tested on Iyonix RO5.10
 Programmer tested only.
Notes:
  Changed by Colin Granville

Version 1.99. Tagged as 'Paint-1_99'
@
text
@d79 6
a84 6
#include "psprite.h"
#include "menus.h"
#include "sprwindow.h"
#include "toolwindow.h"
#include "tools.h"
#include "colours.h"
@


4.5
log
@  Changes to SpriteFile window to allow selections and
  sprite edit window changed to improve positioning accuracy.
Detail:
  * Wimp_EScroll event added to make wheelmouse work.
  * Tool rubber banding now snaps to pixel centres making location easier.
  * flickering of box stopped in move (hand) tool.
  * Bottom left of sprites used in painting aligned with grid and sprite plotted
    directly under moving version.
  * Text painting now plots under the moving version of the text.
  * copy, move and hand tools cancel dragging with Adjust.
  * SpriteFile window changed to allow selections using Select,Adjust or Drag.
  * Alt-Select/Adjust on name allows renaming of sprite.
  * TAB moves rename icon to next sprite.
  * Shift TAB moves rename icon to previous sprite
  * Ctrl-Return renames sprite and moves the rename icon to the
    next sprite.
 V2 changes
  * Rubber band rectangular boxes with 0 width or height drawn as a
   line so they don't disappear.
  * Parallelogram rubber band where all the points are in line drawn
    as a line so they don't disappear.
Admin:
  Tested on Iyonix RO5.10
  Programmer tested only.
Changed by:
  Colin Granville

Version 1.98. Tagged as 'Paint-1_98'
@
text
@a751 2
  ftracef1 ("sprite called \"%s\"\n", name);

d914 30
d951 1
a951 5
  { int xmul = sprw->blobsize.scale_xmul*insdel_sprite->mode.scale_xmul;
    int xdiv = sprw->blobsize.scale_xdiv;
    int ymul = sprw->blobsize.scale_ymul*insdel_sprite->mode.scale_ymul;
    int ydiv = sprw->blobsize.scale_ydiv;
    int more, x0, y0;
d965 2
a966 23
    { os_swi2 (OS_SetColour, 3, -1);
    #if 0 /*replace the following to avoid checking for full-palette modes.
        J R C 22nd Feb 1994*/
      bbc_gcol (3, 127);
      bbc_tint (2, 3); /*27 August 1991*/
    #endif

      if (insdel_rowfield != -1)
      { ftracef0 ("insdel_EOR row\n");
        int top=MAX(insdel_row,Row)+1;
        int bottom=MIN(insdel_row,Row);
        bbc_rectanglefill (MAX (x0, 0), y0 + bottom*ymul/ydiv,
            0x1FFF, (top - bottom)*ymul/ydiv);
      }

      if (insdel_colfield != -1)
      { ftracef0 ("insdel_EOR column\n");
        int left=MIN(insdel_col,Column);
        int right=MAX(insdel_col,Column)+1;
        bbc_rectanglefill (x0 + left*xmul/xdiv, MAX (y0, 0),
            (right-left)*xmul/xdiv, 0x1FFF);
      }

d1024 1
a1024 2
{ main_sprite_window *sprw = &window->data->sprite;

d1027 2
a1028 29
  if (sprw->sprite->needsnull)
  { int xmul = sprw->blobsize.scale_xmul*insdel_sprite->mode.scale_xmul,
      xdiv = sprw->blobsize.scale_xdiv,
      ymul = sprw->blobsize.scale_ymul*insdel_sprite->mode.scale_ymul,
      ydiv = sprw->blobsize.scale_ydiv;

    os_swi2 (OS_SetColour, 3, -1);
  #if 0 /*replace the following to avoid checking for full-palette modes.
      J R C 22nd Feb 1994*/
    bbc_gcol (3, 127);
    bbc_tint (2, 3); /*27 August 1991*/
  #endif

    if (insdel_rowfield != -1)
    { ftracef0 ("insdel_EOR row\n");
      int top=MAX(insdel_row,Row)+1;
      int bottom=MIN(insdel_row,Row);
      bbc_rectanglefill (MAX (x0, 0), y0 + bottom*ymul/ydiv,
          0x1FFF, (top - bottom)*ymul/ydiv);
    }

    if (insdel_colfield != -1)
    { ftracef0 ("insdel_EOR column\n");
      int left=MIN(insdel_col,Column);
      int right=MAX(insdel_col,Column)+1;
      bbc_rectanglefill (x0 + left*xmul/xdiv, MAX (y0, 0),
          (right-left)*xmul/xdiv, 0x1FFF);
    }
  }
@


4.4
log
@Who dares move my sprite area without my noticing?
@
text
@d87 2
d116 1
d737 20
d763 1
d765 1
d932 1
a932 1
    wimpt_noerr (wimp_get_wind_info (&curr));
d950 4
a953 2
        bbc_rectanglefill (MAX (x0, 0), y0 + Row*ymul/ydiv,
            0x1FFF, (insdel_row - Row)*ymul/ydiv);
d958 4
a961 2
        bbc_rectanglefill (x0 + Column*xmul/xdiv, MAX (y0, 0),
            (insdel_col - Column)*xmul/xdiv, 0x1FFF);
d998 4
a1001 2
  { int x, y, tempx, tempy;
    main_scaling_block *ms = &window->data->sprite.sprite->mode;
a1002 7
    tools_mouse_to_extent_coords (window, mpos, &x, &y);
    tempx = x / ms->scale_xmul;
    /* Do integer ceil() in case the xmul is a non integer multiple */
    x = tempx + (((tempx * ms->scale_xmul) < x ) ? 1 : 0);
    tempy = y / ms->scale_ymul;
    /* Do integer ceil() in case the ymul is a non integer multiple */
    y = tempy + (((tempy * ms->scale_ymul) < y ) ? 1 : 0);
a1004 3
    if (x == Column) x = Column + 1;
    if (y == Row)    y = Row    + 1;

d1010 1
a1010 1
        dbox_setnumeric (insdel_d, 0, abs (insdel_row - Row));
d1012 1
a1012 1
        dbox_setnumeric (insdel_d, 0, abs (insdel_col - Column));
d1039 5
a1043 3
    { ftracef0 ("insdeltool_redraw: row\n");
      bbc_rectanglefill (MAX (x0, 0), y0 + Row*ymul/ydiv,
          0x1FFF, (insdel_row - Row)*ymul/ydiv);
d1047 5
a1051 3
    { ftracef0 ("insdeltool_redraw: column\n");
      bbc_rectanglefill (x0 + Column*xmul/xdiv, MAX (y0, 0),
          (insdel_col - Column)*xmul/xdiv, 0x1FFF);
d1087 1
a1087 1
  insdel_row = Row + 1; insdel_col = Column + 1;
a2421 1
      if (hit_sprite != NULL)
d2423 25
a2447 2
        { case m_Sprite_Delete:
          { sprite_area *sarea = hit_sprite->file->spritearea;
d2449 1
a2449 1
            main_file *spritefile = hit_sprite->file;
d2451 2
a2452 8
            sprite_id sid;
            char name [NAME_LIMIT + 1];

            sid.tag = sprite_id_name; /*doesn't flex*/
            sid.s.name = COPY_N (name, psprite_address (hit_sprite)->name,
                NAME_LIMIT);

            ftracef0 ("Edit delete\n");
d2454 9
a2462 3
            /*The next two lines used to be reversed, but it could give a
                fatal error. So do it this way*/
            wimpt_complain (sprite_delete (sarea, &sid));
d2464 1
a2464 1
            menus_ensure_size(&spritefile->spritearea,0);
d2466 4
a2469 4
            psprite_delete (hit_sprite);
            ftracef0("do menus_file_has_changed\n");
            menus_file_has_changed (window);
            ftracef0("do menus_ensure_size(,0)\n");
d2471 5
a2475 2
            menus_ensure_size (&hit_sprite->file->spritearea, 0);
#endif
d2477 1
a2477 1
        break;
a2531 1

d2554 1
a2554 1
                wimpt_noerr (wimp_get_wind_info (&winfo));
d2575 1
a2575 1
            menus_save_sprite (hit_sprite);
d2612 1
a2612 1
          wimpt_noerr (wimp_get_wind_info (&curr));
d2752 4
a2755 1
{ main_file *file = &((main_window *) handle)->data->file;
d2758 2
d2763 2
a2764 4
  { wimp_mousestr mouse;

    wimpt_noerr (wimp_get_point_info (&mouse));
    hit_sprite = main_pick_sprite ((main_window *) handle, &mouse);
d2776 3
a2778 11
  strcpy (Spritename, msgs_lookup ("PntG1"));
  len = strlen (Spritename);
  term [0] = Spritename [len - 1], term [1] = '\0';
  Spritename [len - 1] = '\0';
  if (hit_sprite != NULL)
  { char *nameptr = psprite_address (hit_sprite)->name;
    int i;

    for (i = 0; i < 12 && nameptr [i] > ' '; i++)
      spritenamebuffer [i] = nameptr [i];
    spritenamebuffer [i] = '\0';
d2781 20
a2800 1
    strcpy (spritenamebuffer, "");
a2801 2
  strcat (Spritename, spritenamebuffer);
  strcat (Spritename, term);
d2804 1
a2804 1
  menu_setflags (spritefile_main_menu, m_Sprite, 0, hit_sprite == NULL);
d2815 9
d2849 1
a2849 1
    tools_mouse_to_pixelpos (window, &mouse, &Column, &Row);
d2939 1
a2939 1
{ menu temp1, temp2, temp3, temp4, temp5;
d2945 1
a2945 1
  temp1 = make_menu2 ("PntM4", "PntM5");
d2948 1
a2948 1
  menu_submenu (temp1, m_Sprite_Copy, temp2);
d2951 2
a2952 2
  menu_submenu (temp1, m_Sprite_Rename, temp2);
  menu_submenu (spritefile_main_menu, m_Sprite, temp1);
@


4.3
log
@Deleted some junk from CVS.
On creating a new sprite (which is white) an attempt is made to select the
furthest colour from white in the palette.
Corrected icon shading in create dialogue,redid create template.
On closing a file the sprites are freed in reverse order in an attempt to
make it faster (as the blocks are flex'd in the other order) - will speed
up some situations.
When there are 0 sprites in a file the "Save" entry is greyed,this was
causing a internal error nasty looking error box before.
Tweak to allow the debug to be compiled again.
Filesize info box now used OS_ConvertFileSize as the display field
overflowed for files > 1M ish.
File info box made longer than 50 characters,that was a bit stingy.
Local flood fill with transparent mask added.
Reworded some of the messages.
Added "sort by name" to misc menu - sorts the sprites by name oddly enough.
The delete rows/columns now rounds up the grid coordinates,before there
were cases where you could never quite select the edge column/row,for
example a 79*98 sprites zoomed to x8 versus x7.

Version 1.96. Tagged as 'Paint-1_96'
@
text
@d2329 1
a2329 1
              sprite = nextsprite;
d2332 2
a2333 1
              sprite_select_rp(sarea, &sid, &sid.s.addr); /* Will succeed as they were there 15 lines ago */
@


4.2
log
@Version number now extracted from the VersionNum file and inserted into
messages at build time.
Saving palette files now preserve the attributes if a file of the same name
already existed in the target directory.
New tool sprites (and corresponding changed Templates)
Now strips dependencies when cleaned.

Version 1.95. Tagged as 'Paint-1_95'
@
text
@d969 1
a969 1
  { int x, y;
d973 6
a978 2
    x /= ms->scale_xmul;
    y /= ms->scale_ymul;
d1672 1
a1672 1
              number = 0x80000000;
a2225 1

d2242 1
d2250 3
a2252 3
              dbox_setnumeric (d, d_File_Size, sarea->size);
              dbox_setfield (d, d_File_Mod,
                  yesno (window->data->file.modified));
d2257 121
d2743 4
@


4.1
log
@Initial revision
@
text
@d609 1
a609 1
  int len;
d619 7
a626 1
  r.r [1] = (int) filename;
d633 7
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.11;
access;
symbols
	Paint-2_23-1:4.11
	Paint-2_23:4.11
	Paint-2_22:4.10
	Paint-2_21:4.10
	Paint-2_20:4.9
	Paint-2_19:4.9
	Paint-2_18:4.9
	Paint-2_17:4.9
	Paint-2_16:4.9
	Paint-2_15:4.8
	Paint-2_14:4.8
	Paint-2_13:4.8
	Paint-2_12:4.8
	Paint-2_11:4.7
	Paint-2_10:4.7
	Paint-2_09:4.7
	Paint-2_08:4.7
	Paint-2_07:4.7
	Paint-2_06:4.7
	Paint-2_05:4.7
	Paint-2_04:4.7
	Paint-2_03:4.6
	Paint-2_02:4.6
	Paint-2_01:4.5
	Paint-2_00:4.4
	Paint-1_99:4.4
	Paint-1_98:4.3
	Paint-1_97:4.2
	RO_5_07:4.2
	Paint-1_96:4.2
	Paint-1_95:4.1.1.1
	Paint-1_94:4.1.1.1
	Ursula_merge:4.1.1.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.1.1
	Ursula_RiscPC:4.1.1.1.0.6
	rthornb_UrsulaBuild-19Aug1998:4.1.1.1
	UrsulaBuild_FinalSoftload:4.1.1.1
	rthornb_UrsulaBuild-12Aug1998:4.1.1.1
	aglover_UrsulaBuild-05Aug1998:4.1.1.1
	rthornb_UrsulaBuild-29Jul1998:4.1.1.1
	rthornb_UrsulaBuild-22Jul1998:4.1.1.1
	rthornb_UrsulaBuild-15Jul1998:4.1.1.1
	rthornb_UrsulaBuild-07Jul1998:4.1.1.1
	rthornb_UrsulaBuild-17Jun1998:4.1.1.1
	rthornb_UrsulaBuild-10Jun1998:4.1.1.1
	rthornb_UrsulaBuild-03Jun1998:4.1.1.1
	rthornb_UrsulaBuild-27May1998:4.1.1.1
	rthornb_UrsulaBuild-21May1998:4.1.1.1
	rthornb_UrsulaBuild_01May1998:4.1.1.1
	Daytona:4.1.1.1.0.4
	Daytona_bp:4.1.1.1
	Ursula:4.1.1.1.0.2
	Ursula_bp:4.1.1.1
	RO_3_71:4.1.3.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	2017.11.11.12.32.36;	author rool;	state Exp;
branches;
next	4.10;
commitid	7xcfho84RnWggCeA;

4.10
date	2017.05.20.09.03.20;	author rool;	state Exp;
branches;
next	4.9;
commitid	GzVnMq2x9MpfJ6Sz;

4.9
date	2014.03.27.23.18.34;	author jlee;	state Exp;
branches;
next	4.8;
commitid	zsqBYJ6Lrncsqoux;

4.8
date	2012.08.22.07.18.10;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	jkPgRNvjP7QROvhw;

4.7
date	2010.12.06.22.30.45;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2010.11.29.20.55.25;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2009.05.29.02.09.31;	author pnaulls;	state Exp;
branches;
next	4.4;

4.4
date	2008.06.05.13.06.07;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2008.06.05.12.56.40;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2003.02.21.11.58.24;	author rsprowson;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.20.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1;
next	;

4.1.1.1
date	96.11.05.09.20.10;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.28.24;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Add mousewheel zoom/scroll and auto scrolling of selected tools
Detail:
  The mouse wheel can now be used to
  * scroll up/down
  * +shift to scroll left/right
  * +control to zoom in/out
  on an open sprite editing window.
  The sprite editing window will auto scroll when the mouse approaches the border with
  * the move whole sprite "hand" tool
  * the copy block "camera" tool
  * the move block "scissors" tool
Admin:
  Submission for the Paint bounty.

Version 2.23. Tagged as 'Paint-2_23'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* > c.Tools
 *
 *  Paint: Arthur 2 sprite editor
 *   Tools to paint all over sprites
 *
 *  Author: A.P. Thompson
 *
 *  Upgraded to RISCOSlib - DAHE - 16 Aug 1989
 *  DAHE, 28 Aug  89 - internationalisation
 *  DAHE,  4 Sept 89 - flood fill amended to handle transparent better
 *  JAB,   18 Oct 90 - Fixed bug in floodfill routine
 */

#include <limits.h>
#include <math.h>
#include <signal.h>
#include <swis.h>
#include "Global/OsBytes.h"

#include "bbc.h"
#include "flex.h"
#include "visdelay.h"
#include "werr.h"
#include "wimpt.h"

#include "ftrace.h"
#include "main.h"
#include "PSprite.h"
#include "SprWindow.h"
#include "ToolWindow.h"
#include "Tools.h"
#include "Colours.h"
#include "Menus.h"
#include "guard.h"
#include "PaintLib.h"

#define MUNGE_PIXEL(x, y, c, gcol, sa, sp, sb) \
  { if (toolwindow_current_mode != 0 || gcol.ecf) \
      domungepixel (x, y, c, gcol, sa, sp, sb); \
  }

static void Set_Marked_Extent (main_sprite *);

/*************************
 *  Static variables     *
 *************************/

char        tools_text_buffer [256] = "";
static char curr_text_buffer [256];
char        tools_text_xsize [5] = "8";
char        tools_text_ysize [5] = "8";
char        tools_text_xspace [5] = "8";
static int  textxsize;
static int  textysize;
static int  textxspace;

char        tools_spray_density [5] = "100";
char        tools_spray_radius [5]  = "30";
static int  spraydensity;
static int  sprayradius;
static int  spraytime = 0;

/* SMC: The following are not sprite names. They are tokens which must be
 * used to look up the real sprite name in the Messages file.
 */
char        tools_brushsprite [13]  = "circle";
char        tools_newbrushsprite [13]  = "circle";
char        tools_brush_nxscalem [3] = "1";
char        tools_brush_nxscaled [3] = "1";
char        tools_brush_nyscalem [3] = "1";
char        tools_brush_nyscaled [3] = "1";
char        tools_brush_cxscalem [3] = "1";
char        tools_brush_cxscaled [3] = "1";
char        tools_brush_cyscalem [3] = "1";
char        tools_brush_cyscaled [3] = "1";
main_scaling_block tools_brushscale = { 1, 1, 1, 1 };

wimp_i             tools_icons [tools_bicon_Max];
main_sprite *tools_brushsprite_ptr = NULL;

BOOL tools_flood_local      = TRUE;
BOOL tools_brush_use_gcol   = TRUE;
BOOL tools_exporting_sprite = FALSE;

static wimp_box Marked_Extent;

/*************************
 * Data tables           *
 *************************/

static char circledata [] = {bbc_CircleFill + bbc_DrawAbsFore, 0};
static char linedata [] = {bbc_SolidBoth + bbc_DrawAbsFore, 0};
static char circleoutlinedata [] = {bbc_Circle + bbc_DrawAbsFore, 0};
static char triangledata [] = {bbc_SolidBoth + bbc_DrawAbsFore,
             bbc_TriangleFill + bbc_DrawAbsFore, 0 };
static char ellipsedata [] = {bbc_SolidBoth + bbc_DrawAbsFore,
             bbc_EllipseFill + bbc_DrawAbsFore, 0 };
static char ellipseoutlinedata [] = {bbc_SolidBoth + bbc_DrawAbsFore,
             bbc_Ellipse + bbc_DrawAbsFore, 0 };
static char segmentdata [] = {bbc_SolidBoth + bbc_DrawAbsFore,
             bbc_Segment + bbc_DrawAbsFore, 0 };
static char sectordata [] = {bbc_SolidBoth + bbc_DrawAbsFore,
             bbc_Sector + bbc_DrawAbsFore, 0 };
static char arcdata [] = {bbc_SolidBoth + bbc_DrawAbsFore,
             bbc_CircleArc + bbc_DrawAbsFore, 0 };
static char parallelogramdata [] = {bbc_SolidBoth + bbc_DrawAbsFore,
             bbc_ParallelFill + bbc_DrawAbsFore, 0 };
static char rectangledata [] = {bbc_RectangleFill + bbc_DrawAbsFore, 0 };


static int  tools_extent_to_pixel_x(const main_sprite_window *window, int x)
{
  x *= window->blobsize.scale_xdiv;
  x /= window->blobsize.scale_xmul;
  x /= window->sprite->mode.scale_xmul;
  return x;
}

static int  tools_pixel_to_extent_x(const main_sprite_window *window, int x)
{
  x *= window->sprite->mode.scale_xmul;
  x *= window->blobsize.scale_xmul;
  x /= window->blobsize.scale_xdiv;
  return x;
}

static int  tools_pixel_to_extent_centre_x(const main_sprite_window *window, int x)
{
  x *= window->sprite->mode.scale_xmul;
  x *= window->blobsize.scale_xmul;
  x += (window->sprite->mode.scale_xmul*window->blobsize.scale_xmul)/2;
  x /= window->blobsize.scale_xdiv;
  return x;
}

static int  tools_extent_to_pixel_y(const main_sprite_window *window, int y)
{
  y *= window->blobsize.scale_ydiv;
  y /= window->blobsize.scale_ymul;
  y /= window->sprite->mode.scale_ymul;
  return y;
}


static int  tools_pixel_to_extent_y(const main_sprite_window *window, int y)
{
  y *= window->blobsize.scale_ymul;
  y *= window->sprite->mode.scale_ymul;
  y /= window->blobsize.scale_ydiv;
  return y;
}

static int  tools_pixel_to_extent_centre_y(const main_sprite_window *window, int y)
{
  y *= window->sprite->mode.scale_ymul;
  y *= window->blobsize.scale_ymul;
  y += (window->sprite->mode.scale_ymul*window->blobsize.scale_ymul)/2;
  y /= window->blobsize.scale_ydiv;
  return y;
}

static int tools_pixel_to_point_x(const main_sprite_window *window, int x)
{ 
  x *= window->sprite->mode.scale_xmul;
  return x;
}

static int tools_pixel_to_point_y(const main_sprite_window *window, int y)
{
  y *= window->sprite->mode.scale_ymul;
  return y;
}

static void tools_get_sprite_info_pixels(main_sprite *sprite, sprite_info *sin)
{
  sprite_id sid;
  sid.tag    = sprite_id_addr;
  sid.s.addr = psprite_address(sprite);
  wimpt_noerr (sprite_readsize (sprite->file->spritearea, &sid, sin));
}

/********************************************************
 * Convert mouse pos to the row or column that it is in *
 *   (0 <= x < width, 0 <= y < height)                  *
 ********************************************************/

void tools_mouse_to_pixel(main_window *window, wimp_mousestr *mpos,
                            int *cx, int *cy)
{
  /* Original code clamps coordinates overflowing the sprite bounds, so pass
  NULL for new overflowx and overflowy args */
  tools_mouse_to_pixel_overflow(window, mpos, cx, cy, NULL, NULL);
}

/********************************************************
 * Convert mouse pos to the row or column that it is in *
 *   (0 <= x < width, 0 <= y < height)                  *
 * If outside or near sprite bounds, an offset is       *
 * returned using overflowx and overflowy.              *
 ********************************************************/

void tools_mouse_to_pixel_overflow(main_window *window, wimp_mousestr *mpos,
                            int *cx, int *cy, int *overflowx, int *overflowy)
{
  sprite_info sin;
  main_sprite *sprite = window->data->sprite.sprite;
  wimp_winfo curr;
  ftracef0 ("tools_mouse_to_pixel\n");

  /* Default values for optional overflow parameters */
  if (overflowx)
    *overflowx = 0;
  if (overflowy)
    *overflowy = 0;

  curr.w = window->handle;
  wimpt_noerr (paintlib_get_wind_info (&curr));
  
  tools_get_sprite_info_pixels(sprite,&sin);
  
  /* See if we have dragged close to the edge of the window */
  if (overflowx)
  {
    if (mpos->x >= curr.info.box.x1 - 10)
      *overflowx = 1;
    else if (mpos->x - curr.info.box.x0 < 10)
      *overflowx = -1;
  }
  if (overflowy)
  {
    if (mpos->y >= curr.info.box.y1 - 10)
      *overflowy = 1;
    else if (mpos->y - curr.info.box.y0 < 10)
      *overflowy = -1;
  }
  
  if (cx)
  {
    int x=tools_extent_to_pixel_x(&window->data->sprite, mpos->x - curr.info.box.x0 + curr.info.scx);
    if (x>=sin.width) x=sin.width-1;
    if (x<0) x=0;
    *cx=x;
  }

  if (cy)
  {
    int y=tools_extent_to_pixel_y(&window->data->sprite,-curr.info.ex.y0 + curr.info.scy + mpos->y - curr.info.box.y1);
                                                                    /* offset from bottom left of sprite window */
    if (y>=sin.height) y=sin.height-1;
    if (y<0) y=0;
    *cy=y;
  }
}

/************************************
 does a wimp_update_wind and returns 
 bottom left of sprite in the window,
 and output from wimp_wind_update.
*************************************/

static void sprite_update_window(main_sprite_window *swind, int *x0, int *y0, wimp_redrawstr *rds, int *more)
{
  wimp_winfo curr;

  curr.w = swind->window->handle;
  wimpt_noerr (paintlib_get_wind_info (&curr));

  rds->w = swind->window->handle;
  rds->box = main_big_extent;
  wimpt_noerr (wimp_update_wind (rds, more));

  if (x0) *x0 = rds->box.x0 - rds->scx;
  if (y0) *y0 = rds->box.y1 - rds->scy + curr.info.ex.y0;
}

/********************************
 * EORed table-driven plotter   *
 ********************************/

static void tabledriven_drawEOR(main_sprite_window *swind, int *toolspace, int x0, int y0)
{
  int i, *coords = &toolspace [2];

  os_swi2 (OS_SetColour, 3, -1);
#if 0
  /*replaces the following, avoiding need to check full-palette bit*/
  bbc_gcol (3, 127);
  bbc_tint (2, 3); /*10 Sept 1991*/
#endif

  for (i = toolspace [0] & 0xFF; i; i--)
  {
     bbc_move (x0 + tools_pixel_to_extent_centre_x(swind, coords [0]),
               y0 + tools_pixel_to_extent_centre_y(swind, coords [1]));
    coords += 2;
  }

  bbc_plot (((char *) toolspace [1]) [(toolspace [0] & 0xFF) - 1],
              x0 + tools_pixel_to_extent_centre_x(swind, coords [0]),
              y0 + tools_pixel_to_extent_centre_y(swind, coords [1]));

}


static void tabledrivenEOR (main_sprite *sprite)

{ main_sprite_window *swind;

  ftracef0 ("tabledrivenEOR\n");
  for (swind = sprite->windows; swind != NULL; swind = swind->link)
  { int more, x0, y0;
    wimp_redrawstr rds;

    sprite_update_window(swind,&x0,&y0,&rds,&more);
    while (more)
    {  
      tabledriven_drawEOR(swind, sprite->toolspace, x0, y0);
      wimpt_noerr (wimp_get_rectangle (&rds, &more));
    }
  }
}

/***********************************************************
 * Null events: if pointer is over a window on the sprite, *
 *    then eor new shape.                                  *
 ***********************************************************/

static void tabledriven_null (main_window *window, wimp_mousestr *mpos)

{ main_sprite *sprite = window->data->sprite.sprite;
  int point, coord, x, y;

  ftracef0 ("tabledriven_null\n");
  if ((mpos->bbits & wimp_BRIGHT) == 0)     /* has adjust been released? */
    sprite->toolspace [0] = sprite->toolspace [0] & 0xFF;
                                  /*  then clear to just state */
  ftracef2 ("0x%X->toolspace [0]: 0x%X\n", sprite, sprite->toolspace [0]);

  if (sprite->toolspace [0] < 0)
    point = (sprite->toolspace [0] & 0x00FF0000) >> 16;
  else
    point = sprite->toolspace [0] & 0xFF;

  coord = point*2 + 2;
  tools_mouse_to_pixel (window, mpos, &x, &y);

  if (x != sprite->toolspace [coord] || y != sprite->toolspace [coord + 1])
  { tabledrivenEOR (sprite);       /* unplot it */

    sprite->toolspace [coord] = x;
    sprite->toolspace [coord  + 1] = y;

    tabledrivenEOR (sprite);       /* replot it at new size */
  }
}

/***************************************************************************
 * Redraw tool: most of EORing routine, rehashed to just do current window *
 **************************************************************************/

static void tabledriven_redraw (main_window *window, int x0, int y0)

{ main_sprite *sprite = window->data->sprite.sprite;

  ftracef0 ("tabledriven_redraw\n");
  if (sprite->needsnull)
      tabledriven_drawEOR(&window->data->sprite, sprite->toolspace, x0, y0);
}

/**************
 * Stop tool  *
 **************/

static void tabledriven_stop (main_sprite *sprite)

{ ftracef0 ("tabledriven_stop\n");
  if (sprite->needsnull)
  { tabledrivenEOR (sprite);   /* unplot outline */
    sprite->toolspace [0] = 0; /* and restart state */
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n", sprite, sprite->toolspace [0]);
    sprwindow_release_idle_events (sprite);
  }
}

static void tabledriven_click (main_window *window,
    wimp_mousestr *mpos, char *table)

{ ftracef1 ("tabledriven_click: bits 0x%X\n", mpos->bbits);
  if (mpos->bbits & (wimp_BRIGHT | wimp_BLEFT)) /* ignore drags */
  { main_sprite *sprite = window->data->sprite.sprite;
    int x, y, state;

    tools_mouse_to_pixel (window, mpos, &x, &y);

    state = sprite->toolspace [0] &= 0xFF;
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n", sprite, sprite->toolspace [0]);

    if (mpos->bbits & wimp_BRIGHT)
    { /* adjust: select a point and move it */
      int point = 0, bdist = INT_MAX, i;

      for (i = 1; i <= (state & 0xFF); i++)
      { /* Adjust pressed: adjust point closest to mouse */
        int dx = sprite->toolspace [i*2]     - x;
        int dy = sprite->toolspace [i*2 + 1] - y;

        if (dx*dx + dy*dy < bdist) bdist = dx*dx + dy*dy, point = i - 1;
      }

      sprite->toolspace [0] = state & ~0xFF00 | point << 16 | 0x80000000;
      ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
          sprite, sprite->toolspace [0]);
      ftracef1 ("selected adjust point %d\n", point);
    }
    else if (state == 0 || table [state] != 0)
    { /*another state to pass through*/
      if (state == 0)
      { sprwindow_claim_idle_events (window);
        sprite->toolspace [4] = sprite->toolspace [2] = x;
        sprite->toolspace [5] = sprite->toolspace [3] = y;
        sprite->toolspace [1] = (int) table;
      }
      else
      { tabledrivenEOR (sprite);           /* unplot old */
        ftracef3 ("Add coordinates %d, %d at %d\n", x, y, state*2 + 2);
        sprite->toolspace [state*2 + 2] = x;
        sprite->toolspace [state*2 + 3] = y;

        if (state*2 + 5 < toolspacesize)
        { sprite->toolspace [state*2 + 4] = x;
          sprite->toolspace [state*2 + 5] = y;
        }
      }

      sprite->toolspace [0]++;
      ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
          sprite, sprite->toolspace [0]);
      tabledrivenEOR (sprite);
    }
    else
    { main_colour gcol = sprite->gcol;
      int *c = &sprite->toolspace [2];
      main_sprite_window *swind=&window->data->sprite;

      sprwindow_release_idle_events (sprite);
      tabledrivenEOR (sprite);         /* unplot old */

      BOOL write_image = gcol.alpha || (psprite_transparency_type(sprite) == transparency_type_alphachannel);
      if (write_image)
      { int *coords = c;
        int scopy;

        sprwindow_swap_output_to_sprite (sprite);
        colours_set_sprite_gcol (gcol, sprite, 0);

        for (scopy = state; scopy; scopy--)
        {
           bbc_move (tools_pixel_to_point_x(swind, coords [0]),
                     tools_pixel_to_point_y(swind, coords [1]));
          coords += 2;
        }
        bbc_plot (table [sprite->toolspace [0] - 1],
                   tools_pixel_to_point_x(swind, x),
                   tools_pixel_to_point_y(swind, y));
      }

      if (sprwindow_swap_output_to_mask (sprite, write_image))
      { int *coords = c;

        colours_set_gcol (gcol.alpha, 0, 0);

        for (; state; state--)
        { bbc_move (tools_pixel_to_point_x(swind, coords [0]),
                    tools_pixel_to_point_y(swind, coords [1]));
          coords += 2;
        }
        bbc_plot (table [sprite->toolspace [0] - 1],
                   tools_pixel_to_point_x(swind, x),
                   tools_pixel_to_point_y(swind, y));
      }

      sprite->toolspace [0] = 0;
      ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
          sprite, sprite->toolspace [0]);

      Set_Marked_Extent (sprite);
      sprwindow_swap_output_to_screen ();

      psprite_recalculate_offsets (sprite->file);
      sprwindow_redisplay (sprite, &Marked_Extent);
    }

    ftracef1 ("state after click is 0x%X\n", sprite->toolspace [0]);
  }
}

/************************************************************
 *  Data driven tools                                       *
 ************************************************************/

static void circlepaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("circlepaint_click\n");
  tabledriven_click (window, mpos, circledata);
}

static void linepaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("linepaint_click\n");
  tabledriven_click (window, mpos, linedata);
}

static void circleoutlinepaint_click (main_window *window,
                                     wimp_mousestr *mpos)

{ ftracef0 ("circleoutlinepaint_click\n");
  tabledriven_click (window, mpos, circleoutlinedata);
}

static void trianglepaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("trianglepaint_click\n");
  tabledriven_click (window, mpos, triangledata);
}

static void ellipsepaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("ellipsepaint_click\n");
  tabledriven_click (window, mpos, ellipsedata);
}

static void ellipseoutlinepaint_click (main_window *window,
                                      wimp_mousestr *mpos)

{ ftracef0 ("ellipseoutlinepaint_click\n");
  tabledriven_click (window, mpos, ellipseoutlinedata);
}

static void segmentpaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("segmentpaint_click\n");
  tabledriven_click (window, mpos, segmentdata);
}

static void sectorpaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("sectorpaint_click\n");
  tabledriven_click (window, mpos, sectordata);
}

static void arcpaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("arcpaint_click\n");
  tabledriven_click (window, mpos, arcdata);
}

static void parallelogrampaint_click (main_window *window,
                                     wimp_mousestr *mpos)

{ ftracef0 ("parallelogrampaint_click\n");
  tabledriven_click (window, mpos, parallelogramdata);
}

static void rectanglepaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("rectanglepaint_click\n");
  tabledriven_click (window, mpos, rectangledata);
}

/********************************
 * Pixelpaint tool: plot points *
 ********************************/

static void domungepixel (int x, int y, sprite_colour *c, main_colour *mc,
    sprite_area *sarea, sprite_id *sid, main_sprite *sb)

{ ftracef0 ("domungepixel\n");

  if (mc->ecf)
  { sprite_id cyd;
    sprite_area *sa = sb->ECFs [mc->colour].sarea;
    int h = y - 1 & 7;  /* row number of ECF */
      /*was (psprite_address (sb)->height - y) & 7. JRC 13th Feb 1995*/

    /*pick pixel out of appropriate ECF, noting that this will be aligned
      with the top of both sprites */
    /*but we want the bottoms aligned See psprte_setup_ecf(). JRC 13th Feb 1995*/
    cyd.tag = sprite_id_addr;
    cyd.s.addr = (char *) sa + sizeof (sprite_area);

    /*h = ((sprite_header *) cyd.s.addr)->height + h - 7;*/
      /*don't align to top of ECF sprite JRC 13th Feb 1995*/

    main_read_pixel (sa, &cyd, x & 7, h, c);
  }

  ftracef3 ("domungepixel: c->colour %d, c->tint %d; "
      "toolwindow_current_mode %d\n",
      c->colour, c->tint, toolwindow_current_mode);

  if (toolwindow_current_mode != 0)
  { sprite_colour there;

    main_read_pixel (sarea, sid, x, y, &there);

    switch (toolwindow_current_mode)
    { case 1: /* OR */
        c->colour |= there.colour;
        c->tint   |= there.tint;
      break;

      case 2: /* AND */
        c->colour &= there.colour;
        c->tint   &= there.tint;
      break;

      case 3: /* EOR */
        c->colour ^= there.colour;
        c->tint   ^= there.tint;
      break;
    }
  }

  ftracef2 ("domungepixel: c->colour %d, c->tint %d\n", c->colour, c->tint);
}

/***********************************************************
 *  Actual pixel zapper                                    *
 ***********************************************************/

static void pixelpaint_splot (main_window *window, wimp_mousestr *mpos)

{ main_sprite *sprite = window->data->sprite.sprite;
  int x, y;
  main_colour gcol = mpos->bbits == wimp_BRIGHT ? sprite->gcol2 : sprite->gcol;
        /* adjust clears to 0, select uses current gcol */

  ftracef2 ("pixelpaint_splot: sprite %.12s, gcol 0x%X\n",
      psprite_address (sprite)->name, gcol);

  tools_mouse_to_pixel(window, mpos,&x,&y); 

  if (x != sprite->toolspace [0] || y != sprite->toolspace [1])
  {
    wimp_box redraw_area;
    sprite_id sid;
    sprite_area *sarea = sprite->file->spritearea;

    sprite->toolspace [0] = x;
    sprite->toolspace [1] = y;
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n", sprite, sprite->toolspace [0]);

    sid.s.addr = psprite_address (sprite);
    sid.tag = sprite_id_addr;

    BOOL write_image = gcol.alpha || (psprite_transparency_type(sprite) == transparency_type_alphachannel);
    
    if (write_image)
    { sprite_colour colour;

      ftracef3 ("gcol 0x%X %d %d\n", gcol.colour, gcol.alpha, gcol.ecf);
      colour = colours_pack_colour(sprite,gcol);

      MUNGE_PIXEL (x, y, &colour, &gcol, sarea, &sid, sprite)
      ftracef2 ("sprite_writepixel (GCOL 0x%X, TINT 0x%X)\n",
          colour.colour, colour.tint);
      sprite_writepixel (sarea, &sid, x, y, &colour);
    }

    if (psprite_hasmask (sprite))
    { sprite_maskstate mask = colours_pack_mask(sprite,gcol);

      sprite_writemask (sarea, &sid, x, y, &mask);
    }

    
    redraw_area.x0=tools_pixel_to_point_x(&window->data->sprite, x);
    redraw_area.x1=tools_pixel_to_point_x(&window->data->sprite, x+1);
    redraw_area.y0=tools_pixel_to_point_y(&window->data->sprite, y);
    redraw_area.y1=tools_pixel_to_point_y(&window->data->sprite, y+1);

    sprwindow_redisplay (sprite, &redraw_area);
  }
}

/***********************************************************
 *  Start point plotting                                   *
 ***********************************************************/

static void pixelpaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("pixelpaint_click\n");
  if (mpos->bbits & (wimp_BRIGHT | wimp_BLEFT)) /* ignore drags */
  { main_sprite *sprite = window->data->sprite.sprite;

    sprwindow_claim_idle_events (window);    /* start tracking */
    main_set_modified (sprite->file);
    sprite->toolspace [0] = sprite->toolspace [1] = -1;
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
        sprite, sprite->toolspace [0]);

    pixelpaint_splot (window, mpos);
  }
}

/***********************************************************
 * Null events: if pointer is over a window on the sprite, *
 *    then plot a point                                    *
 ***********************************************************/

static void pixelpaint_null (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("pixelpaint_null\n");
  if (mpos->bbits == 0) /*if the mouse button is now up, stop tracking*/
    sprwindow_release_idle_events (window->data->sprite.sprite);
  else
    pixelpaint_splot (window, mpos);
}

/********************************
 * EORed parallelogram plotter  *
 ********************************/

static void parallelogram_drawEOR(main_sprite_window *swind, int *toolspace, int x0, int y0)
{
  os_swi2 (OS_SetColour, 3, -1);
  int drawline=0;
  int *point=&toolspace[2];
#if 0
  /*replaces the following, avoiding need to check full-palette bit*/
  bbc_gcol (3, 127);
  bbc_tint (2, 3); /*10 Sept 1991*/
#endif

  /* draw a line if parallelogram points all lie on a straight line
     so that it doesnt disappear */
  if ((toolspace [0] & 0xFF) == 2)
  {
    int dx1=point[2]-point[0];
    int dy1=point[3]-point[1];
    int dx2=point[4]-point[0];
    int dy2=point[5]-point[1];
    if (point[0]==point[4] && point[1]==point[5])
    {
      dx2=point[4]-point[2];
      dy2=point[5]-point[3];
    }

    if (dy1==0 && dy2==0)
      drawline=1;/* horizontal line */
    else if (dx1==0 && dx2==0)
      drawline=2;/* vertical line */
    else if (dy1 && dy2 && abs(dx1)>abs(dy1) && dx1*4096/dy1==dx2*4096/dy2)
      drawline=1;
    else if (dx1 && dx2 && abs(dy1)>=abs(dx1) && dy1*4096/dx1==dy2*4096/dx2)
      drawline=2;
  }

  if (drawline)
  {
     int i, xa, ya, xb, yb;

     /* find endpoints */
     if (drawline==1)
     {
        xa=point[4] + point[0] - point[2];
        ya=point[5] + point[1] - point[3];
        for (i=0;i<6;i+=2) {if (point[i]<xa) xa=point[i], ya=point[i+1];}
        xb=point[4] + point[0] - point[2];
        yb=point[5] + point[1] - point[3];
        for (i=0;i<6;i+=2) {if (point[i]>xb) xb=point[i], yb=point[i+1];}
     }
     else
     {
        xa=point[4] + point[0] - point[2];
        ya=point[5] + point[1] - point[3];
        for (i=0;i<6;i+=2) {if (point[i+1]<ya) xa=point[i], ya=point[i+1];}
        xb=point[4] + point[0] - point[2];
        yb=point[5] + point[1] - point[3];
        for (i=0;i<6;i+=2) {if (point[i+1]>yb) xb=point[i], yb=point[i+1];}
     }
     bbc_move (x0 + tools_pixel_to_extent_centre_x(swind, xa),
               y0 + tools_pixel_to_extent_centre_y(swind, ya));
     bbc_draw (x0 + tools_pixel_to_extent_centre_x(swind, xb),
               y0 + tools_pixel_to_extent_centre_y(swind, yb));


  }
  else
  {
    bbc_move (x0 + tools_pixel_to_extent_centre_x(swind, point[0]),
              y0 + tools_pixel_to_extent_centre_y(swind, point[1]));
    bbc_draw (x0 + tools_pixel_to_extent_centre_x(swind, point[2]),
              y0 + tools_pixel_to_extent_centre_y(swind, point[3]));

    if ((toolspace [0] & 0xFF) == 2)
    { bbc_draw (x0 + tools_pixel_to_extent_centre_x(swind, point[4]),
                y0 + tools_pixel_to_extent_centre_y(swind, point[5]));
      bbc_drawby (tools_pixel_to_extent_x(swind, point[0] - point[2]),
                  tools_pixel_to_extent_y(swind, point[1] - point[3]));
      bbc_draw (x0 + tools_pixel_to_extent_centre_x(swind, point[0]),
                y0 + tools_pixel_to_extent_centre_y(swind, point[1]));
    }
  }
}

static void parallelogramEOR (main_sprite *sprite)

{ main_sprite_window *swind;

  ftracef0 ("parallelogramEOR\n");
  for (swind = sprite->windows; swind != NULL; swind = swind->link)
  { int more, x0, y0;
    wimp_redrawstr rds;

    sprite_update_window(swind,&x0,&y0,&rds,&more);
    while (more)
    {
      parallelogram_drawEOR(swind, sprite->toolspace, x0, y0);
      wimpt_noerr (wimp_get_rectangle (&rds, &more));
    }
  }
}

/***********************************************************
 * Null events: if pointer is over a window on the sprite, *
 *    then eor new pgram.                                  *
 ***********************************************************/

static void parallelogramoutlinepaint_null (main_window *window,
                                           wimp_mousestr *mpos)

{ main_sprite *sprite = window->data->sprite.sprite;
  int point, coord, x, y;

  ftracef0 ("parallelogramoutlinepaint_null\n");
  if ((mpos->bbits & wimp_BRIGHT) == 0)     /* has adjust been released? */
  sprite->toolspace [0] = sprite->toolspace [0] & 0xFF;
                                 /*  then clear to just state */
  ftracef2 ("0x%X->toolspace [0]: 0x%X\n", sprite, sprite->toolspace [0]);


 if (sprite->toolspace [0] < 0)
      point = (sprite->toolspace [0] & 0x00FF0000) >> 16;
 else point = sprite->toolspace [0] & 0xFF;

 coord = point*2 + 2;

 tools_mouse_to_pixel(window, mpos, &x, &y);

 if (x != sprite->toolspace [coord] || y != sprite->toolspace [coord + 1])
 { parallelogramEOR (sprite);       /* unplot it */

  sprite->toolspace [coord] = x;
  sprite->toolspace [coord  + 1] = y;

  parallelogramEOR (sprite);       /* replot it at new size */
 }
}

/****************************************************************************
 * Redraw tool: most of EORing routine, rehashed to just do current window  *
 ****************************************************************************/

static void parallelogramoutlinepaint_redraw (main_window *window,
                                             int x0, int y0)

{ main_sprite *sprite = window->data->sprite.sprite;

  ftracef0 ("parallelogramoutlinepaint_redraw\n");
  if (sprite->needsnull)
    parallelogram_drawEOR(&window->data->sprite, window->data->sprite.sprite->toolspace, x0, y0);
}

/**************
 * Stop tool  *
 **************/

static void parallelogramoutlinepaint_stop (main_sprite *sprite)

{ ftracef0 ("parallelogramoutlinepaint_stop\n");
  if (sprite->needsnull)
  { parallelogramEOR (sprite);   /* unplot outline */
    sprite->toolspace [0] = 0; /* and restart state */
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n", sprite, sprite->toolspace [0]);
    sprwindow_release_idle_events (sprite);
  }
}

static void parallelogramoutlinepaint_click (main_window *window,
    wimp_mousestr *mpos)

{ ftracef0 ("parallelogramoutlinepaint_click\n");
  if (mpos->bbits & (wimp_BRIGHT | wimp_BLEFT)) /* ignore drags */
  { main_sprite *sprite = window->data->sprite.sprite;
    int x, y;
    tools_mouse_to_pixel (window, mpos, &x, &y);

    if (mpos->bbits & wimp_BRIGHT)   /* adjust: select a point and move it */
    { int point = 0, bdist = INT_MAX, i;

      for (i = 1; i <= (sprite->toolspace [0] & 0xFF); i++)
      { /*adjust pressed: adjust point closest to mouse*/
        int dx = sprite->toolspace [i*2] - x;
        int dy = sprite->toolspace [i*2 + 1] - y;

        if (dx*dx + dy*dy < bdist) bdist = dx*dx + dy*dy, point = i-1;
      }

      sprite->toolspace [0] = sprite->toolspace [0] & ~0x00FF00 |
          point << 16 | 0x80000000;
      ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
          sprite, sprite->toolspace [0]);
    }
    else
      switch (sprite->toolspace [0] & 0xFF /*low byte only. JRC 6 July 1991*/)
      { case 0:
          sprwindow_claim_idle_events (window);    /* start tracking */
          sprite->toolspace [4] = sprite->toolspace [2] = x;
          sprite->toolspace [5] = sprite->toolspace [3] = y;
          sprite->toolspace [0] = 1;
          ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
              sprite, sprite->toolspace [0]);
          parallelogramEOR (sprite);
        break;

        case 1:
          parallelogramEOR (sprite);           /* unplot old */
          sprite->toolspace [6] = sprite->toolspace [4] = x;
          sprite->toolspace [7] = sprite->toolspace [5] = y;
          sprite->toolspace [0] = 2;
          ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
              sprite, sprite->toolspace [0]);
          parallelogramEOR (sprite);
        break;

        case 2:
        { main_sprite_window *swind=&window->data->sprite;

          main_colour gcol = sprite->gcol;

          sprwindow_release_idle_events (sprite);
          parallelogramEOR (sprite);         /* unplot old */

          BOOL write_image = gcol.alpha || (psprite_transparency_type(sprite) == transparency_type_alphachannel);
          
          if (write_image)
          { sprwindow_swap_output_to_sprite (sprite);
            colours_set_sprite_gcol (gcol, sprite, 0);

            bbc_move (tools_pixel_to_point_x(swind, sprite->toolspace [2]),
                      tools_pixel_to_point_y(swind, sprite->toolspace [3]));
            bbc_draw (tools_pixel_to_point_x(swind, sprite->toolspace [4]),
                      tools_pixel_to_point_y(swind, sprite->toolspace [5]));
            bbc_draw (tools_pixel_to_point_x(swind, sprite->toolspace [6]), 
                      tools_pixel_to_point_y(swind, sprite->toolspace [7]));
            bbc_drawby (tools_pixel_to_point_x(swind, sprite->toolspace [2] - sprite->toolspace [4]),
                        tools_pixel_to_point_y(swind, sprite->toolspace [3] - sprite->toolspace [5]));
            bbc_draw (tools_pixel_to_point_x(swind, sprite->toolspace [2]),
                      tools_pixel_to_point_y(swind, sprite->toolspace [3]));
          }

          if (sprwindow_swap_output_to_mask (sprite, write_image))
          { colours_set_gcol (gcol.alpha, 0, 0);

            bbc_move (tools_pixel_to_point_x(swind, sprite->toolspace [2]),
                      tools_pixel_to_point_y(swind, sprite->toolspace [3]));
            bbc_draw (tools_pixel_to_point_x(swind, sprite->toolspace [4]),
                      tools_pixel_to_point_y(swind, sprite->toolspace [5]));
            bbc_draw (tools_pixel_to_point_x(swind, sprite->toolspace [6]),
                      tools_pixel_to_point_y(swind, sprite->toolspace [7]));
            bbc_drawby (tools_pixel_to_point_x(swind, sprite->toolspace [2] - sprite->toolspace [4]),
                        tools_pixel_to_point_y(swind, sprite->toolspace [3] - sprite->toolspace [5]));
            bbc_draw (tools_pixel_to_point_x(swind, sprite->toolspace [2]),
                      tools_pixel_to_point_y(swind, sprite->toolspace [3]));
          }

          sprite->toolspace [0] = 0;
          ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
              sprite, sprite->toolspace [0]);

          Set_Marked_Extent (sprite);
          sprwindow_swap_output_to_screen ();

          psprite_recalculate_offsets (sprite->file);
          sprwindow_redisplay (sprite, &Marked_Extent);
        }
        break;
      }
  }
}

/********************************
 * EORed rectangle plotter  *
 ********************************/

static void rectangle_drawEOR(main_sprite_window *swind, int *points, int x0, int y0)
{
  os_swi2 (OS_SetColour, 3, -1);
#if 0
  /*replaces the following, avoiding need to check full-palette bit*/
  bbc_gcol (3, 127);
  bbc_tint (2, 3); /*10 Sept 1991*/
#endif



  if (points[0] == points[2] || points[1] == points[3])
  {
    bbc_move (x0 + tools_pixel_to_extent_centre_x(swind, points [0]),
              y0 + tools_pixel_to_extent_centre_y(swind, points [1]));
    bbc_drawby (tools_pixel_to_extent_x(swind, points [2] - points [0]),
                tools_pixel_to_extent_y(swind, points [3] - points [1]));
  }
  else
    bbc_rectangle (x0 + tools_pixel_to_extent_centre_x(swind, points [0]),
                   y0 + tools_pixel_to_extent_centre_y(swind, points [1]),
                   tools_pixel_to_extent_x(swind, points [2] - points [0]),
                   tools_pixel_to_extent_y(swind, points [3] - points [1]));

}

static void rectangleEOR (main_sprite *sprite, int coord)

{ main_sprite_window *swind;

  ftracef1 ("rectangleEOR rect at toolspace [%d])\n", coord);
  for (swind = sprite->windows; swind != NULL; swind = swind->link)
  { int more, x0, y0;
    wimp_redrawstr rds;

    sprite_update_window(swind,&x0,&y0,&rds,&more);
    while (more)
    {
      rectangle_drawEOR(swind,&sprite->toolspace [coord], x0, y0);
      wimpt_noerr (wimp_get_rectangle (&rds, &more));
    }
  }
}

/***********************************************************
 * Null events: if pointer is over a window on the sprite, *
 *    then eor new pgram.                                  *
 ***********************************************************/

static void rectangleoutlinepaint_null (main_window *window,
                                       wimp_mousestr *mpos)

{ main_sprite *sprite = window->data->sprite.sprite;
  int coord, x, y;

  ftracef0 ("rectangleoutlinepaint_null\n");
  if ((mpos->bbits & 1) == 0)     /* has adjust been released? */
  sprite->toolspace [0] = sprite->toolspace [0] & 0xFF;
                                 /*  then clear to just state */
  ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
      sprite, sprite->toolspace [0]);

 if (sprite->toolspace [0] < 0)
      coord = 2;
 else coord = 4;

 tools_mouse_to_pixel (window, mpos, &x, &y);

 if (x != sprite->toolspace [coord] || y != sprite->toolspace [coord + 1])
 { rectangleEOR (sprite, 2);       /* unplot it */

  sprite->toolspace [coord] = x;
  sprite->toolspace [coord  + 1] = y;

  rectangleEOR (sprite, 2);       /* replot it at new size */
 }
}

/****************************************************************************
 * Redraw tool: most of EORing routine, rehashed to just do current window  *
 ****************************************************************************/

static void rectangleoutlinepaint_redraw (main_window *window,
    int x0, int y0)

{ main_sprite *sprite = window->data->sprite.sprite;
 
  ftracef0 ("rectangleoutlinepaint_redraw\n");
  if (sprite->needsnull)
    rectangle_drawEOR(&window->data->sprite,&sprite->toolspace [2], x0, y0);
}

/**************
 * Stop tool  *
 **************/

static void rectangleoutlinepaint_stop (main_sprite *sprite)

{ ftracef0 ("rectangleoutlinepaint_stop\n");
  if (sprite->needsnull)
  { rectangleEOR (sprite, 2);   /* unplot outline */
    sprite->toolspace [0] = 0; /* and restart state */
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
        sprite, sprite->toolspace [0]);
    sprwindow_release_idle_events (sprite);
  }
}

static void rectangleoutlinepaint_click (main_window *window,
    wimp_mousestr *mpos)

{ ftracef0 ("rectangleoutlinepaint_click\n");
  if (mpos->bbits & (wimp_BRIGHT | wimp_BLEFT)) /* ignore drags */
  { main_sprite *sprite = window->data->sprite.sprite;
    int x, y;
    tools_mouse_to_pixel (window, mpos, &x, &y);

    if (mpos->bbits & 1)   /* adjust: select a point and move it */
    { int point = 0, bdist = INT_MAX, i;

      for (i = 1; i <= (sprite->toolspace [0] & 0xFF); i++)
      { /* adjust pressed: adjust point closest to mouse */
        int dx = sprite->toolspace [i*2] - x;
        int dy = sprite->toolspace [i*2 + 1] - y;

        if (dx*dx + dy*dy < bdist)  bdist = dx*dx + dy*dy, point = i - 1;
      }

      sprite->toolspace [0] = sprite->toolspace [0] & ~0x00FF00 |
          point << 16 | 0x80000000;
      ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
          sprite, sprite->toolspace [0]);
    }
    else
      switch (sprite->toolspace [0] & 0xFF /*low byte only. JRC 6 July 1991*/)
      { case 0:
          sprwindow_claim_idle_events (window);    /* start tracking */
          sprite->toolspace [4] = sprite->toolspace [2] = x;
          sprite->toolspace [5] = sprite->toolspace [3] = y;

          sprite->toolspace [0] = 1;
          ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
              sprite, sprite->toolspace [0]);
          rectangleEOR (sprite, 2);
        break;

        case 1:
        { main_sprite_window *swind=&window->data->sprite;
          main_colour gcol = sprite->gcol;

          sprwindow_release_idle_events (sprite);
          rectangleEOR (sprite, 2);         /* unplot old */

          BOOL write_image = gcol.alpha || (psprite_transparency_type(sprite) == transparency_type_alphachannel);
          if (write_image)
          { sprwindow_swap_output_to_sprite (sprite);
            colours_set_sprite_gcol (gcol, sprite, 0);

            bbc_rectangle (tools_pixel_to_point_x(swind, sprite->toolspace [2]),
                           tools_pixel_to_point_y(swind, sprite->toolspace [3]),
                           tools_pixel_to_point_x(swind, sprite->toolspace [4] - sprite->toolspace [2]),
                           tools_pixel_to_point_y(swind, sprite->toolspace [5] - sprite->toolspace [3]));
          }

          if (sprwindow_swap_output_to_mask (sprite, write_image))
          { colours_set_gcol (gcol.alpha, 0, 0);

            bbc_rectangle (tools_pixel_to_point_x(swind, sprite->toolspace [2]),
                           tools_pixel_to_point_y(swind, sprite->toolspace [3]),
                           tools_pixel_to_point_x(swind, sprite->toolspace [4] - sprite->toolspace [2]),
                           tools_pixel_to_point_y(swind, sprite->toolspace [5] - sprite->toolspace [3]));
          }

          sprite->toolspace [0] = 0;
          ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
              sprite, sprite->toolspace [0]);

          Set_Marked_Extent (sprite);
          sprwindow_swap_output_to_screen ();

          psprite_recalculate_offsets (sprite->file);
          sprwindow_redisplay (sprite, &Marked_Extent);
        }
        break;
      }
  }
}

/********************
 * Flood fill tool  *
 ********************/

static volatile sig_atomic_t Escape_Pressed;

static void Escape_Handler (int type)

{ ftracef0 ("Escape_Handler\n");
  type = type; /*for Norcroft*/

  signal (SIGINT, &Escape_Handler);
  Escape_Pressed = TRUE;
}

/* Version with improved transparent handling */
static void floodfillpaint_click (main_window *window,
    wimp_mousestr *mpos)

{ ftracef0 ("floodfillpaint_click\n");
  if (mpos->bbits & (wimp_BRIGHT | wimp_BLEFT)) /* ignore drags */
  { main_sprite *sprite = window->data->sprite.sprite;
    int x, y, nc = colours_count (sprite);
    main_colour gcol = mpos->bbits & 4? sprite->gcol: sprite->gcol2;
    BOOL to_transparent = !gcol.alpha && psprite_hasmask(sprite), from_transparent;
    sprite_area *sarea = sprite->file->spritearea;
    sprite_id sid;
    sprite_colour col;
    sprite_maskstate mask;

    ftracef4 ("floodfillpaint_click: w 0x%X, mpos {(%d, %d), bbits 0x%X}\n",
        window, mpos->x, mpos->y, mpos->bbits);

    ftracef2 ("Flood Filling at (%d, %d)\n", mpos->x, mpos->y);

    sid.tag    = sprite_id_addr;
    sid.s.addr = psprite_address (sprite);

    /* Find pixel location in sprite */
    tools_mouse_to_pixel (window, mpos, &x,&y);

    /* Read colour and mask from it */
    ftracef0 ("Reading colour and mask from sprite\n");
    if (main_read_pixel (sarea, &sid, x, y, &col) != NULL ||
        sprite_readmask (sarea, &sid, x, y, &mask) != NULL)
      return; /*Fix MED-04614. Do not report any error - it's probably
          'Invalid row or column. J R C 31st Jan 1995*/
    ftracef2 ("(gcol, tint) read from sprite (%d, %d)\n",
        col.colour, col.tint);

    from_transparent = mask == sprite_masktransparent;

    /* Do nothing if changing from transparent to transparent */
    if (to_transparent && from_transparent)
      return;

    sprwindow_swap_output_to_sprite (sprite);
    colours_set_sprite_gcol (gcol, sprite, 0);

    if (!tools_flood_local)
    { /* IF flood global */

      int x, y, r1, r2;
      int sx = tools_pixel_to_point_x(&window->data->sprite, 1);
      int sy = tools_pixel_to_point_y(&window->data->sprite, 1);
      sprite_info sin;
      sprite_maskstate sms =
          from_transparent? sprite_masksolid: sprite_masktransparent;
      void (*old_escape_handler) (int);
      ftracef0 ("Global colour change\n");

      wimpt_noerr (sprite_readsize (sarea, &sid, &sin));
      visdelay_begin ();
      /*Install a new escape handler*/
      Escape_Pressed = FALSE;
      old_escape_handler = signal (SIGINT, &Escape_Handler);
      ftracef0 ("Enable Escape events\n");
      wimpt_noerr (os_byte (OsByte_RW_EscapeKeyEffects, (r1 = 0, &r1), (r2 = 0, &r2)));

      ftracef4 ("FloodFill: width %d, height %d, mask %d, mode %d\n",
          sin.width, sin.height, sin.mask, sin.mode);
      for (y = 0; y < sin.height; y++)
      { 
        visdelay_percent (y*100/sin.height);

        /*Check escape*/
        if (Escape_Pressed)
        { /*Report error*/
          werr (FALSE, msgs_lookup ("PntHH"));
          break;
        }

        for (x = 0; x < sin.width; x++)
        { if (from_transparent)
          { sprite_maskstate mask;

            wimpt_noerr (sprite_readmask (sarea, &sid, x, y, &mask));

            /* Don't change pixel if transparent */
            if (mask != sprite_masktransparent)
              continue;
            else /* Not transparent: clear mask on it */
              wimpt_noerr (sprite_writemask (sarea, &sid, x, y, &sms));
          }
          else /* Changing from a colour */
          { sprite_colour sc;

            wimpt_noerr (main_read_pixel (sarea, &sid, x, y, &sc));
            if (!(sc.colour == col.colour && sc.tint == col.tint))
              continue;
            else if (to_transparent) /*Changing to transparent: set mask*/
            { wimpt_noerr (sprite_writemask (sarea, &sid, x, y, &sms));
              continue;
            }
          }
          /* If we get here, the pixel is to be changed to a colour */
          bbc_plot (bbc_Point | bbc_DrawAbsFore, x*sx, y*sy);
        }
      }
      ftracef0 ("disable Escape events\n");
      wimpt_noerr (os_byte (OsByte_RW_EscapeKeyEffects, (r1 = 1, &r1), (r2 = 0, &r2)));
      /*Replace escape handler*/
      (void) signal (SIGINT, old_escape_handler);
      visdelay_end ();
    }
    else
    { /* Flood local */
      int x, y;

      tools_mouse_to_pixel (window, mpos, &x, &y);
      x=tools_pixel_to_point_x(&window->data->sprite, x);
      y=tools_pixel_to_point_y(&window->data->sprite, y);
      ftracef2 ("Point Coords: x %d, y %d\n", x, y);

      if (!to_transparent)
      { /* Set colours in local region */
        BOOL mode8bpp = nc == 256 && !psprite_hastruecolpal (sprite);
        sprite_colour scol = colours_pack_colour(sprite,gcol);

        if (!from_transparent)
        { /* IF not from_transparent */
          ftracef4 ("sgc %d, gcol %d, st %d, tint %d\n",
              scol.colour, col.colour, scol.tint, col.tint >> 6);

          /*Check that the proposed action does have an effect.*/
          if
          (!( ( toolwindow_current_mode == 0? /*Set*/ scol.colour:
                toolwindow_current_mode == 1? /*OR*/  scol.colour | col.colour:
                toolwindow_current_mode == 2? /*AND*/ scol.colour & col.colour:
                toolwindow_current_mode == 3? /*EOR*/ scol.colour ^ col.colour: 0
              ) == col.colour &&
              ( toolwindow_current_mode == 0? /*Set*/ scol.tint:
                toolwindow_current_mode == 1? /*OR*/  scol.tint | col.tint >> 6:
                toolwindow_current_mode == 2? /*AND*/ scol.tint & col.tint >> 6:
                toolwindow_current_mode == 3? /*EOR*/ scol.tint ^ col.tint >> 6: 0
              ) == col.tint >> 6
          ) )
          { /*Set the background colour to the pixel selected.*/
            if (nc != 256 || psprite_hastruecolpal (sprite))
            { ftracef1 ("deep sprite - setting bg to %d\n", col.colour);
              os_swi2 (OS_SetColour, 1 << 4, col.colour);
            }
            else
            { bbc_gcol (0, 128 | col.colour);
              bbc_tint (3, col.tint >> 6);
            }

            ftracef0 ("flooding to non-bg ...\n");
            bbc_plot (bbc_FloodToBack | bbc_DrawAbsFore, x, y);
            ftracef0 ("flooding to non-bg ... done\n");
          }
        }
        else
        { /* from_transparent */

          /*The plan is:
            (j) Plot the transparent parts of the mask onto the sprite in
               the colour - this is invisible so far.
            (ij) Local fill the mask with 1's in the area to be changed.
               This exposes the colour just written to the sprite.
          */
          sprwindow_swap_output_to_screen (),
          sprwindow_swap_output_to_mask (sprite, 0);

          os_swi2 (OS_SetColour, 4 | 1 << 4, 0);
          bbc_clg (); /*invert the mask*/

          sprwindow_swap_output_to_screen (),
          sprwindow_swap_output_to_sprite (sprite);
          if (mode8bpp)
            bbc_gcol (0, 128 | scol.colour), bbc_tint (3, scol.tint);
          else
            os_swi2 (OS_SetColour, 1 << 4, scol.colour);
          sprite_put_mask_given (sarea, &sid, 0, 0);

          sprwindow_swap_output_to_screen (),
          sprwindow_swap_output_to_mask (sprite, 0);

          os_swi2 (OS_SetColour, 4, 0);
          bbc_plot (bbc_FloodToFore | bbc_DrawAbsFore, x, y);

          os_swi2 (OS_SetColour, 4 | 1 << 4, 0);
          bbc_clg (); /*invert back again*/
        }
      }
      else
      { /* local to_transparent */

        /* Always trying to change to transparent so there are two cases:
           changing from transparent - no action required, flooding nothing with nothing leaves nothing
           changing to transparent - remember what the sprite currently looks like
           and local flood fill the foreground using the OS flood fill routine (no point
           reinventing the wheel).
           Diff the resulting sprites, and for each changed pixel poke the mask with a
           see through blob */
    
        char tempname [NAME_LIMIT + 1], realname [NAME_LIMIT + 1], *msg = NULL;
        sprite_info      sin;
        psprite_info     sinfo;
        sprite_id        sid, sid2;
        sprite_colour    was, now;
        sprite_maskstate sms = sprite_masktransparent;
        BOOL             hourglass = FALSE, created_sprite = FALSE, seenachange=FALSE, seenthisline=FALSE;
        os_error        *error;
        main_colour      temp;

        ftracef0 ("local fill sprite with transparent\n");
        strcpy (realname, psprite_address (sprite)->name);

        sid.tag    = sprite_id_name;
        sid.s.name = realname;

        wimpt_noerr (sprite_readsize (sarea, &sid, &sin)); /* Get dimensions */
        psprite_read_full_info(sprite, &sinfo);            /* Get number of bytes of RAM reqd */

        /*ensure room for copy*/
        if (!menus_ensure_size (&sprite->file->spritearea, sinfo.size))
        { msg = msgs_lookup ("PntEG");
          goto finish;
        }

        Temporary_Name (sprite->file->spritearea, tempname);
        if ((error = sprite_copy (sprite->file->spritearea, &sid, tempname))
            != NULL)
        { msg = error->errmess;
          goto finish;
        }

        created_sprite = TRUE;
        sid2.tag    = sprite_id_name;
        sid2.s.name = tempname;

        visdelay_begin ();
        hourglass = TRUE;

        /* Not really bothered what colour is locally filled with, so long as it's different
           to the one under the mouse */
        temp = colours_unpack_colour(sprite,col);
        temp.colour ^= 1;
        colours_set_sprite_gcol (temp, sprite, 0);

        /* Set the bg colour for the OS to flood up to */
        if (nc != 256 || psprite_hastruecolpal (sprite))
        { ftracef1 ("deep sprite - setting bg to %d\n", col.colour);
          os_swi2 (OS_SetColour, 1 << 4, col.colour);
        }
        else
        { bbc_gcol (0, 128 | col.colour);
          bbc_tint (3, col.tint >> 6);
        }

        ftracef0 ("flooding to non-bg ...\n");
        bbc_plot (bbc_FloodToBack | bbc_DrawAbsFore, x, y);
        ftracef0 ("flooding to non-bg ... done\n");

        for (y = 0; (y < sin.height) && !(!seenthisline && seenachange); y++)
            {
            seenthisline = FALSE;
            visdelay_percent (y*100/sin.height);
            for (x = 0; x < sin.width; x++)
                {
                /* Diff */
                wimpt_noerr (main_read_pixel (sarea, &sid, x, y, &was));
                wimpt_noerr (main_read_pixel (sarea, &sid2, x, y, &now));
                if ((was.colour != now.colour) || (was.tint != now.tint))
                   {
                   seenthisline = seenachange = TRUE; /* Prevent a quick exit */
                   wimpt_noerr (sprite_writepixel (sarea, &sid, x, y, &col));
                   wimpt_noerr (sprite_writemask (sarea, &sid, x, y, &sms));
                   }
                }
            }
            
      finish:
        if (hourglass) visdelay_end ();
        if (created_sprite) sprite_delete (sprite->file->spritearea, &sid2);
        menus_ensure_size (&sprite->file->spritearea, 0);
        if (msg != NULL)
           {
           sprwindow_swap_output_to_screen ();
           werr (FALSE, msg);
           }
      }
    }

    sprwindow_swap_output_to_screen ();
    psprite_recalculate_offsets (sprite->file);

    ftracef0 ("redisplaying after fill\n");
    sprwindow_redisplay (sprite, NULL);
  }
}

/********************
 * Scissor tool     *
 ********************/

static void order_rect (int *c)

{ ftracef0 ("order_rect\n");
  if (c [2] < c [0]) {int t = c [0]; c [0]  = c [2]; c [2]  = t;}
  if (c [3] < c [1]) {int t = c [1]; c [1]  = c [3]; c [3]  = t;}
}

/* Bound_Pointer() and Unbound_Pointer() were taken from Draw, to constrain
 * the mouse pointer to the window bounds during auto scrolling */
static void Bound_Pointer (int x0, int y0, int x1, int y1)

{ int ox, oy;
  char buf [20];

  ftracef0 ("Tools: Bound_Pointer\n");

  ox = bbc_vduvar (bbc_OrgX);
  oy = bbc_vduvar (bbc_OrgY);

  x0 -= ox, y0 -= oy;
  x1 -= ox, y1 -= oy;

  buf [0] = 1;

  buf [1] = x0;
  buf [2] = x0 >> 8;
  buf [3] = y0;
  buf [4] = y0 >> 8;

  buf [5] = x1;
  buf [6] = x1 >> 8;
  buf [7] = y1;
  buf [8] = y1 >> 8;

  os_swi2 (OS_Word, 21, (int) buf);
}

static void Unbound_Pointer (void)

{ ftracef0 ("Tools: Unbound_Pointer\n");
  Bound_Pointer
   (  0,
      0,
      bbc_vduvar (bbc_XWindLimit) << bbc_vduvar (bbc_XEigFactor),
      bbc_vduvar (bbc_YWindLimit) << bbc_vduvar (bbc_YEigFactor)
   );
}

static void scissorpaint_null (main_window *window, wimp_mousestr *mpos)

{ main_sprite *sprite = window->data->sprite.sprite;
  int state, x, y, coord = 3;
  int overflowx, overflowy, scrollx, scrolly;

  ftracef0 ("scissorpaint_null\n");
  if (sprite->toolspace [0] < 0) return;    /* we're inside an export */

  tools_mouse_to_pixel_overflow (window, mpos, &x, &y, &overflowx, &overflowy);

  /* Auto scroll if the rectangle was dragged to the edge of the window */
  if ((sprite->toolspace [0] == 1 || sprite->toolspace [0] == 3) &&
      (mpos->bbits & wimp_BLEFT))
  { wimp_wstate state;

    /* Bound the mouse to this window while dragging / auto-scrolling, as Draw does */
    wimpt_noerr (wimp_get_wind_state (window->handle,
        &state));
    Bound_Pointer (state.o.box.x0, state.o.box.y0,
        state.o.box.x1, state.o.box.y1);
        
    scrollx = scrolly = 0;
    if (overflowx != 0)
      scrollx = (overflowx>0)?20:-20;
    if (overflowy != 0)
      scrolly = (overflowy>0)?20:-20;

    if (scrollx || scrolly)
    { /* Auto-scroll the window at a fixed speed */
      sprwindow_scroll (window, scrollx, scrolly);
      tools_mouse_to_pixel (window, mpos, &x, &y);
    }
    else
    { /* Reset the auto-scroll timer */
      sprwindow_stop_scroll ();      
    }
  }
  else
  { /* Unbound the mouse */
    Unbound_Pointer ();
    /* Reset the auto-scroll timer */
    sprwindow_stop_scroll ();
  }

  if ((state = sprite->toolspace [0]) == 1 && (mpos->bbits & 4) == 0)
  { /* button gone up on initial rect entry: step state */
    rectangleEOR (sprite, 1);
    sprite->toolspace [3] = sprite->toolspace [5] = x;
    sprite->toolspace [4] = sprite->toolspace [6] = y;
    sprite->toolspace [7] = sprite->toolspace [1];
    sprite->toolspace [8] = sprite->toolspace [2];
    state = sprite->toolspace [0] = 2;
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
        sprite, sprite->toolspace [0]);
    rectangleEOR (sprite, 1);

    if (tools_exporting_sprite)
    { main_sprite tempsprite;
      int width, height, smode, dx, x0;
      main_file file;

      order_rect (&sprite->toolspace [1]);
      sprite->toolspace [0] = -1;
      ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
          sprite, sprite->toolspace [0]);

      smode = psprite_address (sprite)->mode;
      dx = bbc_modevar (smode, bbc_XEigFactor);
      x0 = tools_pixel_to_point_x(&window->data->sprite, sprite->toolspace [1]) &
          ~(((32 >> bbc_modevar (smode, bbc_Log2BPC)) << dx) - 1);
                            /* round down to word boundary */
      width = ((tools_pixel_to_point_x(&window->data->sprite, sprite->toolspace [3]) - x0) >> dx) + 2;
      if ((height = sprite->toolspace [4]-sprite->toolspace [2]) < 0)
           height = -height;
      height += 2;

      ftracef1 ("need %d bytes\n", psprite_size (width, height, smode,
          psprite_hasmask (sprite), !psprite_haspal (sprite)? 0:
          !psprite_hastruecolpal (sprite)? 1: 2));
      flex_alloc ((flex_ptr) &file.spritearea,
          psprite_size (width, height, smode, psprite_hasmask (sprite),
          !psprite_haspal (sprite)? 0: !psprite_hastruecolpal (sprite)? 1:
          2) + sizeof (sprite_area) + 256);

      if (file.spritearea != 0)
      { sprite_id sid;
        os_error *error;

        sprite_area_initialise (file.spritearea,
            flex_size ((flex_ptr) &file.spritearea));

        sprwindow_swap_output_to_sprite (sprite);
        error = sprite_get_given (file.spritearea, "Export",
            psprite_haspal (sprite),
            tools_pixel_to_point_x(&window->data->sprite, sprite->toolspace [1]), 
            tools_pixel_to_point_y(&window->data->sprite, sprite->toolspace [2]),
            tools_pixel_to_point_x(&window->data->sprite, sprite->toolspace [3]), 
            tools_pixel_to_point_y(&window->data->sprite, sprite->toolspace [4]));
        sprwindow_swap_output_to_screen ();
        wimpt_noerr (error);
        sid.tag = sprite_id_name;
        sid.s.name = "Export";
        wimpt_noerr (sprite_select_rp (file.spritearea, &sid, &sid.s.addr));

        /*fake main_sprite*/
        tempsprite.file = &file;
        tempsprite.offset = (int) sid.s.addr - (int) file.spritearea;
        ftracef1 ("offset = %d\n", tempsprite.offset);
        sid.tag = sprite_id_addr;

        if (psprite_hasmask (sprite))
        { sprite_id ssid;

          ftracef0 ("Creating mask\n");

          wimpt_noerr (sprite_create_mask (file.spritearea, &sid));
          ssid.tag = sprite_id_addr;
          ssid.s.addr = psprite_address (sprite);

          sprwindow_swap_output_to_mask (&tempsprite, 0);
          bbc_gcol (0, 0);
          bbc_gcol (3, 0);        /* set empty gcol */
          bbc_clg ();            /* clear it all out */
          bbc_gcol (0, 255);
          bbc_gcol (3, 3);        /* set solid gcol */
          error = sprite_put_mask_given (sprite->file->spritearea,
              &ssid, -tools_pixel_to_point_x(&window->data->sprite, sprite->toolspace [1]),
                     -tools_pixel_to_point_y(&window->data->sprite, sprite->toolspace [2]));
          sprwindow_swap_output_to_screen ();
          wimpt_noerr (error);
        }

        if (psprite_haspal (sprite))
        { int *s, *d, *e;
          sprite_header *saddr = psprite_address (sprite);

          s = &saddr->mode + 1;
          e = (int *) ((char *)saddr + saddr->image);
          d = &psprite_address (&tempsprite)->mode + 1;
          for (; s < e; *d++ = *s++);
        }

        ftracef3 ("export sprite @@ %x (%x, size %d)\n",
           sid.s.addr, psprite_address (sprite),
           ((sprite_header *) sid.s.addr)->next);
        menus_save_sprite (&tempsprite); /* save via xfersend */
        sid.s.addr = psprite_address (&tempsprite);
        sprite_delete (file.spritearea, &sid);
        flex_free ((flex_ptr) &file.spritearea);
      }
      else
        main_NO_ROOM ("Export buffer");

      sprwindow_release_idle_events (sprite);
      rectangleEOR (sprite, 1);
      sprite->toolspace [0] = 0;
      ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
          sprite, sprite->toolspace [0]);
      return;
    }

    rectangleEOR (sprite, 5);
  }

  if (state >= 2) coord = 5;

  if (x != sprite->toolspace [coord] || y != sprite->toolspace [coord + 1])
  { 
    if (state == 3)
    {
      if (sprite->toolspace [5]==x-sprite->toolspace [1] &&
          sprite->toolspace [6]==y-sprite->toolspace [2]) return;
    }

    if (state != 3) rectangleEOR (sprite, 1);
                                    /* unplot source clip outline */

    if (state >= 2)
    { rectangleEOR (sprite, 5);       /* unplot dest clip outline */
      if (state == 3)
      { sprite->toolspace [5] = x-sprite->toolspace [1];
        sprite->toolspace [6] = y-sprite->toolspace [2];
        sprite->toolspace [7] = sprite->toolspace [5] + sprite->toolspace [3];
        sprite->toolspace [8] = sprite->toolspace [6] + sprite->toolspace [4];
      }
      else
      { sprite->toolspace [7] = x + sprite->toolspace [7] -
            sprite->toolspace [5];
        sprite->toolspace [8] = y + sprite->toolspace [8] -
            sprite->toolspace [6];
        sprite->toolspace [5] = x;
        sprite->toolspace [6] = y;
      }
      rectangleEOR (sprite, 5);       /* replot dest clip outline */
    }
    else
    { sprite->toolspace [coord] = x;
      sprite->toolspace [coord  + 1] = y;
    }

    if (state != 3) rectangleEOR (sprite, 1);
                               /* replot source clip outline */
  }
}

/***************************************************************************
 * Redraw tool: most of EORing routine, rehashed to just do current window *
 **************************************************************************/

static void scissorpaint_redraw (main_window *window, int x0, int y0)

{ main_sprite *sprite = window->data->sprite.sprite;

  ftracef0 ("scissorpaint_redraw\n");
  if (sprite->needsnull)
  { 
    if (sprite->toolspace [0] != 3)
      rectangle_drawEOR(&window->data->sprite,&sprite->toolspace [1], x0, y0);
   
    if (sprite->toolspace [0] >= 2)
      rectangle_drawEOR(&window->data->sprite,&sprite->toolspace [5], x0, y0);
  }
}

/**************
 * Stop tool  *
 **************/

static void scissorpaint_stop (main_sprite *sprite)

{ ftracef0 ("scissorpaint_stop\n");
  if (sprite->needsnull)
  { if (sprite->toolspace [0] != 3) rectangleEOR (sprite, 1);
      /* unplot outline */
    if (sprite->toolspace [0] >= 2) rectangleEOR (sprite, 5);
    sprite->toolspace [0] = 0; /* and restart state */
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
        sprite, sprite->toolspace [0]);
    sprwindow_release_idle_events (sprite);
  }
  /* Unbound the mouse */
  Unbound_Pointer ();
  /* Reset the auto-scroll timer */
  sprwindow_stop_scroll ();  
}

static void copymovepaint_click (main_window *window, wimp_mousestr *mpos,
    int move)

{ main_sprite *sprite = window->data->sprite.sprite;
  int x, y;

  tools_mouse_to_pixel (window, mpos, &x, &y);

  ftracef0 ("copymovepaint_click\n");
  if ((mpos->bbits & 1) == 0) /*ignore adjust: done in nulls*/
    switch (sprite->toolspace [0] & 0xFF /*low byte only. JRC 6 July 1991*/)
    { case 0:
        if ((mpos->bbits & wimp_BDRAGLEFT) != 0) /*have to drag to start*/
        { sprwindow_claim_idle_events (window);    /* start tracking */
          sprite->toolspace [3] = sprite->toolspace [1] = x;
          sprite->toolspace [4] = sprite->toolspace [2] = y;
          sprite->toolspace [0] = 1;
          ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
              sprite, sprite->toolspace [0]);
          rectangleEOR (sprite, 1);
        }
      break;

      case 2:
        rectangleEOR (sprite, 1);         /* unplot old */
      case 3:
      { int code = move? bbc_BMoveRectAbs: bbc_BCopyRectAbs;
        int x, y;
        main_sprite_window *swind=&window->data->sprite;
        if (move) sprwindow_release_idle_events (sprite);
        rectangleEOR (sprite, 5);

        sprwindow_swap_output_to_sprite (sprite);
        x = sprite->toolspace [5];
        if (x>sprite->toolspace [7]) x = sprite->toolspace [7];
        y = sprite->toolspace [6];
        if (y>sprite->toolspace [8]) y = sprite->toolspace [8];

        bbc_move (tools_pixel_to_point_x(swind, sprite->toolspace [1]), 
                  tools_pixel_to_point_y(swind, sprite->toolspace [2]));
        bbc_move (tools_pixel_to_point_x(swind, sprite->toolspace [3]),
                  tools_pixel_to_point_y(swind, sprite->toolspace [4]));
        bbc_plot (bbc_Block + code, tools_pixel_to_point_x(swind, x),
                                    tools_pixel_to_point_y(swind, y));

        if (sprwindow_swap_output_to_mask (sprite, 1))
        {
          bbc_move (tools_pixel_to_point_x(swind, sprite->toolspace [1]), 
                    tools_pixel_to_point_y(swind, sprite->toolspace [2]));
          bbc_move (tools_pixel_to_point_x(swind, sprite->toolspace [3]),
                    tools_pixel_to_point_y(swind, sprite->toolspace [4]));
          bbc_plot (bbc_Block + code, tools_pixel_to_point_x(swind, x),
                                      tools_pixel_to_point_y(swind, y));
        }

        Set_Marked_Extent (sprite);
        sprwindow_swap_output_to_screen ();

        if (move)
        { sprite->toolspace [0] = 0;
          ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
              sprite, sprite->toolspace [0]);
        }
        else
        { rectangleEOR (sprite, 1);
          rectangleEOR (sprite, 5);
        }

        psprite_recalculate_offsets (sprite->file);
        sprwindow_redisplay (sprite, &Marked_Extent);
      }
    break;
  }
}


static void camerapaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("camerapaint_click\n");

  if (mpos->bbits & 1)
  {
    scissorpaint_stop(window->data->sprite.sprite);
    return;
  }

  copymovepaint_click (window, mpos, 0);
}

static void scissorpaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("scissorpaint_click\n");

  if (mpos->bbits & 1)
  {
    scissorpaint_stop(window->data->sprite.sprite);
    return;
  }

  copymovepaint_click (window, mpos, 1);
}

static void grabberpaint_click (main_window *window, wimp_mousestr *mpos)

{ main_sprite *sprite = window->data->sprite.sprite;

  ftracef0 ("grabberpaint_click\n");

  if (mpos->bbits & 1)
  {
    scissorpaint_stop(window->data->sprite.sprite);
    return;
  }

  if (sprite->toolspace [0] == 0)
  { if (mpos->bbits & wimp_BDRAGLEFT)
    { sprite_info sid;
      int x, y;

      tools_mouse_to_pixel (window, mpos, &x, &y);
      sprwindow_claim_idle_events (window);
      tools_get_sprite_info_pixels(sprite,&sid);
      sprite->toolspace [1] = x;             /* start pos */
      sprite->toolspace [2] = y;
      sprite->toolspace [3] = sid.width-1;     /* box size */
      sprite->toolspace [4] = sid.height-1;
      sprite->toolspace [5] = 0;  /* curr rectangle */
      sprite->toolspace [6] = 0;
      sprite->toolspace [7] = sprite->toolspace [3] + sprite->toolspace [5];
      sprite->toolspace [8] = sprite->toolspace [4] + sprite->toolspace [6];
      sprite->toolspace [0] = 3;
      ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
          sprite, sprite->toolspace [0]);
      rectangleEOR (sprite, 5);
    }
  }
}

static void grabberpaint_null (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("grabberpaint_null\n");
  scissorpaint_null (window, mpos);

  if ((mpos->bbits & 4) == 0)           /* if button gone up do move */
  { main_sprite *sprite = window->data->sprite.sprite;
    sprite->toolspace [1] = 0;
    sprite->toolspace [2] = 0;
    copymovepaint_click (window, mpos, 2);
  }
}


/********************
 * The text tool    *
 ********************/

static int saved_tx;
static int saved_ty;
static int saved_txs;
static int saved_tys;

/* get the default text sizes for the mode */

extern void tools_get_default_text_size ( void )

{
#if 1
  int  text_x;
  int  text_y;
  int  text_xs;

  ftracef0 ("get_default_text_size\n");
  text_x = bbc_vduvar (162);
  text_y = bbc_vduvar (163);
  text_xs = bbc_vduvar (164);

  sprintf (tools_text_xsize, "%d", text_x);
  sprintf (tools_text_ysize, "%d", text_y);
  sprintf (tools_text_xspace, "%d", text_xs);
#endif
}


static void set_text_size (int tx, int ty, int txs)

{ ftracef0 ("set_text_size\n");
  saved_tx  = bbc_vduvar (162);
  saved_ty  = bbc_vduvar (163);
  saved_txs = bbc_vduvar (164);
  saved_tys = bbc_vduvar (165);

 spencer2
 ({int text_x  = bbc_vduvar (162); /* changed from 162 -> 167 */
   int text_y  = bbc_vduvar (163); /* changed from 163 -> 168 */
   int text_xs = bbc_vduvar (164); /* changed from 164 -> 169 */
   int text_ys = bbc_vduvar (175); /* changed from 165 -> 170 */

   ftracef0 ("text_size: setting the text size\n");
   ftracef4 ("sizes are: x=%d y=%d xs=%d ys=%d\n",
     text_x, text_y, text_xs, text_ys);
  }
 )

 bbc_vduq (23, 17, 7, 2, tx, tx>>8, ty, ty>>8, 0, 0);
 bbc_vduq (23, 17, 7, 4, txs, txs>>8, ty, ty>>8, 0, 0);
}

static void restore_text_size (void)

{ ftracef0 ("restore_text_size\n");
  bbc_vduq (23, 17, 7, 2, saved_tx, saved_tx>>8, saved_ty, saved_ty>>8, 0, 0);
 bbc_vduq (23, 17, 7, 4, saved_txs, saved_txs>>8, saved_tys, saved_tys>>8, 0, 0);
}

static void text_drawEOR(main_sprite_window *swind, int *toolspace, int x0, int y0)
{
  int tx, ty, txs;

  tx  = tools_pixel_to_extent_x(swind, textxsize)/swind->sprite->mode.scale_xdiv;
  txs = tools_pixel_to_extent_x(swind, textxspace)/swind->sprite->mode.scale_xdiv;
  ty  = tools_pixel_to_extent_y(swind, textysize)/swind->sprite->mode.scale_ydiv;

  set_text_size (tx, ty, txs);
  x0 += tools_pixel_to_extent_x(swind, toolspace[3]-((strlen(curr_text_buffer)-1)*textxspace+textxsize)/2);
  y0 += tools_pixel_to_extent_y(swind, toolspace[4]+textysize/2+1)-1;

  os_swi2 (OS_SetColour, 3, -1);
#if 0
  /*replaces the following, avoiding need to check full-palette bit*/
  bbc_gcol (3, 127);
  bbc_tint (2, 3); /*10 Sept 1991*/
#endif
  bbc_move (x0, y0);
  puts (curr_text_buffer);
  restore_text_size ();
}

static void textEOR (main_sprite *sprite)

{ main_sprite_window *swind;

  for (swind = sprite->windows; swind != NULL; swind = swind->link)
  {
    int more, x0, y0;
    wimp_redrawstr rds;

    ftracef0 ("textEOR\n");

    sprite_update_window(swind,&x0,&y0,&rds,&more);
    while (more)
    { 
      text_drawEOR(swind, sprite->toolspace, x0, y0);
      wimpt_noerr (wimp_get_rectangle (&rds, &more));
    }

    restore_text_size ();
  }
}

static void set_text_parameters (void)

{ char *str;
  int tx, ty, txs, changed, n;

  ftracef0 ("set_text_parameters\n");
  /* ensure termination */
  for (str = tools_text_buffer; *str >= ' '; str++);
  *str = '\0';

  changed = strcmp (tools_text_buffer, curr_text_buffer);
  if (!(sscanf (tools_text_xsize, "%d%n", &tx, &n) == 1 &&
      n == strlen (tools_text_xsize)))
    tx = textxsize;
  changed |= tx != textxsize;

  if (!(sscanf (tools_text_ysize, "%d%n", &ty, &n) == 1 &&
      n == strlen (tools_text_ysize)))
    ty = textysize;
  changed |= ty != textysize;

  if (!(sscanf (tools_text_xspace, "%d%n", &txs, &n) == 1 &&
      n == strlen (tools_text_xspace)))
    txs = textxspace;
  changed |= txs != textxspace;

  if (changed)
  { main_window *window;

    /* remove any EORed text on screen */

    for (window = main_windows; window != NULL; window = window->link)
      if (window->tag == main_window_is_file)
      { main_sprite *sprite;
        for (sprite = window->data->file.sprites;
            sprite != NULL;
            sprite = sprite->link)
          if (sprite->toolspace [0] == 1) textEOR (sprite);
      }

    /* update the current data */
    strcpy (curr_text_buffer, tools_text_buffer);
    textxsize = tx;
    textysize = ty;
    textxspace = txs;

    /* put the text back */
    for (window = main_windows; window != NULL; window = window->link)
      if (window->tag == main_window_is_file)
      { main_sprite *sprite;
        for (sprite = window->data->file.sprites;
            sprite != NULL; sprite = sprite->link)
          if (sprite->toolspace [0] == 1) textEOR (sprite);
      }
  }
}

static void textpaint_splot (main_window *window, wimp_mousestr *mpos)

{ int x0, y1;
  main_sprite_window *spritew = &window->data->sprite;
  main_sprite *sprite = spritew->sprite;

  ftracef0 ("textpaint_splot\n");
  tools_mouse_to_pixel (window, mpos, &x0, &y1);

  if (x0 != sprite->toolspace [3] || y1 != sprite->toolspace [4])
  { int restore = 0;
    main_colour gcol = mpos->bbits & wimp_BRIGHT? sprite->gcol2: sprite->gcol;

    sprite->toolspace [3]=x0;
    sprite->toolspace [4]=y1;

    x0 = tools_pixel_to_point_x(spritew, x0 - ((strlen (curr_text_buffer)-1)*textxspace + textxsize)/2);
    y1 = tools_pixel_to_point_y(spritew, y1 + textysize/2+1)-1;      

    BOOL write_image = gcol.alpha || (psprite_transparency_type(sprite) == transparency_type_alphachannel);
    if (write_image)       /* if not "transparent" */
    { restore = 1;
      sprwindow_swap_output_to_sprite (sprite);

      colours_set_sprite_gcol (gcol, sprite, 0);
      bbc_vdu (5);
      bbc_vduq (23, 17, 7, 2,
          textxsize, textxsize>>8, textysize, textysize>>8, 0, 0);
      bbc_vduq (23, 17, 7, 4,
          textxspace, textxspace>>8, textysize, textysize>>8, 0, 0);
      bbc_move (x0, y1);
      puts (curr_text_buffer);
    }

    if (sprwindow_swap_output_to_mask (sprite, write_image))
    { restore = 1;
      colours_set_gcol (gcol.alpha, 0, 0);
      bbc_vdu (5);
      bbc_vduq (23, 17, 7, 2,
          textxsize, textxsize>>8, textysize, textysize>>8, 0, 0);
      bbc_vduq (23, 17, 7, 4,
          textxspace, textxspace>>8, textysize, textysize>>8, 0, 0);
      bbc_move (x0, y1);
      puts (curr_text_buffer);
    }

    if (restore)
    { Set_Marked_Extent (sprite);
      sprwindow_swap_output_to_screen ();
      psprite_recalculate_offsets (sprite->file);

      sprwindow_redisplay (sprite, &Marked_Extent);
    }
  }
}

/***********************************************************
 * Null events: if pointer is over a window on the sprite, *
 *    then another text stroke                             *
 ***********************************************************/

static void textpaint_null (main_window *window, wimp_mousestr *mpos)

{ main_sprite *sprite = window->data->sprite.sprite;

  ftracef0 ("textpaint_null\n");
  set_text_parameters ();

  if (mpos->bbits == 0 || sprite->toolspace [0] != 2)
  /* if the mouse button is now up, stop tracking; no tracking until click */
  { int x, y;

    tools_mouse_to_pixel (window, mpos, &x, &y);

    if (x != sprite->toolspace [3] || y != sprite->toolspace [4])
    { if (sprite->toolspace [0] == 1)
        textEOR (sprite);         /* remove old copy */
      else
      { sprite->toolspace [0] = 1;
        ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
            sprite, sprite->toolspace [0]);
      }

      sprite->toolspace [3] = x;
      sprite->toolspace [4] = y;

      textEOR (sprite);
    }
  }
  else
    textpaint_splot (window, mpos);
}

static void stoptext (main_sprite *sprite)

{ ftracef0 ("stoptext\n");
  if (sprite->toolspace [0] == 1) textEOR (sprite);
  sprwindow_release_idle_events (sprite);
  sprite->toolspace [0] = 0;
  ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
      sprite, sprite->toolspace [0]);
}

static void textredraw (main_window *window, int x0, int y0)

{ main_sprite_window *swind = &window->data->sprite;
  main_sprite *sprite=window->data->sprite.sprite;
  ftracef0 ("textredraw\n");
  /* set_text_parameters ();  don't do this as it may lead to calls which
    invalidate the surrounding get_rectangle calls! */

  if (sprite->toolspace [0] == 1)
    text_drawEOR(swind, sprite->toolspace, x0, y0);
}

static void textpaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("textpaint_click\n");
  set_text_parameters ();
  if ((mpos->bbits & (wimp_BLEFT | wimp_BRIGHT)) != 0)
  { main_sprite *sprite = window->data->sprite.sprite;

    if (sprite->toolspace [0] == 1) textEOR (sprite);
    sprite->toolspace [0] = 2;
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
        sprite, sprite->toolspace [0]);
    sprite->toolspace [3] = sprite->toolspace [4] = -1;
    textpaint_splot (window, mpos);
  }
}

/***********************************
 *                                 *
 * spraycanpaint tool: plot points *
 *                                 *
 ***********************************/

/***********************************************************
 *  Actual spraycan zapper                                 *
 ***********************************************************/

/* random number generation: return 0..1, using knowledge of IEEE format */

static int rndseed = 42;
static int myrnd (void)

{ ftracef0 ("myrnd\n");
  rndseed = 2147001325*rndseed + 715136305;
  return rndseed;
}

static void spraycanpaint_splot (main_window *window, wimp_mousestr *mpos)

{ int dopix, domask, i, x, y;
  sprite_id sid;
  sprite_colour colour;
  sprite_maskstate mask;
  wimp_box redraw_area;
  main_sprite *sprite = window->data->sprite.sprite;
  sprite_area *sarea = sprite->file->spritearea;
  main_colour gcol = mpos->bbits == 1? sprite->gcol2: sprite->gcol;
      /* adjust clears to background, select uses current gcol */

  ftracef0 ("spraycanpaint_splot\n");

  /*Do nothing if radius == 0. J R C 5th Oct 1993*/
  if (sprayradius > 0)
  {
    int pxs, pys, elapsed, adjusted_density;
    /*Adjust spray density according to CPU speed */
    os_swix1r(OS_ReadMonotonicTime, 0, &elapsed);
    if (spraytime > 0)
    {
      elapsed -= spraytime;
      /*Divide this by a bigger constant to slow down the spray rate*/
      adjusted_density = (spraydensity * elapsed) / 8;
      if (adjusted_density > 0)
      {
        /*Reset the timer*/
        spraytime += elapsed;
        /*Sanity checks to stop unresponsiveness*/
        if (adjusted_density > 999)
          adjusted_density = 999;
        if (adjusted_density > spraydensity * 2)
          adjusted_density = spraydensity * 2;
      }
    }
    else
    {
      /*Initial spray iteration*/
      spraytime = elapsed;
      adjusted_density = spraydensity / 10;
    }

    if (adjusted_density > 0)
    {
      tools_mouse_to_pixel (window, mpos, &x, &y);
      pxs=tools_pixel_to_point_x(&window->data->sprite, 1);
      pys=tools_pixel_to_point_y(&window->data->sprite, 1);

      colour = colours_pack_colour(sprite, gcol);
      mask = colours_pack_mask(sprite, gcol);

      sprite->toolspace [0] = x;
      sprite->toolspace [1] = y;
      ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
          sprite, sprite->toolspace [0]);

      sid.s.addr = psprite_address (sprite);
      sid.tag = sprite_id_addr;

      dopix  = gcol.alpha || (psprite_transparency_type(sprite) == transparency_type_alphachannel);
      domask = psprite_hasmask (sprite);

      visdelay_begin ();
      for (i = 0; i < adjusted_density; i++)
      { int r, nx, ny;
        double theta;

        /*nx = (myrnd () >> 24) % sprayradius;
        ny = (myrnd () >> 23) % sprayradius;*/

        /*nx = myrnd ()%sprayradius;
        ny = myrnd ()%sprayradius;*/

        r = myrnd ()%sprayradius;
        theta = fmod ((double) myrnd (), 2*3.1415926);

        nx = x + (int) (r*cos (theta))/pxs;
        ny = y + (int) (r*sin (theta))/pys;

        if (dopix)
        { sprite_colour newcolour = colour;

          MUNGE_PIXEL (nx, ny, &newcolour, &gcol, sarea, &sid, sprite)
          ftracef2 ("sprite_writepixel (GCOL 0x%X, TINT 0x%X)\n",
              newcolour.colour, newcolour.tint);
          sprite_writepixel (sarea, &sid, nx, ny, &newcolour);
        }

        if (domask)
          sprite_writemask (sarea, &sid, nx, ny, &mask);
      }
      visdelay_end ();


      redraw_area.x0=tools_pixel_to_point_x(&window->data->sprite, x) - sprayradius;
      redraw_area.y0=tools_pixel_to_point_y(&window->data->sprite, y) - sprayradius;
      redraw_area.x1=tools_pixel_to_point_x(&window->data->sprite, x+1) + sprayradius + 1;
      redraw_area.y1=tools_pixel_to_point_y(&window->data->sprite, y+1) + sprayradius + 1;

      sprwindow_redisplay (sprite, &redraw_area);
    }
  }
}

/***********************************************************
 *  Start point plotting                                   *
 ***********************************************************/

static void spraycanpaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("spraycanpaint_click\n");
  if (mpos->bbits & (wimp_BRIGHT | wimp_BLEFT)) /* ignore drags */
  { main_sprite *sprite = window->data->sprite.sprite;
    int n, s;

    if (sscanf (tools_spray_radius, "%d%n", &s, &n) == 1 &&
        n == strlen (tools_spray_radius))
      sprayradius = s;
    if (sscanf (tools_spray_density, "%d%n", &s, &n) == 1 &&
        n == strlen (tools_spray_density))
      spraydensity = s;

    ftracef2 ("Radius %d, density %d\n", sprayradius, spraydensity);

    sprwindow_claim_idle_events (window);    /* start tracking */
    main_set_modified (sprite->file);
    sprite->toolspace [0] = sprite->toolspace [1] = -1;
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
        sprite, sprite->toolspace [0]);

    spraycanpaint_splot (window, mpos);
  }
}

/***********************************************************
 * Null events: if pointer is over a window on the sprite, *
 *    then plot a point                                    *
 ***********************************************************/

static void spraycanpaint_null (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("spraycanpaint_null\n");
  if (mpos->bbits == 0) /*if the mouse button is now up, stop tracking*/
  {
    sprwindow_release_idle_events (window->data->sprite.sprite);
    /*Reset spray timer*/
    spraytime = 0;
  }
  else
    spraycanpaint_splot (window, mpos);
}

/*********************
 *  The Brush tool   *
 *********************/

static void brushpaint_splot (main_window *window, wimp_mousestr *mpos)

{ int x, y;
  main_sprite *sprite = window->data->sprite.sprite;
  tools_mouse_to_pixel (window, mpos, &x, &y);

  ftracef0 ("brushpaint_splot\n");

  if (x != sprite->toolspace [3] || y != sprite->toolspace [4])
  { main_ttab *ott = tools_brushsprite_ptr->transtab;
    int smxd = tools_brushsprite_ptr->mode.scale_xdiv;
        /*current mode pixel sizes*/
    int smyd = tools_brushsprite_ptr->mode.scale_ydiv;
    sprite_info sbi;
    sprite_id sid;
    int mul, div;
    main_sprite_window *swind=&window->data->sprite;

    sid.s.addr = psprite_address (tools_brushsprite_ptr);
    sid.tag = sprite_id_addr;

    sprite_readsize (tools_brushsprite_ptr->file->spritearea, &sid, &sbi);

    /* now set dest mode pixel sizes */
    tools_brushsprite_ptr->mode.scale_xdiv = sprite->mode.scale_xmul;
    tools_brushsprite_ptr->mode.scale_ydiv = sprite->mode.scale_ymul;

    tools_brushsprite_ptr->transtab = (main_ttab *) sprite->toolspace [2];

    sprite->toolspace [3] = x;
    sprite->toolspace [4] = y;

    x = tools_pixel_to_point_x(swind, sprite->toolspace [3]);
    mul=tools_brushsprite_ptr->mode.scale_xmul*tools_brushscale.scale_xmul;
    div=swind->sprite->mode.scale_xmul*tools_brushscale.scale_xdiv;
    x-=tools_pixel_to_point_x(swind,(sbi.width*mul/div)/2);

    y = tools_pixel_to_point_y(swind, sprite->toolspace [4]);
    mul=tools_brushsprite_ptr->mode.scale_ymul*tools_brushscale.scale_ymul;
    div=swind->sprite->mode.scale_ymul*tools_brushscale.scale_ydiv;
    y -= tools_pixel_to_point_y(swind,(sbi.height*mul/div)/2);

    sprwindow_swap_output_to_sprite (sprite);

    if (tools_brush_use_gcol)
    { colours_set_sprite_gcol (mpos->bbits & wimp_BRIGHT? sprite->gcol2:
          sprite->gcol, sprite, 1);
      psprite_plot_scaled_m (x, y, tools_brushsprite_ptr,
          &tools_brushscale, toolwindow_current_mode, 1);
    }
    else
      psprite_plot_scaled_m (x, y, tools_brushsprite_ptr,
          &tools_brushscale, toolwindow_current_mode, 0);

    if (sprwindow_swap_output_to_mask (sprite, 1))
    { BOOL c = tools_brush_use_gcol &&
          !sprite->gcol.alpha;

      os_swi2 (OS_SetColour, c? 0: 1 << 4, c? 0: -1);
    #if 0
      /*replaces the following, avoiding need to check full-palette bit*/
      colour = tools_brush_use_gcol &&
          sprite->gcol == colours_count (sprite)? 0: 255;
      bbc_gcol (0, colour);
      bbc_tint (3, colour);
    #endif
      psprite_plot_scaled_m (x, y,
          tools_brushsprite_ptr, &tools_brushscale, 0, 1);
    }

    tools_brushsprite_ptr->transtab = ott;
    tools_brushsprite_ptr->mode.scale_xdiv = smxd;
    tools_brushsprite_ptr->mode.scale_ydiv = smyd;

    Set_Marked_Extent (sprite);
    sprwindow_swap_output_to_screen ();
    psprite_recalculate_offsets (sprite->file);
    sprwindow_redisplay (sprite, &Marked_Extent);
  }
}

static void brush_drawEOR(main_sprite_window *swind, int *toolspace, int x0, int y0)
{
  int x, y;
  main_scaling_block scale;
  sprite_info sbi;
  sprite_id sid;
  int mul, div;

  sid.s.addr = psprite_address (tools_brushsprite_ptr);
  sid.tag = sprite_id_addr;

  sprite_readsize (tools_brushsprite_ptr->file->spritearea, &sid, &sbi);

  scale.scale_xmul =
      tools_brushscale.scale_xmul*swind->blobsize.scale_xmul;
  scale.scale_xdiv =
      tools_brushscale.scale_xdiv*swind->blobsize.scale_xdiv;
  scale.scale_ymul =
      tools_brushscale.scale_ymul*swind->blobsize.scale_ymul;
  scale.scale_ydiv =
      tools_brushscale.scale_ydiv*swind->blobsize.scale_ydiv;

  /* find bottom left of brush. Pixel over pointer is aligned
     to pixel grid. */

  x = tools_pixel_to_extent_x(swind, toolspace [3]);
  mul=tools_brushsprite_ptr->mode.scale_xmul*tools_brushscale.scale_xmul;
  div=swind->sprite->mode.scale_xmul*tools_brushscale.scale_xdiv;
  x-=tools_pixel_to_extent_x(swind,(sbi.width*mul/div)/2);

  y = tools_pixel_to_extent_y(swind, toolspace [4]);
  mul=tools_brushsprite_ptr->mode.scale_ymul*tools_brushscale.scale_ymul;
  div=swind->sprite->mode.scale_ymul*tools_brushscale.scale_ydiv;
  y -= tools_pixel_to_extent_y(swind,(sbi.height*mul/div)/2);


  psprite_plot_scaled (x+x0, y+y0, tools_brushsprite_ptr, &scale, 4);
}

static void brushEOR (main_sprite *sprite)

{ main_sprite_window *swind;

  ftracef0 ("brushEOR\n");
  for (swind = sprite->windows; swind != NULL; swind = swind->link)
  { 
    int more, x0, y0;
    wimp_redrawstr rds;
    
    sprite_update_window(swind,&x0,&y0,&rds,&more);
    while (more)
    { 
      brush_drawEOR(swind, sprite->toolspace, x0, y0);
      wimpt_noerr (wimp_get_rectangle (&rds, &more));
    }
  }
}

/**************************************************
 * Brush: find named sprite, plot at current pos. *
 **************************************************/

static void brushpaint_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("brushpaint_click\n");
  if ((mpos->bbits & (wimp_BLEFT | wimp_BRIGHT)) != 0 &&
      tools_brushsprite_ptr != NULL)
  { main_sprite *sprite = window->data->sprite.sprite;

    if (sprite->toolspace [0] == 1) brushEOR (sprite);
    sprite->toolspace [0] = 2;    /* had click, no EOR */
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
        sprite, sprite->toolspace [0]);
    sprite->toolspace [3] = sprite->toolspace [4] = -1;
    brushpaint_splot (window, mpos);
  }
}

/***********************************************************
 * Null events: if pointer is over a window on the sprite, *
 *    then another brush stroke                            *
 ***********************************************************/

static void brushpaint_null (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("brushpaint_null\n");
  if (tools_brushsprite_ptr != NULL)
  { main_sprite *sprite = window->data->sprite.sprite;

    if (mpos->bbits == 0 || sprite->toolspace [0] != 2)
    /*if the mouse button is now up, stop tracking; don't start until click*/
    { int x, y;

      tools_mouse_to_pixel (window, mpos, &x, &y);

      if (x != sprite->toolspace [3] || y != sprite->toolspace [4])
      { if (sprite->toolspace [0] == 1)
          brushEOR (sprite);         /* remove old copy */
        else
        { sprite->toolspace [0] = 1;
          ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
              sprite, sprite->toolspace [0]);
        }

        sprite->toolspace [3] = x;
        sprite->toolspace [4] = y;

        brushEOR (sprite);
      }
    }
    else
      brushpaint_splot (window, mpos);
  }
}

static void stopbrush (main_sprite *sprite)

{ ftracef0 ("stopbrush\n");
  if (sprite->toolspace [0] == 1 && tools_brushsprite_ptr != NULL)
    brushEOR (sprite);
  sprwindow_release_idle_events (sprite);
  sprite->toolspace [0] = 0;
  ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
      sprite, sprite->toolspace [0]);
}

void tools_remove_brush (void)

{ main_window *window;

  ftracef0 ("tools_remove_brush\n");
  /* remove any EORed brushes on screen */

  for (window = main_windows; window != NULL; window = window->link)
  if (window->tag == main_window_is_file)
  { main_sprite *sprite;
   for (sprite = window->data->file.sprites;
        sprite != NULL;
        sprite = sprite->link)
    if (sprite->toolspace [0] == 1) brushEOR (sprite);
  }
}

void tools_replace_brush (void)

{ ftracef0 ("tools_replace_brush\n");
  tools_remove_brush ();
}

static void brushredraw (main_window *window, int x0, int y0)

{ ftracef0 ("brushredraw\n");
  if (tools_brushsprite_ptr != NULL)
  { main_sprite_window *swind = &window->data->sprite;
    main_sprite *sprite = swind->sprite;

    if (sprite->toolspace [0] == 1)
    { 
      brush_drawEOR(swind, sprite->toolspace, x0, y0);
    }
  }
}

/***********************************************************
 * Stop null events: general purpose tool closure routine  *
 ***********************************************************/

static void stopnulls (main_sprite *sprite)

{ ftracef0 ("stopnulls\n");
  sprwindow_release_idle_events (sprite);
  sprite->toolspace [0] = 0;
  ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
      sprite, sprite->toolspace [0]);
}

static void Skip (main_window *window, int x, int y)

{ ftracef0 ("Skip\n");
  window = window; x = x; y = y;
}

/*************************************
 *                                   *
 *     The available tools           *
 *                                   *
 *************************************/

toolwindow_block tools_pixelpaint = { &pixelpaint_click,
                          &pixelpaint_null,
                          &Skip,
                          &stopnulls,
                          "PntT1" };
toolwindow_block tools_circlepaint= { &circlepaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntT2" };
toolwindow_block tools_linepaint  = { &linepaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntT3" };
toolwindow_block tools_circleoutlinepaint
                      = { &circleoutlinepaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntT4" };
toolwindow_block tools_trianglepaint
                      = { &trianglepaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntT5" };
toolwindow_block tools_ellipsepaint
                      = { &ellipsepaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntT6" };
toolwindow_block tools_ellipseoutlinepaint
                      = { &ellipseoutlinepaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntT7" };
toolwindow_block tools_segmentpaint
                      = { &segmentpaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntT8" };
toolwindow_block tools_sectorpaint
                      = { &sectorpaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntT9" };
toolwindow_block tools_arcpaint
                      = { &arcpaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntTA" };
toolwindow_block tools_parallelogrampaint
                      = { &parallelogrampaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntTB" };
toolwindow_block tools_parallelogramoutlinepaint
                      = { &parallelogramoutlinepaint_click,
                          &parallelogramoutlinepaint_null,
                          &parallelogramoutlinepaint_redraw,
                          &parallelogramoutlinepaint_stop,
                          "PntTC" };
toolwindow_block tools_rectanglepaint
                      = { &rectanglepaint_click,
                          &tabledriven_null,
                          &tabledriven_redraw,
                          &tabledriven_stop,
                          "PntTD" };
toolwindow_block tools_rectangleoutlinepaint
                      = { &rectangleoutlinepaint_click,
                          &rectangleoutlinepaint_null,
                          &rectangleoutlinepaint_redraw,
                          &rectangleoutlinepaint_stop,
                          "PntTE" };
toolwindow_block tools_floodfillpaint
                      = { &floodfillpaint_click,
 (void (*) (main_window *, wimp_mousestr *)) &Skip,
                          &Skip,
                          &stopnulls,
                          "PntTF" };
toolwindow_block tools_scissorpaint
                      = { &scissorpaint_click,
                          &scissorpaint_null,
                          &scissorpaint_redraw,
                          &scissorpaint_stop,
                          "PntTG" };
toolwindow_block tools_grabberpaint
                      = { &grabberpaint_click,
                          &grabberpaint_null,
                          &scissorpaint_redraw,
                          &scissorpaint_stop,
                          "PntTH" };
toolwindow_block tools_camerapaint
                      = { &camerapaint_click,
                          &scissorpaint_null,
                          &scissorpaint_redraw,
                          &scissorpaint_stop,
                          "PntTI" };
toolwindow_block tools_textpaint
                      = { &textpaint_click,
                          &textpaint_null,
                          &textredraw,
                          &stoptext,
                          "PntTJ" };
toolwindow_block tools_spraycanpaint
                      = { &spraycanpaint_click,
                          &spraycanpaint_null,
                          &Skip,
                          &stopnulls,
                          "PntTK" };
toolwindow_block tools_brushpaint
                      = { &brushpaint_click,
                          &brushpaint_null,
                          &brushredraw,
                          &stopbrush,
                          "PntTL" };

/*************************************************
 * Call OS_ChangedBox to get invalid screen area *
 *************************************************/

#pragma -c0 /*Doesn't work with memory access checks on!!*/

static void Set_Marked_Extent (main_sprite *sprite)

{ int *r, xm, ym;
  wimp_box *cb;

  ftracef0 ("Set_Marked_Extent\n");
  os_swix2r (OS_ChangedBox, -1, 0, NULL, (int *) &r);
  cb = (wimp_box *) (r + 1);
  xm = sprite->mode.scale_xmul;
  ym = sprite->mode.scale_ymul;
  Marked_Extent.x0 = cb->x0*xm;
  Marked_Extent.x1 = (cb->x1 + 1)*xm;
  Marked_Extent.y0 = cb->y0*ym;
  Marked_Extent.y1 = (cb->y1 + 1)*ym;

  ftracef4 ("new marked extent is ((%d, %d), (%d, %d))\n",
      Marked_Extent.x0, Marked_Extent.y0,
      Marked_Extent.x1, Marked_Extent.y1);
}
@


4.10
log
@Moderate spray can density based on time not CPU speed
Detail:
  The spray tool rate was ultimately determined by the number of wimp polls per second, which on a fast CPU can be 10,000's making the spray can more of a circle drawing tool.
  Use OS_ReadMonotonicTime to moderate the spray rate, so the speed of the CPU doesn't matter.
  Default density increased to 100 to achieve roughly the same density as a StrongARM Risc PC would previously.
Admin:
  Submission for the Paint bounty.

Version 2.21. Tagged as 'Paint-2_21'
@
text
@d204 15
d224 6
d235 16
d1523 41
d1568 1
d1573 35
a1607 1
  tools_mouse_to_pixel (window, mpos, &x, &y);
d1805 4
@


4.9
log
@Various bugfixes. Improve sprite info dialog.
Detail:
  - Handling of currently selected foreground & background colour rewritten; colour is now stored as a 'main_colour' struct, in order to allow representation of alpha level, pixel colour/palette index (which must be 4 bytes for things like CMYK) and ECF index (previously encoded as negative colour values). Fixes crashes when editing RISC OS 5 32bpp ARGB sprites. Note that although the alpha level is now stored internally, and tools should mostly respect it, palette/colour picker limitations mean that only 0/255 is available when selecting colours.
  - "Select colour" code rewritten to decode all the new pixel formats correctly; colours_entry() now accepts a sprite mode word instead of a number-of-colours value
  - "Full info" display tweaked to give more information about the mask (now displays no mask, normal mask, alpha mask, alpha channel)
  - Sprite info dialog extended to display lots more information, including OS version compatibility
  - Fix sprite menu to disallow add/remove mask option if the sprite has a RISC OS 5 alpha channel
  - Fix ECF pattern that's used for the background of masked sprites to get black/white colour values from ColourTrans when in >8bpp modes, to ensure correct colours in new RISC OS 5 modes
  - Fix palette window to render ECF patterns correctly - when creating the sprite that shows the ECF pattern in the palette, psprite_setup_ecf() was failing to set its palette due to passing a sprite pointer to ColourTrans but setting the flags as if it was a sprite name
  - Fix sprwindow_redisplay() and sprwindow_invalidate() to refresh the display correctly when in full info mode; was previously assuming only one column of sprites visible
  - Fix sprites with alpha channels to have the mask ECF pattern plotted in the background
  Files changed:
  - Resources/UK/Messages, Resources/UK/Templates,fec, c/Colours, c/Main, c/Menus, c/PSprite, c/SprWindow, c/Tools, h/Colours, h/MenuD, h/PSprite, h/main
Admin:
  Tested on BB-xM
  Amongst others, fixes issue reported on forums with spritefile window not refreshing correctly when in full info display with multiple columns:
  http://www.riscosopen.org/forum/forums/8/topics/2146?page=5#posts-31272


Version 2.16. Tagged as 'Paint-2_16'
@
text
@d71 1
a71 1
char        tools_spray_density [5] = "20";
d75 1
d2178 31
a2208 4
    int pxs, pys;
    tools_mouse_to_pixel (window, mpos, &x, &y);
    pxs=tools_pixel_to_point_x(&window->data->sprite, 1);
    pys=tools_pixel_to_point_y(&window->data->sprite, 1);
d2210 2
a2211 2
    colour = colours_pack_colour(sprite, gcol);
    mask = colours_pack_mask(sprite, gcol);
d2213 7
a2219 4
    sprite->toolspace [0] = x;
    sprite->toolspace [1] = y;
    ftracef2 ("0x%X->toolspace [0]: 0x%X\n",
        sprite, sprite->toolspace [0]);
d2221 2
a2222 2
    sid.s.addr = psprite_address (sprite);
    sid.tag = sprite_id_addr;
d2224 4
a2227 2
    dopix  = gcol.alpha || (psprite_transparency_type(sprite) == transparency_type_alphachannel);
    domask = psprite_hasmask (sprite);
d2229 2
a2230 4
    visdelay_begin ();
    for (i = 0; i < spraydensity; i++)
    { int r, nx, ny;
      double theta;
d2232 2
a2233 2
      /*nx = (myrnd () >> 24) % sprayradius;
      ny = (myrnd () >> 23) % sprayradius;*/
d2235 2
a2236 2
      /*nx = myrnd ()%sprayradius;
      ny = myrnd ()%sprayradius;*/
d2238 2
a2239 2
      r = myrnd ()%sprayradius;
      theta = fmod ((double) myrnd (), 2*3.1415926);
d2241 2
a2242 2
      nx = x + (int) (r*cos (theta))/pxs;
      ny = y + (int) (r*sin (theta))/pys;
d2244 5
a2248 2
      if (dopix)
      { sprite_colour newcolour = colour;
d2250 2
a2251 4
        MUNGE_PIXEL (nx, ny, &newcolour, &gcol, sarea, &sid, sprite)
        ftracef2 ("sprite_writepixel (GCOL 0x%X, TINT 0x%X)\n",
            newcolour.colour, newcolour.tint);
        sprite_writepixel (sarea, &sid, nx, ny, &newcolour);
d2253 1
a2253 5

      if (domask)
        sprite_writemask (sarea, &sid, nx, ny, &mask);
    }
    visdelay_end ();
d2256 4
a2259 4
    redraw_area.x0=tools_pixel_to_point_x(&window->data->sprite, x) - sprayradius;
    redraw_area.y0=tools_pixel_to_point_y(&window->data->sprite, y) - sprayradius;
    redraw_area.x1=tools_pixel_to_point_x(&window->data->sprite, x+1) + sprayradius + 1;
    redraw_area.y1=tools_pixel_to_point_y(&window->data->sprite, y+1) + sprayradius + 1;
d2261 2
a2262 1
    sprwindow_redisplay (sprite, &redraw_area);
d2305 1
d2307 3
@


4.8
log
@Sprite filer selection logic made consistent with filer
Specifically, in the filer when you menu click on a file it is temporarily selected. Clicking on a different file loses the first temporary selection and moves the highlight to the new file. This behaviour is skipped if there are already files selected (using left or right click).
This change makes !Paint behave this way too, previously the menu click was a permanent selection, so menu clicking elsewhere on a different sprite would actually manipulate the sprite selected some time earlier - very confusing.
Tidy ups
 * Remove hardwired mouse button bitmask operations, now uses defines from <wimp.h>.
 * Use OS_Byte numbers from header

Version 2.12. Tagged as 'Paint-2_12'
@
text
@d51 3
a53 3
#define MUNGE_PIXEL(x, y, c, sa, sp, sb) \
  { if (toolwindow_current_mode != 0 || (c)->colour < 0) \
      domungepixel (x, y, c, sa, sp, sb); \
d417 1
a417 2
    { int ncolours = colours_count (sprite);
      int gcol = sprite->gcol;
d424 2
a425 1
      if (gcol != ncolours)
d443 1
a443 1
      if (sprwindow_swap_output_to_mask (sprite, gcol != ncolours))
d446 1
a446 1
        colours_set_gcol (gcol != ncolours? 255: 0, 0, 0);
d550 1
a550 1
static void domungepixel (int x, int y, sprite_colour *c,
d555 1
a555 1
  if (c->colour < 0)
d557 1
a557 1
    sprite_area *sa = sb->ECFs [-c->colour - 1].sarea;
d610 2
a611 2
  int x, y, ncolours = colours_count (sprite),
    gcol = mpos->bbits == wimp_BRIGHT ? sprite->gcol2 : sprite->gcol;
d632 3
a634 1
    if (gcol != ncolours)       /* if not "transparent" */
d637 2
a638 9
      ftracef1 ("gcol 0x%X\n", gcol);
      if (gcol < 0 /*ECF*/ || ncolours != 256 || psprite_hastruecolpal (sprite))
      { colour.colour = gcol;
        colour.tint = 0 /*was -1 - an illegal value JRC 13th Feb 1995*/;
      }
      else
      { colour.colour = colours_gcol_ttab [gcol >> 2];
        colour.tint = (gcol & 3) << 6;
      }
d640 1
a640 1
      MUNGE_PIXEL (x, y, &colour, sarea, &sid, sprite)
d647 1
a647 2
    { sprite_maskstate mask =
          gcol == ncolours? sprite_masktransparent: sprite_masksolid;
d914 1
a914 2
        { int ncolours = colours_count (sprite);
          main_sprite_window *swind=&window->data->sprite;
d916 1
a916 1
          int gcol = sprite->gcol;
d921 3
a923 1
          if (gcol != ncolours)
d939 2
a940 2
          if (sprwindow_swap_output_to_mask (sprite, gcol != ncolours))
          { colours_set_gcol (gcol != ncolours? 255: 0, 0, 0);
d1120 2
a1121 3
        { int ncolours = colours_count (sprite);
          main_sprite_window *swind=&window->data->sprite;
          int gcol = sprite->gcol;
d1126 2
a1127 1
          if (gcol != ncolours)
d1137 2
a1138 2
          if (sprwindow_swap_output_to_mask (sprite, gcol != ncolours))
          { colours_set_gcol (gcol != ncolours? 255: 0, 0, 0);
d1183 3
a1185 3
    int x, y, nc = colours_count (sprite),
      gcol = mpos->bbits & 4? sprite->gcol: sprite->gcol2;
    BOOL to_transparent = gcol == nc, from_transparent;
d1298 1
a1298 6
        int sgc = gcol, st;

        if (mode8bpp && sgc > 0)
          st = sgc & 3, sgc = colours_gcol_ttab [sgc >> 2];
        else
          st = 0;
d1303 1
a1303 1
              sgc, col.colour, st, col.tint >> 6);
d1307 4
a1310 4
          (!( ( toolwindow_current_mode == 0? /*Set*/ sgc:
                toolwindow_current_mode == 1? /*OR*/  sgc | col.colour:
                toolwindow_current_mode == 2? /*AND*/ sgc & col.colour:
                toolwindow_current_mode == 3? /*EOR*/ sgc ^ col.colour: 0
d1312 4
a1315 4
              ( toolwindow_current_mode == 0? /*Set*/ st:
                toolwindow_current_mode == 1? /*OR*/  st | col.tint >> 6:
                toolwindow_current_mode == 2? /*AND*/ st & col.tint >> 6:
                toolwindow_current_mode == 3? /*EOR*/ st ^ col.tint >> 6: 0
d1351 1
a1351 1
            bbc_gcol (0, 128 | sgc), bbc_tint (3, st);
d1353 1
a1353 1
            os_swi2 (OS_SetColour, 1 << 4, sgc);
d1385 1
d1418 3
a1420 12
        ftracef2("was colour %d %d\n", col.colour, col.tint);
        if (nc != 256 || psprite_hastruecolpal (sprite))
           now.colour = col.colour;
        else
           now.colour =
              colours_gcol_ttab [colours_gcol_ttab [colours_gcol_ttab
              [col.colour]]] << 2 | col.tint >> 6;
              
        now.colour--;
        if (now.colour < 0) now.colour = now.colour +2;
        colours_set_sprite_gcol (now.colour, sprite, 0);
        ftracef2("now colour %d %d\n", now.colour, now.tint);
d2020 1
a2020 2
    int ncolours = colours_count (sprite);
    int gcol = mpos->bbits & wimp_BRIGHT? sprite->gcol2: sprite->gcol;
d2028 2
a2029 1
    if (gcol != ncolours)       /* if not "transparent" */
d2043 1
a2043 1
    if (sprwindow_swap_output_to_mask (sprite, gcol != ncolours))
d2045 1
a2045 1
      colours_set_gcol (gcol != ncolours? 255: 0, 0, 0);
d2169 1
a2169 2
  int ncolours = colours_count (sprite);
  int gcol = mpos->bbits == 1? sprite->gcol2: sprite->gcol;
d2182 2
a2183 8
    if (ncolours != 256 || psprite_hastruecolpal (sprite))
      colour.colour = gcol;
    else
    { colour.colour = colours_gcol_ttab [gcol >> 2];
      colour.tint = (gcol & 3) << 6;
    }

    mask = gcol == ncolours? sprite_masktransparent: sprite_masksolid;
d2193 1
a2193 1
    dopix  = gcol != ncolours;
d2216 1
a2216 1
        MUNGE_PIXEL (nx, ny, &newcolour, sarea, &sid, sprite)
d2341 1
a2341 1
          sprite->gcol == colours_count (sprite);
@


4.7
log
@Clean up pass.
No functional changes, but it's now a consistent ball of spaghetti.
@
text
@d32 1
d310 1
a310 1
  if ((mpos->bbits & 1) == 0)     /* has adjust been released? */
d611 1
a611 1
    gcol = mpos->bbits == 1? sprite->gcol2: sprite->gcol;
d819 1
a819 1
  if ((mpos->bbits & 1) == 0)     /* has adjust been released? */
d881 1
a881 1
    if (mpos->bbits & 1)   /* adjust: select a point and move it */
d1243 1
a1243 1
      wimpt_noerr (os_byte (229, (r1 = 0, &r1), (r2 = 0, &r2)));
d1286 1
a1286 1
      wimpt_noerr (os_byte (229, (r1 = 1, &r1), (r2 = 0, &r2)));
@


4.6
log
@Fix abort when sorting the sprites by name and one or more sprite viewers
are open, also massively simplified it since the copying around of
main_sprite blocks was pointless - much simpler to just rejoin the linked
list leaving the data in place.
*Tidy up
 Delete awk.*, change to use central 'AwkVers' script.
 Delete h.types.
 Delete h.Paint, it's a duplicate of h.main.
 Delete writepixel, swap to using the one in RISCOS_Lib
 Retire 'h.fixes', switches collapsed, bugfixes proven after 18 years use.
 Cast away some warnings.
 Sprinkled in some consts, moved pointer qualifiers to get syntax colouring
 right.
 Remove local SWI defines, read from <swis.h> now.
 !MkInstall now installs into <Install$Dir>.Apps
*Little UI changes
 Make the colour number in the colour picker be in the right place vertically
 and correct horizontal position of 'T' and 'E' for ECFs.
 In the create new sprite dialogue box the 32k and 16M options are shaded
 when a palette is requested, this avoids the problem of selecting a deep
 colour mode (which trapped the radio icon in a shaded paletted selection).
 The 'Selection' menu is now shaded when there are zero sprites in the
 file
*Sprite filer
 Fix tiled main window fill to work in EX0 modes and not overwrite in EX2
 modes (was using the sprite's mode word not the current mode to deduce eigen
 factors), leading to odd chequer board areas not being redrawn.
 Refactored main_clear_background() to use stronger typing of RISC_OSLib
 rather than _swix where possible.
 A failure to get the Wimp pixel translation table now falls back to solid
 fill
 Double clicking on a sprite in the sprite file window no longer leaves it
 selected, to mimic the filer.
 Set DISPLAY_MARGIN to 0 to counter for the recent increase from 32 to 40
 of main_FILER_TextHeight
 Added 'Sort by size' after 'Sort by name'

Version 2.02. Tagged as 'Paint-2_02'
@
text
@d208 1
a208 1
  wimpt_noerr (PaintLib_get_wind_info (&curr));
d214 1
a214 1
    int x=tools_extent_to_pixel_x(&window->data->sprite,mpos->x - curr.info.box.x0 + curr.info.scx);
d241 1
a241 1
  wimpt_noerr (PaintLib_get_wind_info (&curr));
d268 2
a269 2
     bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,coords [0]),
               y0 + tools_pixel_to_extent_centre_y(swind,coords [1]));
d274 2
a275 2
              x0 + tools_pixel_to_extent_centre_x(swind,coords [0]),
              y0 + tools_pixel_to_extent_centre_y(swind,coords [1]));
d292 1
a292 1
      tabledriven_drawEOR(swind,sprite->toolspace,x0,y0);
d342 1
a342 1
      tabledriven_drawEOR(&window->data->sprite,sprite->toolspace,x0,y0);
d407 2
a408 1
      } }
d433 2
a434 2
           bbc_move (tools_pixel_to_point_x(swind,coords [0]),
                     tools_pixel_to_point_y(swind,coords [1]));
d438 2
a439 2
                   tools_pixel_to_point_x(swind,x),
                   tools_pixel_to_point_y(swind,y));
d448 2
a449 2
        { bbc_move (tools_pixel_to_point_x(swind,coords [0]),
                    tools_pixel_to_point_y(swind,coords [1]));
d453 2
a454 2
                   tools_pixel_to_point_x(swind,x),
                   tools_pixel_to_point_y(swind,y));
d609 1
a609 1
  int x,y, ncolours = colours_count (sprite),
d658 4
a661 4
    redraw_area.x0=tools_pixel_to_point_x(&window->data->sprite,x);
    redraw_area.x1=tools_pixel_to_point_x(&window->data->sprite,x+1);
    redraw_area.y0=tools_pixel_to_point_y(&window->data->sprite,y);
    redraw_area.y1=tools_pixel_to_point_y(&window->data->sprite,y+1);
d742 1
a742 1
     int i,xa,ya,xb,yb;
d749 1
a749 1
        for (i=0;i<6;i+=2) {if (point[i]<xa) xa=point[i],ya=point[i+1];}
d752 1
a752 1
        for (i=0;i<6;i+=2) {if (point[i]>xb) xb=point[i],yb=point[i+1];}
d758 1
a758 1
        for (i=0;i<6;i+=2) {if (point[i+1]<ya) xa=point[i],ya=point[i+1];}
d761 1
a761 1
        for (i=0;i<6;i+=2) {if (point[i+1]>yb) xb=point[i],yb=point[i+1];}
d763 4
a766 4
     bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,xa),
               y0 + tools_pixel_to_extent_centre_y(swind,ya));
     bbc_draw (x0 + tools_pixel_to_extent_centre_x(swind,xb),
               y0 + tools_pixel_to_extent_centre_y(swind,yb));
d772 4
a775 4
    bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,point[0]),
              y0 + tools_pixel_to_extent_centre_y(swind,point[1]));
    bbc_draw (x0 + tools_pixel_to_extent_centre_x(swind,point[2]),
              y0 + tools_pixel_to_extent_centre_y(swind,point[3]));
d778 6
a783 6
    { bbc_draw (x0 + tools_pixel_to_extent_centre_x(swind,point[4]),
                y0 + tools_pixel_to_extent_centre_y(swind,point[5]));
      bbc_drawby (tools_pixel_to_extent_x(swind,point[0] - point[2]),
                  tools_pixel_to_extent_y(swind,point[1] - point[3]));
      bbc_draw (x0 + tools_pixel_to_extent_centre_x(swind,point[0]),
                y0 + tools_pixel_to_extent_centre_y(swind,point[1]));
d800 1
a800 1
      parallelogram_drawEOR(swind,sprite->toolspace,x0,y0);
d853 1
a853 1
    parallelogram_drawEOR(&window->data->sprite,window->data->sprite.sprite->toolspace,x0,y0);
d931 10
a940 10
            bbc_move (tools_pixel_to_point_x(swind,sprite->toolspace [2]),
                      tools_pixel_to_point_y(swind,sprite->toolspace [3]));
            bbc_draw (tools_pixel_to_point_x(swind,sprite->toolspace [4]),
                      tools_pixel_to_point_y(swind,sprite->toolspace [5]));
            bbc_draw (tools_pixel_to_point_x(swind,sprite->toolspace [6]), 
                      tools_pixel_to_point_y(swind,sprite->toolspace [7]));
            bbc_drawby (tools_pixel_to_point_x(swind,sprite->toolspace [2] - sprite->toolspace [4]),
                        tools_pixel_to_point_y(swind,sprite->toolspace [3] - sprite->toolspace [5]));
            bbc_draw (tools_pixel_to_point_x(swind,sprite->toolspace [2]),
                      tools_pixel_to_point_y(swind,sprite->toolspace [3]));
d946 10
a955 10
            bbc_move (tools_pixel_to_point_x(swind,sprite->toolspace [2]),
                      tools_pixel_to_point_y(swind,sprite->toolspace [3]));
            bbc_draw (tools_pixel_to_point_x(swind,sprite->toolspace [4]),
                      tools_pixel_to_point_y(swind,sprite->toolspace [5]));
            bbc_draw (tools_pixel_to_point_x(swind,sprite->toolspace [6]),
                      tools_pixel_to_point_y(swind,sprite->toolspace [7]));
            bbc_drawby (tools_pixel_to_point_x(swind,sprite->toolspace [2] - sprite->toolspace [4]),
                        tools_pixel_to_point_y(swind,sprite->toolspace [3] - sprite->toolspace [5]));
            bbc_draw (tools_pixel_to_point_x(swind,sprite->toolspace [2]),
                      tools_pixel_to_point_y(swind,sprite->toolspace [3]));
d977 1
a977 1
static void rectangle_drawEOR(main_sprite_window *swind, int *points,int x0, int y0)
d990 4
a993 4
    bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,points [0]),
              y0 + tools_pixel_to_extent_centre_y(swind,points [1]));
    bbc_drawby (tools_pixel_to_extent_x(swind,points [2] - points [0]),
                tools_pixel_to_extent_y(swind,points [3] - points [1]));
d996 4
a999 4
    bbc_rectangle (x0 + tools_pixel_to_extent_centre_x(swind,points [0]),
                   y0 + tools_pixel_to_extent_centre_y(swind,points [1]),
                   tools_pixel_to_extent_x(swind,points [2] - points [0]),
                   tools_pixel_to_extent_y(swind,points [3] - points [1]));
d1015 1
a1015 1
      rectangle_drawEOR(swind,&sprite->toolspace [coord],x0,y0);
d1066 1
a1066 1
    rectangle_drawEOR(&window->data->sprite,&sprite->toolspace [2],x0,y0);
d1135 4
a1138 4
            bbc_rectangle (tools_pixel_to_point_x(swind,sprite->toolspace [2]),
                           tools_pixel_to_point_y(swind,sprite->toolspace [3]),
                           tools_pixel_to_point_x(swind,sprite->toolspace [4] - sprite->toolspace [2]),
                           tools_pixel_to_point_y(swind,sprite->toolspace [5] - sprite->toolspace [3]));
d1144 4
a1147 4
            bbc_rectangle (tools_pixel_to_point_x(swind,sprite->toolspace [2]),
                           tools_pixel_to_point_y(swind,sprite->toolspace [3]),
                           tools_pixel_to_point_x(swind,sprite->toolspace [4] - sprite->toolspace [2]),
                           tools_pixel_to_point_y(swind,sprite->toolspace [5] - sprite->toolspace [3]));
d1228 2
a1229 2
      int sx = tools_pixel_to_point_x(&window->data->sprite,1);
      int sy = tools_pixel_to_point_y(&window->data->sprite,1);
d1295 2
a1296 2
      x=tools_pixel_to_point_x(&window->data->sprite,x);
      y=tools_pixel_to_point_y(&window->data->sprite,y);
d1338 1
a1338 1
            bbc_plot (bbc_FloodToBack | bbc_DrawAbsFore, x,y);
d1369 1
a1369 1
          bbc_plot (bbc_FloodToFore | bbc_DrawAbsFore, x,y);
d1379 1
a1379 1
           changing from transparent - no action required,flooding nothing with nothing leaves nothing
d1383 1
a1383 1
           Diff the resulting sprites,and for each changed pixel poke the mask with a
d1424 1
a1424 1
        /* Not really bothered what colour is locally filled with,so long as it's different
d1426 1
a1426 1
        ftracef2("was colour %d %d\n",col.colour,col.tint);
d1437 1
a1437 1
        ftracef2("now colour %d %d\n",now.colour,now.tint);
d1536 1
a1536 1
      x0 = tools_pixel_to_point_x(&window->data->sprite,sprite->toolspace [1]) &
d1539 1
a1539 1
      width = ((tools_pixel_to_point_x(&window->data->sprite,sprite->toolspace [3]) - x0) >> dx) + 2;
d1562 4
a1565 4
            tools_pixel_to_point_x(&window->data->sprite,sprite->toolspace [1]), 
            tools_pixel_to_point_y(&window->data->sprite,sprite->toolspace [2]),
            tools_pixel_to_point_x(&window->data->sprite,sprite->toolspace [3]), 
            tools_pixel_to_point_y(&window->data->sprite,sprite->toolspace [4]));
d1594 2
a1595 2
              &ssid, -tools_pixel_to_point_x(&window->data->sprite,sprite->toolspace [1]),
                     -tools_pixel_to_point_y(&window->data->sprite,sprite->toolspace [2]));
d1685 1
a1685 1
      rectangle_drawEOR(&window->data->sprite,&sprite->toolspace [1],x0,y0);
d1688 1
a1688 1
      rectangle_drawEOR(&window->data->sprite,&sprite->toolspace [5],x0,y0);
d1748 6
a1753 6
        bbc_move (tools_pixel_to_point_x(swind,sprite->toolspace [1]), 
                  tools_pixel_to_point_y(swind,sprite->toolspace [2]));
        bbc_move (tools_pixel_to_point_x(swind,sprite->toolspace [3]),
                  tools_pixel_to_point_y(swind,sprite->toolspace [4]));
        bbc_plot (bbc_Block + code, tools_pixel_to_point_x(swind,x),
                                    tools_pixel_to_point_y(swind,y));
d1757 6
a1762 6
          bbc_move (tools_pixel_to_point_x(swind,sprite->toolspace [1]), 
                    tools_pixel_to_point_y(swind,sprite->toolspace [2]));
          bbc_move (tools_pixel_to_point_x(swind,sprite->toolspace [3]),
                    tools_pixel_to_point_y(swind,sprite->toolspace [4]));
          bbc_plot (bbc_Block + code, tools_pixel_to_point_x(swind,x),
                                      tools_pixel_to_point_y(swind,y));
d1876 4
a1879 4
#if (1)
int  text_x;
int  text_y;
int  text_xs;
d1882 7
a1888 7
   text_x = bbc_vduvar (162);
   text_y = bbc_vduvar (163);
   text_xs = bbc_vduvar (164);

   sprintf (tools_text_xsize, "%d", text_x);
   sprintf (tools_text_ysize, "%d", text_y);
   sprintf (tools_text_xspace, "%d", text_xs);
d1928 3
a1930 3
  tx  = tools_pixel_to_extent_x(swind,textxsize)/swind->sprite->mode.scale_xdiv;
  txs = tools_pixel_to_extent_x(swind,textxspace)/swind->sprite->mode.scale_xdiv;
  ty  = tools_pixel_to_extent_y(swind,textysize)/swind->sprite->mode.scale_ydiv;
d1933 2
a1934 2
  x0 += tools_pixel_to_extent_x(swind,toolspace[3]-((strlen(curr_text_buffer)-1)*textxspace+textxsize)/2);
  y0 += tools_pixel_to_extent_y(swind,toolspace[4]+textysize/2+1)-1;
d1961 1
a1961 1
      text_drawEOR(swind,sprite->toolspace,x0,y0);
d2005 1
a2005 1
            sprite=sprite->link)
d2020 1
a2020 1
            sprite != NULL; sprite=sprite->link)
d2043 2
a2044 2
    x0 = tools_pixel_to_point_x(spritew,x0 - ((strlen (curr_text_buffer)-1)*textxspace + textxsize)/2);
    y1 = tools_pixel_to_point_y(spritew,y1 + textysize/2+1)-1;      
d2138 1
a2138 1
    text_drawEOR(swind,sprite->toolspace,x0,y0);
d2197 2
a2198 2
    pxs=tools_pixel_to_point_x(&window->data->sprite,1);
    pys=tools_pixel_to_point_y(&window->data->sprite,1);
d2252 4
a2255 4
    redraw_area.x0=tools_pixel_to_point_x(&window->data->sprite,x) - sprayradius;
    redraw_area.y0=tools_pixel_to_point_y(&window->data->sprite,y) - sprayradius;
    redraw_area.x1=tools_pixel_to_point_x(&window->data->sprite,x+1) + sprayradius + 1;
    redraw_area.y1=tools_pixel_to_point_y(&window->data->sprite,y+1) + sprayradius + 1;
d2288 2
a2289 1
} }
d2324 1
a2324 1
    int mul,div;
d2341 1
a2341 1
    x = tools_pixel_to_point_x(swind,sprite->toolspace [3]);
d2346 1
a2346 1
    y = tools_pixel_to_point_y(swind,sprite->toolspace [4]);
d2396 1
a2396 1
  int mul,div;
d2415 1
a2415 1
  x = tools_pixel_to_extent_x(swind,toolspace [3]);
d2420 1
a2420 1
  y = tools_pixel_to_extent_y(swind,toolspace [4]);
d2442 1
a2442 1
      brush_drawEOR(swind,sprite->toolspace,x0,y0);
d2528 1
a2528 1
        sprite=sprite->link)
d2548 1
a2548 1
      brush_drawEOR(swind,sprite->toolspace,x0,y0);
@


4.5
log
@Filename fixes for case-sensitive environments.  No functional changes.  First commit to ROOL CVS, hooray.

Version 2.00. Not tagged
@
text
@a47 1
#include "writepixel.h"
d123 1
a123 1
static int  tools_extent_to_pixel_x(const main_sprite_window* window,int x)
d131 1
a131 1
static int  tools_pixel_to_extent_x(const main_sprite_window* window,int x)
d139 1
a139 1
static int  tools_pixel_to_extent_centre_x(const main_sprite_window* window,int x)
d148 1
a148 1
static int  tools_extent_to_pixel_y(const main_sprite_window* window,int y)
d157 1
a157 1
static int  tools_pixel_to_extent_y(const main_sprite_window* window,int y)
d165 1
a165 1
static int  tools_pixel_to_extent_centre_y(const main_sprite_window* window,int y)
d174 1
a174 1
static int tools_pixel_to_point_x(const main_sprite_window* window,int x)
d180 1
a180 1
static int tools_pixel_to_point_y(const main_sprite_window* window,int y)
d186 1
a186 1
static void tools_get_sprite_info_pixels(main_sprite* sprite,sprite_info* sin)
d236 1
a236 1
static void sprite_update_window(main_sprite_window* swind,int* x0,int* y0,wimp_redrawstr* rds, int *more)
d255 1
a255 1
static void tabledriven_drawEOR(main_sprite_window* swind,int* toolspace,int x0, int y0)
d418 1
a418 1
      main_sprite_window* swind=&window->data->sprite;
d704 1
a704 1
static void parallelogram_drawEOR(main_sprite_window* swind,int* toolspace,int x0,int y0)
d708 1
a708 1
  int* point=&toolspace[2];
d919 1
a919 1
          main_sprite_window* swind=&window->data->sprite;
d976 1
a976 1
static void rectangle_drawEOR(main_sprite_window* swind,int* points,int x0, int y0)
d1124 1
a1124 1
          main_sprite_window* swind=&window->data->sprite;
d1737 1
a1737 1
        main_sprite_window* swind=&window->data->sprite;
d1923 1
a1923 1
static void text_drawEOR(main_sprite_window* swind,int* toolspace,int x0,int y0)
d2131 1
a2131 1
  main_sprite* sprite=window->data->sprite.sprite;
d2242 1
a2242 3
        (void) xosspriteop_write_pixel_colour (512, sarea, sid.s.addr, nx,
            ny, newcolour.colour, newcolour.tint); /*was 'sprite_writepixel
            (sarea, &sid, nx, ny, &newcolour);' JRC 5th Dec 1994*/
d2246 1
a2246 3
        (void) xosspriteop_write_pixel_mask (512, sarea, sid.s.addr, nx, ny,
            mask); /*was 'sprite_writemask (sarea, &sid, nx, ny, &mask);' JRC
            5th Dec 1994*/
d2323 1
a2323 1
    main_sprite_window* swind=&window->data->sprite;
d2388 1
a2388 1
static void brush_drawEOR(main_sprite_window* swind,int* toolspace,int x0, int y0)
@


4.4
log
@Fix to filename capitalisation clash for version 1.99.
Summary:
  Bugfix of version 1.98
Detail:
  * Show error message when dragging selection fails.
  * Sprite target area in spritefile window set to a minimum height
    of 64 units and minimum width of 64 units.
  * Moving brush now redrawn in the same place that it is updated.
  * Changed moving brush plotting from EOR to NOT to stop
    black in brushes not appearing.
  * Fixed situation where the moving text y position is different
    to plotted text y position at 1:1 scale.
  * Stopped text redrawing repeatedly at the same place. This makes
    single clicks when using EOR plotting always work as expected.
    (old bug)
  * fixed width of insert/delete display at 1:1 scale.
  * fixed ftrace calls left in from changes that cause the !Debug
    compilation to fail.
  * makefile: changed OBJSZ o.Paintlib and o.AltRename. Changed o. to  oz.
  * makefile: changed OBJSD o.Paintlib and o.AltRename. Changed o. to  od.
Admin:
 Tested on Iyonix RO5.10
 Programmer tested only.
Notes:
  Changed by Colin Granville

Version 1.99. Retagged as 'Paint-1_99'
@
text
@d41 6
a46 6
#include "psprite.h"
#include "sprwindow.h"
#include "toolwindow.h"
#include "tools.h"
#include "colours.h"
#include "menus.h"
@


4.3
log
@Fix to filename capitalisation clash for version 1.98.
Summary:
  Changes to SpriteFile window to allow selections and
  sprite edit window changed to improve positioning accuracy.
Detail:
  * Wimp_EScroll event added to make wheelmouse work.
  * Tool rubber banding now snaps to pixel centres making location easier.
  * flickering of box stopped in move (hand) tool.
  * Bottom left of sprites used in painting aligned with grid and sprite plotted
    directly under moving version.
  * Text painting now plots under the moving version of the text.
  * copy, move and hand tools cancel dragging with Adjust.
  * SpriteFile window changed to allow selections using Select,Adjust or Drag.
  * Alt-Select/Adjust on name allows renaming of sprite.
  * TAB moves rename icon to next sprite.
  * Shift TAB moves rename icon to previous sprite
  * Ctrl-Return renames sprite and moves the rename icon to the
    next sprite.
 V2 changes
  * Rubber band rectangular boxes with 0 width or height drawn as a
   line so they don't disappear.
  * Parallelogram rubber band where all the points are in line drawn
    as a line so they don't disappear.
Admin:
  Tested on Iyonix RO5.10
  Programmer tested only.
Changed by:
  Colin Granville

Version 1.98. Retagged as 'Paint-1_98'
@
text
@d231 20
d256 25
a288 10
    wimp_winfo curr;

    curr.w = swind->window->handle;
    wimpt_noerr (PaintLib_get_wind_info (&curr));
    rds.w = swind->window->handle;
    rds.box = main_big_extent;
    wimpt_noerr (wimp_update_wind (&rds, &more));

    x0 = rds.box.x0 - rds.scx;
    y0 = rds.box.y1 - rds.scy + curr.info.ex.y0;
d290 1
d292 2
a293 20
    { int i, *coords = &sprite->toolspace [2];

      os_swi2 (OS_SetColour, 3, -1);
    #if 0
      /*replaces the following, avoiding need to check full-palette bit*/
      bbc_gcol (3, 127);
      bbc_tint (2, 3); /*10 Sept 1991*/
    #endif

      for (i = sprite->toolspace [0] & 0xFF; i; i--)
      {
         bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,coords [0]),
                   y0 + tools_pixel_to_extent_centre_y(swind,coords [1]));
        coords += 2;
      }

      bbc_plot (((char *) sprite->toolspace [1]) [(sprite->toolspace [0] & 0xFF) - 1],
                  x0 + tools_pixel_to_extent_centre_x(swind,coords [0]),
                  y0 + tools_pixel_to_extent_centre_y(swind,coords [1]));

d343 1
a343 22
  { main_sprite_window *swind = &window->data->sprite;
    int i, *coords = &sprite->toolspace [2];

    os_swi2 (OS_SetColour, 3, -1);
  #if 0
    /*replaces the following, avoiding need to check full-palette bit*/
    bbc_gcol (3, 127);
    bbc_tint (2, 3); /*10 Sept 1991*/
  #endif

  for (i = sprite->toolspace [0] & 0xFF; i; i--)
  {
     bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,coords [0]),
               y0 + tools_pixel_to_extent_centre_y(swind,coords [1]));
    coords += 2;
  }

  bbc_plot (((char *) sprite->toolspace [1]) [(sprite->toolspace [0] & 0xFF) - 1],
              x0 + tools_pixel_to_extent_centre_x(swind,coords [0]),
              y0 + tools_pixel_to_extent_centre_y(swind,coords [1]));

  }
a795 11
    wimp_winfo curr;

    curr.w = swind->window->handle;
    wimpt_noerr (PaintLib_get_wind_info (&curr));
    rds.w = swind->window->handle;
    rds.box = main_big_extent;
    wimpt_noerr (wimp_update_wind (&rds, &more));

    x0 = rds.box.x0 - rds.scx;
    y0 = rds.box.y1 - rds.scy + curr.info.ex.y0;

d797 1
a852 1
  { 
a853 1
  }
d977 26
a1005 1
  int *points = &sprite->toolspace [coord];
a1010 10
    wimp_winfo curr;

    curr.w = swind->window->handle;
    wimpt_noerr (PaintLib_get_wind_info (&curr));
    rds.w = swind->window->handle;
    rds.box = main_big_extent;
    wimpt_noerr (wimp_update_wind (&rds, &more));

    x0 = rds.box.x0 - rds.scx;
    y0 = rds.box.y1 - rds.scy + curr.info.ex.y0;
d1012 1
d1014 2
a1015 22
    { os_swi2 (OS_SetColour, 3, -1);
    #if 0
      /*replaces the following, avoiding need to check full-palette bit*/
      bbc_gcol (3, 127);
      bbc_tint (2, 3); /*10 Sept 1991*/
    #endif



      if (points[0] == points[2] || points[1] == points[3])
      {
        bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,points [0]),
                  y0 + tools_pixel_to_extent_centre_y(swind,points [1]));
        bbc_drawby (tools_pixel_to_extent_x(swind,points [2] - points [0]),
                    tools_pixel_to_extent_y(swind,points [3] - points [1]));
      }
      else
        bbc_rectangle (x0 + tools_pixel_to_extent_centre_x(swind,points [0]),
                       y0 + tools_pixel_to_extent_centre_y(swind,points [1]),
                       tools_pixel_to_extent_x(swind,points [2] - points [0]),
                       tools_pixel_to_extent_y(swind,points [3] - points [1]));

d1066 1
a1066 22
  { main_sprite_window *swind = &window->data->sprite;
    int* point;
    os_swi2 (OS_SetColour, 3, -1);
  #if 0
    /*replaces the following, avoiding need to check full-palette bit*/
    bbc_gcol (3, 127);
    bbc_tint (2, 3); /*10 Sept 1991*/
  #endif
    point=&sprite->toolspace [2];
    if (point[0]==point[2] || point[1]==point[3])
    {
      bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,point [0]),
                 y0 + tools_pixel_to_extent_centre_y(swind,point [1]));
      bbc_drawby (tools_pixel_to_extent_x(swind,point [2] - point [0]),
                  tools_pixel_to_extent_y(swind,point [3] - point [1]));
    }
    else
      bbc_rectangle (x0 + tools_pixel_to_extent_centre_x(swind,point[0]),
                     y0 + tools_pixel_to_extent_centre_y(swind,point[1]),
                     tools_pixel_to_extent_x(swind,point[2] - point[0]),
                     tools_pixel_to_extent_y(swind,point[3] - point[1]));
  }
d1683 6
a1688 23
 { main_sprite_window *swind = &window->data->sprite;

  os_swi2 (OS_SetColour, 3, -1);
#if 0
  /*replaces the following, avoiding need to check full-palette bit*/
  bbc_gcol (3, 127);
  bbc_tint (2, 3); /*10 Sept 1991*/
#endif
  if (sprite->toolspace [0] != 3)
  {
    int* point=&sprite->toolspace [1];
    if (point[0]==point[2] || point[1]==point[3])
    {
      bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,point [0]),
                y0 + tools_pixel_to_extent_centre_y(swind,point [1]));
      bbc_drawby (tools_pixel_to_extent_x(swind,point [2] - point [0]),
                  tools_pixel_to_extent_y(swind,point [3] - point [1]));
    }
    else
      bbc_rectangle (x0 + tools_pixel_to_extent_centre_x(swind,point[0]),
                     y0 + tools_pixel_to_extent_centre_y(swind,point[1]),
                     tools_pixel_to_extent_x(swind,point[2] - point[0]),
                     tools_pixel_to_extent_y(swind,point[3] - point[1]));
a1689 18
   
  if (sprite->toolspace [0] >= 2)
  {
    int* point=&sprite->toolspace [5];
    if (point[0]==point[2] || point[1]==point[3])
    {
      bbc_move (x0 + tools_pixel_to_extent_centre_x(swind,point [0]),
                 y0 + tools_pixel_to_extent_centre_y(swind,point [1]));
      bbc_drawby (tools_pixel_to_extent_x(swind,point [2] - point [0]),
                  tools_pixel_to_extent_y(swind,point [3] - point [1]));
    }
    else
      bbc_rectangle (x0 + tools_pixel_to_extent_centre_x(swind,point[0]),
                     y0 + tools_pixel_to_extent_centre_y(swind,point[1]),
                     tools_pixel_to_extent_x(swind,point[2] - point[0]),
                     tools_pixel_to_extent_y(swind,point[3] - point[1]));
   }
 }
d1924 23
d1952 2
a1953 1
  { int more, x0, y1;
a1954 2
    wimp_winfo curr;
    int tx, ty, txs;
a1956 21
    curr.w = swind->window->handle;
    wimpt_noerr (PaintLib_get_wind_info (&curr));
    rds.w = swind->window->handle;
    rds.box = main_big_extent;
    wimpt_noerr (wimp_update_wind (&rds, &more));

    x0 = rds.box.x0 - rds.scx + tools_pixel_to_extent_x(swind,sprite->toolspace [3]);

    y1 = rds.box.y1 - rds.scy + curr.info.ex.y0 +
             tools_pixel_to_extent_y(swind,sprite->toolspace [4]);

    tx  =  textxsize*swind->blobsize.scale_xmul*sprite->mode.scale_xmul
        /swind->blobsize.scale_xdiv/sprite->mode.scale_xdiv;
    txs = textxspace*swind->blobsize.scale_xmul*sprite->mode.scale_xmul
        /swind->blobsize.scale_xdiv/sprite->mode.scale_xdiv;
    ty  =  textysize*swind->blobsize.scale_ymul*sprite->mode.scale_ymul
        /swind->blobsize.scale_ydiv/sprite->mode.scale_ydiv;

    set_text_size (tx, ty, txs);
    x0 -= ((strlen (curr_text_buffer) - 1)*txs + tx)*sprite->mode.scale_xdiv/2;
    y1 += sprite->mode.scale_ydiv*ty/2;
d1958 1
d1960 2
a1961 9
    { os_swi2 (OS_SetColour, 3, -1);
    #if 0
      /*replaces the following, avoiding need to check full-palette bit*/
      bbc_gcol (3, 127);
      bbc_tint (2, 3); /*10 Sept 1991*/
    #endif
      bbc_move (x0, y1);
      puts (curr_text_buffer);
      ftracef0 ("T!");
d2039 6
a2044 5
    x0=tools_pixel_to_point_x(spritew,x0);
    y1=tools_pixel_to_point_y(spritew,y1);
    x0 -= tools_pixel_to_point_x(spritew,(strlen (curr_text_buffer)-1)*textxspace + textxsize)/2;
    y1 += tools_pixel_to_point_y(spritew,textysize)/2;      
    y1 -= tools_pixel_to_point_y(spritew,1);
d2129 1
a2129 1
static void textredraw (main_window *window, int x, int y)
d2132 1
a2132 2
  main_sprite *sprite = swind->sprite;

d2138 1
a2138 24
  { int tx, ty, txs;
    tx  =  textxsize*swind->blobsize.scale_xmul*sprite->mode.scale_xmul
        /swind->blobsize.scale_xdiv/sprite->mode.scale_xdiv;
    txs = textxspace*swind->blobsize.scale_xmul*sprite->mode.scale_xmul
        /swind->blobsize.scale_xdiv/sprite->mode.scale_xdiv;
    ty  =  textysize*swind->blobsize.scale_ymul*sprite->mode.scale_ymul
        /swind->blobsize.scale_ydiv/sprite->mode.scale_ydiv;

    set_text_size (tx, ty, txs);
    x += tools_pixel_to_extent_x(swind,sprite->toolspace [3]);
    y += tools_pixel_to_extent_y(swind,sprite->toolspace [4]);
    x -= ((strlen (curr_text_buffer)-1)*txs + tx)*sprite->mode.scale_xdiv/2;
    y += sprite->mode.scale_ydiv*ty/2;

    os_swi2 (OS_SetColour, 3, -1);
  #if 0
    /*replaces the following, avoiding need to check full-palette bit*/
    bbc_gcol (3, 127);
    bbc_tint (2, 3); /*10 Sept 1991*/
  #endif
    bbc_move (x, y);
    puts (curr_text_buffer);
    restore_text_size ();
  }
d2393 12
a2404 1
static void brushEOR (main_sprite *sprite)
d2406 8
a2413 1
{ main_sprite_window *swind;
d2415 2
a2416 9
  ftracef0 ("brushEOR\n");
  for (swind = sprite->windows; swind != NULL; swind = swind->link)
  { int more, x, y;
    wimp_redrawstr rds;
    wimp_winfo curr;
    main_scaling_block scale;
    sprite_info sbi;
    sprite_id sid;
    int mul,div;
d2418 4
a2421 2
    sid.s.addr = psprite_address (tools_brushsprite_ptr);
    sid.tag = sprite_id_addr;
d2423 4
a2426 1
    sprite_readsize (tools_brushsprite_ptr->file->spritearea, &sid, &sbi);
a2427 14
    curr.w = swind->window->handle;
    wimpt_noerr (PaintLib_get_wind_info (&curr));
    rds.w = swind->window->handle;
    rds.box = main_big_extent;
    wimpt_noerr (wimp_update_wind (&rds, &more));
  
    scale.scale_xmul =
        tools_brushscale.scale_xmul*swind->blobsize.scale_xmul;
    scale.scale_xdiv =
        tools_brushscale.scale_xdiv*swind->blobsize.scale_xdiv;
    scale.scale_ymul =
        tools_brushscale.scale_ymul*swind->blobsize.scale_ymul;
    scale.scale_ydiv =
        tools_brushscale.scale_ydiv*swind->blobsize.scale_ydiv;
d2429 2
a2430 2
    /* find bottom left of brush. Pixel over pointer is aligned
       to pixel grid. */
d2432 1
a2432 5
    x = tools_pixel_to_extent_x(swind,sprite->toolspace [3]);
    mul=tools_brushsprite_ptr->mode.scale_xmul*tools_brushscale.scale_xmul;
    div=swind->sprite->mode.scale_xmul*tools_brushscale.scale_xdiv;
    x-=tools_pixel_to_extent_x(swind,(sbi.width*mul/div)/2);
    x+=(rds.box.x0 - rds.scx);
d2434 1
a2434 5
    y = tools_pixel_to_extent_y(swind,sprite->toolspace [4]);
    mul=tools_brushsprite_ptr->mode.scale_ymul*tools_brushscale.scale_ymul;
    div=swind->sprite->mode.scale_ymul*tools_brushscale.scale_ydiv;
    y -= tools_pixel_to_extent_y(swind,(sbi.height*mul/div)/2);
    y += (rds.box.y1 - rds.scy + curr.info.ex.y0);
d2436 7
d2445 1
a2445 1
      psprite_plot_scaled (x, y, tools_brushsprite_ptr, &scale, 3);
d2542 1
a2542 1
static void brushredraw (main_window *window, int x, int y)
d2550 2
a2551 32
    { main_scaling_block scale;
      int i;
      sprite_info sbi;
      sprite_id sid;
      int mul,div;

      sid.s.addr = psprite_address (tools_brushsprite_ptr);
      sid.tag = sprite_id_addr;

      sprite_readsize (tools_brushsprite_ptr->file->spritearea, &sid, &sbi);

      scale.scale_xmul = tools_brushscale.scale_xmul*swind->blobsize.scale_xmul;
      scale.scale_xdiv = tools_brushscale.scale_xdiv*swind->blobsize.scale_xdiv;
      scale.scale_ymul = tools_brushscale.scale_ymul*swind->blobsize.scale_ymul;
      scale.scale_ydiv = tools_brushscale.scale_ydiv*swind->blobsize.scale_ydiv;

      /* find bottom left of brush. Pixel over pointer is aligned
         to pixel grid. */

      i = tools_pixel_to_extent_x(swind,sprite->toolspace [3]);
      mul=tools_brushsprite_ptr->mode.scale_xmul*tools_brushscale.scale_xmul;
      div=swind->sprite->mode.scale_xmul*tools_brushscale.scale_xdiv;
      i-=tools_pixel_to_extent_x(swind,(sbi.width*mul/div)/2);
      x+=i;

      i = tools_pixel_to_extent_y(swind,sprite->toolspace [4]);
      mul=tools_brushsprite_ptr->mode.scale_ymul*tools_brushscale.scale_ymul;
      div=swind->sprite->mode.scale_ymul*tools_brushscale.scale_ydiv;
      i-=tools_pixel_to_extent_y(swind,(sbi.width*mul/div)/2);
      y+=i;

      psprite_plot_scaled (x,y,tools_brushsprite_ptr, &scale, 3);
@


4.2
log
@Deleted some junk from CVS.
On creating a new sprite (which is white) an attempt is made to select the
furthest colour from white in the palette.
Corrected icon shading in create dialogue,redid create template.
On closing a file the sprites are freed in reverse order in an attempt to
make it faster (as the blocks are flex'd in the other order) - will speed
up some situations.
When there are 0 sprites in a file the "Save" entry is greyed,this was
causing a internal error nasty looking error box before.
Tweak to allow the debug to be compiled again.
Filesize info box now used OS_ConvertFileSize as the display field
overflowed for files > 1M ish.
File info box made longer than 50 characters,that was a bit stingy.
Local flood fill with transparent mask added.
Reworded some of the messages.
Added "sort by name" to misc menu - sorts the sprites by name oddly enough.
The delete rows/columns now rounds up the grid coordinates,before there
were cases where you could never quite select the edge column/row,for
example a 79*98 sprites zoomed to x8 versus x7.

Version 1.96. Tagged as 'Paint-1_96'
@
text
@d49 1
a122 3
/**************************************************
 * Convert mouse pos to extent coordinates        *
 **************************************************/
d124 7
a130 5
void tools_mouse_to_extent_coords (main_window *window, wimp_mousestr *mpos,
                            int *cx, int *cy)
{ wimp_winfo curr;
  main_sprite_window *swind = &window->data->sprite;
  int x, y;
d132 7
a138 3
  ftracef0 ("tools_mouse_to_extent_coords\n");
  curr.w = window->handle;
  wimpt_noerr (wimp_get_wind_info (&curr));
d140 8
a147 10
  /* convert to work extent coordinates */
  x = mpos->x - curr.info.box.x0 + curr.info.scx;
  y = -curr.info.ex.y0 + curr.info.scy + mpos->y - curr.info.box.y1;
                             /* offset from bottom left of sprite */

  /* now convert to OS units from sprite bottom left */
  x *= swind->blobsize.scale_xdiv;
  x /= swind->blobsize.scale_xmul;
  y *= swind->blobsize.scale_ydiv;
  y /= swind->blobsize.scale_ymul;
d149 6
a154 2
  *cx = x;
  *cy = y;
a156 4
/********************************************************
 * Convert mouse pos to the row or column that it is in *
 *   (0 <= x < width, 0 <= y < height)                  *
 ********************************************************/
d158 7
a164 2
void tools_mouse_to_pixelpos (main_window *window, wimp_mousestr *mpos,
   int *cx, int *cy)
d166 8
a173 5
{ wimp_winfo curr;
  main_sprite_window *swind = &window->data->sprite;
  main_sprite *sprite = swind->sprite;
  int x, y, a, b;
  psprite_info sinfo;
d175 5
a179 2
  ftracef0 ("tools_mouse_to_pixelpos\n");
  psprite_read_full_info (sprite, &sinfo);
d181 5
a185 2
  curr.w = window->handle;
  wimpt_noerr (wimp_get_wind_info (&curr));
d187 6
a192 30
  /* convert to work extent coordinates */
  x = mpos->x - curr.info.box.x0 + curr.info.scx +1;
  y = mpos->y - curr.info.box.y1 + curr.info.scy - curr.info.ex.y0 +1;
      /*offset from bottom left of sprite*/
  ftracef2 ("in OSU, (x, y) = (%d, %d)\n", x, y);

  /* now convert to OS units from sprite bottom left */
  ftracef1 ("sprite mode word is 0x%X\n", sinfo.mode);
  ftracef3 ("for x, mul: div = %d: %d, shifted by %d\n",
    swind->blobsize.scale_xmul, swind->blobsize.scale_xdiv,
    bbc_modevar (sinfo.mode, bbc_XEigFactor));
  a = x*swind->blobsize.scale_xdiv;
  b = swind->blobsize.scale_xmul <<
        bbc_modevar (sinfo.mode, bbc_XEigFactor);
  x = a/b;

  ftracef3 ("for y, mul: div = %d: %d, shifted by %d\n",
    swind->blobsize.scale_ymul, swind->blobsize.scale_ydiv,
    bbc_modevar (sinfo.mode, bbc_YEigFactor));
  a = y*swind->blobsize.scale_ydiv;
  b = swind->blobsize.scale_ymul <<
        bbc_modevar (sinfo.mode, bbc_YEigFactor);
  y = a/b;

  /*Force row and column values to be within sprite*/
  ftracef2 ("giving (x, y) = (%d, %d)\n", x, y);
  if (x < 0) x = 0; else if (x > sinfo.width - 1) x = sinfo.width - 1;
  if (y < 0) y = 0; else if (y > sinfo.height - 1) y = sinfo.height - 1;

  *cx = x, *cy = y;
d195 4
a198 5
#if 0
/**************************************************
 * Convert mouse pos to nearest grid position     *
 *   (0 <= x <= width, 0 <= y <= height)          *
 **************************************************/
d200 7
a206 11
void tools_mouse_to_gridloc (main_window *window, wimp_mousestr *mpos,
  int *cx, int *cy)

{ wimp_winfo curr;
  main_sprite_window *swind = &window->data->sprite;
  main_sprite *sprite = swind->sprite;
  int x, y, a, b;
  psprite_info sinfo;

  ftracef0 ("tools_mouse_to_gridloc\n");
  psprite_read_full_info (sprite, &sinfo);
d209 21
a229 19
  wimpt_noerr (wimp_get_wind_info (&curr));

  /* convert to work extent coordinates */
  x = mpos->x - curr.info.box.x0 + curr.info.scx;
  y = mpos->y - curr.info.box.y1 + curr.info.scy - curr.info.ex.y0;
      /*offset from bottom left of sprite*/

  /* now convert to OS units from sprite bottom left */
  a = x*swind->blobsize.scale_xdiv;
  b = swind->blobsize.scale_xmul << bbc_modevar (sinfo.mode, bbc_XEigFactor);
  x = a/b;

  a = y*swind->blobsize.scale_ydiv;
  b = swind->blobsize.scale_ymul << bbc_modevar (sinfo.mode, bbc_YEigFactor);
  y = a/b;

  /*Force row and column values to be within sprite*/
  if (x < 0) x = 0; else if (x > sinfo.width)  x = sinfo.width;
  if (y < 0) y = 0; else if (y > sinfo.height) y = sinfo.height;
a230 3
  *cx = x, *cy = y;
}
#endif
d242 1
a242 1
  { int more, x0, y0, bxm, bxd, bym, byd;
d247 1
a247 1
    wimpt_noerr (wimp_get_wind_info (&curr));
a254 5
    bxm = swind->blobsize.scale_xmul;
    bxd = swind->blobsize.scale_xdiv;
    bym = swind->blobsize.scale_ymul;
    byd = swind->blobsize.scale_ydiv;

d266 3
a268 1
      { bbc_move (x0 + coords [0]*bxm/bxd, y0 + coords [1]*bym/byd);
d272 3
a274 2
      bbc_plot (((char *) sprite->toolspace [1]) [(sprite->toolspace [0] &
          0xFF) - 1], x0 + coords [0]*bxm/bxd, y0 + coords [1]*bym/byd);
d303 1
a303 1
  tools_mouse_to_extent_coords (window, mpos, &x, &y);
d326 1
a326 6
    int bxm, bxd, bym, byd, i, *coords = &sprite->toolspace [2];

    bxm = swind->blobsize.scale_xmul;
    bxd = swind->blobsize.scale_xdiv;
    bym = swind->blobsize.scale_ymul;
    byd = swind->blobsize.scale_ydiv;
d335 10
a344 4
    for (i = sprite->toolspace [0] & 0xFF; i; i--)
    { bbc_move (x0 + coords [0]*bxm/bxd, y0 + coords [1]*bym/byd);
      coords += 2;
    }
a345 2
    bbc_plot (((char *) sprite->toolspace [1]) [(sprite->toolspace [0] &
        0xFF) - 1], x0 + coords [0]*bxm/bxd, y0 + coords [1]*bym/byd);
d372 1
a372 1
    tools_mouse_to_extent_coords (window, mpos, &x, &y);
d422 1
d435 3
a437 1
        { bbc_move (coords [0], coords [1]);
d440 3
a442 1
        bbc_plot (table [sprite->toolspace [0] - 1], x, y);
d451 2
a452 1
        { bbc_move (coords [0], coords [1]);
d455 3
a457 1
        bbc_plot (table [sprite->toolspace [0] - 1], x, y);
a604 21
/* Coordinate conversion - mouse to pixel box */
/* Also yields multiplication factors */
static void tools_mouse_to_pixelbox (main_window *window,
    wimp_mousestr *mpos, wimp_box *pxb, int *pxs, int *pys)

{ int p_xs, p_ys;
  main_sprite *sprite = window->data->sprite.sprite;

  ftracef0 ("tools_mouse_to_pixelbox\n");
  tools_mouse_to_extent_coords (window, mpos, &pxb->x0, &pxb->y0);

  p_xs = sprite->mode.scale_xmul;
  p_ys = sprite->mode.scale_ymul;

  pxb->x0 = pxb->x0 & ~(p_xs - 1);
  pxb->y0 = pxb->y0 & ~(p_ys - 1);

  if (pxs) *pxs = p_xs;
  if (pys) *pys = p_ys;
}

d612 1
a612 2
  wimp_box pxb;
  int pxs, pys, ncolours = colours_count (sprite),
a617 9
  #if (1)
    tools_mouse_to_pixelbox (window, mpos, &pxb, &pxs, &pys);
  #else
    tools_mouse_to_extent_coords (window, mpos, &pxb.x0, &pxb.y0);
    pxs = sprite->mode.scale_xmul;
    pys = sprite->mode.scale_ymul;
    pxb.x0 = pxb.x0 & ~(pxs - 1);
    pxb.y0 = pxb.y0 & ~(pys - 1);
  #endif
d619 6
a624 3
  if (pxb.x0 != sprite->toolspace [0] || pxb.y0 != sprite->toolspace [1])
  { sprite_id sid;
    int x, y;
d627 2
a628 2
    sprite->toolspace [0] = pxb.x0;
    sprite->toolspace [1] = pxb.y0;
a632 2
    x = pxb.x0/pxs;
    y = pxb.y0/pys;
d660 5
a664 2
    pxb.x1 = pxb.x0 + pxs;
    pxb.y1 = pxb.y0 + pys;
d666 1
a666 1
    sprwindow_redisplay (sprite, &pxb);
d708 83
d797 1
a797 1
  { int more, x0, y0, bxm, bxd, bym, byd;
d802 1
a802 1
    wimpt_noerr (wimp_get_wind_info (&curr));
a809 4
    bxm = swind->blobsize.scale_xmul;
    bxd = swind->blobsize.scale_xdiv;
    bym = swind->blobsize.scale_ymul;
    byd = swind->blobsize.scale_ydiv;
d812 2
a813 21
    { os_swi2 (OS_SetColour, 3, -1);
    #if 0
      /*replaces the following, avoiding need to check full-palette bit*/
      bbc_gcol (3, 127);
      bbc_tint (2, 3); /*10 Sept 1991*/
    #endif

      bbc_move (x0 + sprite->toolspace [2]*bxm/bxd,
               y0 + sprite->toolspace [3]*bym/byd);
      bbc_draw (x0 + sprite->toolspace [4]*bxm/bxd,
               y0 + sprite->toolspace [5]*bym/byd);

      if ((sprite->toolspace [0] & 0xFF) == 2)
      { bbc_draw (x0 + sprite->toolspace [6]*bxm/bxd,
                 y0 + sprite->toolspace [7]*bym/byd);
        bbc_drawby ((sprite->toolspace [2] - sprite->toolspace [4])*bxm/bxd,
                   (sprite->toolspace [3] - sprite->toolspace [5])*bym/byd);
        bbc_draw (x0 + sprite->toolspace [2]*bxm/bxd,
                 y0 + sprite->toolspace [3]*bym/byd);
      }

d843 1
a843 1
 tools_mouse_to_extent_coords (window, mpos, &x, &y);
d866 2
a867 28
  { main_sprite_window *swind = &window->data->sprite;
    int bxm, bxd, bym, byd;

    bxm = swind->blobsize.scale_xmul;
    bxd = swind->blobsize.scale_xdiv;
    bym = swind->blobsize.scale_ymul;
    byd = swind->blobsize.scale_ydiv;

    os_swi2 (OS_SetColour, 3, -1);
  #if 0
    /*replaces the following, avoiding need to check full-palette bit*/
    bbc_gcol (3, 127);
    bbc_tint (2, 3); /*10 Sept 1991*/
  #endif

    bbc_move (x0 + sprite->toolspace [2]*bxm/bxd,
        y0 + sprite->toolspace [3]*bym/byd);
    bbc_draw (x0 + sprite->toolspace [4]*bxm/bxd,
        y0 + sprite->toolspace [5]*bym/byd);

    if ((sprite->toolspace [0] & 0xFF) == 2)
    { bbc_draw (x0 + sprite->toolspace [6]*bxm/bxd,
          y0 + sprite->toolspace [7]*bym/byd);
      bbc_drawby ((sprite->toolspace [2] - sprite->toolspace [4])*bxm/bxd,
          (sprite->toolspace [3] - sprite->toolspace [5])*bym/byd);
      bbc_draw (x0 + sprite->toolspace [2]*bxm/bxd,
          y0 + sprite->toolspace [3]*bym/byd);
    }
d893 1
a893 1
    tools_mouse_to_extent_coords (window, mpos, &x, &y);
d935 2
d946 10
a955 6
            bbc_move (sprite->toolspace [2], sprite->toolspace [3]);
            bbc_draw (sprite->toolspace [4], sprite->toolspace [5]);
            bbc_draw (sprite->toolspace [6], sprite->toolspace [7]);
            bbc_drawby (sprite->toolspace [2] - sprite->toolspace [4],
                       sprite->toolspace [3] - sprite->toolspace [5]);
            bbc_draw (sprite->toolspace [2], sprite->toolspace [3]);
d961 10
a970 6
            bbc_move (sprite->toolspace [2], sprite->toolspace [3]);
            bbc_draw (sprite->toolspace [4], sprite->toolspace [5]);
            bbc_draw (sprite->toolspace [6], sprite->toolspace [7]);
            bbc_drawby (sprite->toolspace [2] - sprite->toolspace [4],
                       sprite->toolspace [3] - sprite->toolspace [5]);
            bbc_draw (sprite->toolspace [2], sprite->toolspace [3]);
d999 1
a999 1
  { int more, x0, y0, bxm, bxd, bym, byd;
d1004 1
a1004 1
    wimpt_noerr (wimp_get_wind_info (&curr));
a1011 5
    bxm = swind->blobsize.scale_xmul;
    bxd = swind->blobsize.scale_xdiv;
    bym = swind->blobsize.scale_ymul;
    byd = swind->blobsize.scale_ydiv;

d1019 15
a1033 4
      bbc_rectangle (x0 + points [0]*bxm/bxd,
          y0 + points [1]*bym/byd,
          (points [2] - points [0])*bxm/bxd,
          (points [3] - points [1])*bym/byd);
d1062 1
a1062 1
 tools_mouse_to_extent_coords (window, mpos, &x, &y);
d1082 1
a1082 1

d1086 1
a1086 7
    int bxm, bxd, bym, byd;

    bxm = swind->blobsize.scale_xmul;
    bxd = swind->blobsize.scale_xdiv;
    bym = swind->blobsize.scale_ymul;
    byd = swind->blobsize.scale_ydiv;

d1093 13
a1105 4
    bbc_rectangle (x0 + sprite->toolspace [2]*bxm/bxd,
        y0 + sprite->toolspace [3]*bym/byd,
        (sprite->toolspace [4] - sprite->toolspace [2])*bxm/bxd,
        (sprite->toolspace [5] - sprite->toolspace [3])*bym/byd);
d1132 1
a1132 1
    tools_mouse_to_extent_coords (window, mpos, &x, &y);
d1165 1
d1175 4
a1178 3
            bbc_rectangle (sprite->toolspace [2], sprite->toolspace [3],
                         sprite->toolspace [4] - sprite->toolspace [2],
                         sprite->toolspace [5] - sprite->toolspace [3]);
d1184 4
a1187 3
            bbc_rectangle (sprite->toolspace [2], sprite->toolspace [3],
                         sprite->toolspace [4] - sprite->toolspace [2],
                         sprite->toolspace [5] - sprite->toolspace [3]);
d1227 1
a1227 1
    int x, y, pxs, pys, nc = colours_count (sprite),
a1228 1
    wimp_box pxb;
d1244 1
a1244 3
    tools_mouse_to_pixelbox (window, mpos, &pxb, &pxs, &pys);
    x = pxb.x0/pxs;
    y = pxb.y0/pys;
d1267 3
a1269 2
      int x, y, sx = sprite->mode.scale_xmul, sy = sprite->mode.scale_ymul,
          r1, r2;
d1287 2
a1288 1
      { visdelay_percent (y*100/sin.height);
d1334 4
a1337 2
      tools_mouse_to_extent_coords (window, mpos, &x, &y);
      ftracef2 ("Extent Coords: x %d, y %d\n", x, y);
d1378 1
a1378 1
            bbc_plot (bbc_FloodToBack | bbc_DrawAbsFore, x, y);
d1409 1
a1409 1
          bbc_plot (bbc_FloodToFore | bbc_DrawAbsFore, x, y);
d1432 1
a1432 1
        BOOL             hourglass = FALSE, created_sprite = FALSE, seenachange=FALSE, seenthisline;
d1550 1
a1550 1
  tools_mouse_to_extent_coords (window, mpos, &x, &y);
d1576 1
a1576 1
      x0 = sprite->toolspace [1] &
d1579 1
a1579 1
      width = (sprite->toolspace [3] - x0 >> dx) + 2;
a1581 1
      height >>= bbc_modevar (smode, bbc_YEigFactor);
d1602 4
a1605 2
            sprite->toolspace [1], sprite->toolspace [2],
            sprite->toolspace [3], sprite->toolspace [4]);
d1634 2
a1635 1
              &ssid, -sprite->toolspace [1], -sprite->toolspace [2]);
d1675 8
a1682 1
  { if (state != 3) rectangleEOR (sprite, 1);
d1684 1
a1723 6
  int bxm, bxd, bym, byd;

  bxm = swind->blobsize.scale_xmul;
  bxd = swind->blobsize.scale_xdiv;
  bym = swind->blobsize.scale_ymul;
  byd = swind->blobsize.scale_ydiv;
d1732 16
a1747 5
  bbc_rectangle (x0 + sprite->toolspace [1]*bxm/bxd,
                y0 + sprite->toolspace [2]*bym/byd,
                (sprite->toolspace [3] - sprite->toolspace [1])*bxm/bxd,
                (sprite->toolspace [4] - sprite->toolspace [2])*bym/byd);

d1749 15
a1763 4
    bbc_rectangle (x0 + sprite->toolspace [5]*bxm/bxd,
                  y0 + sprite->toolspace [6]*bym/byd,
                  (sprite->toolspace [7] - sprite->toolspace [5])*bxm/bxd,
                  (sprite->toolspace [8] - sprite->toolspace [6])*bym/byd);
d1790 2
a1791 1
  tools_mouse_to_extent_coords (window, mpos, &x, &y);
d1813 1
d1823 6
a1828 3
        bbc_move (sprite->toolspace [1], sprite->toolspace [2]);
        bbc_move (sprite->toolspace [3], sprite->toolspace [4]);
        bbc_plot (bbc_Block + code, x, y);
d1831 7
a1837 3
        { bbc_move (sprite->toolspace [1], sprite->toolspace [2]);
          bbc_move (sprite->toolspace [3], sprite->toolspace [4]);
          bbc_plot (bbc_Block + code, x, y);
d1864 7
d1877 7
d1892 7
d1904 1
a1904 1
      tools_mouse_to_extent_coords (window, mpos, &x, &y);
d1906 1
a1906 2
      psprite_read_size (sprite, &sid);

d1909 3
a1911 3
      sprite->toolspace [3] = sid.width;     /* box size */
      sprite->toolspace [4] = sid.height;
      sprite->toolspace [5] = 0;             /* curr rectangle */
d1913 2
a1914 2
      sprite->toolspace [7] = sid.width;
      sprite->toolspace [8] = sid.height;
d2011 1
a2011 1
    wimpt_noerr (wimp_get_wind_info (&curr));
d2016 4
a2019 7
    x0 = rds.box.x0 - rds.scx +
        sprite->toolspace [3]*swind->blobsize.scale_xmul/
        swind->blobsize.scale_xdiv;

    y1 = rds.box.y1 - rds.scy + curr.info.ex.y0  +
        sprite->toolspace [4]*swind->blobsize.scale_ymul/
        swind->blobsize.scale_ydiv;
d2108 1
a2108 1
{ int pxs, pys, x0, y1;
d2113 1
a2113 5
  tools_mouse_to_extent_coords (window, mpos, &x0, &y1);
  pxs = sprite->mode.scale_xmul;
  pys = sprite->mode.scale_ymul;
  x0 &= ~(pxs - 1);
  y1 &= ~(pys - 1);   /* set to pixels */
d2119 5
a2123 3

    x0 -= ((strlen (curr_text_buffer)-1)*textxspace + textxsize)*pxs/2;
    y1 += pys*textysize/2;      /* pointer points at centre of text */
d2177 1
a2177 3
    tools_mouse_to_extent_coords (window, mpos, &x, &y);
    x &= ~(sprite->mode.scale_xmul-1);
    y &= ~(sprite->mode.scale_ymul-1);  /* round to nearest pixel */
d2227 2
a2228 4
    x += sprite->toolspace [3]*swind->blobsize.scale_xmul
                           /swind->blobsize.scale_xdiv;
    y += sprite->toolspace [4]*swind->blobsize.scale_ymul
                           /swind->blobsize.scale_ydiv;
d2286 1
a2286 1
  int pxs, pys;
a2288 1
  wimp_box pxb;
d2297 5
a2301 5
  { tools_mouse_to_extent_coords (window, mpos, &pxb.x0, &pxb.y0);
    pxs = sprite->mode.scale_xmul;
    pys = sprite->mode.scale_ymul;
    pxb.x0 = pxb.x0 & ~(pxs - 1);
    pxb.y0 = pxb.y0 & ~(pys - 1);
d2312 2
a2313 2
    sprite->toolspace [0] = pxb.x0;
    sprite->toolspace [1] = pxb.y0;
a2322 2
    x = pxb.x0/pxs; y = pxb.y0/pys;

a2357 4
    pxb.x1 = pxb.x0 + sprayradius + 1 + pxs;
    pxb.x0 -= sprayradius + 1;
    pxb.y1 = pxb.y0 + sprayradius + 1 + pys;
    pxb.y0 -= sprayradius + 1;
d2359 6
a2364 1
    sprwindow_redisplay (sprite, &pxb);
d2419 1
a2419 1
  tools_mouse_to_extent_coords (window, mpos, &x, &y);
a2421 2
  x &= ~(sprite->mode.scale_xmul - 1);
  y &= ~(sprite->mode.scale_ymul - 1);  /* round down to nearest pixel */
d2428 9
d2446 11
d2462 1
a2462 1
      psprite_plot_scaled_centred (x, y, tools_brushsprite_ptr,
d2466 1
a2466 1
      psprite_plot_scaled_centred (x, y, tools_brushsprite_ptr,
d2481 1
a2481 1
      psprite_plot_scaled_centred (x, y,
d2508 1
d2516 1
a2516 1
    wimpt_noerr (wimp_get_wind_info (&curr));
d2520 1
a2520 16

    x = rds.box.x0 - rds.scx +
        sprite->toolspace [3]*swind->blobsize.scale_xmul
                          /swind->blobsize.scale_xdiv;
    /*if (sbi.width & 1)
    x -= sprite->mode.scale_xmul*swind->blobsize.scale_xmul
                            /swind->blobsize.scale_xdiv/2;
    Don't know what that was for, but it didn't. JRC 4th June 1991.*/

    y = rds.box.y1 - rds.scy + curr.info.ex.y0  +
        sprite->toolspace [4]*swind->blobsize.scale_ymul
                          /swind->blobsize.scale_ydiv;
    /*if (sbi.height & 1)
      y -= sprite->mode.scale_ymul*swind->blobsize.scale_ymul
                            /swind->blobsize.scale_ydiv/2; Ditto.*/

d2530 15
d2546 2
a2547 2
    { psprite_plot_scaled_centred (x, y, tools_brushsprite_ptr, &scale, 3,
          0);
d2588 1
a2588 3
      tools_mouse_to_extent_coords (window, mpos, &x, &y);
      x &= ~(sprite->mode.scale_xmul-1);
      y &= ~(sprite->mode.scale_ymul-1);  /* round down to nearest pixel */
a2646 1

d2653 9
d2668 16
a2683 7
      psprite_plot_scaled_centred
      ( x + sprite->toolspace [3]*swind->blobsize.scale_xmul/
            swind->blobsize.scale_xdiv,
        y + sprite->toolspace [4]*swind->blobsize.scale_ymul/
            swind->blobsize.scale_ydiv,
        tools_brushsprite_ptr, &scale, 3, 0
      );
@


4.1
log
@Initial revision
@
text
@d25 1
a25 4
 *
 *  Local flood fill to/from transparent not yet implemented.
 *
 *  JAB, 18 Oct 90 - Fixed bug in floodfill routine
d172 2
a173 2
  x = mpos->x - curr.info.box.x0 + curr.info.scx;
  y = mpos->y - curr.info.box.y1 + curr.info.scy - curr.info.ex.y0;
d197 1
a197 1
  if (x < 0) x = 0; else if (x > sinfo.width  - 1) x = sinfo.width  - 1;
d203 1
d244 1
d1189 1
a1189 1
volatile static sig_atomic_t Escape_Pressed;
d1248 3
a1250 1
    { int x, y, sx = sprite->mode.scale_xmul, sy = sprite->mode.scale_ymul,
a1255 1

d1299 2
a1300 2
          } }

d1303 2
a1304 2
      } }

d1311 3
a1313 2
    else /*Local fill*/
    { int x, y;
d1329 2
a1330 1
        { ftracef4 ("sgc %d, gcol %d, st %d, tint %d\n",
d1359 2
a1360 1
        } }
d1362 3
a1364 1
        { /*The plan is:
d1372 1
a1372 6
        #if 0
          /*no need for this bit*/
          if (nc <= 256)
            bbc_gcol (4, 128),  bbc_tint (3, 0);
          else
        #endif
d1386 1
a1386 6
        #if 0
          /*no need for this bit*/
          if (nc <= 256)
            bbc_gcol (4, 0), bbc_tint (2, 0);
          else
        #endif
a1389 5
        #if 0
          if (nc <= 256)
            bbc_gcol (4, 128), bbc_tint (3, 0);
          else
        #endif
d1392 2
a1393 1
      } }
d1395 106
a1500 3
      { /*Filling with transparent.*/
        werr (FALSE, msgs_lookup ("PntEL"));
    } }
a1501 1
    /*Set_Marked_Extent (sprite);*/
d1507 2
a1508 1
} }
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

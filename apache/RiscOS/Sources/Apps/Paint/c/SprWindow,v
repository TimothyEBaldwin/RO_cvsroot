head	4.9;
access;
symbols
	Paint-2_23-1:4.9
	Paint-2_23:4.9
	Paint-2_22:4.8
	Paint-2_21:4.8
	Paint-2_20:4.8
	Paint-2_19:4.8
	Paint-2_18:4.8
	Paint-2_17:4.8
	Paint-2_16:4.8
	Paint-2_15:4.7
	Paint-2_14:4.7
	Paint-2_13:4.7
	Paint-2_12:4.7
	Paint-2_11:4.7
	Paint-2_10:4.7
	Paint-2_09:4.7
	Paint-2_08:4.7
	Paint-2_07:4.7
	Paint-2_06:4.7
	Paint-2_05:4.7
	Paint-2_04:4.7
	Paint-2_03:4.6
	Paint-2_02:4.5
	Paint-2_01:4.4
	Paint-2_00:4.3
	Paint-1_99:4.3
	Paint-1_98:4.2
	Paint-1_97:4.1.1.1
	RO_5_07:4.1.1.1
	Paint-1_96:4.1.1.1
	Paint-1_95:4.1.1.1
	Paint-1_94:4.1.1.1
	Ursula_merge:4.1.1.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.1.1
	Ursula_RiscPC:4.1.1.1.0.6
	rthornb_UrsulaBuild-19Aug1998:4.1.1.1
	UrsulaBuild_FinalSoftload:4.1.1.1
	rthornb_UrsulaBuild-12Aug1998:4.1.1.1
	aglover_UrsulaBuild-05Aug1998:4.1.1.1
	rthornb_UrsulaBuild-29Jul1998:4.1.1.1
	rthornb_UrsulaBuild-22Jul1998:4.1.1.1
	rthornb_UrsulaBuild-15Jul1998:4.1.1.1
	rthornb_UrsulaBuild-07Jul1998:4.1.1.1
	rthornb_UrsulaBuild-17Jun1998:4.1.1.1
	rthornb_UrsulaBuild-10Jun1998:4.1.1.1
	rthornb_UrsulaBuild-03Jun1998:4.1.1.1
	rthornb_UrsulaBuild-27May1998:4.1.1.1
	rthornb_UrsulaBuild-21May1998:4.1.1.1
	rthornb_UrsulaBuild_01May1998:4.1.1.1
	Daytona:4.1.1.1.0.4
	Daytona_bp:4.1.1.1
	Ursula:4.1.1.1.0.2
	Ursula_bp:4.1.1.1
	RO_3_71:4.1.3.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2017.11.11.12.32.36;	author rool;	state Exp;
branches;
next	4.8;
commitid	7xcfho84RnWggCeA;

4.8
date	2014.03.27.23.18.34;	author jlee;	state Exp;
branches;
next	4.7;
commitid	zsqBYJ6Lrncsqoux;

4.7
date	2010.12.06.22.30.45;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2010.12.05.19.04.57;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2010.11.29.20.55.25;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2009.05.29.02.09.31;	author pnaulls;	state Exp;
branches;
next	4.3;

4.3
date	2008.06.05.13.06.07;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2008.06.05.12.56.40;	author bavison;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.20.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1;
next	;

4.1.1.1
date	96.11.05.09.20.10;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.28.23;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Add mousewheel zoom/scroll and auto scrolling of selected tools
Detail:
  The mouse wheel can now be used to
  * scroll up/down
  * +shift to scroll left/right
  * +control to zoom in/out
  on an open sprite editing window.
  The sprite editing window will auto scroll when the mouse approaches the border with
  * the move whole sprite "hand" tool
  * the copy block "camera" tool
  * the move block "scissors" tool
Admin:
  Submission for the Paint bounty.

Version 2.23. Tagged as 'Paint-2_23'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* SprWindow.c
 *
 *  Paint: Arthur 2 sprite editor
 *   Sprite window handling
 *
 *  Author: A.P. Thompson
 *
 * Upgraded to RISCOSlib - DAHE - 16 Aug 1989
 *  DAHE, 28 Aug 89 - internationalisation
 */

#include <swis.h>
#include "Global/FileTypes.h"
#include "Global/OsBytes.h"

#include "akbd.h"
#include "bbc.h"
#include "help.h"
#include "xferrecv.h"
#include "werr.h"
#include "wimpt.h"

#include "ftrace.h"
#include "m.h"
#include "main.h"
#include "Menus.h"
#include "PSprite.h"
#include "SprWindow.h"
#include "ToolWindow.h"
#include "Tools.h"
#include "Colours.h"
#include "PaintLib.h"

/**************************************************************************
 *                                                                        *
 *  Static variables.                                                     *
 *                                                                        *
 **************************************************************************/

main_template sprwindow_template;
static os_regset savedVDUstate;

/*int main_current_options.zoom.mul = 1;
int main_current_options.zoom.div = 1;
int main_current_options.grid.colour = 255;*/

static wimp_w lastnullholder = -1;
static int scrolltime = 0;

/***************************************
 *                                     *
 *  Set the extent of a file window.   *
 *                                     *
 ***************************************/

void sprwindow_set_work_extent (main_window *window, BOOL open)

{ /* The open parameter avoid getting two open requests in some circumstances */
  wimp_wstate currinfo;
  wimp_redrawstr newext;
  sprite_info sinfo;

  ftracef0 ("sprwindow_set_work_extent\n");
  wimpt_noerr (wimp_get_wind_state (window->handle, &currinfo));

  psprite_read_size (window->data->sprite.sprite, &sinfo);

  sinfo.width = sinfo.width * window->data->sprite.blobsize.scale_xmul /
                              window->data->sprite.blobsize.scale_xdiv;

  sinfo.height= sinfo.height * window->data->sprite.blobsize.scale_ymul /
                               window->data->sprite.blobsize.scale_ydiv;

  sinfo.width  &= ~((1 << bbc_modevar (-1, bbc_XEigFactor)) - 1);
  sinfo.height &= ~((1 << bbc_modevar (-1, bbc_YEigFactor)) - 1);

  newext.w      = window->handle;
  newext.box.y1 = 0;
  newext.box.y0 = -sinfo.height;
  newext.box.x0 = 0;
  newext.box.x1 = sinfo.width;

  ftracef2 ("Resetting sprite window extent to (%d, %d)\n",
      newext.box.x1, newext.box.y0);

  wimpt_noerr (wimp_set_extent (&newext));
  if (open) wimpt_noerr (wimp_open_wind (&currinfo.o)); /*force resize*/
  main_force_redraw (window->handle);
}

/****************************************************
 *                                                  *
 *  Scroll a sprite window at the specified speeds. *
 *                                                  *
 ****************************************************/

void sprwindow_scroll (main_window *window, int scrollx, int scrolly)

{ wimp_wstate currinfo;
  ftracef0 ("sprwindow_scroll\n");  
  
  int oldscrollx = scrollx;
  int oldscrolly = scrolly;
  int elapsed;
  
  /* Adjust scrolling speed according to CPU speed */
  os_swix1r(OS_ReadMonotonicTime, 0, &elapsed);
    
  if (scrolltime > 0)
  { elapsed -= scrolltime;
    /* Divide these by a bigger constant to slow down the scroll rate */
    scrollx = (scrollx * elapsed) / 3;
    scrolly = (scrolly * elapsed) / 3;
    /* The scrolling will only go ahead when enough time's passed to scroll in every direction requested */
    /* The elapsed >= 8 clause is like a frame rate cap to avoid excess CPU load and flicker */
    if (!((scrollx || scrolly) && elapsed >= 8  && (scrollx || !oldscrollx) && (scrolly || !oldscrolly)))
    { /* Do nothing until more time has elapsed */
      return;
    }
  }
  else
  { scrolltime = elapsed;
    /* Do nothing until more time has elapsed */
    return;
  }
  
  wimpt_noerr (wimp_get_wind_state (window->handle, &currinfo));

  int oldx = currinfo.o.x;
  int oldy = currinfo.o.y;

  /* Apply the scrolling */
  currinfo.o.x += scrollx;
  currinfo.o.y += scrolly;
  ftracef3 ("scrollx: %d oldx: %d currinfo.o.x: %d\n", scrollx, oldx, currinfo.o.x);
  ftracef3 ("scrolly: %d oldy: %d currinfo.o.y: %d\n", scrolly, oldy, currinfo.o.y);

  wimpt_noerr (wimp_open_wind (&currinfo.o)); /* force resize */
  /* Find out how much the window really scrolled by */
  wimpt_noerr (wimp_get_wind_state (window->handle, &currinfo));
  scrollx = (currinfo.o.x - oldx) / window->data->sprite.sprite->mode.scale_xmul;
  scrolly = (currinfo.o.y - oldy) / window->data->sprite.sprite->mode.scale_ymul;
  if (scrollx || scrolly)
  { /* Reset the timer */
    scrolltime += elapsed;   
  }
}

/***********************************************************
 *                                                         *
 *  Stop the auto-scroll timer used in sprwindow_scroll () *
 *                                                         *
 ***********************************************************/

void sprwindow_stop_scroll (void)
{ scrolltime = 0;
}

/******************************************************
 * Reset the titles of all windows open on the sprite *
 ******************************************************/

void sprwindow_set_window_titles (main_sprite *sprite)

{ char newname[20];
  int nviews = 0;
  main_sprite_window *sprwind;

  ftracef0 ("sprwindow_set_window_titles\n");
  for (sprwind = sprite->windows; sprwind != NULL; sprwind = sprwind->link)
    nviews++;
  sprintf (newname, "%.12s", psprite_address (sprite)->name);
  if (nviews != 1) sprintf (newname+strlen (newname), " %d", nviews);
  ftracef2 ("%d views; name is \"%.12s\"\n", nviews,
      psprite_address (sprite)->name);

  for (sprwind = sprite->windows; sprwind != NULL; sprwind = sprwind->link)
  { main_window *window = sprwind->window;
    wimp_wstate currinfo;
    wimp_redrawstr r;

    strcpy (sprwind->title, newname);
    wimpt_noerr (wimp_get_wind_state (window->handle, &currinfo));
    r.w = window->handle;
    wimp_getwindowoutline (&r);

    r.w = -1;
    r.box.y0 = currinfo.o.box.y1;
    wimp_force_redraw (&r);
  }
  ftracef0 ("sprwindow_set_window_titles done\n");
}

/***************************************
 *                                     *
 *  Swap VDU output to given sprite.   *
 *                                     *
 ***************************************/

void sprwindow_swap_output_to_sprite (main_sprite *sprite)

{ ftracef0 ("sprwindow_swap_output_to_sprite\n");
  savedVDUstate.r[0] = 0x23C;
  savedVDUstate.r[1] = (int) sprite->file->spritearea;
  savedVDUstate.r[2] = (int) psprite_address (sprite);
  savedVDUstate.r[3] = 0;
  wimpt_complain (os_swix (OS_SpriteOp, &savedVDUstate));
  os_swi1 (OS_ChangedBox, 2);
  os_swi1 (OS_ChangedBox, 1); /*enable changed box calcs*/
}

/***************************************
 *                                     *
 *  Remove wastage from a sprite       *
 *                                     *
 ***************************************/

void sprwindow_remove_wastage (main_sprite *sprite)

{ sprite_id id;

  ftracef0 ("sprwindow_remove_wastage\n");
  id.tag = sprite_id_addr;
  id.s.addr = psprite_address (sprite);
  wimpt_complain (sprite_removewastage (sprite->file->spritearea, &id));
}

/**********************************************
 *                                            *
 *  Swap VDU output to given sprite's mask.   *
 *                                            *
 **********************************************/

int sprwindow_swap_output_to_mask (main_sprite *sprite, int statesaved)

{ ftracef0 ("sprwindow_swap_output_to_mask\n");
  if (psprite_hasmask (sprite))
  { os_regset  regs;
    os_regset *state = statesaved ? &regs : &savedVDUstate;

    state->r[0] = 0x23D;
    state->r[1] = (int) sprite->file->spritearea;
    state->r[2] = (int) psprite_address (sprite);
    state->r[3] = 0;
    wimpt_complain (os_swix (OS_SpriteOp, state));
    os_swix1 (OS_ChangedBox, 2);
    os_swix1 (OS_ChangedBox, 1);          /* enable changed box calcs */
    return 1;
  }
  else return 0;
}

/********************************
 *                              *
 *  restore VDU output state.   *
 *                              *
 ********************************/

void sprwindow_swap_output_to_screen (void)

{ ftracef0 ("sprwindow_swap_output_to_screen\n");
  wimpt_complain (os_swix (OS_SpriteOp, &savedVDUstate));
}

/**************************************************
 *                                                *
 * Force redraw of all copies of sprite on screen *
 *                                                *
 **************************************************/

void sprwindow_redisplay (main_sprite *sprite, wimp_box *area)

{ main_sprite_window *window;
  wimp_winfo curr;
  wimp_redrawstr redraw;
  int filersprite_x, filersprite_y;

  ftracef0 ("sprwindow_redisplay\n");
  for (window = sprite->windows; window != NULL; window = window->link)
  { curr.w = window->window->handle;
    wimpt_noerr (paintlib_get_wind_info (&curr));

    if (area != NULL)
    { redraw.box.x0 = area->x0*window->blobsize.scale_xmul/
          window->blobsize.scale_xdiv;
      redraw.box.y0 = curr.info.ex.y0 +
          area->y0*window->blobsize.scale_ymul/window->blobsize.scale_ydiv;
      redraw.box.x1 = area->x1*window->blobsize.scale_xmul/
          window->blobsize.scale_xdiv;
      redraw.box.y1 = curr.info.ex.y0 +
          area->y1*window->blobsize.scale_ymul/window->blobsize.scale_ydiv;
    }
    else
      redraw.box = main_big_extent;

    redraw.w = window->window->handle;

    ftracef5 ("forcing redraw of window 0x%X, ((%d, %d), (%d, %d))\n",
        redraw.w, redraw.box.x0, redraw.box.y0,
        redraw.box.x1, redraw.box.y1);
    wimpt_noerr (wimp_force_redraw (&redraw));
  }

  /* now invalidate area in filer window */
  curr.w = sprite->file->window->handle;
  wimpt_noerr (paintlib_get_wind_info (&curr));

  int w, h, iconwidth, iconheight;
  if (sprite->file->fullinfo)
  {
    w = main_FILER_FullInfoWidth;
    h = main_FILER_FullInfoHeight;
    iconwidth = iconheight = 3*main_FILER_TextHeight-main_FILER_Border;
  }
  else
  {
    w = main_FILER_TotalWidth;
    h = main_FILER_TotalHeight;
    iconwidth = main_FILER_XSize;
    iconheight = main_FILER_YSize;
  }
  filersprite_x = curr.info.box.x1-curr.info.box.x0;
  if (filersprite_x < w)
    filersprite_x = w;
  filersprite_x /= w;  /* no of sprites per line */

  filersprite_y = sprite->spriteno/filersprite_x;
  filersprite_x = sprite->spriteno % filersprite_x;

  redraw.box.x0 = filersprite_x*w + main_FILER_Border/2;
  redraw.box.x1 = redraw.box.x0+iconwidth;
  redraw.box.y1 = -(filersprite_y*h + main_FILER_Border/2);
  redraw.box.y0 = redraw.box.y1-iconheight;

  redraw.w = curr.w;

  wimpt_noerr (wimp_force_redraw (&redraw));
}

void sprwindow_invalidate (main_sprite *sprite)

{ ftracef0 ("sprwindow_invalidate\n");
  if (sprite->file->fullinfo)
  { wimp_redrawstr redraw;
    int filersprite_x, filersprite_y;
    wimp_winfo curr;
    int w = main_FILER_FullInfoWidth;
    int h = main_FILER_FullInfoHeight;

    curr.w = sprite->file->window->handle;
    wimpt_noerr (paintlib_get_wind_info (&curr));

    filersprite_x = curr.info.box.x1-curr.info.box.x0;
    if (filersprite_x < w)
      filersprite_x = w;
    filersprite_x /= w;  /* no of sprites per line */
  
    filersprite_y = sprite->spriteno/filersprite_x;
    filersprite_x = sprite->spriteno % filersprite_x;

    redraw.box.x0 = filersprite_x*w;
    redraw.box.x1 = redraw.box.x0 + w;
    redraw.box.y1 = -filersprite_y*h;
    redraw.box.y0 = redraw.box.y1 - h;
    redraw.w = sprite->file->window->handle;

    wimpt_noerr (wimp_force_redraw (&redraw));
  }
}

/**********************************************************************
 *                                                                    *
 *  Window event handler for sprite windows.                          *
 *                                                                    *
 **********************************************************************/

void sprwindow_claim_idle_events (main_window *window)

{ ftracef0 ("sprwindow_claim_idle_events\n");
  window->data->sprite.sprite->needsnull = 1;
  lastnullholder = win_idle_event_claimer ();

  main_claim_idle (window->handle);
}

void sprwindow_release_idle_events (main_sprite *sprite)

{ main_sprite_window *list;
  wimp_w claimer = win_idle_event_claimer ();

  ftracef0 ("sprwindow_release_idle_events\n");
  sprite->needsnull = 0;

  for (list = sprite->windows; list != NULL; list = list->link)
    if (list->window->handle == claimer)
    { main_claim_idle (lastnullholder);
      break;
    }
  /* Reset the timer used in window auto-scrolling */
  sprwindow_stop_scroll ();
}

static BOOL cant_extend_stack_buffer (char **b, int *s)

{ ftracef0 ("cant_extend_stack_buffer\n");
  b = b; s = s;
  werr (FALSE, msgs_lookup ("PntE1"));
  return 0;
}

static BOOL check_palette_type (int type, char *name)

{ ftracef0 ("check_palette_type\n");
  if (type != FileType_Palette && type != -1)
  { werr (FALSE, msgs_lookup (name == NULL? "PntE2": "PntE3"), name);
    return FALSE;
  }
  return type == FileType_Palette;
}

void sprwindow_event_handler (wimp_eventstr *e, void *handle)

{ main_window *window = (main_window *) handle;
  BOOL read_only = window->data->sprite.read_only;
  int isMouseWheel = 1;

  ftracef3
      ("sprwindow_event_handler: event type %d, main_window 0x%X, w 0x%X\n",
      e->e, window, window->handle);

  switch (e->e)
  { case wimp_ENULL:
    if (!read_only)
    { wimp_mousestr mouse;
      wimpt_noerr (wimp_get_point_info (&mouse));

      ftracef2 ("mouse located at w 0x%X, i 0x%X\n", mouse.w, mouse.i);
      if (mouse.w == window->handle && mouse.i == -1)
        toolwindow_current_tool->null_action (window, &mouse);
    }
    break;

    case wimp_EOPEN:
      wimpt_complain (wimp_open_wind (&e->data.o));
    break;

    case wimp_EREDRAW:
    { int more, x, y, gridcol = window->data->sprite.gridcol;
      wimp_redrawstr rds;
      wimp_winfo curr;
      main_scaling_block *scale = &window->data->sprite.blobsize;
      main_sprite *sprite = window->data->sprite.sprite;
      sprite_info sinfo;

      psprite_read_size (sprite, &sinfo);

      sinfo.width  = sinfo.width * scale->scale_xmul/scale->scale_xdiv;
      sinfo.height = sinfo.height * scale->scale_ymul/scale->scale_ydiv;

      rds.w = e->data.o.w;
      wimpt_noerr (wimp_redraw_wind (&rds, &more));

      curr.w = e->data.o.w;
      wimpt_noerr (paintlib_get_wind_info (&curr));

      /*Screen coords of work area origin*/
      x = rds.box.x0 - rds.scx;
      y = rds.box.y1 - rds.scy + curr.info.ex.y0;

      /*redraw is replot sprite at current scale, at bottom left of extent
        plus redrawing of any tool lines currently active */

      if (gridcol == 255) gridcol = 256;
        /*we know this will wrap conveniently */

      while (more)
      { wimp_setcolour (gridcol | 1 << 7); /*Fix G-RO-9612 JRC 21 Nov '91
            Fill the background with gridcolour, not white.*/
        /*bbc_rectanglefill (x, y, curr.info.ex.x1 - curr.info.ex.x0,
            curr.info.ex.y1 - curr.info.ex.y0);*/
        bbc_clg (); /*JRC*/

        /*Fill in the mask E C F.*/
        if (psprite_transparency_type (sprite) != transparency_type_none)
        { int x0, y0, x1, y1;

          psprite_ecf (0);

          /*Clipping rectangle is (rds.g.x0, rds.g.y0, rds.g.x1, rds.g.y1);
            sprite location is (x, y, x + sinfo.width, y + sinfo.height). To
            fix MED-xxxx, we must get the intersecting box. JRC 7th Dec
            1994*/
          x0 = MAX (x, rds.g.x0);
          y0 = MAX (y, rds.g.y0);
          x1 = MIN (rds.g.x1, x + sinfo.width);
          y1 = MIN (rds.g.y1, y + sinfo.height);
          if (x0 < x1 && y0 < y1)
          {  ftracef4 ("bbc_rectanglefill (%d, %d, %d, %d)\n",
                 x0, y0, x1 - x0 - 1, y1 - y0 - 1);
              bbc_rectanglefill (x0, y0, x1 - x0, y1 - y0);
          }
        }

        wimpt_noerr (psprite_plot_scaled (x, y, sprite, scale, 0));

        if (gridcol != 256 &&
            sprite->mode.scale_xmul*scale->scale_xmul >=
              sprwindow_MIN_GRID*sprite->mode.scale_xdiv*scale->scale_xdiv &&
            sprite->mode.scale_ymul*scale->scale_ymul >=
              sprwindow_MIN_GRID*sprite->mode.scale_ydiv*scale->scale_ydiv)
        { int p, pr, g, gr, rlim, d, n;

          wimp_setcolour (gridcol);

          /*calculate the pixel dimension in integer & fractional parts*/
          rlim = scale->scale_xdiv;
          pr   = sprite->mode.scale_xmul*scale->scale_xmul;
          p    = pr/rlim;
          d    = rds.g.x0 - x;           /* distance from edge of sprite */
          n    = d*rlim/pr;              /* number of pixels from edge */
          pr   = pr - p*rlim;
          /* pixel size is p+pr/rlim; now calculate where to start */
          gr = n*pr%rlim;

          for (g = x + n*p + n*pr/rlim; g <= rds.g.x1; g += p)
          { bbc_move (g, rds.g.y0);
            bbc_draw (g, rds.g.y1);
            gr += pr; if (gr >= rlim) { g++; gr -= rlim; }
          }

          rlim = scale->scale_ydiv;
          pr   = sprite->mode.scale_ymul * scale->scale_ymul;
          p    = pr/rlim;
          d    = rds.g.y0 - y;
          n    = d*rlim/pr;
          pr   = pr - p*rlim;
          gr   = n*pr%rlim;

          for (g = y + n*p + n*pr/rlim; g <= rds.g.y1; g += p)
          { bbc_move (rds.g.x0, g);
            bbc_draw (rds.g.x1, g);
            gr += pr;
            if (gr >= rlim)
            { g++;
              gr -= rlim;
            }
          }
        }

        if (!read_only)
          toolwindow_current_tool->redraw_action (window, x, y);
        wimpt_noerr (wimp_get_rectangle (&rds, &more));
      }
    }
    break;

    case wimp_EBUT:
      if (!read_only)
        toolwindow_current_tool->click_action (window, &e->data.but.m);
    break;

    case wimp_EKEY:
      wimp_processkey (e->data.key.chcode);
    break;

    case wimp_ESCROLL: /* Support for mousewheel to scroll and zoom */
      ftracef2("wimp_ESCROLL in sprite window. scroll.x: %d scroll.y: %d\n", e->data.scroll.x, e->data.scroll.y);
      /* Workaround for RISC OS 5 mousewheel behaviour (5 scroll events sent per wheel step) */
      static int eventCount = -1;
      static int scrollFix = 0;
      wimp_mousestr mouse;
      wimpt_noerr (wimp_get_point_info (&mouse));
      /* If the pointer is over the scroll bar / buttons and select / adjust clicked, don't skip any scroll events. */
      if (((mouse.bbits & wimp_BRIGHT) || (mouse.bbits & wimp_BLEFT)) &&
          ((mouse.i <= -6 && mouse.i >= -8) || (mouse.i <= -10 && mouse.i >= -12)))
      { ftracef0("Mouse is over vertical scroll bar / buttons. Scroll fix inactive.\n");
        if (eventCount > 0)
          eventCount = 0;
        isMouseWheel = 0;
      }

      if (eventCount <= 0 && (e->data.scroll.x || e->data.scroll.y))
      { /*Read keyboard state.*/
        int r1 = 0;
        int r2 = 255;
        if (isMouseWheel)
          os_byte (OsByte_RW_KeybStatus, &r1, &r2);
        /*If Ctrl pressed, adjust the zoom level*/
        if (r1 & 0x40)
        { if (e->data.scroll.y == -1)
          { /* Zoom out */
            if (window->data->sprite.blobsize.scale_xmul > 1)
              window->data->sprite.blobsize.scale_xmul--;
            else if (window->data->sprite.blobsize.scale_xdiv < 999)
              window->data->sprite.blobsize.scale_xdiv++;
            menus_showmag (&window->data->sprite);
          }
          else if (e->data.scroll.y == 1)
          { /* Zoom in */
            if (window->data->sprite.blobsize.scale_xdiv > 1)
              window->data->sprite.blobsize.scale_xdiv--;
            else if (window->data->sprite.blobsize.scale_xmul < 999)
              window->data->sprite.blobsize.scale_xmul++;
            menus_showmag (&window->data->sprite);
          }
        }
        else
        { /*If Shift pressed, scroll horizontally with mousewheel*/
          if ((r1 & 8) && e->data.scroll.y)
          { e->data.scroll.x = -e->data.scroll.y;
            e->data.scroll.y = 0;
          }
          switch (e->data.scroll.x)
          { case -2: e->data.scroll.o.x -= (e->data.scroll.o.box.x1 - e->data.scroll.o.box.x0); break;
            case -1: e->data.scroll.o.x -= 64; break;
            case 1:  e->data.scroll.o.x += 64; break;
            case 2:  e->data.scroll.o.x += (e->data.scroll.o.box.x1 - e->data.scroll.o.box.x0); break;
          }
          switch (e->data.scroll.y)
          { case -2: e->data.scroll.o.y -= (e->data.scroll.o.box.y1 - e->data.scroll.o.box.y0); break;
            case -1: e->data.scroll.o.y -= 64; break;
            case 1:  e->data.scroll.o.y += 64; break;
            case 2:  e->data.scroll.o.y += (e->data.scroll.o.box.y1 - e->data.scroll.o.box.y0); break;
          }
          if (wimpt_complain (wimp_open_wind (&e->data.scroll.o)))
            return;
        }
      }
      if (eventCount == -1)
      { /* At time of writing, version 0.25 and up of the USBDriver has a "feature" that sends 5 scroll events per mouse wheel step */
        os_error *err = os_cli("RMEnsure USBDriver 0.25");
        /* If no error is generated by RMEnsure, the troublesome driver is present and we do need the fix */
        scrollFix = (err == NULL);
        eventCount = 0;
      }
      if (scrollFix)
      { eventCount++;
        ftracef1("scrollFix active. eventCount %d\n", eventCount);
        if (eventCount >=5)
          eventCount = 0;
      }
      break;

    case wimp_ECLOSE:
      ftracef0 ("Window close event\n");
      sprwindow_delete (window);
    break;

    case wimp_EPTRLEAVE:
      if (!read_only && window->data->sprite.sprite->needsnull)
        main_claim_idle (lastnullholder);
    break;

    case wimp_EPTRENTER:
      if (!read_only && window->data->sprite.sprite->needsnull)
        sprwindow_claim_idle_events (window);
    break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
      if (e->data.msg.hdr.action == wimp_MHELPREQUEST)
      { ftracef0 ("Help request on sprite window\n");
        main_help_message ("PntH2", e);
      }
      else if (!read_only)
      { char *name, *rgb, palfile [6*256 + 1] /*room for our palette data*/;
        int i, entries, size, palette [256] /*the palette itself*/, mode;
        BOOL old;

        mode = psprite_address (window->data->sprite.sprite)->mode;

        if (check_palette_type (xferrecv_checkinsert (&name), name))
        { /*Load the file if it's not too big.*/
          os_filestr file_str;

          file_str.action = 5 /*read catalogue info*/;
          file_str.name   = name;
          if (wimpt_complain (os_file (&file_str)) != NULL)
            break;

          if (file_str.action != 1)
          { file_str.loadaddr = file_str.action;
            file_str.action   = 19 /*report error*/;
            wimpt_complain (os_file (&file_str));
            break;
          }
          size = file_str.start;
          ftracef1 ("palette file size is %d\n", size);

          if (size > 6*256)
          { werr (FALSE, msgs_lookup ("PntE1"), name);
            break;
          }

          file_str.action = 16 /*load file*/;
          file_str.loadaddr = (int) palfile;
          file_str.execaddr = 0 /*load at R2*/;
          if (wimpt_complain (os_file (&file_str)) != NULL)
            break;

          ftracef0 ("Read palette\n");
        }
        else if (check_palette_type (xferrecv_checkimport (&size), NULL))
        { size = xferrecv_doimport (palfile, 6*256 + 1,
              &cant_extend_stack_buffer);
          ftracef1 ("Imported %d byte palette\n", size);
        }

        /*How many entries in the palette we just got?*/
        old = FALSE;
        switch (size)
        { case 6*2:
            entries = 2;
          break;

          case 6*4:
            entries = 4;
          break;

          case 60 /*Arthur 1.2 format*/:
            old = TRUE;
          /*fall through*/

          case 6*16:
          case 6*16 + 6*4 /*with mouse+border colours*/:
            entries = 16;
          break;

          case 6*256:
            entries = 256;
          break;

          default:
            werr (FALSE, msgs_lookup ("PntE1"));
            entries = 0;
          break;
        }
        if (entries == 0) break;

        /*Fix DF-300: check not a new format sprite.*/
        if ((unsigned) mode >= 256u)
        { werr (FALSE, msgs_lookup ("PntE1"));
          break;
        }

        ftracef1 ("that means we need a sprite with %d colours\n", entries);
        if (entries != 1 << (1 << bbc_modevar (mode, bbc_Log2BPP)))
        { werr (FALSE, msgs_lookup ("PntE1"));
          break;
        }

        xferrecv_insertfileok ();

        /*Copy the data out of the palette file*/
        rgb = !old? &palfile [3]: &palfile [0];
        for (i = 0; i < entries; i++)
        { palette [i] = *rgb << 8 | *(rgb + 1) << 16 | *(rgb + 2) << 24;
          rgb += !old? 6: 3;
        }

        menus_set_palette (window->data->sprite.sprite, entries, palette);
        ftracef0 ("palette loaded\n");
      }
    break;

    default:
      ftracef1 ("Sprite window event %d\n", e->e);
    break;
  }

  menus_insdel_frig ();
}

/*******************************************************************
 *                                                                 *
 *  Delete a sprite window with given sprite                       *
 *                                                                 *
 *******************************************************************/

void sprwindow_delete (main_window *window)

{ main_sprite_window *us, *beforeus;

  ftracef0 ("sprwindow_delete\n");
  ftracef1 ("sprwindow_delete: deleting main_window 0x%X\n", window);
  us = &window->data->sprite;

  ftracef1 ("sprwindow_delete: freeing title \"%s\"\n", us->title);
  m_FREE (us->title, 20);

  beforeus = /*(main_sprite_window *) &*/us->sprite->windows;
  while (beforeus != NULL && beforeus->link != us)
    beforeus = beforeus->link;

  if (beforeus != NULL)
    beforeus->link = us->link;
  else
    ftracef0 ("oh god a sprite window's gone walkies\n");

  /*If we are pointed at by the main_sprite for this sprite, set it to
    our successor.*/
  if (us->sprite->windows == us)
  { ftracef1 ("deleting the chain header main_sprite_window - "
        "setting sprite->windows to 0x%X\n", us->link);
    us->sprite->windows = us->link;
  }

  /* are we closing the last window on a sprite */
  if (us->sprite->windows == NULL)
  { ftracef0 ("closing the last window on a sprite\n");
    if (us->sprite->colourhandle != 0)
      colours_delete_window (us->sprite);

    if (toolwindow_current_tool == &tools_brushpaint)
      psprite_drop_translation ((main_ttab **) &us->sprite->toolspace [2]);
  }

  sprwindow_set_window_titles (us->sprite); /*there might not be any*/

  main_window_delete (window);
}

/***********************************************************************
 *                                                                     *
 *  Create a new sprite window with given sprite                       *
 *                                                                     *
 ***********************************************************************/

void sprwindow_new (main_sprite *sprite)

{ main_window *window;
  main_sprite_window *sprite_window;
  wimp_wind wind;
  wimp_openstr open_str;
  wimp_w w;
  sprite_info info;

  ftracef0 ("sprwindow_new\n");
  if ((window = m_ALLOC (sizeof (main_window))) == NULL)
  { main_NO_ROOM ("sprite window descriptor");
    return;
  }

  if ((sprite_window = m_ALLOC (sizeof (main_sprite_window))) == NULL)
  { main_NO_ROOM ("main_sprite_window");
    m_FREE (window, sizeof (main_window));
    return;
  }

  wind = sprwindow_template.t;

  psprite_read_size (sprite, &info);
  wind.ex.y1 = 0;
  wind.ex.y0 = -info.height*main_current_options.zoom.mul/
      main_current_options.zoom.div;
  wind.ex.x0 = 0;
  wind.ex.x1 = info.width*main_current_options.zoom.mul/
      main_current_options.zoom.div;
  main_allocate_position (&wind.box);
  wind.colours [wimp_WCWKAREABACK] = '\377';
  wind.titleflags = (wimp_iconflags) (wind.titleflags | wimp_INDIRECT);
  wind.flags = (wimp_wflags) (wind.flags | wimp_WSCROLL_R1); /* Enable scroll requests for mouse wheel */

  if ((wind.title.indirecttext.buffer = m_ALLOC (20)) == NULL)
  { m_FREE (sprite_window, sizeof (main_sprite_window));
    m_FREE (window, sizeof (main_window));
    main_NO_ROOM ("indirect title - sprite window");
    return;
  }
  wind.title.indirecttext.bufflen = 20;
  wind.title.indirecttext.validstring = 0;

  sprite_window->title = wind.title.indirecttext.buffer;

  if (!main_create_window (&wind, &w, &sprwindow_event_handler,
      window))
  { m_FREE (wind.title.indirecttext.buffer, 20);
    m_FREE (sprite_window, sizeof (main_sprite_window));
    m_FREE (window, sizeof (main_window));
    return;
  }

  sprite_window->link                = sprite->windows;
  sprite_window->window              = window;
  sprite_window->sprite              = sprite;
  sprite_window->blobsize.scale_xmul =
  sprite_window->blobsize.scale_ymul = main_current_options.zoom.mul;
  sprite_window->blobsize.scale_xdiv =
  sprite_window->blobsize.scale_ydiv = main_current_options.zoom.div;
  sprite_window->gridcol             = main_current_options.grid.show?
      main_current_options.grid.colour: 255;
  sprite_window->read_only           = !main_current_options.extended.on &&
      colours_count (sprite) > 256;

  sprite->windows = sprite_window;

  event_attachmenumaker (w, &menus_sprite_maker,
      &menus_sprite_handler, window);

  open_str.w = w;
  open_str.box = wind.box;
  open_str.behind = -1;
  open_str.x = 0;
  open_str.y = 0;
  wimpt_noerr (wimp_open_wind (&open_str));
  win_activeinc ();

  window->link = main_windows;
  main_windows = window;
  window->handle = w;
  window->tag = main_window_is_sprite;
  window->data = (main_info_block *) sprite_window;

  sprwindow_set_window_titles (sprite);
  sprwindow_set_work_extent (window, TRUE);
  main_check_position (window);

  if (main_current_options.colours.show_colours && !sprite_window->read_only)
    colours_create_window (sprite);

  /*Fix MED-xxxx: brush translation tables are only maintained for open
    windows, so create one now if necessary. J R C 26th Jul 1994*/
  if (sprite_window->link == NULL /*first window on this sprite*/)
  { if (toolwindow_current_tool == &tools_brushpaint &&
        tools_brushsprite_ptr != NULL)
      psprite_set_brush_translation (sprite);
  }     
}
@


4.8
log
@Various bugfixes. Improve sprite info dialog.
Detail:
  - Handling of currently selected foreground & background colour rewritten; colour is now stored as a 'main_colour' struct, in order to allow representation of alpha level, pixel colour/palette index (which must be 4 bytes for things like CMYK) and ECF index (previously encoded as negative colour values). Fixes crashes when editing RISC OS 5 32bpp ARGB sprites. Note that although the alpha level is now stored internally, and tools should mostly respect it, palette/colour picker limitations mean that only 0/255 is available when selecting colours.
  - "Select colour" code rewritten to decode all the new pixel formats correctly; colours_entry() now accepts a sprite mode word instead of a number-of-colours value
  - "Full info" display tweaked to give more information about the mask (now displays no mask, normal mask, alpha mask, alpha channel)
  - Sprite info dialog extended to display lots more information, including OS version compatibility
  - Fix sprite menu to disallow add/remove mask option if the sprite has a RISC OS 5 alpha channel
  - Fix ECF pattern that's used for the background of masked sprites to get black/white colour values from ColourTrans when in >8bpp modes, to ensure correct colours in new RISC OS 5 modes
  - Fix palette window to render ECF patterns correctly - when creating the sprite that shows the ECF pattern in the palette, psprite_setup_ecf() was failing to set its palette due to passing a sprite pointer to ColourTrans but setting the flags as if it was a sprite name
  - Fix sprwindow_redisplay() and sprwindow_invalidate() to refresh the display correctly when in full info mode; was previously assuming only one column of sprites visible
  - Fix sprites with alpha channels to have the mask ECF pattern plotted in the background
  Files changed:
  - Resources/UK/Messages, Resources/UK/Templates,fec, c/Colours, c/Main, c/Menus, c/PSprite, c/SprWindow, c/Tools, h/Colours, h/MenuD, h/PSprite, h/main
Admin:
  Tested on BB-xM
  Amongst others, fixes issue reported on forums with spritefile window not refreshing correctly when in full info display with multiple columns:
  http://www.riscosopen.org/forum/forums/8/topics/2146?page=5#posts-31272


Version 2.16. Tagged as 'Paint-2_16'
@
text
@d28 1
d62 1
d64 1
a64 1
/************************************+**
d105 67
d413 2
d439 1
d580 78
d876 1
@


4.7
log
@Clean up pass.
No functional changes, but it's now a consistent ball of spaghetti.
@
text
@d253 1
d255 4
a258 3
  { redraw.box.x0 = 0; redraw.box.x1 = 3*main_FILER_TextHeight;
    redraw.box.y1 = -sprite->spriteno*3*main_FILER_TextHeight;
    redraw.box.y0 = redraw.box.y1 - 3*main_FILER_TextHeight;
d261 18
a278 4
  { filersprite_x = curr.info.box.x1-curr.info.box.x0;
    if (filersprite_x < main_FILER_TotalWidth)
      filersprite_x = main_FILER_TotalWidth;
    filersprite_x /= main_FILER_TotalWidth;  /* no of sprites per line */
a279 10
    filersprite_y = sprite->spriteno/filersprite_x;
    filersprite_x = sprite->spriteno % filersprite_x;

    redraw.box.x0 = filersprite_x*main_FILER_TotalWidth +
        main_FILER_Border/2;
    redraw.box.x1 = redraw.box.x0+main_FILER_XSize;
    redraw.box.y1 =-(filersprite_y*main_FILER_TotalHeight +
        main_FILER_Border/2);
    redraw.box.y0 =  redraw.box.y1 - main_FILER_YSize;
  }
d290 15
d306 4
a309 3
    redraw.box.x0 = 0; redraw.box.x1 = 100000;
    redraw.box.y1 = -sprite->spriteno*3*main_FILER_TextHeight;
    redraw.box.y0 = redraw.box.y1 - 3*main_FILER_TextHeight;
d426 1
a426 1
        if (psprite_hasmask (sprite))
@


4.6
log
@Prune the plethora of targets a bit.
Spurious ';' after an if at line 2386 of c.Main deleted, something to do with scroll wheel support. Untested.
Refer to FileType_ using the filetypes header file.
Internationalised "Selection" when saving a sprite selection.
main_save_selection wasn't checking if fwrite() worked so never reported 'disc full'.
Turn on egg timer during main_save_selection().
Fix (de)selection bug when in full sprite info view, the 'spritesperrow' was being rounded down to zero, and unlike everywhere else it wasn't being adjusted back to a minimum of 1.

Version 2.03. Tagged as 'Paint-2_03'
@
text
@a67 1
/* The open parameter avoid getting two open requests in some circumstances */
d70 2
a71 1
{ wimp_wstate currinfo;
d206 1
a206 2
{
  ftracef0 ("sprwindow_swap_output_to_screen\n");
d226 1
a226 1
    wimpt_noerr (PaintLib_get_wind_info (&curr));
d251 1
a251 1
  wimpt_noerr (PaintLib_get_wind_info (&curr));
d384 1
a384 1
      wimpt_noerr (PaintLib_get_wind_info (&curr));
d609 1
a609 1
      ftracef1 ("Sprite window event %d\n",e->e);
@


4.5
log
@Fix abort when sorting the sprites by name and one or more sprite viewers
are open, also massively simplified it since the copying around of
main_sprite blocks was pointless - much simpler to just rejoin the linked
list leaving the data in place.
*Tidy up
 Delete awk.*, change to use central 'AwkVers' script.
 Delete h.types.
 Delete h.Paint, it's a duplicate of h.main.
 Delete writepixel, swap to using the one in RISCOS_Lib
 Retire 'h.fixes', switches collapsed, bugfixes proven after 18 years use.
 Cast away some warnings.
 Sprinkled in some consts, moved pointer qualifiers to get syntax colouring
 right.
 Remove local SWI defines, read from <swis.h> now.
 !MkInstall now installs into <Install$Dir>.Apps
*Little UI changes
 Make the colour number in the colour picker be in the right place vertically
 and correct horizontal position of 'T' and 'E' for ECFs.
 In the create new sprite dialogue box the 32k and 16M options are shaded
 when a palette is requested, this avoids the problem of selecting a deep
 colour mode (which trapped the radio icon in a shaded paletted selection).
 The 'Selection' menu is now shaded when there are zero sprites in the
 file
*Sprite filer
 Fix tiled main window fill to work in EX0 modes and not overwrite in EX2
 modes (was using the sprite's mode word not the current mode to deduce eigen
 factors), leading to odd chequer board areas not being redrawn.
 Refactored main_clear_background() to use stronger typing of RISC_OSLib
 rather than _swix where possible.
 A failure to get the Wimp pixel translation table now falls back to solid
 fill
 Double clicking on a sprite in the sprite file window no longer leaves it
 selected, to mimic the filer.
 Set DISPLAY_MARGIN to 0 to counter for the recent increase from 32 to 40
 of main_FILER_TextHeight
 Added 'Sort by size' after 'Sort by name'

Version 2.02. Tagged as 'Paint-2_02'
@
text
@d27 1
d191 2
a192 2
    os_swix1 (OS_ChangedBox+os_X, 2);
    os_swix1 (OS_ChangedBox+os_X, 1);          /* enable changed box calcs */
d336 1
a336 1
  if (type != 0xFED && type != -1)
d340 1
a340 1
  return type == 0xFED;
@


4.4
log
@Filename fixes for case-sensitive environments.  No functional changes.  First commit to ROOL CVS, hooray.

Version 2.00. Not tagged
@
text
@a45 3
#define MIN(a, b) ((a) < (b)? (a): (b))
#define MAX(a, b) ((a) > (b)? (a): (b))

d82 2
a83 2
  sinfo.height= sinfo.height* window->data->sprite.blobsize.scale_ymul /
                              window->data->sprite.blobsize.scale_ydiv;
d324 1
a324 1
static BOOL cant_extend_stack_buffer (char** b, int* s)
d332 1
a332 1
static BOOL Check_Palette_Type (int type, char *name)
d334 1
a334 1
{ ftracef0 ("Check_Palette_Type\n");
d377 2
a378 2
      sinfo.width  = sinfo.width* scale->scale_xmul/scale->scale_xdiv;
      sinfo.height = sinfo.height*scale->scale_ymul/scale->scale_ydiv;
d514 1
a514 1
        if (Check_Palette_Type (xferrecv_checkinsert (&name), name))
d545 1
a545 1
        else if (Check_Palette_Type (xferrecv_checkimport (&size), NULL))
@


4.3
log
@Fix to filename capitalisation clash for version 1.99.
Summary:
  Bugfix of version 1.98
Detail:
  * Show error message when dragging selection fails.
  * Sprite target area in spritefile window set to a minimum height
    of 64 units and minimum width of 64 units.
  * Moving brush now redrawn in the same place that it is updated.
  * Changed moving brush plotting from EOR to NOT to stop
    black in brushes not appearing.
  * Fixed situation where the moving text y position is different
    to plotted text y position at 1:1 scale.
  * Stopped text redrawing repeatedly at the same place. This makes
    single clicks when using EOR plotting always work as expected.
    (old bug)
  * fixed width of insert/delete display at 1:1 scale.
  * fixed ftrace calls left in from changes that cause the !Debug
    compilation to fail.
  * makefile: changed OBJSZ o.Paintlib and o.AltRename. Changed o. to  oz.
  * makefile: changed OBJSD o.Paintlib and o.AltRename. Changed o. to  od.
Admin:
 Tested on Iyonix RO5.10
 Programmer tested only.
Notes:
  Changed by Colin Granville

Version 1.99. Retagged as 'Paint-1_99'
@
text
@d38 7
a44 7
#include "menus.h"
#include "psprite.h"
#include "sprwindow.h"
#include "toolwindow.h"
#include "tools.h"
#include "colours.h"
#include "paintlib.h"
@


4.2
log
@Fix to filename capitalisation clash for version 1.98.
Summary:
  Changes to SpriteFile window to allow selections and
  sprite edit window changed to improve positioning accuracy.
Detail:
  * Wimp_EScroll event added to make wheelmouse work.
  * Tool rubber banding now snaps to pixel centres making location easier.
  * flickering of box stopped in move (hand) tool.
  * Bottom left of sprites used in painting aligned with grid and sprite plotted
    directly under moving version.
  * Text painting now plots under the moving version of the text.
  * copy, move and hand tools cancel dragging with Adjust.
  * SpriteFile window changed to allow selections using Select,Adjust or Drag.
  * Alt-Select/Adjust on name allows renaming of sprite.
  * TAB moves rename icon to next sprite.
  * Shift TAB moves rename icon to previous sprite
  * Ctrl-Return renames sprite and moves the rename icon to the
    next sprite.
 V2 changes
  * Rubber band rectangular boxes with 0 width or height drawn as a
   line so they don't disappear.
  * Parallelogram rubber band where all the points are in line drawn
    as a line so they don't disappear.
Admin:
  Tested on Iyonix RO5.10
  Programmer tested only.
Changed by:
  Colin Granville

Version 1.98. Retagged as 'Paint-1_98'
@
text
@d771 1
a771 1
  }
@


4.1
log
@Initial revision
@
text
@d44 1
d93 1
a93 1
  newext.box.y0 =-sinfo.height;
d206 1
a206 1
void sprwindow_swap_output_to_screen ()
d229 1
a229 1
    wimpt_noerr (wimp_get_wind_info (&curr));
d254 1
a254 1
  wimpt_noerr (wimp_get_wind_info (&curr));
d387 1
a387 1
      wimpt_noerr (wimp_get_wind_info (&curr));
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@
